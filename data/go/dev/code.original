func ( q * query ) Close ( ) { for _ , s := range q . matrix { putPointSlice ( s . Points ) } } 
func ( q * query ) Exec ( ctx context . Context ) * Result { if span := opentracing . SpanFromContext ( ctx ) ; span != nil { span . SetTag ( queryTag , q . stmt . String ( ) ) } res , warnings , err := q . ng . exec ( ctx , q ) return & Result { Err : err , Value : res , Warnings : warnings } } 
func contextDone ( ctx context . Context , env string ) error { if err := ctx . Err ( ) ; err != nil { return contextErr ( err , env ) } return nil } 
func NewEngine ( opts EngineOpts ) * Engine { if opts . Logger == nil { opts . Logger = log . NewNopLogger ( ) } metrics := & engineMetrics { currentQueries : prometheus . NewGauge ( prometheus . GaugeOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , } ) , maxConcurrentQueries : prometheus . NewGauge ( prometheus . GaugeOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , } ) , queryQueueTime : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , ConstLabels : prometheus . Labels { " " : " " } , } ) , queryPrepareTime : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , ConstLabels : prometheus . Labels { " " : " " } , } ) , queryInnerEval : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , ConstLabels : prometheus . Labels { " " : " " } , } ) , queryResultSort : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , ConstLabels : prometheus . Labels { " " : " " } , } ) , } metrics . maxConcurrentQueries . Set ( float64 ( opts . MaxConcurrent ) ) if opts . Reg != nil { opts . Reg . MustRegister ( metrics . currentQueries , metrics . maxConcurrentQueries , metrics . queryQueueTime , metrics . queryPrepareTime , metrics . queryInnerEval , metrics . queryResultSort , ) } return & Engine { gate : gate . New ( opts . MaxConcurrent ) , timeout : opts . Timeout , logger : opts . Logger , metrics : metrics , maxSamplesPerQuery : opts . MaxSamples , } } 
func ( ng * Engine ) NewInstantQuery ( q storage . Queryable , qs string , ts time . Time ) ( Query , error ) { expr , err := ParseExpr ( qs ) if err != nil { return nil , err } qry := ng . newQuery ( q , expr , ts , ts , 0 ) qry . q = qs return qry , nil } 
func ( ng * Engine ) NewRangeQuery ( q storage . Queryable , qs string , start , end time . Time , interval time . Duration ) ( Query , error ) { expr , err := ParseExpr ( qs ) if err != nil { return nil , err } if expr . Type ( ) != ValueTypeVector && expr . Type ( ) != ValueTypeScalar { return nil , errors . Errorf ( " " , documentedType ( expr . Type ( ) ) ) } qry := ng . newQuery ( q , expr , start , end , interval ) qry . q = qs return qry , nil } 
func ( ng * Engine ) exec ( ctx context . Context , q * query ) ( Value , storage . Warnings , error ) { ng . metrics . currentQueries . Inc ( ) defer ng . metrics . currentQueries . Dec ( ) ctx , cancel := context . WithTimeout ( ctx , ng . timeout ) q . cancel = cancel execSpanTimer , ctx := q . stats . GetSpanTimer ( ctx , stats . ExecTotalTime ) defer execSpanTimer . Finish ( ) queueSpanTimer , _ := q . stats . GetSpanTimer ( ctx , stats . ExecQueueTime , ng . metrics . queryQueueTime ) if err := ng . gate . Start ( ctx ) ; err != nil { return nil , nil , contextErr ( err , " " ) } defer ng . gate . Done ( ) queueSpanTimer . Finish ( ) const env = " " evalSpanTimer , ctx := q . stats . GetSpanTimer ( ctx , stats . EvalTotalTime ) defer evalSpanTimer . Finish ( ) } switch s := q . Statement ( ) . ( type ) { case * EvalStmt : return ng . execEvalStmt ( ctx , q , s ) case testStmt : return nil , nil , s ( ctx ) } panic ( errors . Errorf ( " " , q . Statement ( ) ) ) } 
func ( ng * Engine ) execEvalStmt ( ctx context . Context , query * query , s * EvalStmt ) ( Value , storage . Warnings , error ) { prepareSpanTimer , ctxPrepare := query . stats . GetSpanTimer ( ctx , stats . QueryPreparationTime , ng . metrics . queryPrepareTime ) querier , warnings , err := ng . populateSeries ( ctxPrepare , query . queryable , s ) prepareSpanTimer . Finish ( ) } if err != nil { return nil , warnings , err } evalSpanTimer , ctxInnerEval := query . stats . GetSpanTimer ( ctx , stats . InnerEvalTime , ng . metrics . queryInnerEval ) evaluator := & evaluator { startTimestamp : start , endTimestamp : start , interval : 1 , ctx : ctxInnerEval , maxSamples : ng . maxSamplesPerQuery , defaultEvalInterval : GetDefaultEvaluationInterval ( ) , logger : ng . logger , } val , err := evaluator . Eval ( s . Expr ) if err != nil { return nil , warnings , err } evalSpanTimer . Finish ( ) mat , ok := val . ( Matrix ) if ! ok { panic ( errors . Errorf ( " " , val . Type ( ) ) ) } query . matrix = mat switch s . Expr . Type ( ) { case ValueTypeVector : for i , s := range mat { } return vector , warnings , nil case ValueTypeScalar : return Scalar { V : mat [ 0 ] . Points [ 0 ] . V , T : start } , warnings , nil case ValueTypeMatrix : return mat , warnings , nil default : panic ( errors . Errorf ( " " , s . Expr . Type ( ) ) ) } } val , err := evaluator . Eval ( s . Expr ) if err != nil { return nil , warnings , err } evalSpanTimer . Finish ( ) mat , ok := val . ( Matrix ) if ! ok { panic ( errors . Errorf ( " " , val . Type ( ) ) ) } query . matrix = mat if err := contextDone ( ctx , " " ) ; err != nil { return nil , warnings , err } sort . Sort ( mat ) sortSpanTimer . Finish ( ) return mat , warnings , nil } 
func ( ng * Engine ) cumulativeSubqueryOffset ( path [ ] Node ) time . Duration { var subqOffset time . Duration for _ , node := range path { switch n := node . ( type ) { case * SubqueryExpr : subqOffset += n . Range + n . Offset } } return subqOffset } 
func extractFuncFromPath ( p [ ] Node ) string { if len ( p ) == 0 { return " " } switch n := p [ len ( p ) - 1 ] . ( type ) { case * AggregateExpr : return n . Op . String ( ) case * Call : return n . Func . Name case * BinaryExpr : } return extractFuncFromPath ( p [ : len ( p ) - 1 ] ) } 
func ( ev * evaluator ) errorf ( format string , args ... interface { } ) { ev . error ( errors . Errorf ( format , args ... ) ) } 
func ( ev * evaluator ) recover ( errp * error ) { e := recover ( ) if e == nil { return } if err , ok := e . ( runtime . Error ) ; ok { buf = buf [ : runtime . Stack ( buf , false ) ] level . Error ( ev . logger ) . Log ( " " , " " , " " , e , " " , string ( buf ) ) * errp = errors . Wrap ( err , " " ) } else { * errp = e . ( error ) } } 
func ( enh * EvalNodeHelper ) dropMetricName ( l labels . Labels ) labels . Labels { if enh . dmn == nil { enh . dmn = make ( map [ uint64 ] labels . Labels , len ( enh . out ) ) } h := l . Hash ( ) ret , ok := enh . dmn [ h ] if ok { return ret } ret = dropMetricName ( l ) enh . dmn [ h ] = ret return ret } 
func ( enh * EvalNodeHelper ) signatureFunc ( on bool , names ... string ) func ( labels . Labels ) uint64 { if enh . sigf == nil { enh . sigf = make ( map [ uint64 ] uint64 , len ( enh . out ) ) } f := signatureFunc ( on , names ... ) return func ( l labels . Labels ) uint64 { h := l . Hash ( ) ret , ok := enh . sigf [ h ] if ok { return ret } ret = f ( l ) enh . sigf [ h ] = ret return ret } } 
func ( ev * evaluator ) rangeEval ( f func ( [ ] Value , * EvalNodeHelper ) Vector , exprs ... Expr ) Matrix { numSteps := int ( ( ev . endTimestamp - ev . startTimestamp ) / ev . interval ) + 1 matrixes := make ( [ ] Matrix , len ( exprs ) ) origMatrixes := make ( [ ] Matrix , len ( exprs ) ) originalNumSamples := ev . currentSamples for i , e := range exprs { copy ( origMatrixes [ i ] , matrixes [ i ] ) } } vectors := make ( [ ] Vector , len ( exprs ) ) args := make ( [ ] Value , len ( exprs ) ) for i := range exprs { vectors [ i ] = make ( Vector , 0 , len ( matrixes [ i ] ) ) if len ( matrixes [ i ] ) > biggestLen { biggestLen = len ( matrixes [ i ] ) } } enh := & EvalNodeHelper { out : make ( Vector , 0 , biggestLen ) } seriess := make ( map [ uint64 ] Series , biggestLen ) tempNumSamples := ev . currentSamples for ts := ev . startTimestamp ; ts <= ev . endTimestamp ; ts += ev . interval { if err := contextDone ( ev . ctx , " " ) ; err != nil { ev . error ( err ) } for si , series := range matrixes [ i ] { for _ , point := range series . Points { if point . T == ts { if ev . currentSamples < ev . maxSamples { vectors [ i ] = append ( vectors [ i ] , Sample { Metric : series . Metric , Point : point } ) ev . currentSamples ++ } else { ev . error ( ErrTooManySamples ( env ) ) } } break } } args [ i ] = vectors [ i ] } result := f ( args , enh ) if result . ContainsSameLabelset ( ) { ev . errorf ( " " ) } enh . out = result [ : 0 ] ev . currentSamples += len ( result ) if ev . currentSamples > ev . maxSamples { ev . error ( ErrTooManySamples ( env ) ) } for i , s := range result { s . Point . T = ts mat [ i ] = Series { Metric : s . Metric , Points : [ ] Point { s . Point } } } ev . currentSamples = originalNumSamples + mat . TotalSamples ( ) return mat } ss , ok := seriess [ h ] if ! ok { ss = Series { Metric : sample . Metric , Points : getPointSlice ( numSteps ) , } } sample . Point . T = ts ss . Points = append ( ss . Points , sample . Point ) seriess [ h ] = ss } } } } for _ , ss := range seriess { mat = append ( mat , ss ) } ev . currentSamples = originalNumSamples + mat . TotalSamples ( ) return mat } 
func ( ev * evaluator ) evalSubquery ( subq * SubqueryExpr ) * MatrixSelector { val := ev . eval ( subq ) . ( Matrix ) ms := & MatrixSelector { Range : subq . Range , Offset : subq . Offset , series : make ( [ ] storage . Series , 0 , len ( val ) ) , } for _ , s := range val { ms . series = append ( ms . series , NewStorageSeries ( s ) ) } return ms } 
func ( ev * evaluator ) eval ( expr Expr ) Value { } numSteps := int ( ( ev . endTimestamp - ev . startTimestamp ) / ev . interval ) + 1 switch e := expr . ( type ) { case * AggregateExpr : if s , ok := e . Param . ( * StringLiteral ) ; ok { return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . aggregation ( e . Op , e . Grouping , e . Without , s . Val , v [ 0 ] . ( Vector ) , enh ) } , e . Expr ) } return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { var param float64 if e . Param != nil { param = v [ 0 ] . ( Vector ) [ 0 ] . V } return ev . aggregation ( e . Op , e . Grouping , e . Without , param , v [ 1 ] . ( Vector ) , enh ) } , e . Param , e . Expr ) case * Call : if e . Func . Name == " " { if ok { return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return e . Func . Call ( [ ] Value { ev . vectorSelector ( vs , enh . ts ) } , e . Args , enh ) } ) } } var matrixArg bool for i , a := range e . Args { if _ , ok := a . ( * MatrixSelector ) ; ok { matrixArgIndex = i matrixArg = true break } matrixArg = true break } } if ! matrixArg { } , e . Args ... ) } inArgs := make ( [ ] Value , len ( e . Args ) ) otherInArgs := make ( [ ] Vector , len ( e . Args ) ) for i , e := range e . Args { if i != matrixArgIndex { otherArgs [ i ] = ev . eval ( e ) . ( Matrix ) otherInArgs [ i ] = Vector { Sample { } } inArgs [ i ] = otherInArgs [ i ] } } sel := e . Args [ matrixArgIndex ] . ( * MatrixSelector ) checkForSeriesSetExpansion ( ev . ctx , sel ) mat := make ( Matrix , 0 , len ( sel . series ) ) offset := durationMilliseconds ( sel . Offset ) selRange := durationMilliseconds ( sel . Range ) stepRange := selRange if stepRange > ev . interval { stepRange = ev . interval } inMatrix := make ( Matrix , 1 ) inArgs [ matrixArgIndex ] = inMatrix enh := & EvalNodeHelper { out : make ( Vector , 0 , 1 ) } for i , s := range sel . series { points = points [ : 0 ] it . Reset ( s . Iterator ( ) ) ss := Series { inMatrix [ 0 ] . Metric = sel . series [ i ] . Labels ( ) for ts , step := ev . startTimestamp , - 1 ; ts <= ev . endTimestamp ; ts += ev . interval { step ++ } } maxt := ts - offset mint := maxt - selRange if len ( points ) == 0 { continue } inMatrix [ 0 ] . Points = points enh . ts = ts enh . out = outVec [ : 0 ] if len ( outVec ) > 0 { ss . Points = append ( ss . Points , Point { V : outVec [ 0 ] . Point . V , T : ts } ) } } if len ( ss . Points ) > 0 { if ev . currentSamples < ev . maxSamples { mat = append ( mat , ss ) ev . currentSamples += len ( ss . Points ) } else { ev . error ( ErrTooManySamples ( env ) ) } } } if mat . ContainsSameLabelset ( ) { ev . errorf ( " " ) } putPointSlice ( points ) return mat case * ParenExpr : return ev . eval ( e . Expr ) case * UnaryExpr : mat := ev . eval ( e . Expr ) . ( Matrix ) if e . Op == ItemSUB { for i := range mat { mat [ i ] . Metric = dropMetricName ( mat [ i ] . Metric ) for j := range mat [ i ] . Points { mat [ i ] . Points [ j ] . V = - mat [ i ] . Points [ j ] . V } } if mat . ContainsSameLabelset ( ) { ev . errorf ( " " ) } } return mat case * BinaryExpr : switch lt , rt := e . LHS . Type ( ) , e . RHS . Type ( ) ; { case lt == ValueTypeScalar && rt == ValueTypeScalar : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { val := scalarBinop ( e . Op , v [ 0 ] . ( Vector ) [ 0 ] . Point . V , v [ 1 ] . ( Vector ) [ 0 ] . Point . V ) return append ( enh . out , Sample { Point : Point { V : val } } ) } , e . LHS , e . RHS ) case lt == ValueTypeVector && rt == ValueTypeVector : switch e . Op { case ItemLAND : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorAnd ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . VectorMatching , enh ) } , e . LHS , e . RHS ) case ItemLOR : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorOr ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . VectorMatching , enh ) } , e . LHS , e . RHS ) case ItemLUnless : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorUnless ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . VectorMatching , enh ) } , e . LHS , e . RHS ) default : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorBinop ( e . Op , v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . VectorMatching , e . ReturnBool , enh ) } , e . LHS , e . RHS ) } case lt == ValueTypeVector && rt == ValueTypeScalar : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorscalarBinop ( e . Op , v [ 0 ] . ( Vector ) , Scalar { V : v [ 1 ] . ( Vector ) [ 0 ] . Point . V } , false , e . ReturnBool , enh ) } , e . LHS , e . RHS ) case lt == ValueTypeScalar && rt == ValueTypeVector : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return ev . VectorscalarBinop ( e . Op , v [ 1 ] . ( Vector ) , Scalar { V : v [ 0 ] . ( Vector ) [ 0 ] . Point . V } , true , e . ReturnBool , enh ) } , e . LHS , e . RHS ) } case * NumberLiteral : return ev . rangeEval ( func ( v [ ] Value , enh * EvalNodeHelper ) Vector { return append ( enh . out , Sample { Point : Point { V : e . Val } } ) } ) case * VectorSelector : checkForSeriesSetExpansion ( ev . ctx , e ) mat := make ( Matrix , 0 , len ( e . series ) ) it := storage . NewBuffer ( durationMilliseconds ( LookbackDelta ) ) for i , s := range e . series { it . Reset ( s . Iterator ( ) ) ss := Series { Metric : e . series [ i ] . Labels ( ) , Points : getPointSlice ( numSteps ) , } for ts := ev . startTimestamp ; ts <= ev . endTimestamp ; ts += ev . interval { _ , v , ok := ev . vectorSelectorSingle ( it , e , ts ) if ok { if ev . currentSamples < ev . maxSamples { ss . Points = append ( ss . Points , Point { V : v , T : ts } ) ev . currentSamples ++ } else { ev . error ( ErrTooManySamples ( env ) ) } } } if len ( ss . Points ) > 0 { mat = append ( mat , ss ) } } return mat case * MatrixSelector : if ev . startTimestamp != ev . endTimestamp { panic ( errors . New ( " " ) ) } return ev . matrixSelector ( e ) case * SubqueryExpr : offsetMillis := durationToInt64Millis ( e . Offset ) rangeMillis := durationToInt64Millis ( e . Range ) newEv := & evaluator { endTimestamp : ev . endTimestamp - offsetMillis , interval : ev . defaultEvalInterval , ctx : ev . ctx , currentSamples : ev . currentSamples , maxSamples : ev . maxSamples , defaultEvalInterval : ev . defaultEvalInterval , logger : ev . logger , } if e . Step != 0 { newEv . interval = durationToInt64Millis ( e . Step ) } if newEv . startTimestamp < ( ev . startTimestamp - offsetMillis - rangeMillis ) { newEv . startTimestamp += newEv . interval } res := newEv . eval ( e . Expr ) ev . currentSamples = newEv . currentSamples return res } panic ( errors . Errorf ( " " , expr ) ) } 
func ( ev * evaluator ) vectorSelector ( node * VectorSelector , ts int64 ) Vector { checkForSeriesSetExpansion ( ev . ctx , node ) var ( vec = make ( Vector , 0 , len ( node . series ) ) ) it := storage . NewBuffer ( durationMilliseconds ( LookbackDelta ) ) for i , s := range node . series { it . Reset ( s . Iterator ( ) ) t , v , ok := ev . vectorSelectorSingle ( it , node , ts ) if ok { vec = append ( vec , Sample { Metric : node . series [ i ] . Labels ( ) , Point : Point { V : v , T : t } , } ) ev . currentSamples ++ } if ev . currentSamples >= ev . maxSamples { ev . error ( ErrTooManySamples ( env ) ) } } return vec } 
func ( ev * evaluator ) vectorSelectorSingle ( it * storage . BufferedSeriesIterator , node * VectorSelector , ts int64 ) ( int64 , float64 , bool ) { refTime := ts - durationMilliseconds ( node . Offset ) var t int64 var v float64 ok := it . Seek ( refTime ) if ! ok { if it . Err ( ) != nil { ev . error ( it . Err ( ) ) } } if ok { t , v = it . Values ( ) } if ! ok || t > refTime { t , v , ok = it . PeekBack ( 1 ) if ! ok || t < refTime - durationMilliseconds ( LookbackDelta ) { return 0 , 0 , false } } if value . IsStaleNaN ( v ) { return 0 , 0 , false } return t , v , true } 
func ( ev * evaluator ) matrixSelector ( node * MatrixSelector ) Matrix { checkForSeriesSetExpansion ( ev . ctx , node ) var ( offset = durationMilliseconds ( node . Offset ) maxt = ev . startTimestamp - offset mint = maxt - durationMilliseconds ( node . Range ) matrix = make ( Matrix , 0 , len ( node . series ) ) ) it := storage . NewBuffer ( durationMilliseconds ( node . Range ) ) for i , s := range node . series { if err := contextDone ( ev . ctx , " " ) ; err != nil { ev . error ( err ) } it . Reset ( s . Iterator ( ) ) ss := Series { Metric : node . series [ i ] . Labels ( ) , } ss . Points = ev . matrixIterSlice ( it , mint , maxt , getPointSlice ( 16 ) ) if len ( ss . Points ) > 0 { matrix = append ( matrix , ss ) } else { putPointSlice ( ss . Points ) } } return matrix } 
func ( ev * evaluator ) matrixIterSlice ( it * storage . BufferedSeriesIterator , mint , maxt int64 , out [ ] Point ) [ ] Point { if len ( out ) > 0 && out [ len ( out ) - 1 ] . T >= mint { for drop = 0 ; out [ drop ] . T < mint ; drop ++ { } copy ( out , out [ drop : ] ) out = out [ : len ( out ) - drop ] } else { out = out [ : 0 ] } ok := it . Seek ( maxt ) if ! ok { if it . Err ( ) != nil { ev . error ( it . Err ( ) ) } } buf := it . Buffer ( ) for buf . Next ( ) { t , v := buf . At ( ) if value . IsStaleNaN ( v ) { continue } } out = append ( out , Point { T : t , V : v } ) ev . currentSamples ++ } } if t == maxt && ! value . IsStaleNaN ( v ) { if ev . currentSamples >= ev . maxSamples { ev . error ( ErrTooManySamples ( env ) ) } out = append ( out , Point { T : t , V : v } ) ev . currentSamples ++ } } return out } 
func ( ev * evaluator ) VectorBinop ( op ItemType , lhs , rhs Vector , matching * VectorMatching , returnBool bool , enh * EvalNodeHelper ) Vector { if matching . Card == CardManyToMany { panic ( " " ) } sigf := enh . signatureFunc ( matching . On , matching . MatchingLabels ... ) } } else { for k := range enh . rightSigs { delete ( enh . rightSigs , k ) } } rightSigs := enh . rightSigs if matching . Card == CardOneToMany { oneSide = " " } matchedLabels := rs . Metric . MatchLabels ( matching . On , matching . MatchingLabels ... ) } rightSigs [ sig ] = rs } } else { for k := range enh . matchedSigs { delete ( enh . matchedSigs , k ) } } matchedSigs := enh . matchedSigs rs , found := rightSigs [ sig ] if ! found { continue } if matching . Card == CardOneToMany { vl , vr = vr , vl } value , keep := vectorElemBinop ( op , vl , vr ) if returnBool { if keep { value = 1.0 } else { value = 0.0 } } else if ! keep { continue } metric := resultMetric ( ls . Metric , rs . Metric , op , matching , enh ) insertedSigs , exists := matchedSigs [ sig ] if matching . Card == CardOneToOne { if exists { ev . errorf ( " " ) } matchedSigs [ sig ] = nil } else { if ! exists { insertedSigs = map [ uint64 ] struct { } { } matchedSigs [ sig ] = insertedSigs } else if _ , duplicate := insertedSigs [ insertSig ] ; duplicate { ev . errorf ( " " ) } insertedSigs [ insertSig ] = struct { } { } } enh . out = append ( enh . out , Sample { Metric : metric , Point : Point { V : value } , } ) } return enh . out } 
func signatureFunc ( on bool , names ... string ) func ( labels . Labels ) uint64 { } return func ( lset labels . Labels ) uint64 { return lset . HashWithoutLabels ( names ... ) } } 
func resultMetric ( lhs , rhs labels . Labels , op ItemType , matching * VectorMatching , enh * EvalNodeHelper ) labels . Labels { if enh . resultMetric == nil { enh . resultMetric = make ( map [ uint64 ] labels . Labels , len ( enh . out ) ) } h := ( lh ^ rhs . Hash ( ) ) + lh if ret , ok := enh . resultMetric [ h ] ; ok { return ret } lb := labels . NewBuilder ( lhs ) if shouldDropMetricName ( op ) { lb . Del ( labels . MetricName ) } if matching . Card == CardOneToOne { if matching . On { Outer : for _ , l := range lhs { for _ , n := range matching . MatchingLabels { if l . Name == n { continue Outer } } lb . Del ( l . Name ) } } else { lb . Del ( matching . MatchingLabels ... ) } } for _ , ln := range matching . Include { } else { lb . Del ( ln ) } } ret := lb . Labels ( ) enh . resultMetric [ h ] = ret return ret } 
func ( ev * evaluator ) VectorscalarBinop ( op ItemType , lhs Vector , rhs Scalar , swap , returnBool bool , enh * EvalNodeHelper ) Vector { for _ , lhsSample := range lhs { lv , rv := lhsSample . V , rhs . V } value , keep := vectorElemBinop ( op , lv , rv ) } if returnBool { if keep { value = 1.0 } else { value = 0.0 } keep = true } if keep { lhsSample . V = value if shouldDropMetricName ( op ) || returnBool { lhsSample . Metric = enh . dropMetricName ( lhsSample . Metric ) } enh . out = append ( enh . out , lhsSample ) } } return enh . out } 
func scalarBinop ( op ItemType , lhs , rhs float64 ) float64 { switch op { case ItemADD : return lhs + rhs case ItemSUB : return lhs - rhs case ItemMUL : return lhs * rhs case ItemDIV : return lhs / rhs case ItemPOW : return math . Pow ( lhs , rhs ) case ItemMOD : return math . Mod ( lhs , rhs ) case ItemEQL : return btos ( lhs == rhs ) case ItemNEQ : return btos ( lhs != rhs ) case ItemGTR : return btos ( lhs > rhs ) case ItemLSS : return btos ( lhs < rhs ) case ItemGTE : return btos ( lhs >= rhs ) case ItemLTE : return btos ( lhs <= rhs ) } panic ( errors . Errorf ( " " , op ) ) } 
func ( ev * evaluator ) aggregation ( op ItemType , grouping [ ] string , without bool , param interface { } , vec Vector , enh * EvalNodeHelper ) Vector { result := map [ uint64 ] * groupedAggregation { } var k int64 if op == ItemTopK || op == ItemBottomK { f := param . ( float64 ) if ! convertibleToInt64 ( f ) { ev . errorf ( " " , f ) } k = int64 ( f ) if k < 1 { return Vector { } } } var q float64 if op == ItemQuantile { q = param . ( float64 ) } var valueLabel string if op == ItemCountValues { valueLabel = param . ( string ) if ! model . LabelName ( valueLabel ) . IsValid ( ) { ev . errorf ( " " , valueLabel ) } if ! without { grouping = append ( grouping , valueLabel ) } } for _ , s := range vec { metric := s . Metric if op == ItemCountValues { lb := labels . NewBuilder ( metric ) lb . Set ( valueLabel , strconv . FormatFloat ( s . V , 'f' , - 1 , 64 ) ) metric = lb . Labels ( ) } var ( groupingKey uint64 ) if without { groupingKey = metric . HashWithoutLabels ( grouping ... ) } else { groupingKey = metric . HashForLabels ( grouping ... ) } group , ok := result [ groupingKey ] if without { lb := labels . NewBuilder ( metric ) lb . Del ( grouping ... ) lb . Del ( labels . MetricName ) m = lb . Labels ( ) } else { m = make ( labels . Labels , 0 , len ( grouping ) ) for _ , l := range metric { for _ , n := range grouping { if l . Name == n { m = append ( m , l ) break } } } sort . Sort ( m ) } result [ groupingKey ] = & groupedAggregation { labels : m , value : s . V , mean : s . V , groupCount : 1 , } inputVecLen := int64 ( len ( vec ) ) resultSize := k if k > inputVecLen { resultSize = inputVecLen } if op == ItemStdvar || op == ItemStddev { result [ groupingKey ] . value = 0.0 } else if op == ItemTopK || op == ItemQuantile { result [ groupingKey ] . heap = make ( vectorByValueHeap , 0 , resultSize ) heap . Push ( & result [ groupingKey ] . heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } else if op == ItemBottomK { result [ groupingKey ] . reverseHeap = make ( vectorByReverseValueHeap , 0 , resultSize ) heap . Push ( & result [ groupingKey ] . reverseHeap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } continue } switch op { case ItemSum : group . value += s . V case ItemAvg : group . groupCount ++ group . mean += ( s . V - group . mean ) / float64 ( group . groupCount ) case ItemMax : if group . value < s . V || math . IsNaN ( group . value ) { group . value = s . V } case ItemMin : if group . value > s . V || math . IsNaN ( group . value ) { group . value = s . V } case ItemCount , ItemCountValues : group . groupCount ++ case ItemStdvar , ItemStddev : group . groupCount ++ delta := s . V - group . mean group . mean += delta / float64 ( group . groupCount ) group . value += delta * ( s . V - group . mean ) case ItemTopK : if int64 ( len ( group . heap ) ) < k || group . heap [ 0 ] . V < s . V || math . IsNaN ( group . heap [ 0 ] . V ) { if int64 ( len ( group . heap ) ) == k { heap . Pop ( & group . heap ) } heap . Push ( & group . heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } case ItemBottomK : if int64 ( len ( group . reverseHeap ) ) < k || group . reverseHeap [ 0 ] . V > s . V || math . IsNaN ( group . reverseHeap [ 0 ] . V ) { if int64 ( len ( group . reverseHeap ) ) == k { heap . Pop ( & group . reverseHeap ) } heap . Push ( & group . reverseHeap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } case ItemQuantile : group . heap = append ( group . heap , s ) default : panic ( errors . Errorf ( " " , op ) ) } } case ItemCount , ItemCountValues : aggr . value = float64 ( aggr . groupCount ) case ItemStdvar : aggr . value = aggr . value / float64 ( aggr . groupCount ) case ItemStddev : aggr . value = math . Sqrt ( aggr . value / float64 ( aggr . groupCount ) ) case ItemTopK : for _ , v := range aggr . heap { enh . out = append ( enh . out , Sample { Metric : v . Metric , Point : Point { V : v . V } , } ) } continue case ItemBottomK : for _ , v := range aggr . reverseHeap { enh . out = append ( enh . out , Sample { Metric : v . Metric , Point : Point { V : v . V } , } ) } continue case ItemQuantile : aggr . value = quantile ( q , aggr . heap ) default : enh . out = append ( enh . out , Sample { Metric : aggr . labels , Point : Point { V : aggr . value } , } ) } return enh . out } 
func shouldDropMetricName ( op ItemType ) bool { switch op { case ItemADD , ItemSUB , ItemDIV , ItemMUL , ItemPOW , ItemMOD : return true default : return false } } 
func NewEndpoints ( l log . Logger , svc , eps , pod cache . SharedInformer ) * Endpoints { if l == nil { l = log . NewNopLogger ( ) } e := & Endpoints { logger : l , endpointsInf : eps , endpointsStore : eps . GetStore ( ) , serviceInf : svc , serviceStore : svc . GetStore ( ) , podInf : pod , podStore : pod . GetStore ( ) , queue : workqueue . NewNamed ( " " ) , } e . endpointsInf . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , } ) serviceUpdate := func ( o interface { } ) { svc , err := convertToService ( o ) if err != nil { level . Error ( e . logger ) . Log ( " " , " " , " " , err ) return } ep := & apiv1 . Endpoints { } ep . Namespace = svc . Namespace ep . Name = svc . Name obj , exists , err := e . endpointsStore . Get ( ep ) if exists && err == nil { e . enqueue ( obj . ( * apiv1 . Endpoints ) ) } if err != nil { level . Error ( e . logger ) . Log ( " " , " " , " " , err ) } } e . serviceInf . AddEventHandler ( cache . ResourceEventHandlerFuncs { serviceUpdate ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) serviceUpdate ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) serviceUpdate ( o ) } , } ) return e } 
func ( e * Endpoints ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer e . queue . ShutDown ( ) if ! cache . WaitForCacheSync ( ctx . Done ( ) , e . endpointsInf . HasSynced , e . serviceInf . HasSynced , e . podInf . HasSynced ) { level . Error ( e . logger ) . Log ( " " , " " ) return } go func ( ) { for e . process ( ctx , ch ) { } } ( ) } 
func funcTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return Vector { Sample { Point : Point { V : float64 ( enh . ts ) / 1000 , } } } } 
func extrapolatedRate ( vals [ ] Value , args Expressions , enh * EvalNodeHelper , isCounter bool , isRate bool ) Vector { ms := args [ 0 ] . ( * MatrixSelector ) var ( matrix = vals [ 0 ] . ( Matrix ) rangeStart = enh . ts - durationMilliseconds ( ms . Range + ms . Offset ) rangeEnd = enh . ts - durationMilliseconds ( ms . Offset ) ) for _ , samples := range matrix { } var ( counterCorrection float64 lastValue float64 ) for _ , sample := range samples . Points { if isCounter && sample . V < lastValue { counterCorrection += lastValue } lastValue = sample . V } resultValue := lastValue - samples . Points [ 0 ] . V + counterCorrection durationToEnd := float64 ( rangeEnd - samples . Points [ len ( samples . Points ) - 1 ] . T ) / 1000 sampledInterval := float64 ( samples . Points [ len ( samples . Points ) - 1 ] . T - samples . Points [ 0 ] . T ) / 1000 averageDurationBetweenSamples := sampledInterval / float64 ( len ( samples . Points ) - 1 ) if isCounter && resultValue > 0 && samples . Points [ 0 ] . V >= 0 { if durationToZero < durationToStart { durationToStart = durationToZero } } extrapolateToInterval := sampledInterval if durationToStart < extrapolationThreshold { extrapolateToInterval += durationToStart } else { extrapolateToInterval += averageDurationBetweenSamples / 2 } if durationToEnd < extrapolationThreshold { extrapolateToInterval += durationToEnd } else { extrapolateToInterval += averageDurationBetweenSamples / 2 } resultValue = resultValue * ( extrapolateToInterval / sampledInterval ) if isRate { resultValue = resultValue / ms . Range . Seconds ( ) } enh . out = append ( enh . out , Sample { Point : Point { V : resultValue } , } ) } return enh . out } 
func funcDelta ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return extrapolatedRate ( vals , args , enh , false , false ) } 
func funcRate ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return extrapolatedRate ( vals , args , enh , true , true ) } 
func funcIncrease ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return extrapolatedRate ( vals , args , enh , true , false ) } 
func funcIrate ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return instantValue ( vals , enh . out , true ) } 
func funcIdelta ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return instantValue ( vals , enh . out , false ) } 
func calcTrendValue ( i int , sf , tf , s0 , s1 , b float64 ) float64 { if i == 0 { return b } x := tf * ( s1 - s0 ) y := ( 1 - tf ) * b return x + y } 
func funcHoltWinters ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { mat := vals [ 0 ] . ( Matrix ) } if tf <= 0 || tf >= 1 { panic ( errors . Errorf ( " " , tf ) ) } var l int for _ , samples := range mat { l = len ( samples . Points ) } var s0 , s1 , b float64 b = samples . Points [ 1 ] . V - samples . Points [ 0 ] . V for i := 1 ; i < l ; i ++ { y = ( 1 - sf ) * ( s1 + b ) s0 , s1 = s1 , x + y } enh . out = append ( enh . out , Sample { Point : Point { V : s1 } , } ) } return enh . out } 
func funcSort ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { sort . Sort ( sort . Reverse ( byValueSorter ) ) return Vector ( byValueSorter ) } 
func funcSortDesc ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { sort . Sort ( sort . Reverse ( byValueSorter ) ) return Vector ( byValueSorter ) } 
func funcClampMax ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { vec := vals [ 0 ] . ( Vector ) max := vals [ 1 ] . ( Vector ) [ 0 ] . Point . V for _ , el := range vec { enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : math . Min ( max , el . V ) } , } ) } return enh . out } 
func funcClampMin ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { vec := vals [ 0 ] . ( Vector ) min := vals [ 1 ] . ( Vector ) [ 0 ] . Point . V for _ , el := range vec { enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : math . Max ( min , el . V ) } , } ) } return enh . out } 
func funcRound ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { vec := vals [ 0 ] . ( Vector ) if len ( args ) >= 2 { toNearest = vals [ 1 ] . ( Vector ) [ 0 ] . Point . V } for _ , el := range vec { v := math . Floor ( el . V * toNearestInverse + 0.5 ) / toNearestInverse enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : v } , } ) } return enh . out } 
func funcScalar ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { v := vals [ 0 ] . ( Vector ) if len ( v ) != 1 { return append ( enh . out , Sample { Point : Point { V : math . NaN ( ) } , } ) } return append ( enh . out , Sample { Point : Point { V : v [ 0 ] . V } , } ) } 
func funcCountOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return aggrOverTime ( vals , enh , func ( values [ ] Point ) float64 { return float64 ( len ( values ) ) } ) } 
func funcMaxOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return aggrOverTime ( vals , enh , func ( values [ ] Point ) float64 { max := values [ 0 ] . V for _ , v := range values { if v . V > max || math . IsNaN ( max ) { max = v . V } } return max } ) } 
func funcMinOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return aggrOverTime ( vals , enh , func ( values [ ] Point ) float64 { min := values [ 0 ] . V for _ , v := range values { if v . V < min || math . IsNaN ( min ) { min = v . V } } return min } ) } 
func funcSumOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return aggrOverTime ( vals , enh , func ( values [ ] Point ) float64 { var sum float64 for _ , v := range values { sum += v . V } return sum } ) } 
func funcQuantileOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { q := vals [ 0 ] . ( Vector ) [ 0 ] . V mat := vals [ 1 ] . ( Matrix ) for _ , el := range mat { if len ( el . Points ) == 0 { continue } values := make ( vectorByValueHeap , 0 , len ( el . Points ) ) for _ , v := range el . Points { values = append ( values , Sample { Point : Point { V : v . V } } ) } enh . out = append ( enh . out , Sample { Point : Point { V : quantile ( q , values ) } , } ) } return enh . out } 
func funcStddevOverTime ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return aggrOverTime ( vals , enh , func ( values [ ] Point ) float64 { var aux , count , mean float64 for _ , v := range values { count ++ delta := v . V - mean mean += delta / count aux += delta * ( v . V - mean ) } return math . Sqrt ( aux / count ) } ) } 
func funcAbsent ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { if len ( vals [ 0 ] . ( Vector ) ) > 0 { return enh . out } m := [ ] labels . Label { } if vs , ok := args [ 0 ] . ( * VectorSelector ) ; ok { for _ , ma := range vs . LabelMatchers { if ma . Type == labels . MatchEqual && ma . Name != labels . MetricName { m = append ( m , labels . Label { Name : ma . Name , Value : ma . Value } ) } } } return append ( enh . out , Sample { Metric : labels . New ( m ... ) , Point : Point { V : 1 } , } ) } 
func funcAbs ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Abs ) } 
func funcCeil ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Ceil ) } 
func funcFloor ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Floor ) } 
func funcExp ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Exp ) } 
func funcSqrt ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Sqrt ) } 
func funcLn ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Log ) } 
func funcLog2 ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Log2 ) } 
func funcLog10 ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return simpleFunc ( vals , enh , math . Log10 ) } 
func funcTimestamp ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { vec := vals [ 0 ] . ( Vector ) for _ , el := range vec { enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : float64 ( el . T ) / 1000 } , } ) } return enh . out } 
func linearRegression ( samples [ ] Point , interceptTime int64 ) ( slope , intercept float64 ) { var ( n float64 sumX , sumY float64 sumXY , sumX2 float64 ) for _ , sample := range samples { x := float64 ( sample . T - interceptTime ) / 1e3 n += 1.0 sumY += sample . V sumX += x sumXY += x * sample . V sumX2 += x * x } covXY := sumXY - sumX * sumY / n varX := sumX2 - sumX * sumX / n slope = covXY / varX intercept = sumY / n - slope * sumX / n return slope , intercept } 
func funcDeriv ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { mat := vals [ 0 ] . ( Matrix ) for _ , samples := range mat { } enh . out = append ( enh . out , Sample { Point : Point { V : slope } , } ) } return enh . out } 
func funcPredictLinear ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { mat := vals [ 0 ] . ( Matrix ) duration := vals [ 1 ] . ( Vector ) [ 0 ] . V for _ , samples := range mat { } slope , intercept := linearRegression ( samples . Points , enh . ts ) enh . out = append ( enh . out , Sample { Point : Point { V : slope * duration + intercept } , } ) } return enh . out } 
func funcHistogramQuantile ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { q := vals [ 0 ] . ( Vector ) [ 0 ] . V inVec := vals [ 1 ] . ( Vector ) sigf := enh . signatureFunc ( false , excludedLabels ... ) if enh . signatureToMetricWithBuckets == nil { enh . signatureToMetricWithBuckets = map [ uint64 ] * metricWithBuckets { } } else { for _ , v := range enh . signatureToMetricWithBuckets { v . buckets = v . buckets [ : 0 ] } } for _ , el := range inVec { upperBound , err := strconv . ParseFloat ( el . Metric . Get ( model . BucketLabel ) , 64 , ) if err != nil { } hash := sigf ( el . Metric ) mb , ok := enh . signatureToMetricWithBuckets [ hash ] if ! ok { el . Metric = labels . NewBuilder ( el . Metric ) . Del ( labels . BucketLabel , labels . MetricName ) . Labels ( ) mb = & metricWithBuckets { el . Metric , nil } enh . signatureToMetricWithBuckets [ hash ] = mb } mb . buckets = append ( mb . buckets , bucket { upperBound , el . V } ) } for _ , mb := range enh . signatureToMetricWithBuckets { if len ( mb . buckets ) > 0 { enh . out = append ( enh . out , Sample { Metric : mb . metric , Point : Point { V : bucketQuantile ( q , mb . buckets ) } , } ) } } return enh . out } 
func funcResets ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { in := vals [ 0 ] . ( Matrix ) for _ , samples := range in { resets := 0 prev := samples . Points [ 0 ] . V for _ , sample := range samples . Points [ 1 : ] { current := sample . V if current < prev { resets ++ } prev = current } enh . out = append ( enh . out , Sample { Point : Point { V : float64 ( resets ) } , } ) } return enh . out } 
func funcChanges ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { in := vals [ 0 ] . ( Matrix ) for _ , samples := range in { changes := 0 prev := samples . Points [ 0 ] . V for _ , sample := range samples . Points [ 1 : ] { current := sample . V if current != prev && ! ( math . IsNaN ( current ) && math . IsNaN ( prev ) ) { changes ++ } prev = current } enh . out = append ( enh . out , Sample { Point : Point { V : float64 ( changes ) } , } ) } return enh . out } 
func funcLabelReplace ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { var ( vector = vals [ 0 ] . ( Vector ) dst = args [ 1 ] . ( * StringLiteral ) . Val repl = args [ 2 ] . ( * StringLiteral ) . Val src = args [ 3 ] . ( * StringLiteral ) . Val regexStr = args [ 4 ] . ( * StringLiteral ) . Val ) if enh . regex == nil { var err error enh . regex , err = regexp . Compile ( " " + regexStr + " " ) if err != nil { panic ( errors . Errorf ( " " , regexStr ) ) } if ! model . LabelNameRE . MatchString ( dst ) { panic ( errors . Errorf ( " " , dst ) ) } enh . dmn = make ( map [ uint64 ] labels . Labels , len ( enh . out ) ) } for _ , el := range vector { h := el . Metric . Hash ( ) var outMetric labels . Labels if l , ok := enh . dmn [ h ] ; ok { outMetric = l } else { srcVal := el . Metric . Get ( src ) indexes := enh . regex . FindStringSubmatchIndex ( srcVal ) if indexes == nil { enh . dmn [ h ] = outMetric } else { res := enh . regex . ExpandString ( [ ] byte { } , repl , srcVal , indexes ) lb := labels . NewBuilder ( el . Metric ) . Del ( dst ) if len ( res ) > 0 { lb . Set ( dst , string ( res ) ) } outMetric = lb . Labels ( ) enh . dmn [ h ] = outMetric } } enh . out = append ( enh . out , Sample { Metric : outMetric , Point : Point { V : el . Point . V } , } ) } return enh . out } 
func funcVector ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return append ( enh . out , Sample { Metric : labels . Labels { } , Point : Point { V : vals [ 0 ] . ( Vector ) [ 0 ] . V } , } ) } 
func funcLabelJoin ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { var ( vector = vals [ 0 ] . ( Vector ) dst = args [ 1 ] . ( * StringLiteral ) . Val sep = args [ 2 ] . ( * StringLiteral ) . Val srcLabels = make ( [ ] string , len ( args ) - 3 ) ) if enh . dmn == nil { enh . dmn = make ( map [ uint64 ] labels . Labels , len ( enh . out ) ) } for i := 3 ; i < len ( args ) ; i ++ { src := args [ i ] . ( * StringLiteral ) . Val if ! model . LabelName ( src ) . IsValid ( ) { panic ( errors . Errorf ( " " , src ) ) } srcLabels [ i - 3 ] = src } if ! model . LabelName ( dst ) . IsValid ( ) { panic ( errors . Errorf ( " " , dst ) ) } srcVals := make ( [ ] string , len ( srcLabels ) ) for _ , el := range vector { h := el . Metric . Hash ( ) var outMetric labels . Labels if l , ok := enh . dmn [ h ] ; ok { outMetric = l } else { for i , src := range srcLabels { srcVals [ i ] = el . Metric . Get ( src ) } lb := labels . NewBuilder ( el . Metric ) strval := strings . Join ( srcVals , sep ) if strval == " " { lb . Del ( dst ) } else { lb . Set ( dst , strval ) } outMetric = lb . Labels ( ) enh . dmn [ h ] = outMetric } enh . out = append ( enh . out , Sample { Metric : outMetric , Point : Point { V : el . Point . V } , } ) } return enh . out } 
func dateWrapper ( vals [ ] Value , enh * EvalNodeHelper , f func ( time . Time ) float64 ) Vector { if len ( vals ) == 0 { return append ( enh . out , Sample { Metric : labels . Labels { } , Point : Point { V : f ( time . Unix ( enh . ts / 1000 , 0 ) . UTC ( ) ) } , } ) } for _ , el := range vals [ 0 ] . ( Vector ) { t := time . Unix ( int64 ( el . V ) , 0 ) . UTC ( ) enh . out = append ( enh . out , Sample { Metric : enh . dropMetricName ( el . Metric ) , Point : Point { V : f ( t ) } , } ) } return enh . out } 
func funcDaysInMonth ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( 32 - time . Date ( t . Year ( ) , t . Month ( ) , 32 , 0 , 0 , 0 , 0 , time . UTC ) . Day ( ) ) } ) } 
func funcDayOfMonth ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Day ( ) ) } ) } 
func funcDayOfWeek ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Weekday ( ) ) } ) } 
func funcHour ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Hour ( ) ) } ) } 
func funcMinute ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Minute ( ) ) } ) } 
func funcMonth ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Month ( ) ) } ) } 
func funcYear ( vals [ ] Value , args Expressions , enh * EvalNodeHelper ) Vector { return dateWrapper ( vals , enh , func ( t time . Time ) float64 { return float64 ( t . Year ( ) ) } ) } 
func getFunction ( name string ) ( * Function , bool ) { function , ok := functions [ name ] return function , ok } 
func ( c * ServiceDiscoveryConfig ) Validate ( ) error { for _ , cfg := range c . AzureSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . ConsulSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . DNSSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . EC2SDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . FileSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . GCESDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . KubernetesSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . MarathonSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . NerveSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . OpenstackSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . ServersetSDConfigs { if cfg == nil { return errors . New ( " " ) } } for _ , cfg := range c . StaticConfigs { if cfg == nil { return errors . New ( " " ) } } return nil } 
func Dedupe ( next log . Logger , repeat time . Duration ) * Deduper { d := & Deduper { next : next , repeat : repeat , quit : make ( chan struct { } ) , seen : map [ string ] time . Time { } , } go d . run ( ) return d } 
func ( d * Deduper ) Log ( keyvals ... interface { } ) error { line , err := encode ( keyvals ... ) if err != nil { return err } d . mtx . RLock ( ) last , ok := d . seen [ line ] d . mtx . RUnlock ( ) if ok && time . Since ( last ) < d . repeat { return nil } d . mtx . Lock ( ) if len ( d . seen ) < maxEntries { d . seen [ line ] = time . Now ( ) } d . mtx . Unlock ( ) return d . next . Log ( keyvals ... ) } 
func ( g * Gate ) Start ( ctx context . Context ) error { select { case <- ctx . Done ( ) : return ctx . Err ( ) case g . ch <- struct { } { } : return nil } } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if c . Account == " " { return errors . New ( " " ) } if c . DNSSuffix == " " { return errors . New ( " " ) } if c . Endpoint == " " { return errors . New ( " " ) } if c . RefreshInterval <= 0 { return errors . New ( " " ) } return nil } 
func New ( logger log . Logger , conf * SDConfig ) ( * Discovery , error ) { tls , err := config_util . NewTLSConfig ( & conf . TLSConfig ) if err != nil { return nil , err } transport := & http . Transport { TLSClientConfig : tls , DialContext : conntrack . NewDialContextFunc ( conntrack . DialWithTracing ( ) , conntrack . DialWithName ( " " ) , ) , } client := & http . Client { Transport : transport } d := & Discovery { client : client , interval : time . Duration ( conf . RefreshInterval ) , sdConfig : conf , } d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d , nil } 
func withStackTracer ( h http . Handler , l log . Logger ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if err := recover ( ) ; err != nil { const size = 64 << 10 buf := make ( [ ] byte , size ) buf = buf [ : runtime . Stack ( buf , false ) ] level . Error ( l ) . Log ( " " , " " , " " , r . RemoteAddr , " " , r . URL , " " , err , " " , buf ) panic ( err ) } } ( ) h . ServeHTTP ( w , r ) } ) } 
func ( h * Handler ) ApplyConfig ( conf * config . Config ) error { h . mtx . Lock ( ) defer h . mtx . Unlock ( ) h . config = conf return nil } 
func New ( logger log . Logger , o * Options ) * Handler { router := route . New ( ) . WithInstrumentation ( instrumentHandler ) cwd , err := os . Getwd ( ) if err != nil { cwd = " " } if logger == nil { logger = log . NewNopLogger ( ) } h := & Handler { logger : logger , router : router , quitCh : make ( chan struct { } ) , reloadCh : make ( chan chan error ) , options : o , versionInfo : o . Version , birth : time . Now ( ) , cwd : cwd , flagsMap : o . Flags , context : o . Context , scrapeManager : o . ScrapeManager , ruleManager : o . RuleManager , queryEngine : o . QueryEngine , tsdb : o . TSDB , storage : o . Storage , notifier : o . Notifier , now : model . Now , ready : 0 , } h . apiV1 = api_v1 . NewAPI ( h . queryEngine , h . storage , h . scrapeManager , h . notifier , func ( ) config . Config { h . mtx . RLock ( ) defer h . mtx . RUnlock ( ) return * h . config } , o . Flags , h . testReady , func ( ) api_v1 . TSDBAdmin { return h . options . TSDB ( ) } , h . options . EnableAdminAPI , logger , h . ruleManager , h . options . RemoteReadSampleLimit , h . options . RemoteReadConcurrencyLimit , h . options . CORSOrigin , ) if o . RoutePrefix != " " { } ) router = router . WithPrefix ( o . RoutePrefix ) } readyf := h . testReady router . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { http . Redirect ( w , r , path . Join ( o . ExternalURL . Path , " " ) , http . StatusFound ) } ) router . Get ( " " , readyf ( h . alerts ) ) router . Get ( " " , readyf ( h . graph ) ) router . Get ( " " , readyf ( h . status ) ) router . Get ( " " , readyf ( h . flags ) ) router . Get ( " " , readyf ( h . serveConfig ) ) router . Get ( " " , readyf ( h . rules ) ) router . Get ( " " , readyf ( h . targets ) ) router . Get ( " " , readyf ( h . version ) ) router . Get ( " " , readyf ( h . serviceDiscovery ) ) router . Get ( " " , promhttp . Handler ( ) . ServeHTTP ) router . Get ( " " , readyf ( httputil . CompressionHandler { Handler : http . HandlerFunc ( h . federation ) , } . ServeHTTP ) ) router . Get ( " " , readyf ( h . consoles ) ) router . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { r . URL . Path = path . Join ( " " , route . Param ( r . Context ( ) , " " ) ) fs := http . FileServer ( ui . Assets ) fs . ServeHTTP ( w , r ) } ) if o . UserAssetsPath != " " { router . Get ( " " , route . FileServe ( o . UserAssetsPath ) ) } if o . EnableLifecycle { router . Post ( " " , h . quit ) router . Put ( " " , h . quit ) router . Post ( " " , h . reload ) router . Put ( " " , h . reload ) } else { router . Post ( " " , func ( w http . ResponseWriter , _ * http . Request ) { w . WriteHeader ( http . StatusForbidden ) w . Write ( [ ] byte ( " " ) ) } ) router . Post ( " " , func ( w http . ResponseWriter , _ * http . Request ) { w . WriteHeader ( http . StatusForbidden ) w . Write ( [ ] byte ( " " ) ) } ) } router . Get ( " " , func ( w http . ResponseWriter , _ * http . Request ) { w . WriteHeader ( http . StatusMethodNotAllowed ) w . Write ( [ ] byte ( " " ) ) } ) router . Get ( " " , func ( w http . ResponseWriter , _ * http . Request ) { w . WriteHeader ( http . StatusMethodNotAllowed ) w . Write ( [ ] byte ( " " ) ) } ) router . Get ( " " , serveDebug ) router . Post ( " " , serveDebug ) router . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { w . WriteHeader ( http . StatusOK ) fmt . Fprintf ( w , " \n " ) } ) router . Get ( " " , readyf ( func ( w http . ResponseWriter , r * http . Request ) { w . WriteHeader ( http . StatusOK ) fmt . Fprintf ( w , " \n " ) } ) ) return h } 
func ( h * Handler ) isReady ( ) bool { ready := atomic . LoadUint32 ( & h . ready ) return ready > 0 } 
func ( h * Handler ) Run ( ctx context . Context ) error { level . Info ( h . logger ) . Log ( " " , " " , " " , h . options . ListenAddress ) listener , err := net . Listen ( " " , h . options . ListenAddress ) if err != nil { return err } listener = netutil . LimitListener ( listener , h . options . MaxConnections ) var ( m = cmux . New ( listener ) httpl = m . Match ( cmux . HTTP1Fast ( ) ) grpcSrv = grpc . NewServer ( ) ) av2 := api_v2 . New ( h . options . TSDB , h . options . EnableAdminAPI , ) av2 . RegisterGRPC ( grpcSrv ) hh , err := av2 . HTTPHandler ( ctx , h . options . ListenAddress ) if err != nil { return err } hhFunc := h . testReadyHandler ( hh ) operationName := nethttp . OperationNameFunc ( func ( r * http . Request ) string { return fmt . Sprintf ( " " , r . Method , r . URL . Path ) } ) mux := http . NewServeMux ( ) mux . Handle ( " " , h . router ) av1 := route . New ( ) . WithInstrumentation ( instrumentHandlerWithPrefix ( " " ) ) h . apiV1 . Register ( av1 ) apiPath := " " if h . options . RoutePrefix != " " { apiPath = h . options . RoutePrefix + apiPath level . Info ( h . logger ) . Log ( " " , " " , " " , h . options . RoutePrefix ) } mux . Handle ( apiPath + " " , http . StripPrefix ( apiPath + " " , av1 ) ) mux . Handle ( apiPath + " " , http . StripPrefix ( apiPath , http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { httputil . SetCORS ( w , h . options . CORSOrigin , r ) hhFunc ( w , r ) } ) , ) ) errlog := stdlog . New ( log . NewStdlibAdapter ( level . Error ( h . logger ) ) , " " , 0 ) httpSrv := & http . Server { Handler : withStackTracer ( nethttp . Middleware ( opentracing . GlobalTracer ( ) , mux , operationName ) , h . logger ) , ErrorLog : errlog , ReadTimeout : h . options . ReadTimeout , } errCh := make ( chan error ) go func ( ) { errCh <- httpSrv . Serve ( httpl ) } ( ) go func ( ) { errCh <- grpcSrv . Serve ( grpcl ) } ( ) go func ( ) { errCh <- m . Serve ( ) } ( ) select { case e := <- errCh : return e case <- ctx . Done ( ) : httpSrv . Shutdown ( ctx ) grpcSrv . GracefulStop ( ) return nil } } 
func New ( fs http . FileSystem , t time . Time ) http . FileSystem { return & timefs { fs : fs , t : t } } 
func ( tv TagValue ) MarshalJSON ( ) ( [ ] byte , error ) { length := len ( tv ) result . WriteByte ( '"' ) for i := 0 ; i < length ; i ++ { b := tv [ i ] switch { case ( b >= '-' && b <= '9' ) || case b == '_' : result . WriteString ( " " ) case b == ':' : result . WriteString ( " " ) default : result . WriteString ( fmt . Sprintf ( " " , b ) ) } } result . WriteByte ( '"' ) return result . Bytes ( ) , nil } 
func ( tv * TagValue ) UnmarshalJSON ( json [ ] byte ) error { escapeLevel := 0 var parsedByte byte for i , b := range json { if i == 0 { if b != '"' { return errors . Errorf ( " \" " , b ) } continue } if i == len ( json ) - 1 { if b != '"' { return errors . Errorf ( " \" " , b ) } break } switch escapeLevel { case 0 : if b == '_' { escapeLevel = 1 continue } result . WriteByte ( b ) case 1 : switch { case b == '_' : result . WriteByte ( '_' ) escapeLevel = 0 case b == '.' : result . WriteByte ( ':' ) escapeLevel = 0 case b >= '0' && b <= '9' : parsedByte = ( b - 48 ) << 4 escapeLevel = 2 case b >= 'A' && b <= 'F' : // A-F parsedByte = ( b - 55 ) << 4 escapeLevel = 2 default : return errors . Errorf ( " " , i , b , ) } case 2 : switch { case b >= '0' && b <= '9' : parsedByte += b - 48 case b >= 'A' && b <= 'F' : default : return errors . Errorf ( " " , i , b , ) } result . WriteByte ( parsedByte ) escapeLevel = 0 default : panic ( " " ) } } * tv = TagValue ( result . String ( ) ) return nil } 
func NewClient ( logger log . Logger , conf influx . HTTPConfig , db string , rp string ) * Client { c , err := influx . NewHTTPClient ( conf ) os . Exit ( 1 ) } if logger == nil { logger = log . NewNopLogger ( ) } return & Client { logger : logger , client : c , database : db , retentionPolicy : rp , ignoredSamples : prometheus . NewCounter ( prometheus . CounterOpts { Name : " " , Help : " " , } , ) , } } 
func ( c * Client ) Write ( samples model . Samples ) error { points := make ( [ ] * influx . Point , 0 , len ( samples ) ) for _ , s := range samples { v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) c . ignoredSamples . Inc ( ) continue } p , err := influx . NewPoint ( string ( s . Metric [ model . MetricNameLabel ] ) , tagsFromMetric ( s . Metric ) , map [ string ] interface { } { " " : v } , s . Timestamp . Time ( ) , ) if err != nil { return err } points = append ( points , p ) } bps , err := influx . NewBatchPoints ( influx . BatchPointsConfig { Precision : " " , Database : c . database , RetentionPolicy : c . retentionPolicy , } ) if err != nil { return err } bps . AddPoints ( points ) return c . client . Write ( bps ) } 
func mergeSamples ( a , b [ ] prompb . Sample ) [ ] prompb . Sample { result := make ( [ ] prompb . Sample , 0 , len ( a ) + len ( b ) ) i , j := 0 , 0 for i < len ( a ) && j < len ( b ) { if a [ i ] . Timestamp < b [ j ] . Timestamp { result = append ( result , a [ i ] ) i ++ } else if a [ i ] . Timestamp > b [ j ] . Timestamp { result = append ( result , b [ j ] ) j ++ } else { result = append ( result , a [ i ] ) i ++ j ++ } } result = append ( result , a [ i : ] ... ) result = append ( result , b [ j : ] ... ) return result } 
func ( c * Client ) Describe ( ch chan <- * prometheus . Desc ) { ch <- c . ignoredSamples . Desc ( ) } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if len ( c . Servers ) == 0 { return errors . New ( " " ) } if len ( c . AuthToken ) > 0 && len ( c . AuthTokenFile ) > 0 { return errors . New ( " " ) } if c . HTTPClientConfig . BasicAuth != nil && ( len ( c . AuthToken ) > 0 || len ( c . AuthTokenFile ) > 0 ) { return errors . New ( " " ) } if ( len ( c . HTTPClientConfig . BearerToken ) > 0 || len ( c . HTTPClientConfig . BearerTokenFile ) > 0 ) && ( len ( c . AuthToken ) > 0 || len ( c . AuthTokenFile ) > 0 ) { return errors . New ( " " ) } return c . HTTPClientConfig . Validate ( ) } 
func NewDiscovery ( conf SDConfig , logger log . Logger ) ( * Discovery , error ) { rt , err := config_util . NewRoundTripperFromConfig ( conf . HTTPClientConfig , " " ) if err != nil { return nil , err } if len ( conf . AuthToken ) > 0 { rt , err = newAuthTokenRoundTripper ( conf . AuthToken , rt ) } else if len ( conf . AuthTokenFile ) > 0 { rt , err = newAuthTokenFileRoundTripper ( conf . AuthTokenFile , rt ) } if err != nil { return nil , err } d := & Discovery { client : & http . Client { Transport : rt } , servers : conf . Servers , appsClient : fetchApps , } d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d , nil } 
func newAuthTokenRoundTripper ( token config_util . Secret , rt http . RoundTripper ) ( http . RoundTripper , error ) { return & authTokenRoundTripper { token , rt } , nil } 
func newAuthTokenFileRoundTripper ( tokenFile string , rt http . RoundTripper ) ( http . RoundTripper , error ) { if err != nil { return nil , errors . Wrapf ( err , " " , tokenFile ) } return & authTokenFileRoundTripper { tokenFile , rt } , nil } 
func ( app app ) isContainerNet ( ) bool { return len ( app . Networks ) > 0 && app . Networks [ 0 ] . Mode == " " } 
func fetchApps ( ctx context . Context , client * http . Client , url string ) ( * appList , error ) { request , err := http . NewRequest ( " " , url , nil ) if err != nil { return nil , err } request = request . WithContext ( ctx ) resp , err := client . Do ( request ) if err != nil { return nil , err } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) if ( resp . StatusCode < 200 ) || ( resp . StatusCode >= 300 ) { return nil , errors . Errorf ( " " , resp . StatusCode ) } var apps appList err = json . NewDecoder ( resp . Body ) . Decode ( & apps ) if err != nil { return nil , errors . Wrapf ( err , " " , url ) } return & apps , nil } 
func randomAppsURL ( servers [ ] string ) string { return fmt . Sprintf ( " " , server , appListPath ) } 
func appsToTargetGroups ( apps * appList ) map [ string ] * targetgroup . Group { tgroups := map [ string ] * targetgroup . Group { } for _ , a := range apps . Apps { group := createTargetGroup ( & a ) tgroups [ group . Source ] = group } return tgroups } 
func targetEndpoint ( task * task , port uint32 , containerNet bool ) string { var host string } else { host = task . Host } return net . JoinHostPort ( host , fmt . Sprintf ( " " , port ) ) } 
func extractPortMapping ( portMappings [ ] portMapping , containerNet bool ) ( [ ] uint32 , [ ] map [ string ] string ) { ports := make ( [ ] uint32 , len ( portMappings ) ) labels := make ( [ ] map [ string ] string , len ( portMappings ) ) for i := 0 ; i < len ( portMappings ) ; i ++ { labels [ i ] = portMappings [ i ] . Labels if containerNet { } else { } } return ports , labels } 
func Load ( s string ) ( * Config , error ) { cfg := & Config { } err := yaml . UnmarshalStrict ( [ ] byte ( s ) , cfg ) if err != nil { return nil , err } cfg . original = s return cfg , nil } 
func LoadFile ( filename string ) ( * Config , error ) { content , err := ioutil . ReadFile ( filename ) if err != nil { return nil , err } cfg , err := Load ( string ( content ) ) if err != nil { return nil , errors . Wrapf ( err , " " , filename ) } resolveFilepaths ( filepath . Dir ( filename ) , cfg ) return cfg , nil } 
func resolveFilepaths ( baseDir string , cfg * Config ) { join := func ( fp string ) string { if len ( fp ) > 0 && ! filepath . IsAbs ( fp ) { fp = filepath . Join ( baseDir , fp ) } return fp } for i , rf := range cfg . RuleFiles { cfg . RuleFiles [ i ] = join ( rf ) } tlsPaths := func ( cfg * config_util . TLSConfig ) { cfg . CAFile = join ( cfg . CAFile ) cfg . CertFile = join ( cfg . CertFile ) cfg . KeyFile = join ( cfg . KeyFile ) } clientPaths := func ( scfg * config_util . HTTPClientConfig ) { if scfg . BasicAuth != nil { scfg . BasicAuth . PasswordFile = join ( scfg . BasicAuth . PasswordFile ) } scfg . BearerTokenFile = join ( scfg . BearerTokenFile ) tlsPaths ( & scfg . TLSConfig ) } sdPaths := func ( cfg * sd_config . ServiceDiscoveryConfig ) { for _ , kcfg := range cfg . KubernetesSDConfigs { clientPaths ( & kcfg . HTTPClientConfig ) } for _ , mcfg := range cfg . MarathonSDConfigs { mcfg . AuthTokenFile = join ( mcfg . AuthTokenFile ) clientPaths ( & mcfg . HTTPClientConfig ) } for _ , consulcfg := range cfg . ConsulSDConfigs { tlsPaths ( & consulcfg . TLSConfig ) } for _ , cfg := range cfg . OpenstackSDConfigs { tlsPaths ( & cfg . TLSConfig ) } for _ , cfg := range cfg . TritonSDConfigs { tlsPaths ( & cfg . TLSConfig ) } for _ , filecfg := range cfg . FileSDConfigs { for i , fn := range filecfg . Files { filecfg . Files [ i ] = join ( fn ) } } } for _ , cfg := range cfg . ScrapeConfigs { clientPaths ( & cfg . HTTPClientConfig ) sdPaths ( & cfg . ServiceDiscoveryConfig ) } for _ , cfg := range cfg . AlertingConfig . AlertmanagerConfigs { clientPaths ( & cfg . HTTPClientConfig ) sdPaths ( & cfg . ServiceDiscoveryConfig ) } for _ , cfg := range cfg . RemoteReadConfigs { clientPaths ( & cfg . HTTPClientConfig ) } for _ , cfg := range cfg . RemoteWriteConfigs { clientPaths ( & cfg . HTTPClientConfig ) } } 
func ( c * Config ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultConfig if err := unmarshal ( ( * plain ) ( c ) ) ; err != nil { return err } } for _ , rf := range c . RuleFiles { if ! patRulePath . MatchString ( rf ) { return errors . Errorf ( " " , rf ) } } for _ , scfg := range c . ScrapeConfigs { if scfg == nil { return errors . New ( " " ) } } if scfg . ScrapeTimeout > scfg . ScrapeInterval { return errors . Errorf ( " " , scfg . JobName ) } if scfg . ScrapeTimeout == 0 { if c . GlobalConfig . ScrapeTimeout > scfg . ScrapeInterval { scfg . ScrapeTimeout = scfg . ScrapeInterval } else { scfg . ScrapeTimeout = c . GlobalConfig . ScrapeTimeout } } if _ , ok := jobNames [ scfg . JobName ] ; ok { return errors . Errorf ( " " , scfg . JobName ) } jobNames [ scfg . JobName ] = struct { } { } } for _ , rwcfg := range c . RemoteWriteConfigs { if rwcfg == nil { return errors . New ( " " ) } } for _ , rrcfg := range c . RemoteReadConfigs { if rrcfg == nil { return errors . New ( " " ) } } return nil } 
func ( c * GlobalConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { type plain GlobalConfig if err := unmarshal ( ( * plain ) ( gc ) ) ; err != nil { return err } for _ , l := range gc . ExternalLabels { if ! model . LabelName ( l . Name ) . IsValid ( ) { return errors . Errorf ( " " , l . Name ) } if ! model . LabelValue ( l . Value ) . IsValid ( ) { return errors . Errorf ( " " , l . Value ) } } } if gc . ScrapeTimeout > gc . ScrapeInterval { return errors . New ( " " ) } if gc . ScrapeTimeout == 0 { if DefaultGlobalConfig . ScrapeTimeout > gc . ScrapeInterval { gc . ScrapeTimeout = gc . ScrapeInterval } else { gc . ScrapeTimeout = DefaultGlobalConfig . ScrapeTimeout } } if gc . EvaluationInterval == 0 { gc . EvaluationInterval = DefaultGlobalConfig . EvaluationInterval } * c = * gc return nil } 
func ( c * GlobalConfig ) isZero ( ) bool { return c . ExternalLabels == nil && c . ScrapeInterval == 0 && c . ScrapeTimeout == 0 && c . EvaluationInterval == 0 } 
func ( c * ScrapeConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultScrapeConfig type plain ScrapeConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if len ( c . JobName ) == 0 { return errors . New ( " " ) } } } } } } } for _ , rlcfg := range c . RelabelConfigs { if rlcfg == nil { return errors . New ( " " ) } } for _ , rlcfg := range c . MetricRelabelConfigs { if rlcfg == nil { return errors . New ( " " ) } } } return nil } 
func ( c * AlertingConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { type plain AlertingConfig if err := unmarshal ( ( * plain ) ( c ) ) ; err != nil { return err } for _ , rlcfg := range c . AlertRelabelConfigs { if rlcfg == nil { return errors . New ( " " ) } } return nil } 
func CheckTargetAddress ( address model . LabelValue ) error { } return nil } 
func ( c * RemoteWriteConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultRemoteWriteConfig type plain RemoteWriteConfig if err := unmarshal ( ( * plain ) ( c ) ) ; err != nil { return err } if c . URL == nil { return errors . New ( " " ) } for _ , rlcfg := range c . WriteRelabelConfigs { if rlcfg == nil { return errors . New ( " " ) } } } 
func ( c * RemoteReadConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultRemoteReadConfig type plain RemoteReadConfig if err := unmarshal ( ( * plain ) ( c ) ) ; err != nil { return err } if c . URL == nil { return errors . New ( " " ) } } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if strings . TrimSpace ( c . Server ) == " " { return errors . New ( " " ) } return nil } 
func NewDiscovery ( conf * SDConfig , logger log . Logger ) ( * Discovery , error ) { if logger == nil { logger = log . NewNopLogger ( ) } tls , err := config_util . NewTLSConfig ( & conf . TLSConfig ) if err != nil { return nil , err } transport := & http . Transport { IdleConnTimeout : 5 * time . Duration ( conf . RefreshInterval ) , TLSClientConfig : tls , DialContext : conntrack . NewDialContextFunc ( conntrack . DialWithTracing ( ) , conntrack . DialWithName ( " " ) , ) , } wrapper := & http . Client { Transport : transport , Timeout : 35 * time . Second , } clientConf := & consul . Config { Address : conf . Server , Scheme : conf . Scheme , Datacenter : conf . Datacenter , Token : string ( conf . Token ) , HttpAuth : & consul . HttpBasicAuth { Username : conf . Username , Password : string ( conf . Password ) , } , HttpClient : wrapper , } client , err := consul . NewClient ( clientConf ) if err != nil { return nil , err } cd := & Discovery { client : client , tagSeparator : conf . TagSeparator , watchedServices : conf . Services , watchedTags : conf . ServiceTags , watchedNodeMeta : conf . NodeMeta , allowStale : conf . AllowStale , refreshInterval : time . Duration ( conf . RefreshInterval ) , clientDatacenter : conf . Datacenter , finalizer : transport . CloseIdleConnections , logger : logger , } return cd , nil } 
func ( d * Discovery ) shouldWatch ( name string , tags [ ] string ) bool { return d . shouldWatchFromName ( name ) && d . shouldWatchFromTags ( tags ) } 
func ( d * Discovery ) shouldWatchFromName ( name string ) bool { } for _ , sn := range d . watchedServices { if sn == name { return true } } return false } 
func ( d * Discovery ) shouldWatchFromTags ( tags [ ] string ) bool { } tagOuter : for _ , wtag := range d . watchedTags { for _ , tag := range tags { if wtag == tag { continue tagOuter } } return false } return true } 
func ( d * Discovery ) getDatacenter ( ) error { } info , err := d . client . Agent ( ) . Self ( ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) rpcFailuresCount . Inc ( ) return err } dc , ok := info [ " " ] [ " " ] . ( string ) if ! ok { err := errors . Errorf ( " " , info [ " " ] [ " " ] ) level . Error ( d . logger ) . Log ( " " , " " , " " , err ) return err } d . clientDatacenter = dc return nil } 
func ( d * Discovery ) initialize ( ctx context . Context ) { default : } if err != nil { time . Sleep ( retryInterval ) continue } } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { if d . finalizer != nil { defer d . finalizer ( ) } d . initialize ( ctx ) if len ( d . watchedServices ) == 0 || len ( d . watchedTags ) != 0 { var lastIndex uint64 for { select { case <- ctx . Done ( ) : ticker . Stop ( ) return default : d . watchServices ( ctx , ch , & lastIndex , services ) <- ticker . C } } } else { } <- ctx . Done ( ) } } 
func ( d * Discovery ) watchServices ( ctx context . Context , ch chan <- [ ] * targetgroup . Group , lastIndex * uint64 , services map [ string ] func ( ) ) error { catalog := d . client . Catalog ( ) level . Debug ( d . logger ) . Log ( " " , " " , " " , d . watchedTags ) t0 := time . Now ( ) opts := & consul . QueryOptions { WaitIndex : * lastIndex , WaitTime : watchTimeout , AllowStale : d . allowStale , NodeMeta : d . watchedNodeMeta , } srvs , meta , err := catalog . Services ( opts . WithContext ( ctx ) ) elapsed := time . Since ( t0 ) rpcDuration . WithLabelValues ( " " , " " ) . Observe ( elapsed . Seconds ( ) ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) rpcFailuresCount . Inc ( ) time . Sleep ( retryInterval ) return err } } * lastIndex = meta . LastIndex } if _ , ok := services [ name ] ; ok { continue } wctx , cancel := context . WithCancel ( ctx ) d . watchService ( wctx , ch , name ) services [ name ] = cancel } delete ( services , name ) case ch <- [ ] * targetgroup . Group { { Source : name } } : } } } return nil } 
func ( d * Discovery ) watchService ( ctx context . Context , ch chan <- [ ] * targetgroup . Group , name string ) { srv := & consulService { discovery : d , client : d . client , name : name , tags : d . watchedTags , labels : model . LabelSet { serviceLabel : model . LabelValue ( name ) , datacenterLabel : model . LabelValue ( d . clientDatacenter ) , } , tagSeparator : d . tagSeparator , logger : d . logger , } go func ( ) { ticker := time . NewTicker ( d . refreshInterval ) var lastIndex uint64 catalog := srv . client . Catalog ( ) for { select { case <- ctx . Done ( ) : ticker . Stop ( ) return default : srv . watch ( ctx , ch , catalog , & lastIndex ) <- ticker . C } } } ( ) } 
func ( srv * consulService ) watch ( ctx context . Context , ch chan <- [ ] * targetgroup . Group , catalog * consul . Catalog , lastIndex * uint64 ) error { level . Debug ( srv . logger ) . Log ( " " , " " , " " , srv . name , " " , srv . tags ) t0 := time . Now ( ) opts := & consul . QueryOptions { WaitIndex : * lastIndex , WaitTime : watchTimeout , AllowStale : srv . discovery . allowStale , NodeMeta : srv . discovery . watchedNodeMeta , } nodes , meta , err := catalog . ServiceMultipleTags ( srv . name , srv . tags , opts . WithContext ( ctx ) ) elapsed := time . Since ( t0 ) rpcDuration . WithLabelValues ( " " , " " ) . Observe ( elapsed . Seconds ( ) ) default : if err != nil { level . Error ( srv . logger ) . Log ( " " , " " , " " , srv . name , " " , srv . tags , " " , err ) rpcFailuresCount . Inc ( ) time . Sleep ( retryInterval ) return err } } * lastIndex = meta . LastIndex tgroup := targetgroup . Group { Source : srv . name , Labels : srv . labels , Targets : make ( [ ] model . LabelSet , 0 , len ( nodes ) ) , } for _ , node := range nodes { if node . ServiceAddress != " " { addr = net . JoinHostPort ( node . ServiceAddress , fmt . Sprintf ( " " , node . ServicePort ) ) } else { addr = net . JoinHostPort ( node . Address , fmt . Sprintf ( " " , node . ServicePort ) ) } labels := model . LabelSet { model . AddressLabel : model . LabelValue ( addr ) , addressLabel : model . LabelValue ( node . Address ) , nodeLabel : model . LabelValue ( node . Node ) , tagsLabel : model . LabelValue ( tags ) , serviceAddressLabel : model . LabelValue ( node . ServiceAddress ) , servicePortLabel : model . LabelValue ( strconv . Itoa ( node . ServicePort ) ) , serviceIDLabel : model . LabelValue ( node . ServiceID ) , } labels [ metaDataLabel + model . LabelName ( name ) ] = model . LabelValue ( v ) } labels [ serviceMetaDataLabel + model . LabelName ( name ) ] = model . LabelValue ( v ) } labels [ taggedAddressesLabel + model . LabelName ( name ) ] = model . LabelValue ( v ) } tgroup . Targets = append ( tgroup . Targets , labels ) } select { case <- ctx . Done ( ) : return ctx . Err ( ) case ch <- [ ] * targetgroup . Group { & tgroup } : } return nil } 
func NewPod ( l log . Logger , pods cache . SharedInformer ) * Pod { if l == nil { l = log . NewNopLogger ( ) } p := & Pod { informer : pods , store : pods . GetStore ( ) , logger : l , queue : workqueue . NewNamed ( " " ) , } p . informer . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , } ) return p } 
func ( p * Pod ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer p . queue . ShutDown ( ) if ! cache . WaitForCacheSync ( ctx . Done ( ) , p . informer . HasSynced ) { level . Error ( p . logger ) . Log ( " " , " " ) return } go func ( ) { for p . process ( ctx , ch ) { } } ( ) } 
func NewMatcher ( t MatchType , n , v string ) ( * Matcher , error ) { m := & Matcher { Type : t , Name : n , Value : v , } if t == MatchRegexp || t == MatchNotRegexp { re , err := regexp . Compile ( " " + v + " " ) if err != nil { return nil , err } m . re = re } return m , nil } 
func ( m * Matcher ) Matches ( s string ) bool { switch m . Type { case MatchEqual : return s == m . Value case MatchNotEqual : return s != m . Value case MatchRegexp : return m . re . MatchString ( s ) case MatchNotRegexp : return ! m . re . MatchString ( s ) } panic ( " " ) } 
func ( s QueryTiming ) SpanOperation ( ) string { switch s { case EvalTotalTime : return " " case ResultSortTime : return " " case QueryPreparationTime : return " " case InnerEvalTime : return " " case ExecQueueTime : return " " case ExecTotalTime : return " " default : return " " } } 
func NewQueryStats ( tg * QueryTimers ) * QueryStats { var qt queryTimings for s , timer := range tg . TimerGroup . timers { switch s { case EvalTotalTime : qt . EvalTotalTime = timer . Duration ( ) case ResultSortTime : qt . ResultSortTime = timer . Duration ( ) case QueryPreparationTime : qt . QueryPreparationTime = timer . Duration ( ) case InnerEvalTime : qt . InnerEvalTime = timer . Duration ( ) case ExecQueueTime : qt . ExecQueueTime = timer . Duration ( ) case ExecTotalTime : qt . ExecTotalTime = timer . Duration ( ) } } qs := QueryStats { Timings : qt } return & qs } 
func ( c * Role ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { if err := unmarshal ( ( * string ) ( c ) ) ; err != nil { return err } switch * c { case OpenStackRoleHypervisor , OpenStackRoleInstance : return nil default : return errors . Errorf ( " " , * c ) } } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if c . Role == " " { return errors . New ( " " ) } if c . Region == " " { return errors . New ( " " ) } return nil } 
func NewDiscovery ( conf * SDConfig , l log . Logger ) ( * refresh . Discovery , error ) { r , err := newRefresher ( conf , l ) if err != nil { return nil , err } return refresh . NewDiscovery ( l , " " , time . Duration ( conf . RefreshInterval ) , r . refresh , ) , nil } 
func ( ls * Labels ) UnmarshalJSON ( b [ ] byte ) error { var m map [ string ] string if err := json . Unmarshal ( b , & m ) ; err != nil { return err } * ls = FromMap ( m ) return nil } 
func ( ls * Labels ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { var m map [ string ] string if err := unmarshal ( & m ) ; err != nil { return err } * ls = FromMap ( m ) return nil } 
func ( ls Labels ) MatchLabels ( on bool , names ... string ) Labels { matchedLabels := Labels { } nameSet := map [ string ] struct { } { } for _ , n := range names { nameSet [ n ] = struct { } { } } for _ , v := range ls { if _ , ok := nameSet [ v . Name ] ; on == ok { matchedLabels = append ( matchedLabels , v ) } } return matchedLabels } 
func ( ls Labels ) Hash ( ) uint64 { b := make ( [ ] byte , 0 , 1024 ) for _ , v := range ls { b = append ( b , v . Name ... ) b = append ( b , sep ) b = append ( b , v . Value ... ) b = append ( b , sep ) } return xxhash . Sum64 ( b ) } 
func ( ls Labels ) HashForLabels ( names ... string ) uint64 { b := make ( [ ] byte , 0 , 1024 ) for _ , v := range ls { for _ , n := range names { if v . Name == n { b = append ( b , v . Name ... ) b = append ( b , sep ) b = append ( b , v . Value ... ) b = append ( b , sep ) break } } } return xxhash . Sum64 ( b ) } 
func ( ls Labels ) Copy ( ) Labels { res := make ( Labels , len ( ls ) ) copy ( res , ls ) return res } 
func ( ls Labels ) Get ( name string ) string { for _ , l := range ls { if l . Name == name { return l . Value } } return " " } 
func ( ls Labels ) Has ( name string ) bool { for _ , l := range ls { if l . Name == name { return true } } return false } 
func Equal ( ls , o Labels ) bool { if len ( ls ) != len ( o ) { return false } for i , l := range ls { if l . Name != o [ i ] . Name || l . Value != o [ i ] . Value { return false } } return true } 
func ( ls Labels ) Map ( ) map [ string ] string { m := make ( map [ string ] string , len ( ls ) ) for _ , l := range ls { m [ l . Name ] = l . Value } return m } 
func New ( ls ... Label ) Labels { set := make ( Labels , 0 , len ( ls ) ) for _ , l := range ls { set = append ( set , l ) } sort . Sort ( set ) return set } 
func FromStrings ( ss ... string ) Labels { if len ( ss ) % 2 != 0 { panic ( " " ) } var res Labels for i := 0 ; i < len ( ss ) ; i += 2 { res = append ( res , Label { Name : ss [ i ] , Value : ss [ i + 1 ] } ) } sort . Sort ( res ) return res } 
func Compare ( a , b Labels ) int { l := len ( a ) if len ( b ) < l { l = len ( b ) } for i := 0 ; i < l ; i ++ { if d := strings . Compare ( a [ i ] . Name , b [ i ] . Name ) ; d != 0 { return d } if d := strings . Compare ( a [ i ] . Value , b [ i ] . Value ) ; d != 0 { return d } } } 
func NewBuilder ( base Labels ) * Builder { return & Builder { base : base , del : make ( [ ] string , 0 , 5 ) , add : make ( [ ] Label , 0 , 5 ) , } } 
func ( b * Builder ) Del ( ns ... string ) * Builder { for _ , n := range ns { for i , a := range b . add { if a . Name == n { b . add = append ( b . add [ : i ] , b . add [ i + 1 : ] ... ) } } b . del = append ( b . del , n ) } return b } 
func ( b * Builder ) Set ( n , v string ) * Builder { for i , a := range b . add { if a . Name == n { b . add [ i ] . Value = v return b } } b . add = append ( b . add , Label { Name : n , Value : v } ) return b } 
func ( b * Builder ) Labels ( ) Labels { if len ( b . del ) == 0 && len ( b . add ) == 0 { return b . base } Outer : for _ , l := range b . base { for _ , n := range b . del { if l . Name == n { continue Outer } } for _ , la := range b . add { if l . Name == la . Name { continue Outer } } res = append ( res , l ) } res = append ( res , b . add ... ) sort . Sort ( res ) return res } 
func NewStorage ( l log . Logger , reg prometheus . Registerer , stCallback startTimeCallback , walDir string , flushDeadline time . Duration ) * Storage { if l == nil { l = log . NewNopLogger ( ) } s := & Storage { logger : logging . Dedupe ( l , 1 * time . Minute ) , localStartTimeCallback : stCallback , flushDeadline : flushDeadline , samplesIn : newEWMARate ( ewmaWeight , shardUpdateDuration ) , walDir : walDir , } go s . run ( ) return s } 
func ( s * Storage ) ApplyConfig ( conf * config . Config ) error { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) cfgBytes , err := json . Marshal ( conf . RemoteWriteConfigs ) if err != nil { return err } hash := md5 . Sum ( cfgBytes ) if hash == s . configHash { level . Debug ( s . logger ) . Log ( " " , " " ) return nil } s . configHash = hash if err != nil { return err } newQueues = append ( newQueues , NewQueueManager ( s . logger , s . walDir , s . samplesIn , rwConf . QueueConfig , conf . GlobalConfig . ExternalLabels , rwConf . WriteRelabelConfigs , c , s . flushDeadline , ) ) } for _ , q := range s . queues { q . Stop ( ) } s . queues = newQueues for _ , q := range s . queues { q . Start ( ) } for i , rrConf := range conf . RemoteReadConfigs { c , err := NewClient ( i , & ClientConfig { URL : rrConf . URL , Timeout : rrConf . RemoteTimeout , HTTPClientConfig : rrConf . HTTPClientConfig , } ) if err != nil { return err } q := QueryableClient ( c ) q = ExternalLabelsHandler ( q , conf . GlobalConfig . ExternalLabels ) if len ( rrConf . RequiredMatchers ) > 0 { q = RequiredMatchersFilter ( q , labelsToEqualityMatchers ( rrConf . RequiredMatchers ) ) } if ! rrConf . ReadRecent { q = PreferLocalStorageFilter ( q , s . localStartTimeCallback ) } queryables = append ( queryables , q ) } s . queryables = queryables return nil } 
func ( s * Storage ) Querier ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { s . mtx . Lock ( ) queryables := s . queryables s . mtx . Unlock ( ) queriers := make ( [ ] storage . Querier , 0 , len ( queryables ) ) for _ , queryable := range queryables { q , err := queryable . Querier ( ctx , mint , maxt ) if err != nil { return nil , err } queriers = append ( queriers , q ) } return storage . NewMergeQuerier ( nil , queriers ) , nil } 
func ( s * Storage ) Close ( ) error { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) for _ , q := range s . queues { q . Stop ( ) } return nil } 
func RateLimit ( next log . Logger , limit rate . Limit ) log . Logger { return & ratelimiter { limiter : rate . NewLimiter ( limit , int ( limit ) ) , next : next , } } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if len ( c . Names ) == 0 { return errors . New ( " " ) } switch strings . ToUpper ( c . Type ) { case " " : case " " , " " : if c . Port == 0 { return errors . New ( " " ) } default : return errors . Errorf ( " " , c . Type ) } return nil } 
func NewDiscovery ( conf SDConfig , logger log . Logger ) * Discovery { if logger == nil { logger = log . NewNopLogger ( ) } qtype := dns . TypeSRV switch strings . ToUpper ( conf . Type ) { case " " : qtype = dns . TypeA case " " : qtype = dns . TypeAAAA case " " : qtype = dns . TypeSRV } d := & Discovery { names : conf . Names , qtype : qtype , port : conf . Port , logger : logger , lookupFn : lookupWithSearchPath , } d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d } 
func lookupWithSearchPath ( name string , qtype uint16 , logger log . Logger ) ( * dns . Msg , error ) { conf , err := dns . ClientConfigFromFile ( resolvConf ) if err != nil { return nil , errors . Wrap ( err , " " ) } allResponsesValid := true for _ , lname := range conf . NameList ( name ) { response , err := lookupFromAnyServer ( lname , qtype , conf , logger ) if err != nil { } else if response . Rcode == dns . RcodeSuccess { } } if allResponsesValid { } } 
func lookupFromAnyServer ( name string , qtype uint16 , conf * dns . ClientConfig , logger log . Logger ) ( * dns . Msg , error ) { client := & dns . Client { } for _ , server := range conf . Servers { servAddr := net . JoinHostPort ( server , conf . Port ) msg , err := askServerForName ( name , qtype , client , servAddr , true ) if err != nil { level . Warn ( logger ) . Log ( " " , " " , " " , server , " " , name , " " , err ) continue } if msg . Rcode == dns . RcodeSuccess || msg . Rcode == dns . RcodeNameError { } } return nil , errors . Errorf ( " " , name ) } 
func askServerForName ( name string , queryType uint16 , client * dns . Client , servAddr string , edns bool ) ( * dns . Msg , error ) { msg := & dns . Msg { } msg . SetQuestion ( dns . Fqdn ( name ) , queryType ) if edns { msg . SetEdns0 ( dns . DefaultMsgSize , false ) } response , _ , err := client . Exchange ( msg , servAddr ) if err != nil { return nil , err } if response . Truncated { if client . Net == " " { return nil , errors . New ( " " ) } client . Net = " " return askServerForName ( name , queryType , client , servAddr , false ) } return response , nil } 
func newHypervisorDiscovery ( provider * gophercloud . ProviderClient , opts * gophercloud . AuthOptions , port int , region string , l log . Logger ) * HypervisorDiscovery { return & HypervisorDiscovery { provider : provider , authOpts : opts , region : region , port : port , logger : l } } 
func New ( db func ( ) * tsdb . DB , enableAdmin bool , ) * API { return & API { db : db , enableAdmin : enableAdmin , } } 
func ( api * API ) RegisterGRPC ( srv * grpc . Server ) { if api . enableAdmin { pb . RegisterAdminServer ( srv , NewAdmin ( api . db ) ) } else { pb . RegisterAdminServer ( srv , & AdminDisabled { } ) } } 
func ( api * API ) HTTPHandler ( ctx context . Context , grpcAddr string ) ( http . Handler , error ) { enc := new ( protoutil . JSONPb ) mux := runtime . NewServeMux ( runtime . WithMarshalerOption ( enc . ContentType ( ) , enc ) ) opts := [ ] grpc . DialOption { grpc . WithInsecure ( ) , } ) , } err := pb . RegisterAdminHandlerFromEndpoint ( ctx , mux , grpcAddr , opts ) if err != nil { return nil , err } return mux , nil } 
func extractTimeRange ( min , max * time . Time ) ( mint , maxt time . Time , err error ) { if min == nil { mint = minTime } else { mint = * min } if max == nil { maxt = maxTime } else { maxt = * max } if mint . After ( maxt ) { return mint , maxt , errors . Errorf ( " " ) } return mint , maxt , nil } 
func ( s * AdminDisabled ) TSDBSnapshot ( _ context . Context , _ * pb . TSDBSnapshotRequest ) ( * pb . TSDBSnapshotResponse , error ) { return nil , errAdminDisabled } 
func ( s * AdminDisabled ) TSDBCleanTombstones ( _ context . Context , _ * pb . TSDBCleanTombstonesRequest ) ( * pb . TSDBCleanTombstonesResponse , error ) { return nil , errAdminDisabled } 
func ( s * AdminDisabled ) DeleteSeries ( _ context . Context , r * pb . SeriesDeleteRequest ) ( * pb . SeriesDeleteResponse , error ) { return nil , errAdminDisabled } 
func ( s * Admin ) TSDBSnapshot ( _ context . Context , req * pb . TSDBSnapshotRequest ) ( * pb . TSDBSnapshotResponse , error ) { db := s . db ( ) if db == nil { return nil , errTSDBNotReady } var ( snapdir = filepath . Join ( db . Dir ( ) , " " ) name = fmt . Sprintf ( " " , time . Now ( ) . UTC ( ) . Format ( " " ) , rand . Int ( ) ) dir = filepath . Join ( snapdir , name ) ) if err := os . MkdirAll ( dir , 0777 ) ; err != nil { return nil , status . Errorf ( codes . Internal , " " , err ) } if err := db . Snapshot ( dir , ! req . SkipHead ) ; err != nil { return nil , status . Errorf ( codes . Internal , " " , err ) } return & pb . TSDBSnapshotResponse { Name : name } , nil } 
func ( s * Admin ) TSDBCleanTombstones ( _ context . Context , _ * pb . TSDBCleanTombstonesRequest ) ( * pb . TSDBCleanTombstonesResponse , error ) { db := s . db ( ) if db == nil { return nil , errTSDBNotReady } if err := db . CleanTombstones ( ) ; err != nil { return nil , status . Errorf ( codes . Internal , " " , err ) } return & pb . TSDBCleanTombstonesResponse { } , nil } 
func ( s * Admin ) DeleteSeries ( _ context . Context , r * pb . SeriesDeleteRequest ) ( * pb . SeriesDeleteResponse , error ) { mint , maxt , err := extractTimeRange ( r . MinTime , r . MaxTime ) if err != nil { return nil , status . Error ( codes . InvalidArgument , err . Error ( ) ) } var matchers tsdbLabels . Selector for _ , m := range r . Matchers { var lm tsdbLabels . Matcher var err error switch m . Type { case pb . LabelMatcher_EQ : lm = tsdbLabels . NewEqualMatcher ( m . Name , m . Value ) case pb . LabelMatcher_NEQ : lm = tsdbLabels . Not ( tsdbLabels . NewEqualMatcher ( m . Name , m . Value ) ) case pb . LabelMatcher_RE : lm , err = tsdbLabels . NewRegexpMatcher ( m . Name , m . Value ) if err != nil { return nil , status . Errorf ( codes . InvalidArgument , " " , err ) } case pb . LabelMatcher_NRE : lm , err = tsdbLabels . NewRegexpMatcher ( m . Name , m . Value ) if err != nil { return nil , status . Errorf ( codes . InvalidArgument , " " , err ) } lm = tsdbLabels . Not ( lm ) default : return nil , status . Error ( codes . InvalidArgument , " " ) } matchers = append ( matchers , lm ) } db := s . db ( ) if db == nil { return nil , errTSDBNotReady } if err := db . Delete ( timestamp . FromTime ( mint ) , timestamp . FromTime ( maxt ) , matchers ... ) ; err != nil { return nil , status . Error ( codes . Internal , err . Error ( ) ) } return & pb . SeriesDeleteResponse { } , nil } 
func ( c * compressedResponseWriter ) Write ( p [ ] byte ) ( int , error ) { return c . writer . Write ( p ) } 
func ( c * compressedResponseWriter ) Close ( ) { if zlibWriter , ok := c . writer . ( * zlib . Writer ) ; ok { zlibWriter . Flush ( ) } if gzipWriter , ok := c . writer . ( * gzip . Writer ) ; ok { gzipWriter . Flush ( ) } if closer , ok := c . writer . ( io . Closer ) ; ok { defer closer . Close ( ) } } 
func newCompressedResponseWriter ( writer http . ResponseWriter , req * http . Request ) * compressedResponseWriter { encodings := strings . Split ( req . Header . Get ( acceptEncodingHeader ) , " " ) for _ , encoding := range encodings { switch strings . TrimSpace ( encoding ) { case gzipEncoding : writer . Header ( ) . Set ( contentEncodingHeader , gzipEncoding ) return & compressedResponseWriter { ResponseWriter : writer , writer : gzip . NewWriter ( writer ) , } case deflateEncoding : writer . Header ( ) . Set ( contentEncodingHeader , deflateEncoding ) return & compressedResponseWriter { ResponseWriter : writer , writer : zlib . NewWriter ( writer ) , } } } return & compressedResponseWriter { ResponseWriter : writer , writer : writer , } } 
func ( c CompressionHandler ) ServeHTTP ( writer http . ResponseWriter , req * http . Request ) { compWriter := newCompressedResponseWriter ( writer , req ) c . Handler . ServeHTTP ( compWriter , req ) compWriter . Close ( ) } 
func NewTemplateExpander ( ctx context . Context , text string , name string , data interface { } , timestamp model . Time , queryFunc QueryFunc , externalURL * url . URL , ) * Expander { return & Expander { text : text , name : name , data : data , funcMap : text_template . FuncMap { " " : func ( q string ) ( queryResult , error ) { return query ( ctx , q , timestamp . Time ( ) , queryFunc ) } , " " : func ( v queryResult ) ( * sample , error ) { if len ( v ) > 0 { return v [ 0 ] , nil } return nil , errors . New ( " " ) } , " " : func ( label string , s * sample ) string { return s . Labels [ label ] } , " " : func ( s * sample ) float64 { return s . Value } , " " : func ( s * sample ) string { return s . Labels [ " " ] } , " " : func ( args ... interface { } ) map [ string ] interface { } { result := make ( map [ string ] interface { } ) for i , a := range args { result [ fmt . Sprintf ( " " , i ) ] = a } return result } , " " : func ( pattern , repl , text string ) string { re := regexp . MustCompile ( pattern ) return re . ReplaceAllString ( text , repl ) } , " " : func ( text string ) html_template . HTML { return html_template . HTML ( text ) } , " " : regexp . MatchString , " " : strings . Title , " " : strings . ToUpper , " " : strings . ToLower , " " : strutil . GraphLinkForExpression , " " : strutil . TableLinkForExpression , " " : func ( label string , v queryResult ) queryResult { sorter := queryResultByLabelSorter { v [ : ] , label } sort . Stable ( sorter ) return v } , " " : func ( v float64 ) string { if v == 0 || math . IsNaN ( v ) || math . IsInf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } if math . Abs ( v ) >= 1 { prefix := " " for _ , p := range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) < 1000 { break } prefix = p v /= 1000 } return fmt . Sprintf ( " " , v , prefix ) } prefix := " " for _ , p := range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) >= 1 { break } prefix = p v *= 1000 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float64 ) string { if math . Abs ( v ) <= 1 || math . IsNaN ( v ) || math . IsInf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } prefix := " " for _ , p := range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) < 1024 { break } prefix = p v /= 1024 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float64 ) string { if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } if v == 0 { return fmt . Sprintf ( " " , v ) } if math . Abs ( v ) >= 1 { sign := " " if v < 0 { sign = " " v = - v } seconds := int64 ( v ) % 60 minutes := ( int64 ( v ) / 60 ) % 60 hours := ( int64 ( v ) / 60 / 60 ) % 24 days := ( int64 ( v ) / 60 / 60 / 24 ) } if hours != 0 { return fmt . Sprintf ( " " , sign , hours , minutes , seconds ) } if minutes != 0 { return fmt . Sprintf ( " " , sign , minutes , seconds ) } } prefix := " " for _ , p := range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) >= 1 { break } prefix = p v *= 1000 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float64 ) string { if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } t := model . TimeFromUnixNano ( int64 ( v * 1e9 ) ) . Time ( ) . UTC ( ) return fmt . Sprint ( t ) } , " " : func ( ) string { return externalURL . Path } , " " : func ( ) string { return externalURL . String ( ) } , } , } } 
func AlertTemplateData ( labels map [ string ] string , externalLabels map [ string ] string , value float64 ) interface { } { return struct { Labels map [ string ] string ExternalLabels map [ string ] string Value float64 } { Labels : labels , ExternalLabels : externalLabels , Value : value , } } 
func ( te Expander ) Funcs ( fm text_template . FuncMap ) { for k , v := range fm { te . funcMap [ k ] = v } } 
func ( te Expander ) Expand ( ) ( result string , resultErr error ) { resultErr , ok = r . ( error ) if ! ok { resultErr = errors . Errorf ( " " , te . name , r ) } } if resultErr != nil { templateTextExpansionFailures . Inc ( ) } } ( ) templateTextExpansionTotal . Inc ( ) tmpl , err := text_template . New ( te . name ) . Funcs ( te . funcMap ) . Option ( " " ) . Parse ( te . text ) if err != nil { return " " , errors . Wrapf ( err , " " , te . name ) } var buffer bytes . Buffer err = tmpl . Execute ( & buffer , te . data ) if err != nil { return " " , errors . Wrapf ( err , " " , te . name ) } return buffer . String ( ) , nil } 
func ( te Expander ) ExpandHTML ( templateFiles [ ] string ) ( result string , resultErr error ) { defer func ( ) { if r := recover ( ) ; r != nil { var ok bool resultErr , ok = r . ( error ) if ! ok { resultErr = errors . Errorf ( " " , te . name , r ) } } } ( ) tmpl := html_template . New ( te . name ) . Funcs ( html_template . FuncMap ( te . funcMap ) ) tmpl . Option ( " " ) tmpl . Funcs ( html_template . FuncMap { " " : func ( name string , data interface { } ) ( html_template . HTML , error ) { var buffer bytes . Buffer err := tmpl . ExecuteTemplate ( & buffer , name , data ) return html_template . HTML ( buffer . String ( ) ) , err } , } ) tmpl , err := tmpl . Parse ( te . text ) if err != nil { return " " , errors . Wrapf ( err , " " , te . name ) } if len ( templateFiles ) > 0 { _ , err = tmpl . ParseFiles ( templateFiles ... ) if err != nil { return " " , errors . Wrapf ( err , " " , te . name ) } } var buffer bytes . Buffer err = tmpl . Execute ( & buffer , te . data ) if err != nil { return " " , errors . Wrapf ( err , " " , te . name ) } return buffer . String ( ) , nil } 
func NewTarget ( labels , discoveredLabels labels . Labels , params url . Values ) * Target { return & Target { labels : labels , discoveredLabels : discoveredLabels , params : params , health : HealthUnknown , } } 
func ( t * Target ) Metadata ( metric string ) ( MetricMetadata , bool ) { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) if t . metadata == nil { return MetricMetadata { } , false } return t . metadata . getMetadata ( metric ) } 
func ( t * Target ) hash ( ) uint64 { h := fnv . New64a ( ) h . Write ( [ ] byte ( fmt . Sprintf ( " " , t . labels . Hash ( ) ) ) ) h . Write ( [ ] byte ( t . URL ( ) . String ( ) ) ) return h . Sum64 ( ) } 
func ( t * Target ) offset ( interval time . Duration , jitterSeed uint64 ) time . Duration { now := time . Now ( ) . UnixNano ( ) offset = ( t . hash ( ) ^ jitterSeed ) % uint64 ( interval ) next = base + int64 ( offset ) ) if next > int64 ( interval ) { next -= int64 ( interval ) } return time . Duration ( next ) } 
func ( t * Target ) Labels ( ) labels . Labels { lset := make ( labels . Labels , 0 , len ( t . labels ) ) for _ , l := range t . labels { if ! strings . HasPrefix ( l . Name , model . ReservedLabelPrefix ) { lset = append ( lset , l ) } } return lset } 
func ( t * Target ) DiscoveredLabels ( ) labels . Labels { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) lset := make ( labels . Labels , len ( t . discoveredLabels ) ) copy ( lset , t . discoveredLabels ) return lset } 
func ( t * Target ) SetDiscoveredLabels ( l labels . Labels ) { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) t . discoveredLabels = l } 
func ( t * Target ) URL ( ) * url . URL { params := url . Values { } for k , v := range t . params { params [ k ] = make ( [ ] string , len ( v ) ) copy ( params [ k ] , v ) } for _ , l := range t . labels { if ! strings . HasPrefix ( l . Name , model . ParamLabelPrefix ) { continue } ks := l . Name [ len ( model . ParamLabelPrefix ) : ] if len ( params [ ks ] ) > 0 { params [ ks ] [ 0 ] = l . Value } else { params [ ks ] = [ ] string { l . Value } } } return & url . URL { Scheme : t . labels . Get ( model . SchemeLabel ) , Host : t . labels . Get ( model . AddressLabel ) , Path : t . labels . Get ( model . MetricsPathLabel ) , RawQuery : params . Encode ( ) , } } 
func ( t * Target ) LastError ( ) error { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastError } 
func ( t * Target ) LastScrape ( ) time . Time { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastScrape } 
func ( t * Target ) LastScrapeDuration ( ) time . Duration { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . lastScrapeDuration } 
func ( t * Target ) Health ( ) TargetHealth { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . health } 
func populateLabels ( lset labels . Labels , cfg * config . ScrapeConfig ) ( res , orig labels . Labels , err error ) { lb := labels . NewBuilder ( lset ) for _ , l := range scrapeLabels { if lv := lset . Get ( l . Name ) ; lv == " " { lb . Set ( l . Name , l . Value ) } } } } preRelabelLabels := lb . Labels ( ) lset = relabel . Process ( preRelabelLabels , cfg . RelabelConfigs ... ) } if v := lset . Get ( model . AddressLabel ) ; v == " " { return nil , nil , errors . New ( " " ) } lb = labels . NewBuilder ( lset ) } return err == nil } addr := lset . Get ( model . AddressLabel ) case " " : addr = addr + " " default : return nil , nil , errors . Errorf ( " " , cfg . Scheme ) } lb . Set ( model . AddressLabel , addr ) } if err := config . CheckTargetAddress ( model . LabelValue ( addr ) ) ; err != nil { return nil , nil , err } } } } res = lb . Labels ( ) for _ , l := range res { } } return res , preRelabelLabels , nil } 
func targetsFromGroup ( tg * targetgroup . Group , cfg * config . ScrapeConfig ) ( [ ] * Target , error ) { targets := make ( [ ] * Target , 0 , len ( tg . Targets ) ) for i , tlset := range tg . Targets { lbls := make ( [ ] labels . Label , 0 , len ( tlset ) + len ( tg . Labels ) ) for ln , lv := range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } for ln , lv := range tg . Labels { if _ , ok := tlset [ ln ] ; ! ok { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } } lset := labels . New ( lbls ... ) lbls , origLabels , err := populateLabels ( lset , cfg ) if err != nil { return nil , errors . Wrapf ( err , " " , i , tg ) } if lbls != nil || origLabels != nil { targets = append ( targets , NewTarget ( lbls , origLabels , cfg . Params ) ) } } return targets , nil } 
func FromTime ( t time . Time ) int64 { return t . Unix ( ) * 1000 + int64 ( t . Nanosecond ( ) ) / int64 ( time . Millisecond ) } 
func Time ( ts int64 ) time . Time { return time . Unix ( ts / 1000 , ( ts % 1000 ) * int64 ( time . Millisecond ) ) } 
func SetCORS ( w http . ResponseWriter , o * regexp . Regexp , r * http . Request ) { origin := r . Header . Get ( " " ) if origin == " " { return } for k , v := range corsHeaders { w . Header ( ) . Set ( k , v ) } if o . String ( ) == " " { w . Header ( ) . Set ( " " , " " ) return } if o . MatchString ( origin ) { w . Header ( ) . Set ( " " , origin ) } } 
func NewClient ( index int , conf * ClientConfig ) ( * Client , error ) { httpClient , err := config_util . NewClientFromConfig ( conf . HTTPClientConfig , " " ) if err != nil { return nil , err } return & Client { index : index , url : conf . URL , client : httpClient , timeout : time . Duration ( conf . Timeout ) , } , nil } 
func ( c * Client ) Store ( ctx context . Context , req [ ] byte ) error { httpReq , err := http . NewRequest ( " " , c . url . String ( ) , bytes . NewReader ( req ) ) if err != nil { } httpReq . Header . Add ( " " , " " ) httpReq . Header . Set ( " " , " " ) httpReq . Header . Set ( " " , userAgent ) httpReq . Header . Set ( " " , " " ) httpReq = httpReq . WithContext ( ctx ) ctx , cancel := context . WithTimeout ( context . Background ( ) , c . timeout ) defer cancel ( ) httpResp , err := c . client . Do ( httpReq . WithContext ( ctx ) ) if err != nil { } defer func ( ) { io . Copy ( ioutil . Discard , httpResp . Body ) httpResp . Body . Close ( ) } ( ) if httpResp . StatusCode / 100 != 2 { scanner := bufio . NewScanner ( io . LimitReader ( httpResp . Body , maxErrMsgLen ) ) line := " " if scanner . Scan ( ) { line = scanner . Text ( ) } err = errors . Errorf ( " " , httpResp . Status , line ) } if httpResp . StatusCode / 100 == 5 { return recoverableError { err } } return err } 
func ( c Client ) Name ( ) string { return fmt . Sprintf ( " " , c . index , c . url ) } 
func ( c * Client ) Read ( ctx context . Context , query * prompb . Query ) ( * prompb . QueryResult , error ) { req := & prompb . ReadRequest { data , err := proto . Marshal ( req ) if err != nil { return nil , errors . Wrapf ( err , " " ) } compressed := snappy . Encode ( nil , data ) httpReq , err := http . NewRequest ( " " , c . url . String ( ) , bytes . NewReader ( compressed ) ) if err != nil { return nil , errors . Wrap ( err , " " ) } httpReq . Header . Add ( " " , " " ) httpReq . Header . Add ( " " , " " ) httpReq . Header . Set ( " " , " " ) httpReq . Header . Set ( " " , userAgent ) httpReq . Header . Set ( " " , " " ) ctx , cancel := context . WithTimeout ( ctx , c . timeout ) defer cancel ( ) httpResp , err := c . client . Do ( httpReq . WithContext ( ctx ) ) if err != nil { return nil , errors . Wrap ( err , " " ) } defer func ( ) { io . Copy ( ioutil . Discard , httpResp . Body ) httpResp . Body . Close ( ) } ( ) if httpResp . StatusCode / 100 != 2 { return nil , errors . Errorf ( " " , httpResp . Status ) } compressed , err = ioutil . ReadAll ( httpResp . Body ) if err != nil { return nil , errors . Wrap ( err , " " ) } uncompressed , err := snappy . Decode ( nil , compressed ) if err != nil { return nil , errors . Wrap ( err , " " ) } var resp prompb . ReadResponse err = proto . Unmarshal ( uncompressed , & resp ) if err != nil { return nil , errors . Wrap ( err , " " ) } if len ( resp . Results ) != len ( req . Queries ) { return nil , errors . Errorf ( " " , len ( req . Queries ) , len ( resp . Results ) ) } return resp . Results [ 0 ] , nil } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if err = validateAuthParam ( c . SubscriptionID , " " ) ; err != nil { return err } if c . AuthenticationMethod == authMethodOAuth { if err = validateAuthParam ( c . TenantID , " " ) ; err != nil { return err } if err = validateAuthParam ( c . ClientID , " " ) ; err != nil { return err } if err = validateAuthParam ( string ( c . ClientSecret ) , " " ) ; err != nil { return err } } if c . AuthenticationMethod != authMethodOAuth && c . AuthenticationMethod != authMethodManagedIdentity { return errors . Errorf ( " " , c . AuthenticationMethod , authMethodOAuth , authMethodManagedIdentity ) } return nil } 
func NewDiscovery ( cfg * SDConfig , logger log . Logger ) * Discovery { if logger == nil { logger = log . NewNopLogger ( ) } d := & Discovery { cfg : cfg , port : cfg . Port , logger : logger , } d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( cfg . RefreshInterval ) , d . refresh , ) return d } 
func createAzureClient ( cfg SDConfig ) ( azureClient , error ) { env , err := azure . EnvironmentFromName ( cfg . Environment ) if err != nil { return azureClient { } , err } activeDirectoryEndpoint := env . ActiveDirectoryEndpoint resourceManagerEndpoint := env . ResourceManagerEndpoint var c azureClient var spt * adal . ServicePrincipalToken switch cfg . AuthenticationMethod { case authMethodManagedIdentity : msiEndpoint , err := adal . GetMSIVMEndpoint ( ) if err != nil { return azureClient { } , err } spt , err = adal . NewServicePrincipalTokenFromMSI ( msiEndpoint , resourceManagerEndpoint ) if err != nil { return azureClient { } , err } case authMethodOAuth : oauthConfig , err := adal . NewOAuthConfig ( activeDirectoryEndpoint , cfg . TenantID ) if err != nil { return azureClient { } , err } spt , err = adal . NewServicePrincipalToken ( * oauthConfig , cfg . ClientID , string ( cfg . ClientSecret ) , resourceManagerEndpoint ) if err != nil { return azureClient { } , err } } bearerAuthorizer := autorest . NewBearerAuthorizer ( spt ) c . vm = compute . NewVirtualMachinesClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vm . Authorizer = bearerAuthorizer c . nic = network . NewInterfacesClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . nic . Authorizer = bearerAuthorizer c . vmss = compute . NewVirtualMachineScaleSetsClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vmss . Authorizer = bearerAuthorizer c . vmssvm = compute . NewVirtualMachineScaleSetVMsClientWithBaseURI ( resourceManagerEndpoint , cfg . SubscriptionID ) c . vmssvm . Authorizer = bearerAuthorizer return c , nil } 
func newAzureResourceFromID ( id string , logger log . Logger ) ( azureResource , error ) { if len ( s ) != 9 && len ( s ) != 11 { err := errors . Errorf ( " " , id ) level . Error ( logger ) . Log ( " " , err ) return azureResource { } , err } return azureResource { Name : strings . ToLower ( s [ 8 ] ) , ResourceGroup : strings . ToLower ( s [ 4 ] ) , } , nil } 
func ( t * Timer ) String ( ) string { return fmt . Sprintf ( " " , t . name , t . duration ) } 
func ( t * TimerGroup ) GetTimer ( name fmt . Stringer ) * Timer { if timer , exists := t . timers [ name ] ; exists { return timer } timer := & Timer { name : name , created : time . Now ( ) , } t . timers [ name ] = timer return timer } 
func ( t Timers ) Swap ( i , j int ) { t [ i ] , t [ j ] = t [ j ] , t [ i ] } 
func ( t * TimerGroup ) String ( ) string { timers := byCreationTimeSorter { } for _ , timer := range t . timers { timers . Timers = append ( timers . Timers , timer ) } sort . Sort ( timers ) result := & bytes . Buffer { } for _ , timer := range timers . Timers { fmt . Fprintf ( result , " \n " , timer ) } return result . String ( ) } 
func RegisterAdminHandler ( ctx context . Context , mux * runtime . ServeMux , conn * grpc . ClientConn ) error { return RegisterAdminHandlerClient ( ctx , mux , NewAdminClient ( conn ) ) } 
func RegisterAdminHandlerClient ( ctx context . Context , mux * runtime . ServeMux , client AdminClient ) error { mux . Handle ( " " , pattern_Admin_TSDBSnapshot_0 , func ( w http . ResponseWriter , req * http . Request , pathParams map [ string ] string ) { ctx , cancel := context . WithCancel ( req . Context ( ) ) defer cancel ( ) inboundMarshaler , outboundMarshaler := runtime . MarshalerForRequest ( mux , req ) rctx , err := runtime . AnnotateContext ( ctx , mux , req ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } resp , md , err := request_Admin_TSDBSnapshot_0 ( rctx , inboundMarshaler , client , req , pathParams ) ctx = runtime . NewServerMetadataContext ( ctx , md ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } forward_Admin_TSDBSnapshot_0 ( ctx , mux , outboundMarshaler , w , req , resp , mux . GetForwardResponseOptions ( ) ... ) } ) mux . Handle ( " " , pattern_Admin_TSDBCleanTombstones_0 , func ( w http . ResponseWriter , req * http . Request , pathParams map [ string ] string ) { ctx , cancel := context . WithCancel ( req . Context ( ) ) defer cancel ( ) inboundMarshaler , outboundMarshaler := runtime . MarshalerForRequest ( mux , req ) rctx , err := runtime . AnnotateContext ( ctx , mux , req ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } resp , md , err := request_Admin_TSDBCleanTombstones_0 ( rctx , inboundMarshaler , client , req , pathParams ) ctx = runtime . NewServerMetadataContext ( ctx , md ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } forward_Admin_TSDBCleanTombstones_0 ( ctx , mux , outboundMarshaler , w , req , resp , mux . GetForwardResponseOptions ( ) ... ) } ) mux . Handle ( " " , pattern_Admin_DeleteSeries_0 , func ( w http . ResponseWriter , req * http . Request , pathParams map [ string ] string ) { ctx , cancel := context . WithCancel ( req . Context ( ) ) defer cancel ( ) inboundMarshaler , outboundMarshaler := runtime . MarshalerForRequest ( mux , req ) rctx , err := runtime . AnnotateContext ( ctx , mux , req ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } resp , md , err := request_Admin_DeleteSeries_0 ( rctx , inboundMarshaler , client , req , pathParams ) ctx = runtime . NewServerMetadataContext ( ctx , md ) if err != nil { runtime . HTTPError ( ctx , mux , outboundMarshaler , w , req , err ) return } forward_Admin_DeleteSeries_0 ( ctx , mux , outboundMarshaler , w , req , resp , mux . GetForwardResponseOptions ( ) ... ) } ) return nil } 
func ParseExpr ( input string ) ( Expr , error ) { p := newParser ( input ) expr , err := p . parseExpr ( ) if err != nil { return nil , err } err = p . typecheck ( expr ) return expr , err } 
func ParseMetric ( input string ) ( m labels . Labels , err error ) { p := newParser ( input ) defer p . recover ( & err ) m = p . metric ( ) if p . peek ( ) . typ != ItemEOF { p . errorf ( " " , p . lex . input [ p . lex . lastPos : ] ) } return m , nil } 
func ParseMetricSelector ( input string ) ( m [ ] * labels . Matcher , err error ) { p := newParser ( input ) defer p . recover ( & err ) name := " " if t := p . peek ( ) . typ ; t == ItemMetricIdentifier || t == ItemIdentifier { name = p . next ( ) . val } vs := p . VectorSelector ( name ) if p . peek ( ) . typ != ItemEOF { p . errorf ( " " , p . lex . input [ p . lex . lastPos : ] ) } return vs . LabelMatchers , nil } 
func newParser ( input string ) * parser { p := & parser { lex : lex ( input ) , } return p } 
func ( p * parser ) parseExpr ( ) ( expr Expr , err error ) { defer p . recover ( & err ) for p . peek ( ) . typ != ItemEOF { if p . peek ( ) . typ == ItemComment { continue } if expr != nil { p . errorf ( " " , p . lex . input [ p . lex . lastPos : ] ) } expr = p . expr ( ) } if expr == nil { p . errorf ( " " ) } return } 
func parseSeriesDesc ( input string ) ( labels . Labels , [ ] sequenceValue , error ) { p := newParser ( input ) p . lex . seriesDesc = true return p . parseSeriesDesc ( ) } 
func ( p * parser ) parseSeriesDesc ( ) ( m labels . Labels , vals [ ] sequenceValue , err error ) { defer p . recover ( & err ) m = p . metric ( ) const ctx = " " for { for p . peek ( ) . typ == ItemSpace { p . next ( ) } if p . peek ( ) . typ == ItemEOF { break } times := uint64 ( 1 ) if p . peek ( ) . typ == ItemTimes { p . next ( ) times , err = strconv . ParseUint ( p . expect ( ItemNumber , ctx ) . val , 10 , 64 ) if err != nil { p . errorf ( " " , ctx , err ) } } for i := uint64 ( 0 ) ; i < times ; i ++ { vals = append ( vals , sequenceValue { omitted : true } ) } } continue } if t := p . peek ( ) . typ ; t == ItemSUB || t == ItemADD { if p . next ( ) . typ == ItemSUB { sign = - 1 } } var k float64 if t := p . peek ( ) . typ ; t == ItemNumber { k = sign * p . number ( p . expect ( ItemNumber , ctx ) . val ) } else if t == ItemIdentifier && p . peek ( ) . val == " " { p . next ( ) k = math . Float64frombits ( value . StaleNaN ) } else { p . errorf ( " " , ctx , t . desc ( ) , p . peek ( ) ) } vals = append ( vals , sequenceValue { value : k , } ) } else if t . typ == ItemEOF { break } else if t . typ != ItemADD && t . typ != ItemSUB { p . errorf ( " " , ctx , t . desc ( ) , p . peek ( ) ) } if p . next ( ) . typ == ItemSUB { sign = - 1.0 } offset := sign * p . number ( p . expect ( ItemNumber , ctx ) . val ) p . expect ( ItemTimes , ctx ) times , err := strconv . ParseUint ( p . expect ( ItemNumber , ctx ) . val , 10 , 64 ) if err != nil { p . errorf ( " " , ctx , err ) } for i := uint64 ( 0 ) ; i < times ; i ++ { k += offset vals = append ( vals , sequenceValue { value : k , } ) } } } return m , vals , nil } 
func ( p * parser ) typecheck ( node Node ) ( err error ) { defer p . recover ( & err ) p . checkType ( node ) return nil } 
func ( p * parser ) next ( ) item { if p . peekCount > 0 { p . peekCount -- } else { t := p . lex . nextItem ( ) } p . token [ 0 ] = t } if p . token [ p . peekCount ] . typ == ItemError { p . errorf ( " " , p . token [ p . peekCount ] . val ) } return p . token [ p . peekCount ] } 
func ( p * parser ) peek ( ) item { if p . peekCount > 0 { return p . token [ p . peekCount - 1 ] } p . peekCount = 1 t := p . lex . nextItem ( ) } p . token [ 0 ] = t return p . token [ 0 ] } 
func ( p * parser ) errorf ( format string , args ... interface { } ) { p . error ( errors . Errorf ( format , args ... ) ) } 
func ( p * parser ) error ( err error ) { perr := & ParseErr { Line : p . lex . lineNumber ( ) , Pos : p . lex . linePosition ( ) , Err : err , } if strings . Count ( strings . TrimSpace ( p . lex . input ) , " \n " ) == 0 { perr . Line = 0 } panic ( perr ) } 
func ( p * parser ) expect ( exp ItemType , context string ) item { token := p . next ( ) if token . typ != exp { p . errorf ( " " , token . desc ( ) , context , exp . desc ( ) ) } return token } 
func ( p * parser ) expectOneOf ( exp1 , exp2 ItemType , context string ) item { token := p . next ( ) if token . typ != exp1 && token . typ != exp2 { p . errorf ( " " , token . desc ( ) , context , exp1 . desc ( ) , exp2 . desc ( ) ) } return token } 
func ( p * parser ) recover ( errp * error ) { e := recover ( ) if _ , ok := e . ( runtime . Error ) ; ok { buf = buf [ : runtime . Stack ( buf , false ) ] fmt . Fprintf ( os . Stderr , " \n " , e , buf ) * errp = errUnexpected } else if e != nil { * errp = e . ( error ) } p . lex . close ( ) } 
func ( p * parser ) expr ( ) Expr { if ! op . isOperator ( ) { if s , ok := expr . ( * SubqueryExpr ) ; ok { s . Offset = offset } } } return expr } p . next ( ) if op . isSetOperator ( ) { vecMatching . Card = CardManyToMany } returnBool := false } p . next ( ) returnBool = true } } p . next ( ) vecMatching . MatchingLabels = p . labels ( ) if t == ItemGroupLeft { vecMatching . Card = CardManyToOne } else { vecMatching . Card = CardOneToMany } if p . peek ( ) . typ == ItemLeftParen { vecMatching . Include = p . labels ( ) } } } for _ , ln := range vecMatching . MatchingLabels { for _ , ln2 := range vecMatching . Include { if ln == ln2 && vecMatching . On { p . errorf ( " " , ln ) } } } } } 
func ( p * parser ) unaryExpr ( ) Expr { switch t := p . peek ( ) ; t . typ { case ItemADD , ItemSUB : p . next ( ) e := p . unaryExpr ( ) } return nl } return & UnaryExpr { Op : t . typ , Expr : e } case ItemLeftParen : p . next ( ) e := p . expr ( ) p . expect ( ItemRightParen , " " ) return & ParenExpr { Expr : e } } e := p . primaryExpr ( ) } switch s := e . ( type ) { case * VectorSelector : s . Offset = offset case * MatrixSelector : s . Offset = offset case * SubqueryExpr : s . Offset = offset default : p . errorf ( " " , e ) } } return e } 
func ( p * parser ) subqueryOrRangeSelector ( expr Expr , checkRange bool ) Expr { ctx := " " if checkRange { ctx = " " } p . next ( ) var erange time . Duration var err error erangeStr := p . expect ( ItemDuration , ctx ) . val erange , err = parseDuration ( erangeStr ) if err != nil { p . error ( err ) } var itm item if checkRange { itm = p . expectOneOf ( ItemRightBracket , ItemColon , ctx ) if itm . typ == ItemRightBracket { if ! ok { p . errorf ( " " , expr ) } return & MatrixSelector { Name : vs . Name , LabelMatchers : vs . LabelMatchers , Range : erange , } } } else { itm = p . expect ( ItemColon , ctx ) } itm = p . expectOneOf ( ItemRightBracket , ItemDuration , ctx ) if itm . typ == ItemDuration { estepStr := itm . val estep , err = parseDuration ( estepStr ) if err != nil { p . error ( err ) } p . expect ( ItemRightBracket , ctx ) } return & SubqueryExpr { Expr : expr , Range : erange , Step : estep , } } 
func ( p * parser ) number ( val string ) float64 { n , err := strconv . ParseInt ( val , 0 , 64 ) f := float64 ( n ) if err != nil { f , err = strconv . ParseFloat ( val , 64 ) } if err != nil { p . errorf ( " " , err ) } return f } 
func ( p * parser ) primaryExpr ( ) Expr { switch t := p . next ( ) ; { case t . typ == ItemNumber : f := p . number ( t . val ) return & NumberLiteral { f } case t . typ == ItemString : return & StringLiteral { p . unquoteString ( t . val ) } case t . typ == ItemLeftBrace : return p . VectorSelector ( " " ) case t . typ == ItemIdentifier : } fallthrough case t . typ == ItemMetricIdentifier : return p . VectorSelector ( t . val ) case t . typ . isAggregator ( ) : p . backup ( ) return p . aggrExpr ( ) default : p . errorf ( " " ) } return nil } 
func ( p * parser ) labels ( ) [ ] string { const ctx = " " p . expect ( ItemLeftParen , ctx ) labels := [ ] string { } if p . peek ( ) . typ != ItemRightParen { for { id := p . next ( ) if ! isLabel ( id . val ) { p . errorf ( " " , id . desc ( ) , ctx ) } labels = append ( labels , id . val ) if p . peek ( ) . typ != ItemComma { break } p . next ( ) } } p . expect ( ItemRightParen , ctx ) return labels } 
func ( p * parser ) aggrExpr ( ) * AggregateExpr { const ctx = " " agop := p . next ( ) if ! agop . typ . isAggregator ( ) { p . errorf ( " " , agop ) } var grouping [ ] string var without bool modifiersFirst := false if t := p . peek ( ) . typ ; t == ItemBy || t == ItemWithout { if t == ItemWithout { without = true } p . next ( ) grouping = p . labels ( ) modifiersFirst = true } p . expect ( ItemLeftParen , ctx ) var param Expr if agop . typ . isAggregatorWithParam ( ) { param = p . expr ( ) p . expect ( ItemComma , ctx ) } e := p . expr ( ) p . expect ( ItemRightParen , ctx ) if ! modifiersFirst { if t := p . peek ( ) . typ ; t == ItemBy || t == ItemWithout { if len ( grouping ) > 0 { p . errorf ( " " ) } if t == ItemWithout { without = true } p . next ( ) grouping = p . labels ( ) } } return & AggregateExpr { Op : agop . typ , Expr : e , Param : param , Grouping : grouping , Without : without , } } 
func ( p * parser ) call ( name string ) * Call { const ctx = " " fn , exist := getFunction ( name ) if ! exist { p . errorf ( " " , name ) } p . expect ( ItemLeftParen , ctx ) return & Call { fn , nil } } var args [ ] Expr for { e := p . expr ( ) args = append ( args , e ) } p . next ( ) } return & Call { Func : fn , Args : args } } 
func ( p * parser ) labelSet ( ) labels . Labels { set := [ ] labels . Label { } for _ , lm := range p . labelMatchers ( ItemEQL ) { set = append ( set , labels . Label { Name : lm . Name , Value : lm . Value } ) } return labels . New ( set ... ) } 
func ( p * parser ) labelMatchers ( operators ... ItemType ) [ ] * labels . Matcher { const ctx = " " matchers := [ ] * labels . Matcher { } p . expect ( ItemLeftBrace , ctx ) return matchers } for { label := p . expect ( ItemIdentifier , ctx ) op := p . next ( ) . typ if ! op . isOperator ( ) { p . errorf ( " " , op ) } var validOp = false for _ , allowedOp := range operators { if op == allowedOp { validOp = true } } if ! validOp { p . errorf ( " " , operators , op ) } val := p . unquoteString ( p . expect ( ItemString , ctx ) . val ) switch op { case ItemEQL : matchType = labels . MatchEqual case ItemNEQ : matchType = labels . MatchNotEqual case ItemEQLRegex : matchType = labels . MatchRegexp case ItemNEQRegex : matchType = labels . MatchNotRegexp default : p . errorf ( " " , op ) } m , err := labels . NewMatcher ( matchType , label . val , val ) if err != nil { p . error ( err ) } matchers = append ( matchers , m ) if p . peek ( ) . typ == ItemIdentifier { p . errorf ( " " , p . peek ( ) . val ) } } p . next ( ) } } p . expect ( ItemRightBrace , ctx ) return matchers } 
func ( p * parser ) metric ( ) labels . Labels { name := " " var m labels . Labels t := p . peek ( ) . typ if t == ItemIdentifier || t == ItemMetricIdentifier { name = p . next ( ) . val t = p . peek ( ) . typ } if t != ItemLeftBrace && name == " " { p . errorf ( " " ) } if t == ItemLeftBrace { m = p . labelSet ( ) } if name != " " { m = append ( m , labels . Label { Name : labels . MetricName , Value : name } ) sort . Sort ( m ) } return m } 
func ( p * parser ) offset ( ) time . Duration { const ctx = " " p . next ( ) offi := p . expect ( ItemDuration , ctx ) offset , err := parseDuration ( offi . val ) if err != nil { p . error ( err ) } return offset } 
func ( p * parser ) VectorSelector ( name string ) * VectorSelector { var matchers [ ] * labels . Matcher } } } if err != nil { panic ( err ) } matchers = append ( matchers , m ) } if len ( matchers ) == 0 { p . errorf ( " " ) } for _ , lm := range matchers { if ! lm . Matches ( " " ) { notEmpty = true break } } if ! notEmpty { p . errorf ( " " ) } return & VectorSelector { Name : name , LabelMatchers : matchers , } } 
func ( p * parser ) expectType ( node Node , want ValueType , context string ) { t := p . checkType ( node ) if t != want { p . errorf ( " " , documentedType ( want ) , context , documentedType ( t ) ) } } 
func ( p * parser ) checkType ( node Node ) ( typ ValueType ) { case Expr : typ = n . Type ( ) default : p . errorf ( " " , node ) } if ty == ValueTypeNone { p . errorf ( " " , documentedType ( ty ) ) } case Expressions : for _ , e := range n { ty := p . checkType ( e ) if ty == ValueTypeNone { p . errorf ( " " , documentedType ( ty ) ) } } case * AggregateExpr : if ! n . Op . isAggregator ( ) { p . errorf ( " " , n . Op ) } p . expectType ( n . Expr , ValueTypeVector , " " ) if n . Op == ItemTopK || n . Op == ItemBottomK || n . Op == ItemQuantile { p . expectType ( n . Param , ValueTypeScalar , " " ) } if n . Op == ItemCountValues { p . expectType ( n . Param , ValueTypeString , " " ) } case * BinaryExpr : lt := p . checkType ( n . LHS ) rt := p . checkType ( n . RHS ) if ! n . Op . isOperator ( ) { p . errorf ( " " , n . Op ) } if ( lt != ValueTypeScalar && lt != ValueTypeVector ) || ( rt != ValueTypeScalar && rt != ValueTypeVector ) { p . errorf ( " " ) } if ( lt != ValueTypeVector || rt != ValueTypeVector ) && n . VectorMatching != nil { if len ( n . VectorMatching . MatchingLabels ) > 0 { p . errorf ( " " ) } n . VectorMatching = nil } else { } if n . VectorMatching . Card != CardManyToMany { p . errorf ( " " ) } } } if ( lt == ValueTypeScalar || rt == ValueTypeScalar ) && n . Op . isSetOperator ( ) { p . errorf ( " " , n . Op ) } case * Call : nargs := len ( n . Func . ArgTypes ) if n . Func . Variadic == 0 { if nargs != len ( n . Args ) { p . errorf ( " " , nargs , n . Func . Name , len ( n . Args ) ) } } else { na := nargs - 1 if na > len ( n . Args ) { p . errorf ( " " , na , n . Func . Name , len ( n . Args ) ) } else if nargsmax := na + n . Func . Variadic ; n . Func . Variadic > 0 && nargsmax < len ( n . Args ) { p . errorf ( " " , nargsmax , n . Func . Name , len ( n . Args ) ) } } for i , arg := range n . Args { if i >= len ( n . Func . ArgTypes ) { i = len ( n . Func . ArgTypes ) - 1 } p . expectType ( arg , n . Func . ArgTypes [ i ] , fmt . Sprintf ( " " , n . Func . Name ) ) } case * ParenExpr : p . checkType ( n . Expr ) case * UnaryExpr : if n . Op != ItemADD && n . Op != ItemSUB { p . errorf ( " " ) } if t := p . checkType ( n . Expr ) ; t != ValueTypeScalar && t != ValueTypeVector { p . errorf ( " " , documentedType ( t ) ) } case * SubqueryExpr : ty := p . checkType ( n . Expr ) if ty != ValueTypeVector { p . errorf ( " " , ty , n . String ( ) ) } case * NumberLiteral , * MatrixSelector , * StringLiteral , * VectorSelector : } return } 
func ( s * Storage ) Appender ( ) ( storage . Appender , error ) { return & timestampTracker { storage : s , } , nil } 
func ( t * timestampTracker ) Add ( _ labels . Labels , ts int64 , v float64 ) ( uint64 , error ) { t . samples ++ if ts > t . highestTimestamp { t . highestTimestamp = ts } return 0 , nil } 
func ( t * timestampTracker ) AddFast ( l labels . Labels , _ uint64 , ts int64 , v float64 ) error { _ , err := t . Add ( l , ts , v ) return err } 
func ( t * timestampTracker ) Commit ( ) error { t . storage . samplesIn . incr ( t . samples ) samplesIn . Add ( float64 ( t . samples ) ) highestTimestamp . Set ( float64 ( t . highestTimestamp / 1000 ) ) return nil } 
func ( p * problems ) Add ( mf dto . MetricFamily , text string ) { * p = append ( * p , Problem { Metric : mf . GetName ( ) , Text : text , } ) } 
func ( l * Linter ) Lint ( ) ( [ ] Problem , error ) { var problems [ ] Problem var mf dto . MetricFamily for { if err := d . Decode ( & mf ) ; err != nil { if err == io . EOF { break } return nil , err } problems = append ( problems , lint ( mf ) ... ) } } return problems [ i ] . Text < problems [ j ] . Text } ) return problems , nil } 
func lint ( mf dto . MetricFamily ) [ ] Problem { fns := [ ] func ( mf dto . MetricFamily ) [ ] Problem { lintHelp , lintMetricUnits , lintCounter , lintHistogramSummaryReserved , } var problems [ ] Problem for _ , fn := range fns { problems = append ( problems , fn ( mf ) ... ) } } 
func lintHelp ( mf dto . MetricFamily ) [ ] Problem { var problems problems } return problems } 
func lintMetricUnits ( mf dto . MetricFamily ) [ ] Problem { var problems problems unit , base , ok := metricUnits ( * mf . Name ) if ! ok { } } problems . Add ( mf , fmt . Sprintf ( " " , base , unit ) ) return problems } 
func lintCounter ( mf dto . MetricFamily ) [ ] Problem { var problems problems isCounter := mf . GetType ( ) == dto . MetricType_COUNTER isUntyped := mf . GetType ( ) == dto . MetricType_UNTYPED hasTotalSuffix := strings . HasSuffix ( mf . GetName ( ) , " " ) switch { case isCounter && ! hasTotalSuffix : problems . Add ( mf , `counter metrics should have "_total" suffix` ) case ! isUntyped && ! isCounter && hasTotalSuffix : problems . Add ( mf , `non-counter metrics should not have "_total" suffix` ) } return problems } 
func lintHistogramSummaryReserved ( mf dto . MetricFamily ) [ ] Problem { if t == dto . MetricType_UNTYPED { return nil } var problems problems isHistogram := t == dto . MetricType_HISTOGRAM isSummary := t == dto . MetricType_SUMMARY n := mf . GetName ( ) if ! isHistogram && strings . HasSuffix ( n , " " ) { problems . Add ( mf , `non-histogram metrics should not have "_bucket" suffix` ) } if ! isHistogram && ! isSummary && strings . HasSuffix ( n , " " ) { problems . Add ( mf , `non-histogram and non-summary metrics should not have "_count" suffix` ) } if ! isHistogram && ! isSummary && strings . HasSuffix ( n , " " ) { problems . Add ( mf , `non-histogram and non-summary metrics should not have "_sum" suffix` ) } for _ , m := range mf . GetMetric ( ) { for _ , l := range m . GetLabel ( ) { ln := l . GetName ( ) if ! isHistogram && ln == " " { problems . Add ( mf , `non-histogram metrics should not have "le" label` ) } if ! isSummary && ln == " " { problems . Add ( mf , `non-summary metrics should not have "quantile" label` ) } } } return problems } 
func metricUnits ( m string ) ( unit string , base string , ok bool ) { ss := strings . Split ( m , " " ) for _ , u := range baseUnits { } } } } return " " , " " , false } 
func NewClient ( logger log . Logger , address string , transport string , timeout time . Duration , prefix string ) * Client { if logger == nil { logger = log . NewNopLogger ( ) } return & Client { logger : logger , address : address , transport : transport , timeout : timeout , prefix : prefix , } } 
func ( c * Client ) Write ( samples model . Samples ) error { conn , err := net . DialTimeout ( c . transport , c . address , c . timeout ) if err != nil { return err } defer conn . Close ( ) var buf bytes . Buffer for _ , s := range samples { k := pathFromMetric ( s . Metric , c . prefix ) t := float64 ( s . Timestamp . UnixNano ( ) ) / 1e9 v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) continue } fmt . Fprintf ( & buf , " \n " , k , v , t ) } _ , err = conn . Write ( buf . Bytes ( ) ) return err } 
func New ( minSize , maxSize int , factor float64 , makeFunc func ( int ) interface { } ) * Pool { if minSize < 1 { panic ( " " ) } if maxSize < 1 { panic ( " " ) } if factor < 1 { panic ( " " ) } var sizes [ ] int for s := minSize ; s <= maxSize ; s = int ( float64 ( s ) * factor ) { sizes = append ( sizes , s ) } p := & Pool { buckets : make ( [ ] sync . Pool , len ( sizes ) ) , sizes : sizes , make : makeFunc , } return p } 
func ( p * Pool ) Get ( sz int ) interface { } { for i , bktSize := range p . sizes { if sz > bktSize { continue } b := p . buckets [ i ] . Get ( ) if b == nil { b = p . make ( bktSize ) } return b } return p . make ( sz ) } 
func ( p * Pool ) Put ( s interface { } ) { slice := reflect . ValueOf ( s ) if slice . Kind ( ) != reflect . Slice { panic ( fmt . Sprintf ( " " , slice ) ) } for i , size := range p . sizes { if slice . Cap ( ) > size { continue } p . buckets [ i ] . Put ( slice . Slice ( 0 , 0 ) . Interface ( ) ) return } } 
func ( p Point ) MarshalJSON ( ) ( [ ] byte , error ) { v := strconv . FormatFloat ( p . V , 'f' , - 1 , 64 ) return json . Marshal ( [ ... ] interface { } { float64 ( p . T ) / 1000 , v } ) } 
func ( vec Vector ) ContainsSameLabelset ( ) bool { l := make ( map [ uint64 ] struct { } , len ( vec ) ) for _ , s := range vec { hash := s . Metric . Hash ( ) if _ , ok := l [ hash ] ; ok { return true } l [ hash ] = struct { } { } } return false } 
func ( m Matrix ) TotalSamples ( ) int { numSamples := 0 for _ , series := range m { numSamples += len ( series . Points ) } return numSamples } 
func ( m Matrix ) ContainsSameLabelset ( ) bool { l := make ( map [ uint64 ] struct { } , len ( m ) ) for _ , ss := range m { hash := ss . Metric . Hash ( ) if _ , ok := l [ hash ] ; ok { return true } l [ hash ] = struct { } { } } return false } 
func ( r * Result ) Vector ( ) ( Vector , error ) { if r . Err != nil { return nil , r . Err } v , ok := r . Value . ( Vector ) if ! ok { return nil , errors . New ( " " ) } return v , nil } 
func ( r * Result ) Scalar ( ) ( Scalar , error ) { if r . Err != nil { return Scalar { } , r . Err } v , ok := r . Value . ( Scalar ) if ! ok { return Scalar { } , errors . New ( " " ) } return v , nil } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if c . Region == " " { sess , err := session . NewSession ( ) if err != nil { return err } metadata := ec2metadata . New ( sess ) region , err := metadata . Region ( ) if err != nil { return errors . New ( " " ) } c . Region = region } for _ , f := range c . Filters { if len ( f . Values ) == 0 { return errors . New ( " " ) } } return nil } 
func NewDiscovery ( conf * SDConfig , logger log . Logger ) * Discovery { creds := credentials . NewStaticCredentials ( conf . AccessKey , string ( conf . SecretKey ) , " " ) if conf . AccessKey == " " && conf . SecretKey == " " { creds = nil } if logger == nil { logger = log . NewNopLogger ( ) } d := & Discovery { aws : & aws . Config { Endpoint : & conf . Endpoint , Region : & conf . Region , Credentials : creds , } , profile : conf . Profile , roleARN : conf . RoleARN , filters : conf . Filters , interval : time . Duration ( conf . RefreshInterval ) , port : conf . Port , } d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d } 
func ( d * discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { for c := time . Tick ( time . Duration ( d . refreshInterval ) * time . Second ) ; ; { var srvs map [ string ] [ ] string resp , err := http . Get ( fmt . Sprintf ( " " , d . address ) ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( d . refreshInterval ) * time . Second ) continue } dec := json . NewDecoder ( resp . Body ) err = dec . Decode ( & srvs ) resp . Body . Close ( ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( d . refreshInterval ) * time . Second ) continue } var tgs [ ] * targetgroup . Group for name := range srvs { if name == " " { continue } resp , err := http . Get ( fmt . Sprintf ( " " , d . address , name ) ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , name , " " , err ) break } tg , err := d . parseServiceNodes ( resp , name ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , name , " " , err ) break } tgs = append ( tgs , tg ) newSourceList [ tg . Source ] = true } } } d . oldSourceList = newSourceList if err == nil { } case <- ctx . Done ( ) : return } } } 
func NewQueueManager ( logger log . Logger , walDir string , samplesIn * ewmaRate , cfg config . QueueConfig , externalLabels labels . Labels , relabelConfigs [ ] * relabel . Config , client StorageClient , flushDeadline time . Duration ) * QueueManager { if logger == nil { logger = log . NewNopLogger ( ) } name := client . Name ( ) logger = log . With ( logger , " " , name ) t := & QueueManager { logger : logger , flushDeadline : flushDeadline , cfg : cfg , externalLabels : externalLabels , relabelConfigs : relabelConfigs , client : client , seriesLabels : make ( map [ uint64 ] [ ] prompb . Label ) , seriesSegmentIndexes : make ( map [ uint64 ] int ) , droppedSeries : make ( map [ uint64 ] struct { } ) , numShards : cfg . MinShards , reshardChan : make ( chan int ) , quit : make ( chan struct { } ) , samplesIn : samplesIn , samplesDropped : newEWMARate ( ewmaWeight , shardUpdateDuration ) , samplesOut : newEWMARate ( ewmaWeight , shardUpdateDuration ) , samplesOutDuration : newEWMARate ( ewmaWeight , shardUpdateDuration ) , } t . watcher = NewWALWatcher ( logger , name , t , walDir ) t . shards = t . newShards ( ) return t } 
func ( t * QueueManager ) Append ( s [ ] tsdb . RefSample ) bool { type enqueuable struct { ts prompb . TimeSeries ref uint64 } tempSamples := make ( [ ] enqueuable , 0 , len ( s ) ) t . seriesMtx . Lock ( ) for _ , sample := range s { t . samplesDropped . incr ( 1 ) if _ , ok := t . droppedSeries [ sample . Ref ] ; ! ok { level . Info ( t . logger ) . Log ( " " , " " , " " , sample . Ref ) } continue } tempSamples = append ( tempSamples , enqueuable { ts : prompb . TimeSeries { Labels : t . seriesLabels [ sample . Ref ] , Samples : [ ] prompb . Sample { prompb . Sample { Value : float64 ( sample . V ) , Timestamp : sample . T , } , } , } , ref : sample . Ref , } ) } t . seriesMtx . Unlock ( ) outer : for _ , sample := range tempSamples { for { select { case <- t . quit : return false default : } if t . shards . enqueue ( sample . ref , sample . ts ) { continue outer } t . enqueueRetriesMetric . Inc ( ) time . Sleep ( time . Duration ( backoff ) ) backoff = backoff * 2 if backoff > t . cfg . MaxBackoff { backoff = t . cfg . MaxBackoff } } } return true } 
func ( t * QueueManager ) Start ( ) { t . highestSentTimestampMetric = & maxGauge { Gauge : queueHighestSentTimestamp . WithLabelValues ( name ) , } t . pendingSamplesMetric = queuePendingSamples . WithLabelValues ( name ) t . enqueueRetriesMetric = enqueueRetriesTotal . WithLabelValues ( name ) t . droppedSamplesTotal = droppedSamplesTotal . WithLabelValues ( name ) t . numShardsMetric = numShards . WithLabelValues ( name ) t . failedSamplesTotal = failedSamplesTotal . WithLabelValues ( name ) t . sentBatchDuration = sentBatchDuration . WithLabelValues ( name ) t . succeededSamplesTotal = succeededSamplesTotal . WithLabelValues ( name ) t . retriedSamplesTotal = retriedSamplesTotal . WithLabelValues ( name ) t . shardCapacity = shardCapacity . WithLabelValues ( name ) t . pendingSamplesMetric . Set ( 0 ) t . shards . start ( t . numShards ) t . watcher . Start ( ) t . wg . Add ( 2 ) go t . updateShardsLoop ( ) go t . reshardLoop ( ) } 
func ( t * QueueManager ) Stop ( ) { level . Info ( t . logger ) . Log ( " " , " " ) defer level . Info ( t . logger ) . Log ( " " , " " ) close ( t . quit ) t . wg . Wait ( ) t . watcher . Stop ( ) defer t . seriesMtx . Unlock ( ) for _ , labels := range t . seriesLabels { release ( labels ) } queueHighestSentTimestamp . DeleteLabelValues ( name ) queuePendingSamples . DeleteLabelValues ( name ) enqueueRetriesTotal . DeleteLabelValues ( name ) droppedSamplesTotal . DeleteLabelValues ( name ) numShards . DeleteLabelValues ( name ) failedSamplesTotal . DeleteLabelValues ( name ) sentBatchDuration . DeleteLabelValues ( name ) succeededSamplesTotal . DeleteLabelValues ( name ) retriedSamplesTotal . DeleteLabelValues ( name ) shardCapacity . DeleteLabelValues ( name ) } 
func ( t * QueueManager ) StoreSeries ( series [ ] tsdb . RefSeries , index int ) { defer t . seriesMtx . Unlock ( ) temp := make ( map [ uint64 ] [ ] prompb . Label , len ( series ) ) for _ , s := range series { ls := processExternalLabels ( s . Labels , t . externalLabels ) rl := relabel . Process ( ls , t . relabelConfigs ... ) if len ( rl ) == 0 { t . droppedSeries [ s . Ref ] = struct { } { } continue } temp [ s . Ref ] = labelsToLabelsProto ( rl ) } for ref , labels := range temp { t . seriesSegmentIndexes [ ref ] = index } t . seriesLabels [ ref ] = labels } } 
func ( t * QueueManager ) SeriesReset ( index int ) { t . seriesMtx . Lock ( ) defer t . seriesMtx . Unlock ( ) release ( t . seriesLabels [ k ] ) delete ( t . seriesLabels , k ) } } } 
func processExternalLabels ( ls tsdbLabels . Labels , externalLabels labels . Labels ) labels . Labels { i , j , result := 0 , 0 , make ( labels . Labels , 0 , len ( ls ) + len ( externalLabels ) ) for i < len ( ls ) && j < len ( externalLabels ) { if ls [ i ] . Name < externalLabels [ j ] . Name { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i ++ } else if ls [ i ] . Name > externalLabels [ j ] . Name { result = append ( result , externalLabels [ j ] ) j ++ } else { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i ++ j ++ } } for ; i < len ( ls ) ; i ++ { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) } result = append ( result , externalLabels [ j : ] ... ) return result } 
func ( s * shards ) start ( n int ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) newQueues := make ( [ ] chan prompb . TimeSeries , n ) for i := 0 ; i < n ; i ++ { newQueues [ i ] = make ( chan prompb . TimeSeries , s . qm . cfg . Capacity ) } s . queues = newQueues var hardShutdownCtx context . Context hardShutdownCtx , s . hardShutdown = context . WithCancel ( context . Background ( ) ) s . softShutdown = make ( chan struct { } ) s . running = int32 ( n ) s . done = make ( chan struct { } ) for i := 0 ; i < n ; i ++ { go s . runShard ( hardShutdownCtx , i , newQueues [ i ] ) } s . qm . numShardsMetric . Set ( float64 ( n ) ) } 
func ( s * shards ) stop ( ) { close ( s . softShutdown ) s . mtx . RUnlock ( ) defer s . mtx . Unlock ( ) for _ , queue := range s . queues { close ( queue ) } select { case <- s . done : return case <- time . After ( s . qm . flushDeadline ) : level . Error ( s . qm . logger ) . Log ( " " , " " ) } <- s . done } 
func ( s * shards ) enqueue ( ref uint64 , sample prompb . TimeSeries ) bool { s . mtx . RLock ( ) defer s . mtx . RUnlock ( ) select { case <- s . softShutdown : return false default : } shard := uint64 ( ref ) % uint64 ( len ( s . queues ) ) select { case <- s . softShutdown : return false case s . queues [ shard ] <- sample : return true } } 
func ( s * shards ) sendSamplesWithBackoff ( ctx context . Context , samples [ ] prompb . TimeSeries ) error { backoff := s . qm . cfg . MinBackoff req , highest , err := buildWriteRequest ( samples ) if err != nil { } for { select { case <- ctx . Done ( ) : return ctx . Err ( ) default : } begin := time . Now ( ) err := s . qm . client . Store ( ctx , req ) s . qm . sentBatchDuration . Observe ( time . Since ( begin ) . Seconds ( ) ) if err == nil { s . qm . succeededSamplesTotal . Add ( float64 ( len ( samples ) ) ) s . qm . highestSentTimestampMetric . Set ( float64 ( highest / 1000 ) ) return nil } if _ , ok := err . ( recoverableError ) ; ! ok { return err } s . qm . retriedSamplesTotal . Add ( float64 ( len ( samples ) ) ) level . Debug ( s . qm . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( backoff ) ) backoff = backoff * 2 if backoff > s . qm . cfg . MaxBackoff { backoff = s . qm . cfg . MaxBackoff } } } 
func ( c * Role ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { if err := unmarshal ( ( * string ) ( c ) ) ; err != nil { return err } switch * c { case RoleNode , RolePod , RoleService , RoleEndpoint , RoleIngress : return nil default : return errors . Errorf ( " " , * c ) } } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = SDConfig { } type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if c . Role == " " { return errors . Errorf ( " " ) } err = c . HTTPClientConfig . Validate ( ) if err != nil { return err } if c . APIServer . URL == nil && ! reflect . DeepEqual ( c . HTTPClientConfig , config_util . HTTPClientConfig { } ) { return errors . Errorf ( " " ) } return nil } 
func ( c * NamespaceDiscovery ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = NamespaceDiscovery { } type plain NamespaceDiscovery return unmarshal ( ( * plain ) ( c ) ) } 
func New ( l log . Logger , conf * SDConfig ) ( * Discovery , error ) { if l == nil { l = log . NewNopLogger ( ) } var ( kcfg * rest . Config err error ) if conf . APIServer . URL == nil { if err != nil { return nil , err } level . Info ( l ) . Log ( " " , " " ) } else { rt , err := config_util . NewRoundTripperFromConfig ( conf . HTTPClientConfig , " " ) if err != nil { return nil , err } kcfg = & rest . Config { Host : conf . APIServer . String ( ) , Transport : rt , } } kcfg . UserAgent = " " c , err := kubernetes . NewForConfig ( kcfg ) if err != nil { return nil , err } return & Discovery { client : c , logger : l , role : conf . Role , namespaceDiscovery : & conf . NamespaceDiscovery , discoverers : make ( [ ] discoverer , 0 ) , } , nil } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { d . Lock ( ) namespaces := d . getNamespaces ( ) switch d . role { case RoleEndpoint : for _ , namespace := range namespaces { e := d . client . CoreV1 ( ) . Endpoints ( namespace ) elw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return e . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return e . Watch ( options ) } , } s := d . client . CoreV1 ( ) . Services ( namespace ) slw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return s . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return s . Watch ( options ) } , } p := d . client . CoreV1 ( ) . Pods ( namespace ) plw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return p . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return p . Watch ( options ) } , } eps := NewEndpoints ( log . With ( d . logger , " " , " " ) , cache . NewSharedInformer ( slw , & apiv1 . Service { } , resyncPeriod ) , cache . NewSharedInformer ( elw , & apiv1 . Endpoints { } , resyncPeriod ) , cache . NewSharedInformer ( plw , & apiv1 . Pod { } , resyncPeriod ) , ) d . discoverers = append ( d . discoverers , eps ) go eps . endpointsInf . Run ( ctx . Done ( ) ) go eps . serviceInf . Run ( ctx . Done ( ) ) go eps . podInf . Run ( ctx . Done ( ) ) } case RolePod : for _ , namespace := range namespaces { p := d . client . CoreV1 ( ) . Pods ( namespace ) plw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return p . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return p . Watch ( options ) } , } pod := NewPod ( log . With ( d . logger , " " , " " ) , cache . NewSharedInformer ( plw , & apiv1 . Pod { } , resyncPeriod ) , ) d . discoverers = append ( d . discoverers , pod ) go pod . informer . Run ( ctx . Done ( ) ) } case RoleService : for _ , namespace := range namespaces { s := d . client . CoreV1 ( ) . Services ( namespace ) slw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return s . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return s . Watch ( options ) } , } svc := NewService ( log . With ( d . logger , " " , " " ) , cache . NewSharedInformer ( slw , & apiv1 . Service { } , resyncPeriod ) , ) d . discoverers = append ( d . discoverers , svc ) go svc . informer . Run ( ctx . Done ( ) ) } case RoleIngress : for _ , namespace := range namespaces { i := d . client . ExtensionsV1beta1 ( ) . Ingresses ( namespace ) ilw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return i . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return i . Watch ( options ) } , } ingress := NewIngress ( log . With ( d . logger , " " , " " ) , cache . NewSharedInformer ( ilw , & extensionsv1beta1 . Ingress { } , resyncPeriod ) , ) d . discoverers = append ( d . discoverers , ingress ) go ingress . informer . Run ( ctx . Done ( ) ) } case RoleNode : nlw := & cache . ListWatch { ListFunc : func ( options metav1 . ListOptions ) ( runtime . Object , error ) { return d . client . CoreV1 ( ) . Nodes ( ) . List ( options ) } , WatchFunc : func ( options metav1 . ListOptions ) ( watch . Interface , error ) { return d . client . CoreV1 ( ) . Nodes ( ) . Watch ( options ) } , } node := NewNode ( log . With ( d . logger , " " , " " ) , cache . NewSharedInformer ( nlw , & apiv1 . Node { } , resyncPeriod ) , ) d . discoverers = append ( d . discoverers , node ) go node . informer . Run ( ctx . Done ( ) ) default : level . Error ( d . logger ) . Log ( " " , " " , " " , d . role ) } var wg sync . WaitGroup for _ , dd := range d . discoverers { wg . Add ( 1 ) go func ( d discoverer ) { defer wg . Done ( ) d . Run ( ctx , ch ) } ( dd ) } d . Unlock ( ) wg . Wait ( ) <- ctx . Done ( ) } 
func compileCORSRegexString ( s string ) ( * regexp . Regexp , error ) { r , err := relabel . NewRegexp ( s ) if err != nil { return nil , err } return r . Regexp , nil } 
func computeExternalURL ( u , listenAddr string ) ( * url . URL , error ) { if u == " " { hostname , err := os . Hostname ( ) if err != nil { return nil , err } _ , port , err := net . SplitHostPort ( listenAddr ) if err != nil { return nil , err } u = fmt . Sprintf ( " " , hostname , port ) } if startsOrEndsWithQuote ( u ) { return nil , errors . New ( " " ) } eu , err := url . Parse ( u ) if err != nil { return nil , err } ppref := strings . TrimRight ( eu . Path , " " ) if ppref != " " && ! strings . HasPrefix ( ppref , " " ) { ppref = " " + ppref } eu . Path = ppref return eu , nil } 
func sendAlerts ( s sender , externalURL string ) rules . NotifyFunc { return func ( ctx context . Context , expr string , alerts ... * rules . Alert ) { var res [ ] * notifier . Alert for _ , alert := range alerts { a := & notifier . Alert { StartsAt : alert . FiredAt , Labels : alert . Labels , Annotations : alert . Annotations , GeneratorURL : externalURL + strutil . TableLinkForExpression ( expr ) , } if ! alert . ResolvedAt . IsZero ( ) { a . EndsAt = alert . ResolvedAt } else { a . EndsAt = alert . ValidUntil } res = append ( res , a ) } if len ( alerts ) > 0 { s . Send ( res ... ) } } } 
func ( g * RuleGroups ) Validate ( ) ( errs [ ] error ) { set := map [ string ] struct { } { } for _ , g := range g . Groups { if g . Name == " " { errs = append ( errs , errors . Errorf ( " " ) ) } if _ , ok := set [ g . Name ] ; ok { errs = append ( errs , errors . Errorf ( " \" \" " , g . Name ) , ) } set [ g . Name ] = struct { } { } for i , r := range g . Rules { for _ , err := range r . Validate ( ) { var ruleName string if r . Alert != " " { ruleName = r . Alert } else { ruleName = r . Record } errs = append ( errs , & Error { Group : g . Name , Rule : i , RuleName : ruleName , Err : err , } ) } } } return errs } 
func ( r * Rule ) Validate ( ) ( errs [ ] error ) { if r . Record != " " && r . Alert != " " { errs = append ( errs , errors . Errorf ( " " ) ) } if r . Record == " " && r . Alert == " " { errs = append ( errs , errors . Errorf ( " " ) ) } if r . Expr == " " { errs = append ( errs , errors . Errorf ( " " ) ) } else if _ , err := promql . ParseExpr ( r . Expr ) ; err != nil { errs = append ( errs , errors . Errorf ( " " , err ) ) } if r . Record != " " { if len ( r . Annotations ) > 0 { errs = append ( errs , errors . Errorf ( " " ) ) } if r . For != 0 { errs = append ( errs , errors . Errorf ( " " ) ) } if ! model . IsValidMetricName ( model . LabelValue ( r . Record ) ) { errs = append ( errs , errors . Errorf ( " " , r . Record ) ) } } for k , v := range r . Labels { if ! model . LabelName ( k ) . IsValid ( ) { errs = append ( errs , errors . Errorf ( " " , k ) ) } if ! model . LabelValue ( v ) . IsValid ( ) { errs = append ( errs , errors . Errorf ( " " , v ) ) } } for k := range r . Annotations { if ! model . LabelName ( k ) . IsValid ( ) { errs = append ( errs , errors . Errorf ( " " , k ) ) } } errs = append ( errs , testTemplateParsing ( r ) ... ) return errs } 
func Parse ( content [ ] byte ) ( * RuleGroups , [ ] error ) { var groups RuleGroups if err := yaml . UnmarshalStrict ( content , & groups ) ; err != nil { return nil , [ ] error { err } } return & groups , groups . Validate ( ) } 
func ParseFile ( file string ) ( * RuleGroups , [ ] error ) { b , err := ioutil . ReadFile ( file ) if err != nil { return nil , [ ] error { err } } return Parse ( b ) } 
func TableLinkForExpression ( expr string ) string { escapedExpression := url . QueryEscape ( expr ) return fmt . Sprintf ( " " , escapedExpression ) } 
func GraphLinkForExpression ( expr string ) string { escapedExpression := url . QueryEscape ( expr ) return fmt . Sprintf ( " " , escapedExpression ) } 
func NewFanout ( logger log . Logger , primary Storage , secondaries ... Storage ) Storage { return & fanout { logger : logger , primary : primary , secondaries : secondaries , } } 
func ( f * fanout ) StartTime ( ) ( int64 , error ) { if err != nil { return int64 ( model . Latest ) , err } for _ , storage := range f . secondaries { t , err := storage . StartTime ( ) if err != nil { return int64 ( model . Latest ) , err } if t < firstTime { firstTime = t } } return firstTime , nil } 
func ( f * fanout ) Close ( ) error { if err := f . primary . Close ( ) ; err != nil { return err } for _ , storage := range f . secondaries { if err := storage . Close ( ) ; err != nil { lastErr = err } } return lastErr } 
func NewMergeQuerier ( primaryQuerier Querier , queriers [ ] Querier ) Querier { filtered := make ( [ ] Querier , 0 , len ( queriers ) ) for _ , querier := range queriers { if querier != NoopQuerier ( ) { filtered = append ( filtered , querier ) } } setQuerierMap := make ( map [ SeriesSet ] Querier ) failedQueriers := make ( map [ Querier ] struct { } ) switch len ( filtered ) { case 0 : return NoopQuerier ( ) case 1 : return filtered [ 0 ] default : return & mergeQuerier { primaryQuerier : primaryQuerier , queriers : filtered , failedQueriers : failedQueriers , setQuerierMap : setQuerierMap , } } } 
func ( q * mergeQuerier ) Select ( params * SelectParams , matchers ... * labels . Matcher ) ( SeriesSet , Warnings , error ) { seriesSets := make ( [ ] SeriesSet , 0 , len ( q . queriers ) ) var warnings Warnings for _ , querier := range q . queriers { set , wrn , err := querier . Select ( params , matchers ... ) q . setQuerierMap [ set ] = querier if wrn != nil { warnings = append ( warnings , wrn ... ) } if err != nil { q . failedQueriers [ querier ] = struct { } { } continue } else { return nil , nil , err } } seriesSets = append ( seriesSets , set ) } return NewMergeSeriesSet ( seriesSets , q ) , warnings , nil } 
func ( q * mergeQuerier ) LabelValues ( name string ) ( [ ] string , error ) { var results [ ] [ ] string for _ , querier := range q . queriers { values , err := querier . LabelValues ( name ) if err != nil { return nil , err } results = append ( results , values ) } return mergeStringSlices ( results ) , nil } 
func ( q * mergeQuerier ) LabelNames ( ) ( [ ] string , error ) { labelNamesMap := make ( map [ string ] struct { } ) for _ , b := range q . queriers { names , err := b . LabelNames ( ) if err != nil { return nil , errors . Wrap ( err , " " ) } for _ , name := range names { labelNamesMap [ name ] = struct { } { } } } labelNames := make ( [ ] string , 0 , len ( labelNamesMap ) ) for name := range labelNamesMap { labelNames = append ( labelNames , name ) } sort . Strings ( labelNames ) return labelNames , nil } 
func ( q * mergeQuerier ) Close ( ) error { for _ , querier := range q . queriers { if err := querier . Close ( ) ; err != nil { lastErr = err } } return lastErr } 
func NewMergeSeriesSet ( sets [ ] SeriesSet , querier * mergeQuerier ) SeriesSet { if len ( sets ) == 1 { return sets [ 0 ] } for _ , set := range sets { if set == nil { continue } if set . Next ( ) { heap . Push ( & h , set ) } } return & mergeSeriesSet { heap : h , sets : sets , querier : querier , } } 
func escape ( tv model . LabelValue ) string { length := len ( tv ) result := bytes . NewBuffer ( make ( [ ] byte , 0 , length ) ) for i := 0 ; i < length ; i ++ { b := tv [ i ] switch { } } return result . String ( ) } 
func NewAlertingRule ( name string , vec promql . Expr , hold time . Duration , labels , annotations , externalLabels labels . Labels , restored bool , logger log . Logger , ) * AlertingRule { el := make ( map [ string ] string , len ( externalLabels ) ) for _ , lbl := range externalLabels { el [ lbl . Name ] = lbl . Value } return & AlertingRule { name : name , vector : vec , holdDuration : hold , labels : labels , annotations : annotations , externalLabels : el , health : HealthUnknown , active : map [ uint64 ] * Alert { } , logger : logger , restored : restored , } } 
func ( r * AlertingRule ) SetLastError ( err error ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . lastError = err } 
func ( r * AlertingRule ) LastError ( ) error { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . lastError } 
func ( r * AlertingRule ) SetHealth ( health RuleHealth ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . health = health } 
func ( r * AlertingRule ) Health ( ) RuleHealth { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . health } 
func ( r * AlertingRule ) forStateSample ( alert * Alert , ts time . Time , v float64 ) promql . Sample { lb := labels . NewBuilder ( r . labels ) for _ , l := range alert . Labels { lb . Set ( l . Name , l . Value ) } lb . Set ( labels . MetricName , alertForStateMetricName ) lb . Set ( labels . AlertName , r . name ) s := promql . Sample { Metric : lb . Labels ( ) , Point : promql . Point { T : timestamp . FromTime ( ts ) , V : v } , } return s } 
func ( r * AlertingRule ) SetEvaluationDuration ( dur time . Duration ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . evaluationDuration = dur } 
func ( r * AlertingRule ) GetEvaluationDuration ( ) time . Duration { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . evaluationDuration } 
func ( r * AlertingRule ) SetEvaluationTimestamp ( ts time . Time ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . evaluationTimestamp = ts } 
func ( r * AlertingRule ) GetEvaluationTimestamp ( ) time . Time { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . evaluationTimestamp } 
func ( r * AlertingRule ) Eval ( ctx context . Context , ts time . Time , query QueryFunc , externalURL * url . URL ) ( promql . Vector , error ) { res , err := query ( ctx , r . vector . String ( ) , ts ) if err != nil { r . SetHealth ( HealthBad ) r . SetLastError ( err ) return nil , err } r . mtx . Lock ( ) defer r . mtx . Unlock ( ) var vec promql . Vector for _ , smpl := range res { for _ , lbl := range smpl . Metric { l [ lbl . Name ] = lbl . Value } tmplData := template . AlertTemplateData ( l , r . externalLabels , smpl . V ) expand := func ( text string ) string { tmpl := template . NewTemplateExpander ( ctx , strings . Join ( append ( defs , text ) , " " ) , " " + r . Name ( ) , tmplData , model . Time ( timestamp . FromTime ( ts ) ) , template . QueryFunc ( query ) , externalURL , ) result , err := tmpl . Expand ( ) if err != nil { result = fmt . Sprintf ( " " , err ) level . Warn ( r . logger ) . Log ( " " , " " , " " , err , " " , tmplData ) } return result } lb := labels . NewBuilder ( smpl . Metric ) . Del ( labels . MetricName ) for _ , l := range r . labels { lb . Set ( l . Name , expand ( l . Value ) ) } lb . Set ( labels . AlertName , r . Name ( ) ) annotations := make ( labels . Labels , 0 , len ( r . annotations ) ) for _ , a := range r . annotations { annotations = append ( annotations , labels . Label { Name : a . Name , Value : expand ( a . Value ) } ) } lbs := lb . Labels ( ) h := lbs . Hash ( ) resultFPs [ h ] = struct { } { } alert . Annotations = annotations continue } r . active [ h ] = & Alert { Labels : lbs , Annotations : annotations , ActiveAt : ts , State : StatePending , Value : smpl . V , } } } if a . State != StateInactive { a . State = StateInactive a . ResolvedAt = ts } continue } if a . State == StatePending && ts . Sub ( a . ActiveAt ) >= r . holdDuration { a . State = StateFiring a . FiredAt = ts } if r . restored { vec = append ( vec , r . sample ( a , ts ) ) vec = append ( vec , r . forStateSample ( a , ts , float64 ( a . ActiveAt . Unix ( ) ) ) ) } } r . lastError = err return vec , nil } 
func ( r * AlertingRule ) State ( ) AlertState { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) maxState := StateInactive for _ , a := range r . active { if a . State > maxState { maxState = a . State } } return maxState } 
func ( r * AlertingRule ) ActiveAlerts ( ) [ ] * Alert { var res [ ] * Alert for _ , a := range r . currentAlerts ( ) { if a . ResolvedAt . IsZero ( ) { res = append ( res , a ) } } return res } 
func ( r * AlertingRule ) currentAlerts ( ) [ ] * Alert { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) alerts := make ( [ ] * Alert , 0 , len ( r . active ) ) for _ , a := range r . active { anew := * a alerts = append ( alerts , & anew ) } return alerts } 
func ( r * AlertingRule ) ForEachActiveAlert ( f func ( * Alert ) ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) for _ , a := range r . active { f ( a ) } } 
func ( r * AlertingRule ) HTMLSnippet ( pathPrefix string ) html_template . HTML { alertMetric := model . Metric { model . MetricNameLabel : alertMetricName , alertNameLabel : model . LabelValue ( r . name ) , } labelsMap := make ( map [ string ] string , len ( r . labels ) ) for _ , l := range r . labels { labelsMap [ l . Name ] = html_template . HTMLEscapeString ( l . Value ) } annotationsMap := make ( map [ string ] string , len ( r . annotations ) ) for _ , l := range r . annotations { annotationsMap [ l . Name ] = html_template . HTMLEscapeString ( l . Value ) } ar := rulefmt . Rule { Alert : fmt . Sprintf ( " " , pathPrefix + strutil . TableLinkForExpression ( alertMetric . String ( ) ) , r . name ) , Expr : fmt . Sprintf ( " " , pathPrefix + strutil . TableLinkForExpression ( r . vector . String ( ) ) , html_template . HTMLEscapeString ( r . vector . String ( ) ) ) , For : model . Duration ( r . holdDuration ) , Labels : labelsMap , Annotations : annotationsMap , } byt , err := yaml . Marshal ( ar ) if err != nil { return html_template . HTML ( fmt . Sprintf ( " " , html_template . HTMLEscapeString ( err . Error ( ) ) ) ) } return html_template . HTML ( byt ) } 
func ( a * Adapter ) refreshTargetGroups ( allTargetGroups map [ string ] [ ] * targetgroup . Group ) { tempGroups := generateTargetGroups ( allTargetGroups ) if ! reflect . DeepEqual ( a . groups , tempGroups ) { a . groups = tempGroups err := a . writeOutput ( ) if err != nil { level . Error ( log . With ( a . logger , " " , " " ) ) . Log ( " " , err ) } } } 
func ( a * Adapter ) writeOutput ( ) error { arr := mapToArray ( a . groups ) b , _ := json . MarshalIndent ( arr , " " , " " ) dir , _ := filepath . Split ( a . output ) tmpfile , err := ioutil . TempFile ( dir , " " ) if err != nil { return err } defer tmpfile . Close ( ) _ , err = tmpfile . Write ( b ) if err != nil { return err } err = os . Rename ( tmpfile . Name ( ) , a . output ) if err != nil { return err } return nil } 
func ( a * Adapter ) Run ( ) { go a . manager . Run ( ) a . manager . StartCustomProvider ( a . ctx , a . name , a . disc ) go a . runCustomSD ( a . ctx ) } 
func NewAdapter ( ctx context . Context , file string , name string , d discovery . Discoverer , logger log . Logger ) * Adapter { return & Adapter { ctx : ctx , disc : d , groups : make ( map [ string ] * customSD ) , manager : discovery . NewManager ( ctx , logger ) , output : file , name : name , logger : logger , } } 
func NewGroupMetrics ( reg prometheus . Registerer ) * Metrics { m := & Metrics { evalDuration : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Name : " " , Help : " " , } ) , evalFailures : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : " " , Help : " " , } ) , evalTotal : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : " " , Help : " " , } ) , iterationDuration : prometheus . NewSummary ( prometheus . SummaryOpts { Namespace : namespace , Name : " " , Help : " " , Objectives : map [ float64 ] float64 { 0.01 : 0.001 , 0.05 : 0.005 , 0.5 : 0.05 , 0.90 : 0.01 , 0.99 : 0.001 } , } ) , iterationsMissed : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : " " , Help : " " , } ) , iterationsScheduled : prometheus . NewCounter ( prometheus . CounterOpts { Namespace : namespace , Name : " " , Help : " " , } ) , groupLastEvalTime : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , groupLastDuration : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , groupRules : prometheus . NewGaugeVec ( prometheus . GaugeOpts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , } if reg != nil { reg . MustRegister ( m . evalDuration , m . evalFailures , m . evalTotal , m . iterationDuration , m . iterationsMissed , m . iterationsScheduled , m . groupLastEvalTime , m . groupLastDuration , m . groupRules , ) } return m } 
func EngineQueryFunc ( engine * promql . Engine , q storage . Queryable ) QueryFunc { return func ( ctx context . Context , qs string , t time . Time ) ( promql . Vector , error ) { q , err := engine . NewInstantQuery ( q , qs , t ) if err != nil { return nil , err } res := q . Exec ( ctx ) if res . Err != nil { return nil , res . Err } switch v := res . Value . ( type ) { case promql . Vector : return v , nil case promql . Scalar : return promql . Vector { promql . Sample { Point : promql . Point ( v ) , Metric : labels . Labels { } , } } , nil default : return nil , errors . New ( " " ) } } } 
func NewGroup ( name , file string , interval time . Duration , rules [ ] Rule , shouldRestore bool , opts * ManagerOptions ) * Group { metrics := opts . Metrics if metrics == nil { metrics = NewGroupMetrics ( opts . Registerer ) } metrics . groupLastEvalTime . WithLabelValues ( groupKey ( file , name ) ) metrics . groupLastDuration . WithLabelValues ( groupKey ( file , name ) ) metrics . groupRules . WithLabelValues ( groupKey ( file , name ) ) . Set ( float64 ( len ( rules ) ) ) return & Group { name : name , file : file , interval : interval , rules : rules , shouldRestore : shouldRestore , opts : opts , seriesInPreviousEval : make ( [ ] map [ string ] labels . Labels , len ( rules ) ) , done : make ( chan struct { } ) , terminated : make ( chan struct { } ) , logger : log . With ( opts . Logger , " " , name ) , metrics : metrics , } } 
func ( g * Group ) GetEvaluationDuration ( ) time . Duration { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluationDuration } 
func ( g * Group ) setEvaluationDuration ( dur time . Duration ) { g . metrics . groupLastDuration . WithLabelValues ( groupKey ( g . file , g . name ) ) . Set ( dur . Seconds ( ) ) g . mtx . Lock ( ) defer g . mtx . Unlock ( ) g . evaluationDuration = dur } 
func ( g * Group ) GetEvaluationTimestamp ( ) time . Time { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluationTimestamp } 
func ( g * Group ) setEvaluationTimestamp ( ts time . Time ) { g . metrics . groupLastEvalTime . WithLabelValues ( groupKey ( g . file , g . name ) ) . Set ( float64 ( ts . UnixNano ( ) ) / 1e9 ) g . mtx . Lock ( ) defer g . mtx . Unlock ( ) g . evaluationTimestamp = ts } 
func ( g * Group ) evalTimestamp ( ) time . Time { var ( offset = int64 ( g . hash ( ) % uint64 ( g . interval ) ) now = time . Now ( ) . UnixNano ( ) adjNow = now - offset base = adjNow - ( adjNow % int64 ( g . interval ) ) ) return time . Unix ( 0 , base + offset ) } 
func ( g * Group ) CopyState ( from * Group ) { g . evaluationDuration = from . evaluationDuration ruleMap := make ( map [ string ] [ ] int , len ( from . rules ) ) for fi , fromRule := range from . rules { nameAndLabels := nameAndLabels ( fromRule ) l := ruleMap [ nameAndLabels ] ruleMap [ nameAndLabels ] = append ( l , fi ) } for i , rule := range g . rules { nameAndLabels := nameAndLabels ( rule ) indexes := ruleMap [ nameAndLabels ] if len ( indexes ) == 0 { continue } fi := indexes [ 0 ] g . seriesInPreviousEval [ i ] = from . seriesInPreviousEval [ fi ] ruleMap [ nameAndLabels ] = indexes [ 1 : ] ar , ok := rule . ( * AlertingRule ) if ! ok { continue } far , ok := from . rules [ fi ] . ( * AlertingRule ) if ! ok { continue } for fp , a := range far . active { ar . active [ fp ] = a } } } 
func ( g * Group ) Eval ( ctx context . Context , ts time . Time ) { for i , rule := range g . rules { select { case <- g . done : return default : } func ( i int , rule Rule ) { sp , ctx := opentracing . StartSpanFromContext ( ctx , " " ) sp . SetTag ( " " , rule . Name ( ) ) defer func ( t time . Time ) { sp . Finish ( ) since := time . Since ( t ) g . metrics . evalDuration . Observe ( since . Seconds ( ) ) rule . SetEvaluationDuration ( since ) rule . SetEvaluationTimestamp ( t ) } ( time . Now ( ) ) g . metrics . evalTotal . Inc ( ) vector , err := rule . Eval ( ctx , ts , g . opts . QueryFunc , g . opts . ExternalURL ) if err != nil { } g . metrics . evalFailures . Inc ( ) return } if ar , ok := rule . ( * AlertingRule ) ; ok { ar . sendAlerts ( ctx , ts , g . opts . ResendDelay , g . interval , g . opts . NotifyFunc ) } var ( numOutOfOrder = 0 numDuplicates = 0 ) app , err := g . opts . Appendable . Appender ( ) if err != nil { level . Warn ( g . logger ) . Log ( " " , " " , " " , err ) return } seriesReturned := make ( map [ string ] labels . Labels , len ( g . seriesInPreviousEval [ i ] ) ) for _ , s := range vector { if _ , err := app . Add ( s . Metric , s . T , s . V ) ; err != nil { switch err { case storage . ErrOutOfOrderSample : numOutOfOrder ++ level . Debug ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) case storage . ErrDuplicateSampleForTimestamp : numDuplicates ++ level . Debug ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) default : level . Warn ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) } } else { seriesReturned [ s . Metric . String ( ) ] = s . Metric } } if numOutOfOrder > 0 { level . Warn ( g . logger ) . Log ( " " , " " , " " , numOutOfOrder ) } if numDuplicates > 0 { level . Warn ( g . logger ) . Log ( " " , " " , " " , numDuplicates ) } for metric , lset := range g . seriesInPreviousEval [ i ] { if _ , ok := seriesReturned [ metric ] ; ! ok { switch err { case nil : case storage . ErrOutOfOrderSample , storage . ErrDuplicateSampleForTimestamp : } } } if err := app . Commit ( ) ; err != nil { level . Warn ( g . logger ) . Log ( " " , " " , " " , err ) } else { g . seriesInPreviousEval [ i ] = seriesReturned } } ( i , rule ) } } 
func ( g * Group ) RestoreForState ( ts time . Time ) { maxtMS := int64 ( model . TimeFromUnixNano ( ts . UnixNano ( ) ) ) mintMS := int64 ( model . TimeFromUnixNano ( mint . UnixNano ( ) ) ) q , err := g . opts . TSDB . Querier ( g . opts . Context , mintMS , maxtMS ) if err != nil { level . Error ( g . logger ) . Log ( " " , " " , " " , err ) return } defer func ( ) { if err := q . Close ( ) ; err != nil { level . Error ( g . logger ) . Log ( " " , " " , " " , err ) } } ( ) for _ , rule := range g . Rules ( ) { alertRule , ok := rule . ( * AlertingRule ) if ! ok { continue } alertHoldDuration := alertRule . HoldDuration ( ) if alertHoldDuration < g . opts . ForGracePeriod { continue } alertRule . ForEachActiveAlert ( func ( a * Alert ) { smpl := alertRule . forStateSample ( a , time . Now ( ) , 0 ) var matchers [ ] * labels . Matcher for _ , l := range smpl . Metric { mt , err := labels . NewMatcher ( labels . MatchEqual , l . Name , l . Value ) if err != nil { panic ( err ) } matchers = append ( matchers , mt ) } sset , err , _ := q . Select ( nil , matchers ... ) if err != nil { level . Error ( g . logger ) . Log ( " " , " " , labels . AlertName , alertRule . Name ( ) , " " , " " , " " , err ) return } seriesFound := false var s storage . Series for sset . Next ( ) { seriesFound = true break } } if ! seriesFound { return } var v float64 it := s . Iterator ( ) for it . Next ( ) { t , v = it . At ( ) } if it . Err ( ) != nil { level . Error ( g . logger ) . Log ( " " , " " , labels . AlertName , alertRule . Name ( ) , " " , " " , " " , it . Err ( ) ) return } if value . IsStaleNaN ( v ) { } downAt := time . Unix ( t / 1000 , 0 ) restoredActiveAt := time . Unix ( int64 ( v ) , 0 ) timeSpentPending := downAt . Sub ( restoredActiveAt ) timeRemainingPending := alertHoldDuration - timeSpentPending if timeRemainingPending <= 0 { } else { restoredActiveAt = restoredActiveAt . Add ( downDuration ) } a . ActiveAt = restoredActiveAt level . Debug ( g . logger ) . Log ( " " , " " , labels . AlertName , alertRule . Name ( ) , " " , a . ActiveAt . Format ( time . RFC850 ) , " " , a . Labels . String ( ) ) } ) alertRule . SetRestored ( true ) } } 
func NewManager ( o * ManagerOptions ) * Manager { if o . Metrics == nil { o . Metrics = NewGroupMetrics ( o . Registerer ) } m := & Manager { groups : map [ string ] * Group { } , opts : o , block : make ( chan struct { } ) , logger : o . Logger , } if o . Registerer != nil { o . Registerer . MustRegister ( m ) } o . Metrics . iterationsMissed . Inc ( ) return m } 
func ( m * Manager ) Stop ( ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) level . Info ( m . logger ) . Log ( " " , " " ) for _ , eg := range m . groups { eg . stop ( ) } level . Info ( m . logger ) . Log ( " " , " " ) } 
func ( m * Manager ) Update ( interval time . Duration , files [ ] string , externalLabels labels . Labels ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) groups , errs := m . LoadGroups ( interval , externalLabels , files ... ) if errs != nil { for _ , e := range errs { level . Error ( m . logger ) . Log ( " " , " " , " " , e ) } return errors . New ( " " ) } m . restored = true var wg sync . WaitGroup for _ , newg := range groups { wg . Add ( 1 ) oldg , ok := m . groups [ gn ] delete ( m . groups , gn ) go func ( newg * Group ) { if ok { oldg . stop ( ) newg . CopyState ( oldg ) } go func ( ) { newg . run ( m . opts . Context ) } ( ) wg . Done ( ) } ( newg ) } } wg . Wait ( ) m . groups = groups return nil } 
func ( m * Manager ) LoadGroups ( interval time . Duration , externalLabels labels . Labels , filenames ... string , ) ( map [ string ] * Group , [ ] error ) { groups := make ( map [ string ] * Group ) shouldRestore := ! m . restored for _ , fn := range filenames { rgs , errs := rulefmt . ParseFile ( fn ) if errs != nil { return nil , errs } for _ , rg := range rgs . Groups { itv := interval if rg . Interval != 0 { itv = time . Duration ( rg . Interval ) } rules := make ( [ ] Rule , 0 , len ( rg . Rules ) ) for _ , r := range rg . Rules { expr , err := promql . ParseExpr ( r . Expr ) if err != nil { return nil , [ ] error { err } } if r . Alert != " " { rules = append ( rules , NewAlertingRule ( r . Alert , expr , time . Duration ( r . For ) , labels . FromMap ( r . Labels ) , labels . FromMap ( r . Annotations ) , externalLabels , m . restored , log . With ( m . logger , " " , r . Alert ) , ) ) continue } rules = append ( rules , NewRecordingRule ( r . Record , expr , labels . FromMap ( r . Labels ) , ) ) } groups [ groupKey ( rg . Name , fn ) ] = NewGroup ( rg . Name , fn , itv , rules , shouldRestore , m . opts ) } } return groups , nil } 
func ( m * Manager ) RuleGroups ( ) [ ] * Group { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) rgs := make ( [ ] * Group , 0 , len ( m . groups ) ) for _ , g := range m . groups { rgs = append ( rgs , g ) } } return rgs [ i ] . name < rgs [ j ] . name } ) return rgs } 
func ( m * Manager ) Rules ( ) [ ] Rule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) var rules [ ] Rule for _ , g := range m . groups { rules = append ( rules , g . rules ... ) } return rules } 
func ( m * Manager ) AlertingRules ( ) [ ] * AlertingRule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) alerts := [ ] * AlertingRule { } for _ , rule := range m . Rules ( ) { if alertingRule , ok := rule . ( * AlertingRule ) ; ok { alerts = append ( alerts , alertingRule ) } } return alerts } 
func ( m * Manager ) Collect ( ch chan <- prometheus . Metric ) { for _ , g := range m . RuleGroups ( ) { ch <- prometheus . MustNewConstMetric ( groupInterval , prometheus . GaugeValue , g . interval . Seconds ( ) , groupKey ( g . file , g . name ) ) } } 
func NewWALWatcher ( logger log . Logger , name string , writer writeTo , walDir string ) * WALWatcher { if logger == nil { logger = log . NewNopLogger ( ) } return & WALWatcher { logger : logger , writer : writer , walDir : path . Join ( walDir , " " ) , name : name , quit : make ( chan struct { } ) , done : make ( chan struct { } ) , maxSegment : - 1 , } } 
func ( w * WALWatcher ) Start ( ) { w . setMetrics ( ) level . Info ( w . logger ) . Log ( " " , " " , " " , w . name ) go w . loop ( ) } 
func ( w * WALWatcher ) Stop ( ) { close ( w . quit ) <- w . done watcherRecordsRead . DeleteLabelValues ( w . name , " " ) watcherRecordDecodeFails . DeleteLabelValues ( w . name ) watcherSamplesSentPreTailing . DeleteLabelValues ( w . name ) watcherCurrentSegment . DeleteLabelValues ( w . name ) level . Info ( w . logger ) . Log ( " " , " " , " " , w . name ) } 
func ( w * WALWatcher ) findSegmentForIndex ( index int ) ( int , error ) { refs , err := w . segments ( w . walDir ) if err != nil { return - 1 , nil } for _ , r := range refs { if r >= index { return r , nil } } return - 1 , errors . New ( " " ) } 
func ( w * WALWatcher ) segments ( dir string ) ( [ ] int , error ) { files , err := fileutil . ReadDir ( dir ) if err != nil { return nil , err } var refs [ ] int var last int for _ , fn := range files { k , err := strconv . Atoi ( fn ) if err != nil { continue } if len ( refs ) > 0 && k > last + 1 { return nil , errors . New ( " " ) } refs = append ( refs , k ) last = k } sort . Ints ( refs ) return refs , nil } 
func ( w * WALWatcher ) watch ( segmentNum int , tail bool ) error { segment , err := wal . OpenReadSegment ( wal . SegmentName ( w . walDir , segmentNum ) ) if err != nil { return err } defer segment . Close ( ) reader := wal . NewLiveReader ( w . logger , segment ) readTicker := time . NewTicker ( readPeriod ) defer readTicker . Stop ( ) checkpointTicker := time . NewTicker ( checkpointPeriod ) defer checkpointTicker . Stop ( ) segmentTicker := time . NewTicker ( segmentCheckPeriod ) defer segmentTicker . Stop ( ) if ! tail { segmentTicker . Stop ( ) checkpointTicker . Stop ( ) var err error size , err = getSegmentSize ( w . walDir , segmentNum ) if err != nil { return errors . Wrap ( err , " " ) } } for { select { case <- w . quit : return nil case <- checkpointTicker . C : } case <- segmentTicker . C : _ , last , err := w . firstAndLast ( ) if err != nil { return errors . Wrap ( err , " " ) } } err = w . readSegment ( reader , segmentNum , tail ) } else if reader . Offset ( ) != size { level . Warn ( w . logger ) . Log ( " " , " " , " " , segmentNum , " " , reader . Offset ( ) , " " , size ) } return nil } } return nil case <- readTicker . C : err = w . readSegment ( reader , segmentNum , tail ) } else if reader . Offset ( ) != size { level . Warn ( w . logger ) . Log ( " " , " " , " " , segmentNum , " " , reader . Offset ( ) , " " , size ) } return nil } } } } } 
func ( w * WALWatcher ) readCheckpoint ( checkpointDir string ) error { level . Debug ( w . logger ) . Log ( " " , " " , " " , checkpointDir ) index , err := checkpointNum ( checkpointDir ) if err != nil { return errors . Wrap ( err , " " ) } if err != nil { return errors . Wrap ( err , " " ) } for _ , seg := range segs { size , err := getSegmentSize ( checkpointDir , seg ) if err != nil { return errors . Wrap ( err , " " ) } sr , err := wal . OpenReadSegment ( wal . SegmentName ( checkpointDir , seg ) ) if err != nil { return errors . Wrap ( err , " " ) } defer sr . Close ( ) r := wal . NewLiveReader ( w . logger , sr ) if err := w . readSegment ( r , index , false ) ; err != io . EOF && err != nil { return errors . Wrap ( err , " " ) } if r . Offset ( ) != size { return fmt . Errorf ( " " , checkpointDir , seg , size , r . Offset ( ) ) } } level . Debug ( w . logger ) . Log ( " " , " " , " " , checkpointDir ) return nil } 
func getSegmentSize ( dir string , index int ) ( int64 , error ) { i := int64 ( - 1 ) fi , err := os . Stat ( wal . SegmentName ( dir , index ) ) if err == nil { i = fi . Size ( ) } return i , err } 
func ( zl ZookeeperLogger ) Printf ( s string , i ... interface { } ) { level . Info ( zl . logger ) . Log ( " " , fmt . Sprintf ( s , i ... ) ) } 
func NewZookeeperTreeCache ( conn * zk . Conn , path string , events chan ZookeeperTreeCacheEvent , logger log . Logger ) * ZookeeperTreeCache { tc := & ZookeeperTreeCache { conn : conn , prefix : path , events : events , stop : make ( chan struct { } ) , logger : logger , } tc . head = & zookeeperTreeCacheNode { events : make ( chan zk . Event ) , children : map [ string ] * zookeeperTreeCacheNode { } , stopped : true , } go tc . loop ( path ) return tc } 
func NewManager ( ctx context . Context , logger log . Logger , options ... func ( * Manager ) ) * Manager { if logger == nil { logger = log . NewNopLogger ( ) } mgr := & Manager { logger : logger , syncCh : make ( chan map [ string ] [ ] * targetgroup . Group ) , targets : make ( map [ poolKey ] map [ string ] * targetgroup . Group ) , discoverCancel : [ ] context . CancelFunc { } , ctx : ctx , updatert : 5 * time . Second , triggerSend : make ( chan struct { } , 1 ) , } for _ , option := range options { option ( mgr ) } return mgr } 
func Name ( n string ) func ( * Manager ) { return func ( m * Manager ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) m . name = n } } 
func ( m * Manager ) Run ( ) error { go m . sender ( ) for range m . ctx . Done ( ) { m . cancelDiscoverers ( ) return m . ctx . Err ( ) } return nil } 
func ( m * Manager ) ApplyConfig ( cfg map [ string ] sd_config . ServiceDiscoveryConfig ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) for pk := range m . targets { if _ , ok := cfg [ pk . setName ] ; ! ok { discoveredTargets . DeleteLabelValues ( m . name , pk . setName ) } } m . cancelDiscoverers ( ) for name , scfg := range cfg { m . registerProviders ( scfg , name ) discoveredTargets . WithLabelValues ( m . name , name ) . Set ( 0 ) } for _ , prov := range m . providers { m . startProvider ( m . ctx , prov ) } return nil } 
func ( m * Manager ) StartCustomProvider ( ctx context . Context , name string , worker Discoverer ) { p := & provider { name : name , d : worker , subs : [ ] string { name } , } m . providers = append ( m . providers , p ) m . startProvider ( ctx , p ) } 
func ( sd * StaticProvider ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { close ( ch ) } 
func NewDiscovery ( l log . Logger , mech string , interval time . Duration , refreshf func ( ctx context . Context ) ( [ ] * targetgroup . Group , error ) ) * Discovery { if l == nil { l = log . NewNopLogger ( ) } return & Discovery { logger : l , interval : interval , refreshf : refreshf , failures : failuresCount . WithLabelValues ( mech ) , duration : duration . WithLabelValues ( mech ) , } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err . Error ( ) ) } else { select { case ch <- tgs : case <- ctx . Done ( ) : return } } ticker := time . NewTicker ( d . interval ) defer ticker . Stop ( ) for { select { case <- ticker . C : tgs , err := d . refresh ( ctx ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err . Error ( ) ) continue } select { case ch <- tgs : case <- ctx . Done ( ) : return } case <- ctx . Done ( ) : return } } } 
func ( c * ServersetSDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultServersetSDConfig type plain ServersetSDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if len ( c . Servers ) == 0 { return errors . New ( " " ) } if len ( c . Paths ) == 0 { return errors . New ( " " ) } for _ , path := range c . Paths { if ! strings . HasPrefix ( path , " " ) { return errors . Errorf ( " " , path ) } } return nil } 
func NewNerveDiscovery ( conf * NerveSDConfig , logger log . Logger ) ( * Discovery , error ) { return NewDiscovery ( conf . Servers , time . Duration ( conf . Timeout ) , conf . Paths , logger , parseNerveMember ) } 
func NewServersetDiscovery ( conf * ServersetSDConfig , logger log . Logger ) ( * Discovery , error ) { return NewDiscovery ( conf . Servers , time . Duration ( conf . Timeout ) , conf . Paths , logger , parseServersetMember ) } 
func NewDiscovery ( srvs [ ] string , timeout time . Duration , paths [ ] string , logger log . Logger , pf func ( data [ ] byte , path string ) ( model . LabelSet , error ) , ) ( * Discovery , error ) { if logger == nil { logger = log . NewNopLogger ( ) } conn , _ , err := zk . Connect ( srvs , timeout , func ( c * zk . Conn ) { c . SetLogger ( treecache . NewZookeeperLogger ( logger ) ) } ) if err != nil { return nil , err } updates := make ( chan treecache . ZookeeperTreeCacheEvent ) sd := & Discovery { conn : conn , updates : updates , sources : map [ string ] * targetgroup . Group { } , parse : pf , logger : logger , } for _ , path := range paths { sd . treeCaches = append ( sd . treeCaches , treecache . NewZookeeperTreeCache ( conn , path , updates , logger ) ) } return sd , nil } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer func ( ) { for _ , tc := range d . treeCaches { tc . Stop ( ) } d . conn . Close ( ) } ( ) for { select { case <- ctx . Done ( ) : return case event := <- d . updates : tg := & targetgroup . Group { Source : event . Path , } if event . Data != nil { labelSet , err := d . parse ( * event . Data , event . Path ) if err == nil { tg . Targets = [ ] model . LabelSet { labelSet } d . sources [ event . Path ] = tg } else { delete ( d . sources , event . Path ) } } else { delete ( d . sources , event . Path ) } select { case <- ctx . Done ( ) : return case ch <- [ ] * targetgroup . Group { tg } : } } } } 
func Walk ( v Visitor , node Node , path [ ] Node ) error { var err error if v , err = v . Visit ( node , path ) ; v == nil || err != nil { return err } path = append ( path , node ) switch n := node . ( type ) { case * EvalStmt : if err := Walk ( v , n . Expr , path ) ; err != nil { return err } case Expressions : for _ , e := range n { if err := Walk ( v , e , path ) ; err != nil { return err } } case * AggregateExpr : if n . Param != nil { if err := Walk ( v , n . Param , path ) ; err != nil { return err } } if err := Walk ( v , n . Expr , path ) ; err != nil { return err } case * BinaryExpr : if err := Walk ( v , n . LHS , path ) ; err != nil { return err } if err := Walk ( v , n . RHS , path ) ; err != nil { return err } case * Call : if err := Walk ( v , n . Args , path ) ; err != nil { return err } case * SubqueryExpr : if err := Walk ( v , n . Expr , path ) ; err != nil { return err } case * ParenExpr : if err := Walk ( v , n . Expr , path ) ; err != nil { return err } case * UnaryExpr : if err := Walk ( v , n . Expr , path ) ; err != nil { return err } case * MatrixSelector , * NumberLiteral , * StringLiteral , * VectorSelector : } _ , err = v . Visit ( nil , nil ) return err } 
func Inspect ( node Node , f inspector ) { Walk ( inspector ( f ) , node , nil ) } 
func ( l * openMetricsLexer ) Lex ( ) token { if l . i >= len ( l . b ) { return tEOF } c := l . b [ l . i ] l . start = l . i yystate0 : switch yyt := l . state ; yyt { default : panic ( errors . Errorf ( `invalid start condition %d` , yyt ) ) case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : } goto yystate0 goto yystate1 yystate1 : c = l . next ( ) yystart1 : switch { default : goto yyabort case c == '#' : goto yystate2 case c == ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate4 } yystate2 : c = l . next ( ) switch { default : goto yyabort case c == ' ' : goto yystate3 } yystate3 : c = l . next ( ) goto yyrule1 yystate4 : c = l . next ( ) switch { default : goto yyrule8 case c >= '0' && c <= ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate4 } goto yystate5 yystate5 : c = l . next ( ) yystart5 : switch { default : goto yyabort case c == 'E' : goto yystate6 case c == 'H' : goto yystate10 case c == 'T' : goto yystate15 case c == 'U' : goto yystate20 } yystate6 : c = l . next ( ) switch { default : goto yyabort case c == 'O' : goto yystate7 } yystate7 : c = l . next ( ) switch { default : goto yyabort case c == 'F' : goto yystate8 } yystate8 : c = l . next ( ) switch { default : goto yyrule5 case c == '\n' : goto yystate9 } yystate9 : c = l . next ( ) goto yyrule5 yystate10 : c = l . next ( ) switch { default : goto yyabort case c == 'E' : goto yystate11 } yystate11 : c = l . next ( ) switch { default : goto yyabort case c == 'L' : goto yystate12 } yystate12 : c = l . next ( ) switch { default : goto yyabort case c == 'P' : goto yystate13 } yystate13 : c = l . next ( ) switch { default : goto yyabort case c == ' ' : goto yystate14 } yystate14 : c = l . next ( ) goto yyrule2 yystate15 : c = l . next ( ) switch { default : goto yyabort case c == 'Y' : goto yystate16 } yystate16 : c = l . next ( ) switch { default : goto yyabort case c == 'P' : goto yystate17 } yystate17 : c = l . next ( ) switch { default : goto yyabort case c == 'E' : goto yystate18 } yystate18 : c = l . next ( ) switch { default : goto yyabort case c == ' ' : goto yystate19 } yystate19 : c = l . next ( ) goto yyrule3 yystate20 : c = l . next ( ) switch { default : goto yyabort case c == 'N' : goto yystate21 } yystate21 : c = l . next ( ) switch { default : goto yyabort case c == 'I' : goto yystate22 } yystate22 : c = l . next ( ) switch { default : goto yyabort case c == 'T' : goto yystate23 } yystate23 : c = l . next ( ) switch { default : goto yyabort case c == ' ' : goto yystate24 } yystate24 : c = l . next ( ) goto yyrule4 goto yystate25 yystate25 : c = l . next ( ) yystart25 : switch { default : goto yyabort case c == ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate26 } yystate26 : c = l . next ( ) switch { default : goto yyrule6 case c >= '0' && c <= ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate26 } goto yystate27 yystate27 : c = l . next ( ) yystart27 : switch { default : goto yyabort case c == ' ' : goto yystate28 } yystate28 : c = l . next ( ) switch { default : goto yyabort case c == '\n' : goto yystate29 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '': goto yystate28 } yystate29 : c = l . next ( ) goto yyrule7 goto yystate30 yystate30 : c = l . next ( ) yystart30 : switch { default : goto yyabort case c == ',' : goto yystate31 case c == '=' : goto yystate32 case c == '}' : goto yystate34 case c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate33 } yystate31 : c = l . next ( ) goto yyrule13 yystate32 : c = l . next ( ) goto yyrule12 yystate33 : c = l . next ( ) switch { default : goto yyrule10 case c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate33 } yystate34 : c = l . next ( ) goto yyrule11 goto yystate35 yystate35 : c = l . next ( ) yystart35 : switch { default : goto yyabort case c == '"' : goto yystate36 } yystate36 : c = l . next ( ) switch { default : goto yyabort case c == '"' : goto yystate37 case c == '\\' : goto yystate38 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '!' || c >= '#' && c <= '[' || c >= ']' && c <= '': goto yystate36 } yystate37 : c = l . next ( ) goto yyrule14 yystate38 : c = l . next ( ) switch { default : goto yyabort case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '': goto yystate36 } goto yystate39 yystate39 : c = l . next ( ) yystart39 : switch { default : goto yyabort case c == ' ' : goto yystate40 case c == '{' : goto yystate42 } yystate40 : c = l . next ( ) switch { default : goto yyabort case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate41 } yystate41 : c = l . next ( ) switch { default : goto yyrule15 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate41 } yystate42 : c = l . next ( ) goto yyrule9 goto yystate43 yystate43 : c = l . next ( ) yystart43 : switch { default : goto yyabort case c == ' ' : goto yystate45 case c == '\n' : goto yystate44 } yystate44 : c = l . next ( ) goto yyrule18 yystate45 : c = l . next ( ) switch { default : goto yyabort case c == '#' : goto yystate47 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '\x1f' || c == '!' || c == '"' || c >= '$' && c <= '': goto yystate46 } yystate46 : c = l . next ( ) switch { default : goto yyrule16 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate46 } yystate47 : c = l . next ( ) switch { default : goto yyrule16 case c == ' ' : goto yystate48 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate46 } yystate48 : c = l . next ( ) switch { default : goto yyabort case c == '\n' : goto yystate49 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '': goto yystate48 } yystate49 : c = l . next ( ) goto yyrule17 yyrule1 : goto yystate0 } yyrule2 : return tHelp goto yystate0 } yyrule3 : return tType goto yystate0 } yyrule4 : return tUnit goto yystate0 } yyrule5 : return tEofWord goto yystate0 } yyrule6 : return tMName goto yystate0 } yyrule7 : return tText goto yystate0 } yyrule8 : return tMName goto yystate0 } yyrule9 : return tBraceOpen goto yystate0 } yyrule10 : } yyrule11 : return tBraceClose goto yystate0 } yyrule12 : return tEqual goto yystate0 } yyrule13 : } yyrule14 : return tLValue goto yystate0 } yyrule15 : return tValue goto yystate0 } yyrule16 : } yyrule17 : return tLinebreak goto yystate0 } yyrule18 : return tLinebreak goto yystate0 } panic ( " " ) goto yyabort yyabort : } 
func FuzzParseMetric ( in [ ] byte ) int { p := textparse . New ( in ) for p . Next ( ) { } if p . Err ( ) == nil { return fuzzInteresting } return fuzzMeh } 
func FuzzParseMetricSelector ( in [ ] byte ) int { _ , err := ParseMetricSelector ( string ( in ) ) if err == nil { return fuzzInteresting } return fuzzMeh } 
func FuzzParseExpr ( in [ ] byte ) int { _ , err := ParseExpr ( string ( in ) ) if err == nil { return fuzzInteresting } return fuzzMeh } 
func FuzzParseStmts ( in [ ] byte ) int { _ , err := ParseStmts ( string ( in ) ) if err == nil { return fuzzInteresting } return fuzzMeh } 
func ( s * Service ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer s . queue . ShutDown ( ) if ! cache . WaitForCacheSync ( ctx . Done ( ) , s . informer . HasSynced ) { level . Error ( s . logger ) . Log ( " " , " " ) return } go func ( ) { for s . process ( ctx , ch ) { } } ( ) } 
func NewManager ( logger log . Logger , app Appendable ) * Manager { if logger == nil { logger = log . NewNopLogger ( ) } return & Manager { append : app , logger : logger , scrapeConfigs : make ( map [ string ] * config . ScrapeConfig ) , scrapePools : make ( map [ string ] * scrapePool ) , graceShut : make ( chan struct { } ) , triggerReload : make ( chan struct { } , 1 ) , } } 
func ( m * Manager ) Run ( tsets <- chan map [ string ] [ ] * targetgroup . Group ) error { go m . reloader ( ) for { select { case ts := <- tsets : m . updateTsets ( ts ) select { case m . triggerReload <- struct { } { } : default : } case <- m . graceShut : return nil } } } 
func ( m * Manager ) setJitterSeed ( labels labels . Labels ) error { h := fnv . New64a ( ) hostname , err := getFqdn ( ) if err != nil { return err } if _ , err := fmt . Fprintf ( h , " " , hostname , labels . String ( ) ) ; err != nil { return err } m . jitterSeed = h . Sum64 ( ) return nil } 
func ( m * Manager ) Stop ( ) { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) for _ , sp := range m . scrapePools { sp . stop ( ) } close ( m . graceShut ) } 
func ( m * Manager ) ApplyConfig ( cfg * config . Config ) error { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) c := make ( map [ string ] * config . ScrapeConfig ) for _ , scfg := range cfg . ScrapeConfigs { c [ scfg . JobName ] = scfg } m . scrapeConfigs = c if err := m . setJitterSeed ( cfg . GlobalConfig . ExternalLabels ) ; err != nil { return err } for name , sp := range m . scrapePools { if cfg , ok := m . scrapeConfigs [ name ] ; ! ok { sp . stop ( ) delete ( m . scrapePools , name ) } else if ! reflect . DeepEqual ( sp . config , cfg ) { err := sp . reload ( cfg ) if err != nil { level . Error ( m . logger ) . Log ( " " , " " , " " , err , " " , name ) failed = true } } } if failed { return errors . New ( " " ) } return nil } 
func ( m * Manager ) TargetsAll ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = append ( sp . ActiveTargets ( ) , sp . DroppedTargets ( ) ... ) } return targets } 
func ( m * Manager ) TargetsActive ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = sp . ActiveTargets ( ) } return targets } 
func ( m * Manager ) TargetsDropped ( ) map [ string ] [ ] * Target { m . mtxScrape . Lock ( ) defer m . mtxScrape . Unlock ( ) targets := make ( map [ string ] [ ] * Target , len ( m . scrapePools ) ) for tset , sp := range m . scrapePools { targets [ tset ] = sp . DroppedTargets ( ) } return targets } 
func getFqdn ( ) ( string , error ) { hostname , err := os . Hostname ( ) if err != nil { return " " , err } ips , err := net . LookupIP ( hostname ) if err != nil { } lookup := func ( ipStr encoding . TextMarshaler ) ( string , error ) { ip , err := ipStr . MarshalText ( ) if err != nil { return " " , err } hosts , err := net . LookupAddr ( string ( ip ) ) if err != nil || len ( hosts ) == 0 { return " " , err } return hosts [ 0 ] , nil } for _ , addr := range ips { if ip := addr . To4 ( ) ; ip != nil { if fqdn , err := lookup ( ip ) ; err == nil { return fqdn , nil } } if ip := addr . To16 ( ) ; ip != nil { if fqdn , err := lookup ( ip ) ; err == nil { return fqdn , nil } } } return hostname , nil } 
func NewClient ( logger log . Logger , url string , timeout time . Duration ) * Client { return & Client { logger : logger , url : url , timeout : timeout , } } 
func tagsFromMetric ( m model . Metric ) map [ string ] TagValue { tags := make ( map [ string ] TagValue , len ( m ) - 1 ) for l , v := range m { if l == model . MetricNameLabel { continue } tags [ string ( l ) ] = TagValue ( v ) } return tags } 
func ( c * Client ) Write ( samples model . Samples ) error { reqs := make ( [ ] StoreSamplesRequest , 0 , len ( samples ) ) for _ , s := range samples { v := float64 ( s . Value ) if math . IsNaN ( v ) || math . IsInf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) continue } metric := TagValue ( s . Metric [ model . MetricNameLabel ] ) reqs = append ( reqs , StoreSamplesRequest { Metric : metric , Timestamp : s . Timestamp . Unix ( ) , Value : v , Tags : tagsFromMetric ( s . Metric ) , } ) } u , err := url . Parse ( c . url ) if err != nil { return err } u . Path = putEndpoint buf , err := json . Marshal ( reqs ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , c . timeout ) defer cancel ( ) req , err := http . NewRequest ( " " , u . String ( ) , bytes . NewBuffer ( buf ) ) if err != nil { return err } req . Header . Set ( " " , contentTypeJSON ) resp , err := http . DefaultClient . Do ( req . WithContext ( ctx ) ) if err != nil { return err } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) } if err != nil { return err } var r map [ string ] int if err := json . Unmarshal ( buf , & r ) ; err != nil { return err } return errors . Errorf ( " " , r [ " " ] , r [ " " ] ) } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if c . Project == " " { return errors . New ( " " ) } if c . Zone == " " { return errors . New ( " " ) } return nil } 
func NewDiscovery ( conf SDConfig , logger log . Logger ) ( * Discovery , error ) { d := & Discovery { project : conf . Project , zone : conf . Zone , filter : conf . Filter , port : conf . Port , tagSeparator : conf . TagSeparator , } var err error d . client , err = google . DefaultClient ( context . Background ( ) , compute . ComputeReadonlyScope ) if err != nil { return nil , errors . Wrap ( err , " " ) } d . svc , err = compute . NewService ( context . Background ( ) , option . WithHTTPClient ( d . client ) ) if err != nil { return nil , errors . Wrap ( err , " " ) } d . isvc = compute . NewInstancesService ( d . svc ) d . Discovery = refresh . NewDiscovery ( logger , " " , time . Duration ( conf . RefreshInterval ) , d . refresh , ) return d , nil } 
func QueryableClient ( c * Client ) storage . Queryable { remoteReadQueries . WithLabelValues ( c . Name ( ) ) return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { return & querier { ctx : ctx , mint : mint , maxt : maxt , client : c , } , nil } ) } 
func ( q * querier ) Select ( p * storage . SelectParams , matchers ... * labels . Matcher ) ( storage . SeriesSet , storage . Warnings , error ) { query , err := ToQuery ( q . mint , q . maxt , matchers , p ) if err != nil { return nil , nil , err } remoteReadGauge := remoteReadQueries . WithLabelValues ( q . client . Name ( ) ) remoteReadGauge . Inc ( ) defer remoteReadGauge . Dec ( ) res , err := q . client . Read ( q . ctx , query ) if err != nil { return nil , nil , err } return FromQueryResult ( res ) , nil , nil } 
func ExternalLabelsHandler ( next storage . Queryable , externalLabels labels . Labels ) storage . Queryable { return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { q , err := next . Querier ( ctx , mint , maxt ) if err != nil { return nil , err } return & externalLabelsQuerier { Querier : q , externalLabels : externalLabels } , nil } ) } 
func ( q externalLabelsQuerier ) Select ( p * storage . SelectParams , matchers ... * labels . Matcher ) ( storage . SeriesSet , storage . Warnings , error ) { m , added := q . addExternalLabels ( matchers ) s , warnings , err := q . Querier . Select ( p , m ... ) if err != nil { return nil , warnings , err } return newSeriesSetFilter ( s , added ) , warnings , nil } 
func PreferLocalStorageFilter ( next storage . Queryable , cb startTimeCallback ) storage . Queryable { return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { localStartTime , err := cb ( ) if err != nil { return nil , err } cmaxt := maxt } } return next . Querier ( ctx , mint , cmaxt ) } ) } 
func RequiredMatchersFilter ( next storage . Queryable , required [ ] * labels . Matcher ) storage . Queryable { return storage . QueryableFunc ( func ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { q , err := next . Querier ( ctx , mint , maxt ) if err != nil { return nil , err } return & requiredMatchersQuerier { Querier : q , requiredMatchers : required } , nil } ) } 
func ( q requiredMatchersQuerier ) Select ( p * storage . SelectParams , matchers ... * labels . Matcher ) ( storage . SeriesSet , storage . Warnings , error ) { ms := q . requiredMatchers for _ , m := range matchers { for i , r := range ms { if m . Type == labels . MatchEqual && m . Name == r . Name && m . Value == r . Value { ms = append ( ms [ : i ] , ms [ i + 1 : ] ... ) break } } if len ( ms ) == 0 { break } } if len ( ms ) > 0 { return storage . NoopSeriesSet ( ) , nil , nil } return q . Querier . Select ( p , matchers ... ) } 
func ( q externalLabelsQuerier ) addExternalLabels ( ms [ ] * labels . Matcher ) ( [ ] * labels . Matcher , labels . Labels ) { el := make ( labels . Labels , len ( q . externalLabels ) ) copy ( el , q . externalLabels ) continue } i ++ } } for _ , l := range el { m , err := labels . NewMatcher ( labels . MatchEqual , l . Name , l . Value ) if err != nil { panic ( err ) } ms = append ( ms , m ) } return ms , el } 
func New ( b [ ] byte , contentType string ) Parser { mediaType , _ , err := mime . ParseMediaType ( contentType ) if err == nil && mediaType == " " { return NewOpenMetricsParser ( b ) } return NewPromParser ( b ) } 
func newInstanceDiscovery ( provider * gophercloud . ProviderClient , opts * gophercloud . AuthOptions , port int , region string , allTenants bool , l log . Logger ) * InstanceDiscovery { if l == nil { l = log . NewNopLogger ( ) } return & InstanceDiscovery { provider : provider , authOpts : opts , region : region , port : port , allTenants : allTenants , logger : l } } 
func ( f QueryableFunc ) Querier ( ctx context . Context , mint , maxt int64 ) ( Querier , error ) { return f ( ctx , mint , maxt ) } 
func ( a * Alert ) ResolvedAt ( ts time . Time ) bool { if a . EndsAt . IsZero ( ) { return false } return ! a . EndsAt . After ( ts ) } 
func NewManager ( o * Options , logger log . Logger ) * Manager { ctx , cancel := context . WithCancel ( context . Background ( ) ) if o . Do == nil { o . Do = do } if logger == nil { logger = log . NewNopLogger ( ) } n := & Manager { queue : make ( [ ] * Alert , 0 , o . QueueCapacity ) , ctx : ctx , cancel : cancel , more : make ( chan struct { } , 1 ) , opts : o , logger : logger , } queueLenFunc := func ( ) float64 { return float64 ( n . queueLen ( ) ) } alertmanagersDiscoveredFunc := func ( ) float64 { return float64 ( len ( n . Alertmanagers ( ) ) ) } n . metrics = newAlertMetrics ( o . Registerer , o . QueueCapacity , queueLenFunc , alertmanagersDiscoveredFunc , ) return n } 
func ( n * Manager ) ApplyConfig ( conf * config . Config ) error { n . mtx . Lock ( ) defer n . mtx . Unlock ( ) n . opts . ExternalLabels = conf . GlobalConfig . ExternalLabels n . opts . RelabelConfigs = conf . AlertingConfig . AlertRelabelConfigs amSets := make ( map [ string ] * alertmanagerSet ) for _ , cfg := range conf . AlertingConfig . AlertmanagerConfigs { ams , err := newAlertmanagerSet ( cfg , n . logger ) if err != nil { return err } ams . metrics = n . metrics if err != nil { return err } amSets [ fmt . Sprintf ( " " , md5 . Sum ( b ) ) ] = ams } n . alertmanagers = amSets return nil } 
func ( n * Manager ) Run ( tsets <- chan map [ string ] [ ] * targetgroup . Group ) { for { select { case <- n . ctx . Done ( ) : return case ts := <- tsets : n . reload ( ts ) case <- n . more : } alerts := n . nextBatch ( ) if ! n . sendAll ( alerts ... ) { n . metrics . dropped . Add ( float64 ( len ( alerts ) ) ) } } } } 
func ( n * Manager ) Send ( alerts ... * Alert ) { n . mtx . Lock ( ) defer n . mtx . Unlock ( ) for _ , l := range n . opts . ExternalLabels { if a . Labels . Get ( l . Name ) == " " { lb . Set ( l . Name , l . Value ) } } a . Labels = lb . Labels ( ) } alerts = n . relabelAlerts ( alerts ) level . Warn ( n . logger ) . Log ( " " , " " , " " , d ) n . metrics . dropped . Add ( float64 ( d ) ) } level . Warn ( n . logger ) . Log ( " " , " " , " " , d ) n . metrics . dropped . Add ( float64 ( d ) ) } n . queue = append ( n . queue , alerts ... ) } 
func ( n * Manager ) Alertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , am := range ams . ams { res = append ( res , am . url ( ) ) } ams . mtx . RUnlock ( ) } return res } 
func ( n * Manager ) DroppedAlertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , dam := range ams . droppedAms { res = append ( res , dam . url ( ) ) } ams . mtx . RUnlock ( ) } return res } 
func ( n * Manager ) sendAll ( alerts ... * Alert ) bool { begin := time . Now ( ) b , err := json . Marshal ( alerts ) if err != nil { level . Error ( n . logger ) . Log ( " " , " " , " " , err ) return false } n . mtx . RLock ( ) amSets := n . alertmanagers n . mtx . RUnlock ( ) var ( wg sync . WaitGroup numSuccess uint64 ) for _ , ams := range amSets { ams . mtx . RLock ( ) for _ , am := range ams . ams { wg . Add ( 1 ) ctx , cancel := context . WithTimeout ( n . ctx , time . Duration ( ams . cfg . Timeout ) ) defer cancel ( ) go func ( ams * alertmanagerSet , am alertmanager ) { u := am . url ( ) . String ( ) if err := n . sendOne ( ctx , ams . client , u , b ) ; err != nil { level . Error ( n . logger ) . Log ( " " , u , " " , len ( alerts ) , " " , " " , " " , err ) n . metrics . errors . WithLabelValues ( u ) . Inc ( ) } else { atomic . AddUint64 ( & numSuccess , 1 ) } n . metrics . latency . WithLabelValues ( u ) . Observe ( time . Since ( begin ) . Seconds ( ) ) n . metrics . sent . WithLabelValues ( u ) . Add ( float64 ( len ( alerts ) ) ) wg . Done ( ) } ( ams , am ) } ams . mtx . RUnlock ( ) } wg . Wait ( ) return numSuccess > 0 } 
func ( n * Manager ) Stop ( ) { level . Info ( n . logger ) . Log ( " " , " " ) n . cancel ( ) } 
func ( s * alertmanagerSet ) sync ( tgs [ ] * targetgroup . Group ) { allAms := [ ] alertmanager { } allDroppedAms := [ ] alertmanager { } for _ , tg := range tgs { ams , droppedAms , err := alertmanagerFromGroup ( tg , s . cfg ) if err != nil { level . Error ( s . logger ) . Log ( " " , " " , " " , err ) continue } allAms = append ( allAms , ams ... ) allDroppedAms = append ( allDroppedAms , droppedAms ... ) } s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . droppedAms = [ ] alertmanager { } s . droppedAms = append ( s . droppedAms , allDroppedAms ... ) seen := map [ string ] struct { } { } for _ , am := range allAms { us := am . url ( ) . String ( ) if _ , ok := seen [ us ] ; ok { continue } s . metrics . errors . WithLabelValues ( us ) seen [ us ] = struct { } { } s . ams = append ( s . ams , am ) } } 
func alertmanagerFromGroup ( tg * targetgroup . Group , cfg * config . AlertmanagerConfig ) ( [ ] alertmanager , [ ] alertmanager , error ) { var res [ ] alertmanager var droppedAlertManagers [ ] alertmanager for _ , tlset := range tg . Targets { lbls := make ( [ ] labels . Label , 0 , len ( tlset ) + 2 + len ( tg . Labels ) ) for ln , lv := range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } lbls = append ( lbls , labels . Label { Name : pathLabel , Value : postPath ( cfg . PathPrefix ) } ) } } lset := relabel . Process ( labels . New ( lbls ... ) , cfg . RelabelConfigs ... ) if lset == nil { droppedAlertManagers = append ( droppedAlertManagers , alertmanagerLabels { lbls } ) continue } lb := labels . NewBuilder ( lset ) } return err == nil } addr := lset . Get ( model . AddressLabel ) case " " : addr = addr + " " default : return nil , nil , errors . Errorf ( " " , cfg . Scheme ) } lb . Set ( model . AddressLabel , addr ) } if err := config . CheckTargetAddress ( model . LabelValue ( addr ) ) ; err != nil { return nil , nil , err } } } res = append ( res , alertmanagerLabels { lset } ) } return res , droppedAlertManagers , nil } 
func Unquote ( s string ) ( t string , err error ) { n := len ( s ) if n < 2 { return " " , ErrSyntax } quote := s [ 0 ] if quote != s [ n - 1 ] { return " " , ErrSyntax } s = s [ 1 : n - 1 ] if quote == '`' { if contains ( s , '`' ) { return " " , ErrSyntax } return s , nil } if quote != '"' && quote != '\'' { return " " , ErrSyntax } if contains ( s , '\n' ) { return " " , ErrSyntax } // Is it trivial? Avoid allocation. if ! contains ( s , '\\' ) && ! contains ( s , quote ) { return s , nil } var runeTmp [ utf8 . UTFMax ] byte buf := make ( [ ] byte , 0 , 3 * len ( s ) / 2 ) for len ( s ) > 0 { c , multibyte , ss , err := unquoteChar ( s , quote ) if err != nil { return " " , err } s = ss if c < utf8 . RuneSelf || ! multibyte { buf = append ( buf , byte ( c ) ) } else { n := utf8 . EncodeRune ( runeTmp [ : ] , c ) buf = append ( buf , runeTmp [ : n ] ... ) } } return string ( buf ) , nil } 
func ( i item ) String ( ) string { switch { case i . typ == ItemEOF : return " " case i . typ == ItemError : return i . val case i . typ == ItemIdentifier || i . typ == ItemMetricIdentifier : return fmt . Sprintf ( " " , i . val ) case i . typ . isKeyword ( ) : return fmt . Sprintf ( " " , i . val ) case i . typ . isOperator ( ) : return fmt . Sprintf ( " " , i . val ) case i . typ . isAggregator ( ) : return fmt . Sprintf ( " " , i . val ) case len ( i . val ) > 10 : return fmt . Sprintf ( " " , i . val ) } return fmt . Sprintf ( " " , i . val ) } 
func ( i ItemType ) isAggregatorWithParam ( ) bool { return i == ItemTopK || i == ItemBottomK || i == ItemCountValues || i == ItemQuantile } 
func ( i ItemType ) isComparisonOperator ( ) bool { switch i { case ItemEQL , ItemNEQ , ItemLTE , ItemLSS , ItemGTE , ItemGTR : return true default : return false } } 
func ( i ItemType ) isSetOperator ( ) bool { switch i { case ItemLAND , ItemLOR , ItemLUnless : return true } return false } 
func ( i ItemType ) precedence ( ) int { switch i { case ItemLOR : return 1 case ItemLAND , ItemLUnless : return 2 case ItemEQL , ItemNEQ , ItemLTE , ItemLSS , ItemGTE , ItemGTR : return 3 case ItemADD , ItemSUB : return 4 case ItemMUL , ItemDIV , ItemMOD : return 5 case ItemPOW : return 6 default : return LowestPrec } } 
func ( l * lexer ) next ( ) rune { if int ( l . pos ) >= len ( l . input ) { l . width = 0 return eof } r , w := utf8 . DecodeRuneInString ( l . input [ l . pos : ] ) l . width = Pos ( w ) l . pos += l . width return r } 
func ( l * lexer ) peek ( ) rune { r := l . next ( ) l . backup ( ) return r } 
func ( l * lexer ) emit ( t ItemType ) { l . items <- item { t , l . start , l . input [ l . start : l . pos ] } l . start = l . pos } 
func ( l * lexer ) linePosition ( ) int { lb := strings . LastIndex ( l . input [ : l . lastPos ] , " \n " ) if lb == - 1 { return 1 + int ( l . lastPos ) } return 1 + int ( l . lastPos ) - lb } 
func ( l * lexer ) nextItem ( ) item { item := <- l . items l . lastPos = item . pos return item } 
func lex ( input string ) * lexer { l := & lexer { input : input , items : make ( chan item ) , } go l . run ( ) return l } 
func lexStatements ( l * lexer ) stateFn { if l . braceOpen { return lexInsideBraces } if strings . HasPrefix ( l . input [ l . pos : ] , lineComment ) { return lexLineComment } switch r := l . next ( ) ; { case r == eof : if l . parenDepth != 0 { return l . errorf ( " " ) } else if l . bracketOpen { return l . errorf ( " " ) } l . emit ( ItemEOF ) return nil case r == ',' : l . emit ( ItemComma ) case isSpace ( r ) : return lexSpace case r == '*' : l . emit ( ItemMUL ) case r == '/' : l . emit ( ItemDIV ) case r == '%' : l . emit ( ItemMOD ) case r == '+' : l . emit ( ItemADD ) case r == '-' : l . emit ( ItemSUB ) case r == '^' : l . emit ( ItemPOW ) case r == '=' : if t := l . peek ( ) ; t == '=' { l . next ( ) l . emit ( ItemEQL ) } else if t == '~' { return l . errorf ( " " , t ) } else { l . emit ( ItemAssign ) } case r == '!' : if t := l . next ( ) ; t == '=' { l . emit ( ItemNEQ ) } else { return l . errorf ( " " , t ) } case r == '<' : if t := l . peek ( ) ; t == '=' { l . next ( ) l . emit ( ItemLTE ) } else { l . emit ( ItemLSS ) } case r == '>' : if t := l . peek ( ) ; t == '=' { l . next ( ) l . emit ( ItemGTE ) } else { l . emit ( ItemGTR ) } case isDigit ( r ) || ( r == '.' && isDigit ( l . peek ( ) ) ) : l . backup ( ) return lexNumberOrDuration case r == '"' || r == '\'' : l . stringOpen = r return lexString case r == '`' : l . stringOpen = r return lexRawString case isAlpha ( r ) || r == ':' : if ! l . bracketOpen { l . backup ( ) return lexKeywordOrIdentifier } if l . gotColon { return l . errorf ( " " , r ) } l . emit ( ItemColon ) l . gotColon = true case r == '(' : l . emit ( ItemLeftParen ) l . parenDepth ++ return lexStatements case r == ')' : l . emit ( ItemRightParen ) l . parenDepth -- if l . parenDepth < 0 { return l . errorf ( " " , r ) } return lexStatements case r == '{' : l . emit ( ItemLeftBrace ) l . braceOpen = true return lexInsideBraces ( l ) case r == '[' : if l . bracketOpen { return l . errorf ( " " , r ) } l . gotColon = false l . emit ( ItemLeftBracket ) l . bracketOpen = true return lexDuration case r == ']' : if ! l . bracketOpen { return l . errorf ( " " , r ) } l . emit ( ItemRightBracket ) l . bracketOpen = false default : return l . errorf ( " " , r ) } return lexStatements } 
func lexInsideBraces ( l * lexer ) stateFn { if strings . HasPrefix ( l . input [ l . pos : ] , lineComment ) { return lexLineComment } switch r := l . next ( ) ; { case r == eof : return l . errorf ( " " ) case isSpace ( r ) : return lexSpace case isAlpha ( r ) : l . backup ( ) return lexIdentifier case r == ',' : l . emit ( ItemComma ) case r == '"' || r == '\'' : l . stringOpen = r return lexString case r == '`' : l . stringOpen = r return lexRawString case r == '=' : if l . next ( ) == '~' { l . emit ( ItemEQLRegex ) break } l . backup ( ) l . emit ( ItemEQL ) case r == '!' : switch nr := l . next ( ) ; { case nr == '~' : l . emit ( ItemNEQRegex ) case nr == '=' : l . emit ( ItemNEQ ) default : return l . errorf ( " " , nr ) } case r == '{' : return l . errorf ( " " , r ) case r == '}' : l . emit ( ItemRightBrace ) l . braceOpen = false if l . seriesDesc { return lexValueSequence } return lexStatements default : return l . errorf ( " " , r ) } return lexInsideBraces } 
func lexValueSequence ( l * lexer ) stateFn { switch r := l . next ( ) ; { case r == eof : return lexStatements case isSpace ( r ) : l . emit ( ItemSpace ) lexSpace ( l ) case r == '+' : l . emit ( ItemADD ) case r == '-' : l . emit ( ItemSUB ) case r == 'x' : l . emit ( ItemTimes ) case r == '_' : l . emit ( ItemBlank ) case isDigit ( r ) || ( r == '.' && isDigit ( l . peek ( ) ) ) : l . backup ( ) lexNumber ( l ) case isAlpha ( r ) : l . backup ( ) default : return l . errorf ( " " , r ) } return lexValueSequence } 
func lexEscape ( l * lexer ) { var n int var base , max uint32 ch := l . next ( ) switch ch { case 'a' , 'b' , 'f' , 'n' , 'r' , 't' , 'v' , '\\' , l . stringOpen : return case '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' : n , base , max = 3 , 8 , 255 case 'x' : ch = l . next ( ) n , base , max = 2 , 16 , 255 case 'u' : ch = l . next ( ) n , base , max = 4 , 16 , unicode . MaxRune case 'U' : ch = l . next ( ) n , base , max = 8 , 16 , unicode . MaxRune case eof : l . errorf ( " " ) default : l . errorf ( " " , ch ) } var x uint32 for n > 0 { d := uint32 ( digitVal ( ch ) ) if d >= base { if ch == eof { l . errorf ( " " ) } l . errorf ( " " , ch ) } x = x * base + d ch = l . next ( ) n -- } if x > max || 0xD800 <= x && x < 0xE000 { l . errorf ( " " ) } } 
func digitVal ( ch rune ) int { switch { case '0' <= ch && ch <= '9' : return int ( ch - '0' ) case 'a' <= ch && ch <= 'f' : return int ( ch - 'a' + 10 ) case 'A' <= ch && ch <= 'F' : return int ( ch - 'A' + 10 ) } return 16 } 
func lexString ( l * lexer ) stateFn { Loop : for { switch l . next ( ) { case '\\' : lexEscape ( l ) case utf8 . RuneError : return l . errorf ( " " ) case eof , '\n' : return l . errorf ( " " ) case l . stringOpen : break Loop } } l . emit ( ItemString ) return lexStatements } 
func lexSpace ( l * lexer ) stateFn { for isSpace ( l . peek ( ) ) { l . next ( ) } l . ignore ( ) return lexStatements } 
func lexLineComment ( l * lexer ) stateFn { l . pos += Pos ( len ( lineComment ) ) for r := l . next ( ) ; ! isEndOfLine ( r ) && r != eof ; { r = l . next ( ) } l . backup ( ) l . emit ( ItemComment ) return lexStatements } 
func lexNumber ( l * lexer ) stateFn { if ! l . scanNumber ( ) { return l . errorf ( " " , l . input [ l . start : l . pos ] ) } l . emit ( ItemNumber ) return lexStatements } 
func lexNumberOrDuration ( l * lexer ) stateFn { if l . scanNumber ( ) { l . emit ( ItemNumber ) return lexStatements } } l . backup ( ) l . emit ( ItemDuration ) return lexStatements } return l . errorf ( " " , l . input [ l . start : l . pos ] ) } 
func ( l * lexer ) scanNumber ( ) bool { digits := " " } l . acceptRun ( digits ) if l . accept ( " " ) { l . acceptRun ( digits ) } if l . accept ( " " ) { l . accept ( " " ) l . acceptRun ( " " ) } } return false } 
func lexIdentifier ( l * lexer ) stateFn { for isAlphaNumeric ( l . next ( ) ) { l . backup ( ) l . emit ( ItemIdentifier ) return lexStatements } 
func lexKeywordOrIdentifier ( l * lexer ) stateFn { Loop : for { switch r := l . next ( ) ; { case isAlphaNumeric ( r ) || r == ':' : word := l . input [ l . start : l . pos ] if kw , ok := key [ strings . ToLower ( word ) ] ; ok { l . emit ( kw ) } else if ! strings . Contains ( word , " " ) { l . emit ( ItemIdentifier ) } else { l . emit ( ItemMetricIdentifier ) } break Loop } } if l . seriesDesc && l . peek ( ) != '{' { return lexValueSequence } return lexStatements } 
func isLabel ( s string ) bool { if len ( s ) == 0 || ! isAlpha ( rune ( s [ 0 ] ) ) { return false } for _ , c := range s [ 1 : ] { if ! isAlphaNumeric ( c ) { return false } } return true } 
func ( l * promlexer ) buf ( ) [ ] byte { return l . b [ l . start : l . i ] } 
func NewPromParser ( b [ ] byte ) Parser { return & PromParser { l : & promlexer { b : append ( b , '\n' ) } } } 
func ( p * PromParser ) Series ( ) ( [ ] byte , * int64 , float64 ) { if p . hasTS { return p . series , & p . ts , p . val } return p . series , nil , p . val } 
func ( p * PromParser ) Help ( ) ( [ ] byte , [ ] byte ) { m := p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] } return m , p . text } 
func ( p * PromParser ) Type ( ) ( [ ] byte , MetricType ) { return p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] , p . mtype } 
func ( p * PromParser ) nextToken ( ) token { for { if tok := p . l . Lex ( ) ; tok != tWhitespace { return tok } } } 
func ( p * PromParser ) Next ( ) ( Entry , error ) { var err error p . start = p . l . i p . offsets = p . offsets [ : 0 ] switch t := p . nextToken ( ) ; t { case tEOF : return EntryInvalid , io . EOF case tLinebreak : case tHelp , tType : switch t := p . nextToken ( ) ; t { case tMName : p . offsets = append ( p . offsets , p . l . start , p . l . i ) default : return EntryInvalid , parseError ( " " , t ) } switch t := p . nextToken ( ) ; t { case tText : if len ( p . l . buf ( ) ) > 1 { p . text = p . l . buf ( ) [ 1 : ] } else { p . text = [ ] byte { } } default : return EntryInvalid , parseError ( " " , t ) } switch t { case tType : switch s := yoloString ( p . text ) ; s { case " " : p . mtype = MetricTypeCounter case " " : p . mtype = MetricTypeGauge case " " : p . mtype = MetricTypeHistogram case " " : p . mtype = MetricTypeSummary case " " : p . mtype = MetricTypeUnknown default : return EntryInvalid , errors . Errorf ( " " , s ) } case tHelp : if ! utf8 . Valid ( p . text ) { return EntryInvalid , errors . Errorf ( " " ) } } if t := p . nextToken ( ) ; t != tLinebreak { return EntryInvalid , parseError ( " " , t ) } switch t { case tHelp : return EntryHelp , nil case tType : return EntryType , nil } case tComment : p . text = p . l . buf ( ) if t := p . nextToken ( ) ; t != tLinebreak { return EntryInvalid , parseError ( " " , t ) } return EntryComment , nil case tMName : p . offsets = append ( p . offsets , p . l . i ) p . series = p . l . b [ p . start : p . l . i ] t2 := p . nextToken ( ) if t2 == tBraceOpen { if err := p . parseLVals ( ) ; err != nil { return EntryInvalid , err } p . series = p . l . b [ p . start : p . l . i ] t2 = p . nextToken ( ) } if t2 != tValue { return EntryInvalid , parseError ( " " , t ) } if p . val , err = strconv . ParseFloat ( yoloString ( p . l . buf ( ) ) , 64 ) ; err != nil { return EntryInvalid , err } } p . hasTS = false switch p . nextToken ( ) { case tLinebreak : break case tTimestamp : p . hasTS = true if p . ts , err = strconv . ParseInt ( yoloString ( p . l . buf ( ) ) , 10 , 64 ) ; err != nil { return EntryInvalid , err } if t2 := p . nextToken ( ) ; t2 != tLinebreak { return EntryInvalid , parseError ( " " , t ) } default : return EntryInvalid , parseError ( " " , t ) } return EntrySeries , nil default : err = errors . Errorf ( " " , t ) } return EntryInvalid , err } 
func NewAPI ( qe * promql . Engine , q storage . Queryable , tr targetRetriever , ar alertmanagerRetriever , configFunc func ( ) config . Config , flagsMap map [ string ] string , readyFunc func ( http . HandlerFunc ) http . HandlerFunc , db func ( ) TSDBAdmin , enableAdmin bool , logger log . Logger , rr rulesRetriever , remoteReadSampleLimit int , remoteReadConcurrencyLimit int , CORSOrigin * regexp . Regexp , ) * API { return & API { QueryEngine : qe , Queryable : q , targetRetriever : tr , alertmanagerRetriever : ar , now : time . Now , config : configFunc , flagsMap : flagsMap , ready : readyFunc , db : db , enableAdmin : enableAdmin , rulesRetriever : rr , remoteReadSampleLimit : remoteReadSampleLimit , remoteReadGate : gate . New ( remoteReadConcurrencyLimit ) , logger : logger , CORSOrigin : CORSOrigin , } } 
func ( api * API ) Register ( r * route . Router ) { wrap := func ( f apiFunc ) http . HandlerFunc { hf := http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { httputil . SetCORS ( w , api . CORSOrigin , r ) result := f ( r ) if result . err != nil { api . respondError ( w , result . err , result . data ) } else if result . data != nil { api . respond ( w , result . data , result . warnings ) } else { w . WriteHeader ( http . StatusNoContent ) } if result . finalizer != nil { result . finalizer ( ) } } ) return api . ready ( httputil . CompressionHandler { Handler : hf , } . ServeHTTP ) } r . Options ( " " , wrap ( api . options ) ) r . Get ( " " , wrap ( api . query ) ) r . Post ( " " , wrap ( api . query ) ) r . Get ( " " , wrap ( api . queryRange ) ) r . Post ( " " , wrap ( api . queryRange ) ) r . Get ( " " , wrap ( api . labelNames ) ) r . Post ( " " , wrap ( api . labelNames ) ) r . Get ( " " , wrap ( api . labelValues ) ) r . Get ( " " , wrap ( api . series ) ) r . Post ( " " , wrap ( api . series ) ) r . Del ( " " , wrap ( api . dropSeries ) ) r . Get ( " " , wrap ( api . targets ) ) r . Get ( " " , wrap ( api . targetMetadata ) ) r . Get ( " " , wrap ( api . alertmanagers ) ) r . Get ( " " , wrap ( api . serveConfig ) ) r . Get ( " " , wrap ( api . serveFlags ) ) r . Post ( " " , api . ready ( http . HandlerFunc ( api . remoteRead ) ) ) r . Get ( " " , wrap ( api . alerts ) ) r . Get ( " " , wrap ( api . rules ) ) r . Post ( " " , wrap ( api . cleanTombstones ) ) r . Post ( " " , wrap ( api . snapshot ) ) r . Put ( " " , wrap ( api . deleteSeries ) ) r . Put ( " " , wrap ( api . cleanTombstones ) ) r . Put ( " " , wrap ( api . snapshot ) ) } 
func mergeLabels ( primary , secondary [ ] prompb . Label ) [ ] prompb . Label { result := make ( [ ] prompb . Label , 0 , len ( primary ) + len ( secondary ) ) i , j := 0 , 0 for i < len ( primary ) && j < len ( secondary ) { if primary [ i ] . Name < secondary [ j ] . Name { result = append ( result , primary [ i ] ) i ++ } else if primary [ i ] . Name > secondary [ j ] . Name { result = append ( result , secondary [ j ] ) j ++ } else { result = append ( result , primary [ i ] ) i ++ j ++ } } for ; i < len ( primary ) ; i ++ { result = append ( result , primary [ i ] ) } for ; j < len ( secondary ) ; j ++ { result = append ( result , secondary [ j ] ) } return result } 
func ( l * promlexer ) Lex ( ) token { if l . i >= len ( l . b ) { return tEOF } c := l . b [ l . i ] l . start = l . i yystate0 : switch yyt := l . state ; yyt { default : panic ( errors . Errorf ( `invalid start condition %d` , yyt ) ) case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : } goto yystate0 goto yystate1 yystate1 : c = l . next ( ) yystart1 : switch { default : goto yyabort case c == '#' : goto yystate5 case c == ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate7 case c == '\n' : goto yystate4 case c == '\t' || c == ' ' : goto yystate3 case c == '\x00' : goto yystate2 } yystate2 : c = l . next ( ) goto yyrule1 yystate3 : c = l . next ( ) switch { default : goto yyrule3 case c == '\t' || c == ' ' : goto yystate3 } yystate4 : c = l . next ( ) goto yyrule2 yystate5 : c = l . next ( ) switch { default : goto yyrule5 case c == '\t' || c == ' ' : goto yystate6 } yystate6 : c = l . next ( ) switch { default : goto yyrule4 case c == '\t' || c == ' ' : goto yystate6 } yystate7 : c = l . next ( ) switch { default : goto yyrule10 case c >= '0' && c <= ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate7 } goto yystate8 yystate8 : c = l . next ( ) yystart8 : switch { default : goto yyabort case c == 'H' : goto yystate9 case c == 'T' : goto yystate14 case c == '\t' || c == ' ' : goto yystate3 } yystate9 : c = l . next ( ) switch { default : goto yyabort case c == 'E' : goto yystate10 } yystate10 : c = l . next ( ) switch { default : goto yyabort case c == 'L' : goto yystate11 } yystate11 : c = l . next ( ) switch { default : goto yyabort case c == 'P' : goto yystate12 } yystate12 : c = l . next ( ) switch { default : goto yyabort case c == '\t' || c == ' ' : goto yystate13 } yystate13 : c = l . next ( ) switch { default : goto yyrule6 case c == '\t' || c == ' ' : goto yystate13 } yystate14 : c = l . next ( ) switch { default : goto yyabort case c == 'Y' : goto yystate15 } yystate15 : c = l . next ( ) switch { default : goto yyabort case c == 'P' : goto yystate16 } yystate16 : c = l . next ( ) switch { default : goto yyabort case c == 'E' : goto yystate17 } yystate17 : c = l . next ( ) switch { default : goto yyabort case c == '\t' || c == ' ' : goto yystate18 } yystate18 : c = l . next ( ) switch { default : goto yyrule7 case c == '\t' || c == ' ' : goto yystate18 } goto yystate19 yystate19 : c = l . next ( ) yystart19 : switch { default : goto yyabort case c == ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate20 case c == '\t' || c == ' ' : goto yystate3 } yystate20 : c = l . next ( ) switch { default : goto yyrule8 case c >= '0' && c <= ':' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate20 } goto yystate21 yystate21 : c = l . next ( ) yystart21 : switch { default : goto yyrule9 case c == '\t' || c == ' ' : goto yystate23 case c >= '\x01' && c <= '\b' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate22 } yystate22 : c = l . next ( ) switch { default : goto yyrule9 case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '': goto yystate22 } yystate23 : c = l . next ( ) switch { default : goto yyrule3 case c == '\t' || c == ' ' : goto yystate23 case c >= '\x01' && c <= '\b' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= '': goto yystate22 } goto yystate24 yystate24 : c = l . next ( ) yystart24 : switch { default : goto yyabort case c == ',' : goto yystate25 case c == '=' : goto yystate26 case c == '\t' || c == ' ' : goto yystate3 case c == '}' : goto yystate28 case c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate27 } yystate25 : c = l . next ( ) goto yyrule15 yystate26 : c = l . next ( ) goto yyrule14 yystate27 : c = l . next ( ) switch { default : goto yyrule12 case c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c == '_' || c >= 'a' && c <= 'z' : goto yystate27 } yystate28 : c = l . next ( ) goto yyrule13 goto yystate29 yystate29 : c = l . next ( ) yystart29 : switch { default : goto yyabort case c == '"' : goto yystate30 case c == '\t' || c == ' ' : goto yystate3 } yystate30 : c = l . next ( ) switch { default : goto yyabort case c == '"' : goto yystate31 case c == '\\' : goto yystate32 case c >= '\x01' && c <= '!' || c >= '#' && c <= '[' || c >= ']' && c <= '': goto yystate30 } yystate31 : c = l . next ( ) goto yyrule16 yystate32 : c = l . next ( ) switch { default : goto yyabort case c >= '\x01' && c <= '\t' || c >= '\v' && c <= '': goto yystate30 } goto yystate33 yystate33 : c = l . next ( ) yystart33 : switch { default : goto yyabort case c == '\t' || c == ' ' : goto yystate3 case c == '{' : goto yystate35 case c >= '\x01' && c <= '\b' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= 'z' || c >= '|' && c <= '': goto yystate34 } yystate34 : c = l . next ( ) switch { default : goto yyrule17 case c >= '\x01' && c <= '\b' || c >= '\v' && c <= '\x1f' || c >= '!' && c <= 'z' || c >= '|' && c <= '': goto yystate34 } yystate35 : c = l . next ( ) goto yyrule11 goto yystate36 yystate36 : c = l . next ( ) yystart36 : switch { default : goto yyabort case c == '\n' : goto yystate37 case c == '\t' || c == ' ' : goto yystate3 case c >= '0' && c <= '9' : goto yystate38 } yystate37 : c = l . next ( ) goto yyrule19 yystate38 : c = l . next ( ) switch { default : goto yyrule18 case c >= '0' && c <= '9' : goto yystate38 } yyrule1 : } yyrule2 : return tLinebreak goto yystate0 } yyrule3 : } yyrule4 : goto yystate0 } yyrule5 : } yyrule6 : return tHelp goto yystate0 } yyrule7 : return tType goto yystate0 } yyrule8 : return tMName goto yystate0 } yyrule9 : return tText goto yystate0 } yyrule10 : return tMName goto yystate0 } yyrule11 : return tBraceOpen goto yystate0 } yyrule12 : } yyrule13 : return tBraceClose goto yystate0 } yyrule14 : return tEqual goto yystate0 } yyrule15 : } yyrule16 : return tLValue goto yystate0 } yyrule17 : return tValue goto yystate0 } yyrule18 : } yyrule19 : return tLinebreak goto yystate0 } panic ( " " ) goto yyabort yyabort : } return tInvalid } 
func ( s * ReadyStorage ) Set ( db * tsdb . DB , startTimeMargin int64 ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . a = & adapter { db : db , startTimeMargin : startTimeMargin } } 
func ( s * ReadyStorage ) Get ( ) * tsdb . DB { if x := s . get ( ) ; x != nil { return x . db } return nil } 
func ( s * ReadyStorage ) StartTime ( ) ( int64 , error ) { if x := s . get ( ) ; x != nil { return x . StartTime ( ) } return int64 ( model . Latest ) , ErrNotReady } 
func ( s * ReadyStorage ) Querier ( ctx context . Context , mint , maxt int64 ) ( storage . Querier , error ) { if x := s . get ( ) ; x != nil { return x . Querier ( ctx , mint , maxt ) } return nil , ErrNotReady } 
func ( s * ReadyStorage ) Appender ( ) ( storage . Appender , error ) { if x := s . get ( ) ; x != nil { return x . Appender ( ) } return nil , ErrNotReady } 
func ( s * ReadyStorage ) Close ( ) error { if x := s . Get ( ) ; x != nil { return x . Close ( ) } return nil } 
func Adapter ( db * tsdb . DB , startTimeMargin int64 ) storage . Storage { return & adapter { db : db , startTimeMargin : startTimeMargin } } 
func Open ( path string , l log . Logger , r prometheus . Registerer , opts * Options ) ( * tsdb . DB , error ) { if opts . MinBlockDuration > opts . MaxBlockDuration { opts . MaxBlockDuration = opts . MinBlockDuration } for i , v := range rngs { if v > int64 ( time . Duration ( opts . MaxBlockDuration ) . Seconds ( ) * 1000 ) { rngs = rngs [ : i ] break } } db , err := tsdb . Open ( path , l , r , & tsdb . Options { WALSegmentSize : int ( opts . WALSegmentSize ) , RetentionDuration : uint64 ( time . Duration ( opts . RetentionDuration ) . Seconds ( ) * 1000 ) , MaxBytes : int64 ( opts . MaxBytes ) , BlockRanges : rngs , NoLockfile : opts . NoLockfile , AllowOverlappingBlocks : opts . AllowOverlappingBlocks , } ) if err != nil { return nil , err } registerMetrics ( db , r ) return db , nil } 
func ( a adapter ) StartTime ( ) ( int64 , error ) { var startTime int64 if len ( a . db . Blocks ( ) ) > 0 { startTime = a . db . Blocks ( ) [ 0 ] . Meta ( ) . MinTime } else { startTime = time . Now ( ) . Unix ( ) * 1000 } } 
func ( a adapter ) Appender ( ) ( storage . Appender , error ) { return appender { a : a . db . Appender ( ) } , nil } 
func ( a * Action ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { var s string if err := unmarshal ( & s ) ; err != nil { return err } switch act := Action ( strings . ToLower ( s ) ) ; act { case Replace , Keep , Drop , HashMod , LabelMap , LabelDrop , LabelKeep : * a = act return nil } return errors . Errorf ( " " , s ) } 
func ( c * Config ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultRelabelConfig type plain Config if err := unmarshal ( ( * plain ) ( c ) ) ; err != nil { return err } if c . Regex . Regexp == nil { c . Regex = MustNewRegexp ( " " ) } if c . Modulus == 0 && c . Action == HashMod { return errors . Errorf ( " " ) } if ( c . Action == Replace || c . Action == HashMod ) && c . TargetLabel == " " { return errors . Errorf ( " " , c . Action ) } if c . Action == Replace && ! relabelTarget . MatchString ( c . TargetLabel ) { return errors . Errorf ( " " , c . TargetLabel , c . Action ) } if c . Action == LabelMap && ! relabelTarget . MatchString ( c . Replacement ) { return errors . Errorf ( " " , c . Replacement , c . Action ) } if c . Action == HashMod && ! model . LabelName ( c . TargetLabel ) . IsValid ( ) { return errors . Errorf ( " " , c . TargetLabel , c . Action ) } if c . Action == LabelDrop || c . Action == LabelKeep { if c . SourceLabels != nil || c . TargetLabel != DefaultRelabelConfig . TargetLabel || c . Modulus != DefaultRelabelConfig . Modulus || c . Separator != DefaultRelabelConfig . Separator || c . Replacement != DefaultRelabelConfig . Replacement { return errors . Errorf ( " " , c . Action ) } } return nil } 
func NewRegexp ( s string ) ( Regexp , error ) { regex , err := regexp . Compile ( " " + s + " " ) return Regexp { Regexp : regex , original : s , } , err } 
func MustNewRegexp ( s string ) Regexp { re , err := NewRegexp ( s ) if err != nil { panic ( err ) } return re } 
func ( re * Regexp ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { var s string if err := unmarshal ( & s ) ; err != nil { return err } r , err := NewRegexp ( s ) if err != nil { return err } * re = r return nil } 
func ( re Regexp ) MarshalYAML ( ) ( interface { } , error ) { if re . original != " " { return re . original , nil } return nil , nil } 
func Process ( labels labels . Labels , cfgs ... * Config ) labels . Labels { for _ , cfg := range cfgs { labels = relabel ( labels , cfg ) if labels == nil { return nil } } return labels } 
func sum64 ( hash [ md5 . Size ] byte ) uint64 { var s uint64 for i , b := range hash { shift := uint64 ( ( md5 . Size - i - 1 ) * 8 ) s |= uint64 ( b ) << shift } return s } 
func ( sp * scrapePool ) stop ( ) { sp . cancel ( ) var wg sync . WaitGroup sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) for fp , l := range sp . loops { wg . Add ( 1 ) go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( l ) delete ( sp . loops , fp ) delete ( sp . activeTargets , fp ) } wg . Wait ( ) sp . client . CloseIdleConnections ( ) } 
func ( sp * scrapePool ) reload ( cfg * config . ScrapeConfig ) error { targetScrapePoolReloads . Inc ( ) start := time . Now ( ) sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) client , err := config_util . NewClientFromConfig ( cfg . HTTPClientConfig , cfg . JobName ) if err != nil { targetScrapePoolReloadsFailed . Inc ( ) return errors . Wrap ( err , " " ) } sp . config = cfg oldClient := sp . client sp . client = client var ( wg sync . WaitGroup interval = time . Duration ( sp . config . ScrapeInterval ) timeout = time . Duration ( sp . config . ScrapeTimeout ) limit = int ( sp . config . SampleLimit ) honorLabels = sp . config . HonorLabels honorTimestamps = sp . config . HonorTimestamps mrc = sp . config . MetricRelabelConfigs ) for fp , oldLoop := range sp . loops { var ( t = sp . activeTargets [ fp ] s = & targetScraper { Target : t , client : sp . client , timeout : timeout } newLoop = sp . newLoop ( scrapeLoopOptions { target : t , scraper : s , limit : limit , honorLabels : honorLabels , honorTimestamps : honorTimestamps , mrc : mrc , } ) ) wg . Add ( 1 ) go func ( oldLoop , newLoop loop ) { oldLoop . stop ( ) wg . Done ( ) go newLoop . run ( interval , timeout , nil ) } ( oldLoop , newLoop ) sp . loops [ fp ] = newLoop } wg . Wait ( ) oldClient . CloseIdleConnections ( ) targetReloadIntervalLength . WithLabelValues ( interval . String ( ) ) . Observe ( time . Since ( start ) . Seconds ( ) , ) return nil } 
func ( sp * scrapePool ) Sync ( tgs [ ] * targetgroup . Group ) { start := time . Now ( ) var all [ ] * Target sp . mtx . Lock ( ) sp . droppedTargets = [ ] * Target { } for _ , tg := range tgs { targets , err := targetsFromGroup ( tg , sp . config ) if err != nil { level . Error ( sp . logger ) . Log ( " " , " " , " " , err ) continue } for _ , t := range targets { if t . Labels ( ) . Len ( ) > 0 { all = append ( all , t ) } else if t . DiscoveredLabels ( ) . Len ( ) > 0 { sp . droppedTargets = append ( sp . droppedTargets , t ) } } } sp . mtx . Unlock ( ) sp . sync ( all ) targetSyncIntervalLength . WithLabelValues ( sp . config . JobName ) . Observe ( time . Since ( start ) . Seconds ( ) , ) targetScrapePoolSyncsCounter . WithLabelValues ( sp . config . JobName ) . Inc ( ) } 
func ( sp * scrapePool ) sync ( targets [ ] * Target ) { sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) var ( uniqueTargets = map [ uint64 ] struct { } { } interval = time . Duration ( sp . config . ScrapeInterval ) timeout = time . Duration ( sp . config . ScrapeTimeout ) limit = int ( sp . config . SampleLimit ) honorLabels = sp . config . HonorLabels honorTimestamps = sp . config . HonorTimestamps mrc = sp . config . MetricRelabelConfigs ) for _ , t := range targets { t := t hash := t . hash ( ) uniqueTargets [ hash ] = struct { } { } if _ , ok := sp . activeTargets [ hash ] ; ! ok { s := & targetScraper { Target : t , client : sp . client , timeout : timeout } l := sp . newLoop ( scrapeLoopOptions { target : t , scraper : s , limit : limit , honorLabels : honorLabels , honorTimestamps : honorTimestamps , mrc : mrc , } ) sp . activeTargets [ hash ] = t sp . loops [ hash ] = l go l . run ( interval , timeout , nil ) } else { } } var wg sync . WaitGroup go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( sp . loops [ hash ] ) delete ( sp . loops , hash ) delete ( sp . activeTargets , hash ) } } } 
func appender ( app storage . Appender , limit int ) storage . Appender { app = & timeLimitAppender { Appender : app , maxTime : timestamp . FromTime ( time . Now ( ) . Add ( maxAheadTime ) ) , } } return app } 
func ( i * Ingress ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer i . queue . ShutDown ( ) if ! cache . WaitForCacheSync ( ctx . Done ( ) , i . informer . HasSynced ) { level . Error ( i . logger ) . Log ( " " , " " ) return } go func ( ) { for i . process ( ctx , ch ) { } } ( ) } 
func Uname ( ) string { buf := syscall . Utsname { } err := syscall . Uname ( & buf ) if err != nil { panic ( " " + err . Error ( ) ) } str := " " + charsToString ( buf . Sysname [ : ] ) str += " " + charsToString ( buf . Release [ : ] ) str += " " + charsToString ( buf . Version [ : ] ) str += " " + charsToString ( buf . Machine [ : ] ) str += " " + charsToString ( buf . Nodename [ : ] ) str += " " + charsToString ( buf . Domainname [ : ] ) + " " return str } 
func DecodeReadRequest ( r * http . Request ) ( * prompb . ReadRequest , error ) { compressed , err := ioutil . ReadAll ( io . LimitReader ( r . Body , decodeReadLimit ) ) if err != nil { return nil , err } reqBuf , err := snappy . Decode ( nil , compressed ) if err != nil { return nil , err } var req prompb . ReadRequest if err := proto . Unmarshal ( reqBuf , & req ) ; err != nil { return nil , err } return & req , nil } 
func EncodeReadResponse ( resp * prompb . ReadResponse , w http . ResponseWriter ) error { data , err := proto . Marshal ( resp ) if err != nil { return err } w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) compressed := snappy . Encode ( nil , data ) _ , err = w . Write ( compressed ) return err } 
func ToQuery ( from , to int64 , matchers [ ] * labels . Matcher , p * storage . SelectParams ) ( * prompb . Query , error ) { ms , err := toLabelMatchers ( matchers ) if err != nil { return nil , err } var rp * prompb . ReadHints if p != nil { rp = & prompb . ReadHints { StepMs : p . Step , Func : p . Func , StartMs : p . Start , EndMs : p . End , } } return & prompb . Query { StartTimestampMs : from , EndTimestampMs : to , Matchers : ms , Hints : rp , } , nil } 
func FromQuery ( req * prompb . Query ) ( int64 , int64 , [ ] * labels . Matcher , * storage . SelectParams , error ) { matchers , err := fromLabelMatchers ( req . Matchers ) if err != nil { return 0 , 0 , nil , nil , err } var selectParams * storage . SelectParams if req . Hints != nil { selectParams = & storage . SelectParams { Start : req . Hints . StartMs , End : req . Hints . EndMs , Step : req . Hints . StepMs , Func : req . Hints . Func , } } return req . StartTimestampMs , req . EndTimestampMs , matchers , selectParams , nil } 
func ToQueryResult ( ss storage . SeriesSet , sampleLimit int ) ( * prompb . QueryResult , error ) { numSamples := 0 resp := & prompb . QueryResult { } for ss . Next ( ) { series := ss . At ( ) iter := series . Iterator ( ) samples := [ ] prompb . Sample { } for iter . Next ( ) { numSamples ++ if sampleLimit > 0 && numSamples > sampleLimit { return nil , HTTPError { msg : fmt . Sprintf ( " " , sampleLimit ) , status : http . StatusBadRequest , } } ts , val := iter . At ( ) samples = append ( samples , prompb . Sample { Timestamp : ts , Value : val , } ) } if err := iter . Err ( ) ; err != nil { return nil , err } resp . Timeseries = append ( resp . Timeseries , & prompb . TimeSeries { Labels : labelsToLabelsProto ( series . Labels ( ) ) , Samples : samples , } ) } if err := ss . Err ( ) ; err != nil { return nil , err } return resp , nil } 
func FromQueryResult ( res * prompb . QueryResult ) storage . SeriesSet { series := make ( [ ] storage . Series , 0 , len ( res . Timeseries ) ) for _ , ts := range res . Timeseries { labels := labelProtosToLabels ( ts . Labels ) if err := validateLabelsAndMetricName ( labels ) ; err != nil { return errSeriesSet { err : err } } series = append ( series , & concreteSeries { labels : labels , samples : ts . Samples , } ) } sort . Sort ( byLabel ( series ) ) return & concreteSeriesSet { series : series , } } 
func ( c * concreteSeriesIterator ) Seek ( t int64 ) bool { c . cur = sort . Search ( len ( c . series . samples ) , func ( n int ) bool { return c . series . samples [ n ] . Timestamp >= t } ) return c . cur < len ( c . series . samples ) } 
func ( c * concreteSeriesIterator ) At ( ) ( t int64 , v float64 ) { s := c . series . samples [ c . cur ] return s . Timestamp , s . Value } 
func ( c * concreteSeriesIterator ) Next ( ) bool { c . cur ++ return c . cur < len ( c . series . samples ) } 
func validateLabelsAndMetricName ( ls labels . Labels ) error { for _ , l := range ls { if l . Name == labels . MetricName && ! model . IsValidMetricName ( model . LabelValue ( l . Value ) ) { return errors . Errorf ( " " , l . Value ) } if ! model . LabelName ( l . Name ) . IsValid ( ) { return errors . Errorf ( " " , l . Name ) } if ! model . LabelValue ( l . Value ) . IsValid ( ) { return errors . Errorf ( " " , l . Value ) } } return nil } 
func LabelProtosToMetric ( labelPairs [ ] * prompb . Label ) model . Metric { metric := make ( model . Metric , len ( labelPairs ) ) for _ , l := range labelPairs { metric [ model . LabelName ( l . Name ) ] = model . LabelValue ( l . Value ) } return metric } 
func NewBufferIterator ( it SeriesIterator , delta int64 ) * BufferedSeriesIterator { bit := & BufferedSeriesIterator { buf : newSampleRing ( delta , 16 ) , delta : delta , } bit . Reset ( it ) return bit } 
func ( b * BufferedSeriesIterator ) Reset ( it SeriesIterator ) { b . it = it b . lastTime = math . MinInt64 b . ok = true b . buf . reset ( ) b . buf . delta = b . delta it . Next ( ) } 
func ( b * BufferedSeriesIterator ) ReduceDelta ( delta int64 ) bool { return b . buf . reduceDelta ( delta ) } 
func ( b * BufferedSeriesIterator ) PeekBack ( n int ) ( t int64 , v float64 , ok bool ) { return b . buf . nthLast ( n ) } 
func ( b * BufferedSeriesIterator ) Seek ( t int64 ) bool { t0 := t - b . buf . delta b . ok = b . it . Seek ( t0 ) if ! b . ok { return false } b . lastTime , _ = b . Values ( ) } if b . lastTime >= t { return true } for b . Next ( ) { if b . lastTime >= t { return true } } return false } 
func ( b * BufferedSeriesIterator ) Next ( ) bool { if ! b . ok { return false } b . ok = b . it . Next ( ) if b . ok { b . lastTime , _ = b . Values ( ) } return b . ok } 
func ( r * sampleRing ) iterator ( ) SeriesIterator { r . it . r = r r . it . i = - 1 return & r . it } 
func ( r * sampleRing ) reduceDelta ( delta int64 ) bool { if delta > r . delta { return false } r . delta = delta if r . l == 0 { return true } tmin := r . buf [ r . i ] . t - delta for r . buf [ r . f ] . t < tmin { r . f ++ if r . f >= l { r . f -= l } r . l -- } return true } 
func ( r * sampleRing ) nthLast ( n int ) ( int64 , float64 , bool ) { if n > r . l { return 0 , 0 , false } t , v := r . at ( r . l - n ) return t , v , true } 
func ( l * openMetricsLexer ) buf ( ) [ ] byte { return l . b [ l . start : l . i ] } 
func ( l * openMetricsLexer ) next ( ) byte { l . i ++ if l . i >= len ( l . b ) { l . err = io . EOF return byte ( tEOF ) } if l . i >= len ( l . b ) { l . err = io . EOF return byte ( tEOF ) } } return l . b [ l . i ] } 
func ( p * OpenMetricsParser ) Help ( ) ( [ ] byte , [ ] byte ) { m := p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] } return m , p . text } 
func ( p * OpenMetricsParser ) Unit ( ) ( [ ] byte , [ ] byte ) { } 
func ( p * OpenMetricsParser ) Metric ( l * labels . Labels ) string { * l = append ( * l , labels . Label { Name : labels . MetricName , Value : s [ : p . offsets [ 0 ] - p . start ] , } ) for i := 1 ; i < len ( p . offsets ) ; i += 4 { a := p . offsets [ i ] - p . start b := p . offsets [ i + 1 ] - p . start c := p . offsets [ i + 2 ] - p . start d := p . offsets [ i + 3 ] - p . start continue } * l = append ( * l , labels . Label { Name : s [ a : b ] , Value : s [ c : d ] } ) } return s } 
func ( p * OpenMetricsParser ) Next ( ) ( Entry , error ) { var err error p . start = p . l . i p . offsets = p . offsets [ : 0 ] switch t := p . nextToken ( ) ; t { case tEofWord : if t := p . nextToken ( ) ; t != tEOF { return EntryInvalid , errors . New ( " " ) } return EntryInvalid , io . EOF case tEOF : return EntryInvalid , parseError ( " " , t ) case tHelp , tType , tUnit : switch t := p . nextToken ( ) ; t { case tMName : p . offsets = append ( p . offsets , p . l . start , p . l . i ) default : return EntryInvalid , parseError ( " " , t ) } switch t := p . nextToken ( ) ; t { case tText : if len ( p . l . buf ( ) ) > 1 { p . text = p . l . buf ( ) [ 1 : len ( p . l . buf ( ) ) - 1 ] } else { p . text = [ ] byte { } } default : return EntryInvalid , parseError ( " " , t ) } switch t { case tType : switch s := yoloString ( p . text ) ; s { case " " : p . mtype = MetricTypeCounter case " " : p . mtype = MetricTypeGauge case " " : p . mtype = MetricTypeHistogram case " " : p . mtype = MetricTypeGaugeHistogram case " " : p . mtype = MetricTypeSummary case " " : p . mtype = MetricTypeInfo case " " : p . mtype = MetricTypeStateset case " " : p . mtype = MetricTypeUnknown default : return EntryInvalid , errors . Errorf ( " " , s ) } case tHelp : if ! utf8 . Valid ( p . text ) { return EntryInvalid , errors . New ( " " ) } } switch t { case tHelp : return EntryHelp , nil case tType : return EntryType , nil case tUnit : m := yoloString ( p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] ) u := yoloString ( p . text ) if len ( u ) > 0 { if ! strings . HasSuffix ( m , u ) || len ( m ) < len ( u ) + 1 || p . l . b [ p . offsets [ 1 ] - len ( u ) - 1 ] != '_' { return EntryInvalid , errors . Errorf ( " " , m ) } } return EntryUnit , nil } case tMName : p . offsets = append ( p . offsets , p . l . i ) p . series = p . l . b [ p . start : p . l . i ] t2 := p . nextToken ( ) if t2 == tBraceOpen { if err := p . parseLVals ( ) ; err != nil { return EntryInvalid , err } p . series = p . l . b [ p . start : p . l . i ] t2 = p . nextToken ( ) } if t2 != tValue { return EntryInvalid , parseError ( " " , t ) } if p . val , err = strconv . ParseFloat ( yoloString ( p . l . buf ( ) [ 1 : ] ) , 64 ) ; err != nil { return EntryInvalid , err } } p . hasTS = false switch p . nextToken ( ) { case tLinebreak : break case tTimestamp : p . hasTS = true var ts float64 } p . ts = int64 ( ts * 1000 ) if t2 := p . nextToken ( ) ; t2 != tLinebreak { return EntryInvalid , parseError ( " " , t ) } default : return EntryInvalid , parseError ( " " , t ) } return EntrySeries , nil default : err = errors . Errorf ( " " , t , string ( p . l . cur ( ) ) ) } return EntryInvalid , err } 
func bucketQuantile ( q float64 , buckets buckets ) float64 { if q < 0 { return math . Inf ( - 1 ) } if q > 1 { return math . Inf ( + 1 ) } sort . Sort ( buckets ) if ! math . IsInf ( buckets [ len ( buckets ) - 1 ] . upperBound , + 1 ) { return math . NaN ( ) } buckets = coalesceBuckets ( buckets ) ensureMonotonic ( buckets ) if len ( buckets ) < 2 { return math . NaN ( ) } rank := q * buckets [ len ( buckets ) - 1 ] . count b := sort . Search ( len ( buckets ) - 1 , func ( i int ) bool { return buckets [ i ] . count >= rank } ) if b == len ( buckets ) - 1 { return buckets [ len ( buckets ) - 2 ] . upperBound } if b == 0 && buckets [ 0 ] . upperBound <= 0 { return buckets [ 0 ] . upperBound } var ( bucketStart float64 bucketEnd = buckets [ b ] . upperBound count = buckets [ b ] . count ) if b > 0 { bucketStart = buckets [ b - 1 ] . upperBound count -= buckets [ b - 1 ] . count rank -= buckets [ b - 1 ] . count } return bucketStart + ( bucketEnd - bucketStart ) * ( rank / count ) } 
func coalesceBuckets ( buckets buckets ) buckets { last := buckets [ 0 ] i := 0 for _ , b := range buckets [ 1 : ] { if b . upperBound == last . upperBound { last . count += b . count } else { buckets [ i ] = last last = b i ++ } } buckets [ i ] = last return buckets [ : i + 1 ] } 
func ensureMonotonic ( buckets buckets ) { max := buckets [ 0 ] . count for i := range buckets [ 1 : ] { switch { case buckets [ i ] . count > max : max = buckets [ i ] . count case buckets [ i ] . count < max : buckets [ i ] . count = max } } } 
func quantile ( q float64 , values vectorByValueHeap ) float64 { if len ( values ) == 0 { return math . NaN ( ) } if q < 0 { return math . Inf ( - 1 ) } if q > 1 { return math . Inf ( + 1 ) } sort . Sort ( values ) n := float64 ( len ( values ) ) lowerIndex := math . Max ( 0 , math . Floor ( rank ) ) upperIndex := math . Min ( n - 1 , lowerIndex + 1 ) weight := rank - math . Floor ( rank ) return values [ int ( lowerIndex ) ] . V * ( 1 - weight ) + values [ int ( upperIndex ) ] . V * weight } 
func ( c * SDConfig ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { * c = DefaultSDConfig type plain SDConfig err := unmarshal ( ( * plain ) ( c ) ) if err != nil { return err } if len ( c . Files ) == 0 { return errors . New ( " " ) } for _ , name := range c . Files { if ! patFileSDName . MatchString ( name ) { return errors . Errorf ( " " , name ) } } return nil } 
func ( t * TimestampCollector ) Collect ( ch chan <- prometheus . Metric ) { t . lock . RLock ( ) for fileSD := range t . discoverers { fileSD . lock . RLock ( ) for filename , timestamp := range fileSD . timestamps { uniqueFiles [ filename ] = timestamp } fileSD . lock . RUnlock ( ) } t . lock . RUnlock ( ) for filename , timestamp := range uniqueFiles { ch <- prometheus . MustNewConstMetric ( t . Description , prometheus . GaugeValue , timestamp , filename , ) } } 
func NewTimestampCollector ( ) * TimestampCollector { return & TimestampCollector { Description : prometheus . NewDesc ( " " , " " , [ ] string { " " } , nil , ) , discoverers : make ( map [ * Discovery ] struct { } ) , } } 
func NewDiscovery ( conf * SDConfig , logger log . Logger ) * Discovery { if logger == nil { logger = log . NewNopLogger ( ) } disc := & Discovery { paths : conf . Files , interval : time . Duration ( conf . RefreshInterval ) , timestamps : make ( map [ string ] float64 ) , logger : logger , } fileSDTimeStamp . addDiscoverer ( disc ) return disc } 
func ( d * Discovery ) listFiles ( ) [ ] string { var paths [ ] string for _ , p := range d . paths { files , err := filepath . Glob ( p ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) continue } paths = append ( paths , files ... ) } return paths } 
func ( d * Discovery ) watchFiles ( ) { if d . watcher == nil { panic ( " " ) } for _ , p := range d . paths { if idx := strings . LastIndex ( p , " " ) ; idx > - 1 { p = p [ : idx ] } else { p = " " } if err := d . watcher . Add ( p ) ; err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) } } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { watcher , err := fsnotify . NewWatcher ( ) if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) return } d . watcher = watcher defer d . stop ( ) d . refresh ( ctx , ch ) ticker := time . NewTicker ( d . interval ) defer ticker . Stop ( ) for { select { case <- ctx . Done ( ) : return case event := <- d . watcher . Events : } } case <- ticker . C : case err := <- d . watcher . Errors : if err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) } } } } 
func ( d * Discovery ) stop ( ) { level . Debug ( d . logger ) . Log ( " " , " " , " " , fmt . Sprintf ( " " , d . paths ) ) done := make ( chan struct { } ) defer close ( done ) fileSDTimeStamp . removeDiscoverer ( d ) } } } ( ) if err := d . watcher . Close ( ) ; err != nil { level . Error ( d . logger ) . Log ( " " , " " , " " , fmt . Sprintf ( " " , d . paths ) , " " , err ) } level . Debug ( d . logger ) . Log ( " " , " " ) } 
func ( d * Discovery ) refresh ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { t0 := time . Now ( ) defer func ( ) { fileSDScanDuration . Observe ( time . Since ( t0 ) . Seconds ( ) ) } ( ) ref := map [ string ] int { } for _ , p := range d . listFiles ( ) { tgroups , err := d . readFile ( p ) if err != nil { fileSDReadErrorsCount . Inc ( ) level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) continue } select { case ch <- tgroups : case <- ctx . Done ( ) : return } ref [ p ] = len ( tgroups ) } if ! ok || n > m { level . Debug ( d . logger ) . Log ( " " , " " , " " , f ) d . deleteTimestamp ( f ) for i := m ; i < n ; i ++ { select { case ch <- [ ] * targetgroup . Group { { Source : fileSource ( f , i ) } } : case <- ctx . Done ( ) : return } } } } d . lastRefresh = ref d . watchFiles ( ) } 
func ( d * Discovery ) readFile ( filename string ) ( [ ] * targetgroup . Group , error ) { fd , err := os . Open ( filename ) if err != nil { return nil , err } defer fd . Close ( ) content , err := ioutil . ReadAll ( fd ) if err != nil { return nil , err } info , err := fd . Stat ( ) if err != nil { return nil , err } var targetGroups [ ] * targetgroup . Group switch ext := filepath . Ext ( filename ) ; strings . ToLower ( ext ) { case " " : if err := json . Unmarshal ( content , & targetGroups ) ; err != nil { return nil , err } case " " , " " : if err := yaml . UnmarshalStrict ( content , & targetGroups ) ; err != nil { return nil , err } default : panic ( errors . Errorf ( " " , ext ) ) } for i , tg := range targetGroups { if tg == nil { err = errors . New ( " " ) return nil , err } tg . Source = fileSource ( filename , i ) if tg . Labels == nil { tg . Labels = model . LabelSet { } } tg . Labels [ fileSDFilepathLabel ] = model . LabelValue ( filename ) } d . writeTimestamp ( filename , float64 ( info . ModTime ( ) . Unix ( ) ) ) return targetGroups , nil } 
func fileSource ( filename string , i int ) string { return fmt . Sprintf ( " " , filename , i ) } 
func NewRecordingRule ( name string , vector promql . Expr , lset labels . Labels ) * RecordingRule { return & RecordingRule { name : name , vector : vector , health : HealthUnknown , labels : lset , } } 
func ( rule * RecordingRule ) Eval ( ctx context . Context , ts time . Time , query QueryFunc , _ * url . URL ) ( promql . Vector , error ) { vector , err := query ( ctx , rule . vector . String ( ) , ts ) if err != nil { rule . SetHealth ( HealthBad ) rule . SetLastError ( err ) return nil , err } lb := labels . NewBuilder ( sample . Metric ) lb . Set ( labels . MetricName , rule . name ) for _ , l := range rule . labels { if l . Value == " " { lb . Del ( l . Name ) } else { lb . Set ( l . Name , l . Value ) } } sample . Metric = lb . Labels ( ) } rule . SetHealth ( HealthGood ) rule . SetLastError ( err ) return vector , nil } 
func ( rule * RecordingRule ) SetEvaluationDuration ( dur time . Duration ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . evaluationDuration = dur } 
func ( rule * RecordingRule ) SetLastError ( err error ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . lastError = err } 
func ( rule * RecordingRule ) LastError ( ) error { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . lastError } 
func ( rule * RecordingRule ) SetHealth ( health RuleHealth ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . health = health } 
func ( rule * RecordingRule ) Health ( ) RuleHealth { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . health } 
func ( rule * RecordingRule ) GetEvaluationDuration ( ) time . Duration { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . evaluationDuration } 
func ( rule * RecordingRule ) SetEvaluationTimestamp ( ts time . Time ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . evaluationTimestamp = ts } 
func ( rule * RecordingRule ) GetEvaluationTimestamp ( ) time . Time { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . evaluationTimestamp } 
func ( rule * RecordingRule ) HTMLSnippet ( pathPrefix string ) template . HTML { ruleExpr := rule . vector . String ( ) labels := make ( map [ string ] string , len ( rule . labels ) ) for _ , l := range rule . labels { labels [ l . Name ] = template . HTMLEscapeString ( l . Value ) } r := rulefmt . Rule { Record : fmt . Sprintf ( `<a href="%s">%s</a>` , pathPrefix + strutil . TableLinkForExpression ( rule . name ) , rule . name ) , Expr : fmt . Sprintf ( `<a href="%s">%s</a>` , pathPrefix + strutil . TableLinkForExpression ( ruleExpr ) , template . HTMLEscapeString ( ruleExpr ) ) , Labels : labels , } byt , err := yaml . Marshal ( r ) if err != nil { return template . HTML ( fmt . Sprintf ( " " , template . HTMLEscapeString ( err . Error ( ) ) ) ) } return template . HTML ( byt ) } 
func newEWMARate ( alpha float64 , interval time . Duration ) * ewmaRate { return & ewmaRate { alpha : alpha , interval : interval , } } 
func ( r * ewmaRate ) rate ( ) float64 { r . mutex . Lock ( ) defer r . mutex . Unlock ( ) return r . lastRate } 
func ( r * ewmaRate ) tick ( ) { newEvents := atomic . LoadInt64 ( & r . newEvents ) atomic . AddInt64 ( & r . newEvents , - newEvents ) instantRate := float64 ( newEvents ) / r . interval . Seconds ( ) r . mutex . Lock ( ) defer r . mutex . Unlock ( ) if r . init { r . lastRate += r . alpha * ( instantRate - r . lastRate ) } else { r . init = true r . lastRate = instantRate } } 
func ( r * ewmaRate ) incr ( incr int64 ) { atomic . AddInt64 ( & r . newEvents , incr ) } 
func NewNode ( l log . Logger , inf cache . SharedInformer ) * Node { if l == nil { l = log . NewNopLogger ( ) } n := & Node { logger : l , informer : inf , store : inf . GetStore ( ) , queue : workqueue . NewNamed ( " " ) } n . informer . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , DeleteFunc : func ( o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , UpdateFunc : func ( _ , o interface { } ) { eventCount . WithLabelValues ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , } ) return n } 
func ( n * Node ) Run ( ctx context . Context , ch chan <- [ ] * targetgroup . Group ) { defer n . queue . ShutDown ( ) if ! cache . WaitForCacheSync ( ctx . Done ( ) , n . informer . HasSynced ) { level . Error ( n . logger ) . Log ( " " , " " ) return } go func ( ) { for n . process ( ctx , ch ) { } } ( ) } 
func nodeAddress ( node * apiv1 . Node ) ( string , map [ apiv1 . NodeAddressType ] [ ] string , error ) { m := map [ apiv1 . NodeAddressType ] [ ] string { } for _ , a := range node . Status . Addresses { m [ a . Type ] = append ( m [ a . Type ] , a . Address ) } if addresses , ok := m [ apiv1 . NodeInternalIP ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok := m [ apiv1 . NodeExternalIP ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok := m [ apiv1 . NodeAddressType ( NodeLegacyHostIP ) ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok := m [ apiv1 . NodeHostName ] ; ok { return addresses [ 0 ] , m , nil } return " " , m , errors . New ( " " ) } 
func CheckConfig ( files ... string ) int { failed := false for _ , f := range files { ruleFiles , err := checkConfig ( f ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) failed = true } else { fmt . Printf ( " \n " , len ( ruleFiles ) ) } fmt . Println ( ) for _ , rf := range ruleFiles { if n , err := checkRules ( rf ) ; err != nil { fmt . Fprintln ( os . Stderr , " " , err ) failed = true } else { fmt . Printf ( " \n " , n ) } fmt . Println ( ) } } if failed { return 1 } return 0 } 
func CheckRules ( files ... string ) int { failed := false for _ , f := range files { if n , errs := checkRules ( f ) ; errs != nil { fmt . Fprintln ( os . Stderr , " " ) for _ , e := range errs { fmt . Fprintln ( os . Stderr , e . Error ( ) ) } failed = true } else { fmt . Printf ( " \n " , n ) } fmt . Println ( ) } if failed { return 1 } return 0 } 
func CheckMetrics ( ) int { l := promlint . New ( os . Stdin ) problems , err := l . Lint ( ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } for _ , p := range problems { fmt . Fprintln ( os . Stderr , p . Metric , p . Text ) } if len ( problems ) > 0 { return 3 } return 0 } 
func QueryInstant ( url , query string , p printer ) int { config := api . Config { Address : url , } if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . Query ( ctx , query , time . Now ( ) ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . printValue ( val ) return 0 } 
func QueryRange ( url , query , start , end string , step time . Duration , p printer ) int { config := api . Config { Address : url , } if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } var stime , etime time . Time if end == " " { etime = time . Now ( ) } else { etime , err = parseTime ( end ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } } if start == " " { stime = etime . Add ( - 5 * time . Minute ) } else { stime , err = parseTime ( start ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) } } if ! stime . Before ( etime ) { fmt . Fprintln ( os . Stderr , " " ) } if step == 0 { resolution := math . Max ( math . Floor ( etime . Sub ( stime ) . Seconds ( ) / 250 ) , 1 ) } r := v1 . Range { Start : stime , End : etime , Step : step } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . QueryRange ( ctx , query , r ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . printValue ( val ) return 0 } 
func QuerySeries ( url * url . URL , matchers [ ] string , start , end string , p printer ) int { config := api . Config { Address : url . String ( ) , } if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } maxTime = time . Now ( ) . Add ( 9999 * time . Hour ) ) var stime , etime time . Time if start == " " { stime = minTime } else { stime , err = parseTime ( start ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) } } if end == " " { etime = maxTime } else { etime , err = parseTime ( end ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) } } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . Series ( ctx , matchers , stime , etime ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . printSeries ( val ) return 0 } 
func QueryLabels ( url * url . URL , name string , p printer ) int { config := api . Config { Address : url . String ( ) , } if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } ctx , cancel := context . WithTimeout ( context . Background ( ) , 2 * time . Minute ) val , err := api . LabelValues ( ctx , name ) cancel ( ) if err != nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . printLabelValues ( val ) return 0 } 
func ( tg * Group ) UnmarshalYAML ( unmarshal func ( interface { } ) error ) error { g := struct { Targets [ ] string `yaml:"targets"` Labels model . LabelSet `yaml:"labels"` } { } if err := unmarshal ( & g ) ; err != nil { return err } tg . Targets = make ( [ ] model . LabelSet , 0 , len ( g . Targets ) ) for _ , t := range g . Targets { tg . Targets = append ( tg . Targets , model . LabelSet { model . AddressLabel : model . LabelValue ( t ) , } ) } tg . Labels = g . Labels return nil } 
func ( tg Group ) MarshalYAML ( ) ( interface { } , error ) { g := & struct { Targets [ ] string `yaml:"targets"` Labels model . LabelSet `yaml:"labels,omitempty"` } { Targets : make ( [ ] string , 0 , len ( tg . Targets ) ) , Labels : tg . Labels , } for _ , t := range tg . Targets { g . Targets = append ( g . Targets , string ( t [ model . AddressLabel ] ) ) } return g , nil } 
func ( tg * Group ) UnmarshalJSON ( b [ ] byte ) error { g := struct { Targets [ ] string `json:"targets"` Labels model . LabelSet `json:"labels"` } { } dec := json . NewDecoder ( bytes . NewReader ( b ) ) dec . DisallowUnknownFields ( ) if err := dec . Decode ( & g ) ; err != nil { return err } tg . Targets = make ( [ ] model . LabelSet , 0 , len ( g . Targets ) ) for _ , t := range g . Targets { tg . Targets = append ( tg . Targets , model . LabelSet { model . AddressLabel : model . LabelValue ( t ) , } ) } tg . Labels = g . Labels return nil } 
func NewStreamReader ( sw StreamWriter ) io . ReadCloser { pc := fasthttputil . NewPipeConns ( ) pw := pc . Conn1 ( ) pr := pc . Conn2 ( ) var bw * bufio . Writer v := streamWriterBufPool . Get ( ) if v == nil { bw = bufio . NewWriter ( pw ) } else { bw = v . ( * bufio . Writer ) bw . Reset ( pw ) } go func ( ) { sw ( bw ) bw . Flush ( ) pw . Close ( ) streamWriterBufPool . Put ( bw ) } ( ) return pr } 
func ExpvarHandler ( ctx * fasthttp . RequestCtx ) { expvarHandlerCalls . Add ( 1 ) ctx . Response . Reset ( ) r , err := getExpvarRegexp ( ctx ) if err != nil { expvarRegexpErrors . Add ( 1 ) fmt . Fprintf ( ctx , " " , err ) ctx . SetStatusCode ( fasthttp . StatusBadRequest ) return } fmt . Fprintf ( ctx , " \n " ) first := true expvar . Do ( func ( kv expvar . KeyValue ) { if r . MatchString ( kv . Key ) { if ! first { fmt . Fprintf ( ctx , " \n " ) } first = false fmt . Fprintf ( ctx , " \t " , kv . Key , kv . Value ) } } ) fmt . Fprintf ( ctx , " \n \n " ) ctx . SetContentType ( " " ) } 
func StatusMessage ( statusCode int ) string { s := statusMessages [ statusCode ] if s == " " { s = " " } return s } 
func ( a * Args ) CopyTo ( dst * Args ) { dst . Reset ( ) dst . args = copyArgs ( dst . args , a . args ) } 
func ( a * Args ) VisitAll ( f func ( key , value [ ] byte ) ) { visitArgs ( a . args , f ) } 
func ( a * Args ) Parse ( s string ) { a . buf = append ( a . buf [ : 0 ] , s ... ) a . ParseBytes ( a . buf ) } 
func ( a * Args ) ParseBytes ( b [ ] byte ) { a . Reset ( ) var s argsScanner s . b = b var kv * argsKV a . args , kv = allocArg ( a . args ) for s . next ( kv ) { if len ( kv . key ) > 0 || len ( kv . value ) > 0 { a . args , kv = allocArg ( a . args ) } } a . args = releaseArg ( a . args ) } 
func ( a * Args ) QueryString ( ) [ ] byte { a . buf = a . AppendBytes ( a . buf [ : 0 ] ) return a . buf } 
func ( a * Args ) Sort ( f func ( x , y [ ] byte ) int ) { sort . SliceStable ( a . args , func ( i , j int ) bool { n := f ( a . args [ i ] . key , a . args [ j ] . key ) if n == 0 { return f ( a . args [ i ] . value , a . args [ j ] . value ) == - 1 } return n == - 1 } ) } 
func ( a * Args ) AppendBytes ( dst [ ] byte ) [ ] byte { for i , n := 0 , len ( a . args ) ; i < n ; i ++ { kv := & a . args [ i ] dst = AppendQuotedArg ( dst , kv . key ) if ! kv . noValue { dst = append ( dst , '=' ) if len ( kv . value ) > 0 { dst = AppendQuotedArg ( dst , kv . value ) } } if i + 1 < n { dst = append ( dst , '&' ) } } return dst } 
func ( a * Args ) WriteTo ( w io . Writer ) ( int64 , error ) { n , err := w . Write ( a . QueryString ( ) ) return int64 ( n ) , err } 
func ( a * Args ) Del ( key string ) { a . args = delAllArgs ( a . args , key ) } 
func ( a * Args ) DelBytes ( key [ ] byte ) { a . args = delAllArgs ( a . args , b2s ( key ) ) } 
func ( a * Args ) Add ( key , value string ) { a . args = appendArg ( a . args , key , value , argsHasValue ) } 
func ( a * Args ) AddBytesK ( key [ ] byte , value string ) { a . args = appendArg ( a . args , b2s ( key ) , value , argsHasValue ) } 
func ( a * Args ) AddBytesKV ( key , value [ ] byte ) { a . args = appendArg ( a . args , b2s ( key ) , b2s ( value ) , argsHasValue ) } 
func ( a * Args ) AddNoValue ( key string ) { a . args = appendArg ( a . args , key , " " , argsNoValue ) } 
func ( a * Args ) AddBytesKNoValue ( key [ ] byte ) { a . args = appendArg ( a . args , b2s ( key ) , " " , argsNoValue ) } 
func ( a * Args ) Set ( key , value string ) { a . args = setArg ( a . args , key , value , argsHasValue ) } 
func ( a * Args ) SetBytesV ( key string , value [ ] byte ) { a . args = setArg ( a . args , key , b2s ( value ) , argsHasValue ) } 
func ( a * Args ) SetBytesKV ( key , value [ ] byte ) { a . args = setArgBytes ( a . args , key , value , argsHasValue ) } 
func ( a * Args ) SetNoValue ( key string ) { a . args = setArg ( a . args , key , " " , argsNoValue ) } 
func ( a * Args ) SetBytesKNoValue ( key [ ] byte ) { a . args = setArg ( a . args , b2s ( key ) , " " , argsNoValue ) } 
func ( a * Args ) Peek ( key string ) [ ] byte { return peekArgStr ( a . args , key ) } 
func ( a * Args ) PeekBytes ( key [ ] byte ) [ ] byte { return peekArgBytes ( a . args , key ) } 
func ( a * Args ) PeekMulti ( key string ) [ ] [ ] byte { var values [ ] [ ] byte a . VisitAll ( func ( k , v [ ] byte ) { if string ( k ) == key { values = append ( values , v ) } } ) return values } 
func ( a * Args ) PeekMultiBytes ( key [ ] byte ) [ ] [ ] byte { return a . PeekMulti ( b2s ( key ) ) } 
func ( a * Args ) Has ( key string ) bool { return hasArg ( a . args , key ) } 
func ( a * Args ) HasBytes ( key [ ] byte ) bool { return hasArg ( a . args , b2s ( key ) ) } 
func ( a * Args ) GetUint ( key string ) ( int , error ) { value := a . Peek ( key ) if len ( value ) == 0 { return - 1 , ErrNoArgValue } return ParseUint ( value ) } 
func ( a * Args ) SetUint ( key string , value int ) { bb := bytebufferpool . Get ( ) bb . B = AppendUint ( bb . B [ : 0 ] , value ) a . SetBytesV ( key , bb . B ) bytebufferpool . Put ( bb ) } 
func ( a * Args ) SetUintBytes ( key [ ] byte , value int ) { a . SetUint ( b2s ( key ) , value ) } 
func ( a * Args ) GetUintOrZero ( key string ) int { n , err := a . GetUint ( key ) if err != nil { n = 0 } return n } 
func ( a * Args ) GetUfloat ( key string ) ( float64 , error ) { value := a . Peek ( key ) if len ( value ) == 0 { return - 1 , ErrNoArgValue } return ParseUfloat ( value ) } 
func ( a * Args ) GetUfloatOrZero ( key string ) float64 { f , err := a . GetUfloat ( key ) if err != nil { f = 0 } return f } 
func ( a * Args ) GetBool ( key string ) bool { switch b2s ( a . Peek ( key ) ) { default : return false } } 
func decodeArgAppendNoPlus ( dst , src [ ] byte ) [ ] byte { if bytes . IndexByte ( src , '%' ) < 0 { } if c == '%' { if i + 2 >= len ( src ) { return append ( dst , src [ i : ] ... ) } x2 := hex2intTable [ src [ i + 2 ] ] x1 := hex2intTable [ src [ i + 1 ] ] if x1 == 16 || x2 == 16 { dst = append ( dst , '%' ) } else { dst = append ( dst , x1 << 4 | x2 ) i += 2 } } else { dst = append ( dst , c ) } } return dst } 
func AppendHTMLEscape ( dst [ ] byte , s string ) [ ] byte { if strings . IndexByte ( s , '<' ) < 0 && strings . IndexByte ( s , '>' ) < 0 && strings . IndexByte ( s , '"' ) < 0 && strings . IndexByte ( s , '\'' ) < 0 { // fast path - nothing to escape return append ( dst , s ... ) } // slow path var prev int var sub string for i , n := 0 , len ( s ) ; i < n ; i ++ { sub = " " switch s [ i ] { case '<' : sub = " " case '>' : sub = " " case '"' : sub = " " case '\'' : sub = " " } if len ( sub ) > 0 { dst = append ( dst , s [ prev : i ] ... ) dst = append ( dst , sub ... ) prev = i + 1 } } return append ( dst , s [ prev : ] ... ) } 
func AppendIPv4 ( dst [ ] byte , ip net . IP ) [ ] byte { ip = ip . To4 ( ) if ip == nil { return append ( dst , " " ... ) } dst = AppendUint ( dst , int ( ip [ 0 ] ) ) for i := 1 ; i < 4 ; i ++ { dst = append ( dst , '.' ) dst = AppendUint ( dst , int ( ip [ i ] ) ) } return dst } 
func ParseIPv4 ( dst net . IP , ipStr [ ] byte ) ( net . IP , error ) { if len ( ipStr ) == 0 { return dst , errEmptyIPStr } if len ( dst ) < net . IPv4len { dst = make ( [ ] byte , net . IPv4len ) } copy ( dst , net . IPv4zero ) dst = dst . To4 ( ) if dst == nil { panic ( " " ) } b := ipStr for i := 0 ; i < 3 ; i ++ { n := bytes . IndexByte ( b , '.' ) if n < 0 { return dst , fmt . Errorf ( " " , ipStr ) } v , err := ParseUint ( b [ : n ] ) if err != nil { return dst , fmt . Errorf ( " " , ipStr , err ) } if v > 255 { return dst , fmt . Errorf ( " " , ipStr , v ) } dst [ i ] = byte ( v ) b = b [ n + 1 : ] } v , err := ParseUint ( b ) if err != nil { return dst , fmt . Errorf ( " " , ipStr , err ) } if v > 255 { return dst , fmt . Errorf ( " " , ipStr , v ) } dst [ 3 ] = byte ( v ) return dst , nil } 
func AppendHTTPDate ( dst [ ] byte , date time . Time ) [ ] byte { dst = date . In ( time . UTC ) . AppendFormat ( dst , time . RFC1123 ) copy ( dst [ len ( dst ) - 3 : ] , strGMT ) return dst } 
func ParseHTTPDate ( date [ ] byte ) ( time . Time , error ) { return time . Parse ( time . RFC1123 , b2s ( date ) ) } 
func ParseUint ( buf [ ] byte ) ( int , error ) { v , n , err := parseUintBuf ( buf ) if n != len ( buf ) { return - 1 , errUnexpectedTrailingChar } return v , err } 
func ParseUfloat ( buf [ ] byte ) ( float64 , error ) { if len ( buf ) == 0 { return - 1 , errEmptyFloat } b := buf var v uint64 var offset = 1.0 var pointFound bool for i , c := range b { if c < '0' || c > '9' { if c == '.' { if pointFound { return - 1 , errDuplicateFloatPoint } pointFound = true continue } if c == 'e' || c == 'E' { if i + 1 >= len ( b ) { return - 1 , errUnexpectedFloatEnd } b = b [ i + 1 : ] minus := - 1 switch b [ 0 ] { case '+' : b = b [ 1 : ] minus = 1 case '-' : b = b [ 1 : ] default : minus = 1 } vv , err := ParseUint ( b ) if err != nil { return - 1 , errInvalidFloatExponent } return float64 ( v ) * offset * math . Pow10 ( minus * int ( vv ) ) , nil } return - 1 , errUnexpectedFloatChar } v = 10 * v + uint64 ( c - '0' ) if pointFound { offset /= 10 } } return float64 ( v ) * offset , nil } 
func AppendQuotedArg ( dst , src [ ] byte ) [ ] byte { for _ , c := range src { } else { dst = append ( dst , '%' , hexCharUpper ( c >> 4 ) , hexCharUpper ( c & 15 ) ) } } return dst } 
func ( u * URI ) CopyTo ( dst * URI ) { dst . Reset ( ) dst . pathOriginal = append ( dst . pathOriginal [ : 0 ] , u . pathOriginal ... ) dst . scheme = append ( dst . scheme [ : 0 ] , u . scheme ... ) dst . path = append ( dst . path [ : 0 ] , u . path ... ) dst . queryString = append ( dst . queryString [ : 0 ] , u . queryString ... ) dst . hash = append ( dst . hash [ : 0 ] , u . hash ... ) dst . host = append ( dst . host [ : 0 ] , u . host ... ) u . queryArgs . CopyTo ( & dst . queryArgs ) dst . parsedQueryArgs = u . parsedQueryArgs } 
func ( u * URI ) SetHash ( hash string ) { u . hash = append ( u . hash [ : 0 ] , hash ... ) } 
func ( u * URI ) SetHashBytes ( hash [ ] byte ) { u . hash = append ( u . hash [ : 0 ] , hash ... ) } 
func ( u * URI ) SetQueryString ( queryString string ) { u . queryString = append ( u . queryString [ : 0 ] , queryString ... ) u . parsedQueryArgs = false } 
func ( u * URI ) SetQueryStringBytes ( queryString [ ] byte ) { u . queryString = append ( u . queryString [ : 0 ] , queryString ... ) u . parsedQueryArgs = false } 
func ( u * URI ) Path ( ) [ ] byte { path := u . path if len ( path ) == 0 { path = strSlash } return path } 
func ( u * URI ) SetPath ( path string ) { u . pathOriginal = append ( u . pathOriginal [ : 0 ] , path ... ) u . path = normalizePath ( u . path , u . pathOriginal ) } 
func ( u * URI ) SetPathBytes ( path [ ] byte ) { u . pathOriginal = append ( u . pathOriginal [ : 0 ] , path ... ) u . path = normalizePath ( u . path , u . pathOriginal ) } 
func ( u * URI ) Scheme ( ) [ ] byte { scheme := u . scheme if len ( scheme ) == 0 { scheme = strHTTP } return scheme } 
func ( u * URI ) SetScheme ( scheme string ) { u . scheme = append ( u . scheme [ : 0 ] , scheme ... ) lowercaseBytes ( u . scheme ) } 
func ( u * URI ) SetSchemeBytes ( scheme [ ] byte ) { u . scheme = append ( u . scheme [ : 0 ] , scheme ... ) lowercaseBytes ( u . scheme ) } 
func ( u * URI ) Reset ( ) { u . pathOriginal = u . pathOriginal [ : 0 ] u . scheme = u . scheme [ : 0 ] u . path = u . path [ : 0 ] u . queryString = u . queryString [ : 0 ] u . hash = u . hash [ : 0 ] u . host = u . host [ : 0 ] u . queryArgs . Reset ( ) u . parsedQueryArgs = false } 
func ( u * URI ) Host ( ) [ ] byte { if len ( u . host ) == 0 && u . h != nil { u . host = append ( u . host [ : 0 ] , u . h . Host ( ) ... ) lowercaseBytes ( u . host ) u . h = nil } return u . host } 
func ( u * URI ) SetHost ( host string ) { u . host = append ( u . host [ : 0 ] , host ... ) lowercaseBytes ( u . host ) } 
func ( u * URI ) SetHostBytes ( host [ ] byte ) { u . host = append ( u . host [ : 0 ] , host ... ) lowercaseBytes ( u . host ) } 
func ( u * URI ) Parse ( host , uri [ ] byte ) { u . parse ( host , uri , nil ) } 
func ( u * URI ) RequestURI ( ) [ ] byte { dst := appendQuotedPath ( u . requestURI [ : 0 ] , u . Path ( ) ) if u . queryArgs . Len ( ) > 0 { dst = append ( dst , '?' ) dst = u . queryArgs . AppendBytes ( dst ) } else if len ( u . queryString ) > 0 { dst = append ( dst , '?' ) dst = append ( dst , u . queryString ... ) } if len ( u . hash ) > 0 { dst = append ( dst , '#' ) dst = append ( dst , u . hash ... ) } u . requestURI = dst return u . requestURI } 
func ( u * URI ) LastPathSegment ( ) [ ] byte { path := u . Path ( ) n := bytes . LastIndexByte ( path , '/' ) if n < 0 { return path } return path [ n + 1 : ] } 
func ( u * URI ) UpdateBytes ( newURI [ ] byte ) { u . requestURI = u . updateBytes ( newURI , u . requestURI ) } 
func ( u * URI ) FullURI ( ) [ ] byte { u . fullURI = u . AppendBytes ( u . fullURI [ : 0 ] ) return u . fullURI } 
func ( u * URI ) AppendBytes ( dst [ ] byte ) [ ] byte { dst = u . appendSchemeHost ( dst ) return append ( dst , u . RequestURI ( ) ... ) } 
func ( u * URI ) WriteTo ( w io . Writer ) ( int64 , error ) { n , err := w . Write ( u . FullURI ( ) ) return int64 ( n ) , err } 
func NewWriter ( dstW io . Writer , newWriter NewWriterFunc ) Writer { w := & writer { dstW : dstW , } w . zw = newWriter ( & w . xw ) return w } 
func NewPipeConns ( ) * PipeConns { ch1 := make ( chan * byteBuffer , 4 ) ch2 := make ( chan * byteBuffer , 4 ) pc := & PipeConns { stopCh : make ( chan struct { } ) , } pc . c1 . rCh = ch1 pc . c1 . wCh = ch2 pc . c2 . rCh = ch2 pc . c2 . wCh = ch1 pc . c1 . pc = pc pc . c2 . pc = pc return pc } 
func ( pc * PipeConns ) Close ( ) error { pc . stopChLock . Lock ( ) select { case <- pc . stopCh : default : close ( pc . stopCh ) } pc . stopChLock . Unlock ( ) return nil } 
func Do ( req * Request , resp * Response ) error { return defaultClient . Do ( req , resp ) } 
func DoTimeout ( req * Request , resp * Response , timeout time . Duration ) error { return defaultClient . DoTimeout ( req , resp , timeout ) } 
func DoDeadline ( req * Request , resp * Response , deadline time . Time ) error { return defaultClient . DoDeadline ( req , resp , deadline ) } 
func Get ( dst [ ] byte , url string ) ( statusCode int , body [ ] byte , err error ) { return defaultClient . Get ( dst , url ) } 
func GetTimeout ( dst [ ] byte , url string , timeout time . Duration ) ( statusCode int , body [ ] byte , err error ) { return defaultClient . GetTimeout ( dst , url , timeout ) } 
func GetDeadline ( dst [ ] byte , url string , deadline time . Time ) ( statusCode int , body [ ] byte , err error ) { return defaultClient . GetDeadline ( dst , url , deadline ) } 
func Post ( dst [ ] byte , url string , postArgs * Args ) ( statusCode int , body [ ] byte , err error ) { return defaultClient . Post ( dst , url , postArgs ) } 
func ( c * Client ) GetTimeout ( dst [ ] byte , url string , timeout time . Duration ) ( statusCode int , body [ ] byte , err error ) { return clientGetURLTimeout ( dst , url , timeout , c ) } 
func ( c * Client ) GetDeadline ( dst [ ] byte , url string , deadline time . Time ) ( statusCode int , body [ ] byte , err error ) { return clientGetURLDeadline ( dst , url , deadline , c ) } 
func ( c * Client ) Post ( dst [ ] byte , url string , postArgs * Args ) ( statusCode int , body [ ] byte , err error ) { return clientPostURL ( dst , url , postArgs , c ) } 
func ( c * Client ) DoTimeout ( req * Request , resp * Response , timeout time . Duration ) error { return clientDoTimeout ( req , resp , timeout , c ) } 
func ( c * Client ) DoDeadline ( req * Request , resp * Response , deadline time . Time ) error { return clientDoDeadline ( req , resp , deadline , c ) } 
func ( c * Client ) Do ( req * Request , resp * Response ) error { uri := req . URI ( ) host := uri . Host ( ) isTLS := false scheme := uri . Scheme ( ) if bytes . Equal ( scheme , strHTTPS ) { isTLS = true } else if ! bytes . Equal ( scheme , strHTTP ) { return fmt . Errorf ( " " , scheme ) } startCleaner := false c . mLock . Lock ( ) m := c . m if isTLS { m = c . ms } if m == nil { m = make ( map [ string ] * HostClient ) if isTLS { c . ms = m } else { c . m = m } } hc := m [ string ( host ) ] if hc == nil { hc = & HostClient { Addr : addMissingPort ( string ( host ) , isTLS ) , Name : c . Name , NoDefaultUserAgentHeader : c . NoDefaultUserAgentHeader , Dial : c . Dial , DialDualStack : c . DialDualStack , IsTLS : isTLS , TLSConfig : c . TLSConfig , MaxConns : c . MaxConnsPerHost , MaxIdleConnDuration : c . MaxIdleConnDuration , MaxIdemponentCallAttempts : c . MaxIdemponentCallAttempts , ReadBufferSize : c . ReadBufferSize , WriteBufferSize : c . WriteBufferSize , ReadTimeout : c . ReadTimeout , WriteTimeout : c . WriteTimeout , MaxResponseBodySize : c . MaxResponseBodySize , DisableHeaderNamesNormalizing : c . DisableHeaderNamesNormalizing , } m [ string ( host ) ] = hc if len ( m ) == 1 { startCleaner = true } } c . mLock . Unlock ( ) if startCleaner { go c . mCleaner ( m ) } return hc . Do ( req , resp ) } 
func ( c * HostClient ) LastUseTime ( ) time . Time { n := atomic . LoadUint32 ( & c . lastUseTime ) return time . Unix ( startTimeUnix + int64 ( n ) , 0 ) } 
func ( c * HostClient ) Get ( dst [ ] byte , url string ) ( statusCode int , body [ ] byte , err error ) { return clientGetURL ( dst , url , c ) } 
func AcquireRequest ( ) * Request { v := requestPool . Get ( ) if v == nil { return & Request { } } return v . ( * Request ) } 
func AcquireResponse ( ) * Response { v := responsePool . Get ( ) if v == nil { return & Response { } } return v . ( * Response ) } 
func ( c * HostClient ) Do ( req * Request , resp * Response ) error { var err error var retry bool maxAttempts := c . MaxIdemponentCallAttempts if maxAttempts <= 0 { maxAttempts = DefaultMaxIdemponentCallAttempts } attempts := 0 atomic . AddInt32 ( & c . pendingRequests , 1 ) for { retry , err = c . do ( req , resp ) if err == nil || ! retry { break } if ! isIdempotent ( req ) { } } attempts ++ if attempts >= maxAttempts { break } } atomic . AddInt32 ( & c . pendingRequests , - 1 ) if err == io . EOF { err = ErrConnectionClosed } return err } 
func ( c * PipelineClient ) DoTimeout ( req * Request , resp * Response , timeout time . Duration ) error { return c . DoDeadline ( req , resp , time . Now ( ) . Add ( timeout ) ) } 
func ( c * PipelineClient ) DoDeadline ( req * Request , resp * Response , deadline time . Time ) error { return c . getConnClient ( ) . DoDeadline ( req , resp , deadline ) } 
func ( c * PipelineClient ) Do ( req * Request , resp * Response ) error { return c . getConnClient ( ) . Do ( req , resp ) } 
func ( c * PipelineClient ) PendingRequests ( ) int { c . connClientsLock . Lock ( ) n := 0 for _ , cc := range c . connClients { n += cc . PendingRequests ( ) } c . connClientsLock . Unlock ( ) return n } 
func ( cc * LBClient ) DoDeadline ( req * Request , resp * Response , deadline time . Time ) error { return cc . get ( ) . DoDeadline ( req , resp , deadline ) } 
func ( cc * LBClient ) DoTimeout ( req * Request , resp * Response , timeout time . Duration ) error { deadline := time . Now ( ) . Add ( timeout ) return cc . get ( ) . DoDeadline ( req , resp , deadline ) } 
func ( cc * LBClient ) Do ( req * Request , resp * Response ) error { timeout := cc . Timeout if timeout <= 0 { timeout = DefaultLBClientTimeout } return cc . DoTimeout ( req , resp , timeout ) } 
func ServeConn ( c net . Conn , handler RequestHandler ) error { v := serverPool . Get ( ) if v == nil { v = & Server { } } s := v . ( * Server ) s . Handler = handler err := s . ServeConn ( c ) s . Handler = nil serverPool . Put ( v ) return err } 
func Serve ( ln net . Listener , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . Serve ( ln ) } 
func ServeTLS ( ln net . Listener , certFile , keyFile string , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ServeTLS ( ln , certFile , keyFile ) } 
func ServeTLSEmbed ( ln net . Listener , certData , keyData [ ] byte , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ServeTLSEmbed ( ln , certData , keyData ) } 
func ListenAndServe ( addr string , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ListenAndServe ( addr ) } 
func ListenAndServeUNIX ( addr string , mode os . FileMode , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ListenAndServeUNIX ( addr , mode ) } 
func ListenAndServeTLS ( addr , certFile , keyFile string , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ListenAndServeTLS ( addr , certFile , keyFile ) } 
func ListenAndServeTLSEmbed ( addr string , certData , keyData [ ] byte , handler RequestHandler ) error { s := & Server { Handler : handler , } return s . ListenAndServeTLSEmbed ( addr , certData , keyData ) } 
func TimeoutHandler ( h RequestHandler , timeout time . Duration , msg string ) RequestHandler { if timeout <= 0 { return h } return func ( ctx * RequestCtx ) { concurrencyCh := ctx . s . concurrencyCh select { case concurrencyCh <- struct { } { } : default : ctx . Error ( msg , StatusTooManyRequests ) return } ch := ctx . timeoutCh if ch == nil { ch = make ( chan struct { } , 1 ) ctx . timeoutCh = ch } go func ( ) { h ( ctx ) ch <- struct { } { } <- concurrencyCh } ( ) ctx . timeoutTimer = initTimer ( ctx . timeoutTimer , timeout ) select { case <- ch : case <- ctx . timeoutTimer . C : ctx . TimeoutError ( msg ) } stopTimer ( ctx . timeoutTimer ) } } 
func CompressHandlerLevel ( h RequestHandler , level int ) RequestHandler { return func ( ctx * RequestCtx ) { h ( ctx ) if ctx . Request . Header . HasAcceptEncodingBytes ( strGzip ) { ctx . Response . gzipBody ( level ) } else if ctx . Request . Header . HasAcceptEncodingBytes ( strDeflate ) { ctx . Response . deflateBody ( level ) } } } 
func ( ctx * RequestCtx ) SetUserValue ( key string , value interface { } ) { ctx . userValues . Set ( key , value ) } 
func ( ctx * RequestCtx ) SetUserValueBytes ( key [ ] byte , value interface { } ) { ctx . userValues . SetBytes ( key , value ) } 
func ( ctx * RequestCtx ) VisitUserValues ( visitor func ( [ ] byte , interface { } ) ) { for i , n := 0 , len ( ctx . userValues ) ; i < n ; i ++ { kv := & ctx . userValues [ i ] visitor ( kv . key , kv . value ) } } 
func ( ctx * RequestCtx ) IsTLS ( ) bool { return ok } 
func ( ctx * RequestCtx ) TLSConnectionState ( ) * tls . ConnectionState { tlsConn , ok := ctx . c . ( connTLSer ) if ! ok { return nil } state := tlsConn . ConnectionState ( ) return & state } 
func ( ctx * RequestCtx ) String ( ) string { return fmt . Sprintf ( " " , ctx . ID ( ) , ctx . LocalAddr ( ) , ctx . RemoteAddr ( ) , ctx . Request . Header . Method ( ) , ctx . URI ( ) . FullURI ( ) ) } 
func ( ctx * RequestCtx ) SetContentType ( contentType string ) { ctx . Response . Header . SetContentType ( contentType ) } 
func ( ctx * RequestCtx ) SetContentTypeBytes ( contentType [ ] byte ) { ctx . Response . Header . SetContentTypeBytes ( contentType ) } 
func ( ctx * RequestCtx ) FormFile ( key string ) ( * multipart . FileHeader , error ) { mf , err := ctx . MultipartForm ( ) if err != nil { return nil , err } if mf . File == nil { return nil , err } fhh := mf . File [ key ] if fhh == nil { return nil , ErrMissingFile } return fhh [ 0 ] , nil } 
func SaveMultipartFile ( fh * multipart . FileHeader , path string ) error { f , err := fh . Open ( ) if err != nil { return err } if ff , ok := f . ( * os . File ) ; ok { } } if err != nil { return err } } defer f . Close ( ) ff , err := os . Create ( path ) if err != nil { return err } defer ff . Close ( ) _ , err = copyZeroAlloc ( ff , f ) return err } 
func ( ctx * RequestCtx ) FormValue ( key string ) [ ] byte { v := ctx . QueryArgs ( ) . Peek ( key ) if len ( v ) > 0 { return v } v = ctx . PostArgs ( ) . Peek ( key ) if len ( v ) > 0 { return v } mf , err := ctx . MultipartForm ( ) if err == nil && mf . Value != nil { vv := mf . Value [ key ] if len ( vv ) > 0 { return [ ] byte ( vv [ 0 ] ) } } return nil } 
func ( ctx * RequestCtx ) RemoteAddr ( ) net . Addr { if ctx . c == nil { return zeroTCPAddr } addr := ctx . c . RemoteAddr ( ) if addr == nil { return zeroTCPAddr } return addr } 
func ( ctx * RequestCtx ) Error ( msg string , statusCode int ) { ctx . Response . Reset ( ) ctx . SetStatusCode ( statusCode ) ctx . SetContentTypeBytes ( defaultContentType ) ctx . SetBodyString ( msg ) } 
func ( ctx * RequestCtx ) Success ( contentType string , body [ ] byte ) { ctx . SetContentType ( contentType ) ctx . SetBody ( body ) } 
func ( ctx * RequestCtx ) SuccessString ( contentType , body string ) { ctx . SetContentType ( contentType ) ctx . SetBodyString ( body ) } 
func ( ctx * RequestCtx ) Redirect ( uri string , statusCode int ) { u := AcquireURI ( ) ctx . URI ( ) . CopyTo ( u ) u . Update ( uri ) ctx . redirect ( u . FullURI ( ) , statusCode ) ReleaseURI ( u ) } 
func ( ctx * RequestCtx ) RedirectBytes ( uri [ ] byte , statusCode int ) { s := b2s ( uri ) ctx . Redirect ( s , statusCode ) } 
func ( ctx * RequestCtx ) IfModifiedSince ( lastModified time . Time ) bool { ifModStr := ctx . Request . Header . peek ( strIfModifiedSince ) if len ( ifModStr ) == 0 { return true } ifMod , err := ParseHTTPDate ( ifModStr ) if err != nil { return true } lastModified = lastModified . Truncate ( time . Second ) return ifMod . Before ( lastModified ) } 
func ( ctx * RequestCtx ) NotFound ( ) { ctx . Response . Reset ( ) ctx . SetStatusCode ( StatusNotFound ) ctx . SetBodyString ( " " ) } 
func ( ctx * RequestCtx ) Write ( p [ ] byte ) ( int , error ) { ctx . Response . AppendBody ( p ) return len ( p ) , nil } 
func ( ctx * RequestCtx ) WriteString ( s string ) ( int , error ) { ctx . Response . AppendBodyString ( s ) return len ( s ) , nil } 
func ( ctx * RequestCtx ) SetBodyStream ( bodyStream io . Reader , bodySize int ) { ctx . Response . SetBodyStream ( bodyStream , bodySize ) } 
func ( ctx * RequestCtx ) Logger ( ) Logger { if ctx . logger . ctx == nil { ctx . logger . ctx = ctx } if ctx . logger . logger == nil { ctx . logger . logger = ctx . s . logger ( ) } return & ctx . logger } 
func ( ctx * RequestCtx ) TimeoutErrorWithCode ( msg string , statusCode int ) { var resp Response resp . SetStatusCode ( statusCode ) resp . SetBodyString ( msg ) ctx . TimeoutErrorWithResponse ( & resp ) } 
func ( ctx * RequestCtx ) TimeoutErrorWithResponse ( resp * Response ) { respCopy := & Response { } resp . CopyTo ( respCopy ) ctx . timeoutResponse = respCopy } 
func ( s * Server ) NextProto ( key string , nph ServeHandler ) { if s . nextProtos == nil { s . nextProtos = make ( map [ string ] ServeHandler ) } s . configTLS ( ) s . tlsConfig . NextProtos = append ( s . tlsConfig . NextProtos , key ) s . nextProtos [ key ] = nph } 
func ( s * Server ) ListenAndServe ( addr string ) error { ln , err := net . Listen ( " " , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . Serve ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } ) } } return s . Serve ( ln ) } 
func ( s * Server ) ListenAndServeUNIX ( addr string , mode os . FileMode ) error { if err := os . Remove ( addr ) ; err != nil && ! os . IsNotExist ( err ) { return fmt . Errorf ( " " , addr , err ) } ln , err := net . Listen ( " " , addr ) if err != nil { return err } if err = os . Chmod ( addr , mode ) ; err != nil { return fmt . Errorf ( " " , mode , addr , err ) } return s . Serve ( ln ) } 
func ( s * Server ) ListenAndServeTLS ( addr , certFile , keyFile string ) error { ln , err := net . Listen ( " " , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . ServeTLS ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } , certFile , keyFile ) } } return s . ServeTLS ( ln , certFile , keyFile ) } 
func ( s * Server ) ListenAndServeTLSEmbed ( addr string , certData , keyData [ ] byte ) error { ln , err := net . Listen ( " " , addr ) if err != nil { return err } if s . TCPKeepalive { if tcpln , ok := ln . ( * net . TCPListener ) ; ok { return s . ServeTLSEmbed ( tcpKeepaliveListener { TCPListener : tcpln , keepalivePeriod : s . TCPKeepalivePeriod , } , certData , keyData ) } } return s . ServeTLSEmbed ( ln , certData , keyData ) } 
func ( s * Server ) ServeTLS ( ln net . Listener , certFile , keyFile string ) error { err := s . AppendCert ( certFile , keyFile ) if err != nil && err != errNoCertOrKeyProvided { return err } if s . tlsConfig == nil { return errNoCertOrKeyProvided } s . tlsConfig . BuildNameToCertificate ( ) return s . Serve ( tls . NewListener ( ln , s . tlsConfig ) , ) } 
func ( s * Server ) ServeTLSEmbed ( ln net . Listener , certData , keyData [ ] byte ) error { err := s . AppendCertEmbed ( certData , keyData ) if err != nil && err != errNoCertOrKeyProvided { return err } if s . tlsConfig == nil { return errNoCertOrKeyProvided } s . tlsConfig . BuildNameToCertificate ( ) return s . Serve ( tls . NewListener ( ln , s . tlsConfig ) , ) } 
func ( s * Server ) AppendCert ( certFile , keyFile string ) error { if len ( certFile ) == 0 && len ( keyFile ) == 0 { return errNoCertOrKeyProvided } cert , err := tls . LoadX509KeyPair ( certFile , keyFile ) if err != nil { return fmt . Errorf ( " " , certFile , keyFile , err ) } s . configTLS ( ) s . tlsConfig . Certificates = append ( s . tlsConfig . Certificates , cert ) return nil } 
func ( s * Server ) AppendCertEmbed ( certData , keyData [ ] byte ) error { if len ( certData ) == 0 && len ( keyData ) == 0 { return errNoCertOrKeyProvided } cert , err := tls . X509KeyPair ( certData , keyData ) if err != nil { return fmt . Errorf ( " " , len ( certData ) , len ( keyData ) , err ) } s . configTLS ( ) s . tlsConfig . Certificates = append ( s . tlsConfig . Certificates , cert ) return nil } 
func ( s * Server ) Serve ( ln net . Listener ) error { var lastOverflowErrorTime time . Time var lastPerIPErrorTime time . Time var c net . Conn var err error s . mu . Lock ( ) { if s . ln != nil { s . mu . Unlock ( ) return ErrAlreadyServing } s . ln = ln s . done = make ( chan struct { } ) } s . mu . Unlock ( ) maxWorkersCount := s . getConcurrency ( ) s . concurrencyCh = make ( chan struct { } , maxWorkersCount ) wp := & workerPool { WorkerFunc : s . serveConn , MaxWorkersCount : maxWorkersCount , LogAllErrors : s . LogAllErrors , Logger : s . logger ( ) , connState : s . setState , } wp . Start ( ) defer atomic . AddInt32 ( & s . open , - 1 ) for { if c , err = acceptConn ( s , ln , & lastPerIPErrorTime ) ; err != nil { wp . Stop ( ) if err == io . EOF { return nil } return err } s . setState ( c , StateNew ) atomic . AddInt32 ( & s . open , 1 ) if ! wp . Serve ( c ) { atomic . AddInt32 ( & s . open , - 1 ) s . writeFastError ( c , StatusServiceUnavailable , " " ) c . Close ( ) s . setState ( c , StateClosed ) if time . Since ( lastOverflowErrorTime ) > time . Minute { s . logger ( ) . Printf ( " " + " " , maxWorkersCount ) lastOverflowErrorTime = time . Now ( ) } } } c = nil } } 
func ( s * Server ) Shutdown ( ) error { s . mu . Lock ( ) defer s . mu . Unlock ( ) atomic . StoreInt32 ( & s . stop , 1 ) defer atomic . StoreInt32 ( & s . stop , 0 ) if s . ln == nil { return nil } if err := s . ln . Close ( ) ; err != nil { return err } if s . done != nil { close ( s . done ) } } } s . ln = nil return nil } 
func ( s * Server ) ServeConn ( c net . Conn ) error { if s . MaxConnsPerIP > 0 { pic := wrapPerIPConn ( s , c ) if pic == nil { return ErrPerIPConnLimit } c = pic } n := atomic . AddUint32 ( & s . concurrency , 1 ) if n > uint32 ( s . getConcurrency ( ) ) { atomic . AddUint32 ( & s . concurrency , ^ uint32 ( 0 ) ) s . writeFastError ( c , StatusServiceUnavailable , " " ) c . Close ( ) return ErrConcurrencyLimit } atomic . AddInt32 ( & s . open , 1 ) err := s . serveConn ( c ) atomic . AddUint32 ( & s . concurrency , ^ uint32 ( 0 ) ) if err != errHijacked { err1 := c . Close ( ) s . setState ( c , StateClosed ) if err == nil { err = err1 } } else { err = nil s . setState ( c , StateHijacked ) } return err } 
func ( ctx * RequestCtx ) Init2 ( conn net . Conn , logger Logger , reduceMemoryUsage bool ) { ctx . c = conn ctx . logger . logger = logger ctx . connID = nextConnID ( ) ctx . s = fakeServer ctx . connRequestNum = 0 ctx . connTime = time . Now ( ) keepBodyBuffer := ! reduceMemoryUsage ctx . Request . keepBodyBuffer = keepBodyBuffer ctx . Response . keepBodyBuffer = keepBodyBuffer } 
func ( ctx * RequestCtx ) Init ( req * Request , remoteAddr net . Addr , logger Logger ) { if remoteAddr == nil { remoteAddr = zeroTCPAddr } c := & fakeAddrer { laddr : zeroTCPAddr , raddr : remoteAddr , } if logger == nil { logger = defaultLogger } ctx . Init2 ( c , logger , true ) req . CopyTo ( & ctx . Request ) } 
func ( ctx * RequestCtx ) Err ( ) error { select { case <- ctx . s . done : return context . Canceled default : return nil } } 
func ( ctx * RequestCtx ) Value ( key interface { } ) interface { } { if keyString , ok := key . ( string ) ; ok { return ctx . UserValue ( keyString ) } return nil } 
func AppendGzipBytesLevel ( dst , src [ ] byte , level int ) [ ] byte { w := & byteSliceWriter { dst } WriteGzipLevel ( w , src , level ) return w . b } 
func WriteGzipLevel ( w io . Writer , p [ ] byte , level int ) ( int , error ) { switch w . ( type ) { case * byteSliceWriter , * bytes . Buffer , * bytebufferpool . ByteBuffer : stacklessWriteGzip ( ctx ) return len ( p ) , nil default : zw := acquireStacklessGzipWriter ( w , level ) n , err := zw . Write ( p ) releaseStacklessGzipWriter ( zw , level ) return n , err } } 
func WriteGzip ( w io . Writer , p [ ] byte ) ( int , error ) { return WriteGzipLevel ( w , p , CompressDefaultCompression ) } 
func WriteGunzip ( w io . Writer , p [ ] byte ) ( int , error ) { r := & byteSliceReader { p } zr , err := acquireGzipReader ( r ) if err != nil { return 0 , err } n , err := copyZeroAlloc ( w , zr ) releaseGzipReader ( zr ) nn := int ( n ) if int64 ( nn ) != n { return 0 , fmt . Errorf ( " " , n ) } return nn , err } 
func AppendGunzipBytes ( dst , src [ ] byte ) ( [ ] byte , error ) { w := & byteSliceWriter { dst } _ , err := WriteGunzip ( w , src ) return w . b , err } 
func AppendDeflateBytesLevel ( dst , src [ ] byte , level int ) [ ] byte { w := & byteSliceWriter { dst } WriteDeflateLevel ( w , src , level ) return w . b } 
func WriteDeflateLevel ( w io . Writer , p [ ] byte , level int ) ( int , error ) { switch w . ( type ) { case * byteSliceWriter , * bytes . Buffer , * bytebufferpool . ByteBuffer : stacklessWriteDeflate ( ctx ) return len ( p ) , nil default : zw := acquireStacklessDeflateWriter ( w , level ) n , err := zw . Write ( p ) releaseStacklessDeflateWriter ( zw , level ) return n , err } } 
func WriteDeflate ( w io . Writer , p [ ] byte ) ( int , error ) { return WriteDeflateLevel ( w , p , CompressDefaultCompression ) } 
func WriteInflate ( w io . Writer , p [ ] byte ) ( int , error ) { r := & byteSliceReader { p } zr , err := acquireFlateReader ( r ) if err != nil { return 0 , err } n , err := copyZeroAlloc ( w , zr ) releaseFlateReader ( zr ) nn := int ( n ) if int64 ( nn ) != n { return 0 , fmt . Errorf ( " " , n ) } return nn , err } 
func AppendInflateBytes ( dst , src [ ] byte ) ( [ ] byte , error ) { w := & byteSliceWriter { dst } _ , err := WriteInflate ( w , src ) return w . b , err } 
func NewFunc ( f func ( ctx interface { } ) ) func ( ctx interface { } ) bool { if f == nil { panic ( " " ) } funcWorkCh := make ( chan * funcWork , runtime . GOMAXPROCS ( - 1 ) * 2048 ) onceInit := func ( ) { n := runtime . GOMAXPROCS ( - 1 ) for i := 0 ; i < n ; i ++ { go funcWorker ( funcWorkCh , f ) } } var once sync . Once return func ( ctx interface { } ) bool { once . Do ( onceInit ) fw := getFuncWork ( ) fw . ctx = ctx select { case funcWorkCh <- fw : default : putFuncWork ( fw ) return false } <- fw . done putFuncWork ( fw ) return true } } 
func ( req * Request ) SetRequestURI ( requestURI string ) { req . Header . SetRequestURI ( requestURI ) req . parsedURI = false } 
func ( req * Request ) SetRequestURIBytes ( requestURI [ ] byte ) { req . Header . SetRequestURIBytes ( requestURI ) req . parsedURI = false } 
func ( req * Request ) RequestURI ( ) [ ] byte { if req . parsedURI { requestURI := req . uri . RequestURI ( ) req . SetRequestURIBytes ( requestURI ) } return req . Header . RequestURI ( ) } 
func ( resp * Response ) SendFile ( path string ) error { f , err := os . Open ( path ) if err != nil { return err } fileInfo , err := f . Stat ( ) if err != nil { f . Close ( ) return err } size64 := fileInfo . Size ( ) size := int ( size64 ) if int64 ( size ) != size64 { size = - 1 } resp . Header . SetLastModified ( fileInfo . ModTime ( ) ) resp . SetBodyStream ( f , size ) return nil } 
func ( req * Request ) SetBodyStream ( bodyStream io . Reader , bodySize int ) { req . ResetBody ( ) req . bodyStream = bodyStream req . Header . SetContentLength ( bodySize ) } 
func ( resp * Response ) SetBodyStream ( bodyStream io . Reader , bodySize int ) { resp . ResetBody ( ) resp . bodyStream = bodyStream resp . Header . SetContentLength ( bodySize ) } 
func ( req * Request ) SetBodyStreamWriter ( sw StreamWriter ) { sr := NewStreamReader ( sw ) req . SetBodyStream ( sr , - 1 ) } 
func ( resp * Response ) SetBodyStreamWriter ( sw StreamWriter ) { sr := NewStreamReader ( sw ) resp . SetBodyStream ( sr , - 1 ) } 
func ( resp * Response ) BodyWriter ( ) io . Writer { resp . w . r = resp return & resp . w } 
func ( req * Request ) BodyWriter ( ) io . Writer { req . w . r = req return & req . w } 
func ( resp * Response ) Body ( ) [ ] byte { if resp . bodyStream != nil { bodyBuf := resp . bodyBuffer ( ) bodyBuf . Reset ( ) _ , err := copyZeroAlloc ( bodyBuf , resp . bodyStream ) resp . closeBodyStream ( ) if err != nil { bodyBuf . SetString ( err . Error ( ) ) } } return resp . bodyBytes ( ) } 
func ( req * Request ) BodyWriteTo ( w io . Writer ) error { if req . bodyStream != nil { _ , err := copyZeroAlloc ( w , req . bodyStream ) req . closeBodyStream ( ) return err } if req . onlyMultipartForm ( ) { return WriteMultipartForm ( w , req . multipartForm , req . multipartFormBoundary ) } _ , err := w . Write ( req . bodyBytes ( ) ) return err } 
func ( resp * Response ) BodyWriteTo ( w io . Writer ) error { if resp . bodyStream != nil { _ , err := copyZeroAlloc ( w , resp . bodyStream ) resp . closeBodyStream ( ) return err } _ , err := w . Write ( resp . bodyBytes ( ) ) return err } 
func ( resp * Response ) AppendBodyString ( s string ) { resp . closeBodyStream ( ) resp . bodyBuffer ( ) . WriteString ( s ) } 
func ( resp * Response ) SetBodyString ( body string ) { resp . closeBodyStream ( ) bodyBuf := resp . bodyBuffer ( ) bodyBuf . Reset ( ) bodyBuf . WriteString ( body ) } 
func ( resp * Response ) ResetBody ( ) { resp . bodyRaw = nil resp . closeBodyStream ( ) if resp . body != nil { if resp . keepBodyBuffer { resp . body . Reset ( ) } else { responseBodyPool . Put ( resp . body ) resp . body = nil } } } 
func ( resp * Response ) SetBodyRaw ( body [ ] byte ) { resp . ResetBody ( ) resp . bodyRaw = body } 
func ( resp * Response ) ReleaseBody ( size int ) { resp . bodyRaw = nil if cap ( resp . body . B ) > size { resp . closeBodyStream ( ) resp . body = nil } } 
func ( req * Request ) ReleaseBody ( size int ) { if cap ( req . body . B ) > size { req . closeBodyStream ( ) req . body = nil } } 
func ( resp * Response ) SwapBody ( body [ ] byte ) [ ] byte { bb := resp . bodyBuffer ( ) if resp . bodyStream != nil { bb . Reset ( ) _ , err := copyZeroAlloc ( bb , resp . bodyStream ) resp . closeBodyStream ( ) if err != nil { bb . Reset ( ) bb . SetString ( err . Error ( ) ) } } resp . bodyRaw = nil oldBody := bb . B bb . B = body return oldBody } 
func ( req * Request ) SwapBody ( body [ ] byte ) [ ] byte { bb := req . bodyBuffer ( ) if req . bodyStream != nil { bb . Reset ( ) _ , err := copyZeroAlloc ( bb , req . bodyStream ) req . closeBodyStream ( ) if err != nil { bb . Reset ( ) bb . SetString ( err . Error ( ) ) } } oldBody := bb . B bb . B = body return oldBody } 
func ( req * Request ) Body ( ) [ ] byte { if req . bodyStream != nil { bodyBuf := req . bodyBuffer ( ) bodyBuf . Reset ( ) _ , err := copyZeroAlloc ( bodyBuf , req . bodyStream ) req . closeBodyStream ( ) if err != nil { bodyBuf . SetString ( err . Error ( ) ) } } else if req . onlyMultipartForm ( ) { body , err := marshalMultipartForm ( req . multipartForm , req . multipartFormBoundary ) if err != nil { return [ ] byte ( err . Error ( ) ) } return body } return req . bodyBytes ( ) } 
func ( req * Request ) AppendBodyString ( s string ) { req . RemoveMultipartFormFiles ( ) req . closeBodyStream ( ) req . bodyBuffer ( ) . WriteString ( s ) } 
func ( req * Request ) SetBodyString ( body string ) { req . RemoveMultipartFormFiles ( ) req . closeBodyStream ( ) req . bodyBuffer ( ) . SetString ( body ) } 
func ( req * Request ) ResetBody ( ) { req . RemoveMultipartFormFiles ( ) req . closeBodyStream ( ) if req . body != nil { if req . keepBodyBuffer { req . body . Reset ( ) } else { requestBodyPool . Put ( req . body ) req . body = nil } } } 
func ( req * Request ) CopyTo ( dst * Request ) { req . copyToSkipBody ( dst ) if req . body != nil { dst . bodyBuffer ( ) . Set ( req . body . B ) } else if dst . body != nil { dst . body . Reset ( ) } } 
func ( resp * Response ) CopyTo ( dst * Response ) { resp . copyToSkipBody ( dst ) if resp . bodyRaw != nil { dst . bodyRaw = resp . bodyRaw if dst . body != nil { dst . body . Reset ( ) } } else if resp . body != nil { dst . bodyBuffer ( ) . Set ( resp . body . B ) } else if dst . body != nil { dst . body . Reset ( ) } } 
func ( req * Request ) MultipartForm ( ) ( * multipart . Form , error ) { if req . multipartForm != nil { return req . multipartForm , nil } req . multipartFormBoundary = string ( req . Header . MultipartFormBoundary ( ) ) if len ( req . multipartFormBoundary ) == 0 { return nil , ErrNoMultipartForm } ce := req . Header . peek ( strContentEncoding ) body := req . bodyBytes ( ) if bytes . Equal ( ce , strGzip ) { if body , err = AppendGunzipBytes ( nil , body ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } } else if len ( ce ) > 0 { return nil , fmt . Errorf ( " " , ce ) } f , err := readMultipartForm ( bytes . NewReader ( body ) , req . multipartFormBoundary , len ( body ) , len ( body ) ) if err != nil { return nil , err } req . multipartForm = f return f , nil } 
func WriteMultipartForm ( w io . Writer , f * multipart . Form , boundary string ) error { } mw := multipart . NewWriter ( w ) if err := mw . SetBoundary ( boundary ) ; err != nil { return fmt . Errorf ( " " , boundary , err ) } } } } if err != nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } fh , err := fv . Open ( ) if err != nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } if _ , err = copyZeroAlloc ( vw , fh ) ; err != nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } if err = fh . Close ( ) ; err != nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } } } if err := mw . Close ( ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( req * Request ) RemoveMultipartFormFiles ( ) { if req . multipartForm != nil { req . multipartForm = nil } req . multipartFormBoundary = " " } 
func ( resp * Response ) Reset ( ) { resp . Header . Reset ( ) resp . resetSkipHeader ( ) resp . SkipBody = false resp . raddr = nil resp . laddr = nil } 
func ( req * Request ) Read ( r * bufio . Reader ) error { return req . ReadLimitBody ( r , 0 ) } 
func ( req * Request ) ReadLimitBody ( r * bufio . Reader , maxBodySize int ) error { req . resetSkipHeader ( ) return req . readLimitBody ( r , maxBodySize , false ) } 
func ( req * Request ) MayContinue ( ) bool { return bytes . Equal ( req . Header . peek ( strExpect ) , str100Continue ) } 
func ( req * Request ) ContinueReadBody ( r * bufio . Reader , maxBodySize int ) error { var err error contentLength := req . Header . realContentLength ( ) if contentLength > 0 { if maxBodySize > 0 && contentLength > maxBodySize { return ErrBodyTooLarge } if len ( req . multipartFormBoundary ) > 0 && len ( req . Header . peek ( strContentEncoding ) ) == 0 { req . multipartForm , err = readMultipartForm ( r , req . multipartFormBoundary , contentLength , defaultMaxInMemoryFileSize ) if err != nil { req . Reset ( ) } return err } } if contentLength == - 2 { return nil } bodyBuf := req . bodyBuffer ( ) bodyBuf . Reset ( ) bodyBuf . B , err = readBody ( r , contentLength , maxBodySize , bodyBuf . B ) if err != nil { req . Reset ( ) return err } req . Header . SetContentLength ( len ( bodyBuf . B ) ) return nil } 
func ( resp * Response ) Read ( r * bufio . Reader ) error { return resp . ReadLimitBody ( r , 0 ) } 
func ( resp * Response ) ReadLimitBody ( r * bufio . Reader , maxBodySize int ) error { resp . resetSkipHeader ( ) err := resp . Header . Read ( r ) if err != nil { return err } if resp . Header . StatusCode ( ) == StatusContinue { } } if ! resp . mustSkipBody ( ) { bodyBuf := resp . bodyBuffer ( ) bodyBuf . Reset ( ) bodyBuf . B , err = readBody ( r , resp . Header . ContentLength ( ) , maxBodySize , bodyBuf . B ) if err != nil { return err } resp . Header . SetContentLength ( len ( bodyBuf . B ) ) } return nil } 
func ( req * Request ) WriteTo ( w io . Writer ) ( int64 , error ) { return writeBufio ( req , w ) } 
func ( resp * Response ) WriteTo ( w io . Writer ) ( int64 , error ) { return writeBufio ( resp , w ) } 
func ( req * Request ) Write ( w * bufio . Writer ) error { if len ( req . Header . Host ( ) ) == 0 || req . parsedURI { uri := req . URI ( ) host := uri . Host ( ) if len ( host ) == 0 { return errRequestHostRequired } req . Header . SetHostBytes ( host ) req . Header . SetRequestURIBytes ( uri . RequestURI ( ) ) } if req . bodyStream != nil { return req . writeBodyStream ( w ) } body := req . bodyBytes ( ) var err error if req . onlyMultipartForm ( ) { body , err = marshalMultipartForm ( req . multipartForm , req . multipartFormBoundary ) if err != nil { return fmt . Errorf ( " " , err ) } req . Header . SetMultipartFormBoundary ( req . multipartFormBoundary ) } hasBody := ! req . Header . ignoreBody ( ) if hasBody { if len ( body ) == 0 { body = req . postArgs . QueryString ( ) } req . Header . SetContentLength ( len ( body ) ) } if err = req . Header . Write ( w ) ; err != nil { return err } if hasBody { _ , err = w . Write ( body ) } else if len ( body ) > 0 { return fmt . Errorf ( " " , body ) } return err } 
func ( resp * Response ) WriteGzip ( w * bufio . Writer ) error { return resp . WriteGzipLevel ( w , CompressDefaultCompression ) } 
func ( resp * Response ) WriteGzipLevel ( w * bufio . Writer , level int ) error { if err := resp . gzipBody ( level ) ; err != nil { return err } return resp . Write ( w ) } 
func ( resp * Response ) WriteDeflate ( w * bufio . Writer ) error { return resp . WriteDeflateLevel ( w , CompressDefaultCompression ) } 
func ( resp * Response ) WriteDeflateLevel ( w * bufio . Writer , level int ) error { if err := resp . deflateBody ( level ) ; err != nil { return err } return resp . Write ( w ) } 
func ( resp * Response ) Write ( w * bufio . Writer ) error { sendBody := ! resp . mustSkipBody ( ) if resp . bodyStream != nil { return resp . writeBodyStream ( w , sendBody ) } body := resp . bodyBytes ( ) bodyLen := len ( body ) if sendBody || bodyLen > 0 { resp . Header . SetContentLength ( bodyLen ) } if err := resp . Header . Write ( w ) ; err != nil { return err } if sendBody { if _ , err := w . Write ( body ) ; err != nil { return err } } return nil } 
func ( h * ResponseHeader ) SetContentRange ( startPos , endPos , contentLength int ) { b := h . bufKV . value [ : 0 ] b = append ( b , strBytes ... ) b = append ( b , ' ' ) b = AppendUint ( b , startPos ) b = append ( b , '-' ) b = AppendUint ( b , endPos ) b = append ( b , '/' ) b = AppendUint ( b , contentLength ) h . bufKV . value = b h . SetCanonical ( strContentRange , h . bufKV . value ) } 
func ( h * RequestHeader ) SetByteRange ( startPos , endPos int ) { h . parseRawHeaders ( ) b := h . bufKV . value [ : 0 ] b = append ( b , strBytes ... ) b = append ( b , '=' ) if startPos >= 0 { b = AppendUint ( b , startPos ) } else { endPos = - startPos } b = append ( b , '-' ) if endPos >= 0 { b = AppendUint ( b , endPos ) } h . bufKV . value = b h . SetCanonical ( strRange , h . bufKV . value ) } 
func ( h * ResponseHeader ) SetLastModified ( t time . Time ) { h . bufKV . value = AppendHTTPDate ( h . bufKV . value [ : 0 ] , t ) h . SetCanonical ( strLastModified , h . bufKV . value ) } 
func ( h * ResponseHeader ) ResetConnectionClose ( ) { if h . connectionClose { h . connectionClose = false h . h = delAllArgsBytes ( h . h , strConnection ) } } 
func ( h * RequestHeader ) ResetConnectionClose ( ) { h . parseRawHeaders ( ) if h . connectionClose { h . connectionClose = false h . h = delAllArgsBytes ( h . h , strConnection ) } } 
func ( h * RequestHeader ) ConnectionUpgrade ( ) bool { h . parseRawHeaders ( ) return hasHeaderValue ( h . Peek ( " " ) , strUpgrade ) } 
func ( h * ResponseHeader ) PeekCookie ( key string ) [ ] byte { return peekArgStr ( h . cookies , key ) } 
func ( h * ResponseHeader ) SetContentLength ( contentLength int ) { if h . mustSkipContentLength ( ) { return } h . contentLength = contentLength if contentLength >= 0 { h . contentLengthBytes = AppendUint ( h . contentLengthBytes [ : 0 ] , contentLength ) h . h = delAllArgsBytes ( h . h , strTransferEncoding ) } else { h . contentLengthBytes = h . contentLengthBytes [ : 0 ] value := strChunked if contentLength == - 2 { h . SetConnectionClose ( ) value = strIdentity } h . h = setArgBytes ( h . h , strTransferEncoding , value , argsHasValue ) } } 
func ( h * RequestHeader ) SetContentLength ( contentLength int ) { h . parseRawHeaders ( ) h . contentLength = contentLength if contentLength >= 0 { h . contentLengthBytes = AppendUint ( h . contentLengthBytes [ : 0 ] , contentLength ) h . h = delAllArgsBytes ( h . h , strTransferEncoding ) } else { h . contentLengthBytes = h . contentLengthBytes [ : 0 ] h . h = setArgBytes ( h . h , strTransferEncoding , strChunked , argsHasValue ) } } 
func ( h * ResponseHeader ) ContentType ( ) [ ] byte { contentType := h . contentType if ! h . noDefaultContentType && len ( h . contentType ) == 0 { contentType = defaultContentType } return contentType } 
func ( h * ResponseHeader ) SetContentType ( contentType string ) { h . contentType = append ( h . contentType [ : 0 ] , contentType ... ) } 
func ( h * ResponseHeader ) SetContentTypeBytes ( contentType [ ] byte ) { h . contentType = append ( h . contentType [ : 0 ] , contentType ... ) } 
func ( h * ResponseHeader ) SetServer ( server string ) { h . server = append ( h . server [ : 0 ] , server ... ) } 
func ( h * ResponseHeader ) SetServerBytes ( server [ ] byte ) { h . server = append ( h . server [ : 0 ] , server ... ) } 
func ( h * RequestHeader ) SetContentType ( contentType string ) { h . parseRawHeaders ( ) h . contentType = append ( h . contentType [ : 0 ] , contentType ... ) } 
func ( h * RequestHeader ) SetContentTypeBytes ( contentType [ ] byte ) { h . parseRawHeaders ( ) h . contentType = append ( h . contentType [ : 0 ] , contentType ... ) } 
func ( h * RequestHeader ) SetMultipartFormBoundary ( boundary string ) { h . parseRawHeaders ( ) b := h . bufKV . value [ : 0 ] b = append ( b , strMultipartFormData ... ) b = append ( b , ';' , ' ' ) b = append ( b , strBoundary ... ) b = append ( b , '=' ) b = append ( b , boundary ... ) h . bufKV . value = b h . SetContentTypeBytes ( h . bufKV . value ) } 
func ( h * RequestHeader ) SetMultipartFormBoundaryBytes ( boundary [ ] byte ) { h . parseRawHeaders ( ) b := h . bufKV . value [ : 0 ] b = append ( b , strMultipartFormData ... ) b = append ( b , ';' , ' ' ) b = append ( b , strBoundary ... ) b = append ( b , '=' ) b = append ( b , boundary ... ) h . bufKV . value = b h . SetContentTypeBytes ( h . bufKV . value ) } 
func ( h * RequestHeader ) MultipartFormBoundary ( ) [ ] byte { b := h . ContentType ( ) if ! bytes . HasPrefix ( b , strMultipartFormData ) { return nil } b = b [ len ( strMultipartFormData ) : ] if len ( b ) == 0 || b [ 0 ] != ';' { return nil } var n int for len ( b ) > 0 { n ++ for len ( b ) > n && b [ n ] == ' ' { n ++ } b = b [ n : ] if ! bytes . HasPrefix ( b , strBoundary ) { if n = bytes . IndexByte ( b , ';' ) ; n < 0 { return nil } continue } b = b [ len ( strBoundary ) : ] if len ( b ) == 0 || b [ 0 ] != '=' { return nil } b = b [ 1 : ] if n = bytes . IndexByte ( b , ';' ) ; n >= 0 { b = b [ : n ] } if len ( b ) > 1 && b [ 0 ] == '"' && b [ len ( b ) - 1 ] == '"' { b = b [ 1 : len ( b ) - 1 ] } return b } return nil } 
func ( h * RequestHeader ) Host ( ) [ ] byte { if len ( h . host ) > 0 { return h . host } if ! h . rawHeadersParsed { if len ( host ) > 0 { h . host = append ( h . host [ : 0 ] , host ... ) return h . host } } return h . host } 
func ( h * RequestHeader ) SetHost ( host string ) { h . parseRawHeaders ( ) h . host = append ( h . host [ : 0 ] , host ... ) } 
func ( h * RequestHeader ) SetHostBytes ( host [ ] byte ) { h . parseRawHeaders ( ) h . host = append ( h . host [ : 0 ] , host ... ) } 
func ( h * RequestHeader ) SetUserAgent ( userAgent string ) { h . parseRawHeaders ( ) h . userAgent = append ( h . userAgent [ : 0 ] , userAgent ... ) } 
func ( h * RequestHeader ) SetUserAgentBytes ( userAgent [ ] byte ) { h . parseRawHeaders ( ) h . userAgent = append ( h . userAgent [ : 0 ] , userAgent ... ) } 
func ( h * RequestHeader ) Method ( ) [ ] byte { if len ( h . method ) == 0 { return strGet } return h . method } 
func ( h * RequestHeader ) SetMethod ( method string ) { h . method = append ( h . method [ : 0 ] , method ... ) } 
func ( h * RequestHeader ) SetMethodBytes ( method [ ] byte ) { h . method = append ( h . method [ : 0 ] , method ... ) } 
func ( h * RequestHeader ) RequestURI ( ) [ ] byte { requestURI := h . requestURI if len ( requestURI ) == 0 { requestURI = strSlash } return requestURI } 
func ( h * RequestHeader ) SetRequestURI ( requestURI string ) { h . requestURI = append ( h . requestURI [ : 0 ] , requestURI ... ) } 
func ( h * RequestHeader ) SetRequestURIBytes ( requestURI [ ] byte ) { h . requestURI = append ( h . requestURI [ : 0 ] , requestURI ... ) } 
func ( h * RequestHeader ) HasAcceptEncoding ( acceptEncoding string ) bool { h . bufKV . value = append ( h . bufKV . value [ : 0 ] , acceptEncoding ... ) return h . HasAcceptEncodingBytes ( h . bufKV . value ) } 
func ( h * RequestHeader ) HasAcceptEncodingBytes ( acceptEncoding [ ] byte ) bool { ae := h . peek ( strAcceptEncoding ) n := bytes . Index ( ae , acceptEncoding ) if n < 0 { return false } b := ae [ n + len ( acceptEncoding ) : ] if len ( b ) > 0 && b [ 0 ] != ',' { return false } if n == 0 { return true } return ae [ n - 1 ] == ' ' } 
func ( h * ResponseHeader ) Len ( ) int { n := 0 h . VisitAll ( func ( k , v [ ] byte ) { n ++ } ) return n } 
func ( h * ResponseHeader ) Reset ( ) { h . disableNormalizing = false h . noDefaultContentType = false h . resetSkipNormalize ( ) } 
func ( h * ResponseHeader ) CopyTo ( dst * ResponseHeader ) { dst . Reset ( ) dst . disableNormalizing = h . disableNormalizing dst . noHTTP11 = h . noHTTP11 dst . connectionClose = h . connectionClose dst . noDefaultContentType = h . noDefaultContentType dst . statusCode = h . statusCode dst . contentLength = h . contentLength dst . contentLengthBytes = append ( dst . contentLengthBytes [ : 0 ] , h . contentLengthBytes ... ) dst . contentType = append ( dst . contentType [ : 0 ] , h . contentType ... ) dst . server = append ( dst . server [ : 0 ] , h . server ... ) dst . h = copyArgs ( dst . h , h . h ) dst . cookies = copyArgs ( dst . cookies , h . cookies ) } 
func ( h * RequestHeader ) CopyTo ( dst * RequestHeader ) { dst . Reset ( ) dst . disableNormalizing = h . disableNormalizing dst . noHTTP11 = h . noHTTP11 dst . connectionClose = h . connectionClose dst . contentLength = h . contentLength dst . contentLengthBytes = append ( dst . contentLengthBytes [ : 0 ] , h . contentLengthBytes ... ) dst . method = append ( dst . method [ : 0 ] , h . method ... ) dst . requestURI = append ( dst . requestURI [ : 0 ] , h . requestURI ... ) dst . host = append ( dst . host [ : 0 ] , h . host ... ) dst . contentType = append ( dst . contentType [ : 0 ] , h . contentType ... ) dst . userAgent = append ( dst . userAgent [ : 0 ] , h . userAgent ... ) dst . h = copyArgs ( dst . h , h . h ) dst . cookies = copyArgs ( dst . cookies , h . cookies ) dst . cookiesCollected = h . cookiesCollected dst . rawHeaders = append ( dst . rawHeaders [ : 0 ] , h . rawHeaders ... ) dst . rawHeadersParsed = h . rawHeadersParsed dst . rawHeadersCopy = append ( dst . rawHeadersCopy [ : 0 ] , h . rawHeadersCopy ... ) } 
func ( h * ResponseHeader ) VisitAll ( f func ( key , value [ ] byte ) ) { if len ( h . contentLengthBytes ) > 0 { f ( strContentLength , h . contentLengthBytes ) } contentType := h . ContentType ( ) if len ( contentType ) > 0 { f ( strContentType , contentType ) } server := h . Server ( ) if len ( server ) > 0 { f ( strServer , server ) } if len ( h . cookies ) > 0 { visitArgs ( h . cookies , func ( k , v [ ] byte ) { f ( strSetCookie , v ) } ) } visitArgs ( h . h , f ) if h . ConnectionClose ( ) { f ( strConnection , strClose ) } } 
func ( h * ResponseHeader ) VisitAllCookie ( f func ( key , value [ ] byte ) ) { visitArgs ( h . cookies , f ) } 
func ( h * RequestHeader ) VisitAllCookie ( f func ( key , value [ ] byte ) ) { h . parseRawHeaders ( ) h . collectCookies ( ) visitArgs ( h . cookies , f ) } 
func ( h * RequestHeader ) VisitAll ( f func ( key , value [ ] byte ) ) { h . parseRawHeaders ( ) host := h . Host ( ) if len ( host ) > 0 { f ( strHost , host ) } if len ( h . contentLengthBytes ) > 0 { f ( strContentLength , h . contentLengthBytes ) } contentType := h . ContentType ( ) if len ( contentType ) > 0 { f ( strContentType , contentType ) } userAgent := h . UserAgent ( ) if len ( userAgent ) > 0 { f ( strUserAgent , userAgent ) } h . collectCookies ( ) if len ( h . cookies ) > 0 { h . bufKV . value = appendRequestCookieBytes ( h . bufKV . value [ : 0 ] , h . cookies ) f ( strCookie , h . bufKV . value ) } visitArgs ( h . h , f ) if h . ConnectionClose ( ) { f ( strConnection , strClose ) } } 
func ( h * RequestHeader ) VisitAllInOrder ( f func ( key , value [ ] byte ) ) { h . parseRawHeaders ( ) var s headerScanner s . b = h . rawHeaders s . disableNormalizing = h . disableNormalizing for s . next ( ) { if len ( s . key ) > 0 { f ( s . key , s . value ) } } } 
func ( h * ResponseHeader ) Del ( key string ) { k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) h . del ( k ) } 
func ( h * ResponseHeader ) DelBytes ( key [ ] byte ) { h . bufKV . key = append ( h . bufKV . key [ : 0 ] , key ... ) normalizeHeaderKey ( h . bufKV . key , h . disableNormalizing ) h . del ( h . bufKV . key ) } 
func ( h * RequestHeader ) Del ( key string ) { h . parseRawHeaders ( ) k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) h . del ( k ) } 
func ( h * RequestHeader ) DelBytes ( key [ ] byte ) { h . parseRawHeaders ( ) h . bufKV . key = append ( h . bufKV . key [ : 0 ] , key ... ) normalizeHeaderKey ( h . bufKV . key , h . disableNormalizing ) h . del ( h . bufKV . key ) } 
func ( h * ResponseHeader ) AddBytesKV ( key , value [ ] byte ) { h . Add ( b2s ( key ) , b2s ( value ) ) } 
func ( h * ResponseHeader ) Set ( key , value string ) { initHeaderKV ( & h . bufKV , key , value , h . disableNormalizing ) h . SetCanonical ( h . bufKV . key , h . bufKV . value ) } 
func ( h * ResponseHeader ) SetBytesK ( key [ ] byte , value string ) { h . bufKV . value = append ( h . bufKV . value [ : 0 ] , value ... ) h . SetBytesKV ( key , h . bufKV . value ) } 
func ( h * ResponseHeader ) SetCanonical ( key , value [ ] byte ) { switch string ( key ) { case " " : h . SetContentTypeBytes ( value ) case " " : h . SetServerBytes ( value ) case " " : var kv * argsKV h . cookies , kv = allocArg ( h . cookies ) kv . key = getCookieKey ( kv . key , value ) kv . value = append ( kv . value [ : 0 ] , value ... ) case " " : if contentLength , err := parseContentLength ( value ) ; err == nil { h . contentLength = contentLength h . contentLengthBytes = append ( h . contentLengthBytes [ : 0 ] , value ... ) } case " " : if bytes . Equal ( strClose , value ) { h . SetConnectionClose ( ) } else { h . ResetConnectionClose ( ) h . h = setArgBytes ( h . h , key , value , argsHasValue ) } case " " : } } 
func ( h * ResponseHeader ) SetCookie ( cookie * Cookie ) { h . cookies = setArgBytes ( h . cookies , cookie . Key ( ) , cookie . Cookie ( ) , argsHasValue ) } 
func ( h * RequestHeader ) SetCookie ( key , value string ) { h . parseRawHeaders ( ) h . collectCookies ( ) h . cookies = setArg ( h . cookies , key , value , argsHasValue ) } 
func ( h * RequestHeader ) SetCookieBytesK ( key [ ] byte , value string ) { h . SetCookie ( b2s ( key ) , value ) } 
func ( h * RequestHeader ) SetCookieBytesKV ( key , value [ ] byte ) { h . SetCookie ( b2s ( key ) , b2s ( value ) ) } 
func ( h * ResponseHeader ) DelClientCookie ( key string ) { h . DelCookie ( key ) c := AcquireCookie ( ) c . SetKey ( key ) c . SetExpire ( CookieExpireDelete ) h . SetCookie ( c ) ReleaseCookie ( c ) } 
func ( h * ResponseHeader ) DelCookie ( key string ) { h . cookies = delAllArgs ( h . cookies , key ) } 
func ( h * RequestHeader ) DelCookie ( key string ) { h . parseRawHeaders ( ) h . collectCookies ( ) h . cookies = delAllArgs ( h . cookies , key ) } 
func ( h * RequestHeader ) DelAllCookies ( ) { h . parseRawHeaders ( ) h . collectCookies ( ) h . cookies = h . cookies [ : 0 ] } 
func ( h * RequestHeader ) Add ( key , value string ) { k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) h . h = appendArg ( h . h , b2s ( k ) , value , argsHasValue ) } 
func ( h * RequestHeader ) AddBytesK ( key [ ] byte , value string ) { h . Add ( b2s ( key ) , value ) } 
func ( h * RequestHeader ) AddBytesKV ( key , value [ ] byte ) { h . Add ( b2s ( key ) , b2s ( value ) ) } 
func ( h * RequestHeader ) SetBytesV ( key string , value [ ] byte ) { k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) h . SetCanonical ( k , value ) } 
func ( h * RequestHeader ) SetBytesKV ( key , value [ ] byte ) { h . bufKV . key = append ( h . bufKV . key [ : 0 ] , key ... ) normalizeHeaderKey ( h . bufKV . key , h . disableNormalizing ) h . SetCanonical ( h . bufKV . key , value ) } 
func ( h * RequestHeader ) SetCanonical ( key , value [ ] byte ) { h . parseRawHeaders ( ) switch string ( key ) { case " " : h . SetHostBytes ( value ) case " " : h . SetContentTypeBytes ( value ) case " " : h . SetUserAgentBytes ( value ) case " " : h . collectCookies ( ) h . cookies = parseRequestCookies ( h . cookies , value ) case " " : if contentLength , err := parseContentLength ( value ) ; err == nil { h . contentLength = contentLength h . contentLengthBytes = append ( h . contentLengthBytes [ : 0 ] , value ... ) } case " " : if bytes . Equal ( strClose , value ) { h . SetConnectionClose ( ) } else { h . ResetConnectionClose ( ) h . h = setArgBytes ( h . h , key , value , argsHasValue ) } case " " : } } 
func ( h * ResponseHeader ) Peek ( key string ) [ ] byte { k := getHeaderKeyBytes ( & h . bufKV , key , h . disableNormalizing ) return h . peek ( k ) } 
func ( h * ResponseHeader ) PeekBytes ( key [ ] byte ) [ ] byte { h . bufKV . key = append ( h . bufKV . key [ : 0 ] , key ... ) normalizeHeaderKey ( h . bufKV . key , h . disableNormalizing ) return h . peek ( h . bufKV . key ) } 
func ( h * RequestHeader ) Cookie ( key string ) [ ] byte { h . parseRawHeaders ( ) h . collectCookies ( ) return peekArgStr ( h . cookies , key ) } 
func ( h * RequestHeader ) CookieBytes ( key [ ] byte ) [ ] byte { h . parseRawHeaders ( ) h . collectCookies ( ) return peekArgBytes ( h . cookies , key ) } 
func ( h * ResponseHeader ) Cookie ( cookie * Cookie ) bool { v := peekArgBytes ( h . cookies , cookie . Key ( ) ) if v == nil { return false } cookie . ParseBytes ( v ) return true } 
func ( h * RequestHeader ) Read ( r * bufio . Reader ) error { n := 1 for { err := h . tryRead ( r , n ) if err == nil { return nil } if err != errNeedMore { h . resetSkipNormalize ( ) return err } n = r . Buffered ( ) + 1 } } 
func ( h * ResponseHeader ) Header ( ) [ ] byte { h . bufKV . value = h . AppendBytes ( h . bufKV . value [ : 0 ] ) return h . bufKV . value } 
func ( h * ResponseHeader ) AppendBytes ( dst [ ] byte ) [ ] byte { statusCode := h . StatusCode ( ) if statusCode < 0 { statusCode = StatusOK } dst = append ( dst , statusLine ( statusCode ) ... ) server := h . Server ( ) if len ( server ) != 0 { dst = appendHeaderLine ( dst , strServer , server ) } dst = appendHeaderLine ( dst , strDate , serverDate . Load ( ) . ( [ ] byte ) ) } if len ( h . contentLengthBytes ) > 0 { dst = appendHeaderLine ( dst , strContentLength , h . contentLengthBytes ) } for i , n := 0 , len ( h . h ) ; i < n ; i ++ { kv := & h . h [ i ] if ! bytes . Equal ( kv . key , strDate ) { dst = appendHeaderLine ( dst , kv . key , kv . value ) } } n := len ( h . cookies ) if n > 0 { for i := 0 ; i < n ; i ++ { kv := & h . cookies [ i ] dst = appendHeaderLine ( dst , strSetCookie , kv . value ) } } if h . ConnectionClose ( ) { dst = appendHeaderLine ( dst , strConnection , strClose ) } return append ( dst , strCRLF ... ) } 
func ( h * RequestHeader ) Write ( w * bufio . Writer ) error { _ , err := w . Write ( h . Header ( ) ) return err } 
func ( h * RequestHeader ) WriteTo ( w io . Writer ) ( int64 , error ) { n , err := w . Write ( h . Header ( ) ) return int64 ( n ) , err } 
func ( h * RequestHeader ) Header ( ) [ ] byte { h . bufKV . value = h . AppendBytes ( h . bufKV . value [ : 0 ] ) return h . bufKV . value } 
func ( h * RequestHeader ) AppendBytes ( dst [ ] byte ) [ ] byte { dst = append ( dst , ' ' ) dst = append ( dst , h . RequestURI ( ) ... ) dst = append ( dst , ' ' ) dst = append ( dst , strHTTP11 ... ) dst = append ( dst , strCRLF ... ) if ! h . rawHeadersParsed && len ( h . rawHeaders ) > 0 { return append ( dst , h . rawHeaders ... ) } userAgent := h . UserAgent ( ) if len ( userAgent ) > 0 { dst = appendHeaderLine ( dst , strUserAgent , userAgent ) } host := h . Host ( ) if len ( host ) > 0 { dst = appendHeaderLine ( dst , strHost , host ) } contentType := h . ContentType ( ) if ! h . ignoreBody ( ) { if len ( contentType ) == 0 { contentType = strPostArgsContentType } dst = appendHeaderLine ( dst , strContentType , contentType ) if len ( h . contentLengthBytes ) > 0 { dst = appendHeaderLine ( dst , strContentLength , h . contentLengthBytes ) } } else if len ( contentType ) > 0 { dst = appendHeaderLine ( dst , strContentType , contentType ) } for i , n := 0 , len ( h . h ) ; i < n ; i ++ { kv := & h . h [ i ] dst = appendHeaderLine ( dst , kv . key , kv . value ) } if n > 0 { dst = append ( dst , strCookie ... ) dst = append ( dst , strColonSpace ... ) dst = appendRequestCookieBytes ( dst , h . cookies ) dst = append ( dst , strCRLF ... ) } if h . ConnectionClose ( ) { dst = appendHeaderLine ( dst , strConnection , strClose ) } return append ( dst , strCRLF ... ) } 
func AppendNormalizedHeaderKey ( dst [ ] byte , key string ) [ ] byte { dst = append ( dst , key ... ) normalizeHeaderKey ( dst [ len ( dst ) - len ( key ) : ] , false ) return dst } 
func FasthttpSocksDialer ( proxyAddr string ) fasthttp . DialFunc { return func ( addr string ) ( net . Conn , error ) { dialer , err := proxy . SOCKS5 ( " " , proxyAddr , nil , proxy . Direct ) if err != nil { return nil , err } return dialer . Dial ( " " , addr ) } } 
func ServeFileUncompressed ( ctx * RequestCtx , path string ) { ctx . Request . Header . DelBytes ( strAcceptEncoding ) ServeFile ( ctx , path ) } 
func ServeFile ( ctx * RequestCtx , path string ) { rootFSOnce . Do ( func ( ) { rootFSHandler = rootFS . NewRequestHandler ( ) } ) if len ( path ) == 0 || path [ 0 ] != '/' { if path , err = filepath . Abs ( path ) ; err != nil { ctx . Logger ( ) . Printf ( " " , path , err ) ctx . Error ( " " , StatusInternalServerError ) return } } ctx . Request . SetRequestURI ( path ) rootFSHandler ( ctx ) } 
func NewVHostPathRewriter ( slashesCount int ) PathRewriteFunc { return func ( ctx * RequestCtx ) [ ] byte { path := stripLeadingSlashes ( ctx . Path ( ) , slashesCount ) host := ctx . Host ( ) if n := bytes . IndexByte ( host , '/' ) ; n >= 0 { host = nil } if len ( host ) == 0 { host = strInvalidHost } b := bytebufferpool . Get ( ) b . B = append ( b . B , '/' ) b . B = append ( b . B , host ... ) b . B = append ( b . B , path ... ) ctx . URI ( ) . SetPathBytes ( b . B ) bytebufferpool . Put ( b ) return ctx . Path ( ) } } 
func NewPathSlashesStripper ( slashesCount int ) PathRewriteFunc { return func ( ctx * RequestCtx ) [ ] byte { return stripLeadingSlashes ( ctx . Path ( ) , slashesCount ) } } 
func NewPathPrefixStripper ( prefixSize int ) PathRewriteFunc { return func ( ctx * RequestCtx ) [ ] byte { path := ctx . Path ( ) if len ( path ) >= prefixSize { path = path [ prefixSize : ] } return path } } 
func FSHandler ( root string , stripSlashes int ) RequestHandler { fs := & FS { Root : root , IndexNames : [ ] string { " " } , GenerateIndexPages : true , AcceptByteRange : true , } if stripSlashes > 0 { fs . PathRewrite = NewPathSlashesStripper ( stripSlashes ) } return fs . NewRequestHandler ( ) } 
func ( fs * FS ) NewRequestHandler ( ) RequestHandler { fs . once . Do ( fs . initRequestHandler ) return fs . h } 
func ParseByteRange ( byteRange [ ] byte , contentLength int ) ( startPos , endPos int , err error ) { b := byteRange if ! bytes . HasPrefix ( b , strBytes ) { return 0 , 0 , fmt . Errorf ( " " , byteRange , strBytes ) } b = b [ len ( strBytes ) : ] if len ( b ) == 0 || b [ 0 ] != '=' { return 0 , 0 , fmt . Errorf ( " " , byteRange ) } b = b [ 1 : ] n := bytes . IndexByte ( b , '-' ) if n < 0 { return 0 , 0 , fmt . Errorf ( " " , byteRange ) } if n == 0 { v , err := ParseUint ( b [ n + 1 : ] ) if err != nil { return 0 , 0 , err } startPos := contentLength - v if startPos < 0 { startPos = 0 } return startPos , contentLength - 1 , nil } if startPos , err = ParseUint ( b [ : n ] ) ; err != nil { return 0 , 0 , err } if startPos >= contentLength { return 0 , 0 , fmt . Errorf ( " " , contentLength - 1 , byteRange ) } b = b [ n + 1 : ] if len ( b ) == 0 { return startPos , contentLength - 1 , nil } if endPos , err = ParseUint ( b ) ; err != nil { return 0 , 0 , err } if endPos >= contentLength { endPos = contentLength - 1 } if endPos < startPos { return 0 , 0 , fmt . Errorf ( " " , byteRange ) } return startPos , endPos , nil } 
func FileLastModified ( path string ) ( time . Time , error ) { f , err := os . Open ( path ) if err != nil { return zeroTime , err } fileInfo , err := f . Stat ( ) f . Close ( ) if err != nil { return zeroTime , err } return fsModTime ( fileInfo . ModTime ( ) ) , nil } 
func ( c * Cookie ) CopyTo ( src * Cookie ) { c . Reset ( ) c . key = append ( c . key [ : 0 ] , src . key ... ) c . value = append ( c . value [ : 0 ] , src . value ... ) c . expire = src . expire c . maxAge = src . maxAge c . domain = append ( c . domain [ : 0 ] , src . domain ... ) c . path = append ( c . path [ : 0 ] , src . path ... ) c . httpOnly = src . httpOnly c . secure = src . secure c . sameSite = src . sameSite } 
func ( c * Cookie ) SetPath ( path string ) { c . buf = append ( c . buf [ : 0 ] , path ... ) c . path = normalizePath ( c . path , c . buf ) } 
func ( c * Cookie ) SetPathBytes ( path [ ] byte ) { c . buf = append ( c . buf [ : 0 ] , path ... ) c . path = normalizePath ( c . path , c . buf ) } 
func ( c * Cookie ) SetDomain ( domain string ) { c . domain = append ( c . domain [ : 0 ] , domain ... ) } 
func ( c * Cookie ) SetDomainBytes ( domain [ ] byte ) { c . domain = append ( c . domain [ : 0 ] , domain ... ) } 
func ( c * Cookie ) Expire ( ) time . Time { expire := c . expire if expire . IsZero ( ) { expire = CookieExpireUnlimited } return expire } 
func ( c * Cookie ) SetValue ( value string ) { c . value = append ( c . value [ : 0 ] , value ... ) } 
func ( c * Cookie ) SetValueBytes ( value [ ] byte ) { c . value = append ( c . value [ : 0 ] , value ... ) } 
func ( c * Cookie ) SetKey ( key string ) { c . key = append ( c . key [ : 0 ] , key ... ) } 
func ( c * Cookie ) SetKeyBytes ( key [ ] byte ) { c . key = append ( c . key [ : 0 ] , key ... ) } 
func ( c * Cookie ) Reset ( ) { c . key = c . key [ : 0 ] c . value = c . value [ : 0 ] c . expire = zeroTime c . maxAge = 0 c . domain = c . domain [ : 0 ] c . path = c . path [ : 0 ] c . httpOnly = false c . secure = false c . sameSite = CookieSameSiteDisabled } 
func ( c * Cookie ) AppendBytes ( dst [ ] byte ) [ ] byte { if len ( c . key ) > 0 { dst = append ( dst , c . key ... ) dst = append ( dst , '=' ) } dst = append ( dst , c . value ... ) if c . maxAge > 0 { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieMaxAge ... ) dst = append ( dst , '=' ) dst = AppendUint ( dst , c . maxAge ) } else if ! c . expire . IsZero ( ) { c . bufKV . value = AppendHTTPDate ( c . bufKV . value [ : 0 ] , c . expire ) dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieExpires ... ) dst = append ( dst , '=' ) dst = append ( dst , c . bufKV . value ... ) } if len ( c . domain ) > 0 { dst = appendCookiePart ( dst , strCookieDomain , c . domain ) } if len ( c . path ) > 0 { dst = appendCookiePart ( dst , strCookiePath , c . path ) } if c . httpOnly { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieHTTPOnly ... ) } if c . secure { dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSecure ... ) } switch c . sameSite { case CookieSameSiteDefaultMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) case CookieSameSiteLaxMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) dst = append ( dst , '=' ) dst = append ( dst , strCookieSameSiteLax ... ) case CookieSameSiteStrictMode : dst = append ( dst , ';' , ' ' ) dst = append ( dst , strCookieSameSite ... ) dst = append ( dst , '=' ) dst = append ( dst , strCookieSameSiteStrict ... ) } return dst } 
func ( c * Cookie ) Cookie ( ) [ ] byte { c . buf = c . AppendBytes ( c . buf [ : 0 ] ) return c . buf } 
func ( c * Cookie ) WriteTo ( w io . Writer ) ( int64 , error ) { n , err := w . Write ( c . Cookie ( ) ) return int64 ( n ) , err } 
func ( c * Cookie ) Parse ( src string ) error { c . buf = append ( c . buf [ : 0 ] , src ... ) return c . ParseBytes ( c . buf ) } 
func ( c * Cookie ) ParseBytes ( src [ ] byte ) error { c . Reset ( ) var s cookieScanner s . b = src kv := & c . bufKV if ! s . next ( kv ) { return errNoCookies } c . key = append ( c . key [ : 0 ] , kv . key ... ) c . value = append ( c . value [ : 0 ] , kv . value ... ) for s . next ( kv ) { if len ( kv . key ) != 0 { if err != nil { return err } c . maxAge = maxAge } case 'e' : if err != nil { exptime , err = time . Parse ( " " , v ) if err != nil { return err } } c . expire = exptime } case 'd' : } case 'p' : } case 's' : } case 's' : } } } } } else if len ( kv . value ) != 0 { } case 's' : } else if caseInsensitiveCompare ( strCookieSameSite , kv . value ) { c . sameSite = CookieSameSiteDefaultMode } } } } return nil } 
func appendResponseCookieBytes ( dst [ ] byte , cookies [ ] argsKV ) [ ] byte { for i , n := 0 , len ( cookies ) ; i < n ; i ++ { kv := & cookies [ i ] dst = append ( dst , kv . value ... ) if i + 1 < n { dst = append ( dst , ';' , ' ' ) } } return dst } 
func PprofHandler ( ctx * fasthttp . RequestCtx ) { ctx . Response . Header . Set ( " " , " " ) if strings . HasPrefix ( string ( ctx . Path ( ) ) , " " ) { cmdline ( ctx ) } else if strings . HasPrefix ( string ( ctx . Path ( ) ) , " " ) { profile ( ctx ) } else if strings . HasPrefix ( string ( ctx . Path ( ) ) , " " ) { symbol ( ctx ) } else if strings . HasPrefix ( string ( ctx . Path ( ) ) , " " ) { trace ( ctx ) } else { for _ , v := range rtp . Profiles ( ) { ppName := v . Name ( ) if strings . HasPrefix ( string ( ctx . Path ( ) ) , " " + ppName ) { namedHandler := fasthttpadaptor . NewFastHTTPHandlerFunc ( pprof . Handler ( ppName ) . ServeHTTP ) namedHandler ( ctx ) return } } index ( ctx ) } } 
func DialTimeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return defaultDialer . DialTimeout ( addr , timeout ) } 
func ( d * TCPDialer ) Dial ( addr string ) ( net . Conn , error ) { return d . dial ( addr , false , DefaultDialTimeout ) } 
func ( d * TCPDialer ) DialTimeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return d . dial ( addr , false , timeout ) } 
func ( d * TCPDialer ) DialDualStack ( addr string ) ( net . Conn , error ) { return d . dial ( addr , true , DefaultDialTimeout ) } 
func ( d * TCPDialer ) DialDualStackTimeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return d . dial ( addr , true , timeout ) } 
func AcquireTimer ( timeout time . Duration ) * time . Timer { v := timerPool . Get ( ) if v == nil { return time . NewTimer ( timeout ) } t := v . ( * time . Timer ) initTimer ( t , timeout ) return t } 
func ( ln * InmemoryListener ) Accept ( ) ( net . Conn , error ) { c , ok := <- ln . conns if ! ok { return nil , fmt . Errorf ( " " ) } close ( c . accepted ) return c . conn , nil } 
func ( ln * InmemoryListener ) Close ( ) error { var err error ln . lock . Lock ( ) if ! ln . closed { close ( ln . conns ) ln . closed = true } else { err = fmt . Errorf ( " " ) } ln . lock . Unlock ( ) return err } 
func ( ln * InmemoryListener ) Dial ( ) ( net . Conn , error ) { pc := NewPipeConns ( ) cConn := pc . Conn1 ( ) sConn := pc . Conn2 ( ) ln . lock . Lock ( ) accepted := make ( chan struct { } ) if ! ln . closed { ln . conns <- acceptConn { sConn , accepted } } else { sConn . Close ( ) cConn . Close ( ) cConn = nil } ln . lock . Unlock ( ) if cConn == nil { return nil , fmt . Errorf ( " " ) } return cConn , nil } 
func Listen ( network , addr string ) ( net . Listener , error ) { ln , err := cfg . NewListener ( network , addr ) if err != nil && strings . Contains ( err . Error ( ) , " " ) { return nil , & ErrNoReusePort { err } } return ln , err } 
func FileServer ( r chi . Router , path string , root http . FileSystem ) { if strings . ContainsAny ( path , " " ) { panic ( " " ) } fs := http . StripPrefix ( path , http . FileServer ( root ) ) if path != " " && path [ len ( path ) - 1 ] != '/' { r . Get ( path , http . RedirectHandler ( path + " " , 301 ) . ServeHTTP ) path += " " } path += " " r . Get ( path , http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { fs . ServeHTTP ( w , r ) } ) ) } 
func ( x * Context ) Reset ( ) { x . Routes = nil x . RoutePath = " " x . RouteMethod = " " x . RoutePatterns = x . RoutePatterns [ : 0 ] x . URLParams . Keys = x . URLParams . Keys [ : 0 ] x . URLParams . Values = x . URLParams . Values [ : 0 ] x . routePattern = " " x . routeParams . Keys = x . routeParams . Keys [ : 0 ] x . routeParams . Values = x . routeParams . Values [ : 0 ] x . methodNotAllowed = false } 
func ( x * Context ) URLParam ( key string ) string { for k := len ( x . URLParams . Keys ) - 1 ; k >= 0 ; k -- { if x . URLParams . Keys [ k ] == key { return x . URLParams . Values [ k ] } } return " " } 
func ( x * Context ) RoutePattern ( ) string { routePattern := strings . Join ( x . RoutePatterns , " " ) return strings . Replace ( routePattern , " " , " " , - 1 ) } 
func URLParam ( r * http . Request , key string ) string { if rctx := RouteContext ( r . Context ( ) ) ; rctx != nil { return rctx . URLParam ( key ) } return " " } 
func URLParamFromCtx ( ctx context . Context , key string ) string { if rctx := RouteContext ( ctx ) ; rctx != nil { return rctx . URLParam ( key ) } return " " } 
func ( s * RouteParams ) Add ( key , value string ) { ( * s ) . Keys = append ( ( * s ) . Keys , key ) ( * s ) . Values = append ( ( * s ) . Values , value ) } 
func ServerBaseContext ( baseCtx context . Context , h http . Handler ) http . Handler { fn := http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) baseCtx := baseCtx } if v , ok := ctx . Value ( http . LocalAddrContextKey ) . ( net . Addr ) ; ok { baseCtx = context . WithValue ( baseCtx , http . LocalAddrContextKey , v ) } h . ServeHTTP ( w , r . WithContext ( baseCtx ) ) } ) return fn } 
func GetHead ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if r . Method == " " { rctx := chi . RouteContext ( r . Context ( ) ) routePath := rctx . RoutePath if routePath == " " { if r . URL . RawPath != " " { routePath = r . URL . RawPath } else { routePath = r . URL . Path } } rctx . RoutePath = routePath next . ServeHTTP ( w , r ) return } } next . ServeHTTP ( w , r ) } ) } 
func Heartbeat ( endpoint string ) func ( http . Handler ) http . Handler { f := func ( h http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { if r . Method == " " && strings . EqualFold ( r . URL . Path , endpoint ) { w . Header ( ) . Set ( " " , " " ) w . WriteHeader ( http . StatusOK ) w . Write ( [ ] byte ( " " ) ) return } h . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } return f } 
func RealIP ( h http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { if rip := realIP ( r ) ; rip != " " { r . RemoteAddr = rip } h . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func Ping ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } 
func cW ( w io . Writer , useColor bool , color [ ] byte , s string , args ... interface { } ) { if isTTY && useColor { w . Write ( color ) } fmt . Fprintf ( w , s , args ... ) if isTTY && useColor { w . Write ( reset ) } } 
func Recoverer ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { defer func ( ) { if rvr := recover ( ) ; rvr != nil { logEntry := GetLogEntry ( r ) if logEntry != nil { logEntry . Panic ( rvr , debug . Stack ( ) ) } else { fmt . Fprintf ( os . Stderr , " \n " , rvr ) debug . PrintStack ( ) } http . Error ( w , http . StatusText ( http . StatusInternalServerError ) , http . StatusInternalServerError ) } } ( ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func StripSlashes ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { var path string rctx := chi . RouteContext ( r . Context ( ) ) if rctx . RoutePath != " " { path = rctx . RoutePath } else { path = r . URL . Path } if len ( path ) > 1 && path [ len ( path ) - 1 ] == '/' { rctx . RoutePath = path [ : len ( path ) - 1 ] } next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func RedirectSlashes ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { var path string rctx := chi . RouteContext ( r . Context ( ) ) if rctx . RoutePath != " " { path = rctx . RoutePath } else { path = r . URL . Path } if len ( path ) > 1 && path [ len ( path ) - 1 ] == '/' { if r . URL . RawQuery != " " { path = fmt . Sprintf ( " " , path [ : len ( path ) - 1 ] , r . URL . RawQuery ) } else { path = path [ : len ( path ) - 1 ] } http . Redirect ( w , r , path , 301 ) return } next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func Profiler ( ) http . Handler { r := chi . NewRouter ( ) r . Use ( NoCache ) r . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { http . Redirect ( w , r , r . RequestURI + " " , 301 ) } ) r . HandleFunc ( " " , func ( w http . ResponseWriter , r * http . Request ) { http . Redirect ( w , r , r . RequestURI + " " , 301 ) } ) r . HandleFunc ( " " , pprof . Index ) r . HandleFunc ( " " , pprof . Cmdline ) r . HandleFunc ( " " , pprof . Profile ) r . HandleFunc ( " " , pprof . Symbol ) r . HandleFunc ( " " , pprof . Trace ) r . HandleFunc ( " " , expVars ) return r } 
func Timeout ( timeout time . Duration ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { ctx , cancel := context . WithTimeout ( r . Context ( ) , timeout ) defer func ( ) { cancel ( ) if ctx . Err ( ) == context . DeadlineExceeded { w . WriteHeader ( http . StatusGatewayTimeout ) } } ( ) r = r . WithContext ( ctx ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } } 
func SetHeader ( key , value string ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { w . Header ( ) . Set ( key , value ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } } 
func AllowContentType ( contentTypes ... string ) func ( next http . Handler ) http . Handler { cT := [ ] string { } for _ , t := range contentTypes { cT = append ( cT , strings . ToLower ( t ) ) } return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { if r . ContentLength == 0 { return } s := strings . ToLower ( strings . TrimSpace ( r . Header . Get ( " " ) ) ) if i := strings . Index ( s , " " ) ; i > - 1 { s = s [ 0 : i ] } for _ , t := range cT { if t == s { next . ServeHTTP ( w , r ) return } } w . WriteHeader ( http . StatusUnsupportedMediaType ) } return http . HandlerFunc ( fn ) } } 
func init ( ) { hostname , err := os . Hostname ( ) if hostname == " " || err != nil { hostname = " " } var buf [ 12 ] byte var b64 string for len ( b64 ) < 10 { rand . Read ( buf [ : ] ) b64 = base64 . StdEncoding . EncodeToString ( buf [ : ] ) b64 = strings . NewReplacer ( " " , " " , " " , " " ) . Replace ( b64 ) } prefix = fmt . Sprintf ( " " , hostname , b64 [ 0 : 10 ] ) } 
func RequestID ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) requestID := r . Header . Get ( " " ) if requestID == " " { myid := atomic . AddUint64 ( & reqid , 1 ) requestID = fmt . Sprintf ( " " , prefix , myid ) } ctx = context . WithValue ( ctx , RequestIDKey , requestID ) next . ServeHTTP ( w , r . WithContext ( ctx ) ) } return http . HandlerFunc ( fn ) } 
func GetReqID ( ctx context . Context ) string { if ctx == nil { return " " } if reqID , ok := ctx . Value ( RequestIDKey ) . ( string ) ; ok { return reqID } return " " } 
func ( mws Middlewares ) HandlerFunc ( h http . HandlerFunc ) http . Handler { return & ChainHandler { mws , h , chain ( mws , h ) } } 
func chain ( middlewares [ ] func ( http . Handler ) http . Handler , endpoint http . Handler ) http . Handler { } for i := len ( middlewares ) - 2 ; i >= 0 ; i -- { h = middlewares [ i ] ( h ) } return h } 
func NewMux ( ) * Mux { mux := & Mux { tree : & node { } , pool : & sync . Pool { } } mux . pool . New = func ( ) interface { } { return NewRouteContext ( ) } return mux } 
func ( mx * Mux ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { return } if rctx != nil { mx . handler . ServeHTTP ( w , r ) return } rctx . Reset ( ) rctx . Routes = mx r = r . WithContext ( context . WithValue ( r . Context ( ) , RouteCtxKey , rctx ) ) mx . handler . ServeHTTP ( w , r ) mx . pool . Put ( rctx ) } 
func ( mx * Mux ) Use ( middlewares ... func ( http . Handler ) http . Handler ) { if mx . handler != nil { panic ( " " ) } mx . middlewares = append ( mx . middlewares , middlewares ... ) } 
func ( mx * Mux ) Handle ( pattern string , handler http . Handler ) { mx . handle ( mALL , pattern , handler ) } 
func ( mx * Mux ) HandleFunc ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mALL , pattern , handlerFn ) } 
func ( mx * Mux ) Method ( method , pattern string , handler http . Handler ) { m , ok := methodMap [ strings . ToUpper ( method ) ] if ! ok { panic ( fmt . Sprintf ( " " , method ) ) } mx . handle ( m , pattern , handler ) } 
func ( mx * Mux ) MethodFunc ( method , pattern string , handlerFn http . HandlerFunc ) { mx . Method ( method , pattern , handlerFn ) } 
func ( mx * Mux ) Connect ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mCONNECT , pattern , handlerFn ) } 
func ( mx * Mux ) Delete ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mDELETE , pattern , handlerFn ) } 
func ( mx * Mux ) Get ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mGET , pattern , handlerFn ) } 
func ( mx * Mux ) Head ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mHEAD , pattern , handlerFn ) } 
func ( mx * Mux ) Options ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mOPTIONS , pattern , handlerFn ) } 
func ( mx * Mux ) Patch ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mPATCH , pattern , handlerFn ) } 
func ( mx * Mux ) Post ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mPOST , pattern , handlerFn ) } 
func ( mx * Mux ) Put ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mPUT , pattern , handlerFn ) } 
func ( mx * Mux ) Trace ( pattern string , handlerFn http . HandlerFunc ) { mx . handle ( mTRACE , pattern , handlerFn ) } 
func ( mx * Mux ) NotFound ( handlerFn http . HandlerFunc ) { hFn := handlerFn if mx . inline && mx . parent != nil { m = mx . parent hFn = Chain ( mx . middlewares ... ) . HandlerFunc ( hFn ) . ServeHTTP } m . updateSubRoutes ( func ( subMux * Mux ) { if subMux . notFoundHandler == nil { subMux . NotFound ( hFn ) } } ) } 
func ( mx * Mux ) MethodNotAllowed ( handlerFn http . HandlerFunc ) { hFn := handlerFn if mx . inline && mx . parent != nil { m = mx . parent hFn = Chain ( mx . middlewares ... ) . HandlerFunc ( hFn ) . ServeHTTP } m . updateSubRoutes ( func ( subMux * Mux ) { if subMux . methodNotAllowedHandler == nil { subMux . MethodNotAllowed ( hFn ) } } ) } 
func ( mx * Mux ) With ( middlewares ... func ( http . Handler ) http . Handler ) Router { } if mx . inline { mws = make ( Middlewares , len ( mx . middlewares ) ) copy ( mws , mx . middlewares ) } mws = append ( mws , middlewares ... ) im := & Mux { pool : mx . pool , inline : true , parent : mx , tree : mx . tree , middlewares : mws } return im } 
func ( mx * Mux ) Group ( fn func ( r Router ) ) Router { im := mx . With ( ) . ( * Mux ) if fn != nil { fn ( im ) } return im } 
func ( mx * Mux ) Route ( pattern string , fn func ( r Router ) ) Router { subRouter := NewRouter ( ) if fn != nil { fn ( subRouter ) } mx . Mount ( pattern , subRouter ) return subRouter } 
func ( mx * Mux ) Mount ( pattern string , handler http . Handler ) { } if ok && subr . notFoundHandler == nil && mx . notFoundHandler != nil { subr . NotFound ( mx . notFoundHandler ) } if ok && subr . methodNotAllowedHandler == nil && mx . methodNotAllowedHandler != nil { subr . MethodNotAllowed ( mx . methodNotAllowedHandler ) } rctx . RoutePath = mx . nextRoutePath ( rctx ) handler . ServeHTTP ( w , r ) } ) if pattern == " " || pattern [ len ( pattern ) - 1 ] != '/' { mx . handle ( mALL | mSTUB , pattern , mountHandler ) mx . handle ( mALL | mSTUB , pattern + " " , mountHandler ) pattern += " " } method := mALL subroutes , _ := handler . ( Routes ) if subroutes != nil { method |= mSTUB } n := mx . handle ( method , pattern + " " , mountHandler ) if subroutes != nil { n . subroutes = subroutes } } 
func ( mx * Mux ) Match ( rctx * Context , method , path string ) bool { m , ok := methodMap [ method ] if ! ok { return false } node , _ , h := mx . tree . FindRoute ( rctx , m , path ) if node != nil && node . subroutes != nil { rctx . RoutePath = mx . nextRoutePath ( rctx ) return node . subroutes . Match ( rctx , method , rctx . RoutePath ) } return h != nil } 
func ( mx * Mux ) NotFoundHandler ( ) http . HandlerFunc { if mx . notFoundHandler != nil { return mx . notFoundHandler } return http . NotFound } 
func ( mx * Mux ) MethodNotAllowedHandler ( ) http . HandlerFunc { if mx . methodNotAllowedHandler != nil { return mx . methodNotAllowedHandler } return methodNotAllowedHandler } 
func ( mx * Mux ) buildRouteHandler ( ) { mx . handler = chain ( mx . middlewares , http . HandlerFunc ( mx . routeHTTP ) ) } 
func ( mx * Mux ) handle ( method methodTyp , pattern string , handler http . Handler ) * node { if len ( pattern ) == 0 || pattern [ 0 ] != '/' { panic ( fmt . Sprintf ( " " , pattern ) ) } } if mx . inline { mx . handler = http . HandlerFunc ( mx . routeHTTP ) h = Chain ( mx . middlewares ... ) . Handler ( handler ) } else { h = handler } } 
func ( mx * Mux ) routeHTTP ( w http . ResponseWriter , r * http . Request ) { if routePath == " " { if r . URL . RawPath != " " { routePath = r . URL . RawPath } else { routePath = r . URL . Path } } } method , ok := methodMap [ rctx . RouteMethod ] if ! ok { mx . MethodNotAllowedHandler ( ) . ServeHTTP ( w , r ) return } return } if rctx . methodNotAllowed { mx . MethodNotAllowedHandler ( ) . ServeHTTP ( w , r ) } else { mx . NotFoundHandler ( ) . ServeHTTP ( w , r ) } } 
func ( mx * Mux ) updateSubRoutes ( fn func ( subMux * Mux ) ) { for _ , r := range mx . tree . routes ( ) { subMux , ok := r . SubRoutes . ( * Mux ) if ! ok { continue } fn ( subMux ) } } 
func methodNotAllowedHandler ( w http . ResponseWriter , r * http . Request ) { w . WriteHeader ( 405 ) w . Write ( nil ) } 
func NoCache ( h http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { } } } h . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func RequestLogger ( f LogFormatter ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { entry := f . NewLogEntry ( r ) ww := NewWrapResponseWriter ( w , r . ProtoMajor ) t1 := time . Now ( ) defer func ( ) { entry . Write ( ww . Status ( ) , ww . BytesWritten ( ) , time . Since ( t1 ) ) } ( ) next . ServeHTTP ( ww , WithLogEntry ( r , entry ) ) } return http . HandlerFunc ( fn ) } } 
func GetLogEntry ( r * http . Request ) LogEntry { entry , _ := r . Context ( ) . Value ( LogEntryCtxKey ) . ( LogEntry ) return entry } 
func WithLogEntry ( r * http . Request , entry LogEntry ) * http . Request { r = r . WithContext ( context . WithValue ( r . Context ( ) , LogEntryCtxKey , entry ) ) return r } 
func ( l * DefaultLogFormatter ) NewLogEntry ( r * http . Request ) LogEntry { useColor := ! l . NoColor entry := & defaultLogEntry { DefaultLogFormatter : l , request : r , buf : & bytes . Buffer { } , useColor : useColor , } reqID := GetReqID ( r . Context ( ) ) if reqID != " " { cW ( entry . buf , useColor , nYellow , " " , reqID ) } cW ( entry . buf , useColor , nCyan , " \" " ) cW ( entry . buf , useColor , bMagenta , " " , r . Method ) scheme := " " if r . TLS != nil { scheme = " " } cW ( entry . buf , useColor , nCyan , " \" " , scheme , r . Host , r . RequestURI , r . Proto ) entry . buf . WriteString ( " " ) entry . buf . WriteString ( r . RemoteAddr ) entry . buf . WriteString ( " " ) return entry } 
func NewStructuredLogger ( logger * logrus . Logger ) func ( next http . Handler ) http . Handler { return middleware . RequestLogger ( & StructuredLogger { logger } ) } 
func GetLogEntry ( r * http . Request ) logrus . FieldLogger { entry := middleware . GetLogEntry ( r ) . ( * StructuredLoggerEntry ) return entry . Logger } 
func ContentCharset ( charsets ... string ) func ( next http . Handler ) http . Handler { for i , c := range charsets { charsets [ i ] = strings . ToLower ( c ) } return func ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { if ! contentEncoding ( r . Header . Get ( " " ) , charsets ... ) { w . WriteHeader ( http . StatusUnsupportedMediaType ) return } next . ServeHTTP ( w , r ) } ) } } 
func contentEncoding ( ce string , charsets ... string ) bool { _ , ce = split ( strings . ToLower ( ce ) , " " ) _ , ce = split ( ce , " " ) ce , _ = split ( ce , " " ) for _ , c := range charsets { if ce == c { return true } } return false } 
func split ( str , sep string ) ( string , string ) { var a , b string var parts = strings . SplitN ( str , sep , 2 ) a = strings . TrimSpace ( parts [ 0 ] ) if len ( parts ) == 2 { b = strings . TrimSpace ( parts [ 1 ] ) } return a , b } 
func RegisterMethod ( method string ) { if method == " " { return } method = strings . ToUpper ( method ) if _ , ok := methodMap [ method ] ; ok { return } n := len ( methodMap ) if n > strconv . IntSize { panic ( fmt . Sprintf ( " " , strconv . IntSize ) ) } mt := methodTyp ( math . Exp2 ( float64 ( n ) ) ) methodMap [ method ] = mt mALL |= mt } 
func ( n * node ) addChild ( child * node , prefix string ) * node { search := prefix if err != nil { panic ( fmt . Sprintf ( " " , segRexpat ) ) } child . prefix = segRexpat child . rex = rex } if segStartIdx == 0 { if segTyp == ntCatchAll { segStartIdx = - 1 } else { segStartIdx = segEndIdx } if segStartIdx < 0 { segStartIdx = len ( search ) } child . tail = segTail if segStartIdx != len ( search ) { nn := & node { typ : ntStatic , label : search [ 0 ] , prefix : search , } hn = child . addChild ( nn , search ) } } else if segStartIdx > 0 { child . prefix = search [ : segStartIdx ] child . rex = nil nn := & node { typ : segTyp , label : search [ 0 ] , tail : segTail , } hn = child . addChild ( nn , search ) } } n . children [ child . typ ] = append ( n . children [ child . typ ] , child ) n . children [ child . typ ] . Sort ( ) return hn } 
func ( n * node ) findRoute ( rctx * Context , method methodTyp , path string ) * node { nn := n search := path for t , nds := range nn . children { ntyp := nodeTyp ( t ) if len ( nds ) == 0 { continue } var xn * node xsearch := search var label byte if search != " " { label = search [ 0 ] } switch ntyp { case ntStatic : xn = nds . findEdge ( label ) if xn == nil || ! strings . HasPrefix ( xsearch , xn . prefix ) { continue } xsearch = xsearch [ len ( xn . prefix ) : ] case ntParam , ntRegexp : } if p < 0 { if xn . tail == '/' { p = len ( xsearch ) } else { continue } } if ntyp == ntRegexp && xn . rex != nil { if xn . rex . Match ( [ ] byte ( xsearch [ : p ] ) ) == false { continue } } else if strings . IndexByte ( xsearch [ : p ] , '/' ) != - 1 { } rctx . routeParams . Values = append ( rctx . routeParams . Values , xsearch [ : p ] ) xsearch = xsearch [ p : ] break } default : xn = nds [ 0 ] xsearch = " " } if xn == nil { continue } if h != nil && h . handler != nil { rctx . routeParams . Keys = append ( rctx . routeParams . Keys , h . paramKeys ... ) return xn } } } if fin != nil { return fin } } } } return nil } 
func patNextSegment ( pattern string ) ( nodeTyp , string , string , byte , int , int ) { ps := strings . Index ( pattern , " " ) ws := strings . Index ( pattern , " " ) if ps < 0 && ws < 0 { return ntStatic , " " , " " , 0 , 0 , len ( pattern ) } } var tail byte = '/' if ps >= 0 { pe := ps for i , c := range pattern [ ps : ] { if c == '{' { cc ++ } else if c == '}' { cc -- if cc == 0 { pe = ps + i break } } } if pe == ps { panic ( " " ) } key := pattern [ ps + 1 : pe ] pe ++ if pe < len ( pattern ) { tail = pattern [ pe ] } var rexpat string if idx := strings . Index ( key , " " ) ; idx >= 0 { nt = ntRegexp rexpat = key [ idx + 1 : ] key = key [ : idx ] } if len ( rexpat ) > 0 { if rexpat [ 0 ] != '^' { rexpat = " " + rexpat } if rexpat [ len ( rexpat ) - 1 ] != '$' { rexpat = rexpat + " " } } return nt , key , rexpat , tail , ps , pe } } return ntCatchAll , " " , " " , 0 , ws , len ( pattern ) } 
func ( ns nodes ) tailSort ( ) { for i := len ( ns ) - 1 ; i >= 0 ; i -- { if ns [ i ] . typ > ntStatic && ns [ i ] . tail == '/' { ns . Swap ( i , len ( ns ) - 1 ) return } } } 
func ArticleCtx ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { var article * Article var err error if articleID := chi . URLParam ( r , " " ) ; articleID != " " { article , err = dbGetArticle ( articleID ) } else if articleSlug := chi . URLParam ( r , " " ) ; articleSlug != " " { article , err = dbGetArticleBySlug ( articleSlug ) } else { render . Render ( w , r , ErrNotFound ) return } if err != nil { render . Render ( w , r , ErrNotFound ) return } ctx := context . WithValue ( r . Context ( ) , " " , article ) next . ServeHTTP ( w , r . WithContext ( ctx ) ) } ) } 
func SearchArticles ( w http . ResponseWriter , r * http . Request ) { render . RenderList ( w , r , NewArticleListResponse ( articles ) ) } 
func CreateArticle ( w http . ResponseWriter , r * http . Request ) { data := & ArticleRequest { } if err := render . Bind ( r , data ) ; err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } article := data . Article dbNewArticle ( article ) render . Status ( r , http . StatusCreated ) render . Render ( w , r , NewArticleResponse ( article ) ) } 
func GetArticle ( w http . ResponseWriter , r * http . Request ) { if err := render . Render ( w , r , NewArticleResponse ( article ) ) ; err != nil { render . Render ( w , r , ErrRender ( err ) ) return } } 
func UpdateArticle ( w http . ResponseWriter , r * http . Request ) { article := r . Context ( ) . Value ( " " ) . ( * Article ) data := & ArticleRequest { Article : article } if err := render . Bind ( r , data ) ; err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } article = data . Article dbUpdateArticle ( article . ID , article ) render . Render ( w , r , NewArticleResponse ( article ) ) } 
func DeleteArticle ( w http . ResponseWriter , r * http . Request ) { var err error article , err = dbRemoveArticle ( article . ID ) if err != nil { render . Render ( w , r , ErrInvalidRequest ( err ) ) return } render . Render ( w , r , NewArticleResponse ( article ) ) } 
func adminRouter ( ) chi . Router { r := chi . NewRouter ( ) r . Use ( AdminOnly ) r . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } ) r . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } ) r . Get ( " " , func ( w http . ResponseWriter , r * http . Request ) { w . Write ( [ ] byte ( fmt . Sprintf ( " " , chi . URLParam ( r , " " ) ) ) ) } ) return r } 
func AdminOnly ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { isAdmin , ok := r . Context ( ) . Value ( " " ) . ( bool ) if ! ok || ! isAdmin { http . Error ( w , http . StatusText ( http . StatusForbidden ) , http . StatusForbidden ) return } next . ServeHTTP ( w , r ) } ) } 
func paginate ( next http . Handler ) http . Handler { return http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { } ) } 
func init ( ) { render . Respond = func ( w http . ResponseWriter , r * http . Request , v interface { } ) { if err , ok := v . ( error ) ; ok { } return } render . DefaultResponder ( w , r , v ) } } 
func NewCompressor ( level int , types ... string ) * Compressor { if len ( types ) > 0 { for _ , t := range types { allowedTypes [ t ] = true } } else { for _ , t := range defaultCompressibleContentTypes { allowedTypes [ t ] = true } } c := & Compressor { level : level , encoders : make ( map [ string ] EncoderFunc ) , pooledEncoders : make ( map [ string ] * sync . Pool ) , allowedTypes : allowedTypes , } } 
func ( c * Compressor ) SetEncoder ( encoding string , fn EncoderFunc ) { encoding = strings . ToLower ( encoding ) if encoding == " " { panic ( " " ) } if fn == nil { panic ( " " ) } } if _ , ok := c . encoders [ encoding ] ; ok { delete ( c . encoders , encoding ) } if encoder != nil { if _ , ok := encoder . ( ioResetterWriter ) ; ok { pool := & sync . Pool { New : func ( ) interface { } { return fn ( ioutil . Discard , c . level ) } , } c . pooledEncoders [ encoding ] = pool } } } for i , v := range c . encodingPrecedence { if v == encoding { c . encodingPrecedence = append ( c . encodingPrecedence [ : i ] , c . encodingPrecedence [ i + 1 : ] ... ) } } c . encodingPrecedence = append ( [ ] string { encoding } , c . encodingPrecedence ... ) } 
func ( c * Compressor ) Handler ( ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { encoder , encoding , cleanup := c . selectEncoder ( r . Header , w ) cw := & compressResponseWriter { ResponseWriter : w , w : w , contentTypes : c . allowedTypes , encoding : encoding , } if encoder != nil { cw . w = encoder } defer cw . Close ( ) next . ServeHTTP ( cw , r ) } return http . HandlerFunc ( fn ) } } 
func ( c * Compressor ) selectEncoder ( h http . Header , w io . Writer ) ( io . Writer , string , func ( ) ) { header := h . Get ( " " ) cleanup := func ( ) { pool . Put ( encoder ) } encoder . Reset ( w ) return encoder , name , cleanup } if fn , ok := c . encoders [ name ] ; ok { return fn ( w , c . level ) , name , func ( ) { } } } } } 
func SetEncoder ( encoding string , fn EncoderFunc ) { if defaultCompressor == nil { panic ( " " ) } defaultCompressor . SetEncoder ( encoding , fn ) } 
func DefaultCompress ( next http . Handler ) http . Handler { return Compress ( flate . DefaultCompression ) ( next ) } 
func Compress ( level int , types ... string ) func ( next http . Handler ) http . Handler { defaultCompressor = NewCompressor ( level , types ... ) return defaultCompressor . Handler ( ) } 
func Throttle ( limit int ) func ( http . Handler ) http . Handler { return ThrottleBacklog ( limit , 0 , defaultBacklogTimeout ) } 
func ThrottleBacklog ( limit int , backlogLimit int , backlogTimeout time . Duration ) func ( http . Handler ) http . Handler { if limit < 1 { panic ( " " ) } if backlogLimit < 0 { panic ( " " ) } t := throttler { tokens : make ( chan token , limit ) , backlogTokens : make ( chan token , limit + backlogLimit ) , backlogTimeout : backlogTimeout , } } t . backlogTokens <- token { } } fn := func ( h http . Handler ) http . Handler { t . h = h return & t } return fn } 
func ( t * throttler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) select { case <- ctx . Done ( ) : http . Error ( w , errContextCanceled , http . StatusServiceUnavailable ) return case btok := <- t . backlogTokens : timer := time . NewTimer ( t . backlogTimeout ) defer func ( ) { t . backlogTokens <- btok } ( ) select { case <- timer . C : http . Error ( w , errTimedOut , http . StatusServiceUnavailable ) return case <- ctx . Done ( ) : http . Error ( w , errContextCanceled , http . StatusServiceUnavailable ) return case tok := <- t . tokens : defer func ( ) { t . tokens <- tok } ( ) t . h . ServeHTTP ( w , r ) } return default : http . Error ( w , errCapacityExceeded , http . StatusServiceUnavailable ) return } } 
func URLFormat ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { ctx := r . Context ( ) var format string path := r . URL . Path if strings . Index ( path , " " ) > 0 { base := strings . LastIndex ( path , " " ) idx := strings . Index ( path [ base : ] , " " ) if idx > 0 { idx += base format = path [ idx + 1 : ] rctx := chi . RouteContext ( r . Context ( ) ) rctx . RoutePath = path [ : idx ] } } r = r . WithContext ( context . WithValue ( ctx , URLFormatCtxKey , format ) ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } 
func NewWrapResponseWriter ( w http . ResponseWriter , protoMajor int ) WrapResponseWriter { _ , fl := w . ( http . Flusher ) bw := basicWriter { ResponseWriter : w } if protoMajor == 2 { _ , ps := w . ( http . Pusher ) if fl && ps { return & http2FancyWriter { bw } } } else { _ , hj := w . ( http . Hijacker ) _ , rf := w . ( io . ReaderFrom ) if fl && hj && rf { return & httpFancyWriter { bw } } } if fl { return & flushWriter { bw } } return & bw } 
func WithValue ( key interface { } , val interface { } ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn := func ( w http . ResponseWriter , r * http . Request ) { r = r . WithContext ( context . WithValue ( r . Context ( ) , key , val ) ) next . ServeHTTP ( w , r ) } return http . HandlerFunc ( fn ) } } 
func ( rs todosResource ) Routes ( ) chi . Router { r := chi . NewRouter ( ) r . Post ( " " , rs . Create ) r . Put ( " " , rs . Delete ) r . Route ( " " , func ( r chi . Router ) { r . Put ( " " , rs . Update ) r . Delete ( " " , rs . Delete ) r . Get ( " " , rs . Sync ) } ) return r } 
func NewAWSProvider ( awsConfig AWSConfig ) ( * AWSProvider , error ) { config := aws . NewConfig ( ) . WithMaxRetries ( awsConfig . APIRetries ) config . WithHTTPClient ( instrumented_http . NewClient ( config . HTTPClient , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) , ) session , err := session . NewSessionWithOptions ( session . Options { Config : * config , SharedConfigState : session . SharedConfigEnable , } ) if err != nil { return nil , err } if awsConfig . AssumeRole != " " { log . Infof ( " " , awsConfig . AssumeRole ) session . Config . WithCredentials ( stscreds . NewCredentials ( session , awsConfig . AssumeRole ) ) } provider := & AWSProvider { client : route53 . New ( session ) , domainFilter : awsConfig . DomainFilter , zoneIDFilter : awsConfig . ZoneIDFilter , zoneTypeFilter : awsConfig . ZoneTypeFilter , zoneTagFilter : awsConfig . ZoneTagFilter , batchChangeSize : awsConfig . BatchChangeSize , batchChangeInterval : awsConfig . BatchChangeInterval , evaluateTargetHealth : awsConfig . EvaluateTargetHealth , dryRun : awsConfig . DryRun , } return provider , nil } 
func ( p * AWSProvider ) Zones ( ) ( map [ string ] * route53 . HostedZone , error ) { zones := make ( map [ string ] * route53 . HostedZone ) var tagErr error f := func ( resp * route53 . ListHostedZonesOutput , lastPage bool ) ( shouldContinue bool ) { for _ , zone := range resp . HostedZones { if ! p . zoneIDFilter . Match ( aws . StringValue ( zone . Id ) ) { continue } if ! p . zoneTypeFilter . Match ( zone ) { continue } if ! p . domainFilter . Match ( aws . StringValue ( zone . Name ) ) { continue } if err != nil { tagErr = err return false } if ! p . zoneTagFilter . Match ( tags ) { continue } } zones [ aws . StringValue ( zone . Id ) ] = zone } return true } err := p . client . ListHostedZonesPages ( & route53 . ListHostedZonesInput { } , f ) if err != nil { return nil , err } if tagErr != nil { return nil , tagErr } for _ , zone := range zones { log . Debugf ( " " , aws . StringValue ( zone . Id ) , aws . StringValue ( zone . Name ) ) } return zones , nil } 
func wildcardUnescape ( s string ) string { if strings . Contains ( s , " \\ " ) { s = strings . Replace ( s , " \\ " , " " , 1 ) } return s } 
func ( p * AWSProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } return p . records ( zones ) } 
func ( p * AWSProvider ) CreateRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . doRecords ( route53 . ChangeActionCreate , endpoints ) } 
func ( p * AWSProvider ) UpdateRecords ( endpoints , _ [ ] * endpoint . Endpoint ) error { return p . doRecords ( route53 . ChangeActionUpsert , endpoints ) } 
func ( p * AWSProvider ) DeleteRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . doRecords ( route53 . ChangeActionDelete , endpoints ) } 
func ( p * AWSProvider ) ApplyChanges ( changes * plan . Changes ) error { zones , err := p . Zones ( ) if err != nil { return err } records , err := p . records ( zones ) if err != nil { log . Errorf ( " " , err ) } combinedChanges := make ( [ ] * route53 . Change , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , p . newChanges ( route53 . ChangeActionCreate , changes . Create , records , zones ) ... ) combinedChanges = append ( combinedChanges , p . newChanges ( route53 . ChangeActionUpsert , changes . UpdateNew , records , zones ) ... ) combinedChanges = append ( combinedChanges , p . newChanges ( route53 . ChangeActionDelete , changes . Delete , records , zones ) ... ) return p . submitChanges ( combinedChanges , zones ) } 
func ( p * AWSProvider ) submitChanges ( changes [ ] * route53 . Change , zones map [ string ] * route53 . HostedZone ) error { return nil } if len ( changesByZone ) == 0 { log . Info ( " " ) } var failedZones [ ] string for z , cs := range changesByZone { var failedUpdate bool batchCs := batchChangeSet ( cs , p . batchChangeSize ) for i , b := range batchCs { for _ , c := range b { log . Infof ( " " , * c . Action , * c . ResourceRecordSet . Name , * c . ResourceRecordSet . Type ) } if ! p . dryRun { params := & route53 . ChangeResourceRecordSetsInput { HostedZoneId : aws . String ( z ) , ChangeBatch : & route53 . ChangeBatch { Changes : b , } , } if _ , err := p . client . ChangeResourceRecordSets ( params ) ; err != nil { log . Error ( err ) failedUpdate = true } else { log . Infof ( " " , len ( b ) , aws . StringValue ( zones [ z ] . Name ) ) } if i != len ( batchCs ) - 1 { time . Sleep ( p . batchChangeInterval ) } } } if failedUpdate { failedZones = append ( failedZones , z ) } } if len ( failedZones ) > 0 { return fmt . Errorf ( " " , failedZones ) } return nil } 
func ( p * AWSProvider ) newChanges ( action string , endpoints [ ] * endpoint . Endpoint , recordsCache [ ] * endpoint . Endpoint , zones map [ string ] * route53 . HostedZone ) [ ] * route53 . Change { changes := make ( [ ] * route53 . Change , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , p . newChange ( action , endpoint , recordsCache , zones ) ) } return changes } 
func ( p * AWSProvider ) newChange ( action string , endpoint * endpoint . Endpoint , recordsCache [ ] * endpoint . Endpoint , zones map [ string ] * route53 . HostedZone ) * route53 . Change { change := & route53 . Change { Action : aws . String ( action ) , ResourceRecordSet : & route53 . ResourceRecordSet { Name : aws . String ( endpoint . DNSName ) , } , } if isAWSLoadBalancer ( endpoint ) { evalTargetHealth := p . evaluateTargetHealth if prop , ok := endpoint . GetProviderSpecificProperty ( providerSpecificEvaluateTargetHealth ) ; ok { evalTargetHealth = prop . Value == " " } change . ResourceRecordSet . Type = aws . String ( route53 . RRTypeA ) change . ResourceRecordSet . AliasTarget = & route53 . AliasTarget { DNSName : aws . String ( endpoint . Targets [ 0 ] ) , HostedZoneId : aws . String ( canonicalHostedZone ( endpoint . Targets [ 0 ] ) ) , EvaluateTargetHealth : aws . Bool ( evalTargetHealth ) , } } else if hostedZone := isAWSAlias ( endpoint , recordsCache ) ; hostedZone != " " { for _ , zone := range zones { change . ResourceRecordSet . Type = aws . String ( route53 . RRTypeA ) change . ResourceRecordSet . AliasTarget = & route53 . AliasTarget { DNSName : aws . String ( endpoint . Targets [ 0 ] ) , HostedZoneId : aws . String ( cleanZoneID ( * zone . Id ) ) , EvaluateTargetHealth : aws . Bool ( p . evaluateTargetHealth ) , } } } else { change . ResourceRecordSet . Type = aws . String ( endpoint . RecordType ) if ! endpoint . RecordTTL . IsConfigured ( ) { change . ResourceRecordSet . TTL = aws . Int64 ( recordTTL ) } else { change . ResourceRecordSet . TTL = aws . Int64 ( int64 ( endpoint . RecordTTL ) ) } change . ResourceRecordSet . ResourceRecords = make ( [ ] * route53 . ResourceRecord , len ( endpoint . Targets ) ) for idx , val := range endpoint . Targets { change . ResourceRecordSet . ResourceRecords [ idx ] = & route53 . ResourceRecord { Value : aws . String ( val ) , } } } return change } 
func changesByZone ( zones map [ string ] * route53 . HostedZone , changeSet [ ] * route53 . Change ) map [ string ] [ ] * route53 . Change { changes := make ( map [ string ] [ ] * route53 . Change ) for _ , z := range zones { changes [ aws . StringValue ( z . Id ) ] = [ ] * route53 . Change { } } for _ , c := range changeSet { hostname := ensureTrailingDot ( aws . StringValue ( c . ResourceRecordSet . Name ) ) zones := suitableZones ( hostname , zones ) if len ( zones ) == 0 { log . Debugf ( " " , c . String ( ) ) continue } for _ , z := range zones { changes [ aws . StringValue ( z . Id ) ] = append ( changes [ aws . StringValue ( z . Id ) ] , c ) log . Debugf ( " " , hostname , aws . StringValue ( z . Name ) , aws . StringValue ( z . Id ) ) } } } } return changes } 
func suitableZones ( hostname string , zones map [ string ] * route53 . HostedZone ) [ ] * route53 . HostedZone { var matchingZones [ ] * route53 . HostedZone var publicZone * route53 . HostedZone for _ , z := range zones { if aws . StringValue ( z . Name ) == hostname || strings . HasSuffix ( hostname , " " + aws . StringValue ( z . Name ) ) { if z . Config == nil || ! aws . BoolValue ( z . Config . PrivateZone ) { } } else { } } } if publicZone != nil { matchingZones = append ( matchingZones , publicZone ) } return matchingZones } 
func isAWSLoadBalancer ( ep * endpoint . Endpoint ) bool { if ep . RecordType == endpoint . RecordTypeCNAME { return canonicalHostedZone ( ep . Targets [ 0 ] ) != " " } return false } 
func isAWSAlias ( ep * endpoint . Endpoint , addrs [ ] * endpoint . Endpoint ) string { if prop , exists := ep . GetProviderSpecificProperty ( " " ) ; ep . RecordType == endpoint . RecordTypeCNAME && exists && prop . Value == " " { for _ , addr := range addrs { if addr . DNSName == ep . Targets [ 0 ] { if hostedZone := canonicalHostedZone ( addr . Targets [ 0 ] ) ; hostedZone != " " { return hostedZone } } } } return " " } 
func canonicalHostedZone ( hostname string ) string { for suffix , zone := range canonicalHostedZones { if strings . HasSuffix ( hostname , suffix ) { return zone } } return " " } 
func cleanZoneID ( ID string ) string { if strings . HasPrefix ( ID , " " ) { ID = strings . TrimPrefix ( ID , " " ) } return ID } 
func NewTXTRegistry ( provider provider . Provider , txtPrefix , ownerID string , cacheInterval time . Duration ) ( * TXTRegistry , error ) { if ownerID == " " { return nil , errors . New ( " " ) } mapper := newPrefixNameMapper ( txtPrefix ) return & TXTRegistry { provider : provider , ownerID : ownerID , mapper : mapper , cacheInterval : cacheInterval , } , nil } 
func ( im * TXTRegistry ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { return im . recordsCache , nil } records , err := im . provider . Records ( ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } labelMap := map [ string ] endpoint . Labels { } for _ , record := range records { if record . RecordType != endpoint . RecordTypeTXT { endpoints = append ( endpoints , record ) continue } if err == endpoint . ErrInvalidHeritage { continue } if err != nil { return nil , err } endpointDNSName := im . mapper . toEndpointName ( record . DNSName ) labelMap [ endpointDNSName ] = labels } for _ , ep := range endpoints { ep . Labels = endpoint . NewLabels ( ) if labels , ok := labelMap [ ep . DNSName ] ; ok { for k , v := range labels { ep . Labels [ k ] = v } } } im . recordsCacheRefreshTime = time . Now ( ) } return endpoints , nil } 
func ( im * TXTRegistry ) ApplyChanges ( changes * plan . Changes ) error { filteredChanges := & plan . Changes { Create : changes . Create , UpdateNew : filterOwnedRecords ( im . ownerID , changes . UpdateNew ) , UpdateOld : filterOwnedRecords ( im . ownerID , changes . UpdateOld ) , Delete : filterOwnedRecords ( im . ownerID , changes . Delete ) , } for _ , r := range filteredChanges . Create { if r . Labels == nil { r . Labels = make ( map [ string ] string ) } r . Labels [ endpoint . OwnerLabelKey ] = im . ownerID txt := endpoint . NewEndpoint ( im . mapper . toTXTName ( r . DNSName ) , endpoint . RecordTypeTXT , r . Labels . Serialize ( true ) ) filteredChanges . Create = append ( filteredChanges . Create , txt ) if im . cacheInterval > 0 { im . addToCache ( r ) } } for _ , r := range filteredChanges . Delete { txt := endpoint . NewEndpoint ( im . mapper . toTXTName ( r . DNSName ) , endpoint . RecordTypeTXT , r . Labels . Serialize ( true ) ) if im . cacheInterval > 0 { im . removeFromCache ( r ) } } } } filteredChanges . UpdateNew = append ( filteredChanges . UpdateNew , txt ) } } return im . provider . ApplyChanges ( filteredChanges ) } 
func NewDomainFilter ( domainFilters [ ] string ) DomainFilter { filters := make ( [ ] string , len ( domainFilters ) ) } return DomainFilter { filters } } 
func ( df DomainFilter ) Match ( domain string ) bool { } for _ , filter := range df . filters { strippedDomain := strings . TrimSuffix ( domain , " " ) if filter == " " { return true } else if strings . HasPrefix ( filter , " " ) && strings . HasSuffix ( strippedDomain , filter ) { return true } else if strings . Count ( strippedDomain , " " ) == strings . Count ( filter , " " ) { if strippedDomain == filter { return true } } else if strings . HasSuffix ( strippedDomain , " " + filter ) { return true } } return false } 
func ( df DomainFilter ) IsConfigured ( ) bool { if len ( df . filters ) == 1 { return df . filters [ 0 ] != " " } return len ( df . filters ) > 0 } 
func InMemoryWithLogging ( ) InMemoryOption { return func ( p * InMemoryProvider ) { p . OnApplyChanges = func ( changes * plan . Changes ) { for _ , v := range changes . Create { log . Infof ( " " , v ) } for _ , v := range changes . UpdateOld { log . Infof ( " " , v ) } for _ , v := range changes . UpdateNew { log . Infof ( " " , v ) } for _ , v := range changes . Delete { log . Infof ( " " , v ) } } } } 
func InMemoryInitZones ( zones [ ] string ) InMemoryOption { return func ( p * InMemoryProvider ) { for _ , z := range zones { if err := p . CreateZone ( z ) ; err != nil { log . Warnf ( " " ) } } } } 
func NewInMemoryProvider ( opts ... InMemoryOption ) * InMemoryProvider { im := & InMemoryProvider { filter : & filter { } , OnApplyChanges : func ( changes * plan . Changes ) { } , OnRecords : func ( ) { } , domain : NewDomainFilter ( [ ] string { " " } ) , client : newInMemoryClient ( ) , } for _ , opt := range opts { opt ( im ) } return im } 
func ( im * InMemoryProvider ) CreateZone ( newZone string ) error { return im . client . CreateZone ( newZone ) } 
func ( im * InMemoryProvider ) Zones ( ) map [ string ] string { return im . filter . Zones ( im . client . Zones ( ) ) } 
func ( im * InMemoryProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { defer im . OnRecords ( ) endpoints := make ( [ ] * endpoint . Endpoint , 0 ) for zoneID := range im . Zones ( ) { records , err := im . client . Records ( zoneID ) if err != nil { return nil , err } for _ , record := range records { endpoints = append ( endpoints , endpoint . NewEndpoint ( record . Name , record . Type , record . Target ) ) } } return endpoints , nil } 
func ( im * InMemoryProvider ) ApplyChanges ( changes * plan . Changes ) error { defer im . OnApplyChanges ( changes ) perZoneChanges := map [ string ] * plan . Changes { } zones := im . Zones ( ) for zoneID := range zones { perZoneChanges [ zoneID ] = & plan . Changes { } } for _ , ep := range changes . Create { zoneID := im . filter . EndpointZoneID ( ep , zones ) if zoneID == " " { continue } perZoneChanges [ zoneID ] . Create = append ( perZoneChanges [ zoneID ] . Create , ep ) } for _ , ep := range changes . UpdateNew { zoneID := im . filter . EndpointZoneID ( ep , zones ) if zoneID == " " { continue } perZoneChanges [ zoneID ] . UpdateNew = append ( perZoneChanges [ zoneID ] . UpdateNew , ep ) } for _ , ep := range changes . UpdateOld { zoneID := im . filter . EndpointZoneID ( ep , zones ) if zoneID == " " { continue } perZoneChanges [ zoneID ] . UpdateOld = append ( perZoneChanges [ zoneID ] . UpdateOld , ep ) } for _ , ep := range changes . Delete { zoneID := im . filter . EndpointZoneID ( ep , zones ) if zoneID == " " { continue } perZoneChanges [ zoneID ] . Delete = append ( perZoneChanges [ zoneID ] . Delete , ep ) } for zoneID := range perZoneChanges { change := & inMemoryChange { Create : convertToInMemoryRecord ( perZoneChanges [ zoneID ] . Create ) , UpdateNew : convertToInMemoryRecord ( perZoneChanges [ zoneID ] . UpdateNew ) , UpdateOld : convertToInMemoryRecord ( perZoneChanges [ zoneID ] . UpdateOld ) , Delete : convertToInMemoryRecord ( perZoneChanges [ zoneID ] . Delete ) , } err := im . client . ApplyChanges ( zoneID , change ) if err != nil { return err } } return nil } 
func ( f * filter ) Zones ( zones map [ string ] string ) map [ string ] string { result := map [ string ] string { } for zoneID , zoneName := range zones { if strings . HasSuffix ( zoneName , f . domain ) { result [ zoneID ] = zoneName } } return result } 
func ( f * filter ) EndpointZoneID ( endpoint * endpoint . Endpoint , zones map [ string ] string ) ( zoneID string ) { var matchZoneID , matchZoneName string for zoneID , zoneName := range zones { if strings . HasSuffix ( endpoint . DNSName , zoneName ) && len ( zoneName ) > len ( matchZoneName ) { matchZoneName = zoneName matchZoneID = zoneID } } return matchZoneID } 
func ( c * inMemoryClient ) validateChangeBatch ( zone string , changes * inMemoryChange ) error { curZone , ok := c . zones [ zone ] if ! ok { return ErrZoneNotFound } mesh := map [ string ] map [ string ] bool { } for _ , newEndpoint := range changes . Create { if c . findByType ( newEndpoint . Type , curZone [ newEndpoint . Name ] ) != nil { return ErrRecordAlreadyExists } if err := c . updateMesh ( mesh , newEndpoint ) ; err != nil { return err } } for _ , updateEndpoint := range changes . UpdateNew { if c . findByType ( updateEndpoint . Type , curZone [ updateEndpoint . Name ] ) == nil { return ErrRecordNotFound } if err := c . updateMesh ( mesh , updateEndpoint ) ; err != nil { return err } } for _ , updateOldEndpoint := range changes . UpdateOld { if rec := c . findByType ( updateOldEndpoint . Type , curZone [ updateOldEndpoint . Name ] ) ; rec == nil || rec . Target != updateOldEndpoint . Target { return ErrRecordNotFound } } for _ , deleteEndpoint := range changes . Delete { if rec := c . findByType ( deleteEndpoint . Type , curZone [ deleteEndpoint . Name ] ) ; rec == nil || rec . Target != deleteEndpoint . Target { return ErrRecordNotFound } if err := c . updateMesh ( mesh , deleteEndpoint ) ; err != nil { return err } } return nil } 
func NewZoneTagFilter ( tags [ ] string ) ZoneTagFilter { if len ( tags ) == 1 && len ( tags [ 0 ] ) == 0 { tags = [ ] string { } } return ZoneTagFilter { zoneTags : tags } } 
func ( f ZoneTagFilter ) Match ( tagsMap map [ string ] string ) bool { for _ , tagFilter := range f . zoneTags { filterParts := strings . SplitN ( tagFilter , " " , 2 ) switch len ( filterParts ) { case 1 : if _ , hasTag := tagsMap [ filterParts [ 0 ] ] ; ! hasTag { return false } case 2 : if value , hasTag := tagsMap [ filterParts [ 0 ] ] ; ! hasTag || value != filterParts [ 1 ] { return false } } } return true } 
func NewIngressSource ( kubeClient kubernetes . Interface , namespace , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , ignoreHostnameAnnotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdnTemplate != " " { tmpl , err = template . New ( " " ) . Funcs ( template . FuncMap { " " : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } ingressInformer := informerFactory . Extensions ( ) . V1beta1 ( ) . Ingresses ( ) } ) if err != nil { return nil , fmt . Errorf ( " " , err ) } sc := & ingressSource { client : kubeClient , namespace : namespace , annotationFilter : annotationFilter , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , ingressInformer : ingressInformer , } return sc , nil } 
func ( sc * ingressSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { ingresses , err := sc . ingressInformer . Lister ( ) . Ingresses ( sc . namespace ) . List ( labels . Everything ( ) ) if err != nil { return nil , err } ingresses , err = sc . filterByAnnotations ( ingresses ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , ing := range ingresses { if ok && controller != controllerAnnotationValue { log . Debugf ( " " , ing . Namespace , ing . Name , controller , controllerAnnotationValue ) continue } ingEndpoints := endpointsFromIngress ( ing , sc . ignoreHostnameAnnotation ) if err != nil { return nil , err } if sc . combineFQDNAnnotation { ingEndpoints = append ( ingEndpoints , iEndpoints ... ) } else { ingEndpoints = iEndpoints } } if len ( ingEndpoints ) == 0 { log . Debugf ( " " , ing . Namespace , ing . Name ) continue } log . Debugf ( " " , ing . Namespace , ing . Name , ingEndpoints ) sc . setResourceLabel ( ing , ingEndpoints ) endpoints = append ( endpoints , ingEndpoints ... ) } for _ , ep := range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * ingressSource ) filterByAnnotations ( ingresses [ ] * v1beta1 . Ingress ) ( [ ] * v1beta1 . Ingress , error ) { labelSelector , err := metav1 . ParseToLabelSelector ( sc . annotationFilter ) if err != nil { return nil , err } selector , err := metav1 . LabelSelectorAsSelector ( labelSelector ) if err != nil { return nil , err } } filteredList := [ ] * v1beta1 . Ingress { } for _ , ingress := range ingresses { } } return filteredList , nil } 
func endpointsFromIngress ( ing * v1beta1 . Ingress , ignoreHostnameAnnotation bool ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint ttl , err := getTTLFromAnnotations ( ing . Annotations ) if err != nil { log . Warn ( err ) } targets := getTargetsFromTargetAnnotation ( ing . Annotations ) if len ( targets ) == 0 { targets = targetsFromIngressStatus ( ing . Status ) } providerSpecific := getProviderSpecificAnnotations ( ing . Annotations ) for _ , rule := range ing . Spec . Rules { if rule . Host == " " { continue } endpoints = append ( endpoints , endpointsForHostname ( rule . Host , targets , ttl , providerSpecific ) ... ) } for _ , tls := range ing . Spec . TLS { for _ , host := range tls . Hosts { if host == " " { continue } endpoints = append ( endpoints , endpointsForHostname ( host , targets , ttl , providerSpecific ) ... ) } } for _ , hostname := range hostnameList { endpoints = append ( endpoints , endpointsForHostname ( hostname , targets , ttl , providerSpecific ) ... ) } } return endpoints } 
func NewLabelsFromString ( labelText string ) ( Labels , error ) { endpointLabels := map [ string ] string { } labelText = strings . Trim ( labelText , " \" " ) // drop quotes tokens := strings . Split ( labelText , " " ) foundExternalDNSHeritage := false for _ , token := range tokens { if len ( strings . Split ( token , " " ) ) != 2 { continue } key := strings . Split ( token , " " ) [ 0 ] val := strings . Split ( token , " " ) [ 1 ] if key == " " && val != heritage { return nil , ErrInvalidHeritage } if key == " " { foundExternalDNSHeritage = true continue } if strings . HasPrefix ( key , heritage ) { endpointLabels [ strings . TrimPrefix ( key , heritage + " " ) ] = val } } if ! foundExternalDNSHeritage { return nil , ErrInvalidHeritage } return endpointLabels , nil } 
func ( l Labels ) Serialize ( withQuotes bool ) string { var tokens [ ] string tokens = append ( tokens , fmt . Sprintf ( " " , heritage ) ) var keys [ ] string for key := range l { keys = append ( keys , key ) } sort . Strings ( keys ) for _ , key := range keys { tokens = append ( tokens , fmt . Sprintf ( " " , heritage , key , l [ key ] ) ) } if withQuotes { return fmt . Sprintf ( " \" \" " , strings . Join ( tokens , " " ) ) } return strings . Join ( tokens , " " ) } 
func ( p * SingletonClientGenerator ) KubeClient ( ) ( kubernetes . Interface , error ) { var err error p . kubeOnce . Do ( func ( ) { p . kubeClient , err = NewKubeClient ( p . KubeConfig , p . KubeMaster , p . RequestTimeout ) } ) return p . kubeClient , err } 
func ( p * SingletonClientGenerator ) IstioClient ( ) ( istiomodel . ConfigStore , error ) { var err error p . istioOnce . Do ( func ( ) { p . istioClient , err = NewIstioClient ( p . KubeConfig ) } ) return p . istioClient , err } 
func ByNames ( p ClientGenerator , names [ ] string , cfg * Config ) ( [ ] Source , error ) { sources := [ ] Source { } for _ , name := range names { source , err := BuildWithConfig ( name , p , cfg ) if err != nil { return nil , err } sources = append ( sources , source ) } return sources , nil } 
func BuildWithConfig ( source string , p ClientGenerator , cfg * Config ) ( Source , error ) { switch source { case " " : client , err := p . KubeClient ( ) if err != nil { return nil , err } return NewServiceSource ( client , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . Compatibility , cfg . PublishInternal , cfg . PublishHostIP , cfg . ServiceTypeFilter , cfg . IgnoreHostnameAnnotation ) case " " : client , err := p . KubeClient ( ) if err != nil { return nil , err } return NewIngressSource ( client , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . IgnoreHostnameAnnotation ) case " " : kubernetesClient , err := p . KubeClient ( ) if err != nil { return nil , err } istioClient , err := p . IstioClient ( ) if err != nil { return nil , err } return NewIstioGatewaySource ( kubernetesClient , istioClient , cfg . IstioIngressGatewayServices , cfg . Namespace , cfg . AnnotationFilter , cfg . FQDNTemplate , cfg . CombineFQDNAndAnnotation , cfg . IgnoreHostnameAnnotation ) case " " : return NewFakeSource ( cfg . FQDNTemplate ) case " " : return NewConnectorSource ( cfg . ConnectorServer ) case " " : client , err := p . KubeClient ( ) if err != nil { return nil , err } crdClient , scheme , err := NewCRDClientForAPIVersionKind ( client , cfg . KubeConfig , cfg . KubeMaster , cfg . CRDSourceAPIVersion , cfg . CRDSourceKind ) if err != nil { return nil , err } return NewCRDSource ( crdClient , cfg . Namespace , cfg . CRDSourceKind , scheme ) } return nil , ErrSourceNotFound } 
func NewKubeClient ( kubeConfig , kubeMaster string , requestTimeout time . Duration ) ( * kubernetes . Clientset , error ) { if kubeConfig == " " { if _ , err := os . Stat ( clientcmd . RecommendedHomeFile ) ; err == nil { kubeConfig = clientcmd . RecommendedHomeFile } } config , err := clientcmd . BuildConfigFromFlags ( kubeMaster , kubeConfig ) if err != nil { return nil , err } config . WrapTransport = func ( rt http . RoundTripper ) http . RoundTripper { return instrumented_http . NewTransport ( rt , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) } config . Timeout = requestTimeout client , err := kubernetes . NewForConfig ( config ) if err != nil { return nil , err } log . Infof ( " " , config . Host ) return client , nil } 
func NewIstioClient ( kubeConfig string ) ( * istiocrd . Client , error ) { if kubeConfig == " " { if _ , err := os . Stat ( clientcmd . RecommendedHomeFile ) ; err == nil { kubeConfig = clientcmd . RecommendedHomeFile } } client , err := istiocrd . NewClient ( kubeConfig , " " , istiomodel . ConfigDescriptor { istiomodel . Gateway } , " " , ) if err != nil { return nil , err } log . Info ( " " ) return client , nil } 
func NewCRDClientForAPIVersionKind ( client kubernetes . Interface , kubeConfig , kubeMaster , apiVersion , kind string ) ( * rest . RESTClient , * runtime . Scheme , error ) { if kubeConfig == " " { if _ , err := os . Stat ( clientcmd . RecommendedHomeFile ) ; err == nil { kubeConfig = clientcmd . RecommendedHomeFile } } config , err := clientcmd . BuildConfigFromFlags ( kubeMaster , kubeConfig ) if err != nil { return nil , nil , err } groupVersion , err := schema . ParseGroupVersion ( apiVersion ) if err != nil { return nil , nil , err } apiResourceList , err := client . Discovery ( ) . ServerResourcesForGroupVersion ( groupVersion . String ( ) ) if err != nil { return nil , nil , fmt . Errorf ( " " , groupVersion . String ( ) , err ) } var crdAPIResource * metav1 . APIResource for _ , apiResource := range apiResourceList . APIResources { if apiResource . Kind == kind { crdAPIResource = & apiResource break } } if crdAPIResource == nil { return nil , nil , fmt . Errorf ( " " , kind , apiVersion ) } scheme := runtime . NewScheme ( ) addKnownTypes ( scheme , groupVersion ) config . ContentConfig . GroupVersion = & groupVersion config . APIPath = " " config . NegotiatedSerializer = serializer . DirectCodecFactory { CodecFactory : serializer . NewCodecFactory ( scheme ) } crdClient , err := rest . UnversionedRESTClientFor ( config ) if err != nil { return nil , nil , err } return crdClient , scheme , nil } 
func NewCRDSource ( crdClient rest . Interface , namespace , kind string , scheme * runtime . Scheme ) ( Source , error ) { return & crdSource { crdResource : strings . ToLower ( kind ) + " " , namespace : namespace , crdClient : crdClient , codec : runtime . NewParameterCodec ( scheme ) , } , nil } 
func ( cs * crdSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints := [ ] * endpoint . Endpoint { } result , err := cs . List ( & metav1 . ListOptions { } ) if err != nil { return nil , err } for _ , dnsEndpoint := range result . Items { endpoints = append ( endpoints , dnsEndpoint . Spec . Endpoints ... ) if dnsEndpoint . Status . ObservedGeneration == dnsEndpoint . Generation { continue } dnsEndpoint . Status . ObservedGeneration = dnsEndpoint . Generation if err != nil { log . Warnf ( " " , err ) } } return endpoints , nil } 
func ( f ZoneTypeFilter ) Match ( zone * route53 . HostedZone ) bool { } } case zoneTypePrivate : return aws . BoolValue ( zone . Config . PrivateZone ) } } 
func filterOwnedRecords ( ownerID string , eps [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { filtered := [ ] * endpoint . Endpoint { } for _ , ep := range eps { if endpointOwner , ok := ep . Labels [ endpoint . OwnerLabelKey ] ; ! ok || endpointOwner != ownerID { log . Debugf ( `Skipping endpoint %v because owner id does not match, found: "%s", required: "%s"` , ep , endpointOwner , ownerID ) continue } filtered = append ( filtered , ep ) } return filtered } 
func NewInfobloxProvider ( infobloxConfig InfobloxConfig ) ( * InfobloxProvider , error ) { hostConfig := ibclient . HostConfig { Host : infobloxConfig . Host , Port : strconv . Itoa ( infobloxConfig . Port ) , Username : infobloxConfig . Username , Password : infobloxConfig . Password , Version : infobloxConfig . Version , } httpPoolConnections := lookupEnvAtoi ( " " , 10 ) httpRequestTimeout := lookupEnvAtoi ( " " , 60 ) transportConfig := ibclient . NewTransportConfig ( strconv . FormatBool ( infobloxConfig . SSLVerify ) , httpRequestTimeout , httpPoolConnections , ) requestBuilder := & ibclient . WapiRequestBuilder { } requestor := & ibclient . WapiHttpRequestor { } client , err := ibclient . NewConnector ( hostConfig , transportConfig , requestBuilder , requestor ) if err != nil { return nil , err } provider := & InfobloxProvider { client : client , domainFilter : infobloxConfig . DomainFilter , zoneIDFilter : infobloxConfig . ZoneIDFilter , dryRun : infobloxConfig . DryRun , view : infobloxConfig . View , } return provider , nil } 
func ( p * InfobloxProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { zones , err := p . zones ( ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , zone := range zones { logrus . Debugf ( " " , zone . Fqdn ) var resA [ ] ibclient . RecordA objA := ibclient . NewRecordA ( ibclient . RecordA { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . GetObject ( objA , " " , & resA ) if err != nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res := range resA { endpoints = append ( endpoints , endpoint . NewEndpoint ( res . Name , endpoint . RecordTypeA , res . Ipv4Addr ) ) } objH := ibclient . NewHostRecord ( ibclient . HostRecord { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . GetObject ( objH , " " , & resH ) if err != nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res := range resH { for _ , ip := range res . Ipv4Addrs { endpoints = append ( endpoints , endpoint . NewEndpoint ( res . Name , endpoint . RecordTypeA , ip . Ipv4Addr ) ) } } var resC [ ] ibclient . RecordCNAME objC := ibclient . NewRecordCNAME ( ibclient . RecordCNAME { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . GetObject ( objC , " " , & resC ) if err != nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res := range resC { endpoints = append ( endpoints , endpoint . NewEndpoint ( res . Name , endpoint . RecordTypeCNAME , res . Canonical ) ) } var resT [ ] ibclient . RecordTXT objT := ibclient . NewRecordTXT ( ibclient . RecordTXT { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . GetObject ( objT , " " , & resT ) if err != nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res := range resT { } endpoints = append ( endpoints , endpoint . NewEndpoint ( res . Name , endpoint . RecordTypeTXT , res . Text ) ) } } logrus . Debugf ( " " , len ( endpoints ) ) return endpoints , nil } 
func ( p * InfobloxProvider ) ApplyChanges ( changes * plan . Changes ) error { zones , err := p . zones ( ) if err != nil { return err } created , deleted := p . mapChanges ( zones , changes ) p . deleteRecords ( deleted ) p . createRecords ( created ) return nil } 
func NewServiceSource ( kubeClient kubernetes . Interface , namespace , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , compatibility string , publishInternal bool , publishHostIP bool , serviceTypeFilter [ ] string , ignoreHostnameAnnotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdnTemplate != " " { tmpl , err = template . New ( " " ) . Funcs ( template . FuncMap { " " : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } serviceInformer := informerFactory . Core ( ) . V1 ( ) . Services ( ) podInformer := informerFactory . Core ( ) . V1 ( ) . Pods ( ) nodeInformer := informerFactory . Core ( ) . V1 ( ) . Nodes ( ) } , } , ) podInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { log . Debug ( " " ) } , } , ) nodeInformer . Informer ( ) . AddEventHandler ( cache . ResourceEventHandlerFuncs { AddFunc : func ( obj interface { } ) { log . Debug ( " " ) } , } , ) } ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , serviceType := range serviceTypeFilter { serviceTypes [ serviceType ] = struct { } { } } return & serviceSource { client : kubeClient , namespace : namespace , annotationFilter : annotationFilter , compatibility : compatibility , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , publishInternal : publishInternal , publishHostIP : publishHostIP , serviceInformer : serviceInformer , podInformer : podInformer , nodeInformer : nodeInformer , serviceTypeFilter : serviceTypes , } , nil } 
func ( sc * serviceSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { services , err := sc . serviceInformer . Lister ( ) . Services ( sc . namespace ) . List ( labels . Everything ( ) ) if err != nil { return nil , err } services , err = sc . filterByAnnotations ( services ) if err != nil { return nil , err } } if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , svc := range services { if ok && controller != controllerAnnotationValue { log . Debugf ( " " , svc . Namespace , svc . Name , controller , controllerAnnotationValue ) continue } svcEndpoints := sc . endpoints ( svc , nodeTargets ) } if err != nil { return nil , err } if sc . combineFQDNAnnotation { svcEndpoints = append ( svcEndpoints , sEndpoints ... ) } else { svcEndpoints = sEndpoints } } if len ( svcEndpoints ) == 0 { log . Debugf ( " " , svc . Namespace , svc . Name ) continue } log . Debugf ( " " , svc . Namespace , svc . Name , svcEndpoints ) sc . setResourceLabel ( svc , svcEndpoints ) endpoints = append ( endpoints , svcEndpoints ... ) } for _ , ep := range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * serviceSource ) endpoints ( svc * v1 . Service , nodeTargets endpoint . Targets ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint hostnameList := getHostnamesFromAnnotations ( svc . Annotations ) for _ , hostname := range hostnameList { endpoints = append ( endpoints , sc . generateEndpoints ( svc , hostname , nodeTargets , providerSpecific ) ... ) } } return endpoints } 
func ( sc * serviceSource ) filterByAnnotations ( services [ ] * v1 . Service ) ( [ ] * v1 . Service , error ) { labelSelector , err := metav1 . ParseToLabelSelector ( sc . annotationFilter ) if err != nil { return nil , err } selector , err := metav1 . LabelSelectorAsSelector ( labelSelector ) if err != nil { return nil , err } } filteredList := [ ] * v1 . Service { } for _ , service := range services { } } return filteredList , nil } 
func ( sc * serviceSource ) filterByServiceType ( services [ ] * v1 . Service ) [ ] * v1 . Service { filteredList := [ ] * v1 . Service { } for _ , service := range services { } } return filteredList } 
func ( t planTable ) getUpdates ( ) ( updateNew [ ] * endpoint . Endpoint , updateOld [ ] * endpoint . Endpoint ) { for _ , row := range t . rows { if row . current != nil && len ( row . candidates ) > 0 { updateNew = append ( updateNew , update ) updateOld = append ( updateOld , row . current ) } continue } } return } 
func ( p * Plan ) Calculate ( ) * Plan { t := newPlanTable ( ) for _ , current := range filterRecordsForPlan ( p . Current ) { t . addCurrent ( current ) } for _ , desired := range filterRecordsForPlan ( p . Desired ) { t . addCandidate ( desired ) } changes := & Changes { } changes . Create = t . getCreates ( ) changes . Delete = t . getDeletes ( ) changes . UpdateNew , changes . UpdateOld = t . getUpdates ( ) for _ , pol := range p . Policies { changes = pol . Apply ( changes ) } plan := & Plan { Current : p . Current , Desired : p . Desired , Changes : changes , } return plan } 
func filterRecordsForPlan ( records [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { filtered := [ ] * endpoint . Endpoint { } for _ , record := range records { default : continue } } return filtered } 
func normalizeDNSName ( dnsName string ) string { s := strings . TrimSpace ( strings . ToLower ( dnsName ) ) if ! strings . HasSuffix ( s , " " ) { s += " " } return s } 
func NewExoscaleProvider ( endpoint , apiKey , apiSecret string , dryRun bool , opts ... ExoscaleOption ) * ExoscaleProvider { client := egoscale . NewClient ( endpoint , apiKey , apiSecret ) return NewExoscaleProviderWithClient ( endpoint , apiKey , apiSecret , client , dryRun , opts ... ) } 
func NewExoscaleProviderWithClient ( endpoint , apiKey , apiSecret string , client EgoscaleClientI , dryRun bool , opts ... ExoscaleOption ) * ExoscaleProvider { ep := & ExoscaleProvider { filter : & zoneFilter { } , OnApplyChanges : func ( changes * plan . Changes ) { } , domain : NewDomainFilter ( [ ] string { " " } ) , client : client , dryRun : dryRun , } for _ , opt := range opts { opt ( ep ) } return ep } 
func ( ep * ExoscaleProvider ) ApplyChanges ( changes * plan . Changes ) error { ep . OnApplyChanges ( changes ) if ep . dryRun { log . Infof ( " " , changes . Delete ) log . Infof ( " " , changes . Create ) log . Infof ( " " , merge ( changes . UpdateOld , changes . UpdateNew ) ) return nil } zones , err := ep . getZones ( ) if err != nil { return err } for _ , epoint := range changes . Create { if ep . domain . Match ( epoint . DNSName ) { if zoneID , name := ep . filter . EndpointZoneID ( epoint , zones ) ; zoneID != 0 { rec := egoscale . DNSRecord { Name : name , RecordType : epoint . RecordType , TTL : int ( epoint . RecordTTL ) , Content : epoint . Targets [ 0 ] , } _ , err := ep . client . CreateRecord ( zones [ zoneID ] , rec ) if err != nil { return err } } } } for _ , epoint := range changes . UpdateNew { if ep . domain . Match ( epoint . DNSName ) { if zoneID , name := ep . filter . EndpointZoneID ( epoint , zones ) ; zoneID != 0 { records , err := ep . client . GetRecords ( zones [ zoneID ] ) if err != nil { return err } for _ , r := range records { if r . Name == name { rec := egoscale . UpdateDNSRecord { ID : r . ID , DomainID : r . DomainID , Name : name , RecordType : epoint . RecordType , TTL : int ( epoint . RecordTTL ) , Content : epoint . Targets [ 0 ] , Prio : r . Prio , } if _ , err := ep . client . UpdateRecord ( zones [ zoneID ] , rec ) ; err != nil { return err } break } } } } } for _ , epoint := range changes . UpdateOld { } for _ , epoint := range changes . Delete { if ep . domain . Match ( epoint . DNSName ) { if zoneID , name := ep . filter . EndpointZoneID ( epoint , zones ) ; zoneID != 0 { records , err := ep . client . GetRecords ( zones [ zoneID ] ) if err != nil { return err } for _ , r := range records { if r . Name == name { if err := ep . client . DeleteRecord ( zones [ zoneID ] , r . ID ) ; err != nil { return err } break } } } } } return nil } 
func ( ep * ExoscaleProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints := make ( [ ] * endpoint . Endpoint , 0 ) domains , err := ep . client . GetDomains ( ) if err != nil { return nil , err } for _ , d := range domains { record , err := ep . client . GetRecords ( d . Name ) if err != nil { return nil , err } for _ , r := range record { switch r . RecordType { case egoscale . A . String ( ) , egoscale . CNAME . String ( ) , egoscale . TXT . String ( ) : break default : continue } ep := endpoint . NewEndpointWithTTL ( r . Name + " " + d . Name , r . RecordType , endpoint . TTL ( r . TTL ) , r . Content ) endpoints = append ( endpoints , ep ) } } log . Infof ( " " , len ( endpoints ) ) return endpoints , nil } 
func ExoscaleWithLogging ( ) ExoscaleOption { return func ( p * ExoscaleProvider ) { p . OnApplyChanges = func ( changes * plan . Changes ) { for _ , v := range changes . Create { log . Infof ( " " , v ) } for _ , v := range changes . UpdateOld { log . Infof ( " " , v ) } for _ , v := range changes . UpdateNew { log . Infof ( " " , v ) } for _ , v := range changes . Delete { log . Infof ( " " , v ) } } } } 
func ( f * zoneFilter ) Zones ( zones map [ int64 ] string ) map [ int64 ] string { result := map [ int64 ] string { } for zoneID , zoneName := range zones { if strings . HasSuffix ( zoneName , f . domain ) { result [ zoneID ] = zoneName } } return result } 
func ( f * zoneFilter ) EndpointZoneID ( endpoint * endpoint . Endpoint , zones map [ int64 ] string ) ( zoneID int64 , name string ) { var matchZoneID int64 var matchZoneName string for zoneID , zoneName := range zones { if strings . HasSuffix ( endpoint . DNSName , " " + zoneName ) && len ( zoneName ) > len ( matchZoneName ) { matchZoneName = zoneName matchZoneID = zoneID name = strings . TrimSuffix ( endpoint . DNSName , " " + zoneName ) } } return matchZoneID , name } 
func NewLinodeProvider ( domainFilter DomainFilter , dryRun bool , appVersion string ) ( * LinodeProvider , error ) { token , ok := os . LookupEnv ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } tokenSource := oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token } ) oauth2Client := & http . Client { Transport : & oauth2 . Transport { Source : tokenSource , } , } linodeClient := linodego . NewClient ( oauth2Client ) linodeClient . SetUserAgent ( fmt . Sprintf ( " " , appVersion , linodego . Version ) ) provider := & LinodeProvider { Client : & linodeClient , domainFilter : domainFilter , DryRun : dryRun , } return provider , nil } 
func ( p * LinodeProvider ) Zones ( ) ( [ ] * linodego . Domain , error ) { zones , err := p . fetchZones ( ) if err != nil { return nil , err } return zones , nil } 
func ( p * LinodeProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone := range zones { records , err := p . fetchRecords ( zone . ID ) if err != nil { return nil , err } for _ , r := range records { if supportedRecordType ( string ( r . Type ) ) { name := fmt . Sprintf ( " " , r . Name , zone . Domain ) } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( name , string ( r . Type ) , endpoint . TTL ( r . TTLSec ) , r . Target ) ) } } } return endpoints , nil } 
func ( p * LinodeProvider ) submitChanges ( changes LinodeChanges ) error { for _ , change := range changes . Creates { logFields := log . Fields { " " : change . Options . Name , " " : change . Options . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { log . WithFields ( logFields ) . Info ( " " ) } else { if _ , err := p . Client . CreateDomainRecord ( context . TODO ( ) , change . Domain . ID , change . Options ) ; err != nil { log . WithFields ( logFields ) . Errorf ( " " , err , ) } } } for _ , change := range changes . Deletes { logFields := log . Fields { " " : change . DomainRecord . Name , " " : change . DomainRecord . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { log . WithFields ( logFields ) . Info ( " " ) } else { if err := p . Client . DeleteDomainRecord ( context . TODO ( ) , change . Domain . ID , change . DomainRecord . ID ) ; err != nil { log . WithFields ( logFields ) . Errorf ( " " , err , ) } } } for _ , change := range changes . Updates { logFields := log . Fields { " " : change . Options . Name , " " : change . Options . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { log . WithFields ( logFields ) . Info ( " " ) } else { if _ , err := p . Client . UpdateDomainRecord ( context . TODO ( ) , change . Domain . ID , change . DomainRecord . ID , change . Options ) ; err != nil { log . WithFields ( logFields ) . Errorf ( " " , err , ) } } } return nil } 
func ( p * LinodeProvider ) ApplyChanges ( changes * plan . Changes ) error { recordsByZoneID := make ( map [ string ] [ ] * linodego . DomainRecord ) zones , err := p . fetchZones ( ) if err != nil { return err } zonesByID := make ( map [ string ] * linodego . Domain ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( strconv . Itoa ( z . ID ) , z . Domain ) zonesByID [ strconv . Itoa ( z . ID ) ] = z } if err != nil { return err } recordsByZoneID [ strconv . Itoa ( zone . ID ) ] = append ( recordsByZoneID [ strconv . Itoa ( zone . ID ) ] , records ... ) } createsByZone := endpointsByZone ( zoneNameIDMapper , changes . Create ) updatesByZone := endpointsByZone ( zoneNameIDMapper , changes . UpdateNew ) deletesByZone := endpointsByZone ( zoneNameIDMapper , changes . Delete ) var linodeCreates [ ] * LinodeChangeCreate var linodeUpdates [ ] * LinodeChangeUpdate var linodeDeletes [ ] * LinodeChangeDelete if len ( creates ) == 0 { log . WithFields ( log . Fields { " " : zoneID , " " : zone . Domain , } ) . Debug ( " " ) continue } records := recordsByZoneID [ zoneID ] for _ , ep := range creates { matchedRecords := getRecordID ( records , zone , ep ) if len ( matchedRecords ) != 0 { log . WithFields ( log . Fields { " " : zoneID , " " : zone . Domain , " " : ep . DNSName , " " : ep . RecordType , } ) . Warn ( " " ) } recordType , err := convertRecordType ( ep . RecordType ) if err != nil { return err } for _ , target := range ep . Targets { linodeCreates = append ( linodeCreates , & LinodeChangeCreate { Domain : zone , Options : linodego . DomainRecordCreateOptions { Target : target , Name : getStrippedRecordName ( zone , ep ) , Type : recordType , Weight : getWeight ( ) , Port : getPort ( ) , Priority : getPriority ( ) , TTLSec : int ( ep . RecordTTL ) , } , } ) } } } if len ( updates ) == 0 { log . WithFields ( log . Fields { " " : zoneID , " " : zone . Domain , } ) . Debug ( " " ) continue } records := recordsByZoneID [ zoneID ] for _ , ep := range updates { matchedRecords := getRecordID ( records , zone , ep ) if len ( matchedRecords ) == 0 { log . WithFields ( log . Fields { " " : zoneID , " " : ep . DNSName , " " : zone . Domain , " " : ep . RecordType , } ) . Warn ( " " ) } recordType , err := convertRecordType ( ep . RecordType ) if err != nil { return err } matchedRecordsByTarget := make ( map [ string ] * linodego . DomainRecord ) for _ , record := range matchedRecords { matchedRecordsByTarget [ record . Target ] = record } for _ , target := range ep . Targets { if record , ok := matchedRecordsByTarget [ target ] ; ok { log . WithFields ( log . Fields { " " : zoneID , " " : ep . DNSName , " " : zone . Domain , " " : ep . RecordType , " " : target , } ) . Warn ( " " ) linodeUpdates = append ( linodeUpdates , & LinodeChangeUpdate { Domain : zone , DomainRecord : record , Options : linodego . DomainRecordUpdateOptions { Target : target , Name : getStrippedRecordName ( zone , ep ) , Type : recordType , Weight : getWeight ( ) , Port : getPort ( ) , Priority : getPriority ( ) , TTLSec : int ( ep . RecordTTL ) , } , } ) delete ( matchedRecordsByTarget , target ) } else { linodeCreates = append ( linodeCreates , & LinodeChangeCreate { Domain : zone , Options : linodego . DomainRecordCreateOptions { Target : target , Name : getStrippedRecordName ( zone , ep ) , Type : recordType , Weight : getWeight ( ) , Port : getPort ( ) , Priority : getPriority ( ) , TTLSec : int ( ep . RecordTTL ) , } , } ) } } linodeDeletes = append ( linodeDeletes , & LinodeChangeDelete { Domain : zone , DomainRecord : record , } ) } } } if len ( deletes ) == 0 { log . WithFields ( log . Fields { " " : zoneID , " " : zone . Domain , } ) . Debug ( " " ) continue } records := recordsByZoneID [ zoneID ] for _ , ep := range deletes { matchedRecords := getRecordID ( records , zone , ep ) if len ( matchedRecords ) == 0 { log . WithFields ( log . Fields { " " : zoneID , " " : ep . DNSName , " " : zone . Domain , " " : ep . RecordType , } ) . Warn ( " " ) } for _ , record := range matchedRecords { linodeDeletes = append ( linodeDeletes , & LinodeChangeDelete { Domain : zone , DomainRecord : record , } ) } } } return p . submitChanges ( LinodeChanges { Creates : linodeCreates , Deletes : linodeDeletes , Updates : linodeUpdates , } ) } 
func NewTargets ( target ... string ) Targets { t := make ( Targets , 0 , len ( target ) ) t = append ( t , target ... ) return t } 
func ( t Targets ) Same ( o Targets ) bool { if len ( t ) != len ( o ) { return false } sort . Stable ( t ) sort . Stable ( o ) for i , e := range t { if e != o [ i ] { return false } } return true } 
func ( t Targets ) IsLess ( o Targets ) bool { if len ( t ) < len ( o ) { return true } if len ( t ) > len ( o ) { return false } sort . Sort ( t ) sort . Sort ( o ) for i , e := range t { if e != o [ i ] { return e < o [ i ] } } return false } 
func NewEndpoint ( dnsName , recordType string , targets ... string ) * Endpoint { return NewEndpointWithTTL ( dnsName , recordType , TTL ( 0 ) , targets ... ) } 
func NewEndpointWithTTL ( dnsName , recordType string , ttl TTL , targets ... string ) * Endpoint { cleanTargets := make ( [ ] string , len ( targets ) ) for idx , target := range targets { cleanTargets [ idx ] = strings . TrimSuffix ( target , " " ) } return & Endpoint { DNSName : strings . TrimSuffix ( dnsName , " " ) , Targets : cleanTargets , RecordType : recordType , Labels : NewLabels ( ) , RecordTTL : ttl , } } 
func ( e * Endpoint ) WithProviderSpecific ( key , value string ) * Endpoint { if e . ProviderSpecific == nil { e . ProviderSpecific = ProviderSpecific { } } e . ProviderSpecific = append ( e . ProviderSpecific , ProviderSpecificProperty { Name : key , Value : value } ) return e } 
func ( e * Endpoint ) GetProviderSpecificProperty ( key string ) ( ProviderSpecificProperty , bool ) { for _ , providerSpecific := range e . ProviderSpecific { if providerSpecific . Name == key { return providerSpecific , true } } return ProviderSpecificProperty { } , false } 
func ( f ZoneIDFilter ) Match ( zoneID string ) bool { } for _ , id := range f . zoneIDs { if strings . HasSuffix ( zoneID , id ) { return true } } return false } 
func ValidateConfig ( cfg * externaldns . Config ) error { } if len ( cfg . Sources ) == 0 { return errors . New ( " " ) } if cfg . Provider == " " { return errors . New ( " " ) } } } } if cfg . InfobloxWapiPassword == " " { return errors . New ( " " ) } } if cfg . Provider == " " { if cfg . DynUsername == " " { return errors . New ( " " ) } if cfg . DynCustomerName == " " { return errors . New ( " " ) } if cfg . DynMinTTLSeconds < 0 { return errors . New ( " " ) } } if cfg . IgnoreHostnameAnnotation && cfg . FQDNTemplate == " " { return errors . New ( " " ) } return nil } 
func ( n NS1DomainService ) CreateRecord ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Create ( r ) } 
func ( n NS1DomainService ) DeleteRecord ( zone string , domain string , t string ) ( * http . Response , error ) { return n . service . Records . Delete ( zone , domain , t ) } 
func ( n NS1DomainService ) UpdateRecord ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Update ( r ) } 
func ( n NS1DomainService ) GetZone ( zone string ) ( * dns . Zone , * http . Response , error ) { return n . service . Zones . Get ( zone ) } 
func ( n NS1DomainService ) ListZones ( ) ( [ ] * dns . Zone , * http . Response , error ) { return n . service . Zones . List ( ) } 
func ( p * NS1Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . zonesFiltered ( ) if err != nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone := range zones { if err != nil { return nil , err } for _ , record := range zoneData . Records { if supportedRecordType ( record . Type ) { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( record . Domain , record . Type , endpoint . TTL ( record . TTL ) , record . ShortAns ... , ) , ) } } } return endpoints , nil } 
func ns1BuildRecord ( zoneName string , change * ns1Change ) * dns . Record { record := dns . NewRecord ( zoneName , change . Endpoint . DNSName , change . Endpoint . RecordType ) for _ , v := range change . Endpoint . Targets { record . AddAnswer ( dns . NewAnswer ( strings . Split ( v , " " ) ) ) } if change . Endpoint . RecordTTL . IsConfigured ( ) { ttl = int ( change . Endpoint . RecordTTL ) } record . TTL = ttl return record } 
func ( p * NS1Provider ) ns1SubmitChanges ( changes [ ] * ns1Change ) error { } zones , err := p . zonesFiltered ( ) if err != nil { return err } for zoneName , changes := range changesByZone { for _ , change := range changes { record := ns1BuildRecord ( zoneName , change ) logFields := log . Fields { " " : record . Domain , " " : record . Type , " " : record . TTL , " " : change . Action , " " : zoneName , } log . WithFields ( logFields ) . Info ( " " ) if p . dryRun { continue } switch change . Action { case ns1Create : _ , err := p . client . CreateRecord ( record ) if err != nil { return err } case ns1Delete : _ , err := p . client . DeleteRecord ( zoneName , record . Domain , record . Type ) if err != nil { return err } case ns1Update : _ , err := p . client . UpdateRecord ( record ) if err != nil { return err } } } } return nil } 
func ( p * NS1Provider ) zonesFiltered ( ) ( [ ] * dns . Zone , error ) { if err != nil { return nil , err } toReturn := [ ] * dns . Zone { } for _ , z := range zones { if p . domainFilter . Match ( z . Zone ) && p . zoneIDFilter . Match ( z . ID ) { toReturn = append ( toReturn , z ) log . Debugf ( " " , z . Zone ) } else { log . Debugf ( " " , z . Zone ) } } return toReturn , nil } 
func ( p * NS1Provider ) ApplyChanges ( changes * plan . Changes ) error { combinedChanges := make ( [ ] * ns1Change , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , newNS1Changes ( ns1Create , changes . Create ) ... ) combinedChanges = append ( combinedChanges , newNS1Changes ( ns1Update , changes . UpdateNew ) ... ) combinedChanges = append ( combinedChanges , newNS1Changes ( ns1Delete , changes . Delete ) ... ) return p . ns1SubmitChanges ( combinedChanges ) } 
func newNS1Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * ns1Change { changes := make ( [ ] * ns1Change , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , & ns1Change { Action : action , Endpoint : endpoint , } , ) } return changes } 
func ns1ChangesByZone ( zones [ ] * dns . Zone , changeSets [ ] * ns1Change ) map [ string ] [ ] * ns1Change { changes := make ( map [ string ] [ ] * ns1Change ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . Zone , z . Zone ) changes [ z . Zone ] = [ ] * ns1Change { } } for _ , c := range changeSets { zone , _ := zoneNameIDMapper . FindZone ( c . Endpoint . DNSName ) if zone == " " { log . Debugf ( " " , c . Endpoint . DNSName ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func allLogLevelsAsStrings ( ) [ ] string { var levels [ ] string for _ , level := range logrus . AllLevels { levels = append ( levels , level . String ( ) ) } return levels } 
func ( cfg * Config ) ParseFlags ( args [ ] string ) error { app := kingpin . New ( " " , " \n \n " ) app . Version ( Version ) app . DefaultEnvars ( ) app . Flag ( " " , " " ) . Default ( defaultConfig . KubeConfig ) . StringVar ( & cfg . KubeConfig ) app . Flag ( " " , " " ) . Default ( defaultConfig . RequestTimeout . String ( ) ) . DurationVar ( & cfg . RequestTimeout ) app . Flag ( " " , " " ) . Default ( defaultConfig . Namespace ) . StringVar ( & cfg . Namespace ) app . Flag ( " " , " " ) . Default ( defaultConfig . AnnotationFilter ) . StringVar ( & cfg . AnnotationFilter ) app . Flag ( " " , " " ) . Default ( defaultConfig . FQDNTemplate ) . StringVar ( & cfg . FQDNTemplate ) app . Flag ( " " , " " ) . BoolVar ( & cfg . CombineFQDNAndAnnotation ) app . Flag ( " " , " " ) . BoolVar ( & cfg . IgnoreHostnameAnnotation ) app . Flag ( " " , " " ) . Default ( defaultConfig . Compatibility ) . EnumVar ( & cfg . Compatibility , " " , " " , " " ) app . Flag ( " " , " " ) . BoolVar ( & cfg . PublishInternal ) app . Flag ( " " , " " ) . BoolVar ( & cfg . PublishHostIP ) app . Flag ( " " , " " ) . Default ( defaultConfig . ConnectorSourceServer ) . StringVar ( & cfg . ConnectorSourceServer ) app . Flag ( " " , " " ) . Default ( defaultConfig . CRDSourceAPIVersion ) . StringVar ( & cfg . CRDSourceAPIVersion ) app . Flag ( " " , " " ) . Default ( defaultConfig . CRDSourceKind ) . StringVar ( & cfg . CRDSourceKind ) app . Flag ( " " , " " ) . StringsVar ( & cfg . ServiceTypeFilter ) app . Flag ( " " , " " ) . Default ( " " ) . StringsVar ( & cfg . DomainFilter ) app . Flag ( " " , " " ) . Default ( " " ) . StringsVar ( & cfg . ZoneIDFilter ) app . Flag ( " " , " " ) . Default ( defaultConfig . GoogleProject ) . StringVar ( & cfg . GoogleProject ) app . Flag ( " " , " " ) . Default ( defaultConfig . AlibabaCloudConfigFile ) . StringVar ( & cfg . AlibabaCloudConfigFile ) app . Flag ( " " , " " ) . Default ( defaultConfig . AlibabaCloudZoneType ) . EnumVar ( & cfg . AlibabaCloudZoneType , " " , " " , " " ) app . Flag ( " " , " " ) . Default ( defaultConfig . AWSZoneType ) . EnumVar ( & cfg . AWSZoneType , " " , " " , " " ) app . Flag ( " " , " " ) . Default ( " " ) . StringsVar ( & cfg . AWSZoneTagFilter ) app . Flag ( " " , " " ) . Default ( defaultConfig . AWSAssumeRole ) . StringVar ( & cfg . AWSAssumeRole ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( defaultConfig . AWSBatchChangeSize ) ) . IntVar ( & cfg . AWSBatchChangeSize ) app . Flag ( " " , " " ) . Default ( defaultConfig . AWSBatchChangeInterval . String ( ) ) . DurationVar ( & cfg . AWSBatchChangeInterval ) app . Flag ( " " , " " ) . Default ( strconv . FormatBool ( defaultConfig . AWSEvaluateTargetHealth ) ) . BoolVar ( & cfg . AWSEvaluateTargetHealth ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( defaultConfig . AWSAPIRetries ) ) . IntVar ( & cfg . AWSAPIRetries ) app . Flag ( " " , " " ) . Default ( defaultConfig . AzureConfigFile ) . StringVar ( & cfg . AzureConfigFile ) app . Flag ( " " , " " ) . Default ( defaultConfig . AzureResourceGroup ) . StringVar ( & cfg . AzureResourceGroup ) app . Flag ( " " , " " ) . BoolVar ( & cfg . CloudflareProxied ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( defaultConfig . CloudflareZonesPerPage ) ) . IntVar ( & cfg . CloudflareZonesPerPage ) app . Flag ( " " , " " ) . Default ( defaultConfig . InfobloxGridHost ) . StringVar ( & cfg . InfobloxGridHost ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( defaultConfig . InfobloxWapiPort ) ) . IntVar ( & cfg . InfobloxWapiPort ) app . Flag ( " " , " " ) . Default ( defaultConfig . InfobloxWapiUsername ) . StringVar ( & cfg . InfobloxWapiUsername ) app . Flag ( " " , " " ) . Default ( defaultConfig . InfobloxWapiPassword ) . StringVar ( & cfg . InfobloxWapiPassword ) app . Flag ( " " , " " ) . Default ( defaultConfig . InfobloxWapiVersion ) . StringVar ( & cfg . InfobloxWapiVersion ) app . Flag ( " " , " " ) . Default ( strconv . FormatBool ( defaultConfig . InfobloxSSLVerify ) ) . BoolVar ( & cfg . InfobloxSSLVerify ) app . Flag ( " " , " \" \" " ) . Default ( defaultConfig . InfobloxView ) . StringVar ( & cfg . InfobloxView ) app . Flag ( " " , " " ) . Default ( " " ) . StringVar ( & cfg . DynCustomerName ) app . Flag ( " " , " " ) . Default ( " " ) . StringVar ( & cfg . DynUsername ) app . Flag ( " " , " " ) . Default ( " " ) . StringVar ( & cfg . DynPassword ) app . Flag ( " " , " " ) . IntVar ( & cfg . DynMinTTLSeconds ) app . Flag ( " " , " " ) . Default ( defaultConfig . OCIConfigFile ) . StringVar ( & cfg . OCIConfigFile ) app . Flag ( " " , " " ) . Default ( strconv . FormatBool ( defaultConfig . RcodezeroTXTEncrypt ) ) . BoolVar ( & cfg . RcodezeroTXTEncrypt ) app . Flag ( " " , " " ) . Default ( " " ) . StringsVar ( & cfg . InMemoryZones ) app . Flag ( " " , " " ) . Default ( defaultConfig . PDNSServer ) . StringVar ( & cfg . PDNSServer ) app . Flag ( " " , " " ) . Default ( defaultConfig . PDNSAPIKey ) . StringVar ( & cfg . PDNSAPIKey ) app . Flag ( " " , " " ) . Default ( strconv . FormatBool ( defaultConfig . PDNSTLSEnabled ) ) . BoolVar ( & cfg . PDNSTLSEnabled ) app . Flag ( " " , " " ) . Default ( defaultConfig . TLSClientCert ) . StringVar ( & cfg . TLSClientCert ) app . Flag ( " " , " " ) . Default ( defaultConfig . TLSClientCertKey ) . StringVar ( & cfg . TLSClientCertKey ) app . Flag ( " " , " " ) . Default ( defaultConfig . ExoscaleEndpoint ) . StringVar ( & cfg . ExoscaleEndpoint ) app . Flag ( " " , " " ) . Default ( defaultConfig . ExoscaleAPIKey ) . StringVar ( & cfg . ExoscaleAPIKey ) app . Flag ( " " , " " ) . Default ( defaultConfig . ExoscaleAPISecret ) . StringVar ( & cfg . ExoscaleAPISecret ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( defaultConfig . RFC2136Port ) ) . IntVar ( & cfg . RFC2136Port ) app . Flag ( " " , " " ) . Default ( defaultConfig . RFC2136Zone ) . StringVar ( & cfg . RFC2136Zone ) app . Flag ( " " , " " ) . Default ( strconv . FormatBool ( defaultConfig . RFC2136Insecure ) ) . BoolVar ( & cfg . RFC2136Insecure ) app . Flag ( " " , " " ) . Default ( defaultConfig . RFC2136TSIGKeyName ) . StringVar ( & cfg . RFC2136TSIGKeyName ) app . Flag ( " " , " " ) . Default ( defaultConfig . RFC2136TSIGSecret ) . StringVar ( & cfg . RFC2136TSIGSecret ) app . Flag ( " " , " " ) . Default ( defaultConfig . RFC2136TSIGSecretAlg ) . StringVar ( & cfg . RFC2136TSIGSecretAlg ) app . Flag ( " " , " " ) . BoolVar ( & cfg . RFC2136TAXFR ) app . Flag ( " " , " " ) . Default ( defaultConfig . TXTOwnerID ) . StringVar ( & cfg . TXTOwnerID ) app . Flag ( " " , " " ) . Default ( defaultConfig . TXTPrefix ) . StringVar ( & cfg . TXTPrefix ) app . Flag ( " " , " " ) . Default ( defaultConfig . Interval . String ( ) ) . DurationVar ( & cfg . Interval ) app . Flag ( " " , " " ) . BoolVar ( & cfg . Once ) app . Flag ( " " , " " ) . BoolVar ( & cfg . DryRun ) app . Flag ( " " , " " ) . Default ( defaultConfig . MetricsAddress ) . StringVar ( & cfg . MetricsAddress ) app . Flag ( " " , " " ) . Default ( defaultConfig . LogLevel ) . EnumVar ( & cfg . LogLevel , allLogLevelsAsStrings ( ) ... ) _ , err := app . Parse ( args ) if err != nil { return err } return nil } 
func ( p * UpsertOnlyPolicy ) Apply ( changes * Changes ) * Changes { return & Changes { Create : changes . Create , UpdateOld : changes . UpdateOld , UpdateNew : changes . UpdateNew , } } 
func ( c * Controller ) RunOnce ( ) error { records , err := c . Registry . Records ( ) if err != nil { registryErrors . Inc ( ) return err } registryEndpointsTotal . Set ( float64 ( len ( records ) ) ) endpoints , err := c . Source . Endpoints ( ) if err != nil { sourceErrors . Inc ( ) return err } sourceEndpointsTotal . Set ( float64 ( len ( endpoints ) ) ) plan := & plan . Plan { Policies : [ ] plan . Policy { c . Policy } , Current : records , Desired : endpoints , } plan = plan . Calculate ( ) err = c . Registry . ApplyChanges ( plan . Changes ) if err != nil { registryErrors . Inc ( ) return err } return nil } 
func ( c * Controller ) Run ( stopChan <- chan struct { } ) { ticker := time . NewTicker ( c . Interval ) defer ticker . Stop ( ) for { err := c . RunOnce ( ) if err != nil { log . Error ( err ) } select { case <- ticker . C : case <- stopChan : log . Info ( " " ) return } } } 
func NewCloudFlareProvider ( domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , zonesPerPage int , proxiedByDefault bool , dryRun bool ) ( * CloudFlareProvider , error ) { if err != nil { return nil , fmt . Errorf ( " " , err ) } provider := & CloudFlareProvider { return provider , nil } 
func ( p * CloudFlareProvider ) Zones ( ) ( [ ] cloudflare . Zone , error ) { result := [ ] cloudflare . Zone { } ctx := context . TODO ( ) p . PaginationOptions . Page = 1 for { zonesResponse , err := p . Client . ListZonesContext ( ctx , cloudflare . WithPagination ( p . PaginationOptions ) ) if err != nil { return nil , err } for _ , zone := range zonesResponse . Result { if ! p . domainFilter . Match ( zone . Name ) { continue } if ! p . zoneIDFilter . Match ( zone . ID ) { continue } result = append ( result , zone ) } if p . PaginationOptions . Page == zonesResponse . ResultInfo . TotalPages { break } p . PaginationOptions . Page ++ } return result , nil } 
func ( p * CloudFlareProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , zone := range zones { records , err := p . Client . DNSRecords ( zone . ID , cloudflare . DNSRecord { } ) if err != nil { return nil , err } for _ , r := range records { if supportedRecordType ( r . Type ) { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , r . Content ) . WithProviderSpecific ( source . CloudflareProxiedKey , strconv . FormatBool ( r . Proxied ) ) ) } } } return endpoints , nil } 
func ( p * CloudFlareProvider ) ApplyChanges ( changes * plan . Changes ) error { proxiedByDefault := p . proxiedByDefault combinedChanges := make ( [ ] * cloudFlareChange , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , newCloudFlareChanges ( cloudFlareCreate , changes . Create , proxiedByDefault ) ... ) combinedChanges = append ( combinedChanges , newCloudFlareChanges ( cloudFlareUpdate , changes . UpdateNew , proxiedByDefault ) ... ) combinedChanges = append ( combinedChanges , newCloudFlareChanges ( cloudFlareDelete , changes . Delete , proxiedByDefault ) ... ) return p . submitChanges ( combinedChanges ) } 
func ( p * CloudFlareProvider ) submitChanges ( changes [ ] * cloudFlareChange ) error { } zones , err := p . Zones ( ) if err != nil { return err } for zoneID , changes := range changesByZone { records , err := p . Client . DNSRecords ( zoneID , cloudflare . DNSRecord { } ) if err != nil { return fmt . Errorf ( " " , err ) } for _ , change := range changes { logFields := log . Fields { " " : change . ResourceRecordSet [ 0 ] . Name , " " : change . ResourceRecordSet [ 0 ] . Type , " " : change . ResourceRecordSet [ 0 ] . TTL , " " : len ( change . ResourceRecordSet ) , " " : change . Action , " " : zoneID , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { continue } recordIDs := p . getRecordIDs ( records , change . ResourceRecordSet [ 0 ] ) if err != nil { log . WithFields ( logFields ) . Errorf ( " " , err ) } } } if change . Action == cloudFlareCreate || change . Action == cloudFlareUpdate { for _ , record := range change . ResourceRecordSet { _ , err := p . Client . CreateDNSRecord ( zoneID , record ) if err != nil { log . WithFields ( logFields ) . Errorf ( " " , err ) } } } } } return nil } 
func ( p * CloudFlareProvider ) changesByZone ( zones [ ] cloudflare . Zone , changeSet [ ] * cloudFlareChange ) map [ string ] [ ] * cloudFlareChange { changes := make ( map [ string ] [ ] * cloudFlareChange ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . ID , z . Name ) changes [ z . ID ] = [ ] * cloudFlareChange { } } for _ , c := range changeSet { zoneID , _ := zoneNameIDMapper . FindZone ( c . ResourceRecordSet [ 0 ] . Name ) if zoneID == " " { log . Debugf ( " " , c . ResourceRecordSet [ 0 ] . Name ) continue } changes [ zoneID ] = append ( changes [ zoneID ] , c ) } return changes } 
func newCloudFlareChanges ( action string , endpoints [ ] * endpoint . Endpoint , proxiedByDefault bool ) [ ] * cloudFlareChange { changes := make ( [ ] * cloudFlareChange , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , newCloudFlareChange ( action , endpoint , proxiedByDefault ) ) } return changes } 
func ( p * dnsimpleProvider ) GetAccountID ( credentials dnsimple . Credentials , client dnsimple . Client ) ( accountID string , err error ) { if err != nil { return " " , err } return strconv . Itoa ( whoamiResponse . Data . Account . ID ) , nil } 
func NewDnsimpleProvider ( domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( Provider , error ) { oauthToken := os . Getenv ( " " ) if len ( oauthToken ) == 0 { return nil , fmt . Errorf ( " " ) } client := dnsimple . NewClient ( dnsimple . NewOauthTokenCredentials ( oauthToken ) ) provider := & dnsimpleProvider { client : dnsimpleZoneService { service : client . Zones } , identity : identityService { service : client . Identity } , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , } whoamiResponse , err := provider . identity . service . Whoami ( ) if err != nil { return nil , err } provider . accountID = strconv . Itoa ( whoamiResponse . Data . Account . ID ) return provider , nil } 
func ( p * dnsimpleProvider ) Zones ( ) ( map [ string ] dnsimple . Zone , error ) { zones := make ( map [ string ] dnsimple . Zone ) page := 1 listOptions := & dnsimple . ZoneListOptions { } for { listOptions . Page = page zonesResponse , err := p . client . ListZones ( p . accountID , listOptions ) if err != nil { return nil , err } for _ , zone := range zonesResponse . Data { if ! p . domainFilter . Match ( zone . Name ) { continue } if ! p . zoneIDFilter . Match ( strconv . Itoa ( zone . ID ) ) { continue } zones [ strconv . Itoa ( zone . ID ) ] = zone } page ++ if page > zonesResponse . Pagination . TotalPages { break } } return zones , nil } 
func ( p * dnsimpleProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } for _ , zone := range zones { page := 1 listOptions := & dnsimple . ZoneRecordListOptions { } for { listOptions . Page = page records , err := p . client . ListRecords ( p . accountID , zone . Name , listOptions ) if err != nil { return nil , err } for _ , record := range records . Data { switch record . Type { case " " , " " , " " : break default : continue } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( record . Name + " " + record . ZoneID , record . Type , endpoint . TTL ( record . TTL ) , record . Content ) ) } page ++ if page > records . Pagination . TotalPages { break } } } return endpoints , nil } 
func newDnsimpleChange ( action string , e * endpoint . Endpoint ) * dnsimpleChange { ttl := dnsimpleRecordTTL if e . RecordTTL . IsConfigured ( ) { ttl = int ( e . RecordTTL ) } change := & dnsimpleChange { Action : action , ResourceRecordSet : dnsimple . ZoneRecord { Name : e . DNSName , Type : e . RecordType , Content : e . Targets [ 0 ] , TTL : ttl , } , } return change } 
func newDnsimpleChanges ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * dnsimpleChange { changes := make ( [ ] * dnsimpleChange , 0 , len ( endpoints ) ) for _ , e := range endpoints { changes = append ( changes , newDnsimpleChange ( action , e ) ) } return changes } 
func ( p * dnsimpleProvider ) submitChanges ( changes [ ] * dnsimpleChange ) error { if len ( changes ) == 0 { log . Infof ( " " ) return nil } zones , err := p . Zones ( ) if err != nil { return err } for _ , change := range changes { zone := dnsimpleSuitableZone ( change . ResourceRecordSet . Name , zones ) if zone == nil { log . Debugf ( " " , change . ResourceRecordSet . Name ) continue } log . Infof ( " " , change . Action , change . ResourceRecordSet , zone . Name ) change . ResourceRecordSet . Name = strings . TrimSuffix ( change . ResourceRecordSet . Name , " " + zone . Name ) if ! p . dryRun { switch change . Action { case dnsimpleCreate : _ , err := p . client . CreateRecord ( p . accountID , zone . Name , change . ResourceRecordSet ) if err != nil { return err } case dnsimpleDelete : recordID , err := p . GetRecordID ( zone . Name , change . ResourceRecordSet . Name ) if err != nil { return err } _ , err = p . client . DeleteRecord ( p . accountID , zone . Name , recordID ) if err != nil { return err } case dnsimpleUpdate : recordID , err := p . GetRecordID ( zone . Name , change . ResourceRecordSet . Name ) if err != nil { return err } _ , err = p . client . UpdateRecord ( p . accountID , zone . Name , recordID , change . ResourceRecordSet ) if err != nil { return err } } } } return nil } 
func ( p * dnsimpleProvider ) GetRecordID ( zone string , recordName string ) ( recordID int , err error ) { page := 1 listOptions := & dnsimple . ZoneRecordListOptions { Name : recordName } for { listOptions . Page = page records , err := p . client . ListRecords ( p . accountID , zone , listOptions ) if err != nil { return 0 , err } for _ , record := range records . Data { if record . Name == recordName { return record . ID , nil } } page ++ if page > records . Pagination . TotalPages { break } } return 0 , fmt . Errorf ( " " ) } 
func dnsimpleSuitableZone ( hostname string , zones map [ string ] dnsimple . Zone ) * dnsimple . Zone { var zone * dnsimple . Zone for _ , z := range zones { if strings . HasSuffix ( hostname , z . Name ) { if zone == nil || len ( z . Name ) > len ( zone . Name ) { newZ := z zone = & newZ } } } return zone } 
func ( p * dnsimpleProvider ) CreateRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . submitChanges ( newDnsimpleChanges ( dnsimpleCreate , endpoints ) ) } 
func ( p * dnsimpleProvider ) DeleteRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . submitChanges ( newDnsimpleChanges ( dnsimpleDelete , endpoints ) ) } 
func ( p * dnsimpleProvider ) UpdateRecords ( endpoints [ ] * endpoint . Endpoint ) error { return p . submitChanges ( newDnsimpleChanges ( dnsimpleUpdate , endpoints ) ) } 
func ( p * dnsimpleProvider ) ApplyChanges ( changes * plan . Changes ) error { combinedChanges := make ( [ ] * dnsimpleChange , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleCreate , changes . Create ) ... ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleUpdate , changes . UpdateNew ) ... ) combinedChanges = append ( combinedChanges , newDnsimpleChanges ( dnsimpleDelete , changes . Delete ) ... ) return p . submitChanges ( combinedChanges ) } 
func NewGoogleProvider ( project string , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( * GoogleProvider , error ) { gcloud , err := google . DefaultClient ( context . TODO ( ) , dns . NdevClouddnsReadwriteScope ) if err != nil { return nil , err } gcloud = instrumented_http . NewClient ( gcloud , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) dnsClient , err := dns . New ( gcloud ) if err != nil { return nil , err } if project == " " { mProject , mErr := metadata . ProjectID ( ) if mErr == nil { log . Infof ( " " , mProject ) project = mProject } } provider := & GoogleProvider { project : project , dryRun : dryRun , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , resourceRecordSetsClient : resourceRecordSetsService { dnsClient . ResourceRecordSets } , managedZonesClient : managedZonesService { dnsClient . ManagedZones } , changesClient : changesService { dnsClient . Changes } , } return provider , nil } 
func ( p * GoogleProvider ) Zones ( ) ( map [ string ] * dns . ManagedZone , error ) { zones := make ( map [ string ] * dns . ManagedZone ) f := func ( resp * dns . ManagedZonesListResponse ) error { for _ , zone := range resp . ManagedZones { if p . domainFilter . Match ( zone . DnsName ) && p . zoneIDFilter . Match ( fmt . Sprintf ( " " , zone . Id ) ) { zones [ zone . Name ] = zone log . Debugf ( " " , zone . DnsName , zone . Name ) } else { log . Debugf ( " " , zone . DnsName , zone . Name ) } } return nil } log . Debugf ( " " , p . domainFilter . filters ) if err := p . managedZonesClient . List ( p . project ) . Pages ( context . TODO ( ) , f ) ; err != nil { return nil , err } if len ( zones ) == 0 { if p . domainFilter . IsConfigured ( ) { log . Warnf ( " " , p . project , p . domainFilter . filters ) } else { log . Warnf ( " " , p . project ) } } for _ , zone := range zones { log . Debugf ( " " , zone . Name , zone . DnsName ) } return zones , nil } 
func ( p * GoogleProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } f := func ( resp * dns . ResourceRecordSetsListResponse ) error { for _ , r := range resp . Rrsets { if ! supportedRecordType ( r . Type ) { continue } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . Ttl ) , r . Rrdatas ... ) ) } return nil } for _ , z := range zones { if err := p . resourceRecordSetsClient . List ( p . project , z . Name ) . Pages ( context . TODO ( ) , f ) ; err != nil { return nil , err } } return endpoints , nil } 
func ( p * GoogleProvider ) CreateRecords ( endpoints [ ] * endpoint . Endpoint ) error { change := & dns . Change { } change . Additions = append ( change . Additions , p . newFilteredRecords ( endpoints ) ... ) return p . submitChange ( change ) } 
func ( p * GoogleProvider ) UpdateRecords ( records , oldRecords [ ] * endpoint . Endpoint ) error { change := & dns . Change { } change . Additions = append ( change . Additions , p . newFilteredRecords ( records ) ... ) change . Deletions = append ( change . Deletions , p . newFilteredRecords ( oldRecords ) ... ) return p . submitChange ( change ) } 
func ( p * GoogleProvider ) DeleteRecords ( endpoints [ ] * endpoint . Endpoint ) error { change := & dns . Change { } change . Deletions = append ( change . Deletions , p . newFilteredRecords ( endpoints ) ... ) return p . submitChange ( change ) } 
func ( p * GoogleProvider ) ApplyChanges ( changes * plan . Changes ) error { change := & dns . Change { } change . Additions = append ( change . Additions , p . newFilteredRecords ( changes . Create ) ... ) change . Additions = append ( change . Additions , p . newFilteredRecords ( changes . UpdateNew ) ... ) change . Deletions = append ( change . Deletions , p . newFilteredRecords ( changes . UpdateOld ) ... ) change . Deletions = append ( change . Deletions , p . newFilteredRecords ( changes . Delete ) ... ) return p . submitChange ( change ) } 
func ( p * GoogleProvider ) newFilteredRecords ( endpoints [ ] * endpoint . Endpoint ) [ ] * dns . ResourceRecordSet { records := [ ] * dns . ResourceRecordSet { } for _ , endpoint := range endpoints { if p . domainFilter . Match ( endpoint . DNSName ) { records = append ( records , newRecord ( endpoint ) ) } } return records } 
func ( p * GoogleProvider ) submitChange ( change * dns . Change ) error { if len ( change . Additions ) == 0 && len ( change . Deletions ) == 0 { log . Info ( " " ) return nil } zones , err := p . Zones ( ) if err != nil { return err } for z , c := range changes { log . Infof ( " " , z ) for _ , del := range c . Deletions { log . Infof ( " " , del . Name , del . Type , del . Rrdatas , del . Ttl ) } for _ , add := range c . Additions { log . Infof ( " " , add . Name , add . Type , add . Rrdatas , add . Ttl ) } } if p . dryRun { return nil } for z , c := range changes { if _ , err := p . changesClient . Create ( p . project , z , c ) . Do ( ) ; err != nil { return err } } return nil } 
func separateChange ( zones map [ string ] * dns . ManagedZone , change * dns . Change ) map [ string ] * dns . Change { changes := make ( map [ string ] * dns . Change ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper [ z . Name ] = z . DnsName changes [ z . Name ] = & dns . Change { Additions : [ ] * dns . ResourceRecordSet { } , Deletions : [ ] * dns . ResourceRecordSet { } , } } for _ , a := range change . Additions { if zoneName , _ := zoneNameIDMapper . FindZone ( ensureTrailingDot ( a . Name ) ) ; zoneName != " " { changes [ zoneName ] . Additions = append ( changes [ zoneName ] . Additions , a ) } else { log . Warnf ( " " , a . Name , a . Type , a . Rrdatas , a . Ttl ) } } for _ , d := range change . Deletions { if zoneName , _ := zoneNameIDMapper . FindZone ( ensureTrailingDot ( d . Name ) ) ; zoneName != " " { changes [ zoneName ] . Deletions = append ( changes [ zoneName ] . Deletions , d ) } else { log . Warnf ( " " , d . Name , d . Type , d . Rrdatas , d . Ttl ) } } } } return changes } 
func newRecord ( ep * endpoint . Endpoint ) * dns . ResourceRecordSet { copy ( targets , [ ] string ( ep . Targets ) ) if ep . RecordType == endpoint . RecordTypeCNAME { targets [ 0 ] = ensureTrailingDot ( targets [ 0 ] ) } if ep . RecordTTL . IsConfigured ( ) { ttl = int64 ( ep . RecordTTL ) } return & dns . ResourceRecordSet { Name : ensureTrailingDot ( ep . DNSName ) , Rrdatas : targets , Ttl : ttl , Type : ep . RecordType , } } 
func NewRcodeZeroProvider ( domainFilter DomainFilter , dryRun bool , txtEnc bool ) ( * RcodeZeroProvider , error ) { client , err := rc0 . NewClient ( os . Getenv ( " " ) ) if err != nil { return nil , err } value := os . Getenv ( " " ) if len ( value ) != 0 { client . BaseURL , err = url . Parse ( os . Getenv ( " " ) ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } provider := & RcodeZeroProvider { Client : client , DomainFilter : domainFilter , DryRun : dryRun , TXTEncrypt : txtEnc , } if txtEnc { provider . Key = [ ] byte ( os . Getenv ( " " ) ) } return provider , nil } 
func ( p * RcodeZeroProvider ) Zones ( ) ( [ ] * rc0 . Zone , error ) { var result [ ] * rc0 . Zone zones , err := p . fetchZones ( ) if err != nil { return nil , err } for _ , zone := range zones { if p . DomainFilter . Match ( zone . Domain ) { result = append ( result , zone ) } } return result , nil } 
func ( p * RcodeZeroProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone := range zones { rrset , err := p . fetchRecords ( zone . Domain ) if err != nil { return nil , err } for _ , r := range rrset { if supportedRecordType ( r . Type ) { if p . TXTEncrypt && ( p . Key != nil ) && strings . EqualFold ( r . Type , " " ) { p . Client . RRSet . DecryptTXT ( p . Key , r ) } if len ( r . Records ) > 1 { for _ , _r := range r . Records { if ! _r . Disabled { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , _r . Content ) ) } } } else { if ! r . Records [ 0 ] . Disabled { endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , r . Records [ 0 ] . Content ) ) } } } } } return endpoints , nil } 
func ( p * RcodeZeroProvider ) ApplyChanges ( changes * plan . Changes ) error { combinedChanges := make ( [ ] * rc0 . RRSetChange , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , p . NewRcodezeroChanges ( rc0 . ChangeTypeADD , changes . Create ) ... ) combinedChanges = append ( combinedChanges , p . NewRcodezeroChanges ( rc0 . ChangeTypeUPDATE , changes . UpdateNew ) ... ) combinedChanges = append ( combinedChanges , p . NewRcodezeroChanges ( rc0 . ChangeTypeDELETE , changes . Delete ) ... ) return p . submitChanges ( combinedChanges ) } 
func rcodezeroChangesByZone ( zones [ ] * rc0 . Zone , changeSet [ ] * rc0 . RRSetChange ) map [ string ] [ ] * rc0 . RRSetChange { changes := make ( map [ string ] [ ] * rc0 . RRSetChange ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . Domain , z . Domain ) changes [ z . Domain ] = [ ] * rc0 . RRSetChange { } } for _ , c := range changeSet { zone , _ := zoneNameIDMapper . FindZone ( c . Name ) if zone == " " { log . Debugf ( " " , c . Name ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func ( p * RcodeZeroProvider ) fetchRecords ( zoneName string ) ( [ ] * rc0 . RRType , error ) { var allRecords [ ] * rc0 . RRType listOptions := rc0 . NewListOptions ( ) for { records , page , err := p . Client . RRSet . List ( zoneName , listOptions ) if err != nil { return nil , err } allRecords = append ( allRecords , records ... ) if page == nil || ( page . CurrentPage == page . LastPage ) { break } listOptions . SetPageNumber ( page . CurrentPage + 1 ) } return allRecords , nil } 
func ( p * RcodeZeroProvider ) fetchZones ( ) ( [ ] * rc0 . Zone , error ) { var allZones [ ] * rc0 . Zone listOptions := rc0 . NewListOptions ( ) for { zones , page , err := p . Client . Zones . List ( listOptions ) if err != nil { return nil , err } allZones = append ( allZones , zones ... ) if page == nil || page . IsLastPage ( ) { break } listOptions . SetPageNumber ( page . CurrentPage + 1 ) } return allZones , nil } 
func ( p * RcodeZeroProvider ) submitChanges ( changes [ ] * rc0 . RRSetChange ) error { if len ( changes ) == 0 { return nil } zones , err := p . Zones ( ) if err != nil { return err } for zoneName , changes := range changesByZone { for _ , change := range changes { logFields := log . Fields { " " : change . Name , " " : change . Records [ 0 ] . Content , " " : change . Type , " " : change . ChangeType , " " : zoneName , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { continue } switch change . ChangeType { case rc0 . ChangeTypeADD : sr , err := p . Client . RRSet . Create ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( " " , sr . Message ) } case rc0 . ChangeTypeUPDATE : sr , err := p . Client . RRSet . Edit ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( " " , sr . Message ) } case rc0 . ChangeTypeDELETE : sr , err := p . Client . RRSet . Delete ( zoneName , [ ] * rc0 . RRSetChange { change } ) if err != nil { return err } if sr . HasError ( ) { return fmt . Errorf ( " " , sr . Message ) } default : return fmt . Errorf ( " " , change . ChangeType ) } } } return nil } 
func ( p * RcodeZeroProvider ) NewRcodezeroChanges ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * rc0 . RRSetChange { changes := make ( [ ] * rc0 . RRSetChange , 0 , len ( endpoints ) ) for _ , _endpoint := range endpoints { changes = append ( changes , p . NewRcodezeroChange ( action , _endpoint ) ) } return changes } 
func ( p * RcodeZeroProvider ) NewRcodezeroChange ( action string , endpoint * endpoint . Endpoint ) * rc0 . RRSetChange { change := & rc0 . RRSetChange { Type : endpoint . RecordType , ChangeType : action , Name : endpoint . DNSName , Records : [ ] * rc0 . Record { { Disabled : false , Content : endpoint . Targets [ 0 ] , } } , } if p . TXTEncrypt && ( p . Key != nil ) && strings . EqualFold ( endpoint . RecordType , " " ) { p . Client . RRSet . EncryptTXT ( p . Key , change ) } return change } 
func NewAlibabaCloudProvider ( configFile string , domainFilter DomainFilter , zoneIDFileter ZoneIDFilter , zoneType string , dryRun bool ) ( * AlibabaCloudProvider , error ) { cfg := alibabaCloudConfig { } if configFile != " " { contents , err := ioutil . ReadFile ( configFile ) if err != nil { return nil , fmt . Errorf ( " " , configFile , err ) } err = yaml . Unmarshal ( contents , & cfg ) if err != nil { return nil , fmt . Errorf ( " " , configFile , err ) } } else { var tmpError error cfg , tmpError = getCloudConfigFromStsToken ( ) if tmpError != nil { return nil , fmt . Errorf ( " " , tmpError ) } } var err error if cfg . RoleName == " " { dnsClient , err = alidns . NewClientWithAccessKey ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , ) } else { dnsClient , err = alidns . NewClientWithStsToken ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , cfg . StsToken , ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } if cfg . RoleName == " " { pvtzClient , err = pvtz . NewClientWithAccessKey ( " " , } else { pvtzClient , err = pvtz . NewClientWithStsToken ( cfg . RegionID , cfg . AccessKeyID , cfg . AccessKeySecret , cfg . StsToken , ) } if err != nil { return nil , err } provider := & AlibabaCloudProvider { domainFilter : domainFilter , zoneIDFilter : zoneIDFileter , vpcID : cfg . VPCID , dryRun : dryRun , dnsClient : dnsClient , pvtzClient : pvtzClient , privateZone : zoneType == " " , } if cfg . RoleName != " " { provider . setNextExpire ( cfg . ExpireTime ) go provider . refreshStsToken ( 1 * time . Second ) } return provider , nil } 
func ( p * AlibabaCloudProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { if p . privateZone { endpoints , err = p . privateZoneRecords ( ) } else { endpoints , err = p . recordsForDNS ( ) } return endpoints , err } 
func ( p * AlibabaCloudProvider ) ApplyChanges ( changes * plan . Changes ) error { if changes == nil || len ( changes . Create ) + len ( changes . Delete ) + len ( changes . UpdateNew ) == 0 { } if p . privateZone { return p . applyChangesForPrivateZone ( changes ) } return p . applyChangesForDNS ( changes ) } 
func ( p * AlibabaCloudProvider ) recordsForDNS ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { records , err := p . records ( ) if err != nil { return nil , err } for _ , recordList := range p . groupRecords ( records ) { name := p . getDNSName ( recordList [ 0 ] . RR , recordList [ 0 ] . DomainName ) recordType := recordList [ 0 ] . Type ttl := recordList [ 0 ] . TTL if ttl == defaultAlibabaCloudRecordTTL { ttl = 0 } var targets [ ] string for _ , record := range recordList { target := record . Value if recordType == " " { target = p . unescapeTXTRecordValue ( target ) } targets = append ( targets , target ) } ep := endpoint . NewEndpointWithTTL ( name , recordType , endpoint . TTL ( ttl ) , targets ... ) endpoints = append ( endpoints , ep ) } return endpoints , nil } 
func ( p * AlibabaCloudProvider ) privateZoneRecords ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . getPrivateZones ( ) if err != nil { return nil , err } for _ , zone := range zones { recordMap := p . groupPrivateZoneRecords ( zone ) for _ , recordList := range recordMap { name := p . getDNSName ( recordList [ 0 ] . Rr , zone . ZoneName ) recordType := recordList [ 0 ] . Type ttl := recordList [ 0 ] . Ttl if ttl == defaultAlibabaCloudPrivateZoneRecordTTL { ttl = 0 } var targets [ ] string for _ , record := range recordList { target := record . Value if recordType == " " { target = p . unescapeTXTRecordValue ( target ) } targets = append ( targets , target ) } ep := endpoint . NewEndpointWithTTL ( name , recordType , endpoint . TTL ( ttl ) , targets ... ) endpoints = append ( endpoints , ep ) } } return endpoints , nil } 
func ( p * AlibabaCloudProvider ) applyChangesForPrivateZone ( changes * plan . Changes ) error { log . Infof ( " " , * changes ) zones , err := p . getPrivateZones ( ) if err != nil { return err } for zoneName , zone := range zones { log . Debugf ( " " , zoneName , zone ) } p . createPrivateZoneRecords ( zones , changes . Create ) p . deletePrivateZoneRecords ( zones , changes . Delete ) p . updatePrivateZoneRecords ( zones , changes . UpdateNew ) return nil } 
func ( c etcdClient ) GetServices ( prefix string ) ( [ ] * Service , error ) { ctx , cancel := context . WithTimeout ( c . ctx , etcdTimeout ) defer cancel ( ) path := prefix r , err := c . client . Get ( ctx , path , etcdcv3 . WithPrefix ( ) ) if err != nil { return nil , err } var svcs [ ] * Service bx := make ( map [ Service ] bool ) for _ , n := range r . Kvs { svc := new ( Service ) if err := json . Unmarshal ( n . Value , svc ) ; err != nil { return nil , fmt . Errorf ( " " , n . Key , err . Error ( ) ) } b := Service { Host : svc . Host , Port : svc . Port , Priority : svc . Priority , Weight : svc . Weight , Text : svc . Text , Key : string ( n . Key ) } if _ , ok := bx [ b ] ; ok { } bx [ b ] = true svc . Key = string ( n . Key ) if svc . Priority == 0 { svc . Priority = priority } svcs = append ( svcs , svc ) } return svcs , nil } 
func ( c etcdClient ) SaveService ( service * Service ) error { ctx , cancel := context . WithTimeout ( c . ctx , etcdTimeout ) defer cancel ( ) value , err := json . Marshal ( & service ) if err != nil { return err } _ , err = c . client . Put ( ctx , service . Key , string ( value ) ) if err != nil { return err } return nil } 
func ( c etcdClient ) DeleteService ( key string ) error { ctx , cancel := context . WithTimeout ( c . ctx , etcdTimeout ) defer cancel ( ) _ , err := c . client . Delete ( ctx , key , etcdcv3 . WithPrefix ( ) ) return err } 
func newTLSConfig ( certPath , keyPath , caPath , serverName string , insecure bool ) ( * tls . Config , error ) { if certPath != " " && keyPath == " " || certPath == " " && keyPath != " " { return nil , errors . New ( " " ) } var certificates [ ] tls . Certificate if certPath != " " { cert , err := tls . LoadX509KeyPair ( certPath , keyPath ) if err != nil { return nil , fmt . Errorf ( " " , err ) } certificates = append ( certificates , cert ) } roots , err := loadRoots ( caPath ) if err != nil { return nil , err } return & tls . Config { Certificates : certificates , RootCAs : roots , InsecureSkipVerify : insecure , ServerName : serverName , } , nil } 
func getETCDConfig ( ) ( * etcdcv3 . Config , error ) { etcdURLsStr := os . Getenv ( " " ) if etcdURLsStr == " " { etcdURLsStr = " " } etcdURLs := strings . Split ( etcdURLsStr , " " ) firstURL := strings . ToLower ( etcdURLs [ 0 ] ) if strings . HasPrefix ( firstURL , " " ) { return & etcdcv3 . Config { Endpoints : etcdURLs } , nil } else if strings . HasPrefix ( firstURL , " " ) { caFile := os . Getenv ( " " ) certFile := os . Getenv ( " " ) keyFile := os . Getenv ( " " ) serverName := os . Getenv ( " " ) isInsecureStr := strings . ToLower ( os . Getenv ( " " ) ) isInsecure := isInsecureStr == " " || isInsecureStr == " " || isInsecureStr == " " tlsConfig , err := newTLSConfig ( certFile , keyFile , caFile , serverName , isInsecure ) if err != nil { return nil , err } return & etcdcv3 . Config { Endpoints : etcdURLs , TLS : tlsConfig , } , nil } else { return nil , errors . New ( " " ) } } 
func newETCDClient ( ) ( coreDNSClient , error ) { cfg , err := getETCDConfig ( ) if err != nil { return nil , err } c , err := etcdcv3 . New ( * cfg ) if err != nil { return nil , err } return etcdClient { c , context . Background ( ) } , nil } 
func NewCoreDNSProvider ( domainFilter DomainFilter , dryRun bool ) ( Provider , error ) { client , err := newETCDClient ( ) if err != nil { return nil , err } return coreDNSProvider { client : client , dryRun : dryRun , domainFilter : domainFilter , } , nil } 
func ( p coreDNSProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { var result [ ] * endpoint . Endpoint services , err := p . client . GetServices ( coreDNSPrefix ) if err != nil { return nil , err } for _ , service := range services { domains := strings . Split ( strings . TrimPrefix ( service . Key , coreDNSPrefix ) , " " ) reverse ( domains ) dnsName := strings . Join ( domains [ service . TargetStrip : ] , " " ) if ! p . domainFilter . Match ( dnsName ) { continue } prefix := strings . Join ( domains [ : service . TargetStrip ] , " " ) if service . Host != " " { ep := endpoint . NewEndpointWithTTL ( dnsName , guessRecordType ( service . Host ) , endpoint . TTL ( service . TTL ) , service . Host , ) ep . Labels [ " " ] = service . Text ep . Labels [ randomPrefixLabel ] = prefix result = append ( result , ep ) } if service . Text != " " { ep := endpoint . NewEndpoint ( dnsName , endpoint . RecordTypeTXT , service . Text , ) ep . Labels [ randomPrefixLabel ] = prefix result = append ( result , ep ) } } return result , nil } 
func ( p coreDNSProvider ) ApplyChanges ( changes * plan . Changes ) error { grouped := map [ string ] [ ] * endpoint . Endpoint { } for _ , ep := range changes . Create { grouped [ ep . DNSName ] = append ( grouped [ ep . DNSName ] , ep ) } for i , ep := range changes . UpdateNew { ep . Labels [ randomPrefixLabel ] = changes . UpdateOld [ i ] . Labels [ randomPrefixLabel ] grouped [ ep . DNSName ] = append ( grouped [ ep . DNSName ] , ep ) } for dnsName , group := range grouped { if ! p . domainFilter . Match ( dnsName ) { log . Debugf ( " " , dnsName ) continue } var services [ ] Service for _ , ep := range group { if ep . RecordType == endpoint . RecordTypeTXT { continue } for _ , target := range ep . Targets { prefix := ep . Labels [ randomPrefixLabel ] if prefix == " " { prefix = fmt . Sprintf ( " " , rand . Int31 ( ) ) } service := Service { Host : target , Text : ep . Labels [ " " ] , Key : etcdKeyFor ( prefix + " " + dnsName ) , TargetStrip : strings . Count ( prefix , " " ) + 1 , TTL : uint32 ( ep . RecordTTL ) , } services = append ( services , service ) } } index := 0 for _ , ep := range group { if ep . RecordType != endpoint . RecordTypeTXT { continue } if index >= len ( services ) { prefix := ep . Labels [ randomPrefixLabel ] if prefix == " " { prefix = fmt . Sprintf ( " " , rand . Int31 ( ) ) } services = append ( services , Service { Key : etcdKeyFor ( prefix + " " + dnsName ) , TargetStrip : strings . Count ( prefix , " " ) + 1 , TTL : uint32 ( ep . RecordTTL ) , } ) } services [ index ] . Text = ep . Targets [ 0 ] index ++ } for i := index ; index > 0 && i < len ( services ) ; i ++ { services [ i ] . Text = " " } for _ , service := range services { log . Infof ( " " , service . Key , service . Host , service . Text , service . TTL ) if ! p . dryRun { err := p . client . SaveService ( & service ) if err != nil { return err } } } } for _ , ep := range changes . Delete { dnsName := ep . DNSName if ep . Labels [ randomPrefixLabel ] != " " { dnsName = ep . Labels [ randomPrefixLabel ] + " " + dnsName } key := etcdKeyFor ( dnsName ) log . Infof ( " " , key ) if ! p . dryRun { err := p . client . DeleteService ( key ) if err != nil { return err } } } return nil } 
func NewRfc2136Provider ( host string , port int , zoneName string , insecure bool , keyName string , secret string , secretAlg string , axfr bool , domainFilter DomainFilter , dryRun bool , actions rfc2136Actions ) ( Provider , error ) { secretAlgChecked , ok := tsigAlgs [ secretAlg ] if ! ok && ! insecure { return nil , errors . Errorf ( " " , secretAlg ) } r := & rfc2136Provider { nameserver : net . JoinHostPort ( host , strconv . Itoa ( port ) ) , zoneName : dns . Fqdn ( zoneName ) , insecure : insecure , domainFilter : domainFilter , dryRun : dryRun , axfr : axfr , } if actions != nil { r . actions = actions } else { r . actions = r } if ! insecure { r . tsigKeyName = dns . Fqdn ( keyName ) r . tsigSecret = secret r . tsigSecretAlg = secretAlgChecked } log . Infof ( " " , r . zoneName , r . nameserver ) return r , nil } 
func ( r rfc2136Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { rrs , err := r . List ( ) if err != nil { return nil , err } var eps [ ] * endpoint . Endpoint OuterLoop : for _ , rr := range rrs { log . Debugf ( " " , rr ) if rr . Header ( ) . Class != dns . ClassINET { continue } rrFqdn := rr . Header ( ) . Name rrTTL := endpoint . TTL ( rr . Header ( ) . Ttl ) var rrType string var rrValues [ ] string switch rr . Header ( ) . Rrtype { case dns . TypeCNAME : rrValues = [ ] string { rr . ( * dns . CNAME ) . Target } rrType = " " case dns . TypeA : rrValues = [ ] string { rr . ( * dns . A ) . A . String ( ) } rrType = " " case dns . TypeAAAA : rrValues = [ ] string { rr . ( * dns . AAAA ) . AAAA . String ( ) } rrType = " " case dns . TypeTXT : rrValues = ( rr . ( * dns . TXT ) . Txt ) rrType = " " default : continue } for idx , existingEndpoint := range eps { if existingEndpoint . DNSName == rrFqdn && existingEndpoint . RecordType == rrType { eps [ idx ] . Targets = append ( eps [ idx ] . Targets , rrValues ... ) continue OuterLoop } } ep := endpoint . NewEndpointWithTTL ( rrFqdn , rrType , rrTTL , rrValues ... , ) eps = append ( eps , ep ) } return eps , nil } 
func ( r rfc2136Provider ) ApplyChanges ( changes * plan . Changes ) error { log . Debugf ( " " ) for _ , ep := range changes . Create { if ! r . domainFilter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . AddRecord ( ep ) } for _ , ep := range changes . UpdateNew { if ! r . domainFilter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . UpdateRecord ( ep ) } for _ , ep := range changes . Delete { if ! r . domainFilter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . RemoveRecord ( ep ) } return nil } 
func stringifyHTTPResponseBody ( r * http . Response ) ( body string ) { if r == nil { return " " } buf := new ( bytes . Buffer ) buf . ReadFrom ( r . Body ) body = buf . String ( ) return body } 
func ( c * PDNSAPIClient ) ListZones ( ) ( zones [ ] pgo . Zone , resp * http . Response , err error ) { for i := 0 ; i < retryLimit ; i ++ { zones , resp , err = c . client . ZonesApi . ListZones ( c . authCtx , defaultServerID ) if err != nil { log . Debugf ( " " , err ) log . Debugf ( " " , i ) time . Sleep ( retryAfterTime * ( 1 << uint ( i ) ) ) continue } return zones , resp , err } log . Errorf ( " " , err ) return zones , resp , err } 
func ( c * PDNSAPIClient ) PartitionZones ( zones [ ] pgo . Zone ) ( filteredZones [ ] pgo . Zone , residualZones [ ] pgo . Zone ) { if c . domainFilter . IsConfigured ( ) { for _ , zone := range zones { if c . domainFilter . Match ( zone . Name ) { filteredZones = append ( filteredZones , zone ) } else { residualZones = append ( residualZones , zone ) } } } else { filteredZones = zones } return filteredZones , residualZones } 
func ( c * PDNSAPIClient ) ListZone ( zoneID string ) ( zone pgo . Zone , resp * http . Response , err error ) { for i := 0 ; i < retryLimit ; i ++ { zone , resp , err = c . client . ZonesApi . ListZone ( c . authCtx , defaultServerID , zoneID ) if err != nil { log . Debugf ( " " , err ) log . Debugf ( " " , i ) time . Sleep ( retryAfterTime * ( 1 << uint ( i ) ) ) continue } return zone , resp , err } log . Errorf ( " " , err ) return zone , resp , err } 
func NewPDNSProvider ( config PDNSConfig ) ( * PDNSProvider , error ) { } } if config . Server == " " { log . Warnf ( " " ) } pdnsClientConfig := pgo . NewConfiguration ( ) pdnsClientConfig . BasePath = config . Server + apiBase if err := config . TLSConfig . setHTTPClient ( pdnsClientConfig ) ; err != nil { return nil , err } provider := & PDNSProvider { client : & PDNSAPIClient { dryRun : config . DryRun , authCtx : context . WithValue ( context . TODO ( ) , pgo . ContextAPIKey , pgo . APIKey { Key : config . APIKey } ) , client : pgo . NewAPIClient ( pdnsClientConfig ) , domainFilter : config . DomainFilter , } , } return provider , nil } 
func ( p * PDNSProvider ) ConvertEndpointsToZones ( eps [ ] * endpoint . Endpoint , changetype pdnsChangeType ) ( zonelist [ ] pgo . Zone , _ error ) { zonelist = [ ] pgo . Zone { } endpoints := make ( [ ] * endpoint . Endpoint , len ( eps ) ) copy ( endpoints , eps ) } return endpoints [ i ] . DNSName < endpoints [ j ] . DNSName } ) zones , _ , err := p . client . ListZones ( ) if err != nil { return nil , err } filteredZones , residualZones := p . client . PartitionZones ( zones ) for i := 0 ; i < len ( endpoints ) ; { ep := endpoints [ i ] dnsname := ensureTrailingDot ( ep . DNSName ) if dnsname == zone . Name || strings . HasSuffix ( dnsname , " " + zone . Name ) { for _ , t := range ep . Targets { if " " == ep . RecordType { t = ensureTrailingDot ( t ) } records = append ( records , pgo . Record { Content : t } ) } rrset := pgo . RrSet { Name : dnsname , Type_ : ep . RecordType , Records : records , Changetype : string ( changetype ) , } } if ep . RecordTTL == 0 { } else { rrset . Ttl = int32 ( ep . RecordTTL ) } } zone . Rrsets = append ( zone . Rrsets , rrset ) } else { } } if len ( zone . Rrsets ) > 0 { zonelist = append ( zonelist , zone ) } } dnsname := ensureTrailingDot ( ep . DNSName ) if dnsname == zone . Name || strings . HasSuffix ( dnsname , " " + zone . Name ) { endpoints = append ( endpoints [ 0 : i ] , endpoints [ i + 1 : ] ... ) } else { i ++ } } } } log . Debugf ( " " , zonelist ) return zonelist , nil } 
func ( p * PDNSProvider ) mutateRecords ( endpoints [ ] * endpoint . Endpoint , changetype pdnsChangeType ) error { zonelist , err := p . ConvertEndpointsToZones ( endpoints , changetype ) if err != nil { return err } for _ , zone := range zonelist { jso , err := json . Marshal ( zone ) if err != nil { log . Errorf ( " " ) } else { log . Debugf ( " \n " , string ( jso ) ) } resp , err := p . client . PatchZone ( zone . Id , zone ) if err != nil { log . Debugf ( " " , stringifyHTTPResponseBody ( resp ) ) return err } } return nil } 
func ( p * PDNSProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , _ , err := p . client . ListZones ( ) if err != nil { return nil , err } filteredZones , _ := p . client . PartitionZones ( zones ) for _ , zone := range filteredZones { z , _ , err := p . client . ListZone ( zone . Id ) if err != nil { log . Warnf ( " " ) return nil , err } for _ , rr := range z . Rrsets { e , err := p . convertRRSetToEndpoints ( rr ) if err != nil { return nil , err } endpoints = append ( endpoints , e ... ) } } log . Debugf ( " \n " , endpoints ) return endpoints , nil } 
func ( p * PDNSProvider ) ApplyChanges ( changes * plan . Changes ) error { startTime := time . Now ( ) } if err != nil { return err } } } for _ , change := range changes . UpdateNew { log . Debugf ( " " , change ) } if len ( changes . UpdateNew ) > 0 { err := p . mutateRecords ( changes . UpdateNew , PdnsReplace ) if err != nil { return err } } } if len ( changes . Delete ) > 0 { err := p . mutateRecords ( changes . Delete , PdnsDelete ) if err != nil { return err } } log . Debugf ( " \n " , time . Since ( startTime ) ) return nil } 
func NewAWSSDProvider ( domainFilter DomainFilter , namespaceType string , assumeRole string , dryRun bool ) ( * AWSSDProvider , error ) { config := aws . NewConfig ( ) config = config . WithHTTPClient ( instrumented_http . NewClient ( config . HTTPClient , & instrumented_http . Callbacks { PathProcessor : func ( path string ) string { parts := strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) , ) sess , err := session . NewSessionWithOptions ( session . Options { Config : * config , SharedConfigState : session . SharedConfigEnable , } ) if err != nil { return nil , err } if assumeRole != " " { log . Infof ( " " , assumeRole ) sess . Config . WithCredentials ( stscreds . NewCredentials ( sess , assumeRole ) ) } sess . Handlers . Build . PushBack ( request . MakeAddToUserAgentHandler ( " " , externaldns . Version ) ) provider := & AWSSDProvider { client : sd . New ( sess ) , namespaceFilter : domainFilter , namespaceTypeFilter : newSdNamespaceFilter ( namespaceType ) , dryRun : dryRun , } return provider , nil } 
func newSdNamespaceFilter ( namespaceTypeConfig string ) * sd . NamespaceFilter { switch namespaceTypeConfig { case sdNamespaceTypePublic : return & sd . NamespaceFilter { Name : aws . String ( sd . NamespaceFilterNameType ) , Values : [ ] * string { aws . String ( sd . NamespaceTypeDnsPublic ) } , } case sdNamespaceTypePrivate : return & sd . NamespaceFilter { Name : aws . String ( sd . NamespaceFilterNameType ) , Values : [ ] * string { aws . String ( sd . NamespaceTypeDnsPrivate ) } , } default : return nil } } 
func ( p * AWSSDProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { namespaces , err := p . ListNamespaces ( ) if err != nil { return nil , err } for _ , ns := range namespaces { services , err := p . ListServicesByNamespaceID ( ns . Id ) if err != nil { return nil , err } for _ , srv := range services { instances , err := p . ListInstancesByServiceID ( srv . Id ) if err != nil { return nil , err } if len ( instances ) > 0 { ep := p . instancesToEndpoint ( ns , srv , instances ) endpoints = append ( endpoints , ep ) } } } return endpoints , nil } 
func ( p * AWSSDProvider ) ApplyChanges ( changes * plan . Changes ) error { return nil } changes . Delete = append ( changes . Delete , deletes ... ) changes . Create = append ( changes . Create , creates ... ) namespaces , err := p . ListNamespaces ( ) if err != nil { return err } if err != nil { return err } err = p . submitCreates ( namespaces , changes . Create ) if err != nil { return err } return nil } 
func ( p * AWSSDProvider ) ListNamespaces ( ) ( [ ] * sd . NamespaceSummary , error ) { namespaces := make ( [ ] * sd . NamespaceSummary , 0 ) f := func ( resp * sd . ListNamespacesOutput , lastPage bool ) bool { for _ , ns := range resp . Namespaces { if ! p . namespaceFilter . Match ( aws . StringValue ( ns . Name ) ) { continue } namespaces = append ( namespaces , ns ) } return true } err := p . client . ListNamespacesPages ( & sd . ListNamespacesInput { Filters : [ ] * sd . NamespaceFilter { p . namespaceTypeFilter } , } , f ) if err != nil { return nil , err } return namespaces , nil } 
func ( p * AWSSDProvider ) ListServicesByNamespaceID ( namespaceID * string ) ( map [ string ] * sd . Service , error ) { serviceIds := make ( [ ] * string , 0 ) f := func ( resp * sd . ListServicesOutput , lastPage bool ) bool { for _ , srv := range resp . Services { serviceIds = append ( serviceIds , srv . Id ) } return true } err := p . client . ListServicesPages ( & sd . ListServicesInput { Filters : [ ] * sd . ServiceFilter { { Name : aws . String ( sd . ServiceFilterNameNamespaceId ) , Values : [ ] * string { namespaceID } , } } , } , f ) if err != nil { return nil , err } for _ , serviceID := range serviceIds { service , err := p . GetServiceDetail ( serviceID ) if err != nil { return nil , err } services [ aws . StringValue ( service . Name ) ] = service } return services , nil } 
func ( p * AWSSDProvider ) GetServiceDetail ( serviceID * string ) ( * sd . Service , error ) { output , err := p . client . GetService ( & sd . GetServiceInput { Id : serviceID , } ) if err != nil { return nil , err } return output . Service , nil } 
func ( p * AWSSDProvider ) ListInstancesByServiceID ( serviceID * string ) ( [ ] * sd . InstanceSummary , error ) { instances := make ( [ ] * sd . InstanceSummary , 0 ) f := func ( resp * sd . ListInstancesOutput , lastPage bool ) bool { instances = append ( instances , resp . Instances ... ) return true } err := p . client . ListInstancesPages ( & sd . ListInstancesInput { ServiceId : serviceID , } , f ) if err != nil { return nil , err } return instances , nil } 
func ( p * AWSSDProvider ) CreateService ( namespaceID * string , srvName * string , ep * endpoint . Endpoint ) ( * sd . Service , error ) { log . Infof ( " \" \" \" \" " , * srvName , * namespaceID ) srvType := p . serviceTypeFromEndpoint ( ep ) routingPolicy := p . routingPolicyFromEndpoint ( ep ) ttl := int64 ( sdDefaultRecordTTL ) if ep . RecordTTL . IsConfigured ( ) { ttl = int64 ( ep . RecordTTL ) } if ! p . dryRun { out , err := p . client . CreateService ( & sd . CreateServiceInput { Name : srvName , Description : aws . String ( ep . Labels [ endpoint . AWSSDDescriptionLabel ] ) , DnsConfig : & sd . DnsConfig { NamespaceId : namespaceID , RoutingPolicy : aws . String ( routingPolicy ) , DnsRecords : [ ] * sd . DnsRecord { { Type : aws . String ( srvType ) , TTL : aws . Int64 ( ttl ) , } } , } , } ) if err != nil { return nil , err } return out . Service , nil } } 
func ( p * AWSSDProvider ) UpdateService ( service * sd . Service , ep * endpoint . Endpoint ) error { log . Infof ( " \" \" " , * service . Name ) srvType := p . serviceTypeFromEndpoint ( ep ) ttl := int64 ( sdDefaultRecordTTL ) if ep . RecordTTL . IsConfigured ( ) { ttl = int64 ( ep . RecordTTL ) } if ! p . dryRun { _ , err := p . client . UpdateService ( & sd . UpdateServiceInput { Id : service . Id , Service : & sd . ServiceChange { Description : aws . String ( ep . Labels [ endpoint . AWSSDDescriptionLabel ] ) , DnsConfig : & sd . DnsConfigChange { DnsRecords : [ ] * sd . DnsRecord { { Type : aws . String ( srvType ) , TTL : aws . Int64 ( ttl ) , } } , } } } ) if err != nil { return err } } return nil } 
func ( p * AWSSDProvider ) RegisterInstance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target := range ep . Targets { log . Infof ( " \" \" \" \" " , target , * service . Name , * service . Id ) attr := make ( map [ string ] * string ) if ep . RecordType == endpoint . RecordTypeCNAME { if p . isAWSLoadBalancer ( target ) { attr [ sdInstanceAttrAlias ] = aws . String ( target ) } else { attr [ sdInstanceAttrCname ] = aws . String ( target ) } } else if ep . RecordType == endpoint . RecordTypeA { attr [ sdInstanceAttrIPV4 ] = aws . String ( target ) } else { return fmt . Errorf ( " " , ep ) } if ! p . dryRun { _ , err := p . client . RegisterInstance ( & sd . RegisterInstanceInput { ServiceId : service . Id , Attributes : attr , InstanceId : aws . String ( p . targetToInstanceID ( target ) ) , } ) if err != nil { return err } } } return nil } 
func ( p * AWSSDProvider ) DeregisterInstance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target := range ep . Targets { log . Infof ( " \" \" \" \" " , target , * service . Name , * service . Id ) if ! p . dryRun { _ , err := p . client . DeregisterInstance ( & sd . DeregisterInstanceInput { InstanceId : aws . String ( p . targetToInstanceID ( target ) ) , ServiceId : service . Id , } ) if err != nil { return err } } } return nil } 
func ( p * AWSSDProvider ) targetToInstanceID ( target string ) string { if len ( target ) > 64 { hash := sha256 . Sum256 ( [ ] byte ( strings . ToLower ( target ) ) ) return hex . EncodeToString ( hash [ : ] ) } return strings . ToLower ( target ) } 
func namespaceToNamespaceSummary ( namespace * sd . Namespace ) * sd . NamespaceSummary { if namespace == nil { return nil } return & sd . NamespaceSummary { Id : namespace . Id , Type : namespace . Type , Name : namespace . Name , Arn : namespace . Arn , } } 
func serviceToServiceSummary ( service * sd . Service ) * sd . ServiceSummary { if service == nil { return nil } return & sd . ServiceSummary { Name : service . Name , Id : service . Id , Arn : service . Arn , Description : service . Description , InstanceCount : service . InstanceCount , } } 
func instanceToInstanceSummary ( instance * sd . Instance ) * sd . InstanceSummary { if instance == nil { return nil } return & sd . InstanceSummary { Id : instance . Id , Attributes : instance . Attributes , } } 
func matchingNamespaces ( hostname string , namespaces [ ] * sd . NamespaceSummary ) [ ] * sd . NamespaceSummary { matchingNamespaces := make ( [ ] * sd . NamespaceSummary , 0 ) for _ , ns := range namespaces { if * ns . Name == hostname { matchingNamespaces = append ( matchingNamespaces , ns ) } } return matchingNamespaces } 
func ( p * AWSSDProvider ) parseHostname ( hostname string ) ( namespace string , service string ) { parts := strings . Split ( hostname , " " ) service = parts [ 0 ] namespace = strings . Join ( parts [ 1 : ] , " " ) return } 
func ( p * AWSSDProvider ) routingPolicyFromEndpoint ( ep * endpoint . Endpoint ) string { if ep . RecordType == endpoint . RecordTypeA { return sd . RoutingPolicyMultivalue } return sd . RoutingPolicyWeighted } 
func ( p * AWSSDProvider ) serviceTypeFromEndpoint ( ep * endpoint . Endpoint ) string { if ep . RecordType == endpoint . RecordTypeCNAME { } return sd . RecordTypeCname } return sd . RecordTypeA } 
func ( p * AWSSDProvider ) isAWSLoadBalancer ( hostname string ) bool { return strings . HasSuffix ( hostname , sdElbHostnameSuffix ) } 
func ( s PerResource ) ResolveCreate ( candidates [ ] * endpoint . Endpoint ) * endpoint . Endpoint { var min * endpoint . Endpoint for _ , ep := range candidates { if min == nil || s . less ( ep , min ) { min = ep } } return min } 
func ( s PerResource ) ResolveUpdate ( current * endpoint . Endpoint , candidates [ ] * endpoint . Endpoint ) * endpoint . Endpoint { currentResource := current . Labels [ endpoint . ResourceLabelKey ] } ) for _ , ep := range candidates { if ep . Labels [ endpoint . ResourceLabelKey ] == currentResource { return ep } } return s . ResolveCreate ( candidates ) } 
func ( s PerResource ) less ( x , y * endpoint . Endpoint ) bool { return x . Targets . IsLess ( y . Targets ) } 
func NewDigitalOceanProvider ( domainFilter DomainFilter , dryRun bool ) ( * DigitalOceanProvider , error ) { token , ok := os . LookupEnv ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } oauthClient := oauth2 . NewClient ( oauth2 . NoContext , oauth2 . StaticTokenSource ( & oauth2 . Token { AccessToken : token , } ) ) client := godo . NewClient ( oauthClient ) provider := & DigitalOceanProvider { Client : client . Domains , domainFilter : domainFilter , DryRun : dryRun , } return provider , nil } 
func ( p * DigitalOceanProvider ) Zones ( ) ( [ ] godo . Domain , error ) { result := [ ] godo . Domain { } zones , err := p . fetchZones ( ) if err != nil { return nil , err } for _ , zone := range zones { if p . domainFilter . Match ( zone . Name ) { result = append ( result , zone ) } } return result , nil } 
func ( p * DigitalOceanProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err := p . Zones ( ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , zone := range zones { records , err := p . fetchRecords ( zone . Name ) if err != nil { return nil , err } for _ , r := range records { if supportedRecordType ( r . Type ) { name := r . Name + " " + zone . Name } endpoints = append ( endpoints , endpoint . NewEndpoint ( name , r . Type , r . Data ) ) } } } return endpoints , nil } 
func ( p * DigitalOceanProvider ) submitChanges ( changes [ ] * DigitalOceanChange ) error { } zones , err := p . Zones ( ) if err != nil { return err } for zoneName , changes := range changesByZone { records , err := p . fetchRecords ( zoneName ) if err != nil { log . Errorf ( " " , zoneName ) continue } for _ , change := range changes { logFields := log . Fields { " " : change . ResourceRecordSet . Name , " " : change . ResourceRecordSet . Type , " " : change . ResourceRecordSet . TTL , " " : change . Action , " " : zoneName , } log . WithFields ( logFields ) . Info ( " " ) if p . DryRun { continue } change . ResourceRecordSet . Name = strings . TrimSuffix ( change . ResourceRecordSet . Name , " " + zoneName ) } } switch change . Action { case DigitalOceanCreate : _ , _ , err = p . Client . CreateRecord ( context . TODO ( ) , zoneName , & godo . DomainRecordEditRequest { Data : change . ResourceRecordSet . Data , Name : change . ResourceRecordSet . Name , Type : change . ResourceRecordSet . Type , TTL : change . ResourceRecordSet . TTL , } ) if err != nil { return err } case DigitalOceanDelete : recordID := p . getRecordID ( records , change . ResourceRecordSet ) _ , err = p . Client . DeleteRecord ( context . TODO ( ) , zoneName , recordID ) if err != nil { return err } case DigitalOceanUpdate : recordID := p . getRecordID ( records , change . ResourceRecordSet ) _ , _ , err = p . Client . EditRecord ( context . TODO ( ) , zoneName , recordID , & godo . DomainRecordEditRequest { Data : change . ResourceRecordSet . Data , Name : change . ResourceRecordSet . Name , Type : change . ResourceRecordSet . Type , TTL : change . ResourceRecordSet . TTL , } ) if err != nil { return err } } } } return nil } 
func ( p * DigitalOceanProvider ) ApplyChanges ( changes * plan . Changes ) error { combinedChanges := make ( [ ] * DigitalOceanChange , 0 , len ( changes . Create ) + len ( changes . UpdateNew ) + len ( changes . Delete ) ) combinedChanges = append ( combinedChanges , newDigitalOceanChanges ( DigitalOceanCreate , changes . Create ) ... ) combinedChanges = append ( combinedChanges , newDigitalOceanChanges ( DigitalOceanUpdate , changes . UpdateNew ) ... ) combinedChanges = append ( combinedChanges , newDigitalOceanChanges ( DigitalOceanDelete , changes . Delete ) ... ) return p . submitChanges ( combinedChanges ) } 
func newDigitalOceanChanges ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * DigitalOceanChange { changes := make ( [ ] * DigitalOceanChange , 0 , len ( endpoints ) ) for _ , endpoint := range endpoints { changes = append ( changes , newDigitalOceanChange ( action , endpoint ) ) } return changes } 
func ( p * DigitalOceanProvider ) getRecordID ( records [ ] godo . DomainRecord , record godo . DomainRecord ) int { for _ , zoneRecord := range records { if zoneRecord . Name == record . Name && zoneRecord . Type == record . Type { return zoneRecord . ID } } return 0 } 
func digitalOceanChangesByZone ( zones [ ] godo . Domain , changeSet [ ] * DigitalOceanChange ) map [ string ] [ ] * DigitalOceanChange { changes := make ( map [ string ] [ ] * DigitalOceanChange ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( z . Name , z . Name ) changes [ z . Name ] = [ ] * DigitalOceanChange { } } for _ , c := range changeSet { zone , _ := zoneNameIDMapper . FindZone ( c . ResourceRecordSet . Name ) if zone == " " { log . Debugf ( " " , c . ResourceRecordSet . Name ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func legacyEndpointsFromService ( svc * v1 . Service , compatibility string ) [ ] * endpoint . Endpoint { switch compatibility { case " " : return legacyEndpointsFromMateService ( svc ) case " " : return legacyEndpointsFromMoleculeService ( svc ) } return [ ] * endpoint . Endpoint { } } 
func legacyEndpointsFromMateService ( svc * v1 . Service ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint if ! exists { return nil } } if lb . Hostname != " " { endpoints = append ( endpoints , endpoint . NewEndpoint ( hostname , endpoint . RecordTypeCNAME , lb . Hostname ) ) } } return endpoints } 
func legacyEndpointsFromMoleculeService ( svc * v1 . Service ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint } if ! exists { return nil } hostnameList := strings . Split ( strings . Replace ( hostnameAnnotation , " " , " " , - 1 ) , " " ) for _ , hostname := range hostnameList { } if lb . Hostname != " " { endpoints = append ( endpoints , endpoint . NewEndpoint ( hostname , endpoint . RecordTypeCNAME , lb . Hostname ) ) } } } return endpoints } 
func ( cs * connectorSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints := [ ] * endpoint . Endpoint { } conn , err := net . DialTimeout ( " " , cs . remoteServer , dialTimeout ) if err != nil { log . Errorf ( " " , err ) return nil , err } defer conn . Close ( ) decoder := gob . NewDecoder ( conn ) if err := decoder . Decode ( & endpoints ) ; err != nil { log . Errorf ( " " , err ) return nil , err } log . Debugf ( " " , endpoints ) return endpoints , nil } 
func getTargetsFromTargetAnnotation ( annotations map [ string ] string ) endpoint . Targets { var targets endpoint . Targets if exists && targetAnnotation != " " { for _ , targetHostname := range targetsList { targetHostname = strings . TrimSuffix ( targetHostname , " " ) targets = append ( targets , targetHostname ) } } return targets } 
func suitableType ( target string ) string { if net . ParseIP ( target ) != nil { return endpoint . RecordTypeA } return endpoint . RecordTypeCNAME } 
func endpointsForHostname ( hostname string , targets endpoint . Targets , ttl endpoint . TTL , providerSpecific endpoint . ProviderSpecific ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint var aTargets endpoint . Targets var cnameTargets endpoint . Targets for _ , t := range targets { switch suitableType ( t ) { case endpoint . RecordTypeA : aTargets = append ( aTargets , t ) default : cnameTargets = append ( cnameTargets , t ) } } if len ( aTargets ) > 0 { epA := & endpoint . Endpoint { DNSName : strings . TrimSuffix ( hostname , " " ) , Targets : aTargets , RecordTTL : ttl , RecordType : endpoint . RecordTypeA , Labels : endpoint . NewLabels ( ) , ProviderSpecific : providerSpecific , } endpoints = append ( endpoints , epA ) } if len ( cnameTargets ) > 0 { epCNAME := & endpoint . Endpoint { DNSName : strings . TrimSuffix ( hostname , " " ) , Targets : cnameTargets , RecordTTL : ttl , RecordType : endpoint . RecordTypeCNAME , Labels : endpoint . NewLabels ( ) , ProviderSpecific : providerSpecific , } endpoints = append ( endpoints , epCNAME ) } return endpoints } 
func ( snap * ZoneSnapshot ) GetRecordsForSerial ( zone string , serial int ) [ ] * endpoint . Endpoint { lastSerial , ok := snap . serials [ zone ] if ! ok { } if lastSerial != serial { } endpoints , ok := snap . endpoints [ zone ] if ! ok { } return endpoints } 
func ( snap * ZoneSnapshot ) StoreRecordsForSerial ( zone string , serial int , records [ ] * endpoint . Endpoint ) { snap . serials [ zone ] = serial snap . endpoints [ zone ] = records } 
func NewDynProvider ( config DynConfig ) ( Provider , error ) { return & dynProviderState { DynConfig : config , ZoneSnapshot : & ZoneSnapshot { endpoints : map [ string ] [ ] * endpoint . Endpoint { } , serials : map [ string ] int { } , } , } , nil } 
func filterAndFixLinks ( links [ ] string , filter DomainFilter ) [ ] string { var result [ ] string for _ , link := range links { } if filter . Match ( domain ) { result = append ( result , link ) } } return result } 
func merge ( updateOld , updateNew [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { findMatch := func ( template * endpoint . Endpoint ) * endpoint . Endpoint { for _ , new := range updateNew { if template . DNSName == new . DNSName && template . RecordType == new . RecordType { return new } } return nil } var result [ ] * endpoint . Endpoint for _ , old := range updateOld { matchingNew := findMatch ( old ) if matchingNew == nil { } if ! matchingNew . Targets . Same ( old . Targets ) { continue } if matchingNew . RecordTTL != 0 && matchingNew . RecordTTL != old . RecordTTL { } } return result } 
func endpointToRecord ( ep * endpoint . Endpoint ) * dynect . DataBlock { result := dynect . DataBlock { } if ep . RecordType == endpoint . RecordTypeA { result . Address = ep . Targets [ 0 ] } else if ep . RecordType == endpoint . RecordTypeCNAME { result . CName = ep . Targets [ 0 ] } else if ep . RecordType == endpoint . RecordTypeTXT { result . TxtData = ep . Targets [ 0 ] } return & result } 
func ( d * dynProviderState ) fetchAllRecordsInZone ( zone string ) ( * dynectsoap . GetAllRecordsResponseType , error ) { var err error client := dynectsoap . NewClient ( " " ) service := dynectsoap . NewDynect ( client ) sessionRequest := dynectsoap . SessionLoginRequestType { Customer_name : d . CustomerName , User_name : d . Username , Password : d . Password , Fault_incompat : 0 , } resp := dynectsoap . SessionLoginResponseType { } err = apiRetryLoop ( func ( ) error { return service . Do ( & sessionRequest , & resp ) } ) if err != nil { return nil , err } token := resp . Data . Token logoutRequest := dynectsoap . SessionLogoutRequestType { Token : token , Fault_incompat : 0 , } logoutResponse := dynectsoap . SessionLogoutResponseType { } defer service . Do ( & logoutRequest , & logoutResponse ) req := dynectsoap . GetAllRecordsRequestType { Token : token , Zone : zone , Fault_incompat : 0 , } records := dynectsoap . GetAllRecordsResponseType { } err = apiRetryLoop ( func ( ) error { return service . Do ( & req , & records ) } ) if err != nil { return nil , err } log . Debugf ( " " , records . Status ) if strings . ToLower ( records . Status ) == " " { jobRequest := dynectsoap . GetJobRequestType { Token : token , Job_id : records . Job_id , Fault_incompat : 0 , } jobResults := dynectsoap . GetJobResponseType { } err = apiRetryLoop ( func ( ) error { return service . GetJobRetry ( & jobRequest , & jobResults ) } ) if err != nil { return nil , err } return jobResults . Data . ( * dynectsoap . GetAllRecordsResponseType ) , nil } return & records , nil } 
func ( d * dynProviderState ) fetchAllRecordLinksInZone ( client * dynect . Client , zone string ) ( [ ] string , error ) { var allRecords dynect . AllRecordsResponse err := client . Do ( " " , fmt . Sprintf ( " " , zone ) , nil , & allRecords ) if err != nil { return nil , err } return filterAndFixLinks ( allRecords . Data , d . DomainFilter ) , nil } 
func ( d * dynProviderState ) buildLinkToRecord ( ep * endpoint . Endpoint ) string { if ep == nil { return " " } var matchingZone = " " for _ , zone := range d . ZoneIDFilter . zoneIDs { if strings . HasSuffix ( ep . DNSName , zone ) { matchingZone = zone break } } if matchingZone == " " { } if ! d . DomainFilter . Match ( ep . DNSName ) { } return fmt . Sprintf ( " " , ep . RecordType , matchingZone , ep . DNSName ) } 
func ( d * dynProviderState ) login ( ) ( * dynect . Client , error ) { if d . LastLoginErrorTime != 0 { secondsSinceLastError := unixNow ( ) - d . LastLoginErrorTime if secondsSinceLastError < badLoginMinIntervalSeconds { return nil , fmt . Errorf ( " " , secondsSinceLastError ) } } client := dynect . NewClient ( d . CustomerName ) var req = dynect . LoginBlock { Username : d . Username , Password : d . Password , CustomerName : d . CustomerName } var resp dynect . LoginResponse err := client . Do ( " " , " " , req , & resp ) if err != nil { d . LastLoginErrorTime = unixNow ( ) return nil , err } d . LastLoginErrorTime = 0 client . Token = resp . Data . Token return client , nil } 
func ( d * dynProviderState ) zones ( client * dynect . Client ) [ ] string { return d . ZoneIDFilter . zoneIDs } 
func ( d * dynProviderState ) deleteRecord ( client * dynect . Client , ep * endpoint . Endpoint ) error { link := d . buildLinkToRecord ( ep ) if link == " " { return nil } response := dynect . RecordResponse { } err := apiRetryLoop ( func ( ) error { return client . Do ( " " , link , nil , & response ) } ) log . Debugf ( " " , link , errorOrValue ( err , & response ) ) return err } 
func ( d * dynProviderState ) replaceRecord ( client * dynect . Client , ep * endpoint . Endpoint ) error { link , record := d . buildRecordRequest ( ep ) if link == " " { return nil } response := dynect . RecordResponse { } err := apiRetryLoop ( func ( ) error { return client . Do ( " " , link , record , & response ) } ) log . Debugf ( " " , link , errorOrValue ( err , & response ) ) return err } 
func ( d * dynProviderState ) commit ( client * dynect . Client ) error { errs := [ ] error { } for _ , zone := range d . zones ( client ) { err := client . Do ( " " , fmt . Sprintf ( " " , zone ) , nil , & response ) log . Debugf ( " " , zone , errorOrValue ( err , & response ) ) } h , err := os . Hostname ( ) if err != nil { h = " " } notes := fmt . Sprintf ( " " , d . AppVersion , d . DynVersion , time . Now ( ) . Format ( time . RFC3339 ) , h , ) zonePublish := ZonePublishRequest { Publish : true , Notes : notes , } response := ZonePublishResponse { } } ) log . Infof ( " " , zone , errorOrValue ( err , & response ) ) } switch len ( errs ) { case 0 : return nil case 1 : return errs [ 0 ] default : return fmt . Errorf ( " " , errs ) } } 
func ( d * dynProviderState ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { client , err := d . login ( ) if err != nil { return nil , err } defer client . Logout ( ) log . Debugf ( " " , d . DynVersion ) var result [ ] * endpoint . Endpoint zones := d . zones ( client ) log . Infof ( " " , zones ) for _ , zone := range zones { serial , err := d . fetchZoneSerial ( client , zone ) if err != nil { if strings . Index ( err . Error ( ) , " " ) >= 0 { log . Infof ( " " , zone ) continue } return nil , err } relevantRecords := d . ZoneSnapshot . GetRecordsForSerial ( zone , serial ) if relevantRecords != nil { log . Infof ( " " , len ( relevantRecords ) , zone , serial ) result = append ( result , relevantRecords ... ) continue } if err != nil { return nil , err } relevantRecords = d . allRecordsToEndpoints ( records ) log . Debugf ( " " , relevantRecords ) d . ZoneSnapshot . StoreRecordsForSerial ( zone , serial , relevantRecords ) log . Infof ( " " , len ( relevantRecords ) , zone , serial ) result = append ( result , relevantRecords ... ) } return result , nil } 
func ( d * dynProviderState ) ApplyChanges ( changes * plan . Changes ) error { log . Debugf ( " " , changes ) if d . DryRun { log . Infof ( " " , changes . Delete ) log . Infof ( " " , changes . Create ) log . Infof ( " " , merge ( changes . UpdateOld , changes . UpdateNew ) ) return nil } client , err := d . login ( ) if err != nil { return err } defer client . Logout ( ) var errs [ ] error needsCommit := false for _ , ep := range changes . Delete { err := d . deleteRecord ( client , ep ) if err != nil { errs = append ( errs , err ) } else { needsCommit = true } } for _ , ep := range changes . Create { err := d . createRecord ( client , ep ) if err != nil { errs = append ( errs , err ) } else { needsCommit = true } } updates := merge ( changes . UpdateOld , changes . UpdateNew ) log . Debugf ( " " , updates ) for _ , ep := range updates { err := d . replaceRecord ( client , ep ) if err != nil { errs = append ( errs , err ) } else { needsCommit = true } } switch len ( errs ) { case 0 : case 1 : return errs [ 0 ] default : return fmt . Errorf ( " " , errs ) } if needsCommit { return d . commit ( client ) } return nil } 
func ( ms * multiSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { result := [ ] * endpoint . Endpoint { } for _ , s := range ms . children { endpoints , err := s . Endpoints ( ) if err != nil { return nil , err } result = append ( result , endpoints ... ) } return result , nil } 
func newDesignateClient ( ) ( designateClientInterface , error ) { serviceClient , err := createDesignateServiceClient ( ) if err != nil { return nil , err } return & designateClient { serviceClient } , nil } 
func remapEnv ( mapping map [ string ] string ) { for k , v := range mapping { currentVal := os . Getenv ( k ) newVal := os . Getenv ( v ) if currentVal == " " && newVal != " " { os . Setenv ( k , newVal ) } } } 
func getAuthSettings ( ) ( gophercloud . AuthOptions , error ) { remapEnv ( map [ string ] string { " " : " " , " " : " " , " " : " " , " " : " " , } ) opts , err := openstack . AuthOptionsFromEnv ( ) if err != nil { return gophercloud . AuthOptions { } , err } opts . AllowReauth = true if ! strings . HasSuffix ( opts . IdentityEndpoint , " " ) { opts . IdentityEndpoint += " " } if ! strings . HasSuffix ( opts . IdentityEndpoint , " " ) && ! strings . HasSuffix ( opts . IdentityEndpoint , " " ) { opts . IdentityEndpoint += " " } return opts , nil } 
func createDesignateServiceClient ( ) ( * gophercloud . ServiceClient , error ) { opts , err := getAuthSettings ( ) if err != nil { return nil , err } log . Infof ( " " , opts . IdentityEndpoint ) authProvider , err := openstack . NewClient ( opts . IdentityEndpoint ) if err != nil { return nil , err } tlsConfig , err := tlsutils . CreateTLSConfig ( " " ) if err != nil { return nil , err } transport := & http . Transport { Proxy : http . ProxyFromEnvironment , DialContext : ( & net . Dialer { Timeout : 30 * time . Second , KeepAlive : 30 * time . Second , } ) . DialContext , MaxIdleConns : 100 , IdleConnTimeout : 90 * time . Second , TLSHandshakeTimeout : 10 * time . Second , ExpectContinueTimeout : 1 * time . Second , TLSClientConfig : tlsConfig , } authProvider . HTTPClient . Transport = transport if err = openstack . Authenticate ( authProvider , opts ) ; err != nil { return nil , err } eo := gophercloud . EndpointOpts { Region : os . Getenv ( " " ) , } client , err := openstack . NewDNSV2 ( authProvider , eo ) if err != nil { return nil , err } log . Infof ( " " , client . Endpoint ) return client , nil } 
func ( c designateClient ) ForEachZone ( handler func ( zone * zones . Zone ) error ) error { pager := zones . List ( c . serviceClient , zones . ListOpts { } ) return pager . EachPage ( func ( page pagination . Page ) ( bool , error ) { list , err := zones . ExtractZones ( page ) if err != nil { return false , err } for _ , zone := range list { err := handler ( & zone ) if err != nil { return false , err } } return true , nil } , ) } 
func ( c designateClient ) ForEachRecordSet ( zoneID string , handler func ( recordSet * recordsets . RecordSet ) error ) error { pager := recordsets . ListByZone ( c . serviceClient , zoneID , recordsets . ListOpts { } ) return pager . EachPage ( func ( page pagination . Page ) ( bool , error ) { list , err := recordsets . ExtractRecordSets ( page ) if err != nil { return false , err } for _ , recordSet := range list { err := handler ( & recordSet ) if err != nil { return false , err } } return true , nil } , ) } 
func ( c designateClient ) CreateRecordSet ( zoneID string , opts recordsets . CreateOpts ) ( string , error ) { r , err := recordsets . Create ( c . serviceClient , zoneID , opts ) . Extract ( ) if err != nil { return " " , err } return r . ID , nil } 
func ( c designateClient ) UpdateRecordSet ( zoneID , recordSetID string , opts recordsets . UpdateOpts ) error { _ , err := recordsets . Update ( c . serviceClient , zoneID , recordSetID , opts ) . Extract ( ) return err } 
func ( c designateClient ) DeleteRecordSet ( zoneID , recordSetID string ) error { return recordsets . Delete ( c . serviceClient , zoneID , recordSetID ) . ExtractErr ( ) } 
func NewDesignateProvider ( domainFilter DomainFilter , dryRun bool ) ( Provider , error ) { client , err := newDesignateClient ( ) if err != nil { return nil , err } return & designateProvider { client : client , domainFilter : domainFilter , dryRun : dryRun , } , nil } 
func canonicalizeDomainNames ( domains [ ] string ) [ ] string { var cDomains [ ] string for _ , d := range domains { if ! strings . HasSuffix ( d , " " ) { d += " " cDomains = append ( cDomains , strings . ToLower ( d ) ) } } return cDomains } 
func canonicalizeDomainName ( d string ) string { if ! strings . HasSuffix ( d , " " ) { d += " " } return strings . ToLower ( d ) } 
func ( p designateProvider ) getZones ( ) ( map [ string ] string , error ) { result := map [ string ] string { } err := p . client . ForEachZone ( func ( zone * zones . Zone ) error { if zone . Type != " " && strings . ToUpper ( zone . Type ) != " " || zone . Status != " " { return nil } zoneName := canonicalizeDomainName ( zone . Name ) if ! p . domainFilter . Match ( zoneName ) { return nil } result [ zone . ID ] = zoneName return nil } , ) return result , err } 
func ( p designateProvider ) getHostZoneID ( hostname string , managedZones map [ string ] string ) ( string , error ) { longestZoneLength := 0 resultID := " " for zoneID , zoneName := range managedZones { if ! strings . HasSuffix ( hostname , zoneName ) { continue } ln := len ( zoneName ) if ln > longestZoneLength { resultID = zoneID longestZoneLength = ln } } return resultID , nil } 
func ( p designateProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { var result [ ] * endpoint . Endpoint managedZones , err := p . getZones ( ) if err != nil { return nil , err } for zoneID := range managedZones { err = p . client . ForEachRecordSet ( zoneID , func ( recordSet * recordsets . RecordSet ) error { if recordSet . Type != endpoint . RecordTypeA && recordSet . Type != endpoint . RecordTypeTXT && recordSet . Type != endpoint . RecordTypeCNAME { return nil } for _ , record := range recordSet . Records { ep := endpoint . NewEndpoint ( recordSet . Name , recordSet . Type , record ) ep . Labels [ designateRecordSetID ] = recordSet . ID ep . Labels [ designateZoneID ] = recordSet . ZoneID ep . Labels [ designateOriginalRecords ] = strings . Join ( recordSet . Records , " \000 " ) result = append ( result , ep ) } return nil } , ) if err != nil { return nil , err } } return result , nil } 
func addEndpoint ( ep * endpoint . Endpoint , recordSets map [ string ] * recordSet , delete bool ) { key := fmt . Sprintf ( " " , ep . DNSName , ep . RecordType ) rs := recordSets [ key ] if rs == nil { rs = & recordSet { dnsName : canonicalizeDomainName ( ep . DNSName ) , recordType : ep . RecordType , names : make ( map [ string ] bool ) , } } if rs . zoneID == " " { rs . zoneID = ep . Labels [ designateZoneID ] } if rs . recordSetID == " " { rs . recordSetID = ep . Labels [ designateRecordSetID ] } for _ , rec := range strings . Split ( ep . Labels [ designateOriginalRecords ] , " \000 " ) { if _ , ok := rs . names [ rec ] ; ! ok && rec != " " { rs . names [ rec ] = true } } targets := ep . Targets if ep . RecordType == endpoint . RecordTypeCNAME { targets = canonicalizeDomainNames ( targets ) } for _ , t := range targets { rs . names [ t ] = ! delete } recordSets [ key ] = rs } 
func ( p designateProvider ) ApplyChanges ( changes * plan . Changes ) error { managedZones , err := p . getZones ( ) if err != nil { return err } recordSets := map [ string ] * recordSet { } for _ , ep := range changes . Create { addEndpoint ( ep , recordSets , false ) } for _ , ep := range changes . UpdateNew { addEndpoint ( ep , recordSets , false ) } for _ , ep := range changes . UpdateOld { addEndpoint ( ep , recordSets , true ) } for _ , ep := range changes . Delete { addEndpoint ( ep , recordSets , true ) } for _ , rs := range recordSets { if err2 := p . upsertRecordSet ( rs , managedZones ) ; err == nil { err = err2 } } return err } 
func ( p designateProvider ) upsertRecordSet ( rs * recordSet , managedZones map [ string ] string ) error { if rs . zoneID == " " { var err error rs . zoneID , err = p . getHostZoneID ( rs . dnsName , managedZones ) if err != nil { return err } if rs . zoneID == " " { log . Debugf ( " " , rs . dnsName ) return nil } } var records [ ] string for rec , v := range rs . names { if v { records = append ( records , rec ) } } if rs . recordSetID == " " && records == nil { return nil } if rs . recordSetID == " " { opts := recordsets . CreateOpts { Name : rs . dnsName , Type : rs . recordType , Records : records , } log . Infof ( " " , rs . dnsName , rs . recordType , strings . Join ( records , " " ) ) if p . dryRun { return nil } _ , err := p . client . CreateRecordSet ( rs . zoneID , opts ) return err } else if len ( records ) == 0 { log . Infof ( " " , rs . dnsName , rs . recordType ) if p . dryRun { return nil } return p . client . DeleteRecordSet ( rs . zoneID , rs . recordSetID ) } else { opts := recordsets . UpdateOpts { Records : records , } log . Infof ( " " , rs . dnsName , rs . recordType , strings . Join ( records , " " ) ) if p . dryRun { return nil } return p . client . UpdateRecordSet ( rs . zoneID , rs . recordSetID , opts ) } } 
func NewIstioGatewaySource ( kubeClient kubernetes . Interface , istioClient istiomodel . ConfigStore , istioIngressGatewayServices [ ] string , namespace string , annotationFilter string , fqdnTemplate string , combineFqdnAnnotation bool , ignoreHostnameAnnotation bool , ) ( Source , error ) { var ( tmpl * template . Template err error ) for _ , lbService := range istioIngressGatewayServices { if _ , _ , err = parseIngressGateway ( lbService ) ; err != nil { return nil , err } } if fqdnTemplate != " " { tmpl , err = template . New ( " " ) . Funcs ( template . FuncMap { " " : strings . TrimPrefix , } ) . Parse ( fqdnTemplate ) if err != nil { return nil , err } } return & gatewaySource { kubeClient : kubeClient , istioClient : istioClient , istioIngressGatewayServices : istioIngressGatewayServices , namespace : namespace , annotationFilter : annotationFilter , fqdnTemplate : tmpl , combineFQDNAnnotation : combineFqdnAnnotation , ignoreHostnameAnnotation : ignoreHostnameAnnotation , } , nil } 
func ( sc * gatewaySource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { configs , err := sc . istioClient . List ( istiomodel . Gateway . Type , sc . namespace ) if err != nil { return nil , err } configs , err = sc . filterByAnnotations ( configs ) if err != nil { return nil , err } endpoints := [ ] * endpoint . Endpoint { } for _ , config := range configs { if ok && controller != controllerAnnotationValue { log . Debugf ( " " , config . Namespace , config . Name , controller , controllerAnnotationValue ) continue } gwEndpoints , err := sc . endpointsFromGatewayConfig ( config ) if err != nil { return nil , err } if err != nil { return nil , err } if sc . combineFQDNAnnotation { gwEndpoints = append ( gwEndpoints , iEndpoints ... ) } else { gwEndpoints = iEndpoints } } if len ( gwEndpoints ) == 0 { log . Debugf ( " " , config . Namespace , config . Name ) continue } log . Debugf ( " " , config . Namespace , config . Name , gwEndpoints ) sc . setResourceLabel ( config , gwEndpoints ) endpoints = append ( endpoints , gwEndpoints ... ) } for _ , ep := range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * gatewaySource ) filterByAnnotations ( configs [ ] istiomodel . Config ) ( [ ] istiomodel . Config , error ) { labelSelector , err := metav1 . ParseToLabelSelector ( sc . annotationFilter ) if err != nil { return nil , err } selector , err := metav1 . LabelSelectorAsSelector ( labelSelector ) if err != nil { return nil , err } } filteredList := [ ] istiomodel . Config { } for _ , config := range configs { } } return filteredList , nil } 
func ( sc * gatewaySource ) endpointsFromGatewayConfig ( config istiomodel . Config ) ( [ ] * endpoint . Endpoint , error ) { var endpoints [ ] * endpoint . Endpoint ttl , err := getTTLFromAnnotations ( config . Annotations ) if err != nil { log . Warn ( err ) } targets := getTargetsFromTargetAnnotation ( config . Annotations ) if len ( targets ) == 0 { targets , err = sc . targetsFromIstioIngressGatewayServices ( ) if err != nil { return nil , err } } gateway := config . Spec . ( * istionetworking . Gateway ) providerSpecific := getProviderSpecificAnnotations ( config . Annotations ) for _ , server := range gateway . Servers { for _ , host := range server . Hosts { if host == " " { continue } endpoints = append ( endpoints , endpointsForHostname ( host , targets , ttl , providerSpecific ) ... ) } } for _ , hostname := range hostnameList { endpoints = append ( endpoints , endpointsForHostname ( hostname , targets , ttl , providerSpecific ) ... ) } } return endpoints , nil } 
func ( in * DNSEndpoint ) DeepCopyInto ( out * DNSEndpoint ) { * out = * in out . TypeMeta = in . TypeMeta in . ObjectMeta . DeepCopyInto ( & out . ObjectMeta ) in . Spec . DeepCopyInto ( & out . Spec ) out . Status = in . Status return } 
func ( in * DNSEndpoint ) DeepCopy ( ) * DNSEndpoint { if in == nil { return nil } out := new ( DNSEndpoint ) in . DeepCopyInto ( out ) return out } 
func ( in * DNSEndpoint ) DeepCopyObject ( ) runtime . Object { if c := in . DeepCopy ( ) ; c != nil { return c } return nil } 
func ( in * DNSEndpointList ) DeepCopyInto ( out * DNSEndpointList ) { * out = * in out . TypeMeta = in . TypeMeta out . ListMeta = in . ListMeta if in . Items != nil { in , out := & in . Items , & out . Items * out = make ( [ ] DNSEndpoint , len ( * in ) ) for i := range * in { ( * in ) [ i ] . DeepCopyInto ( & ( * out ) [ i ] ) } } return } 
func ( in * DNSEndpointList ) DeepCopy ( ) * DNSEndpointList { if in == nil { return nil } out := new ( DNSEndpointList ) in . DeepCopyInto ( out ) return out } 
func ( in * DNSEndpointList ) DeepCopyObject ( ) runtime . Object { if c := in . DeepCopy ( ) ; c != nil { return c } return nil } 
func ( in * DNSEndpointSpec ) DeepCopyInto ( out * DNSEndpointSpec ) { * out = * in if in . Endpoints != nil { in , out := & in . Endpoints , & out . Endpoints * out = make ( [ ] * Endpoint , len ( * in ) ) for i := range * in { if ( * in ) [ i ] == nil { ( * out ) [ i ] = nil } else { ( * out ) [ i ] = new ( Endpoint ) ( * in ) [ i ] . DeepCopyInto ( ( * out ) [ i ] ) } } } return } 
func ( in * DNSEndpointSpec ) DeepCopy ( ) * DNSEndpointSpec { if in == nil { return nil } out := new ( DNSEndpointSpec ) in . DeepCopyInto ( out ) return out } 
func ( in * DNSEndpointStatus ) DeepCopy ( ) * DNSEndpointStatus { if in == nil { return nil } out := new ( DNSEndpointStatus ) in . DeepCopyInto ( out ) return out } 
func ( in * Endpoint ) DeepCopyInto ( out * Endpoint ) { * out = * in if in . Targets != nil { in , out := & in . Targets , & out . Targets * out = make ( Targets , len ( * in ) ) copy ( * out , * in ) } if in . Labels != nil { in , out := & in . Labels , & out . Labels * out = make ( Labels , len ( * in ) ) for key , val := range * in { ( * out ) [ key ] = val } } if in . ProviderSpecific != nil { in , out := & in . ProviderSpecific , & out . ProviderSpecific * out = make ( ProviderSpecific , len ( * in ) ) for key , val := range * in { ( * out ) [ key ] = val } } return } 
func ( in * Endpoint ) DeepCopy ( ) * Endpoint { if in == nil { return nil } out := new ( Endpoint ) in . DeepCopyInto ( out ) return out } 
func ( in Labels ) DeepCopyInto ( out * Labels ) { { in := & in * out = make ( Labels , len ( * in ) ) for key , val := range * in { ( * out ) [ key ] = val } return } } 
func ( in Labels ) DeepCopy ( ) Labels { if in == nil { return nil } out := new ( Labels ) in . DeepCopyInto ( out ) return * out } 
func ( in ProviderSpecific ) DeepCopyInto ( out * ProviderSpecific ) { { in := & in * out = make ( ProviderSpecific , len ( * in ) ) for key , val := range * in { ( * out ) [ key ] = val } return } } 
func ( in ProviderSpecific ) DeepCopy ( ) ProviderSpecific { if in == nil { return nil } out := new ( ProviderSpecific ) in . DeepCopyInto ( out ) return * out } 
func ( in Targets ) DeepCopyInto ( out * Targets ) { { in := & in * out = make ( Targets , len ( * in ) ) copy ( * out , * in ) return } } 
func ( in Targets ) DeepCopy ( ) Targets { if in == nil { return nil } out := new ( Targets ) in . DeepCopyInto ( out ) return * out } 
func ensureTrailingDot ( hostname string ) string { if net . ParseIP ( hostname ) != nil { return hostname } return strings . TrimSuffix ( hostname , " " ) + " " } 
func NewNoopRegistry ( provider provider . Provider ) ( * NoopRegistry , error ) { return & NoopRegistry { provider : provider , } , nil } 
func ( im * NoopRegistry ) ApplyChanges ( changes * plan . Changes ) error { return im . provider . ApplyChanges ( changes ) } 
func ( ms * dedupSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { result := [ ] * endpoint . Endpoint { } collected := map [ string ] bool { } endpoints , err := ms . source . Endpoints ( ) if err != nil { return nil , err } for _ , ep := range endpoints { identifier := ep . DNSName + " " + ep . Targets . String ( ) if _ , ok := collected [ identifier ] ; ok { log . Debugf ( " " , ep ) continue } collected [ identifier ] = true result = append ( result , ep ) } return result , nil } 
func NewFakeSource ( fqdnTemplate string ) ( Source , error ) { if fqdnTemplate == " " { fqdnTemplate = defaultFQDNTemplate } return & fakeSource { dnsName : fqdnTemplate , } , nil } 
func ( sc * fakeSource ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints := make ( [ ] * endpoint . Endpoint , 10 ) for i := 0 ; i < 10 ; i ++ { endpoints [ i ] , _ = sc . generateEndpoint ( ) } return endpoints , nil } 
func CreateTLSConfig ( prefix string ) ( * tls . Config , error ) { caFile := os . Getenv ( fmt . Sprintf ( " " , prefix ) ) certFile := os . Getenv ( fmt . Sprintf ( " " , prefix ) ) keyFile := os . Getenv ( fmt . Sprintf ( " " , prefix ) ) serverName := os . Getenv ( fmt . Sprintf ( " " , prefix ) ) isInsecureStr := strings . ToLower ( os . Getenv ( fmt . Sprintf ( " " , prefix ) ) ) isInsecure := isInsecureStr == " " || isInsecureStr == " " || isInsecureStr == " " tlsConfig , err := NewTLSConfig ( certFile , keyFile , caFile , serverName , isInsecure , defaultMinVersion ) if err != nil { return nil , err } return tlsConfig , nil } 
func NewAWSSDRegistry ( provider provider . Provider , ownerID string ) ( * AWSSDRegistry , error ) { if ownerID == " " { return nil , errors . New ( " " ) } return & AWSSDRegistry { provider : provider , ownerID : ownerID , } , nil } 
func ( sdr * AWSSDRegistry ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { records , err := sdr . provider . Records ( ) if err != nil { return nil , err } for _ , record := range records { labels , err := endpoint . NewLabelsFromString ( record . Labels [ endpoint . AWSSDDescriptionLabel ] ) if err != nil { continue } record . Labels = labels } return records , nil } 
func ( sdr * AWSSDRegistry ) ApplyChanges ( changes * plan . Changes ) error { filteredChanges := & plan . Changes { Create : changes . Create , UpdateNew : filterOwnedRecords ( sdr . ownerID , changes . UpdateNew ) , UpdateOld : filterOwnedRecords ( sdr . ownerID , changes . UpdateOld ) , Delete : filterOwnedRecords ( sdr . ownerID , changes . Delete ) , } sdr . updateLabels ( filteredChanges . Create ) sdr . updateLabels ( filteredChanges . UpdateNew ) sdr . updateLabels ( filteredChanges . UpdateOld ) sdr . updateLabels ( filteredChanges . Delete ) return sdr . provider . ApplyChanges ( filteredChanges ) } 
func LoadOCIConfig ( path string ) ( * OCIConfig , error ) { contents , err := ioutil . ReadFile ( path ) if err != nil { return nil , errors . Wrapf ( err , " " , path ) } cfg := OCIConfig { } if err := yaml . Unmarshal ( contents , & cfg ) ; err != nil { return nil , errors . Wrapf ( err , " " , path ) } return & cfg , nil } 
func NewOCIProvider ( cfg OCIConfig , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , dryRun bool ) ( * OCIProvider , error ) { var client ociDNSClient client , err := dns . NewDnsClientWithConfigurationProvider ( common . NewRawConfigurationProvider ( cfg . Auth . TenancyID , cfg . Auth . UserID , cfg . Auth . Region , cfg . Auth . Fingerprint , cfg . Auth . PrivateKey , & cfg . Auth . Passphrase , ) ) if err != nil { return nil , errors . Wrap ( err , " " ) } return & OCIProvider { client : client , cfg : cfg , domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , } , nil } 
func ( p * OCIProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { ctx := context . Background ( ) zones , err := p . zones ( ctx ) if err != nil { return nil , errors . Wrap ( err , " " ) } endpoints := [ ] * endpoint . Endpoint { } for _ , zone := range zones { var page * string for { resp , err := p . client . GetZoneRecords ( ctx , dns . GetZoneRecordsRequest { ZoneNameOrId : zone . Id , Page : page , CompartmentId : & p . cfg . CompartmentID , } ) if err != nil { return nil , errors . Wrapf ( err , " " , * zone . Id ) } for _ , record := range resp . Items { if ! supportedRecordType ( * record . Rtype ) { continue } endpoints = append ( endpoints , endpoint . NewEndpointWithTTL ( * record . Domain , * record . Rtype , endpoint . TTL ( * record . Ttl ) , * record . Rdata , ) , ) } if page = resp . OpcNextPage ; resp . OpcNextPage == nil { break } } } return endpoints , nil } 
func ( p * OCIProvider ) ApplyChanges ( changes * plan . Changes ) error { log . Debugf ( " " , changes ) ops := [ ] dns . RecordOperation { } ops = append ( ops , p . newFilteredRecordOperations ( changes . Create , dns . RecordOperationOperationAdd ) ... ) ops = append ( ops , p . newFilteredRecordOperations ( changes . UpdateNew , dns . RecordOperationOperationAdd ) ... ) ops = append ( ops , p . newFilteredRecordOperations ( changes . UpdateOld , dns . RecordOperationOperationRemove ) ... ) ops = append ( ops , p . newFilteredRecordOperations ( changes . Delete , dns . RecordOperationOperationRemove ) ... ) if len ( ops ) == 0 { log . Info ( " " ) return nil } ctx := context . Background ( ) zones , err := p . zones ( ctx ) if err != nil { return errors . Wrap ( err , " " ) } for zoneID , ops := range opsByZone { log . Infof ( " " , zoneID ) for _ , op := range ops { log . Info ( op ) } } if p . dryRun { return nil } for zoneID , ops := range opsByZone { if _ , err := p . client . PatchZoneRecords ( ctx , dns . PatchZoneRecordsRequest { CompartmentId : & p . cfg . CompartmentID , ZoneNameOrId : & zoneID , PatchZoneRecordsDetails : dns . PatchZoneRecordsDetails { Items : ops } , } ) ; err != nil { return err } } return nil } 
func newRecordOperation ( ep * endpoint . Endpoint , opType dns . RecordOperationOperationEnum ) dns . RecordOperation { targets := make ( [ ] string , len ( ep . Targets ) ) copy ( targets , [ ] string ( ep . Targets ) ) if ep . RecordType == endpoint . RecordTypeCNAME { targets [ 0 ] = ensureTrailingDot ( targets [ 0 ] ) } rdata := strings . Join ( targets , " " ) ttl := ociRecordTTL if ep . RecordTTL . IsConfigured ( ) { ttl = int ( ep . RecordTTL ) } return dns . RecordOperation { Domain : & ep . DNSName , Rdata : & rdata , Ttl : & ttl , Rtype : & ep . RecordType , Operation : opType , } } 
func operationsByZone ( zones map [ string ] * dns . ZoneSummary , ops [ ] dns . RecordOperation ) map [ string ] [ ] dns . RecordOperation { changes := make ( map [ string ] [ ] dns . RecordOperation ) zoneNameIDMapper := zoneIDName { } for _ , z := range zones { zoneNameIDMapper . Add ( * z . Id , * z . Name ) changes [ * z . Id ] = [ ] dns . RecordOperation { } } for _ , op := range ops { if zoneID , _ := zoneNameIDMapper . FindZone ( * op . Domain ) ; zoneID != " " { changes [ zoneID ] = append ( changes [ zoneID ] , op ) } else { log . Warnf ( " " , op ) } } } } return changes } 
func NewAzureProvider ( configFile string , domainFilter DomainFilter , zoneIDFilter ZoneIDFilter , resourceGroup string , dryRun bool ) ( * AzureProvider , error ) { contents , err := ioutil . ReadFile ( configFile ) if err != nil { return nil , fmt . Errorf ( " " , configFile , err ) } cfg := config { } err = yaml . Unmarshal ( contents , & cfg ) if err != nil { return nil , fmt . Errorf ( " " , configFile , err ) } } var environment azure . Environment if cfg . Cloud == " " { environment = azure . PublicCloud } else { environment , err = azure . EnvironmentFromName ( cfg . Cloud ) if err != nil { return nil , fmt . Errorf ( " " , cfg . Cloud , err ) } } token , err := getAccessToken ( cfg , environment ) if err != nil { return nil , fmt . Errorf ( " " , err ) } zonesClient := dns . NewZonesClientWithBaseURI ( environment . ResourceManagerEndpoint , cfg . SubscriptionID ) zonesClient . Authorizer = autorest . NewBearerAuthorizer ( token ) recordsClient := dns . NewRecordSetsClientWithBaseURI ( environment . ResourceManagerEndpoint , cfg . SubscriptionID ) recordsClient . Authorizer = autorest . NewBearerAuthorizer ( token ) provider := & AzureProvider { domainFilter : domainFilter , zoneIDFilter : zoneIDFilter , dryRun : dryRun , resourceGroup : cfg . ResourceGroup , zonesClient : zonesClient , recordsClient : recordsClient , } return provider , nil } 
func getAccessToken ( cfg config , environment azure . Environment ) ( * adal . ServicePrincipalToken , error ) { msiEndpoint , err := adal . GetMSIVMEndpoint ( ) if err != nil { return nil , fmt . Errorf ( " " , err ) } token , err := adal . NewServicePrincipalTokenFromMSI ( msiEndpoint , environment . ServiceManagementEndpoint ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return token , nil } oauthConfig , err := adal . NewOAuthConfig ( environment . ActiveDirectoryEndpoint , cfg . TenantID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } token , err := adal . NewServicePrincipalToken ( * oauthConfig , cfg . ClientID , cfg . ClientSecret , environment . ResourceManagerEndpoint ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return token , nil } return nil , fmt . Errorf ( " " ) } 
func ( p * AzureProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err := p . zones ( ) if err != nil { return nil , err } for _ , zone := range zones { err := p . iterateRecords ( * zone . Name , func ( recordSet dns . RecordSet ) bool { if recordSet . Name == nil || recordSet . Type == nil { log . Error ( " " ) return true } recordType := strings . TrimLeft ( * recordSet . Type , " " ) if ! supportedRecordType ( recordType ) { return true } name := formatAzureDNSName ( * recordSet . Name , * zone . Name ) targets := extractAzureTargets ( & recordSet ) if len ( targets ) == 0 { log . Errorf ( " " , name , recordType ) return true } var ttl endpoint . TTL if recordSet . TTL != nil { ttl = endpoint . TTL ( * recordSet . TTL ) } ep := endpoint . NewEndpointWithTTL ( name , recordType , endpoint . TTL ( ttl ) , targets ... ) log . Debugf ( " " , ep . RecordType , ep . DNSName , ep . Targets , ) endpoints = append ( endpoints , ep ) return true } ) if err != nil { return nil , err } } return endpoints , nil } 
func ( p * AzureProvider ) ApplyChanges ( changes * plan . Changes ) error { zones , err := p . zones ( ) if err != nil { return err } deleted , updated := p . mapChanges ( zones , changes ) p . deleteRecords ( deleted ) p . updateRecords ( updated ) return nil } 
func formatAzureDNSName ( recordName , zoneName string ) string { if recordName == " " { return zoneName } return fmt . Sprintf ( " " , recordName , zoneName ) } 
func extractAzureTargets ( recordSet * dns . RecordSet ) [ ] string { properties := recordSet . RecordSetProperties if properties == nil { return [ ] string { } } if aRecords != nil && len ( * aRecords ) > 0 && ( * aRecords ) [ 0 ] . Ipv4Address != nil { targets := make ( [ ] string , len ( * aRecords ) ) for i , aRecord := range * aRecords { targets [ i ] = * aRecord . Ipv4Address } return targets } if cnameRecord != nil && cnameRecord . Cname != nil { return [ ] string { * cnameRecord . Cname } } if txtRecords != nil && len ( * txtRecords ) > 0 && ( * txtRecords ) [ 0 ] . Value != nil { values := ( * txtRecords ) [ 0 ] . Value if values != nil && len ( * values ) > 0 { return [ ] string { ( * values ) [ 0 ] } } } return [ ] string { } } 
func ( c * defaultDiskCreator ) Create ( size int , publicSSHKeyPath , diskPath string ) error { log . Debugf ( " " , size ) tarBuf , err := mcnutils . MakeDiskImage ( publicSSHKeyPath ) if err != nil { return err } log . Debug ( " " ) return createDiskImage ( diskPath , size , tarBuf ) } 
func createDiskImage ( dest string , size int , r io . Reader ) error { log . Debug ( cmd ) if os . Getenv ( " " ) != " " { cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr } stdin , err := cmd . StdinPipe ( ) if err != nil { return err } log . Debug ( " " ) if err := cmd . Start ( ) ; err != nil { return err } log . Debug ( " " ) n , err := io . Copy ( stdin , r ) if err != nil { return err } log . Debug ( " " ) } } log . Debug ( " " ) } log . Debug ( " " ) return cmd . Wait ( ) } 
func ( n * hostOnlyNetwork ) Save ( vbox VBoxManager ) error { if err := n . SaveIPv4 ( vbox ) ; err != nil { return err } if n . DHCP { vbox . vbm ( " " , " " , n . Name , " " ) } return nil } 
func ( n * hostOnlyNetwork ) SaveIPv4 ( vbox VBoxManager ) error { if n . IPv4 . IP != nil && n . IPv4 . Mask != nil { if runtime . GOOS == " " { log . Warn ( " " ) } if err := vbox . vbm ( " " , " " , n . Name , " " , n . IPv4 . IP . String ( ) , " " , net . IP ( n . IPv4 . Mask ) . String ( ) ) ; err != nil { return err } } return nil } 
func createHostonlyAdapter ( vbox VBoxManager ) ( * hostOnlyNetwork , error ) { if runtime . GOOS == " " { log . Warn ( " " ) } out , err := vbox . vbmOut ( " " , " " ) if err != nil { return nil , err } res := reHostOnlyAdapterCreated . FindStringSubmatch ( string ( out ) ) if res == nil { return nil , errors . New ( " " ) } return & hostOnlyNetwork { Name : res [ 1 ] } , nil } 
func listHostOnlyAdapters ( vbox VBoxManager ) ( map [ string ] * hostOnlyNetwork , error ) { out , err := vbox . vbmOut ( " " , " " ) if err != nil { return nil , err } byName := map [ string ] * hostOnlyNetwork { } byIP := map [ string ] * hostOnlyNetwork { } n := & hostOnlyNetwork { } err = parseKeyValues ( out , reColonLine , func ( key , val string ) error { switch key { case " " : n . Name = val case " " : n . GUID = val case " " : n . DHCP = ( val != " " ) case " " : n . IPv4 . IP = net . ParseIP ( val ) case " " : n . IPv4 . Mask = parseIPv4Mask ( val ) case " " : mac , err := net . ParseMAC ( val ) if err != nil { return err } n . HwAddr = mac case " " : n . Medium = val case " " : n . Status = val case " " : n . NetworkName = val if _ , present := byName [ n . NetworkName ] ; present { return fmt . Errorf ( " " , n . NetworkName ) } byName [ n . NetworkName ] = n if len ( n . IPv4 . IP ) != 0 { if _ , present := byIP [ n . IPv4 . IP . String ( ) ] ; present { return fmt . Errorf ( " " , n . IPv4 . IP ) } byIP [ n . IPv4 . IP . String ( ) ] = n } n = & hostOnlyNetwork { } } return nil } ) if err != nil { return nil , err } return byName , nil } 
func removeOrphanDHCPServers ( vbox VBoxManager ) error { dhcps , err := listDHCPServers ( vbox ) if err != nil { return err } if len ( dhcps ) == 0 { return nil } log . Debug ( " " ) nets , err := listHostOnlyAdapters ( vbox ) if err != nil { return err } for name := range dhcps { if strings . HasPrefix ( name , dhcpPrefix ) { if _ , present := nets [ name ] ; ! present { if err := vbox . vbm ( " " , " " , " " , name ) ; err != nil { log . Warnf ( " " , name , err ) } } } } return nil } 
func addHostOnlyDHCPServer ( ifname string , d dhcpServer , vbox VBoxManager ) error { name := dhcpPrefix + ifname dhcps , err := listDHCPServers ( vbox ) if err != nil { return err } if dhcp , ok := dhcps [ name ] ; ok { command = " " if ( dhcp . IPv4 . IP . Equal ( d . IPv4 . IP ) ) && ( dhcp . IPv4 . Mask . String ( ) == d . IPv4 . Mask . String ( ) ) && ( dhcp . LowerIP . Equal ( d . LowerIP ) ) && ( dhcp . UpperIP . Equal ( d . UpperIP ) ) && ( dhcp . Enabled == d . Enabled ) { } } args := [ ] string { " " , command , " " , name , " " , d . IPv4 . IP . String ( ) , " " , net . IP ( d . IPv4 . Mask ) . String ( ) , " " , d . LowerIP . String ( ) , " " , d . UpperIP . String ( ) , } if d . Enabled { args = append ( args , " " ) } else { args = append ( args , " " ) } if runtime . GOOS == " " { log . Warn ( " " ) } return vbox . vbm ( args ... ) } 
func listDHCPServers ( vbox VBoxManager ) ( map [ string ] * dhcpServer , error ) { out , err := vbox . vbmOut ( " " , " " ) if err != nil { return nil , err } m := map [ string ] * dhcpServer { } dhcp := & dhcpServer { } err = parseKeyValues ( out , reColonLine , func ( key , val string ) error { switch key { case " " : dhcp = & dhcpServer { } m [ val ] = dhcp dhcp . NetworkName = val case " " : dhcp . IPv4 . IP = net . ParseIP ( val ) case " " : dhcp . UpperIP = net . ParseIP ( val ) case " " : dhcp . LowerIP = net . ParseIP ( val ) case " " : dhcp . IPv4 . Mask = parseIPv4Mask ( val ) case " " : dhcp . Enabled = ( val == " " ) } return nil } ) if err != nil { return nil , err } return m , nil } 
func listHostInterfaces ( hif HostInterfaces , excludeNets map [ string ] * hostOnlyNetwork ) ( map [ string ] * net . IPNet , error ) { ifaces , err := hif . Interfaces ( ) if err != nil { return nil , err } m := map [ string ] * net . IPNet { } for _ , iface := range ifaces { addrs , err := hif . Addrs ( & iface ) if err != nil { return nil , err } for _ , a := range addrs { switch ipnet := a . ( type ) { case * net . IPNet : _ , excluded := excludeNets [ ipnet . String ( ) ] if excluded { ifaceExcluded = true break } } } } } } } return m , nil } 
func checkIPNetCollision ( hostonly * net . IPNet , hostIfaces map [ string ] * net . IPNet ) ( bool , error ) { for _ , ifaceNet := range hostIfaces { if hostonly . IP . Equal ( ifaceNet . IP . Mask ( ifaceNet . Mask ) ) { return true , nil } } return false , nil } 
func parseIPv4Mask ( s string ) net . IPMask { mask := net . ParseIP ( s ) if mask == nil { return nil } return net . IPv4Mask ( mask [ 12 ] , mask [ 13 ] , mask [ 14 ] , mask [ 15 ] ) } 
func NewDriverNotSupported ( driverName , hostName , storePath string ) Driver { return & DriverNotSupported { BaseDriver : & BaseDriver { MachineName : hostName , StorePath : storePath , } , Name : driverName , } } 
func ( c * RPCClientDriver ) rpcStringCall ( method string ) ( string , error ) { var info string if err := c . Client . Call ( method , struct { } { } , & info ) ; err != nil { return " " , err } return info , nil } 
func ( c * RPCClientDriver ) DriverName ( ) string { driverName , err := c . rpcStringCall ( DriverNameMethod ) if err != nil { log . Warnf ( " " , err ) } return driverName } 
func ( c * RPCClientDriver ) GetSSHKeyPath ( ) string { path , err := c . rpcStringCall ( GetSSHKeyPathMethod ) if err != nil { log . Warnf ( " " , err ) } return path } 
func MustBeRunning ( d Driver ) error { s , err := d . GetState ( ) if err != nil { return err } if s != state . Running { return ErrHostIsNotRunning } return nil } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . IntFlag { Name : " " , Usage : " " , Value : engine . DefaultPort , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : drivers . DefaultSSHUser , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : " " , EnvVar : " " , } , mcnflag . IntFlag { Name : " " , Usage : " " , Value : drivers . DefaultSSHPort , EnvVar : " " , } , } } 
func NewDriver ( hostName , storePath string ) drivers . Driver { return & Driver { EnginePort : engine . DefaultPort , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } } 
func powerStateFromInstanceView ( instanceView * compute . VirtualMachineInstanceView ) VMPowerState { if instanceView == nil { log . Debug ( " " ) return Unknown } else if instanceView . Statuses == nil || len ( * instanceView . Statuses ) == 0 { log . Debug ( " " ) return Unknown } statuses := * instanceView . Statuses for _ , v := range statuses { log . Debugf ( " " , to . String ( v . Code ) ) if strings . HasPrefix ( to . String ( v . Code ) , powerStateCodePrefix ) { log . Debug ( " " ) s = & v break } } if s == nil { log . Debug ( " " ) return Unknown } code := strings . TrimPrefix ( to . String ( s . Code ) , powerStateCodePrefix ) switch code { case " " : return Stopped case " " : return Stopping case " " : return Starting case " " : return Running case " " : return Deallocated case " " : return Deallocating default : log . Warn ( " " , code ) return Unknown } } 
func migrateStringToSlice ( value string , values [ ] string ) ( result [ ] string ) { if value != " " { result = append ( result , value ) } result = append ( result , values ... ) return } 
func DockerClient ( dockerHost DockerHost ) ( * dockerclient . DockerClient , error ) { url , err := dockerHost . URL ( ) if err != nil { return nil , err } tlsConfig , err := cert . ReadTLSConfig ( url , dockerHost . AuthOptions ( ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return dockerclient . NewDockerClient ( url , tlsConfig ) } 
func CreateContainer ( dockerHost DockerHost , config * dockerclient . ContainerConfig , name string ) error { docker , err := DockerClient ( dockerHost ) if err != nil { return err } if err = docker . PullImage ( config . Image , nil ) ; err != nil { return fmt . Errorf ( " " , err ) } var authConfig * dockerclient . AuthConfig containerID , err := docker . CreateContainer ( config , name , authConfig ) if err != nil { return fmt . Errorf ( " " , err ) } if err = docker . StartContainer ( containerID , & config . HostConfig ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( a AzureClient ) cleanupResourceIfExists ( r cleanupResource ) error { f := r . LogFields ( ) log . Info ( fmt . Sprintf ( " " , r . ResourceType ( ) ) , f ) err := r . Get ( a ) if exists , err := checkResourceExistsFromError ( err ) ; err != nil { return err } else if ! exists { log . Debug ( fmt . Sprintf ( " " , r . ResourceType ( ) ) , f ) return nil } if ! r . HasAttachedResources ( ) { log . Debug ( fmt . Sprintf ( " " , r . ResourceType ( ) ) , f ) log . Info ( fmt . Sprintf ( " " , r . ResourceType ( ) ) , f ) return r . Delete ( a ) } log . Info ( fmt . Sprintf ( " " , r . ResourceType ( ) ) , f ) return nil } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Value : defaultInstanceProfile , Usage : " " , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Value : defaultDiskSize , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Value : defaultImage , Usage : " " , } , mcnflag . StringSliceFlag { EnvVar : " " , Name : " " , Value : [ ] string { defaultSecurityGroup } , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Value : defaultAvailabilityZone , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Value : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Value : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringSliceFlag { EnvVar : " " , Name : " " , Value : [ ] string { } , Usage : " " , } , } } 
func NewDriver ( machineName , storePath string ) drivers . Driver { return & Driver { InstanceProfile : defaultInstanceProfile , DiskSize : defaultDiskSize , Image : defaultImage , AvailabilityZone : defaultAvailabilityZone , BaseDriver : & drivers . BaseDriver { MachineName : machineName , StorePath : storePath , } , } } 
func ( d * Driver ) GetSSHUsername ( ) string { if d . SSHUser == " " { name := strings . ToLower ( d . Image ) if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } return defaultSSHUser } return d . SSHUser } 
func ( d * Driver ) SetConfigFromFlags ( flags drivers . DriverOptions ) error { d . URL = flags . String ( " " ) d . APIKey = flags . String ( " " ) d . APISecretKey = flags . String ( " " ) d . InstanceProfile = flags . String ( " " ) d . DiskSize = int64 ( flags . Int ( " " ) ) d . Image = flags . String ( " " ) d . SecurityGroups = flags . StringSlice ( " " ) d . AffinityGroups = flags . StringSlice ( " " ) d . AvailabilityZone = flags . String ( " " ) d . SSHUser = flags . String ( " " ) d . SSHKey = flags . String ( " " ) d . UserDataFile = flags . String ( " " ) d . UserData = [ ] byte ( defaultCloudInit ) d . SetSwarmConfigFromFlags ( flags ) if d . URL == " " { d . URL = defaultAPIEndpoint } if d . APIKey == " " || d . APISecretKey == " " { return errors . New ( " " ) } return nil } 
func ( d * Driver ) PreCreateCheck ( ) error { if d . UserDataFile != " " { if _ , err := os . Stat ( d . UserDataFile ) ; os . IsNotExist ( err ) { return fmt . Errorf ( " " , d . UserDataFile ) } } return nil } 
func ( d * Driver ) GetState ( ) ( state . State , error ) { vm , err := d . virtualMachine ( ) if err != nil { return state . Error , err } switch vm . State { case " " : return state . Starting , nil case " " : return state . Running , nil case " " : return state . Running , nil case " " : return state . Stopped , nil case " " : return state . Stopped , nil case " " : return state . Stopped , nil case " " : return state . Paused , nil case " " : return state . Error , nil case " " : return state . Error , nil case " " : return state . Stopped , nil } return state . None , nil } 
func ( d * Driver ) Create ( ) error { cloudInit , err := d . getCloudInit ( ) if err != nil { return err } log . Infof ( " " ) client := egoscale . NewClient ( d . URL , d . APIKey , d . APISecretKey ) resp , err := client . RequestWithContext ( context . TODO ( ) , & egoscale . ListZones { Name : d . AvailabilityZone , } ) if err != nil { return err } zones := resp . ( * egoscale . ListZonesResponse ) if len ( zones . Zone ) != 1 { return fmt . Errorf ( " " , d . AvailabilityZone ) } zone := zones . Zone [ 0 ] . ID log . Debugf ( " " , d . AvailabilityZone , zone ) templates , err := client . ListWithContext ( context . TODO ( ) , & template ) if err != nil { return err } image := strings . ToLower ( d . Image ) re := regexp . MustCompile ( `^Linux (?P<name>.+?) (?P<version>[0-9.]+)\b` ) for _ , t := range templates { tpl := t . ( * egoscale . Template ) } fullname := strings . ToLower ( tpl . Name ) if image == fullname { template = * tpl break } submatch := re . FindStringSubmatch ( tpl . Name ) if len ( submatch ) > 0 { name := strings . Replace ( strings . ToLower ( submatch [ 1 ] ) , " " , " " , - 1 ) version := submatch [ 2 ] shortname := fmt . Sprintf ( " " , name , version ) if image == shortname { template = * tpl break } } } if template . ID == " " { return fmt . Errorf ( " " , d . Image ) } } log . Debugf ( " " , d . Image , template . ID , d . SSHUser ) if err != nil { return err } profiles := resp . ( * egoscale . ListServiceOfferingsResponse ) if len ( profiles . ServiceOffering ) != 1 { return fmt . Errorf ( " " , d . InstanceProfile ) } profile := profiles . ServiceOffering [ 0 ] . ID log . Debugf ( " " , d . InstanceProfile , profile ) for _ , group := range d . SecurityGroups { if group == " " { continue } sg := & egoscale . SecurityGroup { Name : group } if err := client . Get ( sg ) ; err != nil { if _ , ok := err . ( * egoscale . ErrorResponse ) ; ! ok { return err } log . Infof ( " " , group ) securityGroup , err := d . createDefaultSecurityGroup ( group ) if err != nil { return err } sg . ID = securityGroup . ID } log . Debugf ( " " , group , sg . ID ) sgs = append ( sgs , sg . ID ) } for _ , group := range d . AffinityGroups { if group == " " { continue } ag := & egoscale . AffinityGroup { Name : group } if err := client . Get ( ag ) ; err != nil { if _ , ok := err . ( * egoscale . ErrorResponse ) ; ! ok { return err } log . Infof ( " " , group ) affinityGroup , err := d . createDefaultAffinityGroup ( group ) if err != nil { return err } ag . ID = affinityGroup . ID } log . Debugf ( " " , group , ag . ID ) ags = append ( ags , ag . ID ) } keyPairName = fmt . Sprintf ( " " , d . MachineName ) log . Infof ( " " ) resp , err := client . RequestWithContext ( context . TODO ( ) , & egoscale . CreateSSHKeyPair { Name : keyPairName , } ) if err != nil { return fmt . Errorf ( " " , err ) } keyPair := resp . ( * egoscale . CreateSSHKeyPairResponse ) . KeyPair if err = os . MkdirAll ( filepath . Dir ( d . GetSSHKeyPath ( ) ) , 0750 ) ; err != nil { return fmt . Errorf ( " " , err ) } if err = ioutil . WriteFile ( d . GetSSHKeyPath ( ) , [ ] byte ( keyPair . PrivateKey ) , 0600 ) ; err != nil { return fmt . Errorf ( " " , err ) } d . KeyPair = keyPairName } else { log . Infof ( " " , d . SSHKey ) sshKey := d . SSHKey if strings . HasPrefix ( sshKey , " " ) { usr , _ := user . Current ( ) sshKey = filepath . Join ( usr . HomeDir , sshKey [ 2 : ] ) } else { var err error if sshKey , err = filepath . Abs ( sshKey ) ; err != nil { return err } } if err != nil { return fmt . Errorf ( " " , err ) } sshAuthorizedKeys := ` ssh_authorized_keys: - ` cloudInit = bytes . Join ( [ ] [ ] byte { cloudInit , [ ] byte ( sshAuthorizedKeys ) , pubKey } , [ ] byte ( " " ) ) } if err := os . Chmod ( d . GetSSHKeyPath ( ) , 0600 ) ; err != nil { return fmt . Errorf ( " " , err ) } } log . Infof ( " " ) log . Debugf ( " " ) log . Debugf ( " " , string ( cloudInit ) ) encodedUserData := base64 . StdEncoding . EncodeToString ( d . UserData ) req := & egoscale . DeployVirtualMachine { TemplateID : template . ID , ServiceOfferingID : profile , UserData : encodedUserData , ZoneID : zone , Name : d . MachineName , KeyPair : d . KeyPair , DisplayName : d . MachineName , RootDiskSize : d . DiskSize , SecurityGroupIDs : sgs , AffinityGroupIDs : ags , } log . Infof ( " " , req ) resp , err = client . RequestWithContext ( context . TODO ( ) , req ) if err != nil { return err } vm := resp . ( * egoscale . DeployVirtualMachineResponse ) . VirtualMachine IPAddress := vm . Nic [ 0 ] . IPAddress if IPAddress != nil { d . IPAddress = IPAddress . String ( ) } d . ID = vm . ID log . Infof ( " " , d . IPAddress , d . GetSSHUsername ( ) ) if vm . PasswordEnabled { d . Password = vm . Password } } key := & egoscale . SSHKeyPair { Name : d . KeyPair , } if err := client . DeleteWithContext ( context . TODO ( ) , key ) ; err != nil { return err } d . KeyPair = " " } return nil } 
func ( d * Driver ) Start ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . StartVirtualMachine { ID : d . ID , } ) return err } 
func ( d * Driver ) Stop ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . StopVirtualMachine { ID : d . ID , } ) return err } 
func ( d * Driver ) Restart ( ) error { cs := d . client ( ) _ , err := cs . RequestWithContext ( context . TODO ( ) , & egoscale . RebootVirtualMachine { ID : d . ID , } ) return err } 
func ( d * Driver ) Remove ( ) error { client := d . client ( ) if err := client . DeleteWithContext ( context . TODO ( ) , key ) ; err != nil { return err } } if err := client . DeleteWithContext ( context . TODO ( ) , vm ) ; err != nil { return err } } log . Infof ( " " ) return nil } 
func ( d * Driver ) getCloudInit ( ) ( [ ] byte , error ) { var err error if d . UserDataFile != " " { d . UserData , err = ioutil . ReadFile ( d . UserDataFile ) } return d . UserData , err } 
func ( xcg * X509CertGenerator ) GenerateCACertificate ( certFile , keyFile , org string , bits int ) error { template , err := xcg . newCertificate ( org ) if err != nil { return err } template . IsCA = true template . KeyUsage |= x509 . KeyUsageCertSign template . KeyUsage |= x509 . KeyUsageKeyEncipherment template . KeyUsage |= x509 . KeyUsageKeyAgreement priv , err := rsa . GenerateKey ( rand . Reader , bits ) if err != nil { return err } derBytes , err := x509 . CreateCertificate ( rand . Reader , template , template , & priv . PublicKey , priv ) if err != nil { return err } certOut , err := os . Create ( certFile ) if err != nil { return err } pem . Encode ( certOut , & pem . Block { Type : " " , Bytes : derBytes } ) certOut . Close ( ) keyOut , err := os . OpenFile ( keyFile , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0600 ) if err != nil { return err } pem . Encode ( keyOut , & pem . Block { Type : " " , Bytes : x509 . MarshalPKCS1PrivateKey ( priv ) } ) keyOut . Close ( ) return nil } 
func ( xcg * X509CertGenerator ) GenerateCert ( opts * Options ) error { template , err := xcg . newCertificate ( opts . Org ) if err != nil { return err } template . KeyUsage = x509 . KeyUsageDigitalSignature } else { if opts . SwarmMaster { } for _ , h := range opts . Hosts { if ip := net . ParseIP ( h ) ; ip != nil { template . IPAddresses = append ( template . IPAddresses , ip ) } else { template . DNSNames = append ( template . DNSNames , h ) } } } tlsCert , err := tls . LoadX509KeyPair ( opts . CAFile , opts . CAKeyFile ) if err != nil { return err } priv , err := rsa . GenerateKey ( rand . Reader , opts . Bits ) if err != nil { return err } x509Cert , err := x509 . ParseCertificate ( tlsCert . Certificate [ 0 ] ) if err != nil { return err } derBytes , err := x509 . CreateCertificate ( rand . Reader , template , x509Cert , & priv . PublicKey , tlsCert . PrivateKey ) if err != nil { return err } certOut , err := os . Create ( opts . CertFile ) if err != nil { return err } pem . Encode ( certOut , & pem . Block { Type : " " , Bytes : derBytes } ) certOut . Close ( ) keyOut , err := os . OpenFile ( opts . KeyFile , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0600 ) if err != nil { return err } pem . Encode ( keyOut , & pem . Block { Type : " " , Bytes : x509 . MarshalPKCS1PrivateKey ( priv ) } ) keyOut . Close ( ) return nil } 
func ( xcg * X509CertGenerator ) ReadTLSConfig ( addr string , authOptions * auth . Options ) ( * tls . Config , error ) { caCertPath := authOptions . CaCertPath clientCertPath := authOptions . ClientCertPath clientKeyPath := authOptions . ClientKeyPath log . Debugf ( " " , caCertPath ) caCert , err := ioutil . ReadFile ( caCertPath ) if err != nil { return nil , err } log . Debugf ( " " , clientCertPath ) clientCert , err := ioutil . ReadFile ( clientCertPath ) if err != nil { return nil , err } log . Debugf ( " " , clientKeyPath ) clientKey , err := ioutil . ReadFile ( clientKeyPath ) if err != nil { return nil , err } return xcg . getTLSConfig ( caCert , clientCert , clientKey , false ) } 
func ( xcg * X509CertGenerator ) ValidateCertificate ( addr string , authOptions * auth . Options ) ( bool , error ) { tlsConfig , err := xcg . ReadTLSConfig ( addr , authOptions ) if err != nil { return false , err } dialer := & net . Dialer { Timeout : time . Second * 20 , } _ , err = tls . DialWithDialer ( dialer , " " , addr , tlsConfig ) if err != nil { return false , err } return true , nil } 
func compare ( v1 , v2 string ) int { v2 = strings . Replace ( v2 , rcString , " " , - 1 ) } if ! strings . Contains ( v1 , ceEdition ) && strings . Contains ( v2 , ceEdition ) { return - 1 } } return compareCE ( v1 , v2 ) } 
func compareCE ( v1 , v2 string ) int { return compareNumeric ( strings . Replace ( v1 , ceEdition , " " , - 1 ) , strings . Replace ( v2 , ceEdition , " " , - 1 ) , ) } 
func ( d * Driver ) IsVTXDisabled ( ) bool { if cpuid . HasFeature ( cpuid . VMX ) || cpuid . HasFeature ( cpuid . SVM ) { return false } return true } 
func NewVBoxManager ( ) * VBoxCmdManager { return & VBoxCmdManager { runCmd : func ( cmd * exec . Cmd ) error { return cmd . Run ( ) } , } } 
func oauthClient ( ) autorest . Client { c := autorest . NewClientWithUserAgent ( fmt . Sprintf ( " " , version . Version ) ) c . RequestInspector = withInspection ( ) c . ResponseInspector = byInspecting ( ) } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultCPU , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultMemory , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultDiskSize , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHUser , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHPass , } , mcnflag . BoolFlag { EnvVar : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) PreCreateCheck ( ) error { return b2dutils . UpdateISOCache ( d . Boot2DockerURL ) } 
func executeSSHCommand ( command string , d * Driver ) error { log . Debugf ( " " , command ) config := & cryptossh . ClientConfig { User : d . SSHUser , Auth : [ ] cryptossh . AuthMethod { cryptossh . Password ( d . SSHPassword ) , } , } client , err := cryptossh . Dial ( " " , fmt . Sprintf ( " " , d . IPAddress , d . SSHPort ) , config ) if err != nil { log . Debugf ( " " , err ) return err } session , err := client . NewSession ( ) if err != nil { log . Debugf ( " " + err . Error ( ) ) return err } defer session . Close ( ) var b bytes . Buffer session . Stdout = & b if err := session . Run ( command ) ; err != nil { log . Debugf ( " " + err . Error ( ) ) return err } log . Debugf ( " " , b . String ( ) ) return nil } 
func driverPath ( driverName string ) string { for _ , coreDriver := range CoreDrivers { if coreDriver == driverName { if CurrentBinaryIsDockerMachine { return os . Args [ 0 ] } return " " } } return fmt . Sprintf ( " " , driverName ) } 
func AuthenticateDeviceFlow ( env azure . Environment , subscriptionID string ) ( * azure . ServicePrincipalToken , error ) { if err != nil { return nil , err } oauthCfg , err := env . OAuthConfigForTenant ( tenantID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } tokenPath := tokenCachePath ( tenantID ) saveToken := mkTokenCallback ( tokenPath ) saveTokenCallback := func ( t azure . Token ) error { log . Debug ( " " ) return saveToken ( t ) } f := logutil . Fields { " " : tokenPath } appID , ok := appIDs [ env . Name ] if ! ok { return nil , fmt . Errorf ( " " , env . Name ) } scope := getScope ( env ) if err != nil { return nil , err } if spt != nil { log . Debug ( " " , f ) if err := validateToken ( env , spt ) ; err != nil { log . Debug ( fmt . Sprintf ( " " , err ) ) log . Debug ( fmt . Sprintf ( " " , tokenPath ) ) if err := os . RemoveAll ( tokenPath ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } } else { log . Debug ( " " ) return spt , nil } } log . Debug ( " " , f ) spt , err = deviceFlowAuth ( * oauthCfg , appID , scope ) if err != nil { return nil , err } log . Debug ( " " ) if err := saveToken ( spt . Token ) ; err != nil { log . Error ( " " ) return nil , err } return spt , nil } 
func AuthenticateServicePrincipal ( env azure . Environment , subscriptionID , spID , spPassword string ) ( * azure . ServicePrincipalToken , error ) { tenantID , err := loadOrFindTenantID ( env , subscriptionID ) if err != nil { return nil , err } oauthCfg , err := env . OAuthConfigForTenant ( tenantID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } spt , err := azure . NewServicePrincipalToken ( * oauthCfg , spID , spPassword , getScope ( env ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func tokenFromFile ( oauthCfg azure . OAuthConfig , tokenPath , clientID , resource string , callback azure . TokenRefreshCallback ) ( * azure . ServicePrincipalToken , error ) { log . Debug ( " " , logutil . Fields { " " : tokenPath } ) if _ , err := os . Stat ( tokenPath ) ; err != nil { if os . IsNotExist ( err ) { } return nil , err } token , err := azure . LoadToken ( tokenPath ) if err != nil { return nil , fmt . Errorf ( " " , err ) } spt , err := azure . NewServicePrincipalTokenFromManualToken ( oauthCfg , clientID , resource , * token , callback ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func deviceFlowAuth ( oauthCfg azure . OAuthConfig , clientID , resource string ) ( * azure . ServicePrincipalToken , error ) { cl := oauthClient ( ) deviceCode , err := azure . InitiateDeviceAuth ( & cl , oauthCfg , clientID , resource ) if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Debug ( " " , logutil . Fields { " " : to . Int64 ( deviceCode . ExpiresIn ) , " " : to . Int64 ( deviceCode . Interval ) , } ) token , err := azure . WaitForUserCompletion ( & cl , deviceCode ) if err != nil { return nil , fmt . Errorf ( " " , err ) } spt , err := azure . NewServicePrincipalTokenFromManualToken ( oauthCfg , clientID , resource , * token ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func tokenCachePath ( tenantID string ) string { return filepath . Join ( azureCredsPath ( ) , fmt . Sprintf ( " " , tenantID ) ) } 
func tenantIDPath ( subscriptionID string ) string { return filepath . Join ( azureCredsPath ( ) , fmt . Sprintf ( " " , subscriptionID ) ) } 
func mkTokenCallback ( path string ) azure . TokenRefreshCallback { return func ( t azure . Token ) error { if err := azure . SaveToken ( path , 0600 , t ) ; err != nil { return err } log . Debug ( " " ) return nil } } 
func validateToken ( env azure . Environment , token * azure . ServicePrincipalToken ) error { c := subscriptionsClient ( env . ResourceManagerEndpoint ) c . Authorizer = token _ , err := c . List ( ) if err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func NewFmtMachineLogger ( ) MachineLogger { return & FmtMachineLogger { outWriter : os . Stdout , errWriter : os . Stderr , debug : false , history : NewHistoryRecorder ( ) , } } 
func newComputeUtil ( driver * Driver ) ( * ComputeUtil , error ) { client , err := google . DefaultClient ( oauth2 . NoContext , raw . ComputeScope ) if err != nil { return nil , err } service , err := raw . New ( client ) if err != nil { return nil , err } return & ComputeUtil { zone : driver . Zone , instanceName : driver . MachineName , userName : driver . SSHUser , project : driver . Project , diskTypeURL : driver . DiskType , address : driver . Address , network : driver . Network , subnetwork : driver . Subnetwork , preemptible : driver . Preemptible , useInternalIP : driver . UseInternalIP , useInternalIPOnly : driver . UseInternalIPOnly , service : service , zoneURL : apiURL + driver . Project + " " + driver . Zone , globalURL : apiURL + driver . Project + " " , SwarmMaster : driver . SwarmMaster , SwarmHost : driver . SwarmHost , openPorts : driver . OpenPorts , } , nil } 
func ( c * ComputeUtil ) disk ( ) ( * raw . Disk , error ) { return c . service . Disks . Get ( c . project , c . zone , c . diskName ( ) ) . Do ( ) } 
func ( c * ComputeUtil ) deleteDisk ( ) error { disk , _ := c . disk ( ) if disk == nil { return nil } log . Infof ( " " ) op , err := c . service . Disks . Delete ( c . project , c . zone , c . diskName ( ) ) . Do ( ) if err != nil { return err } log . Infof ( " " ) return c . waitForRegionalOp ( op . Name ) } 
func ( c * ComputeUtil ) staticAddress ( ) ( string , error ) { if err != nil { return " " , err } if ! isName { return c . address , nil } if err != nil { return " " , err } return externalAddress . Address , nil } 
func ( c * ComputeUtil ) openFirewallPorts ( d * Driver ) error { log . Infof ( " " ) create := false rule , _ := c . firewallRule ( ) if rule == nil { create = true rule = & raw . Firewall { Name : firewallRule , Allowed : [ ] * raw . FirewallAllowed { } , SourceRanges : [ ] string { " " } , TargetTags : [ ] string { firewallTargetTag } , Network : c . globalURL + " " + d . Network , } } portsUsed , err := c . portsUsed ( ) if err != nil { return err } missingPorts := missingOpenedPorts ( rule , portsUsed ) if len ( missingPorts ) == 0 { return nil } for proto , ports := range missingPorts { rule . Allowed = append ( rule . Allowed , & raw . FirewallAllowed { IPProtocol : proto , Ports : ports , } ) } var op * raw . Operation if create { op , err = c . service . Firewalls . Insert ( c . project , rule ) . Do ( ) } else { op , err = c . service . Firewalls . Update ( c . project , firewallRule , rule ) . Do ( ) } if err != nil { return err } return c . waitForGlobalOp ( op . Name ) } 
func ( c * ComputeUtil ) instance ( ) ( * raw . Instance , error ) { return c . service . Instances . Get ( c . project , c . zone , c . instanceName ) . Do ( ) } 
func ( c * ComputeUtil ) createInstance ( d * Driver ) error { log . Infof ( " " ) var net string if strings . Contains ( d . Network , " " ) { net = d . Network } else { net = c . globalURL + " " + d . Network } instance := & raw . Instance { Name : c . instanceName , Description : " " , MachineType : c . zoneURL + " " + d . MachineType , Disks : [ ] * raw . AttachedDisk { { Boot : true , AutoDelete : true , Type : " " , Mode : " " , } , } , NetworkInterfaces : [ ] * raw . NetworkInterface { { Network : net , } , } , Tags : & raw . Tags { Items : parseTags ( d ) , } , ServiceAccounts : [ ] * raw . ServiceAccount { { Email : d . ServiceAccount , Scopes : strings . Split ( d . Scopes , " " ) , } , } , Scheduling : & raw . Scheduling { Preemptible : c . preemptible , } , } if strings . Contains ( c . subnetwork , " " ) { instance . NetworkInterfaces [ 0 ] . Subnetwork = c . subnetwork } else if c . subnetwork != " " { instance . NetworkInterfaces [ 0 ] . Subnetwork = " " + c . project + " " + c . region ( ) + " " + c . subnetwork } if ! c . useInternalIPOnly { cfg := & raw . AccessConfig { Type : " " , } instance . NetworkInterfaces [ 0 ] . AccessConfigs = append ( instance . NetworkInterfaces [ 0 ] . AccessConfigs , cfg ) } if c . address != " " { staticAddress , err := c . staticAddress ( ) if err != nil { return err } instance . NetworkInterfaces [ 0 ] . AccessConfigs [ 0 ] . NatIP = staticAddress } disk , err := c . disk ( ) if disk == nil || err != nil { instance . Disks [ 0 ] . InitializeParams = & raw . AttachedDiskInitializeParams { DiskName : c . diskName ( ) , SourceImage : " " + d . MachineImage , } else { instance . Disks [ 0 ] . Source = c . zoneURL + " " + c . instanceName + " " } op , err := c . service . Instances . Insert ( c . project , c . zone , instance ) . Do ( ) if err != nil { return err } log . Infof ( " " ) if err = c . waitForRegionalOp ( op . Name ) ; err != nil { return err } instance , err = c . instance ( ) if err != nil { return err } return c . uploadSSHKey ( instance , d . GetSSHKeyPath ( ) ) } 
func ( c * ComputeUtil ) configureInstance ( d * Driver ) error { log . Infof ( " " ) instance , err := c . instance ( ) if err != nil { return err } if err := c . addFirewallTag ( instance ) ; err != nil { return err } return c . uploadSSHKey ( instance , d . GetSSHKeyPath ( ) ) } 
func ( c * ComputeUtil ) addFirewallTag ( instance * raw . Instance ) error { log . Infof ( " " ) tags := instance . Tags for _ , tag := range tags . Items { if tag == firewallTargetTag { return nil } } tags . Items = append ( tags . Items , firewallTargetTag ) op , err := c . service . Instances . SetTags ( c . project , c . zone , instance . Name , tags ) . Do ( ) if err != nil { return err } return c . waitForRegionalOp ( op . Name ) } 
func ( c * ComputeUtil ) uploadSSHKey ( instance * raw . Instance , sshKeyPath string ) error { log . Infof ( " " ) sshKey , err := ioutil . ReadFile ( sshKeyPath + " " ) if err != nil { return err } metaDataValue := fmt . Sprintf ( " \n " , c . userName , strings . TrimSpace ( string ( sshKey ) ) , c . userName ) op , err := c . service . Instances . SetMetadata ( c . project , c . zone , c . instanceName , & raw . Metadata { Fingerprint : instance . Metadata . Fingerprint , Items : [ ] * raw . MetadataItems { { Key : " " , Value : & metaDataValue , } , } , } ) . Do ( ) return c . waitForRegionalOp ( op . Name ) } 
func parseTags ( d * Driver ) [ ] string { tags := [ ] string { firewallTargetTag } if d . Tags != " " { tags = append ( tags , strings . Split ( d . Tags , " " ) ... ) } return tags } 
func ( c * ComputeUtil ) startInstance ( ) error { op , err := c . service . Instances . Start ( c . project , c . zone , c . instanceName ) . Do ( ) if err != nil { return err } log . Infof ( " " ) return c . waitForRegionalOp ( op . Name ) } 
func ( c * ComputeUtil ) waitForOp ( opGetter func ( ) ( * raw . Operation , error ) ) error { for { op , err := opGetter ( ) if err != nil { return err } log . Debugf ( " " , op . Name , op . Status ) if op . Status == " " { if op . Error != nil { return fmt . Errorf ( " " , * op . Error . Errors [ 0 ] ) } break } time . Sleep ( 1 * time . Second ) } return nil } 
func ( c * ComputeUtil ) waitForRegionalOp ( name string ) error { return c . waitForOp ( func ( ) ( * raw . Operation , error ) { return c . service . ZoneOperations . Get ( c . project , c . zone , name ) . Do ( ) } ) } 
func ( c * ComputeUtil ) waitForGlobalOp ( name string ) error { return c . waitForOp ( func ( ) ( * raw . Operation , error ) { return c . service . GlobalOperations . Get ( c . project , name ) . Do ( ) } ) } 
func ( c * ComputeUtil ) ip ( ) ( string , error ) { instance , err := c . service . Instances . Get ( c . project , c . zone , c . instanceName ) . Do ( ) if err != nil { return " " , unwrapGoogleError ( err ) } nic := instance . NetworkInterfaces [ 0 ] if c . useInternalIP { return nic . NetworkIP , nil } return nic . AccessConfigs [ 0 ] . NatIP , nil } 
func ( r * RPCServerDriver ) GetSSHPort ( _ * struct { } , reply * int ) error { port , err := r . ActualDriver . GetSSHPort ( ) * reply = port return err } 
func cmdOutput ( name string , args ... string ) ( string , error ) { cmd := exec . Command ( name , args ... ) log . Debugf ( " " , name , strings . Join ( args , " " ) ) stdout , err := cmd . Output ( ) if err != nil { return " " , err } log . Debugf ( " \n \n " , string ( stdout ) ) return string ( stdout ) , nil } 
func setVmwareCmd ( cmd string ) string { if path , err := exec . LookPath ( cmd ) ; err == nil { return path } return filepath . Join ( " " , cmd ) } 
func vdiskmanager ( dest string , size int ) error { cmd := exec . Command ( vdiskmanbin , " " , " " , " " , " " , fmt . Sprintf ( " " , size ) , " " , " " , dest ) if os . Getenv ( " " ) != " " { cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr } if stdout := cmd . Run ( ) ; stdout != nil { if ee , ok := stdout . ( * exec . Error ) ; ok && ee == exec . ErrNotFound { return ErrVMRUNNotFound } } return nil } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultCatalog , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultCatalogItem , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultCpus , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultMemory , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHPort , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultDockerPort , } , } } 
func generateVMName ( ) string { randomID := mcnutils . TruncateID ( mcnutils . GenerateRandomID ( ) ) return fmt . Sprintf ( " " , randomID ) } 
func ( a AzureClient ) RegisterResourceProviders ( namespaces ... string ) error { l , err := a . providersClient ( ) . List ( nil , " " ) if err != nil { return err } if l . Value == nil { return errors . New ( " " ) } m := make ( map [ string ] bool ) for _ , p := range * l . Value { m [ strings . ToLower ( to . String ( p . Namespace ) ) ] = to . String ( p . RegistrationState ) == " " } for _ , ns := range namespaces { registered , ok := m [ strings . ToLower ( ns ) ] if ! ok { return fmt . Errorf ( " " , ns ) } if registered { log . Debugf ( " " , ns ) } else { log . Info ( " " , logutil . Fields { " " : ns , " " : a . subscriptionID , } ) if _ , err := a . providersClient ( ) . Register ( ns ) ; err != nil { return err } } } return nil } 
func ( a AzureClient ) CreateResourceGroup ( name , location string ) error { if ok , err := a . resourceGroupExists ( name ) ; err != nil { return err } else if ok { log . Infof ( " " , name ) return nil } log . Info ( " " , logutil . Fields { " " : name , " " : location } ) _ , err := a . resourceGroupsClient ( ) . CreateOrUpdate ( name , resources . ResourceGroup { Location : to . StringPtr ( location ) , } ) return err } 
func ( a AzureClient ) CleanupVirtualNetworkIfExists ( resourceGroup , name string ) error { return a . cleanupResourceIfExists ( & vnetCleanup { rg : resourceGroup , name : name } ) } 
func ( a AzureClient ) CreateSubnet ( ctx * DeploymentContext , resourceGroup , virtualNetwork , name , subnetPrefix string ) error { subnet , err := a . GetSubnet ( resourceGroup , virtualNetwork , name ) if err == nil { log . Info ( " " ) ctx . SubnetID = to . String ( subnet . ID ) return err } _ , err = a . subnetsClient ( ) . CreateOrUpdate ( resourceGroup , virtualNetwork , name , network . Subnet { Properties : & network . SubnetPropertiesFormat { AddressPrefix : to . StringPtr ( subnetPrefix ) , } , } , nil ) if err != nil { return err } subnet , err = a . subnetsClient ( ) . Get ( resourceGroup , virtualNetwork , name , " " ) ctx . SubnetID = to . String ( subnet . ID ) return err } log . Warn ( " " , err ) return err } 
func ( a AzureClient ) CleanupSubnetIfExists ( resourceGroup , virtualNetwork , name string ) error { return a . cleanupResourceIfExists ( & subnetCleanup { rg : resourceGroup , vnet : virtualNetwork , name : name , } ) } 
func ( a AzureClient ) CleanupAvailabilitySetIfExists ( resourceGroup , name string ) error { return a . cleanupResourceIfExists ( & avSetCleanup { rg : resourceGroup , name : name } ) } 
func ( a AzureClient ) GetPublicIPAddress ( resourceGroup , name string , useFqdn bool ) ( string , error ) { f := logutil . Fields { " " : name } log . Debug ( " " , f ) ip , err := a . publicIPAddressClient ( ) . Get ( resourceGroup , name , " " ) if err != nil { return " " , err } if ip . Properties == nil { log . Debug ( " " , f ) return " " , nil } if useFqdn { if ip . Properties . DNSSettings == nil || ip . Properties . DNSSettings . Fqdn == nil { return " " , errors . New ( " " ) } return to . String ( ip . Properties . DNSSettings . Fqdn ) , nil } return to . String ( ip . Properties . IPAddress ) , nil } 
func ( a AzureClient ) GetPrivateIPAddress ( resourceGroup , name string ) ( string , error ) { f := logutil . Fields { " " : name } log . Debug ( " " , f ) nic , err := a . networkInterfacesClient ( ) . Get ( resourceGroup , name , " " ) if err != nil { return " " , err } if nic . Properties == nil || nic . Properties . IPConfigurations == nil || len ( * nic . Properties . IPConfigurations ) == 0 { log . Debug ( " " , f ) return " " , nil } return to . String ( ( * nic . Properties . IPConfigurations ) [ 0 ] . Properties . PrivateIPAddress ) , nil } 
func ( a AzureClient ) StopVirtualMachine ( resourceGroup , name string ) error { log . Info ( " " , logutil . Fields { " " : name } ) if _ , err := a . virtualMachinesClient ( ) . PowerOff ( resourceGroup , name , nil ) ; err != nil { return err } return a . waitVMPowerState ( resourceGroup , name , Stopped , waitPowerOffTimeout ) } 
func ( a AzureClient ) RestartVirtualMachine ( resourceGroup , name string ) error { log . Info ( " " , logutil . Fields { " " : name } ) if _ , err := a . virtualMachinesClient ( ) . Restart ( resourceGroup , name , nil ) ; err != nil { return err } return a . waitVMPowerState ( resourceGroup , name , Running , waitStartTimeout ) } 
func deleteResourceIfExists ( resourceType , name string , getFunc func ( ) error , deleteFunc func ( ) ( autorest . Response , error ) ) error { f := logutil . Fields { " " : name } log . Debug ( fmt . Sprintf ( " " , resourceType ) , f ) if exists , err := checkResourceExistsFromError ( getFunc ( ) ) ; err != nil { return err } else if ! exists { log . Info ( fmt . Sprintf ( " " , resourceType ) , f ) return nil } log . Info ( fmt . Sprintf ( " " , resourceType ) , f ) _ , err := deleteFunc ( ) return err } 
func ( a AzureClient ) waitVMPowerState ( resourceGroup , name string , goalState VMPowerState , timeout time . Duration ) error { chErr := make ( chan error ) go func ( ch chan error ) { for { select { case <- ch : default : state , err := a . GetVirtualMachinePowerState ( resourceGroup , name ) if err != nil { ch <- err return } if state != goalState { log . Debug ( fmt . Sprintf ( " " , powerStatePollingInterval ) , logutil . Fields { " " : goalState , " " : state , } ) time . Sleep ( powerStatePollingInterval ) } else { log . Debug ( " " , logutil . Fields { " " : state } ) ch <- nil return } } } } ( chErr ) select { case <- time . After ( timeout ) : close ( chErr ) return fmt . Errorf ( " " , goalState , timeout ) case err := <- chErr : return err } } 
func checkResourceExistsFromError ( err error ) ( bool , error ) { if err == nil { return true , nil } v , ok := err . ( autorest . DetailedError ) if ok && v . StatusCode == http . StatusNotFound { return false , nil } return false , v } 
func osDiskStorageBlobURL ( account * storage . AccountProperties , vmName string ) string { containerURL := osDiskStorageContainerURL ( account , vmName ) blobName := fmt . Sprintf ( fmtOSDiskBlobName , vmName ) return containerURL + blobName } 
func osDiskStorageContainerURL ( account * storage . AccountProperties , vmName string ) string { return fmt . Sprintf ( " " , to . String ( account . PrimaryEndpoints . Blob ) , osDiskStorageContainerName ( vmName ) ) } 
func extractStorageAccountFromVHDURL ( vhdURL string ) ( string , string ) { u , err := url . Parse ( vhdURL ) if err != nil { log . Warn ( fmt . Sprintf ( " " , err ) , logutil . Fields { " " : vhdURL } ) return " " , " " } parts := strings . SplitN ( u . Host , " " , 2 ) if len ( parts ) != 2 { log . Warnf ( " " , vhdURL ) return " " , " " } return parts [ 0 ] , strings . TrimPrefix ( parts [ 1 ] , " " ) } 
func NewKeyPair ( ) ( keyPair * KeyPair , err error ) { priv , err := rsa . GenerateKey ( rand . Reader , 2048 ) if err != nil { return nil , ErrKeyGeneration } if err := priv . Validate ( ) ; err != nil { return nil , ErrValidation } privDer := x509 . MarshalPKCS1PrivateKey ( priv ) pubSSH , err := gossh . NewPublicKey ( & priv . PublicKey ) if err != nil { return nil , ErrPublicKey } return & KeyPair { PrivateKey : privDer , PublicKey : gossh . MarshalAuthorizedKey ( pubSSH ) , } , nil } 
func ( kp * KeyPair ) Fingerprint ( ) string { b , _ := base64 . StdEncoding . DecodeString ( string ( kp . PublicKey ) ) h := md5 . New ( ) io . WriteString ( h , string ( b ) ) return fmt . Sprintf ( " " , h . Sum ( nil ) ) } 
func GenerateSSHKey ( path string ) error { if _ , err := os . Stat ( path ) ; err != nil { if ! os . IsNotExist ( err ) { return fmt . Errorf ( " " , err ) } kp , err := NewKeyPair ( ) if err != nil { return fmt . Errorf ( " " , err ) } if err := kp . WriteToFile ( path , fmt . Sprintf ( " " , path ) ) ; err != nil { return fmt . Errorf ( " " , err ) } } return nil } 
func loadOrFindTenantID ( env azure . Environment , subscriptionID string ) ( string , error ) { var tenantID string log . Debug ( " " , logutil . Fields { " " : subscriptionID } ) b , err := ioutil . ReadFile ( fp ) if err == nil { tenantID = strings . TrimSpace ( string ( b ) ) log . Debugf ( " " , fp ) } else if os . IsNotExist ( err ) { log . Debugf ( " " , fp ) } else { return " " , fmt . Errorf ( " " , err ) } t , err := findTenantID ( env , subscriptionID ) if err != nil { return " " , err } tenantID = t } log . Debugf ( " " , fp ) } log . Debug ( " " , logutil . Fields { " " : tenantID , " " : subscriptionID } ) return tenantID , nil } 
func findTenantID ( env azure . Environment , subscriptionID string ) ( string , error ) { const hdrKey = " " c := subscriptionsClient ( env . ResourceManagerEndpoint ) if subs . Response . Response == nil { return " " , fmt . Errorf ( " " , err ) } } hdr := subs . Header . Get ( hdrKey ) if hdr == " " { return " " , fmt . Errorf ( " " , hdrKey ) } m := r . FindStringSubmatch ( hdr ) if m == nil { return " " , fmt . Errorf ( " " , hdrKey , hdr ) } return m [ 1 ] , nil } 
func saveTenantID ( path string , tenantID string ) error { var perm os . FileMode = 0600 dir := filepath . Dir ( path ) if err := os . MkdirAll ( dir , os . ModePerm ) ; err != nil { return fmt . Errorf ( " " , dir , err ) } f , err := ioutil . TempFile ( dir , " " ) if err != nil { return fmt . Errorf ( " " , err ) } defer f . Close ( ) fp := f . Name ( ) if _ , err := f . Write ( [ ] byte ( tenantID ) ) ; err != nil { return fmt . Errorf ( " " , err ) } f . Close ( ) } if err := os . Chmod ( path , perm ) ; err != nil { return fmt . Errorf ( " " , path , err ) } return nil } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHUser , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHPort , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultImage , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultRegion , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSize , } , mcnflag . BoolFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . BoolFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . BoolFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . BoolFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , } } 
func ( r * BugsnagCrashReporter ) Send ( err CrashError ) error { if r . noReportFileExist ( ) || r . apiKey == noreportAPIKey { log . Debug ( " " ) return nil } if r . apiKey == " " { return errors . New ( " " ) } bugsnag . Configure ( bugsnag . Configuration { APIKey : r . apiKey , metaData := bugsnag . MetaData { } metaData . Add ( " " , " " , fmt . Sprintf ( " " , runtime . Compiler , runtime . Version ( ) ) ) metaData . Add ( " " , " " , runtime . GOOS ) metaData . Add ( " " , " " , runtime . GOARCH ) detectRunningShell ( & metaData ) detectUname ( & metaData ) detectOSVersion ( & metaData ) addFile ( err . LogFilePath , & metaData ) var buffer bytes . Buffer for _ , message := range log . History ( ) { buffer . WriteString ( message + " \n " ) } metaData . Add ( " " , " " , buffer . String ( ) ) return bugsnag . Notify ( err . Cause , metaData , bugsnag . SeverityError , bugsnag . Context { String : err . Context } , bugsnag . ErrorClass { Name : fmt . Sprintf ( " " , err . DriverName , err . Command ) } ) } 
func ( d * SerialDriver ) Create ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Create ( ) } 
func ( d * SerialDriver ) DriverName ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . DriverName ( ) } 
func ( d * SerialDriver ) GetCreateFlags ( ) [ ] mcnflag . Flag { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetCreateFlags ( ) } 
func ( d * SerialDriver ) GetIP ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetIP ( ) } 
func ( d * SerialDriver ) GetMachineName ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetMachineName ( ) } 
func ( d * SerialDriver ) GetSSHHostname ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHHostname ( ) } 
func ( d * SerialDriver ) GetSSHKeyPath ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHKeyPath ( ) } 
func ( d * SerialDriver ) GetSSHPort ( ) ( int , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHPort ( ) } 
func ( d * SerialDriver ) GetSSHUsername ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetSSHUsername ( ) } 
func ( d * SerialDriver ) GetURL ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetURL ( ) } 
func ( d * SerialDriver ) GetState ( ) ( state . State , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . GetState ( ) } 
func ( d * SerialDriver ) Kill ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Kill ( ) } 
func ( d * SerialDriver ) PreCreateCheck ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . PreCreateCheck ( ) } 
func ( d * SerialDriver ) Remove ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Remove ( ) } 
func ( d * SerialDriver ) Restart ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Restart ( ) } 
func ( d * SerialDriver ) SetConfigFromFlags ( opts DriverOptions ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . SetConfigFromFlags ( opts ) } 
func ( d * SerialDriver ) Start ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Start ( ) } 
func ( d * SerialDriver ) Stop ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Stop ( ) } 
func MigrateHostV0ToHostV1 ( hostV0 * V0 ) * V1 { hostV1 := & V1 { Driver : hostV0 . Driver , DriverName : hostV0 . DriverName , } hostV1 . HostOptions = & OptionsV1 { } hostV1 . HostOptions . EngineOptions = & engine . Options { TLSVerify : true , InstallURL : " " , } hostV1 . HostOptions . SwarmOptions = & swarm . Options { Address : " " , Discovery : hostV0 . SwarmDiscovery , Host : hostV0 . SwarmHost , Master : hostV0 . SwarmMaster , } hostV1 . HostOptions . AuthOptions = & AuthOptionsV1 { StorePath : hostV0 . StorePath , CaCertPath : hostV0 . CaCertPath , CaCertRemotePath : " " , ServerCertPath : hostV0 . ServerCertPath , ServerKeyPath : hostV0 . ServerKeyPath , ClientKeyPath : hostV0 . ClientKeyPath , ServerCertRemotePath : " " , ServerKeyRemotePath : " " , PrivateKeyPath : hostV0 . PrivateKeyPath , ClientCertPath : hostV0 . ClientCertPath , } return hostV1 } 
func MigrateHostMetadataV0ToHostMetadataV1 ( m * MetadataV0 ) * Metadata { hostMetadata := & Metadata { } hostMetadata . DriverName = m . DriverName hostMetadata . HostOptions . EngineOptions = & engine . Options { } hostMetadata . HostOptions . AuthOptions = & auth . Options { StorePath : m . StorePath , CaCertPath : m . CaCertPath , CaCertRemotePath : " " , ServerCertPath : m . ServerCertPath , ServerKeyPath : m . ServerKeyPath , ClientKeyPath : " " , ServerCertRemotePath : " " , ServerKeyRemotePath : " " , CaPrivateKeyPath : m . PrivateKeyPath , ClientCertPath : m . ClientCertPath , } hostMetadata . ConfigVersion = m . ConfigVersion return hostMetadata } 
func getProcessEntry ( pid int ) ( pe * syscall . ProcessEntry32 , err error ) { snapshot , err := syscall . CreateToolhelp32Snapshot ( syscall . TH32CS_SNAPPROCESS , 0 ) if err != nil { return nil , err } defer syscall . CloseHandle ( syscall . Handle ( snapshot ) ) var processEntry syscall . ProcessEntry32 processEntry . Size = uint32 ( unsafe . Sizeof ( processEntry ) ) err = syscall . Process32First ( snapshot , & processEntry ) if err != nil { return nil , err } for { if processEntry . ProcessID == uint32 ( pid ) { pe = & processEntry return } err = syscall . Process32Next ( snapshot , & processEntry ) if err != nil { return nil , err } } } 
func getNameAndItsPpid ( pid int ) ( exefile string , parentid int , err error ) { pe , err := getProcessEntry ( pid ) if err != nil { return " " , 0 , err } name := syscall . UTF16ToString ( pe . ExeFile [ : ] ) return name , int ( pe . ParentProcessID ) , nil } 
func flagHackLookup ( flagName string ) string { } } } } } return " " } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultZone , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultMachineType , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultImageName , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultUser , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultServiceAccount , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultScopes , EnvVar : " " , } , mcnflag . IntFlag { Name : " " , Usage : " " , Value : defaultDiskSize , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultDiskType , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultNetwork , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultSubnetwork , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , EnvVar : " " , Value : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringSliceFlag { Name : " " , Usage : " " , } , } } 
func NewDriver ( machineName string , storePath string ) * Driver { return & Driver { Zone : defaultZone , DiskType : defaultDiskType , DiskSize : defaultDiskSize , MachineType : defaultMachineType , MachineImage : defaultImageName , Network : defaultNetwork , Subnetwork : defaultSubnetwork , ServiceAccount : defaultServiceAccount , Scopes : defaultScopes , BaseDriver : & drivers . BaseDriver { SSHUser : defaultUser , MachineName : machineName , StorePath : storePath , } , } } 
func ( d * Driver ) SetConfigFromFlags ( flags drivers . DriverOptions ) error { d . Project = flags . String ( " " ) if d . Project == " " { return errors . New ( " " ) } d . Zone = flags . String ( " " ) d . UseExisting = flags . Bool ( " " ) if ! d . UseExisting { d . MachineType = flags . String ( " " ) d . MachineImage = flags . String ( " " ) d . MachineImage = strings . TrimPrefix ( d . MachineImage , " " ) d . DiskSize = flags . Int ( " " ) d . DiskType = flags . String ( " " ) d . Address = flags . String ( " " ) d . Network = flags . String ( " " ) d . Subnetwork = flags . String ( " " ) d . Preemptible = flags . Bool ( " " ) d . UseInternalIP = flags . Bool ( " " ) || flags . Bool ( " " ) d . UseInternalIPOnly = flags . Bool ( " " ) d . ServiceAccount = flags . String ( " " ) d . Scopes = flags . String ( " " ) d . Tags = flags . String ( " " ) d . OpenPorts = flags . StringSlice ( " " ) } d . SSHUser = flags . String ( " " ) d . SSHPort = 22 d . SetSwarmConfigFromFlags ( flags ) return nil } 
func ( d * Driver ) PreCreateCheck ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } if _ , err = c . service . Projects . Get ( d . Project ) . Do ( ) ; err != nil { return fmt . Errorf ( " " , d . Project , err ) } instance , _ := c . instance ( ) if d . UseExisting { if instance == nil { return fmt . Errorf ( " " , d . MachineName , d . Zone ) } } else { if instance != nil { return fmt . Errorf ( " " , d . MachineName , d . Zone ) } } return nil } 
func ( d * Driver ) Create ( ) error { log . Infof ( " " ) if err := ssh . GenerateSSHKey ( d . GetSSHKeyPath ( ) ) ; err != nil { return err } log . Infof ( " " ) c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . openFirewallPorts ( d ) ; err != nil { return err } if d . UseExisting { return c . configureInstance ( d ) } return c . createInstance ( d ) } 
func ( d * Driver ) GetIP ( ) ( string , error ) { c , err := newComputeUtil ( d ) if err != nil { return " " , err } ip , err := c . ip ( ) if err != nil { return " " , err } if ip == " " { return " " , drivers . ErrHostIsNotRunning } return ip , nil } 
func ( d * Driver ) GetState ( ) ( state . State , error ) { c , err := newComputeUtil ( d ) if err != nil { return state . None , err } if instance == nil { disk , _ := c . disk ( ) if disk == nil { return state . None , nil } return state . Stopped , nil } switch instance . Status { case " " , " " : return state . Starting , nil case " " : return state . Running , nil case " " , " " , " " : return state . Stopped , nil } return state . None , nil } 
func ( d * Driver ) Start ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } instance , err := c . instance ( ) if err != nil { if ! isNotFound ( err ) { return err } } if instance == nil { if err = c . createInstance ( d ) ; err != nil { return err } } else { if err := c . startInstance ( ) ; err != nil { return err } } d . IPAddress , err = d . GetIP ( ) return err } 
func ( d * Driver ) Stop ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . stopInstance ( ) ; err != nil { return err } d . IPAddress = " " return nil } 
func ( d * Driver ) Restart ( ) error { if err := d . Stop ( ) ; err != nil { return err } return d . Start ( ) } 
func ( d * Driver ) Remove ( ) error { c , err := newComputeUtil ( d ) if err != nil { return err } if err := c . deleteInstance ( ) ; err != nil { if isNotFound ( err ) { log . Warn ( " " ) } else { return err } } if err := c . deleteDisk ( ) ; err != nil { if isNotFound ( err ) { log . Warn ( " " ) } else { return err } } return nil } 
func NewDriver ( hostName , storePath string ) drivers . Driver { return d } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { Name : flAzureEnvironment , Usage : " " , EnvVar : " " , Value : defaultAzureEnvironment , } , mcnflag . StringFlag { Name : flAzureSubscriptionID , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : flAzureResourceGroup , Usage : " " , EnvVar : " " , Value : defaultAzureResourceGroup , } , mcnflag . StringFlag { Name : flAzureSSHUser , Usage : " " , EnvVar : " " , Value : defaultSSHUser , } , mcnflag . IntFlag { Name : flAzureDockerPort , Usage : " " , EnvVar : " " , Value : defaultDockerPort , } , mcnflag . StringFlag { Name : flAzureLocation , Usage : " " , EnvVar : " " , Value : defaultAzureLocation , } , mcnflag . StringFlag { Name : flAzureSize , Usage : " " , EnvVar : " " , Value : defaultAzureSize , } , mcnflag . StringFlag { Name : flAzureImage , Usage : " " , EnvVar : " " , Value : defaultAzureImage , } , mcnflag . StringFlag { Name : flAzureVNet , Usage : " " , EnvVar : " " , Value : defaultAzureVNet , } , mcnflag . StringFlag { Name : flAzureSubnet , Usage : " " , EnvVar : " " , Value : defaultAzureSubnet , } , mcnflag . StringFlag { Name : flAzureSubnetPrefix , Usage : " " , EnvVar : " " , Value : defaultAzureSubnetPrefix , } , mcnflag . StringFlag { Name : flAzureAvailabilitySet , Usage : " " , EnvVar : " " , Value : defaultAzureAvailabilitySet , } , mcnflag . StringFlag { Name : flAzureCustomData , EnvVar : " " , Usage : " " , } , mcnflag . StringFlag { Name : flAzurePrivateIPAddr , Usage : " " , } , mcnflag . StringFlag { Name : flAzureStorageType , Usage : " " , EnvVar : " " , Value : defaultStorageType , } , mcnflag . BoolFlag { Name : flAzureUsePrivateIP , Usage : " " , } , mcnflag . BoolFlag { Name : flAzureNoPublicIP , Usage : " " , } , mcnflag . BoolFlag { Name : flAzureStaticPublicIP , Usage : " " , } , mcnflag . StringFlag { Name : flAzureDNSLabel , Usage : " " , EnvVar : " " , } , mcnflag . StringSliceFlag { Name : flAzurePorts , Usage : " " , } , mcnflag . StringFlag { Name : flAzureClientID , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : flAzureClientSecret , Usage : " " , EnvVar : " " , } , } } 
func ( d * Driver ) SetConfigFromFlags ( fl drivers . DriverOptions ) error { flag string } { { & d . BaseDriver . SSHUser , flAzureSSHUser } , { & d . SubscriptionID , flAzureSubscriptionID } , { & d . ResourceGroup , flAzureResourceGroup } , { & d . Location , flAzureLocation } , { & d . Size , flAzureSize } , { & d . Image , flAzureImage } , { & d . VirtualNetwork , flAzureVNet } , { & d . SubnetName , flAzureSubnet } , { & d . SubnetPrefix , flAzureSubnetPrefix } , { & d . AvailabilitySet , flAzureAvailabilitySet } , { & d . StorageType , flAzureStorageType } , } for _ , f := range flags { * f . target = fl . String ( f . flag ) if * f . target == " " { return requiredOptionError ( f . flag ) } } d . OpenPorts = fl . StringSlice ( flAzurePorts ) d . PrivateIPAddr = fl . String ( flAzurePrivateIPAddr ) d . UsePrivateIP = fl . Bool ( flAzureUsePrivateIP ) d . NoPublicIP = fl . Bool ( flAzureNoPublicIP ) d . StaticPublicIP = fl . Bool ( flAzureStaticPublicIP ) d . DockerPort = fl . Int ( flAzureDockerPort ) d . DNSLabel = fl . String ( flAzureDNSLabel ) d . CustomDataFile = fl . String ( flAzureCustomData ) d . ClientID = fl . String ( flAzureClientID ) d . ClientSecret = fl . String ( flAzureClientSecret ) d . SetSwarmConfigFromFlags ( fl ) log . Debug ( " " ) return nil } 
func ( d * Driver ) PreCreateCheck ( ) ( err error ) { if d . CustomDataFile != " " { if _ , err := os . Stat ( d . CustomDataFile ) ; os . IsNotExist ( err ) { return fmt . Errorf ( " " , d . CustomDataFile ) } } c , err := d . newAzureClient ( ) if err != nil { return err } } if err != nil { return err } if exists , err := c . VirtualMachineExists ( d . ResourceGroup , d . naming ( ) . VM ( ) ) ; err != nil { return err } else if exists { return fmt . Errorf ( " " , d . naming ( ) . VM ( ) , d . ResourceGroup ) } return nil } 
func ( d * Driver ) Create ( ) error { if err != nil { return err } var customData string if d . CustomDataFile != " " { buf , err := ioutil . ReadFile ( d . CustomDataFile ) if err != nil { return err } customData = base64 . StdEncoding . EncodeToString ( buf ) } if err := c . CreateResourceGroup ( d . ResourceGroup , d . Location ) ; err != nil { return err } if err := c . CreateAvailabilitySetIfNotExists ( d . ctx , d . ResourceGroup , d . AvailabilitySet , d . Location ) ; err != nil { return err } if err := c . CreateNetworkSecurityGroup ( d . ctx , d . ResourceGroup , d . naming ( ) . NSG ( ) , d . Location , d . ctx . FirewallRules ) ; err != nil { return err } vnetResourceGroup , vNetName := parseVirtualNetwork ( d . VirtualNetwork , d . ResourceGroup ) if err := c . CreateVirtualNetworkIfNotExists ( vnetResourceGroup , vNetName , d . Location ) ; err != nil { return err } if err := c . CreateSubnet ( d . ctx , vnetResourceGroup , vNetName , d . SubnetName , d . SubnetPrefix ) ; err != nil { return err } if d . NoPublicIP { log . Info ( " " ) } else { if err := c . CreatePublicIPAddress ( d . ctx , d . ResourceGroup , d . naming ( ) . IP ( ) , d . Location , d . StaticPublicIP , d . DNSLabel ) ; err != nil { return err } } if err := c . CreateNetworkInterface ( d . ctx , d . ResourceGroup , d . naming ( ) . NIC ( ) , d . Location , d . ctx . PublicIPAddressID , d . ctx . SubnetID , d . ctx . NetworkSecurityGroupID , d . PrivateIPAddr ) ; err != nil { return err } if err := c . CreateStorageAccount ( d . ctx , d . ResourceGroup , d . Location , storage . SkuName ( d . StorageType ) ) ; err != nil { return err } if err := d . generateSSHKey ( d . ctx ) ; err != nil { return err } err = c . CreateVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) , d . Location , d . Size , d . ctx . AvailabilitySetID , d . ctx . NetworkInterfaceID , d . BaseDriver . SSHUser , d . ctx . SSHPublicKey , d . Image , customData , d . ctx . StorageAccount ) return err } 
func ( d * Driver ) Remove ( ) error { if err := d . checkLegacyDriver ( false ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } if err := c . DeleteVirtualMachineIfExists ( d . ResourceGroup , d . naming ( ) . VM ( ) ) ; err != nil { return err } if err := c . DeleteNetworkInterfaceIfExists ( d . ResourceGroup , d . naming ( ) . NIC ( ) ) ; err != nil { return err } if err := c . DeletePublicIPAddressIfExists ( d . ResourceGroup , d . naming ( ) . IP ( ) ) ; err != nil { return err } if err := c . DeleteNetworkSecurityGroupIfExists ( d . ResourceGroup , d . naming ( ) . NSG ( ) ) ; err != nil { return err } if err := c . CleanupAvailabilitySetIfExists ( d . ResourceGroup , d . AvailabilitySet ) ; err != nil { return err } if err := c . CleanupSubnetIfExists ( d . ResourceGroup , d . VirtualNetwork , d . SubnetName ) ; err != nil { return err } err = c . CleanupVirtualNetworkIfExists ( d . ResourceGroup , d . VirtualNetwork ) return err } 
func ( d * Driver ) GetIP ( ) ( string , error ) { if err := d . checkLegacyDriver ( true ) ; err != nil { return " " , err } if d . resolvedIP == " " { ip , err := d . ipAddress ( ) if err != nil { return " " , err } d . resolvedIP = ip } log . Debugf ( " " , d . resolvedIP ) return d . resolvedIP , nil } 
func ( d * Driver ) GetURL ( ) ( string , error ) { if err := drivers . MustBeRunning ( d ) ; err != nil { return " " , err } if err != nil { return " " , err } u := ( & url . URL { Scheme : " " , Host : net . JoinHostPort ( ip , fmt . Sprintf ( " " , d . DockerPort ) ) , } ) . String ( ) log . Debugf ( " " , u ) return u , nil } 
func ( d * Driver ) GetState ( ) ( state . State , error ) { if err := d . checkLegacyDriver ( true ) ; err != nil { return state . None , err } c , err := d . newAzureClient ( ) if err != nil { return state . None , err } powerState , err := c . GetVirtualMachinePowerState ( d . ResourceGroup , d . naming ( ) . VM ( ) ) if err != nil { return state . None , err } machineState := machineStateForVMPowerState ( powerState ) log . Debugf ( " " , powerState , machineState ) return machineState , nil } 
func ( d * Driver ) Start ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } return c . StartVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) Stop ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } c , err := d . newAzureClient ( ) if err != nil { return err } log . Info ( " " ) log . Info ( " " ) return c . StopVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) Restart ( ) error { if err := d . checkLegacyDriver ( true ) ; err != nil { return err } if err != nil { return err } return c . RestartVirtualMachine ( d . ResourceGroup , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) checkLegacyDriver ( short bool ) error { if d . ResourceGroup == " " { if short { return errors . New ( " " ) } return errors . New ( " " ) } return nil } 
func create ( ) { log . SetDebug ( true ) client := libmachine . NewClient ( " " , " " ) defer client . Close ( ) hostName := " " driver . CPU = 2 driver . Memory = 2048 data , err := json . Marshal ( driver ) if err != nil { log . Error ( err ) return } h , err := client . NewHost ( " " , data ) if err != nil { log . Error ( err ) return } h . HostOptions . EngineOptions . StorageDriver = " " if err := client . Create ( h ) ; err != nil { log . Error ( err ) return } out , err := h . RunSSHCommand ( " " ) if err != nil { log . Error ( err ) return } fmt . Printf ( " \n \n " , out ) fmt . Println ( " " ) if err := h . Stop ( ) ; err != nil { log . Error ( err ) return } } 
func streaming ( ) { log . SetDebug ( true ) client := libmachine . NewClient ( " " , " " ) defer client . Close ( ) hostName := " " data , err := json . Marshal ( driver ) if err != nil { log . Error ( err ) return } h , err := client . NewHost ( " " , data ) if err != nil { log . Error ( err ) return } if err := client . Create ( h ) ; err != nil { log . Error ( err ) return } h . HostOptions . EngineOptions . StorageDriver = " " sshClient , err := h . CreateSSHClient ( ) if err != nil { log . Error ( err ) return } stdout , stderr , err := sshClient . Start ( " " ) if err != nil { log . Error ( err ) return } defer func ( ) { _ = stdout . Close ( ) _ = stderr . Close ( ) } ( ) scanner := bufio . NewScanner ( stdout ) for scanner . Scan ( ) { fmt . Println ( scanner . Text ( ) ) } if err := scanner . Err ( ) ; err != nil { log . Error ( err ) } if err := sshClient . Wait ( ) ; err != nil { log . Error ( err ) } fmt . Println ( " " ) if err := h . Stop ( ) ; err != nil { log . Error ( err ) return } } 
func NewDriver ( hostName , storePath string ) * Driver { return & Driver { DiskSize : defaultDiskSize , MemSize : defaultMemory , CPU : defaultCPU , DisableDynamicMemory : defaultDisableDynamicMemory , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } } 
func ( d * Driver ) PreCreateCheck ( ) error { } } if err != nil { return err } if ! isAdmin { return ErrNotAdministrator } } err = b2dutils . UpdateISOCache ( d . Boot2DockerURL ) return err } 
func ( d * Driver ) waitForIP ( ) ( string , error ) { log . Infof ( " " ) for { ip , _ := d . GetIP ( ) if ip != " " { return ip , nil } time . Sleep ( 1 * time . Second ) } } 
func ( d * Driver ) waitStopped ( ) error { log . Infof ( " " ) for { s , err := d . GetState ( ) if err != nil { return err } if s != state . Running { return nil } time . Sleep ( 1 * time . Second ) } } 
func ( d * Driver ) Start ( ) error { if err := cmd ( " \\ " , d . MachineName ) ; err != nil { return err } ip , err := d . waitForIP ( ) if err != nil { return err } d . IPAddress = ip return nil } 
func ( d * Driver ) Stop ( ) error { if err := cmd ( " \\ " , d . MachineName ) ; err != nil { return err } if err := d . waitStopped ( ) ; err != nil { return err } d . IPAddress = " " return nil } 
func ( d * Driver ) Remove ( ) error { s , err := d . GetState ( ) if err != nil { return err } if s == state . Running { if err := d . Kill ( ) ; err != nil { return err } } return cmd ( " \\ " , d . MachineName , " " ) } 
func ( d * Driver ) generateDiskImage ( ) ( string , error ) { diskImage := d . ResolveStorePath ( " " ) fixed := d . ResolveStorePath ( " " ) if err != nil { return " " , err } fixedDiskSize := " " if ! isWindowsAdmin { fixedDiskSize = toMb ( d . DiskSize ) } log . Infof ( " " ) if err := cmd ( " \\ " , " " , quote ( fixed ) , " " , fixedDiskSize , " " ) ; err != nil { return " " , err } tarBuf , err := mcnutils . MakeDiskImage ( d . publicSSHKeyPath ( ) ) if err != nil { return " " , err } file , err := os . OpenFile ( fixed , os . O_WRONLY , 0644 ) if err != nil { return " " , err } defer file . Close ( ) file . Seek ( 0 , os . SEEK_SET ) _ , err = file . Write ( tarBuf . Bytes ( ) ) if err != nil { return " " , err } file . Close ( ) if err := cmd ( " \\ " , " " , quote ( fixed ) , " " , quote ( diskImage ) , " " , " " , " " ) ; err != nil { return " " , err } if isWindowsAdmin { if err := cmd ( " \\ " , " " , quote ( diskImage ) , " " , toMb ( d . DiskSize ) ) ; err != nil { return " " , err } } return diskImage , nil } 
func ( d * BaseDriver ) GetIP ( ) ( string , error ) { if d . IPAddress == " " { return " " , errors . New ( " " ) } return d . IPAddress , nil } 
func ( d * BaseDriver ) GetSSHKeyPath ( ) string { if d . SSHKeyPath == " " { d . SSHKeyPath = d . ResolveStorePath ( " " ) } return d . SSHKeyPath } 
func ( d * BaseDriver ) GetSSHPort ( ) ( int , error ) { if d . SSHPort == 0 { d . SSHPort = DefaultSSHPort } return d . SSHPort , nil } 
func ( d * BaseDriver ) GetSSHUsername ( ) string { if d . SSHUser == " " { d . SSHUser = DefaultSSHUser } return d . SSHUser } 
func ( d * BaseDriver ) ResolveStorePath ( file string ) string { return filepath . Join ( d . StorePath , " " , d . MachineName , file ) } 
func ( d * BaseDriver ) SetSwarmConfigFromFlags ( flags DriverOptions ) { d . SwarmMaster = flags . Bool ( " " ) d . SwarmHost = flags . String ( " " ) d . SwarmDiscovery = flags . String ( " " ) } 
func ( d * Driver ) IsVTXDisabledInTheVM ( ) ( bool , error ) { lines , err := d . readVBoxLog ( ) if err != nil { return true , err } for _ , line := range lines { if strings . Contains ( line , " " ) && ! strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) && strings . Contains ( line , " " ) { return true , nil } } return false , nil } 
func ( * b2dReleaseGetter ) getReleaseTag ( apiURL string ) ( string , error ) { if apiURL == " " { apiURL = defaultURL } if ! version . RC ( ) { } client := getClient ( ) req , err := getRequest ( apiURL ) if err != nil { return " " , err } rsp , err := client . Do ( req ) if err != nil { return " " , err } defer rsp . Body . Close ( ) } if err := json . NewDecoder ( rsp . Body ) . Decode ( & tags ) ; err != nil { return " " , err } t := tags [ 0 ] if t . TagName == " " { return " " , errGitHubAPIResponse } return t . TagName , nil } } if err := json . NewDecoder ( rsp . Body ) . Decode ( & t ) ; err != nil { return " " , err } if t . TagName == " " { return " " , errGitHubAPIResponse } return t . TagName , nil } 
func ( b * b2dReleaseGetter ) getReleaseURL ( apiURL string ) ( string , error ) { if apiURL == " " { apiURL = defaultURL } matches := re . FindStringSubmatch ( apiURL ) if len ( matches ) != 6 { } scheme , host , org , repo := matches [ 1 ] , matches [ 2 ] , matches [ 4 ] , matches [ 5 ] if host == " " { host = " " } tag , err := b . getReleaseTag ( apiURL ) if err != nil { return " " , err } log . Infof ( " " , host , org , repo , tag ) bugURL , ok := AUFSBugB2DVersions [ tag ] if ok { log . Warnf ( ` Boot2Docker %s has a known issue with AUFS. See here for more details: %s Consider specifying another storage driver (e.g. 'overlay') using '--engine-storage-driver' instead. ` , tag , bugURL ) } url := fmt . Sprintf ( " " , scheme , host , org , repo , tag , b . isoFilename ) return url , nil } 
func ( b * b2dISO ) version ( ) ( string , error ) { if b == nil { return " " , nil } iso , err := os . Open ( b . commonIsoPath ) if err != nil { return " " , err } defer iso . Close ( ) isoMetadata := make ( [ ] byte , b . volumeIDLength ) _ , err = iso . ReadAt ( isoMetadata , b . volumeIDOffset ) if err != nil { return " " , err } trimmedVersion := strings . TrimSpace ( string ( isoMetadata ) ) versionIndex := strings . Index ( trimmedVersion , versionPrefix ) if versionIndex == - 1 { return " " , fmt . Errorf ( " " , versionPrefix ) } log . Debug ( " " , vers ) return vers , nil } 
func ( b * B2dUtils ) DownloadISO ( dir , file , isoURL string ) error { log . Infof ( " " , b . path ( ) , isoURL ) return b . download ( dir , file , isoURL ) } 
func MakeDiskImage ( publicSSHKeyPath string ) ( * bytes . Buffer , error ) { magicString := " " buf := new ( bytes . Buffer ) tw := tar . NewWriter ( buf ) log . Debug ( " " ) if err := tw . WriteHeader ( file ) ; err != nil { return nil , err } if _ , err := tw . Write ( [ ] byte ( magicString ) ) ; err != nil { return nil , err } if err := tw . WriteHeader ( file ) ; err != nil { return nil , err } log . Debug ( " " ) pubKey , err := ioutil . ReadFile ( publicSSHKeyPath ) if err != nil { return nil , err } file = & tar . Header { Name : " " , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return nil , err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return nil , err } file = & tar . Header { Name : " " , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return nil , err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return nil , err } if err := tw . Close ( ) ; err != nil { return nil , err } return buf , nil } 
func ( c * Client ) Authenticate ( d * openstack . Driver ) error { if c . Provider != nil { return nil } log . Debug ( " " , map [ string ] string { " " : d . Username , } ) apiKey := c . driver . APIKey opts := gophercloud . AuthOptions { Username : d . Username , APIKey : apiKey , } provider , err := rackspace . NewClient ( rackspace . RackspaceUSIdentity ) if err != nil { return err } provider . UserAgent . Prepend ( fmt . Sprintf ( " " , version . APIVersion ) ) err = rackspace . Authenticate ( provider , opts ) if err != nil { return err } c . Provider = provider return nil } 
func ( c * Client ) GetInstanceIPAddresses ( d * openstack . Driver ) ( [ ] openstack . IPAddress , error ) { server , err := c . GetServerDetail ( d ) if err != nil { return nil , err } return [ ] openstack . IPAddress { { Network : " " , Address : server . AccessIPv4 , AddressType : openstack . Fixed , } , } , nil } 
func targetHost ( c CommandLine , api libmachine . API ) ( string , error ) { if len ( c . Args ( ) ) == 0 { defaultExists , err := api . Exists ( defaultMachineName ) if err != nil { return " " , fmt . Errorf ( " " , defaultMachineName , err ) } if defaultExists { return defaultMachineName , nil } return " " , ErrNoDefault } return c . Args ( ) [ 0 ] , nil } 
func machineCommand ( actionName string , host * host . Host , errorChan chan <- error ) { log . Debugf ( " " , actionName , host . Name ) errorChan <- commands [ actionName ] ( ) } 
func runActionForeachMachine ( actionName string , machines [ ] * host . Host ) [ ] error { var ( numConcurrentActions = 0 errorChan = make ( chan error ) errs = [ ] error { } ) for _ , machine := range machines { numConcurrentActions ++ go machineCommand ( actionName , machine , errorChan ) } } } close ( errorChan ) return errs } 
func attemptGetHostState ( h * host . Host , stateQueryChan chan <- HostListItem ) { requestBeginning := time . Now ( ) url := " " currentState := state . None dockerVersion := " " hostError := " " url , err := h . URL ( ) } else { currentState , err = h . Driver . GetState ( ) } } else { currentState , _ = h . Driver . GetState ( ) } if err == nil && url != " " { dockerVersion , err = mcndockerclient . DockerVersion ( dockerHost ) if err != nil { dockerVersion = " " } else { dockerVersion = fmt . Sprintf ( " " , dockerVersion ) } } if err != nil { hostError = err . Error ( ) } if hostError == drivers . ErrHostIsNotRunning . Error ( ) { hostError = " " } var swarmOptions * swarm . Options var engineOptions * engine . Options if h . HostOptions != nil { swarmOptions = h . HostOptions . SwarmOptions engineOptions = h . HostOptions . EngineOptions } isMaster := false swarmHost := " " if swarmOptions != nil { isMaster = swarmOptions . Master swarmHost = swarmOptions . Host } activeHost := isActive ( currentState , url ) activeSwarm := isSwarmActive ( currentState , url , isMaster , swarmHost ) active := " " if activeHost { active = " " } if activeSwarm { active = " " } stateQueryChan <- HostListItem { Name : h . Name , Active : active , ActiveHost : activeHost , ActiveSwarm : activeSwarm , DriverName : h . Driver . DriverName ( ) , State : currentState , URL : url , SwarmOptions : swarmOptions , EngineOptions : engineOptions , DockerVersion : dockerVersion , Error : hostError , ResponseTime : time . Now ( ) . Round ( time . Millisecond ) . Sub ( requestBeginning . Round ( time . Millisecond ) ) , } } 
func DockerClientVersion ( ssh SSHCommander ) ( string , error ) { if err != nil { return " " , err } words := strings . Fields ( output ) if len ( words ) < 3 || words [ 0 ] != " " || words [ 1 ] != " " { return " " , fmt . Errorf ( " " , output ) } return strings . TrimRight ( words [ 2 ] , " " ) , nil } 
func SplitPortProto ( raw string ) ( port string , protocol string ) { parts := strings . SplitN ( raw , " " , 2 ) if len ( parts ) == 1 { return parts [ 0 ] , " " } return parts [ 0 ] , parts [ 1 ] } 
func ( api * Client ) Create ( h * host . Host ) error { if err := cert . BootstrapCertificates ( h . AuthOptions ( ) ) ; err != nil { return fmt . Errorf ( " " , err ) } log . Info ( " " ) if err := h . Driver . PreCreateCheck ( ) ; err != nil { return mcnerror . ErrDuringPreCreate { Cause : err , } } if err := api . Save ( h ) ; err != nil { return fmt . Errorf ( " " , err ) } log . Info ( " " ) if err := api . performCreate ( h ) ; err != nil { return fmt . Errorf ( " " , err ) } log . Debug ( " " ) return nil } 
func TruncateID ( id string ) string { shortLen := 12 if len ( id ) < shortLen { shortLen = len ( id ) } return id [ : shortLen ] } 
func GenerateRandomID ( ) string { for { id := make ( [ ] byte , 32 ) if _ , err := io . ReadFull ( rand . Reader , id ) ; err != nil { panic ( err ) } value := hex . EncodeToString ( id ) } return value } } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultRegionName , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultEndpointType , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultFlavorID , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHUser , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSSHPort , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultDockerInstall , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultActiveTimeout , } , } } 
func NewDriver ( machineName , storePath string ) drivers . Driver { log . Debug ( " " , map [ string ] string { " " : machineName } ) inner := openstack . NewDerivedDriver ( machineName , storePath ) driver := & Driver { Driver : inner , } inner . SetClient ( & Client { driver : driver , } ) return driver } 
func ( d * Driver ) SetConfigFromFlags ( flags drivers . DriverOptions ) error { d . ActiveTimeout = flags . Int ( " " ) d . Username = flags . String ( " " ) d . APIKey = flags . String ( " " ) d . Region = flags . String ( " " ) d . EndpointType = flags . String ( " " ) d . ImageId = flags . String ( " " ) d . FlavorId = flags . String ( " " ) d . SSHUser = flags . String ( " " ) d . SSHPort = flags . Int ( " " ) d . SetSwarmConfigFromFlags ( flags ) if d . Region == " " { return missingEnvOrOption ( " " , " " , " " ) } if d . Username == " " { return missingEnvOrOption ( " " , " " , " " ) } if d . APIKey == " " { return missingEnvOrOption ( " " , " " , " " ) } if d . ImageId == " " { } if d . EndpointType != " " && d . EndpointType != " " && d . EndpointType != " " { return fmt . Errorf ( " " , d . EndpointType ) } return nil } 
func ( rd * RemoteDocker ) URL ( ) ( string , error ) { if rd . HostURL == " " { return " " , fmt . Errorf ( " " ) } return rd . HostURL , nil } 
func ( d * Driver ) newAzureClient ( ) ( * azureutil . AzureClient , error ) { env , ok := environments [ d . Environment ] if ! ok { valid := make ( [ ] string , 0 , len ( environments ) ) for k := range environments { valid = append ( valid , k ) } return nil , fmt . Errorf ( " " , d . Environment , strings . Join ( valid , " " ) ) } var ( token * azure . ServicePrincipalToken err error ) if d . ClientID != " " && d . ClientSecret != " " { token , err = azureutil . AuthenticateServicePrincipal ( env , d . SubscriptionID , d . ClientID , d . ClientSecret ) if err != nil { return nil , fmt . Errorf ( " " , err ) } } else { token , err = azureutil . AuthenticateDeviceFlow ( env , d . SubscriptionID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } } return azureutil . New ( env , d . SubscriptionID , token ) , nil } 
func ( d * Driver ) generateSSHKey ( ctx * azureutil . DeploymentContext ) error { privPath := d . GetSSHKeyPath ( ) pubPath := privPath + " " log . Debug ( " " , logutil . Fields { " " : pubPath , " " : privPath , } ) if err := ssh . GenerateSSHKey ( privPath ) ; err != nil { return err } log . Debug ( " " ) publicKey , err := ioutil . ReadFile ( pubPath ) ctx . SSHPublicKey = string ( publicKey ) return err } 
func ( d * Driver ) getSecurityRules ( extraPorts [ ] string ) ( * [ ] network . SecurityRule , error ) { mkRule := func ( priority int , name , description , srcPort , dstPort string , proto network . SecurityRuleProtocol ) network . SecurityRule { return network . SecurityRule { Name : to . StringPtr ( name ) , Properties : & network . SecurityRulePropertiesFormat { Description : to . StringPtr ( description ) , SourceAddressPrefix : to . StringPtr ( " " ) , DestinationAddressPrefix : to . StringPtr ( " " ) , SourcePortRange : to . StringPtr ( srcPort ) , DestinationPortRange : to . StringPtr ( dstPort ) , Access : network . Allow , Direction : network . Inbound , Protocol : proto , Priority : to . Int32Ptr ( int32 ( priority ) ) , } , } } log . Debugf ( " " , d . DockerPort ) log . Debugf ( " " , swarmHost ) u , err := url . Parse ( swarmHost ) if err != nil { return nil , fmt . Errorf ( " " , swarmHost , err ) } _ , swarmPort , err := net . SplitHostPort ( u . Host ) if err != nil { return nil , fmt . Errorf ( " " , u . Host , err ) } rl = append ( rl , mkRule ( 500 , " " , " " , " " , swarmPort , network . TCP ) ) } else { log . Debug ( " " ) } for i , p := range extraPorts { port , protocol := driverutil . SplitPortProto ( p ) proto , err := parseSecurityRuleProtocol ( protocol ) if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Debugf ( " " , port , proto ) name := fmt . Sprintf ( " " , port , proto ) name = strings . Replace ( name , " " , " " , - 1 ) r := mkRule ( basePri + i , name , " " , " " , port , proto ) rl = append ( rl , r ) } log . Debugf ( " " , len ( rl ) ) return & rl , nil } 
func ( d * Driver ) ipAddress ( ) ( ip string , err error ) { c , err := d . newAzureClient ( ) if err != nil { return " " , err } var ipType string if d . UsePrivateIP || d . NoPublicIP { ipType = " " ip , err = c . GetPrivateIPAddress ( d . ResourceGroup , d . naming ( ) . NIC ( ) ) } else { ipType = " " ip , err = c . GetPublicIPAddress ( d . ResourceGroup , d . naming ( ) . IP ( ) , d . DNSLabel != " " ) } log . Debugf ( " " , ipType ) if err != nil { return " " , fmt . Errorf ( " " , ipType , err ) } if ip == " " { log . Debugf ( " " , ipType ) } return ip , nil } 
func parseVirtualNetwork ( name string , defaultRG string ) ( string , string ) { l := strings . SplitN ( name , " " , 2 ) if len ( l ) == 2 { return l [ 0 ] , l [ 1 ] } return defaultRG , name } 
func parseSecurityRuleProtocol ( proto string ) ( network . SecurityRuleProtocol , error ) { switch strings . ToLower ( proto ) { case " " : return network . TCP , nil case " " : return network . UDP , nil case " " : return network . Asterisk , nil default : return " " , fmt . Errorf ( " " , proto ) } } 
func ( s State ) String ( ) string { if int ( s ) >= 0 && int ( s ) < len ( states ) { return states [ s ] } return " " } 
func randomAzureStorageAccountName ( ) string { const ( maxLen = 24 chars = " " ) return storageAccountPrefix + randomString ( maxLen - len ( storageAccountPrefix ) , chars ) } 
func randomString ( n int , alphabet string ) string { r := timeSeed ( ) b := make ( [ ] byte , n ) for i := range b { b [ i ] = alphabet [ r . Intn ( len ( alphabet ) ) ] } return string ( b ) } 
func parseImageName ( image string ) ( imageName , error ) { l := strings . Split ( image , " " ) if len ( l ) != 4 { return imageName { } , fmt . Errorf ( " " , image ) } return imageName { l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] } , nil } 
func parseSwarm ( hostURL string , h * host . Host ) ( string , error ) { swarmOptions := h . HostOptions . SwarmOptions if ! swarmOptions . Master { return " " , fmt . Errorf ( " " , h . Name ) } u , err := url . Parse ( swarmOptions . Host ) if err != nil { return " " , fmt . Errorf ( " " , err ) } parts := strings . Split ( u . Host , " " ) swarmPort := parts [ 1 ] if err != nil { return " " , fmt . Errorf ( " " , err ) } mParts := strings . Split ( mURL . Host , " " ) machineIP := mParts [ 0 ] hostURL = fmt . Sprintf ( " " , machineIP , swarmPort ) return hostURL , nil } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultCpus , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultMemory , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultDiskSize , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . IntFlag { EnvVar : " " , Name : " " , Usage : " " , Value : defaultSDKPort , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringSliceFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringSliceFlag { EnvVar : " " , Name : " " , Usage : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) PreCreateCheck ( ) error { log . Debug ( " " ) defer cancel ( ) c , err := d . vsphereLogin ( ctx ) if err != nil { return err } defer c . Logout ( ctx ) dc , err := f . DatacenterOrDefault ( ctx , d . Datacenter ) if err != nil { return err } f . SetDatacenter ( dc ) if err != nil { return err } folder , err := f . Folder ( ctx , fmt . Sprintf ( " " , folders . VmFolder . InventoryPath , d . Folder ) ) } if folder == nil { return fmt . Errorf ( " " , d . Folder ) } } if _ , err := f . DatastoreOrDefault ( ctx , d . Datastore ) ; err != nil { return err } } for _ , netName := range d . Networks { if _ , err := f . NetworkOrDefault ( ctx , netName ) ; err != nil { return err } } var hs * object . HostSystem if d . HostSystem != " " { var err error hs , err = f . HostSystemOrDefault ( ctx , d . HostSystem ) if err != nil { return err } } } } else if hs != nil { } } else { } } return nil } 
func ( d * Driver ) Create ( ) error { b2dutils := mcnutils . NewB2dUtils ( d . StorePath ) if err := b2dutils . CopyIsoToMachineDir ( d . Boot2DockerURL , d . MachineName ) ; err != nil { return err } log . Infof ( " " ) if err := ssh . GenerateSSHKey ( d . GetSSHKeyPath ( ) ) ; err != nil { return err } defer cancel ( ) c , err := d . vsphereLogin ( ctx ) if err != nil { return err } defer c . Logout ( ctx ) dc , err := f . DatacenterOrDefault ( ctx , d . Datacenter ) if err != nil { return err } f . SetDatacenter ( dc ) dss , err := f . DatastoreOrDefault ( ctx , d . Datastore ) if err != nil { return err } networks := make ( map [ string ] object . NetworkReference ) for _ , netName := range d . Networks { net , err := f . NetworkOrDefault ( ctx , netName ) if err != nil { return err } networks [ netName ] = net } var hs * object . HostSystem if d . HostSystem != " " { var err error hs , err = f . HostSystemOrDefault ( ctx , d . HostSystem ) if err != nil { return err } } var rp * object . ResourcePool if d . Pool != " " { if err != nil { return err } } else if d . HostSystem != " " { if err != nil { return err } } else { if err != nil { return err } } spec := types . VirtualMachineConfigSpec { Name : d . MachineName , GuestId : " " , Files : & types . VirtualMachineFileInfo { VmPathName : fmt . Sprintf ( " " , dss . Name ( ) ) } , NumCPUs : int32 ( d . CPU ) , MemoryMB : int64 ( d . Memory ) , } scsi , err := object . SCSIControllerTypes ( ) . CreateSCSIController ( " " ) if err != nil { return err } spec . DeviceChange = append ( spec . DeviceChange , & types . VirtualDeviceConfigSpec { Operation : types . VirtualDeviceConfigSpecOperationAdd , Device : scsi , } ) log . Infof ( " " ) folders , err := dc . Folders ( ctx ) folder := folders . VmFolder if d . Folder != " " { folder , err = f . Folder ( ctx , fmt . Sprintf ( " " , folders . VmFolder . InventoryPath , d . Folder ) ) if err != nil { return err } } task , err := folder . CreateVM ( ctx , spec , rp , hs ) if err != nil { return err } info , err := task . WaitForResult ( ctx , nil ) if err != nil { return err } log . Infof ( " " ) dsurl , err := dss . URL ( ctx , dc , fmt . Sprintf ( " " , d . MachineName , isoFilename ) ) if err != nil { return err } p := soap . DefaultUpload if err = c . Client . UploadFile ( d . ISO , dsurl , & p ) ; err != nil { return err } devices , err := vm . Device ( ctx ) if err != nil { return err } var add [ ] types . BaseVirtualDevice controller , err := devices . FindDiskController ( " " ) if err != nil { return err } disk := devices . CreateDisk ( controller , dss . Reference ( ) , dss . Path ( fmt . Sprintf ( " " , d . MachineName , d . MachineName ) ) ) add = append ( add , disk ) ide , err := devices . FindIDEController ( " " ) if err != nil { return err } cdrom , err := devices . CreateCdrom ( ide ) if err != nil { return err } add = append ( add , devices . InsertIso ( cdrom , dss . Path ( fmt . Sprintf ( " " , d . MachineName , isoFilename ) ) ) ) for _ , netName := range d . Networks { backing , err := networks [ netName ] . EthernetCardBackingInfo ( ctx ) if err != nil { return err } netdev , err := object . EthernetCardTypes ( ) . CreateEthernetCard ( " " , backing ) if err != nil { return err } log . Infof ( " " , netName ) add = append ( add , netdev ) } log . Infof ( " " ) if vm . AddDevice ( ctx , add ... ) ; err != nil { return err } for _ , param := range d . CfgParams { v := strings . SplitN ( param , " " , 2 ) key := v [ 0 ] value := " " if len ( v ) > 1 { value = v [ 1 ] } fmt . Printf ( " \n " , key , value ) opts = append ( opts , & types . OptionValue { Key : key , Value : value , } ) } if d . CloudInit != " " { if _ , err := url . ParseRequestURI ( d . CloudInit ) ; err == nil { log . Infof ( " \n " , d . CloudInit ) opts = append ( opts , & types . OptionValue { Key : " " , Value : d . CloudInit , } ) } else { if _ , err := os . Stat ( d . CloudInit ) ; err == nil { if value , err := ioutil . ReadFile ( d . CloudInit ) ; err == nil { log . Infof ( " \n " , d . CloudInit ) encoded := base64 . StdEncoding . EncodeToString ( value ) opts = append ( opts , & types . OptionValue { Key : " " , Value : encoded , } ) opts = append ( opts , & types . OptionValue { Key : " " , Value : " " , } ) } } } } task , err = vm . Reconfigure ( ctx , types . VirtualMachineConfigSpec { ExtraConfig : opts , } ) if err != nil { return err } task . Wait ( ctx ) if err := d . Start ( ) ; err != nil { return err } log . Infof ( " " ) } opman := guest . NewOperationsManager ( c . Client , vm . Reference ( ) ) fileman , err := opman . FileManager ( ctx ) if err != nil { return err } src := d . ResolveStorePath ( " " ) s , err := os . Stat ( src ) if err != nil { return err } auth := AuthFlag { } flag := FileAttrFlag { } auth . auth . Username = B2DUser auth . auth . Password = B2DPass flag . SetPerms ( 0 , 0 , 660 ) url , err := fileman . InitiateFileTransferToGuest ( ctx , auth . Auth ( ) , " " , flag . Attr ( ) , s . Size ( ) , true ) if err != nil { return err } u , err := c . Client . ParseURL ( url ) if err != nil { return err } if err = c . Client . UploadFile ( src , u , nil ) ; err != nil { return err } procman , err := opman . ProcessManager ( ctx ) if err != nil { return err } guestspec := types . GuestProgramSpec { ProgramPath : " " , Arguments : " \" \" " , WorkingDirectory : " " , EnvVariables : env , } _ , err = procman . StartProgram ( ctx , auth . Auth ( ) , & guestspec ) if err != nil { return err } _ , err = procman . StartProgram ( ctx , auth . Auth ( ) , & guestspec ) if err != nil { return err } return nil } 
func ( d * Driver ) generateKeyBundle ( ) error { log . Debugf ( " " ) magicString := " " tf , err := os . Create ( d . ResolveStorePath ( " " ) ) if err != nil { return err } defer tf . Close ( ) var fileWriter = tf tw := tar . NewWriter ( fileWriter ) defer tw . Close ( ) if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( magicString ) ) ; err != nil { return err } if err := tw . WriteHeader ( file ) ; err != nil { return err } pubKey , err := ioutil . ReadFile ( d . publicSSHKeyPath ( ) ) if err != nil { return err } file = & tar . Header { Name : " " , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return err } file = & tar . Header { Name : " " , Size : int64 ( len ( pubKey ) ) , Mode : 0644 } if err := tw . WriteHeader ( file ) ; err != nil { return err } if _ , err := tw . Write ( [ ] byte ( pubKey ) ) ; err != nil { return err } err = tw . Close ( ) return err } 
func NewDriver ( hostName , storePath string ) * Driver { return & Driver { VBoxManager : NewVBoxManager ( ) , b2dUpdater : NewB2DUpdater ( ) , sshKeyGenerator : NewSSHKeyGenerator ( ) , diskCreator : NewDiskCreator ( ) , logsReader : NewLogsReader ( ) , ipWaiter : NewIPWaiter ( ) , randomInter : NewRandomInter ( ) , sleeper : NewSleeper ( ) , HostInterfaces : NewHostInterfaces ( ) , Memory : defaultMemory , CPU : defaultCPU , DiskSize : defaultDiskSize , NatNicType : defaultHostOnlyNictype , HostOnlyCIDR : defaultHostOnlyCIDR , HostOnlyNicType : defaultHostOnlyNictype , HostOnlyPromiscMode : defaultHostOnlyPromiscMode , UIType : defaultUIType , HostOnlyNoDHCP : defaultHostOnlyNoDHCP , DNSProxy : defaultDNSProxy , HostDNSResolver : defaultDNSResolver , BaseDriver : & drivers . BaseDriver { MachineName : hostName , StorePath : storePath , } , } } 
func ( d * Driver ) GetCreateFlags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . IntFlag { Name : " " , Usage : " " , Value : defaultMemory , EnvVar : " " , } , mcnflag . IntFlag { Name : " " , Usage : " " , Value : defaultCPU , EnvVar : " " , } , mcnflag . IntFlag { Name : " " , Usage : " " , Value : defaultDiskSize , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultBoot2DockerURL , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultBoot2DockerImportVM , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultHostOnlyNictype , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultHostOnlyCIDR , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultHostOnlyNictype , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultHostOnlyPromiscMode , EnvVar : " " , } , mcnflag . StringFlag { Name : " " , Usage : " " , Value : defaultUIType , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . BoolFlag { Name : " " , Usage : " " , EnvVar : " " , } , mcnflag . StringFlag { EnvVar : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) PreCreateCheck ( ) error { if err != nil { return err } } if ! d . NoVTXCheck { if isHyperVInstalled ( ) { return ErrNotCompatibleWithHyperV } if d . IsVTXDisabled ( ) { return ErrMustEnableVTX } } } } return nil } 
func ( d * Driver ) Restart ( ) error { if err := d . Stop ( ) ; err != nil { return fmt . Errorf ( " " , err ) } if err := d . Start ( ) ; err != nil { return fmt . Errorf ( " " , err ) } d . IPAddress = " " return d . ipWaiter . Wait ( d ) } 
func validateNoIPCollisions ( hif HostInterfaces , hostOnlyNet * net . IPNet , currHostOnlyNets map [ string ] * hostOnlyNetwork ) error { hostOnlyByCIDR := map [ string ] * hostOnlyNetwork { } hostOnlyByCIDR [ ipnet . String ( ) ] = n } m , err := listHostInterfaces ( hif , hostOnlyByCIDR ) if err != nil { return err } collision , err := checkIPNetCollision ( hostOnlyNet , m ) if err != nil { return err } if collision { return ErrNetworkAddrCollision } return nil } 
func getAvailableTCPPort ( port int ) ( int , error ) { for i := 0 ; i <= 10 ; i ++ { ln , err := net . Listen ( " " , fmt . Sprintf ( " " , port ) ) if err != nil { return 0 , err } defer ln . Close ( ) addr := ln . Addr ( ) . String ( ) addrParts := strings . SplitN ( addr , " " , 2 ) p , err := strconv . Atoi ( addrParts [ 1 ] ) if err != nil { return 0 , err } if p != 0 { port = p return port , nil } port = 0 time . Sleep ( 1 ) } return 0 , fmt . Errorf ( " " ) } 
func setPortForwarding ( d * Driver , interfaceNum int , mapName , protocol string , guestPort , desiredHostPort int ) ( int , error ) { actualHostPort , err := getAvailableTCPPort ( desiredHostPort ) if err != nil { return - 1 , err } if desiredHostPort != actualHostPort && desiredHostPort != 0 { log . Debugf ( " " , guestPort , mapName , desiredHostPort , actualHostPort ) } cmd := fmt . Sprintf ( " " , interfaceNum ) d . vbm ( " " , d . MachineName , cmd , " " , mapName ) if err := d . vbm ( " " , d . MachineName , cmd , fmt . Sprintf ( " " , mapName , protocol , actualHostPort , guestPort ) ) ; err != nil { return - 1 , err } return actualHostPort , nil } 
func getRandomIPinSubnet ( d * Driver , baseIP net . IP ) ( net . IP , error ) { var dhcpAddr net . IP nAddr := baseIP . To4 ( ) if byte ( n ) != nAddr [ 3 ] { dhcpAddr = net . IPv4 ( nAddr [ 0 ] , nAddr [ 1 ] , nAddr [ 2 ] , byte ( n ) ) break } } if dhcpAddr == nil { return nil , ErrUnableToGenerateRandomIP } return dhcpAddr , nil } 
func Detect ( ) ( string , error ) { shell := os . Getenv ( " " ) if shell == " " { fmt . Printf ( " \n \n " ) return " " , ErrUnknownShell } return filepath . Base ( shell ) , nil } 
func vaultRenewDuration ( s * Secret ) time . Duration { if s . Auth != nil && s . Auth . LeaseDuration > 0 { base = s . Auth . LeaseDuration } } if vaultSecretRenewable ( s ) { } else { } return time . Duration ( sleep ) } 
func printVaultWarnings ( d Dependency , warnings [ ] string ) { for _ , w := range warnings { log . Printf ( " " , d , w ) } } 
func vaultSecretRenewable ( s * Secret ) bool { if s . Auth != nil { return s . Auth . Renewable } return s . Renewable } 
func transformSecret ( theirs * api . Secret ) * Secret { var ours Secret updateSecret ( & ours , theirs ) return & ours } 
func updateSecret ( ours * Secret , theirs * api . Secret ) { if theirs . RequestID != " " { ours . RequestID = theirs . RequestID } if theirs . LeaseID != " " { ours . LeaseID = theirs . LeaseID } if theirs . LeaseDuration != 0 { ours . LeaseDuration = theirs . LeaseDuration } if theirs . Renewable { ours . Renewable = theirs . Renewable } if len ( theirs . Data ) != 0 { ours . Data = theirs . Data } if len ( theirs . Warnings ) != 0 { ours . Warnings = theirs . Warnings } if theirs . Auth != nil { if ours . Auth == nil { ours . Auth = & SecretAuth { } } if theirs . Auth . ClientToken != " " { ours . Auth . ClientToken = theirs . Auth . ClientToken } if theirs . Auth . Accessor != " " { ours . Auth . Accessor = theirs . Auth . Accessor } if len ( theirs . Auth . Policies ) != 0 { ours . Auth . Policies = theirs . Auth . Policies } if len ( theirs . Auth . Metadata ) != 0 { ours . Auth . Metadata = theirs . Auth . Metadata } if theirs . Auth . LeaseDuration != 0 { ours . Auth . LeaseDuration = theirs . Auth . LeaseDuration } if theirs . Auth . Renewable { ours . Auth . Renewable = theirs . Auth . Renewable } } if theirs . WrapInfo != nil { if ours . WrapInfo == nil { ours . WrapInfo = & SecretWrapInfo { } } if theirs . WrapInfo . Token != " " { ours . WrapInfo . Token = theirs . WrapInfo . Token } if theirs . WrapInfo . TTL != 0 { ours . WrapInfo . TTL = theirs . WrapInfo . TTL } if ! theirs . WrapInfo . CreationTime . IsZero ( ) { ours . WrapInfo . CreationTime = theirs . WrapInfo . CreationTime } if theirs . WrapInfo . WrappedAccessor != " " { ours . WrapInfo . WrappedAccessor = theirs . WrapInfo . WrappedAccessor } } } 
func ( c * TemplateConfig ) Copy ( ) * TemplateConfig { if c == nil { return nil } var o TemplateConfig o . Backup = c . Backup o . Command = c . Command o . CommandTimeout = c . CommandTimeout o . Contents = c . Contents o . CreateDestDirs = c . CreateDestDirs o . Destination = c . Destination o . ErrMissingKey = c . ErrMissingKey if c . Exec != nil { o . Exec = c . Exec . Copy ( ) } o . Perms = c . Perms o . Source = c . Source if c . Wait != nil { o . Wait = c . Wait . Copy ( ) } o . LeftDelim = c . LeftDelim o . RightDelim = c . RightDelim return & o } 
func ( c * TemplateConfig ) Merge ( o * TemplateConfig ) * TemplateConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Backup != nil { r . Backup = o . Backup } if o . Command != nil { r . Command = o . Command } if o . CommandTimeout != nil { r . CommandTimeout = o . CommandTimeout } if o . Contents != nil { r . Contents = o . Contents } if o . CreateDestDirs != nil { r . CreateDestDirs = o . CreateDestDirs } if o . Destination != nil { r . Destination = o . Destination } if o . ErrMissingKey != nil { r . ErrMissingKey = o . ErrMissingKey } if o . Exec != nil { r . Exec = r . Exec . Merge ( o . Exec ) } if o . Perms != nil { r . Perms = o . Perms } if o . Source != nil { r . Source = o . Source } if o . Wait != nil { r . Wait = r . Wait . Merge ( o . Wait ) } if o . LeftDelim != nil { r . LeftDelim = o . LeftDelim } if o . RightDelim != nil { r . RightDelim = o . RightDelim } return r } 
func ( c * TemplateConfig ) Finalize ( ) { if c . Backup == nil { c . Backup = Bool ( false ) } if c . Command == nil { c . Command = String ( " " ) } if c . CommandTimeout == nil { c . CommandTimeout = TimeDuration ( DefaultTemplateCommandTimeout ) } if c . Contents == nil { c . Contents = String ( " " ) } if c . CreateDestDirs == nil { c . CreateDestDirs = Bool ( true ) } if c . Destination == nil { c . Destination = String ( " " ) } if c . ErrMissingKey == nil { c . ErrMissingKey = Bool ( false ) } if c . Exec == nil { c . Exec = DefaultExecConfig ( ) } } if c . Exec . Timeout == nil && c . CommandTimeout != nil { c . Exec . Timeout = c . CommandTimeout } c . Exec . Finalize ( ) if c . Perms == nil { c . Perms = FileMode ( 0 ) } if c . Source == nil { c . Source = String ( " " ) } if c . Wait == nil { c . Wait = DefaultWaitConfig ( ) } c . Wait . Finalize ( ) if c . LeftDelim == nil { c . LeftDelim = String ( " " ) } if c . RightDelim == nil { c . RightDelim = String ( " " ) } } 
func ( c * TemplateConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , BoolGoString ( c . Backup ) , StringGoString ( c . Command ) , TimeDurationGoString ( c . CommandTimeout ) , StringGoString ( c . Contents ) , BoolGoString ( c . CreateDestDirs ) , StringGoString ( c . Destination ) , BoolGoString ( c . ErrMissingKey ) , c . Exec , FileModeGoString ( c . Perms ) , StringGoString ( c . Source ) , c . Wait , StringGoString ( c . LeftDelim ) , StringGoString ( c . RightDelim ) , ) } 
func ( c * TemplateConfig ) Display ( ) string { if c == nil { return " " } source := c . Source if StringPresent ( c . Contents ) { source = String ( " " ) } return fmt . Sprintf ( " " , StringVal ( source ) , StringVal ( c . Destination ) , ) } 
func ( c * TemplateConfigs ) Copy ( ) * TemplateConfigs { o := make ( TemplateConfigs , len ( * c ) ) for i , t := range * c { o [ i ] = t . Copy ( ) } return & o } 
func ( c * TemplateConfigs ) Merge ( o * TemplateConfigs ) * TemplateConfigs { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) * r = append ( * r , * o ... ) return r } 
func ( c * TemplateConfigs ) Finalize ( ) { if c == nil { * c = * DefaultTemplateConfigs ( ) } for _ , t := range * c { t . Finalize ( ) } } 
func ( c * TemplateConfigs ) GoString ( ) string { if c == nil { return " " } s := make ( [ ] string , len ( * c ) ) for i , t := range * c { s [ i ] = t . GoString ( ) } return " " + strings . Join ( s , " " ) + " " } 
func ParseTemplateConfig ( s string ) ( * TemplateConfig , error ) { if len ( strings . TrimSpace ( s ) ) < 1 { return nil , ErrTemplateStringEmpty } var source , destination , command string parts := configTemplateRe . FindAllString ( s , - 1 ) switch len ( parts ) { case 1 : source = parts [ 0 ] case 2 : source , destination = parts [ 0 ] , parts [ 1 ] case 3 : source , destination , command = parts [ 0 ] , parts [ 1 ] , parts [ 2 ] default : source , destination = parts [ 0 ] , parts [ 1 ] command = strings . Join ( parts [ 2 : ] , " " ) } var sourcePtr , destinationPtr , commandPtr * string if source != " " { sourcePtr = String ( source ) } if destination != " " { destinationPtr = String ( destination ) } if command != " " { commandPtr = String ( command ) } return & TemplateConfig { Source : sourcePtr , Destination : destinationPtr , Command : commandPtr , } , nil } 
func NewVaultWriteQuery ( s string , d map [ string ] interface { } ) ( * VaultWriteQuery , error ) { s = strings . TrimSpace ( s ) s = strings . Trim ( s , " " ) if s == " " { return nil , fmt . Errorf ( " " , s ) } return & VaultWriteQuery { stopCh : make ( chan struct { } , 1 ) , path : s , data : d , dataHash : sha1Map ( d ) , } , nil } 
func ( d * VaultWriteQuery ) String ( ) string { return fmt . Sprintf ( " " , d . path , d . dataHash ) } 
func sha1Map ( m map [ string ] interface { } ) string { keys := make ( [ ] string , 0 , len ( m ) ) for k , _ := range m { keys = append ( keys , k ) } sort . Strings ( keys ) h := sha1 . New ( ) for _ , k := range keys { io . WriteString ( h , fmt . Sprintf ( " " , k , m [ k ] ) ) } return fmt . Sprintf ( " " , h . Sum ( nil ) ) } 
func NewView ( i * NewViewInput ) ( * View , error ) { return & View { dependency : i . Dependency , clients : i . Clients , maxStale : i . MaxStale , once : i . Once , retryFunc : i . RetryFunc , stopCh : make ( chan struct { } , 1 ) , vaultGrace : i . VaultGrace , } , nil } 
func ( v * View ) Data ( ) interface { } { v . dataLock . RLock ( ) defer v . dataLock . RUnlock ( ) return v . data } 
func ( v * View ) DataAndLastIndex ( ) ( interface { } , uint64 ) { v . dataLock . RLock ( ) defer v . dataLock . RUnlock ( ) return v . data , v . lastIndex } 
func ( v * View ) poll ( viewCh chan <- * View , errCh chan <- error ) { var retries int for { doneCh := make ( chan struct { } , 1 ) successCh := make ( chan struct { } , 1 ) fetchErrCh := make ( chan error , 1 ) go v . fetch ( doneCh , successCh , fetchErrCh ) WAIT : select { case <- doneCh : log . Printf ( " " , v . dependency ) select { case <- v . stopCh : return case viewCh <- v : } } case <- successCh : retries = 0 goto WAIT case err := <- fetchErrCh : if v . retryFunc != nil { retry , sleep := v . retryFunc ( retries ) if retry { log . Printf ( " " , err , retries + 1 , sleep ) select { case <- time . After ( sleep ) : retries ++ continue case <- v . stopCh : return } } } log . Printf ( " " , err ) case errCh <- err : return } case <- v . stopCh : log . Printf ( " " , v . dependency ) return } } } 
func ( v * View ) fetch ( doneCh , successCh chan <- struct { } , errCh chan <- error ) { log . Printf ( " " , v . dependency ) var allowStale bool if v . maxStale != 0 { allowStale = true } for { default : } data , rm , err := v . dependency . Fetch ( v . clients , & dep . QueryOptions { AllowStale : allowStale , WaitTime : defaultWaitTime , WaitIndex : v . lastIndex , VaultGrace : v . vaultGrace , } ) if err != nil { if err == dep . ErrStopped { log . Printf ( " " , v . dependency ) } else { errCh <- err } return } if rm == nil { errCh <- fmt . Errorf ( " " + " " ) return } select { case successCh <- struct { } { } : default : } if allowStale && rm . LastContact > v . maxStale { allowStale = false log . Printf ( " " , v . dependency ) continue } if v . maxStale != 0 { allowStale = true } if rm . LastIndex == v . lastIndex { log . Printf ( " " , v . dependency ) continue } v . dataLock . Lock ( ) if rm . LastIndex < v . lastIndex { log . Printf ( " " , v . dependency ) v . lastIndex = 0 v . dataLock . Unlock ( ) continue } v . lastIndex = rm . LastIndex if v . receivedData && reflect . DeepEqual ( data , v . data ) { log . Printf ( " " , v . dependency ) v . dataLock . Unlock ( ) continue } if data == nil && rm . Block { log . Printf ( " " , v . dependency ) v . dataLock . Unlock ( ) continue } v . data = data v . receivedData = true v . dataLock . Unlock ( ) close ( doneCh ) return } } 
func NewCatalogNodeQuery ( s string ) ( * CatalogNodeQuery , error ) { if s != " " && ! CatalogNodeQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( CatalogNodeQueryRe , s ) return & CatalogNodeQuery { dc : m [ " " ] , name : m [ " " ] , stopCh : make ( chan struct { } , 1 ) , } , nil } 
func ( d * CatalogNodeQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) if name == " " { log . Printf ( " " , d ) var err error name , err = clients . Consul ( ) . Agent ( ) . NodeName ( ) if err != nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } } log . Printf ( " " , d , & url . URL { Path : " " + name , RawQuery : opts . String ( ) , } ) node , qm , err := clients . Consul ( ) . Catalog ( ) . Node ( name , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d ) rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } if node == nil { log . Printf ( " " , d , name ) var node CatalogNode return & node , rm , nil } services := make ( [ ] * CatalogNodeService , 0 , len ( node . Services ) ) for _ , v := range node . Services { services = append ( services , & CatalogNodeService { ID : v . ID , Service : v . Service , Tags : ServiceTags ( deepCopyAndSortTags ( v . Tags ) ) , Meta : v . Meta , Port : v . Port , Address : v . Address , EnableTagOverride : v . EnableTagOverride , } ) } sort . Stable ( ByService ( services ) ) detail := & CatalogNode { Node : & Node { ID : node . Node . ID , Node : node . Node . Node , Address : node . Node . Address , Datacenter : node . Node . Datacenter , TaggedAddresses : node . Node . TaggedAddresses , Meta : node . Node . Meta , } , Services : services , } return detail , rm , nil } 
func ( d * CatalogNodeQuery ) String ( ) string { name := d . name if d . dc != " " { name = name + " " + d . dc } if name == " " { return " " } return fmt . Sprintf ( " " , name ) } 
func ParseAuthConfig ( s string ) ( * AuthConfig , error ) { if s == " " { return nil , ErrAuthStringEmpty } var a AuthConfig if strings . Contains ( s , " " ) { split := strings . SplitN ( s , " " , 2 ) a . Username = String ( split [ 0 ] ) a . Password = String ( split [ 1 ] ) } else { a . Username = String ( s ) } return & a , nil } 
func ( c * AuthConfig ) Copy ( ) * AuthConfig { if c == nil { return nil } var o AuthConfig o . Enabled = c . Enabled o . Username = c . Username o . Password = c . Password return & o } 
func ( c * AuthConfig ) Merge ( o * AuthConfig ) * AuthConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Enabled != nil { r . Enabled = o . Enabled } if o . Username != nil { r . Username = o . Username } if o . Password != nil { r . Password = o . Password } return r } 
func ( c * AuthConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( false || StringPresent ( c . Username ) || StringPresent ( c . Password ) ) } if c . Username == nil { c . Username = String ( " " ) } if c . Password == nil { c . Password = String ( " " ) } if c . Enabled == nil { c . Enabled = Bool ( * c . Username != " " || * c . Password != " " ) } } 
func ( c * AuthConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " , BoolGoString ( c . Enabled ) , StringGoString ( c . Username ) , StringGoString ( c . Password ) , ) } 
func ( c * AuthConfig ) String ( ) string { if ! BoolVal ( c . Enabled ) { return " " } if c . Password != nil { return fmt . Sprintf ( " " , StringVal ( c . Username ) , StringVal ( c . Password ) ) } return StringVal ( c . Username ) } 
func NewVaultListQuery ( s string ) ( * VaultListQuery , error ) { s = strings . TrimSpace ( s ) s = strings . Trim ( s , " " ) if s == " " { return nil , fmt . Errorf ( " " , s ) } return & VaultListQuery { stopCh : make ( chan struct { } , 1 ) , path : s , } , nil } 
func ( d * VaultListQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { } ) log . Printf ( " " , d , dur ) select { case <- d . stopCh : return nil , nil , ErrStopped case <- time . After ( dur ) : } } secret , err := clients . Vault ( ) . Logical ( ) . List ( d . path ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } var result [ ] string return respWithMetadata ( result ) } if ! ok { log . Printf ( " " , d ) return respWithMetadata ( result ) } list , ok := keys . ( [ ] interface { } ) if ! ok { log . Printf ( " " , d ) return nil , nil , fmt . Errorf ( " " , d ) } for _ , v := range list { typed , ok := v . ( string ) if ! ok { return nil , nil , fmt . Errorf ( " " , d ) } result = append ( result , typed ) } sort . Strings ( result ) log . Printf ( " " , d , len ( result ) ) return respWithMetadata ( result ) } 
func ( b * Brain ) Remember ( d dep . Dependency , data interface { } ) { b . Lock ( ) defer b . Unlock ( ) b . data [ d . String ( ) ] = data b . receivedData [ d . String ( ) ] = struct { } { } } 
func ( b * Brain ) Recall ( d dep . Dependency ) ( interface { } , bool ) { b . RLock ( ) defer b . RUnlock ( ) } return b . data [ d . String ( ) ] , true } 
func ( b * Brain ) ForceSet ( hashCode string , data interface { } ) { b . Lock ( ) defer b . Unlock ( ) b . data [ hashCode ] = data b . receivedData [ hashCode ] = struct { } { } } 
func ( b * Brain ) Forget ( d dep . Dependency ) { b . Lock ( ) defer b . Unlock ( ) delete ( b . data , d . String ( ) ) delete ( b . receivedData , d . String ( ) ) } 
func NewCatalogDatacentersQuery ( ignoreFailing bool ) ( * CatalogDatacentersQuery , error ) { return & CatalogDatacentersQuery { ignoreFailing : ignoreFailing , stopCh : make ( chan struct { } , 1 ) , } , nil } 
func ( d * CatalogDatacentersQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { opts = opts . Merge ( & QueryOptions { } ) log . Printf ( " " , d , & url . URL { Path : " " , RawQuery : opts . String ( ) , } ) select { case <- d . stopCh : return nil , nil , ErrStopped case <- time . After ( CatalogDatacentersQuerySleepTime ) : } } result , err := clients . Consul ( ) . Catalog ( ) . Datacenters ( ) if err != nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } for _ , dc := range result { if _ , _ , err := clients . Consul ( ) . Catalog ( ) . Services ( & api . QueryOptions { Datacenter : dc , AllowStale : false , RequireConsistent : true , } ) ; err == nil { dcs = append ( dcs , dc ) } } result = dcs } log . Printf ( " " , d , len ( result ) ) sort . Strings ( result ) return respWithMetadata ( result ) } 
func NewCatalogNodesQuery ( s string ) ( * CatalogNodesQuery , error ) { if ! CatalogNodesQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( CatalogNodesQueryRe , s ) return & CatalogNodesQuery { dc : m [ " " ] , near : m [ " " ] , stopCh : make ( chan struct { } , 1 ) , } , nil } 
func ( d * CatalogNodesQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , Near : d . near , } ) log . Printf ( " " , d , & url . URL { Path : " " , RawQuery : opts . String ( ) , } ) n , qm , err := clients . Consul ( ) . Catalog ( ) . Nodes ( opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( n ) ) nodes := make ( [ ] * Node , 0 , len ( n ) ) for _ , node := range n { nodes = append ( nodes , & Node { ID : node . ID , Node : node . Node , Address : node . Address , Datacenter : node . Datacenter , TaggedAddresses : node . TaggedAddresses , Meta : node . Meta , } ) } } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return nodes , rm , nil } 
func ( d * CatalogNodesQuery ) String ( ) string { name := " " if d . dc != " " { name = name + " " + d . dc } if d . near != " " { name = name + " " + d . near } if name == " " { return " " } return fmt . Sprintf ( " " , name ) } 
func ( c * SSLConfig ) Copy ( ) * SSLConfig { if c == nil { return nil } var o SSLConfig o . CaCert = c . CaCert o . CaPath = c . CaPath o . Cert = c . Cert o . Enabled = c . Enabled o . Key = c . Key o . ServerName = c . ServerName o . Verify = c . Verify return & o } 
func ( c * SSLConfig ) Merge ( o * SSLConfig ) * SSLConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Cert != nil { r . Cert = o . Cert } if o . CaCert != nil { r . CaCert = o . CaCert } if o . CaPath != nil { r . CaPath = o . CaPath } if o . Enabled != nil { r . Enabled = o . Enabled } if o . Key != nil { r . Key = o . Key } if o . ServerName != nil { r . ServerName = o . ServerName } if o . Verify != nil { r . Verify = o . Verify } return r } 
func ( c * SSLConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( false || StringPresent ( c . Cert ) || StringPresent ( c . CaCert ) || StringPresent ( c . CaPath ) || StringPresent ( c . Key ) || StringPresent ( c . ServerName ) || BoolPresent ( c . Verify ) ) } if c . Cert == nil { c . Cert = String ( " " ) } if c . CaCert == nil { c . CaCert = String ( " " ) } if c . CaPath == nil { c . CaPath = String ( " " ) } if c . Key == nil { c . Key = String ( " " ) } if c . ServerName == nil { c . ServerName = String ( " " ) } if c . Verify == nil { c . Verify = Bool ( DefaultSSLVerify ) } } 
func ( c * SSLConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " , StringGoString ( c . CaCert ) , StringGoString ( c . CaPath ) , StringGoString ( c . Cert ) , BoolGoString ( c . Enabled ) , StringGoString ( c . Key ) , StringGoString ( c . ServerName ) , BoolGoString ( c . Verify ) , ) } 
func Parse ( s string ) ( os . Signal , error ) { sig , ok := SignalLookup [ strings . ToUpper ( s ) ] if ! ok { return nil , fmt . Errorf ( " " , s , ValidSignals ) } return sig , nil } 
func ( c * TransportConfig ) Copy ( ) * TransportConfig { if c == nil { return nil } var o TransportConfig o . DialKeepAlive = c . DialKeepAlive o . DialTimeout = c . DialTimeout o . DisableKeepAlives = c . DisableKeepAlives o . IdleConnTimeout = c . IdleConnTimeout o . MaxIdleConns = c . MaxIdleConns o . MaxIdleConnsPerHost = c . MaxIdleConnsPerHost o . TLSHandshakeTimeout = c . TLSHandshakeTimeout return & o } 
func ( c * TransportConfig ) Merge ( o * TransportConfig ) * TransportConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . DialKeepAlive != nil { r . DialKeepAlive = o . DialKeepAlive } if o . DialTimeout != nil { r . DialTimeout = o . DialTimeout } if o . DisableKeepAlives != nil { r . DisableKeepAlives = o . DisableKeepAlives } if o . IdleConnTimeout != nil { r . IdleConnTimeout = o . IdleConnTimeout } if o . MaxIdleConns != nil { r . MaxIdleConns = o . MaxIdleConns } if o . MaxIdleConnsPerHost != nil { r . MaxIdleConnsPerHost = o . MaxIdleConnsPerHost } if o . TLSHandshakeTimeout != nil { r . TLSHandshakeTimeout = o . TLSHandshakeTimeout } return r } 
func ( c * TransportConfig ) Finalize ( ) { if c . DialKeepAlive == nil { c . DialKeepAlive = TimeDuration ( DefaultDialKeepAlive ) } if c . DialTimeout == nil { c . DialTimeout = TimeDuration ( DefaultDialTimeout ) } if c . DisableKeepAlives == nil { c . DisableKeepAlives = Bool ( false ) } if c . IdleConnTimeout == nil { c . IdleConnTimeout = TimeDuration ( DefaultIdleConnTimeout ) } if c . MaxIdleConns == nil { c . MaxIdleConns = Int ( DefaultMaxIdleConns ) } if c . MaxIdleConnsPerHost == nil { c . MaxIdleConnsPerHost = Int ( DefaultMaxIdleConnsPerHost ) } if c . TLSHandshakeTimeout == nil { c . TLSHandshakeTimeout = TimeDuration ( DefaultTLSHandshakeTimeout ) } } 
func ( c * TransportConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " , TimeDurationVal ( c . DialKeepAlive ) , TimeDurationVal ( c . DialTimeout ) , BoolVal ( c . DisableKeepAlives ) , IntVal ( c . MaxIdleConnsPerHost ) , TimeDurationVal ( c . TLSHandshakeTimeout ) , ) } 
func DefaultVaultConfig ( ) * VaultConfig { v := & VaultConfig { Retry : DefaultRetryConfig ( ) , SSL : DefaultSSLConfig ( ) , Transport : DefaultTransportConfig ( ) , } return v } 
func ( c * VaultConfig ) Copy ( ) * VaultConfig { if c == nil { return nil } var o VaultConfig o . Address = c . Address o . Enabled = c . Enabled o . Grace = c . Grace o . Namespace = c . Namespace o . RenewToken = c . RenewToken if c . Retry != nil { o . Retry = c . Retry . Copy ( ) } if c . SSL != nil { o . SSL = c . SSL . Copy ( ) } o . Token = c . Token o . VaultAgentTokenFile = c . VaultAgentTokenFile if c . Transport != nil { o . Transport = c . Transport . Copy ( ) } o . UnwrapToken = c . UnwrapToken return & o } 
func ( c * VaultConfig ) Merge ( o * VaultConfig ) * VaultConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Address != nil { r . Address = o . Address } if o . Enabled != nil { r . Enabled = o . Enabled } if o . Grace != nil { r . Grace = o . Grace } if o . Namespace != nil { r . Namespace = o . Namespace } if o . RenewToken != nil { r . RenewToken = o . RenewToken } if o . Retry != nil { r . Retry = r . Retry . Merge ( o . Retry ) } if o . SSL != nil { r . SSL = r . SSL . Merge ( o . SSL ) } if o . Token != nil { r . Token = o . Token } if o . VaultAgentTokenFile != nil { r . VaultAgentTokenFile = o . VaultAgentTokenFile } if o . Transport != nil { r . Transport = r . Transport . Merge ( o . Transport ) } if o . UnwrapToken != nil { r . UnwrapToken = o . UnwrapToken } return r } 
func ( c * VaultConfig ) Finalize ( ) { if c . Address == nil { c . Address = stringFromEnv ( [ ] string { api . EnvVaultAddress , } , " " ) } if c . Grace == nil { c . Grace = TimeDuration ( DefaultVaultGrace ) } if c . Namespace == nil { c . Namespace = stringFromEnv ( [ ] string { " " } , " " ) } if c . RenewToken == nil { c . RenewToken = boolFromEnv ( [ ] string { " " , } , DefaultVaultRenewToken ) } if c . Retry == nil { c . Retry = DefaultRetryConfig ( ) } c . Retry . Finalize ( ) } if c . SSL . Enabled == nil { c . SSL . Enabled = Bool ( true ) } if c . SSL . CaCert == nil { c . SSL . CaCert = stringFromEnv ( [ ] string { api . EnvVaultCACert } , " " ) } if c . SSL . CaPath == nil { c . SSL . CaPath = stringFromEnv ( [ ] string { api . EnvVaultCAPath } , " " ) } if c . SSL . Cert == nil { c . SSL . Cert = stringFromEnv ( [ ] string { api . EnvVaultClientCert } , " " ) } if c . SSL . Key == nil { c . SSL . Key = stringFromEnv ( [ ] string { api . EnvVaultClientKey } , " " ) } if c . SSL . ServerName == nil { c . SSL . ServerName = stringFromEnv ( [ ] string { api . EnvVaultTLSServerName } , " " ) } if c . SSL . Verify == nil { c . SSL . Verify = antiboolFromEnv ( [ ] string { api . EnvVaultInsecure } , true ) } c . SSL . Finalize ( ) } if c . VaultAgentTokenFile != nil { c . Token = stringFromFile ( [ ] string { * c . VaultAgentTokenFile } , " " ) c . RenewToken = Bool ( false ) } if c . Transport == nil { c . Transport = DefaultTransportConfig ( ) } c . Transport . Finalize ( ) if c . UnwrapToken == nil { c . UnwrapToken = boolFromEnv ( [ ] string { " " , } , DefaultVaultUnwrapToken ) } if c . Enabled == nil { c . Enabled = Bool ( StringPresent ( c . Address ) ) } } 
func ( c * VaultConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , StringGoString ( c . Address ) , BoolGoString ( c . Enabled ) , TimeDurationGoString ( c . Grace ) , StringGoString ( c . Namespace ) , BoolGoString ( c . RenewToken ) , c . Retry , c . SSL , StringPresent ( c . Token ) , StringPresent ( c . VaultAgentTokenFile ) , c . Transport , BoolGoString ( c . UnwrapToken ) , ) } 
func NewTemplate ( i * NewTemplateInput ) ( * Template , error ) { if i == nil { i = & NewTemplateInput { } } } else if i . Source == " " && i . Contents == " " { return nil , ErrTemplateMissingContentsAndSource } var t Template t . source = i . Source t . contents = i . Contents t . leftDelim = i . LeftDelim t . rightDelim = i . RightDelim t . errMissingKey = i . ErrMissingKey if i . Source != " " { contents , err := ioutil . ReadFile ( i . Source ) if err != nil { return nil , errors . Wrap ( err , " " ) } t . contents = string ( contents ) } t . hexMD5 = hex . EncodeToString ( hash [ : ] ) return & t , nil } 
func ( t * Template ) Execute ( i * ExecuteInput ) ( * ExecuteResult , error ) { if i == nil { i = & ExecuteInput { } } var used , missing dep . Set tmpl := template . New ( " " ) tmpl . Delims ( t . leftDelim , t . rightDelim ) tmpl . Funcs ( funcMap ( & funcMapInput { t : tmpl , brain : i . Brain , env : i . Env , used : & used , missing : & missing , } ) ) if t . errMissingKey { tmpl . Option ( " " ) } else { tmpl . Option ( " " ) } tmpl , err := tmpl . Parse ( t . contents ) if err != nil { return nil , errors . Wrap ( err , " " ) } if err := tmpl . Execute ( & b , nil ) ; err != nil { return nil , errors . Wrap ( err , " " ) } return & ExecuteResult { Used : & used , Missing : & missing , Output : b . Bytes ( ) , } , nil } 
func funcMap ( i * funcMapInput ) template . FuncMap { var scratch Scratch return template . FuncMap { } 
func StringToFileModeFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) != reflect . String { return data , nil } if t != reflect . TypeOf ( os . FileMode ( 0 ) ) { return data , nil } if err != nil { return data , err } return os . FileMode ( v ) , nil } } 
func StringToWaitDurationHookFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) != reflect . String { return data , nil } if t != reflect . TypeOf ( WaitConfig { } ) { return data , nil } } } 
func ConsulStringToStructFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if t == reflect . TypeOf ( ConsulConfig { } ) && f . Kind ( ) == reflect . String { log . Println ( " " + " \" \" " + " " ) return & ConsulConfig { Address : String ( data . ( string ) ) , } , nil } return data , nil } } 
func ( c * DedupConfig ) Copy ( ) * DedupConfig { if c == nil { return nil } var o DedupConfig o . Enabled = c . Enabled o . MaxStale = c . MaxStale o . Prefix = c . Prefix o . TTL = c . TTL return & o } 
func ( c * DedupConfig ) Merge ( o * DedupConfig ) * DedupConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Enabled != nil { r . Enabled = o . Enabled } if o . MaxStale != nil { r . MaxStale = o . MaxStale } if o . Prefix != nil { r . Prefix = o . Prefix } if o . TTL != nil { r . TTL = o . TTL } return r } 
func ( c * DedupConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( false || TimeDurationPresent ( c . MaxStale ) || StringPresent ( c . Prefix ) || TimeDurationPresent ( c . TTL ) ) } if c . MaxStale == nil { c . MaxStale = TimeDuration ( DefaultDedupMaxStale ) } if c . Prefix == nil { c . Prefix = String ( DefaultDedupPrefix ) } if c . TTL == nil { c . TTL = TimeDuration ( DefaultDedupTTL ) } } 
func ( c * DedupConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , BoolGoString ( c . Enabled ) , TimeDurationGoString ( c . MaxStale ) , StringGoString ( c . Prefix ) , TimeDurationGoString ( c . TTL ) , ) } 
func ( s * Scratch ) Key ( k string ) bool { s . RLock ( ) defer s . RUnlock ( ) _ , ok := s . values [ k ] return ok } 
func ( s * Scratch ) Get ( k string ) interface { } { s . RLock ( ) defer s . RUnlock ( ) return s . values [ k ] } 
func ( s * Scratch ) Set ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) s . values [ k ] = v return " " } 
func ( s * Scratch ) SetX ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if _ , ok := s . values [ k ] ; ! ok { s . values [ k ] = v } return " " } 
func ( s * Scratch ) MapSet ( k , mk string , v interface { } ) ( string , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) return s . mapSet ( k , mk , v , true ) } 
func ( s * Scratch ) MapSetX ( k , mk string , v interface { } ) ( string , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) return s . mapSet ( k , mk , v , false ) } 
func ( s * Scratch ) mapSet ( k , mk string , v interface { } , o bool ) ( string , error ) { if _ , ok := s . values [ k ] ; ! ok { s . values [ k ] = make ( map [ string ] interface { } ) } typed , ok := s . values [ k ] . ( map [ string ] interface { } ) if ! ok { return " " , fmt . Errorf ( " " , k ) } if _ , ok := typed [ mk ] ; o || ! ok { typed [ mk ] = v } return " " , nil } 
func ( s * Scratch ) MapValues ( k string ) ( [ ] interface { } , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if s . values == nil { return nil , nil } typed , ok := s . values [ k ] . ( map [ string ] interface { } ) if ! ok { return nil , nil } keys := make ( [ ] string , 0 , len ( typed ) ) for k := range typed { keys = append ( keys , k ) } sort . Strings ( keys ) sorted := make ( [ ] interface { } , len ( keys ) ) for i , k := range keys { sorted [ i ] = typed [ k ] } return sorted , nil } 
func ( s * Scratch ) init ( ) { if s . values == nil { s . values = make ( map [ string ] interface { } ) } } 
func Render ( i * RenderInput ) ( * RenderResult , error ) { existing , err := ioutil . ReadFile ( i . Path ) if err != nil && ! os . IsNotExist ( err ) { return nil , errors . Wrap ( err , " " ) } if bytes . Equal ( existing , i . Contents ) { return & RenderResult { DidRender : false , WouldRender : true , Contents : existing , } , nil } if i . Dry { fmt . Fprintf ( i . DryStream , " \n " , i . Path , i . Contents ) } else { if err := AtomicWrite ( i . Path , i . CreateDestDirs , i . Contents , i . Perms , i . Backup ) ; err != nil { return nil , errors . Wrap ( err , " " ) } } return & RenderResult { DidRender : true , WouldRender : true , Contents : i . Contents , } , nil } 
func AtomicWrite ( path string , createDestDirs bool , contents [ ] byte , perms os . FileMode , backup bool ) error { if path == " " { return ErrMissingDest } parent := filepath . Dir ( path ) if _ , err := os . Stat ( parent ) ; os . IsNotExist ( err ) { if createDestDirs { if err := os . MkdirAll ( parent , 0755 ) ; err != nil { return err } } else { return ErrNoParentDir } } f , err := ioutil . TempFile ( parent , " " ) if err != nil { return err } defer os . Remove ( f . Name ( ) ) if _ , err := f . Write ( contents ) ; err != nil { return err } if err := f . Sync ( ) ; err != nil { return err } if err := f . Close ( ) ; err != nil { return err } if err != nil { if os . IsNotExist ( err ) { perms = DefaultFilePerms } else { return err } } else { perms = currentInfo . Mode ( ) } } } if err := os . Chmod ( f . Name ( ) , perms ) ; err != nil { return err } } } } if err := os . Rename ( f . Name ( ) , path ) ; err != nil { return err } return nil } 
func copyFile ( src , dst string ) error { s , err := os . Open ( src ) if err != nil { return err } defer s . Close ( ) stat , err := s . Stat ( ) if err != nil { return err } d , err := os . OpenFile ( dst , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , stat . Mode ( ) ) if err != nil { return err } if _ , err := io . Copy ( d , s ) ; err != nil { d . Close ( ) return err } if err := d . Close ( ) ; err != nil { return err } } 
func ( c * Config ) Copy ( ) * Config { var o Config o . Consul = c . Consul if c . Consul != nil { o . Consul = c . Consul . Copy ( ) } if c . Dedup != nil { o . Dedup = c . Dedup . Copy ( ) } if c . Exec != nil { o . Exec = c . Exec . Copy ( ) } o . KillSignal = c . KillSignal o . LogLevel = c . LogLevel o . MaxStale = c . MaxStale o . PidFile = c . PidFile o . ReloadSignal = c . ReloadSignal if c . Syslog != nil { o . Syslog = c . Syslog . Copy ( ) } if c . Templates != nil { o . Templates = c . Templates . Copy ( ) } if c . Vault != nil { o . Vault = c . Vault . Copy ( ) } if c . Wait != nil { o . Wait = c . Wait . Copy ( ) } return & o } 
func ( c * Config ) Merge ( o * Config ) * Config { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Consul != nil { r . Consul = r . Consul . Merge ( o . Consul ) } if o . Dedup != nil { r . Dedup = r . Dedup . Merge ( o . Dedup ) } if o . Exec != nil { r . Exec = r . Exec . Merge ( o . Exec ) } if o . KillSignal != nil { r . KillSignal = o . KillSignal } if o . LogLevel != nil { r . LogLevel = o . LogLevel } if o . MaxStale != nil { r . MaxStale = o . MaxStale } if o . PidFile != nil { r . PidFile = o . PidFile } if o . ReloadSignal != nil { r . ReloadSignal = o . ReloadSignal } if o . Syslog != nil { r . Syslog = r . Syslog . Merge ( o . Syslog ) } if o . Templates != nil { r . Templates = r . Templates . Merge ( o . Templates ) } if o . Vault != nil { r . Vault = r . Vault . Merge ( o . Vault ) } if o . Wait != nil { r . Wait = r . Wait . Merge ( o . Wait ) } return r } 
func Parse ( s string ) ( * Config , error ) { var shadow interface { } if err := hcl . Decode ( & shadow , s ) ; err != nil { return nil , errors . Wrap ( err , " " ) } if ! ok { return nil , errors . New ( " " ) } flattenKeys ( parsed , [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , } ) } } decoder , err := mapstructure . NewDecoder ( & mapstructure . DecoderConfig { DecodeHook : mapstructure . ComposeDecodeHookFunc ( ConsulStringToStructFunc ( ) , StringToFileModeFunc ( ) , signals . StringToSignalFunc ( ) , StringToWaitDurationHookFunc ( ) , mapstructure . StringToSliceHookFunc ( " " ) , mapstructure . StringToTimeDurationHookFunc ( ) , ) , ErrorUnused : true , Metadata : & md , Result : & c , } ) if err != nil { return nil , errors . Wrap ( err , " " ) } if err := decoder . Decode ( parsed ) ; err != nil { return nil , errors . Wrap ( err , " " ) } return & c , nil } 
func Must ( s string ) * Config { c , err := Parse ( s ) if err != nil { log . Fatal ( err ) } return c } 
func FromFile ( path string ) ( * Config , error ) { c , err := ioutil . ReadFile ( path ) if err != nil { return nil , errors . Wrap ( err , " " + path ) } config , err := Parse ( string ( c ) ) if err != nil { return nil , errors . Wrap ( err , " " + path ) } return config , nil } 
func FromPath ( path string ) ( * Config , error ) { } if err != nil { return nil , errors . Wrap ( err , " " + path ) } if err != nil { return nil , errors . Wrap ( err , " " + path ) } } } if err != nil { return err } c = c . Merge ( newConfig ) return nil } ) if err != nil { return nil , errors . Wrap ( err , " " ) } return c , nil } else if stat . Mode ( ) . IsRegular ( ) { return FromFile ( path ) } return nil , fmt . Errorf ( " " , stat . Mode ( ) . String ( ) ) } 
func ( c * Config ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , c . Consul , c . Dedup , c . Exec , SignalGoString ( c . KillSignal ) , StringGoString ( c . LogLevel ) , TimeDurationGoString ( c . MaxStale ) , StringGoString ( c . PidFile ) , SignalGoString ( c . ReloadSignal ) , c . Syslog , c . Templates , c . Vault , c . Wait , ) } 
func DefaultConfig ( ) * Config { return & Config { Consul : DefaultConsulConfig ( ) , Dedup : DefaultDedupConfig ( ) , Exec : DefaultExecConfig ( ) , Syslog : DefaultSyslogConfig ( ) , Templates : DefaultTemplateConfigs ( ) , Vault : DefaultVaultConfig ( ) , Wait : DefaultWaitConfig ( ) , } } 
func ( c * Config ) Finalize ( ) { if c . Consul == nil { c . Consul = DefaultConsulConfig ( ) } c . Consul . Finalize ( ) if c . Dedup == nil { c . Dedup = DefaultDedupConfig ( ) } c . Dedup . Finalize ( ) if c . Exec == nil { c . Exec = DefaultExecConfig ( ) } c . Exec . Finalize ( ) if c . KillSignal == nil { c . KillSignal = Signal ( DefaultKillSignal ) } if c . LogLevel == nil { c . LogLevel = stringFromEnv ( [ ] string { " " , " " , } , DefaultLogLevel ) } if c . MaxStale == nil { c . MaxStale = TimeDuration ( DefaultMaxStale ) } if c . PidFile == nil { c . PidFile = String ( " " ) } if c . ReloadSignal == nil { c . ReloadSignal = Signal ( DefaultReloadSignal ) } if c . Syslog == nil { c . Syslog = DefaultSyslogConfig ( ) } c . Syslog . Finalize ( ) if c . Templates == nil { c . Templates = DefaultTemplateConfigs ( ) } c . Templates . Finalize ( ) if c . Vault == nil { c . Vault = DefaultVaultConfig ( ) } c . Vault . Finalize ( ) if c . Wait == nil { c . Wait = DefaultWaitConfig ( ) } c . Wait . Finalize ( ) } 
func flattenKeys ( m map [ string ] interface { } , keys [ ] string ) { keyMap := make ( map [ string ] struct { } ) for _ , key := range keys { keyMap [ key ] = struct { } { } } var flatten func ( map [ string ] interface { } , string ) flatten = func ( m map [ string ] interface { } , parent string ) { for k , v := range m { if parent != " " { mapKey = parent + " " + k } if _ , ok := keyMap [ mapKey ] ; ! ok { continue } switch typed := v . ( type ) { case [ ] map [ string ] interface { } : if len ( typed ) > 0 { last := typed [ len ( typed ) - 1 ] flatten ( last , mapKey ) m [ k ] = last } else { m [ k ] = nil } case map [ string ] interface { } : flatten ( typed , mapKey ) m [ k ] = typed default : m [ k ] = v } } } flatten ( m , " " ) } 
func NewWatcher ( i * NewWatcherInput ) ( * Watcher , error ) { w := & Watcher { clients : i . Clients , depViewMap : make ( map [ string ] * View ) , dataCh : make ( chan * View , dataBufferSize ) , errCh : make ( chan error ) , maxStale : i . MaxStale , once : i . Once , retryFuncConsul : i . RetryFuncConsul , retryFuncDefault : i . RetryFuncDefault , retryFuncVault : i . RetryFuncVault , vaultGrace : i . VaultGrace , } if err != nil { return nil , errors . Wrap ( err , " " ) } if _ , err := w . Add ( vt ) ; err != nil { return nil , errors . Wrap ( err , " " ) } } if len ( i . VaultAgentTokenFile ) > 0 { vag , err := dep . NewVaultAgentTokenQuery ( i . VaultAgentTokenFile ) if err != nil { return nil , errors . Wrap ( err , " " ) } if _ , err := w . Add ( vag ) ; err != nil { return nil , errors . Wrap ( err , " " ) } } return w , nil } 
func ( w * Watcher ) Add ( d dep . Dependency ) ( bool , error ) { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " , d ) if _ , ok := w . depViewMap [ d . String ( ) ] ; ok { log . Printf ( " " , d ) return false , nil } switch d . Type ( ) { case dep . TypeConsul : retryFunc = w . retryFuncConsul case dep . TypeVault : retryFunc = w . retryFuncVault default : retryFunc = w . retryFuncDefault } v , err := NewView ( & NewViewInput { Dependency : d , Clients : w . clients , MaxStale : w . maxStale , Once : w . once , RetryFunc : retryFunc , VaultGrace : w . vaultGrace , } ) if err != nil { return false , errors . Wrap ( err , " " ) } log . Printf ( " " , d ) w . depViewMap [ d . String ( ) ] = v go v . poll ( w . dataCh , w . errCh ) return true , nil } 
func ( w * Watcher ) Watching ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) _ , ok := w . depViewMap [ d . String ( ) ] return ok } 
func ( w * Watcher ) ForceWatching ( d dep . Dependency , enabled bool ) { w . Lock ( ) defer w . Unlock ( ) if enabled { w . depViewMap [ d . String ( ) ] = nil } else { delete ( w . depViewMap , d . String ( ) ) } } 
func ( w * Watcher ) Remove ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " , d ) if view , ok := w . depViewMap [ d . String ( ) ] ; ok { log . Printf ( " " , d ) view . stop ( ) delete ( w . depViewMap , d . String ( ) ) return true } log . Printf ( " " , d ) return false } 
func ( w * Watcher ) Size ( ) int { w . Lock ( ) defer w . Unlock ( ) return len ( w . depViewMap ) } 
func ( w * Watcher ) Stop ( ) { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " ) for _ , view := range w . depViewMap { if view == nil { continue } log . Printf ( " " , view . Dependency ( ) ) view . stop ( ) } } 
func ( s * Set ) Add ( d Dependency ) bool { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if _ , ok := s . set [ d . String ( ) ] ; ! ok { s . list = append ( s . list , d . String ( ) ) s . set [ d . String ( ) ] = d return true } return false } 
func ( s * Set ) Get ( v string ) Dependency { s . RLock ( ) defer s . RUnlock ( ) return s . set [ v ] } 
func ( s * Set ) List ( ) [ ] Dependency { s . RLock ( ) defer s . RUnlock ( ) r := make ( [ ] Dependency , len ( s . list ) ) for i , k := range s . list { r [ i ] = s . set [ k ] } return r } 
func ( s * Set ) Len ( ) int { s . RLock ( ) defer s . RUnlock ( ) return len ( s . list ) } 
func ( s * Set ) String ( ) string { s . RLock ( ) defer s . RUnlock ( ) return strings . Join ( s . list , " " ) } 
func deepCopyAndSortTags ( tags [ ] string ) [ ] string { newTags := make ( [ ] string , 0 , len ( tags ) ) for _ , tag := range tags { newTags = append ( newTags , tag ) } sort . Strings ( newTags ) return newTags } 
func respWithMetadata ( i interface { } ) ( interface { } , * ResponseMetadata , error ) { return i , & ResponseMetadata { LastContact : 0 , LastIndex : uint64 ( time . Now ( ) . Unix ( ) ) , } , nil } 
func regexpMatch ( re * regexp . Regexp , q string ) map [ string ] string { names := re . SubexpNames ( ) match := re . FindAllStringSubmatch ( q , - 1 ) if len ( match ) == 0 { return map [ string ] string { } } m := map [ string ] string { } for i , n := range match [ 0 ] { if names [ i ] != " " { m [ names [ i ] ] = n } } return m } 
func NewCatalogServiceQuery ( s string ) ( * CatalogServiceQuery , error ) { if ! CatalogServiceQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( CatalogServiceQueryRe , s ) return & CatalogServiceQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , name : m [ " " ] , near : m [ " " ] , tag : m [ " " ] , } , nil } 
func ( d * CatalogServiceQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , Near : d . near , } ) u := & url . URL { Path : " " + d . name , RawQuery : opts . String ( ) , } if d . tag != " " { q := u . Query ( ) q . Set ( " " , d . tag ) u . RawQuery = q . Encode ( ) } log . Printf ( " " , d , u ) entries , qm , err := clients . Consul ( ) . Catalog ( ) . Service ( d . name , d . tag , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) var list [ ] * CatalogService for _ , s := range entries { list = append ( list , & CatalogService { ID : s . ID , Node : s . Node , Address : s . Address , Datacenter : s . Datacenter , TaggedAddresses : s . TaggedAddresses , NodeMeta : s . NodeMeta , ServiceID : s . ServiceID , ServiceName : s . ServiceName , ServiceAddress : s . ServiceAddress , ServiceTags : ServiceTags ( deepCopyAndSortTags ( s . ServiceTags ) ) , ServiceMeta : s . ServiceMeta , ServicePort : s . ServicePort , } ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return list , rm , nil } 
func ( d * CatalogServiceQuery ) String ( ) string { name := d . name if d . tag != " " { name = d . tag + " " + name } if d . dc != " " { name = name + " " + d . dc } if d . near != " " { name = name + " " + d . near } return fmt . Sprintf ( " " , name ) } 
func NewKVListQuery ( s string ) ( * KVListQuery , error ) { if s != " " && ! KVListQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( KVListQueryRe , s ) return & KVListQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , prefix : m [ " " ] , } , nil } 
func ( d * KVListQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . prefix , RawQuery : opts . String ( ) , } ) list , qm , err := clients . Consul ( ) . KV ( ) . List ( d . prefix , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( list ) ) pairs := make ( [ ] * KeyPair , 0 , len ( list ) ) for _ , pair := range list { key := strings . TrimPrefix ( pair . Key , d . prefix ) key = strings . TrimLeft ( key , " " ) pairs = append ( pairs , & KeyPair { Path : pair . Key , Key : key , Value : string ( pair . Value ) , CreateIndex : pair . CreateIndex , ModifyIndex : pair . ModifyIndex , LockIndex : pair . LockIndex , Flags : pair . Flags , Session : pair . Session , } ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return pairs , rm , nil } 
func ( d * KVListQuery ) String ( ) string { prefix := d . prefix if d . dc != " " { prefix = prefix + " " + d . dc } return fmt . Sprintf ( " " , prefix ) } 
func NewDedupManager ( config * config . DedupConfig , clients * dep . ClientSet , brain * template . Brain , templates [ ] * template . Template ) ( * DedupManager , error ) { d := & DedupManager { config : config , clients : clients , brain : brain , templates : templates , leader : make ( map [ * template . Template ] <- chan struct { } ) , lastWrite : make ( map [ * template . Template ] uint64 ) , updateCh : make ( chan struct { } , 1 ) , stopCh : make ( chan struct { } ) , } return d , nil } 
func ( d * DedupManager ) Start ( ) error { log . Printf ( " " ) client := d . clients . Consul ( ) go d . createSession ( client ) } return nil } 
func ( d * DedupManager ) Stop ( ) error { d . stopLock . Lock ( ) defer d . stopLock . Unlock ( ) if d . stop { return nil } log . Printf ( " " ) d . stop = true close ( d . stopCh ) d . wg . Wait ( ) return nil } 
func ( d * DedupManager ) createSession ( client * consulapi . Client ) { START : log . Printf ( " " ) session := client . Session ( ) sessionCh := make ( chan struct { } ) ttl := fmt . Sprintf ( " " , float64 ( * d . config . TTL ) / float64 ( time . Second ) ) se := & consulapi . SessionEntry { Name : " " , Behavior : " " , TTL : ttl , } id , _ , err := session . Create ( se , nil ) if err != nil { log . Printf ( " " , err ) goto WAIT } log . Printf ( " " , id ) go d . attemptLock ( client , id , sessionCh , t ) } } close ( sessionCh ) d . wg . Wait ( ) WAIT : select { case <- time . After ( sessionCreateRetry ) : goto START case <- d . stopCh : return } } 
func ( d * DedupManager ) IsLeader ( tmpl * template . Template ) bool { d . leaderLock . RLock ( ) defer d . leaderLock . RUnlock ( ) lockCh , ok := d . leader [ tmpl ] if ! ok { return false } select { case <- lockCh : return false default : return true } } 
func ( d * DedupManager ) UpdateDeps ( t * template . Template , deps [ ] dep . Dependency ) error { for _ , dp := range deps { } if ok { td . Data [ dp . String ( ) ] = val } } if err != nil { return fmt . Errorf ( " " , err ) } d . lastWriteLock . RLock ( ) existing , ok := d . lastWrite [ t ] d . lastWriteLock . RUnlock ( ) if ok && existing == hash { log . Printf ( " " , dataPath ) return nil } compress := lzw . NewWriter ( & buf , lzw . LSB , 8 ) enc := gob . NewEncoder ( compress ) if err := enc . Encode ( & td ) ; err != nil { return fmt . Errorf ( " " , err ) } compress . Close ( ) client := d . clients . Consul ( ) if _ , err := client . KV ( ) . Put ( & kvPair , nil ) ; err != nil { return fmt . Errorf ( " " , dataPath , err ) } log . Printf ( " " , dataPath ) d . lastWriteLock . Lock ( ) d . lastWrite [ t ] = hash d . lastWriteLock . Unlock ( ) return nil } 
func ( d * DedupManager ) setLeader ( tmpl * template . Template , lockCh <- chan struct { } ) { if lockCh != nil { d . leader [ tmpl ] = lockCh } else { delete ( d . leader , tmpl ) } d . leaderLock . Unlock ( ) delete ( d . lastWrite , tmpl ) d . lastWriteLock . Unlock ( ) } } 
func ( d * DedupManager ) parseData ( path string , raw [ ] byte ) { decompress := lzw . NewReader ( r , lzw . LSB , 8 ) defer decompress . Close ( ) dec := gob . NewDecoder ( decompress ) if err := dec . Decode ( & td ) ; err != nil { log . Printf ( " " , path , err ) return } if td . Version != version . Version { log . Printf ( " " , td . Version , version . Version ) return } log . Printf ( " " , len ( td . Data ) , path ) } } 
func NewFileQuery ( s string ) ( * FileQuery , error ) { s = strings . TrimSpace ( s ) if s == " " { return nil , fmt . Errorf ( " " , s ) } return & FileQuery { stopCh : make ( chan struct { } , 1 ) , path : s , } , nil } 
func ( d * FileQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { log . Printf ( " " , d , d . path ) select { case <- d . stopCh : log . Printf ( " " , d ) return " " , nil , ErrStopped case r := <- d . watch ( d . stat ) : if r . err != nil { return " " , nil , errors . Wrap ( r . err , d . String ( ) ) } log . Printf ( " " , d ) data , err := ioutil . ReadFile ( d . path ) if err != nil { return " " , nil , errors . Wrap ( err , d . String ( ) ) } d . stat = r . stat return respWithMetadata ( string ( data ) ) } } 
func NewCLI ( out , err io . Writer ) * CLI { return & CLI { outStream : out , errStream : err , signalCh : make ( chan os . Signal , 1 ) , stopCh : make ( chan struct { } ) , } } 
func ( cli * CLI ) Run ( args [ ] string ) int { if err != nil { if err == flag . ErrHelp { fmt . Fprintf ( cli . errStream , usage , version . Name ) return 0 } fmt . Fprintln ( cli . errStream , err . Error ( ) ) return ExitCodeParseFlagsError } if err != nil { return logError ( err , ExitCodeConfigError ) } config . Finalize ( ) if err != nil { return logError ( err , ExitCodeConfigError ) } fmt . Fprintf ( cli . errStream , " \n " , version . HumanVersion ) return ExitCodeOK } if err != nil { return logError ( err , ExitCodeRunnerError ) } go runner . Start ( ) for { select { case err := <- runner . ErrCh : if typed , ok := err . ( manager . ErrExitable ) ; ok { code = typed . ExitStatus ( ) } return logError ( err , code ) case <- runner . DoneCh : return ExitCodeOK case s := <- cli . signalCh : log . Printf ( " " , s ) switch s { case * config . ReloadSignal : fmt . Fprintf ( cli . errStream , " \n " ) runner . Stop ( ) if err != nil { return logError ( err , ExitCodeConfigError ) } config . Finalize ( ) if err != nil { return logError ( err , ExitCodeConfigError ) } runner , err = manager . NewRunner ( config , dry , once ) if err != nil { return logError ( err , ExitCodeRunnerError ) } go runner . Start ( ) case * config . KillSignal : fmt . Fprintf ( cli . errStream , " \n " ) runner . Stop ( ) return ExitCodeInterrupt case signals . SignalLookup [ " " ] : } case <- cli . stopCh : return ExitCodeOK } } } 
func ( cli * CLI ) stop ( ) { cli . Lock ( ) defer cli . Unlock ( ) if cli . stopped { return } close ( cli . stopCh ) cli . stopped = true } 
func ( cli * CLI ) ParseFlags ( args [ ] string ) ( * config . Config , [ ] string , bool , bool , bool , error ) { var dry , once , isVersion bool c := config . DefaultConfig ( ) if s := os . Getenv ( " " ) ; s != " " { envConfig , err := config . Parse ( s ) if err != nil { return nil , nil , false , false , false , err } c = c . Merge ( envConfig ) } flags . SetOutput ( ioutil . Discard ) flags . Usage = func ( ) { } flags . Var ( ( funcVar ) ( func ( s string ) error { configPaths = append ( configPaths , s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . Address = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { a , err := config . ParseAuthConfig ( s ) if err != nil { return err } c . Consul . Auth = a return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Consul . Retry . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcIntVar ) ( func ( i int ) error { c . Consul . Retry . Attempts = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Retry . Backoff = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Retry . MaxBackoff = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Consul . SSL . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . SSL . CaCert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . SSL . CaPath = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . SSL . Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . SSL . Key = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . SSL . ServerName = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Consul . SSL . Verify = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Consul . Token = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Transport . DialKeepAlive = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Transport . DialTimeout = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Consul . Transport . DisableKeepAlives = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcIntVar ) ( func ( i int ) error { c . Consul . Transport . MaxIdleConnsPerHost = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Transport . TLSHandshakeTimeout = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Dedup . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . BoolVar ( & dry , " " , false , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Exec . Enabled = config . Bool ( true ) c . Exec . Command = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { sig , err := signals . Parse ( s ) if err != nil { return err } c . Exec . KillSignal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Exec . KillTimeout = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { sig , err := signals . Parse ( s ) if err != nil { return err } c . Exec . ReloadSignal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Exec . Splay = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { sig , err := signals . Parse ( s ) if err != nil { return err } c . KillSignal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . LogLevel = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . MaxStale = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . BoolVar ( & once , " " , false , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . PidFile = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { sig , err := signals . Parse ( s ) if err != nil { return err } c . ReloadSignal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Consul . Retry . Backoff = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Syslog . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Syslog . Facility = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { t , err := config . ParseTemplateConfig ( s ) if err != nil { return err } * c . Templates = append ( * c . Templates , t ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . Address = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( t time . Duration ) error { c . Vault . Grace = config . TimeDuration ( t ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . RenewToken = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . Retry . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcIntVar ) ( func ( i int ) error { c . Vault . Retry . Attempts = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Vault . Retry . Backoff = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Vault . Retry . MaxBackoff = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . SSL . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . SSL . CaCert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . SSL . CaPath = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . SSL . Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . SSL . Key = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . SSL . ServerName = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . SSL . Verify = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Vault . Transport . DialKeepAlive = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Vault . Transport . DialTimeout = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . Transport . DisableKeepAlives = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcIntVar ) ( func ( i int ) error { c . Vault . Transport . MaxIdleConnsPerHost = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( funcDurationVar ) ( func ( d time . Duration ) error { c . Vault . Transport . TLSHandshakeTimeout = config . TimeDuration ( d ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . Token = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { c . Vault . VaultAgentTokenFile = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( funcBoolVar ) ( func ( b bool ) error { c . Vault . UnwrapToken = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( funcVar ) ( func ( s string ) error { w , err := config . ParseWaitConfig ( s ) if err != nil { return err } c . Wait = w return nil } ) , " " , " " ) flags . BoolVar ( & isVersion , " " , false , " " ) flags . BoolVar ( & isVersion , " " , false , " " ) } if len ( args ) > 0 { return nil , nil , false , false , false , fmt . Errorf ( " " , args ) } return c , configPaths , once , dry , isVersion , nil } 
func loadConfigs ( paths [ ] string , o * config . Config ) ( * config . Config , error ) { finalC := config . DefaultConfig ( ) for _ , path := range paths { c , err := config . FromPath ( path ) if err != nil { return nil , err } finalC = finalC . Merge ( c ) } finalC = finalC . Merge ( o ) finalC . Finalize ( ) return finalC , nil } 
func logError ( err error , status int ) int { log . Printf ( " " , err ) return status } 
func FileModeGoString ( o * os . FileMode ) string { if o == nil { return " " } return fmt . Sprintf ( " " , * o ) } 
func SignalVal ( s * os . Signal ) os . Signal { if s == nil { return ( os . Signal ) ( nil ) } return * s } 
func SignalGoString ( s * os . Signal ) string { if s == nil { return " " } if * s == nil { return " " } return fmt . Sprintf ( " " , * s ) } 
func SignalPresent ( s * os . Signal ) bool { if s == nil { return false } return * s != signals . SIGNIL } 
func TimeDurationVal ( t * time . Duration ) time . Duration { if t == nil { return time . Duration ( 0 ) } return * t } 
func TimeDurationGoString ( t * time . Duration ) string { if t == nil { return " " } return fmt . Sprintf ( " " , t ) } 
func ( c * ClientSet ) CreateConsulClient ( i * CreateConsulClientInput ) error { consulConfig := consulapi . DefaultConfig ( ) if i . Address != " " { consulConfig . Address = i . Address } if i . Token != " " { consulConfig . Token = i . Token } if i . AuthEnabled { consulConfig . HttpAuth = & consulapi . HttpBasicAuth { Username : i . AuthUsername , Password : i . AuthPassword , } } var tlsConfig tls . Config if err != nil { return fmt . Errorf ( " " , err ) } tlsConfig . Certificates = [ ] tls . Certificate { cert } } else if i . SSLCert != " " { cert , err := tls . LoadX509KeyPair ( i . SSLCert , i . SSLCert ) if err != nil { return fmt . Errorf ( " " , err ) } tlsConfig . Certificates = [ ] tls . Certificate { cert } } if err := rootcerts . ConfigureTLS ( & tlsConfig , rootConfig ) ; err != nil { return fmt . Errorf ( " " , err ) } } tlsConfig . InsecureSkipVerify = false } if ! i . SSLVerify { log . Printf ( " " ) tlsConfig . InsecureSkipVerify = true } } if err != nil { return fmt . Errorf ( " " , err ) } c . consul = & consulClient { client : client , transport : transport , } c . Unlock ( ) return nil } 
func ( c * ClientSet ) Consul ( ) * consulapi . Client { c . RLock ( ) defer c . RUnlock ( ) return c . consul . client } 
func ( c * ClientSet ) Vault ( ) * vaultapi . Client { c . RLock ( ) defer c . RUnlock ( ) return c . vault . client } 
func ( c * ClientSet ) Stop ( ) { c . Lock ( ) defer c . Unlock ( ) if c . consul != nil { c . consul . transport . CloseIdleConnections ( ) } if c . vault != nil { c . vault . httpClient . Transport . ( * http . Transport ) . CloseIdleConnections ( ) } } 
func NewVaultReadQuery ( s string ) ( * VaultReadQuery , error ) { s = strings . TrimSpace ( s ) s = strings . Trim ( s , " " ) if s == " " { return nil , fmt . Errorf ( " " , s ) } secretURL , err := url . Parse ( s ) if err != nil { return nil , err } return & VaultReadQuery { stopCh : make ( chan struct { } , 1 ) , rawPath : secretURL . Path , queryValues : secretURL . Query ( ) , } , nil } 
func ( d * VaultReadQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { } ) if d . secret != nil { if vaultSecretRenewable ( d . secret ) { log . Printf ( " " , d ) renewer , err := clients . Vault ( ) . NewRenewer ( & api . RenewerInput { Grace : opts . VaultGrace , Secret : d . vaultSecret , } ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } go renewer . Renew ( ) defer renewer . Stop ( ) RENEW : for { select { case err := <- renewer . DoneCh ( ) : if err != nil { log . Printf ( " " , d , err ) } log . Printf ( " " , d ) break RENEW case renewal := <- renewer . RenewCh ( ) : log . Printf ( " " , d ) printVaultWarnings ( d , renewal . Secret . Warnings ) updateSecret ( d . secret , renewal . Secret ) case <- d . stopCh : return nil , nil , ErrStopped } } } else { log . Printf ( " " , d , dur ) select { case <- time . After ( dur ) : } } } if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } d . secret = transformSecret ( vaultSecret ) return respWithMetadata ( d . secret ) } 
func ( c * ExecConfig ) Copy ( ) * ExecConfig { if c == nil { return nil } var o ExecConfig o . Command = c . Command o . Enabled = c . Enabled if c . Env != nil { o . Env = c . Env . Copy ( ) } o . KillSignal = c . KillSignal o . KillTimeout = c . KillTimeout o . ReloadSignal = c . ReloadSignal o . Splay = c . Splay o . Timeout = c . Timeout return & o } 
func ( c * ExecConfig ) Merge ( o * ExecConfig ) * ExecConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Command != nil { r . Command = o . Command } if o . Enabled != nil { r . Enabled = o . Enabled } if o . Env != nil { r . Env = r . Env . Merge ( o . Env ) } if o . KillSignal != nil { r . KillSignal = o . KillSignal } if o . KillTimeout != nil { r . KillTimeout = o . KillTimeout } if o . ReloadSignal != nil { r . ReloadSignal = o . ReloadSignal } if o . Splay != nil { r . Splay = o . Splay } if o . Timeout != nil { r . Timeout = o . Timeout } return r } 
func ( c * ExecConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( StringPresent ( c . Command ) ) } if c . Command == nil { c . Command = String ( " " ) } if c . Env == nil { c . Env = DefaultEnvConfig ( ) } c . Env . Finalize ( ) if c . KillSignal == nil { c . KillSignal = Signal ( DefaultExecKillSignal ) } if c . KillTimeout == nil { c . KillTimeout = TimeDuration ( DefaultExecKillTimeout ) } if c . ReloadSignal == nil { c . ReloadSignal = Signal ( DefaultExecReloadSignal ) } if c . Splay == nil { c . Splay = TimeDuration ( 0 * time . Second ) } if c . Timeout == nil { c . Timeout = TimeDuration ( DefaultExecTimeout ) } } 
func ( c * ExecConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , StringGoString ( c . Command ) , BoolGoString ( c . Enabled ) , c . Env , SignalGoString ( c . KillSignal ) , TimeDurationGoString ( c . KillTimeout ) , SignalGoString ( c . ReloadSignal ) , TimeDurationGoString ( c . Splay ) , TimeDurationGoString ( c . Timeout ) , ) } 
func NewKVGetQuery ( s string ) ( * KVGetQuery , error ) { if s != " " && ! KVGetQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( KVGetQueryRe , s ) return & KVGetQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , key : m [ " " ] , } , nil } 
func ( d * KVGetQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . key , RawQuery : opts . String ( ) , } ) pair , qm , err := clients . Consul ( ) . KV ( ) . Get ( d . key , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , Block : d . block , } if pair == nil { log . Printf ( " " , d ) return nil , rm , nil } value := string ( pair . Value ) log . Printf ( " " , d , value ) return value , rm , nil } 
func ( d * KVGetQuery ) String ( ) string { key := d . key if d . dc != " " { key = key + " " + d . dc } if d . block { return fmt . Sprintf ( " " , key ) } return fmt . Sprintf ( " " , key ) } 
func NewVaultAgentTokenQuery ( path string ) ( * VaultAgentTokenQuery , error ) { return & VaultAgentTokenQuery { stopCh : make ( chan struct { } , 1 ) , path : path , } , nil } 
func ( d * VaultAgentTokenQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { log . Printf ( " " , d , d . path ) select { case <- d . stopCh : log . Printf ( " " , d ) return " " , nil , ErrStopped case r := <- d . watch ( d . stat ) : if r . err != nil { return " " , nil , errors . Wrap ( r . err , d . String ( ) ) } log . Printf ( " " , d ) token , err := ioutil . ReadFile ( d . path ) if err != nil { return " " , nil , errors . Wrap ( err , d . String ( ) ) } d . stat = r . stat clients . Vault ( ) . SetToken ( strings . TrimSpace ( string ( token ) ) ) } return respWithMetadata ( " " ) } 
func ( d * VaultAgentTokenQuery ) watch ( lastStat os . FileInfo ) <- chan * watchResult { ch := make ( chan * watchResult , 1 ) go func ( lastStat os . FileInfo ) { for { stat , err := os . Stat ( d . path ) if err != nil { select { case <- d . stopCh : return case ch <- & watchResult { err : err } : return } } changed := lastStat == nil || lastStat . Size ( ) != stat . Size ( ) || lastStat . ModTime ( ) != stat . ModTime ( ) if changed { select { case <- d . stopCh : return case ch <- & watchResult { stat : stat } : return } } time . Sleep ( VaultAgentTokenSleepTime ) } } ( lastStat ) return ch } 
func NewKVKeysQuery ( s string ) ( * KVKeysQuery , error ) { if s != " " && ! KVKeysQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( KVKeysQueryRe , s ) return & KVKeysQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , prefix : m [ " " ] , } , nil } 
func ( d * KVKeysQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . prefix , RawQuery : opts . String ( ) , } ) list , qm , err := clients . Consul ( ) . KV ( ) . Keys ( d . prefix , " " , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } keys := make ( [ ] string , len ( list ) ) for i , v := range list { v = strings . TrimPrefix ( v , d . prefix ) v = strings . TrimLeft ( v , " " ) keys [ i ] = v } log . Printf ( " " , d , len ( list ) ) rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return keys , rm , nil } 
func ( d * KVKeysQuery ) String ( ) string { prefix := d . prefix if d . dc != " " { prefix = prefix + " " + d . dc } return fmt . Sprintf ( " " , prefix ) } 
func New ( i * NewInput ) ( * Child , error ) { if i == nil { i = new ( NewInput ) } if len ( i . Command ) == 0 { return nil , ErrMissingCommand } child := & Child { stdin : i . Stdin , stdout : i . Stdout , stderr : i . Stderr , command : i . Command , args : i . Args , env : i . Env , timeout : i . Timeout , reloadSignal : i . ReloadSignal , killSignal : i . KillSignal , killTimeout : i . KillTimeout , splay : i . Splay , stopCh : make ( chan struct { } , 1 ) , } return child , nil } 
func ( c * Child ) ExitCh ( ) <- chan int { c . RLock ( ) defer c . RUnlock ( ) return c . exitCh } 
func ( c * Child ) Pid ( ) int { c . RLock ( ) defer c . RUnlock ( ) return c . pid ( ) } 
func ( c * Child ) Command ( ) string { list := append ( [ ] string { c . command } , c . args ... ) return strings . Join ( list , " " ) } 
func ( c * Child ) Start ( ) error { log . Printf ( " " , c . Command ( ) ) c . Lock ( ) defer c . Unlock ( ) return c . start ( ) } 
func ( c * Child ) Signal ( s os . Signal ) error { log . Printf ( " " , s . String ( ) ) c . RLock ( ) defer c . RUnlock ( ) return c . signal ( s ) } 
func ( c * Child ) Reload ( ) error { if c . reloadSignal == nil { log . Printf ( " " ) defer c . Unlock ( ) c . kill ( ) return c . start ( ) } log . Printf ( " " ) defer c . RUnlock ( ) return c . reload ( ) } 
func ( c * Child ) Kill ( ) { log . Printf ( " " ) c . Lock ( ) defer c . Unlock ( ) c . kill ( ) } 
func ( c * Child ) Stop ( ) { log . Printf ( " " ) c . Lock ( ) defer c . Unlock ( ) c . stopLock . Lock ( ) defer c . stopLock . Unlock ( ) if c . stopped { log . Printf ( " " ) return } c . kill ( ) close ( c . stopCh ) c . stopped = true } 
func ( c * EnvConfig ) Copy ( ) * EnvConfig { if c == nil { return nil } var o EnvConfig if c . Blacklist != nil { o . Blacklist = append ( [ ] string { } , c . Blacklist ... ) } if c . Custom != nil { o . Custom = append ( [ ] string { } , c . Custom ... ) } o . Pristine = c . Pristine if c . Whitelist != nil { o . Whitelist = append ( [ ] string { } , c . Whitelist ... ) } return & o } 
func ( c * EnvConfig ) Merge ( o * EnvConfig ) * EnvConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Blacklist != nil { r . Blacklist = append ( r . Blacklist , o . Blacklist ... ) } if o . Custom != nil { r . Custom = append ( r . Custom , o . Custom ... ) } if o . Pristine != nil { r . Pristine = o . Pristine } if o . Whitelist != nil { r . Whitelist = append ( r . Whitelist , o . Whitelist ... ) } return r } 
func ( c * EnvConfig ) Env ( ) [ ] string { } return [ ] string { } } keys := make ( [ ] string , len ( environ ) ) env := make ( map [ string ] string , len ( environ ) ) for i , v := range environ { list := strings . SplitN ( v , " " , 2 ) keys [ i ] = list [ 0 ] env [ list [ 0 ] ] = list [ 1 ] } } } return false } for _ , k := range keys { if anyGlobMatch ( k , c . Whitelist ) { newKeys = append ( newKeys , k ) } } keys = newKeys } for _ , k := range keys { if ! anyGlobMatch ( k , c . Blacklist ) { newKeys = append ( newKeys , k ) } } keys = newKeys } for _ , k := range keys { finalEnv = append ( finalEnv , k + " " + env [ k ] ) } return finalEnv } 
func ( c * EnvConfig ) Finalize ( ) { if c . Blacklist == nil { c . Blacklist = [ ] string { } } if c . Custom == nil { c . Custom = [ ] string { } } if c . Pristine == nil { c . Pristine = Bool ( false ) } if c . Whitelist == nil { c . Whitelist = [ ] string { } } } 
func ( c * EnvConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , c . Blacklist , c . Custom , BoolGoString ( c . Pristine ) , c . Whitelist , ) } 
func NewHealthServiceQuery ( s string ) ( * HealthServiceQuery , error ) { if ! HealthServiceQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( HealthServiceQueryRe , s ) var filters [ ] string if filter := m [ " " ] ; filter != " " { split := strings . Split ( filter , " " ) for _ , f := range split { f = strings . TrimSpace ( f ) switch f { case HealthAny , HealthPassing , HealthWarning , HealthCritical , HealthMaint : filters = append ( filters , f ) case " " : default : return nil , fmt . Errorf ( " " , f , s ) } } sort . Strings ( filters ) } else { filters = [ ] string { HealthPassing } } return & HealthServiceQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , filters : filters , name : m [ " " ] , near : m [ " " ] , tag : m [ " " ] , } , nil } 
func ( d * HealthServiceQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , Near : d . near , } ) u := & url . URL { Path : " " + d . name , RawQuery : opts . String ( ) , } if d . tag != " " { q := u . Query ( ) q . Set ( " " , d . tag ) u . RawQuery = q . Encode ( ) } log . Printf ( " " , d , u ) entries , qm , err := clients . Consul ( ) . Health ( ) . Service ( d . name , d . tag , passingOnly , opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) list := make ( [ ] * HealthService , 0 , len ( entries ) ) for _ , entry := range entries { } if address == " " { address = entry . Node . Address } list = append ( list , & HealthService { Node : entry . Node . Node , NodeID : entry . Node . ID , NodeAddress : entry . Node . Address , NodeTaggedAddresses : entry . Node . TaggedAddresses , NodeMeta : entry . Node . Meta , ServiceMeta : entry . Service . Meta , Address : address , ID : entry . Service . ID , Name : entry . Service . Service , Tags : ServiceTags ( deepCopyAndSortTags ( entry . Service . Tags ) ) , Status : status , Checks : entry . Checks , Port : entry . Service . Port , } ) } log . Printf ( " " , d , len ( list ) ) } rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return list , rm , nil } 
func ( d * HealthServiceQuery ) String ( ) string { name := d . name if d . tag != " " { name = d . tag + " " + name } if d . dc != " " { name = name + " " + d . dc } if d . near != " " { name = name + " " + d . near } if len ( d . filters ) > 0 { name = name + " " + strings . Join ( d . filters , " " ) } return fmt . Sprintf ( " " , name ) } 
func acceptStatus ( list [ ] string , s string ) bool { for _ , status := range list { if status == s || status == HealthAny { return true } } return false } 
func ( c * RetryConfig ) Copy ( ) * RetryConfig { if c == nil { return nil } var o RetryConfig o . Attempts = c . Attempts o . Backoff = c . Backoff o . MaxBackoff = c . MaxBackoff o . Enabled = c . Enabled return & o } 
func ( c * RetryConfig ) Merge ( o * RetryConfig ) * RetryConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Attempts != nil { r . Attempts = o . Attempts } if o . Backoff != nil { r . Backoff = o . Backoff } if o . MaxBackoff != nil { r . MaxBackoff = o . MaxBackoff } if o . Enabled != nil { r . Enabled = o . Enabled } return r } 
func ( c * RetryConfig ) RetryFunc ( ) RetryFunc { return func ( retry int ) ( bool , time . Duration ) { if ! BoolVal ( c . Enabled ) { return false , 0 } if IntVal ( c . Attempts ) > 0 && retry > IntVal ( c . Attempts ) - 1 { return false , 0 } baseSleep := TimeDurationVal ( c . Backoff ) maxSleep := TimeDurationVal ( c . MaxBackoff ) if maxSleep > 0 { attemptsTillMaxBackoff := int ( math . Log2 ( maxSleep . Seconds ( ) / baseSleep . Seconds ( ) ) ) if retry > attemptsTillMaxBackoff { return true , maxSleep } } base := math . Pow ( 2 , float64 ( retry ) ) sleep := time . Duration ( base ) * baseSleep return true , sleep } } 
func ( c * RetryConfig ) Finalize ( ) { if c . Attempts == nil { c . Attempts = Int ( DefaultRetryAttempts ) } if c . Backoff == nil { c . Backoff = TimeDuration ( DefaultRetryBackoff ) } if c . MaxBackoff == nil { c . MaxBackoff = TimeDuration ( DefaultRetryMaxBackoff ) } if c . Enabled == nil { c . Enabled = Bool ( true ) } } 
func ( c * RetryConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , IntGoString ( c . Attempts ) , TimeDurationGoString ( c . Backoff ) , TimeDurationGoString ( c . MaxBackoff ) , BoolGoString ( c . Enabled ) , ) } 
func NewRunner ( config * config . Config , dry , once bool ) ( * Runner , error ) { log . Printf ( " " , dry , once ) runner := & Runner { config : config , dry : dry , once : once , } if err := runner . init ( ) ; err != nil { return nil , err } return runner , nil } 
func ( r * Runner ) Start ( ) { log . Printf ( " " ) return } if r . dedup != nil { if err := r . dedup . Start ( ) ; err != nil { r . ErrCh <- err return } dedupCh = r . dedup . UpdateCh ( ) } if err := r . Run ( ) ; err != nil { r . ErrCh <- err return } for { } for _ , c := range r . templateConfigsFor ( t ) { if * c . Wait . Enabled { log . Printf ( " " , t . ID ( ) ) r . quiescenceMap [ t . ID ( ) ] = newQuiescence ( r . quiescenceCh , * c . Wait . Min , * c . Wait . Max , t ) continue NEXT_Q } } if * r . config . Wait . Enabled { log . Printf ( " " , t . ID ( ) ) r . quiescenceMap [ t . ID ( ) ] = newQuiescence ( r . quiescenceCh , * r . config . Wait . Min , * r . config . Wait . Max , t ) continue NEXT_Q } } } else { log . Printf ( " " , r . watcher . Size ( ) ) } if r . allTemplatesRendered ( ) { log . Printf ( " " ) log . Printf ( " " ) if r . child == nil { env := r . config . Exec . Env . Copy ( ) env . Custom = append ( r . childEnv ( ) , env . Custom ... ) child , err := spawnChild ( & spawnChildInput { Stdin : r . inStream , Stdout : r . outStream , Stderr : r . errStream , Command : config . StringVal ( r . config . Exec . Command ) , Env : env . Env ( ) , ReloadSignal : config . SignalVal ( r . config . Exec . ReloadSignal ) , KillSignal : config . SignalVal ( r . config . Exec . KillSignal ) , KillTimeout : config . TimeDurationVal ( r . config . Exec . KillTimeout ) , Splay : config . TimeDurationVal ( r . config . Exec . Splay ) , } ) if err != nil { r . ErrCh <- err r . childLock . Unlock ( ) return } r . child = child } if nexitCh != nil { childExitCh = nexitCh } } if r . child != nil { r . stopDedup ( ) r . stopWatcher ( ) log . Printf ( " " ) select { case c := <- childExitCh : log . Printf ( " " ) r . ErrCh <- NewErrChildDied ( c ) return case <- r . DoneCh : } } r . Stop ( ) return } } OUTER : select { case view := <- r . watcher . DataCh ( ) : default : break OUTER } } case <- dedupCh : break OUTER case err := <- r . watcher . ErrCh ( ) : r . ErrCh <- err return case tmpl := <- r . quiescenceCh : delete ( r . quiescenceMap , tmpl . ID ( ) ) case c := <- childExitCh : log . Printf ( " " ) r . ErrCh <- NewErrChildDied ( c ) return case <- r . DoneCh : log . Printf ( " " ) return } return } } } 
func ( r * Runner ) Stop ( ) { r . stopLock . Lock ( ) defer r . stopLock . Unlock ( ) if r . stopped { return } log . Printf ( " " ) r . stopDedup ( ) r . stopWatcher ( ) r . stopChild ( ) if err := r . deletePid ( ) ; err != nil { log . Printf ( " " , r . config . PidFile , err ) } r . stopped = true close ( r . DoneCh ) } 
func ( r * Runner ) RenderEvents ( ) map [ string ] * RenderEvent { r . renderEventsLock . RLock ( ) defer r . renderEventsLock . RUnlock ( ) times := make ( map [ string ] * RenderEvent , len ( r . renderEvents ) ) for k , v := range r . renderEvents { times [ k ] = v } return times } 
func ( r * Runner ) Receive ( d dep . Dependency , data interface { } ) { r . dependenciesLock . Lock ( ) defer r . dependenciesLock . Unlock ( ) r . brain . Remember ( d , data ) } } 
func ( r * Runner ) Signal ( s os . Signal ) error { r . childLock . RLock ( ) defer r . childLock . RUnlock ( ) if r . child == nil { return nil } return r . child . Signal ( s ) } 
func ( r * Runner ) Run ( ) error { log . Printf ( " " ) var newRenderEvent , wouldRenderAny , renderedAny bool runCtx := & templateRunCtx { depsMap : make ( map [ string ] dep . Dependency ) , } for _ , tmpl := range r . templates { event , err := r . runTemplate ( tmpl , runCtx ) if err != nil { return err } r . renderEvents [ tmpl . ID ( ) ] = event r . renderEventsLock . Unlock ( ) } } } } } } for _ , t := range runCtx . commands { command := config . StringVal ( t . Exec . Command ) log . Printf ( " " , command , t . Display ( ) ) env := t . Exec . Env . Copy ( ) env . Custom = append ( r . childEnv ( ) , env . Custom ... ) if _ , err := spawnChild ( & spawnChildInput { Stdin : r . inStream , Stdout : r . outStream , Stderr : r . errStream , Command : command , Env : env . Env ( ) , Timeout : config . TimeDurationVal ( t . Exec . Timeout ) , ReloadSignal : config . SignalVal ( t . Exec . ReloadSignal ) , KillSignal : config . SignalVal ( t . Exec . KillSignal ) , KillTimeout : config . TimeDurationVal ( t . Exec . KillTimeout ) , Splay : config . TimeDurationVal ( t . Exec . Splay ) , } ) ; err != nil { s := fmt . Sprintf ( " " , command , t . Display ( ) ) errs = append ( errs , errors . Wrap ( err , s ) ) } } if err := r . child . Reload ( ) ; err != nil { errs = append ( errs , err ) } r . childLock . RUnlock ( ) } for _ , err := range errs { result = multierror . Append ( result , err ) } return result . ErrorOrNil ( ) } return nil } 
func ( r * Runner ) runTemplate ( tmpl * template . Template , runCtx * templateRunCtx ) ( * RenderEvent , error ) { log . Printf ( " " , tmpl . ID ( ) ) lastEvent := r . renderEvents [ tmpl . ID ( ) ] r . renderEventsLock . RUnlock ( ) if lastEvent != nil { event . LastWouldRender = lastEvent . LastWouldRender event . LastDidRender = lastEvent . LastDidRender } if r . dedup != nil { isLeader = r . dedup . IsLeader ( tmpl ) } event , ok := r . renderEvents [ tmpl . ID ( ) ] r . renderEventsLock . RUnlock ( ) if ok && ( event . WouldRender || event . DidRender ) { log . Printf ( " " ) return nil , nil } } if err != nil { return nil , errors . Wrap ( err , tmpl . Source ( ) ) } } if _ , ok := runCtx . depsMap [ d . String ( ) ] ; ! ok { runCtx . depsMap [ d . String ( ) ] = d } } for _ , d := range missing . List ( ) { if ! r . watcher . Watching ( d ) { unwatched . Add ( d ) } } event . UnwatchedDeps = unwatched event . UsedDeps = used event . UpdatedAt = time . Now ( ) . UTC ( ) for _ , d := range unwatched . List ( ) { } } return event , nil } return event , nil } } } return event , nil } if err != nil { return nil , errors . Wrap ( err , " " + templateConfig . Display ( ) ) } renderTime := time . Now ( ) . UTC ( ) event . LastWouldRender = renderTime } event . LastDidRender = renderTime if ! r . dry { if existing != nil { log . Printf ( " " , c , templateConfig . Display ( ) , existing . Display ( ) ) } else { log . Printf ( " " , c , templateConfig . Display ( ) ) runCtx . commands = append ( runCtx . commands , templateConfig ) } } } } } return event , nil } 
func ( r * Runner ) init ( ) error { r . config . Finalize ( ) if err != nil { return err } log . Printf ( " " , result ) if err != nil { return fmt . Errorf ( " " , err ) } if err != nil { return fmt . Errorf ( " " , err ) } r . watcher = watcher numTemplates := len ( * r . config . Templates ) templates := make ( [ ] * template . Template , 0 , numTemplates ) ctemplatesMap := make ( map [ string ] config . TemplateConfigs ) if err != nil { return err } if _ , ok := ctemplatesMap [ tmpl . ID ( ) ] ; ! ok { templates = append ( templates , tmpl ) } if _ , ok := ctemplatesMap [ tmpl . ID ( ) ] ; ! ok { ctemplatesMap [ tmpl . ID ( ) ] = make ( [ ] * config . TemplateConfig , 0 , 1 ) } ctemplatesMap [ tmpl . ID ( ) ] = append ( ctemplatesMap [ tmpl . ID ( ) ] , ctmpl ) } r . renderEvents = make ( map [ string ] * RenderEvent , numTemplates ) r . dependencies = make ( map [ string ] dep . Dependency ) r . renderedCh = make ( chan struct { } , 1 ) r . renderEventCh = make ( chan struct { } , 1 ) r . ctemplatesMap = ctemplatesMap r . inStream = os . Stdin r . outStream = os . Stdout r . errStream = os . Stderr r . brain = template . NewBrain ( ) r . ErrCh = make ( chan error ) r . DoneCh = make ( chan struct { } ) r . quiescenceMap = make ( map [ string ] * quiescence ) r . quiescenceCh = make ( chan * template . Template ) if * r . config . Dedup . Enabled { if r . once { log . Printf ( " " ) } else { r . dedup , err = NewDedupManager ( r . config . Dedup , clients , r . brain , r . templates ) if err != nil { return err } } } return nil } 
func ( r * Runner ) diffAndUpdateDeps ( depsMap map [ string ] dep . Dependency ) { r . dependenciesLock . Lock ( ) defer r . dependenciesLock . Unlock ( ) for key , d := range r . dependencies { if _ , ok := depsMap [ key ] ; ! ok { log . Printf ( " " , d ) r . watcher . Remove ( d ) r . brain . Forget ( d ) } else { log . Printf ( " " , d ) } } r . dependencies = depsMap } 
func ( r * Runner ) templateConfigsFor ( tmpl * template . Template ) [ ] * config . TemplateConfig { return r . ctemplatesMap [ tmpl . ID ( ) ] } 
func ( r * Runner ) TemplateConfigMapping ( ) map [ string ] [ ] config . TemplateConfig { m := make ( map [ string ] [ ] config . TemplateConfig , len ( r . ctemplatesMap ) ) for id , set := range r . ctemplatesMap { ctmpls := make ( [ ] config . TemplateConfig , len ( set ) ) m [ id ] = ctmpls for i , ctmpl := range set { ctmpls [ i ] = * ctmpl } } return m } 
func ( r * Runner ) allTemplatesRendered ( ) bool { r . renderEventsLock . RLock ( ) defer r . renderEventsLock . RUnlock ( ) for _ , tmpl := range r . templates { event , rendered := r . renderEvents [ tmpl . ID ( ) ] if ! rendered { return false } } } } return true } 
func ( r * Runner ) childEnv ( ) [ ] string { var m = make ( map [ string ] string ) if config . StringPresent ( r . config . Consul . Address ) { m [ " " ] = config . StringVal ( r . config . Consul . Address ) } if config . BoolVal ( r . config . Consul . Auth . Enabled ) { m [ " " ] = r . config . Consul . Auth . String ( ) } m [ " " ] = strconv . FormatBool ( config . BoolVal ( r . config . Consul . SSL . Enabled ) ) m [ " " ] = strconv . FormatBool ( config . BoolVal ( r . config . Consul . SSL . Verify ) ) if config . StringPresent ( r . config . Vault . Address ) { m [ " " ] = config . StringVal ( r . config . Vault . Address ) } if ! config . BoolVal ( r . config . Vault . SSL . Verify ) { m [ " " ] = " " } if config . StringPresent ( r . config . Vault . SSL . Cert ) { m [ " " ] = config . StringVal ( r . config . Vault . SSL . Cert ) } if config . StringPresent ( r . config . Vault . SSL . Key ) { m [ " " ] = config . StringVal ( r . config . Vault . SSL . Key ) } if config . StringPresent ( r . config . Vault . SSL . CaPath ) { m [ " " ] = config . StringVal ( r . config . Vault . SSL . CaPath ) } if config . StringPresent ( r . config . Vault . SSL . CaCert ) { m [ " " ] = config . StringVal ( r . config . Vault . SSL . CaCert ) } if config . StringPresent ( r . config . Vault . SSL . ServerName ) { m [ " " ] = config . StringVal ( r . config . Vault . SSL . ServerName ) } } e := make ( [ ] string , 0 , len ( m ) ) for k , v := range m { e = append ( e , k + " " + v ) } return e } 
func ( r * Runner ) storePid ( ) error { path := config . StringVal ( r . config . PidFile ) if path == " " { return nil } log . Printf ( " " , path ) f , err := os . OpenFile ( path , os . O_CREATE | os . O_WRONLY | os . O_TRUNC , 0666 ) if err != nil { return fmt . Errorf ( " " , err ) } defer f . Close ( ) pid := os . Getpid ( ) _ , err = f . WriteString ( fmt . Sprintf ( " " , pid ) ) if err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( r * Runner ) deletePid ( ) error { path := config . StringVal ( r . config . PidFile ) if path == " " { return nil } log . Printf ( " " , path ) stat , err := os . Stat ( path ) if err != nil { return fmt . Errorf ( " " , err ) } if stat . IsDir ( ) { return fmt . Errorf ( " " ) } err = os . Remove ( path ) if err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func spawnChild ( i * spawnChildInput ) ( * child . Child , error ) { p := shellwords . NewParser ( ) p . ParseEnv = true p . ParseBacktick = true args , err := p . Parse ( i . Command ) if err != nil { return nil , errors . Wrap ( err , " " ) } child , err := child . New ( & child . NewInput { Stdin : i . Stdin , Stdout : i . Stdout , Stderr : i . Stderr , Command : args [ 0 ] , Args : args [ 1 : ] , Env : i . Env , Timeout : i . Timeout , ReloadSignal : i . ReloadSignal , KillSignal : i . KillSignal , KillTimeout : i . KillTimeout , Splay : i . Splay , } ) if err != nil { return nil , errors . Wrap ( err , " " ) } if err := child . Start ( ) ; err != nil { return nil , errors . Wrap ( err , " " ) } return child , nil } 
func newQuiescence ( ch chan * template . Template , min , max time . Duration , t * template . Template ) * quiescence { return & quiescence { template : t , min : min , max : max , ch : ch , } } 
func ( q * quiescence ) tick ( ) { now := time . Now ( ) go func ( ) { select { case <- q . timer . C : q . ch <- q . template } } ( ) q . deadline = now . Add ( q . max ) return } } else if dur := q . deadline . Sub ( now ) ; dur > 0 { q . timer . Reset ( dur ) } } 
func findCommand ( c * config . TemplateConfig , templates [ ] * config . TemplateConfig ) * config . TemplateConfig { needle := config . StringVal ( c . Exec . Command ) for _ , t := range templates { if needle == config . StringVal ( t . Exec . Command ) { return t } } return nil } 
func newClientSet ( c * config . Config ) ( * dep . ClientSet , error ) { clients := dep . NewClientSet ( ) if err := clients . CreateConsulClient ( & dep . CreateConsulClientInput { Address : config . StringVal ( c . Consul . Address ) , Token : config . StringVal ( c . Consul . Token ) , AuthEnabled : config . BoolVal ( c . Consul . Auth . Enabled ) , AuthUsername : config . StringVal ( c . Consul . Auth . Username ) , AuthPassword : config . StringVal ( c . Consul . Auth . Password ) , SSLEnabled : config . BoolVal ( c . Consul . SSL . Enabled ) , SSLVerify : config . BoolVal ( c . Consul . SSL . Verify ) , SSLCert : config . StringVal ( c . Consul . SSL . Cert ) , SSLKey : config . StringVal ( c . Consul . SSL . Key ) , SSLCACert : config . StringVal ( c . Consul . SSL . CaCert ) , SSLCAPath : config . StringVal ( c . Consul . SSL . CaPath ) , ServerName : config . StringVal ( c . Consul . SSL . ServerName ) , TransportDialKeepAlive : config . TimeDurationVal ( c . Consul . Transport . DialKeepAlive ) , TransportDialTimeout : config . TimeDurationVal ( c . Consul . Transport . DialTimeout ) , TransportDisableKeepAlives : config . BoolVal ( c . Consul . Transport . DisableKeepAlives ) , TransportIdleConnTimeout : config . TimeDurationVal ( c . Consul . Transport . IdleConnTimeout ) , TransportMaxIdleConns : config . IntVal ( c . Consul . Transport . MaxIdleConns ) , TransportMaxIdleConnsPerHost : config . IntVal ( c . Consul . Transport . MaxIdleConnsPerHost ) , TransportTLSHandshakeTimeout : config . TimeDurationVal ( c . Consul . Transport . TLSHandshakeTimeout ) , } ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } if err := clients . CreateVaultClient ( & dep . CreateVaultClientInput { Address : config . StringVal ( c . Vault . Address ) , Namespace : config . StringVal ( c . Vault . Namespace ) , Token : config . StringVal ( c . Vault . Token ) , UnwrapToken : config . BoolVal ( c . Vault . UnwrapToken ) , SSLEnabled : config . BoolVal ( c . Vault . SSL . Enabled ) , SSLVerify : config . BoolVal ( c . Vault . SSL . Verify ) , SSLCert : config . StringVal ( c . Vault . SSL . Cert ) , SSLKey : config . StringVal ( c . Vault . SSL . Key ) , SSLCACert : config . StringVal ( c . Vault . SSL . CaCert ) , SSLCAPath : config . StringVal ( c . Vault . SSL . CaPath ) , ServerName : config . StringVal ( c . Vault . SSL . ServerName ) , TransportDialKeepAlive : config . TimeDurationVal ( c . Vault . Transport . DialKeepAlive ) , TransportDialTimeout : config . TimeDurationVal ( c . Vault . Transport . DialTimeout ) , TransportDisableKeepAlives : config . BoolVal ( c . Vault . Transport . DisableKeepAlives ) , TransportIdleConnTimeout : config . TimeDurationVal ( c . Vault . Transport . IdleConnTimeout ) , TransportMaxIdleConns : config . IntVal ( c . Vault . Transport . MaxIdleConns ) , TransportMaxIdleConnsPerHost : config . IntVal ( c . Vault . Transport . MaxIdleConnsPerHost ) , TransportTLSHandshakeTimeout : config . TimeDurationVal ( c . Vault . Transport . TLSHandshakeTimeout ) , } ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } return clients , nil } 
func newWatcher ( c * config . Config , clients * dep . ClientSet , once bool ) ( * watch . Watcher , error ) { log . Printf ( " " ) w , err := watch . NewWatcher ( & watch . NewWatcherInput { Clients : clients , MaxStale : config . TimeDurationVal ( c . MaxStale ) , Once : once , RenewVault : clients . Vault ( ) . Token ( ) != " " && config . BoolVal ( c . Vault . RenewToken ) , VaultAgentTokenFile : config . StringVal ( c . Vault . VaultAgentTokenFile ) , RetryFuncConsul : watch . RetryFunc ( c . Consul . Retry . RetryFunc ( ) ) , if err != nil { return nil , errors . Wrap ( err , " " ) } return w , nil } 
func NewCatalogServicesQuery ( s string ) ( * CatalogServicesQuery , error ) { if ! CatalogServicesQueryRe . MatchString ( s ) { return nil , fmt . Errorf ( " " , s ) } m := regexpMatch ( CatalogServicesQueryRe , s ) return & CatalogServicesQuery { stopCh : make ( chan struct { } , 1 ) , dc : m [ " " ] , } , nil } 
func ( d * CatalogServicesQuery ) Fetch ( clients * ClientSet , opts * QueryOptions ) ( interface { } , * ResponseMetadata , error ) { select { case <- d . stopCh : return nil , nil , ErrStopped default : } opts = opts . Merge ( & QueryOptions { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " , RawQuery : opts . String ( ) , } ) entries , qm , err := clients . Consul ( ) . Catalog ( ) . Services ( opts . ToConsulOpts ( ) ) if err != nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) var catalogServices [ ] * CatalogSnippet for name , tags := range entries { catalogServices = append ( catalogServices , & CatalogSnippet { Name : name , Tags : ServiceTags ( deepCopyAndSortTags ( tags ) ) , } ) } sort . Stable ( ByName ( catalogServices ) ) rm := & ResponseMetadata { LastIndex : qm . LastIndex , LastContact : qm . LastContact , } return catalogServices , rm , nil } 
func ( d * CatalogServicesQuery ) String ( ) string { if d . dc != " " { return fmt . Sprintf ( " " , d . dc ) } return " " } 
func DefaultConsulConfig ( ) * ConsulConfig { return & ConsulConfig { Auth : DefaultAuthConfig ( ) , Retry : DefaultRetryConfig ( ) , SSL : DefaultSSLConfig ( ) , Transport : DefaultTransportConfig ( ) , } } 
func ( c * ConsulConfig ) Copy ( ) * ConsulConfig { if c == nil { return nil } var o ConsulConfig o . Address = c . Address if c . Auth != nil { o . Auth = c . Auth . Copy ( ) } if c . Retry != nil { o . Retry = c . Retry . Copy ( ) } if c . SSL != nil { o . SSL = c . SSL . Copy ( ) } o . Token = c . Token if c . Transport != nil { o . Transport = c . Transport . Copy ( ) } return & o } 
func ( c * ConsulConfig ) Merge ( o * ConsulConfig ) * ConsulConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Address != nil { r . Address = o . Address } if o . Auth != nil { r . Auth = r . Auth . Merge ( o . Auth ) } if o . Retry != nil { r . Retry = r . Retry . Merge ( o . Retry ) } if o . SSL != nil { r . SSL = r . SSL . Merge ( o . SSL ) } if o . Token != nil { r . Token = o . Token } if o . Transport != nil { r . Transport = r . Transport . Merge ( o . Transport ) } return r } 
func ( c * ConsulConfig ) Finalize ( ) { if c . Address == nil { c . Address = stringFromEnv ( [ ] string { " " , } , " " ) } if c . Auth == nil { c . Auth = DefaultAuthConfig ( ) } c . Auth . Finalize ( ) if c . Retry == nil { c . Retry = DefaultRetryConfig ( ) } c . Retry . Finalize ( ) if c . SSL == nil { c . SSL = DefaultSSLConfig ( ) } c . SSL . Finalize ( ) if c . Token == nil { c . Token = stringFromEnv ( [ ] string { " " , " " , } , " " ) } if c . Transport == nil { c . Transport = DefaultTransportConfig ( ) } c . Transport . Finalize ( ) } 
func ( c * ConsulConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " , StringGoString ( c . Address ) , c . Auth , c . Retry , c . SSL , StringPresent ( c . Token ) , c . Transport , ) } 
func StringToSignalFunc ( ) mapstructure . DecodeHookFunc { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) != reflect . String { return data , nil } if t . String ( ) != " " { return data , nil } if data == nil || data . ( string ) == " " { return SIGNIL , nil } return Parse ( data . ( string ) ) } } 
func ( c * WaitConfig ) Copy ( ) * WaitConfig { if c == nil { return nil } var o WaitConfig o . Enabled = c . Enabled o . Min = c . Min o . Max = c . Max return & o } 
func ( c * WaitConfig ) Merge ( o * WaitConfig ) * WaitConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Enabled != nil { r . Enabled = o . Enabled } if o . Min != nil { r . Min = o . Min } if o . Max != nil { r . Max = o . Max } return r } 
func ( c * WaitConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( TimeDurationPresent ( c . Min ) ) } if c . Min == nil { c . Min = TimeDuration ( 0 * time . Second ) } if c . Max == nil { c . Max = TimeDuration ( 4 * * c . Min ) } } 
func ( c * WaitConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " , BoolGoString ( c . Enabled ) , TimeDurationGoString ( c . Min ) , TimeDurationGoString ( c . Max ) , ) } 
func ParseWaitConfig ( s string ) ( * WaitConfig , error ) { s = strings . TrimSpace ( s ) if len ( s ) < 1 { return nil , ErrWaitStringEmpty } parts := strings . Split ( s , " " ) var min , max time . Duration var err error switch len ( parts ) { case 1 : min , err = time . ParseDuration ( strings . TrimSpace ( parts [ 0 ] ) ) if err != nil { return nil , err } max = 4 * min case 2 : min , err = time . ParseDuration ( strings . TrimSpace ( parts [ 0 ] ) ) if err != nil { return nil , err } max , err = time . ParseDuration ( strings . TrimSpace ( parts [ 1 ] ) ) if err != nil { return nil , err } default : return nil , ErrWaitInvalidFormat } if min < 0 || max < 0 { return nil , ErrWaitNegative } if max < min { return nil , ErrWaitMinLTMax } var c WaitConfig c . Min = TimeDuration ( min ) c . Max = TimeDuration ( max ) return & c , nil } 
func ( w * WaitVar ) Set ( value string ) error { wait , err := ParseWaitConfig ( value ) if err != nil { return err } w . Min = wait . Min w . Max = wait . Max return nil } 
func ( w * WaitVar ) String ( ) string { return fmt . Sprintf ( " " , w . Min , w . Max ) } 
func ( c * SyslogConfig ) Copy ( ) * SyslogConfig { if c == nil { return nil } var o SyslogConfig o . Enabled = c . Enabled o . Facility = c . Facility return & o } 
func ( c * SyslogConfig ) Merge ( o * SyslogConfig ) * SyslogConfig { if c == nil { if o == nil { return nil } return o . Copy ( ) } if o == nil { return c . Copy ( ) } r := c . Copy ( ) if o . Enabled != nil { r . Enabled = o . Enabled } if o . Facility != nil { r . Facility = o . Facility } return r } 
func ( c * SyslogConfig ) Finalize ( ) { if c . Enabled == nil { c . Enabled = Bool ( StringPresent ( c . Facility ) ) } if c . Facility == nil { c . Facility = String ( DefaultSyslogFacility ) } } 
func ( c * SyslogConfig ) GoString ( ) string { if c == nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " , BoolGoString ( c . Enabled ) , StringGoString ( c . Facility ) , ) } 
func NewVaultTokenQuery ( token string ) ( * VaultTokenQuery , error ) { vaultSecret := & api . Secret { Auth : & api . SecretAuth { ClientToken : token , Renewable : true , LeaseDuration : 1 , } , } return & VaultTokenQuery { stopCh : make ( chan struct { } , 1 ) , vaultSecret : vaultSecret , secret : transformSecret ( vaultSecret ) , } , nil } 
func NewLogFilter ( ) * logutils . LevelFilter { return & logutils . LevelFilter { Levels : Levels , MinLevel : " " , Writer : ioutil . Discard , } } 
func ValidateLevelFilter ( min logutils . LogLevel , filter * logutils . LevelFilter ) bool { for _ , level := range filter . Levels { if level == min { return true } } return false } 
func datacentersFunc ( b * Brain , used , missing * dep . Set ) func ( ignore ... bool ) ( [ ] string , error ) { return func ( i ... bool ) ( [ ] string , error ) { result := [ ] string { } var ignore bool switch len ( i ) { case 0 : ignore = false case 1 : ignore = i [ 0 ] default : return result , fmt . Errorf ( " " + " " , len ( i ) ) } d , err := dep . NewCatalogDatacentersQuery ( ignore ) if err != nil { return result , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] string ) , nil } missing . Add ( d ) return result , nil } } 
func envFunc ( env [ ] string ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { for _ , e := range env { split := strings . SplitN ( e , " " , 2 ) k , v := split [ 0 ] , split [ 1 ] if k == s { return v , nil } } return os . Getenv ( s ) , nil } } 
func executeTemplateFunc ( t * template . Template ) func ( string , ... interface { } ) ( string , error ) { return func ( s string , data ... interface { } ) ( string , error ) { var dot interface { } switch len ( data ) { case 0 : dot = nil case 1 : dot = data [ 0 ] default : return " " , fmt . Errorf ( " " + " " , len ( data ) + 1 ) } var b bytes . Buffer if err := t . ExecuteTemplate ( & b , s , dot ) ; err != nil { return " " , err } return b . String ( ) , nil } } 
func fileFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) == 0 { return " " , nil } d , err := dep . NewFileQuery ( s ) if err != nil { return " " , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { if value == nil { return " " , nil } return value . ( string ) , nil } missing . Add ( d ) return " " , nil } } 
func keyFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) == 0 { return " " , nil } d , err := dep . NewKVGetQuery ( s ) if err != nil { return " " , err } d . EnableBlocking ( ) used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { if value == nil { return " " , nil } return value . ( string ) , nil } missing . Add ( d ) return " " , nil } } 
func keyExistsFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( bool , error ) { return func ( s string ) ( bool , error ) { if len ( s ) == 0 { return false , nil } d , err := dep . NewKVGetQuery ( s ) if err != nil { return false , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value != nil , nil } missing . Add ( d ) return false , nil } } 
func nodeFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( * dep . CatalogNode , error ) { return func ( s ... string ) ( * dep . CatalogNode , error ) { d , err := dep . NewCatalogNodeQuery ( strings . Join ( s , " " ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( * dep . CatalogNode ) , nil } missing . Add ( d ) return nil , nil } } 
func nodesFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( [ ] * dep . Node , error ) { return func ( s ... string ) ( [ ] * dep . Node , error ) { result := [ ] * dep . Node { } d , err := dep . NewCatalogNodesQuery ( strings . Join ( s , " " ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] * dep . Node ) , nil } missing . Add ( d ) return result , nil } } 
func secretFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( * dep . Secret , error ) { return func ( s ... string ) ( * dep . Secret , error ) { var result * dep . Secret if len ( s ) == 0 { return result , nil } data := make ( map [ string ] interface { } ) for _ , str := range rest { parts := strings . SplitN ( str , " " , 2 ) if len ( parts ) != 2 { return result , fmt . Errorf ( " " , str ) } k , v := strings . TrimSpace ( parts [ 0 ] ) , strings . TrimSpace ( parts [ 1 ] ) data [ k ] = v } var d dep . Dependency var err error if len ( rest ) == 0 { d , err = dep . NewVaultReadQuery ( path ) } else { d , err = dep . NewVaultWriteQuery ( path , data ) } if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { result = value . ( * dep . Secret ) return result , nil } missing . Add ( d ) return result , nil } } 
func secretsFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] string , error ) { return func ( s string ) ( [ ] string , error ) { var result [ ] string if len ( s ) == 0 { return result , nil } d , err := dep . NewVaultListQuery ( s ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { result = value . ( [ ] string ) return result , nil } missing . Add ( d ) return result , nil } } 
func serviceFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( [ ] * dep . HealthService , error ) { return func ( s ... string ) ( [ ] * dep . HealthService , error ) { result := [ ] * dep . HealthService { } if len ( s ) == 0 || s [ 0 ] == " " { return result , nil } d , err := dep . NewHealthServiceQuery ( strings . Join ( s , " " ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] * dep . HealthService ) , nil } missing . Add ( d ) return result , nil } } 
func servicesFunc ( b * Brain , used , missing * dep . Set ) func ( ... string ) ( [ ] * dep . CatalogSnippet , error ) { return func ( s ... string ) ( [ ] * dep . CatalogSnippet , error ) { result := [ ] * dep . CatalogSnippet { } d , err := dep . NewCatalogServicesQuery ( strings . Join ( s , " " ) ) if err != nil { return nil , err } used . Add ( d ) if value , ok := b . Recall ( d ) ; ok { return value . ( [ ] * dep . CatalogSnippet ) , nil } missing . Add ( d ) return result , nil } } 
func treeFunc ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] * dep . KeyPair , error ) { return func ( s string ) ( [ ] * dep . KeyPair , error ) { result := [ ] * dep . KeyPair { } if len ( s ) == 0 { return result , nil } d , err := dep . NewKVListQuery ( s ) if err != nil { return result , err } used . Add ( d ) if parts [ len ( parts ) - 1 ] != " " { result = append ( result , pair ) } } return result , nil } missing . Add ( d ) return result , nil } } 
func base64Decode ( s string ) ( string , error ) { v , err := base64 . StdEncoding . DecodeString ( s ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( v ) , nil } 
func base64Encode ( s string ) ( string , error ) { return base64 . StdEncoding . EncodeToString ( [ ] byte ( s ) ) , nil } 
func base64URLDecode ( s string ) ( string , error ) { v , err := base64 . URLEncoding . DecodeString ( s ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( v ) , nil } 
func base64URLEncode ( s string ) ( string , error ) { return base64 . URLEncoding . EncodeToString ( [ ] byte ( s ) ) , nil } 
func byKey ( pairs [ ] * dep . KeyPair ) ( map [ string ] map [ string ] * dep . KeyPair , error ) { m := make ( map [ string ] map [ string ] * dep . KeyPair ) for _ , pair := range pairs { parts := strings . Split ( pair . Key , " " ) top := parts [ 0 ] key := strings . Join ( parts [ 1 : ] , " " ) if key == " " { } if _ , ok := m [ top ] ; ! ok { m [ top ] = make ( map [ string ] * dep . KeyPair ) } newPair := * pair newPair . Key = key m [ top ] [ key ] = & newPair } return m , nil } 
func byTag ( in interface { } ) ( map [ string ] [ ] interface { } , error ) { m := make ( map [ string ] [ ] interface { } ) switch typed := in . ( type ) { case nil : case [ ] * dep . CatalogSnippet : for _ , s := range typed { for _ , t := range s . Tags { m [ t ] = append ( m [ t ] , s ) } } case [ ] * dep . CatalogService : for _ , s := range typed { for _ , t := range s . ServiceTags { m [ t ] = append ( m [ t ] , s ) } } case [ ] * dep . HealthService : for _ , s := range typed { for _ , t := range s . Tags { m [ t ] = append ( m [ t ] , s ) } } default : return nil , fmt . Errorf ( " " , in ) } return m , nil } 
func containsSomeFunc ( retTrue , invert bool ) func ( [ ] interface { } , interface { } ) ( bool , error ) { return func ( v [ ] interface { } , l interface { } ) ( bool , error ) { for i := 0 ; i < len ( v ) ; i ++ { if ok , _ := in ( l , v [ i ] ) ; ok != invert { return ! retTrue , nil } } return retTrue , nil } } 
func explode ( pairs [ ] * dep . KeyPair ) ( map [ string ] interface { } , error ) { m := make ( map [ string ] interface { } ) for _ , pair := range pairs { if err := explodeHelper ( m , pair . Key , pair . Value , pair . Key ) ; err != nil { return nil , errors . Wrap ( err , " " ) } } return m , nil } 
func explodeHelper ( m map [ string ] interface { } , k , v , p string ) error { if strings . Contains ( k , " " ) { parts := strings . Split ( k , " " ) top := parts [ 0 ] key := strings . Join ( parts [ 1 : ] , " " ) if _ , ok := m [ top ] ; ! ok { m [ top ] = make ( map [ string ] interface { } ) } nest , ok := m [ top ] . ( map [ string ] interface { } ) if ! ok { return fmt . Errorf ( " " , p , top , m [ top ] ) } return explodeHelper ( nest , key , v , k ) } if k != " " { m [ k ] = v } return nil } 
func in ( l , v interface { } ) ( bool , error ) { lv := reflect . ValueOf ( l ) vv := reflect . ValueOf ( v ) switch lv . Kind ( ) { case reflect . Array , reflect . Slice : if reflect . TypeOf ( l ) . Elem ( ) . Kind ( ) == reflect . Interface { interfaceSlice = l . ( [ ] interface { } ) } for i := 0 ; i < lv . Len ( ) ; i ++ { var lvv reflect . Value if interfaceSlice != nil { lvv = reflect . ValueOf ( interfaceSlice [ i ] ) } else { lvv = lv . Index ( i ) } switch lvv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch vv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : if vv . Int ( ) == lvv . Int ( ) { return true , nil } } case reflect . Float32 , reflect . Float64 : switch vv . Kind ( ) { case reflect . Float32 , reflect . Float64 : if vv . Float ( ) == lvv . Float ( ) { return true , nil } } case reflect . String : if vv . Type ( ) == lvv . Type ( ) && vv . String ( ) == lvv . String ( ) { return true , nil } } } case reflect . String : if vv . Type ( ) == lv . Type ( ) && strings . Contains ( lv . String ( ) , vv . String ( ) ) { return true , nil } } return false , nil } 
func indent ( spaces int , s string ) ( string , error ) { if spaces < 0 { return " " , fmt . Errorf ( " " ) } var output , prefix [ ] byte var sp bool var size int prefix = [ ] byte ( strings . Repeat ( " " , spaces ) ) sp = true for _ , c := range [ ] byte ( s ) { if sp && c != '\n' { output = append ( output , prefix ... ) size += spaces } output = append ( output , c ) sp = c == '\n' size ++ } return string ( output [ : size ] ) , nil } 
func loop ( ints ... int64 ) ( <- chan int64 , error ) { var start , stop int64 switch len ( ints ) { case 1 : start , stop = 0 , ints [ 0 ] case 2 : start , stop = ints [ 0 ] , ints [ 1 ] default : return nil , fmt . Errorf ( " " + " " , len ( ints ) ) } ch := make ( chan int64 ) go func ( ) { for i := start ; i < stop ; i ++ { ch <- i } close ( ch ) } ( ) return ch , nil } 
func join ( sep string , a [ ] string ) ( string , error ) { return strings . Join ( a , sep ) , nil } 
func parseBool ( s string ) ( bool , error ) { if s == " " { return false , nil } result , err := strconv . ParseBool ( s ) if err != nil { return false , errors . Wrap ( err , " " ) } return result , nil } 
func parseFloat ( s string ) ( float64 , error ) { if s == " " { return 0.0 , nil } result , err := strconv . ParseFloat ( s , 10 ) if err != nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func parseInt ( s string ) ( int64 , error ) { if s == " " { return 0 , nil } result , err := strconv . ParseInt ( s , 10 , 64 ) if err != nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func parseJSON ( s string ) ( interface { } , error ) { if s == " " { return map [ string ] interface { } { } , nil } var data interface { } if err := json . Unmarshal ( [ ] byte ( s ) , & data ) ; err != nil { return nil , err } return data , nil } 
func parseUint ( s string ) ( uint64 , error ) { if s == " " { return 0 , nil } result , err := strconv . ParseUint ( s , 10 , 64 ) if err != nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func plugin ( name string , args ... string ) ( string , error ) { if name == " " { return " " , nil } stdout , stderr := new ( bytes . Buffer ) , new ( bytes . Buffer ) for _ , arg := range args { if v := strings . TrimSpace ( arg ) ; v != " " { jsons = append ( jsons , v ) } } cmd := exec . Command ( name , jsons ... ) cmd . Stdout = stdout cmd . Stderr = stderr if err := cmd . Start ( ) ; err != nil { return " " , fmt . Errorf ( " \n \n \n \n \n \n \n \n " , name , err , stdout . Bytes ( ) , stderr . Bytes ( ) ) } done := make ( chan error , 1 ) go func ( ) { done <- cmd . Wait ( ) } ( ) select { case <- time . After ( 30 * time . Second ) : if cmd . Process != nil { if err := cmd . Process . Kill ( ) ; err != nil { return " " , fmt . Errorf ( " " , name ) } } <- done return " " , fmt . Errorf ( " " , name ) case err := <- done : if err != nil { return " " , fmt . Errorf ( " \n \n \n \n \n \n \n \n " , name , err , stdout . Bytes ( ) , stderr . Bytes ( ) ) } } return strings . TrimSpace ( stdout . String ( ) ) , nil } 
func replaceAll ( f , t , s string ) ( string , error ) { return strings . Replace ( s , f , t , - 1 ) , nil } 
func regexReplaceAll ( re , pl , s string ) ( string , error ) { compiled , err := regexp . Compile ( re ) if err != nil { return " " , err } return compiled . ReplaceAllString ( s , pl ) , nil } 
func regexMatch ( re , s string ) ( bool , error ) { compiled , err := regexp . Compile ( re ) if err != nil { return false , err } return compiled . MatchString ( s ) , nil } 
func split ( sep , s string ) ( [ ] string , error ) { s = strings . TrimSpace ( s ) if s == " " { return [ ] string { } , nil } return strings . Split ( s , sep ) , nil } 
func timestamp ( s ... string ) ( string , error ) { switch len ( s ) { case 0 : return now ( ) . Format ( time . RFC3339 ) , nil case 1 : if s [ 0 ] == " " { return strconv . FormatInt ( now ( ) . Unix ( ) , 10 ) , nil } return now ( ) . Format ( s [ 0 ] ) , nil default : return " " , fmt . Errorf ( " " + " " , len ( s ) ) } } 
func toJSON ( i interface { } ) ( string , error ) { result , err := json . Marshal ( i ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . TrimSpace ( result ) ) , err } 
func toJSONPretty ( m map [ string ] interface { } ) ( string , error ) { result , err := json . MarshalIndent ( m , " " , " " ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . TrimSpace ( result ) ) , err } 
func toYAML ( m map [ string ] interface { } ) ( string , error ) { result , err := yaml . Marshal ( m ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . TrimSpace ( result ) ) , nil } 
func toTOML ( m map [ string ] interface { } ) ( string , error ) { buf := bytes . NewBuffer ( [ ] byte { } ) enc := toml . NewEncoder ( buf ) if err := enc . Encode ( m ) ; err != nil { return " " , errors . Wrap ( err , " " ) } result , err := ioutil . ReadAll ( buf ) if err != nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . TrimSpace ( result ) ) , nil } 
func add ( b , a interface { } ) ( interface { } , error ) { av := reflect . ValueOf ( a ) bv := reflect . ValueOf ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Int ( ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Int ( ) + int64 ( bv . Uint ( ) ) , nil case reflect . Float32 , reflect . Float64 : return float64 ( av . Int ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return int64 ( av . Uint ( ) ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Uint ( ) + bv . Uint ( ) , nil case reflect . Float32 , reflect . Float64 : return float64 ( av . Uint ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Float32 , reflect . Float64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Float ( ) + float64 ( bv . Int ( ) ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Float ( ) + float64 ( bv . Uint ( ) ) , nil case reflect . Float32 , reflect . Float64 : return av . Float ( ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } default : return nil , fmt . Errorf ( " " , av , a ) } } 
func modulo ( b , a interface { } ) ( interface { } , error ) { av := reflect . ValueOf ( a ) bv := reflect . ValueOf ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return av . Int ( ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Int ( ) % int64 ( bv . Uint ( ) ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : switch bv . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 : return int64 ( av . Uint ( ) ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 : return av . Uint ( ) % bv . Uint ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } default : return nil , fmt . Errorf ( " " , av , a ) } } 
func ( item Item ) Expired ( ) bool { if item . Expiration == 0 { return false } return time . Now ( ) . UnixNano ( ) > item . Expiration } 
func ( c * cache ) Set ( k string , x interface { } , d time . Duration ) { if d == DefaultExpiration { d = c . defaultExpiration } if d > 0 { e = time . Now ( ) . Add ( d ) . UnixNano ( ) } c . mu . Lock ( ) c . items [ k ] = Item { Object : x , Expiration : e , } } 
func ( c * cache ) SetDefault ( k string , x interface { } ) { c . Set ( k , x , DefaultExpiration ) } 
func ( c * cache ) Add ( k string , x interface { } , d time . Duration ) error { c . mu . Lock ( ) _ , found := c . get ( k ) if found { c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . set ( k , x , d ) c . mu . Unlock ( ) return nil } 
func ( c * cache ) Get ( k string ) ( interface { } , bool ) { c . mu . RLock ( ) if ! found { c . mu . RUnlock ( ) return nil , false } if item . Expiration > 0 { if time . Now ( ) . UnixNano ( ) > item . Expiration { c . mu . RUnlock ( ) return nil , false } } c . mu . RUnlock ( ) return item . Object , true } 
func ( c * cache ) GetWithExpiration ( k string ) ( interface { } , time . Time , bool ) { c . mu . RLock ( ) if ! found { c . mu . RUnlock ( ) return nil , time . Time { } , false } if item . Expiration > 0 { if time . Now ( ) . UnixNano ( ) > item . Expiration { c . mu . RUnlock ( ) return nil , time . Time { } , false } return item . Object , time . Unix ( 0 , item . Expiration ) , true } return item . Object , time . Time { } , true } 
func ( c * cache ) IncrementInt ( k string , n int ) ( int , error ) { c . mu . Lock ( ) v , found := c . items [ k ] if ! found || v . Expired ( ) { c . mu . Unlock ( ) return 0 , fmt . Errorf ( " " , k ) } rv , ok := v . Object . ( int ) if ! ok { c . mu . Unlock ( ) return 0 , fmt . Errorf ( " " , k ) } nv := rv + n v . Object = nv c . items [ k ] = v c . mu . Unlock ( ) return nv , nil } 
func ( c * cache ) Decrement ( k string , n int64 ) error { v , found := c . items [ k ] if ! found || v . Expired ( ) { c . mu . Unlock ( ) return fmt . Errorf ( " " ) } switch v . Object . ( type ) { case int : v . Object = v . Object . ( int ) - int ( n ) case int8 : v . Object = v . Object . ( int8 ) - int8 ( n ) case int16 : v . Object = v . Object . ( int16 ) - int16 ( n ) case int32 : v . Object = v . Object . ( int32 ) - int32 ( n ) case int64 : v . Object = v . Object . ( int64 ) - n case uint : v . Object = v . Object . ( uint ) - uint ( n ) case uintptr : v . Object = v . Object . ( uintptr ) - uintptr ( n ) case uint8 : v . Object = v . Object . ( uint8 ) - uint8 ( n ) case uint16 : v . Object = v . Object . ( uint16 ) - uint16 ( n ) case uint32 : v . Object = v . Object . ( uint32 ) - uint32 ( n ) case uint64 : v . Object = v . Object . ( uint64 ) - uint64 ( n ) case float32 : v . Object = v . Object . ( float32 ) - float32 ( n ) case float64 : v . Object = v . Object . ( float64 ) - float64 ( n ) default : c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . items [ k ] = v c . mu . Unlock ( ) return nil } 
func ( c * cache ) DecrementFloat ( k string , n float64 ) error { c . mu . Lock ( ) v , found := c . items [ k ] if ! found || v . Expired ( ) { c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } switch v . Object . ( type ) { case float32 : v . Object = v . Object . ( float32 ) - float32 ( n ) case float64 : v . Object = v . Object . ( float64 ) - n default : c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . items [ k ] = v c . mu . Unlock ( ) return nil } 
func ( c * cache ) Delete ( k string ) { c . mu . Lock ( ) v , evicted := c . delete ( k ) c . mu . Unlock ( ) if evicted { c . onEvicted ( k , v ) } } 
func ( c * cache ) DeleteExpired ( ) { var evictedItems [ ] keyAndValue now := time . Now ( ) . UnixNano ( ) c . mu . Lock ( ) for k , v := range c . items { if evicted { evictedItems = append ( evictedItems , keyAndValue { k , ov } ) } } } c . mu . Unlock ( ) for _ , v := range evictedItems { c . onEvicted ( v . key , v . value ) } } 
func ( c * cache ) OnEvicted ( f func ( string , interface { } ) ) { c . mu . Lock ( ) c . onEvicted = f c . mu . Unlock ( ) } 
func ( c * cache ) Save ( w io . Writer ) ( err error ) { enc := gob . NewEncoder ( w ) defer func ( ) { if x := recover ( ) ; x != nil { err = fmt . Errorf ( " " ) } } ( ) c . mu . RLock ( ) defer c . mu . RUnlock ( ) for _ , v := range c . items { gob . Register ( v . Object ) } err = enc . Encode ( & c . items ) return } 
func ( c * cache ) SaveFile ( fname string ) error { fp , err := os . Create ( fname ) if err != nil { return err } err = c . Save ( fp ) if err != nil { fp . Close ( ) return err } return fp . Close ( ) } 
func ( c * cache ) Load ( r io . Reader ) error { dec := gob . NewDecoder ( r ) items := map [ string ] Item { } err := dec . Decode ( & items ) if err == nil { c . mu . Lock ( ) defer c . mu . Unlock ( ) for k , v := range items { ov , found := c . items [ k ] if ! found || ov . Expired ( ) { c . items [ k ] = v } } } return err } 
func ( c * cache ) LoadFile ( fname string ) error { fp , err := os . Open ( fname ) if err != nil { return err } err = c . Load ( fp ) if err != nil { fp . Close ( ) return err } return fp . Close ( ) } 
func ( c * cache ) Items ( ) map [ string ] Item { c . mu . RLock ( ) defer c . mu . RUnlock ( ) m := make ( map [ string ] Item , len ( c . items ) ) now := time . Now ( ) . UnixNano ( ) for k , v := range c . items { } } m [ k ] = v } return m } 
func ( c * cache ) ItemCount ( ) int { c . mu . RLock ( ) n := len ( c . items ) c . mu . RUnlock ( ) return n } 
func ( c * cache ) Flush ( ) { c . mu . Lock ( ) c . items = map [ string ] Item { } c . mu . Unlock ( ) } 
func New ( defaultExpiration , cleanupInterval time . Duration ) * Cache { items := make ( map [ string ] Item ) return newCacheWithJanitor ( defaultExpiration , cleanupInterval , items ) } 
func NewFrom ( defaultExpiration , cleanupInterval time . Duration , items map [ string ] Item ) * Cache { return newCacheWithJanitor ( defaultExpiration , cleanupInterval , items ) } 
func djb33 ( seed uint32 , k string ) uint32 { var ( l = uint32 ( len ( k ) ) d = 5381 + seed + l i = uint32 ( 0 ) ) d = ( d * 33 ) ^ uint32 ( k [ i + 1 ] ) d = ( d * 33 ) ^ uint32 ( k [ i + 2 ] ) d = ( d * 33 ) ^ uint32 ( k [ i + 3 ] ) i += 4 } } switch l - i { case 1 : case 2 : d = ( d * 33 ) ^ uint32 ( k [ i ] ) case 3 : d = ( d * 33 ) ^ uint32 ( k [ i ] ) d = ( d * 33 ) ^ uint32 ( k [ i + 1 ] ) case 4 : d = ( d * 33 ) ^ uint32 ( k [ i ] ) d = ( d * 33 ) ^ uint32 ( k [ i + 1 ] ) d = ( d * 33 ) ^ uint32 ( k [ i + 2 ] ) } return d ^ ( d >> 16 ) } 
func ( sc * shardedCache ) Items ( ) [ ] map [ string ] Item { res := make ( [ ] map [ string ] Item , len ( sc . cs ) ) for i , v := range sc . cs { res [ i ] = v . Items ( ) } return res } 
func ( NetLinkClient ) LinkByName ( name string ) ( netlink . Link , error ) { return netlink . LinkByName ( name ) } 
func NewMockTaskEngine ( ctrl * gomock . Controller ) * MockTaskEngine { mock := & MockTaskEngine { ctrl : ctrl } mock . recorder = & MockTaskEngineMockRecorder { mock } return mock } 
func ( m * MockTaskEngine ) AddTask ( arg0 * task . Task ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockTaskEngineMockRecorder ) AddTask ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskEngine ) ( nil ) . AddTask ) , arg0 ) } 
func ( m * MockTaskEngine ) GetTaskByArn ( arg0 string ) ( * task . Task , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * task . Task ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockTaskEngine ) Init ( arg0 context . Context ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockTaskEngine ) ListTasks ( ) ( [ ] * task . Task , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] * task . Task ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockTaskEngine ) MarshalJSON ( ) ( [ ] byte , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] byte ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockTaskEngine ) MustInit ( arg0 context . Context ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngine ) SetSaver ( arg0 statemanager . Saver ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngine ) StateChangeEvents ( ) chan statechange . Event { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( chan statechange . Event ) return ret0 } 
func ( m * MockTaskEngine ) Version ( ) ( string , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockTaskEngineMockRecorder ) Version ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskEngine ) ( nil ) . Version ) ) } 
func NewMockImageManager ( ctrl * gomock . Controller ) * MockImageManager { mock := & MockImageManager { ctrl : ctrl } mock . recorder = & MockImageManagerMockRecorder { mock } return mock } 
func ( m * MockImageManager ) AddAllImageStates ( arg0 [ ] * image . ImageState ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockImageManagerMockRecorder ) AddAllImageStates ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockImageManager ) ( nil ) . AddAllImageStates ) , arg0 ) } 
func ( m * MockImageManager ) GetImageStateFromImageName ( arg0 string ) ( * image . ImageState , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * image . ImageState ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockImageManager ) RecordContainerReference ( arg0 * container . Container ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockImageManager ) SetSaver ( arg0 statemanager . Saver ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockImageManager ) StartImageCleanupProcess ( arg0 context . Context ) { m . ctrl . Call ( m , " " , arg0 ) } 
func NewEC2MetadataClient ( client HttpClient ) EC2MetadataClient { if client == nil { return & ec2MetadataClientImpl { client : ec2metadata . New ( session . New ( ) , aws . NewConfig ( ) . WithMaxRetries ( metadataRetries ) ) , } } else { return & ec2MetadataClientImpl { client : client } } } 
func ( c * ec2MetadataClientImpl ) DefaultCredentials ( ) ( * RoleCredentials , error ) { securityCredential , err := c . client . GetMetadata ( SecurityCrednetialsResource ) if err != nil { return nil , err } securityCredentialList := strings . Split ( strings . TrimSpace ( securityCredential ) , " \n " ) if len ( securityCredentialList ) == 0 { return nil , errors . New ( " " ) } defaultCredentialName := securityCredentialList [ 0 ] defaultCredentialStr , err := c . client . GetMetadata ( SecurityCrednetialsResource + defaultCredentialName ) if err != nil { return nil , err } var credential RoleCredentials err = json . Unmarshal ( [ ] byte ( defaultCredentialStr ) , & credential ) if err != nil { return nil , err } return & credential , nil } 
func ( c * ec2MetadataClientImpl ) GetDynamicData ( path string ) ( string , error ) { return c . client . GetDynamicData ( path ) } 
func ( c * ec2MetadataClientImpl ) GetMetadata ( path string ) ( string , error ) { return c . client . GetMetadata ( path ) } 
func ( c * ec2MetadataClientImpl ) VPCID ( mac string ) ( string , error ) { return c . client . GetMetadata ( fmt . Sprintf ( VPCIDResourceFormat , mac ) ) } 
func ( c * ec2MetadataClientImpl ) SubnetID ( mac string ) ( string , error ) { return c . client . GetMetadata ( fmt . Sprintf ( SubnetIDResourceFormat , mac ) ) } 
func newRefreshCredentialsHandler ( ctx context . Context , cluster string , containerInstanceArn string , acsClient wsclient . ClientServer , credentialsManager credentials . Manager , taskEngine engine . TaskEngine ) refreshCredentialsHandler { return refreshCredentialsHandler { messageBuffer : make ( chan * ecsacs . IAMRoleCredentialsMessage ) , ackRequest : make ( chan * ecsacs . IAMRoleCredentialsAckRequest ) , ctx : derivedContext , cancel : cancel , cluster : aws . String ( cluster ) , containerInstance : aws . String ( containerInstanceArn ) , acsClient : acsClient , credentialsManager : credentialsManager , taskEngine : taskEngine , } } 
func ( refreshHandler * refreshCredentialsHandler ) handlerFunc ( ) func ( message * ecsacs . IAMRoleCredentialsMessage ) { } } 
func ( refreshHandler * refreshCredentialsHandler ) sendAcks ( ) { for { select { case ack := <- refreshHandler . ackRequest : refreshHandler . ackMessage ( ack ) case <- refreshHandler . ctx . Done ( ) : return } } } 
func ( refreshHandler * refreshCredentialsHandler ) ackMessage ( ack * ecsacs . IAMRoleCredentialsAckRequest ) { err := refreshHandler . acsClient . MakeRequest ( ack ) if err != nil { seelog . Warnf ( " " , aws . StringValue ( ack . MessageId ) , err ) } seelog . Debugf ( " " , ack . String ( ) ) } 
func ( refreshHandler * refreshCredentialsHandler ) handleMessages ( ) { for { select { case message := <- refreshHandler . messageBuffer : refreshHandler . handleSingleMessage ( message ) case <- refreshHandler . ctx . Done ( ) : return } } } 
func ( refreshHandler * refreshCredentialsHandler ) handleSingleMessage ( message * ecsacs . IAMRoleCredentialsMessage ) error { if err != nil { seelog . Errorf ( " " , err ) return err } taskArn := aws . StringValue ( message . TaskArn ) messageId := aws . StringValue ( message . MessageId ) task , ok := refreshHandler . taskEngine . GetTaskByArn ( taskArn ) if ! ok { seelog . Errorf ( " " , taskArn , messageId ) return fmt . Errorf ( " " , taskArn ) } roleType := aws . StringValue ( message . RoleType ) if ! validRoleType ( roleType ) { seelog . Errorf ( " " , roleType , taskArn , messageId ) } else { err = refreshHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : taskArn , IAMRoleCredentials : credentials . IAMRoleCredentialsFromACS ( message . RoleCredentials , roleType ) , } ) ) if err != nil { seelog . Errorf ( " " , err , messageId ) return fmt . Errorf ( " " , err ) } if roleType == credentials . ApplicationRoleType { task . SetCredentialsID ( aws . StringValue ( message . RoleCredentials . CredentialsId ) ) } if roleType == credentials . ExecutionRoleType { task . SetExecutionRoleCredentialsID ( aws . StringValue ( message . RoleCredentials . CredentialsId ) ) } } go func ( ) { response := & ecsacs . IAMRoleCredentialsAckRequest { Expiration : message . RoleCredentials . Expiration , MessageId : message . MessageId , CredentialsId : message . RoleCredentials . CredentialsId , } refreshHandler . ackRequest <- response } ( ) return nil } 
func validateIAMRoleCredentialsMessage ( message * ecsacs . IAMRoleCredentialsMessage ) error { if message == nil { return fmt . Errorf ( " " ) } messageId := aws . StringValue ( message . MessageId ) if messageId == " " { return fmt . Errorf ( " " ) } if aws . StringValue ( message . TaskArn ) == " " { return fmt . Errorf ( " " ) } if message . RoleCredentials == nil { return fmt . Errorf ( " " , messageId ) } if aws . StringValue ( message . RoleCredentials . CredentialsId ) == " " { return fmt . Errorf ( " " , messageId ) } return nil } 
func validRoleType ( roleType string ) bool { switch roleType { case credentials . ApplicationRoleType : return true case credentials . ExecutionRoleType : return true default : return false } } 
func ( ae * acsError ) NewError ( err interface { } ) * wsclient . WSError { return & wsclient . WSError { ErrObj : err , Type : errType , WSUnretriableErrors : & ACSUnretriableErrors { } } } 
func newPayloadRequestHandler ( ctx context . Context , taskEngine engine . TaskEngine , ecsClient api . ECSClient , cluster string , containerInstanceArn string , acsClient wsclient . ClientServer , saver statemanager . Saver , refreshHandler refreshCredentialsHandler , credentialsManager credentials . Manager , taskHandler * eventhandler . TaskHandler ) payloadRequestHandler { return payloadRequestHandler { messageBuffer : make ( chan * ecsacs . PayloadMessage , payloadMessageBufferSize ) , ackRequest : make ( chan string , payloadMessageBufferSize ) , taskEngine : taskEngine , ecsClient : ecsClient , saver : saver , taskHandler : taskHandler , ctx : derivedContext , cancel : cancel , cluster : cluster , containerInstanceArn : containerInstanceArn , acsClient : acsClient , refreshHandler : refreshHandler , credentialsManager : credentialsManager , } } 
func ( payloadHandler * payloadRequestHandler ) handlerFunc ( ) func ( payload * ecsacs . PayloadMessage ) { } } 
func ( payloadHandler * payloadRequestHandler ) sendAcks ( ) { for { select { case mid := <- payloadHandler . ackRequest : payloadHandler . ackMessageId ( mid ) case <- payloadHandler . ctx . Done ( ) : return } } } 
func ( payloadHandler * payloadRequestHandler ) ackMessageId ( messageID string ) { seelog . Debugf ( " " , messageID ) err := payloadHandler . acsClient . MakeRequest ( & ecsacs . AckRequest { Cluster : aws . String ( payloadHandler . cluster ) , ContainerInstance : aws . String ( payloadHandler . containerInstanceArn ) , MessageId : aws . String ( messageID ) , } ) if err != nil { seelog . Warnf ( " " , messageID , err ) } } 
func ( payloadHandler * payloadRequestHandler ) handleMessages ( ) { for { select { case payload := <- payloadHandler . messageBuffer : payloadHandler . handleSingleMessage ( payload ) case <- payloadHandler . ctx . Done ( ) : return } } } 
func ( payloadHandler * payloadRequestHandler ) handleSingleMessage ( payload * ecsacs . PayloadMessage ) error { if aws . StringValue ( payload . MessageId ) == " " { seelog . Criticalf ( " " ) return fmt . Errorf ( " " ) } seelog . Debugf ( " " , aws . StringValue ( payload . MessageId ) ) credentialsAcks , allTasksHandled := payloadHandler . addPayloadTasks ( payload ) if err != nil { seelog . Errorf ( " " , err , aws . StringValue ( payload . MessageId ) ) } if ! allTasksHandled { return fmt . Errorf ( " " ) } go func ( ) { } payloadHandler . ackRequest <- * payload . MessageId } ( ) return nil } 
func ( payloadHandler * payloadRequestHandler ) addPayloadTasks ( payload * ecsacs . PayloadMessage ) ( [ ] * ecsacs . IAMRoleCredentialsAckRequest , bool ) { validTasks := make ( [ ] * apitask . Task , 0 , len ( payload . Tasks ) ) for _ , task := range payload . Tasks { if task == nil { seelog . Criticalf ( " " , aws . StringValue ( payload . MessageId ) ) allTasksOK = false continue } apiTask , err := apitask . TaskFromACS ( task , payload ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } if task . RoleCredentials != nil { err = payloadHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : aws . StringValue ( task . Arn ) , IAMRoleCredentials : taskIAMRoleCredentials , } ) ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetCredentialsID ( taskIAMRoleCredentials . CredentialsID ) } if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetTaskENI ( eni ) } if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetAppMesh ( appmesh ) } if task . ExecutionRoleCredentials != nil { err = payloadHandler . credentialsManager . SetTaskCredentials ( & ( credentials . TaskIAMRoleCredentials { ARN : aws . StringValue ( task . Arn ) , IAMRoleCredentials : taskExecutionIAMRoleCredentials , } ) ) if err != nil { payloadHandler . handleUnrecognizedTask ( task , err , payload ) allTasksOK = false continue } apiTask . SetExecutionRoleCredentialsID ( taskExecutionIAMRoleCredentials . CredentialsID ) } validTasks = append ( validTasks , apiTask ) } newTasksCredentialsAcks , newTasksAddedOK := payloadHandler . addTasks ( payload , validTasks , isTaskStatusStopped ) if ! stoppedTasksAddedOK || ! newTasksAddedOK { allTasksOK = false } credentialsAcks = append ( stoppedTasksCredentialsAcks , newTasksCredentialsAcks ... ) return credentialsAcks , allTasksOK } 
func ( payloadHandler * payloadRequestHandler ) addTasks ( payload * ecsacs . PayloadMessage , tasks [ ] * apitask . Task , skipAddTask skipAddTaskComparatorFunc ) ( [ ] * ecsacs . IAMRoleCredentialsAckRequest , bool ) { allTasksOK := true var credentialsAcks [ ] * ecsacs . IAMRoleCredentialsAckRequest for _ , task := range tasks { if skipAddTask ( task . GetDesiredStatus ( ) ) { continue } payloadHandler . taskEngine . AddTask ( task ) ackCredentials := func ( id string , description string ) { ack , err := payloadHandler . ackCredentials ( payload . MessageId , id ) if err != nil { allTasksOK = false seelog . Errorf ( " " , description , task . String ( ) , err ) return } credentialsAcks = append ( credentialsAcks , ack ) } if taskCredentialsID != " " { ackCredentials ( taskCredentialsID , " " ) } taskExecutionCredentialsID := task . GetExecutionCredentialsID ( ) if taskExecutionCredentialsID != " " { ackCredentials ( taskExecutionCredentialsID , " " ) } } return credentialsAcks , allTasksOK } 
func ( payloadHandler * payloadRequestHandler ) handleUnrecognizedTask ( task * ecsacs . Task , err error , payload * ecsacs . PayloadMessage ) { seelog . Warnf ( " " , aws . StringValue ( payload . MessageId ) , aws . StringValue ( task . Arn ) , err ) if aws . StringValue ( task . Arn ) == " " { seelog . Criticalf ( " " , aws . StringValue ( payload . MessageId ) ) return } payloadHandler . taskHandler . AddStateChangeEvent ( taskEvent , payloadHandler . ecsClient ) } 
func BuildTypeDecoder ( recognizedTypes [ ] interface { } ) TypeDecoder { typeMappings := make ( map [ string ] reflect . Type ) for _ , recognizedType := range recognizedTypes { typeMappings [ reflect . TypeOf ( recognizedType ) . Name ( ) ] = reflect . TypeOf ( recognizedType ) } return & TypeDecoderImpl { typeMappings : typeMappings } } 
func v2HandlersSetup ( muxRouter * mux . Router , state dockerstate . TaskEngineState , ecsClient api . ECSClient , statsEngine stats . Engine , cluster string , credentialsManager credentials . Manager , auditLogger audit . AuditLogger , availabilityZone string , containerInstanceArn string ) { muxRouter . HandleFunc ( v2 . CredentialsPath , v2 . CredentialsHandler ( credentialsManager , auditLogger ) ) muxRouter . HandleFunc ( v2 . ContainerMetadataPath , v2 . TaskContainerMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , false ) ) muxRouter . HandleFunc ( v2 . TaskMetadataPath , v2 . TaskContainerMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , false ) ) muxRouter . HandleFunc ( v2 . TaskWithTagsMetadataPath , v2 . TaskContainerMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , true ) ) muxRouter . HandleFunc ( v2 . TaskMetadataPathWithSlash , v2 . TaskContainerMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , false ) ) muxRouter . HandleFunc ( v2 . TaskWithTagsMetadataPathWithSlash , v2 . TaskContainerMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , true ) ) muxRouter . HandleFunc ( v2 . ContainerStatsPath , v2 . TaskContainerStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v2 . TaskStatsPath , v2 . TaskContainerStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v2 . TaskStatsPathWithSlash , v2 . TaskContainerStatsHandler ( state , statsEngine ) ) } 
func v3HandlersSetup ( muxRouter * mux . Router , state dockerstate . TaskEngineState , ecsClient api . ECSClient , statsEngine stats . Engine , cluster string , availabilityZone string , containerInstanceArn string ) { muxRouter . HandleFunc ( v3 . ContainerMetadataPath , v3 . ContainerMetadataHandler ( state ) ) muxRouter . HandleFunc ( v3 . TaskMetadataPath , v3 . TaskMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , false ) ) muxRouter . HandleFunc ( v3 . TaskWithTagsMetadataPath , v3 . TaskMetadataHandler ( state , ecsClient , cluster , availabilityZone , containerInstanceArn , true ) ) muxRouter . HandleFunc ( v3 . ContainerStatsPath , v3 . ContainerStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v3 . TaskStatsPath , v3 . TaskStatsHandler ( state , statsEngine ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationsPath , v3 . ContainerAssociationsHandler ( state ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationPathWithSlash , v3 . ContainerAssociationHandler ( state ) ) muxRouter . HandleFunc ( v3 . ContainerAssociationPath , v3 . ContainerAssociationHandler ( state ) ) } 
func ServeTaskHTTPEndpoint ( credentialsManager credentials . Manager , state dockerstate . TaskEngineState , ecsClient api . ECSClient , containerInstanceArn string , cfg * config . Config , statsEngine stats . Engine , availabilityZone string ) { if err != nil { seelog . Errorf ( " " , err ) } auditLogger := audit . NewAuditLog ( containerInstanceArn , cfg , logger ) server := taskServerSetup ( credentialsManager , auditLogger , state , ecsClient , cfg . Cluster , statsEngine , cfg . TaskMetadataSteadyStateRate , cfg . TaskMetadataBurstRate , availabilityZone , containerInstanceArn ) for { retry . RetryWithBackoff ( retry . NewExponentialBackoff ( time . Second , time . Minute , 0.2 , 2 ) , func ( ) error { if err != nil { seelog . Errorf ( " " , err ) } return err } ) } } 
func AgentMetadataHandler ( containerInstanceArn * string , cfg * config . Config ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { resp := & MetadataResponse { Cluster : cfg . Cluster , ContainerInstanceArn : containerInstanceArn , Version : agentversion . String ( ) , } responseJSON , _ := json . Marshal ( resp ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeAgentMetadata ) } } 
func NewMockProvider ( ctrl * gomock . Controller ) * MockProvider { mock := & MockProvider { ctrl : ctrl } mock . recorder = & MockProviderMockRecorder { mock } return mock } 
func ( m * MockProvider ) IsExpired ( ) bool { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( mr * MockProviderMockRecorder ) IsExpired ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockProvider ) ( nil ) . IsExpired ) ) } 
func ( m * MockProvider ) Retrieve ( ) ( credentials . Value , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( credentials . Value ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockContainerMetadataResolver ( ctrl * gomock . Controller ) * MockContainerMetadataResolver { mock := & MockContainerMetadataResolver { ctrl : ctrl } mock . recorder = & MockContainerMetadataResolverMockRecorder { mock } return mock } 
func ( m * MockContainerMetadataResolver ) ResolveContainer ( arg0 string ) ( * container . DockerContainer , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * container . DockerContainer ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockContainerMetadataResolverMockRecorder ) ResolveContainer ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockContainerMetadataResolver ) ( nil ) . ResolveContainer ) , arg0 ) } 
func ( m * MockContainerMetadataResolver ) ResolveTask ( arg0 string ) ( * task . Task , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * task . Task ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewSensitiveRawMessage ( data json . RawMessage ) * SensitiveRawMessage { if len ( data ) == 0 { return nil } return & SensitiveRawMessage { contents : data } } 
func NewTaskResponse ( taskARN string , state dockerstate . TaskEngineState , ecsClient api . ECSClient , cluster string , az string , containerInstanceArn string , propagateTags bool ) ( * TaskResponse , error ) { task , ok := state . TaskByArn ( taskARN ) if ! ok { return nil , errors . Errorf ( " " , taskARN ) } resp := & TaskResponse { Cluster : cluster , TaskARN : task . Arn , Family : task . Family , Revision : task . Version , DesiredStatus : task . GetDesiredStatus ( ) . String ( ) , KnownStatus : task . GetKnownStatus ( ) . String ( ) , AvailabilityZone : az , } taskCPU := task . CPU taskMemory := task . Memory if taskCPU != 0 || taskMemory != 0 { taskLimits := & LimitsResponse { } if taskCPU != 0 { taskLimits . CPU = & taskCPU } if taskMemory != 0 { taskLimits . Memory = & taskMemory } resp . Limits = taskLimits } if timestamp := task . GetPullStartedAt ( ) ; ! timestamp . IsZero ( ) { resp . PullStartedAt = aws . Time ( timestamp . UTC ( ) ) } if timestamp := task . GetPullStoppedAt ( ) ; ! timestamp . IsZero ( ) { resp . PullStoppedAt = aws . Time ( timestamp . UTC ( ) ) } if timestamp := task . GetExecutionStoppedAt ( ) ; ! timestamp . IsZero ( ) { resp . ExecutionStoppedAt = aws . Time ( timestamp . UTC ( ) ) } containerNameToDockerContainer , ok := state . ContainerMapByArn ( task . Arn ) if ! ok { seelog . Warnf ( " " , task . Arn ) return resp , nil } eni := task . GetTaskENI ( ) for _ , dockerContainer := range containerNameToDockerContainer { containerResponse := newContainerResponse ( dockerContainer , eni , state ) resp . Containers = append ( resp . Containers , containerResponse ) } if propagateTags { propagateTagsToMetadata ( state , ecsClient , containerInstanceArn , taskARN , resp ) } return resp , nil } 
func NewContainerResponse ( containerID string , state dockerstate . TaskEngineState ) ( * ContainerResponse , error ) { dockerContainer , ok := state . ContainerByID ( containerID ) if ! ok { return nil , errors . Errorf ( " " , containerID ) } task , ok := state . TaskByID ( containerID ) if ! ok { return nil , errors . Errorf ( " " , containerID ) } resp := newContainerResponse ( dockerContainer , task . GetTaskENI ( ) , state ) return & resp , nil } 
func New ( arguments [ ] string ) ( * Args , error ) { flagset := flag . NewFlagSet ( " " , flag . ContinueOnError ) args := & Args { Version : flagset . Bool ( versionFlagName , false , versionUsage ) , LogLevel : flagset . String ( logLevelFlagName , " " , logLevelUsage ) , AcceptInsecureCert : flagset . Bool ( acceptInsecureCertFlagName , false , acceptInsecureCertUsage ) , License : flagset . Bool ( licenseFlagName , false , licenseUsage ) , BlackholeEC2Metadata : flagset . Bool ( blackholeEC2MetadataFlagName , false , blacholeEC2MetadataUsage ) , ECSAttributes : flagset . Bool ( ecsAttributesFlagName , false , ecsAttributesUsage ) , WindowsService : flagset . Bool ( windowsServiceFlagName , false , windowsServiceUsage ) , } err := flagset . Parse ( arguments ) if err != nil { return nil , err } return args , nil } 
func DefaultConfig ( ) Config { programData := utils . DefaultIfBlank ( os . Getenv ( " " ) , `C:\ProgramData` ) ecsRoot := filepath . Join ( programData , " " , " " ) dataDir := filepath . Join ( ecsRoot , " " ) platformVariables := PlatformVariables { CPUUnbounded : false , } return Config { DockerEndpoint : " " , ReservedPorts : [ ] uint16 { DockerReservedPort , DockerReservedSSLPort , AgentIntrospectionPort , AgentCredentialsPort , rdpPort , rpcPort , smbPort , winRMPortHTTP , winRMPortHTTPS , dnsPort , netBIOSPort , } , ReservedPortsUDP : [ ] uint16 { } , DataDir : dataDir , } 
func New ( timeout time . Duration , insecureSkipVerify bool ) * http . Client { transport . TLSClientConfig = & tls . Config { } cipher . WithSupportedCipherSuites ( transport . TLSClientConfig ) transport . TLSClientConfig . InsecureSkipVerify = insecureSkipVerify client := & http . Client { Transport : & ecsRoundTripper { insecureSkipVerify , transport } , Timeout : timeout , } return client } 
func RemoveFromTaskArray ( arr [ ] * Task , ndx int ) [ ] * Task { if ndx < 0 || ndx >= len ( arr ) { return arr } return append ( arr [ 0 : ndx ] , arr [ ndx + 1 : ] ... ) } 
func ( task * Task ) adjustForPlatform ( cfg * config . Config ) { task . downcaseAllVolumePaths ( ) platformFields := PlatformFields { CpuUnbounded : cfg . PlatformVariables . CPUUnbounded , } task . PlatformFields = platformFields } 
func ( task * Task ) downcaseAllVolumePaths ( ) { for _ , volume := range task . Volumes { if hostVol , ok := volume . Volume . ( * taskresourcevolume . FSHostVolume ) ; ok { hostVol . FSSourcePath = getCanonicalPath ( hostVol . FSSourcePath ) } } for _ , container := range task . Containers { for i , mountPoint := range container . MountPoints { } } } 
func ( task * Task ) platformHostConfigOverride ( hostConfig * dockercontainer . HostConfig ) error { if hostConfig . CPUPercent == 0 && hostConfig . CPUShares != 0 { } hostConfig . CPUShares = 0 return nil } 
func ( eni * ENIAttachmentStatus ) String ( ) string { for k , v := range eniAttachmentStatusMap { if v == * eni { return k } } return " " } 
func _main ( ) int { var typesOnly bool flag . BoolVar ( & typesOnly , " " , false , " " ) flag . Parse ( ) apiFile := " " var err error if typesOnly { err = genTypesOnlyAPI ( apiFile ) } else { err = genFull ( apiFile ) } if err != nil { fmt . Println ( err ) return 1 } return 0 } 
func newSubmitStateChangeClient ( awsConfig * aws . Config ) * ecs . ECS { sscConfig := awsConfig . Copy ( ) sscConfig . Retryer = & oneDayRetrier { } client := ecs . New ( session . New ( sscConfig ) ) return client } 
func ( retrier * oneDayRetrier ) RetryRules ( r * request . Request ) time . Duration { return time . Duration ( delay ) * time . Millisecond } return 5 * time . Minute } 
func ( vs VolumeStatus ) String ( ) string { for k , v := range resourceStatusMap { if v == vs { return k } } return " " } 
func ( vs * VolumeStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if vs == nil { return nil , nil } return [ ] byte ( `"` + vs . String ( ) + `"` ) , nil } 
func ( vs * VolumeStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * vs = VolumeStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * vs = VolumeStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) stat , ok := resourceStatusMap [ strStatus ] if ! ok { * vs = VolumeStatusNone return errors . New ( " " ) } * vs = stat return nil } 
func NewMockTime ( ctrl * gomock . Controller ) * MockTime { mock := & MockTime { ctrl : ctrl } mock . recorder = & MockTimeMockRecorder { mock } return mock } 
func ( m * MockTime ) After ( arg0 time . Duration ) <- chan time . Time { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( <- chan time . Time ) return ret0 } 
func ( m * MockTime ) AfterFunc ( arg0 time . Duration , arg1 func ( ) ) ttime . Timer { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( ttime . Timer ) return ret0 } 
func ( m * MockTime ) Now ( ) time . Time { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( time . Time ) return ret0 } 
func ( mr * MockTimeMockRecorder ) Now ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTime ) ( nil ) . Now ) ) } 
func ( m * MockTime ) Sleep ( arg0 time . Duration ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockTimeMockRecorder ) Sleep ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTime ) ( nil ) . Sleep ) , arg0 ) } 
func NewMockTimer ( ctrl * gomock . Controller ) * MockTimer { mock := & MockTimer { ctrl : ctrl } mock . recorder = & MockTimerMockRecorder { mock } return mock } 
func ( m * MockTimer ) Reset ( arg0 time . Duration ) bool { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( mr * MockTimerMockRecorder ) Reset ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTimer ) ( nil ) . Reset ) , arg0 ) } 
func ( m * MockTimer ) Stop ( ) bool { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( mr * MockTimerMockRecorder ) Stop ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTimer ) ( nil ) . Stop ) ) } 
func AddAgentUpdateHandlers ( cs wsclient . ClientServer , cfg * config . Config , saver statemanager . Saver , taskEngine engine . TaskEngine ) { singleUpdater := & updater { acs : cs , config : cfg , fs : os . Default , httpclient : httpclient . New ( updateDownloadTimeout , false ) , } cs . AddRequestHandler ( singleUpdater . stageUpdateHandler ( ) ) cs . AddRequestHandler ( singleUpdater . performUpdateHandler ( saver , taskEngine ) ) } 
func NewDockerGoClient ( sdkclientFactory sdkclientfactory . Factory , cfg * config . Config , ctx context . Context ) ( DockerClient , error ) { if err != nil { seelog . Errorf ( " " + " " , err ) return nil , err } if err != nil { seelog . Errorf ( " " + " " , err ) return nil , err } var dockerAuthData json . RawMessage if cfg . EngineAuthData != nil { dockerAuthData = cfg . EngineAuthData . Contents ( ) } return & dockerGoClient { sdkClientFactory : sdkclientFactory , auth : dockerauth . NewDockerAuthProvider ( cfg . EngineAuthType , dockerAuthData ) , ecrClientFactory : ecr . NewECRFactory ( cfg . AcceptInsecureCert ) , ecrTokenCache : async . NewLRUCache ( tokenCacheSize , tokenCacheTTL ) , config : cfg , context : ctx , imagePullBackoff : retry . NewExponentialBackoff ( minimumPullRetryDelay , maximumPullRetryDelay , pullRetryJitterMultiplier , pullRetryDelayMultiplier ) , } , nil } 
func ( dg * dockerGoClient ) sdkDockerClient ( ) ( sdkclient . Client , error ) { if dg . version == " " { return dg . sdkClientFactory . GetDefaultClient ( ) } return dg . sdkClientFactory . GetClient ( dg . version ) } 
func DockerStateToState ( state * types . ContainerState ) apicontainerstatus . ContainerStatus { if state . Running { return apicontainerstatus . ContainerRunning } if state . Dead { return apicontainerstatus . ContainerStopped } if startTime . IsZero ( ) && state . Error == " " { return apicontainerstatus . ContainerCreated } return apicontainerstatus . ContainerStopped } 
func MetadataFromContainer ( dockerContainer * types . ContainerJSON ) DockerContainerMetadata { var bindings [ ] apicontainer . PortBinding var err apierrors . NamedError if dockerContainer . NetworkSettings != nil { if err != nil { seelog . Criticalf ( " " , err ) return DockerContainerMetadata { Error : apierrors . NamedError ( err ) } } } createdTime , _ := time . Parse ( time . RFC3339 , dockerContainer . Created ) startedTime := time . Time { } finishedTime := time . Time { } finishedTime , _ = time . Parse ( time . RFC3339 , dockerContainer . State . FinishedAt ) } metadata := DockerContainerMetadata { DockerID : dockerContainer . ID , PortBindings : bindings , Volumes : dockerContainer . Mounts , CreatedAt : createdTime , StartedAt : startedTime , FinishedAt : finishedTime , } if dockerContainer . NetworkSettings != nil { metadata . NetworkSettings = dockerContainer . NetworkSettings } if dockerContainer . HostConfig != nil { metadata . NetworkMode = string ( dockerContainer . HostConfig . NetworkMode ) } if dockerContainer . Config != nil { metadata . Labels = dockerContainer . Config . Labels } if dockerContainer . State == nil { return metadata } if ! dockerContainer . State . Running && ! finishedTime . IsZero ( ) { } if dockerContainer . State . Error != " " { metadata . Error = NewDockerStateError ( dockerContainer . State . Error ) } if dockerContainer . State . OOMKilled { metadata . Error = OutOfMemoryError { } } } return metadata } 
func ( dg * dockerGoClient ) ContainerEvents ( ctx context . Context ) ( <- chan DockerContainerChangeEvent , error ) { client , err := dg . sdkDockerClient ( ) if err != nil { return nil , err } events := make ( chan * events . Message ) buffer := NewInfiniteBuffer ( ) derivedCtx , cancel := context . WithCancel ( ctx ) dockerEvents , eventErr := client . Events ( derivedCtx , types . EventsOptions { } ) cancel ( ) return } else { nextCtx , nextCancel := context . WithCancel ( ctx ) dockerEvents , eventErr = client . Events ( nextCtx , types . EventsOptions { } ) } case <- ctx . Done ( ) : return } } } ( ) changedContainers := make ( chan DockerContainerChangeEvent ) go dg . handleContainerEvents ( ctx , events , changedContainers ) return changedContainers , nil } 
func ( dg * dockerGoClient ) ListContainers ( ctx context . Context , all bool , timeout time . Duration ) ListContainersResponse { ctx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) go func ( ) { response <- dg . listContainers ( ctx , all ) } ( ) select { case resp := <- response : return resp case <- ctx . Done ( ) : if err == context . DeadlineExceeded { return ListContainersResponse { Error : & DockerTimeoutError { timeout , " " } } } return ListContainersResponse { Error : & CannotListContainersError { err } } } } 
func ( dg * dockerGoClient ) ListPluginsWithFilters ( ctx context . Context , enabled bool , capabilities [ ] string , timeout time . Duration ) ( [ ] string , error ) { for _ , capability := range capabilities { filterList . Add ( " " , capability ) } var filteredPluginNames [ ] string response := dg . ListPlugins ( ctx , timeout , filterList ) if response . Error != nil { return nil , response . Error } } return filteredPluginNames , nil } 
func ( dg * dockerGoClient ) APIVersion ( ) ( dockerclient . DockerVersion , error ) { client , err := dg . sdkDockerClient ( ) if err != nil { return " " , err } return dg . sdkClientFactory . FindClientAPIVersion ( client ) , nil } 
func ( dg * dockerGoClient ) Stats ( ctx context . Context , id string , inactivityTimeout time . Duration ) ( <- chan * types . StatsJSON , error ) { subCtx , cancelRequest := context . WithCancel ( ctx ) client , err := dg . sdkDockerClient ( ) if err != nil { cancelRequest ( ) return nil , err } var resp types . ContainerStats if ! dg . config . PollMetrics { go func ( ) { defer cancelRequest ( ) defer close ( statsChnl ) resp , err = client . ContainerStats ( subCtx , id , stream ) if err != nil { seelog . Warnf ( " " , id , err ) return } var ch chan <- struct { } resp . Body , ch = handleInactivityTimeout ( resp . Body , inactivityTimeout , cancelRequest , & canceled ) defer resp . Body . Close ( ) defer close ( ch ) data := new ( types . StatsJSON ) for err := decoder . Decode ( data ) ; err != io . EOF ; err = decoder . Decode ( data ) { if err != nil { seelog . Warnf ( " " , id , err ) return } if atomic . LoadUint32 ( & canceled ) != 0 { seelog . Warnf ( " " , id ) return } statsChnl <- data data = new ( types . StatsJSON ) } } ( ) } else { seelog . Infof ( " " , id ) statPollTicker := time . NewTicker ( dg . config . PollingMetricsWaitDuration ) go func ( ) { defer cancelRequest ( ) defer close ( statsChnl ) defer statPollTicker . Stop ( ) for range statPollTicker . C { resp , err = client . ContainerStats ( subCtx , id , stream ) if err != nil { seelog . Warnf ( " " , id , err ) return } data := new ( types . StatsJSON ) err := decoder . Decode ( data ) if err != nil { seelog . Warnf ( " " , id , err ) return } statsChnl <- data data = new ( types . StatsJSON ) } } ( ) } return statsChnl , nil } 
func ( dg * dockerGoClient ) LoadImage ( ctx context . Context , inputStream io . Reader , timeout time . Duration ) error { ctx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) defer metrics . MetricsEngineGlobal . RecordDockerMetric ( " " ) ( ) response := make ( chan error , 1 ) go func ( ) { response <- dg . loadImage ( ctx , inputStream ) } ( ) select { case resp := <- response : return resp case <- ctx . Done ( ) : return & DockerTimeoutError { timeout , " " } } } 
func ( imageState * ImageState ) UpdateContainerReference ( container * apicontainer . Container ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) seelog . Infof ( " " , container . Name , imageState . Image . ImageID ) imageState . Containers = append ( imageState . Containers , container ) } 
func ( imageState * ImageState ) AddImageName ( imageName string ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) if ! imageState . HasImageName ( imageName ) { seelog . Infof ( " " , imageName , imageState . Image . ImageID ) imageState . Image . Names = append ( imageState . Image . Names , imageName ) } } 
func ( imageState * ImageState ) GetImageNamesCount ( ) int { imageState . lock . RLock ( ) defer imageState . lock . RUnlock ( ) return len ( imageState . Image . Names ) } 
func ( imageState * ImageState ) UpdateImageState ( container * apicontainer . Container ) { imageState . AddImageName ( container . Image ) imageState . UpdateContainerReference ( container ) } 
func ( imageState * ImageState ) RemoveImageName ( containerImageName string ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) for i , imageName := range imageState . Image . Names { if imageName == containerImageName { imageState . Image . Names = append ( imageState . Image . Names [ : i ] , imageState . Image . Names [ i + 1 : ] ... ) } } } 
func ( imageState * ImageState ) HasImageName ( containerImageName string ) bool { for _ , imageName := range imageState . Image . Names { if imageName == containerImageName { return true } } return false } 
func ( imageState * ImageState ) RemoveContainerReference ( container * apicontainer . Container ) error { defer imageState . lock . Unlock ( ) for i := range imageState . Containers { if imageState . Containers [ i ] . Name == container . Name { imageState . Containers = append ( imageState . Containers [ : i ] , imageState . Containers [ i + 1 : ] ... ) return nil } } return fmt . Errorf ( " " , container . String ( ) ) } 
func ( imageState * ImageState ) SetPullSucceeded ( pullSucceeded bool ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) imageState . PullSucceeded = pullSucceeded } 
func ( imageState * ImageState ) GetPullSucceeded ( ) bool { imageState . lock . RLock ( ) defer imageState . lock . RUnlock ( ) return imageState . PullSucceeded } 
func ( imageState * ImageState ) MarshalJSON ( ) ( [ ] byte , error ) { imageState . lock . Lock ( ) defer imageState . lock . Unlock ( ) return json . Marshal ( & struct { Image * Image PulledAt time . Time LastUsedAt time . Time PullSucceeded bool } { Image : imageState . Image , PulledAt : imageState . PulledAt , LastUsedAt : imageState . LastUsedAt , PullSucceeded : imageState . PullSucceeded , } ) } 
func ( ts TaskStatus ) String ( ) string { for k , v := range taskStatusMap { if v == ts { return k } } return " " } 
func ( ts * TaskStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * ts = TaskStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * ts = TaskStatusNone return errors . New ( " " ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) return nil } if strStatus == " " { * ts = TaskStopped return nil } stat , ok := taskStatusMap [ strStatus ] if ! ok { * ts = TaskStatusNone return errors . New ( " " ) } * ts = stat return nil } 
func ( ts * TaskStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if ts == nil { return nil , nil } return [ ] byte ( `"` + ts . String ( ) + `"` ) , nil } 
func NewClient ( cfg * Config ) CNIClient { libcniConfig := & libcni . CNIConfig { Path : [ ] string { cfg . PluginsPath } , } return & cniClient { pluginsPath : cfg . PluginsPath , cniVersion : cfg . MinSupportedCNIVersion , subnet : ecsSubnet , libcni : libcniConfig , } } 
func ( client * cniClient ) SetupNS ( ctx context . Context , cfg * Config , timeout time . Duration ) ( * current . Result , error ) { derivedCtx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) type output struct { result * current . Result err error } response := make ( chan output ) go func ( response chan output ) { result , err := client . setupNS ( cfg ) response <- output { result : result , err : err , } } ( response ) select { case <- derivedCtx . Done ( ) : return nil , errors . Wrap ( derivedCtx . Err ( ) , " " ) case result := <- response : return result . result , result . err } } 
func ( client * cniClient ) CleanupNS ( ctx context . Context , cfg * Config , timeout time . Duration ) error { derivedCtx , cancel := context . WithTimeout ( ctx , timeout ) defer cancel ( ) err := make ( chan error ) go func ( err chan error ) { err <- client . cleanupNS ( cfg ) } ( err ) select { case <- derivedCtx . Done ( ) : return errors . Wrap ( derivedCtx . Err ( ) , " " ) case err := <- err : return err } } 
func ( client * cniClient ) ReleaseIPResource ( cfg * Config ) error { runtimeConfig := libcni . RuntimeConf { ContainerID : cfg . ContainerID , NetNS : fmt . Sprintf ( netnsFormat , cfg . ContainerPID ) , } seelog . Debugf ( " " , cfg . ID , cfg . IPAMV4Address ) os . Setenv ( " " , logger . GetLevel ( ) ) defer os . Unsetenv ( " " ) return client . del ( runtimeConfig , cfg , client . createIPAMNetworkConfig ) } 
func ( client * cniClient ) add ( runtimeConfig libcni . RuntimeConf , cfg * Config , pluginConfigFunc func ( * Config ) ( string , * libcni . NetworkConfig , error ) ) ( cnitypes . Result , error ) { deviceName , networkConfig , err := pluginConfigFunc ( cfg ) if err != nil { return nil , err } runtimeConfig . IfName = deviceName return client . libcni . AddNetwork ( networkConfig , & runtimeConfig ) } 
func ( client * cniClient ) del ( runtimeConfig libcni . RuntimeConf , cfg * Config , pluginConfigFunc func ( * Config ) ( string , * libcni . NetworkConfig , error ) ) error { deviceName , networkConfig , err := pluginConfigFunc ( cfg ) if err != nil { return err } runtimeConfig . IfName = deviceName return client . libcni . DelNetwork ( networkConfig , & runtimeConfig ) } 
func ( client * cniClient ) createBridgeNetworkConfigWithIPAM ( cfg * Config ) ( string , * libcni . NetworkConfig , error ) { if err != nil { return " " , nil , errors . Wrap ( err , " " ) } bridgeConfig . IPAM = ipamConfig networkConfig , err := client . constructNetworkConfig ( bridgeConfig , ECSBridgePluginName ) if err != nil { return " " , nil , errors . Wrap ( err , " " ) } return defaultVethName , networkConfig , nil } 
func ( client * cniClient ) createBridgeNetworkConfigWithoutIPAM ( cfg * Config ) ( string , * libcni . NetworkConfig , error ) { networkConfig , err := client . constructNetworkConfig ( client . createBridgeConfig ( cfg ) , ECSBridgePluginName ) if err != nil { return " " , nil , errors . Wrap ( err , " " ) } return defaultVethName , networkConfig , nil } 
func ( client * cniClient ) constructNetworkConfig ( cfg interface { } , plugin string ) ( * libcni . NetworkConfig , error ) { configBytes , err := json . Marshal ( cfg ) if err != nil { seelog . Errorf ( " " , plugin , err ) return nil , err } networkConfig := & libcni . NetworkConfig { Network : & cnitypes . NetConf { Type : plugin , } , Bytes : configBytes , } return networkConfig , nil } 
func ( client * cniClient ) createIPAMNetworkConfig ( cfg * Config ) ( string , * libcni . NetworkConfig , error ) { ipamConfig , err := client . createIPAMConfig ( cfg ) if err != nil { return defaultVethName , nil , errors . Wrap ( err , " " ) } ipamNetworkConfig := IPAMNetworkConfig { Name : ECSIPAMPluginName , CNIVersion : client . cniVersion , IPAM : ipamConfig , } networkConfig , err := client . constructNetworkConfig ( ipamNetworkConfig , ECSIPAMPluginName ) if err != nil { return " " , nil , errors . Wrap ( err , " " ) } return defaultVethName , networkConfig , nil } 
func ( client * cniClient ) Version ( name string ) ( string , error ) { file := filepath . Join ( client . pluginsPath , name ) if err != nil { return " " , err } cmd := exec . Command ( file , versionCommand ) versionInfo , err := cmd . Output ( ) if err != nil { return " " , err } version := & cniPluginVersion { } if err != nil { return " " , errors . Wrapf ( err , " " , versionInfo ) } return version . str ( ) , nil } 
func ( version * cniPluginVersion ) str ( ) string { ver := " " if version . Dirty { ver = " " } return ver + version . Hash + " " + version . Version } 
func ( client * cniClient ) Capabilities ( name string ) ( [ ] string , error ) { file := filepath . Join ( client . pluginsPath , name ) if err != nil { return nil , errors . Wrapf ( err , " " , file ) } cmd := exec . Command ( file , capabilitiesCommand ) capabilitiesInfo , err := cmd . Output ( ) if err != nil { return nil , errors . Wrapf ( err , " " , name ) } capabilities := & struct { Capabilities [ ] string `json:"capabilities"` } { } err = json . Unmarshal ( capabilitiesInfo , capabilities ) if err != nil { return nil , errors . Wrapf ( err , " " , name , capabilitiesInfo ) } return capabilities . Capabilities , nil } 
func ( as SSMSecretStatus ) String ( ) string { for k , v := range ssmSecretStatusMap { if v == as { return k } } return " " } 
func ( as * SSMSecretStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if as == nil { return nil , errors . New ( " " ) } return [ ] byte ( `"` + as . String ( ) + `"` ) , nil } 
func ( as * SSMSecretStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * as = SSMSecretStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * as = SSMSecretStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) stat , ok := ssmSecretStatusMap [ strStatus ] if ! ok { * as = SSMSecretStatusNone return errors . New ( " " ) } * as = stat return nil } 
func New ( ctx context . Context , primaryMAC string , udevwrap udevwrapper . Udev , state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) * UdevWatcher { return newWatcher ( ctx , primaryMAC , netlinkwrapper . New ( ) , udevwrap , state , stateChangeEvents ) } 
func newWatcher ( ctx context . Context , primaryMAC string , nlWrap netlinkwrapper . NetLink , udevWrap udevwrapper . Udev , state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) * UdevWatcher { derivedContext , cancel := context . WithCancel ( ctx ) return & UdevWatcher { ctx : derivedContext , cancel : cancel , netlinkClient : nlWrap , udevMonitor : udevWrap , events : make ( chan * udev . UEvent ) , agentState : state , eniChangeEvent : stateChangeEvents , primaryMAC : primaryMAC , } } 
func ( udevWatcher * UdevWatcher ) performPeriodicReconciliation ( updateInterval time . Duration ) { udevWatcher . updateIntervalTicker = time . NewTicker ( updateInterval ) for { select { case <- udevWatcher . updateIntervalTicker . C : if err := udevWatcher . reconcileOnce ( ) ; err != nil { log . Warnf ( " " , err ) } case <- udevWatcher . ctx . Done ( ) : udevWatcher . updateIntervalTicker . Stop ( ) return } } } 
func ( udevWatcher * UdevWatcher ) reconcileOnce ( ) error { links , err := udevWatcher . netlinkClient . LinkList ( ) if err != nil { return errors . Wrapf ( err , " " ) } return nil } currentState := udevWatcher . buildState ( links ) } } return nil } 
func ( udevWatcher * UdevWatcher ) sendENIStateChange ( mac string ) error { if mac == " " { return errors . New ( " " ) } if ! ok { return & unmanagedENIError { mac } } if eni . IsSent ( ) { return errors . Errorf ( " " , eni . String ( ) ) } if eni . HasExpired ( ) { return errors . Errorf ( " " , eni . String ( ) ) } log . Infof ( " " , eni . String ( ) ) udevWatcher . eniChangeEvent <- api . TaskStateChange { TaskARN : eni . TaskARN , Attachment : eni , } } ( eni ) return nil } 
func ( udevWatcher * UdevWatcher ) buildState ( links [ ] netlink . Link ) map [ string ] string { state := make ( map [ string ] string ) for _ , link := range links { if link . Type ( ) != linkTypeDevice { } if link . Attrs ( ) . EncapType == encapTypeLoopback { } macAddress := link . Attrs ( ) . HardwareAddr . String ( ) if macAddress != " " && macAddress != udevWatcher . primaryMAC { state [ macAddress ] = link . Attrs ( ) . Name } } return state } 
func ( udevWatcher * UdevWatcher ) eventHandler ( ) { for { select { case event := <- udevWatcher . events : subsystem , ok := event . Env [ udevSubsystem ] if ! ok || subsystem != udevNetSubsystem { continue } if event . Env [ udevEventAction ] != udevAddEvent { continue } if ! networkutils . IsValidNetworkDevice ( event . Env [ udevDevPath ] ) { log . Debugf ( " " , event . String ( ) ) continue } netInterface := event . Env [ udevInterface ] macAddress , err := networkutils . GetMACAddress ( udevWatcher . ctx , macAddressRetryTimeout , dev , udevWatcher . netlinkClient ) if err != nil { log . Warnf ( " " , dev ) return } if err := udevWatcher . sendENIStateChangeWithRetries ( ctx , macAddress , timeout ) ; err != nil { log . Warnf ( " " , err ) } } ( udevWatcher . ctx , netInterface , sendENIStateChangeRetryTimeout ) case <- udevWatcher . ctx . Done ( ) : log . Info ( " " ) if err := udevWatcher . udevMonitor . Close ( ) ; err != nil { log . Warnf ( " " , err ) } return } } } 
func ( udevWatcher * UdevWatcher ) sendENIStateChangeWithRetries ( parentCtx context . Context , macAddress string , timeout time . Duration ) error { backoff := retry . NewExponentialBackoff ( sendENIStateChangeBackoffMin , sendENIStateChangeBackoffMax , sendENIStateChangeBackoffJitter , sendENIStateChangeBackoffMultiple ) ctx , cancel := context . WithTimeout ( parentCtx , timeout ) defer cancel ( ) err := retry . RetryWithBackoffCtx ( ctx , backoff , func ( ) error { sendErr := udevWatcher . sendENIStateChange ( macAddress ) if sendErr != nil { if _ , ok := sendErr . ( * unmanagedENIError ) ; ok { log . Debugf ( " " , sendErr ) return sendErr } } return nil } ) if err != nil { return err } } return nil } 
func New ( url string , cfg * config . Config , credentialProvider * credentials . Credentials , statsEngine stats . Engine , publishMetricsInterval time . Duration , rwTimeout time . Duration , disableResourceMetrics bool ) wsclient . ClientServer { cs := & clientServer { statsEngine : statsEngine , publishTicker : nil , publishHealthTicker : nil , publishMetricsInterval : publishMetricsInterval , } cs . URL = url cs . AgentConfig = cfg cs . CredentialProvider = credentialProvider cs . ServiceError = & tcsError { } cs . RequestHandlers = make ( map [ string ] wsclient . RequestHandler ) cs . MakeRequestHook = signRequestFunc ( url , cs . AgentConfig . AWSRegion , credentialProvider ) cs . TypeDecoder = NewTCSDecoder ( ) cs . RWTimeout = rwTimeout cs . disableResourceMetrics = disableResourceMetrics return cs } 
func ( cs * clientServer ) Serve ( ) error { seelog . Debug ( " " ) if ! cs . IsReady ( ) { return fmt . Errorf ( " " ) } if cs . statsEngine == nil { return fmt . Errorf ( " " ) } cs . publishHealthTicker = time . NewTicker ( cs . publishMetricsInterval ) if ! cs . disableResourceMetrics { go cs . publishMetrics ( ) } go cs . publishHealthMetrics ( ) return cs . ConsumeMessages ( ) } 
func ( cs * clientServer ) Close ( ) error { if cs . publishTicker != nil { cs . publishTicker . Stop ( ) } if cs . publishHealthTicker != nil { cs . publishHealthTicker . Stop ( ) } cs . cancel ( ) return cs . Disconnect ( ) } 
func signRequestFunc ( url , region string , credentialProvider * credentials . Credentials ) wsclient . MakeRequestHookFunc { return func ( payload [ ] byte ) ( [ ] byte , error ) { reqBody := bytes . NewReader ( payload ) request , err := http . NewRequest ( " " , url , reqBody ) if err != nil { return nil , err } err = utils . SignHTTPRequest ( request , region , " " , credentialProvider , reqBody ) if err != nil { return nil , err } request . Header . Add ( " " , request . Host ) var dataBuffer bytes . Buffer request . Header . Write ( & dataBuffer ) io . WriteString ( & dataBuffer , " \r \n " ) data := dataBuffer . Bytes ( ) data = append ( data , payload ... ) return data , nil } } 
func ( cs * clientServer ) publishMetrics ( ) { if cs . publishTicker == nil { seelog . Debug ( " " ) return } if err != nil && err != stats . EmptyMetricsError { seelog . Warnf ( " " , err ) } if err != nil { seelog . Warnf ( " " , err ) } case <- cs . ctx . Done ( ) : return } } } 
func ( cs * clientServer ) publishMetricsOnce ( ) error { if err != nil { return err } if err != nil { return err } } return nil } 
func ( cs * clientServer ) metricsToPublishMetricRequests ( ) ( [ ] * ecstcs . PublishMetricsRequest , error ) { metadata , taskMetrics , err := cs . statsEngine . GetInstanceMetrics ( ) if err != nil { return nil , err } var requests [ ] * ecstcs . PublishMetricsRequest if * metadata . Idle { metadata . Fin = aws . Bool ( true ) return requests , nil } var messageTaskMetrics [ ] * ecstcs . TaskMetric numTasks := len ( taskMetrics ) for i , taskMetric := range taskMetrics { messageTaskMetrics = append ( messageTaskMetrics , taskMetric ) var requestMetadata * ecstcs . MetricsMetadata if ( i + 1 ) == numTasks { } else { requestMetadata = copyMetricsMetadata ( metadata , false ) } if ( i + 1 ) % tasksInMetricMessage == 0 { messageTaskMetrics = messageTaskMetrics [ : 0 ] } } if len ( messageTaskMetrics ) > 0 { } return requests , nil } 
func ( cs * clientServer ) publishHealthMetrics ( ) { if cs . publishTicker == nil { seelog . Debug ( " " ) return } if err != nil { seelog . Warnf ( " " , err ) } for { select { case <- cs . publishHealthTicker . C : err := cs . publishHealthMetricsOnce ( ) if err != nil { seelog . Warnf ( " " , err ) } case <- cs . ctx . Done ( ) : return } } } 
func ( cs * clientServer ) publishHealthMetricsOnce ( ) error { if err != nil { return err } if err != nil { return err } } return nil } 
func ( cs * clientServer ) createPublishHealthRequests ( ) ( [ ] * ecstcs . PublishHealthRequest , error ) { metadata , taskHealthMetrics , err := cs . statsEngine . GetTaskHealthMetrics ( ) if err != nil { return nil , err } if metadata == nil || taskHealthMetrics == nil { seelog . Debug ( " " ) return nil , nil } var requests [ ] * ecstcs . PublishHealthRequest var taskHealths [ ] * ecstcs . TaskHealth numOfTasks := len ( taskHealthMetrics ) for i , taskHealth := range taskHealthMetrics { taskHealths = append ( taskHealths , taskHealth ) requestTaskHealth := copyTaskHealthMetrics ( taskHealths ) request := ecstcs . NewPublishHealthMetricsRequest ( requestMetadata , requestTaskHealth ) requests = append ( requests , request ) taskHealths = taskHealths [ : 0 ] } } requests = append ( requests , ecstcs . NewPublishHealthMetricsRequest ( requestMetadata , taskHealths ) ) } return requests , nil } 
func copyMetricsMetadata ( metadata * ecstcs . MetricsMetadata , fin bool ) * ecstcs . MetricsMetadata { return & ecstcs . MetricsMetadata { Cluster : aws . String ( * metadata . Cluster ) , ContainerInstance : aws . String ( * metadata . ContainerInstance ) , Idle : aws . Bool ( * metadata . Idle ) , MessageId : aws . String ( * metadata . MessageId ) , Fin : aws . Bool ( fin ) , } } 
func copyTaskMetrics ( from [ ] * ecstcs . TaskMetric ) [ ] * ecstcs . TaskMetric { to := make ( [ ] * ecstcs . TaskMetric , len ( from ) ) copy ( to , from ) return to } 
func copyHealthMetadata ( metadata * ecstcs . HealthMetadata , fin bool ) * ecstcs . HealthMetadata { return & ecstcs . HealthMetadata { Cluster : aws . String ( aws . StringValue ( metadata . Cluster ) ) , ContainerInstance : aws . String ( aws . StringValue ( metadata . ContainerInstance ) ) , Fin : aws . Bool ( fin ) , MessageId : aws . String ( aws . StringValue ( metadata . MessageId ) ) , } } 
func copyTaskHealthMetrics ( from [ ] * ecstcs . TaskHealth ) [ ] * ecstcs . TaskHealth { to := make ( [ ] * ecstcs . TaskHealth , len ( from ) ) copy ( to , from ) return to } 
func CredentialsHandler ( credentialsManager credentials . Manager , auditLogger audit . AuditLogger ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { credentialsID := getCredentialsID ( r ) errPrefix := fmt . Sprintf ( " " , apiVersion ) v1 . CredentialsHandlerImpl ( w , r , auditLogger , credentialsManager , credentialsID , errPrefix ) } } 
func ( as ASMAuthStatus ) String ( ) string { for k , v := range asmAuthStatusMap { if v == as { return k } } return " " } 
func ( as * ASMAuthStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * as = ASMAuthStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * as = ASMAuthStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) stat , ok := asmAuthStatusMap [ strStatus ] if ! ok { * as = ASMAuthStatusNone return errors . New ( " " ) } * as = stat return nil } 
func ( rm * ResourcesMap ) UnmarshalJSON ( data [ ] byte ) error { resources := make ( map [ string ] json . RawMessage ) err := json . Unmarshal ( data , & resources ) if err != nil { return err } result := make ( map [ string ] [ ] taskresource . TaskResource ) for key , value := range resources { switch key { case CgroupKey : if unmarshlCgroup ( key , value , result ) != nil { return err } case DockerVolumeKey : if unmarshalDockerVolume ( key , value , result ) != nil { return err } case ASMAuthKey : if unmarshalASMAuthKey ( key , value , result ) != nil { return err } case SSMSecretKey : if unmarshalSSMSecretKey ( key , value , result ) != nil { return err } case ASMSecretKey : if unmarshalASMSecretKey ( key , value , result ) != nil { return err } default : return errors . New ( " " ) } } * rm = result return nil } 
func New ( url string , cfg * config . Config , credentialProvider * credentials . Credentials , rwTimeout time . Duration ) wsclient . ClientServer { cs := & clientServer { } cs . URL = url cs . CredentialProvider = credentialProvider cs . AgentConfig = cfg cs . ServiceError = & acsError { } cs . RequestHandlers = make ( map [ string ] wsclient . RequestHandler ) cs . TypeDecoder = NewACSDecoder ( ) cs . RWTimeout = rwTimeout return cs } 
func ( cs * clientServer ) Serve ( ) error { seelog . Debug ( " " ) if ! cs . IsReady ( ) { return errors . New ( " " ) } return cs . ConsumeMessages ( ) } 
func NewVolumeResource ( ctx context . Context , name string , dockerVolumeName string , scope string , autoprovision bool , driver string , driverOptions map [ string ] string , labels map [ string ] string , client dockerapi . DockerClient ) ( * VolumeResource , error ) { if scope == TaskScope && autoprovision { return nil , errors . Errorf ( " " , name ) } v := & VolumeResource { Name : name , VolumeConfig : DockerVolumeConfig { Scope : scope , Autoprovision : autoprovision , Driver : driver , DriverOpts : driverOptions , Labels : labels , DockerVolumeName : dockerVolumeName , } , client : client , ctx : ctx , } v . initStatusToTransitions ( ) return v , nil } 
func ( vol * VolumeResource ) DesiredTerminal ( ) bool { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . desiredStatusUnsafe == resourcestatus . ResourceStatus ( VolumeRemoved ) } 
func ( vol * VolumeResource ) SetDesiredStatus ( status resourcestatus . ResourceStatus ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . desiredStatusUnsafe = status } 
func ( vol * VolumeResource ) GetDesiredStatus ( ) resourcestatus . ResourceStatus { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . desiredStatusUnsafe } 
func ( vol * VolumeResource ) SetKnownStatus ( status resourcestatus . ResourceStatus ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . knownStatusUnsafe = status } 
func ( vol * VolumeResource ) GetKnownStatus ( ) resourcestatus . ResourceStatus { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . knownStatusUnsafe } 
func ( vol * VolumeResource ) KnownCreated ( ) bool { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . knownStatusUnsafe == resourcestatus . ResourceStatus ( VolumeCreated ) } 
func ( vol * VolumeResource ) ApplyTransition ( nextState resourcestatus . ResourceStatus ) error { transitionFunc , ok := vol . statusToTransitions [ nextState ] if ! ok { return errors . Errorf ( " " , vol . Name , vol . StatusString ( nextState ) ) } return transitionFunc ( ) } 
func ( vol * VolumeResource ) SetAppliedStatus ( status resourcestatus . ResourceStatus ) bool { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) if vol . appliedStatusUnsafe != resourcestatus . ResourceStatus ( VolumeStatusNone ) { } vol . appliedStatusUnsafe = status return true } 
func ( vol * VolumeResource ) StatusString ( status resourcestatus . ResourceStatus ) string { return VolumeStatus ( status ) . String ( ) } 
func ( vol * VolumeResource ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . createdAtUnsafe = createdAt } 
func ( vol * VolumeResource ) GetCreatedAt ( ) time . Time { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . createdAtUnsafe } 
func ( vol * VolumeResource ) setMountPoint ( mountPoint string ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . VolumeConfig . Mountpoint = mountPoint } 
func ( vol * VolumeResource ) GetMountPoint ( ) string { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . VolumeConfig . Mountpoint } 
func ( vol * VolumeResource ) Create ( ) error { seelog . Debugf ( " " , vol . VolumeConfig . DockerVolumeName , vol . VolumeConfig . Driver ) volumeResponse := vol . client . CreateVolume ( vol . ctx , vol . VolumeConfig . DockerVolumeName , vol . VolumeConfig . Driver , vol . VolumeConfig . DriverOpts , vol . VolumeConfig . Labels , dockerclient . CreateVolumeTimeout ) if volumeResponse . Error != nil { return volumeResponse . Error } return nil } 
func ( vol * VolumeResource ) Cleanup ( ) error { return nil } seelog . Debugf ( " " , vol . Name ) err := vol . client . RemoveVolume ( vol . ctx , vol . VolumeConfig . DockerVolumeName , dockerclient . RemoveVolumeTimeout ) if err != nil { return err } return nil } 
func ( vol * VolumeResource ) MarshalJSON ( ) ( [ ] byte , error ) { if vol == nil { return nil , nil } return json . Marshal ( volumeResourceJSON { vol . Name , vol . VolumeConfig , vol . GetCreatedAt ( ) , func ( ) * VolumeStatus { desiredState := VolumeStatus ( vol . GetDesiredStatus ( ) ) ; return & desiredState } ( ) , func ( ) * VolumeStatus { knownState := VolumeStatus ( vol . GetKnownStatus ( ) ) ; return & knownState } ( ) , } ) } 
func ( vol * VolumeResource ) UnmarshalJSON ( b [ ] byte ) error { temp := & volumeResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } vol . Name = temp . Name vol . VolumeConfig = temp . VolumeConfig if temp . DesiredStatus != nil { vol . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { vol . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } return nil } 
func NewMockClientCreator ( ctrl * gomock . Controller ) * MockClientCreator { mock := & MockClientCreator { ctrl : ctrl } mock . recorder = & MockClientCreatorMockRecorder { mock } return mock } 
func ( m * MockClientCreator ) NewASMClient ( arg0 string , arg1 credentials . IAMRoleCredentials ) secretsmanageriface . SecretsManagerAPI { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( secretsmanageriface . SecretsManagerAPI ) return ret0 } 
func ( mr * MockClientCreatorMockRecorder ) NewASMClient ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockClientCreator ) ( nil ) . NewASMClient ) , arg0 , arg1 ) } 
func NewTransportProtocol ( protocol string ) ( TransportProtocol , error ) { switch protocol { case tcp : return TransportProtocolTCP , nil case udp : return TransportProtocolUDP , nil default : return TransportProtocolTCP , errors . New ( protocol + " " ) } } 
func ( tp * TransportProtocol ) String ( ) string { if tp == nil { return tcp } switch * tp { case TransportProtocolUDP : return udp case TransportProtocolTCP : return tcp default : seelog . Critical ( " " ) return tcp } } 
func ( tp * TransportProtocol ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * tp = TransportProtocolTCP seelog . Warn ( " " ) return nil } switch string ( b ) { case `"tcp"` : * tp = TransportProtocolTCP case `"udp"` : * tp = TransportProtocolUDP default : * tp = TransportProtocolTCP return errors . New ( " \" \" \" \" " + string ( b ) ) } return nil } 
func ( tp * TransportProtocol ) MarshalJSON ( ) ( [ ] byte , error ) { if tp == nil { return [ ] byte ( " " ) , nil } return [ ] byte ( `"` + tp . String ( ) + `"` ) , nil } 
func NewMockManager ( ctrl * gomock . Controller ) * MockManager { mock := & MockManager { ctrl : ctrl } mock . recorder = & MockManagerMockRecorder { mock } return mock } 
func ( m * MockManager ) GetTaskCredentials ( arg0 string ) ( credentials . TaskIAMRoleCredentials , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( credentials . TaskIAMRoleCredentials ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockManager ) RemoveCredentials ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockManager ) SetTaskCredentials ( arg0 * credentials . TaskIAMRoleCredentials ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func GetDockerAuthFromASM ( secretID string , client secretsmanageriface . SecretsManagerAPI ) ( types . AuthConfig , error ) { in := & secretsmanager . GetSecretValueInput { SecretId : aws . String ( secretID ) , } out , err := client . GetSecretValue ( in ) if err != nil { return types . AuthConfig { } , errors . Wrapf ( err , " " , secretID ) } return extractASMValue ( out ) } 
func GetSecretFromASM ( secretID string , client secretsmanageriface . SecretsManagerAPI ) ( string , error ) { in := & secretsmanager . GetSecretValueInput { SecretId : aws . String ( secretID ) , } out , err := client . GetSecretValue ( in ) if err != nil { return " " , errors . Wrapf ( err , " " , secretID ) } return aws . StringValue ( out . SecretString ) , nil } 
func NewMockCgroupFactory ( ctrl * gomock . Controller ) * MockCgroupFactory { mock := & MockCgroupFactory { ctrl : ctrl } mock . recorder = & MockCgroupFactoryMockRecorder { mock } return mock } 
func ( m * MockCgroupFactory ) Load ( arg0 cgroups . Hierarchy , arg1 cgroups . Path ) ( cgroups . Cgroup , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( cgroups . Cgroup ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockCgroupFactoryMockRecorder ) Load ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCgroupFactory ) ( nil ) . Load ) , arg0 , arg1 ) } 
func ( m * MockCgroupFactory ) New ( arg0 cgroups . Hierarchy , arg1 cgroups . Path , arg2 * specs_go . LinuxResources ) ( cgroups . Cgroup , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( cgroups . Cgroup ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( * loader ) LoadImage ( ctx context . Context , cfg * config . Config , dockerClient dockerapi . DockerClient ) ( * types . ImageInspect , error ) { log . Debugf ( " " , cfg . PauseContainerTarballPath ) if err := loadFromFile ( ctx , cfg . PauseContainerTarballPath , dockerClient , os . Default ) ; err != nil { return nil , err } return getPauseContainerImage ( config . DefaultPauseContainerImageName , config . DefaultPauseContainerTag , dockerClient ) } 
func NewCgroupResource ( taskARN string , control control . Control , ioutil ioutilwrapper . IOUtil , cgroupRoot string , cgroupMountPath string , resourceSpec specs . LinuxResources ) * CgroupResource { c := & CgroupResource { taskARN : taskARN , control : control , ioutil : ioutil , cgroupRoot : cgroupRoot , cgroupMountPath : cgroupMountPath , resourceSpec : resourceSpec , } c . initializeResourceStatusToTransitionFunction ( ) return c } 
func ( cgroup * CgroupResource ) SetDesiredStatus ( status resourcestatus . ResourceStatus ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . desiredStatusUnsafe = status } 
func ( cgroup * CgroupResource ) GetDesiredStatus ( ) resourcestatus . ResourceStatus { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . desiredStatusUnsafe } 
func ( cgroup * CgroupResource ) GetName ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return resourceName } 
func ( cgroup * CgroupResource ) DesiredTerminal ( ) bool { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . desiredStatusUnsafe == resourcestatus . ResourceStatus ( CgroupRemoved ) } 
func ( cgroup * CgroupResource ) KnownCreated ( ) bool { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . knownStatusUnsafe == resourcestatus . ResourceStatus ( CgroupCreated ) } 
func ( cgroup * CgroupResource ) ApplyTransition ( nextState resourcestatus . ResourceStatus ) error { transitionFunc , ok := cgroup . statusToTransitions [ nextState ] if ! ok { seelog . Errorf ( " " , cgroup . taskARN , cgroup . GetName ( ) , cgroup . StatusString ( nextState ) ) return errors . Errorf ( " " , cgroup . GetName ( ) , cgroup . StatusString ( nextState ) ) } return transitionFunc ( ) } 
func ( cgroup * CgroupResource ) SetKnownStatus ( status resourcestatus . ResourceStatus ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . knownStatusUnsafe = status cgroup . updateAppliedStatusUnsafe ( status ) } 
func ( cgroup * CgroupResource ) updateAppliedStatusUnsafe ( knownStatus resourcestatus . ResourceStatus ) { if cgroup . appliedStatus == resourcestatus . ResourceStatus ( CgroupStatusNone ) { return } } } 
func ( cgroup * CgroupResource ) SetAppliedStatus ( status resourcestatus . ResourceStatus ) bool { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) if cgroup . appliedStatus != resourcestatus . ResourceStatus ( CgroupStatusNone ) { } cgroup . appliedStatus = status return true } 
func ( cgroup * CgroupResource ) GetKnownStatus ( ) resourcestatus . ResourceStatus { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . knownStatusUnsafe } 
func ( cgroup * CgroupResource ) StatusString ( status resourcestatus . ResourceStatus ) string { return CgroupStatus ( status ) . String ( ) } 
func ( cgroup * CgroupResource ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . createdAt = createdAt } 
func ( cgroup * CgroupResource ) GetCreatedAt ( ) time . Time { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . createdAt } 
func ( cgroup * CgroupResource ) Create ( ) error { err := cgroup . setupTaskCgroup ( ) if err != nil { seelog . Criticalf ( " " , cgroup . taskARN , err ) return err } return nil } 
func ( cgroup * CgroupResource ) Cleanup ( ) error { err := cgroup . control . Remove ( cgroup . cgroupRoot ) return nil } return errors . Wrapf ( err , " " , cgroup . cgroupRoot ) } return nil } 
func ( cgroup * CgroupResource ) MarshalJSON ( ) ( [ ] byte , error ) { if cgroup == nil { return nil , errors . New ( " " ) } return json . Marshal ( cgroupResourceJSON { cgroup . cgroupRoot , cgroup . cgroupMountPath , cgroup . GetCreatedAt ( ) , func ( ) * CgroupStatus { desiredState := cgroup . GetDesiredStatus ( ) status := CgroupStatus ( desiredState ) return & status } ( ) , func ( ) * CgroupStatus { knownState := cgroup . GetKnownStatus ( ) status := CgroupStatus ( knownState ) return & status } ( ) , cgroup . resourceSpec , } ) } 
func ( cgroup * CgroupResource ) UnmarshalJSON ( b [ ] byte ) error { temp := cgroupResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } cgroup . cgroupRoot = temp . CgroupRoot cgroup . cgroupMountPath = temp . CgroupMountPath cgroup . resourceSpec = temp . LinuxSpec if temp . DesiredStatus != nil { cgroup . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { cgroup . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } return nil } 
func ( cgroup * CgroupResource ) GetCgroupRoot ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . cgroupRoot } 
func ( cgroup * CgroupResource ) GetCgroupMountPath ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . cgroupMountPath } 
func ( cgroup * CgroupResource ) Initialize ( resourceFields * taskresource . ResourceFields , taskKnownStatus status . TaskStatus , taskDesiredStatus status . TaskStatus ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . initializeResourceStatusToTransitionFunction ( ) cgroup . ioutil = resourceFields . IOUtil cgroup . control = resourceFields . Control } 
func ( * loader ) LoadImage ( ctx context . Context , cfg * config . Config , dockerClient dockerapi . DockerClient ) ( * types . ImageInspect , error ) { return nil , NewUnsupportedPlatformError ( errors . Errorf ( " " , runtime . GOOS , runtime . GOARCH ) ) } 
func NewECRFactory ( acceptInsecureCert bool ) ECRFactory { return & ecrFactory { httpClient : httpclient . New ( roundtripTimeout , acceptInsecureCert ) , } } 
func ( factory * ecrFactory ) GetClient ( authData * apicontainer . ECRAuthData ) ( ECRClient , error ) { clientConfig , err := getClientConfig ( factory . httpClient , authData ) if err != nil { return & ecrClient { } , err } return factory . newClient ( clientConfig ) , nil } 
func getClientConfig ( httpClient * http . Client , authData * apicontainer . ECRAuthData ) ( * aws . Config , error ) { cfg := aws . NewConfig ( ) . WithRegion ( authData . Region ) . WithHTTPClient ( httpClient ) if authData . EndpointOverride != " " { cfg . Endpoint = aws . String ( authData . EndpointOverride ) } if authData . UseExecutionRole { if authData . GetPullCredentials ( ) == ( credentials . IAMRoleCredentials { } ) { return nil , fmt . Errorf ( " " ) } creds := awscreds . NewStaticCredentials ( authData . GetPullCredentials ( ) . AccessKeyID , authData . GetPullCredentials ( ) . SecretAccessKey , authData . GetPullCredentials ( ) . SessionToken ) cfg = cfg . WithCredentials ( creds ) } return cfg , nil } 
func NewMockAuditLogger ( ctrl * gomock . Controller ) * MockAuditLogger { mock := & MockAuditLogger { ctrl : ctrl } mock . recorder = & MockAuditLoggerMockRecorder { mock } return mock } 
func ( m * MockAuditLogger ) GetContainerInstanceArn ( ) string { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( string ) return ret0 } 
func ( mr * MockAuditLoggerMockRecorder ) GetContainerInstanceArn ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockAuditLogger ) ( nil ) . GetContainerInstanceArn ) ) } 
func ( m * MockAuditLogger ) Log ( arg0 request . LogRequest , arg1 int , arg2 string ) { m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) } 
func ( mr * MockAuditLoggerMockRecorder ) Log ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockAuditLogger ) ( nil ) . Log ) , arg0 , arg1 , arg2 ) } 
func NewMockInfoLogger ( ctrl * gomock . Controller ) * MockInfoLogger { mock := & MockInfoLogger { ctrl : ctrl } mock . recorder = & MockInfoLoggerMockRecorder { mock } return mock } 
func ( m * MockInfoLogger ) Info ( arg0 ... interface { } ) { varargs := [ ] interface { } { } for _ , a := range arg0 { varargs = append ( varargs , a ) } m . ctrl . Call ( m , " " , varargs ... ) } 
func ( mr * MockInfoLoggerMockRecorder ) Info ( arg0 ... interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockInfoLogger ) ( nil ) . Info ) , arg0 ... ) } 
func ( te * tcsError ) NewError ( err interface { } ) * wsclient . WSError { return & wsclient . WSError { ErrObj : err , Type : errType , WSUnretriableErrors : & UnretriableErrors { } } } 
func ( event * sendableEvent ) taskShouldBeSent ( ) bool { event . lock . RLock ( ) defer event . lock . RUnlock ( ) if event . isContainerEvent { return false } tevent := event . taskChange if event . taskSent { return false } } } if container . GetSentStatus ( ) < container . GetKnownStatus ( ) { } } return false } 
func ( event * sendableEvent ) send ( sendStatusToECS sendStatusChangeToECS , setChangeSent setStatusSent , eventType string , client api . ECSClient , eventToSubmit * list . Element , stateSaver statemanager . Saver , backoff retry . Backoff , taskEvents * taskSendableEvents ) error { seelog . Infof ( " " , eventType , event . toString ( ) ) return err } seelog . Debugf ( " " , event . toString ( ) ) taskEvents . events . Remove ( eventToSubmit ) backoff . Reset ( ) return nil } 
func sendContainerStatusToECS ( client api . ECSClient , event * sendableEvent ) error { return client . SubmitContainerStateChange ( event . containerChange ) } 
func sendTaskStatusToECS ( client api . ECSClient , event * sendableEvent ) error { return client . SubmitTaskStateChange ( event . taskChange ) } 
func setContainerChangeSent ( event * sendableEvent ) { containerChangeStatus := event . containerChange . Status container := event . containerChange . Container if container != nil && container . GetSentStatus ( ) < containerChangeStatus { container . SetSentStatus ( containerChangeStatus ) } } 
func setTaskChangeSent ( event * sendableEvent ) { taskChangeStatus := event . taskChange . Status task := event . taskChange . Task if task != nil && task . GetSentStatus ( ) < taskChangeStatus { task . SetSentStatus ( taskChangeStatus ) } for _ , containerStateChange := range event . taskChange . Containers { container := containerStateChange . Container containerChangeStatus := containerStateChange . Status if container . GetSentStatus ( ) < containerChangeStatus { container . SetSentStatus ( containerStateChange . Status ) } } } 
func setTaskAttachmentSent ( event * sendableEvent ) { if event . taskChange . Attachment != nil { event . taskChange . Attachment . SetSentStatus ( ) event . taskChange . Attachment . StopAckTimer ( ) } } 
func GetSecretsFromSSM ( names [ ] string , client SSMClient ) ( map [ string ] string , error ) { var secretNames [ ] * string for _ , name := range names { secretNames = append ( secretNames , aws . String ( name ) ) } in := & ssm . GetParametersInput { Names : secretNames , WithDecryption : aws . Bool ( true ) , } out , err := client . GetParameters ( in ) if err != nil { return nil , err } return extractSSMValues ( out ) } 
func main ( ) { versionStr , _ := ioutil . ReadFile ( filepath . Join ( " " , " " , " " ) ) if strings . TrimSpace ( os . Getenv ( " " ) ) == " " { } if os . Getenv ( " " ) == " " { } outFile , err := os . Create ( " " ) if err != nil { log . Fatalf ( " " , err ) } t := template . Must ( template . New ( " " ) . Parse ( versiongoTemplate ) ) err = t . Execute ( outFile , info ) if err != nil { log . Fatalf ( " " , err ) } } 
func newAssociationResponse ( taskARN , associationType , associationName string , state dockerstate . TaskEngineState ) ( string , error ) { task , ok := state . TaskByArn ( taskARN ) if ! ok { return " " , errors . Errorf ( " " , taskARN ) } association , ok := task . AssociationByTypeAndName ( associationType , associationName ) if ! ok { return " " , errors . Errorf ( " " , associationType , associationName ) } return association . Content . Value , nil } 
func ( err CannotStopContainerError ) IsRetriableError ( ) bool { if _ , ok := err . FromError . ( NoSuchContainerError ) ; ok { return false } return true } 
func NewMockFile ( ctrl * gomock . Controller ) * MockFile { mock := & MockFile { ctrl : ctrl } mock . recorder = & MockFileMockRecorder { mock } return mock } 
func ( m * MockFile ) Chmod ( arg0 os . FileMode ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockFileMockRecorder ) Chmod ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockFile ) ( nil ) . Chmod ) , arg0 ) } 
func ( mr * MockFileMockRecorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockFile ) ( nil ) . Close ) ) } 
func ( m * MockFile ) Write ( arg0 [ ] byte ) ( int , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( int ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockOS ( ctrl * gomock . Controller ) * MockOS { mock := & MockOS { ctrl : ctrl } mock . recorder = & MockOSMockRecorder { mock } return mock } 
func ( m * MockOS ) Create ( arg0 string ) ( oswrapper . File , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( oswrapper . File ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockOSMockRecorder ) Create ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockOS ) ( nil ) . Create ) , arg0 ) } 
func ( m * MockOS ) IsNotExist ( arg0 error ) bool { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( m * MockOS ) OpenFile ( arg0 string , arg1 int , arg2 os . FileMode ) ( oswrapper . File , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( oswrapper . File ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockOS ) RemoveAll ( arg0 string ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func NewMockSSMClientCreator ( ctrl * gomock . Controller ) * MockSSMClientCreator { mock := & MockSSMClientCreator { ctrl : ctrl } mock . recorder = & MockSSMClientCreatorMockRecorder { mock } return mock } 
func ( m * MockSSMClientCreator ) NewSSMClient ( arg0 string , arg1 credentials . IAMRoleCredentials ) ssm . SSMClient { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( ssm . SSMClient ) return ret0 } 
func ( mr * MockSSMClientCreatorMockRecorder ) NewSSMClient ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockSSMClientCreator ) ( nil ) . NewSSMClient ) , arg0 , arg1 ) } 
func NewMockEC2MetadataClient ( ctrl * gomock . Controller ) * MockEC2MetadataClient { mock := & MockEC2MetadataClient { ctrl : ctrl } mock . recorder = & MockEC2MetadataClientMockRecorder { mock } return mock } 
func ( m * MockEC2MetadataClient ) DefaultCredentials ( ) ( * ec2 . RoleCredentials , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( * ec2 . RoleCredentials ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockEC2MetadataClientMockRecorder ) DefaultCredentials ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockEC2MetadataClient ) ( nil ) . DefaultCredentials ) ) } 
func ( m * MockEC2MetadataClient ) GetDynamicData ( arg0 string ) ( string , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockEC2MetadataClientMockRecorder ) GetMetadata ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockEC2MetadataClient ) ( nil ) . GetMetadata ) , arg0 ) } 
func ( m * MockEC2MetadataClient ) InstanceIdentityDocument ( ) ( ec2metadata . EC2InstanceIdentityDocument , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( ec2metadata . EC2InstanceIdentityDocument ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockHttpClient ( ctrl * gomock . Controller ) * MockHttpClient { mock := & MockHttpClient { ctrl : ctrl } mock . recorder = & MockHttpClientMockRecorder { mock } return mock } 
func ( m * MockHttpClient ) GetInstanceIdentityDocument ( ) ( ec2metadata . EC2InstanceIdentityDocument , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( ec2metadata . EC2InstanceIdentityDocument ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockHttpClientMockRecorder ) GetMetadata ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockHttpClient ) ( nil ) . GetMetadata ) , arg0 ) } 
func ( m * MockHttpClient ) GetUserData ( ) ( string , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockHttpClientMockRecorder ) GetUserData ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockHttpClient ) ( nil ) . GetUserData ) ) } 
func NewMockClient ( ctrl * gomock . Controller ) * MockClient { mock := & MockClient { ctrl : ctrl } mock . recorder = & MockClientMockRecorder { mock } return mock } 
func ( m * MockClient ) DescribeECSTagsForInstance ( arg0 string ) ( [ ] * ecs . Tag , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . Tag ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockClientSDK ( ctrl * gomock . Controller ) * MockClientSDK { mock := & MockClientSDK { ctrl : ctrl } mock . recorder = & MockClientSDKMockRecorder { mock } return mock } 
func ( m * MockClientSDK ) CreateTags ( arg0 * ec20 . CreateTagsInput ) ( * ec20 . CreateTagsOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ec20 . CreateTagsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClientSDK ) DescribeTags ( arg0 * ec20 . DescribeTagsInput ) ( * ec20 . DescribeTagsOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ec20 . DescribeTagsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockClientSDKMockRecorder ) DescribeTags ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockClientSDK ) ( nil ) . DescribeTags ) , arg0 ) } 
func NewStateManager ( cfg * config . Config , options ... Option ) ( StateManager , error ) { fi , err := os . Stat ( cfg . DataDir ) if err != nil { return nil , err } if ! fi . IsDir ( ) { return nil , errors . New ( " " ) } state := & state { Data : make ( saveableState ) , Version : ECSDataVersion , } manager := & basicStateManager { statePath : cfg . DataDir , state : state , } for _ , option := range options { option ( manager ) } manager . platformDependencies = newPlatformDependencies ( ) return manager , nil } 
func AddSaveable ( name string , saveable Saveable ) Option { return ( Option ) ( func ( m StateManager ) { manager , ok := m . ( * basicStateManager ) if ! ok { log . Crit ( " " ) return } manager . state . Data [ name ] = & saveable } ) } 
func ( manager * basicStateManager ) Save ( ) error { defer metrics . MetricsEngineGlobal . RecordStateManagerMetric ( " " ) ( ) manager . saveTimesLock . Lock ( ) defer manager . saveTimesLock . Unlock ( ) if time . Since ( manager . lastSave ) >= minSaveInterval { manager . lastSave = time . Now ( ) manager . nextPlannedSave = time . Time { } return err } else if manager . nextPlannedSave . IsZero ( ) { manager . nextPlannedSave = next go func ( ) { time . Sleep ( next . Sub ( time . Now ( ) ) ) manager . Save ( ) } ( ) } } 
func ( manager * basicStateManager ) ForceSave ( ) error { manager . savingLock . Lock ( ) defer manager . savingLock . Unlock ( ) log . Info ( " " ) s := manager . state s . Version = ECSDataVersion data , err := json . Marshal ( s ) if err != nil { log . Error ( " " , " " , err ) return err } return manager . writeFile ( data ) } 
func ( manager * basicStateManager ) Load ( ) error { s := manager . state log . Info ( " " ) data , err := manager . readFile ( ) if err != nil { log . Error ( " " , " " , err ) return err } if data == nil { return nil } if err != nil { return err } err = json . Unmarshal ( data , & intermediate ) if err != nil { log . Debug ( " " ) return err } for key , rawJSON := range intermediate . Data { actualPointer , ok := manager . state . Data [ key ] if ! ok { log . Error ( " " + key ) continue } err = json . Unmarshal ( rawJSON , actualPointer ) if err != nil { log . Debug ( " " ) return err } } log . Debug ( " " , " " , s ) return nil } 
func ValidDependencies ( task * apitask . Task ) bool { unresolved := make ( [ ] * apicontainer . Container , len ( task . Containers ) ) resolved := make ( [ ] * apicontainer . Container , 0 , len ( task . Containers ) ) copy ( unresolved , task . Containers ) OuterLoop : for len ( unresolved ) > 0 { for i , tryResolve := range unresolved { if dependenciesCanBeResolved ( tryResolve , resolved ) { resolved = append ( resolved , tryResolve ) unresolved = append ( unresolved [ : i ] , unresolved [ i + 1 : ] ... ) } } log . Warnf ( " " , unresolved , task ) return false } return true } 
func dependenciesCanBeResolved ( target * apicontainer . Container , by [ ] * apicontainer . Container ) bool { nameMap := make ( map [ string ] * apicontainer . Container ) for _ , cont := range by { nameMap [ cont . Name ] = cont } if _ , err := verifyContainerOrderingStatusResolvable ( target , nameMap , containerOrderingDependenciesCanResolve ) ; err != nil { return false } return verifyStatusResolvable ( target , nameMap , target . SteadyStateDependencies , onSteadyStateCanResolve ) } 
func DependenciesAreResolved ( target * apicontainer . Container , by [ ] * apicontainer . Container , id string , manager credentials . Manager , resources [ ] taskresource . TaskResource ) ( * apicontainer . DependsOn , error ) { if ! executionCredentialsResolved ( target , id , manager ) { return nil , CredentialsNotResolvedErr } nameMap := make ( map [ string ] * apicontainer . Container ) for _ , cont := range by { nameMap [ cont . Name ] = cont } neededVolumeContainers := make ( [ ] string , len ( target . VolumesFrom ) ) for i , volume := range target . VolumesFrom { neededVolumeContainers [ i ] = volume . SourceContainer } resourcesMap := make ( map [ string ] taskresource . TaskResource ) for _ , resource := range resources { resourcesMap [ resource . GetName ( ) ] = resource } if blocked , err := verifyContainerOrderingStatusResolvable ( target , nameMap , containerOrderingDependenciesIsResolved ) ; err != nil { return blocked , err } if ! verifyStatusResolvable ( target , nameMap , target . SteadyStateDependencies , onSteadyStateIsResolved ) { return nil , DependentContainerNotResolvedErr } if err := verifyTransitionDependenciesResolved ( target , nameMap , resourcesMap ) ; err != nil { return nil , err } } } return nil , nil } 
func verifyStatusResolvable ( target * apicontainer . Container , existingContainers map [ string ] * apicontainer . Container , dependencies [ ] string , resolves func ( * apicontainer . Container , * apicontainer . Container ) bool ) bool { targetGoal := target . GetDesiredStatus ( ) if targetGoal != target . GetSteadyStateStatus ( ) && targetGoal != apicontainerstatus . ContainerCreated { } for _ , dependency := range dependencies { maybeResolves , exists := existingContainers [ dependency ] if ! exists { return false } if ! resolves ( target , maybeResolves ) { return false } } return true } 
func verifyContainerOrderingStatusResolvable ( target * apicontainer . Container , existingContainers map [ string ] * apicontainer . Container , resolves func ( * apicontainer . Container , * apicontainer . Container , string ) bool ) ( * apicontainer . DependsOn , error ) { targetGoal := target . GetDesiredStatus ( ) targetKnown := target . GetKnownStatus ( ) if targetGoal != target . GetSteadyStateStatus ( ) && targetGoal != apicontainerstatus . ContainerCreated { } for _ , dependency := range target . DependsOn { dependencyContainer , ok := existingContainers [ dependency . ContainerName ] if ! ok { return nil , fmt . Errorf ( " " , dependencyContainer , target ) } } } } } if ! resolves ( target , dependencyContainer , dependency . Condition ) { return & dependency , fmt . Errorf ( " " , dependencyContainer , target ) } } return nil , nil } 
func onSteadyStateIsResolved ( target * apicontainer . Container , run * apicontainer . Container ) bool { return target . GetDesiredStatus ( ) >= apicontainerstatus . ContainerCreated && run . GetKnownStatus ( ) >= run . GetSteadyStateStatus ( ) } 
func newAgent ( ctx context . Context , blackholeEC2Metadata bool , acceptInsecureCert * bool ) ( agent , error ) { ec2MetadataClient := ec2 . NewEC2MetadataClient ( nil ) if blackholeEC2Metadata { ec2MetadataClient = ec2 . NewBlackholeEC2MetadataClient ( ) } seelog . Info ( " " ) cfg , err := config . NewConfig ( ec2MetadataClient ) if err != nil { return nil , err } cfg . AcceptInsecureCert = aws . BoolValue ( acceptInsecureCert ) if cfg . AcceptInsecureCert { seelog . Warn ( " " ) } seelog . Infof ( " " , version . Version , version . GitShortHash ) seelog . Debugf ( " " , cfg . String ( ) ) ec2Client := ec2 . NewClientImpl ( cfg . AWSRegion ) dockerClient , err := dockerapi . NewDockerGoClient ( sdkclientfactory . NewFactory ( ctx , cfg . DockerEndpoint ) , cfg , ctx ) if err != nil { return nil , err } var metadataManager containermetadata . Manager if cfg . ContainerMetadataEnabled { } return & ecsAgent { ctx : ctx , ec2MetadataClient : ec2MetadataClient , ec2Client : ec2Client , cfg : cfg , dockerClient : dockerClient , } 
func ( agent * ecsAgent ) printECSAttributes ( ) int { capabilities , err := agent . capabilities ( ) if err != nil { seelog . Warnf ( " " , err ) return exitcodes . ExitError } for _ , attr := range capabilities { fmt . Printf ( " \t \n " , aws . StringValue ( attr . Name ) , aws . StringValue ( attr . Value ) ) } return exitcodes . ExitSuccess } 
func ( agent * ecsAgent ) start ( ) int { sighandlers . StartDebugHandler ( ) containerChangeEventStream := eventstream . NewEventStream ( containerChangeEventStreamName , agent . ctx ) credentialsManager := credentials . NewManager ( ) state := dockerstate . NewTaskEngineState ( ) imageManager := engine . NewImageManager ( agent . cfg , agent . dockerClient , state ) client := ecsclient . NewECSClient ( agent . credentialProvider , agent . cfg , agent . ec2MetadataClient ) agent . initializeResourceFields ( credentialsManager ) return agent . doStart ( containerChangeEventStream , credentialsManager , state , imageManager , client ) } 
func ( agent * ecsAgent ) doStart ( containerChangeEventStream * eventstream . EventStream , credentialsManager credentials . Manager , state dockerstate . TaskEngineState , imageManager engine . ImageManager , client api . ECSClient ) int { } return exitcodes . ExitTerminal } } if agent . cfg . GPUSupportEnabled { err := agent . initializeGPUManager ( ) if err != nil { seelog . Criticalf ( " " , err ) return exitcodes . ExitError } } if err != nil { return exitcodes . ExitTerminal } agent . initMetricsEngine ( ) if err != nil { seelog . Criticalf ( " " , err ) return exitcodes . ExitTerminal } var vpcSubnetAttributes [ ] * ecs . Attribute switch err { case nil : case instanceNotLaunchedInVPCError : agent . cfg . TaskENIEnabled = false default : if terminal { return exitcodes . ExitTerminal } return exitcodes . ExitError } } if err != nil { if isTransient ( err ) { return exitcodes . ExitError } return exitcodes . ExitTerminal } agent . metadataManager . SetAvailabilityZone ( agent . availabilityZone ) agent . metadataManager . SetHostPublicIPv4Address ( agent . getHostPublicIPv4AddressFromEC2Metadata ( ) ) } imageManager . SetSaver ( stateManager ) taskEngine . MustInit ( agent . ctx ) deregisterInstanceEventStream . StartListening ( ) taskHandler := eventhandler . NewTaskHandler ( agent . ctx , stateManager , state , client ) agent . startAsyncRoutines ( containerChangeEventStream , credentialsManager , imageManager , taskEngine , stateManager , deregisterInstanceEventStream , client , taskHandler , state ) } 
func ( agent * ecsAgent ) newTaskEngine ( containerChangeEventStream * eventstream . EventStream , credentialsManager credentials . Manager , state dockerstate . TaskEngineState , imageManager engine . ImageManager ) ( engine . TaskEngine , string , error ) { containerChangeEventStream . StartListening ( ) if ! agent . cfg . Checkpoint { seelog . Info ( " " ) return engine . NewTaskEngine ( agent . cfg , agent . dockerClient , credentialsManager , containerChangeEventStream , imageManager , state , agent . metadataManager , agent . resourceFields ) , " " , nil } previousTaskEngine := engine . NewTaskEngine ( agent . cfg , agent . dockerClient , credentialsManager , containerChangeEventStream , imageManager , state , agent . metadataManager , agent . resourceFields ) if err != nil { seelog . Criticalf ( " " , err ) return nil , " " , err } err = previousStateManager . Load ( ) if err != nil { seelog . Criticalf ( " " , err ) return nil , " " , err } err = agent . checkCompatibility ( previousTaskEngine ) if err != nil { seelog . Criticalf ( " " , err ) return nil , " " , err } currentEC2InstanceID := agent . getEC2InstanceID ( ) if previousEC2InstanceID != " " && previousEC2InstanceID != currentEC2InstanceID { seelog . Warnf ( instanceIDMismatchErrorFormat , previousEC2InstanceID , currentEC2InstanceID ) } if previousCluster != " " { if err := agent . setClusterInConfig ( previousCluster ) ; err != nil { return nil , " " , err } } return previousTaskEngine , currentEC2InstanceID , nil } 
func ( agent * ecsAgent ) setClusterInConfig ( previousCluster string ) error { if configuredCluster == " " { seelog . Debug ( " " ) configuredCluster = config . DefaultClusterName } if previousCluster != configuredCluster { err := clusterMismatchError { fmt . Errorf ( clusterMismatchErrorFormat , previousCluster , configuredCluster ) , } seelog . Criticalf ( " " , err ) return err } agent . cfg . Cluster = previousCluster seelog . Infof ( " " , agent . cfg . Cluster ) return nil } 
func ( agent * ecsAgent ) getEC2InstanceID ( ) string { instanceID , err := agent . ec2MetadataClient . InstanceID ( ) if err != nil { seelog . Warnf ( " " , err ) return " " } return instanceID } 
func ( agent * ecsAgent ) newStateManager ( taskEngine engine . TaskEngine , cluster * string , containerInstanceArn * string , savedInstanceID * string , availabilityZone * string ) ( statemanager . StateManager , error ) { if ! agent . cfg . Checkpoint { return statemanager . NewNoopStateManager ( ) , nil } return agent . stateManagerFactory . NewStateManager ( agent . cfg , statemanager . AddSaveable ( " " , taskEngine ) , } 
func ( agent * ecsAgent ) constructVPCSubnetAttributes ( ) [ ] * ecs . Attribute { return [ ] * ecs . Attribute { { Name : aws . String ( vpcIDAttributeName ) , Value : aws . String ( agent . vpc ) , } , { Name : aws . String ( subnetIDAttributeName ) , Value : aws . String ( agent . subnet ) , } , } } 
func ( agent * ecsAgent ) registerContainerInstance ( stateManager statemanager . StateManager , client api . ECSClient , additionalAttributes [ ] * ecs . Attribute ) error { } agentCapabilities , err := agent . capabilities ( ) if err != nil { return err } capabilities := append ( agentCapabilities , additionalAttributes ... ) if agent . cfg . ContainerInstancePropagateTagsFrom == config . ContainerInstancePropagateTagsFromEC2InstanceType { ec2Tags , err := agent . getContainerInstanceTagsFromEC2API ( ) } seelog . Infof ( " \n " , ec2Tags ) tags = mergeTags ( tags , ec2Tags ) } platformDevices := agent . getPlatformDevices ( ) if agent . containerInstanceARN != " " { seelog . Infof ( " " , agent . containerInstanceARN , agent . cfg . Cluster ) return agent . reregisterContainerInstance ( client , capabilities , tags , uuid . New ( ) , platformDevices ) } seelog . Info ( " " ) containerInstanceArn , availabilityZone , err := client . RegisterContainerInstance ( " " , capabilities , tags , uuid . New ( ) , platformDevices ) if err != nil { seelog . Errorf ( " " , err ) if retriable , ok := err . ( apierrors . Retriable ) ; ok && ! retriable . Retry ( ) { return err } if utils . IsAWSErrorCodeEqual ( err , ecs . ErrCodeInvalidParameterException ) { seelog . Critical ( " " ) return err } if _ , ok := err . ( apierrors . AttributeError ) ; ok { seelog . Critical ( " " ) return err } return transientError { err } } seelog . Infof ( " " , containerInstanceArn , agent . cfg . Cluster ) agent . containerInstanceARN = containerInstanceArn agent . availabilityZone = availabilityZone return nil } 
func ( agent * ecsAgent ) reregisterContainerInstance ( client api . ECSClient , capabilities [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registrationToken string , platformDevices [ ] * ecs . PlatformDevice ) error { _ , availabilityZone , err := client . RegisterContainerInstance ( agent . containerInstanceARN , capabilities , tags , registrationToken , platformDevices ) if err == nil { return nil } seelog . Errorf ( " " , err ) if apierrors . IsInstanceTypeChangedError ( err ) { seelog . Criticalf ( instanceTypeMismatchErrorFormat , err ) return err } if _ , ok := err . ( apierrors . AttributeError ) ; ok { seelog . Critical ( " " ) return err } return transientError { err } } 
func ( agent * ecsAgent ) startAsyncRoutines ( containerChangeEventStream * eventstream . EventStream , credentialsManager credentials . Manager , imageManager engine . ImageManager , taskEngine engine . TaskEngine , stateManager statemanager . StateManager , deregisterInstanceEventStream * eventstream . EventStream , client api . ECSClient , taskHandler * eventhandler . TaskHandler , state dockerstate . TaskEngineState ) { } go agent . terminationHandler ( stateManager , taskEngine ) statsEngine := stats . NewDockerStatsEngine ( agent . cfg , agent . dockerClient , containerChangeEventStream ) } else { go handlers . ServeTaskHTTPEndpoint ( credentialsManager , state , client , agent . containerInstanceARN , agent . cfg , statsEngine , agent . availabilityZone ) } telemetrySessionParams := tcshandler . TelemetrySessionParams { Ctx : agent . ctx , CredentialProvider : agent . credentialProvider , Cfg : agent . cfg , ContainerInstanceArn : agent . containerInstanceARN , DeregisterInstanceEventStream : deregisterInstanceEventStream , ECSClient : client , TaskEngine : taskEngine , StatsEngine : statsEngine , } } 
func ( agent * ecsAgent ) startACSSession ( credentialsManager credentials . Manager , taskEngine engine . TaskEngine , stateManager statemanager . StateManager , deregisterInstanceEventStream * eventstream . EventStream , client api . ECSClient , state dockerstate . TaskEngineState , taskHandler * eventhandler . TaskHandler ) int { acsSession := acshandler . NewSession ( agent . ctx , agent . cfg , deregisterInstanceEventStream , agent . containerInstanceARN , agent . credentialProvider , client , state , stateManager , taskEngine , credentialsManager , taskHandler , ) seelog . Info ( " " ) err := acsSession . Start ( ) if err != nil { seelog . Criticalf ( " " , err ) return exitcodes . ExitTerminal } seelog . Critical ( " " ) return exitcodes . ExitError } 
func ( agent * ecsAgent ) verifyRequiredDockerVersion ( ) ( int , bool ) { supportedVersions := agent . dockerClient . SupportedVersions ( ) if len ( supportedVersions ) == 0 { seelog . Critical ( " " ) return exitcodes . ExitError , false } } } return exitcodes . ExitTerminal , false } 
func ( agent * ecsAgent ) getContainerInstanceTagsFromEC2API ( ) ( [ ] * ecs . Tag , error ) { if err != nil { return nil , err } return agent . ec2Client . DescribeECSTagsForInstance ( instanceID ) } 
func mergeTags ( localTags [ ] * ecs . Tag , ec2Tags [ ] * ecs . Tag ) [ ] * ecs . Tag { tagsMap := make ( map [ string ] string ) for _ , ec2Tag := range ec2Tags { tagsMap [ aws . StringValue ( ec2Tag . Key ) ] = aws . StringValue ( ec2Tag . Value ) } for _ , localTag := range localTags { tagsMap [ aws . StringValue ( localTag . Key ) ] = aws . StringValue ( localTag . Value ) } return utils . MapToTags ( tagsMap ) } 
func ( agent * ecsAgent ) getHostPublicIPv4AddressFromEC2Metadata ( ) string { if err != nil { seelog . Errorf ( " " , err ) return " " } return hostPublicIPv4Address } 
func SlicesDeepEqual ( slice1 , slice2 interface { } ) bool { s1 := reflect . ValueOf ( slice1 ) s2 := reflect . ValueOf ( slice2 ) if s1 . Len ( ) != s2 . Len ( ) { return false } if s1 . Len ( ) == 0 { return true } s2found := make ( [ ] int , s2 . Len ( ) ) OuterLoop : for i := 0 ; i < s1 . Len ( ) ; i ++ { s1el := s1 . Slice ( i , i + 1 ) for j := 0 ; j < s2 . Len ( ) ; j ++ { if s2found [ j ] == 1 { } s2el := s2 . Slice ( j , j + 1 ) if reflect . DeepEqual ( s1el . Interface ( ) , s2el . Interface ( ) ) { s2found [ j ] = 1 continue OuterLoop } } } return true } 
func Uint16SliceToStringSlice ( slice [ ] uint16 ) [ ] * string { stringSlice := make ( [ ] * string , len ( slice ) ) for i , el := range slice { str := strconv . Itoa ( int ( el ) ) stringSlice [ i ] = & str } return stringSlice } 
func IsAWSErrorCodeEqual ( err error , code string ) bool { awsErr , ok := err . ( awserr . Error ) return ok && awsErr . Code ( ) == code } 
func MapToTags ( tagsMap map [ string ] string ) [ ] * ecs . Tag { tags := make ( [ ] * ecs . Tag , 0 ) if tagsMap == nil { return tags } for key , value := range tagsMap { tags = append ( tags , & ecs . Tag { Key : aws . String ( key ) , Value : aws . String ( value ) , } ) } return tags } 
func CredentialsHandlerImpl ( w http . ResponseWriter , r * http . Request , auditLogger audit . AuditLogger , credentialsManager credentials . Manager , credentialsID string , errPrefix string ) { responseJSON , arn , roleType , errorMessage , err := processCredentialsRequest ( credentialsManager , r , credentialsID , errPrefix ) if err != nil { errResponseJSON , _ := json . Marshal ( errorMessage ) writeCredentialsRequestResponse ( w , r , errorMessage . HTTPErrorCode , audit . GetCredentialsEventType ( roleType ) , arn , auditLogger , errResponseJSON ) return } writeCredentialsRequestResponse ( w , r , http . StatusOK , audit . GetCredentialsEventType ( roleType ) , arn , auditLogger , responseJSON ) } 
func processCredentialsRequest ( credentialsManager credentials . Manager , r * http . Request , credentialsID string , errPrefix string ) ( [ ] byte , string , string , * handlersutils . ErrorMessage , error ) { if credentialsID == " " { errText := errPrefix + " " seelog . Infof ( " " , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrNoIDInRequest , Message : errText , HTTPErrorCode : http . StatusBadRequest , } return nil , " " , " " , msg , errors . New ( errText ) } credentials , ok := credentialsManager . GetTaskCredentials ( credentialsID ) if ! ok { errText := errPrefix + " " seelog . Infof ( " " , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrInvalidIDInRequest , Message : errText , HTTPErrorCode : http . StatusBadRequest , } return nil , " " , " " , msg , errors . New ( errText ) } if utils . ZeroOrNil ( credentials . ARN ) && utils . ZeroOrNil ( credentials . IAMRoleCredentials ) { seelog . Infof ( " " , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrCredentialsUninitialized , Message : errText , HTTPErrorCode : http . StatusServiceUnavailable , } return nil , " " , " " , msg , errors . New ( errText ) } credentialsJSON , err := json . Marshal ( credentials . IAMRoleCredentials ) if err != nil { errText := errPrefix + " " seelog . Errorf ( " " , errText , r . RemoteAddr ) msg := & handlersutils . ErrorMessage { Code : ErrInternalServer , Message : " " , HTTPErrorCode : http . StatusInternalServerError , } return nil , " " , " " , msg , errors . New ( errText ) } } 
func NewTaskHandler ( ctx context . Context , stateManager statemanager . Saver , state dockerstate . TaskEngineState , client api . ECSClient ) * TaskHandler { go taskHandler . startDrainEventsTicker ( ) return taskHandler } 
func ( handler * TaskHandler ) AddStateChangeEvent ( change statechange . Event , client api . ECSClient ) error { handler . lock . Lock ( ) defer handler . lock . Unlock ( ) switch change . GetEventType ( ) { case statechange . TaskEvent : event , ok := change . ( api . TaskStateChange ) if ! ok { return errors . New ( " " ) } return nil case statechange . ContainerEvent : event , ok := change . ( api . ContainerStateChange ) if ! ok { return errors . New ( " " ) } handler . batchContainerEventUnsafe ( event ) return nil default : return errors . New ( " " ) } } 
func ( handler * TaskHandler ) startDrainEventsTicker ( ) { derivedCtx , cancel := context . WithCancel ( handler . ctx ) defer cancel ( ) ticker := utils . NewJitteredTicker ( derivedCtx , handler . minDrainEventsFrequency , handler . maxDrainEventsFrequency ) for { select { case <- handler . ctx . Done ( ) : seelog . Infof ( " " ) return case <- ticker : } } } } 
func ( handler * TaskHandler ) taskStateChangesToSend ( ) [ ] api . TaskStateChange { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) var events [ ] api . TaskStateChange for taskARN := range handler . tasksToContainerStates { if knownStatus >= apitaskstatus . TaskStopped { continue } event := api . TaskStateChange { TaskARN : taskARN , Status : task . GetKnownStatus ( ) , Task : task , } event . SetTaskTimestamps ( ) events = append ( events , event ) } } return events } 
func ( handler * TaskHandler ) batchContainerEventUnsafe ( event api . ContainerStateChange ) { seelog . Infof ( " " , event . String ( ) ) handler . tasksToContainerStates [ event . TaskArn ] = append ( handler . tasksToContainerStates [ event . TaskArn ] , event ) } 
func ( handler * TaskHandler ) flushBatchUnsafe ( taskStateChange * api . TaskStateChange , client api . ECSClient ) { taskStateChange . Containers = append ( taskStateChange . Containers , handler . tasksToContainerStates [ taskStateChange . TaskARN ] ... ) taskEvents := handler . getTaskEventsUnsafe ( event ) } 
func ( handler * TaskHandler ) getTaskEventsUnsafe ( event * sendableEvent ) * taskSendableEvents { taskARN := event . taskArn ( ) taskEvents , ok := handler . tasksToEvents [ taskARN ] if ! ok { handler . tasksToEvents [ taskARN ] = taskEvents seelog . Debugf ( " " , event . toString ( ) , taskEvents . toStringUnsafe ( ) ) } return taskEvents } 
func ( handler * TaskHandler ) submitTaskEvents ( taskEvents * taskSendableEvents , client api . ECSClient , taskARN string ) { defer metrics . MetricsEngineGlobal . RecordECSClientMetric ( " " ) ( ) defer handler . removeTaskEvents ( taskARN ) backoff := retry . NewExponentialBackoff ( submitStateBackoffMin , submitStateBackoffMax , submitStateBackoffJitterMultiple , submitStateBackoffMultiple ) retry . RetryWithBackoff ( backoff , func ( ) error { handler . submitSemaphore . Wait ( ) defer handler . submitSemaphore . Post ( ) var err error done , err = taskEvents . submitFirstEvent ( handler , backoff ) return err } ) } } 
func ( taskEvents * taskSendableEvents ) sendChange ( change * sendableEvent , client api . ECSClient , handler * TaskHandler ) { taskEvents . lock . Lock ( ) defer taskEvents . lock . Unlock ( ) taskEvents . events . PushBack ( change ) if ! taskEvents . sending { go handler . submitTaskEvents ( taskEvents , client , change . taskArn ( ) ) } else { seelog . Debugf ( " " , change . toString ( ) ) } } 
func ( taskEvents * taskSendableEvents ) submitFirstEvent ( handler * TaskHandler , backoff retry . Backoff ) ( bool , error ) { seelog . Debug ( " " ) taskEvents . lock . Lock ( ) defer taskEvents . lock . Unlock ( ) seelog . Debugf ( " " , taskEvents . toStringUnsafe ( ) ) if taskEvents . events . Len ( ) == 0 { seelog . Debug ( " " ) taskEvents . sending = false return true , nil } eventToSubmit := taskEvents . events . Front ( ) if event . containerShouldBeSent ( ) { if err := event . send ( sendContainerStatusToECS , setContainerChangeSent , " " , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { return false , err } } else if event . taskShouldBeSent ( ) { if err := event . send ( sendTaskStatusToECS , setTaskChangeSent , " " , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { handleInvalidParamException ( err , taskEvents . events , eventToSubmit ) return false , err } } else if event . taskAttachmentShouldBeSent ( ) { if err := event . send ( sendTaskStatusToECS , setTaskAttachmentSent , " " , handler . client , eventToSubmit , handler . stateSaver , backoff , taskEvents ) ; err != nil { handleInvalidParamException ( err , taskEvents . events , eventToSubmit ) return false , err } } else { taskEvents . events . Remove ( eventToSubmit ) } if taskEvents . events . Len ( ) == 0 { seelog . Debug ( " " ) taskEvents . sending = false return true , nil } return false , nil } 
func ( handler * TaskHandler ) getTasksToEventsLen ( ) int { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) return len ( handler . tasksToEvents ) } 
func handleInvalidParamException ( err error , events * list . List , eventToSubmit * list . Element ) { if utils . IsAWSErrorCodeEqual ( err , ecs . ErrCodeInvalidParameterException ) { event := eventToSubmit . Value . ( * sendableEvent ) seelog . Warnf ( " " , event . toString ( ) ) events . Remove ( eventToSubmit ) } } 
func NewMockControl ( ctrl * gomock . Controller ) * MockControl { mock := & MockControl { ctrl : ctrl } mock . recorder = & MockControlMockRecorder { mock } return mock } 
func ( m * MockControl ) Create ( arg0 * control . Spec ) ( cgroups . Cgroup , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( cgroups . Cgroup ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockControl ) Exists ( arg0 string ) bool { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( m * MockControl ) Init ( ) error { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockControlMockRecorder ) Init ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockControl ) ( nil ) . Init ) ) } 
func ( mr * MockControlMockRecorder ) Remove ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockControl ) ( nil ) . Remove ) , arg0 ) } 
func NewQueue ( maxSize int ) * Queue { return & Queue { buffer : make ( [ ] UsageStats , 0 , maxSize ) , maxSize : maxSize , } } 
func ( queue * Queue ) Reset ( ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queue . lastResetTime = time . Now ( ) queue . buffer = queue . buffer [ : 0 ] } 
func ( queue * Queue ) Add ( dockerStat * types . StatsJSON ) error { queue . setLastStat ( dockerStat ) stat , err := dockerStatsToContainerStats ( dockerStat ) if err != nil { return err } queue . add ( stat ) return nil } 
func ( queue * Queue ) GetLastStat ( ) * types . StatsJSON { queue . lock . RLock ( ) defer queue . lock . RUnlock ( ) return queue . lastStat } 
func ( queue * Queue ) GetRawUsageStats ( numStats int ) ( [ ] UsageStats , error ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queueLength := len ( queue . buffer ) if queueLength == 0 { return nil , fmt . Errorf ( " " ) } if numStats > queueLength { numStats = queueLength } usageStats := make ( [ ] UsageStats , numStats ) for i := 0 ; i < numStats ; i ++ { usageStats [ i ] = UsageStats { CPUUsagePerc : rawUsageStat . CPUUsagePerc , MemoryUsageInMegs : rawUsageStat . MemoryUsageInMegs , Timestamp : rawUsageStat . Timestamp , } } return usageStats , nil } 
func ( queue * Queue ) getCWStatsSet ( f getUsageFunc ) ( * ecstcs . CWStatsSet , error ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queueLength := len ( queue . buffer ) if queueLength < 2 { } var min , max , sum float64 var sampleCount int64 min = math . MaxFloat64 max = - math . MaxFloat64 sum = 0 sampleCount = 0 for _ , stat := range queue . buffer { perc := f ( & stat ) if math . IsNaN ( perc ) { continue } min = math . Min ( min , perc ) max = math . Max ( max , perc ) sampleCount ++ sum += perc } return & ecstcs . CWStatsSet { Max : & max , Min : & min , SampleCount : & sampleCount , Sum : & sum , } , nil } 
func ( as ASMSecretStatus ) String ( ) string { for k , v := range asmSecretStatusMap { if v == as { return k } } return " " } 
func ( as * ASMSecretStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * as = ASMSecretStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * as = ASMSecretStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) stat , ok := asmSecretStatusMap [ strStatus ] if ! ok { * as = ASMSecretStatusNone return errors . New ( " " ) } * as = stat return nil } 
func NewMockCNIClient ( ctrl * gomock . Controller ) * MockCNIClient { mock := & MockCNIClient { ctrl : ctrl } mock . recorder = & MockCNIClientMockRecorder { mock } return mock } 
func ( m * MockCNIClient ) Capabilities ( arg0 string ) ( [ ] string , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockCNIClientMockRecorder ) Capabilities ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCNIClient ) ( nil ) . Capabilities ) , arg0 ) } 
func ( m * MockCNIClient ) CleanupNS ( arg0 context . Context , arg1 * ecscni . Config , arg2 time . Duration ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockCNIClient ) ReleaseIPResource ( arg0 * ecscni . Config ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockCNIClient ) SetupNS ( arg0 context . Context , arg1 * ecscni . Config , arg2 time . Duration ) ( * current . Result , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( * current . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockCNIClientMockRecorder ) SetupNS ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCNIClient ) ( nil ) . SetupNS ) , arg0 , arg1 , arg2 ) } 
func ContainerAssociationsHandler ( state dockerstate . TaskEngineState ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { containerID , err := getContainerIDByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } associationType , err := getAssociationTypeByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociations ) return } seelog . Infof ( " " , containerID , associationType ) writeContainerAssociationsResponse ( w , containerID , taskARN , associationType , state ) } } 
func ContainerAssociationHandler ( state dockerstate . TaskEngineState ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } associationType , err := getAssociationTypeByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } associationName , err := getAssociationNameByRequest ( r ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerAssociation ) return } seelog . Infof ( " " , associationName , associationType ) writeContainerAssociationResponse ( w , taskARN , associationType , associationName , state ) } } 
func dockerStatsToContainerStats ( dockerStats * types . StatsJSON ) ( * ContainerStats , error ) { if numCores == uint64 ( 0 ) { seelog . Error ( " " ) return nil , fmt . Errorf ( " " ) } cpuUsage := ( dockerStats . CPUStats . CPUUsage . TotalUsage * 100 ) / numCores memoryUsage := dockerStats . MemoryStats . PrivateWorkingSet return & ContainerStats { cpuUsage : cpuUsage , memoryUsage : memoryUsage , timestamp : dockerStats . Read , } , nil } 
func GetMockServer ( closeWS <- chan [ ] byte ) ( * httptest . Server , chan <- string , <- chan string , <- chan error , error ) { serverChan := make ( chan string ) requestsChan := make ( chan string ) errChan := make ( chan error ) stopListen := make ( chan bool ) upgrader := websocket . Upgrader { ReadBufferSize : 1024 , WriteBufferSize : 1024 } handler := http . HandlerFunc ( func ( w http . ResponseWriter , r * http . Request ) { ws , err := upgrader . Upgrade ( w , r , nil ) go func ( ) { ws . WriteControl ( websocket . CloseMessage , <- closeWS , time . Now ( ) . Add ( time . Second ) ) close ( stopListen ) } ( ) if err != nil { errChan <- err } go func ( ) { for { select { case <- stopListen : return default : _ , msg , err := ws . ReadMessage ( ) if err != nil { errChan <- err } else { requestsChan <- string ( msg ) } } } } ( ) for str := range serverChan { err := ws . WriteMessage ( websocket . TextMessage , [ ] byte ( str ) ) if err != nil { errChan <- err } } } ) server := httptest . NewUnstartedServer ( handler ) return server , serverChan , requestsChan , errChan , nil } 
func ( cs CgroupStatus ) String ( ) string { for k , v := range cgroupStatusMap { if v == cs { return k } } return " " } 
func ( cs * CgroupStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if cs == nil { return nil , nil } return [ ] byte ( `"` + cs . String ( ) + `"` ) , nil } 
func ( cs * CgroupStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * cs = CgroupStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * cs = CgroupStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) stat , ok := cgroupStatusMap [ strStatus ] if ! ok { * cs = CgroupStatusNone return errors . New ( " " ) } * cs = stat return nil } 
func NewManager ( client DockerMetadataClient , cfg * config . Config ) Manager { return & metadataManager { client : client , cluster : cfg . Cluster , dataDir : cfg . DataDir , dataDirOnHost : cfg . DataDirOnHost , osWrap : oswrapper . NewOS ( ) , ioutilWrap : ioutilwrapper . NewIOUtil ( ) , } } 
func ( manager * metadataManager ) Create ( config * dockercontainer . Config , hostConfig * dockercontainer . HostConfig , task * apitask . Task , containerName string ) error { } err = manager . osWrap . MkdirAll ( metadataDirectoryPath , os . ModePerm ) if err != nil { return fmt . Errorf ( " " , task . Arn , err ) } err = manager . marshalAndWrite ( metadata , task . Arn , containerName ) if err != nil { return err } config . Env = env hostConfig . Binds = binds return nil } 
func ( manager * metadataManager ) Update ( ctx context . Context , dockerID string , task * apitask . Task , containerName string ) error { if err != nil { return err } } return manager . marshalAndWrite ( metadata , task . Arn , containerName ) } 
func ( manager * metadataManager ) Clean ( taskARN string ) error { metadataPath , err := getTaskMetadataDir ( taskARN , manager . dataDir ) if err != nil { return fmt . Errorf ( " " , taskARN , err ) } return manager . osWrap . RemoveAll ( metadataPath ) } 
func ( authProvider * dockerAuthProvider ) GetAuthconfig ( image string , registryAuthData * apicontainer . RegistryAuthenticationData ) ( types . AuthConfig , error ) { authDataMap := authProvider . authMap if isDockerhubHostname ( indexName ) { return authDataMap [ dockerRegistryKey ] , nil } authConfigKey := indexName } for registry := range authDataMap { nameParts := strings . SplitN ( registry , " " , 2 ) hostname := nameParts [ 0 ] } else if len ( registry ) > len ( longestKey ) && strings . HasPrefix ( image , registry ) { } } } if longestKey != " " { return authDataMap [ longestKey ] , nil } return types . AuthConfig { } , nil } 
func parseAuthData ( authType string , authData json . RawMessage ) dockerAuths { intermediateAuthData := make ( dockerAuths ) switch authType { case " " : err := json . Unmarshal ( authData , & intermediateAuthData ) if err != nil { seelog . Warn ( " " ) return dockerAuths { } } case " " : var base64dAuthInfo dockercfgData err := json . Unmarshal ( authData , & base64dAuthInfo ) if err != nil { seelog . Warn ( " " ) return dockerAuths { } } for registry , auth := range base64dAuthInfo { data , err := base64 . StdEncoding . DecodeString ( auth . Auth ) if err != nil { seelog . Warnf ( " " , registry ) continue } usernamePass := strings . SplitN ( string ( data ) , " " , 2 ) if len ( usernamePass ) != 2 { seelog . Warnf ( " " , registry ) continue } intermediateAuthData [ registry ] = types . AuthConfig { Username : usernamePass [ 0 ] , Password : usernamePass [ 1 ] , } } case " " : default : seelog . Warnf ( " " , authType ) return dockerAuths { } } for key , val := range intermediateAuthData { output [ stripRegistrySchema ( key ) ] = val } return output } 
func stripRegistrySchema ( registry string ) string { if strings . HasPrefix ( registry , " " ) { return strings . TrimPrefix ( registry , " " ) } else if strings . HasPrefix ( registry , " " ) { return strings . TrimPrefix ( registry , " " ) } return registry } 
func ( lh LoggingHandler ) ServeHTTP ( w http . ResponseWriter , r * http . Request ) { seelog . Debug ( " " , " " , r . Method , " " , r . RemoteAddr ) lh . h . ServeHTTP ( w , r ) } 
func NewJitteredTicker ( ctx context . Context , start , end time . Duration ) <- chan time . Time { ticker := make ( chan time . Time , 1 ) go func ( ) { defer close ( ticker ) for { select { case <- ctx . Done ( ) : return default : time . Sleep ( randomDuration ( start , end ) ) sendNow ( ticker ) } } } ( ) return ticker } 
func ( agent * ecsAgent ) capabilities ( ) ( [ ] * ecs . Attribute , error ) { var capabilities [ ] * ecs . Attribute if ! agent . cfg . PrivilegedDisabled { capabilities = appendNameOnlyAttribute ( capabilities , capabilityPrefix + " " ) } supportedVersions := make ( map [ dockerclient . DockerVersion ] bool ) supportedVersions [ version ] = true } capabilities = agent . appendLoggingDriverCapabilities ( capabilities ) if agent . cfg . SELinuxCapable { capabilities = appendNameOnlyAttribute ( capabilities , capabilityPrefix + " " ) } if agent . cfg . AppArmorCapable { capabilities = appendNameOnlyAttribute ( capabilities , capabilityPrefix + " " ) } capabilities = agent . appendTaskIamRoleCapabilities ( capabilities , supportedVersions ) capabilities , err := agent . appendTaskCPUMemLimitCapabilities ( capabilities , supportedVersions ) if err != nil { return nil , err } capabilities = agent . appendTaskENICapabilities ( capabilities ) capabilities = agent . appendDockerDependentCapabilities ( capabilities , supportedVersions ) } capabilities = agent . appendVolumeDriverCapabilities ( capabilities ) if agent . cfg . GPUSupportEnabled { capabilities = agent . appendNvidiaDriverVersionAttribute ( capabilities ) } return capabilities , nil } 
func ( agent * ecsAgent ) getTaskENIPluginVersionAttribute ( ) ( * ecs . Attribute , error ) { version , err := agent . cniClient . Version ( ecscni . ECSENIPluginName ) if err != nil { seelog . Warnf ( " " , ecscni . ECSENIPluginName , err ) return nil , err } return & ecs . Attribute { Name : aws . String ( attributePrefix + cniPluginVersionSuffix ) , Value : aws . String ( version ) , } , nil } 
func NewMockECSSDK ( ctrl * gomock . Controller ) * MockECSSDK { mock := & MockECSSDK { ctrl : ctrl } mock . recorder = & MockECSSDKMockRecorder { mock } return mock } 
func ( m * MockECSSDK ) CreateCluster ( arg0 * ecs . CreateClusterInput ) ( * ecs . CreateClusterOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . CreateClusterOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockECSSDK ) DiscoverPollEndpoint ( arg0 * ecs . DiscoverPollEndpointInput ) ( * ecs . DiscoverPollEndpointOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . DiscoverPollEndpointOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockECSSDK ) ListTagsForResource ( arg0 * ecs . ListTagsForResourceInput ) ( * ecs . ListTagsForResourceOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . ListTagsForResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockECSSDK ) RegisterContainerInstance ( arg0 * ecs . RegisterContainerInstanceInput ) ( * ecs . RegisterContainerInstanceOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . RegisterContainerInstanceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECSSDKMockRecorder ) RegisterContainerInstance ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECSSDK ) ( nil ) . RegisterContainerInstance ) , arg0 ) } 
func NewMockECSSubmitStateSDK ( ctrl * gomock . Controller ) * MockECSSubmitStateSDK { mock := & MockECSSubmitStateSDK { ctrl : ctrl } mock . recorder = & MockECSSubmitStateSDKMockRecorder { mock } return mock } 
func ( m * MockECSSubmitStateSDK ) SubmitContainerStateChange ( arg0 * ecs . SubmitContainerStateChangeInput ) ( * ecs . SubmitContainerStateChangeOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . SubmitContainerStateChangeOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECSSubmitStateSDKMockRecorder ) SubmitContainerStateChange ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECSSubmitStateSDK ) ( nil ) . SubmitContainerStateChange ) , arg0 ) } 
func ( m * MockECSSubmitStateSDK ) SubmitTaskStateChange ( arg0 * ecs . SubmitTaskStateChangeInput ) ( * ecs . SubmitTaskStateChangeOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecs . SubmitTaskStateChangeOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockECSClient ( ctrl * gomock . Controller ) * MockECSClient { mock := & MockECSClient { ctrl : ctrl } mock . recorder = & MockECSClientMockRecorder { mock } return mock } 
func ( m * MockECSClient ) DiscoverPollEndpoint ( arg0 string ) ( string , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECSClientMockRecorder ) DiscoverPollEndpoint ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECSClient ) ( nil ) . DiscoverPollEndpoint ) , arg0 ) } 
func ( m * MockECSClient ) GetResourceTags ( arg0 string ) ( [ ] * ecs . Tag , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . Tag ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockECSClient ) RegisterContainerInstance ( arg0 string , arg1 [ ] * ecs . Attribute , arg2 [ ] * ecs . Tag , arg3 string , arg4 [ ] * ecs . PlatformDevice ) ( string , string , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 , arg4 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( string ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 } 
func ( mr * MockECSClientMockRecorder ) RegisterContainerInstance ( arg0 , arg1 , arg2 , arg3 , arg4 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECSClient ) ( nil ) . RegisterContainerInstance ) , arg0 , arg1 , arg2 , arg3 , arg4 ) } 
func ( m * MockECSClient ) SubmitContainerStateChange ( arg0 api . ContainerStateChange ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockECSClient ) SubmitTaskStateChange ( arg0 api . TaskStateChange ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func NewTaskEngine ( cfg * config . Config , client dockerapi . DockerClient , credentialsManager credentials . Manager , containerChangeEventStream * eventstream . EventStream , imageManager ImageManager , state dockerstate . TaskEngineState , metadataManager containermetadata . Manager , resourceFields * taskresource . ResourceFields ) TaskEngine { taskEngine := NewDockerTaskEngine ( cfg , client , credentialsManager , containerChangeEventStream , imageManager , state , metadataManager , resourceFields ) return taskEngine } 
func NewMockStateManager ( ctrl * gomock . Controller ) * MockStateManager { mock := & MockStateManager { ctrl : ctrl } mock . recorder = & MockStateManagerMockRecorder { mock } return mock } 
func ( m * MockStateManager ) NewStateManager ( arg0 * config . Config , arg1 ... statemanager . Option ) ( statemanager . StateManager , error ) { varargs := [ ] interface { } { arg0 } for _ , a := range arg1 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( statemanager . StateManager ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockStateManagerMockRecorder ) NewStateManager ( arg0 interface { } , arg1 ... interface { } ) * gomock . Call { varargs := append ( [ ] interface { } { arg0 } , arg1 ... ) return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockStateManager ) ( nil ) . NewStateManager ) , varargs ... ) } 
func NewMockSaveableOption ( ctrl * gomock . Controller ) * MockSaveableOption { mock := & MockSaveableOption { ctrl : ctrl } mock . recorder = & MockSaveableOptionMockRecorder { mock } return mock } 
func ( m * MockSaveableOption ) AddSaveable ( arg0 string , arg1 statemanager . Saveable ) statemanager . Option { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( statemanager . Option ) return ret0 } 
func ( mr * MockSaveableOptionMockRecorder ) AddSaveable ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockSaveableOption ) ( nil ) . AddSaveable ) , arg0 , arg1 ) } 
func NewECSClient ( credentialProvider * credentials . Credentials , config * config . Config , ec2MetadataClient ec2 . EC2MetadataClient ) api . ECSClient { var ecsConfig aws . Config ecsConfig . Credentials = credentialProvider ecsConfig . Region = & config . AWSRegion ecsConfig . HTTPClient = httpclient . New ( roundtripTimeout , config . AcceptInsecureCert ) if config . APIEndpoint != " " { ecsConfig . Endpoint = & config . APIEndpoint } standardClient := ecs . New ( session . New ( & ecsConfig ) ) submitStateChangeClient := newSubmitStateChangeClient ( & ecsConfig ) pollEndpoinCache := async . NewLRUCache ( pollEndpointCacheSize , pollEndpointCacheTTL ) return & APIECSClient { credentialProvider : credentialProvider , config : config , standardClient : standardClient , submitStateChangeClient : submitStateChangeClient , ec2metadata : ec2MetadataClient , pollEndpoinCache : pollEndpoinCache , } } 
func ( client * APIECSClient ) CreateCluster ( clusterName string ) ( string , error ) { resp , err := client . standardClient . CreateCluster ( & ecs . CreateClusterInput { ClusterName : & clusterName } ) if err != nil { seelog . Criticalf ( " " , err ) return " " , err } seelog . Infof ( " " , clusterName ) return * resp . Cluster . ClusterName , nil } 
func ( client * APIECSClient ) RegisterContainerInstance ( containerInstanceArn string , attributes [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registrationToken string , platformDevices [ ] * ecs . PlatformDevice ) ( string , string , error ) { clusterRef := client . config . Cluster defer func ( ) { } ( ) if err == nil { return containerInstanceArn , availabilityzone , nil } if err != nil { return " " , " " , err } } } return client . registerContainerInstance ( clusterRef , containerInstanceArn , attributes , tags , registrationToken , platformDevices ) } 
func ( cs * ClientServerImpl ) Connect ( ) error { seelog . Infof ( " " , cs . URL ) parsedURL , err := url . Parse ( cs . URL ) if err != nil { return err } wsScheme , err := websocketScheme ( parsedURL . Scheme ) if err != nil { return err } parsedURL . Scheme = wsScheme if err != nil { return err } timeoutDialer := & net . Dialer { Timeout : wsConnectTimeout } tlsConfig := & tls . Config { ServerName : parsedURL . Host , InsecureSkipVerify : cs . AgentConfig . AcceptInsecureCert } cipher . WithSupportedCipherSuites ( tlsConfig ) if noProxy == " " { dockerHost , err := url . Parse ( cs . AgentConfig . DockerEndpoint ) if err == nil { dockerHost . Scheme = " " os . Setenv ( " " , fmt . Sprintf ( " " , defaultNoProxyIP , dockerHost . String ( ) ) ) seelog . Info ( " " , os . Getenv ( " " ) ) } else { seelog . Errorf ( " " ) } } dialer := websocket . Dialer { ReadBufferSize : readBufSize , WriteBufferSize : writeBufSize , TLSClientConfig : tlsConfig , Proxy : http . ProxyFromEnvironment , NetDial : timeoutDialer . Dial , HandshakeTimeout : wsHandshakeTimeout , } websocketConn , httpResponse , err := dialer . Dial ( parsedURL . String ( ) , request . Header ) if httpResponse != nil { defer httpResponse . Body . Close ( ) } if err != nil { var resp [ ] byte if httpResponse != nil { var readErr error resp , readErr = ioutil . ReadAll ( httpResponse . Body ) if readErr != nil { return fmt . Errorf ( " " + readErr . Error ( ) + " " + err . Error ( ) ) } if decodeErr == nil { return cs . NewError ( possibleError ) } } seelog . Warnf ( " " , err ) return errors . Wrapf ( err , " " , parsedURL . Host , string ( resp ) ) } cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) cs . conn = websocketConn seelog . Debugf ( " " , cs . URL ) return nil } 
func ( cs * ClientServerImpl ) IsReady ( ) bool { cs . writeLock . RLock ( ) defer cs . writeLock . RUnlock ( ) return cs . conn != nil } 
func ( cs * ClientServerImpl ) SetReadDeadline ( t time . Time ) error { err := cs . conn . SetReadDeadline ( t ) if err == nil { return nil } seelog . Warnf ( " " , err , cs . URL ) return opErr } return err } 
func ( cs * ClientServerImpl ) Disconnect ( ... interface { } ) error { cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) if cs . conn == nil { return fmt . Errorf ( " " ) } } return cs . conn . Close ( ) } 
func ( cs * ClientServerImpl ) AddRequestHandler ( f RequestHandler ) { firstArg := reflect . TypeOf ( f ) . In ( 0 ) firstArgTypeStr := firstArg . Elem ( ) . Name ( ) recognizedTypes := cs . GetRecognizedTypes ( ) _ , ok := recognizedTypes [ firstArgTypeStr ] if ! ok { panic ( " " + firstArgTypeStr ) } cs . RequestHandlers [ firstArgTypeStr ] = f } 
func ( cs * ClientServerImpl ) MakeRequest ( input interface { } ) error { send , err := cs . CreateRequestMessage ( input ) if err != nil { return err } if cs . MakeRequestHook != nil { send , err = cs . MakeRequestHook ( send ) if err != nil { return err } } } 
func ( cs * ClientServerImpl ) WriteMessage ( send [ ] byte ) error { cs . writeLock . Lock ( ) defer cs . writeLock . Unlock ( ) } return cs . conn . WriteMessage ( websocket . TextMessage , send ) } 
func ( cs * ClientServerImpl ) ConsumeMessages ( ) error { for { if err := cs . SetReadDeadline ( time . Now ( ) . Add ( cs . RWTimeout ) ) ; err != nil { return err } messageType , message , err := cs . conn . ReadMessage ( ) switch { case err == nil : if messageType != websocket . TextMessage { } cs . handleMessage ( message ) case permissibleCloseCode ( err ) : seelog . Debugf ( " " , err ) return io . EOF default : return err } } } 
func ( cs * ClientServerImpl ) CreateRequestMessage ( input interface { } ) ( [ ] byte , error ) { msg := & RequestMessage { } recognizedTypes := cs . GetRecognizedTypes ( ) for typeStr , typeVal := range recognizedTypes { if reflect . TypeOf ( input ) == reflect . PtrTo ( typeVal ) { msg . Type = typeStr break } } if msg . Type == " " { return nil , & UnrecognizedWSRequestType { reflect . TypeOf ( input ) . String ( ) } } messageData , err := jsonutil . BuildJSON ( input ) if err != nil { return nil , & NotMarshallableWSRequest { msg . Type , err } } msg . Message = json . RawMessage ( messageData ) send , err := json . Marshal ( msg ) if err != nil { return nil , & NotMarshallableWSRequest { msg . Type , err } } return send , nil } 
func ( cs * ClientServerImpl ) handleMessage ( data [ ] byte ) { typedMessage , typeStr , err := DecodeData ( data , cs . TypeDecoder ) if err != nil { seelog . Warnf ( " " , err ) return } seelog . Debugf ( " " , typeStr ) if cs . AnyRequestHandler != nil { reflect . ValueOf ( cs . AnyRequestHandler ) . Call ( [ ] reflect . Value { reflect . ValueOf ( typedMessage ) } ) } if handler , ok := cs . RequestHandlers [ typeStr ] ; ok { reflect . ValueOf ( handler ) . Call ( [ ] reflect . Value { reflect . ValueOf ( typedMessage ) } ) } else { seelog . Infof ( " " , typeStr ) } } 
func permissibleCloseCode ( err error ) bool { return websocket . IsCloseError ( err , websocket . CloseNormalClosure , } 
func ( state * DockerTaskEngineState ) AllTasks ( ) [ ] * apitask . Task { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . allTasksUnsafe ( ) } 
func ( state * DockerTaskEngineState ) AllImageStates ( ) [ ] * image . ImageState { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . allImageStatesUnsafe ( ) } 
func ( state * DockerTaskEngineState ) AllENIAttachments ( ) [ ] * apieni . ENIAttachment { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . allENIAttachmentsUnsafe ( ) } 
func ( state * DockerTaskEngineState ) ENIByMac ( mac string ) ( * apieni . ENIAttachment , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) eni , ok := state . eniAttachments [ mac ] return eni , ok } 
func ( state * DockerTaskEngineState ) AddENIAttachment ( eniAttachment * apieni . ENIAttachment ) { if eniAttachment == nil { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok := state . eniAttachments [ eniAttachment . MACAddress ] ; ! ok { state . eniAttachments [ eniAttachment . MACAddress ] = eniAttachment } else { seelog . Debugf ( " " , eniAttachment ) } } 
func ( state * DockerTaskEngineState ) RemoveENIAttachment ( mac string ) { if mac == " " { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok := state . eniAttachments [ mac ] ; ok { delete ( state . eniAttachments , mac ) } else { seelog . Debugf ( " " , mac ) } } 
func ( state * DockerTaskEngineState ) GetAllContainerIDs ( ) [ ] string { state . lock . RLock ( ) defer state . lock . RUnlock ( ) var ids [ ] string for id := range state . idToTask { ids = append ( ids , id ) } return ids } 
func ( state * DockerTaskEngineState ) ContainerByID ( id string ) ( * apicontainer . DockerContainer , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) c , ok := state . idToContainer [ id ] return c , ok } 
func ( state * DockerTaskEngineState ) ContainerMapByArn ( arn string ) ( map [ string ] * apicontainer . DockerContainer , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) ret , ok := state . taskToID [ arn ] for k , v := range ret { mc [ k ] = v } return mc , ok } return ret , ok } 
func ( state * DockerTaskEngineState ) TaskByShortID ( cid string ) ( [ ] * apitask . Task , bool ) { containerIDs := state . GetAllContainerIDs ( ) var tasks [ ] * apitask . Task for _ , id := range containerIDs { if strings . HasPrefix ( id , cid ) { if task , ok := state . TaskByID ( id ) ; ok { tasks = append ( tasks , task ) } } } return tasks , len ( tasks ) > 0 } 
func ( state * DockerTaskEngineState ) TaskByID ( cid string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) arn , found := state . idToTask [ cid ] if ! found { return nil , false } return state . taskByArn ( arn ) } 
func ( state * DockerTaskEngineState ) TaskByArn ( arn string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . taskByArn ( arn ) } 
func ( state * DockerTaskEngineState ) AddTask ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . tasks [ task . Arn ] = task } 
func ( state * DockerTaskEngineState ) AddContainer ( container * apicontainer . DockerContainer , task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) if task == nil || container == nil { log . Crit ( " " ) return } _ , exists := state . tasks [ task . Arn ] if ! exists { log . Debug ( " " , " " , task . Arn ) state . tasks [ task . Arn ] = task } state . storeIDToContainerTaskUnsafe ( container , task ) dockerID := container . DockerID v3EndpointID := container . Container . V3EndpointID state . storeV3EndpointIDToDockerIDUnsafe ( v3EndpointID , dockerID ) } existingMap , exists := state . taskToID [ task . Arn ] if ! exists { existingMap = make ( map [ string ] * apicontainer . DockerContainer , len ( task . Containers ) ) state . taskToID [ task . Arn ] = existingMap } existingMap [ container . Container . Name ] = container } 
func ( state * DockerTaskEngineState ) AddImageState ( imageState * image . ImageState ) { if imageState == nil { log . Debug ( " " ) return } if imageState . Image . ImageID == " " { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) state . imageStates [ imageState . Image . ImageID ] = imageState } 
func ( state * DockerTaskEngineState ) RemoveTask ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) task , ok := state . tasks [ task . Arn ] if ! ok { seelog . Warnf ( " " , task . Arn ) return } delete ( state . tasks , task . Arn ) if ip , ok := state . taskToIPUnsafe ( task . Arn ) ; ok { delete ( state . ipToTask , ip ) } containerMap , ok := state . taskToID [ task . Arn ] if ! ok { seelog . Warnf ( " " , task . Arn ) return } delete ( state . taskToID , task . Arn ) for _ , dockerContainer := range containerMap { state . removeIDToContainerTaskUnsafe ( dockerContainer ) } } 
func ( state * DockerTaskEngineState ) taskToIPUnsafe ( arn string ) ( string , bool ) { for ip , taskARN := range state . ipToTask { if arn == taskARN { return ip , true } } return " " , false } 
func ( state * DockerTaskEngineState ) storeIDToContainerTaskUnsafe ( container * apicontainer . DockerContainer , task * apitask . Task ) { if container . DockerID != " " { state . idToTask [ container . DockerID ] = task . Arn delete ( state . idToTask , container . DockerName ) } else if container . DockerName != " " { state . idToTask [ container . DockerName ] = task . Arn } } 
func ( state * DockerTaskEngineState ) removeIDToContainerTaskUnsafe ( container * apicontainer . DockerContainer ) { if key == " " { key = container . DockerName } delete ( state . idToTask , key ) delete ( state . idToContainer , key ) } 
func ( state * DockerTaskEngineState ) removeV3EndpointIDToTaskContainerUnsafe ( v3EndpointID string ) { if v3EndpointID != " " { delete ( state . v3EndpointIDToTask , v3EndpointID ) delete ( state . v3EndpointIDToDockerID , v3EndpointID ) } } 
func ( state * DockerTaskEngineState ) RemoveImageState ( imageState * image . ImageState ) { if imageState == nil { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) imageState , ok := state . imageStates [ imageState . Image . ImageID ] if ! ok { log . Debug ( " " ) return } delete ( state . imageStates , imageState . Image . ImageID ) } 
func ( state * DockerTaskEngineState ) AddTaskIPAddress ( addr string , taskARN string ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . ipToTask [ addr ] = taskARN } 
func ( state * DockerTaskEngineState ) GetTaskByIPAddress ( addr string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) taskARN , ok := state . ipToTask [ addr ] return taskARN , ok } 
func ( state * DockerTaskEngineState ) storeV3EndpointIDToTaskUnsafe ( v3EndpointID , taskARN string ) { state . v3EndpointIDToTask [ v3EndpointID ] = taskARN } 
func ( state * DockerTaskEngineState ) storeV3EndpointIDToDockerIDUnsafe ( v3EndpointID , dockerID string ) { state . v3EndpointIDToDockerID [ v3EndpointID ] = dockerID } 
func ( state * DockerTaskEngineState ) DockerIDByV3EndpointID ( v3EndpointID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) dockerID , ok := state . v3EndpointIDToDockerID [ v3EndpointID ] return dockerID , ok } 
func ( state * DockerTaskEngineState ) TaskARNByV3EndpointID ( v3EndpointID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) taskArn , ok := state . v3EndpointIDToTask [ v3EndpointID ] return taskArn , ok } 
func v1HandlersSetup ( serverMux * http . ServeMux , containerInstanceArn * string , taskEngine handlersutils . DockerStateResolver , cfg * config . Config ) { serverMux . HandleFunc ( v1 . AgentMetadataPath , v1 . AgentMetadataHandler ( containerInstanceArn , cfg ) ) serverMux . HandleFunc ( v1 . TaskContainerMetadataPath , v1 . TaskContainerMetadataHandler ( taskEngine ) ) serverMux . HandleFunc ( v1 . LicensePath , v1 . LicenseHandler ) } 
func ServeIntrospectionHTTPEndpoint ( containerInstanceArn * string , taskEngine engine . TaskEngine , cfg * config . Config ) { server := introspectionServerSetup ( containerInstanceArn , dockerTaskEngine , cfg ) for { once := sync . Once { } retry . RetryWithBackoff ( retry . NewExponentialBackoff ( time . Second , time . Minute , 0.2 , 2 ) , func ( ) error { once . Do ( func ( ) { seelog . Error ( " " , " " , err ) } ) return err } ) } } 
func ( dc * DockerContainer ) String ( ) string { if dc == nil { return " " } return fmt . Sprintf ( " " , dc . DockerID , dc . DockerName , dc . Container . String ( ) ) } 
func NewContainerWithSteadyState ( steadyState apicontainerstatus . ContainerStatus ) * Container { steadyStateStatus := steadyState return & Container { SteadyStateStatusUnsafe : & steadyStateStatus , } } 
func ( c * Container ) GetKnownStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownStatusUnsafe } 
func ( c * Container ) SetKnownStatus ( status apicontainerstatus . ContainerStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownStatusUnsafe = status c . updateAppliedStatusUnsafe ( status ) } 
func ( c * Container ) GetDesiredStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . DesiredStatusUnsafe } 
func ( c * Container ) SetDesiredStatus ( status apicontainerstatus . ContainerStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . DesiredStatusUnsafe = status } 
func ( c * Container ) GetSentStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . SentStatusUnsafe } 
func ( c * Container ) SetSentStatus ( status apicontainerstatus . ContainerStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . SentStatusUnsafe = status } 
func ( c * Container ) SetKnownExitCode ( i * int ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownExitCodeUnsafe = i } 
func ( c * Container ) GetKnownExitCode ( ) * int { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownExitCodeUnsafe } 
func ( c * Container ) SetRegistryAuthCredentials ( credential credentials . IAMRoleCredentials ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . RegistryAuthentication . ECRAuthData . SetPullCredentials ( credential ) } 
func ( c * Container ) ShouldPullWithExecutionRole ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . RegistryAuthentication != nil && c . RegistryAuthentication . Type == AuthTypeECR && c . RegistryAuthentication . ECRAuthData != nil && c . RegistryAuthentication . ECRAuthData . UseExecutionRole } 
func ( c * Container ) String ( ) string { ret := fmt . Sprintf ( " " , c . Name , c . Image , c . GetKnownStatus ( ) . String ( ) , c . GetDesiredStatus ( ) . String ( ) ) if c . GetKnownExitCode ( ) != nil { ret += " " + strconv . Itoa ( * c . GetKnownExitCode ( ) ) } return ret } 
func ( c * Container ) GetSteadyStateStatus ( ) apicontainerstatus . ContainerStatus { if c . SteadyStateStatusUnsafe == nil { return defaultContainerSteadyStateStatus } return * c . SteadyStateStatusUnsafe } 
func ( c * Container ) IsKnownSteadyState ( ) bool { knownStatus := c . GetKnownStatus ( ) return knownStatus == c . GetSteadyStateStatus ( ) } 
func ( c * Container ) GetNextKnownStateProgression ( ) apicontainerstatus . ContainerStatus { if c . IsKnownSteadyState ( ) { return apicontainerstatus . ContainerStopped } return c . GetKnownStatus ( ) + 1 } 
func ( c * Container ) IsMetadataFileUpdated ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . MetadataFileUpdated } 
func ( c * Container ) SetMetadataFileUpdated ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . MetadataFileUpdated = true } 
func ( c * Container ) IsEssential ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Essential } 
func ( c * Container ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . createdAt = createdAt } 
func ( c * Container ) SetStartedAt ( startedAt time . Time ) { if startedAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . startedAt = startedAt } 
func ( c * Container ) SetFinishedAt ( finishedAt time . Time ) { if finishedAt . IsZero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . finishedAt = finishedAt } 
func ( c * Container ) GetCreatedAt ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . createdAt } 
func ( c * Container ) GetStartedAt ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . startedAt } 
func ( c * Container ) GetFinishedAt ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . finishedAt } 
func ( c * Container ) SetLabels ( labels map [ string ] string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . labels = labels } 
func ( c * Container ) GetLabels ( ) map [ string ] string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . labels } 
func ( c * Container ) SetKnownPortBindings ( ports [ ] PortBinding ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . KnownPortBindingsUnsafe = ports } 
func ( c * Container ) GetKnownPortBindings ( ) [ ] PortBinding { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . KnownPortBindingsUnsafe } 
func ( c * Container ) SetVolumes ( volumes [ ] types . MountPoint ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . VolumesUnsafe = volumes } 
func ( c * Container ) GetVolumes ( ) [ ] types . MountPoint { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . VolumesUnsafe } 
func ( c * Container ) SetNetworkSettings ( networks * types . NetworkSettings ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . NetworkSettingsUnsafe = networks } 
func ( c * Container ) GetNetworkSettings ( ) * types . NetworkSettings { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . NetworkSettingsUnsafe } 
func ( c * Container ) SetNetworkMode ( networkMode string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . NetworkModeUnsafe = networkMode } 
func ( c * Container ) GetNetworkMode ( ) string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . NetworkModeUnsafe } 
func ( c * Container ) SetHealthStatus ( health HealthStatus ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . Health . Status == health . Status { return } c . Health . Status = health . Status c . Health . Since = aws . Time ( time . Now ( ) ) c . Health . Output = health . Output } } 
func ( c * Container ) GetHealthStatus ( ) HealthStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) if c . Health . Since != nil { copyHealth . Since = aws . Time ( aws . TimeValue ( c . Health . Since ) ) } return copyHealth } 
func ( c * Container ) BuildContainerDependency ( contName string , satisfiedStatus apicontainerstatus . ContainerStatus , dependentStatus apicontainerstatus . ContainerStatus ) { contDep := ContainerDependency { ContainerName : contName , SatisfiedStatus : satisfiedStatus , } if _ , ok := c . TransitionDependenciesMap [ dependentStatus ] ; ! ok { c . TransitionDependenciesMap [ dependentStatus ] = TransitionDependencySet { } } deps := c . TransitionDependenciesMap [ dependentStatus ] deps . ContainerDependencies = append ( deps . ContainerDependencies , contDep ) c . TransitionDependenciesMap [ dependentStatus ] = deps } 
func ( c * Container ) BuildResourceDependency ( resourceName string , requiredStatus resourcestatus . ResourceStatus , dependentStatus apicontainerstatus . ContainerStatus ) { resourceDep := ResourceDependency { Name : resourceName , RequiredStatus : requiredStatus , } if _ , ok := c . TransitionDependenciesMap [ dependentStatus ] ; ! ok { c . TransitionDependenciesMap [ dependentStatus ] = TransitionDependencySet { } } deps := c . TransitionDependenciesMap [ dependentStatus ] deps . ResourceDependencies = append ( deps . ResourceDependencies , resourceDep ) c . TransitionDependenciesMap [ dependentStatus ] = deps } 
func ( c * Container ) updateAppliedStatusUnsafe ( knownStatus apicontainerstatus . ContainerStatus ) { if c . AppliedStatus == apicontainerstatus . ContainerStatusNone { return } } } 
func ( c * Container ) SetAppliedStatus ( status apicontainerstatus . ContainerStatus ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . AppliedStatus != apicontainerstatus . ContainerStatusNone { } c . AppliedStatus = status return true } 
func ( c * Container ) GetAppliedStatus ( ) apicontainerstatus . ContainerStatus { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . AppliedStatus } 
func ( c * Container ) ShouldPullWithASMAuth ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . RegistryAuthentication != nil && c . RegistryAuthentication . Type == AuthTypeASM && c . RegistryAuthentication . ASMAuthData != nil } 
func ( c * Container ) SetASMDockerAuthConfig ( dac types . AuthConfig ) { c . RegistryAuthentication . ASMAuthData . SetDockerAuthConfig ( dac ) } 
func ( c * Container ) SetV3EndpointID ( v3EndpointID string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . V3EndpointID = v3EndpointID } 
func ( c * Container ) GetV3EndpointID ( ) string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . V3EndpointID } 
func ( c * Container ) InjectV3MetadataEndpoint ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) } c . Environment [ MetadataURIEnvironmentVariableName ] = fmt . Sprintf ( MetadataURIFormat , c . V3EndpointID ) } 
func ( c * Container ) ShouldCreateWithSSMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } for _ , secret := range c . Secrets { if secret . Provider == SecretProviderSSM { return true } } return false } 
func ( c * Container ) ShouldCreateWithASMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } for _ , secret := range c . Secrets { if secret . Provider == SecretProviderASM { return true } } return false } 
func ( c * Container ) MergeEnvironmentVariables ( envVars map [ string ] string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) } for k , v := range envVars { c . Environment [ k ] = v } } 
func DecodeData ( data [ ] byte , dec TypeDecoder ) ( interface { } , string , error ) { raw := & ReceivedMessage { } if err != nil || raw . Type == " " { if decodeErr == nil && connErrType != " " { return connErr , connErrType , nil } return nil , " " , decodeErr } reqMessage , ok := dec . NewOfType ( raw . Type ) if ! ok { return nil , raw . Type , & UnrecognizedWSRequestType { raw . Type } } err = jsonutil . UnmarshalJSON ( reqMessage , bytes . NewReader ( raw . Message ) ) return reqMessage , raw . Type , err } 
func DecodeConnectionError ( data [ ] byte , dec TypeDecoder ) ( interface { } , string , error ) { var acsErr map [ string ] string err := json . Unmarshal ( data , & acsErr ) if err != nil { return nil , " " , & UndecodableMessage { string ( data ) } } if len ( acsErr ) != 1 { return nil , " " , & UndecodableMessage { string ( data ) } } var typeStr string for key := range acsErr { typeStr = key } errType , ok := dec . NewOfType ( typeStr ) if ! ok { return nil , typeStr , & UnrecognizedWSRequestType { } } val := reflect . ValueOf ( errType ) if val . Kind ( ) != reflect . Ptr { return nil , typeStr , & UnrecognizedWSRequestType { " " + val . Kind ( ) . String ( ) } } ret := reflect . New ( val . Elem ( ) . Type ( ) ) retObj := ret . Elem ( ) if retObj . Kind ( ) != reflect . Struct { return nil , typeStr , & UnrecognizedWSRequestType { " " + retObj . Kind ( ) . String ( ) } } msgField := retObj . FieldByName ( " " ) if ! msgField . IsValid ( ) { return nil , typeStr , & UnrecognizedWSRequestType { " " } } if msgField . IsValid ( ) && msgField . CanSet ( ) { msgStr := acsErr [ typeStr ] msgStrVal := reflect . ValueOf ( & msgStr ) if ! msgStrVal . Type ( ) . AssignableTo ( msgField . Type ( ) ) { return nil , typeStr , & UnrecognizedWSRequestType { " " } } msgField . Set ( msgStrVal ) return ret . Interface ( ) , typeStr , nil } return nil , typeStr , & UnrecognizedWSRequestType { " " } } 
func getTaskIDfromARN ( taskARN string ) ( string , error ) { colonSplitARN := strings . SplitN ( taskARN , " " , 6 ) } arnTaskPartSplit := strings . SplitN ( colonSplitARN [ 5 ] , " " , 2 ) } return arnTaskPartSplit [ 1 ] , nil } 
func getMetadataFilePath ( taskARN string , containerName string , dataDir string ) ( string , error ) { taskID , err := getTaskIDfromARN ( taskARN ) } return filepath . Join ( dataDir , metadataJoinSuffix , taskID , containerName ) , nil } 
func getTaskMetadataDir ( taskARN string , dataDir string ) ( string , error ) { taskID , err := getTaskIDfromARN ( taskARN ) if err != nil { return " " , fmt . Errorf ( " " , err ) } return filepath . Join ( dataDir , metadataJoinSuffix , taskID ) , err } 
func ( b Conditional ) MarshalJSON ( ) ( [ ] byte , error ) { switch b { case ExplicitlyEnabled : return json . Marshal ( true ) case ExplicitlyDisabled : return json . Marshal ( false ) default : return json . Marshal ( nil ) } } 
func ( b * Conditional ) UnmarshalJSON ( jsonData [ ] byte ) error { jsonString := string ( jsonData ) jsonBool , err := strconv . ParseBool ( jsonString ) if err != nil && jsonString != " " { return err } if jsonString == " " || jsonString == " " { * b = DefaultEnabled } else if jsonBool { * b = ExplicitlyEnabled } else { * b = ExplicitlyDisabled } return nil } 
func NewASMSecretResource ( taskARN string , asmSecrets map [ string ] apicontainer . Secret , executionCredentialsID string , credentialsManager credentials . Manager , asmClientCreator factory . ClientCreator ) * ASMSecretResource { s := & ASMSecretResource { taskARN : taskARN , requiredSecrets : asmSecrets , credentialsManager : credentialsManager , executionCredentialsID : executionCredentialsID , asmClientCreator : asmClientCreator , } s . initStatusToTransition ( ) return s } 
func ( secret * ASMSecretResource ) SetDesiredStatus ( status resourcestatus . ResourceStatus ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . desiredStatusUnsafe = status } 
func ( secret * ASMSecretResource ) GetDesiredStatus ( ) resourcestatus . ResourceStatus { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desiredStatusUnsafe } 
func ( secret * ASMSecretResource ) GetName ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return ResourceName } 
func ( secret * ASMSecretResource ) DesiredTerminal ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desiredStatusUnsafe == resourcestatus . ResourceStatus ( ASMSecretRemoved ) } 
func ( secret * ASMSecretResource ) KnownCreated ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . knownStatusUnsafe == resourcestatus . ResourceStatus ( ASMSecretCreated ) } 
func ( secret * ASMSecretResource ) SetKnownStatus ( status resourcestatus . ResourceStatus ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . knownStatusUnsafe = status secret . updateAppliedStatusUnsafe ( status ) } 
func ( secret * ASMSecretResource ) updateAppliedStatusUnsafe ( knownStatus resourcestatus . ResourceStatus ) { if secret . appliedStatus == resourcestatus . ResourceStatus ( ASMSecretStatusNone ) { return } } } 
func ( secret * ASMSecretResource ) SetAppliedStatus ( status resourcestatus . ResourceStatus ) bool { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . appliedStatus != resourcestatus . ResourceStatus ( ASMSecretStatusNone ) { } secret . appliedStatus = status return true } 
func ( secret * ASMSecretResource ) GetKnownStatus ( ) resourcestatus . ResourceStatus { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . knownStatusUnsafe } 
func ( secret * ASMSecretResource ) StatusString ( status resourcestatus . ResourceStatus ) string { return ASMSecretStatus ( status ) . String ( ) } 
func ( secret * ASMSecretResource ) Create ( ) error { if ! ok { secret . setTerminalReason ( err . Error ( ) ) return err } iamCredentials := executionCredentials . GetIAMRoleCredentials ( ) var wg sync . WaitGroup seelog . Infof ( " " , secret . taskARN ) secret . secretData = make ( map [ string ] string ) for _ , asmsecret := range secret . getRequiredSecrets ( ) { wg . Add ( 1 ) } wg . Wait ( ) close ( errorEvents ) if len ( errorEvents ) > 0 { var terminalReasons [ ] string for err := range errorEvents { terminalReasons = append ( terminalReasons , err . Error ( ) ) } errorString := strings . Join ( terminalReasons , " " ) secret . setTerminalReason ( errorString ) return errors . New ( errorString ) } return nil } 
func ( secret * ASMSecretResource ) retrieveASMSecretValue ( apiSecret apicontainer . Secret , iamCredentials credentials . IAMRoleCredentials , wg * sync . WaitGroup , errorEvents chan error ) { defer wg . Done ( ) asmClient := secret . asmClientCreator . NewASMClient ( apiSecret . Region , iamCredentials ) seelog . Infof ( " " , apiSecret . ValueFrom , apiSecret . Region , secret . taskARN ) if err != nil { errorEvents <- fmt . Errorf ( " " , apiSecret . Region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . secretData [ secretKey ] = secretValue } 
func ( secret * ASMSecretResource ) getRequiredSecrets ( ) map [ string ] apicontainer . Secret { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . requiredSecrets } 
func ( secret * ASMSecretResource ) getExecutionCredentialsID ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . executionCredentialsID } 
func ( secret * ASMSecretResource ) clearASMSecretValue ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key := range secret . secretData { delete ( secret . secretData , key ) } } 
func ( secret * ASMSecretResource ) MarshalJSON ( ) ( [ ] byte , error ) { if secret == nil { return nil , errors . New ( " " ) } createdAt := secret . GetCreatedAt ( ) return json . Marshal ( ASMSecretResourceJSON { TaskARN : secret . taskARN , CreatedAt : & createdAt , DesiredStatus : func ( ) * ASMSecretStatus { desiredState := secret . GetDesiredStatus ( ) s := ASMSecretStatus ( desiredState ) return & s } ( ) , KnownStatus : func ( ) * ASMSecretStatus { knownState := secret . GetKnownStatus ( ) s := ASMSecretStatus ( knownState ) return & s } ( ) , RequiredSecrets : secret . getRequiredSecrets ( ) , ExecutionCredentialsID : secret . getExecutionCredentialsID ( ) , } ) } 
func ( secret * ASMSecretResource ) UnmarshalJSON ( b [ ] byte ) error { temp := ASMSecretResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } if temp . DesiredStatus != nil { secret . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { secret . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } if temp . CreatedAt != nil && ! temp . CreatedAt . IsZero ( ) { secret . SetCreatedAt ( * temp . CreatedAt ) } if temp . RequiredSecrets != nil { secret . requiredSecrets = temp . RequiredSecrets } secret . taskARN = temp . TaskARN secret . executionCredentialsID = temp . ExecutionCredentialsID return nil } 
func ( c * control ) Create ( cgroupSpec * Spec ) ( cgroups . Cgroup , error ) { if err != nil { return nil , errors . Wrapf ( err , " " ) } controller , err := c . New ( cgroups . V1 , cgroups . StaticPath ( cgroupSpec . Root ) , cgroupSpec . Specs ) if err != nil { return nil , errors . Wrapf ( err , " " ) } return controller , nil } 
func ( c * control ) Remove ( cgroupPath string ) error { seelog . Debugf ( " " , cgroupPath ) controller , err := c . Load ( cgroups . V1 , cgroups . StaticPath ( cgroupPath ) ) if err != nil { return errors . Wrapf ( err , " " ) } if err != nil { return errors . Wrapf ( err , " " ) } return nil } 
func ( c * control ) Exists ( cgroupPath string ) bool { seelog . Debugf ( " " , cgroupPath ) controller , err := c . Load ( cgroups . V1 , cgroups . StaticPath ( cgroupPath ) ) if err != nil || controller == nil { return false } return true } 
func validateCgroupSpec ( cgroupSpec * Spec ) error { if cgroupSpec == nil { return errors . New ( " " ) } if cgroupSpec . Root == " " { return errors . New ( " " ) } } return nil } 
func handleInactivityTimeout ( reader io . ReadCloser , timeout time . Duration , cancelRequest func ( ) , canceled * uint32 ) ( io . ReadCloser , chan <- struct { } ) { done := make ( chan struct { } ) proxyReader := & proxyReader { ReadCloser : reader } go func ( ) { var lastCallCount uint64 for { select { case <- time . After ( timeout ) : case <- done : return } curCallCount := proxyReader . callCount ( ) if curCallCount == lastCallCount { atomic . AddUint32 ( canceled , 1 ) cancelRequest ( ) return } lastCallCount = curCallCount } } ( ) return proxyReader , done } 
func NewImageManager ( cfg * config . Config , client dockerapi . DockerClient , state dockerstate . TaskEngineState ) ImageManager { return & dockerImageManager { client : client , state : state , minimumAgeBeforeDeletion : cfg . MinimumImageDeletionAge , numImagesToDelete : cfg . NumImagesToDeletePerCycle , imageCleanupTimeInterval : cfg . ImageCleanupInterval , imagePullBehavior : cfg . ImagePullBehavior , imageCleanupExclusionList : cfg . ImageCleanupExclusionList , deleteNonECSImagesEnabled : cfg . DeleteNonECSImagesEnabled , nonECSContainerCleanupWaitDuration : cfg . TaskCleanupWaitDuration , numNonECSContainersToDelete : cfg . NumNonECSContainersToDeletePerCycle , } } 
func ( imageManager * dockerImageManager ) RecordContainerReference ( container * apicontainer . Container ) error { } return nil } if container . Image == " " { return fmt . Errorf ( " " ) } if err != nil { seelog . Errorf ( " " , container . Image , err ) return err } container . ImageID = imageInspected . ID added := imageManager . addContainerReferenceToExistingImageState ( container ) if ! added { imageManager . addContainerReferenceToNewImageState ( container , imageInspected . Size ) } return nil } 
func ( imageManager * dockerImageManager ) RemoveContainerReferenceFromImageState ( container * apicontainer . Container ) error { defer imageManager . updateLock . RUnlock ( ) if container . ImageID == " " { return fmt . Errorf ( " " ) } if ! ok { return fmt . Errorf ( " " ) } } 
func ( imageManager * dockerImageManager ) getImageState ( containerImageID string ) ( * image . ImageState , bool ) { for _ , imageState := range imageManager . getAllImageStates ( ) { if imageState . Image . ImageID == containerImageID { return imageState , true } } return nil , false } 
func ( imageManager * dockerImageManager ) removeImageState ( imageStateToBeRemoved * image . ImageState ) { for i , imageState := range imageManager . imageStates { if imageState . Image . ImageID == imageStateToBeRemoved . Image . ImageID { imageManager . imageStates = append ( imageManager . imageStates [ : i ] , imageManager . imageStates [ i + 1 : ] ... ) return } } } 
func ( cfg * Config ) Merge ( rhs Config ) * Config { left := reflect . ValueOf ( cfg ) . Elem ( ) right := reflect . ValueOf ( & rhs ) . Elem ( ) for i := 0 ; i < left . NumField ( ) ; i ++ { leftField := left . Field ( i ) if utils . ZeroOrNil ( leftField . Interface ( ) ) { leftField . Set ( reflect . ValueOf ( right . Field ( i ) . Interface ( ) ) ) } } return cfg } 
func NewConfig ( ec2client ec2 . EC2MetadataClient ) ( * Config , error ) { var errs [ ] error envConfig , err := environmentConfig ( ) if err != nil { errs = append ( errs , err ) } config := & envConfig if config . complete ( ) { } fcfg , err := fileConfig ( ) if err != nil { errs = append ( errs , err ) } config . Merge ( fcfg ) config . Merge ( userDataConfig ( ec2client ) ) if config . AWSRegion == " " { if config . NoIID { if err != nil { errs = append ( errs , err ) } config . AWSRegion = awsRegion } else { } } return config , config . mergeDefaultConfig ( errs ) } 
func ( cfg * Config ) trimWhitespace ( ) { cfgElem := reflect . ValueOf ( cfg ) . Elem ( ) cfgStructField := reflect . Indirect ( reflect . ValueOf ( cfg ) ) . Type ( ) for i := 0 ; i < cfgElem . NumField ( ) ; i ++ { cfgField := cfgElem . Field ( i ) if ! cfgField . CanInterface ( ) { continue } trimTag := cfgStructField . Field ( i ) . Tag . Get ( " " ) if len ( trimTag ) == 0 { continue } if cfgField . Kind ( ) != reflect . String { seelog . Warnf ( " " , cfgField . Kind ( ) . String ( ) , i ) continue } str := cfgField . Interface ( ) . ( string ) cfgField . SetString ( strings . TrimSpace ( str ) ) } } 
func ( cfg * Config ) validateAndOverrideBounds ( ) error { err := cfg . checkMissingAndDepreciated ( ) if err != nil { return err } if cfg . DockerStopTimeout < minimumDockerStopTimeout { return fmt . Errorf ( " " , cfg . DockerStopTimeout . String ( ) ) } if cfg . ContainerStartTimeout < minimumContainerStartTimeout { return fmt . Errorf ( " " , cfg . ContainerStartTimeout . String ( ) ) } var badDrivers [ ] string for _ , driver := range cfg . AvailableLoggingDrivers { _ , ok := dockerclient . LoggingDriverMinimumVersion [ driver ] if ! ok { badDrivers = append ( badDrivers , string ( driver ) ) } } if len ( badDrivers ) > 0 { return errors . New ( " " + strings . Join ( badDrivers , " " ) ) } cfg . TaskCleanupWaitDuration = DefaultTaskCleanupWaitDuration } if cfg . ImagePullInactivityTimeout < minimumImagePullInactivityTimeout { seelog . Warnf ( " " , defaultImagePullInactivityTimeout . String ( ) , cfg . ImagePullInactivityTimeout , minimumImagePullInactivityTimeout ) cfg . ImagePullInactivityTimeout = defaultImagePullInactivityTimeout } if cfg . ImageCleanupInterval < minimumImageCleanupInterval { seelog . Warnf ( " " , DefaultImageCleanupTimeInterval . String ( ) , cfg . ImageCleanupInterval , minimumImageCleanupInterval ) cfg . ImageCleanupInterval = DefaultImageCleanupTimeInterval } if cfg . NumImagesToDeletePerCycle < minimumNumImagesToDeletePerCycle { seelog . Warnf ( " " , DefaultImageDeletionAge , cfg . NumImagesToDeletePerCycle , minimumNumImagesToDeletePerCycle ) cfg . NumImagesToDeletePerCycle = DefaultNumImagesToDeletePerCycle } if cfg . TaskMetadataSteadyStateRate <= 0 || cfg . TaskMetadataBurstRate <= 0 { seelog . Warnf ( " " , DefaultTaskMetadataSteadyStateRate , DefaultTaskMetadataBurstRate ) cfg . TaskMetadataSteadyStateRate = DefaultTaskMetadataSteadyStateRate cfg . TaskMetadataBurstRate = DefaultTaskMetadataBurstRate } cfg . platformOverrides ( ) return nil } 
func ( cfg * Config ) checkMissingAndDepreciated ( ) error { cfgElem := reflect . ValueOf ( cfg ) . Elem ( ) cfgStructField := reflect . Indirect ( reflect . ValueOf ( cfg ) ) . Type ( ) fatalFields := [ ] string { } for i := 0 ; i < cfgElem . NumField ( ) ; i ++ { cfgField := cfgElem . Field ( i ) if utils . ZeroOrNil ( cfgField . Interface ( ) ) { missingTag := cfgStructField . Field ( i ) . Tag . Get ( " " ) if len ( missingTag ) == 0 { continue } switch missingTag { case " " : seelog . Warnf ( " " , cfgStructField . Field ( i ) . Name ) case " " : seelog . Criticalf ( " " , cfgStructField . Field ( i ) . Name ) fatalFields = append ( fatalFields , cfgStructField . Field ( i ) . Name ) default : seelog . Warnf ( " " , missingTag ) } } else { if len ( deprecatedTag ) == 0 { continue } seelog . Warnf ( " " , cfgStructField . Field ( i ) . Name , deprecatedTag ) } } if len ( fatalFields ) > 0 { return errors . New ( " " + strings . Join ( fatalFields , " " ) ) } return nil } 
func ( cfg * Config ) complete ( ) bool { cfgElem := reflect . ValueOf ( cfg ) . Elem ( ) for i := 0 ; i < cfgElem . NumField ( ) ; i ++ { if utils . ZeroOrNil ( cfgElem . Field ( i ) . Interface ( ) ) { return false } } return true } 
func userDataConfig ( ec2Client ec2 . EC2MetadataClient ) Config { type userDataParser struct { Config Config `json:"ECSAgentConfiguration"` } parsedUserData := userDataParser { Config : Config { } , } userData , err := ec2Client . GetUserData ( ) if err != nil { seelog . Warnf ( " " , err ) } if err != nil { seelog . Debugf ( " " , err ) } return parsedUserData . Config } 
func environmentConfig ( ) ( Config , error ) { dataDir := os . Getenv ( " " ) steadyStateRate , burstRate := parseTaskMetadataThrottles ( ) var errs [ ] error instanceAttributes , errs := parseInstanceAttributes ( errs ) containerInstanceTags , errs := parseContainerInstanceTags ( errs ) additionalLocalRoutes , errs := parseAdditionalLocalRoutes ( errs ) var err error if len ( errs ) > 0 { err = apierrors . NewMultiError ( errs ... ) } return Config { Cluster : os . Getenv ( " " ) , APIEndpoint : os . Getenv ( " " ) , AWSRegion : os . Getenv ( " " ) , DockerEndpoint : os . Getenv ( " " ) , ReservedPorts : parseReservedPorts ( " " ) , ReservedPortsUDP : parseReservedPorts ( " " ) , DataDir : dataDir , Checkpoint : parseCheckpoint ( dataDir ) , EngineAuthType : os . Getenv ( " " ) , EngineAuthData : NewSensitiveRawMessage ( [ ] byte ( os . Getenv ( " " ) ) ) , UpdatesEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , UpdateDownloadDir : os . Getenv ( " " ) , DisableMetrics : utils . ParseBool ( os . Getenv ( " " ) , false ) , ReservedMemory : parseEnvVariableUint16 ( " " ) , AvailableLoggingDrivers : parseAvailableLoggingDrivers ( ) , PrivilegedDisabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , SELinuxCapable : utils . ParseBool ( os . Getenv ( " " ) , false ) , AppArmorCapable : utils . ParseBool ( os . Getenv ( " " ) , false ) , TaskCleanupWaitDuration : parseEnvVariableDuration ( " " ) , TaskENIEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , TaskIAMRoleEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , DeleteNonECSImagesEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , TaskCPUMemLimit : parseTaskCPUMemLimitEnabled ( ) , DockerStopTimeout : parseDockerStopTimeout ( ) , ContainerStartTimeout : parseContainerStartTimeout ( ) , ImagePullInactivityTimeout : parseImagePullInactivityTimeout ( ) , CredentialsAuditLogFile : os . Getenv ( " " ) , CredentialsAuditLogDisabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , TaskIAMRoleEnabledForNetworkHost : utils . ParseBool ( os . Getenv ( " " ) , false ) , ImageCleanupDisabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , MinimumImageDeletionAge : parseEnvVariableDuration ( " " ) , ImageCleanupInterval : parseEnvVariableDuration ( " " ) , NumImagesToDeletePerCycle : parseNumImagesToDeletePerCycle ( ) , NumNonECSContainersToDeletePerCycle : parseNumNonECSContainersToDeletePerCycle ( ) , ImagePullBehavior : parseImagePullBehavior ( ) , ImageCleanupExclusionList : parseImageCleanupExclusionList ( " " ) , InstanceAttributes : instanceAttributes , CNIPluginsPath : os . Getenv ( " " ) , AWSVPCBlockInstanceMetdata : utils . ParseBool ( os . Getenv ( " " ) , false ) , AWSVPCAdditionalLocalRoutes : additionalLocalRoutes , ContainerMetadataEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , DataDirOnHost : os . Getenv ( " " ) , OverrideAWSLogsExecutionRole : utils . ParseBool ( os . Getenv ( " " ) , false ) , CgroupPath : os . Getenv ( " " ) , TaskMetadataSteadyStateRate : steadyStateRate , TaskMetadataBurstRate : burstRate , SharedVolumeMatchFullConfig : utils . ParseBool ( os . Getenv ( " " ) , false ) , ContainerInstanceTags : containerInstanceTags , ContainerInstancePropagateTagsFrom : parseContainerInstancePropagateTagsFrom ( ) , PollMetrics : utils . ParseBool ( os . Getenv ( " " ) , false ) , PollingMetricsWaitDuration : parseEnvVariableDuration ( " " ) , DisableDockerHealthCheck : utils . ParseBool ( os . Getenv ( " " ) , false ) , GPUSupportEnabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , NvidiaRuntime : os . Getenv ( " " ) , TaskMetadataAZDisabled : utils . ParseBool ( os . Getenv ( " " ) , false ) , } , err } 
func ( cfg * Config ) String ( ) string { return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , cfg . Cluster , cfg . AWSRegion , cfg . DataDir , cfg . Checkpoint , cfg . EngineAuthType , cfg . UpdatesEnabled , cfg . DisableMetrics , cfg . PollMetrics , cfg . PollingMetricsWaitDuration , cfg . ReservedMemory , cfg . TaskCleanupWaitDuration , cfg . DockerStopTimeout , cfg . ContainerStartTimeout , cfg . TaskCPUMemLimit , cfg . platformString ( ) , ) } 
func NewTaskStatsResponse ( taskARN string , state dockerstate . TaskEngineState , statsEngine stats . Engine ) ( map [ string ] * types . StatsJSON , error ) { containerMap , ok := state . ContainerMapByArn ( taskARN ) if ! ok { return nil , errors . Errorf ( " " , taskARN ) } resp := make ( map [ string ] * types . StatsJSON ) for _ , dockerContainer := range containerMap { containerID := dockerContainer . DockerID dockerStats , err := statsEngine . ContainerDockerStats ( taskARN , containerID ) if err != nil { seelog . Warnf ( " " , containerID , taskARN , err ) resp [ containerID ] = nil continue } resp [ containerID ] = dockerStats } return resp , nil } 
func NewSession ( ctx context . Context , config * config . Config , deregisterInstanceEventStream * eventstream . EventStream , containerInstanceArn string , credentialsProvider * credentials . Credentials , ecsClient api . ECSClient , taskEngineState dockerstate . TaskEngineState , stateManager statemanager . StateManager , taskEngine engine . TaskEngine , credentialsManager rolecredentials . Manager , taskHandler * eventhandler . TaskHandler ) Session { resources := newSessionResources ( credentialsProvider ) backoff := retry . NewExponentialBackoff ( connectionBackoffMin , connectionBackoffMax , connectionBackoffJitter , connectionBackoffMultiplier ) derivedContext , cancel := context . WithCancel ( ctx ) return & session { agentConfig : config , deregisterInstanceEventStream : deregisterInstanceEventStream , containerInstanceARN : containerInstanceArn , credentialsProvider : credentialsProvider , ecsClient : ecsClient , state : taskEngineState , stateManager : stateManager , taskEngine : taskEngine , credentialsManager : credentialsManager , taskHandler : taskHandler , ctx : derivedContext , cancel : cancel , backoff : backoff , resources : resources , _heartbeatTimeout : heartbeatTimeout , _heartbeatJitter : heartbeatJitter , _inactiveInstanceReconnectDelay : inactiveInstanceReconnectDelay , } } 
func ( acsSession * session ) Start ( ) error { } ( ) for { select { case <- connectToACS : seelog . Debugf ( " " ) if isInactiveInstance { err := acsSession . deregisterInstanceEventStream . WriteToEventStream ( struct { } { } ) if err != nil { seelog . Debugf ( " " , err ) } } if shouldReconnectWithoutBackoff ( acsError ) { acsSession . backoff . Reset ( ) sendEmptyMessageOnChannel ( connectToACS ) } else { seelog . Infof ( " " , reconnectDelay . String ( ) ) waitComplete := acsSession . waitForDuration ( reconnectDelay ) if waitComplete { } else { } } case <- acsSession . ctx . Done ( ) : seelog . Debugf ( " " ) return acsSession . ctx . Err ( ) } } } 
func ( acsSession * session ) startSessionOnce ( ) error { acsEndpoint , err := acsSession . ecsClient . DiscoverPollEndpoint ( acsSession . containerInstanceARN ) if err != nil { seelog . Errorf ( " " , err ) return err } url := acsWsURL ( acsEndpoint , acsSession . agentConfig . Cluster , acsSession . containerInstanceARN , acsSession . taskEngine , acsSession . resources ) client := acsSession . resources . createACSClient ( url , acsSession . agentConfig ) defer client . Close ( ) return acsSession . startACSSession ( client ) } 
func ( acsSession * session ) startACSSession ( client wsclient . ClientServer ) error { cfg := acsSession . agentConfig refreshCredsHandler := newRefreshCredentialsHandler ( acsSession . ctx , cfg . Cluster , acsSession . containerInstanceARN , client , acsSession . credentialsManager , acsSession . taskEngine ) defer refreshCredsHandler . clearAcks ( ) refreshCredsHandler . start ( ) defer refreshCredsHandler . stop ( ) client . AddRequestHandler ( refreshCredsHandler . handlerFunc ( ) ) eniAttachHandler . start ( ) defer eniAttachHandler . stop ( ) client . AddRequestHandler ( eniAttachHandler . handlerFunc ( ) ) payloadHandler . start ( ) defer payloadHandler . stop ( ) client . AddRequestHandler ( payloadHandler . handlerFunc ( ) ) updater . AddAgentUpdateHandlers ( client , cfg , acsSession . stateManager , acsSession . taskEngine ) err := client . Connect ( ) if err != nil { seelog . Errorf ( " " , err ) return err } seelog . Info ( " " ) defer timer . Stop ( ) acsSession . resources . connectedToACS ( ) backoffResetTimer := time . AfterFunc ( retry . AddJitter ( acsSession . heartbeatTimeout ( ) , acsSession . heartbeatJitter ( ) ) , func ( ) { } ) defer backoffResetTimer . Stop ( ) serveErr := make ( chan error , 1 ) go func ( ) { serveErr <- client . Serve ( ) } ( ) for { select { case <- acsSession . ctx . Done ( ) : case err := <- serveErr : } } } 
func ( acsSession * session ) waitForDuration ( delay time . Duration ) bool { reconnectTimer := time . NewTimer ( delay ) select { case <- reconnectTimer . C : return true case <- acsSession . ctx . Done ( ) : reconnectTimer . Stop ( ) return false } } 
func ( acsResources * acsSessionResources ) createACSClient ( url string , cfg * config . Config ) wsclient . ClientServer { return acsclient . New ( url , cfg , acsResources . credentialsProvider , wsRWTimeout ) } 
func acsWsURL ( endpoint , cluster , containerInstanceArn string , taskEngine engine . TaskEngine , acsSessionState sessionState ) string { acsURL := endpoint if endpoint [ len ( endpoint ) - 1 ] != '/' { acsURL += " " } acsURL += " " query := url . Values { } query . Set ( " " , cluster ) query . Set ( " " , containerInstanceArn ) query . Set ( " " , version . GitHashString ( ) ) query . Set ( " " , version . Version ) query . Set ( " " , " " ) if dockerVersion , err := taskEngine . Version ( ) ; err == nil { query . Set ( " " , " " + dockerVersion ) } query . Set ( sendCredentialsURLParameterName , acsSessionState . getSendCredentialsURLParameter ( ) ) return acsURL + " " + query . Encode ( ) } 
func newDisconnectionTimer ( client wsclient . ClientServer , timeout time . Duration , jitter time . Duration ) ttime . Timer { timer := time . AfterFunc ( retry . AddJitter ( timeout , jitter ) , func ( ) { seelog . Warn ( " " ) if err := client . Close ( ) ; err != nil { seelog . Warnf ( " " , err ) } seelog . Info ( " " ) } ) return timer } 
func anyMessageHandler ( timer ttime . Timer , client wsclient . ClientServer ) func ( interface { } ) { return func ( interface { } ) { seelog . Debug ( " " ) } } } 
func validateIPRules ( ) error { var iptable * iptables . IPTables var err error if iptable , err = iptables . NewWithProtocol ( iptables . ProtocolIPv4 ) ; err != nil { return err } fmt . Printf ( " " , str ) strs , _ := iptable . Stats ( " " , ingressChain ) for _ , str = range strs { fmt . Printf ( " " , str ) } strs , _ = iptable . Stats ( " " , egressChain ) for _ , str = range strs { fmt . Printf ( " " , str ) } if exist , err := iptable . Exists ( " " , ingressChain , " " , " " , " " , " " , " " , appPorts , " " , " " , " " , proxyIngressPort ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , ingressChain ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , egressChain , " " , " " , " " , gid , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , egressChain , " " , " " , " " , " " , " " , egressIgnoredPorts , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , egressChain , " " , " " , " " , egressIgnoredIPv4Addresses , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , egressChain , " " , " " , " " , " " , " " , proxyEgressPort ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err := iptable . Exists ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , egressChain ) ; ! exist { return fmt . Errorf ( " \n " , err ) } return nil } 
func WriteJSONToResponse ( w http . ResponseWriter , httpStatusCode int , responseJSON [ ] byte , requestType string ) { w . Header ( ) . Set ( " " , " " ) w . WriteHeader ( httpStatusCode ) _ , err := w . Write ( responseJSON ) if err != nil { seelog . Errorf ( " " , requestType ) } } 
func ValueFromRequest ( r * http . Request , field string ) ( string , bool ) { values := r . URL . Query ( ) _ , exists := values [ field ] return values . Get ( field ) , exists } 
func GetMuxValueFromRequest ( r * http . Request , gorillaMuxName string ) ( string , bool ) { vars := mux . Vars ( r ) val , ok := vars [ gorillaMuxName ] return val , ok } 
func ConstructMuxVar ( name string , pattern string ) string { if pattern == " " { return " " + name + " " } return " " + name + " " + pattern + " " } 
func LimitReachedHandler ( auditLogger audit . AuditLogger ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { logRequest := request . LogRequest { Request : r , } auditLogger . Log ( logRequest , http . StatusTooManyRequests , " " ) } } 
func ( td * TransitionDependenciesMap ) UnmarshalJSON ( b [ ] byte ) error { depMap := make ( map [ apicontainerstatus . ContainerStatus ] TransitionDependencySet ) err := json . Unmarshal ( b , & depMap ) if err == nil { * td = depMap return nil } seelog . Debugf ( " " , string ( b ) , err ) if err := json . Unmarshal ( b , & tdSet ) ; err != nil { return errors . Wrapf ( err , " " ) } for _ , dep := range tdSet . ContainerDependencies { dependentStatus := dep . DependentStatus if _ , ok := depMap [ dependentStatus ] ; ! ok { depMap [ dependentStatus ] = TransitionDependencySet { } } deps := depMap [ dependentStatus ] deps . ContainerDependencies = append ( deps . ContainerDependencies , dep ) depMap [ dependentStatus ] = deps } * td = depMap return nil } 
func ( s * SequentialWaitGroup ) Add ( sequence int64 , delta int ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) _ , ok := s . semaphores [ sequence ] if ok { s . semaphores [ sequence ] += delta } else { s . semaphores [ sequence ] = delta } if s . semaphores [ sequence ] <= 0 { delete ( s . semaphores , sequence ) s . change . Broadcast ( ) } } 
func ( s * SequentialWaitGroup ) Done ( sequence int64 ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) _ , ok := s . semaphores [ sequence ] if ok { s . semaphores [ sequence ] -- if s . semaphores [ sequence ] == 0 { delete ( s . semaphores , sequence ) s . change . Broadcast ( ) } } } 
func ( s * SequentialWaitGroup ) Wait ( sequence int64 ) { waitOver := func ( ) bool { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) for storedSequence := range s . semaphores { if storedSequence <= sequence { } } return true } s . change . L . Lock ( ) defer s . change . L . Unlock ( ) } } 
func NewMockCgroup ( ctrl * gomock . Controller ) * MockCgroup { mock := & MockCgroup { ctrl : ctrl } mock . recorder = & MockCgroupMockRecorder { mock } return mock } 
func ( m * MockCgroup ) Add ( arg0 cgroups . Process ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockCgroupMockRecorder ) Add ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCgroup ) ( nil ) . Add ) , arg0 ) } 
func ( mr * MockCgroupMockRecorder ) Delete ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCgroup ) ( nil ) . Delete ) ) } 
func ( m * MockCgroup ) MoveTo ( arg0 cgroups . Cgroup ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockCgroup ) New ( arg0 string , arg1 * specs_go . LinuxResources ) ( cgroups . Cgroup , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( cgroups . Cgroup ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCgroup ) OOMEventFD ( ) ( uintptr , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( uintptr ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCgroup ) Processes ( arg0 cgroups . Name , arg1 bool ) ( [ ] cgroups . Process , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] cgroups . Process ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCgroup ) Stat ( arg0 ... cgroups . ErrorHandler ) ( * cgroups . Stats , error ) { varargs := [ ] interface { } { } for _ , a := range arg0 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * cgroups . Stats ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCgroup ) State ( ) cgroups . State { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( cgroups . State ) return ret0 } 
func ( m * MockCgroup ) Subsystems ( ) [ ] cgroups . Subsystem { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] cgroups . Subsystem ) return ret0 } 
func ( m * MockCgroup ) Update ( arg0 * specs_go . LinuxResources ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func TaskStatsHandler ( state dockerstate . TaskEngineState , statsEngine stats . Engine ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { errResponseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } seelog . Infof ( " " , taskARN ) } } 
func GetKnownAPIVersions ( ) [ ] DockerVersion { return [ ] DockerVersion { Version_1_17 , Version_1_18 , Version_1_19 , Version_1_20 , Version_1_21 , Version_1_22 , Version_1_23 , Version_1_24 , Version_1_25 , Version_1_26 , Version_1_27 , Version_1_28 , Version_1_29 , Version_1_30 , Version_1_31 , Version_1_32 , } } 
func NewMockUdev ( ctrl * gomock . Controller ) * MockUdev { mock := & MockUdev { ctrl : ctrl } mock . recorder = & MockUdevMockRecorder { mock } return mock } 
func ( mr * MockUdevMockRecorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockUdev ) ( nil ) . Close ) ) } 
func ( m * MockUdev ) Monitor ( arg0 chan * udev . UEvent ) chan bool { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( chan bool ) return ret0 } 
func ( mr * MockUdevMockRecorder ) Monitor ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockUdev ) ( nil ) . Monitor ) , arg0 ) } 
func ( s * ContainerDefinition ) Validate ( ) error { invalidParams := request . ErrInvalidParams { Context : " " } if s . DependsOn != nil { for i , v := range s . DependsOn { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if s . ExtraHosts != nil { for i , v := range s . ExtraHosts { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if s . HealthCheck != nil { if err := s . HealthCheck . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if s . LinuxParameters != nil { if err := s . LinuxParameters . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if s . LogConfiguration != nil { if err := s . LogConfiguration . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if s . RepositoryCredentials != nil { if err := s . RepositoryCredentials . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if s . Secrets != nil { for i , v := range s . Secrets { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if s . Ulimits != nil { for i , v := range s . Ulimits { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if invalidParams . Len ( ) > 0 { return invalidParams } return nil } 
func ( s * ContainerDefinition ) SetInferenceDevices ( v [ ] * string ) * ContainerDefinition { s . InferenceDevices = v return s } 
func ( s * ContainerInstance ) SetClientToken ( v string ) * ContainerInstance { s . ClientToken = & v return s } 
func ( s * InferenceAccelerator ) Validate ( ) error { invalidParams := request . ErrInvalidParams { Context : " " } if s . DeviceName == nil { invalidParams . Add ( request . NewErrParamRequired ( " " ) ) } if s . DeviceType == nil { invalidParams . Add ( request . NewErrParamRequired ( " " ) ) } if invalidParams . Len ( ) > 0 { return invalidParams } return nil } 
func ( s * InferenceAccelerator ) SetDeviceName ( v string ) * InferenceAccelerator { s . DeviceName = & v return s } 
func ( s * InferenceAccelerator ) SetDeviceType ( v string ) * InferenceAccelerator { s . DeviceType = & v return s } 
func ( s * RegisterContainerInstanceInput ) SetClientToken ( v string ) * RegisterContainerInstanceInput { s . ClientToken = & v return s } 
func ( s * RegisterTaskDefinitionInput ) Validate ( ) error { invalidParams := request . ErrInvalidParams { Context : " " } if s . ContainerDefinitions == nil { invalidParams . Add ( request . NewErrParamRequired ( " " ) ) } if s . Family == nil { invalidParams . Add ( request . NewErrParamRequired ( " " ) ) } if s . ContainerDefinitions != nil { for i , v := range s . ContainerDefinitions { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if s . InferenceAccelerators != nil { for i , v := range s . InferenceAccelerators { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if s . ProxyConfiguration != nil { if err := s . ProxyConfiguration . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if s . Tags != nil { for i , v := range s . Tags { if v == nil { continue } if err := v . Validate ( ) ; err != nil { invalidParams . AddNested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . ErrInvalidParams ) ) } } } if invalidParams . Len ( ) > 0 { return invalidParams } return nil } 
func ( s * RegisterTaskDefinitionInput ) SetInferenceAccelerators ( v [ ] * InferenceAccelerator ) * RegisterTaskDefinitionInput { s . InferenceAccelerators = v return s } 
func ( s * RunTaskInput ) Validate ( ) error { invalidParams := request . ErrInvalidParams { Context : " " } if s . TaskDefinition == nil { invalidParams . Add ( request . NewErrParamRequired ( " " ) ) } if s . NetworkConfiguration != nil { if err := s . NetworkConfiguration . Validate ( ) ; err != nil { invalidParams . AddNested ( " " , err . ( request . ErrInvalidParams ) ) } } if invalidParams . Len ( ) > 0 { return invalidParams } return nil } 
func ( s * TaskDefinition ) SetInferenceAccelerators ( v [ ] * InferenceAccelerator ) * TaskDefinition { s . InferenceAccelerators = v return s } 
func DefaultConfig ( ) Config { return Config { DockerEndpoint : " " , ReservedPorts : [ ] uint16 { SSHPort , DockerReservedPort , DockerReservedSSLPort , AgentIntrospectionPort , AgentCredentialsPort } , ReservedPortsUDP : [ ] uint16 { } , DataDir : " " , DataDirOnHost : " " , DisableMetrics : false , ReservedMemory : 0 , AvailableLoggingDrivers : [ ] dockerclient . LoggingDriver { dockerclient . JSONFileDriver , dockerclient . NoneDriver } , TaskCleanupWaitDuration : DefaultTaskCleanupWaitDuration , DockerStopTimeout : defaultDockerStopTimeout , ContainerStartTimeout : defaultContainerStartTimeout , CredentialsAuditLogFile : defaultCredentialsAuditLogFile , CredentialsAuditLogDisabled : false , ImageCleanupDisabled : false , MinimumImageDeletionAge : DefaultImageDeletionAge , ImageCleanupInterval : DefaultImageCleanupTimeInterval , ImagePullInactivityTimeout : defaultImagePullInactivityTimeout , NumImagesToDeletePerCycle : DefaultNumImagesToDeletePerCycle , NumNonECSContainersToDeletePerCycle : DefaultNumNonECSContainersToDeletePerCycle , CNIPluginsPath : defaultCNIPluginsPath , PauseContainerTarballPath : pauseContainerTarballPath , PauseContainerImageName : DefaultPauseContainerImageName , PauseContainerTag : DefaultPauseContainerTag , AWSVPCBlockInstanceMetdata : false , ContainerMetadataEnabled : false , TaskCPUMemLimit : DefaultEnabled , CgroupPath : defaultCgroupPath , TaskMetadataSteadyStateRate : DefaultTaskMetadataSteadyStateRate , TaskMetadataBurstRate : DefaultTaskMetadataBurstRate , SharedVolumeMatchFullConfig : false , } 
func ( cfg * Config ) platformString ( ) string { } return " " } 
func MapContainerToTaskStatus ( knownState apicontainerstatus . ContainerStatus , steadyState apicontainerstatus . ContainerStatus ) TaskStatus { switch knownState { case apicontainerstatus . ContainerStatusNone : return TaskStatusNone case steadyState : return TaskRunning case apicontainerstatus . ContainerCreated : return TaskCreated case apicontainerstatus . ContainerStopped : return TaskStopped } if knownState == apicontainerstatus . ContainerRunning && steadyState == apicontainerstatus . ContainerResourcesProvisioned { return TaskCreated } return TaskStatusNone } 
func MapTaskToContainerStatus ( desiredState TaskStatus , steadyState apicontainerstatus . ContainerStatus ) apicontainerstatus . ContainerStatus { switch desiredState { case TaskStatusNone : return apicontainerstatus . ContainerStatusNone case TaskCreated : return apicontainerstatus . ContainerCreated case TaskRunning : return steadyState case TaskStopped : return apicontainerstatus . ContainerStopped } return apicontainerstatus . ContainerStatusNone } 
func ( me MultiErr ) Error ( ) string { ret := make ( [ ] string , len ( me . errors ) + 1 ) ret [ 0 ] = " " for ndx , err := range me . errors { ret [ ndx + 1 ] = fmt . Sprintf ( " \t " , ndx , err . Error ( ) ) } return strings . Join ( ret , " \n " ) } 
func NewMultiError ( errs ... error ) error { errors := make ( [ ] error , 0 , len ( errs ) ) for _ , err := range errs { if err != nil { errors = append ( errors , err ) } } return MultiErr { errors } } 
func ( auth * ECRAuthData ) GetPullCredentials ( ) credentials . IAMRoleCredentials { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . pullCredentials } 
func ( auth * ECRAuthData ) SetPullCredentials ( creds credentials . IAMRoleCredentials ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . pullCredentials = creds } 
func ( auth * ASMAuthData ) GetDockerAuthConfig ( ) types . AuthConfig { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . dockerAuthConfig } 
func ( auth * ASMAuthData ) SetDockerAuthConfig ( dac types . AuthConfig ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . dockerAuthConfig = dac } 
func NewMockSecretsManagerAPI ( ctrl * gomock . Controller ) * MockSecretsManagerAPI { mock := & MockSecretsManagerAPI { ctrl : ctrl } mock . recorder = & MockSecretsManagerAPIMockRecorder { mock } return mock } 
func ( m * MockSecretsManagerAPI ) CancelRotateSecret ( arg0 * secretsmanager . CancelRotateSecretInput ) ( * secretsmanager . CancelRotateSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CancelRotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockSecretsManagerAPIMockRecorder ) CancelRotateSecret ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockSecretsManagerAPI ) ( nil ) . CancelRotateSecret ) , arg0 ) } 
func ( m * MockSecretsManagerAPI ) CancelRotateSecretRequest ( arg0 * secretsmanager . CancelRotateSecretInput ) ( * request . Request , * secretsmanager . CancelRotateSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . CancelRotateSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) CancelRotateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . CancelRotateSecretInput , arg2 ... request . Option ) ( * secretsmanager . CancelRotateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CancelRotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) CreateSecret ( arg0 * secretsmanager . CreateSecretInput ) ( * secretsmanager . CreateSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CreateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) CreateSecretRequest ( arg0 * secretsmanager . CreateSecretInput ) ( * request . Request , * secretsmanager . CreateSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . CreateSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) CreateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . CreateSecretInput , arg2 ... request . Option ) ( * secretsmanager . CreateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . CreateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteResourcePolicy ( arg0 * secretsmanager . DeleteResourcePolicyInput ) ( * secretsmanager . DeleteResourcePolicyOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DeleteResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteResourcePolicyRequest ( arg0 * secretsmanager . DeleteResourcePolicyInput ) ( * request . Request , * secretsmanager . DeleteResourcePolicyOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . DeleteResourcePolicyOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteResourcePolicyWithContext ( arg0 aws . Context , arg1 * secretsmanager . DeleteResourcePolicyInput , arg2 ... request . Option ) ( * secretsmanager . DeleteResourcePolicyOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DeleteResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteSecret ( arg0 * secretsmanager . DeleteSecretInput ) ( * secretsmanager . DeleteSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DeleteSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteSecretRequest ( arg0 * secretsmanager . DeleteSecretInput ) ( * request . Request , * secretsmanager . DeleteSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . DeleteSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DeleteSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . DeleteSecretInput , arg2 ... request . Option ) ( * secretsmanager . DeleteSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DeleteSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DescribeSecret ( arg0 * secretsmanager . DescribeSecretInput ) ( * secretsmanager . DescribeSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DescribeSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DescribeSecretRequest ( arg0 * secretsmanager . DescribeSecretInput ) ( * request . Request , * secretsmanager . DescribeSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . DescribeSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) DescribeSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . DescribeSecretInput , arg2 ... request . Option ) ( * secretsmanager . DescribeSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . DescribeSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetRandomPassword ( arg0 * secretsmanager . GetRandomPasswordInput ) ( * secretsmanager . GetRandomPasswordOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetRandomPasswordOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetRandomPasswordRequest ( arg0 * secretsmanager . GetRandomPasswordInput ) ( * request . Request , * secretsmanager . GetRandomPasswordOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . GetRandomPasswordOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetRandomPasswordWithContext ( arg0 aws . Context , arg1 * secretsmanager . GetRandomPasswordInput , arg2 ... request . Option ) ( * secretsmanager . GetRandomPasswordOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetRandomPasswordOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetResourcePolicy ( arg0 * secretsmanager . GetResourcePolicyInput ) ( * secretsmanager . GetResourcePolicyOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetResourcePolicyRequest ( arg0 * secretsmanager . GetResourcePolicyInput ) ( * request . Request , * secretsmanager . GetResourcePolicyOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . GetResourcePolicyOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetResourcePolicyWithContext ( arg0 aws . Context , arg1 * secretsmanager . GetResourcePolicyInput , arg2 ... request . Option ) ( * secretsmanager . GetResourcePolicyOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetSecretValue ( arg0 * secretsmanager . GetSecretValueInput ) ( * secretsmanager . GetSecretValueOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetSecretValueRequest ( arg0 * secretsmanager . GetSecretValueInput ) ( * request . Request , * secretsmanager . GetSecretValueOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . GetSecretValueOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) GetSecretValueWithContext ( arg0 aws . Context , arg1 * secretsmanager . GetSecretValueInput , arg2 ... request . Option ) ( * secretsmanager . GetSecretValueOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . GetSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) ListSecretVersionIds ( arg0 * secretsmanager . ListSecretVersionIdsInput ) ( * secretsmanager . ListSecretVersionIdsOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . ListSecretVersionIdsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) ListSecretVersionIdsPages ( arg0 * secretsmanager . ListSecretVersionIdsInput , arg1 func ( * secretsmanager . ListSecretVersionIdsOutput , bool ) bool ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockSecretsManagerAPI ) ListSecretVersionIdsPagesWithContext ( arg0 aws . Context , arg1 * secretsmanager . ListSecretVersionIdsInput , arg2 func ( * secretsmanager . ListSecretVersionIdsOutput , bool ) bool , arg3 ... request . Option ) error { varargs := [ ] interface { } { arg0 , arg1 , arg2 } for _ , a := range arg3 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockSecretsManagerAPI ) ListSecretVersionIdsRequest ( arg0 * secretsmanager . ListSecretVersionIdsInput ) ( * request . Request , * secretsmanager . ListSecretVersionIdsOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . ListSecretVersionIdsOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) ListSecrets ( arg0 * secretsmanager . ListSecretsInput ) ( * secretsmanager . ListSecretsOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . ListSecretsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) ListSecretsPages ( arg0 * secretsmanager . ListSecretsInput , arg1 func ( * secretsmanager . ListSecretsOutput , bool ) bool ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockSecretsManagerAPI ) ListSecretsRequest ( arg0 * secretsmanager . ListSecretsInput ) ( * request . Request , * secretsmanager . ListSecretsOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . ListSecretsOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) ListSecretsWithContext ( arg0 aws . Context , arg1 * secretsmanager . ListSecretsInput , arg2 ... request . Option ) ( * secretsmanager . ListSecretsOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . ListSecretsOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutResourcePolicy ( arg0 * secretsmanager . PutResourcePolicyInput ) ( * secretsmanager . PutResourcePolicyOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutResourcePolicyRequest ( arg0 * secretsmanager . PutResourcePolicyInput ) ( * request . Request , * secretsmanager . PutResourcePolicyOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . PutResourcePolicyOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutResourcePolicyWithContext ( arg0 aws . Context , arg1 * secretsmanager . PutResourcePolicyInput , arg2 ... request . Option ) ( * secretsmanager . PutResourcePolicyOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutResourcePolicyOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutSecretValue ( arg0 * secretsmanager . PutSecretValueInput ) ( * secretsmanager . PutSecretValueOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutSecretValueRequest ( arg0 * secretsmanager . PutSecretValueInput ) ( * request . Request , * secretsmanager . PutSecretValueOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . PutSecretValueOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) PutSecretValueWithContext ( arg0 aws . Context , arg1 * secretsmanager . PutSecretValueInput , arg2 ... request . Option ) ( * secretsmanager . PutSecretValueOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . PutSecretValueOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RestoreSecret ( arg0 * secretsmanager . RestoreSecretInput ) ( * secretsmanager . RestoreSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RestoreSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RestoreSecretRequest ( arg0 * secretsmanager . RestoreSecretInput ) ( * request . Request , * secretsmanager . RestoreSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . RestoreSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RestoreSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . RestoreSecretInput , arg2 ... request . Option ) ( * secretsmanager . RestoreSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RestoreSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RotateSecret ( arg0 * secretsmanager . RotateSecretInput ) ( * secretsmanager . RotateSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RotateSecretRequest ( arg0 * secretsmanager . RotateSecretInput ) ( * request . Request , * secretsmanager . RotateSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . RotateSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) RotateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . RotateSecretInput , arg2 ... request . Option ) ( * secretsmanager . RotateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . RotateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) TagResource ( arg0 * secretsmanager . TagResourceInput ) ( * secretsmanager . TagResourceOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . TagResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) TagResourceRequest ( arg0 * secretsmanager . TagResourceInput ) ( * request . Request , * secretsmanager . TagResourceOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . TagResourceOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UntagResource ( arg0 * secretsmanager . UntagResourceInput ) ( * secretsmanager . UntagResourceOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UntagResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UntagResourceRequest ( arg0 * secretsmanager . UntagResourceInput ) ( * request . Request , * secretsmanager . UntagResourceOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . UntagResourceOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UntagResourceWithContext ( arg0 aws . Context , arg1 * secretsmanager . UntagResourceInput , arg2 ... request . Option ) ( * secretsmanager . UntagResourceOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UntagResourceOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UpdateSecret ( arg0 * secretsmanager . UpdateSecretInput ) ( * secretsmanager . UpdateSecretOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UpdateSecretRequest ( arg0 * secretsmanager . UpdateSecretInput ) ( * request . Request , * secretsmanager . UpdateSecretOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . UpdateSecretOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UpdateSecretVersionStage ( arg0 * secretsmanager . UpdateSecretVersionStageInput ) ( * secretsmanager . UpdateSecretVersionStageOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretVersionStageOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UpdateSecretVersionStageRequest ( arg0 * secretsmanager . UpdateSecretVersionStageInput ) ( * request . Request , * secretsmanager . UpdateSecretVersionStageOutput ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * request . Request ) ret1 , _ := ret [ 1 ] . ( * secretsmanager . UpdateSecretVersionStageOutput ) return ret0 , ret1 } 
func ( m * MockSecretsManagerAPI ) UpdateSecretVersionStageWithContext ( arg0 aws . Context , arg1 * secretsmanager . UpdateSecretVersionStageInput , arg2 ... request . Option ) ( * secretsmanager . UpdateSecretVersionStageOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretVersionStageOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockSecretsManagerAPIMockRecorder ) UpdateSecretVersionStageWithContext ( arg0 , arg1 interface { } , arg2 ... interface { } ) * gomock . Call { varargs := append ( [ ] interface { } { arg0 , arg1 } , arg2 ... ) return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockSecretsManagerAPI ) ( nil ) . UpdateSecretVersionStageWithContext ) , varargs ... ) } 
func ( m * MockSecretsManagerAPI ) UpdateSecretWithContext ( arg0 aws . Context , arg1 * secretsmanager . UpdateSecretInput , arg2 ... request . Option ) ( * secretsmanager . UpdateSecretOutput , error ) { varargs := [ ] interface { } { arg0 , arg1 } for _ , a := range arg2 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( * secretsmanager . UpdateSecretOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func createBindsEnv ( binds [ ] string , env [ ] string , dataDirOnHost string , metadataDirectoryPath string ) ( [ ] string , [ ] string ) { randID := uuid . New ( ) instanceBind := fmt . Sprintf ( `%s/%s:%s/%s` , dataDirOnHost , metadataDirectoryPath , mountPoint , randID ) metadataEnvVariable := fmt . Sprintf ( " " , metadataEnvironmentVariable , mountPoint , randID , metadataFile ) binds = append ( binds , instanceBind ) env = append ( env , metadataEnvVariable ) return binds , env } 
func writeToMetadataFile ( osWrap oswrapper . OS , ioutilWrap ioutilwrapper . IOUtil , data [ ] byte , taskARN string , containerName string , dataDir string ) error { metadataFileDir , err := getMetadataFilePath ( taskARN , containerName , dataDir ) } metadataFileName := filepath . Join ( metadataFileDir , metadataFile ) temp , err := ioutilWrap . TempFile ( metadataFileDir , tempFile ) if err != nil { return err } defer temp . Close ( ) _ , err = temp . Write ( data ) if err != nil { return err } err = temp . Chmod ( metadataPerm ) if err != nil { return err } return osWrap . Rename ( temp . Name ( ) , metadataFileName ) } 
func ( manager * metadataManager ) parseMetadataAtContainerCreate ( task * apitask . Task , containerName string ) Metadata { return Metadata { cluster : manager . cluster , taskMetadata : TaskMetadata { containerName : containerName , taskARN : task . Arn , taskDefinitionFamily : task . Family , taskDefinitionRevision : task . Version , } , containerInstanceARN : manager . containerInstanceARN , metadataStatus : MetadataInitial , availabilityZone : manager . availabilityZone , hostPublicIPv4Address : manager . hostPublicIPv4Address , } } 
func ( manager * metadataManager ) parseMetadata ( dockerContainer * types . ContainerJSON , task * apitask . Task , containerName string ) Metadata { dockerMD := parseDockerContainerMetadata ( task . Arn , containerName , dockerContainer ) return Metadata { cluster : manager . cluster , taskMetadata : TaskMetadata { containerName : containerName , taskARN : task . Arn , taskDefinitionFamily : task . Family , taskDefinitionRevision : task . Version , } , dockerContainerMetadata : dockerMD , containerInstanceARN : manager . containerInstanceARN , metadataStatus : MetadataReady , availabilityZone : manager . availabilityZone , hostPublicIPv4Address : manager . hostPublicIPv4Address , } } 
func parseDockerContainerMetadata ( taskARN string , containerName string , dockerContainer * types . ContainerJSON ) DockerContainerMetadata { if dockerContainer == nil { seelog . Warnf ( " " , taskARN , containerName ) return DockerContainerMetadata { } } if dockerContainer . Config != nil { imageNameFromConfig = dockerContainer . Config . Image } else { seelog . Warnf ( " " , taskARN , containerName ) } if dockerContainer . ContainerJSONBase == nil { seelog . Warnf ( " " , taskARN , containerName ) return DockerContainerMetadata { imageName : imageNameFromConfig , } } networkMetadata , err := parseNetworkMetadata ( dockerContainer . NetworkSettings , dockerContainer . HostConfig ) if err != nil { seelog . Warnf ( " " , taskARN , containerName , err ) } ports , err = apicontainer . PortBindingFromDockerPortBinding ( dockerContainer . NetworkSettings . Ports ) if err != nil { seelog . Warnf ( " " , taskARN , containerName , err ) } return DockerContainerMetadata { containerID : dockerContainer . ID , dockerContainerName : dockerContainer . Name , imageID : dockerContainer . Image , imageName : imageNameFromConfig , ports : ports , networkInfo : networkMetadata , } } 
func parseNetworkMetadata ( settings * types . NetworkSettings , hostConfig * dockercontainer . HostConfig ) ( NetworkMetadata , error ) { return NetworkMetadata { } , err } if hostConfig == nil { err := fmt . Errorf ( " " ) return NetworkMetadata { } , err } networkModeFromHostConfig := string ( hostConfig . NetworkMode ) if len ( settings . Networks ) > 0 { for modeFromSettings , containerNetwork := range settings . Networks { networkMode := modeFromSettings ipv4Addresses := [ ] string { containerNetwork . IPAddress } network := Network { NetworkMode : networkMode , IPv4Addresses : ipv4Addresses } networkList = append ( networkList , network ) } } else { ipv4Addresses := [ ] string { ipv4AddressFromSettings } network := Network { NetworkMode : networkModeFromHostConfig , IPv4Addresses : ipv4Addresses } networkList = append ( networkList , network ) } return NetworkMetadata { networks : networkList , } , nil } 
func ( n * NvidiaGPUManager ) Initialize ( ) error { if GPUInfoFileExists ( ) { if err != nil { return errors . Wrapf ( err , " " ) } var nvidiaGPUInfo NvidiaGPUManager err = json . Unmarshal ( gpuJSON , & nvidiaGPUInfo ) if err != nil { return errors . Wrapf ( err , " " ) } n . SetDriverVersion ( nvidiaGPUInfo . GetDriverVersion ( ) ) nvidiaGPUInfo . lock . RLock ( ) gpuIDs := nvidiaGPUInfo . GetGPUIDsUnsafe ( ) nvidiaGPUInfo . lock . RUnlock ( ) n . SetGPUIDs ( gpuIDs ) n . SetDevices ( ) } else { seelog . Error ( " " ) } return nil } 
func ( n * NvidiaGPUManager ) SetGPUIDs ( gpuIDs [ ] string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . GPUIDs = gpuIDs } 
func ( n * NvidiaGPUManager ) SetDriverVersion ( version string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . DriverVersion = version } 
func ( n * NvidiaGPUManager ) GetDriverVersion ( ) string { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . DriverVersion } 
func ( n * NvidiaGPUManager ) GetDevices ( ) [ ] * ecs . PlatformDevice { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . GPUDevices } 
func NewMockLicenseProvider ( ctrl * gomock . Controller ) * MockLicenseProvider { mock := & MockLicenseProvider { ctrl : ctrl } mock . recorder = & MockLicenseProviderMockRecorder { mock } return mock } 
func ( m * MockLicenseProvider ) GetText ( ) ( string , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockLicenseProviderMockRecorder ) GetText ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockLicenseProvider ) ( nil ) . GetText ) ) } 
func NewMockBackoff ( ctrl * gomock . Controller ) * MockBackoff { mock := & MockBackoff { ctrl : ctrl } mock . recorder = & MockBackoffMockRecorder { mock } return mock } 
func ( m * MockBackoff ) Duration ( ) time . Duration { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( time . Duration ) return ret0 } 
func ( mr * MockBackoffMockRecorder ) Duration ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockBackoff ) ( nil ) . Duration ) ) } 
func ( status * MetadataStatus ) UnmarshalText ( text [ ] byte ) error { t := string ( text ) switch t { case MetadataInitialText : * status = MetadataInitial case MetadataReadyText : * status = MetadataReady default : return fmt . Errorf ( " " , text ) } return nil } 
func ( * DefaultTime ) After ( d time . Duration ) <- chan time . Time { return time . After ( d ) } 
func ( * DefaultTime ) AfterFunc ( d time . Duration , f func ( ) ) Timer { return time . AfterFunc ( d , f ) } 
func Since ( t time . Time ) time . Duration { return _time . Now ( ) . Sub ( t ) } 
func NewMockTaskResource ( ctrl * gomock . Controller ) * MockTaskResource { mock := & MockTaskResource { ctrl : ctrl } mock . recorder = & MockTaskResourceMockRecorder { mock } return mock } 
func ( m * MockTaskResource ) ApplyTransition ( arg0 status0 . ResourceStatus ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockTaskResource ) Cleanup ( ) error { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockTaskResource ) GetCreatedAt ( ) time . Time { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( time . Time ) return ret0 } 
func ( m * MockTaskResource ) GetTerminalReason ( ) string { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( string ) return ret0 } 
func ( m * MockTaskResource ) Initialize ( arg0 * taskresource . ResourceFields , arg1 , arg2 status . TaskStatus ) { m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) } 
func ( mr * MockTaskResourceMockRecorder ) Initialize ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskResource ) ( nil ) . Initialize ) , arg0 , arg1 , arg2 ) } 
func ( m * MockTaskResource ) KnownCreated ( ) bool { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( mr * MockTaskResourceMockRecorder ) MarshalJSON ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskResource ) ( nil ) . MarshalJSON ) ) } 
func ( m * MockTaskResource ) NextKnownState ( ) status0 . ResourceStatus { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( status0 . ResourceStatus ) return ret0 } 
func ( m * MockTaskResource ) SetAppliedStatus ( arg0 status0 . ResourceStatus ) bool { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( mr * MockTaskResourceMockRecorder ) SetAppliedStatus ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskResource ) ( nil ) . SetAppliedStatus ) , arg0 ) } 
func ( m * MockTaskResource ) SetCreatedAt ( arg0 time . Time ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskResource ) SetDesiredStatus ( arg0 status0 . ResourceStatus ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskResource ) SetKnownStatus ( arg0 status0 . ResourceStatus ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskResource ) StatusString ( arg0 status0 . ResourceStatus ) string { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) return ret0 } 
func NewMockLoader ( ctrl * gomock . Controller ) * MockLoader { mock := & MockLoader { ctrl : ctrl } mock . recorder = & MockLoaderMockRecorder { mock } return mock } 
func ( m * MockLoader ) LoadImage ( arg0 context . Context , arg1 * config . Config , arg2 dockerapi . DockerClient ) ( * types . ImageInspect , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( * types . ImageInspect ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockLoaderMockRecorder ) LoadImage ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockLoader ) ( nil ) . LoadImage ) , arg0 , arg1 , arg2 ) } 
func ( cnferror ContainerNotFound ) Error ( ) string { return fmt . Sprintf ( " " , cnferror . ContainerName , cnferror . TaskArn ) } 
func ( event * DockerContainerChangeEvent ) String ( ) string { res := fmt . Sprintf ( " " , event . Status . String ( ) , event . DockerID ) res += " " + event . Health . Status . String ( ) if event . ExitCode != nil { res += fmt . Sprintf ( " " , aws . IntValue ( event . ExitCode ) ) } if len ( event . PortBindings ) != 0 { res += fmt . Sprintf ( " " , event . PortBindings ) } if event . Error != nil { res += " " + event . Error . Error ( ) } if len ( event . Volumes ) != 0 { res += fmt . Sprintf ( " " , event . Volumes ) } if len ( event . Labels ) != 0 { res += fmt . Sprintf ( " " , event . Labels ) } if ! event . CreatedAt . IsZero ( ) { res += " " + event . CreatedAt . String ( ) } if ! event . StartedAt . IsZero ( ) { res += " " + event . StartedAt . String ( ) } if ! event . FinishedAt . IsZero ( ) { res += " " + event . FinishedAt . String ( ) } return res } 
func ( tv * TaskVolume ) UnmarshalJSON ( b [ ] byte ) error { if err := json . Unmarshal ( b , & intermediate ) ; err != nil { return err } name , ok := intermediate [ " " ] if ! ok { return errors . New ( " " ) } if err := json . Unmarshal ( name , & tv . Name ) ; err != nil { return err } volumeType , ok := intermediate [ " " ] if ! ok { volumeType = [ ] byte ( `"host"` ) seelog . Infof ( " " ) } if err := json . Unmarshal ( volumeType , & tv . Type ) ; err != nil { return err } switch tv . Type { case HostVolumeType : return tv . unmarshalHostVolume ( intermediate [ " " ] ) case DockerVolumeType : return tv . unmarshalDockerVolume ( intermediate [ " " ] ) default : return errors . Errorf ( " " , tv . Type ) } } 
func ( tv * TaskVolume ) MarshalJSON ( ) ( [ ] byte , error ) { result := make ( map [ string ] interface { } ) if len ( tv . Type ) == 0 { tv . Type = HostVolumeType } result [ " " ] = tv . Name result [ " " ] = tv . Type switch tv . Type { case DockerVolumeType : result [ " " ] = tv . Volume case HostVolumeType : result [ " " ] = tv . Volume default : return nil , errors . Errorf ( " " , tv . Type ) } return json . Marshal ( result ) } 
func ( agent * ecsAgent ) checkCompatibility ( engine engine . TaskEngine ) error { } tasks , err := engine . ListTasks ( ) if err != nil { return err } for _ , task := range tasks { if ! task . MemoryCPULimitsEnabled { seelog . Warnf ( " " , task . Arn ) compatible = false break } } if compatible { return nil } if agent . cfg . TaskCPUMemLimit == config . ExplicitlyEnabled { return errors . New ( " " ) } seelog . Warn ( " " ) agent . cfg . TaskCPUMemLimit = config . ExplicitlyDisabled return nil } 
func ( * ssmClientCreator ) NewSSMClient ( region string , creds credentials . IAMRoleCredentials ) ssmclient . SSMClient { cfg := aws . NewConfig ( ) . WithHTTPClient ( httpclient . New ( roundtripTimeout , false ) ) . WithRegion ( region ) . WithCredentials ( awscreds . NewStaticCredentials ( creds . AccessKeyID , creds . SecretAccessKey , creds . SessionToken ) ) sess := session . Must ( session . NewSession ( cfg ) ) return ssm . New ( sess ) } 
func ( f * factory ) GetClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { for _ , v := range getWindowsReplaceableVersions ( ) { if v == version { version = minDockerAPIVersion break } } return f . getClient ( version ) } 
func getWindowsReplaceableVersions ( ) [ ] dockerclient . DockerVersion { return [ ] dockerclient . DockerVersion { dockerclient . Version_1_17 , dockerclient . Version_1_18 , dockerclient . Version_1_19 , dockerclient . Version_1_20 , dockerclient . Version_1_21 , dockerclient . Version_1_22 , dockerclient . Version_1_23 , } } 
func getWindowsSupportedVersions ( ) [ ] dockerclient . DockerVersion { return [ ] dockerclient . DockerVersion { dockerclient . Version_1_24 , dockerclient . Version_1_25 , dockerclient . Version_1_26 , dockerclient . Version_1_27 , dockerclient . Version_1_28 , dockerclient . Version_1_29 , dockerclient . Version_1_30 , } } 
func PortBindingFromDockerPortBinding ( dockerPortBindings nat . PortMap ) ( [ ] PortBinding , apierrors . NamedError ) { portBindings := make ( [ ] PortBinding , 0 , len ( dockerPortBindings ) ) for port , bindings := range dockerPortBindings { containerPort , err := nat . ParsePort ( port . Port ( ) ) if err != nil { return nil , & apierrors . DefaultNamedError { Name : UnparseablePortErrorName , Err : " " + err . Error ( ) } } protocol , err := NewTransportProtocol ( port . Proto ( ) ) if err != nil { return nil , & apierrors . DefaultNamedError { Name : UnrecognizedTransportProtocolErrorName , Err : err . Error ( ) } } for _ , binding := range bindings { hostPort , err := strconv . Atoi ( binding . HostPort ) if err != nil { return nil , & apierrors . DefaultNamedError { Name : UnparseablePortErrorName , Err : " " + err . Error ( ) } } portBindings = append ( portBindings , PortBinding { ContainerPort : uint16 ( containerPort ) , HostPort : uint16 ( hostPort ) , BindIP : binding . HostIP , Protocol : protocol , } ) } } return portBindings , nil } 
func NewASMAuthResource ( taskARN string , asmRequirements [ ] * apicontainer . ASMAuthData , executionCredentialsID string , credentialsManager credentials . Manager , asmClientCreator factory . ClientCreator ) * ASMAuthResource { c := & ASMAuthResource { taskARN : taskARN , requiredASMResources : asmRequirements , credentialsManager : credentialsManager , executionCredentialsID : executionCredentialsID , asmClientCreator : asmClientCreator , } c . initStatusToTransition ( ) return c } 
func ( auth * ASMAuthResource ) SetDesiredStatus ( status resourcestatus . ResourceStatus ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . desiredStatusUnsafe = status } 
func ( auth * ASMAuthResource ) GetDesiredStatus ( ) resourcestatus . ResourceStatus { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . desiredStatusUnsafe } 
func ( auth * ASMAuthResource ) GetName ( ) string { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return ResourceName } 
func ( auth * ASMAuthResource ) DesiredTerminal ( ) bool { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . desiredStatusUnsafe == resourcestatus . ResourceStatus ( ASMAuthStatusRemoved ) } 
func ( auth * ASMAuthResource ) KnownCreated ( ) bool { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . knownStatusUnsafe == resourcestatus . ResourceStatus ( ASMAuthStatusCreated ) } 
func ( auth * ASMAuthResource ) ApplyTransition ( nextState resourcestatus . ResourceStatus ) error { transitionFunc , ok := auth . resourceStatusToTransitionFunction [ nextState ] if ! ok { return errors . Errorf ( " " , auth . GetName ( ) , auth . StatusString ( nextState ) ) } return transitionFunc ( ) } 
func ( auth * ASMAuthResource ) SetKnownStatus ( status resourcestatus . ResourceStatus ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . knownStatusUnsafe = status auth . updateAppliedStatusUnsafe ( status ) } 
func ( auth * ASMAuthResource ) updateAppliedStatusUnsafe ( knownStatus resourcestatus . ResourceStatus ) { if auth . appliedStatus == resourcestatus . ResourceStatus ( ASMAuthStatusNone ) { return } } } 
func ( auth * ASMAuthResource ) SetAppliedStatus ( status resourcestatus . ResourceStatus ) bool { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) if auth . appliedStatus != resourcestatus . ResourceStatus ( ASMAuthStatusNone ) { } auth . appliedStatus = status return true } 
func ( auth * ASMAuthResource ) GetKnownStatus ( ) resourcestatus . ResourceStatus { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . knownStatusUnsafe } 
func ( auth * ASMAuthResource ) StatusString ( status resourcestatus . ResourceStatus ) string { return ASMAuthStatus ( status ) . String ( ) } 
func ( auth * ASMAuthResource ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . createdAt = createdAt } 
func ( auth * ASMAuthResource ) GetCreatedAt ( ) time . Time { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . createdAt } 
func ( auth * ASMAuthResource ) Create ( ) error { seelog . Infof ( " " , auth . taskARN ) if auth . dockerAuthData == nil { auth . dockerAuthData = make ( map [ string ] types . AuthConfig ) } for _ , a := range auth . GetRequiredASMResources ( ) { err := auth . retrieveASMDockerAuthData ( a ) if err != nil { auth . setTerminalReason ( err . Error ( ) ) return err } } return nil } 
func ( auth * ASMAuthResource ) GetRequiredASMResources ( ) [ ] * apicontainer . ASMAuthData { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . requiredASMResources } 
func ( auth * ASMAuthResource ) GetExecutionCredentialsID ( ) string { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . executionCredentialsID } 
func ( auth * ASMAuthResource ) clearASMDockerAuthConfig ( ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) for k := range auth . dockerAuthData { delete ( auth . dockerAuthData , k ) } } 
func ( auth * ASMAuthResource ) GetASMDockerAuthConfig ( secretID string ) ( types . AuthConfig , bool ) { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) d , ok := auth . dockerAuthData [ secretID ] return d , ok } 
func ( auth * ASMAuthResource ) MarshalJSON ( ) ( [ ] byte , error ) { if auth == nil { return nil , errors . New ( " " ) } createdAt := auth . GetCreatedAt ( ) return json . Marshal ( asmAuthResourceJSON { TaskARN : auth . taskARN , CreatedAt : & createdAt , DesiredStatus : func ( ) * ASMAuthStatus { desiredState := auth . GetDesiredStatus ( ) status := ASMAuthStatus ( desiredState ) return & status } ( ) , KnownStatus : func ( ) * ASMAuthStatus { knownState := auth . GetKnownStatus ( ) status := ASMAuthStatus ( knownState ) return & status } ( ) , RequiredASMResources : auth . GetRequiredASMResources ( ) , ExecutionCredentialsID : auth . GetExecutionCredentialsID ( ) , } ) } 
func ( auth * ASMAuthResource ) UnmarshalJSON ( b [ ] byte ) error { temp := asmAuthResourceJSON { } if err := json . Unmarshal ( b , & temp ) ; err != nil { return err } if temp . DesiredStatus != nil { auth . SetDesiredStatus ( resourcestatus . ResourceStatus ( * temp . DesiredStatus ) ) } if temp . KnownStatus != nil { auth . SetKnownStatus ( resourcestatus . ResourceStatus ( * temp . KnownStatus ) ) } if temp . CreatedAt != nil && ! temp . CreatedAt . IsZero ( ) { auth . SetCreatedAt ( * temp . CreatedAt ) } if temp . RequiredASMResources != nil { auth . requiredASMResources = temp . RequiredASMResources } auth . taskARN = temp . TaskARN auth . executionCredentialsID = temp . ExecutionCredentialsID return nil } 
func ContainerMetadataHandler ( state dockerstate . TaskEngineState ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { containerID , err := getContainerIDByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerMetadata ) return } containerResponse , err := GetContainerResponse ( containerID , state ) if err != nil { errResponseJSON , _ := json . Marshal ( err . Error ( ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerMetadata ) return } seelog . Infof ( " " , containerID ) responseJSON , _ := json . Marshal ( containerResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeContainerMetadata ) } } 
func GetContainerResponse ( containerID string , state dockerstate . TaskEngineState ) ( * v2 . ContainerResponse , error ) { containerResponse , err := v2 . NewContainerResponse ( containerID , state ) if err != nil { return nil , errors . Errorf ( " " , containerID ) } } } return containerResponse , nil } 
func GetContainerNetworkMetadata ( containerID string , state dockerstate . TaskEngineState ) ( [ ] containermetadata . Network , error ) { dockerContainer , ok := state . ContainerByID ( containerID ) if ! ok { return nil , errors . Errorf ( " " , containerID ) } if settings == nil { return nil , errors . Errorf ( " " , containerID ) } networkModeFromHostConfig := dockerContainer . Container . GetNetworkMode ( ) if len ( settings . Networks ) > 0 { for modeFromSettings , containerNetwork := range settings . Networks { networkMode := modeFromSettings ipv4Addresses := [ ] string { containerNetwork . IPAddress } network := containermetadata . Network { NetworkMode : networkMode , IPv4Addresses : ipv4Addresses } networks = append ( networks , network ) } } else { ipv4Addresses := [ ] string { ipv4AddressFromSettings } network := containermetadata . Network { NetworkMode : networkModeFromHostConfig , IPv4Addresses : ipv4Addresses } networks = append ( networks , network ) } return networks , nil } 
func ( cgroup * CgroupResource ) Initialize ( resourceFields * taskresource . ResourceFields , taskKnownStatus status . TaskStatus , taskDesiredStatus status . TaskStatus ) { } 
func StartDefaultTerminationHandler ( saver statemanager . Saver , taskEngine engine . TaskEngine ) { signalChannel := make ( chan os . Signal , 2 ) signal . Notify ( signalChannel , os . Interrupt , syscall . SIGTERM ) sig := <- signalChannel seelog . Debugf ( " " , sig . String ( ) ) err := FinalSave ( saver , taskEngine ) if err != nil { seelog . Criticalf ( " " , err ) } os . Exit ( exitcodes . ExitSuccess ) } 
func FinalSave ( saver statemanager . Saver , taskEngine engine . TaskEngine ) error { engineDisabled := make ( chan error ) disableTimer := time . AfterFunc ( engineDisableTimeout , func ( ) { engineDisabled <- errors . New ( " " ) } ) go func ( ) { seelog . Debug ( " " ) taskEngine . Disable ( ) disableTimer . Stop ( ) engineDisabled <- nil } ( ) disableErr := <- engineDisabled stateSaved := make ( chan error ) saveTimer := time . AfterFunc ( finalSaveTimeout , func ( ) { stateSaved <- errors . New ( " " ) } ) go func ( ) { seelog . Debug ( " " ) stateSaved <- saver . ForceSave ( ) saveTimer . Stop ( ) } ( ) saveErr := <- stateSaved if disableErr != nil || saveErr != nil { return apierrors . NewMultiError ( disableErr , saveErr ) } return nil } 
func ( key * cacheKey ) String ( ) string { return fmt . Sprintf ( " " , key . roleARN , key . region , key . registryID , key . endpointOverride ) } 
func NewECRAuthProvider ( ecrFactory ecr . ECRFactory , cache async . Cache ) DockerAuthProvider { return & ecrAuthProvider { tokenCache : cache , factory : ecrFactory , } } 
func ( authProvider * ecrAuthProvider ) GetAuthconfig ( image string , registryAuthData * apicontainer . RegistryAuthenticationData ) ( types . AuthConfig , error ) { if registryAuthData == nil { return types . AuthConfig { } , fmt . Errorf ( " " ) } authData := registryAuthData . ECRAuthData if authData == nil { return types . AuthConfig { } , fmt . Errorf ( " " ) } } if auth != nil { return * auth , nil } } 
func ( authProvider * ecrAuthProvider ) getAuthConfigFromCache ( key cacheKey ) * types . AuthConfig { token , ok := authProvider . tokenCache . Get ( key . String ( ) ) if ! ok { return nil } cachedToken , ok := token . ( * ecrapi . AuthorizationData ) if ! ok { log . Warnf ( " " ) return nil } if authProvider . IsTokenValid ( cachedToken ) { auth , err := extractToken ( cachedToken ) if err != nil { log . Errorf ( " " , err ) return nil } return & auth } else { } return nil } 
func ( authProvider * ecrAuthProvider ) getAuthConfigFromECR ( image string , key cacheKey , authData * apicontainer . ECRAuthData ) ( types . AuthConfig , error ) { if err != nil { return types . AuthConfig { } , err } log . Debugf ( " " , image ) ecrAuthData , err := client . GetAuthorizationToken ( authData . RegistryID ) if err != nil { return types . AuthConfig { } , err } if ecrAuthData == nil { return types . AuthConfig { } , fmt . Errorf ( " " , image ) } return extractToken ( ecrAuthData ) } return types . AuthConfig { } , fmt . Errorf ( " " , image ) } 
func ( authProvider * ecrAuthProvider ) IsTokenValid ( authData * ecrapi . AuthorizationData ) bool { if authData == nil || authData . ExpiresAt == nil { return false } refreshTime := aws . TimeValue ( authData . ExpiresAt ) . Add ( - 1 * retry . AddJitter ( MinimumJitterDuration , MinimumJitterDuration ) ) return time . Now ( ) . Before ( refreshTime ) } 
func createTaskResponse ( task * apitask . Task , found bool , resourceID string , state dockerstate . TaskEngineState ) ( [ ] byte , int ) { var responseJSON [ ] byte status := http . StatusOK if found { containerMap , _ := state . ContainerMapByArn ( task . Arn ) responseJSON , _ = json . Marshal ( NewTaskResponse ( task , containerMap ) ) } else { seelog . Warn ( " " + resourceID ) responseJSON , _ = json . Marshal ( & TaskResponse { } ) status = http . StatusNotFound } return responseJSON , status } 
func TaskContainerMetadataHandler ( taskEngine utils . DockerStateResolver ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { var responseJSON [ ] byte dockerTaskEngineState := taskEngine . State ( ) dockerID , dockerIDExists := utils . ValueFromRequest ( r , dockerIDQueryField ) taskArn , taskARNExists := utils . ValueFromRequest ( r , taskARNQueryField ) var status int if dockerIDExists && taskARNExists { seelog . Info ( " " , dockerIDQueryField , " " , taskARNQueryField , " " ) w . WriteHeader ( http . StatusBadRequest ) w . Write ( responseJSON ) return } if dockerIDExists { var found bool if len ( dockerID ) > dockerShortIDLen { task , found = dockerTaskEngineState . TaskByID ( dockerID ) } else { tasks , _ := dockerTaskEngineState . TaskByShortID ( dockerID ) if len ( tasks ) == 0 { task = nil found = false } else if len ( tasks ) == 1 { task = tasks [ 0 ] found = true } else { seelog . Info ( " " + dockerID ) w . WriteHeader ( http . StatusBadRequest ) w . Write ( responseJSON ) return } } responseJSON , status = createTaskResponse ( task , found , dockerID , dockerTaskEngineState ) w . WriteHeader ( status ) } else if taskARNExists { responseJSON , status = createTaskResponse ( task , found , taskArn , dockerTaskEngineState ) w . WriteHeader ( status ) } else { } w . Write ( responseJSON ) } } 
func NewTaskStateChangeEvent ( task * apitask . Task , reason string ) ( TaskStateChange , error ) { var event TaskStateChange taskKnownStatus := task . GetKnownStatus ( ) if ! taskKnownStatus . BackendRecognized ( ) { return event , errors . Errorf ( " " , taskKnownStatus ) } if task . GetSentStatus ( ) >= taskKnownStatus { return event , errors . Errorf ( " " , taskKnownStatus . String ( ) ) } event = TaskStateChange { TaskARN : task . Arn , Status : taskKnownStatus , Reason : reason , Task : task , } event . SetTaskTimestamps ( ) return event , nil } 
func NewContainerStateChangeEvent ( task * apitask . Task , cont * apicontainer . Container , reason string ) ( ContainerStateChange , error ) { var event ContainerStateChange contKnownStatus := cont . GetKnownStatus ( ) if ! contKnownStatus . ShouldReportToBackend ( cont . GetSteadyStateStatus ( ) ) { return event , errors . Errorf ( " " , contKnownStatus ) } if cont . IsInternal ( ) { return event , errors . Errorf ( " " , cont . Name ) } if cont . GetSentStatus ( ) >= contKnownStatus { return event , errors . Errorf ( " " , contKnownStatus . String ( ) , cont . Name , task . Arn ) } if reason == " " && cont . ApplyingError != nil { reason = cont . ApplyingError . Error ( ) } event = ContainerStateChange { TaskArn : task . Arn , ContainerName : cont . Name , Status : contKnownStatus . BackendStatus ( cont . GetSteadyStateStatus ( ) ) , ExitCode : cont . GetKnownExitCode ( ) , PortBindings : cont . GetKnownPortBindings ( ) , Reason : reason , Container : cont , } return event , nil } 
func ( c * ContainerStateChange ) String ( ) string { res := fmt . Sprintf ( " " , c . TaskArn , c . ContainerName , c . Status . String ( ) ) if c . ExitCode != nil { res += " " + strconv . Itoa ( * c . ExitCode ) + " " } if c . Reason != " " { res += " " + c . Reason } if len ( c . PortBindings ) != 0 { res += fmt . Sprintf ( " " , c . PortBindings ) } if c . Container != nil { res += " " + c . Container . GetSentStatus ( ) . String ( ) } return res } 
func ( change * TaskStateChange ) SetTaskTimestamps ( ) { if change . Task == nil { return } } if timestamp := change . Task . GetPullStoppedAt ( ) ; ! timestamp . IsZero ( ) { change . PullStoppedAt = aws . Time ( timestamp . UTC ( ) ) } if timestamp := change . Task . GetExecutionStoppedAt ( ) ; ! timestamp . IsZero ( ) { change . ExecutionStoppedAt = aws . Time ( timestamp . UTC ( ) ) } } 
func ( change * TaskStateChange ) ShouldBeReported ( ) bool { } if len ( change . Containers ) != 0 { return true } return false } 
func ( change * TaskStateChange ) String ( ) string { res := fmt . Sprintf ( " " , change . TaskARN , change . Status . String ( ) ) if change . Task != nil { res += fmt . Sprintf ( " " , change . Task . GetSentStatus ( ) . String ( ) , change . Task . GetPullStartedAt ( ) , change . Task . GetPullStoppedAt ( ) , change . Task . GetExecutionStoppedAt ( ) ) } if change . Attachment != nil { res += " " + change . Attachment . String ( ) } for _ , containerChange := range change . Containers { res += " " + containerChange . String ( ) } return res } 
func ( eni * ENI ) GetIPV4Addresses ( ) [ ] string { var addresses [ ] string for _ , addr := range eni . IPV4Addresses { addresses = append ( addresses , addr . Address ) } return addresses } 
func ( eni * ENI ) GetIPV6Addresses ( ) [ ] string { var addresses [ ] string for _ , addr := range eni . IPV6Addresses { addresses = append ( addresses , addr . Address ) } return addresses } 
func ( eni * ENI ) String ( ) string { var ipv4Addresses [ ] string for _ , addr := range eni . IPV4Addresses { ipv4Addresses = append ( ipv4Addresses , addr . Address ) } var ipv6Addresses [ ] string for _ , addr := range eni . IPV6Addresses { ipv6Addresses = append ( ipv6Addresses , addr . Address ) } return fmt . Sprintf ( " " , eni . ID , eni . MacAddress , eni . GetHostname ( ) , strings . Join ( ipv4Addresses , " " ) , strings . Join ( ipv6Addresses , " " ) , strings . Join ( eni . DomainNameServers , " " ) , strings . Join ( eni . DomainNameSearchList , " " ) , eni . SubnetGatewayIPV4Address ) } 
func ENIFromACS ( acsenis [ ] * ecsacs . ElasticNetworkInterface ) ( * ENI , error ) { err := ValidateTaskENI ( acsenis ) if err != nil { return nil , err } var ipv4 [ ] * ENIIPV4Address var ipv6 [ ] * ENIIPV6Address } } eni := & ENI { ID : aws . StringValue ( acsenis [ 0 ] . Ec2Id ) , IPV4Addresses : ipv4 , IPV6Addresses : ipv6 , MacAddress : aws . StringValue ( acsenis [ 0 ] . MacAddress ) , PrivateDNSName : aws . StringValue ( acsenis [ 0 ] . PrivateDnsName ) , SubnetGatewayIPV4Address : aws . StringValue ( acsenis [ 0 ] . SubnetGatewayIpv4Address ) , } for _ , nameserverIP := range acsenis [ 0 ] . DomainNameServers { eni . DomainNameServers = append ( eni . DomainNameServers , aws . StringValue ( nameserverIP ) ) } for _ , nameserverDomain := range acsenis [ 0 ] . DomainName { eni . DomainNameSearchList = append ( eni . DomainNameSearchList , aws . StringValue ( nameserverDomain ) ) } return eni , nil } 
func ValidateTaskENI ( acsenis [ ] * ecsacs . ElasticNetworkInterface ) error { } else if len ( acsenis [ 0 ] . Ipv4Addresses ) != 1 { return errors . Errorf ( " " , len ( acsenis [ 0 ] . Ipv4Addresses ) ) } else if len ( acsenis [ 0 ] . Ipv6Addresses ) > 1 { return errors . Errorf ( " " , len ( acsenis [ 0 ] . Ipv6Addresses ) ) } if acsenis [ 0 ] . MacAddress == nil { return errors . Errorf ( " " ) } if acsenis [ 0 ] . Ec2Id == nil { return errors . Errorf ( " " ) } return nil } 
func NewMockPlugins ( ctrl * gomock . Controller ) * MockPlugins { mock := & MockPlugins { ctrl : ctrl } mock . recorder = & MockPluginsMockRecorder { mock } return mock } 
func ( m * MockPlugins ) Scan ( ) ( [ ] string , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockPluginsMockRecorder ) Scan ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockPlugins ) ( nil ) . Scan ) ) } 
func TaskFromACS ( acsTask * ecsacs . Task , envelope * ecsacs . PayloadMessage ) ( * Task , error ) { data , err := jsonutil . BuildJSON ( acsTask ) if err != nil { return nil , err } task := & Task { } err = json . Unmarshal ( data , task ) if err != nil { return nil , err } if task . GetDesiredStatus ( ) == apitaskstatus . TaskRunning && envelope . SeqNum != nil { task . StartSequenceNumber = * envelope . SeqNum } else if task . GetDesiredStatus ( ) == apitaskstatus . TaskStopped && envelope . SeqNum != nil { task . StopSequenceNumber = * envelope . SeqNum } } container . TransitionDependenciesMap = make ( map [ apicontainerstatus . ContainerStatus ] apicontainer . TransitionDependencySet ) } return task , nil } 
func ( task * Task ) PostUnmarshalTask ( cfg * config . Config , credentialsManager credentials . Manager , resourceFields * taskresource . ResourceFields , dockerClient dockerapi . DockerClient , ctx context . Context ) error { if task . MemoryCPULimitsEnabled { err := task . initializeCgroupResourceSpec ( cfg . CgroupPath , resourceFields ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . NewResourceInitError ( task . Arn , err ) } } err := task . initializeContainerOrderingForVolumes ( ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . NewResourceInitError ( task . Arn , err ) } err = task . initializeContainerOrderingForLinks ( ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . NewResourceInitError ( task . Arn , err ) } if task . requiresASMDockerAuthData ( ) { task . initializeASMAuthResource ( credentialsManager , resourceFields ) } if task . requiresSSMSecret ( ) { task . initializeSSMSecretResource ( credentialsManager , resourceFields ) } if task . requiresASMSecret ( ) { task . initializeASMSecretResource ( credentialsManager , resourceFields ) } err = task . initializeDockerLocalVolumes ( dockerClient , ctx ) if err != nil { return apierrors . NewResourceInitError ( task . Arn , err ) } err = task . initializeDockerVolumes ( cfg . SharedVolumeMatchFullConfig , dockerClient , ctx ) if err != nil { return apierrors . NewResourceInitError ( task . Arn , err ) } if cfg . GPUSupportEnabled { err = task . addGPUResource ( ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . NewResourceInitError ( task . Arn , err ) } task . NvidiaRuntime = cfg . NvidiaRuntime } task . initializeCredentialsEndpoint ( credentialsManager ) task . initializeContainersV3MetadataEndpoint ( utils . NewDynamicUUIDProvider ( ) ) err = task . addNetworkResourceProvisioningDependency ( cfg ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . NewResourceInitError ( task . Arn , err ) } return nil } 
func ( task * Task ) initializeDockerVolumes ( sharedVolumeMatchFullConfig bool , dockerClient dockerapi . DockerClient , ctx context . Context ) error { for i , vol := range task . Volumes { } dockerVolume , ok := vol . Volume . ( * taskresourcevolume . DockerVolumeConfig ) if ! ok { return errors . New ( " " ) } if err != nil { return err } } else { if err != nil { return err } } } return nil } 
func ( task * Task ) addTaskScopedVolumes ( ctx context . Context , dockerClient dockerapi . DockerClient , vol * TaskVolume ) error { volumeConfig := vol . Volume . ( * taskresourcevolume . DockerVolumeConfig ) volumeResource , err := taskresourcevolume . NewVolumeResource ( ctx , vol . Name , task . volumeName ( vol . Name ) , volumeConfig . Scope , volumeConfig . Autoprovision , volumeConfig . Driver , volumeConfig . DriverOpts , volumeConfig . Labels , dockerClient ) if err != nil { return err } vol . Volume = & volumeResource . VolumeConfig task . AddResource ( resourcetype . DockerVolumeKey , volumeResource ) task . updateContainerVolumeDependency ( vol . Name ) return nil } 
func ( task * Task ) addSharedVolumes ( SharedVolumeMatchFullConfig bool , ctx context . Context , dockerClient dockerapi . DockerClient , vol * TaskVolume ) error { volumeConfig := vol . Volume . ( * taskresourcevolume . DockerVolumeConfig ) volumeConfig . DockerVolumeName = vol . Name if volumeMetadata . Error != nil { return errors . Wrapf ( volumeMetadata . Error , " " , vol . Name ) } return nil } if volumeMetadata . Error != nil { } seelog . Infof ( " " , task . Arn , vol . Name ) if err != nil { return err } task . AddResource ( resourcetype . DockerVolumeKey , volumeResource ) task . updateContainerVolumeDependency ( vol . Name ) return nil } seelog . Infof ( " " , task . Arn , volumeConfig . DockerVolumeName ) if ! SharedVolumeMatchFullConfig { seelog . Infof ( " " , task . Arn , volumeConfig . DockerVolumeName ) return nil } } else if ! reflect . DeepEqual ( volumeMetadata . DockerVolume . Labels , volumeConfig . Labels ) { return errors . Errorf ( " " , volumeMetadata . DockerVolume . Labels , volumeConfig . Labels ) } if len ( volumeMetadata . DockerVolume . Options ) == 0 && len ( volumeMetadata . DockerVolume . Options ) == len ( volumeConfig . DriverOpts ) { seelog . Infof ( " " , task . Arn , volumeConfig . DockerVolumeName ) } else if ! reflect . DeepEqual ( volumeMetadata . DockerVolume . Options , volumeConfig . DriverOpts ) { return errors . Errorf ( " " , volumeMetadata . DockerVolume . Options , volumeConfig . DriverOpts ) } } 
func ( task * Task ) updateContainerVolumeDependency ( name string ) { } } } } 
func ( task * Task ) initializeCredentialsEndpoint ( credentialsManager credentials . Manager ) { id := task . GetCredentialsID ( ) if id == " " { } taskCredentials , ok := credentialsManager . GetTaskCredentials ( id ) if ! ok { return } credentialsEndpointRelativeURI := taskCredentials . IAMRoleCredentials . GenerateCredentialsEndpointRelativeURI ( ) for _ , container := range task . Containers { } container . Environment [ awsSDKCredentialsRelativeURIPathEnvironmentVariableName ] = credentialsEndpointRelativeURI } } 
func ( task * Task ) initializeContainersV3MetadataEndpoint ( uuidProvider utils . UUIDProvider ) { for _ , container := range task . Containers { v3EndpointID := container . GetV3EndpointID ( ) if v3EndpointID == " " { } container . InjectV3MetadataEndpoint ( ) } } 
func ( task * Task ) requiresASMDockerAuthData ( ) bool { for _ , container := range task . Containers { if container . ShouldPullWithASMAuth ( ) { return true } } return false } 
func ( task * Task ) initializeASMAuthResource ( credentialsManager credentials . Manager , resourceFields * taskresource . ResourceFields ) { asmAuthResource := asmauth . NewASMAuthResource ( task . Arn , task . getAllASMAuthDataRequirements ( ) , task . ExecutionCredentialsID , credentialsManager , resourceFields . ASMClientCreator ) task . AddResource ( asmauth . ResourceName , asmAuthResource ) for _ , container := range task . Containers { if container . ShouldPullWithASMAuth ( ) { container . BuildResourceDependency ( asmAuthResource . GetName ( ) , resourcestatus . ResourceStatus ( asmauth . ASMAuthStatusCreated ) , apicontainerstatus . ContainerPulled ) } } } 
func ( task * Task ) requiresSSMSecret ( ) bool { for _ , container := range task . Containers { if container . ShouldCreateWithSSMSecret ( ) { return true } } return false } 
func ( task * Task ) initializeSSMSecretResource ( credentialsManager credentials . Manager , resourceFields * taskresource . ResourceFields ) { ssmSecretResource := ssmsecret . NewSSMSecretResource ( task . Arn , task . getAllSSMSecretRequirements ( ) , task . ExecutionCredentialsID , credentialsManager , resourceFields . SSMClientCreator ) task . AddResource ( ssmsecret . ResourceName , ssmSecretResource ) } } } 
func ( task * Task ) getAllSSMSecretRequirements ( ) map [ string ] [ ] apicontainer . Secret { reqs := make ( map [ string ] [ ] apicontainer . Secret ) for _ , container := range task . Containers { for _ , secret := range container . Secrets { if secret . Provider == apicontainer . SecretProviderSSM { if _ , ok := reqs [ secret . Region ] ; ! ok { reqs [ secret . Region ] = [ ] apicontainer . Secret { } } reqs [ secret . Region ] = append ( reqs [ secret . Region ] , secret ) } } } return reqs } 
func ( task * Task ) requiresASMSecret ( ) bool { for _ , container := range task . Containers { if container . ShouldCreateWithASMSecret ( ) { return true } } return false } 
func ( task * Task ) initializeASMSecretResource ( credentialsManager credentials . Manager , resourceFields * taskresource . ResourceFields ) { asmSecretResource := asmsecret . NewASMSecretResource ( task . Arn , task . getAllASMSecretRequirements ( ) , task . ExecutionCredentialsID , credentialsManager , resourceFields . ASMClientCreator ) task . AddResource ( asmsecret . ResourceName , asmSecretResource ) } } } 
func ( task * Task ) getAllASMSecretRequirements ( ) map [ string ] apicontainer . Secret { reqs := make ( map [ string ] apicontainer . Secret ) for _ , container := range task . Containers { for _ , secret := range container . Secrets { if secret . Provider == apicontainer . SecretProviderASM { secretKey := secret . GetSecretResourceCacheKey ( ) if _ , ok := reqs [ secretKey ] ; ! ok { reqs [ secretKey ] = secret } } } } return reqs } 
func ( task * Task ) BuildCNIConfig ( ) ( * ecscni . Config , error ) { if ! task . isNetworkModeVPC ( ) { return nil , errors . New ( " " ) } cfg := & ecscni . Config { } convertENIToCNIConfig ( task . GetTaskENI ( ) , cfg ) if task . GetAppMesh ( ) != nil { convertAppMeshToCNIConfig ( task . GetAppMesh ( ) , cfg ) } return cfg , nil } 
func convertENIToCNIConfig ( eni * apieni . ENI , cfg * ecscni . Config ) { cfg . ENIID = eni . ID cfg . ID = eni . MacAddress cfg . ENIMACAddress = eni . MacAddress cfg . SubnetGatewayIPV4Address = eni . GetSubnetGatewayIPV4Address ( ) for _ , ipv4 := range eni . IPV4Addresses { if ipv4 . Primary { cfg . ENIIPV4Address = ipv4 . Address break } } } } 
func convertAppMeshToCNIConfig ( appMesh * apiappmesh . AppMesh , cfg * ecscni . Config ) { cfg . AppMeshCNIEnabled = true cfg . IgnoredUID = appMesh . IgnoredUID cfg . IgnoredGID = appMesh . IgnoredGID cfg . ProxyIngressPort = appMesh . ProxyIngressPort cfg . ProxyEgressPort = appMesh . ProxyEgressPort cfg . AppPorts = appMesh . AppPorts cfg . EgressIgnoredIPs = appMesh . EgressIgnoredIPs cfg . EgressIgnoredPorts = appMesh . EgressIgnoredPorts } 
func ( task * Task ) ContainerByName ( name string ) ( * apicontainer . Container , bool ) { for _ , container := range task . Containers { if container . Name == name { return container , true } } return nil , false } 
func ( task * Task ) HostVolumeByName ( name string ) ( taskresourcevolume . Volume , bool ) { for _ , v := range task . Volumes { if v . Name == name { return v . Volume , true } } return nil , false } 
func ( task * Task ) UpdateMountPoints ( cont * apicontainer . Container , vols [ ] types . MountPoint ) { for _ , mountPoint := range cont . MountPoints { containerPath := getCanonicalPath ( mountPoint . ContainerPath ) for _ , vol := range vols { if strings . Compare ( vol . Destination , containerPath ) == 0 || } } } } } } 
func ( task * Task ) updateTaskKnownStatus ( ) ( newStatus apitaskstatus . TaskStatus ) { seelog . Debugf ( " " , task . String ( ) ) var earliestKnownStatusContainer * apicontainer . Container essentialContainerStopped := false for _ , container := range task . Containers { containerKnownStatus := container . GetKnownStatus ( ) if containerKnownStatus == apicontainerstatus . ContainerStopped && container . Essential { essentialContainerStopped = true } if containerKnownStatus < containerEarliestKnownStatus { containerEarliestKnownStatus = containerKnownStatus earliestKnownStatusContainer = container } } if earliestKnownStatusContainer == nil { seelog . Criticalf ( " " , containerEarliestKnownStatus . String ( ) , task ) return apitaskstatus . TaskStatusNone } seelog . Debugf ( " " , earliestKnownStatusContainer . String ( ) , task . String ( ) ) return apitaskstatus . TaskStatusNone } if task . GetKnownStatus ( ) < earliestKnownTaskStatus { seelog . Debugf ( " " , earliestKnownTaskStatus . String ( ) , task . String ( ) ) task . SetKnownStatus ( earliestKnownTaskStatus ) return task . GetKnownStatus ( ) } return apitaskstatus . TaskStatusNone } 
func ( task * Task ) getEarliestKnownTaskStatusForContainers ( ) apitaskstatus . TaskStatus { if len ( task . Containers ) == 0 { seelog . Criticalf ( " " , task . String ( ) ) return apitaskstatus . TaskStatusNone } for _ , container := range task . Containers { containerTaskStatus := apitaskstatus . MapContainerToTaskStatus ( container . GetKnownStatus ( ) , container . GetSteadyStateStatus ( ) ) if containerTaskStatus < earliest { earliest = containerTaskStatus } } return earliest } 
func ( task * Task ) DockerConfig ( container * apicontainer . Container , apiVersion dockerclient . DockerVersion ) ( * dockercontainer . Config , * apierrors . DockerClientConfigError ) { return task . dockerConfig ( container , apiVersion ) } 
func ( task * Task ) DockerHostConfig ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer , apiVersion dockerclient . DockerVersion ) ( * dockercontainer . HostConfig , * apierrors . HostConfigError ) { return task . dockerHostConfig ( container , dockerContainerMap , apiVersion ) } 
func ( task * Task ) ApplyExecutionRoleLogsAuth ( hostConfig * dockercontainer . HostConfig , credentialsManager credentials . Manager ) * apierrors . HostConfigError { id := task . GetExecutionCredentialsID ( ) if id == " " { } executionRoleCredentials , ok := credentialsManager . GetTaskCredentials ( id ) if ! ok { } credentialsEndpointRelativeURI := executionRoleCredentials . IAMRoleCredentials . GenerateCredentialsEndpointRelativeURI ( ) hostConfig . LogConfig . Config [ awslogsCredsEndpointOpt ] = credentialsEndpointRelativeURI return nil } 
func ( task * Task ) getDockerResources ( container * apicontainer . Container ) dockercontainer . Resources { if dockerMem != 0 && dockerMem < apicontainer . DockerContainerMinimumMemoryInBytes { seelog . Warnf ( " " , task . Arn , container . Name , apicontainer . DockerContainerMinimumMemoryInBytes ) dockerMem = apicontainer . DockerContainerMinimumMemoryInBytes } resources := dockercontainer . Resources { Memory : dockerMem , CPUShares : cpuShare , } return resources } 
func ( task * Task ) shouldOverrideNetworkMode ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer ) ( bool , string ) { } } pauseContName := " " for _ , cont := range task . Containers { if cont . Type == apicontainer . ContainerCNIPause { pauseContName = cont . Name break } } if pauseContName == " " { seelog . Critical ( " " , task . String ( ) ) return false , " " } pauseContainer , ok := dockerContainerMap [ pauseContName ] if ! ok || pauseContainer == nil { return false , " " } return true , dockerMappingContainerPrefix + pauseContainer . DockerID } 
func ( task * Task ) overrideDNS ( hostConfig * dockercontainer . HostConfig ) * dockercontainer . HostConfig { eni := task . GetTaskENI ( ) if eni == nil { return hostConfig } hostConfig . DNS = eni . DomainNameServers hostConfig . DNSSearch = eni . DomainNameSearchList return hostConfig } 
func ( task * Task ) applyENIHostname ( dockerConfig * dockercontainer . Config ) * dockercontainer . Config { eni := task . GetTaskENI ( ) if eni == nil { return dockerConfig } hostname := eni . GetHostname ( ) if hostname == " " { return dockerConfig } dockerConfig . Hostname = hostname return dockerConfig } 
func ( task * Task ) generateENIExtraHosts ( ) [ ] string { eni := task . GetTaskENI ( ) if eni == nil { return nil } hostname := eni . GetHostname ( ) if hostname == " " { return nil } extraHosts := [ ] string { } for _ , ip := range eni . GetIPV4Addresses ( ) { host := fmt . Sprintf ( " " , hostname , ip ) extraHosts = append ( extraHosts , host ) } return extraHosts } 
func ( task * Task ) shouldOverridePIDMode ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer ) ( bool , string ) { } switch task . getPIDMode ( ) { case pidModeHost : return true , pidModeHost case pidModeTask : pauseCont , ok := task . ContainerByName ( NamespacePauseContainerName ) if ! ok { seelog . Criticalf ( " " , task . Arn ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , " " } pauseDockerID , ok := dockerContainerMap [ pauseCont . Name ] if ! ok || pauseDockerID == nil { task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , " " } return true , dockerMappingContainerPrefix + pauseDockerID . DockerID } } 
func ( task * Task ) shouldOverrideIPCMode ( container * apicontainer . Container , dockerContainerMap map [ string ] * apicontainer . DockerContainer ) ( bool , string ) { } } } switch task . getIPCMode ( ) { case ipcModeHost : return true , ipcModeHost case ipcModeTask : pauseCont , ok := task . ContainerByName ( NamespacePauseContainerName ) if ! ok { seelog . Criticalf ( " " , task . Arn ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , " " } pauseDockerID , ok := dockerContainerMap [ pauseCont . Name ] if ! ok || pauseDockerID == nil { task . SetDesiredStatus ( apitaskstatus . TaskStopped ) return false , " " } return true , dockerMappingContainerPrefix + pauseDockerID . DockerID default : return false , " " } } 
func ( task * Task ) UpdateStatus ( ) bool { change := task . updateTaskKnownStatus ( ) return change != apitaskstatus . TaskStatusNone } 
func ( task * Task ) UpdateDesiredStatus ( ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . updateTaskDesiredStatusUnsafe ( ) task . updateContainerDesiredStatusUnsafe ( task . DesiredStatusUnsafe ) task . updateResourceDesiredStatusUnsafe ( task . DesiredStatusUnsafe ) } 
func ( task * Task ) updateTaskDesiredStatusUnsafe ( ) { seelog . Debugf ( " " , task . stringUnsafe ( ) ) task . DesiredStatusUnsafe = apitaskstatus . TaskStopped } } } 
func ( task * Task ) updateContainerDesiredStatusUnsafe ( taskDesiredStatus apitaskstatus . TaskStatus ) { for _ , container := range task . Containers { taskDesiredStatusToContainerStatus := apitaskstatus . MapTaskToContainerStatus ( taskDesiredStatus , container . GetSteadyStateStatus ( ) ) if container . GetDesiredStatus ( ) < taskDesiredStatusToContainerStatus { container . SetDesiredStatus ( taskDesiredStatusToContainerStatus ) } } } 
func ( task * Task ) updateResourceDesiredStatusUnsafe ( taskDesiredStatus apitaskstatus . TaskStatus ) { resources := task . getResourcesUnsafe ( ) for _ , r := range resources { if taskDesiredStatus == apitaskstatus . TaskRunning { if r . GetDesiredStatus ( ) < r . SteadyState ( ) { r . SetDesiredStatus ( r . SteadyState ( ) ) } } else { if r . GetDesiredStatus ( ) < r . TerminalStatus ( ) { r . SetDesiredStatus ( r . TerminalStatus ( ) ) } } } } 
func ( task * Task ) SetKnownStatus ( status apitaskstatus . TaskStatus ) { task . setKnownStatus ( status ) task . updateKnownStatusTime ( ) } 
func ( task * Task ) GetKnownStatus ( ) apitaskstatus . TaskStatus { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . KnownStatusUnsafe } 
func ( task * Task ) GetKnownStatusTime ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . KnownStatusTimeUnsafe } 
func ( task * Task ) SetCredentialsID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . credentialsID = id } 
func ( task * Task ) GetCredentialsID ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . credentialsID } 
func ( task * Task ) SetExecutionRoleCredentialsID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ExecutionCredentialsID = id } 
func ( task * Task ) GetExecutionCredentialsID ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ExecutionCredentialsID } 
func ( task * Task ) GetDesiredStatus ( ) apitaskstatus . TaskStatus { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . DesiredStatusUnsafe } 
func ( task * Task ) SetDesiredStatus ( status apitaskstatus . TaskStatus ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . DesiredStatusUnsafe = status } 
func ( task * Task ) GetSentStatus ( ) apitaskstatus . TaskStatus { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . SentStatusUnsafe } 
func ( task * Task ) SetSentStatus ( status apitaskstatus . TaskStatus ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . SentStatusUnsafe = status } 
func ( task * Task ) SetTaskENI ( eni * apieni . ENI ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ENI = eni } 
func ( task * Task ) GetTaskENI ( ) * apieni . ENI { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ENI } 
func ( task * Task ) SetAppMesh ( appMesh * apiappmesh . AppMesh ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . AppMesh = appMesh } 
func ( task * Task ) GetAppMesh ( ) * apiappmesh . AppMesh { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . AppMesh } 
func ( task * Task ) GetStopSequenceNumber ( ) int64 { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . StopSequenceNumber } 
func ( task * Task ) SetStopSequenceNumber ( seqnum int64 ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . StopSequenceNumber = seqnum } 
func ( task * Task ) SetPullStartedAt ( timestamp time . Time ) bool { task . lock . Lock ( ) defer task . lock . Unlock ( ) return true } return false } 
func ( task * Task ) GetPullStartedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PullStartedAtUnsafe } 
func ( task * Task ) SetPullStoppedAt ( timestamp time . Time ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . PullStoppedAtUnsafe = timestamp } 
func ( task * Task ) GetPullStoppedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PullStoppedAtUnsafe } 
func ( task * Task ) SetExecutionStoppedAt ( timestamp time . Time ) bool { task . lock . Lock ( ) defer task . lock . Unlock ( ) if task . ExecutionStoppedAtUnsafe . IsZero ( ) { task . ExecutionStoppedAtUnsafe = timestamp return true } return false } 
func ( task * Task ) GetExecutionStoppedAt ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ExecutionStoppedAtUnsafe } 
func ( task * Task ) String ( ) string { task . lock . Lock ( ) defer task . lock . Unlock ( ) return task . stringUnsafe ( ) } 
func ( task * Task ) stringUnsafe ( ) string { res := fmt . Sprintf ( " " , task . Family , task . Version , task . Arn , task . KnownStatusUnsafe . String ( ) , task . DesiredStatusUnsafe . String ( ) ) res += " " for _ , container := range task . Containers { res += fmt . Sprintf ( " " , container . Name , container . GetKnownStatus ( ) . String ( ) , container . GetDesiredStatus ( ) . String ( ) ) } if task . ENI != nil { res += fmt . Sprintf ( " " , task . ENI . String ( ) ) } return res + " " } 
func ( task * Task ) GetID ( ) ( string , error ) { if err != nil { return " " , errors . Wrapf ( err , " " , task . Arn ) } if ! strings . Contains ( resource , arnResourceDelimiter ) { return " " , errors . Errorf ( " " , resource ) } resourceSplit := strings . SplitN ( resource , arnResourceDelimiter , arnResourceSections ) if len ( resourceSplit ) != arnResourceSections { return " " , errors . Errorf ( " " , resource , arnResourceSections , len ( resourceSplit ) ) } return resourceSplit [ 1 ] , nil } 
func ( task * Task ) RecordExecutionStoppedAt ( container * apicontainer . Container ) { if ! container . Essential { return } if container . GetKnownStatus ( ) != apicontainerstatus . ContainerStopped { return } ok := task . SetExecutionStoppedAt ( now ) if ! ok { } seelog . Infof ( " " , task . Arn , container . Name , now . String ( ) ) } 
func ( task * Task ) GetResources ( ) [ ] taskresource . TaskResource { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . getResourcesUnsafe ( ) } 
func ( task * Task ) getResourcesUnsafe ( ) [ ] taskresource . TaskResource { var resourceList [ ] taskresource . TaskResource for _ , resources := range task . ResourcesMapUnsafe { resourceList = append ( resourceList , resources ... ) } return resourceList } 
func ( task * Task ) AddResource ( resourceType string , resource taskresource . TaskResource ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ResourcesMapUnsafe [ resourceType ] = append ( task . ResourcesMapUnsafe [ resourceType ] , resource ) } 
func ( task * Task ) SetTerminalReason ( reason string ) { seelog . Infof ( " " , task . Arn , reason ) task . terminalReasonOnce . Do ( func ( ) { seelog . Infof ( " " , task . Arn , reason ) words [ 0 ] = strings . Title ( words [ 0 ] ) task . terminalReason = strings . Join ( words , " " ) } ) } 
func ( task * Task ) GetTerminalReason ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . terminalReason } 
func ( task * Task ) PopulateASMAuthData ( container * apicontainer . Container ) error { secretID := container . RegistryAuthentication . ASMAuthData . CredentialsParameter resource , ok := task . getASMAuthResource ( ) if ! ok { return errors . New ( " " ) } dac , ok := asmResource . GetASMDockerAuthConfig ( secretID ) if ! ok { return errors . Errorf ( " " , secretID ) } container . SetASMDockerAuthConfig ( dac ) return nil } 
func ( task * Task ) getSSMSecretsResource ( ) ( [ ] taskresource . TaskResource , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) res , ok := task . ResourcesMapUnsafe [ ssmsecret . ResourceName ] return res , ok } 
func ( task * Task ) PopulateSecrets ( hostConfig * dockercontainer . HostConfig , container * apicontainer . Container ) * apierrors . DockerClientConfigError { var ssmRes * ssmsecret . SSMSecretResource var asmRes * asmsecret . ASMSecretResource if container . ShouldCreateWithSSMSecret ( ) { resource , ok := task . getSSMSecretsResource ( ) if ! ok { return & apierrors . DockerClientConfigError { Msg : " " } } ssmRes = resource [ 0 ] . ( * ssmsecret . SSMSecretResource ) } if container . ShouldCreateWithASMSecret ( ) { resource , ok := task . getASMSecretsResource ( ) if ! ok { return & apierrors . DockerClientConfigError { Msg : " " } } asmRes = resource [ 0 ] . ( * asmsecret . ASMSecretResource ) } envVars := make ( map [ string ] string ) logDriverTokenName := " " logDriverTokenSecretValue := " " for _ , secret := range container . Secrets { secretVal := " " if secret . Provider == apicontainer . SecretProviderSSM { k := secret . GetSecretResourceCacheKey ( ) if secretValue , ok := ssmRes . GetCachedSecretValue ( k ) ; ok { secretVal = secretValue } } if secret . Provider == apicontainer . SecretProviderASM { k := secret . GetSecretResourceCacheKey ( ) if secretValue , ok := asmRes . GetCachedSecretValue ( k ) ; ok { secretVal = secretValue } } if secret . Type == apicontainer . SecretTypeEnv { envVars [ secret . Name ] = secretVal continue } if secret . Target == apicontainer . SecretTargetLogDriver { logDriverTokenName = secret . Name logDriverTokenSecretValue = secretVal } } } container . MergeEnvironmentVariables ( envVars ) return nil } 
func ( task * Task ) getASMSecretsResource ( ) ( [ ] taskresource . TaskResource , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) res , ok := task . ResourcesMapUnsafe [ asmsecret . ResourceName ] return res , ok } 
func ( task * Task ) InitializeResources ( resourceFields * taskresource . ResourceFields ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) for _ , resources := range task . ResourcesMapUnsafe { for _ , resource := range resources { resource . Initialize ( resourceFields , task . KnownStatusUnsafe , task . DesiredStatusUnsafe ) } } } 
func ( task * Task ) getPIDMode ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PIDMode } 
func ( task * Task ) getIPCMode ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . IPCMode } 
func ( task * Task ) AssociationsByTypeAndContainer ( associationType , containerName string ) [ ] string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) var associationNames [ ] string for _ , association := range task . Associations { if association . Type == associationType { for _ , associatedContainerName := range association . Containers { if associatedContainerName == containerName { associationNames = append ( associationNames , association . Name ) } } } } return associationNames } 
func ( task * Task ) AssociationByTypeAndName ( associationType , associationName string ) ( * Association , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) for _ , association := range task . Associations { if association . Type == associationType && association . Name == associationName { return & association , true } } return nil , false } 
func newAttachENIHandler ( ctx context . Context , cluster string , containerInstanceArn string , acsClient wsclient . ClientServer , taskEngineState dockerstate . TaskEngineState , saver statemanager . Saver ) attachENIHandler { return attachENIHandler { messageBuffer : make ( chan * ecsacs . AttachTaskNetworkInterfacesMessage ) , ctx : derivedContext , cancel : cancel , cluster : aws . String ( cluster ) , containerInstance : aws . String ( containerInstanceArn ) , acsClient : acsClient , state : taskEngineState , saver : saver , } } 
func ( attachENIHandler * attachENIHandler ) handlerFunc ( ) func ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) { return func ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) { attachENIHandler . messageBuffer <- message } } 
func ( attachENIHandler * attachENIHandler ) handleMessages ( ) { for { select { case message := <- attachENIHandler . messageBuffer : if err := attachENIHandler . handleSingleMessage ( message ) ; err != nil { seelog . Warnf ( " " , message . String ( ) , err ) } case <- attachENIHandler . ctx . Done ( ) : return } } } 
func ( handler * attachENIHandler ) handleSingleMessage ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) error { receivedAt := time . Now ( ) } } } ( message . ClusterArn , message . ContainerInstanceArn , message . MessageId ) if eniAttachment , ok := handler . state . ENIByMac ( mac ) ; ok { seelog . Infof ( " " , mac ) eniAckTimeoutHandler := ackTimeoutHandler { mac : mac , state : handler . state } return eniAttachment . StartTimer ( eniAckTimeoutHandler . handle ) } if err := handler . addENIAttachmentToState ( message , receivedAt ) ; err != nil { return errors . Wrapf ( err , " " ) } if err := handler . saver . Save ( ) ; err != nil { return errors . Wrapf ( err , " " ) } return nil } 
func ( handler * attachENIHandler ) addENIAttachmentToState ( message * ecsacs . AttachTaskNetworkInterfacesMessage , receivedAt time . Time ) error { attachmentARN := aws . StringValue ( message . ElasticNetworkInterfaces [ 0 ] . AttachmentArn ) mac := aws . StringValue ( message . ElasticNetworkInterfaces [ 0 ] . MacAddress ) taskARN := aws . StringValue ( message . TaskArn ) eniAttachment := & apieni . ENIAttachment { TaskARN : taskARN , AttachmentARN : attachmentARN , AttachStatusSent : false , MACAddress : mac , eniAckTimeoutHandler := ackTimeoutHandler { mac : mac , state : handler . state } if err := eniAttachment . StartTimer ( eniAckTimeoutHandler . handle ) ; err != nil { return err } seelog . Infof ( " " , taskARN , attachmentARN , mac ) handler . state . AddENIAttachment ( eniAttachment ) return nil } 
func validateAttachTaskNetworkInterfacesMessage ( message * ecsacs . AttachTaskNetworkInterfacesMessage ) error { if message == nil { return errors . Errorf ( " " ) } messageId := aws . StringValue ( message . MessageId ) if messageId == " " { return errors . Errorf ( " " ) } clusterArn := aws . StringValue ( message . ClusterArn ) if clusterArn == " " { return errors . Errorf ( " " ) } containerInstanceArn := aws . StringValue ( message . ContainerInstanceArn ) if containerInstanceArn == " " { return errors . Errorf ( " " ) } enis := message . ElasticNetworkInterfaces if len ( enis ) != 1 { return errors . Errorf ( " " , len ( enis ) ) } eni := enis [ 0 ] if aws . StringValue ( eni . MacAddress ) == " " { return errors . Errorf ( " " ) } taskArn := aws . StringValue ( message . TaskArn ) if taskArn == " " { return errors . Errorf ( " " ) } timeout := aws . Int64Value ( message . WaitTimeoutMs ) if timeout <= 0 { return errors . Errorf ( " " ) } return nil } 
func ( m * MockStateManager ) ForceSave ( ) error { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockStateManagerMockRecorder ) ForceSave ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockStateManager ) ( nil ) . ForceSave ) ) } 
func ( overrides * ContainerOverrides ) UnmarshalJSON ( b [ ] byte ) error { regular := ContainerOverridesCopy { } if err == nil { err = utils . CompleteJsonUnmarshal ( b , regular ) if err == nil { * overrides = ContainerOverrides ( regular ) return nil } err = apierrors . NewMultiError ( errors . New ( " " ) , err ) } err2 := json . Unmarshal ( b , & str ) if err2 != nil { return apierrors . NewMultiError ( errors . New ( " " ) , err , err2 ) } if err3 == nil { err3 = utils . CompleteJsonUnmarshal ( [ ] byte ( str ) , regular ) if err3 == nil { * overrides = ContainerOverrides ( regular ) return nil } err3 = apierrors . NewMultiError ( errors . New ( " " ) , err3 ) } return apierrors . NewMultiError ( errors . New ( " " ) , err , err2 , err3 ) } 
func NewMockClientServer ( ctrl * gomock . Controller ) * MockClientServer { mock := & MockClientServer { ctrl : ctrl } mock . recorder = & MockClientServerMockRecorder { mock } return mock } 
func ( m * MockClientServer ) AddRequestHandler ( arg0 wsclient . RequestHandler ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockClientServerMockRecorder ) AddRequestHandler ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockClientServer ) ( nil ) . AddRequestHandler ) , arg0 ) } 
func ( mr * MockClientServerMockRecorder ) Connect ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockClientServer ) ( nil ) . Connect ) ) } 
func ( m * MockClientServer ) Disconnect ( arg0 ... interface { } ) error { varargs := [ ] interface { } { } for _ , a := range arg0 { varargs = append ( varargs , a ) } ret := m . ctrl . Call ( m , " " , varargs ... ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClientServer ) IsConnected ( ) bool { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( bool ) return ret0 } 
func ( m * MockClientServer ) MakeRequest ( arg0 interface { } ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClientServer ) SetAnyRequestHandler ( arg0 wsclient . RequestHandler ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockClientServer ) SetConnection ( arg0 wsconn . WebsocketConn ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockClientServer ) SetReadDeadline ( arg0 time . Time ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClientServer ) WriteMessage ( arg0 [ ] byte ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func NewExponentialBackoff ( min , max time . Duration , jitterMultiple , multiple float64 ) * ExponentialBackoff { return & ExponentialBackoff { start : min , current : min , max : max , jitterMultiple : jitterMultiple , multiple : multiple , } } 
func ( cs ContainerStatus ) String ( ) string { for k , v := range containerStatusMap { if v == cs { return k } } return " " } 
func ( cs * ContainerStatus ) ShouldReportToBackend ( steadyStateStatus ContainerStatus ) bool { return * cs == steadyStateStatus || * cs == ContainerStopped } 
func ( cs * ContainerStatus ) BackendStatus ( steadyStateStatus ContainerStatus ) ContainerStatus { if * cs == steadyStateStatus { return ContainerRunning } if * cs == ContainerStopped { return ContainerStopped } return ContainerStatusNone } 
func ( cs * ContainerStatus ) UnmarshalJSON ( b [ ] byte ) error { if strings . ToLower ( string ( b ) ) == " " { * cs = ContainerStatusNone return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * cs = ContainerStatusNone return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) return nil } if strStatus == " " { * cs = ContainerStopped return nil } stat , ok := containerStatusMap [ strStatus ] if ! ok { * cs = ContainerStatusNone return errors . New ( " " ) } * cs = stat return nil } 
func ( cs * ContainerStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if cs == nil { return nil , nil } return [ ] byte ( `"` + cs . String ( ) + `"` ) , nil } 
func ( healthStatus * ContainerHealthStatus ) UnmarshalJSON ( b [ ] byte ) error { * healthStatus = ContainerHealthUnknown if strings . ToLower ( string ( b ) ) == " " { return nil } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { return errors . New ( " " + string ( b ) ) } strStatus := string ( b [ 1 : len ( b ) - 1 ] ) switch strStatus { case " " : case " " : * healthStatus = ContainerUnhealthy default : return errors . New ( " " + string ( b ) ) } return nil } 
func ( healthStatus * ContainerHealthStatus ) MarshalJSON ( ) ( [ ] byte , error ) { if healthStatus == nil { return nil , nil } return [ ] byte ( `"` + healthStatus . String ( ) + `"` ) , nil } 
func MustInit ( cfg * config . Config , registry ... * prometheus . Registry ) { if ! cfg . PrometheusMetricsEnabled { return } var registryToUse * prometheus . Registry if len ( registry ) > 0 { registryToUse = registry [ 0 ] } else { registryToUse = prometheus . DefaultRegisterer . ( * prometheus . Registry ) } MetricsEngineGlobal = NewMetricsEngine ( cfg , registryToUse ) MetricsEngineGlobal . collection = true } 
func NewMetricsEngine ( cfg * config . Config , registry * prometheus . Registry ) * MetricsEngine { metricsEngine := & MetricsEngine { cfg : cfg , Registry : registry , managedMetrics : make ( map [ APIType ] MetricsClient ) , } for managedAPI , _ := range managedAPIs { aClient := NewMetricsClient ( managedAPI , metricsEngine . Registry ) metricsEngine . managedMetrics [ managedAPI ] = aClient } return metricsEngine } 
func ( engine * MetricsEngine ) recordGenericMetric ( apiType APIType , callName string ) func ( ) { callStarted := make ( chan bool , 1 ) if engine == nil || ! engine . collection { return func ( ) { } } callID := engine . recordMetric ( apiType , callName , " " , callStarted ) return func ( ) { engine . recordMetric ( apiType , callName , callID , callStarted ) } } 
func ( engine * MetricsEngine ) publishMetrics ( ) { go func ( ) { err := http . ListenAndServe ( fmt . Sprintf ( " " , config . AgentPrometheusExpositionPort ) , nil ) if err != nil { seelog . Errorf ( " " , err . Error ( ) ) } } ( ) } 
func NewMockDockerClient ( ctrl * gomock . Controller ) * MockDockerClient { mock := & MockDockerClient { ctrl : ctrl } mock . recorder = & MockDockerClientMockRecorder { mock } return mock } 
func ( m * MockDockerClient ) APIVersion ( ) ( dockerclient . DockerVersion , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( dockerclient . DockerVersion ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockDockerClient ) ContainerEvents ( arg0 context . Context ) ( <- chan dockerapi . DockerContainerChangeEvent , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( <- chan dockerapi . DockerContainerChangeEvent ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockDockerClientMockRecorder ) ContainerEvents ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockDockerClient ) ( nil ) . ContainerEvents ) , arg0 ) } 
func ( m * MockDockerClient ) CreateContainer ( arg0 context . Context , arg1 * container0 . Config , arg2 * container0 . HostConfig , arg3 string , arg4 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 , arg4 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 } 
func ( m * MockDockerClient ) CreateVolume ( arg0 context . Context , arg1 , arg2 string , arg3 , arg4 map [ string ] string , arg5 time . Duration ) dockerapi . SDKVolumeResponse { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 , arg4 , arg5 ) ret0 , _ := ret [ 0 ] . ( dockerapi . SDKVolumeResponse ) return ret0 } 
func ( m * MockDockerClient ) DescribeContainer ( arg0 context . Context , arg1 string ) ( status . ContainerStatus , dockerapi . DockerContainerMetadata ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( status . ContainerStatus ) ret1 , _ := ret [ 1 ] . ( dockerapi . DockerContainerMetadata ) return ret0 , ret1 } 
func ( m * MockDockerClient ) InspectContainer ( arg0 context . Context , arg1 string , arg2 time . Duration ) ( * types . ContainerJSON , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( * types . ContainerJSON ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockDockerClient ) InspectImage ( arg0 string ) ( * types . ImageInspect , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * types . ImageInspect ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockDockerClient ) KnownVersions ( ) [ ] dockerclient . DockerVersion { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] dockerclient . DockerVersion ) return ret0 } 
func ( mr * MockDockerClientMockRecorder ) KnownVersions ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockDockerClient ) ( nil ) . KnownVersions ) ) } 
func ( m * MockDockerClient ) ListContainers ( arg0 context . Context , arg1 bool , arg2 time . Duration ) dockerapi . ListContainersResponse { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( dockerapi . ListContainersResponse ) return ret0 } 
func ( m * MockDockerClient ) ListImages ( arg0 context . Context , arg1 time . Duration ) dockerapi . ListImagesResponse { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( dockerapi . ListImagesResponse ) return ret0 } 
func ( m * MockDockerClient ) ListPlugins ( arg0 context . Context , arg1 time . Duration , arg2 filters . Args ) dockerapi . ListPluginsResponse { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( dockerapi . ListPluginsResponse ) return ret0 } 
func ( m * MockDockerClient ) ListPluginsWithFilters ( arg0 context . Context , arg1 bool , arg2 [ ] string , arg3 time . Duration ) ( [ ] string , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( [ ] string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockDockerClient ) LoadImage ( arg0 context . Context , arg1 io . Reader , arg2 time . Duration ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockDockerClient ) PullImage ( arg0 context . Context , arg1 string , arg2 * container . RegistryAuthenticationData , arg3 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 } 
func ( m * MockDockerClient ) RemoveImage ( arg0 context . Context , arg1 string , arg2 time . Duration ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockDockerClient ) StopContainer ( arg0 context . Context , arg1 string , arg2 time . Duration ) dockerapi . DockerContainerMetadata { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerContainerMetadata ) return ret0 } 
func ( m * MockDockerClient ) Version ( arg0 context . Context , arg1 time . Duration ) ( string , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockDockerClient ) WithVersion ( arg0 dockerclient . DockerVersion ) dockerapi . DockerClient { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( dockerapi . DockerClient ) return ret0 } 
func NewMockCache ( ctrl * gomock . Controller ) * MockCache { mock := & MockCache { ctrl : ctrl } mock . recorder = & MockCacheMockRecorder { mock } return mock } 
func ( m * MockCache ) Delete ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockCache ) Get ( arg0 string ) ( async . Value , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( async . Value ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockCache ) Set ( arg0 string , arg1 async . Value ) { m . ctrl . Call ( m , " " , arg0 , arg1 ) } 
func ( mr * MockCacheMockRecorder ) Set ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCache ) ( nil ) . Set ) , arg0 , arg1 ) } 
func ( engine * DockerTaskEngine ) newManagedTask ( task * apitask . Task ) * managedTask { ctx , cancel := context . WithCancel ( engine . ctx ) t := & managedTask { ctx : ctx , cancel : cancel , Task : task , acsMessages : make ( chan acsTransition ) , dockerMessages : make ( chan dockerContainerChange ) , resourceStateChangeEvent : make ( chan resourceStateChange ) , engine : engine , cfg : engine . cfg , stateChangeEvents : engine . stateChangeEvents , containerChangeEventStream : engine . containerChangeEventStream , saver : engine . saver , credentialsManager : engine . credentialsManager , cniClient : engine . cniClient , taskStopWG : engine . taskStopGroup , steadyStatePollInterval : engine . taskSteadyStatePollInterval , } engine . managedTasks [ task . Arn ] = t return t } 
func ( mtask * managedTask ) overseeTask ( ) { return default : } } if ! mtask . GetKnownStatus ( ) . Terminal ( ) { mtask . progressTask ( ) } if err != nil { seelog . Warnf ( " " , mtask . Arn , err ) } if mtask . GetKnownStatus ( ) . Terminal ( ) { break } } mtask . cleanupCredentials ( ) if mtask . StopSequenceNumber != 0 { seelog . Debugf ( " " , mtask . Arn , mtask . StopSequenceNumber ) mtask . taskStopWG . Done ( mtask . StopSequenceNumber ) } mtask . cleanupTask ( mtask . cfg . TaskCleanupWaitDuration ) } 
func ( mtask * managedTask ) emitCurrentStatus ( ) { for _ , container := range mtask . Containers { mtask . emitContainerEvent ( mtask . Task , container , " " ) } mtask . emitTaskEvent ( mtask . Task , " " ) } 
func ( mtask * managedTask ) waitForHostResources ( ) { if mtask . StartSequenceNumber == 0 { } if mtask . GetDesiredStatus ( ) . Terminal ( ) { } seelog . Infof ( " " , mtask . Arn , mtask . StartSequenceNumber ) othersStoppedCtx , cancel := context . WithCancel ( mtask . ctx ) defer cancel ( ) go func ( ) { mtask . taskStopWG . Wait ( mtask . StartSequenceNumber ) cancel ( ) } ( ) for ! mtask . waitEvent ( othersStoppedCtx . Done ( ) ) { if mtask . GetDesiredStatus ( ) . Terminal ( ) { } } seelog . Infof ( " " , mtask . Arn , mtask . GetDesiredStatus ( ) . String ( ) ) } 
func ( mtask * managedTask ) waitSteady ( ) { seelog . Infof ( " " , mtask . Arn , mtask . GetKnownStatus ( ) . String ( ) ) timeoutCtx , cancel := context . WithTimeout ( mtask . ctx , mtask . steadyStatePollInterval ) defer cancel ( ) timedOut := mtask . waitEvent ( timeoutCtx . Done ( ) ) if timedOut { seelog . Debugf ( " " , mtask . Arn ) go mtask . engine . checkTaskState ( mtask . Task ) } } 
func ( mtask * managedTask ) steadyState ( ) bool { select { case <- mtask . ctx . Done ( ) : seelog . Info ( " " ) return false default : taskKnownStatus := mtask . GetKnownStatus ( ) return taskKnownStatus == apitaskstatus . TaskRunning && taskKnownStatus >= mtask . GetDesiredStatus ( ) } } 
func ( mtask * managedTask ) cleanupCredentials ( ) { taskCredentialsID := mtask . GetCredentialsID ( ) if taskCredentialsID != " " { mtask . credentialsManager . RemoveCredentials ( taskCredentialsID ) } } 
func ( mtask * managedTask ) waitEvent ( stopWaiting <- chan struct { } ) bool { seelog . Debugf ( " " , mtask . Arn ) select { case acsTransition := <- mtask . acsMessages : seelog . Debugf ( " " , mtask . Arn ) mtask . handleDesiredStatusChange ( acsTransition . desiredStatus , acsTransition . seqnum ) return false case dockerChange := <- mtask . dockerMessages : seelog . Debugf ( " " , mtask . Arn , dockerChange . container . Name , dockerChange . event . Status . String ( ) ) mtask . handleContainerChange ( dockerChange ) return false case resChange := <- mtask . resourceStateChangeEvent : res := resChange . resource seelog . Debugf ( " " , mtask . Arn , res . GetName ( ) , res . StatusString ( resChange . nextState ) ) mtask . handleResourceStateChange ( resChange ) return false case <- stopWaiting : seelog . Debugf ( " " , mtask . Arn ) return true } } 
func ( mtask * managedTask ) handleDesiredStatusChange ( desiredStatus apitaskstatus . TaskStatus , seqnum int64 ) { if desiredStatus <= mtask . GetDesiredStatus ( ) { seelog . Debugf ( " " , mtask . Arn , mtask . GetDesiredStatus ( ) . String ( ) , desiredStatus . String ( ) ) return } if desiredStatus == apitaskstatus . TaskStopped && seqnum != 0 && mtask . GetStopSequenceNumber ( ) == 0 { seelog . Debugf ( " " , mtask . Arn , seqnum ) mtask . SetStopSequenceNumber ( seqnum ) mtask . taskStopWG . Add ( seqnum , 1 ) } mtask . SetDesiredStatus ( desiredStatus ) mtask . UpdateDesiredStatus ( ) } 
func ( mtask * managedTask ) handleContainerChange ( containerChange dockerContainerChange ) { found := mtask . isContainerFound ( container ) if ! found { seelog . Criticalf ( " " , mtask . Arn , container . Name ) return } event := containerChange . event seelog . Debugf ( " " , mtask . Arn , event , container . Name ) mtask . handleStoppedToRunningContainerTransition ( event . Status , container ) if event . Status <= containerKnownStatus { seelog . Infof ( " " , mtask . Arn , container . Name , event . Status . String ( ) , containerKnownStatus . String ( ) ) return } container . SetKnownStatus ( event . Status ) updateContainerMetadata ( & event . DockerContainerMetadata , container , mtask . Task ) if event . Error != nil { proceedAnyway := mtask . handleEventError ( containerChange , currentKnownStatus ) if ! proceedAnyway { return } } } mtask . RecordExecutionStoppedAt ( container ) seelog . Debugf ( " " , mtask . Arn , container . Name , event . DockerID , event . Status . String ( ) ) err := mtask . containerChangeEventStream . WriteToEventStream ( event ) if err != nil { seelog . Warnf ( " " , mtask . Arn , container . Name , err ) } mtask . emitContainerEvent ( mtask . Task , container , " " ) if mtask . UpdateStatus ( ) { seelog . Debugf ( " " , mtask . Arn , container . Name , mtask . GetDesiredStatus ( ) . String ( ) ) if mtask . GetKnownStatus ( ) . Terminal ( ) { taskStateChangeReason = mtask . Task . GetTerminalReason ( ) } mtask . emitTaskEvent ( mtask . Task , taskStateChangeReason ) } seelog . Debugf ( " " , mtask . Arn , container . Name , mtask . GetDesiredStatus ( ) . String ( ) ) } 
func ( mtask * managedTask ) handleResourceStateChange ( resChange resourceStateChange ) { if ! mtask . isResourceFound ( res ) { seelog . Criticalf ( " " , mtask . Arn , res . GetName ( ) ) return } status := resChange . nextState err := resChange . err currentKnownStatus := res . GetKnownStatus ( ) if status <= currentKnownStatus { seelog . Infof ( " " , mtask . Arn , res . GetName ( ) , res . StatusString ( status ) , res . StatusString ( currentKnownStatus ) ) return } if err == nil { res . SetKnownStatus ( status ) mtask . engine . saver . Save ( ) return } seelog . Debugf ( " " , mtask . Arn , res . GetName ( ) , res . StatusString ( status ) , err ) if status == res . SteadyState ( ) { seelog . Errorf ( " " , mtask . Arn , res . GetName ( ) ) mtask . SetDesiredStatus ( apitaskstatus . TaskStopped ) mtask . Task . SetTerminalReason ( res . GetTerminalReason ( ) ) mtask . engine . saver . Save ( ) } } 
func ( mtask * managedTask ) emitContainerEvent ( task * apitask . Task , cont * apicontainer . Container , reason string ) { event , err := api . NewContainerStateChangeEvent ( task , cont , reason ) if err != nil { seelog . Debugf ( " " , task . Arn , cont . Name , err ) return } seelog . Infof ( " " , mtask . Arn , cont . Name , event . String ( ) ) mtask . stateChangeEvents <- event seelog . Infof ( " " , mtask . Arn , cont . Name , event . String ( ) ) } 
func ( mtask * managedTask ) releaseIPInIPAM ( ) { if mtask . ENI == nil { return } seelog . Infof ( " " , mtask . Arn ) cfg , err := mtask . BuildCNIConfig ( ) if err != nil { seelog . Warnf ( " " , mtask . Arn , err ) return } err = mtask . cniClient . ReleaseIPResource ( cfg ) if err != nil { seelog . Warnf ( " " , mtask . Arn , err ) return } } 
func ( mtask * managedTask ) handleStoppedToRunningContainerTransition ( status apicontainerstatus . ContainerStatus , container * apicontainer . Container ) { containerKnownStatus := container . GetKnownStatus ( ) if status > containerKnownStatus { } if containerKnownStatus != apicontainerstatus . ContainerStopped { } if ! status . IsRunning ( ) { } go mtask . engine . transitionContainer ( mtask . Task , container , apicontainerstatus . ContainerStopped ) } 
func ( mtask * managedTask ) handleEventError ( containerChange dockerContainerChange , currentKnownStatus apicontainerstatus . ContainerStatus ) bool { container := containerChange . container event := containerChange . event if container . ApplyingError == nil { container . ApplyingError = apierrors . NewNamedError ( event . Error ) } switch event . Status { return false } case apicontainerstatus . ContainerStopped : case apicontainerstatus . ContainerStatusNone : fallthrough case apicontainerstatus . ContainerCreated : container . SetKnownStatus ( currentKnownStatus ) container . SetDesiredStatus ( apicontainerstatus . ContainerStopped ) return false default : container . SetKnownStatus ( currentKnownStatus ) container . SetDesiredStatus ( apicontainerstatus . ContainerStopped ) errorName := event . Error . ErrorName ( ) if errorName == dockerapi . DockerTimeoutErrorName || errorName == dockerapi . CannotInspectContainerErrorName { go mtask . engine . transitionContainer ( mtask . Task , container , apicontainerstatus . ContainerStopped ) } } } 
func ( mtask * managedTask ) handleContainerStoppedTransitionError ( event dockerapi . DockerContainerChangeEvent , container * apicontainer . Container , currentKnownStatus apicontainerstatus . ContainerStatus ) bool { container . SetKnownStatus ( currentKnownStatus ) return false } if ok && cannotStopContainerError . IsRetriableError ( ) { seelog . Infof ( " " , mtask . Arn , container . Name , cannotStopContainerError . Error ( ) ) container . SetKnownStatus ( currentKnownStatus ) return false } container . SetKnownStatus ( apicontainerstatus . ContainerStopped ) container . SetDesiredStatus ( apicontainerstatus . ContainerStopped ) return true } 
func ( mtask * managedTask ) progressTask ( ) { seelog . Debugf ( " " , mtask . Arn ) transitionChange := make ( chan struct { } , len ( mtask . Containers ) + len ( resources ) ) transitionChangeEntity := make ( chan string , len ( mtask . Containers ) + len ( resources ) ) transitionChange <- struct { } { } transitionChangeEntity <- resource . GetName ( ) } ) anyContainerTransition , blockedDependencies , contTransitions , reasons := mtask . startContainerTransitions ( func ( container * apicontainer . Container , nextStatus apicontainerstatus . ContainerStatus ) { mtask . engine . transitionContainer ( mtask . Task , container , nextStatus ) transitionChange <- struct { } { } transitionChangeEntity <- container . Name } ) atLeastOneTransitionStarted := anyResourceTransition || anyContainerTransition blockedByOrderingDependencies := len ( blockedDependencies ) > 0 } return } ctx , cancel := context . WithTimeout ( context . Background ( ) , transitionPollTime ) defer cancel ( ) for timeout := mtask . waitEvent ( ctx . Done ( ) ) ; ! timeout ; { timeout = mtask . waitEvent ( ctx . Done ( ) ) } return } for k , v := range resTransitions { transitions [ k ] = v } for k , v := range contTransitions { transitions [ k ] = v . String ( ) } if changed { seelog . Debugf ( " " , mtask . Arn ) if mtask . GetKnownStatus ( ) . Terminal ( ) { taskStateChangeReason = mtask . Task . GetTerminalReason ( ) } mtask . emitTaskEvent ( mtask . Task , taskStateChangeReason ) } } 
func ( mtask * managedTask ) isWaitingForACSExecutionCredentials ( reasons [ ] error ) bool { for _ , reason := range reasons { if reason == dependencygraph . CredentialsNotResolvedErr { seelog . Debugf ( " " , mtask . Arn ) timeoutCtx , timeoutCancel := context . WithTimeout ( mtask . ctx , waitForPullCredentialsTimeout ) defer timeoutCancel ( ) timedOut := mtask . waitEvent ( timeoutCtx . Done ( ) ) if timedOut { seelog . Debugf ( " " , mtask . Arn ) } return true } } return false } 
func ( mtask * managedTask ) startContainerTransitions ( transitionFunc containerTransitionFunc ) ( bool , map [ string ] apicontainer . DependsOn , map [ string ] apicontainerstatus . ContainerStatus , [ ] error ) { anyCanTransition := false var reasons [ ] error blocked := make ( map [ string ] apicontainer . DependsOn ) transitions := make ( map [ string ] apicontainerstatus . ContainerStatus ) for _ , cont := range mtask . Containers { transition := mtask . containerNextState ( cont ) if transition . reason != nil { if transition . blockedOn != nil { blocked [ cont . Name ] = * transition . blockedOn } continue } continue } if ! transition . actionRequired { } ( cont , transition . nextState ) continue } transitions [ cont . Name ] = transition . nextState go transitionFunc ( cont , transition . nextState ) } return anyCanTransition , blocked , transitions , reasons } 
func ( mtask * managedTask ) startResourceTransitions ( transitionFunc resourceTransitionFunc ) ( bool , map [ string ] string ) { anyCanTransition := false transitions := make ( map [ string ] string ) for _ , res := range mtask . GetResources ( ) { knownStatus := res . GetKnownStatus ( ) desiredStatus := res . GetDesiredStatus ( ) if knownStatus >= desiredStatus { seelog . Debugf ( " " , mtask . Arn , res . GetName ( ) , res . StatusString ( desiredStatus ) , res . StatusString ( knownStatus ) ) continue } anyCanTransition = true transition := mtask . resourceNextState ( res ) } if ! transition . actionRequired { continue } go transitionFunc ( res , transition . nextState ) } return anyCanTransition , transitions } 
func ( mtask * managedTask ) transitionResource ( resource taskresource . TaskResource , to resourcestatus . ResourceStatus ) { err := mtask . applyResourceState ( resource , to ) if mtask . engine . isTaskManaged ( mtask . Arn ) { mtask . emitResourceChange ( resourceStateChange { resource : resource , nextState : to , err : err , } ) } } 
func ( mtask * managedTask ) applyResourceState ( resource taskresource . TaskResource , nextState resourcestatus . ResourceStatus ) error { resName := resource . GetName ( ) resStatus := resource . StatusString ( nextState ) err := resource . ApplyTransition ( nextState ) if err != nil { seelog . Infof ( " " , mtask . Arn , resName , resStatus , err ) return err } seelog . Debugf ( " " , mtask . Arn , resName , resStatus ) return nil } 
func ( mtask * managedTask ) containerNextState ( container * apicontainer . Container ) * containerTransition { containerKnownStatus := container . GetKnownStatus ( ) containerDesiredStatus := container . GetDesiredStatus ( ) if containerKnownStatus == containerDesiredStatus { seelog . Debugf ( " " , mtask . Arn , container . Name , containerDesiredStatus . String ( ) ) return & containerTransition { nextState : apicontainerstatus . ContainerStatusNone , actionRequired : false , reason : dependencygraph . ContainerPastDesiredStatusErr , } } if containerKnownStatus > containerDesiredStatus { seelog . Debugf ( " " , mtask . Arn , container . Name , containerKnownStatus . String ( ) , containerDesiredStatus . String ( ) ) return & containerTransition { nextState : apicontainerstatus . ContainerStatusNone , actionRequired : false , reason : dependencygraph . ContainerPastDesiredStatusErr , } } if blocked , err := dependencygraph . DependenciesAreResolved ( container , mtask . Containers , mtask . Task . GetExecutionCredentialsID ( ) , mtask . credentialsManager , mtask . GetResources ( ) ) ; err != nil { seelog . Debugf ( " " , mtask . Arn , container . Name , err ) return & containerTransition { nextState : apicontainerstatus . ContainerStatusNone , actionRequired : false , reason : err , blockedOn : blocked , } } var nextState apicontainerstatus . ContainerStatus if container . DesiredTerminal ( ) { nextState = apicontainerstatus . ContainerStopped } return & containerTransition { nextState : nextState , actionRequired : false , } } } else { nextState = container . GetNextKnownStateProgression ( ) } return & containerTransition { nextState : nextState , actionRequired : true , } } 
func ( mtask * managedTask ) waitForStopReported ( ) bool { stoppedSentBool := make ( chan struct { } ) taskStopped := false go func ( ) { for i := 0 ; i < _maxStoppedWaitTimes ; i ++ { if sentStatus >= apitaskstatus . TaskStopped { taskStopped = true break } seelog . Warnf ( " " , mtask . Arn , sentStatus . String ( ) , i + 1 , _maxStoppedWaitTimes ) mtask . _time . Sleep ( _stoppedSentWaitInterval ) } stoppedSentBool <- struct { } { } close ( stoppedSentBool ) } ( ) return taskStopped } 
func NewFactory ( ctx context . Context , endpoint string ) Factory { return & factory { endpoint : endpoint , clients : findDockerVersions ( ctx , endpoint ) , } } 
func ( f * factory ) FindClientAPIVersion ( client sdkclient . Client ) dockerclient . DockerVersion { return dockerclient . DockerVersion ( client . ClientVersion ( ) ) } 
func ( f * factory ) getClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { client , ok := f . clients [ version ] if ! ok { return nil , errors . New ( " " + string ( version ) ) } return client , nil } 
func findDockerVersions ( ctx context . Context , endpoint string ) map [ dockerclient . DockerVersion ] sdkclient . Client { if err == nil { derivedCtx , cancel := context . WithTimeout ( ctx , dockerclient . VersionTimeout ) defer cancel ( ) serverVersion , err := client . ServerVersion ( derivedCtx ) if err == nil { apiVersion = serverVersion . APIVersion } } } clients := make ( map [ dockerclient . DockerVersion ] sdkclient . Client ) for _ , version := range dockerclient . GetKnownAPIVersions ( ) { dockerClient , err := getDockerClientForVersion ( endpoint , string ( version ) , minAPIVersion , apiVersion , ctx ) if err != nil { log . Infof ( " " , version , err ) continue } clients [ version ] = dockerClient } return clients } 
func ( h * handler ) Execute ( args [ ] string , requests <- chan svc . ChangeRequest , responses chan <- svc . Status ) ( bool , uint32 ) { defer seelog . Flush ( ) agentDone := make ( chan struct { } ) windowsDone := make ( chan struct { } ) wg := sync . WaitGroup { } wg . Add ( 2 ) go func ( ) { defer close ( windowsDone ) defer wg . Done ( ) h . handleWindowsRequests ( ctx , requests , responses ) } ( ) var agentExitCode uint32 go func ( ) { defer close ( agentDone ) defer wg . Done ( ) agentExitCode = h . runAgent ( ctx ) } ( ) case <- agentDone : } cancel ( ) wg . Wait ( ) seelog . Infof ( " " , agentExitCode ) return true , agentExitCode } 
func ( h * handler ) handleWindowsRequests ( ctx context . Context , requests <- chan svc . ChangeRequest , responses chan <- svc . Status ) { seelog . Info ( " " ) defer func ( ) { responses <- svc . Status { State : svc . StopPending } } ( ) for { select { case <- ctx . Done ( ) : return case r := <- requests : switch r . Cmd { case svc . Interrogate : case svc . Stop , svc . Shutdown : return default : continue } } } } 
func ( h * handler ) runAgent ( ctx context . Context ) uint32 { agentCtx , cancel := context . WithCancel ( ctx ) indicator := newTermHandlerIndicator ( ) terminationHandler := func ( saver statemanager . Saver , taskEngine engine . TaskEngine ) { indicator . setInvoked ( ) <- agentCtx . Done ( ) if ! indicator . isAgentRunning ( ) { return } seelog . Info ( " " ) err := sighandlers . FinalSave ( saver , taskEngine ) if err != nil { seelog . Criticalf ( " " , err ) } } h . ecsAgent . setTerminationHandler ( terminationHandler ) go func ( ) { defer cancel ( ) exitCode := h . ecsAgent . start ( ) if exitCode == exitcodes . ExitTerminal { seelog . Critical ( " " ) } indicator . agentStopped ( exitCode ) } ( ) sleepCtx ( agentCtx , time . Minute ) } 
func sleepCtx ( ctx context . Context , duration time . Duration ) { derivedCtx , _ := context . WithDeadline ( ctx , time . Now ( ) . Add ( duration ) ) <- derivedCtx . Done ( ) } 
func TaskMetadataHandler ( state dockerstate . TaskEngineState , ecsClient api . ECSClient , cluster , az , containerInstanceArn string , propagateTags bool ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeTaskMetadata ) return } seelog . Infof ( " " , taskARN ) taskResponse , err := v2 . NewTaskResponse ( taskARN , state , ecsClient , cluster , az , containerInstanceArn , propagateTags ) if err != nil { errResponseJSON , _ := json . Marshal ( " " + taskARN + " " ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskMetadata ) return } task , _ := state . TaskByArn ( taskARN ) if task . GetTaskENI ( ) == nil { for _ , containerResponse := range taskResponse . Containers { networks , err := GetContainerNetworkMetadata ( containerResponse . ID , state ) if err != nil { errResponseJSON , _ := json . Marshal ( err . Error ( ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerMetadata ) return } containerResponse . Networks = networks responses = append ( responses , containerResponse ) } taskResponse . Containers = responses } responseJSON , _ := json . Marshal ( taskResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeTaskMetadata ) } } 
func ( eventStream * EventStream ) Subscribe ( name string , handler eventHandler ) error { eventStream . handlersLock . Lock ( ) defer eventStream . handlersLock . Unlock ( ) if _ , ok := eventStream . handlers [ name ] ; ok { return fmt . Errorf ( " " , name ) } eventStream . handlers [ name ] = handler return nil } 
func ( eventStream * EventStream ) broadcast ( event interface { } ) { eventStream . handlersLock . RLock ( ) defer eventStream . handlersLock . RUnlock ( ) seelog . Debugf ( " " , eventStream . name ) for _ , handlerFunc := range eventStream . handlers { go handlerFunc ( event ) } } 
func ( eventStream * EventStream ) Unsubscribe ( name string ) { eventStream . handlersLock . Lock ( ) defer eventStream . handlersLock . Unlock ( ) for handler := range eventStream . handlers { if handler == name { seelog . Debugf ( " " , handler , eventStream . name ) delete ( eventStream . handlers , handler ) return } } } 
func ( eventStream * EventStream ) WriteToEventStream ( event interface { } ) error { eventStream . statusLock . RLock ( ) defer eventStream . statusLock . RUnlock ( ) if ! eventStream . open { return fmt . Errorf ( " " ) } eventStream . event <- event return nil } 
func ( eventStream * EventStream ) listen ( ) { seelog . Infof ( " " , eventStream . name ) for { select { case event := <- eventStream . event : eventStream . broadcast ( event ) case <- eventStream . ctx . Done ( ) : seelog . Infof ( " " , eventStream . name ) eventStream . statusLock . Lock ( ) eventStream . open = false close ( eventStream . event ) eventStream . statusLock . Unlock ( ) return } } } 
func ( eventStream * EventStream ) StartListening ( ) { eventStream . statusLock . Lock ( ) defer eventStream . statusLock . Unlock ( ) eventStream . open = true go eventStream . listen ( ) } 
func SetLevel ( logLevel string ) { parsedLevel , ok := levels [ strings . ToLower ( logLevel ) ] if ok { levelLock . Lock ( ) defer levelLock . Unlock ( ) level = parsedLevel reloadConfig ( ) } } 
func ForModule ( module string ) OldLogger { once . Do ( initLogger ) return logger . New ( " " , module ) } 
func NewMockWebsocketConn ( ctrl * gomock . Controller ) * MockWebsocketConn { mock := & MockWebsocketConn { ctrl : ctrl } mock . recorder = & MockWebsocketConnMockRecorder { mock } return mock } 
func ( mr * MockWebsocketConnMockRecorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockWebsocketConn ) ( nil ) . Close ) ) } 
func ( m * MockWebsocketConn ) ReadMessage ( ) ( int , [ ] byte , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( int ) ret1 , _ := ret [ 1 ] . ( [ ] byte ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 } 
func ( mr * MockWebsocketConnMockRecorder ) SetWriteDeadline ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockWebsocketConn ) ( nil ) . SetWriteDeadline ) , arg0 ) } 
func ( m * MockWebsocketConn ) WriteMessage ( arg0 int , arg1 [ ] byte ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func dockerStatsToContainerStats ( dockerStats * types . StatsJSON ) ( * ContainerStats , error ) { return nil , fmt . Errorf ( " " ) } cpuUsage := dockerStats . CPUStats . CPUUsage . TotalUsage / numCores memoryUsage := dockerStats . MemoryStats . Usage - dockerStats . MemoryStats . Stats [ " " ] return & ContainerStats { cpuUsage : cpuUsage , memoryUsage : memoryUsage , timestamp : dockerStats . Read , } , nil } 
func ( mr * MockClientMockRecorder ) Get ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockClient ) ( nil ) . Get ) , arg0 ) } 
func NewSSMSecretResource ( taskARN string , ssmSecrets map [ string ] [ ] apicontainer . Secret , executionCredentialsID string , credentialsManager credentials . Manager , ssmClientCreator factory . SSMClientCreator ) * SSMSecretResource { s := & SSMSecretResource { taskARN : taskARN , requiredSecrets : ssmSecrets , credentialsManager : credentialsManager , executionCredentialsID : executionCredentialsID , ssmClientCreator : ssmClientCreator , } s . initStatusToTransition ( ) return s } 
func ( secret * SSMSecretResource ) GetName ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return ResourceName } 
func ( secret * SSMSecretResource ) DesiredTerminal ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desiredStatusUnsafe == resourcestatus . ResourceStatus ( SSMSecretRemoved ) } 
func ( secret * SSMSecretResource ) KnownCreated ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . knownStatusUnsafe == resourcestatus . ResourceStatus ( SSMSecretCreated ) } 
func ( secret * SSMSecretResource ) ApplyTransition ( nextState resourcestatus . ResourceStatus ) error { transitionFunc , ok := secret . resourceStatusToTransitionFunction [ nextState ] if ! ok { return errors . Errorf ( " " , secret . GetName ( ) , secret . StatusString ( nextState ) ) } return transitionFunc ( ) } 
func ( secret * SSMSecretResource ) updateAppliedStatusUnsafe ( knownStatus resourcestatus . ResourceStatus ) { if secret . appliedStatus == resourcestatus . ResourceStatus ( SSMSecretStatusNone ) { return } } } 
func ( secret * SSMSecretResource ) SetAppliedStatus ( status resourcestatus . ResourceStatus ) bool { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . appliedStatus != resourcestatus . ResourceStatus ( SSMSecretStatusNone ) { } secret . appliedStatus = status return true } 
func ( secret * SSMSecretResource ) StatusString ( status resourcestatus . ResourceStatus ) string { return SSMSecretStatus ( status ) . String ( ) } 
func ( secret * SSMSecretResource ) SetCreatedAt ( createdAt time . Time ) { if createdAt . IsZero ( ) { return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . createdAt = createdAt } 
func ( secret * SSMSecretResource ) GetCreatedAt ( ) time . Time { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . createdAt } 
func ( secret * SSMSecretResource ) Create ( ) error { if ! ok { secret . setTerminalReason ( err . Error ( ) ) return err } iamCredentials := executionCredentials . GetIAMRoleCredentials ( ) var wg sync . WaitGroup errorEvents := make ( chan error , chanLen ) seelog . Infof ( " " , secret . taskARN ) secret . secretData = make ( map [ string ] string ) for region , secrets := range secret . getRequiredSecrets ( ) { wg . Add ( 1 ) } wg . Wait ( ) return err default : return nil } } 
func ( secret * SSMSecretResource ) getGoRoutineMaxNum ( ) int { total := 0 for _ , secrets := range secret . requiredSecrets { total += len ( secrets ) / MaxBatchNum + 1 } return total } 
func ( secret * SSMSecretResource ) retrieveSSMSecretValuesByRegion ( region string , secrets [ ] apicontainer . Secret , iamCredentials credentials . IAMRoleCredentials , wg * sync . WaitGroup , errorEvents chan error ) { seelog . Infof ( " " , region , secret . taskARN ) defer wg . Done ( ) var wgPerRegion sync . WaitGroup var secretNames [ ] string for _ , s := range secrets { secretKey := s . GetSecretResourceCacheKey ( ) if _ , ok := secret . GetCachedSecretValue ( secretKey ) ; ok { continue } secretNames = append ( secretNames , s . ValueFrom ) if len ( secretNames ) == MaxBatchNum { secretNamesTmp := make ( [ ] string , MaxBatchNum ) copy ( secretNamesTmp , secretNames ) wgPerRegion . Add ( 1 ) go secret . retrieveSSMSecretValues ( region , secretNamesTmp , iamCredentials , & wgPerRegion , errorEvents ) secretNames = [ ] string { } } } if len ( secretNames ) > 0 { wgPerRegion . Add ( 1 ) go secret . retrieveSSMSecretValues ( region , secretNames , iamCredentials , & wgPerRegion , errorEvents ) } wgPerRegion . Wait ( ) } 
func ( secret * SSMSecretResource ) retrieveSSMSecretValues ( region string , names [ ] string , iamCredentials credentials . IAMRoleCredentials , wg * sync . WaitGroup , errorEvents chan error ) { defer wg . Done ( ) ssmClient := secret . ssmClientCreator . NewSSMClient ( region , iamCredentials ) seelog . Infof ( " " , names , region , secret . taskARN ) secValueMap , err := ssm . GetSecretsFromSSM ( names , ssmClient ) if err != nil { errorEvents <- fmt . Errorf ( " " , region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . secretData [ secretKey ] = secretValue } } 
func ( secret * SSMSecretResource ) getExecutionCredentialsID ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . executionCredentialsID } 
func ( secret * SSMSecretResource ) clearSSMSecretValue ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key := range secret . secretData { delete ( secret . secretData , key ) } } 
func ( secret * SSMSecretResource ) GetCachedSecretValue ( secretKey string ) ( string , bool ) { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) s , ok := secret . secretData [ secretKey ] return s , ok } 
func ( secret * SSMSecretResource ) SetCachedSecretValue ( secretKey string , secretValue string ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . secretData == nil { secret . secretData = make ( map [ string ] string ) } secret . secretData [ secretKey ] = secretValue } 
func ( m * MockManager ) Clean ( arg0 string ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockManager ) Create ( arg0 * container . Config , arg1 * container . HostConfig , arg2 * task . Task , arg3 string ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockManager ) SetAvailabilityZone ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockManager ) SetContainerInstanceARN ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockManager ) SetHostPublicIPv4Address ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockManager ) Update ( arg0 context . Context , arg1 string , arg2 * task . Task , arg3 string ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func NewMockDockerMetadataClient ( ctrl * gomock . Controller ) * MockDockerMetadataClient { mock := & MockDockerMetadataClient { ctrl : ctrl } mock . recorder = & MockDockerMetadataClientMockRecorder { mock } return mock } 
func ( mr * MockDockerMetadataClientMockRecorder ) InspectContainer ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockDockerMetadataClient ) ( nil ) . InspectContainer ) , arg0 , arg1 , arg2 ) } 
func JsonKeys ( b [ ] byte ) ( [ ] string , error ) { var keyMap map [ string ] interface { } err := json . Unmarshal ( b , & keyMap ) if err != nil { return [ ] string { } , err } keys := make ( [ ] string , len ( keyMap ) ) ndx := 0 for k := range keyMap { keys [ ndx ] = k ndx ++ } return keys , nil } 
func CompleteJsonUnmarshal ( b [ ] byte , iface interface { } ) error { keys , err := JsonKeys ( b ) if err != nil { return err } structType := reflect . ValueOf ( iface ) . Type ( ) for _ , key := range keys { _ , found := structType . FieldByNameFunc ( func ( name string ) bool { structField , _ := structType . FieldByName ( name ) jsonTag := structField . Tag . Get ( " " ) jsonName := strings . Split ( jsonTag , " " ) [ 0 ] if jsonName == key { return true } if strings . EqualFold ( key , structField . Name ) { return true } return false } ) if ! found { } } return nil } 
func TaskContainerMetadataHandler ( state dockerstate . TaskEngineState , ecsClient api . ECSClient , cluster , az , containerInstanceArn string , propagateTags bool ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeTaskMetadata ) return } if containerID , ok := utils . GetMuxValueFromRequest ( r , metadataContainerIDMuxName ) ; ok { seelog . Infof ( " " , containerID ) WriteContainerMetadataResponse ( w , containerID , state ) return } seelog . Infof ( " " , taskARN ) WriteTaskMetadataResponse ( w , taskARN , cluster , state , ecsClient , az , containerInstanceArn , propagateTags ) } } 
func WriteContainerMetadataResponse ( w http . ResponseWriter , containerID string , state dockerstate . TaskEngineState ) { containerResponse , err := NewContainerResponse ( containerID , state ) if err != nil { errResponseJSON , _ := json . Marshal ( " " + containerID + " " ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerMetadata ) return } responseJSON , _ := json . Marshal ( containerResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeContainerMetadata ) } 
func WriteTaskMetadataResponse ( w http . ResponseWriter , taskARN string , cluster string , state dockerstate . TaskEngineState , ecsClient api . ECSClient , az , containerInstanceArn string , propagateTags bool ) { if err != nil { errResponseJSON , _ := json . Marshal ( " " + taskARN + " " ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskMetadata ) return } responseJSON , _ := json . Marshal ( taskResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeTaskMetadata ) } 
func ( c * control ) Init ( ) error { seelog . Infof ( " " , config . DefaultTaskCgroupPrefix ) _ , err := c . Create ( cgroupSpec ) return err } 
func writeToMetadataFile ( osWrap oswrapper . OS , ioutilWrap ioutilwrapper . IOUtil , data [ ] byte , taskARN string , containerName string , dataDir string ) error { metadataFileDir , err := getMetadataFilePath ( taskARN , containerName , dataDir ) } metadataFileName := filepath . Join ( metadataFileDir , metadataFile ) file , err := osWrap . OpenFile ( metadataFileName , os . O_WRONLY | os . O_CREATE , metadataPerm ) if err != nil { return err } defer file . Close ( ) _ , err = file . Write ( data ) if err != nil { return err } return file . Sync ( ) } 
func ( err * WSError ) Error ( ) string { val := reflect . ValueOf ( err . ErrObj ) if val . Kind ( ) == reflect . Ptr { val = val . Elem ( ) } var typeStr = " " if val . IsValid ( ) { typeStr = val . Type ( ) . Name ( ) msg := val . FieldByName ( " " ) if msg . IsValid ( ) && msg . CanInterface ( ) { str , ok := msg . Interface ( ) . ( * string ) if ok { if str == nil { return typeStr + " " } return typeStr + " " + * str } } } if asErr , ok := err . ErrObj . ( error ) ; ok { return err . Type + " " + asErr . Error ( ) } return err . Type + " " + typeStr + " " } 
func ( err * WSError ) Retry ( ) bool { for _ , unretriable := range err . Get ( ) { if reflect . TypeOf ( err . ErrObj ) == reflect . TypeOf ( unretriable ) { return false } } return true } 
func NewMockDockerStateResolver ( ctrl * gomock . Controller ) * MockDockerStateResolver { mock := & MockDockerStateResolver { ctrl : ctrl } mock . recorder = & MockDockerStateResolverMockRecorder { mock } return mock } 
func ( m * MockDockerStateResolver ) State ( ) dockerstate . TaskEngineState { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( dockerstate . TaskEngineState ) return ret0 } 
func ( mr * MockDockerStateResolverMockRecorder ) State ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockDockerStateResolver ) ( nil ) . State ) ) } 
func printLicense ( ) int { license := utils . NewLicenseProvider ( ) text , err := license . GetText ( ) if err != nil { fmt . Fprintln ( os . Stderr , err ) return exitcodes . ExitError } fmt . Println ( text ) return exitcodes . ExitSuccess } 
func ( c * GlobalCgroupFactory ) Load ( hierarchy cgroups . Hierarchy , path cgroups . Path ) ( cgroups . Cgroup , error ) { return cgroups . Load ( hierarchy , path ) } 
func ( c * GlobalCgroupFactory ) New ( hierarchy cgroups . Hierarchy , path cgroups . Path , specs * specs . LinuxResources ) ( cgroups . Cgroup , error ) { return cgroups . New ( hierarchy , path , specs ) } 
func PrintVersion ( ) int { cleanliness := " " if GitDirty { cleanliness = " \t \n " } fmt . Printf ( `Amazon ECS Agent: Version: %v Commit: %v %v` , Version , GitShortHash , cleanliness ) return exitcodes . ExitSuccess } 
func timeoutAndMoveOn ( fp loiterFunc , timeout time . Duration ) { ch := time . After ( timeout ) for { select { case <- ch : return default : fp ( ) } } } 
func NewDockerTaskEngine ( cfg * config . Config , client dockerapi . DockerClient , credentialsManager credentials . Manager , containerChangeEventStream * eventstream . EventStream , imageManager ImageManager , state dockerstate . TaskEngineState , metadataManager containermetadata . Manager , resourceFields * taskresource . ResourceFields ) * DockerTaskEngine { dockerTaskEngine := & DockerTaskEngine { cfg : cfg , client : client , saver : statemanager . NewNoopStateManager ( ) , state : state , managedTasks : make ( map [ string ] * managedTask ) , taskStopGroup : utilsync . NewSequentialWaitGroup ( ) , stateChangeEvents : make ( chan statechange . Event ) , credentialsManager : credentialsManager , containerChangeEventStream : containerChangeEventStream , imageManager : imageManager , cniClient : ecscni . NewClient ( & ecscni . Config { PluginsPath : cfg . CNIPluginsPath , MinSupportedCNIVersion : config . DefaultMinSupportedCNIVersion , } ) , metadataManager : metadataManager , taskSteadyStatePollInterval : defaultTaskSteadyStatePollInterval , resourceFields : resourceFields , } dockerTaskEngine . initializeContainerStatusToTransitionFunction ( ) return dockerTaskEngine } 
func ( engine * DockerTaskEngine ) UnmarshalJSON ( data [ ] byte ) error { return engine . state . UnmarshalJSON ( data ) } 
func ( engine * DockerTaskEngine ) Init ( ctx context . Context ) error { engine . stopEngine = cancel engine . ctx = derivedCtx if err != nil { return err } engine . synchronizeState ( ) engine . initialized = true return nil } 
func ( engine * DockerTaskEngine ) MustInit ( ctx context . Context ) { if engine . initialized { return } engine . mustInitLock . Lock ( ) defer engine . mustInitLock . Unlock ( ) errorOnce := sync . Once { } taskEngineConnectBackoff := retry . NewExponentialBackoff ( minEngineConnectRetryDelay , maxEngineConnectRetryDelay , engineConnectRetryJitterMultiplier , engineConnectRetryDelayMultiplier ) retry . RetryWithBackoff ( taskEngineConnectBackoff , func ( ) error { if engine . initialized { return nil } err := engine . Init ( ctx ) if err != nil { errorOnce . Do ( func ( ) { seelog . Errorf ( " " , err ) } ) } return err } ) } 
func ( engine * DockerTaskEngine ) isTaskManaged ( arn string ) bool { engine . tasksLock . RLock ( ) defer engine . tasksLock . RUnlock ( ) _ , ok := engine . managedTasks [ arn ] return ok } 
func ( engine * DockerTaskEngine ) synchronizeState ( ) { engine . tasksLock . Lock ( ) defer engine . tasksLock . Unlock ( ) imageStates := engine . state . AllImageStates ( ) if len ( imageStates ) != 0 { engine . imageManager . AddAllImageStates ( imageStates ) } tasks := engine . state . AllTasks ( ) tasksToStart := engine . filterTasksToStartUnsafe ( tasks ) for _ , task := range tasks { task . InitializeResources ( engine . resourceFields ) } for _ , task := range tasksToStart { engine . startTask ( task ) } engine . saver . Save ( ) } 
func ( engine * DockerTaskEngine ) filterTasksToStartUnsafe ( tasks [ ] * apitask . Task ) [ ] * apitask . Task { var tasksToStart [ ] * apitask . Task for _ , task := range tasks { conts , ok := engine . state . ContainerMapByArn ( task . Arn ) if ! ok { continue } for _ , cont := range conts { engine . synchronizeContainerStatus ( cont , task ) } tasksToStart = append ( tasksToStart , task ) } } return tasksToStart } 
func updateContainerMetadata ( metadata * dockerapi . DockerContainerMetadata , container * apicontainer . Container , task * apitask . Task ) { container . SetCreatedAt ( metadata . CreatedAt ) container . SetStartedAt ( metadata . StartedAt ) container . SetFinishedAt ( metadata . FinishedAt ) } } else { container . SetVolumes ( metadata . Volumes ) } } } } } container . SetNetworkMode ( metadata . NetworkMode ) container . SetNetworkSettings ( metadata . NetworkSettings ) } 
func ( engine * DockerTaskEngine ) synchronizeContainerStatus ( container * apicontainer . DockerContainer , task * apitask . Task ) { if container . DockerID == " " { seelog . Debugf ( " " , task . Arn , container . DockerName ) if err != nil { seelog . Warnf ( " " , task . Arn , container . DockerName , err ) } else { updateContainerMetadata ( & metadata , container . Container , task ) container . DockerID = describedContainer . ID container . Container . SetKnownStatus ( dockerapi . DockerStateToState ( describedContainer . State ) ) engine . imageManager . RecordContainerReference ( container . Container ) } return } currentState , metadata := engine . client . DescribeContainer ( engine . ctx , container . DockerID ) if metadata . Error != nil { currentState = apicontainerstatus . ContainerStopped if ! container . Container . KnownTerminal ( ) { container . Container . ApplyingError = apierrors . NewNamedError ( & ContainerVanishedError { } ) engine . imageManager . RemoveContainerReferenceFromImageState ( container . Container ) } } else { container . Container . ApplyingError = apierrors . NewNamedError ( metadata . Error ) } } else { engine . imageManager . RecordContainerReference ( container . Container ) if engine . cfg . ContainerMetadataEnabled && ! container . Container . IsMetadataFileUpdated ( ) { go engine . updateMetadataFile ( task , container ) } } if currentState > container . Container . GetKnownStatus ( ) { } } 
func ( engine * DockerTaskEngine ) checkTaskState ( task * apitask . Task ) { defer metrics . MetricsEngineGlobal . RecordTaskEngineMetric ( " " ) ( ) taskContainers , ok := engine . state . ContainerMapByArn ( task . Arn ) if ! ok { seelog . Warnf ( " " , task . Arn ) return } for _ , container := range task . Containers { dockerContainer , ok := taskContainers [ container . Name ] if ! ok { continue } status , metadata := engine . client . DescribeContainer ( engine . ctx , dockerContainer . DockerID ) engine . tasksLock . RLock ( ) managedTask , ok := engine . managedTasks [ task . Arn ] engine . tasksLock . RUnlock ( ) if ok { managedTask . emitDockerContainerChange ( dockerContainerChange { container : container , event : dockerapi . DockerContainerChangeEvent { Status : status , DockerContainerMetadata : metadata , } , } ) } } } 
func ( engine * DockerTaskEngine ) sweepTask ( task * apitask . Task ) { for _ , cont := range task . Containers { err := engine . removeContainer ( task , cont ) if err != nil { seelog . Debugf ( " " , task . Arn , cont . Name , err ) } } err = engine . imageManager . RemoveContainerReferenceFromImageState ( cont ) if err != nil { seelog . Errorf ( " " , task . Arn , cont . Name , err ) } } if err != nil { seelog . Warnf ( " " , task . Arn , err ) } } engine . saver . Save ( ) } 
func ( engine * DockerTaskEngine ) startTask ( task * apitask . Task ) { thisTask . _time = engine . time ( ) go thisTask . overseeTask ( ) } 
func ( engine * DockerTaskEngine ) openEventstream ( ctx context . Context ) error { events , err := engine . client . ContainerEvents ( ctx ) if err != nil { return err } engine . events = events return nil } 
func ( engine * DockerTaskEngine ) handleDockerEvents ( ctx context . Context ) { for { select { case <- ctx . Done ( ) : return case event := <- engine . events : engine . handleDockerEvent ( event ) } } } 
func ( engine * DockerTaskEngine ) handleDockerEvent ( event dockerapi . DockerContainerChangeEvent ) { seelog . Debugf ( " " , event . String ( ) ) task , ok := engine . state . TaskByID ( event . DockerID ) if ! ok { seelog . Debugf ( " " , event . DockerID ) return } cont , ok := engine . state . ContainerByID ( event . DockerID ) if ! ok { seelog . Debugf ( " " , event . DockerID ) return } cont . Container . SetHealthStatus ( event . DockerContainerMetadata . Health ) } return } engine . tasksLock . RLock ( ) managedTask , ok := engine . managedTasks [ task . Arn ] if ! ok { seelog . Criticalf ( " " , task . Arn , event . String ( ) ) return } seelog . Debugf ( " " , task . Arn , event . String ( ) ) managedTask . emitDockerContainerChange ( dockerContainerChange { container : cont . Container , event : event } ) seelog . Debugf ( " " , task . Arn , event . String ( ) ) } 
func ( engine * DockerTaskEngine ) AddTask ( task * apitask . Task ) { defer metrics . MetricsEngineGlobal . RecordTaskEngineMetric ( " " ) ( ) err := task . PostUnmarshalTask ( engine . cfg , engine . credentialsManager , engine . resourceFields , engine . client , engine . ctx ) if err != nil { seelog . Errorf ( " " , task . Arn , err ) task . SetKnownStatus ( apitaskstatus . TaskStopped ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) engine . emitTaskEvent ( task , err . Error ( ) ) return } engine . tasksLock . Lock ( ) defer engine . tasksLock . Unlock ( ) existingTask , exists := engine . state . TaskByArn ( task . Arn ) if ! exists { engine . state . AddTask ( task ) if dependencygraph . ValidDependencies ( task ) { engine . startTask ( task ) } else { seelog . Errorf ( " " , task . Arn ) task . SetKnownStatus ( apitaskstatus . TaskStopped ) task . SetDesiredStatus ( apitaskstatus . TaskStopped ) err := TaskDependencyError { task . Arn } engine . emitTaskEvent ( task , err . Error ( ) ) } return } } 
func ( engine * DockerTaskEngine ) ListTasks ( ) ( [ ] * apitask . Task , error ) { return engine . state . AllTasks ( ) , nil } 
func ( engine * DockerTaskEngine ) GetTaskByArn ( arn string ) ( * apitask . Task , bool ) { return engine . state . TaskByArn ( arn ) } 
func ( engine * DockerTaskEngine ) imagePullRequired ( imagePullBehavior config . ImagePullBehaviorType , container * apicontainer . Container , taskArn string ) bool { switch imagePullBehavior { case config . ImagePullOnceBehavior : if ok && imageState . GetPullSucceeded ( ) { seelog . Infof ( " " , taskArn , container . Image , container . Name ) return false } return true case config . ImagePullPreferCachedBehavior : if err != nil { return true } seelog . Infof ( " " , taskArn , container . Image , container . Name ) return false default : } } 
func ( engine * DockerTaskEngine ) cleanupPauseContainerNetwork ( task * apitask . Task , container * apicontainer . Container ) error { seelog . Infof ( " " , task . Arn ) cniConfig , err := engine . buildCNIConfigFromTaskContainer ( task , container ) if err != nil { return errors . Wrapf ( err , " " , task . String ( ) ) } return engine . cniClient . CleanupNS ( engine . ctx , cniConfig , cniCleanupTimeout ) } 
func ( engine * DockerTaskEngine ) updateTaskUnsafe ( task * apitask . Task , update * apitask . Task ) { managedTask , ok := engine . managedTasks [ task . Arn ] if ! ok { seelog . Criticalf ( " " , task . Arn ) return } seelog . Debugf ( " " , task . Arn , updateDesiredStatus . String ( ) , update . StopSequenceNumber ) managedTask . emitACSTransition ( acsTransition { desiredStatus : updateDesiredStatus , seqnum : update . StopSequenceNumber , } ) seelog . Debugf ( " " , task . Arn , updateDesiredStatus . String ( ) , update . StopSequenceNumber ) } 
func ( engine * DockerTaskEngine ) transitionContainer ( task * apitask . Task , container * apicontainer . Container , to apicontainerstatus . ContainerStatus ) { engine . tasksLock . RLock ( ) managedTask , ok := engine . managedTasks [ task . Arn ] engine . tasksLock . RUnlock ( ) if ok { managedTask . emitDockerContainerChange ( dockerContainerChange { container : container , event : dockerapi . DockerContainerChangeEvent { Status : to , DockerContainerMetadata : metadata , } , } ) } } 
func ( engine * DockerTaskEngine ) applyContainerState ( task * apitask . Task , container * apicontainer . Container , nextState apicontainerstatus . ContainerStatus ) dockerapi . DockerContainerMetadata { transitionFunction , ok := engine . transitionFunctionMap ( ) [ nextState ] if ! ok { seelog . Criticalf ( " " , task . Arn , container . Name , nextState . String ( ) ) return dockerapi . DockerContainerMetadata { Error : & impossibleTransitionError { nextState } } } metadata := transitionFunction ( task , container ) if metadata . Error != nil { seelog . Infof ( " " , task . Arn , container . Name , nextState . String ( ) , metadata . Error ) } else { seelog . Debugf ( " " , task . Arn , container . Name , nextState . String ( ) ) engine . saver . Save ( ) } return metadata } 
func ( engine * DockerTaskEngine ) Version ( ) ( string , error ) { return engine . client . Version ( engine . ctx , dockerclient . VersionTimeout ) } 
func NewMockSSMClient ( ctrl * gomock . Controller ) * MockSSMClient { mock := & MockSSMClient { ctrl : ctrl } mock . recorder = & MockSSMClientMockRecorder { mock } return mock } 
func ( m * MockSSMClient ) GetParameters ( arg0 * ssm . GetParametersInput ) ( * ssm . GetParametersOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ssm . GetParametersOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockSSMClientMockRecorder ) GetParameters ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockSSMClient ) ( nil ) . GetParameters ) , arg0 ) } 
func NewMockFactory ( ctrl * gomock . Controller ) * MockFactory { mock := & MockFactory { ctrl : ctrl } mock . recorder = & MockFactoryMockRecorder { mock } return mock } 
func ( m * MockFactory ) FindClientAPIVersion ( arg0 sdkclient . Client ) dockerclient . DockerVersion { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( dockerclient . DockerVersion ) return ret0 } 
func ( m * MockFactory ) FindKnownAPIVersions ( ) [ ] dockerclient . DockerVersion { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] dockerclient . DockerVersion ) return ret0 } 
func ( m * MockFactory ) GetClient ( arg0 dockerclient . DockerVersion ) ( sdkclient . Client , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( sdkclient . Client ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockFactory ) GetDefaultClient ( ) ( sdkclient . Client , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( sdkclient . Client ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func NewMockFileSystem ( ctrl * gomock . Controller ) * MockFileSystem { mock := & MockFileSystem { ctrl : ctrl } mock . recorder = & MockFileSystemMockRecorder { mock } return mock } 
func ( m * MockFileSystem ) Copy ( arg0 io . Writer , arg1 io . Reader ) ( int64 , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( int64 ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockFileSystem ) Exit ( arg0 int ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockFileSystem ) MkdirAll ( arg0 string , arg1 os . FileMode ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockFileSystem ) Open ( arg0 string ) ( io . ReadWriteCloser , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( io . ReadWriteCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockFileSystem ) ReadAll ( arg0 io . Reader ) ( [ ] byte , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( [ ] byte ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockFileSystem ) Remove ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockFileSystemMockRecorder ) Remove ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockFileSystem ) ( nil ) . Remove ) , arg0 ) } 
func ( m * MockFileSystem ) Rename ( arg0 , arg1 string ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockFileSystem ) TeeReader ( arg0 io . Reader , arg1 io . Writer ) io . Reader { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( io . Reader ) return ret0 } 
func ( m * MockFileSystem ) TempFile ( arg0 , arg1 string ) ( * os . File , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( * os . File ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( agent * ecsAgent ) initializeTaskENIDependencies ( state dockerstate . TaskEngineState , taskEngine engine . TaskEngine ) ( error , bool ) { } } } } return err , false } if err := agent . startUdevWatcher ( state , taskEngine . StateChangeEvents ( ) ) ; err != nil { } return nil , false } 
func ( agent * ecsAgent ) setVPCSubnet ( ) ( error , bool ) { mac , err := agent . ec2MetadataClient . PrimaryENIMAC ( ) if err != nil { return fmt . Errorf ( " " , err ) , false } vpcID , err := agent . ec2MetadataClient . VPCID ( mac ) if err != nil { if isInstanceLaunchedInVPC ( err ) { return fmt . Errorf ( " " , err ) , true } return instanceNotLaunchedInVPCError , false } subnetID , err := agent . ec2MetadataClient . SubnetID ( mac ) if err != nil { return fmt . Errorf ( " " , err ) , false } agent . vpc = vpcID agent . subnet = subnetID agent . mac = mac return nil , false } 
func isInstanceLaunchedInVPC ( err error ) bool { if metadataErr , ok := err . ( * ec2 . MetadataError ) ; ok && metadataErr . GetStatusCode ( ) == http . StatusNotFound { return false } return true } 
func ( agent * ecsAgent ) verifyCNIPluginsCapabilities ( ) error { if err != nil { return err } } if ! contains ( capabilities , ecscni . CapabilityAWSVPCNetworkingMode ) { return errors . Errorf ( " " , plugin , ecscni . CapabilityAWSVPCNetworkingMode ) } } return nil } 
func ( agent * ecsAgent ) startUdevWatcher ( state dockerstate . TaskEngineState , stateChangeEvents chan <- statechange . Event ) error { seelog . Debug ( " " ) udevMonitor , err := udevwrapper . New ( ) if err != nil { return errors . Wrapf ( err , " " ) } if err := eniWatcher . Init ( ) ; err != nil { return errors . Wrapf ( err , " " ) } go eniWatcher . Start ( ) return nil } 
func ( agent * ecsAgent ) initializeResourceFields ( credentialsManager credentials . Manager ) { agent . resourceFields = & taskresource . ResourceFields { Control : cgroup . New ( ) , ResourceFieldsCommon : & taskresource . ResourceFieldsCommon { IOUtil : ioutilwrapper . NewIOUtil ( ) , ASMClientCreator : asmfactory . NewClientCreator ( ) , SSMClientCreator : ssmfactory . NewSSMClientCreator ( ) , CredentialsManager : credentialsManager , } , Ctx : agent . ctx , DockerClient : agent . dockerClient , NvidiaGPUManager : gpu . NewNvidiaGPUManager ( ) , } } 
func ( gm * GenericMetrics ) RecordCall ( callID , callName string , callTime time . Time , callStarted chan bool ) string { if callID == " " { hashData := [ ] byte ( " " + callName + strconv . FormatFloat ( float64 ( rand . Float32 ( ) ) , 'f' , - 1 , 32 ) ) hash := fmt . Sprintf ( " " , md5 . Sum ( hashData ) ) go gm . IncrementCallCount ( callName ) return hash } else { go gm . FireCallEnd ( callID , callName , callTime , callStarted ) return " " } } 
func ( gm * GenericMetrics ) IncrementCallCount ( callName string ) { defer func ( ) { if r := recover ( ) ; r != nil { seelog . Errorf ( " " , callName , r ) } } ( ) gm . lock . Lock ( ) defer gm . lock . Unlock ( ) gm . counterVec . WithLabelValues ( callName ) . Inc ( ) } 
func NewMockTaskEngineState ( ctrl * gomock . Controller ) * MockTaskEngineState { mock := & MockTaskEngineState { ctrl : ctrl } mock . recorder = & MockTaskEngineStateMockRecorder { mock } return mock } 
func ( m * MockTaskEngineState ) AddContainer ( arg0 * container . DockerContainer , arg1 * task . Task ) { m . ctrl . Call ( m , " " , arg0 , arg1 ) } 
func ( m * MockTaskEngineState ) AddENIAttachment ( arg0 * eni . ENIAttachment ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngineState ) AddImageState ( arg0 * image . ImageState ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngineState ) AddTask ( arg0 * task . Task ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngineState ) AddTaskIPAddress ( arg0 , arg1 string ) { m . ctrl . Call ( m , " " , arg0 , arg1 ) } 
func ( m * MockTaskEngineState ) AllImageStates ( ) [ ] * image . ImageState { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] * image . ImageState ) return ret0 } 
func ( mr * MockTaskEngineStateMockRecorder ) AllImageStates ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskEngineState ) ( nil ) . AllImageStates ) ) } 
func ( m * MockTaskEngineState ) AllTasks ( ) [ ] * task . Task { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] * task . Task ) return ret0 } 
func ( m * MockTaskEngineState ) ContainerByID ( arg0 string ) ( * container . DockerContainer , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * container . DockerContainer ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockTaskEngineState ) ENIByMac ( arg0 string ) ( * eni . ENIAttachment , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * eni . ENIAttachment ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockTaskEngineState ) GetAllContainerIDs ( ) [ ] string { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] string ) return ret0 } 
func ( m * MockTaskEngineState ) RemoveENIAttachment ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngineState ) RemoveImageState ( arg0 * image . ImageState ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockTaskEngineState ) RemoveTask ( arg0 * task . Task ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockTaskEngineStateMockRecorder ) RemoveTask ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockTaskEngineState ) ( nil ) . RemoveTask ) , arg0 ) } 
func ( m * MockTaskEngineState ) TaskARNByV3EndpointID ( arg0 string ) ( string , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( string ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockTaskEngineState ) TaskByArn ( arg0 string ) ( * task . Task , bool ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * task . Task ) ret1 , _ := ret [ 1 ] . ( bool ) return ret0 , ret1 } 
func ( m * MockTaskEngineState ) UnmarshalJSON ( arg0 [ ] byte ) error { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( containerType ContainerType ) String ( ) string { for str , contType := range stringToContainerType { if contType == containerType { return str } } return " " } 
func ( containerType * ContainerType ) UnmarshalJSON ( b [ ] byte ) error { strType := string ( b ) switch strType { case " " : * containerType = ContainerNormal seelog . Warn ( " " ) return nil return nil case " " : * containerType = ContainerNormal return nil } if len ( strType ) < 2 { * containerType = ContainerNormal return errors . New ( " " + string ( b ) ) } if b [ 0 ] != '"' || b [ len ( b ) - 1 ] != '"' { * containerType = ContainerNormal return errors . New ( " " + string ( b ) ) } strType = string ( b [ 1 : len ( b ) - 1 ] ) contType , ok := stringToContainerType [ strType ] if ! ok { * containerType = ContainerNormal return errors . New ( " " + strType ) } * containerType = contType return nil } 
func ( containerType * ContainerType ) MarshalJSON ( ) ( [ ] byte , error ) { if containerType == nil { return [ ] byte ( " " ) , nil } return [ ] byte ( `"` + containerType . String ( ) + `"` ) , nil } 
func parseNanoTime ( value string ) time . Time { ts , _ := time . Parse ( time . RFC3339Nano , value ) return ts } 
func isNetworkStatsError ( err error ) bool { matched , mErr := regexp . MatchString ( networkStatsErrorPattern , err . Error ( ) ) if mErr != nil { seelog . Debugf ( " " , mErr ) return false } return matched } 
func NewMockResponseWriter ( ctrl * gomock . Controller ) * MockResponseWriter { mock := & MockResponseWriter { ctrl : ctrl } mock . recorder = & MockResponseWriterMockRecorder { mock } return mock } 
func ( m * MockResponseWriter ) Header ( ) http . Header { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( http . Header ) return ret0 } 
func ( mr * MockResponseWriterMockRecorder ) Header ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockResponseWriter ) ( nil ) . Header ) ) } 
func ( m * MockResponseWriter ) WriteHeader ( arg0 int ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockResponseWriterMockRecorder ) WriteHeader ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockResponseWriter ) ( nil ) . WriteHeader ) , arg0 ) } 
func ( lhs DockerAPIVersion ) Matches ( selector string ) ( bool , error ) { lhsVersion , err := parseDockerVersions ( string ( lhs ) ) if err != nil { return false , err } if strings . Contains ( selector , " " ) { orElements := strings . Split ( selector , " " ) for _ , el := range orElements { if elMatches , err := lhs . Matches ( el ) ; err != nil { return false , err } else if elMatches { return true , nil } } } if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseDockerVersions ( selector [ 2 : ] ) if err != nil { return false , err } return compareDockerVersions ( lhsVersion , rhsVersion ) >= 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseDockerVersions ( selector [ 1 : ] ) if err != nil { return false , err } return compareDockerVersions ( lhsVersion , rhsVersion ) > 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseDockerVersions ( selector [ 2 : ] ) if err != nil { return false , err } return compareDockerVersions ( lhsVersion , rhsVersion ) <= 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseDockerVersions ( selector [ 1 : ] ) if err != nil { return false , err } return compareDockerVersions ( lhsVersion , rhsVersion ) < 0 , nil } rhsVersion , err := parseDockerVersions ( selector ) if err != nil { return false , err } return compareDockerVersions ( lhsVersion , rhsVersion ) == 0 , nil } 
func compareDockerVersions ( lhs , rhs dockerVersion ) int { switch { case lhs . major < rhs . major : return - 1 case lhs . major > rhs . major : return 1 case lhs . minor < rhs . minor : return - 1 case lhs . minor > rhs . minor : return 1 } return 0 } 
func SignHTTPRequest ( req * http . Request , region , service string , creds * credentials . Credentials , body io . ReadSeeker ) error { signer := v4 . NewSigner ( creds ) _ , err := signer . Sign ( req , body , service , region , time . Now ( ) ) if err != nil { seelog . Warnf ( " " , err ) return errors . Wrap ( err , " " ) } return nil } 
func ( f * factory ) GetClient ( version dockerclient . DockerVersion ) ( sdkclient . Client , error ) { return f . getClient ( version ) } 
func getAgentVersions ( ) [ ] dockerclient . DockerVersion { return [ ] dockerclient . DockerVersion { dockerclient . Version_1_17 , dockerclient . Version_1_18 , dockerclient . Version_1_19 , dockerclient . Version_1_20 , dockerclient . Version_1_21 , dockerclient . Version_1_22 , dockerclient . Version_1_23 , dockerclient . Version_1_24 , dockerclient . Version_1_25 , dockerclient . Version_1_26 , dockerclient . Version_1_27 , dockerclient . Version_1_28 , dockerclient . Version_1_29 , dockerclient . Version_1_30 , dockerclient . Version_1_31 , dockerclient . Version_1_32 , } } 
func ( a * auditLog ) Log ( r request . LogRequest , httpResponseCode int , eventType string ) { if ! a . cfg . CredentialsAuditLogDisabled { auditLogEntry := constructAuditLogEntry ( r , httpResponseCode , eventType , a . GetCluster ( ) , a . GetContainerInstanceArn ( ) ) a . logger . Info ( auditLogEntry ) } } 
func ( task * Task ) dockerCPUShares ( containerCPU uint ) int64 { if containerCPU <= 1 { seelog . Debugf ( " " , task . Arn , containerCPU ) return 2 } return int64 ( containerCPU ) } 
func verifyTasksMetadata ( tasksMetadataRawMsg json . RawMessage ) error { var tasksMetadataMap map [ string ] json . RawMessage json . Unmarshal ( tasksMetadataRawMsg , & tasksMetadataMap ) if tasksMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } var tasksMetadataArray [ ] json . RawMessage json . Unmarshal ( tasksMetadataMap [ " " ] , & tasksMetadataArray ) if len ( tasksMetadataArray ) != 1 { return fmt . Errorf ( " " , len ( tasksMetadataArray ) ) } return verifyTaskMetadata ( tasksMetadataArray [ 0 ] ) } 
func verifyTaskMetadata ( taskMetadataRawMsg json . RawMessage ) error { taskMetadataMap := make ( map [ string ] json . RawMessage ) json . Unmarshal ( taskMetadataRawMsg , & taskMetadataMap ) if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if taskMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } var containersMetadataArray [ ] json . RawMessage json . Unmarshal ( taskMetadataMap [ " " ] , & containersMetadataArray ) if len ( containersMetadataArray ) != 1 { return fmt . Errorf ( " " , len ( containersMetadataArray ) ) } return verifyContainerMetadata ( containersMetadataArray [ 0 ] ) } 
func verifyContainerMetadata ( containerMetadataRawMsg json . RawMessage ) error { containerMetadataMap := make ( map [ string ] json . RawMessage ) json . Unmarshal ( containerMetadataRawMsg , & containerMetadataMap ) if containerMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } var actualContainerName string json . Unmarshal ( containerMetadataMap [ " " ] , & actualContainerName ) if actualContainerName != containerName { return fmt . Errorf ( " " , containerName , actualContainerName ) } if containerMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if containerMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } if containerMetadataMap [ " " ] == nil { return notEmptyErrMsg ( " " ) } return nil } 
func NewMockResult ( ctrl * gomock . Controller ) * MockResult { mock := & MockResult { ctrl : ctrl } mock . recorder = & MockResultMockRecorder { mock } return mock } 
func ( m * MockResult ) GetAsVersion ( arg0 string ) ( types . Result , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( types . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockResultMockRecorder ) GetAsVersion ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockResult ) ( nil ) . GetAsVersion ) , arg0 ) } 
func ( m * MockResult ) Print ( ) error { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockResultMockRecorder ) Print ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockResult ) ( nil ) . Print ) ) } 
func ( m * MockClient ) ContainerCreate ( arg0 context . Context , arg1 * container . Config , arg2 * container . HostConfig , arg3 * network . NetworkingConfig , arg4 string ) ( container . ContainerCreateCreatedBody , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 , arg4 ) ret0 , _ := ret [ 0 ] . ( container . ContainerCreateCreatedBody ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ContainerInspect ( arg0 context . Context , arg1 string ) ( types . ContainerJSON , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . ContainerJSON ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ContainerList ( arg0 context . Context , arg1 types . ContainerListOptions ) ( [ ] types . Container , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] types . Container ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ContainerRemove ( arg0 context . Context , arg1 string , arg2 types . ContainerRemoveOptions ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClient ) ContainerStart ( arg0 context . Context , arg1 string , arg2 types . ContainerStartOptions ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClient ) ContainerStats ( arg0 context . Context , arg1 string , arg2 bool ) ( types . ContainerStats , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( types . ContainerStats ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ContainerStop ( arg0 context . Context , arg1 string , arg2 * time . Duration ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( m * MockClient ) Events ( arg0 context . Context , arg1 types . EventsOptions ) ( <- chan events . Message , <- chan error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( <- chan events . Message ) ret1 , _ := ret [ 1 ] . ( <- chan error ) return ret0 , ret1 } 
func ( m * MockClient ) ImageImport ( arg0 context . Context , arg1 types . ImageImportSource , arg2 string , arg3 types . ImageImportOptions ) ( io . ReadCloser , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 , arg3 ) ret0 , _ := ret [ 0 ] . ( io . ReadCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ImageInspectWithRaw ( arg0 context . Context , arg1 string ) ( types . ImageInspect , [ ] byte , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . ImageInspect ) ret1 , _ := ret [ 1 ] . ( [ ] byte ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 } 
func ( m * MockClient ) ImageList ( arg0 context . Context , arg1 types . ImageListOptions ) ( [ ] types . ImageSummary , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( [ ] types . ImageSummary ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ImageLoad ( arg0 context . Context , arg1 io . Reader , arg2 bool ) ( types . ImageLoadResponse , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( types . ImageLoadResponse ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ImagePull ( arg0 context . Context , arg1 string , arg2 types . ImagePullOptions ) ( io . ReadCloser , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( io . ReadCloser ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) ImageRemove ( arg0 context . Context , arg1 string , arg2 types . ImageRemoveOptions ) ( [ ] types . ImageDeleteResponseItem , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( [ ] types . ImageDeleteResponseItem ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) Ping ( arg0 context . Context ) ( types . Ping , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( types . Ping ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) PluginList ( arg0 context . Context , arg1 filters . Args ) ( types . PluginsListResponse , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . PluginsListResponse ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) VolumeCreate ( arg0 context . Context , arg1 volume . VolumeCreateBody ) ( types . Volume , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Volume ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) VolumeInspect ( arg0 context . Context , arg1 string ) ( types . Volume , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Volume ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockClient ) VolumeRemove ( arg0 context . Context , arg1 string , arg2 bool ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( resolver * DockerContainerMetadataResolver ) ResolveTask ( dockerID string ) ( * apitask . Task , error ) { if resolver . dockerTaskEngine == nil { return nil , fmt . Errorf ( " " ) } task , found := resolver . dockerTaskEngine . State ( ) . TaskByID ( dockerID ) if ! found { return nil , fmt . Errorf ( " " , dockerID ) } return task , nil } 
func ( resolver * DockerContainerMetadataResolver ) ResolveContainer ( dockerID string ) ( * apicontainer . DockerContainer , error ) { if resolver . dockerTaskEngine == nil { return nil , fmt . Errorf ( " " ) } container , found := resolver . dockerTaskEngine . State ( ) . ContainerByID ( dockerID ) if ! found { return nil , fmt . Errorf ( " " , dockerID ) } return container , nil } 
func NewDockerStatsEngine ( cfg * config . Config , client dockerapi . DockerClient , containerChangeEventStream * eventstream . EventStream ) * DockerStatsEngine { return & DockerStatsEngine { client : client , resolver : nil , disableMetrics : cfg . DisableMetrics , tasksToContainers : make ( map [ string ] map [ string ] * StatsContainer ) , tasksToHealthCheckContainers : make ( map [ string ] map [ string ] * StatsContainer ) , tasksToDefinitions : make ( map [ string ] * taskDefinition ) , containerChangeEventStream : containerChangeEventStream , } } 
func ( engine * DockerStatsEngine ) synchronizeState ( ) error { listContainersResponse := engine . client . ListContainers ( engine . ctx , false , dockerclient . ListContainersTimeout ) if listContainersResponse . Error != nil { return listContainersResponse . Error } for _ , containerID := range listContainersResponse . DockerIDs { engine . addAndStartStatsContainer ( containerID ) } return nil } 
func ( engine * DockerStatsEngine ) addAndStartStatsContainer ( containerID string ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) statsContainer , err := engine . addContainerUnsafe ( containerID ) if err != nil { seelog . Debugf ( " " , containerID , err ) return } if engine . disableMetrics || statsContainer == nil { return } statsContainer . StartStatsCollection ( ) } 
func ( engine * DockerStatsEngine ) MustInit ( ctx context . Context , taskEngine ecsengine . TaskEngine , cluster string , containerInstanceArn string ) error { derivedCtx , cancel := context . WithCancel ( ctx ) engine . stopEngine = cancel engine . ctx = derivedCtx engine . cluster = cluster engine . containerInstanceArn = containerInstanceArn var err error engine . resolver , err = newDockerContainerMetadataResolver ( taskEngine ) if err != nil { return err } if err != nil { return fmt . Errorf ( " " , err ) } err = engine . synchronizeState ( ) if err != nil { seelog . Warnf ( " " , err ) } go engine . waitToStop ( ) return nil } 
func ( engine * DockerStatsEngine ) waitToStop ( ) { select { case <- ctx . Done ( ) : seelog . Debug ( " " ) engine . containerChangeEventStream . Unsubscribe ( containerChangeHandler ) engine . removeAll ( ) } } 
func ( engine * DockerStatsEngine ) removeAll ( ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) for task , containers := range engine . tasksToContainers { for _ , statsContainer := range containers { statsContainer . StopStatsCollection ( ) } delete ( engine . tasksToContainers , task ) } for task := range engine . tasksToHealthCheckContainers { delete ( engine . tasksToContainers , task ) } } 
func ( engine * DockerStatsEngine ) addContainerUnsafe ( dockerID string ) ( * StatsContainer , error ) { if err != nil { return nil , errors . Wrapf ( err , " " , dockerID ) } if len ( task . Arn ) == 0 || len ( task . Family ) == 0 { return nil , errors . Errorf ( " " , task . Arn , task . Family ) } if task . GetKnownStatus ( ) . Terminal ( ) { return nil , errors . Errorf ( " " , dockerID , task . Arn ) } seelog . Debugf ( " " , dockerID , task . Arn ) statsContainer := newStatsContainer ( dockerID , engine . client , engine . resolver ) engine . tasksToDefinitions [ task . Arn ] = & taskDefinition { family : task . Family , version : task . Version } watchStatsContainer := false if ! engine . disableMetrics { } if dockerContainer , err := engine . resolver . ResolveContainer ( dockerID ) ; err != nil { seelog . Debugf ( " " , dockerID , err ) } else if dockerContainer . Container . HealthStatusShouldBeReported ( ) { seelog . Debugf ( " " , dockerID , task . Arn ) } if ! watchStatsContainer { return nil , nil } return statsContainer , nil } 
func ( engine * DockerStatsEngine ) addToStatsContainerMapUnsafe ( taskARN , containerID string , statsContainer * StatsContainer , statsMapToUpdate func ( ) map [ string ] map [ string ] * StatsContainer ) bool { taskToContainerMap := statsMapToUpdate ( ) if taskExists { if containerExists { return false } } else { } taskToContainerMap [ taskARN ] [ containerID ] = statsContainer return true } 
func ( engine * DockerStatsEngine ) GetInstanceMetrics ( ) ( * ecstcs . MetricsMetadata , [ ] * ecstcs . TaskMetric , error ) { var taskMetrics [ ] * ecstcs . TaskMetric idle := engine . isIdle ( ) metricsMetadata := & ecstcs . MetricsMetadata { Cluster : aws . String ( engine . cluster ) , ContainerInstance : aws . String ( engine . containerInstanceArn ) , Idle : aws . Bool ( idle ) , MessageId : aws . String ( uuid . NewRandom ( ) . String ( ) ) , } if idle { seelog . Debug ( " " ) fin := true metricsMetadata . Fin = & fin return metricsMetadata , taskMetrics , nil } engine . lock . Lock ( ) defer engine . lock . Unlock ( ) for taskArn := range engine . tasksToContainers { containerMetrics , err := engine . taskContainerMetricsUnsafe ( taskArn ) if err != nil { seelog . Debugf ( " " , taskArn , err ) continue } if len ( containerMetrics ) == 0 { seelog . Debugf ( " " , taskArn ) continue } taskDef , exists := engine . tasksToDefinitions [ taskArn ] if ! exists { seelog . Debugf ( " " , taskArn ) continue } metricTaskArn := taskArn taskMetric := & ecstcs . TaskMetric { TaskArn : & metricTaskArn , TaskDefinitionFamily : & taskDef . family , TaskDefinitionVersion : & taskDef . version , ContainerMetrics : containerMetrics , } taskMetrics = append ( taskMetrics , taskMetric ) } if len ( taskMetrics ) == 0 { } return metricsMetadata , taskMetrics , nil } 
func ( engine * DockerStatsEngine ) GetTaskHealthMetrics ( ) ( * ecstcs . HealthMetadata , [ ] * ecstcs . TaskHealth , error ) { var taskHealths [ ] * ecstcs . TaskHealth metadata := & ecstcs . HealthMetadata { Cluster : aws . String ( engine . cluster ) , ContainerInstance : aws . String ( engine . containerInstanceArn ) , MessageId : aws . String ( uuid . NewRandom ( ) . String ( ) ) , } if ! engine . containerHealthsToMonitor ( ) { return metadata , taskHealths , nil } engine . lock . RLock ( ) defer engine . lock . RUnlock ( ) for taskARN := range engine . tasksToHealthCheckContainers { taskHealth := engine . getTaskHealthUnsafe ( taskARN ) if taskHealth == nil { continue } taskHealths = append ( taskHealths , taskHealth ) } if len ( taskHealths ) == 0 { return nil , nil , EmptyHealthMetricsError } return metadata , taskHealths , nil } 
func ( engine * DockerStatsEngine ) stopTrackingContainerUnsafe ( container * StatsContainer , taskARN string ) bool { terminal , err := container . terminal ( ) if err != nil { engine . doRemoveContainerUnsafe ( container , taskARN ) return true } if terminal { engine . doRemoveContainerUnsafe ( container , taskARN ) return true } return false } 
func ( engine * DockerStatsEngine ) handleDockerEvents ( events ... interface { } ) error { for _ , event := range events { dockerContainerChangeEvent , ok := event . ( dockerapi . DockerContainerChangeEvent ) if ! ok { return fmt . Errorf ( " " ) } switch dockerContainerChangeEvent . Status { case apicontainerstatus . ContainerRunning : engine . addAndStartStatsContainer ( dockerContainerChangeEvent . DockerID ) case apicontainerstatus . ContainerStopped : engine . removeContainer ( dockerContainerChangeEvent . DockerID ) default : seelog . Debugf ( " " , dockerContainerChangeEvent . DockerID , dockerContainerChangeEvent . Status ) } } return nil } 
func ( engine * DockerStatsEngine ) removeContainer ( dockerID string ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) if err != nil { seelog . Debugf ( " " , err , dockerID ) return } _ , taskExists := engine . tasksToContainers [ task . Arn ] if ! taskExists { seelog . Debugf ( " " , dockerID ) return } if ! containerExists { return } engine . doRemoveContainerUnsafe ( container , task . Arn ) } 
func newDockerContainerMetadataResolver ( taskEngine ecsengine . TaskEngine ) ( * DockerContainerMetadataResolver , error ) { dockerTaskEngine , ok := taskEngine . ( * ecsengine . DockerTaskEngine ) if ! ok { } resolver := & DockerContainerMetadataResolver { dockerTaskEngine : dockerTaskEngine , } return resolver , nil } 
func ( engine * DockerStatsEngine ) taskContainerMetricsUnsafe ( taskArn string ) ( [ ] * ecstcs . ContainerMetric , error ) { containerMap , taskExists := engine . tasksToContainers [ taskArn ] if ! taskExists { return nil , fmt . Errorf ( " " ) } var containerMetrics [ ] * ecstcs . ContainerMetric for _ , container := range containerMap { dockerID := container . containerMetadata . DockerID } if ! container . statsQueue . enoughDatapointsInBuffer ( ) && ! container . statsQueue . resetThresholdElapsed ( queueResetThreshold ) { seelog . Debugf ( " " , dockerID ) continue } if err != nil { seelog . Warnf ( " " , err , dockerID ) continue } if err != nil { seelog . Warnf ( " " , err , dockerID ) continue } containerMetrics = append ( containerMetrics , & ecstcs . ContainerMetric { CpuStatsSet : cpuStatsSet , MemoryStatsSet : memoryStatsSet , } ) } return containerMetrics , nil } 
func ( engine * DockerStatsEngine ) resetStatsUnsafe ( ) { for _ , containerMap := range engine . tasksToContainers { for _ , container := range containerMap { container . statsQueue . Reset ( ) } } } 
func ( engine * DockerStatsEngine ) ContainerDockerStats ( taskARN string , containerID string ) ( * types . StatsJSON , error ) { engine . lock . RLock ( ) defer engine . lock . RUnlock ( ) containerIDToStatsContainer , ok := engine . tasksToContainers [ taskARN ] if ! ok { return nil , errors . Errorf ( " " , taskARN , containerID ) } container , ok := containerIDToStatsContainer [ containerID ] if ! ok { return nil , errors . Errorf ( " " , containerID ) } return container . statsQueue . GetLastStat ( ) , nil } 
func newMetricsMetadata ( cluster * string , containerInstance * string ) * ecstcs . MetricsMetadata { return & ecstcs . MetricsMetadata { Cluster : cluster , ContainerInstance : containerInstance , } } 
func ( lhs Version ) Matches ( selector string ) ( bool , error ) { lhsVersion , err := parseSemver ( string ( lhs ) ) if err != nil { return false , err } if strings . Contains ( selector , " " ) { orElements := strings . Split ( selector , " " ) for _ , el := range orElements { if elMatches , err := lhs . Matches ( el ) ; err != nil { return false , err } else if elMatches { return true , nil } } } if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseSemver ( selector [ 2 : ] ) if err != nil { return false , err } return compareSemver ( lhsVersion , rhsVersion ) >= 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseSemver ( selector [ 1 : ] ) if err != nil { return false , err } return compareSemver ( lhsVersion , rhsVersion ) > 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseSemver ( selector [ 2 : ] ) if err != nil { return false , err } return compareSemver ( lhsVersion , rhsVersion ) <= 0 , nil } else if strings . HasPrefix ( selector , " " ) { rhsVersion , err := parseSemver ( selector [ 1 : ] ) if err != nil { return false , err } return compareSemver ( lhsVersion , rhsVersion ) < 0 , nil } rhsVersion , err := parseSemver ( selector ) if err != nil { return false , err } return compareSemver ( lhsVersion , rhsVersion ) == 0 , nil } 
func compareSemver ( lhs , rhs semver ) int { if lhs . major < rhs . major { return - 1 } if lhs . major > rhs . major { return 1 } if lhs . minor < rhs . minor { return - 1 } if lhs . minor > rhs . minor { return 1 } if lhs . patch < rhs . patch { return - 1 } if lhs . patch > rhs . patch { return 1 } if lhs . preReleaseVersion != " " && rhs . preReleaseVersion == " " { return - 1 } if lhs . preReleaseVersion == " " && rhs . preReleaseVersion != " " { return 1 } if lhs . preReleaseVersion < rhs . preReleaseVersion { return - 1 } if lhs . preReleaseVersion > rhs . preReleaseVersion { return 1 } return 0 } 
func ExtractVersion ( input string ) string { versionNumberRegex := regexp . MustCompile ( ` v(\d+\.\d+\.\d+(\-[\S\.\-]+)?(\+[\S\.\-]+)?)` ) versionNumberStr := versionNumberRegex . FindStringSubmatch ( input ) if len ( versionNumberStr ) >= 2 { return string ( versionNumberStr [ 1 ] ) } return " " } 
func ( role * TaskIAMRoleCredentials ) GetIAMRoleCredentials ( ) IAMRoleCredentials { role . lock . RLock ( ) defer role . lock . RUnlock ( ) return role . IAMRoleCredentials } 
func ( roleCredentials * IAMRoleCredentials ) GenerateCredentialsEndpointRelativeURI ( ) string { return fmt . Sprintf ( credentialsEndpointRelativeURIFormat , CredentialsPath , roleCredentials . CredentialsID ) } 
func IAMRoleCredentialsFromACS ( roleCredentials * ecsacs . IAMRoleCredentials , roleType string ) IAMRoleCredentials { return IAMRoleCredentials { CredentialsID : aws . StringValue ( roleCredentials . CredentialsId ) , SessionToken : aws . StringValue ( roleCredentials . SessionToken ) , RoleArn : aws . StringValue ( roleCredentials . RoleArn ) , AccessKeyID : aws . StringValue ( roleCredentials . AccessKeyId ) , SecretAccessKey : aws . StringValue ( roleCredentials . SecretAccessKey ) , Expiration : aws . StringValue ( roleCredentials . Expiration ) , RoleType : roleType , } } 
func ( manager * credentialsManager ) SetTaskCredentials ( taskCredentials * TaskIAMRoleCredentials ) error { manager . taskCredentialsLock . Lock ( ) defer manager . taskCredentialsLock . Unlock ( ) credentials := taskCredentials . IAMRoleCredentials } } manager . idToTaskCredentials [ credentials . CredentialsID ] = TaskIAMRoleCredentials { ARN : taskCredentials . ARN , IAMRoleCredentials : taskCredentials . GetIAMRoleCredentials ( ) , } return nil } 
func ( manager * credentialsManager ) GetTaskCredentials ( id string ) ( TaskIAMRoleCredentials , bool ) { manager . taskCredentialsLock . RLock ( ) defer manager . taskCredentialsLock . RUnlock ( ) taskCredentials , ok := manager . idToTaskCredentials [ id ] if ! ok { return TaskIAMRoleCredentials { } , ok } return TaskIAMRoleCredentials { ARN : taskCredentials . ARN , IAMRoleCredentials : taskCredentials . GetIAMRoleCredentials ( ) , } , ok } 
func ( manager * credentialsManager ) RemoveCredentials ( id string ) { manager . taskCredentialsLock . Lock ( ) defer manager . taskCredentialsLock . Unlock ( ) delete ( manager . idToTaskCredentials , id ) } 
func verifyResponseFieldNames ( expectedFields [ ] string , responseBody [ ] byte , responseName string ) error { var responseMap map [ string ] json . RawMessage if err := json . Unmarshal ( responseBody , & responseMap ) ; err != nil { fmt . Errorf ( " " , responseName ) } for _ , field := range expectedFields { if _ , ok := responseMap [ field ] ; ! ok { return fmt . Errorf ( " " , field , responseName ) } } return nil } 
func matchWithoutOrder ( a1 , a2 [ ] string ) bool { if len ( a1 ) != len ( a2 ) { return false } m := make ( map [ string ] bool ) for _ , x := range a1 { m [ x ] = true } for _ , y := range a2 { if _ , ok := m [ y ] ; ! ok { return false } } return true } 
func ( m * MockOS ) Getpid ( ) int { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( int ) return ret0 } 
func ( mr * MockOSMockRecorder ) Getpid ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockOS ) ( nil ) . Getpid ) ) } 
func Run ( arguments [ ] string ) int { defer log . Flush ( ) parsedArgs , err := args . New ( arguments ) if err != nil { return exitcodes . ExitTerminal } if * parsedArgs . License { return printLicense ( ) } else if * parsedArgs . Version { return version . PrintVersion ( ) } logger . SetLevel ( * parsedArgs . LogLevel ) if err != nil { } switch { case * parsedArgs . ECSAttributes : case * parsedArgs . WindowsService : default : } } 
func AppMeshFromACS ( proxyConfig * ecsacs . ProxyConfiguration ) ( * AppMesh , error ) { if * proxyConfig . Type != appMesh { return nil , fmt . Errorf ( " " ) } return & AppMesh { ContainerName : aws . StringValue ( proxyConfig . ContainerName ) , IgnoredUID : aws . StringValue ( proxyConfig . Properties [ ignoredUID ] ) , IgnoredGID : aws . StringValue ( proxyConfig . Properties [ ignoredGID ] ) , ProxyIngressPort : aws . StringValue ( proxyConfig . Properties [ proxyIngressPort ] ) , ProxyEgressPort : aws . StringValue ( proxyConfig . Properties [ proxyEgressPort ] ) , AppPorts : buildAppPorts ( proxyConfig ) , EgressIgnoredIPs : buildEgressIgnoredIPs ( proxyConfig ) , EgressIgnoredPorts : buildEgressIgnoredPorts ( proxyConfig ) , } , nil } 
func buildAppPorts ( proxyConfig * ecsacs . ProxyConfiguration ) [ ] string { var inputAppPorts [ ] string if proxyConfig . Properties [ appPorts ] != nil { inputAppPorts = strings . Split ( * proxyConfig . Properties [ appPorts ] , splitter ) } return inputAppPorts } 
func buildEgressIgnoredIPs ( proxyConfig * ecsacs . ProxyConfiguration ) [ ] string { var inputEgressIgnoredIPs [ ] string if proxyConfig . Properties [ egressIgnoredIPs ] != nil { inputEgressIgnoredIPs = strings . Split ( * proxyConfig . Properties [ egressIgnoredIPs ] , splitter ) } } 
func buildEgressIgnoredPorts ( proxyConfig * ecsacs . ProxyConfiguration ) [ ] string { var inputEgressIgnoredPorts [ ] string if proxyConfig . Properties [ egressIgnoredPorts ] != nil { inputEgressIgnoredPorts = strings . Split ( * proxyConfig . Properties [ egressIgnoredPorts ] , splitter ) } return inputEgressIgnoredPorts } 
func appendDefaultEgressIgnoredIPs ( egressIgnoredIPs [ ] string ) [ ] string { hasTaskMetadataEndpointIP := false hasInstanceMetadataEndpointIP := false for _ , egressIgnoredIP := range egressIgnoredIPs { if strings . TrimSpace ( egressIgnoredIP ) == taskMetadataEndpointIP { hasTaskMetadataEndpointIP = true } if strings . TrimSpace ( egressIgnoredIP ) == instanceMetadataEndpointIP { hasInstanceMetadataEndpointIP = true } } if ! hasTaskMetadataEndpointIP { egressIgnoredIPs = append ( egressIgnoredIPs , taskMetadataEndpointIP ) } if ! hasInstanceMetadataEndpointIP { egressIgnoredIPs = append ( egressIgnoredIPs , instanceMetadataEndpointIP ) } return egressIgnoredIPs } 
func IsInstanceTypeChangedError ( err error ) bool { if awserr , ok := err . ( awserr . Error ) ; ok { return strings . Contains ( awserr . Message ( ) , InstanceTypeChangedErrorMessage ) } return false } 
func ( err * DefaultNamedError ) Error ( ) string { if err . Name == " " { return " " + err . Err } return err . Name + " " + err . Err } 
func NewNamedError ( err error ) * DefaultNamedError { if namedErr , ok := err . ( NamedError ) ; ok { return & DefaultNamedError { Err : namedErr . Error ( ) , Name : namedErr . ErrorName ( ) } } return & DefaultNamedError { Err : err . Error ( ) } } 
func ( err * ResourceInitError ) Error ( ) string { return fmt . Sprintf ( " " , err . taskARN , err . origErr ) } 
func ( u * NotMarshallableWSRequest ) Error ( ) string { ret := " " if u . Type != " " { ret += " " + u . Type + " " } return ret + " " + u . Err . Error ( ) } 
func ( task * Task ) BuildCgroupRoot ( ) ( string , error ) { taskID , err := task . GetID ( ) if err != nil { return " " , errors . Wrapf ( err , " " , task . Arn ) } return filepath . Join ( config . DefaultTaskCgroupPrefix , taskID ) , nil } 
func ( task * Task ) BuildLinuxResourceSpec ( ) ( specs . LinuxResources , error ) { linuxResourceSpec := specs . LinuxResources { } if err != nil { return specs . LinuxResources { } , err } linuxResourceSpec . CPU = & linuxCPUSpec } else { linuxCPUSpec := task . buildImplicitLinuxCPUSpec ( ) linuxResourceSpec . CPU = & linuxCPUSpec } if err != nil { return specs . LinuxResources { } , err } linuxResourceSpec . Memory = & linuxMemorySpec } return linuxResourceSpec , nil } 
func ( task * Task ) buildExplicitLinuxCPUSpec ( ) ( specs . LinuxCPU , error ) { if task . CPU > maxTaskVCPULimit { return specs . LinuxCPU { } , errors . Errorf ( " " , task . CPU , maxTaskVCPULimit ) } taskCPUPeriod := uint64 ( defaultCPUPeriod / time . Microsecond ) taskCPUQuota := int64 ( task . CPU * float64 ( taskCPUPeriod ) ) } 
func ( task * Task ) buildImplicitLinuxCPUSpec ( ) specs . LinuxCPU { for _ , container := range task . Containers { if container . CPU > 0 { taskCPUShares += uint64 ( container . CPU ) } } } return specs . LinuxCPU { Shares : & taskCPUShares , } } 
func ( task * Task ) buildLinuxMemorySpec ( ) ( specs . LinuxMemory , error ) { if containerMemoryLimit > task . Memory { return specs . LinuxMemory { } , errors . Errorf ( " " , containerMemoryLimit , task . Memory ) } } return specs . LinuxMemory { Limit : & memoryBytes , } , nil } 
func ( task * Task ) platformHostConfigOverride ( hostConfig * dockercontainer . HostConfig ) error { } 
func ( task * Task ) overrideCgroupParent ( hostConfig * dockercontainer . HostConfig ) error { task . lock . RLock ( ) defer task . lock . RUnlock ( ) if task . MemoryCPULimitsEnabled { cgroupRoot , err := task . BuildCgroupRoot ( ) if err != nil { return errors . Wrapf ( err , " " , task . Arn ) } hostConfig . CgroupParent = cgroupRoot } return nil } 
func GetMACAddress ( ctx context . Context , timeout time . Duration , dev string , netlinkClient netlinkwrapper . NetLink ) ( string , error ) { retriever := & macAddressRetriever { dev : dev , netlinkClient : netlinkClient , ctx : ctx , timeout : timeout , } return retriever . retrieve ( ) } 
func ( retriever * macAddressRetriever ) retrieve ( ) ( string , error ) { backoff := retry . NewExponentialBackoff ( macAddressBackoffMin , macAddressBackoffMax , macAddressBackoffJitter , macAddressBackoffMultiple ) ctx , cancel := context . WithTimeout ( retriever . ctx , retriever . timeout ) defer cancel ( ) err := retry . RetryWithBackoffCtx ( ctx , backoff , func ( ) error { retErr := retriever . retrieveOnce ( ) if retErr != nil { seelog . Warnf ( " " , retriever . dev , retErr ) return retErr } if retriever . macAddress == " " { seelog . Debugf ( " " , retriever . dev ) } return nil } ) if err != nil { return " " , err } } return retriever . macAddress , nil } 
func ( retriever * macAddressRetriever ) retrieveOnce ( ) error { dev := filepath . Base ( retriever . dev ) link , err := retriever . netlinkClient . LinkByName ( dev ) if err != nil { return apierrors . NewRetriableError ( apierrors . NewRetriable ( false ) , err ) } retriever . macAddress = link . Attrs ( ) . HardwareAddr . String ( ) return nil } 
func IsValidNetworkDevice ( devicePath string ) bool { splitDevLink := strings . SplitN ( devicePath , " " , 2 ) if len ( splitDevLink ) != 2 { seelog . Warnf ( " " , devicePath ) return false } if strings . HasPrefix ( splitDevLink [ 1 ] , pciDevicePrefix ) || strings . HasPrefix ( splitDevLink [ 1 ] , vifDevicePrefix ) { return true } if strings . HasPrefix ( splitDevLink [ 1 ] , virtualDevicePrefix ) { return false } return false } 
func ( r * eventLogReceiver ) ReceiveMessage ( message string , level seelog . LogLevel , context seelog . LogContextInterface ) error { switch level { case seelog . DebugLvl , seelog . InfoLvl : return eventLog . Info ( eventLogID , message ) case seelog . WarnLvl : return eventLog . Warning ( eventLogID , message ) case seelog . ErrorLvl , seelog . CriticalLvl : return eventLog . Error ( eventLogID , message ) } return nil } 
func ( client * ecrClient ) GetAuthorizationToken ( registryId string ) ( * ecrapi . AuthorizationData , error ) { log . Debugf ( " " , registryId ) output , err := client . sdkClient . GetAuthorizationToken ( & ecrapi . GetAuthorizationTokenInput { RegistryIds : [ ] * string { aws . String ( registryId ) } , } ) if err != nil { return nil , err } if len ( output . AuthorizationData ) != 1 { return nil , fmt . Errorf ( " " , len ( output . AuthorizationData ) ) } return output . AuthorizationData [ 0 ] , nil } 
func NewMockEngine ( ctrl * gomock . Controller ) * MockEngine { mock := & MockEngine { ctrl : ctrl } mock . recorder = & MockEngineMockRecorder { mock } return mock } 
func ( m * MockEngine ) ContainerDockerStats ( arg0 , arg1 string ) ( * types . StatsJSON , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( * types . StatsJSON ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockEngineMockRecorder ) ContainerDockerStats ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockEngine ) ( nil ) . ContainerDockerStats ) , arg0 , arg1 ) } 
func ( m * MockEngine ) GetInstanceMetrics ( ) ( * ecstcs . MetricsMetadata , [ ] * ecstcs . TaskMetric , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( * ecstcs . MetricsMetadata ) ret1 , _ := ret [ 1 ] . ( [ ] * ecstcs . TaskMetric ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 } 
func ( mr * MockEngineMockRecorder ) GetInstanceMetrics ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockEngine ) ( nil ) . GetInstanceMetrics ) ) } 
func ( m * MockEngine ) GetTaskHealthMetrics ( ) ( * ecstcs . HealthMetadata , [ ] * ecstcs . TaskHealth , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( * ecstcs . HealthMetadata ) ret1 , _ := ret [ 1 ] . ( [ ] * ecstcs . TaskHealth ) ret2 , _ := ret [ 2 ] . ( error ) return ret0 , ret1 , ret2 } 
func RetryWithBackoff ( backoff Backoff , fn func ( ) error ) error { return RetryWithBackoffCtx ( context . Background ( ) , backoff , fn ) } 
func RetryWithBackoffCtx ( ctx context . Context , backoff Backoff , fn func ( ) error ) error { var err error for { select { case <- ctx . Done ( ) : return nil default : } err = fn ( ) retriableErr , isRetriableErr := err . ( apierrors . Retriable ) if err == nil || ( isRetriableErr && ! retriableErr . Retry ( ) ) { return err } _time . Sleep ( backoff . Duration ( ) ) } } 
func RetryNWithBackoff ( backoff Backoff , n int , fn func ( ) error ) error { return RetryNWithBackoffCtx ( context . Background ( ) , backoff , n , fn ) } 
func RetryNWithBackoffCtx ( ctx context . Context , backoff Backoff , n int , fn func ( ) error ) error { var err error RetryWithBackoffCtx ( ctx , backoff , func ( ) error { err = fn ( ) n -- if n == 0 { } return err } ) return err } 
func AddJitter ( duration time . Duration , jitter time . Duration ) time . Duration { var randJitter int64 if jitter . Nanoseconds ( ) == 0 { randJitter = 0 } else { randJitter = rand . Int63n ( jitter . Nanoseconds ( ) ) } return time . Duration ( duration . Nanoseconds ( ) + randJitter ) } 
func LicenseHandler ( w http . ResponseWriter , h * http . Request ) { text , err := licenseProvider . GetText ( ) if err != nil { w . WriteHeader ( http . StatusInternalServerError ) } else { w . Write ( [ ] byte ( text ) ) } } 
func NewMockIOUtil ( ctrl * gomock . Controller ) * MockIOUtil { mock := & MockIOUtil { ctrl : ctrl } mock . recorder = & MockIOUtilMockRecorder { mock } return mock } 
func ( m * MockIOUtil ) TempFile ( arg0 , arg1 string ) ( oswrapper . File , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( oswrapper . File ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockIOUtil ) WriteFile ( arg0 string , arg1 [ ] byte , arg2 os . FileMode ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 , arg2 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockIOUtilMockRecorder ) WriteFile ( arg0 , arg1 , arg2 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockIOUtil ) ( nil ) . WriteFile ) , arg0 , arg1 , arg2 ) } 
func ( c * ClientImpl ) DescribeECSTagsForInstance ( instanceID string ) ( [ ] * ecs . Tag , error ) { describeTagsInput := ec2sdk . DescribeTagsInput { Filters : [ ] * ec2sdk . Filter { { Name : aws . String ( ResourceIDFilterName ) , Values : [ ] * string { aws . String ( instanceID ) } , } , { Name : aws . String ( ResourceTypeFilterName ) , Values : [ ] * string { aws . String ( ResourceTypeFilterValueInstance ) } , } , } , MaxResults : aws . Int64 ( InstanceMaxTagsNum ) , } res , err := c . client . DescribeTags ( & describeTagsInput ) if err != nil { seelog . Criticalf ( " " , err ) return nil , err } var tags [ ] * ecs . Tag } } return tags , nil } 
func TaskContainerStatsHandler ( state dockerstate . TaskEngineState , statsEngine stats . Engine ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { errResponseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } if containerID , ok := utils . GetMuxValueFromRequest ( r , statsContainerIDMuxName ) ; ok { seelog . Infof ( " " , containerID ) WriteContainerStatsResponse ( w , taskARN , containerID , statsEngine ) return } seelog . Infof ( " " , taskARN ) WriteTaskStatsResponse ( w , taskARN , state , statsEngine ) } } 
func WriteTaskStatsResponse ( w http . ResponseWriter , taskARN string , state dockerstate . TaskEngineState , statsEngine stats . Engine ) { taskStatsResponse , err := NewTaskStatsResponse ( taskARN , state , statsEngine ) if err != nil { seelog . Warnf ( " " , taskARN , err ) errResponseJSON , _ := json . Marshal ( " " + taskARN ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } responseJSON , _ := json . Marshal ( taskStatsResponse ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeTaskStats ) } 
func WriteContainerStatsResponse ( w http . ResponseWriter , taskARN string , containerID string , statsEngine stats . Engine ) { dockerStats , err := statsEngine . ContainerDockerStats ( taskARN , containerID ) if err != nil { errResponseJSON , _ := json . Marshal ( " " + containerID ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeContainerStats ) return } responseJSON , _ := json . Marshal ( dockerStats ) utils . WriteJSONToResponse ( w , http . StatusOK , responseJSON , utils . RequestTypeContainerStats ) } 
func NewTaskResponse ( task * apitask . Task , containerMap map [ string ] * apicontainer . DockerContainer ) * TaskResponse { containers := [ ] ContainerResponse { } for _ , container := range containerMap { if container . Container . IsInternal ( ) { continue } containerResponse := NewContainerResponse ( container , task . GetTaskENI ( ) ) containers = append ( containers , containerResponse ) } knownStatus := task . GetKnownStatus ( ) knownBackendStatus := knownStatus . BackendStatus ( ) desiredStatusInAgent := task . GetDesiredStatus ( ) desiredStatus := desiredStatusInAgent . BackendStatus ( ) if ( knownBackendStatus == " " && desiredStatus != " " ) || ( knownBackendStatus == " " && desiredStatus == " " ) { desiredStatus = " " } return & TaskResponse { Arn : task . Arn , DesiredStatus : desiredStatus , KnownStatus : knownBackendStatus , Family : task . Family , Version : task . Version , Containers : containers , } } 
func NewContainerResponse ( dockerContainer * apicontainer . DockerContainer , eni * apieni . ENI ) ContainerResponse { container := dockerContainer . Container resp := ContainerResponse { Name : container . Name , DockerID : dockerContainer . DockerID , DockerName : dockerContainer . DockerName , } resp . Ports = NewPortBindingsResponse ( dockerContainer , eni ) resp . Volumes = NewVolumesResponse ( dockerContainer ) if eni != nil { resp . Networks = [ ] containermetadata . Network { { NetworkMode : utils . NetworkModeAWSVPC , IPv4Addresses : eni . GetIPV4Addresses ( ) , IPv6Addresses : eni . GetIPV6Addresses ( ) , } , } } return resp } 
func NewPortBindingsResponse ( dockerContainer * apicontainer . DockerContainer , eni * apieni . ENI ) [ ] PortResponse { container := dockerContainer . Container resp := [ ] PortResponse { } bindings := container . GetKnownPortBindings ( ) } for _ , binding := range bindings { port := PortResponse { ContainerPort : binding . ContainerPort , Protocol : binding . Protocol . String ( ) , } if eni == nil { port . HostPort = binding . HostPort } else { port . HostPort = port . ContainerPort } resp = append ( resp , port ) } return resp } 
func NewVolumesResponse ( dockerContainer * apicontainer . DockerContainer ) [ ] VolumeResponse { container := dockerContainer . Container var resp [ ] VolumeResponse volumes := container . GetVolumes ( ) for _ , volume := range volumes { volResp := VolumeResponse { DockerName : volume . Name , Source : volume . Source , Destination : volume . Destination , } resp = append ( resp , volResp ) } return resp } 
func NewTasksResponse ( state dockerstate . TaskEngineState ) * TasksResponse { allTasks := state . AllTasks ( ) taskResponses := make ( [ ] * TaskResponse , len ( allTasks ) ) for ndx , task := range allTasks { containerMap , _ := state . ContainerMapByArn ( task . Arn ) taskResponses [ ndx ] = NewTaskResponse ( task , containerMap ) } return & TasksResponse { Tasks : taskResponses } } 
func NewPublishMetricsRequest ( metadata * MetricsMetadata , taskMetrics [ ] * TaskMetric ) * PublishMetricsRequest { return & PublishMetricsRequest { Metadata : metadata , TaskMetrics : taskMetrics , Timestamp : aws . Time ( time . Now ( ) ) , } } 
func NewPublishHealthMetricsRequest ( metadata * HealthMetadata , healthMetrics [ ] * TaskHealth ) * PublishHealthRequest { return & PublishHealthRequest { Metadata : metadata , Tasks : healthMetrics , Timestamp : aws . Time ( time . Now ( ) ) , } } 
func ( buffer * InfiniteBuffer ) StartListening ( ctx context . Context , eventChan <- chan events . Message ) { for { select { go buffer . CopyEvents ( & event ) } return case event := <- eventChan : go buffer . CopyEvents ( & event ) } } } 
func ( buffer * InfiniteBuffer ) CopyEvents ( event * events . Message ) { if event . ID == " " || event . Type != containerTypeEvent { return } defer buffer . lock . Unlock ( ) buffer . events = append ( buffer . events , event ) } return } } } 
func ( buffer * InfiniteBuffer ) Consume ( in chan <- * events . Message ) { for { buffer . lock . Lock ( ) if len ( buffer . events ) == 0 { buffer . waitForEvent . Add ( 1 ) buffer . lock . Unlock ( ) buffer . waitForEvent . Wait ( ) } else { event := buffer . events [ 0 ] buffer . events = buffer . events [ 1 : ] buffer . lock . Unlock ( ) } } } 
func ContainerStatsHandler ( state dockerstate . TaskEngineState , statsEngine stats . Engine ) func ( http . ResponseWriter , * http . Request ) { return func ( w http . ResponseWriter , r * http . Request ) { taskARN , err := getTaskARNByRequest ( r , state ) if err != nil { errResponseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , errResponseJSON , utils . RequestTypeTaskStats ) return } containerID , err := getContainerIDByRequest ( r , state ) if err != nil { responseJSON , _ := json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . WriteJSONToResponse ( w , http . StatusBadRequest , responseJSON , utils . RequestTypeContainerStats ) return } seelog . Infof ( " " , containerID ) } } 
func NewMetricsClient ( api APIType , registry * prometheus . Registry ) MetricsClient { switch api { case DockerAPI : return NewGenericMetricsClient ( DockerSubsystem , registry ) case TaskEngine : return NewGenericMetricsClient ( TaskEngineSubsystem , registry ) case StateManager : return NewGenericMetricsClient ( StateManagerSubsystem , registry ) case ECSClient : return NewGenericMetricsClient ( ECSClientSubsystem , registry ) default : seelog . Error ( " " ) return nil } } 
func NewMockECRSDK ( ctrl * gomock . Controller ) * MockECRSDK { mock := & MockECRSDK { ctrl : ctrl } mock . recorder = & MockECRSDKMockRecorder { mock } return mock } 
func ( m * MockECRSDK ) GetAuthorizationToken ( arg0 * ecr0 . GetAuthorizationTokenInput ) ( * ecr0 . GetAuthorizationTokenOutput , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecr0 . GetAuthorizationTokenOutput ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECRSDKMockRecorder ) GetAuthorizationToken ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECRSDK ) ( nil ) . GetAuthorizationToken ) , arg0 ) } 
func NewMockECRFactory ( ctrl * gomock . Controller ) * MockECRFactory { mock := & MockECRFactory { ctrl : ctrl } mock . recorder = & MockECRFactoryMockRecorder { mock } return mock } 
func ( m * MockECRFactory ) GetClient ( arg0 * container . ECRAuthData ) ( ecr . ECRClient , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( ecr . ECRClient ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECRFactoryMockRecorder ) GetClient ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECRFactory ) ( nil ) . GetClient ) , arg0 ) } 
func NewMockECRClient ( ctrl * gomock . Controller ) * MockECRClient { mock := & MockECRClient { ctrl : ctrl } mock . recorder = & MockECRClientMockRecorder { mock } return mock } 
func ( m * MockECRClient ) GetAuthorizationToken ( arg0 string ) ( * ecr0 . AuthorizationData , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * ecr0 . AuthorizationData ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockECRClientMockRecorder ) GetAuthorizationToken ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockECRClient ) ( nil ) . GetAuthorizationToken ) , arg0 ) } 
func GetCredentialsEventType ( roleType string ) string { switch roleType { case credentials . ApplicationRoleType : return getCredentialsEventType case credentials . ExecutionRoleType : return getCredentialsTaskExecutionEventType default : return getCredentialsInvalidRoleTypeEventType } } 
func NewMockGPUManager ( ctrl * gomock . Controller ) * MockGPUManager { mock := & MockGPUManager { ctrl : ctrl } mock . recorder = & MockGPUManagerMockRecorder { mock } return mock } 
func ( m * MockGPUManager ) GetDevices ( ) [ ] * ecs . PlatformDevice { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] * ecs . PlatformDevice ) return ret0 } 
func ( m * MockGPUManager ) GetGPUIDsUnsafe ( ) [ ] string { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] string ) return ret0 } 
func ( m * MockGPUManager ) Initialize ( ) error { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockGPUManagerMockRecorder ) SetDevices ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockGPUManager ) ( nil ) . SetDevices ) ) } 
func ( m * MockGPUManager ) SetDriverVersion ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( mr * MockGPUManagerMockRecorder ) SetDriverVersion ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockGPUManager ) ( nil ) . SetDriverVersion ) , arg0 ) } 
func ( m * MockGPUManager ) SetGPUIDs ( arg0 [ ] string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func ( m * MockGPUManager ) SetRuntimeVersion ( arg0 string ) { m . ctrl . Call ( m , " " , arg0 ) } 
func NewMockRoundTripper ( ctrl * gomock . Controller ) * MockRoundTripper { mock := & MockRoundTripper { ctrl : ctrl } mock . recorder = & MockRoundTripperMockRecorder { mock } return mock } 
func ( m * MockRoundTripper ) RoundTrip ( arg0 * http . Request ) ( * http . Response , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( * http . Response ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockRoundTripperMockRecorder ) RoundTrip ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockRoundTripper ) ( nil ) . RoundTrip ) , arg0 ) } 
func NewMockNetLink ( ctrl * gomock . Controller ) * MockNetLink { mock := & MockNetLink { ctrl : ctrl } mock . recorder = & MockNetLinkMockRecorder { mock } return mock } 
func ( m * MockNetLink ) LinkByName ( arg0 string ) ( netlink . Link , error ) { ret := m . ctrl . Call ( m , " " , arg0 ) ret0 , _ := ret [ 0 ] . ( netlink . Link ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockNetLinkMockRecorder ) LinkByName ( arg0 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockNetLink ) ( nil ) . LinkByName ) , arg0 ) } 
func ( m * MockNetLink ) LinkList ( ) ( [ ] netlink . Link , error ) { ret := m . ctrl . Call ( m , " " ) ret0 , _ := ret [ 0 ] . ( [ ] netlink . Link ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( mr * MockNetLinkMockRecorder ) LinkList ( ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockNetLink ) ( nil ) . LinkList ) ) } 
func NewMockCNI ( ctrl * gomock . Controller ) * MockCNI { mock := & MockCNI { ctrl : ctrl } mock . recorder = & MockCNIMockRecorder { mock } return mock } 
func ( m * MockCNI ) AddNetwork ( arg0 * libcni . NetworkConfig , arg1 * libcni . RuntimeConf ) ( types . Result , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCNI ) AddNetworkList ( arg0 * libcni . NetworkConfigList , arg1 * libcni . RuntimeConf ) ( types . Result , error ) { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( types . Result ) ret1 , _ := ret [ 1 ] . ( error ) return ret0 , ret1 } 
func ( m * MockCNI ) DelNetwork ( arg0 * libcni . NetworkConfig , arg1 * libcni . RuntimeConf ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func ( mr * MockCNIMockRecorder ) DelNetwork ( arg0 , arg1 interface { } ) * gomock . Call { return mr . mock . ctrl . RecordCallWithMethodType ( mr . mock , " " , reflect . TypeOf ( ( * MockCNI ) ( nil ) . DelNetwork ) , arg0 , arg1 ) } 
func ( m * MockCNI ) DelNetworkList ( arg0 * libcni . NetworkConfigList , arg1 * libcni . RuntimeConf ) error { ret := m . ctrl . Call ( m , " " , arg0 , arg1 ) ret0 , _ := ret [ 0 ] . ( error ) return ret0 } 
func NewLRUCache ( size int , ttl time . Duration ) Cache { lru := & lruCache { size : size , ttl : ttl , cache : make ( map [ string ] * entry ) , evictList : list . New ( ) , } return lru } 
func ( lru * lruCache ) Get ( key string ) ( Value , bool ) { lru . Lock ( ) defer lru . Unlock ( ) entry , ok := lru . cache [ key ] if ! ok { return nil , false } ok = lru . evictStale ( entry , key ) if ! ok { return nil , false } lru . updateAccessed ( key ) return entry . value , true } 
func ( lru * lruCache ) Set ( key string , value Value ) { lru . Lock ( ) defer lru . Unlock ( ) lru . cache [ key ] = & entry { value : value , added : time . Now ( ) } lru . evictList . PushBack ( key ) lru . purgeSize ( ) } 
func ( lru * lruCache ) Delete ( key string ) { lru . Lock ( ) defer lru . Unlock ( ) lru . removeFromEvictList ( key ) delete ( lru . cache , key ) } 
func ( eni * ENIAttachment ) StartTimer ( timeoutFunc func ( ) ) error { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) if eni . ackTimer != nil { } now := time . Now ( ) duration := eni . ExpiresAt . Sub ( now ) if duration <= 0 { return errors . Errorf ( " " , eni . ExpiresAt . String ( ) , now . String ( ) ) } seelog . Infof ( " " , duration . String ( ) , eni . stringUnsafe ( ) ) eni . ackTimer = time . AfterFunc ( duration , timeoutFunc ) return nil } 
func ( eni * ENIAttachment ) IsSent ( ) bool { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return eni . AttachStatusSent } 
func ( eni * ENIAttachment ) SetSentStatus ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . AttachStatusSent = true } 
func ( eni * ENIAttachment ) StopAckTimer ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . ackTimer . Stop ( ) } 
func ( eni * ENIAttachment ) HasExpired ( ) bool { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return time . Now ( ) . After ( eni . ExpiresAt ) } 
func ( eni * ENIAttachment ) String ( ) string { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return eni . stringUnsafe ( ) } 
func ( eni * ENIAttachment ) stringUnsafe ( ) string { return fmt . Sprintf ( " " , eni . TaskARN , eni . AttachmentARN , eni . AttachStatusSent , eni . MACAddress , eni . Status . String ( ) , eni . ExpiresAt . String ( ) ) } 
func StartMetricsSession ( params * TelemetrySessionParams ) { ok , err := params . isContainerHealthMetricsDisabled ( ) if err != nil { seelog . Warnf ( " " , err ) return } if ok { seelog . Warnf ( " " ) return } err = params . StatsEngine . MustInit ( params . Ctx , params . TaskEngine , params . Cfg . Cluster , params . ContainerInstanceArn ) if err != nil { seelog . Warnf ( " " , err ) return } err = StartSession ( params , params . StatsEngine ) if err != nil { seelog . Warnf ( " " , err ) } } 
func StartSession ( params * TelemetrySessionParams , statsEngine stats . Engine ) error { backoff := retry . NewExponentialBackoff ( time . Second , 1 * time . Minute , 0.2 , 2 ) for { tcsError := startTelemetrySession ( params , statsEngine ) if tcsError == nil || tcsError == io . EOF { seelog . Info ( " " ) backoff . Reset ( ) } else { seelog . Infof ( " " , tcsError ) params . time ( ) . Sleep ( backoff . Duration ( ) ) } } } 
func heartbeatHandler ( timer * time . Timer ) func ( * ecstcs . HeartbeatMessage ) { return func ( * ecstcs . HeartbeatMessage ) { seelog . Debug ( " " ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } } 
func ackPublishMetricHandler ( timer * time . Timer ) func ( * ecstcs . AckPublishMetric ) { return func ( * ecstcs . AckPublishMetric ) { seelog . Debug ( " " ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } } 
func ackPublishHealthMetricHandler ( timer * time . Timer ) func ( * ecstcs . AckPublishHealth ) { return func ( * ecstcs . AckPublishHealth ) { seelog . Debug ( " " ) timer . Reset ( retry . AddJitter ( defaultHeartbeatTimeout , defaultHeartbeatJitter ) ) } } 
func anyMessageHandler ( client wsclient . ClientServer ) func ( interface { } ) { return func ( interface { } ) { seelog . Trace ( " " ) } } } 
func formatURL ( endpoint string , cluster string , containerInstance string ) string { tcsURL := endpoint if ! strings . HasSuffix ( tcsURL , " " ) { tcsURL += " " } query := url . Values { } query . Set ( " " , cluster ) query . Set ( " " , containerInstance ) return tcsURL + " " + query . Encode ( ) } 
func ( a * Box ) SetCenterWidget ( child IWidget ) { if child == nil { C . gtk_box_set_center_widget ( a . native ( ) , nil ) } else { C . gtk_box_set_center_widget ( a . native ( ) , child . toWidget ( ) ) } } 
func ( a * Box ) GetCenterWidget ( ) * Widget { w := C . gtk_box_get_center_widget ( a . native ( ) ) if w == nil { return nil } return & Widget { glib . InitiallyUnowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func ( v * StackSwitcher ) native ( ) * C . GtkStackSwitcher { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStackSwitcher ( p ) } 
func StackSwitcherNew ( ) ( * StackSwitcher , error ) { c := C . gtk_stack_switcher_new ( ) if c == nil { return nil , nilPtrErr } return wrapStackSwitcher ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * StackSwitcher ) SetStack ( stack * Stack ) { C . gtk_stack_switcher_set_stack ( v . native ( ) , stack . native ( ) ) } 
func ( v * StackSwitcher ) GetStack ( ) * Stack { c := C . gtk_stack_switcher_get_stack ( v . native ( ) ) if c == nil { return nil } return wrapStack ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ComboBox ) native ( ) * C . GtkComboBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkComboBox ( p ) } 
func ComboBoxNew ( ) ( * ComboBox , error ) { c := C . gtk_combo_box_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapComboBox ( obj ) , nil } 
func ComboBoxNewWithEntry ( ) ( * ComboBox , error ) { c := C . gtk_combo_box_new_with_entry ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapComboBox ( obj ) , nil } 
func ComboBoxNewWithModel ( model ITreeModel ) ( * ComboBox , error ) { c := C . gtk_combo_box_new_with_model ( model . toTreeModel ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapComboBox ( obj ) , nil } 
func ( v * ComboBox ) GetActive ( ) int { c := C . gtk_combo_box_get_active ( v . native ( ) ) return int ( c ) } 
func ( v * ComboBox ) SetActive ( index int ) { C . gtk_combo_box_set_active ( v . native ( ) , C . gint ( index ) ) } 
func ( v * ComboBox ) GetActiveIter ( ) ( * TreeIter , error ) { var cIter C . GtkTreeIter c := C . gtk_combo_box_get_active_iter ( v . native ( ) , & cIter ) if ! gobool ( c ) { return nil , errors . New ( " " ) } return & TreeIter { cIter } , nil } 
func ( v * ComboBox ) SetActiveIter ( iter * TreeIter ) { var cIter * C . GtkTreeIter if iter != nil { cIter = & iter . GtkTreeIter } C . gtk_combo_box_set_active_iter ( v . native ( ) , cIter ) } 
func ( v * ComboBox ) GetActiveID ( ) string { c := C . gtk_combo_box_get_active_id ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * ComboBox ) SetActiveID ( id string ) bool { cid := C . CString ( id ) defer C . free ( unsafe . Pointer ( cid ) ) c := C . gtk_combo_box_set_active_id ( v . native ( ) , ( * C . gchar ) ( cid ) ) return gobool ( c ) } 
func ( v * ComboBox ) GetModel ( ) ( * TreeModel , error ) { c := C . gtk_combo_box_get_model ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapTreeModel ( obj ) , nil } 
func ( v * ComboBox ) SetModel ( model ITreeModel ) { var mptr * C . GtkTreeModel if model != nil { mptr = model . toTreeModel ( ) } C . gtk_combo_box_set_model ( v . native ( ) , mptr ) } 
func ( v * ComboBoxText ) native ( ) * C . GtkComboBoxText { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkComboBoxText ( p ) } 
func ComboBoxTextNew ( ) ( * ComboBoxText , error ) { c := C . gtk_combo_box_text_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapComboBoxText ( obj ) , nil } 
func ComboBoxTextNewWithEntry ( ) ( * ComboBoxText , error ) { c := C . gtk_combo_box_text_new_with_entry ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapComboBoxText ( obj ) , nil } 
func ( v * ComboBoxText ) Append ( id , text string ) { cid := C . CString ( id ) ctext := C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk_combo_box_text_append ( v . native ( ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * ComboBoxText ) Prepend ( id , text string ) { cid := C . CString ( id ) ctext := C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk_combo_box_text_prepend ( v . native ( ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * ComboBoxText ) Insert ( position int , id , text string ) { cid := C . CString ( id ) ctext := C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk_combo_box_text_insert ( v . native ( ) , C . gint ( position ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * ComboBoxText ) AppendText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_combo_box_text_append_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ComboBoxText ) PrependText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_combo_box_text_prepend_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ComboBoxText ) InsertText ( position int , text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_combo_box_text_insert_text ( v . native ( ) , C . gint ( position ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ComboBoxText ) Remove ( position int ) { C . gtk_combo_box_text_remove ( v . native ( ) , C . gint ( position ) ) } 
func ( v * ComboBoxText ) GetActiveText ( ) string { c := ( * C . char ) ( C . gtk_combo_box_text_get_active_text ( v . native ( ) ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . GoString ( c ) } 
func ( inclusive * Rectangle ) ExtentsToPixels ( nearest * Rectangle ) { C . pango_extents_to_pixels ( inclusive . native ( ) , nearest . native ( ) ) } 
func ( v * Menu ) PopupAtPointer ( _ * gdk . Event ) { C . gtk_menu_popup ( v . native ( ) , nil , nil , nil , nil , C . guint ( 0 ) , C . gtk_get_current_event_time ( ) ) } 
func ( v * Application ) native ( ) * C . GApplication { if v == nil || v . GObject == nil { return nil } return C . toGApplication ( unsafe . Pointer ( v . GObject ) ) } 
func ApplicationIDIsValid ( id string ) bool { cstr1 := ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_application_id_is_valid ( cstr1 ) ) } 
func ApplicationNew ( appID string , flags ApplicationFlags ) * Application { cstr1 := ( * C . gchar ) ( C . CString ( appID ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . g_application_new ( cstr1 , C . GApplicationFlags ( flags ) ) if c == nil { return nil } return wrapApplication ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) GetApplicationID ( ) string { c := C . g_application_get_application_id ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Application ) SetApplicationID ( id string ) { cstr1 := ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_application_set_application_id ( v . native ( ) , cstr1 ) } 
func ( v * Application ) SetInactivityTimeout ( timeout uint ) { C . g_application_set_inactivity_timeout ( v . native ( ) , C . guint ( timeout ) ) } 
func ( v * Application ) SetFlags ( flags ApplicationFlags ) { C . g_application_set_flags ( v . native ( ) , C . GApplicationFlags ( flags ) ) } 
func ( v * Application ) GetDbusObjectPath ( ) string { c := C . g_application_get_dbus_object_path ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Application ) SendNotification ( id string , notification * Notification ) { cstr1 := ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_application_send_notification ( v . native ( ) , cstr1 , notification . native ( ) ) } 
func ( v * Application ) WithdrawNotification ( id string ) { cstr1 := ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_application_withdraw_notification ( v . native ( ) , cstr1 ) } 
func ApplicationGetDefault ( ) * Application { c := C . g_application_get_default ( ) if c == nil { return nil } return wrapApplication ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Run ( args [ ] string ) int { cargs := C . make_strings ( C . int ( len ( args ) ) ) defer C . destroy_strings ( cargs ) for i , arg := range args { cstr := C . CString ( arg ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set_string ( cargs , C . int ( i ) , ( * C . char ) ( cstr ) ) } return int ( C . g_application_run ( v . native ( ) , C . int ( len ( args ) ) , cargs ) ) } 
func ( v * AppChooser ) native ( ) * C . GtkAppChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAppChooser ( p ) } 
func ( v * AppChooser ) GetContentType ( ) string { cstr := C . gtk_app_chooser_get_content_type ( v . native ( ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( ( * C . char ) ( cstr ) ) } 
func ( v * AppChooserButton ) native ( ) * C . GtkAppChooserButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAppChooserButton ( p ) } 
func AppChooserButtonNew ( content_type string ) ( * AppChooserButton , error ) { cstr := C . CString ( content_type ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_app_chooser_button_new ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapAppChooserButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * AppChooserButton ) SetActiveCustomItem ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_app_chooser_button_set_active_custom_item ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AppChooserButton ) SetShowDefaultItem ( setting bool ) { C . gtk_app_chooser_button_set_show_default_item ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserButton ) SetShowDialogItem ( setting bool ) { C . gtk_app_chooser_button_set_show_dialog_item ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserButton ) GetHeading ( ) ( string , error ) { cstr := C . gtk_app_chooser_button_get_heading ( v . native ( ) ) if cstr == nil { return " " , nilPtrErr } defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * AppChooserButton ) SetHeading ( heading string ) { cstr := C . CString ( heading ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_app_chooser_button_set_heading ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AppChooserWidget ) native ( ) * C . GtkAppChooserWidget { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAppChooserWidget ( p ) } 
func AppChooserWidgetNew ( content_type string ) ( * AppChooserWidget , error ) { cstr := C . CString ( content_type ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_app_chooser_widget_new ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapAppChooserWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * AppChooserWidget ) SetShowDefault ( setting bool ) { C . gtk_app_chooser_widget_set_show_default ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserWidget ) SetShowRecommended ( setting bool ) { C . gtk_app_chooser_widget_set_show_recommended ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserWidget ) SetShowFallback ( setting bool ) { C . gtk_app_chooser_widget_set_show_fallback ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserWidget ) SetShowOther ( setting bool ) { C . gtk_app_chooser_widget_set_show_other ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserWidget ) SetShowAll ( setting bool ) { C . gtk_app_chooser_widget_set_show_all ( v . native ( ) , gbool ( setting ) ) } 
func ( v * AppChooserWidget ) GetDefaultText ( ) ( string , error ) { cstr := C . gtk_app_chooser_widget_get_default_text ( v . native ( ) ) if cstr == nil { return " " , nilPtrErr } defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * AppChooserWidget ) SetDefaultText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_app_chooser_widget_set_default_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AppChooserDialog ) native ( ) * C . GtkAppChooserDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAppChooserDialog ( p ) } 
func AppChooserDialogNewForContentType ( parent * Window , flags DialogFlags , content_type string ) ( * AppChooserDialog , error ) { cstr := C . CString ( content_type ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_app_chooser_dialog_new_for_content_type ( parent . native ( ) , C . GtkDialogFlags ( flags ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapAppChooserDialog ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * AppChooserDialog ) GetWidget ( ) * AppChooserWidget { c := C . gtk_app_chooser_dialog_get_widget ( v . native ( ) ) return wrapAppChooserWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * AppChooserDialog ) GetHeading ( ) ( string , error ) { cstr := C . gtk_app_chooser_dialog_get_heading ( v . native ( ) ) if cstr == nil { return " " , nilPtrErr } defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * AppChooserDialog ) SetHeading ( heading string ) { cstr := C . CString ( heading ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_app_chooser_dialog_set_heading ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * PixbufFormat ) native ( ) * C . GdkPixbufFormat { if v == nil { return nil } return v . format } 
func ( f * PixbufFormat ) GetMimeTypes ( ) [ ] string { var types [ ] string c := C . gdk_pixbuf_format_get_mime_types ( f . native ( ) ) if c == nil { return nil } for * c != nil { types = append ( types , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return types } 
func ( f * PixbufFormat ) GetExtensions ( ) [ ] string { var extensions [ ] string c := C . gdk_pixbuf_format_get_extensions ( f . native ( ) ) if c == nil { return nil } for * c != nil { extensions = append ( extensions , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return extensions } 
func ( v * Window ) ResizeGripIsVisible ( ) bool { c := C . gtk_window_resize_grip_is_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) SetHasResizeGrip ( setting bool ) { C . gtk_window_set_has_resize_grip ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) GetHasResizeGrip ( ) bool { c := C . gtk_window_get_has_resize_grip ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Reparent ( newParent IWidget ) { C . gtk_widget_reparent ( v . native ( ) , newParent . toWidget ( ) ) } 
func ( v * Alignment ) GetPadding ( ) ( top , bottom , left , right uint ) { var ctop , cbottom , cleft , cright C . guint C . gtk_alignment_get_padding ( v . native ( ) , & ctop , & cbottom , & cleft , & cright ) return uint ( ctop ) , uint ( cbottom ) , uint ( cleft ) , uint ( cright ) } 
func ( v * Alignment ) SetPadding ( top , bottom , left , right uint ) { C . gtk_alignment_set_padding ( v . native ( ) , C . guint ( top ) , C . guint ( bottom ) , C . guint ( left ) , C . guint ( right ) ) } 
func AlignmentNew ( xalign , yalign , xscale , yscale float32 ) ( * Alignment , error ) { c := C . gtk_alignment_new ( C . gfloat ( xalign ) , C . gfloat ( yalign ) , C . gfloat ( xscale ) , C . gfloat ( yscale ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAlignment ( obj ) , nil } 
func ( v * Alignment ) Set ( xalign , yalign , xscale , yscale float32 ) { C . gtk_alignment_set ( v . native ( ) , C . gfloat ( xalign ) , C . gfloat ( yalign ) , C . gfloat ( xscale ) , C . gfloat ( yscale ) ) } 
func ArrowNew ( arrowType ArrowType , shadowType ShadowType ) ( * Arrow , error ) { c := C . gtk_arrow_new ( C . GtkArrowType ( arrowType ) , C . GtkShadowType ( shadowType ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapArrow ( obj ) , nil } 
func ( v * Arrow ) Set ( arrowType ArrowType , shadowType ShadowType ) { C . gtk_arrow_set ( v . native ( ) , C . GtkArrowType ( arrowType ) , C . GtkShadowType ( shadowType ) ) } 
func ( v * Button ) SetAlignment ( xalign , yalign float32 ) { C . gtk_button_set_alignment ( v . native ( ) , ( C . gfloat ) ( xalign ) , ( C . gfloat ) ( yalign ) ) } 
func ( v * Button ) GetAlignment ( ) ( xalign , yalign float32 ) { var x , y C . gfloat C . gtk_button_get_alignment ( v . native ( ) , & x , & y ) return float32 ( x ) , float32 ( y ) } 
func ( v * Container ) SetReallocateRedraws ( needsRedraws bool ) { C . gtk_container_set_reallocate_redraws ( v . native ( ) , gbool ( needsRedraws ) ) } 
func ( v * Misc ) GetAlignment ( ) ( xAlign , yAlign float32 ) { var x , y C . gfloat C . gtk_misc_get_alignment ( v . native ( ) , & x , & y ) return float32 ( x ) , float32 ( y ) } 
func ( v * Misc ) SetAlignment ( xAlign , yAlign float32 ) { C . gtk_misc_set_alignment ( v . native ( ) , C . gfloat ( xAlign ) , C . gfloat ( yAlign ) ) } 
func ( v * Misc ) GetPadding ( ) ( xpad , ypad int ) { var x , y C . gint C . gtk_misc_get_padding ( v . native ( ) , & x , & y ) return int ( x ) , int ( y ) } 
func ( v * Misc ) SetPadding ( xPad , yPad int ) { C . gtk_misc_set_padding ( v . native ( ) , C . gint ( xPad ) , C . gint ( yPad ) ) } 
func ( v * Widget ) SetDoubleBuffered ( doubleBuffered bool ) { C . gtk_widget_set_double_buffered ( v . native ( ) , gbool ( doubleBuffered ) ) } 
func ( v * Widget ) GetDoubleBuffered ( ) bool { c := C . gtk_widget_get_double_buffered ( v . native ( ) ) return gobool ( c ) } 
func ( v * Arrow ) native ( ) * C . GtkArrow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkArrow ( p ) } 
func ( v * Alignment ) native ( ) * C . GtkAlignment { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAlignment ( p ) } 
func StatusIconNew ( ) ( * StatusIcon , error ) { c := C . gtk_status_icon_new ( ) if c == nil { return nil , nilPtrErr } return wrapStatusIcon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func StatusIconNewFromFile ( filename string ) ( * StatusIcon , error ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_status_icon_new_from_file ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapStatusIcon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func StatusIconNewFromIconName ( iconName string ) ( * StatusIcon , error ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_status_icon_new_from_icon_name ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapStatusIcon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func StatusIconNewFromPixbuf ( pixbuf * gdk . Pixbuf ) ( * StatusIcon , error ) { c := C . gtk_status_icon_new_from_pixbuf ( C . toGdkPixbuf ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapStatusIcon ( obj ) , nil } 
func ( v * StatusIcon ) SetFromFile ( filename string ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_from_file ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) SetFromIconName ( iconName string ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_from_icon_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) SetFromPixbuf ( pixbuf * gdk . Pixbuf ) { C . gtk_status_icon_set_from_pixbuf ( v . native ( ) , C . toGdkPixbuf ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * StatusIcon ) SetTooltipText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_tooltip_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) GetTooltipText ( ) string { c := C . gtk_status_icon_get_tooltip_text ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * StatusIcon ) SetTooltipMarkup ( markup string ) { cstr := C . CString ( markup ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_tooltip_markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) GetTooltipMarkup ( ) string { c := C . gtk_status_icon_get_tooltip_markup ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * StatusIcon ) SetHasTooltip ( hasTooltip bool ) { C . gtk_status_icon_set_has_tooltip ( v . native ( ) , gbool ( hasTooltip ) ) } 
func ( v * StatusIcon ) GetTitle ( ) string { c := C . gtk_status_icon_get_title ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * StatusIcon ) SetName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) SetVisible ( visible bool ) { C . gtk_status_icon_set_visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * StatusIcon ) SetTitle ( title string ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) GetIconName ( ) string { c := C . gtk_status_icon_get_icon_name ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Menu ) PopupAtStatusIcon ( statusIcon * StatusIcon , button uint , activateTime uint32 ) { C . gotk_menu_popup_at_status_icon ( v . native ( ) , statusIcon . native ( ) , C . guint ( button ) , C . guint32 ( activateTime ) ) } 
func ( v * Misc ) native ( ) * C . GtkMisc { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMisc ( p ) } 
func CairoCreateContext ( cr * cairo . Context ) * Context { c := C . pango_cairo_create_context ( cairo_context ( cr ) ) context := new ( Context ) context . pangoContext = ( * C . PangoContext ) ( c ) return context } 
func CairoCreateLayout ( cr * cairo . Context ) * Layout { c := C . pango_cairo_create_layout ( cairo_context ( cr ) ) layout := new ( Layout ) layout . pangoLayout = ( * C . PangoLayout ) ( c ) return layout } 
func CairoUpdateLayout ( cr * cairo . Context , v * Layout ) { C . pango_cairo_update_layout ( cairo_context ( cr ) , v . native ( ) ) } 
func CairoShowGlyphString ( cr * cairo . Context , font * Font , glyphs * GlyphString ) { C . pango_cairo_show_glyph_string ( cairo_context ( cr ) , font . native ( ) , glyphs . native ( ) ) } 
func CairoShowGlyphItem ( cr * cairo . Context , text string , glyph_item * GlyphItem ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango_cairo_show_glyph_item ( cairo_context ( cr ) , ( * C . char ) ( cstr ) , glyph_item . native ( ) ) } 
func CairoShowLayoutLine ( cr * cairo . Context , line * LayoutLine ) { C . pango_cairo_show_layout_line ( cairo_context ( cr ) , line . native ( ) ) } 
func CairoShowLayout ( cr * cairo . Context , layout * Layout ) { C . pango_cairo_show_layout ( cairo_context ( cr ) , layout . native ( ) ) } 
func CairoGlyphStringPath ( cr * cairo . Context , font * Font , glyphs * GlyphString ) { C . pango_cairo_glyph_string_path ( cairo_context ( cr ) , font . native ( ) , glyphs . native ( ) ) } 
func CairoLayoutLinePath ( cr * cairo . Context , line * LayoutLine ) { C . pango_cairo_layout_line_path ( cairo_context ( cr ) , line . native ( ) ) } 
func CairoLayoutPath ( cr * cairo . Context , layout * Layout ) { C . pango_cairo_layout_path ( cairo_context ( cr ) , layout . native ( ) ) } 
func CairoErrorUnderlinePath ( cr * cairo . Context , x , y , width , height float64 ) { C . pango_cairo_error_underline_path ( cairo_context ( cr ) , C . double ( x ) , C . double ( y ) , C . double ( width ) , C . double ( height ) ) } 
func ( v * ApplicationWindow ) native ( ) * C . GtkApplicationWindow { if v == nil || v . Window . GObject == nil { } p := unsafe . Pointer ( v . Window . GObject ) return C . toGtkApplicationWindow ( p ) } 
func ApplicationWindowNew ( app * Application ) ( * ApplicationWindow , error ) { c := C . gtk_application_window_new ( app . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapApplicationWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ApplicationWindow ) SetShowMenubar ( b bool ) { C . gtk_application_window_set_show_menubar ( v . native ( ) , gbool ( b ) ) } 
func ( v * Widget ) IsVisible ( ) bool { c := C . gtk_widget_is_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetOpacity ( opacity float64 ) { C . gtk_widget_set_opacity ( v . native ( ) , C . double ( opacity ) ) } 
func ( v * Widget ) GetOpacity ( ) float64 { c := C . gtk_widget_get_opacity ( v . native ( ) ) return float64 ( c ) } 
func ( v * Widget ) GetFrameClock ( ) * gdk . FrameClock { c := C . gtk_widget_get_frame_clock ( v . native ( ) ) return gdk . WrapFrameClock ( unsafe . Pointer ( c ) ) } 
func ( v * Widget ) AddTickCallback ( fn TickCallback , userData uintptr ) int { tickCallbackRegistry . Lock ( ) id := tickCallbackRegistry . next tickCallbackRegistry . next ++ tickCallbackRegistry . m [ id ] = tickCallbackData { fn : fn , userData : userData } tickCallbackRegistry . Unlock ( ) return int ( C . _gtk_widget_add_tick_callback ( v . native ( ) , C . gpointer ( uintptr ( id ) ) ) ) } 
func ( v * Widget ) RemoveTickCallback ( id int ) { C . gtk_widget_remove_tick_callback ( v . native ( ) , C . guint ( id ) ) } 
func goListBoxFilterFuncs ( row * C . GtkListBoxRow , userData C . gpointer ) C . gboolean { id := int ( uintptr ( userData ) ) listBoxFilterFuncRegistry . Lock ( ) r := listBoxFilterFuncRegistry . m [ id ] return gbool ( r . fn ( wrapListBoxRow ( glib . Take ( unsafe . Pointer ( row ) ) ) , r . userData ) ) } 
func ( v * Variant ) ToGVariant ( ) * C . GVariant { if v == nil { return nil } return v . native ( ) } 
func ( v * Variant ) native ( ) * C . GVariant { if v == nil || v . GVariant == nil { return nil } return v . GVariant } 
func ( v * Variant ) TypeString ( ) string { } 
func ( v * Variant ) GetString ( ) string { var len C . gsize gc := C . g_variant_get_string ( v . native ( ) , & len ) defer C . g_free ( C . gpointer ( gc ) ) return C . GoStringN ( ( * C . char ) ( gc ) , ( C . int ) ( len ) ) } 
func ( v * Variant ) GetStrv ( ) [ ] string { gstrv := C . g_variant_get_strv ( v . native ( ) , nil ) defer C . g_free ( C . gpointer ( gstrv ) ) var strs [ ] string for * c != nil { strs = append ( strs , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return strs } 
func ( v * Variant ) GetInt ( ) ( int64 , error ) { t := v . Type ( ) . String ( ) var i int64 switch t { case " " : i = int64 ( C . g_variant_get_byte ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_int16 ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_uint16 ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_int32 ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_uint32 ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_int64 ( v . native ( ) ) ) case " " : i = int64 ( C . g_variant_get_uint64 ( v . native ( ) ) ) default : return 0 , fmt . Errorf ( " " , t ) } return i , nil } 
func ( v * Variant ) IsType ( t * VariantType ) bool { return gobool ( C . g_variant_is_of_type ( v . native ( ) , t . native ( ) ) ) } 
func ( v * Variant ) String ( ) string { gc := C . g_variant_print ( v . native ( ) , gbool ( false ) ) defer C . g_free ( C . gpointer ( gc ) ) return C . GoString ( ( * C . char ) ( gc ) ) } 
func ( v * Variant ) AnnotatedString ( ) string { gc := C . g_variant_print ( v . native ( ) , gbool ( true ) ) defer C . g_free ( C . gpointer ( gc ) ) return C . GoString ( ( * C . char ) ( gc ) ) } 
func ( p * Popover ) SetDefaultWidget ( widget IWidget ) { C . gtk_popover_set_default_widget ( p . native ( ) , widget . toWidget ( ) ) } 
func ( p * Popover ) GetDefaultWidget ( ) * Widget { w := C . gtk_popover_get_default_widget ( p . native ( ) ) if w == nil { return nil } return & Widget { glib . InitiallyUnowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func LayoutNew ( context * Context ) * Layout { c := C . pango_layout_new ( context . native ( ) ) layout := new ( Layout ) layout . pangoLayout = ( * C . PangoLayout ) ( c ) return layout } 
func ( v * Layout ) Copy ( ) * Layout { c := C . pango_layout_copy ( v . native ( ) ) layout := new ( Layout ) layout . pangoLayout = ( * C . PangoLayout ) ( c ) return layout } 
func ( v * Layout ) GetContext ( ) * Context { c := C . pango_layout_get_context ( v . native ( ) ) context := new ( Context ) context . pangoContext = ( * C . PangoContext ) ( c ) return context } 
func ( v * Layout ) SetAttributes ( attrs * AttrList ) { C . pango_layout_set_attributes ( v . native ( ) , attrs . native ( ) ) } 
func ( v * Layout ) GetAttributes ( ) * AttrList { c := C . pango_layout_get_attributes ( v . native ( ) ) attrList := new ( AttrList ) attrList . pangoAttrList = ( * C . PangoAttrList ) ( c ) return attrList } 
func ( v * Layout ) SetText ( text string , length int ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango_layout_set_text ( v . native ( ) , ( * C . char ) ( cstr ) , ( C . int ) ( length ) ) } 
func ( v * Layout ) GetText ( ) string { c := C . pango_layout_get_text ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Layout ) GetCharacterCount ( ) int { c := C . pango_layout_get_character_count ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) SetMarkup ( text string , length int ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango_layout_set_markup ( v . native ( ) , ( * C . char ) ( cstr ) , ( C . int ) ( length ) ) } 
func ( v * Layout ) SetFontDescription ( desc * FontDescription ) { C . pango_layout_set_font_description ( v . native ( ) , desc . native ( ) ) } 
func ( v * Layout ) GetFontDescription ( ) * FontDescription { c := C . pango_layout_get_font_description ( v . native ( ) ) desc := new ( FontDescription ) desc . pangoFontDescription = ( * C . PangoFontDescription ) ( c ) return desc } 
func ( v * Layout ) SetWidth ( width int ) { C . pango_layout_set_width ( v . native ( ) , C . int ( width ) ) } 
func ( v * Layout ) GetWidth ( ) int { c := C . pango_layout_get_width ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) SetHeight ( width int ) { C . pango_layout_set_height ( v . native ( ) , C . int ( width ) ) } 
func ( v * Layout ) GetHeight ( ) int { c := C . pango_layout_get_height ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) SetWrap ( wrap WrapMode ) { C . pango_layout_set_wrap ( v . native ( ) , C . PangoWrapMode ( wrap ) ) } 
func ( v * Layout ) GetWrap ( ) WrapMode { c := C . pango_layout_get_wrap ( v . native ( ) ) return WrapMode ( c ) } 
func ( v * Layout ) IsWrapped ( ) bool { c := C . pango_layout_is_wrapped ( v . native ( ) ) return gobool ( c ) } 
func ( v * Layout ) SetIndent ( indent int ) { C . pango_layout_set_indent ( v . native ( ) , C . int ( indent ) ) } 
func ( v * Layout ) GetIndent ( ) int { c := C . pango_layout_get_indent ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) GetSize ( ) ( int , int ) { var w , h C . int C . pango_layout_get_size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func ButtonNewFromStock ( stock Stock ) ( * Button , error ) { cstr := C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_button_new_from_stock ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Button ) SetUseStock ( useStock bool ) { C . gtk_button_set_use_stock ( v . native ( ) , gbool ( useStock ) ) } 
func ( v * Button ) GetUseStock ( ) bool { c := C . gtk_button_get_use_stock ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) GetIconStock ( iconPos EntryIconPosition ) ( string , error ) { c := C . gtk_entry_get_icon_stock ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Entry ) SetIconFromStock ( iconPos EntryIconPosition , stockID string ) { cstr := C . CString ( stockID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_icon_from_stock ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , ( * C . gchar ) ( cstr ) ) } 
func ImageNewFromStock ( stock Stock , size IconSize ) ( * Image , error ) { cstr := C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_image_new_from_stock ( ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) if c == nil { return nil , nilPtrErr } return wrapImage ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Image ) SetFromStock ( stock Stock , size IconSize ) { cstr := C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_image_set_from_stock ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) } 
func StatusIconNewFromStock ( stockId string ) ( * StatusIcon , error ) { cstr := C . CString ( stockId ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_status_icon_new_from_file ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapStatusIcon ( obj ) , nil } 
func ( v * StatusIcon ) SetFromStock ( stockID string ) { cstr := C . CString ( stockID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_status_icon_set_from_stock ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * StatusIcon ) GetStock ( ) string { c := C . gtk_status_icon_get_stock ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Container ) GetFocusChain ( ) ( [ ] * Widget , bool ) { var cwlist * C . GList c := C . gtk_container_get_focus_chain ( v . native ( ) , & cwlist ) var widgets [ ] * Widget wlist := glib . WrapList ( uintptr ( unsafe . Pointer ( cwlist ) ) ) for ; wlist . Data ( ) != nil ; wlist = wlist . Next ( ) { widgets = append ( widgets , wrapWidget ( glib . Take ( wlist . Data ( ) . ( unsafe . Pointer ) ) ) ) } return widgets , gobool ( c ) } 
func ( v * Container ) SetFocusChain ( focusableWidgets [ ] IWidget ) { var list * glib . List for _ , w := range focusableWidgets { data := uintptr ( unsafe . Pointer ( w . toWidget ( ) ) ) list = list . Append ( data ) } glist := ( * C . GList ) ( unsafe . Pointer ( list ) ) C . gtk_container_set_focus_chain ( v . native ( ) , glist ) } 
func CssProviderGetDefault ( ) ( * CssProvider , error ) { c := C . gtk_css_provider_get_default ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCssProvider ( obj ) , nil } 
func ( v * MenuModel ) native ( ) * C . GMenuModel { if v == nil || v . GObject == nil { return nil } return C . toGMenuModel ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * MenuModel ) GetItemLink ( index int , link string ) * MenuModel { cstr := ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . g_menu_model_get_item_link ( v . native ( ) , C . gint ( index ) , cstr ) if c == nil { return nil } return wrapMenuModel ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuModel ) ItemsChanged ( position , removed , added int ) { C . g_menu_model_items_changed ( v . native ( ) , C . gint ( position ) , C . gint ( removed ) , C . gint ( added ) ) } 
func ( m * Menu ) native ( ) * C . GMenu { if m == nil || m . GObject == nil { return nil } p := unsafe . Pointer ( m . GObject ) return C . toGMenu ( p ) } 
func MenuNew ( ) * Menu { c := C . g_menu_new ( ) if c == nil { return nil } return wrapMenu ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) Insert ( position int , label , detailed_action string ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( detailed_action ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) C . g_menu_insert ( v . native ( ) , C . gint ( position ) , cstr1 , cstr2 ) } 
func ( v * Menu ) Prepend ( label , detailed_action string ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( detailed_action ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) C . g_menu_prepend ( v . native ( ) , cstr1 , cstr2 ) } 
func ( v * Menu ) Append ( label , detailed_action string ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( detailed_action ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) C . g_menu_append ( v . native ( ) , cstr1 , cstr2 ) } 
func ( v * Menu ) InsertItem ( position int , item * MenuItem ) { C . g_menu_insert_item ( v . native ( ) , C . gint ( position ) , item . native ( ) ) } 
func ( v * Menu ) AppendItem ( item * MenuItem ) { C . g_menu_append_item ( v . native ( ) , item . native ( ) ) } 
func ( v * Menu ) PrependItem ( item * MenuItem ) { C . g_menu_prepend_item ( v . native ( ) , item . native ( ) ) } 
func ( v * Menu ) InsertSection ( position int , label string , section * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_insert_section ( v . native ( ) , C . gint ( position ) , cstr1 , section . native ( ) ) } 
func ( v * Menu ) PrependSection ( label string , section * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_prepend_section ( v . native ( ) , cstr1 , section . native ( ) ) } 
func ( v * Menu ) AppendSection ( label string , section * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_append_section ( v . native ( ) , cstr1 , section . native ( ) ) } 
func ( v * Menu ) InsertSectionWithoutLabel ( position int , section * MenuModel ) { C . g_menu_insert_section ( v . native ( ) , C . gint ( position ) , nil , section . native ( ) ) } 
func ( v * Menu ) PrependSectionWithoutLabel ( section * MenuModel ) { C . g_menu_prepend_section ( v . native ( ) , nil , section . native ( ) ) } 
func ( v * Menu ) AppendSectionWithoutLabel ( section * MenuModel ) { C . g_menu_append_section ( v . native ( ) , nil , section . native ( ) ) } 
func ( v * Menu ) InsertSubmenu ( position int , label string , submenu * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_insert_submenu ( v . native ( ) , C . gint ( position ) , cstr1 , submenu . native ( ) ) } 
func ( v * Menu ) PrependSubmenu ( label string , submenu * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_prepend_submenu ( v . native ( ) , cstr1 , submenu . native ( ) ) } 
func ( v * Menu ) AppendSubmenu ( label string , submenu * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_append_submenu ( v . native ( ) , cstr1 , submenu . native ( ) ) } 
func ( v * Menu ) Remove ( position int ) { C . g_menu_remove ( v . native ( ) , C . gint ( position ) ) } 
func ( m * MenuItem ) native ( ) * C . GMenuItem { if m == nil || m . GObject == nil { return nil } p := unsafe . Pointer ( m . GObject ) return C . toGMenuItem ( p ) } 
func MenuItemNew ( label , detailed_action string ) * MenuItem { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( detailed_action ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) c := C . g_menu_item_new ( cstr1 , cstr2 ) if c == nil { return nil } return wrapMenuItem ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func MenuItemNewSection ( label string , section * MenuModel ) * MenuItem { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . g_menu_item_new_section ( cstr1 , section . native ( ) ) if c == nil { return nil } return wrapMenuItem ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func MenuItemNewSubmenu ( label string , submenu * MenuModel ) * MenuItem { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . g_menu_item_new_submenu ( cstr1 , submenu . native ( ) ) if c == nil { return nil } return wrapMenuItem ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func MenuItemNewFromModel ( model * MenuModel , index int ) * MenuItem { c := C . g_menu_item_new_from_model ( model . native ( ) , C . gint ( index ) ) if c == nil { return nil } return wrapMenuItem ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuItem ) SetLabel ( label string ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_item_set_label ( v . native ( ) , cstr1 ) } 
func ( v * MenuItem ) SetDetailedAction ( act string ) { cstr1 := ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_item_set_detailed_action ( v . native ( ) , cstr1 ) } 
func ( v * MenuItem ) SetSection ( section * MenuModel ) { C . g_menu_item_set_section ( v . native ( ) , section . native ( ) ) } 
func ( v * MenuItem ) SetSubmenu ( submenu * MenuModel ) { C . g_menu_item_set_submenu ( v . native ( ) , submenu . native ( ) ) } 
func ( v * MenuItem ) GetLink ( link string ) * MenuModel { cstr1 := ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . g_menu_item_get_link ( v . native ( ) , cstr1 ) if c == nil { return nil } return wrapMenuModel ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuItem ) SetLink ( link string , model * MenuModel ) { cstr1 := ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_menu_item_set_link ( v . native ( ) , cstr1 , model . native ( ) ) } 
func ( v * ScrolledWindow ) SetOverlayScrolling ( scrolling bool ) { C . gtk_scrolled_window_set_overlay_scrolling ( v . native ( ) , gbool ( scrolling ) ) } 
func ( v * Paned ) SetWideHandle ( wide bool ) { C . gtk_paned_set_wide_handle ( v . native ( ) , gbool ( wide ) ) } 
func ( v * Label ) GetXAlign ( ) float64 { c := C . gtk_label_get_xalign ( v . native ( ) ) return float64 ( c ) } 
func ( v * Label ) GetYAlign ( ) float64 { c := C . gtk_label_get_yalign ( v . native ( ) ) return float64 ( c ) } 
func ( v * Label ) SetXAlign ( n float64 ) { C . gtk_label_set_xalign ( v . native ( ) , C . gfloat ( n ) ) } 
func ( v * Label ) SetYAlign ( n float64 ) { C . gtk_label_set_yalign ( v . native ( ) , C . gfloat ( n ) ) } 
func ( v * StackSidebar ) native ( ) * C . GtkStackSidebar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStackSidebar ( p ) } 
func StackSidebarNew ( ) ( * StackSidebar , error ) { c := C . gtk_stack_sidebar_new ( ) if c == nil { return nil , nilPtrErr } return wrapStackSidebar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Overlay ) ReorderOverlay ( child IWidget , position int ) { C . gtk_overlay_reorder_overlay ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func ( v * Overlay ) GetOverlayPassThrough ( widget IWidget ) bool { c := C . gtk_overlay_get_overlay_pass_through ( v . native ( ) , widget . toWidget ( ) ) return gobool ( c ) } 
func ( v * Overlay ) SetOverlayPassThrough ( widget IWidget , passThrough bool ) { C . gtk_overlay_set_overlay_pass_through ( v . native ( ) , widget . toWidget ( ) , gbool ( passThrough ) ) } 
func ( v * FrameClock ) native ( ) * C . GdkFrameClock { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkFrameClock ( p ) } 
func ( v * FrameClock ) GetTimings ( frameCounter int64 ) ( * FrameTimings , error ) { c := C . gdk_frame_clock_get_timings ( v . native ( ) , C . gint64 ( frameCounter ) ) if c == nil { return nil , nilPtrErr } return wrapFrameTimings ( unsafe . Pointer ( c ) ) , nil } 
func ( v * FrameClock ) GetCurrentTimings ( ) ( * FrameTimings , error ) { c := C . gdk_frame_clock_get_current_timings ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapFrameTimings ( unsafe . Pointer ( c ) ) , nil } 
func ( v * FrameClock ) GetRefreshInfo ( baseTime int64 ) ( int64 , int64 ) { var cr , cp ( * C . gint64 ) defer C . free ( unsafe . Pointer ( cr ) ) ; defer C . free ( unsafe . Pointer ( cp ) ) b := C . gint64 ( baseTime ) C . gdk_frame_clock_get_refresh_info ( v . native ( ) , b , cr , cp ) r , p := int64 ( * cr ) , int64 ( * cp ) return r , p } 
func ( v * FrameClock ) RequestPhase ( phase ClockPhase ) { C . gdk_frame_clock_request_phase ( v . native ( ) , C . GdkFrameClockPhase ( phase ) ) } 
func ( v * FrameTimings ) native ( ) * C . GdkFrameTimings { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkFrameTimings ( p ) } 
func ( v * FrameTimings ) Ref ( ) { c := C . gdk_frame_timings_ref ( v . native ( ) ) v = wrapFrameTimings ( unsafe . Pointer ( c ) ) } 
func ( v * Display ) GetNMonitors ( ) int { c := C . gdk_display_get_n_monitors ( v . native ( ) ) return int ( c ) } 
func ( v * Display ) GetPrimaryMonitor ( ) ( * Monitor , error ) { c := C . gdk_display_get_primary_monitor ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Monitor { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Monitor ) native ( ) * C . GdkMonitor { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkMonitor ( p ) } 
func ( v * Monitor ) GetGeometry ( ) * Rectangle { var rect C . GdkRectangle C . gdk_monitor_get_geometry ( v . native ( ) , & rect ) return WrapRectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * GLContext ) SetUseES ( es int ) { C . gdk_gl_context_set_use_es ( v . native ( ) , ( C . int ) ( es ) ) } 
func ( v * Screen ) native ( ) * C . GdkScreen { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkScreen ( p ) } 
func ( v * Screen ) GetRGBAVisual ( ) ( * Visual , error ) { c := C . gdk_screen_get_rgba_visual ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Visual { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Screen ) GetSystemVisual ( ) ( * Visual , error ) { c := C . gdk_screen_get_system_visual ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Visual { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Screen ) GetRootWindow ( ) ( * Window , error ) { return toWindow ( C . gdk_screen_get_root_window ( v . native ( ) ) ) } 
func ( v * Screen ) GetDisplay ( ) ( * Display , error ) { return toDisplay ( C . gdk_screen_get_display ( v . native ( ) ) ) } 
func ( v * Screen ) SetResolution ( r float64 ) { C . gdk_screen_set_resolution ( v . native ( ) , C . gdouble ( r ) ) } 
func ( v * VariantBuilder ) native ( ) * C . GVariantBuilder { if v == nil || v . GVariantBuilder == nil { return nil } p := unsafe . Pointer ( v . GVariantBuilder ) return C . toGVariantBuilder ( p ) } 
func ( v * Window ) GetOpacity ( ) float64 { c := C . gtk_window_get_opacity ( v . native ( ) ) return float64 ( c ) } 
func ( s Status ) String ( ) string { str := StatusToString ( s ) str = strings . Replace ( str , " " , " " , 1 ) str = strings . Replace ( str , " " , " " , 0 ) return strings . ToLower ( str ) } 
func ( s Status ) ToError ( ) error { if s == STATUS_SUCCESS { return nil } return errors . New ( s . String ( ) ) } 
func ( v * LevelBar ) native ( ) * C . GtkLevelBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLevelBar ( p ) } 
func LevelBarNew ( ) ( * LevelBar , error ) { c := C . gtk_level_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapLevelBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func LevelBarNewForInterval ( min_value , max_value float64 ) ( * LevelBar , error ) { c := C . gtk_level_bar_new_for_interval ( C . gdouble ( min_value ) , C . gdouble ( max_value ) ) if c == nil { return nil , nilPtrErr } return wrapLevelBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * LevelBar ) SetMode ( m LevelBarMode ) { C . gtk_level_bar_set_mode ( v . native ( ) , C . GtkLevelBarMode ( m ) ) } 
func ( v * LevelBar ) SetValue ( value float64 ) { C . gtk_level_bar_set_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * LevelBar ) GetValue ( ) float64 { c := C . gtk_level_bar_get_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * LevelBar ) SetMinValue ( value float64 ) { C . gtk_level_bar_set_min_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * LevelBar ) GetMinValue ( ) float64 { c := C . gtk_level_bar_get_min_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * LevelBar ) SetMaxValue ( value float64 ) { C . gtk_level_bar_set_max_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * LevelBar ) GetMaxValue ( ) float64 { c := C . gtk_level_bar_get_max_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * LevelBar ) AddOffsetValue ( name string , value float64 ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_level_bar_add_offset_value ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) ) } 
func ( v * LevelBar ) RemoveOffsetValue ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_level_bar_remove_offset_value ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * LevelBar ) GetOffsetValue ( name string ) ( float64 , bool ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var value C . gdouble c := C . gtk_level_bar_get_offset_value ( v . native ( ) , ( * C . gchar ) ( cstr ) , & value ) return float64 ( value ) , gobool ( c ) } 
func AcceleratorName ( key uint , mods gdk . ModifierType ) string { c := C . gtk_accelerator_name ( C . guint ( key ) , C . GdkModifierType ( mods ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func AcceleratorValid ( key uint , mods gdk . ModifierType ) bool { return gobool ( C . gtk_accelerator_valid ( C . guint ( key ) , C . GdkModifierType ( mods ) ) ) } 
func AcceleratorParse ( acc string ) ( key uint , mods gdk . ModifierType ) { cstr := C . CString ( acc ) defer C . free ( unsafe . Pointer ( cstr ) ) k := C . guint ( 0 ) m := C . GdkModifierType ( 0 ) C . gtk_accelerator_parse ( ( * C . gchar ) ( cstr ) , & k , & m ) return uint ( k ) , gdk . ModifierType ( m ) } 
func AcceleratorGetLabel ( key uint , mods gdk . ModifierType ) string { c := C . gtk_accelerator_get_label ( C . guint ( key ) , C . GdkModifierType ( mods ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AccelGroup ) native ( ) * C . GtkAccelGroup { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAccelGroup ( p ) } 
func AccelGroupNew ( ) ( * AccelGroup , error ) { c := C . gtk_accel_group_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAccelGroup ( obj ) , nil } 
func ( v * AccelGroup ) Connect ( key uint , mods gdk . ModifierType , flags AccelFlags , f interface { } ) { closure , _ := glib . ClosureNew ( f ) cl := ( * C . struct__GClosure ) ( unsafe . Pointer ( closure ) ) C . gtk_accel_group_connect ( v . native ( ) , C . guint ( key ) , C . GdkModifierType ( mods ) , C . GtkAccelFlags ( flags ) , cl ) } 
func ( v * AccelGroup ) ConnectByPath ( path string , f interface { } ) { closure , _ := glib . ClosureNew ( f ) cl := ( * C . struct__GClosure ) ( unsafe . Pointer ( closure ) ) cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_group_connect_by_path ( v . native ( ) , ( * C . gchar ) ( cstr ) , cl ) } 
func ( v * AccelGroup ) Disconnect ( f interface { } ) { closure , _ := glib . ClosureNew ( f ) cl := ( * C . struct__GClosure ) ( unsafe . Pointer ( closure ) ) C . gtk_accel_group_disconnect ( v . native ( ) , cl ) } 
func ( v * AccelGroup ) DisconnectKey ( key uint , mods gdk . ModifierType ) { C . gtk_accel_group_disconnect_key ( v . native ( ) , C . guint ( key ) , C . GdkModifierType ( mods ) ) } 
func AccelGroupFromClosure ( f interface { } ) * AccelGroup { closure , _ := glib . ClosureNew ( f ) cl := ( * C . struct__GClosure ) ( unsafe . Pointer ( closure ) ) c := C . gtk_accel_group_from_accel_closure ( cl ) if c == nil { return nil } return wrapAccelGroup ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * AccelGroup ) GetModifierMask ( ) gdk . ModifierType { return gdk . ModifierType ( C . gtk_accel_group_get_modifier_mask ( v . native ( ) ) ) } 
func AccelGroupsActivate ( obj * glib . Object , key uint , mods gdk . ModifierType ) bool { return gobool ( C . gtk_accel_groups_activate ( ( * C . GObject ) ( unsafe . Pointer ( obj . Native ( ) ) ) , C . guint ( key ) , C . GdkModifierType ( mods ) ) ) } 
func ( v * AccelGroup ) Activate ( quark glib . Quark , acceleratable * glib . Object , key uint , mods gdk . ModifierType ) bool { return gobool ( C . gtk_accel_group_activate ( v . native ( ) , C . GQuark ( quark ) , ( * C . GObject ) ( unsafe . Pointer ( acceleratable . Native ( ) ) ) , C . guint ( key ) , C . GdkModifierType ( mods ) ) ) } 
func AccelGroupsFromObject ( obj * glib . Object ) * glib . SList { res := C . gtk_accel_groups_from_object ( ( * C . GObject ) ( unsafe . Pointer ( obj . Native ( ) ) ) ) if res == nil { return nil } return ( * glib . SList ) ( unsafe . Pointer ( res ) ) } 
func ( v * AccelMap ) native ( ) * C . GtkAccelMap { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAccelMap ( p ) } 
func AccelMapAddEntry ( path string , key uint , mods gdk . ModifierType ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_add_entry ( ( * C . gchar ) ( cstr ) , C . guint ( key ) , C . GdkModifierType ( mods ) ) } 
func AccelMapLookupEntry ( path string ) * AccelKey { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) var v * C . struct__GtkAccelKey C . gtk_accel_map_lookup_entry ( ( * C . gchar ) ( cstr ) , v ) return wrapAccelKey ( v ) } 
func AccelMapChangeEntry ( path string , key uint , mods gdk . ModifierType , replace bool ) bool { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gtk_accel_map_change_entry ( ( * C . gchar ) ( cstr ) , C . guint ( key ) , C . GdkModifierType ( mods ) , gbool ( replace ) ) ) } 
func AccelMapLoad ( fileName string ) { cstr := C . CString ( fileName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_load ( ( * C . gchar ) ( cstr ) ) } 
func AccelMapSave ( fileName string ) { cstr := C . CString ( fileName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_save ( ( * C . gchar ) ( cstr ) ) } 
func AccelMapAddFilter ( filter string ) { cstr := C . CString ( filter ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_add_filter ( ( * C . gchar ) ( cstr ) ) } 
func AccelMapGet ( ) * AccelMap { c := C . gtk_accel_map_get ( ) if c == nil { return nil } return wrapAccelMap ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func AccelMapLockPath ( path string ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_lock_path ( ( * C . gchar ) ( cstr ) ) } 
func AccelMapUnlockPath ( path string ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_accel_map_unlock_path ( ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu ) SetAccelGroup ( accelGroup * AccelGroup ) { C . gtk_menu_set_accel_group ( v . native ( ) , accelGroup . native ( ) ) } 
func ( v * Menu ) GetAccelGroup ( ) * AccelGroup { c := C . gtk_menu_get_accel_group ( v . native ( ) ) if c == nil { return nil } return wrapAccelGroup ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) SetAccelPath ( path string ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_menu_set_accel_path ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu ) GetAccelPath ( ) string { c := C . gtk_menu_get_accel_path ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * MenuItem ) SetAccelPath ( path string ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_menu_item_set_accel_path ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * MenuItem ) GetAccelPath ( ) string { c := C . gtk_menu_item_get_accel_path ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Widget ) AddAccelerator ( signal string , group * AccelGroup , key uint , mods gdk . ModifierType , flags AccelFlags ) { csignal := ( * C . gchar ) ( C . CString ( signal ) ) defer C . free ( unsafe . Pointer ( csignal ) ) C . gtk_widget_add_accelerator ( v . native ( ) , csignal , group . native ( ) , C . guint ( key ) , C . GdkModifierType ( mods ) , C . GtkAccelFlags ( flags ) ) } 
func ( v * Widget ) RemoveAccelerator ( group * AccelGroup , key uint , mods gdk . ModifierType ) bool { return gobool ( C . gtk_widget_remove_accelerator ( v . native ( ) , group . native ( ) , C . guint ( key ) , C . GdkModifierType ( mods ) ) ) } 
func ( v * Widget ) SetAccelPath ( path string , group * AccelGroup ) { cstr := ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_widget_set_accel_path ( v . native ( ) , cstr , group . native ( ) ) } 
func ( v * Widget ) CanActivateAccel ( signalId uint ) bool { return gobool ( C . gtk_widget_can_activate_accel ( v . native ( ) , C . guint ( signalId ) ) ) } 
func ( v * Window ) AddAccelGroup ( accelGroup * AccelGroup ) { C . gtk_window_add_accel_group ( v . native ( ) , accelGroup . native ( ) ) } 
func ( v * Window ) RemoveAccelGroup ( accelGroup * AccelGroup ) { C . gtk_window_remove_accel_group ( v . native ( ) , accelGroup . native ( ) ) } 
func ( v * List ) DataWrapper ( fn func ( unsafe . Pointer ) interface { } ) { if v == nil { return } v . dataWrap = fn } 
func ( v * List ) Append ( data uintptr ) * List { glist := C . g_list_append ( v . native ( ) , C . gpointer ( data ) ) return v . wrapNewHead ( glist ) } 
func ( v * List ) Prepend ( data uintptr ) * List { glist := C . g_list_prepend ( v . native ( ) , C . gpointer ( data ) ) return v . wrapNewHead ( glist ) } 
func ( v * List ) Insert ( data uintptr , position int ) * List { glist := C . g_list_insert ( v . native ( ) , C . gpointer ( data ) , C . gint ( position ) ) return v . wrapNewHead ( glist ) } 
func ( v * List ) nthDataRaw ( n uint ) unsafe . Pointer { return unsafe . Pointer ( C . g_list_nth_data ( v . native ( ) , C . guint ( n ) ) ) } 
func ( v * List ) Nth ( n uint ) * List { list := wrapList ( C . g_list_nth ( v . native ( ) , C . guint ( n ) ) ) list . DataWrapper ( v . dataWrap ) return list } 
func ( v * List ) NthData ( n uint ) interface { } { ptr := v . nthDataRaw ( n ) if v . dataWrap != nil { return v . dataWrap ( ptr ) } return ptr } 
func ( v * List ) dataRaw ( ) unsafe . Pointer { return unsafe . Pointer ( v . native ( ) . data ) } 
func ( v * List ) Data ( ) interface { } { ptr := v . dataRaw ( ) if v . dataWrap != nil { return v . dataWrap ( ptr ) } return ptr } 
func ( v * List ) Foreach ( fn func ( item interface { } ) ) { for l := v ; l != nil ; l = l . Next ( ) { fn ( l . Data ( ) ) } } 
func ( v * List ) FreeFull ( fn func ( item interface { } ) ) { v . Foreach ( fn ) v . Free ( ) } 
func WrapContext ( p uintptr ) * Context { context := new ( Context ) context . pangoContext = ( * C . PangoContext ) ( unsafe . Pointer ( p ) ) return context } 
func ContextNew ( ) * Context { c := C . pango_context_new ( ) context := new ( Context ) context . pangoContext = ( * C . PangoContext ) ( c ) return context } 
func ( v * Dialog ) GetHeaderBar ( ) * Widget { c := C . gtk_dialog_get_header_bar ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Entry ) SetMaxWidthChars ( nChars int ) { C . gtk_entry_set_max_width_chars ( v . native ( ) , C . gint ( nChars ) ) } 
func ( v * Entry ) GetMaxWidthChars ( ) int { c := C . gtk_entry_get_max_width_chars ( v . native ( ) ) return int ( c ) } 
func ( v * HeaderBar ) GetDecorationLayout ( ) string { c := C . gtk_header_bar_get_decoration_layout ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * HeaderBar ) SetDecorationLayout ( layout string ) { cstr := C . CString ( layout ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_header_bar_set_decoration_layout ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * HeaderBar ) GetHasSubtitle ( ) bool { c := C . gtk_header_bar_get_has_subtitle ( v . native ( ) ) return gobool ( c ) } 
func ( v * HeaderBar ) SetHasSubtitle ( setting bool ) { C . gtk_header_bar_set_has_subtitle ( v . native ( ) , gbool ( setting ) ) } 
func ( v * MenuButton ) SetPopover ( popover * Popover ) { C . gtk_menu_button_set_popover ( v . native ( ) , popover . toWidget ( ) ) } 
func ( v * MenuButton ) GetPopover ( ) * Popover { c := C . gtk_menu_button_get_popover ( v . native ( ) ) if c == nil { return nil } return wrapPopover ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuButton ) GetUsePopover ( ) bool { c := C . gtk_menu_button_get_use_popover ( v . native ( ) ) return gobool ( c ) } 
func ( v * MenuButton ) SetUsePopover ( setting bool ) { C . gtk_menu_button_set_use_popover ( v . native ( ) , gbool ( setting ) ) } 
func FlowBoxNew ( ) ( * FlowBox , error ) { c := C . gtk_flow_box_new ( ) if c == nil { return nil , nilPtrErr } return wrapFlowBox ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( fb * FlowBox ) Insert ( widget IWidget , position int ) { C . gtk_flow_box_insert ( fb . native ( ) , widget . toWidget ( ) , C . gint ( position ) ) } 
func ( fb * FlowBox ) GetChildAtIndex ( idx int ) * FlowBoxChild { c := C . gtk_flow_box_get_child_at_index ( fb . native ( ) , C . gint ( idx ) ) if c == nil { return nil } return wrapFlowBoxChild ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( fb * FlowBox ) SetHAdjustment ( adjustment * Adjustment ) { C . gtk_flow_box_set_hadjustment ( fb . native ( ) , adjustment . native ( ) ) } 
func ( fb * FlowBox ) SetVAdjustment ( adjustment * Adjustment ) { C . gtk_flow_box_set_vadjustment ( fb . native ( ) , adjustment . native ( ) ) } 
func ( fb * FlowBox ) SetHomogeneous ( homogeneous bool ) { C . gtk_flow_box_set_homogeneous ( fb . native ( ) , gbool ( homogeneous ) ) } 
func ( fb * FlowBox ) GetHomogeneous ( ) bool { c := C . gtk_flow_box_get_homogeneous ( fb . native ( ) ) return gobool ( c ) } 
func ( fb * FlowBox ) SetRowSpacing ( spacing uint ) { C . gtk_flow_box_set_row_spacing ( fb . native ( ) , C . guint ( spacing ) ) } 
func ( fb * FlowBox ) GetRowSpacing ( ) uint { c := C . gtk_flow_box_get_row_spacing ( fb . native ( ) ) return uint ( c ) } 
func ( fb * FlowBox ) SetColumnSpacing ( spacing uint ) { C . gtk_flow_box_set_column_spacing ( fb . native ( ) , C . guint ( spacing ) ) } 
func ( fb * FlowBox ) GetColumnSpacing ( ) uint { c := C . gtk_flow_box_get_column_spacing ( fb . native ( ) ) return uint ( c ) } 
func ( fb * FlowBox ) SetMinChildrenPerLine ( n_children uint ) { C . gtk_flow_box_set_min_children_per_line ( fb . native ( ) , C . guint ( n_children ) ) } 
func ( fb * FlowBox ) GetMinChildrenPerLine ( ) uint { c := C . gtk_flow_box_get_min_children_per_line ( fb . native ( ) ) return uint ( c ) } 
func ( fb * FlowBox ) SetMaxChildrenPerLine ( n_children uint ) { C . gtk_flow_box_set_max_children_per_line ( fb . native ( ) , C . guint ( n_children ) ) } 
func ( fb * FlowBox ) GetMaxChildrenPerLine ( ) uint { c := C . gtk_flow_box_get_max_children_per_line ( fb . native ( ) ) return uint ( c ) } 
func ( fb * FlowBox ) SetActivateOnSingleClick ( single bool ) { C . gtk_flow_box_set_activate_on_single_click ( fb . native ( ) , gbool ( single ) ) } 
func ( fb * FlowBox ) GetActivateOnSingleClick ( ) bool { c := C . gtk_flow_box_get_activate_on_single_click ( fb . native ( ) ) return gobool ( c ) } 
func ( fb * FlowBox ) GetSelectedChildren ( ) ( rv [ ] * FlowBoxChild ) { c := C . gtk_flow_box_get_selected_children ( fb . native ( ) ) if c == nil { return } list := glib . WrapList ( uintptr ( unsafe . Pointer ( c ) ) ) for l := list ; l != nil ; l = l . Next ( ) { o := wrapFlowBoxChild ( glib . Take ( l . Data ( ) . ( unsafe . Pointer ) ) ) rv = append ( rv , o ) } return } 
func ( fb * FlowBox ) SelectChild ( child * FlowBoxChild ) { C . gtk_flow_box_select_child ( fb . native ( ) , child . native ( ) ) } 
func ( fb * FlowBox ) UnselectChild ( child * FlowBoxChild ) { C . gtk_flow_box_unselect_child ( fb . native ( ) , child . native ( ) ) } 
func ( fb * FlowBox ) SetSelectionMode ( mode SelectionMode ) { C . gtk_flow_box_set_selection_mode ( fb . native ( ) , C . GtkSelectionMode ( mode ) ) } 
func ( fb * FlowBox ) GetSelectionMode ( ) SelectionMode { c := C . gtk_flow_box_get_selection_mode ( fb . native ( ) ) return SelectionMode ( c ) } 
func FlowBoxChildNew ( ) ( * FlowBoxChild , error ) { c := C . gtk_flow_box_child_new ( ) if c == nil { return nil , nilPtrErr } return wrapFlowBoxChild ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( fbc * FlowBoxChild ) GetIndex ( ) int { c := C . gtk_flow_box_child_get_index ( fbc . native ( ) ) return int ( c ) } 
func ( fbc * FlowBoxChild ) IsSelected ( ) bool { c := C . gtk_flow_box_child_is_selected ( fbc . native ( ) ) return gobool ( c ) } 
func ( v * Context ) native ( ) * C . cairo_t { if v == nil { return nil } return v . context } 
func Create ( target * Surface ) * Context { c := C . cairo_create ( target . native ( ) ) ctx := wrapContext ( c ) runtime . SetFinalizer ( ctx , ( * Context ) . destroy ) return ctx } 
func ( v * Context ) destroy ( ) { if v . context != nil { C . cairo_destroy ( v . native ( ) ) v . context = nil } } 
func ( v * Context ) Status ( ) Status { c := C . cairo_status ( v . native ( ) ) return Status ( c ) } 
func ( v * Context ) GetTarget ( ) * Surface { c := C . cairo_get_target ( v . native ( ) ) s := wrapSurface ( c ) s . reference ( ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Context ) PushGroupWithContent ( content Content ) { C . cairo_push_group_with_content ( v . native ( ) , C . cairo_content_t ( content ) ) } 
func ( v * Context ) GetGroupTarget ( ) * Surface { c := C . cairo_get_group_target ( v . native ( ) ) s := wrapSurface ( c ) s . reference ( ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Context ) SetSource ( p * Pattern ) { C . cairo_set_source ( v . native ( ) , p . native ( ) ) } 
func ( v * Context ) SetSourceRGB ( red , green , blue float64 ) { C . cairo_set_source_rgb ( v . native ( ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) ) } 
func ( v * Context ) SetSourceRGBA ( red , green , blue , alpha float64 ) { C . cairo_set_source_rgba ( v . native ( ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) } 
func ( v * Context ) SetSourceSurface ( surface * Surface , x , y float64 ) { C . cairo_set_source_surface ( v . native ( ) , surface . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) SetAntialias ( antialias Antialias ) { C . cairo_set_antialias ( v . native ( ) , C . cairo_antialias_t ( antialias ) ) } 
func ( v * Context ) GetAntialias ( ) Antialias { c := C . cairo_get_antialias ( v . native ( ) ) return Antialias ( c ) } 
func ( v * Context ) SetDash ( dashes [ ] float64 , offset float64 ) { header := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & dashes ) ) cdashes := ( * C . double ) ( unsafe . Pointer ( header . Data ) ) C . cairo_set_dash ( v . native ( ) , cdashes , C . int ( header . Len ) , C . double ( offset ) ) } 
func ( v * Context ) GetDashCount ( ) int { c := C . cairo_get_dash_count ( v . native ( ) ) return int ( c ) } 
func ( v * Context ) GetDash ( ) ( dashes [ ] float64 , offset float64 ) { dashCount := v . GetDashCount ( ) cdashes := ( * C . double ) ( C . calloc ( 8 , C . size_t ( dashCount ) ) ) var coffset C . double C . cairo_get_dash ( v . native ( ) , cdashes , & coffset ) header := ( * reflect . SliceHeader ) ( ( unsafe . Pointer ( & dashes ) ) ) header . Data = uintptr ( unsafe . Pointer ( cdashes ) ) header . Len = dashCount header . Cap = dashCount return dashes , float64 ( coffset ) } 
func ( v * Context ) SetFillRule ( fillRule FillRule ) { C . cairo_set_fill_rule ( v . native ( ) , C . cairo_fill_rule_t ( fillRule ) ) } 
func ( v * Context ) GetFillRule ( ) FillRule { c := C . cairo_get_fill_rule ( v . native ( ) ) return FillRule ( c ) } 
func ( v * Context ) SetLineCap ( lineCap LineCap ) { C . cairo_set_line_cap ( v . native ( ) , C . cairo_line_cap_t ( lineCap ) ) } 
func ( v * Context ) GetLineCap ( ) LineCap { c := C . cairo_get_line_cap ( v . native ( ) ) return LineCap ( c ) } 
func ( v * Context ) SetLineJoin ( lineJoin LineJoin ) { C . cairo_set_line_join ( v . native ( ) , C . cairo_line_join_t ( lineJoin ) ) } 
func ( v * Context ) GetLineJoin ( ) LineJoin { c := C . cairo_get_line_join ( v . native ( ) ) return LineJoin ( c ) } 
func ( v * Context ) SetLineWidth ( width float64 ) { C . cairo_set_line_width ( v . native ( ) , C . double ( width ) ) } 
func ( v * Context ) GetLineWidth ( ) float64 { c := C . cairo_get_line_width ( v . native ( ) ) return float64 ( c ) } 
func ( v * Context ) SetMiterLimit ( limit float64 ) { C . cairo_set_miter_limit ( v . native ( ) , C . double ( limit ) ) } 
func ( v * Context ) GetMiterLimit ( ) float64 { c := C . cairo_get_miter_limit ( v . native ( ) ) return float64 ( c ) } 
func ( v * Context ) SetOperator ( op Operator ) { C . cairo_set_operator ( v . native ( ) , C . cairo_operator_t ( op ) ) } 
func ( v * Context ) GetOperator ( ) Operator { c := C . cairo_get_operator ( v . native ( ) ) return Operator ( c ) } 
func ( v * Context ) SetTolerance ( tolerance float64 ) { C . cairo_set_tolerance ( v . native ( ) , C . double ( tolerance ) ) } 
func ( v * Context ) GetTolerance ( ) float64 { c := C . cairo_get_tolerance ( v . native ( ) ) return float64 ( c ) } 
func ( v * Context ) ClipExtents ( ) ( x1 , y1 , x2 , y2 float64 ) { var cx1 , cy1 , cx2 , cy2 C . double C . cairo_clip_extents ( v . native ( ) , & cx1 , & cy1 , & cx2 , & cy2 ) return float64 ( cx1 ) , float64 ( cy1 ) , float64 ( cx2 ) , float64 ( cy2 ) } 
func ( v * Context ) InClip ( x , y float64 ) bool { c := C . cairo_in_clip ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * Context ) Rectangle ( x , y , w , h float64 ) { C . cairo_rectangle ( v . native ( ) , C . double ( x ) , C . double ( y ) , C . double ( w ) , C . double ( h ) ) } 
func ( v * Context ) Arc ( xc , yc , radius , angle1 , angle2 float64 ) { C . cairo_arc ( v . native ( ) , C . double ( xc ) , C . double ( yc ) , C . double ( radius ) , C . double ( angle1 ) , C . double ( angle2 ) ) } 
func ( v * Context ) ArcNegative ( xc , yc , radius , angle1 , angle2 float64 ) { C . cairo_arc_negative ( v . native ( ) , C . double ( xc ) , C . double ( yc ) , C . double ( radius ) , C . double ( angle1 ) , C . double ( angle2 ) ) } 
func ( v * Context ) LineTo ( x , y float64 ) { C . cairo_line_to ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) CurveTo ( x1 , y1 , x2 , y2 , x3 , y3 float64 ) { C . cairo_curve_to ( v . native ( ) , C . double ( x1 ) , C . double ( y1 ) , C . double ( x2 ) , C . double ( y2 ) , C . double ( x3 ) , C . double ( y3 ) ) } 
func ( v * Context ) MoveTo ( x , y float64 ) { C . cairo_move_to ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) GetCurrentPoint ( ) ( x , y float64 ) { C . cairo_get_current_point ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return } 
func ( v * Context ) FillExtents ( ) ( x1 , y1 , x2 , y2 float64 ) { var cx1 , cy1 , cx2 , cy2 C . double C . cairo_fill_extents ( v . native ( ) , & cx1 , & cy1 , & cx2 , & cy2 ) return float64 ( cx1 ) , float64 ( cy1 ) , float64 ( cx2 ) , float64 ( cy2 ) } 
func ( v * Context ) InFill ( x , y float64 ) bool { c := C . cairo_in_fill ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * Context ) MaskSurface ( surface * Surface , surfaceX , surfaceY float64 ) { C . cairo_mask_surface ( v . native ( ) , surface . native ( ) , C . double ( surfaceX ) , C . double ( surfaceY ) ) } 
func ( v * Context ) PaintWithAlpha ( alpha float64 ) { C . cairo_paint_with_alpha ( v . native ( ) , C . double ( alpha ) ) } 
func ( v * Context ) StrokeExtents ( ) ( x1 , y1 , x2 , y2 float64 ) { var cx1 , cy1 , cx2 , cy2 C . double C . cairo_stroke_extents ( v . native ( ) , & cx1 , & cy1 , & cx2 , & cy2 ) return float64 ( cx1 ) , float64 ( cy1 ) , float64 ( cx2 ) , float64 ( cy2 ) } 
func ( v * Context ) InStroke ( x , y float64 ) bool { c := C . cairo_in_stroke ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * TextView ) native ( ) * C . GtkTextView { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTextView ( p ) } 
func TextViewNew ( ) ( * TextView , error ) { c := C . gtk_text_view_new ( ) if c == nil { return nil , nilPtrErr } return wrapTextView ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func TextViewNewWithBuffer ( buf * TextBuffer ) ( * TextView , error ) { cbuf := buf . native ( ) c := C . gtk_text_view_new_with_buffer ( cbuf ) return wrapTextView ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TextView ) GetBuffer ( ) ( * TextBuffer , error ) { c := C . gtk_text_view_get_buffer ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapTextBuffer ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TextView ) SetBuffer ( buffer * TextBuffer ) { C . gtk_text_view_set_buffer ( v . native ( ) , buffer . native ( ) ) } 
func ( v * TextView ) SetEditable ( editable bool ) { C . gtk_text_view_set_editable ( v . native ( ) , gbool ( editable ) ) } 
func ( v * TextView ) GetEditable ( ) bool { c := C . gtk_text_view_get_editable ( v . native ( ) ) return gobool ( c ) } 
func ( v * TextView ) SetWrapMode ( wrapMode WrapMode ) { C . gtk_text_view_set_wrap_mode ( v . native ( ) , C . GtkWrapMode ( wrapMode ) ) } 
func ( v * TextView ) SetCursorVisible ( visible bool ) { C . gtk_text_view_set_cursor_visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * TextView ) GetCursorVisible ( ) bool { c := C . gtk_text_view_get_cursor_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * TextView ) GetOverwrite ( ) bool { c := C . gtk_text_view_get_overwrite ( v . native ( ) ) return gobool ( c ) } 
func ( v * TextView ) SetJustification ( justify Justification ) { C . gtk_text_view_set_justification ( v . native ( ) , C . GtkJustification ( justify ) ) } 
func ( v * TextView ) GetJustification ( ) Justification { c := C . gtk_text_view_get_justification ( v . native ( ) ) return Justification ( c ) } 
func ( v * TextView ) SetAcceptsTab ( acceptsTab bool ) { C . gtk_text_view_set_accepts_tab ( v . native ( ) , gbool ( acceptsTab ) ) } 
func ( v * TextView ) GetAcceptsTab ( ) bool { c := C . gtk_text_view_get_accepts_tab ( v . native ( ) ) return gobool ( c ) } 
func ( v * TextView ) SetPixelsAboveLines ( px int ) { C . gtk_text_view_set_pixels_above_lines ( v . native ( ) , C . gint ( px ) ) } 
func ( v * TextView ) GetPixelsAboveLines ( ) int { c := C . gtk_text_view_get_pixels_above_lines ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetPixelsBelowLines ( px int ) { C . gtk_text_view_set_pixels_below_lines ( v . native ( ) , C . gint ( px ) ) } 
func ( v * TextView ) GetPixelsBelowLines ( ) int { c := C . gtk_text_view_get_pixels_below_lines ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetPixelsInsideWrap ( px int ) { C . gtk_text_view_set_pixels_inside_wrap ( v . native ( ) , C . gint ( px ) ) } 
func ( v * TextView ) GetPixelsInsideWrap ( ) int { c := C . gtk_text_view_get_pixels_inside_wrap ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetLeftMargin ( margin int ) { C . gtk_text_view_set_left_margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * TextView ) GetLeftMargin ( ) int { c := C . gtk_text_view_get_left_margin ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetRightMargin ( margin int ) { C . gtk_text_view_set_right_margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * TextView ) GetRightMargin ( ) int { c := C . gtk_text_view_get_right_margin ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetIndent ( indent int ) { C . gtk_text_view_set_indent ( v . native ( ) , C . gint ( indent ) ) } 
func ( v * TextView ) GetIndent ( ) int { c := C . gtk_text_view_get_indent ( v . native ( ) ) return int ( c ) } 
func ( v * TextView ) SetInputHints ( hints InputHints ) { C . gtk_text_view_set_input_hints ( v . native ( ) , C . GtkInputHints ( hints ) ) } 
func ( v * TextView ) GetInputHints ( ) InputHints { c := C . gtk_text_view_get_input_hints ( v . native ( ) ) return InputHints ( c ) } 
func ( v * TextView ) SetInputPurpose ( purpose InputPurpose ) { C . gtk_text_view_set_input_purpose ( v . native ( ) , C . GtkInputPurpose ( purpose ) ) } 
func ( v * TextView ) GetInputPurpose ( ) InputPurpose { c := C . gtk_text_view_get_input_purpose ( v . native ( ) ) return InputPurpose ( c ) } 
func ( v * TextView ) ScrollToMark ( mark * TextMark , within_margin float64 , use_align bool , xalign , yalign float64 ) { C . gtk_text_view_scroll_to_mark ( v . native ( ) , mark . native ( ) , C . gdouble ( within_margin ) , gbool ( use_align ) , C . gdouble ( xalign ) , C . gdouble ( yalign ) ) } 
func ( v * TextView ) ScrollToIter ( iter * TextIter , within_margin float64 , use_align bool , xalign , yalign float64 ) bool { return gobool ( C . gtk_text_view_scroll_to_iter ( v . native ( ) , iter . native ( ) , C . gdouble ( within_margin ) , gbool ( use_align ) , C . gdouble ( xalign ) , C . gdouble ( yalign ) ) ) } 
func ( v * TextView ) ScrollMarkOnscreen ( mark * TextMark ) { C . gtk_text_view_scroll_mark_onscreen ( v . native ( ) , mark . native ( ) ) } 
func ( v * TextView ) MoveMarkOnscreen ( mark * TextMark ) bool { return gobool ( C . gtk_text_view_move_mark_onscreen ( v . native ( ) , mark . native ( ) ) ) } 
func ( v * TextView ) GetVisibleRect ( ) * gdk . Rectangle { var rect C . GdkRectangle C . gtk_text_view_get_visible_rect ( v . native ( ) , & rect ) return gdk . WrapRectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * TextView ) GetIterLocation ( iter * TextIter ) * gdk . Rectangle { var rect C . GdkRectangle C . gtk_text_view_get_iter_location ( v . native ( ) , iter . native ( ) , & rect ) return gdk . WrapRectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * TextView ) GetCursorLocations ( iter * TextIter ) ( strong , weak * gdk . Rectangle ) { var strongRect , weakRect C . GdkRectangle C . gtk_text_view_get_cursor_locations ( v . native ( ) , iter . native ( ) , & strongRect , & weakRect ) return gdk . WrapRectangle ( uintptr ( unsafe . Pointer ( & strongRect ) ) ) , gdk . WrapRectangle ( uintptr ( unsafe . Pointer ( & weakRect ) ) ) } 
func ( v * TextView ) GetLineAtY ( y int ) ( * TextIter , int ) { var iter TextIter var line_top C . gint iiter := ( C . GtkTextIter ) ( iter ) C . gtk_text_view_get_line_at_y ( v . native ( ) , & iiter , C . gint ( y ) , & line_top ) return & iter , int ( line_top ) } 
func ( v * TextView ) GetLineYrange ( iter * TextIter ) ( y , height int ) { var yx , heightx C . gint C . gtk_text_view_get_line_yrange ( v . native ( ) , iter . native ( ) , & yx , & heightx ) return int ( yx ) , int ( heightx ) } 
func ( v * TextView ) GetIterAtLocation ( x , y int ) * TextIter { var iter C . GtkTextIter C . gtk_text_view_get_iter_at_location ( v . native ( ) , & iter , C . gint ( x ) , C . gint ( y ) ) return ( * TextIter ) ( & iter ) } 
func ( v * TextView ) GetIterAtPosition ( x , y int ) ( * TextIter , int ) { var iter C . GtkTextIter var trailing C . gint C . gtk_text_view_get_iter_at_position ( v . native ( ) , & iter , & trailing , C . gint ( x ) , C . gint ( y ) ) return ( * TextIter ) ( & iter ) , int ( trailing ) } 
func ( v * TextView ) BufferToWindowCoords ( win TextWindowType , buffer_x , buffer_y int ) ( window_x , window_y int ) { var wx , wy C . gint C . gtk_text_view_buffer_to_window_coords ( v . native ( ) , C . GtkTextWindowType ( win ) , C . gint ( buffer_x ) , C . gint ( buffer_y ) , & wx , & wy ) return int ( wx ) , int ( wy ) } 
func ( v * TextView ) WindowToBufferCoords ( win TextWindowType , window_x , window_y int ) ( buffer_x , buffer_y int ) { var bx , by C . gint C . gtk_text_view_window_to_buffer_coords ( v . native ( ) , C . GtkTextWindowType ( win ) , C . gint ( window_x ) , C . gint ( window_y ) , & bx , & by ) return int ( bx ) , int ( by ) } 
func ( v * TextView ) GetWindow ( win TextWindowType ) * gdk . Window { c := C . gtk_text_view_get_window ( v . native ( ) , C . GtkTextWindowType ( win ) ) if c == nil { return nil } return & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * TextView ) GetWindowType ( w * gdk . Window ) TextWindowType { return TextWindowType ( C . gtk_text_view_get_window_type ( v . native ( ) , ( * C . GdkWindow ) ( unsafe . Pointer ( w . Native ( ) ) ) ) ) } 
func ( v * TextView ) SetBorderWindowSize ( tp TextWindowType , size int ) { C . gtk_text_view_set_border_window_size ( v . native ( ) , C . GtkTextWindowType ( tp ) , C . gint ( size ) ) } 
func ( v * TextView ) GetBorderWindowSize ( tp TextWindowType ) int { return int ( C . gtk_text_view_get_border_window_size ( v . native ( ) , C . GtkTextWindowType ( tp ) ) ) } 
func ( v * TextView ) ForwardDisplayLine ( iter * TextIter ) bool { return gobool ( C . gtk_text_view_forward_display_line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * TextView ) BackwardDisplayLine ( iter * TextIter ) bool { return gobool ( C . gtk_text_view_backward_display_line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * TextView ) ForwardDisplayLineEnd ( iter * TextIter ) bool { return gobool ( C . gtk_text_view_forward_display_line_end ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * TextView ) BackwardDisplayLineStart ( iter * TextIter ) bool { return gobool ( C . gtk_text_view_backward_display_line_start ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * TextView ) StartsDisplayLine ( iter * TextIter ) bool { return gobool ( C . gtk_text_view_starts_display_line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * TextView ) MoveVisually ( iter * TextIter , count int ) bool { return gobool ( C . gtk_text_view_move_visually ( v . native ( ) , iter . native ( ) , C . gint ( count ) ) ) } 
func ( v * TextView ) AddChildInWindow ( child IWidget , tp TextWindowType , xpos , ypos int ) { C . gtk_text_view_add_child_in_window ( v . native ( ) , child . toWidget ( ) , C . GtkTextWindowType ( tp ) , C . gint ( xpos ) , C . gint ( ypos ) ) } 
func ( v * TextView ) MoveChild ( child IWidget , xpos , ypos int ) { C . gtk_text_view_move_child ( v . native ( ) , child . toWidget ( ) , C . gint ( xpos ) , C . gint ( ypos ) ) } 
func ( v * TextView ) ImContextFilterKeypress ( event * gdk . EventKey ) bool { return gobool ( C . gtk_text_view_im_context_filter_keypress ( v . native ( ) , ( * C . GdkEventKey ) ( unsafe . Pointer ( event . Native ( ) ) ) ) ) } 
func ( v * TextView ) AddChildAtAnchor ( child IWidget , anchor * TextChildAnchor ) { C . gtk_text_view_add_child_at_anchor ( v . native ( ) , child . toWidget ( ) , anchor . native ( ) ) } 
func ( v * SettingsBackend ) native ( ) * C . GSettingsBackend { if v == nil || v . GObject == nil { return nil } return C . toGSettingsBackend ( unsafe . Pointer ( v . GObject ) ) } 
func KeyfileSettingsBackendNew ( filename , rootPath , rootGroup string ) * SettingsBackend { cstr1 := ( * C . gchar ) ( C . CString ( filename ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( rootPath ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) cstr3 := ( * C . gchar ) ( C . CString ( rootGroup ) ) defer C . free ( unsafe . Pointer ( cstr3 ) ) return wrapSettingsBackend ( wrapObject ( unsafe . Pointer ( C . g_keyfile_settings_backend_new ( cstr1 , cstr2 , cstr3 ) ) ) ) } 
func ( v * Stack ) GetChildByName ( name string ) * Widget { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_stack_get_child_by_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Stack ) GetTransitionRunning ( ) bool { c := C . gtk_stack_get_transition_running ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) GetClip ( ) * Allocation { var clip Allocation C . gtk_widget_get_clip ( v . native ( ) , clip . native ( ) ) return & clip } 
func ( v * Widget ) SetClip ( clip * Allocation ) { C . gtk_widget_set_clip ( v . native ( ) , clip . native ( ) ) } 
func ( v * Color ) Copy ( c * Color ) * Color { w := new ( Color ) w . pangoColor = C . pango_color_copy ( v . native ( ) ) return w } 
func ( v * Color ) Parse ( spec string ) bool { cstr := C . CString ( spec ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . pango_color_parse ( v . native ( ) , ( * C . char ) ( cstr ) ) return gobool ( c ) } 
func ( v * Color ) ToString ( ) string { c := C . pango_color_to_string ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Screen ) GetActiveWindow ( ) ( * Window , error ) { return toWindow ( C . gdk_screen_get_active_window ( v . native ( ) ) ) } 
func ( v * Screen ) GetHeight ( ) int { c := C . gdk_screen_get_height ( v . native ( ) ) return int ( c ) } 
func ( v * Screen ) GetMonitorAtPoint ( x , y int ) int { return int ( C . gdk_screen_get_monitor_at_point ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) ) } 
func ( v * Screen ) GetMonitorAtWindow ( w * Window ) int { return int ( C . gdk_screen_get_monitor_at_window ( v . native ( ) , w . native ( ) ) ) } 
func ( v * Screen ) GetMonitorHeightMM ( m int ) int { return int ( C . gdk_screen_get_monitor_height_mm ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) GetMonitorPlugName ( m int ) ( string , error ) { return toString ( C . gdk_screen_get_monitor_plug_name ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) GetMonitorScaleFactor ( m int ) int { return int ( C . gdk_screen_get_monitor_scale_factor ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) GetMonitorWidthMM ( m int ) int { return int ( C . gdk_screen_get_monitor_width_mm ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) GetWidth ( ) int { c := C . gdk_screen_get_width ( v . native ( ) ) return int ( c ) } 
func ( v * Screen ) MakeDisplayName ( ) ( string , error ) { return toString ( C . gdk_screen_make_display_name ( v . native ( ) ) ) } 
func ( v * VariantType ) String ( ) string { ch := C . g_variant_type_dup_string ( v . native ( ) ) defer C . g_free ( C . gpointer ( ch ) ) return C . GoString ( ( * C . char ) ( ch ) ) } 
func ( v * Application ) native ( ) * C . GtkApplication { if v == nil || v . GObject == nil { return nil } return C . toGtkApplication ( unsafe . Pointer ( v . GObject ) ) } 
func ApplicationNew ( appId string , flags glib . ApplicationFlags ) ( * Application , error ) { cstr := ( * C . gchar ) ( C . CString ( appId ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_application_new ( cstr , C . GApplicationFlags ( flags ) ) if c == nil { return nil , nilPtrErr } return wrapApplication ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Application ) AddWindow ( w * Window ) { C . gtk_application_add_window ( v . native ( ) , w . native ( ) ) } 
func ( v * Application ) RemoveWindow ( w * Window ) { C . gtk_application_remove_window ( v . native ( ) , w . native ( ) ) } 
func ( v * Application ) GetWindowByID ( id uint ) * Window { c := C . gtk_application_get_window_by_id ( v . native ( ) , C . guint ( id ) ) if c == nil { return nil } return wrapWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) GetActiveWindow ( ) * Window { c := C . gtk_application_get_active_window ( v . native ( ) ) if c == nil { return nil } return wrapWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Uninhibit ( cookie uint ) { C . gtk_application_uninhibit ( v . native ( ) , C . guint ( cookie ) ) } 
func ( v * Application ) GetAppMenu ( ) * glib . MenuModel { c := C . gtk_application_get_app_menu ( v . native ( ) ) if c == nil { return nil } return & glib . MenuModel { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Application ) SetAppMenu ( m * glib . MenuModel ) { mptr := ( * C . GMenuModel ) ( unsafe . Pointer ( m . Native ( ) ) ) C . gtk_application_set_app_menu ( v . native ( ) , mptr ) } 
func ( v * Application ) GetMenubar ( ) * glib . MenuModel { c := C . gtk_application_get_menubar ( v . native ( ) ) if c == nil { return nil } return & glib . MenuModel { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Application ) SetMenubar ( m * glib . MenuModel ) { mptr := ( * C . GMenuModel ) ( unsafe . Pointer ( m . Native ( ) ) ) C . gtk_application_set_menubar ( v . native ( ) , mptr ) } 
func ( v * Application ) IsInhibited ( flags ApplicationInhibitFlags ) bool { return gobool ( C . gtk_application_is_inhibited ( v . native ( ) , C . GtkApplicationInhibitFlags ( flags ) ) ) } 
func ( v * Application ) Inhibited ( w * Window , flags ApplicationInhibitFlags , reason string ) uint { cstr1 := ( * C . gchar ) ( C . CString ( reason ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return uint ( C . gtk_application_inhibit ( v . native ( ) , w . native ( ) , C . GtkApplicationInhibitFlags ( flags ) , cstr1 ) ) } 
func ( v * Application ) GetWindows ( ) * glib . List { glist := C . gtk_application_get_windows ( v . native ( ) ) list := glib . WrapList ( uintptr ( unsafe . Pointer ( glist ) ) ) list . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return wrapWindow ( glib . Take ( ptr ) ) } ) runtime . SetFinalizer ( list , func ( l * glib . List ) { l . Free ( ) } ) return list } 
func ( v * Display ) SupportsComposite ( ) bool { c := C . gdk_display_supports_composite ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) IsMaximized ( ) bool { c := C . gtk_window_is_maximized ( v . native ( ) ) return gobool ( c ) } 
func ( v * MenuShell ) native ( ) * C . GtkMenuShell { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuShell ( p ) } 
func ( v * MenuShell ) Append ( child IMenuItem ) { C . gtk_menu_shell_append ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * MenuShell ) Prepend ( child IMenuItem ) { C . gtk_menu_shell_prepend ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * MenuShell ) Insert ( child IMenuItem , position int ) { C . gtk_menu_shell_insert ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func ( v * MenuShell ) SelectItem ( child IMenuItem ) { C . gtk_menu_shell_select_item ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * MenuShell ) SelectFirst ( searchSensitive bool ) { C . gtk_menu_shell_select_first ( v . native ( ) , gbool ( searchSensitive ) ) } 
func ( v * MenuShell ) ActivateItem ( child IMenuItem , forceDeactivate bool ) { C . gtk_menu_shell_activate_item ( v . native ( ) , child . toWidget ( ) , gbool ( forceDeactivate ) ) } 
func ( v * MenuShell ) SetTakeFocus ( takeFocus bool ) { C . gtk_menu_shell_set_take_focus ( v . native ( ) , gbool ( takeFocus ) ) } 
func gbool ( b bool ) C . gboolean { if b { return C . gboolean ( 1 ) } return C . gboolean ( 0 ) } 
func ( v * StyleContext ) native ( ) * C . GtkStyleContext { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStyleContext ( p ) } 
func ( v * Widget ) GetStyleContext ( ) ( * StyleContext , error ) { return fromNativeStyleContext ( C . gtk_widget_get_style_context ( v . native ( ) ) ) } 
func ( v * StyleContext ) GetParent ( ) ( * StyleContext , error ) { return fromNativeStyleContext ( C . gtk_style_context_get_parent ( v . native ( ) ) ) } 
func ( v * StyleContext ) GetProperty ( property string , state StateFlags ) ( interface { } , error ) { cstr := ( * C . gchar ) ( C . CString ( property ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var gval C . GValue C . gtk_style_context_get_property ( v . native ( ) , cstr , C . GtkStateFlags ( state ) , & gval ) val := glib . ValueFromNative ( unsafe . Pointer ( & gval ) ) return val . GoValue ( ) } 
func ( v * StyleContext ) GetStyleProperty ( property string ) ( interface { } , error ) { cstr := ( * C . gchar ) ( C . CString ( property ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var gval C . GValue C . gtk_style_context_get_style_property ( v . native ( ) , cstr , & gval ) val := glib . ValueFromNative ( unsafe . Pointer ( & gval ) ) return val . GoValue ( ) } 
func ( v * StyleContext ) GetScreen ( ) ( * gdk . Screen , error ) { c := C . gtk_style_context_get_screen ( v . native ( ) ) if c == nil { return nil , nilPtrErr } d := & gdk . Screen { glib . Take ( unsafe . Pointer ( c ) ) } return d , nil } 
func ( v * StyleContext ) GetColor ( state StateFlags ) * gdk . RGBA { gdkColor := gdk . NewRGBA ( ) C . gtk_style_context_get_color ( v . native ( ) , C . GtkStateFlags ( state ) , ( * C . GdkRGBA ) ( unsafe . Pointer ( gdkColor . Native ( ) ) ) ) return gdkColor } 
func ( v * StyleContext ) LookupColor ( colorName string ) ( * gdk . RGBA , bool ) { cstr := ( * C . gchar ) ( C . CString ( colorName ) ) defer C . free ( unsafe . Pointer ( cstr ) ) gdkColor := gdk . NewRGBA ( ) ret := C . gtk_style_context_lookup_color ( v . native ( ) , cstr , ( * C . GdkRGBA ) ( unsafe . Pointer ( gdkColor . Native ( ) ) ) ) return gdkColor , gobool ( ret ) } 
func StyleContextResetWidgets ( v * gdk . Screen ) { C . gtk_style_context_reset_widgets ( ( * C . GdkScreen ) ( unsafe . Pointer ( v . Native ( ) ) ) ) } 
func ( v * StyleContext ) SetParent ( p * StyleContext ) { C . gtk_style_context_set_parent ( v . native ( ) , p . native ( ) ) } 
func ( v * StyleContext ) HasClass ( className string ) bool { cstr := C . CString ( className ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gtk_style_context_has_class ( v . native ( ) , ( * C . gchar ) ( cstr ) ) ) } 
func ( v * StyleContext ) SetScreen ( s * gdk . Screen ) { C . gtk_style_context_set_screen ( v . native ( ) , ( * C . GdkScreen ) ( unsafe . Pointer ( s . Native ( ) ) ) ) } 
func ( v * StyleContext ) SetState ( state StateFlags ) { C . gtk_style_context_set_state ( v . native ( ) , C . GtkStateFlags ( state ) ) } 
func ( v * StyleContext ) AddProvider ( provider IStyleProvider , prio uint ) { C . gtk_style_context_add_provider ( v . native ( ) , provider . toStyleProvider ( ) , C . guint ( prio ) ) } 
func AddProviderForScreen ( s * gdk . Screen , provider IStyleProvider , prio uint ) { C . gtk_style_context_add_provider_for_screen ( ( * C . GdkScreen ) ( unsafe . Pointer ( s . Native ( ) ) ) , provider . toStyleProvider ( ) , C . guint ( prio ) ) } 
func ( v * StyleContext ) RemoveProvider ( provider IStyleProvider ) { C . gtk_style_context_remove_provider ( v . native ( ) , provider . toStyleProvider ( ) ) } 
func RemoveProviderForScreen ( s * gdk . Screen , provider IStyleProvider ) { C . gtk_style_context_remove_provider_for_screen ( ( * C . GdkScreen ) ( unsafe . Pointer ( s . Native ( ) ) ) , provider . toStyleProvider ( ) ) } 
func NewMatrix ( xx , yx , xy , yy , x0 , y0 float64 ) * Matrix { return & Matrix { Xx : xx , Yx : yx , Xy : xy , Yy : yy , X0 : x0 , Y0 : y0 , } } 
func ( m * Matrix ) native ( ) * C . cairo_matrix_t { return ( * C . cairo_matrix_t ) ( unsafe . Pointer ( m ) ) } 
func ( m * Matrix ) InitTranslate ( tx , ty float64 ) { C . cairo_matrix_init_translate ( m . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( m * Matrix ) InitScale ( sx , sy float64 ) { C . cairo_matrix_init_scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( m * Matrix ) InitRotate ( radians float64 ) { C . cairo_matrix_init_rotate ( m . native ( ) , C . double ( radians ) ) } 
func ( m * Matrix ) Translate ( tx , ty float64 ) { C . cairo_matrix_translate ( m . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( m * Matrix ) Scale ( sx , sy float64 ) { C . cairo_matrix_scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( m * Matrix ) Rotate ( radians float64 ) { C . cairo_matrix_rotate ( m . native ( ) , C . double ( radians ) ) } 
func ( m * Matrix ) Multiply ( a , b Matrix ) { C . cairo_matrix_multiply ( m . native ( ) , a . native ( ) , b . native ( ) ) } 
func ( m * Matrix ) TransformDistance ( dx , dy float64 ) ( float64 , float64 ) { C . cairo_matrix_transform_distance ( m . native ( ) , ( * C . double ) ( unsafe . Pointer ( & dx ) ) , ( * C . double ) ( unsafe . Pointer ( & dy ) ) ) return dx , dy } 
func ( m * Matrix ) TransformPoint ( x , y float64 ) ( float64 , float64 ) { C . cairo_matrix_transform_point ( m . native ( ) , ( * C . double ) ( unsafe . Pointer ( & x ) ) , ( * C . double ) ( unsafe . Pointer ( & y ) ) ) return x , y } 
func ( v * Menu ) native ( ) * C . GtkMenu { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenu ( p ) } 
func MenuNew ( ) ( * Menu , error ) { c := C . gtk_menu_new ( ) if c == nil { return nil , nilPtrErr } return wrapMenu ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Menu ) ReorderChild ( child IWidget , position int ) { C . gtk_menu_reorder_child ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func PageSetupNew ( ) ( * PageSetup , error ) { c := C . gtk_page_setup_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPageSetup ( obj ) , nil } 
func ( ps * PageSetup ) Copy ( ) ( * PageSetup , error ) { c := C . gtk_page_setup_copy ( ps . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPageSetup ( obj ) , nil } 
func ( ps * PageSetup ) GetOrientation ( ) PageOrientation { c := C . gtk_page_setup_get_orientation ( ps . native ( ) ) return PageOrientation ( c ) } 
func ( ps * PageSetup ) SetOrientation ( orientation PageOrientation ) { C . gtk_page_setup_set_orientation ( ps . native ( ) , C . GtkPageOrientation ( orientation ) ) } 
func ( ps * PageSetup ) GetPaperSize ( ) * PaperSize { c := C . gtk_page_setup_get_paper_size ( ps . native ( ) ) p := & PaperSize { c } runtime . SetFinalizer ( p , ( * PaperSize ) . free ) return p } 
func ( ps * PageSetup ) SetPaperSize ( size * PaperSize ) { C . gtk_page_setup_set_paper_size ( ps . native ( ) , size . native ( ) ) } 
func ( ps * PageSetup ) GetTopMargin ( unit Unit ) float64 { c := C . gtk_page_setup_get_top_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) SetTopMargin ( margin float64 , unit Unit ) { C . gtk_page_setup_set_top_margin ( ps . native ( ) , C . gdouble ( margin ) , C . GtkUnit ( unit ) ) } 
func ( ps * PageSetup ) GetBottomMargin ( unit Unit ) float64 { c := C . gtk_page_setup_get_bottom_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) SetBottomMargin ( margin float64 , unit Unit ) { C . gtk_page_setup_set_bottom_margin ( ps . native ( ) , C . gdouble ( margin ) , C . GtkUnit ( unit ) ) } 
func ( ps * PageSetup ) GetLeftMargin ( unit Unit ) float64 { c := C . gtk_page_setup_get_left_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) SetLeftMargin ( margin float64 , unit Unit ) { C . gtk_page_setup_set_left_margin ( ps . native ( ) , C . gdouble ( margin ) , C . GtkUnit ( unit ) ) } 
func ( ps * PageSetup ) GetRightMargin ( unit Unit ) float64 { c := C . gtk_page_setup_get_right_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) SetRightMargin ( margin float64 , unit Unit ) { C . gtk_page_setup_set_right_margin ( ps . native ( ) , C . gdouble ( margin ) , C . GtkUnit ( unit ) ) } 
func ( ps * PageSetup ) SetPaperSizeAndDefaultMargins ( size * PaperSize ) { C . gtk_page_setup_set_paper_size_and_default_margins ( ps . native ( ) , size . native ( ) ) } 
func ( ps * PageSetup ) GetPaperWidth ( unit Unit ) float64 { c := C . gtk_page_setup_get_paper_width ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) GetPaperHeight ( unit Unit ) float64 { c := C . gtk_page_setup_get_paper_height ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) GetPageWidth ( unit Unit ) float64 { c := C . gtk_page_setup_get_page_width ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PageSetup ) GetPageHeight ( unit Unit ) float64 { c := C . gtk_page_setup_get_page_height ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func PageSetupNewFromFile ( fileName string ) ( * PageSetup , error ) { cstr := C . CString ( fileName ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c := C . gtk_page_setup_new_from_file ( ( * C . gchar ) ( cstr ) , & err ) if c == nil { defer C . g_error_free ( err ) return nil , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } obj := glib . Take ( unsafe . Pointer ( c ) ) return & PageSetup { obj } , nil } 
func ( ps * PageSetup ) PageSetupToFile ( name string ) error { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res := C . gtk_page_setup_to_file ( ps . native ( ) , cstr , & err ) if ! gobool ( res ) { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( ps * PaperSize ) native ( ) * C . GtkPaperSize { if ps == nil { return nil } return ps . GtkPaperSize } 
func PaperSizeNew ( name string ) ( * PaperSize , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var gName * C . gchar if name == " " { gName = nil } else { gName = ( * C . gchar ) ( cstr ) } c := C . gtk_paper_size_new ( gName ) if c == nil { return nil , nilPtrErr } t := & PaperSize { c } runtime . SetFinalizer ( t , ( * PaperSize ) . free ) return t , nil } 
func PaperSizeNewFromPPD ( name , displayName string , width , height float64 ) ( * PaperSize , error ) { cName := C . CString ( name ) defer C . free ( unsafe . Pointer ( cName ) ) cDisplayName := C . CString ( displayName ) defer C . free ( unsafe . Pointer ( cDisplayName ) ) c := C . gtk_paper_size_new_from_ppd ( ( * C . gchar ) ( cName ) , ( * C . gchar ) ( cDisplayName ) , C . gdouble ( width ) , C . gdouble ( height ) ) if c == nil { return nil , nilPtrErr } t := & PaperSize { c } runtime . SetFinalizer ( t , ( * PaperSize ) . free ) return t , nil } 
func PaperSizeNewCustom ( name , displayName string , width , height float64 , unit Unit ) ( * PaperSize , error ) { cName := C . CString ( name ) defer C . free ( unsafe . Pointer ( cName ) ) cDisplayName := C . CString ( displayName ) defer C . free ( unsafe . Pointer ( cDisplayName ) ) c := C . gtk_paper_size_new_custom ( ( * C . gchar ) ( cName ) , ( * C . gchar ) ( cDisplayName ) , C . gdouble ( width ) , C . gdouble ( height ) , C . GtkUnit ( unit ) ) if c == nil { return nil , nilPtrErr } t := & PaperSize { c } runtime . SetFinalizer ( t , ( * PaperSize ) . free ) return t , nil } 
func ( ps * PaperSize ) Copy ( ) ( * PaperSize , error ) { c := C . gtk_paper_size_copy ( ps . native ( ) ) if c == nil { return nil , nilPtrErr } t := & PaperSize { c } runtime . SetFinalizer ( t , ( * PaperSize ) . free ) return t , nil } 
func ( ps * PaperSize ) IsEqual ( other * PaperSize ) bool { c := C . gtk_paper_size_is_equal ( ps . native ( ) , other . native ( ) ) return gobool ( c ) } 
func PaperSizeGetPaperSizes ( includeCustom bool ) * glib . List { clist := C . gtk_paper_size_get_paper_sizes ( gbool ( includeCustom ) ) if clist == nil { return nil } glist := glib . WrapList ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return & PaperSize { ( * C . GtkPaperSize ) ( ptr ) } } ) runtime . SetFinalizer ( glist , func ( glist * glib . List ) { glist . FreeFull ( func ( item interface { } ) { ps := item . ( * PaperSize ) C . gtk_paper_size_free ( ps . GtkPaperSize ) } ) } ) return glist } 
func ( ps * PaperSize ) GetName ( ) string { c := C . gtk_paper_size_get_name ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PaperSize ) GetDisplayName ( ) string { c := C . gtk_paper_size_get_display_name ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PaperSize ) GetPPDName ( ) ( string , error ) { c := C . gtk_paper_size_get_ppd_name ( ps . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( ps * PaperSize ) GetWidth ( unit Unit ) float64 { c := C . gtk_paper_size_get_width ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PaperSize ) IsCustom ( ) bool { c := C . gtk_paper_size_is_custom ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * PaperSize ) SetSize ( width , height float64 , unit Unit ) { C . gtk_paper_size_set_size ( ps . native ( ) , C . gdouble ( width ) , C . gdouble ( height ) , C . GtkUnit ( unit ) ) } 
func ( ps * PaperSize ) GetDefaultTopMargin ( unit Unit ) float64 { c := C . gtk_paper_size_get_default_top_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PaperSize ) GetDefaultBottomMargin ( unit Unit ) float64 { c := C . gtk_paper_size_get_default_bottom_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PaperSize ) GetDefaultLeftMargin ( unit Unit ) float64 { c := C . gtk_paper_size_get_default_left_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PaperSize ) GetDefaultRightMargin ( unit Unit ) float64 { c := C . gtk_paper_size_get_default_right_margin ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func PaperSizeGetDefaultRightMargin ( unit Unit ) string { c := C . gtk_paper_size_get_default ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( pc * PrintContext ) native ( ) * C . GtkPrintContext { if pc == nil || pc . GObject == nil { return nil } p := unsafe . Pointer ( pc . GObject ) return C . toGtkPrintContext ( p ) } 
func ( pc * PrintContext ) GetCairoContext ( ) * cairo . Context { c := C . gtk_print_context_get_cairo_context ( pc . native ( ) ) return cairo . WrapContext ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * PrintContext ) SetCairoContext ( cr * cairo . Context , dpiX , dpiY float64 ) { C . gtk_print_context_set_cairo_context ( pc . native ( ) , ( * C . cairo_t ) ( unsafe . Pointer ( cr . Native ( ) ) ) , C . double ( dpiX ) , C . double ( dpiY ) ) } 
func ( pc * PrintContext ) GetPageSetup ( ) * PageSetup { c := C . gtk_print_context_get_page_setup ( pc . native ( ) ) obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPageSetup ( obj ) } 
func ( pc * PrintContext ) GetWidth ( ) float64 { c := C . gtk_print_context_get_width ( pc . native ( ) ) return float64 ( c ) } 
func ( pc * PrintContext ) GetHeight ( ) float64 { c := C . gtk_print_context_get_height ( pc . native ( ) ) return float64 ( c ) } 
func ( pc * PrintContext ) GetDpiX ( ) float64 { c := C . gtk_print_context_get_dpi_x ( pc . native ( ) ) return float64 ( c ) } 
func ( pc * PrintContext ) GetDpiY ( ) float64 { c := C . gtk_print_context_get_dpi_y ( pc . native ( ) ) return float64 ( c ) } 
func ( pc * PrintContext ) GetPangoFontMap ( ) * pango . FontMap { c := C . gtk_print_context_get_pango_fontmap ( pc . native ( ) ) return pango . WrapFontMap ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * PrintContext ) CreatePangoContext ( ) * pango . Context { c := C . gtk_print_context_create_pango_context ( pc . native ( ) ) return pango . WrapContext ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * PrintContext ) CreatePangoLayout ( ) * pango . Layout { c := C . gtk_print_context_create_pango_layout ( pc . native ( ) ) return pango . WrapLayout ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * PrintContext ) GetHardMargins ( ) ( float64 , float64 , float64 , float64 , error ) { var top , bottom , left , right C . gdouble c := C . gtk_print_context_get_hard_margins ( pc . native ( ) , & top , & bottom , & left , & right ) if gobool ( c ) == false { return 0.0 , 0.0 , 0.0 , 0.0 , errors . New ( " " ) } return float64 ( top ) , float64 ( bottom ) , float64 ( left ) , float64 ( right ) , nil } 
func PrintOperationNew ( ) ( * PrintOperation , error ) { c := C . gtk_print_operation_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPrintOperation ( obj ) , nil } 
func ( po * PrintOperation ) PrintOperationSetAllowAsync ( allowSync bool ) { C . gtk_print_operation_set_allow_async ( po . native ( ) , gbool ( allowSync ) ) } 
func ( po * PrintOperation ) PrintOperationGetError ( ) error { var err * C . GError = nil C . gtk_print_operation_get_error ( po . native ( ) , & err ) defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } 
func ( po * PrintOperation ) SetDefaultPageSetup ( ps * PageSetup ) { C . gtk_print_operation_set_default_page_setup ( po . native ( ) , ps . native ( ) ) } 
func ( po * PrintOperation ) GetDefaultPageSetup ( ) ( * PageSetup , error ) { c := C . gtk_print_operation_get_default_page_setup ( po . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPageSetup ( obj ) , nil } 
func ( po * PrintOperation ) SetPrintSettings ( ps * PrintSettings ) { C . gtk_print_operation_set_print_settings ( po . native ( ) , ps . native ( ) ) } 
func ( po * PrintOperation ) GetPrintSettings ( ps * PageSetup ) ( * PrintSettings , error ) { c := C . gtk_print_operation_get_print_settings ( po . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPrintSettings ( obj ) , nil } 
func ( po * PrintOperation ) SetJobName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_operation_set_job_name ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * PrintOperation ) SetNPages ( pages int ) { C . gtk_print_operation_set_n_pages ( po . native ( ) , C . gint ( pages ) ) } 
func ( po * PrintOperation ) GetNPagesToPrint ( ) int { c := C . gtk_print_operation_get_n_pages_to_print ( po . native ( ) ) return int ( c ) } 
func ( po * PrintOperation ) SetCurrentPage ( page int ) { C . gtk_print_operation_set_current_page ( po . native ( ) , C . gint ( page ) ) } 
func ( po * PrintOperation ) SetUseFullPage ( full bool ) { C . gtk_print_operation_set_use_full_page ( po . native ( ) , gbool ( full ) ) } 
func ( po * PrintOperation ) SetUnit ( unit Unit ) { C . gtk_print_operation_set_unit ( po . native ( ) , C . GtkUnit ( unit ) ) } 
func ( po * PrintOperation ) SetExportFilename ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_operation_set_export_filename ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * PrintOperation ) SetShowProgress ( show bool ) { C . gtk_print_operation_set_show_progress ( po . native ( ) , gbool ( show ) ) } 
func ( po * PrintOperation ) SetTrackPrintStatus ( progress bool ) { C . gtk_print_operation_set_track_print_status ( po . native ( ) , gbool ( progress ) ) } 
func ( po * PrintOperation ) SetCustomTabLabel ( label string ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_operation_set_custom_tab_label ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * PrintOperation ) Run ( action PrintOperationAction , parent * Window ) ( PrintOperationResult , error ) { var err * C . GError = nil c := C . gtk_print_operation_run ( po . native ( ) , C . GtkPrintOperationAction ( action ) , parent . native ( ) , & err ) res := PrintOperationResult ( c ) if res == PRINT_OPERATION_RESULT_ERROR { defer C . g_error_free ( err ) return res , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return res , nil } 
func ( po * PrintOperation ) GetStatus ( ) PrintStatus { c := C . gtk_print_operation_get_status ( po . native ( ) ) return PrintStatus ( c ) } 
func ( po * PrintOperation ) GetStatusString ( ) string { c := C . gtk_print_operation_get_status_string ( po . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( po * PrintOperation ) IsFinished ( ) bool { c := C . gtk_print_operation_is_finished ( po . native ( ) ) return gobool ( c ) } 
func ( po * PrintOperation ) SetSupportSelection ( selection bool ) { C . gtk_print_operation_set_support_selection ( po . native ( ) , gbool ( selection ) ) } 
func ( po * PrintOperation ) GetSupportSelection ( ) bool { c := C . gtk_print_operation_get_support_selection ( po . native ( ) ) return gobool ( c ) } 
func ( po * PrintOperation ) SetHasSelection ( selection bool ) { C . gtk_print_operation_set_has_selection ( po . native ( ) , gbool ( selection ) ) } 
func ( po * PrintOperation ) GetHasSelection ( ) bool { c := C . gtk_print_operation_get_has_selection ( po . native ( ) ) return gobool ( c ) } 
func ( po * PrintOperation ) SetEmbedPageSetup ( embed bool ) { C . gtk_print_operation_set_embed_page_setup ( po . native ( ) , gbool ( embed ) ) } 
func ( po * PrintOperation ) GetEmbedPageSetup ( ) bool { c := C . gtk_print_operation_get_embed_page_setup ( po . native ( ) ) return gobool ( c ) } 
func PrintRunPageSetupDialog ( parent * Window , pageSetup * PageSetup , settings * PrintSettings ) * PageSetup { c := C . gtk_print_run_page_setup_dialog ( parent . native ( ) , pageSetup . native ( ) , settings . native ( ) ) obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPageSetup ( obj ) } 
func PrintRunPageSetupDialogAsync ( parent * Window , setup * PageSetup , settings * PrintSettings , cb PageSetupDoneCallback , data uintptr ) { pageSetupDoneCallbackRegistry . Lock ( ) id := pageSetupDoneCallbackRegistry . next pageSetupDoneCallbackRegistry . next ++ pageSetupDoneCallbackRegistry . m [ id ] = pageSetupDoneCallbackData { fn : cb , data : data } pageSetupDoneCallbackRegistry . Unlock ( ) C . _gtk_print_run_page_setup_dialog_async ( parent . native ( ) , setup . native ( ) , settings . native ( ) , C . gpointer ( uintptr ( id ) ) ) } 
func ( v * PrintOperationPreview ) native ( ) * C . GtkPrintOperationPreview { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkPrintOperationPreview ( p ) } 
func ( pop * PrintOperationPreview ) RenderPage ( page int ) { C . gtk_print_operation_preview_render_page ( pop . native ( ) , C . gint ( page ) ) } 
func ( pop * PrintOperationPreview ) IsSelected ( page int ) bool { c := C . gtk_print_operation_preview_is_selected ( pop . native ( ) , C . gint ( page ) ) return gobool ( c ) } 
func PrintSettingsNew ( ) ( * PrintSettings , error ) { c := C . gtk_print_settings_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPrintSettings ( obj ) , nil } 
func ( ps * PrintSettings ) Copy ( ) ( * PrintSettings , error ) { c := C . gtk_print_settings_copy ( ps . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPrintSettings ( obj ) , nil } 
func ( ps * PrintSettings ) HasKey ( key string ) bool { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_has_key ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( ps * PrintSettings ) Get ( key string ) string { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) Set ( key , value string ) { cKey := C . CString ( key ) defer C . free ( unsafe . Pointer ( cKey ) ) cValue := C . CString ( value ) defer C . free ( unsafe . Pointer ( cValue ) ) C . gtk_print_settings_set ( ps . native ( ) , ( * C . gchar ) ( cKey ) , ( * C . gchar ) ( cValue ) ) } 
func ( ps * PrintSettings ) Unset ( key string ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_unset ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) ForEach ( cb PrintSettingsCallback , userData uintptr ) { printSettingsCallbackRegistry . Lock ( ) id := printSettingsCallbackRegistry . next printSettingsCallbackRegistry . next ++ printSettingsCallbackRegistry . m [ id ] = printSettingsCallbackData { fn : cb , userData : userData } printSettingsCallbackRegistry . Unlock ( ) C . _gtk_print_settings_foreach ( ps . native ( ) , C . gpointer ( uintptr ( id ) ) ) } 
func ( ps * PrintSettings ) GetBool ( key string ) bool { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_bool ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( ps * PrintSettings ) SetBool ( key string , value bool ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_bool ( ps . native ( ) , ( * C . gchar ) ( cstr ) , gbool ( value ) ) } 
func ( ps * PrintSettings ) GetDouble ( key string ) float64 { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_double ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) GetDoubleWithDefault ( key string , def float64 ) float64 { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_double_with_default ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( def ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetDouble ( key string , value float64 ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_double ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) ) } 
func ( ps * PrintSettings ) GetLength ( key string , unit Unit ) float64 { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_length ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetLength ( key string , value float64 , unit Unit ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_length ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) , C . GtkUnit ( unit ) ) } 
func ( ps * PrintSettings ) GetInt ( key string ) int { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_int ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return int ( c ) } 
func ( ps * PrintSettings ) GetIntWithDefault ( key string , def int ) int { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_print_settings_get_int_with_default ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( def ) ) return int ( c ) } 
func ( ps * PrintSettings ) SetInt ( key string , value int ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_int ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( value ) ) } 
func ( ps * PrintSettings ) GetPrinter ( ) string { c := C . gtk_print_settings_get_printer ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetPrinter ( printer string ) { cstr := C . CString ( printer ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_printer ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) GetOrientation ( ) PageOrientation { c := C . gtk_print_settings_get_orientation ( ps . native ( ) ) return PageOrientation ( c ) } 
func ( ps * PrintSettings ) SetOrientation ( orientation PageOrientation ) { C . gtk_print_settings_set_orientation ( ps . native ( ) , C . GtkPageOrientation ( orientation ) ) } 
func ( ps * PrintSettings ) GetPaperSize ( ) ( * PaperSize , error ) { c := C . gtk_print_settings_get_paper_size ( ps . native ( ) ) if c == nil { return nil , nilPtrErr } p := & PaperSize { c } runtime . SetFinalizer ( p , ( * PaperSize ) . free ) return p , nil } 
func ( ps * PrintSettings ) SetPaperSize ( size * PaperSize ) { C . gtk_print_settings_set_paper_size ( ps . native ( ) , size . native ( ) ) } 
func ( ps * PrintSettings ) GetPaperWidth ( unit Unit ) float64 { c := C . gtk_print_settings_get_paper_width ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetPaperWidth ( width float64 , unit Unit ) { C . gtk_print_settings_set_paper_width ( ps . native ( ) , C . gdouble ( width ) , C . GtkUnit ( unit ) ) } 
func ( ps * PrintSettings ) GetPaperHeight ( unit Unit ) float64 { c := C . gtk_print_settings_get_paper_height ( ps . native ( ) , C . GtkUnit ( unit ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetPaperHeight ( width float64 , unit Unit ) { C . gtk_print_settings_set_paper_height ( ps . native ( ) , C . gdouble ( width ) , C . GtkUnit ( unit ) ) } 
func ( ps * PrintSettings ) GetUseColor ( ) bool { c := C . gtk_print_settings_get_use_color ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * PrintSettings ) SetUseColor ( color bool ) { C . gtk_print_settings_set_use_color ( ps . native ( ) , gbool ( color ) ) } 
func ( ps * PrintSettings ) GetCollate ( ) bool { c := C . gtk_print_settings_get_collate ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * PrintSettings ) SetCollate ( collate bool ) { C . gtk_print_settings_set_collate ( ps . native ( ) , gbool ( collate ) ) } 
func ( ps * PrintSettings ) GetReverse ( ) bool { c := C . gtk_print_settings_get_reverse ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * PrintSettings ) SetReverse ( reverse bool ) { C . gtk_print_settings_set_reverse ( ps . native ( ) , gbool ( reverse ) ) } 
func ( ps * PrintSettings ) GetDuplex ( ) PrintDuplex { c := C . gtk_print_settings_get_duplex ( ps . native ( ) ) return PrintDuplex ( c ) } 
func ( ps * PrintSettings ) SetDuplex ( duplex PrintDuplex ) { C . gtk_print_settings_set_duplex ( ps . native ( ) , C . GtkPrintDuplex ( duplex ) ) } 
func ( ps * PrintSettings ) GetQuality ( ) PrintQuality { c := C . gtk_print_settings_get_quality ( ps . native ( ) ) return PrintQuality ( c ) } 
func ( ps * PrintSettings ) SetQuality ( quality PrintQuality ) { C . gtk_print_settings_set_quality ( ps . native ( ) , C . GtkPrintQuality ( quality ) ) } 
func ( ps * PrintSettings ) GetNCopies ( ) int { c := C . gtk_print_settings_get_n_copies ( ps . native ( ) ) return int ( c ) } 
func ( ps * PrintSettings ) SetNCopies ( copies int ) { C . gtk_print_settings_set_n_copies ( ps . native ( ) , C . gint ( copies ) ) } 
func ( ps * PrintSettings ) GetNmberUp ( ) int { c := C . gtk_print_settings_get_number_up ( ps . native ( ) ) return int ( c ) } 
func ( ps * PrintSettings ) SetNumberUp ( numberUp int ) { C . gtk_print_settings_set_number_up ( ps . native ( ) , C . gint ( numberUp ) ) } 
func ( ps * PrintSettings ) GetNumberUpLayout ( ) NumberUpLayout { c := C . gtk_print_settings_get_number_up_layout ( ps . native ( ) ) return NumberUpLayout ( c ) } 
func ( ps * PrintSettings ) SetNumberUpLayout ( numberUpLayout NumberUpLayout ) { C . gtk_print_settings_set_number_up_layout ( ps . native ( ) , C . GtkNumberUpLayout ( numberUpLayout ) ) } 
func ( ps * PrintSettings ) GetResolution ( ) int { c := C . gtk_print_settings_get_resolution ( ps . native ( ) ) return int ( c ) } 
func ( ps * PrintSettings ) SetResolution ( resolution int ) { C . gtk_print_settings_set_resolution ( ps . native ( ) , C . gint ( resolution ) ) } 
func ( ps * PrintSettings ) SetResolutionXY ( resolutionX , resolutionY int ) { C . gtk_print_settings_set_resolution_xy ( ps . native ( ) , C . gint ( resolutionX ) , C . gint ( resolutionY ) ) } 
func ( ps * PrintSettings ) GetResolutionX ( ) int { c := C . gtk_print_settings_get_resolution_x ( ps . native ( ) ) return int ( c ) } 
func ( ps * PrintSettings ) GetResolutionY ( ) int { c := C . gtk_print_settings_get_resolution_y ( ps . native ( ) ) return int ( c ) } 
func ( ps * PrintSettings ) GetPrinterLpi ( ) float64 { c := C . gtk_print_settings_get_printer_lpi ( ps . native ( ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetPrinterLpi ( lpi float64 ) { C . gtk_print_settings_set_printer_lpi ( ps . native ( ) , C . gdouble ( lpi ) ) } 
func ( ps * PrintSettings ) GetScale ( ) float64 { c := C . gtk_print_settings_get_scale ( ps . native ( ) ) return float64 ( c ) } 
func ( ps * PrintSettings ) SetScale ( scale float64 ) { C . gtk_print_settings_set_scale ( ps . native ( ) , C . gdouble ( scale ) ) } 
func ( ps * PrintSettings ) GetPrintPages ( ) PrintPages { c := C . gtk_print_settings_get_print_pages ( ps . native ( ) ) return PrintPages ( c ) } 
func ( ps * PrintSettings ) SetPrintPages ( pages PrintPages ) { C . gtk_print_settings_set_print_pages ( ps . native ( ) , C . GtkPrintPages ( pages ) ) } 
func ( ps * PrintSettings ) GetPageSet ( pages PrintPages ) PageSet { c := C . gtk_print_settings_get_page_set ( ps . native ( ) ) return PageSet ( c ) } 
func ( ps * PrintSettings ) SetPageSet ( pageSet PageSet ) { C . gtk_print_settings_set_page_set ( ps . native ( ) , C . GtkPageSet ( pageSet ) ) } 
func ( ps * PrintSettings ) GetDefaultSource ( ) string { c := C . gtk_print_settings_get_default_source ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetSefaultSource ( defaultSource string ) { cstr := C . CString ( defaultSource ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_default_source ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) GetMediaType ( ) string { c := C . gtk_print_settings_get_media_type ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetMediaType ( mediaType string ) { cstr := C . CString ( mediaType ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_media_type ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) GetDither ( ) string { c := C . gtk_print_settings_get_dither ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetDither ( dither string ) { cstr := C . CString ( dither ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_dither ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) GetFinishings ( ) string { c := C . gtk_print_settings_get_finishings ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetFinishings ( dither string ) { cstr := C . CString ( dither ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_finishings ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * PrintSettings ) GetOutputBin ( ) string { c := C . gtk_print_settings_get_output_bin ( ps . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( ps * PrintSettings ) SetOutputBin ( bin string ) { cstr := C . CString ( bin ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_print_settings_set_output_bin ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func PrintSettingsNewFromFile ( name string ) ( * PrintSettings , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c := C . gtk_print_settings_new_from_file ( ( * C . gchar ) ( cstr ) , & err ) if c == nil { defer C . g_error_free ( err ) return nil , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapPrintSettings ( obj ) , nil } 
func ( ps * PrintSettings ) LoadFile ( name string ) error { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c := C . gtk_print_settings_load_file ( ps . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if gobool ( c ) == false { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func substring_match_equal_func ( model * C . GtkTreeModel , column C . gint , key * C . gchar , iter * C . GtkTreeIter , data C . gpointer ) C . gboolean { goModel := & TreeModel { glib . Take ( unsafe . Pointer ( model ) ) } goIter := & TreeIter { ( C . GtkTreeIter ) ( * iter ) } value , err := goModel . GetValue ( goIter , int ( column ) ) if err != nil { return gbool ( true ) } str , _ := value . GetString ( ) if str == " " { return gbool ( true ) } subStr := C . GoString ( ( * C . char ) ( key ) ) res := strings . Contains ( str , subStr ) return gbool ( ! res ) } 
func goBuilderConnect ( builder * C . GtkBuilder , object * C . GObject , signal_name * C . gchar , handler_name * C . gchar , connect_object * C . GObject , flags C . GConnectFlags , user_data C . gpointer ) { builderSignals . Lock ( ) signals , ok := builderSignals . m [ builder ] builderSignals . Unlock ( ) if ! ok { panic ( " " ) } h := C . GoString ( ( * C . char ) ( handler_name ) ) s := C . GoString ( ( * C . char ) ( signal_name ) ) handler , ok := signals [ h ] if ! ok { return } if object == nil { panic ( " " ) } gobj . Connect ( s , handler ) } 
func goPageSetupDone ( setup * C . GtkPageSetup , data C . gpointer ) { id := int ( uintptr ( data ) ) pageSetupDoneCallbackRegistry . Lock ( ) r := pageSetupDoneCallbackRegistry . m [ id ] delete ( pageSetupDoneCallbackRegistry . m , id ) pageSetupDoneCallbackRegistry . Unlock ( ) obj := glib . Take ( unsafe . Pointer ( setup ) ) r . fn ( wrapPageSetup ( obj ) , r . data ) } 
func goPrintSettings ( key * C . gchar , value * C . gchar , userData C . gpointer ) { id := int ( uintptr ( userData ) ) printSettingsCallbackRegistry . Lock ( ) r := printSettingsCallbackRegistry . m [ id ] r . fn ( C . GoString ( ( * C . char ) ( key ) ) , C . GoString ( ( * C . char ) ( value ) ) , r . userData ) } 
func goTreeModelFilterFuncs ( filter * C . GtkTreeModelFilter , iter * C . GtkTreeIter , data C . gpointer ) C . gboolean { id := int ( uintptr ( data ) ) treeModelVisibleFilterFuncRegistry . Lock ( ) r := treeModelVisibleFilterFuncRegistry . m [ id ] treeModelVisibleFilterFuncRegistry . Unlock ( ) goIter := & TreeIter { ( C . GtkTreeIter ) ( * iter ) } return gbool ( r . fn ( wrapTreeModelFilter ( glib . Take ( unsafe . Pointer ( filter ) ) ) , goIter , r . userData ) ) } 
func ( v * Dialog ) GetActionArea ( ) ( * Widget , error ) { c := C . gtk_dialog_get_action_area ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * MessageDialog ) GetImage ( ) ( * Widget , error ) { c := C . gtk_message_dialog_get_image ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * MessageDialog ) SetImage ( image IWidget ) { C . gtk_message_dialog_set_image ( v . native ( ) , image . toWidget ( ) ) } 
func ( v * Widget ) GetMarginLeft ( ) int { c := C . gtk_widget_get_margin_left ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) SetMarginLeft ( margin int ) { C . gtk_widget_set_margin_left ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) GetMarginRight ( ) int { c := C . gtk_widget_get_margin_right ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) SetMarginRight ( margin int ) { C . gtk_widget_set_margin_right ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * GLContext ) native ( ) * C . GdkGLContext { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkGLContext ( p ) } 
func ( v * GLContext ) GetDisplay ( ) ( * Display , error ) { c := C . gdk_gl_context_get_display ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) GetSurface ( ) ( * Window , error ) { c := C . gdk_gl_context_get_window ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Window { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) GetSharedContext ( ) ( * GLContext , error ) { c := C . gdk_gl_context_get_shared_context ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & GLContext { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) GetVersion ( ) ( MajorVersion , MinorVersion ) { var major , minor int C . gdk_gl_context_get_version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return MajorVersion ( major ) , MinorVersion ( minor ) } 
func ( v * GLContext ) GetRequiredVersion ( ) ( MajorVersion , MinorVersion ) { var major , minor int C . gdk_gl_context_get_required_version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return MajorVersion ( major ) , MinorVersion ( minor ) } 
func ( v * GLContext ) SetRequiredVersion ( major , minor int ) { C . gdk_gl_context_set_required_version ( v . native ( ) , ( C . int ) ( major ) , ( C . int ) ( minor ) ) } 
func ( v * GLContext ) SetDebugEnabled ( enabled bool ) { C . gdk_gl_context_set_debug_enabled ( v . native ( ) , gbool ( enabled ) ) } 
func ( v * GLContext ) SetForwardCompatible ( compatible bool ) { C . gdk_gl_context_set_forward_compatible ( v . native ( ) , gbool ( compatible ) ) } 
func ( v * GLContext ) Realize ( ) ( bool , error ) { var err * C . GError r := gobool ( C . gdk_gl_context_realize ( v . native ( ) , & err ) ) if ! r { defer C . g_error_free ( err ) return r , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return r , nil } 
func GetCurrent ( ) ( * GLContext , error ) { c := C . gdk_gl_context_get_current ( ) if c == nil { return nil , nilPtrErr } return & GLContext { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * ButtonBox ) native ( ) * C . GtkButtonBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkButtonBox ( p ) } 
func ButtonBoxNew ( o Orientation ) ( * ButtonBox , error ) { c := C . gtk_button_box_new ( C . GtkOrientation ( o ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapButtonBox ( obj ) , nil } 
func ( v * ButtonBox ) GetLayout ( ) ButtonBoxStyle { c := C . gtk_button_box_get_layout ( v . native ( ) ) return ButtonBoxStyle ( c ) } 
func ( v * ButtonBox ) GetChildSecondary ( child IWidget ) bool { c := C . gtk_button_box_get_child_secondary ( v . native ( ) , child . toWidget ( ) ) return gobool ( c ) } 
func ( v * ButtonBox ) GetChildNonHomogeneous ( child IWidget ) bool { c := C . gtk_button_box_get_child_non_homogeneous ( v . native ( ) , child . toWidget ( ) ) return gobool ( c ) } 
func ( v * ButtonBox ) SetLayout ( style ButtonBoxStyle ) { C . gtk_button_box_set_layout ( v . native ( ) , C . GtkButtonBoxStyle ( style ) ) } 
func ( v * ButtonBox ) SetChildSecondary ( child IWidget , isSecondary bool ) { C . gtk_button_box_set_child_secondary ( v . native ( ) , child . toWidget ( ) , gbool ( isSecondary ) ) } 
func ( v * ButtonBox ) SetChildNonHomogeneous ( child IWidget , nonHomogeneous bool ) { C . gtk_button_box_set_child_non_homogeneous ( v . native ( ) , child . toWidget ( ) , gbool ( nonHomogeneous ) ) } 
func ( t * Tooltip ) native ( ) * C . GtkTooltip { if t == nil || t . GObject == nil { return nil } p := unsafe . Pointer ( t . GObject ) return C . toGtkTooltip ( p ) } 
func ( t * Tooltip ) SetMarkup ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tooltip_set_markup ( t . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( t * Tooltip ) SetText ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tooltip_set_text ( t . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( t * Tooltip ) SetIcon ( pixbuf * gdk . Pixbuf ) { C . gtk_tooltip_set_icon ( t . native ( ) , ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( t * Tooltip ) SetIconFromIconName ( iconName string , size IconSize ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tooltip_set_icon_from_icon_name ( t . native ( ) , ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) } 
func ( t * Tooltip ) SetCustom ( w * Widget ) { C . gtk_tooltip_set_custom ( t . native ( ) , w . native ( ) ) } 
func ( t * Tooltip ) SetTipArea ( rect gdk . Rectangle ) { C . gtk_tooltip_set_tip_area ( t . native ( ) , nativeGdkRectangle ( rect ) ) } 
func ( v * Device ) Grab ( w * Window , ownership GrabOwnership , owner_events bool , event_mask EventMask , cursor * Cursor , time uint32 ) GrabStatus { ret := C . gdk_device_grab ( v . native ( ) , w . native ( ) , C . GdkGrabOwnership ( ownership ) , gbool ( owner_events ) , C . GdkEventMask ( event_mask ) , cursor . native ( ) , C . guint32 ( time ) , ) return GrabStatus ( ret ) } 
func ( v * DeviceManager ) GetClientPointer ( ) ( * Device , error ) { c := C . gdk_device_manager_get_client_pointer ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Device { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * DeviceManager ) ListDevices ( tp DeviceType ) * glib . List { clist := C . gdk_device_manager_list_devices ( v . native ( ) , C . GdkDeviceType ( tp ) ) if clist == nil { return nil } glist . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return & Device { & glib . Object { glib . ToGObject ( ptr ) } } } ) runtime . SetFinalizer ( glist , func ( glist * glib . List ) { glist . Free ( ) } ) return glist } 
func ( v * Device ) Ungrab ( time uint32 ) { C . gdk_device_ungrab ( v . native ( ) , C . guint32 ( time ) ) } 
func ( v * Display ) GetDeviceManager ( ) ( * DeviceManager , error ) { c := C . gdk_display_get_device_manager ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & DeviceManager { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) GetScreen ( screenNum int ) ( * Screen , error ) { c := C . gdk_display_get_screen ( v . native ( ) , C . gint ( screenNum ) ) if c == nil { return nil , nilPtrErr } return & Screen { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Window ) SetTitlebar ( titlebar IWidget ) { C . gtk_window_set_titlebar ( v . native ( ) , titlebar . toWidget ( ) ) } 
func ( v * TextIter ) native ( ) * C . GtkTextIter { if v == nil { return nil } return ( * C . GtkTextIter ) ( v ) } 
func ( v * TextIter ) GetBuffer ( ) * TextBuffer { c := C . gtk_text_iter_get_buffer ( v . native ( ) ) if c == nil { return nil } return wrapTextBuffer ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * TextIter ) GetSlice ( end * TextIter ) string { c := C . gtk_text_iter_get_slice ( v . native ( ) , end . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * TextIter ) GetText ( end * TextIter ) string { c := C . gtk_text_iter_get_text ( v . native ( ) , end . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * TextIter ) GetVisibleSlice ( end * TextIter ) string { c := C . gtk_text_iter_get_visible_slice ( v . native ( ) , end . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * TextIter ) GetVisibleText ( end * TextIter ) string { c := C . gtk_text_iter_get_visible_text ( v . native ( ) , end . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * TextIter ) EndsTag ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_ends_tag ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) TogglesTag ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_toggles_tag ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) HasTag ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_has_tag ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) Editable ( v1 bool ) bool { return gobool ( C . gtk_text_iter_editable ( v . native ( ) , gbool ( v1 ) ) ) } 
func ( v * TextIter ) CanInsert ( v1 bool ) bool { return gobool ( C . gtk_text_iter_can_insert ( v . native ( ) , gbool ( v1 ) ) ) } 
func ( v * TextIter ) ForwardChars ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_chars ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) BackwardChars ( v1 int ) bool { return gobool ( C . gtk_text_iter_backward_chars ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardLines ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_lines ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) BackwardLines ( v1 int ) bool { return gobool ( C . gtk_text_iter_backward_lines ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardWordEnds ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_word_ends ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardCursorPositions ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_cursor_positions ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) BackwardCursorPositions ( v1 int ) bool { return gobool ( C . gtk_text_iter_backward_cursor_positions ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardSentenceEnds ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_sentence_ends ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardVisibleCursorPositions ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_visible_cursor_positions ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) BackwardVisibleCursorPositions ( v1 int ) bool { return gobool ( C . gtk_text_iter_backward_visible_cursor_positions ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) ForwardVisibleLines ( v1 int ) bool { return gobool ( C . gtk_text_iter_forward_visible_lines ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) BackwardVisibleLines ( v1 int ) bool { return gobool ( C . gtk_text_iter_backward_visible_lines ( v . native ( ) , C . gint ( v1 ) ) ) } 
func ( v * TextIter ) SetOffset ( v1 int ) { C . gtk_text_iter_set_offset ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) SetLine ( v1 int ) { C . gtk_text_iter_set_line ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) SetLineOffset ( v1 int ) { C . gtk_text_iter_set_line_offset ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) SetLineIndex ( v1 int ) { C . gtk_text_iter_set_line_index ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) SetVisibleLineOffset ( v1 int ) { C . gtk_text_iter_set_visible_line_offset ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) SetVisibleLineIndex ( v1 int ) { C . gtk_text_iter_set_visible_line_index ( v . native ( ) , C . gint ( v1 ) ) } 
func ( v * TextIter ) ForwardToTagToggle ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_forward_to_tag_toggle ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) BackwardToTagToggle ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_backward_to_tag_toggle ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) Equal ( v1 * TextIter ) bool { return gobool ( C . gtk_text_iter_equal ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) Compare ( v1 * TextIter ) int { return int ( C . gtk_text_iter_compare ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * TextIter ) InRange ( v1 * TextIter , v2 * TextIter ) bool { return gobool ( C . gtk_text_iter_in_range ( v . native ( ) , v1 . native ( ) , v2 . native ( ) ) ) } 
func ( v * MainContext ) native ( ) * C . GMainContext { if v == nil { return nil } return ( * C . GMainContext ) ( v ) } 
func MainContextDefault ( ) * MainContext { c := C . g_main_context_default ( ) if c == nil { return nil } return ( * MainContext ) ( c ) } 
func ( v * TreeViewColumn ) native ( ) * C . GtkTreeViewColumn { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeViewColumn ( p ) } 
func TreeViewColumnNew ( ) ( * TreeViewColumn , error ) { c := C . gtk_tree_view_column_new ( ) if c == nil { return nil , nilPtrErr } return wrapTreeViewColumn ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func TreeViewColumnNewWithAttribute ( title string , renderer ICellRenderer , attribute string , column int ) ( * TreeViewColumn , error ) { t_cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( t_cstr ) ) a_cstr := C . CString ( attribute ) defer C . free ( unsafe . Pointer ( a_cstr ) ) c := C . _gtk_tree_view_column_new_with_attributes_one ( ( * C . gchar ) ( t_cstr ) , renderer . toCellRenderer ( ) , ( * C . gchar ) ( a_cstr ) , C . gint ( column ) ) if c == nil { return nil , nilPtrErr } return wrapTreeViewColumn ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TreeViewColumn ) AddAttribute ( renderer ICellRenderer , attribute string , column int ) { cstr := C . CString ( attribute ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tree_view_column_add_attribute ( v . native ( ) , renderer . toCellRenderer ( ) , ( * C . gchar ) ( cstr ) , C . gint ( column ) ) } 
func ( v * TreeViewColumn ) SetExpand ( expand bool ) { C . gtk_tree_view_column_set_expand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * TreeViewColumn ) GetExpand ( ) bool { c := C . gtk_tree_view_column_get_expand ( v . native ( ) ) return gobool ( c ) } 
func ( v * TreeViewColumn ) SetMinWidth ( minWidth int ) { C . gtk_tree_view_column_set_min_width ( v . native ( ) , C . gint ( minWidth ) ) } 
func ( v * TreeViewColumn ) GetMinWidth ( ) int { c := C . gtk_tree_view_column_get_min_width ( v . native ( ) ) return int ( c ) } 
func ( v * TreeViewColumn ) PackStart ( cell ICellRenderer , expand bool ) { C . gtk_tree_view_column_pack_start ( v . native ( ) , cell . toCellRenderer ( ) , gbool ( expand ) ) } 
func ( v * TreeViewColumn ) PackEnd ( cell ICellRenderer , expand bool ) { C . gtk_tree_view_column_pack_end ( v . native ( ) , cell . toCellRenderer ( ) , gbool ( expand ) ) } 
func ( v * TreeViewColumn ) ClearAttributes ( cell * CellRenderer ) { C . gtk_tree_view_column_clear_attributes ( v . native ( ) , cell . native ( ) ) } 
func ( v * TreeViewColumn ) SetSpacing ( spacing int ) { C . gtk_tree_view_column_set_spacing ( v . native ( ) , C . gint ( spacing ) ) } 
func ( v * TreeViewColumn ) SetVisible ( visible bool ) { C . gtk_tree_view_column_set_visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * TreeViewColumn ) SetFixedWidth ( w int ) { C . gtk_tree_view_column_set_fixed_width ( v . native ( ) , C . gint ( w ) ) } 
func ( v * TreeViewColumn ) SetTitle ( t string ) { cstr := ( * C . gchar ) ( C . CString ( t ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tree_view_column_set_title ( v . native ( ) , cstr ) } 
func ( v * TreeViewColumn ) GetTitle ( ) string { return C . GoString ( ( * C . char ) ( C . gtk_tree_view_column_get_title ( v . native ( ) ) ) ) } 
func ( v * TreeViewColumn ) SetReorderable ( reorderable bool ) { C . gtk_tree_view_column_set_reorderable ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * TreeViewColumn ) SetSortIndicator ( reorderable bool ) { C . gtk_tree_view_column_set_sort_indicator ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * TreeViewColumn ) SetSortColumnID ( w int ) { C . gtk_tree_view_column_set_sort_column_id ( v . native ( ) , C . gint ( w ) ) } 
func ( v * TreeViewColumn ) FocusCell ( cell * CellRenderer ) { C . gtk_tree_view_column_focus_cell ( v . native ( ) , cell . native ( ) ) } 
func ( v * TreeViewColumn ) SetSizing ( sizing TreeViewColumnSizing ) { C . gtk_tree_view_column_set_sizing ( v . native ( ) , C . GtkTreeViewColumnSizing ( sizing ) ) } 
func ( v * TreeViewColumn ) SetWidget ( widget IWidget ) { C . gtk_tree_view_column_set_widget ( v . native ( ) , widget . toWidget ( ) ) } 
func ( v * TreeViewColumn ) GetWidget ( ) ( * Widget , error ) { widget := C . gtk_tree_view_column_get_widget ( v . native ( ) ) if widget == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( widget ) ) return wrapWidget ( obj ) , nil } 
func ( v * TreeViewColumn ) SetSortOrder ( order SortType ) { C . gtk_tree_view_column_set_sort_order ( v . native ( ) , C . GtkSortType ( order ) ) } 
func ( v * VariantIter ) native ( ) * C . GVariantIter { if v == nil || v . GVariantIter == nil { return nil } p := unsafe . Pointer ( v . GVariantIter ) return C . toGVariantIter ( p ) } 
func ( v * SList ) Next ( ) * SList { n := v . native ( ) if n == nil { return nil } return wrapSList ( n . next ) } 
func ( v * SList ) Foreach ( fn func ( ptr unsafe . Pointer ) ) { for l := v ; l != nil ; l = l . Next ( ) { fn ( unsafe . Pointer ( l . native ( ) . data ) ) } } 
func ( v * SList ) Free ( ) { C . g_slist_free ( v . native ( ) ) v . list = nil } 
func ( v * SList ) FreeFull ( ) { v . list = nil } 
func ( v * Application ) GetAccelsForAction ( act string ) [ ] string { cstr1 := ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) var descs [ ] string c := C . gtk_application_get_accels_for_action ( v . native ( ) , cstr1 ) originalc := c defer C . g_strfreev ( originalc ) for * c != nil { descs = append ( descs , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return descs } 
func ( v * Application ) SetAccelsForAction ( act string , accels [ ] string ) { cstr1 := ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) caccels := C . make_strings ( C . int ( len ( accels ) + 1 ) ) defer C . destroy_strings ( caccels ) for i , accel := range accels { cstr := C . CString ( accel ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set_string ( caccels , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set_string ( caccels , C . int ( len ( accels ) ) , nil ) C . gtk_application_set_accels_for_action ( v . native ( ) , cstr1 , caccels ) } 
func ( v * Application ) ListActionDescriptions ( ) [ ] string { var descs [ ] string c := C . gtk_application_list_action_descriptions ( v . native ( ) ) originalc := c defer C . g_strfreev ( originalc ) for * c != nil { descs = append ( descs , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return descs } 
func ( v * Settings ) native ( ) * C . GSettings { if v == nil || v . GObject == nil { return nil } return C . toGSettings ( unsafe . Pointer ( v . GObject ) ) } 
func SettingsNew ( schemaID string ) * Settings { cstr := ( * C . gchar ) ( C . CString ( schemaID ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrapFullSettings ( C . g_settings_new ( cstr ) ) } 
func SettingsNewWithPath ( schemaID , path string ) * Settings { cstr1 := ( * C . gchar ) ( C . CString ( schemaID ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) return wrapFullSettings ( C . g_settings_new_with_path ( cstr1 , cstr2 ) ) } 
func SettingsNewWithBackend ( schemaID string , backend * SettingsBackend ) * Settings { cstr1 := ( * C . gchar ) ( C . CString ( schemaID ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return wrapFullSettings ( C . g_settings_new_with_backend ( cstr1 , backend . native ( ) ) ) } 
func SettingsNewWithBackendAndPath ( schemaID string , backend * SettingsBackend , path string ) * Settings { cstr1 := ( * C . gchar ) ( C . CString ( schemaID ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) return wrapFullSettings ( C . g_settings_new_with_backend_and_path ( cstr1 , backend . native ( ) , cstr2 ) ) } 
func SettingsNewFull ( schema * SettingsSchema , backend * SettingsBackend , path string ) * Settings { cstr1 := ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return wrapFullSettings ( C . g_settings_new_full ( schema . native ( ) , backend . native ( ) , cstr1 ) ) } 
func ( v * Settings ) IsWritable ( name string ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_is_writable ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) GetChild ( name string ) * Settings { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return wrapFullSettings ( C . g_settings_get_child ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) Reset ( name string ) { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_settings_reset ( v . native ( ) , cstr1 ) } 
func ( v * Settings ) GetBoolean ( name string ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_get_boolean ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) SetBoolean ( name string , value bool ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_set_boolean ( v . native ( ) , cstr1 , gbool ( value ) ) ) } 
func ( v * Settings ) GetInt ( name string ) int { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return int ( C . g_settings_get_int ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) SetInt ( name string , value int ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_set_int ( v . native ( ) , cstr1 , C . gint ( value ) ) ) } 
func ( v * Settings ) GetUInt ( name string ) uint { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return uint ( C . g_settings_get_uint ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) SetUInt ( name string , value uint ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_set_uint ( v . native ( ) , cstr1 , C . guint ( value ) ) ) } 
func ( v * Settings ) GetDouble ( name string ) float64 { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return float64 ( C . g_settings_get_double ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) SetDouble ( name string , value float64 ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return gobool ( C . g_settings_set_double ( v . native ( ) , cstr1 , C . gdouble ( value ) ) ) } 
func ( v * Settings ) GetString ( name string ) string { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return C . GoString ( ( * C . char ) ( C . g_settings_get_string ( v . native ( ) , cstr1 ) ) ) } 
func ( v * Settings ) SetString ( name string , value string ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( value ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) return gobool ( C . g_settings_set_string ( v . native ( ) , cstr1 , cstr2 ) ) } 
func ( v * Settings ) GetEnum ( name string ) int { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return int ( C . g_settings_get_enum ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) GetStrv ( name string ) [ ] string { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return toGoStringArray ( C . g_settings_get_strv ( v . native ( ) , cstr1 ) ) } 
func ( v * Settings ) SetStrv ( name string , values [ ] string ) bool { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cvalues := make ( [ ] * C . gchar , len ( values ) ) for i , accel := range values { cvalues [ i ] = ( * C . gchar ) ( C . CString ( accel ) ) defer C . free ( unsafe . Pointer ( cvalues [ i ] ) ) } cvalues = append ( cvalues , nil ) return gobool ( C . g_settings_set_strv ( v . native ( ) , cstr1 , & cvalues [ 0 ] ) ) } 
func ( v * Settings ) GetFlags ( name string ) uint { cstr1 := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) return uint ( C . g_settings_get_flags ( v . native ( ) , cstr1 ) ) } 
func ( v * ActionMap ) native ( ) * C . GActionMap { if v == nil || v . GObject == nil { return nil } return C . toGActionMap ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * ActionMap ) LookupAction ( actionName string ) * Action { c := C . g_action_map_lookup_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return wrapAction ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * ActionMap ) AddAction ( action IAction ) { C . g_action_map_add_action ( v . native ( ) , action . toGAction ( ) ) } 
func ( v * ActionMap ) RemoveAction ( actionName string ) { C . g_action_map_remove_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) } 
func ( v * Menu ) PopupAtMouseCursor ( parentMenuShell IMenu , parentMenuItem IMenuItem , button int , activateTime uint32 ) { wshell := nullableWidget ( parentMenuShell ) witem := nullableWidget ( parentMenuItem ) C . gtk_menu_popup ( v . native ( ) , wshell , witem , nil , nil , C . guint ( button ) , C . guint32 ( activateTime ) ) } 
func ( v * Window ) SetWMClass ( name , class string ) { cName := C . CString ( name ) defer C . free ( unsafe . Pointer ( cName ) ) cClass := C . CString ( class ) defer C . free ( unsafe . Pointer ( cClass ) ) C . gtk_window_set_wmclass ( v . native ( ) , ( * C . gchar ) ( cName ) , ( * C . gchar ) ( cClass ) ) } 
func ( v * FontButton ) GetFontName ( ) string { c := C . gtk_font_button_get_font_name ( v . native ( ) ) return goString ( c ) } 
func ( v * FontButton ) SetFontName ( fontname string ) bool { cstr := C . CString ( fontname ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_font_button_set_font_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( v * Context ) ShowText ( utf8 string ) { cstr := C . CString ( utf8 ) defer C . free ( unsafe . Pointer ( cstr ) ) C . cairo_show_text ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func CreateImageSurface ( format Format , width , height int ) * Surface { c := C . cairo_image_surface_create ( C . cairo_format_t ( format ) , C . int ( width ) , C . int ( height ) ) s := wrapSurface ( c ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s } 
func CreatePDFSurface ( fileName string , width float64 , height float64 ) ( * Surface , error ) { cstr := C . CString ( fileName ) defer C . free ( unsafe . Pointer ( cstr ) ) surfaceNative := C . cairo_pdf_surface_create ( cstr , C . double ( width ) , C . double ( height ) ) status := Status ( C . cairo_surface_status ( surfaceNative ) ) if status != STATUS_SUCCESS { return nil , ErrorStatus ( status ) } s := wrapSurface ( surfaceNative ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s , nil } 
func ( v * Surface ) native ( ) * C . cairo_surface_t { if v == nil { return nil } return v . surface } 
func NewSurface ( s uintptr , needsRef bool ) * Surface { surface := WrapSurface ( s ) if needsRef { surface . reference ( ) } runtime . SetFinalizer ( surface , ( * Surface ) . destroy ) return surface } 
func ( v * Surface ) CreateSimilar ( content Content , width , height int ) * Surface { c := C . cairo_surface_create_similar ( v . native ( ) , C . cairo_content_t ( content ) , C . int ( width ) , C . int ( height ) ) s := wrapSurface ( c ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Surface ) CreateForRectangle ( x , y , width , height float64 ) * Surface { c := C . cairo_surface_create_for_rectangle ( v . native ( ) , C . double ( x ) , C . double ( y ) , C . double ( width ) , C . double ( height ) ) s := wrapSurface ( c ) runtime . SetFinalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Surface ) destroy ( ) { if v . surface != nil { C . cairo_surface_destroy ( v . native ( ) ) v . surface = nil } } 
func ( v * Surface ) Status ( ) Status { c := C . cairo_surface_status ( v . native ( ) ) return Status ( c ) } 
func ( v * Surface ) MarkDirtyRectangle ( x , y , width , height int ) { C . cairo_surface_mark_dirty_rectangle ( v . native ( ) , C . int ( x ) , C . int ( y ) , C . int ( width ) , C . int ( height ) ) } 
func ( v * Surface ) SetDeviceOffset ( x , y float64 ) { C . cairo_surface_set_device_offset ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Surface ) GetDeviceOffset ( ) ( x , y float64 ) { var xOffset , yOffset C . double C . cairo_surface_get_device_offset ( v . native ( ) , & xOffset , & yOffset ) return float64 ( xOffset ) , float64 ( yOffset ) } 
func ( v * Surface ) SetFallbackResolution ( xPPI , yPPI float64 ) { C . cairo_surface_set_fallback_resolution ( v . native ( ) , C . double ( xPPI ) , C . double ( yPPI ) ) } 
func ( v * Surface ) GetFallbackResolution ( ) ( xPPI , yPPI float64 ) { var x , y C . double C . cairo_surface_get_fallback_resolution ( v . native ( ) , & x , & y ) return float64 ( x ) , float64 ( y ) } 
func ( v * Surface ) GetType ( ) SurfaceType { c := C . cairo_surface_get_type ( v . native ( ) ) return SurfaceType ( c ) } 
func ( v * Surface ) HasShowTextGlyphs ( ) bool { c := C . cairo_surface_has_show_text_glyphs ( v . native ( ) ) return gobool ( c ) } 
func ( v * Surface ) GetMimeData ( mimeType MimeType ) [ ] byte { cstr := C . CString ( string ( mimeType ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var data * C . uchar var length C . ulong C . cairo_surface_get_mime_data ( v . native ( ) , cstr , & data , & length ) return C . GoBytes ( unsafe . Pointer ( data ) , C . int ( length ) ) } 
func ( v * Surface ) WriteToPNG ( fileName string ) error { cstr := C . CString ( fileName ) defer C . free ( unsafe . Pointer ( cstr ) ) status := Status ( C . cairo_surface_write_to_png ( v . surface , cstr ) ) if status != STATUS_SUCCESS { return ErrorStatus ( status ) } return nil } 
func ( v * Surface ) GetData ( ) unsafe . Pointer { return unsafe . Pointer ( C . cairo_image_surface_get_data ( v . surface ) ) } 
func FixedNew ( ) ( * Fixed , error ) { c := C . gtk_fixed_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFixed ( obj ) , nil } 
func ( v * Fixed ) Put ( w IWidget , x , y int ) { C . gtk_fixed_put ( v . native ( ) , w . toWidget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Fixed ) Move ( w IWidget , x , y int ) { C . gtk_fixed_move ( v . native ( ) , w . toWidget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * AboutDialog ) native ( ) * C . GtkAboutDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAboutDialog ( p ) } 
func AboutDialogNew ( ) ( * AboutDialog , error ) { c := C . gtk_about_dialog_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAboutDialog ( obj ) , nil } 
func ( v * AboutDialog ) GetComments ( ) string { c := C . gtk_about_dialog_get_comments ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetComments ( comments string ) { cstr := C . CString ( comments ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_comments ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetCopyright ( ) string { c := C . gtk_about_dialog_get_copyright ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetCopyright ( copyright string ) { cstr := C . CString ( copyright ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_copyright ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetLicense ( ) string { c := C . gtk_about_dialog_get_license ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetLicense ( license string ) { cstr := C . CString ( license ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_license ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetLicenseType ( ) License { c := C . gtk_about_dialog_get_license_type ( v . native ( ) ) return License ( c ) } 
func ( v * AboutDialog ) SetLicenseType ( license License ) { C . gtk_about_dialog_set_license_type ( v . native ( ) , C . GtkLicense ( license ) ) } 
func ( v * AboutDialog ) GetLogo ( ) ( * gdk . Pixbuf , error ) { c := C . gtk_about_dialog_get_logo ( v . native ( ) ) if c == nil { return nil , nilPtrErr } p := & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * AboutDialog ) SetLogo ( logo * gdk . Pixbuf ) { logoPtr := ( * C . GdkPixbuf ) ( unsafe . Pointer ( logo . Native ( ) ) ) C . gtk_about_dialog_set_logo ( v . native ( ) , logoPtr ) } 
func ( v * AboutDialog ) GetLogoIconName ( ) string { c := C . gtk_about_dialog_get_logo_icon_name ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetLogoIconName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_logo_icon_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetProgramName ( ) string { c := C . gtk_about_dialog_get_program_name ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetProgramName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_program_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetAuthors ( ) [ ] string { var authors [ ] string cauthors := C . gtk_about_dialog_get_authors ( v . native ( ) ) if cauthors == nil { return nil } for { if * cauthors == nil { break } authors = append ( authors , C . GoString ( ( * C . char ) ( * cauthors ) ) ) cauthors = C . next_gcharptr ( cauthors ) } return authors } 
func ( v * AboutDialog ) SetAuthors ( authors [ ] string ) { cauthors := C . make_strings ( C . int ( len ( authors ) + 1 ) ) for i , author := range authors { cstr := C . CString ( author ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set_string ( cauthors , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set_string ( cauthors , C . int ( len ( authors ) ) , nil ) C . gtk_about_dialog_set_authors ( v . native ( ) , cauthors ) C . destroy_strings ( cauthors ) } 
func ( v * AboutDialog ) GetArtists ( ) [ ] string { var artists [ ] string cartists := C . gtk_about_dialog_get_artists ( v . native ( ) ) if cartists == nil { return nil } for { if * cartists == nil { break } artists = append ( artists , C . GoString ( ( * C . char ) ( * cartists ) ) ) cartists = C . next_gcharptr ( cartists ) } return artists } 
func ( v * AboutDialog ) SetArtists ( artists [ ] string ) { cartists := C . make_strings ( C . int ( len ( artists ) + 1 ) ) for i , artist := range artists { cstr := C . CString ( artist ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set_string ( cartists , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set_string ( cartists , C . int ( len ( artists ) ) , nil ) C . gtk_about_dialog_set_artists ( v . native ( ) , cartists ) C . destroy_strings ( cartists ) } 
func ( v * AboutDialog ) GetDocumenters ( ) [ ] string { var documenters [ ] string cdocumenters := C . gtk_about_dialog_get_documenters ( v . native ( ) ) if cdocumenters == nil { return nil } for { if * cdocumenters == nil { break } documenters = append ( documenters , C . GoString ( ( * C . char ) ( * cdocumenters ) ) ) cdocumenters = C . next_gcharptr ( cdocumenters ) } return documenters } 
func ( v * AboutDialog ) SetDocumenters ( documenters [ ] string ) { cdocumenters := C . make_strings ( C . int ( len ( documenters ) + 1 ) ) for i , doc := range documenters { cstr := C . CString ( doc ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set_string ( cdocumenters , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set_string ( cdocumenters , C . int ( len ( documenters ) ) , nil ) C . gtk_about_dialog_set_documenters ( v . native ( ) , cdocumenters ) C . destroy_strings ( cdocumenters ) } 
func ( v * AboutDialog ) GetTranslatorCredits ( ) string { c := C . gtk_about_dialog_get_translator_credits ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetTranslatorCredits ( translatorCredits string ) { cstr := C . CString ( translatorCredits ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_translator_credits ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetVersion ( ) string { c := C . gtk_about_dialog_get_version ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetVersion ( version string ) { cstr := C . CString ( version ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_version ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetWebsite ( ) string { c := C . gtk_about_dialog_get_website ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetWebsite ( website string ) { cstr := C . CString ( website ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_website ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) GetWebsiteLabel ( ) string { c := C . gtk_about_dialog_get_website_label ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * AboutDialog ) SetWebsiteLabel ( websiteLabel string ) { cstr := C . CString ( websiteLabel ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_about_dialog_set_website_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * AboutDialog ) SetWrapLicense ( wrapLicense bool ) { C . gtk_about_dialog_set_wrap_license ( v . native ( ) , gbool ( wrapLicense ) ) } 
func ( v * AboutDialog ) AddCreditSection ( sectionName string , people [ ] string ) { cname := ( * C . gchar ) ( C . CString ( sectionName ) ) defer C . free ( unsafe . Pointer ( cname ) ) cpeople := C . make_strings ( C . int ( len ( people ) ) + 1 ) defer C . destroy_strings ( cpeople ) for i , p := range people { cp := ( * C . gchar ) ( C . CString ( p ) ) defer C . free ( unsafe . Pointer ( cp ) ) C . set_string ( cpeople , C . int ( i ) , cp ) } C . set_string ( cpeople , C . int ( len ( people ) ) , nil ) C . gtk_about_dialog_add_credit_section ( v . native ( ) , cname , cpeople ) } 
func AddFont ( fontPath string ) { path := ( * C . uchar ) ( unsafe . Pointer ( C . CString ( fontPath ) ) ) C . addFont ( path ) } 
func marshalFontDescription ( p uintptr ) ( interface { } , error ) { c := C . g_value_get_boxed ( ( * C . GValue ) ( unsafe . Pointer ( p ) ) ) c2 := ( * C . PangoFontDescription ) ( unsafe . Pointer ( c ) ) return wrapFontDescription ( c2 ) , nil } 
func FontDescriptionNew ( ) * FontDescription { c := C . pango_font_description_new ( ) v := new ( FontDescription ) v . pangoFontDescription = c return v } 
func ( v * FontDescription ) Copy ( ) * FontDescription { c := C . pango_font_description_copy ( v . native ( ) ) v2 := new ( FontDescription ) v2 . pangoFontDescription = c return v2 } 
func ( v * FontDescription ) CopyStatic ( ) * FontDescription { c := C . pango_font_description_copy_static ( v . native ( ) ) v2 := new ( FontDescription ) v2 . pangoFontDescription = c return v2 } 
func ( v * FontDescription ) Hash ( ) uint { c := C . pango_font_description_hash ( v . native ( ) ) return uint ( c ) } 
func ( v * FontDescription ) Equal ( v2 * FontDescription ) bool { c := C . pango_font_description_equal ( v . native ( ) , v2 . native ( ) ) return gobool ( c ) } 
func ( v * FontDescription ) SetFamily ( family string ) { cstr := C . CString ( family ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango_font_description_set_family ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * FontDescription ) SetFamilyStatic ( family string ) { cstr := C . CString ( family ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango_font_description_set_family_static ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * FontDescription ) GetFamily ( ) string { c := C . pango_font_description_get_family ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * FontDescription ) SetStyle ( style Style ) { C . pango_font_description_set_style ( v . native ( ) , ( C . PangoStyle ) ( style ) ) } 
func ( v * FontDescription ) GetStyle ( ) Style { c := C . pango_font_description_get_style ( v . native ( ) ) return Style ( c ) } 
func ( v * FontDescription ) SetWeight ( weight Weight ) { C . pango_font_description_set_weight ( v . native ( ) , ( C . PangoWeight ) ( weight ) ) } 
func ( v * FontDescription ) GetWeight ( ) Weight { c := C . pango_font_description_get_weight ( v . native ( ) ) return Weight ( c ) } 
func ( v * FontDescription ) SetStretch ( stretch Stretch ) { C . pango_font_description_set_stretch ( v . native ( ) , ( C . PangoStretch ) ( stretch ) ) } 
func ( v * FontDescription ) GetStretch ( ) Stretch { c := C . pango_font_description_get_stretch ( v . native ( ) ) return Stretch ( c ) } 
func ( v * FontDescription ) SetSize ( size int ) { C . pango_font_description_set_size ( v . native ( ) , ( C . gint ) ( size ) ) } 
func ( v * FontDescription ) GetSize ( ) int { c := C . pango_font_description_get_size ( v . native ( ) ) return int ( c ) } 
func ( v * FontDescription ) SetAbsoluteSize ( size float64 ) { C . pango_font_description_set_absolute_size ( v . native ( ) , ( C . double ) ( size ) ) } 
func ( v * FontDescription ) GetSizeIsAbsolute ( ) bool { c := C . pango_font_description_get_size_is_absolute ( v . native ( ) ) return gobool ( c ) } 
func ( v * FontDescription ) SetGravity ( gravity Gravity ) { C . pango_font_description_set_gravity ( v . native ( ) , ( C . PangoGravity ) ( gravity ) ) } 
func ( v * FontDescription ) GetGravity ( ) Gravity { c := C . pango_font_description_get_gravity ( v . native ( ) ) return Gravity ( c ) } 
func ( v * FontDescription ) GetSetFields ( ) FontMask { c := C . pango_font_description_get_set_fields ( v . native ( ) ) return FontMask ( c ) } 
func ( v * FontDescription ) GetUnsetFields ( to_unset FontMask ) { C . pango_font_description_unset_fields ( v . native ( ) , ( C . PangoFontMask ) ( to_unset ) ) } 
func ( v * FontDescription ) Merge ( desc_to_merge * FontDescription , replace_existing bool ) { C . pango_font_description_merge ( v . native ( ) , desc_to_merge . native ( ) , gbool ( replace_existing ) ) } 
func ( v * FontDescription ) MergeStatic ( desc_to_merge * FontDescription , replace_existing bool ) { C . pango_font_description_merge_static ( v . native ( ) , desc_to_merge . native ( ) , gbool ( replace_existing ) ) } 
func ( v * FontDescription ) BetterMatch ( old_match , new_match * FontDescription ) bool { c := C . pango_font_description_better_match ( v . native ( ) , old_match . native ( ) , new_match . native ( ) ) return gobool ( c ) } 
func FontDescriptionFromString ( str string ) * FontDescription { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . pango_font_description_from_string ( ( * C . char ) ( cstr ) ) v := new ( FontDescription ) v . pangoFontDescription = c return v } 
func ( v * FontDescription ) ToString ( ) string { c := C . pango_font_description_to_string ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * FontDescription ) ToFilename ( ) string { c := C . pango_font_description_to_filename ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Button ) GetFocusOnClick ( ) bool { c := C . gtk_button_get_focus_on_click ( v . native ( ) ) return gobool ( c ) } 
func ( v * TextIter ) BeginsTag ( v1 * TextTag ) bool { return gobool ( C . gtk_text_iter_begins_tag ( v . native ( ) , v1 . native ( ) ) ) } 
func ( v * Window ) ResizeToGeometry ( width , height int ) { C . gtk_window_resize_to_geometry ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Window ) SetDefaultGeometry ( width , height int ) { C . gtk_window_set_default_geometry ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Button ) SetFocusOnClick ( focusOnClick bool ) { C . gtk_button_set_focus_on_click ( v . native ( ) , gbool ( focusOnClick ) ) } 
func ActionBarNew ( ) ( * ActionBar , error ) { c := C . gtk_action_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapActionBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( a * ActionBar ) PackStart ( child IWidget ) { C . gtk_action_bar_pack_start ( a . native ( ) , child . toWidget ( ) ) } 
func ( a * ActionBar ) PackEnd ( child IWidget ) { C . gtk_action_bar_pack_end ( a . native ( ) , child . toWidget ( ) ) } 
func ( a * ActionBar ) SetCenterWidget ( child IWidget ) { if child == nil { C . gtk_action_bar_set_center_widget ( a . native ( ) , nil ) } else { C . gtk_action_bar_set_center_widget ( a . native ( ) , child . toWidget ( ) ) } } 
func ( a * ActionBar ) GetCenterWidget ( ) * Widget { w := C . gtk_action_bar_get_center_widget ( a . native ( ) ) if w == nil { return nil } return & Widget { glib . InitiallyUnowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func ( v * Label ) native ( ) * C . GtkLabel { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLabel ( p ) } 
func ( v * Label ) SetText ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_label_set_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) SetMarkup ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_label_set_markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) SetMarkupWithMnemonic ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_label_set_markup_with_mnemonic ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) SetPattern ( patern string ) { cstr := C . CString ( patern ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_label_set_pattern ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) SetJustify ( jtype Justification ) { C . gtk_label_set_justify ( v . native ( ) , C . GtkJustification ( jtype ) ) } 
func ( v * Label ) SetEllipsize ( mode pango . EllipsizeMode ) { C . gtk_label_set_ellipsize ( v . native ( ) , C . PangoEllipsizeMode ( mode ) ) } 
func ( v * Label ) GetWidthChars ( ) int { c := C . gtk_label_get_width_chars ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) SetWidthChars ( nChars int ) { C . gtk_label_set_width_chars ( v . native ( ) , C . gint ( nChars ) ) } 
func ( v * Label ) GetMaxWidthChars ( ) int { c := C . gtk_label_get_max_width_chars ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) SetMaxWidthChars ( nChars int ) { C . gtk_label_set_max_width_chars ( v . native ( ) , C . gint ( nChars ) ) } 
func ( v * Label ) GetLineWrap ( ) bool { c := C . gtk_label_get_line_wrap ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) SetLineWrap ( wrap bool ) { C . gtk_label_set_line_wrap ( v . native ( ) , gbool ( wrap ) ) } 
func ( v * Label ) SetLineWrapMode ( wrapMode pango . WrapMode ) { C . gtk_label_set_line_wrap_mode ( v . native ( ) , C . PangoWrapMode ( wrapMode ) ) } 
func ( v * Label ) GetSelectable ( ) bool { c := C . gtk_label_get_selectable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) GetText ( ) ( string , error ) { c := C . gtk_label_get_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Label ) GetJustify ( ) Justification { c := C . gtk_label_get_justify ( v . native ( ) ) return Justification ( c ) } 
func ( v * Label ) GetEllipsize ( ) pango . EllipsizeMode { c := C . gtk_label_get_ellipsize ( v . native ( ) ) return pango . EllipsizeMode ( c ) } 
func ( v * Label ) GetCurrentUri ( ) string { c := C . gtk_label_get_current_uri ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Label ) GetTrackVisitedLinks ( ) bool { c := C . gtk_label_get_track_visited_links ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) SetTrackVisitedLinks ( trackLinks bool ) { C . gtk_label_set_track_visited_links ( v . native ( ) , gbool ( trackLinks ) ) } 
func ( v * Label ) GetAngle ( ) float64 { c := C . gtk_label_get_angle ( v . native ( ) ) return float64 ( c ) } 
func ( v * Label ) GetSelectionBounds ( ) ( start , end int , nonEmpty bool ) { var cstart , cend C . gint c := C . gtk_label_get_selection_bounds ( v . native ( ) , & cstart , & cend ) return int ( cstart ) , int ( cend ) , gobool ( c ) } 
func ( v * Label ) GetSingleLineMode ( ) bool { c := C . gtk_label_get_single_line_mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) SetSingleLineMode ( mode bool ) { C . gtk_label_set_single_line_mode ( v . native ( ) , gbool ( mode ) ) } 
func ( v * Label ) GetUseMarkup ( ) bool { c := C . gtk_label_get_use_markup ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) SetUseMarkup ( use bool ) { C . gtk_label_set_use_markup ( v . native ( ) , gbool ( use ) ) } 
func ( v * Label ) GetUseUnderline ( ) bool { c := C . gtk_label_get_use_underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) SetUseUnderline ( use bool ) { C . gtk_label_set_use_underline ( v . native ( ) , gbool ( use ) ) } 
func LabelNewWithMnemonic ( str string ) ( * Label , error ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_label_new_with_mnemonic ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapLabel ( obj ) , nil } 
func ( v * Label ) SelectRegion ( startOffset , endOffset int ) { C . gtk_label_select_region ( v . native ( ) , C . gint ( startOffset ) , C . gint ( endOffset ) ) } 
func ( v * Label ) SetSelectable ( setting bool ) { C . gtk_label_set_selectable ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Label ) SetLabel ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_label_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) GetLabel ( ) string { c := C . gtk_label_get_label ( v . native ( ) ) if c == nil { return " " } return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Label ) SetMnemonicWidget ( widget IWidget ) { C . gtk_label_set_mnemonic_widget ( v . native ( ) , widget . toWidget ( ) ) } 
func goTickCallbacks ( widget * C . GtkWidget , frameClock * C . GdkFrameClock , userData C . gpointer ) C . gboolean { id := int ( uintptr ( userData ) ) tickCallbackRegistry . Lock ( ) r := tickCallbackRegistry . m [ id ] tickCallbackRegistry . Unlock ( ) return gbool ( r . fn ( wrapWidget ( glib . Take ( unsafe . Pointer ( widget ) ) ) , gdk . WrapFrameClock ( unsafe . Pointer ( frameClock ) ) , r . userData , ) ) } 
func ( v * VariantDict ) native ( ) * C . GVariantDict { if v == nil || v . GVariantDict == nil { return nil } p := unsafe . Pointer ( v . GVariantDict ) return C . toGVariantDict ( p ) } 
func ( v * Actionable ) native ( ) * C . GtkActionable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkActionable ( p ) } 
func ( v * Actionable ) SetActionName ( action_name string ) { cstr := C . CString ( action_name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_actionable_set_action_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Actionable ) GetActionName ( ) ( string , error ) { c := C . gtk_actionable_get_action_name ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Actionable ) SetDetailedActionName ( detailed_action_name string ) { cstr := C . CString ( detailed_action_name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_actionable_set_detailed_action_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ButtonNewFromIconName ( iconName string , size IconSize ) ( * Button , error ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_button_new_from_icon_name ( ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) if c == nil { return nil , nilPtrErr } return wrapButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Grid ) RemoveRow ( position int ) { C . gtk_grid_remove_row ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) RemoveColumn ( position int ) { C . gtk_grid_remove_column ( v . native ( ) , C . gint ( position ) ) } 
func ( v * HeaderBar ) native ( ) * C . GtkHeaderBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkHeaderBar ( p ) } 
func HeaderBarNew ( ) ( * HeaderBar , error ) { c := C . gtk_header_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapHeaderBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * HeaderBar ) SetTitle ( title string ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_header_bar_set_title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * HeaderBar ) GetTitle ( ) string { cstr := C . gtk_header_bar_get_title ( v . native ( ) ) return C . GoString ( ( * C . char ) ( cstr ) ) } 
func ( v * HeaderBar ) SetSubtitle ( subtitle string ) { cstr := C . CString ( subtitle ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_header_bar_set_subtitle ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * HeaderBar ) GetSubtitle ( ) string { cstr := C . gtk_header_bar_get_subtitle ( v . native ( ) ) return C . GoString ( ( * C . char ) ( cstr ) ) } 
func ( v * HeaderBar ) SetCustomTitle ( titleWidget IWidget ) { C . gtk_header_bar_set_custom_title ( v . native ( ) , titleWidget . toWidget ( ) ) } 
func ( v * HeaderBar ) GetCustomTitle ( ) ( * Widget , error ) { c := C . gtk_header_bar_get_custom_title ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * HeaderBar ) PackStart ( child IWidget ) { C . gtk_header_bar_pack_start ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * HeaderBar ) PackEnd ( child IWidget ) { C . gtk_header_bar_pack_end ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * HeaderBar ) SetShowCloseButton ( setting bool ) { C . gtk_header_bar_set_show_close_button ( v . native ( ) , gbool ( setting ) ) } 
func ( v * HeaderBar ) GetShowCloseButton ( ) bool { c := C . gtk_header_bar_get_show_close_button ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) GetLines ( ) int { c := C . gtk_label_get_lines ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) SetLines ( lines int ) { C . gtk_label_set_lines ( v . native ( ) , C . gint ( lines ) ) } 
func ( v * ListBox ) native ( ) * C . GtkListBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkListBox ( p ) } 
func ListBoxNew ( ) ( * ListBox , error ) { c := C . gtk_list_box_new ( ) if c == nil { return nil , nilPtrErr } return wrapListBox ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ListBox ) Prepend ( child IWidget ) { C . gtk_list_box_prepend ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * ListBox ) Insert ( child IWidget , position int ) { C . gtk_list_box_insert ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func ( v * ListBox ) SelectRow ( row * ListBoxRow ) { C . gtk_list_box_select_row ( v . native ( ) , row . native ( ) ) } 
func ( v * ListBox ) GetSelectedRow ( ) * ListBoxRow { c := C . gtk_list_box_get_selected_row ( v . native ( ) ) if c == nil { return nil } return wrapListBoxRow ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ListBox ) SetSelectionMode ( mode SelectionMode ) { C . gtk_list_box_set_selection_mode ( v . native ( ) , C . GtkSelectionMode ( mode ) ) } 
func ( v * ListBox ) GetSelectionMode ( ) SelectionMode { c := C . gtk_list_box_get_selection_mode ( v . native ( ) ) return SelectionMode ( c ) } 
func ( v * ListBox ) SetActivateOnSingleClick ( single bool ) { C . gtk_list_box_set_activate_on_single_click ( v . native ( ) , gbool ( single ) ) } 
func ( v * ListBox ) GetActivateOnSingleClick ( ) bool { c := C . gtk_list_box_get_activate_on_single_click ( v . native ( ) ) return gobool ( c ) } 
func ( v * ListBox ) GetAdjustment ( ) * Adjustment { c := C . gtk_list_box_get_adjustment ( v . native ( ) ) obj := glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . InitiallyUnowned { obj } } } 
func ( v * ListBox ) SetAdjustment ( adjustment * Adjustment ) { C . gtk_list_box_set_adjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * ListBox ) SetPlaceholder ( placeholder IWidget ) { C . gtk_list_box_set_placeholder ( v . native ( ) , placeholder . toWidget ( ) ) } 
func ( v * ListBox ) GetRowAtIndex ( index int ) * ListBoxRow { c := C . gtk_list_box_get_row_at_index ( v . native ( ) , C . gint ( index ) ) if c == nil { return nil } return wrapListBoxRow ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ListBox ) GetRowAtY ( y int ) * ListBoxRow { c := C . gtk_list_box_get_row_at_y ( v . native ( ) , C . gint ( y ) ) if c == nil { return nil } return wrapListBoxRow ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ListBox ) DragHighlightRow ( row * ListBoxRow ) { C . gtk_list_box_drag_highlight_row ( v . native ( ) , row . native ( ) ) } 
func ( v * ListBoxRow ) native ( ) * C . GtkListBoxRow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkListBoxRow ( p ) } 
func ( v * ListBoxRow ) GetHeader ( ) * Widget { c := C . gtk_list_box_row_get_header ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ListBoxRow ) SetHeader ( header IWidget ) { C . gtk_list_box_row_set_header ( v . native ( ) , header . toWidget ( ) ) } 
func ( v * ListBoxRow ) GetIndex ( ) int { c := C . gtk_list_box_row_get_index ( v . native ( ) ) return int ( c ) } 
func ( v * Revealer ) native ( ) * C . GtkRevealer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRevealer ( p ) } 
func RevealerNew ( ) ( * Revealer , error ) { c := C . gtk_revealer_new ( ) if c == nil { return nil , nilPtrErr } return wrapRevealer ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Revealer ) GetRevealChild ( ) bool { c := C . gtk_revealer_get_reveal_child ( v . native ( ) ) return gobool ( c ) } 
func ( v * Revealer ) SetRevealChild ( revealChild bool ) { C . gtk_revealer_set_reveal_child ( v . native ( ) , gbool ( revealChild ) ) } 
func ( v * Revealer ) GetChildRevealed ( ) bool { c := C . gtk_revealer_get_child_revealed ( v . native ( ) ) return gobool ( c ) } 
func ( v * Revealer ) GetTransitionDuration ( ) uint { c := C . gtk_revealer_get_transition_duration ( v . native ( ) ) return uint ( c ) } 
func ( v * Revealer ) SetTransitionDuration ( duration uint ) { C . gtk_revealer_set_transition_duration ( v . native ( ) , C . guint ( duration ) ) } 
func ( v * Revealer ) GetTransitionType ( ) RevealerTransitionType { c := C . gtk_revealer_get_transition_type ( v . native ( ) ) return RevealerTransitionType ( c ) } 
func ( v * Revealer ) SetTransitionType ( transition RevealerTransitionType ) { t := C . GtkRevealerTransitionType ( transition ) C . gtk_revealer_set_transition_type ( v . native ( ) , t ) } 
func ( v * SearchBar ) native ( ) * C . GtkSearchBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSearchBar ( p ) } 
func SearchBarNew ( ) ( * SearchBar , error ) { c := C . gtk_search_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapSearchBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SearchBar ) ConnectEntry ( entry IEntry ) { C . gtk_search_bar_connect_entry ( v . native ( ) , entry . toEntry ( ) ) } 
func ( v * SearchBar ) GetSearchMode ( ) bool { c := C . gtk_search_bar_get_search_mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * SearchBar ) SetSearchMode ( searchMode bool ) { C . gtk_search_bar_set_search_mode ( v . native ( ) , gbool ( searchMode ) ) } 
func ( v * SearchBar ) GetShowCloseButton ( ) bool { c := C . gtk_search_bar_get_show_close_button ( v . native ( ) ) return gobool ( c ) } 
func ( v * SearchBar ) SetShowCloseButton ( visible bool ) { C . gtk_search_bar_set_show_close_button ( v . native ( ) , gbool ( visible ) ) } 
func ( v * SearchBar ) HandleEvent ( event * gdk . Event ) { e := ( * C . GdkEvent ) ( unsafe . Pointer ( event . Native ( ) ) ) C . gtk_search_bar_handle_event ( v . native ( ) , e ) } 
func ( v * Stack ) native ( ) * C . GtkStack { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStack ( p ) } 
func StackNew ( ) ( * Stack , error ) { c := C . gtk_stack_new ( ) if c == nil { return nil , nilPtrErr } return wrapStack ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Stack ) AddNamed ( child IWidget , name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_stack_add_named ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Stack ) AddTitled ( child IWidget , name , title string ) { cName := C . CString ( name ) defer C . free ( unsafe . Pointer ( cName ) ) cTitle := C . CString ( title ) defer C . free ( unsafe . Pointer ( cTitle ) ) C . gtk_stack_add_titled ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cName ) , ( * C . gchar ) ( cTitle ) ) } 
func ( v * Stack ) SetVisibleChild ( child IWidget ) { C . gtk_stack_set_visible_child ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Stack ) GetVisibleChild ( ) * Widget { c := C . gtk_stack_get_visible_child ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Stack ) SetVisibleChildName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_stack_set_visible_child_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Stack ) GetVisibleChildName ( ) string { c := C . gtk_stack_get_visible_child_name ( v . native ( ) ) return C . GoString ( ( * C . char ) ( c ) ) } 
func ( v * Stack ) SetVisibleChildFull ( name string , transaction StackTransitionType ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_stack_set_visible_child_full ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . GtkStackTransitionType ( transaction ) ) } 
func ( v * Stack ) SetHomogeneous ( homogeneous bool ) { C . gtk_stack_set_homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Stack ) GetHomogeneous ( ) bool { c := C . gtk_stack_get_homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Stack ) SetTransitionDuration ( duration uint ) { C . gtk_stack_set_transition_duration ( v . native ( ) , C . guint ( duration ) ) } 
func ( v * Stack ) GetTransitionDuration ( ) uint { c := C . gtk_stack_get_transition_duration ( v . native ( ) ) return uint ( c ) } 
func ( v * Stack ) SetTransitionType ( transition StackTransitionType ) { C . gtk_stack_set_transition_type ( v . native ( ) , C . GtkStackTransitionType ( transition ) ) } 
func ( v * Stack ) GetTransitionType ( ) StackTransitionType { c := C . gtk_stack_get_transition_type ( v . native ( ) ) return StackTransitionType ( c ) } 
func BindProperty ( source * Object , sourceProperty string , target * Object , targetProperty string , flags BindingFlags ) * Binding { srcStr := ( * C . gchar ) ( C . CString ( sourceProperty ) ) defer C . free ( unsafe . Pointer ( srcStr ) ) tgtStr := ( * C . gchar ) ( C . CString ( targetProperty ) ) defer C . free ( unsafe . Pointer ( tgtStr ) ) obj := C . g_object_bind_property ( C . gpointer ( source . GObject ) , srcStr , C . gpointer ( target . GObject ) , tgtStr , C . GBindingFlags ( flags ) , ) if obj == nil { return nil } return & Binding { wrapObject ( unsafe . Pointer ( obj ) ) } } 
func ( v * Binding ) GetSource ( ) * Object { obj := C . g_binding_get_source ( v . native ( ) ) if obj == nil { return nil } return wrapObject ( unsafe . Pointer ( obj ) ) } 
func ( v * Binding ) GetSourceProperty ( ) string { s := C . g_binding_get_source_property ( v . native ( ) ) return C . GoString ( ( * C . char ) ( s ) ) } 
func ( v * Binding ) GetTarget ( ) * Object { obj := C . g_binding_get_target ( v . native ( ) ) if obj == nil { return nil } return wrapObject ( unsafe . Pointer ( obj ) ) } 
func ( v * Binding ) GetTargetProperty ( ) string { s := C . g_binding_get_target_property ( v . native ( ) ) return C . GoString ( ( * C . char ) ( s ) ) } 
func ( v * Binding ) GetFlags ( ) BindingFlags { flags := C . g_binding_get_flags ( v . native ( ) ) return BindingFlags ( flags ) } 
func ( v * FontChooser ) native ( ) * C . GtkFontChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFontChooser ( p ) } 
func ( v * FontChooser ) GetFont ( ) string { c := C . gtk_font_chooser_get_font ( v . native ( ) ) return goString ( c ) } 
func ( v * FontChooser ) SetFont ( font string ) { cstr := C . CString ( font ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_font_chooser_set_font ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * FontButton ) native ( ) * C . GtkFontButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFontButton ( p ) } 
func FontButtonNew ( ) ( * FontButton , error ) { c := C . gtk_font_button_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFontButton ( obj ) , nil } 
func FontButtonNewWithFont ( fontname string ) ( * FontButton , error ) { cstr := C . CString ( fontname ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_font_button_new_with_font ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFontButton ( obj ) , nil } 
func ( v * ActionGroup ) native ( ) * C . GActionGroup { if v == nil || v . GObject == nil { return nil } return C . toGActionGroup ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * ActionGroup ) HasAction ( actionName string ) bool { return gobool ( C . g_action_group_has_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) ) } 
func ( v * ActionGroup ) GetActionEnabled ( actionName string ) bool { return gobool ( C . g_action_group_get_action_enabled ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) ) } 
func ( v * ActionGroup ) GetActionParameterType ( actionName string ) * VariantType { c := C . g_action_group_get_action_parameter_type ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) } 
func ( v * ActionGroup ) GetActionStateType ( actionName string ) * VariantType { c := C . g_action_group_get_action_state_type ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) } 
func ( v * ActionGroup ) GetActionState ( actionName string ) * Variant { c := C . g_action_group_get_action_state ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) } 
func ( v * ActionGroup ) GetActionStateHint ( actionName string ) * Variant { c := C . g_action_group_get_action_state_hint ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) } 
func ( v * ActionGroup ) ChangeActionState ( actionName string , value * Variant ) { C . g_action_group_change_action_state ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) , value . native ( ) ) } 
func ( v * ActionGroup ) Activate ( actionName string , parameter * Variant ) { C . g_action_group_activate_action ( v . native ( ) , ( * C . gchar ) ( C . CString ( actionName ) ) , parameter . native ( ) ) } 
func GravityToRotation ( gravity Gravity ) float64 { c := C . pango_gravity_to_rotation ( ( C . PangoGravity ) ( gravity ) ) return float64 ( c ) } 
func ( v * Widget ) native ( ) * C . GtkWidget { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkWidget ( p ) } 
func ( v * Widget ) GetCanFocus ( ) bool { c := C . gtk_widget_get_can_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetCanFocus ( canFocus bool ) { C . gtk_widget_set_can_focus ( v . native ( ) , gbool ( canFocus ) ) } 
func ( v * Widget ) GetCanDefault ( ) bool { c := C . gtk_widget_get_can_default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetCanDefault ( canDefault bool ) { C . gtk_widget_set_can_default ( v . native ( ) , gbool ( canDefault ) ) } 
func ( v * Widget ) GetMapped ( ) bool { c := C . gtk_widget_get_mapped ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetMapped ( mapped bool ) { C . gtk_widget_set_can_focus ( v . native ( ) , gbool ( mapped ) ) } 
func ( v * Widget ) GetRealized ( ) bool { c := C . gtk_widget_get_realized ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetRealized ( realized bool ) { C . gtk_widget_set_realized ( v . native ( ) , gbool ( realized ) ) } 
func ( v * Widget ) GetHasWindow ( ) bool { c := C . gtk_widget_get_has_window ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetHasWindow ( hasWindow bool ) { C . gtk_widget_set_has_window ( v . native ( ) , gbool ( hasWindow ) ) } 
func ( v * Widget ) SetNoShowAll ( noShowAll bool ) { C . gtk_widget_set_no_show_all ( v . native ( ) , gbool ( noShowAll ) ) } 
func ( v * Widget ) GetNoShowAll ( ) bool { c := C . gtk_widget_get_no_show_all ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) QueueDrawArea ( x , y , w , h int ) { C . gtk_widget_queue_draw_area ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , C . gint ( w ) , C . gint ( h ) ) } 
func ( v * Allocation ) native ( ) * C . GtkAllocation { return ( * C . GtkAllocation ) ( unsafe . Pointer ( & v . GdkRectangle ) ) } 
func ( v * Widget ) Event ( event * gdk . Event ) bool { c := C . gtk_widget_event ( v . native ( ) , ( * C . GdkEvent ) ( unsafe . Pointer ( event . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Widget ) SetName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_widget_set_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Widget ) GetName ( ) ( string , error ) { c := C . gtk_widget_get_name ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Widget ) GetSensitive ( ) bool { c := C . gtk_widget_get_sensitive ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) IsSensitive ( ) bool { c := C . gtk_widget_is_sensitive ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetSensitive ( sensitive bool ) { C . gtk_widget_set_sensitive ( v . native ( ) , gbool ( sensitive ) ) } 
func ( v * Widget ) GetVisible ( ) bool { c := C . gtk_widget_get_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetVisible ( visible bool ) { C . gtk_widget_set_visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Widget ) SetParent ( parent IWidget ) { C . gtk_widget_set_parent ( v . native ( ) , parent . toWidget ( ) ) } 
func ( v * Widget ) GetParent ( ) ( * Widget , error ) { c := C . gtk_widget_get_parent ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Widget ) SetSizeRequest ( width , height int ) { C . gtk_widget_set_size_request ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Widget ) SetParentWindow ( parentWindow * gdk . Window ) { C . gtk_widget_set_parent_window ( v . native ( ) , ( * C . GdkWindow ) ( unsafe . Pointer ( parentWindow . Native ( ) ) ) ) } 
func ( v * Widget ) GetParentWindow ( ) ( * gdk . Window , error ) { c := C . gtk_widget_get_parent_window ( v . native ( ) ) if v == nil { return nil , nilPtrErr } w := & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * Widget ) SetEvents ( events int ) { C . gtk_widget_set_events ( v . native ( ) , C . gint ( events ) ) } 
func ( v * Widget ) AddEvents ( events int ) { C . gtk_widget_add_events ( v . native ( ) , C . gint ( events ) ) } 
func ( v * Widget ) HasDefault ( ) bool { c := C . gtk_widget_has_default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) HasFocus ( ) bool { c := C . gtk_widget_has_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) HasVisibleFocus ( ) bool { c := C . gtk_widget_has_visible_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) HasGrab ( ) bool { c := C . gtk_widget_has_grab ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) IsDrawable ( ) bool { c := C . gtk_widget_is_drawable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) IsToplevel ( ) bool { c := C . gtk_widget_is_toplevel ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetDeviceEnabled ( device * gdk . Device , enabled bool ) { C . gtk_widget_set_device_enabled ( v . native ( ) , ( * C . GdkDevice ) ( unsafe . Pointer ( device . Native ( ) ) ) , gbool ( enabled ) ) } 
func ( v * Widget ) GetDeviceEnabled ( device * gdk . Device ) bool { c := C . gtk_widget_get_device_enabled ( v . native ( ) , ( * C . GdkDevice ) ( unsafe . Pointer ( device . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Widget ) GetToplevel ( ) ( * Widget , error ) { c := C . gtk_widget_get_toplevel ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Widget ) GetTooltipText ( ) ( string , error ) { c := C . gtk_widget_get_tooltip_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Widget ) SetTooltipText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_widget_set_tooltip_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Widget ) GetHAlign ( ) Align { c := C . gtk_widget_get_halign ( v . native ( ) ) return Align ( c ) } 
func ( v * Widget ) SetHAlign ( align Align ) { C . gtk_widget_set_halign ( v . native ( ) , C . GtkAlign ( align ) ) } 
func ( v * Widget ) GetVAlign ( ) Align { c := C . gtk_widget_get_valign ( v . native ( ) ) return Align ( c ) } 
func ( v * Widget ) SetVAlign ( align Align ) { C . gtk_widget_set_valign ( v . native ( ) , C . GtkAlign ( align ) ) } 
func ( v * Widget ) GetMarginTop ( ) int { c := C . gtk_widget_get_margin_top ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) SetMarginTop ( margin int ) { C . gtk_widget_set_margin_top ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) GetMarginBottom ( ) int { c := C . gtk_widget_get_margin_bottom ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) SetMarginBottom ( margin int ) { C . gtk_widget_set_margin_bottom ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) GetHExpand ( ) bool { c := C . gtk_widget_get_hexpand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetHExpand ( expand bool ) { C . gtk_widget_set_hexpand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * Widget ) GetVExpand ( ) bool { c := C . gtk_widget_get_vexpand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) SetVExpand ( expand bool ) { C . gtk_widget_set_vexpand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * Widget ) TranslateCoordinates ( dest IWidget , srcX , srcY int ) ( destX , destY int , e error ) { cdest := nullableWidget ( dest ) var cdestX , cdestY C . gint c := C . gtk_widget_translate_coordinates ( v . native ( ) , cdest , C . gint ( srcX ) , C . gint ( srcY ) , & cdestX , & cdestY ) if ! gobool ( c ) { return 0 , 0 , errors . New ( " " ) } return int ( cdestX ) , int ( cdestY ) , nil } 
func ( v * Widget ) SetVisual ( visual * gdk . Visual ) { C . gtk_widget_set_visual ( v . native ( ) , ( * C . GdkVisual ) ( unsafe . Pointer ( visual . Native ( ) ) ) ) } 
func ( v * Widget ) SetAppPaintable ( paintable bool ) { C . gtk_widget_set_app_paintable ( v . native ( ) , gbool ( paintable ) ) } 
func ( v * Widget ) GetAppPaintable ( ) bool { c := C . gtk_widget_get_app_paintable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) GetAllocation ( ) * Allocation { var a Allocation C . gtk_widget_get_allocation ( v . native ( ) , a . native ( ) ) return & a } 
func ( v * Widget ) SetAllocation ( allocation * Allocation ) { C . gtk_widget_set_allocation ( v . native ( ) , allocation . native ( ) ) } 
func ( v * Widget ) SizeAllocate ( allocation * Allocation ) { C . gtk_widget_size_allocate ( v . native ( ) , allocation . native ( ) ) } 
func ( v * Widget ) SetStateFlags ( stateFlags StateFlags , clear bool ) { C . gtk_widget_set_state_flags ( v . native ( ) , C . GtkStateFlags ( stateFlags ) , gbool ( clear ) ) } 
func ( v * Widget ) GetWindow ( ) ( * gdk . Window , error ) { c := C . gtk_widget_get_window ( v . native ( ) ) if c == nil { return nil , nilPtrErr } w := & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * Widget ) GetPreferredHeight ( ) ( int , int ) { var minimum , natural C . gint C . gtk_widget_get_preferred_height ( v . native ( ) , & minimum , & natural ) return int ( minimum ) , int ( natural ) } 
func ( v * Widget ) GetPreferredWidth ( ) ( int , int ) { var minimum , natural C . gint C . gtk_widget_get_preferred_width ( v . native ( ) , & minimum , & natural ) return int ( minimum ) , int ( natural ) } 
func ( v * Widget ) GetScreen ( ) ( * gdk . Screen , error ) { c := C . gtk_widget_get_screen ( v . native ( ) ) if c == nil { return nil , nilPtrErr } s := & gdk . Screen { glib . Take ( unsafe . Pointer ( c ) ) } return s , nil } 
func ( v * GLArea ) native ( ) * C . GtkGLArea { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkGLArea ( p ) } 
func GLAreaNew ( ) ( * GLArea , error ) { c := C . gtk_gl_area_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapGLArea ( obj ) , nil } 
func ( v * GLArea ) GetRequiredVersion ( ) ( MajorVersion , MinorVersion ) { var major , minor int C . gtk_gl_area_get_required_version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return MajorVersion ( major ) , MinorVersion ( minor ) } 
func ( v * GLArea ) SetRequiredVersion ( major , minor int ) { C . gtk_gl_area_set_required_version ( v . native ( ) , ( C . int ) ( major ) , ( C . int ) ( minor ) ) } 
func ( v * GLArea ) SetHasDepthBuffer ( hasDepthBuffer bool ) { C . gtk_gl_area_set_has_depth_buffer ( v . native ( ) , gbool ( hasDepthBuffer ) ) } 
func ( v * GLArea ) SetHasStencilBuffer ( hasStencilBuffer bool ) { C . gtk_gl_area_set_has_stencil_buffer ( v . native ( ) , gbool ( hasStencilBuffer ) ) } 
func ( v * GLArea ) SetAutoRender ( autoRender bool ) { C . gtk_gl_area_set_auto_render ( v . native ( ) , gbool ( autoRender ) ) } 
func ( v * GLArea ) GetContext ( ) ( * gdk . GLContext , error ) { c := C . gtk_gl_area_get_context ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } return & ( gdk . GLContext { obj } ) , nil } 
func ( v * GLArea ) GetError ( ) error { var err * C . GError = nil err = C . gtk_gl_area_get_error ( v . native ( ) ) if err != nil { defer C . g_error_free ( err ) return errors . New ( goString ( err . message ) ) } return nil } 
func ( v * TreeView ) native ( ) * C . GtkTreeView { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeView ( p ) } 
func TreeViewNewWithModel ( model ITreeModel ) ( * TreeView , error ) { return setupTreeView ( unsafe . Pointer ( C . gtk_tree_view_new_with_model ( model . toTreeModel ( ) ) ) ) } 
func ( v * TreeView ) GetModel ( ) ( * TreeModel , error ) { c := C . gtk_tree_view_get_model ( v . native ( ) ) if c == nil { return nil , nil } return wrapTreeModel ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TreeView ) SetModel ( model ITreeModel ) { var mptr * C . GtkTreeModel if model != nil { mptr = model . toTreeModel ( ) } C . gtk_tree_view_set_model ( v . native ( ) , mptr ) } 
func ( v * TreeView ) GetSelection ( ) ( * TreeSelection , error ) { c := C . gtk_tree_view_get_selection ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapTreeSelection ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TreeView ) AppendColumn ( column * TreeViewColumn ) int { c := C . gtk_tree_view_append_column ( v . native ( ) , column . native ( ) ) return int ( c ) } 
func ( v * TreeView ) GetPathAtPos ( x , y int , path * TreePath , column * TreeViewColumn , cellX , cellY * int ) bool { var ctp * * C . GtkTreePath if path != nil { ctp = ( * * C . GtkTreePath ) ( unsafe . Pointer ( & path . GtkTreePath ) ) } else { ctp = nil } var pctvcol * * C . GtkTreeViewColumn if column != nil { ctvcol := column . native ( ) pctvcol = & ctvcol } else { pctvcol = nil } return 0 != C . gtk_tree_view_get_path_at_pos ( v . native ( ) , ( C . gint ) ( x ) , ( C . gint ) ( y ) , ctp , pctvcol , ( * C . gint ) ( unsafe . Pointer ( cellX ) ) , ( * C . gint ) ( unsafe . Pointer ( cellY ) ) ) } 
func ( v * TreeView ) SetLevelIndentation ( indent int ) { C . gtk_tree_view_set_level_indentation ( v . native ( ) , C . gint ( indent ) ) } 
func ( v * TreeView ) SetShowExpanders ( show bool ) { C . gtk_tree_view_set_show_expanders ( v . native ( ) , gbool ( show ) ) } 
func ( v * TreeView ) SetHeadersVisible ( show bool ) { C . gtk_tree_view_set_headers_visible ( v . native ( ) , gbool ( show ) ) } 
func ( v * TreeView ) SetHeadersClickable ( show bool ) { C . gtk_tree_view_set_headers_clickable ( v . native ( ) , gbool ( show ) ) } 
func ( v * TreeView ) SetActivateOnSingleClick ( show bool ) { C . gtk_tree_view_set_activate_on_single_click ( v . native ( ) , gbool ( show ) ) } 
func ( v * TreeView ) RemoveColumn ( column * TreeViewColumn ) int { return int ( C . gtk_tree_view_remove_column ( v . native ( ) , column . native ( ) ) ) } 
func ( v * TreeView ) InsertColumn ( column * TreeViewColumn , pos int ) int { return int ( C . gtk_tree_view_insert_column ( v . native ( ) , column . native ( ) , C . gint ( pos ) ) ) } 
func ( v * TreeView ) GetColumn ( n int ) * TreeViewColumn { c := C . gtk_tree_view_get_column ( v . native ( ) , C . gint ( n ) ) if c == nil { return nil } return wrapTreeViewColumn ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * TreeView ) MoveColumnAfter ( column * TreeViewColumn , baseColumn * TreeViewColumn ) { C . gtk_tree_view_move_column_after ( v . native ( ) , column . native ( ) , baseColumn . native ( ) ) } 
func ( v * TreeView ) SetExpanderColumn ( column * TreeViewColumn ) { C . gtk_tree_view_set_expander_column ( v . native ( ) , column . native ( ) ) } 
func ( v * TreeView ) GetExpanderColumn ( ) * TreeViewColumn { c := C . gtk_tree_view_get_expander_column ( v . native ( ) ) if c == nil { return nil } return wrapTreeViewColumn ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * TreeView ) ScrollToPoint ( treeX , treeY int ) { C . gtk_tree_view_scroll_to_point ( v . native ( ) , C . gint ( treeX ) , C . gint ( treeY ) ) } 
func ( v * TreeView ) SetCursor ( path * TreePath , focusColumn * TreeViewColumn , startEditing bool ) { C . gtk_tree_view_set_cursor ( v . native ( ) , path . native ( ) , focusColumn . native ( ) , gbool ( startEditing ) ) } 
func ( v * TreeView ) SetCursorOnCell ( path * TreePath , focusColumn * TreeViewColumn , focusCell * CellRenderer , startEditing bool ) { C . gtk_tree_view_set_cursor_on_cell ( v . native ( ) , path . native ( ) , focusColumn . native ( ) , focusCell . native ( ) , gbool ( startEditing ) ) } 
func ( v * TreeView ) GetCursor ( ) ( p * TreePath , c * TreeViewColumn ) { var path * C . GtkTreePath var col * C . GtkTreeViewColumn C . gtk_tree_view_get_cursor ( v . native ( ) , & path , & col ) if path != nil { p = & TreePath { path } runtime . SetFinalizer ( p , ( * TreePath ) . free ) } if col != nil { c = wrapTreeViewColumn ( glib . Take ( unsafe . Pointer ( col ) ) ) } return } 
func ( v * TreeView ) RowActivated ( path * TreePath , column * TreeViewColumn ) { C . gtk_tree_view_row_activated ( v . native ( ) , path . native ( ) , column . native ( ) ) } 
func ( v * TreeView ) ExpandToPath ( path * TreePath ) { C . gtk_tree_view_expand_to_path ( v . native ( ) , path . native ( ) ) } 
func ( v * TreeView ) ExpandRow ( path * TreePath , openAll bool ) bool { return gobool ( C . gtk_tree_view_expand_row ( v . native ( ) , path . native ( ) , gbool ( openAll ) ) ) } 
func ( v * TreeView ) CollapseRow ( path * TreePath ) bool { return gobool ( C . gtk_tree_view_collapse_row ( v . native ( ) , path . native ( ) ) ) } 
func ( v * TreeView ) RowExpanded ( path * TreePath ) bool { return gobool ( C . gtk_tree_view_row_expanded ( v . native ( ) , path . native ( ) ) ) } 
func ( v * TreeView ) SetReorderable ( b bool ) { C . gtk_tree_view_set_reorderable ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) GetBinWindow ( ) * gdk . Window { c := C . gtk_tree_view_get_bin_window ( v . native ( ) ) if c == nil { return nil } w := & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w } 
func ( v * TreeView ) SetEnableSearch ( b bool ) { C . gtk_tree_view_set_enable_search ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetSearchColumn ( c int ) { C . gtk_tree_view_set_search_column ( v . native ( ) , C . gint ( c ) ) } 
func ( v * TreeView ) GetSearchEntry ( ) * Entry { c := C . gtk_tree_view_get_search_entry ( v . native ( ) ) if c == nil { return nil } return wrapEntry ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * TreeView ) SetSearchEntry ( e * Entry ) { C . gtk_tree_view_set_search_entry ( v . native ( ) , e . native ( ) ) } 
func ( v * TreeView ) SetSearchEqualSubstringMatch ( ) { C . gtk_tree_view_set_search_equal_func ( v . native ( ) , ( C . GtkTreeViewSearchEqualFunc ) ( unsafe . Pointer ( C . substring_match_equal_func ) ) , nil , nil ) } 
func ( v * TreeView ) SetFixedHeightMode ( b bool ) { C . gtk_tree_view_set_fixed_height_mode ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetHoverSelection ( b bool ) { C . gtk_tree_view_set_hover_selection ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetHoverExpand ( b bool ) { C . gtk_tree_view_set_hover_expand ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetRubberBanding ( b bool ) { C . gtk_tree_view_set_rubber_banding ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetEnableTreeLines ( b bool ) { C . gtk_tree_view_set_enable_tree_lines ( v . native ( ) , gbool ( b ) ) } 
func ( v * TreeView ) SetTooltipColumn ( c int ) { C . gtk_tree_view_set_tooltip_column ( v . native ( ) , C . gint ( c ) ) } 
func ( v * TreeView ) SetGridLines ( gridLines TreeViewGridLines ) { C . gtk_tree_view_set_grid_lines ( v . native ( ) , C . GtkTreeViewGridLines ( gridLines ) ) } 
func ( t Type ) Name ( ) string { return C . GoString ( ( * C . char ) ( C . g_type_name ( C . GType ( t ) ) ) ) } 
func ( t Type ) Depth ( ) uint { return uint ( C . g_type_depth ( C . GType ( t ) ) ) } 
func ( t Type ) Parent ( ) Type { return Type ( C . g_type_parent ( C . GType ( t ) ) ) } 
func goMarshal ( closure * C . GClosure , retValue * C . GValue , nParams C . guint , params * C . GValue , invocationHint C . gpointer , marshalData * C . GValue ) { cc := closures . m [ closure ] closures . RUnlock ( ) nTotalParams := nGLibParams if cc . userData . IsValid ( ) { nTotalParams ++ } if nCbParams > nTotalParams { fmt . Fprintf ( os . Stderr , " \n " , nCbParams , nTotalParams ) return } args := make ( [ ] reflect . Value , 0 , nCbParams ) val , err := v . GoValue ( ) if err != nil { fmt . Fprintf ( os . Stderr , " \n " , i , err ) return } if err != nil { } else { val = innerVal } } rv := reflect . ValueOf ( val ) args = append ( args , rv . Convert ( cc . rf . Type ( ) . In ( i ) ) ) } } if retValue != nil && len ( rv ) > 0 { if g , err := GValue ( rv [ 0 ] . Interface ( ) ) ; err != nil { fmt . Fprintf ( os . Stderr , " " , err ) } else { * retValue = * g . native ( ) } } } 
func gValueSlice ( values * C . GValue , nValues int ) ( slice [ ] C . GValue ) { header := ( * reflect . SliceHeader ) ( ( unsafe . Pointer ( & slice ) ) ) header . Cap = nValues header . Len = nValues header . Data = uintptr ( unsafe . Pointer ( values ) ) return } 
func IdleAdd ( f interface { } , args ... interface { } ) ( SourceHandle , error ) { if rf . Type ( ) . Kind ( ) != reflect . Func { return 0 , errors . New ( " " ) } if idleSrc == nil { return 0 , errNilPtr } return sourceAttach ( idleSrc , rf , args ... ) } 
func TimeoutAdd ( timeout uint , f interface { } , args ... interface { } ) ( SourceHandle , error ) { if rf . Type ( ) . Kind ( ) != reflect . Func { return 0 , errors . New ( " " ) } if timeoutSrc == nil { return 0 , errNilPtr } return sourceAttach ( timeoutSrc , rf , args ... ) } 
func sourceAttach ( src * C . struct__GSource , rf reflect . Value , args ... interface { } ) ( SourceHandle , error ) { if src == nil { return 0 , errNilPtr } return 0 , errors . New ( " " ) } closure , _ = ClosureNew ( rf . Interface ( ) , args ... ) return SourceHandle ( cid ) , nil } 
func GetHomeDir ( ) string { c := C . g_get_home_dir ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func GetUserCacheDir ( ) string { c := C . g_get_user_cache_dir ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func GetUserDataDir ( ) string { c := C . g_get_user_data_dir ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func GetUserConfigDir ( ) string { c := C . g_get_user_config_dir ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func GetUserRuntimeDir ( ) string { c := C . g_get_user_runtime_dir ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func GetUserSpecialDir ( directory UserDirectory ) ( string , error ) { c := C . g_get_user_special_dir ( C . GUserDirectory ( directory ) ) if c == nil { return " " , errNilPtr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Object ) native ( ) * C . GObject { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGObject ( p ) } 
func ( v * Object ) goValue ( ) ( interface { } , error ) { objType := Type ( C . _g_type_from_instance ( C . gpointer ( v . native ( ) ) ) ) f , err := gValueMarshalers . lookupType ( objType ) if err != nil { return nil , err } if err != nil { return nil , err } val . SetInstance ( uintptr ( unsafe . Pointer ( v . GObject ) ) ) rv , err := f ( uintptr ( unsafe . Pointer ( val . native ( ) ) ) ) return rv , err } 
func Take ( ptr unsafe . Pointer ) * Object { obj := newObject ( ToGObject ( ptr ) ) if obj . IsFloating ( ) { obj . RefSink ( ) } else { obj . Ref ( ) } runtime . SetFinalizer ( obj , ( * Object ) . Unref ) return obj } 
func ( v * Object ) IsA ( typ Type ) bool { return gobool ( C . g_type_is_a ( C . GType ( v . TypeFromInstance ( ) ) , C . GType ( typ ) ) ) } 
func ( v * Object ) TypeFromInstance ( ) Type { c := C . _g_type_from_instance ( C . gpointer ( unsafe . Pointer ( v . native ( ) ) ) ) return Type ( c ) } 
func ( v * Object ) IsFloating ( ) bool { c := C . g_object_is_floating ( C . gpointer ( v . GObject ) ) return gobool ( c ) } 
func ( v * Object ) StopEmission ( s string ) { cstr := C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g_signal_stop_emission_by_name ( ( C . gpointer ) ( v . GObject ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Object ) Set ( name string , value interface { } ) error { return v . SetProperty ( name , value ) } 
func ( v * Object ) GetPropertyType ( name string ) ( Type , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) paramSpec := C . g_object_class_find_property ( C . _g_object_get_class ( v . native ( ) ) , ( * C . gchar ) ( cstr ) ) if paramSpec == nil { return TYPE_INVALID , errors . New ( " " ) } return Type ( paramSpec . value_type ) , nil } 
func ( v * Object ) GetProperty ( name string ) ( interface { } , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) t , err := v . GetPropertyType ( name ) if err != nil { return nil , err } p , err := ValueInit ( t ) if err != nil { return nil , errors . New ( " " ) } C . g_object_get_property ( v . GObject , ( * C . gchar ) ( cstr ) , p . native ( ) ) return p . GoValue ( ) } 
func ( v * Object ) SetProperty ( name string , value interface { } ) error { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) if _ , ok := value . ( Object ) ; ok { value = value . ( Object ) . GObject } p , err := GValue ( value ) if err != nil { return errors . New ( " " ) } C . g_object_set_property ( v . GObject , ( * C . gchar ) ( cstr ) , p . native ( ) ) return nil } 
func ( v * Object ) Emit ( s string , args ... interface { } ) ( interface { } , error ) { cstr := C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) defer C . free ( unsafe . Pointer ( valv ) ) if err != nil { return nil , errors . New ( " " + err . Error ( ) ) } C . val_list_insert ( valv , C . int ( 0 ) , val . native ( ) ) for i := range args { val , err := GValue ( args [ i ] ) if err != nil { return nil , fmt . Errorf ( " " , i , err . Error ( ) ) } C . val_list_insert ( valv , C . int ( i + 1 ) , val . native ( ) ) } t := v . TypeFromInstance ( ) ret , err := ValueAlloc ( ) if err != nil { return nil , errors . New ( " " ) } C . g_signal_emitv ( valv , id , C . GQuark ( 0 ) , ret . native ( ) ) return ret . GoValue ( ) } 
func ( v * Object ) HandlerBlock ( handle SignalHandle ) { C . g_signal_handler_block ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) } 
func ( v * Object ) HandlerUnblock ( handle SignalHandle ) { C . g_signal_handler_unblock ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) } 
func ( v * Object ) HandlerDisconnect ( handle SignalHandle ) { C . g_signal_handler_disconnect ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) C . g_closure_invalidate ( signals [ handle ] ) delete ( closures . m , signals [ handle ] ) delete ( signals , handle ) } 
func ( v * InitiallyUnowned ) Native ( ) uintptr { if v == nil || v . Object == nil { return uintptr ( unsafe . Pointer ( nil ) ) } return v . Object . Native ( ) } 
func ValueAlloc ( ) ( * Value , error ) { c := C . _g_value_alloc ( ) if c == nil { return nil , errNilPtr } v := & Value { c } return } f . unset ( ) } ) return v , nil } 
func ValueInit ( t Type ) ( * Value , error ) { c := C . _g_value_init ( C . GType ( t ) ) if c == nil { return nil , errNilPtr } v := & Value { c } runtime . SetFinalizer ( v , ( * Value ) . unset ) return v , nil } 
func ( v * Value ) Type ( ) ( actual Type , fundamental Type , err error ) { if ! gobool ( C . _g_is_value ( v . native ( ) ) ) { return actual , fundamental , errors . New ( " " ) } cActual := C . _g_value_type ( v . native ( ) ) cFundamental := C . _g_value_fundamental ( cActual ) return Type ( cActual ) , Type ( cFundamental ) , nil } 
func GValue ( v interface { } ) ( gvalue * Value , err error ) { if v == nil { val , err := ValueInit ( TYPE_POINTER ) if err != nil { return nil , err } val . SetPointer ( uintptr ( unsafe . Pointer ( nil ) ) ) return val , nil } switch e := v . ( type ) { case bool : val , err := ValueInit ( TYPE_BOOLEAN ) if err != nil { return nil , err } val . SetBool ( e ) return val , nil case int8 : val , err := ValueInit ( TYPE_CHAR ) if err != nil { return nil , err } val . SetSChar ( e ) return val , nil case int64 : val , err := ValueInit ( TYPE_INT64 ) if err != nil { return nil , err } val . SetInt64 ( e ) return val , nil case int : val , err := ValueInit ( TYPE_INT ) if err != nil { return nil , err } val . SetInt ( e ) return val , nil case uint8 : val , err := ValueInit ( TYPE_UCHAR ) if err != nil { return nil , err } val . SetUChar ( e ) return val , nil case uint64 : val , err := ValueInit ( TYPE_UINT64 ) if err != nil { return nil , err } val . SetUInt64 ( e ) return val , nil case uint : val , err := ValueInit ( TYPE_UINT ) if err != nil { return nil , err } val . SetUInt ( e ) return val , nil case float32 : val , err := ValueInit ( TYPE_FLOAT ) if err != nil { return nil , err } val . SetFloat ( e ) return val , nil case float64 : val , err := ValueInit ( TYPE_DOUBLE ) if err != nil { return nil , err } val . SetDouble ( e ) return val , nil case string : val , err := ValueInit ( TYPE_STRING ) if err != nil { return nil , err } val . SetString ( e ) return val , nil case * Object : val , err := ValueInit ( TYPE_OBJECT ) if err != nil { return nil , err } val . SetInstance ( uintptr ( unsafe . Pointer ( e . GObject ) ) ) return val , nil default : rval := reflect . ValueOf ( v ) switch rval . Kind ( ) { case reflect . Int8 : val , err := ValueInit ( TYPE_CHAR ) if err != nil { return nil , err } val . SetSChar ( int8 ( rval . Int ( ) ) ) return val , nil case reflect . Int16 : return nil , errors . New ( " " ) case reflect . Int32 : return nil , errors . New ( " " ) case reflect . Int64 : val , err := ValueInit ( TYPE_INT64 ) if err != nil { return nil , err } val . SetInt64 ( rval . Int ( ) ) return val , nil case reflect . Int : val , err := ValueInit ( TYPE_INT ) if err != nil { return nil , err } val . SetInt ( int ( rval . Int ( ) ) ) return val , nil case reflect . Uintptr , reflect . Ptr : val , err := ValueInit ( TYPE_POINTER ) if err != nil { return nil , err } val . SetPointer ( rval . Pointer ( ) ) return val , nil } } return nil , errors . New ( " " ) } 
func ( v * Value ) GoValue ( ) ( interface { } , error ) { f , err := gValueMarshalers . lookup ( v ) if err != nil { return nil , err } return rv , err } 
func ( v * Value ) SetBool ( val bool ) { C . g_value_set_boolean ( v . native ( ) , gbool ( val ) ) } 
func ( v * Value ) SetSChar ( val int8 ) { C . g_value_set_schar ( v . native ( ) , C . gint8 ( val ) ) } 
func ( v * Value ) SetInt64 ( val int64 ) { C . g_value_set_int64 ( v . native ( ) , C . gint64 ( val ) ) } 
func ( v * Value ) SetInt ( val int ) { C . g_value_set_int ( v . native ( ) , C . gint ( val ) ) } 
func ( v * Value ) SetUChar ( val uint8 ) { C . g_value_set_uchar ( v . native ( ) , C . guchar ( val ) ) } 
func ( v * Value ) SetUInt64 ( val uint64 ) { C . g_value_set_uint64 ( v . native ( ) , C . guint64 ( val ) ) } 
func ( v * Value ) SetUInt ( val uint ) { C . g_value_set_uint ( v . native ( ) , C . guint ( val ) ) } 
func ( v * Value ) SetFloat ( val float32 ) { C . g_value_set_float ( v . native ( ) , C . gfloat ( val ) ) } 
func ( v * Value ) SetDouble ( val float64 ) { C . g_value_set_double ( v . native ( ) , C . gdouble ( val ) ) } 
func ( v * Value ) SetString ( val string ) { cstr := C . CString ( val ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g_value_set_string ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Value ) SetInstance ( instance uintptr ) { C . g_value_set_instance ( v . native ( ) , C . gpointer ( instance ) ) } 
func ( v * Value ) SetPointer ( p uintptr ) { C . g_value_set_pointer ( v . native ( ) , C . gpointer ( p ) ) } 
func ( v * Value ) GetPointer ( ) unsafe . Pointer { return unsafe . Pointer ( C . g_value_get_pointer ( v . native ( ) ) ) } 
func ( v * Value ) GetString ( ) ( string , error ) { c := C . g_value_get_string ( v . native ( ) ) if c == nil { return " " , errNilPtr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func GetApplicationName ( ) string { c := C . g_get_application_name ( ) return C . GoString ( ( * C . char ) ( c ) ) } 
func SetApplicationName ( name string ) { cstr := ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g_set_application_name ( cstr ) } 
func InitI18n ( domain string , dir string ) { domainStr := C . CString ( domain ) defer C . free ( unsafe . Pointer ( domainStr ) ) dirStr := C . CString ( dir ) defer C . free ( unsafe . Pointer ( dirStr ) ) C . init_i18n ( domainStr , dirStr ) } 
func Local ( input string ) string { cstr := C . CString ( input ) defer C . free ( unsafe . Pointer ( cstr ) ) return C . GoString ( C . localize ( cstr ) ) } 
func ( v * LevelBar ) SetInverted ( inverted bool ) { C . gtk_level_bar_set_inverted ( v . native ( ) , gbool ( inverted ) ) } 
func ( v * LevelBar ) GetInverted ( ) bool { c := C . gtk_level_bar_get_inverted ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) GetNScreens ( ) int { c := C . gdk_display_get_n_screens ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) OverrideFont ( description string ) { cstr := C . CString ( description ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . pango_font_description_from_string ( cstr ) C . gtk_widget_override_font ( v . native ( ) , c ) } 
func ( v * ShortcutsSection ) native ( ) * C . GtkShortcutsSection { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkShortcutsSection ( p ) } 
func ( v * ShortcutsGroup ) native ( ) * C . GtkShortcutsGroup { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkShortcutsGroup ( p ) } 
func ( v * ShortcutsShortcut ) native ( ) * C . GtkShortcutsShortcut { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkShortcutsShortcut ( p ) } 
func ( v * NativeDialog ) native ( ) * C . GtkNativeDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkNativeDialog ( p ) } 
func ( v * NativeDialog ) Run ( ) int { c := C . gtk_native_dialog_run ( v . native ( ) ) return int ( c ) } 
func ( v * NativeDialog ) SetModal ( modal bool ) { C . gtk_native_dialog_set_modal ( v . native ( ) , gbool ( modal ) ) } 
func ( v * NativeDialog ) GetModal ( ) bool { c := C . gtk_native_dialog_get_modal ( v . native ( ) ) return gobool ( c ) } 
func ( v * NativeDialog ) SetTitle ( title string ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_native_dialog_set_title ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * NativeDialog ) GetTitle ( ) ( string , error ) { return stringReturn ( ( * C . gchar ) ( C . gtk_native_dialog_get_title ( v . native ( ) ) ) ) } 
func ( v * NativeDialog ) SetTransientFor ( parent IWindow ) { var pw * C . GtkWindow = nil if parent != nil { pw = parent . toWindow ( ) } C . gtk_native_dialog_set_transient_for ( v . native ( ) , pw ) } 
func ( v * NativeDialog ) GetVisible ( ) bool { c := C . gtk_native_dialog_get_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * FileChooserNativeDialog ) native ( ) * C . GtkFileChooserNative { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooserNative ( p ) } 
func FileChooserNativeDialogNew ( title string , parent * Window , action FileChooserAction , accept_label string , cancel_label string ) ( * FileChooserNativeDialog , error ) { c_title := C . CString ( title ) defer C . free ( unsafe . Pointer ( c_title ) ) c_accept_label := C . CString ( accept_label ) defer C . free ( unsafe . Pointer ( c_accept_label ) ) c_cancel_label := C . CString ( cancel_label ) defer C . free ( unsafe . Pointer ( c_cancel_label ) ) c := C . gtk_file_chooser_native_new ( ( * C . gchar ) ( c_title ) , parent . native ( ) , C . GtkFileChooserAction ( action ) , ( * C . gchar ) ( c_accept_label ) , ( * C . gchar ) ( c_cancel_label ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFileChooserNativeDialog ( obj ) , nil } 
func OpenFileChooserNative ( title string , parent_window * Window ) * string { c_title := C . CString ( title ) var native * C . GtkFileChooserNative native = C . gtk_file_chooser_native_new ( ( * C . gchar ) ( c_title ) , parent_window . native ( ) , C . GtkFileChooserAction ( FILE_CHOOSER_ACTION_OPEN ) , ( * C . gchar ) ( C . CString ( " " ) ) , ( * C . gchar ) ( C . CString ( " " ) ) ) p := unsafe . Pointer ( unsafe . Pointer ( native ) ) dlg := C . toGtkNativeDialog ( p ) res := C . gtk_native_dialog_run ( dlg ) if res == C . GTK_RESPONSE_ACCEPT { c := C . gtk_file_chooser_get_filename ( C . toGtkFileChooser ( p ) ) s := goString ( c ) defer C . g_free ( ( C . gpointer ) ( c ) ) return & s } return nil } 
func ( v * FileChooserNativeDialog ) SetAcceptLabel ( accept_label string ) { cstr := C . CString ( accept_label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_file_chooser_native_set_accept_label ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * FileChooserNativeDialog ) GetAcceptLabel ( ) ( string , error ) { return stringReturn ( ( * C . gchar ) ( C . gtk_file_chooser_native_get_accept_label ( v . native ( ) ) ) ) } 
func ( v * FileChooserNativeDialog ) SetCancelLabel ( cancel_label string ) { cstr := C . CString ( cancel_label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_file_chooser_native_set_cancel_label ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * FileChooserNativeDialog ) GetCancelLabel ( ) ( string , error ) { return stringReturn ( ( * C . gchar ) ( C . gtk_file_chooser_native_get_cancel_label ( v . native ( ) ) ) ) } 
func ( v * SimpleActionGroup ) native ( ) * C . GSimpleActionGroup { if v == nil || v . GObject == nil { return nil } return C . toGSimpleActionGroup ( unsafe . Pointer ( v . GObject ) ) } 
func SimpleActionGroupNew ( ) * SimpleActionGroup { c := C . g_simple_action_group_new ( ) if c == nil { return nil } return wrapSimpleActionGroup ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Action ) native ( ) * C . GAction { if v == nil || v . GObject == nil { return nil } return C . toGAction ( unsafe . Pointer ( v . GObject ) ) } 
func ActionNameIsValid ( actionName string ) bool { cstr := ( * C . gchar ) ( C . CString ( actionName ) ) return gobool ( C . g_action_name_is_valid ( cstr ) ) } 
func ( v * Action ) GetName ( ) string { return C . GoString ( ( * C . char ) ( C . g_action_get_name ( v . native ( ) ) ) ) } 
func ( v * Action ) GetState ( ) * Variant { c := C . g_action_get_state ( v . native ( ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action ) GetStateHint ( ) * Variant { c := C . g_action_get_state_hint ( v . native ( ) ) if c == nil { return nil } return newVariant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action ) GetParameterType ( ) * VariantType { c := C . g_action_get_parameter_type ( v . native ( ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) } 
func ( v * Action ) GetStateType ( ) * VariantType { c := C . g_action_get_state_type ( v . native ( ) ) if c == nil { return nil } return newVariantType ( ( * C . GVariantType ) ( c ) ) } 
func ( v * Action ) ChangeState ( value * Variant ) { C . g_action_change_state ( v . native ( ) , value . native ( ) ) } 
func ( v * Action ) Activate ( parameter * Variant ) { C . g_action_activate ( v . native ( ) , parameter . native ( ) ) } 
func SimpleActionNew ( name string , parameterType * VariantType ) * SimpleAction { c := C . g_simple_action_new ( ( * C . gchar ) ( C . CString ( name ) ) , parameterType . native ( ) ) if c == nil { return nil } return wrapSimpleAction ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func SimpleActionNewStateful ( name string , parameterType * VariantType , state * Variant ) * SimpleAction { c := C . g_simple_action_new_stateful ( ( * C . gchar ) ( C . CString ( name ) ) , parameterType . native ( ) , state . native ( ) ) if c == nil { return nil } return wrapSimpleAction ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * SimpleAction ) SetEnabled ( enabled bool ) { C . g_simple_action_set_enabled ( v . native ( ) , gbool ( enabled ) ) } 
func ( v * SimpleAction ) SetState ( value * Variant ) { C . g_simple_action_set_state ( v . native ( ) , value . native ( ) ) } 
func PropertyActionNew ( name string , object * Object , propertyName string ) * PropertyAction { c := C . g_property_action_new ( ( * C . gchar ) ( C . CString ( name ) ) , C . gpointer ( unsafe . Pointer ( object . native ( ) ) ) , ( * C . gchar ) ( C . CString ( propertyName ) ) ) if c == nil { return nil } return wrapPropertyAction ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) PopupAtPointer ( triggerEvent * gdk . Event ) { e := ( * C . GdkEvent ) ( unsafe . Pointer ( triggerEvent . Native ( ) ) ) C . gtk_menu_popup_at_pointer ( v . native ( ) , e ) } 
func ( v * Menu ) PopupAtWidget ( widget IWidget , widgetAnchor gdk . GdkGravity , menuAnchor gdk . GdkGravity , triggerEvent * gdk . Event ) { e := ( * C . GdkEvent ) ( unsafe . Pointer ( triggerEvent . Native ( ) ) ) C . gtk_menu_popup_at_widget ( v . native ( ) , widget . toWidget ( ) , C . GdkGravity ( widgetAnchor ) , C . GdkGravity ( menuAnchor ) , e ) } 
func InitCheck ( args * [ ] string ) error { success := false if args != nil { argc := C . int ( len ( * args ) ) argv := C . make_strings ( argc ) defer C . destroy_strings ( argv ) for i , arg := range * args { cstr := C . CString ( arg ) C . set_string ( argv , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } success = gobool ( C . gtk_init_check ( ( * C . int ) ( unsafe . Pointer ( & argc ) ) , ( * * * C . char ) ( unsafe . Pointer ( & argv ) ) ) ) unhandled := make ( [ ] string , argc ) for i := 0 ; i < int ( argc ) ; i ++ { cstr := C . get_string ( argv , C . int ( i ) ) unhandled [ i ] = goString ( cstr ) C . free ( unsafe . Pointer ( cstr ) ) } * args = unhandled } else { success = gobool ( C . gtk_init_check ( nil , nil ) ) } if success { return nil } else { return errors . New ( " " ) } } 
func ( v * Adjustment ) native ( ) * C . GtkAdjustment { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAdjustment ( p ) } 
func AdjustmentNew ( value , lower , upper , stepIncrement , pageIncrement , pageSize float64 ) ( * Adjustment , error ) { c := C . gtk_adjustment_new ( C . gdouble ( value ) , C . gdouble ( lower ) , C . gdouble ( upper ) , C . gdouble ( stepIncrement ) , C . gdouble ( pageIncrement ) , C . gdouble ( pageSize ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAdjustment ( obj ) , nil } 
func ( v * Adjustment ) GetValue ( ) float64 { c := C . gtk_adjustment_get_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * Adjustment ) GetLower ( ) float64 { c := C . gtk_adjustment_get_lower ( v . native ( ) ) return float64 ( c ) } 
func ( v * Adjustment ) SetPageSize ( value float64 ) { C . gtk_adjustment_set_page_size ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Configure ( value , lower , upper , stepIncrement , pageIncrement , pageSize float64 ) { C . gtk_adjustment_configure ( v . native ( ) , C . gdouble ( value ) , C . gdouble ( lower ) , C . gdouble ( upper ) , C . gdouble ( stepIncrement ) , C . gdouble ( pageIncrement ) , C . gdouble ( pageSize ) ) } 
func ( v * Adjustment ) SetLower ( value float64 ) { C . gtk_adjustment_set_lower ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) GetUpper ( ) float64 { c := C . gtk_adjustment_get_upper ( v . native ( ) ) return float64 ( c ) } 
func ( v * Adjustment ) SetUpper ( value float64 ) { C . gtk_adjustment_set_upper ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) GetPageIncrement ( ) float64 { c := C . gtk_adjustment_get_page_increment ( v . native ( ) ) return float64 ( c ) } 
func ( v * Adjustment ) SetPageIncrement ( value float64 ) { C . gtk_adjustment_set_page_increment ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) GetStepIncrement ( ) float64 { c := C . gtk_adjustment_get_step_increment ( v . native ( ) ) return float64 ( c ) } 
func ( v * Adjustment ) SetStepIncrement ( value float64 ) { C . gtk_adjustment_set_step_increment ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) GetMinimumIncrement ( ) float64 { c := C . gtk_adjustment_get_minimum_increment ( v . native ( ) ) return float64 ( c ) } 
func ( v * Assistant ) native ( ) * C . GtkAssistant { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAssistant ( p ) } 
func AssistantNew ( ) ( * Assistant , error ) { c := C . gtk_assistant_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAssistant ( obj ) , nil } 
func ( v * Assistant ) GetCurrentPage ( ) int { c := C . gtk_assistant_get_current_page ( v . native ( ) ) return int ( c ) } 
func ( v * Assistant ) SetCurrentPage ( pageNum int ) { C . gtk_assistant_set_current_page ( v . native ( ) , C . gint ( pageNum ) ) } 
func ( v * Assistant ) GetNPages ( ) int { c := C . gtk_assistant_get_n_pages ( v . native ( ) ) return int ( c ) } 
func ( v * Assistant ) GetNthPage ( pageNum int ) ( * Widget , error ) { c := C . gtk_assistant_get_nth_page ( v . native ( ) , C . gint ( pageNum ) ) if c == nil { return nil , fmt . Errorf ( " " , pageNum ) } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( v * Assistant ) PrependPage ( page IWidget ) int { c := C . gtk_assistant_prepend_page ( v . native ( ) , page . toWidget ( ) ) return int ( c ) } 
func ( v * Assistant ) AppendPage ( page IWidget ) int { c := C . gtk_assistant_append_page ( v . native ( ) , page . toWidget ( ) ) return int ( c ) } 
func ( v * Assistant ) InsertPage ( page IWidget , position int ) int { c := C . gtk_assistant_insert_page ( v . native ( ) , page . toWidget ( ) , C . gint ( position ) ) return int ( c ) } 
func ( v * Assistant ) RemovePage ( pageNum int ) { C . gtk_assistant_remove_page ( v . native ( ) , C . gint ( pageNum ) ) } 
func ( v * Assistant ) SetPageType ( page IWidget , ptype AssistantPageType ) { C . gtk_assistant_set_page_type ( v . native ( ) , page . toWidget ( ) , C . GtkAssistantPageType ( ptype ) ) } 
func ( v * Assistant ) GetPageType ( page IWidget ) AssistantPageType { c := C . gtk_assistant_get_page_type ( v . native ( ) , page . toWidget ( ) ) return AssistantPageType ( c ) } 
func ( v * Assistant ) SetPageTitle ( page IWidget , title string ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_assistant_set_page_title ( v . native ( ) , page . toWidget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Assistant ) GetPageTitle ( page IWidget ) string { return goString ( C . gtk_assistant_get_page_title ( v . native ( ) , page . toWidget ( ) ) ) } 
func ( v * Assistant ) SetPageComplete ( page IWidget , complete bool ) { C . gtk_assistant_set_page_complete ( v . native ( ) , page . toWidget ( ) , gbool ( complete ) ) } 
func ( v * Assistant ) GetPageComplete ( page IWidget ) bool { c := C . gtk_assistant_get_page_complete ( v . native ( ) , page . toWidget ( ) ) return gobool ( c ) } 
func ( v * Assistant ) AddActionWidget ( child IWidget ) { C . gtk_assistant_add_action_widget ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Assistant ) RemoveActionWidget ( child IWidget ) { C . gtk_assistant_remove_action_widget ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Bin ) native ( ) * C . GtkBin { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkBin ( p ) } 
func ( v * Bin ) GetChild ( ) ( * Widget , error ) { c := C . gtk_bin_get_child ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( b * Builder ) native ( ) * C . GtkBuilder { if b == nil || b . GObject == nil { return nil } p := unsafe . Pointer ( b . GObject ) return C . toGtkBuilder ( p ) } 
func BuilderNew ( ) ( * Builder , error ) { c := C . gtk_builder_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func BuilderNewFromFile ( filePath string ) ( * Builder , error ) { cstr := C . CString ( filePath ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_builder_new_from_file ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func BuilderNewFromResource ( resourcePath string ) ( * Builder , error ) { cstr := C . CString ( resourcePath ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_builder_new_from_resource ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func ( b * Builder ) AddFromFile ( filename string ) error { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res := C . gtk_builder_add_from_file ( b . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res == 0 { defer C . g_error_free ( err ) return errors . New ( goString ( err . message ) ) } return nil } 
func ( b * Builder ) AddFromResource ( path string ) error { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res := C . gtk_builder_add_from_resource ( b . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res == 0 { defer C . g_error_free ( err ) return errors . New ( goString ( err . message ) ) } return nil } 
func ( b * Builder ) AddFromString ( str string ) error { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) length := ( C . gsize ) ( len ( str ) ) var err * C . GError = nil res := C . gtk_builder_add_from_string ( b . native ( ) , ( * C . gchar ) ( cstr ) , length , & err ) if res == 0 { defer C . g_error_free ( err ) return errors . New ( goString ( err . message ) ) } return nil } 
func ( b * Builder ) GetObject ( name string ) ( glib . IObject , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_builder_get_object ( b . native ( ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , errors . New ( " " + name + " " ) } obj , err := cast ( c ) if err != nil { return nil , err } return obj , nil } 
func ( b * Builder ) ConnectSignals ( signals map [ string ] interface { } ) { builderSignals . Lock ( ) builderSignals . m [ b . native ( ) ] = signals builderSignals . Unlock ( ) C . _gtk_builder_connect_signals_full ( b . native ( ) ) } 
func ( v * Button ) native ( ) * C . GtkButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkButton ( p ) } 
func ButtonNew ( ) ( * Button , error ) { c := C . gtk_button_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapButton ( obj ) , nil } 
func ButtonNewWithLabel ( label string ) ( * Button , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_button_new_with_label ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapButton ( obj ) , nil } 
func ( v * Button ) SetRelief ( newStyle ReliefStyle ) { C . gtk_button_set_relief ( v . native ( ) , C . GtkReliefStyle ( newStyle ) ) } 
func ( v * Button ) GetRelief ( ) ReliefStyle { c := C . gtk_button_get_relief ( v . native ( ) ) return ReliefStyle ( c ) } 
func ( v * Button ) SetLabel ( label string ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_button_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Button ) GetLabel ( ) ( string , error ) { c := C . gtk_button_get_label ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Button ) SetUseUnderline ( useUnderline bool ) { C . gtk_button_set_use_underline ( v . native ( ) , gbool ( useUnderline ) ) } 
func ( v * Button ) GetUseUnderline ( ) bool { c := C . gtk_button_get_use_underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * Button ) SetImage ( image IWidget ) { C . gtk_button_set_image ( v . native ( ) , image . toWidget ( ) ) } 
func ( v * Button ) GetImage ( ) ( * Widget , error ) { c := C . gtk_button_get_image ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( v * Button ) SetImagePosition ( position PositionType ) { C . gtk_button_set_image_position ( v . native ( ) , C . GtkPositionType ( position ) ) } 
func ( v * Button ) GetImagePosition ( ) PositionType { c := C . gtk_button_get_image_position ( v . native ( ) ) return PositionType ( c ) } 
func ( v * Button ) SetAlwaysShowImage ( alwaysShow bool ) { C . gtk_button_set_always_show_image ( v . native ( ) , gbool ( alwaysShow ) ) } 
func ( v * Button ) GetAlwaysShowImage ( ) bool { c := C . gtk_button_get_always_show_image ( v . native ( ) ) return gobool ( c ) } 
func ( v * Button ) GetEventWindow ( ) ( * gdk . Window , error ) { c := C . gtk_button_get_event_window ( v . native ( ) ) if c == nil { return nil , nilPtrErr } w := & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * ColorButton ) native ( ) * C . GtkColorButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkColorButton ( p ) } 
func ColorButtonNew ( ) ( * ColorButton , error ) { c := C . gtk_color_button_new ( ) if c == nil { return nil , nilPtrErr } return wrapColorButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ColorButtonNewWithRGBA ( gdkColor * gdk . RGBA ) ( * ColorButton , error ) { c := C . gtk_color_button_new_with_rgba ( ( * C . GdkRGBA ) ( unsafe . Pointer ( gdkColor . Native ( ) ) ) ) if c == nil { return nil , nilPtrErr } return wrapColorButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Box ) native ( ) * C . GtkBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkBox ( p ) } 
func ( v * Box ) SetOrientation ( o Orientation ) { C . gtk_orientable_set_orientation ( v . toOrientable ( ) , C . GtkOrientation ( o ) ) } 
func BoxNew ( orientation Orientation , spacing int ) ( * Box , error ) { c := C . gtk_box_new ( C . GtkOrientation ( orientation ) , C . gint ( spacing ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapBox ( obj ) , nil } 
func ( v * Box ) PackStart ( child IWidget , expand , fill bool , padding uint ) { C . gtk_box_pack_start ( v . native ( ) , child . toWidget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) ) } 
func ( v * Box ) PackEnd ( child IWidget , expand , fill bool , padding uint ) { C . gtk_box_pack_end ( v . native ( ) , child . toWidget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) ) } 
func ( v * Box ) GetHomogeneous ( ) bool { c := C . gtk_box_get_homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Box ) SetHomogeneous ( homogeneous bool ) { C . gtk_box_set_homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Box ) GetSpacing ( ) int { c := C . gtk_box_get_spacing ( v . native ( ) ) return int ( c ) } 
func ( v * Box ) ReorderChild ( child IWidget , position int ) { C . gtk_box_reorder_child ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func ( v * Box ) QueryChildPacking ( child IWidget ) ( expand , fill bool , padding uint , packType PackType ) { var cexpand , cfill C . gboolean var cpadding C . guint var cpackType C . GtkPackType C . gtk_box_query_child_packing ( v . native ( ) , child . toWidget ( ) , & cexpand , & cfill , & cpadding , & cpackType ) return gobool ( cexpand ) , gobool ( cfill ) , uint ( cpadding ) , PackType ( cpackType ) } 
func ( v * Box ) SetChildPacking ( child IWidget , expand , fill bool , padding uint , packType PackType ) { C . gtk_box_set_child_packing ( v . native ( ) , child . toWidget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) , C . GtkPackType ( packType ) ) } 
func ( v * Calendar ) native ( ) * C . GtkCalendar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCalendar ( p ) } 
func CalendarNew ( ) ( * Calendar , error ) { c := C . gtk_calendar_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCalendar ( obj ) , nil } 
func ( v * Calendar ) SelectMonth ( month , year uint ) { C . gtk_calendar_select_month ( v . native ( ) , C . guint ( month ) , C . guint ( year ) ) } 
func ( v * Calendar ) SelectDay ( day uint ) { C . gtk_calendar_select_day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) MarkDay ( day uint ) { C . gtk_calendar_mark_day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) UnmarkDay ( day uint ) { C . gtk_calendar_unmark_day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) GetDayIsMarked ( day uint ) bool { c := C . gtk_calendar_get_day_is_marked ( v . native ( ) , C . guint ( day ) ) return gobool ( c ) } 
func ( v * Calendar ) GetDisplayOptions ( ) CalendarDisplayOptions { c := C . gtk_calendar_get_display_options ( v . native ( ) ) return CalendarDisplayOptions ( c ) } 
func ( v * Calendar ) SetDisplayOptions ( flags CalendarDisplayOptions ) { C . gtk_calendar_set_display_options ( v . native ( ) , C . GtkCalendarDisplayOptions ( flags ) ) } 
func ( v * Calendar ) GetDate ( ) ( year , month , day uint ) { var cyear , cmonth , cday C . guint C . gtk_calendar_get_date ( v . native ( ) , & cyear , & cmonth , & cday ) return uint ( cyear ) , uint ( cmonth ) , uint ( cday ) } 
func ( v * Calendar ) GetDetailWidthChars ( ) int { c := C . gtk_calendar_get_detail_width_chars ( v . native ( ) ) return int ( c ) } 
func ( v * Calendar ) SetDetailWidthChars ( chars int ) { C . gtk_calendar_set_detail_width_chars ( v . native ( ) , C . gint ( chars ) ) } 
func ( v * Calendar ) GetDetailHeightRows ( ) int { c := C . gtk_calendar_get_detail_height_rows ( v . native ( ) ) return int ( c ) } 
func ( v * Calendar ) SetDetailHeightRows ( rows int ) { C . gtk_calendar_set_detail_height_rows ( v . native ( ) , C . gint ( rows ) ) } 
func ( v * CellLayout ) native ( ) * C . GtkCellLayout { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellLayout ( p ) } 
func ( v * CellLayout ) PackStart ( cell ICellRenderer , expand bool ) { C . gtk_cell_layout_pack_start ( v . native ( ) , cell . toCellRenderer ( ) , gbool ( expand ) ) } 
func ( v * CellLayout ) AddAttribute ( cell ICellRenderer , attribute string , column int ) { cstr := C . CString ( attribute ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_cell_layout_add_attribute ( v . native ( ) , cell . toCellRenderer ( ) , ( * C . gchar ) ( cstr ) , C . gint ( column ) ) } 
func ( v * CellRenderer ) native ( ) * C . GtkCellRenderer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRenderer ( p ) } 
func ( v * CellRendererSpinner ) native ( ) * C . GtkCellRendererSpinner { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererSpinner ( p ) } 
func CellRendererSpinnerNew ( ) ( * CellRendererSpinner , error ) { c := C . gtk_cell_renderer_spinner_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCellRendererSpinner ( obj ) , nil } 
func ( v * CellRendererPixbuf ) native ( ) * C . GtkCellRendererPixbuf { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererPixbuf ( p ) } 
func CellRendererPixbufNew ( ) ( * CellRendererPixbuf , error ) { c := C . gtk_cell_renderer_pixbuf_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCellRendererPixbuf ( obj ) , nil } 
func ( v * CellRendererText ) native ( ) * C . GtkCellRendererText { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererText ( p ) } 
func CellRendererTextNew ( ) ( * CellRendererText , error ) { c := C . gtk_cell_renderer_text_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCellRendererText ( obj ) , nil } 
func ( v * CellRendererToggle ) native ( ) * C . GtkCellRendererToggle { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCellRendererToggle ( p ) } 
func CellRendererToggleNew ( ) ( * CellRendererToggle , error ) { c := C . gtk_cell_renderer_toggle_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCellRendererToggle ( obj ) , nil } 
func ( v * CellRendererToggle ) SetRadio ( set bool ) { C . gtk_cell_renderer_toggle_set_radio ( v . native ( ) , gbool ( set ) ) } 
func ( v * CellRendererToggle ) GetRadio ( ) bool { c := C . gtk_cell_renderer_toggle_get_radio ( v . native ( ) ) return gobool ( c ) } 
func ( v * CellRendererToggle ) SetActive ( active bool ) { C . gtk_cell_renderer_toggle_set_active ( v . native ( ) , gbool ( active ) ) } 
func ( v * CellRendererToggle ) GetActive ( ) bool { c := C . gtk_cell_renderer_toggle_get_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * CellRendererToggle ) SetActivatable ( activatable bool ) { C . gtk_cell_renderer_toggle_set_activatable ( v . native ( ) , gbool ( activatable ) ) } 
func ( v * CellRendererToggle ) GetActivatable ( ) bool { c := C . gtk_cell_renderer_toggle_get_activatable ( v . native ( ) ) return gobool ( c ) } 
func ( v * CheckButton ) native ( ) * C . GtkCheckButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCheckButton ( p ) } 
func CheckButtonNew ( ) ( * CheckButton , error ) { c := C . gtk_check_button_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCheckButton ( obj ) , nil } 
func CheckButtonNewWithLabel ( label string ) ( * CheckButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_check_button_new_with_label ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapCheckButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func CheckButtonNewWithMnemonic ( label string ) ( * CheckButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_check_button_new_with_mnemonic ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCheckButton ( obj ) , nil } 
func ( v * CheckMenuItem ) native ( ) * C . GtkCheckMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCheckMenuItem ( p ) } 
func CheckMenuItemNew ( ) ( * CheckMenuItem , error ) { c := C . gtk_check_menu_item_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCheckMenuItem ( obj ) , nil } 
func CheckMenuItemNewWithLabel ( label string ) ( * CheckMenuItem , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_check_menu_item_new_with_label ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCheckMenuItem ( obj ) , nil } 
func ( v * CheckMenuItem ) GetActive ( ) bool { c := C . gtk_check_menu_item_get_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * CheckMenuItem ) SetActive ( isActive bool ) { C . gtk_check_menu_item_set_active ( v . native ( ) , gbool ( isActive ) ) } 
func ( v * CheckMenuItem ) GetInconsistent ( ) bool { c := C . gtk_check_menu_item_get_inconsistent ( v . native ( ) ) return gobool ( c ) } 
func ( v * CheckMenuItem ) SetInconsistent ( setting bool ) { C . gtk_check_menu_item_set_inconsistent ( v . native ( ) , gbool ( setting ) ) } 
func ( v * CheckMenuItem ) SetDrawAsRadio ( drawAsRadio bool ) { C . gtk_check_menu_item_set_draw_as_radio ( v . native ( ) , gbool ( drawAsRadio ) ) } 
func ( v * CheckMenuItem ) GetDrawAsRadio ( ) bool { c := C . gtk_check_menu_item_get_draw_as_radio ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) native ( ) * C . GtkClipboard { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkClipboard ( p ) } 
func ClipboardGet ( atom gdk . Atom ) ( * Clipboard , error ) { c := C . gtk_clipboard_get ( C . GdkAtom ( unsafe . Pointer ( atom ) ) ) if c == nil { return nil , nilPtrErr } cb := & Clipboard { glib . Take ( unsafe . Pointer ( c ) ) } return cb , nil } 
func ClipboardGetForDisplay ( display * gdk . Display , atom gdk . Atom ) ( * Clipboard , error ) { displayPtr := ( * C . GdkDisplay ) ( unsafe . Pointer ( display . Native ( ) ) ) c := C . gtk_clipboard_get_for_display ( displayPtr , C . GdkAtom ( unsafe . Pointer ( atom ) ) ) if c == nil { return nil , nilPtrErr } cb := & Clipboard { glib . Take ( unsafe . Pointer ( c ) ) } return cb , nil } 
func ( v * Clipboard ) WaitIsTextAvailable ( ) bool { c := C . gtk_clipboard_wait_is_text_available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) WaitForText ( ) ( string , error ) { c := C . gtk_clipboard_wait_for_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } defer C . g_free ( C . gpointer ( c ) ) return goString ( c ) , nil } 
func ( v * Clipboard ) SetText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_clipboard_set_text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * Clipboard ) WaitIsRichTextAvailable ( buf * TextBuffer ) bool { c := C . gtk_clipboard_wait_is_rich_text_available ( v . native ( ) , buf . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) WaitIsUrisAvailable ( ) bool { c := C . gtk_clipboard_wait_is_uris_available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) WaitIsImageAvailable ( ) bool { c := C . gtk_clipboard_wait_is_image_available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) SetImage ( pixbuf * gdk . Pixbuf ) { C . gtk_clipboard_set_image ( v . native ( ) , ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Clipboard ) WaitForImage ( ) ( * gdk . Pixbuf , error ) { c := C . gtk_clipboard_wait_for_image ( v . native ( ) ) if c == nil { return nil , nilPtrErr } p := & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * Clipboard ) WaitIsTargetAvailable ( target gdk . Atom ) bool { c := C . gtk_clipboard_wait_is_target_available ( v . native ( ) , C . GdkAtom ( unsafe . Pointer ( target ) ) ) return gobool ( c ) } 
func ( v * Clipboard ) WaitForContents ( target gdk . Atom ) ( * SelectionData , error ) { c := C . gtk_clipboard_wait_for_contents ( v . native ( ) , C . GdkAtom ( unsafe . Pointer ( target ) ) ) if c == nil { return nil , nilPtrErr } p := & SelectionData { c } runtime . SetFinalizer ( p , ( * SelectionData ) . free ) return p , nil } 
func ( v * Container ) native ( ) * C . GtkContainer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkContainer ( p ) } 
func ( v * Container ) Add ( w IWidget ) { C . gtk_container_add ( v . native ( ) , w . toWidget ( ) ) } 
func ( v * Container ) Remove ( w IWidget ) { C . gtk_container_remove ( v . native ( ) , w . toWidget ( ) ) } 
func ( v * Container ) GetChildren ( ) * glib . List { clist := C . gtk_container_get_children ( v . native ( ) ) glist := glib . WrapList ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return wrapWidget ( glib . Take ( ptr ) ) } ) return glist } 
func ( v * Container ) GetFocusChild ( ) * Widget { c := C . gtk_container_get_focus_child ( v . native ( ) ) if c == nil { return nil } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) } 
func ( v * Container ) SetFocusChild ( child IWidget ) { C . gtk_container_set_focus_child ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Container ) GetFocusVAdjustment ( ) * Adjustment { c := C . gtk_container_get_focus_vadjustment ( v . native ( ) ) if c == nil { return nil } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAdjustment ( obj ) } 
func ( v * Container ) SetFocusVAdjustment ( adjustment * Adjustment ) { C . gtk_container_set_focus_vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Container ) GetFocusHAdjustment ( ) * Adjustment { c := C . gtk_container_get_focus_hadjustment ( v . native ( ) ) if c == nil { return nil } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapAdjustment ( obj ) } 
func ( v * Container ) SetFocusHAdjustment ( adjustment * Adjustment ) { C . gtk_container_set_focus_hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Container ) ChildType ( ) glib . Type { c := C . gtk_container_child_type ( v . native ( ) ) return glib . Type ( c ) } 
func ( v * Container ) ChildNotify ( child IWidget , childProperty string ) { cstr := C . CString ( childProperty ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_container_child_notify ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Container ) ChildGetProperty ( child IWidget , name string , valueType glib . Type ) ( interface { } , error ) { gv , e := glib . ValueInit ( valueType ) if e != nil { return nil , e } cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_container_child_get_property ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) return gv . GoValue ( ) } 
func ( v * Container ) ChildSetProperty ( child IWidget , name string , value interface { } ) error { gv , e := glib . GValue ( value ) if e != nil { return e } cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_container_child_set_property ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) return nil } 
func ( v * Container ) GetBorderWidth ( ) uint { c := C . gtk_container_get_border_width ( v . native ( ) ) return uint ( c ) } 
func ( v * Container ) SetBorderWidth ( borderWidth uint ) { C . gtk_container_set_border_width ( v . native ( ) , C . guint ( borderWidth ) ) } 
func ( v * Container ) PropagateDraw ( child IWidget , cr * cairo . Context ) { context := ( * C . cairo_t ) ( unsafe . Pointer ( cr . Native ( ) ) ) C . gtk_container_propagate_draw ( v . native ( ) , child . toWidget ( ) , context ) } 
func GdkCairoSetSourcePixBuf ( cr * cairo . Context , pixbuf * gdk . Pixbuf , pixbufX , pixbufY float64 ) { context := ( * C . cairo_t ) ( unsafe . Pointer ( cr . Native ( ) ) ) ptr := ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) C . gdk_cairo_set_source_pixbuf ( context , ptr , C . gdouble ( pixbufX ) , C . gdouble ( pixbufY ) ) } 
func ( v * CssProvider ) native ( ) * C . GtkCssProvider { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkCssProvider ( p ) } 
func CssProviderNew ( ) ( * CssProvider , error ) { c := C . gtk_css_provider_new ( ) if c == nil { return nil , nilPtrErr } return wrapCssProvider ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * CssProvider ) LoadFromPath ( path string ) error { cpath := C . CString ( path ) defer C . free ( unsafe . Pointer ( cpath ) ) var gerr * C . GError if C . gtk_css_provider_load_from_path ( v . native ( ) , ( * C . gchar ) ( cpath ) , & gerr ) == 0 { defer C . g_error_free ( gerr ) return errors . New ( goString ( gerr . message ) ) } return nil } 
func ( v * CssProvider ) LoadFromData ( data string ) error { cdata := C . CString ( data ) defer C . free ( unsafe . Pointer ( cdata ) ) var gerr * C . GError if C . gtk_css_provider_load_from_data ( v . native ( ) , ( * C . gchar ) ( unsafe . Pointer ( cdata ) ) , C . gssize ( len ( data ) ) , & gerr ) == 0 { defer C . g_error_free ( gerr ) return errors . New ( goString ( gerr . message ) ) } return nil } 
func ( v * CssProvider ) ToString ( ) ( string , error ) { c := C . gtk_css_provider_to_string ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( c ) , nil } 
func CssProviderGetNamed ( name string , variant string ) ( * CssProvider , error ) { cname := C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) cvariant := C . CString ( variant ) defer C . free ( unsafe . Pointer ( cvariant ) ) c := C . gtk_css_provider_get_named ( ( * C . gchar ) ( cname ) , ( * C . gchar ) ( cvariant ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapCssProvider ( obj ) , nil } 
func ( v * Dialog ) native ( ) * C . GtkDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkDialog ( p ) } 
func DialogNew ( ) ( * Dialog , error ) { c := C . gtk_dialog_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapDialog ( obj ) , nil } 
func ( v * Dialog ) Run ( ) ResponseType { c := C . gtk_dialog_run ( v . native ( ) ) return ResponseType ( c ) } 
func ( v * Dialog ) Response ( response ResponseType ) { C . gtk_dialog_response ( v . native ( ) , C . gint ( response ) ) } 
func ( v * Dialog ) AddButton ( text string , id ResponseType ) ( * Button , error ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_dialog_add_button ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( id ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapButton ( obj ) , nil } 
func ( v * Dialog ) AddActionWidget ( child IWidget , id ResponseType ) { C . gtk_dialog_add_action_widget ( v . native ( ) , child . toWidget ( ) , C . gint ( id ) ) } 
func ( v * Dialog ) SetDefaultResponse ( id ResponseType ) { C . gtk_dialog_set_default_response ( v . native ( ) , C . gint ( id ) ) } 
func ( v * Dialog ) SetResponseSensitive ( id ResponseType , setting bool ) { C . gtk_dialog_set_response_sensitive ( v . native ( ) , C . gint ( id ) , gbool ( setting ) ) } 
func ( v * Dialog ) GetResponseForWidget ( widget IWidget ) ResponseType { c := C . gtk_dialog_get_response_for_widget ( v . native ( ) , widget . toWidget ( ) ) return ResponseType ( c ) } 
func ( v * Dialog ) GetWidgetForResponse ( id ResponseType ) ( * Widget , error ) { c := C . gtk_dialog_get_widget_for_response ( v . native ( ) , C . gint ( id ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( v * Dialog ) GetContentArea ( ) ( * Box , error ) { c := C . gtk_dialog_get_content_area ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) b := & Box { Container { Widget { glib . InitiallyUnowned { obj } } } } return b , nil } 
func ( v * DrawingArea ) native ( ) * C . GtkDrawingArea { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkDrawingArea ( p ) } 
func DrawingAreaNew ( ) ( * DrawingArea , error ) { c := C . gtk_drawing_area_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapDrawingArea ( obj ) , nil } 
func ( v * Editable ) native ( ) * C . GtkEditable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEditable ( p ) } 
func ( v * Editable ) SelectRegion ( startPos , endPos int ) { C . gtk_editable_select_region ( v . native ( ) , C . gint ( startPos ) , C . gint ( endPos ) ) } 
func ( v * Editable ) GetSelectionBounds ( ) ( start , end int , nonEmpty bool ) { var cstart , cend C . gint c := C . gtk_editable_get_selection_bounds ( v . native ( ) , & cstart , & cend ) return int ( cstart ) , int ( cend ) , gobool ( c ) } 
func ( v * Editable ) InsertText ( newText string , position int ) int { cstr := C . CString ( newText ) defer C . free ( unsafe . Pointer ( cstr ) ) pos := new ( C . gint ) * pos = C . gint ( position ) C . gtk_editable_insert_text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( newText ) ) , pos ) return int ( * pos ) } 
func ( v * Editable ) DeleteText ( startPos , endPos int ) { C . gtk_editable_delete_text ( v . native ( ) , C . gint ( startPos ) , C . gint ( endPos ) ) } 
func ( v * Editable ) GetChars ( startPos , endPos int ) string { c := C . gtk_editable_get_chars ( v . native ( ) , C . gint ( startPos ) , C . gint ( endPos ) ) defer C . free ( unsafe . Pointer ( c ) ) return goString ( c ) } 
func ( v * Editable ) GetPosition ( ) int { c := C . gtk_editable_get_position ( v . native ( ) ) return int ( c ) } 
func ( v * Editable ) SetEditable ( isEditable bool ) { C . gtk_editable_set_editable ( v . native ( ) , gbool ( isEditable ) ) } 
func ( v * Editable ) GetEditable ( ) bool { c := C . gtk_editable_get_editable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) native ( ) * C . GtkEntry { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEntry ( p ) } 
func EntryNew ( ) ( * Entry , error ) { c := C . gtk_entry_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapEntry ( obj ) , nil } 
func EntryNewWithBuffer ( buffer * EntryBuffer ) ( * Entry , error ) { c := C . gtk_entry_new_with_buffer ( buffer . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapEntry ( obj ) , nil } 
func ( v * Entry ) GetBuffer ( ) ( * EntryBuffer , error ) { c := C . gtk_entry_get_buffer ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & EntryBuffer { obj } , nil } 
func ( v * Entry ) SetBuffer ( buffer * EntryBuffer ) { C . gtk_entry_set_buffer ( v . native ( ) , buffer . native ( ) ) } 
func ( v * Entry ) SetText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) GetText ( ) ( string , error ) { c := C . gtk_entry_get_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Entry ) GetTextLength ( ) uint16 { c := C . gtk_entry_get_text_length ( v . native ( ) ) return uint16 ( c ) } 
func ( v * Entry ) SetVisibility ( visible bool ) { C . gtk_entry_set_visibility ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Entry ) SetInvisibleChar ( ch rune ) { C . gtk_entry_set_invisible_char ( v . native ( ) , C . gunichar ( ch ) ) } 
func ( v * Entry ) SetMaxLength ( len int ) { C . gtk_entry_set_max_length ( v . native ( ) , C . gint ( len ) ) } 
func ( v * Entry ) GetActivatesDefault ( ) bool { c := C . gtk_entry_get_activates_default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) GetHasFrame ( ) bool { c := C . gtk_entry_get_has_frame ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) GetWidthChars ( ) int { c := C . gtk_entry_get_width_chars ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) SetActivatesDefault ( setting bool ) { C . gtk_entry_set_activates_default ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Entry ) SetWidthChars ( nChars int ) { C . gtk_entry_set_width_chars ( v . native ( ) , C . gint ( nChars ) ) } 
func ( v * Entry ) GetInvisibleChar ( ) rune { c := C . gtk_entry_get_invisible_char ( v . native ( ) ) return rune ( c ) } 
func ( v * Entry ) SetAlignment ( xalign float32 ) { C . gtk_entry_set_alignment ( v . native ( ) , C . gfloat ( xalign ) ) } 
func ( v * Entry ) GetAlignment ( ) float32 { c := C . gtk_entry_get_alignment ( v . native ( ) ) return float32 ( c ) } 
func ( v * Entry ) SetPlaceholderText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_placeholder_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) GetPlaceholderText ( ) ( string , error ) { c := C . gtk_entry_get_placeholder_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Entry ) SetOverwriteMode ( overwrite bool ) { C . gtk_entry_set_overwrite_mode ( v . native ( ) , gbool ( overwrite ) ) } 
func ( v * Entry ) GetOverwriteMode ( ) bool { c := C . gtk_entry_get_overwrite_mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) GetLayoutOffsets ( ) ( x , y int ) { var gx , gy C . gint C . gtk_entry_get_layout_offsets ( v . native ( ) , & gx , & gy ) return int ( gx ) , int ( gy ) } 
func ( v * Entry ) LayoutIndexToTextIndex ( layoutIndex int ) int { c := C . gtk_entry_layout_index_to_text_index ( v . native ( ) , C . gint ( layoutIndex ) ) return int ( c ) } 
func ( v * Entry ) TextIndexToLayoutIndex ( textIndex int ) int { c := C . gtk_entry_text_index_to_layout_index ( v . native ( ) , C . gint ( textIndex ) ) return int ( c ) } 
func ( v * Entry ) GetMaxLength ( ) int { c := C . gtk_entry_get_max_length ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) GetVisibility ( ) bool { c := C . gtk_entry_get_visibility ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) SetCompletion ( completion * EntryCompletion ) { C . gtk_entry_set_completion ( v . native ( ) , completion . native ( ) ) } 
func ( v * Entry ) GetCompletion ( ) ( * EntryCompletion , error ) { c := C . gtk_entry_get_completion ( v . native ( ) ) if c == nil { return nil , nilPtrErr } e := & EntryCompletion { glib . Take ( unsafe . Pointer ( c ) ) } return e , nil } 
func ( v * Entry ) SetCursorHAdjustment ( adjustment * Adjustment ) { C . gtk_entry_set_cursor_hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Entry ) GetCursorHAdjustment ( ) ( * Adjustment , error ) { c := C . gtk_entry_get_cursor_hadjustment ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . InitiallyUnowned { obj } } , nil } 
func ( v * Entry ) SetProgressFraction ( fraction float64 ) { C . gtk_entry_set_progress_fraction ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * Entry ) GetProgressFraction ( ) float64 { c := C . gtk_entry_get_progress_fraction ( v . native ( ) ) return float64 ( c ) } 
func ( v * Entry ) SetProgressPulseStep ( fraction float64 ) { C . gtk_entry_set_progress_pulse_step ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * Entry ) GetProgressPulseStep ( ) float64 { c := C . gtk_entry_get_progress_pulse_step ( v . native ( ) ) return float64 ( c ) } 
func ( v * Entry ) SetIconFromPixbuf ( iconPos EntryIconPosition , pixbuf * gdk . Pixbuf ) { C . gtk_entry_set_icon_from_pixbuf ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Entry ) SetIconFromIconName ( iconPos EntryIconPosition , name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_icon_from_icon_name ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) RemoveIcon ( iconPos EntryIconPosition ) { C . gtk_entry_set_icon_from_icon_name ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , nil ) } 
func ( v * Entry ) GetIconStorageType ( iconPos EntryIconPosition ) ImageType { c := C . gtk_entry_get_icon_storage_type ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) return ImageType ( c ) } 
func ( v * Entry ) GetIconName ( iconPos EntryIconPosition ) ( string , error ) { c := C . gtk_entry_get_icon_name ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Entry ) SetIconActivatable ( iconPos EntryIconPosition , activatable bool ) { C . gtk_entry_set_icon_activatable ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , gbool ( activatable ) ) } 
func ( v * Entry ) GetIconActivatable ( iconPos EntryIconPosition ) bool { c := C . gtk_entry_get_icon_activatable ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) return gobool ( c ) } 
func ( v * Entry ) SetIconSensitive ( iconPos EntryIconPosition , sensitive bool ) { C . gtk_entry_set_icon_sensitive ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , gbool ( sensitive ) ) } 
func ( v * Entry ) GetIconSensitive ( iconPos EntryIconPosition ) bool { c := C . gtk_entry_get_icon_sensitive ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) return gobool ( c ) } 
func ( v * Entry ) GetIconAtPos ( x , y int ) int { c := C . gtk_entry_get_icon_at_pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) return int ( c ) } 
func ( v * Entry ) SetIconTooltipText ( iconPos EntryIconPosition , tooltip string ) { cstr := C . CString ( tooltip ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_icon_tooltip_text ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) GetIconTooltipText ( iconPos EntryIconPosition ) ( string , error ) { c := C . gtk_entry_get_icon_tooltip_text ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Entry ) SetIconTooltipMarkup ( iconPos EntryIconPosition , tooltip string ) { cstr := C . CString ( tooltip ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_set_icon_tooltip_markup ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) GetIconTooltipMarkup ( iconPos EntryIconPosition ) ( string , error ) { c := C . gtk_entry_get_icon_tooltip_markup ( v . native ( ) , C . GtkEntryIconPosition ( iconPos ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * Entry ) GetCurrentIconDragSource ( ) int { c := C . gtk_entry_get_current_icon_drag_source ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) SetInputPurpose ( purpose InputPurpose ) { C . gtk_entry_set_input_purpose ( v . native ( ) , C . GtkInputPurpose ( purpose ) ) } 
func ( v * Entry ) GetInputPurpose ( ) InputPurpose { c := C . gtk_entry_get_input_purpose ( v . native ( ) ) return InputPurpose ( c ) } 
func ( v * Entry ) SetInputHints ( hints InputHints ) { C . gtk_entry_set_input_hints ( v . native ( ) , C . GtkInputHints ( hints ) ) } 
func ( v * Entry ) GetInputHints ( ) InputHints { c := C . gtk_entry_get_input_hints ( v . native ( ) ) return InputHints ( c ) } 
func ( v * EntryBuffer ) native ( ) * C . GtkEntryBuffer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEntryBuffer ( p ) } 
func EntryBufferNew ( initialChars string , nInitialChars int ) ( * EntryBuffer , error ) { cstr := C . CString ( initialChars ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_entry_buffer_new ( ( * C . gchar ) ( cstr ) , C . gint ( nInitialChars ) ) if c == nil { return nil , nilPtrErr } e := wrapEntryBuffer ( glib . Take ( unsafe . Pointer ( c ) ) ) return e , nil } 
func ( v * EntryBuffer ) GetText ( ) ( string , error ) { c := C . gtk_entry_buffer_get_text ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return goString ( c ) , nil } 
func ( v * EntryBuffer ) SetText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_buffer_set_text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * EntryBuffer ) GetBytes ( ) uint { c := C . gtk_entry_buffer_get_bytes ( v . native ( ) ) return uint ( c ) } 
func ( v * EntryBuffer ) GetLength ( ) uint { c := C . gtk_entry_buffer_get_length ( v . native ( ) ) return uint ( c ) } 
func ( v * EntryBuffer ) GetMaxLength ( ) int { c := C . gtk_entry_buffer_get_max_length ( v . native ( ) ) return int ( c ) } 
func ( v * EntryBuffer ) SetMaxLength ( maxLength int ) { C . gtk_entry_buffer_set_max_length ( v . native ( ) , C . gint ( maxLength ) ) } 
func ( v * EntryBuffer ) InsertText ( position uint , text string ) uint { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_entry_buffer_insert_text ( v . native ( ) , C . guint ( position ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) return uint ( c ) } 
func ( v * EntryBuffer ) DeleteText ( position uint , nChars int ) uint { c := C . gtk_entry_buffer_delete_text ( v . native ( ) , C . guint ( position ) , C . gint ( nChars ) ) return uint ( c ) } 
func ( v * EntryBuffer ) EmitDeletedText ( pos , nChars uint ) { C . gtk_entry_buffer_emit_deleted_text ( v . native ( ) , C . guint ( pos ) , C . guint ( nChars ) ) } 
func ( v * EntryBuffer ) EmitInsertedText ( pos uint , text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_entry_buffer_emit_inserted_text ( v . native ( ) , C . guint ( pos ) , ( * C . gchar ) ( cstr ) , C . guint ( len ( text ) ) ) } 
func ( v * EntryCompletion ) native ( ) * C . GtkEntryCompletion { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEntryCompletion ( p ) } 
func ( v * EventBox ) native ( ) * C . GtkEventBox { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkEventBox ( p ) } 
func EventBoxNew ( ) ( * EventBox , error ) { c := C . gtk_event_box_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapEventBox ( obj ) , nil } 
func ( v * EventBox ) SetAboveChild ( aboveChild bool ) { C . gtk_event_box_set_above_child ( v . native ( ) , gbool ( aboveChild ) ) } 
func ( v * EventBox ) GetAboveChild ( ) bool { c := C . gtk_event_box_get_above_child ( v . native ( ) ) return gobool ( c ) } 
func ( v * EventBox ) SetVisibleWindow ( visibleWindow bool ) { C . gtk_event_box_set_visible_window ( v . native ( ) , gbool ( visibleWindow ) ) } 
func ( v * EventBox ) GetVisibleWindow ( ) bool { c := C . gtk_event_box_get_visible_window ( v . native ( ) ) return gobool ( c ) } 
func ( v * Expander ) native ( ) * C . GtkExpander { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkExpander ( p ) } 
func ExpanderNew ( label string ) ( * Expander , error ) { var cstr * C . gchar if label != " " { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } c := C . gtk_expander_new ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapExpander ( obj ) , nil } 
func ( v * Expander ) GetExpanded ( ) bool { c := C . gtk_expander_get_expanded ( v . native ( ) ) return gobool ( c ) } 
func ( v * Expander ) SetLabel ( label string ) { var cstr * C . char if label != " " { cstr = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } C . gtk_expander_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Expander ) GetLabel ( ) string { c := C . gtk_expander_get_label ( v . native ( ) ) return goString ( c ) } 
func ( v * Expander ) SetLabelWidget ( widget IWidget ) { C . gtk_expander_set_label_widget ( v . native ( ) , widget . toWidget ( ) ) } 
func ( v * FileChooser ) native ( ) * C . GtkFileChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooser ( p ) } 
func ( v * FileChooser ) SetFilename ( filename string ) bool { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_file_chooser_set_filename ( v . native ( ) , cstr ) return gobool ( c ) } 
func ( v * FileChooser ) GetFilename ( ) string { c := C . gtk_file_chooser_get_filename ( v . native ( ) ) s := goString ( c ) defer C . g_free ( ( C . gpointer ) ( c ) ) return s } 
func ( v * FileChooser ) GetFilenames ( ) ( * glib . SList , error ) { c := C . gtk_file_chooser_get_filenames ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return glib . WrapSList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v FileChooser ) GetURIs ( ) ( * glib . SList , error ) { c := C . gtk_file_chooser_get_uris ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return glib . WrapSList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * FileChooser ) SetDoOverwriteConfirmation ( value bool ) { C . gtk_file_chooser_set_do_overwrite_confirmation ( v . native ( ) , gbool ( value ) ) } 
func ( v * FileChooser ) GetDoOverwriteConfirmation ( ) bool { c := C . gtk_file_chooser_get_do_overwrite_confirmation ( v . native ( ) ) return gobool ( c ) } 
func ( v * FileChooser ) SetCreateFolders ( value bool ) { C . gtk_file_chooser_set_create_folders ( v . native ( ) , gbool ( value ) ) } 
func ( v * FileChooser ) GetCreateFolders ( ) bool { c := C . gtk_file_chooser_get_create_folders ( v . native ( ) ) return gobool ( c ) } 
func ( v * FileChooser ) SetCurrentName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_file_chooser_set_current_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return } 
func ( v * FileChooser ) SetCurrentFolder ( folder string ) bool { cstr := C . CString ( folder ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_file_chooser_set_current_folder ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( v * FileChooser ) GetCurrentFolder ( ) ( string , error ) { c := C . gtk_file_chooser_get_current_folder ( v . native ( ) ) if c == nil { return " " , nilPtrErr } defer C . free ( unsafe . Pointer ( c ) ) return goString ( c ) , nil } 
func ( v * FileChooser ) SetPreviewWidget ( widget IWidget ) { C . gtk_file_chooser_set_preview_widget ( v . native ( ) , widget . toWidget ( ) ) } 
func ( v * FileChooser ) SetPreviewWidgetActive ( active bool ) { C . gtk_file_chooser_set_preview_widget_active ( v . native ( ) , gbool ( active ) ) } 
func ( v * FileChooser ) GetPreviewFilename ( ) string { c := C . gtk_file_chooser_get_preview_filename ( v . native ( ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . GoString ( c ) } 
func ( v * FileChooser ) GetURI ( ) string { c := C . gtk_file_chooser_get_uri ( v . native ( ) ) s := goString ( c ) defer C . g_free ( ( C . gpointer ) ( c ) ) return s } 
func ( v * FileChooser ) AddFilter ( filter * FileFilter ) { C . gtk_file_chooser_add_filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * FileChooser ) RemoveFilter ( filter * FileFilter ) { C . gtk_file_chooser_remove_filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * FileChooser ) SetFilter ( filter * FileFilter ) { C . gtk_file_chooser_set_filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * FileChooser ) AddShortcutFolder ( folder string ) bool { cstr := C . CString ( folder ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_file_chooser_add_shortcut_folder ( v . native ( ) , cstr , nil ) return gobool ( c ) } 
func ( v * FileChooser ) SetLocalOnly ( value bool ) { C . gtk_file_chooser_set_local_only ( v . native ( ) , gbool ( value ) ) } 
func ( v * FileChooser ) GetLocalOnly ( ) bool { c := C . gtk_file_chooser_get_local_only ( v . native ( ) ) return gobool ( c ) } 
func ( v * FileChooser ) SetSelectMultiple ( value bool ) { C . gtk_file_chooser_set_select_multiple ( v . native ( ) , gbool ( value ) ) } 
func ( v * FileChooser ) GetSelectMultiple ( ) bool { c := C . gtk_file_chooser_get_select_multiple ( v . native ( ) ) return gobool ( c ) } 
func ( v * FileChooserButton ) native ( ) * C . GtkFileChooserButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooserButton ( p ) } 
func FileChooserButtonNew ( title string , action FileChooserAction ) ( * FileChooserButton , error ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_file_chooser_button_new ( ( * C . gchar ) ( cstr ) , ( C . GtkFileChooserAction ) ( action ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFileChooserButton ( obj ) , nil } 
func ( v * FileChooserDialog ) native ( ) * C . GtkFileChooserDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooserDialog ( p ) } 
func FileChooserDialogNewWith1Button ( title string , parent * Window , action FileChooserAction , first_button_text string , first_button_id ResponseType ) ( * FileChooserDialog , error ) { c_title := C . CString ( title ) defer C . free ( unsafe . Pointer ( c_title ) ) c_first_button_text := C . CString ( first_button_text ) defer C . free ( unsafe . Pointer ( c_first_button_text ) ) c := C . gtk_file_chooser_dialog_new_1 ( ( * C . gchar ) ( c_title ) , parent . native ( ) , C . GtkFileChooserAction ( action ) , ( * C . gchar ) ( c_first_button_text ) , C . int ( first_button_id ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFileChooserDialog ( obj ) , nil } 
func ( v * FileChooserWidget ) native ( ) * C . GtkFileChooserWidget { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileChooserWidget ( p ) } 
func FileChooserWidgetNew ( action FileChooserAction ) ( * FileChooserWidget , error ) { c := C . gtk_file_chooser_widget_new ( ( C . GtkFileChooserAction ) ( action ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFileChooserWidget ( obj ) , nil } 
func ( v * FileFilter ) native ( ) * C . GtkFileFilter { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFileFilter ( p ) } 
func FileFilterNew ( ) ( * FileFilter , error ) { c := C . gtk_file_filter_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFileFilter ( obj ) , nil } 
func ( v * FileFilter ) SetName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_file_filter_set_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * FileFilter ) AddPattern ( pattern string ) { cstr := C . CString ( pattern ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_file_filter_add_pattern ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Frame ) native ( ) * C . GtkFrame { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkFrame ( p ) } 
func FrameNew ( label string ) ( * Frame , error ) { var cstr * C . char if label != " " { cstr = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } c := C . gtk_frame_new ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapFrame ( obj ) , nil } 
func ( v * Frame ) SetLabel ( label string ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_frame_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Frame ) SetLabelWidget ( labelWidget IWidget ) { C . gtk_frame_set_label_widget ( v . native ( ) , labelWidget . toWidget ( ) ) } 
func ( v * Frame ) SetLabelAlign ( xAlign , yAlign float32 ) { C . gtk_frame_set_label_align ( v . native ( ) , C . gfloat ( xAlign ) , C . gfloat ( yAlign ) ) } 
func ( v * Frame ) SetShadowType ( t ShadowType ) { C . gtk_frame_set_shadow_type ( v . native ( ) , C . GtkShadowType ( t ) ) } 
func ( v * Frame ) GetLabel ( ) string { c := C . gtk_frame_get_label ( v . native ( ) ) return goString ( c ) } 
func ( v * Frame ) GetLabelAlign ( ) ( xAlign , yAlign float32 ) { var x , y C . gfloat C . gtk_frame_get_label_align ( v . native ( ) , & x , & y ) return float32 ( x ) , float32 ( y ) } 
func ( v * Frame ) GetLabelWidget ( ) ( * Widget , error ) { c := C . gtk_frame_get_label_widget ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( v * Frame ) GetShadowType ( ) ShadowType { c := C . gtk_frame_get_shadow_type ( v . native ( ) ) return ShadowType ( c ) } 
func ( v * AspectFrame ) native ( ) * C . GtkAspectFrame { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkAspectFrame ( p ) } 
func ( v * Grid ) native ( ) * C . GtkGrid { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkGrid ( p ) } 
func GridNew ( ) ( * Grid , error ) { c := C . gtk_grid_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapGrid ( obj ) , nil } 
func ( v * Grid ) Attach ( child IWidget , left , top , width , height int ) { C . gtk_grid_attach ( v . native ( ) , child . toWidget ( ) , C . gint ( left ) , C . gint ( top ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Grid ) AttachNextTo ( child , sibling IWidget , side PositionType , width , height int ) { C . gtk_grid_attach_next_to ( v . native ( ) , child . toWidget ( ) , sibling . toWidget ( ) , C . GtkPositionType ( side ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Grid ) GetChildAt ( left , top int ) ( * Widget , error ) { c := C . gtk_grid_get_child_at ( v . native ( ) , C . gint ( left ) , C . gint ( top ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) , nil } 
func ( v * Grid ) InsertRow ( position int ) { C . gtk_grid_insert_row ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) InsertColumn ( position int ) { C . gtk_grid_insert_column ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) InsertNextTo ( sibling IWidget , side PositionType ) { C . gtk_grid_insert_next_to ( v . native ( ) , sibling . toWidget ( ) , C . GtkPositionType ( side ) ) } 
func ( v * Grid ) SetRowHomogeneous ( homogeneous bool ) { C . gtk_grid_set_row_homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Grid ) GetRowHomogeneous ( ) bool { c := C . gtk_grid_get_row_homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Grid ) SetRowSpacing ( spacing uint ) { C . gtk_grid_set_row_spacing ( v . native ( ) , C . guint ( spacing ) ) } 
func ( v * Grid ) GetRowSpacing ( ) uint { c := C . gtk_grid_get_row_spacing ( v . native ( ) ) return uint ( c ) } 
func ( v * Grid ) SetColumnHomogeneous ( homogeneous bool ) { C . gtk_grid_set_column_homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Grid ) GetColumnHomogeneous ( ) bool { c := C . gtk_grid_get_column_homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Grid ) SetColumnSpacing ( spacing uint ) { C . gtk_grid_set_column_spacing ( v . native ( ) , C . guint ( spacing ) ) } 
func ( v * Grid ) GetColumnSpacing ( ) uint { c := C . gtk_grid_get_column_spacing ( v . native ( ) ) return uint ( c ) } 
func IconThemeGetDefault ( ) ( * IconTheme , error ) { c := C . gtk_icon_theme_get_default ( ) if c == nil { return nil , nilPtrErr } return & IconTheme { c } , nil } 
func IconThemeGetForScreen ( screen gdk . Screen ) ( * IconTheme , error ) { cScreen := ( * C . GdkScreen ) ( unsafe . Pointer ( screen . Native ( ) ) ) c := C . gtk_icon_theme_get_for_screen ( cScreen ) if c == nil { return nil , nilPtrErr } return & IconTheme { c } , nil } 
func ( v * IconTheme ) LoadIcon ( iconName string , size int , flags IconLookupFlags ) ( * gdk . Pixbuf , error ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c := C . gtk_icon_theme_load_icon ( v . Theme , ( * C . gchar ) ( cstr ) , C . gint ( size ) , C . GtkIconLookupFlags ( flags ) , & err ) if c == nil { defer C . g_error_free ( err ) return nil , errors . New ( goString ( err . message ) ) } return & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Image ) native ( ) * C . GtkImage { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkImage ( p ) } 
func ImageNew ( ) ( * Image , error ) { c := C . gtk_image_new ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapImage ( obj ) , nil } 
func ImageNewFromFile ( filename string ) ( * Image , error ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_image_new_from_file ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapImage ( obj ) , nil } 
func ImageNewFromResource ( resourcePath string ) ( * Image , error ) { cstr := C . CString ( resourcePath ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_image_new_from_resource ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapImage ( obj ) , nil } 
func ImageNewFromPixbuf ( pixbuf * gdk . Pixbuf ) ( * Image , error ) { c := C . gtk_image_new_from_pixbuf ( ( * C . GdkPixbuf ) ( pixbuf . NativePrivate ( ) ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapImage ( obj ) , nil } 
func ImageNewFromIconName ( iconName string , size IconSize ) ( * Image , error ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_image_new_from_icon_name ( ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapImage ( obj ) , nil } 
func ( v * Image ) SetFromFile ( filename string ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_image_set_from_file ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Image ) SetFromResource ( resourcePath string ) { cstr := C . CString ( resourcePath ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_image_set_from_resource ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Image ) SetFromPixbuf ( pixbuf * gdk . Pixbuf ) { pbptr := ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) C . gtk_image_set_from_pixbuf ( v . native ( ) , pbptr ) } 
func ( v * Image ) SetFromIconName ( iconName string , size IconSize ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_image_set_from_icon_name ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . GtkIconSize ( size ) ) } 
func ( v * Image ) SetPixelSize ( pixelSize int ) { C . gtk_image_set_pixel_size ( v . native ( ) , C . gint ( pixelSize ) ) } 
func ( v * Image ) GetStorageType ( ) ImageType { c := C . gtk_image_get_storage_type ( v . native ( ) ) return ImageType ( c ) } 
func ( v * Image ) GetPixbuf ( ) * gdk . Pixbuf { c := C . gtk_image_get_pixbuf ( v . native ( ) ) if c == nil { return nil } pb := & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return pb } 
func ( v * Image ) GetIconName ( ) ( string , IconSize ) { var iconName * C . gchar var size C . GtkIconSize C . gtk_image_get_icon_name ( v . native ( ) , & iconName , & size ) return goString ( iconName ) , IconSize ( size ) } 
func ( v * Image ) GetPixelSize ( ) int { c := C . gtk_image_get_pixel_size ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) native ( ) * C . GtkLayout { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLayout ( p ) } 
func LayoutNew ( hadjustment , vadjustment * Adjustment ) ( * Layout , error ) { c := C . gtk_layout_new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapLayout ( obj ) , nil } 
func ( v * Layout ) Put ( w IWidget , x , y int ) { C . gtk_layout_put ( v . native ( ) , w . toWidget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Layout ) Move ( w IWidget , x , y int ) { C . gtk_layout_move ( v . native ( ) , w . toWidget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Layout ) SetSize ( width , height uint ) { C . gtk_layout_set_size ( v . native ( ) , C . guint ( width ) , C . guint ( height ) ) } 
func ( v * Layout ) GetSize ( ) ( width , height uint ) { var w , h C . guint C . gtk_layout_get_size ( v . native ( ) , & w , & h ) return uint ( w ) , uint ( h ) } 
func ( v * LinkButton ) native ( ) * C . GtkLinkButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkLinkButton ( p ) } 
func LinkButtonNew ( label string ) ( * LinkButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_link_button_new ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapLinkButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func LinkButtonNewWithLabel ( uri , label string ) ( * LinkButton , error ) { curi := C . CString ( uri ) defer C . free ( unsafe . Pointer ( curi ) ) clabel := C . CString ( label ) defer C . free ( unsafe . Pointer ( clabel ) ) c := C . gtk_link_button_new_with_label ( ( * C . gchar ) ( curi ) , ( * C . gchar ) ( clabel ) ) if c == nil { return nil , nilPtrErr } return wrapLinkButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * LinkButton ) GetUri ( ) string { c := C . gtk_link_button_get_uri ( v . native ( ) ) return goString ( c ) } 
func ( v * LinkButton ) SetUri ( uri string ) { cstr := C . CString ( uri ) C . gtk_link_button_set_uri ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ListStore ) native ( ) * C . GtkListStore { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkListStore ( p ) } 
func ListStoreNew ( types ... glib . Type ) ( * ListStore , error ) { gtypes := C . alloc_types ( C . int ( len ( types ) ) ) for n , val := range types { C . set_type ( gtypes , C . int ( n ) , C . GType ( val ) ) } defer C . g_free ( C . gpointer ( gtypes ) ) c := C . gtk_list_store_newv ( C . gint ( len ( types ) ) , gtypes ) if c == nil { return nil , nilPtrErr } ls := wrapListStore ( glib . Take ( unsafe . Pointer ( c ) ) ) return ls , nil } 
func ( v * ListStore ) Remove ( iter * TreeIter ) bool { c := C . gtk_list_store_remove ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * ListStore ) Set ( iter * TreeIter , columns [ ] int , values [ ] interface { } ) error { if len ( columns ) != len ( values ) { return errors . New ( " " ) } for i , val := range values { v . SetValue ( iter , columns [ i ] , val ) } return nil } 
func ( v * ListStore ) SetValue ( iter * TreeIter , column int , value interface { } ) error { switch value . ( type ) { case * gdk . Pixbuf : pix := value . ( * gdk . Pixbuf ) C . _gtk_list_store_set ( v . native ( ) , iter . native ( ) , C . gint ( column ) , unsafe . Pointer ( pix . Native ( ) ) ) default : gv , err := glib . GValue ( value ) if err != nil { return err } C . gtk_list_store_set_value ( v . native ( ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) } return nil } 
func ( v * ListStore ) InsertWithValues ( iter * TreeIter , position int , inColumns [ ] int , inValues [ ] interface { } ) error { length := len ( inColumns ) if len ( inValues ) < length { length = len ( inValues ) } var cColumns [ ] C . gint var cValues [ ] C . GValue for i := 0 ; i < length ; i ++ { cColumns = append ( cColumns , C . gint ( inColumns [ i ] ) ) gv , err := glib . GValue ( inValues [ i ] ) if err != nil { return err } var cvp * C . GValue = ( * C . GValue ) ( gv . Native ( ) ) cValues = append ( cValues , * cvp ) } var cColumnsPointer * C . gint = & cColumns [ 0 ] var cValuesPointer * C . GValue = & cValues [ 0 ] C . gtk_list_store_insert_with_valuesv ( v . native ( ) , iter . native ( ) , C . gint ( position ) , cColumnsPointer , cValuesPointer , C . gint ( length ) ) return nil } 
func ( v * ListStore ) InsertBefore ( sibling * TreeIter ) * TreeIter { var ti C . GtkTreeIter C . gtk_list_store_insert_before ( v . native ( ) , & ti , sibling . native ( ) ) iter := & TreeIter { ti } return iter } 
func ( v * ListStore ) InsertAfter ( sibling * TreeIter ) * TreeIter { var ti C . GtkTreeIter C . gtk_list_store_insert_after ( v . native ( ) , & ti , sibling . native ( ) ) iter := & TreeIter { ti } return iter } 
func ( v * ListStore ) Prepend ( ) * TreeIter { var ti C . GtkTreeIter C . gtk_list_store_prepend ( v . native ( ) , & ti ) iter := & TreeIter { ti } return iter } 
func ( v * ListStore ) Append ( ) * TreeIter { var ti C . GtkTreeIter C . gtk_list_store_append ( v . native ( ) , & ti ) iter := & TreeIter { ti } return iter } 
func ( v * ListStore ) IterIsValid ( iter * TreeIter ) bool { c := C . gtk_list_store_iter_is_valid ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * ListStore ) Swap ( a , b * TreeIter ) { C . gtk_list_store_swap ( v . native ( ) , a . native ( ) , b . native ( ) ) } 
func ( v * ListStore ) MoveBefore ( iter , position * TreeIter ) { C . gtk_list_store_move_before ( v . native ( ) , iter . native ( ) , position . native ( ) ) } 
func ( v * ListStore ) MoveAfter ( iter , position * TreeIter ) { C . gtk_list_store_move_after ( v . native ( ) , iter . native ( ) , position . native ( ) ) } 
func ( v * MenuBar ) native ( ) * C . GtkMenuBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuBar ( p ) } 
func MenuBarNew ( ) ( * MenuBar , error ) { c := C . gtk_menu_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapMenuBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * MenuButton ) native ( ) * C . GtkMenuButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuButton ( p ) } 
func MenuButtonNew ( ) ( * MenuButton , error ) { c := C . gtk_menu_button_new ( ) if c == nil { return nil , nilPtrErr } return wrapMenuButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * MenuButton ) SetPopup ( menu IMenu ) { C . gtk_menu_button_set_popup ( v . native ( ) , menu . toWidget ( ) ) } 
func ( v * MenuButton ) GetPopup ( ) * Menu { c := C . gtk_menu_button_get_popup ( v . native ( ) ) if c == nil { return nil } return wrapMenu ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuButton ) SetMenuModel ( menuModel * glib . MenuModel ) { C . gtk_menu_button_set_menu_model ( v . native ( ) , C . toGMenuModel ( unsafe . Pointer ( menuModel . Native ( ) ) ) ) } 
func ( v * MenuButton ) GetMenuModel ( ) * glib . MenuModel { c := C . gtk_menu_button_get_menu_model ( v . native ( ) ) if c == nil { return nil } return & glib . MenuModel { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * MenuButton ) SetDirection ( direction ArrowType ) { C . gtk_menu_button_set_direction ( v . native ( ) , C . GtkArrowType ( direction ) ) } 
func ( v * MenuButton ) GetDirection ( ) ArrowType { c := C . gtk_menu_button_get_direction ( v . native ( ) ) return ArrowType ( c ) } 
func ( v * MenuButton ) SetAlignWidget ( alignWidget IWidget ) { C . gtk_menu_button_set_align_widget ( v . native ( ) , alignWidget . toWidget ( ) ) } 
func ( v * MenuButton ) GetAlignWidget ( ) * Widget { c := C . gtk_menu_button_get_align_widget ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * MenuItem ) native ( ) * C . GtkMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMenuItem ( p ) } 
func MenuItemNew ( ) ( * MenuItem , error ) { c := C . gtk_menu_item_new ( ) if c == nil { return nil , nilPtrErr } return wrapMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func MenuItemNewWithLabel ( label string ) ( * MenuItem , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_menu_item_new_with_label ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * MenuItem ) SetSubmenu ( submenu IWidget ) { C . gtk_menu_item_set_submenu ( v . native ( ) , submenu . toWidget ( ) ) } 
func ( v * MenuItem ) SetLabel ( label string ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_menu_item_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * MenuItem ) GetLabel ( ) string { l := C . gtk_menu_item_get_label ( v . native ( ) ) return goString ( l ) } 
func ( v * MessageDialog ) native ( ) * C . GtkMessageDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkMessageDialog ( p ) } 
func MessageDialogNew ( parent IWindow , flags DialogFlags , mType MessageType , buttons ButtonsType , format string , a ... interface { } ) * MessageDialog { s := fmt . Sprintf ( format , a ... ) cstr := C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) var w * C . GtkWindow = nil if parent != nil { w = parent . toWindow ( ) } c := C . _gtk_message_dialog_new ( w , C . GtkDialogFlags ( flags ) , C . GtkMessageType ( mType ) , C . GtkButtonsType ( buttons ) , cstr ) return wrapMessageDialog ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * MessageDialog ) SetMarkup ( str string ) { cstr := C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_message_dialog_set_markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * MessageDialog ) FormatSecondaryText ( format string , a ... interface { } ) { s := fmt . Sprintf ( format , a ... ) cstr := C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) C . _gtk_message_dialog_format_secondary_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) native ( ) * C . GtkNotebook { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkNotebook ( p ) } 
func NotebookNew ( ) ( * Notebook , error ) { c := C . gtk_notebook_new ( ) if c == nil { return nil , nilPtrErr } return wrapNotebook ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) AppendPage ( child IWidget , tabLabel IWidget ) int { cTabLabel := nullableWidget ( tabLabel ) c := C . gtk_notebook_append_page ( v . native ( ) , child . toWidget ( ) , cTabLabel ) return int ( c ) } 
func ( v * Notebook ) AppendPageMenu ( child IWidget , tabLabel IWidget , menuLabel IWidget ) int { c := C . gtk_notebook_append_page_menu ( v . native ( ) , child . toWidget ( ) , tabLabel . toWidget ( ) , menuLabel . toWidget ( ) ) return int ( c ) } 
func ( v * Notebook ) PrependPage ( child IWidget , tabLabel IWidget ) int { cTabLabel := nullableWidget ( tabLabel ) c := C . gtk_notebook_prepend_page ( v . native ( ) , child . toWidget ( ) , cTabLabel ) return int ( c ) } 
func ( v * Notebook ) PrependPageMenu ( child IWidget , tabLabel IWidget , menuLabel IWidget ) int { c := C . gtk_notebook_prepend_page_menu ( v . native ( ) , child . toWidget ( ) , tabLabel . toWidget ( ) , menuLabel . toWidget ( ) ) return int ( c ) } 
func ( v * Notebook ) InsertPage ( child IWidget , tabLabel IWidget , position int ) int { label := nullableWidget ( tabLabel ) c := C . gtk_notebook_insert_page ( v . native ( ) , child . toWidget ( ) , label , C . gint ( position ) ) return int ( c ) } 
func ( v * Notebook ) InsertPageMenu ( child IWidget , tabLabel IWidget , menuLabel IWidget , position int ) int { c := C . gtk_notebook_insert_page_menu ( v . native ( ) , child . toWidget ( ) , tabLabel . toWidget ( ) , menuLabel . toWidget ( ) , C . gint ( position ) ) return int ( c ) } 
func ( v * Notebook ) RemovePage ( pageNum int ) { C . gtk_notebook_remove_page ( v . native ( ) , C . gint ( pageNum ) ) } 
func ( v * Notebook ) PageNum ( child IWidget ) int { c := C . gtk_notebook_page_num ( v . native ( ) , child . toWidget ( ) ) return int ( c ) } 
func ( v * Notebook ) ReorderChild ( child IWidget , position int ) { C . gtk_notebook_reorder_child ( v . native ( ) , child . toWidget ( ) , C . gint ( position ) ) } 
func ( v * Notebook ) SetTabPos ( pos PositionType ) { C . gtk_notebook_set_tab_pos ( v . native ( ) , C . GtkPositionType ( pos ) ) } 
func ( v * Notebook ) SetShowTabs ( showTabs bool ) { C . gtk_notebook_set_show_tabs ( v . native ( ) , gbool ( showTabs ) ) } 
func ( v * Notebook ) SetShowBorder ( showBorder bool ) { C . gtk_notebook_set_show_border ( v . native ( ) , gbool ( showBorder ) ) } 
func ( v * Notebook ) GetCurrentPage ( ) int { c := C . gtk_notebook_get_current_page ( v . native ( ) ) return int ( c ) } 
func ( v * Notebook ) GetMenuLabel ( child IWidget ) ( * Widget , error ) { c := C . gtk_notebook_get_menu_label ( v . native ( ) , child . toWidget ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) GetNthPage ( pageNum int ) ( * Widget , error ) { c := C . gtk_notebook_get_nth_page ( v . native ( ) , C . gint ( pageNum ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) GetNPages ( ) int { c := C . gtk_notebook_get_n_pages ( v . native ( ) ) return int ( c ) } 
func ( v * Notebook ) SetMenuLabel ( child , menuLabel IWidget ) { C . gtk_notebook_set_menu_label ( v . native ( ) , child . toWidget ( ) , menuLabel . toWidget ( ) ) } 
func ( v * Notebook ) SetMenuLabelText ( child IWidget , menuText string ) { cstr := C . CString ( menuText ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_notebook_set_menu_label_text ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) SetTabLabel ( child , tabLabel IWidget ) { C . gtk_notebook_set_tab_label ( v . native ( ) , child . toWidget ( ) , tabLabel . toWidget ( ) ) } 
func ( v * Notebook ) SetTabLabelText ( child IWidget , tabText string ) { cstr := C . CString ( tabText ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_notebook_set_tab_label_text ( v . native ( ) , child . toWidget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) SetTabReorderable ( child IWidget , reorderable bool ) { C . gtk_notebook_set_tab_reorderable ( v . native ( ) , child . toWidget ( ) , gbool ( reorderable ) ) } 
func ( v * Notebook ) SetTabDetachable ( child IWidget , detachable bool ) { C . gtk_notebook_set_tab_detachable ( v . native ( ) , child . toWidget ( ) , gbool ( detachable ) ) } 
func ( v * Notebook ) GetMenuLabelText ( child IWidget ) ( string , error ) { c := C . gtk_notebook_get_menu_label_text ( v . native ( ) , child . toWidget ( ) ) if c == nil { return " " , errors . New ( " " ) } return goString ( c ) , nil } 
func ( v * Notebook ) GetScrollable ( ) bool { c := C . gtk_notebook_get_scrollable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) GetShowBorder ( ) bool { c := C . gtk_notebook_get_show_border ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) GetShowTabs ( ) bool { c := C . gtk_notebook_get_show_tabs ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) GetTabLabelText ( child IWidget ) ( string , error ) { c := C . gtk_notebook_get_tab_label_text ( v . native ( ) , child . toWidget ( ) ) if c == nil { return " " , errors . New ( " " ) } return goString ( c ) , nil } 
func ( v * Notebook ) GetTabPos ( ) PositionType { c := C . gtk_notebook_get_tab_pos ( v . native ( ) ) return PositionType ( c ) } 
func ( v * Notebook ) GetTabReorderable ( child IWidget ) bool { c := C . gtk_notebook_get_tab_reorderable ( v . native ( ) , child . toWidget ( ) ) return gobool ( c ) } 
func ( v * Notebook ) GetTabDetachable ( child IWidget ) bool { c := C . gtk_notebook_get_tab_detachable ( v . native ( ) , child . toWidget ( ) ) return gobool ( c ) } 
func ( v * Notebook ) SetGroupName ( groupName string ) { cstr := C . CString ( groupName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_notebook_set_group_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) GetGroupName ( ) ( string , error ) { c := C . gtk_notebook_get_group_name ( v . native ( ) ) if c == nil { return " " , errors . New ( " " ) } return goString ( c ) , nil } 
func ( v * Notebook ) SetActionWidget ( widget IWidget , packType PackType ) { C . gtk_notebook_set_action_widget ( v . native ( ) , widget . toWidget ( ) , C . GtkPackType ( packType ) ) } 
func ( v * Notebook ) GetActionWidget ( packType PackType ) ( * Widget , error ) { c := C . gtk_notebook_get_action_widget ( v . native ( ) , C . GtkPackType ( packType ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * OffscreenWindow ) native ( ) * C . GtkOffscreenWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOffscreenWindow ( p ) } 
func OffscreenWindowNew ( ) ( * OffscreenWindow , error ) { c := C . gtk_offscreen_window_new ( ) if c == nil { return nil , nilPtrErr } return wrapOffscreenWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * OffscreenWindow ) GetSurface ( ) ( * cairo . Surface , error ) { c := C . gtk_offscreen_window_get_surface ( v . native ( ) ) if c == nil { return nil , nilPtrErr } cairoPtr := ( uintptr ) ( unsafe . Pointer ( c ) ) s := cairo . NewSurface ( cairoPtr , true ) return s , nil } 
func ( v * OffscreenWindow ) GetPixbuf ( ) ( * gdk . Pixbuf , error ) { c := C . gtk_offscreen_window_get_pixbuf ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return pb , nil } 
func ( v * Orientable ) native ( ) * C . GtkOrientable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOrientable ( p ) } 
func ( v * Orientable ) GetOrientation ( ) Orientation { c := C . gtk_orientable_get_orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * Orientable ) SetOrientation ( orientation Orientation ) { C . gtk_orientable_set_orientation ( v . native ( ) , C . GtkOrientation ( orientation ) ) } 
func ( v * Overlay ) native ( ) * C . GtkOverlay { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkOverlay ( p ) } 
func OverlayNew ( ) ( * Overlay , error ) { c := C . gtk_overlay_new ( ) if c == nil { return nil , nilPtrErr } return wrapOverlay ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Overlay ) AddOverlay ( widget IWidget ) { C . gtk_overlay_add_overlay ( v . native ( ) , widget . toWidget ( ) ) } 
func ( v * Paned ) native ( ) * C . GtkPaned { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkPaned ( p ) } 
func PanedNew ( orientation Orientation ) ( * Paned , error ) { c := C . gtk_paned_new ( C . GtkOrientation ( orientation ) ) if c == nil { return nil , nilPtrErr } return wrapPaned ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) Add1 ( child IWidget ) { C . gtk_paned_add1 ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Paned ) Add2 ( child IWidget ) { C . gtk_paned_add2 ( v . native ( ) , child . toWidget ( ) ) } 
func ( v * Paned ) Pack1 ( child IWidget , resize , shrink bool ) { C . gtk_paned_pack1 ( v . native ( ) , child . toWidget ( ) , gbool ( resize ) , gbool ( shrink ) ) } 
func ( v * Paned ) Pack2 ( child IWidget , resize , shrink bool ) { C . gtk_paned_pack2 ( v . native ( ) , child . toWidget ( ) , gbool ( resize ) , gbool ( shrink ) ) } 
func ( v * Paned ) SetPosition ( position int ) { C . gtk_paned_set_position ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Paned ) GetChild1 ( ) ( * Widget , error ) { c := C . gtk_paned_get_child1 ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) GetChild2 ( ) ( * Widget , error ) { c := C . gtk_paned_get_child2 ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) GetHandleWindow ( ) ( * Window , error ) { c := C . gtk_paned_get_handle_window ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ProgressBar ) native ( ) * C . GtkProgressBar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkProgressBar ( p ) } 
func ProgressBarNew ( ) ( * ProgressBar , error ) { c := C . gtk_progress_bar_new ( ) if c == nil { return nil , nilPtrErr } return wrapProgressBar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ProgressBar ) SetFraction ( fraction float64 ) { C . gtk_progress_bar_set_fraction ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * ProgressBar ) GetFraction ( ) float64 { c := C . gtk_progress_bar_get_fraction ( v . native ( ) ) return float64 ( c ) } 
func ( v * ProgressBar ) SetShowText ( showText bool ) { C . gtk_progress_bar_set_show_text ( v . native ( ) , gbool ( showText ) ) } 
func ( v * ProgressBar ) GetShowText ( ) bool { c := C . gtk_progress_bar_get_show_text ( v . native ( ) ) return gobool ( c ) } 
func ( v * ProgressBar ) SetText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_progress_bar_set_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ProgressBar ) GetPulseStep ( ) float64 { c := C . gtk_progress_bar_get_pulse_step ( v . native ( ) ) return float64 ( c ) } 
func ( v * ProgressBar ) SetInverted ( inverted bool ) { C . gtk_progress_bar_set_inverted ( v . native ( ) , gbool ( inverted ) ) } 
func ( v * ProgressBar ) GetInverted ( ) bool { c := C . gtk_progress_bar_get_inverted ( v . native ( ) ) return gobool ( c ) } 
func ( v * RadioButton ) native ( ) * C . GtkRadioButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRadioButton ( p ) } 
func RadioButtonNew ( group * glib . SList ) ( * RadioButton , error ) { c := C . gtk_radio_button_new ( cGSList ( group ) ) if c == nil { return nil , nilPtrErr } return wrapRadioButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioButtonNewFromWidget ( radioGroupMember * RadioButton ) ( * RadioButton , error ) { c := C . gtk_radio_button_new_from_widget ( radioGroupMember . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapRadioButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioButtonNewWithLabel ( group * glib . SList , label string ) ( * RadioButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_radio_button_new_with_label ( cGSList ( group ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapRadioButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioButtonNewWithLabelFromWidget ( radioGroupMember * RadioButton , label string ) ( * RadioButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) var cradio * C . GtkRadioButton if radioGroupMember != nil { cradio = radioGroupMember . native ( ) } c := C . gtk_radio_button_new_with_label_from_widget ( cradio , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapRadioButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * RadioButton ) SetGroup ( group * glib . SList ) { C . gtk_radio_button_set_group ( v . native ( ) , cGSList ( group ) ) } 
func ( v * RadioButton ) GetGroup ( ) ( * glib . SList , error ) { c := C . gtk_radio_button_get_group ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return glib . WrapSList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * RadioButton ) JoinGroup ( groupSource * RadioButton ) { var cgroup * C . GtkRadioButton if groupSource != nil { cgroup = groupSource . native ( ) } C . gtk_radio_button_join_group ( v . native ( ) , cgroup ) } 
func ( v * RadioMenuItem ) native ( ) * C . GtkRadioMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRadioMenuItem ( p ) } 
func RadioMenuItemNew ( group * glib . SList ) ( * RadioMenuItem , error ) { c := C . gtk_radio_menu_item_new ( cGSList ( group ) ) if c == nil { return nil , nilPtrErr } return wrapRadioMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioMenuItemNewWithLabel ( group * glib . SList , label string ) ( * RadioMenuItem , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_radio_menu_item_new_with_label ( cGSList ( group ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapRadioMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioMenuItemNewFromWidget ( group * RadioMenuItem ) ( * RadioMenuItem , error ) { c := C . gtk_radio_menu_item_new_from_widget ( group . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapRadioMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func RadioMenuItemNewWithLabelFromWidget ( group * RadioMenuItem , label string ) ( * RadioMenuItem , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_radio_menu_item_new_with_label_from_widget ( group . native ( ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapRadioMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * RadioMenuItem ) SetGroup ( group * glib . SList ) { C . gtk_radio_menu_item_set_group ( v . native ( ) , cGSList ( group ) ) } 
func ( v * RadioMenuItem ) GetGroup ( ) ( * glib . SList , error ) { c := C . gtk_radio_menu_item_get_group ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return glib . WrapSList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Range ) native ( ) * C . GtkRange { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRange ( p ) } 
func ( v * Range ) GetValue ( ) float64 { c := C . gtk_range_get_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * Range ) SetValue ( value float64 ) { C . gtk_range_set_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Range ) SetIncrements ( step , page float64 ) { C . gtk_range_set_increments ( v . native ( ) , C . gdouble ( step ) , C . gdouble ( page ) ) } 
func ( v * Range ) SetRange ( min , max float64 ) { C . gtk_range_set_range ( v . native ( ) , C . gdouble ( min ) , C . gdouble ( max ) ) } 
func ( v * RecentChooser ) native ( ) * C . GtkRecentChooser { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRecentChooser ( p ) } 
func ( v * RecentChooserMenu ) native ( ) * C . GtkRecentChooserMenu { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRecentChooserMenu ( p ) } 
func ( v * RecentFilter ) native ( ) * C . GtkRecentFilter { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRecentFilter ( p ) } 
func RecentFilterNew ( ) ( * RecentFilter , error ) { c := C . gtk_recent_filter_new ( ) if c == nil { return nil , nilPtrErr } return wrapRecentFilter ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * RecentManager ) native ( ) * C . GtkRecentManager { if v == nil || v . Object == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkRecentManager ( p ) } 
func RecentManagerGetDefault ( ) ( * RecentManager , error ) { c := C . gtk_recent_manager_get_default ( ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) v := wrapRecentManager ( obj ) return v , nil } 
func ( v * RecentManager ) AddItem ( fileURI string ) bool { cstr := C . CString ( fileURI ) defer C . free ( unsafe . Pointer ( cstr ) ) cok := C . gtk_recent_manager_add_item ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( cok ) } 
func ( v * Scale ) native ( ) * C . GtkScale { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScale ( p ) } 
func ScaleNew ( orientation Orientation , adjustment * Adjustment ) ( * Scale , error ) { c := C . gtk_scale_new ( C . GtkOrientation ( orientation ) , adjustment . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapScale ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ScaleNewWithRange ( orientation Orientation , min , max , step float64 ) ( * Scale , error ) { c := C . gtk_scale_new_with_range ( C . GtkOrientation ( orientation ) , C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) ) if c == nil { return nil , nilPtrErr } return wrapScale ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scale ) SetDrawValue ( drawValue bool ) { C . gtk_scale_set_draw_value ( v . native ( ) , gbool ( drawValue ) ) } 
func ( v * ScaleButton ) native ( ) * C . GtkScaleButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScaleButton ( p ) } 
func ScaleButtonNew ( size IconSize , min , max , step float64 , icons [ ] string ) ( * ScaleButton , error ) { cicons := make ( [ ] * C . gchar , len ( icons ) ) for i , icon := range icons { cicons [ i ] = ( * C . gchar ) ( C . CString ( icon ) ) defer C . free ( unsafe . Pointer ( cicons [ i ] ) ) } cicons = append ( cicons , nil ) c := C . gtk_scale_button_new ( C . GtkIconSize ( size ) , C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) , & cicons [ 0 ] ) if c == nil { return nil , nilPtrErr } return wrapScaleButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ScaleButton ) GetAdjustment ( ) * Adjustment { c := C . gtk_scale_button_get_adjustment ( v . native ( ) ) obj := glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . InitiallyUnowned { obj } } } 
func ( v * ScaleButton ) GetPopup ( ) ( * Widget , error ) { c := C . gtk_scale_button_get_popup ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ScaleButton ) SetAdjustment ( adjustment * Adjustment ) { C . gtk_scale_button_set_adjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * ScaleButton ) SetValue ( value float64 ) { C . gtk_scale_button_set_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Scrollable ) native ( ) * C . GtkScrollable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScrollable ( p ) } 
func ( v * Scrollable ) SetHAdjustment ( adjustment * Adjustment ) { C . gtk_scrollable_set_hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrollable ) GetHAdjustment ( ) ( * Adjustment , error ) { c := C . gtk_scrollable_get_hadjustment ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapAdjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrollable ) SetVAdjustment ( adjustment * Adjustment ) { C . gtk_scrollable_set_vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrollable ) GetVAdjustment ( ) ( * Adjustment , error ) { c := C . gtk_scrollable_get_vadjustment ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapAdjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrollbar ) native ( ) * C . GtkScrollbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScrollbar ( p ) } 
func ScrollbarNew ( orientation Orientation , adjustment * Adjustment ) ( * Scrollbar , error ) { c := C . gtk_scrollbar_new ( C . GtkOrientation ( orientation ) , adjustment . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapScrollbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ScrolledWindow ) native ( ) * C . GtkScrolledWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkScrolledWindow ( p ) } 
func ScrolledWindowNew ( hadjustment , vadjustment * Adjustment ) ( * ScrolledWindow , error ) { c := C . gtk_scrolled_window_new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapScrolledWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ScrolledWindow ) SetPolicy ( hScrollbarPolicy , vScrollbarPolicy PolicyType ) { C . gtk_scrolled_window_set_policy ( v . native ( ) , C . GtkPolicyType ( hScrollbarPolicy ) , C . GtkPolicyType ( vScrollbarPolicy ) ) } 
func ( v * ScrolledWindow ) GetHAdjustment ( ) * Adjustment { c := C . gtk_scrolled_window_get_hadjustment ( v . native ( ) ) if c == nil { return nil } return wrapAdjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ScrolledWindow ) SetHAdjustment ( adjustment * Adjustment ) { C . gtk_scrolled_window_set_hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * ScrolledWindow ) GetVAdjustment ( ) * Adjustment { c := C . gtk_scrolled_window_get_vadjustment ( v . native ( ) ) if c == nil { return nil } return wrapAdjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ScrolledWindow ) SetVAdjustment ( adjustment * Adjustment ) { C . gtk_scrolled_window_set_vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * ScrolledWindow ) GetShadowType ( ) ShadowType { c := C . gtk_scrolled_window_get_shadow_type ( v . native ( ) ) return ShadowType ( c ) } 
func ( v * ScrolledWindow ) SetShadowType ( t ShadowType ) { C . gtk_scrolled_window_set_shadow_type ( v . native ( ) , C . GtkShadowType ( t ) ) } 
func ( v * SearchEntry ) native ( ) * C . GtkSearchEntry { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSearchEntry ( p ) } 
func SearchEntryNew ( ) ( * SearchEntry , error ) { c := C . gtk_search_entry_new ( ) if c == nil { return nil , nilPtrErr } return wrapSearchEntry ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SelectionData ) native ( ) * C . GtkSelectionData { if v == nil { return nil } return v . GtkSelectionData } 
func ( v * SelectionData ) GetData ( ) ( data [ ] byte ) { var length C . gint c := C . gtk_selection_data_get_data_with_length ( v . native ( ) , & length ) sliceHeader := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & data ) ) sliceHeader . Data = uintptr ( unsafe . Pointer ( c ) ) sliceHeader . Len = int ( length ) sliceHeader . Cap = int ( length ) return } 
func GetData ( pointer uintptr ) ( data [ ] byte ) { c := ( * C . GValue ) ( unsafe . Pointer ( pointer ) ) p := ( * C . GtkSelectionData ) ( unsafe . Pointer ( c ) ) C . gtk_selection_data_get_text ( p ) var byteData [ ] byte var length C . gint cptr := C . gtk_selection_data_get_data_with_length ( p , & length ) sliceHeader := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & byteData ) ) sliceHeader . Data = uintptr ( unsafe . Pointer ( cptr ) ) sliceHeader . Len = int ( length ) sliceHeader . Cap = int ( length ) return byteData } 
func SetData ( pointer uintptr , atom gdk . Atom , data [ ] byte ) { c := ( * C . GValue ) ( unsafe . Pointer ( pointer ) ) p := ( * C . GtkSelectionData ) ( unsafe . Pointer ( c ) ) C . gtk_selection_data_set ( p , C . GdkAtom ( unsafe . Pointer ( atom ) ) , C . gint ( 8 ) , ( * C . guchar ) ( unsafe . Pointer ( & data [ 0 ] ) ) , C . gint ( len ( data ) ) ) } 
func DragSetIconPixbuf ( context * gdk . DragContext , pixbuf * gdk . Pixbuf , hot_x int , hot_y int ) { ctx := unsafe . Pointer ( context . Native ( ) ) pix := unsafe . Pointer ( pixbuf . Native ( ) ) C . gtk_drag_set_icon_pixbuf ( ( * C . GdkDragContext ) ( ctx ) , ( * C . GdkPixbuf ) ( pix ) , C . gint ( hot_x ) , C . gint ( hot_y ) ) } 
func ( v * Separator ) native ( ) * C . GtkSeparator { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSeparator ( p ) } 
func SeparatorNew ( orientation Orientation ) ( * Separator , error ) { c := C . gtk_separator_new ( C . GtkOrientation ( orientation ) ) if c == nil { return nil , nilPtrErr } return wrapSeparator ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SeparatorMenuItem ) native ( ) * C . GtkSeparatorMenuItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSeparatorMenuItem ( p ) } 
func SeparatorMenuItemNew ( ) ( * SeparatorMenuItem , error ) { c := C . gtk_separator_menu_item_new ( ) if c == nil { return nil , nilPtrErr } return wrapSeparatorMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SeparatorToolItem ) native ( ) * C . GtkSeparatorToolItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSeparatorToolItem ( p ) } 
func SeparatorToolItemNew ( ) ( * SeparatorToolItem , error ) { c := C . gtk_separator_tool_item_new ( ) if c == nil { return nil , nilPtrErr } return wrapSeparatorToolItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SeparatorToolItem ) SetDraw ( draw bool ) { C . gtk_separator_tool_item_set_draw ( v . native ( ) , gbool ( draw ) ) } 
func ( v * SeparatorToolItem ) GetDraw ( ) bool { c := C . gtk_separator_tool_item_get_draw ( v . native ( ) ) return gobool ( c ) } 
func ( v * SizeGroup ) native ( ) * C . GtkSizeGroup { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSizeGroup ( p ) } 
func SizeGroupNew ( mode SizeGroupMode ) ( * SizeGroup , error ) { c := C . gtk_size_group_new ( C . GtkSizeGroupMode ( mode ) ) if c == nil { return nil , nilPtrErr } return wrapSizeGroup ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SpinButton ) native ( ) * C . GtkSpinButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSpinButton ( p ) } 
func ( v * SpinButton ) Configure ( adjustment * Adjustment , climbRate float64 , digits uint ) { C . gtk_spin_button_configure ( v . native ( ) , adjustment . native ( ) , C . gdouble ( climbRate ) , C . guint ( digits ) ) } 
func SpinButtonNew ( adjustment * Adjustment , climbRate float64 , digits uint ) ( * SpinButton , error ) { c := C . gtk_spin_button_new ( adjustment . native ( ) , C . gdouble ( climbRate ) , C . guint ( digits ) ) if c == nil { return nil , nilPtrErr } return wrapSpinButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func SpinButtonNewWithRange ( min , max , step float64 ) ( * SpinButton , error ) { c := C . gtk_spin_button_new_with_range ( C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) ) if c == nil { return nil , nilPtrErr } return wrapSpinButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SpinButton ) GetValueAsInt ( ) int { c := C . gtk_spin_button_get_value_as_int ( v . native ( ) ) return int ( c ) } 
func ( v * SpinButton ) SetValue ( value float64 ) { C . gtk_spin_button_set_value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * SpinButton ) GetValue ( ) float64 { c := C . gtk_spin_button_get_value ( v . native ( ) ) return float64 ( c ) } 
func ( v * SpinButton ) GetAdjustment ( ) * Adjustment { c := C . gtk_spin_button_get_adjustment ( v . native ( ) ) if c == nil { return nil } return wrapAdjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * SpinButton ) SetRange ( min , max float64 ) { C . gtk_spin_button_set_range ( v . native ( ) , C . gdouble ( min ) , C . gdouble ( max ) ) } 
func ( v * Spinner ) native ( ) * C . GtkSpinner { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSpinner ( p ) } 
func SpinnerNew ( ) ( * Spinner , error ) { c := C . gtk_spinner_new ( ) if c == nil { return nil , nilPtrErr } return wrapSpinner ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Statusbar ) native ( ) * C . GtkStatusbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkStatusbar ( p ) } 
func StatusbarNew ( ) ( * Statusbar , error ) { c := C . gtk_statusbar_new ( ) if c == nil { return nil , nilPtrErr } return wrapStatusbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Statusbar ) GetContextId ( contextDescription string ) uint { cstr := C . CString ( contextDescription ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_statusbar_get_context_id ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return uint ( c ) } 
func ( v * Statusbar ) Push ( contextID uint , text string ) uint { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_statusbar_push ( v . native ( ) , C . guint ( contextID ) , ( * C . gchar ) ( cstr ) ) return uint ( c ) } 
func ( v * Statusbar ) Pop ( contextID uint ) { C . gtk_statusbar_pop ( v . native ( ) , C . guint ( contextID ) ) } 
func ( v * Statusbar ) GetMessageArea ( ) ( * Box , error ) { c := C . gtk_statusbar_get_message_area ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return & Box { Container { Widget { glib . InitiallyUnowned { obj } } } } , nil } 
func ( v * Switch ) native ( ) * C . GtkSwitch { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkSwitch ( p ) } 
func SwitchNew ( ) ( * Switch , error ) { c := C . gtk_switch_new ( ) if c == nil { return nil , nilPtrErr } return wrapSwitch ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Switch ) GetActive ( ) bool { c := C . gtk_switch_get_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Switch ) SetActive ( isActive bool ) { C . gtk_switch_set_active ( v . native ( ) , gbool ( isActive ) ) } 
func TargetEntryNew ( target string , flags TargetFlags , info uint ) ( * TargetEntry , error ) { cstr := C . CString ( target ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_target_entry_new ( ( * C . gchar ) ( cstr ) , C . guint ( flags ) , C . guint ( info ) ) if c == nil { return nil , nilPtrErr } t := ( * TargetEntry ) ( unsafe . Pointer ( c ) ) } 
func ( v * TextTag ) native ( ) * C . GtkTextTag { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTextTag ( p ) } 
func ( v * TextTag ) Event ( eventObject * glib . Object , event * gdk . Event , iter * TextIter ) bool { ok := C . gtk_text_tag_event ( v . native ( ) , ( * C . GObject ) ( unsafe . Pointer ( eventObject . Native ( ) ) ) , ( * C . GdkEvent ) ( unsafe . Pointer ( event . Native ( ) ) ) , ( * C . GtkTextIter ) ( iter ) , ) return gobool ( ok ) } 
func ( v * TextTagTable ) native ( ) * C . GtkTextTagTable { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTextTagTable ( p ) } 
func ( v * TextTagTable ) Add ( tag * TextTag ) { C . gtk_text_tag_table_add ( v . native ( ) , tag . native ( ) ) 
func ( v * TextTagTable ) Lookup ( name string ) ( * TextTag , error ) { cname := C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) c := C . gtk_text_tag_table_lookup ( v . native ( ) , ( * C . gchar ) ( cname ) ) if c == nil { return nil , nilPtrErr } return wrapTextTag ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TextTagTable ) Remove ( tag * TextTag ) { C . gtk_text_tag_table_remove ( v . native ( ) , tag . native ( ) ) } 
func ( v * TextBuffer ) native ( ) * C . GtkTextBuffer { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTextBuffer ( p ) } 
func TextBufferNew ( table * TextTagTable ) ( * TextBuffer , error ) { c := C . gtk_text_buffer_new ( table . native ( ) ) if c == nil { return nil , nilPtrErr } e := wrapTextBuffer ( glib . Take ( unsafe . Pointer ( c ) ) ) return e , nil } 
func ( v * TextBuffer ) ApplyTag ( tag * TextTag , start , end * TextIter ) { C . gtk_text_buffer_apply_tag ( v . native ( ) , tag . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) ApplyTagByName ( name string , start , end * TextIter ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_text_buffer_apply_tag_by_name ( v . native ( ) , ( * C . gchar ) ( cstr ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) SelectRange ( start , end * TextIter ) { C . gtk_text_buffer_select_range ( v . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) CreateChildAnchor ( iter * TextIter ) * TextChildAnchor { ret := C . gtk_text_buffer_create_child_anchor ( v . native ( ) , iter . native ( ) ) return ( * TextChildAnchor ) ( ret ) } 
func ( v * TextBuffer ) Delete ( start , end * TextIter ) { C . gtk_text_buffer_delete ( v . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) GetIterAtOffset ( charOffset int ) * TextIter { var iter C . GtkTextIter C . gtk_text_buffer_get_iter_at_offset ( v . native ( ) , & iter , C . gint ( charOffset ) ) return ( * TextIter ) ( & iter ) } 
func ( v * TextBuffer ) GetIterAtLine ( line int ) * TextIter { var iter C . GtkTextIter C . gtk_text_buffer_get_iter_at_line ( v . native ( ) , & iter , C . gint ( line ) ) return ( * TextIter ) ( & iter ) } 
func ( v * TextBuffer ) GetStartIter ( ) * TextIter { var iter C . GtkTextIter C . gtk_text_buffer_get_start_iter ( v . native ( ) , & iter ) return ( * TextIter ) ( & iter ) } 
func ( v * TextBuffer ) GetEndIter ( ) * TextIter { var iter C . GtkTextIter C . gtk_text_buffer_get_end_iter ( v . native ( ) , & iter ) return ( * TextIter ) ( & iter ) } 
func ( v * TextBuffer ) GetTagTable ( ) ( * TextTagTable , error ) { c := C . gtk_text_buffer_get_tag_table ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapTextTagTable ( obj ) , nil } 
func ( v * TextBuffer ) Insert ( iter * TextIter , text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_text_buffer_insert ( v . native ( ) , ( * C . GtkTextIter ) ( iter ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * TextBuffer ) InsertPixbuf ( iter * TextIter , pixbuf * gdk . Pixbuf ) { C . gtk_text_buffer_insert_pixbuf ( v . native ( ) , ( * C . GtkTextIter ) ( iter ) , ( * C . GdkPixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * TextBuffer ) InsertAtCursor ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_text_buffer_insert_at_cursor ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * TextBuffer ) RemoveTag ( tag * TextTag , start , end * TextIter ) { C . gtk_text_buffer_remove_tag ( v . native ( ) , tag . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) RemoveAllTags ( start , end * TextIter ) { C . gtk_text_buffer_remove_all_tags ( v . native ( ) , ( * C . GtkTextIter ) ( start ) , ( * C . GtkTextIter ) ( end ) ) } 
func ( v * TextBuffer ) GetIterAtMark ( mark * TextMark ) * TextIter { var iter C . GtkTextIter C . gtk_text_buffer_get_iter_at_mark ( v . native ( ) , & iter , ( * C . GtkTextMark ) ( mark ) ) return ( * TextIter ) ( & iter ) } 
func ( v * TextBuffer ) CreateMark ( mark_name string , where * TextIter , left_gravity bool ) * TextMark { cstr := C . CString ( mark_name ) defer C . free ( unsafe . Pointer ( cstr ) ) ret := C . gtk_text_buffer_create_mark ( v . native ( ) , ( * C . gchar ) ( cstr ) , ( * C . GtkTextIter ) ( where ) , gbool ( left_gravity ) ) return ( * TextMark ) ( ret ) } 
func ( v * TextBuffer ) GetMark ( mark_name string ) * TextMark { cstr := C . CString ( mark_name ) defer C . free ( unsafe . Pointer ( cstr ) ) ret := C . gtk_text_buffer_get_mark ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return ( * TextMark ) ( ret ) } 
func ( v * ToggleButton ) native ( ) * C . GtkToggleButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToggleButton ( p ) } 
func ToggleButtonNew ( ) ( * ToggleButton , error ) { c := C . gtk_toggle_button_new ( ) if c == nil { return nil , nilPtrErr } return wrapToggleButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ToggleButtonNewWithLabel ( label string ) ( * ToggleButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_toggle_button_new_with_label ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapToggleButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ToggleButton ) GetActive ( ) bool { c := C . gtk_toggle_button_get_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToggleButton ) SetActive ( isActive bool ) { C . gtk_toggle_button_set_active ( v . native ( ) , gbool ( isActive ) ) } 
func ( v * ToggleButton ) GetMode ( ) bool { c := C . gtk_toggle_button_get_mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToggleButton ) SetMode ( drawIndicator bool ) { C . gtk_toggle_button_set_mode ( v . native ( ) , gbool ( drawIndicator ) ) } 
func ( v * Toolbar ) native ( ) * C . GtkToolbar { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolbar ( p ) } 
func ToolbarNew ( ) ( * Toolbar , error ) { c := C . gtk_toolbar_new ( ) if c == nil { return nil , nilPtrErr } return wrapToolbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Toolbar ) Insert ( item IToolItem , pos int ) { C . gtk_toolbar_insert ( v . native ( ) , item . toToolItem ( ) , C . gint ( pos ) ) } 
func ( v * Toolbar ) GetItemIndex ( item IToolItem ) int { c := C . gtk_toolbar_get_item_index ( v . native ( ) , item . toToolItem ( ) ) return int ( c ) } 
func ( v * Toolbar ) GetNItems ( ) int { c := C . gtk_toolbar_get_n_items ( v . native ( ) ) return int ( c ) } 
func ( v * Toolbar ) GetNthItem ( n int ) * ToolItem { c := C . gtk_toolbar_get_nth_item ( v . native ( ) , C . gint ( n ) ) if c == nil { return nil } return wrapToolItem ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Toolbar ) GetDropIndex ( x , y int ) int { c := C . gtk_toolbar_get_drop_index ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) return int ( c ) } 
func ( v * Toolbar ) SetDropHighlightItem ( toolItem IToolItem , index int ) { C . gtk_toolbar_set_drop_highlight_item ( v . native ( ) , toolItem . toToolItem ( ) , C . gint ( index ) ) } 
func ( v * Toolbar ) SetShowArrow ( showArrow bool ) { C . gtk_toolbar_set_show_arrow ( v . native ( ) , gbool ( showArrow ) ) } 
func ( v * Toolbar ) GetShowArrow ( ) bool { c := C . gtk_toolbar_get_show_arrow ( v . native ( ) ) return gobool ( c ) } 
func ( v * Toolbar ) GetStyle ( ) ToolbarStyle { c := C . gtk_toolbar_get_style ( v . native ( ) ) return ToolbarStyle ( c ) } 
func ( v * Toolbar ) GetIconSize ( ) IconSize { c := C . gtk_toolbar_get_icon_size ( v . native ( ) ) return IconSize ( c ) } 
func ( v * Toolbar ) GetReliefStyle ( ) ReliefStyle { c := C . gtk_toolbar_get_relief_style ( v . native ( ) ) return ReliefStyle ( c ) } 
func ( v * Toolbar ) SetStyle ( style ToolbarStyle ) { C . gtk_toolbar_set_style ( v . native ( ) , C . GtkToolbarStyle ( style ) ) } 
func ( v * Toolbar ) SetIconSize ( iconSize IconSize ) { C . gtk_toolbar_set_icon_size ( v . native ( ) , C . GtkIconSize ( iconSize ) ) } 
func ( v * ToolButton ) native ( ) * C . GtkToolButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolButton ( p ) } 
func ToolButtonNew ( iconWidget IWidget , label string ) ( * ToolButton , error ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) w := nullableWidget ( iconWidget ) c := C . gtk_tool_button_new ( w , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return wrapToolButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ToolButton ) SetLabel ( label string ) { cstr := C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tool_button_set_label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ToolButton ) GetLabel ( ) string { c := C . gtk_tool_button_get_label ( v . native ( ) ) return goString ( c ) } 
func ( v * ToolButton ) SetGetUnderline ( useUnderline bool ) { C . gtk_tool_button_set_use_underline ( v . native ( ) , gbool ( useUnderline ) ) } 
func ( v * ToolButton ) GetuseUnderline ( ) bool { c := C . gtk_tool_button_get_use_underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolButton ) SetIconName ( iconName string ) { cstr := C . CString ( iconName ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tool_button_set_icon_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ToolButton ) GetIconName ( ) string { c := C . gtk_tool_button_get_icon_name ( v . native ( ) ) return goString ( c ) } 
func ( v * ToolButton ) SetIconWidget ( iconWidget IWidget ) { C . gtk_tool_button_set_icon_widget ( v . native ( ) , iconWidget . toWidget ( ) ) } 
func ( v * ToolButton ) GetIconWidget ( ) * Widget { c := C . gtk_tool_button_get_icon_widget ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ToolButton ) SetLabelWidget ( labelWidget IWidget ) { C . gtk_tool_button_set_label_widget ( v . native ( ) , labelWidget . toWidget ( ) ) } 
func ( v * ToolButton ) GetLabelWidget ( ) * Widget { c := C . gtk_tool_button_get_label_widget ( v . native ( ) ) if c == nil { return nil } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ToggleToolButton ) native ( ) * C . GtkToggleToolButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToggleToolButton ( p ) } 
func ToggleToolButtonNew ( ) ( * ToggleToolButton , error ) { c := C . gtk_toggle_tool_button_new ( ) if c == nil { return nil , nilPtrErr } return wrapToggleToolButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ToggleToolButton ) GetActive ( ) bool { c := C . gtk_toggle_tool_button_get_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToggleToolButton ) SetActive ( isActive bool ) { C . gtk_toggle_tool_button_set_active ( v . native ( ) , gbool ( isActive ) ) } 
func ( v * ToolItem ) native ( ) * C . GtkToolItem { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkToolItem ( p ) } 
func ToolItemNew ( ) ( * ToolItem , error ) { c := C . gtk_tool_item_new ( ) if c == nil { return nil , nilPtrErr } return wrapToolItem ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * ToolItem ) SetHomogeneous ( homogeneous bool ) { C . gtk_tool_item_set_homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * ToolItem ) GetHomogeneous ( ) bool { c := C . gtk_tool_item_get_homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) GetExpand ( ) bool { c := C . gtk_tool_item_get_expand ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) SetTooltipText ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tool_item_set_tooltip_text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ToolItem ) SetTooltipMarkup ( text string ) { cstr := C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tool_item_set_tooltip_markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * ToolItem ) SetUseDragWindow ( useDragWindow bool ) { C . gtk_tool_item_set_use_drag_window ( v . native ( ) , gbool ( useDragWindow ) ) } 
func ( v * ToolItem ) GetUseDragWindow ( ) bool { c := C . gtk_tool_item_get_use_drag_window ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) SetVisibleHorizontal ( visibleHorizontal bool ) { C . gtk_tool_item_set_visible_horizontal ( v . native ( ) , gbool ( visibleHorizontal ) ) } 
func ( v * ToolItem ) GetVisibleHorizontal ( ) bool { c := C . gtk_tool_item_get_visible_horizontal ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) SetVisibleVertical ( visibleVertical bool ) { C . gtk_tool_item_set_visible_vertical ( v . native ( ) , gbool ( visibleVertical ) ) } 
func ( v * ToolItem ) GetVisibleVertical ( ) bool { c := C . gtk_tool_item_get_visible_vertical ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) SetIsImportant ( isImportant bool ) { C . gtk_tool_item_set_is_important ( v . native ( ) , gbool ( isImportant ) ) } 
func ( v * ToolItem ) GetIsImportant ( ) bool { c := C . gtk_tool_item_get_is_important ( v . native ( ) ) return gobool ( c ) } 
func ( v * ToolItem ) GetIconSize ( ) IconSize { c := C . gtk_tool_item_get_icon_size ( v . native ( ) ) return IconSize ( c ) } 
func ( v * ToolItem ) GetOrientation ( ) Orientation { c := C . gtk_tool_item_get_orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * ToolItem ) gtk_tool_item_get_toolbar_style ( ) ToolbarStyle { c := C . gtk_tool_item_get_toolbar_style ( v . native ( ) ) return ToolbarStyle ( c ) } 
func ( v * ToolItem ) GetReliefStyle ( ) ReliefStyle { c := C . gtk_tool_item_get_relief_style ( v . native ( ) ) return ReliefStyle ( c ) } 
func ( v * ToolItem ) GetTextAlignment ( ) float32 { c := C . gtk_tool_item_get_text_alignment ( v . native ( ) ) return float32 ( c ) } 
func ( v * ToolItem ) GetTextOrientation ( ) Orientation { c := C . gtk_tool_item_get_text_orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * ToolItem ) RetrieveProxyMenuItem ( ) * MenuItem { c := C . gtk_tool_item_retrieve_proxy_menu_item ( v . native ( ) ) if c == nil { return nil } return wrapMenuItem ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * ToolItem ) SetProxyMenuItem ( menuItemId string , menuItem IMenuItem ) { cstr := C . CString ( menuItemId ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_tool_item_set_proxy_menu_item ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . toGtkWidget ( unsafe . Pointer ( menuItem . toMenuItem ( ) ) ) ) } 
func ( v * TreeIter ) native ( ) * C . GtkTreeIter { if v == nil { return nil } return & v . GtkTreeIter } 
func ( v * TreeIter ) Copy ( ) ( * TreeIter , error ) { c := C . gtk_tree_iter_copy ( v . native ( ) ) if c == nil { return nil , nilPtrErr } t := & TreeIter { * c } runtime . SetFinalizer ( t , ( * TreeIter ) . free ) return t , nil } 
func ( v * TreeModel ) native ( ) * C . GtkTreeModel { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeModel ( p ) } 
func ( v * TreeModel ) GetFlags ( ) TreeModelFlags { c := C . gtk_tree_model_get_flags ( v . native ( ) ) return TreeModelFlags ( c ) } 
func ( v * TreeModel ) GetNColumns ( ) int { c := C . gtk_tree_model_get_n_columns ( v . native ( ) ) return int ( c ) } 
func ( v * TreeModel ) GetColumnType ( index int ) glib . Type { c := C . gtk_tree_model_get_column_type ( v . native ( ) , C . gint ( index ) ) return glib . Type ( c ) } 
func ( v * TreeModel ) GetIter ( path * TreePath ) ( * TreeIter , error ) { var iter C . GtkTreeIter c := C . gtk_tree_model_get_iter ( v . native ( ) , & iter , path . native ( ) ) if ! gobool ( c ) { return nil , errors . New ( " " ) } t := & TreeIter { iter } return t , nil } 
func ( v * TreeModel ) GetIterFromString ( path string ) ( * TreeIter , error ) { var iter C . GtkTreeIter cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_tree_model_get_iter_from_string ( v . native ( ) , & iter , ( * C . gchar ) ( cstr ) ) if ! gobool ( c ) { return nil , errors . New ( " " ) } t := & TreeIter { iter } return t , nil } 
func ( v * TreeModel ) GetIterFirst ( ) ( * TreeIter , bool ) { var iter C . GtkTreeIter c := C . gtk_tree_model_get_iter_first ( v . native ( ) , & iter ) if ! gobool ( c ) { return nil , false } t := & TreeIter { iter } return t , true } 
func ( v * TreeModel ) GetPath ( iter * TreeIter ) ( * TreePath , error ) { c := C . gtk_tree_model_get_path ( v . native ( ) , iter . native ( ) ) if c == nil { return nil , nilPtrErr } p := & TreePath { c } runtime . SetFinalizer ( p , ( * TreePath ) . free ) return p , nil } 
func ( v * TreeModel ) GetValue ( iter * TreeIter , column int ) ( * glib . Value , error ) { val , err := glib . ValueAlloc ( ) if err != nil { return nil , err } C . gtk_tree_model_get_value ( ( * C . GtkTreeModel ) ( unsafe . Pointer ( v . native ( ) ) ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( unsafe . Pointer ( val . Native ( ) ) ) ) return val , nil } 
func ( v * TreeModel ) IterHasChild ( iter * TreeIter ) bool { c := C . gtk_tree_model_iter_has_child ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * TreeModel ) IterNext ( iter * TreeIter ) bool { c := C . gtk_tree_model_iter_next ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * TreeModel ) IterPrevious ( iter * TreeIter ) bool { c := C . gtk_tree_model_iter_previous ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * TreeModel ) IterParent ( iter , child * TreeIter ) bool { c := C . gtk_tree_model_iter_parent ( v . native ( ) , iter . native ( ) , child . native ( ) ) return gobool ( c ) } 
func ( v * TreeModel ) IterNthChild ( iter * TreeIter , parent * TreeIter , n int ) bool { c := C . gtk_tree_model_iter_nth_child ( v . native ( ) , iter . native ( ) , parent . native ( ) , C . gint ( n ) ) return gobool ( c ) } 
func ( v * TreeModel ) IterChildren ( iter , child * TreeIter ) bool { var cIter , cChild * C . GtkTreeIter if iter != nil { cIter = iter . native ( ) } cChild = child . native ( ) c := C . gtk_tree_model_iter_children ( v . native ( ) , cChild , cIter ) return gobool ( c ) } 
func ( v * TreeModel ) IterNChildren ( iter * TreeIter ) int { var cIter * C . GtkTreeIter if iter != nil { cIter = iter . native ( ) } c := C . gtk_tree_model_iter_n_children ( v . native ( ) , cIter ) return int ( c ) } 
func ( v * TreeModel ) FilterNew ( root * TreePath ) ( * TreeModelFilter , error ) { c := C . gtk_tree_model_filter_new ( v . native ( ) , root . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapTreeModelFilter ( obj ) , nil } 
func ( v * TreeModelFilter ) SetVisibleColumn ( column int ) { C . gtk_tree_model_filter_set_visible_column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * TreeModelFilter ) ConvertIterToChildIter ( filterIter * TreeIter ) * TreeIter { var iter C . GtkTreeIter C . gtk_tree_model_filter_convert_iter_to_child_iter ( v . native ( ) , & iter , filterIter . native ( ) ) t := & TreeIter { iter } return t } 
func ( v * TreeModelFilter ) ConvertPathToChildPath ( filterPath * TreePath ) * TreePath { path := C . gtk_tree_model_filter_convert_path_to_child_path ( v . native ( ) , filterPath . native ( ) ) if path == nil { return nil } p := & TreePath { path } runtime . SetFinalizer ( p , ( * TreePath ) . free ) return p } 
func ( v * TreeModelFilter ) SetVisibleFunc ( f TreeModelFilterVisibleFunc , userData ... interface { } ) error { if len ( userData ) > 1 { return errors . New ( " " ) } t := treeModelFilterVisibleFuncData { fn : f } if len ( userData ) > 0 { t . userData = userData [ 0 ] } treeModelVisibleFilterFuncRegistry . Lock ( ) id := treeModelVisibleFilterFuncRegistry . next treeModelVisibleFilterFuncRegistry . next ++ treeModelVisibleFilterFuncRegistry . m [ id ] = t treeModelVisibleFilterFuncRegistry . Unlock ( ) C . _gtk_tree_model_filter_set_visible_func ( v . native ( ) , C . gpointer ( uintptr ( id ) ) ) return nil } 
func TreePathFromList ( list * glib . List ) * TreePath { if list == nil { return nil } return & TreePath { ( * C . GtkTreePath ) ( list . Data ( ) . ( unsafe . Pointer ) ) } } 
func ( v * TreePath ) native ( ) * C . GtkTreePath { if v == nil { return nil } return v . GtkTreePath } 
func ( v * TreePath ) GetIndices ( ) [ ] int { var depth C . gint var goindices [ ] int var ginthelp C . gint indices := uintptr ( unsafe . Pointer ( C . gtk_tree_path_get_indices_with_depth ( v . native ( ) , & depth ) ) ) size := unsafe . Sizeof ( ginthelp ) for i := 0 ; i < int ( depth ) ; i ++ { goind := int ( * ( ( * C . gint ) ( unsafe . Pointer ( indices ) ) ) ) goindices = append ( goindices , goind ) indices += size } return goindices } 
func ( v * TreePath ) String ( ) string { c := C . gtk_tree_path_to_string ( v . native ( ) ) return goString ( c ) } 
func TreePathNewFromString ( path string ) ( * TreePath , error ) { cstr := C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_tree_path_new_from_string ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } t := & TreePath { c } runtime . SetFinalizer ( t , ( * TreePath ) . free ) return t , nil } 
func ( v * TreeSelection ) native ( ) * C . GtkTreeSelection { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeSelection ( p ) } 
func ( v * TreeSelection ) GetSelected ( ) ( model ITreeModel , iter * TreeIter , ok bool ) { var cmodel * C . GtkTreeModel var citer C . GtkTreeIter c := C . gtk_tree_selection_get_selected ( v . native ( ) , & cmodel , & citer ) model = wrapTreeModel ( glib . Take ( unsafe . Pointer ( cmodel ) ) ) iter = & TreeIter { citer } ok = gobool ( c ) return } 
func ( v * TreeSelection ) SelectPath ( path * TreePath ) { C . gtk_tree_selection_select_path ( v . native ( ) , path . native ( ) ) } 
func ( v * TreeSelection ) UnselectPath ( path * TreePath ) { C . gtk_tree_selection_unselect_path ( v . native ( ) , path . native ( ) ) } 
func ( v * TreeSelection ) GetSelectedRows ( model ITreeModel ) * glib . List { var pcmodel * * C . GtkTreeModel if model != nil { cmodel := model . toTreeModel ( ) pcmodel = & cmodel } clist := C . gtk_tree_selection_get_selected_rows ( v . native ( ) , pcmodel ) if clist == nil { return nil } glist := glib . WrapList ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return & TreePath { ( * C . GtkTreePath ) ( ptr ) } } ) runtime . SetFinalizer ( glist , func ( glist * glib . List ) { glist . FreeFull ( func ( item interface { } ) { path := item . ( * TreePath ) C . gtk_tree_path_free ( path . GtkTreePath ) } ) } ) return glist } 
func ( v * TreeSelection ) SelectIter ( iter * TreeIter ) { C . gtk_tree_selection_select_iter ( v . native ( ) , iter . native ( ) ) } 
func ( v * TreeSelection ) SetMode ( m SelectionMode ) { C . gtk_tree_selection_set_mode ( v . native ( ) , C . GtkSelectionMode ( m ) ) } 
func TreeRowReferenceNew ( model * TreeModel , path * TreePath ) ( * TreeRowReference , error ) { c := C . gtk_tree_row_reference_new ( model . native ( ) , path . native ( ) ) if c == nil { return nil , nilPtrErr } r := & TreeRowReference { c } runtime . SetFinalizer ( r , ( * TreeRowReference ) . free ) return r , nil } 
func ( v * TreeRowReference ) GetPath ( ) * TreePath { c := C . gtk_tree_row_reference_get_path ( v . native ( ) ) if c == nil { return nil } t := & TreePath { c } runtime . SetFinalizer ( t , ( * TreePath ) . free ) return t } 
func ( v * TreeRowReference ) GetModel ( ) ITreeModel { c := C . gtk_tree_row_reference_get_model ( v . native ( ) ) if c == nil { return nil } m := wrapTreeModel ( glib . Take ( unsafe . Pointer ( c ) ) ) return m } 
func ( v * TreeRowReference ) Valid ( ) bool { c := C . gtk_tree_row_reference_valid ( v . native ( ) ) return gobool ( c ) } 
func ( v * TreeStore ) native ( ) * C . GtkTreeStore { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkTreeStore ( p ) } 
func TreeStoreNew ( types ... glib . Type ) ( * TreeStore , error ) { gtypes := C . alloc_types ( C . int ( len ( types ) ) ) for n , val := range types { C . set_type ( gtypes , C . int ( n ) , C . GType ( val ) ) } defer C . g_free ( C . gpointer ( gtypes ) ) c := C . gtk_tree_store_newv ( C . gint ( len ( types ) ) , gtypes ) if c == nil { return nil , nilPtrErr } ts := wrapTreeStore ( glib . Take ( unsafe . Pointer ( c ) ) ) return ts , nil } 
func ( v * TreeStore ) Append ( parent * TreeIter ) * TreeIter { var ti C . GtkTreeIter var cParent * C . GtkTreeIter if parent != nil { cParent = parent . native ( ) } C . gtk_tree_store_append ( v . native ( ) , & ti , cParent ) iter := & TreeIter { ti } return iter } 
func ( v * TreeStore ) Insert ( parent * TreeIter , position int ) * TreeIter { var ti C . GtkTreeIter var cParent * C . GtkTreeIter if parent != nil { cParent = parent . native ( ) } C . gtk_tree_store_insert ( v . native ( ) , & ti , cParent , C . gint ( position ) ) iter := & TreeIter { ti } return iter } 
func ( v * TreeStore ) SetValue ( iter * TreeIter , column int , value interface { } ) error { switch value . ( type ) { case * gdk . Pixbuf : pix := value . ( * gdk . Pixbuf ) C . _gtk_tree_store_set ( v . native ( ) , iter . native ( ) , C . gint ( column ) , unsafe . Pointer ( pix . Native ( ) ) ) default : gv , err := glib . GValue ( value ) if err != nil { return err } C . gtk_tree_store_set_value ( v . native ( ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( C . gpointer ( gv . Native ( ) ) ) ) } return nil } 
func ( v * TreeStore ) Remove ( iter * TreeIter ) bool { var ti * C . GtkTreeIter if iter != nil { ti = iter . native ( ) } return 0 != C . gtk_tree_store_remove ( v . native ( ) , ti ) } 
func ( v * TreeStore ) SetSortColumnId ( column int , order SortType ) { sort := C . toGtkTreeSortable ( unsafe . Pointer ( v . Native ( ) ) ) C . gtk_tree_sortable_set_sort_column_id ( sort , C . gint ( column ) , C . GtkSortType ( order ) ) } 
func ( v * Viewport ) native ( ) * C . GtkViewport { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkViewport ( p ) } 
func ViewportNew ( hadjustment , vadjustment * Adjustment ) ( * Viewport , error ) { c := C . gtk_viewport_new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapViewport ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * VolumeButton ) native ( ) * C . GtkVolumeButton { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkVolumeButton ( p ) } 
func VolumeButtonNew ( ) ( * VolumeButton , error ) { c := C . gtk_volume_button_new ( ) if c == nil { return nil , nilPtrErr } return wrapVolumeButton ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func cast ( c * C . GObject ) ( glib . IObject , error ) { var ( className = goString ( C . object_get_class_name ( c ) ) obj = glib . Take ( unsafe . Pointer ( c ) ) ) fn , ok := WrapMap [ className ] if ! ok { return nil , errors . New ( " " + className + " " ) } rf := reflect . ValueOf ( fn ) if rf . Type ( ) . Kind ( ) != reflect . Func { return nil , errors . New ( " " ) } v := reflect . ValueOf ( obj ) rv := rf . Call ( [ ] reflect . Value { v } ) if len ( rv ) != 1 { return nil , errors . New ( " " ) } if k := rv [ 0 ] . Kind ( ) ; k != reflect . Ptr { return nil , fmt . Errorf ( " " , k ) } ret , ok := rv [ 0 ] . Interface ( ) . ( glib . IObject ) if ! ok { return nil , errors . New ( " " ) } return ret , nil } 
func ( v * GLArea ) SetUseES ( es bool ) { C . gtk_gl_area_set_use_es ( v . native ( ) , gbool ( es ) ) } 
func SettingsGetDefault ( ) ( * Settings , error ) { c := C . gtk_settings_get_default ( ) if c == nil { return nil , nilPtrErr } return wrapSettings ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * TextMark ) native ( ) * C . GtkTextMark { if v == nil { return nil } return ( * C . GtkTextMark ) ( v ) } 
func NewPatternFromRGB ( red , green , blue float64 ) ( * Pattern , error ) { c := C . cairo_pattern_create_rgb ( C . double ( red ) , C . double ( green ) , C . double ( blue ) ) return newPatternFromNative ( c ) } 
func NewPatternFromRGBA ( red , green , blue , alpha float64 ) ( * Pattern , error ) { c := C . cairo_pattern_create_rgba ( C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) return newPatternFromNative ( c ) } 
func NewPatternForSurface ( s * Surface ) ( * Pattern , error ) { c := C . cairo_pattern_create_for_surface ( s . native ( ) ) return newPatternFromNative ( c ) } 
func NewPatternLinear ( x0 , y0 , x1 , y1 float64 ) ( * Pattern , error ) { c := C . cairo_pattern_create_linear ( C . double ( x0 ) , C . double ( y0 ) , C . double ( x1 ) , C . double ( y1 ) ) return newPatternFromNative ( c ) } 
func NewPatternRadial ( x0 , y0 , r0 , x1 , y1 , r1 float64 ) ( * Pattern , error ) { c := C . cairo_pattern_create_radial ( C . double ( x0 ) , C . double ( y0 ) , C . double ( r0 ) , C . double ( x1 ) , C . double ( y1 ) , C . double ( r1 ) ) return newPatternFromNative ( c ) } 
func ( v * Pattern ) native ( ) * C . cairo_pattern_t { if v == nil { return nil } return v . pattern } 
func ( v * Pattern ) Status ( ) Status { c := C . cairo_pattern_status ( v . native ( ) ) return Status ( c ) } 
func ( v * Pattern ) AddColorStopRGB ( offset , red , green , blue float64 ) error { C . cairo_pattern_add_color_stop_rgb ( v . native ( ) , C . double ( offset ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) ) return v . Status ( ) . ToError ( ) } 
func ( v * Pattern ) AddColorStopRGBA ( offset , red , green , blue , alpha float64 ) error { C . cairo_pattern_add_color_stop_rgba ( v . native ( ) , C . double ( offset ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) return v . Status ( ) . ToError ( ) } 
func ( v * Application ) GetActionsForAccel ( acc string ) [ ] string { cstr1 := ( * C . gchar ) ( C . CString ( acc ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) var acts [ ] string c := C . gtk_application_get_actions_for_accel ( v . native ( ) , cstr1 ) originalc := c defer C . g_strfreev ( originalc ) for * c != nil { acts = append ( acts , C . GoString ( ( * C . char ) ( * c ) ) ) c = C . next_gcharptr ( c ) } return acts } 
func ( v * Application ) GetMenuByID ( id string ) * glib . Menu { cstr1 := ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . gtk_application_get_menu_by_id ( v . native ( ) , cstr1 ) if c == nil { return nil } return & glib . Menu { glib . MenuModel { glib . Take ( unsafe . Pointer ( c ) ) } } } 
func ( v * Window ) native ( ) * C . GtkWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkWindow ( p ) } 
func WindowNew ( t WindowType ) ( * Window , error ) { c := C . gtk_window_new ( C . GtkWindowType ( t ) ) if c == nil { return nil , nilPtrErr } return wrapWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) SetTitle ( title string ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_window_set_title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Window ) GetResizable ( ) bool { c := C . gtk_window_get_resizable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) ActivateFocus ( ) bool { c := C . gtk_window_activate_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) ActivateDefault ( ) bool { c := C . gtk_window_activate_default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) SetModal ( modal bool ) { C . gtk_window_set_modal ( v . native ( ) , gbool ( modal ) ) } 
func ( v * Window ) SetDefaultSize ( width , height int ) { C . gtk_window_set_default_size ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Window ) SetIcon ( icon * gdk . Pixbuf ) { iconPtr := ( * C . GdkPixbuf ) ( unsafe . Pointer ( icon . Native ( ) ) ) C . gtk_window_set_icon ( v . native ( ) , iconPtr ) } 
func WindowSetDefaultIcon ( icon * gdk . Pixbuf ) { iconPtr := ( * C . GdkPixbuf ) ( unsafe . Pointer ( icon . Native ( ) ) ) C . gtk_window_set_default_icon ( iconPtr ) } 
func ( v * Window ) SetGravity ( gravity gdk . GdkGravity ) { C . gtk_window_set_gravity ( v . native ( ) , C . GdkGravity ( gravity ) ) } 
func ( v * Window ) SetTransientFor ( parent IWindow ) { var pw * C . GtkWindow = nil if parent != nil { pw = parent . toWindow ( ) } C . gtk_window_set_transient_for ( v . native ( ) , pw ) } 
func ( v * Window ) SetHideTitlebarWhenMaximized ( setting bool ) { C . gtk_window_set_hide_titlebar_when_maximized ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) IsActive ( ) bool { c := C . gtk_window_is_active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) HasToplevelFocus ( ) bool { c := C . gtk_window_has_toplevel_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetFocus ( ) ( * Widget , error ) { c := C . gtk_window_get_focus ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) SetFocus ( w * Widget ) { C . gtk_window_set_focus ( v . native ( ) , w . native ( ) ) } 
func ( v * Window ) GetDefaultWidget ( ) * Widget { c := C . gtk_window_get_default_widget ( v . native ( ) ) if c == nil { return nil } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapWidget ( obj ) } 
func ( v * Window ) SetDefault ( widget IWidget ) { C . gtk_window_set_default ( v . native ( ) , widget . toWidget ( ) ) } 
func ( v * Window ) PresentWithTime ( ts uint32 ) { C . gtk_window_present_with_time ( v . native ( ) , C . guint32 ( ts ) ) } 
func ( v * Window ) SetKeepAbove ( setting bool ) { C . gtk_window_set_keep_above ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetKeepBelow ( setting bool ) { C . gtk_window_set_keep_below ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetDecorated ( setting bool ) { C . gtk_window_set_decorated ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetDeletable ( setting bool ) { C . gtk_window_set_deletable ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetTypeHint ( typeHint gdk . WindowTypeHint ) { C . gtk_window_set_type_hint ( v . native ( ) , C . GdkWindowTypeHint ( typeHint ) ) } 
func ( v * Window ) SetSkipPagerHint ( setting bool ) { C . gtk_window_set_skip_pager_hint ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetUrgencyHint ( setting bool ) { C . gtk_window_set_urgency_hint ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetFocusOnMap ( setting bool ) { C . gtk_window_set_focus_on_map ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) SetStartupID ( sid string ) { cstr := ( * C . gchar ) ( C . CString ( sid ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_window_set_startup_id ( v . native ( ) , cstr ) } 
func ( v * Window ) SetRole ( s string ) { cstr := ( * C . gchar ) ( C . CString ( s ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_window_set_role ( v . native ( ) , cstr ) } 
func ( v * Window ) GetDecorated ( ) bool { c := C . gtk_window_get_decorated ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetDeletable ( ) bool { c := C . gtk_window_get_deletable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetDefaultSize ( ) ( width , height int ) { var w , h C . gint C . gtk_window_get_default_size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func ( v * Window ) GetDestroyWithParent ( ) bool { c := C . gtk_window_get_destroy_with_parent ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetHideTitlebarWhenMaximized ( ) bool { c := C . gtk_window_get_hide_titlebar_when_maximized ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetIcon ( ) ( * gdk . Pixbuf , error ) { c := C . gtk_window_get_icon ( v . native ( ) ) if c == nil { return nil , nilPtrErr } p := & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * Window ) GetIconName ( ) ( string , error ) { return stringReturn ( C . gtk_window_get_icon_name ( v . native ( ) ) ) } 
func ( v * Window ) GetModal ( ) bool { c := C . gtk_window_get_modal ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetPosition ( ) ( root_x , root_y int ) { var x , y C . gint C . gtk_window_get_position ( v . native ( ) , & x , & y ) return int ( x ) , int ( y ) } 
func ( v * Window ) GetRole ( ) ( string , error ) { return stringReturn ( C . gtk_window_get_role ( v . native ( ) ) ) } 
func ( v * Window ) GetSize ( ) ( width , height int ) { var w , h C . gint C . gtk_window_get_size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func ( v * Window ) GetTitle ( ) ( string , error ) { return stringReturn ( C . gtk_window_get_title ( v . native ( ) ) ) } 
func ( v * Window ) GetTransientFor ( ) ( * Window , error ) { c := C . gtk_window_get_transient_for ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWindow ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) GetAttachedTo ( ) ( * Widget , error ) { c := C . gtk_window_get_attached_to ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapWidget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) GetTypeHint ( ) gdk . WindowTypeHint { c := C . gtk_window_get_type_hint ( v . native ( ) ) return gdk . WindowTypeHint ( c ) } 
func ( v * Window ) GetSkipTaskbarHint ( ) bool { c := C . gtk_window_get_skip_taskbar_hint ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetUrgencyHint ( ) bool { c := C . gtk_window_get_urgency_hint ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetAcceptFocus ( ) bool { c := C . gtk_window_get_accept_focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) GetFocusOnMap ( ) bool { c := C . gtk_window_get_focus_on_map ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) HasGroup ( ) bool { c := C . gtk_window_has_group ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Resize ( width , height int ) { C . gtk_window_resize ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func WindowSetDefaultIconFromFile ( file string ) error { cstr := C . CString ( file ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res := C . gtk_window_set_default_icon_from_file ( ( * C . gchar ) ( cstr ) , & err ) if res == 0 { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func WindowSetDefaultIconName ( s string ) { cstr := ( * C . gchar ) ( C . CString ( s ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_window_set_default_icon_name ( cstr ) } 
func ( v * Window ) SetIconFromFile ( file string ) error { cstr := C . CString ( file ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res := C . gtk_window_set_icon_from_file ( v . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res == 0 { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * Window ) SetIconName ( name string ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk_window_set_icon_name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Window ) GetMnemonicsVisible ( ) bool { c := C . gtk_window_get_mnemonics_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) SetMnemonicsVisible ( setting bool ) { C . gtk_window_set_mnemonics_visible ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) GetFocusVisible ( ) bool { c := C . gtk_window_get_focus_visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) SetFocusVisible ( setting bool ) { C . gtk_window_set_focus_visible ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) GetApplication ( ) ( * Application , error ) { c := C . gtk_window_get_application ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapApplication ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) SetApplication ( a * Application ) { C . gtk_window_set_application ( v . native ( ) , a . native ( ) ) } 
func ( v * Window ) ActivateKey ( event * gdk . EventKey ) bool { c := C . gtk_window_activate_key ( v . native ( ) , ( * C . GdkEventKey ) ( unsafe . Pointer ( event . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Window ) AddMnemonic ( keyval uint , target * Widget ) { C . gtk_window_add_mnemonic ( v . native ( ) , C . guint ( keyval ) , target . native ( ) ) } 
func ( v * Window ) RemoveMnemonic ( keyval uint , target * Widget ) { C . gtk_window_remove_mnemonic ( v . native ( ) , C . guint ( keyval ) , target . native ( ) ) } 
func ( v * Window ) ActivateMnemonic ( keyval uint , mods gdk . ModifierType ) bool { c := C . gtk_window_mnemonic_activate ( v . native ( ) , C . guint ( keyval ) , C . GdkModifierType ( mods ) ) return gobool ( c ) } 
func ( v * Window ) GetMnemonicModifier ( ) gdk . ModifierType { c := C . gtk_window_get_mnemonic_modifier ( v . native ( ) ) return gdk . ModifierType ( c ) } 
func ( v * Window ) SetMnemonicModifier ( mods gdk . ModifierType ) { C . gtk_window_set_mnemonic_modifier ( v . native ( ) , C . GdkModifierType ( mods ) ) } 
func ( v Atom ) native ( ) C . GdkAtom { return C . toGdkAtom ( unsafe . Pointer ( uintptr ( v ) ) ) } 
func GdkAtomIntern ( atomName string , onlyIfExists bool ) Atom { cstr := C . CString ( atomName ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gdk_atom_intern ( ( * C . gchar ) ( cstr ) , gbool ( onlyIfExists ) ) return Atom ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( v * Device ) native ( ) * C . GdkDevice { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDevice ( p ) } 
func CursorNewFromName ( display * Display , name string ) ( * Cursor , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gdk_cursor_new_from_name ( display . native ( ) , ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return & Cursor { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Cursor ) native ( ) * C . GdkCursor { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkCursor ( p ) } 
func ( v * DeviceManager ) native ( ) * C . GdkDeviceManager { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDeviceManager ( p ) } 
func ( v * DeviceManager ) GetDisplay ( ) ( * Display , error ) { c := C . gdk_device_manager_get_display ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) native ( ) * C . GdkDisplay { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDisplay ( p ) } 
func DisplayOpen ( displayName string ) ( * Display , error ) { cstr := C . CString ( displayName ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gdk_display_open ( ( * C . gchar ) ( cstr ) ) if c == nil { return nil , nilPtrErr } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func DisplayGetDefault ( ) ( * Display , error ) { c := C . gdk_display_get_default ( ) if c == nil { return nil , nilPtrErr } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) GetName ( ) ( string , error ) { c := C . gdk_display_get_name ( v . native ( ) ) if c == nil { return " " , nilPtrErr } return C . GoString ( ( * C . char ) ( c ) ) , nil } 
func ( v * Display ) GetDefaultScreen ( ) ( * Screen , error ) { c := C . gdk_display_get_default_screen ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Screen { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) DeviceIsGrabbed ( device * Device ) bool { c := C . gdk_display_device_is_grabbed ( v . native ( ) , device . native ( ) ) return gobool ( c ) } 
func ( v * Display ) IsClosed ( ) bool { c := C . gdk_display_is_closed ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) GetEvent ( ) ( * Event , error ) { c := C . gdk_display_get_event ( v . native ( ) ) if c == nil { return nil , nilPtrErr } runtime . SetFinalizer ( e , ( * Event ) . free ) return e , nil } 
func ( v * Display ) PeekEvent ( ) ( * Event , error ) { c := C . gdk_display_peek_event ( v . native ( ) ) if c == nil { return nil , nilPtrErr } runtime . SetFinalizer ( e , ( * Event ) . free ) return e , nil } 
func ( v * Display ) PutEvent ( event * Event ) { C . gdk_display_put_event ( v . native ( ) , event . native ( ) ) } 
func ( v * Display ) HasPending ( ) bool { c := C . gdk_display_has_pending ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) SetDoubleClickTime ( msec uint ) { C . gdk_display_set_double_click_time ( v . native ( ) , C . guint ( msec ) ) } 
func ( v * Display ) SetDoubleClickDistance ( distance uint ) { C . gdk_display_set_double_click_distance ( v . native ( ) , C . guint ( distance ) ) } 
func ( v * Display ) SupportsColorCursor ( ) bool { c := C . gdk_display_supports_cursor_color ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) SupportsCursorAlpha ( ) bool { c := C . gdk_display_supports_cursor_alpha ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) GetDefaultCursorSize ( ) uint { c := C . gdk_display_get_default_cursor_size ( v . native ( ) ) return uint ( c ) } 
func ( v * Display ) GetMaximalCursorSize ( ) ( width , height uint ) { var w , h C . guint C . gdk_display_get_maximal_cursor_size ( v . native ( ) , & w , & h ) return uint ( w ) , uint ( h ) } 
func ( v * Display ) GetDefaultGroup ( ) ( * Window , error ) { c := C . gdk_display_get_default_group ( v . native ( ) ) if c == nil { return nil , nilPtrErr } return & Window { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) SupportsSelectionNotification ( ) bool { c := C . gdk_display_supports_selection_notification ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) RequestSelectionNotification ( selection Atom ) bool { c := C . gdk_display_request_selection_notification ( v . native ( ) , selection . native ( ) ) return gobool ( c ) } 
func ( v * Display ) SupportsClipboardPersistence ( ) bool { c := C . gdk_display_supports_clipboard_persistence ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) StoreClipboard ( clipboardWindow * Window , time uint32 , targets ... Atom ) { panic ( " " ) } 
func ( v * Display ) SupportsShapes ( ) bool { c := C . gdk_display_supports_shapes ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) SupportsInputShapes ( ) bool { c := C . gdk_display_supports_input_shapes ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) NotifyStartupComplete ( startupID string ) { cstr := C . CString ( startupID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gdk_display_notify_startup_complete ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func KeyvalFromName ( keyvalName string ) uint { str := ( * C . gchar ) ( C . CString ( keyvalName ) ) defer C . free ( unsafe . Pointer ( str ) ) return uint ( C . gdk_keyval_from_name ( str ) ) } 
func ( v * DragContext ) native ( ) * C . GdkDragContext { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkDragContext ( p ) } 
func ( v * Event ) native ( ) * C . GdkEvent { if v == nil { return nil } return v . GdkEvent } 
func EventButtonNewFromEvent ( event * Event ) * EventButton { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventButton { & ev } } 
func ( v * EventButton ) XRoot ( ) float64 { c := v . native ( ) . x_root return float64 ( c ) } 
func ( v * EventButton ) YRoot ( ) float64 { c := v . native ( ) . y_root return float64 ( c ) } 
func ( v * EventButton ) Time ( ) uint32 { c := v . native ( ) . time return uint32 ( c ) } 
func EventKeyNewFromEvent ( event * Event ) * EventKey { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventKey { & ev } } 
func EventMotionNewFromEvent ( event * Event ) * EventMotion { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventMotion { & ev } } 
func ( v * EventMotion ) Time ( ) uint32 { c := v . native ( ) . time return uint32 ( c ) } 
func ( v * EventMotion ) State ( ) ModifierType { c := v . native ( ) . state return ModifierType ( c ) } 
func EventScrollNewFromEvent ( event * Event ) * EventScroll { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventScroll { & ev } } 
func EventWindowStateNewFromEvent ( event * Event ) * EventWindowState { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventWindowState { & ev } } 
func EventConfigureNewFromEvent ( event * Event ) * EventConfigure { ee := ( * C . GdkEvent ) ( unsafe . Pointer ( event . native ( ) ) ) ev := Event { ee } return & EventConfigure { & ev } } 
func ( v * Pixbuf ) GetColorspace ( ) Colorspace { c := C . gdk_pixbuf_get_colorspace ( v . native ( ) ) return Colorspace ( c ) } 
func ( v * Pixbuf ) GetNChannels ( ) int { c := C . gdk_pixbuf_get_n_channels ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetHasAlpha ( ) bool { c := C . gdk_pixbuf_get_has_alpha ( v . native ( ) ) return gobool ( c ) } 
func ( v * Pixbuf ) GetBitsPerSample ( ) int { c := C . gdk_pixbuf_get_bits_per_sample ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetPixels ( ) ( channels [ ] byte ) { var length C . guint c := C . gdk_pixbuf_get_pixels_with_length ( v . native ( ) , & length ) sliceHeader := ( * reflect . SliceHeader ) ( unsafe . Pointer ( & channels ) ) sliceHeader . Data = uintptr ( unsafe . Pointer ( c ) ) sliceHeader . Len = int ( length ) sliceHeader . Cap = int ( length ) runtime . SetFinalizer ( & channels , func ( _ * [ ] byte ) { v . Unref ( ) } ) return } 
func ( v * Pixbuf ) GetWidth ( ) int { c := C . gdk_pixbuf_get_width ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetHeight ( ) int { c := C . gdk_pixbuf_get_height ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetRowstride ( ) int { c := C . gdk_pixbuf_get_rowstride ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetByteLength ( ) int { c := C . gdk_pixbuf_get_byte_length ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) GetOption ( key string ) ( value string , ok bool ) { cstr := C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gdk_pixbuf_get_option ( v . native ( ) , ( * C . gchar ) ( cstr ) ) if c == nil { return " " , false } return C . GoString ( ( * C . char ) ( c ) ) , true } 
func PixbufNew ( colorspace Colorspace , hasAlpha bool , bitsPerSample , width , height int ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_new ( C . GdkColorspace ( colorspace ) , gbool ( hasAlpha ) , C . int ( bitsPerSample ) , C . int ( width ) , C . int ( height ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func PixbufNewFromFile ( filename string ) ( * Pixbuf , error ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError c := C . gdk_pixbuf_new_from_file ( ( * C . char ) ( cstr ) , & err ) if c == nil { defer C . g_error_free ( err ) return nil , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func PixbufNewFromFileAtScale ( filename string , width , height int , preserveAspectRatio bool ) ( * Pixbuf , error ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c := C . gdk_pixbuf_new_from_file_at_scale ( cstr , C . int ( width ) , C . int ( height ) , gbool ( preserveAspectRatio ) , & err ) if err != nil { defer C . g_error_free ( err ) return nil , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) ScaleSimple ( destWidth , destHeight int , interpType InterpType ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_scale_simple ( v . native ( ) , C . int ( destWidth ) , C . int ( destHeight ) , C . GdkInterpType ( interpType ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) RotateSimple ( angle PixbufRotation ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_rotate_simple ( v . native ( ) , C . GdkPixbufRotation ( angle ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) ApplyEmbeddedOrientation ( ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_apply_embedded_orientation ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Flip ( horizontal bool ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_flip ( v . native ( ) , gbool ( horizontal ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) SaveJPEG ( path string , quality int ) error { cpath := C . CString ( path ) cquality := C . CString ( strconv . Itoa ( quality ) ) defer C . free ( unsafe . Pointer ( cpath ) ) defer C . free ( unsafe . Pointer ( cquality ) ) var err * C . GError c := C . _gdk_pixbuf_save_jpeg ( v . native ( ) , cpath , & err , cquality ) if ! gobool ( c ) { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * Pixbuf ) SavePNG ( path string , compression int ) error { cpath := C . CString ( path ) ccompression := C . CString ( strconv . Itoa ( compression ) ) defer C . free ( unsafe . Pointer ( cpath ) ) defer C . free ( unsafe . Pointer ( ccompression ) ) var err * C . GError c := C . _gdk_pixbuf_save_png ( v . native ( ) , cpath , & err , ccompression ) if ! gobool ( c ) { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func PixbufGetFileInfo ( filename string ) ( format interface { } , width , height int ) { cstr := C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var cw , ch C . gint format = C . gdk_pixbuf_get_file_info ( ( * C . gchar ) ( cstr ) , & cw , & ch ) } 
func ( v * PixbufLoader ) native ( ) * C . GdkPixbufLoader { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkPixbufLoader ( p ) } 
func PixbufLoaderNew ( ) ( * PixbufLoader , error ) { c := C . gdk_pixbuf_loader_new ( ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & PixbufLoader { obj } obj . Ref ( ) runtime . SetFinalizer ( p , func ( _ interface { } ) { obj . Unref ( ) } ) return p , nil } 
func PixbufLoaderNewWithType ( t string ) ( * PixbufLoader , error ) { var err * C . GError cstr := C . CString ( t ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gdk_pixbuf_loader_new_with_type ( ( * C . char ) ( cstr ) , & err ) if err != nil { defer C . g_error_free ( err ) return nil , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } if c == nil { return nil , nilPtrErr } return & PixbufLoader { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * PixbufLoader ) Write ( data [ ] byte ) ( int , error ) { } var err * C . GError c := C . gdk_pixbuf_loader_write ( v . native ( ) , ( * C . guchar ) ( unsafe . Pointer ( & data [ 0 ] ) ) , C . gsize ( len ( data ) ) , & err ) if ! gobool ( c ) { defer C . g_error_free ( err ) return 0 , errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return len ( data ) , nil } 
func ( v * PixbufLoader ) Close ( ) error { var err * C . GError if ok := gobool ( C . gdk_pixbuf_loader_close ( v . native ( ) , & err ) ) ; ! ok { defer C . g_error_free ( err ) return errors . New ( C . GoString ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * PixbufLoader ) SetSize ( width , height int ) { C . gdk_pixbuf_loader_set_size ( v . native ( ) , C . int ( width ) , C . int ( height ) ) } 
func ( v * PixbufLoader ) GetPixbuf ( ) ( * Pixbuf , error ) { c := C . gdk_pixbuf_loader_get_pixbuf ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := & glib . Object { glib . ToGObject ( unsafe . Pointer ( c ) ) } p := & Pixbuf { obj } return p , nil } 
func ( c * RGBA ) SetColors ( r , g , b , a float64 ) { c . rgba . red = C . gdouble ( r ) c . rgba . green = C . gdouble ( g ) c . rgba . blue = C . gdouble ( b ) c . rgba . alpha = C . gdouble ( a ) } 
func ( v * RGBA ) Parse ( spec string ) bool { cstr := ( * C . gchar ) ( C . CString ( spec ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gdk_rgba_parse ( v . rgba , cstr ) ) } 
func ( v * RGBA ) String ( ) string { return C . GoString ( ( * C . char ) ( C . gdk_rgba_to_string ( v . rgba ) ) ) } 
func ( v * Window ) SetCursor ( cursor * Cursor ) { C . gdk_window_set_cursor ( v . native ( ) , cursor . native ( ) ) } 
func ( v * Window ) native ( ) * C . GdkWindow { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGdkWindow ( p ) } 
func ( v * IconView ) native ( ) * C . GtkIconView { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkIconView ( p ) } 
func IconViewNew ( ) ( * IconView , error ) { c := C . gtk_icon_view_new ( ) if c == nil { return nil , nilPtrErr } return wrapIconView ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func IconViewNewWithModel ( model ITreeModel ) ( * IconView , error ) { c := C . gtk_icon_view_new_with_model ( model . toTreeModel ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapIconView ( obj ) , nil } 
func ( v * IconView ) SetModel ( model ITreeModel ) { var mptr * C . GtkTreeModel if model != nil { mptr = model . toTreeModel ( ) } C . gtk_icon_view_set_model ( v . native ( ) , mptr ) } 
func ( v * IconView ) GetModel ( ) ( * TreeModel , error ) { c := C . gtk_icon_view_get_model ( v . native ( ) ) if c == nil { return nil , nilPtrErr } obj := glib . Take ( unsafe . Pointer ( c ) ) return wrapTreeModel ( obj ) , nil } 
func ( v * IconView ) SetTextColumn ( column int ) { C . gtk_icon_view_set_text_column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * IconView ) SetMarkupColumn ( column int ) { C . gtk_icon_view_set_markup_column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * IconView ) SetPixbufColumn ( column int ) { C . gtk_icon_view_set_pixbuf_column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * IconView ) GetPathAtPos ( x , y int ) * TreePath { var ( cpath * C . GtkTreePath path * TreePath ) cpath = C . gtk_icon_view_get_path_at_pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) if cpath != nil { path = & TreePath { cpath } runtime . SetFinalizer ( path , ( * TreePath ) . free ) } return path } 
func ( v * IconView ) GetItemAtPos ( x , y int ) ( * TreePath , * CellRenderer ) { var ( cpath * C . GtkTreePath ccell * C . GtkCellRenderer path * TreePath cell * CellRenderer ) C . gtk_icon_view_get_item_at_pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , & cpath , & ccell ) if cpath != nil { path = & TreePath { cpath } runtime . SetFinalizer ( path , ( * TreePath ) . free ) } if ccell != nil { cell = wrapCellRenderer ( glib . Take ( unsafe . Pointer ( ccell ) ) ) } return path , cell } 
func ( v * IconView ) ConvertWidgetToBinWindowCoords ( x , y int ) ( int , int ) { var bx , by C . gint C . gtk_icon_view_convert_widget_to_bin_window_coords ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , & bx , & by ) return int ( bx ) , int ( by ) } 
func ( v * IconView ) SetCursor ( path * TreePath , cell * CellRenderer , startEditing bool ) { C . gtk_icon_view_set_cursor ( v . native ( ) , path . native ( ) , cell . native ( ) , gbool ( startEditing ) ) } 
func ( v * IconView ) GetCursor ( ) ( * TreePath , * CellRenderer ) { var ( cpath * C . GtkTreePath ccell * C . GtkCellRenderer path * TreePath cell * CellRenderer ) C . gtk_icon_view_get_cursor ( v . native ( ) , & cpath , & ccell ) if cpath != nil { path = & TreePath { cpath } runtime . SetFinalizer ( path , ( * TreePath ) . free ) } if ccell != nil { cell = wrapCellRenderer ( glib . Take ( unsafe . Pointer ( ccell ) ) ) } return path , cell } 
func ( v * IconView ) SetSelectionMode ( mode SelectionMode ) { C . gtk_icon_view_set_selection_mode ( v . native ( ) , C . GtkSelectionMode ( mode ) ) } 
func ( v * IconView ) SetItemOrientation ( orientation Orientation ) { C . gtk_icon_view_set_item_orientation ( v . native ( ) , C . GtkOrientation ( orientation ) ) } 
func ( v * IconView ) SetColumns ( columns int ) { C . gtk_icon_view_set_columns ( v . native ( ) , C . gint ( columns ) ) } 
func ( v * IconView ) SetItemWidth ( width int ) { C . gtk_icon_view_set_item_width ( v . native ( ) , C . gint ( width ) ) } 
func ( v * IconView ) SetSpacing ( spacing int ) { C . gtk_icon_view_set_spacing ( v . native ( ) , C . gint ( spacing ) ) } 
func ( v * IconView ) SetRowSpacing ( rowSpacing int ) { C . gtk_icon_view_set_row_spacing ( v . native ( ) , C . gint ( rowSpacing ) ) } 
func ( v * IconView ) SetColumnSpacing ( columnSpacing int ) { C . gtk_icon_view_set_column_spacing ( v . native ( ) , C . gint ( columnSpacing ) ) } 
func ( v * IconView ) SetMargin ( margin int ) { C . gtk_icon_view_set_margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * IconView ) SetItemPadding ( itemPadding int ) { C . gtk_icon_view_set_item_padding ( v . native ( ) , C . gint ( itemPadding ) ) } 
func ( v * IconView ) SetActivateOnSingleClick ( single bool ) { C . gtk_icon_view_set_activate_on_single_click ( v . native ( ) , gbool ( single ) ) } 
func ( v * IconView ) GetCellRect ( path * TreePath , cell * CellRenderer ) * gdk . Rectangle { var crect C . GdkRectangle C . gtk_icon_view_get_cell_rect ( v . native ( ) , path . native ( ) , cell . native ( ) , & crect ) return gdk . WrapRectangle ( uintptr ( unsafe . Pointer ( & crect ) ) ) } 
func ( v * IconView ) SelectPath ( path * TreePath ) { C . gtk_icon_view_select_path ( v . native ( ) , path . native ( ) ) } 
func ( v * IconView ) UnselectPath ( path * TreePath ) { C . gtk_icon_view_unselect_path ( v . native ( ) , path . native ( ) ) } 
func ( v * IconView ) PathIsSelected ( path * TreePath ) bool { return gobool ( C . gtk_icon_view_path_is_selected ( v . native ( ) , path . native ( ) ) ) } 
func ( v * IconView ) GetSelectedItems ( ) * glib . List { clist := C . gtk_icon_view_get_selected_items ( v . native ( ) ) if clist == nil { return nil } glist := glib . WrapList ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . DataWrapper ( func ( ptr unsafe . Pointer ) interface { } { return & TreePath { ( * C . GtkTreePath ) ( ptr ) } } ) runtime . SetFinalizer ( glist , func ( glist * glib . List ) { glist . FreeFull ( func ( item interface { } ) { path := item . ( * TreePath ) C . gtk_tree_path_free ( path . GtkTreePath ) } ) } ) return glist } 
func ( v * IconView ) ItemActivated ( path * TreePath ) { C . gtk_icon_view_item_activated ( v . native ( ) , path . native ( ) ) } 
func ( v * IconView ) ScrollToPath ( path * TreePath , useAlign bool , rowAlign , colAlign float64 ) { C . gtk_icon_view_scroll_to_path ( v . native ( ) , path . native ( ) , gbool ( useAlign ) , C . gfloat ( rowAlign ) , C . gfloat ( colAlign ) ) } 
func ( v * IconView ) GetVisibleRange ( ) ( * TreePath , * TreePath ) { var ( cpathStart , cpathEnd * C . GtkTreePath pathStart , pathEnd * TreePath ) C . gtk_icon_view_get_visible_range ( v . native ( ) , & cpathStart , & cpathEnd ) if cpathStart != nil { pathStart = & TreePath { cpathStart } runtime . SetFinalizer ( pathStart , ( * TreePath ) . free ) } if cpathEnd != nil { pathEnd = & TreePath { cpathEnd } runtime . SetFinalizer ( pathEnd , ( * TreePath ) . free ) } return pathStart , pathEnd } 
func ( v * IconView ) SetTooltipItem ( tooltip * Tooltip , path * TreePath ) { C . gtk_icon_view_set_tooltip_item ( v . native ( ) , tooltip . native ( ) , path . native ( ) ) } 
func ( v * IconView ) SetTooltipCell ( tooltip * Tooltip , path * TreePath , cell * CellRenderer ) { C . gtk_icon_view_set_tooltip_cell ( v . native ( ) , tooltip . native ( ) , path . native ( ) , cell . native ( ) ) } 
func ( v * IconView ) GetTooltipContext ( x , y int , keyboardTip bool ) ( * TreeModel , * TreePath , * TreeIter ) { var ( cmodel * C . GtkTreeModel cpath * C . GtkTreePath citer * C . GtkTreeIter model * TreeModel path * TreePath iter * TreeIter ) px := C . gint ( x ) py := C . gint ( y ) if ! gobool ( C . gtk_icon_view_get_tooltip_context ( v . native ( ) , & px , & py , gbool ( keyboardTip ) , & cmodel , & cpath , citer , ) ) { return nil , nil , nil } if cmodel != nil { model = wrapTreeModel ( glib . Take ( unsafe . Pointer ( cmodel ) ) ) } if cpath != nil { path = & TreePath { cpath } runtime . SetFinalizer ( path , ( * TreePath ) . free ) } if citer != nil { iter = & TreeIter { * citer } runtime . SetFinalizer ( iter , ( * TreeIter ) . free ) } return model , path , iter } 
func ( v * IconView ) SetTooltipColumn ( column int ) { C . gtk_icon_view_set_tooltip_column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * IconView ) GetItemRow ( path * TreePath ) int { return int ( C . gtk_icon_view_get_item_row ( v . native ( ) , path . native ( ) ) ) } 
func ( v * IconView ) SetReorderable ( reorderable bool ) { C . gtk_icon_view_set_reorderable ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * Window ) MoveToDesktop ( d uint32 ) { C . gdk_x11_window_move_to_desktop ( v . native ( ) , C . guint32 ( d ) ) } 
func PaperSizeNewFromIPP ( name string , width , height float64 ) ( * PaperSize , error ) { cstr := C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_paper_size_new_from_ipp ( ( * C . gchar ) ( cstr ) , C . gdouble ( width ) , C . gdouble ( height ) ) if c == nil { return nil , nilPtrErr } t := & PaperSize { c } runtime . SetFinalizer ( t , ( * PaperSize ) . free ) return t , nil } 
func ( ps * PaperSize ) IsIPP ( ) bool { c := C . gtk_paper_size_is_ipp ( ps . native ( ) ) return gobool ( c ) } 
func ( v * Notification ) native ( ) * C . GNotification { if v == nil || v . GObject == nil { return nil } return C . toGNotification ( unsafe . Pointer ( v . GObject ) ) } 
func NotificationNew ( title string ) * Notification { cstr1 := ( * C . gchar ) ( C . CString ( title ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) c := C . g_notification_new ( cstr1 ) if c == nil { return nil } return wrapNotification ( wrapObject ( unsafe . Pointer ( c ) ) ) } 
func ( v * Notification ) SetTitle ( title string ) { cstr1 := ( * C . gchar ) ( C . CString ( title ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_notification_set_title ( v . native ( ) , cstr1 ) } 
func ( v * Notification ) SetBody ( body string ) { cstr1 := ( * C . gchar ) ( C . CString ( body ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_notification_set_body ( v . native ( ) , cstr1 ) } 
func ( v * Notification ) SetDefaultAction ( detailedAction string ) { cstr1 := ( * C . gchar ) ( C . CString ( detailedAction ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) C . g_notification_set_default_action ( v . native ( ) , cstr1 ) } 
func ( v * Notification ) AddButton ( label , detailedAction string ) { cstr1 := ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr1 ) ) cstr2 := ( * C . gchar ) ( C . CString ( detailedAction ) ) defer C . free ( unsafe . Pointer ( cstr2 ) ) C . g_notification_add_button ( v . native ( ) , cstr1 , cstr2 ) } 
func PopoverNew ( relative IWidget ) ( * Popover , error ) { if relative == nil { c = C . gtk_popover_new ( nil ) } else { c = C . gtk_popover_new ( relative . toWidget ( ) ) } if c == nil { return nil , nilPtrErr } return wrapPopover ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * SettingsSchema ) GetID ( ) string { return C . GoString ( ( * C . char ) ( C . g_settings_schema_get_id ( v . native ( ) ) ) ) } 
func ( v * SettingsSchema ) GetPath ( ) string { return C . GoString ( ( * C . char ) ( C . g_settings_schema_get_path ( v . native ( ) ) ) ) } 
func ( v * SettingsSchema ) HasKey ( v1 string ) bool { cstr := ( * C . gchar ) ( C . CString ( v1 ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . g_settings_schema_has_key ( v . native ( ) , cstr ) ) } 
func ( v * Object ) Connect ( detailedSignal string , f interface { } , userData ... interface { } ) ( SignalHandle , error ) { return v . connectClosure ( false , detailedSignal , f , userData ... ) } 
func ( v * Object ) ConnectAfter ( detailedSignal string , f interface { } , userData ... interface { } ) ( SignalHandle , error ) { return v . connectClosure ( true , detailedSignal , f , userData ... ) } 
func ClosureNew ( f interface { } , marshalData ... interface { } ) ( * C . GClosure , error ) { } if len ( marshalData ) > 0 { cc . userData = reflect . ValueOf ( marshalData [ 0 ] ) } c := C . _g_closure_new ( ) closures . m [ c ] = cc closures . Unlock ( ) return c , nil } 
func removeClosure ( _ C . gpointer , closure * C . GClosure ) { closures . Lock ( ) delete ( closures . m , closure ) closures . Unlock ( ) } 
func SettingsSchemaSourceNewFromDirectory ( dir string , parent * SettingsSchemaSource , trusted bool ) * SettingsSchemaSource { cstr := ( * C . gchar ) ( C . CString ( dir ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrapSettingsSchemaSource ( C . g_settings_schema_source_new_from_directory ( cstr , parent . native ( ) , gbool ( trusted ) , nil ) ) } 
func ( v * SettingsSchemaSource ) Lookup ( schema string , recursive bool ) * SettingsSchema { cstr := ( * C . gchar ) ( C . CString ( schema ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrapSettingsSchema ( C . g_settings_schema_source_lookup ( v . native ( ) , cstr , gbool ( recursive ) ) ) } 
func ( v * SettingsSchemaSource ) ListSchemas ( recursive bool ) ( nonReolcatable , relocatable [ ] string ) { var nonRel , rel * * C . gchar C . g_settings_schema_source_list_schemas ( v . native ( ) , gbool ( recursive ) , & nonRel , & rel ) return toGoStringArray ( nonRel ) , toGoStringArray ( rel ) } 
func ( v * ColorChooser ) native ( ) * C . GtkColorChooser { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkColorChooser ( p ) } 
func ( v * ColorChooser ) GetRGBA ( ) * gdk . RGBA { gdkColor := gdk . NewRGBA ( ) C . gtk_color_chooser_get_rgba ( v . native ( ) , ( * C . GdkRGBA ) ( unsafe . Pointer ( gdkColor . Native ( ) ) ) ) return gdkColor } 
func ( v * ColorChooser ) SetRGBA ( gdkColor * gdk . RGBA ) { C . gtk_color_chooser_set_rgba ( v . native ( ) , ( * C . GdkRGBA ) ( unsafe . Pointer ( gdkColor . Native ( ) ) ) ) } 
func ( v * ColorChooser ) SetUseAlpha ( use_alpha bool ) { C . gtk_color_chooser_set_use_alpha ( v . native ( ) , gbool ( use_alpha ) ) } 
func ( v * ColorChooser ) AddPalette ( orientation Orientation , colors_per_line int , colors [ ] * gdk . RGBA ) { n_colors := len ( colors ) var c_colors [ ] C . GdkRGBA for _ , c := range colors { c_colors = append ( c_colors , * ( * C . GdkRGBA ) ( unsafe . Pointer ( c . Native ( ) ) ) ) } C . gtk_color_chooser_add_palette ( v . native ( ) , C . GtkOrientation ( orientation ) , C . gint ( colors_per_line ) , C . gint ( n_colors ) , & c_colors [ 0 ] , ) } 
func ( v * ColorChooserDialog ) native ( ) * C . GtkColorChooserDialog { if v == nil || v . GObject == nil { return nil } p := unsafe . Pointer ( v . GObject ) return C . toGtkColorChooserDialog ( p ) } 
func ColorChooserDialogNew ( title string , parent * Window ) ( * ColorChooserDialog , error ) { cstr := C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) c := C . gtk_color_chooser_dialog_new ( ( * C . gchar ) ( cstr ) , parent . native ( ) ) if c == nil { return nil , nilPtrErr } return wrapColorChooserDialog ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Source ) native ( ) * C . GSource { if v == nil { return nil } return ( * C . GSource ) ( v ) } 
func MainCurrentSource ( ) * Source { c := C . g_main_current_source ( ) if c == nil { return nil } return ( * Source ) ( c ) } 
func ( v * Context ) Translate ( tx , ty float64 ) { C . cairo_translate ( v . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( v * Context ) Scale ( sx , sy float64 ) { C . cairo_scale ( v . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( v * Context ) Rotate ( angle float64 ) { C . cairo_rotate ( v . native ( ) , C . double ( angle ) ) } 
func ( v * Context ) Transform ( matrix * Matrix ) { C . cairo_transform ( v . native ( ) , matrix . native ( ) ) } 
func ( v * Context ) SetMatrix ( matrix * Matrix ) { C . cairo_set_matrix ( v . native ( ) , matrix . native ( ) ) } 
func ( v * Context ) GetMatrix ( ) * Matrix { var matrix C . cairo_matrix_t C . cairo_get_matrix ( v . native ( ) , & matrix ) return & Matrix { Xx : float64 ( matrix . xx ) , Yx : float64 ( matrix . yx ) , Xy : float64 ( matrix . xy ) , Yy : float64 ( matrix . yy ) , X0 : float64 ( matrix . x0 ) , Y0 : float64 ( matrix . y0 ) , } } 
func ( v * Context ) UserToDevice ( x , y float64 ) ( float64 , float64 ) { C . cairo_user_to_device ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( v * Context ) UserToDeviceDistance ( dx , dy float64 ) ( float64 , float64 ) { C . cairo_user_to_device_distance ( v . native ( ) , ( * C . double ) ( & dx ) , ( * C . double ) ( & dy ) ) return dx , dy } 
func ( v * Context ) DeviceToUser ( x , y float64 ) ( float64 , float64 ) { C . cairo_device_to_user ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( v * Context ) DeviceToUserDistance ( x , y float64 ) ( float64 , float64 ) { C . cairo_device_to_user_distance ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( p * Piece ) isBlocked ( i , j int , angle Angle ) bool { size := len ( p . blocks ) i2 , j2 := i , j switch angle { case Angle0 : case Angle90 : i2 = j j2 = size - 1 - i case Angle180 : i2 = size - 1 - i j2 = size - 1 - j case Angle270 : i2 = size - 1 - j j2 = i } return p . blocks [ i2 ] [ j2 ] } 
func ( p * Piece ) collides ( field * Field , x , y int , angle Angle ) bool { size := len ( p . blocks ) for i := 0 ; i < size ; i ++ { for j := 0 ; j < size ; j ++ { if field . IsBlocked ( x + i , y + j ) && p . isBlocked ( i , j , angle ) { return true } } } return false } 
func ( s * Sprite ) In ( x , y int ) bool { } 
func ( s * Sprite ) MoveBy ( x , y int ) { w , h := s . image . Size ( ) s . x += x s . y += y if s . x < 0 { s . x = 0 } if s . x > screenWidth - w { s . x = screenWidth - w } if s . y < 0 { s . y = 0 } if s . y > screenHeight - h { s . y = screenHeight - h } } 
func ( s * Sprite ) Draw ( screen * ebiten . Image , dx , dy int , alpha float64 ) { op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( float64 ( s . x + dx ) , float64 ( s . y + dy ) ) op . ColorM . Scale ( 1 , 1 , 1 , alpha ) screen . DrawImage ( s . image , op ) screen . DrawImage ( s . image , op ) } 
func ( s * Stream ) Read ( buf [ ] byte ) ( int , error ) { if s . resampling != nil { return s . resampling . Read ( buf ) } return s . orig . Read ( buf ) } 
func ( s * Stream ) Seek ( offset int64 , whence int ) ( int64 , error ) { if s . resampling != nil { return s . resampling . Seek ( offset , whence ) } return s . orig . Seek ( offset , whence ) } 
func ( s * Stream ) Close ( ) error { runtime . SetFinalizer ( s , nil ) return s . toClose . Close ( ) } 
func ( s * Stream ) Length ( ) int64 { if s . resampling != nil { return s . resampling . Length ( ) } return s . orig . Length ( ) } 
func Decode ( context * audio . Context , src audio . ReadSeekCloser ) ( * Stream , error ) { d , err := mp3 . NewDecoder ( src ) if err != nil { return nil , err } var r * convert . Resampling if d . SampleRate ( ) != context . SampleRate ( ) { r = convert . NewResampling ( d , d . Length ( ) , d . SampleRate ( ) , context . SampleRate ( ) ) } s := & Stream { orig : d , resampling : r , toClose : src , } runtime . SetFinalizer ( s , ( * Stream ) . Close ) return s , nil } 
func InputChars ( ) [ ] rune { rb := uiDriver ( ) . Input ( ) . RuneBuffer ( ) return append ( make ( [ ] rune , 0 , len ( rb ) ) , rb ... ) } 
func IsKeyPressed ( key Key ) bool { return uiDriver ( ) . Input ( ) . IsKeyPressed ( driver . Key ( key ) ) } 
func IsMouseButtonPressed ( mouseButton MouseButton ) bool { return uiDriver ( ) . Input ( ) . IsMouseButtonPressed ( driver . MouseButton ( mouseButton ) ) } 
func GamepadAxis ( id int , axis int ) float64 { return uiDriver ( ) . Input ( ) . GamepadAxis ( id , axis ) } 
func IsGamepadButtonPressed ( id int , button GamepadButton ) bool { return uiDriver ( ) . Input ( ) . IsGamepadButtonPressed ( id , driver . GamepadButton ( button ) ) } 
func TouchPosition ( id int ) ( int , int ) { found := false for _ , i := range uiDriver ( ) . Input ( ) . TouchIDs ( ) { if id == i { found = true break } } if ! found { return 0 , 0 } return uiDriver ( ) . Input ( ) . TouchPosition ( id ) } 
func Touches ( ) [ ] Touch { var ts [ ] Touch for _ , id := range TouchIDs ( ) { x , y := TouchPosition ( id ) ts = append ( ts , & touch { id : id , x : x , y : y , } ) } return ts } 
func paeth ( a , b , c uint8 ) uint8 { pa := int ( b ) - pc pb := int ( a ) - pc pc = abs ( pa + pb ) pa = abs ( pa ) pb = abs ( pb ) if pa <= pb && pa <= pc { return a } else if pb <= pc { return b } return c } 
func filterPaeth ( cdat , pdat [ ] byte , bytesPerPixel int ) { var a , b , c , pa , pb , pc int for i := 0 ; i < bytesPerPixel ; i ++ { a , c = 0 , 0 for j := i ; j < len ( cdat ) ; j += bytesPerPixel { b = int ( pdat [ j ] ) pa = b - c pb = a - c pc = abs ( pa + pb ) pa = abs ( pa ) pb = abs ( pb ) if pa <= pb && pa <= pc { } else { a = c } a += int ( cdat [ j ] ) a &= 0xff cdat [ j ] = uint8 ( a ) c = b } } } 
func MipmapLevel ( det float32 ) int { if math . IsNaN ( float64 ( det ) ) { panic ( " " ) } if det == 0 { return - 1 } d := math . Abs ( float64 ( det ) ) level := 0 for d < 0.25 { level ++ d *= 4 } return level } 
func hideConsoleWindowOnWindows ( ) { pid , err := getCurrentProcessId ( ) if err != nil { } w , err := getConsoleWindow ( ) if err != nil { } if err != nil { } if pid == cpid { } } 
func Accum ( op uint32 , value float32 ) { C . glowAccum ( gpAccum , ( C . GLenum ) ( op ) , ( C . GLfloat ) ( value ) ) } 
func ActiveShaderProgram ( pipeline uint32 , program uint32 ) { C . glowActiveShaderProgram ( gpActiveShaderProgram , ( C . GLuint ) ( pipeline ) , ( C . GLuint ) ( program ) ) } 
func AlphaFunc ( xfunc uint32 , ref float32 ) { C . glowAlphaFunc ( gpAlphaFunc , ( C . GLenum ) ( xfunc ) , ( C . GLfloat ) ( ref ) ) } 
func AreTexturesResident ( n int32 , textures * uint32 , residences * bool ) bool { ret := C . glowAreTexturesResident ( gpAreTexturesResident , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) , ( * C . GLboolean ) ( unsafe . Pointer ( residences ) ) ) return ret == TRUE } 
func AttachShader ( program uint32 , shader uint32 ) { C . glowAttachShader ( gpAttachShader , ( C . GLuint ) ( program ) , ( C . GLuint ) ( shader ) ) } 
func BeginQuery ( target uint32 , id uint32 ) { C . glowBeginQuery ( gpBeginQuery , ( C . GLenum ) ( target ) , ( C . GLuint ) ( id ) ) } 
func BindAttribLocation ( program uint32 , index uint32 , name * uint8 ) { C . glowBindAttribLocation ( gpBindAttribLocation , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func BindBuffer ( target uint32 , buffer uint32 ) { C . glowBindBuffer ( gpBindBuffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( buffer ) ) } 
func BindBufferBase ( target uint32 , index uint32 , buffer uint32 ) { C . glowBindBufferBase ( gpBindBufferBase , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) ) } 
func BindBufferRange ( target uint32 , index uint32 , buffer uint32 , offset int , size int ) { C . glowBindBufferRange ( gpBindBufferRange , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func BindBuffersBase ( target uint32 , first uint32 , count int32 , buffers * uint32 ) { C . glowBindBuffersBase ( gpBindBuffersBase , ( C . GLenum ) ( target ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func BindBuffersRange ( target uint32 , first uint32 , count int32 , buffers * uint32 , offsets * int , sizes * int ) { C . glowBindBuffersRange ( gpBindBuffersRange , ( C . GLenum ) ( target ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizeiptr ) ( unsafe . Pointer ( sizes ) ) ) } 
func BindFragDataLocationIndexed ( program uint32 , colorNumber uint32 , index uint32 , name * uint8 ) { C . glowBindFragDataLocationIndexed ( gpBindFragDataLocationIndexed , ( C . GLuint ) ( program ) , ( C . GLuint ) ( colorNumber ) , ( C . GLuint ) ( index ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func BindFramebuffer ( target uint32 , framebuffer uint32 ) { C . glowBindFramebuffer ( gpBindFramebuffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( framebuffer ) ) } 
func BindImageTexture ( unit uint32 , texture uint32 , level int32 , layered bool , layer int32 , access uint32 , format uint32 ) { C . glowBindImageTexture ( gpBindImageTexture , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLboolean ) ( boolToInt ( layered ) ) , ( C . GLint ) ( layer ) , ( C . GLenum ) ( access ) , ( C . GLenum ) ( format ) ) } 
func BindImageTextures ( first uint32 , count int32 , textures * uint32 ) { C . glowBindImageTextures ( gpBindImageTextures , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func BindRenderbuffer ( target uint32 , renderbuffer uint32 ) { C . glowBindRenderbuffer ( gpBindRenderbuffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( renderbuffer ) ) } 
func BindSampler ( unit uint32 , sampler uint32 ) { C . glowBindSampler ( gpBindSampler , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( sampler ) ) } 
func BindSamplers ( first uint32 , count int32 , samplers * uint32 ) { C . glowBindSamplers ( gpBindSamplers , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func BindTexture ( target uint32 , texture uint32 ) { C . glowBindTexture ( gpBindTexture , ( C . GLenum ) ( target ) , ( C . GLuint ) ( texture ) ) } 
func BindTextureUnit ( unit uint32 , texture uint32 ) { C . glowBindTextureUnit ( gpBindTextureUnit , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( texture ) ) } 
func BindTextures ( first uint32 , count int32 , textures * uint32 ) { C . glowBindTextures ( gpBindTextures , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func BindTransformFeedback ( target uint32 , id uint32 ) { C . glowBindTransformFeedback ( gpBindTransformFeedback , ( C . GLenum ) ( target ) , ( C . GLuint ) ( id ) ) } 
func BindVertexBuffer ( bindingindex uint32 , buffer uint32 , offset int , stride int32 ) { C . glowBindVertexBuffer ( gpBindVertexBuffer , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizei ) ( stride ) ) } 
func BindVertexBuffers ( first uint32 , count int32 , buffers * uint32 , offsets * int , strides * int32 ) { C . glowBindVertexBuffers ( gpBindVertexBuffers , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( strides ) ) ) } 
func Bitmap ( width int32 , height int32 , xorig float32 , yorig float32 , xmove float32 , ymove float32 , bitmap * uint8 ) { C . glowBitmap ( gpBitmap , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLfloat ) ( xorig ) , ( C . GLfloat ) ( yorig ) , ( C . GLfloat ) ( xmove ) , ( C . GLfloat ) ( ymove ) , ( * C . GLubyte ) ( unsafe . Pointer ( bitmap ) ) ) } 
func BlendColor ( red float32 , green float32 , blue float32 , alpha float32 ) { C . glowBlendColor ( gpBlendColor , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func BlendEquationSeparate ( modeRGB uint32 , modeAlpha uint32 ) { C . glowBlendEquationSeparate ( gpBlendEquationSeparate , ( C . GLenum ) ( modeRGB ) , ( C . GLenum ) ( modeAlpha ) ) } 
func BlendFunc ( sfactor uint32 , dfactor uint32 ) { C . glowBlendFunc ( gpBlendFunc , ( C . GLenum ) ( sfactor ) , ( C . GLenum ) ( dfactor ) ) } 
func BlendFuncSeparate ( sfactorRGB uint32 , dfactorRGB uint32 , sfactorAlpha uint32 , dfactorAlpha uint32 ) { C . glowBlendFuncSeparate ( gpBlendFuncSeparate , ( C . GLenum ) ( sfactorRGB ) , ( C . GLenum ) ( dfactorRGB ) , ( C . GLenum ) ( sfactorAlpha ) , ( C . GLenum ) ( dfactorAlpha ) ) } 
func BlitFramebuffer ( srcX0 int32 , srcY0 int32 , srcX1 int32 , srcY1 int32 , dstX0 int32 , dstY0 int32 , dstX1 int32 , dstY1 int32 , mask uint32 , filter uint32 ) { C . glowBlitFramebuffer ( gpBlitFramebuffer , ( C . GLint ) ( srcX0 ) , ( C . GLint ) ( srcY0 ) , ( C . GLint ) ( srcX1 ) , ( C . GLint ) ( srcY1 ) , ( C . GLint ) ( dstX0 ) , ( C . GLint ) ( dstY0 ) , ( C . GLint ) ( dstX1 ) , ( C . GLint ) ( dstY1 ) , ( C . GLbitfield ) ( mask ) , ( C . GLenum ) ( filter ) ) } 
func BlitNamedFramebuffer ( readFramebuffer uint32 , drawFramebuffer uint32 , srcX0 int32 , srcY0 int32 , srcX1 int32 , srcY1 int32 , dstX0 int32 , dstY0 int32 , dstX1 int32 , dstY1 int32 , mask uint32 , filter uint32 ) { C . glowBlitNamedFramebuffer ( gpBlitNamedFramebuffer , ( C . GLuint ) ( readFramebuffer ) , ( C . GLuint ) ( drawFramebuffer ) , ( C . GLint ) ( srcX0 ) , ( C . GLint ) ( srcY0 ) , ( C . GLint ) ( srcX1 ) , ( C . GLint ) ( srcY1 ) , ( C . GLint ) ( dstX0 ) , ( C . GLint ) ( dstY0 ) , ( C . GLint ) ( dstX1 ) , ( C . GLint ) ( dstY1 ) , ( C . GLbitfield ) ( mask ) , ( C . GLenum ) ( filter ) ) } 
func BufferData ( target uint32 , size int , data unsafe . Pointer , usage uint32 ) { C . glowBufferData ( gpBufferData , ( C . GLenum ) ( target ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLenum ) ( usage ) ) } 
func BufferStorage ( target uint32 , size int , data unsafe . Pointer , flags uint32 ) { C . glowBufferStorage ( gpBufferStorage , ( C . GLenum ) ( target ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLbitfield ) ( flags ) ) } 
func BufferStorageExternalEXT ( target uint32 , offset int , size int , clientBuffer unsafe . Pointer , flags uint32 ) { C . glowBufferStorageExternalEXT ( gpBufferStorageExternalEXT , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLeglClientBufferEXT ) ( clientBuffer ) , ( C . GLbitfield ) ( flags ) ) } 
func BufferSubData ( target uint32 , offset int , size int , data unsafe . Pointer ) { C . glowBufferSubData ( gpBufferSubData , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func CallLists ( n int32 , xtype uint32 , lists unsafe . Pointer ) { C . glowCallLists ( gpCallLists , ( C . GLsizei ) ( n ) , ( C . GLenum ) ( xtype ) , lists ) } 
func CheckFramebufferStatus ( target uint32 ) uint32 { ret := C . glowCheckFramebufferStatus ( gpCheckFramebufferStatus , ( C . GLenum ) ( target ) ) return ( uint32 ) ( ret ) } 
func CheckNamedFramebufferStatus ( framebuffer uint32 , target uint32 ) uint32 { ret := C . glowCheckNamedFramebufferStatus ( gpCheckNamedFramebufferStatus , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( target ) ) return ( uint32 ) ( ret ) } 
func ClearAccum ( red float32 , green float32 , blue float32 , alpha float32 ) { C . glowClearAccum ( gpClearAccum , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func ClearBufferData ( target uint32 , internalformat uint32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearBufferData ( gpClearBufferData , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClearBufferSubData ( target uint32 , internalformat uint32 , offset int , size int , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearBufferSubData ( gpClearBufferSubData , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClearColor ( red float32 , green float32 , blue float32 , alpha float32 ) { C . glowClearColor ( gpClearColor , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func ClearNamedBufferData ( buffer uint32 , internalformat uint32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearNamedBufferData ( gpClearNamedBufferData , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClearNamedBufferSubData ( buffer uint32 , internalformat uint32 , offset int , size int , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearNamedBufferSubData ( gpClearNamedBufferSubData , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClearTexImage ( texture uint32 , level int32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearTexImage ( gpClearTexImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClearTexSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { C . glowClearTexSubImage ( gpClearTexSubImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func ClientWaitSync ( sync uintptr , flags uint32 , timeout uint64 ) uint32 { ret := C . glowClientWaitSync ( gpClientWaitSync , ( C . GLsync ) ( sync ) , ( C . GLbitfield ) ( flags ) , ( C . GLuint64 ) ( timeout ) ) return ( uint32 ) ( ret ) } 
func ClipControl ( origin uint32 , depth uint32 ) { C . glowClipControl ( gpClipControl , ( C . GLenum ) ( origin ) , ( C . GLenum ) ( depth ) ) } 
func ClipPlane ( plane uint32 , equation * float64 ) { C . glowClipPlane ( gpClipPlane , ( C . GLenum ) ( plane ) , ( * C . GLdouble ) ( unsafe . Pointer ( equation ) ) ) } 
func ColorMaterial ( face uint32 , mode uint32 ) { C . glowColorMaterial ( gpColorMaterial , ( C . GLenum ) ( face ) , ( C . GLenum ) ( mode ) ) } 
func ColorPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowColorPointer ( gpColorPointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func CompressedTexImage1D ( target uint32 , level int32 , internalformat uint32 , width int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexImage1D ( gpCompressedTexImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTexImage2D ( target uint32 , level int32 , internalformat uint32 , width int32 , height int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexImage2D ( gpCompressedTexImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTexImage3D ( target uint32 , level int32 , internalformat uint32 , width int32 , height int32 , depth int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexImage3D ( gpCompressedTexImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTexSubImage1D ( target uint32 , level int32 , xoffset int32 , width int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexSubImage1D ( gpCompressedTexSubImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTexSubImage2D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexSubImage2D ( gpCompressedTexSubImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTexSubImage3D ( gpCompressedTexSubImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , width int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTextureSubImage1D ( gpCompressedTextureSubImage1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTextureSubImage2D ( gpCompressedTextureSubImage2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CompressedTextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { C . glowCompressedTextureSubImage3D ( gpCompressedTextureSubImage3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( imageSize ) , data ) } 
func CopyBufferSubData ( readTarget uint32 , writeTarget uint32 , readOffset int , writeOffset int , size int ) { C . glowCopyBufferSubData ( gpCopyBufferSubData , ( C . GLenum ) ( readTarget ) , ( C . GLenum ) ( writeTarget ) , ( C . GLintptr ) ( readOffset ) , ( C . GLintptr ) ( writeOffset ) , ( C . GLsizeiptr ) ( size ) ) } 
func CopyImageSubData ( srcName uint32 , srcTarget uint32 , srcLevel int32 , srcX int32 , srcY int32 , srcZ int32 , dstName uint32 , dstTarget uint32 , dstLevel int32 , dstX int32 , dstY int32 , dstZ int32 , srcWidth int32 , srcHeight int32 , srcDepth int32 ) { C . glowCopyImageSubData ( gpCopyImageSubData , ( C . GLuint ) ( srcName ) , ( C . GLenum ) ( srcTarget ) , ( C . GLint ) ( srcLevel ) , ( C . GLint ) ( srcX ) , ( C . GLint ) ( srcY ) , ( C . GLint ) ( srcZ ) , ( C . GLuint ) ( dstName ) , ( C . GLenum ) ( dstTarget ) , ( C . GLint ) ( dstLevel ) , ( C . GLint ) ( dstX ) , ( C . GLint ) ( dstY ) , ( C . GLint ) ( dstZ ) , ( C . GLsizei ) ( srcWidth ) , ( C . GLsizei ) ( srcHeight ) , ( C . GLsizei ) ( srcDepth ) ) } 
func CopyNamedBufferSubData ( readBuffer uint32 , writeBuffer uint32 , readOffset int , writeOffset int , size int ) { C . glowCopyNamedBufferSubData ( gpCopyNamedBufferSubData , ( C . GLuint ) ( readBuffer ) , ( C . GLuint ) ( writeBuffer ) , ( C . GLintptr ) ( readOffset ) , ( C . GLintptr ) ( writeOffset ) , ( C . GLsizeiptr ) ( size ) ) } 
func CopyPixels ( x int32 , y int32 , width int32 , height int32 , xtype uint32 ) { C . glowCopyPixels ( gpCopyPixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( xtype ) ) } 
func CopyTexImage1D ( target uint32 , level int32 , internalformat uint32 , x int32 , y int32 , width int32 , border int32 ) { C . glowCopyTexImage1D ( gpCopyTexImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) ) } 
func CopyTexImage2D ( target uint32 , level int32 , internalformat uint32 , x int32 , y int32 , width int32 , height int32 , border int32 ) { C . glowCopyTexImage2D ( gpCopyTexImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) ) } 
func CopyTexSubImage1D ( target uint32 , level int32 , xoffset int32 , x int32 , y int32 , width int32 ) { C . glowCopyTexSubImage1D ( gpCopyTexSubImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) ) } 
func CopyTexSubImage2D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , x int32 , y int32 , width int32 , height int32 ) { C . glowCopyTexSubImage2D ( gpCopyTexSubImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func CopyTexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , x int32 , y int32 , width int32 , height int32 ) { C . glowCopyTexSubImage3D ( gpCopyTexSubImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func CopyTextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , x int32 , y int32 , width int32 ) { C . glowCopyTextureSubImage1D ( gpCopyTextureSubImage1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) ) } 
func CopyTextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , x int32 , y int32 , width int32 , height int32 ) { C . glowCopyTextureSubImage2D ( gpCopyTextureSubImage2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func CopyTextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , x int32 , y int32 , width int32 , height int32 ) { C . glowCopyTextureSubImage3D ( gpCopyTextureSubImage3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func CreateBuffers ( n int32 , buffers * uint32 ) { C . glowCreateBuffers ( gpCreateBuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func CreateFramebuffers ( n int32 , framebuffers * uint32 ) { C . glowCreateFramebuffers ( gpCreateFramebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func CreateProgramPipelines ( n int32 , pipelines * uint32 ) { C . glowCreateProgramPipelines ( gpCreateProgramPipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func CreateQueries ( target uint32 , n int32 , ids * uint32 ) { C . glowCreateQueries ( gpCreateQueries , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func CreateRenderbuffers ( n int32 , renderbuffers * uint32 ) { C . glowCreateRenderbuffers ( gpCreateRenderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func CreateSamplers ( n int32 , samplers * uint32 ) { C . glowCreateSamplers ( gpCreateSamplers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func CreateShader ( xtype uint32 ) uint32 { ret := C . glowCreateShader ( gpCreateShader , ( C . GLenum ) ( xtype ) ) return ( uint32 ) ( ret ) } 
func CreateShaderProgramv ( xtype uint32 , count int32 , strings * * uint8 ) uint32 { ret := C . glowCreateShaderProgramv ( gpCreateShaderProgramv , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( count ) , ( * * C . GLchar ) ( unsafe . Pointer ( strings ) ) ) return ( uint32 ) ( ret ) } 
func CreateSyncFromCLeventARB ( context unsafe . Pointer , event unsafe . Pointer , flags uint32 ) uintptr { ret := C . glowCreateSyncFromCLeventARB ( gpCreateSyncFromCLeventARB , ( * C . struct__cl_context ) ( context ) , ( * C . struct__cl_event ) ( event ) , ( C . GLbitfield ) ( flags ) ) return ( uintptr ) ( ret ) } 
func CreateTextures ( target uint32 , n int32 , textures * uint32 ) { C . glowCreateTextures ( gpCreateTextures , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func CreateTransformFeedbacks ( n int32 , ids * uint32 ) { C . glowCreateTransformFeedbacks ( gpCreateTransformFeedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func CreateVertexArrays ( n int32 , arrays * uint32 ) { C . glowCreateVertexArrays ( gpCreateVertexArrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func DebugMessageCallbackAMD ( callback unsafe . Pointer , userParam unsafe . Pointer ) { C . glowDebugMessageCallbackAMD ( gpDebugMessageCallbackAMD , ( C . GLDEBUGPROCAMD ) ( callback ) , userParam ) } 
func DebugMessageCallbackARB ( callback unsafe . Pointer , userParam unsafe . Pointer ) { C . glowDebugMessageCallbackARB ( gpDebugMessageCallbackARB , ( C . GLDEBUGPROCARB ) ( unsafe . Pointer ( & callback ) ) , userParam ) } 
func DebugMessageCallbackKHR ( callback unsafe . Pointer , userParam unsafe . Pointer ) { C . glowDebugMessageCallbackKHR ( gpDebugMessageCallbackKHR , ( C . GLDEBUGPROCKHR ) ( unsafe . Pointer ( & callback ) ) , userParam ) } 
func DebugMessageControl ( source uint32 , xtype uint32 , severity uint32 , count int32 , ids * uint32 , enabled bool ) { C . glowDebugMessageControl ( gpDebugMessageControl , ( C . GLenum ) ( source ) , ( C . GLenum ) ( xtype ) , ( C . GLenum ) ( severity ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) , ( C . GLboolean ) ( boolToInt ( enabled ) ) ) } 
func DebugMessageInsert ( source uint32 , xtype uint32 , id uint32 , severity uint32 , length int32 , buf * uint8 ) { C . glowDebugMessageInsert ( gpDebugMessageInsert , ( C . GLenum ) ( source ) , ( C . GLenum ) ( xtype ) , ( C . GLuint ) ( id ) , ( C . GLenum ) ( severity ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( buf ) ) ) } 
func DeleteBuffers ( n int32 , buffers * uint32 ) { C . glowDeleteBuffers ( gpDeleteBuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func DeleteFramebuffers ( n int32 , framebuffers * uint32 ) { C . glowDeleteFramebuffers ( gpDeleteFramebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func DeleteLists ( list uint32 , xrange int32 ) { C . glowDeleteLists ( gpDeleteLists , ( C . GLuint ) ( list ) , ( C . GLsizei ) ( xrange ) ) } 
func DeleteProgramPipelines ( n int32 , pipelines * uint32 ) { C . glowDeleteProgramPipelines ( gpDeleteProgramPipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func DeleteQueries ( n int32 , ids * uint32 ) { C . glowDeleteQueries ( gpDeleteQueries , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func DeleteRenderbuffers ( n int32 , renderbuffers * uint32 ) { C . glowDeleteRenderbuffers ( gpDeleteRenderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func DeleteSamplers ( count int32 , samplers * uint32 ) { C . glowDeleteSamplers ( gpDeleteSamplers , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func DeleteTextures ( n int32 , textures * uint32 ) { C . glowDeleteTextures ( gpDeleteTextures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func DeleteTransformFeedbacks ( n int32 , ids * uint32 ) { C . glowDeleteTransformFeedbacks ( gpDeleteTransformFeedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func DeleteVertexArrays ( n int32 , arrays * uint32 ) { C . glowDeleteVertexArrays ( gpDeleteVertexArrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func DepthMask ( flag bool ) { C . glowDepthMask ( gpDepthMask , ( C . GLboolean ) ( boolToInt ( flag ) ) ) } 
func DepthRange ( n float64 , f float64 ) { C . glowDepthRange ( gpDepthRange , ( C . GLdouble ) ( n ) , ( C . GLdouble ) ( f ) ) } 
func DepthRangeIndexed ( index uint32 , n float64 , f float64 ) { C . glowDepthRangeIndexed ( gpDepthRangeIndexed , ( C . GLuint ) ( index ) , ( C . GLdouble ) ( n ) , ( C . GLdouble ) ( f ) ) } 
func DepthRangef ( n float32 , f float32 ) { C . glowDepthRangef ( gpDepthRangef , ( C . GLfloat ) ( n ) , ( C . GLfloat ) ( f ) ) } 
func DetachShader ( program uint32 , shader uint32 ) { C . glowDetachShader ( gpDetachShader , ( C . GLuint ) ( program ) , ( C . GLuint ) ( shader ) ) } 
func DisableVertexArrayAttrib ( vaobj uint32 , index uint32 ) { C . glowDisableVertexArrayAttrib ( gpDisableVertexArrayAttrib , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( index ) ) } 
func DispatchCompute ( num_groups_x uint32 , num_groups_y uint32 , num_groups_z uint32 ) { C . glowDispatchCompute ( gpDispatchCompute , ( C . GLuint ) ( num_groups_x ) , ( C . GLuint ) ( num_groups_y ) , ( C . GLuint ) ( num_groups_z ) ) } 
func DrawArrays ( mode uint32 , first int32 , count int32 ) { C . glowDrawArrays ( gpDrawArrays , ( C . GLenum ) ( mode ) , ( C . GLint ) ( first ) , ( C . GLsizei ) ( count ) ) } 
func DrawArraysIndirect ( mode uint32 , indirect unsafe . Pointer ) { C . glowDrawArraysIndirect ( gpDrawArraysIndirect , ( C . GLenum ) ( mode ) , indirect ) } 
func DrawArraysInstancedBaseInstance ( mode uint32 , first int32 , count int32 , instancecount int32 , baseinstance uint32 ) { C . glowDrawArraysInstancedBaseInstance ( gpDrawArraysInstancedBaseInstance , ( C . GLenum ) ( mode ) , ( C . GLint ) ( first ) , ( C . GLsizei ) ( count ) , ( C . GLsizei ) ( instancecount ) , ( C . GLuint ) ( baseinstance ) ) } 
func DrawBuffers ( n int32 , bufs * uint32 ) { C . glowDrawBuffers ( gpDrawBuffers , ( C . GLsizei ) ( n ) , ( * C . GLenum ) ( unsafe . Pointer ( bufs ) ) ) } 
func DrawElements ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer ) { C . glowDrawElements ( gpDrawElements , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices ) } 
func DrawElementsBaseVertex ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , basevertex int32 ) { C . glowDrawElementsBaseVertex ( gpDrawElementsBaseVertex , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLint ) ( basevertex ) ) } 
func DrawElementsIndirect ( mode uint32 , xtype uint32 , indirect unsafe . Pointer ) { C . glowDrawElementsIndirect ( gpDrawElementsIndirect , ( C . GLenum ) ( mode ) , ( C . GLenum ) ( xtype ) , indirect ) } 
func DrawElementsInstancedBaseInstance ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , baseinstance uint32 ) { C . glowDrawElementsInstancedBaseInstance ( gpDrawElementsInstancedBaseInstance , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLuint ) ( baseinstance ) ) } 
func DrawElementsInstancedBaseVertex ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , basevertex int32 ) { C . glowDrawElementsInstancedBaseVertex ( gpDrawElementsInstancedBaseVertex , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLint ) ( basevertex ) ) } 
func DrawElementsInstancedBaseVertexBaseInstance ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , basevertex int32 , baseinstance uint32 ) { C . glowDrawElementsInstancedBaseVertexBaseInstance ( gpDrawElementsInstancedBaseVertexBaseInstance , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLint ) ( basevertex ) , ( C . GLuint ) ( baseinstance ) ) } 
func DrawPixels ( width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowDrawPixels ( gpDrawPixels , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func DrawRangeElements ( mode uint32 , start uint32 , end uint32 , count int32 , xtype uint32 , indices unsafe . Pointer ) { C . glowDrawRangeElements ( gpDrawRangeElements , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( start ) , ( C . GLuint ) ( end ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices ) } 
func DrawRangeElementsBaseVertex ( mode uint32 , start uint32 , end uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , basevertex int32 ) { C . glowDrawRangeElementsBaseVertex ( gpDrawRangeElementsBaseVertex , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( start ) , ( C . GLuint ) ( end ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLint ) ( basevertex ) ) } 
func DrawTransformFeedback ( mode uint32 , id uint32 ) { C . glowDrawTransformFeedback ( gpDrawTransformFeedback , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) ) } 
func DrawTransformFeedbackInstanced ( mode uint32 , id uint32 , instancecount int32 ) { C . glowDrawTransformFeedbackInstanced ( gpDrawTransformFeedbackInstanced , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLsizei ) ( instancecount ) ) } 
func DrawTransformFeedbackStream ( mode uint32 , id uint32 , stream uint32 ) { C . glowDrawTransformFeedbackStream ( gpDrawTransformFeedbackStream , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLuint ) ( stream ) ) } 
func DrawTransformFeedbackStreamInstanced ( mode uint32 , id uint32 , stream uint32 , instancecount int32 ) { C . glowDrawTransformFeedbackStreamInstanced ( gpDrawTransformFeedbackStreamInstanced , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLuint ) ( stream ) , ( C . GLsizei ) ( instancecount ) ) } 
func EGLImageTargetTexStorageEXT ( target uint32 , image unsafe . Pointer , attrib_list * int32 ) { C . glowEGLImageTargetTexStorageEXT ( gpEGLImageTargetTexStorageEXT , ( C . GLenum ) ( target ) , ( C . GLeglImageOES ) ( image ) , ( * C . GLint ) ( unsafe . Pointer ( attrib_list ) ) ) } 
func EGLImageTargetTextureStorageEXT ( texture uint32 , image unsafe . Pointer , attrib_list * int32 ) { C . glowEGLImageTargetTextureStorageEXT ( gpEGLImageTargetTextureStorageEXT , ( C . GLuint ) ( texture ) , ( C . GLeglImageOES ) ( image ) , ( * C . GLint ) ( unsafe . Pointer ( attrib_list ) ) ) } 
func EdgeFlag ( flag bool ) { C . glowEdgeFlag ( gpEdgeFlag , ( C . GLboolean ) ( boolToInt ( flag ) ) ) } 
func EdgeFlagPointer ( stride int32 , pointer unsafe . Pointer ) { C . glowEdgeFlagPointer ( gpEdgeFlagPointer , ( C . GLsizei ) ( stride ) , pointer ) } 
func EnableVertexArrayAttrib ( vaobj uint32 , index uint32 ) { C . glowEnableVertexArrayAttrib ( gpEnableVertexArrayAttrib , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( index ) ) } 
func FeedbackBuffer ( size int32 , xtype uint32 , buffer * float32 ) { C . glowFeedbackBuffer ( gpFeedbackBuffer , ( C . GLsizei ) ( size ) , ( C . GLenum ) ( xtype ) , ( * C . GLfloat ) ( unsafe . Pointer ( buffer ) ) ) } 
func FenceSync ( condition uint32 , flags uint32 ) uintptr { ret := C . glowFenceSync ( gpFenceSync , ( C . GLenum ) ( condition ) , ( C . GLbitfield ) ( flags ) ) return ( uintptr ) ( ret ) } 
func FlushMappedBufferRange ( target uint32 , offset int , length int ) { C . glowFlushMappedBufferRange ( gpFlushMappedBufferRange , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func FlushMappedNamedBufferRange ( buffer uint32 , offset int , length int ) { C . glowFlushMappedNamedBufferRange ( gpFlushMappedNamedBufferRange , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func FogCoordPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowFogCoordPointer ( gpFogCoordPointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func FramebufferParameteri ( target uint32 , pname uint32 , param int32 ) { C . glowFramebufferParameteri ( gpFramebufferParameteri , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func FramebufferRenderbuffer ( target uint32 , attachment uint32 , renderbuffertarget uint32 , renderbuffer uint32 ) { C . glowFramebufferRenderbuffer ( gpFramebufferRenderbuffer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( renderbuffertarget ) , ( C . GLuint ) ( renderbuffer ) ) } 
func FramebufferTexture2D ( target uint32 , attachment uint32 , textarget uint32 , texture uint32 , level int32 ) { C . glowFramebufferTexture2D ( gpFramebufferTexture2D , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( textarget ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) ) } 
func FramebufferTextureLayer ( target uint32 , attachment uint32 , texture uint32 , level int32 , layer int32 ) { C . glowFramebufferTextureLayer ( gpFramebufferTextureLayer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( layer ) ) } 
func Frustum ( left float64 , right float64 , bottom float64 , top float64 , zNear float64 , zFar float64 ) { C . glowFrustum ( gpFrustum , ( C . GLdouble ) ( left ) , ( C . GLdouble ) ( right ) , ( C . GLdouble ) ( bottom ) , ( C . GLdouble ) ( top ) , ( C . GLdouble ) ( zNear ) , ( C . GLdouble ) ( zFar ) ) } 
func GenBuffers ( n int32 , buffers * uint32 ) { C . glowGenBuffers ( gpGenBuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func GenFramebuffers ( n int32 , framebuffers * uint32 ) { C . glowGenFramebuffers ( gpGenFramebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func GenLists ( xrange int32 ) uint32 { ret := C . glowGenLists ( gpGenLists , ( C . GLsizei ) ( xrange ) ) return ( uint32 ) ( ret ) } 
func GenProgramPipelines ( n int32 , pipelines * uint32 ) { C . glowGenProgramPipelines ( gpGenProgramPipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func GenQueries ( n int32 , ids * uint32 ) { C . glowGenQueries ( gpGenQueries , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func GenRenderbuffers ( n int32 , renderbuffers * uint32 ) { C . glowGenRenderbuffers ( gpGenRenderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func GenSamplers ( count int32 , samplers * uint32 ) { C . glowGenSamplers ( gpGenSamplers , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func GenTextures ( n int32 , textures * uint32 ) { C . glowGenTextures ( gpGenTextures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func GenTransformFeedbacks ( n int32 , ids * uint32 ) { C . glowGenTransformFeedbacks ( gpGenTransformFeedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func GenVertexArrays ( n int32 , arrays * uint32 ) { C . glowGenVertexArrays ( gpGenVertexArrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func GetActiveAtomicCounterBufferiv ( program uint32 , bufferIndex uint32 , pname uint32 , params * int32 ) { C . glowGetActiveAtomicCounterBufferiv ( gpGetActiveAtomicCounterBufferiv , ( C . GLuint ) ( program ) , ( C . GLuint ) ( bufferIndex ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetActiveAttrib ( program uint32 , index uint32 , bufSize int32 , length * int32 , size * int32 , xtype * uint32 , name * uint8 ) { C . glowGetActiveAttrib ( gpGetActiveAttrib , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( size ) ) , ( * C . GLenum ) ( unsafe . Pointer ( xtype ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func GetActiveSubroutineName ( program uint32 , shadertype uint32 , index uint32 , bufsize int32 , length * int32 , name * uint8 ) { C . glowGetActiveSubroutineName ( gpGetActiveSubroutineName , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufsize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func GetActiveSubroutineUniformName ( program uint32 , shadertype uint32 , index uint32 , bufsize int32 , length * int32 , name * uint8 ) { C . glowGetActiveSubroutineUniformName ( gpGetActiveSubroutineUniformName , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufsize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func GetActiveUniform ( program uint32 , index uint32 , bufSize int32 , length * int32 , size * int32 , xtype * uint32 , name * uint8 ) { C . glowGetActiveUniform ( gpGetActiveUniform , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( size ) ) , ( * C . GLenum ) ( unsafe . Pointer ( xtype ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func GetActiveUniformBlockName ( program uint32 , uniformBlockIndex uint32 , bufSize int32 , length * int32 , uniformBlockName * uint8 ) { C . glowGetActiveUniformBlockName ( gpGetActiveUniformBlockName , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniformBlockIndex ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( uniformBlockName ) ) ) } 
func GetActiveUniformBlockiv ( program uint32 , uniformBlockIndex uint32 , pname uint32 , params * int32 ) { C . glowGetActiveUniformBlockiv ( gpGetActiveUniformBlockiv , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniformBlockIndex ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetActiveUniformName ( program uint32 , uniformIndex uint32 , bufSize int32 , length * int32 , uniformName * uint8 ) { C . glowGetActiveUniformName ( gpGetActiveUniformName , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniformIndex ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( uniformName ) ) ) } 
func GetActiveUniformsiv ( program uint32 , uniformCount int32 , uniformIndices * uint32 , pname uint32 , params * int32 ) { C . glowGetActiveUniformsiv ( gpGetActiveUniformsiv , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( uniformCount ) , ( * C . GLuint ) ( unsafe . Pointer ( uniformIndices ) ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetAttachedShaders ( program uint32 , maxCount int32 , count * int32 , shaders * uint32 ) { C . glowGetAttachedShaders ( gpGetAttachedShaders , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( maxCount ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( * C . GLuint ) ( unsafe . Pointer ( shaders ) ) ) } 
func GetAttribLocation ( program uint32 , name * uint8 ) int32 { ret := C . glowGetAttribLocation ( gpGetAttribLocation , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetBufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { C . glowGetBufferParameteriv ( gpGetBufferParameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetBufferPointerv ( target uint32 , pname uint32 , params * unsafe . Pointer ) { C . glowGetBufferPointerv ( gpGetBufferPointerv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , params ) } 
func GetBufferSubData ( target uint32 , offset int , size int , data unsafe . Pointer ) { C . glowGetBufferSubData ( gpGetBufferSubData , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func GetClipPlane ( plane uint32 , equation * float64 ) { C . glowGetClipPlane ( gpGetClipPlane , ( C . GLenum ) ( plane ) , ( * C . GLdouble ) ( unsafe . Pointer ( equation ) ) ) } 
func GetCompressedTexImage ( target uint32 , level int32 , img unsafe . Pointer ) { C . glowGetCompressedTexImage ( gpGetCompressedTexImage , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , img ) } 
func GetCompressedTextureImage ( texture uint32 , level int32 , bufSize int32 , pixels unsafe . Pointer ) { C . glowGetCompressedTextureImage ( gpGetCompressedTextureImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLsizei ) ( bufSize ) , pixels ) } 
func GetCompressedTextureSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , bufSize int32 , pixels unsafe . Pointer ) { C . glowGetCompressedTextureSubImage ( gpGetCompressedTextureSubImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLsizei ) ( bufSize ) , pixels ) } 
func GetDebugMessageLog ( count uint32 , bufSize int32 , sources * uint32 , types * uint32 , ids * uint32 , severities * uint32 , lengths * int32 , messageLog * uint8 ) uint32 { ret := C . glowGetDebugMessageLog ( gpGetDebugMessageLog , ( C . GLuint ) ( count ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLenum ) ( unsafe . Pointer ( sources ) ) , ( * C . GLenum ) ( unsafe . Pointer ( types ) ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) , ( * C . GLenum ) ( unsafe . Pointer ( severities ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( lengths ) ) , ( * C . GLchar ) ( unsafe . Pointer ( messageLog ) ) ) return ( uint32 ) ( ret ) } 
func GetFragDataIndex ( program uint32 , name * uint8 ) int32 { ret := C . glowGetFragDataIndex ( gpGetFragDataIndex , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetFramebufferAttachmentParameteriv ( target uint32 , attachment uint32 , pname uint32 , params * int32 ) { C . glowGetFramebufferAttachmentParameteriv ( gpGetFramebufferAttachmentParameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetFramebufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { C . glowGetFramebufferParameteriv ( gpGetFramebufferParameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetInternalformativ ( target uint32 , internalformat uint32 , pname uint32 , bufSize int32 , params * int32 ) { C . glowGetInternalformativ ( gpGetInternalformativ , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( pname ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetMultisamplefv ( pname uint32 , index uint32 , val * float32 ) { C . glowGetMultisamplefv ( gpGetMultisamplefv , ( C . GLenum ) ( pname ) , ( C . GLuint ) ( index ) , ( * C . GLfloat ) ( unsafe . Pointer ( val ) ) ) } 
func GetNamedBufferParameteri64v ( buffer uint32 , pname uint32 , params * int64 ) { C . glowGetNamedBufferParameteri64v ( gpGetNamedBufferParameteri64v , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint64 ) ( unsafe . Pointer ( params ) ) ) } 
func GetNamedBufferParameteriv ( buffer uint32 , pname uint32 , params * int32 ) { C . glowGetNamedBufferParameteriv ( gpGetNamedBufferParameteriv , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetNamedBufferPointerv ( buffer uint32 , pname uint32 , params * unsafe . Pointer ) { C . glowGetNamedBufferPointerv ( gpGetNamedBufferPointerv , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , params ) } 
func GetNamedBufferSubData ( buffer uint32 , offset int , size int , data unsafe . Pointer ) { C . glowGetNamedBufferSubData ( gpGetNamedBufferSubData , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func GetNamedFramebufferAttachmentParameteriv ( framebuffer uint32 , attachment uint32 , pname uint32 , params * int32 ) { C . glowGetNamedFramebufferAttachmentParameteriv ( gpGetNamedFramebufferAttachmentParameteriv , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetNamedFramebufferParameteriv ( framebuffer uint32 , pname uint32 , param * int32 ) { C . glowGetNamedFramebufferParameteriv ( gpGetNamedFramebufferParameteriv , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func GetNamedRenderbufferParameteriv ( renderbuffer uint32 , pname uint32 , params * int32 ) { C . glowGetNamedRenderbufferParameteriv ( gpGetNamedRenderbufferParameteriv , ( C . GLuint ) ( renderbuffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetObjectLabel ( identifier uint32 , name uint32 , bufSize int32 , length * int32 , label * uint8 ) { C . glowGetObjectLabel ( gpGetObjectLabel , ( C . GLenum ) ( identifier ) , ( C . GLuint ) ( name ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func GetObjectPtrLabel ( ptr unsafe . Pointer , bufSize int32 , length * int32 , label * uint8 ) { C . glowGetObjectPtrLabel ( gpGetObjectPtrLabel , ptr , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func GetPointerv ( pname uint32 , params * unsafe . Pointer ) { C . glowGetPointerv ( gpGetPointerv , ( C . GLenum ) ( pname ) , params ) } 
func GetPolygonStipple ( mask * uint8 ) { C . glowGetPolygonStipple ( gpGetPolygonStipple , ( * C . GLubyte ) ( unsafe . Pointer ( mask ) ) ) } 
func GetProgramBinary ( program uint32 , bufSize int32 , length * int32 , binaryFormat * uint32 , binary unsafe . Pointer ) { C . glowGetProgramBinary ( gpGetProgramBinary , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLenum ) ( unsafe . Pointer ( binaryFormat ) ) , binary ) } 
func GetProgramInfoLog ( program uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { C . glowGetProgramInfoLog ( gpGetProgramInfoLog , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( infoLog ) ) ) } 
func GetProgramPipelineInfoLog ( pipeline uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { C . glowGetProgramPipelineInfoLog ( gpGetProgramPipelineInfoLog , ( C . GLuint ) ( pipeline ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( infoLog ) ) ) } 
func GetProgramResourceIndex ( program uint32 , programInterface uint32 , name * uint8 ) uint32 { ret := C . glowGetProgramResourceIndex ( gpGetProgramResourceIndex , ( C . GLuint ) ( program ) , ( C . GLenum ) ( programInterface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( uint32 ) ( ret ) } 
func GetProgramResourceLocation ( program uint32 , programInterface uint32 , name * uint8 ) int32 { ret := C . glowGetProgramResourceLocation ( gpGetProgramResourceLocation , ( C . GLuint ) ( program ) , ( C . GLenum ) ( programInterface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetProgramResourceLocationIndex ( program uint32 , programInterface uint32 , name * uint8 ) int32 { ret := C . glowGetProgramResourceLocationIndex ( gpGetProgramResourceLocationIndex , ( C . GLuint ) ( program ) , ( C . GLenum ) ( programInterface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetProgramResourceName ( program uint32 , programInterface uint32 , index uint32 , bufSize int32 , length * int32 , name * uint8 ) { C . glowGetProgramResourceName ( gpGetProgramResourceName , ( C . GLuint ) ( program ) , ( C . GLenum ) ( programInterface ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func GetProgramiv ( program uint32 , pname uint32 , params * int32 ) { C . glowGetProgramiv ( gpGetProgramiv , ( C . GLuint ) ( program ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetQueryIndexediv ( target uint32 , index uint32 , pname uint32 , params * int32 ) { C . glowGetQueryIndexediv ( gpGetQueryIndexediv , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetQueryObjectuiv ( id uint32 , pname uint32 , params * uint32 ) { C . glowGetQueryObjectuiv ( gpGetQueryObjectuiv , ( C . GLuint ) ( id ) , ( C . GLenum ) ( pname ) , ( * C . GLuint ) ( unsafe . Pointer ( params ) ) ) } 
func GetQueryiv ( target uint32 , pname uint32 , params * int32 ) { C . glowGetQueryiv ( gpGetQueryiv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetRenderbufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { C . glowGetRenderbufferParameteriv ( gpGetRenderbufferParameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetShaderInfoLog ( shader uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { C . glowGetShaderInfoLog ( gpGetShaderInfoLog , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( infoLog ) ) ) } 
func GetShaderPrecisionFormat ( shadertype uint32 , precisiontype uint32 , xrange * int32 , precision * int32 ) { C . glowGetShaderPrecisionFormat ( gpGetShaderPrecisionFormat , ( C . GLenum ) ( shadertype ) , ( C . GLenum ) ( precisiontype ) , ( * C . GLint ) ( unsafe . Pointer ( xrange ) ) , ( * C . GLint ) ( unsafe . Pointer ( precision ) ) ) } 
func GetShaderSource ( shader uint32 , bufSize int32 , length * int32 , source * uint8 ) { C . glowGetShaderSource ( gpGetShaderSource , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( source ) ) ) } 
func GetShaderiv ( shader uint32 , pname uint32 , params * int32 ) { C . glowGetShaderiv ( gpGetShaderiv , ( C . GLuint ) ( shader ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetString ( name uint32 ) * uint8 { ret := C . glowGetString ( gpGetString , ( C . GLenum ) ( name ) ) return ( * uint8 ) ( ret ) } 
func GetSubroutineIndex ( program uint32 , shadertype uint32 , name * uint8 ) uint32 { ret := C . glowGetSubroutineIndex ( gpGetSubroutineIndex , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( uint32 ) ( ret ) } 
func GetSubroutineUniformLocation ( program uint32 , shadertype uint32 , name * uint8 ) int32 { ret := C . glowGetSubroutineUniformLocation ( gpGetSubroutineUniformLocation , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetSynciv ( sync uintptr , pname uint32 , bufSize int32 , length * int32 , values * int32 ) { C . glowGetSynciv ( gpGetSynciv , ( C . GLsync ) ( sync ) , ( C . GLenum ) ( pname ) , ( C . GLsizei ) ( bufSize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( values ) ) ) } 
func GetTexImage ( target uint32 , level int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowGetTexImage ( gpGetTexImage , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func GetTextureImage ( texture uint32 , level int32 , format uint32 , xtype uint32 , bufSize int32 , pixels unsafe . Pointer ) { C . glowGetTextureImage ( gpGetTextureImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( bufSize ) , pixels ) } 
func GetTextureSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , bufSize int32 , pixels unsafe . Pointer ) { C . glowGetTextureSubImage ( gpGetTextureSubImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( bufSize ) , pixels ) } 
func GetTransformFeedbackiv ( xfb uint32 , pname uint32 , param * int32 ) { C . glowGetTransformFeedbackiv ( gpGetTransformFeedbackiv , ( C . GLuint ) ( xfb ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func GetUniformBlockIndex ( program uint32 , uniformBlockName * uint8 ) uint32 { ret := C . glowGetUniformBlockIndex ( gpGetUniformBlockIndex , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( uniformBlockName ) ) ) return ( uint32 ) ( ret ) } 
func GetUniformIndices ( program uint32 , uniformCount int32 , uniformNames * * uint8 , uniformIndices * uint32 ) { C . glowGetUniformIndices ( gpGetUniformIndices , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( uniformCount ) , ( * * C . GLchar ) ( unsafe . Pointer ( uniformNames ) ) , ( * C . GLuint ) ( unsafe . Pointer ( uniformIndices ) ) ) } 
func GetUniformLocation ( program uint32 , name * uint8 ) int32 { ret := C . glowGetUniformLocation ( gpGetUniformLocation , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetUniformfv ( program uint32 , location int32 , params * float32 ) { C . glowGetUniformfv ( gpGetUniformfv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( * C . GLfloat ) ( unsafe . Pointer ( params ) ) ) } 
func GetUniformiv ( program uint32 , location int32 , params * int32 ) { C . glowGetUniformiv ( gpGetUniformiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetVertexArrayiv ( vaobj uint32 , pname uint32 , param * int32 ) { C . glowGetVertexArrayiv ( gpGetVertexArrayiv , ( C . GLuint ) ( vaobj ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func GetVertexAttribLdv ( index uint32 , pname uint32 , params * float64 ) { C . glowGetVertexAttribLdv ( gpGetVertexAttribLdv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLdouble ) ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribPointerv ( index uint32 , pname uint32 , pointer * unsafe . Pointer ) { C . glowGetVertexAttribPointerv ( gpGetVertexAttribPointerv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , pointer ) } 
func GetVertexAttribdv ( index uint32 , pname uint32 , params * float64 ) { C . glowGetVertexAttribdv ( gpGetVertexAttribdv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLdouble ) ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribfv ( index uint32 , pname uint32 , params * float32 ) { C . glowGetVertexAttribfv ( gpGetVertexAttribfv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLfloat ) ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribiv ( index uint32 , pname uint32 , params * int32 ) { C . glowGetVertexAttribiv ( gpGetVertexAttribiv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func GetVkProcAddrNV ( name * uint8 ) unsafe . Pointer { ret := C . glowGetVkProcAddrNV ( gpGetVkProcAddrNV , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( unsafe . Pointer ) ( ret ) } 
func Hint ( target uint32 , mode uint32 ) { C . glowHint ( gpHint , ( C . GLenum ) ( target ) , ( C . GLenum ) ( mode ) ) } 
func IndexPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowIndexPointer ( gpIndexPointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func InterleavedArrays ( format uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowInterleavedArrays ( gpInterleavedArrays , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func InvalidateBufferSubData ( buffer uint32 , offset int , length int ) { C . glowInvalidateBufferSubData ( gpInvalidateBufferSubData , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func InvalidateFramebuffer ( target uint32 , numAttachments int32 , attachments * uint32 ) { C . glowInvalidateFramebuffer ( gpInvalidateFramebuffer , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( numAttachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) ) } 
func InvalidateNamedFramebufferData ( framebuffer uint32 , numAttachments int32 , attachments * uint32 ) { C . glowInvalidateNamedFramebufferData ( gpInvalidateNamedFramebufferData , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( numAttachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) ) } 
func InvalidateNamedFramebufferSubData ( framebuffer uint32 , numAttachments int32 , attachments * uint32 , x int32 , y int32 , width int32 , height int32 ) { C . glowInvalidateNamedFramebufferSubData ( gpInvalidateNamedFramebufferSubData , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( numAttachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func InvalidateSubFramebuffer ( target uint32 , numAttachments int32 , attachments * uint32 , x int32 , y int32 , width int32 , height int32 ) { C . glowInvalidateSubFramebuffer ( gpInvalidateSubFramebuffer , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( numAttachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func InvalidateTexImage ( texture uint32 , level int32 ) { C . glowInvalidateTexImage ( gpInvalidateTexImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) ) } 
func InvalidateTexSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 ) { C . glowInvalidateTexSubImage ( gpInvalidateTexSubImage , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func IsBuffer ( buffer uint32 ) bool { ret := C . glowIsBuffer ( gpIsBuffer , ( C . GLuint ) ( buffer ) ) return ret == TRUE } 
func IsFramebuffer ( framebuffer uint32 ) bool { ret := C . glowIsFramebuffer ( gpIsFramebuffer , ( C . GLuint ) ( framebuffer ) ) return ret == TRUE } 
func IsList ( list uint32 ) bool { ret := C . glowIsList ( gpIsList , ( C . GLuint ) ( list ) ) return ret == TRUE } 
func IsProgram ( program uint32 ) bool { ret := C . glowIsProgram ( gpIsProgram , ( C . GLuint ) ( program ) ) return ret == TRUE } 
func IsProgramPipeline ( pipeline uint32 ) bool { ret := C . glowIsProgramPipeline ( gpIsProgramPipeline , ( C . GLuint ) ( pipeline ) ) return ret == TRUE } 
func IsQuery ( id uint32 ) bool { ret := C . glowIsQuery ( gpIsQuery , ( C . GLuint ) ( id ) ) return ret == TRUE } 
func IsRenderbuffer ( renderbuffer uint32 ) bool { ret := C . glowIsRenderbuffer ( gpIsRenderbuffer , ( C . GLuint ) ( renderbuffer ) ) return ret == TRUE } 
func IsSampler ( sampler uint32 ) bool { ret := C . glowIsSampler ( gpIsSampler , ( C . GLuint ) ( sampler ) ) return ret == TRUE } 
func IsShader ( shader uint32 ) bool { ret := C . glowIsShader ( gpIsShader , ( C . GLuint ) ( shader ) ) return ret == TRUE } 
func IsSync ( sync uintptr ) bool { ret := C . glowIsSync ( gpIsSync , ( C . GLsync ) ( sync ) ) return ret == TRUE } 
func IsTexture ( texture uint32 ) bool { ret := C . glowIsTexture ( gpIsTexture , ( C . GLuint ) ( texture ) ) return ret == TRUE } 
func IsTransformFeedback ( id uint32 ) bool { ret := C . glowIsTransformFeedback ( gpIsTransformFeedback , ( C . GLuint ) ( id ) ) return ret == TRUE } 
func IsVertexArray ( array uint32 ) bool { ret := C . glowIsVertexArray ( gpIsVertexArray , ( C . GLuint ) ( array ) ) return ret == TRUE } 
func LineStipple ( factor int32 , pattern uint16 ) { C . glowLineStipple ( gpLineStipple , ( C . GLint ) ( factor ) , ( C . GLushort ) ( pattern ) ) } 
func MapBuffer ( target uint32 , access uint32 ) unsafe . Pointer { ret := C . glowMapBuffer ( gpMapBuffer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func MapBufferRange ( target uint32 , offset int , length int , access uint32 ) unsafe . Pointer { ret := C . glowMapBufferRange ( gpMapBufferRange , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) , ( C . GLbitfield ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func MapNamedBuffer ( buffer uint32 , access uint32 ) unsafe . Pointer { ret := C . glowMapNamedBuffer ( gpMapNamedBuffer , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func MapNamedBufferRange ( buffer uint32 , offset int , length int , access uint32 ) unsafe . Pointer { ret := C . glowMapNamedBufferRange ( gpMapNamedBufferRange , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) , ( C . GLbitfield ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func MultiDrawArrays ( mode uint32 , first * int32 , count * int32 , drawcount int32 ) { C . glowMultiDrawArrays ( gpMultiDrawArrays , ( C . GLenum ) ( mode ) , ( * C . GLint ) ( unsafe . Pointer ( first ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLsizei ) ( drawcount ) ) } 
func MultiDrawArraysIndirect ( mode uint32 , indirect unsafe . Pointer , drawcount int32 , stride int32 ) { C . glowMultiDrawArraysIndirect ( gpMultiDrawArraysIndirect , ( C . GLenum ) ( mode ) , indirect , ( C . GLsizei ) ( drawcount ) , ( C . GLsizei ) ( stride ) ) } 
func MultiDrawElements ( mode uint32 , count * int32 , xtype uint32 , indices * unsafe . Pointer , drawcount int32 ) { C . glowMultiDrawElements ( gpMultiDrawElements , ( C . GLenum ) ( mode ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( drawcount ) ) } 
func MultiDrawElementsBaseVertex ( mode uint32 , count * int32 , xtype uint32 , indices * unsafe . Pointer , drawcount int32 , basevertex * int32 ) { C . glowMultiDrawElementsBaseVertex ( gpMultiDrawElementsBaseVertex , ( C . GLenum ) ( mode ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( drawcount ) , ( * C . GLint ) ( unsafe . Pointer ( basevertex ) ) ) } 
func MultiDrawElementsIndirect ( mode uint32 , xtype uint32 , indirect unsafe . Pointer , drawcount int32 , stride int32 ) { C . glowMultiDrawElementsIndirect ( gpMultiDrawElementsIndirect , ( C . GLenum ) ( mode ) , ( C . GLenum ) ( xtype ) , indirect , ( C . GLsizei ) ( drawcount ) , ( C . GLsizei ) ( stride ) ) } 
func NamedBufferData ( buffer uint32 , size int , data unsafe . Pointer , usage uint32 ) { C . glowNamedBufferData ( gpNamedBufferData , ( C . GLuint ) ( buffer ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLenum ) ( usage ) ) } 
func NamedBufferStorage ( buffer uint32 , size int , data unsafe . Pointer , flags uint32 ) { C . glowNamedBufferStorage ( gpNamedBufferStorage , ( C . GLuint ) ( buffer ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLbitfield ) ( flags ) ) } 
func NamedBufferStorageExternalEXT ( buffer uint32 , offset int , size int , clientBuffer unsafe . Pointer , flags uint32 ) { C . glowNamedBufferStorageExternalEXT ( gpNamedBufferStorageExternalEXT , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLeglClientBufferEXT ) ( clientBuffer ) , ( C . GLbitfield ) ( flags ) ) } 
func NamedBufferSubData ( buffer uint32 , offset int , size int , data unsafe . Pointer ) { C . glowNamedBufferSubData ( gpNamedBufferSubData , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func NamedFramebufferDrawBuffer ( framebuffer uint32 , buf uint32 ) { C . glowNamedFramebufferDrawBuffer ( gpNamedFramebufferDrawBuffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( buf ) ) } 
func NamedFramebufferDrawBuffers ( framebuffer uint32 , n int32 , bufs * uint32 ) { C . glowNamedFramebufferDrawBuffers ( gpNamedFramebufferDrawBuffers , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( n ) , ( * C . GLenum ) ( unsafe . Pointer ( bufs ) ) ) } 
func NamedFramebufferParameteri ( framebuffer uint32 , pname uint32 , param int32 ) { C . glowNamedFramebufferParameteri ( gpNamedFramebufferParameteri , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func NamedFramebufferReadBuffer ( framebuffer uint32 , src uint32 ) { C . glowNamedFramebufferReadBuffer ( gpNamedFramebufferReadBuffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( src ) ) } 
func NamedFramebufferRenderbuffer ( framebuffer uint32 , attachment uint32 , renderbuffertarget uint32 , renderbuffer uint32 ) { C . glowNamedFramebufferRenderbuffer ( gpNamedFramebufferRenderbuffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( renderbuffertarget ) , ( C . GLuint ) ( renderbuffer ) ) } 
func NamedFramebufferTextureLayer ( framebuffer uint32 , attachment uint32 , texture uint32 , level int32 , layer int32 ) { C . glowNamedFramebufferTextureLayer ( gpNamedFramebufferTextureLayer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( layer ) ) } 
func NamedRenderbufferStorage ( renderbuffer uint32 , internalformat uint32 , width int32 , height int32 ) { C . glowNamedRenderbufferStorage ( gpNamedRenderbufferStorage , ( C . GLuint ) ( renderbuffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func NamedRenderbufferStorageMultisample ( renderbuffer uint32 , samples int32 , internalformat uint32 , width int32 , height int32 ) { C . glowNamedRenderbufferStorageMultisample ( gpNamedRenderbufferStorageMultisample , ( C . GLuint ) ( renderbuffer ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func NewList ( list uint32 , mode uint32 ) { C . glowNewList ( gpNewList , ( C . GLuint ) ( list ) , ( C . GLenum ) ( mode ) ) } 
func NormalPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowNormalPointer ( gpNormalPointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func ObjectLabel ( identifier uint32 , name uint32 , length int32 , label * uint8 ) { C . glowObjectLabel ( gpObjectLabel , ( C . GLenum ) ( identifier ) , ( C . GLuint ) ( name ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func ObjectPtrLabel ( ptr unsafe . Pointer , length int32 , label * uint8 ) { C . glowObjectPtrLabel ( gpObjectPtrLabel , ptr , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func Ortho ( left float64 , right float64 , bottom float64 , top float64 , zNear float64 , zFar float64 ) { C . glowOrtho ( gpOrtho , ( C . GLdouble ) ( left ) , ( C . GLdouble ) ( right ) , ( C . GLdouble ) ( bottom ) , ( C . GLdouble ) ( top ) , ( C . GLdouble ) ( zNear ) , ( C . GLdouble ) ( zFar ) ) } 
func PatchParameteri ( pname uint32 , value int32 ) { C . glowPatchParameteri ( gpPatchParameteri , ( C . GLenum ) ( pname ) , ( C . GLint ) ( value ) ) } 
func PixelStorei ( pname uint32 , param int32 ) { C . glowPixelStorei ( gpPixelStorei , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func PixelZoom ( xfactor float32 , yfactor float32 ) { C . glowPixelZoom ( gpPixelZoom , ( C . GLfloat ) ( xfactor ) , ( C . GLfloat ) ( yfactor ) ) } 
func PolygonMode ( face uint32 , mode uint32 ) { C . glowPolygonMode ( gpPolygonMode , ( C . GLenum ) ( face ) , ( C . GLenum ) ( mode ) ) } 
func PolygonOffset ( factor float32 , units float32 ) { C . glowPolygonOffset ( gpPolygonOffset , ( C . GLfloat ) ( factor ) , ( C . GLfloat ) ( units ) ) } 
func PolygonStipple ( mask * uint8 ) { C . glowPolygonStipple ( gpPolygonStipple , ( * C . GLubyte ) ( unsafe . Pointer ( mask ) ) ) } 
func PrioritizeTextures ( n int32 , textures * uint32 , priorities * float32 ) { C . glowPrioritizeTextures ( gpPrioritizeTextures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( priorities ) ) ) } 
func ProgramBinary ( program uint32 , binaryFormat uint32 , binary unsafe . Pointer , length int32 ) { C . glowProgramBinary ( gpProgramBinary , ( C . GLuint ) ( program ) , ( C . GLenum ) ( binaryFormat ) , binary , ( C . GLsizei ) ( length ) ) } 
func ProgramParameteri ( program uint32 , pname uint32 , value int32 ) { C . glowProgramParameteri ( gpProgramParameteri , ( C . GLuint ) ( program ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( value ) ) } 
func ProgramUniform1f ( program uint32 , location int32 , v0 float32 ) { C . glowProgramUniform1f ( gpProgramUniform1f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) ) } 
func ProgramUniform1fv ( program uint32 , location int32 , count int32 , value * float32 ) { C . glowProgramUniform1fv ( gpProgramUniform1fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform1i ( program uint32 , location int32 , v0 int32 ) { C . glowProgramUniform1i ( gpProgramUniform1i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) ) } 
func ProgramUniform1iv ( program uint32 , location int32 , count int32 , value * int32 ) { C . glowProgramUniform1iv ( gpProgramUniform1iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform1ui ( program uint32 , location int32 , v0 uint32 ) { C . glowProgramUniform1ui ( gpProgramUniform1ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v0 ) ) } 
func ProgramUniform1uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { C . glowProgramUniform1uiv ( gpProgramUniform1uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform2f ( program uint32 , location int32 , v0 float32 , v1 float32 ) { C . glowProgramUniform2f ( gpProgramUniform2f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) ) } 
func ProgramUniform2fv ( program uint32 , location int32 , count int32 , value * float32 ) { C . glowProgramUniform2fv ( gpProgramUniform2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform2i ( program uint32 , location int32 , v0 int32 , v1 int32 ) { C . glowProgramUniform2i ( gpProgramUniform2i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) ) } 
func ProgramUniform2iv ( program uint32 , location int32 , count int32 , value * int32 ) { C . glowProgramUniform2iv ( gpProgramUniform2iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform2ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 ) { C . glowProgramUniform2ui ( gpProgramUniform2ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v0 ) , ( C . GLuint ) ( v1 ) ) } 
func ProgramUniform2uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { C . glowProgramUniform2uiv ( gpProgramUniform2uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform3f ( program uint32 , location int32 , v0 float32 , v1 float32 , v2 float32 ) { C . glowProgramUniform3f ( gpProgramUniform3f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) , ( C . GLfloat ) ( v2 ) ) } 
func ProgramUniform3fv ( program uint32 , location int32 , count int32 , value * float32 ) { C . glowProgramUniform3fv ( gpProgramUniform3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform3i ( program uint32 , location int32 , v0 int32 , v1 int32 , v2 int32 ) { C . glowProgramUniform3i ( gpProgramUniform3i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) , ( C . GLint ) ( v2 ) ) } 
func ProgramUniform3iv ( program uint32 , location int32 , count int32 , value * int32 ) { C . glowProgramUniform3iv ( gpProgramUniform3iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform3ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 , v2 uint32 ) { C . glowProgramUniform3ui ( gpProgramUniform3ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v0 ) , ( C . GLuint ) ( v1 ) , ( C . GLuint ) ( v2 ) ) } 
func ProgramUniform3uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { C . glowProgramUniform3uiv ( gpProgramUniform3uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform4f ( program uint32 , location int32 , v0 float32 , v1 float32 , v2 float32 , v3 float32 ) { C . glowProgramUniform4f ( gpProgramUniform4f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) , ( C . GLfloat ) ( v2 ) , ( C . GLfloat ) ( v3 ) ) } 
func ProgramUniform4fv ( program uint32 , location int32 , count int32 , value * float32 ) { C . glowProgramUniform4fv ( gpProgramUniform4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform4i ( program uint32 , location int32 , v0 int32 , v1 int32 , v2 int32 , v3 int32 ) { C . glowProgramUniform4i ( gpProgramUniform4i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) , ( C . GLint ) ( v2 ) , ( C . GLint ) ( v3 ) ) } 
func ProgramUniform4iv ( program uint32 , location int32 , count int32 , value * int32 ) { C . glowProgramUniform4iv ( gpProgramUniform4iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniform4ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 , v2 uint32 , v3 uint32 ) { C . glowProgramUniform4ui ( gpProgramUniform4ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v0 ) , ( C . GLuint ) ( v1 ) , ( C . GLuint ) ( v2 ) , ( C . GLuint ) ( v3 ) ) } 
func ProgramUniform4uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { C . glowProgramUniform4uiv ( gpProgramUniform4uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix2fv ( gpProgramUniformMatrix2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix2x3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix2x3fv ( gpProgramUniformMatrix2x3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix2x4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix2x4fv ( gpProgramUniformMatrix2x4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix3fv ( gpProgramUniformMatrix3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix3x2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix3x2fv ( gpProgramUniformMatrix3x2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix3x4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix3x4fv ( gpProgramUniformMatrix3x4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix4fv ( gpProgramUniformMatrix4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix4x2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix4x2fv ( gpProgramUniformMatrix4x2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func ProgramUniformMatrix4x3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { C . glowProgramUniformMatrix4x3fv ( gpProgramUniformMatrix4x3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func PushDebugGroup ( source uint32 , id uint32 , length int32 , message * uint8 ) { C . glowPushDebugGroup ( gpPushDebugGroup , ( C . GLenum ) ( source ) , ( C . GLuint ) ( id ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( message ) ) ) } 
func QueryCounter ( id uint32 , target uint32 ) { C . glowQueryCounter ( gpQueryCounter , ( C . GLuint ) ( id ) , ( C . GLenum ) ( target ) ) } 
func QueryMatrixxOES ( mantissa * int32 , exponent * int32 ) uint32 { ret := C . glowQueryMatrixxOES ( gpQueryMatrixxOES , ( * C . GLfixed ) ( unsafe . Pointer ( mantissa ) ) , ( * C . GLint ) ( unsafe . Pointer ( exponent ) ) ) return ( uint32 ) ( ret ) } 
func ReadPixels ( x int32 , y int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowReadPixels ( gpReadPixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func ReadnPixels ( x int32 , y int32 , width int32 , height int32 , format uint32 , xtype uint32 , bufSize int32 , data unsafe . Pointer ) { C . glowReadnPixels ( gpReadnPixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( bufSize ) , data ) } 
func RenderMode ( mode uint32 ) int32 { ret := C . glowRenderMode ( gpRenderMode , ( C . GLenum ) ( mode ) ) return ( int32 ) ( ret ) } 
func RenderbufferStorage ( target uint32 , internalformat uint32 , width int32 , height int32 ) { C . glowRenderbufferStorage ( gpRenderbufferStorage , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func RenderbufferStorageMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 ) { C . glowRenderbufferStorageMultisample ( gpRenderbufferStorageMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func SampleCoverage ( value float32 , invert bool ) { C . glowSampleCoverage ( gpSampleCoverage , ( C . GLfloat ) ( value ) , ( C . GLboolean ) ( boolToInt ( invert ) ) ) } 
func SampleMaski ( maskNumber uint32 , mask uint32 ) { C . glowSampleMaski ( gpSampleMaski , ( C . GLuint ) ( maskNumber ) , ( C . GLbitfield ) ( mask ) ) } 
func Scissor ( x int32 , y int32 , width int32 , height int32 ) { C . glowScissor ( gpScissor , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func ScissorIndexed ( index uint32 , left int32 , bottom int32 , width int32 , height int32 ) { C . glowScissorIndexed ( gpScissorIndexed , ( C . GLuint ) ( index ) , ( C . GLint ) ( left ) , ( C . GLint ) ( bottom ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func SecondaryColorPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowSecondaryColorPointer ( gpSecondaryColorPointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func SelectBuffer ( size int32 , buffer * uint32 ) { C . glowSelectBuffer ( gpSelectBuffer , ( C . GLsizei ) ( size ) , ( * C . GLuint ) ( unsafe . Pointer ( buffer ) ) ) } 
func ShaderBinary ( count int32 , shaders * uint32 , binaryformat uint32 , binary unsafe . Pointer , length int32 ) { C . glowShaderBinary ( gpShaderBinary , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( shaders ) ) , ( C . GLenum ) ( binaryformat ) , binary , ( C . GLsizei ) ( length ) ) } 
func ShaderSource ( shader uint32 , count int32 , xstring * * uint8 , length * int32 ) { C . glowShaderSource ( gpShaderSource , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( count ) , ( * * C . GLchar ) ( unsafe . Pointer ( xstring ) ) , ( * C . GLint ) ( unsafe . Pointer ( length ) ) ) } 
func ShaderStorageBlockBinding ( program uint32 , storageBlockIndex uint32 , storageBlockBinding uint32 ) { C . glowShaderStorageBlockBinding ( gpShaderStorageBlockBinding , ( C . GLuint ) ( program ) , ( C . GLuint ) ( storageBlockIndex ) , ( C . GLuint ) ( storageBlockBinding ) ) } 
func StencilFunc ( xfunc uint32 , ref int32 , mask uint32 ) { C . glowStencilFunc ( gpStencilFunc , ( C . GLenum ) ( xfunc ) , ( C . GLint ) ( ref ) , ( C . GLuint ) ( mask ) ) } 
func StencilFuncSeparate ( face uint32 , xfunc uint32 , ref int32 , mask uint32 ) { C . glowStencilFuncSeparate ( gpStencilFuncSeparate , ( C . GLenum ) ( face ) , ( C . GLenum ) ( xfunc ) , ( C . GLint ) ( ref ) , ( C . GLuint ) ( mask ) ) } 
func StencilMaskSeparate ( face uint32 , mask uint32 ) { C . glowStencilMaskSeparate ( gpStencilMaskSeparate , ( C . GLenum ) ( face ) , ( C . GLuint ) ( mask ) ) } 
func StencilOp ( fail uint32 , zfail uint32 , zpass uint32 ) { C . glowStencilOp ( gpStencilOp , ( C . GLenum ) ( fail ) , ( C . GLenum ) ( zfail ) , ( C . GLenum ) ( zpass ) ) } 
func StencilOpSeparate ( face uint32 , sfail uint32 , dpfail uint32 , dppass uint32 ) { C . glowStencilOpSeparate ( gpStencilOpSeparate , ( C . GLenum ) ( face ) , ( C . GLenum ) ( sfail ) , ( C . GLenum ) ( dpfail ) , ( C . GLenum ) ( dppass ) ) } 
func TexBufferRange ( target uint32 , internalformat uint32 , buffer uint32 , offset int , size int ) { C . glowTexBufferRange ( gpTexBufferRange , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func TexCoordPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowTexCoordPointer ( gpTexCoordPointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func TexImage1D ( target uint32 , level int32 , internalformat int32 , width int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexImage1D ( gpTexImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TexImage2D ( target uint32 , level int32 , internalformat int32 , width int32 , height int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexImage2D ( gpTexImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TexImage2DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { C . glowTexImage2DMultisample ( gpTexImage2DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TexImage3D ( target uint32 , level int32 , internalformat int32 , width int32 , height int32 , depth int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexImage3D ( gpTexImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TexImage3DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { C . glowTexImage3DMultisample ( gpTexImage3DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TexStorage1D ( target uint32 , levels int32 , internalformat uint32 , width int32 ) { C . glowTexStorage1D ( gpTexStorage1D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) ) } 
func TexStorage2D ( target uint32 , levels int32 , internalformat uint32 , width int32 , height int32 ) { C . glowTexStorage2D ( gpTexStorage2D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func TexStorage2DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { C . glowTexStorage2DMultisample ( gpTexStorage2DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TexStorage3D ( target uint32 , levels int32 , internalformat uint32 , width int32 , height int32 , depth int32 ) { C . glowTexStorage3D ( gpTexStorage3D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func TexStorage3DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { C . glowTexStorage3DMultisample ( gpTexStorage3DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TexSubImage1D ( target uint32 , level int32 , xoffset int32 , width int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexSubImage1D ( gpTexSubImage1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TexSubImage2D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexSubImage2D ( gpTexSubImage2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTexSubImage3D ( gpTexSubImage3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TextureBuffer ( texture uint32 , internalformat uint32 , buffer uint32 ) { C . glowTextureBuffer ( gpTextureBuffer , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) ) } 
func TextureBufferRange ( texture uint32 , internalformat uint32 , buffer uint32 , offset int , size int ) { C . glowTextureBufferRange ( gpTextureBufferRange , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func TextureStorage1D ( texture uint32 , levels int32 , internalformat uint32 , width int32 ) { C . glowTextureStorage1D ( gpTextureStorage1D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) ) } 
func TextureStorage2D ( texture uint32 , levels int32 , internalformat uint32 , width int32 , height int32 ) { C . glowTextureStorage2D ( gpTextureStorage2D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func TextureStorage2DMultisample ( texture uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { C . glowTextureStorage2DMultisample ( gpTextureStorage2DMultisample , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TextureStorage3D ( texture uint32 , levels int32 , internalformat uint32 , width int32 , height int32 , depth int32 ) { C . glowTextureStorage3D ( gpTextureStorage3D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func TextureStorage3DMultisample ( texture uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { C . glowTextureStorage3DMultisample ( gpTextureStorage3DMultisample , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( boolToInt ( fixedsamplelocations ) ) ) } 
func TextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , width int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTextureSubImage1D ( gpTextureSubImage1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTextureSubImage2D ( gpTextureSubImage2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { C . glowTextureSubImage3D ( gpTextureSubImage3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func TextureView ( texture uint32 , target uint32 , origtexture uint32 , internalformat uint32 , minlevel uint32 , numlevels uint32 , minlayer uint32 , numlayers uint32 ) { C . glowTextureView ( gpTextureView , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( target ) , ( C . GLuint ) ( origtexture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( minlevel ) , ( C . GLuint ) ( numlevels ) , ( C . GLuint ) ( minlayer ) , ( C . GLuint ) ( numlayers ) ) } 
func TransformFeedbackBufferBase ( xfb uint32 , index uint32 , buffer uint32 ) { C . glowTransformFeedbackBufferBase ( gpTransformFeedbackBufferBase , ( C . GLuint ) ( xfb ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) ) } 
func TransformFeedbackBufferRange ( xfb uint32 , index uint32 , buffer uint32 , offset int , size int ) { C . glowTransformFeedbackBufferRange ( gpTransformFeedbackBufferRange , ( C . GLuint ) ( xfb ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Uniform1f ( location int32 , v0 float32 ) { C . glowUniform1f ( gpUniform1f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) ) } 
func Uniform1fv ( location int32 , count int32 , value * float32 ) { C . glowUniform1fv ( gpUniform1fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform1i ( location int32 , v0 int32 ) { C . glowUniform1i ( gpUniform1i , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) ) } 
func Uniform1iv ( location int32 , count int32 , value * int32 ) { C . glowUniform1iv ( gpUniform1iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform2f ( location int32 , v0 float32 , v1 float32 ) { C . glowUniform2f ( gpUniform2f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) ) } 
func Uniform2fv ( location int32 , count int32 , value * float32 ) { C . glowUniform2fv ( gpUniform2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform2i ( location int32 , v0 int32 , v1 int32 ) { C . glowUniform2i ( gpUniform2i , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) ) } 
func Uniform2iv ( location int32 , count int32 , value * int32 ) { C . glowUniform2iv ( gpUniform2iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform3f ( location int32 , v0 float32 , v1 float32 , v2 float32 ) { C . glowUniform3f ( gpUniform3f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) , ( C . GLfloat ) ( v2 ) ) } 
func Uniform3fv ( location int32 , count int32 , value * float32 ) { C . glowUniform3fv ( gpUniform3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform3i ( location int32 , v0 int32 , v1 int32 , v2 int32 ) { C . glowUniform3i ( gpUniform3i , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) , ( C . GLint ) ( v2 ) ) } 
func Uniform3iv ( location int32 , count int32 , value * int32 ) { C . glowUniform3iv ( gpUniform3iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform4f ( location int32 , v0 float32 , v1 float32 , v2 float32 , v3 float32 ) { C . glowUniform4f ( gpUniform4f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v0 ) , ( C . GLfloat ) ( v1 ) , ( C . GLfloat ) ( v2 ) , ( C . GLfloat ) ( v3 ) ) } 
func Uniform4fv ( location int32 , count int32 , value * float32 ) { C . glowUniform4fv ( gpUniform4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform4i ( location int32 , v0 int32 , v1 int32 , v2 int32 , v3 int32 ) { C . glowUniform4i ( gpUniform4i , ( C . GLint ) ( location ) , ( C . GLint ) ( v0 ) , ( C . GLint ) ( v1 ) , ( C . GLint ) ( v2 ) , ( C . GLint ) ( v3 ) ) } 
func Uniform4iv ( location int32 , count int32 , value * int32 ) { C . glowUniform4iv ( gpUniform4iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func UniformBlockBinding ( program uint32 , uniformBlockIndex uint32 , uniformBlockBinding uint32 ) { C . glowUniformBlockBinding ( gpUniformBlockBinding , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniformBlockIndex ) , ( C . GLuint ) ( uniformBlockBinding ) ) } 
func UniformMatrix2fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix2fv ( gpUniformMatrix2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix2x3fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix2x3fv ( gpUniformMatrix2x3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix2x4fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix2x4fv ( gpUniformMatrix2x4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix3fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix3fv ( gpUniformMatrix3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix3x2fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix3x2fv ( gpUniformMatrix3x2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix3x4fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix3x4fv ( gpUniformMatrix3x4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix4fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix4fv ( gpUniformMatrix4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix4x2fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix4x2fv ( gpUniformMatrix4x2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UniformMatrix4x3fv ( location int32 , count int32 , transpose bool , value * float32 ) { C . glowUniformMatrix4x3fv ( gpUniformMatrix4x3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( boolToInt ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func UnmapBuffer ( target uint32 ) bool { ret := C . glowUnmapBuffer ( gpUnmapBuffer , ( C . GLenum ) ( target ) ) return ret == TRUE } 
func UnmapNamedBuffer ( buffer uint32 ) bool { ret := C . glowUnmapNamedBuffer ( gpUnmapNamedBuffer , ( C . GLuint ) ( buffer ) ) return ret == TRUE } 
func UseProgramStages ( pipeline uint32 , stages uint32 , program uint32 ) { C . glowUseProgramStages ( gpUseProgramStages , ( C . GLuint ) ( pipeline ) , ( C . GLbitfield ) ( stages ) , ( C . GLuint ) ( program ) ) } 
func VertexArrayAttribFormat ( vaobj uint32 , attribindex uint32 , size int32 , xtype uint32 , normalized bool , relativeoffset uint32 ) { C . glowVertexArrayAttribFormat ( gpVertexArrayAttribFormat , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( attribindex ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( boolToInt ( normalized ) ) , ( C . GLuint ) ( relativeoffset ) ) } 
func VertexArrayBindingDivisor ( vaobj uint32 , bindingindex uint32 , divisor uint32 ) { C . glowVertexArrayBindingDivisor ( gpVertexArrayBindingDivisor , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( divisor ) ) } 
func VertexArrayElementBuffer ( vaobj uint32 , buffer uint32 ) { C . glowVertexArrayElementBuffer ( gpVertexArrayElementBuffer , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( buffer ) ) } 
func VertexArrayVertexBuffer ( vaobj uint32 , bindingindex uint32 , buffer uint32 , offset int , stride int32 ) { C . glowVertexArrayVertexBuffer ( gpVertexArrayVertexBuffer , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizei ) ( stride ) ) } 
func VertexArrayVertexBuffers ( vaobj uint32 , first uint32 , count int32 , buffers * uint32 , offsets * int , strides * int32 ) { C . glowVertexArrayVertexBuffers ( gpVertexArrayVertexBuffers , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( strides ) ) ) } 
func VertexAttribBinding ( attribindex uint32 , bindingindex uint32 ) { C . glowVertexAttribBinding ( gpVertexAttribBinding , ( C . GLuint ) ( attribindex ) , ( C . GLuint ) ( bindingindex ) ) } 
func VertexAttribFormat ( attribindex uint32 , size int32 , xtype uint32 , normalized bool , relativeoffset uint32 ) { C . glowVertexAttribFormat ( gpVertexAttribFormat , ( C . GLuint ) ( attribindex ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( boolToInt ( normalized ) ) , ( C . GLuint ) ( relativeoffset ) ) } 
func VertexAttribPointer ( index uint32 , size int32 , xtype uint32 , normalized bool , stride int32 , pointer unsafe . Pointer ) { C . glowVertexAttribPointer ( gpVertexAttribPointer , ( C . GLuint ) ( index ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( boolToInt ( normalized ) ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func VertexBindingDivisor ( bindingindex uint32 , divisor uint32 ) { C . glowVertexBindingDivisor ( gpVertexBindingDivisor , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( divisor ) ) } 
func VertexPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { C . glowVertexPointer ( gpVertexPointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Viewport ( x int32 , y int32 , width int32 , height int32 ) { C . glowViewport ( gpViewport , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func WaitSync ( sync uintptr , flags uint32 , timeout uint64 ) { C . glowWaitSync ( gpWaitSync , ( C . GLsync ) ( sync ) , ( C . GLbitfield ) ( flags ) , ( C . GLuint64 ) ( timeout ) ) } 
func ( i * Image ) QuadVertices ( sx0 , sy0 , sx1 , sy1 int , a , b , c , d , tx , ty float32 , cr , cg , cb , ca float32 ) [ ] float32 { if i . backend == nil { i . allocate ( true ) } ox , oy , _ , _ := i . region ( ) return i . backend . restorable . QuadVertices ( sx0 + ox , sy0 + oy , sx1 + ox , sy1 + oy , a , b , c , d , tx , ty , cr , cg , cb , ca ) } 
func ( i * Image ) PutVertex ( dest [ ] float32 , dx , dy , sx , sy float32 , bx0 , by0 , bx1 , by1 float32 , cr , cg , cb , ca float32 ) { if i . backend == nil { i . allocate ( true ) } ox , oy , _ , _ := i . region ( ) oxf , oyf := float32 ( ox ) , float32 ( oy ) i . backend . restorable . PutVertex ( dest , dx , dy , sx + oxf , sy + oyf , bx0 + oxf , by0 + oyf , bx1 + oxf , by1 + oyf , cr , cg , cb , ca ) } 
func ( i * Image ) Fill ( r , g , b , a uint8 ) { backendsM . Lock ( ) if i . disposed { panic ( " " ) } i . ensureNotShared ( ) i . backend . restorable . Fill ( r , g , b , a ) backendsM . Unlock ( ) } 
func scaleUpdater ( ) { for { s := getscale ( 0 , 0 ) atomic . StoreUint64 ( & cachedScale , math . Float64bits ( s ) ) time . Sleep ( cacheUpdateWait ) } } 
func Draw ( dst * ebiten . Image , text string , face font . Face , x , y int , clr color . Color ) { textM . Lock ( ) fx := fixed . I ( x ) prevR := rune ( - 1 ) runes := [ ] rune ( text ) glyphImgs := getGlyphImages ( face , runes ) colorm := colorToColorM ( clr ) for i , r := range runes { if prevR >= 0 { fx += face . Kern ( prevR , r ) } drawGlyph ( dst , face , r , glyphImgs [ i ] , fx , fixed . I ( y ) , colorm ) fx += glyphAdvance ( face , r ) prevR = r } textM . Unlock ( ) } 
func Run ( f func ( * Image ) error , width , height int , scale float64 , title string ) error { f = ( & imageDumper { f : f } ) . update c := newUIContext ( f ) theUIContext . Store ( c ) atomic . StoreInt32 ( & isRunning , 1 ) } if err := uiDriver ( ) . Run ( width , height , scale , title , c , graphicsDriver ( ) ) ; err != nil { if err == driver . RegularTermination { return nil } return err } return nil } 
func RunWithoutMainLoop ( f func ( * Image ) error , width , height int , scale float64 , title string ) <- chan error { f = ( & imageDumper { f : f } ) . update c := newUIContext ( f ) theUIContext . Store ( c ) atomic . StoreInt32 ( & isRunning , 1 ) return uiDriver ( ) . RunWithoutMainLoop ( width , height , scale , title , c , graphicsDriver ( ) ) } 
func SetScreenSize ( width , height int ) { if width <= 0 || height <= 0 { panic ( " " ) } uiDriver ( ) . SetScreenSize ( width , height ) } 
func SetMaxTPS ( tps int ) { if tps < 0 && tps != UncappedTPS { panic ( " " ) } atomic . StoreInt32 ( & currentMaxTPS , int32 ( tps ) ) } 
func NewBoard ( size int ) ( * Board , error ) { b := & Board { size : size , tiles : map [ * Tile ] struct { } { } , } for i := 0 ; i < 2 ; i ++ { if err := addRandomTile ( b . tiles , b . size ) ; err != nil { return nil , err } } return b , nil } 
func ( b * Board ) Update ( input * Input ) error { for t := range b . tiles { if err := t . Update ( ) ; err != nil { return err } } if 0 < len ( b . tasks ) { t := b . tasks [ 0 ] if err := t ( ) ; err == taskTerminated { b . tasks = b . tasks [ 1 : ] } else if err != nil { return err } return nil } if dir , ok := input . Dir ( ) ; ok { if err := b . Move ( dir ) ; err != nil { return err } } return nil } 
func ( b * Board ) Move ( dir Dir ) error { for t := range b . tiles { t . stopAnimation ( ) } if ! MoveTiles ( b . tiles , b . size , dir ) { return nil } b . tasks = append ( b . tasks , func ( ) error { for t := range b . tiles { if t . IsMoving ( ) { return nil } } return taskTerminated } ) b . tasks = append ( b . tasks , func ( ) error { nextTiles := map [ * Tile ] struct { } { } for t := range b . tiles { if t . IsMoving ( ) { panic ( " " ) } if t . next . value != 0 { panic ( " " ) } if t . current . value == 0 { continue } nextTiles [ t ] = struct { } { } } b . tiles = nextTiles if err := addRandomTile ( b . tiles , b . size ) ; err != nil { return err } return taskTerminated } ) return nil } 
func ( b * Board ) Size ( ) ( int , int ) { x := b . size * tileSize + ( b . size + 1 ) * tileMargin y := x return x , y } 
func ( b * Board ) Draw ( boardImage * ebiten . Image ) { boardImage . Fill ( frameColor ) for j := 0 ; j < b . size ; j ++ { for i := 0 ; i < b . size ; i ++ { v := 0 op := & ebiten . DrawImageOptions { } x := i * tileSize + ( i + 1 ) * tileMargin y := j * tileSize + ( j + 1 ) * tileMargin op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) r , g , b , a := colorToScale ( tileBackgroundColor ( v ) ) op . ColorM . Scale ( r , g , b , a ) boardImage . DrawImage ( tileImage , op ) } } animatingTiles := map [ * Tile ] struct { } { } nonAnimatingTiles := map [ * Tile ] struct { } { } for t := range b . tiles { if t . IsMoving ( ) { animatingTiles [ t ] = struct { } { } } else { nonAnimatingTiles [ t ] = struct { } { } } } for t := range nonAnimatingTiles { t . Draw ( boardImage ) } for t := range animatingTiles { t . Draw ( boardImage ) } } 
func Accum ( op uint32 , value float32 ) { syscall . Syscall ( gpAccum , 2 , uintptr ( op ) , uintptr ( math . Float32bits ( value ) ) , 0 ) } 
func ActiveShaderProgram ( pipeline uint32 , program uint32 ) { syscall . Syscall ( gpActiveShaderProgram , 2 , uintptr ( pipeline ) , uintptr ( program ) , 0 ) } 
func AlphaFunc ( xfunc uint32 , ref float32 ) { syscall . Syscall ( gpAlphaFunc , 2 , uintptr ( xfunc ) , uintptr ( math . Float32bits ( ref ) ) , 0 ) } 
func AreTexturesResident ( n int32 , textures * uint32 , residences * bool ) bool { ret , _ , _ := syscall . Syscall ( gpAreTexturesResident , 3 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , uintptr ( unsafe . Pointer ( residences ) ) ) return ret != 0 } 
func AttachShader ( program uint32 , shader uint32 ) { syscall . Syscall ( gpAttachShader , 2 , uintptr ( program ) , uintptr ( shader ) , 0 ) } 
func BeginQuery ( target uint32 , id uint32 ) { syscall . Syscall ( gpBeginQuery , 2 , uintptr ( target ) , uintptr ( id ) , 0 ) } 
func BindAttribLocation ( program uint32 , index uint32 , name * uint8 ) { syscall . Syscall ( gpBindAttribLocation , 3 , uintptr ( program ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func BindBuffer ( target uint32 , buffer uint32 ) { syscall . Syscall ( gpBindBuffer , 2 , uintptr ( target ) , uintptr ( buffer ) , 0 ) } 
func BindBufferBase ( target uint32 , index uint32 , buffer uint32 ) { syscall . Syscall ( gpBindBufferBase , 3 , uintptr ( target ) , uintptr ( index ) , uintptr ( buffer ) ) } 
func BindBufferRange ( target uint32 , index uint32 , buffer uint32 , offset int , size int ) { syscall . Syscall6 ( gpBindBufferRange , 5 , uintptr ( target ) , uintptr ( index ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func BindBuffersBase ( target uint32 , first uint32 , count int32 , buffers * uint32 ) { syscall . Syscall6 ( gpBindBuffersBase , 4 , uintptr ( target ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 , 0 ) } 
func BindBuffersRange ( target uint32 , first uint32 , count int32 , buffers * uint32 , offsets * int , sizes * int ) { syscall . Syscall6 ( gpBindBuffersRange , 6 , uintptr ( target ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( sizes ) ) ) } 
func BindFragDataLocationIndexed ( program uint32 , colorNumber uint32 , index uint32 , name * uint8 ) { syscall . Syscall6 ( gpBindFragDataLocationIndexed , 4 , uintptr ( program ) , uintptr ( colorNumber ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func BindFramebuffer ( target uint32 , framebuffer uint32 ) { syscall . Syscall ( gpBindFramebuffer , 2 , uintptr ( target ) , uintptr ( framebuffer ) , 0 ) } 
func BindImageTexture ( unit uint32 , texture uint32 , level int32 , layered bool , layer int32 , access uint32 , format uint32 ) { syscall . Syscall9 ( gpBindImageTexture , 7 , uintptr ( unit ) , uintptr ( texture ) , uintptr ( level ) , boolToUintptr ( layered ) , uintptr ( layer ) , uintptr ( access ) , uintptr ( format ) , 0 , 0 ) } 
func BindImageTextures ( first uint32 , count int32 , textures * uint32 ) { syscall . Syscall ( gpBindImageTextures , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func BindRenderbuffer ( target uint32 , renderbuffer uint32 ) { syscall . Syscall ( gpBindRenderbuffer , 2 , uintptr ( target ) , uintptr ( renderbuffer ) , 0 ) } 
func BindSampler ( unit uint32 , sampler uint32 ) { syscall . Syscall ( gpBindSampler , 2 , uintptr ( unit ) , uintptr ( sampler ) , 0 ) } 
func BindSamplers ( first uint32 , count int32 , samplers * uint32 ) { syscall . Syscall ( gpBindSamplers , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) ) } 
func BindTexture ( target uint32 , texture uint32 ) { syscall . Syscall ( gpBindTexture , 2 , uintptr ( target ) , uintptr ( texture ) , 0 ) } 
func BindTextureUnit ( unit uint32 , texture uint32 ) { syscall . Syscall ( gpBindTextureUnit , 2 , uintptr ( unit ) , uintptr ( texture ) , 0 ) } 
func BindTextures ( first uint32 , count int32 , textures * uint32 ) { syscall . Syscall ( gpBindTextures , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func BindTransformFeedback ( target uint32 , id uint32 ) { syscall . Syscall ( gpBindTransformFeedback , 2 , uintptr ( target ) , uintptr ( id ) , 0 ) } 
func BindVertexBuffer ( bindingindex uint32 , buffer uint32 , offset int , stride int32 ) { syscall . Syscall6 ( gpBindVertexBuffer , 4 , uintptr ( bindingindex ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( stride ) , 0 , 0 ) } 
func BindVertexBuffers ( first uint32 , count int32 , buffers * uint32 , offsets * int , strides * int32 ) { syscall . Syscall6 ( gpBindVertexBuffers , 5 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( strides ) ) , 0 ) } 
func Bitmap ( width int32 , height int32 , xorig float32 , yorig float32 , xmove float32 , ymove float32 , bitmap * uint8 ) { syscall . Syscall9 ( gpBitmap , 7 , uintptr ( width ) , uintptr ( height ) , uintptr ( math . Float32bits ( xorig ) ) , uintptr ( math . Float32bits ( yorig ) ) , uintptr ( math . Float32bits ( xmove ) ) , uintptr ( math . Float32bits ( ymove ) ) , uintptr ( unsafe . Pointer ( bitmap ) ) , 0 , 0 ) } 
func BlendColor ( red float32 , green float32 , blue float32 , alpha float32 ) { syscall . Syscall6 ( gpBlendColor , 4 , uintptr ( math . Float32bits ( red ) ) , uintptr ( math . Float32bits ( green ) ) , uintptr ( math . Float32bits ( blue ) ) , uintptr ( math . Float32bits ( alpha ) ) , 0 , 0 ) } 
func BlendEquationSeparate ( modeRGB uint32 , modeAlpha uint32 ) { syscall . Syscall ( gpBlendEquationSeparate , 2 , uintptr ( modeRGB ) , uintptr ( modeAlpha ) , 0 ) } 
func BlendFunc ( sfactor uint32 , dfactor uint32 ) { syscall . Syscall ( gpBlendFunc , 2 , uintptr ( sfactor ) , uintptr ( dfactor ) , 0 ) } 
func BlendFuncSeparate ( sfactorRGB uint32 , dfactorRGB uint32 , sfactorAlpha uint32 , dfactorAlpha uint32 ) { syscall . Syscall6 ( gpBlendFuncSeparate , 4 , uintptr ( sfactorRGB ) , uintptr ( dfactorRGB ) , uintptr ( sfactorAlpha ) , uintptr ( dfactorAlpha ) , 0 , 0 ) } 
func BlitFramebuffer ( srcX0 int32 , srcY0 int32 , srcX1 int32 , srcY1 int32 , dstX0 int32 , dstY0 int32 , dstX1 int32 , dstY1 int32 , mask uint32 , filter uint32 ) { syscall . Syscall12 ( gpBlitFramebuffer , 10 , uintptr ( srcX0 ) , uintptr ( srcY0 ) , uintptr ( srcX1 ) , uintptr ( srcY1 ) , uintptr ( dstX0 ) , uintptr ( dstY0 ) , uintptr ( dstX1 ) , uintptr ( dstY1 ) , uintptr ( mask ) , uintptr ( filter ) , 0 , 0 ) } 
func BlitNamedFramebuffer ( readFramebuffer uint32 , drawFramebuffer uint32 , srcX0 int32 , srcY0 int32 , srcX1 int32 , srcY1 int32 , dstX0 int32 , dstY0 int32 , dstX1 int32 , dstY1 int32 , mask uint32 , filter uint32 ) { syscall . Syscall12 ( gpBlitNamedFramebuffer , 12 , uintptr ( readFramebuffer ) , uintptr ( drawFramebuffer ) , uintptr ( srcX0 ) , uintptr ( srcY0 ) , uintptr ( srcX1 ) , uintptr ( srcY1 ) , uintptr ( dstX0 ) , uintptr ( dstY0 ) , uintptr ( dstX1 ) , uintptr ( dstY1 ) , uintptr ( mask ) , uintptr ( filter ) ) } 
func BufferData ( target uint32 , size int , data unsafe . Pointer , usage uint32 ) { syscall . Syscall6 ( gpBufferData , 4 , uintptr ( target ) , uintptr ( size ) , uintptr ( data ) , uintptr ( usage ) , 0 , 0 ) } 
func BufferStorage ( target uint32 , size int , data unsafe . Pointer , flags uint32 ) { syscall . Syscall6 ( gpBufferStorage , 4 , uintptr ( target ) , uintptr ( size ) , uintptr ( data ) , uintptr ( flags ) , 0 , 0 ) } 
func BufferStorageExternalEXT ( target uint32 , offset int , size int , clientBuffer unsafe . Pointer , flags uint32 ) { syscall . Syscall6 ( gpBufferStorageExternalEXT , 5 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( clientBuffer ) , uintptr ( flags ) , 0 ) } 
func BufferSubData ( target uint32 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall6 ( gpBufferSubData , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func CallLists ( n int32 , xtype uint32 , lists unsafe . Pointer ) { syscall . Syscall ( gpCallLists , 3 , uintptr ( n ) , uintptr ( xtype ) , uintptr ( lists ) ) } 
func CheckFramebufferStatus ( target uint32 ) uint32 { ret , _ , _ := syscall . Syscall ( gpCheckFramebufferStatus , 1 , uintptr ( target ) , 0 , 0 ) return ( uint32 ) ( ret ) } 
func CheckNamedFramebufferStatus ( framebuffer uint32 , target uint32 ) uint32 { ret , _ , _ := syscall . Syscall ( gpCheckNamedFramebufferStatus , 2 , uintptr ( framebuffer ) , uintptr ( target ) , 0 ) return ( uint32 ) ( ret ) } 
func ClearAccum ( red float32 , green float32 , blue float32 , alpha float32 ) { syscall . Syscall6 ( gpClearAccum , 4 , uintptr ( math . Float32bits ( red ) ) , uintptr ( math . Float32bits ( green ) ) , uintptr ( math . Float32bits ( blue ) ) , uintptr ( math . Float32bits ( alpha ) ) , 0 , 0 ) } 
func ClearBufferData ( target uint32 , internalformat uint32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall6 ( gpClearBufferData , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func ClearBufferSubData ( target uint32 , internalformat uint32 , offset int , size int , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpClearBufferSubData , 7 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 , 0 ) } 
func ClearColor ( red float32 , green float32 , blue float32 , alpha float32 ) { syscall . Syscall6 ( gpClearColor , 4 , uintptr ( math . Float32bits ( red ) ) , uintptr ( math . Float32bits ( green ) ) , uintptr ( math . Float32bits ( blue ) ) , uintptr ( math . Float32bits ( alpha ) ) , 0 , 0 ) } 
func ClearDepth ( depth float64 ) { syscall . Syscall ( gpClearDepth , 1 , uintptr ( math . Float64bits ( depth ) ) , 0 , 0 ) } 
func ClearDepthf ( d float32 ) { syscall . Syscall ( gpClearDepthf , 1 , uintptr ( math . Float32bits ( d ) ) , 0 , 0 ) } 
func ClearIndex ( c float32 ) { syscall . Syscall ( gpClearIndex , 1 , uintptr ( math . Float32bits ( c ) ) , 0 , 0 ) } 
func ClearNamedBufferData ( buffer uint32 , internalformat uint32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall6 ( gpClearNamedBufferData , 5 , uintptr ( buffer ) , uintptr ( internalformat ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func ClearNamedBufferSubData ( buffer uint32 , internalformat uint32 , offset int , size int , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpClearNamedBufferSubData , 7 , uintptr ( buffer ) , uintptr ( internalformat ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 , 0 ) } 
func ClearTexImage ( texture uint32 , level int32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall6 ( gpClearTexImage , 5 , uintptr ( texture ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func ClearTexSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , data unsafe . Pointer ) { syscall . Syscall12 ( gpClearTexSubImage , 11 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func ClientWaitSync ( sync uintptr , flags uint32 , timeout uint64 ) uint32 { ret , _ , _ := syscall . Syscall ( gpClientWaitSync , 3 , uintptr ( sync ) , uintptr ( flags ) , uintptr ( timeout ) ) return ( uint32 ) ( ret ) } 
func ClipControl ( origin uint32 , depth uint32 ) { syscall . Syscall ( gpClipControl , 2 , uintptr ( origin ) , uintptr ( depth ) , 0 ) } 
func ClipPlane ( plane uint32 , equation * float64 ) { syscall . Syscall ( gpClipPlane , 2 , uintptr ( plane ) , uintptr ( unsafe . Pointer ( equation ) ) , 0 ) } 
func ColorMaterial ( face uint32 , mode uint32 ) { syscall . Syscall ( gpColorMaterial , 2 , uintptr ( face ) , uintptr ( mode ) , 0 ) } 
func ColorPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall6 ( gpColorPointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func CompressedTexImage1D ( target uint32 , level int32 , internalformat uint32 , width int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTexImage1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( border ) , uintptr ( imageSize ) , uintptr ( data ) , 0 , 0 ) } 
func CompressedTexImage2D ( target uint32 , level int32 , internalformat uint32 , width int32 , height int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTexImage2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , uintptr ( imageSize ) , uintptr ( data ) , 0 ) } 
func CompressedTexImage3D ( target uint32 , level int32 , internalformat uint32 , width int32 , height int32 , depth int32 , border int32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTexImage3D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( border ) , uintptr ( imageSize ) , uintptr ( data ) ) } 
func CompressedTexSubImage1D ( target uint32 , level int32 , xoffset int32 , width int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTexSubImage1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( imageSize ) , uintptr ( data ) , 0 , 0 ) } 
func CompressedTexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall12 ( gpCompressedTexSubImage3D , 11 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( imageSize ) , uintptr ( data ) , 0 ) } 
func CompressedTextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , width int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTextureSubImage1D , 7 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( imageSize ) , uintptr ( data ) , 0 , 0 ) } 
func CompressedTextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpCompressedTextureSubImage2D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( imageSize ) , uintptr ( data ) ) } 
func CompressedTextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , imageSize int32 , data unsafe . Pointer ) { syscall . Syscall12 ( gpCompressedTextureSubImage3D , 11 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( imageSize ) , uintptr ( data ) , 0 ) } 
func CopyBufferSubData ( readTarget uint32 , writeTarget uint32 , readOffset int , writeOffset int , size int ) { syscall . Syscall6 ( gpCopyBufferSubData , 5 , uintptr ( readTarget ) , uintptr ( writeTarget ) , uintptr ( readOffset ) , uintptr ( writeOffset ) , uintptr ( size ) , 0 ) } 
func CopyImageSubData ( srcName uint32 , srcTarget uint32 , srcLevel int32 , srcX int32 , srcY int32 , srcZ int32 , dstName uint32 , dstTarget uint32 , dstLevel int32 , dstX int32 , dstY int32 , dstZ int32 , srcWidth int32 , srcHeight int32 , srcDepth int32 ) { syscall . Syscall15 ( gpCopyImageSubData , 15 , uintptr ( srcName ) , uintptr ( srcTarget ) , uintptr ( srcLevel ) , uintptr ( srcX ) , uintptr ( srcY ) , uintptr ( srcZ ) , uintptr ( dstName ) , uintptr ( dstTarget ) , uintptr ( dstLevel ) , uintptr ( dstX ) , uintptr ( dstY ) , uintptr ( dstZ ) , uintptr ( srcWidth ) , uintptr ( srcHeight ) , uintptr ( srcDepth ) ) } 
func CopyNamedBufferSubData ( readBuffer uint32 , writeBuffer uint32 , readOffset int , writeOffset int , size int ) { syscall . Syscall6 ( gpCopyNamedBufferSubData , 5 , uintptr ( readBuffer ) , uintptr ( writeBuffer ) , uintptr ( readOffset ) , uintptr ( writeOffset ) , uintptr ( size ) , 0 ) } 
func CopyPixels ( x int32 , y int32 , width int32 , height int32 , xtype uint32 ) { syscall . Syscall6 ( gpCopyPixels , 5 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( xtype ) , 0 ) } 
func CopyTexImage1D ( target uint32 , level int32 , internalformat uint32 , x int32 , y int32 , width int32 , border int32 ) { syscall . Syscall9 ( gpCopyTexImage1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( border ) , 0 , 0 ) } 
func CopyTexImage2D ( target uint32 , level int32 , internalformat uint32 , x int32 , y int32 , width int32 , height int32 , border int32 ) { syscall . Syscall9 ( gpCopyTexImage2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , 0 ) } 
func CopyTexSubImage1D ( target uint32 , level int32 , xoffset int32 , x int32 , y int32 , width int32 ) { syscall . Syscall6 ( gpCopyTexSubImage1D , 6 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) ) } 
func CopyTexSubImage2D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpCopyTexSubImage2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func CopyTexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpCopyTexSubImage3D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) ) } 
func CopyTextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , x int32 , y int32 , width int32 ) { syscall . Syscall6 ( gpCopyTextureSubImage1D , 6 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) ) } 
func CopyTextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpCopyTextureSubImage2D , 8 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func CopyTextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpCopyTextureSubImage3D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) ) } 
func CreateBuffers ( n int32 , buffers * uint32 ) { syscall . Syscall ( gpCreateBuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func CreateFramebuffers ( n int32 , framebuffers * uint32 ) { syscall . Syscall ( gpCreateFramebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func CreateProgram ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpCreateProgram , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) } 
func CreateProgramPipelines ( n int32 , pipelines * uint32 ) { syscall . Syscall ( gpCreateProgramPipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func CreateQueries ( target uint32 , n int32 , ids * uint32 ) { syscall . Syscall ( gpCreateQueries , 3 , uintptr ( target ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) ) } 
func CreateRenderbuffers ( n int32 , renderbuffers * uint32 ) { syscall . Syscall ( gpCreateRenderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func CreateSamplers ( n int32 , samplers * uint32 ) { syscall . Syscall ( gpCreateSamplers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func CreateShader ( xtype uint32 ) uint32 { ret , _ , _ := syscall . Syscall ( gpCreateShader , 1 , uintptr ( xtype ) , 0 , 0 ) return ( uint32 ) ( ret ) } 
func CreateShaderProgramv ( xtype uint32 , count int32 , strings * * uint8 ) uint32 { ret , _ , _ := syscall . Syscall ( gpCreateShaderProgramv , 3 , uintptr ( xtype ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( strings ) ) ) return ( uint32 ) ( ret ) } 
func CreateSyncFromCLeventARB ( context unsafe . Pointer , event unsafe . Pointer , flags uint32 ) uintptr { ret , _ , _ := syscall . Syscall ( gpCreateSyncFromCLeventARB , 3 , uintptr ( context ) , uintptr ( event ) , uintptr ( flags ) ) return ( uintptr ) ( ret ) } 
func CreateTextures ( target uint32 , n int32 , textures * uint32 ) { syscall . Syscall ( gpCreateTextures , 3 , uintptr ( target ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func CreateTransformFeedbacks ( n int32 , ids * uint32 ) { syscall . Syscall ( gpCreateTransformFeedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func CreateVertexArrays ( n int32 , arrays * uint32 ) { syscall . Syscall ( gpCreateVertexArrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func DebugMessageCallback ( callback unsafe . Pointer , userParam unsafe . Pointer ) { syscall . Syscall ( gpDebugMessageCallback , 2 , syscall . NewCallback ( callback ) , uintptr ( userParam ) , 0 ) } 
func DebugMessageCallbackAMD ( callback unsafe . Pointer , userParam unsafe . Pointer ) { syscall . Syscall ( gpDebugMessageCallbackAMD , 2 , uintptr ( callback ) , uintptr ( userParam ) , 0 ) } 
func DebugMessageCallbackARB ( callback unsafe . Pointer , userParam unsafe . Pointer ) { syscall . Syscall ( gpDebugMessageCallbackARB , 2 , syscall . NewCallback ( callback ) , uintptr ( userParam ) , 0 ) } 
func DebugMessageCallbackKHR ( callback unsafe . Pointer , userParam unsafe . Pointer ) { syscall . Syscall ( gpDebugMessageCallbackKHR , 2 , syscall . NewCallback ( callback ) , uintptr ( userParam ) , 0 ) } 
func DebugMessageControl ( source uint32 , xtype uint32 , severity uint32 , count int32 , ids * uint32 , enabled bool ) { syscall . Syscall6 ( gpDebugMessageControl , 6 , uintptr ( source ) , uintptr ( xtype ) , uintptr ( severity ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( ids ) ) , boolToUintptr ( enabled ) ) } 
func DebugMessageInsert ( source uint32 , xtype uint32 , id uint32 , severity uint32 , length int32 , buf * uint8 ) { syscall . Syscall6 ( gpDebugMessageInsert , 6 , uintptr ( source ) , uintptr ( xtype ) , uintptr ( id ) , uintptr ( severity ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( buf ) ) ) } 
func DeleteBuffers ( n int32 , buffers * uint32 ) { syscall . Syscall ( gpDeleteBuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func DeleteFramebuffers ( n int32 , framebuffers * uint32 ) { syscall . Syscall ( gpDeleteFramebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func DeleteLists ( list uint32 , xrange int32 ) { syscall . Syscall ( gpDeleteLists , 2 , uintptr ( list ) , uintptr ( xrange ) , 0 ) } 
func DeleteProgramPipelines ( n int32 , pipelines * uint32 ) { syscall . Syscall ( gpDeleteProgramPipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func DeleteQueries ( n int32 , ids * uint32 ) { syscall . Syscall ( gpDeleteQueries , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func DeleteRenderbuffers ( n int32 , renderbuffers * uint32 ) { syscall . Syscall ( gpDeleteRenderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func DeleteSamplers ( count int32 , samplers * uint32 ) { syscall . Syscall ( gpDeleteSamplers , 2 , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func DeleteTextures ( n int32 , textures * uint32 ) { syscall . Syscall ( gpDeleteTextures , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , 0 ) } 
func DeleteTransformFeedbacks ( n int32 , ids * uint32 ) { syscall . Syscall ( gpDeleteTransformFeedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func DeleteVertexArrays ( n int32 , arrays * uint32 ) { syscall . Syscall ( gpDeleteVertexArrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func DepthRange ( n float64 , f float64 ) { syscall . Syscall ( gpDepthRange , 2 , uintptr ( math . Float64bits ( n ) ) , uintptr ( math . Float64bits ( f ) ) , 0 ) } 
func DepthRangeIndexed ( index uint32 , n float64 , f float64 ) { syscall . Syscall ( gpDepthRangeIndexed , 3 , uintptr ( index ) , uintptr ( math . Float64bits ( n ) ) , uintptr ( math . Float64bits ( f ) ) ) } 
func DepthRangef ( n float32 , f float32 ) { syscall . Syscall ( gpDepthRangef , 2 , uintptr ( math . Float32bits ( n ) ) , uintptr ( math . Float32bits ( f ) ) , 0 ) } 
func DetachShader ( program uint32 , shader uint32 ) { syscall . Syscall ( gpDetachShader , 2 , uintptr ( program ) , uintptr ( shader ) , 0 ) } 
func DisableVertexArrayAttrib ( vaobj uint32 , index uint32 ) { syscall . Syscall ( gpDisableVertexArrayAttrib , 2 , uintptr ( vaobj ) , uintptr ( index ) , 0 ) } 
func DispatchCompute ( num_groups_x uint32 , num_groups_y uint32 , num_groups_z uint32 ) { syscall . Syscall ( gpDispatchCompute , 3 , uintptr ( num_groups_x ) , uintptr ( num_groups_y ) , uintptr ( num_groups_z ) ) } 
func DrawArrays ( mode uint32 , first int32 , count int32 ) { syscall . Syscall ( gpDrawArrays , 3 , uintptr ( mode ) , uintptr ( first ) , uintptr ( count ) ) } 
func DrawArraysIndirect ( mode uint32 , indirect unsafe . Pointer ) { syscall . Syscall ( gpDrawArraysIndirect , 2 , uintptr ( mode ) , uintptr ( indirect ) , 0 ) } 
func DrawArraysInstancedBaseInstance ( mode uint32 , first int32 , count int32 , instancecount int32 , baseinstance uint32 ) { syscall . Syscall6 ( gpDrawArraysInstancedBaseInstance , 5 , uintptr ( mode ) , uintptr ( first ) , uintptr ( count ) , uintptr ( instancecount ) , uintptr ( baseinstance ) , 0 ) } 
func DrawBuffers ( n int32 , bufs * uint32 ) { syscall . Syscall ( gpDrawBuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( bufs ) ) , 0 ) } 
func DrawElements ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer ) { syscall . Syscall6 ( gpDrawElements , 4 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , 0 , 0 ) } 
func DrawElementsBaseVertex ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , basevertex int32 ) { syscall . Syscall6 ( gpDrawElementsBaseVertex , 5 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( basevertex ) , 0 ) } 
func DrawElementsIndirect ( mode uint32 , xtype uint32 , indirect unsafe . Pointer ) { syscall . Syscall ( gpDrawElementsIndirect , 3 , uintptr ( mode ) , uintptr ( xtype ) , uintptr ( indirect ) ) } 
func DrawElementsInstancedBaseInstance ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , baseinstance uint32 ) { syscall . Syscall6 ( gpDrawElementsInstancedBaseInstance , 6 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( baseinstance ) ) } 
func DrawElementsInstancedBaseVertex ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , basevertex int32 ) { syscall . Syscall6 ( gpDrawElementsInstancedBaseVertex , 6 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( basevertex ) ) } 
func DrawElementsInstancedBaseVertexBaseInstance ( mode uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , instancecount int32 , basevertex int32 , baseinstance uint32 ) { syscall . Syscall9 ( gpDrawElementsInstancedBaseVertexBaseInstance , 7 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( basevertex ) , uintptr ( baseinstance ) , 0 , 0 ) } 
func DrawPixels ( width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall6 ( gpDrawPixels , 5 , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func DrawRangeElements ( mode uint32 , start uint32 , end uint32 , count int32 , xtype uint32 , indices unsafe . Pointer ) { syscall . Syscall6 ( gpDrawRangeElements , 6 , uintptr ( mode ) , uintptr ( start ) , uintptr ( end ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) ) } 
func DrawRangeElementsBaseVertex ( mode uint32 , start uint32 , end uint32 , count int32 , xtype uint32 , indices unsafe . Pointer , basevertex int32 ) { syscall . Syscall9 ( gpDrawRangeElementsBaseVertex , 7 , uintptr ( mode ) , uintptr ( start ) , uintptr ( end ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( basevertex ) , 0 , 0 ) } 
func DrawTransformFeedback ( mode uint32 , id uint32 ) { syscall . Syscall ( gpDrawTransformFeedback , 2 , uintptr ( mode ) , uintptr ( id ) , 0 ) } 
func DrawTransformFeedbackInstanced ( mode uint32 , id uint32 , instancecount int32 ) { syscall . Syscall ( gpDrawTransformFeedbackInstanced , 3 , uintptr ( mode ) , uintptr ( id ) , uintptr ( instancecount ) ) } 
func DrawTransformFeedbackStream ( mode uint32 , id uint32 , stream uint32 ) { syscall . Syscall ( gpDrawTransformFeedbackStream , 3 , uintptr ( mode ) , uintptr ( id ) , uintptr ( stream ) ) } 
func DrawTransformFeedbackStreamInstanced ( mode uint32 , id uint32 , stream uint32 , instancecount int32 ) { syscall . Syscall6 ( gpDrawTransformFeedbackStreamInstanced , 4 , uintptr ( mode ) , uintptr ( id ) , uintptr ( stream ) , uintptr ( instancecount ) , 0 , 0 ) } 
func EGLImageTargetTexStorageEXT ( target uint32 , image unsafe . Pointer , attrib_list * int32 ) { syscall . Syscall ( gpEGLImageTargetTexStorageEXT , 3 , uintptr ( target ) , uintptr ( image ) , uintptr ( unsafe . Pointer ( attrib_list ) ) ) } 
func EGLImageTargetTextureStorageEXT ( texture uint32 , image unsafe . Pointer , attrib_list * int32 ) { syscall . Syscall ( gpEGLImageTargetTextureStorageEXT , 3 , uintptr ( texture ) , uintptr ( image ) , uintptr ( unsafe . Pointer ( attrib_list ) ) ) } 
func EdgeFlagPointer ( stride int32 , pointer unsafe . Pointer ) { syscall . Syscall ( gpEdgeFlagPointer , 2 , uintptr ( stride ) , uintptr ( pointer ) , 0 ) } 
func EnableVertexArrayAttrib ( vaobj uint32 , index uint32 ) { syscall . Syscall ( gpEnableVertexArrayAttrib , 2 , uintptr ( vaobj ) , uintptr ( index ) , 0 ) } 
func FeedbackBuffer ( size int32 , xtype uint32 , buffer * float32 ) { syscall . Syscall ( gpFeedbackBuffer , 3 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( buffer ) ) ) } 
func FenceSync ( condition uint32 , flags uint32 ) uintptr { ret , _ , _ := syscall . Syscall ( gpFenceSync , 2 , uintptr ( condition ) , uintptr ( flags ) , 0 ) return ( uintptr ) ( ret ) } 
func FlushMappedBufferRange ( target uint32 , offset int , length int ) { syscall . Syscall ( gpFlushMappedBufferRange , 3 , uintptr ( target ) , uintptr ( offset ) , uintptr ( length ) ) } 
func FlushMappedNamedBufferRange ( buffer uint32 , offset int , length int ) { syscall . Syscall ( gpFlushMappedNamedBufferRange , 3 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) ) } 
func FogCoordPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall ( gpFogCoordPointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func FramebufferParameteri ( target uint32 , pname uint32 , param int32 ) { syscall . Syscall ( gpFramebufferParameteri , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( param ) ) } 
func FramebufferRenderbuffer ( target uint32 , attachment uint32 , renderbuffertarget uint32 , renderbuffer uint32 ) { syscall . Syscall6 ( gpFramebufferRenderbuffer , 4 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( renderbuffertarget ) , uintptr ( renderbuffer ) , 0 , 0 ) } 
func FramebufferTexture2D ( target uint32 , attachment uint32 , textarget uint32 , texture uint32 , level int32 ) { syscall . Syscall6 ( gpFramebufferTexture2D , 5 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( textarget ) , uintptr ( texture ) , uintptr ( level ) , 0 ) } 
func FramebufferTextureLayer ( target uint32 , attachment uint32 , texture uint32 , level int32 , layer int32 ) { syscall . Syscall6 ( gpFramebufferTextureLayer , 5 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( texture ) , uintptr ( level ) , uintptr ( layer ) , 0 ) } 
func Frustum ( left float64 , right float64 , bottom float64 , top float64 , zNear float64 , zFar float64 ) { syscall . Syscall6 ( gpFrustum , 6 , uintptr ( math . Float64bits ( left ) ) , uintptr ( math . Float64bits ( right ) ) , uintptr ( math . Float64bits ( bottom ) ) , uintptr ( math . Float64bits ( top ) ) , uintptr ( math . Float64bits ( zNear ) ) , uintptr ( math . Float64bits ( zFar ) ) ) } 
func GenBuffers ( n int32 , buffers * uint32 ) { syscall . Syscall ( gpGenBuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func GenFramebuffers ( n int32 , framebuffers * uint32 ) { syscall . Syscall ( gpGenFramebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func GenLists ( xrange int32 ) uint32 { ret , _ , _ := syscall . Syscall ( gpGenLists , 1 , uintptr ( xrange ) , 0 , 0 ) return ( uint32 ) ( ret ) } 
func GenProgramPipelines ( n int32 , pipelines * uint32 ) { syscall . Syscall ( gpGenProgramPipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func GenQueries ( n int32 , ids * uint32 ) { syscall . Syscall ( gpGenQueries , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func GenRenderbuffers ( n int32 , renderbuffers * uint32 ) { syscall . Syscall ( gpGenRenderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func GenSamplers ( count int32 , samplers * uint32 ) { syscall . Syscall ( gpGenSamplers , 2 , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func GenTextures ( n int32 , textures * uint32 ) { syscall . Syscall ( gpGenTextures , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , 0 ) } 
func GenTransformFeedbacks ( n int32 , ids * uint32 ) { syscall . Syscall ( gpGenTransformFeedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func GenVertexArrays ( n int32 , arrays * uint32 ) { syscall . Syscall ( gpGenVertexArrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func GetActiveAtomicCounterBufferiv ( program uint32 , bufferIndex uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetActiveAtomicCounterBufferiv , 4 , uintptr ( program ) , uintptr ( bufferIndex ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func GetActiveAttrib ( program uint32 , index uint32 , bufSize int32 , length * int32 , size * int32 , xtype * uint32 , name * uint8 ) { syscall . Syscall9 ( gpGetActiveAttrib , 7 , uintptr ( program ) , uintptr ( index ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( size ) ) , uintptr ( unsafe . Pointer ( xtype ) ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func GetActiveSubroutineName ( program uint32 , shadertype uint32 , index uint32 , bufsize int32 , length * int32 , name * uint8 ) { syscall . Syscall6 ( gpGetActiveSubroutineName , 6 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( index ) , uintptr ( bufsize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func GetActiveSubroutineUniformName ( program uint32 , shadertype uint32 , index uint32 , bufsize int32 , length * int32 , name * uint8 ) { syscall . Syscall6 ( gpGetActiveSubroutineUniformName , 6 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( index ) , uintptr ( bufsize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func GetActiveUniform ( program uint32 , index uint32 , bufSize int32 , length * int32 , size * int32 , xtype * uint32 , name * uint8 ) { syscall . Syscall9 ( gpGetActiveUniform , 7 , uintptr ( program ) , uintptr ( index ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( size ) ) , uintptr ( unsafe . Pointer ( xtype ) ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func GetActiveUniformBlockName ( program uint32 , uniformBlockIndex uint32 , bufSize int32 , length * int32 , uniformBlockName * uint8 ) { syscall . Syscall6 ( gpGetActiveUniformBlockName , 5 , uintptr ( program ) , uintptr ( uniformBlockIndex ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( uniformBlockName ) ) , 0 ) } 
func GetActiveUniformBlockiv ( program uint32 , uniformBlockIndex uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetActiveUniformBlockiv , 4 , uintptr ( program ) , uintptr ( uniformBlockIndex ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func GetActiveUniformName ( program uint32 , uniformIndex uint32 , bufSize int32 , length * int32 , uniformName * uint8 ) { syscall . Syscall6 ( gpGetActiveUniformName , 5 , uintptr ( program ) , uintptr ( uniformIndex ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( uniformName ) ) , 0 ) } 
func GetActiveUniformsiv ( program uint32 , uniformCount int32 , uniformIndices * uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetActiveUniformsiv , 5 , uintptr ( program ) , uintptr ( uniformCount ) , uintptr ( unsafe . Pointer ( uniformIndices ) ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func GetAttachedShaders ( program uint32 , maxCount int32 , count * int32 , shaders * uint32 ) { syscall . Syscall6 ( gpGetAttachedShaders , 4 , uintptr ( program ) , uintptr ( maxCount ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( unsafe . Pointer ( shaders ) ) , 0 , 0 ) } 
func GetAttribLocation ( program uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetAttribLocation , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int32 ) ( ret ) } 
func GetBufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetBufferParameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetBufferPointerv ( target uint32 , pname uint32 , params * unsafe . Pointer ) { syscall . Syscall ( gpGetBufferPointerv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetBufferSubData ( target uint32 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall6 ( gpGetBufferSubData , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func GetClipPlane ( plane uint32 , equation * float64 ) { syscall . Syscall ( gpGetClipPlane , 2 , uintptr ( plane ) , uintptr ( unsafe . Pointer ( equation ) ) , 0 ) } 
func GetCompressedTexImage ( target uint32 , level int32 , img unsafe . Pointer ) { syscall . Syscall ( gpGetCompressedTexImage , 3 , uintptr ( target ) , uintptr ( level ) , uintptr ( img ) ) } 
func GetCompressedTextureImage ( texture uint32 , level int32 , bufSize int32 , pixels unsafe . Pointer ) { syscall . Syscall6 ( gpGetCompressedTextureImage , 4 , uintptr ( texture ) , uintptr ( level ) , uintptr ( bufSize ) , uintptr ( pixels ) , 0 , 0 ) } 
func GetCompressedTextureSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , bufSize int32 , pixels unsafe . Pointer ) { syscall . Syscall12 ( gpGetCompressedTextureSubImage , 10 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( bufSize ) , uintptr ( pixels ) , 0 , 0 ) } 
func GetDebugMessageLog ( count uint32 , bufSize int32 , sources * uint32 , types * uint32 , ids * uint32 , severities * uint32 , lengths * int32 , messageLog * uint8 ) uint32 { ret , _ , _ := syscall . Syscall9 ( gpGetDebugMessageLog , 8 , uintptr ( count ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( sources ) ) , uintptr ( unsafe . Pointer ( types ) ) , uintptr ( unsafe . Pointer ( ids ) ) , uintptr ( unsafe . Pointer ( severities ) ) , uintptr ( unsafe . Pointer ( lengths ) ) , uintptr ( unsafe . Pointer ( messageLog ) ) , 0 ) return ( uint32 ) ( ret ) } 
func GetError ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetError , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) } 
func GetFragDataIndex ( program uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetFragDataIndex , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int32 ) ( ret ) } 
func GetFramebufferAttachmentParameteriv ( target uint32 , attachment uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetFramebufferAttachmentParameteriv , 4 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func GetFramebufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetFramebufferParameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetGraphicsResetStatus ( ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetGraphicsResetStatus , 0 , 0 , 0 , 0 ) return ( uint32 ) ( ret ) } 
func GetInternalformativ ( target uint32 , internalformat uint32 , pname uint32 , bufSize int32 , params * int32 ) { syscall . Syscall6 ( gpGetInternalformativ , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( pname ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func GetMultisamplefv ( pname uint32 , index uint32 , val * float32 ) { syscall . Syscall ( gpGetMultisamplefv , 3 , uintptr ( pname ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( val ) ) ) } 
func GetNamedBufferParameteri64v ( buffer uint32 , pname uint32 , params * int64 ) { syscall . Syscall ( gpGetNamedBufferParameteri64v , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetNamedBufferParameteriv ( buffer uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetNamedBufferParameteriv , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetNamedBufferPointerv ( buffer uint32 , pname uint32 , params * unsafe . Pointer ) { syscall . Syscall ( gpGetNamedBufferPointerv , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetNamedBufferSubData ( buffer uint32 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall6 ( gpGetNamedBufferSubData , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func GetNamedFramebufferAttachmentParameteriv ( framebuffer uint32 , attachment uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetNamedFramebufferAttachmentParameteriv , 4 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func GetNamedFramebufferParameteriv ( framebuffer uint32 , pname uint32 , param * int32 ) { syscall . Syscall ( gpGetNamedFramebufferParameteriv , 3 , uintptr ( framebuffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func GetNamedRenderbufferParameteriv ( renderbuffer uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetNamedRenderbufferParameteriv , 3 , uintptr ( renderbuffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetObjectLabel ( identifier uint32 , name uint32 , bufSize int32 , length * int32 , label * uint8 ) { syscall . Syscall6 ( gpGetObjectLabel , 5 , uintptr ( identifier ) , uintptr ( name ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( label ) ) , 0 ) } 
func GetObjectPtrLabel ( ptr unsafe . Pointer , bufSize int32 , length * int32 , label * uint8 ) { syscall . Syscall6 ( gpGetObjectPtrLabel , 4 , uintptr ( ptr ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( label ) ) , 0 , 0 ) } 
func GetPointerv ( pname uint32 , params * unsafe . Pointer ) { syscall . Syscall ( gpGetPointerv , 2 , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func GetPolygonStipple ( mask * uint8 ) { syscall . Syscall ( gpGetPolygonStipple , 1 , uintptr ( unsafe . Pointer ( mask ) ) , 0 , 0 ) } 
func GetProgramBinary ( program uint32 , bufSize int32 , length * int32 , binaryFormat * uint32 , binary unsafe . Pointer ) { syscall . Syscall6 ( gpGetProgramBinary , 5 , uintptr ( program ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( binaryFormat ) ) , uintptr ( binary ) , 0 ) } 
func GetProgramInfoLog ( program uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { syscall . Syscall6 ( gpGetProgramInfoLog , 4 , uintptr ( program ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( infoLog ) ) , 0 , 0 ) } 
func GetProgramPipelineInfoLog ( pipeline uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { syscall . Syscall6 ( gpGetProgramPipelineInfoLog , 4 , uintptr ( pipeline ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( infoLog ) ) , 0 , 0 ) } 
func GetProgramResourceIndex ( program uint32 , programInterface uint32 , name * uint8 ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetProgramResourceIndex , 3 , uintptr ( program ) , uintptr ( programInterface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( uint32 ) ( ret ) } 
func GetProgramResourceLocation ( program uint32 , programInterface uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetProgramResourceLocation , 3 , uintptr ( program ) , uintptr ( programInterface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetProgramResourceLocationIndex ( program uint32 , programInterface uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetProgramResourceLocationIndex , 3 , uintptr ( program ) , uintptr ( programInterface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetProgramResourceName ( program uint32 , programInterface uint32 , index uint32 , bufSize int32 , length * int32 , name * uint8 ) { syscall . Syscall6 ( gpGetProgramResourceName , 6 , uintptr ( program ) , uintptr ( programInterface ) , uintptr ( index ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func GetProgramiv ( program uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetProgramiv , 3 , uintptr ( program ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetQueryIndexediv ( target uint32 , index uint32 , pname uint32 , params * int32 ) { syscall . Syscall6 ( gpGetQueryIndexediv , 4 , uintptr ( target ) , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func GetQueryObjectuiv ( id uint32 , pname uint32 , params * uint32 ) { syscall . Syscall ( gpGetQueryObjectuiv , 3 , uintptr ( id ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetQueryiv ( target uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetQueryiv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetRenderbufferParameteriv ( target uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetRenderbufferParameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetShaderInfoLog ( shader uint32 , bufSize int32 , length * int32 , infoLog * uint8 ) { syscall . Syscall6 ( gpGetShaderInfoLog , 4 , uintptr ( shader ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( infoLog ) ) , 0 , 0 ) } 
func GetShaderPrecisionFormat ( shadertype uint32 , precisiontype uint32 , xrange * int32 , precision * int32 ) { syscall . Syscall6 ( gpGetShaderPrecisionFormat , 4 , uintptr ( shadertype ) , uintptr ( precisiontype ) , uintptr ( unsafe . Pointer ( xrange ) ) , uintptr ( unsafe . Pointer ( precision ) ) , 0 , 0 ) } 
func GetShaderSource ( shader uint32 , bufSize int32 , length * int32 , source * uint8 ) { syscall . Syscall6 ( gpGetShaderSource , 4 , uintptr ( shader ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( source ) ) , 0 , 0 ) } 
func GetShaderiv ( shader uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetShaderiv , 3 , uintptr ( shader ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetString ( name uint32 ) * uint8 { ret , _ , _ := syscall . Syscall ( gpGetString , 1 , uintptr ( name ) , 0 , 0 ) return ( * uint8 ) ( unsafe . Pointer ( ret ) ) } 
func GetSubroutineIndex ( program uint32 , shadertype uint32 , name * uint8 ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetSubroutineIndex , 3 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( uint32 ) ( ret ) } 
func GetSubroutineUniformLocation ( program uint32 , shadertype uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetSubroutineUniformLocation , 3 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int32 ) ( ret ) } 
func GetSynciv ( sync uintptr , pname uint32 , bufSize int32 , length * int32 , values * int32 ) { syscall . Syscall6 ( gpGetSynciv , 5 , uintptr ( sync ) , uintptr ( pname ) , uintptr ( bufSize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( values ) ) , 0 ) } 
func GetTexImage ( target uint32 , level int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall6 ( gpGetTexImage , 5 , uintptr ( target ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func GetTextureImage ( texture uint32 , level int32 , format uint32 , xtype uint32 , bufSize int32 , pixels unsafe . Pointer ) { syscall . Syscall6 ( gpGetTextureImage , 6 , uintptr ( texture ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( bufSize ) , uintptr ( pixels ) ) } 
func GetTextureSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , bufSize int32 , pixels unsafe . Pointer ) { syscall . Syscall12 ( gpGetTextureSubImage , 12 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( bufSize ) , uintptr ( pixels ) ) } 
func GetTransformFeedbackiv ( xfb uint32 , pname uint32 , param * int32 ) { syscall . Syscall ( gpGetTransformFeedbackiv , 3 , uintptr ( xfb ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func GetUniformBlockIndex ( program uint32 , uniformBlockName * uint8 ) uint32 { ret , _ , _ := syscall . Syscall ( gpGetUniformBlockIndex , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( uniformBlockName ) ) , 0 ) return ( uint32 ) ( ret ) } 
func GetUniformIndices ( program uint32 , uniformCount int32 , uniformNames * * uint8 , uniformIndices * uint32 ) { syscall . Syscall6 ( gpGetUniformIndices , 4 , uintptr ( program ) , uintptr ( uniformCount ) , uintptr ( unsafe . Pointer ( uniformNames ) ) , uintptr ( unsafe . Pointer ( uniformIndices ) ) , 0 , 0 ) } 
func GetUniformLocation ( program uint32 , name * uint8 ) int32 { ret , _ , _ := syscall . Syscall ( gpGetUniformLocation , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int32 ) ( ret ) } 
func GetUniformfv ( program uint32 , location int32 , params * float32 ) { syscall . Syscall ( gpGetUniformfv , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetUniformiv ( program uint32 , location int32 , params * int32 ) { syscall . Syscall ( gpGetUniformiv , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetVertexArrayiv ( vaobj uint32 , pname uint32 , param * int32 ) { syscall . Syscall ( gpGetVertexArrayiv , 3 , uintptr ( vaobj ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func GetVertexAttribLdv ( index uint32 , pname uint32 , params * float64 ) { syscall . Syscall ( gpGetVertexAttribLdv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribPointerv ( index uint32 , pname uint32 , pointer * unsafe . Pointer ) { syscall . Syscall ( gpGetVertexAttribPointerv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( pointer ) ) ) } 
func GetVertexAttribdv ( index uint32 , pname uint32 , params * float64 ) { syscall . Syscall ( gpGetVertexAttribdv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribfv ( index uint32 , pname uint32 , params * float32 ) { syscall . Syscall ( gpGetVertexAttribfv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetVertexAttribiv ( index uint32 , pname uint32 , params * int32 ) { syscall . Syscall ( gpGetVertexAttribiv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func GetVkProcAddrNV ( name * uint8 ) unsafe . Pointer { ret , _ , _ := syscall . Syscall ( gpGetVkProcAddrNV , 1 , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Hint ( target uint32 , mode uint32 ) { syscall . Syscall ( gpHint , 2 , uintptr ( target ) , uintptr ( mode ) , 0 ) } 
func IndexPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall ( gpIndexPointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func InterleavedArrays ( format uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall ( gpInterleavedArrays , 3 , uintptr ( format ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func InvalidateBufferSubData ( buffer uint32 , offset int , length int ) { syscall . Syscall ( gpInvalidateBufferSubData , 3 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) ) } 
func InvalidateFramebuffer ( target uint32 , numAttachments int32 , attachments * uint32 ) { syscall . Syscall ( gpInvalidateFramebuffer , 3 , uintptr ( target ) , uintptr ( numAttachments ) , uintptr ( unsafe . Pointer ( attachments ) ) ) } 
func InvalidateNamedFramebufferData ( framebuffer uint32 , numAttachments int32 , attachments * uint32 ) { syscall . Syscall ( gpInvalidateNamedFramebufferData , 3 , uintptr ( framebuffer ) , uintptr ( numAttachments ) , uintptr ( unsafe . Pointer ( attachments ) ) ) } 
func InvalidateNamedFramebufferSubData ( framebuffer uint32 , numAttachments int32 , attachments * uint32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpInvalidateNamedFramebufferSubData , 7 , uintptr ( framebuffer ) , uintptr ( numAttachments ) , uintptr ( unsafe . Pointer ( attachments ) ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func InvalidateSubFramebuffer ( target uint32 , numAttachments int32 , attachments * uint32 , x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall9 ( gpInvalidateSubFramebuffer , 7 , uintptr ( target ) , uintptr ( numAttachments ) , uintptr ( unsafe . Pointer ( attachments ) ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func InvalidateTexImage ( texture uint32 , level int32 ) { syscall . Syscall ( gpInvalidateTexImage , 2 , uintptr ( texture ) , uintptr ( level ) , 0 ) } 
func InvalidateTexSubImage ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 ) { syscall . Syscall9 ( gpInvalidateTexSubImage , 8 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , 0 ) } 
func IsBuffer ( buffer uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsBuffer , 1 , uintptr ( buffer ) , 0 , 0 ) return ret != 0 } 
func IsFramebuffer ( framebuffer uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsFramebuffer , 1 , uintptr ( framebuffer ) , 0 , 0 ) return ret != 0 } 
func IsList ( list uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsList , 1 , uintptr ( list ) , 0 , 0 ) return ret != 0 } 
func IsProgram ( program uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsProgram , 1 , uintptr ( program ) , 0 , 0 ) return ret != 0 } 
func IsProgramPipeline ( pipeline uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsProgramPipeline , 1 , uintptr ( pipeline ) , 0 , 0 ) return ret != 0 } 
func IsQuery ( id uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsQuery , 1 , uintptr ( id ) , 0 , 0 ) return ret != 0 } 
func IsRenderbuffer ( renderbuffer uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsRenderbuffer , 1 , uintptr ( renderbuffer ) , 0 , 0 ) return ret != 0 } 
func IsSampler ( sampler uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsSampler , 1 , uintptr ( sampler ) , 0 , 0 ) return ret != 0 } 
func IsShader ( shader uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsShader , 1 , uintptr ( shader ) , 0 , 0 ) return ret != 0 } 
func IsSync ( sync uintptr ) bool { ret , _ , _ := syscall . Syscall ( gpIsSync , 1 , uintptr ( sync ) , 0 , 0 ) return ret != 0 } 
func IsTexture ( texture uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsTexture , 1 , uintptr ( texture ) , 0 , 0 ) return ret != 0 } 
func IsTransformFeedback ( id uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsTransformFeedback , 1 , uintptr ( id ) , 0 , 0 ) return ret != 0 } 
func IsVertexArray ( array uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpIsVertexArray , 1 , uintptr ( array ) , 0 , 0 ) return ret != 0 } 
func LineStipple ( factor int32 , pattern uint16 ) { syscall . Syscall ( gpLineStipple , 2 , uintptr ( factor ) , uintptr ( pattern ) , 0 ) } 
func LineWidth ( width float32 ) { syscall . Syscall ( gpLineWidth , 1 , uintptr ( math . Float32bits ( width ) ) , 0 , 0 ) } 
func MapBuffer ( target uint32 , access uint32 ) unsafe . Pointer { ret , _ , _ := syscall . Syscall ( gpMapBuffer , 2 , uintptr ( target ) , uintptr ( access ) , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func MapBufferRange ( target uint32 , offset int , length int , access uint32 ) unsafe . Pointer { ret , _ , _ := syscall . Syscall6 ( gpMapBufferRange , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( length ) , uintptr ( access ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func MapNamedBuffer ( buffer uint32 , access uint32 ) unsafe . Pointer { ret , _ , _ := syscall . Syscall ( gpMapNamedBuffer , 2 , uintptr ( buffer ) , uintptr ( access ) , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func MapNamedBufferRange ( buffer uint32 , offset int , length int , access uint32 ) unsafe . Pointer { ret , _ , _ := syscall . Syscall6 ( gpMapNamedBufferRange , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) , uintptr ( access ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func MultiDrawArrays ( mode uint32 , first * int32 , count * int32 , drawcount int32 ) { syscall . Syscall6 ( gpMultiDrawArrays , 4 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( first ) ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( drawcount ) , 0 , 0 ) } 
func MultiDrawArraysIndirect ( mode uint32 , indirect unsafe . Pointer , drawcount int32 , stride int32 ) { syscall . Syscall6 ( gpMultiDrawArraysIndirect , 4 , uintptr ( mode ) , uintptr ( indirect ) , uintptr ( drawcount ) , uintptr ( stride ) , 0 , 0 ) } 
func MultiDrawElements ( mode uint32 , count * int32 , xtype uint32 , indices * unsafe . Pointer , drawcount int32 ) { syscall . Syscall6 ( gpMultiDrawElements , 5 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( indices ) ) , uintptr ( drawcount ) , 0 ) } 
func MultiDrawElementsBaseVertex ( mode uint32 , count * int32 , xtype uint32 , indices * unsafe . Pointer , drawcount int32 , basevertex * int32 ) { syscall . Syscall6 ( gpMultiDrawElementsBaseVertex , 6 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( indices ) ) , uintptr ( drawcount ) , uintptr ( unsafe . Pointer ( basevertex ) ) ) } 
func MultiDrawElementsIndirect ( mode uint32 , xtype uint32 , indirect unsafe . Pointer , drawcount int32 , stride int32 ) { syscall . Syscall6 ( gpMultiDrawElementsIndirect , 5 , uintptr ( mode ) , uintptr ( xtype ) , uintptr ( indirect ) , uintptr ( drawcount ) , uintptr ( stride ) , 0 ) } 
func NamedBufferData ( buffer uint32 , size int , data unsafe . Pointer , usage uint32 ) { syscall . Syscall6 ( gpNamedBufferData , 4 , uintptr ( buffer ) , uintptr ( size ) , uintptr ( data ) , uintptr ( usage ) , 0 , 0 ) } 
func NamedBufferStorage ( buffer uint32 , size int , data unsafe . Pointer , flags uint32 ) { syscall . Syscall6 ( gpNamedBufferStorage , 4 , uintptr ( buffer ) , uintptr ( size ) , uintptr ( data ) , uintptr ( flags ) , 0 , 0 ) } 
func NamedBufferStorageExternalEXT ( buffer uint32 , offset int , size int , clientBuffer unsafe . Pointer , flags uint32 ) { syscall . Syscall6 ( gpNamedBufferStorageExternalEXT , 5 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( clientBuffer ) , uintptr ( flags ) , 0 ) } 
func NamedBufferSubData ( buffer uint32 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall6 ( gpNamedBufferSubData , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func NamedFramebufferDrawBuffer ( framebuffer uint32 , buf uint32 ) { syscall . Syscall ( gpNamedFramebufferDrawBuffer , 2 , uintptr ( framebuffer ) , uintptr ( buf ) , 0 ) } 
func NamedFramebufferDrawBuffers ( framebuffer uint32 , n int32 , bufs * uint32 ) { syscall . Syscall ( gpNamedFramebufferDrawBuffers , 3 , uintptr ( framebuffer ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( bufs ) ) ) } 
func NamedFramebufferParameteri ( framebuffer uint32 , pname uint32 , param int32 ) { syscall . Syscall ( gpNamedFramebufferParameteri , 3 , uintptr ( framebuffer ) , uintptr ( pname ) , uintptr ( param ) ) } 
func NamedFramebufferReadBuffer ( framebuffer uint32 , src uint32 ) { syscall . Syscall ( gpNamedFramebufferReadBuffer , 2 , uintptr ( framebuffer ) , uintptr ( src ) , 0 ) } 
func NamedFramebufferRenderbuffer ( framebuffer uint32 , attachment uint32 , renderbuffertarget uint32 , renderbuffer uint32 ) { syscall . Syscall6 ( gpNamedFramebufferRenderbuffer , 4 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( renderbuffertarget ) , uintptr ( renderbuffer ) , 0 , 0 ) } 
func NamedFramebufferTextureLayer ( framebuffer uint32 , attachment uint32 , texture uint32 , level int32 , layer int32 ) { syscall . Syscall6 ( gpNamedFramebufferTextureLayer , 5 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( texture ) , uintptr ( level ) , uintptr ( layer ) , 0 ) } 
func NamedRenderbufferStorage ( renderbuffer uint32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpNamedRenderbufferStorage , 4 , uintptr ( renderbuffer ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func NamedRenderbufferStorageMultisample ( renderbuffer uint32 , samples int32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpNamedRenderbufferStorageMultisample , 5 , uintptr ( renderbuffer ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func NewList ( list uint32 , mode uint32 ) { syscall . Syscall ( gpNewList , 2 , uintptr ( list ) , uintptr ( mode ) , 0 ) } 
func NormalPointer ( xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall ( gpNormalPointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func ObjectLabel ( identifier uint32 , name uint32 , length int32 , label * uint8 ) { syscall . Syscall6 ( gpObjectLabel , 4 , uintptr ( identifier ) , uintptr ( name ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( label ) ) , 0 , 0 ) } 
func ObjectPtrLabel ( ptr unsafe . Pointer , length int32 , label * uint8 ) { syscall . Syscall ( gpObjectPtrLabel , 3 , uintptr ( ptr ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( label ) ) ) } 
func Ortho ( left float64 , right float64 , bottom float64 , top float64 , zNear float64 , zFar float64 ) { syscall . Syscall6 ( gpOrtho , 6 , uintptr ( math . Float64bits ( left ) ) , uintptr ( math . Float64bits ( right ) ) , uintptr ( math . Float64bits ( bottom ) ) , uintptr ( math . Float64bits ( top ) ) , uintptr ( math . Float64bits ( zNear ) ) , uintptr ( math . Float64bits ( zFar ) ) ) } 
func PassThrough ( token float32 ) { syscall . Syscall ( gpPassThrough , 1 , uintptr ( math . Float32bits ( token ) ) , 0 , 0 ) } 
func PatchParameteri ( pname uint32 , value int32 ) { syscall . Syscall ( gpPatchParameteri , 2 , uintptr ( pname ) , uintptr ( value ) , 0 ) } 
func PixelStorei ( pname uint32 , param int32 ) { syscall . Syscall ( gpPixelStorei , 2 , uintptr ( pname ) , uintptr ( param ) , 0 ) } 
func PixelZoom ( xfactor float32 , yfactor float32 ) { syscall . Syscall ( gpPixelZoom , 2 , uintptr ( math . Float32bits ( xfactor ) ) , uintptr ( math . Float32bits ( yfactor ) ) , 0 ) } 
func PointSize ( size float32 ) { syscall . Syscall ( gpPointSize , 1 , uintptr ( math . Float32bits ( size ) ) , 0 , 0 ) } 
func PolygonMode ( face uint32 , mode uint32 ) { syscall . Syscall ( gpPolygonMode , 2 , uintptr ( face ) , uintptr ( mode ) , 0 ) } 
func PolygonOffset ( factor float32 , units float32 ) { syscall . Syscall ( gpPolygonOffset , 2 , uintptr ( math . Float32bits ( factor ) ) , uintptr ( math . Float32bits ( units ) ) , 0 ) } 
func PolygonStipple ( mask * uint8 ) { syscall . Syscall ( gpPolygonStipple , 1 , uintptr ( unsafe . Pointer ( mask ) ) , 0 , 0 ) } 
func PrioritizeTextures ( n int32 , textures * uint32 , priorities * float32 ) { syscall . Syscall ( gpPrioritizeTextures , 3 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , uintptr ( unsafe . Pointer ( priorities ) ) ) } 
func ProgramBinary ( program uint32 , binaryFormat uint32 , binary unsafe . Pointer , length int32 ) { syscall . Syscall6 ( gpProgramBinary , 4 , uintptr ( program ) , uintptr ( binaryFormat ) , uintptr ( binary ) , uintptr ( length ) , 0 , 0 ) } 
func ProgramParameteri ( program uint32 , pname uint32 , value int32 ) { syscall . Syscall ( gpProgramParameteri , 3 , uintptr ( program ) , uintptr ( pname ) , uintptr ( value ) ) } 
func ProgramUniform1f ( program uint32 , location int32 , v0 float32 ) { syscall . Syscall ( gpProgramUniform1f , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) ) } 
func ProgramUniform1fv ( program uint32 , location int32 , count int32 , value * float32 ) { syscall . Syscall6 ( gpProgramUniform1fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform1i ( program uint32 , location int32 , v0 int32 ) { syscall . Syscall ( gpProgramUniform1i , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) ) } 
func ProgramUniform1iv ( program uint32 , location int32 , count int32 , value * int32 ) { syscall . Syscall6 ( gpProgramUniform1iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform1ui ( program uint32 , location int32 , v0 uint32 ) { syscall . Syscall ( gpProgramUniform1ui , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) ) } 
func ProgramUniform1uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { syscall . Syscall6 ( gpProgramUniform1uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform2f ( program uint32 , location int32 , v0 float32 , v1 float32 ) { syscall . Syscall6 ( gpProgramUniform2f , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) , 0 , 0 ) } 
func ProgramUniform2fv ( program uint32 , location int32 , count int32 , value * float32 ) { syscall . Syscall6 ( gpProgramUniform2fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform2i ( program uint32 , location int32 , v0 int32 , v1 int32 ) { syscall . Syscall6 ( gpProgramUniform2i , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , 0 , 0 ) } 
func ProgramUniform2iv ( program uint32 , location int32 , count int32 , value * int32 ) { syscall . Syscall6 ( gpProgramUniform2iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform2ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 ) { syscall . Syscall6 ( gpProgramUniform2ui , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , 0 , 0 ) } 
func ProgramUniform2uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { syscall . Syscall6 ( gpProgramUniform2uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform3f ( program uint32 , location int32 , v0 float32 , v1 float32 , v2 float32 ) { syscall . Syscall6 ( gpProgramUniform3f , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) , uintptr ( math . Float32bits ( v2 ) ) , 0 ) } 
func ProgramUniform3fv ( program uint32 , location int32 , count int32 , value * float32 ) { syscall . Syscall6 ( gpProgramUniform3fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform3i ( program uint32 , location int32 , v0 int32 , v1 int32 , v2 int32 ) { syscall . Syscall6 ( gpProgramUniform3i , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , 0 ) } 
func ProgramUniform3iv ( program uint32 , location int32 , count int32 , value * int32 ) { syscall . Syscall6 ( gpProgramUniform3iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform3ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 , v2 uint32 ) { syscall . Syscall6 ( gpProgramUniform3ui , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , 0 ) } 
func ProgramUniform3uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { syscall . Syscall6 ( gpProgramUniform3uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform4f ( program uint32 , location int32 , v0 float32 , v1 float32 , v2 float32 , v3 float32 ) { syscall . Syscall6 ( gpProgramUniform4f , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) , uintptr ( math . Float32bits ( v2 ) ) , uintptr ( math . Float32bits ( v3 ) ) ) } 
func ProgramUniform4fv ( program uint32 , location int32 , count int32 , value * float32 ) { syscall . Syscall6 ( gpProgramUniform4fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform4i ( program uint32 , location int32 , v0 int32 , v1 int32 , v2 int32 , v3 int32 ) { syscall . Syscall6 ( gpProgramUniform4i , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , uintptr ( v3 ) ) } 
func ProgramUniform4iv ( program uint32 , location int32 , count int32 , value * int32 ) { syscall . Syscall6 ( gpProgramUniform4iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniform4ui ( program uint32 , location int32 , v0 uint32 , v1 uint32 , v2 uint32 , v3 uint32 ) { syscall . Syscall6 ( gpProgramUniform4ui , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , uintptr ( v3 ) ) } 
func ProgramUniform4uiv ( program uint32 , location int32 , count int32 , value * uint32 ) { syscall . Syscall6 ( gpProgramUniform4uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func ProgramUniformMatrix2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix2x3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix2x3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix2x4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix2x4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix3x2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix3x2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix3x4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix3x4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix4fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix4x2fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix4x2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func ProgramUniformMatrix4x3fv ( program uint32 , location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpProgramUniformMatrix4x3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func PushDebugGroup ( source uint32 , id uint32 , length int32 , message * uint8 ) { syscall . Syscall6 ( gpPushDebugGroup , 4 , uintptr ( source ) , uintptr ( id ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( message ) ) , 0 , 0 ) } 
func QueryCounter ( id uint32 , target uint32 ) { syscall . Syscall ( gpQueryCounter , 2 , uintptr ( id ) , uintptr ( target ) , 0 ) } 
func QueryMatrixxOES ( mantissa * int32 , exponent * int32 ) uint32 { ret , _ , _ := syscall . Syscall ( gpQueryMatrixxOES , 2 , uintptr ( unsafe . Pointer ( mantissa ) ) , uintptr ( unsafe . Pointer ( exponent ) ) , 0 ) return ( uint32 ) ( ret ) } 
func ReadPixels ( x int32 , y int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpReadPixels , 7 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func ReadnPixels ( x int32 , y int32 , width int32 , height int32 , format uint32 , xtype uint32 , bufSize int32 , data unsafe . Pointer ) { syscall . Syscall9 ( gpReadnPixels , 8 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( bufSize ) , uintptr ( data ) , 0 ) } 
func RenderMode ( mode uint32 ) int32 { ret , _ , _ := syscall . Syscall ( gpRenderMode , 1 , uintptr ( mode ) , 0 , 0 ) return ( int32 ) ( ret ) } 
func RenderbufferStorage ( target uint32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpRenderbufferStorage , 4 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func RenderbufferStorageMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpRenderbufferStorageMultisample , 5 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func SampleCoverage ( value float32 , invert bool ) { syscall . Syscall ( gpSampleCoverage , 2 , uintptr ( math . Float32bits ( value ) ) , boolToUintptr ( invert ) , 0 ) } 
func SampleMaski ( maskNumber uint32 , mask uint32 ) { syscall . Syscall ( gpSampleMaski , 2 , uintptr ( maskNumber ) , uintptr ( mask ) , 0 ) } 
func Scissor ( x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall6 ( gpScissor , 4 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func ScissorIndexed ( index uint32 , left int32 , bottom int32 , width int32 , height int32 ) { syscall . Syscall6 ( gpScissorIndexed , 5 , uintptr ( index ) , uintptr ( left ) , uintptr ( bottom ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func SecondaryColorPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall6 ( gpSecondaryColorPointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func SelectBuffer ( size int32 , buffer * uint32 ) { syscall . Syscall ( gpSelectBuffer , 2 , uintptr ( size ) , uintptr ( unsafe . Pointer ( buffer ) ) , 0 ) } 
func ShaderBinary ( count int32 , shaders * uint32 , binaryformat uint32 , binary unsafe . Pointer , length int32 ) { syscall . Syscall6 ( gpShaderBinary , 5 , uintptr ( count ) , uintptr ( unsafe . Pointer ( shaders ) ) , uintptr ( binaryformat ) , uintptr ( binary ) , uintptr ( length ) , 0 ) } 
func ShaderSource ( shader uint32 , count int32 , xstring * * uint8 , length * int32 ) { syscall . Syscall6 ( gpShaderSource , 4 , uintptr ( shader ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( xstring ) ) , uintptr ( unsafe . Pointer ( length ) ) , 0 , 0 ) } 
func ShaderStorageBlockBinding ( program uint32 , storageBlockIndex uint32 , storageBlockBinding uint32 ) { syscall . Syscall ( gpShaderStorageBlockBinding , 3 , uintptr ( program ) , uintptr ( storageBlockIndex ) , uintptr ( storageBlockBinding ) ) } 
func StencilFunc ( xfunc uint32 , ref int32 , mask uint32 ) { syscall . Syscall ( gpStencilFunc , 3 , uintptr ( xfunc ) , uintptr ( ref ) , uintptr ( mask ) ) } 
func StencilFuncSeparate ( face uint32 , xfunc uint32 , ref int32 , mask uint32 ) { syscall . Syscall6 ( gpStencilFuncSeparate , 4 , uintptr ( face ) , uintptr ( xfunc ) , uintptr ( ref ) , uintptr ( mask ) , 0 , 0 ) } 
func StencilMaskSeparate ( face uint32 , mask uint32 ) { syscall . Syscall ( gpStencilMaskSeparate , 2 , uintptr ( face ) , uintptr ( mask ) , 0 ) } 
func StencilOp ( fail uint32 , zfail uint32 , zpass uint32 ) { syscall . Syscall ( gpStencilOp , 3 , uintptr ( fail ) , uintptr ( zfail ) , uintptr ( zpass ) ) } 
func StencilOpSeparate ( face uint32 , sfail uint32 , dpfail uint32 , dppass uint32 ) { syscall . Syscall6 ( gpStencilOpSeparate , 4 , uintptr ( face ) , uintptr ( sfail ) , uintptr ( dpfail ) , uintptr ( dppass ) , 0 , 0 ) } 
func TexBufferRange ( target uint32 , internalformat uint32 , buffer uint32 , offset int , size int ) { syscall . Syscall6 ( gpTexBufferRange , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func TexCoordPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall6 ( gpTexCoordPointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func TexImage1D ( target uint32 , level int32 , internalformat int32 , width int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTexImage1D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( border ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func TexImage2D ( target uint32 , level int32 , internalformat int32 , width int32 , height int32 , border int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTexImage2D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func TexImage2DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { syscall . Syscall6 ( gpTexImage2DMultisample , 6 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , boolToUintptr ( fixedsamplelocations ) ) } 
func TexImage3DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { syscall . Syscall9 ( gpTexImage3DMultisample , 7 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , boolToUintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func TexStorage1D ( target uint32 , levels int32 , internalformat uint32 , width int32 ) { syscall . Syscall6 ( gpTexStorage1D , 4 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , 0 , 0 ) } 
func TexStorage2D ( target uint32 , levels int32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpTexStorage2D , 5 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func TexStorage2DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { syscall . Syscall6 ( gpTexStorage2DMultisample , 6 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , boolToUintptr ( fixedsamplelocations ) ) } 
func TexStorage3D ( target uint32 , levels int32 , internalformat uint32 , width int32 , height int32 , depth int32 ) { syscall . Syscall6 ( gpTexStorage3D , 6 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) ) } 
func TexStorage3DMultisample ( target uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { syscall . Syscall9 ( gpTexStorage3DMultisample , 7 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , boolToUintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func TexSubImage1D ( target uint32 , level int32 , xoffset int32 , width int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTexSubImage1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func TexSubImage2D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTexSubImage2D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func TexSubImage3D ( target uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall12 ( gpTexSubImage3D , 11 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func TextureBuffer ( texture uint32 , internalformat uint32 , buffer uint32 ) { syscall . Syscall ( gpTextureBuffer , 3 , uintptr ( texture ) , uintptr ( internalformat ) , uintptr ( buffer ) ) } 
func TextureBufferRange ( texture uint32 , internalformat uint32 , buffer uint32 , offset int , size int ) { syscall . Syscall6 ( gpTextureBufferRange , 5 , uintptr ( texture ) , uintptr ( internalformat ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func TextureStorage1D ( texture uint32 , levels int32 , internalformat uint32 , width int32 ) { syscall . Syscall6 ( gpTextureStorage1D , 4 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , 0 , 0 ) } 
func TextureStorage2D ( texture uint32 , levels int32 , internalformat uint32 , width int32 , height int32 ) { syscall . Syscall6 ( gpTextureStorage2D , 5 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func TextureStorage2DMultisample ( texture uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , fixedsamplelocations bool ) { syscall . Syscall6 ( gpTextureStorage2DMultisample , 6 , uintptr ( texture ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , boolToUintptr ( fixedsamplelocations ) ) } 
func TextureStorage3D ( texture uint32 , levels int32 , internalformat uint32 , width int32 , height int32 , depth int32 ) { syscall . Syscall6 ( gpTextureStorage3D , 6 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) ) } 
func TextureStorage3DMultisample ( texture uint32 , samples int32 , internalformat uint32 , width int32 , height int32 , depth int32 , fixedsamplelocations bool ) { syscall . Syscall9 ( gpTextureStorage3DMultisample , 7 , uintptr ( texture ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , boolToUintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func TextureSubImage1D ( texture uint32 , level int32 , xoffset int32 , width int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTextureSubImage1D , 7 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func TextureSubImage2D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , width int32 , height int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall9 ( gpTextureSubImage2D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func TextureSubImage3D ( texture uint32 , level int32 , xoffset int32 , yoffset int32 , zoffset int32 , width int32 , height int32 , depth int32 , format uint32 , xtype uint32 , pixels unsafe . Pointer ) { syscall . Syscall12 ( gpTextureSubImage3D , 11 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func TextureView ( texture uint32 , target uint32 , origtexture uint32 , internalformat uint32 , minlevel uint32 , numlevels uint32 , minlayer uint32 , numlayers uint32 ) { syscall . Syscall9 ( gpTextureView , 8 , uintptr ( texture ) , uintptr ( target ) , uintptr ( origtexture ) , uintptr ( internalformat ) , uintptr ( minlevel ) , uintptr ( numlevels ) , uintptr ( minlayer ) , uintptr ( numlayers ) , 0 ) } 
func TransformFeedbackBufferBase ( xfb uint32 , index uint32 , buffer uint32 ) { syscall . Syscall ( gpTransformFeedbackBufferBase , 3 , uintptr ( xfb ) , uintptr ( index ) , uintptr ( buffer ) ) } 
func TransformFeedbackBufferRange ( xfb uint32 , index uint32 , buffer uint32 , offset int , size int ) { syscall . Syscall6 ( gpTransformFeedbackBufferRange , 5 , uintptr ( xfb ) , uintptr ( index ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func Uniform1f ( location int32 , v0 float32 ) { syscall . Syscall ( gpUniform1f , 2 , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , 0 ) } 
func Uniform1fv ( location int32 , count int32 , value * float32 ) { syscall . Syscall ( gpUniform1fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform1i ( location int32 , v0 int32 ) { syscall . Syscall ( gpUniform1i , 2 , uintptr ( location ) , uintptr ( v0 ) , 0 ) } 
func Uniform1iv ( location int32 , count int32 , value * int32 ) { syscall . Syscall ( gpUniform1iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform2f ( location int32 , v0 float32 , v1 float32 ) { syscall . Syscall ( gpUniform2f , 3 , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) ) } 
func Uniform2fv ( location int32 , count int32 , value * float32 ) { syscall . Syscall ( gpUniform2fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform2i ( location int32 , v0 int32 , v1 int32 ) { syscall . Syscall ( gpUniform2i , 3 , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) ) } 
func Uniform2iv ( location int32 , count int32 , value * int32 ) { syscall . Syscall ( gpUniform2iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform3f ( location int32 , v0 float32 , v1 float32 , v2 float32 ) { syscall . Syscall6 ( gpUniform3f , 4 , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) , uintptr ( math . Float32bits ( v2 ) ) , 0 , 0 ) } 
func Uniform3fv ( location int32 , count int32 , value * float32 ) { syscall . Syscall ( gpUniform3fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform3i ( location int32 , v0 int32 , v1 int32 , v2 int32 ) { syscall . Syscall6 ( gpUniform3i , 4 , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , 0 , 0 ) } 
func Uniform3iv ( location int32 , count int32 , value * int32 ) { syscall . Syscall ( gpUniform3iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform4f ( location int32 , v0 float32 , v1 float32 , v2 float32 , v3 float32 ) { syscall . Syscall6 ( gpUniform4f , 5 , uintptr ( location ) , uintptr ( math . Float32bits ( v0 ) ) , uintptr ( math . Float32bits ( v1 ) ) , uintptr ( math . Float32bits ( v2 ) ) , uintptr ( math . Float32bits ( v3 ) ) , 0 ) } 
func Uniform4fv ( location int32 , count int32 , value * float32 ) { syscall . Syscall ( gpUniform4fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform4i ( location int32 , v0 int32 , v1 int32 , v2 int32 , v3 int32 ) { syscall . Syscall6 ( gpUniform4i , 5 , uintptr ( location ) , uintptr ( v0 ) , uintptr ( v1 ) , uintptr ( v2 ) , uintptr ( v3 ) , 0 ) } 
func Uniform4iv ( location int32 , count int32 , value * int32 ) { syscall . Syscall ( gpUniform4iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func UniformBlockBinding ( program uint32 , uniformBlockIndex uint32 , uniformBlockBinding uint32 ) { syscall . Syscall ( gpUniformBlockBinding , 3 , uintptr ( program ) , uintptr ( uniformBlockIndex ) , uintptr ( uniformBlockBinding ) ) } 
func UniformMatrix2fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix2fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix2x3fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix2x3fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix2x4fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix2x4fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix3fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix3fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix3x2fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix3x2fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix3x4fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix3x4fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix4fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix4fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix4x2fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix4x2fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UniformMatrix4x3fv ( location int32 , count int32 , transpose bool , value * float32 ) { syscall . Syscall6 ( gpUniformMatrix4x3fv , 4 , uintptr ( location ) , uintptr ( count ) , boolToUintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func UnmapBuffer ( target uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpUnmapBuffer , 1 , uintptr ( target ) , 0 , 0 ) return ret != 0 } 
func UnmapNamedBuffer ( buffer uint32 ) bool { ret , _ , _ := syscall . Syscall ( gpUnmapNamedBuffer , 1 , uintptr ( buffer ) , 0 , 0 ) return ret != 0 } 
func UseProgramStages ( pipeline uint32 , stages uint32 , program uint32 ) { syscall . Syscall ( gpUseProgramStages , 3 , uintptr ( pipeline ) , uintptr ( stages ) , uintptr ( program ) ) } 
func VertexArrayAttribFormat ( vaobj uint32 , attribindex uint32 , size int32 , xtype uint32 , normalized bool , relativeoffset uint32 ) { syscall . Syscall6 ( gpVertexArrayAttribFormat , 6 , uintptr ( vaobj ) , uintptr ( attribindex ) , uintptr ( size ) , uintptr ( xtype ) , boolToUintptr ( normalized ) , uintptr ( relativeoffset ) ) } 
func VertexArrayBindingDivisor ( vaobj uint32 , bindingindex uint32 , divisor uint32 ) { syscall . Syscall ( gpVertexArrayBindingDivisor , 3 , uintptr ( vaobj ) , uintptr ( bindingindex ) , uintptr ( divisor ) ) } 
func VertexArrayElementBuffer ( vaobj uint32 , buffer uint32 ) { syscall . Syscall ( gpVertexArrayElementBuffer , 2 , uintptr ( vaobj ) , uintptr ( buffer ) , 0 ) } 
func VertexArrayVertexBuffer ( vaobj uint32 , bindingindex uint32 , buffer uint32 , offset int , stride int32 ) { syscall . Syscall6 ( gpVertexArrayVertexBuffer , 5 , uintptr ( vaobj ) , uintptr ( bindingindex ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( stride ) , 0 ) } 
func VertexArrayVertexBuffers ( vaobj uint32 , first uint32 , count int32 , buffers * uint32 , offsets * int , strides * int32 ) { syscall . Syscall6 ( gpVertexArrayVertexBuffers , 6 , uintptr ( vaobj ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( strides ) ) ) } 
func VertexAttribBinding ( attribindex uint32 , bindingindex uint32 ) { syscall . Syscall ( gpVertexAttribBinding , 2 , uintptr ( attribindex ) , uintptr ( bindingindex ) , 0 ) } 
func VertexAttribFormat ( attribindex uint32 , size int32 , xtype uint32 , normalized bool , relativeoffset uint32 ) { syscall . Syscall6 ( gpVertexAttribFormat , 5 , uintptr ( attribindex ) , uintptr ( size ) , uintptr ( xtype ) , boolToUintptr ( normalized ) , uintptr ( relativeoffset ) , 0 ) } 
func VertexAttribPointer ( index uint32 , size int32 , xtype uint32 , normalized bool , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall6 ( gpVertexAttribPointer , 6 , uintptr ( index ) , uintptr ( size ) , uintptr ( xtype ) , boolToUintptr ( normalized ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func VertexBindingDivisor ( bindingindex uint32 , divisor uint32 ) { syscall . Syscall ( gpVertexBindingDivisor , 2 , uintptr ( bindingindex ) , uintptr ( divisor ) , 0 ) } 
func VertexPointer ( size int32 , xtype uint32 , stride int32 , pointer unsafe . Pointer ) { syscall . Syscall6 ( gpVertexPointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func Viewport ( x int32 , y int32 , width int32 , height int32 ) { syscall . Syscall6 ( gpViewport , 4 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func WaitSync ( sync uintptr , flags uint32 , timeout uint64 ) { syscall . Syscall ( gpWaitSync , 3 , uintptr ( sync ) , uintptr ( flags ) , uintptr ( timeout ) ) } 
func InitWithProcAddrFunc ( getProcAddr func ( name string ) unsafe . Pointer ) error { gpAccum = uintptr ( getProcAddr ( " " ) ) if gpAccum == 0 { return errors . New ( " " ) } gpAccumxOES = uintptr ( getProcAddr ( " " ) ) gpAcquireKeyedMutexWin32EXT = uintptr ( getProcAddr ( " " ) ) gpActiveProgramEXT = uintptr ( getProcAddr ( " " ) ) gpActiveShaderProgram = uintptr ( getProcAddr ( " " ) ) gpActiveShaderProgramEXT = uintptr ( getProcAddr ( " " ) ) gpActiveStencilFaceEXT = uintptr ( getProcAddr ( " " ) ) gpActiveTexture = uintptr ( getProcAddr ( " " ) ) if gpActiveTexture == 0 { return errors . New ( " " ) } gpActiveTextureARB = uintptr ( getProcAddr ( " " ) ) gpActiveVaryingNV = uintptr ( getProcAddr ( " " ) ) gpAlphaFragmentOp1ATI = uintptr ( getProcAddr ( " " ) ) gpAlphaFragmentOp2ATI = uintptr ( getProcAddr ( " " ) ) gpAlphaFragmentOp3ATI = uintptr ( getProcAddr ( " " ) ) gpAlphaFunc = uintptr ( getProcAddr ( " " ) ) if gpAlphaFunc == 0 { return errors . New ( " " ) } gpAlphaFuncxOES = uintptr ( getProcAddr ( " " ) ) gpAlphaToCoverageDitherControlNV = uintptr ( getProcAddr ( " " ) ) gpApplyFramebufferAttachmentCMAAINTEL = uintptr ( getProcAddr ( " " ) ) gpApplyTextureEXT = uintptr ( getProcAddr ( " " ) ) gpAreProgramsResidentNV = uintptr ( getProcAddr ( " " ) ) gpAreTexturesResident = uintptr ( getProcAddr ( " " ) ) if gpAreTexturesResident == 0 { return errors . New ( " " ) } gpAreTexturesResidentEXT = uintptr ( getProcAddr ( " " ) ) gpArrayElement = uintptr ( getProcAddr ( " " ) ) if gpArrayElement == 0 { return errors . New ( " " ) } gpArrayElementEXT = uintptr ( getProcAddr ( " " ) ) gpArrayObjectATI = uintptr ( getProcAddr ( " " ) ) gpAsyncMarkerSGIX = uintptr ( getProcAddr ( " " ) ) gpAttachObjectARB = uintptr ( getProcAddr ( " " ) ) gpAttachShader = uintptr ( getProcAddr ( " " ) ) if gpAttachShader == 0 { return errors . New ( " " ) } gpBegin = uintptr ( getProcAddr ( " " ) ) if gpBegin == 0 { return errors . New ( " " ) } gpBeginConditionalRenderNV = uintptr ( getProcAddr ( " " ) ) gpBeginConditionalRenderNVX = uintptr ( getProcAddr ( " " ) ) gpBeginFragmentShaderATI = uintptr ( getProcAddr ( " " ) ) gpBeginOcclusionQueryNV = uintptr ( getProcAddr ( " " ) ) gpBeginPerfMonitorAMD = uintptr ( getProcAddr ( " " ) ) gpBeginPerfQueryINTEL = uintptr ( getProcAddr ( " " ) ) gpBeginQuery = uintptr ( getProcAddr ( " " ) ) if gpBeginQuery == 0 { return errors . New ( " " ) } gpBeginQueryARB = uintptr ( getProcAddr ( " " ) ) gpBeginQueryIndexed = uintptr ( getProcAddr ( " " ) ) gpBeginTransformFeedbackEXT = uintptr ( getProcAddr ( " " ) ) gpBeginTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpBeginVertexShaderEXT = uintptr ( getProcAddr ( " " ) ) gpBeginVideoCaptureNV = uintptr ( getProcAddr ( " " ) ) gpBindAttribLocation = uintptr ( getProcAddr ( " " ) ) if gpBindAttribLocation == 0 { return errors . New ( " " ) } gpBindAttribLocationARB = uintptr ( getProcAddr ( " " ) ) gpBindBuffer = uintptr ( getProcAddr ( " " ) ) if gpBindBuffer == 0 { return errors . New ( " " ) } gpBindBufferARB = uintptr ( getProcAddr ( " " ) ) gpBindBufferBase = uintptr ( getProcAddr ( " " ) ) gpBindBufferBaseEXT = uintptr ( getProcAddr ( " " ) ) gpBindBufferBaseNV = uintptr ( getProcAddr ( " " ) ) gpBindBufferOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpBindBufferOffsetNV = uintptr ( getProcAddr ( " " ) ) gpBindBufferRange = uintptr ( getProcAddr ( " " ) ) gpBindBufferRangeEXT = uintptr ( getProcAddr ( " " ) ) gpBindBufferRangeNV = uintptr ( getProcAddr ( " " ) ) gpBindBuffersBase = uintptr ( getProcAddr ( " " ) ) gpBindBuffersRange = uintptr ( getProcAddr ( " " ) ) gpBindFragDataLocationEXT = uintptr ( getProcAddr ( " " ) ) gpBindFragDataLocationIndexed = uintptr ( getProcAddr ( " " ) ) gpBindFragmentShaderATI = uintptr ( getProcAddr ( " " ) ) gpBindFramebuffer = uintptr ( getProcAddr ( " " ) ) gpBindFramebufferEXT = uintptr ( getProcAddr ( " " ) ) gpBindImageTexture = uintptr ( getProcAddr ( " " ) ) gpBindImageTextureEXT = uintptr ( getProcAddr ( " " ) ) gpBindImageTextures = uintptr ( getProcAddr ( " " ) ) gpBindLightParameterEXT = uintptr ( getProcAddr ( " " ) ) gpBindMaterialParameterEXT = uintptr ( getProcAddr ( " " ) ) gpBindMultiTextureEXT = uintptr ( getProcAddr ( " " ) ) gpBindParameterEXT = uintptr ( getProcAddr ( " " ) ) gpBindProgramARB = uintptr ( getProcAddr ( " " ) ) gpBindProgramNV = uintptr ( getProcAddr ( " " ) ) gpBindProgramPipeline = uintptr ( getProcAddr ( " " ) ) gpBindProgramPipelineEXT = uintptr ( getProcAddr ( " " ) ) gpBindRenderbuffer = uintptr ( getProcAddr ( " " ) ) gpBindRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpBindSampler = uintptr ( getProcAddr ( " " ) ) gpBindSamplers = uintptr ( getProcAddr ( " " ) ) gpBindTexGenParameterEXT = uintptr ( getProcAddr ( " " ) ) gpBindTexture = uintptr ( getProcAddr ( " " ) ) if gpBindTexture == 0 { return errors . New ( " " ) } gpBindTextureEXT = uintptr ( getProcAddr ( " " ) ) gpBindTextureUnit = uintptr ( getProcAddr ( " " ) ) gpBindTextureUnitParameterEXT = uintptr ( getProcAddr ( " " ) ) gpBindTextures = uintptr ( getProcAddr ( " " ) ) gpBindTransformFeedback = uintptr ( getProcAddr ( " " ) ) gpBindTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpBindVertexArray = uintptr ( getProcAddr ( " " ) ) gpBindVertexArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpBindVertexBuffer = uintptr ( getProcAddr ( " " ) ) gpBindVertexBuffers = uintptr ( getProcAddr ( " " ) ) gpBindVertexShaderEXT = uintptr ( getProcAddr ( " " ) ) gpBindVideoCaptureStreamBufferNV = uintptr ( getProcAddr ( " " ) ) gpBindVideoCaptureStreamTextureNV = uintptr ( getProcAddr ( " " ) ) gpBinormal3bEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3bvEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3dEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3dvEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3fEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3fvEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3iEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3ivEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3sEXT = uintptr ( getProcAddr ( " " ) ) gpBinormal3svEXT = uintptr ( getProcAddr ( " " ) ) gpBinormalPointerEXT = uintptr ( getProcAddr ( " " ) ) gpBitmap = uintptr ( getProcAddr ( " " ) ) if gpBitmap == 0 { return errors . New ( " " ) } gpBitmapxOES = uintptr ( getProcAddr ( " " ) ) gpBlendBarrierKHR = uintptr ( getProcAddr ( " " ) ) gpBlendBarrierNV = uintptr ( getProcAddr ( " " ) ) gpBlendColor = uintptr ( getProcAddr ( " " ) ) if gpBlendColor == 0 { return errors . New ( " " ) } gpBlendColorEXT = uintptr ( getProcAddr ( " " ) ) gpBlendColorxOES = uintptr ( getProcAddr ( " " ) ) gpBlendEquation = uintptr ( getProcAddr ( " " ) ) if gpBlendEquation == 0 { return errors . New ( " " ) } gpBlendEquationEXT = uintptr ( getProcAddr ( " " ) ) gpBlendEquationIndexedAMD = uintptr ( getProcAddr ( " " ) ) gpBlendEquationSeparate = uintptr ( getProcAddr ( " " ) ) if gpBlendEquationSeparate == 0 { return errors . New ( " " ) } gpBlendEquationSeparateEXT = uintptr ( getProcAddr ( " " ) ) gpBlendEquationSeparateIndexedAMD = uintptr ( getProcAddr ( " " ) ) gpBlendEquationSeparateiARB = uintptr ( getProcAddr ( " " ) ) gpBlendEquationiARB = uintptr ( getProcAddr ( " " ) ) gpBlendFunc = uintptr ( getProcAddr ( " " ) ) if gpBlendFunc == 0 { return errors . New ( " " ) } gpBlendFuncIndexedAMD = uintptr ( getProcAddr ( " " ) ) gpBlendFuncSeparate = uintptr ( getProcAddr ( " " ) ) if gpBlendFuncSeparate == 0 { return errors . New ( " " ) } gpBlendFuncSeparateEXT = uintptr ( getProcAddr ( " " ) ) gpBlendFuncSeparateINGR = uintptr ( getProcAddr ( " " ) ) gpBlendFuncSeparateIndexedAMD = uintptr ( getProcAddr ( " " ) ) gpBlendFuncSeparateiARB = uintptr ( getProcAddr ( " " ) ) gpBlendFunciARB = uintptr ( getProcAddr ( " " ) ) gpBlendParameteriNV = uintptr ( getProcAddr ( " " ) ) gpBlitFramebuffer = uintptr ( getProcAddr ( " " ) ) gpBlitFramebufferEXT = uintptr ( getProcAddr ( " " ) ) gpBlitNamedFramebuffer = uintptr ( getProcAddr ( " " ) ) gpBufferAddressRangeNV = uintptr ( getProcAddr ( " " ) ) gpBufferData = uintptr ( getProcAddr ( " " ) ) if gpBufferData == 0 { return errors . New ( " " ) } gpBufferDataARB = uintptr ( getProcAddr ( " " ) ) gpBufferPageCommitmentARB = uintptr ( getProcAddr ( " " ) ) gpBufferParameteriAPPLE = uintptr ( getProcAddr ( " " ) ) gpBufferStorage = uintptr ( getProcAddr ( " " ) ) gpBufferStorageExternalEXT = uintptr ( getProcAddr ( " " ) ) gpBufferStorageMemEXT = uintptr ( getProcAddr ( " " ) ) gpBufferSubData = uintptr ( getProcAddr ( " " ) ) if gpBufferSubData == 0 { return errors . New ( " " ) } gpBufferSubDataARB = uintptr ( getProcAddr ( " " ) ) gpCallCommandListNV = uintptr ( getProcAddr ( " " ) ) gpCallList = uintptr ( getProcAddr ( " " ) ) if gpCallList == 0 { return errors . New ( " " ) } gpCallLists = uintptr ( getProcAddr ( " " ) ) if gpCallLists == 0 { return errors . New ( " " ) } gpCheckFramebufferStatus = uintptr ( getProcAddr ( " " ) ) gpCheckFramebufferStatusEXT = uintptr ( getProcAddr ( " " ) ) gpCheckNamedFramebufferStatus = uintptr ( getProcAddr ( " " ) ) gpCheckNamedFramebufferStatusEXT = uintptr ( getProcAddr ( " " ) ) gpClampColorARB = uintptr ( getProcAddr ( " " ) ) gpClear = uintptr ( getProcAddr ( " " ) ) if gpClear == 0 { return errors . New ( " " ) } gpClearAccum = uintptr ( getProcAddr ( " " ) ) if gpClearAccum == 0 { return errors . New ( " " ) } gpClearAccumxOES = uintptr ( getProcAddr ( " " ) ) gpClearBufferData = uintptr ( getProcAddr ( " " ) ) gpClearBufferSubData = uintptr ( getProcAddr ( " " ) ) gpClearColor = uintptr ( getProcAddr ( " " ) ) if gpClearColor == 0 { return errors . New ( " " ) } gpClearColorIiEXT = uintptr ( getProcAddr ( " " ) ) gpClearColorIuiEXT = uintptr ( getProcAddr ( " " ) ) gpClearColorxOES = uintptr ( getProcAddr ( " " ) ) gpClearDepth = uintptr ( getProcAddr ( " " ) ) if gpClearDepth == 0 { return errors . New ( " " ) } gpClearDepthdNV = uintptr ( getProcAddr ( " " ) ) gpClearDepthf = uintptr ( getProcAddr ( " " ) ) gpClearDepthfOES = uintptr ( getProcAddr ( " " ) ) gpClearDepthxOES = uintptr ( getProcAddr ( " " ) ) gpClearIndex = uintptr ( getProcAddr ( " " ) ) if gpClearIndex == 0 { return errors . New ( " " ) } gpClearNamedBufferData = uintptr ( getProcAddr ( " " ) ) gpClearNamedBufferDataEXT = uintptr ( getProcAddr ( " " ) ) gpClearNamedBufferSubData = uintptr ( getProcAddr ( " " ) ) gpClearNamedBufferSubDataEXT = uintptr ( getProcAddr ( " " ) ) gpClearNamedFramebufferfi = uintptr ( getProcAddr ( " " ) ) gpClearNamedFramebufferfv = uintptr ( getProcAddr ( " " ) ) gpClearNamedFramebufferiv = uintptr ( getProcAddr ( " " ) ) gpClearNamedFramebufferuiv = uintptr ( getProcAddr ( " " ) ) gpClearStencil = uintptr ( getProcAddr ( " " ) ) if gpClearStencil == 0 { return errors . New ( " " ) } gpClearTexImage = uintptr ( getProcAddr ( " " ) ) gpClearTexSubImage = uintptr ( getProcAddr ( " " ) ) gpClientActiveTexture = uintptr ( getProcAddr ( " " ) ) if gpClientActiveTexture == 0 { return errors . New ( " " ) } gpClientActiveTextureARB = uintptr ( getProcAddr ( " " ) ) gpClientActiveVertexStreamATI = uintptr ( getProcAddr ( " " ) ) gpClientAttribDefaultEXT = uintptr ( getProcAddr ( " " ) ) gpClientWaitSync = uintptr ( getProcAddr ( " " ) ) gpClipControl = uintptr ( getProcAddr ( " " ) ) gpClipPlane = uintptr ( getProcAddr ( " " ) ) if gpClipPlane == 0 { return errors . New ( " " ) } gpClipPlanefOES = uintptr ( getProcAddr ( " " ) ) gpClipPlanexOES = uintptr ( getProcAddr ( " " ) ) gpColor3b = uintptr ( getProcAddr ( " " ) ) if gpColor3b == 0 { return errors . New ( " " ) } gpColor3bv = uintptr ( getProcAddr ( " " ) ) if gpColor3bv == 0 { return errors . New ( " " ) } gpColor3d = uintptr ( getProcAddr ( " " ) ) if gpColor3d == 0 { return errors . New ( " " ) } gpColor3dv = uintptr ( getProcAddr ( " " ) ) if gpColor3dv == 0 { return errors . New ( " " ) } gpColor3f = uintptr ( getProcAddr ( " " ) ) if gpColor3f == 0 { return errors . New ( " " ) } gpColor3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpColor3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpColor3fv = uintptr ( getProcAddr ( " " ) ) if gpColor3fv == 0 { return errors . New ( " " ) } gpColor3hNV = uintptr ( getProcAddr ( " " ) ) gpColor3hvNV = uintptr ( getProcAddr ( " " ) ) gpColor3i = uintptr ( getProcAddr ( " " ) ) if gpColor3i == 0 { return errors . New ( " " ) } gpColor3iv = uintptr ( getProcAddr ( " " ) ) if gpColor3iv == 0 { return errors . New ( " " ) } gpColor3s = uintptr ( getProcAddr ( " " ) ) if gpColor3s == 0 { return errors . New ( " " ) } gpColor3sv = uintptr ( getProcAddr ( " " ) ) if gpColor3sv == 0 { return errors . New ( " " ) } gpColor3ub = uintptr ( getProcAddr ( " " ) ) if gpColor3ub == 0 { return errors . New ( " " ) } gpColor3ubv = uintptr ( getProcAddr ( " " ) ) if gpColor3ubv == 0 { return errors . New ( " " ) } gpColor3ui = uintptr ( getProcAddr ( " " ) ) if gpColor3ui == 0 { return errors . New ( " " ) } gpColor3uiv = uintptr ( getProcAddr ( " " ) ) if gpColor3uiv == 0 { return errors . New ( " " ) } gpColor3us = uintptr ( getProcAddr ( " " ) ) if gpColor3us == 0 { return errors . New ( " " ) } gpColor3usv = uintptr ( getProcAddr ( " " ) ) if gpColor3usv == 0 { return errors . New ( " " ) } gpColor3xOES = uintptr ( getProcAddr ( " " ) ) gpColor3xvOES = uintptr ( getProcAddr ( " " ) ) gpColor4b = uintptr ( getProcAddr ( " " ) ) if gpColor4b == 0 { return errors . New ( " " ) } gpColor4bv = uintptr ( getProcAddr ( " " ) ) if gpColor4bv == 0 { return errors . New ( " " ) } gpColor4d = uintptr ( getProcAddr ( " " ) ) if gpColor4d == 0 { return errors . New ( " " ) } gpColor4dv = uintptr ( getProcAddr ( " " ) ) if gpColor4dv == 0 { return errors . New ( " " ) } gpColor4f = uintptr ( getProcAddr ( " " ) ) if gpColor4f == 0 { return errors . New ( " " ) } gpColor4fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpColor4fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpColor4fv = uintptr ( getProcAddr ( " " ) ) if gpColor4fv == 0 { return errors . New ( " " ) } gpColor4hNV = uintptr ( getProcAddr ( " " ) ) gpColor4hvNV = uintptr ( getProcAddr ( " " ) ) gpColor4i = uintptr ( getProcAddr ( " " ) ) if gpColor4i == 0 { return errors . New ( " " ) } gpColor4iv = uintptr ( getProcAddr ( " " ) ) if gpColor4iv == 0 { return errors . New ( " " ) } gpColor4s = uintptr ( getProcAddr ( " " ) ) if gpColor4s == 0 { return errors . New ( " " ) } gpColor4sv = uintptr ( getProcAddr ( " " ) ) if gpColor4sv == 0 { return errors . New ( " " ) } gpColor4ub = uintptr ( getProcAddr ( " " ) ) if gpColor4ub == 0 { return errors . New ( " " ) } gpColor4ubVertex2fSUN = uintptr ( getProcAddr ( " " ) ) gpColor4ubVertex2fvSUN = uintptr ( getProcAddr ( " " ) ) gpColor4ubVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpColor4ubVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpColor4ubv = uintptr ( getProcAddr ( " " ) ) if gpColor4ubv == 0 { return errors . New ( " " ) } gpColor4ui = uintptr ( getProcAddr ( " " ) ) if gpColor4ui == 0 { return errors . New ( " " ) } gpColor4uiv = uintptr ( getProcAddr ( " " ) ) if gpColor4uiv == 0 { return errors . New ( " " ) } gpColor4us = uintptr ( getProcAddr ( " " ) ) if gpColor4us == 0 { return errors . New ( " " ) } gpColor4usv = uintptr ( getProcAddr ( " " ) ) if gpColor4usv == 0 { return errors . New ( " " ) } gpColor4xOES = uintptr ( getProcAddr ( " " ) ) gpColor4xvOES = uintptr ( getProcAddr ( " " ) ) gpColorFormatNV = uintptr ( getProcAddr ( " " ) ) gpColorFragmentOp1ATI = uintptr ( getProcAddr ( " " ) ) gpColorFragmentOp2ATI = uintptr ( getProcAddr ( " " ) ) gpColorFragmentOp3ATI = uintptr ( getProcAddr ( " " ) ) gpColorMask = uintptr ( getProcAddr ( " " ) ) if gpColorMask == 0 { return errors . New ( " " ) } gpColorMaskIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpColorMaterial = uintptr ( getProcAddr ( " " ) ) if gpColorMaterial == 0 { return errors . New ( " " ) } gpColorPointer = uintptr ( getProcAddr ( " " ) ) if gpColorPointer == 0 { return errors . New ( " " ) } gpColorPointerEXT = uintptr ( getProcAddr ( " " ) ) gpColorPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpColorPointervINTEL = uintptr ( getProcAddr ( " " ) ) gpColorSubTableEXT = uintptr ( getProcAddr ( " " ) ) gpColorTableEXT = uintptr ( getProcAddr ( " " ) ) gpColorTableParameterfvSGI = uintptr ( getProcAddr ( " " ) ) gpColorTableParameterivSGI = uintptr ( getProcAddr ( " " ) ) gpColorTableSGI = uintptr ( getProcAddr ( " " ) ) gpCombinerInputNV = uintptr ( getProcAddr ( " " ) ) gpCombinerOutputNV = uintptr ( getProcAddr ( " " ) ) gpCombinerParameterfNV = uintptr ( getProcAddr ( " " ) ) gpCombinerParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpCombinerParameteriNV = uintptr ( getProcAddr ( " " ) ) gpCombinerParameterivNV = uintptr ( getProcAddr ( " " ) ) gpCombinerStageParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpCommandListSegmentsNV = uintptr ( getProcAddr ( " " ) ) gpCompileCommandListNV = uintptr ( getProcAddr ( " " ) ) gpCompileShader = uintptr ( getProcAddr ( " " ) ) if gpCompileShader == 0 { return errors . New ( " " ) } gpCompileShaderARB = uintptr ( getProcAddr ( " " ) ) gpCompileShaderIncludeARB = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedMultiTexSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTexImage1D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexImage1D == 0 { return errors . New ( " " ) } gpCompressedTexImage1DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTexImage2D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexImage2D == 0 { return errors . New ( " " ) } gpCompressedTexImage2DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTexImage3D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexImage3D == 0 { return errors . New ( " " ) } gpCompressedTexImage3DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTexSubImage1D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexSubImage1D == 0 { return errors . New ( " " ) } gpCompressedTexSubImage1DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTexSubImage2D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexSubImage2D == 0 { return errors . New ( " " ) } gpCompressedTexSubImage2DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTexSubImage3D = uintptr ( getProcAddr ( " " ) ) if gpCompressedTexSubImage3D == 0 { return errors . New ( " " ) } gpCompressedTexSubImage3DARB = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage1D = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage2D = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage3D = uintptr ( getProcAddr ( " " ) ) gpCompressedTextureSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpConservativeRasterParameterfNV = uintptr ( getProcAddr ( " " ) ) gpConservativeRasterParameteriNV = uintptr ( getProcAddr ( " " ) ) gpConvolutionFilter1DEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionFilter2DEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameterfEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameterxOES = uintptr ( getProcAddr ( " " ) ) gpConvolutionParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpCopyBufferSubData = uintptr ( getProcAddr ( " " ) ) gpCopyColorSubTableEXT = uintptr ( getProcAddr ( " " ) ) gpCopyColorTableSGI = uintptr ( getProcAddr ( " " ) ) gpCopyConvolutionFilter1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyConvolutionFilter2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyImageSubData = uintptr ( getProcAddr ( " " ) ) gpCopyImageSubDataNV = uintptr ( getProcAddr ( " " ) ) gpCopyMultiTexImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyMultiTexImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyMultiTexSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyMultiTexSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyMultiTexSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyNamedBufferSubData = uintptr ( getProcAddr ( " " ) ) gpCopyPathNV = uintptr ( getProcAddr ( " " ) ) gpCopyPixels = uintptr ( getProcAddr ( " " ) ) if gpCopyPixels == 0 { return errors . New ( " " ) } gpCopyTexImage1D = uintptr ( getProcAddr ( " " ) ) if gpCopyTexImage1D == 0 { return errors . New ( " " ) } gpCopyTexImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTexImage2D = uintptr ( getProcAddr ( " " ) ) if gpCopyTexImage2D == 0 { return errors . New ( " " ) } gpCopyTexImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTexSubImage1D = uintptr ( getProcAddr ( " " ) ) if gpCopyTexSubImage1D == 0 { return errors . New ( " " ) } gpCopyTexSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTexSubImage2D = uintptr ( getProcAddr ( " " ) ) if gpCopyTexSubImage2D == 0 { return errors . New ( " " ) } gpCopyTexSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTexSubImage3D = uintptr ( getProcAddr ( " " ) ) if gpCopyTexSubImage3D == 0 { return errors . New ( " " ) } gpCopyTexSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTextureImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTextureImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage1D = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage2D = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage3D = uintptr ( getProcAddr ( " " ) ) gpCopyTextureSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpCoverFillPathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpCoverFillPathNV = uintptr ( getProcAddr ( " " ) ) gpCoverStrokePathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpCoverStrokePathNV = uintptr ( getProcAddr ( " " ) ) gpCoverageModulationNV = uintptr ( getProcAddr ( " " ) ) gpCoverageModulationTableNV = uintptr ( getProcAddr ( " " ) ) gpCreateBuffers = uintptr ( getProcAddr ( " " ) ) gpCreateCommandListsNV = uintptr ( getProcAddr ( " " ) ) gpCreateFramebuffers = uintptr ( getProcAddr ( " " ) ) gpCreateMemoryObjectsEXT = uintptr ( getProcAddr ( " " ) ) gpCreatePerfQueryINTEL = uintptr ( getProcAddr ( " " ) ) gpCreateProgram = uintptr ( getProcAddr ( " " ) ) if gpCreateProgram == 0 { return errors . New ( " " ) } gpCreateProgramObjectARB = uintptr ( getProcAddr ( " " ) ) gpCreateProgramPipelines = uintptr ( getProcAddr ( " " ) ) gpCreateQueries = uintptr ( getProcAddr ( " " ) ) gpCreateRenderbuffers = uintptr ( getProcAddr ( " " ) ) gpCreateSamplers = uintptr ( getProcAddr ( " " ) ) gpCreateShader = uintptr ( getProcAddr ( " " ) ) if gpCreateShader == 0 { return errors . New ( " " ) } gpCreateShaderObjectARB = uintptr ( getProcAddr ( " " ) ) gpCreateShaderProgramEXT = uintptr ( getProcAddr ( " " ) ) gpCreateShaderProgramv = uintptr ( getProcAddr ( " " ) ) gpCreateShaderProgramvEXT = uintptr ( getProcAddr ( " " ) ) gpCreateStatesNV = uintptr ( getProcAddr ( " " ) ) gpCreateSyncFromCLeventARB = uintptr ( getProcAddr ( " " ) ) gpCreateTextures = uintptr ( getProcAddr ( " " ) ) gpCreateTransformFeedbacks = uintptr ( getProcAddr ( " " ) ) gpCreateVertexArrays = uintptr ( getProcAddr ( " " ) ) gpCullFace = uintptr ( getProcAddr ( " " ) ) if gpCullFace == 0 { return errors . New ( " " ) } gpCullParameterdvEXT = uintptr ( getProcAddr ( " " ) ) gpCullParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpCurrentPaletteMatrixARB = uintptr ( getProcAddr ( " " ) ) gpDebugMessageCallback = uintptr ( getProcAddr ( " " ) ) gpDebugMessageCallbackAMD = uintptr ( getProcAddr ( " " ) ) gpDebugMessageCallbackARB = uintptr ( getProcAddr ( " " ) ) gpDebugMessageCallbackKHR = uintptr ( getProcAddr ( " " ) ) gpDebugMessageControl = uintptr ( getProcAddr ( " " ) ) gpDebugMessageControlARB = uintptr ( getProcAddr ( " " ) ) gpDebugMessageControlKHR = uintptr ( getProcAddr ( " " ) ) gpDebugMessageEnableAMD = uintptr ( getProcAddr ( " " ) ) gpDebugMessageInsert = uintptr ( getProcAddr ( " " ) ) gpDebugMessageInsertAMD = uintptr ( getProcAddr ( " " ) ) gpDebugMessageInsertARB = uintptr ( getProcAddr ( " " ) ) gpDebugMessageInsertKHR = uintptr ( getProcAddr ( " " ) ) gpDeformSGIX = uintptr ( getProcAddr ( " " ) ) gpDeformationMap3dSGIX = uintptr ( getProcAddr ( " " ) ) gpDeformationMap3fSGIX = uintptr ( getProcAddr ( " " ) ) gpDeleteAsyncMarkersSGIX = uintptr ( getProcAddr ( " " ) ) gpDeleteBuffers = uintptr ( getProcAddr ( " " ) ) if gpDeleteBuffers == 0 { return errors . New ( " " ) } gpDeleteBuffersARB = uintptr ( getProcAddr ( " " ) ) gpDeleteCommandListsNV = uintptr ( getProcAddr ( " " ) ) gpDeleteFencesAPPLE = uintptr ( getProcAddr ( " " ) ) gpDeleteFencesNV = uintptr ( getProcAddr ( " " ) ) gpDeleteFragmentShaderATI = uintptr ( getProcAddr ( " " ) ) gpDeleteFramebuffers = uintptr ( getProcAddr ( " " ) ) gpDeleteFramebuffersEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteLists = uintptr ( getProcAddr ( " " ) ) if gpDeleteLists == 0 { return errors . New ( " " ) } gpDeleteMemoryObjectsEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteNamedStringARB = uintptr ( getProcAddr ( " " ) ) gpDeleteNamesAMD = uintptr ( getProcAddr ( " " ) ) gpDeleteObjectARB = uintptr ( getProcAddr ( " " ) ) gpDeleteOcclusionQueriesNV = uintptr ( getProcAddr ( " " ) ) gpDeletePathsNV = uintptr ( getProcAddr ( " " ) ) gpDeletePerfMonitorsAMD = uintptr ( getProcAddr ( " " ) ) gpDeletePerfQueryINTEL = uintptr ( getProcAddr ( " " ) ) gpDeleteProgram = uintptr ( getProcAddr ( " " ) ) if gpDeleteProgram == 0 { return errors . New ( " " ) } gpDeleteProgramPipelines = uintptr ( getProcAddr ( " " ) ) gpDeleteProgramPipelinesEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteProgramsARB = uintptr ( getProcAddr ( " " ) ) gpDeleteProgramsNV = uintptr ( getProcAddr ( " " ) ) gpDeleteQueries = uintptr ( getProcAddr ( " " ) ) if gpDeleteQueries == 0 { return errors . New ( " " ) } gpDeleteQueriesARB = uintptr ( getProcAddr ( " " ) ) gpDeleteQueryResourceTagNV = uintptr ( getProcAddr ( " " ) ) gpDeleteRenderbuffers = uintptr ( getProcAddr ( " " ) ) gpDeleteRenderbuffersEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteSamplers = uintptr ( getProcAddr ( " " ) ) gpDeleteSemaphoresEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteShader = uintptr ( getProcAddr ( " " ) ) if gpDeleteShader == 0 { return errors . New ( " " ) } gpDeleteStatesNV = uintptr ( getProcAddr ( " " ) ) gpDeleteSync = uintptr ( getProcAddr ( " " ) ) gpDeleteTextures = uintptr ( getProcAddr ( " " ) ) if gpDeleteTextures == 0 { return errors . New ( " " ) } gpDeleteTexturesEXT = uintptr ( getProcAddr ( " " ) ) gpDeleteTransformFeedbacks = uintptr ( getProcAddr ( " " ) ) gpDeleteTransformFeedbacksNV = uintptr ( getProcAddr ( " " ) ) gpDeleteVertexArrays = uintptr ( getProcAddr ( " " ) ) gpDeleteVertexArraysAPPLE = uintptr ( getProcAddr ( " " ) ) gpDeleteVertexShaderEXT = uintptr ( getProcAddr ( " " ) ) gpDepthBoundsEXT = uintptr ( getProcAddr ( " " ) ) gpDepthBoundsdNV = uintptr ( getProcAddr ( " " ) ) gpDepthFunc = uintptr ( getProcAddr ( " " ) ) if gpDepthFunc == 0 { return errors . New ( " " ) } gpDepthMask = uintptr ( getProcAddr ( " " ) ) if gpDepthMask == 0 { return errors . New ( " " ) } gpDepthRange = uintptr ( getProcAddr ( " " ) ) if gpDepthRange == 0 { return errors . New ( " " ) } gpDepthRangeArrayv = uintptr ( getProcAddr ( " " ) ) gpDepthRangeIndexed = uintptr ( getProcAddr ( " " ) ) gpDepthRangedNV = uintptr ( getProcAddr ( " " ) ) gpDepthRangef = uintptr ( getProcAddr ( " " ) ) gpDepthRangefOES = uintptr ( getProcAddr ( " " ) ) gpDepthRangexOES = uintptr ( getProcAddr ( " " ) ) gpDetachObjectARB = uintptr ( getProcAddr ( " " ) ) gpDetachShader = uintptr ( getProcAddr ( " " ) ) if gpDetachShader == 0 { return errors . New ( " " ) } gpDetailTexFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpDisable = uintptr ( getProcAddr ( " " ) ) if gpDisable == 0 { return errors . New ( " " ) } gpDisableClientState = uintptr ( getProcAddr ( " " ) ) if gpDisableClientState == 0 { return errors . New ( " " ) } gpDisableClientStateIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpDisableClientStateiEXT = uintptr ( getProcAddr ( " " ) ) gpDisableIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpDisableVariantClientStateEXT = uintptr ( getProcAddr ( " " ) ) gpDisableVertexArrayAttrib = uintptr ( getProcAddr ( " " ) ) gpDisableVertexArrayAttribEXT = uintptr ( getProcAddr ( " " ) ) gpDisableVertexArrayEXT = uintptr ( getProcAddr ( " " ) ) gpDisableVertexAttribAPPLE = uintptr ( getProcAddr ( " " ) ) gpDisableVertexAttribArray = uintptr ( getProcAddr ( " " ) ) if gpDisableVertexAttribArray == 0 { return errors . New ( " " ) } gpDisableVertexAttribArrayARB = uintptr ( getProcAddr ( " " ) ) gpDispatchCompute = uintptr ( getProcAddr ( " " ) ) gpDispatchComputeGroupSizeARB = uintptr ( getProcAddr ( " " ) ) gpDispatchComputeIndirect = uintptr ( getProcAddr ( " " ) ) gpDrawArrays = uintptr ( getProcAddr ( " " ) ) if gpDrawArrays == 0 { return errors . New ( " " ) } gpDrawArraysEXT = uintptr ( getProcAddr ( " " ) ) gpDrawArraysIndirect = uintptr ( getProcAddr ( " " ) ) gpDrawArraysInstancedARB = uintptr ( getProcAddr ( " " ) ) gpDrawArraysInstancedBaseInstance = uintptr ( getProcAddr ( " " ) ) gpDrawArraysInstancedEXT = uintptr ( getProcAddr ( " " ) ) gpDrawBuffer = uintptr ( getProcAddr ( " " ) ) if gpDrawBuffer == 0 { return errors . New ( " " ) } gpDrawBuffers = uintptr ( getProcAddr ( " " ) ) if gpDrawBuffers == 0 { return errors . New ( " " ) } gpDrawBuffersARB = uintptr ( getProcAddr ( " " ) ) gpDrawBuffersATI = uintptr ( getProcAddr ( " " ) ) gpDrawCommandsAddressNV = uintptr ( getProcAddr ( " " ) ) gpDrawCommandsNV = uintptr ( getProcAddr ( " " ) ) gpDrawCommandsStatesAddressNV = uintptr ( getProcAddr ( " " ) ) gpDrawCommandsStatesNV = uintptr ( getProcAddr ( " " ) ) gpDrawElementArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpDrawElementArrayATI = uintptr ( getProcAddr ( " " ) ) gpDrawElements = uintptr ( getProcAddr ( " " ) ) if gpDrawElements == 0 { return errors . New ( " " ) } gpDrawElementsBaseVertex = uintptr ( getProcAddr ( " " ) ) gpDrawElementsIndirect = uintptr ( getProcAddr ( " " ) ) gpDrawElementsInstancedARB = uintptr ( getProcAddr ( " " ) ) gpDrawElementsInstancedBaseInstance = uintptr ( getProcAddr ( " " ) ) gpDrawElementsInstancedBaseVertex = uintptr ( getProcAddr ( " " ) ) gpDrawElementsInstancedBaseVertexBaseInstance = uintptr ( getProcAddr ( " " ) ) gpDrawElementsInstancedEXT = uintptr ( getProcAddr ( " " ) ) gpDrawMeshArraysSUN = uintptr ( getProcAddr ( " " ) ) gpDrawPixels = uintptr ( getProcAddr ( " " ) ) if gpDrawPixels == 0 { return errors . New ( " " ) } gpDrawRangeElementArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpDrawRangeElementArrayATI = uintptr ( getProcAddr ( " " ) ) gpDrawRangeElements = uintptr ( getProcAddr ( " " ) ) if gpDrawRangeElements == 0 { return errors . New ( " " ) } gpDrawRangeElementsBaseVertex = uintptr ( getProcAddr ( " " ) ) gpDrawRangeElementsEXT = uintptr ( getProcAddr ( " " ) ) gpDrawTextureNV = uintptr ( getProcAddr ( " " ) ) gpDrawTransformFeedback = uintptr ( getProcAddr ( " " ) ) gpDrawTransformFeedbackInstanced = uintptr ( getProcAddr ( " " ) ) gpDrawTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpDrawTransformFeedbackStream = uintptr ( getProcAddr ( " " ) ) gpDrawTransformFeedbackStreamInstanced = uintptr ( getProcAddr ( " " ) ) gpDrawVkImageNV = uintptr ( getProcAddr ( " " ) ) gpEGLImageTargetTexStorageEXT = uintptr ( getProcAddr ( " " ) ) gpEGLImageTargetTextureStorageEXT = uintptr ( getProcAddr ( " " ) ) gpEdgeFlag = uintptr ( getProcAddr ( " " ) ) if gpEdgeFlag == 0 { return errors . New ( " " ) } gpEdgeFlagFormatNV = uintptr ( getProcAddr ( " " ) ) gpEdgeFlagPointer = uintptr ( getProcAddr ( " " ) ) if gpEdgeFlagPointer == 0 { return errors . New ( " " ) } gpEdgeFlagPointerEXT = uintptr ( getProcAddr ( " " ) ) gpEdgeFlagPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpEdgeFlagv = uintptr ( getProcAddr ( " " ) ) if gpEdgeFlagv == 0 { return errors . New ( " " ) } gpElementPointerAPPLE = uintptr ( getProcAddr ( " " ) ) gpElementPointerATI = uintptr ( getProcAddr ( " " ) ) gpEnable = uintptr ( getProcAddr ( " " ) ) if gpEnable == 0 { return errors . New ( " " ) } gpEnableClientState = uintptr ( getProcAddr ( " " ) ) if gpEnableClientState == 0 { return errors . New ( " " ) } gpEnableClientStateIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpEnableClientStateiEXT = uintptr ( getProcAddr ( " " ) ) gpEnableIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpEnableVariantClientStateEXT = uintptr ( getProcAddr ( " " ) ) gpEnableVertexArrayAttrib = uintptr ( getProcAddr ( " " ) ) gpEnableVertexArrayAttribEXT = uintptr ( getProcAddr ( " " ) ) gpEnableVertexArrayEXT = uintptr ( getProcAddr ( " " ) ) gpEnableVertexAttribAPPLE = uintptr ( getProcAddr ( " " ) ) gpEnableVertexAttribArray = uintptr ( getProcAddr ( " " ) ) if gpEnableVertexAttribArray == 0 { return errors . New ( " " ) } gpEnableVertexAttribArrayARB = uintptr ( getProcAddr ( " " ) ) gpEnd = uintptr ( getProcAddr ( " " ) ) if gpEnd == 0 { return errors . New ( " " ) } gpEndConditionalRenderNV = uintptr ( getProcAddr ( " " ) ) gpEndConditionalRenderNVX = uintptr ( getProcAddr ( " " ) ) gpEndFragmentShaderATI = uintptr ( getProcAddr ( " " ) ) gpEndList = uintptr ( getProcAddr ( " " ) ) if gpEndList == 0 { return errors . New ( " " ) } gpEndOcclusionQueryNV = uintptr ( getProcAddr ( " " ) ) gpEndPerfMonitorAMD = uintptr ( getProcAddr ( " " ) ) gpEndPerfQueryINTEL = uintptr ( getProcAddr ( " " ) ) gpEndQuery = uintptr ( getProcAddr ( " " ) ) if gpEndQuery == 0 { return errors . New ( " " ) } gpEndQueryARB = uintptr ( getProcAddr ( " " ) ) gpEndQueryIndexed = uintptr ( getProcAddr ( " " ) ) gpEndTransformFeedbackEXT = uintptr ( getProcAddr ( " " ) ) gpEndTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpEndVertexShaderEXT = uintptr ( getProcAddr ( " " ) ) gpEndVideoCaptureNV = uintptr ( getProcAddr ( " " ) ) gpEvalCoord1d = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord1d == 0 { return errors . New ( " " ) } gpEvalCoord1dv = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord1dv == 0 { return errors . New ( " " ) } gpEvalCoord1f = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord1f == 0 { return errors . New ( " " ) } gpEvalCoord1fv = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord1fv == 0 { return errors . New ( " " ) } gpEvalCoord1xOES = uintptr ( getProcAddr ( " " ) ) gpEvalCoord1xvOES = uintptr ( getProcAddr ( " " ) ) gpEvalCoord2d = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord2d == 0 { return errors . New ( " " ) } gpEvalCoord2dv = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord2dv == 0 { return errors . New ( " " ) } gpEvalCoord2f = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord2f == 0 { return errors . New ( " " ) } gpEvalCoord2fv = uintptr ( getProcAddr ( " " ) ) if gpEvalCoord2fv == 0 { return errors . New ( " " ) } gpEvalCoord2xOES = uintptr ( getProcAddr ( " " ) ) gpEvalCoord2xvOES = uintptr ( getProcAddr ( " " ) ) gpEvalMapsNV = uintptr ( getProcAddr ( " " ) ) gpEvalMesh1 = uintptr ( getProcAddr ( " " ) ) if gpEvalMesh1 == 0 { return errors . New ( " " ) } gpEvalMesh2 = uintptr ( getProcAddr ( " " ) ) if gpEvalMesh2 == 0 { return errors . New ( " " ) } gpEvalPoint1 = uintptr ( getProcAddr ( " " ) ) if gpEvalPoint1 == 0 { return errors . New ( " " ) } gpEvalPoint2 = uintptr ( getProcAddr ( " " ) ) if gpEvalPoint2 == 0 { return errors . New ( " " ) } gpEvaluateDepthValuesARB = uintptr ( getProcAddr ( " " ) ) gpExecuteProgramNV = uintptr ( getProcAddr ( " " ) ) gpExtractComponentEXT = uintptr ( getProcAddr ( " " ) ) gpFeedbackBuffer = uintptr ( getProcAddr ( " " ) ) if gpFeedbackBuffer == 0 { return errors . New ( " " ) } gpFeedbackBufferxOES = uintptr ( getProcAddr ( " " ) ) gpFenceSync = uintptr ( getProcAddr ( " " ) ) gpFinalCombinerInputNV = uintptr ( getProcAddr ( " " ) ) gpFinish = uintptr ( getProcAddr ( " " ) ) if gpFinish == 0 { return errors . New ( " " ) } gpFinishAsyncSGIX = uintptr ( getProcAddr ( " " ) ) gpFinishFenceAPPLE = uintptr ( getProcAddr ( " " ) ) gpFinishFenceNV = uintptr ( getProcAddr ( " " ) ) gpFinishObjectAPPLE = uintptr ( getProcAddr ( " " ) ) gpFinishTextureSUNX = uintptr ( getProcAddr ( " " ) ) gpFlush = uintptr ( getProcAddr ( " " ) ) if gpFlush == 0 { return errors . New ( " " ) } gpFlushMappedBufferRange = uintptr ( getProcAddr ( " " ) ) gpFlushMappedBufferRangeAPPLE = uintptr ( getProcAddr ( " " ) ) gpFlushMappedNamedBufferRange = uintptr ( getProcAddr ( " " ) ) gpFlushMappedNamedBufferRangeEXT = uintptr ( getProcAddr ( " " ) ) gpFlushPixelDataRangeNV = uintptr ( getProcAddr ( " " ) ) gpFlushRasterSGIX = uintptr ( getProcAddr ( " " ) ) gpFlushStaticDataIBM = uintptr ( getProcAddr ( " " ) ) gpFlushVertexArrayRangeAPPLE = uintptr ( getProcAddr ( " " ) ) gpFlushVertexArrayRangeNV = uintptr ( getProcAddr ( " " ) ) gpFogCoordFormatNV = uintptr ( getProcAddr ( " " ) ) gpFogCoordPointer = uintptr ( getProcAddr ( " " ) ) if gpFogCoordPointer == 0 { return errors . New ( " " ) } gpFogCoordPointerEXT = uintptr ( getProcAddr ( " " ) ) gpFogCoordPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpFogCoordd = uintptr ( getProcAddr ( " " ) ) if gpFogCoordd == 0 { return errors . New ( " " ) } gpFogCoorddEXT = uintptr ( getProcAddr ( " " ) ) gpFogCoorddv = uintptr ( getProcAddr ( " " ) ) if gpFogCoorddv == 0 { return errors . New ( " " ) } gpFogCoorddvEXT = uintptr ( getProcAddr ( " " ) ) gpFogCoordf = uintptr ( getProcAddr ( " " ) ) if gpFogCoordf == 0 { return errors . New ( " " ) } gpFogCoordfEXT = uintptr ( getProcAddr ( " " ) ) gpFogCoordfv = uintptr ( getProcAddr ( " " ) ) if gpFogCoordfv == 0 { return errors . New ( " " ) } gpFogCoordfvEXT = uintptr ( getProcAddr ( " " ) ) gpFogCoordhNV = uintptr ( getProcAddr ( " " ) ) gpFogCoordhvNV = uintptr ( getProcAddr ( " " ) ) gpFogFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpFogf = uintptr ( getProcAddr ( " " ) ) if gpFogf == 0 { return errors . New ( " " ) } gpFogfv = uintptr ( getProcAddr ( " " ) ) if gpFogfv == 0 { return errors . New ( " " ) } gpFogi = uintptr ( getProcAddr ( " " ) ) if gpFogi == 0 { return errors . New ( " " ) } gpFogiv = uintptr ( getProcAddr ( " " ) ) if gpFogiv == 0 { return errors . New ( " " ) } gpFogxOES = uintptr ( getProcAddr ( " " ) ) gpFogxvOES = uintptr ( getProcAddr ( " " ) ) gpFragmentColorMaterialSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentCoverageColorNV = uintptr ( getProcAddr ( " " ) ) gpFragmentLightModelfSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightModelfvSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightModeliSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightModelivSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightfSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightfvSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightiSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentLightivSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentMaterialfSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentMaterialfvSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentMaterialiSGIX = uintptr ( getProcAddr ( " " ) ) gpFragmentMaterialivSGIX = uintptr ( getProcAddr ( " " ) ) gpFrameTerminatorGREMEDY = uintptr ( getProcAddr ( " " ) ) gpFrameZoomSGIX = uintptr ( getProcAddr ( " " ) ) gpFramebufferDrawBufferEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferDrawBuffersEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferFetchBarrierEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferParameteri = uintptr ( getProcAddr ( " " ) ) gpFramebufferReadBufferEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferRenderbuffer = uintptr ( getProcAddr ( " " ) ) gpFramebufferRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferSampleLocationsfvARB = uintptr ( getProcAddr ( " " ) ) gpFramebufferSampleLocationsfvNV = uintptr ( getProcAddr ( " " ) ) gpFramebufferSamplePositionsfvAMD = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture1D = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture1DEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture2D = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture2DEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture3D = uintptr ( getProcAddr ( " " ) ) gpFramebufferTexture3DEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureARB = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureFaceARB = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureFaceEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureLayer = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureLayerARB = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureLayerEXT = uintptr ( getProcAddr ( " " ) ) gpFramebufferTextureMultiviewOVR = uintptr ( getProcAddr ( " " ) ) gpFreeObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpFrontFace = uintptr ( getProcAddr ( " " ) ) if gpFrontFace == 0 { return errors . New ( " " ) } gpFrustum = uintptr ( getProcAddr ( " " ) ) if gpFrustum == 0 { return errors . New ( " " ) } gpFrustumfOES = uintptr ( getProcAddr ( " " ) ) gpFrustumxOES = uintptr ( getProcAddr ( " " ) ) gpGenAsyncMarkersSGIX = uintptr ( getProcAddr ( " " ) ) gpGenBuffers = uintptr ( getProcAddr ( " " ) ) if gpGenBuffers == 0 { return errors . New ( " " ) } gpGenBuffersARB = uintptr ( getProcAddr ( " " ) ) gpGenFencesAPPLE = uintptr ( getProcAddr ( " " ) ) gpGenFencesNV = uintptr ( getProcAddr ( " " ) ) gpGenFragmentShadersATI = uintptr ( getProcAddr ( " " ) ) gpGenFramebuffers = uintptr ( getProcAddr ( " " ) ) gpGenFramebuffersEXT = uintptr ( getProcAddr ( " " ) ) gpGenLists = uintptr ( getProcAddr ( " " ) ) if gpGenLists == 0 { return errors . New ( " " ) } gpGenNamesAMD = uintptr ( getProcAddr ( " " ) ) gpGenOcclusionQueriesNV = uintptr ( getProcAddr ( " " ) ) gpGenPathsNV = uintptr ( getProcAddr ( " " ) ) gpGenPerfMonitorsAMD = uintptr ( getProcAddr ( " " ) ) gpGenProgramPipelines = uintptr ( getProcAddr ( " " ) ) gpGenProgramPipelinesEXT = uintptr ( getProcAddr ( " " ) ) gpGenProgramsARB = uintptr ( getProcAddr ( " " ) ) gpGenProgramsNV = uintptr ( getProcAddr ( " " ) ) gpGenQueries = uintptr ( getProcAddr ( " " ) ) if gpGenQueries == 0 { return errors . New ( " " ) } gpGenQueriesARB = uintptr ( getProcAddr ( " " ) ) gpGenQueryResourceTagNV = uintptr ( getProcAddr ( " " ) ) gpGenRenderbuffers = uintptr ( getProcAddr ( " " ) ) gpGenRenderbuffersEXT = uintptr ( getProcAddr ( " " ) ) gpGenSamplers = uintptr ( getProcAddr ( " " ) ) gpGenSemaphoresEXT = uintptr ( getProcAddr ( " " ) ) gpGenSymbolsEXT = uintptr ( getProcAddr ( " " ) ) gpGenTextures = uintptr ( getProcAddr ( " " ) ) if gpGenTextures == 0 { return errors . New ( " " ) } gpGenTexturesEXT = uintptr ( getProcAddr ( " " ) ) gpGenTransformFeedbacks = uintptr ( getProcAddr ( " " ) ) gpGenTransformFeedbacksNV = uintptr ( getProcAddr ( " " ) ) gpGenVertexArrays = uintptr ( getProcAddr ( " " ) ) gpGenVertexArraysAPPLE = uintptr ( getProcAddr ( " " ) ) gpGenVertexShadersEXT = uintptr ( getProcAddr ( " " ) ) gpGenerateMipmap = uintptr ( getProcAddr ( " " ) ) gpGenerateMipmapEXT = uintptr ( getProcAddr ( " " ) ) gpGenerateMultiTexMipmapEXT = uintptr ( getProcAddr ( " " ) ) gpGenerateTextureMipmap = uintptr ( getProcAddr ( " " ) ) gpGenerateTextureMipmapEXT = uintptr ( getProcAddr ( " " ) ) gpGetActiveAtomicCounterBufferiv = uintptr ( getProcAddr ( " " ) ) gpGetActiveAttrib = uintptr ( getProcAddr ( " " ) ) if gpGetActiveAttrib == 0 { return errors . New ( " " ) } gpGetActiveAttribARB = uintptr ( getProcAddr ( " " ) ) gpGetActiveSubroutineName = uintptr ( getProcAddr ( " " ) ) gpGetActiveSubroutineUniformName = uintptr ( getProcAddr ( " " ) ) gpGetActiveSubroutineUniformiv = uintptr ( getProcAddr ( " " ) ) gpGetActiveUniform = uintptr ( getProcAddr ( " " ) ) if gpGetActiveUniform == 0 { return errors . New ( " " ) } gpGetActiveUniformARB = uintptr ( getProcAddr ( " " ) ) gpGetActiveUniformBlockName = uintptr ( getProcAddr ( " " ) ) gpGetActiveUniformBlockiv = uintptr ( getProcAddr ( " " ) ) gpGetActiveUniformName = uintptr ( getProcAddr ( " " ) ) gpGetActiveUniformsiv = uintptr ( getProcAddr ( " " ) ) gpGetActiveVaryingNV = uintptr ( getProcAddr ( " " ) ) gpGetArrayObjectfvATI = uintptr ( getProcAddr ( " " ) ) gpGetArrayObjectivATI = uintptr ( getProcAddr ( " " ) ) gpGetAttachedObjectsARB = uintptr ( getProcAddr ( " " ) ) gpGetAttachedShaders = uintptr ( getProcAddr ( " " ) ) if gpGetAttachedShaders == 0 { return errors . New ( " " ) } gpGetAttribLocation = uintptr ( getProcAddr ( " " ) ) if gpGetAttribLocation == 0 { return errors . New ( " " ) } gpGetAttribLocationARB = uintptr ( getProcAddr ( " " ) ) gpGetBooleanIndexedvEXT = uintptr ( getProcAddr ( " " ) ) gpGetBooleanv = uintptr ( getProcAddr ( " " ) ) if gpGetBooleanv == 0 { return errors . New ( " " ) } gpGetBufferParameteriv = uintptr ( getProcAddr ( " " ) ) if gpGetBufferParameteriv == 0 { return errors . New ( " " ) } gpGetBufferParameterivARB = uintptr ( getProcAddr ( " " ) ) gpGetBufferParameterui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetBufferPointerv = uintptr ( getProcAddr ( " " ) ) if gpGetBufferPointerv == 0 { return errors . New ( " " ) } gpGetBufferPointervARB = uintptr ( getProcAddr ( " " ) ) gpGetBufferSubData = uintptr ( getProcAddr ( " " ) ) if gpGetBufferSubData == 0 { return errors . New ( " " ) } gpGetBufferSubDataARB = uintptr ( getProcAddr ( " " ) ) gpGetClipPlane = uintptr ( getProcAddr ( " " ) ) if gpGetClipPlane == 0 { return errors . New ( " " ) } gpGetClipPlanefOES = uintptr ( getProcAddr ( " " ) ) gpGetClipPlanexOES = uintptr ( getProcAddr ( " " ) ) gpGetColorTableEXT = uintptr ( getProcAddr ( " " ) ) gpGetColorTableParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetColorTableParameterfvSGI = uintptr ( getProcAddr ( " " ) ) gpGetColorTableParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetColorTableParameterivSGI = uintptr ( getProcAddr ( " " ) ) gpGetColorTableSGI = uintptr ( getProcAddr ( " " ) ) gpGetCombinerInputParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetCombinerInputParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetCombinerOutputParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetCombinerOutputParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetCombinerStageParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetCommandHeaderNV = uintptr ( getProcAddr ( " " ) ) gpGetCompressedMultiTexImageEXT = uintptr ( getProcAddr ( " " ) ) gpGetCompressedTexImage = uintptr ( getProcAddr ( " " ) ) if gpGetCompressedTexImage == 0 { return errors . New ( " " ) } gpGetCompressedTexImageARB = uintptr ( getProcAddr ( " " ) ) gpGetCompressedTextureImage = uintptr ( getProcAddr ( " " ) ) gpGetCompressedTextureImageEXT = uintptr ( getProcAddr ( " " ) ) gpGetCompressedTextureSubImage = uintptr ( getProcAddr ( " " ) ) gpGetConvolutionFilterEXT = uintptr ( getProcAddr ( " " ) ) gpGetConvolutionParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetConvolutionParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetConvolutionParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpGetCoverageModulationTableNV = uintptr ( getProcAddr ( " " ) ) gpGetDebugMessageLog = uintptr ( getProcAddr ( " " ) ) gpGetDebugMessageLogAMD = uintptr ( getProcAddr ( " " ) ) gpGetDebugMessageLogARB = uintptr ( getProcAddr ( " " ) ) gpGetDebugMessageLogKHR = uintptr ( getProcAddr ( " " ) ) gpGetDetailTexFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpGetDoubleIndexedvEXT = uintptr ( getProcAddr ( " " ) ) gpGetDoublei_v = uintptr ( getProcAddr ( " " ) ) gpGetDoublei_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetDoublev = uintptr ( getProcAddr ( " " ) ) if gpGetDoublev == 0 { return errors . New ( " " ) } gpGetError = uintptr ( getProcAddr ( " " ) ) if gpGetError == 0 { return errors . New ( " " ) } gpGetFenceivNV = uintptr ( getProcAddr ( " " ) ) gpGetFinalCombinerInputParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetFinalCombinerInputParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetFirstPerfQueryIdINTEL = uintptr ( getProcAddr ( " " ) ) gpGetFixedvOES = uintptr ( getProcAddr ( " " ) ) gpGetFloatIndexedvEXT = uintptr ( getProcAddr ( " " ) ) gpGetFloati_v = uintptr ( getProcAddr ( " " ) ) gpGetFloati_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetFloatv = uintptr ( getProcAddr ( " " ) ) if gpGetFloatv == 0 { return errors . New ( " " ) } gpGetFogFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpGetFragDataIndex = uintptr ( getProcAddr ( " " ) ) gpGetFragDataLocationEXT = uintptr ( getProcAddr ( " " ) ) gpGetFragmentLightfvSGIX = uintptr ( getProcAddr ( " " ) ) gpGetFragmentLightivSGIX = uintptr ( getProcAddr ( " " ) ) gpGetFragmentMaterialfvSGIX = uintptr ( getProcAddr ( " " ) ) gpGetFragmentMaterialivSGIX = uintptr ( getProcAddr ( " " ) ) gpGetFramebufferAttachmentParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetFramebufferAttachmentParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetFramebufferParameterfvAMD = uintptr ( getProcAddr ( " " ) ) gpGetFramebufferParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetFramebufferParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetGraphicsResetStatus = uintptr ( getProcAddr ( " " ) ) gpGetGraphicsResetStatusARB = uintptr ( getProcAddr ( " " ) ) gpGetGraphicsResetStatusKHR = uintptr ( getProcAddr ( " " ) ) gpGetHandleARB = uintptr ( getProcAddr ( " " ) ) gpGetHistogramEXT = uintptr ( getProcAddr ( " " ) ) gpGetHistogramParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetHistogramParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetHistogramParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpGetImageHandleARB = uintptr ( getProcAddr ( " " ) ) gpGetImageHandleNV = uintptr ( getProcAddr ( " " ) ) gpGetImageTransformParameterfvHP = uintptr ( getProcAddr ( " " ) ) gpGetImageTransformParameterivHP = uintptr ( getProcAddr ( " " ) ) gpGetInfoLogARB = uintptr ( getProcAddr ( " " ) ) gpGetInstrumentsSGIX = uintptr ( getProcAddr ( " " ) ) gpGetInteger64v = uintptr ( getProcAddr ( " " ) ) gpGetIntegerIndexedvEXT = uintptr ( getProcAddr ( " " ) ) gpGetIntegeri_v = uintptr ( getProcAddr ( " " ) ) gpGetIntegerui64i_vNV = uintptr ( getProcAddr ( " " ) ) gpGetIntegerui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetIntegerv = uintptr ( getProcAddr ( " " ) ) if gpGetIntegerv == 0 { return errors . New ( " " ) } gpGetInternalformatSampleivNV = uintptr ( getProcAddr ( " " ) ) gpGetInternalformati64v = uintptr ( getProcAddr ( " " ) ) gpGetInternalformativ = uintptr ( getProcAddr ( " " ) ) gpGetInvariantBooleanvEXT = uintptr ( getProcAddr ( " " ) ) gpGetInvariantFloatvEXT = uintptr ( getProcAddr ( " " ) ) gpGetInvariantIntegervEXT = uintptr ( getProcAddr ( " " ) ) gpGetLightfv = uintptr ( getProcAddr ( " " ) ) if gpGetLightfv == 0 { return errors . New ( " " ) } gpGetLightiv = uintptr ( getProcAddr ( " " ) ) if gpGetLightiv == 0 { return errors . New ( " " ) } gpGetLightxOES = uintptr ( getProcAddr ( " " ) ) gpGetLightxvOES = uintptr ( getProcAddr ( " " ) ) gpGetListParameterfvSGIX = uintptr ( getProcAddr ( " " ) ) gpGetListParameterivSGIX = uintptr ( getProcAddr ( " " ) ) gpGetLocalConstantBooleanvEXT = uintptr ( getProcAddr ( " " ) ) gpGetLocalConstantFloatvEXT = uintptr ( getProcAddr ( " " ) ) gpGetLocalConstantIntegervEXT = uintptr ( getProcAddr ( " " ) ) gpGetMapAttribParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetMapAttribParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetMapControlPointsNV = uintptr ( getProcAddr ( " " ) ) gpGetMapParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetMapParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetMapdv = uintptr ( getProcAddr ( " " ) ) if gpGetMapdv == 0 { return errors . New ( " " ) } gpGetMapfv = uintptr ( getProcAddr ( " " ) ) if gpGetMapfv == 0 { return errors . New ( " " ) } gpGetMapiv = uintptr ( getProcAddr ( " " ) ) if gpGetMapiv == 0 { return errors . New ( " " ) } gpGetMapxvOES = uintptr ( getProcAddr ( " " ) ) gpGetMaterialfv = uintptr ( getProcAddr ( " " ) ) if gpGetMaterialfv == 0 { return errors . New ( " " ) } gpGetMaterialiv = uintptr ( getProcAddr ( " " ) ) if gpGetMaterialiv == 0 { return errors . New ( " " ) } gpGetMaterialxOES = uintptr ( getProcAddr ( " " ) ) gpGetMaterialxvOES = uintptr ( getProcAddr ( " " ) ) gpGetMemoryObjectParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMinmaxEXT = uintptr ( getProcAddr ( " " ) ) gpGetMinmaxParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMinmaxParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexEnvfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexEnvivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexGendvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexGenfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexGenivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexImageEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexLevelParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexLevelParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultiTexParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetMultisamplefv = uintptr ( getProcAddr ( " " ) ) gpGetMultisamplefvNV = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferParameteri64v = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferParameterui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferPointerv = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferPointervEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferSubData = uintptr ( getProcAddr ( " " ) ) gpGetNamedBufferSubDataEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedFramebufferAttachmentParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetNamedFramebufferAttachmentParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedFramebufferParameterfvAMD = uintptr ( getProcAddr ( " " ) ) gpGetNamedFramebufferParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetNamedFramebufferParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramLocalParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramLocalParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramLocalParameterdvEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramLocalParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramStringEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedProgramivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedRenderbufferParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetNamedRenderbufferParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetNamedStringARB = uintptr ( getProcAddr ( " " ) ) gpGetNamedStringivARB = uintptr ( getProcAddr ( " " ) ) gpGetNextPerfQueryIdINTEL = uintptr ( getProcAddr ( " " ) ) gpGetObjectBufferfvATI = uintptr ( getProcAddr ( " " ) ) gpGetObjectBufferivATI = uintptr ( getProcAddr ( " " ) ) gpGetObjectLabel = uintptr ( getProcAddr ( " " ) ) gpGetObjectLabelEXT = uintptr ( getProcAddr ( " " ) ) gpGetObjectLabelKHR = uintptr ( getProcAddr ( " " ) ) gpGetObjectParameterfvARB = uintptr ( getProcAddr ( " " ) ) gpGetObjectParameterivAPPLE = uintptr ( getProcAddr ( " " ) ) gpGetObjectParameterivARB = uintptr ( getProcAddr ( " " ) ) gpGetObjectPtrLabel = uintptr ( getProcAddr ( " " ) ) gpGetObjectPtrLabelKHR = uintptr ( getProcAddr ( " " ) ) gpGetOcclusionQueryivNV = uintptr ( getProcAddr ( " " ) ) gpGetOcclusionQueryuivNV = uintptr ( getProcAddr ( " " ) ) gpGetPathCommandsNV = uintptr ( getProcAddr ( " " ) ) gpGetPathCoordsNV = uintptr ( getProcAddr ( " " ) ) gpGetPathDashArrayNV = uintptr ( getProcAddr ( " " ) ) gpGetPathLengthNV = uintptr ( getProcAddr ( " " ) ) gpGetPathMetricRangeNV = uintptr ( getProcAddr ( " " ) ) gpGetPathMetricsNV = uintptr ( getProcAddr ( " " ) ) gpGetPathParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetPathParameterivNV = uintptr ( getProcAddr ( " " ) ) gpGetPathSpacingNV = uintptr ( getProcAddr ( " " ) ) gpGetPerfCounterInfoINTEL = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorCounterDataAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorCounterInfoAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorCounterStringAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorCountersAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorGroupStringAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfMonitorGroupsAMD = uintptr ( getProcAddr ( " " ) ) gpGetPerfQueryDataINTEL = uintptr ( getProcAddr ( " " ) ) gpGetPerfQueryIdByNameINTEL = uintptr ( getProcAddr ( " " ) ) gpGetPerfQueryInfoINTEL = uintptr ( getProcAddr ( " " ) ) gpGetPixelMapfv = uintptr ( getProcAddr ( " " ) ) if gpGetPixelMapfv == 0 { return errors . New ( " " ) } gpGetPixelMapuiv = uintptr ( getProcAddr ( " " ) ) if gpGetPixelMapuiv == 0 { return errors . New ( " " ) } gpGetPixelMapusv = uintptr ( getProcAddr ( " " ) ) if gpGetPixelMapusv == 0 { return errors . New ( " " ) } gpGetPixelMapxv = uintptr ( getProcAddr ( " " ) ) gpGetPixelTexGenParameterfvSGIS = uintptr ( getProcAddr ( " " ) ) gpGetPixelTexGenParameterivSGIS = uintptr ( getProcAddr ( " " ) ) gpGetPixelTransformParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetPixelTransformParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetPointerIndexedvEXT = uintptr ( getProcAddr ( " " ) ) gpGetPointeri_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetPointerv = uintptr ( getProcAddr ( " " ) ) if gpGetPointerv == 0 { return errors . New ( " " ) } gpGetPointervEXT = uintptr ( getProcAddr ( " " ) ) gpGetPointervKHR = uintptr ( getProcAddr ( " " ) ) gpGetPolygonStipple = uintptr ( getProcAddr ( " " ) ) if gpGetPolygonStipple == 0 { return errors . New ( " " ) } gpGetProgramBinary = uintptr ( getProcAddr ( " " ) ) gpGetProgramEnvParameterIivNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramEnvParameterIuivNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramEnvParameterdvARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramEnvParameterfvARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramInfoLog = uintptr ( getProcAddr ( " " ) ) if gpGetProgramInfoLog == 0 { return errors . New ( " " ) } gpGetProgramInterfaceiv = uintptr ( getProcAddr ( " " ) ) gpGetProgramLocalParameterIivNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramLocalParameterIuivNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramLocalParameterdvARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramLocalParameterfvARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramNamedParameterdvNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramNamedParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramParameterdvNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramPipelineInfoLog = uintptr ( getProcAddr ( " " ) ) gpGetProgramPipelineInfoLogEXT = uintptr ( getProcAddr ( " " ) ) gpGetProgramPipelineiv = uintptr ( getProcAddr ( " " ) ) gpGetProgramPipelineivEXT = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourceIndex = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourceLocation = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourceLocationIndex = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourceName = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourcefvNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramResourceiv = uintptr ( getProcAddr ( " " ) ) gpGetProgramStageiv = uintptr ( getProcAddr ( " " ) ) gpGetProgramStringARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramStringNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramSubroutineParameteruivNV = uintptr ( getProcAddr ( " " ) ) gpGetProgramiv = uintptr ( getProcAddr ( " " ) ) if gpGetProgramiv == 0 { return errors . New ( " " ) } gpGetProgramivARB = uintptr ( getProcAddr ( " " ) ) gpGetProgramivNV = uintptr ( getProcAddr ( " " ) ) gpGetQueryBufferObjecti64v = uintptr ( getProcAddr ( " " ) ) gpGetQueryBufferObjectiv = uintptr ( getProcAddr ( " " ) ) gpGetQueryBufferObjectui64v = uintptr ( getProcAddr ( " " ) ) gpGetQueryBufferObjectuiv = uintptr ( getProcAddr ( " " ) ) gpGetQueryIndexediv = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjecti64v = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjecti64vEXT = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjectiv = uintptr ( getProcAddr ( " " ) ) if gpGetQueryObjectiv == 0 { return errors . New ( " " ) } gpGetQueryObjectivARB = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjectui64v = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjectui64vEXT = uintptr ( getProcAddr ( " " ) ) gpGetQueryObjectuiv = uintptr ( getProcAddr ( " " ) ) if gpGetQueryObjectuiv == 0 { return errors . New ( " " ) } gpGetQueryObjectuivARB = uintptr ( getProcAddr ( " " ) ) gpGetQueryiv = uintptr ( getProcAddr ( " " ) ) if gpGetQueryiv == 0 { return errors . New ( " " ) } gpGetQueryivARB = uintptr ( getProcAddr ( " " ) ) gpGetRenderbufferParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetRenderbufferParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetSamplerParameterIiv = uintptr ( getProcAddr ( " " ) ) gpGetSamplerParameterIuiv = uintptr ( getProcAddr ( " " ) ) gpGetSamplerParameterfv = uintptr ( getProcAddr ( " " ) ) gpGetSamplerParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetSemaphoreParameterui64vEXT = uintptr ( getProcAddr ( " " ) ) gpGetSeparableFilterEXT = uintptr ( getProcAddr ( " " ) ) gpGetShaderInfoLog = uintptr ( getProcAddr ( " " ) ) if gpGetShaderInfoLog == 0 { return errors . New ( " " ) } gpGetShaderPrecisionFormat = uintptr ( getProcAddr ( " " ) ) gpGetShaderSource = uintptr ( getProcAddr ( " " ) ) if gpGetShaderSource == 0 { return errors . New ( " " ) } gpGetShaderSourceARB = uintptr ( getProcAddr ( " " ) ) gpGetShaderiv = uintptr ( getProcAddr ( " " ) ) if gpGetShaderiv == 0 { return errors . New ( " " ) } gpGetSharpenTexFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpGetStageIndexNV = uintptr ( getProcAddr ( " " ) ) gpGetString = uintptr ( getProcAddr ( " " ) ) if gpGetString == 0 { return errors . New ( " " ) } gpGetSubroutineIndex = uintptr ( getProcAddr ( " " ) ) gpGetSubroutineUniformLocation = uintptr ( getProcAddr ( " " ) ) gpGetSynciv = uintptr ( getProcAddr ( " " ) ) gpGetTexBumpParameterfvATI = uintptr ( getProcAddr ( " " ) ) gpGetTexBumpParameterivATI = uintptr ( getProcAddr ( " " ) ) gpGetTexEnvfv = uintptr ( getProcAddr ( " " ) ) if gpGetTexEnvfv == 0 { return errors . New ( " " ) } gpGetTexEnviv = uintptr ( getProcAddr ( " " ) ) if gpGetTexEnviv == 0 { return errors . New ( " " ) } gpGetTexEnvxvOES = uintptr ( getProcAddr ( " " ) ) gpGetTexFilterFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpGetTexGendv = uintptr ( getProcAddr ( " " ) ) if gpGetTexGendv == 0 { return errors . New ( " " ) } gpGetTexGenfv = uintptr ( getProcAddr ( " " ) ) if gpGetTexGenfv == 0 { return errors . New ( " " ) } gpGetTexGeniv = uintptr ( getProcAddr ( " " ) ) if gpGetTexGeniv == 0 { return errors . New ( " " ) } gpGetTexGenxvOES = uintptr ( getProcAddr ( " " ) ) gpGetTexImage = uintptr ( getProcAddr ( " " ) ) if gpGetTexImage == 0 { return errors . New ( " " ) } gpGetTexLevelParameterfv = uintptr ( getProcAddr ( " " ) ) if gpGetTexLevelParameterfv == 0 { return errors . New ( " " ) } gpGetTexLevelParameteriv = uintptr ( getProcAddr ( " " ) ) if gpGetTexLevelParameteriv == 0 { return errors . New ( " " ) } gpGetTexLevelParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpGetTexParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTexParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTexParameterPointervAPPLE = uintptr ( getProcAddr ( " " ) ) gpGetTexParameterfv = uintptr ( getProcAddr ( " " ) ) if gpGetTexParameterfv == 0 { return errors . New ( " " ) } gpGetTexParameteriv = uintptr ( getProcAddr ( " " ) ) if gpGetTexParameteriv == 0 { return errors . New ( " " ) } gpGetTexParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpGetTextureHandleARB = uintptr ( getProcAddr ( " " ) ) gpGetTextureHandleNV = uintptr ( getProcAddr ( " " ) ) gpGetTextureImage = uintptr ( getProcAddr ( " " ) ) gpGetTextureImageEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureLevelParameterfv = uintptr ( getProcAddr ( " " ) ) gpGetTextureLevelParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureLevelParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetTextureLevelParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterIiv = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterIuiv = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterfv = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameteriv = uintptr ( getProcAddr ( " " ) ) gpGetTextureParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpGetTextureSamplerHandleARB = uintptr ( getProcAddr ( " " ) ) gpGetTextureSamplerHandleNV = uintptr ( getProcAddr ( " " ) ) gpGetTextureSubImage = uintptr ( getProcAddr ( " " ) ) gpGetTrackMatrixivNV = uintptr ( getProcAddr ( " " ) ) gpGetTransformFeedbackVaryingEXT = uintptr ( getProcAddr ( " " ) ) gpGetTransformFeedbackVaryingNV = uintptr ( getProcAddr ( " " ) ) gpGetTransformFeedbacki64_v = uintptr ( getProcAddr ( " " ) ) gpGetTransformFeedbacki_v = uintptr ( getProcAddr ( " " ) ) gpGetTransformFeedbackiv = uintptr ( getProcAddr ( " " ) ) gpGetUniformBlockIndex = uintptr ( getProcAddr ( " " ) ) gpGetUniformBufferSizeEXT = uintptr ( getProcAddr ( " " ) ) gpGetUniformIndices = uintptr ( getProcAddr ( " " ) ) gpGetUniformLocation = uintptr ( getProcAddr ( " " ) ) if gpGetUniformLocation == 0 { return errors . New ( " " ) } gpGetUniformLocationARB = uintptr ( getProcAddr ( " " ) ) gpGetUniformOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpGetUniformSubroutineuiv = uintptr ( getProcAddr ( " " ) ) gpGetUniformdv = uintptr ( getProcAddr ( " " ) ) gpGetUniformfv = uintptr ( getProcAddr ( " " ) ) if gpGetUniformfv == 0 { return errors . New ( " " ) } gpGetUniformfvARB = uintptr ( getProcAddr ( " " ) ) gpGetUniformi64vARB = uintptr ( getProcAddr ( " " ) ) gpGetUniformi64vNV = uintptr ( getProcAddr ( " " ) ) gpGetUniformiv = uintptr ( getProcAddr ( " " ) ) if gpGetUniformiv == 0 { return errors . New ( " " ) } gpGetUniformivARB = uintptr ( getProcAddr ( " " ) ) gpGetUniformui64vARB = uintptr ( getProcAddr ( " " ) ) gpGetUniformui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetUniformuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetUnsignedBytei_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetUnsignedBytevEXT = uintptr ( getProcAddr ( " " ) ) gpGetVariantArrayObjectfvATI = uintptr ( getProcAddr ( " " ) ) gpGetVariantArrayObjectivATI = uintptr ( getProcAddr ( " " ) ) gpGetVariantBooleanvEXT = uintptr ( getProcAddr ( " " ) ) gpGetVariantFloatvEXT = uintptr ( getProcAddr ( " " ) ) gpGetVariantIntegervEXT = uintptr ( getProcAddr ( " " ) ) gpGetVariantPointervEXT = uintptr ( getProcAddr ( " " ) ) gpGetVaryingLocationNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayIndexed64iv = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayIndexediv = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayIntegeri_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayIntegervEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayPointeri_vEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayPointervEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexArrayiv = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribArrayObjectfvATI = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribArrayObjectivATI = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribIivEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribIuivEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribLdv = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribLdvEXT = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribLi64vNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribLui64vARB = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribLui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribPointerv = uintptr ( getProcAddr ( " " ) ) if gpGetVertexAttribPointerv == 0 { return errors . New ( " " ) } gpGetVertexAttribPointervARB = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribPointervNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribdv = uintptr ( getProcAddr ( " " ) ) if gpGetVertexAttribdv == 0 { return errors . New ( " " ) } gpGetVertexAttribdvARB = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribdvNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribfv = uintptr ( getProcAddr ( " " ) ) if gpGetVertexAttribfv == 0 { return errors . New ( " " ) } gpGetVertexAttribfvARB = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribfvNV = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribiv = uintptr ( getProcAddr ( " " ) ) if gpGetVertexAttribiv == 0 { return errors . New ( " " ) } gpGetVertexAttribivARB = uintptr ( getProcAddr ( " " ) ) gpGetVertexAttribivNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoCaptureStreamdvNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoCaptureStreamfvNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoCaptureStreamivNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoCaptureivNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoi64vNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoivNV = uintptr ( getProcAddr ( " " ) ) gpGetVideoui64vNV = uintptr ( getProcAddr ( " " ) ) gpGetVideouivNV = uintptr ( getProcAddr ( " " ) ) gpGetVkProcAddrNV = uintptr ( getProcAddr ( " " ) ) gpGetnCompressedTexImageARB = uintptr ( getProcAddr ( " " ) ) gpGetnTexImageARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformdvARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformfv = uintptr ( getProcAddr ( " " ) ) gpGetnUniformfvARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformfvKHR = uintptr ( getProcAddr ( " " ) ) gpGetnUniformi64vARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformiv = uintptr ( getProcAddr ( " " ) ) gpGetnUniformivARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformivKHR = uintptr ( getProcAddr ( " " ) ) gpGetnUniformui64vARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformuiv = uintptr ( getProcAddr ( " " ) ) gpGetnUniformuivARB = uintptr ( getProcAddr ( " " ) ) gpGetnUniformuivKHR = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactorbSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactordSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactorfSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactoriSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactorsSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactorubSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactoruiSUN = uintptr ( getProcAddr ( " " ) ) gpGlobalAlphaFactorusSUN = uintptr ( getProcAddr ( " " ) ) gpHint = uintptr ( getProcAddr ( " " ) ) if gpHint == 0 { return errors . New ( " " ) } gpHintPGI = uintptr ( getProcAddr ( " " ) ) gpHistogramEXT = uintptr ( getProcAddr ( " " ) ) gpIglooInterfaceSGIX = uintptr ( getProcAddr ( " " ) ) gpImageTransformParameterfHP = uintptr ( getProcAddr ( " " ) ) gpImageTransformParameterfvHP = uintptr ( getProcAddr ( " " ) ) gpImageTransformParameteriHP = uintptr ( getProcAddr ( " " ) ) gpImageTransformParameterivHP = uintptr ( getProcAddr ( " " ) ) gpImportMemoryFdEXT = uintptr ( getProcAddr ( " " ) ) gpImportMemoryWin32HandleEXT = uintptr ( getProcAddr ( " " ) ) gpImportMemoryWin32NameEXT = uintptr ( getProcAddr ( " " ) ) gpImportSemaphoreFdEXT = uintptr ( getProcAddr ( " " ) ) gpImportSemaphoreWin32HandleEXT = uintptr ( getProcAddr ( " " ) ) gpImportSemaphoreWin32NameEXT = uintptr ( getProcAddr ( " " ) ) gpImportSyncEXT = uintptr ( getProcAddr ( " " ) ) gpIndexFormatNV = uintptr ( getProcAddr ( " " ) ) gpIndexFuncEXT = uintptr ( getProcAddr ( " " ) ) gpIndexMask = uintptr ( getProcAddr ( " " ) ) if gpIndexMask == 0 { return errors . New ( " " ) } gpIndexMaterialEXT = uintptr ( getProcAddr ( " " ) ) gpIndexPointer = uintptr ( getProcAddr ( " " ) ) if gpIndexPointer == 0 { return errors . New ( " " ) } gpIndexPointerEXT = uintptr ( getProcAddr ( " " ) ) gpIndexPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpIndexd = uintptr ( getProcAddr ( " " ) ) if gpIndexd == 0 { return errors . New ( " " ) } gpIndexdv = uintptr ( getProcAddr ( " " ) ) if gpIndexdv == 0 { return errors . New ( " " ) } gpIndexf = uintptr ( getProcAddr ( " " ) ) if gpIndexf == 0 { return errors . New ( " " ) } gpIndexfv = uintptr ( getProcAddr ( " " ) ) if gpIndexfv == 0 { return errors . New ( " " ) } gpIndexi = uintptr ( getProcAddr ( " " ) ) if gpIndexi == 0 { return errors . New ( " " ) } gpIndexiv = uintptr ( getProcAddr ( " " ) ) if gpIndexiv == 0 { return errors . New ( " " ) } gpIndexs = uintptr ( getProcAddr ( " " ) ) if gpIndexs == 0 { return errors . New ( " " ) } gpIndexsv = uintptr ( getProcAddr ( " " ) ) if gpIndexsv == 0 { return errors . New ( " " ) } gpIndexub = uintptr ( getProcAddr ( " " ) ) if gpIndexub == 0 { return errors . New ( " " ) } gpIndexubv = uintptr ( getProcAddr ( " " ) ) if gpIndexubv == 0 { return errors . New ( " " ) } gpIndexxOES = uintptr ( getProcAddr ( " " ) ) gpIndexxvOES = uintptr ( getProcAddr ( " " ) ) gpInitNames = uintptr ( getProcAddr ( " " ) ) if gpInitNames == 0 { return errors . New ( " " ) } gpInsertComponentEXT = uintptr ( getProcAddr ( " " ) ) gpInsertEventMarkerEXT = uintptr ( getProcAddr ( " " ) ) gpInstrumentsBufferSGIX = uintptr ( getProcAddr ( " " ) ) gpInterleavedArrays = uintptr ( getProcAddr ( " " ) ) if gpInterleavedArrays == 0 { return errors . New ( " " ) } gpInterpolatePathsNV = uintptr ( getProcAddr ( " " ) ) gpInvalidateBufferData = uintptr ( getProcAddr ( " " ) ) gpInvalidateBufferSubData = uintptr ( getProcAddr ( " " ) ) gpInvalidateFramebuffer = uintptr ( getProcAddr ( " " ) ) gpInvalidateNamedFramebufferData = uintptr ( getProcAddr ( " " ) ) gpInvalidateNamedFramebufferSubData = uintptr ( getProcAddr ( " " ) ) gpInvalidateSubFramebuffer = uintptr ( getProcAddr ( " " ) ) gpInvalidateTexImage = uintptr ( getProcAddr ( " " ) ) gpInvalidateTexSubImage = uintptr ( getProcAddr ( " " ) ) gpIsAsyncMarkerSGIX = uintptr ( getProcAddr ( " " ) ) gpIsBuffer = uintptr ( getProcAddr ( " " ) ) if gpIsBuffer == 0 { return errors . New ( " " ) } gpIsBufferARB = uintptr ( getProcAddr ( " " ) ) gpIsBufferResidentNV = uintptr ( getProcAddr ( " " ) ) gpIsCommandListNV = uintptr ( getProcAddr ( " " ) ) gpIsEnabled = uintptr ( getProcAddr ( " " ) ) if gpIsEnabled == 0 { return errors . New ( " " ) } gpIsEnabledIndexedEXT = uintptr ( getProcAddr ( " " ) ) gpIsFenceAPPLE = uintptr ( getProcAddr ( " " ) ) gpIsFenceNV = uintptr ( getProcAddr ( " " ) ) gpIsFramebuffer = uintptr ( getProcAddr ( " " ) ) gpIsFramebufferEXT = uintptr ( getProcAddr ( " " ) ) gpIsImageHandleResidentARB = uintptr ( getProcAddr ( " " ) ) gpIsImageHandleResidentNV = uintptr ( getProcAddr ( " " ) ) gpIsList = uintptr ( getProcAddr ( " " ) ) if gpIsList == 0 { return errors . New ( " " ) } gpIsMemoryObjectEXT = uintptr ( getProcAddr ( " " ) ) gpIsNameAMD = uintptr ( getProcAddr ( " " ) ) gpIsNamedBufferResidentNV = uintptr ( getProcAddr ( " " ) ) gpIsNamedStringARB = uintptr ( getProcAddr ( " " ) ) gpIsObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpIsOcclusionQueryNV = uintptr ( getProcAddr ( " " ) ) gpIsPathNV = uintptr ( getProcAddr ( " " ) ) gpIsPointInFillPathNV = uintptr ( getProcAddr ( " " ) ) gpIsPointInStrokePathNV = uintptr ( getProcAddr ( " " ) ) gpIsProgram = uintptr ( getProcAddr ( " " ) ) if gpIsProgram == 0 { return errors . New ( " " ) } gpIsProgramARB = uintptr ( getProcAddr ( " " ) ) gpIsProgramNV = uintptr ( getProcAddr ( " " ) ) gpIsProgramPipeline = uintptr ( getProcAddr ( " " ) ) gpIsProgramPipelineEXT = uintptr ( getProcAddr ( " " ) ) gpIsQuery = uintptr ( getProcAddr ( " " ) ) if gpIsQuery == 0 { return errors . New ( " " ) } gpIsQueryARB = uintptr ( getProcAddr ( " " ) ) gpIsRenderbuffer = uintptr ( getProcAddr ( " " ) ) gpIsRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpIsSampler = uintptr ( getProcAddr ( " " ) ) gpIsSemaphoreEXT = uintptr ( getProcAddr ( " " ) ) gpIsShader = uintptr ( getProcAddr ( " " ) ) if gpIsShader == 0 { return errors . New ( " " ) } gpIsStateNV = uintptr ( getProcAddr ( " " ) ) gpIsSync = uintptr ( getProcAddr ( " " ) ) gpIsTexture = uintptr ( getProcAddr ( " " ) ) if gpIsTexture == 0 { return errors . New ( " " ) } gpIsTextureEXT = uintptr ( getProcAddr ( " " ) ) gpIsTextureHandleResidentARB = uintptr ( getProcAddr ( " " ) ) gpIsTextureHandleResidentNV = uintptr ( getProcAddr ( " " ) ) gpIsTransformFeedback = uintptr ( getProcAddr ( " " ) ) gpIsTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpIsVariantEnabledEXT = uintptr ( getProcAddr ( " " ) ) gpIsVertexArray = uintptr ( getProcAddr ( " " ) ) gpIsVertexArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpIsVertexAttribEnabledAPPLE = uintptr ( getProcAddr ( " " ) ) gpLGPUCopyImageSubDataNVX = uintptr ( getProcAddr ( " " ) ) gpLGPUInterlockNVX = uintptr ( getProcAddr ( " " ) ) gpLGPUNamedBufferSubDataNVX = uintptr ( getProcAddr ( " " ) ) gpLabelObjectEXT = uintptr ( getProcAddr ( " " ) ) gpLightEnviSGIX = uintptr ( getProcAddr ( " " ) ) gpLightModelf = uintptr ( getProcAddr ( " " ) ) if gpLightModelf == 0 { return errors . New ( " " ) } gpLightModelfv = uintptr ( getProcAddr ( " " ) ) if gpLightModelfv == 0 { return errors . New ( " " ) } gpLightModeli = uintptr ( getProcAddr ( " " ) ) if gpLightModeli == 0 { return errors . New ( " " ) } gpLightModeliv = uintptr ( getProcAddr ( " " ) ) if gpLightModeliv == 0 { return errors . New ( " " ) } gpLightModelxOES = uintptr ( getProcAddr ( " " ) ) gpLightModelxvOES = uintptr ( getProcAddr ( " " ) ) gpLightf = uintptr ( getProcAddr ( " " ) ) if gpLightf == 0 { return errors . New ( " " ) } gpLightfv = uintptr ( getProcAddr ( " " ) ) if gpLightfv == 0 { return errors . New ( " " ) } gpLighti = uintptr ( getProcAddr ( " " ) ) if gpLighti == 0 { return errors . New ( " " ) } gpLightiv = uintptr ( getProcAddr ( " " ) ) if gpLightiv == 0 { return errors . New ( " " ) } gpLightxOES = uintptr ( getProcAddr ( " " ) ) gpLightxvOES = uintptr ( getProcAddr ( " " ) ) gpLineStipple = uintptr ( getProcAddr ( " " ) ) if gpLineStipple == 0 { return errors . New ( " " ) } gpLineWidth = uintptr ( getProcAddr ( " " ) ) if gpLineWidth == 0 { return errors . New ( " " ) } gpLineWidthxOES = uintptr ( getProcAddr ( " " ) ) gpLinkProgram = uintptr ( getProcAddr ( " " ) ) if gpLinkProgram == 0 { return errors . New ( " " ) } gpLinkProgramARB = uintptr ( getProcAddr ( " " ) ) gpListBase = uintptr ( getProcAddr ( " " ) ) if gpListBase == 0 { return errors . New ( " " ) } gpListDrawCommandsStatesClientNV = uintptr ( getProcAddr ( " " ) ) gpListParameterfSGIX = uintptr ( getProcAddr ( " " ) ) gpListParameterfvSGIX = uintptr ( getProcAddr ( " " ) ) gpListParameteriSGIX = uintptr ( getProcAddr ( " " ) ) gpListParameterivSGIX = uintptr ( getProcAddr ( " " ) ) gpLoadIdentity = uintptr ( getProcAddr ( " " ) ) if gpLoadIdentity == 0 { return errors . New ( " " ) } gpLoadIdentityDeformationMapSGIX = uintptr ( getProcAddr ( " " ) ) gpLoadMatrixd = uintptr ( getProcAddr ( " " ) ) if gpLoadMatrixd == 0 { return errors . New ( " " ) } gpLoadMatrixf = uintptr ( getProcAddr ( " " ) ) if gpLoadMatrixf == 0 { return errors . New ( " " ) } gpLoadMatrixxOES = uintptr ( getProcAddr ( " " ) ) gpLoadName = uintptr ( getProcAddr ( " " ) ) if gpLoadName == 0 { return errors . New ( " " ) } gpLoadProgramNV = uintptr ( getProcAddr ( " " ) ) gpLoadTransposeMatrixd = uintptr ( getProcAddr ( " " ) ) if gpLoadTransposeMatrixd == 0 { return errors . New ( " " ) } gpLoadTransposeMatrixdARB = uintptr ( getProcAddr ( " " ) ) gpLoadTransposeMatrixf = uintptr ( getProcAddr ( " " ) ) if gpLoadTransposeMatrixf == 0 { return errors . New ( " " ) } gpLoadTransposeMatrixfARB = uintptr ( getProcAddr ( " " ) ) gpLoadTransposeMatrixxOES = uintptr ( getProcAddr ( " " ) ) gpLockArraysEXT = uintptr ( getProcAddr ( " " ) ) gpLogicOp = uintptr ( getProcAddr ( " " ) ) if gpLogicOp == 0 { return errors . New ( " " ) } gpMakeBufferNonResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeBufferResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeImageHandleNonResidentARB = uintptr ( getProcAddr ( " " ) ) gpMakeImageHandleNonResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeImageHandleResidentARB = uintptr ( getProcAddr ( " " ) ) gpMakeImageHandleResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeNamedBufferNonResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeNamedBufferResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeTextureHandleNonResidentARB = uintptr ( getProcAddr ( " " ) ) gpMakeTextureHandleNonResidentNV = uintptr ( getProcAddr ( " " ) ) gpMakeTextureHandleResidentARB = uintptr ( getProcAddr ( " " ) ) gpMakeTextureHandleResidentNV = uintptr ( getProcAddr ( " " ) ) gpMap1d = uintptr ( getProcAddr ( " " ) ) if gpMap1d == 0 { return errors . New ( " " ) } gpMap1f = uintptr ( getProcAddr ( " " ) ) if gpMap1f == 0 { return errors . New ( " " ) } gpMap1xOES = uintptr ( getProcAddr ( " " ) ) gpMap2d = uintptr ( getProcAddr ( " " ) ) if gpMap2d == 0 { return errors . New ( " " ) } gpMap2f = uintptr ( getProcAddr ( " " ) ) if gpMap2f == 0 { return errors . New ( " " ) } gpMap2xOES = uintptr ( getProcAddr ( " " ) ) gpMapBuffer = uintptr ( getProcAddr ( " " ) ) if gpMapBuffer == 0 { return errors . New ( " " ) } gpMapBufferARB = uintptr ( getProcAddr ( " " ) ) gpMapBufferRange = uintptr ( getProcAddr ( " " ) ) gpMapControlPointsNV = uintptr ( getProcAddr ( " " ) ) gpMapGrid1d = uintptr ( getProcAddr ( " " ) ) if gpMapGrid1d == 0 { return errors . New ( " " ) } gpMapGrid1f = uintptr ( getProcAddr ( " " ) ) if gpMapGrid1f == 0 { return errors . New ( " " ) } gpMapGrid1xOES = uintptr ( getProcAddr ( " " ) ) gpMapGrid2d = uintptr ( getProcAddr ( " " ) ) if gpMapGrid2d == 0 { return errors . New ( " " ) } gpMapGrid2f = uintptr ( getProcAddr ( " " ) ) if gpMapGrid2f == 0 { return errors . New ( " " ) } gpMapGrid2xOES = uintptr ( getProcAddr ( " " ) ) gpMapNamedBuffer = uintptr ( getProcAddr ( " " ) ) gpMapNamedBufferEXT = uintptr ( getProcAddr ( " " ) ) gpMapNamedBufferRange = uintptr ( getProcAddr ( " " ) ) gpMapNamedBufferRangeEXT = uintptr ( getProcAddr ( " " ) ) gpMapObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpMapParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpMapParameterivNV = uintptr ( getProcAddr ( " " ) ) gpMapTexture2DINTEL = uintptr ( getProcAddr ( " " ) ) gpMapVertexAttrib1dAPPLE = uintptr ( getProcAddr ( " " ) ) gpMapVertexAttrib1fAPPLE = uintptr ( getProcAddr ( " " ) ) gpMapVertexAttrib2dAPPLE = uintptr ( getProcAddr ( " " ) ) gpMapVertexAttrib2fAPPLE = uintptr ( getProcAddr ( " " ) ) gpMaterialf = uintptr ( getProcAddr ( " " ) ) if gpMaterialf == 0 { return errors . New ( " " ) } gpMaterialfv = uintptr ( getProcAddr ( " " ) ) if gpMaterialfv == 0 { return errors . New ( " " ) } gpMateriali = uintptr ( getProcAddr ( " " ) ) if gpMateriali == 0 { return errors . New ( " " ) } gpMaterialiv = uintptr ( getProcAddr ( " " ) ) if gpMaterialiv == 0 { return errors . New ( " " ) } gpMaterialxOES = uintptr ( getProcAddr ( " " ) ) gpMaterialxvOES = uintptr ( getProcAddr ( " " ) ) gpMatrixFrustumEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixIndexPointerARB = uintptr ( getProcAddr ( " " ) ) gpMatrixIndexubvARB = uintptr ( getProcAddr ( " " ) ) gpMatrixIndexuivARB = uintptr ( getProcAddr ( " " ) ) gpMatrixIndexusvARB = uintptr ( getProcAddr ( " " ) ) gpMatrixLoad3x2fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixLoad3x3fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixLoadIdentityEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixLoadTranspose3x3fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixLoadTransposedEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixLoadTransposefEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixLoaddEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixLoadfEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixMode = uintptr ( getProcAddr ( " " ) ) if gpMatrixMode == 0 { return errors . New ( " " ) } gpMatrixMult3x2fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixMult3x3fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixMultTranspose3x3fNV = uintptr ( getProcAddr ( " " ) ) gpMatrixMultTransposedEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixMultTransposefEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixMultdEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixMultfEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixOrthoEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixPopEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixPushEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixRotatedEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixRotatefEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixScaledEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixScalefEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixTranslatedEXT = uintptr ( getProcAddr ( " " ) ) gpMatrixTranslatefEXT = uintptr ( getProcAddr ( " " ) ) gpMaxShaderCompilerThreadsARB = uintptr ( getProcAddr ( " " ) ) gpMaxShaderCompilerThreadsKHR = uintptr ( getProcAddr ( " " ) ) gpMemoryBarrier = uintptr ( getProcAddr ( " " ) ) gpMemoryBarrierByRegion = uintptr ( getProcAddr ( " " ) ) gpMemoryBarrierEXT = uintptr ( getProcAddr ( " " ) ) gpMemoryObjectParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpMinSampleShadingARB = uintptr ( getProcAddr ( " " ) ) gpMinmaxEXT = uintptr ( getProcAddr ( " " ) ) gpMultMatrixd = uintptr ( getProcAddr ( " " ) ) if gpMultMatrixd == 0 { return errors . New ( " " ) } gpMultMatrixf = uintptr ( getProcAddr ( " " ) ) if gpMultMatrixf == 0 { return errors . New ( " " ) } gpMultMatrixxOES = uintptr ( getProcAddr ( " " ) ) gpMultTransposeMatrixd = uintptr ( getProcAddr ( " " ) ) if gpMultTransposeMatrixd == 0 { return errors . New ( " " ) } gpMultTransposeMatrixdARB = uintptr ( getProcAddr ( " " ) ) gpMultTransposeMatrixf = uintptr ( getProcAddr ( " " ) ) if gpMultTransposeMatrixf == 0 { return errors . New ( " " ) } gpMultTransposeMatrixfARB = uintptr ( getProcAddr ( " " ) ) gpMultTransposeMatrixxOES = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArrays = uintptr ( getProcAddr ( " " ) ) if gpMultiDrawArrays == 0 { return errors . New ( " " ) } gpMultiDrawArraysEXT = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArraysIndirect = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArraysIndirectAMD = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArraysIndirectBindlessCountNV = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArraysIndirectBindlessNV = uintptr ( getProcAddr ( " " ) ) gpMultiDrawArraysIndirectCountARB = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElements = uintptr ( getProcAddr ( " " ) ) if gpMultiDrawElements == 0 { return errors . New ( " " ) } gpMultiDrawElementsBaseVertex = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsEXT = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsIndirect = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsIndirectAMD = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsIndirectBindlessCountNV = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsIndirectBindlessNV = uintptr ( getProcAddr ( " " ) ) gpMultiDrawElementsIndirectCountARB = uintptr ( getProcAddr ( " " ) ) gpMultiDrawRangeElementArrayAPPLE = uintptr ( getProcAddr ( " " ) ) gpMultiModeDrawArraysIBM = uintptr ( getProcAddr ( " " ) ) gpMultiModeDrawElementsIBM = uintptr ( getProcAddr ( " " ) ) gpMultiTexBufferEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1bOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1bvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1d = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1d == 0 { return errors . New ( " " ) } gpMultiTexCoord1dARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1dv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1dv == 0 { return errors . New ( " " ) } gpMultiTexCoord1dvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1f = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1f == 0 { return errors . New ( " " ) } gpMultiTexCoord1fARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1fv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1fv == 0 { return errors . New ( " " ) } gpMultiTexCoord1fvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1hNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1hvNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1i = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1i == 0 { return errors . New ( " " ) } gpMultiTexCoord1iARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1iv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1iv == 0 { return errors . New ( " " ) } gpMultiTexCoord1ivARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1s = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1s == 0 { return errors . New ( " " ) } gpMultiTexCoord1sARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1sv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord1sv == 0 { return errors . New ( " " ) } gpMultiTexCoord1svARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1xOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord1xvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2bOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2bvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2d = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2d == 0 { return errors . New ( " " ) } gpMultiTexCoord2dARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2dv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2dv == 0 { return errors . New ( " " ) } gpMultiTexCoord2dvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2f = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2f == 0 { return errors . New ( " " ) } gpMultiTexCoord2fARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2fv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2fv == 0 { return errors . New ( " " ) } gpMultiTexCoord2fvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2hNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2hvNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2i = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2i == 0 { return errors . New ( " " ) } gpMultiTexCoord2iARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2iv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2iv == 0 { return errors . New ( " " ) } gpMultiTexCoord2ivARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2s = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2s == 0 { return errors . New ( " " ) } gpMultiTexCoord2sARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2sv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord2sv == 0 { return errors . New ( " " ) } gpMultiTexCoord2svARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2xOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord2xvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3bOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3bvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3d = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3d == 0 { return errors . New ( " " ) } gpMultiTexCoord3dARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3dv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3dv == 0 { return errors . New ( " " ) } gpMultiTexCoord3dvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3f = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3f == 0 { return errors . New ( " " ) } gpMultiTexCoord3fARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3fv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3fv == 0 { return errors . New ( " " ) } gpMultiTexCoord3fvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3hNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3hvNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3i = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3i == 0 { return errors . New ( " " ) } gpMultiTexCoord3iARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3iv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3iv == 0 { return errors . New ( " " ) } gpMultiTexCoord3ivARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3s = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3s == 0 { return errors . New ( " " ) } gpMultiTexCoord3sARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3sv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord3sv == 0 { return errors . New ( " " ) } gpMultiTexCoord3svARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3xOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord3xvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4bOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4bvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4d = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4d == 0 { return errors . New ( " " ) } gpMultiTexCoord4dARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4dv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4dv == 0 { return errors . New ( " " ) } gpMultiTexCoord4dvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4f = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4f == 0 { return errors . New ( " " ) } gpMultiTexCoord4fARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4fv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4fv == 0 { return errors . New ( " " ) } gpMultiTexCoord4fvARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4hNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4hvNV = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4i = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4i == 0 { return errors . New ( " " ) } gpMultiTexCoord4iARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4iv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4iv == 0 { return errors . New ( " " ) } gpMultiTexCoord4ivARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4s = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4s == 0 { return errors . New ( " " ) } gpMultiTexCoord4sARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4sv = uintptr ( getProcAddr ( " " ) ) if gpMultiTexCoord4sv == 0 { return errors . New ( " " ) } gpMultiTexCoord4svARB = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4xOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoord4xvOES = uintptr ( getProcAddr ( " " ) ) gpMultiTexCoordPointerEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexEnvfEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexEnvfvEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexEnviEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexEnvivEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGendEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGendvEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGenfEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGenfvEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGeniEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexGenivEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameterfEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpMultiTexSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpMulticastBarrierNV = uintptr ( getProcAddr ( " " ) ) gpMulticastBlitFramebufferNV = uintptr ( getProcAddr ( " " ) ) gpMulticastBufferSubDataNV = uintptr ( getProcAddr ( " " ) ) gpMulticastCopyBufferSubDataNV = uintptr ( getProcAddr ( " " ) ) gpMulticastCopyImageSubDataNV = uintptr ( getProcAddr ( " " ) ) gpMulticastFramebufferSampleLocationsfvNV = uintptr ( getProcAddr ( " " ) ) gpMulticastGetQueryObjecti64vNV = uintptr ( getProcAddr ( " " ) ) gpMulticastGetQueryObjectivNV = uintptr ( getProcAddr ( " " ) ) gpMulticastGetQueryObjectui64vNV = uintptr ( getProcAddr ( " " ) ) gpMulticastGetQueryObjectuivNV = uintptr ( getProcAddr ( " " ) ) gpMulticastWaitSyncNV = uintptr ( getProcAddr ( " " ) ) gpNamedBufferData = uintptr ( getProcAddr ( " " ) ) gpNamedBufferDataEXT = uintptr ( getProcAddr ( " " ) ) gpNamedBufferPageCommitmentARB = uintptr ( getProcAddr ( " " ) ) gpNamedBufferPageCommitmentEXT = uintptr ( getProcAddr ( " " ) ) gpNamedBufferStorage = uintptr ( getProcAddr ( " " ) ) gpNamedBufferStorageEXT = uintptr ( getProcAddr ( " " ) ) gpNamedBufferStorageExternalEXT = uintptr ( getProcAddr ( " " ) ) gpNamedBufferStorageMemEXT = uintptr ( getProcAddr ( " " ) ) gpNamedBufferSubData = uintptr ( getProcAddr ( " " ) ) gpNamedBufferSubDataEXT = uintptr ( getProcAddr ( " " ) ) gpNamedCopyBufferSubDataEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferDrawBuffer = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferDrawBuffers = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferParameteri = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferReadBuffer = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferRenderbuffer = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferSampleLocationsfvARB = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferSampleLocationsfvNV = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferSamplePositionsfvAMD = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTexture = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTexture1DEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTexture2DEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTexture3DEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTextureEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTextureFaceEXT = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTextureLayer = uintptr ( getProcAddr ( " " ) ) gpNamedFramebufferTextureLayerEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameter4dEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameter4dvEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameter4fEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameter4fvEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameterI4iEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameterI4ivEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameterI4uiEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameterI4uivEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParameters4fvEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParametersI4ivEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramLocalParametersI4uivEXT = uintptr ( getProcAddr ( " " ) ) gpNamedProgramStringEXT = uintptr ( getProcAddr ( " " ) ) gpNamedRenderbufferStorage = uintptr ( getProcAddr ( " " ) ) gpNamedRenderbufferStorageEXT = uintptr ( getProcAddr ( " " ) ) gpNamedRenderbufferStorageMultisample = uintptr ( getProcAddr ( " " ) ) gpNamedRenderbufferStorageMultisampleCoverageEXT = uintptr ( getProcAddr ( " " ) ) gpNamedRenderbufferStorageMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpNamedStringARB = uintptr ( getProcAddr ( " " ) ) gpNewList = uintptr ( getProcAddr ( " " ) ) if gpNewList == 0 { return errors . New ( " " ) } gpNewObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpNormal3b = uintptr ( getProcAddr ( " " ) ) if gpNormal3b == 0 { return errors . New ( " " ) } gpNormal3bv = uintptr ( getProcAddr ( " " ) ) if gpNormal3bv == 0 { return errors . New ( " " ) } gpNormal3d = uintptr ( getProcAddr ( " " ) ) if gpNormal3d == 0 { return errors . New ( " " ) } gpNormal3dv = uintptr ( getProcAddr ( " " ) ) if gpNormal3dv == 0 { return errors . New ( " " ) } gpNormal3f = uintptr ( getProcAddr ( " " ) ) if gpNormal3f == 0 { return errors . New ( " " ) } gpNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpNormal3fv = uintptr ( getProcAddr ( " " ) ) if gpNormal3fv == 0 { return errors . New ( " " ) } gpNormal3hNV = uintptr ( getProcAddr ( " " ) ) gpNormal3hvNV = uintptr ( getProcAddr ( " " ) ) gpNormal3i = uintptr ( getProcAddr ( " " ) ) if gpNormal3i == 0 { return errors . New ( " " ) } gpNormal3iv = uintptr ( getProcAddr ( " " ) ) if gpNormal3iv == 0 { return errors . New ( " " ) } gpNormal3s = uintptr ( getProcAddr ( " " ) ) if gpNormal3s == 0 { return errors . New ( " " ) } gpNormal3sv = uintptr ( getProcAddr ( " " ) ) if gpNormal3sv == 0 { return errors . New ( " " ) } gpNormal3xOES = uintptr ( getProcAddr ( " " ) ) gpNormal3xvOES = uintptr ( getProcAddr ( " " ) ) gpNormalFormatNV = uintptr ( getProcAddr ( " " ) ) gpNormalPointer = uintptr ( getProcAddr ( " " ) ) if gpNormalPointer == 0 { return errors . New ( " " ) } gpNormalPointerEXT = uintptr ( getProcAddr ( " " ) ) gpNormalPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpNormalPointervINTEL = uintptr ( getProcAddr ( " " ) ) gpNormalStream3bATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3bvATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3dATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3dvATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3fATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3fvATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3iATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3ivATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3sATI = uintptr ( getProcAddr ( " " ) ) gpNormalStream3svATI = uintptr ( getProcAddr ( " " ) ) gpObjectLabel = uintptr ( getProcAddr ( " " ) ) gpObjectLabelKHR = uintptr ( getProcAddr ( " " ) ) gpObjectPtrLabel = uintptr ( getProcAddr ( " " ) ) gpObjectPtrLabelKHR = uintptr ( getProcAddr ( " " ) ) gpObjectPurgeableAPPLE = uintptr ( getProcAddr ( " " ) ) gpObjectUnpurgeableAPPLE = uintptr ( getProcAddr ( " " ) ) gpOrtho = uintptr ( getProcAddr ( " " ) ) if gpOrtho == 0 { return errors . New ( " " ) } gpOrthofOES = uintptr ( getProcAddr ( " " ) ) gpOrthoxOES = uintptr ( getProcAddr ( " " ) ) gpPNTrianglesfATI = uintptr ( getProcAddr ( " " ) ) gpPNTrianglesiATI = uintptr ( getProcAddr ( " " ) ) gpPassTexCoordATI = uintptr ( getProcAddr ( " " ) ) gpPassThrough = uintptr ( getProcAddr ( " " ) ) if gpPassThrough == 0 { return errors . New ( " " ) } gpPassThroughxOES = uintptr ( getProcAddr ( " " ) ) gpPatchParameterfv = uintptr ( getProcAddr ( " " ) ) gpPatchParameteri = uintptr ( getProcAddr ( " " ) ) gpPathCommandsNV = uintptr ( getProcAddr ( " " ) ) gpPathCoordsNV = uintptr ( getProcAddr ( " " ) ) gpPathCoverDepthFuncNV = uintptr ( getProcAddr ( " " ) ) gpPathDashArrayNV = uintptr ( getProcAddr ( " " ) ) gpPathGlyphIndexArrayNV = uintptr ( getProcAddr ( " " ) ) gpPathGlyphIndexRangeNV = uintptr ( getProcAddr ( " " ) ) gpPathGlyphRangeNV = uintptr ( getProcAddr ( " " ) ) gpPathGlyphsNV = uintptr ( getProcAddr ( " " ) ) gpPathMemoryGlyphIndexArrayNV = uintptr ( getProcAddr ( " " ) ) gpPathParameterfNV = uintptr ( getProcAddr ( " " ) ) gpPathParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpPathParameteriNV = uintptr ( getProcAddr ( " " ) ) gpPathParameterivNV = uintptr ( getProcAddr ( " " ) ) gpPathStencilDepthOffsetNV = uintptr ( getProcAddr ( " " ) ) gpPathStencilFuncNV = uintptr ( getProcAddr ( " " ) ) gpPathStringNV = uintptr ( getProcAddr ( " " ) ) gpPathSubCommandsNV = uintptr ( getProcAddr ( " " ) ) gpPathSubCoordsNV = uintptr ( getProcAddr ( " " ) ) gpPauseTransformFeedback = uintptr ( getProcAddr ( " " ) ) gpPauseTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpPixelDataRangeNV = uintptr ( getProcAddr ( " " ) ) gpPixelMapfv = uintptr ( getProcAddr ( " " ) ) if gpPixelMapfv == 0 { return errors . New ( " " ) } gpPixelMapuiv = uintptr ( getProcAddr ( " " ) ) if gpPixelMapuiv == 0 { return errors . New ( " " ) } gpPixelMapusv = uintptr ( getProcAddr ( " " ) ) if gpPixelMapusv == 0 { return errors . New ( " " ) } gpPixelMapx = uintptr ( getProcAddr ( " " ) ) gpPixelStoref = uintptr ( getProcAddr ( " " ) ) if gpPixelStoref == 0 { return errors . New ( " " ) } gpPixelStorei = uintptr ( getProcAddr ( " " ) ) if gpPixelStorei == 0 { return errors . New ( " " ) } gpPixelStorex = uintptr ( getProcAddr ( " " ) ) gpPixelTexGenParameterfSGIS = uintptr ( getProcAddr ( " " ) ) gpPixelTexGenParameterfvSGIS = uintptr ( getProcAddr ( " " ) ) gpPixelTexGenParameteriSGIS = uintptr ( getProcAddr ( " " ) ) gpPixelTexGenParameterivSGIS = uintptr ( getProcAddr ( " " ) ) gpPixelTexGenSGIX = uintptr ( getProcAddr ( " " ) ) gpPixelTransferf = uintptr ( getProcAddr ( " " ) ) if gpPixelTransferf == 0 { return errors . New ( " " ) } gpPixelTransferi = uintptr ( getProcAddr ( " " ) ) if gpPixelTransferi == 0 { return errors . New ( " " ) } gpPixelTransferxOES = uintptr ( getProcAddr ( " " ) ) gpPixelTransformParameterfEXT = uintptr ( getProcAddr ( " " ) ) gpPixelTransformParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpPixelTransformParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpPixelTransformParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpPixelZoom = uintptr ( getProcAddr ( " " ) ) if gpPixelZoom == 0 { return errors . New ( " " ) } gpPixelZoomxOES = uintptr ( getProcAddr ( " " ) ) gpPointAlongPathNV = uintptr ( getProcAddr ( " " ) ) gpPointParameterf = uintptr ( getProcAddr ( " " ) ) if gpPointParameterf == 0 { return errors . New ( " " ) } gpPointParameterfARB = uintptr ( getProcAddr ( " " ) ) gpPointParameterfEXT = uintptr ( getProcAddr ( " " ) ) gpPointParameterfSGIS = uintptr ( getProcAddr ( " " ) ) gpPointParameterfv = uintptr ( getProcAddr ( " " ) ) if gpPointParameterfv == 0 { return errors . New ( " " ) } gpPointParameterfvARB = uintptr ( getProcAddr ( " " ) ) gpPointParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpPointParameterfvSGIS = uintptr ( getProcAddr ( " " ) ) gpPointParameteri = uintptr ( getProcAddr ( " " ) ) if gpPointParameteri == 0 { return errors . New ( " " ) } gpPointParameteriNV = uintptr ( getProcAddr ( " " ) ) gpPointParameteriv = uintptr ( getProcAddr ( " " ) ) if gpPointParameteriv == 0 { return errors . New ( " " ) } gpPointParameterivNV = uintptr ( getProcAddr ( " " ) ) gpPointParameterxOES = uintptr ( getProcAddr ( " " ) ) gpPointParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpPointSize = uintptr ( getProcAddr ( " " ) ) if gpPointSize == 0 { return errors . New ( " " ) } gpPointSizexOES = uintptr ( getProcAddr ( " " ) ) gpPollAsyncSGIX = uintptr ( getProcAddr ( " " ) ) gpPollInstrumentsSGIX = uintptr ( getProcAddr ( " " ) ) gpPolygonMode = uintptr ( getProcAddr ( " " ) ) if gpPolygonMode == 0 { return errors . New ( " " ) } gpPolygonOffset = uintptr ( getProcAddr ( " " ) ) if gpPolygonOffset == 0 { return errors . New ( " " ) } gpPolygonOffsetClamp = uintptr ( getProcAddr ( " " ) ) gpPolygonOffsetClampEXT = uintptr ( getProcAddr ( " " ) ) gpPolygonOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpPolygonOffsetxOES = uintptr ( getProcAddr ( " " ) ) gpPolygonStipple = uintptr ( getProcAddr ( " " ) ) if gpPolygonStipple == 0 { return errors . New ( " " ) } gpPopAttrib = uintptr ( getProcAddr ( " " ) ) if gpPopAttrib == 0 { return errors . New ( " " ) } gpPopClientAttrib = uintptr ( getProcAddr ( " " ) ) if gpPopClientAttrib == 0 { return errors . New ( " " ) } gpPopDebugGroup = uintptr ( getProcAddr ( " " ) ) gpPopDebugGroupKHR = uintptr ( getProcAddr ( " " ) ) gpPopGroupMarkerEXT = uintptr ( getProcAddr ( " " ) ) gpPopMatrix = uintptr ( getProcAddr ( " " ) ) if gpPopMatrix == 0 { return errors . New ( " " ) } gpPopName = uintptr ( getProcAddr ( " " ) ) if gpPopName == 0 { return errors . New ( " " ) } gpPresentFrameDualFillNV = uintptr ( getProcAddr ( " " ) ) gpPresentFrameKeyedNV = uintptr ( getProcAddr ( " " ) ) gpPrimitiveBoundingBoxARB = uintptr ( getProcAddr ( " " ) ) gpPrimitiveRestartIndexNV = uintptr ( getProcAddr ( " " ) ) gpPrimitiveRestartNV = uintptr ( getProcAddr ( " " ) ) gpPrioritizeTextures = uintptr ( getProcAddr ( " " ) ) if gpPrioritizeTextures == 0 { return errors . New ( " " ) } gpPrioritizeTexturesEXT = uintptr ( getProcAddr ( " " ) ) gpPrioritizeTexturesxOES = uintptr ( getProcAddr ( " " ) ) gpProgramBinary = uintptr ( getProcAddr ( " " ) ) gpProgramBufferParametersIivNV = uintptr ( getProcAddr ( " " ) ) gpProgramBufferParametersIuivNV = uintptr ( getProcAddr ( " " ) ) gpProgramBufferParametersfvNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameter4dARB = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameter4dvARB = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameter4fARB = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameter4fvARB = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameterI4iNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameterI4ivNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameterI4uiNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameterI4uivNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParameters4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParametersI4ivNV = uintptr ( getProcAddr ( " " ) ) gpProgramEnvParametersI4uivNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameter4dARB = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameter4dvARB = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameter4fARB = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameter4fvARB = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameterI4iNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameterI4ivNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameterI4uiNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameterI4uivNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParameters4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParametersI4ivNV = uintptr ( getProcAddr ( " " ) ) gpProgramLocalParametersI4uivNV = uintptr ( getProcAddr ( " " ) ) gpProgramNamedParameter4dNV = uintptr ( getProcAddr ( " " ) ) gpProgramNamedParameter4dvNV = uintptr ( getProcAddr ( " " ) ) gpProgramNamedParameter4fNV = uintptr ( getProcAddr ( " " ) ) gpProgramNamedParameter4fvNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameter4dNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameter4dvNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameter4fNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameter4fvNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameteri = uintptr ( getProcAddr ( " " ) ) gpProgramParameteriARB = uintptr ( getProcAddr ( " " ) ) gpProgramParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpProgramParameters4dvNV = uintptr ( getProcAddr ( " " ) ) gpProgramParameters4fvNV = uintptr ( getProcAddr ( " " ) ) gpProgramPathFragmentInputGenNV = uintptr ( getProcAddr ( " " ) ) gpProgramStringARB = uintptr ( getProcAddr ( " " ) ) gpProgramSubroutineParametersuivNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1d = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1dEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1f = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1fEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1i = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1i64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1i64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1i64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1i64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1iEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1iv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ui = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ui64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ui64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1ui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1uiEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1uiv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform1uivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2d = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2dEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2f = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2fEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2i = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2i64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2i64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2i64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2i64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2iEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2iv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ui = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ui64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ui64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2ui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2uiEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2uiv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform2uivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3d = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3dEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3f = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3fEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3i = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3i64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3i64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3i64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3i64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3iEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3iv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ui = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ui64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ui64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3ui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3uiEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3uiv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform3uivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4d = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4dEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4f = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4fEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4i = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4i64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4i64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4i64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4i64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4iEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4iv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ui = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ui64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ui64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4ui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4uiEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4uiv = uintptr ( getProcAddr ( " " ) ) gpProgramUniform4uivEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformHandleui64ARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniformHandleui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniformHandleui64vARB = uintptr ( getProcAddr ( " " ) ) gpProgramUniformHandleui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x3dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x3dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x3fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x3fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x4dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x4dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x4fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix2x4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x2dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x2dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x2fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x2fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x4dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x4dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x4fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix3x4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x2dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x2dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x2fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x2fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x3dv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x3dvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x3fv = uintptr ( getProcAddr ( " " ) ) gpProgramUniformMatrix4x3fvEXT = uintptr ( getProcAddr ( " " ) ) gpProgramUniformui64NV = uintptr ( getProcAddr ( " " ) ) gpProgramUniformui64vNV = uintptr ( getProcAddr ( " " ) ) gpProgramVertexLimitNV = uintptr ( getProcAddr ( " " ) ) gpProvokingVertex = uintptr ( getProcAddr ( " " ) ) gpProvokingVertexEXT = uintptr ( getProcAddr ( " " ) ) gpPushAttrib = uintptr ( getProcAddr ( " " ) ) if gpPushAttrib == 0 { return errors . New ( " " ) } gpPushClientAttrib = uintptr ( getProcAddr ( " " ) ) if gpPushClientAttrib == 0 { return errors . New ( " " ) } gpPushClientAttribDefaultEXT = uintptr ( getProcAddr ( " " ) ) gpPushDebugGroup = uintptr ( getProcAddr ( " " ) ) gpPushDebugGroupKHR = uintptr ( getProcAddr ( " " ) ) gpPushGroupMarkerEXT = uintptr ( getProcAddr ( " " ) ) gpPushMatrix = uintptr ( getProcAddr ( " " ) ) if gpPushMatrix == 0 { return errors . New ( " " ) } gpPushName = uintptr ( getProcAddr ( " " ) ) if gpPushName == 0 { return errors . New ( " " ) } gpQueryCounter = uintptr ( getProcAddr ( " " ) ) gpQueryMatrixxOES = uintptr ( getProcAddr ( " " ) ) gpQueryObjectParameteruiAMD = uintptr ( getProcAddr ( " " ) ) gpQueryResourceNV = uintptr ( getProcAddr ( " " ) ) gpQueryResourceTagNV = uintptr ( getProcAddr ( " " ) ) gpRasterPos2d = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2d == 0 { return errors . New ( " " ) } gpRasterPos2dv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2dv == 0 { return errors . New ( " " ) } gpRasterPos2f = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2f == 0 { return errors . New ( " " ) } gpRasterPos2fv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2fv == 0 { return errors . New ( " " ) } gpRasterPos2i = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2i == 0 { return errors . New ( " " ) } gpRasterPos2iv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2iv == 0 { return errors . New ( " " ) } gpRasterPos2s = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2s == 0 { return errors . New ( " " ) } gpRasterPos2sv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos2sv == 0 { return errors . New ( " " ) } gpRasterPos2xOES = uintptr ( getProcAddr ( " " ) ) gpRasterPos2xvOES = uintptr ( getProcAddr ( " " ) ) gpRasterPos3d = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3d == 0 { return errors . New ( " " ) } gpRasterPos3dv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3dv == 0 { return errors . New ( " " ) } gpRasterPos3f = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3f == 0 { return errors . New ( " " ) } gpRasterPos3fv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3fv == 0 { return errors . New ( " " ) } gpRasterPos3i = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3i == 0 { return errors . New ( " " ) } gpRasterPos3iv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3iv == 0 { return errors . New ( " " ) } gpRasterPos3s = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3s == 0 { return errors . New ( " " ) } gpRasterPos3sv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos3sv == 0 { return errors . New ( " " ) } gpRasterPos3xOES = uintptr ( getProcAddr ( " " ) ) gpRasterPos3xvOES = uintptr ( getProcAddr ( " " ) ) gpRasterPos4d = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4d == 0 { return errors . New ( " " ) } gpRasterPos4dv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4dv == 0 { return errors . New ( " " ) } gpRasterPos4f = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4f == 0 { return errors . New ( " " ) } gpRasterPos4fv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4fv == 0 { return errors . New ( " " ) } gpRasterPos4i = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4i == 0 { return errors . New ( " " ) } gpRasterPos4iv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4iv == 0 { return errors . New ( " " ) } gpRasterPos4s = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4s == 0 { return errors . New ( " " ) } gpRasterPos4sv = uintptr ( getProcAddr ( " " ) ) if gpRasterPos4sv == 0 { return errors . New ( " " ) } gpRasterPos4xOES = uintptr ( getProcAddr ( " " ) ) gpRasterPos4xvOES = uintptr ( getProcAddr ( " " ) ) gpRasterSamplesEXT = uintptr ( getProcAddr ( " " ) ) gpReadBuffer = uintptr ( getProcAddr ( " " ) ) if gpReadBuffer == 0 { return errors . New ( " " ) } gpReadInstrumentsSGIX = uintptr ( getProcAddr ( " " ) ) gpReadPixels = uintptr ( getProcAddr ( " " ) ) if gpReadPixels == 0 { return errors . New ( " " ) } gpReadnPixels = uintptr ( getProcAddr ( " " ) ) gpReadnPixelsARB = uintptr ( getProcAddr ( " " ) ) gpReadnPixelsKHR = uintptr ( getProcAddr ( " " ) ) gpRectd = uintptr ( getProcAddr ( " " ) ) if gpRectd == 0 { return errors . New ( " " ) } gpRectdv = uintptr ( getProcAddr ( " " ) ) if gpRectdv == 0 { return errors . New ( " " ) } gpRectf = uintptr ( getProcAddr ( " " ) ) if gpRectf == 0 { return errors . New ( " " ) } gpRectfv = uintptr ( getProcAddr ( " " ) ) if gpRectfv == 0 { return errors . New ( " " ) } gpRecti = uintptr ( getProcAddr ( " " ) ) if gpRecti == 0 { return errors . New ( " " ) } gpRectiv = uintptr ( getProcAddr ( " " ) ) if gpRectiv == 0 { return errors . New ( " " ) } gpRects = uintptr ( getProcAddr ( " " ) ) if gpRects == 0 { return errors . New ( " " ) } gpRectsv = uintptr ( getProcAddr ( " " ) ) if gpRectsv == 0 { return errors . New ( " " ) } gpRectxOES = uintptr ( getProcAddr ( " " ) ) gpRectxvOES = uintptr ( getProcAddr ( " " ) ) gpReferencePlaneSGIX = uintptr ( getProcAddr ( " " ) ) gpReleaseKeyedMutexWin32EXT = uintptr ( getProcAddr ( " " ) ) gpReleaseShaderCompiler = uintptr ( getProcAddr ( " " ) ) gpRenderGpuMaskNV = uintptr ( getProcAddr ( " " ) ) gpRenderMode = uintptr ( getProcAddr ( " " ) ) if gpRenderMode == 0 { return errors . New ( " " ) } gpRenderbufferStorage = uintptr ( getProcAddr ( " " ) ) gpRenderbufferStorageEXT = uintptr ( getProcAddr ( " " ) ) gpRenderbufferStorageMultisample = uintptr ( getProcAddr ( " " ) ) gpRenderbufferStorageMultisampleCoverageNV = uintptr ( getProcAddr ( " " ) ) gpRenderbufferStorageMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpReplacementCodePointerSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeubSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeubvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor4fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor4fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor4ubVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiColor4ubVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiTexCoord2fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuiVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeuivSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeusSUN = uintptr ( getProcAddr ( " " ) ) gpReplacementCodeusvSUN = uintptr ( getProcAddr ( " " ) ) gpRequestResidentProgramsNV = uintptr ( getProcAddr ( " " ) ) gpResetHistogramEXT = uintptr ( getProcAddr ( " " ) ) gpResetMinmaxEXT = uintptr ( getProcAddr ( " " ) ) gpResizeBuffersMESA = uintptr ( getProcAddr ( " " ) ) gpResolveDepthValuesNV = uintptr ( getProcAddr ( " " ) ) gpResumeTransformFeedback = uintptr ( getProcAddr ( " " ) ) gpResumeTransformFeedbackNV = uintptr ( getProcAddr ( " " ) ) gpRotated = uintptr ( getProcAddr ( " " ) ) if gpRotated == 0 { return errors . New ( " " ) } gpRotatef = uintptr ( getProcAddr ( " " ) ) if gpRotatef == 0 { return errors . New ( " " ) } gpRotatexOES = uintptr ( getProcAddr ( " " ) ) gpSampleCoverage = uintptr ( getProcAddr ( " " ) ) if gpSampleCoverage == 0 { return errors . New ( " " ) } gpSampleCoverageARB = uintptr ( getProcAddr ( " " ) ) gpSampleCoveragexOES = uintptr ( getProcAddr ( " " ) ) gpSampleMapATI = uintptr ( getProcAddr ( " " ) ) gpSampleMaskEXT = uintptr ( getProcAddr ( " " ) ) gpSampleMaskIndexedNV = uintptr ( getProcAddr ( " " ) ) gpSampleMaskSGIS = uintptr ( getProcAddr ( " " ) ) gpSampleMaski = uintptr ( getProcAddr ( " " ) ) gpSamplePatternEXT = uintptr ( getProcAddr ( " " ) ) gpSamplePatternSGIS = uintptr ( getProcAddr ( " " ) ) gpSamplerParameterIiv = uintptr ( getProcAddr ( " " ) ) gpSamplerParameterIuiv = uintptr ( getProcAddr ( " " ) ) gpSamplerParameterf = uintptr ( getProcAddr ( " " ) ) gpSamplerParameterfv = uintptr ( getProcAddr ( " " ) ) gpSamplerParameteri = uintptr ( getProcAddr ( " " ) ) gpSamplerParameteriv = uintptr ( getProcAddr ( " " ) ) gpScaled = uintptr ( getProcAddr ( " " ) ) if gpScaled == 0 { return errors . New ( " " ) } gpScalef = uintptr ( getProcAddr ( " " ) ) if gpScalef == 0 { return errors . New ( " " ) } gpScalexOES = uintptr ( getProcAddr ( " " ) ) gpScissor = uintptr ( getProcAddr ( " " ) ) if gpScissor == 0 { return errors . New ( " " ) } gpScissorArrayv = uintptr ( getProcAddr ( " " ) ) gpScissorIndexed = uintptr ( getProcAddr ( " " ) ) gpScissorIndexedv = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3b = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3b == 0 { return errors . New ( " " ) } gpSecondaryColor3bEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3bv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3bv == 0 { return errors . New ( " " ) } gpSecondaryColor3bvEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3d = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3d == 0 { return errors . New ( " " ) } gpSecondaryColor3dEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3dv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3dv == 0 { return errors . New ( " " ) } gpSecondaryColor3dvEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3f = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3f == 0 { return errors . New ( " " ) } gpSecondaryColor3fEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3fv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3fv == 0 { return errors . New ( " " ) } gpSecondaryColor3fvEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3hNV = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3hvNV = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3i = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3i == 0 { return errors . New ( " " ) } gpSecondaryColor3iEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3iv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3iv == 0 { return errors . New ( " " ) } gpSecondaryColor3ivEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3s = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3s == 0 { return errors . New ( " " ) } gpSecondaryColor3sEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3sv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3sv == 0 { return errors . New ( " " ) } gpSecondaryColor3svEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3ub = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3ub == 0 { return errors . New ( " " ) } gpSecondaryColor3ubEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3ubv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3ubv == 0 { return errors . New ( " " ) } gpSecondaryColor3ubvEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3ui = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3ui == 0 { return errors . New ( " " ) } gpSecondaryColor3uiEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3uiv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3uiv == 0 { return errors . New ( " " ) } gpSecondaryColor3uivEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3us = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3us == 0 { return errors . New ( " " ) } gpSecondaryColor3usEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColor3usv = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColor3usv == 0 { return errors . New ( " " ) } gpSecondaryColor3usvEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColorFormatNV = uintptr ( getProcAddr ( " " ) ) gpSecondaryColorPointer = uintptr ( getProcAddr ( " " ) ) if gpSecondaryColorPointer == 0 { return errors . New ( " " ) } gpSecondaryColorPointerEXT = uintptr ( getProcAddr ( " " ) ) gpSecondaryColorPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpSelectBuffer = uintptr ( getProcAddr ( " " ) ) if gpSelectBuffer == 0 { return errors . New ( " " ) } gpSelectPerfMonitorCountersAMD = uintptr ( getProcAddr ( " " ) ) gpSemaphoreParameterui64vEXT = uintptr ( getProcAddr ( " " ) ) gpSeparableFilter2DEXT = uintptr ( getProcAddr ( " " ) ) gpSetFenceAPPLE = uintptr ( getProcAddr ( " " ) ) gpSetFenceNV = uintptr ( getProcAddr ( " " ) ) gpSetFragmentShaderConstantATI = uintptr ( getProcAddr ( " " ) ) gpSetInvariantEXT = uintptr ( getProcAddr ( " " ) ) gpSetLocalConstantEXT = uintptr ( getProcAddr ( " " ) ) gpSetMultisamplefvAMD = uintptr ( getProcAddr ( " " ) ) gpShadeModel = uintptr ( getProcAddr ( " " ) ) if gpShadeModel == 0 { return errors . New ( " " ) } gpShaderBinary = uintptr ( getProcAddr ( " " ) ) gpShaderOp1EXT = uintptr ( getProcAddr ( " " ) ) gpShaderOp2EXT = uintptr ( getProcAddr ( " " ) ) gpShaderOp3EXT = uintptr ( getProcAddr ( " " ) ) gpShaderSource = uintptr ( getProcAddr ( " " ) ) if gpShaderSource == 0 { return errors . New ( " " ) } gpShaderSourceARB = uintptr ( getProcAddr ( " " ) ) gpShaderStorageBlockBinding = uintptr ( getProcAddr ( " " ) ) gpSharpenTexFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpSignalSemaphoreEXT = uintptr ( getProcAddr ( " " ) ) gpSignalVkFenceNV = uintptr ( getProcAddr ( " " ) ) gpSignalVkSemaphoreNV = uintptr ( getProcAddr ( " " ) ) gpSpecializeShaderARB = uintptr ( getProcAddr ( " " ) ) gpSpriteParameterfSGIX = uintptr ( getProcAddr ( " " ) ) gpSpriteParameterfvSGIX = uintptr ( getProcAddr ( " " ) ) gpSpriteParameteriSGIX = uintptr ( getProcAddr ( " " ) ) gpSpriteParameterivSGIX = uintptr ( getProcAddr ( " " ) ) gpStartInstrumentsSGIX = uintptr ( getProcAddr ( " " ) ) gpStateCaptureNV = uintptr ( getProcAddr ( " " ) ) gpStencilClearTagEXT = uintptr ( getProcAddr ( " " ) ) gpStencilFillPathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpStencilFillPathNV = uintptr ( getProcAddr ( " " ) ) gpStencilFunc = uintptr ( getProcAddr ( " " ) ) if gpStencilFunc == 0 { return errors . New ( " " ) } gpStencilFuncSeparate = uintptr ( getProcAddr ( " " ) ) if gpStencilFuncSeparate == 0 { return errors . New ( " " ) } gpStencilFuncSeparateATI = uintptr ( getProcAddr ( " " ) ) gpStencilMask = uintptr ( getProcAddr ( " " ) ) if gpStencilMask == 0 { return errors . New ( " " ) } gpStencilMaskSeparate = uintptr ( getProcAddr ( " " ) ) if gpStencilMaskSeparate == 0 { return errors . New ( " " ) } gpStencilOp = uintptr ( getProcAddr ( " " ) ) if gpStencilOp == 0 { return errors . New ( " " ) } gpStencilOpSeparate = uintptr ( getProcAddr ( " " ) ) if gpStencilOpSeparate == 0 { return errors . New ( " " ) } gpStencilOpSeparateATI = uintptr ( getProcAddr ( " " ) ) gpStencilOpValueAMD = uintptr ( getProcAddr ( " " ) ) gpStencilStrokePathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpStencilStrokePathNV = uintptr ( getProcAddr ( " " ) ) gpStencilThenCoverFillPathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpStencilThenCoverFillPathNV = uintptr ( getProcAddr ( " " ) ) gpStencilThenCoverStrokePathInstancedNV = uintptr ( getProcAddr ( " " ) ) gpStencilThenCoverStrokePathNV = uintptr ( getProcAddr ( " " ) ) gpStopInstrumentsSGIX = uintptr ( getProcAddr ( " " ) ) gpStringMarkerGREMEDY = uintptr ( getProcAddr ( " " ) ) gpSubpixelPrecisionBiasNV = uintptr ( getProcAddr ( " " ) ) gpSwizzleEXT = uintptr ( getProcAddr ( " " ) ) gpSyncTextureINTEL = uintptr ( getProcAddr ( " " ) ) gpTagSampleBufferSGIX = uintptr ( getProcAddr ( " " ) ) gpTangent3bEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3bvEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3dEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3dvEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3fEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3fvEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3iEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3ivEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3sEXT = uintptr ( getProcAddr ( " " ) ) gpTangent3svEXT = uintptr ( getProcAddr ( " " ) ) gpTangentPointerEXT = uintptr ( getProcAddr ( " " ) ) gpTbufferMask3DFX = uintptr ( getProcAddr ( " " ) ) gpTessellationFactorAMD = uintptr ( getProcAddr ( " " ) ) gpTessellationModeAMD = uintptr ( getProcAddr ( " " ) ) gpTestFenceAPPLE = uintptr ( getProcAddr ( " " ) ) gpTestFenceNV = uintptr ( getProcAddr ( " " ) ) gpTestObjectAPPLE = uintptr ( getProcAddr ( " " ) ) gpTexBufferARB = uintptr ( getProcAddr ( " " ) ) gpTexBufferEXT = uintptr ( getProcAddr ( " " ) ) gpTexBufferRange = uintptr ( getProcAddr ( " " ) ) gpTexBumpParameterfvATI = uintptr ( getProcAddr ( " " ) ) gpTexBumpParameterivATI = uintptr ( getProcAddr ( " " ) ) gpTexCoord1bOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord1bvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord1d = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1d == 0 { return errors . New ( " " ) } gpTexCoord1dv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1dv == 0 { return errors . New ( " " ) } gpTexCoord1f = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1f == 0 { return errors . New ( " " ) } gpTexCoord1fv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1fv == 0 { return errors . New ( " " ) } gpTexCoord1hNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord1hvNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord1i = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1i == 0 { return errors . New ( " " ) } gpTexCoord1iv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1iv == 0 { return errors . New ( " " ) } gpTexCoord1s = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1s == 0 { return errors . New ( " " ) } gpTexCoord1sv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord1sv == 0 { return errors . New ( " " ) } gpTexCoord1xOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord1xvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord2bOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord2bvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord2d = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2d == 0 { return errors . New ( " " ) } gpTexCoord2dv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2dv == 0 { return errors . New ( " " ) } gpTexCoord2f = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2f == 0 { return errors . New ( " " ) } gpTexCoord2fColor3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fColor3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fColor4fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fColor4fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fColor4ubVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fColor4ubVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fNormal3fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fNormal3fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fVertex3fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fVertex3fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord2fv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2fv == 0 { return errors . New ( " " ) } gpTexCoord2hNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord2hvNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord2i = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2i == 0 { return errors . New ( " " ) } gpTexCoord2iv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2iv == 0 { return errors . New ( " " ) } gpTexCoord2s = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2s == 0 { return errors . New ( " " ) } gpTexCoord2sv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord2sv == 0 { return errors . New ( " " ) } gpTexCoord2xOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord2xvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord3bOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord3bvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord3d = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3d == 0 { return errors . New ( " " ) } gpTexCoord3dv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3dv == 0 { return errors . New ( " " ) } gpTexCoord3f = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3f == 0 { return errors . New ( " " ) } gpTexCoord3fv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3fv == 0 { return errors . New ( " " ) } gpTexCoord3hNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord3hvNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord3i = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3i == 0 { return errors . New ( " " ) } gpTexCoord3iv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3iv == 0 { return errors . New ( " " ) } gpTexCoord3s = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3s == 0 { return errors . New ( " " ) } gpTexCoord3sv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord3sv == 0 { return errors . New ( " " ) } gpTexCoord3xOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord3xvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord4bOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord4bvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord4d = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4d == 0 { return errors . New ( " " ) } gpTexCoord4dv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4dv == 0 { return errors . New ( " " ) } gpTexCoord4f = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4f == 0 { return errors . New ( " " ) } gpTexCoord4fColor4fNormal3fVertex4fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord4fColor4fNormal3fVertex4fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord4fVertex4fSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord4fVertex4fvSUN = uintptr ( getProcAddr ( " " ) ) gpTexCoord4fv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4fv == 0 { return errors . New ( " " ) } gpTexCoord4hNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord4hvNV = uintptr ( getProcAddr ( " " ) ) gpTexCoord4i = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4i == 0 { return errors . New ( " " ) } gpTexCoord4iv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4iv == 0 { return errors . New ( " " ) } gpTexCoord4s = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4s == 0 { return errors . New ( " " ) } gpTexCoord4sv = uintptr ( getProcAddr ( " " ) ) if gpTexCoord4sv == 0 { return errors . New ( " " ) } gpTexCoord4xOES = uintptr ( getProcAddr ( " " ) ) gpTexCoord4xvOES = uintptr ( getProcAddr ( " " ) ) gpTexCoordFormatNV = uintptr ( getProcAddr ( " " ) ) gpTexCoordPointer = uintptr ( getProcAddr ( " " ) ) if gpTexCoordPointer == 0 { return errors . New ( " " ) } gpTexCoordPointerEXT = uintptr ( getProcAddr ( " " ) ) gpTexCoordPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpTexCoordPointervINTEL = uintptr ( getProcAddr ( " " ) ) gpTexEnvf = uintptr ( getProcAddr ( " " ) ) if gpTexEnvf == 0 { return errors . New ( " " ) } gpTexEnvfv = uintptr ( getProcAddr ( " " ) ) if gpTexEnvfv == 0 { return errors . New ( " " ) } gpTexEnvi = uintptr ( getProcAddr ( " " ) ) if gpTexEnvi == 0 { return errors . New ( " " ) } gpTexEnviv = uintptr ( getProcAddr ( " " ) ) if gpTexEnviv == 0 { return errors . New ( " " ) } gpTexEnvxOES = uintptr ( getProcAddr ( " " ) ) gpTexEnvxvOES = uintptr ( getProcAddr ( " " ) ) gpTexFilterFuncSGIS = uintptr ( getProcAddr ( " " ) ) gpTexGend = uintptr ( getProcAddr ( " " ) ) if gpTexGend == 0 { return errors . New ( " " ) } gpTexGendv = uintptr ( getProcAddr ( " " ) ) if gpTexGendv == 0 { return errors . New ( " " ) } gpTexGenf = uintptr ( getProcAddr ( " " ) ) if gpTexGenf == 0 { return errors . New ( " " ) } gpTexGenfv = uintptr ( getProcAddr ( " " ) ) if gpTexGenfv == 0 { return errors . New ( " " ) } gpTexGeni = uintptr ( getProcAddr ( " " ) ) if gpTexGeni == 0 { return errors . New ( " " ) } gpTexGeniv = uintptr ( getProcAddr ( " " ) ) if gpTexGeniv == 0 { return errors . New ( " " ) } gpTexGenxOES = uintptr ( getProcAddr ( " " ) ) gpTexGenxvOES = uintptr ( getProcAddr ( " " ) ) gpTexImage1D = uintptr ( getProcAddr ( " " ) ) if gpTexImage1D == 0 { return errors . New ( " " ) } gpTexImage2D = uintptr ( getProcAddr ( " " ) ) if gpTexImage2D == 0 { return errors . New ( " " ) } gpTexImage2DMultisample = uintptr ( getProcAddr ( " " ) ) gpTexImage2DMultisampleCoverageNV = uintptr ( getProcAddr ( " " ) ) gpTexImage3D = uintptr ( getProcAddr ( " " ) ) if gpTexImage3D == 0 { return errors . New ( " " ) } gpTexImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpTexImage3DMultisample = uintptr ( getProcAddr ( " " ) ) gpTexImage3DMultisampleCoverageNV = uintptr ( getProcAddr ( " " ) ) gpTexImage4DSGIS = uintptr ( getProcAddr ( " " ) ) gpTexPageCommitmentARB = uintptr ( getProcAddr ( " " ) ) gpTexParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpTexParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpTexParameterf = uintptr ( getProcAddr ( " " ) ) if gpTexParameterf == 0 { return errors . New ( " " ) } gpTexParameterfv = uintptr ( getProcAddr ( " " ) ) if gpTexParameterfv == 0 { return errors . New ( " " ) } gpTexParameteri = uintptr ( getProcAddr ( " " ) ) if gpTexParameteri == 0 { return errors . New ( " " ) } gpTexParameteriv = uintptr ( getProcAddr ( " " ) ) if gpTexParameteriv == 0 { return errors . New ( " " ) } gpTexParameterxOES = uintptr ( getProcAddr ( " " ) ) gpTexParameterxvOES = uintptr ( getProcAddr ( " " ) ) gpTexRenderbufferNV = uintptr ( getProcAddr ( " " ) ) gpTexStorage1D = uintptr ( getProcAddr ( " " ) ) gpTexStorage2D = uintptr ( getProcAddr ( " " ) ) gpTexStorage2DMultisample = uintptr ( getProcAddr ( " " ) ) gpTexStorage3D = uintptr ( getProcAddr ( " " ) ) gpTexStorage3DMultisample = uintptr ( getProcAddr ( " " ) ) gpTexStorageMem1DEXT = uintptr ( getProcAddr ( " " ) ) gpTexStorageMem2DEXT = uintptr ( getProcAddr ( " " ) ) gpTexStorageMem2DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTexStorageMem3DEXT = uintptr ( getProcAddr ( " " ) ) gpTexStorageMem3DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTexStorageSparseAMD = uintptr ( getProcAddr ( " " ) ) gpTexSubImage1D = uintptr ( getProcAddr ( " " ) ) if gpTexSubImage1D == 0 { return errors . New ( " " ) } gpTexSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpTexSubImage2D = uintptr ( getProcAddr ( " " ) ) if gpTexSubImage2D == 0 { return errors . New ( " " ) } gpTexSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpTexSubImage3D = uintptr ( getProcAddr ( " " ) ) if gpTexSubImage3D == 0 { return errors . New ( " " ) } gpTexSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpTexSubImage4DSGIS = uintptr ( getProcAddr ( " " ) ) gpTextureBarrier = uintptr ( getProcAddr ( " " ) ) gpTextureBarrierNV = uintptr ( getProcAddr ( " " ) ) gpTextureBuffer = uintptr ( getProcAddr ( " " ) ) gpTextureBufferEXT = uintptr ( getProcAddr ( " " ) ) gpTextureBufferRange = uintptr ( getProcAddr ( " " ) ) gpTextureBufferRangeEXT = uintptr ( getProcAddr ( " " ) ) gpTextureColorMaskSGIS = uintptr ( getProcAddr ( " " ) ) gpTextureImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureImage2DMultisampleCoverageNV = uintptr ( getProcAddr ( " " ) ) gpTextureImage2DMultisampleNV = uintptr ( getProcAddr ( " " ) ) gpTextureImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureImage3DMultisampleCoverageNV = uintptr ( getProcAddr ( " " ) ) gpTextureImage3DMultisampleNV = uintptr ( getProcAddr ( " " ) ) gpTextureLightEXT = uintptr ( getProcAddr ( " " ) ) gpTextureMaterialEXT = uintptr ( getProcAddr ( " " ) ) gpTextureNormalEXT = uintptr ( getProcAddr ( " " ) ) gpTexturePageCommitmentEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameterIiv = uintptr ( getProcAddr ( " " ) ) gpTextureParameterIivEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameterIuiv = uintptr ( getProcAddr ( " " ) ) gpTextureParameterIuivEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameterf = uintptr ( getProcAddr ( " " ) ) gpTextureParameterfEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameterfv = uintptr ( getProcAddr ( " " ) ) gpTextureParameterfvEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameteri = uintptr ( getProcAddr ( " " ) ) gpTextureParameteriEXT = uintptr ( getProcAddr ( " " ) ) gpTextureParameteriv = uintptr ( getProcAddr ( " " ) ) gpTextureParameterivEXT = uintptr ( getProcAddr ( " " ) ) gpTextureRangeAPPLE = uintptr ( getProcAddr ( " " ) ) gpTextureRenderbufferEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorage1D = uintptr ( getProcAddr ( " " ) ) gpTextureStorage1DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorage2D = uintptr ( getProcAddr ( " " ) ) gpTextureStorage2DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorage2DMultisample = uintptr ( getProcAddr ( " " ) ) gpTextureStorage2DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorage3D = uintptr ( getProcAddr ( " " ) ) gpTextureStorage3DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorage3DMultisample = uintptr ( getProcAddr ( " " ) ) gpTextureStorage3DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageMem1DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageMem2DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageMem2DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageMem3DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageMem3DMultisampleEXT = uintptr ( getProcAddr ( " " ) ) gpTextureStorageSparseAMD = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage1D = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage1DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage2D = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage2DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage3D = uintptr ( getProcAddr ( " " ) ) gpTextureSubImage3DEXT = uintptr ( getProcAddr ( " " ) ) gpTextureView = uintptr ( getProcAddr ( " " ) ) gpTrackMatrixNV = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackAttribsNV = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackBufferBase = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackBufferRange = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackStreamAttribsNV = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackVaryingsEXT = uintptr ( getProcAddr ( " " ) ) gpTransformFeedbackVaryingsNV = uintptr ( getProcAddr ( " " ) ) gpTransformPathNV = uintptr ( getProcAddr ( " " ) ) gpTranslated = uintptr ( getProcAddr ( " " ) ) if gpTranslated == 0 { return errors . New ( " " ) } gpTranslatef = uintptr ( getProcAddr ( " " ) ) if gpTranslatef == 0 { return errors . New ( " " ) } gpTranslatexOES = uintptr ( getProcAddr ( " " ) ) gpUniform1d = uintptr ( getProcAddr ( " " ) ) gpUniform1dv = uintptr ( getProcAddr ( " " ) ) gpUniform1f = uintptr ( getProcAddr ( " " ) ) if gpUniform1f == 0 { return errors . New ( " " ) } gpUniform1fARB = uintptr ( getProcAddr ( " " ) ) gpUniform1fv = uintptr ( getProcAddr ( " " ) ) if gpUniform1fv == 0 { return errors . New ( " " ) } gpUniform1fvARB = uintptr ( getProcAddr ( " " ) ) gpUniform1i = uintptr ( getProcAddr ( " " ) ) if gpUniform1i == 0 { return errors . New ( " " ) } gpUniform1i64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform1i64NV = uintptr ( getProcAddr ( " " ) ) gpUniform1i64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform1i64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform1iARB = uintptr ( getProcAddr ( " " ) ) gpUniform1iv = uintptr ( getProcAddr ( " " ) ) if gpUniform1iv == 0 { return errors . New ( " " ) } gpUniform1ivARB = uintptr ( getProcAddr ( " " ) ) gpUniform1ui64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform1ui64NV = uintptr ( getProcAddr ( " " ) ) gpUniform1ui64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform1ui64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform1uiEXT = uintptr ( getProcAddr ( " " ) ) gpUniform1uivEXT = uintptr ( getProcAddr ( " " ) ) gpUniform2d = uintptr ( getProcAddr ( " " ) ) gpUniform2dv = uintptr ( getProcAddr ( " " ) ) gpUniform2f = uintptr ( getProcAddr ( " " ) ) if gpUniform2f == 0 { return errors . New ( " " ) } gpUniform2fARB = uintptr ( getProcAddr ( " " ) ) gpUniform2fv = uintptr ( getProcAddr ( " " ) ) if gpUniform2fv == 0 { return errors . New ( " " ) } gpUniform2fvARB = uintptr ( getProcAddr ( " " ) ) gpUniform2i = uintptr ( getProcAddr ( " " ) ) if gpUniform2i == 0 { return errors . New ( " " ) } gpUniform2i64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform2i64NV = uintptr ( getProcAddr ( " " ) ) gpUniform2i64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform2i64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform2iARB = uintptr ( getProcAddr ( " " ) ) gpUniform2iv = uintptr ( getProcAddr ( " " ) ) if gpUniform2iv == 0 { return errors . New ( " " ) } gpUniform2ivARB = uintptr ( getProcAddr ( " " ) ) gpUniform2ui64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform2ui64NV = uintptr ( getProcAddr ( " " ) ) gpUniform2ui64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform2ui64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform2uiEXT = uintptr ( getProcAddr ( " " ) ) gpUniform2uivEXT = uintptr ( getProcAddr ( " " ) ) gpUniform3d = uintptr ( getProcAddr ( " " ) ) gpUniform3dv = uintptr ( getProcAddr ( " " ) ) gpUniform3f = uintptr ( getProcAddr ( " " ) ) if gpUniform3f == 0 { return errors . New ( " " ) } gpUniform3fARB = uintptr ( getProcAddr ( " " ) ) gpUniform3fv = uintptr ( getProcAddr ( " " ) ) if gpUniform3fv == 0 { return errors . New ( " " ) } gpUniform3fvARB = uintptr ( getProcAddr ( " " ) ) gpUniform3i = uintptr ( getProcAddr ( " " ) ) if gpUniform3i == 0 { return errors . New ( " " ) } gpUniform3i64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform3i64NV = uintptr ( getProcAddr ( " " ) ) gpUniform3i64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform3i64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform3iARB = uintptr ( getProcAddr ( " " ) ) gpUniform3iv = uintptr ( getProcAddr ( " " ) ) if gpUniform3iv == 0 { return errors . New ( " " ) } gpUniform3ivARB = uintptr ( getProcAddr ( " " ) ) gpUniform3ui64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform3ui64NV = uintptr ( getProcAddr ( " " ) ) gpUniform3ui64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform3ui64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform3uiEXT = uintptr ( getProcAddr ( " " ) ) gpUniform3uivEXT = uintptr ( getProcAddr ( " " ) ) gpUniform4d = uintptr ( getProcAddr ( " " ) ) gpUniform4dv = uintptr ( getProcAddr ( " " ) ) gpUniform4f = uintptr ( getProcAddr ( " " ) ) if gpUniform4f == 0 { return errors . New ( " " ) } gpUniform4fARB = uintptr ( getProcAddr ( " " ) ) gpUniform4fv = uintptr ( getProcAddr ( " " ) ) if gpUniform4fv == 0 { return errors . New ( " " ) } gpUniform4fvARB = uintptr ( getProcAddr ( " " ) ) gpUniform4i = uintptr ( getProcAddr ( " " ) ) if gpUniform4i == 0 { return errors . New ( " " ) } gpUniform4i64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform4i64NV = uintptr ( getProcAddr ( " " ) ) gpUniform4i64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform4i64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform4iARB = uintptr ( getProcAddr ( " " ) ) gpUniform4iv = uintptr ( getProcAddr ( " " ) ) if gpUniform4iv == 0 { return errors . New ( " " ) } gpUniform4ivARB = uintptr ( getProcAddr ( " " ) ) gpUniform4ui64ARB = uintptr ( getProcAddr ( " " ) ) gpUniform4ui64NV = uintptr ( getProcAddr ( " " ) ) gpUniform4ui64vARB = uintptr ( getProcAddr ( " " ) ) gpUniform4ui64vNV = uintptr ( getProcAddr ( " " ) ) gpUniform4uiEXT = uintptr ( getProcAddr ( " " ) ) gpUniform4uivEXT = uintptr ( getProcAddr ( " " ) ) gpUniformBlockBinding = uintptr ( getProcAddr ( " " ) ) gpUniformBufferEXT = uintptr ( getProcAddr ( " " ) ) gpUniformHandleui64ARB = uintptr ( getProcAddr ( " " ) ) gpUniformHandleui64NV = uintptr ( getProcAddr ( " " ) ) gpUniformHandleui64vARB = uintptr ( getProcAddr ( " " ) ) gpUniformHandleui64vNV = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix2dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix2fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix2fv == 0 { return errors . New ( " " ) } gpUniformMatrix2fvARB = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix2x3dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix2x3fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix2x3fv == 0 { return errors . New ( " " ) } gpUniformMatrix2x4dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix2x4fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix2x4fv == 0 { return errors . New ( " " ) } gpUniformMatrix3dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix3fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix3fv == 0 { return errors . New ( " " ) } gpUniformMatrix3fvARB = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix3x2dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix3x2fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix3x2fv == 0 { return errors . New ( " " ) } gpUniformMatrix3x4dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix3x4fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix3x4fv == 0 { return errors . New ( " " ) } gpUniformMatrix4dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix4fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix4fv == 0 { return errors . New ( " " ) } gpUniformMatrix4fvARB = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix4x2dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix4x2fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix4x2fv == 0 { return errors . New ( " " ) } gpUniformMatrix4x3dv = uintptr ( getProcAddr ( " " ) ) gpUniformMatrix4x3fv = uintptr ( getProcAddr ( " " ) ) if gpUniformMatrix4x3fv == 0 { return errors . New ( " " ) } gpUniformSubroutinesuiv = uintptr ( getProcAddr ( " " ) ) gpUniformui64NV = uintptr ( getProcAddr ( " " ) ) gpUniformui64vNV = uintptr ( getProcAddr ( " " ) ) gpUnlockArraysEXT = uintptr ( getProcAddr ( " " ) ) gpUnmapBuffer = uintptr ( getProcAddr ( " " ) ) if gpUnmapBuffer == 0 { return errors . New ( " " ) } gpUnmapBufferARB = uintptr ( getProcAddr ( " " ) ) gpUnmapNamedBuffer = uintptr ( getProcAddr ( " " ) ) gpUnmapNamedBufferEXT = uintptr ( getProcAddr ( " " ) ) gpUnmapObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpUnmapTexture2DINTEL = uintptr ( getProcAddr ( " " ) ) gpUpdateObjectBufferATI = uintptr ( getProcAddr ( " " ) ) gpUseProgram = uintptr ( getProcAddr ( " " ) ) if gpUseProgram == 0 { return errors . New ( " " ) } gpUseProgramObjectARB = uintptr ( getProcAddr ( " " ) ) gpUseProgramStages = uintptr ( getProcAddr ( " " ) ) gpUseProgramStagesEXT = uintptr ( getProcAddr ( " " ) ) gpUseShaderProgramEXT = uintptr ( getProcAddr ( " " ) ) gpVDPAUFiniNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUGetSurfaceivNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUInitNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUIsSurfaceNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUMapSurfacesNV = uintptr ( getProcAddr ( " " ) ) gpVDPAURegisterOutputSurfaceNV = uintptr ( getProcAddr ( " " ) ) gpVDPAURegisterVideoSurfaceNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUSurfaceAccessNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUUnmapSurfacesNV = uintptr ( getProcAddr ( " " ) ) gpVDPAUUnregisterSurfaceNV = uintptr ( getProcAddr ( " " ) ) gpValidateProgram = uintptr ( getProcAddr ( " " ) ) if gpValidateProgram == 0 { return errors . New ( " " ) } gpValidateProgramARB = uintptr ( getProcAddr ( " " ) ) gpValidateProgramPipeline = uintptr ( getProcAddr ( " " ) ) gpValidateProgramPipelineEXT = uintptr ( getProcAddr ( " " ) ) gpVariantArrayObjectATI = uintptr ( getProcAddr ( " " ) ) gpVariantPointerEXT = uintptr ( getProcAddr ( " " ) ) gpVariantbvEXT = uintptr ( getProcAddr ( " " ) ) gpVariantdvEXT = uintptr ( getProcAddr ( " " ) ) gpVariantfvEXT = uintptr ( getProcAddr ( " " ) ) gpVariantivEXT = uintptr ( getProcAddr ( " " ) ) gpVariantsvEXT = uintptr ( getProcAddr ( " " ) ) gpVariantubvEXT = uintptr ( getProcAddr ( " " ) ) gpVariantuivEXT = uintptr ( getProcAddr ( " " ) ) gpVariantusvEXT = uintptr ( getProcAddr ( " " ) ) gpVertex2bOES = uintptr ( getProcAddr ( " " ) ) gpVertex2bvOES = uintptr ( getProcAddr ( " " ) ) gpVertex2d = uintptr ( getProcAddr ( " " ) ) if gpVertex2d == 0 { return errors . New ( " " ) } gpVertex2dv = uintptr ( getProcAddr ( " " ) ) if gpVertex2dv == 0 { return errors . New ( " " ) } gpVertex2f = uintptr ( getProcAddr ( " " ) ) if gpVertex2f == 0 { return errors . New ( " " ) } gpVertex2fv = uintptr ( getProcAddr ( " " ) ) if gpVertex2fv == 0 { return errors . New ( " " ) } gpVertex2hNV = uintptr ( getProcAddr ( " " ) ) gpVertex2hvNV = uintptr ( getProcAddr ( " " ) ) gpVertex2i = uintptr ( getProcAddr ( " " ) ) if gpVertex2i == 0 { return errors . New ( " " ) } gpVertex2iv = uintptr ( getProcAddr ( " " ) ) if gpVertex2iv == 0 { return errors . New ( " " ) } gpVertex2s = uintptr ( getProcAddr ( " " ) ) if gpVertex2s == 0 { return errors . New ( " " ) } gpVertex2sv = uintptr ( getProcAddr ( " " ) ) if gpVertex2sv == 0 { return errors . New ( " " ) } gpVertex2xOES = uintptr ( getProcAddr ( " " ) ) gpVertex2xvOES = uintptr ( getProcAddr ( " " ) ) gpVertex3bOES = uintptr ( getProcAddr ( " " ) ) gpVertex3bvOES = uintptr ( getProcAddr ( " " ) ) gpVertex3d = uintptr ( getProcAddr ( " " ) ) if gpVertex3d == 0 { return errors . New ( " " ) } gpVertex3dv = uintptr ( getProcAddr ( " " ) ) if gpVertex3dv == 0 { return errors . New ( " " ) } gpVertex3f = uintptr ( getProcAddr ( " " ) ) if gpVertex3f == 0 { return errors . New ( " " ) } gpVertex3fv = uintptr ( getProcAddr ( " " ) ) if gpVertex3fv == 0 { return errors . New ( " " ) } gpVertex3hNV = uintptr ( getProcAddr ( " " ) ) gpVertex3hvNV = uintptr ( getProcAddr ( " " ) ) gpVertex3i = uintptr ( getProcAddr ( " " ) ) if gpVertex3i == 0 { return errors . New ( " " ) } gpVertex3iv = uintptr ( getProcAddr ( " " ) ) if gpVertex3iv == 0 { return errors . New ( " " ) } gpVertex3s = uintptr ( getProcAddr ( " " ) ) if gpVertex3s == 0 { return errors . New ( " " ) } gpVertex3sv = uintptr ( getProcAddr ( " " ) ) if gpVertex3sv == 0 { return errors . New ( " " ) } gpVertex3xOES = uintptr ( getProcAddr ( " " ) ) gpVertex3xvOES = uintptr ( getProcAddr ( " " ) ) gpVertex4bOES = uintptr ( getProcAddr ( " " ) ) gpVertex4bvOES = uintptr ( getProcAddr ( " " ) ) gpVertex4d = uintptr ( getProcAddr ( " " ) ) if gpVertex4d == 0 { return errors . New ( " " ) } gpVertex4dv = uintptr ( getProcAddr ( " " ) ) if gpVertex4dv == 0 { return errors . New ( " " ) } gpVertex4f = uintptr ( getProcAddr ( " " ) ) if gpVertex4f == 0 { return errors . New ( " " ) } gpVertex4fv = uintptr ( getProcAddr ( " " ) ) if gpVertex4fv == 0 { return errors . New ( " " ) } gpVertex4hNV = uintptr ( getProcAddr ( " " ) ) gpVertex4hvNV = uintptr ( getProcAddr ( " " ) ) gpVertex4i = uintptr ( getProcAddr ( " " ) ) if gpVertex4i == 0 { return errors . New ( " " ) } gpVertex4iv = uintptr ( getProcAddr ( " " ) ) if gpVertex4iv == 0 { return errors . New ( " " ) } gpVertex4s = uintptr ( getProcAddr ( " " ) ) if gpVertex4s == 0 { return errors . New ( " " ) } gpVertex4sv = uintptr ( getProcAddr ( " " ) ) if gpVertex4sv == 0 { return errors . New ( " " ) } gpVertex4xOES = uintptr ( getProcAddr ( " " ) ) gpVertex4xvOES = uintptr ( getProcAddr ( " " ) ) gpVertexArrayAttribBinding = uintptr ( getProcAddr ( " " ) ) gpVertexArrayAttribFormat = uintptr ( getProcAddr ( " " ) ) gpVertexArrayAttribIFormat = uintptr ( getProcAddr ( " " ) ) gpVertexArrayAttribLFormat = uintptr ( getProcAddr ( " " ) ) gpVertexArrayBindVertexBufferEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayBindingDivisor = uintptr ( getProcAddr ( " " ) ) gpVertexArrayColorOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayEdgeFlagOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayElementBuffer = uintptr ( getProcAddr ( " " ) ) gpVertexArrayFogCoordOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayIndexOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayMultiTexCoordOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayNormalOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayParameteriAPPLE = uintptr ( getProcAddr ( " " ) ) gpVertexArrayRangeAPPLE = uintptr ( getProcAddr ( " " ) ) gpVertexArrayRangeNV = uintptr ( getProcAddr ( " " ) ) gpVertexArraySecondaryColorOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayTexCoordOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribBindingEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribDivisorEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribFormatEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribIFormatEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribIOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribLFormatEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribLOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexAttribOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexBindingDivisorEXT = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexBuffer = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexBuffers = uintptr ( getProcAddr ( " " ) ) gpVertexArrayVertexOffsetEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1d = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1d == 0 { return errors . New ( " " ) } gpVertexAttrib1dARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1dNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1dv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1dv == 0 { return errors . New ( " " ) } gpVertexAttrib1dvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1f = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1f == 0 { return errors . New ( " " ) } gpVertexAttrib1fARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1fNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1fv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1fv == 0 { return errors . New ( " " ) } gpVertexAttrib1fvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1hNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1s = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1s == 0 { return errors . New ( " " ) } gpVertexAttrib1sARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1sNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1sv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib1sv == 0 { return errors . New ( " " ) } gpVertexAttrib1svARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib1svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2d = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2d == 0 { return errors . New ( " " ) } gpVertexAttrib2dARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2dNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2dv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2dv == 0 { return errors . New ( " " ) } gpVertexAttrib2dvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2f = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2f == 0 { return errors . New ( " " ) } gpVertexAttrib2fARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2fNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2fv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2fv == 0 { return errors . New ( " " ) } gpVertexAttrib2fvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2hNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2s = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2s == 0 { return errors . New ( " " ) } gpVertexAttrib2sARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2sNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2sv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib2sv == 0 { return errors . New ( " " ) } gpVertexAttrib2svARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib2svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3d = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3d == 0 { return errors . New ( " " ) } gpVertexAttrib3dARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3dNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3dv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3dv == 0 { return errors . New ( " " ) } gpVertexAttrib3dvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3f = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3f == 0 { return errors . New ( " " ) } gpVertexAttrib3fARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3fNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3fv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3fv == 0 { return errors . New ( " " ) } gpVertexAttrib3fvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3hNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3s = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3s == 0 { return errors . New ( " " ) } gpVertexAttrib3sARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3sNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3sv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib3sv == 0 { return errors . New ( " " ) } gpVertexAttrib3svARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib3svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nbv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nbv == 0 { return errors . New ( " " ) } gpVertexAttrib4NbvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Niv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Niv == 0 { return errors . New ( " " ) } gpVertexAttrib4NivARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nsv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nsv == 0 { return errors . New ( " " ) } gpVertexAttrib4NsvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nub = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nub == 0 { return errors . New ( " " ) } gpVertexAttrib4NubARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nubv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nubv == 0 { return errors . New ( " " ) } gpVertexAttrib4NubvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nuiv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nuiv == 0 { return errors . New ( " " ) } gpVertexAttrib4NuivARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4Nusv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4Nusv == 0 { return errors . New ( " " ) } gpVertexAttrib4NusvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4bv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4bv == 0 { return errors . New ( " " ) } gpVertexAttrib4bvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4d = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4d == 0 { return errors . New ( " " ) } gpVertexAttrib4dARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4dNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4dv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4dv == 0 { return errors . New ( " " ) } gpVertexAttrib4dvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4f = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4f == 0 { return errors . New ( " " ) } gpVertexAttrib4fARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4fNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4fv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4fv == 0 { return errors . New ( " " ) } gpVertexAttrib4fvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4hNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4iv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4iv == 0 { return errors . New ( " " ) } gpVertexAttrib4ivARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4s = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4s == 0 { return errors . New ( " " ) } gpVertexAttrib4sARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4sNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4sv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4sv == 0 { return errors . New ( " " ) } gpVertexAttrib4svARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4ubNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4ubv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4ubv == 0 { return errors . New ( " " ) } gpVertexAttrib4ubvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4ubvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4uiv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4uiv == 0 { return errors . New ( " " ) } gpVertexAttrib4uivARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttrib4usv = uintptr ( getProcAddr ( " " ) ) if gpVertexAttrib4usv == 0 { return errors . New ( " " ) } gpVertexAttrib4usvARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttribArrayObjectATI = uintptr ( getProcAddr ( " " ) ) gpVertexAttribBinding = uintptr ( getProcAddr ( " " ) ) gpVertexAttribDivisorARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttribFormat = uintptr ( getProcAddr ( " " ) ) gpVertexAttribFormatNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI1iEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI1ivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI1uiEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI1uivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI2iEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI2ivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI2uiEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI2uivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI3iEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI3ivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI3uiEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI3uivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4bvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4iEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4ivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4svEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4ubvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4uiEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4uivEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribI4usvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribIFormat = uintptr ( getProcAddr ( " " ) ) gpVertexAttribIFormatNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribIPointerEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1d = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1dEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1dv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1dvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1i64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1i64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1ui64ARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1ui64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1ui64vARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL1ui64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2d = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2dEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2dv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2dvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2i64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2i64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2ui64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL2ui64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3d = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3dEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3dv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3dvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3i64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3i64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3ui64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL3ui64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4d = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4dEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4dv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4dvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4i64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4i64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4ui64NV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribL4ui64vNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribLFormat = uintptr ( getProcAddr ( " " ) ) gpVertexAttribLFormatNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribLPointer = uintptr ( getProcAddr ( " " ) ) gpVertexAttribLPointerEXT = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP1ui = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP1uiv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP2ui = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP2uiv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP3ui = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP3uiv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP4ui = uintptr ( getProcAddr ( " " ) ) gpVertexAttribP4uiv = uintptr ( getProcAddr ( " " ) ) gpVertexAttribParameteriAMD = uintptr ( getProcAddr ( " " ) ) gpVertexAttribPointer = uintptr ( getProcAddr ( " " ) ) if gpVertexAttribPointer == 0 { return errors . New ( " " ) } gpVertexAttribPointerARB = uintptr ( getProcAddr ( " " ) ) gpVertexAttribPointerNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs1dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs1fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs1hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs1svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs2dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs2fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs2hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs2svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs3dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs3fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs3hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs3svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs4dvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs4fvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs4hvNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs4svNV = uintptr ( getProcAddr ( " " ) ) gpVertexAttribs4ubvNV = uintptr ( getProcAddr ( " " ) ) gpVertexBindingDivisor = uintptr ( getProcAddr ( " " ) ) gpVertexBlendARB = uintptr ( getProcAddr ( " " ) ) gpVertexBlendEnvfATI = uintptr ( getProcAddr ( " " ) ) gpVertexBlendEnviATI = uintptr ( getProcAddr ( " " ) ) gpVertexFormatNV = uintptr ( getProcAddr ( " " ) ) gpVertexPointer = uintptr ( getProcAddr ( " " ) ) if gpVertexPointer == 0 { return errors . New ( " " ) } gpVertexPointerEXT = uintptr ( getProcAddr ( " " ) ) gpVertexPointerListIBM = uintptr ( getProcAddr ( " " ) ) gpVertexPointervINTEL = uintptr ( getProcAddr ( " " ) ) gpVertexStream1dATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1dvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1fATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1fvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1iATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1ivATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1sATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream1svATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2dATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2dvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2fATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2fvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2iATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2ivATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2sATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream2svATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3dATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3dvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3fATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3fvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3iATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3ivATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3sATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream3svATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4dATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4dvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4fATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4fvATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4iATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4ivATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4sATI = uintptr ( getProcAddr ( " " ) ) gpVertexStream4svATI = uintptr ( getProcAddr ( " " ) ) gpVertexWeightPointerEXT = uintptr ( getProcAddr ( " " ) ) gpVertexWeightfEXT = uintptr ( getProcAddr ( " " ) ) gpVertexWeightfvEXT = uintptr ( getProcAddr ( " " ) ) gpVertexWeighthNV = uintptr ( getProcAddr ( " " ) ) gpVertexWeighthvNV = uintptr ( getProcAddr ( " " ) ) gpVideoCaptureNV = uintptr ( getProcAddr ( " " ) ) gpVideoCaptureStreamParameterdvNV = uintptr ( getProcAddr ( " " ) ) gpVideoCaptureStreamParameterfvNV = uintptr ( getProcAddr ( " " ) ) gpVideoCaptureStreamParameterivNV = uintptr ( getProcAddr ( " " ) ) gpViewport = uintptr ( getProcAddr ( " " ) ) if gpViewport == 0 { return errors . New ( " " ) } gpViewportArrayv = uintptr ( getProcAddr ( " " ) ) gpViewportIndexedf = uintptr ( getProcAddr ( " " ) ) gpViewportIndexedfv = uintptr ( getProcAddr ( " " ) ) gpViewportPositionWScaleNV = uintptr ( getProcAddr ( " " ) ) gpViewportSwizzleNV = uintptr ( getProcAddr ( " " ) ) gpWaitSemaphoreEXT = uintptr ( getProcAddr ( " " ) ) gpWaitSync = uintptr ( getProcAddr ( " " ) ) gpWaitVkSemaphoreNV = uintptr ( getProcAddr ( " " ) ) gpWeightPathsNV = uintptr ( getProcAddr ( " " ) ) gpWeightPointerARB = uintptr ( getProcAddr ( " " ) ) gpWeightbvARB = uintptr ( getProcAddr ( " " ) ) gpWeightdvARB = uintptr ( getProcAddr ( " " ) ) gpWeightfvARB = uintptr ( getProcAddr ( " " ) ) gpWeightivARB = uintptr ( getProcAddr ( " " ) ) gpWeightsvARB = uintptr ( getProcAddr ( " " ) ) gpWeightubvARB = uintptr ( getProcAddr ( " " ) ) gpWeightuivARB = uintptr ( getProcAddr ( " " ) ) gpWeightusvARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2d = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2d == 0 { return errors . New ( " " ) } gpWindowPos2dARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2dMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2dv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2dv == 0 { return errors . New ( " " ) } gpWindowPos2dvARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2dvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2f = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2f == 0 { return errors . New ( " " ) } gpWindowPos2fARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2fMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2fv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2fv == 0 { return errors . New ( " " ) } gpWindowPos2fvARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2fvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2i = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2i == 0 { return errors . New ( " " ) } gpWindowPos2iARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2iMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2iv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2iv == 0 { return errors . New ( " " ) } gpWindowPos2ivARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2ivMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2s = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2s == 0 { return errors . New ( " " ) } gpWindowPos2sARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2sMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos2sv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos2sv == 0 { return errors . New ( " " ) } gpWindowPos2svARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos2svMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3d = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3d == 0 { return errors . New ( " " ) } gpWindowPos3dARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3dMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3dv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3dv == 0 { return errors . New ( " " ) } gpWindowPos3dvARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3dvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3f = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3f == 0 { return errors . New ( " " ) } gpWindowPos3fARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3fMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3fv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3fv == 0 { return errors . New ( " " ) } gpWindowPos3fvARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3fvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3i = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3i == 0 { return errors . New ( " " ) } gpWindowPos3iARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3iMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3iv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3iv == 0 { return errors . New ( " " ) } gpWindowPos3ivARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3ivMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3s = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3s == 0 { return errors . New ( " " ) } gpWindowPos3sARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3sMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos3sv = uintptr ( getProcAddr ( " " ) ) if gpWindowPos3sv == 0 { return errors . New ( " " ) } gpWindowPos3svARB = uintptr ( getProcAddr ( " " ) ) gpWindowPos3svMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4dMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4dvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4fMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4fvMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4iMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4ivMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4sMESA = uintptr ( getProcAddr ( " " ) ) gpWindowPos4svMESA = uintptr ( getProcAddr ( " " ) ) gpWindowRectanglesEXT = uintptr ( getProcAddr ( " " ) ) gpWriteMaskEXT = uintptr ( getProcAddr ( " " ) ) return nil } 
func NewContext ( sampleRate int ) ( * Context , error ) { theContextLock . Lock ( ) defer theContextLock . Unlock ( ) if theContext != nil { panic ( " " ) } c := & Context { sampleRate : sampleRate , c : newContext ( sampleRate ) , players : map [ * playerImpl ] struct { } { } , inited : make ( chan struct { } ) , } theContext = c h := getHook ( ) h . OnSuspendAudio ( func ( ) { c . m . Lock ( ) c . suspended = true c . m . Unlock ( ) } ) h . OnResumeAudio ( func ( ) { c . m . Lock ( ) c . suspended = false c . m . Unlock ( ) } ) h . AppendHookOnBeforeUpdate ( func ( ) error { c . initedOnce . Do ( func ( ) { close ( c . inited ) } ) var err error theContextLock . Lock ( ) if theContext != nil { theContext . m . Lock ( ) err = theContext . err theContext . m . Unlock ( ) } theContextLock . Unlock ( ) return err } ) return c , nil } 
func ( c * Context ) IsReady ( ) bool { c . m . Lock ( ) r := c . ready c . m . Unlock ( ) return r } 
func NewPlayer ( context * Context , src io . ReadCloser ) ( * Player , error ) { p := & Player { & playerImpl { context : context , src : src , sampleRate : context . sampleRate , volume : 1 , } , } if seeker , ok := p . p . src . ( io . Seeker ) ; ok { if err != nil { return nil , err } p . p . pos = pos } runtime . SetFinalizer ( p , ( * Player ) . finalize ) return p , nil } 
func NewPlayerFromBytes ( context * Context , src [ ] byte ) ( * Player , error ) { b := BytesReadSeekCloser ( src ) p , err := NewPlayer ( context , b ) if err != nil { } return p , nil } 
func ( p * Player ) Close ( ) error { runtime . SetFinalizer ( p , nil ) return p . p . Close ( ) } 
func ( p * Player ) Seek ( offset time . Duration ) error { return p . p . Seek ( offset ) } 
func ( d * decoder ) Read ( p [ ] byte ) ( int , error ) { if len ( p ) == 0 { return 0 , nil } for d . idatLength == 0 { } } d . idatLength = binary . BigEndian . Uint32 ( d . tmp [ : 4 ] ) if string ( d . tmp [ 4 : 8 ] ) != " " { return 0 , FormatError ( " " ) } d . crc . Reset ( ) d . crc . Write ( d . tmp [ 4 : 8 ] ) } if int ( d . idatLength ) < 0 { return 0 , UnsupportedError ( " " ) } n , err := d . r . Read ( p [ : min ( len ( p ) , int ( d . idatLength ) ) ] ) d . crc . Write ( p [ : n ] ) d . idatLength -= uint32 ( n ) return n , err } 
func ( d * decoder ) decode ( ) ( image . Image , error ) { r , err := zlib . NewReader ( d ) if err != nil { return nil , err } defer r . Close ( ) var img image . Image if d . interlace == itNone { img , err = d . readImagePass ( r , 0 , false ) if err != nil { return nil , err } } else if d . interlace == itAdam7 { if err != nil { return nil , err } for pass := 0 ; pass < 7 ; pass ++ { imagePass , err := d . readImagePass ( r , pass , false ) if err != nil { return nil , err } if imagePass != nil { d . mergePassInto ( img , imagePass , pass ) } } } for i := 0 ; n == 0 && err == nil ; i ++ { if i == 100 { return nil , io . ErrNoProgress } n , err = r . Read ( d . tmp [ : 1 ] ) } if err != nil && err != io . EOF { return nil , FormatError ( err . Error ( ) ) } if n != 0 || d . idatLength != 0 { return nil , FormatError ( " " ) } return img , nil } 
func ( d * decoder ) readImagePass ( r io . Reader , pass int , allocateOnly bool ) ( image . Image , error ) { bitsPerPixel := 0 pixOffset := 0 var ( gray * image . Gray rgba * image . RGBA paletted * image . Paletted nrgba * image . NRGBA gray16 * image . Gray16 rgba64 * image . RGBA64 nrgba64 * image . NRGBA64 img image . Image ) width , height := d . width , d . height if d . interlace == itAdam7 && ! allocateOnly { p := interlacing [ pass ] height = ( height - p . yOffset + p . yFactor - 1 ) / p . yFactor } } switch d . cb { case cbG1 , cbG2 , cbG4 , cbG8 : bitsPerPixel = d . depth if d . useTransparent { nrgba = image . NewNRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba } else { gray = image . NewGray ( image . Rect ( 0 , 0 , width , height ) ) img = gray } case cbGA8 : bitsPerPixel = 16 nrgba = image . NewNRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba case cbTC8 : bitsPerPixel = 24 if d . useTransparent { nrgba = image . NewNRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba } else { rgba = image . NewRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = rgba } case cbP1 , cbP2 , cbP4 , cbP8 : bitsPerPixel = d . depth paletted = image . NewPaletted ( image . Rect ( 0 , 0 , width , height ) , d . palette ) img = paletted case cbTCA8 : bitsPerPixel = 32 nrgba = image . NewNRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba case cbG16 : bitsPerPixel = 16 if d . useTransparent { nrgba64 = image . NewNRGBA64 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba64 } else { gray16 = image . NewGray16 ( image . Rect ( 0 , 0 , width , height ) ) img = gray16 } case cbGA16 : bitsPerPixel = 32 nrgba64 = image . NewNRGBA64 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba64 case cbTC16 : bitsPerPixel = 48 if d . useTransparent { nrgba64 = image . NewNRGBA64 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba64 } else { rgba64 = image . NewRGBA64 ( image . Rect ( 0 , 0 , width , height ) ) img = rgba64 } case cbTCA16 : bitsPerPixel = 64 nrgba64 = image . NewNRGBA64 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba64 } if allocateOnly { return img , nil } bytesPerPixel := ( bitsPerPixel + 7 ) / 8 pr := make ( [ ] uint8 , rowSize ) for y := 0 ; y < height ; y ++ { if err != nil { if err == io . EOF || err == io . ErrUnexpectedEOF { return nil , FormatError ( " " ) } return nil , err } pdat := pr [ 1 : ] switch cr [ 0 ] { case ftNone : } case ftUp : for i , p := range pdat { cdat [ i ] += p } case ftAverage : } for i := bytesPerPixel ; i < len ( cdat ) ; i ++ { cdat [ i ] += uint8 ( ( int ( cdat [ i - bytesPerPixel ] ) + int ( pdat [ i ] ) ) / 2 ) } case ftPaeth : filterPaeth ( cdat , pdat , bytesPerPixel ) default : return nil , FormatError ( " " ) } for x := 0 ; x < width ; x += 8 { b := cdat [ x / 8 ] for x2 := 0 ; x2 < 8 && x + x2 < width ; x2 ++ { ycol := ( b >> 7 ) * 0xff acol := uint8 ( 0xff ) if ycol == ty { acol = 0x00 } nrgba . SetNRGBA ( x + x2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b <<= 1 } } } else { for x := 0 ; x < width ; x += 8 { b := cdat [ x / 8 ] for x2 := 0 ; x2 < 8 && x + x2 < width ; x2 ++ { gray . SetGray ( x + x2 , y , color . Gray { ( b >> 7 ) * 0xff } ) b <<= 1 } } } case cbG2 : if d . useTransparent { ty := d . transparent [ 1 ] for x := 0 ; x < width ; x += 4 { b := cdat [ x / 4 ] for x2 := 0 ; x2 < 4 && x + x2 < width ; x2 ++ { ycol := ( b >> 6 ) * 0x55 acol := uint8 ( 0xff ) if ycol == ty { acol = 0x00 } nrgba . SetNRGBA ( x + x2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b <<= 2 } } } else { for x := 0 ; x < width ; x += 4 { b := cdat [ x / 4 ] for x2 := 0 ; x2 < 4 && x + x2 < width ; x2 ++ { gray . SetGray ( x + x2 , y , color . Gray { ( b >> 6 ) * 0x55 } ) b <<= 2 } } } case cbG4 : if d . useTransparent { ty := d . transparent [ 1 ] for x := 0 ; x < width ; x += 2 { b := cdat [ x / 2 ] for x2 := 0 ; x2 < 2 && x + x2 < width ; x2 ++ { ycol := ( b >> 4 ) * 0x11 acol := uint8 ( 0xff ) if ycol == ty { acol = 0x00 } nrgba . SetNRGBA ( x + x2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b <<= 4 } } } else { for x := 0 ; x < width ; x += 2 { b := cdat [ x / 2 ] for x2 := 0 ; x2 < 2 && x + x2 < width ; x2 ++ { gray . SetGray ( x + x2 , y , color . Gray { ( b >> 4 ) * 0x11 } ) b <<= 4 } } } case cbG8 : if d . useTransparent { ty := d . transparent [ 1 ] for x := 0 ; x < width ; x ++ { ycol := cdat [ x ] acol := uint8 ( 0xff ) if ycol == ty { acol = 0x00 } nrgba . SetNRGBA ( x , y , color . NRGBA { ycol , ycol , ycol , acol } ) } } else { copy ( gray . Pix [ pixOffset : ] , cdat ) pixOffset += gray . Stride } case cbGA8 : for x := 0 ; x < width ; x ++ { ycol := cdat [ 2 * x + 0 ] nrgba . SetNRGBA ( x , y , color . NRGBA { ycol , ycol , ycol , cdat [ 2 * x + 1 ] } ) } case cbTC8 : if d . useTransparent { pix , i , j := nrgba . Pix , pixOffset , 0 tr , tg , tb := d . transparent [ 1 ] , d . transparent [ 3 ] , d . transparent [ 5 ] for x := 0 ; x < width ; x ++ { r := cdat [ j + 0 ] g := cdat [ j + 1 ] b := cdat [ j + 2 ] a := uint8 ( 0xff ) if r == tr && g == tg && b == tb { a = 0x00 } pix [ i + 0 ] = r pix [ i + 1 ] = g pix [ i + 2 ] = b pix [ i + 3 ] = a i += 4 j += 3 } pixOffset += nrgba . Stride } else { pix , i , j := rgba . Pix , pixOffset , 0 for x := 0 ; x < width ; x ++ { pix [ i + 0 ] = cdat [ j + 0 ] pix [ i + 1 ] = cdat [ j + 1 ] pix [ i + 2 ] = cdat [ j + 2 ] pix [ i + 3 ] = 0xff i += 4 j += 3 } pixOffset += rgba . Stride } case cbP1 : for x := 0 ; x < width ; x += 8 { b := cdat [ x / 8 ] for x2 := 0 ; x2 < 8 && x + x2 < width ; x2 ++ { idx := b >> 7 if len ( paletted . Palette ) <= int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . SetColorIndex ( x + x2 , y , idx ) b <<= 1 } } case cbP2 : for x := 0 ; x < width ; x += 4 { b := cdat [ x / 4 ] for x2 := 0 ; x2 < 4 && x + x2 < width ; x2 ++ { idx := b >> 6 if len ( paletted . Palette ) <= int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . SetColorIndex ( x + x2 , y , idx ) b <<= 2 } } case cbP4 : for x := 0 ; x < width ; x += 2 { b := cdat [ x / 2 ] for x2 := 0 ; x2 < 2 && x + x2 < width ; x2 ++ { idx := b >> 4 if len ( paletted . Palette ) <= int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . SetColorIndex ( x + x2 , y , idx ) b <<= 4 } } case cbP8 : if len ( paletted . Palette ) != 255 { for x := 0 ; x < width ; x ++ { if len ( paletted . Palette ) <= int ( cdat [ x ] ) { paletted . Palette = paletted . Palette [ : int ( cdat [ x ] ) + 1 ] } } } copy ( paletted . Pix [ pixOffset : ] , cdat ) pixOffset += paletted . Stride case cbTCA8 : copy ( nrgba . Pix [ pixOffset : ] , cdat ) pixOffset += nrgba . Stride case cbG16 : if d . useTransparent { ty := uint16 ( d . transparent [ 0 ] ) << 8 | uint16 ( d . transparent [ 1 ] ) for x := 0 ; x < width ; x ++ { ycol := uint16 ( cdat [ 2 * x + 0 ] ) << 8 | uint16 ( cdat [ 2 * x + 1 ] ) acol := uint16 ( 0xffff ) if ycol == ty { acol = 0x0000 } nrgba64 . SetNRGBA64 ( x , y , color . NRGBA64 { ycol , ycol , ycol , acol } ) } } else { for x := 0 ; x < width ; x ++ { ycol := uint16 ( cdat [ 2 * x + 0 ] ) << 8 | uint16 ( cdat [ 2 * x + 1 ] ) gray16 . SetGray16 ( x , y , color . Gray16 { ycol } ) } } case cbGA16 : for x := 0 ; x < width ; x ++ { ycol := uint16 ( cdat [ 4 * x + 0 ] ) << 8 | uint16 ( cdat [ 4 * x + 1 ] ) acol := uint16 ( cdat [ 4 * x + 2 ] ) << 8 | uint16 ( cdat [ 4 * x + 3 ] ) nrgba64 . SetNRGBA64 ( x , y , color . NRGBA64 { ycol , ycol , ycol , acol } ) } case cbTC16 : if d . useTransparent { tr := uint16 ( d . transparent [ 0 ] ) << 8 | uint16 ( d . transparent [ 1 ] ) tg := uint16 ( d . transparent [ 2 ] ) << 8 | uint16 ( d . transparent [ 3 ] ) tb := uint16 ( d . transparent [ 4 ] ) << 8 | uint16 ( d . transparent [ 5 ] ) for x := 0 ; x < width ; x ++ { rcol := uint16 ( cdat [ 6 * x + 0 ] ) << 8 | uint16 ( cdat [ 6 * x + 1 ] ) gcol := uint16 ( cdat [ 6 * x + 2 ] ) << 8 | uint16 ( cdat [ 6 * x + 3 ] ) bcol := uint16 ( cdat [ 6 * x + 4 ] ) << 8 | uint16 ( cdat [ 6 * x + 5 ] ) acol := uint16 ( 0xffff ) if rcol == tr && gcol == tg && bcol == tb { acol = 0x0000 } nrgba64 . SetNRGBA64 ( x , y , color . NRGBA64 { rcol , gcol , bcol , acol } ) } } else { for x := 0 ; x < width ; x ++ { rcol := uint16 ( cdat [ 6 * x + 0 ] ) << 8 | uint16 ( cdat [ 6 * x + 1 ] ) gcol := uint16 ( cdat [ 6 * x + 2 ] ) << 8 | uint16 ( cdat [ 6 * x + 3 ] ) bcol := uint16 ( cdat [ 6 * x + 4 ] ) << 8 | uint16 ( cdat [ 6 * x + 5 ] ) rgba64 . SetRGBA64 ( x , y , color . RGBA64 { rcol , gcol , bcol , 0xffff } ) } } case cbTCA16 : for x := 0 ; x < width ; x ++ { rcol := uint16 ( cdat [ 8 * x + 0 ] ) << 8 | uint16 ( cdat [ 8 * x + 1 ] ) gcol := uint16 ( cdat [ 8 * x + 2 ] ) << 8 | uint16 ( cdat [ 8 * x + 3 ] ) bcol := uint16 ( cdat [ 8 * x + 4 ] ) << 8 | uint16 ( cdat [ 8 * x + 5 ] ) acol := uint16 ( cdat [ 8 * x + 6 ] ) << 8 | uint16 ( cdat [ 8 * x + 7 ] ) nrgba64 . SetNRGBA64 ( x , y , color . NRGBA64 { rcol , gcol , bcol , acol } ) } } } return img , nil } 
func ( d * decoder ) mergePassInto ( dst image . Image , src image . Image , pass int ) { p := interlacing [ pass ] var ( srcPix [ ] uint8 dstPix [ ] uint8 stride int rect image . Rectangle bytesPerPixel int ) switch target := dst . ( type ) { case * image . Alpha : srcPix = src . ( * image . Alpha ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 1 case * image . Alpha16 : srcPix = src . ( * image . Alpha16 ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 2 case * image . Gray : srcPix = src . ( * image . Gray ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 1 case * image . Gray16 : srcPix = src . ( * image . Gray16 ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 2 case * image . NRGBA : srcPix = src . ( * image . NRGBA ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 4 case * image . NRGBA64 : srcPix = src . ( * image . NRGBA64 ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 8 case * image . Paletted : srcPix = src . ( * image . Paletted ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 1 case * image . RGBA : srcPix = src . ( * image . RGBA ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 4 case * image . RGBA64 : srcPix = src . ( * image . RGBA64 ) . Pix dstPix , stride , rect = target . Pix , target . Stride , target . Rect bytesPerPixel = 8 } s , bounds := 0 , src . Bounds ( ) for y := bounds . Min . Y ; y < bounds . Max . Y ; y ++ { dBase := ( y * p . yFactor + p . yOffset - rect . Min . Y ) * stride + ( p . xOffset - rect . Min . X ) * bytesPerPixel for x := bounds . Min . X ; x < bounds . Max . X ; x ++ { d := dBase + x * p . xFactor * bytesPerPixel copy ( dstPix [ d : ] , srcPix [ s : s + bytesPerPixel ] ) s += bytesPerPixel } } } 
func Decode ( r io . Reader ) ( image . Image , error ) { d := & decoder { r : r , crc : crc32 . NewIEEE ( ) , } if err := d . checkHeader ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return nil , err } for d . stage != dsSeenIEND { if err := d . parseChunk ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return nil , err } } return d . img , nil } 
func DecodeConfig ( r io . Reader ) ( image . Config , error ) { d := & decoder { r : r , crc : crc32 . NewIEEE ( ) , } if err := d . checkHeader ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return image . Config { } , err } for { if err := d . parseChunk ( ) ; err != nil { if err == io . EOF { err = io . ErrUnexpectedEOF } return image . Config { } , err } paletted := cbPaletted ( d . cb ) if d . stage == dsSeenIHDR && ! paletted { break } if d . stage == dsSeenPLTE && paletted { break } } var cm color . Model switch d . cb { case cbG1 , cbG2 , cbG4 , cbG8 : cm = color . GrayModel case cbGA8 : cm = color . NRGBAModel case cbTC8 : cm = color . RGBAModel case cbP1 , cbP2 , cbP4 , cbP8 : cm = d . palette case cbTCA8 : cm = color . NRGBAModel case cbG16 : cm = color . Gray16Model case cbGA16 : cm = color . NRGBA64Model case cbTC16 : cm = color . RGBA64Model case cbTCA16 : cm = color . NRGBA64Model } return image . Config { ColorModel : cm , Width : d . width , Height : d . height , } , nil } 
func ( c * ColorM ) SetElement ( i , j int , element float32 ) * ColorM { newC := & ColorM { body : make ( [ ] float32 , 16 ) , translate : make ( [ ] float32 , 4 ) , } copy ( newC . body , colorMIdentityBody ) copy ( newC . translate , colorMIdentityTranslate ) if c . isInited ( ) { if c . body != nil { copy ( newC . body , c . body ) } if c . translate != nil { copy ( newC . translate , c . translate ) } } if j < ( ColorMDim - 1 ) { newC . body [ i + j * ( ColorMDim - 1 ) ] = element } else { newC . translate [ i ] = element } return newC } 
func ( c * ColorM ) Concat ( other * ColorM ) * ColorM { if ! c . isInited ( ) { return other } if ! other . isInited ( ) { return c } lhsb := colorMIdentityBody lhst := colorMIdentityTranslate rhsb := colorMIdentityBody rhst := colorMIdentityTranslate if other . isInited ( ) { if other . body != nil { lhsb = other . body } if other . translate != nil { lhst = other . translate } } if c . isInited ( ) { if c . body != nil { rhsb = c . body } if c . translate != nil { rhst = c . translate } } return & ColorM { } 
func ( c * ColorM ) Add ( other * ColorM ) * ColorM { lhsb := colorMIdentityBody lhst := colorMIdentityTranslate rhsb := colorMIdentityBody rhst := colorMIdentityTranslate if other . isInited ( ) { if other . body != nil { lhsb = other . body } if other . translate != nil { lhst = other . translate } } if c . isInited ( ) { if c . body != nil { rhsb = c . body } if c . translate != nil { rhst = c . translate } } newC := & ColorM { body : make ( [ ] float32 , 16 ) , translate : make ( [ ] float32 , 4 ) , } for i := range lhsb { newC . body [ i ] = lhsb [ i ] + rhsb [ i ] } for i := range lhst { newC . translate [ i ] = lhst [ i ] + rhst [ i ] } return newC } 
func ( c * ColorM ) Scale ( r , g , b , a float32 ) * ColorM { if ! c . isInited ( ) { return & ColorM { body : [ ] float32 { r , 0 , 0 , 0 , 0 , g , 0 , 0 , 0 , 0 , b , 0 , 0 , 0 , 0 , a , } , } } eb := make ( [ ] float32 , len ( colorMIdentityBody ) ) if c . body != nil { copy ( eb , c . body ) for i := 0 ; i < ColorMDim - 1 ; i ++ { eb [ i * ( ColorMDim - 1 ) ] *= r eb [ i * ( ColorMDim - 1 ) + 1 ] *= g eb [ i * ( ColorMDim - 1 ) + 2 ] *= b eb [ i * ( ColorMDim - 1 ) + 3 ] *= a } } else { eb [ 0 ] = r eb [ 5 ] = g eb [ 10 ] = b eb [ 15 ] = a } et := make ( [ ] float32 , len ( colorMIdentityTranslate ) ) if c . translate != nil { et [ 0 ] = c . translate [ 0 ] * r et [ 1 ] = c . translate [ 1 ] * g et [ 2 ] = c . translate [ 2 ] * b et [ 3 ] = c . translate [ 3 ] * a } return & ColorM { body : eb , translate : et , } } 
func ( c * ColorM ) Translate ( r , g , b , a float32 ) * ColorM { if ! c . isInited ( ) { return & ColorM { translate : [ ] float32 { r , g , b , a } , } } es := make ( [ ] float32 , len ( colorMIdentityTranslate ) ) if c . translate != nil { copy ( es , c . translate ) } es [ 0 ] += r es [ 1 ] += g es [ 2 ] += b es [ 3 ] += a return & ColorM { body : c . body , translate : es , } } 
func ( c * ColorM ) ChangeHSV ( hueTheta float64 , saturationScale float32 , valueScale float32 ) * ColorM { sin , cos := math . Sincos ( hueTheta ) s32 , c32 := float32 ( sin ) , float32 ( cos ) c = c . Concat ( rgbToYCbCr ) c = c . Concat ( & ColorM { body : [ ] float32 { 1 , 0 , 0 , 0 , 0 , c32 , s32 , 0 , 0 , - s32 , c32 , 0 , 0 , 0 , 0 , 1 , } , } ) s := saturationScale v := valueScale c = c . Scale ( v , s * v , s * v , 1 ) c = c . Concat ( yCbCrToRgb ) return c } 
func ( c * gamepadConfig ) Scan ( b virtualGamepadButton ) bool { if ! c . gamepadIDInitialized { panic ( " " ) } c . initializeIfNeeded ( ) delete ( c . buttons , b ) delete ( c . axes , b ) ebn := ebiten . GamepadButton ( ebiten . GamepadButtonNum ( c . gamepadID ) ) for eb := ebiten . GamepadButton ( 0 ) ; eb < ebn ; eb ++ { if _ , ok := c . assignedButtons [ eb ] ; ok { continue } if inpututil . IsGamepadButtonJustPressed ( c . gamepadID , eb ) { c . buttons [ b ] = eb c . assignedButtons [ eb ] = struct { } { } return true } } na := ebiten . GamepadAxisNum ( c . gamepadID ) for a := 0 ; a < na ; a ++ { v := ebiten . GamepadAxis ( c . gamepadID , a ) const delta = 0.25 c . assignedAxes [ axis { a , true } ] = struct { } { } return true } } if - 1.0 <= v && v <= - axisThreshold && ( v < c . defaultAxesValues [ a ] - delta || c . defaultAxesValues [ a ] + delta < v ) { if _ , ok := c . assignedAxes [ axis { a , false } ] ; ! ok { c . axes [ b ] = axis { a , false } c . assignedAxes [ axis { a , false } ] = struct { } { } return true } } } return false } 
func ( c * gamepadConfig ) IsButtonPressed ( b virtualGamepadButton ) bool { if ! c . gamepadIDInitialized { panic ( " " ) } c . initializeIfNeeded ( ) bb , ok := c . buttons [ b ] if ok { return ebiten . IsGamepadButtonPressed ( c . gamepadID , bb ) } a , ok := c . axes [ b ] if ok { v := ebiten . GamepadAxis ( c . gamepadID , a . id ) if a . positive { return axisThreshold <= v && v <= 1.0 } else { return - 1.0 <= v && v <= - axisThreshold } } return false } 
func ( c * gamepadConfig ) ButtonName ( b virtualGamepadButton ) string { if ! c . gamepadIDInitialized { panic ( " " ) } c . initializeIfNeeded ( ) bb , ok := c . buttons [ b ] if ok { return fmt . Sprintf ( " " , bb ) } a , ok := c . axes [ b ] if ok { if a . positive { return fmt . Sprintf ( " " , a . id ) } else { return fmt . Sprintf ( " " , a . id ) } } return " " } 
func paint ( canvas * ebiten . Image , x , y int ) { op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) tps := ebiten . MaxTPS ( ) theta := 2.0 * math . Pi * float64 ( count % tps ) / float64 ( tps ) op . ColorM . RotateHue ( theta ) canvas . DrawImage ( brushImage , op ) } 
func AppendHookOnBeforeUpdate ( f func ( ) error ) { m . Lock ( ) onBeforeUpdateHooks = append ( onBeforeUpdateHooks , f ) m . Unlock ( ) } 
func ( k Key ) String ( ) string { switch k { case Key0 : return " " case Key1 : return " " case Key2 : return " " case Key3 : return " " case Key4 : return " " case Key5 : return " " case Key6 : return " " case Key7 : return " " case Key8 : return " " case Key9 : return " " case KeyA : return " " case KeyB : return " " case KeyC : return " " case KeyD : return " " case KeyE : return " " case KeyF : return " " case KeyG : return " " case KeyH : return " " case KeyI : return " " case KeyJ : return " " case KeyK : return " " case KeyL : return " " case KeyM : return " " case KeyN : return " " case KeyO : return " " case KeyP : return " " case KeyQ : return " " case KeyR : return " " case KeyS : return " " case KeyT : return " " case KeyU : return " " case KeyV : return " " case KeyW : return " " case KeyX : return " " case KeyY : return " " case KeyZ : return " " case KeyAlt : return " " case KeyApostrophe : return " " case KeyBackslash : return " " case KeyBackspace : return " " case KeyCapsLock : return " " case KeyComma : return " " case KeyControl : return " " case KeyDelete : return " " case KeyDown : return " " case KeyEnd : return " " case KeyEnter : return " " case KeyEqual : return " " case KeyEscape : return " " case KeyF1 : return " " case KeyF2 : return " " case KeyF3 : return " " case KeyF4 : return " " case KeyF5 : return " " case KeyF6 : return " " case KeyF7 : return " " case KeyF8 : return " " case KeyF9 : return " " case KeyF10 : return " " case KeyF11 : return " " case KeyF12 : return " " case KeyGraveAccent : return " " case KeyHome : return " " case KeyInsert : return " " case KeyKP0 : return " " case KeyKP1 : return " " case KeyKP2 : return " " case KeyKP3 : return " " case KeyKP4 : return " " case KeyKP5 : return " " case KeyKP6 : return " " case KeyKP7 : return " " case KeyKP8 : return " " case KeyKP9 : return " " case KeyKPAdd : return " " case KeyKPDecimal : return " " case KeyKPDivide : return " " case KeyKPEnter : return " " case KeyKPEqual : return " " case KeyKPMultiply : return " " case KeyKPSubtract : return " " case KeyLeft : return " " case KeyLeftBracket : return " " case KeyMenu : return " " case KeyMinus : return " " case KeyNumLock : return " " case KeyPageDown : return " " case KeyPageUp : return " " case KeyPause : return " " case KeyPeriod : return " " case KeyPrintScreen : return " " case KeyRight : return " " case KeyRightBracket : return " " case KeyScrollLock : return " " case KeySemicolon : return " " case KeyShift : return " " case KeySlash : return " " case KeySpace : return " " case KeyTab : return " " case KeyUp : return " " } return " " } 
func DebugPrint ( image * ebiten . Image , str string ) error { DebugPrintAt ( image , str , 0 , 0 ) return nil } 
func DebugPrintAt ( image * ebiten . Image , str string , x , y int ) { drawDebugText ( image , str , x + 1 , y + 1 , true ) drawDebugText ( image , str , x , y , false ) } 
func ( i * Input ) GamepadIDButtonPressed ( ) int { for _ , id := range ebiten . GamepadIDs ( ) { for b := ebiten . GamepadButton ( 0 ) ; b <= ebiten . GamepadButtonMax ; b ++ { if ebiten . IsGamepadButtonPressed ( id , b ) { return id } } } return - 1 } 
func ( s * Stream ) Read ( p [ ] byte ) ( int , error ) { return s . decoded . Read ( p ) } 
func ( s * Stream ) Seek ( offset int64 , whence int ) ( int64 , error ) { return s . decoded . Seek ( offset , whence ) } 
func ( s * Stream ) Close ( ) error { runtime . SetFinalizer ( s , nil ) if err := s . decoded . Close ( ) ; err != nil { return err } return nil } 
func decode ( in audio . ReadSeekCloser ) ( * decoded , int , int , error ) { r , err := newDecoder ( in ) if err != nil { return nil , 0 , 0 , err } d := & decoded { runtime . SetFinalizer ( d , ( * decoded ) . Close ) if _ , err := d . Read ( make ( [ ] byte , 65536 ) ) ; err != nil && err != io . EOF { return nil , 0 , 0 , err } if _ , err := d . Seek ( 0 , io . SeekStart ) ; err != nil { return nil , 0 , 0 , err } return d , r . Channels ( ) , r . SampleRate ( ) , nil } 
func Decode ( context * audio . Context , src audio . ReadSeekCloser ) ( * Stream , error ) { decoded , channelNum , sampleRate , err := decode ( src ) if err != nil { return nil , err } if channelNum != 1 && channelNum != 2 { return nil , fmt . Errorf ( " " , channelNum ) } var s audio . ReadSeekCloser = decoded size := decoded . Length ( ) if channelNum == 1 { s = convert . NewStereo16 ( s , true , false ) size *= 2 } if sampleRate != context . SampleRate ( ) { r := convert . NewResampling ( s , size , sampleRate , context . SampleRate ( ) ) s = r size = r . Length ( ) } stream := & Stream { decoded : s , size : size } runtime . SetFinalizer ( stream , ( * Stream ) . Close ) return stream , nil } 
func Start ( f func ( * ebiten . Image ) error , width , height int , scale float64 , title string ) error { mobileMutex . Lock ( ) defer mobileMutex . Unlock ( ) start ( f , width , height , scale , title ) return nil } 
func UpdateTouchesOnAndroid ( action int , id int , x , y int ) { mobileMutex . Lock ( ) defer mobileMutex . Unlock ( ) updateTouchesOnAndroid ( action , id , x , y ) } 
func UpdateTouchesOnIOS ( phase int , ptr int64 , x , y int ) { mobileMutex . Lock ( ) defer mobileMutex . Unlock ( ) updateTouchesOnIOSImpl ( phase , ptr , x , y ) } 
func ( f * Field ) IsBlocked ( x , y int ) bool { if x < 0 || fieldBlockNumX <= x { return true } if y < 0 { return false } if fieldBlockNumY <= y { return true } return f . blocks [ x ] [ y ] != BlockTypeNone } 
func ( f * Field ) MovePieceToLeft ( piece * Piece , x , y int , angle Angle ) int { if piece . collides ( f , x - 1 , y , angle ) { return x } return x - 1 } 
func ( f * Field ) PieceDroppable ( piece * Piece , x , y int , angle Angle ) bool { return ! piece . collides ( f , x , y + 1 , angle ) } 
func ( f * Field ) RotatePieceRight ( piece * Piece , x , y int , angle Angle ) Angle { if piece . collides ( f , x , y , angle . RotateRight ( ) ) { return angle } return angle . RotateRight ( ) } 
func ( f * Field ) RotatePieceLeft ( piece * Piece , x , y int , angle Angle ) Angle { if piece . collides ( f , x , y , angle . RotateLeft ( ) ) { return angle } return angle . RotateLeft ( ) } 
func ( f * Field ) AbsorbPiece ( piece * Piece , x , y int , angle Angle ) { piece . AbsorbInto ( f , x , y , angle ) if f . flushable ( ) { f . flushCount = maxFlushCount } } 
func ( f * Field ) flushable ( ) bool { for j := fieldBlockNumY - 1 ; 0 <= j ; j -- { if f . flushableLine ( j ) { return true } } return false } 
func ( f * Field ) flushableLine ( j int ) bool { for i := 0 ; i < fieldBlockNumX ; i ++ { if f . blocks [ i ] [ j ] == BlockTypeNone { return false } } return true } 
func ( f * Field ) flushLine ( j int ) bool { for i := 0 ; i < fieldBlockNumX ; i ++ { if f . blocks [ i ] [ j ] == BlockTypeNone { return false } } for j2 := j ; 1 <= j2 ; j2 -- { for i := 0 ; i < fieldBlockNumX ; i ++ { f . blocks [ i ] [ j2 ] = f . blocks [ i ] [ j2 - 1 ] } } for i := 0 ; i < fieldBlockNumX ; i ++ { f . blocks [ i ] [ 0 ] = BlockTypeNone } return true } 
func intersection ( l1 , l2 line ) ( float64 , float64 , bool ) { tNum := ( l1 . X1 - l2 . X1 ) * ( l2 . Y1 - l2 . Y2 ) - ( l1 . Y1 - l2 . Y1 ) * ( l2 . X1 - l2 . X2 ) uNum := - ( ( l1 . X1 - l1 . X2 ) * ( l1 . Y1 - l2 . Y1 ) - ( l1 . Y1 - l1 . Y2 ) * ( l1 . X1 - l2 . X1 ) ) if denom == 0 { return 0 , 0 , false } t := tNum / denom if t > 1 || t < 0 { return 0 , 0 , false } u := uNum / denom if u > 1 || u < 0 { return 0 , 0 , false } x := l1 . X1 + t * ( l1 . X2 - l1 . X1 ) y := l1 . Y1 + t * ( l1 . Y2 - l1 . Y1 ) return x , y , true } 
func rayCasting ( cx , cy float64 , objects [ ] object ) [ ] line { const rayLength = 1000 var rays [ ] line for _ , obj := range objects { angle := l . angle ( ) for _ , offset := range [ ] float64 { - 0.005 , 0.005 } { points := [ ] [ 2 ] float64 { } ray := newRay ( cx , cy , rayLength , angle + offset ) } } } minI := - 1 for i , p := range points { d2 := ( cx - p [ 0 ] ) * ( cx - p [ 0 ] ) + ( cy - p [ 1 ] ) * ( cy - p [ 1 ] ) if d2 < min { min = d2 minI = i } } rays = append ( rays , line { cx , cy , points [ minI ] [ 0 ] , points [ minI ] [ 1 ] } ) } } } } ) return rays } 
func square ( width , height int ) float64 { if width == 0 && height == 0 { return 0 } if width <= height { return float64 ( width ) / float64 ( height ) } return float64 ( height ) / float64 ( width ) } 
func RecordScreenAsGIF ( update func ( * ebiten . Image ) error , out io . Writer , frameNum int ) func ( * ebiten . Image ) error { r := & recorder { inner : update , writer : out , frameNum : frameNum , skips : 10 , } return r . update } 
func Ptr ( data interface { } ) unsafe . Pointer { if data == nil { return unsafe . Pointer ( nil ) } var addr unsafe . Pointer v := reflect . ValueOf ( data ) switch v . Type ( ) . Kind ( ) { case reflect . Ptr : e := v . Elem ( ) switch e . Kind ( ) { case reflect . Int , reflect . Int8 , reflect . Int16 , reflect . Int32 , reflect . Int64 , reflect . Uint , reflect . Uint8 , reflect . Uint16 , reflect . Uint32 , reflect . Uint64 , reflect . Float32 , reflect . Float64 : addr = unsafe . Pointer ( e . UnsafeAddr ( ) ) default : panic ( fmt . Errorf ( " " , e . Kind ( ) ) ) } case reflect . Uintptr : addr = unsafe . Pointer ( v . Pointer ( ) ) case reflect . Slice : addr = unsafe . Pointer ( v . Index ( 0 ) . UnsafeAddr ( ) ) default : panic ( fmt . Errorf ( " " , v . Type ( ) ) ) } return addr } 
func Str ( str string ) * uint8 { if ! strings . HasSuffix ( str , " \x00 " ) { panic ( " " + str ) } header := ( * reflect . StringHeader ) ( unsafe . Pointer ( & str ) ) return ( * uint8 ) ( unsafe . Pointer ( header . Data ) ) } 
func GoStr ( cstr * uint8 ) string { return C . GoString ( ( * C . char ) ( unsafe . Pointer ( cstr ) ) ) } 
func Strs ( strs ... string ) ( cstrs * * uint8 , free func ( ) ) { if len ( strs ) == 0 { panic ( " " ) } for i := range strs { n += len ( strs [ i ] ) } data := C . malloc ( C . size_t ( n ) ) css := make ( [ ] * uint8 , len ( strs ) ) offset := 0 for i := range strs { copy ( dataSlice [ offset : offset + len ( strs [ i ] ) ] , strs [ i ] [ : ] ) css [ i ] = ( * uint8 ) ( unsafe . Pointer ( & dataSlice [ offset ] ) ) offset += len ( strs [ i ] ) } return ( * * uint8 ) ( & css [ 0 ] ) , func ( ) { C . free ( data ) } } 
func OpenFile ( path string ) ( ReadSeekCloser , error ) { return os . Open ( filepath . FromSlash ( path ) ) } 
func CreateSystemDefaultDevice ( ) ( Device , error ) { d := C . CreateSystemDefaultDevice ( ) if d . Device == nil { return Device { } , errors . New ( " " ) } return Device { device : d . Device , Headless : d . Headless != 0 , LowPower : d . LowPower != 0 , Name : C . GoString ( d . Name ) , } , nil } 
func CopyAllDevices ( ) [ ] Device { d := C . CopyAllDevices ( ) defer C . free ( unsafe . Pointer ( d . Devices ) ) ds := make ( [ ] Device , d . Length ) for i := 0 ; i < len ( ds ) ; i ++ { d := ( * C . struct_Device ) ( unsafe . Pointer ( uintptr ( unsafe . Pointer ( d . Devices ) ) + uintptr ( i ) * C . sizeof_struct_Device ) ) ds [ i ] . device = d . Device ds [ i ] . Headless = d . Headless != 0 ds [ i ] . LowPower = d . LowPower != 0 ds [ i ] . Name = C . GoString ( d . Name ) } return ds } 
func ( d Device ) SupportsFeatureSet ( fs FeatureSet ) bool { return C . Device_SupportsFeatureSet ( d . device , C . uint16_t ( fs ) ) != 0 } 
func ( d Device ) MakeLibrary ( source string , opt CompileOptions ) ( Library , error ) { l := C . Go_Device_MakeLibrary ( d . device , source ) if l . Library == nil { return Library { } , errors . New ( C . GoString ( l . Error ) ) } return Library { l . Library } , nil } 
func ( d Device ) MakeRenderPipelineState ( rpd RenderPipelineDescriptor ) ( RenderPipelineState , error ) { blendingEnabled := C . BOOL ( 0 ) if rpd . ColorAttachments [ 0 ] . BlendingEnabled { blendingEnabled = C . BOOL ( 1 ) } c := & rpd . ColorAttachments [ 0 ] descriptor := C . struct_RenderPipelineDescriptor { VertexFunction : rpd . VertexFunction . function , FragmentFunction : rpd . FragmentFunction . function , ColorAttachment0PixelFormat : C . uint16_t ( c . PixelFormat ) , ColorAttachment0BlendingEnabled : C . BOOL ( blendingEnabled ) , ColorAttachment0DestinationAlphaBlendFactor : C . uint8_t ( c . DestinationAlphaBlendFactor ) , ColorAttachment0DestinationRGBBlendFactor : C . uint8_t ( c . DestinationRGBBlendFactor ) , ColorAttachment0SourceAlphaBlendFactor : C . uint8_t ( c . SourceAlphaBlendFactor ) , ColorAttachment0SourceRGBBlendFactor : C . uint8_t ( c . SourceRGBBlendFactor ) , } rps := C . Device_MakeRenderPipelineState ( d . device , descriptor ) if rps . RenderPipelineState == nil { return RenderPipelineState { } , errors . New ( C . GoString ( rps . Error ) ) } return RenderPipelineState { rps . RenderPipelineState } , nil } 
func ( d Device ) MakeBufferWithBytes ( bytes unsafe . Pointer , length uintptr , opt ResourceOptions ) Buffer { return Buffer { C . Device_MakeBufferWithBytes ( d . device , bytes , C . size_t ( length ) , C . uint16_t ( opt ) ) } } 
func ( d Device ) MakeBufferWithLength ( length uintptr , opt ResourceOptions ) Buffer { return Buffer { C . Device_MakeBufferWithLength ( d . device , C . size_t ( length ) , C . uint16_t ( opt ) ) } } 
func ( d Device ) MakeTexture ( td TextureDescriptor ) Texture { descriptor := C . struct_TextureDescriptor { PixelFormat : C . uint16_t ( td . PixelFormat ) , Width : C . uint_t ( td . Width ) , Height : C . uint_t ( td . Height ) , StorageMode : C . uint8_t ( td . StorageMode ) , Usage : C . uint8_t ( td . Usage ) , } return Texture { texture : C . Device_MakeTexture ( d . device , descriptor ) , Width : td . Width , } 
func ( cb CommandBuffer ) PresentDrawable ( d Drawable ) { C . CommandBuffer_PresentDrawable ( cb . commandBuffer , d . Drawable ( ) ) } 
func ( cb CommandBuffer ) MakeRenderCommandEncoder ( rpd RenderPassDescriptor ) RenderCommandEncoder { descriptor := C . struct_RenderPassDescriptor { ColorAttachment0LoadAction : C . uint8_t ( rpd . ColorAttachments [ 0 ] . LoadAction ) , ColorAttachment0StoreAction : C . uint8_t ( rpd . ColorAttachments [ 0 ] . StoreAction ) , ColorAttachment0ClearColor : C . struct_ClearColor { Red : C . double ( rpd . ColorAttachments [ 0 ] . ClearColor . Red ) , Green : C . double ( rpd . ColorAttachments [ 0 ] . ClearColor . Green ) , Blue : C . double ( rpd . ColorAttachments [ 0 ] . ClearColor . Blue ) , Alpha : C . double ( rpd . ColorAttachments [ 0 ] . ClearColor . Alpha ) , } , ColorAttachment0Texture : rpd . ColorAttachments [ 0 ] . Texture . texture , } return RenderCommandEncoder { CommandEncoder { C . CommandBuffer_MakeRenderCommandEncoder ( cb . commandBuffer , descriptor ) } } } 
func ( cb CommandBuffer ) MakeBlitCommandEncoder ( ) BlitCommandEncoder { return BlitCommandEncoder { CommandEncoder { C . CommandBuffer_MakeBlitCommandEncoder ( cb . commandBuffer ) } } } 
func ( rce RenderCommandEncoder ) SetRenderPipelineState ( rps RenderPipelineState ) { C . RenderCommandEncoder_SetRenderPipelineState ( rce . commandEncoder , rps . renderPipelineState ) } 
func ( rce RenderCommandEncoder ) SetVertexBuffer ( buf Buffer , offset , index int ) { C . RenderCommandEncoder_SetVertexBuffer ( rce . commandEncoder , buf . buffer , C . uint_t ( offset ) , C . uint_t ( index ) ) } 
func ( rce RenderCommandEncoder ) SetVertexBytes ( bytes unsafe . Pointer , length uintptr , index int ) { C . RenderCommandEncoder_SetVertexBytes ( rce . commandEncoder , bytes , C . size_t ( length ) , C . uint_t ( index ) ) } 
func ( rce RenderCommandEncoder ) SetFragmentTexture ( texture Texture , index int ) { C . RenderCommandEncoder_SetFragmentTexture ( rce . commandEncoder , texture . texture , C . uint_t ( index ) ) } 
func ( rce RenderCommandEncoder ) DrawPrimitives ( typ PrimitiveType , vertexStart , vertexCount int ) { C . RenderCommandEncoder_DrawPrimitives ( rce . commandEncoder , C . uint8_t ( typ ) , C . uint_t ( vertexStart ) , C . uint_t ( vertexCount ) ) } 
func ( rce RenderCommandEncoder ) DrawIndexedPrimitives ( typ PrimitiveType , indexCount int , indexType IndexType , indexBuffer Buffer , indexBufferOffset int ) { C . RenderCommandEncoder_DrawIndexedPrimitives ( rce . commandEncoder , C . uint8_t ( typ ) , C . uint_t ( indexCount ) , C . uint8_t ( indexType ) , indexBuffer . buffer , C . uint_t ( indexBufferOffset ) ) } 
func ( bce BlitCommandEncoder ) Synchronize ( resource Resource ) { C . BlitCommandEncoder_Synchronize ( bce . commandEncoder , resource . resource ( ) ) } 
func ( l Library ) MakeFunction ( name string ) ( Function , error ) { f := C . Library_MakeFunction ( l . library , C . CString ( name ) ) if f == nil { return Function { } , fmt . Errorf ( " " , name ) } return Function { f } , nil } 
func ( t Texture ) GetBytes ( pixelBytes * byte , bytesPerRow uintptr , region Region , level int ) { r := region . c ( ) C . Texture_GetBytes ( t . texture , unsafe . Pointer ( pixelBytes ) , C . size_t ( bytesPerRow ) , r , C . uint_t ( level ) ) } 
func ( t Texture ) ReplaceRegion ( region Region , level int , pixelBytes unsafe . Pointer , bytesPerRow int ) { r := region . c ( ) C . Texture_ReplaceRegion ( t . texture , r , C . uint_t ( level ) , pixelBytes , C . uint_t ( bytesPerRow ) ) } 
func RegionMake2D ( x , y , width , height int ) Region { return Region { Origin : Origin { x , y , 0 } , Size : Size { width , height , 1 } , } } 
func ( s * Stream ) Read ( p [ ] byte ) ( int , error ) { return s . inner . Read ( p ) } 
func ( s * Stream ) Close ( ) error { runtime . SetFinalizer ( s , nil ) return s . inner . Close ( ) } 
func ( s * stream ) Read ( p [ ] byte ) ( int , error ) { if s . remaining <= 0 { return 0 , io . EOF } if s . remaining < int64 ( len ( p ) ) { p = p [ 0 : s . remaining ] } n , err := s . src . Read ( p ) s . remaining -= int64 ( n ) return n , err } 
func ( s * stream ) Seek ( offset int64 , whence int ) ( int64 , error ) { switch whence { case io . SeekStart : offset = offset + s . headerSize case io . SeekCurrent : case io . SeekEnd : offset = s . headerSize + s . dataSize + offset whence = io . SeekStart } n , err := s . src . Seek ( offset , whence ) if err != nil { return 0 , err } if n - s . headerSize < 0 { return 0 , fmt . Errorf ( " " ) } s . remaining = s . dataSize - ( n - s . headerSize ) return s . dataSize , nil } return n - s . headerSize , nil } 
func ( s * stream ) Close ( ) error { runtime . SetFinalizer ( s , nil ) return s . src . Close ( ) } 
func NewWorld ( width , height int , maxInitLiveCells int ) * World { w := & World { area : make ( [ ] bool , width * height ) , width : width , height : height , } w . init ( maxInitLiveCells ) return w } 
func ( w * World ) init ( maxLiveCells int ) { for i := 0 ; i < maxLiveCells ; i ++ { x := rand . Intn ( w . width ) y := rand . Intn ( w . height ) w . area [ y * w . width + x ] = true } } 
func ( w * World ) Update ( ) { width := w . width height := w . height next := make ( [ ] bool , width * height ) for y := 0 ; y < height ; y ++ { for x := 0 ; x < width ; x ++ { pop := neighbourCount ( w . area , width , height , x , y ) switch { case pop < 2 : case ( pop == 2 || pop == 3 ) && w . area [ y * width + x ] : case pop > 3 : case pop == 3 : } } } w . area = next } 
func ( w * World ) Draw ( pix [ ] byte ) { for i , v := range w . area { if v { pix [ 4 * i ] = 0xff pix [ 4 * i + 1 ] = 0xff pix [ 4 * i + 2 ] = 0xff pix [ 4 * i + 3 ] = 0xff } else { pix [ 4 * i ] = 0 pix [ 4 * i + 1 ] = 0 pix [ 4 * i + 2 ] = 0 pix [ 4 * i + 3 ] = 0 } } } 
func neighbourCount ( a [ ] bool , width , height , x , y int ) int { c := 0 for j := - 1 ; j <= 1 ; j ++ { for i := - 1 ; i <= 1 ; i ++ { if i == 0 && j == 0 { continue } x2 := x + i y2 := y + j if x2 < 0 || y2 < 0 || width <= x2 || height <= y2 { continue } if a [ y2 * width + x2 ] { c ++ } } } return c } 
func ( ml MetalLayer ) PixelFormat ( ) mtl . PixelFormat { return mtl . PixelFormat ( C . MetalLayer_PixelFormat ( ml . metalLayer ) ) } 
func ( ml MetalLayer ) SetDevice ( device mtl . Device ) { C . MetalLayer_SetDevice ( ml . metalLayer , device . Device ( ) ) } 
func ( ml MetalLayer ) SetPixelFormat ( pf mtl . PixelFormat ) { e := C . MetalLayer_SetPixelFormat ( ml . metalLayer , C . uint16_t ( pf ) ) if e != nil { panic ( errors . New ( C . GoString ( e ) ) ) } } 
func ( ml MetalLayer ) SetMaximumDrawableCount ( count int ) { e := C . MetalLayer_SetMaximumDrawableCount ( ml . metalLayer , C . uint_t ( count ) ) if e != nil { panic ( errors . New ( C . GoString ( e ) ) ) } } 
func ( ml MetalLayer ) SetDisplaySyncEnabled ( enabled bool ) { switch enabled { case true : C . MetalLayer_SetDisplaySyncEnabled ( ml . metalLayer , 1 ) case false : C . MetalLayer_SetDisplaySyncEnabled ( ml . metalLayer , 0 ) } } 
func ( ml MetalLayer ) SetDrawableSize ( width , height int ) { C . MetalLayer_SetDrawableSize ( ml . metalLayer , C . double ( width ) , C . double ( height ) ) } 
func ( ml MetalLayer ) NextDrawable ( ) ( MetalDrawable , error ) { md := C . MetalLayer_NextDrawable ( ml . metalLayer ) if md == nil { return MetalDrawable { } , errors . New ( " " ) } return MetalDrawable { md } , nil } 
func ( md MetalDrawable ) Texture ( ) mtl . Texture { return mtl . NewTexture ( C . MetalDrawable_Texture ( md . metalDrawable ) ) } 
func DrawLine ( dst * ebiten . Image , x1 , y1 , x2 , y2 float64 , clr color . Color ) { ew , eh := emptyImage . Size ( ) length := math . Hypot ( x2 - x1 , y2 - y1 ) op := & ebiten . DrawImageOptions { } op . GeoM . Scale ( length / float64 ( ew ) , 1 / float64 ( eh ) ) op . GeoM . Rotate ( math . Atan2 ( y2 - y1 , x2 - x1 ) ) op . GeoM . Translate ( x1 , y1 ) op . ColorM . Scale ( colorScale ( clr ) ) } 
func DrawRect ( dst * ebiten . Image , x , y , width , height float64 , clr color . Color ) { ew , eh := emptyImage . Size ( ) op := & ebiten . DrawImageOptions { } op . GeoM . Scale ( width / float64 ( ew ) , height / float64 ( eh ) ) op . GeoM . Translate ( x , y ) op . ColorM . Scale ( colorScale ( clr ) ) } 
func NewGame ( ) ( * Game , error ) { g := & Game { input : NewInput ( ) , } var err error g . board , err = NewBoard ( boardSize ) if err != nil { return nil , err } return g , nil } 
func ( g * Game ) Update ( ) error { g . input . Update ( ) if err := g . board . Update ( g . input ) ; err != nil { return err } return nil } 
func ( g * Game ) Draw ( screen * ebiten . Image ) { if g . boardImage == nil { w , h := g . board . Size ( ) g . boardImage , _ = ebiten . NewImage ( w , h , ebiten . FilterDefault ) } screen . Fill ( backgroundColor ) g . board . Draw ( g . boardImage ) op := & ebiten . DrawImageOptions { } sw , sh := screen . Size ( ) bw , bh := g . boardImage . Size ( ) x := ( sw - bw ) / 2 y := ( sh - bh ) / 2 op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) screen . DrawImage ( g . boardImage , op ) } 
func IsKeyJustReleased ( key ebiten . Key ) bool { theInputState . m . RLock ( ) r := theInputState . keyDurations [ key ] == 0 && theInputState . prevKeyDurations [ key ] > 0 theInputState . m . RUnlock ( ) return r } 
func KeyPressDuration ( key ebiten . Key ) int { theInputState . m . RLock ( ) s := theInputState . keyDurations [ key ] theInputState . m . RUnlock ( ) return s } 
func IsMouseButtonJustReleased ( button ebiten . MouseButton ) bool { theInputState . m . RLock ( ) r := theInputState . mouseButtonDurations [ button ] == 0 && theInputState . prevMouseButtonDurations [ button ] > 0 theInputState . m . RUnlock ( ) return r } 
func MouseButtonPressDuration ( button ebiten . MouseButton ) int { theInputState . m . RLock ( ) s := theInputState . mouseButtonDurations [ button ] theInputState . m . RUnlock ( ) return s } 
func JustConnectedGamepadIDs ( ) [ ] int { var ids [ ] int theInputState . m . RLock ( ) for id := range theInputState . gamepadIDs { if _ , ok := theInputState . prevGamepadIDs [ id ] ; ! ok { ids = append ( ids , id ) } } theInputState . m . RUnlock ( ) sort . Ints ( ids ) return ids } 
func IsGamepadJustDisconnected ( id int ) bool { theInputState . m . RLock ( ) _ , prev := theInputState . prevGamepadIDs [ id ] _ , current := theInputState . gamepadIDs [ id ] theInputState . m . RUnlock ( ) return prev && ! current } 
func IsGamepadButtonJustPressed ( id int , button ebiten . GamepadButton ) bool { return GamepadButtonPressDuration ( id , button ) == 1 } 
func IsGamepadButtonJustReleased ( id int , button ebiten . GamepadButton ) bool { theInputState . m . RLock ( ) prev := 0 if _ , ok := theInputState . prevGamepadButtonDurations [ id ] ; ok { prev = theInputState . prevGamepadButtonDurations [ id ] [ button ] } current := 0 if _ , ok := theInputState . gamepadButtonDurations [ id ] ; ok { current = theInputState . gamepadButtonDurations [ id ] [ button ] } theInputState . m . RUnlock ( ) return current == 0 && prev > 0 } 
func GamepadButtonPressDuration ( id int , button ebiten . GamepadButton ) int { theInputState . m . RLock ( ) s := 0 if _ , ok := theInputState . gamepadButtonDurations [ id ] ; ok { s = theInputState . gamepadButtonDurations [ id ] [ button ] } theInputState . m . RUnlock ( ) return s } 
func JustPressedTouchIDs ( ) [ ] int { var ids [ ] int theInputState . m . RLock ( ) for id , s := range theInputState . touchDurations { if s == 1 { ids = append ( ids , id ) } } theInputState . m . RUnlock ( ) sort . Ints ( ids ) return ids } 
func IsTouchJustReleased ( id int ) bool { theInputState . m . RLock ( ) r := theInputState . touchDurations [ id ] == 0 && theInputState . prevTouchDurations [ id ] > 0 theInputState . m . RUnlock ( ) return r } 
func TouchPressDuration ( id int ) int { theInputState . m . RLock ( ) s := theInputState . touchDurations [ id ] theInputState . m . RUnlock ( ) return s } 
func ( i * Image ) viewportSize ( ) ( int , int ) { if i . screen { return i . width , i . height } return graphics . InternalImageSize ( i . width ) , graphics . InternalImageSize ( i . height ) } 
func Loop ( ch <- chan error ) error { atomic . StoreInt32 ( & started , 1 ) for { select { case f := <- funcs : f ( ) case err := <- ch : } } } 
func Run ( f func ( ) error ) error { if atomic . LoadInt32 ( & started ) == 0 { ch := make ( chan struct { } ) var err error funcs <- func ( ) { err = f ( ) close ( ch ) } <- ch return err } 
func Update ( tps int ) int { m . Lock ( ) defer m . Unlock ( ) n := now ( ) c := 0 if tps == UncappedTPS { c = 1 } else if tps > 0 { c = calcCountFromTPS ( int64 ( tps ) , n ) } updateFPSAndTPS ( n , c ) return c } 
func ( v View ) SetLayer ( l ca . Layer ) { C . View_SetLayer ( v . view , l . Layer ( ) ) } 
func ( v View ) SetWantsLayer ( wantsLayer bool ) { if wantsLayer { C . View_SetWantsLayer ( v . view , 1 ) } else { C . View_SetWantsLayer ( v . view , 0 ) } } 
func InternalImageSize ( x int ) int { if x <= 0 { panic ( " " ) } if x < minInternalImageSize { return minInternalImageSize } r := 1 for r < x { r <<= 1 } return r } 
func square ( out [ ] int16 , volume float64 , freq float64 , sequence float64 ) { if freq == 0 { for i := 0 ; i < len ( out ) ; i ++ { out [ i ] = 0 } return } length := int ( float64 ( sampleRate ) / freq ) if length == 0 { panic ( " " ) } for i := 0 ; i < len ( out ) ; i ++ { a := int16 ( volume * math . MaxInt16 ) if i % length < int ( float64 ( length ) * sequence ) { a = - a } out [ i ] = a } } 
func toBytes ( l , r [ ] int16 ) [ ] byte { if len ( l ) != len ( r ) { panic ( " " ) } b := make ( [ ] byte , len ( l ) * 4 ) for i := range l { b [ 4 * i ] = byte ( l [ i ] ) b [ 4 * i + 1 ] = byte ( l [ i ] >> 8 ) b [ 4 * i + 2 ] = byte ( r [ i ] ) b [ 4 * i + 3 ] = byte ( r [ i ] >> 8 ) } return b } 
func playNote ( scoreIndex int ) rune { note := score [ scoreIndex ] } freqs := [ ] float64 { freqC , freqD , freqE , freqF , freqG , freqA * 2 , freqB * 2 } freq := 0.0 switch { case 'A' <= note && note <= 'B' : freq = freqs [ int ( note ) + len ( freqs ) - int ( 'C' ) ] case 'C' <= note && note <= 'G' : freq = freqs [ note - 'C' ] default : panic ( " " ) } const vol = 1.0 / 16.0 size := ( ebiten . MaxTPS ( ) / 2 - 2 ) * sampleRate / ebiten . MaxTPS ( ) l := make ( [ ] int16 , size ) r := make ( [ ] int16 , size ) square ( l , vol , freq , 0.25 ) square ( r , vol , freq , 0.25 ) p , _ := audio . NewPlayerFromBytes ( audioContext , toBytes ( l , r ) ) p . Play ( ) return rune ( note ) } 
func NewImageFromURL ( url string ) ( * ebiten . Image , error ) { res , err := http . Get ( url ) if err != nil { return nil , err } defer res . Body . Close ( ) img , _ , err := image . Decode ( res . Body ) if err != nil { return nil , err } eimg , _ := ebiten . NewImageFromImage ( img , ebiten . FilterDefault ) return eimg , nil } 
func pianoAt ( i int , freq float64 ) float64 { x := [ ] float64 { 4.0 , 2.0 , 1.0 , 0.5 , 0.25 } v := 0.0 for j := 0 ; j < len ( amp ) ; j ++ { v += a * math . Sin ( 2.0 * math . Pi * float64 ( i ) * freq * float64 ( j + 1 ) / sampleRate ) } return v / 5.0 } 
func playNote ( freq float64 ) { f := int ( freq ) p , _ := audio . NewPlayerFromBytes ( audioContext , pianoNoteSamples [ f ] ) p . Play ( ) } 
func ( p * Path ) MoveTo ( x , y float32 ) { p . cur = math . Point { x , y } if len ( p . segs ) > 0 && len ( p . segs [ len ( p . segs ) - 1 ] ) == 0 { return } p . segs = append ( p . segs , [ ] math . Segment { } ) } 
func ( p * Path ) LineTo ( x , y float32 ) { if len ( p . segs ) == 0 { p . segs = append ( p . segs , [ ] math . Segment { } ) } p . segs [ len ( p . segs ) - 1 ] = append ( p . segs [ len ( p . segs ) - 1 ] , math . Segment { p . cur , math . Point { x , y } } ) p . cur = math . Point { x , y } } 
func ( p * Path ) Draw ( target * ebiten . Image , op * DrawPathOptions ) { if op == nil { return } op := & ebiten . DrawTrianglesOptions { } op . Address = ebiten . AddressRepeat target . DrawTriangles ( vs , is , emptyImage , op ) } } 
func seekNextFrame ( buf [ ] byte ) ( [ ] byte , bool ) { } buf = buf [ 1 : ] for { if buf [ 0 ] == 0xff && buf [ 1 ] & 0xfe == 0xfe { break } buf = buf [ 1 : ] if len ( buf ) < 2 { return nil , false } } return buf , true } 
func ( g * GeoM ) String ( ) string { return fmt . Sprintf ( " " , g . a_1 + 1 , g . b , g . tx , g . c , g . d_1 + 1 , g . ty ) } 
func ( g * GeoM ) Reset ( ) { g . a_1 = 0 g . b = 0 g . c = 0 g . d_1 = 0 g . tx = 0 g . ty = 0 } 
func ( g * GeoM ) Apply ( x , y float64 ) ( float64 , float64 ) { x2 , y2 := g . apply32 ( float32 ( x ) , float32 ( y ) ) return float64 ( x2 ) , float64 ( y2 ) } 
func ( g * GeoM ) Element ( i , j int ) float64 { switch { case i == 0 && j == 0 : return float64 ( g . a_1 ) + 1 case i == 0 && j == 1 : return float64 ( g . b ) case i == 0 && j == 2 : return float64 ( g . tx ) case i == 1 && j == 0 : return float64 ( g . c ) case i == 1 && j == 1 : return float64 ( g . d_1 ) + 1 case i == 1 && j == 2 : return float64 ( g . ty ) default : panic ( " " ) } } 
func ( g * GeoM ) Concat ( other GeoM ) { a := ( other . a_1 + 1 ) * ( g . a_1 + 1 ) + other . b * g . c b := ( other . a_1 + 1 ) * g . b + other . b * ( g . d_1 + 1 ) tx := ( other . a_1 + 1 ) * g . tx + other . b * g . ty + other . tx c := other . c * ( g . a_1 + 1 ) + ( other . d_1 + 1 ) * g . c d := other . c * g . b + ( other . d_1 + 1 ) * ( g . d_1 + 1 ) ty := other . c * g . tx + ( other . d_1 + 1 ) * g . ty + other . ty g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * GeoM ) Add ( other GeoM ) { g . a_1 += other . a_1 g . b += other . b g . c += other . c g . d_1 += other . d_1 g . tx += other . tx g . ty += other . ty } 
func ( g * GeoM ) Scale ( x , y float64 ) { a := ( float64 ( g . a_1 ) + 1 ) * x b := float64 ( g . b ) * x tx := float64 ( g . tx ) * x c := float64 ( g . c ) * y d := ( float64 ( g . d_1 ) + 1 ) * y ty := float64 ( g . ty ) * y g . a_1 = float32 ( a ) - 1 g . b = float32 ( b ) g . c = float32 ( c ) g . d_1 = float32 ( d ) - 1 g . tx = float32 ( tx ) g . ty = float32 ( ty ) } 
func ( g * GeoM ) Translate ( tx , ty float64 ) { g . tx += float32 ( tx ) g . ty += float32 ( ty ) } 
func ( g * GeoM ) Rotate ( theta float64 ) { if theta == 0 { return } sin64 , cos64 := math . Sincos ( theta ) sin , cos := float32 ( sin64 ) , float32 ( cos64 ) a := cos * ( g . a_1 + 1 ) - sin * g . c b := cos * g . b - sin * ( g . d_1 + 1 ) tx := cos * g . tx - sin * g . ty c := sin * ( g . a_1 + 1 ) + cos * g . c d := sin * g . b + cos * ( g . d_1 + 1 ) ty := sin * g . tx + cos * g . ty g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * GeoM ) Skew ( skewX , skewY float64 ) { sx64 := math . Tan ( skewX ) sy64 := math . Tan ( skewY ) sx , sy := float32 ( sx64 ) , float32 ( sy64 ) a := ( g . a_1 + 1 ) + g . c * sx b := g . b + ( g . d_1 + 1 ) * sx c := ( g . a_1 + 1 ) * sy + g . c d := g . b * sy + ( g . d_1 + 1 ) tx := g . tx + g . ty * sx ty := g . ty + g . tx * sy g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * GeoM ) Invert ( ) { det := g . det ( ) if det == 0 { panic ( " " ) } a := ( g . d_1 + 1 ) / det b := - g . b / det c := - g . c / det d := ( g . a_1 + 1 ) / det tx := ( - ( g . d_1 + 1 ) * g . tx + g . b * g . ty ) / det ty := ( g . c * g . tx + - ( g . a_1 + 1 ) * g . ty ) / det g . a_1 = a - 1 g . b = b g . c = c g . d_1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * GeoM ) SetElement ( i , j int , element float64 ) { e := float32 ( element ) switch { case i == 0 && j == 0 : g . a_1 = e - 1 case i == 0 && j == 1 : g . b = e case i == 0 && j == 2 : g . tx = e case i == 1 && j == 0 : g . c = e case i == 1 && j == 1 : g . d_1 = e - 1 case i == 1 && j == 2 : g . ty = e default : panic ( " " ) } } 
func ScaleGeo ( x , y float64 ) GeoM { g := GeoM { } g . Scale ( x , y ) return g } 
func TranslateGeo ( tx , ty float64 ) GeoM { g := GeoM { } g . Translate ( tx , ty ) return g } 
func RotateGeo ( theta float64 ) GeoM { g := GeoM { } g . Rotate ( theta ) return g } 
func clamp ( v , min , max int ) int { if min > max { panic ( " " ) } if v < min { return min } if max < v { return max } return v } 
func newFramebufferFromTexture ( context * context , texture textureNative , width , height int ) ( * framebuffer , error ) { native , err := context . newFramebuffer ( texture ) if err != nil { return nil , err } return & framebuffer { native : native , width : width , height : height , } , nil } 
func newScreenFramebuffer ( context * context , width , height int ) * framebuffer { return & framebuffer { native : context . getScreenFramebuffer ( ) , width : width , height : height , } } 
func opaque ( m image . Image ) bool { if o , ok := m . ( opaquer ) ; ok { return o . Opaque ( ) } b := m . Bounds ( ) for y := b . Min . Y ; y < b . Max . Y ; y ++ { for x := b . Min . X ; x < b . Max . X ; x ++ { _ , _ , _ , a := m . At ( x , y ) . RGBA ( ) if a != 0xffff { return false } } } return true } 
func ( e * encoder ) Write ( b [ ] byte ) ( int , error ) { e . writeChunk ( b , " " ) if e . err != nil { return 0 , e . err } return len ( b ) , nil } 
func filter ( cr * [ nFilter ] [ ] byte , pr [ ] byte , bpp int ) int { cdat1 := cr [ 1 ] [ 1 : ] cdat2 := cr [ 2 ] [ 1 : ] cdat3 := cr [ 3 ] [ 1 : ] cdat4 := cr [ 4 ] [ 1 : ] pdat := pr [ 1 : ] n := len ( cdat0 ) for i := 0 ; i < n ; i ++ { cdat2 [ i ] = cdat0 [ i ] - pdat [ i ] sum += abs8 ( cdat2 [ i ] ) } best := sum filter := ftUp for i := 0 ; i < bpp ; i ++ { cdat4 [ i ] = cdat0 [ i ] - pdat [ i ] sum += abs8 ( cdat4 [ i ] ) } for i := bpp ; i < n ; i ++ { cdat4 [ i ] = cdat0 [ i ] - paeth ( cdat0 [ i - bpp ] , pdat [ i ] , pdat [ i - bpp ] ) sum += abs8 ( cdat4 [ i ] ) if sum >= best { break } } if sum < best { best = sum filter = ftPaeth } for i := 0 ; i < n ; i ++ { sum += abs8 ( cdat0 [ i ] ) if sum >= best { break } } if sum < best { best = sum filter = ftNone } for i := 0 ; i < bpp ; i ++ { cdat1 [ i ] = cdat0 [ i ] sum += abs8 ( cdat1 [ i ] ) } for i := bpp ; i < n ; i ++ { cdat1 [ i ] = cdat0 [ i ] - cdat0 [ i - bpp ] sum += abs8 ( cdat1 [ i ] ) if sum >= best { break } } if sum < best { best = sum filter = ftSub } for i := 0 ; i < bpp ; i ++ { cdat3 [ i ] = cdat0 [ i ] - pdat [ i ] / 2 sum += abs8 ( cdat3 [ i ] ) } for i := bpp ; i < n ; i ++ { cdat3 [ i ] = cdat0 [ i ] - uint8 ( ( int ( cdat0 [ i - bpp ] ) + int ( pdat [ i ] ) ) / 2 ) sum += abs8 ( cdat3 [ i ] ) if sum >= best { break } } if sum < best { best = sum filter = ftAverage } return filter } 
func ( e * encoder ) writeIDATs ( ) { if e . err != nil { return } if e . bw == nil { e . bw = bufio . NewWriterSize ( e , 1 << 15 ) } else { e . bw . Reset ( e ) } e . err = e . writeImage ( e . bw , e . m , e . cb , levelToZlib ( e . enc . CompressionLevel ) ) if e . err != nil { return } e . err = e . bw . Flush ( ) } 
func levelToZlib ( l CompressionLevel ) int { switch l { case DefaultCompression : return zlib . DefaultCompression case NoCompression : return zlib . NoCompression case BestSpeed : return zlib . BestSpeed case BestCompression : return zlib . BestCompression default : return zlib . DefaultCompression } } 
func Encode ( w io . Writer , m image . Image ) error { var e Encoder return e . Encode ( w , m ) } 
func ( enc * Encoder ) Encode ( w io . Writer , m image . Image ) error { if mw <= 0 || mh <= 0 || mw >= 1 << 32 || mh >= 1 << 32 { return FormatError ( " " + strconv . FormatInt ( mw , 10 ) + " " + strconv . FormatInt ( mh , 10 ) ) } var e * encoder if enc . BufferPool != nil { buffer := enc . BufferPool . Get ( ) e = ( * encoder ) ( buffer ) } if e == nil { e = & encoder { } } if enc . BufferPool != nil { defer enc . BufferPool . Put ( ( * EncoderBuffer ) ( e ) ) } e . enc = enc e . w = w e . m = m var pal color . Palette } if pal != nil { if len ( pal ) <= 2 { e . cb = cbP1 } else if len ( pal ) <= 4 { e . cb = cbP2 } else if len ( pal ) <= 16 { e . cb = cbP4 } else { e . cb = cbP8 } } else { switch m . ColorModel ( ) { case color . GrayModel : e . cb = cbG8 case color . Gray16Model : e . cb = cbG16 case color . RGBAModel , color . NRGBAModel , color . AlphaModel : if opaque ( m ) { e . cb = cbTC8 } else { e . cb = cbTCA8 } default : if opaque ( m ) { e . cb = cbTC16 } else { e . cb = cbTCA16 } } } _ , e . err = io . WriteString ( w , pngHeader ) e . writeIHDR ( ) if pal != nil { e . writePLTEAndTRNS ( pal ) } e . writeIDATs ( ) e . writeIEND ( ) return e . err } 
func NewImage ( width , height int ) * Image { i := & Image { image : graphicscommand . NewImage ( width , height ) , } i . clear ( ) theImages . add ( i ) return i } 
func NewScreenFramebufferImage ( width , height int ) * Image { i := & Image { image : graphicscommand . NewScreenFramebufferImage ( width , height ) , screen : true , } i . clear ( ) theImages . add ( i ) return i } 
func ( i * Image ) internalSize ( ) ( int , int ) { if i . w2 == 0 || i . h2 == 0 { w , h := i . image . Size ( ) i . w2 = graphics . InternalImageSize ( w ) i . h2 = graphics . InternalImageSize ( h ) } return i . w2 , i . h2 } 
func ( i * Image ) makeStale ( ) { i . basePixels = nil i . drawTrianglesHistory = nil i . stale = true 
func ( i * Image ) ReplacePixels ( pixels [ ] byte , x , y , width , height int ) { w , h := i . image . Size ( ) if width <= 0 || height <= 0 { panic ( " " ) } if x < 0 || y < 0 || w <= x || h <= y || x + width <= 0 || y + height <= 0 || w < x + width || h < y + height { panic ( fmt . Sprintf ( " " , x , y , width , height ) ) } if pixels == nil { pixels = make ( [ ] byte , 4 * width * height ) } i . image . ReplacePixels ( pixels , x , y , width , height ) if ! IsRestoringEnabled ( ) { i . makeStale ( ) return } if x == 0 && y == 0 && width == w && height == h { if pixels != nil { if i . basePixels == nil { i . basePixels = & Pixels { length : 4 * w * h , } } i . basePixels . CopyFrom ( pixels , 0 ) } else { } i . drawTrianglesHistory = nil i . stale = false return } if len ( i . drawTrianglesHistory ) > 0 { panic ( " " ) } if i . stale { return } idx := 4 * ( y * w + x ) if pixels != nil { if i . basePixels == nil { i . basePixels = & Pixels { length : 4 * w * h , } } for j := 0 ; j < height ; j ++ { i . basePixels . CopyFrom ( pixels [ 4 * j * width : 4 * ( j + 1 ) * width ] , idx ) idx += 4 * w } } else if i . basePixels != nil { zeros := make ( [ ] byte , 4 * width ) for j := 0 ; j < height ; j ++ { i . basePixels . CopyFrom ( zeros , idx ) idx += 4 * w } } } 
func ( i * Image ) DrawTriangles ( img * Image , vertices [ ] float32 , indices [ ] uint16 , colorm * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) { if i . priority { panic ( " " ) } if len ( vertices ) == 0 { return } theImages . makeStaleIfDependingOn ( i ) if img . stale || img . volatile || i . screen || ! IsRestoringEnabled ( ) || i . volatile { i . makeStale ( ) } else { i . appendDrawTrianglesHistory ( img , vertices , indices , colorm , mode , filter , address ) } i . image . DrawTriangles ( img . image , vertices , indices , colorm , mode , filter , address ) } 
func ( i * Image ) appendDrawTrianglesHistory ( image * Image , vertices [ ] float32 , indices [ ] uint16 , colorm * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) { if i . stale || i . volatile || i . screen { return } if len ( i . drawTrianglesHistory ) + 1 > maxDrawTrianglesHistoryNum { i . makeStale ( ) return } i . drawTrianglesHistory = append ( i . drawTrianglesHistory , item ) } 
func ( i * Image ) At ( x , y int ) ( byte , byte , byte , byte ) { w , h := i . image . Size ( ) if x < 0 || y < 0 || w <= x || h <= y { return 0 , 0 , 0 , 0 } i . readPixelsFromGPUIfNeeded ( ) } idx := 4 * x + 4 * y * w return i . basePixels . At ( idx ) , i . basePixels . At ( idx + 1 ) , i . basePixels . At ( idx + 2 ) , i . basePixels . At ( idx + 3 ) } 
func ( i * Image ) makeStaleIfDependingOn ( target * Image ) { if i . stale { return } if i . dependsOn ( target ) { i . makeStale ( ) } } 
func ( i * Image ) readPixelsFromGPU ( ) { pix := i . image . Pixels ( ) i . basePixels = & Pixels { pixels : pix , length : len ( pix ) , } i . drawTrianglesHistory = nil i . stale = false } 
func ( i * Image ) resolveStale ( ) { if ! IsRestoringEnabled ( ) { return } if i . volatile { return } if i . screen { return } if ! i . stale { return } i . readPixelsFromGPU ( ) } 
func ( i * Image ) dependsOn ( target * Image ) bool { for _ , c := range i . drawTrianglesHistory { if c . image == target { return true } } return false } 
func ( i * Image ) dependingImages ( ) map [ * Image ] struct { } { r := map [ * Image ] struct { } { } for _ , c := range i . drawTrianglesHistory { r [ c . image ] = struct { } { } } return r } 
func ( i * Image ) hasDependency ( ) bool { if i . stale { return false } return len ( i . drawTrianglesHistory ) > 0 } 
func ( i * Image ) restore ( ) error { w , h := i . image . Size ( ) if i . screen { i . basePixels = nil i . drawTrianglesHistory = nil i . stale = false return nil } if i . volatile { i . image = graphicscommand . NewImage ( w , h ) i . clear ( ) return nil } if i . stale { } gimg := graphicscommand . NewImage ( w , h ) if i . basePixels != nil { gimg . ReplacePixels ( i . basePixels . Slice ( ) , 0 , 0 , w , h ) } else { gimg . ReplacePixels ( pix , 0 , 0 , w , h ) } for _ , c := range i . drawTrianglesHistory { if c . image . hasDependency ( ) { panic ( " " ) } gimg . DrawTriangles ( c . image . image , c . vertices , c . indices , c . colorm , c . mode , c . filter , c . address ) } i . image = gimg pix := gimg . Pixels ( ) i . basePixels = & Pixels { pixels : pix , length : len ( pix ) , } i . drawTrianglesHistory = nil i . stale = false return nil } 
func ( i * Image ) Dispose ( ) { theImages . remove ( i ) i . image . Dispose ( ) i . image = nil i . basePixels = nil i . drawTrianglesHistory = nil i . stale = false } 
func ( i * Image ) IsInvalidated ( ) ( bool , error ) { if ! IsRestoringEnabled ( ) { return false , nil } return i . image . IsInvalidated ( ) , nil } 
func NewImage ( width , height int ) * Image { i := & Image { width : width , height : height , } c := & newImageCommand { result : i , width : width , height : height , } theCommandQueue . Enqueue ( c ) return i } 
func ( i * Image ) Pixels ( ) [ ] byte { c := & pixelsCommand { result : nil , img : i , } theCommandQueue . Enqueue ( c ) theCommandQueue . Flush ( ) return c . result } 
func ( i * Image ) CopyPixels ( src * Image ) { if i . lastCommand == lastCommandDrawTriangles { if i . width != src . width || i . height != src . height { panic ( " " ) } } c := & copyPixelsCommand { dst : i , src : src , } theCommandQueue . Enqueue ( c ) } 
func ( t * Tile ) Pos ( ) ( int , int ) { return t . current . x , t . current . y } 
func ( t * Tile ) NextPos ( ) ( int , int ) { return t . next . x , t . next . y } 
func NewTile ( value int , x , y int ) * Tile { return & Tile { current : TileData { value : value , x : x , y : y , } , startPoppingCount : maxPoppingCount , } } 
func MoveTiles ( tiles map [ * Tile ] struct { } , size int , dir Dir ) bool { vx , vy := dir . Vector ( ) tx := [ ] int { } ty := [ ] int { } for i := 0 ; i < size ; i ++ { tx = append ( tx , i ) ty = append ( ty , i ) } if vx > 0 { sort . Sort ( sort . Reverse ( sort . IntSlice ( tx ) ) ) } if vy > 0 { sort . Sort ( sort . Reverse ( sort . IntSlice ( ty ) ) ) } moved := false for _ , j := range ty { for _ , i := range tx { t := tileAt ( tiles , i , j ) if t == nil { continue } if t . next != ( TileData { } ) { panic ( " " ) } if t . IsMoving ( ) { panic ( " " ) } jj := j for { ni := ii + vx nj := jj + vy if ni < 0 || ni >= size || nj < 0 || nj >= size { break } tt := currentOrNextTileAt ( tiles , ni , nj ) if tt == nil { ii = ni jj = nj moved = true continue } if t . current . value != tt . current . value { break } if 0 < tt . movingCount && tt . current . value != tt . next . value { } ii = ni jj = nj moved = true break } next . value = t . current . value tt . next . value = 0 tt . next . x = ii tt . next . y = jj tt . movingCount = maxMovingCount } next . x = ii next . y = jj if t . current != next { t . next = next t . movingCount = maxMovingCount } } } if ! moved { for t := range tiles { t . next = TileData { } t . movingCount = 0 } } return moved } 
func ( t * Tile ) Update ( ) error { switch { case 0 < t . movingCount : t . movingCount -- if t . movingCount == 0 { if t . current . value != t . next . value && 0 < t . next . value { t . poppingCount = maxPoppingCount } t . current = t . next t . next = TileData { } } case 0 < t . startPoppingCount : t . startPoppingCount -- case 0 < t . poppingCount : t . poppingCount -- } return nil } 
func ( t * Tile ) Draw ( boardImage * ebiten . Image ) { i , j := t . current . x , t . current . y ni , nj := t . next . x , t . next . y v := t . current . value if v == 0 { return } op := & ebiten . DrawImageOptions { } x := i * tileSize + ( i + 1 ) * tileMargin y := j * tileSize + ( j + 1 ) * tileMargin nx := ni * tileSize + ( ni + 1 ) * tileMargin ny := nj * tileSize + ( nj + 1 ) * tileMargin switch { case 0 < t . movingCount : rate := 1 - float64 ( t . movingCount ) / maxMovingCount x = mean ( x , nx , rate ) y = mean ( y , ny , rate ) case 0 < t . startPoppingCount : rate := 1 - float64 ( t . startPoppingCount ) / float64 ( maxPoppingCount ) scale := meanF ( 0.0 , 1.0 , rate ) op . GeoM . Translate ( float64 ( - tileSize / 2 ) , float64 ( - tileSize / 2 ) ) op . GeoM . Scale ( scale , scale ) op . GeoM . Translate ( float64 ( tileSize / 2 ) , float64 ( tileSize / 2 ) ) case 0 < t . poppingCount : const maxScale = 1.2 rate := 0.0 if maxPoppingCount * 2 / 3 <= t . poppingCount { } else { } scale := meanF ( 1.0 , maxScale , rate ) op . GeoM . Translate ( float64 ( - tileSize / 2 ) , float64 ( - tileSize / 2 ) ) op . GeoM . Scale ( scale , scale ) op . GeoM . Translate ( float64 ( tileSize / 2 ) , float64 ( tileSize / 2 ) ) } op . GeoM . Translate ( float64 ( x ) , float64 ( y ) ) r , g , b , a := colorToScale ( tileBackgroundColor ( v ) ) op . ColorM . Scale ( r , g , b , a ) boardImage . DrawImage ( tileImage , op ) str := strconv . Itoa ( v ) f := mplusBigFont switch { case 3 < len ( str ) : f = mplusSmallFont case 2 < len ( str ) : f = mplusNormalFont } bound , _ := font . BoundString ( f , str ) w := ( bound . Max . X - bound . Min . X ) . Ceil ( ) h := ( bound . Max . Y - bound . Min . Y ) . Ceil ( ) x = x + ( tileSize - w ) / 2 y = y + ( tileSize - h ) / 2 + h text . Draw ( boardImage , str , f , x , y , tileColor ( v ) ) } 
func ( c * ColorM ) String ( ) string { b , t := c . impl . UnsafeElements ( ) return fmt . Sprintf ( " " , b [ 0 ] , b [ 4 ] , b [ 8 ] , b [ 12 ] , t [ 0 ] , b [ 1 ] , b [ 5 ] , b [ 9 ] , b [ 13 ] , t [ 1 ] , b [ 2 ] , b [ 6 ] , b [ 10 ] , b [ 14 ] , t [ 2 ] , b [ 3 ] , b [ 7 ] , b [ 11 ] , b [ 15 ] , t [ 3 ] ) } 
func ( c * ColorM ) Apply ( clr color . Color ) color . Color { return c . impl . Apply ( clr ) } 
func ( c * ColorM ) Concat ( other ColorM ) { c . impl = c . impl . Concat ( other . impl ) } 
func ( c * ColorM ) Add ( other ColorM ) { c . impl = c . impl . Add ( other . impl ) } 
func ( c * ColorM ) Scale ( r , g , b , a float64 ) { c . impl = c . impl . Scale ( float32 ( r ) , float32 ( g ) , float32 ( b ) , float32 ( a ) ) } 
func ( c * ColorM ) ChangeHSV ( hueTheta float64 , saturationScale float64 , valueScale float64 ) { c . impl = c . impl . ChangeHSV ( hueTheta , float32 ( saturationScale ) , float32 ( valueScale ) ) } 
func ( c * ColorM ) Element ( i , j int ) float64 { b , t := c . impl . UnsafeElements ( ) if j < ColorMDim - 1 { return float64 ( b [ i + j * ( ColorMDim - 1 ) ] ) } return float64 ( t [ i ] ) } 
func ( c * ColorM ) SetElement ( i , j int , element float64 ) { c . impl = c . impl . SetElement ( i , j , float32 ( element ) ) } 
func ScaleColor ( r , g , b , a float64 ) ColorM { c := ColorM { } c . Scale ( r , g , b , a ) return c } 
func TranslateColor ( r , g , b , a float64 ) ColorM { c := ColorM { } c . Translate ( r , g , b , a ) return c } 
func RotateHue ( theta float64 ) ColorM { c := ColorM { } c . RotateHue ( theta ) return c } 
func availableFilename ( prefix , postfix string ) ( string , error ) { const datetimeFormat = " " now := time . Now ( ) name := fmt . Sprintf ( " " , prefix , now . Format ( datetimeFormat ) , postfix ) for i := 1 ; ; i ++ { if _ , err := os . Stat ( name ) ; err != nil { if os . IsNotExist ( err ) { break } if ! os . IsNotExist ( err ) { return " " , err } } name = fmt . Sprintf ( " " , prefix , now . Format ( datetimeFormat ) , i , postfix ) } return name , nil } 
func NewImageFromFile ( path string , filter ebiten . Filter ) ( * ebiten . Image , image . Image , error ) { file , err := OpenFile ( path ) if err != nil { return nil , nil , err } defer func ( ) { _ = file . Close ( ) } ( ) img , _ , err := image . Decode ( file ) if err != nil { return nil , nil , err } img2 , err := ebiten . NewImageFromImage ( img , filter ) if err != nil { return nil , nil , err } return img2 , img , err } 
func ( u * UserInterface ) appMain ( a app . App ) { var glctx gl . Context touches := map [ touch . Sequence ] * Touch { } for e := range a . Events ( ) { switch e := a . Filter ( e ) . ( type ) { case lifecycle . Event : switch e . Crosses ( lifecycle . StageVisible ) { case lifecycle . CrossOn : glctx , _ = e . DrawContext . ( gl . Context ) glContextCh = nil } a . Send ( paint . Event { } ) case lifecycle . CrossOff : glctx = nil } case size . Event : u . setFullscreenImpl ( e . WidthPx , e . HeightPx ) case paint . Event : if glctx == nil || e . External { continue } renderCh <- struct { } { } <- renderChEnd a . Publish ( ) a . Send ( paint . Event { } ) case touch . Event : switch e . Type { case touch . TypeBegin , touch . TypeMove : s := getDeviceScale ( ) x , y := float64 ( e . X ) / s , float64 ( e . Y ) / s case touch . TypeEnd : delete ( touches , e . Sequence ) } ts := [ ] * Touch { } for _ , t := range touches { ts = append ( ts , t ) } u . input . update ( ts ) } } } 
func repeatingKeyPressed ( key ebiten . Key ) bool { const ( delay = 30 interval = 3 ) d := inpututil . KeyPressDuration ( key ) if d == 1 { return true } if d >= delay && ( d - delay ) % interval == 0 { return true } return false } 
func ( a * arrayBufferLayout ) totalBytes ( ) int { if a . total != 0 { return a . total } t := 0 for _ , p := range a . parts { t += float . SizeInBytes ( ) * p . num } a . total = t return a . total } 
func ( a * arrayBufferLayout ) newArrayBuffer ( context * context ) buffer { return context . newArrayBuffer ( a . totalBytes ( ) * graphics . IndicesNum ) } 
func ( a * arrayBufferLayout ) enable ( context * context , program program ) { for i := range a . parts { context . enableVertexAttribArray ( program , i ) } total := a . totalBytes ( ) offset := 0 for i , p := range a . parts { context . vertexAttribPointer ( program , i , p . num , float , total , offset ) offset += float . SizeInBytes ( ) * p . num } } 
func ( a * arrayBufferLayout ) disable ( context * context , program program ) { } } 
func ( s * openGLState ) reset ( context * context ) error { if err := context . reset ( ) ; err != nil { return err } s . lastProgram = zeroProgram s . lastViewportWidth = 0 s . lastViewportHeight = 0 s . lastColorMatrix = nil s . lastColorMatrixTranslation = nil s . lastSourceWidth = 0 s . lastSourceHeight = 0 s . lastFilter = nil s . lastAddress = nil } else { for k , p := range s . programs { context . deleteProgram ( p ) delete ( s . programs , k ) } } } if s . elementArrayBuffer != zeroBuffer { context . deleteBuffer ( s . elementArrayBuffer ) } } shaderVertexModelviewNative , err := context . newShader ( vertexShader , vertexShaderStr ( ) ) if err != nil { panic ( fmt . Sprintf ( " \n " , err ) ) } defer context . deleteShader ( shaderVertexModelviewNative ) for _ , c := range [ ] bool { false , true } { for _ , a := range [ ] graphics . Address { graphics . AddressClampToZero , graphics . AddressRepeat , } { for _ , f := range [ ] graphics . Filter { graphics . FilterNearest , graphics . FilterLinear , graphics . FilterScreen , } { shaderFragmentColorMatrixNative , err := context . newShader ( fragmentShader , fragmentShaderStr ( c , f , a ) ) if err != nil { panic ( fmt . Sprintf ( " \n " , err ) ) } defer context . deleteShader ( shaderFragmentColorMatrixNative ) program , err := context . newProgram ( [ ] shader { shaderVertexModelviewNative , shaderFragmentColorMatrixNative , } , theArrayBufferLayout . names ( ) ) if err != nil { return err } s . programs [ programKey { useColorM : c , filter : f , address : a , } ] = program } } } s . arrayBuffer = theArrayBufferLayout . newArrayBuffer ( context ) return nil } 
func areSameFloat32Array ( a , b [ ] float32 ) bool { if len ( a ) != len ( b ) { return false } for i := 0 ; i < len ( a ) ; i ++ { if a [ i ] != b [ i ] { return false } } return true } 
func ( d * Driver ) useProgram ( mode graphics . CompositeMode , colorM * affine . ColorM , filter graphics . Filter , address graphics . Address ) error { destination := d . state . destination if destination == nil { panic ( " " ) } source := d . state . source if source == nil { panic ( " " ) } if err := destination . setViewport ( ) ; err != nil { return err } dstW := destination . width srcW , srcH := source . width , source . height d . context . blendFunc ( mode ) program := d . state . programs [ programKey { useColorM : colorM != nil , filter : filter , address : address , } ] if d . state . lastProgram != program { d . context . useProgram ( program ) if d . state . lastProgram == zeroProgram { theArrayBufferLayout . enable ( & d . context , program ) d . context . bindBuffer ( arrayBuffer , d . state . arrayBuffer ) d . context . bindBuffer ( elementArrayBuffer , d . state . elementArrayBuffer ) d . context . uniformInt ( program , " " , 0 ) } d . state . lastProgram = program d . state . lastViewportWidth = 0 d . state . lastViewportHeight = 0 d . state . lastColorMatrix = nil d . state . lastColorMatrixTranslation = nil d . state . lastSourceWidth = 0 d . state . lastSourceHeight = 0 } vw := destination . framebuffer . width vh := destination . framebuffer . height if d . state . lastViewportWidth != vw || d . state . lastViewportHeight != vh { d . context . uniformFloats ( program , " " , [ ] float32 { float32 ( vw ) , float32 ( vh ) } ) d . state . lastViewportWidth = vw d . state . lastViewportHeight = vh } if colorM != nil { esBody , esTranslate := colorM . UnsafeElements ( ) if ! areSameFloat32Array ( d . state . lastColorMatrix , esBody ) { d . context . uniformFloats ( program , " " , esBody ) } if ! areSameFloat32Array ( d . state . lastColorMatrixTranslation , esTranslate ) { d . context . uniformFloats ( program , " " , esTranslate ) } } if filter != graphics . FilterNearest { sw := graphics . InternalImageSize ( srcW ) sh := graphics . InternalImageSize ( srcH ) if d . state . lastSourceWidth != sw || d . state . lastSourceHeight != sh { d . context . uniformFloats ( program , " " , [ ] float32 { float32 ( sw ) , float32 ( sh ) } ) d . state . lastSourceWidth = sw d . state . lastSourceHeight = sh } } if filter == graphics . FilterScreen { scale := float32 ( dstW ) / float32 ( srcW ) d . context . uniformFloat ( program , " " , scale ) } d . state . source = nil d . state . destination = nil return nil } 
func NewInfiniteLoopWithIntro ( src ReadSeekCloser , introLength int64 , loopLength int64 ) * InfiniteLoop { return & InfiniteLoop { src : src , lstart : introLength , llength : loopLength , pos : - 1 , } } 
func ( i * InfiniteLoop ) Read ( b [ ] byte ) ( int , error ) { if err := i . ensurePos ( ) ; err != nil { return 0 , err } if i . pos + int64 ( len ( b ) ) > i . length ( ) { b = b [ : i . length ( ) - i . pos ] } n , err := i . src . Read ( b ) i . pos += int64 ( n ) if i . pos > i . length ( ) { panic ( fmt . Sprintf ( " " , i . pos , i . length ( ) ) ) } if err != nil && err != io . EOF { return 0 , err } if err == io . EOF || i . pos == i . length ( ) { pos , err := i . Seek ( i . lstart , io . SeekStart ) if err != nil { return 0 , err } i . pos = pos } return n , nil } 
func ( i * InfiniteLoop ) Seek ( offset int64 , whence int ) ( int64 , error ) { if err := i . ensurePos ( ) ; err != nil { return 0 , err } next := int64 ( 0 ) switch whence { case io . SeekStart : next = offset case io . SeekCurrent : next = i . pos + offset case io . SeekEnd : return 0 , fmt . Errorf ( " " ) } if next < 0 { return 0 , fmt . Errorf ( " " ) } if next >= i . lstart { next = ( ( next - i . lstart ) % i . llength ) + i . lstart } } i . pos = next return i . pos , nil } 
func GoStr ( cstr * uint8 ) string { str := " " for { if * cstr == 0 { break } str += string ( * cstr ) cstr = ( * uint8 ) ( unsafe . Pointer ( uintptr ( unsafe . Pointer ( cstr ) ) + 1 ) ) } return str } 
func Strs ( strs ... string ) ( cstrs * * uint8 , free func ( ) ) { if len ( strs ) == 0 { panic ( " " ) } var pinned [ ] string var ptrs [ ] * uint8 for _ , str := range strs { if ! strings . HasSuffix ( str , " \x00 " ) { str += " \x00 " } pinned = append ( pinned , str ) ptrs = append ( ptrs , Str ( str ) ) } return & ptrs [ 0 ] , func ( ) { runtime . KeepAlive ( pinned ) pinned = nil } } 
func Restore ( ) error { if err := graphicscommand . ResetGraphicsDriverState ( ) ; err != nil { return err } return theImages . restore ( ) } 
func ( i * images ) remove ( img * Image ) { i . makeStaleIfDependingOnImpl ( img ) delete ( i . images , img ) } 
func ( i * images ) resolveStaleImages ( ) { i . lastTarget = nil for img := range i . images { img . resolveStale ( ) } } 
func ( i * images ) restore ( ) error { if ! IsRestoringEnabled ( ) { panic ( " " ) } target * Image } images := map [ * Image ] struct { } { } for i := range i . images { if ! i . priority { images [ i ] = struct { } { } } } edges := map [ edge ] struct { } { } for t := range images { for s := range t . dependingImages ( ) { edges [ edge { source : s , target : t } ] = struct { } { } } } sorted := [ ] * Image { } for i := range i . images { if i . priority { sorted = append ( sorted , i ) } } for len ( images ) > 0 { for i := range images { current [ i ] = struct { } { } } for e := range edges { if _ , ok := current [ e . target ] ; ok { delete ( current , e . target ) } } for i := range current { delete ( images , i ) sorted = append ( sorted , i ) } removed := [ ] edge { } for e := range edges { if _ , ok := current [ e . source ] ; ok { removed = append ( removed , e ) } } for _ , e := range removed { delete ( edges , e ) } } for _ , img := range sorted { if err := img . restore ( ) ; err != nil { return err } } return nil } 
func ( p * player ) MoveForward ( ) { w , h := gophersImage . Size ( ) mx := w * 16 my := h * 16 s , c := math . Sincos ( float64 ( p . angle ) * 2 * math . Pi / maxAngle ) p . x16 += int ( round ( 16 * c ) * 2 ) p . y16 += int ( round ( 16 * s ) * 2 ) for mx <= p . x16 { p . x16 -= mx } for my <= p . y16 { p . y16 -= my } for p . x16 < 0 { p . x16 += mx } for p . y16 < 0 { p . y16 += my } } 
func ( p * player ) RotateRight ( ) { p . angle ++ if maxAngle <= p . angle { p . angle -= maxAngle } p . lean ++ if maxLean < p . lean { p . lean = maxLean } } 
func ( p * player ) RotateLeft ( ) { p . angle -- if p . angle < 0 { p . angle += maxAngle } p . lean -- if p . lean < - maxLean { p . lean = - maxLean } } 
func ( p * player ) Stabilize ( ) { if 0 < p . lean { p . lean -- } if p . lean < 0 { p . lean ++ } } 
func updateGroundImage ( ground * ebiten . Image ) { ground . Clear ( ) x16 , y16 := thePlayer . Position ( ) a := thePlayer . Angle ( ) gw , gh := ground . Size ( ) w , h := gophersImage . Size ( ) op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( float64 ( - x16 ) / 16 , float64 ( - y16 ) / 16 ) op . GeoM . Translate ( float64 ( - w * 2 ) , float64 ( - h * 2 ) ) op . GeoM . Rotate ( float64 ( - a ) * 2 * math . Pi / maxAngle + math . Pi * 3.0 / 2.0 ) op . GeoM . Translate ( float64 ( gw ) / 2 , float64 ( gh ) - 32 ) ground . DrawImage ( repeatedGophersImage , op ) } 
func drawGroundImage ( screen * ebiten . Image , ground * ebiten . Image ) { perspectiveGroundImage . Clear ( ) gw , _ := ground . Size ( ) pw , ph := perspectiveGroundImage . Size ( ) for j := 0 ; j < ph ; j ++ { z := ( 1 - rate ) * 2 + rate * - 1 if z <= 0 { break } op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( - float64 ( pw ) / 2 , 0 ) op . GeoM . Scale ( 1 / z , 8 ) op . GeoM . Translate ( float64 ( pw ) / 2 , float64 ( j ) / z ) perspectiveGroundImage . DrawImage ( ground . SubImage ( image . Rect ( 0 , j , gw , j + 1 ) ) . ( * ebiten . Image ) , op ) } perspectiveGroundImage . DrawImage ( fogImage , nil ) op := & ebiten . DrawImageOptions { } op . GeoM . Translate ( - float64 ( pw ) / 2 , 0 ) op . GeoM . Rotate ( - 1 * float64 ( thePlayer . lean ) / maxLean * math . Pi / 8 ) op . GeoM . Translate ( float64 ( screenWidth ) / 2 , screenHeight / 3 ) screen . DrawImage ( perspectiveGroundImage , op ) } 
func ( d Dir ) String ( ) string { switch d { case DirUp : return " " case DirRight : return " " case DirDown : return " " case DirLeft : return " " } panic ( " " ) } 
func ( d Dir ) Vector ( ) ( x , y int ) { switch d { case DirUp : return 0 , - 1 case DirRight : return 1 , 0 case DirDown : return 0 , 1 case DirLeft : return - 1 , 0 } panic ( " " ) } 
func ( i * Input ) Update ( ) { switch i . mouseState { case mouseStateNone : if ebiten . IsMouseButtonPressed ( ebiten . MouseButtonLeft ) { x , y := ebiten . CursorPosition ( ) i . mouseInitPosX = x i . mouseInitPosY = y i . mouseState = mouseStatePressing } case mouseStatePressing : if ! ebiten . IsMouseButtonPressed ( ebiten . MouseButtonLeft ) { x , y := ebiten . CursorPosition ( ) dx := x - i . mouseInitPosX dy := y - i . mouseInitPosY d , ok := vecToDir ( dx , dy ) if ! ok { i . mouseState = mouseStateNone break } i . mouseDir = d i . mouseState = mouseStateSettled } case mouseStateSettled : i . mouseState = mouseStateNone } switch i . touchState { case touchStateNone : ts := ebiten . TouchIDs ( ) if len ( ts ) == 1 { i . touchID = ts [ 0 ] x , y := ebiten . TouchPosition ( ts [ 0 ] ) i . touchInitPosX = x i . touchInitPosY = y i . touchLastPosX = x i . touchLastPosX = y i . touchState = touchStatePressing } case touchStatePressing : ts := ebiten . TouchIDs ( ) if len ( ts ) >= 2 { break } if len ( ts ) == 1 { if ts [ 0 ] != i . touchID { i . touchState = touchStateInvalid } else { x , y := ebiten . TouchPosition ( ts [ 0 ] ) i . touchLastPosX = x i . touchLastPosY = y } break } if len ( ts ) == 0 { dx := i . touchLastPosX - i . touchInitPosX dy := i . touchLastPosY - i . touchInitPosY d , ok := vecToDir ( dx , dy ) if ! ok { i . touchState = touchStateNone break } i . touchDir = d i . touchState = touchStateSettled } case touchStateSettled : i . touchState = touchStateNone case touchStateInvalid : if len ( ebiten . TouchIDs ( ) ) == 0 { i . touchState = touchStateNone } } } 
func ( i * Input ) Dir ( ) ( Dir , bool ) { if inpututil . IsKeyJustPressed ( ebiten . KeyUp ) { return DirUp , true } if inpututil . IsKeyJustPressed ( ebiten . KeyLeft ) { return DirLeft , true } if inpututil . IsKeyJustPressed ( ebiten . KeyRight ) { return DirRight , true } if inpututil . IsKeyJustPressed ( ebiten . KeyDown ) { return DirDown , true } if i . mouseState == mouseStateSettled { return i . mouseDir , true } if i . touchState == touchStateSettled { return i . touchDir , true } return 0 , false } 
func ( s * stream ) Read ( buf [ ] byte ) ( int , error ) { if len ( s . remaining ) > 0 { n := copy ( buf , s . remaining ) s . remaining = s . remaining [ n : ] return n , nil } var origBuf [ ] byte if len ( buf ) % 4 > 0 { origBuf = buf buf = make ( [ ] byte , len ( origBuf ) + 4 - len ( origBuf ) % 4 ) } const length = int64 ( sampleRate / frequency ) p := s . position / 4 for i := 0 ; i < len ( buf ) / 4 ; i ++ { const max = 32767 b := int16 ( math . Sin ( 2 * math . Pi * float64 ( p ) / float64 ( length ) ) * max ) buf [ 4 * i ] = byte ( b ) buf [ 4 * i + 1 ] = byte ( b >> 8 ) buf [ 4 * i + 2 ] = byte ( b ) buf [ 4 * i + 3 ] = byte ( b >> 8 ) p ++ } s . position += int64 ( len ( buf ) ) s . position %= length * 4 if origBuf != nil { n := copy ( origBuf , buf ) s . remaining = buf [ n : ] return n , nil } return len ( buf ) , nil } 
func ( i * Image ) Size ( ) ( width , height int ) { s := i . Bounds ( ) . Size ( ) return s . X , s . Y } 
func ( i * Image ) Fill ( clr color . Color ) error { i . copyCheck ( ) if i . isDisposed ( ) { return nil } } i . resolvePendingPixels ( false ) r16 , g16 , b16 , a16 := clr . RGBA ( ) r , g , b , a := uint8 ( r16 >> 8 ) , uint8 ( g16 >> 8 ) , uint8 ( b16 >> 8 ) , uint8 ( a16 >> 8 ) i . mipmap . original ( ) . Fill ( r , g , b , a ) i . disposeMipmaps ( ) return nil } 
func ( i * Image ) DrawImage ( img * Image , options * DrawImageOptions ) error { i . drawImage ( img , options ) return nil } 
func ( i * Image ) DrawTriangles ( vertices [ ] Vertex , indices [ ] uint16 , img * Image , options * DrawTrianglesOptions ) { i . copyCheck ( ) if i . isDisposed ( ) { return } if i . isSubImage ( ) { panic ( " " ) } img . resolvePendingPixels ( true ) i . resolvePendingPixels ( true ) if len ( indices ) % 3 != 0 { panic ( " " ) } if len ( indices ) > MaxIndicesNum { panic ( " " ) } } mode := graphics . CompositeMode ( options . CompositeMode ) filter := graphics . FilterNearest if options . Filter != FilterDefault { filter = graphics . Filter ( options . Filter ) } else if img . filter != FilterDefault { filter = graphics . Filter ( img . filter ) } vs := make ( [ ] float32 , len ( vertices ) * graphics . VertexFloatNum ) src := img . mipmap . original ( ) r := img . Bounds ( ) for idx , v := range vertices { src . PutVertex ( vs [ idx * graphics . VertexFloatNum : ( idx + 1 ) * graphics . VertexFloatNum ] , float32 ( v . DstX ) , float32 ( v . DstY ) , v . SrcX , v . SrcY , float32 ( r . Min . X ) , float32 ( r . Min . Y ) , float32 ( r . Max . X ) , float32 ( r . Max . Y ) , v . ColorR , v . ColorG , v . ColorB , v . ColorA ) } i . mipmap . original ( ) . DrawTriangles ( img . mipmap . original ( ) , vs , indices , options . ColorM . impl , mode , filter , graphics . Address ( options . Address ) ) i . disposeMipmaps ( ) } 
func ( i * Image ) SubImage ( r image . Rectangle ) image . Image { i . copyCheck ( ) if i . isDisposed ( ) { return nil } img := & Image { mipmap : i . mipmap , filter : i . filter , } } else { img . original = i } img . addr = img r = r . Intersect ( i . Bounds ( ) ) } else { img . bounds = r } return img } 
func ( i * Image ) Bounds ( ) image . Rectangle { if ! i . isSubImage ( ) { w , h := i . mipmap . original ( ) . Size ( ) return image . Rect ( 0 , 0 , w , h ) } return i . bounds } 
func ( i * Image ) At ( x , y int ) color . Color { if atomic . LoadInt32 ( & isRunning ) == 0 { panic ( " " ) } if i . isDisposed ( ) { return color . RGBA { } } if i . isSubImage ( ) && ! image . Pt ( x , y ) . In ( i . bounds ) { return color . RGBA { } } i . resolvePendingPixels ( true ) r , g , b , a := i . mipmap . original ( ) . At ( x , y ) return color . RGBA { r , g , b , a } } 
func ( img * Image ) Set ( x , y int , clr color . Color ) { if atomic . LoadInt32 ( & isRunning ) == 0 { panic ( " " ) } img . copyCheck ( ) if img . isDisposed ( ) { return } if img . isSubImage ( ) && ! image . Pt ( x , y ) . In ( img . bounds ) { return } if img . isSubImage ( ) { img = img . original } w , h := img . Size ( ) if img . pendingPixels == nil { pix := make ( [ ] byte , 4 * w * h ) idx := 0 for j := 0 ; j < h ; j ++ { for i := 0 ; i < w ; i ++ { r , g , b , a := img . mipmap . original ( ) . At ( i , j ) pix [ 4 * idx ] = r pix [ 4 * idx + 1 ] = g pix [ 4 * idx + 2 ] = b pix [ 4 * idx + 3 ] = a idx ++ } } img . pendingPixels = pix } r , g , b , a := clr . RGBA ( ) img . pendingPixels [ 4 * ( x + y * w ) ] = byte ( r >> 8 ) img . pendingPixels [ 4 * ( x + y * w ) + 1 ] = byte ( g >> 8 ) img . pendingPixels [ 4 * ( x + y * w ) + 2 ] = byte ( b >> 8 ) img . pendingPixels [ 4 * ( x + y * w ) + 3 ] = byte ( a >> 8 ) } 
func ( i * Image ) Dispose ( ) error { i . copyCheck ( ) if i . isDisposed ( ) { return nil } if i . isSubImage ( ) { return nil } i . mipmap . dispose ( ) i . resolvePendingPixels ( false ) return nil } 
func ( i * Image ) ReplacePixels ( p [ ] byte ) error { i . copyCheck ( ) if i . isDisposed ( ) { return nil } } i . resolvePendingPixels ( false ) s := i . Bounds ( ) . Size ( ) if l := 4 * s . X * s . Y ; len ( p ) != l { panic ( fmt . Sprintf ( " " , len ( p ) , l ) ) } i . mipmap . original ( ) . ReplacePixels ( p ) i . disposeMipmaps ( ) return nil } 
func NewImage ( width , height int , filter Filter ) ( * Image , error ) { s := shareable . NewImage ( width , height ) i := & Image { mipmap : newMipmap ( s ) , filter : filter , } i . addr = i return i , nil } 
func ( i * Image ) makeVolatile ( ) { if i . isDisposed ( ) { return } i . mipmap . orig . MakeVolatile ( ) i . disposeMipmaps ( ) } 
func NewImageFromImage ( source image . Image , filter Filter ) ( * Image , error ) { size := source . Bounds ( ) . Size ( ) width , height := size . X , size . Y s := shareable . NewImage ( width , height ) i := & Image { mipmap : newMipmap ( s ) , filter : filter , } i . addr = i _ = i . ReplacePixels ( graphics . CopyImage ( source ) ) return i , nil } 
func getCachedMonitor ( wx , wy int ) ( * cachedMonitor , bool ) { for _ , m := range monitors { if m . x <= wx && wx < m . x + m . vm . Width && m . y <= wy && wy < m . y + m . vm . Height { return m , true } } return nil , false } 
func ( u * UserInterface ) isFullscreen ( ) bool { if ! u . isRunning ( ) { panic ( " " ) } return u . window . GetMonitor ( ) != nil } 
func ( u * UserInterface ) glfwSize ( ) ( int , int ) { w := int ( float64 ( u . windowWidth ) * u . getScale ( ) * u . glfwScale ( ) ) h := int ( float64 ( u . height ) * u . getScale ( ) * u . glfwScale ( ) ) return w , h } 
func ( u * UserInterface ) getScale ( ) float64 { if ! u . isFullscreen ( ) { return u . scale } if u . fullscreenScale == 0 { v := u . window . GetMonitor ( ) . GetVideoMode ( ) sw := float64 ( v . Width ) / u . glfwScale ( ) / float64 ( u . width ) sh := float64 ( v . Height ) / u . glfwScale ( ) / float64 ( u . height ) s := sw if s > sh { s = sh } u . fullscreenScale = s } return u . fullscreenScale } 
func ( u * UserInterface ) actualScreenScale ( ) float64 { } return u . getScale ( ) * devicescale . GetAt ( u . currentMonitor ( ) . GetPos ( ) ) } 
func ( u * UserInterface ) setScreenSize ( width , height int , scale float64 , fullscreen bool , vsync bool ) bool { if u . width == width && u . height == height && u . scale == scale && u . isFullscreen ( ) == fullscreen && u . vsync == vsync { return false } u . forceSetScreenSize ( width , height , scale , fullscreen , vsync ) return true } 
func ( u * UserInterface ) forceSetScreenSize ( width , height int , scale float64 , fullscreen bool , vsync bool ) { if u . window . GetAttrib ( glfw . Decorated ) == glfw . False { minWindowWidth = 1 } if width < 1 { width = 1 } if height < 1 { height = 1 } u . width = width u . windowWidth = width s := scale * devicescale . GetAt ( u . currentMonitor ( ) . GetPos ( ) ) if int ( float64 ( width ) * s ) < minWindowWidth { u . windowWidth = int ( math . Ceil ( float64 ( minWindowWidth ) / s ) ) } u . height = height u . scale = scale u . fullscreenScale = 0 u . vsync = vsync if fullscreen { if u . origPosX == invalidPos || u . origPosY == invalidPos { u . origPosX , u . origPosY = u . window . GetPos ( ) } m := u . currentMonitor ( ) v := m . GetVideoMode ( ) u . window . SetMonitor ( m , 0 , 0 , v . Width , v . Height , v . RefreshRate ) } else { if u . window . GetMonitor ( ) != nil { } oldW , oldH := u . window . GetSize ( ) newW , newH := u . glfwSize ( ) if oldW != newW || oldH != newH { ch := make ( chan struct { } ) u . window . SetFramebufferSizeCallback ( func ( _ * glfw . Window , _ , _ int ) { u . window . SetFramebufferSizeCallback ( nil ) close ( ch ) } ) u . window . SetSize ( u . glfwSize ( ) ) event : for { glfw . PollEvents ( ) select { case <- ch : break event default : } } } if u . origPosX != invalidPos && u . origPosY != invalidPos { x := u . origPosX y := u . origPosY u . window . SetPos ( x , y ) u . window . SetPos ( x , y ) } u . origPosX = invalidPos u . origPosY = invalidPos } } if u . graphics . IsGL ( ) { } else { glfw . SwapInterval ( 0 ) } } u . graphics . SetVsyncEnabled ( vsync ) u . toChangeSize = true } 
func ( u * UserInterface ) currentMonitor ( ) * glfw . Monitor { w := u . window if m := w . GetMonitor ( ) ; m != nil { return m } } 
func CopyImage ( img image . Image ) [ ] byte { size := img . Bounds ( ) . Size ( ) w , h := size . X , size . Y bs := make ( [ ] byte , 4 * w * h ) switch img := img . ( type ) { case * image . Paletted : b := img . Bounds ( ) x0 := b . Min . X y0 := b . Min . Y x1 := b . Max . X y1 := b . Max . Y palette := make ( [ ] uint8 , len ( img . Palette ) * 4 ) for i , c := range img . Palette { rgba := color . RGBAModel . Convert ( c ) . ( color . RGBA ) palette [ 4 * i ] = rgba . R palette [ 4 * i + 1 ] = rgba . G palette [ 4 * i + 2 ] = rgba . B palette [ 4 * i + 3 ] = rgba . A } idx1 := 0 d := img . Stride - ( x1 - x0 ) for j := 0 ; j < y1 - y0 ; j ++ { for i := 0 ; i < x1 - x0 ; i ++ { p := int ( img . Pix [ idx0 ] ) bs [ idx1 ] = palette [ 4 * p ] bs [ idx1 + 1 ] = palette [ 4 * p + 1 ] bs [ idx1 + 2 ] = palette [ 4 * p + 2 ] bs [ idx1 + 3 ] = palette [ 4 * p + 3 ] idx0 ++ idx1 += 4 } idx0 += d } default : dstImg := & image . RGBA { Pix : bs , Stride : 4 * w , Rect : image . Rect ( 0 , 0 , w , h ) , } draw . Draw ( dstImg , image . Rect ( 0 , 0 , w , h ) , img , img . Bounds ( ) . Min , draw . Src ) } return bs } 
func ( q * commandQueue ) appendVertices ( vertices [ ] float32 ) { if len ( q . vertices ) < q . nvertices + len ( vertices ) { n := q . nvertices + len ( vertices ) - len ( q . vertices ) q . vertices = append ( q . vertices , make ( [ ] float32 , n ) ... ) } copy ( q . vertices [ q . nvertices : ] , vertices ) q . nvertices += len ( vertices ) } 
func ( q * commandQueue ) EnqueueDrawTrianglesCommand ( dst , src * Image , vertices [ ] float32 , indices [ ] uint16 , color * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) { if len ( indices ) > graphics . IndicesNum { panic ( fmt . Sprintf ( " " , len ( indices ) , graphics . IndicesNum ) ) } split := false if q . tmpNumIndices + len ( indices ) > graphics . IndicesNum { q . tmpNumIndices = 0 q . nextIndex = 0 split = true } q . appendVertices ( vertices ) q . appendIndices ( indices , uint16 ( q . nextIndex ) ) q . nextIndex += len ( vertices ) / graphics . VertexFloatNum q . tmpNumIndices += len ( indices ) } 
func ( q * commandQueue ) Enqueue ( command command ) { } 
func ( q * commandQueue ) Flush ( ) { if q . err != nil { return } es := q . indices vs := q . vertices if recordLog ( ) { fmt . Println ( " " ) } theGraphicsDriver . Begin ( ) for len ( q . commands ) > 0 { nv := 0 ne := 0 nc := 0 for _ , c := range q . commands { if c . NumIndices ( ) > graphics . IndicesNum { panic ( fmt . Sprintf ( " " , c . NumIndices ( ) , graphics . IndicesNum ) ) } if ne + c . NumIndices ( ) > graphics . IndicesNum { break } nv += c . NumVertices ( ) ne += c . NumIndices ( ) nc ++ } if 0 < ne { theGraphicsDriver . SetVertices ( vs [ : nv ] , es [ : ne ] ) es = es [ ne : ] vs = vs [ nv : ] } indexOffset := 0 for _ , c := range q . commands [ : nc ] { if err := c . Exec ( indexOffset ) ; err != nil { q . err = err return } if recordLog ( ) { fmt . Printf ( " \n " , c ) } } if 0 < nc { } q . commands = q . commands [ nc : ] } theGraphicsDriver . End ( ) q . commands = nil q . nvertices = 0 q . nindices = 0 q . tmpNumIndices = 0 q . nextIndex = 0 } 
func ( c * drawTrianglesCommand ) Exec ( indexOffset int ) error { } c . dst . image . SetAsDestination ( ) c . src . image . SetAsSource ( ) if err := theGraphicsDriver . Draw ( c . nindices , indexOffset , c . mode , c . color , c . filter , c . address ) ; err != nil { return err } return nil } 
func ( c * drawTrianglesCommand ) CanMerge ( dst , src * Image , color * affine . ColorM , mode graphics . CompositeMode , filter graphics . Filter , address graphics . Address ) bool { if c . dst != dst { return false } if c . src != src { return false } if ! c . color . Equals ( color ) { return false } if c . mode != mode { return false } if c . filter != filter { return false } if c . address != address { return false } return true } 
func ( c * replacePixelsCommand ) Exec ( indexOffset int ) error { c . dst . image . ReplacePixels ( c . pixels , c . x , c . y , c . width , c . height ) return nil } 
func ( c * pixelsCommand ) Exec ( indexOffset int ) error { p , err := c . img . image . Pixels ( ) if err != nil { return err } c . result = p return nil } 
func ( c * disposeCommand ) Exec ( indexOffset int ) error { c . target . image . Dispose ( ) return nil } 
func ( c * newImageCommand ) Exec ( indexOffset int ) error { i , err := theGraphicsDriver . NewImage ( c . width , c . height ) if err != nil { return err } c . result . image = i return nil } 
func ( c * newScreenFramebufferImageCommand ) Exec ( indexOffset int ) error { var err error c . result . image , err = theGraphicsDriver . NewScreenFramebufferImage ( c . width , c . height ) return err } 
func OpaqueNetworkFromNetworkID ( client * govmomi . Client , id string ) ( * object . OpaqueNetwork , error ) { vctx , vcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer vcancel ( ) v , err := m . CreateContainerView ( vctx , client . ServiceContent . RootFolder , [ ] string { " " } , true ) if err != nil { return nil , err } defer func ( ) { dctx , dcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer dcancel ( ) v . Destroy ( dctx ) } ( ) var networks [ ] mo . OpaqueNetwork err = v . Retrieve ( vctx , [ ] string { " " } , nil , & networks ) if err != nil { return nil , err } for _ , net := range networks { if net . Summary . ( * types . OpaqueNetworkSummary ) . OpaqueNetworkId == id { ref := net . Reference ( ) finder := find . NewFinder ( client . Client , false ) fctx , fcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer fcancel ( ) nref , err := finder . ObjectReference ( fctx , ref ) if err != nil { return nil , err } } } return nil , fmt . Errorf ( " " , id ) } 
func schemaHostNetworkPolicy ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expandHostNicFailureCriteria ( d * schema . ResourceData ) * types . HostNicFailureCriteria { obj := & types . HostNicFailureCriteria { } if v , ok := d . GetOkExists ( " " ) ; ok { obj . CheckBeacon = structure . BoolPtr ( v . ( bool ) ) } obj . Speed = 10 obj . CheckDuplex = structure . BoolPtr ( false ) obj . FullDuplex = structure . BoolPtr ( false ) obj . CheckErrorPercent = structure . BoolPtr ( false ) obj . Percentage = 0 return obj } 
func flattenHostNicFailureCriteria ( d * schema . ResourceData , obj * types . HostNicFailureCriteria ) error { if obj . CheckBeacon != nil { d . Set ( " " , obj . CheckBeacon ) } return nil } 
func expandHostNicOrderPolicy ( d * schema . ResourceData ) * types . HostNicOrderPolicy { obj := & types . HostNicOrderPolicy { } activeNics , activeOk := d . GetOkExists ( " " ) standbyNics , standbyOk := d . GetOkExists ( " " ) if ! activeOk && ! standbyOk { return nil } obj . ActiveNic = structure . SliceInterfacesToStrings ( activeNics . ( [ ] interface { } ) ) obj . StandbyNic = structure . SliceInterfacesToStrings ( standbyNics . ( [ ] interface { } ) ) return obj } 
func flattenHostNicOrderPolicy ( d * schema . ResourceData , obj * types . HostNicOrderPolicy ) error { if obj == nil { return nil } if err := d . Set ( " " , structure . SliceStringsToInterfaces ( obj . ActiveNic ) ) ; err != nil { return err } if err := d . Set ( " " , structure . SliceStringsToInterfaces ( obj . StandbyNic ) ) ; err != nil { return err } return nil } 
func expandHostNicTeamingPolicy ( d * schema . ResourceData ) * types . HostNicTeamingPolicy { obj := & types . HostNicTeamingPolicy { Policy : d . Get ( " " ) . ( string ) , } if v , ok := d . GetOkExists ( " " ) ; ok { obj . RollingOrder = structure . BoolPtr ( ! v . ( bool ) ) } if v , ok := d . GetOkExists ( " " ) ; ok { obj . NotifySwitches = structure . BoolPtr ( v . ( bool ) ) } obj . FailureCriteria = expandHostNicFailureCriteria ( d ) obj . NicOrder = expandHostNicOrderPolicy ( d ) return obj } 
func flattenHostNicTeamingPolicy ( d * schema . ResourceData , obj * types . HostNicTeamingPolicy ) error { if obj . RollingOrder != nil { v := * obj . RollingOrder d . Set ( " " , ! v ) } if obj . NotifySwitches != nil { d . Set ( " " , obj . NotifySwitches ) } d . Set ( " " , obj . Policy ) if err := flattenHostNicFailureCriteria ( d , obj . FailureCriteria ) ; err != nil { return err } if err := flattenHostNicOrderPolicy ( d , obj . NicOrder ) ; err != nil { return err } return nil } 
func expandHostNetworkSecurityPolicy ( d * schema . ResourceData ) * types . HostNetworkSecurityPolicy { obj := & types . HostNetworkSecurityPolicy { } if v , ok := d . GetOkExists ( " " ) ; ok { obj . AllowPromiscuous = structure . BoolPtr ( v . ( bool ) ) } if v , ok := d . GetOkExists ( " " ) ; ok { obj . ForgedTransmits = structure . BoolPtr ( v . ( bool ) ) } if v , ok := d . GetOkExists ( " " ) ; ok { obj . MacChanges = structure . BoolPtr ( v . ( bool ) ) } return obj } 
func flattenHostNetworkSecurityPolicy ( d * schema . ResourceData , obj * types . HostNetworkSecurityPolicy ) error { if obj . AllowPromiscuous != nil { d . Set ( " " , * obj . AllowPromiscuous ) } if obj . ForgedTransmits != nil { d . Set ( " " , * obj . ForgedTransmits ) } if obj . MacChanges != nil { d . Set ( " " , * obj . MacChanges ) } return nil } 
func expandHostNetworkTrafficShapingPolicy ( d * schema . ResourceData ) * types . HostNetworkTrafficShapingPolicy { obj := & types . HostNetworkTrafficShapingPolicy { AverageBandwidth : int64 ( d . Get ( " " ) . ( int ) ) , BurstSize : int64 ( d . Get ( " " ) . ( int ) ) , PeakBandwidth : int64 ( d . Get ( " " ) . ( int ) ) , } if v , ok := d . GetOkExists ( " " ) ; ok { obj . Enabled = structure . BoolPtr ( v . ( bool ) ) } return obj } 
func flattenHostNetworkTrafficShapingPolicy ( d * schema . ResourceData , obj * types . HostNetworkTrafficShapingPolicy ) error { if obj . Enabled != nil { d . Set ( " " , * obj . Enabled ) } d . Set ( " " , obj . AverageBandwidth ) d . Set ( " " , obj . BurstSize ) d . Set ( " " , obj . PeakBandwidth ) return nil } 
func expandHostNetworkPolicy ( d * schema . ResourceData ) * types . HostNetworkPolicy { obj := & types . HostNetworkPolicy { Security : expandHostNetworkSecurityPolicy ( d ) , NicTeaming : expandHostNicTeamingPolicy ( d ) , ShapingPolicy : expandHostNetworkTrafficShapingPolicy ( d ) , } return obj } 
func flattenHostNetworkPolicy ( d * schema . ResourceData , obj * types . HostNetworkPolicy ) error { if err := flattenHostNetworkSecurityPolicy ( d , obj . Security ) ; err != nil { return err } if err := flattenHostNicTeamingPolicy ( d , obj . NicTeaming ) ; err != nil { return err } if err := flattenHostNetworkTrafficShapingPolicy ( d , obj . ShapingPolicy ) ; err != nil { return err } return nil } 
func schemaHostNasVolumeSpec ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expandHostNasVolumeSpec ( d * schema . ResourceData ) * types . HostNasVolumeSpec { obj := & types . HostNasVolumeSpec { AccessMode : d . Get ( " " ) . ( string ) , LocalPath : d . Get ( " " ) . ( string ) , RemoteHost : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) [ 0 ] , RemoteHostNames : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) , RemotePath : d . Get ( " " ) . ( string ) , SecurityType : d . Get ( " " ) . ( string ) , Type : d . Get ( " " ) . ( string ) , } return obj } 
func flattenHostNasVolume ( d * schema . ResourceData , obj * types . HostNasVolume ) error { d . Set ( " " , obj . RemotePath ) d . Set ( " " , obj . SecurityType ) d . Set ( " " , obj . ProtocolEndpoint ) if err := d . Set ( " " , obj . RemoteHostNames ) ; err != nil { return err } return nil } 
func isNasVolume ( t types . HostFileSystemVolumeFileSystemType ) bool { switch t { case types . HostFileSystemVolumeFileSystemTypeNFS , types . HostFileSystemVolumeFileSystemTypeNFS41 : return true } return false } 
func schemaDVPortgroupConfigSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaVMwareDVSPortSetting ( ) ) return s } 
func expandVMwareDVSPortgroupPolicy ( d * schema . ResourceData ) * types . VMwareDVSPortgroupPolicy { obj := & types . VMwareDVSPortgroupPolicy { DVPortgroupPolicy : types . DVPortgroupPolicy { BlockOverrideAllowed : d . Get ( " " ) . ( bool ) , ShapingOverrideAllowed : d . Get ( " " ) . ( bool ) , LivePortMovingAllowed : d . Get ( " " ) . ( bool ) , PortConfigResetAtDisconnect : d . Get ( " " ) . ( bool ) , NetworkResourcePoolOverrideAllowed : structure . GetBoolPtr ( d , " " ) , TrafficFilterOverrideAllowed : structure . GetBoolPtr ( d , " " ) , } , VlanOverrideAllowed : d . Get ( " " ) . ( bool ) , UplinkTeamingOverrideAllowed : d . Get ( " " ) . ( bool ) , SecurityPolicyOverrideAllowed : d . Get ( " " ) . ( bool ) , IpfixOverrideAllowed : structure . GetBoolPtr ( d , " " ) , } return obj } 
func flattenVMwareDVSPortgroupPolicy ( d * schema . ResourceData , obj * types . VMwareDVSPortgroupPolicy ) error { d . Set ( " " , obj . BlockOverrideAllowed ) d . Set ( " " , obj . ShapingOverrideAllowed ) d . Set ( " " , obj . LivePortMovingAllowed ) d . Set ( " " , obj . PortConfigResetAtDisconnect ) d . Set ( " " , obj . VlanOverrideAllowed ) d . Set ( " " , obj . UplinkTeamingOverrideAllowed ) d . Set ( " " , obj . SecurityPolicyOverrideAllowed ) structure . SetBoolPtr ( d , " " , obj . NetworkResourcePoolOverrideAllowed ) structure . SetBoolPtr ( d , " " , obj . TrafficFilterOverrideAllowed ) structure . SetBoolPtr ( d , " " , obj . IpfixOverrideAllowed ) return nil } 
func expandDVPortgroupConfigSpec ( d * schema . ResourceData ) types . DVPortgroupConfigSpec { obj := types . DVPortgroupConfigSpec { ConfigVersion : d . Get ( " " ) . ( string ) , Name : d . Get ( " " ) . ( string ) , NumPorts : int32 ( d . Get ( " " ) . ( int ) ) , PortNameFormat : d . Get ( " " ) . ( string ) , DefaultPortConfig : expandVMwareDVSPortSetting ( d ) , Description : d . Get ( " " ) . ( string ) , Type : d . Get ( " " ) . ( string ) , Policy : expandVMwareDVSPortgroupPolicy ( d ) , AutoExpand : structure . GetBoolPtr ( d , " " ) , VmVnicNetworkResourcePoolKey : d . Get ( " " ) . ( string ) , } return obj } 
func flattenDVPortgroupConfigInfo ( d * schema . ResourceData , obj types . DVPortgroupConfigInfo ) error { d . Set ( " " , obj . ConfigVersion ) d . Set ( " " , obj . Name ) d . Set ( " " , obj . NumPorts ) d . Set ( " " , obj . PortNameFormat ) d . Set ( " " , obj . Description ) d . Set ( " " , obj . Type ) structure . SetBoolPtr ( d , " " , obj . AutoExpand ) d . Set ( " " , obj . VmVnicNetworkResourcePoolKey ) if err := flattenVMwareDVSPortSetting ( d , obj . DefaultPortConfig . ( * types . VMwareDVSPortSetting ) ) ; err != nil { return err } if err := flattenVMwareDVSPortgroupPolicy ( d , obj . Policy . ( * types . VMwareDVSPortgroupPolicy ) ) ; err != nil { return err } return nil } 
func expandClusterHostGroup ( d * schema . ResourceData , name string ) ( * types . ClusterHostGroup , error ) { obj := & types . ClusterHostGroup { ClusterGroupInfo : types . ClusterGroupInfo { Name : name , UserCreated : structure . BoolPtr ( true ) , } , Host : structure . SliceInterfacesToManagedObjectReferences ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " ) , } return obj , nil } 
func flattenClusterHostGroup ( d * schema . ResourceData , obj * types . ClusterHostGroup ) error { var hostIDs [ ] string for _ , v := range obj . Host { hostIDs = append ( hostIDs , v . Value ) } return structure . SetBatch ( d , map [ string ] interface { } { " " : hostIDs , } ) } 
func resourceVSphereComputeClusterHostGroupFlattenID ( cluster * object . ClusterComputeResource , name string ) ( string , error ) { clusterID := cluster . Reference ( ) . Value return strings . Join ( [ ] string { clusterID , name } , " " ) , nil } 
func resourceVSphereComputeClusterHostGroupObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , string , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterHostGroupObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterHostGroupObjectsFromAttributes ( d , meta ) } 
func resourceVSphereComputeClusterHostGroupFetchObjects ( meta interface { } , clusterID string , name string , ) ( * object . ClusterComputeResource , string , error ) { client , err := resourceVSphereComputeClusterHostGroupClient ( meta ) if err != nil { return nil , " " , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , " " , fmt . Errorf ( " " , err ) } return cluster , name , nil } 
func netifKey ( key string , n int ) string { return fmt . Sprintf ( " " , cNetifKeyPrefix , n , key ) } 
func matchGateway ( a string , m int , g string ) bool { ip := net . ParseIP ( a ) gw := net . ParseIP ( g ) var mask net . IPMask if ip . To4 ( ) != nil { mask = net . CIDRMask ( m , 32 ) } else { mask = net . CIDRMask ( m , 128 ) } if ip . Mask ( mask ) . Equal ( gw . Mask ( mask ) ) { return true } return false } 
func VirtualMachineCustomizeSchema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expandCustomizationGlobalIPSettings ( d * schema . ResourceData ) types . CustomizationGlobalIPSettings { obj := types . CustomizationGlobalIPSettings { DnsSuffixList : structure . SliceInterfacesToStrings ( d . Get ( cKeyPrefix + " " + " " ) . ( [ ] interface { } ) ) , DnsServerList : structure . SliceInterfacesToStrings ( d . Get ( cKeyPrefix + " " + " " ) . ( [ ] interface { } ) ) , } return obj } 
func expandCustomizationLinuxPrep ( d * schema . ResourceData ) * types . CustomizationLinuxPrep { obj := & types . CustomizationLinuxPrep { HostName : & types . CustomizationFixedName { Name : d . Get ( cLinuxKeyPrefix + " " + " " ) . ( string ) , } , Domain : d . Get ( cLinuxKeyPrefix + " " + " " ) . ( string ) , TimeZone : d . Get ( cLinuxKeyPrefix + " " + " " ) . ( string ) , HwClockUTC : structure . GetBoolPtr ( d , cLinuxKeyPrefix + " " + " " ) , } return obj } 
func expandCustomizationGuiRunOnce ( d * schema . ResourceData ) * types . CustomizationGuiRunOnce { obj := & types . CustomizationGuiRunOnce { CommandList : structure . SliceInterfacesToStrings ( d . Get ( cWindowsKeyPrefix + " " + " " ) . ( [ ] interface { } ) ) , } if len ( obj . CommandList ) < 1 { return nil } return obj } 
func expandCustomizationGuiUnattended ( d * schema . ResourceData ) types . CustomizationGuiUnattended { obj := types . CustomizationGuiUnattended { TimeZone : int32 ( d . Get ( cWindowsKeyPrefix + " " + " " ) . ( int ) ) , AutoLogon : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( bool ) , AutoLogonCount : int32 ( d . Get ( cWindowsKeyPrefix + " " + " " ) . ( int ) ) , } if v , ok := d . GetOk ( cWindowsKeyPrefix + " " + " " ) ; ok { obj . Password = & types . CustomizationPassword { Value : v . ( string ) , PlainText : true , } } return obj } 
func expandCustomizationIdentification ( d * schema . ResourceData ) types . CustomizationIdentification { obj := types . CustomizationIdentification { JoinWorkgroup : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , JoinDomain : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , DomainAdmin : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , } if v , ok := d . GetOk ( cWindowsKeyPrefix + " " + " " ) ; ok { obj . DomainAdminPassword = & types . CustomizationPassword { Value : v . ( string ) , PlainText : true , } } return obj } 
func expandCustomizationUserData ( d * schema . ResourceData ) types . CustomizationUserData { obj := types . CustomizationUserData { FullName : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , OrgName : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , ComputerName : & types . CustomizationFixedName { Name : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , } , ProductId : d . Get ( cWindowsKeyPrefix + " " + " " ) . ( string ) , } return obj } 
func expandCustomizationSysprep ( d * schema . ResourceData ) * types . CustomizationSysprep { obj := & types . CustomizationSysprep { GuiUnattended : expandCustomizationGuiUnattended ( d ) , UserData : expandCustomizationUserData ( d ) , GuiRunOnce : expandCustomizationGuiRunOnce ( d ) , Identification : expandCustomizationIdentification ( d ) , } return obj } 
func expandCustomizationSysprepText ( d * schema . ResourceData ) * types . CustomizationSysprepText { obj := & types . CustomizationSysprepText { Value : d . Get ( cKeyPrefix + " " + " " ) . ( string ) , } return obj } 
func expandBaseCustomizationIdentitySettings ( d * schema . ResourceData , family string ) types . BaseCustomizationIdentitySettings { var obj types . BaseCustomizationIdentitySettings _ , windowsExists := d . GetOkExists ( cKeyPrefix + " " + " " ) _ , sysprepExists := d . GetOkExists ( cKeyPrefix + " " + " " ) switch { case family == string ( types . VirtualMachineGuestOsFamilyLinuxGuest ) : obj = expandCustomizationLinuxPrep ( d ) case family == string ( types . VirtualMachineGuestOsFamilyWindowsGuest ) && windowsExists : obj = expandCustomizationSysprep ( d ) case family == string ( types . VirtualMachineGuestOsFamilyWindowsGuest ) && sysprepExists : obj = expandCustomizationSysprepText ( d ) default : obj = & types . CustomizationIdentitySettings { } } return obj } 
func expandCustomizationIPSettingsIPV6AddressSpec ( d * schema . ResourceData , n int , gwAdd bool ) ( * types . CustomizationIPSettingsIpV6AddressSpec , bool ) { v , ok := d . GetOk ( netifKey ( " " , n ) ) var gwFound bool if ! ok { return nil , gwFound } addr := v . ( string ) mask := d . Get ( netifKey ( " " , n ) ) . ( int ) gw , gwOk := d . Get ( cKeyPrefix + " " + " " ) . ( string ) obj := & types . CustomizationIPSettingsIpV6AddressSpec { Ip : [ ] types . BaseCustomizationIpV6Generator { & types . CustomizationFixedIpV6 { IpAddress : addr , SubnetMask : int32 ( mask ) , } , } , } if gwAdd && gwOk && matchGateway ( addr , mask , gw ) { obj . Gateway = [ ] string { gw } gwFound = true } return obj , gwFound } 
func expandCustomizationIPSettings ( d * schema . ResourceData , n int , v4gwAdd , v6gwAdd bool ) ( types . CustomizationIPSettings , bool , bool ) { var v4gwFound , v6gwFound bool v4addr , v4addrOk := d . GetOk ( netifKey ( " " , n ) ) v4mask := d . Get ( netifKey ( " " , n ) ) . ( int ) v4gw , v4gwOk := d . Get ( cKeyPrefix + " " + " " ) . ( string ) var obj types . CustomizationIPSettings switch { case v4addrOk : obj . Ip = & types . CustomizationFixedIp { IpAddress : v4addr . ( string ) , } obj . SubnetMask = v4CIDRMaskToDotted ( v4mask ) v4gwFound = true } default : obj . Ip = & types . CustomizationDhcpIpGenerator { } } obj . DnsServerList = structure . SliceInterfacesToStrings ( d . Get ( netifKey ( " " , n ) ) . ( [ ] interface { } ) ) obj . DnsDomain = d . Get ( netifKey ( " " , n ) ) . ( string ) obj . IpV6Spec , v6gwFound = expandCustomizationIPSettingsIPV6AddressSpec ( d , n , v6gwAdd ) return obj , v4gwFound , v6gwFound } 
func expandSliceOfCustomizationAdapterMapping ( d * schema . ResourceData ) [ ] types . CustomizationAdapterMapping { s := d . Get ( cKeyPrefix + " " + " " ) . ( [ ] interface { } ) if len ( s ) < 1 { return nil } result := make ( [ ] types . CustomizationAdapterMapping , len ( s ) ) var v4gwFound , v6gwFound bool for i := range s { var adapter types . CustomizationIPSettings adapter , v4gwFound , v6gwFound = expandCustomizationIPSettings ( d , i , ! v4gwFound , ! v6gwFound ) obj := types . CustomizationAdapterMapping { Adapter : adapter , } result [ i ] = obj } return result } 
func ExpandCustomizationSpec ( d * schema . ResourceData , family string ) types . CustomizationSpec { obj := types . CustomizationSpec { Identity : expandBaseCustomizationIdentitySettings ( d , family ) , GlobalIPSettings : expandCustomizationGlobalIPSettings ( d ) , NicSettingMap : expandSliceOfCustomizationAdapterMapping ( d ) , } return obj } 
func ValidateCustomizationSpec ( d * schema . ResourceDiff , family string ) error { windowsExists := len ( d . Get ( cKeyPrefix + " " + " " ) . ( [ ] interface { } ) ) > 0 sysprepExists := d . Get ( cKeyPrefix + " " + " " ) . ( string ) != " " switch { case family == string ( types . VirtualMachineGuestOsFamilyLinuxGuest ) && ! linuxExists : return errors . New ( " " ) case family == string ( types . VirtualMachineGuestOsFamilyWindowsGuest ) && ! windowsExists && ! sysprepExists : return errors . New ( " " ) } return nil } 
func schemaHostVirtualSwitchBondBridge ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expandHostVirtualSwitchBeaconConfig ( d * schema . ResourceData ) * types . HostVirtualSwitchBeaconConfig { obj := & types . HostVirtualSwitchBeaconConfig { Interval : int32 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flattenHostVirtualSwitchBeaconConfig ( d * schema . ResourceData , obj * types . HostVirtualSwitchBeaconConfig ) error { d . Set ( " " , obj . Interval ) return nil } 
func expandLinkDiscoveryProtocolConfig ( d * schema . ResourceData ) * types . LinkDiscoveryProtocolConfig { obj := & types . LinkDiscoveryProtocolConfig { Operation : d . Get ( " " ) . ( string ) , Protocol : d . Get ( " " ) . ( string ) , } return obj } 
func flattenLinkDiscoveryProtocolConfig ( d * schema . ResourceData , obj * types . LinkDiscoveryProtocolConfig ) error { d . Set ( " " , obj . Operation ) d . Set ( " " , obj . Protocol ) return nil } 
func expandHostVirtualSwitchBondBridge ( d * schema . ResourceData ) * types . HostVirtualSwitchBondBridge { obj := & types . HostVirtualSwitchBondBridge { NicDevice : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } obj . Beacon = expandHostVirtualSwitchBeaconConfig ( d ) obj . LinkDiscoveryProtocolConfig = expandLinkDiscoveryProtocolConfig ( d ) return obj } 
func flattenHostVirtualSwitchBondBridge ( d * schema . ResourceData , obj * types . HostVirtualSwitchBondBridge ) error { if err := d . Set ( " " , structure . SliceStringsToInterfaces ( obj . NicDevice ) ) ; err != nil { return err } if err := flattenHostVirtualSwitchBeaconConfig ( d , obj . Beacon ) ; err != nil { return err } if err := flattenLinkDiscoveryProtocolConfig ( d , obj . LinkDiscoveryProtocolConfig ) ; err != nil { return err } return nil } 
func schemaHostVirtualSwitchSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaHostVirtualSwitchBondBridge ( ) ) structure . MergeSchema ( s , schemaHostNetworkPolicy ( ) ) return s } 
func expandHostVirtualSwitchSpec ( d * schema . ResourceData ) * types . HostVirtualSwitchSpec { obj := & types . HostVirtualSwitchSpec { Mtu : int32 ( d . Get ( " " ) . ( int ) ) , NumPorts : int32 ( d . Get ( " " ) . ( int ) ) , Bridge : expandHostVirtualSwitchBondBridge ( d ) , Policy : expandHostNetworkPolicy ( d ) , } } return obj } 
func flattenHostVirtualSwitchSpec ( d * schema . ResourceData , obj * types . HostVirtualSwitchSpec ) error { d . Set ( " " , obj . Mtu ) d . Set ( " " , obj . NumPorts ) if obj . Bridge != nil { if err := flattenHostVirtualSwitchBondBridge ( d , obj . Bridge . ( * types . HostVirtualSwitchBondBridge ) ) ; err != nil { return err } } if err := flattenHostNetworkPolicy ( d , obj . Policy ) ; err != nil { return err } return nil } 
func saveHostVirtualSwitchID ( d * schema . ResourceData , hsID , name string ) { d . SetId ( fmt . Sprintf ( " " , hostVirtualSwitchIDPrefix , hsID , name ) ) } 
func splitHostVirtualSwitchID ( raw string ) ( string , string , error ) { s := strings . SplitN ( raw , " " , 3 ) if len ( s ) != 3 || s [ 0 ] != hostVirtualSwitchIDPrefix || s [ 1 ] == " " || s [ 2 ] == " " { return " " , " " , fmt . Errorf ( " " , raw ) } return s [ 1 ] , s [ 2 ] , nil } 
func virtualSwitchIDsFromResourceID ( d * schema . ResourceData ) ( string , string , error ) { return splitHostVirtualSwitchID ( d . Id ( ) ) } 
func expandStorageDrsVMConfigInfo ( d * schema . ResourceData , vm * object . VirtualMachine ) ( * types . StorageDrsVmConfigInfo , error ) { enabled , err := structure . GetBoolStringPtr ( d , " " ) if err != nil { return nil , fmt . Errorf ( " \" \" " , err ) } intraVMAffinity , err := structure . GetBoolStringPtr ( d , " " ) if err != nil { return nil , fmt . Errorf ( " \" \" " , err ) } obj := & types . StorageDrsVmConfigInfo { Behavior : d . Get ( " " ) . ( string ) , Enabled : enabled , IntraVmAffinity : intraVMAffinity , Vm : types . NewReference ( vm . Reference ( ) ) , } return obj , nil } 
func flattenStorageDrsVMConfigInfo ( d * schema . ResourceData , obj * types . StorageDrsVmConfigInfo ) error { if err := d . Set ( " " , obj . Behavior ) ; err != nil { return fmt . Errorf ( " \" \" " , err ) } if err := structure . SetBoolStringPtr ( d , " " , obj . Enabled ) ; err != nil { return fmt . Errorf ( " \" \" " , err ) } if err := structure . SetBoolStringPtr ( d , " " , obj . IntraVmAffinity ) ; err != nil { return fmt . Errorf ( " \" \" " , err ) } return nil } 
func resourceVSphereStorageDrsVMOverrideFlattenID ( pod * object . StoragePod , vm * object . VirtualMachine ) ( string , error ) { podID := pod . Reference ( ) . Value props , err := virtualmachine . Properties ( vm ) if err != nil { return " " , fmt . Errorf ( " " , err ) } vmID := props . Config . Uuid return strings . Join ( [ ] string { podID , vmID } , " " ) , nil } 
func resourceVSphereStorageDrsVMOverrideFindEntry ( pod * object . StoragePod , vm * object . VirtualMachine , ) ( * types . StorageDrsVmConfigInfo , error ) { props , err := storagepod . Properties ( pod ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . PodStorageDrsEntry . StorageDrsConfig . VmConfig { if * info . Vm == vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , pod . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , pod . Name ( ) ) return nil , nil } 
func resourceVSphereStorageDrsVMOverrideObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . StoragePod , * object . VirtualMachine , error ) { if d . Id ( ) != " " { return resourceVSphereStorageDrsVMOverrideObjectsFromID ( d , meta ) } return resourceVSphereStorageDrsVMOverrideObjectsFromAttributes ( d , meta ) } 
func NetworkInterfaceSubresourceSchema ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , subresourceSchema ( ) ) return s } 
func NewNetworkInterfaceSubresource ( client * govmomi . Client , rdd resourceDataDiff , d , old map [ string ] interface { } , idx int ) * NetworkInterfaceSubresource { sr := & NetworkInterfaceSubresource { Subresource : & Subresource { schema : NetworkInterfaceSubresourceSchema ( ) , client : client , srtype : subresourceTypeNetworkInterface , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func NetworkInterfaceRefreshOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) error { log . Printf ( " " ) devices := l . Select ( func ( device types . BaseVirtualDevice ) bool { if _ , ok := device . ( types . BaseVirtualEthernetCard ) ; ok { return true } return false } ) log . Printf ( " " , DeviceListString ( devices ) ) curSet := d . Get ( subresourceTypeNetworkInterface ) . ( [ ] interface { } ) log . Printf ( " " , subresourceListString ( curSet ) ) urange , err := nicUnitRange ( devices ) if err != nil { return fmt . Errorf ( " " , err ) } newSet := make ( [ ] interface { } , urange ) log . Printf ( " " , len ( devices ) , urange ) for n , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r := NewNetworkInterfaceSubresource ( c , d , m , nil , n ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } _ , _ , idx , err := splitDevAddr ( r . Get ( " " ) . ( string ) ) if err != nil { return fmt . Errorf ( " " , r , err ) } newSet [ idx - networkInterfacePciDeviceOffset ] = r . Data ( ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] if device . GetVirtualDevice ( ) . Key == int32 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } } } log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( newSet ) ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] for n , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 0 { } if device . GetVirtualDevice ( ) . Key != int32 ( m [ " " ] . ( int ) ) { } if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if err != nil { return fmt . Errorf ( " " , r , err ) } newSet [ idx - networkInterfacePciDeviceOffset ] = r . Data ( ) devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " , DeviceListString ( devices ) ) for n , device := range devices { m := make ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( " " , err ) } r := NewNetworkInterfaceSubresource ( c , d , m , nil , n ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } _ , _ , idx , err := splitDevAddr ( r . Get ( " " ) . ( string ) ) if err != nil { return fmt . Errorf ( " " , r , err ) } newSet [ idx - networkInterfacePciDeviceOffset ] = r . Data ( ) } i -- } } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " ) return d . Set ( subresourceTypeNetworkInterface , newSet ) } 
func NetworkInterfaceDiffOperation ( d * schema . ResourceDiff , c * govmomi . Client ) error { log . Printf ( " " ) for ni , ne := range n . ( [ ] interface { } ) { nm := ne . ( map [ string ] interface { } ) r := NewNetworkInterfaceSubresource ( c , d , nm , nil , ni ) if err := r . ValidateDiff ( ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } log . Printf ( " " ) return nil } 
func NetworkInterfacePostCloneOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " ) devices := l . Select ( func ( device types . BaseVirtualDevice ) bool { if _ , ok := device . ( types . BaseVirtualEthernetCard ) ; ok { return true } return false } ) log . Printf ( " " , DeviceListString ( devices ) ) curSet := d . Get ( subresourceTypeNetworkInterface ) . ( [ ] interface { } ) log . Printf ( " " , subresourceListString ( curSet ) ) urange , err := nicUnitRange ( devices ) if err != nil { return nil , nil , fmt . Errorf ( " " , err ) } srcSet := make ( [ ] interface { } , urange ) log . Printf ( " " , len ( devices ) , urange ) for n , device := range devices { m := make ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , nil , fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return nil , nil , fmt . Errorf ( " " , err ) } r := NewNetworkInterfaceSubresource ( c , d , m , nil , n ) if err := r . Read ( l ) ; err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } _ , _ , idx , err := splitDevAddr ( r . Get ( " " ) . ( string ) ) if err != nil { return nil , nil , fmt . Errorf ( " " , r , err ) } srcSet [ idx - networkInterfacePciDeviceOffset ] = r . Data ( ) } var updates [ ] interface { } for i , ci := range curSet { cm := ci . ( map [ string ] interface { } ) if i > len ( srcSet ) - 1 || srcSet [ i ] == nil { cspec , err := r . Create ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , cspec ) spec = append ( spec , cspec ... ) updates = append ( updates , r . Data ( ) ) continue } sm := srcSet [ i ] . ( map [ string ] interface { } ) nc , err := copystructure . Copy ( sm ) if err != nil { return nil , nil , fmt . Errorf ( " " , i , err ) } nm := nc . ( map [ string ] interface { } ) for k , v := range cm { } nm [ k ] = v } r := NewNetworkInterfaceSubresource ( c , d , nm , sm , i ) if ! reflect . DeepEqual ( sm , nm ) { if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , cspec ) spec = append ( spec , cspec ... ) } updates = append ( updates , r . Data ( ) ) } r := NewNetworkInterfaceSubresource ( c , d , sm , nil , i + len ( curSet ) ) dspec , err := r . Delete ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , dspec ) spec = append ( spec , dspec ... ) } } log . Printf ( " " , subresourceListString ( updates ) ) } log . Printf ( " " , DeviceListString ( l ) ) log . Printf ( " " , DeviceChangeString ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func ReadNetworkInterfaceTypes ( l object . VirtualDeviceList ) ( [ ] string , error ) { log . Printf ( " " ) devices := l . Select ( func ( device types . BaseVirtualDevice ) bool { if _ , ok := device . ( types . BaseVirtualEthernetCard ) ; ok { return true } return false } ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) var out [ ] string for _ , device := range devices { out = append ( out , virtualEthernetCardString ( device . ( types . BaseVirtualEthernetCard ) ) ) } log . Printf ( " " , out ) return out , nil } 
func baseVirtualEthernetCardToBaseVirtualDevice ( v types . BaseVirtualEthernetCard ) types . BaseVirtualDevice { switch t := v . ( type ) { case * types . VirtualE1000 : return types . BaseVirtualDevice ( t ) case * types . VirtualE1000e : return types . BaseVirtualDevice ( t ) case * types . VirtualPCNet32 : return types . BaseVirtualDevice ( t ) case * types . VirtualSriovEthernetCard : return types . BaseVirtualDevice ( t ) case * types . VirtualVmxnet2 : return types . BaseVirtualDevice ( t ) case * types . VirtualVmxnet3 : return types . BaseVirtualDevice ( t ) } panic ( fmt . Errorf ( " " , v ) ) } 
func baseVirtualDeviceToBaseVirtualEthernetCard ( v types . BaseVirtualDevice ) ( types . BaseVirtualEthernetCard , error ) { if bve , ok := v . ( types . BaseVirtualEthernetCard ) ; ok { return bve , nil } return nil , fmt . Errorf ( " " , v ) } 
func virtualEthernetCardString ( d types . BaseVirtualEthernetCard ) string { switch d . ( type ) { case * types . VirtualE1000 : return networkInterfaceSubresourceTypeE1000 case * types . VirtualE1000e : return networkInterfaceSubresourceTypeE1000e case * types . VirtualPCNet32 : return networkInterfaceSubresourceTypePCNet32 case * types . VirtualSriovEthernetCard : return networkInterfaceSubresourceTypeSriov case * types . VirtualVmxnet2 : return networkInterfaceSubresourceTypeVmxnet2 case * types . VirtualVmxnet3 : return networkInterfaceSubresourceTypeVmxnet3 } return networkInterfaceSubresourceTypeUnknown } 
func ( r * NetworkInterfaceSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec ctlr , err := r . ControllerForCreateUpdate ( l , SubresourceControllerTypePCI , 0 ) if err != nil { return nil , err } if err != nil { return nil , err } bctx , bcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer bcancel ( ) backing , err := net . EthernetCardBackingInfo ( bctx ) if err != nil { return nil , err } device , err := l . CreateEthernetCard ( r . Get ( " " ) . ( string ) , backing ) if err != nil { return nil , err } } card . Key = l . NewKey ( ) card . MacAddress = r . Get ( " " ) . ( string ) } version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { alloc := & types . VirtualEthernetCardResourceAllocation { Limit : structure . Int64Ptr ( int64 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int64Ptr ( int64 ( r . Get ( " " ) . ( int ) ) ) , Share : types . SharesInfo { Shares : int32 ( r . Get ( " " ) . ( int ) ) , Level : types . SharesLevel ( r . Get ( " " ) . ( string ) ) , } , } card . ResourceAllocation = alloc } } dspec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , dspec ... ) log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * NetworkInterfaceSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( " " , r ) vd , err := r . FindVirtualDevice ( l ) if err != nil { return fmt . Errorf ( " " , err ) } device , err := baseVirtualDeviceToBaseVirtualEthernetCard ( vd ) if err != nil { return err } switch backing := card . Backing . ( type ) { case * types . VirtualEthernetCardNetworkBackingInfo : if backing . Network == nil { return fmt . Errorf ( " " ) } netID = backing . Network . Value case * types . VirtualEthernetCardOpaqueNetworkBackingInfo : onet , err := nsx . OpaqueNetworkFromNetworkID ( r . client , backing . OpaqueNetworkId ) if err != nil { return err } netID = onet . Reference ( ) . Value case * types . VirtualEthernetCardDistributedVirtualPortBackingInfo : pg , err := dvportgroup . FromKey ( r . client , backing . Port . SwitchUuid , backing . Port . PortgroupKey ) if err != nil { return err } netID = pg . Reference ( ) . Value default : return fmt . Errorf ( " " , card . Backing ) } r . Set ( " " , netID ) r . Set ( " " , card . AddressType == string ( types . VirtualEthernetCardMacTypeManual ) ) r . Set ( " " , card . MacAddress ) version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if card . ResourceAllocation != nil { r . Set ( " " , card . ResourceAllocation . Limit ) r . Set ( " " , card . ResourceAllocation . Reservation ) r . Set ( " " , card . ResourceAllocation . Share . Shares ) r . Set ( " " , card . ResourceAllocation . Share . Level ) } } if err != nil { return err } if err := r . SaveDevIDs ( vd , ctlr ) ; err != nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * NetworkInterfaceSubresource ) Update ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) vd , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( " " , err ) } device , err := baseVirtualDeviceToBaseVirtualEthernetCard ( vd ) if err != nil { return nil , err } card := device . GetVirtualEthernetCard ( ) newDevice , err := l . CreateEthernetCard ( r . Get ( " " ) . ( string ) , card . Backing ) if err != nil { return nil , err } newCard := newDevice . ( types . BaseVirtualEthernetCard ) . GetVirtualEthernetCard ( ) if card . UnitNumber != nil { var un int32 un = * card . UnitNumber newCard . UnitNumber = & un } } dspec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } spec = append ( spec , dspec ... ) if err != nil { return nil , err } } card := device . GetVirtualEthernetCard ( ) if err != nil { return nil , err } bctx , bcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer bcancel ( ) backing , err := net . EthernetCardBackingInfo ( bctx ) if err != nil { return nil , err } card . Backing = backing } if r . HasChange ( " " ) { if r . Get ( " " ) . ( bool ) { card . AddressType = string ( types . VirtualEthernetCardMacTypeManual ) card . MacAddress = r . Get ( " " ) . ( string ) } else { } else { } card . MacAddress = " " } } version := viapi . ParseVersionFromClient ( r . client ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { alloc := & types . VirtualEthernetCardResourceAllocation { Limit : structure . Int64Ptr ( int64 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int64Ptr ( int64 ( r . Get ( " " ) . ( int ) ) ) , Share : types . SharesInfo { Shares : int32 ( r . Get ( " " ) . ( int ) ) , Level : types . SharesLevel ( r . Get ( " " ) . ( string ) ) , } , } card . ResourceAllocation = alloc } var op types . VirtualDeviceConfigSpecOperation if card . Key < 0 { } else { op = types . VirtualDeviceConfigSpecOperationEdit } bvd := baseVirtualEthernetCardToBaseVirtualDevice ( device ) uspec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( op ) if err != nil { return nil , err } spec = append ( spec , uspec ... ) log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * NetworkInterfaceSubresource ) Delete ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) vd , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( " " , err ) } device , err := baseVirtualDeviceToBaseVirtualEthernetCard ( vd ) if err != nil { return nil , err } } bvd := baseVirtualEthernetCardToBaseVirtualDevice ( device ) spec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * NetworkInterfaceSubresource ) ValidateDiff ( ) error { log . Printf ( " " , r ) if version . Older ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := r . restrictResourceAllocationSettings ( ) ; err != nil { return err } } log . Printf ( " " , r ) return nil } 
func ( r * NetworkInterfaceSubresource ) assignEthernetCard ( l object . VirtualDeviceList , device types . BaseVirtualDevice , c types . BaseVirtualController ) error { ckey := c . GetVirtualController ( ) . Key for _ , device := range l { d := device . GetVirtualDevice ( ) if d . ControllerKey != ckey || d . UnitNumber == nil || * d . UnitNumber < pciDeviceOffset || * d . UnitNumber >= pciDeviceOffset + 10 { continue } units [ * d . UnitNumber - pciDeviceOffset ] = true } if units [ newUnit - pciDeviceOffset ] { return fmt . Errorf ( " " , newUnit ) } d := device . GetVirtualDevice ( ) d . ControllerKey = c . GetVirtualController ( ) . Key d . UnitNumber = & newUnit if d . Key == 0 { d . Key = - 1 } return nil } 
func nicUnitRange ( l object . VirtualDeviceList ) ( int , error ) { } high := int32 ( networkInterfacePciDeviceOffset ) for _ , v := range l { d := v . GetVirtualDevice ( ) if d . UnitNumber == nil { return 0 , fmt . Errorf ( " " , d . Key ) } if * d . UnitNumber > high { high = * d . UnitNumber } } return int ( high - networkInterfacePciDeviceOffset + 1 ) , nil } 
func hostStorageSystemFromHostSystemID ( client * govmomi . Client , hsID string ) ( * object . HostStorageSystem , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return nil , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return hs . ConfigManager ( ) . StorageSystem ( ctx ) } 
func FromUUID ( client * govmomi . Client , uuid string ) ( * object . VirtualMachine , error ) { log . Printf ( " " , uuid ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var result object . Reference var err error version := viapi . ParseVersionFromClient ( client ) expected := vmUUIDSearchIndexVersion expected . Product = version . Product if version . Older ( expected ) { result , err = virtualMachineFromContainerView ( ctx , client , uuid ) } else { result , err = virtualMachineFromSearchIndex ( ctx , client , uuid ) } if err != nil { return nil , err } vm , err := finder . ObjectReference ( ctx , result . Reference ( ) ) if err != nil { return nil , err } return vm . ( * object . VirtualMachine ) , nil } 
func virtualMachineFromSearchIndex ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( " " , uuid ) search := object . NewSearchIndex ( client . Client ) result , err := search . FindByUuid ( ctx , nil , uuid , true , structure . BoolPtr ( false ) ) if err != nil { return nil , err } if result == nil { return nil , newUUIDNotFoundError ( fmt . Sprintf ( " " , uuid ) ) } return result , nil } 
func virtualMachineFromContainerView ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( " " , uuid ) m := view . NewManager ( client . Client ) v , err := m . CreateContainerView ( ctx , client . ServiceContent . RootFolder , [ ] string { " " } , true ) if err != nil { return nil , err } defer func ( ) { if err = v . Destroy ( ctx ) ; err != nil { log . Printf ( " " , err ) } } ( ) var vms , results [ ] mo . VirtualMachine err = v . Retrieve ( ctx , [ ] string { " " } , [ ] string { " " } , & results ) if err != nil { return nil , err } for _ , result := range results { if result . Config == nil { continue } if result . Config . Uuid == uuid { vms = append ( vms , result ) } } switch { case len ( vms ) < 1 : return nil , newUUIDNotFoundError ( fmt . Sprintf ( " " , uuid ) ) case len ( vms ) > 1 : return nil , fmt . Errorf ( " " , uuid ) } return object . NewReference ( client . Client , vms [ 0 ] . Self ) , nil } 
func Properties ( vm * object . VirtualMachine ) ( * mo . VirtualMachine , error ) { log . Printf ( " " , vm . InventoryPath ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . VirtualMachine if err := vm . Properties ( ctx , vm . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func WaitForGuestIP ( client * govmomi . Client , vm * object . VirtualMachine , timeout int , ignoredGuestIPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( " " , vm . InventoryPath ) return nil } log . Printf ( " " , vm . InventoryPath , timeout , ) p := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err := property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { " " } , func ( pc [ ] types . PropertyChange ) bool { for _ , c := range pc { if c . Op != types . PropertyChangeOpAssign { continue } if c . Val == nil { continue } ip := net . ParseIP ( c . Val . ( string ) ) if skipIPAddrForWaiter ( ip , ignoredGuestIPs ) { continue } return true } return false } ) if err != nil { } return err } log . Printf ( " " , vm . InventoryPath ) return nil } 
func WaitForGuestNet ( client * govmomi . Client , vm * object . VirtualMachine , routable bool , timeout int , ignoredGuestIPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( " " , vm . InventoryPath ) return nil } log . Printf ( " " , vm . InventoryPath , routable , timeout , ) var v4gw , v6gw net . IP p := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err := property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { " " , " " } , func ( pc [ ] types . PropertyChange ) bool { for _ , c := range pc { if c . Op != types . PropertyChangeOpAssign { continue } switch v := c . Val . ( type ) { case types . ArrayOfGuestStackInfo : for _ , s := range v . GuestStackInfo { if s . IpRouteConfig != nil { for _ , r := range s . IpRouteConfig . IpRoute { switch r . Network { case " " : v4gw = net . ParseIP ( r . Gateway . IpAddress ) case " " : v6gw = net . ParseIP ( r . Gateway . IpAddress ) } } } } case types . ArrayOfGuestNicInfo : for _ , n := range v . GuestNicInfo { if n . IpConfig != nil { for _ , addr := range n . IpConfig . IpAddress { ip := net . ParseIP ( addr . IpAddress ) if skipIPAddrForWaiter ( ip , ignoredGuestIPs ) { continue } if ! routable { } var mask net . IPMask if ip . To4 ( ) != nil { mask = net . CIDRMask ( int ( addr . PrefixLength ) , 32 ) } else { mask = net . CIDRMask ( int ( addr . PrefixLength ) , 128 ) } if ip . Mask ( mask ) . Equal ( v4gw . Mask ( mask ) ) || ip . Mask ( mask ) . Equal ( v6gw . Mask ( mask ) ) { return true } } } } } } return false } ) if err != nil { } return err } log . Printf ( " " , vm . InventoryPath ) return nil } 
func Create ( c * govmomi . Client , f * object . Folder , s types . VirtualMachineConfigSpec , p * object . ResourcePool , h * object . HostSystem ) ( * object . VirtualMachine , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , s . Name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var task * object . Task if err != nil { if ! viapi . IsManagedObjectNotFoundError ( err ) { return nil , err } task , err = f . CreateVM ( ctx , s , p , h ) } else { task , err = vc . CreateChildVM ( ctx , s , h ) } if err != nil { return nil , err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) result , err := task . WaitForResult ( tctx , nil ) if err != nil { return nil , err } log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , s . Name ) , result . Result . ( types . ManagedObjectReference ) . Value ) return FromMOID ( c , result . Result . ( types . ManagedObjectReference ) . Value ) } 
func Clone ( c * govmomi . Client , src * object . VirtualMachine , f * object . Folder , name string , spec types . VirtualMachineCloneSpec , timeout int ) ( * object . VirtualMachine , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err := src . Clone ( ctx , f , name , spec ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { err = errors . New ( " " ) } return nil , err } result , err := task . WaitForResult ( ctx , nil ) if err != nil { if ctx . Err ( ) == context . DeadlineExceeded { err = errors . New ( " " ) } return nil , err } log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , name ) , result . Result . ( types . ManagedObjectReference ) . Value ) return FromMOID ( c , result . Result . ( types . ManagedObjectReference ) . Value ) } 
func Customize ( vm * object . VirtualMachine , spec types . CustomizationSpec ) error { log . Printf ( " " , vm . InventoryPath ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := vm . Customize ( ctx , spec ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return task . Wait ( tctx ) } 
func ShutdownGuest ( client * govmomi . Client , vm * object . VirtualMachine , timeout int ) error { log . Printf ( " " , vm . InventoryPath ) sctx , scancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer scancel ( ) if err := vm . ShutdownGuest ( sctx ) ; err != nil { return err } if timeout < 1 { timeout = 1 } pctx , pcancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer pcancel ( ) err := property . Wait ( pctx , p , vm . Reference ( ) , [ ] string { " " } , func ( pc [ ] types . PropertyChange ) bool { for _ , c := range pc { if c . Op != types . PropertyChangeOpAssign { continue } switch v := c . Val . ( type ) { case types . VirtualMachinePowerState : if v == types . VirtualMachinePowerStatePoweredOff { return true } } } return false } ) if err != nil { } return err } return nil } 
func GracefulPowerOff ( client * govmomi . Client , vm * object . VirtualMachine , timeout int , force bool ) error { vprops , err := Properties ( vm ) if err != nil { return err } } } else { return nil } } } 
func MoveToFolder ( client * govmomi . Client , vm * object . VirtualMachine , relative string ) error { log . Printf ( " " , vm . InventoryPath , relative ) f , err := folder . VirtualMachineFolderFromObject ( client , vm , relative ) if err != nil { return err } return folder . MoveObjectTo ( vm . Reference ( ) , f ) } 
func Relocate ( vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int ) error { log . Printf ( " " , vm . InventoryPath , timeout ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err := vm . Relocate ( ctx , spec , " " ) if err != nil { return err } if err := task . Wait ( ctx ) ; err != nil { } } return nil } 
func MOIDForUUID ( client * govmomi . Client , uuid string ) ( MOIDForUUIDResult , error ) { vm , err := FromUUID ( client , uuid ) if err != nil { return MOIDForUUIDResult { } , err } return MOIDForUUIDResult { UUID : uuid , MOID : vm . Reference ( ) . Value , } , nil } 
func UUIDForMOID ( client * govmomi . Client , moid string ) ( MOIDForUUIDResult , error ) { vm , err := FromMOID ( client , moid ) if err != nil { return MOIDForUUIDResult { } , err } props , err := Properties ( vm ) if err != nil { return MOIDForUUIDResult { } , err } return MOIDForUUIDResult { UUID : props . Config . Uuid , MOID : vm . Reference ( ) . Value , } , nil } 
func MOIDsForUUIDs ( client * govmomi . Client , uuids [ ] string ) ( MOIDForUUIDResults , error ) { var results MOIDForUUIDResults for _ , uuid := range uuids { result , err := MOIDForUUID ( client , uuid ) if err != nil { return nil , err } results = append ( results , result ) } return results , nil } 
func UUIDsForMOIDs ( client * govmomi . Client , moids [ ] string ) ( MOIDForUUIDResults , error ) { var results MOIDForUUIDResults for _ , uuid := range moids { result , err := UUIDForMOID ( client , uuid ) if err != nil { return nil , err } results = append ( results , result ) } return results , nil } 
func UUIDsForManagedObjectReferences ( client * govmomi . Client , refs [ ] types . ManagedObjectReference ) ( MOIDForUUIDResults , error ) { var moids [ ] string for _ , ref := range refs { moids = append ( moids , ref . Value ) } return UUIDsForMOIDs ( client , moids ) } 
func ( r MOIDForUUIDResults ) MOIDs ( ) [ ] string { var moids [ ] string for _ , result := range r { moids = append ( moids , result . MOID ) } return moids } 
func ( r MOIDForUUIDResults ) ManagedObjectReferences ( ) [ ] types . ManagedObjectReference { var refs [ ] types . ManagedObjectReference for _ , result := range r { refs = append ( refs , types . ManagedObjectReference { Type : " " , Value : result . MOID , } ) } return refs } 
func ( r MOIDForUUIDResults ) UUIDs ( ) [ ] string { var uuids [ ] string for _ , result := range r { uuids = append ( uuids , result . UUID ) } return uuids } 
func FromKey ( client * govmomi . Client , dvsUUID , pgKey string ) ( * object . DistributedVirtualPortgroup , error ) { dvsm := types . ManagedObjectReference { Type : " " , Value : " " } req := & types . DVSManagerLookupDvPortGroup { This : dvsm , SwitchUuid : dvsUUID , PortgroupKey : pgKey , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) resp , err := methods . DVSManagerLookupDvPortGroup ( ctx , client , req ) if err != nil { return nil , err } if resp . Returnval == nil { return nil , NewMissingPortGroupReferenceError ( fmt . Sprintf ( " " , dvsUUID , pgKey , ) , ) } return FromMOID ( client , resp . Returnval . Reference ( ) . Value ) } 
func FromMOID ( client * govmomi . Client , id string ) ( * object . DistributedVirtualPortgroup , error ) { finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : " " , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) ds , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , err } } 
func FromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . DistributedVirtualPortgroup , error ) { finder := find . NewFinder ( client . Client , false ) if dc != nil { finder . SetDatacenter ( dc ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) net , err := finder . Network ( ctx , name ) if err != nil { return nil , err } if net . Reference ( ) . Type != " " { return nil , fmt . Errorf ( " " , name , net . Reference ( ) . Type ) } return FromMOID ( client , net . Reference ( ) . Value ) } 
func Properties ( pg * object . DistributedVirtualPortgroup ) ( * mo . DistributedVirtualPortgroup , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . DistributedVirtualPortgroup if err := pg . Properties ( ctx , pg . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func Create ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , spec types . DVPortgroupConfigSpec ) ( * object . Task , error ) { req := & types . CreateDVPortgroup_Task { This : dvs . Reference ( ) , Spec : spec , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) resp , err := methods . CreateDVPortgroup_Task ( ctx , client , req ) if err != nil { return nil , err } return object . NewTask ( client . Client , resp . Returnval . Reference ( ) ) , nil } 
func Properties ( ds * object . Datastore ) ( * mo . Datastore , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Datastore if err := ds . Properties ( ctx , ds . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func MoveToFolder ( client * govmomi . Client , ds * object . Datastore , relative string ) error { f , err := folder . DatastoreFolderFromObject ( client , ds , relative ) if err != nil { return err } return folder . MoveObjectTo ( ds . Reference ( ) , f ) } 
func MoveToFolderRelativeHostSystemID ( client * govmomi . Client , ds * object . Datastore , hsID , relative string ) error { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return err } f , err := folder . DatastoreFolderFromObject ( client , hs , relative ) if err != nil { return err } return folder . MoveObjectTo ( ds . Reference ( ) , f ) } 
func Browser ( ds * object . Datastore ) ( * object . HostDatastoreBrowser , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return ds . Browser ( ctx ) } 
func SearchDatastore ( ds * object . Datastore , name string ) ( [ ] * types . FileInfo , error ) { result , err := searchDatastore ( ds , name ) if err != nil { return nil , err } var files [ ] * types . FileInfo for _ , bfi := range result . File { files = append ( files , bfi . GetFileInfo ( ) ) } return files , nil } 
func FileExists ( ds * object . Datastore , name string ) ( bool , error ) { files , err := SearchDatastore ( ds , name ) if err != nil { return false , err } if len ( files ) > 1 { return false , fmt . Errorf ( " " , name , ds ) } if len ( files ) < 1 { return false , nil } return path . Base ( name ) == files [ 0 ] . Path , nil } 
func FromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . VirtualApp , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) if dc != nil { finder . SetDatacenter ( dc ) } return finder . VirtualApp ( ctx , name ) } 
func FromID ( client * govmomi . Client , id string ) ( * object . VirtualApp , error ) { log . Printf ( " " , id ) finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : " " , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) obj , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , err } log . Printf ( " " , obj . Reference ( ) . Value ) return obj . ( * object . VirtualApp ) , nil } 
func IsVApp ( client * govmomi . Client , rp string ) bool { _ , err := FromID ( client , rp ) if err != nil { return false } return true } 
func Create ( rp * object . ResourcePool , name string , resSpec * types . ResourceConfigSpec , vSpec * types . VAppConfigSpec , folder * object . Folder ) ( * object . VirtualApp , error ) { log . Printf ( " " , rp . InventoryPath , name ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) nva , err := rp . CreateVApp ( ctx , name , * resSpec , * vSpec , folder ) if err != nil { return nil , err } return nva , nil } 
func Update ( vc * object . VirtualApp , spec types . VAppConfigSpec ) error { log . Printf ( " " , vc . InventoryPath ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return vc . UpdateConfig ( ctx , spec ) } 
func ResourceIDString ( d ResourceIDStringer , name string ) string { id := d . Id ( ) if id == " " { id = " " } return fmt . Sprintf ( " " , name , id ) } 
func SliceInterfacesToStrings ( s [ ] interface { } ) [ ] string { var d [ ] string for _ , v := range s { if o , ok := v . ( string ) ; ok { d = append ( d , o ) } } return d } 
func SliceStringsToInterfaces ( s [ ] string ) [ ] interface { } { var d [ ] interface { } for _ , v := range s { d = append ( d , v ) } return d } 
func SliceInterfacesToManagedObjectReferences ( s [ ] interface { } , t string ) [ ] types . ManagedObjectReference { var d [ ] types . ManagedObjectReference for _ , v := range s { d = append ( d , types . ManagedObjectReference { Type : t , Value : v . ( string ) , } ) } return d } 
func MergeSchema ( dst , src map [ string ] * schema . Schema ) { for k , v := range src { if _ , ok := dst [ k ] ; ok { panic ( fmt . Errorf ( " " , k ) ) } dst [ k ] = v } } 
func GetStringPtr ( d * schema . ResourceData , key string ) * string { v , e := d . GetOkExists ( key ) if e { return StringPtr ( v . ( string ) ) } return nil } 
func GetString ( d * schema . ResourceData , key string ) * string { return StringPtr ( d . Get ( key ) . ( string ) ) } 
func SetStringPtr ( d * schema . ResourceData , key string , val * string ) error { if val == nil { return nil } err := d . Set ( key , val ) return err } 
func GetBoolPtr ( d * schema . ResourceData , key string ) * bool { v , e := d . GetOkExists ( key ) if e { return BoolPtr ( v . ( bool ) ) } return nil } 
func GetBool ( d * schema . ResourceData , key string ) * bool { return BoolPtr ( d . Get ( key ) . ( bool ) ) } 
func SetBoolPtr ( d * schema . ResourceData , key string , val * bool ) error { if val == nil { return nil } err := d . Set ( key , val ) return err } 
func GetBoolStringPtr ( d * schema . ResourceData , key string ) ( * bool , error ) { v , ok := d . GetOk ( key ) if ! ok { return nil , nil } b , err := strconv . ParseBool ( v . ( string ) ) if err != nil { return nil , err } return & b , nil } 
func SetBoolStringPtr ( d * schema . ResourceData , key string , val * bool ) error { var s string if val != nil { s = strconv . FormatBool ( * val ) } return d . Set ( key , s ) } 
func BoolStringPtrState ( v interface { } ) string { b , err := strconv . ParseBool ( v . ( string ) ) if err != nil { return " " } return strconv . FormatBool ( b ) } 
func ValidateBoolStringPtr ( ) schema . SchemaValidateFunc { return func ( i interface { } , k string ) ( s [ ] string , es [ ] error ) { v := i . ( string ) if v == " " { return } if _ , err := strconv . ParseBool ( v ) ; err != nil { es = append ( es , err ) } return } } 
func GetInt64Ptr ( d * schema . ResourceData , key string ) * int64 { v , e := d . GetOkExists ( key ) if e { return Int64Ptr ( int64 ( v . ( int ) ) ) } return nil } 
func GetInt64PtrEmptyZero ( d * schema . ResourceData , key string ) * int64 { i := GetInt64Ptr ( d , key ) if i != nil { return i } return Int64Ptr ( int64 ( 0 ) ) } 
func SetInt64Ptr ( d * schema . ResourceData , key string , val * int64 ) error { if val == nil { return nil } err := d . Set ( key , val ) return err } 
func GiBToByte ( n interface { } ) int64 { switch v := n . ( type ) { case int : return int64 ( v * int ( math . Pow ( 1024 , 3 ) ) ) case int32 : return int64 ( v * int32 ( math . Pow ( 1024 , 3 ) ) ) case int64 : return v * int64 ( math . Pow ( 1024 , 3 ) ) } panic ( fmt . Errorf ( " " , n ) ) } 
func GBToByte ( n interface { } ) int64 { switch v := n . ( type ) { case int : return int64 ( v * 1000000000 ) case int32 : return int64 ( v * 1000000000 ) case int64 : return v * 1000000000 } panic ( fmt . Errorf ( " " , n ) ) } 
func BoolPolicy ( b bool ) * types . BoolPolicy { bp := & types . BoolPolicy { Value : BoolPtr ( b ) , } return bp } 
func GetBoolPolicy ( d * schema . ResourceData , key string ) * types . BoolPolicy { v , e := d . GetOkExists ( key ) if e { return BoolPolicy ( v . ( bool ) ) } return nil } 
func SetBoolPolicy ( d * schema . ResourceData , key string , val * types . BoolPolicy ) error { if val == nil { return nil } err := d . Set ( key , val . Value ) return err } 
func StringPolicy ( s string ) * types . StringPolicy { sp := & types . StringPolicy { Value : s , } return sp } 
func GetStringPolicy ( d * schema . ResourceData , key string ) * types . StringPolicy { v , e := d . GetOkExists ( key ) if e { return StringPolicy ( v . ( string ) ) } return nil } 
func SetStringPolicy ( d * schema . ResourceData , key string , val * types . StringPolicy ) error { if val == nil { return nil } err := d . Set ( key , val . Value ) return err } 
func LongPolicy ( n interface { } ) * types . LongPolicy { lp := & types . LongPolicy { } switch v := n . ( type ) { case int : lp . Value = int64 ( v ) case int8 : lp . Value = int64 ( v ) case int16 : lp . Value = int64 ( v ) case int32 : lp . Value = int64 ( v ) case uint : lp . Value = int64 ( v ) case uint8 : lp . Value = int64 ( v ) case uint16 : lp . Value = int64 ( v ) case uint32 : lp . Value = int64 ( v ) case int64 : lp . Value = v default : panic ( fmt . Errorf ( " " , n ) ) } return lp } 
func GetLongPolicy ( d * schema . ResourceData , key string ) * types . LongPolicy { v , e := d . GetOkExists ( key ) if e { return LongPolicy ( v ) } return nil } 
func SetLongPolicy ( d * schema . ResourceData , key string , val * types . LongPolicy ) error { if val == nil { return nil } err := d . Set ( key , val . Value ) return err } 
func AllFieldsEmpty ( v interface { } ) bool { if v == nil { return true } t := reflect . TypeOf ( v ) if t . Kind ( ) != reflect . Struct && ( t . Kind ( ) == reflect . Ptr && t . Elem ( ) . Kind ( ) != reflect . Struct ) { if reflect . Zero ( t ) . Interface ( ) != reflect . ValueOf ( v ) . Interface ( ) { return false } return true } if t . Kind ( ) == reflect . Ptr { t = t . Elem ( ) } for i := 0 ; i < t . NumField ( ) ; i ++ { var fv reflect . Value if reflect . ValueOf ( v ) . Kind ( ) == reflect . Ptr { fv = reflect . ValueOf ( v ) . Elem ( ) . Field ( i ) } else { fv = reflect . ValueOf ( v ) . Elem ( ) . Field ( i ) } ft := t . Field ( i ) . Type fz := reflect . Zero ( ft ) switch ft . Kind ( ) { case reflect . Map , reflect . Slice : if fv . Len ( ) > 0 { return false } default : if fz . Interface ( ) != fv . Interface ( ) { return false } } } return true } 
func DeRef ( v interface { } ) interface { } { if v == nil { return nil } k := reflect . TypeOf ( v ) . Kind ( ) if k != reflect . Ptr { return v } if reflect . ValueOf ( v ) == reflect . Zero ( reflect . TypeOf ( v ) ) { } return reflect . ValueOf ( v ) . Elem ( ) . Interface ( ) } 
func NormalizeValue ( v interface { } ) interface { } { v = DeRef ( v ) if v == nil { return nil } k := reflect . TypeOf ( v ) . Kind ( ) switch { case k >= reflect . Int8 && k <= reflect . Uint64 : v = reflect . ValueOf ( v ) . Convert ( reflect . TypeOf ( int ( 0 ) ) ) . Interface ( ) case k == reflect . Float32 : v = reflect . ValueOf ( v ) . Convert ( reflect . TypeOf ( float64 ( 0 ) ) ) . Interface ( ) } return v } 
func SetBatch ( d * schema . ResourceData , attrs map [ string ] interface { } ) error { for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func ( s MoRefSorter ) Less ( i , j int ) bool { return s [ i ] . Value < s [ j ] . Value } 
func ( s MoRefSorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] } 
func hostDatastoreSystemFromHostSystemID ( client * govmomi . Client , hsID string ) ( * object . HostDatastoreSystem , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return nil , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return hs . ConfigManager ( ) . DatastoreSystem ( ctx ) } 
func availableScsiDisk ( dss * object . HostDatastoreSystem , name string ) ( * types . HostScsiDisk , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) disks , err := dss . QueryAvailableDisksForVmfs ( ctx ) if err != nil { return nil , fmt . Errorf ( " " , err ) } var disk * types . HostScsiDisk for _ , d := range disks { if d . CanonicalName == name { disk = & d break } } if disk == nil { return nil , fmt . Errorf ( " " , name ) } return disk , nil } 
func diskSpecForCreate ( dss * object . HostDatastoreSystem , name string ) ( * types . VmfsDatastoreCreateSpec , error ) { disk , err := availableScsiDisk ( dss , name ) if err != nil { return nil , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) options , err := dss . QueryVmfsDatastoreCreateOptions ( ctx , disk . DevicePath ) if err != nil { return nil , fmt . Errorf ( " " , name , err ) } var option * types . VmfsDatastoreOption for _ , o := range options { if _ , ok := o . Info . ( * types . VmfsDatastoreAllExtentOption ) ; ok { option = & o break } } if option == nil { return nil , fmt . Errorf ( " " , name ) } return option . Spec . ( * types . VmfsDatastoreCreateSpec ) , nil } 
func diskSpecForExtend ( dss * object . HostDatastoreSystem , ds * object . Datastore , name string ) ( * types . VmfsDatastoreExtendSpec , error ) { disk , err := availableScsiDisk ( dss , name ) if err != nil { return nil , err } props , err := datastore . Properties ( ds ) if err != nil { return nil , fmt . Errorf ( " " , ds . Reference ( ) . Value , err ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) options , err := queryVmfsDatastoreExtendOptions ( ctx , dss , ds , disk . DevicePath , true ) if err != nil { return nil , fmt . Errorf ( " " , name , err ) } var option * types . VmfsDatastoreOption for _ , o := range options { if _ , ok := o . Info . ( * types . VmfsDatastoreAllExtentOption ) ; ok { option = & o break } } if option == nil { return nil , fmt . Errorf ( " " , name , props . Summary . Name ) } return option . Spec . ( * types . VmfsDatastoreExtendSpec ) , nil } 
func removeDatastore ( s * object . HostDatastoreSystem , ds * object . Datastore ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return s . Remove ( ctx , ds ) } 
func queryVmfsDatastoreExtendOptions ( ctx context . Context , s * object . HostDatastoreSystem , ds * object . Datastore , devicePath string , suppressExpandCandidates bool ) ( [ ] types . VmfsDatastoreOption , error ) { req := types . QueryVmfsDatastoreExtendOptions { This : s . Reference ( ) , Datastore : ds . Reference ( ) , DevicePath : devicePath , SuppressExpandCandidates : & suppressExpandCandidates , } res , err := methods . QueryVmfsDatastoreExtendOptions ( ctx , s . Client ( ) , & req ) if err != nil { return nil , err } return res . Returnval , nil } 
func extendVmfsDatastore ( ctx context . Context , s * object . HostDatastoreSystem , ds * object . Datastore , spec types . VmfsDatastoreExtendSpec ) ( * object . Datastore , error ) { req := types . ExtendVmfsDatastore { This : s . Reference ( ) , Datastore : ds . Reference ( ) , Spec : spec , } res , err := methods . ExtendVmfsDatastore ( ctx , s . Client ( ) , & req ) if err != nil { return nil , err } return object . NewDatastore ( s . Client ( ) , res . Returnval ) , nil } 
func resourceVSphereComputeClusterImportSetDefaults ( d * schema . ResourceData ) error { s := resourceVSphereComputeCluster ( ) . Schema return structure . SetBatch ( d , map [ string ] interface { } { " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , } ) } 
func resourceVSphereComputeClusterApplyCreate ( d * schema . ResourceData , meta interface { } ) ( * object . ClusterComputeResource , error ) { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return nil , err } dc , err := datacenterFromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } return cluster , nil } 
func resourceVSphereComputeClusterProcessHostUpdate ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return err } o , n := d . GetChange ( " " ) newHosts , err := resourceVSphereComputeClusterGetHostSystemObjects ( client , structure . SliceInterfacesToStrings ( n . ( * schema . Set ) . Difference ( o . ( * schema . Set ) ) . List ( ) ) , ) if err != nil { return err } oldHosts , err := resourceVSphereComputeClusterGetHostSystemObjects ( client , structure . SliceInterfacesToStrings ( o . ( * schema . Set ) . Difference ( n . ( * schema . Set ) ) . List ( ) ) , ) if err != nil { return err } } } } return nil } 
func resourceVSphereComputeClusterApplyTags ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } return nil } log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) return processTagDiff ( tagsClient , d , cluster ) } 
func resourceVSphereComputeClusterReadTags ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) if err := readTagsForResource ( tagsClient , cluster , d ) ; err != nil { return err } } else { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) } return nil } 
func resourceVSphereComputeClusterApplyCustomAttributes ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { client := meta . ( * VSphereClient ) . vimClient if err != nil { return err } if attrsProcessor == nil { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) return nil } log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) return attrsProcessor . ProcessDiff ( cluster ) } 
func resourceVSphereComputeClusterReadCustomAttributes ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { client := meta . ( * VSphereClient ) . vimClient props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return err } customattribute . ReadFromResource ( client , props . Entity ( ) , d ) } else { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) } return nil } 
func resourceVSphereComputeClusterGetCluster ( d structure . ResourceIDStringer , meta interface { } , ) ( * object . ClusterComputeResource , error ) { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return nil , err } return clustercomputeresource . FromID ( client , d . Id ( ) ) } 
func resourceVSphereComputeClusterGetClusterFromPath ( meta interface { } , path string , dcID string , ) ( * object . ClusterComputeResource , error ) { client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return nil , err } var dc * object . Datacenter if dcID != " " { var err error dc , err = datacenterFromID ( client , dcID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , path , dc . InventoryPath ) } else { log . Printf ( " " , path ) } return clustercomputeresource . FromPath ( client , path , dc ) } 
func resourceVSphereComputeClusterSaveDatacenter ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return err } p , err := folder . RootPathParticleHost . SplitDatacenter ( cluster . InventoryPath ) if err != nil { return fmt . Errorf ( " " , err ) } dc , err := getDatacenter ( client , p ) if err != nil { return fmt . Errorf ( " " , err ) } return d . Set ( " " , dc . Reference ( ) . Value ) } 
func resourceVSphereComputeClusterSaveNameAndPath ( d * schema . ResourceData , cluster * object . ClusterComputeResource ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) if err := d . Set ( " " , cluster . Name ( ) ) ; err != nil { return fmt . Errorf ( " " , err ) } f , err := folder . RootPathParticleHost . SplitRelativeFolder ( cluster . InventoryPath ) if err != nil { return fmt . Errorf ( " " , cluster . InventoryPath , err ) } if err := d . Set ( " " , folder . NormalizePath ( f ) ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func resourceVSphereComputeClusterApplyNameChange ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) ( * object . ClusterComputeResource , error ) { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) var changed bool var err error if d . HasChange ( " " ) { if err = clustercomputeresource . Rename ( cluster , d . Get ( " " ) . ( string ) ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } changed = true } if changed { if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) } return cluster , nil } 
func resourceVSphereComputeClusterApplyFolderChange ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) ( * object . ClusterComputeResource , error ) { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) var changed bool var err error if d . HasChange ( " " ) { f := d . Get ( " " ) . ( string ) client := meta . ( * VSphereClient ) . vimClient if err = clustercomputeresource . MoveToFolder ( client , cluster , f ) ; err != nil { return nil , fmt . Errorf ( " " , f , err ) } changed = true } if changed { if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) , cluster . InventoryPath , ) } return cluster , nil } 
func resourceVSphereComputeClusterValidateEmptyCluster ( d structure . ResourceIDStringer , cluster * object . ClusterComputeResource , ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) ne , err := clustercomputeresource . HasChildren ( cluster ) if err != nil { return fmt . Errorf ( " " , err ) } if ne { return fmt . Errorf ( " " , cluster . InventoryPath , ) } return nil } 
func resourceVSphereComputeClusterDeleteProcessForceRemoveHosts ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { if ! d . Get ( " " ) . ( bool ) { return nil } client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return err } log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) hosts , err := resourceVSphereComputeClusterGetHostSystemObjects ( client , structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err != nil { return err } if err := clustercomputeresource . MoveHostsOutOf ( cluster , hosts , d . Get ( " " ) . ( int ) ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func resourceVSphereComputeClusterApplyDelete ( d structure . ResourceIDStringer , cluster * object . ClusterComputeResource ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) if err := clustercomputeresource . Delete ( cluster ) ; err != nil { return err } return nil } 
func resourceVSphereComputeClusterFlattenData ( d * schema . ResourceData , meta interface { } , cluster * object . ClusterComputeResource , ) error { log . Printf ( " " , resourceVSphereComputeClusterIDString ( d ) ) client , err := resourceVSphereComputeClusterClient ( meta ) if err != nil { return err } props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return err } } return flattenClusterConfigSpecEx ( d , props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) , version ) } 
func expandClusterConfigSpecEx ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . ClusterConfigSpecEx { obj := & types . ClusterConfigSpecEx { DasConfig : expandClusterDasConfigInfo ( d , version ) , DpmConfig : expandClusterDpmConfigInfo ( d ) , DrsConfig : expandClusterDrsConfigInfo ( d ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . InfraUpdateHaConfig = expandClusterInfraUpdateHaConfigInfo ( d ) obj . Orchestration = expandClusterOrchestrationInfo ( d ) obj . ProactiveDrsConfig = expandClusterProactiveDrsConfigInfo ( d ) } return obj } 
func flattenClusterConfigSpecEx ( d * schema . ResourceData , obj * types . ClusterConfigInfoEx , version viapi . VSphereVersion ) error { if err := flattenClusterDasConfigInfo ( d , obj . DasConfig , version ) ; err != nil { return err } if err := flattenClusterDpmConfigInfo ( d , obj . DpmConfigInfo ) ; err != nil { return err } if err := flattenClusterDrsConfigInfo ( d , obj . DrsConfig ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { if err := flattenClusterInfraUpdateHaConfigInfo ( d , obj . InfraUpdateHaConfig ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { if err := flattenClusterOrchestrationInfo ( d , obj . Orchestration ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return flattenClusterProactiveDrsConfigInfo ( d , obj . ProactiveDrsConfig ) } return nil } 
func expandClusterDasConfigInfo ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . ClusterDasConfigInfo { obj := & types . ClusterDasConfigInfo { DefaultVmSettings : expandClusterDasVMSettings ( d , version ) , Enabled : structure . GetBool ( d , " " ) , HBDatastoreCandidatePolicy : d . Get ( " " ) . ( string ) , HostMonitoring : d . Get ( " " ) . ( string ) , Option : expandResourceVSphereComputeClusterDasAdvancedOptions ( d ) , VmMonitoring : d . Get ( " " ) . ( string ) , HeartbeatDatastore : structure . SliceInterfacesToManagedObjectReferences ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " , ) , } policy := d . Get ( " " ) . ( string ) if policy != clusterAdmissionControlTypeDisabled { obj . AdmissionControlEnabled = structure . BoolPtr ( true ) } else { obj . AdmissionControlEnabled = structure . BoolPtr ( false ) } obj . AdmissionControlPolicy = expandBaseClusterDasAdmissionControlPolicy ( d , policy , version ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . VmComponentProtecting = d . Get ( " " ) . ( string ) } return obj } 
func flattenClusterDasConfigInfo ( d * schema . ResourceData , obj types . ClusterDasConfigInfo , version viapi . VSphereVersion ) error { var dsIDs [ ] string for _ , v := range obj . HeartbeatDatastore { dsIDs = append ( dsIDs , v . Value ) } err := structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . HBDatastoreCandidatePolicy , " " : obj . HostMonitoring , " " : obj . VmMonitoring , " " : dsIDs , } ) if err != nil { return err } if err := flattenClusterDasVMSettings ( d , obj . DefaultVmSettings , version ) ; err != nil { return err } if err := flattenResourceVSphereComputeClusterDasAdvancedOptions ( d , obj . Option ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := d . Set ( " " , obj . VmComponentProtecting ) ; err != nil { return err } } } return flattenBaseClusterDasAdmissionControlPolicy ( d , obj . AdmissionControlPolicy , version ) } 
func expandBaseClusterDasAdmissionControlPolicy ( d * schema . ResourceData , policy string , version viapi . VSphereVersion , ) types . BaseClusterDasAdmissionControlPolicy { var obj types . BaseClusterDasAdmissionControlPolicy switch policy { case clusterAdmissionControlTypeResourcePercentage : obj = expandClusterFailoverResourcesAdmissionControlPolicy ( d , version ) case clusterAdmissionControlTypeSlotPolicy : obj = expandClusterFailoverLevelAdmissionControlPolicy ( d ) case clusterAdmissionControlTypeFailoverHosts : obj = expandClusterFailoverHostAdmissionControlPolicy ( d , version ) case clusterAdmissionControlTypeDisabled : return nil } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . GetClusterDasAdmissionControlPolicy ( ) . ResourceReductionToToleratePercent = int32 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flattenBaseClusterDasAdmissionControlPolicy ( d * schema . ResourceData , obj types . BaseClusterDasAdmissionControlPolicy , version viapi . VSphereVersion , ) error { var policy string switch t := obj . ( type ) { case * types . ClusterFailoverResourcesAdmissionControlPolicy : if err := flattenClusterFailoverResourcesAdmissionControlPolicy ( d , t , version ) ; err != nil { return err } policy = clusterAdmissionControlTypeResourcePercentage case * types . ClusterFailoverLevelAdmissionControlPolicy : if err := flattenClusterFailoverLevelAdmissionControlPolicy ( d , t ) ; err != nil { return err } policy = clusterAdmissionControlTypeSlotPolicy case * types . ClusterFailoverHostAdmissionControlPolicy : if err := flattenClusterFailoverHostAdmissionControlPolicy ( d , t , version ) ; err != nil { return err } policy = clusterAdmissionControlTypeFailoverHosts default : policy = clusterAdmissionControlTypeDisabled } return d . Set ( " " , policy ) } 
func expandClusterFailoverResourcesAdmissionControlPolicy ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . ClusterFailoverResourcesAdmissionControlPolicy { obj := & types . ClusterFailoverResourcesAdmissionControlPolicy { CpuFailoverResourcesPercent : int32 ( d . Get ( " " ) . ( int ) ) , MemoryFailoverResourcesPercent : int32 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . AutoComputePercentages = structure . GetBool ( d , " " ) obj . FailoverLevel = int32 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flattenClusterFailoverResourcesAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverResourcesAdmissionControlPolicy , version viapi . VSphereVersion , ) error { if err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . AutoComputePercentages , " " : obj . FailoverLevel , } ) } return nil } 
func expandClusterFailoverLevelAdmissionControlPolicy ( d * schema . ResourceData ) * types . ClusterFailoverLevelAdmissionControlPolicy { obj := & types . ClusterFailoverLevelAdmissionControlPolicy { FailoverLevel : int32 ( d . Get ( " " ) . ( int ) ) , } if d . Get ( " " ) . ( bool ) { obj . SlotPolicy = & types . ClusterFixedSizeSlotPolicy { Cpu : int32 ( d . Get ( " " ) . ( int ) ) , Memory : int32 ( d . Get ( " " ) . ( int ) ) , } } return obj } 
func flattenClusterFailoverLevelAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverLevelAdmissionControlPolicy , ) error { if err := d . Set ( " " , obj . FailoverLevel ) ; err != nil { return err } if obj . SlotPolicy != nil { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . SlotPolicy . ( * types . ClusterFixedSizeSlotPolicy ) . Cpu , " " : obj . SlotPolicy . ( * types . ClusterFixedSizeSlotPolicy ) . Memory , } ) } return nil } 
func expandClusterFailoverHostAdmissionControlPolicy ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . ClusterFailoverHostAdmissionControlPolicy { obj := & types . ClusterFailoverHostAdmissionControlPolicy { FailoverHosts : structure . SliceInterfacesToManagedObjectReferences ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " , ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . FailoverLevel = int32 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flattenClusterFailoverHostAdmissionControlPolicy ( d * schema . ResourceData , obj * types . ClusterFailoverHostAdmissionControlPolicy , version viapi . VSphereVersion , ) error { var hsIDs [ ] string for _ , v := range obj . FailoverHosts { hsIDs = append ( hsIDs , v . Value ) } if err := d . Set ( " " , hsIDs ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( " " , obj . FailoverLevel ) } return nil } 
func expandClusterDasVMSettings ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . ClusterDasVmSettings { obj := & types . ClusterDasVmSettings { IsolationResponse : d . Get ( " " ) . ( string ) , RestartPriority : d . Get ( " " ) . ( string ) , VmToolsMonitoringSettings : expandClusterVMToolsMonitoringSettings ( d ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . VmComponentProtectionSettings = expandClusterVMComponentProtectionSettings ( d ) } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . RestartPriorityTimeout = int32 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flattenClusterDasVMSettings ( d * schema . ResourceData , obj * types . ClusterDasVmSettings , version viapi . VSphereVersion ) error { err := structure . SetBatch ( d , map [ string ] interface { } { " " : obj . IsolationResponse , " " : obj . RestartPriority , } ) if err != nil { return err } if err := flattenClusterVMToolsMonitoringSettings ( d , obj . VmToolsMonitoringSettings ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := flattenClusterVMComponentProtectionSettings ( d , obj . VmComponentProtectionSettings ) ; err != nil { return err } } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( " " , obj . RestartPriorityTimeout ) } return nil } 
func expandClusterVMComponentProtectionSettings ( d * schema . ResourceData ) * types . ClusterVmComponentProtectionSettings { obj := & types . ClusterVmComponentProtectionSettings { VmReactionOnAPDCleared : d . Get ( " " ) . ( string ) , VmStorageProtectionForAPD : d . Get ( " " ) . ( string ) , VmStorageProtectionForPDL : d . Get ( " " ) . ( string ) , VmTerminateDelayForAPDSec : int32 ( d . Get ( " " ) . ( int ) ) , } if d . Get ( " " ) . ( string ) != string ( types . ClusterVmComponentProtectionSettingsStorageVmReactionDisabled ) { } return obj } 
func flattenClusterVMComponentProtectionSettings ( d * schema . ResourceData , obj * types . ClusterVmComponentProtectionSettings ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . VmReactionOnAPDCleared , " " : obj . VmStorageProtectionForAPD , " " : obj . VmStorageProtectionForPDL , " " : obj . VmTerminateDelayForAPDSec , } ) } 
func expandClusterVMToolsMonitoringSettings ( d * schema . ResourceData ) * types . ClusterVmToolsMonitoringSettings { obj := & types . ClusterVmToolsMonitoringSettings { FailureInterval : int32 ( d . Get ( " " ) . ( int ) ) , MaxFailures : int32 ( d . Get ( " " ) . ( int ) ) , MaxFailureWindow : int32 ( d . Get ( " " ) . ( int ) ) , MinUpTime : int32 ( d . Get ( " " ) . ( int ) ) , VmMonitoring : d . Get ( " " ) . ( string ) , } return obj } 
func flattenClusterVMToolsMonitoringSettings ( d * schema . ResourceData , obj * types . ClusterVmToolsMonitoringSettings ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . FailureInterval , " " : obj . MaxFailures , " " : obj . MaxFailureWindow , " " : obj . MinUpTime , " " : obj . VmMonitoring , } ) } 
func expandClusterDpmConfigInfo ( d * schema . ResourceData ) * types . ClusterDpmConfigInfo { obj := & types . ClusterDpmConfigInfo { DefaultDpmBehavior : types . DpmBehavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . GetBool ( d , " " ) , HostPowerActionRate : int32 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flattenClusterDpmConfigInfo ( d * schema . ResourceData , obj * types . ClusterDpmConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . DefaultDpmBehavior , " " : obj . Enabled , " " : obj . HostPowerActionRate , } ) } 
func expandClusterDrsConfigInfo ( d * schema . ResourceData ) * types . ClusterDrsConfigInfo { obj := & types . ClusterDrsConfigInfo { DefaultVmBehavior : types . DrsBehavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . GetBool ( d , " " ) , EnableVmBehaviorOverrides : structure . GetBool ( d , " " ) , VmotionRate : int32 ( d . Get ( " " ) . ( int ) ) , Option : expandResourceVSphereComputeClusterDrsAdvancedOptions ( d ) , } return obj } 
func flattenClusterDrsConfigInfo ( d * schema . ResourceData , obj types . ClusterDrsConfigInfo ) error { err := structure . SetBatch ( d , map [ string ] interface { } { " " : obj . DefaultVmBehavior , " " : obj . Enabled , " " : obj . EnableVmBehaviorOverrides , " " : obj . VmotionRate , } ) if err != nil { return err } return flattenResourceVSphereComputeClusterDrsAdvancedOptions ( d , obj . Option ) } 
func expandResourceVSphereComputeClusterDrsAdvancedOptions ( d * schema . ResourceData ) [ ] types . BaseOptionValue { var opts [ ] types . BaseOptionValue m := d . Get ( " " ) . ( map [ string ] interface { } ) for k , v := range m { opts = append ( opts , & types . OptionValue { Key : k , Value : types . AnyType ( v ) , } ) } return opts } 
func expandClusterInfraUpdateHaConfigInfo ( d * schema . ResourceData ) * types . ClusterInfraUpdateHaConfigInfo { obj := & types . ClusterInfraUpdateHaConfigInfo { Behavior : d . Get ( " " ) . ( string ) , Enabled : structure . GetBool ( d , " " ) , ModerateRemediation : d . Get ( " " ) . ( string ) , Providers : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , SevereRemediation : d . Get ( " " ) . ( string ) , } return obj } 
func flattenClusterInfraUpdateHaConfigInfo ( d * schema . ResourceData , obj * types . ClusterInfraUpdateHaConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , " " : obj . ModerateRemediation , " " : obj . Providers , " " : obj . SevereRemediation , } ) } 
func expandClusterOrchestrationInfo ( d * schema . ResourceData ) * types . ClusterOrchestrationInfo { obj := & types . ClusterOrchestrationInfo { DefaultVmReadiness : & types . ClusterVmReadiness { PostReadyDelay : int32 ( d . Get ( " " ) . ( int ) ) , ReadyCondition : d . Get ( " " ) . ( string ) , } , } return obj } 
func flattenClusterOrchestrationInfo ( d * schema . ResourceData , obj * types . ClusterOrchestrationInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . DefaultVmReadiness . PostReadyDelay , " " : obj . DefaultVmReadiness . ReadyCondition , } ) } 
func expandClusterProactiveDrsConfigInfo ( d * schema . ResourceData ) * types . ClusterProactiveDrsConfigInfo { obj := & types . ClusterProactiveDrsConfigInfo { Enabled : structure . GetBool ( d , " " ) , } return obj } 
func flattenClusterProactiveDrsConfigInfo ( d * schema . ResourceData , obj * types . ClusterProactiveDrsConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Enabled , } ) } 
func resourceVSphereComputeClusterHasClusterConfigChange ( d * schema . ResourceData ) bool { for k := range resourceVSphereComputeCluster ( ) . Schema { switch { case resourceVSphereComputeClusterHasClusterConfigChangeExcluded ( k ) : continue case d . HasChange ( k ) : return true } } return false } 
func Properties ( pod * object . StoragePod ) ( * mo . StoragePod , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . StoragePod if err := pod . Properties ( ctx , pod . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func Create ( f * object . Folder , name string ) ( * object . StoragePod , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) pod , err := f . CreateStoragePod ( ctx , name ) if err != nil { return nil , err } return pod , nil } 
func ApplyDRSConfiguration ( client * govmomi . Client , pod * object . StoragePod , spec types . StorageDrsConfigSpec ) error { log . Printf ( " " , pod . InventoryPath ) mgr := object . NewStorageResourceManager ( client . Client ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := mgr . ConfigureStorageDrsForPod ( ctx , pod , spec , true ) if err != nil { return err } return task . Wait ( ctx ) } 
func Rename ( pod * object . StoragePod , name string ) error { log . Printf ( " " , pod . InventoryPath , name ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := pod . Rename ( ctx , name ) if err != nil { return err } return task . Wait ( ctx ) } 
func MoveToFolder ( client * govmomi . Client , pod * object . StoragePod , relative string ) error { f , err := folder . DatastoreFolderFromObject ( client , pod , relative ) if err != nil { return err } return folder . MoveObjectTo ( pod . Reference ( ) , f ) } 
func HasChildren ( pod * object . StoragePod ) ( bool , error ) { return folder . HasChildren ( pod . Folder ) } 
func StorageDRSEnabled ( pod * object . StoragePod ) ( bool , error ) { props , err := Properties ( pod ) if err != nil { return false , err } if props . PodStorageDrsEntry == nil { return false , nil } return props . PodStorageDrsEntry . StorageDrsConfig . PodConfig . Enabled , nil } 
func CreateVM ( client * govmomi . Client , fo * object . Folder , spec types . VirtualMachineConfigSpec , pool * object . ResourcePool , host * object . HostSystem , pod * object . StoragePod , ) ( * object . VirtualMachine , error ) { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return nil , err } if ! sdrsEnabled { return nil , fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , fmt . Sprintf ( " " , fo . InventoryPath , spec . Name ) , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Type : string ( types . StoragePlacementSpecPlacementTypeCreate ) , ResourcePool : types . NewReference ( pool . Reference ( ) ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , InitialVmConfig : expandVMPodConfigForPlacement ( spec . DeviceChange , pod ) , } , ConfigSpec : & spec , Folder : types . NewReference ( fo . Reference ( ) ) , } if host != nil { sps . Host = types . NewReference ( host . Reference ( ) ) } placement , err := recommendSDRS ( client , sps , provider . DefaultAPITimeout ) if err != nil { return nil , err } switch { case viapi . IsManagedObjectNotFoundError ( err ) : default : return nil , err } } return applySDRS ( client , placement , provider . DefaultAPITimeout ) } 
func CloneVM ( client * govmomi . Client , src * object . VirtualMachine , fo * object . Folder , name string , spec types . VirtualMachineCloneSpec , timeout int , pod * object . StoragePod , ) ( * object . VirtualMachine , error ) { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return nil , err } if ! sdrsEnabled { return nil , fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , src . InventoryPath , fmt . Sprintf ( " " , fo . InventoryPath , name ) , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Folder : types . NewReference ( fo . Reference ( ) ) , Vm : types . NewReference ( src . Reference ( ) ) , CloneName : name , CloneSpec : & spec , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , } , Type : string ( types . StoragePlacementSpecPlacementTypeClone ) , } return recommendAndApplySDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) } 
func ReconfigureVM ( client * govmomi . Client , vm * object . VirtualMachine , spec types . VirtualMachineConfigSpec , pod * object . StoragePod , ) error { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return err } if ! sdrsEnabled { return fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , vm . InventoryPath , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Type : string ( types . StoragePlacementSpecPlacementTypeReconfigure ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { InitialVmConfig : expandVMPodConfigForPlacement ( spec . DeviceChange , pod ) , } , Vm : types . NewReference ( vm . Reference ( ) ) , ConfigSpec : & spec , } _ , err = recommendAndApplySDRS ( client , sps , provider . DefaultAPITimeout ) return err } 
func RelocateVM ( client * govmomi . Client , vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int , pod * object . StoragePod , ) error { sdrsEnabled , err := StorageDRSEnabled ( pod ) if err != nil { return err } if ! sdrsEnabled { return fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , vm . InventoryPath , pod . Name ( ) , ) sps := types . StoragePlacementSpec { Vm : types . NewReference ( vm . Reference ( ) ) , PodSelectionSpec : types . StorageDrsPodSelectionSpec { StoragePod : types . NewReference ( pod . Reference ( ) ) , } , Priority : types . VirtualMachineMovePriorityDefaultPriority , RelocateSpec : & spec , Type : string ( types . StoragePlacementSpecPlacementTypeRelocate ) , } _ , err = recommendAndApplySDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) return err } 
func HasDiskCreationOperations ( dc [ ] types . BaseVirtualDeviceConfigSpec ) bool { for _ , deviceConfigSpec := range dc { if _ , ok := virtualDiskFromDeviceConfigSpecForPlacement ( deviceConfigSpec ) ; ok { return true } } return false } 
func IsMember ( pod * object . StoragePod , ds * object . Datastore ) ( bool , error ) { dprops , err := datastore . Properties ( ds ) if err != nil { return false , fmt . Errorf ( " " , ds . Name ( ) , err ) } if dprops . Parent == nil { return false , nil } if * dprops . Parent != pod . Reference ( ) { return false , nil } return true , nil } 
func ( c * VSphereClient ) TagsClient ( ) ( * tags . RestClient , error ) { if err := viapi . ValidateVirtualCenter ( c . vimClient ) ; err != nil { return nil , err } if c . tagsClient == nil { return nil , fmt . Errorf ( " " , tagsMinVersion ) } return c . tagsClient , nil } 
func NewConfig ( d * schema . ResourceData ) ( * Config , error ) { if server == " " { server = d . Get ( " " ) . ( string ) } if server == " " { return nil , fmt . Errorf ( " " ) } c := & Config { User : d . Get ( " " ) . ( string ) , Password : d . Get ( " " ) . ( string ) , InsecureFlag : d . Get ( " " ) . ( bool ) , VSphereServer : server , Debug : d . Get ( " " ) . ( bool ) , DebugPathRun : d . Get ( " " ) . ( string ) , DebugPath : d . Get ( " " ) . ( string ) , Persist : d . Get ( " " ) . ( bool ) , VimSessionPath : d . Get ( " " ) . ( string ) , RestSessionPath : d . Get ( " " ) . ( string ) , } return c , nil } 
func ( c * Config ) vimURL ( ) ( * url . URL , error ) { u , err := url . Parse ( " " + c . VSphereServer + " " ) if err != nil { return nil , fmt . Errorf ( " " , err ) } u . User = url . UserPassword ( c . User , c . Password ) return u , nil } 
func ( c * Config ) Client ( ) ( * VSphereClient , error ) { client := new ( VSphereClient ) u , err := c . vimURL ( ) if err != nil { return nil , fmt . Errorf ( " " , err ) } err = c . EnableDebug ( ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , err } log . Printf ( " " , c . VSphereServer ) if isEligibleTagEndpoint ( client . vimClient ) { if err != nil { return nil , err } log . Println ( " " ) } else { } } if err := c . SaveRestClient ( client . tagsClient ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } return client , nil } 
func ( c * Config ) EnableDebug ( ) error { if ! c . Debug { return nil } if r == " " { r = filepath . Join ( os . Getenv ( " " ) , " " ) } r = filepath . Join ( r , " " ) if run == " " { now := time . Now ( ) . Format ( " " ) r = filepath . Join ( r , now ) } else { _ = os . RemoveAll ( r ) } err := os . MkdirAll ( r , 0700 ) if err != nil { log . Printf ( " " , err ) return err } p := debug . FileProvider { Path : r , } debug . SetProvider ( & p ) return nil } 
func ( c * Config ) sessionFile ( ) ( string , error ) { u , err := c . vimURLWithoutPassword ( ) if err != nil { return " " , err } name := fmt . Sprintf ( " " , sha1 . Sum ( [ ] byte ( key ) ) ) return name , nil } 
func ( c * Config ) vimSessionFile ( ) ( string , error ) { p , err := c . sessionFile ( ) if err != nil { return " " , err } return filepath . Join ( c . VimSessionPath , p ) , nil } 
func ( c * Config ) restSessionFile ( ) ( string , error ) { p , err := c . sessionFile ( ) if err != nil { return " " , err } return filepath . Join ( c . RestSessionPath , p ) , nil } 
func ( c * Config ) SaveVimClient ( client * govmomi . Client ) error { if ! c . Persist { return nil } p , err := c . vimSessionFile ( ) if err != nil { return err } log . Printf ( " " , p ) err = os . MkdirAll ( filepath . Dir ( p ) , 0700 ) if err != nil { return err } f , err := os . OpenFile ( p , os . O_CREATE | os . O_WRONLY , 0600 ) if err != nil { return err } defer func ( ) { if err = f . Close ( ) ; err != nil { log . Printf ( " " , p , err ) } } ( ) err = json . NewEncoder ( f ) . Encode ( client . Client ) if err != nil { return err } return nil } 
func ( c * Config ) SaveRestClient ( client * tags . RestClient ) error { if ! c . Persist { return nil } p , err := c . restSessionFile ( ) if err != nil { return err } log . Printf ( " " , p ) err = os . MkdirAll ( filepath . Dir ( p ) , 0700 ) if err != nil { return err } err = ioutil . WriteFile ( p , [ ] byte ( client . SessionID ( ) ) , 0600 ) if err != nil { return err } return nil } 
func ( c * Config ) restoreVimClient ( client * vim25 . Client ) ( bool , error ) { if ! c . Persist { return false , nil } p , err := c . vimSessionFile ( ) if err != nil { return false , err } log . Printf ( " " , p ) f , err := os . Open ( p ) if err != nil { if os . IsNotExist ( err ) { log . Printf ( " " , p ) return false , nil } return false , err } defer func ( ) { if err = f . Close ( ) ; err != nil { log . Printf ( " " , p , err ) } } ( ) dec := json . NewDecoder ( f ) err = dec . Decode ( client ) if err != nil { return false , err } return true , nil } 
func ( c * Config ) readRestSessionID ( ) ( string , error ) { if ! c . Persist { return " " , nil } p , err := c . restSessionFile ( ) if err != nil { return " " , err } log . Printf ( " " , p ) id , err := ioutil . ReadFile ( p ) if err != nil { if os . IsNotExist ( err ) { log . Printf ( " " , p ) return " " , nil } return " " , err } return string ( id ) , nil } 
func ( c * Config ) LoadVimClient ( ) ( * govmomi . Client , error ) { client := new ( vim25 . Client ) ok , err := c . restoreVimClient ( client ) if err != nil { return nil , err } if ! ok || ! client . Valid ( ) { log . Println ( " " ) return nil , nil } m := session . NewManager ( client ) u , err := m . UserSession ( context . TODO ( ) ) if err != nil { if soap . IsSoapFault ( err ) { fault := soap . ToSoapFault ( err ) . VimFault ( ) return nil , nil } } return nil , err } return nil , nil } log . Println ( " " ) return & govmomi . Client { Client : client , SessionManager : m , } , nil } 
func ( c * Config ) LoadRestClient ( ctx context . Context , u * url . URL ) ( * tags . RestClient , bool , error ) { id , err := c . readRestSessionID ( ) if err != nil { return nil , false , err } client := tags . NewClientWithSessionID ( u , c . InsecureFlag , " " , id ) if id == " " { log . Println ( " " ) return client , false , nil } if ! client . Valid ( ctx ) { log . Println ( " " ) return client , false , nil } log . Println ( " " ) return client , true , nil } 
func ( c * Config ) SavedVimSessionOrNew ( u * url . URL ) ( * govmomi . Client , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) client , err := c . LoadVimClient ( ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if client == nil { log . Printf ( " " , c . VSphereServer ) client , err = govmomi . NewClient ( ctx , u , c . InsecureFlag ) if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Println ( " " ) } return client , nil } 
func ( c * Config ) SavedRestSessionOrNew ( u * url . URL ) ( * tags . RestClient , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) client , valid , err := c . LoadRestClient ( ctx , u ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if ! valid { log . Printf ( " " , c . VSphereServer ) if err := client . Login ( ctx ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } log . Println ( " " ) } return client , nil } 
func newVirtualMachineCustomizationWaiter ( client * govmomi . Client , vm * object . VirtualMachine , timeout int ) * virtualMachineCustomizationWaiter { w := & virtualMachineCustomizationWaiter { done : make ( chan struct { } ) , } go func ( ) { w . err = w . wait ( client , vm , timeout ) close ( w . done ) } ( ) return w } 
func ( w * virtualMachineCustomizationWaiter ) wait ( client * govmomi . Client , vm * object . VirtualMachine , timeout int ) error { } cb := func ( obj types . ManagedObjectReference , page [ ] types . BaseEvent ) error { for _ , be := range page { switch e := be . ( type ) { case types . BaseCustomizationFailed : cbErr <- errors . New ( e . GetCustomizationFailed ( ) . GetEvent ( ) . FullFormattedMessage ) case * types . CustomizationSucceeded : close ( cbErr ) } } return nil } mgr := event . NewManager ( client . Client ) mgrErr := make ( chan error , 1 ) defer pcancel ( ) go func ( ) { mgrErr <- mgr . Events ( pctx , [ ] types . ManagedObjectReference { vm . Reference ( ) } , 10 , true , false , cb ) } ( ) defer cancel ( ) var err error select { case <- ctx . Done ( ) : if ctx . Err ( ) == context . DeadlineExceeded { err = fmt . Errorf ( " " ) } case err = <- mgrErr : case err = <- cbErr : } return err } 
func selectEventsForReference ( client * govmomi . Client , ref types . ManagedObjectReference , eventTypes [ ] string ) ( [ ] types . BaseEvent , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) filter := types . EventFilterSpec { Entity : & types . EventFilterSpecByEntity { Entity : ref , Recursion : types . EventFilterSpecRecursionOptionAll , } , EventTypeId : eventTypes , } mgr := event . NewManager ( client . Client ) return mgr . QueryEvents ( ctx , filter ) } 
func getDatastore ( f * find . Finder , ds string ) ( * object . Datastore , error ) { if ds != " " { dso , err := f . Datastore ( context . TODO ( ) , ds ) return dso , err } else { dso , err := f . DefaultDatastore ( context . TODO ( ) ) return dso , err } } 
func resourceVSphereVirtualMachineUpdateReconfigureWithSDRS ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , spec types . VirtualMachineConfigSpec , ) error { return virtualmachine . Reconfigure ( vm , spec ) } client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return fmt . Errorf ( " " , err ) } err = storagepod . ReconfigureVM ( client , vm , spec , pod ) if err != nil { return fmt . Errorf ( " " , pod . Name ( ) , err ) } return nil } 
func resourceVSphereVirtualMachineCreateBare ( d * schema . ResourceData , meta interface { } ) ( * object . VirtualMachine , error ) { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient poolID := d . Get ( " " ) . ( string ) pool , err := resourcepool . FromID ( client , poolID ) if err != nil { return nil , fmt . Errorf ( " " , poolID , err ) } if err != nil { return nil , err } var hs * object . HostSystem if v , ok := d . GetOk ( " " ) ; ok { hsID := v . ( string ) var err error if hs , err = hostsystem . FromID ( client , hsID ) ; err != nil { return nil , fmt . Errorf ( " " , hsID , err ) } } } if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , virtualdevice . DeviceListString ( devices ) ) if spec . DeviceChange , err = applyVirtualDevices ( d , client , devices ) ; err != nil { return nil , err } if _ , ok := d . GetOk ( " " ) ; ok { vm , err = resourceVSphereVirtualMachineCreateBareWithSDRS ( d , meta , fo , spec , pool , hs ) } else { vm , err = resourceVSphereVirtualMachineCreateBareStandard ( d , meta , fo , spec , pool , hs ) } if err != nil { return nil , err } if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , vm . InventoryPath , vprops . Config . Uuid ) d . SetId ( vprops . Config . Uuid ) } return vm , nil } 
func resourceVSphereVirtualMachineCreateBareWithSDRS ( d * schema . ResourceData , meta interface { } , fo * object . Folder , spec types . VirtualMachineConfigSpec , pool * object . ResourcePool , hs * object . HostSystem , ) ( * object . VirtualMachine , error ) { client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } vm , err := storagepod . CreateVM ( client , fo , spec , pool , hs , pod ) if err != nil { return nil , fmt . Errorf ( " " , pod . Name ( ) , err ) } return vm , nil } 
func resourceVSphereVirtualMachineCreateBareStandard ( d * schema . ResourceData , meta interface { } , fo * object . Folder , spec types . VirtualMachineConfigSpec , pool * object . ResourcePool , hs * object . HostSystem , ) ( * object . VirtualMachine , error ) { client := meta . ( * VSphereClient ) . vimClient if err != nil { return nil , fmt . Errorf ( " " , err ) } spec . Files = & types . VirtualMachineFileInfo { VmPathName : fmt . Sprintf ( " " , ds . Name ( ) ) , } vm , err := virtualmachine . Create ( client , fo , spec , pool , hs ) if err != nil { return nil , fmt . Errorf ( " " , err ) } return vm , nil } 
func resourceVSphereVirtualMachineCreateClone ( d * schema . ResourceData , meta interface { } ) ( * object . VirtualMachine , error ) { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient pool , err := resourcepool . FromID ( client , poolID ) if err != nil { return nil , fmt . Errorf ( " " , poolID , err ) } fo , err := folder . VirtualMachineFolderFromObject ( client , pool , d . Get ( " " ) . ( string ) ) if err != nil { return nil , err } if err != nil { return nil , err } timeout := d . Get ( " " ) . ( int ) var vm * object . VirtualMachine if _ , ok := d . GetOk ( " " ) ; ok { vm , err = resourceVSphereVirtualMachineCreateCloneWithSDRS ( d , meta , srcVM , fo , name , cloneSpec , timeout ) } else { vm , err = virtualmachine . Clone ( client , srcVM , fo , name , cloneSpec , timeout ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } log . Printf ( " " , vm . InventoryPath , vprops . Config . Uuid ) d . SetId ( vprops . Config . Uuid ) if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } var delta [ ] types . BaseVirtualDeviceConfigSpec if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfgSpec . DeviceChange = virtualdevice . AppendDeviceChangeSpec ( cfgSpec . DeviceChange , delta ... ) if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfgSpec . DeviceChange = virtualdevice . AppendDeviceChangeSpec ( cfgSpec . DeviceChange , delta ... ) if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfgSpec . DeviceChange = virtualdevice . AppendDeviceChangeSpec ( cfgSpec . DeviceChange , delta ... ) if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfgSpec . DeviceChange = virtualdevice . AppendDeviceChangeSpec ( cfgSpec . DeviceChange , delta ... ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceListString ( devices ) ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceChangeString ( cfgSpec . DeviceChange ) ) } else { err = virtualmachine . Reconfigure ( vm , cfgSpec ) } if err != nil { return nil , resourceVSphereVirtualMachineRollbackCreate ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } var cw * virtualMachineCustomizationWaiter if err != nil { return nil , fmt . Errorf ( " " , d . Get ( " " ) . ( string ) , err ) } custSpec := vmworkflow . ExpandCustomizationSpec ( d , family ) cw = newVirtualMachineCustomizationWaiter ( client , vm , d . Get ( " " ) . ( int ) ) if err := virtualmachine . Customize ( vm , custSpec ) ; err != nil { } d . SetId ( " " ) return nil , fmt . Errorf ( " " , err ) } } } <- cw . Done ( ) if err := cw . Err ( ) ; err != nil { return nil , fmt . Errorf ( formatVirtualMachineCustomizationWaitError , vm . InventoryPath , err ) } } } 
func resourceVSphereVirtualMachineCreateCloneWithSDRS ( d * schema . ResourceData , meta interface { } , srcVM * object . VirtualMachine , fo * object . Folder , name string , spec types . VirtualMachineCloneSpec , timeout int , ) ( * object . VirtualMachine , error ) { client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } vm , err := storagepod . CloneVM ( client , srcVM , fo , name , spec , timeout , pod ) if err != nil { return nil , fmt . Errorf ( " " , pod . Name ( ) , err ) } return vm , nil } 
func resourceVSphereVirtualMachineRollbackCreate ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , origErr error , ) error { defer d . SetId ( " " ) } return fmt . Errorf ( " " , origErr ) } 
func resourceVSphereVirtualMachineUpdateLocation ( d * schema . ResourceData , meta interface { } ) error { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient vm , err := virtualmachine . FromUUID ( client , id ) if err != nil { return fmt . Errorf ( " " , id , err ) } if err != nil { return fmt . Errorf ( " " , err ) } devices := object . VirtualDeviceList ( vprops . Config . Hardware . Device ) relocators , diskRelocateOK , err := virtualdevice . DiskMigrateRelocateOperation ( d , client , devices ) if err != nil { return err } return nil } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) pool , err := resourcepool . FromID ( client , poolID ) if err != nil { return fmt . Errorf ( " " , poolID , err ) } var hs * object . HostSystem if v , ok := d . GetOk ( " " ) ; ok { hsID := v . ( string ) var err error if hs , err = hostsystem . FromID ( client , hsID ) ; err != nil { return fmt . Errorf ( " " , hsID , err ) } } if err := resourcepool . ValidateHost ( client , pool , hs ) ; err != nil { return err } if err != nil { return fmt . Errorf ( " " , err ) } spec . Datastore = types . NewReference ( ds . Reference ( ) ) } if hs != nil { hsRef := hs . Reference ( ) spec . Host = & hsRef } spec . Disk = relocators if _ , ok := d . GetOk ( " " ) ; ok { err = resourceVSphereVirtualMachineUpdateLocationRelocateWithSDRS ( d , meta , vm , spec , timeout ) } else { err = virtualmachine . Relocate ( vm , spec , timeout ) } return err } 
func resourceVSphereVirtualMachineUpdateLocationRelocateWithSDRS ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , spec types . VirtualMachineRelocateSpec , timeout int , ) error { client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) pod , err := storagepod . FromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return fmt . Errorf ( " " , err ) } err = storagepod . RelocateVM ( client , vm , spec , timeout , pod ) if err != nil { return fmt . Errorf ( " " , pod . Name ( ) , err ) } return nil } 
func applyVirtualDevices ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { var err error if err != nil { return nil , err } if len ( delta ) > 0 { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) d . Set ( " " , true ) } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) if err != nil { return nil , err } spec = virtualdevice . AppendDeviceChangeSpec ( spec , delta ... ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceListString ( l ) ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , virtualdevice . DeviceChangeString ( spec ) ) return spec , nil } 
func expandClusterDpmHostConfigInfo ( d * schema . ResourceData , host * object . HostSystem ) ( * types . ClusterDpmHostConfigInfo , error ) { obj := & types . ClusterDpmHostConfigInfo { Behavior : types . DpmBehavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . GetBool ( d , " " ) , Key : host . Reference ( ) , } return obj , nil } 
func flattenClusterDpmHostConfigInfo ( d * schema . ResourceData , obj * types . ClusterDpmHostConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , } ) } 
func resourceVSphereDPMHostOverrideFlattenID ( cluster * object . ClusterComputeResource , host * object . HostSystem ) ( string , error ) { return strings . Join ( [ ] string { cluster . Reference ( ) . Value , host . Reference ( ) . Value } , " " ) , nil } 
func resourceVSphereDPMHostOverrideFindEntry ( cluster * object . ClusterComputeResource , host * object . HostSystem , ) ( * types . ClusterDpmHostConfigInfo , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . DpmHostConfig { if info . Key == host . Reference ( ) { log . Printf ( " " , host . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , host . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resourceVSphereDPMHostOverrideObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , * object . HostSystem , error ) { if d . Id ( ) != " " { return resourceVSphereDPMHostOverrideObjectsFromID ( d , meta ) } return resourceVSphereDPMHostOverrideObjectsFromAttributes ( d , meta ) } 
func resourceVSphereVirtualDisk ( ) * schema . Resource { return & schema . Resource { Create : resourceVSphereVirtualDiskCreate , Read : resourceVSphereVirtualDiskRead , Delete : resourceVSphereVirtualDiskDelete , Schema : map [ string ] * schema . Schema { if value != " " && value != " " && value != " " { errors = append ( errors , fmt . Errorf ( " " ) ) } return } , } , " " : { Type : schema . TypeString , Optional : true , ForceNew : true , Default : " " , if value != " " && value != " " && value != " " { errors = append ( errors , fmt . Errorf ( " " ) ) } return } , } , " " : { Type : schema . TypeString , Optional : true , ForceNew : true , } , " " : { Type : schema . TypeBool , Optional : true , ForceNew : true , } , } , } } 
func createHardDisk ( client * govmomi . Client , size int , diskPath string , diskType string , adapterType string , dc string ) error { var vDiskType string switch diskType { case " " : vDiskType = " " case " " : vDiskType = " " case " " : vDiskType = " " } virtualDiskManager := object . NewVirtualDiskManager ( client . Client ) spec := & types . FileBackedVirtualDiskSpec { VirtualDiskSpec : types . VirtualDiskSpec { AdapterType : adapterType , DiskType : vDiskType , } , CapacityKb : int64 ( 1024 * 1024 * size ) , } datacenter , err := getDatacenter ( client , dc ) if err != nil { return err } log . Printf ( " " , spec ) task , err := virtualDiskManager . CreateVirtualDisk ( context . TODO ( ) , diskPath , datacenter , spec ) if err != nil { return err } _ , err = task . WaitForResult ( context . TODO ( ) , nil ) if err != nil { log . Printf ( " " , err ) return err } log . Printf ( " " ) return nil } 
func searchForDirectory ( client * govmomi . Client , datacenter string , datastore string , directoryPath string ) error { log . Printf ( " " ) finder := find . NewFinder ( client . Client , true ) dc , err := getDatacenter ( client , datacenter ) if err != nil { return fmt . Errorf ( " " , datacenter , err ) } finder = finder . SetDatacenter ( dc ) ds , err := finder . Datastore ( context . TODO ( ) , datastore ) if err != nil { return fmt . Errorf ( " " , datastore , err ) } ctx := context . TODO ( ) b , err := ds . Browser ( ctx ) if err != nil { return err } spec := types . HostDatastoreBrowserSearchSpec { Query : [ ] types . BaseFileQuery { & types . FolderFileQuery { } } , Details : & types . FileQueryFlags { FileSize : true , FileType : true , Modification : true , FileOwner : types . NewBool ( true ) , } , MatchPattern : [ ] string { path . Base ( directoryPath ) } , } dsPath := ds . Path ( path . Dir ( directoryPath ) ) task , err := b . SearchDatastore ( context . TODO ( ) , dsPath , & spec ) if err != nil { log . Printf ( " " , directoryPath ) return err } info , err := task . WaitForResult ( context . TODO ( ) , nil ) if err != nil { if info == nil || info . Error != nil { _ , ok := info . Error . Fault . ( * types . FileNotFound ) if ok { log . Printf ( " " , directoryPath ) return nil } } log . Printf ( " " , directoryPath ) return err } res := info . Result . ( types . HostDatastoreBrowserSearchResults ) log . Printf ( " " , len ( res . File ) ) if len ( res . File ) == 0 { log . Printf ( " " , directoryPath ) return nil } if len ( res . File ) != 1 { return errors . New ( " " ) } fileInfo := res . File [ 0 ] log . Printf ( " " , fileInfo ) return nil } 
func ( p * nasDatastoreMountProcessor ) diffOldNew ( ) [ ] string { return p . diff ( p . oldHSIDs , p . newHSIDs ) } 
func ( p * nasDatastoreMountProcessor ) diffNewOld ( ) [ ] string { return p . diff ( p . newHSIDs , p . oldHSIDs ) } 
func ( p * nasDatastoreMountProcessor ) processMountOperations ( ) ( * object . Datastore , error ) { hosts := p . diffNewOld ( ) if len ( hosts ) < 1 { } } } for _ , hsID := range hosts { dss , err := hostDatastoreSystemFromHostSystemID ( p . client , hsID ) if err != nil { return p . ds , fmt . Errorf ( " " , hostsystem . NameOrID ( p . client , hsID ) , err ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ds , err := dss . CreateNasDatastore ( ctx , * p . volSpec ) if err != nil { return p . ds , fmt . Errorf ( " " , hostsystem . NameOrID ( p . client , hsID ) , err ) } if err := p . validateDatastore ( ds ) ; err != nil { return p . ds , fmt . Errorf ( " " , hostsystem . NameOrID ( p . client , hsID ) , err ) } } return p . ds , nil } 
func ( p * nasDatastoreMountProcessor ) processUnmountOperations ( ) error { hosts := p . diffOldNew ( ) if len ( hosts ) < 1 || p . ds == nil { } for _ , hsID := range hosts { dss , err := hostDatastoreSystemFromHostSystemID ( p . client , hsID ) if err != nil { return fmt . Errorf ( " " , hostsystem . NameOrID ( p . client , hsID ) , err ) } if err := removeDatastore ( dss , p . ds ) ; err != nil { return fmt . Errorf ( " " , hostsystem . NameOrID ( p . client , hsID ) , err ) } } return nil } 
func ( p * nasDatastoreMountProcessor ) validateDatastore ( ds * object . Datastore ) error { if p . ds == nil { p . ds = ds return nil } expected := p . ds . Reference ( ) . Value actual := ds . Reference ( ) . Value if expected != actual { return fmt . Errorf ( " " , expected , actual ) } return nil } 
func isEligibleTagEndpoint ( client * govmomi . Client ) bool { if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return false } clientVer := viapi . ParseVersionFromClient ( client ) if ! clientVer . ProductEqual ( tagsMinVersion ) || clientVer . Older ( tagsMinVersion ) { return false } return true } 
func tagCategoryByName ( client * tags . RestClient , name string ) ( string , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) cats , err := client . GetCategoriesByName ( ctx , name ) if err != nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( cats ) < 1 { return " " , fmt . Errorf ( " " , name ) } if len ( cats ) > 1 { } return cats [ 0 ] . ID , nil } 
func tagByName ( client * tags . RestClient , name , categoryID string ) ( string , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) tags , err := client . GetTagByNameForCategory ( ctx , name , categoryID ) if err != nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( tags ) < 1 { return " " , fmt . Errorf ( " " , name , categoryID ) } if len ( tags ) > 1 { } return tags [ 0 ] . ID , nil } 
func tagsSchema ( ) * schema . Schema { return & schema . Schema { Type : schema . TypeSet , Description : " " , Optional : true , Elem : & schema . Schema { Type : schema . TypeString } , } } 
func tagTypeForObject ( obj object . Reference ) ( string , error ) { switch obj . ( type ) { case * object . VirtualMachine : return vSphereTagTypeVirtualMachine , nil case * object . Datastore : return vSphereTagTypeDatastore , nil case * object . Network : return vSphereTagTypeNetwork , nil case * object . Folder : return vSphereTagTypeFolder , nil case * object . VmwareDistributedVirtualSwitch : return vSphereTagTypeVmwareDistributedVirtualSwitch , nil case * object . DistributedVirtualSwitch : return vSphereTagTypeDistributedVirtualSwitch , nil case * object . DistributedVirtualPortgroup : return vSphereTagTypeDistributedVirtualPortgroup , nil case * object . Datacenter : return vSphereTagTypeDatacenter , nil case * object . ClusterComputeResource : return vSphereTagTypeClusterComputeResource , nil case * object . HostSystem : return vSphereTagTypeHostSystem , nil case * object . StoragePod : return vSphereTagTypeStoragePod , nil case * object . ResourcePool : return vSphereTagTypeResourcePool , nil case * object . VirtualApp : return vSphereTagTypeVirtualApp , nil } return " " , fmt . Errorf ( " " , obj ) } 
func readTagsForResource ( client * tags . RestClient , obj object . Reference , d * schema . ResourceData ) error { log . Printf ( " " , obj . Reference ( ) . Value ) objID := obj . Reference ( ) . Value objType , err := tagTypeForObject ( obj ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ids , err := client . ListAttachedTags ( ctx , objID , objType ) log . Printf ( " " , objID , strings . Join ( ids , " " ) ) if err != nil { return err } if err := d . Set ( vSphereTagAttributeKey , ids ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * tagDiffProcessor ) diffOldNew ( ) [ ] string { return p . diff ( p . oldTagIDs , p . newTagIDs ) } 
func ( p * tagDiffProcessor ) diffNewOld ( ) [ ] string { return p . diff ( p . newTagIDs , p . oldTagIDs ) } 
func ( p * tagDiffProcessor ) diff ( a , b [ ] string ) [ ] string { var found bool c := make ( [ ] string , 0 ) for _ , v1 := range a { for _ , v2 := range b { if v1 == v2 { found = true } } if ! found { c = append ( c , v1 ) } found = false } return c } 
func ( p * tagDiffProcessor ) processAttachOperations ( ) error { tagIDs := p . diffNewOld ( ) if len ( tagIDs ) < 1 { } for _ , tagID := range tagIDs { objID := p . subject . Reference ( ) . Value objType , err := tagTypeForObject ( p . subject ) if err != nil { return err } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) log . Printf ( " " , tagID , objID ) if err := p . client . AttachTagToObject ( ctx , tagID , objID , objType ) ; err != nil { return err } } return nil } 
func tagsClientIfDefined ( d * schema . ResourceData , meta interface { } ) ( * tags . RestClient , error ) { old , new := d . GetChange ( vSphereTagAttributeKey ) if len ( old . ( * schema . Set ) . List ( ) ) > 0 || len ( new . ( * schema . Set ) . List ( ) ) > 0 { log . Printf ( " " ) client , err := meta . ( * VSphereClient ) . TagsClient ( ) if err != nil { return nil , err } return client , nil } log . Printf ( " " ) return nil , nil } 
func processTagDiff ( client * tags . RestClient , d * schema . ResourceData , obj object . Reference ) error { log . Printf ( " " , obj . Reference ( ) . Value ) old , new := d . GetChange ( vSphereTagAttributeKey ) tdp := & tagDiffProcessor { client : client , subject : obj , oldTagIDs : structure . SliceInterfacesToStrings ( old . ( * schema . Set ) . List ( ) ) , newTagIDs : structure . SliceInterfacesToStrings ( new . ( * schema . Set ) . List ( ) ) , } if err := tdp . processDetachOperations ( ) ; err != nil { return fmt . Errorf ( " " , obj . Reference ( ) . Value , err ) } if err := tdp . processAttachOperations ( ) ; err != nil { return fmt . Errorf ( " " , obj . Reference ( ) . Value , err ) } return nil } 
func schemaVMwareDVSConfigSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaVMwareDVSPortSetting ( ) ) structure . MergeSchema ( s , schemaDvsHostInfrastructureTrafficResource ( ) ) return s } 
func expandDVSContactInfo ( d * schema . ResourceData ) * types . DVSContactInfo { obj := & types . DVSContactInfo { Name : d . Get ( " " ) . ( string ) , Contact : d . Get ( " " ) . ( string ) , } return obj } 
func flattenDVSContactInfo ( d * schema . ResourceData , obj types . DVSContactInfo ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . Contact ) return nil } 
func expandDistributedVirtualSwitchHostMemberConfigSpec ( d map [ string ] interface { } ) types . DistributedVirtualSwitchHostMemberConfigSpec { hostRef := & types . ManagedObjectReference { Type : " " , Value : d [ " " ] . ( string ) , } var pnSpecs [ ] types . DistributedVirtualSwitchHostMemberPnicSpec nics := structure . SliceInterfacesToStrings ( d [ " " ] . ( [ ] interface { } ) ) for _ , nic := range nics { pnSpec := types . DistributedVirtualSwitchHostMemberPnicSpec { PnicDevice : nic , } pnSpecs = append ( pnSpecs , pnSpec ) } backing := types . DistributedVirtualSwitchHostMemberPnicBacking { PnicSpec : pnSpecs , } obj := types . DistributedVirtualSwitchHostMemberConfigSpec { Host : * hostRef , Backing : & backing , } return obj } 
func flattenDistributedVirtualSwitchHostMember ( obj types . DistributedVirtualSwitchHostMember ) map [ string ] interface { } { d := make ( map [ string ] interface { } ) d [ " " ] = obj . Config . Host . Value var devices [ ] string backing := obj . Config . Backing . ( * types . DistributedVirtualSwitchHostMemberPnicBacking ) for _ , spec := range backing . PnicSpec { devices = append ( devices , spec . PnicDevice ) } d [ " " ] = devices return d } 
func expandSliceOfDistributedVirtualSwitchHostMemberConfigSpec ( d * schema . ResourceData ) [ ] types . DistributedVirtualSwitchHostMemberConfigSpec { var specs [ ] types . DistributedVirtualSwitchHostMemberConfigSpec o , n := d . GetChange ( " " ) os := o . ( * schema . Set ) ns := n . ( * schema . Set ) os = os . Difference ( is ) ns = ns . Difference ( is ) var found bool for _ , ne := range ns . List ( ) { nm := ne . ( map [ string ] interface { } ) if nm [ " " ] == om [ " " ] { found = true } } if ! found { spec := expandDistributedVirtualSwitchHostMemberConfigSpec ( om ) spec . Operation = string ( types . ConfigSpecOperationRemove ) specs = append ( specs , spec ) } } var found bool for _ , oe := range os . List ( ) { om := oe . ( map [ string ] interface { } ) if om [ " " ] == nm [ " " ] { found = true } } spec := expandDistributedVirtualSwitchHostMemberConfigSpec ( nm ) if ! found { spec . Operation = string ( types . ConfigSpecOperationAdd ) } else { spec . Operation = string ( types . ConfigSpecOperationEdit ) } specs = append ( specs , spec ) } } 
func flattenSliceOfDistributedVirtualSwitchHostMember ( d * schema . ResourceData , members [ ] types . DistributedVirtualSwitchHostMember ) error { var hosts [ ] map [ string ] interface { } for _ , m := range members { hosts = append ( hosts , flattenDistributedVirtualSwitchHostMember ( m ) ) } if err := d . Set ( " " , hosts ) ; err != nil { return err } return nil } 
func expandVMwareIpfixConfig ( d * schema . ResourceData ) * types . VMwareIpfixConfig { obj := & types . VMwareIpfixConfig { ActiveFlowTimeout : int32 ( d . Get ( " " ) . ( int ) ) , CollectorIpAddress : d . Get ( " " ) . ( string ) , CollectorPort : int32 ( d . Get ( " " ) . ( int ) ) , IdleFlowTimeout : int32 ( d . Get ( " " ) . ( int ) ) , InternalFlowsOnly : d . Get ( " " ) . ( bool ) , ObservationDomainId : int64 ( d . Get ( " " ) . ( int ) ) , SamplingRate : int32 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flattenVMwareIpfixConfig ( d * schema . ResourceData , obj * types . VMwareIpfixConfig ) error { d . Set ( " " , obj . ActiveFlowTimeout ) d . Set ( " " , obj . CollectorIpAddress ) d . Set ( " " , obj . CollectorPort ) d . Set ( " " , obj . IdleFlowTimeout ) d . Set ( " " , obj . InternalFlowsOnly ) d . Set ( " " , obj . ObservationDomainId ) d . Set ( " " , obj . SamplingRate ) return nil } 
func schemaDvsHostInfrastructureTrafficResource ( ) map [ string ] * schema . Schema { s := make ( map [ string ] * schema . Schema ) shareLevelFmt := " " shareCountFmt := " " maxMbitFmt := " " resMbitFmt := " " for _ , class := range infrastructureTrafficClassValues { shareLevelKey := fmt . Sprintf ( " " , strings . ToLower ( class ) ) shareCountKey := fmt . Sprintf ( " " , strings . ToLower ( class ) ) maxMbitKey := fmt . Sprintf ( " " , strings . ToLower ( class ) ) resMbitKey := fmt . Sprintf ( " " , strings . ToLower ( class ) ) s [ shareLevelKey ] = & schema . Schema { Type : schema . TypeString , Optional : true , Computed : true , Description : fmt . Sprintf ( shareLevelFmt , class ) , ValidateFunc : validation . StringInSlice ( sharesLevelAllowedValues , false ) , } s [ shareCountKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Computed : true , Description : fmt . Sprintf ( shareCountFmt , class ) , ValidateFunc : validation . IntAtLeast ( 0 ) , } s [ maxMbitKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Computed : true , Description : fmt . Sprintf ( maxMbitFmt , class ) , ValidateFunc : validation . IntAtLeast ( - 1 ) , } s [ resMbitKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Computed : true , Description : fmt . Sprintf ( resMbitFmt , class ) , ValidateFunc : validation . IntAtLeast ( - 1 ) , } } return s } 
func expandDvsHostInfrastructureTrafficResource ( d * schema . ResourceData , key string ) * types . DvsHostInfrastructureTrafficResource { shareLevelKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) shareCountKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) maxMbitKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) resMbitKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) obj := & types . DvsHostInfrastructureTrafficResource { AllocationInfo : types . DvsHostInfrastructureTrafficResourceAllocation { Limit : structure . GetInt64Ptr ( d , maxMbitKey ) , Reservation : structure . GetInt64Ptr ( d , resMbitKey ) , } , } shares := & types . SharesInfo { Level : types . SharesLevel ( d . Get ( shareLevelKey ) . ( string ) ) , Shares : int32 ( d . Get ( shareCountKey ) . ( int ) ) , } if ! structure . AllFieldsEmpty ( shares ) { obj . AllocationInfo . Shares = shares } if structure . AllFieldsEmpty ( obj ) { return nil } obj . Key = key return obj } 
func flattenDvsHostInfrastructureTrafficResource ( d * schema . ResourceData , obj types . DvsHostInfrastructureTrafficResource , key string ) error { shareLevelKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) shareCountKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) maxMbitKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) resMbitKey := fmt . Sprintf ( " " , strings . ToLower ( key ) ) structure . SetInt64Ptr ( d , maxMbitKey , obj . AllocationInfo . Limit ) structure . SetInt64Ptr ( d , resMbitKey , obj . AllocationInfo . Reservation ) if obj . AllocationInfo . Shares != nil { d . Set ( shareLevelKey , obj . AllocationInfo . Shares . Level ) d . Set ( shareCountKey , obj . AllocationInfo . Shares . Shares ) } return nil } 
func expandSliceOfDvsHostInfrastructureTrafficResource ( d * schema . ResourceData ) [ ] types . DvsHostInfrastructureTrafficResource { var s [ ] types . DvsHostInfrastructureTrafficResource for _ , key := range infrastructureTrafficClassValues { v := expandDvsHostInfrastructureTrafficResource ( d , key ) if v != nil { s = append ( s , * v ) } } return s } 
func flattenSliceOfDvsHostInfrastructureTrafficResource ( d * schema . ResourceData , s [ ] types . DvsHostInfrastructureTrafficResource ) error { for _ , v := range s { if err := flattenDvsHostInfrastructureTrafficResource ( d , v , v . Key ) ; err != nil { return err } } return nil } 
func expandDVSNameArrayUplinkPortPolicy ( d * schema . ResourceData ) * types . DVSNameArrayUplinkPortPolicy { obj := & types . DVSNameArrayUplinkPortPolicy { UplinkPortName : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenDVSNameArrayUplinkPortPolicy ( d * schema . ResourceData , obj * types . DVSNameArrayUplinkPortPolicy ) error { if err := d . Set ( " " , obj . UplinkPortName ) ; err != nil { return err } return nil } 
func expandVMwareDVSConfigSpec ( d * schema . ResourceData ) * types . VMwareDVSConfigSpec { obj := & types . VMwareDVSConfigSpec { DVSConfigSpec : types . DVSConfigSpec { Name : d . Get ( " " ) . ( string ) , ConfigVersion : d . Get ( " " ) . ( string ) , DefaultPortConfig : expandVMwareDVSPortSetting ( d ) , Host : expandSliceOfDistributedVirtualSwitchHostMemberConfigSpec ( d ) , Description : d . Get ( " " ) . ( string ) , Contact : expandDVSContactInfo ( d ) , SwitchIpAddress : d . Get ( " " ) . ( string ) , InfrastructureTrafficResourceConfig : expandSliceOfDvsHostInfrastructureTrafficResource ( d ) , NetworkResourceControlVersion : d . Get ( " " ) . ( string ) , UplinkPortPolicy : expandDVSNameArrayUplinkPortPolicy ( d ) , } , MaxMtu : int32 ( d . Get ( " " ) . ( int ) ) , LinkDiscoveryProtocolConfig : expandLinkDiscoveryProtocolConfig ( d ) , IpfixConfig : expandVMwareIpfixConfig ( d ) , LacpApiVersion : d . Get ( " " ) . ( string ) , MulticastFilteringMode : d . Get ( " " ) . ( string ) , } return obj } 
func flattenVMwareDVSConfigInfo ( d * schema . ResourceData , obj * types . VMwareDVSConfigInfo ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . ConfigVersion ) d . Set ( " " , obj . Description ) d . Set ( " " , obj . SwitchIpAddress ) d . Set ( " " , obj . MaxMtu ) d . Set ( " " , obj . LacpApiVersion ) d . Set ( " " , obj . MulticastFilteringMode ) d . Set ( " " , obj . NetworkResourceControlVersion ) if err := flattenDVSNameArrayUplinkPortPolicy ( d , obj . UplinkPortPolicy . ( * types . DVSNameArrayUplinkPortPolicy ) ) ; err != nil { return err } if err := flattenVMwareDVSPortSetting ( d , obj . DefaultPortConfig . ( * types . VMwareDVSPortSetting ) ) ; err != nil { return err } if err := flattenSliceOfDistributedVirtualSwitchHostMember ( d , obj . Host ) ; err != nil { return err } if err := flattenSliceOfDvsHostInfrastructureTrafficResource ( d , obj . InfrastructureTrafficResourceConfig ) ; err != nil { return err } if err := flattenDVSContactInfo ( d , obj . Contact ) ; err != nil { return err } if err := flattenLinkDiscoveryProtocolConfig ( d , obj . LinkDiscoveryProtocolConfig ) ; err != nil { return err } if err := flattenVMwareIpfixConfig ( d , obj . IpfixConfig ) ; err != nil { return err } return nil } 
func schemaDVSCreateSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaVMwareDVSConfigSpec ( ) ) return s } 
func expandDVSCreateSpec ( d * schema . ResourceData ) types . DVSCreateSpec { return obj } 
func getWithRestart ( d * schema . ResourceData , key string ) interface { } { if d . HasChange ( key ) { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , key ) d . Set ( " " , true ) } return d . Get ( key ) } 
func getBoolWithRestart ( d * schema . ResourceData , key string ) * bool { if d . HasChange ( key ) { d . Set ( " " , true ) } return structure . GetBool ( d , key ) } 
func schemaVirtualMachineConfigSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaVirtualMachineResourceAllocation ( ) ) return s } 
func vAppSubresourceSchema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . TypeMap , Optional : true , Description : " " , Elem : & schema . Schema { Type : schema . TypeString } , } , } } 
func expandVirtualMachineBootOptions ( d * schema . ResourceData , client * govmomi . Client ) * types . VirtualMachineBootOptions { obj := & types . VirtualMachineBootOptions { BootDelay : int64 ( d . Get ( " " ) . ( int ) ) , BootRetryEnabled : structure . GetBool ( d , " " ) , BootRetryDelay : int64 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . EfiSecureBootEnabled = getBoolWithRestart ( d , " " ) } return obj } 
func flattenVirtualMachineBootOptions ( d * schema . ResourceData , obj * types . VirtualMachineBootOptions ) error { d . Set ( " " , obj . BootDelay ) structure . SetBoolPtr ( d , " " , obj . EfiSecureBootEnabled ) structure . SetBoolPtr ( d , " " , obj . BootRetryEnabled ) d . Set ( " " , obj . BootRetryDelay ) return nil } 
func expandVirtualMachineFlagInfo ( d * schema . ResourceData ) * types . VirtualMachineFlagInfo { obj := & types . VirtualMachineFlagInfo { DiskUuidEnabled : getBoolWithRestart ( d , " " ) , VirtualExecUsage : getWithRestart ( d , " " ) . ( string ) , VirtualMmuUsage : getWithRestart ( d , " " ) . ( string ) , EnableLogging : getBoolWithRestart ( d , " " ) , } return obj } 
func flattenVirtualMachineFlagInfo ( d * schema . ResourceData , obj * types . VirtualMachineFlagInfo ) error { d . Set ( " " , obj . DiskUuidEnabled ) d . Set ( " " , obj . VirtualExecUsage ) d . Set ( " " , obj . VirtualMmuUsage ) d . Set ( " " , obj . EnableLogging ) return nil } 
func expandToolsConfigInfo ( d * schema . ResourceData ) * types . ToolsConfigInfo { obj := & types . ToolsConfigInfo { SyncTimeWithHost : structure . GetBool ( d , " " ) , AfterPowerOn : getBoolWithRestart ( d , " " ) , AfterResume : getBoolWithRestart ( d , " " ) , BeforeGuestStandby : getBoolWithRestart ( d , " " ) , BeforeGuestShutdown : getBoolWithRestart ( d , " " ) , BeforeGuestReboot : getBoolWithRestart ( d , " " ) , } return obj } 
func flattenToolsConfigInfo ( d * schema . ResourceData , obj * types . ToolsConfigInfo ) error { d . Set ( " " , obj . SyncTimeWithHost ) d . Set ( " " , obj . AfterPowerOn ) d . Set ( " " , obj . AfterResume ) d . Set ( " " , obj . BeforeGuestStandby ) d . Set ( " " , obj . BeforeGuestShutdown ) d . Set ( " " , obj . BeforeGuestReboot ) return nil } 
func schemaVirtualMachineResourceAllocation ( ) map [ string ] * schema . Schema { s := make ( map [ string ] * schema . Schema ) shareLevelFmt := " " shareCountFmt := " " limitFmt := " " reservationFmt := " " for _ , t := range virtualMachineResourceAllocationTypeValues { shareLevelKey := fmt . Sprintf ( " " , t ) shareCountKey := fmt . Sprintf ( " " , t ) limitKey := fmt . Sprintf ( " " , t ) reservationKey := fmt . Sprintf ( " " , t ) s [ shareLevelKey ] = & schema . Schema { Type : schema . TypeString , Optional : true , Default : string ( types . SharesLevelNormal ) , Description : fmt . Sprintf ( shareLevelFmt , t ) , ValidateFunc : validation . StringInSlice ( sharesLevelAllowedValues , false ) , } s [ shareCountKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Computed : true , Description : fmt . Sprintf ( shareCountFmt , t ) , ValidateFunc : validation . IntAtLeast ( 0 ) , } s [ limitKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Default : - 1 , Description : fmt . Sprintf ( limitFmt , t ) , ValidateFunc : validation . IntAtLeast ( - 1 ) , } s [ reservationKey ] = & schema . Schema { Type : schema . TypeInt , Optional : true , Description : fmt . Sprintf ( reservationFmt , t ) , ValidateFunc : validation . IntAtLeast ( 0 ) , } } return s } 
func expandVirtualMachineResourceAllocation ( d * schema . ResourceData , key string ) * types . ResourceAllocationInfo { shareLevelKey := fmt . Sprintf ( " " , key ) shareCountKey := fmt . Sprintf ( " " , key ) limitKey := fmt . Sprintf ( " " , key ) reservationKey := fmt . Sprintf ( " " , key ) obj := & types . ResourceAllocationInfo { Limit : structure . GetInt64PtrEmptyZero ( d , limitKey ) , Reservation : structure . GetInt64PtrEmptyZero ( d , reservationKey ) , } shares := & types . SharesInfo { Level : types . SharesLevel ( d . Get ( shareLevelKey ) . ( string ) ) , Shares : int32 ( d . Get ( shareCountKey ) . ( int ) ) , } obj . Shares = shares return obj } 
func expandLatencySensitivity ( d * schema . ResourceData ) * types . LatencySensitivity { obj := & types . LatencySensitivity { Level : types . LatencySensitivitySensitivityLevel ( d . Get ( " " ) . ( string ) ) , } return obj } 
func flattenLatencySensitivity ( d * schema . ResourceData , obj * types . LatencySensitivity ) error { if obj == nil { log . Printf ( " " ) return nil } return d . Set ( " " , obj . Level ) } 
func flattenVirtualMachineResourceAllocation ( d * schema . ResourceData , obj * types . ResourceAllocationInfo , key string ) error { shareLevelKey := fmt . Sprintf ( " " , key ) shareCountKey := fmt . Sprintf ( " " , key ) limitKey := fmt . Sprintf ( " " , key ) reservationKey := fmt . Sprintf ( " " , key ) structure . SetInt64Ptr ( d , limitKey , obj . Limit ) structure . SetInt64Ptr ( d , reservationKey , obj . Reservation ) if obj . Shares != nil { d . Set ( shareLevelKey , obj . Shares . Level ) d . Set ( shareCountKey , obj . Shares . Shares ) } return nil } 
func expandExtraConfig ( d * schema . ResourceData ) [ ] types . BaseOptionValue { if d . HasChange ( " " ) { } else { } var opts [ ] types . BaseOptionValue for k1 := range old . ( map [ string ] interface { } ) { var found bool for k2 := range new . ( map [ string ] interface { } ) { if k1 == k2 { found = true } } if ! found { ov := & types . OptionValue { Key : k1 , Value : " " , } opts = append ( opts , ov ) } } for k2 , v2 := range old . ( map [ string ] interface { } ) { if k1 == k2 { found = true if v1 != v2 { opts = append ( opts , ov ) } } } if ! found { opts = append ( opts , ov ) } } } 
func flattenExtraConfig ( d * schema . ResourceData , opts [ ] types . BaseOptionValue ) error { if len ( opts ) < 1 { } ec := make ( map [ string ] interface { } ) for _ , v := range opts { ov := v . GetOptionValue ( ) for k := range d . Get ( " " ) . ( map [ string ] interface { } ) { if ov . Key == k { ec [ ov . Key ] = ov . Value } } } return d . Set ( " " , ec ) } 
func expandVAppConfig ( d * schema . ResourceData , client * govmomi . Client ) ( * types . VmConfigSpec , error ) { if ! d . HasChange ( " " ) { return nil , nil } var props [ ] types . VAppPropertySpec _ , new := d . GetChange ( " " ) newMap := make ( map [ string ] interface { } ) newVApps := new . ( [ ] interface { } ) if newVApps != nil && len ( newVApps ) > 0 && newVApps [ 0 ] != nil { newVApp := newVApps [ 0 ] . ( map [ string ] interface { } ) if props , ok := newVApp [ " " ] . ( map [ string ] interface { } ) ; ok { newMap = props } } uuid := d . Id ( ) if uuid == " " { } return nil , nil } vm , _ := virtualmachine . FromUUID ( client , d . Id ( ) ) vmProps , _ := virtualmachine . Properties ( vm ) if vmProps . Config . VAppConfig == nil { return nil , fmt . Errorf ( " " ) } allProperties := vmProps . Config . VAppConfig . GetVmConfigInfo ( ) . Property for _ , p := range allProperties { defaultValue := " " if p . DefaultValue != " " { defaultValue = p . DefaultValue } prop := types . VAppPropertySpec { ArrayUpdateSpec : types . ArrayUpdateSpec { Operation : types . ArrayUpdateOperationEdit , } , Info : & types . VAppPropertyInfo { Key : p . Key , Id : p . Id , Value : defaultValue , } , } newValue , ok := newMap [ p . Id ] if ok { prop . Info . Value = newValue . ( string ) delete ( newMap , p . Id ) } props = append ( props , prop ) } if len ( newMap ) > 0 { return nil , fmt . Errorf ( " " , reflect . ValueOf ( newMap ) . MapKeys ( ) ) } return & types . VmConfigSpec { Property : props , } , nil } 
func flattenVAppConfig ( d * schema . ResourceData , config types . BaseVmConfigInfo ) error { if config == nil { d . Set ( " " , [ ] string { } ) return nil } props := config . GetVmConfigInfo ( ) . Property if len ( props ) < 1 { } vac := make ( map [ string ] interface { } ) for _ , v := range props { if v . Value != " " && v . Value != v . DefaultValue { vac [ v . Id ] = v . Value } } } return nil } 
func expandCPUCountConfig ( d * schema . ResourceData ) int32 { occ , ncc := d . GetChange ( " " ) cha , _ := d . GetChange ( " " ) currentHotAdd := cha . ( bool ) chr , _ := d . GetChange ( " " ) currentHotRemove := chr . ( bool ) oldCPUCount := int32 ( occ . ( int ) ) newCPUCount := int32 ( ncc . ( int ) ) switch { case oldCPUCount < newCPUCount : d . Set ( " " , true ) } case oldCPUCount > newCPUCount : d . Set ( " " , true ) } } return newCPUCount } 
func expandMemorySizeConfig ( d * schema . ResourceData ) int64 { om , nm := d . GetChange ( " " ) cha , _ := d . GetChange ( " " ) currentHotAdd := cha . ( bool ) oldMem := int64 ( om . ( int ) ) newMem := int64 ( nm . ( int ) ) switch { case oldMem < newMem : d . Set ( " " , true ) } case oldMem > newMem : d . Set ( " " , true ) } return newMem } 
func expandVirtualMachineConfigSpec ( d * schema . ResourceData , client * govmomi . Client ) ( types . VirtualMachineConfigSpec , error ) { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) vappConfig , err := expandVAppConfig ( d , client ) if err != nil { return types . VirtualMachineConfigSpec { } , err } obj := types . VirtualMachineConfigSpec { Name : d . Get ( " " ) . ( string ) , GuestId : getWithRestart ( d , " " ) . ( string ) , AlternateGuestName : getWithRestart ( d , " " ) . ( string ) , Annotation : d . Get ( " " ) . ( string ) , Tools : expandToolsConfigInfo ( d ) , Flags : expandVirtualMachineFlagInfo ( d ) , NumCPUs : expandCPUCountConfig ( d ) , NumCoresPerSocket : int32 ( getWithRestart ( d , " " ) . ( int ) ) , MemoryMB : expandMemorySizeConfig ( d ) , MemoryHotAddEnabled : getBoolWithRestart ( d , " " ) , CpuHotAddEnabled : getBoolWithRestart ( d , " " ) , CpuHotRemoveEnabled : getBoolWithRestart ( d , " " ) , CpuAllocation : expandVirtualMachineResourceAllocation ( d , " " ) , MemoryAllocation : expandVirtualMachineResourceAllocation ( d , " " ) , MemoryReservationLockedToMax : getMemoryReservationLockedToMax ( d ) , ExtraConfig : expandExtraConfig ( d ) , SwapPlacement : getWithRestart ( d , " " ) . ( string ) , BootOptions : expandVirtualMachineBootOptions ( d , client ) , VAppConfig : vappConfig , Firmware : getWithRestart ( d , " " ) . ( string ) , NestedHVEnabled : getBoolWithRestart ( d , " " ) , VPMCEnabled : getBoolWithRestart ( d , " " ) , LatencySensitivity : expandLatencySensitivity ( d ) , } return obj , nil } 
func flattenVirtualMachineConfigInfo ( d * schema . ResourceData , obj * types . VirtualMachineConfigInfo ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . GuestId ) d . Set ( " " , obj . AlternateGuestName ) d . Set ( " " , obj . Annotation ) d . Set ( " " , obj . Hardware . NumCPU ) d . Set ( " " , obj . Hardware . NumCoresPerSocket ) d . Set ( " " , obj . Hardware . MemoryMB ) d . Set ( " " , obj . MemoryHotAddEnabled ) d . Set ( " " , obj . CpuHotAddEnabled ) d . Set ( " " , obj . CpuHotRemoveEnabled ) d . Set ( " " , obj . SwapPlacement ) d . Set ( " " , obj . Firmware ) d . Set ( " " , obj . NestedHVEnabled ) d . Set ( " " , obj . VPMCEnabled ) d . Set ( " " , obj . ChangeVersion ) d . Set ( " " , obj . Uuid ) if err := flattenToolsConfigInfo ( d , obj . Tools ) ; err != nil { return err } if err := flattenVirtualMachineFlagInfo ( d , & obj . Flags ) ; err != nil { return err } if err := flattenVirtualMachineResourceAllocation ( d , obj . CpuAllocation , " " ) ; err != nil { return err } if err := flattenVirtualMachineResourceAllocation ( d , obj . MemoryAllocation , " " ) ; err != nil { return err } if err := flattenExtraConfig ( d , obj . ExtraConfig ) ; err != nil { return err } if err := flattenVAppConfig ( d , obj . VAppConfig ) ; err != nil { return err } if err := flattenLatencySensitivity ( d , obj . LatencySensitivity ) ; err != nil { return err } } 
func expandVirtualMachineConfigSpecChanged ( d * schema . ResourceData , client * govmomi . Client , info * types . VirtualMachineConfigInfo ) ( types . VirtualMachineConfigSpec , bool , error ) { oldData . SetId ( d . Id ( ) ) oldSpec , err := expandVirtualMachineConfigSpec ( oldData , client ) if err != nil { return types . VirtualMachineConfigSpec { } , false , err } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) newSpec , err := expandVirtualMachineConfigSpec ( d , client ) if err != nil { return types . VirtualMachineConfigSpec { } , false , err } } 
func getMemoryReservationLockedToMax ( d * schema . ResourceData ) * bool { if d . Get ( " " ) . ( int ) != d . Get ( " " ) . ( int ) { return structure . BoolPtr ( false ) } return nil } 
func FromPathOrDefault ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . ResourcePool , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) t := client . ServiceContent . About . ApiType switch t { case " " : ddc , err := finder . DefaultDatacenter ( ctx ) if err != nil { return nil , err } finder . SetDatacenter ( ddc ) return finder . DefaultResourcePool ( ctx ) case " " : if dc != nil { finder . SetDatacenter ( dc ) } if name != " " { return finder . ResourcePool ( ctx , name ) } return finder . DefaultResourcePool ( ctx ) } return nil , fmt . Errorf ( " " , t ) } 
func Properties ( obj * object . ResourcePool ) ( * mo . ResourcePool , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . ResourcePool if err := obj . Properties ( ctx , obj . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func ValidateHost ( client * govmomi . Client , pool * object . ResourcePool , host * object . HostSystem ) error { if host == nil { return nil } log . Printf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) pprops , err := Properties ( pool ) if err != nil { return err } cprops , err := computeresource . BasePropertiesFromReference ( client , pprops . Owner ) if err != nil { return err } for _ , href := range cprops . Host { if href . Value == host . Reference ( ) . Value { log . Printf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) return nil } } return fmt . Errorf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) } 
func DefaultDevices ( client * govmomi . Client , pool * object . ResourcePool , guest string ) ( object . VirtualDeviceList , error ) { log . Printf ( " " , pool . Reference ( ) . Value , guest ) pprops , err := Properties ( pool ) if err != nil { return nil , err } return computeresource . DefaultDevicesFromReference ( client , pprops . Owner , guest ) } 
func OSFamily ( client * govmomi . Client , pool * object . ResourcePool , guest string ) ( string , error ) { log . Printf ( " " , guest ) pprops , err := Properties ( pool ) if err != nil { return " " , err } return computeresource . OSFamily ( client , pprops . Owner , guest ) } 
func Create ( rp * object . ResourcePool , name string , spec * types . ResourceConfigSpec ) ( * object . ResourcePool , error ) { log . Printf ( " " , fmt . Sprintf ( " " , rp . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) nrp , err := rp . Create ( ctx , name , * spec ) if err != nil { return nil , err } return nrp , nil } 
func Update ( rp * object . ResourcePool , name string , spec * types . ResourceConfigSpec ) error { log . Printf ( " " , fmt . Sprintf ( " " , rp . InventoryPath ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return rp . UpdateConfig ( ctx , name , spec ) } 
func MoveIntoResourcePool ( p * object . ResourcePool , c types . ManagedObjectReference ) error { req := types . MoveIntoResourcePool { This : p . Reference ( ) , List : [ ] types . ManagedObjectReference { c } , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) _ , err := methods . MoveIntoResourcePool ( ctx , p . Client ( ) , & req ) return err } 
func HasChildren ( rp * object . ResourcePool ) ( bool , error ) { props , err := Properties ( rp ) if err != nil { return false , err } if len ( props . Vm ) > 0 || len ( props . ResourcePool ) > 0 { return true , nil } return false , nil } 
func expandClusterDasVMConfigInfo ( d * schema . ResourceData , meta interface { } , vm * object . VirtualMachine , ) ( * types . ClusterDasVmConfigInfo , error ) { client , err := resourceVSphereHAVMOverrideClient ( meta ) if err != nil { return nil , err } version := viapi . ParseVersionFromClient ( client ) obj := & types . ClusterDasVmConfigInfo { DasSettings : expandClusterDasVMSettings ( d , version ) , Key : vm . Reference ( ) , } return obj , nil } 
func flattenClusterDasVMConfigInfo ( d * schema . ResourceData , meta interface { } , obj * types . ClusterDasVmConfigInfo ) error { client , err := resourceVSphereHAVMOverrideClient ( meta ) if err != nil { return err } version := viapi . ParseVersionFromClient ( client ) } return flattenClusterDasVMSettings ( d , obj . DasSettings , version ) } 
func resourceVSphereHAVMOverrideFlattenID ( cluster * object . ClusterComputeResource , vm * object . VirtualMachine ) ( string , error ) { clusterID := cluster . Reference ( ) . Value props , err := virtualmachine . Properties ( vm ) if err != nil { return " " , fmt . Errorf ( " " , err ) } vmID := props . Config . Uuid return strings . Join ( [ ] string { clusterID , vmID } , " " ) , nil } 
func resourceVSphereHAVMOverrideFindEntry ( cluster * object . ClusterComputeResource , vm * object . VirtualMachine , ) ( * types . ClusterDasVmConfigInfo , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . DasVmConfig { if info . Key == vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resourceVSphereHAVMOverrideObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , * object . VirtualMachine , error ) { if d . Id ( ) != " " { return resourceVSphereHAVMOverrideObjectsFromID ( d , meta ) } return resourceVSphereHAVMOverrideObjectsFromAttributes ( d , meta ) } 
func schemaHostPortGroupSpec ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , schemaHostNetworkPolicy ( ) ) return s } 
func expandHostPortGroupSpec ( d * schema . ResourceData ) * types . HostPortGroupSpec { obj := & types . HostPortGroupSpec { Name : d . Get ( " " ) . ( string ) , VlanId : int32 ( d . Get ( " " ) . ( int ) ) , VswitchName : d . Get ( " " ) . ( string ) , Policy : * expandHostNetworkPolicy ( d ) , } return obj } 
func flattenHostPortGroupSpec ( d * schema . ResourceData , obj * types . HostPortGroupSpec ) error { d . Set ( " " , obj . VlanId ) if err := flattenHostNetworkPolicy ( d , & obj . Policy ) ; err != nil { return err } return nil } 
func calculateComputedPolicy ( policy types . HostNetworkPolicy ) ( map [ string ] string , error ) { cpr := & schema . Resource { Schema : schemaHostNetworkPolicy ( ) } cpd := cpr . Data ( & terraform . InstanceState { } ) cpd . SetId ( " " ) if err := flattenHostNetworkPolicy ( cpd , & policy ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } cpm := cpd . State ( ) . Attributes delete ( cpm , " " ) return cpm , nil } 
func calculatePorts ( ports [ ] types . HostPortGroupPort ) * schema . Set { s := make ( [ ] interface { } , 0 ) for _ , port := range ports { m := make ( map [ string ] interface { } ) m [ " " ] = port . Key m [ " " ] = structure . SliceStringsToInterfaces ( port . Mac ) m [ " " ] = port . Type s = append ( s , m ) } return schema . NewSet ( schema . HashResource ( portGroupPortSchema ( ) ) , s ) } 
func portGroupPortSchema ( ) * schema . Resource { return & schema . Resource { Schema : map [ string ] * schema . Schema { " " : { Type : schema . TypeString , Description : " " , Computed : true , } , " " : { Type : schema . TypeList , Description : " " , Computed : true , Elem : & schema . Schema { Type : schema . TypeString } , } , " " : { Type : schema . TypeString , Description : " " , Computed : true , } , } , } } 
func saveHostPortGroupID ( d * schema . ResourceData , hsID , name string ) { d . SetId ( fmt . Sprintf ( " " , hostPortGroupIDPrefix , hsID , name ) ) } 
func splitHostPortGroupID ( raw string ) ( string , string , error ) { s := strings . SplitN ( raw , " " , 3 ) if len ( s ) != 3 || s [ 0 ] != hostPortGroupIDPrefix || s [ 1 ] == " " || s [ 2 ] == " " { return " " , " " , fmt . Errorf ( " " , raw ) } return s [ 1 ] , s [ 2 ] , nil } 
func portGroupIDsFromResourceID ( d * schema . ResourceData ) ( string , string , error ) { return splitHostPortGroupID ( d . Id ( ) ) } 
func BaseFromPath ( client * govmomi . Client , path string ) ( BaseComputeResource , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) list , err := finder . ManagedObjectList ( ctx , path , " " , " " ) if err != nil { return nil , err } if len ( list ) < 1 { return nil , fmt . Errorf ( " " , path ) } if len ( list ) > 1 { return nil , fmt . Errorf ( " " , path ) } if ! strings . HasSuffix ( list [ 0 ] . Path , path ) { return nil , fmt . Errorf ( " " , list [ 0 ] . Path , path ) } return BaseFromReference ( client , list [ 0 ] . Object . Reference ( ) ) } 
func BaseFromReference ( client * govmomi . Client , ref types . ManagedObjectReference ) ( BaseComputeResource , error ) { switch ref . Type { case " " : return StandaloneFromID ( client , ref . Value ) case " " : return StandaloneFromID ( client , ref . Value ) } return nil , fmt . Errorf ( " " , ref . Type ) } 
func BaseProperties ( obj BaseComputeResource ) ( * mo . ComputeResource , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . ComputeResource if err := obj . Properties ( ctx , obj . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func BasePropertiesFromReference ( client * govmomi . Client , ref types . ManagedObjectReference ) ( * mo . ComputeResource , error ) { obj , err := BaseFromReference ( client , ref ) if err != nil { return nil , err } return BaseProperties ( obj ) } 
func DefaultDevicesFromReference ( client * govmomi . Client , ref types . ManagedObjectReference , guest string ) ( object . VirtualDeviceList , error ) { log . Printf ( " " , ref . Value , guest ) b , err := EnvironmentBrowserFromReference ( client , ref ) if err != nil { return nil , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return b . DefaultDevices ( ctx , " " , nil ) } 
func OSFamily ( client * govmomi . Client , ref types . ManagedObjectReference , guest string ) ( string , error ) { b , err := EnvironmentBrowserFromReference ( client , ref ) if err != nil { return " " , err } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return b . OSFamily ( ctx , guest ) } 
func EnvironmentBrowserFromReference ( client * govmomi . Client , ref types . ManagedObjectReference ) ( * envbrowse . EnvironmentBrowser , error ) { cr , err := BaseFromReference ( client , ref ) if err != nil { return nil , err } props , err := BaseProperties ( cr ) if err != nil { return nil , err } if props . EnvironmentBrowser == nil { return nil , fmt . Errorf ( " " , cr , ) } return envbrowse . NewEnvironmentBrowser ( client . Client , * props . EnvironmentBrowser ) , nil } 
func Reconfigure ( obj BaseComputeResource , spec types . BaseComputeResourceConfigSpec ) error { var c * object . ComputeResource switch t := obj . ( type ) { case * object . ComputeResource : log . Printf ( " " , t . Name ( ) ) c = t case * object . ClusterComputeResource : log . Printf ( " " , t . Name ( ) ) c = & t . ComputeResource default : return fmt . Errorf ( " " , t ) } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := c . Reconfigure ( ctx , spec , true ) if err != nil { return err } return task . Wait ( ctx ) } 
func HasChildren ( obj BaseComputeResource ) ( bool , error ) { props , err := BaseProperties ( obj ) if err != nil { return false , err } } 
func Properties ( cluster * object . ClusterComputeResource ) ( * mo . ClusterComputeResource , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . ClusterComputeResource if err := cluster . Properties ( ctx , cluster . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func Create ( f * object . Folder , name string , spec types . ClusterConfigSpecEx ) ( * object . ClusterComputeResource , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . InventoryPath , name ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) cluster , err := f . CreateCluster ( ctx , name , spec ) if err != nil { return nil , err } return cluster , nil } 
func MoveToFolder ( client * govmomi . Client , cluster * object . ClusterComputeResource , relative string ) error { f , err := folder . HostFolderFromObject ( client , cluster , relative ) if err != nil { return err } return folder . MoveObjectTo ( cluster . Reference ( ) , f ) } 
func Reconfigure ( cluster * object . ClusterComputeResource , spec * types . ClusterConfigSpecEx ) error { return computeresource . Reconfigure ( cluster , spec ) } 
func Delete ( cluster * object . ClusterComputeResource ) error { log . Printf ( " " , cluster . InventoryPath ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := cluster . Destroy ( ctx ) if err != nil { return err } return task . Wait ( ctx ) } 
func IsMember ( cluster * object . ClusterComputeResource , host * object . HostSystem ) ( bool , error ) { hprops , err := hostsystem . Properties ( host ) if err != nil { return false , fmt . Errorf ( " " , host . Name ( ) , err ) } if hprops . Parent == nil { return false , nil } if * hprops . Parent != cluster . Reference ( ) { return false , nil } return true , nil } 
func MoveHostsInto ( cluster * object . ClusterComputeResource , hosts [ ] * object . HostSystem ) error { var hsNames [ ] string var hsRefs [ ] types . ManagedObjectReference for _ , hs := range hosts { hsNames = append ( hsNames , hs . Name ( ) ) hsRefs = append ( hsRefs , hs . Reference ( ) ) } log . Printf ( " " , cluster . Name ( ) , strings . Join ( hsNames , " " ) ) req := types . MoveInto_Task { This : cluster . Reference ( ) , Host : hsRefs , } ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) resp , err := methods . MoveInto_Task ( ctx , cluster . Client ( ) , & req ) if err != nil { return err } task := object . NewTask ( cluster . Client ( ) , resp . Returnval ) return task . Wait ( ctx ) } 
func MoveHostsOutOf ( cluster * object . ClusterComputeResource , hosts [ ] * object . HostSystem , timeout int ) error { for _ , host := range hosts { if err := moveHostOutOf ( cluster , host , timeout ) ; err != nil { return err } } return nil } 
func schemaVMwareDVSPortSetting ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expandVmwareDistributedVirtualSwitchVlanIDSpec ( d * schema . ResourceData ) * types . VmwareDistributedVirtualSwitchVlanIdSpec { obj := & types . VmwareDistributedVirtualSwitchVlanIdSpec { VlanId : int32 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flattenVmwareDistributedVirtualSwitchVlanIDSpec ( d * schema . ResourceData , obj * types . VmwareDistributedVirtualSwitchVlanIdSpec ) error { d . Set ( " " , obj . VlanId ) return nil } 
func expandVmwareDistributedVirtualSwitchTrunkVlanSpec ( d * schema . ResourceData ) * types . VmwareDistributedVirtualSwitchTrunkVlanSpec { var ranges [ ] types . NumericRange data := d . Get ( " " ) . ( * schema . Set ) . List ( ) for _ , v := range data { log . Printf ( " " , v ) r := v . ( map [ string ] interface { } ) min := r [ " " ] . ( int ) max := r [ " " ] . ( int ) rng := types . NumericRange { Start : int32 ( min ) , End : int32 ( max ) , } ranges = append ( ranges , rng ) } if len ( ranges ) < 1 { return nil } obj := & types . VmwareDistributedVirtualSwitchTrunkVlanSpec { VlanId : ranges , } return obj } 
func flattenVmwareDistributedVirtualSwitchTrunkVlanSpec ( d * schema . ResourceData , obj * types . VmwareDistributedVirtualSwitchTrunkVlanSpec ) error { var s [ ] interface { } for _ , rng := range obj . VlanId { m := make ( map [ string ] interface { } ) m [ " " ] = rng . Start m [ " " ] = rng . End s = append ( s , m ) } if err := d . Set ( " " , s ) ; err != nil { return err } return nil } 
func expandVmwareDistributedVirtualSwitchPvlanSpec ( d * schema . ResourceData ) * types . VmwareDistributedVirtualSwitchPvlanSpec { obj := & types . VmwareDistributedVirtualSwitchPvlanSpec { PvlanId : int32 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flattenVmwareDistributedVirtualSwitchPvlanSpec ( d * schema . ResourceData , obj * types . VmwareDistributedVirtualSwitchPvlanSpec ) error { d . Set ( " " , obj . PvlanId ) return nil } 
func expandBaseVmwareDistributedVirtualSwitchVlanSpec ( d * schema . ResourceData ) types . BaseVmwareDistributedVirtualSwitchVlanSpec { var obj types . BaseVmwareDistributedVirtualSwitchVlanSpec _ , ide := d . GetOkExists ( " " ) _ , pvid := d . GetOkExists ( " " ) vteList , vteOK := d . GetOkExists ( " " ) vte := vteOK && len ( vteList . ( * schema . Set ) . List ( ) ) > 0 switch { case vte : obj = expandVmwareDistributedVirtualSwitchTrunkVlanSpec ( d ) case pvid : obj = expandVmwareDistributedVirtualSwitchPvlanSpec ( d ) case ide : obj = expandVmwareDistributedVirtualSwitchVlanIDSpec ( d ) } return obj } 
func flattenBaseVmwareDistributedVirtualSwitchVlanSpec ( d * schema . ResourceData , obj types . BaseVmwareDistributedVirtualSwitchVlanSpec ) error { if obj == nil { return nil } var err error switch t := obj . ( type ) { case * types . VmwareDistributedVirtualSwitchVlanIdSpec : err = flattenVmwareDistributedVirtualSwitchVlanIDSpec ( d , t ) case * types . VmwareDistributedVirtualSwitchTrunkVlanSpec : err = flattenVmwareDistributedVirtualSwitchTrunkVlanSpec ( d , t ) case * types . VmwareDistributedVirtualSwitchPvlanSpec : err = flattenVmwareDistributedVirtualSwitchPvlanSpec ( d , t ) } return err } 
func expandDVSFailureCriteria ( d * schema . ResourceData ) * types . DVSFailureCriteria { obj := & types . DVSFailureCriteria { CheckBeacon : structure . GetBoolPolicy ( d , " " ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenDVSFailureCriteria ( d * schema . ResourceData , obj * types . DVSFailureCriteria ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , " " , obj . CheckBeacon ) return nil } 
func expandVMwareUplinkPortOrderPolicy ( d * schema . ResourceData ) * types . VMwareUplinkPortOrderPolicy { obj := & types . VMwareUplinkPortOrderPolicy { ActiveUplinkPort : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) , StandbyUplinkPort : structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenVMwareUplinkPortOrderPolicy ( d * schema . ResourceData , obj * types . VMwareUplinkPortOrderPolicy ) error { if obj == nil { return nil } if err := d . Set ( " " , obj . ActiveUplinkPort ) ; err != nil { return err } if err := d . Set ( " " , obj . StandbyUplinkPort ) ; err != nil { return err } return nil } 
func expandVmwareUplinkPortTeamingPolicy ( d * schema . ResourceData ) * types . VmwareUplinkPortTeamingPolicy { obj := & types . VmwareUplinkPortTeamingPolicy { Policy : structure . GetStringPolicy ( d , " " ) , NotifySwitches : structure . GetBoolPolicy ( d , " " ) , RollingOrder : structure . GetBoolPolicyReverse ( d , " " ) , FailureCriteria : expandDVSFailureCriteria ( d ) , UplinkPortOrder : expandVMwareUplinkPortOrderPolicy ( d ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenVmwareUplinkPortTeamingPolicy ( d * schema . ResourceData , obj * types . VmwareUplinkPortTeamingPolicy ) error { if obj == nil { return nil } structure . SetStringPolicy ( d , " " , obj . Policy ) structure . SetBoolPolicy ( d , " " , obj . NotifySwitches ) structure . SetBoolPolicyReverse ( d , " " , obj . RollingOrder ) if err := flattenDVSFailureCriteria ( d , obj . FailureCriteria ) ; err != nil { return err } if err := flattenVMwareUplinkPortOrderPolicy ( d , obj . UplinkPortOrder ) ; err != nil { return err } return nil } 
func expandDVSSecurityPolicy ( d * schema . ResourceData ) * types . DVSSecurityPolicy { obj := & types . DVSSecurityPolicy { AllowPromiscuous : structure . GetBoolPolicy ( d , " " ) , MacChanges : structure . GetBoolPolicy ( d , " " ) , ForgedTransmits : structure . GetBoolPolicy ( d , " " ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenDVSSecurityPolicy ( d * schema . ResourceData , obj * types . DVSSecurityPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , " " , obj . AllowPromiscuous ) structure . SetBoolPolicy ( d , " " , obj . MacChanges ) structure . SetBoolPolicy ( d , " " , obj . ForgedTransmits ) return nil } 
func expandVMwareUplinkLacpPolicy ( d * schema . ResourceData ) * types . VMwareUplinkLacpPolicy { obj := & types . VMwareUplinkLacpPolicy { Enable : structure . GetBoolPolicy ( d , " " ) , Mode : structure . GetStringPolicy ( d , " " ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenVMwareUplinkLacpPolicy ( d * schema . ResourceData , obj * types . VMwareUplinkLacpPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , " " , obj . Enable ) structure . SetStringPolicy ( d , " " , obj . Mode ) return nil } 
func expandDVSTrafficShapingPolicyIngress ( d * schema . ResourceData ) * types . DVSTrafficShapingPolicy { obj := & types . DVSTrafficShapingPolicy { Enabled : structure . GetBoolPolicy ( d , " " ) , AverageBandwidth : structure . GetLongPolicy ( d , " " ) , PeakBandwidth : structure . GetLongPolicy ( d , " " ) , BurstSize : structure . GetLongPolicy ( d , " " ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenDVSTrafficShapingPolicyIngress ( d * schema . ResourceData , obj * types . DVSTrafficShapingPolicy ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , " " , obj . Enabled ) structure . SetLongPolicy ( d , " " , obj . AverageBandwidth ) structure . SetLongPolicy ( d , " " , obj . PeakBandwidth ) structure . SetLongPolicy ( d , " " , obj . BurstSize ) return nil } 
func expandVMwareDVSPortSetting ( d * schema . ResourceData ) * types . VMwareDVSPortSetting { obj := & types . VMwareDVSPortSetting { DVPortSetting : types . DVPortSetting { Blocked : structure . GetBoolPolicy ( d , " " ) , InShapingPolicy : expandDVSTrafficShapingPolicyIngress ( d ) , OutShapingPolicy : expandDVSTrafficShapingPolicyEgress ( d ) , VmDirectPathGen2Allowed : structure . GetBoolPolicy ( d , " " ) , } , Vlan : expandBaseVmwareDistributedVirtualSwitchVlanSpec ( d ) , UplinkTeamingPolicy : expandVmwareUplinkPortTeamingPolicy ( d ) , SecurityPolicy : expandDVSSecurityPolicy ( d ) , IpfixEnabled : structure . GetBoolPolicy ( d , " " ) , TxUplink : structure . GetBoolPolicy ( d , " " ) , LacpPolicy : expandVMwareUplinkLacpPolicy ( d ) , } if structure . AllFieldsEmpty ( obj ) { return nil } return obj } 
func flattenVMwareDVSPortSetting ( d * schema . ResourceData , obj * types . VMwareDVSPortSetting ) error { if obj == nil { return nil } structure . SetBoolPolicy ( d , " " , obj . Blocked ) structure . SetBoolPolicy ( d , " " , obj . IpfixEnabled ) structure . SetBoolPolicy ( d , " " , obj . TxUplink ) structure . SetBoolPolicy ( d , " " , obj . VmDirectPathGen2Allowed ) if err := flattenDVSTrafficShapingPolicyIngress ( d , obj . InShapingPolicy ) ; err != nil { return err } if err := flattenDVSTrafficShapingPolicyEgress ( d , obj . OutShapingPolicy ) ; err != nil { return err } if err := flattenBaseVmwareDistributedVirtualSwitchVlanSpec ( d , obj . Vlan ) ; err != nil { return err } if err := flattenVmwareUplinkPortTeamingPolicy ( d , obj . UplinkTeamingPolicy ) ; err != nil { return err } if err := flattenDVSSecurityPolicy ( d , obj . SecurityPolicy ) ; err != nil { return err } if err := flattenVMwareUplinkLacpPolicy ( d , obj . LacpPolicy ) ; err != nil { return err } return nil } 
func expandClusterDrsVMConfigInfo ( d * schema . ResourceData , vm * object . VirtualMachine ) ( * types . ClusterDrsVmConfigInfo , error ) { obj := & types . ClusterDrsVmConfigInfo { Behavior : types . DrsBehavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . GetBool ( d , " " ) , Key : vm . Reference ( ) , } return obj , nil } 
func flattenClusterDrsVMConfigInfo ( d * schema . ResourceData , obj * types . ClusterDrsVmConfigInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , } ) } 
func resourceVSphereDRSVMOverrideParseID ( id string ) ( string , string , error ) { parts := strings . SplitN ( id , " " , 3 ) if len ( parts ) < 2 { return " " , " " , fmt . Errorf ( " " , id ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func resourceVSphereDRSVMOverrideFindEntry ( cluster * object . ClusterComputeResource , vm * object . VirtualMachine , ) ( * types . ClusterDrsVmConfigInfo , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . DrsVmConfig { if info . Key == vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resourceVSphereDRSVMOverrideObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , * object . VirtualMachine , error ) { if d . Id ( ) != " " { return resourceVSphereDRSVMOverrideObjectsFromID ( d , meta ) } return resourceVSphereDRSVMOverrideObjectsFromAttributes ( d , meta ) } 
func schemaVirtualMachineGuestInfo ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . TypeString , Computed : true , Description : " " , } , " " : { Type : schema . TypeList , Computed : true , Description : " " , Elem : & schema . Schema { Type : schema . TypeString } , } , } } 
func buildAndSelectGuestIPs ( d * schema . ResourceData , guest types . GuestInfo ) error { log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) var v4primary , v6primary , v4gw , v6gw net . IP var v4addrs , v6addrs [ ] string case " " : v6gw = net . ParseIP ( r . Gateway . IpAddress ) } } } } var mask net . IPMask if ip . To4 ( ) != nil { v4addrs = append ( v4addrs , addr . IpAddress ) mask = net . CIDRMask ( int ( addr . PrefixLength ) , 32 ) if ip . Mask ( mask ) . Equal ( v4gw . Mask ( mask ) ) && v4primary == nil { v4primary = ip } } else { v6addrs = append ( v6addrs , addr . IpAddress ) mask = net . CIDRMask ( int ( addr . PrefixLength ) , 128 ) if ip . Mask ( mask ) . Equal ( v6gw . Mask ( mask ) ) && v6primary == nil { v6primary = ip } } } } } addrs := make ( [ ] string , 0 ) addrs = append ( addrs , v4addrs ... ) addrs = append ( addrs , v6addrs ... ) } if len ( addrs ) < 1 { return d . Set ( " " , addrs ) } var primary string switch { case v4primary != nil : primary = v4primary . String ( ) case v6primary != nil : primary = v6primary . String ( ) default : primary = addrs [ 0 ] } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , primary ) d . Set ( " " , primary ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) , strings . Join ( addrs , " " ) ) if err := d . Set ( " " , addrs ) ; err != nil { return err } d . SetConnInfo ( map [ string ] string { " " : " " , " " : primary , } ) return nil } 
func resourceVSphereComputeClusterVMAntiAffinityRuleFlattenID ( cluster * object . ClusterComputeResource , key int32 ) ( string , error ) { clusterID := cluster . Reference ( ) . Value return strings . Join ( [ ] string { clusterID , strconv . Itoa ( int ( key ) ) } , " " ) , nil } 
func resourceVSphereComputeClusterVMAntiAffinityRuleObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , int32 , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterVMAntiAffinityRuleObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterVMAntiAffinityRuleObjectsFromAttributes ( d , meta ) } 
func schemaDatastoreSummary ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func flattenDatastoreSummary ( d * schema . ResourceData , obj * types . DatastoreSummary ) error { d . Set ( " " , obj . Accessible ) d . Set ( " " , structure . ByteToMB ( obj . Capacity ) ) d . Set ( " " , structure . ByteToMB ( obj . FreeSpace ) ) d . Set ( " " , obj . MaintenanceMode ) d . Set ( " " , obj . MultipleHostAccess ) d . Set ( " " , structure . ByteToMB ( obj . Uncommitted ) ) d . Set ( " " , obj . Url ) } return nil } 
func resourceVSphereDatastoreApplyFolderOrStorageClusterPath ( d * schema . ResourceData , meta interface { } ) ( string , error ) { var path string fvalue , fok := d . GetOk ( " " ) cvalue , cok := d . GetOk ( " " ) switch { case fok : path = fvalue . ( string ) case cok : return resourceVSphereDatastoreStorageClusterPathNormalized ( meta , cvalue . ( string ) ) } return path , nil } 
func resourceVSphereDatastoreReadFolderOrStorageClusterPath ( d * schema . ResourceData , ds * object . Datastore ) error { props , err := datastore . Properties ( ds ) if err != nil { return fmt . Errorf ( " " , err ) } switch props . Parent . Type { case " " : return resourceVSphereDatastoreReadFolderOrStorageClusterPathAsFolder ( d , ds ) case " " : return resourceVSphereDatastoreReadFolderOrStorageClusterPathSetAttributes ( d , " " , props . Parent . Value ) } return fmt . Errorf ( " " , props . Parent . Type ) } 
func CdromSubresourceSchema ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { structure . MergeSchema ( s , subresourceSchema ( ) ) return s } 
func NewCdromSubresource ( client * govmomi . Client , rdd resourceDataDiff , d , old map [ string ] interface { } , idx int ) * CdromSubresource { sr := & CdromSubresource { Subresource : & Subresource { schema : CdromSubresourceSchema ( ) , client : client , srtype : subresourceTypeCdrom , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func CdromApplyOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " ) ods := o . ( [ ] interface { } ) nds := n . ( [ ] interface { } ) var spec [ ] types . BaseVirtualDeviceConfigSpec nextOld : for n , oe := range ods { om := oe . ( map [ string ] interface { } ) for _ , ne := range nds { nm := ne . ( map [ string ] interface { } ) if om [ " " ] == nm [ " " ] { continue nextOld } } r := NewCdromSubresource ( c , d , om , nil , n ) dspec , err := r . Delete ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , dspec ) spec = append ( spec , dspec ... ) } log . Printf ( " " ) for n , ne := range nds { nm := ne . ( map [ string ] interface { } ) if n < len ( ods ) { om := oe . ( map [ string ] interface { } ) if nm [ " " ] != om [ " " ] { return nil , nil , fmt . Errorf ( " " , subresourceTypeCdrom , n , nm [ " " ] . ( int ) , om [ " " ] . ( int ) ) } if reflect . DeepEqual ( nm , om ) { log . Printf ( " " , nm [ " " ] . ( int ) ) continue } r := NewCdromSubresource ( c , d , nm , om , n ) uspec , err := r . Update ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , uspec ) spec = append ( spec , uspec ... ) updates = append ( updates , r . Data ( ) ) continue } cspec , err := r . Create ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , cspec ) spec = append ( spec , cspec ... ) updates = append ( updates , r . Data ( ) ) } log . Printf ( " " , subresourceListString ( updates ) ) } log . Printf ( " " , DeviceListString ( l ) ) log . Printf ( " " , DeviceChangeString ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func CdromRefreshOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) error { log . Printf ( " " ) } return false } ) log . Printf ( " " , DeviceListString ( devices ) ) curSet := d . Get ( subresourceTypeCdrom ) . ( [ ] interface { } ) log . Printf ( " " , subresourceListString ( curSet ) ) var newSet [ ] interface { } for n , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r := NewCdromSubresource ( c , d , m , nil , n ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } newSet = append ( newSet , r . Data ( ) ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] if device . GetVirtualDevice ( ) . Key == int32 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } } } log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( newSet ) ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] for n , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 0 { } if device . GetVirtualDevice ( ) . Key != int32 ( m [ " " ] . ( int ) ) { } vApp , err := verifyVAppCdromIso ( d , device . ( * types . VirtualCdrom ) , l , c ) if err != nil { return err } if vApp == true && r . Get ( " " ) == true { log . Printf ( " " , r ) r . Set ( " " , " " ) r . Set ( " " , " " ) } else { if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " , DeviceListString ( devices ) ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( " " , err ) } r := NewCdromSubresource ( c , d , m , nil , n ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } newSet = append ( newSet , r . Data ( ) ) } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " ) return d . Set ( subresourceTypeCdrom , newSet ) } 
func CdromDiffOperation ( d * schema . ResourceDiff , c * govmomi . Client ) error { log . Printf ( " " ) cr := d . Get ( subresourceTypeCdrom ) for ci , ce := range cr . ( [ ] interface { } ) { cm := ce . ( map [ string ] interface { } ) r := NewCdromSubresource ( c , d , cm , nil , ci ) if err := r . ValidateDiff ( ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } log . Printf ( " " ) return nil } 
func ( r * CdromSubresource ) ValidateDiff ( ) error { log . Printf ( " " , r ) dsID := r . Get ( " " ) . ( string ) path := r . Get ( " " ) . ( string ) clientDevice := r . Get ( " " ) . ( bool ) switch { case clientDevice && ( dsID != " " || path != " " ) : return fmt . Errorf ( " " ) case ! clientDevice && ( dsID == " " || path == " " ) : return fmt . Errorf ( " " ) } log . Printf ( " " , r ) return nil } 
func ( r * CdromSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec var ctlr types . BaseVirtualController ctlr , err := r . ControllerForCreateUpdate ( l , SubresourceControllerTypeIDE , 0 ) if err != nil { return nil , err } if err != nil { return nil , err } } dspec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , dspec ... ) log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * CdromSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( " " , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return fmt . Errorf ( " " , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return fmt . Errorf ( " " , l . Name ( d ) ) } case * types . VirtualCdromIsoBackingInfo : dp := & object . DatastorePath { } if ok := dp . FromString ( backing . FileName ) ; ! ok { return fmt . Errorf ( " " , backing . FileName ) } } r . Set ( " " , dp . Path ) default : r . Set ( " " , " " ) r . Set ( " " , " " ) r . Set ( " " , false ) } if err != nil { return err } if err := r . SaveDevIDs ( d , ctlr ) ; err != nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * CdromSubresource ) Update ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( " " , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return nil , fmt . Errorf ( " " , l . Name ( d ) ) } spec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * CdromSubresource ) Delete ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) d , err := r . FindVirtualDevice ( l ) if err != nil { return nil , fmt . Errorf ( " " , err ) } device , ok := d . ( * types . VirtualCdrom ) if ! ok { return nil , fmt . Errorf ( " " , l . Name ( d ) ) } deleteSpec , err := object . VirtualDeviceList { device } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } log . Printf ( " " , r , DeviceChangeString ( deleteSpec ) ) log . Printf ( " " , r ) return deleteSpec , nil } 
func ( r * CdromSubresource ) mapCdrom ( device * types . VirtualCdrom , l object . VirtualDeviceList ) error { dsID := r . Get ( " " ) . ( string ) path := r . Get ( " " ) . ( string ) clientDevice := r . Get ( " " ) . ( bool ) switch { case dsID != " " && path != " " : if err != nil { return fmt . Errorf ( " " , err ) } dsProps , err := datastore . Properties ( ds ) if err != nil { return fmt . Errorf ( " " , err ) } dsName := dsProps . Name dsPath := & object . DatastorePath { Datastore : dsName , Path : path , } device = l . InsertIso ( device , dsPath . String ( ) ) l . Connect ( device ) return nil case clientDevice == true : return nil } panic ( fmt . Sprintf ( " " , r ) ) } 
func VerifyVAppTransport ( d * schema . ResourceDiff , c * govmomi . Client ) error { log . Printf ( " " ) for _ , c := range cl . ( [ ] interface { } ) { if c . ( map [ string ] interface { } ) [ " " ] . ( bool ) == true { return nil } } for _ , m := range tm { if m . ( string ) == vAppTransportIso && len ( tm ) == 1 { return fmt . Errorf ( " " ) } } log . Printf ( " " ) return nil } 
func verifyVAppCdromIso ( d * schema . ResourceData , device * types . VirtualCdrom , l object . VirtualDeviceList , c * govmomi . Client ) ( bool , error ) { log . Printf ( " " ) if ok := dp . FromString ( backing . FileName ) ; ! ok { return false , nil } if ! re . MatchString ( dp . Path ) { log . Printf ( " " , dp . Path ) return false , nil } } else { return false , nil } log . Printf ( " " ) for _ , t := range tm { if t . ( string ) == " " { log . Printf ( " " ) return true , nil } } log . Printf ( " " ) return false , nil } 
func DatastorePathFromString ( p string ) ( * object . DatastorePath , bool ) { dp := new ( object . DatastorePath ) success := dp . FromString ( p ) log . Printf ( " " , success , p ) return dp , success } 
func IsVmdkDatastorePath ( p string ) bool { dp , success := DatastorePathFromString ( p ) if ! success { log . Printf ( " " , p ) return false } isVMDK := dp . IsVMDK ( ) log . Printf ( " " , p , structure . LogCond ( isVMDK , " " , " " ) ) return isVMDK } 
func Move ( client * govmomi . Client , srcPath string , srcDC * object . Datacenter , dstPath string , dstDC * object . Datacenter ) ( string , error ) { vdm := object . NewVirtualDiskManager ( client . Client ) if srcDC == nil { return " " , fmt . Errorf ( " " ) } if ! IsVmdkDatastorePath ( srcPath ) { return " " , fmt . Errorf ( " " , srcPath ) } if ! IsVmdkDatastorePath ( dstPath ) { ddp := dstDataStorePathFromLocalSrc ( srcPath , dstPath ) } dstPath = ddp dstDC = nil } log . Printf ( " " , srcPath , srcDC , dstPath , structure . LogCond ( dstDC != nil , fmt . Sprintf ( " " , dstDC ) , " " ) , ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := vdm . MoveVirtualDisk ( ctx , srcPath , srcDC , dstPath , dstDC , false ) if err != nil { return " " , err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return " " , err } log . Printf ( " " , srcPath , srcDC , dstPath , structure . LogCond ( dstDC != nil , fmt . Sprintf ( " " , dstDC ) , " " ) , ) return dstPath , nil } 
func QueryDiskType ( client * govmomi . Client , name string , dc * object . Datacenter ) ( types . VirtualDiskType , error ) { vdm := object . NewVirtualDiskManager ( client . Client ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) di , err := vdm . QueryVirtualDiskInfo ( ctx , name , dc , false ) if err != nil { return types . VirtualDiskType ( " " ) , err } t := di [ 0 ] . DiskType log . Printf ( " " , name , t ) return types . VirtualDiskType ( t ) , nil } 
func Delete ( client * govmomi . Client , name string , dc * object . Datacenter ) error { if dc == nil { return fmt . Errorf ( " " ) } log . Printf ( " " , name , dc ) vdm := object . NewVirtualDiskManager ( client . Client ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := vdm . DeleteVirtualDisk ( ctx , name , dc ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return err } log . Printf ( " " , name , dc ) return nil } 
func soapFault ( err error ) ( * soap . Fault , bool ) { if soap . IsSoapFault ( err ) { return soap . ToSoapFault ( err ) , true } return nil , false } 
func vimSoapFault ( err error ) ( types . AnyType , bool ) { if sf , ok := soapFault ( err ) ; ok { return sf . VimFault ( ) , true } return nil , false } 
func taskFault ( err error ) ( types . BaseMethodFault , bool ) { if te , ok := err . ( task . Error ) ; ok { return te . Fault ( ) , true } return nil , false } 
func IsManagedObjectNotFoundError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . ManagedObjectNotFound ) ; ok { return true } } return false } 
func isNotFoundError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . NotFound ) ; ok { return true } } return false } 
func IsAnyNotFoundError ( err error ) bool { switch { case IsManagedObjectNotFoundError ( err ) : fallthrough case isNotFoundError ( err ) : return true } return false } 
func IsResourceInUseError ( err error ) bool { if f , ok := vimSoapFault ( err ) ; ok { if _ , ok := f . ( types . ResourceInUse ) ; ok { return true } } return false } 
func isConcurrentAccessError ( err error ) bool { var ok bool f , ok = vimSoapFault ( err ) if ! ok { f , ok = taskFault ( err ) } if ok { switch f . ( type ) { case types . ConcurrentAccess , * types . ConcurrentAccess : return true } } return false } 
func RenameObject ( client * govmomi . Client , ref types . ManagedObjectReference , new string ) error { req := types . Rename_Task { This : ref , NewName : new , } rctx , rcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer rcancel ( ) res , err := methods . Rename_Task ( rctx , client . Client , & req ) if err != nil { return err } t := object . NewTask ( client . Client , res . Returnval ) tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return t . Wait ( tctx ) } 
func VimValidateVirtualCenter ( c * vim25 . Client ) error { if c . ServiceContent . About . ApiType != " " { return errors . New ( ErrVirtualCenterOnly ) } return nil } 
func parseVersion ( name , version , build string ) ( VSphereVersion , error ) { v := VSphereVersion { Product : name , } s := strings . Split ( version , " " ) if len ( s ) > 3 { return v , fmt . Errorf ( " " , version ) } var err error v . Major , err = strconv . Atoi ( s [ 0 ] ) if err != nil { return v , fmt . Errorf ( " " , s [ 0 ] , version ) } v . Minor , err = strconv . Atoi ( s [ 1 ] ) if err != nil { return v , fmt . Errorf ( " " , s [ 1 ] , version ) } v . Patch , err = strconv . Atoi ( s [ 2 ] ) if err != nil { return v , fmt . Errorf ( " " , s [ 2 ] , version ) } v . Build , err = strconv . Atoi ( build ) if err != nil { return v , fmt . Errorf ( " " , build ) } return v , nil } 
func parseVersionFromAboutInfo ( info types . AboutInfo ) VSphereVersion { v , err := parseVersion ( info . Name , info . Version , info . Build ) if err != nil { panic ( err ) } return v } 
func ParseVersionFromClient ( client * govmomi . Client ) VSphereVersion { return parseVersionFromAboutInfo ( client . Client . ServiceContent . About ) } 
func ( v VSphereVersion ) String ( ) string { return fmt . Sprintf ( " " , v . Product , v . Major , v . Minor , v . Patch , v . Build ) } 
func ( v VSphereVersion ) ProductEqual ( other VSphereVersion ) bool { return v . Product == other . Product } 
func ( v VSphereVersion ) olderVersion ( other VSphereVersion ) bool { vo := other . Major << 16 + other . Minor << 8 + other . Patch return vc < vo } 
func ( v VSphereVersion ) Older ( other VSphereVersion ) bool { if ! v . ProductEqual ( other ) { return false } if v . olderVersion ( other ) { return true } } if v . Build < other . Build { return true } return false } 
func ( v VSphereVersion ) Equal ( other VSphereVersion ) bool { return v . ProductEqual ( other ) && ! v . Older ( other ) && ! v . Newer ( other ) } 
func expandClusterVMGroup ( d * schema . ResourceData , meta interface { } , name string ) ( * types . ClusterVmGroup , error ) { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return nil , err } results , err := virtualmachine . MOIDsForUUIDs ( client , structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err != nil { return nil , err } obj := & types . ClusterVmGroup { ClusterGroupInfo : types . ClusterGroupInfo { Name : name , UserCreated : structure . BoolPtr ( true ) , } , Vm : results . ManagedObjectReferences ( ) , } return obj , nil } 
func flattenClusterVMGroup ( d * schema . ResourceData , meta interface { } , obj * types . ClusterVmGroup ) error { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return err } results , err := virtualmachine . UUIDsForManagedObjectReferences ( client , obj . Vm , ) if err != nil { return err } return structure . SetBatch ( d , map [ string ] interface { } { " " : results . UUIDs ( ) , } ) } 
func resourceVSphereComputeClusterVMGroupFindEntry ( cluster * object . ClusterComputeResource , name string , ) ( * types . ClusterVmGroup , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . Group { if info . GetClusterGroupInfo ( ) . Name == name { if vmInfo , ok := info . ( * types . ClusterVmGroup ) ; ok { log . Printf ( " " , name , cluster . Name ( ) ) return vmInfo , nil } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } } log . Printf ( " " , name , cluster . Name ( ) ) return nil , nil } 
func resourceVSphereComputeClusterVMGroupObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , string , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterVMGroupObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterVMGroupObjectsFromAttributes ( d , meta ) } 
func resourceVSphereComputeClusterVMGroupFetchObjects ( meta interface { } , clusterID string , name string , ) ( * object . ClusterComputeResource , string , error ) { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return nil , " " , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , " " , fmt . Errorf ( " " , err ) } return cluster , name , nil } 
func resourceVSphereResourcePoolApplyTags ( d * schema . ResourceData , meta interface { } , rp * object . ResourcePool ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } return nil } log . Printf ( " " , resourceVSphereResourcePoolIDString ( d ) ) return processTagDiff ( tagsClient , d , rp ) } 
func resourceVSphereResourcePoolReadTags ( d * schema . ResourceData , meta interface { } , rp * object . ResourcePool ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( " " , resourceVSphereResourcePoolIDString ( d ) ) if err := readTagsForResource ( tagsClient , rp , d ) ; err != nil { return err } } else { log . Printf ( " " , resourceVSphereResourcePoolIDString ( d ) ) } return nil } 
func expandClusterAffinityRuleSpec ( d * schema . ResourceData , meta interface { } ) ( * types . ClusterAffinityRuleSpec , error ) { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return nil , err } results , err := virtualmachine . MOIDsForUUIDs ( client , structure . SliceInterfacesToStrings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err != nil { return nil , err } obj := & types . ClusterAffinityRuleSpec { ClusterRuleInfo : types . ClusterRuleInfo { Enabled : structure . GetBool ( d , " " ) , Mandatory : structure . GetBool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , UserCreated : structure . BoolPtr ( true ) , } , Vm : results . ManagedObjectReferences ( ) , } return obj , nil } 
func flattenClusterAffinityRuleSpec ( d * schema . ResourceData , meta interface { } , obj * types . ClusterAffinityRuleSpec ) error { client , err := resourceVSphereComputeClusterVMGroupClient ( meta ) if err != nil { return err } results , err := virtualmachine . UUIDsForManagedObjectReferences ( client , obj . Vm , ) if err != nil { return err } return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : results . UUIDs ( ) , } ) } 
func resourceVSphereComputeClusterVMAffinityRuleFindEntry ( cluster * object . ClusterComputeResource , key int32 , ) ( * types . ClusterAffinityRuleSpec , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . Rule { if info . GetClusterRuleInfo ( ) . Key == key { if vmAffinityRuleInfo , ok := info . ( * types . ClusterAffinityRuleSpec ) ; ok { log . Printf ( " " , key , cluster . Name ( ) ) return vmAffinityRuleInfo , nil } return nil , fmt . Errorf ( " " , key , cluster . Name ( ) ) } } log . Printf ( " " , key , cluster . Name ( ) ) return nil , nil } 
func resourceVSphereComputeClusterVMAffinityRuleObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , int32 , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterVMAffinityRuleObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterVMAffinityRuleObjectsFromAttributes ( d , meta ) } 
func ConfigSchema ( ) * schema . Schema { return & schema . Schema { Type : schema . TypeMap , Description : " " , Optional : true , } } 
func ReadFromResource ( client * govmomi . Client , entity * mo . ManagedEntity , d * schema . ResourceData ) { customAttrs := make ( map [ string ] interface { } ) if len ( entity . CustomValue ) > 0 { for _ , fv := range entity . CustomValue { value := fv . ( * types . CustomFieldStringValue ) . Value if value != " " { customAttrs [ fmt . Sprint ( fv . GetCustomFieldValue ( ) . Key ) ] = value } } } d . Set ( ConfigKey , customAttrs ) } 
func VirtualMachineCloneSchema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . TypeString , Required : true , Description : " " , } , " " : { Type : schema . TypeBool , Optional : true , Description : " " , } , " " : { Type : schema . TypeInt , Optional : true , Default : 30 , Description : " " , ValidateFunc : validation . IntAtLeast ( 10 ) , } , " " : { Type : schema . TypeList , Optional : true , MaxItems : 1 , Description : " " , Elem : & schema . Resource { Schema : VirtualMachineCustomizeSchema ( ) } , } , } } 
func ValidateVirtualMachineClone ( d * schema . ResourceDiff , c * govmomi . Client ) error { tUUID := d . Get ( " " ) . ( string ) log . Printf ( " " , tUUID ) vm , err := virtualmachine . FromUUID ( c , tUUID ) if err != nil { return fmt . Errorf ( " " , tUUID , err ) } vprops , err := virtualmachine . Properties ( vm ) if err != nil { return fmt . Errorf ( " " , err ) } } aGuestID := d . Get ( " " ) . ( string ) if eGuestID != aGuestID { return fmt . Errorf ( " " , aGuestID , eGuestID ) } if linked { log . Printf ( " " , tUUID ) if err := validateCloneSnapshots ( vprops ) ; err != nil { return err } } if err := virtualdevice . DiskCloneValidateOperation ( d , c , l , linked ) ; err != nil { return err } if err != nil { return fmt . Errorf ( " " , poolID , err ) } family , err := resourcepool . OSFamily ( c , pool , d . Get ( " " ) . ( string ) ) if err != nil { return fmt . Errorf ( " " , d . Get ( " " ) . ( string ) , err ) } if err := ValidateCustomizationSpec ( d , family ) ; err != nil { return err } } else { log . Printf ( " " ) } } vconfig := vprops . Config . VAppConfig if vconfig != nil { } log . Printf ( " " , tUUID ) return nil } 
func validateCloneSnapshots ( props * mo . VirtualMachine ) error { if props . Snapshot == nil { return fmt . Errorf ( " " , props . Config . Uuid ) } } } } return nil } 
func ExpandVirtualMachineCloneSpec ( d * schema . ResourceData , c * govmomi . Client ) ( types . VirtualMachineCloneSpec , * object . VirtualMachine , error ) { var spec types . VirtualMachineCloneSpec log . Printf ( " " ) if err != nil { return spec , nil , fmt . Errorf ( " " , err ) } spec . Location . Datastore = types . NewReference ( ds . Reference ( ) ) } tUUID := d . Get ( " " ) . ( string ) log . Printf ( " " , tUUID ) vm , err := virtualmachine . FromUUID ( c , tUUID ) if err != nil { return spec , nil , fmt . Errorf ( " " , tUUID , err ) } vprops , err := virtualmachine . Properties ( vm ) if err != nil { return spec , nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , tUUID ) if err := validateCloneSnapshots ( vprops ) ; err != nil { return spec , nil , err } spec . Snapshot = vprops . Snapshot . CurrentSnapshot spec . Location . DiskMoveType = string ( types . VirtualMachineRelocateDiskMoveOptionsCreateNewChildDiskBacking ) log . Printf ( " " , vprops . Snapshot . CurrentSnapshot . Value ) } pool , err := resourcepool . FromID ( c , poolID ) if err != nil { return spec , nil , fmt . Errorf ( " " , poolID , err ) } var hs * object . HostSystem if v , ok := d . GetOk ( " " ) ; ok { hsID := v . ( string ) var err error if hs , err = hostsystem . FromID ( c , hsID ) ; err != nil { return spec , nil , fmt . Errorf ( " " , hsID , err ) } } } poolRef := pool . Reference ( ) spec . Location . Pool = & poolRef if hs != nil { hsRef := hs . Reference ( ) spec . Location . Host = & hsRef } relocators , err := virtualdevice . DiskCloneRelocateOperation ( d , c , l ) if err != nil { return spec , nil , err } spec . Location . Disk = relocators log . Printf ( " " ) return spec , vm , nil } 
func ReferenceProperties ( client * govmomi . Client , net object . NetworkReference ) ( * mo . Network , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Network nc := object . NewCommon ( client . Client , net . Reference ( ) ) if err := nc . Properties ( ctx , nc . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func Properties ( net * object . Network ) ( * mo . Network , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Network if err := net . Properties ( ctx , net . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func SystemOrDefault ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . HostSystem , error ) { finder := find . NewFinder ( client . Client , false ) finder . SetDatacenter ( dc ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) t := client . ServiceContent . About . ApiType switch t { case " " : return finder . DefaultHostSystem ( ctx ) case " " : if name != " " { return finder . HostSystem ( ctx , name ) } return finder . DefaultHostSystem ( ctx ) } return nil , fmt . Errorf ( " " , t ) } 
func Properties ( host * object . HostSystem ) ( * mo . HostSystem , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . HostSystem if err := host . Properties ( ctx , host . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func ResourcePool ( host * object . HostSystem ) ( * object . ResourcePool , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) return host . ResourcePool ( ctx ) } 
func hostSystemNameFromID ( client * govmomi . Client , id string ) ( string , error ) { hs , err := FromID ( client , id ) if err != nil { return " " , err } return hs . Name ( ) , nil } 
func NameOrID ( client * govmomi . Client , id string ) string { name , err := hostSystemNameFromID ( client , id ) if err != nil { return id } return name } 
func EnterMaintenanceMode ( host * object . HostSystem , timeout int , evacuate bool ) error { if err := viapi . VimValidateVirtualCenter ( host . Client ( ) ) ; err != nil { evacuate = false } log . Printf ( " " , host . Name ( ) , evacuate ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Second * time . Duration ( timeout ) ) defer cancel ( ) task , err := host . EnterMaintenanceMode ( ctx , int32 ( timeout ) , evacuate , nil ) if err != nil { return err } return task . Wait ( ctx ) } 
func ExitMaintenanceMode ( host * object . HostSystem , timeout int ) error { log . Printf ( " " , host . Name ( ) ) ctx , cancel := context . WithTimeout ( context . Background ( ) , time . Second * time . Duration ( ctxTimeout ) ) defer cancel ( ) task , err := host . ExitMaintenanceMode ( ctx , int32 ( timeout ) ) if err != nil { return err } return task . Wait ( ctx ) } 
func dvsFromUUID ( client * govmomi . Client , uuid string ) ( * object . VmwareDistributedVirtualSwitch , error ) { dvsm := types . ManagedObjectReference { Type : " " , Value : " " } req := & types . QueryDvsByUuid { This : dvsm , Uuid : uuid , } resp , err := methods . QueryDvsByUuid ( context . TODO ( ) , client , req ) if err != nil { return nil , err } return dvsFromMOID ( client , resp . Returnval . Reference ( ) . Value ) } 
func dvsFromPath ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . VmwareDistributedVirtualSwitch , error ) { net , err := network . FromPath ( client , name , dc ) if err != nil { return nil , err } if net . Reference ( ) . Type != " " { return nil , fmt . Errorf ( " " , name , net . Reference ( ) . Type ) } return dvsFromMOID ( client , net . Reference ( ) . Value ) } 
func dvsProperties ( dvs * object . VmwareDistributedVirtualSwitch ) ( * mo . VmwareDistributedVirtualSwitch , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) var props mo . VmwareDistributedVirtualSwitch if err := dvs . Properties ( ctx , dvs . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func upgradeDVS ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , version string ) error { req := & types . PerformDvsProductSpecOperation_Task { This : dvs . Reference ( ) , Operation : " " , ProductSpec : & types . DistributedVirtualSwitchProductSpec { Version : version , } , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) resp , err := methods . PerformDvsProductSpecOperation_Task ( ctx , client , req ) if err != nil { return err } task := object . NewTask ( client . Client , resp . Returnval ) tctx , tcancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return err } return nil } 
func updateDVSConfiguration ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , spec * types . VMwareDVSConfigSpec ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) task , err := dvs . Reconfigure ( ctx , spec ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer tcancel ( ) if err := task . Wait ( tctx ) ; err != nil { return err } return nil } 
func enableDVSNetworkResourceManagement ( client * govmomi . Client , dvs * object . VmwareDistributedVirtualSwitch , enabled bool ) error { req := & types . EnableNetworkResourceManagement { This : dvs . Reference ( ) , Enable : enabled , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) _ , err := methods . EnableNetworkResourceManagement ( ctx , client , req ) if err != nil { return err } return nil } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleFlattenID ( pod * object . StoragePod , key int32 ) ( string , error ) { podID := pod . Reference ( ) . Value return strings . Join ( [ ] string { podID , strconv . Itoa ( int ( key ) ) } , " " ) , nil } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleFindEntry ( pod * object . StoragePod , key int32 , ) ( * types . ClusterAntiAffinityRuleSpec , error ) { props , err := storagepod . Properties ( pod ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . PodStorageDrsEntry . StorageDrsConfig . PodConfig . Rule { if info . GetClusterRuleInfo ( ) . Key == key { if vmAntiAffinityRuleInfo , ok := info . ( * types . ClusterAntiAffinityRuleSpec ) ; ok { log . Printf ( " " , key , pod . Name ( ) ) return vmAntiAffinityRuleInfo , nil } return nil , fmt . Errorf ( " " , key , pod . Name ( ) ) } } log . Printf ( " " , key , pod . Name ( ) ) return nil , nil } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleFindEntryByName ( pod * object . StoragePod , name string , ) ( * types . ClusterAntiAffinityRuleSpec , error ) { props , err := storagepod . Properties ( pod ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . PodStorageDrsEntry . StorageDrsConfig . PodConfig . Rule { if info . GetClusterRuleInfo ( ) . Name == name { if vmAntiAffinityRuleInfo , ok := info . ( * types . ClusterAntiAffinityRuleSpec ) ; ok { log . Printf ( " " , name , pod . Name ( ) ) return vmAntiAffinityRuleInfo , nil } return nil , fmt . Errorf ( " " , name , pod . Name ( ) ) } } return nil , fmt . Errorf ( " " , name , pod . Name ( ) ) } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . StoragePod , int32 , error ) { if d . Id ( ) != " " { return resourceVSphereDatastoreClusterVMAntiAffinityRuleObjectsFromID ( d , meta ) } return resourceVSphereDatastoreClusterVMAntiAffinityRuleObjectsFromAttributes ( d , meta ) } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleFetchObjects ( meta interface { } , podID string , key int32 , ) ( * object . StoragePod , int32 , error ) { client , err := resourceVSphereDatastoreClusterVMAntiAffinityRuleClient ( meta ) if err != nil { return nil , 0 , err } pod , err := storagepod . FromID ( client , podID ) if err != nil { return nil , 0 , fmt . Errorf ( " " , err ) } return pod , key , nil } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleApplySDRSConfigSpec ( pod * object . StoragePod , spec types . StorageDrsConfigSpec , ) error { return storagepod . ApplyDRSConfiguration ( & govmomi . Client { Client : pod . Client ( ) , } , pod , spec , ) } 
func resourceVSphereDatastoreClusterVMAntiAffinityRuleValidateRuleVMCount ( d * schema . ResourceData ) error { if d . Get ( " " ) . ( * schema . Set ) . Len ( ) < 2 { return errors . New ( " " ) } return nil } 
func controllerTypeToClass ( c types . BaseVirtualController ) ( string , error ) { var t string switch c . ( type ) { case * types . VirtualIDEController : t = SubresourceControllerTypeIDE case * types . VirtualAHCIController : t = SubresourceControllerTypeSATA case * types . VirtualPCIController : t = SubresourceControllerTypePCI case * types . ParaVirtualSCSIController , * types . VirtualBusLogicController , * types . VirtualLsiLogicController , * types . VirtualLsiLogicSASController : t = SubresourceControllerTypeSCSI default : return subresourceControllerTypeUnknown , fmt . Errorf ( " " , c ) } return t , nil } 
func subresourceSchema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . TypeInt , Computed : true , Description : " " , } , " " : { Type : schema . TypeString , Computed : true , Description : " " , } , } } 
func ( r * Subresource ) Addr ( ) string { return fmt . Sprintf ( " " , r . srtype , r . Index ) } 
func ( r * Subresource ) Set ( key string , value interface { } ) { if v := structure . NormalizeValue ( value ) ; v != nil { r . data [ key ] = v } } 
func ( r * Subresource ) HasChange ( key string ) bool { o , n := r . GetChange ( key ) return ! reflect . DeepEqual ( o , n ) } 
func ( r * Subresource ) GetChange ( key string ) ( interface { } , interface { } ) { new := r . data [ key ] if r . olddata != nil { old = r . olddata [ key ] } return old , new } 
func ( r * Subresource ) GetWithRestart ( key string ) interface { } { if r . HasChange ( key ) { r . SetRestart ( key ) } return r . Get ( key ) } 
func ( r * Subresource ) GetWithVeto ( key string ) ( interface { } , error ) { if r . HasChange ( key ) { old , new := r . GetChange ( key ) return r . Get ( key ) , fmt . Errorf ( " " , key , old , new ) } return r . Get ( key ) , nil } 
func ( r * Subresource ) SetRestart ( key string ) { log . Printf ( " " , r , key ) switch d := r . rdd . ( type ) { case * schema . ResourceData : d . Set ( " " , true ) case * schema . ResourceDiff : d . SetNew ( " " , true ) default : } } 
func ( r * Subresource ) Hash ( ) int { hf := schema . HashResource ( & schema . Resource { Schema : r . schema } ) return hf ( r . data ) } 
func computeDevAddr ( device types . BaseVirtualDevice , ctlr types . BaseVirtualController ) ( string , error ) { vd := device . GetVirtualDevice ( ) vc := ctlr . GetVirtualController ( ) ctype , err := controllerTypeToClass ( ctlr ) if err != nil { return " " , err } parts := [ ] string { ctype , strconv . Itoa ( int ( vc . BusNumber ) ) , strconv . Itoa ( int ( structure . DeRef ( vd . UnitNumber ) . ( int32 ) ) ) , } return strings . Join ( parts , " " ) , nil } 
func ( r * Subresource ) SaveDevIDs ( device types . BaseVirtualDevice , ctlr types . BaseVirtualController ) error { r . Set ( " " , device . GetVirtualDevice ( ) . Key ) addr , err := computeDevAddr ( device , ctlr ) if err != nil { return err } r . Set ( " " , addr ) return nil } 
func splitDevAddr ( id string ) ( string , int , int , error ) { parts := strings . Split ( id , " " ) if len ( parts ) < 3 { return " " , 0 , 0 , fmt . Errorf ( " " , id ) } ct , cbs , dus := parts [ 0 ] , parts [ 1 ] , parts [ 2 ] cb , cbe := strconv . Atoi ( cbs ) du , due := strconv . Atoi ( dus ) var found bool for _ , v := range subresourceIDControllerTypeAllowedValues { if v == ct { found = true } } if ! found { return ct , cb , du , fmt . Errorf ( " " , ct ) } if cbe != nil { return ct , cb , du , fmt . Errorf ( " " , cbs ) } if due != nil { return ct , cb , du , fmt . Errorf ( " " , dus ) } return ct , cb , du , nil } 
func findVirtualDeviceInListControllerSelectFunc ( ct string , cb int ) func ( types . BaseVirtualDevice ) bool { return func ( device types . BaseVirtualDevice ) bool { switch ct { case SubresourceControllerTypeIDE : if _ , ok := device . ( * types . VirtualIDEController ) ; ! ok { return false } case SubresourceControllerTypeSATA : if _ , ok := device . ( * types . VirtualAHCIController ) ; ! ok { return false } case SubresourceControllerTypeSCSI : if _ , ok := device . ( types . BaseVirtualSCSIController ) ; ! ok { return false } case SubresourceControllerTypePCI : if _ , ok := device . ( * types . VirtualPCIController ) ; ! ok { return false } } vc := device . ( types . BaseVirtualController ) . GetVirtualController ( ) if vc . BusNumber == int32 ( cb ) { return true } return false } } 
func findVirtualDeviceInListDeviceSelectFunc ( ckey int32 , du int ) func ( types . BaseVirtualDevice ) bool { return func ( d types . BaseVirtualDevice ) bool { vd := d . GetVirtualDevice ( ) if vd . ControllerKey == ckey && vd . UnitNumber != nil && * vd . UnitNumber == int32 ( du ) { return true } return false } } 
func findControllerForDevice ( l object . VirtualDeviceList , bvd types . BaseVirtualDevice ) ( types . BaseVirtualController , error ) { vd := bvd . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , fmt . Errorf ( " " , vd . ControllerKey , vd . Key ) } return ctlr . ( types . BaseVirtualController ) , nil } 
func ( r * Subresource ) FindVirtualDeviceByAddr ( l object . VirtualDeviceList ) ( types . BaseVirtualDevice , error ) { log . Printf ( " " , r . DevAddr ( ) ) ct , cb , du , err := splitDevAddr ( r . DevAddr ( ) ) if err != nil { return nil , err } ctlrs := l . Select ( csf ) if len ( ctlrs ) != 1 { return nil , fmt . Errorf ( " " , len ( ctlrs ) , ct , cb ) } ctlr := ctlrs [ 0 ] dsf := findVirtualDeviceInListDeviceSelectFunc ( ckey , du ) devices := l . Select ( dsf ) if len ( devices ) != 1 { return nil , fmt . Errorf ( " " , len ( devices ) , ckey , du ) } device := devices [ 0 ] log . Printf ( " " , l . Name ( device ) ) return device , nil } 
func ( r * Subresource ) FindVirtualDevice ( l object . VirtualDeviceList ) ( types . BaseVirtualDevice , error ) { if key := r . Get ( " " ) . ( int ) ; key > 0 { log . Printf ( " " , key ) if dev := l . FindByKey ( int32 ( key ) ) ; dev != nil { log . Printf ( " " , l . Name ( dev ) ) return dev , nil } return nil , fmt . Errorf ( " " , key ) } return r . FindVirtualDeviceByAddr ( l ) } 
func ( r * Subresource ) String ( ) string { devaddr := r . Get ( " " ) . ( string ) if devaddr == " " { devaddr = " " } return fmt . Sprintf ( " " , r . Addr ( ) , r . Get ( " " ) . ( int ) , devaddr ) } 
func swapSCSIDevice ( l object . VirtualDeviceList , device types . BaseVirtualSCSIController , ct string , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , ct , l . Name ( device . ( types . BaseVirtualDevice ) ) ) var spec [ ] types . BaseVirtualDeviceConfigSpec bvd := device . ( types . BaseVirtualDevice ) cspec , err := object . VirtualDeviceList { bvd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } spec = append ( spec , cspec ... ) nsd , err := l . CreateSCSIController ( ct ) if err != nil { return nil , err } nsd . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) nsd . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . BusNumber = device . GetVirtualSCSIController ( ) . BusNumber cspec , err = object . VirtualDeviceList { nsd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } spec = append ( spec , cspec ... ) ockey := device . GetVirtualSCSIController ( ) . Key nckey := nsd . GetVirtualDevice ( ) . Key for _ , vd := range l { if vd . GetVirtualDevice ( ) . ControllerKey == ockey { vd . GetVirtualDevice ( ) . ControllerKey = nckey cspec , err := object . VirtualDeviceList { vd } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } if len ( cspec ) != 1 { return nil , fmt . Errorf ( " " , len ( cspec ) ) } spec = append ( spec , cspec ... ) } } log . Printf ( " " , DeviceChangeString ( spec ) ) return spec , nil } 
func NormalizeSCSIBus ( l object . VirtualDeviceList , ct string , count int , st string ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , count , ct ) var spec [ ] types . BaseVirtualDeviceConfigSpec ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok { if busNumber := sc . GetVirtualSCSIController ( ) . BusNumber ; busNumber < iCount { ctlrs [ busNumber ] = sc } } } log . Printf ( " " , scsiControllerListString ( ctlrs ) ) cspec , err := createSCSIController ( & l , ct , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) continue } if l . Type ( ctlr . ( types . BaseVirtualDevice ) ) == ct { cspec , err := setSCSIBusSharing ( & l , ctlr , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) continue } cspec , err := swapSCSIDevice ( l , ctlr , ct , st ) if err != nil { return nil , nil , err } spec = append ( spec , cspec ... ) l = applyDeviceChange ( l , cspec ) continue } log . Printf ( " " , DeviceListString ( l ) ) log . Printf ( " " , DeviceChangeString ( spec ) ) return l , spec , nil } 
func setSCSIBusSharing ( l * object . VirtualDeviceList , ctlr types . BaseVirtualSCSIController , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { var cspec [ ] types . BaseVirtualDeviceConfigSpec if ctlr . GetVirtualSCSIController ( ) . SharedBus != types . VirtualSCSISharing ( st ) { ctlr . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) var err error cspec , err = object . VirtualDeviceList { ctlr . ( types . BaseVirtualDevice ) } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } * l = applyDeviceChange ( * l , cspec ) } return cspec , nil } 
func createSCSIController ( l * object . VirtualDeviceList , ct string , st string ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { nc , err := l . CreateSCSIController ( ct ) if err != nil { return nil , err } nc . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus = types . VirtualSCSISharing ( st ) cspec , err := object . VirtualDeviceList { nc } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) * l = applyDeviceChange ( * l , cspec ) return cspec , err } 
func ReadSCSIBusType ( l object . VirtualDeviceList , count int ) string { ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber < int32 ( count ) { ctlrs [ sc . GetVirtualSCSIController ( ) . BusNumber ] = sc } } log . Printf ( " " , count , scsiControllerListString ( ctlrs ) ) if ctlrs [ 0 ] == nil { return subresourceControllerTypeUnknown } last := l . Type ( ctlrs [ 0 ] . ( types . BaseVirtualDevice ) ) for _ , ctlr := range ctlrs [ 1 : ] { if ctlr == nil || l . Type ( ctlr . ( types . BaseVirtualDevice ) ) != last { return subresourceControllerTypeMixed } } return last } 
func ReadSCSIBusSharing ( l object . VirtualDeviceList , count int ) string { ctlrs := make ( [ ] types . BaseVirtualSCSIController , count ) for _ , dev := range l { if sc , ok := dev . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber < int32 ( count ) { ctlrs [ sc . GetVirtualSCSIController ( ) . BusNumber ] = sc } } log . Printf ( " " , count , scsiControllerListString ( ctlrs ) ) if ctlrs [ 0 ] == nil { return subresourceControllerSharingUnknown } last := ctlrs [ 0 ] . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus for _ , ctlr := range ctlrs [ 1 : ] { if ctlr == nil || ctlr . ( types . BaseVirtualSCSIController ) . GetVirtualSCSIController ( ) . SharedBus != last { return subresourceControllerSharingMixed } } return string ( last ) } 
func pickSCSIController ( l object . VirtualDeviceList , bus int ) ( types . BaseVirtualController , error ) { log . Printf ( " " , bus ) l = l . Select ( func ( device types . BaseVirtualDevice ) bool { switch d := device . ( type ) { case types . BaseVirtualSCSIController : return d . GetVirtualSCSIController ( ) . BusNumber == int32 ( bus ) } return false } ) if len ( l ) == 0 { return nil , fmt . Errorf ( " " , bus ) } log . Printf ( " " , l . Name ( l [ 0 ] ) ) return l [ 0 ] . ( types . BaseVirtualController ) , nil } 
func ( r * Subresource ) ControllerForCreateUpdate ( l object . VirtualDeviceList , ct string , bus int ) ( types . BaseVirtualController , error ) { log . Printf ( " " , ct ) var ctlr types . BaseVirtualController var err error switch ct { case SubresourceControllerTypeIDE : ctlr = l . PickController ( & types . VirtualIDEController { } ) case SubresourceControllerTypeSATA : ctlr = l . PickController ( & types . VirtualAHCIController { } ) case SubresourceControllerTypeSCSI : ctlr , err = pickSCSIController ( l , bus ) case SubresourceControllerTypePCI : ctlr = l . PickController ( & types . VirtualPCIController { } ) default : return nil , fmt . Errorf ( " " , ct ) } if err != nil { return nil , err } if ctlr == nil { return nil , fmt . Errorf ( " " , ct ) } } log . Printf ( " " , l . Name ( ctlr . ( types . BaseVirtualDevice ) ) ) return ctlr , nil } 
func applyDeviceChange ( l object . VirtualDeviceList , cs [ ] types . BaseVirtualDeviceConfigSpec ) object . VirtualDeviceList { log . Printf ( " " , DeviceChangeString ( cs ) ) log . Printf ( " " , DeviceListString ( l ) ) for _ , s := range cs { spec := s . GetVirtualDeviceConfigSpec ( ) switch spec . Operation { case types . VirtualDeviceConfigSpecOperationAdd : l = append ( l , spec . Device ) case types . VirtualDeviceConfigSpecOperationEdit : } } case types . VirtualDeviceConfigSpecOperationRemove : for i := 0 ; i < len ( l ) ; i ++ { dev := l [ i ] if dev . GetVirtualDevice ( ) . Key == spec . Device . GetVirtualDevice ( ) . Key { l = append ( l [ : i ] , l [ i + 1 : ] ... ) i -- } } default : panic ( " " ) } } log . Printf ( " " , DeviceListString ( l ) ) return l } 
func DeviceListString ( l object . VirtualDeviceList ) string { var names [ ] string for _ , d := range l { if d == nil { names = append ( names , " " ) } else { names = append ( names , l . Name ( d ) ) } } return strings . Join ( names , " " ) } 
func DeviceChangeString ( specs [ ] types . BaseVirtualDeviceConfigSpec ) string { var strs [ ] string for _ , v := range specs { spec := v . GetVirtualDeviceConfigSpec ( ) strs = append ( strs , fmt . Sprintf ( " " , string ( spec . Operation ) , spec . Device , spec . Device . GetVirtualDevice ( ) . Key ) ) } return strings . Join ( strs , " " ) } 
func subresourceListString ( data [ ] interface { } ) string { var strs [ ] string for _ , v := range data { if v == nil { strs = append ( strs , " " ) continue } m := v . ( map [ string ] interface { } ) devaddr := m [ " " ] . ( string ) if devaddr == " " { devaddr = " " } strs = append ( strs , fmt . Sprintf ( " " , m [ " " ] . ( int ) , devaddr ) ) } return strings . Join ( strs , " " ) } 
func scsiControllerListString ( ctlrs [ ] types . BaseVirtualSCSIController ) string { var l object . VirtualDeviceList for _ , ctlr := range ctlrs { if ctlr == nil { l = append ( l , types . BaseVirtualDevice ( nil ) ) } else { l = append ( l , ctlr . ( types . BaseVirtualDevice ) ) } } return DeviceListString ( l ) } 
func AppendDeviceChangeSpec ( spec [ ] types . BaseVirtualDeviceConfigSpec , ops ... types . BaseVirtualDeviceConfigSpec , ) [ ] types . BaseVirtualDeviceConfigSpec { for _ , op := range ops { c := copystructure . Must ( copystructure . Copy ( op ) ) . ( types . BaseVirtualDeviceConfigSpec ) spec = append ( spec , c ) } return spec } 
func expandClusterDependencyRuleInfo ( d * schema . ResourceData ) ( * types . ClusterDependencyRuleInfo , error ) { obj := & types . ClusterDependencyRuleInfo { ClusterRuleInfo : types . ClusterRuleInfo { Enabled : structure . GetBool ( d , " " ) , Mandatory : structure . GetBool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , UserCreated : structure . BoolPtr ( true ) , } , DependsOnVmGroup : d . Get ( " " ) . ( string ) , VmGroup : d . Get ( " " ) . ( string ) , } return obj , nil } 
func flattenClusterDependencyRuleInfo ( d * schema . ResourceData , obj * types . ClusterDependencyRuleInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : obj . DependsOnVmGroup , " " : obj . VmGroup , } ) } 
func resourceVSphereComputeClusterVMDependencyRuleParseID ( id string ) ( string , int32 , error ) { parts := strings . SplitN ( id , " " , 3 ) if len ( parts ) < 2 { return " " , 0 , fmt . Errorf ( " " , id ) } key , err := strconv . Atoi ( parts [ 1 ] ) if err != nil { return " " , 0 , fmt . Errorf ( " " , parts [ 1 ] , err ) } return parts [ 0 ] , int32 ( key ) , nil } 
func resourceVSphereComputeClusterVMDependencyRuleObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , int32 , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterVMDependencyRuleObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterVMDependencyRuleObjectsFromAttributes ( d , meta ) } 
func resourceVSphereComputeClusterVMDependencyRuleFetchObjects ( meta interface { } , clusterID string , key int32 , ) ( * object . ClusterComputeResource , int32 , error ) { client , err := resourceVSphereComputeClusterVMDependencyRuleClient ( meta ) if err != nil { return nil , 0 , err } cluster , err := clustercomputeresource . FromID ( client , clusterID ) if err != nil { return nil , 0 , fmt . Errorf ( " " , err ) } return cluster , key , nil } 
func Provider ( ) terraform . ResourceProvider { return & schema . Provider { Schema : map [ string ] * schema . Schema { " " : { Type : schema . TypeString , Required : true , DefaultFunc : schema . EnvDefaultFunc ( " " , nil ) , Description : " " , } , " " : { Type : schema . TypeString , Required : true , DefaultFunc : schema . EnvDefaultFunc ( " " , nil ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , nil ) , Description : " " , } , " " : { Type : schema . TypeBool , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , false ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , nil ) , Deprecated : " " , } , " " : { Type : schema . TypeBool , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , false ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , " " ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , " " ) , Description : " " , } , " " : { Type : schema . TypeBool , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , false ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , filepath . Join ( os . Getenv ( " " ) , " " , " " ) ) , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , DefaultFunc : schema . EnvDefaultFunc ( " " , filepath . Join ( os . Getenv ( " " ) , " " , " " ) ) , Description : " " , } , } , ResourcesMap : map [ string ] * schema . Resource { " " : resourceVSphereComputeCluster ( ) , " " : resourceVSphereComputeClusterHostGroup ( ) , " " : resourceVSphereComputeClusterVMAffinityRule ( ) , " " : resourceVSphereComputeClusterVMAntiAffinityRule ( ) , " " : resourceVSphereComputeClusterVMDependencyRule ( ) , " " : resourceVSphereComputeClusterVMGroup ( ) , " " : resourceVSphereComputeClusterVMHostRule ( ) , " " : resourceVSphereCustomAttribute ( ) , " " : resourceVSphereDatacenter ( ) , " " : resourceVSphereDatastoreCluster ( ) , " " : resourceVSphereDatastoreClusterVMAntiAffinityRule ( ) , " " : resourceVSphereDistributedPortGroup ( ) , " " : resourceVSphereDistributedVirtualSwitch ( ) , " " : resourceVSphereDRSVMOverride ( ) , " " : resourceVSphereDPMHostOverride ( ) , " " : resourceVSphereFile ( ) , " " : resourceVSphereFolder ( ) , " " : resourceVSphereHAVMOverride ( ) , " " : resourceVSphereHostPortGroup ( ) , " " : resourceVSphereHostVirtualSwitch ( ) , " " : resourceVSphereLicense ( ) , " " : resourceVSphereResourcePool ( ) , " " : resourceVSphereTag ( ) , " " : resourceVSphereTagCategory ( ) , " " : resourceVSphereVirtualDisk ( ) , " " : resourceVSphereVirtualMachine ( ) , " " : resourceVSphereNasDatastore ( ) , " " : resourceVSphereStorageDrsVMOverride ( ) , " " : resourceVSphereVAppContainer ( ) , " " : resourceVSphereVAppEntity ( ) , " " : resourceVSphereVmfsDatastore ( ) , " " : resourceVSphereVirtualMachineSnapshot ( ) , } , DataSourcesMap : map [ string ] * schema . Resource { " " : dataSourceVSphereComputeCluster ( ) , " " : dataSourceVSphereCustomAttribute ( ) , " " : dataSourceVSphereDatacenter ( ) , " " : dataSourceVSphereDatastore ( ) , " " : dataSourceVSphereDatastoreCluster ( ) , " " : dataSourceVSphereDistributedVirtualSwitch ( ) , " " : dataSourceVSphereFolder ( ) , " " : dataSourceVSphereHost ( ) , " " : dataSourceVSphereNetwork ( ) , " " : dataSourceVSphereResourcePool ( ) , " " : dataSourceVSphereTag ( ) , " " : dataSourceVSphereTagCategory ( ) , " " : dataSourceVSphereVAppContainer ( ) , " " : dataSourceVSphereVirtualMachine ( ) , " " : dataSourceVSphereVmfsDisks ( ) , } , ConfigureFunc : providerConfigure , } } 
func resourceVSphereDatastoreClusterApplyCreate ( d * schema . ResourceData , meta interface { } ) ( * object . StoragePod , error ) { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , err } dc , err := datacenterFromID ( client , d . Get ( " " ) . ( string ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } return pod , nil } 
func resourceVSphereDatastoreClusterApplyTags ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } return nil } log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) return processTagDiff ( tagsClient , d , pod ) } 
func resourceVSphereDatastoreClusterReadTags ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) if err := readTagsForResource ( tagsClient , pod , d ) ; err != nil { return err } } else { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) } return nil } 
func resourceVSphereDatastoreClusterApplyCustomAttributes ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { client := meta . ( * VSphereClient ) . vimClient if err != nil { return err } if attrsProcessor == nil { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) return nil } log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) return attrsProcessor . ProcessDiff ( pod ) } 
func resourceVSphereDatastoreClusterReadCustomAttributes ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { client := meta . ( * VSphereClient ) . vimClient props , err := storagepod . Properties ( pod ) if err != nil { return err } customattribute . ReadFromResource ( client , props . Entity ( ) , d ) } else { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) } return nil } 
func resourceVSphereDatastoreClusterApplySDRSConfig ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { return nil } log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return err } return storagepod . ApplyDRSConfiguration ( client , pod , spec ) } 
func resourceVSphereDatastoreClusterHasSDRSConfigChange ( d * schema . ResourceData ) bool { for k := range resourceVSphereDatastoreCluster ( ) . Schema { switch { case resourceVSphereDatastoreClusterHasSDRSConfigChangeExcluded ( k ) : continue case d . HasChange ( k ) : return true } } return false } 
func resourceVSphereDatastoreClusterGetPod ( d structure . ResourceIDStringer , meta interface { } ) ( * object . StoragePod , error ) { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , err } return storagepod . FromID ( client , d . Id ( ) ) } 
func resourceVSphereDatastoreClusterGetPodFromPath ( meta interface { } , path string , dcID string ) ( * object . StoragePod , error ) { client := meta . ( * VSphereClient ) . vimClient var dc * object . Datacenter if dcID != " " { var err error dc , err = datacenterFromID ( client , dcID ) if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , path , dc . InventoryPath ) } else { log . Printf ( " " , path ) } if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return nil , err } return storagepod . FromPath ( client , path , dc ) } 
func resourceVSphereDatastoreClusterSaveNameAndPath ( d * schema . ResourceData , pod * object . StoragePod ) error { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) if err := d . Set ( " " , pod . Name ( ) ) ; err != nil { return fmt . Errorf ( " " , err ) } f , err := folder . RootPathParticleDatastore . SplitRelativeFolder ( pod . InventoryPath ) if err != nil { return fmt . Errorf ( " " , pod . InventoryPath , err ) } if err := d . Set ( " " , folder . NormalizePath ( f ) ) ; err != nil { return fmt . Errorf ( " " , err ) } return nil } 
func resourceVSphereDatastoreClusterApplyNameChange ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod , ) ( * object . StoragePod , error ) { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) var changed bool var err error if d . HasChange ( " " ) { if err = storagepod . Rename ( pod , d . Get ( " " ) . ( string ) ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } changed = true } if changed { if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) } return pod , nil } 
func resourceVSphereDatastoreClusterApplyFolderChange ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod , ) ( * object . StoragePod , error ) { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) var changed bool var err error if d . HasChange ( " " ) { f := d . Get ( " " ) . ( string ) client := meta . ( * VSphereClient ) . vimClient if err = storagepod . MoveToFolder ( client , pod , f ) ; err != nil { return nil , fmt . Errorf ( " " , f , err ) } changed = true } if changed { if err != nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) , pod . InventoryPath , ) } return pod , nil } 
func resourceVSphereDatastoreClusterValidateEmptyCluster ( d structure . ResourceIDStringer , pod * object . StoragePod ) error { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) ne , err := storagepod . HasChildren ( pod ) if err != nil { return fmt . Errorf ( " " , err ) } if ne { return fmt . Errorf ( " " , pod . InventoryPath , ) } return nil } 
func resourceVSphereDatastoreClusterApplyDelete ( d * schema . ResourceData , pod * object . StoragePod ) error { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) if err := storagepod . Delete ( pod ) ; err != nil { return err } d . SetId ( " " ) return nil } 
func resourceVSphereDatastoreClusterFlattenSDRSData ( d * schema . ResourceData , meta interface { } , pod * object . StoragePod ) error { log . Printf ( " " , resourceVSphereDatastoreClusterIDString ( d ) ) client := meta . ( * VSphereClient ) . vimClient if err := viapi . ValidateVirtualCenter ( client ) ; err != nil { return err } props , err := storagepod . Properties ( pod ) if err != nil { return err } return flattenStorageDrsPodConfigInfo ( d , props . PodStorageDrsEntry . StorageDrsConfig . PodConfig , version ) } 
func expandStorageDrsPodConfigSpec ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . StorageDrsPodConfigSpec { obj := & types . StorageDrsPodConfigSpec { DefaultIntraVmAffinity : structure . GetBool ( d , " " ) , DefaultVmBehavior : d . Get ( " " ) . ( string ) , Enabled : structure . GetBool ( d , " " ) , IoLoadBalanceConfig : expandStorageDrsIoLoadBalanceConfig ( d , version ) , IoLoadBalanceEnabled : structure . GetBool ( d , " " ) , LoadBalanceInterval : int32 ( d . Get ( " " ) . ( int ) ) , SpaceLoadBalanceConfig : expandStorageDrsSpaceLoadBalanceConfig ( d , version ) , Option : expandStorageDrsOptionSpec ( d ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . AutomationOverrides = expandStorageDrsAutomationConfig ( d ) } return obj } 
func flattenStorageDrsPodConfigInfo ( d * schema . ResourceData , obj types . StorageDrsPodConfigInfo , version viapi . VSphereVersion ) error { attrs := map [ string ] interface { } { " " : obj . DefaultIntraVmAffinity , " " : obj . DefaultVmBehavior , " " : obj . Enabled , " " : obj . IoLoadBalanceEnabled , " " : obj . LoadBalanceInterval , } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( " " , k , err ) } } if err := flattenStorageDrsIoLoadBalanceConfig ( d , obj . IoLoadBalanceConfig , version ) ; err != nil { return err } if err := flattenStorageDrsSpaceLoadBalanceConfig ( d , obj . SpaceLoadBalanceConfig , version ) ; err != nil { return err } if err := flattenStorageDrsOptionSpec ( d , obj . Option ) ; err != nil { return err } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { if err := flattenStorageDrsAutomationConfig ( d , obj . AutomationOverrides ) ; err != nil { return err } } return nil } 
func expandStorageDrsAutomationConfig ( d * schema . ResourceData ) * types . StorageDrsAutomationConfig { obj := & types . StorageDrsAutomationConfig { IoLoadBalanceAutomationMode : d . Get ( " " ) . ( string ) , PolicyEnforcementAutomationMode : d . Get ( " " ) . ( string ) , RuleEnforcementAutomationMode : d . Get ( " " ) . ( string ) , SpaceLoadBalanceAutomationMode : d . Get ( " " ) . ( string ) , VmEvacuationAutomationMode : d . Get ( " " ) . ( string ) , } return obj } 
func flattenStorageDrsAutomationConfig ( d * schema . ResourceData , obj * types . StorageDrsAutomationConfig ) error { attrs := map [ string ] interface { } { " " : obj . IoLoadBalanceAutomationMode , " " : obj . PolicyEnforcementAutomationMode , " " : obj . RuleEnforcementAutomationMode , " " : obj . SpaceLoadBalanceAutomationMode , " " : obj . VmEvacuationAutomationMode , } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expandStorageDrsIoLoadBalanceConfig ( d * schema . ResourceData , version viapi . VSphereVersion ) * types . StorageDrsIoLoadBalanceConfig { obj := & types . StorageDrsIoLoadBalanceConfig { IoLatencyThreshold : int32 ( d . Get ( " " ) . ( int ) ) , IoLoadImbalanceThreshold : int32 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . ReservableIopsThreshold = int32 ( d . Get ( " " ) . ( int ) ) obj . ReservablePercentThreshold = int32 ( d . Get ( " " ) . ( int ) ) obj . ReservableThresholdMode = d . Get ( " " ) . ( string ) } return obj } 
func flattenStorageDrsIoLoadBalanceConfig ( d * schema . ResourceData , obj * types . StorageDrsIoLoadBalanceConfig , version viapi . VSphereVersion , ) error { attrs := map [ string ] interface { } { " " : obj . IoLatencyThreshold , " " : obj . IoLoadImbalanceThreshold , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { attrs [ " " ] = obj . ReservableThresholdMode if obj . ReservableThresholdMode == string ( types . StorageDrsPodConfigInfoBehaviorManual ) { attrs [ " " ] = obj . ReservableIopsThreshold } else { attrs [ " " ] = obj . ReservablePercentThreshold } } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expandStorageDrsSpaceLoadBalanceConfig ( d * schema . ResourceData , version viapi . VSphereVersion , ) * types . StorageDrsSpaceLoadBalanceConfig { obj := & types . StorageDrsSpaceLoadBalanceConfig { MinSpaceUtilizationDifference : int32 ( d . Get ( " " ) . ( int ) ) , SpaceUtilizationThreshold : int32 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { obj . FreeSpaceThresholdGB = int32 ( d . Get ( " " ) . ( int ) ) obj . SpaceThresholdMode = d . Get ( " " ) . ( string ) } return obj } 
func flattenStorageDrsSpaceLoadBalanceConfig ( d * schema . ResourceData , obj * types . StorageDrsSpaceLoadBalanceConfig , version viapi . VSphereVersion , ) error { attrs := map [ string ] interface { } { " " : obj . MinSpaceUtilizationDifference , " " : obj . SpaceThresholdMode , } freeSpaceSupported := version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) if freeSpaceSupported && obj . SpaceThresholdMode == string ( types . StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeFreeSpace ) { attrs [ " " ] = obj . FreeSpaceThresholdGB } else { attrs [ " " ] = obj . SpaceUtilizationThreshold } for k , v := range attrs { if err := d . Set ( k , v ) ; err != nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expandStorageDrsOptionSpec ( d * schema . ResourceData ) [ ] types . StorageDrsOptionSpec { var opts [ ] types . StorageDrsOptionSpec m := d . Get ( " " ) . ( map [ string ] interface { } ) for k , v := range m { opts = append ( opts , types . StorageDrsOptionSpec { Option : & types . OptionValue { Key : k , Value : types . AnyType ( v ) , } , } ) } return opts } 
func flattenStorageDrsOptionSpec ( d * schema . ResourceData , opts [ ] types . BaseOptionValue ) error { m := make ( map [ string ] interface { } ) for _ , opt := range opts { m [ opt . GetOptionValue ( ) . Key ] = opt . GetOptionValue ( ) . Value } return d . Set ( " " , m ) } 
func resourceVSphereFolderMigrateState ( version int , os * terraform . InstanceState , meta interface { } ) ( * terraform . InstanceState , error ) { } } var migrateFunc func ( * terraform . InstanceState , interface { } ) error switch version { case 0 : log . Printf ( " " , version , os ) migrateFunc = resourceVSphereFolderMigrateStateV1 default : return os , nil } if err := migrateFunc ( os , meta ) ; err != nil { return nil , err } version ++ log . Printf ( " " , version , os ) return resourceVSphereFolderMigrateState ( version , os , meta ) } 
func resourceVSphereFolderMigrateStateV1 ( s * terraform . InstanceState , meta interface { } ) error { p := folder . NormalizePath ( s . Attributes [ " " ] ) dc , err := getDatacenter ( client , dcp ) if err != nil { return err } folder , err := folder . FromAbsolutePath ( client , fp ) if err != nil { return err } s . ID = folder . Reference ( ) . Value return nil } 
func getDatacenter ( c * govmomi . Client , dc string ) ( * object . Datacenter , error ) { finder := find . NewFinder ( c . Client , true ) t := c . ServiceContent . About . ApiType switch t { case " " : return finder . DefaultDatacenter ( context . TODO ( ) ) case " " : if dc != " " { return finder . Datacenter ( context . TODO ( ) , dc ) } return finder . DefaultDatacenter ( context . TODO ( ) ) } return nil , fmt . Errorf ( " " , t ) } 
func datacenterFromID ( client * govmomi . Client , id string ) ( * object . Datacenter , error ) { finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : " " , Value : id , } ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) ds , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , fmt . Errorf ( " " , id , err ) } return ds . ( * object . Datacenter ) , nil } 
func DiskSubresourceSchema ( ) map [ string ] * schema . Schema { s := map [ string ] * schema . Schema { } return nil , nil } , Deprecated : diskNameDeprecationNotice , } , " " : { Type : schema . TypeString , Optional : true , Computed : true , ConflictsWith : [ ] string { " " } , Description : " " , ValidateFunc : func ( v interface { } , _ string ) ( [ ] string , [ ] error ) { if path . Ext ( v . ( string ) ) != " " { return nil , [ ] error { fmt . Errorf ( " " , v . ( string ) ) } } return nil , nil } , } , " " : { Type : schema . TypeString , Optional : true , Default : string ( types . VirtualDiskModePersistent ) , Description : " " , ValidateFunc : validation . StringInSlice ( diskSubresourceModeAllowedValues , false ) , } , " " : { Type : schema . TypeBool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . TypeString , Optional : true , Default : string ( types . VirtualDiskSharingSharingNone ) , Description : " " , ValidateFunc : validation . StringInSlice ( diskSubresourceSharingAllowedValues , false ) , } , " " : { Type : schema . TypeBool , Optional : true , Default : true , Description : " " , } , " " : { Type : schema . TypeBool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . TypeString , Computed : true , Description : " " , } , } return nil , nil } , } , " " : { Type : schema . TypeInt , Optional : true , Default : 0 , Description : " " , ValidateFunc : validation . IntBetween ( 0 , 59 ) , } , " " : { Type : schema . TypeBool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . TypeBool , Optional : true , Default : false , ConflictsWith : [ ] string { " " } , Description : " " , } , } structure . MergeSchema ( s , subresourceSchema ( ) ) return s } 
func NewDiskSubresource ( client * govmomi . Client , rdd resourceDataDiff , d , old map [ string ] interface { } , idx int ) * DiskSubresource { sr := & DiskSubresource { Subresource : & Subresource { schema : DiskSubresourceSchema ( ) , client : client , srtype : subresourceTypeDisk , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func DiskApplyOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " ) o , n := d . GetChange ( subresourceTypeDisk ) ods := o . ( [ ] interface { } ) nds := n . ( [ ] interface { } ) var spec [ ] types . BaseVirtualDeviceConfigSpec for oi , oe := range ods { om := oe . ( map [ string ] interface { } ) if err := diskApplyOperationDelete ( oi , om , nds , c , d , & l , & spec ) ; err != nil { return nil , nil , err } } log . Printf ( " " ) log . Printf ( " " , subresourceListString ( updates ) ) for ni , ne := range nds { nm := ne . ( map [ string ] interface { } ) if err := diskApplyOperationCreateUpdate ( ni , nm , ods , c , d , & l , & spec , & updates ) ; err != nil { return nil , nil , err } } log . Printf ( " " , subresourceListString ( updates ) ) } log . Printf ( " " , DeviceListString ( l ) ) log . Printf ( " " , DeviceChangeString ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func diskApplyOperationDelete ( index int , oldData map [ string ] interface { } , newDataSet [ ] interface { } , c * govmomi . Client , d * schema . ResourceData , l * object . VirtualDeviceList , spec * [ ] types . BaseVirtualDeviceConfigSpec , ) error { didx := - 1 for ni , ne := range newDataSet { newData := ne . ( map [ string ] interface { } ) var name string var err error if name , err = diskLabelOrName ( newData ) ; err != nil { return err } if ( name == diskDeletedName || name == diskDetachedName ) && oldData [ " " ] == newData [ " " ] { didx = ni break } } if didx < 0 { } r := NewDiskSubresource ( c , d , oldData , nil , index ) dspec , err := r . Delete ( * l ) if err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = applyDeviceChange ( * l , dspec ) * spec = append ( * spec , dspec ... ) return nil } 
func diskApplyOperationCreateUpdate ( index int , newData map [ string ] interface { } , oldDataSet [ ] interface { } , c * govmomi . Client , d * schema . ResourceData , l * object . VirtualDeviceList , spec * [ ] types . BaseVirtualDeviceConfigSpec , updates * [ ] interface { } , ) error { var name string var err error if name , err = diskLabelOrName ( newData ) ; err != nil { return err } if name == diskDeletedName || name == diskDetachedName { } for _ , oe := range oldDataSet { oldData := oe . ( map [ string ] interface { } ) if newData [ " " ] == oldData [ " " ] { if err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } oldCopy := omc . ( map [ string ] interface { } ) oldCopy [ " " ] = newData [ " " ] oldCopy [ " " ] = newData [ " " ] oldCopy [ " " ] = newData [ " " ] if reflect . DeepEqual ( oldCopy , newData ) { * updates = append ( * updates , r . Data ( ) ) return nil } uspec , err := r . Update ( * l ) if err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = applyDeviceChange ( * l , uspec ) * spec = append ( * spec , uspec ... ) * updates = append ( * updates , r . Data ( ) ) return nil } } cspec , err := r . Create ( * l ) if err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = applyDeviceChange ( * l , cspec ) * spec = append ( * spec , cspec ... ) * updates = append ( * updates , r . Data ( ) ) return nil } 
func DiskRefreshOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) error { log . Printf ( " " ) devices := SelectDisks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , DeviceListString ( devices ) ) curSet := d . Get ( subresourceTypeDisk ) . ( [ ] interface { } ) log . Printf ( " " , subresourceListString ( curSet ) ) var newSet [ ] interface { } for i , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r := NewDiskSubresource ( c , d , m , nil , i ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } newSet = append ( newSet , r . Data ( ) ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] if device . GetVirtualDevice ( ) . Key == int32 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } } } log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( newSet ) ) for i := 0 ; i < len ( devices ) ; i ++ { device := devices [ i ] for n , item := range curSet { m := item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { } if ! diskUUIDMatch ( device , m [ " " ] . ( string ) ) { } if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } devices = append ( devices [ : i ] , devices [ i + 1 : ] ... ) i -- } } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " , DeviceListString ( devices ) ) for i , device := range devices { m := make ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( " " , err ) } r := NewDiskSubresource ( c , d , m , nil , len ( newSet ) ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } newSet = append ( newSet , r . Data ( ) ) } log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " , subresourceListString ( newSet ) ) log . Printf ( " " ) return d . Set ( subresourceTypeDisk , newSet ) } 
func DiskDestroyOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " ) var spec [ ] types . BaseVirtualDeviceConfigSpec log . Printf ( " " ) for oi , oe := range ds { m := oe . ( map [ string ] interface { } ) if ! m [ " " ] . ( bool ) && ! m [ " " ] . ( bool ) { } r := NewDiskSubresource ( c , d , m , nil , oi ) dspec , err := r . Delete ( l ) if err != nil { return nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , dspec ) spec = append ( spec , dspec ... ) } log . Printf ( " " , DeviceChangeString ( spec ) ) return spec , nil } 
func DiskDiffOperation ( d * schema . ResourceDiff , c * govmomi . Client ) error { log . Printf ( " " ) o , n := d . GetChange ( subresourceTypeDisk ) names := make ( map [ string ] struct { } ) attachments := make ( map [ string ] struct { } ) units := make ( map [ int ] struct { } ) if len ( n . ( [ ] interface { } ) ) < 1 { return errors . New ( " " ) } for ni , ne := range n . ( [ ] interface { } ) { nm := ne . ( map [ string ] interface { } ) name , err := diskLabelOrName ( nm ) if err != nil { return fmt . Errorf ( " " , ni , err ) } if _ , ok := names [ name ] ; ok { return fmt . Errorf ( " " , name ) } if path == " " { return fmt . Errorf ( " " , ni ) } if _ , ok := attachments [ path ] ; ok { return fmt . Errorf ( " " , path ) } attachments [ path ] = struct { } { } } if _ , ok := units [ nm [ " " ] . ( int ) ] ; ok { return fmt . Errorf ( " " , nm [ " " ] . ( int ) ) } names [ name ] = struct { } { } units [ nm [ " " ] . ( int ) ] = struct { } { } r := NewDiskSubresource ( c , d , nm , nil , ni ) if err := r . DiffGeneral ( ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } if _ , ok := units [ 0 ] ; ! ok { return errors . New ( " " ) } ods := o . ( [ ] interface { } ) nds := n . ( [ ] interface { } ) normalized := make ( [ ] interface { } , len ( ods ) ) nextNew : for _ , ne := range nds { nm := ne . ( map [ string ] interface { } ) for oi , oe := range ods { om := oe . ( map [ string ] interface { } ) var oname , nname string var err error if oname , err = diskLabelOrName ( om ) ; err != nil { return fmt . Errorf ( " " , oi , err ) } if nname , err = diskLabelOrName ( nm ) ; err != nil { return fmt . Errorf ( " " , oi , err ) } if err := r . DiffExisting ( ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } normalized [ oi ] = r . Data ( ) continue nextNew } } nm [ " " ] = " " nm [ " " ] = " " if a , ok := nm [ " " ] ; ! ok || ! a . ( bool ) { nm [ " " ] = " " } else { _ , ok := nm [ " " ] if ok { delete ( nm , " " ) } } if dsID , ok := nm [ " " ] ; ! ok || dsID == " " { nm [ " " ] = diskDatastoreComputedName } normalized = append ( normalized , nm ) } } nv , err := copystructure . Copy ( ods [ ni ] ) if err != nil { return fmt . Errorf ( " " , ni , err ) } nm := nv . ( map [ string ] interface { } ) switch { case nm [ " " ] . ( bool ) : fallthrough case nm [ " " ] . ( bool ) : nm [ " " ] = diskDetachedName default : nm [ " " ] = diskDeletedName } normalized [ ni ] = nm } log . Printf ( " " ) return d . SetNew ( subresourceTypeDisk , normalized ) } 
func DiskCloneValidateOperation ( d * schema . ResourceDiff , c * govmomi . Client , l object . VirtualDeviceList , linked bool ) error { log . Printf ( " " ) devices := SelectDisks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( curSet ) ) sort . Sort ( virtualDiskSubresourceSorter ( curSet ) ) log . Printf ( " " , subresourceListString ( curSet ) ) } for i , device := range devices { m := make ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( " " , err ) } r := NewDiskSubresource ( c , d , m , nil , i ) if err := r . Read ( l ) ; err != nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } tr := NewDiskSubresource ( c , d , targetM , nil , i ) if err != nil { return fmt . Errorf ( " " , tr . Addr ( ) , err ) } targetPath := r . Get ( " " ) . ( string ) sourceSize := r . Get ( " " ) . ( int ) targetSize := tr . Get ( " " ) . ( int ) targetThin := tr . Get ( " " ) . ( bool ) targetEager := tr . Get ( " " ) . ( bool ) var sourceThin , sourceEager bool if b := r . Get ( " " ) ; b != nil { sourceThin = b . ( bool ) } if b := r . Get ( " " ) ; b != nil { sourceEager = b . ( bool ) } switch { case linked : switch { case sourceSize != targetSize : return fmt . Errorf ( " " , tr . Addr ( ) , targetName , sourceSize ) case sourceThin != targetThin : return fmt . Errorf ( " " , tr . Addr ( ) , targetName , sourceThin ) case sourceEager != targetEager : return fmt . Errorf ( " " , tr . Addr ( ) , targetName , sourceEager ) } default : if sourceSize > targetSize { return fmt . Errorf ( " " , tr . Addr ( ) , targetName , sourceSize ) } } if err != nil { return fmt . Errorf ( " " , tr . Addr ( ) , targetPath , err ) } if ct != SubresourceControllerTypeSCSI { return fmt . Errorf ( " " , tr . Addr ( ) , ct , targetPath ) } } log . Printf ( " " ) return nil } 
func DiskMigrateRelocateOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . VirtualMachineRelocateSpecDiskLocator , bool , error ) { log . Printf ( " " ) ods , nds := d . GetChange ( subresourceTypeDisk ) var relocators [ ] types . VirtualMachineRelocateSpecDiskLocator var relocateOK bool var name string var err error if name , err = diskLabelOrName ( nm ) ; err != nil { return nil , false , fmt . Errorf ( " " , ni , err ) } if name == diskDeletedName || name == diskDetachedName { continue } for _ , oe := range ods . ( [ ] interface { } ) { om := oe . ( map [ string ] interface { } ) if nm [ " " ] == om [ " " ] { } } r := NewDiskSubresource ( c , d , nm , om , ni ) relocator , err := r . Relocate ( l , false ) if err != nil { return nil , false , fmt . Errorf ( " " , r . Addr ( ) , err ) } if d . Get ( " " ) . ( string ) == relocator . Datastore . Value { log . Printf ( " " , r . Addr ( ) ) break } relocators = append ( relocators , relocator ) } } } if ! relocateOK { log . Printf ( " " ) return nil , false , nil } log . Printf ( " " , diskRelocateListString ( relocators ) ) log . Printf ( " " ) return relocators , true , nil } 
func DiskCloneRelocateOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( [ ] types . VirtualMachineRelocateSpecDiskLocator , error ) { log . Printf ( " " ) devices := SelectDisks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( curSet ) ) sort . Sort ( virtualDiskSubresourceSorter ( curSet ) ) log . Printf ( " " , subresourceListString ( curSet ) ) log . Printf ( " " ) var relocators [ ] types . VirtualMachineRelocateSpecDiskLocator for i , device := range devices { m := curSet [ i ] . ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return nil , fmt . Errorf ( " " , err ) } r := NewDiskSubresource ( c , d , m , nil , i ) } if err != nil { return nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } relocators = append ( relocators , relocator ) } log . Printf ( " " , diskRelocateListString ( relocators ) ) log . Printf ( " " ) return relocators , nil } 
func DiskPostCloneOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) ( object . VirtualDeviceList , [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " ) devices := SelectDisks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " , subresourceListString ( curSet ) ) sort . Sort ( virtualDiskSubresourceSorter ( curSet ) ) log . Printf ( " " , subresourceListString ( curSet ) ) var spec [ ] types . BaseVirtualDeviceConfigSpec var updates [ ] interface { } log . Printf ( " " ) for i , device := range devices { src := curSet [ i ] . ( map [ string ] interface { } ) vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return nil , nil , fmt . Errorf ( " " , vd . Key ) } src [ " " ] = int ( vd . Key ) var err error src [ " " ] , err = computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return nil , nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , nil , fmt . Errorf ( " " , src [ " " ] . ( int ) , err ) } rOld := NewDiskSubresource ( c , d , old . ( map [ string ] interface { } ) , nil , i ) if err := rOld . Read ( l ) ; err != nil { return nil , nil , fmt . Errorf ( " " , rOld . Addr ( ) , err ) } new , err := copystructure . Copy ( rOld . Data ( ) ) if err != nil { return nil , nil , fmt . Errorf ( " " , src [ " " ] . ( int ) , err ) } for k , v := range src { case " " : if src [ " " ] != string ( types . SharesLevelCustom ) { continue } } new . ( map [ string ] interface { } ) [ k ] = v } rNew := NewDiskSubresource ( c , d , new . ( map [ string ] interface { } ) , rOld . Data ( ) , i ) if ! reflect . DeepEqual ( rNew . Data ( ) , rOld . Data ( ) ) { uspec , err := rNew . Update ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , rNew . Addr ( ) , err ) } l = applyDeviceChange ( l , uspec ) spec = append ( spec , uspec ... ) } updates = append ( updates , rNew . Data ( ) ) } cspec , err := r . Create ( l ) if err != nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = applyDeviceChange ( l , cspec ) spec = append ( spec , cspec ... ) updates = append ( updates , r . Data ( ) ) } log . Printf ( " " , subresourceListString ( updates ) ) if err := d . Set ( subresourceTypeDisk , updates ) ; err != nil { return nil , nil , err } log . Printf ( " " , DeviceListString ( l ) ) log . Printf ( " " , DeviceChangeString ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func DiskImportOperation ( d * schema . ResourceData , c * govmomi . Client , l object . VirtualDeviceList ) error { log . Printf ( " " ) devices := SelectDisks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) log . Printf ( " " ) for i , device := range devices { vd := device . GetVirtualDevice ( ) ctlr := l . FindByKey ( vd . ControllerKey ) if ctlr == nil { return fmt . Errorf ( " " , vd . Key ) } addr , err := computeDevAddr ( vd , ctlr . ( types . BaseVirtualController ) ) if err != nil { return fmt . Errorf ( " " , err ) } ct , _ , _ , err := splitDevAddr ( addr ) if err != nil { return fmt . Errorf ( " " , i , addr , err ) } if ct != SubresourceControllerTypeSCSI { return fmt . Errorf ( " " , i , ct , addr ) } } m := make ( map [ string ] interface { } ) m [ " " ] = addr curSet = append ( curSet , m ) } log . Printf ( " " , subresourceListString ( curSet ) ) if err := d . Set ( subresourceTypeDisk , curSet ) ; err != nil { return err } log . Printf ( " " ) return nil } 
func ReadDiskAttrsForDataSource ( l object . VirtualDeviceList , count int ) ( [ ] map [ string ] interface { } , error ) { log . Printf ( " " , count ) devices := SelectDisks ( l , count ) log . Printf ( " " , DeviceListString ( devices ) ) sort . Sort ( devSort ) devices = devSort . Sort log . Printf ( " " , DeviceListString ( devices ) ) var out [ ] map [ string ] interface { } for i , device := range devices { disk := device . ( * types . VirtualDisk ) backing , ok := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) if ! ok { return nil , fmt . Errorf ( " " , i , disk . Backing ) } m := make ( map [ string ] interface { } ) var eager , thin bool if backing . EagerlyScrub != nil { eager = * backing . EagerlyScrub } if backing . ThinProvisioned != nil { thin = * backing . ThinProvisioned } m [ " " ] = diskCapacityInGiB ( disk ) m [ " " ] = eager m [ " " ] = thin out = append ( out , m ) } log . Printf ( " " , out ) return out , nil } 
func ( r * DiskSubresource ) Create ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) var spec [ ] types . BaseVirtualDeviceConfigSpec disk , err := r . createDisk ( l ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } if err := r . expandDiskSettings ( disk ) ; err != nil { return nil , err } } dspec , err := object . VirtualDeviceList { disk } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationAdd ) if err != nil { return nil , err } if len ( dspec ) != 1 { return nil , fmt . Errorf ( " " , len ( dspec ) ) } } spec = append ( spec , dspec ... ) log . Printf ( " " , r , DeviceChangeString ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * DiskSubresource ) Read ( l object . VirtualDeviceList ) error { log . Printf ( " " , r ) disk , err := r . findVirtualDisk ( l , true ) if err != nil { return fmt . Errorf ( " " , err ) } unit , ctlr , err := r . findControllerInfo ( l , disk ) if err != nil { return err } r . Set ( " " , unit ) if err := r . SaveDevIDs ( disk , ctlr ) ; err != nil { return err } if r . Get ( " " ) != nil { attach = r . Get ( " " ) . ( bool ) } if ! ok { return fmt . Errorf ( " " , r . Get ( " " ) . ( string ) , disk . Backing ) } r . Set ( " " , b . Uuid ) r . Set ( " " , b . DiskMode ) r . Set ( " " , b . WriteThrough ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) && b . Sharing != " " { r . Set ( " " , b . Sharing ) } if ! attach { r . Set ( " " , b . ThinProvisioned ) r . Set ( " " , b . EagerlyScrub ) } r . Set ( " " , b . Datastore . Value ) if ok := dp . FromString ( b . FileName ) ; ! ok { return fmt . Errorf ( " " , b . FileName ) } r . Set ( " " , dp . Path ) r . Set ( " " , diskCapacityInGiB ( disk ) ) } if allocation := disk . StorageIOAllocation ; allocation != nil { r . Set ( " " , allocation . Limit ) r . Set ( " " , allocation . Reservation ) if shares := allocation . Shares ; shares != nil { r . Set ( " " , string ( shares . Level ) ) r . Set ( " " , shares . Shares ) } } log . Printf ( " " , r ) return nil } 
func ( r * DiskSubresource ) Update ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) disk , err := r . findVirtualDisk ( l , false ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , fmt . Errorf ( " " , err ) } r . SetRestart ( " " ) if err := r . SaveDevIDs ( disk , ctlr ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } } } dspec , err := object . VirtualDeviceList { disk } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationEdit ) if err != nil { return nil , err } if len ( dspec ) != 1 { return nil , fmt . Errorf ( " " , len ( dspec ) ) } log . Printf ( " " , r , DeviceChangeString ( dspec ) ) log . Printf ( " " , r ) return dspec , nil } 
func ( r * DiskSubresource ) Delete ( l object . VirtualDeviceList ) ( [ ] types . BaseVirtualDeviceConfigSpec , error ) { log . Printf ( " " , r ) disk , err := r . findVirtualDisk ( l , false ) if err != nil { return nil , fmt . Errorf ( " " , err ) } deleteSpec , err := object . VirtualDeviceList { disk } . ConfigSpec ( types . VirtualDeviceConfigSpecOperationRemove ) if err != nil { return nil , err } if len ( deleteSpec ) != 1 { return nil , fmt . Errorf ( " " , len ( deleteSpec ) ) } if r . Get ( " " ) . ( bool ) || r . Get ( " " ) . ( bool ) { } log . Printf ( " " , r , DeviceChangeString ( deleteSpec ) ) log . Printf ( " " , r ) return deleteSpec , nil } 
func ( r * DiskSubresource ) DiffExisting ( ) error { log . Printf ( " " , r ) name , err := diskLabelOrName ( r . data ) if err != nil { return err } if olabel != " " && nlabel == " " { return errors . New ( " " ) } r . Set ( " " , oname . ( string ) ) } odaddr , _ := r . GetChange ( " " ) ouuid , _ := r . GetChange ( " " ) r . Set ( " " , okey ) r . Set ( " " , odaddr ) r . Set ( " " , ouuid ) if ! r . Get ( " " ) . ( bool ) { r . Set ( " " , opath . ( string ) ) } if dsID == " " { r . Set ( " " , diskDatastoreComputedName ) } else { r . Set ( " " , dsID ) } default : if err = r . normalizeDiskDatastore ( ) ; err != nil { return err } } } if r . Get ( " " ) . ( string ) != string ( types . SharesLevelCustom ) { r . Set ( " " , osc ) } if osize . ( int ) > nsize . ( int ) { return fmt . Errorf ( " " , name , osize . ( int ) , nsize . ( int ) ) } } if _ , err = r . GetWithVeto ( " " ) ; err != nil { return fmt . Errorf ( " " , name , err ) } } } } log . Printf ( " " , r ) return nil } 
func ( r * DiskSubresource ) DiffGeneral ( ) error { log . Printf ( " " , r ) name , err := diskLabelOrName ( r . data ) if err != nil { return err } maxUnit := ctlrCount * 15 - 1 currentUnit := r . Get ( " " ) . ( int ) if currentUnit > maxUnit { return fmt . Errorf ( " " , name , currentUnit , maxUnit , ctlrCount ) } if r . Get ( " " ) . ( bool ) { switch { case r . Get ( " " ) . ( string ) == " " : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( int ) > 0 : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( bool ) : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( bool ) : return fmt . Errorf ( " " , name ) } } else { } } if r . Get ( " " ) . ( string ) != string ( types . VirtualDiskSharingSharingNone ) { if version . Older ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { return fmt . Errorf ( " " ) } } } log . Printf ( " " , r ) return nil } 
func ( r * DiskSubresource ) normalizeDiskDatastore ( ) error { podID := r . rdd . Get ( " " ) . ( string ) dsID , _ := r . GetChange ( " " ) if podID == " " { return nil } log . Printf ( " " , r ) pod , err := storagepod . FromID ( r . client , podID ) if err != nil { return fmt . Errorf ( " " , podID , err ) } ds , err := datastore . FromID ( r . client , dsID . ( string ) ) if err != nil { return fmt . Errorf ( " " , dsID , err ) } isMember , err := storagepod . IsMember ( pod , ds ) if err != nil { return fmt . Errorf ( " " , err ) } if ! isMember { log . Printf ( " " , r , ds . Name ( ) , pod . Name ( ) , ) dsID = diskDatastoreComputedName } r . Set ( " " , dsID ) return nil } 
func ( r * DiskSubresource ) validateStorageRelocateDiff ( ) error { log . Printf ( " " , r ) if err := r . blockRelocateAttachedDisks ( ) ; err != nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * DiskSubresource ) Relocate ( l object . VirtualDeviceList , clone bool ) ( types . VirtualMachineRelocateSpecDiskLocator , error ) { log . Printf ( " " , r ) disk , err := r . findVirtualDisk ( l , clone ) var relocate types . VirtualMachineRelocateSpecDiskLocator if err != nil { return relocate , fmt . Errorf ( " " , err ) } } relocate . DiskId = disk . Key if dsID == " " { } ds , err := datastore . FromID ( r . client , dsID ) if err != nil { return relocate , err } dsref := ds . Reference ( ) relocate . Datastore = dsref backing := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) backing . FileName = ds . Path ( " " ) backing . Datastore = & dsref relocate . DiskBackingInfo = backing } log . Printf ( " " , r ) return relocate , nil } 
func ( r * DiskSubresource ) String ( ) string { p := diskPathOrName ( r . data ) if p == " " { p = " " } return fmt . Sprintf ( " " , r . Subresource . String ( ) , p ) } 
func ( r * DiskSubresource ) expandDiskSettings ( disk * types . VirtualDisk ) error { b . DiskMode = r . GetWithRestart ( " " ) . ( string ) b . WriteThrough = structure . BoolPtr ( r . GetWithRestart ( " " ) . ( bool ) ) if version . Newer ( viapi . VSphereVersion { Product : version . Product , Major : 6 } ) { b . Sharing = r . GetWithRestart ( " " ) . ( string ) } var v interface { } if v , err = r . GetWithVeto ( " " ) ; err != nil { return err } b . ThinProvisioned = structure . BoolPtr ( v . ( bool ) ) if v , err = r . GetWithVeto ( " " ) ; err != nil { return err } b . EagerlyScrub = structure . BoolPtr ( v . ( bool ) ) if os . ( int ) > ns . ( int ) { return fmt . Errorf ( " " ) } disk . CapacityInBytes = structure . GiBToByte ( ns . ( int ) ) disk . CapacityInKB = disk . CapacityInBytes / 1024 } alloc := & types . StorageIOAllocationInfo { Limit : structure . Int64Ptr ( int64 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int32Ptr ( int32 ( r . Get ( " " ) . ( int ) ) ) , Shares : & types . SharesInfo { Shares : int32 ( r . Get ( " " ) . ( int ) ) , Level : types . SharesLevel ( r . Get ( " " ) . ( string ) ) , } , } disk . StorageIOAllocation = alloc return nil } 
func ( r * DiskSubresource ) createDisk ( l object . VirtualDeviceList ) ( * types . VirtualDisk , error ) { disk := new ( types . VirtualDisk ) disk . Backing = new ( types . VirtualDiskFlatVer2BackingInfo ) } } return disk , nil } 
func ( r * DiskSubresource ) assignDisk ( l object . VirtualDeviceList , disk * types . VirtualDisk ) ( types . BaseVirtualController , error ) { number := r . Get ( " " ) . ( int ) if err != nil { return nil , err } units [ scsiUnit ] = true ckey := ctlr . GetVirtualController ( ) . Key for _ , device := range l { d := device . GetVirtualDevice ( ) if d . ControllerKey != ckey || d . UnitNumber == nil { continue } units [ * d . UnitNumber ] = true } } if units [ unit ] { return nil , fmt . Errorf ( " " , unit , bus ) } disk . UnitNumber = & unit return ctlr , nil } 
func ( r * Subresource ) findControllerInfo ( l object . VirtualDeviceList , disk * types . VirtualDisk ) ( int , types . BaseVirtualController , error ) { ctlr := l . FindByKey ( disk . ControllerKey ) if ctlr == nil { return - 1 , nil , fmt . Errorf ( " " , disk . ControllerKey , disk . Key ) } if disk . UnitNumber == nil { return - 1 , nil , fmt . Errorf ( " " , disk . Key ) } sc , ok := ctlr . ( types . BaseVirtualSCSIController ) if ! ok { return - 1 , nil , fmt . Errorf ( " " , ctlr . GetVirtualDevice ( ) . Key , ctlr ) } unit := * disk . UnitNumber if unit > sc . GetVirtualSCSIController ( ) . ScsiCtlrUnitNumber { unit -- } unit = unit + 15 * sc . GetVirtualSCSIController ( ) . BusNumber return int ( unit ) , ctlr . ( types . BaseVirtualController ) , nil } 
func diskRelocateListString ( relocators [ ] types . VirtualMachineRelocateSpecDiskLocator ) string { var out [ ] string for _ , relocate := range relocators { out = append ( out , diskRelocateString ( relocate ) ) } return strings . Join ( out , " " ) } 
func diskRelocateString ( relocate types . VirtualMachineRelocateSpecDiskLocator ) string { key := relocate . DiskId var locstring string if backing , ok := relocate . DiskBackingInfo . ( * types . VirtualDiskFlatVer2BackingInfo ) ; ok && backing != nil { locstring = backing . FileName } else { locstring = relocate . Datastore . Value } return fmt . Sprintf ( " " , key , locstring ) } 
func ( l virtualDeviceListSorter ) Less ( i , j int ) bool { li := l . Sort [ i ] lj := l . Sort [ j ] liCtlr := l . DeviceList . FindByKey ( li . GetVirtualDevice ( ) . ControllerKey ) ljCtlr := l . DeviceList . FindByKey ( lj . GetVirtualDevice ( ) . ControllerKey ) if liCtlr == nil || ljCtlr == nil { panic ( errors . New ( " " ) ) } if liCtlr . ( types . BaseVirtualController ) . GetVirtualController ( ) . BusNumber < liCtlr . ( types . BaseVirtualController ) . GetVirtualController ( ) . BusNumber { return true } liUnit := li . GetVirtualDevice ( ) . UnitNumber ljUnit := lj . GetVirtualDevice ( ) . UnitNumber if liUnit == nil || ljUnit == nil { panic ( errors . New ( " " ) ) } return * liUnit < * ljUnit } 
func ( l virtualDeviceListSorter ) Swap ( i , j int ) { l . Sort [ i ] , l . Sort [ j ] = l . Sort [ j ] , l . Sort [ i ] } 
func ( s virtualDiskSubresourceSorter ) Less ( i , j int ) bool { mi := s [ i ] . ( map [ string ] interface { } ) mj := s [ j ] . ( map [ string ] interface { } ) return mi [ " " ] . ( int ) < mj [ " " ] . ( int ) } 
func ( s virtualDiskSubresourceSorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] } 
func datastorePathHasBase ( p , b string ) bool { dp := & object . DatastorePath { } if ok := dp . FromString ( p ) ; ! ok { return false } return path . Base ( dp . Path ) == path . Base ( b ) } 
func SelectDisks ( l object . VirtualDeviceList , count int ) object . VirtualDeviceList { devices := l . Select ( func ( device types . BaseVirtualDevice ) bool { if disk , ok := device . ( * types . VirtualDisk ) ; ok { ctlr , err := findControllerForDevice ( l , disk ) if err != nil { log . Printf ( " " , l . Name ( disk ) , err ) return false } if sc , ok := ctlr . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber < int32 ( count ) { cd := sc . ( types . BaseVirtualDevice ) log . Printf ( " " , l . Name ( cd ) , l . Name ( disk ) ) return true } } return false } ) return devices } 
func diskLabelOrName ( data map [ string ] interface { } ) ( string , error ) { var label , name string if v , ok := data [ " " ] ; ok && v != nil { label = v . ( string ) } if v , ok := data [ " " ] ; ok && v != nil { name = v . ( string ) } if name != " " { name = path . Base ( name ) } log . Printf ( " " , label , name ) switch { case label == " " && name == " " : return " " , errors . New ( " " ) case label != " " && name != " " : return " " , errors . New ( " " ) case label != " " : log . Printf ( " " , label ) return label , nil } log . Printf ( " " , name ) return name , nil } 
func diskPathOrName ( data map [ string ] interface { } ) string { var path , name string if v , ok := data [ " " ] ; ok && v != nil { path = v . ( string ) } if v , ok := data [ " " ] ; ok && v != nil { name = v . ( string ) } if path != " " { log . Printf ( " " , path ) return path } log . Printf ( " " , name ) return name } 
func ( r * DiskSubresource ) findVirtualDisk ( l object . VirtualDeviceList , fallback bool ) ( * types . VirtualDisk , error ) { device , err := r . findVirtualDiskByUUIDOrAddress ( l , fallback ) if err != nil { return nil , err } return device . ( * types . VirtualDisk ) , nil } 
func diskCapacityInGiB ( disk * types . VirtualDisk ) int { if disk . CapacityInBytes > 0 { return int ( structure . ByteToGiB ( disk . CapacityInBytes ) . ( int64 ) ) } log . Printf ( " " , object . VirtualDeviceList { } . Name ( disk ) , ) return int ( structure . ByteToGiB ( disk . CapacityInKB * 1024 ) . ( int64 ) ) } 
func hostNetworkSystemFromHostSystem ( hs * object . HostSystem ) ( * object . HostNetworkSystem , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) return hs . ConfigManager ( ) . NetworkSystem ( ctx ) } 
func hostNetworkSystemFromHostSystemID ( client * govmomi . Client , hsID string ) ( * object . HostNetworkSystem , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return nil , err } return hostNetworkSystemFromHostSystem ( hs ) } 
func hostVSwitchFromName ( client * govmomi . Client , ns * object . HostNetworkSystem , name string ) ( * types . HostVirtualSwitch , error ) { var mns mo . HostNetworkSystem pc := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) if err := pc . RetrieveOne ( ctx , ns . Reference ( ) , [ ] string { " " } , & mns ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , sw := range mns . NetworkInfo . Vswitch { if sw . Name == name { return & sw , nil } } return nil , fmt . Errorf ( " " , name ) } 
func hostPortGroupFromName ( client * govmomi . Client , ns * object . HostNetworkSystem , name string ) ( * types . HostPortGroup , error ) { var mns mo . HostNetworkSystem pc := client . PropertyCollector ( ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) if err := pc . RetrieveOne ( ctx , ns . Reference ( ) , [ ] string { " " } , & mns ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , pg := range mns . NetworkInfo . Portgroup { if pg . Spec . Name == name { return & pg , nil } } return nil , fmt . Errorf ( " " , name ) } 
func networkObjectFromHostSystem ( client * govmomi . Client , hs * object . HostSystem , name string ) ( * object . Network , error ) { } finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , defaultAPITimeout ) defer cancel ( ) nets , err := finder . NetworkList ( ctx , " " + name ) if err != nil { return nil , err } for _ , n := range nets { net , ok := n . ( * object . Network ) if ! ok { } props , err := network . Properties ( net ) if err != nil { return nil , err } for _ , hsRef := range props . Host { if hsRef . Value == hs . Reference ( ) . Value { } } } return nil , fmt . Errorf ( " " , name , hs . Reference ( ) . Value ) } 
func resourceVSphereLicenseUpdate ( d * schema . ResourceData , meta interface { } ) error { log . Println ( " " ) client := meta . ( * VSphereClient ) . vimClient manager := license . NewManager ( client . Client ) if key , ok := d . GetOk ( " " ) ; ok { licenseKey := key . ( string ) if ! isKeyPresent ( licenseKey , manager ) { return ErrNoSuchKeyFound } if d . HasChange ( " " ) { labelMap := d . Get ( " " ) . ( map [ string ] interface { } ) err := updateLabels ( manager , licenseKey , labelMap ) if err != nil { return err } } } return resourceVSphereLicenseRead ( d , meta ) } 
func isKeyPresent ( key string , manager * license . Manager ) bool { infoList , _ := manager . List ( context . TODO ( ) ) for _ , info := range infoList { if info . LicenseKey == key { return true } } return false } 
func UpdateLabel ( ctx context . Context , m * license . Manager , licenseKey string , key string , val string ) error { req := types . UpdateLicenseLabel { This : m . Reference ( ) , LicenseKey : licenseKey , LabelKey : key , LabelValue : val , } _ , err := methods . UpdateLicenseLabel ( ctx , m . Client ( ) , & req ) return err } 
func DecodeError ( info types . LicenseManagerLicenseInfo ) error { for _ , property := range info . Properties { if property . Key == " " { return errors . New ( property . Value . ( string ) ) } } return nil } 
func resourceVSphereVAppContainerApplyTags ( d * schema . ResourceData , meta interface { } , va * object . VirtualApp ) error { tagsClient , err := tagsClientIfDefined ( d , meta ) if err != nil { return err } return nil } log . Printf ( " " , resourceVSphereVAppContainerIDString ( d ) ) return processTagDiff ( tagsClient , d , va ) } 
func resourceVSphereVAppContainerReadTags ( d * schema . ResourceData , meta interface { } , va * object . VirtualApp ) error { if tagsClient , _ := meta . ( * VSphereClient ) . TagsClient ( ) ; tagsClient != nil { log . Printf ( " " , resourceVSphereVAppContainerIDString ( d ) ) if err := readTagsForResource ( tagsClient , va , d ) ; err != nil { return err } } else { log . Printf ( " " , resourceVSphereVAppContainerIDString ( d ) ) } return nil } 
func expandClusterVMHostRuleInfo ( d * schema . ResourceData ) ( * types . ClusterVmHostRuleInfo , error ) { obj := & types . ClusterVmHostRuleInfo { ClusterRuleInfo : types . ClusterRuleInfo { Enabled : structure . GetBool ( d , " " ) , Mandatory : structure . GetBool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , UserCreated : structure . BoolPtr ( true ) , } , AffineHostGroupName : d . Get ( " " ) . ( string ) , AntiAffineHostGroupName : d . Get ( " " ) . ( string ) , VmGroupName : d . Get ( " " ) . ( string ) , } return obj , nil } 
func flattenClusterVMHostRuleInfo ( d * schema . ResourceData , obj * types . ClusterVmHostRuleInfo ) error { return structure . SetBatch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : obj . AffineHostGroupName , " " : obj . AntiAffineHostGroupName , " " : obj . VmGroupName , } ) } 
func resourceVSphereComputeClusterVMHostRuleFindEntryByName ( cluster * object . ClusterComputeResource , name string , ) ( * types . ClusterVmHostRuleInfo , error ) { props , err := clustercomputeresource . Properties ( cluster ) if err != nil { return nil , fmt . Errorf ( " " , err ) } for _ , info := range props . ConfigurationEx . ( * types . ClusterConfigInfoEx ) . Rule { if info . GetClusterRuleInfo ( ) . Name == name { if vmHostRuleInfo , ok := info . ( * types . ClusterVmHostRuleInfo ) ; ok { log . Printf ( " " , name , cluster . Name ( ) ) return vmHostRuleInfo , nil } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } 
func resourceVSphereComputeClusterVMHostRuleObjects ( d * schema . ResourceData , meta interface { } , ) ( * object . ClusterComputeResource , int32 , error ) { if d . Id ( ) != " " { return resourceVSphereComputeClusterVMHostRuleObjectsFromID ( d , meta ) } return resourceVSphereComputeClusterVMHostRuleObjectsFromAttributes ( d , meta ) } 
func resourceVSphereVirtualMachineMigrateState ( version int , os * terraform . InstanceState , meta interface { } ) ( * terraform . InstanceState , error ) { } } var migrateFunc func ( * terraform . InstanceState , interface { } ) error switch version { case 2 : log . Printf ( " " , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV3 case 1 : log . Printf ( " " , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV2 case 0 : log . Printf ( " " , version , os ) migrateFunc = migrateVSphereVirtualMachineStateV1 default : return os , nil } if err := migrateFunc ( os , meta ) ; err != nil { return nil , err } version ++ log . Printf ( " " , version , os ) return resourceVSphereVirtualMachineMigrateState ( version , os , meta ) } 
func migrateVSphereVirtualMachineStateV3 ( is * terraform . InstanceState , meta interface { } ) error { id := is . ID log . Printf ( " " , id ) vm , err := virtualmachine . FromUUID ( client , id ) if err != nil { return fmt . Errorf ( " " , err ) } props , err := virtualmachine . Properties ( vm ) if err != nil { return fmt . Errorf ( " " , err ) } l := object . VirtualDeviceList ( props . Config . Hardware . Device ) for i := 0 ; i < diskCnt ; i ++ { v , ok := is . Attributes [ fmt . Sprintf ( " " , i ) ] if ! ok { return fmt . Errorf ( " " , i ) } key , err := strconv . Atoi ( v ) if err != nil { return fmt . Errorf ( " " , i , err ) } if key < 1 { } device := l . FindByKey ( int32 ( key ) ) if device == nil { } disk , ok := device . ( * types . VirtualDisk ) if ! ok { } backing , ok := disk . Backing . ( * types . VirtualDiskFlatVer2BackingInfo ) if ! ok { } is . Attributes [ fmt . Sprintf ( " " , i ) ] = backing . Uuid } d := resourceVSphereVirtualMachine ( ) . Data ( & terraform . InstanceState { } ) log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) return nil } 
func migrateVSphereVirtualMachineStateV2 ( is * terraform . InstanceState , meta interface { } ) error { name := is . ID id := is . Attributes [ " " ] if id == " " { return fmt . Errorf ( " " , name ) } log . Printf ( " " , name , id ) vm , err := virtualmachine . FromUUID ( client , id ) if err != nil { return fmt . Errorf ( " " , err ) } props , err := virtualmachine . Properties ( vm ) if err != nil { return fmt . Errorf ( " " , err ) } maxBus := diskCnt / 15 l := object . VirtualDeviceList ( props . Config . Hardware . Device ) for k , v := range is . Attributes { if ! regexp . MustCompile ( " \\ \\ " ) . MatchString ( k ) { continue } key , _ := strconv . Atoi ( v ) if key < 1 { continue } device := l . FindByKey ( int32 ( key ) ) if device == nil { continue } ctlr := l . FindByKey ( device . GetVirtualDevice ( ) . ControllerKey ) if ctlr == nil { continue } if sc , ok := ctlr . ( types . BaseVirtualSCSIController ) ; ok && sc . GetVirtualSCSIController ( ) . BusNumber > int32 ( maxBus ) { maxBus = int ( sc . GetVirtualSCSIController ( ) . BusNumber ) } } d := resourceVSphereVirtualMachine ( ) . Data ( & terraform . InstanceState { } ) d . Set ( " " , maxBus + 1 ) if err := virtualdevice . DiskImportOperation ( d , client , object . VirtualDeviceList ( props . Config . Hardware . Device ) ) ; err != nil { return err } rs := resourceVSphereVirtualMachine ( ) . Schema var guestNetTimeout string switch is . Attributes [ " " ] { case " " : guestNetTimeout = " " default : guestNetTimeout = fmt . Sprintf ( " " , rs [ " " ] . Default ) } is . ID = id is . Attributes [ " " ] = " " is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = guestNetTimeout is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , maxBus + 1 ) for k , v := range d . State ( ) . Attributes { if strings . HasPrefix ( k , " " ) { is . Attributes [ k ] = v } } log . Printf ( " " , resourceVSphereVirtualMachineIDString ( d ) ) return nil } 
func NewEnvironmentBrowser ( c * vim25 . Client , ref types . ManagedObjectReference ) * EnvironmentBrowser { return & EnvironmentBrowser { Common : object . NewCommon ( c , ref ) , } } 
func ( b * EnvironmentBrowser ) DefaultDevices ( ctx context . Context , key string , host * object . HostSystem ) ( object . VirtualDeviceList , error ) { var eb mo . EnvironmentBrowser err := b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err != nil { return nil , err } req := types . QueryConfigOption { This : b . Reference ( ) , Key : key , } if host != nil { ref := host . Reference ( ) req . Host = & ref } res , err := methods . QueryConfigOption ( ctx , b . Client ( ) , & req ) if err != nil { return nil , err } if res . Returnval == nil { return nil , errors . New ( " " ) } return object . VirtualDeviceList ( res . Returnval . DefaultDevice ) , nil } 
func ( b * EnvironmentBrowser ) OSFamily ( ctx context . Context , guest string ) ( string , error ) { var eb mo . EnvironmentBrowser err := b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err != nil { return " " , err } req := types . QueryConfigOption { This : b . Reference ( ) , } res , err := methods . QueryConfigOption ( ctx , b . Client ( ) , & req ) if err != nil { return " " , err } if res . Returnval == nil { return " " , errors . New ( " " ) } for _ , osd := range res . Returnval . GuestOSDescriptor { if osd . Id == guest { family := osd . Family log . Printf ( " " , guest , family ) return family , nil } } return " " , fmt . Errorf ( " " , guest ) } 
func ( b * EnvironmentBrowser ) QueryConfigOptionDescriptor ( ctx context . Context ) ( [ ] types . VirtualMachineConfigOptionDescriptor , error ) { req := types . QueryConfigOptionDescriptor { This : b . Reference ( ) , } res , err := methods . QueryConfigOptionDescriptor ( ctx , b . Client ( ) , & req ) if err != nil { return nil , err } return res . Returnval , nil } 
func ( p RootPathParticle ) RootFromDatacenter ( dc * object . Datacenter ) string { return dc . InventoryPath + " " + string ( p ) } 
func ( p RootPathParticle ) PathFromDatacenter ( dc * object . Datacenter , relative string ) string { return p . RootFromDatacenter ( dc ) + " " + relative } 
func ( p RootPathParticle ) SplitDatacenter ( inventoryPath string ) ( string , error ) { s := strings . SplitN ( inventoryPath , p . Delimiter ( ) , 2 ) if len ( s ) != 2 { return inventoryPath , fmt . Errorf ( " " , inventoryPath , p . Delimiter ( ) ) } return s [ 0 ] , nil } 
func ( p RootPathParticle ) SplitRelativeFolder ( inventoryPath string ) ( string , error ) { relative , err := p . SplitRelative ( inventoryPath ) if err != nil { return inventoryPath , err } return path . Dir ( relative ) , nil } 
func ( p RootPathParticle ) NewRootFromPath ( inventoryPath string , newParticle RootPathParticle ) ( string , error ) { dcPath , err := p . SplitDatacenter ( inventoryPath ) if err != nil { return inventoryPath , err } return fmt . Sprintf ( " " , dcPath , newParticle ) , nil } 
func ( p RootPathParticle ) PathFromNewRoot ( inventoryPath string , newParticle RootPathParticle , relative string ) ( string , error ) { rootPath , err := p . NewRootFromPath ( inventoryPath , newParticle ) if err != nil { return inventoryPath , err } return path . Clean ( fmt . Sprintf ( " " , rootPath , relative ) ) , nil } 
func datacenterPathFromHostSystemID ( client * govmomi . Client , hsID string ) ( string , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return " " , err } return RootPathParticleHost . SplitDatacenter ( hs . InventoryPath ) } 
func datastoreRootPathFromHostSystemID ( client * govmomi . Client , hsID string ) ( string , error ) { hs , err := hostsystem . FromID ( client , hsID ) if err != nil { return " " , err } return RootPathParticleHost . NewRootFromPath ( hs . InventoryPath , RootPathParticleDatastore ) } 
func FromAbsolutePath ( client * govmomi . Client , path string ) ( * object . Folder , error ) { finder := find . NewFinder ( client . Client , false ) ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) folder , err := finder . Folder ( ctx , path ) if err != nil { return nil , err } return folder , nil } 
func folderFromObject ( client * govmomi . Client , obj interface { } , folderType RootPathParticle , relative string ) ( * object . Folder , error ) { } var p string var err error switch o := obj . ( type ) { case * object . VmwareDistributedVirtualSwitch : p , err = RootPathParticleNetwork . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . Datastore : p , err = RootPathParticleDatastore . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . StoragePod : p , err = RootPathParticleDatastore . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . HostSystem : p , err = RootPathParticleHost . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . ResourcePool : p , err = RootPathParticleHost . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . ComputeResource : p , err = RootPathParticleHost . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . ClusterComputeResource : p , err = RootPathParticleHost . PathFromNewRoot ( o . InventoryPath , folderType , relative ) case * object . VirtualMachine : p , err = RootPathParticleVM . PathFromNewRoot ( o . InventoryPath , folderType , relative ) default : return nil , fmt . Errorf ( " " , o ) } if err != nil { return nil , err } return FromAbsolutePath ( client , p ) } 
func DatastoreFolderFromObject ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err := folderFromObject ( client , obj , RootPathParticleDatastore , relative ) if err != nil { return nil , err } return validateDatastoreFolder ( folder ) } 
func HostFolderFromObject ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err := folderFromObject ( client , obj , RootPathParticleHost , relative ) if err != nil { return nil , err } return validateHostFolder ( folder ) } 
func VirtualMachineFolderFromObject ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { log . Printf ( " " , relative ) folder , err := folderFromObject ( client , obj , RootPathParticleVM , relative ) if err != nil { return nil , err } return validateVirtualMachineFolder ( folder ) } 
func networkFolderFromObject ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err := folderFromObject ( client , obj , RootPathParticleNetwork , relative ) if err != nil { return nil , err } return validateNetworkFolder ( folder ) } 
func validateDatastoreFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeDatastore { return nil , fmt . Errorf ( " " , folder . InventoryPath ) } return folder , nil } 
func validateHostFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeHost { return nil , fmt . Errorf ( " " , folder . InventoryPath ) } return folder , nil } 
func validateVirtualMachineFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeVM { return nil , fmt . Errorf ( " " , folder . InventoryPath ) } log . Printf ( " " , folder . InventoryPath ) return folder , nil } 
func validateNetworkFolder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err := FindType ( folder ) if err != nil { return nil , err } if ft != VSphereFolderTypeNetwork { return nil , fmt . Errorf ( " " , folder . InventoryPath ) } return folder , nil } 
func NormalizePath ( v interface { } ) string { p := v . ( string ) if PathIsEmpty ( p ) { return " " } return strings . TrimPrefix ( path . Clean ( p ) , " " ) } 
func MoveObjectTo ( ref types . ManagedObjectReference , folder * object . Folder ) error { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) task , err := folder . MoveInto ( ctx , [ ] types . ManagedObjectReference { ref } ) if err != nil { return err } tctx , tcancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer tcancel ( ) return task . Wait ( tctx ) } 
func FromPath ( c * govmomi . Client , p string , ft VSphereFolderType , dc * object . Datacenter ) ( * object . Folder , error ) { var fp string if ft == VSphereFolderTypeDatacenter { fp = " " + p } else { pt := RootPathParticle ( ft ) fp = pt . PathFromDatacenter ( dc , p ) } return FromAbsolutePath ( c , fp ) } 
func ParentFromPath ( c * govmomi . Client , p string , ft VSphereFolderType , dc * object . Datacenter ) ( * object . Folder , error ) { return FromPath ( c , path . Dir ( p ) , ft , dc ) } 
func Properties ( folder * object . Folder ) ( * mo . Folder , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) var props mo . Folder if err := folder . Properties ( ctx , folder . Reference ( ) , nil , & props ) ; err != nil { return nil , err } return & props , nil } 
func FindType ( folder * object . Folder ) ( VSphereFolderType , error ) { var ft VSphereFolderType props , err := Properties ( folder ) if err != nil { return ft , err } if props . ChildType [ 0 ] != " " { ct = props . ChildType [ 0 ] } else { ct = props . ChildType [ 1 ] } switch ct { case " " : ft = VSphereFolderTypeDatacenter case " " : ft = VSphereFolderTypeHost case " " : ft = VSphereFolderTypeVM case " " : ft = VSphereFolderTypeDatastore case " " : ft = VSphereFolderTypeNetwork default : return ft , fmt . Errorf ( " " , ct ) } return ft , nil } 
func HasChildren ( f * object . Folder ) ( bool , error ) { ctx , cancel := context . WithTimeout ( context . Background ( ) , provider . DefaultAPITimeout ) defer cancel ( ) children , err := f . Children ( ctx ) if err != nil { return false , err } return len ( children ) > 0 , nil } 
func ( opts ListOpts ) ToServerListQuery ( ) ( string , error ) { q , err := gophercloud . BuildQueryString ( opts ) return q . String ( ) , err } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { authToken := argsOrEnv ( args , " " , " " ) projectID := argsOrEnv ( args , " " , " " ) packetURL := argsOrEnv ( args , " " , " " ) addressType := args [ " " ] packetFacilities := args [ " " ] packetTags := args [ " " ] if addressType != " " && addressType != " " && addressType != " " { l . Printf ( " " , addressType ) addressType = " " } includeFacilities := includeArgs ( packetFacilities ) includeTags := includeArgs ( packetTags ) c , err := client ( p . userAgent , packetURL , authToken ) if err != nil { return nil , fmt . Errorf ( " " , err ) } var devices [ ] packngo . Device if projectID == " " { return nil , fmt . Errorf ( " " ) } devices , _ , err = c . Devices . List ( projectID , nil ) if err != nil { return nil , fmt . Errorf ( " " , err ) } var addrs [ ] string for _ , d := range devices { if len ( includeFacilities ) > 0 && ! Include ( includeFacilities , d . Facility . Code ) { continue } if len ( includeTags ) > 0 && ! Any ( d . Tags , func ( v string ) bool { return Include ( includeTags , v ) } ) { continue } addressFamily := 4 if addressType == " " { addressFamily = 6 } for _ , n := range d . Network { if ( n . Public == ( addressType == " " || addressType == " " ) ) && n . AddressFamily == addressFamily { addrs = append ( addrs , n . Address ) } } } return addrs , nil } 
func Index ( vs [ ] string , t string ) int { for i , v := range vs { if v == t { return i } } return - 1 } 
func Any ( vs [ ] string , f func ( string ) bool ) bool { for _ , v := range vs { if f ( v ) { return true } } return false } 
func client ( path string ) ( * http . Client , error ) { if path == " " { return google . DefaultClient ( oauth2 . NoContext , compute . ComputeScope ) } key , err := ioutil . ReadFile ( path ) if err != nil { return nil , err } jwtConfig , err := google . JWTConfigFromJSON ( key , compute . ComputeScope ) if err != nil { return nil , err } return jwtConfig . Client ( oauth2 . NoContext ) , nil } 
func lookupProject ( ) ( string , error ) { req , err := http . NewRequest ( " " , " " , nil ) if err != nil { return " " , err } req . Header . Add ( " " , " " ) resp , err := http . DefaultClient . Do ( req ) if err != nil { return " " , err } defer resp . Body . Close ( ) if resp . StatusCode != 200 { return " " , fmt . Errorf ( " " , resp . StatusCode ) } project , err := ioutil . ReadAll ( resp . Body ) if err != nil { return " " , err } return string ( project ) , nil } 
func lookupZones ( svc * compute . Service , project , pattern string ) ( [ ] string , error ) { call := svc . Zones . List ( project ) if pattern != " " { call = call . Filter ( " " + pattern ) } var zones [ ] string f := func ( page * compute . ZoneList ) error { for _ , v := range page . Items { zones = append ( zones , v . Name ) } return nil } if err := call . Pages ( oauth2 . NoContext , f ) ; err != nil { return nil , err } return zones , nil } 
func lookupAddrs ( svc * compute . Service , project , zone , tag string ) ( [ ] string , error ) { var addrs [ ] string f := func ( page * compute . InstanceList ) error { for _ , v := range page . Items { if len ( v . NetworkInterfaces ) == 0 || v . NetworkInterfaces [ 0 ] . NetworkIP == " " { continue } for _ , t := range v . Tags . Items { if t == tag { addrs = append ( addrs , v . NetworkInterfaces [ 0 ] . NetworkIP ) break } } } return nil } call := svc . Instances . List ( project , zone ) if err := call . Pages ( oauth2 . NoContext , f ) ; err != nil { return nil , err } return addrs , nil } 
func New ( opts ... Option ) ( * Discover , error ) { d := new ( Discover ) for _ , opt := range opts { if err := opt ( d ) ; err != nil { return nil , err } } d . once . Do ( d . initProviders ) return d , nil } 
func WithUserAgent ( agent string ) Option { return func ( d * Discover ) error { d . userAgent = agent return nil } } 
func WithProviders ( m map [ string ] Provider ) Option { return func ( d * Discover ) error { d . Providers = m return nil } } 
func ( d * Discover ) Names ( ) [ ] string { d . once . Do ( d . initProviders ) var names [ ] string for n := range d . Providers { names = append ( names , n ) } sort . Strings ( names ) return names } 
func ( d * Discover ) Help ( ) string { d . once . Do ( d . initProviders ) h := [ ] string { globalHelp } for _ , name := range d . Names ( ) { h = append ( h , d . Providers [ name ] . Help ( ) ) } return strings . Join ( h , " \n " ) } 
func ( d * Discover ) Addrs ( cfg string , l * log . Logger ) ( [ ] string , error ) { d . once . Do ( d . initProviders ) args , err := Parse ( cfg ) if err != nil { return nil , fmt . Errorf ( " " , err ) } name := args [ " " ] if name == " " { return nil , fmt . Errorf ( " " ) } providers := d . Providers if providers == nil { providers = Providers } p := providers [ name ] if p == nil { return nil , fmt . Errorf ( " " + name ) } l . Printf ( " " , name ) if typ , ok := p . ( ProviderWithUserAgent ) ; ok { typ . SetUserAgent ( d . userAgent ) return p . Addrs ( args , l ) } return p . Addrs ( args , l ) } 
func ( c Config ) String ( ) string { for k := range c { if k != " " { keys = append ( keys , k ) } } sort . Strings ( keys ) keys = append ( [ ] string { " " } , keys ... ) quote := func ( s string ) string { if strings . ContainsAny ( s , ` "\` ) { return strconv . Quote ( s ) } return s } var vals [ ] string for _ , k := range keys { v := c [ k ] if v == " " { continue } vals = append ( vals , quote ( k ) + " " + quote ( v ) ) } return strings . Join ( vals , " " ) } 
func PodAddrs ( pods * corev1 . PodList , args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { hostNetwork := false if v := args [ " " ] ; v != " " { var err error hostNetwork , err = strconv . ParseBool ( v ) if err != nil { return nil , fmt . Errorf ( " " , err ) } } var addrs [ ] string PodLoop : for _ , pod := range pods . Items { if pod . Status . Phase != corev1 . PodRunning { l . Printf ( " " , pod . Name , pod . Status . Phase ) continue } continue PodLoop } } if hostNetwork { addr = pod . Status . HostIP } if addr == " " { continue } if err != nil { l . Printf ( " " , pod . Name , err ) continue } addr = fmt . Sprintf ( " " , addr , port ) } addrs = append ( addrs , addr ) } return addrs , nil } 
func podPort ( pod * corev1 . Pod , annotation string , host bool ) ( int32 , error ) { } return portDef . HostPort , nil } return portDef . ContainerPort , nil } } } return int32 ( v ) , err } 
func argsOrEnv ( args map [ string ] string , key , env string ) string { if value , ok := args [ key ] ; ok { return value } return os . Getenv ( env ) } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { var params * m . QueryParam var ch chan * m . ServiceEntry var v6 , v4 bool var addrs [ ] string var err error } } params . Service = args [ " " ] } else { params . Domain = " " } } } else { params . Timeout = 5 * time . Second } } } else { v6 = true } } } else { v4 = true } defer close ( ch ) params . Entries = ch for e := range ch { addr = " " if v6 && e . AddrV6 != nil { addr = net . JoinHostPort ( e . AddrV6 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr == " " && v4 && e . AddrV4 != nil { addr = net . JoinHostPort ( e . AddrV4 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr != " " { l . Printf ( " " , e . Host , addr ) } } } ( ) } 
func setLog ( l * log . Logger ) { if l != nil { logger = l } else { logger = log . New ( ioutil . Discard , " " , 0 ) } } 
func discoverErr ( format string , a ... interface { } ) error { var s string if len ( a ) > 1 { s = fmt . Sprintf ( format , a ... ) } else { s = format } return fmt . Errorf ( " " , s ) } 
func valueOrEnv ( config map [ string ] string , key , env string ) string { if v := config [ key ] ; v != " " { return v } if v := os . Getenv ( env ) ; v != " " { logger . Printf ( " " , env , key ) return v } return " " } 
func vimURL ( server , user , password string ) ( * url . URL , error ) { u , err := url . Parse ( " " + server + " " ) if err != nil { return nil , fmt . Errorf ( " " , err ) } u . User = url . UserPassword ( user , password ) return u , nil } 
func newVSphereClient ( ctx context . Context , host , user , password string , insecure bool ) ( * vSphereClient , error ) { logger . Println ( " " ) client := new ( vSphereClient ) u , err := vimURL ( host , user , password ) if err != nil { return nil , fmt . Errorf ( " " , err ) } if err != nil { return nil , err } client . TagsClient , err = newRestSession ( ctx , u , insecure ) if err != nil { return nil , err } logger . Println ( " " ) return client , nil } 
func newVimSession ( ctx context . Context , u * url . URL , insecure bool ) ( * govmomi . Client , error ) { logger . Printf ( " " , u . Host ) client , err := govmomi . NewClient ( ctx , u , insecure ) if err != nil { return nil , fmt . Errorf ( " " , err ) } logger . Println ( " " ) return client , nil } 
func newRestSession ( ctx context . Context , u * url . URL , insecure bool ) ( * tags . RestClient , error ) { logger . Printf ( " " , u . Host ) client := tags . NewClient ( u , insecure , " " ) if err := client . Login ( ctx ) ; err != nil { return nil , fmt . Errorf ( " " , err ) } logger . Println ( " " ) return client , nil } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { if args [ " " ] != " " { return nil , discoverErr ( " " , args [ " " ] ) } setLog ( l ) tagName := args [ " " ] categoryName := args [ " " ] host := valueOrEnv ( args , " " , " " ) user := valueOrEnv ( args , " " , " " ) password := valueOrEnv ( args , " " , " " ) insecure , err := strconv . ParseBool ( valueOrEnv ( args , " " , " " ) ) if err != nil { logger . Println ( " " ) } timeout , err := time . ParseDuration ( args [ " " ] ) if err != nil { logger . Println ( " " ) timeout = time . Minute * 10 } ctx , cancel := context . WithTimeout ( context . Background ( ) , timeout ) defer cancel ( ) client , err := newVSphereClient ( ctx , host , user , password , insecure ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } if tagName == " " || categoryName == " " { return nil , discoverErr ( " " ) } logger . Printf ( " " , tagName , categoryName ) tagID , err := tagIDFromName ( ctx , client . TagsClient , tagName , categoryName ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } addrs , err := virtualMachineIPsForTag ( ctx , client , tagID ) if err != nil { return nil , discoverErr ( err . Error ( ) ) } logger . Printf ( " " , strings . Join ( addrs , " " ) ) return addrs , nil } 
func tagIDFromName ( ctx context . Context , client * tags . RestClient , name , category string ) ( string , error ) { logger . Printf ( " " , name , category ) categoryID , err := tagCategoryByName ( ctx , client , category ) if err != nil { return " " , err } return tagByName ( ctx , client , name , categoryID ) } 
func tagCategoryByName ( ctx context . Context , client * tags . RestClient , name string ) ( string , error ) { cats , err := client . GetCategoriesByName ( ctx , name ) if err != nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( cats ) < 1 { return " " , fmt . Errorf ( " " , name ) } if len ( cats ) > 1 { } return cats [ 0 ] . ID , nil } 
func tagByName ( ctx context . Context , client * tags . RestClient , name , categoryID string ) ( string , error ) { tids , err := client . GetTagByNameForCategory ( ctx , name , categoryID ) if err != nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( tids ) < 1 { return " " , fmt . Errorf ( " " , name , categoryID ) } if len ( tids ) > 1 { } logger . Printf ( " " , tids [ 0 ] . ID ) return tids [ 0 ] . ID , nil } 
func virtualMachineIPsForTag ( ctx context . Context , client * vSphereClient , id string ) ( [ ] string , error ) { vms , err := virtualMachinesForTag ( ctx , client , id ) if err != nil { return nil , err } return ipAddrsForVirtualMachines ( ctx , client , vms ) } 
func virtualMachinesForTag ( ctx context . Context , client * vSphereClient , id string ) ( [ ] * object . VirtualMachine , error ) { logger . Printf ( " " , id ) var vms [ ] * object . VirtualMachine objs , err := client . TagsClient . ListAttachedObjects ( ctx , id ) if err != nil { return nil , err } for i , obj := range objs { switch { case obj . Type == nil || obj . ID == nil : logger . Printf ( " " , i ) continue case * obj . Type != " " : logger . Printf ( " " , * obj . ID ) continue } vm , err := virtualMachineFromMOID ( ctx , client . VimClient , * obj . ID ) if err != nil { return nil , fmt . Errorf ( " " , * obj . ID , err ) } vms = append ( vms , vm ) } logger . Printf ( " " , virtualMachineNames ( vms ) ) return vms , nil } 
func ipAddrsForVirtualMachines ( ctx context . Context , client * vSphereClient , vms [ ] * object . VirtualMachine ) ( [ ] string , error ) { var addrs [ ] string for _ , vm := range vms { as , err := buildAndSelectGuestIPs ( ctx , vm ) if err != nil { return nil , err } addrs = append ( addrs , as ... ) } return addrs , nil } 
func virtualMachineFromMOID ( ctx context . Context , client * govmomi . Client , id string ) ( * object . VirtualMachine , error ) { logger . Printf ( " " , id ) finder := find . NewFinder ( client . Client , false ) ref := types . ManagedObjectReference { Type : " " , Value : id , } vm , err := finder . ObjectReference ( ctx , ref ) if err != nil { return nil , err } } 
func virtualMachineProperties ( ctx context . Context , vm * object . VirtualMachine , keys [ ] string ) ( * mo . VirtualMachine , error ) { logger . Printf ( " " , vm . Name ( ) ) var props mo . VirtualMachine if err := vm . Properties ( ctx , vm . Reference ( ) , keys , & props ) ; err != nil { return nil , err } return & props , nil } 
func buildAndSelectGuestIPs ( ctx context . Context , vm * object . VirtualMachine ) ( [ ] string , error ) { logger . Printf ( " " , vm . Name ( ) ) var addrs [ ] string props , err := virtualMachineProperties ( ctx , vm , [ ] string { " " } ) if err != nil { return nil , fmt . Errorf ( " " , vm . Name ( ) , err ) } if props . Guest == nil || props . Guest . Net == nil { logger . Printf ( " " , vm . Name ( ) ) return nil , nil } } addrs = append ( addrs , addr . IpAddress ) } } } logger . Printf ( " " , vm . Name ( ) , strings . Join ( addrs , " " ) ) return addrs , nil } 
func skipIPAddr ( ip net . IP ) bool { switch { case ip . IsLinkLocalMulticast ( ) : fallthrough case ip . IsLinkLocalUnicast ( ) : fallthrough case ip . IsLoopback ( ) : fallthrough case ip . IsMulticast ( ) : return true } return false } 
func virtualMachineNames ( vms [ ] * object . VirtualMachine ) string { var s [ ] string for _ , vm := range vms { s = append ( s , vm . Name ( ) ) } return strings . Join ( s , " " ) } 
func validateAndWrapHandler ( h Handler ) Handler { if reflect . TypeOf ( h ) . Kind ( ) != reflect . Func { panic ( " " ) } if ! inject . IsFastInvoker ( h ) { switch v := h . ( type ) { case func ( * Context ) : return ContextInvoker ( v ) case func ( * Context , * log . Logger ) : return LoggerInvoker ( v ) case func ( http . ResponseWriter , * http . Request ) : return handlerFuncInvoker ( v ) case func ( http . ResponseWriter , error ) : return internalServerErrorInvoker ( v ) } } return h } 
func validateAndWrapHandlers ( handlers [ ] Handler , wrappers ... func ( Handler ) Handler ) [ ] Handler { var wrapper func ( Handler ) Handler if len ( wrappers ) > 0 { wrapper = wrappers [ 0 ] } wrappedHandlers := make ( [ ] Handler , len ( handlers ) ) for i , h := range handlers { h = validateAndWrapHandler ( h ) if wrapper != nil && ! inject . IsFastInvoker ( h ) { h = wrapper ( h ) } wrappedHandlers [ i ] = h } return wrappedHandlers } 
func NewWithLogger ( out io . Writer ) * Macaron { m := & Macaron { Injector : inject . New ( ) , action : func ( ) { } , Router : NewRouter ( ) , logger : log . New ( out , " " , 0 ) , } m . Router . m = m m . Map ( m . logger ) m . Map ( defaultReturnHandler ( ) ) m . NotFound ( http . NotFound ) m . InternalServerError ( func ( rw http . ResponseWriter , err error ) { http . Error ( rw , err . Error ( ) , 500 ) } ) return m } 
func Classic ( ) * Macaron { m := New ( ) m . Use ( Logger ( ) ) m . Use ( Recovery ( ) ) m . Use ( Static ( " " ) ) return m } 
func ( m * Macaron ) Handlers ( handlers ... Handler ) { m . handlers = make ( [ ] Handler , 0 ) for _ , handler := range handlers { m . Use ( handler ) } } 
func ( m * Macaron ) Action ( handler Handler ) { handler = validateAndWrapHandler ( handler ) m . action = handler } 
func ( m * Macaron ) Use ( handler Handler ) { handler = validateAndWrapHandler ( handler ) m . handlers = append ( m . handlers , handler ) } 
func ( m * Macaron ) ServeHTTP ( rw http . ResponseWriter , req * http . Request ) { if m . hasURLPrefix { req . URL . Path = strings . TrimPrefix ( req . URL . Path , m . urlPrefix ) } for _ , h := range m . befores { if h ( rw , req ) { return } } m . Router . ServeHTTP ( rw , req ) } 
func ( m * Macaron ) Run ( args ... interface { } ) { host , port := GetDefaultListenInfo ( ) if len ( args ) == 1 { switch arg := args [ 0 ] . ( type ) { case string : host = arg case int : port = arg } } else if len ( args ) >= 2 { if arg , ok := args [ 0 ] . ( string ) ; ok { host = arg } if arg , ok := args [ 1 ] . ( int ) ; ok { port = arg } } addr := host + " " + com . ToStr ( port ) logger := m . GetVal ( reflect . TypeOf ( m . logger ) ) . Interface ( ) . ( * log . Logger ) logger . Printf ( " \n " , addr , safeEnv ( ) ) logger . Fatalln ( http . ListenAndServe ( addr , m ) ) } 
func ( m * Macaron ) SetURLPrefix ( prefix string ) { m . urlPrefix = prefix m . hasURLPrefix = len ( m . urlPrefix ) > 0 } 
func SetConfig ( source interface { } , others ... interface { } ) ( _ * ini . File , err error ) { cfg , err = ini . Load ( source , others ... ) return Config ( ) , err } 
func ( rb * RequestBody ) String ( ) ( string , error ) { data , err := rb . Bytes ( ) return string ( data ) , err } 
func ( ctx * Context ) RemoteAddr ( ) string { addr := ctx . Req . Header . Get ( " " ) if len ( addr ) == 0 { addr = ctx . Req . Header . Get ( " " ) if addr == " " { addr = ctx . Req . RemoteAddr if i := strings . LastIndex ( addr , " " ) ; i > - 1 { addr = addr [ : i ] } } } return addr } 
func ( ctx * Context ) HTML ( status int , name string , data ... interface { } ) { ctx . renderHTML ( status , DEFAULT_TPL_SET_NAME , name , data ... ) } 
func ( ctx * Context ) HTMLSet ( status int , setName , tplName string , data ... interface { } ) { ctx . renderHTML ( status , setName , tplName , data ... ) } 
func ( ctx * Context ) Query ( name string ) string { ctx . parseForm ( ) return ctx . Req . Form . Get ( name ) } 
func ( ctx * Context ) QueryTrim ( name string ) string { return strings . TrimSpace ( ctx . Query ( name ) ) } 
func ( ctx * Context ) QueryStrings ( name string ) [ ] string { ctx . parseForm ( ) vals , ok := ctx . Req . Form [ name ] if ! ok { return [ ] string { } } return vals } 
func ( ctx * Context ) QueryEscape ( name string ) string { return template . HTMLEscapeString ( ctx . Query ( name ) ) } 
func ( ctx * Context ) QueryBool ( name string ) bool { v , _ := strconv . ParseBool ( ctx . Query ( name ) ) return v } 
func ( ctx * Context ) QueryInt ( name string ) int { return com . StrTo ( ctx . Query ( name ) ) . MustInt ( ) } 
func ( ctx * Context ) QueryInt64 ( name string ) int64 { return com . StrTo ( ctx . Query ( name ) ) . MustInt64 ( ) } 
func ( ctx * Context ) QueryFloat64 ( name string ) float64 { v , _ := strconv . ParseFloat ( ctx . Query ( name ) , 64 ) return v } 
func ( ctx * Context ) Params ( name string ) string { if len ( name ) == 0 { return " " } if len ( name ) > 1 && name [ 0 ] != ':' { name = " " + name } return ctx . params [ name ] } 
func ( ctx * Context ) SetParams ( name , val string ) { if name != " " && ! strings . HasPrefix ( name , " " ) { name = " " + name } ctx . params [ name ] = val } 
func ( ctx * Context ) ParamsEscape ( name string ) string { return template . HTMLEscapeString ( ctx . Params ( name ) ) } 
func ( ctx * Context ) ParamsInt ( name string ) int { return com . StrTo ( ctx . Params ( name ) ) . MustInt ( ) } 
func ( ctx * Context ) ParamsInt64 ( name string ) int64 { return com . StrTo ( ctx . Params ( name ) ) . MustInt64 ( ) } 
func ( ctx * Context ) ParamsFloat64 ( name string ) float64 { v , _ := strconv . ParseFloat ( ctx . Params ( name ) , 64 ) return v } 
func ( ctx * Context ) GetFile ( name string ) ( multipart . File , * multipart . FileHeader , error ) { return ctx . Req . FormFile ( name ) } 
func ( ctx * Context ) SaveToFile ( name , savePath string ) error { fr , _ , err := ctx . GetFile ( name ) if err != nil { return err } defer fr . Close ( ) fw , err := os . OpenFile ( savePath , os . O_WRONLY | os . O_CREATE | os . O_TRUNC , 0666 ) if err != nil { return err } defer fw . Close ( ) _ , err = io . Copy ( fw , fr ) return err } 
func ( ctx * Context ) SetCookie ( name string , value string , others ... interface { } ) { cookie := http . Cookie { } cookie . Name = name cookie . Value = url . QueryEscape ( value ) if len ( others ) > 0 { switch v := others [ 0 ] . ( type ) { case int : cookie . MaxAge = v case int64 : cookie . MaxAge = int ( v ) case int32 : cookie . MaxAge = int ( v ) } } cookie . Path = " " if len ( others ) > 1 { if v , ok := others [ 1 ] . ( string ) ; ok && len ( v ) > 0 { cookie . Path = v } } if len ( others ) > 2 { if v , ok := others [ 2 ] . ( string ) ; ok && len ( v ) > 0 { cookie . Domain = v } } if len ( others ) > 3 { switch v := others [ 3 ] . ( type ) { case bool : cookie . Secure = v default : if others [ 3 ] != nil { cookie . Secure = true } } } if len ( others ) > 4 { if v , ok := others [ 4 ] . ( bool ) ; ok && v { cookie . HttpOnly = true } } if len ( others ) > 5 { if v , ok := others [ 5 ] . ( time . Time ) ; ok { cookie . Expires = v cookie . RawExpires = v . Format ( time . UnixDate ) } } ctx . Resp . Header ( ) . Add ( " " , cookie . String ( ) ) } 
func ( ctx * Context ) GetCookie ( name string ) string { cookie , err := ctx . Req . Cookie ( name ) if err != nil { return " " } val , _ := url . QueryUnescape ( cookie . Value ) return val } 
func ( ctx * Context ) GetCookieInt ( name string ) int { return com . StrTo ( ctx . GetCookie ( name ) ) . MustInt ( ) } 
func ( ctx * Context ) GetCookieInt64 ( name string ) int64 { return com . StrTo ( ctx . GetCookie ( name ) ) . MustInt64 ( ) } 
func ( ctx * Context ) GetCookieFloat64 ( name string ) float64 { v , _ := strconv . ParseFloat ( ctx . GetCookie ( name ) , 64 ) return v } 
func ( ctx * Context ) SetSecureCookie ( name , value string , others ... interface { } ) { ctx . SetSuperSecureCookie ( defaultCookieSecret , name , value , others ... ) } 
func ( ctx * Context ) GetSecureCookie ( key string ) ( string , bool ) { return ctx . GetSuperSecureCookie ( defaultCookieSecret , key ) } 
func ( ctx * Context ) SetSuperSecureCookie ( secret , name , value string , others ... interface { } ) { key := pbkdf2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1000 , 16 , sha256 . New ) text , err := com . AESGCMEncrypt ( key , [ ] byte ( value ) ) if err != nil { panic ( " " + err . Error ( ) ) } ctx . SetCookie ( name , hex . EncodeToString ( text ) , others ... ) } 
func ( ctx * Context ) GetSuperSecureCookie ( secret , name string ) ( string , bool ) { val := ctx . GetCookie ( name ) if val == " " { return " " , false } text , err := hex . DecodeString ( val ) if err != nil { return " " , false } key := pbkdf2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1000 , 16 , sha256 . New ) text , err = com . AESGCMDecrypt ( key , text ) return string ( text ) , err == nil } 
func ( ctx * Context ) ServeContent ( name string , r io . ReadSeeker , params ... interface { } ) { modtime := time . Now ( ) for _ , p := range params { switch v := p . ( type ) { case time . Time : modtime = v } } ctx . setRawContentHeader ( ) http . ServeContent ( ctx . Resp , ctx . Req . Request , name , modtime , r ) } 
func ( ctx * Context ) ServeFileContent ( file string , names ... string ) { var name string if len ( names ) > 0 { name = names [ 0 ] } else { name = path . Base ( file ) } f , err := os . Open ( file ) if err != nil { if Env == PROD { http . Error ( ctx . Resp , " " , 500 ) } else { http . Error ( ctx . Resp , err . Error ( ) , 500 ) } return } defer f . Close ( ) ctx . setRawContentHeader ( ) http . ServeContent ( ctx . Resp , ctx . Req . Request , name , time . Now ( ) , f ) } 
func ( ctx * Context ) ServeFile ( file string , names ... string ) { var name string if len ( names ) > 0 { name = names [ 0 ] } else { name = path . Base ( file ) } ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " + name ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) http . ServeFile ( ctx . Resp , ctx . Req . Request , file ) } 
func ( ctx * Context ) ChangeStaticPath ( oldPath , newPath string ) { if ! filepath . IsAbs ( oldPath ) { oldPath = filepath . Join ( Root , oldPath ) } dir := statics . Get ( oldPath ) if dir != nil { statics . Delete ( oldPath ) if ! filepath . IsAbs ( newPath ) { newPath = filepath . Join ( Root , newPath ) } * dir = http . Dir ( newPath ) statics . Set ( dir ) } } 
func getNextWildcard ( pattern string ) ( wildcard , _ string ) { pos := wildcardPattern . FindStringIndex ( pattern ) if pos == nil { return " " , pattern } wildcard = pattern [ pos [ 0 ] : pos [ 1 ] ] } else if pattern [ pos [ 1 ] ] != '(' { switch { case isSpecialRegexp ( pattern , " " , pos ) : pattern = strings . Replace ( pattern , " " , " " , 1 ) case isSpecialRegexp ( pattern , " " , pos ) : pattern = strings . Replace ( pattern , " " , " \\ " , 1 ) default : return wildcard , strings . Replace ( pattern , wildcard , `(.+)` , 1 ) } } } 
func getRawPattern ( rawPattern string ) string { rawPattern = strings . Replace ( rawPattern , " " , " " , - 1 ) rawPattern = strings . Replace ( rawPattern , " " , " " , - 1 ) for { startIdx := strings . Index ( rawPattern , " " ) if startIdx == - 1 { break } closeIdx := strings . Index ( rawPattern , " " ) if closeIdx > - 1 { rawPattern = rawPattern [ : startIdx ] + rawPattern [ closeIdx + 1 : ] } } return rawPattern } 
func ( l * Leaf ) URLPath ( pairs ... string ) string { if len ( pairs ) % 2 != 0 { panic ( " " ) } urlPath := l . rawPattern parent := l . parent for parent != nil { urlPath = parent . rawPattern + " " + urlPath parent = parent . parent } for i := 0 ; i < len ( pairs ) ; i += 2 { if len ( pairs [ i ] ) == 0 { panic ( " " + com . ToStr ( i ) ) } else if pairs [ i ] [ 0 ] != ':' && pairs [ i ] != " " && pairs [ i ] != " " { pairs [ i ] = " " + pairs [ i ] } urlPath = strings . Replace ( urlPath , pairs [ i ] , pairs [ i + 1 ] , 1 ) } return urlPath } 
func NewRouteMap ( ) * routeMap { rm := & routeMap { routes : make ( map [ string ] map [ string ] * Leaf ) , } for m := range _HTTP_METHODS { rm . routes [ m ] = make ( map [ string ] * Leaf ) } return rm } 
func ( rm * routeMap ) getLeaf ( method , pattern string ) * Leaf { rm . lock . RLock ( ) defer rm . lock . RUnlock ( ) return rm . routes [ method ] [ pattern ] } 
func ( rm * routeMap ) add ( method , pattern string , leaf * Leaf ) { rm . lock . Lock ( ) defer rm . lock . Unlock ( ) rm . routes [ method ] [ pattern ] = leaf } 
func ( r * Route ) Name ( name string ) { if len ( name ) == 0 { panic ( " " ) } else if r . router . namedRoutes [ name ] != nil { panic ( " " + name ) } r . router . namedRoutes [ name ] = r . leaf } 
func ( r * Router ) handle ( method , pattern string , handle Handle ) * Route { method = strings . ToUpper ( method ) var leaf * Leaf } } if method == " " { for m := range _HTTP_METHODS { methods [ m ] = true } } else { methods [ method ] = true } } else { t := NewTree ( ) leaf = t . Add ( pattern , handle ) r . routers [ m ] = t } r . add ( m , pattern , leaf ) } return & Route { r , leaf } } 
func ( r * Router ) Handle ( method string , pattern string , handlers [ ] Handler ) * Route { if len ( r . groups ) > 0 { groupPattern := " " h := make ( [ ] Handler , 0 ) for _ , g := range r . groups { groupPattern += g . pattern h = append ( h , g . handlers ... ) } pattern = groupPattern + pattern h = append ( h , handlers ... ) handlers = h } handlers = validateAndWrapHandlers ( handlers , r . handlerWrapper ) return r . handle ( method , pattern , func ( resp http . ResponseWriter , req * http . Request , params Params ) { c := r . m . createContext ( resp , req ) c . params = params c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers ... ) c . handlers = append ( c . handlers , handlers ... ) c . run ( ) } ) } 
func ( r * Router ) Get ( pattern string , h ... Handler ) ( leaf * Route ) { leaf = r . Handle ( " " , pattern , h ) if r . autoHead { r . Head ( pattern , h ... ) } return leaf } 
func ( r * Router ) Patch ( pattern string , h ... Handler ) * Route { return r . Handle ( " " , pattern , h ) } 
func ( r * Router ) Route ( pattern , methods string , h ... Handler ) ( route * Route ) { for _ , m := range strings . Split ( methods , " " ) { route = r . Handle ( strings . TrimSpace ( m ) , pattern , h ) } return route } 
func ( r * Router ) Combo ( pattern string , h ... Handler ) * ComboRouter { return & ComboRouter { r , pattern , h , map [ string ] bool { } , nil } } 
func ( r * Router ) NotFound ( handlers ... Handler ) { handlers = validateAndWrapHandlers ( handlers ) r . notFound = func ( rw http . ResponseWriter , req * http . Request ) { c := r . m . createContext ( rw , req ) c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers ... ) c . handlers = append ( c . handlers , handlers ... ) c . run ( ) } } 
func ( r * Router ) InternalServerError ( handlers ... Handler ) { handlers = validateAndWrapHandlers ( handlers ) r . internalServerError = func ( c * Context , err error ) { c . index = 0 c . handlers = handlers c . Map ( err ) c . run ( ) } } 
func ( r * Router ) URLFor ( name string , pairs ... string ) string { leaf , ok := r . namedRoutes [ name ] if ! ok { panic ( " " + name ) } return leaf . URLPath ( pairs ... ) } 
func ( cr * ComboRouter ) Name ( name string ) { if cr . lastRoute == nil { panic ( " " ) } cr . lastRoute . Name ( name ) } 
func NewResponseWriter ( method string , rw http . ResponseWriter ) ResponseWriter { return & responseWriter { method , rw , 0 , 0 , nil } } 
func Logger ( ) Handler { return func ( ctx * Context , log * log . Logger ) { start := time . Now ( ) log . Printf ( " " , time . Now ( ) . Format ( LogTimeFormat ) , ctx . Req . Method , ctx . Req . RequestURI , ctx . RemoteAddr ( ) ) rw := ctx . Resp . ( ResponseWriter ) ctx . Next ( ) content := fmt . Sprintf ( " " , time . Now ( ) . Format ( LogTimeFormat ) , ctx . Req . Method , ctx . Req . RequestURI , rw . Status ( ) , http . StatusText ( rw . Status ( ) ) , time . Since ( start ) ) if ColorLog { switch rw . Status ( ) { case 200 , 201 , 202 : content = fmt . Sprintf ( " \033 \033 " , content ) case 301 , 302 : content = fmt . Sprintf ( " \033 \033 " , content ) case 304 : content = fmt . Sprintf ( " \033 \033 " , content ) case 401 , 403 : content = fmt . Sprintf ( " \033 \033 " , content ) case 404 : content = fmt . Sprintf ( " \033 \033 " , content ) case 500 : content = fmt . Sprintf ( " \033 \033 " , content ) } } log . Println ( content ) } } 
func NewTplFile ( name string , data [ ] byte , ext string ) * TplFile { return & TplFile { name , data , ext } } 
func NewTemplateFileSystem ( opt RenderOptions , omitData bool ) TplFileSystem { fs := TplFileSystem { } fs . files = make ( [ ] TemplateFile , 0 , 10 ) for i := len ( opt . AppendDirectories ) - 1 ; i >= 0 ; i -- { dirs = append ( dirs , opt . AppendDirectories [ i ] ) } dirs = append ( dirs , opt . Directory ) var err error for i := range dirs { } dirs [ i ] , err = filepath . EvalSymlinks ( dirs [ i ] ) if err != nil { panic ( " " + dirs [ i ] + " " + err . Error ( ) ) } } lastDir := dirs [ len ( dirs ) - 1 ] if err != nil { return err } ext := GetExt ( r ) for _ , extension := range opt . Extensions { if ext != extension { continue } var data [ ] byte if ! omitData { if ! com . IsFile ( path ) { continue } data , err = ioutil . ReadFile ( path ) if err != nil { return err } break } } name := filepath . ToSlash ( ( r [ 0 : len ( r ) - len ( ext ) ] ) ) fs . files = append ( fs . files , NewTplFile ( name , data , ext ) ) } return nil } ) ; err != nil { panic ( " " + err . Error ( ) ) } return fs } 
func NewTemplateSet ( ) * TemplateSet { return & TemplateSet { sets : make ( map [ string ] * template . Template ) , dirs : make ( map [ string ] string ) , } } 
func GenerateETag ( fileSize , fileName , modTime string ) string { etag := fileSize + fileName + modTime return base64 . StdEncoding . EncodeToString ( [ ] byte ( etag ) ) } 
func Populate ( values ... interface { } ) error { var g Graph for _ , v := range values { if err := g . Provide ( & Object { Value : v } ) ; err != nil { return err } } return g . Populate ( ) } 
func ( o * Object ) String ( ) string { var buf bytes . Buffer fmt . Fprint ( & buf , o . reflectType ) if o . Name != " " { fmt . Fprintf ( & buf , " " , o . Name ) } return buf . String ( ) } 
func ( g * Graph ) Provide ( objects ... * Object ) error { for _ , o := range objects { o . reflectType = reflect . TypeOf ( o . Value ) o . reflectValue = reflect . ValueOf ( o . Value ) if o . Fields != nil { return fmt . Errorf ( " " , o , ) } if o . Name == " " { if ! isStructPtr ( o . reflectType ) { return fmt . Errorf ( " " + " " , o . reflectType , o . Value , ) } if ! o . private { if g . unnamedType == nil { g . unnamedType = make ( map [ reflect . Type ] bool ) } if g . unnamedType [ o . reflectType ] { return fmt . Errorf ( " " , o . reflectType . Elem ( ) . PkgPath ( ) , o . reflectType . Elem ( ) . Name ( ) , ) } g . unnamedType [ o . reflectType ] = true } g . unnamed = append ( g . unnamed , o ) } else { if g . named == nil { g . named = make ( map [ string ] * Object ) } if g . named [ o . Name ] != nil { return fmt . Errorf ( " " , o . Name ) } g . named [ o . Name ] = o } if g . Logger != nil { if o . created { g . Logger . Debugf ( " " , o ) } else if o . embedded { g . Logger . Debugf ( " " , o ) } else { g . Logger . Debugf ( " " , o ) } } } return nil } 
func ( g * Graph ) Populate ( ) error { for _ , o := range g . named { if o . Complete { continue } if err := g . populateExplicit ( o ) ; err != nil { return err } } for { if i == len ( g . unnamed ) { break } o := g . unnamed [ i ] i ++ if o . Complete { continue } if err := g . populateExplicit ( o ) ; err != nil { return err } } } if err := g . populateUnnamedInterface ( o ) ; err != nil { return err } } for _ , o := range g . named { if o . Complete { continue } if err := g . populateUnnamedInterface ( o ) ; err != nil { return err } } return nil } 
func ( g * Graph ) Objects ( ) [ ] * Object { objects := make ( [ ] * Object , 0 , len ( g . unnamed ) + len ( g . named ) ) for _ , o := range g . unnamed { if ! o . embedded { objects = append ( objects , o ) } } for _ , o := range g . named { if ! o . embedded { objects = append ( objects , o ) } } objects [ i ] , objects [ j ] = objects [ j ] , objects [ i ] } return objects } 
func newPubSub ( client * pubsub . Client , name string , options * Options , store func ( * points . Points ) ) ( * PubSub , error ) { logger := zapwriter . Logger ( name ) logger . Info ( " " , zap . String ( " " , options . Project ) , zap . String ( " " , options . Subscription ) , ) if options . Project == " " { return nil , fmt . Errorf ( " " ) } ctx := context . Background ( ) if client == nil { c , err := pubsub . NewClient ( ctx , options . Project ) if err != nil { return nil , err } client = c } sub := client . Subscription ( options . Subscription ) exists , err := sub . Exists ( ctx ) if err != nil { return nil , err } if ! exists { } if options . ReceiverGoRoutines != 0 { sub . ReceiveSettings . NumGoroutines = options . ReceiverGoRoutines } if options . ReceiverMaxBytes != 0 { sub . ReceiveSettings . MaxOutstandingBytes = options . ReceiverMaxBytes } if options . ReceiverMaxMessages != 0 { sub . ReceiveSettings . MaxOutstandingMessages = options . ReceiverMaxMessages } rcv := & PubSub { out : store , name : name , client : client , cancel : cancel , subscription : sub , logger : logger , closed : make ( chan struct { } ) , } m . Ack ( ) } ) if err == context . Canceled { close ( rcv . closed ) rcv . Stop ( ) break } if err != nil { rcv . logger . Error ( err . Error ( ) ) } time . Sleep ( 1 * time . Second ) } } ( ) return rcv , nil } 
func ( rcv * PubSub ) Stat ( send helper . StatCallback ) { messagesReceived := atomic . LoadUint32 ( & rcv . messagesReceived ) send ( " " , float64 ( messagesReceived ) ) metricsReceived := atomic . LoadUint32 ( & rcv . metricsReceived ) send ( " " , float64 ( metricsReceived ) ) errors := atomic . LoadUint32 ( & rcv . errors ) send ( " " , float64 ( errors ) ) if ! rcv . statsAsCounters { atomic . AddUint32 ( & rcv . messagesReceived , - messagesReceived ) atomic . AddUint32 ( & rcv . metricsReceived , - metricsReceived ) atomic . AddUint32 ( & rcv . errors , - errors ) } } 
func acquireGzipReader ( r io . Reader ) ( * gzip . Reader , error ) { v := gzipPool . Get ( ) if v == nil { return gzip . NewReader ( r ) } zr := v . ( * gzip . Reader ) if err := zr . Reset ( r ) ; err != nil { return nil , err } return zr , nil } 
func ( api * Api ) Addr ( ) net . Addr { if api . listener == nil { return nil } return api . listener . Addr ( ) } 
func ( api * Api ) Stat ( send helper . StatCallback ) { helper . SendAndSubstractUint32 ( " " , & api . stat . cacheRequests , send ) helper . SendAndSubstractUint32 ( " " , & api . stat . cacheRequestMetrics , send ) helper . SendAndSubstractUint32 ( " " , & api . stat . cacheResponseMetrics , send ) helper . SendAndSubstractUint32 ( " " , & api . stat . cacheResponsePoints , send ) } 
func ( api * Api ) Listen ( addr * net . TCPAddr ) error { return api . StartFunc ( func ( ) error { tcpListener , err := net . ListenTCP ( " " , addr ) if err != nil { return err } s := grpc . NewServer ( ) carbonpb . RegisterCarbonServer ( s , api ) api . Go ( func ( exit chan struct { } ) { <- exit s . Stop ( ) } ) api . Go ( func ( exit chan struct { } ) { defer s . Stop ( ) if err := s . Serve ( tcpListener ) ; err != nil { } ) api . listener = tcpListener return nil } ) } 
func New ( configFilename string ) * App { app := & App { ConfigFilename : configFilename , Config : NewConfig ( ) , PromRegistry : prometheus . NewPedanticRegistry ( ) , exit : make ( chan bool ) , } return app } 
func ( app * App ) configure ( ) error { var err error cfg , err := ReadConfig ( app . ConfigFilename ) if err != nil { return err } cfg . Common . GraphPrefix = strings . Replace ( cfg . Common . GraphPrefix , " " , hostname , - 1 ) } else { cfg . Common . GraphPrefix = strings . Replace ( cfg . Common . GraphPrefix , " " , " " , - 1 ) } if cfg . Whisper . Enabled { cfg . Whisper . Schemas , err = persister . ReadWhisperSchemas ( cfg . Whisper . SchemasFilename ) if err != nil { return err } if cfg . Whisper . AggregationFilename != " " { cfg . Whisper . Aggregation , err = persister . ReadWhisperAggregation ( cfg . Whisper . AggregationFilename ) if err != nil { return err } } else { cfg . Whisper . Aggregation = persister . NewWhisperAggregation ( ) } } if ! ( cfg . Cache . WriteStrategy == " " || cfg . Cache . WriteStrategy == " " || cfg . Cache . WriteStrategy == " " ) { return fmt . Errorf ( " \" \" \" \" \" \" " ) } if cfg . Common . MetricEndpoint == " " { cfg . Common . MetricEndpoint = MetricEndpointLocal } if cfg . Common . MetricEndpoint != MetricEndpointLocal { u , err := url . Parse ( cfg . Common . MetricEndpoint ) if err != nil { return fmt . Errorf ( " " , err . Error ( ) ) } if u . Scheme != " " && u . Scheme != " " { return fmt . Errorf ( " " , u . Scheme ) } } app . Config = cfg return nil } 
func ( app * App ) ParseConfig ( ) error { app . Lock ( ) defer app . Unlock ( ) err := app . configure ( ) if app . PromRegisterer == nil { app . PromRegisterer = prometheus . WrapRegistererWith ( prometheus . Labels ( app . Config . Prometheus . Labels ) , app . PromRegistry , ) } return err } 
func ( app * App ) ReloadConfig ( ) error { app . Lock ( ) defer app . Unlock ( ) var err error if err = app . configure ( ) ; err != nil { return err } runtime . GOMAXPROCS ( app . Config . Common . MaxCPU ) app . Cache . SetMaxSize ( app . Config . Cache . MaxSize ) app . Cache . SetWriteStrategy ( app . Config . Cache . WriteStrategy ) app . Cache . SetTagsEnabled ( app . Config . Tags . Enabled ) if app . Persister != nil { app . Persister . Stop ( ) app . Persister = nil } if app . Tags != nil { app . Tags . Stop ( ) app . Tags = nil } app . startPersister ( ) if app . Collector != nil { app . Collector . Stop ( ) app . Collector = nil } app . Collector = NewCollector ( app ) return nil } 
func ( app * App ) stopListeners ( ) { logger := zapwriter . Logger ( " " ) if app . Api != nil { app . Api . Stop ( ) app . Api = nil logger . Debug ( " " ) } if app . CarbonLink != nil { app . CarbonLink . Stop ( ) app . CarbonLink = nil logger . Debug ( " " ) } if app . Carbonserver != nil { carbonserver := app . Carbonserver go func ( ) { carbonserver . Stop ( ) logger . Debug ( " " ) } ( ) app . Carbonserver = nil } if app . Receivers != nil { for i := 0 ; i < len ( app . Receivers ) ; i ++ { app . Receivers [ i ] . Stop ( ) logger . Debug ( " " , zap . String ( " " , app . Receivers [ i ] . Name ) ) } app . Receivers = nil } } 
func ( app * App ) Start ( ) ( err error ) { app . Lock ( ) defer app . Unlock ( ) defer func ( ) { if err != nil { app . stopAll ( ) } } ( ) conf := app . Config runtime . GOMAXPROCS ( conf . Common . MaxCPU ) core := cache . New ( ) core . SetMaxSize ( conf . Cache . MaxSize ) core . SetWriteStrategy ( conf . Cache . WriteStrategy ) core . SetTagsEnabled ( conf . Tags . Enabled ) app . Cache = core if conf . Grpc . Enabled { var grpcAddr * net . TCPAddr grpcAddr , err = net . ResolveTCPAddr ( " " , conf . Grpc . Listen ) if err != nil { return } grpcApi := api . New ( core ) if err = grpcApi . Listen ( grpcAddr ) ; err != nil { return } app . Api = grpcApi } app . startPersister ( ) app . Receivers = make ( [ ] * NamedReceiver , 0 ) var rcv receiver . Receiver var rcvOptions map [ string ] interface { } if conf . Udp . Enabled { if rcvOptions , err = receiver . WithProtocol ( conf . Udp , " " ) ; err != nil { return } if rcv , err = receiver . New ( " " , rcvOptions , core . Add ) ; err != nil { return } app . Receivers = append ( app . Receivers , & NamedReceiver { Receiver : rcv , Name : " " , } ) } if conf . Tcp . Enabled { if rcvOptions , err = receiver . WithProtocol ( conf . Tcp , " " ) ; err != nil { return } if rcv , err = receiver . New ( " " , rcvOptions , core . Add ) ; err != nil { return } app . Receivers = append ( app . Receivers , & NamedReceiver { Receiver : rcv , Name : " " , } ) } if conf . Pickle . Enabled { if rcvOptions , err = receiver . WithProtocol ( conf . Pickle , " " ) ; err != nil { return } if rcv , err = receiver . New ( " " , rcvOptions , core . Add ) ; err != nil { return } app . Receivers = append ( app . Receivers , & NamedReceiver { Receiver : rcv , Name : " " , } ) } for receiverName , receiverOptions := range conf . Receiver { if rcv , err = receiver . New ( receiverName , receiverOptions , core . Add ) ; err != nil { return } app . Receivers = append ( app . Receivers , & NamedReceiver { Receiver : rcv , Name : receiverName , } ) } if conf . Carbonserver . Enabled { if err != nil { return } carbonserver := carbonserver . NewCarbonserverListener ( core . Get ) carbonserver . SetWhisperData ( conf . Whisper . DataDir ) carbonserver . SetMaxGlobs ( conf . Carbonserver . MaxGlobs ) carbonserver . SetFLock ( app . Config . Whisper . FLock ) carbonserver . SetFailOnMaxGlobs ( conf . Carbonserver . FailOnMaxGlobs ) carbonserver . SetBuckets ( conf . Carbonserver . Buckets ) carbonserver . SetMetricsAsCounters ( conf . Carbonserver . MetricsAsCounters ) carbonserver . SetScanFrequency ( conf . Carbonserver . ScanFrequency . Value ( ) ) carbonserver . SetReadTimeout ( conf . Carbonserver . ReadTimeout . Value ( ) ) carbonserver . SetIdleTimeout ( conf . Carbonserver . IdleTimeout . Value ( ) ) carbonserver . SetWriteTimeout ( conf . Carbonserver . WriteTimeout . Value ( ) ) carbonserver . SetQueryCacheEnabled ( conf . Carbonserver . QueryCacheEnabled ) carbonserver . SetFindCacheEnabled ( conf . Carbonserver . FindCacheEnabled ) carbonserver . SetQueryCacheSizeMB ( conf . Carbonserver . QueryCacheSizeMB ) carbonserver . SetTrigramIndex ( conf . Carbonserver . TrigramIndex ) carbonserver . SetInternalStatsDir ( conf . Carbonserver . InternalStatsDir ) carbonserver . SetPercentiles ( conf . Carbonserver . Percentiles ) } if err = carbonserver . Listen ( conf . Carbonserver . Listen ) ; err != nil { return } app . Carbonserver = carbonserver } if conf . Carbonlink . Enabled { var linkAddr * net . TCPAddr linkAddr , err = net . ResolveTCPAddr ( " " , conf . Carbonlink . Listen ) if err != nil { return } carbonlink := cache . NewCarbonlinkListener ( core ) carbonlink . SetReadTimeout ( conf . Carbonlink . ReadTimeout . Value ( ) ) } app . CarbonLink = carbonlink } if conf . Dump . Enabled { go app . Restore ( core . Add , conf . Dump . Path , conf . Dump . RestorePerSecond ) } app . Collector = NewCollector ( app ) return } 
func ( app * App ) Loop ( ) { app . RLock ( ) exitChan := app . exit app . RUnlock ( ) if exitChan != nil { <- app . exit } } 
func ( rcv * HTTP ) Addr ( ) net . Addr { if rcv . listener == nil { return nil } return rcv . listener . Addr ( ) } 
func ( o * Offset ) MarshalText ( ) ( [ ] byte , error ) { switch * o { case OffsetNewest : return [ ] byte ( " " ) , nil case OffsetOldest : return [ ] byte ( " " ) , nil } return [ ] byte ( fmt . Sprintf ( " " , * o ) ) , nil } 
func ( o * Offset ) UnmarshalText ( text [ ] byte ) error { offsetName := string ( text ) switch strings . ToLower ( offsetName ) { case " " : * o = OffsetNewest case " " : * o = OffsetOldest default : d , err := time . ParseDuration ( offsetName ) if err != nil { return err } * o = Offset ( time . Now ( ) . Add ( d ) . UnixNano ( ) ) } return nil } 
func ( p * Protocol ) MarshalText ( ) ( [ ] byte , error ) { switch * p { case ProtocolPlain : return [ ] byte ( " " ) , nil case ProtocolProtobuf : return [ ] byte ( " " ) , nil case ProtocolPickle : return [ ] byte ( " " ) , nil } return nil , fmt . Errorf ( " " , p , supportedProtocols ) } 
func ( p * Protocol ) UnmarshalText ( text [ ] byte ) error { protocolName := string ( text ) switch strings . ToLower ( protocolName ) { case " " : * p = ProtocolPlain case " " : * p = ProtocolProtobuf case " " : * p = ProtocolPickle default : return fmt . Errorf ( " " , protocolName , supportedProtocols ) } return nil } 
func ( d * Duration ) UnmarshalText ( text [ ] byte ) error { var err error d . Duration , err = time . ParseDuration ( string ( text ) ) return err } 
func NewOptions ( ) * Options { return & Options { Brokers : [ ] string { " " } , Topic : " " , Partition : 0 , Protocol : ProtocolPlain , InitialOffset : OffsetOldest , StateSaveInterval : & Duration { Duration : 60 * time . Second } , ReconnectInterval : & Duration { Duration : 60 * time . Second } , FetchInterval : & Duration { Duration : 250 * time . Millisecond } , KafkaVersion : " " , } } 
func ( rcv * Kafka ) Stat ( send helper . StatCallback ) { metricsReceived := atomic . LoadUint64 ( & rcv . metricsReceived ) send ( " " , float64 ( metricsReceived ) ) errors := atomic . LoadUint64 ( & rcv . errors ) send ( " " , float64 ( errors ) ) if ! rcv . statsAsCounters { atomic . AddUint64 ( & rcv . metricsReceived , - metricsReceived ) atomic . AddUint64 ( & rcv . errors , - errors ) } } 
func ( rcv * TCP ) Addr ( ) net . Addr { if rcv . listener == nil { return nil } return rcv . listener . Addr ( ) } 
func ( rcv * TCP ) Listen ( addr * net . TCPAddr ) error { return rcv . StartFunc ( func ( ) error { tcpListener , err := net . ListenTCP ( " " , addr ) if err != nil { return err } rcv . Go ( func ( exit chan bool ) { <- exit tcpListener . Close ( ) } ) handler := rcv . HandleConnection if rcv . isFraming { handler = rcv . handleFraming } if rcv . buffer != nil { originalOut := rcv . out rcv . Go ( func ( exit chan bool ) { for { select { case <- exit : return case p := <- rcv . buffer : originalOut ( p ) } } } ) rcv . out = func ( p * points . Points ) { rcv . buffer <- p } } rcv . Go ( func ( exit chan bool ) { defer tcpListener . Close ( ) for { conn , err := tcpListener . Accept ( ) if err != nil { if strings . Contains ( err . Error ( ) , " " ) { break } rcv . logger . Warn ( " " , zap . Error ( err ) , ) continue } rcv . Go ( func ( exit chan bool ) { handler ( conn ) } ) } } ) rcv . listener = tcpListener return nil } ) } 
func WithProtocol ( options interface { } , protocol string ) ( map [ string ] interface { } , error ) { buf := new ( bytes . Buffer ) encoder := toml . NewEncoder ( buf ) encoder . Indent = " " if err := encoder . Encode ( options ) ; err != nil { return nil , err } res := make ( map [ string ] interface { } ) if _ , err := toml . Decode ( buf . String ( ) , & res ) ; err != nil { return nil , err } res [ " " ] = protocol return res , nil } 
func New ( ) * Cache { c := & Cache { data : make ( [ ] * Shard , shardCount ) , writeStrategy : Noop , } for i := 0 ; i < shardCount ; i ++ { c . data [ i ] = & Shard { items : make ( map [ string ] * points . Points ) , notConfirmed : make ( [ ] * points . Points , 4 ) , } } settings := cacheSettings { maxSize : 1000000 , tagsEnabled : false , xlog : nil , } c . settings . Store ( & settings ) c . writeoutQueue = NewWriteoutQueue ( c ) return c } 
func ( c * Cache ) SetWriteStrategy ( s string ) ( err error ) { c . Lock ( ) defer c . Unlock ( ) switch s { case " " : c . writeStrategy = MaximumLength case " " : c . writeStrategy = TimestampOrder case " " : c . writeStrategy = Noop default : return fmt . Errorf ( " " , s ) } return nil } 
func ( c * Cache ) SetMaxSize ( maxSize uint32 ) { s := c . settings . Load ( ) . ( * cacheSettings ) newSettings := * s newSettings . maxSize = int32 ( maxSize ) c . settings . Store ( & newSettings ) } 
func ( c * Cache ) Stat ( send helper . StatCallback ) { s := c . settings . Load ( ) . ( * cacheSettings ) send ( " " , float64 ( c . Size ( ) ) ) send ( " " , float64 ( c . Len ( ) ) ) send ( " " , float64 ( s . maxSize ) ) helper . SendAndSubstractUint32 ( " " , & c . stat . queryCnt , send ) helper . SendAndSubstractUint32 ( " " , & c . stat . tagsNormalizeErrors , send ) helper . SendAndSubstractUint32 ( " " , & c . stat . overflowCnt , send ) helper . SendAndSubstractUint32 ( " " , & c . stat . queueBuildCnt , send ) helper . SendAndSubstractUint32 ( " " , & c . stat . queueBuildTimeMs , send ) helper . SendUint32 ( " " , & c . stat . queueWriteoutTime , send ) } 
func fnv32 ( key string ) uint32 { hash := uint32 ( 2166136261 ) const prime32 = uint32 ( 16777619 ) for i := 0 ; i < len ( key ) ; i ++ { hash *= prime32 hash ^= uint32 ( key [ i ] ) } return hash } 
func ( c * Cache ) GetShard ( key string ) * Shard { } 
func ( c * Cache ) Add ( p * points . Points ) { s := c . settings . Load ( ) . ( * cacheSettings ) if s . xlog != nil { p . WriteTo ( s . xlog ) return } if s . tagsEnabled { var err error p . Metric , err = tags . Normalize ( p . Metric ) if err != nil { atomic . AddUint32 ( & c . stat . tagsNormalizeErrors , 1 ) return } } if s . maxSize > 0 && c . Size ( ) > s . maxSize { atomic . AddUint32 ( & c . stat . overflowCnt , uint32 ( count ) ) return } shard := c . GetShard ( p . Metric ) shard . Lock ( ) if values , exists := shard . items [ p . Metric ] ; exists { values . Data = append ( values . Data , p . Data ... ) } else { shard . items [ p . Metric ] = p } shard . Unlock ( ) atomic . AddInt32 ( & c . stat . size , int32 ( count ) ) } 
func ( c * Cache ) Pop ( key string ) ( p * points . Points , exists bool ) { shard . Lock ( ) p , exists = shard . items [ key ] delete ( shard . items , key ) shard . Unlock ( ) if exists { atomic . AddInt32 ( & c . stat . size , - int32 ( len ( p . Data ) ) ) } return p , exists } 
func ( s * Stoppable ) StopFunc ( callable func ( ) ) { s . Lock ( ) defer s . Unlock ( ) } s . doStop ( callable ) } 
func ParseCarbonlinkRequest ( d [ ] byte ) ( * CarbonlinkRequest , error ) { if ! ( expectBytes ( & d , [ ] byte ( " \x80 \x02 " ) ) && pickleMaybeMemo ( & d ) && expectBytes ( & d , [ ] byte ( " " ) ) ) { return nil , badErr } req := NewCarbonlinkRequest ( ) var Metric , Type string var ok bool if expectBytes ( & d , [ ] byte ( " \x06 " ) ) { if ! pickleMaybeMemo ( & d ) { return nil , badErr } if Metric , ok = pickleGetStr ( & d ) ; ! ok { return nil , badErr } if ! ( pickleMaybeMemo ( & d ) && expectBytes ( & d , [ ] byte ( " \x04 " ) ) && pickleMaybeMemo ( & d ) ) { return nil , badErr } if Type , ok = pickleGetStr ( & d ) ; ! ok { return nil , badErr } if ! pickleMaybeMemo ( & d ) { return nil , badErr } req . Metric = Metric req . Type = Type } else if expectBytes ( & d , [ ] byte ( " \x04 " ) ) { if ! pickleMaybeMemo ( & d ) { return nil , badErr } if Type , ok = pickleGetStr ( & d ) ; ! ok { return nil , badErr } if ! ( pickleMaybeMemo ( & d ) && expectBytes ( & d , [ ] byte ( " \x06 " ) ) && pickleMaybeMemo ( & d ) ) { return nil , badErr } if Metric , ok = pickleGetStr ( & d ) ; ! ok { return nil , badErr } if ! pickleMaybeMemo ( & d ) { return nil , badErr } req . Metric = Metric req . Type = Type } else { return nil , badErr } return req , nil } 
func NewCarbonlinkListener ( cache * Cache ) * CarbonlinkListener { return & CarbonlinkListener { cache : cache , readTimeout : 30 * time . Second , } } 
func ( listener * CarbonlinkListener ) Addr ( ) net . Addr { if listener . tcpListener == nil { return nil } return listener . tcpListener . Addr ( ) } 
func ( listener * CarbonlinkListener ) Listen ( addr * net . TCPAddr ) error { return listener . StartFunc ( func ( ) error { tcpListener , err := net . ListenTCP ( " " , addr ) if err != nil { return err } listener . tcpListener = tcpListener listener . Go ( func ( exit chan bool ) { select { case <- exit : tcpListener . Close ( ) } } ) listener . Go ( func ( exit chan bool ) { defer tcpListener . Close ( ) for { conn , err := tcpListener . Accept ( ) if err != nil { if strings . Contains ( err . Error ( ) , " " ) { break } zapwriter . Logger ( " " ) . Error ( " " , zap . Error ( err ) ) continue } framedConn , _ := framing . NewConn ( conn , byte ( 4 ) , binary . BigEndian ) framedConn . MaxFrameSize = 1048576 go listener . HandleConnection ( * framedConn ) } } ) return nil } ) } 
func OnePoint ( metric string , value float64 , timestamp int64 ) * Points { return & Points { Metric : metric , Data : [ ] Point { Point { Value : value , Timestamp : timestamp , } , } , } } 
func NowPoint ( metric string , value float64 ) * Points { return OnePoint ( metric , value , time . Now ( ) . Unix ( ) ) } 
func ( p * Points ) Copy ( ) * Points { return & Points { Metric : p . Metric , Data : p . Data , } } 
func ParseText ( line string ) ( * Points , error ) { row := strings . Split ( strings . Trim ( line , " \n \t \r " ) , " " ) if len ( row ) != 3 { return nil , fmt . Errorf ( " " , line ) } if err != nil || math . IsNaN ( value ) { return nil , fmt . Errorf ( " " , line ) } tsf , err := strconv . ParseFloat ( row [ 2 ] , 64 ) if err != nil || math . IsNaN ( tsf ) { return nil , fmt . Errorf ( " " , line ) } } 
func ( p * Points ) Append ( onePoint Point ) * Points { p . Data = append ( p . Data , onePoint ) return p } 
func ( p * Points ) Add ( value float64 , timestamp int64 ) * Points { p . Data = append ( p . Data , Point { Value : value , Timestamp : timestamp , } ) return p } 
func ( p * Points ) Eq ( other * Points ) bool { if other == nil { return false } if p . Metric != other . Metric { return false } if p . Data == nil && other . Data == nil { return true } if ( p . Data == nil || other . Data == nil ) && ( p . Data != nil || other . Data != nil ) { return false } if len ( p . Data ) != len ( other . Data ) { return false } for i := 0 ; i < len ( p . Data ) ; i ++ { if p . Data [ i ] . Value != other . Data [ i ] . Value { return false } if p . Data [ i ] . Timestamp != other . Data [ i ] . Timestamp { return false } } return true } 
func NewConfig ( ) * Config { cfg := & Config { Common : commonConfig { GraphPrefix : " " , MetricInterval : & Duration { Duration : time . Minute , } , MetricEndpoint : MetricEndpointLocal , MaxCPU : 1 , User : " " , } , Whisper : whisperConfig { DataDir : " " , SchemasFilename : " " , AggregationFilename : " " , MaxUpdatesPerSecond : 0 , Enabled : true , Workers : 1 , Sparse : false , FLock : false , HashFilenames : true , } , Cache : cacheConfig { MaxSize : 1000000 , WriteStrategy : " " , } , Udp : udp . NewOptions ( ) , Tcp : tcp . NewOptions ( ) , Pickle : tcp . NewFramingOptions ( ) , Carbonserver : carbonserverConfig { Listen : " " , Enabled : false , Buckets : 10 , MaxGlobs : 100 , FailOnMaxGlobs : false , MetricsAsCounters : false , ScanFrequency : & Duration { Duration : 300 * time . Second , } , ReadTimeout : & Duration { Duration : 60 * time . Second , } , IdleTimeout : & Duration { Duration : 60 * time . Second , } , WriteTimeout : & Duration { Duration : 60 * time . Second , } , QueryCacheEnabled : true , QueryCacheSizeMB : 0 , FindCacheEnabled : true , TrigramIndex : true , } , Carbonlink : carbonlinkConfig { Listen : " " , Enabled : true , ReadTimeout : & Duration { Duration : 30 * time . Second , } , } , Grpc : grpcConfig { Listen : " " , Enabled : true , } , Tags : tagsConfig { Enabled : false , TagDB : " " , TagDBTimeout : & Duration { Duration : time . Second , } , TagDBChunkSize : 32 , TagDBUpdateInterval : 100 , LocalDir : " " , } , Pprof : pprofConfig { Listen : " " , Enabled : false , } , Dump : dumpConfig { Path : " " , } , Prometheus : prometheusConfig { Enabled : false , Endpoint : " " , Labels : make ( map [ string ] string ) , } , Logging : nil , } return cfg } 
func PrintDefaultConfig ( ) error { cfg := NewConfig ( ) buf := new ( bytes . Buffer ) if cfg . Logging == nil { cfg . Logging = make ( [ ] zapwriter . Config , 0 ) } if len ( cfg . Logging ) == 0 { cfg . Logging = append ( cfg . Logging , NewLoggingConfig ( ) ) } encoder := toml . NewEncoder ( buf ) encoder . Indent = " " if err := encoder . Encode ( cfg ) ; err != nil { return err } fmt . Print ( buf . String ( ) ) return nil } 
func ReadConfig ( filename string ) ( * Config , error ) { cfg := NewConfig ( ) if filename != " " { b , err := ioutil . ReadFile ( filename ) if err != nil { return nil , err } body := string ( b ) if _ , err := toml . Decode ( body , cfg ) ; err != nil { return nil , err } } if cfg . Logging == nil { cfg . Logging = make ( [ ] zapwriter . Config , 0 ) } if cfg . Common . LogLevel != nil || cfg . Common . Logfile != nil { log . Println ( " " ) l := NewLoggingConfig ( ) if cfg . Common . Logfile != nil { l . File = * cfg . Common . Logfile } if cfg . Common . LogLevel != nil { l . Level = * cfg . Common . LogLevel } cfg . Logging = [ ] zapwriter . Config { l } } if len ( cfg . Logging ) == 0 { cfg . Logging = append ( cfg . Logging , NewLoggingConfig ( ) ) } if err := zapwriter . CheckConfig ( cfg . Logging , nil ) ; err != nil { return nil , err } return cfg , nil } 
func ( s WhisperSchemas ) Match ( metric string ) ( Schema , bool ) { for _ , schema := range s { if schema . Pattern . MatchString ( metric ) { return schema , true } } return Schema { } , false } 
func ParseRetentionDefs ( retentionDefs string ) ( whisper . Retentions , error ) { retentions := make ( whisper . Retentions , 0 ) for _ , retentionDef := range strings . Split ( retentionDefs , " " ) { retentionDef = strings . TrimSpace ( retentionDef ) parts := strings . Split ( retentionDef , " " ) if len ( parts ) != 2 { return nil , fmt . Errorf ( " " , retentionDef ) } val2 , err2 := strconv . ParseInt ( parts [ 1 ] , 10 , 0 ) if err1 == nil && err2 == nil { retention := whisper . NewRetention ( int ( val1 ) , int ( val2 ) ) retentions = append ( retentions , & retention ) continue } if err != nil { return nil , err } retentions = append ( retentions , retention ) } return retentions , nil } 
func ReadWhisperSchemas ( filename string ) ( WhisperSchemas , error ) { config , err := parseIniFile ( filename ) if err != nil { return nil , err } var schemas WhisperSchemas for i , section := range config { schema := Schema { } schema . Name = section [ " " ] if section [ " " ] == " " { return nil , fmt . Errorf ( " " , schema . Name ) } schema . Pattern , err = regexp . Compile ( section [ " " ] ) if err != nil { return nil , fmt . Errorf ( " " , section [ " " ] , schema . Name , err . Error ( ) ) } schema . RetentionStr = section [ " " ] schema . Retentions , err = ParseRetentionDefs ( schema . RetentionStr ) if err != nil { return nil , fmt . Errorf ( " " , schema . RetentionStr , schema . Name , err . Error ( ) ) } p := int64 ( 0 ) if section [ " " ] != " " { p , err = strconv . ParseInt ( section [ " " ] , 10 , 0 ) if err != nil { return nil , fmt . Errorf ( " " , section [ " " ] , schema . Name , err ) } } schema . Priority = int64 ( p ) << 32 - int64 ( i ) schemas = append ( schemas , schema ) } sort . Sort ( schemas ) return schemas , nil } 
func ( app * App ) DumpStop ( ) error { app . Lock ( ) defer app . Unlock ( ) if ! app . Config . Dump . Enabled { return nil } if app . Persister != nil { app . Persister . Stop ( ) app . Persister = nil } logger := zapwriter . Logger ( " " ) logger . Info ( " " ) filenamePostfix := fmt . Sprintf ( " " , os . Getpid ( ) , time . Now ( ) . UnixNano ( ) ) dumpFilename := path . Join ( app . Config . Dump . Path , fmt . Sprintf ( " " , filenamePostfix ) ) xlogFilename := path . Join ( app . Config . Dump . Path , fmt . Sprintf ( " " , filenamePostfix ) ) logger . Info ( " " , zap . String ( " " , xlogFilename ) ) if err != nil { return err } dumpWriter := bufio . NewWriterSize ( dump , 1048576 ) if err != nil { return err } xlogWriter := & SyncWriter { w : bufio . NewWriterSize ( xlog , 4096 ) } app . Cache . DivertToXlog ( xlogWriter ) cacheSize := app . Cache . Size ( ) if err != nil { logger . Info ( " " , zap . Error ( err ) ) return err } logger . Info ( " " , zap . Int ( " " , int ( cacheSize ) ) , zap . Duration ( " " , time . Since ( dumpStart ) ) , ) if err = dumpWriter . Flush ( ) ; err != nil { logger . Info ( " " , zap . Error ( err ) ) return err } if err = dump . Close ( ) ; err != nil { logger . Info ( " " , zap . Error ( err ) ) return err } logger . Info ( " " ) stopped := make ( chan struct { } ) go func ( ) { app . stopListeners ( ) if err := xlogWriter . Flush ( ) ; err != nil { logger . Info ( " " , zap . Error ( err ) ) return } if err := xlog . Close ( ) ; err != nil { logger . Info ( " " , zap . Error ( err ) ) return } close ( stopped ) } ( ) select { case <- time . After ( 5 * time . Second ) : logger . Info ( " " ) case <- stopped : logger . Info ( " " ) } } 
func ( app * App ) RestoreFromFile ( filename string , storeFunc func ( * points . Points ) ) error { var pointsCount int startTime := time . Now ( ) logger := zapwriter . Logger ( " " ) . With ( zap . String ( " " , filename ) ) logger . Info ( " " ) defer func ( ) { logger . Info ( " " , zap . Int ( " " , pointsCount ) , zap . Duration ( " " , time . Since ( startTime ) ) , ) } ( ) err := points . ReadFromFile ( filename , func ( p * points . Points ) { pointsCount += len ( p . Data ) storeFunc ( p ) } ) return err } 
func ( app * App ) RestoreFromDir ( dumpDir string , storeFunc func ( * points . Points ) ) { startTime := time . Now ( ) logger := zapwriter . Logger ( " " ) . With ( zap . String ( " " , dumpDir ) ) defer func ( ) { logger . Info ( " " , zap . Duration ( " " , time . Since ( startTime ) ) , ) } ( ) files , err := ioutil . ReadDir ( dumpDir ) if err != nil { logger . Error ( " " , zap . Error ( err ) ) return } FilesLoop : for _ , file := range files { if file . IsDir ( ) { continue } r := strings . Split ( file . Name ( ) , " " ) if len ( r ) < 3 { } var fileWithSortPrefix string switch r [ 0 ] { case " " : fileWithSortPrefix = fmt . Sprintf ( " " , r [ 2 ] , " " , file . Name ( ) ) case " " : fileWithSortPrefix = fmt . Sprintf ( " " , r [ 2 ] , " " , file . Name ( ) ) default : continue FilesLoop } list = append ( list , fileWithSortPrefix ) } if len ( list ) == 0 { logger . Info ( " " ) return } sort . Strings ( list ) for index , fileWithSortPrefix := range list { list [ index ] = strings . SplitN ( fileWithSortPrefix , " " , 2 ) [ 1 ] } logger . Info ( " " , zap . Int ( " " , len ( list ) ) ) for _ , fn := range list { filename := path . Join ( dumpDir , fn ) app . RestoreFromFile ( filename , storeFunc ) err = os . Remove ( filename ) if err != nil { logger . Error ( " " , zap . String ( " " , filename ) , zap . Error ( err ) ) } } } 
func ( app * App ) Restore ( storeFunc func ( * points . Points ) , path string , rps int ) { if rps > 0 { ticker := persister . NewThrottleTicker ( rps ) defer ticker . Stop ( ) throttledStoreFunc := func ( p * points . Points ) { for i := 0 ; i < len ( p . Data ) ; i ++ { <- ticker . C } storeFunc ( p ) } app . RestoreFromDir ( path , throttledStoreFunc ) } else { app . RestoreFromDir ( path , storeFunc ) } } 
func GetStat ( i os . FileInfo ) FileStats { res := FileStats { Size : i . Size ( ) , MTime : i . ModTime ( ) . Unix ( ) , CTime : i . ModTime ( ) . Unix ( ) , } s := i . Sys ( ) . ( * syscall . Stat_t ) if s != nil { res . RealSize = s . Blocks * 512 } return res } 
func Root ( t * testing . T , callback func ( dir string ) ) { tmpDir , err := ioutil . TempDir ( " " , " " ) if err != nil { t . Fatal ( err ) } defer func ( ) { if err := os . RemoveAll ( tmpDir ) ; err != nil { t . Fatal ( err ) } } ( ) callback ( tmpDir ) } 
func ( rcv * UDP ) Addr ( ) net . Addr { if rcv . conn == nil { return nil } return rcv . conn . LocalAddr ( ) } 
func ( rcv * UDP ) Listen ( addr * net . UDPAddr ) error { return rcv . StartFunc ( func ( ) error { var err error rcv . conn , err = net . ListenUDP ( " " , addr ) if err != nil { return err } rcv . Go ( func ( exit chan bool ) { <- exit rcv . conn . Close ( ) } ) if rcv . buffer != nil { originalOut := rcv . out rcv . Go ( func ( exit chan bool ) { for { select { case <- exit : return case p := <- rcv . buffer : originalOut ( p ) } } } ) rcv . out = func ( p * points . Points ) { rcv . buffer <- p } } rcv . Go ( rcv . receiveWorker ) return nil } ) } 
func ( q * Queue ) delete ( key [ ] byte ) { err := q . db . Delete ( [ ] byte ( key ) , nil ) atomic . AddUint32 ( & q . stat . deleteCount , 1 ) if err != nil { atomic . AddUint32 ( & q . stat . deleteErrors , 1 ) q . logger . Error ( " " , zap . Error ( err ) ) } } 
func NewWhisper ( rootPath string , schemas WhisperSchemas , aggregation * WhisperAggregation , recv func ( chan bool ) string , pop func ( string ) ( * points . Points , bool ) , confirm func ( * points . Points ) ) * Whisper { return & Whisper { recv : recv , pop : pop , confirm : confirm , schemas : schemas , aggregation : aggregation , workersCount : 1 , rootPath : rootPath , maxUpdatesPerSecond : 0 , logger : zapwriter . Logger ( " " ) , createLogger : zapwriter . Logger ( " " ) , } } 
func ( p * Whisper ) SetWorkers ( count int ) { if count >= 1 { p . workersCount = count } else { p . workersCount = 1 } } 
func ( p * Whisper ) Stat ( send helper . StatCallback ) { updateOperations := atomic . LoadUint32 ( & p . updateOperations ) committedPoints := atomic . LoadUint32 ( & p . committedPoints ) atomic . AddUint32 ( & p . updateOperations , - updateOperations ) atomic . AddUint32 ( & p . committedPoints , - committedPoints ) created := atomic . LoadUint32 ( & p . created ) atomic . AddUint32 ( & p . created , - created ) throttledCreates := atomic . LoadUint32 ( & p . throttledCreates ) atomic . AddUint32 ( & p . throttledCreates , - throttledCreates ) send ( " " , float64 ( updateOperations ) ) send ( " " , float64 ( committedPoints ) ) if updateOperations > 0 { send ( " " , float64 ( committedPoints ) / float64 ( updateOperations ) ) } else { send ( " " , 0.0 ) } send ( " " , float64 ( created ) ) send ( " " , float64 ( throttledCreates ) ) send ( " " , float64 ( p . maxCreatesPerSecond ) ) send ( " " , float64 ( p . maxUpdatesPerSecond ) ) send ( " " , float64 ( p . workersCount ) ) 
func ( p * Whisper ) Start ( ) error { return p . StartFunc ( func ( ) error { p . throttleTicker = NewThrottleTicker ( p . maxUpdatesPerSecond ) if p . hardMaxCreatesPerSecond { p . maxCreatesTicker = NewHardThrottleTicker ( p . maxCreatesPerSecond ) } else { p . maxCreatesTicker = NewThrottleTicker ( p . maxCreatesPerSecond ) } for i := 0 ; i < p . workersCount ; i ++ { p . Go ( p . worker ) } return nil } ) } 
func NewWhisperAggregation ( ) * WhisperAggregation { return & WhisperAggregation { Data : make ( [ ] * whisperAggregationItem , 0 ) , Default : & whisperAggregationItem { name : " " , pattern : nil , xFilesFactor : 0.5 , aggregationMethodStr : " " , aggregationMethod : whisper . Average , } , } } 
func ReadWhisperAggregation ( filename string ) ( * WhisperAggregation , error ) { config , err := parseIniFile ( filename ) if err != nil { return nil , err } result := NewWhisperAggregation ( ) for _ , section := range config { item := & whisperAggregationItem { } item . pattern , err = regexp . Compile ( section [ " " ] ) if err != nil { return nil , fmt . Errorf ( " " , section [ " " ] , item . name , err . Error ( ) ) } item . xFilesFactor , err = strconv . ParseFloat ( section [ " " ] , 64 ) if err != nil { return nil , fmt . Errorf ( " " , section [ " " ] , item . name , err . Error ( ) ) } item . aggregationMethodStr = section [ " " ] switch item . aggregationMethodStr { case " " , " " : item . aggregationMethod = whisper . Average case " " : item . aggregationMethod = whisper . Sum case " " : item . aggregationMethod = whisper . Last case " " : item . aggregationMethod = whisper . Max case " " : item . aggregationMethod = whisper . Min default : return nil , fmt . Errorf ( " " , section [ " " ] ) } result . Data = append ( result . Data , item ) } return result , nil } 
func ( a * WhisperAggregation ) match ( metric string ) * whisperAggregationItem { for _ , s := range a . Data { if s . pattern . MatchString ( metric ) { return s } } return a . Default } 
func oldPlain ( body [ ] byte ) ( [ ] * points . Points , error ) { result := make ( [ ] * points . Points , 4 ) reader := bytes . NewBuffer ( body ) for { line , err := reader . ReadBytes ( '\n' ) if err != nil && err != io . EOF { return result , err } if len ( line ) == 0 { break } if line [ len ( line ) - 1 ] != '\n' { return result , errors . New ( " " ) } p , err := points . ParseText ( string ( line ) ) if err != nil { return result , err } result = append ( result , p ) } return result , nil } 
func ( t * Tags ) Stat ( send helper . StatCallback ) { helper . SendAndSubstractUint32 ( " " , & t . q . stat . putErrors , send ) helper . SendAndSubstractUint32 ( " " , & t . q . stat . putCount , send ) helper . SendAndSubstractUint32 ( " " , & t . q . stat . deleteErrors , send ) helper . SendAndSubstractUint32 ( " " , & t . q . stat . deleteCount , send ) helper . SendAndSubstractUint32 ( " " , & t . q . stat . sendFail , send ) helper . SendAndSubstractUint32 ( " " , & t . q . stat . sendSuccess , send ) send ( " " , t . q . Lag ( ) . Seconds ( ) ) } 
func normalizeOriginal ( s string ) ( string , error ) { arr := strings . Split ( s , " " ) if len ( arr [ 0 ] ) == 0 { return " " , fmt . Errorf ( " " , s ) } tags := make ( map [ string ] string ) for i := 1 ; i < len ( arr ) ; i ++ { kv := strings . SplitN ( arr [ i ] , " " , 2 ) if len ( kv ) != 2 || len ( kv [ 0 ] ) == 0 { return " " , fmt . Errorf ( " " , s , arr [ i ] ) } tags [ kv [ 0 ] ] = kv [ 1 ] } tmp := make ( [ ] string , len ( tags ) ) i := 0 for k , v := range tags { tmp [ i ] = fmt . Sprintf ( " " , k , v ) i ++ } sort . Strings ( tmp ) result := arr [ 0 ] + strings . Join ( tmp , " " ) return result , nil } 
func ( client * Client ) CreateIntegrationPD ( pdIntegration * IntegrationPDRequest ) error { return client . doJsonRequest ( " " , " " , pdIntegration , nil ) } 
func ( client * Client ) UpdateIntegrationPD ( pdIntegration * IntegrationPDRequest ) error { return client . doJsonRequest ( " " , " " , pdIntegration , nil ) } 
func ( client * Client ) GetIntegrationPD ( ) ( * integrationPD , error ) { var out integrationPD if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) CreateIntegrationSlack ( slackIntegration * IntegrationSlackRequest ) error { return client . doJsonRequest ( " " , " " , slackIntegration , nil ) } 
func ( client * Client ) UpdateIntegrationSlack ( slackIntegration * IntegrationSlackRequest ) error { return client . doJsonRequest ( " " , " " , slackIntegration , nil ) } 
func ( client * Client ) GetIntegrationSlack ( ) ( * IntegrationSlackRequest , error ) { var out IntegrationSlackRequest if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) CreateIntegrationAWS ( awsAccount * IntegrationAWSAccount ) ( * IntegrationAWSAccountCreateResponse , error ) { var out IntegrationAWSAccountCreateResponse if err := client . doJsonRequest ( " " , " " , awsAccount , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) GetIntegrationAWS ( ) ( * [ ] IntegrationAWSAccount , error ) { var response IntegrationAWSAccountGetResponse if err := client . doJsonRequest ( " " , " " , nil , & response ) ; err != nil { return nil , err } return & response . Accounts , nil } 
func ( client * Client ) DeleteIntegrationAWS ( awsAccount * IntegrationAWSAccountDeleteRequest ) error { return client . doJsonRequest ( " " , " " , awsAccount , nil ) } 
func ( client * Client ) ListIntegrationGCP ( ) ( [ ] * IntegrationGCP , error ) { var list [ ] * IntegrationGCP if err := client . doJsonRequest ( " " , " " , nil , & list ) ; err != nil { return nil , err } return list , nil } 
func ( client * Client ) CreateIntegrationGCP ( cir * IntegrationGCPCreateRequest ) error { return client . doJsonRequest ( " " , " " , cir , nil ) } 
func ( client * Client ) UpdateIntegrationGCP ( cir * IntegrationGCPUpdateRequest ) error { return client . doJsonRequest ( " " , " " , cir , nil ) } 
func ( client * Client ) DeleteIntegrationGCP ( cir * IntegrationGCPDeleteRequest ) error { return client . doJsonRequest ( " " , " " , cir , nil ) } 
func ( client * Client ) GetDashboardList ( id int ) ( * DashboardList , error ) { var out DashboardList if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) GetDashboardLists ( ) ( [ ] DashboardList , error ) { var out reqGetDashboardLists if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return out . DashboardLists , nil } 
func ( client * Client ) CreateDashboardList ( list * DashboardList ) ( * DashboardList , error ) { var out DashboardList if err := client . doJsonRequest ( " " , " " , list , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) UpdateDashboardList ( list * DashboardList ) error { req := reqUpdateDashboardList { list . GetName ( ) } return client . doJsonRequest ( " " , fmt . Sprintf ( " " , * list . Id ) , req , nil ) } 
func ( client * Client ) GetDashboardListItems ( id int ) ( [ ] DashboardListItem , error ) { var out reqDashboardListItems if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err != nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) AddDashboardListItems ( dashboardListId int , items [ ] DashboardListItem ) ( [ ] DashboardListItem , error ) { req := reqDashboardListItems { items } var out reqAddedDashboardListItems if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , dashboardListId ) , req , & out ) ; err != nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) Snapshot ( query string , start , end time . Time , eventQuery string ) ( string , error ) { options := map [ string ] string { " " : query , " " : eventQuery } return client . SnapshotGeneric ( options , start , end ) } 
func ( client * Client ) SnapshotGeneric ( options map [ string ] string , start , end time . Time ) ( string , error ) { v := url . Values { } v . Add ( " " , fmt . Sprintf ( " " , start . Unix ( ) ) ) v . Add ( " " , fmt . Sprintf ( " " , end . Unix ( ) ) ) for opt , val := range options { v . Add ( opt , val ) } return client . doSnapshotRequest ( v ) } 
func ( p * PrecisionT ) UnmarshalJSON ( data [ ] byte ) error { var err error var precisionNum json . Number if err = json . Unmarshal ( data , & precisionNum ) ; err == nil { * p = PrecisionT ( precisionNum ) return nil } var precisionStr string if err = json . Unmarshal ( data , & precisionStr ) ; err == nil { * p = PrecisionT ( precisionStr ) return nil } var p0 PrecisionT * p = p0 return err } 
func ( client * Client ) SearchHosts ( search string ) ( [ ] string , error ) { var out reqSearch if err := client . doJsonRequest ( " " , " " + search , nil , & out ) ; err != nil { return nil , err } return out . Results . Hosts , nil } 
func ( client * Client ) SearchMetrics ( search string ) ( [ ] string , error ) { var out reqSearch if err := client . doJsonRequest ( " " , " " + search , nil , & out ) ; err != nil { return nil , err } return out . Results . Metrics , nil } 
func ( client * Client ) CreateAlert ( alert * Alert ) ( * Alert , error ) { var out Alert if err := client . doJsonRequest ( " " , " " , alert , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) UpdateAlert ( alert * Alert ) error { return client . doJsonRequest ( " " , fmt . Sprintf ( " " , alert . Id ) , alert , nil ) } 
func ( client * Client ) GetAlert ( id int ) ( * Alert , error ) { var out Alert if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) GetAlerts ( ) ( [ ] Alert , error ) { var out reqAlerts if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return out . Alerts , nil } 
func ( client * Client ) CreateComment ( handle , message string ) ( * Comment , error ) { var out reqComment comment := Comment { Message : String ( message ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } if err := client . doJsonRequest ( " " , " " , & comment , & out ) ; err != nil { return nil , err } return out . Comment , nil } 
func ( client * Client ) CreateRelatedComment ( handle , message string , relid int ) ( * Comment , error ) { var out reqComment comment := Comment { Message : String ( message ) , RelatedId : Int ( relid ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } if err := client . doJsonRequest ( " " , " " , & comment , & out ) ; err != nil { return nil , err } return out . Comment , nil } 
func ( client * Client ) EditComment ( id int , handle , message string ) error { comment := Comment { Message : String ( message ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } return client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , & comment , nil ) } 
func ( client * Client ) CreateMonitor ( monitor * Monitor ) ( * Monitor , error ) { var out Monitor } return & out , nil } 
func ( client * Client ) UpdateMonitor ( monitor * Monitor ) error { return client . doJsonRequest ( " " , fmt . Sprintf ( " " , * monitor . Id ) , monitor , nil ) } 
func ( client * Client ) GetMonitor ( id int ) ( * Monitor , error ) { var out Monitor if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( self * Client ) GetMonitorsByName ( name string ) ( [ ] Monitor , error ) { var out reqMonitors query , err := url . ParseQuery ( fmt . Sprintf ( " " , name ) ) if err != nil { return nil , err } err = self . doJsonRequest ( " " , fmt . Sprintf ( " " , query . Encode ( ) ) , nil , & out . Monitors ) if err != nil { return nil , err } return out . Monitors , nil } 
func ( self * Client ) GetMonitorsByTags ( tags [ ] string ) ( [ ] Monitor , error ) { var out reqMonitors query , err := url . ParseQuery ( fmt . Sprintf ( " " , strings . Join ( tags , " " ) ) ) if err != nil { return nil , err } err = self . doJsonRequest ( " " , fmt . Sprintf ( " " , query . Encode ( ) ) , nil , & out . Monitors ) if err != nil { return nil , err } return out . Monitors , nil } 
func ( client * Client ) GetMonitors ( ) ( [ ] Monitor , error ) { var out reqMonitors if err := client . doJsonRequest ( " " , " " , nil , & out . Monitors ) ; err != nil { return nil , err } return out . Monitors , nil } 
func ( client * Client ) GetSyntheticsLocations ( ) ( [ ] SyntheticsLocation , error ) { var out struct { Locations [ ] SyntheticsLocation `json:"locations,omitempty"` } if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return out . Locations , nil } 
func ( client * Client ) GetSyntheticsBrowserDevices ( ) ( [ ] SyntheticsDevice , error ) { var out struct { Devices [ ] SyntheticsDevice `json:"devices,omitempty"` } if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return out . Devices , nil } 
func GetBool ( v * bool ) ( bool , bool ) { if v != nil { return * v , true } return false , false } 
func GetIntOk ( v * int ) ( int , bool ) { if v != nil { return * v , true } return 0 , false } 
func GetStringOk ( v * string ) ( string , bool ) { if v != nil { return * v , true } return " " , false } 
func GetJsonNumberOk ( v * json . Number ) ( json . Number , bool ) { if v != nil { return * v , true } return " " , false } 
func GetPrecision ( v * PrecisionT ) ( PrecisionT , bool ) { if v != nil { return * v , true } return PrecisionT ( " " ) , false } 
func GetStringId ( id interface { } ) ( string , error ) { switch v := id . ( type ) { case int : return strconv . Itoa ( v ) , nil case string : return v , nil default : return " " , errors . New ( " " ) } } 
func ( y * Yaxis ) UnmarshalJSON ( data [ ] byte ) error { type Alias Yaxis wrapper := & struct { Min * json . Number `json:"min,omitempty"` Max * json . Number `json:"max,omitempty"` * Alias } { Alias : ( * Alias ) ( y ) , } if err := json . Unmarshal ( data , & wrapper ) ; err != nil { return err } if wrapper . Min != nil { if * wrapper . Min == " " { y . AutoMin = true y . Min = nil } else { f , err := wrapper . Min . Float64 ( ) if err != nil { return err } y . Min = & f } } if wrapper . Max != nil { if * wrapper . Max == " " { y . AutoMax = true y . Max = nil } else { f , err := wrapper . Max . Float64 ( ) if err != nil { return err } y . Max = & f } } return nil } 
func ( client * Client ) GetDashboard ( id interface { } ) ( * Dashboard , error ) { stringId , err := GetStringId ( id ) if err != nil { return nil , err } var out reqGetDashboard if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , stringId ) , nil , & out ) ; err != nil { return nil , err } return out . Dashboard , nil } 
func ( client * Client ) GetDashboards ( ) ( [ ] DashboardLite , error ) { var out reqGetDashboards if err := client . doJsonRequest ( " " , " " , nil , & out ) ; err != nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) CreateDashboard ( dash * Dashboard ) ( * Dashboard , error ) { var out reqGetDashboard if err := client . doJsonRequest ( " " , " " , dash , & out ) ; err != nil { return nil , err } return out . Dashboard , nil } 
func ( client * Client ) UpdateDashboard ( dash * Dashboard ) error { return client . doJsonRequest ( " " , fmt . Sprintf ( " " , * dash . Id ) , dash , nil ) } 
func ( client * Client ) InviteUsers ( emails [ ] string ) error { return client . doJsonRequest ( " " , " " , reqInviteUsers { Emails : emails } , nil ) } 
func ( self * Client ) CreateUser ( handle , name * string ) ( * User , error ) { in := struct { Handle * string `json:"handle"` Name * string `json:"name"` } { Handle : handle , Name : name , } out := struct { * User `json:"user"` } { } if err := self . doJsonRequest ( " " , " " , in , & out ) ; err != nil { return nil , err } return out . User , nil } 
func ( client * Client ) GetUsers ( ) ( users [ ] User , err error ) { var udata usersData uri := " " err = client . doJsonRequest ( " " , uri , nil , & udata ) users = udata . Users return } 
func ( client * Client ) GetUser ( handle string ) ( user User , err error ) { var udata userData uri := " " + handle err = client . doJsonRequest ( " " , uri , nil , & udata ) user = udata . User return } 
func ( client * Client ) UpdateUser ( user User ) error { uri := " " + * user . Handle return client . doJsonRequest ( " " , uri , user , nil ) } 
func ( client * Client ) DeleteUser ( handle string ) error { uri := " " + handle return client . doJsonRequest ( " " , uri , nil , nil ) } 
func ( client * Client ) GetBoard ( id string ) ( * Board , error ) { var board Board if err := client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , & board ) ; err != nil { return nil , err } return & board , nil } 
func ( client * Client ) DeleteBoard ( id string ) error { return client . doJsonRequest ( " " , fmt . Sprintf ( " " , id ) , nil , nil ) } 
func ( client * Client ) CreateBoard ( board * Board ) ( * Board , error ) { var createdBoard Board if err := client . doJsonRequest ( " " , " " , board , & createdBoard ) ; err != nil { return nil , err } return & createdBoard , nil } 
func ( client * Client ) UpdateBoard ( board * Board ) error { return client . doJsonRequest ( " " , fmt . Sprintf ( " " , * board . Id ) , board , nil ) } 
func NewClient ( apiKey , appKey string ) * Client { baseUrl := os . Getenv ( " " ) if baseUrl == " " { baseUrl = " " } return & Client { apiKey : apiKey , appKey : appKey , baseUrl : baseUrl , HttpClient : http . DefaultClient , RetryTimeout : time . Duration ( 60 * time . Second ) , } } 
func ( c * Client ) SetKeys ( apiKey , appKey string ) { c . apiKey = apiKey c . appKey = appKey } 
func ( client * Client ) Validate ( ) ( bool , error ) { var out valid var resp * http . Response uri , err := client . uriForAPI ( " " ) if err != nil { return false , err } req , err := http . NewRequest ( " " , uri , nil ) if err != nil { return false , err } resp , err = client . doRequestWithRetries ( req , client . RetryTimeout ) if err != nil { return false , err } defer resp . Body . Close ( ) body , err := ioutil . ReadAll ( resp . Body ) if err != nil { return false , err } if err = json . Unmarshal ( body , & out ) ; err != nil { return false , err } return out . IsValid , nil } 
func ( widget * BoardWidget ) UnmarshalJSON ( data [ ] byte ) error { var widgetHandler struct { Definition * struct { Type * string `json:"type"` } `json:"definition"` Id * int `json:"id,omitempty"` Layout * WidgetLayout `json:"layout,omitempty"` } if err := json . Unmarshal ( data , & widgetHandler ) ; err != nil { return err } } if err := json . Unmarshal ( data , & alertGraphWidget ) ; err != nil { return err } widget . Definition = alertGraphWidget . Definition case ALERT_VALUE_WIDGET : var alertValueWidget struct { Definition AlertValueDefinition `json:"definition"` } if err := json . Unmarshal ( data , & alertValueWidget ) ; err != nil { return err } widget . Definition = alertValueWidget . Definition case CHANGE_WIDGET : var changeWidget struct { Definition ChangeDefinition `json:"definition"` } if err := json . Unmarshal ( data , & changeWidget ) ; err != nil { return err } widget . Definition = changeWidget . Definition case CHECK_STATUS_WIDGET : var checkStatusWidget struct { Definition CheckStatusDefinition `json:"definition"` } if err := json . Unmarshal ( data , & checkStatusWidget ) ; err != nil { return err } widget . Definition = checkStatusWidget . Definition case DISTRIBUTION_WIDGET : var distributionWidget struct { Definition DistributionDefinition `json:"definition"` } if err := json . Unmarshal ( data , & distributionWidget ) ; err != nil { return err } widget . Definition = distributionWidget . Definition case EVENT_STREAM_WIDGET : var eventStreamWidget struct { Definition EventStreamDefinition `json:"definition"` } if err := json . Unmarshal ( data , & eventStreamWidget ) ; err != nil { return err } widget . Definition = eventStreamWidget . Definition case EVENT_TIMELINE_WIDGET : var eventTimelineWidget struct { Definition EventTimelineDefinition `json:"definition"` } if err := json . Unmarshal ( data , & eventTimelineWidget ) ; err != nil { return err } widget . Definition = eventTimelineWidget . Definition case FREE_TEXT_WIDGET : var freeTextWidget struct { Definition FreeTextDefinition `json:"definition"` } if err := json . Unmarshal ( data , & freeTextWidget ) ; err != nil { return err } widget . Definition = freeTextWidget . Definition case GROUP_WIDGET : var groupWidget struct { Definition GroupDefinition `json:"definition"` } if err := json . Unmarshal ( data , & groupWidget ) ; err != nil { return err } widget . Definition = groupWidget . Definition case HEATMAP_WIDGET : var heatmapWidget struct { Definition HeatmapDefinition `json:"definition"` } if err := json . Unmarshal ( data , & heatmapWidget ) ; err != nil { return err } widget . Definition = heatmapWidget . Definition case HOSTMAP_WIDGET : var hostmapWidget struct { Definition HostmapDefinition `json:"definition"` } if err := json . Unmarshal ( data , & hostmapWidget ) ; err != nil { return err } widget . Definition = hostmapWidget . Definition case IFRAME_WIDGET : var iframeWidget struct { Definition IframeDefinition `json:"definition"` } if err := json . Unmarshal ( data , & iframeWidget ) ; err != nil { return err } widget . Definition = iframeWidget . Definition case IMAGE_WIDGET : var imageWidget struct { Definition ImageDefinition `json:"definition"` } if err := json . Unmarshal ( data , & imageWidget ) ; err != nil { return err } widget . Definition = imageWidget . Definition case LOG_STREAM_WIDGET : var logStreamWidget struct { Definition LogStreamDefinition `json:"definition"` } if err := json . Unmarshal ( data , & logStreamWidget ) ; err != nil { return err } widget . Definition = logStreamWidget . Definition case MANAGE_STATUS_WIDGET : var manageStatusWidget struct { Definition ManageStatusDefinition `json:"definition"` } if err := json . Unmarshal ( data , & manageStatusWidget ) ; err != nil { return err } widget . Definition = manageStatusWidget . Definition case NOTE_WIDGET : var noteWidget struct { Definition NoteDefinition `json:"definition"` } if err := json . Unmarshal ( data , & noteWidget ) ; err != nil { return err } widget . Definition = noteWidget . Definition case QUERY_VALUE_WIDGET : var queryValueWidget struct { Definition QueryValueDefinition `json:"definition"` } if err := json . Unmarshal ( data , & queryValueWidget ) ; err != nil { return err } widget . Definition = queryValueWidget . Definition case SCATTERPLOT_WIDGET : var scatterplotWidget struct { Definition ScatterplotDefinition `json:"definition"` } if err := json . Unmarshal ( data , & scatterplotWidget ) ; err != nil { return err } widget . Definition = scatterplotWidget . Definition case TIMESERIES_WIDGET : var timeseriesWidget struct { Definition TimeseriesDefinition `json:"definition"` } if err := json . Unmarshal ( data , & timeseriesWidget ) ; err != nil { return err } widget . Definition = timeseriesWidget . Definition case TOPLIST_WIDGET : var toplistWidget struct { Definition ToplistDefinition `json:"definition"` } if err := json . Unmarshal ( data , & toplistWidget ) ; err != nil { return err } widget . Definition = toplistWidget . Definition case TRACE_SERVICE_WIDGET : var traceServiceWidget struct { Definition TraceServiceDefinition `json:"definition"` } if err := json . Unmarshal ( data , & traceServiceWidget ) ; err != nil { return err } widget . Definition = traceServiceWidget . Definition default : return fmt . Errorf ( " " , * widgetHandler . Definition . Type ) } return nil } 
func ( client * Client ) MuteHost ( host string , action * HostActionMute ) ( * HostActionResp , error ) { var out HostActionResp uri := " " + host + " " if err := client . doJsonRequest ( " " , uri , action , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( client * Client ) UnmuteHost ( host string ) ( * HostActionResp , error ) { var out HostActionResp uri := " " + host + " " if err := client . doJsonRequest ( " " , uri , nil , & out ) ; err != nil { return nil , err } return & out , nil } 
func ( a * Alert ) GetCreator ( ) int { if a == nil || a . Creator == nil { return 0 } return * a . Creator } 
func ( a * Alert ) GetCreatorOk ( ) ( int , bool ) { if a == nil || a . Creator == nil { return 0 , false } return * a . Creator , true } 
func ( a * Alert ) HasCreator ( ) bool { if a != nil && a . Creator != nil { return true } return false } 
func ( a * Alert ) GetId ( ) int { if a == nil || a . Id == nil { return 0 } return * a . Id } 
func ( a * Alert ) GetIdOk ( ) ( int , bool ) { if a == nil || a . Id == nil { return 0 , false } return * a . Id , true } 
func ( a * Alert ) HasId ( ) bool { if a != nil && a . Id != nil { return true } return false } 
func ( a * Alert ) GetMessage ( ) string { if a == nil || a . Message == nil { return " " } return * a . Message } 
func ( a * Alert ) GetMessageOk ( ) ( string , bool ) { if a == nil || a . Message == nil { return " " , false } return * a . Message , true } 
func ( a * Alert ) HasMessage ( ) bool { if a != nil && a . Message != nil { return true } return false } 
func ( a * Alert ) GetName ( ) string { if a == nil || a . Name == nil { return " " } return * a . Name } 
func ( a * Alert ) GetNameOk ( ) ( string , bool ) { if a == nil || a . Name == nil { return " " , false } return * a . Name , true } 
func ( a * Alert ) HasName ( ) bool { if a != nil && a . Name != nil { return true } return false } 
func ( a * Alert ) GetNotifyNoData ( ) bool { if a == nil || a . NotifyNoData == nil { return false } return * a . NotifyNoData } 
func ( a * Alert ) GetNotifyNoDataOk ( ) ( bool , bool ) { if a == nil || a . NotifyNoData == nil { return false , false } return * a . NotifyNoData , true } 
func ( a * Alert ) HasNotifyNoData ( ) bool { if a != nil && a . NotifyNoData != nil { return true } return false } 
func ( a * Alert ) GetQuery ( ) string { if a == nil || a . Query == nil { return " " } return * a . Query } 
func ( a * Alert ) GetQueryOk ( ) ( string , bool ) { if a == nil || a . Query == nil { return " " , false } return * a . Query , true } 
func ( a * Alert ) HasQuery ( ) bool { if a != nil && a . Query != nil { return true } return false } 
func ( a * Alert ) GetSilenced ( ) bool { if a == nil || a . Silenced == nil { return false } return * a . Silenced } 
func ( a * Alert ) GetSilencedOk ( ) ( bool , bool ) { if a == nil || a . Silenced == nil { return false , false } return * a . Silenced , true } 
func ( a * Alert ) HasSilenced ( ) bool { if a != nil && a . Silenced != nil { return true } return false } 
func ( a * Alert ) GetState ( ) string { if a == nil || a . State == nil { return " " } return * a . State } 
func ( a * Alert ) GetStateOk ( ) ( string , bool ) { if a == nil || a . State == nil { return " " , false } return * a . State , true } 
func ( a * Alert ) HasState ( ) bool { if a != nil && a . State != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetAlertId ( ) string { if a == nil || a . AlertId == nil { return " " } return * a . AlertId } 
func ( a * AlertGraphDefinition ) HasAlertId ( ) bool { if a != nil && a . AlertId != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetTime ( ) WidgetTime { if a == nil || a . Time == nil { return WidgetTime { } } return * a . Time } 
func ( a * AlertGraphDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if a == nil || a . Time == nil { return WidgetTime { } , false } return * a . Time , true } 
func ( a * AlertGraphDefinition ) HasTime ( ) bool { if a != nil && a . Time != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetTitle ( ) string { if a == nil || a . Title == nil { return " " } return * a . Title } 
func ( a * AlertGraphDefinition ) GetTitleOk ( ) ( string , bool ) { if a == nil || a . Title == nil { return " " , false } return * a . Title , true } 
func ( a * AlertGraphDefinition ) HasTitle ( ) bool { if a != nil && a . Title != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetTitleAlign ( ) string { if a == nil || a . TitleAlign == nil { return " " } return * a . TitleAlign } 
func ( a * AlertGraphDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if a == nil || a . TitleAlign == nil { return " " , false } return * a . TitleAlign , true } 
func ( a * AlertGraphDefinition ) HasTitleAlign ( ) bool { if a != nil && a . TitleAlign != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetTitleSize ( ) string { if a == nil || a . TitleSize == nil { return " " } return * a . TitleSize } 
func ( a * AlertGraphDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if a == nil || a . TitleSize == nil { return " " , false } return * a . TitleSize , true } 
func ( a * AlertGraphDefinition ) HasTitleSize ( ) bool { if a != nil && a . TitleSize != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetType ( ) string { if a == nil || a . Type == nil { return " " } return * a . Type } 
func ( a * AlertGraphDefinition ) GetTypeOk ( ) ( string , bool ) { if a == nil || a . Type == nil { return " " , false } return * a . Type , true } 
func ( a * AlertGraphDefinition ) HasType ( ) bool { if a != nil && a . Type != nil { return true } return false } 
func ( a * AlertGraphDefinition ) GetVizType ( ) string { if a == nil || a . VizType == nil { return " " } return * a . VizType } 
func ( a * AlertGraphDefinition ) GetVizTypeOk ( ) ( string , bool ) { if a == nil || a . VizType == nil { return " " , false } return * a . VizType , true } 
func ( a * AlertGraphDefinition ) HasVizType ( ) bool { if a != nil && a . VizType != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetAlertId ( ) string { if a == nil || a . AlertId == nil { return " " } return * a . AlertId } 
func ( a * AlertValueDefinition ) GetAlertIdOk ( ) ( string , bool ) { if a == nil || a . AlertId == nil { return " " , false } return * a . AlertId , true } 
func ( a * AlertValueDefinition ) HasAlertId ( ) bool { if a != nil && a . AlertId != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetPrecision ( ) int { if a == nil || a . Precision == nil { return 0 } return * a . Precision } 
func ( a * AlertValueDefinition ) GetPrecisionOk ( ) ( int , bool ) { if a == nil || a . Precision == nil { return 0 , false } return * a . Precision , true } 
func ( a * AlertValueDefinition ) HasPrecision ( ) bool { if a != nil && a . Precision != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetTextAlign ( ) string { if a == nil || a . TextAlign == nil { return " " } return * a . TextAlign } 
func ( a * AlertValueDefinition ) GetTextAlignOk ( ) ( string , bool ) { if a == nil || a . TextAlign == nil { return " " , false } return * a . TextAlign , true } 
func ( a * AlertValueDefinition ) HasTextAlign ( ) bool { if a != nil && a . TextAlign != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetTitle ( ) string { if a == nil || a . Title == nil { return " " } return * a . Title } 
func ( a * AlertValueDefinition ) HasTitle ( ) bool { if a != nil && a . Title != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetTitleAlign ( ) string { if a == nil || a . TitleAlign == nil { return " " } return * a . TitleAlign } 
func ( a * AlertValueDefinition ) HasTitleAlign ( ) bool { if a != nil && a . TitleAlign != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetTitleSize ( ) string { if a == nil || a . TitleSize == nil { return " " } return * a . TitleSize } 
func ( a * AlertValueDefinition ) HasTitleSize ( ) bool { if a != nil && a . TitleSize != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetType ( ) string { if a == nil || a . Type == nil { return " " } return * a . Type } 
func ( a * AlertValueDefinition ) HasType ( ) bool { if a != nil && a . Type != nil { return true } return false } 
func ( a * AlertValueDefinition ) GetUnit ( ) string { if a == nil || a . Unit == nil { return " " } return * a . Unit } 
func ( a * AlertValueDefinition ) GetUnitOk ( ) ( string , bool ) { if a == nil || a . Unit == nil { return " " , false } return * a . Unit , true } 
func ( a * AlertValueDefinition ) HasUnit ( ) bool { if a != nil && a . Unit != nil { return true } return false } 
func ( a * APIKey ) GetCreated ( ) time . Time { if a == nil || a . Created == nil { return time . Time { } } return * a . Created } 
func ( a * APIKey ) GetCreatedOk ( ) ( time . Time , bool ) { if a == nil || a . Created == nil { return time . Time { } , false } return * a . Created , true } 
func ( a * APIKey ) HasCreated ( ) bool { if a != nil && a . Created != nil { return true } return false } 
func ( a * APIKey ) GetCreatedBy ( ) string { if a == nil || a . CreatedBy == nil { return " " } return * a . CreatedBy } 
func ( a * APIKey ) GetCreatedByOk ( ) ( string , bool ) { if a == nil || a . CreatedBy == nil { return " " , false } return * a . CreatedBy , true } 
func ( a * APIKey ) HasCreatedBy ( ) bool { if a != nil && a . CreatedBy != nil { return true } return false } 
func ( a * APIKey ) GetKey ( ) string { if a == nil || a . Key == nil { return " " } return * a . Key } 
func ( a * APIKey ) GetKeyOk ( ) ( string , bool ) { if a == nil || a . Key == nil { return " " , false } return * a . Key , true } 
func ( a * APIKey ) HasKey ( ) bool { if a != nil && a . Key != nil { return true } return false } 
func ( a * APIKey ) GetName ( ) string { if a == nil || a . Name == nil { return " " } return * a . Name } 
func ( a * APIKey ) HasName ( ) bool { if a != nil && a . Name != nil { return true } return false } 
func ( a * ApmOrLogQueryCompute ) GetAggregation ( ) string { if a == nil || a . Aggregation == nil { return " " } return * a . Aggregation } 
func ( a * ApmOrLogQueryCompute ) GetAggregationOk ( ) ( string , bool ) { if a == nil || a . Aggregation == nil { return " " , false } return * a . Aggregation , true } 
func ( a * ApmOrLogQueryCompute ) HasAggregation ( ) bool { if a != nil && a . Aggregation != nil { return true } return false } 
func ( a * ApmOrLogQueryCompute ) GetFacet ( ) string { if a == nil || a . Facet == nil { return " " } return * a . Facet } 
func ( a * ApmOrLogQueryCompute ) HasFacet ( ) bool { if a != nil && a . Facet != nil { return true } return false } 
func ( a * ApmOrLogQueryCompute ) GetInterval ( ) int { if a == nil || a . Interval == nil { return 0 } return * a . Interval } 
func ( a * ApmOrLogQueryCompute ) GetIntervalOk ( ) ( int , bool ) { if a == nil || a . Interval == nil { return 0 , false } return * a . Interval , true } 
func ( a * ApmOrLogQueryCompute ) HasInterval ( ) bool { if a != nil && a . Interval != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBy ) GetFacet ( ) string { if a == nil || a . Facet == nil { return " " } return * a . Facet } 
func ( a * ApmOrLogQueryGroupBy ) GetFacetOk ( ) ( string , bool ) { if a == nil || a . Facet == nil { return " " , false } return * a . Facet , true } 
func ( a * ApmOrLogQueryGroupBy ) HasFacet ( ) bool { if a != nil && a . Facet != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBy ) GetLimit ( ) int { if a == nil || a . Limit == nil { return 0 } return * a . Limit } 
func ( a * ApmOrLogQueryGroupBy ) GetLimitOk ( ) ( int , bool ) { if a == nil || a . Limit == nil { return 0 , false } return * a . Limit , true } 
func ( a * ApmOrLogQueryGroupBy ) HasLimit ( ) bool { if a != nil && a . Limit != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBy ) GetSort ( ) ApmOrLogQueryGroupBySort { if a == nil || a . Sort == nil { return ApmOrLogQueryGroupBySort { } } return * a . Sort } 
func ( a * ApmOrLogQueryGroupBy ) GetSortOk ( ) ( ApmOrLogQueryGroupBySort , bool ) { if a == nil || a . Sort == nil { return ApmOrLogQueryGroupBySort { } , false } return * a . Sort , true } 
func ( a * ApmOrLogQueryGroupBy ) HasSort ( ) bool { if a != nil && a . Sort != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBySort ) GetAggregation ( ) string { if a == nil || a . Aggregation == nil { return " " } return * a . Aggregation } 
func ( a * ApmOrLogQueryGroupBySort ) HasAggregation ( ) bool { if a != nil && a . Aggregation != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBySort ) GetFacet ( ) string { if a == nil || a . Facet == nil { return " " } return * a . Facet } 
func ( a * ApmOrLogQueryGroupBySort ) HasFacet ( ) bool { if a != nil && a . Facet != nil { return true } return false } 
func ( a * ApmOrLogQueryGroupBySort ) GetOrder ( ) string { if a == nil || a . Order == nil { return " " } return * a . Order } 
func ( a * ApmOrLogQueryGroupBySort ) GetOrderOk ( ) ( string , bool ) { if a == nil || a . Order == nil { return " " , false } return * a . Order , true } 
func ( a * ApmOrLogQueryGroupBySort ) HasOrder ( ) bool { if a != nil && a . Order != nil { return true } return false } 
func ( a * ApmOrLogQuerySearch ) GetQuery ( ) string { if a == nil || a . Query == nil { return " " } return * a . Query } 
func ( a * ApmOrLogQuerySearch ) HasQuery ( ) bool { if a != nil && a . Query != nil { return true } return false } 
func ( b * Board ) GetAuthorHandle ( ) string { if b == nil || b . AuthorHandle == nil { return " " } return * b . AuthorHandle } 
func ( b * Board ) GetAuthorHandleOk ( ) ( string , bool ) { if b == nil || b . AuthorHandle == nil { return " " , false } return * b . AuthorHandle , true } 
func ( b * Board ) HasAuthorHandle ( ) bool { if b != nil && b . AuthorHandle != nil { return true } return false } 
func ( b * Board ) GetCreatedAt ( ) string { if b == nil || b . CreatedAt == nil { return " " } return * b . CreatedAt } 
func ( b * Board ) GetCreatedAtOk ( ) ( string , bool ) { if b == nil || b . CreatedAt == nil { return " " , false } return * b . CreatedAt , true } 
func ( b * Board ) HasCreatedAt ( ) bool { if b != nil && b . CreatedAt != nil { return true } return false } 
func ( b * Board ) GetDescription ( ) string { if b == nil || b . Description == nil { return " " } return * b . Description } 
func ( b * Board ) GetDescriptionOk ( ) ( string , bool ) { if b == nil || b . Description == nil { return " " , false } return * b . Description , true } 
func ( b * Board ) HasDescription ( ) bool { if b != nil && b . Description != nil { return true } return false } 
func ( b * Board ) GetId ( ) string { if b == nil || b . Id == nil { return " " } return * b . Id } 
func ( b * Board ) GetIdOk ( ) ( string , bool ) { if b == nil || b . Id == nil { return " " , false } return * b . Id , true } 
func ( b * Board ) HasId ( ) bool { if b != nil && b . Id != nil { return true } return false } 
func ( b * Board ) GetIsReadOnly ( ) bool { if b == nil || b . IsReadOnly == nil { return false } return * b . IsReadOnly } 
func ( b * Board ) GetIsReadOnlyOk ( ) ( bool , bool ) { if b == nil || b . IsReadOnly == nil { return false , false } return * b . IsReadOnly , true } 
func ( b * Board ) HasIsReadOnly ( ) bool { if b != nil && b . IsReadOnly != nil { return true } return false } 
func ( b * Board ) GetLayoutType ( ) string { if b == nil || b . LayoutType == nil { return " " } return * b . LayoutType } 
func ( b * Board ) GetLayoutTypeOk ( ) ( string , bool ) { if b == nil || b . LayoutType == nil { return " " , false } return * b . LayoutType , true } 
func ( b * Board ) HasLayoutType ( ) bool { if b != nil && b . LayoutType != nil { return true } return false } 
func ( b * Board ) GetModifiedAt ( ) string { if b == nil || b . ModifiedAt == nil { return " " } return * b . ModifiedAt } 
func ( b * Board ) GetModifiedAtOk ( ) ( string , bool ) { if b == nil || b . ModifiedAt == nil { return " " , false } return * b . ModifiedAt , true } 
func ( b * Board ) HasModifiedAt ( ) bool { if b != nil && b . ModifiedAt != nil { return true } return false } 
func ( b * Board ) GetTitle ( ) string { if b == nil || b . Title == nil { return " " } return * b . Title } 
func ( b * Board ) GetTitleOk ( ) ( string , bool ) { if b == nil || b . Title == nil { return " " , false } return * b . Title , true } 
func ( b * Board ) HasTitle ( ) bool { if b != nil && b . Title != nil { return true } return false } 
func ( b * Board ) GetUrl ( ) string { if b == nil || b . Url == nil { return " " } return * b . Url } 
func ( b * Board ) GetUrlOk ( ) ( string , bool ) { if b == nil || b . Url == nil { return " " , false } return * b . Url , true } 
func ( b * Board ) HasUrl ( ) bool { if b != nil && b . Url != nil { return true } return false } 
func ( b * BoardWidget ) GetId ( ) int { if b == nil || b . Id == nil { return 0 } return * b . Id } 
func ( b * BoardWidget ) GetIdOk ( ) ( int , bool ) { if b == nil || b . Id == nil { return 0 , false } return * b . Id , true } 
func ( b * BoardWidget ) HasId ( ) bool { if b != nil && b . Id != nil { return true } return false } 
func ( b * BoardWidget ) GetLayout ( ) WidgetLayout { if b == nil || b . Layout == nil { return WidgetLayout { } } return * b . Layout } 
func ( b * BoardWidget ) GetLayoutOk ( ) ( WidgetLayout , bool ) { if b == nil || b . Layout == nil { return WidgetLayout { } , false } return * b . Layout , true } 
func ( b * BoardWidget ) HasLayout ( ) bool { if b != nil && b . Layout != nil { return true } return false } 
func ( c * ChangeDefinition ) GetTime ( ) WidgetTime { if c == nil || c . Time == nil { return WidgetTime { } } return * c . Time } 
func ( c * ChangeDefinition ) HasTime ( ) bool { if c != nil && c . Time != nil { return true } return false } 
func ( c * ChangeDefinition ) GetTitle ( ) string { if c == nil || c . Title == nil { return " " } return * c . Title } 
func ( c * ChangeDefinition ) HasTitle ( ) bool { if c != nil && c . Title != nil { return true } return false } 
func ( c * ChangeDefinition ) GetTitleAlign ( ) string { if c == nil || c . TitleAlign == nil { return " " } return * c . TitleAlign } 
func ( c * ChangeDefinition ) HasTitleAlign ( ) bool { if c != nil && c . TitleAlign != nil { return true } return false } 
func ( c * ChangeDefinition ) GetTitleSize ( ) string { if c == nil || c . TitleSize == nil { return " " } return * c . TitleSize } 
func ( c * ChangeDefinition ) HasTitleSize ( ) bool { if c != nil && c . TitleSize != nil { return true } return false } 
func ( c * ChangeDefinition ) GetType ( ) string { if c == nil || c . Type == nil { return " " } return * c . Type } 
func ( c * ChangeDefinition ) HasType ( ) bool { if c != nil && c . Type != nil { return true } return false } 
func ( c * ChangeRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if c == nil || c . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * c . ApmQuery } 
func ( c * ChangeRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if c == nil || c . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * c . ApmQuery , true } 
func ( c * ChangeRequest ) HasApmQuery ( ) bool { if c != nil && c . ApmQuery != nil { return true } return false } 
func ( c * ChangeRequest ) GetChangeType ( ) string { if c == nil || c . ChangeType == nil { return " " } return * c . ChangeType } 
func ( c * ChangeRequest ) GetChangeTypeOk ( ) ( string , bool ) { if c == nil || c . ChangeType == nil { return " " , false } return * c . ChangeType , true } 
func ( c * ChangeRequest ) HasChangeType ( ) bool { if c != nil && c . ChangeType != nil { return true } return false } 
func ( c * ChangeRequest ) GetCompareTo ( ) string { if c == nil || c . CompareTo == nil { return " " } return * c . CompareTo } 
func ( c * ChangeRequest ) GetCompareToOk ( ) ( string , bool ) { if c == nil || c . CompareTo == nil { return " " , false } return * c . CompareTo , true } 
func ( c * ChangeRequest ) HasCompareTo ( ) bool { if c != nil && c . CompareTo != nil { return true } return false } 
func ( c * ChangeRequest ) GetIncreaseGood ( ) bool { if c == nil || c . IncreaseGood == nil { return false } return * c . IncreaseGood } 
func ( c * ChangeRequest ) GetIncreaseGoodOk ( ) ( bool , bool ) { if c == nil || c . IncreaseGood == nil { return false , false } return * c . IncreaseGood , true } 
func ( c * ChangeRequest ) HasIncreaseGood ( ) bool { if c != nil && c . IncreaseGood != nil { return true } return false } 
func ( c * ChangeRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if c == nil || c . LogQuery == nil { return WidgetApmOrLogQuery { } } return * c . LogQuery } 
func ( c * ChangeRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if c == nil || c . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * c . LogQuery , true } 
func ( c * ChangeRequest ) HasLogQuery ( ) bool { if c != nil && c . LogQuery != nil { return true } return false } 
func ( c * ChangeRequest ) GetMetricQuery ( ) string { if c == nil || c . MetricQuery == nil { return " " } return * c . MetricQuery } 
func ( c * ChangeRequest ) GetMetricQueryOk ( ) ( string , bool ) { if c == nil || c . MetricQuery == nil { return " " , false } return * c . MetricQuery , true } 
func ( c * ChangeRequest ) HasMetricQuery ( ) bool { if c != nil && c . MetricQuery != nil { return true } return false } 
func ( c * ChangeRequest ) GetOrderBy ( ) string { if c == nil || c . OrderBy == nil { return " " } return * c . OrderBy } 
func ( c * ChangeRequest ) GetOrderByOk ( ) ( string , bool ) { if c == nil || c . OrderBy == nil { return " " , false } return * c . OrderBy , true } 
func ( c * ChangeRequest ) HasOrderBy ( ) bool { if c != nil && c . OrderBy != nil { return true } return false } 
func ( c * ChangeRequest ) GetOrderDir ( ) string { if c == nil || c . OrderDir == nil { return " " } return * c . OrderDir } 
func ( c * ChangeRequest ) GetOrderDirOk ( ) ( string , bool ) { if c == nil || c . OrderDir == nil { return " " , false } return * c . OrderDir , true } 
func ( c * ChangeRequest ) HasOrderDir ( ) bool { if c != nil && c . OrderDir != nil { return true } return false } 
func ( c * ChangeRequest ) GetProcessQuery ( ) WidgetProcessQuery { if c == nil || c . ProcessQuery == nil { return WidgetProcessQuery { } } return * c . ProcessQuery } 
func ( c * ChangeRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if c == nil || c . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * c . ProcessQuery , true } 
func ( c * ChangeRequest ) HasProcessQuery ( ) bool { if c != nil && c . ProcessQuery != nil { return true } return false } 
func ( c * ChangeRequest ) GetShowPresent ( ) bool { if c == nil || c . ShowPresent == nil { return false } return * c . ShowPresent } 
func ( c * ChangeRequest ) GetShowPresentOk ( ) ( bool , bool ) { if c == nil || c . ShowPresent == nil { return false , false } return * c . ShowPresent , true } 
func ( c * ChangeRequest ) HasShowPresent ( ) bool { if c != nil && c . ShowPresent != nil { return true } return false } 
func ( c * ChannelSlackRequest ) GetAccount ( ) string { if c == nil || c . Account == nil { return " " } return * c . Account } 
func ( c * ChannelSlackRequest ) GetAccountOk ( ) ( string , bool ) { if c == nil || c . Account == nil { return " " , false } return * c . Account , true } 
func ( c * ChannelSlackRequest ) HasAccount ( ) bool { if c != nil && c . Account != nil { return true } return false } 
func ( c * ChannelSlackRequest ) GetChannelName ( ) string { if c == nil || c . ChannelName == nil { return " " } return * c . ChannelName } 
func ( c * ChannelSlackRequest ) GetChannelNameOk ( ) ( string , bool ) { if c == nil || c . ChannelName == nil { return " " , false } return * c . ChannelName , true } 
func ( c * ChannelSlackRequest ) HasChannelName ( ) bool { if c != nil && c . ChannelName != nil { return true } return false } 
func ( c * ChannelSlackRequest ) GetTransferAllUserComments ( ) bool { if c == nil || c . TransferAllUserComments == nil { return false } return * c . TransferAllUserComments } 
func ( c * ChannelSlackRequest ) GetTransferAllUserCommentsOk ( ) ( bool , bool ) { if c == nil || c . TransferAllUserComments == nil { return false , false } return * c . TransferAllUserComments , true } 
func ( c * ChannelSlackRequest ) HasTransferAllUserComments ( ) bool { if c != nil && c . TransferAllUserComments != nil { return true } return false } 
func ( c * Check ) GetCheck ( ) string { if c == nil || c . Check == nil { return " " } return * c . Check } 
func ( c * Check ) GetHostName ( ) string { if c == nil || c . HostName == nil { return " " } return * c . HostName } 
func ( c * Check ) GetHostNameOk ( ) ( string , bool ) { if c == nil || c . HostName == nil { return " " , false } return * c . HostName , true } 
func ( c * Check ) HasHostName ( ) bool { if c != nil && c . HostName != nil { return true } return false } 
func ( c * Check ) GetMessage ( ) string { if c == nil || c . Message == nil { return " " } return * c . Message } 
func ( c * Check ) HasMessage ( ) bool { if c != nil && c . Message != nil { return true } return false } 
func ( c * Check ) GetStatus ( ) Status { if c == nil || c . Status == nil { return 0 } return * c . Status } 
func ( c * Check ) GetStatusOk ( ) ( Status , bool ) { if c == nil || c . Status == nil { return 0 , false } return * c . Status , true } 
func ( c * Check ) HasStatus ( ) bool { if c != nil && c . Status != nil { return true } return false } 
func ( c * Check ) GetTimestamp ( ) string { if c == nil || c . Timestamp == nil { return " " } return * c . Timestamp } 
func ( c * Check ) GetTimestampOk ( ) ( string , bool ) { if c == nil || c . Timestamp == nil { return " " , false } return * c . Timestamp , true } 
func ( c * Check ) HasTimestamp ( ) bool { if c != nil && c . Timestamp != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetCheckOk ( ) ( string , bool ) { if c == nil || c . Check == nil { return " " , false } return * c . Check , true } 
func ( c * CheckStatusDefinition ) HasCheck ( ) bool { if c != nil && c . Check != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetGroup ( ) string { if c == nil || c . Group == nil { return " " } return * c . Group } 
func ( c * CheckStatusDefinition ) GetGroupOk ( ) ( string , bool ) { if c == nil || c . Group == nil { return " " , false } return * c . Group , true } 
func ( c * CheckStatusDefinition ) HasGroup ( ) bool { if c != nil && c . Group != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetGrouping ( ) string { if c == nil || c . Grouping == nil { return " " } return * c . Grouping } 
func ( c * CheckStatusDefinition ) GetGroupingOk ( ) ( string , bool ) { if c == nil || c . Grouping == nil { return " " , false } return * c . Grouping , true } 
func ( c * CheckStatusDefinition ) HasGrouping ( ) bool { if c != nil && c . Grouping != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetTime ( ) WidgetTime { if c == nil || c . Time == nil { return WidgetTime { } } return * c . Time } 
func ( c * CheckStatusDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if c == nil || c . Time == nil { return WidgetTime { } , false } return * c . Time , true } 
func ( c * CheckStatusDefinition ) HasTime ( ) bool { if c != nil && c . Time != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetTitle ( ) string { if c == nil || c . Title == nil { return " " } return * c . Title } 
func ( c * CheckStatusDefinition ) GetTitleOk ( ) ( string , bool ) { if c == nil || c . Title == nil { return " " , false } return * c . Title , true } 
func ( c * CheckStatusDefinition ) HasTitle ( ) bool { if c != nil && c . Title != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetTitleAlign ( ) string { if c == nil || c . TitleAlign == nil { return " " } return * c . TitleAlign } 
func ( c * CheckStatusDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if c == nil || c . TitleAlign == nil { return " " , false } return * c . TitleAlign , true } 
func ( c * CheckStatusDefinition ) HasTitleAlign ( ) bool { if c != nil && c . TitleAlign != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetTitleSize ( ) string { if c == nil || c . TitleSize == nil { return " " } return * c . TitleSize } 
func ( c * CheckStatusDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if c == nil || c . TitleSize == nil { return " " , false } return * c . TitleSize , true } 
func ( c * CheckStatusDefinition ) HasTitleSize ( ) bool { if c != nil && c . TitleSize != nil { return true } return false } 
func ( c * CheckStatusDefinition ) GetType ( ) string { if c == nil || c . Type == nil { return " " } return * c . Type } 
func ( c * CheckStatusDefinition ) GetTypeOk ( ) ( string , bool ) { if c == nil || c . Type == nil { return " " , false } return * c . Type , true } 
func ( c * CheckStatusDefinition ) HasType ( ) bool { if c != nil && c . Type != nil { return true } return false } 
func ( c * Comment ) GetHandle ( ) string { if c == nil || c . Handle == nil { return " " } return * c . Handle } 
func ( c * Comment ) GetHandleOk ( ) ( string , bool ) { if c == nil || c . Handle == nil { return " " , false } return * c . Handle , true } 
func ( c * Comment ) HasHandle ( ) bool { if c != nil && c . Handle != nil { return true } return false } 
func ( c * Comment ) GetId ( ) int { if c == nil || c . Id == nil { return 0 } return * c . Id } 
func ( c * Comment ) GetIdOk ( ) ( int , bool ) { if c == nil || c . Id == nil { return 0 , false } return * c . Id , true } 
func ( c * Comment ) HasId ( ) bool { if c != nil && c . Id != nil { return true } return false } 
func ( c * Comment ) GetMessage ( ) string { if c == nil || c . Message == nil { return " " } return * c . Message } 
func ( c * Comment ) GetMessageOk ( ) ( string , bool ) { if c == nil || c . Message == nil { return " " , false } return * c . Message , true } 
func ( c * Comment ) HasMessage ( ) bool { if c != nil && c . Message != nil { return true } return false } 
func ( c * Comment ) GetRelatedId ( ) int { if c == nil || c . RelatedId == nil { return 0 } return * c . RelatedId } 
func ( c * Comment ) GetRelatedIdOk ( ) ( int , bool ) { if c == nil || c . RelatedId == nil { return 0 , false } return * c . RelatedId , true } 
func ( c * Comment ) HasRelatedId ( ) bool { if c != nil && c . RelatedId != nil { return true } return false } 
func ( c * Comment ) GetResource ( ) string { if c == nil || c . Resource == nil { return " " } return * c . Resource } 
func ( c * Comment ) GetResourceOk ( ) ( string , bool ) { if c == nil || c . Resource == nil { return " " , false } return * c . Resource , true } 
func ( c * Comment ) HasResource ( ) bool { if c != nil && c . Resource != nil { return true } return false } 
func ( c * Comment ) GetUrl ( ) string { if c == nil || c . Url == nil { return " " } return * c . Url } 
func ( c * Comment ) GetUrlOk ( ) ( string , bool ) { if c == nil || c . Url == nil { return " " , false } return * c . Url , true } 
func ( c * Comment ) HasUrl ( ) bool { if c != nil && c . Url != nil { return true } return false } 
func ( c * ConditionalFormat ) GetColor ( ) string { if c == nil || c . Color == nil { return " " } return * c . Color } 
func ( c * ConditionalFormat ) GetColorOk ( ) ( string , bool ) { if c == nil || c . Color == nil { return " " , false } return * c . Color , true } 
func ( c * ConditionalFormat ) HasColor ( ) bool { if c != nil && c . Color != nil { return true } return false } 
func ( c * ConditionalFormat ) GetComparator ( ) string { if c == nil || c . Comparator == nil { return " " } return * c . Comparator } 
func ( c * ConditionalFormat ) GetComparatorOk ( ) ( string , bool ) { if c == nil || c . Comparator == nil { return " " , false } return * c . Comparator , true } 
func ( c * ConditionalFormat ) HasComparator ( ) bool { if c != nil && c . Comparator != nil { return true } return false } 
func ( c * ConditionalFormat ) GetImageURL ( ) string { if c == nil || c . ImageURL == nil { return " " } return * c . ImageURL } 
func ( c * ConditionalFormat ) GetImageURLOk ( ) ( string , bool ) { if c == nil || c . ImageURL == nil { return " " , false } return * c . ImageURL , true } 
func ( c * ConditionalFormat ) HasImageURL ( ) bool { if c != nil && c . ImageURL != nil { return true } return false } 
func ( c * ConditionalFormat ) GetInvert ( ) bool { if c == nil || c . Invert == nil { return false } return * c . Invert } 
func ( c * ConditionalFormat ) GetInvertOk ( ) ( bool , bool ) { if c == nil || c . Invert == nil { return false , false } return * c . Invert , true } 
func ( c * ConditionalFormat ) HasInvert ( ) bool { if c != nil && c . Invert != nil { return true } return false } 
func ( c * ConditionalFormat ) GetPalette ( ) string { if c == nil || c . Palette == nil { return " " } return * c . Palette } 
func ( c * ConditionalFormat ) GetPaletteOk ( ) ( string , bool ) { if c == nil || c . Palette == nil { return " " , false } return * c . Palette , true } 
func ( c * ConditionalFormat ) HasPalette ( ) bool { if c != nil && c . Palette != nil { return true } return false } 
func ( c * ConditionalFormat ) GetValue ( ) string { if c == nil || c . Value == nil { return " " } return * c . Value } 
func ( c * ConditionalFormat ) GetValueOk ( ) ( string , bool ) { if c == nil || c . Value == nil { return " " , false } return * c . Value , true } 
func ( c * ConditionalFormat ) HasValue ( ) bool { if c != nil && c . Value != nil { return true } return false } 
func ( c * CreatedBy ) GetAccessRole ( ) string { if c == nil || c . AccessRole == nil { return " " } return * c . AccessRole } 
func ( c * CreatedBy ) GetAccessRoleOk ( ) ( string , bool ) { if c == nil || c . AccessRole == nil { return " " , false } return * c . AccessRole , true } 
func ( c * CreatedBy ) HasAccessRole ( ) bool { if c != nil && c . AccessRole != nil { return true } return false } 
func ( c * CreatedBy ) GetDisabled ( ) bool { if c == nil || c . Disabled == nil { return false } return * c . Disabled } 
func ( c * CreatedBy ) GetDisabledOk ( ) ( bool , bool ) { if c == nil || c . Disabled == nil { return false , false } return * c . Disabled , true } 
func ( c * CreatedBy ) HasDisabled ( ) bool { if c != nil && c . Disabled != nil { return true } return false } 
func ( c * CreatedBy ) GetEmail ( ) string { if c == nil || c . Email == nil { return " " } return * c . Email } 
func ( c * CreatedBy ) GetEmailOk ( ) ( string , bool ) { if c == nil || c . Email == nil { return " " , false } return * c . Email , true } 
func ( c * CreatedBy ) HasEmail ( ) bool { if c != nil && c . Email != nil { return true } return false } 
func ( c * CreatedBy ) GetHandle ( ) string { if c == nil || c . Handle == nil { return " " } return * c . Handle } 
func ( c * CreatedBy ) HasHandle ( ) bool { if c != nil && c . Handle != nil { return true } return false } 
func ( c * CreatedBy ) GetIcon ( ) string { if c == nil || c . Icon == nil { return " " } return * c . Icon } 
func ( c * CreatedBy ) GetIconOk ( ) ( string , bool ) { if c == nil || c . Icon == nil { return " " , false } return * c . Icon , true } 
func ( c * CreatedBy ) HasIcon ( ) bool { if c != nil && c . Icon != nil { return true } return false } 
func ( c * CreatedBy ) GetIsAdmin ( ) bool { if c == nil || c . IsAdmin == nil { return false } return * c . IsAdmin } 
func ( c * CreatedBy ) GetIsAdminOk ( ) ( bool , bool ) { if c == nil || c . IsAdmin == nil { return false , false } return * c . IsAdmin , true } 
func ( c * CreatedBy ) HasIsAdmin ( ) bool { if c != nil && c . IsAdmin != nil { return true } return false } 
func ( c * CreatedBy ) GetName ( ) string { if c == nil || c . Name == nil { return " " } return * c . Name } 
func ( c * CreatedBy ) HasName ( ) bool { if c != nil && c . Name != nil { return true } return false } 
func ( c * CreatedBy ) GetRole ( ) string { if c == nil || c . Role == nil { return " " } return * c . Role } 
func ( c * CreatedBy ) GetRoleOk ( ) ( string , bool ) { if c == nil || c . Role == nil { return " " , false } return * c . Role , true } 
func ( c * CreatedBy ) HasRole ( ) bool { if c != nil && c . Role != nil { return true } return false } 
func ( c * CreatedBy ) GetVerified ( ) bool { if c == nil || c . Verified == nil { return false } return * c . Verified } 
func ( c * CreatedBy ) GetVerifiedOk ( ) ( bool , bool ) { if c == nil || c . Verified == nil { return false , false } return * c . Verified , true } 
func ( c * CreatedBy ) HasVerified ( ) bool { if c != nil && c . Verified != nil { return true } return false } 
func ( c * Creator ) GetEmail ( ) string { if c == nil || c . Email == nil { return " " } return * c . Email } 
func ( c * Creator ) HasEmail ( ) bool { if c != nil && c . Email != nil { return true } return false } 
func ( c * Creator ) GetHandle ( ) string { if c == nil || c . Handle == nil { return " " } return * c . Handle } 
func ( c * Creator ) HasHandle ( ) bool { if c != nil && c . Handle != nil { return true } return false } 
func ( c * Creator ) GetId ( ) int { if c == nil || c . Id == nil { return 0 } return * c . Id } 
func ( c * Creator ) HasId ( ) bool { if c != nil && c . Id != nil { return true } return false } 
func ( c * Creator ) GetName ( ) string { if c == nil || c . Name == nil { return " " } return * c . Name } 
func ( c * Creator ) GetNameOk ( ) ( string , bool ) { if c == nil || c . Name == nil { return " " , false } return * c . Name , true } 
func ( c * Creator ) HasName ( ) bool { if c != nil && c . Name != nil { return true } return false } 
func ( d * Dashboard ) GetDescription ( ) string { if d == nil || d . Description == nil { return " " } return * d . Description } 
func ( d * Dashboard ) HasDescription ( ) bool { if d != nil && d . Description != nil { return true } return false } 
func ( d * Dashboard ) GetId ( ) int { if d == nil || d . Id == nil { return 0 } return * d . Id } 
func ( d * Dashboard ) HasId ( ) bool { if d != nil && d . Id != nil { return true } return false } 
func ( d * Dashboard ) GetNewId ( ) string { if d == nil || d . NewId == nil { return " " } return * d . NewId } 
func ( d * Dashboard ) GetNewIdOk ( ) ( string , bool ) { if d == nil || d . NewId == nil { return " " , false } return * d . NewId , true } 
func ( d * Dashboard ) HasNewId ( ) bool { if d != nil && d . NewId != nil { return true } return false } 
func ( d * Dashboard ) GetReadOnly ( ) bool { if d == nil || d . ReadOnly == nil { return false } return * d . ReadOnly } 
func ( d * Dashboard ) GetReadOnlyOk ( ) ( bool , bool ) { if d == nil || d . ReadOnly == nil { return false , false } return * d . ReadOnly , true } 
func ( d * Dashboard ) HasReadOnly ( ) bool { if d != nil && d . ReadOnly != nil { return true } return false } 
func ( d * Dashboard ) GetTitle ( ) string { if d == nil || d . Title == nil { return " " } return * d . Title } 
func ( d * Dashboard ) HasTitle ( ) bool { if d != nil && d . Title != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetComparator ( ) string { if d == nil || d . Comparator == nil { return " " } return * d . Comparator } 
func ( d * DashboardConditionalFormat ) GetComparatorOk ( ) ( string , bool ) { if d == nil || d . Comparator == nil { return " " , false } return * d . Comparator , true } 
func ( d * DashboardConditionalFormat ) HasComparator ( ) bool { if d != nil && d . Comparator != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetCustomBgColor ( ) string { if d == nil || d . CustomBgColor == nil { return " " } return * d . CustomBgColor } 
func ( d * DashboardConditionalFormat ) GetCustomBgColorOk ( ) ( string , bool ) { if d == nil || d . CustomBgColor == nil { return " " , false } return * d . CustomBgColor , true } 
func ( d * DashboardConditionalFormat ) HasCustomBgColor ( ) bool { if d != nil && d . CustomBgColor != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetCustomFgColor ( ) string { if d == nil || d . CustomFgColor == nil { return " " } return * d . CustomFgColor } 
func ( d * DashboardConditionalFormat ) GetCustomFgColorOk ( ) ( string , bool ) { if d == nil || d . CustomFgColor == nil { return " " , false } return * d . CustomFgColor , true } 
func ( d * DashboardConditionalFormat ) HasCustomFgColor ( ) bool { if d != nil && d . CustomFgColor != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetCustomImageUrl ( ) string { if d == nil || d . CustomImageUrl == nil { return " " } return * d . CustomImageUrl } 
func ( d * DashboardConditionalFormat ) GetCustomImageUrlOk ( ) ( string , bool ) { if d == nil || d . CustomImageUrl == nil { return " " , false } return * d . CustomImageUrl , true } 
func ( d * DashboardConditionalFormat ) HasCustomImageUrl ( ) bool { if d != nil && d . CustomImageUrl != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetInverted ( ) bool { if d == nil || d . Inverted == nil { return false } return * d . Inverted } 
func ( d * DashboardConditionalFormat ) GetInvertedOk ( ) ( bool , bool ) { if d == nil || d . Inverted == nil { return false , false } return * d . Inverted , true } 
func ( d * DashboardConditionalFormat ) HasInverted ( ) bool { if d != nil && d . Inverted != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetPalette ( ) string { if d == nil || d . Palette == nil { return " " } return * d . Palette } 
func ( d * DashboardConditionalFormat ) GetPaletteOk ( ) ( string , bool ) { if d == nil || d . Palette == nil { return " " , false } return * d . Palette , true } 
func ( d * DashboardConditionalFormat ) HasPalette ( ) bool { if d != nil && d . Palette != nil { return true } return false } 
func ( d * DashboardConditionalFormat ) GetValue ( ) json . Number { if d == nil || d . Value == nil { return " " } return * d . Value } 
func ( d * DashboardConditionalFormat ) GetValueOk ( ) ( json . Number , bool ) { if d == nil || d . Value == nil { return " " , false } return * d . Value , true } 
func ( d * DashboardConditionalFormat ) HasValue ( ) bool { if d != nil && d . Value != nil { return true } return false } 
func ( d * DashboardList ) GetDashboardCount ( ) int { if d == nil || d . DashboardCount == nil { return 0 } return * d . DashboardCount } 
func ( d * DashboardList ) GetDashboardCountOk ( ) ( int , bool ) { if d == nil || d . DashboardCount == nil { return 0 , false } return * d . DashboardCount , true } 
func ( d * DashboardList ) HasDashboardCount ( ) bool { if d != nil && d . DashboardCount != nil { return true } return false } 
func ( d * DashboardList ) GetId ( ) int { if d == nil || d . Id == nil { return 0 } return * d . Id } 
func ( d * DashboardList ) GetIdOk ( ) ( int , bool ) { if d == nil || d . Id == nil { return 0 , false } return * d . Id , true } 
func ( d * DashboardList ) HasId ( ) bool { if d != nil && d . Id != nil { return true } return false } 
func ( d * DashboardList ) GetName ( ) string { if d == nil || d . Name == nil { return " " } return * d . Name } 
func ( d * DashboardList ) GetNameOk ( ) ( string , bool ) { if d == nil || d . Name == nil { return " " , false } return * d . Name , true } 
func ( d * DashboardList ) HasName ( ) bool { if d != nil && d . Name != nil { return true } return false } 
func ( d * DashboardListItem ) GetId ( ) int { if d == nil || d . Id == nil { return 0 } return * d . Id } 
func ( d * DashboardListItem ) HasId ( ) bool { if d != nil && d . Id != nil { return true } return false } 
func ( d * DashboardListItem ) GetType ( ) string { if d == nil || d . Type == nil { return " " } return * d . Type } 
func ( d * DashboardListItem ) HasType ( ) bool { if d != nil && d . Type != nil { return true } return false } 
func ( d * DashboardLite ) GetCreated ( ) string { if d == nil || d . Created == nil { return " " } return * d . Created } 
func ( d * DashboardLite ) GetCreatedOk ( ) ( string , bool ) { if d == nil || d . Created == nil { return " " , false } return * d . Created , true } 
func ( d * DashboardLite ) HasCreated ( ) bool { if d != nil && d . Created != nil { return true } return false } 
func ( d * DashboardLite ) GetCreatedBy ( ) CreatedBy { if d == nil || d . CreatedBy == nil { return CreatedBy { } } return * d . CreatedBy } 
func ( d * DashboardLite ) GetCreatedByOk ( ) ( CreatedBy , bool ) { if d == nil || d . CreatedBy == nil { return CreatedBy { } , false } return * d . CreatedBy , true } 
func ( d * DashboardLite ) HasCreatedBy ( ) bool { if d != nil && d . CreatedBy != nil { return true } return false } 
func ( d * DashboardLite ) GetDescription ( ) string { if d == nil || d . Description == nil { return " " } return * d . Description } 
func ( d * DashboardLite ) GetDescriptionOk ( ) ( string , bool ) { if d == nil || d . Description == nil { return " " , false } return * d . Description , true } 
func ( d * DashboardLite ) HasDescription ( ) bool { if d != nil && d . Description != nil { return true } return false } 
func ( d * DashboardLite ) GetId ( ) int { if d == nil || d . Id == nil { return 0 } return * d . Id } 
func ( d * DashboardLite ) HasId ( ) bool { if d != nil && d . Id != nil { return true } return false } 
func ( d * DashboardLite ) GetModified ( ) string { if d == nil || d . Modified == nil { return " " } return * d . Modified } 
func ( d * DashboardLite ) GetModifiedOk ( ) ( string , bool ) { if d == nil || d . Modified == nil { return " " , false } return * d . Modified , true } 
func ( d * DashboardLite ) HasModified ( ) bool { if d != nil && d . Modified != nil { return true } return false } 
func ( d * DashboardLite ) GetReadOnly ( ) bool { if d == nil || d . ReadOnly == nil { return false } return * d . ReadOnly } 
func ( d * DashboardLite ) GetReadOnlyOk ( ) ( bool , bool ) { if d == nil || d . ReadOnly == nil { return false , false } return * d . ReadOnly , true } 
func ( d * DashboardLite ) HasReadOnly ( ) bool { if d != nil && d . ReadOnly != nil { return true } return false } 
func ( d * DashboardLite ) GetResource ( ) string { if d == nil || d . Resource == nil { return " " } return * d . Resource } 
func ( d * DashboardLite ) GetResourceOk ( ) ( string , bool ) { if d == nil || d . Resource == nil { return " " , false } return * d . Resource , true } 
func ( d * DashboardLite ) HasResource ( ) bool { if d != nil && d . Resource != nil { return true } return false } 
func ( d * DashboardLite ) GetTitle ( ) string { if d == nil || d . Title == nil { return " " } return * d . Title } 
func ( d * DashboardLite ) GetTitleOk ( ) ( string , bool ) { if d == nil || d . Title == nil { return " " , false } return * d . Title , true } 
func ( d * DashboardLite ) HasTitle ( ) bool { if d != nil && d . Title != nil { return true } return false } 
func ( d * DistributionDefinition ) GetTime ( ) WidgetTime { if d == nil || d . Time == nil { return WidgetTime { } } return * d . Time } 
func ( d * DistributionDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if d == nil || d . Time == nil { return WidgetTime { } , false } return * d . Time , true } 
func ( d * DistributionDefinition ) HasTime ( ) bool { if d != nil && d . Time != nil { return true } return false } 
func ( d * DistributionDefinition ) GetTitle ( ) string { if d == nil || d . Title == nil { return " " } return * d . Title } 
func ( d * DistributionDefinition ) HasTitle ( ) bool { if d != nil && d . Title != nil { return true } return false } 
func ( d * DistributionDefinition ) GetTitleAlign ( ) string { if d == nil || d . TitleAlign == nil { return " " } return * d . TitleAlign } 
func ( d * DistributionDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if d == nil || d . TitleAlign == nil { return " " , false } return * d . TitleAlign , true } 
func ( d * DistributionDefinition ) HasTitleAlign ( ) bool { if d != nil && d . TitleAlign != nil { return true } return false } 
func ( d * DistributionDefinition ) GetTitleSize ( ) string { if d == nil || d . TitleSize == nil { return " " } return * d . TitleSize } 
func ( d * DistributionDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if d == nil || d . TitleSize == nil { return " " , false } return * d . TitleSize , true } 
func ( d * DistributionDefinition ) HasTitleSize ( ) bool { if d != nil && d . TitleSize != nil { return true } return false } 
func ( d * DistributionDefinition ) GetType ( ) string { if d == nil || d . Type == nil { return " " } return * d . Type } 
func ( d * DistributionDefinition ) GetTypeOk ( ) ( string , bool ) { if d == nil || d . Type == nil { return " " , false } return * d . Type , true } 
func ( d * DistributionDefinition ) HasType ( ) bool { if d != nil && d . Type != nil { return true } return false } 
func ( d * DistributionRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if d == nil || d . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * d . ApmQuery } 
func ( d * DistributionRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if d == nil || d . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * d . ApmQuery , true } 
func ( d * DistributionRequest ) HasApmQuery ( ) bool { if d != nil && d . ApmQuery != nil { return true } return false } 
func ( d * DistributionRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if d == nil || d . LogQuery == nil { return WidgetApmOrLogQuery { } } return * d . LogQuery } 
func ( d * DistributionRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if d == nil || d . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * d . LogQuery , true } 
func ( d * DistributionRequest ) HasLogQuery ( ) bool { if d != nil && d . LogQuery != nil { return true } return false } 
func ( d * DistributionRequest ) GetMetricQuery ( ) string { if d == nil || d . MetricQuery == nil { return " " } return * d . MetricQuery } 
func ( d * DistributionRequest ) GetMetricQueryOk ( ) ( string , bool ) { if d == nil || d . MetricQuery == nil { return " " , false } return * d . MetricQuery , true } 
func ( d * DistributionRequest ) HasMetricQuery ( ) bool { if d != nil && d . MetricQuery != nil { return true } return false } 
func ( d * DistributionRequest ) GetProcessQuery ( ) WidgetProcessQuery { if d == nil || d . ProcessQuery == nil { return WidgetProcessQuery { } } return * d . ProcessQuery } 
func ( d * DistributionRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if d == nil || d . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * d . ProcessQuery , true } 
func ( d * DistributionRequest ) HasProcessQuery ( ) bool { if d != nil && d . ProcessQuery != nil { return true } return false } 
func ( d * DistributionRequest ) GetStyle ( ) WidgetRequestStyle { if d == nil || d . Style == nil { return WidgetRequestStyle { } } return * d . Style } 
func ( d * DistributionRequest ) GetStyleOk ( ) ( WidgetRequestStyle , bool ) { if d == nil || d . Style == nil { return WidgetRequestStyle { } , false } return * d . Style , true } 
func ( d * DistributionRequest ) HasStyle ( ) bool { if d != nil && d . Style != nil { return true } return false } 
func ( d * Downtime ) GetActive ( ) bool { if d == nil || d . Active == nil { return false } return * d . Active } 
func ( d * Downtime ) GetActiveOk ( ) ( bool , bool ) { if d == nil || d . Active == nil { return false , false } return * d . Active , true } 
func ( d * Downtime ) HasActive ( ) bool { if d != nil && d . Active != nil { return true } return false } 
func ( d * Downtime ) GetCanceled ( ) int { if d == nil || d . Canceled == nil { return 0 } return * d . Canceled } 
func ( d * Downtime ) GetCanceledOk ( ) ( int , bool ) { if d == nil || d . Canceled == nil { return 0 , false } return * d . Canceled , true } 
func ( d * Downtime ) HasCanceled ( ) bool { if d != nil && d . Canceled != nil { return true } return false } 
func ( d * Downtime ) GetDisabled ( ) bool { if d == nil || d . Disabled == nil { return false } return * d . Disabled } 
func ( d * Downtime ) GetDisabledOk ( ) ( bool , bool ) { if d == nil || d . Disabled == nil { return false , false } return * d . Disabled , true } 
func ( d * Downtime ) HasDisabled ( ) bool { if d != nil && d . Disabled != nil { return true } return false } 
func ( d * Downtime ) GetEnd ( ) int { if d == nil || d . End == nil { return 0 } return * d . End } 
func ( d * Downtime ) GetEndOk ( ) ( int , bool ) { if d == nil || d . End == nil { return 0 , false } return * d . End , true } 
func ( d * Downtime ) HasEnd ( ) bool { if d != nil && d . End != nil { return true } return false } 
func ( d * Downtime ) GetId ( ) int { if d == nil || d . Id == nil { return 0 } return * d . Id } 
func ( d * Downtime ) HasId ( ) bool { if d != nil && d . Id != nil { return true } return false } 
func ( d * Downtime ) GetMessage ( ) string { if d == nil || d . Message == nil { return " " } return * d . Message } 
func ( d * Downtime ) GetMessageOk ( ) ( string , bool ) { if d == nil || d . Message == nil { return " " , false } return * d . Message , true } 
func ( d * Downtime ) HasMessage ( ) bool { if d != nil && d . Message != nil { return true } return false } 
func ( d * Downtime ) GetMonitorId ( ) int { if d == nil || d . MonitorId == nil { return 0 } return * d . MonitorId } 
func ( d * Downtime ) GetMonitorIdOk ( ) ( int , bool ) { if d == nil || d . MonitorId == nil { return 0 , false } return * d . MonitorId , true } 
func ( d * Downtime ) HasMonitorId ( ) bool { if d != nil && d . MonitorId != nil { return true } return false } 
func ( d * Downtime ) GetParentId ( ) int { if d == nil || d . ParentId == nil { return 0 } return * d . ParentId } 
func ( d * Downtime ) GetParentIdOk ( ) ( int , bool ) { if d == nil || d . ParentId == nil { return 0 , false } return * d . ParentId , true } 
func ( d * Downtime ) HasParentId ( ) bool { if d != nil && d . ParentId != nil { return true } return false } 
func ( d * Downtime ) GetRecurrence ( ) Recurrence { if d == nil || d . Recurrence == nil { return Recurrence { } } return * d . Recurrence } 
func ( d * Downtime ) GetRecurrenceOk ( ) ( Recurrence , bool ) { if d == nil || d . Recurrence == nil { return Recurrence { } , false } return * d . Recurrence , true } 
func ( d * Downtime ) HasRecurrence ( ) bool { if d != nil && d . Recurrence != nil { return true } return false } 
func ( d * Downtime ) GetStart ( ) int { if d == nil || d . Start == nil { return 0 } return * d . Start } 
func ( d * Downtime ) GetStartOk ( ) ( int , bool ) { if d == nil || d . Start == nil { return 0 , false } return * d . Start , true } 
func ( d * Downtime ) HasStart ( ) bool { if d != nil && d . Start != nil { return true } return false } 
func ( d * Downtime ) GetTimezone ( ) string { if d == nil || d . Timezone == nil { return " " } return * d . Timezone } 
func ( d * Downtime ) GetTimezoneOk ( ) ( string , bool ) { if d == nil || d . Timezone == nil { return " " , false } return * d . Timezone , true } 
func ( d * Downtime ) HasTimezone ( ) bool { if d != nil && d . Timezone != nil { return true } return false } 
func ( e * Event ) GetAggregation ( ) string { if e == nil || e . Aggregation == nil { return " " } return * e . Aggregation } 
func ( e * Event ) GetAggregationOk ( ) ( string , bool ) { if e == nil || e . Aggregation == nil { return " " , false } return * e . Aggregation , true } 
func ( e * Event ) HasAggregation ( ) bool { if e != nil && e . Aggregation != nil { return true } return false } 
func ( e * Event ) GetAlertType ( ) string { if e == nil || e . AlertType == nil { return " " } return * e . AlertType } 
func ( e * Event ) GetAlertTypeOk ( ) ( string , bool ) { if e == nil || e . AlertType == nil { return " " , false } return * e . AlertType , true } 
func ( e * Event ) HasAlertType ( ) bool { if e != nil && e . AlertType != nil { return true } return false } 
func ( e * Event ) GetEventType ( ) string { if e == nil || e . EventType == nil { return " " } return * e . EventType } 
func ( e * Event ) GetEventTypeOk ( ) ( string , bool ) { if e == nil || e . EventType == nil { return " " , false } return * e . EventType , true } 
func ( e * Event ) HasEventType ( ) bool { if e != nil && e . EventType != nil { return true } return false } 
func ( e * Event ) GetHost ( ) string { if e == nil || e . Host == nil { return " " } return * e . Host } 
func ( e * Event ) GetHostOk ( ) ( string , bool ) { if e == nil || e . Host == nil { return " " , false } return * e . Host , true } 
func ( e * Event ) HasHost ( ) bool { if e != nil && e . Host != nil { return true } return false } 
func ( e * Event ) GetId ( ) int { if e == nil || e . Id == nil { return 0 } return * e . Id } 
func ( e * Event ) GetIdOk ( ) ( int , bool ) { if e == nil || e . Id == nil { return 0 , false } return * e . Id , true } 
func ( e * Event ) HasId ( ) bool { if e != nil && e . Id != nil { return true } return false } 
func ( e * Event ) GetPriority ( ) string { if e == nil || e . Priority == nil { return " " } return * e . Priority } 
func ( e * Event ) GetPriorityOk ( ) ( string , bool ) { if e == nil || e . Priority == nil { return " " , false } return * e . Priority , true } 
func ( e * Event ) HasPriority ( ) bool { if e != nil && e . Priority != nil { return true } return false } 
func ( e * Event ) GetResource ( ) string { if e == nil || e . Resource == nil { return " " } return * e . Resource } 
func ( e * Event ) GetResourceOk ( ) ( string , bool ) { if e == nil || e . Resource == nil { return " " , false } return * e . Resource , true } 
func ( e * Event ) HasResource ( ) bool { if e != nil && e . Resource != nil { return true } return false } 
func ( e * Event ) GetSourceType ( ) string { if e == nil || e . SourceType == nil { return " " } return * e . SourceType } 
func ( e * Event ) GetSourceTypeOk ( ) ( string , bool ) { if e == nil || e . SourceType == nil { return " " , false } return * e . SourceType , true } 
func ( e * Event ) HasSourceType ( ) bool { if e != nil && e . SourceType != nil { return true } return false } 
func ( e * Event ) GetText ( ) string { if e == nil || e . Text == nil { return " " } return * e . Text } 
func ( e * Event ) GetTextOk ( ) ( string , bool ) { if e == nil || e . Text == nil { return " " , false } return * e . Text , true } 
func ( e * Event ) HasText ( ) bool { if e != nil && e . Text != nil { return true } return false } 
func ( e * Event ) GetTime ( ) int { if e == nil || e . Time == nil { return 0 } return * e . Time } 
func ( e * Event ) GetTimeOk ( ) ( int , bool ) { if e == nil || e . Time == nil { return 0 , false } return * e . Time , true } 
func ( e * Event ) HasTime ( ) bool { if e != nil && e . Time != nil { return true } return false } 
func ( e * Event ) GetTitle ( ) string { if e == nil || e . Title == nil { return " " } return * e . Title } 
func ( e * Event ) HasTitle ( ) bool { if e != nil && e . Title != nil { return true } return false } 
func ( e * Event ) GetUrl ( ) string { if e == nil || e . Url == nil { return " " } return * e . Url } 
func ( e * Event ) GetUrlOk ( ) ( string , bool ) { if e == nil || e . Url == nil { return " " , false } return * e . Url , true } 
func ( e * Event ) HasUrl ( ) bool { if e != nil && e . Url != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetEventSize ( ) string { if e == nil || e . EventSize == nil { return " " } return * e . EventSize } 
func ( e * EventStreamDefinition ) GetEventSizeOk ( ) ( string , bool ) { if e == nil || e . EventSize == nil { return " " , false } return * e . EventSize , true } 
func ( e * EventStreamDefinition ) HasEventSize ( ) bool { if e != nil && e . EventSize != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetQuery ( ) string { if e == nil || e . Query == nil { return " " } return * e . Query } 
func ( e * EventStreamDefinition ) GetQueryOk ( ) ( string , bool ) { if e == nil || e . Query == nil { return " " , false } return * e . Query , true } 
func ( e * EventStreamDefinition ) HasQuery ( ) bool { if e != nil && e . Query != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetTime ( ) WidgetTime { if e == nil || e . Time == nil { return WidgetTime { } } return * e . Time } 
func ( e * EventStreamDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if e == nil || e . Time == nil { return WidgetTime { } , false } return * e . Time , true } 
func ( e * EventStreamDefinition ) HasTime ( ) bool { if e != nil && e . Time != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetTitle ( ) string { if e == nil || e . Title == nil { return " " } return * e . Title } 
func ( e * EventStreamDefinition ) GetTitleOk ( ) ( string , bool ) { if e == nil || e . Title == nil { return " " , false } return * e . Title , true } 
func ( e * EventStreamDefinition ) HasTitle ( ) bool { if e != nil && e . Title != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetTitleAlign ( ) string { if e == nil || e . TitleAlign == nil { return " " } return * e . TitleAlign } 
func ( e * EventStreamDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if e == nil || e . TitleAlign == nil { return " " , false } return * e . TitleAlign , true } 
func ( e * EventStreamDefinition ) HasTitleAlign ( ) bool { if e != nil && e . TitleAlign != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetTitleSize ( ) string { if e == nil || e . TitleSize == nil { return " " } return * e . TitleSize } 
func ( e * EventStreamDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if e == nil || e . TitleSize == nil { return " " , false } return * e . TitleSize , true } 
func ( e * EventStreamDefinition ) HasTitleSize ( ) bool { if e != nil && e . TitleSize != nil { return true } return false } 
func ( e * EventStreamDefinition ) GetType ( ) string { if e == nil || e . Type == nil { return " " } return * e . Type } 
func ( e * EventStreamDefinition ) GetTypeOk ( ) ( string , bool ) { if e == nil || e . Type == nil { return " " , false } return * e . Type , true } 
func ( e * EventStreamDefinition ) HasType ( ) bool { if e != nil && e . Type != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetQuery ( ) string { if e == nil || e . Query == nil { return " " } return * e . Query } 
func ( e * EventTimelineDefinition ) HasQuery ( ) bool { if e != nil && e . Query != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetTime ( ) WidgetTime { if e == nil || e . Time == nil { return WidgetTime { } } return * e . Time } 
func ( e * EventTimelineDefinition ) HasTime ( ) bool { if e != nil && e . Time != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetTitle ( ) string { if e == nil || e . Title == nil { return " " } return * e . Title } 
func ( e * EventTimelineDefinition ) HasTitle ( ) bool { if e != nil && e . Title != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetTitleAlign ( ) string { if e == nil || e . TitleAlign == nil { return " " } return * e . TitleAlign } 
func ( e * EventTimelineDefinition ) HasTitleAlign ( ) bool { if e != nil && e . TitleAlign != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetTitleSize ( ) string { if e == nil || e . TitleSize == nil { return " " } return * e . TitleSize } 
func ( e * EventTimelineDefinition ) HasTitleSize ( ) bool { if e != nil && e . TitleSize != nil { return true } return false } 
func ( e * EventTimelineDefinition ) GetType ( ) string { if e == nil || e . Type == nil { return " " } return * e . Type } 
func ( e * EventTimelineDefinition ) HasType ( ) bool { if e != nil && e . Type != nil { return true } return false } 
func ( f * FreeTextDefinition ) GetColor ( ) string { if f == nil || f . Color == nil { return " " } return * f . Color } 
func ( f * FreeTextDefinition ) GetColorOk ( ) ( string , bool ) { if f == nil || f . Color == nil { return " " , false } return * f . Color , true } 
func ( f * FreeTextDefinition ) HasColor ( ) bool { if f != nil && f . Color != nil { return true } return false } 
func ( f * FreeTextDefinition ) GetFontSize ( ) string { if f == nil || f . FontSize == nil { return " " } return * f . FontSize } 
func ( f * FreeTextDefinition ) GetFontSizeOk ( ) ( string , bool ) { if f == nil || f . FontSize == nil { return " " , false } return * f . FontSize , true } 
func ( f * FreeTextDefinition ) HasFontSize ( ) bool { if f != nil && f . FontSize != nil { return true } return false } 
func ( f * FreeTextDefinition ) GetText ( ) string { if f == nil || f . Text == nil { return " " } return * f . Text } 
func ( f * FreeTextDefinition ) GetTextOk ( ) ( string , bool ) { if f == nil || f . Text == nil { return " " , false } return * f . Text , true } 
func ( f * FreeTextDefinition ) HasText ( ) bool { if f != nil && f . Text != nil { return true } return false } 
func ( f * FreeTextDefinition ) GetTextAlign ( ) string { if f == nil || f . TextAlign == nil { return " " } return * f . TextAlign } 
func ( f * FreeTextDefinition ) GetTextAlignOk ( ) ( string , bool ) { if f == nil || f . TextAlign == nil { return " " , false } return * f . TextAlign , true } 
func ( f * FreeTextDefinition ) HasTextAlign ( ) bool { if f != nil && f . TextAlign != nil { return true } return false } 
func ( f * FreeTextDefinition ) GetType ( ) string { if f == nil || f . Type == nil { return " " } return * f . Type } 
func ( f * FreeTextDefinition ) GetTypeOk ( ) ( string , bool ) { if f == nil || f . Type == nil { return " " , false } return * f . Type , true } 
func ( f * FreeTextDefinition ) HasType ( ) bool { if f != nil && f . Type != nil { return true } return false } 
func ( g * Graph ) GetDefinition ( ) GraphDefinition { if g == nil || g . Definition == nil { return GraphDefinition { } } return * g . Definition } 
func ( g * Graph ) GetDefinitionOk ( ) ( GraphDefinition , bool ) { if g == nil || g . Definition == nil { return GraphDefinition { } , false } return * g . Definition , true } 
func ( g * Graph ) HasDefinition ( ) bool { if g != nil && g . Definition != nil { return true } return false } 
func ( g * Graph ) GetTitle ( ) string { if g == nil || g . Title == nil { return " " } return * g . Title } 
func ( g * Graph ) GetTitleOk ( ) ( string , bool ) { if g == nil || g . Title == nil { return " " , false } return * g . Title , true } 
func ( g * Graph ) HasTitle ( ) bool { if g != nil && g . Title != nil { return true } return false } 
func ( g * GraphDefinition ) GetAutoscale ( ) bool { if g == nil || g . Autoscale == nil { return false } return * g . Autoscale } 
func ( g * GraphDefinition ) GetAutoscaleOk ( ) ( bool , bool ) { if g == nil || g . Autoscale == nil { return false , false } return * g . Autoscale , true } 
func ( g * GraphDefinition ) HasAutoscale ( ) bool { if g != nil && g . Autoscale != nil { return true } return false } 
func ( g * GraphDefinition ) GetCustomUnit ( ) string { if g == nil || g . CustomUnit == nil { return " " } return * g . CustomUnit } 
func ( g * GraphDefinition ) GetCustomUnitOk ( ) ( string , bool ) { if g == nil || g . CustomUnit == nil { return " " , false } return * g . CustomUnit , true } 
func ( g * GraphDefinition ) HasCustomUnit ( ) bool { if g != nil && g . CustomUnit != nil { return true } return false } 
func ( g * GraphDefinition ) GetIncludeNoMetricHosts ( ) bool { if g == nil || g . IncludeNoMetricHosts == nil { return false } return * g . IncludeNoMetricHosts } 
func ( g * GraphDefinition ) GetIncludeNoMetricHostsOk ( ) ( bool , bool ) { if g == nil || g . IncludeNoMetricHosts == nil { return false , false } return * g . IncludeNoMetricHosts , true } 
func ( g * GraphDefinition ) HasIncludeNoMetricHosts ( ) bool { if g != nil && g . IncludeNoMetricHosts != nil { return true } return false } 
func ( g * GraphDefinition ) GetIncludeUngroupedHosts ( ) bool { if g == nil || g . IncludeUngroupedHosts == nil { return false } return * g . IncludeUngroupedHosts } 
func ( g * GraphDefinition ) GetIncludeUngroupedHostsOk ( ) ( bool , bool ) { if g == nil || g . IncludeUngroupedHosts == nil { return false , false } return * g . IncludeUngroupedHosts , true } 
func ( g * GraphDefinition ) HasIncludeUngroupedHosts ( ) bool { if g != nil && g . IncludeUngroupedHosts != nil { return true } return false } 
func ( g * GraphDefinition ) GetNodeType ( ) string { if g == nil || g . NodeType == nil { return " " } return * g . NodeType } 
func ( g * GraphDefinition ) GetNodeTypeOk ( ) ( string , bool ) { if g == nil || g . NodeType == nil { return " " , false } return * g . NodeType , true } 
func ( g * GraphDefinition ) HasNodeType ( ) bool { if g != nil && g . NodeType != nil { return true } return false } 
func ( g * GraphDefinition ) GetPrecision ( ) PrecisionT { if g == nil || g . Precision == nil { return " " } return * g . Precision } 
func ( g * GraphDefinition ) GetPrecisionOk ( ) ( PrecisionT , bool ) { if g == nil || g . Precision == nil { return " " , false } return * g . Precision , true } 
func ( g * GraphDefinition ) HasPrecision ( ) bool { if g != nil && g . Precision != nil { return true } return false } 
func ( g * GraphDefinition ) GetStyle ( ) Style { if g == nil || g . Style == nil { return Style { } } return * g . Style } 
func ( g * GraphDefinition ) GetStyleOk ( ) ( Style , bool ) { if g == nil || g . Style == nil { return Style { } , false } return * g . Style , true } 
func ( g * GraphDefinition ) HasStyle ( ) bool { if g != nil && g . Style != nil { return true } return false } 
func ( g * GraphDefinition ) GetTextAlign ( ) string { if g == nil || g . TextAlign == nil { return " " } return * g . TextAlign } 
func ( g * GraphDefinition ) GetTextAlignOk ( ) ( string , bool ) { if g == nil || g . TextAlign == nil { return " " , false } return * g . TextAlign , true } 
func ( g * GraphDefinition ) HasTextAlign ( ) bool { if g != nil && g . TextAlign != nil { return true } return false } 
func ( g * GraphDefinition ) GetViz ( ) string { if g == nil || g . Viz == nil { return " " } return * g . Viz } 
func ( g * GraphDefinition ) GetVizOk ( ) ( string , bool ) { if g == nil || g . Viz == nil { return " " , false } return * g . Viz , true } 
func ( g * GraphDefinition ) HasViz ( ) bool { if g != nil && g . Viz != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetLabel ( ) string { if g == nil || g . Label == nil { return " " } return * g . Label } 
func ( g * GraphDefinitionMarker ) GetLabelOk ( ) ( string , bool ) { if g == nil || g . Label == nil { return " " , false } return * g . Label , true } 
func ( g * GraphDefinitionMarker ) HasLabel ( ) bool { if g != nil && g . Label != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetMax ( ) json . Number { if g == nil || g . Max == nil { return " " } return * g . Max } 
func ( g * GraphDefinitionMarker ) GetMaxOk ( ) ( json . Number , bool ) { if g == nil || g . Max == nil { return " " , false } return * g . Max , true } 
func ( g * GraphDefinitionMarker ) HasMax ( ) bool { if g != nil && g . Max != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetMin ( ) json . Number { if g == nil || g . Min == nil { return " " } return * g . Min } 
func ( g * GraphDefinitionMarker ) GetMinOk ( ) ( json . Number , bool ) { if g == nil || g . Min == nil { return " " , false } return * g . Min , true } 
func ( g * GraphDefinitionMarker ) HasMin ( ) bool { if g != nil && g . Min != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetType ( ) string { if g == nil || g . Type == nil { return " " } return * g . Type } 
func ( g * GraphDefinitionMarker ) HasType ( ) bool { if g != nil && g . Type != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetVal ( ) json . Number { if g == nil || g . Val == nil { return " " } return * g . Val } 
func ( g * GraphDefinitionMarker ) GetValOk ( ) ( json . Number , bool ) { if g == nil || g . Val == nil { return " " , false } return * g . Val , true } 
func ( g * GraphDefinitionMarker ) HasVal ( ) bool { if g != nil && g . Val != nil { return true } return false } 
func ( g * GraphDefinitionMarker ) GetValue ( ) string { if g == nil || g . Value == nil { return " " } return * g . Value } 
func ( g * GraphDefinitionMarker ) GetValueOk ( ) ( string , bool ) { if g == nil || g . Value == nil { return " " , false } return * g . Value , true } 
func ( g * GraphDefinitionMarker ) HasValue ( ) bool { if g != nil && g . Value != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetAggregator ( ) string { if g == nil || g . Aggregator == nil { return " " } return * g . Aggregator } 
func ( g * GraphDefinitionRequest ) GetAggregatorOk ( ) ( string , bool ) { if g == nil || g . Aggregator == nil { return " " , false } return * g . Aggregator , true } 
func ( g * GraphDefinitionRequest ) HasAggregator ( ) bool { if g != nil && g . Aggregator != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetChangeType ( ) string { if g == nil || g . ChangeType == nil { return " " } return * g . ChangeType } 
func ( g * GraphDefinitionRequest ) GetChangeTypeOk ( ) ( string , bool ) { if g == nil || g . ChangeType == nil { return " " , false } return * g . ChangeType , true } 
func ( g * GraphDefinitionRequest ) HasChangeType ( ) bool { if g != nil && g . ChangeType != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetCompareTo ( ) string { if g == nil || g . CompareTo == nil { return " " } return * g . CompareTo } 
func ( g * GraphDefinitionRequest ) GetCompareToOk ( ) ( string , bool ) { if g == nil || g . CompareTo == nil { return " " , false } return * g . CompareTo , true } 
func ( g * GraphDefinitionRequest ) HasCompareTo ( ) bool { if g != nil && g . CompareTo != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetExtraCol ( ) string { if g == nil || g . ExtraCol == nil { return " " } return * g . ExtraCol } 
func ( g * GraphDefinitionRequest ) GetExtraColOk ( ) ( string , bool ) { if g == nil || g . ExtraCol == nil { return " " , false } return * g . ExtraCol , true } 
func ( g * GraphDefinitionRequest ) HasExtraCol ( ) bool { if g != nil && g . ExtraCol != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetIncreaseGood ( ) bool { if g == nil || g . IncreaseGood == nil { return false } return * g . IncreaseGood } 
func ( g * GraphDefinitionRequest ) GetIncreaseGoodOk ( ) ( bool , bool ) { if g == nil || g . IncreaseGood == nil { return false , false } return * g . IncreaseGood , true } 
func ( g * GraphDefinitionRequest ) HasIncreaseGood ( ) bool { if g != nil && g . IncreaseGood != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetOrderBy ( ) string { if g == nil || g . OrderBy == nil { return " " } return * g . OrderBy } 
func ( g * GraphDefinitionRequest ) GetOrderByOk ( ) ( string , bool ) { if g == nil || g . OrderBy == nil { return " " , false } return * g . OrderBy , true } 
func ( g * GraphDefinitionRequest ) HasOrderBy ( ) bool { if g != nil && g . OrderBy != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetOrderDirection ( ) string { if g == nil || g . OrderDirection == nil { return " " } return * g . OrderDirection } 
func ( g * GraphDefinitionRequest ) GetOrderDirectionOk ( ) ( string , bool ) { if g == nil || g . OrderDirection == nil { return " " , false } return * g . OrderDirection , true } 
func ( g * GraphDefinitionRequest ) HasOrderDirection ( ) bool { if g != nil && g . OrderDirection != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetQuery ( ) string { if g == nil || g . Query == nil { return " " } return * g . Query } 
func ( g * GraphDefinitionRequest ) HasQuery ( ) bool { if g != nil && g . Query != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetStacked ( ) bool { if g == nil || g . Stacked == nil { return false } return * g . Stacked } 
func ( g * GraphDefinitionRequest ) GetStackedOk ( ) ( bool , bool ) { if g == nil || g . Stacked == nil { return false , false } return * g . Stacked , true } 
func ( g * GraphDefinitionRequest ) HasStacked ( ) bool { if g != nil && g . Stacked != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetStyle ( ) GraphDefinitionRequestStyle { if g == nil || g . Style == nil { return GraphDefinitionRequestStyle { } } return * g . Style } 
func ( g * GraphDefinitionRequest ) GetStyleOk ( ) ( GraphDefinitionRequestStyle , bool ) { if g == nil || g . Style == nil { return GraphDefinitionRequestStyle { } , false } return * g . Style , true } 
func ( g * GraphDefinitionRequest ) HasStyle ( ) bool { if g != nil && g . Style != nil { return true } return false } 
func ( g * GraphDefinitionRequest ) GetType ( ) string { if g == nil || g . Type == nil { return " " } return * g . Type } 
func ( g * GraphDefinitionRequest ) GetTypeOk ( ) ( string , bool ) { if g == nil || g . Type == nil { return " " , false } return * g . Type , true } 
func ( g * GraphDefinitionRequest ) HasType ( ) bool { if g != nil && g . Type != nil { return true } return false } 
func ( g * GraphDefinitionRequestStyle ) GetPalette ( ) string { if g == nil || g . Palette == nil { return " " } return * g . Palette } 
func ( g * GraphDefinitionRequestStyle ) GetPaletteOk ( ) ( string , bool ) { if g == nil || g . Palette == nil { return " " , false } return * g . Palette , true } 
func ( g * GraphDefinitionRequestStyle ) HasPalette ( ) bool { if g != nil && g . Palette != nil { return true } return false } 
func ( g * GraphDefinitionRequestStyle ) GetType ( ) string { if g == nil || g . Type == nil { return " " } return * g . Type } 
func ( g * GraphDefinitionRequestStyle ) HasType ( ) bool { if g != nil && g . Type != nil { return true } return false } 
func ( g * GraphDefinitionRequestStyle ) GetWidth ( ) string { if g == nil || g . Width == nil { return " " } return * g . Width } 
func ( g * GraphDefinitionRequestStyle ) GetWidthOk ( ) ( string , bool ) { if g == nil || g . Width == nil { return " " , false } return * g . Width , true } 
func ( g * GraphDefinitionRequestStyle ) HasWidth ( ) bool { if g != nil && g . Width != nil { return true } return false } 
func ( g * GraphEvent ) GetQuery ( ) string { if g == nil || g . Query == nil { return " " } return * g . Query } 
func ( g * GraphEvent ) GetQueryOk ( ) ( string , bool ) { if g == nil || g . Query == nil { return " " , false } return * g . Query , true } 
func ( g * GraphEvent ) HasQuery ( ) bool { if g != nil && g . Query != nil { return true } return false } 
func ( g * GroupData ) GetLastNoDataTs ( ) int { if g == nil || g . LastNoDataTs == nil { return 0 } return * g . LastNoDataTs } 
func ( g * GroupData ) GetLastNoDataTsOk ( ) ( int , bool ) { if g == nil || g . LastNoDataTs == nil { return 0 , false } return * g . LastNoDataTs , true } 
func ( g * GroupData ) HasLastNoDataTs ( ) bool { if g != nil && g . LastNoDataTs != nil { return true } return false } 
func ( g * GroupData ) GetLastNotifiedTs ( ) int { if g == nil || g . LastNotifiedTs == nil { return 0 } return * g . LastNotifiedTs } 
func ( g * GroupData ) GetLastNotifiedTsOk ( ) ( int , bool ) { if g == nil || g . LastNotifiedTs == nil { return 0 , false } return * g . LastNotifiedTs , true } 
func ( g * GroupData ) HasLastNotifiedTs ( ) bool { if g != nil && g . LastNotifiedTs != nil { return true } return false } 
func ( g * GroupData ) GetLastResolvedTs ( ) int { if g == nil || g . LastResolvedTs == nil { return 0 } return * g . LastResolvedTs } 
func ( g * GroupData ) GetLastResolvedTsOk ( ) ( int , bool ) { if g == nil || g . LastResolvedTs == nil { return 0 , false } return * g . LastResolvedTs , true } 
func ( g * GroupData ) HasLastResolvedTs ( ) bool { if g != nil && g . LastResolvedTs != nil { return true } return false } 
func ( g * GroupData ) GetLastTriggeredTs ( ) int { if g == nil || g . LastTriggeredTs == nil { return 0 } return * g . LastTriggeredTs } 
func ( g * GroupData ) GetLastTriggeredTsOk ( ) ( int , bool ) { if g == nil || g . LastTriggeredTs == nil { return 0 , false } return * g . LastTriggeredTs , true } 
func ( g * GroupData ) HasLastTriggeredTs ( ) bool { if g != nil && g . LastTriggeredTs != nil { return true } return false } 
func ( g * GroupData ) GetName ( ) string { if g == nil || g . Name == nil { return " " } return * g . Name } 
func ( g * GroupData ) GetNameOk ( ) ( string , bool ) { if g == nil || g . Name == nil { return " " , false } return * g . Name , true } 
func ( g * GroupData ) HasName ( ) bool { if g != nil && g . Name != nil { return true } return false } 
func ( g * GroupData ) GetStatus ( ) string { if g == nil || g . Status == nil { return " " } return * g . Status } 
func ( g * GroupData ) GetStatusOk ( ) ( string , bool ) { if g == nil || g . Status == nil { return " " , false } return * g . Status , true } 
func ( g * GroupData ) HasStatus ( ) bool { if g != nil && g . Status != nil { return true } return false } 
func ( g * GroupData ) GetTriggeringValue ( ) TriggeringValue { if g == nil || g . TriggeringValue == nil { return TriggeringValue { } } return * g . TriggeringValue } 
func ( g * GroupData ) GetTriggeringValueOk ( ) ( TriggeringValue , bool ) { if g == nil || g . TriggeringValue == nil { return TriggeringValue { } , false } return * g . TriggeringValue , true } 
func ( g * GroupData ) HasTriggeringValue ( ) bool { if g != nil && g . TriggeringValue != nil { return true } return false } 
func ( g * GroupDefinition ) GetLayoutType ( ) string { if g == nil || g . LayoutType == nil { return " " } return * g . LayoutType } 
func ( g * GroupDefinition ) GetLayoutTypeOk ( ) ( string , bool ) { if g == nil || g . LayoutType == nil { return " " , false } return * g . LayoutType , true } 
func ( g * GroupDefinition ) HasLayoutType ( ) bool { if g != nil && g . LayoutType != nil { return true } return false } 
func ( g * GroupDefinition ) GetTitle ( ) string { if g == nil || g . Title == nil { return " " } return * g . Title } 
func ( g * GroupDefinition ) HasTitle ( ) bool { if g != nil && g . Title != nil { return true } return false } 
func ( g * GroupDefinition ) GetType ( ) string { if g == nil || g . Type == nil { return " " } return * g . Type } 
func ( g * GroupDefinition ) HasType ( ) bool { if g != nil && g . Type != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetTime ( ) WidgetTime { if h == nil || h . Time == nil { return WidgetTime { } } return * h . Time } 
func ( h * HeatmapDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if h == nil || h . Time == nil { return WidgetTime { } , false } return * h . Time , true } 
func ( h * HeatmapDefinition ) HasTime ( ) bool { if h != nil && h . Time != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetTitle ( ) string { if h == nil || h . Title == nil { return " " } return * h . Title } 
func ( h * HeatmapDefinition ) GetTitleOk ( ) ( string , bool ) { if h == nil || h . Title == nil { return " " , false } return * h . Title , true } 
func ( h * HeatmapDefinition ) HasTitle ( ) bool { if h != nil && h . Title != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetTitleAlign ( ) string { if h == nil || h . TitleAlign == nil { return " " } return * h . TitleAlign } 
func ( h * HeatmapDefinition ) HasTitleAlign ( ) bool { if h != nil && h . TitleAlign != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetTitleSize ( ) string { if h == nil || h . TitleSize == nil { return " " } return * h . TitleSize } 
func ( h * HeatmapDefinition ) HasTitleSize ( ) bool { if h != nil && h . TitleSize != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetType ( ) string { if h == nil || h . Type == nil { return " " } return * h . Type } 
func ( h * HeatmapDefinition ) GetTypeOk ( ) ( string , bool ) { if h == nil || h . Type == nil { return " " , false } return * h . Type , true } 
func ( h * HeatmapDefinition ) HasType ( ) bool { if h != nil && h . Type != nil { return true } return false } 
func ( h * HeatmapDefinition ) GetYaxis ( ) WidgetAxis { if h == nil || h . Yaxis == nil { return WidgetAxis { } } return * h . Yaxis } 
func ( h * HeatmapDefinition ) GetYaxisOk ( ) ( WidgetAxis , bool ) { if h == nil || h . Yaxis == nil { return WidgetAxis { } , false } return * h . Yaxis , true } 
func ( h * HeatmapDefinition ) HasYaxis ( ) bool { if h != nil && h . Yaxis != nil { return true } return false } 
func ( h * HeatmapRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if h == nil || h . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * h . ApmQuery } 
func ( h * HeatmapRequest ) HasApmQuery ( ) bool { if h != nil && h . ApmQuery != nil { return true } return false } 
func ( h * HeatmapRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if h == nil || h . LogQuery == nil { return WidgetApmOrLogQuery { } } return * h . LogQuery } 
func ( h * HeatmapRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if h == nil || h . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * h . LogQuery , true } 
func ( h * HeatmapRequest ) HasLogQuery ( ) bool { if h != nil && h . LogQuery != nil { return true } return false } 
func ( h * HeatmapRequest ) GetMetricQuery ( ) string { if h == nil || h . MetricQuery == nil { return " " } return * h . MetricQuery } 
func ( h * HeatmapRequest ) HasMetricQuery ( ) bool { if h != nil && h . MetricQuery != nil { return true } return false } 
func ( h * HeatmapRequest ) GetProcessQuery ( ) WidgetProcessQuery { if h == nil || h . ProcessQuery == nil { return WidgetProcessQuery { } } return * h . ProcessQuery } 
func ( h * HeatmapRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if h == nil || h . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * h . ProcessQuery , true } 
func ( h * HeatmapRequest ) HasProcessQuery ( ) bool { if h != nil && h . ProcessQuery != nil { return true } return false } 
func ( h * HeatmapRequest ) GetStyle ( ) WidgetRequestStyle { if h == nil || h . Style == nil { return WidgetRequestStyle { } } return * h . Style } 
func ( h * HeatmapRequest ) GetStyleOk ( ) ( WidgetRequestStyle , bool ) { if h == nil || h . Style == nil { return WidgetRequestStyle { } , false } return * h . Style , true } 
func ( h * HeatmapRequest ) HasStyle ( ) bool { if h != nil && h . Style != nil { return true } return false } 
func ( h * HostActionMute ) GetEndTime ( ) string { if h == nil || h . EndTime == nil { return " " } return * h . EndTime } 
func ( h * HostActionMute ) GetEndTimeOk ( ) ( string , bool ) { if h == nil || h . EndTime == nil { return " " , false } return * h . EndTime , true } 
func ( h * HostActionMute ) HasEndTime ( ) bool { if h != nil && h . EndTime != nil { return true } return false } 
func ( h * HostActionMute ) GetMessage ( ) string { if h == nil || h . Message == nil { return " " } return * h . Message } 
func ( h * HostActionMute ) GetMessageOk ( ) ( string , bool ) { if h == nil || h . Message == nil { return " " , false } return * h . Message , true } 
func ( h * HostActionMute ) HasMessage ( ) bool { if h != nil && h . Message != nil { return true } return false } 
func ( h * HostActionMute ) GetOverride ( ) bool { if h == nil || h . Override == nil { return false } return * h . Override } 
func ( h * HostActionMute ) GetOverrideOk ( ) ( bool , bool ) { if h == nil || h . Override == nil { return false , false } return * h . Override , true } 
func ( h * HostActionMute ) HasOverride ( ) bool { if h != nil && h . Override != nil { return true } return false } 
func ( h * HostmapDefinition ) GetNodeType ( ) string { if h == nil || h . NodeType == nil { return " " } return * h . NodeType } 
func ( h * HostmapDefinition ) GetNodeTypeOk ( ) ( string , bool ) { if h == nil || h . NodeType == nil { return " " , false } return * h . NodeType , true } 
func ( h * HostmapDefinition ) HasNodeType ( ) bool { if h != nil && h . NodeType != nil { return true } return false } 
func ( h * HostmapDefinition ) GetNoGroupHosts ( ) bool { if h == nil || h . NoGroupHosts == nil { return false } return * h . NoGroupHosts } 
func ( h * HostmapDefinition ) GetNoGroupHostsOk ( ) ( bool , bool ) { if h == nil || h . NoGroupHosts == nil { return false , false } return * h . NoGroupHosts , true } 
func ( h * HostmapDefinition ) HasNoGroupHosts ( ) bool { if h != nil && h . NoGroupHosts != nil { return true } return false } 
func ( h * HostmapDefinition ) GetNoMetricHosts ( ) bool { if h == nil || h . NoMetricHosts == nil { return false } return * h . NoMetricHosts } 
func ( h * HostmapDefinition ) GetNoMetricHostsOk ( ) ( bool , bool ) { if h == nil || h . NoMetricHosts == nil { return false , false } return * h . NoMetricHosts , true } 
func ( h * HostmapDefinition ) HasNoMetricHosts ( ) bool { if h != nil && h . NoMetricHosts != nil { return true } return false } 
func ( h * HostmapDefinition ) GetRequests ( ) HostmapRequests { if h == nil || h . Requests == nil { return HostmapRequests { } } return * h . Requests } 
func ( h * HostmapDefinition ) GetRequestsOk ( ) ( HostmapRequests , bool ) { if h == nil || h . Requests == nil { return HostmapRequests { } , false } return * h . Requests , true } 
func ( h * HostmapDefinition ) HasRequests ( ) bool { if h != nil && h . Requests != nil { return true } return false } 
func ( h * HostmapDefinition ) GetStyle ( ) HostmapStyle { if h == nil || h . Style == nil { return HostmapStyle { } } return * h . Style } 
func ( h * HostmapDefinition ) GetStyleOk ( ) ( HostmapStyle , bool ) { if h == nil || h . Style == nil { return HostmapStyle { } , false } return * h . Style , true } 
func ( h * HostmapDefinition ) HasStyle ( ) bool { if h != nil && h . Style != nil { return true } return false } 
func ( h * HostmapDefinition ) GetTitle ( ) string { if h == nil || h . Title == nil { return " " } return * h . Title } 
func ( h * HostmapDefinition ) HasTitle ( ) bool { if h != nil && h . Title != nil { return true } return false } 
func ( h * HostmapDefinition ) GetTitleAlign ( ) string { if h == nil || h . TitleAlign == nil { return " " } return * h . TitleAlign } 
func ( h * HostmapDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if h == nil || h . TitleAlign == nil { return " " , false } return * h . TitleAlign , true } 
func ( h * HostmapDefinition ) HasTitleAlign ( ) bool { if h != nil && h . TitleAlign != nil { return true } return false } 
func ( h * HostmapDefinition ) GetTitleSize ( ) string { if h == nil || h . TitleSize == nil { return " " } return * h . TitleSize } 
func ( h * HostmapDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if h == nil || h . TitleSize == nil { return " " , false } return * h . TitleSize , true } 
func ( h * HostmapDefinition ) HasTitleSize ( ) bool { if h != nil && h . TitleSize != nil { return true } return false } 
func ( h * HostmapDefinition ) GetType ( ) string { if h == nil || h . Type == nil { return " " } return * h . Type } 
func ( h * HostmapDefinition ) HasType ( ) bool { if h != nil && h . Type != nil { return true } return false } 
func ( h * HostmapRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if h == nil || h . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * h . ApmQuery } 
func ( h * HostmapRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if h == nil || h . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * h . ApmQuery , true } 
func ( h * HostmapRequest ) HasApmQuery ( ) bool { if h != nil && h . ApmQuery != nil { return true } return false } 
func ( h * HostmapRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if h == nil || h . LogQuery == nil { return WidgetApmOrLogQuery { } } return * h . LogQuery } 
func ( h * HostmapRequest ) HasLogQuery ( ) bool { if h != nil && h . LogQuery != nil { return true } return false } 
func ( h * HostmapRequest ) GetMetricQuery ( ) string { if h == nil || h . MetricQuery == nil { return " " } return * h . MetricQuery } 
func ( h * HostmapRequest ) GetMetricQueryOk ( ) ( string , bool ) { if h == nil || h . MetricQuery == nil { return " " , false } return * h . MetricQuery , true } 
func ( h * HostmapRequest ) HasMetricQuery ( ) bool { if h != nil && h . MetricQuery != nil { return true } return false } 
func ( h * HostmapRequest ) GetProcessQuery ( ) WidgetProcessQuery { if h == nil || h . ProcessQuery == nil { return WidgetProcessQuery { } } return * h . ProcessQuery } 
func ( h * HostmapRequest ) HasProcessQuery ( ) bool { if h != nil && h . ProcessQuery != nil { return true } return false } 
func ( h * HostmapRequests ) GetFill ( ) HostmapRequest { if h == nil || h . Fill == nil { return HostmapRequest { } } return * h . Fill } 
func ( h * HostmapRequests ) GetFillOk ( ) ( HostmapRequest , bool ) { if h == nil || h . Fill == nil { return HostmapRequest { } , false } return * h . Fill , true } 
func ( h * HostmapRequests ) HasFill ( ) bool { if h != nil && h . Fill != nil { return true } return false } 
func ( h * HostmapRequests ) GetSize ( ) HostmapRequest { if h == nil || h . Size == nil { return HostmapRequest { } } return * h . Size } 
func ( h * HostmapRequests ) GetSizeOk ( ) ( HostmapRequest , bool ) { if h == nil || h . Size == nil { return HostmapRequest { } , false } return * h . Size , true } 
func ( h * HostmapRequests ) HasSize ( ) bool { if h != nil && h . Size != nil { return true } return false } 
func ( h * HostmapStyle ) GetFillMax ( ) string { if h == nil || h . FillMax == nil { return " " } return * h . FillMax } 
func ( h * HostmapStyle ) GetFillMaxOk ( ) ( string , bool ) { if h == nil || h . FillMax == nil { return " " , false } return * h . FillMax , true } 
func ( h * HostmapStyle ) HasFillMax ( ) bool { if h != nil && h . FillMax != nil { return true } return false } 
func ( h * HostmapStyle ) GetFillMin ( ) string { if h == nil || h . FillMin == nil { return " " } return * h . FillMin } 
func ( h * HostmapStyle ) GetFillMinOk ( ) ( string , bool ) { if h == nil || h . FillMin == nil { return " " , false } return * h . FillMin , true } 
func ( h * HostmapStyle ) HasFillMin ( ) bool { if h != nil && h . FillMin != nil { return true } return false } 
func ( h * HostmapStyle ) GetPalette ( ) string { if h == nil || h . Palette == nil { return " " } return * h . Palette } 
func ( h * HostmapStyle ) GetPaletteOk ( ) ( string , bool ) { if h == nil || h . Palette == nil { return " " , false } return * h . Palette , true } 
func ( h * HostmapStyle ) HasPalette ( ) bool { if h != nil && h . Palette != nil { return true } return false } 
func ( h * HostmapStyle ) GetPaletteFlip ( ) bool { if h == nil || h . PaletteFlip == nil { return false } return * h . PaletteFlip } 
func ( h * HostmapStyle ) GetPaletteFlipOk ( ) ( bool , bool ) { if h == nil || h . PaletteFlip == nil { return false , false } return * h . PaletteFlip , true } 
func ( h * HostmapStyle ) HasPaletteFlip ( ) bool { if h != nil && h . PaletteFlip != nil { return true } return false } 
func ( i * IframeDefinition ) GetType ( ) string { if i == nil || i . Type == nil { return " " } return * i . Type } 
func ( i * IframeDefinition ) GetTypeOk ( ) ( string , bool ) { if i == nil || i . Type == nil { return " " , false } return * i . Type , true } 
func ( i * IframeDefinition ) HasType ( ) bool { if i != nil && i . Type != nil { return true } return false } 
func ( i * IframeDefinition ) GetUrl ( ) string { if i == nil || i . Url == nil { return " " } return * i . Url } 
func ( i * IframeDefinition ) HasUrl ( ) bool { if i != nil && i . Url != nil { return true } return false } 
func ( i * ImageDefinition ) GetMargin ( ) string { if i == nil || i . Margin == nil { return " " } return * i . Margin } 
func ( i * ImageDefinition ) GetMarginOk ( ) ( string , bool ) { if i == nil || i . Margin == nil { return " " , false } return * i . Margin , true } 
func ( i * ImageDefinition ) HasMargin ( ) bool { if i != nil && i . Margin != nil { return true } return false } 
func ( i * ImageDefinition ) GetSizing ( ) string { if i == nil || i . Sizing == nil { return " " } return * i . Sizing } 
func ( i * ImageDefinition ) GetSizingOk ( ) ( string , bool ) { if i == nil || i . Sizing == nil { return " " , false } return * i . Sizing , true } 
func ( i * ImageDefinition ) HasSizing ( ) bool { if i != nil && i . Sizing != nil { return true } return false } 
func ( i * ImageDefinition ) GetType ( ) string { if i == nil || i . Type == nil { return " " } return * i . Type } 
func ( i * ImageDefinition ) HasType ( ) bool { if i != nil && i . Type != nil { return true } return false } 
func ( i * ImageDefinition ) GetUrl ( ) string { if i == nil || i . Url == nil { return " " } return * i . Url } 
func ( i * ImageDefinition ) GetUrlOk ( ) ( string , bool ) { if i == nil || i . Url == nil { return " " , false } return * i . Url , true } 
func ( i * ImageDefinition ) HasUrl ( ) bool { if i != nil && i . Url != nil { return true } return false } 
func ( i * IntegrationAWSAccount ) GetAccountID ( ) string { if i == nil || i . AccountID == nil { return " " } return * i . AccountID } 
func ( i * IntegrationAWSAccount ) HasAccountID ( ) bool { if i != nil && i . AccountID != nil { return true } return false } 
func ( i * IntegrationAWSAccount ) GetRoleName ( ) string { if i == nil || i . RoleName == nil { return " " } return * i . RoleName } 
func ( i * IntegrationAWSAccount ) GetRoleNameOk ( ) ( string , bool ) { if i == nil || i . RoleName == nil { return " " , false } return * i . RoleName , true } 
func ( i * IntegrationAWSAccount ) HasRoleName ( ) bool { if i != nil && i . RoleName != nil { return true } return false } 
func ( i * IntegrationAWSAccountDeleteRequest ) GetAccountID ( ) string { if i == nil || i . AccountID == nil { return " " } return * i . AccountID } 
func ( i * IntegrationAWSAccountDeleteRequest ) GetAccountIDOk ( ) ( string , bool ) { if i == nil || i . AccountID == nil { return " " , false } return * i . AccountID , true } 
func ( i * IntegrationAWSAccountDeleteRequest ) HasAccountID ( ) bool { if i != nil && i . AccountID != nil { return true } return false } 
func ( i * IntegrationAWSAccountDeleteRequest ) GetRoleName ( ) string { if i == nil || i . RoleName == nil { return " " } return * i . RoleName } 
func ( i * IntegrationAWSAccountDeleteRequest ) HasRoleName ( ) bool { if i != nil && i . RoleName != nil { return true } return false } 
func ( i * IntegrationGCP ) GetClientEmail ( ) string { if i == nil || i . ClientEmail == nil { return " " } return * i . ClientEmail } 
func ( i * IntegrationGCP ) HasClientEmail ( ) bool { if i != nil && i . ClientEmail != nil { return true } return false } 
func ( i * IntegrationGCP ) GetHostFilters ( ) string { if i == nil || i . HostFilters == nil { return " " } return * i . HostFilters } 
func ( i * IntegrationGCP ) HasHostFilters ( ) bool { if i != nil && i . HostFilters != nil { return true } return false } 
func ( i * IntegrationGCP ) GetProjectID ( ) string { if i == nil || i . ProjectID == nil { return " " } return * i . ProjectID } 
func ( i * IntegrationGCP ) HasProjectID ( ) bool { if i != nil && i . ProjectID != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetAuthProviderX509CertURL ( ) string { if i == nil || i . AuthProviderX509CertURL == nil { return " " } return * i . AuthProviderX509CertURL } 
func ( i * IntegrationGCPCreateRequest ) GetAuthProviderX509CertURLOk ( ) ( string , bool ) { if i == nil || i . AuthProviderX509CertURL == nil { return " " , false } return * i . AuthProviderX509CertURL , true } 
func ( i * IntegrationGCPCreateRequest ) HasAuthProviderX509CertURL ( ) bool { if i != nil && i . AuthProviderX509CertURL != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetAuthURI ( ) string { if i == nil || i . AuthURI == nil { return " " } return * i . AuthURI } 
func ( i * IntegrationGCPCreateRequest ) GetAuthURIOk ( ) ( string , bool ) { if i == nil || i . AuthURI == nil { return " " , false } return * i . AuthURI , true } 
func ( i * IntegrationGCPCreateRequest ) HasAuthURI ( ) bool { if i != nil && i . AuthURI != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetClientEmail ( ) string { if i == nil || i . ClientEmail == nil { return " " } return * i . ClientEmail } 
func ( i * IntegrationGCPCreateRequest ) HasClientEmail ( ) bool { if i != nil && i . ClientEmail != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetClientID ( ) string { if i == nil || i . ClientID == nil { return " " } return * i . ClientID } 
func ( i * IntegrationGCPCreateRequest ) GetClientIDOk ( ) ( string , bool ) { if i == nil || i . ClientID == nil { return " " , false } return * i . ClientID , true } 
func ( i * IntegrationGCPCreateRequest ) HasClientID ( ) bool { if i != nil && i . ClientID != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetClientX509CertURL ( ) string { if i == nil || i . ClientX509CertURL == nil { return " " } return * i . ClientX509CertURL } 
func ( i * IntegrationGCPCreateRequest ) GetClientX509CertURLOk ( ) ( string , bool ) { if i == nil || i . ClientX509CertURL == nil { return " " , false } return * i . ClientX509CertURL , true } 
func ( i * IntegrationGCPCreateRequest ) HasClientX509CertURL ( ) bool { if i != nil && i . ClientX509CertURL != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetHostFilters ( ) string { if i == nil || i . HostFilters == nil { return " " } return * i . HostFilters } 
func ( i * IntegrationGCPCreateRequest ) GetHostFiltersOk ( ) ( string , bool ) { if i == nil || i . HostFilters == nil { return " " , false } return * i . HostFilters , true } 
func ( i * IntegrationGCPCreateRequest ) HasHostFilters ( ) bool { if i != nil && i . HostFilters != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetPrivateKey ( ) string { if i == nil || i . PrivateKey == nil { return " " } return * i . PrivateKey } 
func ( i * IntegrationGCPCreateRequest ) GetPrivateKeyOk ( ) ( string , bool ) { if i == nil || i . PrivateKey == nil { return " " , false } return * i . PrivateKey , true } 
func ( i * IntegrationGCPCreateRequest ) HasPrivateKey ( ) bool { if i != nil && i . PrivateKey != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetPrivateKeyID ( ) string { if i == nil || i . PrivateKeyID == nil { return " " } return * i . PrivateKeyID } 
func ( i * IntegrationGCPCreateRequest ) GetPrivateKeyIDOk ( ) ( string , bool ) { if i == nil || i . PrivateKeyID == nil { return " " , false } return * i . PrivateKeyID , true } 
func ( i * IntegrationGCPCreateRequest ) HasPrivateKeyID ( ) bool { if i != nil && i . PrivateKeyID != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetProjectID ( ) string { if i == nil || i . ProjectID == nil { return " " } return * i . ProjectID } 
func ( i * IntegrationGCPCreateRequest ) HasProjectID ( ) bool { if i != nil && i . ProjectID != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetTokenURI ( ) string { if i == nil || i . TokenURI == nil { return " " } return * i . TokenURI } 
func ( i * IntegrationGCPCreateRequest ) GetTokenURIOk ( ) ( string , bool ) { if i == nil || i . TokenURI == nil { return " " , false } return * i . TokenURI , true } 
func ( i * IntegrationGCPCreateRequest ) HasTokenURI ( ) bool { if i != nil && i . TokenURI != nil { return true } return false } 
func ( i * IntegrationGCPCreateRequest ) GetType ( ) string { if i == nil || i . Type == nil { return " " } return * i . Type } 
func ( i * IntegrationGCPCreateRequest ) HasType ( ) bool { if i != nil && i . Type != nil { return true } return false } 
func ( i * IntegrationGCPDeleteRequest ) GetClientEmail ( ) string { if i == nil || i . ClientEmail == nil { return " " } return * i . ClientEmail } 
func ( i * IntegrationGCPDeleteRequest ) GetClientEmailOk ( ) ( string , bool ) { if i == nil || i . ClientEmail == nil { return " " , false } return * i . ClientEmail , true } 
func ( i * IntegrationGCPDeleteRequest ) HasClientEmail ( ) bool { if i != nil && i . ClientEmail != nil { return true } return false } 
func ( i * IntegrationGCPDeleteRequest ) GetProjectID ( ) string { if i == nil || i . ProjectID == nil { return " " } return * i . ProjectID } 
func ( i * IntegrationGCPDeleteRequest ) HasProjectID ( ) bool { if i != nil && i . ProjectID != nil { return true } return false } 
func ( i * IntegrationGCPUpdateRequest ) GetClientEmail ( ) string { if i == nil || i . ClientEmail == nil { return " " } return * i . ClientEmail } 
func ( i * IntegrationGCPUpdateRequest ) HasClientEmail ( ) bool { if i != nil && i . ClientEmail != nil { return true } return false } 
func ( i * IntegrationGCPUpdateRequest ) GetHostFilters ( ) string { if i == nil || i . HostFilters == nil { return " " } return * i . HostFilters } 
func ( i * IntegrationGCPUpdateRequest ) HasHostFilters ( ) bool { if i != nil && i . HostFilters != nil { return true } return false } 
func ( i * IntegrationGCPUpdateRequest ) GetProjectID ( ) string { if i == nil || i . ProjectID == nil { return " " } return * i . ProjectID } 
func ( i * IntegrationGCPUpdateRequest ) GetProjectIDOk ( ) ( string , bool ) { if i == nil || i . ProjectID == nil { return " " , false } return * i . ProjectID , true } 
func ( i * IntegrationGCPUpdateRequest ) HasProjectID ( ) bool { if i != nil && i . ProjectID != nil { return true } return false } 
func ( i * integrationPD ) GetAPIToken ( ) string { if i == nil || i . APIToken == nil { return " " } return * i . APIToken } 
func ( i * integrationPD ) GetAPITokenOk ( ) ( string , bool ) { if i == nil || i . APIToken == nil { return " " , false } return * i . APIToken , true } 
func ( i * integrationPD ) HasAPIToken ( ) bool { if i != nil && i . APIToken != nil { return true } return false } 
func ( i * integrationPD ) GetSubdomain ( ) string { if i == nil || i . Subdomain == nil { return " " } return * i . Subdomain } 
func ( i * integrationPD ) GetSubdomainOk ( ) ( string , bool ) { if i == nil || i . Subdomain == nil { return " " , false } return * i . Subdomain , true } 
func ( i * integrationPD ) HasSubdomain ( ) bool { if i != nil && i . Subdomain != nil { return true } return false } 
func ( i * IntegrationPDRequest ) GetAPIToken ( ) string { if i == nil || i . APIToken == nil { return " " } return * i . APIToken } 
func ( i * IntegrationPDRequest ) HasAPIToken ( ) bool { if i != nil && i . APIToken != nil { return true } return false } 
func ( i * IntegrationPDRequest ) GetRunCheck ( ) bool { if i == nil || i . RunCheck == nil { return false } return * i . RunCheck } 
func ( i * IntegrationPDRequest ) GetRunCheckOk ( ) ( bool , bool ) { if i == nil || i . RunCheck == nil { return false , false } return * i . RunCheck , true } 
func ( i * IntegrationPDRequest ) HasRunCheck ( ) bool { if i != nil && i . RunCheck != nil { return true } return false } 
func ( i * IntegrationPDRequest ) GetSubdomain ( ) string { if i == nil || i . Subdomain == nil { return " " } return * i . Subdomain } 
func ( i * IntegrationPDRequest ) HasSubdomain ( ) bool { if i != nil && i . Subdomain != nil { return true } return false } 
func ( i * IntegrationSlackRequest ) GetRunCheck ( ) bool { if i == nil || i . RunCheck == nil { return false } return * i . RunCheck } 
func ( i * IntegrationSlackRequest ) GetRunCheckOk ( ) ( bool , bool ) { if i == nil || i . RunCheck == nil { return false , false } return * i . RunCheck , true } 
func ( i * IntegrationSlackRequest ) HasRunCheck ( ) bool { if i != nil && i . RunCheck != nil { return true } return false } 
func ( l * LogSet ) GetID ( ) json . Number { if l == nil || l . ID == nil { return " " } return * l . ID } 
func ( l * LogSet ) GetIDOk ( ) ( json . Number , bool ) { if l == nil || l . ID == nil { return " " , false } return * l . ID , true } 
func ( l * LogSet ) HasID ( ) bool { if l != nil && l . ID != nil { return true } return false } 
func ( l * LogSet ) GetName ( ) string { if l == nil || l . Name == nil { return " " } return * l . Name } 
func ( l * LogSet ) GetNameOk ( ) ( string , bool ) { if l == nil || l . Name == nil { return " " , false } return * l . Name , true } 
func ( l * LogSet ) HasName ( ) bool { if l != nil && l . Name != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetLogset ( ) string { if l == nil || l . Logset == nil { return " " } return * l . Logset } 
func ( l * LogStreamDefinition ) GetLogsetOk ( ) ( string , bool ) { if l == nil || l . Logset == nil { return " " , false } return * l . Logset , true } 
func ( l * LogStreamDefinition ) HasLogset ( ) bool { if l != nil && l . Logset != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetQuery ( ) string { if l == nil || l . Query == nil { return " " } return * l . Query } 
func ( l * LogStreamDefinition ) GetQueryOk ( ) ( string , bool ) { if l == nil || l . Query == nil { return " " , false } return * l . Query , true } 
func ( l * LogStreamDefinition ) HasQuery ( ) bool { if l != nil && l . Query != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetTime ( ) WidgetTime { if l == nil || l . Time == nil { return WidgetTime { } } return * l . Time } 
func ( l * LogStreamDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if l == nil || l . Time == nil { return WidgetTime { } , false } return * l . Time , true } 
func ( l * LogStreamDefinition ) HasTime ( ) bool { if l != nil && l . Time != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetTitle ( ) string { if l == nil || l . Title == nil { return " " } return * l . Title } 
func ( l * LogStreamDefinition ) GetTitleOk ( ) ( string , bool ) { if l == nil || l . Title == nil { return " " , false } return * l . Title , true } 
func ( l * LogStreamDefinition ) HasTitle ( ) bool { if l != nil && l . Title != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetTitleAlign ( ) string { if l == nil || l . TitleAlign == nil { return " " } return * l . TitleAlign } 
func ( l * LogStreamDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if l == nil || l . TitleAlign == nil { return " " , false } return * l . TitleAlign , true } 
func ( l * LogStreamDefinition ) HasTitleAlign ( ) bool { if l != nil && l . TitleAlign != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetTitleSize ( ) string { if l == nil || l . TitleSize == nil { return " " } return * l . TitleSize } 
func ( l * LogStreamDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if l == nil || l . TitleSize == nil { return " " , false } return * l . TitleSize , true } 
func ( l * LogStreamDefinition ) HasTitleSize ( ) bool { if l != nil && l . TitleSize != nil { return true } return false } 
func ( l * LogStreamDefinition ) GetType ( ) string { if l == nil || l . Type == nil { return " " } return * l . Type } 
func ( l * LogStreamDefinition ) GetTypeOk ( ) ( string , bool ) { if l == nil || l . Type == nil { return " " , false } return * l . Type , true } 
func ( l * LogStreamDefinition ) HasType ( ) bool { if l != nil && l . Type != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetColorPreference ( ) string { if m == nil || m . ColorPreference == nil { return " " } return * m . ColorPreference } 
func ( m * ManageStatusDefinition ) GetColorPreferenceOk ( ) ( string , bool ) { if m == nil || m . ColorPreference == nil { return " " , false } return * m . ColorPreference , true } 
func ( m * ManageStatusDefinition ) HasColorPreference ( ) bool { if m != nil && m . ColorPreference != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetCount ( ) int { if m == nil || m . Count == nil { return 0 } return * m . Count } 
func ( m * ManageStatusDefinition ) GetCountOk ( ) ( int , bool ) { if m == nil || m . Count == nil { return 0 , false } return * m . Count , true } 
func ( m * ManageStatusDefinition ) HasCount ( ) bool { if m != nil && m . Count != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetDisplayFormat ( ) string { if m == nil || m . DisplayFormat == nil { return " " } return * m . DisplayFormat } 
func ( m * ManageStatusDefinition ) GetDisplayFormatOk ( ) ( string , bool ) { if m == nil || m . DisplayFormat == nil { return " " , false } return * m . DisplayFormat , true } 
func ( m * ManageStatusDefinition ) HasDisplayFormat ( ) bool { if m != nil && m . DisplayFormat != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetHideZeroCounts ( ) bool { if m == nil || m . HideZeroCounts == nil { return false } return * m . HideZeroCounts } 
func ( m * ManageStatusDefinition ) GetHideZeroCountsOk ( ) ( bool , bool ) { if m == nil || m . HideZeroCounts == nil { return false , false } return * m . HideZeroCounts , true } 
func ( m * ManageStatusDefinition ) HasHideZeroCounts ( ) bool { if m != nil && m . HideZeroCounts != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetQuery ( ) string { if m == nil || m . Query == nil { return " " } return * m . Query } 
func ( m * ManageStatusDefinition ) GetQueryOk ( ) ( string , bool ) { if m == nil || m . Query == nil { return " " , false } return * m . Query , true } 
func ( m * ManageStatusDefinition ) HasQuery ( ) bool { if m != nil && m . Query != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetSort ( ) string { if m == nil || m . Sort == nil { return " " } return * m . Sort } 
func ( m * ManageStatusDefinition ) GetSortOk ( ) ( string , bool ) { if m == nil || m . Sort == nil { return " " , false } return * m . Sort , true } 
func ( m * ManageStatusDefinition ) HasSort ( ) bool { if m != nil && m . Sort != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetStart ( ) int { if m == nil || m . Start == nil { return 0 } return * m . Start } 
func ( m * ManageStatusDefinition ) GetStartOk ( ) ( int , bool ) { if m == nil || m . Start == nil { return 0 , false } return * m . Start , true } 
func ( m * ManageStatusDefinition ) HasStart ( ) bool { if m != nil && m . Start != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetTitle ( ) string { if m == nil || m . Title == nil { return " " } return * m . Title } 
func ( m * ManageStatusDefinition ) GetTitleOk ( ) ( string , bool ) { if m == nil || m . Title == nil { return " " , false } return * m . Title , true } 
func ( m * ManageStatusDefinition ) HasTitle ( ) bool { if m != nil && m . Title != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetTitleAlign ( ) string { if m == nil || m . TitleAlign == nil { return " " } return * m . TitleAlign } 
func ( m * ManageStatusDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if m == nil || m . TitleAlign == nil { return " " , false } return * m . TitleAlign , true } 
func ( m * ManageStatusDefinition ) HasTitleAlign ( ) bool { if m != nil && m . TitleAlign != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetTitleSize ( ) string { if m == nil || m . TitleSize == nil { return " " } return * m . TitleSize } 
func ( m * ManageStatusDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if m == nil || m . TitleSize == nil { return " " , false } return * m . TitleSize , true } 
func ( m * ManageStatusDefinition ) HasTitleSize ( ) bool { if m != nil && m . TitleSize != nil { return true } return false } 
func ( m * ManageStatusDefinition ) GetType ( ) string { if m == nil || m . Type == nil { return " " } return * m . Type } 
func ( m * ManageStatusDefinition ) GetTypeOk ( ) ( string , bool ) { if m == nil || m . Type == nil { return " " , false } return * m . Type , true } 
func ( m * ManageStatusDefinition ) HasType ( ) bool { if m != nil && m . Type != nil { return true } return false } 
func ( m * Metric ) GetHost ( ) string { if m == nil || m . Host == nil { return " " } return * m . Host } 
func ( m * Metric ) GetHostOk ( ) ( string , bool ) { if m == nil || m . Host == nil { return " " , false } return * m . Host , true } 
func ( m * Metric ) HasHost ( ) bool { if m != nil && m . Host != nil { return true } return false } 
func ( m * Metric ) GetMetric ( ) string { if m == nil || m . Metric == nil { return " " } return * m . Metric } 
func ( m * Metric ) GetMetricOk ( ) ( string , bool ) { if m == nil || m . Metric == nil { return " " , false } return * m . Metric , true } 
func ( m * Metric ) HasMetric ( ) bool { if m != nil && m . Metric != nil { return true } return false } 
func ( m * Metric ) GetType ( ) string { if m == nil || m . Type == nil { return " " } return * m . Type } 
func ( m * Metric ) HasType ( ) bool { if m != nil && m . Type != nil { return true } return false } 
func ( m * Metric ) GetUnit ( ) string { if m == nil || m . Unit == nil { return " " } return * m . Unit } 
func ( m * Metric ) HasUnit ( ) bool { if m != nil && m . Unit != nil { return true } return false } 
func ( m * MetricMetadata ) GetDescription ( ) string { if m == nil || m . Description == nil { return " " } return * m . Description } 
func ( m * MetricMetadata ) GetDescriptionOk ( ) ( string , bool ) { if m == nil || m . Description == nil { return " " , false } return * m . Description , true } 
func ( m * MetricMetadata ) HasDescription ( ) bool { if m != nil && m . Description != nil { return true } return false } 
func ( m * MetricMetadata ) GetPerUnit ( ) string { if m == nil || m . PerUnit == nil { return " " } return * m . PerUnit } 
func ( m * MetricMetadata ) GetPerUnitOk ( ) ( string , bool ) { if m == nil || m . PerUnit == nil { return " " , false } return * m . PerUnit , true } 
func ( m * MetricMetadata ) HasPerUnit ( ) bool { if m != nil && m . PerUnit != nil { return true } return false } 
func ( m * MetricMetadata ) GetShortName ( ) string { if m == nil || m . ShortName == nil { return " " } return * m . ShortName } 
func ( m * MetricMetadata ) GetShortNameOk ( ) ( string , bool ) { if m == nil || m . ShortName == nil { return " " , false } return * m . ShortName , true } 
func ( m * MetricMetadata ) HasShortName ( ) bool { if m != nil && m . ShortName != nil { return true } return false } 
func ( m * MetricMetadata ) GetStatsdInterval ( ) int { if m == nil || m . StatsdInterval == nil { return 0 } return * m . StatsdInterval } 
func ( m * MetricMetadata ) GetStatsdIntervalOk ( ) ( int , bool ) { if m == nil || m . StatsdInterval == nil { return 0 , false } return * m . StatsdInterval , true } 
func ( m * MetricMetadata ) HasStatsdInterval ( ) bool { if m != nil && m . StatsdInterval != nil { return true } return false } 
func ( m * MetricMetadata ) GetType ( ) string { if m == nil || m . Type == nil { return " " } return * m . Type } 
func ( m * MetricMetadata ) HasType ( ) bool { if m != nil && m . Type != nil { return true } return false } 
func ( m * MetricMetadata ) GetUnit ( ) string { if m == nil || m . Unit == nil { return " " } return * m . Unit } 
func ( m * MetricMetadata ) GetUnitOk ( ) ( string , bool ) { if m == nil || m . Unit == nil { return " " , false } return * m . Unit , true } 
func ( m * MetricMetadata ) HasUnit ( ) bool { if m != nil && m . Unit != nil { return true } return false } 
func ( m * Monitor ) GetCreator ( ) Creator { if m == nil || m . Creator == nil { return Creator { } } return * m . Creator } 
func ( m * Monitor ) GetCreatorOk ( ) ( Creator , bool ) { if m == nil || m . Creator == nil { return Creator { } , false } return * m . Creator , true } 
func ( m * Monitor ) HasCreator ( ) bool { if m != nil && m . Creator != nil { return true } return false } 
func ( m * Monitor ) GetId ( ) int { if m == nil || m . Id == nil { return 0 } return * m . Id } 
func ( m * Monitor ) GetIdOk ( ) ( int , bool ) { if m == nil || m . Id == nil { return 0 , false } return * m . Id , true } 
func ( m * Monitor ) HasId ( ) bool { if m != nil && m . Id != nil { return true } return false } 
func ( m * Monitor ) GetMessage ( ) string { if m == nil || m . Message == nil { return " " } return * m . Message } 
func ( m * Monitor ) GetMessageOk ( ) ( string , bool ) { if m == nil || m . Message == nil { return " " , false } return * m . Message , true } 
func ( m * Monitor ) HasMessage ( ) bool { if m != nil && m . Message != nil { return true } return false } 
func ( m * Monitor ) GetName ( ) string { if m == nil || m . Name == nil { return " " } return * m . Name } 
func ( m * Monitor ) GetNameOk ( ) ( string , bool ) { if m == nil || m . Name == nil { return " " , false } return * m . Name , true } 
func ( m * Monitor ) HasName ( ) bool { if m != nil && m . Name != nil { return true } return false } 
func ( m * Monitor ) GetOptions ( ) Options { if m == nil || m . Options == nil { return Options { } } return * m . Options } 
func ( m * Monitor ) GetOptionsOk ( ) ( Options , bool ) { if m == nil || m . Options == nil { return Options { } , false } return * m . Options , true } 
func ( m * Monitor ) HasOptions ( ) bool { if m != nil && m . Options != nil { return true } return false } 
func ( m * Monitor ) GetOverallState ( ) string { if m == nil || m . OverallState == nil { return " " } return * m . OverallState } 
func ( m * Monitor ) GetOverallStateOk ( ) ( string , bool ) { if m == nil || m . OverallState == nil { return " " , false } return * m . OverallState , true } 
func ( m * Monitor ) HasOverallState ( ) bool { if m != nil && m . OverallState != nil { return true } return false } 
func ( m * Monitor ) GetOverallStateModified ( ) string { if m == nil || m . OverallStateModified == nil { return " " } return * m . OverallStateModified } 
func ( m * Monitor ) GetOverallStateModifiedOk ( ) ( string , bool ) { if m == nil || m . OverallStateModified == nil { return " " , false } return * m . OverallStateModified , true } 
func ( m * Monitor ) HasOverallStateModified ( ) bool { if m != nil && m . OverallStateModified != nil { return true } return false } 
func ( m * Monitor ) GetQuery ( ) string { if m == nil || m . Query == nil { return " " } return * m . Query } 
func ( m * Monitor ) HasQuery ( ) bool { if m != nil && m . Query != nil { return true } return false } 
func ( m * Monitor ) GetType ( ) string { if m == nil || m . Type == nil { return " " } return * m . Type } 
func ( m * Monitor ) HasType ( ) bool { if m != nil && m . Type != nil { return true } return false } 
func ( n * NoteDefinition ) GetBackgroundColor ( ) string { if n == nil || n . BackgroundColor == nil { return " " } return * n . BackgroundColor } 
func ( n * NoteDefinition ) GetBackgroundColorOk ( ) ( string , bool ) { if n == nil || n . BackgroundColor == nil { return " " , false } return * n . BackgroundColor , true } 
func ( n * NoteDefinition ) HasBackgroundColor ( ) bool { if n != nil && n . BackgroundColor != nil { return true } return false } 
func ( n * NoteDefinition ) GetContent ( ) string { if n == nil || n . Content == nil { return " " } return * n . Content } 
func ( n * NoteDefinition ) GetContentOk ( ) ( string , bool ) { if n == nil || n . Content == nil { return " " , false } return * n . Content , true } 
func ( n * NoteDefinition ) HasContent ( ) bool { if n != nil && n . Content != nil { return true } return false } 
func ( n * NoteDefinition ) GetFontSize ( ) string { if n == nil || n . FontSize == nil { return " " } return * n . FontSize } 
func ( n * NoteDefinition ) GetFontSizeOk ( ) ( string , bool ) { if n == nil || n . FontSize == nil { return " " , false } return * n . FontSize , true } 
func ( n * NoteDefinition ) HasFontSize ( ) bool { if n != nil && n . FontSize != nil { return true } return false } 
func ( n * NoteDefinition ) GetShowTick ( ) bool { if n == nil || n . ShowTick == nil { return false } return * n . ShowTick } 
func ( n * NoteDefinition ) GetShowTickOk ( ) ( bool , bool ) { if n == nil || n . ShowTick == nil { return false , false } return * n . ShowTick , true } 
func ( n * NoteDefinition ) HasShowTick ( ) bool { if n != nil && n . ShowTick != nil { return true } return false } 
func ( n * NoteDefinition ) GetTextAlign ( ) string { if n == nil || n . TextAlign == nil { return " " } return * n . TextAlign } 
func ( n * NoteDefinition ) GetTextAlignOk ( ) ( string , bool ) { if n == nil || n . TextAlign == nil { return " " , false } return * n . TextAlign , true } 
func ( n * NoteDefinition ) HasTextAlign ( ) bool { if n != nil && n . TextAlign != nil { return true } return false } 
func ( n * NoteDefinition ) GetTickEdge ( ) string { if n == nil || n . TickEdge == nil { return " " } return * n . TickEdge } 
func ( n * NoteDefinition ) GetTickEdgeOk ( ) ( string , bool ) { if n == nil || n . TickEdge == nil { return " " , false } return * n . TickEdge , true } 
func ( n * NoteDefinition ) HasTickEdge ( ) bool { if n != nil && n . TickEdge != nil { return true } return false } 
func ( n * NoteDefinition ) GetTickPos ( ) string { if n == nil || n . TickPos == nil { return " " } return * n . TickPos } 
func ( n * NoteDefinition ) GetTickPosOk ( ) ( string , bool ) { if n == nil || n . TickPos == nil { return " " , false } return * n . TickPos , true } 
func ( n * NoteDefinition ) HasTickPos ( ) bool { if n != nil && n . TickPos != nil { return true } return false } 
func ( n * NoteDefinition ) GetType ( ) string { if n == nil || n . Type == nil { return " " } return * n . Type } 
func ( n * NoteDefinition ) GetTypeOk ( ) ( string , bool ) { if n == nil || n . Type == nil { return " " , false } return * n . Type , true } 
func ( n * NoteDefinition ) HasType ( ) bool { if n != nil && n . Type != nil { return true } return false } 
func ( o * Options ) GetEnableLogsSample ( ) bool { if o == nil || o . EnableLogsSample == nil { return false } return * o . EnableLogsSample } 
func ( o * Options ) GetEnableLogsSampleOk ( ) ( bool , bool ) { if o == nil || o . EnableLogsSample == nil { return false , false } return * o . EnableLogsSample , true } 
func ( o * Options ) HasEnableLogsSample ( ) bool { if o != nil && o . EnableLogsSample != nil { return true } return false } 
func ( o * Options ) GetEscalationMessage ( ) string { if o == nil || o . EscalationMessage == nil { return " " } return * o . EscalationMessage } 
func ( o * Options ) GetEscalationMessageOk ( ) ( string , bool ) { if o == nil || o . EscalationMessage == nil { return " " , false } return * o . EscalationMessage , true } 
func ( o * Options ) HasEscalationMessage ( ) bool { if o != nil && o . EscalationMessage != nil { return true } return false } 
func ( o * Options ) GetEvaluationDelay ( ) int { if o == nil || o . EvaluationDelay == nil { return 0 } return * o . EvaluationDelay } 
func ( o * Options ) GetEvaluationDelayOk ( ) ( int , bool ) { if o == nil || o . EvaluationDelay == nil { return 0 , false } return * o . EvaluationDelay , true } 
func ( o * Options ) HasEvaluationDelay ( ) bool { if o != nil && o . EvaluationDelay != nil { return true } return false } 
func ( o * Options ) GetIncludeTags ( ) bool { if o == nil || o . IncludeTags == nil { return false } return * o . IncludeTags } 
func ( o * Options ) GetIncludeTagsOk ( ) ( bool , bool ) { if o == nil || o . IncludeTags == nil { return false , false } return * o . IncludeTags , true } 
func ( o * Options ) HasIncludeTags ( ) bool { if o != nil && o . IncludeTags != nil { return true } return false } 
func ( o * Options ) GetLocked ( ) bool { if o == nil || o . Locked == nil { return false } return * o . Locked } 
func ( o * Options ) GetLockedOk ( ) ( bool , bool ) { if o == nil || o . Locked == nil { return false , false } return * o . Locked , true } 
func ( o * Options ) HasLocked ( ) bool { if o != nil && o . Locked != nil { return true } return false } 
func ( o * Options ) GetNewHostDelay ( ) int { if o == nil || o . NewHostDelay == nil { return 0 } return * o . NewHostDelay } 
func ( o * Options ) GetNewHostDelayOk ( ) ( int , bool ) { if o == nil || o . NewHostDelay == nil { return 0 , false } return * o . NewHostDelay , true } 
func ( o * Options ) HasNewHostDelay ( ) bool { if o != nil && o . NewHostDelay != nil { return true } return false } 
func ( o * Options ) GetNotifyAudit ( ) bool { if o == nil || o . NotifyAudit == nil { return false } return * o . NotifyAudit } 
func ( o * Options ) GetNotifyAuditOk ( ) ( bool , bool ) { if o == nil || o . NotifyAudit == nil { return false , false } return * o . NotifyAudit , true } 
func ( o * Options ) HasNotifyAudit ( ) bool { if o != nil && o . NotifyAudit != nil { return true } return false } 
func ( o * Options ) GetNotifyNoData ( ) bool { if o == nil || o . NotifyNoData == nil { return false } return * o . NotifyNoData } 
func ( o * Options ) GetNotifyNoDataOk ( ) ( bool , bool ) { if o == nil || o . NotifyNoData == nil { return false , false } return * o . NotifyNoData , true } 
func ( o * Options ) HasNotifyNoData ( ) bool { if o != nil && o . NotifyNoData != nil { return true } return false } 
func ( o * Options ) GetQueryConfig ( ) QueryConfig { if o == nil || o . QueryConfig == nil { return QueryConfig { } } return * o . QueryConfig } 
func ( o * Options ) GetQueryConfigOk ( ) ( QueryConfig , bool ) { if o == nil || o . QueryConfig == nil { return QueryConfig { } , false } return * o . QueryConfig , true } 
func ( o * Options ) HasQueryConfig ( ) bool { if o != nil && o . QueryConfig != nil { return true } return false } 
func ( o * Options ) GetRenotifyInterval ( ) int { if o == nil || o . RenotifyInterval == nil { return 0 } return * o . RenotifyInterval } 
func ( o * Options ) GetRenotifyIntervalOk ( ) ( int , bool ) { if o == nil || o . RenotifyInterval == nil { return 0 , false } return * o . RenotifyInterval , true } 
func ( o * Options ) HasRenotifyInterval ( ) bool { if o != nil && o . RenotifyInterval != nil { return true } return false } 
func ( o * Options ) GetRequireFullWindow ( ) bool { if o == nil || o . RequireFullWindow == nil { return false } return * o . RequireFullWindow } 
func ( o * Options ) GetRequireFullWindowOk ( ) ( bool , bool ) { if o == nil || o . RequireFullWindow == nil { return false , false } return * o . RequireFullWindow , true } 
func ( o * Options ) HasRequireFullWindow ( ) bool { if o != nil && o . RequireFullWindow != nil { return true } return false } 
func ( o * Options ) GetThresholds ( ) ThresholdCount { if o == nil || o . Thresholds == nil { return ThresholdCount { } } return * o . Thresholds } 
func ( o * Options ) GetThresholdsOk ( ) ( ThresholdCount , bool ) { if o == nil || o . Thresholds == nil { return ThresholdCount { } , false } return * o . Thresholds , true } 
func ( o * Options ) HasThresholds ( ) bool { if o != nil && o . Thresholds != nil { return true } return false } 
func ( o * Options ) GetThresholdWindows ( ) ThresholdWindows { if o == nil || o . ThresholdWindows == nil { return ThresholdWindows { } } return * o . ThresholdWindows } 
func ( o * Options ) GetThresholdWindowsOk ( ) ( ThresholdWindows , bool ) { if o == nil || o . ThresholdWindows == nil { return ThresholdWindows { } , false } return * o . ThresholdWindows , true } 
func ( o * Options ) HasThresholdWindows ( ) bool { if o != nil && o . ThresholdWindows != nil { return true } return false } 
func ( o * Options ) GetTimeoutH ( ) int { if o == nil || o . TimeoutH == nil { return 0 } return * o . TimeoutH } 
func ( o * Options ) GetTimeoutHOk ( ) ( int , bool ) { if o == nil || o . TimeoutH == nil { return 0 , false } return * o . TimeoutH , true } 
func ( o * Options ) HasTimeoutH ( ) bool { if o != nil && o . TimeoutH != nil { return true } return false } 
func ( p * Params ) GetCount ( ) string { if p == nil || p . Count == nil { return " " } return * p . Count } 
func ( p * Params ) GetCountOk ( ) ( string , bool ) { if p == nil || p . Count == nil { return " " , false } return * p . Count , true } 
func ( p * Params ) HasCount ( ) bool { if p != nil && p . Count != nil { return true } return false } 
func ( p * Params ) GetSort ( ) string { if p == nil || p . Sort == nil { return " " } return * p . Sort } 
func ( p * Params ) GetSortOk ( ) ( string , bool ) { if p == nil || p . Sort == nil { return " " , false } return * p . Sort , true } 
func ( p * Params ) HasSort ( ) bool { if p != nil && p . Sort != nil { return true } return false } 
func ( p * Params ) GetStart ( ) string { if p == nil || p . Start == nil { return " " } return * p . Start } 
func ( p * Params ) GetStartOk ( ) ( string , bool ) { if p == nil || p . Start == nil { return " " , false } return * p . Start , true } 
func ( p * Params ) HasStart ( ) bool { if p != nil && p . Start != nil { return true } return false } 
func ( p * Params ) GetText ( ) string { if p == nil || p . Text == nil { return " " } return * p . Text } 
func ( p * Params ) HasText ( ) bool { if p != nil && p . Text != nil { return true } return false } 
func ( p * Period ) GetName ( ) string { if p == nil || p . Name == nil { return " " } return * p . Name } 
func ( p * Period ) GetNameOk ( ) ( string , bool ) { if p == nil || p . Name == nil { return " " , false } return * p . Name , true } 
func ( p * Period ) HasName ( ) bool { if p != nil && p . Name != nil { return true } return false } 
func ( p * Period ) GetSeconds ( ) json . Number { if p == nil || p . Seconds == nil { return " " } return * p . Seconds } 
func ( p * Period ) GetSecondsOk ( ) ( json . Number , bool ) { if p == nil || p . Seconds == nil { return " " , false } return * p . Seconds , true } 
func ( p * Period ) HasSeconds ( ) bool { if p != nil && p . Seconds != nil { return true } return false } 
func ( p * Period ) GetText ( ) string { if p == nil || p . Text == nil { return " " } return * p . Text } 
func ( p * Period ) GetTextOk ( ) ( string , bool ) { if p == nil || p . Text == nil { return " " , false } return * p . Text , true } 
func ( p * Period ) HasText ( ) bool { if p != nil && p . Text != nil { return true } return false } 
func ( p * Period ) GetUnit ( ) string { if p == nil || p . Unit == nil { return " " } return * p . Unit } 
func ( p * Period ) GetUnitOk ( ) ( string , bool ) { if p == nil || p . Unit == nil { return " " , false } return * p . Unit , true } 
func ( p * Period ) HasUnit ( ) bool { if p != nil && p . Unit != nil { return true } return false } 
func ( p * Period ) GetValue ( ) string { if p == nil || p . Value == nil { return " " } return * p . Value } 
func ( p * Period ) GetValueOk ( ) ( string , bool ) { if p == nil || p . Value == nil { return " " , false } return * p . Value , true } 
func ( p * Period ) HasValue ( ) bool { if p != nil && p . Value != nil { return true } return false } 
func ( q * QueryConfig ) GetLogSet ( ) LogSet { if q == nil || q . LogSet == nil { return LogSet { } } return * q . LogSet } 
func ( q * QueryConfig ) GetLogSetOk ( ) ( LogSet , bool ) { if q == nil || q . LogSet == nil { return LogSet { } , false } return * q . LogSet , true } 
func ( q * QueryConfig ) HasLogSet ( ) bool { if q != nil && q . LogSet != nil { return true } return false } 
func ( q * QueryConfig ) GetQueryIsFailed ( ) bool { if q == nil || q . QueryIsFailed == nil { return false } return * q . QueryIsFailed } 
func ( q * QueryConfig ) GetQueryIsFailedOk ( ) ( bool , bool ) { if q == nil || q . QueryIsFailed == nil { return false , false } return * q . QueryIsFailed , true } 
func ( q * QueryConfig ) HasQueryIsFailed ( ) bool { if q != nil && q . QueryIsFailed != nil { return true } return false } 
func ( q * QueryConfig ) GetQueryString ( ) string { if q == nil || q . QueryString == nil { return " " } return * q . QueryString } 
func ( q * QueryConfig ) GetQueryStringOk ( ) ( string , bool ) { if q == nil || q . QueryString == nil { return " " , false } return * q . QueryString , true } 
func ( q * QueryConfig ) HasQueryString ( ) bool { if q != nil && q . QueryString != nil { return true } return false } 
func ( q * QueryConfig ) GetTimeRange ( ) TimeRange { if q == nil || q . TimeRange == nil { return TimeRange { } } return * q . TimeRange } 
func ( q * QueryConfig ) GetTimeRangeOk ( ) ( TimeRange , bool ) { if q == nil || q . TimeRange == nil { return TimeRange { } , false } return * q . TimeRange , true } 
func ( q * QueryConfig ) HasTimeRange ( ) bool { if q != nil && q . TimeRange != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetAutoscale ( ) bool { if q == nil || q . Autoscale == nil { return false } return * q . Autoscale } 
func ( q * QueryValueDefinition ) GetAutoscaleOk ( ) ( bool , bool ) { if q == nil || q . Autoscale == nil { return false , false } return * q . Autoscale , true } 
func ( q * QueryValueDefinition ) HasAutoscale ( ) bool { if q != nil && q . Autoscale != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetCustomUnit ( ) string { if q == nil || q . CustomUnit == nil { return " " } return * q . CustomUnit } 
func ( q * QueryValueDefinition ) GetCustomUnitOk ( ) ( string , bool ) { if q == nil || q . CustomUnit == nil { return " " , false } return * q . CustomUnit , true } 
func ( q * QueryValueDefinition ) HasCustomUnit ( ) bool { if q != nil && q . CustomUnit != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetPrecision ( ) int { if q == nil || q . Precision == nil { return 0 } return * q . Precision } 
func ( q * QueryValueDefinition ) GetPrecisionOk ( ) ( int , bool ) { if q == nil || q . Precision == nil { return 0 , false } return * q . Precision , true } 
func ( q * QueryValueDefinition ) HasPrecision ( ) bool { if q != nil && q . Precision != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetTextAlign ( ) string { if q == nil || q . TextAlign == nil { return " " } return * q . TextAlign } 
func ( q * QueryValueDefinition ) GetTextAlignOk ( ) ( string , bool ) { if q == nil || q . TextAlign == nil { return " " , false } return * q . TextAlign , true } 
func ( q * QueryValueDefinition ) HasTextAlign ( ) bool { if q != nil && q . TextAlign != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetTime ( ) WidgetTime { if q == nil || q . Time == nil { return WidgetTime { } } return * q . Time } 
func ( q * QueryValueDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if q == nil || q . Time == nil { return WidgetTime { } , false } return * q . Time , true } 
func ( q * QueryValueDefinition ) HasTime ( ) bool { if q != nil && q . Time != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetTitle ( ) string { if q == nil || q . Title == nil { return " " } return * q . Title } 
func ( q * QueryValueDefinition ) GetTitleOk ( ) ( string , bool ) { if q == nil || q . Title == nil { return " " , false } return * q . Title , true } 
func ( q * QueryValueDefinition ) HasTitle ( ) bool { if q != nil && q . Title != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetTitleAlign ( ) string { if q == nil || q . TitleAlign == nil { return " " } return * q . TitleAlign } 
func ( q * QueryValueDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if q == nil || q . TitleAlign == nil { return " " , false } return * q . TitleAlign , true } 
func ( q * QueryValueDefinition ) HasTitleAlign ( ) bool { if q != nil && q . TitleAlign != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetTitleSize ( ) string { if q == nil || q . TitleSize == nil { return " " } return * q . TitleSize } 
func ( q * QueryValueDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if q == nil || q . TitleSize == nil { return " " , false } return * q . TitleSize , true } 
func ( q * QueryValueDefinition ) HasTitleSize ( ) bool { if q != nil && q . TitleSize != nil { return true } return false } 
func ( q * QueryValueDefinition ) GetType ( ) string { if q == nil || q . Type == nil { return " " } return * q . Type } 
func ( q * QueryValueDefinition ) GetTypeOk ( ) ( string , bool ) { if q == nil || q . Type == nil { return " " , false } return * q . Type , true } 
func ( q * QueryValueDefinition ) HasType ( ) bool { if q != nil && q . Type != nil { return true } return false } 
func ( q * QueryValueRequest ) GetAggregator ( ) string { if q == nil || q . Aggregator == nil { return " " } return * q . Aggregator } 
func ( q * QueryValueRequest ) GetAggregatorOk ( ) ( string , bool ) { if q == nil || q . Aggregator == nil { return " " , false } return * q . Aggregator , true } 
func ( q * QueryValueRequest ) HasAggregator ( ) bool { if q != nil && q . Aggregator != nil { return true } return false } 
func ( q * QueryValueRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if q == nil || q . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * q . ApmQuery } 
func ( q * QueryValueRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if q == nil || q . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * q . ApmQuery , true } 
func ( q * QueryValueRequest ) HasApmQuery ( ) bool { if q != nil && q . ApmQuery != nil { return true } return false } 
func ( q * QueryValueRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if q == nil || q . LogQuery == nil { return WidgetApmOrLogQuery { } } return * q . LogQuery } 
func ( q * QueryValueRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if q == nil || q . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * q . LogQuery , true } 
func ( q * QueryValueRequest ) HasLogQuery ( ) bool { if q != nil && q . LogQuery != nil { return true } return false } 
func ( q * QueryValueRequest ) GetMetricQuery ( ) string { if q == nil || q . MetricQuery == nil { return " " } return * q . MetricQuery } 
func ( q * QueryValueRequest ) GetMetricQueryOk ( ) ( string , bool ) { if q == nil || q . MetricQuery == nil { return " " , false } return * q . MetricQuery , true } 
func ( q * QueryValueRequest ) HasMetricQuery ( ) bool { if q != nil && q . MetricQuery != nil { return true } return false } 
func ( q * QueryValueRequest ) GetProcessQuery ( ) WidgetProcessQuery { if q == nil || q . ProcessQuery == nil { return WidgetProcessQuery { } } return * q . ProcessQuery } 
func ( q * QueryValueRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if q == nil || q . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * q . ProcessQuery , true } 
func ( q * QueryValueRequest ) HasProcessQuery ( ) bool { if q != nil && q . ProcessQuery != nil { return true } return false } 
func ( r * Recurrence ) GetPeriod ( ) int { if r == nil || r . Period == nil { return 0 } return * r . Period } 
func ( r * Recurrence ) GetPeriodOk ( ) ( int , bool ) { if r == nil || r . Period == nil { return 0 , false } return * r . Period , true } 
func ( r * Recurrence ) HasPeriod ( ) bool { if r != nil && r . Period != nil { return true } return false } 
func ( r * Recurrence ) GetType ( ) string { if r == nil || r . Type == nil { return " " } return * r . Type } 
func ( r * Recurrence ) GetTypeOk ( ) ( string , bool ) { if r == nil || r . Type == nil { return " " , false } return * r . Type , true } 
func ( r * Recurrence ) HasType ( ) bool { if r != nil && r . Type != nil { return true } return false } 
func ( r * Recurrence ) GetUntilDate ( ) int { if r == nil || r . UntilDate == nil { return 0 } return * r . UntilDate } 
func ( r * Recurrence ) GetUntilDateOk ( ) ( int , bool ) { if r == nil || r . UntilDate == nil { return 0 , false } return * r . UntilDate , true } 
func ( r * Recurrence ) HasUntilDate ( ) bool { if r != nil && r . UntilDate != nil { return true } return false } 
func ( r * Recurrence ) GetUntilOccurrences ( ) int { if r == nil || r . UntilOccurrences == nil { return 0 } return * r . UntilOccurrences } 
func ( r * Recurrence ) GetUntilOccurrencesOk ( ) ( int , bool ) { if r == nil || r . UntilOccurrences == nil { return 0 , false } return * r . UntilOccurrences , true } 
func ( r * Recurrence ) HasUntilOccurrences ( ) bool { if r != nil && r . UntilOccurrences != nil { return true } return false } 
func ( r * reqAPIKey ) GetAPIKey ( ) APIKey { if r == nil || r . APIKey == nil { return APIKey { } } return * r . APIKey } 
func ( r * reqAPIKey ) GetAPIKeyOk ( ) ( APIKey , bool ) { if r == nil || r . APIKey == nil { return APIKey { } , false } return * r . APIKey , true } 
func ( r * reqAPIKey ) HasAPIKey ( ) bool { if r != nil && r . APIKey != nil { return true } return false } 
func ( r * reqComment ) GetComment ( ) Comment { if r == nil || r . Comment == nil { return Comment { } } return * r . Comment } 
func ( r * reqComment ) GetCommentOk ( ) ( Comment , bool ) { if r == nil || r . Comment == nil { return Comment { } , false } return * r . Comment , true } 
func ( r * reqComment ) HasComment ( ) bool { if r != nil && r . Comment != nil { return true } return false } 
func ( r * reqGetDashboard ) GetDashboard ( ) Dashboard { if r == nil || r . Dashboard == nil { return Dashboard { } } return * r . Dashboard } 
func ( r * reqGetDashboard ) GetDashboardOk ( ) ( Dashboard , bool ) { if r == nil || r . Dashboard == nil { return Dashboard { } , false } return * r . Dashboard , true } 
func ( r * reqGetDashboard ) HasDashboard ( ) bool { if r != nil && r . Dashboard != nil { return true } return false } 
func ( r * reqGetDashboard ) GetResource ( ) string { if r == nil || r . Resource == nil { return " " } return * r . Resource } 
func ( r * reqGetDashboard ) GetResourceOk ( ) ( string , bool ) { if r == nil || r . Resource == nil { return " " , false } return * r . Resource , true } 
func ( r * reqGetDashboard ) HasResource ( ) bool { if r != nil && r . Resource != nil { return true } return false } 
func ( r * reqGetDashboard ) GetUrl ( ) string { if r == nil || r . Url == nil { return " " } return * r . Url } 
func ( r * reqGetDashboard ) GetUrlOk ( ) ( string , bool ) { if r == nil || r . Url == nil { return " " , false } return * r . Url , true } 
func ( r * reqGetDashboard ) HasUrl ( ) bool { if r != nil && r . Url != nil { return true } return false } 
func ( r * reqGetEvent ) GetEvent ( ) Event { if r == nil || r . Event == nil { return Event { } } return * r . Event } 
func ( r * reqGetEvent ) GetEventOk ( ) ( Event , bool ) { if r == nil || r . Event == nil { return Event { } , false } return * r . Event , true } 
func ( r * reqGetEvent ) HasEvent ( ) bool { if r != nil && r . Event != nil { return true } return false } 
func ( r * reqGetTags ) GetTags ( ) TagMap { if r == nil || r . Tags == nil { return TagMap { } } return * r . Tags } 
func ( r * reqGetTags ) GetTagsOk ( ) ( TagMap , bool ) { if r == nil || r . Tags == nil { return TagMap { } , false } return * r . Tags , true } 
func ( r * reqGetTags ) HasTags ( ) bool { if r != nil && r . Tags != nil { return true } return false } 
func ( r * Rule ) GetColor ( ) string { if r == nil || r . Color == nil { return " " } return * r . Color } 
func ( r * Rule ) GetColorOk ( ) ( string , bool ) { if r == nil || r . Color == nil { return " " , false } return * r . Color , true } 
func ( r * Rule ) HasColor ( ) bool { if r != nil && r . Color != nil { return true } return false } 
func ( r * Rule ) GetThreshold ( ) json . Number { if r == nil || r . Threshold == nil { return " " } return * r . Threshold } 
func ( r * Rule ) GetThresholdOk ( ) ( json . Number , bool ) { if r == nil || r . Threshold == nil { return " " , false } return * r . Threshold , true } 
func ( r * Rule ) HasThreshold ( ) bool { if r != nil && r . Threshold != nil { return true } return false } 
func ( r * Rule ) GetTimeframe ( ) string { if r == nil || r . Timeframe == nil { return " " } return * r . Timeframe } 
func ( r * Rule ) GetTimeframeOk ( ) ( string , bool ) { if r == nil || r . Timeframe == nil { return " " , false } return * r . Timeframe , true } 
func ( r * Rule ) HasTimeframe ( ) bool { if r != nil && r . Timeframe != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetRequests ( ) ScatterplotRequests { if s == nil || s . Requests == nil { return ScatterplotRequests { } } return * s . Requests } 
func ( s * ScatterplotDefinition ) GetRequestsOk ( ) ( ScatterplotRequests , bool ) { if s == nil || s . Requests == nil { return ScatterplotRequests { } , false } return * s . Requests , true } 
func ( s * ScatterplotDefinition ) HasRequests ( ) bool { if s != nil && s . Requests != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetTime ( ) WidgetTime { if s == nil || s . Time == nil { return WidgetTime { } } return * s . Time } 
func ( s * ScatterplotDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if s == nil || s . Time == nil { return WidgetTime { } , false } return * s . Time , true } 
func ( s * ScatterplotDefinition ) HasTime ( ) bool { if s != nil && s . Time != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetTitle ( ) string { if s == nil || s . Title == nil { return " " } return * s . Title } 
func ( s * ScatterplotDefinition ) HasTitle ( ) bool { if s != nil && s . Title != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetTitleAlign ( ) string { if s == nil || s . TitleAlign == nil { return " " } return * s . TitleAlign } 
func ( s * ScatterplotDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if s == nil || s . TitleAlign == nil { return " " , false } return * s . TitleAlign , true } 
func ( s * ScatterplotDefinition ) HasTitleAlign ( ) bool { if s != nil && s . TitleAlign != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetTitleSize ( ) string { if s == nil || s . TitleSize == nil { return " " } return * s . TitleSize } 
func ( s * ScatterplotDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if s == nil || s . TitleSize == nil { return " " , false } return * s . TitleSize , true } 
func ( s * ScatterplotDefinition ) HasTitleSize ( ) bool { if s != nil && s . TitleSize != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetType ( ) string { if s == nil || s . Type == nil { return " " } return * s . Type } 
func ( s * ScatterplotDefinition ) GetTypeOk ( ) ( string , bool ) { if s == nil || s . Type == nil { return " " , false } return * s . Type , true } 
func ( s * ScatterplotDefinition ) HasType ( ) bool { if s != nil && s . Type != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetXaxis ( ) WidgetAxis { if s == nil || s . Xaxis == nil { return WidgetAxis { } } return * s . Xaxis } 
func ( s * ScatterplotDefinition ) GetXaxisOk ( ) ( WidgetAxis , bool ) { if s == nil || s . Xaxis == nil { return WidgetAxis { } , false } return * s . Xaxis , true } 
func ( s * ScatterplotDefinition ) HasXaxis ( ) bool { if s != nil && s . Xaxis != nil { return true } return false } 
func ( s * ScatterplotDefinition ) GetYaxis ( ) WidgetAxis { if s == nil || s . Yaxis == nil { return WidgetAxis { } } return * s . Yaxis } 
func ( s * ScatterplotDefinition ) GetYaxisOk ( ) ( WidgetAxis , bool ) { if s == nil || s . Yaxis == nil { return WidgetAxis { } , false } return * s . Yaxis , true } 
func ( s * ScatterplotDefinition ) HasYaxis ( ) bool { if s != nil && s . Yaxis != nil { return true } return false } 
func ( s * ScatterplotRequest ) GetAggregator ( ) string { if s == nil || s . Aggregator == nil { return " " } return * s . Aggregator } 
func ( s * ScatterplotRequest ) GetAggregatorOk ( ) ( string , bool ) { if s == nil || s . Aggregator == nil { return " " , false } return * s . Aggregator , true } 
func ( s * ScatterplotRequest ) HasAggregator ( ) bool { if s != nil && s . Aggregator != nil { return true } return false } 
func ( s * ScatterplotRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if s == nil || s . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * s . ApmQuery } 
func ( s * ScatterplotRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if s == nil || s . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * s . ApmQuery , true } 
func ( s * ScatterplotRequest ) HasApmQuery ( ) bool { if s != nil && s . ApmQuery != nil { return true } return false } 
func ( s * ScatterplotRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if s == nil || s . LogQuery == nil { return WidgetApmOrLogQuery { } } return * s . LogQuery } 
func ( s * ScatterplotRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if s == nil || s . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * s . LogQuery , true } 
func ( s * ScatterplotRequest ) HasLogQuery ( ) bool { if s != nil && s . LogQuery != nil { return true } return false } 
func ( s * ScatterplotRequest ) GetMetricQuery ( ) string { if s == nil || s . MetricQuery == nil { return " " } return * s . MetricQuery } 
func ( s * ScatterplotRequest ) GetMetricQueryOk ( ) ( string , bool ) { if s == nil || s . MetricQuery == nil { return " " , false } return * s . MetricQuery , true } 
func ( s * ScatterplotRequest ) HasMetricQuery ( ) bool { if s != nil && s . MetricQuery != nil { return true } return false } 
func ( s * ScatterplotRequest ) GetProcessQuery ( ) WidgetProcessQuery { if s == nil || s . ProcessQuery == nil { return WidgetProcessQuery { } } return * s . ProcessQuery } 
func ( s * ScatterplotRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if s == nil || s . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * s . ProcessQuery , true } 
func ( s * ScatterplotRequest ) HasProcessQuery ( ) bool { if s != nil && s . ProcessQuery != nil { return true } return false } 
func ( s * ScatterplotRequests ) GetX ( ) ScatterplotRequest { if s == nil || s . X == nil { return ScatterplotRequest { } } return * s . X } 
func ( s * ScatterplotRequests ) GetXOk ( ) ( ScatterplotRequest , bool ) { if s == nil || s . X == nil { return ScatterplotRequest { } , false } return * s . X , true } 
func ( s * ScatterplotRequests ) HasX ( ) bool { if s != nil && s . X != nil { return true } return false } 
func ( s * ScatterplotRequests ) GetY ( ) ScatterplotRequest { if s == nil || s . Y == nil { return ScatterplotRequest { } } return * s . Y } 
func ( s * ScatterplotRequests ) GetYOk ( ) ( ScatterplotRequest , bool ) { if s == nil || s . Y == nil { return ScatterplotRequest { } , false } return * s . Y , true } 
func ( s * ScatterplotRequests ) HasY ( ) bool { if s != nil && s . Y != nil { return true } return false } 
func ( s * Screenboard ) GetHeight ( ) int { if s == nil || s . Height == nil { return 0 } return * s . Height } 
func ( s * Screenboard ) GetHeightOk ( ) ( int , bool ) { if s == nil || s . Height == nil { return 0 , false } return * s . Height , true } 
func ( s * Screenboard ) HasHeight ( ) bool { if s != nil && s . Height != nil { return true } return false } 
func ( s * Screenboard ) GetId ( ) int { if s == nil || s . Id == nil { return 0 } return * s . Id } 
func ( s * Screenboard ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * Screenboard ) GetNewId ( ) string { if s == nil || s . NewId == nil { return " " } return * s . NewId } 
func ( s * Screenboard ) GetNewIdOk ( ) ( string , bool ) { if s == nil || s . NewId == nil { return " " , false } return * s . NewId , true } 
func ( s * Screenboard ) HasNewId ( ) bool { if s != nil && s . NewId != nil { return true } return false } 
func ( s * Screenboard ) GetReadOnly ( ) bool { if s == nil || s . ReadOnly == nil { return false } return * s . ReadOnly } 
func ( s * Screenboard ) GetReadOnlyOk ( ) ( bool , bool ) { if s == nil || s . ReadOnly == nil { return false , false } return * s . ReadOnly , true } 
func ( s * Screenboard ) HasReadOnly ( ) bool { if s != nil && s . ReadOnly != nil { return true } return false } 
func ( s * Screenboard ) GetShared ( ) bool { if s == nil || s . Shared == nil { return false } return * s . Shared } 
func ( s * Screenboard ) GetSharedOk ( ) ( bool , bool ) { if s == nil || s . Shared == nil { return false , false } return * s . Shared , true } 
func ( s * Screenboard ) HasShared ( ) bool { if s != nil && s . Shared != nil { return true } return false } 
func ( s * Screenboard ) GetTitle ( ) string { if s == nil || s . Title == nil { return " " } return * s . Title } 
func ( s * Screenboard ) GetTitleOk ( ) ( string , bool ) { if s == nil || s . Title == nil { return " " , false } return * s . Title , true } 
func ( s * Screenboard ) HasTitle ( ) bool { if s != nil && s . Title != nil { return true } return false } 
func ( s * Screenboard ) GetWidth ( ) int { if s == nil || s . Width == nil { return 0 } return * s . Width } 
func ( s * Screenboard ) GetWidthOk ( ) ( int , bool ) { if s == nil || s . Width == nil { return 0 , false } return * s . Width , true } 
func ( s * Screenboard ) HasWidth ( ) bool { if s != nil && s . Width != nil { return true } return false } 
func ( s * ScreenboardLite ) GetId ( ) int { if s == nil || s . Id == nil { return 0 } return * s . Id } 
func ( s * ScreenboardLite ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * ScreenboardLite ) GetResource ( ) string { if s == nil || s . Resource == nil { return " " } return * s . Resource } 
func ( s * ScreenboardLite ) GetResourceOk ( ) ( string , bool ) { if s == nil || s . Resource == nil { return " " , false } return * s . Resource , true } 
func ( s * ScreenboardLite ) HasResource ( ) bool { if s != nil && s . Resource != nil { return true } return false } 
func ( s * ScreenboardLite ) GetTitle ( ) string { if s == nil || s . Title == nil { return " " } return * s . Title } 
func ( s * ScreenboardLite ) HasTitle ( ) bool { if s != nil && s . Title != nil { return true } return false } 
func ( s * ScreenboardMonitor ) GetId ( ) int { if s == nil || s . Id == nil { return 0 } return * s . Id } 
func ( s * ScreenboardMonitor ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * Series ) GetAggr ( ) string { if s == nil || s . Aggr == nil { return " " } return * s . Aggr } 
func ( s * Series ) GetAggrOk ( ) ( string , bool ) { if s == nil || s . Aggr == nil { return " " , false } return * s . Aggr , true } 
func ( s * Series ) HasAggr ( ) bool { if s != nil && s . Aggr != nil { return true } return false } 
func ( s * Series ) GetDisplayName ( ) string { if s == nil || s . DisplayName == nil { return " " } return * s . DisplayName } 
func ( s * Series ) GetDisplayNameOk ( ) ( string , bool ) { if s == nil || s . DisplayName == nil { return " " , false } return * s . DisplayName , true } 
func ( s * Series ) HasDisplayName ( ) bool { if s != nil && s . DisplayName != nil { return true } return false } 
func ( s * Series ) GetEnd ( ) float64 { if s == nil || s . End == nil { return 0 } return * s . End } 
func ( s * Series ) GetEndOk ( ) ( float64 , bool ) { if s == nil || s . End == nil { return 0 , false } return * s . End , true } 
func ( s * Series ) HasEnd ( ) bool { if s != nil && s . End != nil { return true } return false } 
func ( s * Series ) GetExpression ( ) string { if s == nil || s . Expression == nil { return " " } return * s . Expression } 
func ( s * Series ) GetExpressionOk ( ) ( string , bool ) { if s == nil || s . Expression == nil { return " " , false } return * s . Expression , true } 
func ( s * Series ) HasExpression ( ) bool { if s != nil && s . Expression != nil { return true } return false } 
func ( s * Series ) GetInterval ( ) int { if s == nil || s . Interval == nil { return 0 } return * s . Interval } 
func ( s * Series ) GetIntervalOk ( ) ( int , bool ) { if s == nil || s . Interval == nil { return 0 , false } return * s . Interval , true } 
func ( s * Series ) HasInterval ( ) bool { if s != nil && s . Interval != nil { return true } return false } 
func ( s * Series ) GetLength ( ) int { if s == nil || s . Length == nil { return 0 } return * s . Length } 
func ( s * Series ) GetLengthOk ( ) ( int , bool ) { if s == nil || s . Length == nil { return 0 , false } return * s . Length , true } 
func ( s * Series ) HasLength ( ) bool { if s != nil && s . Length != nil { return true } return false } 
func ( s * Series ) GetMetric ( ) string { if s == nil || s . Metric == nil { return " " } return * s . Metric } 
func ( s * Series ) GetMetricOk ( ) ( string , bool ) { if s == nil || s . Metric == nil { return " " , false } return * s . Metric , true } 
func ( s * Series ) HasMetric ( ) bool { if s != nil && s . Metric != nil { return true } return false } 
func ( s * Series ) GetScope ( ) string { if s == nil || s . Scope == nil { return " " } return * s . Scope } 
func ( s * Series ) GetScopeOk ( ) ( string , bool ) { if s == nil || s . Scope == nil { return " " , false } return * s . Scope , true } 
func ( s * Series ) HasScope ( ) bool { if s != nil && s . Scope != nil { return true } return false } 
func ( s * Series ) GetStart ( ) float64 { if s == nil || s . Start == nil { return 0 } return * s . Start } 
func ( s * Series ) GetStartOk ( ) ( float64 , bool ) { if s == nil || s . Start == nil { return 0 , false } return * s . Start , true } 
func ( s * Series ) HasStart ( ) bool { if s != nil && s . Start != nil { return true } return false } 
func ( s * Series ) GetUnits ( ) UnitPair { if s == nil || s . Units == nil { return UnitPair { } } return * s . Units } 
func ( s * Series ) GetUnitsOk ( ) ( UnitPair , bool ) { if s == nil || s . Units == nil { return UnitPair { } , false } return * s . Units , true } 
func ( s * Series ) HasUnits ( ) bool { if s != nil && s . Units != nil { return true } return false } 
func ( s * ServiceHookSlackRequest ) GetAccount ( ) string { if s == nil || s . Account == nil { return " " } return * s . Account } 
func ( s * ServiceHookSlackRequest ) GetAccountOk ( ) ( string , bool ) { if s == nil || s . Account == nil { return " " , false } return * s . Account , true } 
func ( s * ServiceHookSlackRequest ) HasAccount ( ) bool { if s != nil && s . Account != nil { return true } return false } 
func ( s * ServiceHookSlackRequest ) GetUrl ( ) string { if s == nil || s . Url == nil { return " " } return * s . Url } 
func ( s * ServiceHookSlackRequest ) GetUrlOk ( ) ( string , bool ) { if s == nil || s . Url == nil { return " " , false } return * s . Url , true } 
func ( s * ServiceHookSlackRequest ) HasUrl ( ) bool { if s != nil && s . Url != nil { return true } return false } 
func ( s * servicePD ) GetServiceKey ( ) string { if s == nil || s . ServiceKey == nil { return " " } return * s . ServiceKey } 
func ( s * servicePD ) HasServiceKey ( ) bool { if s != nil && s . ServiceKey != nil { return true } return false } 
func ( s * servicePD ) GetServiceName ( ) string { if s == nil || s . ServiceName == nil { return " " } return * s . ServiceName } 
func ( s * servicePD ) GetServiceNameOk ( ) ( string , bool ) { if s == nil || s . ServiceName == nil { return " " , false } return * s . ServiceName , true } 
func ( s * servicePD ) HasServiceName ( ) bool { if s != nil && s . ServiceName != nil { return true } return false } 
func ( s * ServicePDRequest ) GetServiceKey ( ) string { if s == nil || s . ServiceKey == nil { return " " } return * s . ServiceKey } 
func ( s * ServicePDRequest ) GetServiceKeyOk ( ) ( string , bool ) { if s == nil || s . ServiceKey == nil { return " " , false } return * s . ServiceKey , true } 
func ( s * ServicePDRequest ) HasServiceKey ( ) bool { if s != nil && s . ServiceKey != nil { return true } return false } 
func ( s * ServicePDRequest ) GetServiceName ( ) string { if s == nil || s . ServiceName == nil { return " " } return * s . ServiceName } 
func ( s * ServicePDRequest ) HasServiceName ( ) bool { if s != nil && s . ServiceName != nil { return true } return false } 
func ( s * Style ) GetFillMax ( ) json . Number { if s == nil || s . FillMax == nil { return " " } return * s . FillMax } 
func ( s * Style ) GetFillMaxOk ( ) ( json . Number , bool ) { if s == nil || s . FillMax == nil { return " " , false } return * s . FillMax , true } 
func ( s * Style ) HasFillMax ( ) bool { if s != nil && s . FillMax != nil { return true } return false } 
func ( s * Style ) GetFillMin ( ) json . Number { if s == nil || s . FillMin == nil { return " " } return * s . FillMin } 
func ( s * Style ) GetFillMinOk ( ) ( json . Number , bool ) { if s == nil || s . FillMin == nil { return " " , false } return * s . FillMin , true } 
func ( s * Style ) HasFillMin ( ) bool { if s != nil && s . FillMin != nil { return true } return false } 
func ( s * Style ) GetPalette ( ) string { if s == nil || s . Palette == nil { return " " } return * s . Palette } 
func ( s * Style ) GetPaletteOk ( ) ( string , bool ) { if s == nil || s . Palette == nil { return " " , false } return * s . Palette , true } 
func ( s * Style ) HasPalette ( ) bool { if s != nil && s . Palette != nil { return true } return false } 
func ( s * Style ) GetPaletteFlip ( ) bool { if s == nil || s . PaletteFlip == nil { return false } return * s . PaletteFlip } 
func ( s * Style ) GetPaletteFlipOk ( ) ( bool , bool ) { if s == nil || s . PaletteFlip == nil { return false , false } return * s . PaletteFlip , true } 
func ( s * Style ) HasPaletteFlip ( ) bool { if s != nil && s . PaletteFlip != nil { return true } return false } 
func ( s * SyntheticsAssertion ) GetOperator ( ) string { if s == nil || s . Operator == nil { return " " } return * s . Operator } 
func ( s * SyntheticsAssertion ) GetOperatorOk ( ) ( string , bool ) { if s == nil || s . Operator == nil { return " " , false } return * s . Operator , true } 
func ( s * SyntheticsAssertion ) HasOperator ( ) bool { if s != nil && s . Operator != nil { return true } return false } 
func ( s * SyntheticsAssertion ) GetProperty ( ) string { if s == nil || s . Property == nil { return " " } return * s . Property } 
func ( s * SyntheticsAssertion ) GetPropertyOk ( ) ( string , bool ) { if s == nil || s . Property == nil { return " " , false } return * s . Property , true } 
func ( s * SyntheticsAssertion ) HasProperty ( ) bool { if s != nil && s . Property != nil { return true } return false } 
func ( s * SyntheticsAssertion ) GetType ( ) string { if s == nil || s . Type == nil { return " " } return * s . Type } 
func ( s * SyntheticsAssertion ) HasType ( ) bool { if s != nil && s . Type != nil { return true } return false } 
func ( s * SyntheticsConfig ) GetRequest ( ) SyntheticsRequest { if s == nil || s . Request == nil { return SyntheticsRequest { } } return * s . Request } 
func ( s * SyntheticsConfig ) GetRequestOk ( ) ( SyntheticsRequest , bool ) { if s == nil || s . Request == nil { return SyntheticsRequest { } , false } return * s . Request , true } 
func ( s * SyntheticsConfig ) HasRequest ( ) bool { if s != nil && s . Request != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetHeight ( ) int { if s == nil || s . Height == nil { return 0 } return * s . Height } 
func ( s * SyntheticsDevice ) HasHeight ( ) bool { if s != nil && s . Height != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetId ( ) string { if s == nil || s . Id == nil { return " " } return * s . Id } 
func ( s * SyntheticsDevice ) GetIdOk ( ) ( string , bool ) { if s == nil || s . Id == nil { return " " , false } return * s . Id , true } 
func ( s * SyntheticsDevice ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetIsLandscape ( ) bool { if s == nil || s . IsLandscape == nil { return false } return * s . IsLandscape } 
func ( s * SyntheticsDevice ) GetIsLandscapeOk ( ) ( bool , bool ) { if s == nil || s . IsLandscape == nil { return false , false } return * s . IsLandscape , true } 
func ( s * SyntheticsDevice ) HasIsLandscape ( ) bool { if s != nil && s . IsLandscape != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetIsMobile ( ) bool { if s == nil || s . IsMobile == nil { return false } return * s . IsMobile } 
func ( s * SyntheticsDevice ) GetIsMobileOk ( ) ( bool , bool ) { if s == nil || s . IsMobile == nil { return false , false } return * s . IsMobile , true } 
func ( s * SyntheticsDevice ) HasIsMobile ( ) bool { if s != nil && s . IsMobile != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetName ( ) string { if s == nil || s . Name == nil { return " " } return * s . Name } 
func ( s * SyntheticsDevice ) GetNameOk ( ) ( string , bool ) { if s == nil || s . Name == nil { return " " , false } return * s . Name , true } 
func ( s * SyntheticsDevice ) HasName ( ) bool { if s != nil && s . Name != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetUserAgent ( ) string { if s == nil || s . UserAgent == nil { return " " } return * s . UserAgent } 
func ( s * SyntheticsDevice ) GetUserAgentOk ( ) ( string , bool ) { if s == nil || s . UserAgent == nil { return " " , false } return * s . UserAgent , true } 
func ( s * SyntheticsDevice ) HasUserAgent ( ) bool { if s != nil && s . UserAgent != nil { return true } return false } 
func ( s * SyntheticsDevice ) GetWidth ( ) int { if s == nil || s . Width == nil { return 0 } return * s . Width } 
func ( s * SyntheticsDevice ) HasWidth ( ) bool { if s != nil && s . Width != nil { return true } return false } 
func ( s * SyntheticsLocation ) GetDisplayName ( ) string { if s == nil || s . DisplayName == nil { return " " } return * s . DisplayName } 
func ( s * SyntheticsLocation ) HasDisplayName ( ) bool { if s != nil && s . DisplayName != nil { return true } return false } 
func ( s * SyntheticsLocation ) GetId ( ) int { if s == nil || s . Id == nil { return 0 } return * s . Id } 
func ( s * SyntheticsLocation ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * SyntheticsLocation ) GetIsLandscape ( ) bool { if s == nil || s . IsLandscape == nil { return false } return * s . IsLandscape } 
func ( s * SyntheticsLocation ) GetIsLandscapeOk ( ) ( bool , bool ) { if s == nil || s . IsLandscape == nil { return false , false } return * s . IsLandscape , true } 
func ( s * SyntheticsLocation ) HasIsLandscape ( ) bool { if s != nil && s . IsLandscape != nil { return true } return false } 
func ( s * SyntheticsLocation ) GetName ( ) string { if s == nil || s . Name == nil { return " " } return * s . Name } 
func ( s * SyntheticsLocation ) HasName ( ) bool { if s != nil && s . Name != nil { return true } return false } 
func ( s * SyntheticsLocation ) GetRegion ( ) string { if s == nil || s . Region == nil { return " " } return * s . Region } 
func ( s * SyntheticsLocation ) GetRegionOk ( ) ( string , bool ) { if s == nil || s . Region == nil { return " " , false } return * s . Region , true } 
func ( s * SyntheticsLocation ) HasRegion ( ) bool { if s != nil && s . Region != nil { return true } return false } 
func ( s * SyntheticsOptions ) GetFollowRedirects ( ) bool { if s == nil || s . FollowRedirects == nil { return false } return * s . FollowRedirects } 
func ( s * SyntheticsOptions ) GetFollowRedirectsOk ( ) ( bool , bool ) { if s == nil || s . FollowRedirects == nil { return false , false } return * s . FollowRedirects , true } 
func ( s * SyntheticsOptions ) HasFollowRedirects ( ) bool { if s != nil && s . FollowRedirects != nil { return true } return false } 
func ( s * SyntheticsOptions ) GetMinFailureDuration ( ) int { if s == nil || s . MinFailureDuration == nil { return 0 } return * s . MinFailureDuration } 
func ( s * SyntheticsOptions ) GetMinFailureDurationOk ( ) ( int , bool ) { if s == nil || s . MinFailureDuration == nil { return 0 , false } return * s . MinFailureDuration , true } 
func ( s * SyntheticsOptions ) HasMinFailureDuration ( ) bool { if s != nil && s . MinFailureDuration != nil { return true } return false } 
func ( s * SyntheticsOptions ) GetMinLocationFailed ( ) int { if s == nil || s . MinLocationFailed == nil { return 0 } return * s . MinLocationFailed } 
func ( s * SyntheticsOptions ) GetMinLocationFailedOk ( ) ( int , bool ) { if s == nil || s . MinLocationFailed == nil { return 0 , false } return * s . MinLocationFailed , true } 
func ( s * SyntheticsOptions ) HasMinLocationFailed ( ) bool { if s != nil && s . MinLocationFailed != nil { return true } return false } 
func ( s * SyntheticsOptions ) GetTickEvery ( ) int { if s == nil || s . TickEvery == nil { return 0 } return * s . TickEvery } 
func ( s * SyntheticsOptions ) GetTickEveryOk ( ) ( int , bool ) { if s == nil || s . TickEvery == nil { return 0 , false } return * s . TickEvery , true } 
func ( s * SyntheticsOptions ) HasTickEvery ( ) bool { if s != nil && s . TickEvery != nil { return true } return false } 
func ( s * SyntheticsRequest ) GetBody ( ) string { if s == nil || s . Body == nil { return " " } return * s . Body } 
func ( s * SyntheticsRequest ) GetBodyOk ( ) ( string , bool ) { if s == nil || s . Body == nil { return " " , false } return * s . Body , true } 
func ( s * SyntheticsRequest ) HasBody ( ) bool { if s != nil && s . Body != nil { return true } return false } 
func ( s * SyntheticsRequest ) GetMethod ( ) string { if s == nil || s . Method == nil { return " " } return * s . Method } 
func ( s * SyntheticsRequest ) GetMethodOk ( ) ( string , bool ) { if s == nil || s . Method == nil { return " " , false } return * s . Method , true } 
func ( s * SyntheticsRequest ) HasMethod ( ) bool { if s != nil && s . Method != nil { return true } return false } 
func ( s * SyntheticsRequest ) GetTimeout ( ) int { if s == nil || s . Timeout == nil { return 0 } return * s . Timeout } 
func ( s * SyntheticsRequest ) GetTimeoutOk ( ) ( int , bool ) { if s == nil || s . Timeout == nil { return 0 , false } return * s . Timeout , true } 
func ( s * SyntheticsRequest ) HasTimeout ( ) bool { if s != nil && s . Timeout != nil { return true } return false } 
func ( s * SyntheticsRequest ) GetUrl ( ) string { if s == nil || s . Url == nil { return " " } return * s . Url } 
func ( s * SyntheticsRequest ) HasUrl ( ) bool { if s != nil && s . Url != nil { return true } return false } 
func ( s * SyntheticsTest ) GetConfig ( ) SyntheticsConfig { if s == nil || s . Config == nil { return SyntheticsConfig { } } return * s . Config } 
func ( s * SyntheticsTest ) GetConfigOk ( ) ( SyntheticsConfig , bool ) { if s == nil || s . Config == nil { return SyntheticsConfig { } , false } return * s . Config , true } 
func ( s * SyntheticsTest ) HasConfig ( ) bool { if s != nil && s . Config != nil { return true } return false } 
func ( s * SyntheticsTest ) GetCreatedAt ( ) string { if s == nil || s . CreatedAt == nil { return " " } return * s . CreatedAt } 
func ( s * SyntheticsTest ) GetCreatedAtOk ( ) ( string , bool ) { if s == nil || s . CreatedAt == nil { return " " , false } return * s . CreatedAt , true } 
func ( s * SyntheticsTest ) HasCreatedAt ( ) bool { if s != nil && s . CreatedAt != nil { return true } return false } 
func ( s * SyntheticsTest ) GetCreatedBy ( ) SyntheticsUser { if s == nil || s . CreatedBy == nil { return SyntheticsUser { } } return * s . CreatedBy } 
func ( s * SyntheticsTest ) GetCreatedByOk ( ) ( SyntheticsUser , bool ) { if s == nil || s . CreatedBy == nil { return SyntheticsUser { } , false } return * s . CreatedBy , true } 
func ( s * SyntheticsTest ) HasCreatedBy ( ) bool { if s != nil && s . CreatedBy != nil { return true } return false } 
func ( s * SyntheticsTest ) GetDeletedAt ( ) string { if s == nil || s . DeletedAt == nil { return " " } return * s . DeletedAt } 
func ( s * SyntheticsTest ) GetDeletedAtOk ( ) ( string , bool ) { if s == nil || s . DeletedAt == nil { return " " , false } return * s . DeletedAt , true } 
func ( s * SyntheticsTest ) HasDeletedAt ( ) bool { if s != nil && s . DeletedAt != nil { return true } return false } 
func ( s * SyntheticsTest ) GetMessage ( ) string { if s == nil || s . Message == nil { return " " } return * s . Message } 
func ( s * SyntheticsTest ) GetMessageOk ( ) ( string , bool ) { if s == nil || s . Message == nil { return " " , false } return * s . Message , true } 
func ( s * SyntheticsTest ) HasMessage ( ) bool { if s != nil && s . Message != nil { return true } return false } 
func ( s * SyntheticsTest ) GetModifiedAt ( ) string { if s == nil || s . ModifiedAt == nil { return " " } return * s . ModifiedAt } 
func ( s * SyntheticsTest ) GetModifiedAtOk ( ) ( string , bool ) { if s == nil || s . ModifiedAt == nil { return " " , false } return * s . ModifiedAt , true } 
func ( s * SyntheticsTest ) HasModifiedAt ( ) bool { if s != nil && s . ModifiedAt != nil { return true } return false } 
func ( s * SyntheticsTest ) GetModifiedBy ( ) SyntheticsUser { if s == nil || s . ModifiedBy == nil { return SyntheticsUser { } } return * s . ModifiedBy } 
func ( s * SyntheticsTest ) GetModifiedByOk ( ) ( SyntheticsUser , bool ) { if s == nil || s . ModifiedBy == nil { return SyntheticsUser { } , false } return * s . ModifiedBy , true } 
func ( s * SyntheticsTest ) HasModifiedBy ( ) bool { if s != nil && s . ModifiedBy != nil { return true } return false } 
func ( s * SyntheticsTest ) GetMonitorStatus ( ) string { if s == nil || s . MonitorStatus == nil { return " " } return * s . MonitorStatus } 
func ( s * SyntheticsTest ) GetMonitorStatusOk ( ) ( string , bool ) { if s == nil || s . MonitorStatus == nil { return " " , false } return * s . MonitorStatus , true } 
func ( s * SyntheticsTest ) HasMonitorStatus ( ) bool { if s != nil && s . MonitorStatus != nil { return true } return false } 
func ( s * SyntheticsTest ) GetName ( ) string { if s == nil || s . Name == nil { return " " } return * s . Name } 
func ( s * SyntheticsTest ) HasName ( ) bool { if s != nil && s . Name != nil { return true } return false } 
func ( s * SyntheticsTest ) GetOptions ( ) SyntheticsOptions { if s == nil || s . Options == nil { return SyntheticsOptions { } } return * s . Options } 
func ( s * SyntheticsTest ) GetOptionsOk ( ) ( SyntheticsOptions , bool ) { if s == nil || s . Options == nil { return SyntheticsOptions { } , false } return * s . Options , true } 
func ( s * SyntheticsTest ) HasOptions ( ) bool { if s != nil && s . Options != nil { return true } return false } 
func ( s * SyntheticsTest ) GetPublicId ( ) string { if s == nil || s . PublicId == nil { return " " } return * s . PublicId } 
func ( s * SyntheticsTest ) GetPublicIdOk ( ) ( string , bool ) { if s == nil || s . PublicId == nil { return " " , false } return * s . PublicId , true } 
func ( s * SyntheticsTest ) HasPublicId ( ) bool { if s != nil && s . PublicId != nil { return true } return false } 
func ( s * SyntheticsTest ) GetStatus ( ) string { if s == nil || s . Status == nil { return " " } return * s . Status } 
func ( s * SyntheticsTest ) GetStatusOk ( ) ( string , bool ) { if s == nil || s . Status == nil { return " " , false } return * s . Status , true } 
func ( s * SyntheticsTest ) HasStatus ( ) bool { if s != nil && s . Status != nil { return true } return false } 
func ( s * SyntheticsTest ) GetType ( ) string { if s == nil || s . Type == nil { return " " } return * s . Type } 
func ( s * SyntheticsTest ) HasType ( ) bool { if s != nil && s . Type != nil { return true } return false } 
func ( s * SyntheticsUser ) GetEmail ( ) string { if s == nil || s . Email == nil { return " " } return * s . Email } 
func ( s * SyntheticsUser ) GetEmailOk ( ) ( string , bool ) { if s == nil || s . Email == nil { return " " , false } return * s . Email , true } 
func ( s * SyntheticsUser ) HasEmail ( ) bool { if s != nil && s . Email != nil { return true } return false } 
func ( s * SyntheticsUser ) GetHandle ( ) string { if s == nil || s . Handle == nil { return " " } return * s . Handle } 
func ( s * SyntheticsUser ) GetHandleOk ( ) ( string , bool ) { if s == nil || s . Handle == nil { return " " , false } return * s . Handle , true } 
func ( s * SyntheticsUser ) HasHandle ( ) bool { if s != nil && s . Handle != nil { return true } return false } 
func ( s * SyntheticsUser ) GetId ( ) int { if s == nil || s . Id == nil { return 0 } return * s . Id } 
func ( s * SyntheticsUser ) GetIdOk ( ) ( int , bool ) { if s == nil || s . Id == nil { return 0 , false } return * s . Id , true } 
func ( s * SyntheticsUser ) HasId ( ) bool { if s != nil && s . Id != nil { return true } return false } 
func ( s * SyntheticsUser ) GetName ( ) string { if s == nil || s . Name == nil { return " " } return * s . Name } 
func ( s * SyntheticsUser ) HasName ( ) bool { if s != nil && s . Name != nil { return true } return false } 
func ( t * TemplateVariable ) GetDefault ( ) string { if t == nil || t . Default == nil { return " " } return * t . Default } 
func ( t * TemplateVariable ) GetDefaultOk ( ) ( string , bool ) { if t == nil || t . Default == nil { return " " , false } return * t . Default , true } 
func ( t * TemplateVariable ) HasDefault ( ) bool { if t != nil && t . Default != nil { return true } return false } 
func ( t * TemplateVariable ) GetName ( ) string { if t == nil || t . Name == nil { return " " } return * t . Name } 
func ( t * TemplateVariable ) GetNameOk ( ) ( string , bool ) { if t == nil || t . Name == nil { return " " , false } return * t . Name , true } 
func ( t * TemplateVariable ) HasName ( ) bool { if t != nil && t . Name != nil { return true } return false } 
func ( t * TemplateVariable ) GetPrefix ( ) string { if t == nil || t . Prefix == nil { return " " } return * t . Prefix } 
func ( t * TemplateVariable ) GetPrefixOk ( ) ( string , bool ) { if t == nil || t . Prefix == nil { return " " , false } return * t . Prefix , true } 
func ( t * TemplateVariable ) HasPrefix ( ) bool { if t != nil && t . Prefix != nil { return true } return false } 
func ( t * ThresholdCount ) GetCritical ( ) json . Number { if t == nil || t . Critical == nil { return " " } return * t . Critical } 
func ( t * ThresholdCount ) GetCriticalOk ( ) ( json . Number , bool ) { if t == nil || t . Critical == nil { return " " , false } return * t . Critical , true } 
func ( t * ThresholdCount ) HasCritical ( ) bool { if t != nil && t . Critical != nil { return true } return false } 
func ( t * ThresholdCount ) GetCriticalRecovery ( ) json . Number { if t == nil || t . CriticalRecovery == nil { return " " } return * t . CriticalRecovery } 
func ( t * ThresholdCount ) GetCriticalRecoveryOk ( ) ( json . Number , bool ) { if t == nil || t . CriticalRecovery == nil { return " " , false } return * t . CriticalRecovery , true } 
func ( t * ThresholdCount ) HasCriticalRecovery ( ) bool { if t != nil && t . CriticalRecovery != nil { return true } return false } 
func ( t * ThresholdCount ) GetOk ( ) json . Number { if t == nil || t . Ok == nil { return " " } return * t . Ok } 
func ( t * ThresholdCount ) GetOkOk ( ) ( json . Number , bool ) { if t == nil || t . Ok == nil { return " " , false } return * t . Ok , true } 
func ( t * ThresholdCount ) HasOk ( ) bool { if t != nil && t . Ok != nil { return true } return false } 
func ( t * ThresholdCount ) GetPeriod ( ) Period { if t == nil || t . Period == nil { return Period { } } return * t . Period } 
func ( t * ThresholdCount ) GetPeriodOk ( ) ( Period , bool ) { if t == nil || t . Period == nil { return Period { } , false } return * t . Period , true } 
func ( t * ThresholdCount ) HasPeriod ( ) bool { if t != nil && t . Period != nil { return true } return false } 
func ( t * ThresholdCount ) GetTimeAggregator ( ) string { if t == nil || t . TimeAggregator == nil { return " " } return * t . TimeAggregator } 
func ( t * ThresholdCount ) GetTimeAggregatorOk ( ) ( string , bool ) { if t == nil || t . TimeAggregator == nil { return " " , false } return * t . TimeAggregator , true } 
func ( t * ThresholdCount ) HasTimeAggregator ( ) bool { if t != nil && t . TimeAggregator != nil { return true } return false } 
func ( t * ThresholdCount ) GetUnknown ( ) json . Number { if t == nil || t . Unknown == nil { return " " } return * t . Unknown } 
func ( t * ThresholdCount ) GetUnknownOk ( ) ( json . Number , bool ) { if t == nil || t . Unknown == nil { return " " , false } return * t . Unknown , true } 
func ( t * ThresholdCount ) HasUnknown ( ) bool { if t != nil && t . Unknown != nil { return true } return false } 
func ( t * ThresholdCount ) GetWarning ( ) json . Number { if t == nil || t . Warning == nil { return " " } return * t . Warning } 
func ( t * ThresholdCount ) GetWarningOk ( ) ( json . Number , bool ) { if t == nil || t . Warning == nil { return " " , false } return * t . Warning , true } 
func ( t * ThresholdCount ) HasWarning ( ) bool { if t != nil && t . Warning != nil { return true } return false } 
func ( t * ThresholdCount ) GetWarningRecovery ( ) json . Number { if t == nil || t . WarningRecovery == nil { return " " } return * t . WarningRecovery } 
func ( t * ThresholdCount ) GetWarningRecoveryOk ( ) ( json . Number , bool ) { if t == nil || t . WarningRecovery == nil { return " " , false } return * t . WarningRecovery , true } 
func ( t * ThresholdCount ) HasWarningRecovery ( ) bool { if t != nil && t . WarningRecovery != nil { return true } return false } 
func ( t * ThresholdWindows ) GetRecoveryWindow ( ) string { if t == nil || t . RecoveryWindow == nil { return " " } return * t . RecoveryWindow } 
func ( t * ThresholdWindows ) GetRecoveryWindowOk ( ) ( string , bool ) { if t == nil || t . RecoveryWindow == nil { return " " , false } return * t . RecoveryWindow , true } 
func ( t * ThresholdWindows ) HasRecoveryWindow ( ) bool { if t != nil && t . RecoveryWindow != nil { return true } return false } 
func ( t * ThresholdWindows ) GetTriggerWindow ( ) string { if t == nil || t . TriggerWindow == nil { return " " } return * t . TriggerWindow } 
func ( t * ThresholdWindows ) GetTriggerWindowOk ( ) ( string , bool ) { if t == nil || t . TriggerWindow == nil { return " " , false } return * t . TriggerWindow , true } 
func ( t * ThresholdWindows ) HasTriggerWindow ( ) bool { if t != nil && t . TriggerWindow != nil { return true } return false } 
func ( t * TileDef ) GetAutoscale ( ) bool { if t == nil || t . Autoscale == nil { return false } return * t . Autoscale } 
func ( t * TileDef ) GetAutoscaleOk ( ) ( bool , bool ) { if t == nil || t . Autoscale == nil { return false , false } return * t . Autoscale , true } 
func ( t * TileDef ) HasAutoscale ( ) bool { if t != nil && t . Autoscale != nil { return true } return false } 
func ( t * TileDef ) GetCustomUnit ( ) string { if t == nil || t . CustomUnit == nil { return " " } return * t . CustomUnit } 
func ( t * TileDef ) GetCustomUnitOk ( ) ( string , bool ) { if t == nil || t . CustomUnit == nil { return " " , false } return * t . CustomUnit , true } 
func ( t * TileDef ) HasCustomUnit ( ) bool { if t != nil && t . CustomUnit != nil { return true } return false } 
func ( t * TileDef ) GetNodeType ( ) string { if t == nil || t . NodeType == nil { return " " } return * t . NodeType } 
func ( t * TileDef ) GetNodeTypeOk ( ) ( string , bool ) { if t == nil || t . NodeType == nil { return " " , false } return * t . NodeType , true } 
func ( t * TileDef ) HasNodeType ( ) bool { if t != nil && t . NodeType != nil { return true } return false } 
func ( t * TileDef ) GetNoGroupHosts ( ) bool { if t == nil || t . NoGroupHosts == nil { return false } return * t . NoGroupHosts } 
func ( t * TileDef ) GetNoGroupHostsOk ( ) ( bool , bool ) { if t == nil || t . NoGroupHosts == nil { return false , false } return * t . NoGroupHosts , true } 
func ( t * TileDef ) HasNoGroupHosts ( ) bool { if t != nil && t . NoGroupHosts != nil { return true } return false } 
func ( t * TileDef ) GetNoMetricHosts ( ) bool { if t == nil || t . NoMetricHosts == nil { return false } return * t . NoMetricHosts } 
func ( t * TileDef ) GetNoMetricHostsOk ( ) ( bool , bool ) { if t == nil || t . NoMetricHosts == nil { return false , false } return * t . NoMetricHosts , true } 
func ( t * TileDef ) HasNoMetricHosts ( ) bool { if t != nil && t . NoMetricHosts != nil { return true } return false } 
func ( t * TileDef ) GetPrecision ( ) PrecisionT { if t == nil || t . Precision == nil { return " " } return * t . Precision } 
func ( t * TileDef ) GetPrecisionOk ( ) ( PrecisionT , bool ) { if t == nil || t . Precision == nil { return " " , false } return * t . Precision , true } 
func ( t * TileDef ) HasPrecision ( ) bool { if t != nil && t . Precision != nil { return true } return false } 
func ( t * TileDef ) GetStyle ( ) TileDefStyle { if t == nil || t . Style == nil { return TileDefStyle { } } return * t . Style } 
func ( t * TileDef ) GetStyleOk ( ) ( TileDefStyle , bool ) { if t == nil || t . Style == nil { return TileDefStyle { } , false } return * t . Style , true } 
func ( t * TileDef ) HasStyle ( ) bool { if t != nil && t . Style != nil { return true } return false } 
func ( t * TileDef ) GetTextAlign ( ) string { if t == nil || t . TextAlign == nil { return " " } return * t . TextAlign } 
func ( t * TileDef ) GetTextAlignOk ( ) ( string , bool ) { if t == nil || t . TextAlign == nil { return " " , false } return * t . TextAlign , true } 
func ( t * TileDef ) HasTextAlign ( ) bool { if t != nil && t . TextAlign != nil { return true } return false } 
func ( t * TileDef ) GetViz ( ) string { if t == nil || t . Viz == nil { return " " } return * t . Viz } 
func ( t * TileDef ) GetVizOk ( ) ( string , bool ) { if t == nil || t . Viz == nil { return " " , false } return * t . Viz , true } 
func ( t * TileDef ) HasViz ( ) bool { if t != nil && t . Viz != nil { return true } return false } 
func ( t * TileDefEvent ) GetQuery ( ) string { if t == nil || t . Query == nil { return " " } return * t . Query } 
func ( t * TileDefEvent ) GetQueryOk ( ) ( string , bool ) { if t == nil || t . Query == nil { return " " , false } return * t . Query , true } 
func ( t * TileDefEvent ) HasQuery ( ) bool { if t != nil && t . Query != nil { return true } return false } 
func ( t * TileDefMarker ) GetLabel ( ) string { if t == nil || t . Label == nil { return " " } return * t . Label } 
func ( t * TileDefMarker ) GetLabelOk ( ) ( string , bool ) { if t == nil || t . Label == nil { return " " , false } return * t . Label , true } 
func ( t * TileDefMarker ) HasLabel ( ) bool { if t != nil && t . Label != nil { return true } return false } 
func ( t * TileDefMarker ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * TileDefMarker ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * TileDefMarker ) GetValue ( ) string { if t == nil || t . Value == nil { return " " } return * t . Value } 
func ( t * TileDefMarker ) GetValueOk ( ) ( string , bool ) { if t == nil || t . Value == nil { return " " , false } return * t . Value , true } 
func ( t * TileDefMarker ) HasValue ( ) bool { if t != nil && t . Value != nil { return true } return false } 
func ( t * TileDefRequest ) GetAggregator ( ) string { if t == nil || t . Aggregator == nil { return " " } return * t . Aggregator } 
func ( t * TileDefRequest ) GetAggregatorOk ( ) ( string , bool ) { if t == nil || t . Aggregator == nil { return " " , false } return * t . Aggregator , true } 
func ( t * TileDefRequest ) HasAggregator ( ) bool { if t != nil && t . Aggregator != nil { return true } return false } 
func ( t * TileDefRequest ) GetChangeType ( ) string { if t == nil || t . ChangeType == nil { return " " } return * t . ChangeType } 
func ( t * TileDefRequest ) GetChangeTypeOk ( ) ( string , bool ) { if t == nil || t . ChangeType == nil { return " " , false } return * t . ChangeType , true } 
func ( t * TileDefRequest ) HasChangeType ( ) bool { if t != nil && t . ChangeType != nil { return true } return false } 
func ( t * TileDefRequest ) GetCompareTo ( ) string { if t == nil || t . CompareTo == nil { return " " } return * t . CompareTo } 
func ( t * TileDefRequest ) GetCompareToOk ( ) ( string , bool ) { if t == nil || t . CompareTo == nil { return " " , false } return * t . CompareTo , true } 
func ( t * TileDefRequest ) HasCompareTo ( ) bool { if t != nil && t . CompareTo != nil { return true } return false } 
func ( t * TileDefRequest ) GetExtraCol ( ) string { if t == nil || t . ExtraCol == nil { return " " } return * t . ExtraCol } 
func ( t * TileDefRequest ) GetExtraColOk ( ) ( string , bool ) { if t == nil || t . ExtraCol == nil { return " " , false } return * t . ExtraCol , true } 
func ( t * TileDefRequest ) HasExtraCol ( ) bool { if t != nil && t . ExtraCol != nil { return true } return false } 
func ( t * TileDefRequest ) GetIncreaseGood ( ) bool { if t == nil || t . IncreaseGood == nil { return false } return * t . IncreaseGood } 
func ( t * TileDefRequest ) GetIncreaseGoodOk ( ) ( bool , bool ) { if t == nil || t . IncreaseGood == nil { return false , false } return * t . IncreaseGood , true } 
func ( t * TileDefRequest ) HasIncreaseGood ( ) bool { if t != nil && t . IncreaseGood != nil { return true } return false } 
func ( t * TileDefRequest ) GetLimit ( ) int { if t == nil || t . Limit == nil { return 0 } return * t . Limit } 
func ( t * TileDefRequest ) GetLimitOk ( ) ( int , bool ) { if t == nil || t . Limit == nil { return 0 , false } return * t . Limit , true } 
func ( t * TileDefRequest ) HasLimit ( ) bool { if t != nil && t . Limit != nil { return true } return false } 
func ( t * TileDefRequest ) GetMetric ( ) string { if t == nil || t . Metric == nil { return " " } return * t . Metric } 
func ( t * TileDefRequest ) GetMetricOk ( ) ( string , bool ) { if t == nil || t . Metric == nil { return " " , false } return * t . Metric , true } 
func ( t * TileDefRequest ) HasMetric ( ) bool { if t != nil && t . Metric != nil { return true } return false } 
func ( t * TileDefRequest ) GetOrderBy ( ) string { if t == nil || t . OrderBy == nil { return " " } return * t . OrderBy } 
func ( t * TileDefRequest ) GetOrderByOk ( ) ( string , bool ) { if t == nil || t . OrderBy == nil { return " " , false } return * t . OrderBy , true } 
func ( t * TileDefRequest ) HasOrderBy ( ) bool { if t != nil && t . OrderBy != nil { return true } return false } 
func ( t * TileDefRequest ) GetOrderDir ( ) string { if t == nil || t . OrderDir == nil { return " " } return * t . OrderDir } 
func ( t * TileDefRequest ) GetOrderDirOk ( ) ( string , bool ) { if t == nil || t . OrderDir == nil { return " " , false } return * t . OrderDir , true } 
func ( t * TileDefRequest ) HasOrderDir ( ) bool { if t != nil && t . OrderDir != nil { return true } return false } 
func ( t * TileDefRequest ) GetQuery ( ) string { if t == nil || t . Query == nil { return " " } return * t . Query } 
func ( t * TileDefRequest ) HasQuery ( ) bool { if t != nil && t . Query != nil { return true } return false } 
func ( t * TileDefRequest ) GetQueryType ( ) string { if t == nil || t . QueryType == nil { return " " } return * t . QueryType } 
func ( t * TileDefRequest ) GetQueryTypeOk ( ) ( string , bool ) { if t == nil || t . QueryType == nil { return " " , false } return * t . QueryType , true } 
func ( t * TileDefRequest ) HasQueryType ( ) bool { if t != nil && t . QueryType != nil { return true } return false } 
func ( t * TileDefRequest ) GetStyle ( ) TileDefRequestStyle { if t == nil || t . Style == nil { return TileDefRequestStyle { } } return * t . Style } 
func ( t * TileDefRequest ) GetStyleOk ( ) ( TileDefRequestStyle , bool ) { if t == nil || t . Style == nil { return TileDefRequestStyle { } , false } return * t . Style , true } 
func ( t * TileDefRequest ) HasStyle ( ) bool { if t != nil && t . Style != nil { return true } return false } 
func ( t * TileDefRequest ) GetTextFilter ( ) string { if t == nil || t . TextFilter == nil { return " " } return * t . TextFilter } 
func ( t * TileDefRequest ) GetTextFilterOk ( ) ( string , bool ) { if t == nil || t . TextFilter == nil { return " " , false } return * t . TextFilter , true } 
func ( t * TileDefRequest ) HasTextFilter ( ) bool { if t != nil && t . TextFilter != nil { return true } return false } 
func ( t * TileDefRequest ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * TileDefRequest ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * TileDefRequestStyle ) GetPalette ( ) string { if t == nil || t . Palette == nil { return " " } return * t . Palette } 
func ( t * TileDefRequestStyle ) GetPaletteOk ( ) ( string , bool ) { if t == nil || t . Palette == nil { return " " , false } return * t . Palette , true } 
func ( t * TileDefRequestStyle ) HasPalette ( ) bool { if t != nil && t . Palette != nil { return true } return false } 
func ( t * TileDefRequestStyle ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * TileDefRequestStyle ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * TileDefRequestStyle ) GetWidth ( ) string { if t == nil || t . Width == nil { return " " } return * t . Width } 
func ( t * TileDefRequestStyle ) GetWidthOk ( ) ( string , bool ) { if t == nil || t . Width == nil { return " " , false } return * t . Width , true } 
func ( t * TileDefRequestStyle ) HasWidth ( ) bool { if t != nil && t . Width != nil { return true } return false } 
func ( t * TileDefStyle ) GetFillMax ( ) json . Number { if t == nil || t . FillMax == nil { return " " } return * t . FillMax } 
func ( t * TileDefStyle ) GetFillMaxOk ( ) ( json . Number , bool ) { if t == nil || t . FillMax == nil { return " " , false } return * t . FillMax , true } 
func ( t * TileDefStyle ) HasFillMax ( ) bool { if t != nil && t . FillMax != nil { return true } return false } 
func ( t * TileDefStyle ) GetFillMin ( ) json . Number { if t == nil || t . FillMin == nil { return " " } return * t . FillMin } 
func ( t * TileDefStyle ) GetFillMinOk ( ) ( json . Number , bool ) { if t == nil || t . FillMin == nil { return " " , false } return * t . FillMin , true } 
func ( t * TileDefStyle ) HasFillMin ( ) bool { if t != nil && t . FillMin != nil { return true } return false } 
func ( t * TileDefStyle ) GetPalette ( ) string { if t == nil || t . Palette == nil { return " " } return * t . Palette } 
func ( t * TileDefStyle ) HasPalette ( ) bool { if t != nil && t . Palette != nil { return true } return false } 
func ( t * TileDefStyle ) GetPaletteFlip ( ) string { if t == nil || t . PaletteFlip == nil { return " " } return * t . PaletteFlip } 
func ( t * TileDefStyle ) GetPaletteFlipOk ( ) ( string , bool ) { if t == nil || t . PaletteFlip == nil { return " " , false } return * t . PaletteFlip , true } 
func ( t * TileDefStyle ) HasPaletteFlip ( ) bool { if t != nil && t . PaletteFlip != nil { return true } return false } 
func ( t * Time ) GetLiveSpan ( ) string { if t == nil || t . LiveSpan == nil { return " " } return * t . LiveSpan } 
func ( t * Time ) GetLiveSpanOk ( ) ( string , bool ) { if t == nil || t . LiveSpan == nil { return " " , false } return * t . LiveSpan , true } 
func ( t * Time ) HasLiveSpan ( ) bool { if t != nil && t . LiveSpan != nil { return true } return false } 
func ( t * TimeRange ) GetFrom ( ) json . Number { if t == nil || t . From == nil { return " " } return * t . From } 
func ( t * TimeRange ) GetFromOk ( ) ( json . Number , bool ) { if t == nil || t . From == nil { return " " , false } return * t . From , true } 
func ( t * TimeRange ) HasFrom ( ) bool { if t != nil && t . From != nil { return true } return false } 
func ( t * TimeRange ) GetLive ( ) bool { if t == nil || t . Live == nil { return false } return * t . Live } 
func ( t * TimeRange ) GetLiveOk ( ) ( bool , bool ) { if t == nil || t . Live == nil { return false , false } return * t . Live , true } 
func ( t * TimeRange ) HasLive ( ) bool { if t != nil && t . Live != nil { return true } return false } 
func ( t * TimeRange ) GetTo ( ) json . Number { if t == nil || t . To == nil { return " " } return * t . To } 
func ( t * TimeRange ) GetToOk ( ) ( json . Number , bool ) { if t == nil || t . To == nil { return " " , false } return * t . To , true } 
func ( t * TimeRange ) HasTo ( ) bool { if t != nil && t . To != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetLegendSize ( ) string { if t == nil || t . LegendSize == nil { return " " } return * t . LegendSize } 
func ( t * TimeseriesDefinition ) GetLegendSizeOk ( ) ( string , bool ) { if t == nil || t . LegendSize == nil { return " " , false } return * t . LegendSize , true } 
func ( t * TimeseriesDefinition ) HasLegendSize ( ) bool { if t != nil && t . LegendSize != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetShowLegend ( ) bool { if t == nil || t . ShowLegend == nil { return false } return * t . ShowLegend } 
func ( t * TimeseriesDefinition ) GetShowLegendOk ( ) ( bool , bool ) { if t == nil || t . ShowLegend == nil { return false , false } return * t . ShowLegend , true } 
func ( t * TimeseriesDefinition ) HasShowLegend ( ) bool { if t != nil && t . ShowLegend != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetTime ( ) WidgetTime { if t == nil || t . Time == nil { return WidgetTime { } } return * t . Time } 
func ( t * TimeseriesDefinition ) HasTime ( ) bool { if t != nil && t . Time != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetTitle ( ) string { if t == nil || t . Title == nil { return " " } return * t . Title } 
func ( t * TimeseriesDefinition ) GetTitleOk ( ) ( string , bool ) { if t == nil || t . Title == nil { return " " , false } return * t . Title , true } 
func ( t * TimeseriesDefinition ) HasTitle ( ) bool { if t != nil && t . Title != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetTitleAlign ( ) string { if t == nil || t . TitleAlign == nil { return " " } return * t . TitleAlign } 
func ( t * TimeseriesDefinition ) HasTitleAlign ( ) bool { if t != nil && t . TitleAlign != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetTitleSize ( ) string { if t == nil || t . TitleSize == nil { return " " } return * t . TitleSize } 
func ( t * TimeseriesDefinition ) GetTitleSizeOk ( ) ( string , bool ) { if t == nil || t . TitleSize == nil { return " " , false } return * t . TitleSize , true } 
func ( t * TimeseriesDefinition ) HasTitleSize ( ) bool { if t != nil && t . TitleSize != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * TimeseriesDefinition ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * TimeseriesDefinition ) GetYaxis ( ) WidgetAxis { if t == nil || t . Yaxis == nil { return WidgetAxis { } } return * t . Yaxis } 
func ( t * TimeseriesDefinition ) GetYaxisOk ( ) ( WidgetAxis , bool ) { if t == nil || t . Yaxis == nil { return WidgetAxis { } , false } return * t . Yaxis , true } 
func ( t * TimeseriesDefinition ) HasYaxis ( ) bool { if t != nil && t . Yaxis != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if t == nil || t . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * t . ApmQuery } 
func ( t * TimeseriesRequest ) HasApmQuery ( ) bool { if t != nil && t . ApmQuery != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetDisplayType ( ) string { if t == nil || t . DisplayType == nil { return " " } return * t . DisplayType } 
func ( t * TimeseriesRequest ) GetDisplayTypeOk ( ) ( string , bool ) { if t == nil || t . DisplayType == nil { return " " , false } return * t . DisplayType , true } 
func ( t * TimeseriesRequest ) HasDisplayType ( ) bool { if t != nil && t . DisplayType != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if t == nil || t . LogQuery == nil { return WidgetApmOrLogQuery { } } return * t . LogQuery } 
func ( t * TimeseriesRequest ) GetLogQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if t == nil || t . LogQuery == nil { return WidgetApmOrLogQuery { } , false } return * t . LogQuery , true } 
func ( t * TimeseriesRequest ) HasLogQuery ( ) bool { if t != nil && t . LogQuery != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetMetricQuery ( ) string { if t == nil || t . MetricQuery == nil { return " " } return * t . MetricQuery } 
func ( t * TimeseriesRequest ) GetMetricQueryOk ( ) ( string , bool ) { if t == nil || t . MetricQuery == nil { return " " , false } return * t . MetricQuery , true } 
func ( t * TimeseriesRequest ) HasMetricQuery ( ) bool { if t != nil && t . MetricQuery != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetProcessQuery ( ) WidgetProcessQuery { if t == nil || t . ProcessQuery == nil { return WidgetProcessQuery { } } return * t . ProcessQuery } 
func ( t * TimeseriesRequest ) GetProcessQueryOk ( ) ( WidgetProcessQuery , bool ) { if t == nil || t . ProcessQuery == nil { return WidgetProcessQuery { } , false } return * t . ProcessQuery , true } 
func ( t * TimeseriesRequest ) HasProcessQuery ( ) bool { if t != nil && t . ProcessQuery != nil { return true } return false } 
func ( t * TimeseriesRequest ) GetStyle ( ) TimeseriesRequestStyle { if t == nil || t . Style == nil { return TimeseriesRequestStyle { } } return * t . Style } 
func ( t * TimeseriesRequest ) GetStyleOk ( ) ( TimeseriesRequestStyle , bool ) { if t == nil || t . Style == nil { return TimeseriesRequestStyle { } , false } return * t . Style , true } 
func ( t * TimeseriesRequest ) HasStyle ( ) bool { if t != nil && t . Style != nil { return true } return false } 
func ( t * TimeseriesRequestStyle ) GetLineType ( ) string { if t == nil || t . LineType == nil { return " " } return * t . LineType } 
func ( t * TimeseriesRequestStyle ) GetLineTypeOk ( ) ( string , bool ) { if t == nil || t . LineType == nil { return " " , false } return * t . LineType , true } 
func ( t * TimeseriesRequestStyle ) HasLineType ( ) bool { if t != nil && t . LineType != nil { return true } return false } 
func ( t * TimeseriesRequestStyle ) GetLineWidth ( ) string { if t == nil || t . LineWidth == nil { return " " } return * t . LineWidth } 
func ( t * TimeseriesRequestStyle ) GetLineWidthOk ( ) ( string , bool ) { if t == nil || t . LineWidth == nil { return " " , false } return * t . LineWidth , true } 
func ( t * TimeseriesRequestStyle ) HasLineWidth ( ) bool { if t != nil && t . LineWidth != nil { return true } return false } 
func ( t * TimeseriesRequestStyle ) GetPalette ( ) string { if t == nil || t . Palette == nil { return " " } return * t . Palette } 
func ( t * TimeseriesRequestStyle ) HasPalette ( ) bool { if t != nil && t . Palette != nil { return true } return false } 
func ( t * ToggleStatus ) GetNewStatus ( ) string { if t == nil || t . NewStatus == nil { return " " } return * t . NewStatus } 
func ( t * ToggleStatus ) GetNewStatusOk ( ) ( string , bool ) { if t == nil || t . NewStatus == nil { return " " , false } return * t . NewStatus , true } 
func ( t * ToggleStatus ) HasNewStatus ( ) bool { if t != nil && t . NewStatus != nil { return true } return false } 
func ( t * ToplistDefinition ) GetTime ( ) WidgetTime { if t == nil || t . Time == nil { return WidgetTime { } } return * t . Time } 
func ( t * ToplistDefinition ) HasTime ( ) bool { if t != nil && t . Time != nil { return true } return false } 
func ( t * ToplistDefinition ) GetTitle ( ) string { if t == nil || t . Title == nil { return " " } return * t . Title } 
func ( t * ToplistDefinition ) HasTitle ( ) bool { if t != nil && t . Title != nil { return true } return false } 
func ( t * ToplistDefinition ) GetTitleAlign ( ) string { if t == nil || t . TitleAlign == nil { return " " } return * t . TitleAlign } 
func ( t * ToplistDefinition ) HasTitleAlign ( ) bool { if t != nil && t . TitleAlign != nil { return true } return false } 
func ( t * ToplistDefinition ) GetTitleSize ( ) string { if t == nil || t . TitleSize == nil { return " " } return * t . TitleSize } 
func ( t * ToplistDefinition ) HasTitleSize ( ) bool { if t != nil && t . TitleSize != nil { return true } return false } 
func ( t * ToplistDefinition ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * ToplistDefinition ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * ToplistRequest ) GetApmQuery ( ) WidgetApmOrLogQuery { if t == nil || t . ApmQuery == nil { return WidgetApmOrLogQuery { } } return * t . ApmQuery } 
func ( t * ToplistRequest ) GetApmQueryOk ( ) ( WidgetApmOrLogQuery , bool ) { if t == nil || t . ApmQuery == nil { return WidgetApmOrLogQuery { } , false } return * t . ApmQuery , true } 
func ( t * ToplistRequest ) HasApmQuery ( ) bool { if t != nil && t . ApmQuery != nil { return true } return false } 
func ( t * ToplistRequest ) GetLogQuery ( ) WidgetApmOrLogQuery { if t == nil || t . LogQuery == nil { return WidgetApmOrLogQuery { } } return * t . LogQuery } 
func ( t * ToplistRequest ) HasLogQuery ( ) bool { if t != nil && t . LogQuery != nil { return true } return false } 
func ( t * ToplistRequest ) GetMetricQuery ( ) string { if t == nil || t . MetricQuery == nil { return " " } return * t . MetricQuery } 
func ( t * ToplistRequest ) HasMetricQuery ( ) bool { if t != nil && t . MetricQuery != nil { return true } return false } 
func ( t * ToplistRequest ) GetProcessQuery ( ) WidgetProcessQuery { if t == nil || t . ProcessQuery == nil { return WidgetProcessQuery { } } return * t . ProcessQuery } 
func ( t * ToplistRequest ) HasProcessQuery ( ) bool { if t != nil && t . ProcessQuery != nil { return true } return false } 
func ( t * ToplistRequest ) GetStyle ( ) WidgetRequestStyle { if t == nil || t . Style == nil { return WidgetRequestStyle { } } return * t . Style } 
func ( t * ToplistRequest ) GetStyleOk ( ) ( WidgetRequestStyle , bool ) { if t == nil || t . Style == nil { return WidgetRequestStyle { } , false } return * t . Style , true } 
func ( t * ToplistRequest ) HasStyle ( ) bool { if t != nil && t . Style != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetDisplayFormat ( ) string { if t == nil || t . DisplayFormat == nil { return " " } return * t . DisplayFormat } 
func ( t * TraceServiceDefinition ) GetDisplayFormatOk ( ) ( string , bool ) { if t == nil || t . DisplayFormat == nil { return " " , false } return * t . DisplayFormat , true } 
func ( t * TraceServiceDefinition ) HasDisplayFormat ( ) bool { if t != nil && t . DisplayFormat != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetEnv ( ) string { if t == nil || t . Env == nil { return " " } return * t . Env } 
func ( t * TraceServiceDefinition ) GetEnvOk ( ) ( string , bool ) { if t == nil || t . Env == nil { return " " , false } return * t . Env , true } 
func ( t * TraceServiceDefinition ) HasEnv ( ) bool { if t != nil && t . Env != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetService ( ) string { if t == nil || t . Service == nil { return " " } return * t . Service } 
func ( t * TraceServiceDefinition ) GetServiceOk ( ) ( string , bool ) { if t == nil || t . Service == nil { return " " , false } return * t . Service , true } 
func ( t * TraceServiceDefinition ) HasService ( ) bool { if t != nil && t . Service != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowBreakdown ( ) bool { if t == nil || t . ShowBreakdown == nil { return false } return * t . ShowBreakdown } 
func ( t * TraceServiceDefinition ) GetShowBreakdownOk ( ) ( bool , bool ) { if t == nil || t . ShowBreakdown == nil { return false , false } return * t . ShowBreakdown , true } 
func ( t * TraceServiceDefinition ) HasShowBreakdown ( ) bool { if t != nil && t . ShowBreakdown != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowDistribution ( ) bool { if t == nil || t . ShowDistribution == nil { return false } return * t . ShowDistribution } 
func ( t * TraceServiceDefinition ) GetShowDistributionOk ( ) ( bool , bool ) { if t == nil || t . ShowDistribution == nil { return false , false } return * t . ShowDistribution , true } 
func ( t * TraceServiceDefinition ) HasShowDistribution ( ) bool { if t != nil && t . ShowDistribution != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowErrors ( ) bool { if t == nil || t . ShowErrors == nil { return false } return * t . ShowErrors } 
func ( t * TraceServiceDefinition ) GetShowErrorsOk ( ) ( bool , bool ) { if t == nil || t . ShowErrors == nil { return false , false } return * t . ShowErrors , true } 
func ( t * TraceServiceDefinition ) HasShowErrors ( ) bool { if t != nil && t . ShowErrors != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowHits ( ) bool { if t == nil || t . ShowHits == nil { return false } return * t . ShowHits } 
func ( t * TraceServiceDefinition ) GetShowHitsOk ( ) ( bool , bool ) { if t == nil || t . ShowHits == nil { return false , false } return * t . ShowHits , true } 
func ( t * TraceServiceDefinition ) HasShowHits ( ) bool { if t != nil && t . ShowHits != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowLatency ( ) bool { if t == nil || t . ShowLatency == nil { return false } return * t . ShowLatency } 
func ( t * TraceServiceDefinition ) GetShowLatencyOk ( ) ( bool , bool ) { if t == nil || t . ShowLatency == nil { return false , false } return * t . ShowLatency , true } 
func ( t * TraceServiceDefinition ) HasShowLatency ( ) bool { if t != nil && t . ShowLatency != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetShowResourceList ( ) bool { if t == nil || t . ShowResourceList == nil { return false } return * t . ShowResourceList } 
func ( t * TraceServiceDefinition ) GetShowResourceListOk ( ) ( bool , bool ) { if t == nil || t . ShowResourceList == nil { return false , false } return * t . ShowResourceList , true } 
func ( t * TraceServiceDefinition ) HasShowResourceList ( ) bool { if t != nil && t . ShowResourceList != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetSizeFormat ( ) string { if t == nil || t . SizeFormat == nil { return " " } return * t . SizeFormat } 
func ( t * TraceServiceDefinition ) GetSizeFormatOk ( ) ( string , bool ) { if t == nil || t . SizeFormat == nil { return " " , false } return * t . SizeFormat , true } 
func ( t * TraceServiceDefinition ) HasSizeFormat ( ) bool { if t != nil && t . SizeFormat != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetSpanName ( ) string { if t == nil || t . SpanName == nil { return " " } return * t . SpanName } 
func ( t * TraceServiceDefinition ) GetSpanNameOk ( ) ( string , bool ) { if t == nil || t . SpanName == nil { return " " , false } return * t . SpanName , true } 
func ( t * TraceServiceDefinition ) HasSpanName ( ) bool { if t != nil && t . SpanName != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetTime ( ) WidgetTime { if t == nil || t . Time == nil { return WidgetTime { } } return * t . Time } 
func ( t * TraceServiceDefinition ) GetTimeOk ( ) ( WidgetTime , bool ) { if t == nil || t . Time == nil { return WidgetTime { } , false } return * t . Time , true } 
func ( t * TraceServiceDefinition ) HasTime ( ) bool { if t != nil && t . Time != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetTitle ( ) string { if t == nil || t . Title == nil { return " " } return * t . Title } 
func ( t * TraceServiceDefinition ) HasTitle ( ) bool { if t != nil && t . Title != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetTitleAlign ( ) string { if t == nil || t . TitleAlign == nil { return " " } return * t . TitleAlign } 
func ( t * TraceServiceDefinition ) GetTitleAlignOk ( ) ( string , bool ) { if t == nil || t . TitleAlign == nil { return " " , false } return * t . TitleAlign , true } 
func ( t * TraceServiceDefinition ) HasTitleAlign ( ) bool { if t != nil && t . TitleAlign != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetTitleSize ( ) string { if t == nil || t . TitleSize == nil { return " " } return * t . TitleSize } 
func ( t * TraceServiceDefinition ) HasTitleSize ( ) bool { if t != nil && t . TitleSize != nil { return true } return false } 
func ( t * TraceServiceDefinition ) GetType ( ) string { if t == nil || t . Type == nil { return " " } return * t . Type } 
func ( t * TraceServiceDefinition ) GetTypeOk ( ) ( string , bool ) { if t == nil || t . Type == nil { return " " , false } return * t . Type , true } 
func ( t * TraceServiceDefinition ) HasType ( ) bool { if t != nil && t . Type != nil { return true } return false } 
func ( t * TriggeringValue ) GetFromTs ( ) int { if t == nil || t . FromTs == nil { return 0 } return * t . FromTs } 
func ( t * TriggeringValue ) GetFromTsOk ( ) ( int , bool ) { if t == nil || t . FromTs == nil { return 0 , false } return * t . FromTs , true } 
func ( t * TriggeringValue ) HasFromTs ( ) bool { if t != nil && t . FromTs != nil { return true } return false } 
func ( t * TriggeringValue ) GetToTs ( ) int { if t == nil || t . ToTs == nil { return 0 } return * t . ToTs } 
func ( t * TriggeringValue ) GetToTsOk ( ) ( int , bool ) { if t == nil || t . ToTs == nil { return 0 , false } return * t . ToTs , true } 
func ( t * TriggeringValue ) HasToTs ( ) bool { if t != nil && t . ToTs != nil { return true } return false } 
func ( t * TriggeringValue ) GetValue ( ) int { if t == nil || t . Value == nil { return 0 } return * t . Value } 
func ( t * TriggeringValue ) GetValueOk ( ) ( int , bool ) { if t == nil || t . Value == nil { return 0 , false } return * t . Value , true } 
func ( t * TriggeringValue ) HasValue ( ) bool { if t != nil && t . Value != nil { return true } return false } 
func ( u * User ) GetAccessRole ( ) string { if u == nil || u . AccessRole == nil { return " " } return * u . AccessRole } 
func ( u * User ) GetAccessRoleOk ( ) ( string , bool ) { if u == nil || u . AccessRole == nil { return " " , false } return * u . AccessRole , true } 
func ( u * User ) HasAccessRole ( ) bool { if u != nil && u . AccessRole != nil { return true } return false } 
func ( u * User ) GetDisabled ( ) bool { if u == nil || u . Disabled == nil { return false } return * u . Disabled } 
func ( u * User ) GetDisabledOk ( ) ( bool , bool ) { if u == nil || u . Disabled == nil { return false , false } return * u . Disabled , true } 
func ( u * User ) HasDisabled ( ) bool { if u != nil && u . Disabled != nil { return true } return false } 
func ( u * User ) GetEmailOk ( ) ( string , bool ) { if u == nil || u . Email == nil { return " " , false } return * u . Email , true } 
func ( u * User ) HasEmail ( ) bool { if u != nil && u . Email != nil { return true } return false } 
func ( u * User ) GetHandle ( ) string { if u == nil || u . Handle == nil { return " " } return * u . Handle } 
func ( u * User ) GetHandleOk ( ) ( string , bool ) { if u == nil || u . Handle == nil { return " " , false } return * u . Handle , true } 

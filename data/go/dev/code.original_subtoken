func ( q * query ) Close ( ) { for _ , s : = range q . matrix { put Point Slice ( s . Points ) } } 
func ( q * query ) Exec ( ctx context . Context ) * Result { if span : = opentracing . Span From Context ( ctx ) ; span ! = nil { span . Set Tag ( query Tag , q . stmt . String ( ) ) } res , warnings , err : = q . ng . exec ( ctx , q ) return & Result { Err : err , Value : res , Warnings : warnings } } 
func context Done ( ctx context . Context , env string ) error { if err : = ctx . Err ( ) ; err ! = nil { return context Err ( err , env ) } return nil } 
func New Engine ( opts Engine Opts ) * Engine { if opts . Logger = = nil { opts . Logger = log . New Nop Logger ( ) } metrics : = & engine Metrics { current Queries : prometheus . New Gauge ( prometheus . Gauge Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , } ) , max Concurrent Queries : prometheus . New Gauge ( prometheus . Gauge Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , } ) , query Queue Time : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , Const Labels : prometheus . Labels { " " : " " } , } ) , query Prepare Time : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , Const Labels : prometheus . Labels { " " : " " } , } ) , query Inner Eval : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , Const Labels : prometheus . Labels { " " : " " } , } ) , query Result Sort : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Subsystem : subsystem , Name : " " , Help : " " , Const Labels : prometheus . Labels { " " : " " } , } ) , } metrics . max Concurrent Queries . Set ( float 6 4 ( opts . Max Concurrent ) ) if opts . Reg ! = nil { opts . Reg . Must Register ( metrics . current Queries , metrics . max Concurrent Queries , metrics . query Queue Time , metrics . query Prepare Time , metrics . query Inner Eval , metrics . query Result Sort , ) } return & Engine { gate : gate . New ( opts . Max Concurrent ) , timeout : opts . Timeout , logger : opts . Logger , metrics : metrics , max Samples Per Query : opts . Max Samples , } } 
func ( ng * Engine ) New Instant Query ( q storage . Queryable , qs string , ts time . Time ) ( Query , error ) { expr , err : = Parse Expr ( qs ) if err ! = nil { return nil , err } qry : = ng . new Query ( q , expr , ts , ts , 0 ) qry . q = qs return qry , nil } 
func ( ng * Engine ) New Range Query ( q storage . Queryable , qs string , start , end time . Time , interval time . Duration ) ( Query , error ) { expr , err : = Parse Expr ( qs ) if err ! = nil { return nil , err } if expr . Type ( ) ! = Value Type Vector & & expr . Type ( ) ! = Value Type Scalar { return nil , errors . Errorf ( " " , documented Type ( expr . Type ( ) ) ) } qry : = ng . new Query ( q , expr , start , end , interval ) qry . q = qs return qry , nil } 
func ( ng * Engine ) exec ( ctx context . Context , q * query ) ( Value , storage . Warnings , error ) { ng . metrics . current Queries . Inc ( ) defer ng . metrics . current Queries . Dec ( ) ctx , cancel : = context . With Timeout ( ctx , ng . timeout ) q . cancel = cancel exec Span Timer , ctx : = q . stats . Get Span Timer ( ctx , stats . Exec Total Time ) defer exec Span Timer . Finish ( ) queue Span Timer , _ : = q . stats . Get Span Timer ( ctx , stats . Exec Queue Time , ng . metrics . query Queue Time ) if err : = ng . gate . Start ( ctx ) ; err ! = nil { return nil , nil , context Err ( err , " " ) } defer ng . gate . Done ( ) queue Span Timer . Finish ( ) const env = " " eval Span Timer , ctx : = q . stats . Get Span Timer ( ctx , stats . Eval Total Time ) defer eval Span Timer . Finish ( ) } switch s : = q . Statement ( ) . ( type ) { case * Eval Stmt : return ng . exec Eval Stmt ( ctx , q , s ) case test Stmt : return nil , nil , s ( ctx ) } panic ( errors . Errorf ( " " , q . Statement ( ) ) ) } 
func ( ng * Engine ) exec Eval Stmt ( ctx context . Context , query * query , s * Eval Stmt ) ( Value , storage . Warnings , error ) { prepare Span Timer , ctx Prepare : = query . stats . Get Span Timer ( ctx , stats . Query Preparation Time , ng . metrics . query Prepare Time ) querier , warnings , err : = ng . populate Series ( ctx Prepare , query . queryable , s ) prepare Span Timer . Finish ( ) } if err ! = nil { return nil , warnings , err } eval Span Timer , ctx Inner Eval : = query . stats . Get Span Timer ( ctx , stats . Inner Eval Time , ng . metrics . query Inner Eval ) evaluator : = & evaluator { start Timestamp : start , end Timestamp : start , interval : 1 , ctx : ctx Inner Eval , max Samples : ng . max Samples Per Query , default Eval Interval : Get Default Evaluation Interval ( ) , logger : ng . logger , } val , err : = evaluator . Eval ( s . Expr ) if err ! = nil { return nil , warnings , err } eval Span Timer . Finish ( ) mat , ok : = val . ( Matrix ) if ! ok { panic ( errors . Errorf ( " " , val . Type ( ) ) ) } query . matrix = mat switch s . Expr . Type ( ) { case Value Type Vector : for i , s : = range mat { } return vector , warnings , nil case Value Type Scalar : return Scalar { V : mat [ 0 ] . Points [ 0 ] . V , T : start } , warnings , nil case Value Type Matrix : return mat , warnings , nil default : panic ( errors . Errorf ( " " , s . Expr . Type ( ) ) ) } } val , err : = evaluator . Eval ( s . Expr ) if err ! = nil { return nil , warnings , err } eval Span Timer . Finish ( ) mat , ok : = val . ( Matrix ) if ! ok { panic ( errors . Errorf ( " " , val . Type ( ) ) ) } query . matrix = mat if err : = context Done ( ctx , " " ) ; err ! = nil { return nil , warnings , err } sort . Sort ( mat ) sort Span Timer . Finish ( ) return mat , warnings , nil } 
func ( ng * Engine ) cumulative Subquery Offset ( path [ ] Node ) time . Duration { var subq Offset time . Duration for _ , node : = range path { switch n : = node . ( type ) { case * Subquery Expr : subq Offset + = n . Range + n . Offset } } return subq Offset } 
func extract Func From Path ( p [ ] Node ) string { if len ( p ) = = 0 { return " " } switch n : = p [ len ( p ) - 1 ] . ( type ) { case * Aggregate Expr : return n . Op . String ( ) case * Call : return n . Func . Name case * Binary Expr : } return extract Func From Path ( p [ : len ( p ) - 1 ] ) } 
func ( ev * evaluator ) errorf ( format string , args . . . interface { } ) { ev . error ( errors . Errorf ( format , args . . . ) ) } 
func ( ev * evaluator ) recover ( errp * error ) { e : = recover ( ) if e = = nil { return } if err , ok : = e . ( runtime . Error ) ; ok { buf = buf [ : runtime . Stack ( buf , false ) ] level . Error ( ev . logger ) . Log ( " " , " " , " " , e , " " , string ( buf ) ) * errp = errors . Wrap ( err , " " ) } else { * errp = e . ( error ) } } 
func ( enh * Eval Node Helper ) drop Metric Name ( l labels . Labels ) labels . Labels { if enh . dmn = = nil { enh . dmn = make ( map [ uint 6 4 ] labels . Labels , len ( enh . out ) ) } h : = l . Hash ( ) ret , ok : = enh . dmn [ h ] if ok { return ret } ret = drop Metric Name ( l ) enh . dmn [ h ] = ret return ret } 
func ( enh * Eval Node Helper ) signature Func ( on bool , names . . . string ) func ( labels . Labels ) uint 6 4 { if enh . sigf = = nil { enh . sigf = make ( map [ uint 6 4 ] uint 6 4 , len ( enh . out ) ) } f : = signature Func ( on , names . . . ) return func ( l labels . Labels ) uint 6 4 { h : = l . Hash ( ) ret , ok : = enh . sigf [ h ] if ok { return ret } ret = f ( l ) enh . sigf [ h ] = ret return ret } } 
func ( ev * evaluator ) range Eval ( f func ( [ ] Value , * Eval Node Helper ) Vector , exprs . . . Expr ) Matrix { num Steps : = int ( ( ev . end Timestamp - ev . start Timestamp ) / ev . interval ) + 1 matrixes : = make ( [ ] Matrix , len ( exprs ) ) orig Matrixes : = make ( [ ] Matrix , len ( exprs ) ) original Num Samples : = ev . current Samples for i , e : = range exprs { copy ( orig Matrixes [ i ] , matrixes [ i ] ) } } vectors : = make ( [ ] Vector , len ( exprs ) ) args : = make ( [ ] Value , len ( exprs ) ) for i : = range exprs { vectors [ i ] = make ( Vector , 0 , len ( matrixes [ i ] ) ) if len ( matrixes [ i ] ) > biggest Len { biggest Len = len ( matrixes [ i ] ) } } enh : = & Eval Node Helper { out : make ( Vector , 0 , biggest Len ) } seriess : = make ( map [ uint 6 4 ] Series , biggest Len ) temp Num Samples : = ev . current Samples for ts : = ev . start Timestamp ; ts < = ev . end Timestamp ; ts + = ev . interval { if err : = context Done ( ev . ctx , " " ) ; err ! = nil { ev . error ( err ) } for si , series : = range matrixes [ i ] { for _ , point : = range series . Points { if point . T = = ts { if ev . current Samples < ev . max Samples { vectors [ i ] = append ( vectors [ i ] , Sample { Metric : series . Metric , Point : point } ) ev . current Samples + + } else { ev . error ( Err Too Many Samples ( env ) ) } } break } } args [ i ] = vectors [ i ] } result : = f ( args , enh ) if result . Contains Same Labelset ( ) { ev . errorf ( " " ) } enh . out = result [ : 0 ] ev . current Samples + = len ( result ) if ev . current Samples > ev . max Samples { ev . error ( Err Too Many Samples ( env ) ) } for i , s : = range result { s . Point . T = ts mat [ i ] = Series { Metric : s . Metric , Points : [ ] Point { s . Point } } } ev . current Samples = original Num Samples + mat . Total Samples ( ) return mat } ss , ok : = seriess [ h ] if ! ok { ss = Series { Metric : sample . Metric , Points : get Point Slice ( num Steps ) , } } sample . Point . T = ts ss . Points = append ( ss . Points , sample . Point ) seriess [ h ] = ss } } } } for _ , ss : = range seriess { mat = append ( mat , ss ) } ev . current Samples = original Num Samples + mat . Total Samples ( ) return mat } 
func ( ev * evaluator ) eval Subquery ( subq * Subquery Expr ) * Matrix Selector { val : = ev . eval ( subq ) . ( Matrix ) ms : = & Matrix Selector { Range : subq . Range , Offset : subq . Offset , series : make ( [ ] storage . Series , 0 , len ( val ) ) , } for _ , s : = range val { ms . series = append ( ms . series , New Storage Series ( s ) ) } return ms } 
func ( ev * evaluator ) eval ( expr Expr ) Value { } num Steps : = int ( ( ev . end Timestamp - ev . start Timestamp ) / ev . interval ) + 1 switch e : = expr . ( type ) { case * Aggregate Expr : if s , ok : = e . Param . ( * String Literal ) ; ok { return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . aggregation ( e . Op , e . Grouping , e . Without , s . Val , v [ 0 ] . ( Vector ) , enh ) } , e . Expr ) } return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { var param float 6 4 if e . Param ! = nil { param = v [ 0 ] . ( Vector ) [ 0 ] . V } return ev . aggregation ( e . Op , e . Grouping , e . Without , param , v [ 1 ] . ( Vector ) , enh ) } , e . Param , e . Expr ) case * Call : if e . Func . Name = = " " { if ok { return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return e . Func . Call ( [ ] Value { ev . vector Selector ( vs , enh . ts ) } , e . Args , enh ) } ) } } var matrix Arg bool for i , a : = range e . Args { if _ , ok : = a . ( * Matrix Selector ) ; ok { matrix Arg Index = i matrix Arg = true break } matrix Arg = true break } } if ! matrix Arg { } , e . Args . . . ) } in Args : = make ( [ ] Value , len ( e . Args ) ) other In Args : = make ( [ ] Vector , len ( e . Args ) ) for i , e : = range e . Args { if i ! = matrix Arg Index { other Args [ i ] = ev . eval ( e ) . ( Matrix ) other In Args [ i ] = Vector { Sample { } } in Args [ i ] = other In Args [ i ] } } sel : = e . Args [ matrix Arg Index ] . ( * Matrix Selector ) check For Series Set Expansion ( ev . ctx , sel ) mat : = make ( Matrix , 0 , len ( sel . series ) ) offset : = duration Milliseconds ( sel . Offset ) sel Range : = duration Milliseconds ( sel . Range ) step Range : = sel Range if step Range > ev . interval { step Range = ev . interval } in Matrix : = make ( Matrix , 1 ) in Args [ matrix Arg Index ] = in Matrix enh : = & Eval Node Helper { out : make ( Vector , 0 , 1 ) } for i , s : = range sel . series { points = points [ : 0 ] it . Reset ( s . Iterator ( ) ) ss : = Series { in Matrix [ 0 ] . Metric = sel . series [ i ] . Labels ( ) for ts , step : = ev . start Timestamp , - 1 ; ts < = ev . end Timestamp ; ts + = ev . interval { step + + } } maxt : = ts - offset mint : = maxt - sel Range if len ( points ) = = 0 { continue } in Matrix [ 0 ] . Points = points enh . ts = ts enh . out = out Vec [ : 0 ] if len ( out Vec ) > 0 { ss . Points = append ( ss . Points , Point { V : out Vec [ 0 ] . Point . V , T : ts } ) } } if len ( ss . Points ) > 0 { if ev . current Samples < ev . max Samples { mat = append ( mat , ss ) ev . current Samples + = len ( ss . Points ) } else { ev . error ( Err Too Many Samples ( env ) ) } } } if mat . Contains Same Labelset ( ) { ev . errorf ( " " ) } put Point Slice ( points ) return mat case * Paren Expr : return ev . eval ( e . Expr ) case * Unary Expr : mat : = ev . eval ( e . Expr ) . ( Matrix ) if e . Op = = Item SUB { for i : = range mat { mat [ i ] . Metric = drop Metric Name ( mat [ i ] . Metric ) for j : = range mat [ i ] . Points { mat [ i ] . Points [ j ] . V = - mat [ i ] . Points [ j ] . V } } if mat . Contains Same Labelset ( ) { ev . errorf ( " " ) } } return mat case * Binary Expr : switch lt , rt : = e . LHS . Type ( ) , e . RHS . Type ( ) ; { case lt = = Value Type Scalar & & rt = = Value Type Scalar : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { val : = scalar Binop ( e . Op , v [ 0 ] . ( Vector ) [ 0 ] . Point . V , v [ 1 ] . ( Vector ) [ 0 ] . Point . V ) return append ( enh . out , Sample { Point : Point { V : val } } ) } , e . LHS , e . RHS ) case lt = = Value Type Vector & & rt = = Value Type Vector : switch e . Op { case Item LAND : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vector And ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . Vector Matching , enh ) } , e . LHS , e . RHS ) case Item LOR : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vector Or ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . Vector Matching , enh ) } , e . LHS , e . RHS ) case Item LUnless : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vector Unless ( v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . Vector Matching , enh ) } , e . LHS , e . RHS ) default : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vector Binop ( e . Op , v [ 0 ] . ( Vector ) , v [ 1 ] . ( Vector ) , e . Vector Matching , e . Return Bool , enh ) } , e . LHS , e . RHS ) } case lt = = Value Type Vector & & rt = = Value Type Scalar : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vectorscalar Binop ( e . Op , v [ 0 ] . ( Vector ) , Scalar { V : v [ 1 ] . ( Vector ) [ 0 ] . Point . V } , false , e . Return Bool , enh ) } , e . LHS , e . RHS ) case lt = = Value Type Scalar & & rt = = Value Type Vector : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return ev . Vectorscalar Binop ( e . Op , v [ 1 ] . ( Vector ) , Scalar { V : v [ 0 ] . ( Vector ) [ 0 ] . Point . V } , true , e . Return Bool , enh ) } , e . LHS , e . RHS ) } case * Number Literal : return ev . range Eval ( func ( v [ ] Value , enh * Eval Node Helper ) Vector { return append ( enh . out , Sample { Point : Point { V : e . Val } } ) } ) case * Vector Selector : check For Series Set Expansion ( ev . ctx , e ) mat : = make ( Matrix , 0 , len ( e . series ) ) it : = storage . New Buffer ( duration Milliseconds ( Lookback Delta ) ) for i , s : = range e . series { it . Reset ( s . Iterator ( ) ) ss : = Series { Metric : e . series [ i ] . Labels ( ) , Points : get Point Slice ( num Steps ) , } for ts : = ev . start Timestamp ; ts < = ev . end Timestamp ; ts + = ev . interval { _ , v , ok : = ev . vector Selector Single ( it , e , ts ) if ok { if ev . current Samples < ev . max Samples { ss . Points = append ( ss . Points , Point { V : v , T : ts } ) ev . current Samples + + } else { ev . error ( Err Too Many Samples ( env ) ) } } } if len ( ss . Points ) > 0 { mat = append ( mat , ss ) } } return mat case * Matrix Selector : if ev . start Timestamp ! = ev . end Timestamp { panic ( errors . New ( " " ) ) } return ev . matrix Selector ( e ) case * Subquery Expr : offset Millis : = duration To Int 6 4Millis ( e . Offset ) range Millis : = duration To Int 6 4Millis ( e . Range ) new Ev : = & evaluator { end Timestamp : ev . end Timestamp - offset Millis , interval : ev . default Eval Interval , ctx : ev . ctx , current Samples : ev . current Samples , max Samples : ev . max Samples , default Eval Interval : ev . default Eval Interval , logger : ev . logger , } if e . Step ! = 0 { new Ev . interval = duration To Int 6 4Millis ( e . Step ) } if new Ev . start Timestamp < ( ev . start Timestamp - offset Millis - range Millis ) { new Ev . start Timestamp + = new Ev . interval } res : = new Ev . eval ( e . Expr ) ev . current Samples = new Ev . current Samples return res } panic ( errors . Errorf ( " " , expr ) ) } 
func ( ev * evaluator ) vector Selector ( node * Vector Selector , ts int 6 4 ) Vector { check For Series Set Expansion ( ev . ctx , node ) var ( vec = make ( Vector , 0 , len ( node . series ) ) ) it : = storage . New Buffer ( duration Milliseconds ( Lookback Delta ) ) for i , s : = range node . series { it . Reset ( s . Iterator ( ) ) t , v , ok : = ev . vector Selector Single ( it , node , ts ) if ok { vec = append ( vec , Sample { Metric : node . series [ i ] . Labels ( ) , Point : Point { V : v , T : t } , } ) ev . current Samples + + } if ev . current Samples > = ev . max Samples { ev . error ( Err Too Many Samples ( env ) ) } } return vec } 
func ( ev * evaluator ) vector Selector Single ( it * storage . Buffered Series Iterator , node * Vector Selector , ts int 6 4 ) ( int 6 4 , float 6 4 , bool ) { ref Time : = ts - duration Milliseconds ( node . Offset ) var t int 6 4 var v float 6 4 ok : = it . Seek ( ref Time ) if ! ok { if it . Err ( ) ! = nil { ev . error ( it . Err ( ) ) } } if ok { t , v = it . Values ( ) } if ! ok | | t > ref Time { t , v , ok = it . Peek Back ( 1 ) if ! ok | | t < ref Time - duration Milliseconds ( Lookback Delta ) { return 0 , 0 , false } } if value . Is Stale Na N ( v ) { return 0 , 0 , false } return t , v , true } 
func ( ev * evaluator ) matrix Selector ( node * Matrix Selector ) Matrix { check For Series Set Expansion ( ev . ctx , node ) var ( offset = duration Milliseconds ( node . Offset ) maxt = ev . start Timestamp - offset mint = maxt - duration Milliseconds ( node . Range ) matrix = make ( Matrix , 0 , len ( node . series ) ) ) it : = storage . New Buffer ( duration Milliseconds ( node . Range ) ) for i , s : = range node . series { if err : = context Done ( ev . ctx , " " ) ; err ! = nil { ev . error ( err ) } it . Reset ( s . Iterator ( ) ) ss : = Series { Metric : node . series [ i ] . Labels ( ) , } ss . Points = ev . matrix Iter Slice ( it , mint , maxt , get Point Slice ( 1 6 ) ) if len ( ss . Points ) > 0 { matrix = append ( matrix , ss ) } else { put Point Slice ( ss . Points ) } } return matrix } 
func ( ev * evaluator ) matrix Iter Slice ( it * storage . Buffered Series Iterator , mint , maxt int 6 4 , out [ ] Point ) [ ] Point { if len ( out ) > 0 & & out [ len ( out ) - 1 ] . T > = mint { for drop = 0 ; out [ drop ] . T < mint ; drop + + { } copy ( out , out [ drop : ] ) out = out [ : len ( out ) - drop ] } else { out = out [ : 0 ] } ok : = it . Seek ( maxt ) if ! ok { if it . Err ( ) ! = nil { ev . error ( it . Err ( ) ) } } buf : = it . Buffer ( ) for buf . Next ( ) { t , v : = buf . At ( ) if value . Is Stale Na N ( v ) { continue } } out = append ( out , Point { T : t , V : v } ) ev . current Samples + + } } if t = = maxt & & ! value . Is Stale Na N ( v ) { if ev . current Samples > = ev . max Samples { ev . error ( Err Too Many Samples ( env ) ) } out = append ( out , Point { T : t , V : v } ) ev . current Samples + + } } return out } 
func ( ev * evaluator ) Vector Binop ( op Item Type , lhs , rhs Vector , matching * Vector Matching , return Bool bool , enh * Eval Node Helper ) Vector { if matching . Card = = Card Many To Many { panic ( " " ) } sigf : = enh . signature Func ( matching . On , matching . Matching Labels . . . ) } } else { for k : = range enh . right Sigs { delete ( enh . right Sigs , k ) } } right Sigs : = enh . right Sigs if matching . Card = = Card One To Many { one Side = " " } matched Labels : = rs . Metric . Match Labels ( matching . On , matching . Matching Labels . . . ) } right Sigs [ sig ] = rs } } else { for k : = range enh . matched Sigs { delete ( enh . matched Sigs , k ) } } matched Sigs : = enh . matched Sigs rs , found : = right Sigs [ sig ] if ! found { continue } if matching . Card = = Card One To Many { vl , vr = vr , vl } value , keep : = vector Elem Binop ( op , vl , vr ) if return Bool { if keep { value = 1 . 0 } else { value = 0 . 0 } } else if ! keep { continue } metric : = result Metric ( ls . Metric , rs . Metric , op , matching , enh ) inserted Sigs , exists : = matched Sigs [ sig ] if matching . Card = = Card One To One { if exists { ev . errorf ( " " ) } matched Sigs [ sig ] = nil } else { if ! exists { inserted Sigs = map [ uint 6 4 ] struct { } { } matched Sigs [ sig ] = inserted Sigs } else if _ , duplicate : = inserted Sigs [ insert Sig ] ; duplicate { ev . errorf ( " " ) } inserted Sigs [ insert Sig ] = struct { } { } } enh . out = append ( enh . out , Sample { Metric : metric , Point : Point { V : value } , } ) } return enh . out } 
func signature Func ( on bool , names . . . string ) func ( labels . Labels ) uint 6 4 { } return func ( lset labels . Labels ) uint 6 4 { return lset . Hash Without Labels ( names . . . ) } } 
func result Metric ( lhs , rhs labels . Labels , op Item Type , matching * Vector Matching , enh * Eval Node Helper ) labels . Labels { if enh . result Metric = = nil { enh . result Metric = make ( map [ uint 6 4 ] labels . Labels , len ( enh . out ) ) } h : = ( lh ^ rhs . Hash ( ) ) + lh if ret , ok : = enh . result Metric [ h ] ; ok { return ret } lb : = labels . New Builder ( lhs ) if should Drop Metric Name ( op ) { lb . Del ( labels . Metric Name ) } if matching . Card = = Card One To One { if matching . On { Outer : for _ , l : = range lhs { for _ , n : = range matching . Matching Labels { if l . Name = = n { continue Outer } } lb . Del ( l . Name ) } } else { lb . Del ( matching . Matching Labels . . . ) } } for _ , ln : = range matching . Include { } else { lb . Del ( ln ) } } ret : = lb . Labels ( ) enh . result Metric [ h ] = ret return ret } 
func ( ev * evaluator ) Vectorscalar Binop ( op Item Type , lhs Vector , rhs Scalar , swap , return Bool bool , enh * Eval Node Helper ) Vector { for _ , lhs Sample : = range lhs { lv , rv : = lhs Sample . V , rhs . V } value , keep : = vector Elem Binop ( op , lv , rv ) } if return Bool { if keep { value = 1 . 0 } else { value = 0 . 0 } keep = true } if keep { lhs Sample . V = value if should Drop Metric Name ( op ) | | return Bool { lhs Sample . Metric = enh . drop Metric Name ( lhs Sample . Metric ) } enh . out = append ( enh . out , lhs Sample ) } } return enh . out } 
func scalar Binop ( op Item Type , lhs , rhs float 6 4 ) float 6 4 { switch op { case Item ADD : return lhs + rhs case Item SUB : return lhs - rhs case Item MUL : return lhs * rhs case Item DIV : return lhs / rhs case Item POW : return math . Pow ( lhs , rhs ) case Item MOD : return math . Mod ( lhs , rhs ) case Item EQL : return btos ( lhs = = rhs ) case Item NEQ : return btos ( lhs ! = rhs ) case Item GTR : return btos ( lhs > rhs ) case Item LSS : return btos ( lhs < rhs ) case Item GTE : return btos ( lhs > = rhs ) case Item LTE : return btos ( lhs < = rhs ) } panic ( errors . Errorf ( " " , op ) ) } 
func ( ev * evaluator ) aggregation ( op Item Type , grouping [ ] string , without bool , param interface { } , vec Vector , enh * Eval Node Helper ) Vector { result : = map [ uint 6 4 ] * grouped Aggregation { } var k int 6 4 if op = = Item Top K | | op = = Item Bottom K { f : = param . ( float 6 4 ) if ! convertible To Int 6 4 ( f ) { ev . errorf ( " " , f ) } k = int 6 4 ( f ) if k < 1 { return Vector { } } } var q float 6 4 if op = = Item Quantile { q = param . ( float 6 4 ) } var value Label string if op = = Item Count Values { value Label = param . ( string ) if ! model . Label Name ( value Label ) . Is Valid ( ) { ev . errorf ( " " , value Label ) } if ! without { grouping = append ( grouping , value Label ) } } for _ , s : = range vec { metric : = s . Metric if op = = Item Count Values { lb : = labels . New Builder ( metric ) lb . Set ( value Label , strconv . Format Float ( s . V , 'f ' , - 1 , 6 4 ) ) metric = lb . Labels ( ) } var ( grouping Key uint 6 4 ) if without { grouping Key = metric . Hash Without Labels ( grouping . . . ) } else { grouping Key = metric . Hash For Labels ( grouping . . . ) } group , ok : = result [ grouping Key ] if without { lb : = labels . New Builder ( metric ) lb . Del ( grouping . . . ) lb . Del ( labels . Metric Name ) m = lb . Labels ( ) } else { m = make ( labels . Labels , 0 , len ( grouping ) ) for _ , l : = range metric { for _ , n : = range grouping { if l . Name = = n { m = append ( m , l ) break } } } sort . Sort ( m ) } result [ grouping Key ] = & grouped Aggregation { labels : m , value : s . V , mean : s . V , group Count : 1 , } input Vec Len : = int 6 4 ( len ( vec ) ) result Size : = k if k > input Vec Len { result Size = input Vec Len } if op = = Item Stdvar | | op = = Item Stddev { result [ grouping Key ] . value = 0 . 0 } else if op = = Item Top K | | op = = Item Quantile { result [ grouping Key ] . heap = make ( vector By Value Heap , 0 , result Size ) heap . Push ( & result [ grouping Key ] . heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } else if op = = Item Bottom K { result [ grouping Key ] . reverse Heap = make ( vector By Reverse Value Heap , 0 , result Size ) heap . Push ( & result [ grouping Key ] . reverse Heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } continue } switch op { case Item Sum : group . value + = s . V case Item Avg : group . group Count + + group . mean + = ( s . V - group . mean ) / float 6 4 ( group . group Count ) case Item Max : if group . value < s . V | | math . Is Na N ( group . value ) { group . value = s . V } case Item Min : if group . value > s . V | | math . Is Na N ( group . value ) { group . value = s . V } case Item Count , Item Count Values : group . group Count + + case Item Stdvar , Item Stddev : group . group Count + + delta : = s . V - group . mean group . mean + = delta / float 6 4 ( group . group Count ) group . value + = delta * ( s . V - group . mean ) case Item Top K : if int 6 4 ( len ( group . heap ) ) < k | | group . heap [ 0 ] . V < s . V | | math . Is Na N ( group . heap [ 0 ] . V ) { if int 6 4 ( len ( group . heap ) ) = = k { heap . Pop ( & group . heap ) } heap . Push ( & group . heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } case Item Bottom K : if int 6 4 ( len ( group . reverse Heap ) ) < k | | group . reverse Heap [ 0 ] . V > s . V | | math . Is Na N ( group . reverse Heap [ 0 ] . V ) { if int 6 4 ( len ( group . reverse Heap ) ) = = k { heap . Pop ( & group . reverse Heap ) } heap . Push ( & group . reverse Heap , & Sample { Point : Point { V : s . V } , Metric : s . Metric , } ) } case Item Quantile : group . heap = append ( group . heap , s ) default : panic ( errors . Errorf ( " " , op ) ) } } case Item Count , Item Count Values : aggr . value = float 6 4 ( aggr . group Count ) case Item Stdvar : aggr . value = aggr . value / float 6 4 ( aggr . group Count ) case Item Stddev : aggr . value = math . Sqrt ( aggr . value / float 6 4 ( aggr . group Count ) ) case Item Top K : for _ , v : = range aggr . heap { enh . out = append ( enh . out , Sample { Metric : v . Metric , Point : Point { V : v . V } , } ) } continue case Item Bottom K : for _ , v : = range aggr . reverse Heap { enh . out = append ( enh . out , Sample { Metric : v . Metric , Point : Point { V : v . V } , } ) } continue case Item Quantile : aggr . value = quantile ( q , aggr . heap ) default : enh . out = append ( enh . out , Sample { Metric : aggr . labels , Point : Point { V : aggr . value } , } ) } return enh . out } 
func should Drop Metric Name ( op Item Type ) bool { switch op { case Item ADD , Item SUB , Item DIV , Item MUL , Item POW , Item MOD : return true default : return false } } 
func New Endpoints ( l log . Logger , svc , eps , pod cache . Shared Informer ) * Endpoints { if l = = nil { l = log . New Nop Logger ( ) } e : = & Endpoints { logger : l , endpoints Inf : eps , endpoints Store : eps . Get Store ( ) , service Inf : svc , service Store : svc . Get Store ( ) , pod Inf : pod , pod Store : pod . Get Store ( ) , queue : workqueue . New Named ( " " ) , } e . endpoints Inf . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , Update Func : func ( _ , o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , Delete Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) e . enqueue ( o ) } , } ) service Update : = func ( o interface { } ) { svc , err : = convert To Service ( o ) if err ! = nil { level . Error ( e . logger ) . Log ( " " , " " , " " , err ) return } ep : = & apiv 1 . Endpoints { } ep . Namespace = svc . Namespace ep . Name = svc . Name obj , exists , err : = e . endpoints Store . Get ( ep ) if exists & & err = = nil { e . enqueue ( obj . ( * apiv 1 . Endpoints ) ) } if err ! = nil { level . Error ( e . logger ) . Log ( " " , " " , " " , err ) } } e . service Inf . Add Event Handler ( cache . Resource Event Handler Funcs { service Update ( o ) } , Update Func : func ( _ , o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) service Update ( o ) } , Delete Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) service Update ( o ) } , } ) return e } 
func ( e * Endpoints ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer e . queue . Shut Down ( ) if ! cache . Wait For Cache Sync ( ctx . Done ( ) , e . endpoints Inf . Has Synced , e . service Inf . Has Synced , e . pod Inf . Has Synced ) { level . Error ( e . logger ) . Log ( " " , " " ) return } go func ( ) { for e . process ( ctx , ch ) { } } ( ) } 
func func Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return Vector { Sample { Point : Point { V : float 6 4 ( enh . ts ) / 1 0 0 0 , } } } } 
func extrapolated Rate ( vals [ ] Value , args Expressions , enh * Eval Node Helper , is Counter bool , is Rate bool ) Vector { ms : = args [ 0 ] . ( * Matrix Selector ) var ( matrix = vals [ 0 ] . ( Matrix ) range Start = enh . ts - duration Milliseconds ( ms . Range + ms . Offset ) range End = enh . ts - duration Milliseconds ( ms . Offset ) ) for _ , samples : = range matrix { } var ( counter Correction float 6 4 last Value float 6 4 ) for _ , sample : = range samples . Points { if is Counter & & sample . V < last Value { counter Correction + = last Value } last Value = sample . V } result Value : = last Value - samples . Points [ 0 ] . V + counter Correction duration To End : = float 6 4 ( range End - samples . Points [ len ( samples . Points ) - 1 ] . T ) / 1 0 0 0 sampled Interval : = float 6 4 ( samples . Points [ len ( samples . Points ) - 1 ] . T - samples . Points [ 0 ] . T ) / 1 0 0 0 average Duration Between Samples : = sampled Interval / float 6 4 ( len ( samples . Points ) - 1 ) if is Counter & & result Value > 0 & & samples . Points [ 0 ] . V > = 0 { if duration To Zero < duration To Start { duration To Start = duration To Zero } } extrapolate To Interval : = sampled Interval if duration To Start < extrapolation Threshold { extrapolate To Interval + = duration To Start } else { extrapolate To Interval + = average Duration Between Samples / 2 } if duration To End < extrapolation Threshold { extrapolate To Interval + = duration To End } else { extrapolate To Interval + = average Duration Between Samples / 2 } result Value = result Value * ( extrapolate To Interval / sampled Interval ) if is Rate { result Value = result Value / ms . Range . Seconds ( ) } enh . out = append ( enh . out , Sample { Point : Point { V : result Value } , } ) } return enh . out } 
func func Delta ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return extrapolated Rate ( vals , args , enh , false , false ) } 
func func Rate ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return extrapolated Rate ( vals , args , enh , true , true ) } 
func func Increase ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return extrapolated Rate ( vals , args , enh , true , false ) } 
func func Irate ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return instant Value ( vals , enh . out , true ) } 
func func Idelta ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return instant Value ( vals , enh . out , false ) } 
func calc Trend Value ( i int , sf , tf , s 0 , s 1 , b float 6 4 ) float 6 4 { if i = = 0 { return b } x : = tf * ( s 1 - s 0 ) y : = ( 1 - tf ) * b return x + y } 
func func Holt Winters ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { mat : = vals [ 0 ] . ( Matrix ) } if tf < = 0 | | tf > = 1 { panic ( errors . Errorf ( " " , tf ) ) } var l int for _ , samples : = range mat { l = len ( samples . Points ) } var s 0 , s 1 , b float 6 4 b = samples . Points [ 1 ] . V - samples . Points [ 0 ] . V for i : = 1 ; i < l ; i + + { y = ( 1 - sf ) * ( s 1 + b ) s 0 , s 1 = s 1 , x + y } enh . out = append ( enh . out , Sample { Point : Point { V : s 1 } , } ) } return enh . out } 
func func Sort ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { sort . Sort ( sort . Reverse ( by Value Sorter ) ) return Vector ( by Value Sorter ) } 
func func Sort Desc ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { sort . Sort ( sort . Reverse ( by Value Sorter ) ) return Vector ( by Value Sorter ) } 
func func Clamp Max ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { vec : = vals [ 0 ] . ( Vector ) max : = vals [ 1 ] . ( Vector ) [ 0 ] . Point . V for _ , el : = range vec { enh . out = append ( enh . out , Sample { Metric : enh . drop Metric Name ( el . Metric ) , Point : Point { V : math . Min ( max , el . V ) } , } ) } return enh . out } 
func func Clamp Min ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { vec : = vals [ 0 ] . ( Vector ) min : = vals [ 1 ] . ( Vector ) [ 0 ] . Point . V for _ , el : = range vec { enh . out = append ( enh . out , Sample { Metric : enh . drop Metric Name ( el . Metric ) , Point : Point { V : math . Max ( min , el . V ) } , } ) } return enh . out } 
func func Round ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { vec : = vals [ 0 ] . ( Vector ) if len ( args ) > = 2 { to Nearest = vals [ 1 ] . ( Vector ) [ 0 ] . Point . V } for _ , el : = range vec { v : = math . Floor ( el . V * to Nearest Inverse + 0 . 5 ) / to Nearest Inverse enh . out = append ( enh . out , Sample { Metric : enh . drop Metric Name ( el . Metric ) , Point : Point { V : v } , } ) } return enh . out } 
func func Scalar ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { v : = vals [ 0 ] . ( Vector ) if len ( v ) ! = 1 { return append ( enh . out , Sample { Point : Point { V : math . Na N ( ) } , } ) } return append ( enh . out , Sample { Point : Point { V : v [ 0 ] . V } , } ) } 
func func Count Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return aggr Over Time ( vals , enh , func ( values [ ] Point ) float 6 4 { return float 6 4 ( len ( values ) ) } ) } 
func func Max Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return aggr Over Time ( vals , enh , func ( values [ ] Point ) float 6 4 { max : = values [ 0 ] . V for _ , v : = range values { if v . V > max | | math . Is Na N ( max ) { max = v . V } } return max } ) } 
func func Min Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return aggr Over Time ( vals , enh , func ( values [ ] Point ) float 6 4 { min : = values [ 0 ] . V for _ , v : = range values { if v . V < min | | math . Is Na N ( min ) { min = v . V } } return min } ) } 
func func Sum Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return aggr Over Time ( vals , enh , func ( values [ ] Point ) float 6 4 { var sum float 6 4 for _ , v : = range values { sum + = v . V } return sum } ) } 
func func Quantile Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { q : = vals [ 0 ] . ( Vector ) [ 0 ] . V mat : = vals [ 1 ] . ( Matrix ) for _ , el : = range mat { if len ( el . Points ) = = 0 { continue } values : = make ( vector By Value Heap , 0 , len ( el . Points ) ) for _ , v : = range el . Points { values = append ( values , Sample { Point : Point { V : v . V } } ) } enh . out = append ( enh . out , Sample { Point : Point { V : quantile ( q , values ) } , } ) } return enh . out } 
func func Stddev Over Time ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return aggr Over Time ( vals , enh , func ( values [ ] Point ) float 6 4 { var aux , count , mean float 6 4 for _ , v : = range values { count + + delta : = v . V - mean mean + = delta / count aux + = delta * ( v . V - mean ) } return math . Sqrt ( aux / count ) } ) } 
func func Absent ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { if len ( vals [ 0 ] . ( Vector ) ) > 0 { return enh . out } m : = [ ] labels . Label { } if vs , ok : = args [ 0 ] . ( * Vector Selector ) ; ok { for _ , ma : = range vs . Label Matchers { if ma . Type = = labels . Match Equal & & ma . Name ! = labels . Metric Name { m = append ( m , labels . Label { Name : ma . Name , Value : ma . Value } ) } } } return append ( enh . out , Sample { Metric : labels . New ( m . . . ) , Point : Point { V : 1 } , } ) } 
func func Abs ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Abs ) } 
func func Ceil ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Ceil ) } 
func func Floor ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Floor ) } 
func func Exp ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Exp ) } 
func func Sqrt ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Sqrt ) } 
func func Ln ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Log ) } 
func func Log 2 ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Log 2 ) } 
func func Log 1 0 ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return simple Func ( vals , enh , math . Log 1 0 ) } 
func func Timestamp ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { vec : = vals [ 0 ] . ( Vector ) for _ , el : = range vec { enh . out = append ( enh . out , Sample { Metric : enh . drop Metric Name ( el . Metric ) , Point : Point { V : float 6 4 ( el . T ) / 1 0 0 0 } , } ) } return enh . out } 
func linear Regression ( samples [ ] Point , intercept Time int 6 4 ) ( slope , intercept float 6 4 ) { var ( n float 6 4 sum X , sum Y float 6 4 sum XY , sum X 2 float 6 4 ) for _ , sample : = range samples { x : = float 6 4 ( sample . T - intercept Time ) / 1e 3 n + = 1 . 0 sum Y + = sample . V sum X + = x sum XY + = x * sample . V sum X 2 + = x * x } cov XY : = sum XY - sum X * sum Y / n var X : = sum X 2 - sum X * sum X / n slope = cov XY / var X intercept = sum Y / n - slope * sum X / n return slope , intercept } 
func func Deriv ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { mat : = vals [ 0 ] . ( Matrix ) for _ , samples : = range mat { } enh . out = append ( enh . out , Sample { Point : Point { V : slope } , } ) } return enh . out } 
func func Predict Linear ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { mat : = vals [ 0 ] . ( Matrix ) duration : = vals [ 1 ] . ( Vector ) [ 0 ] . V for _ , samples : = range mat { } slope , intercept : = linear Regression ( samples . Points , enh . ts ) enh . out = append ( enh . out , Sample { Point : Point { V : slope * duration + intercept } , } ) } return enh . out } 
func func Histogram Quantile ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { q : = vals [ 0 ] . ( Vector ) [ 0 ] . V in Vec : = vals [ 1 ] . ( Vector ) sigf : = enh . signature Func ( false , excluded Labels . . . ) if enh . signature To Metric With Buckets = = nil { enh . signature To Metric With Buckets = map [ uint 6 4 ] * metric With Buckets { } } else { for _ , v : = range enh . signature To Metric With Buckets { v . buckets = v . buckets [ : 0 ] } } for _ , el : = range in Vec { upper Bound , err : = strconv . Parse Float ( el . Metric . Get ( model . Bucket Label ) , 6 4 , ) if err ! = nil { } hash : = sigf ( el . Metric ) mb , ok : = enh . signature To Metric With Buckets [ hash ] if ! ok { el . Metric = labels . New Builder ( el . Metric ) . Del ( labels . Bucket Label , labels . Metric Name ) . Labels ( ) mb = & metric With Buckets { el . Metric , nil } enh . signature To Metric With Buckets [ hash ] = mb } mb . buckets = append ( mb . buckets , bucket { upper Bound , el . V } ) } for _ , mb : = range enh . signature To Metric With Buckets { if len ( mb . buckets ) > 0 { enh . out = append ( enh . out , Sample { Metric : mb . metric , Point : Point { V : bucket Quantile ( q , mb . buckets ) } , } ) } } return enh . out } 
func func Resets ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { in : = vals [ 0 ] . ( Matrix ) for _ , samples : = range in { resets : = 0 prev : = samples . Points [ 0 ] . V for _ , sample : = range samples . Points [ 1 : ] { current : = sample . V if current < prev { resets + + } prev = current } enh . out = append ( enh . out , Sample { Point : Point { V : float 6 4 ( resets ) } , } ) } return enh . out } 
func func Changes ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { in : = vals [ 0 ] . ( Matrix ) for _ , samples : = range in { changes : = 0 prev : = samples . Points [ 0 ] . V for _ , sample : = range samples . Points [ 1 : ] { current : = sample . V if current ! = prev & & ! ( math . Is Na N ( current ) & & math . Is Na N ( prev ) ) { changes + + } prev = current } enh . out = append ( enh . out , Sample { Point : Point { V : float 6 4 ( changes ) } , } ) } return enh . out } 
func func Label Replace ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { var ( vector = vals [ 0 ] . ( Vector ) dst = args [ 1 ] . ( * String Literal ) . Val repl = args [ 2 ] . ( * String Literal ) . Val src = args [ 3 ] . ( * String Literal ) . Val regex Str = args [ 4 ] . ( * String Literal ) . Val ) if enh . regex = = nil { var err error enh . regex , err = regexp . Compile ( " " + regex Str + " " ) if err ! = nil { panic ( errors . Errorf ( " " , regex Str ) ) } if ! model . Label Name RE . Match String ( dst ) { panic ( errors . Errorf ( " " , dst ) ) } enh . dmn = make ( map [ uint 6 4 ] labels . Labels , len ( enh . out ) ) } for _ , el : = range vector { h : = el . Metric . Hash ( ) var out Metric labels . Labels if l , ok : = enh . dmn [ h ] ; ok { out Metric = l } else { src Val : = el . Metric . Get ( src ) indexes : = enh . regex . Find String Submatch Index ( src Val ) if indexes = = nil { enh . dmn [ h ] = out Metric } else { res : = enh . regex . Expand String ( [ ] byte { } , repl , src Val , indexes ) lb : = labels . New Builder ( el . Metric ) . Del ( dst ) if len ( res ) > 0 { lb . Set ( dst , string ( res ) ) } out Metric = lb . Labels ( ) enh . dmn [ h ] = out Metric } } enh . out = append ( enh . out , Sample { Metric : out Metric , Point : Point { V : el . Point . V } , } ) } return enh . out } 
func func Vector ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return append ( enh . out , Sample { Metric : labels . Labels { } , Point : Point { V : vals [ 0 ] . ( Vector ) [ 0 ] . V } , } ) } 
func func Label Join ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { var ( vector = vals [ 0 ] . ( Vector ) dst = args [ 1 ] . ( * String Literal ) . Val sep = args [ 2 ] . ( * String Literal ) . Val src Labels = make ( [ ] string , len ( args ) - 3 ) ) if enh . dmn = = nil { enh . dmn = make ( map [ uint 6 4 ] labels . Labels , len ( enh . out ) ) } for i : = 3 ; i < len ( args ) ; i + + { src : = args [ i ] . ( * String Literal ) . Val if ! model . Label Name ( src ) . Is Valid ( ) { panic ( errors . Errorf ( " " , src ) ) } src Labels [ i - 3 ] = src } if ! model . Label Name ( dst ) . Is Valid ( ) { panic ( errors . Errorf ( " " , dst ) ) } src Vals : = make ( [ ] string , len ( src Labels ) ) for _ , el : = range vector { h : = el . Metric . Hash ( ) var out Metric labels . Labels if l , ok : = enh . dmn [ h ] ; ok { out Metric = l } else { for i , src : = range src Labels { src Vals [ i ] = el . Metric . Get ( src ) } lb : = labels . New Builder ( el . Metric ) strval : = strings . Join ( src Vals , sep ) if strval = = " " { lb . Del ( dst ) } else { lb . Set ( dst , strval ) } out Metric = lb . Labels ( ) enh . dmn [ h ] = out Metric } enh . out = append ( enh . out , Sample { Metric : out Metric , Point : Point { V : el . Point . V } , } ) } return enh . out } 
func date Wrapper ( vals [ ] Value , enh * Eval Node Helper , f func ( time . Time ) float 6 4 ) Vector { if len ( vals ) = = 0 { return append ( enh . out , Sample { Metric : labels . Labels { } , Point : Point { V : f ( time . Unix ( enh . ts / 1 0 0 0 , 0 ) . UTC ( ) ) } , } ) } for _ , el : = range vals [ 0 ] . ( Vector ) { t : = time . Unix ( int 6 4 ( el . V ) , 0 ) . UTC ( ) enh . out = append ( enh . out , Sample { Metric : enh . drop Metric Name ( el . Metric ) , Point : Point { V : f ( t ) } , } ) } return enh . out } 
func func Days In Month ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( 3 2 - time . Date ( t . Year ( ) , t . Month ( ) , 3 2 , 0 , 0 , 0 , 0 , time . UTC ) . Day ( ) ) } ) } 
func func Day Of Month ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Day ( ) ) } ) } 
func func Day Of Week ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Weekday ( ) ) } ) } 
func func Hour ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Hour ( ) ) } ) } 
func func Minute ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Minute ( ) ) } ) } 
func func Month ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Month ( ) ) } ) } 
func func Year ( vals [ ] Value , args Expressions , enh * Eval Node Helper ) Vector { return date Wrapper ( vals , enh , func ( t time . Time ) float 6 4 { return float 6 4 ( t . Year ( ) ) } ) } 
func get Function ( name string ) ( * Function , bool ) { function , ok : = functions [ name ] return function , ok } 
func ( c * Service Discovery Config ) Validate ( ) error { for _ , cfg : = range c . Azure SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Consul SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . DNSSDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . EC 2SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . File SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . GCESDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Kubernetes SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Marathon SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Nerve SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Openstack SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Serverset SDConfigs { if cfg = = nil { return errors . New ( " " ) } } for _ , cfg : = range c . Static Configs { if cfg = = nil { return errors . New ( " " ) } } return nil } 
func Dedupe ( next log . Logger , repeat time . Duration ) * Deduper { d : = & Deduper { next : next , repeat : repeat , quit : make ( chan struct { } ) , seen : map [ string ] time . Time { } , } go d . run ( ) return d } 
func ( d * Deduper ) Log ( keyvals . . . interface { } ) error { line , err : = encode ( keyvals . . . ) if err ! = nil { return err } d . mtx . RLock ( ) last , ok : = d . seen [ line ] d . mtx . RUnlock ( ) if ok & & time . Since ( last ) < d . repeat { return nil } d . mtx . Lock ( ) if len ( d . seen ) < max Entries { d . seen [ line ] = time . Now ( ) } d . mtx . Unlock ( ) return d . next . Log ( keyvals . . . ) } 
func ( g * Gate ) Start ( ctx context . Context ) error { select { case < - ctx . Done ( ) : return ctx . Err ( ) case g . ch < - struct { } { } : return nil } } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if c . Account = = " " { return errors . New ( " " ) } if c . DNSSuffix = = " " { return errors . New ( " " ) } if c . Endpoint = = " " { return errors . New ( " " ) } if c . Refresh Interval < = 0 { return errors . New ( " " ) } return nil } 
func New ( logger log . Logger , conf * SDConfig ) ( * Discovery , error ) { tls , err : = config _util . New TLSConfig ( & conf . TLSConfig ) if err ! = nil { return nil , err } transport : = & http . Transport { TLSClient Config : tls , Dial Context : conntrack . New Dial Context Func ( conntrack . Dial With Tracing ( ) , conntrack . Dial With Name ( " " ) , ) , } client : = & http . Client { Transport : transport } d : = & Discovery { client : client , interval : time . Duration ( conf . Refresh Interval ) , sd Config : conf , } d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( conf . Refresh Interval ) , d . refresh , ) return d , nil } 
func with Stack Tracer ( h http . Handler , l log . Logger ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { defer func ( ) { if err : = recover ( ) ; err ! = nil { const size = 6 4 < < 1 0 buf : = make ( [ ] byte , size ) buf = buf [ : runtime . Stack ( buf , false ) ] level . Error ( l ) . Log ( " " , " " , " " , r . Remote Addr , " " , r . URL , " " , err , " " , buf ) panic ( err ) } } ( ) h . Serve HTTP ( w , r ) } ) } 
func ( h * Handler ) Apply Config ( conf * config . Config ) error { h . mtx . Lock ( ) defer h . mtx . Unlock ( ) h . config = conf return nil } 
func New ( logger log . Logger , o * Options ) * Handler { router : = route . New ( ) . With Instrumentation ( instrument Handler ) cwd , err : = os . Getwd ( ) if err ! = nil { cwd = " " } if logger = = nil { logger = log . New Nop Logger ( ) } h : = & Handler { logger : logger , router : router , quit Ch : make ( chan struct { } ) , reload Ch : make ( chan chan error ) , options : o , version Info : o . Version , birth : time . Now ( ) , cwd : cwd , flags Map : o . Flags , context : o . Context , scrape Manager : o . Scrape Manager , rule Manager : o . Rule Manager , query Engine : o . Query Engine , tsdb : o . TSDB , storage : o . Storage , notifier : o . Notifier , now : model . Now , ready : 0 , } h . api V 1 = api _v 1 . New API ( h . query Engine , h . storage , h . scrape Manager , h . notifier , func ( ) config . Config { h . mtx . RLock ( ) defer h . mtx . RUnlock ( ) return * h . config } , o . Flags , h . test Ready , func ( ) api _v 1 . TSDBAdmin { return h . options . TSDB ( ) } , h . options . Enable Admin API , logger , h . rule Manager , h . options . Remote Read Sample Limit , h . options . Remote Read Concurrency Limit , h . options . CORSOrigin , ) if o . Route Prefix ! = " " { } ) router = router . With Prefix ( o . Route Prefix ) } readyf : = h . test Ready router . Get ( " " , func ( w http . Response Writer , r * http . Request ) { http . Redirect ( w , r , path . Join ( o . External URL . Path , " " ) , http . Status Found ) } ) router . Get ( " " , readyf ( h . alerts ) ) router . Get ( " " , readyf ( h . graph ) ) router . Get ( " " , readyf ( h . status ) ) router . Get ( " " , readyf ( h . flags ) ) router . Get ( " " , readyf ( h . serve Config ) ) router . Get ( " " , readyf ( h . rules ) ) router . Get ( " " , readyf ( h . targets ) ) router . Get ( " " , readyf ( h . version ) ) router . Get ( " " , readyf ( h . service Discovery ) ) router . Get ( " " , promhttp . Handler ( ) . Serve HTTP ) router . Get ( " " , readyf ( httputil . Compression Handler { Handler : http . Handler Func ( h . federation ) , } . Serve HTTP ) ) router . Get ( " " , readyf ( h . consoles ) ) router . Get ( " " , func ( w http . Response Writer , r * http . Request ) { r . URL . Path = path . Join ( " " , route . Param ( r . Context ( ) , " " ) ) fs : = http . File Server ( ui . Assets ) fs . Serve HTTP ( w , r ) } ) if o . User Assets Path ! = " " { router . Get ( " " , route . File Serve ( o . User Assets Path ) ) } if o . Enable Lifecycle { router . Post ( " " , h . quit ) router . Put ( " " , h . quit ) router . Post ( " " , h . reload ) router . Put ( " " , h . reload ) } else { router . Post ( " " , func ( w http . Response Writer , _ * http . Request ) { w . Write Header ( http . Status Forbidden ) w . Write ( [ ] byte ( " " ) ) } ) router . Post ( " " , func ( w http . Response Writer , _ * http . Request ) { w . Write Header ( http . Status Forbidden ) w . Write ( [ ] byte ( " " ) ) } ) } router . Get ( " " , func ( w http . Response Writer , _ * http . Request ) { w . Write Header ( http . Status Method Not Allowed ) w . Write ( [ ] byte ( " " ) ) } ) router . Get ( " " , func ( w http . Response Writer , _ * http . Request ) { w . Write Header ( http . Status Method Not Allowed ) w . Write ( [ ] byte ( " " ) ) } ) router . Get ( " " , serve Debug ) router . Post ( " " , serve Debug ) router . Get ( " " , func ( w http . Response Writer , r * http . Request ) { w . Write Header ( http . Status OK ) fmt . Fprintf ( w , " \n " ) } ) router . Get ( " " , readyf ( func ( w http . Response Writer , r * http . Request ) { w . Write Header ( http . Status OK ) fmt . Fprintf ( w , " \n " ) } ) ) return h } 
func ( h * Handler ) is Ready ( ) bool { ready : = atomic . Load Uint 3 2 ( & h . ready ) return ready > 0 } 
func ( h * Handler ) Run ( ctx context . Context ) error { level . Info ( h . logger ) . Log ( " " , " " , " " , h . options . Listen Address ) listener , err : = net . Listen ( " " , h . options . Listen Address ) if err ! = nil { return err } listener = netutil . Limit Listener ( listener , h . options . Max Connections ) var ( m = cmux . New ( listener ) httpl = m . Match ( cmux . HTTP 1Fast ( ) ) grpc Srv = grpc . New Server ( ) ) av 2 : = api _v 2 . New ( h . options . TSDB , h . options . Enable Admin API , ) av 2 . Register GRPC ( grpc Srv ) hh , err : = av 2 . HTTPHandler ( ctx , h . options . Listen Address ) if err ! = nil { return err } hh Func : = h . test Ready Handler ( hh ) operation Name : = nethttp . Operation Name Func ( func ( r * http . Request ) string { return fmt . Sprintf ( " " , r . Method , r . URL . Path ) } ) mux : = http . New Serve Mux ( ) mux . Handle ( " " , h . router ) av 1 : = route . New ( ) . With Instrumentation ( instrument Handler With Prefix ( " " ) ) h . api V 1 . Register ( av 1 ) api Path : = " " if h . options . Route Prefix ! = " " { api Path = h . options . Route Prefix + api Path level . Info ( h . logger ) . Log ( " " , " " , " " , h . options . Route Prefix ) } mux . Handle ( api Path + " " , http . Strip Prefix ( api Path + " " , av 1 ) ) mux . Handle ( api Path + " " , http . Strip Prefix ( api Path , http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { httputil . Set CORS ( w , h . options . CORSOrigin , r ) hh Func ( w , r ) } ) , ) ) errlog : = stdlog . New ( log . New Stdlib Adapter ( level . Error ( h . logger ) ) , " " , 0 ) http Srv : = & http . Server { Handler : with Stack Tracer ( nethttp . Middleware ( opentracing . Global Tracer ( ) , mux , operation Name ) , h . logger ) , Error Log : errlog , Read Timeout : h . options . Read Timeout , } err Ch : = make ( chan error ) go func ( ) { err Ch < - http Srv . Serve ( httpl ) } ( ) go func ( ) { err Ch < - grpc Srv . Serve ( grpcl ) } ( ) go func ( ) { err Ch < - m . Serve ( ) } ( ) select { case e : = < - err Ch : return e case < - ctx . Done ( ) : http Srv . Shutdown ( ctx ) grpc Srv . Graceful Stop ( ) return nil } } 
func New ( fs http . File System , t time . Time ) http . File System { return & timefs { fs : fs , t : t } } 
func ( tv Tag Value ) Marshal JSON ( ) ( [ ] byte , error ) { length : = len ( tv ) result . Write Byte ( ' " ' ) for i : = 0 ; i < length ; i + + { b : = tv [ i ] switch { case ( b > = ' - ' & & b < = ' 9 ' ) | | case b = = ' _ ' : result . Write String ( " " ) case b = = ' : ' : result . Write String ( " " ) default : result . Write String ( fmt . Sprintf ( " " , b ) ) } } result . Write Byte ( ' " ' ) return result . Bytes ( ) , nil } 
func ( tv * Tag Value ) Unmarshal JSON ( json [ ] byte ) error { escape Level : = 0 var parsed Byte byte for i , b : = range json { if i = = 0 { if b ! = ' " ' { return errors . Errorf ( " \ " " , b ) } continue } if i = = len ( json ) - 1 { if b ! = ' " ' { return errors . Errorf ( " \ " " , b ) } break } switch escape Level { case 0 : if b = = ' _ ' { escape Level = 1 continue } result . Write Byte ( b ) case 1 : switch { case b = = ' _ ' : result . Write Byte ( ' _ ' ) escape Level = 0 case b = = ' . ' : result . Write Byte ( ' : ' ) escape Level = 0 case b > = ' 0 ' & & b < = ' 9 ' : parsed Byte = ( b - 4 8 ) < < 4 escape Level = 2 case b > = 'A ' & & b < = 'F ' : escape Level = 2 default : return errors . Errorf ( " " , i , b , ) } case 2 : switch { case b > = ' 0 ' & & b < = ' 9 ' : parsed Byte + = b - 4 8 case b > = 'A ' & & b < = 'F ' : default : return errors . Errorf ( " " , i , b , ) } result . Write Byte ( parsed Byte ) escape Level = 0 default : panic ( " " ) } } * tv = Tag Value ( result . String ( ) ) return nil } 
func New Client ( logger log . Logger , conf influx . HTTPConfig , db string , rp string ) * Client { c , err : = influx . New HTTPClient ( conf ) os . Exit ( 1 ) } if logger = = nil { logger = log . New Nop Logger ( ) } return & Client { logger : logger , client : c , database : db , retention Policy : rp , ignored Samples : prometheus . New Counter ( prometheus . Counter Opts { Name : " " , Help : " " , } , ) , } } 
func ( c * Client ) Write ( samples model . Samples ) error { points : = make ( [ ] * influx . Point , 0 , len ( samples ) ) for _ , s : = range samples { v : = float 6 4 ( s . Value ) if math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) c . ignored Samples . Inc ( ) continue } p , err : = influx . New Point ( string ( s . Metric [ model . Metric Name Label ] ) , tags From Metric ( s . Metric ) , map [ string ] interface { } { " " : v } , s . Timestamp . Time ( ) , ) if err ! = nil { return err } points = append ( points , p ) } bps , err : = influx . New Batch Points ( influx . Batch Points Config { Precision : " " , Database : c . database , Retention Policy : c . retention Policy , } ) if err ! = nil { return err } bps . Add Points ( points ) return c . client . Write ( bps ) } 
func merge Samples ( a , b [ ] prompb . Sample ) [ ] prompb . Sample { result : = make ( [ ] prompb . Sample , 0 , len ( a ) + len ( b ) ) i , j : = 0 , 0 for i < len ( a ) & & j < len ( b ) { if a [ i ] . Timestamp < b [ j ] . Timestamp { result = append ( result , a [ i ] ) i + + } else if a [ i ] . Timestamp > b [ j ] . Timestamp { result = append ( result , b [ j ] ) j + + } else { result = append ( result , a [ i ] ) i + + j + + } } result = append ( result , a [ i : ] . . . ) result = append ( result , b [ j : ] . . . ) return result } 
func ( c * Client ) Describe ( ch chan < - * prometheus . Desc ) { ch < - c . ignored Samples . Desc ( ) } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if len ( c . Servers ) = = 0 { return errors . New ( " " ) } if len ( c . Auth Token ) > 0 & & len ( c . Auth Token File ) > 0 { return errors . New ( " " ) } if c . HTTPClient Config . Basic Auth ! = nil & & ( len ( c . Auth Token ) > 0 | | len ( c . Auth Token File ) > 0 ) { return errors . New ( " " ) } if ( len ( c . HTTPClient Config . Bearer Token ) > 0 | | len ( c . HTTPClient Config . Bearer Token File ) > 0 ) & & ( len ( c . Auth Token ) > 0 | | len ( c . Auth Token File ) > 0 ) { return errors . New ( " " ) } return c . HTTPClient Config . Validate ( ) } 
func New Discovery ( conf SDConfig , logger log . Logger ) ( * Discovery , error ) { rt , err : = config _util . New Round Tripper From Config ( conf . HTTPClient Config , " " ) if err ! = nil { return nil , err } if len ( conf . Auth Token ) > 0 { rt , err = new Auth Token Round Tripper ( conf . Auth Token , rt ) } else if len ( conf . Auth Token File ) > 0 { rt , err = new Auth Token File Round Tripper ( conf . Auth Token File , rt ) } if err ! = nil { return nil , err } d : = & Discovery { client : & http . Client { Transport : rt } , servers : conf . Servers , apps Client : fetch Apps , } d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( conf . Refresh Interval ) , d . refresh , ) return d , nil } 
func new Auth Token Round Tripper ( token config _util . Secret , rt http . Round Tripper ) ( http . Round Tripper , error ) { return & auth Token Round Tripper { token , rt } , nil } 
func new Auth Token File Round Tripper ( token File string , rt http . Round Tripper ) ( http . Round Tripper , error ) { if err ! = nil { return nil , errors . Wrapf ( err , " " , token File ) } return & auth Token File Round Tripper { token File , rt } , nil } 
func ( app app ) is Container Net ( ) bool { return len ( app . Networks ) > 0 & & app . Networks [ 0 ] . Mode = = " " } 
func fetch Apps ( ctx context . Context , client * http . Client , url string ) ( * app List , error ) { request , err : = http . New Request ( " " , url , nil ) if err ! = nil { return nil , err } request = request . With Context ( ctx ) resp , err : = client . Do ( request ) if err ! = nil { return nil , err } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) if ( resp . Status Code < 2 0 0 ) | | ( resp . Status Code > = 3 0 0 ) { return nil , errors . Errorf ( " " , resp . Status Code ) } var apps app List err = json . New Decoder ( resp . Body ) . Decode ( & apps ) if err ! = nil { return nil , errors . Wrapf ( err , " " , url ) } return & apps , nil } 
func random Apps URL ( servers [ ] string ) string { return fmt . Sprintf ( " " , server , app List Path ) } 
func apps To Target Groups ( apps * app List ) map [ string ] * targetgroup . Group { tgroups : = map [ string ] * targetgroup . Group { } for _ , a : = range apps . Apps { group : = create Target Group ( & a ) tgroups [ group . Source ] = group } return tgroups } 
func target Endpoint ( task * task , port uint 3 2 , container Net bool ) string { var host string } else { host = task . Host } return net . Join Host Port ( host , fmt . Sprintf ( " " , port ) ) } 
func extract Port Mapping ( port Mappings [ ] port Mapping , container Net bool ) ( [ ] uint 3 2 , [ ] map [ string ] string ) { ports : = make ( [ ] uint 3 2 , len ( port Mappings ) ) labels : = make ( [ ] map [ string ] string , len ( port Mappings ) ) for i : = 0 ; i < len ( port Mappings ) ; i + + { labels [ i ] = port Mappings [ i ] . Labels if container Net { } else { } } return ports , labels } 
func Load ( s string ) ( * Config , error ) { cfg : = & Config { } err : = yaml . Unmarshal Strict ( [ ] byte ( s ) , cfg ) if err ! = nil { return nil , err } cfg . original = s return cfg , nil } 
func Load File ( filename string ) ( * Config , error ) { content , err : = ioutil . Read File ( filename ) if err ! = nil { return nil , err } cfg , err : = Load ( string ( content ) ) if err ! = nil { return nil , errors . Wrapf ( err , " " , filename ) } resolve Filepaths ( filepath . Dir ( filename ) , cfg ) return cfg , nil } 
func resolve Filepaths ( base Dir string , cfg * Config ) { join : = func ( fp string ) string { if len ( fp ) > 0 & & ! filepath . Is Abs ( fp ) { fp = filepath . Join ( base Dir , fp ) } return fp } for i , rf : = range cfg . Rule Files { cfg . Rule Files [ i ] = join ( rf ) } tls Paths : = func ( cfg * config _util . TLSConfig ) { cfg . CAFile = join ( cfg . CAFile ) cfg . Cert File = join ( cfg . Cert File ) cfg . Key File = join ( cfg . Key File ) } client Paths : = func ( scfg * config _util . HTTPClient Config ) { if scfg . Basic Auth ! = nil { scfg . Basic Auth . Password File = join ( scfg . Basic Auth . Password File ) } scfg . Bearer Token File = join ( scfg . Bearer Token File ) tls Paths ( & scfg . TLSConfig ) } sd Paths : = func ( cfg * sd _config . Service Discovery Config ) { for _ , kcfg : = range cfg . Kubernetes SDConfigs { client Paths ( & kcfg . HTTPClient Config ) } for _ , mcfg : = range cfg . Marathon SDConfigs { mcfg . Auth Token File = join ( mcfg . Auth Token File ) client Paths ( & mcfg . HTTPClient Config ) } for _ , consulcfg : = range cfg . Consul SDConfigs { tls Paths ( & consulcfg . TLSConfig ) } for _ , cfg : = range cfg . Openstack SDConfigs { tls Paths ( & cfg . TLSConfig ) } for _ , cfg : = range cfg . Triton SDConfigs { tls Paths ( & cfg . TLSConfig ) } for _ , filecfg : = range cfg . File SDConfigs { for i , fn : = range filecfg . Files { filecfg . Files [ i ] = join ( fn ) } } } for _ , cfg : = range cfg . Scrape Configs { client Paths ( & cfg . HTTPClient Config ) sd Paths ( & cfg . Service Discovery Config ) } for _ , cfg : = range cfg . Alerting Config . Alertmanager Configs { client Paths ( & cfg . HTTPClient Config ) sd Paths ( & cfg . Service Discovery Config ) } for _ , cfg : = range cfg . Remote Read Configs { client Paths ( & cfg . HTTPClient Config ) } for _ , cfg : = range cfg . Remote Write Configs { client Paths ( & cfg . HTTPClient Config ) } } 
func ( c * Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Config if err : = unmarshal ( ( * plain ) ( c ) ) ; err ! = nil { return err } } for _ , rf : = range c . Rule Files { if ! pat Rule Path . Match String ( rf ) { return errors . Errorf ( " " , rf ) } } for _ , scfg : = range c . Scrape Configs { if scfg = = nil { return errors . New ( " " ) } } if scfg . Scrape Timeout > scfg . Scrape Interval { return errors . Errorf ( " " , scfg . Job Name ) } if scfg . Scrape Timeout = = 0 { if c . Global Config . Scrape Timeout > scfg . Scrape Interval { scfg . Scrape Timeout = scfg . Scrape Interval } else { scfg . Scrape Timeout = c . Global Config . Scrape Timeout } } if _ , ok : = job Names [ scfg . Job Name ] ; ok { return errors . Errorf ( " " , scfg . Job Name ) } job Names [ scfg . Job Name ] = struct { } { } } for _ , rwcfg : = range c . Remote Write Configs { if rwcfg = = nil { return errors . New ( " " ) } } for _ , rrcfg : = range c . Remote Read Configs { if rrcfg = = nil { return errors . New ( " " ) } } return nil } 
func ( c * Global Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { type plain Global Config if err : = unmarshal ( ( * plain ) ( gc ) ) ; err ! = nil { return err } for _ , l : = range gc . External Labels { if ! model . Label Name ( l . Name ) . Is Valid ( ) { return errors . Errorf ( " " , l . Name ) } if ! model . Label Value ( l . Value ) . Is Valid ( ) { return errors . Errorf ( " " , l . Value ) } } } if gc . Scrape Timeout > gc . Scrape Interval { return errors . New ( " " ) } if gc . Scrape Timeout = = 0 { if Default Global Config . Scrape Timeout > gc . Scrape Interval { gc . Scrape Timeout = gc . Scrape Interval } else { gc . Scrape Timeout = Default Global Config . Scrape Timeout } } if gc . Evaluation Interval = = 0 { gc . Evaluation Interval = Default Global Config . Evaluation Interval } * c = * gc return nil } 
func ( c * Global Config ) is Zero ( ) bool { return c . External Labels = = nil & & c . Scrape Interval = = 0 & & c . Scrape Timeout = = 0 & & c . Evaluation Interval = = 0 } 
func ( c * Scrape Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Scrape Config type plain Scrape Config err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if len ( c . Job Name ) = = 0 { return errors . New ( " " ) } } } } } } } for _ , rlcfg : = range c . Relabel Configs { if rlcfg = = nil { return errors . New ( " " ) } } for _ , rlcfg : = range c . Metric Relabel Configs { if rlcfg = = nil { return errors . New ( " " ) } } } return nil } 
func ( c * Alerting Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { type plain Alerting Config if err : = unmarshal ( ( * plain ) ( c ) ) ; err ! = nil { return err } for _ , rlcfg : = range c . Alert Relabel Configs { if rlcfg = = nil { return errors . New ( " " ) } } return nil } 
func Check Target Address ( address model . Label Value ) error { } return nil } 
func ( c * Remote Write Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Remote Write Config type plain Remote Write Config if err : = unmarshal ( ( * plain ) ( c ) ) ; err ! = nil { return err } if c . URL = = nil { return errors . New ( " " ) } for _ , rlcfg : = range c . Write Relabel Configs { if rlcfg = = nil { return errors . New ( " " ) } } } 
func ( c * Remote Read Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Remote Read Config type plain Remote Read Config if err : = unmarshal ( ( * plain ) ( c ) ) ; err ! = nil { return err } if c . URL = = nil { return errors . New ( " " ) } } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if strings . Trim Space ( c . Server ) = = " " { return errors . New ( " " ) } return nil } 
func New Discovery ( conf * SDConfig , logger log . Logger ) ( * Discovery , error ) { if logger = = nil { logger = log . New Nop Logger ( ) } tls , err : = config _util . New TLSConfig ( & conf . TLSConfig ) if err ! = nil { return nil , err } transport : = & http . Transport { Idle Conn Timeout : 5 * time . Duration ( conf . Refresh Interval ) , TLSClient Config : tls , Dial Context : conntrack . New Dial Context Func ( conntrack . Dial With Tracing ( ) , conntrack . Dial With Name ( " " ) , ) , } wrapper : = & http . Client { Transport : transport , Timeout : 3 5 * time . Second , } client Conf : = & consul . Config { Address : conf . Server , Scheme : conf . Scheme , Datacenter : conf . Datacenter , Token : string ( conf . Token ) , Http Auth : & consul . Http Basic Auth { Username : conf . Username , Password : string ( conf . Password ) , } , Http Client : wrapper , } client , err : = consul . New Client ( client Conf ) if err ! = nil { return nil , err } cd : = & Discovery { client : client , tag Separator : conf . Tag Separator , watched Services : conf . Services , watched Tags : conf . Service Tags , watched Node Meta : conf . Node Meta , allow Stale : conf . Allow Stale , refresh Interval : time . Duration ( conf . Refresh Interval ) , client Datacenter : conf . Datacenter , finalizer : transport . Close Idle Connections , logger : logger , } return cd , nil } 
func ( d * Discovery ) should Watch ( name string , tags [ ] string ) bool { return d . should Watch From Name ( name ) & & d . should Watch From Tags ( tags ) } 
func ( d * Discovery ) should Watch From Name ( name string ) bool { } for _ , sn : = range d . watched Services { if sn = = name { return true } } return false } 
func ( d * Discovery ) should Watch From Tags ( tags [ ] string ) bool { } tag Outer : for _ , wtag : = range d . watched Tags { for _ , tag : = range tags { if wtag = = tag { continue tag Outer } } return false } return true } 
func ( d * Discovery ) get Datacenter ( ) error { } info , err : = d . client . Agent ( ) . Self ( ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) rpc Failures Count . Inc ( ) return err } dc , ok : = info [ " " ] [ " " ] . ( string ) if ! ok { err : = errors . Errorf ( " " , info [ " " ] [ " " ] ) level . Error ( d . logger ) . Log ( " " , " " , " " , err ) return err } d . client Datacenter = dc return nil } 
func ( d * Discovery ) initialize ( ctx context . Context ) { default : } if err ! = nil { time . Sleep ( retry Interval ) continue } } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { if d . finalizer ! = nil { defer d . finalizer ( ) } d . initialize ( ctx ) if len ( d . watched Services ) = = 0 | | len ( d . watched Tags ) ! = 0 { var last Index uint 6 4 for { select { case < - ctx . Done ( ) : ticker . Stop ( ) return default : d . watch Services ( ctx , ch , & last Index , services ) < - ticker . C } } } else { } < - ctx . Done ( ) } } 
func ( d * Discovery ) watch Services ( ctx context . Context , ch chan < - [ ] * targetgroup . Group , last Index * uint 6 4 , services map [ string ] func ( ) ) error { catalog : = d . client . Catalog ( ) level . Debug ( d . logger ) . Log ( " " , " " , " " , d . watched Tags ) t 0 : = time . Now ( ) opts : = & consul . Query Options { Wait Index : * last Index , Wait Time : watch Timeout , Allow Stale : d . allow Stale , Node Meta : d . watched Node Meta , } srvs , meta , err : = catalog . Services ( opts . With Context ( ctx ) ) elapsed : = time . Since ( t 0 ) rpc Duration . With Label Values ( " " , " " ) . Observe ( elapsed . Seconds ( ) ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) rpc Failures Count . Inc ( ) time . Sleep ( retry Interval ) return err } } * last Index = meta . Last Index } if _ , ok : = services [ name ] ; ok { continue } wctx , cancel : = context . With Cancel ( ctx ) d . watch Service ( wctx , ch , name ) services [ name ] = cancel } delete ( services , name ) case ch < - [ ] * targetgroup . Group { { Source : name } } : } } } return nil } 
func ( d * Discovery ) watch Service ( ctx context . Context , ch chan < - [ ] * targetgroup . Group , name string ) { srv : = & consul Service { discovery : d , client : d . client , name : name , tags : d . watched Tags , labels : model . Label Set { service Label : model . Label Value ( name ) , datacenter Label : model . Label Value ( d . client Datacenter ) , } , tag Separator : d . tag Separator , logger : d . logger , } go func ( ) { ticker : = time . New Ticker ( d . refresh Interval ) var last Index uint 6 4 catalog : = srv . client . Catalog ( ) for { select { case < - ctx . Done ( ) : ticker . Stop ( ) return default : srv . watch ( ctx , ch , catalog , & last Index ) < - ticker . C } } } ( ) } 
func ( srv * consul Service ) watch ( ctx context . Context , ch chan < - [ ] * targetgroup . Group , catalog * consul . Catalog , last Index * uint 6 4 ) error { level . Debug ( srv . logger ) . Log ( " " , " " , " " , srv . name , " " , srv . tags ) t 0 : = time . Now ( ) opts : = & consul . Query Options { Wait Index : * last Index , Wait Time : watch Timeout , Allow Stale : srv . discovery . allow Stale , Node Meta : srv . discovery . watched Node Meta , } nodes , meta , err : = catalog . Service Multiple Tags ( srv . name , srv . tags , opts . With Context ( ctx ) ) elapsed : = time . Since ( t 0 ) rpc Duration . With Label Values ( " " , " " ) . Observe ( elapsed . Seconds ( ) ) default : if err ! = nil { level . Error ( srv . logger ) . Log ( " " , " " , " " , srv . name , " " , srv . tags , " " , err ) rpc Failures Count . Inc ( ) time . Sleep ( retry Interval ) return err } } * last Index = meta . Last Index tgroup : = targetgroup . Group { Source : srv . name , Labels : srv . labels , Targets : make ( [ ] model . Label Set , 0 , len ( nodes ) ) , } for _ , node : = range nodes { if node . Service Address ! = " " { addr = net . Join Host Port ( node . Service Address , fmt . Sprintf ( " " , node . Service Port ) ) } else { addr = net . Join Host Port ( node . Address , fmt . Sprintf ( " " , node . Service Port ) ) } labels : = model . Label Set { model . Address Label : model . Label Value ( addr ) , address Label : model . Label Value ( node . Address ) , node Label : model . Label Value ( node . Node ) , tags Label : model . Label Value ( tags ) , service Address Label : model . Label Value ( node . Service Address ) , service Port Label : model . Label Value ( strconv . Itoa ( node . Service Port ) ) , service IDLabel : model . Label Value ( node . Service ID ) , } labels [ meta Data Label + model . Label Name ( name ) ] = model . Label Value ( v ) } labels [ service Meta Data Label + model . Label Name ( name ) ] = model . Label Value ( v ) } labels [ tagged Addresses Label + model . Label Name ( name ) ] = model . Label Value ( v ) } tgroup . Targets = append ( tgroup . Targets , labels ) } select { case < - ctx . Done ( ) : return ctx . Err ( ) case ch < - [ ] * targetgroup . Group { & tgroup } : } return nil } 
func New Pod ( l log . Logger , pods cache . Shared Informer ) * Pod { if l = = nil { l = log . New Nop Logger ( ) } p : = & Pod { informer : pods , store : pods . Get Store ( ) , logger : l , queue : workqueue . New Named ( " " ) , } p . informer . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , Delete Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , Update Func : func ( _ , o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) p . enqueue ( o ) } , } ) return p } 
func ( p * Pod ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer p . queue . Shut Down ( ) if ! cache . Wait For Cache Sync ( ctx . Done ( ) , p . informer . Has Synced ) { level . Error ( p . logger ) . Log ( " " , " " ) return } go func ( ) { for p . process ( ctx , ch ) { } } ( ) } 
func New Matcher ( t Match Type , n , v string ) ( * Matcher , error ) { m : = & Matcher { Type : t , Name : n , Value : v , } if t = = Match Regexp | | t = = Match Not Regexp { re , err : = regexp . Compile ( " " + v + " " ) if err ! = nil { return nil , err } m . re = re } return m , nil } 
func ( m * Matcher ) Matches ( s string ) bool { switch m . Type { case Match Equal : return s = = m . Value case Match Not Equal : return s ! = m . Value case Match Regexp : return m . re . Match String ( s ) case Match Not Regexp : return ! m . re . Match String ( s ) } panic ( " " ) } 
func ( s Query Timing ) Span Operation ( ) string { switch s { case Eval Total Time : return " " case Result Sort Time : return " " case Query Preparation Time : return " " case Inner Eval Time : return " " case Exec Queue Time : return " " case Exec Total Time : return " " default : return " " } } 
func New Query Stats ( tg * Query Timers ) * Query Stats { var qt query Timings for s , timer : = range tg . Timer Group . timers { switch s { case Eval Total Time : qt . Eval Total Time = timer . Duration ( ) case Result Sort Time : qt . Result Sort Time = timer . Duration ( ) case Query Preparation Time : qt . Query Preparation Time = timer . Duration ( ) case Inner Eval Time : qt . Inner Eval Time = timer . Duration ( ) case Exec Queue Time : qt . Exec Queue Time = timer . Duration ( ) case Exec Total Time : qt . Exec Total Time = timer . Duration ( ) } } qs : = Query Stats { Timings : qt } return & qs } 
func ( c * Role ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { if err : = unmarshal ( ( * string ) ( c ) ) ; err ! = nil { return err } switch * c { case Open Stack Role Hypervisor , Open Stack Role Instance : return nil default : return errors . Errorf ( " " , * c ) } } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if c . Role = = " " { return errors . New ( " " ) } if c . Region = = " " { return errors . New ( " " ) } return nil } 
func New Discovery ( conf * SDConfig , l log . Logger ) ( * refresh . Discovery , error ) { r , err : = new Refresher ( conf , l ) if err ! = nil { return nil , err } return refresh . New Discovery ( l , " " , time . Duration ( conf . Refresh Interval ) , r . refresh , ) , nil } 
func ( ls * Labels ) Unmarshal JSON ( b [ ] byte ) error { var m map [ string ] string if err : = json . Unmarshal ( b , & m ) ; err ! = nil { return err } * ls = From Map ( m ) return nil } 
func ( ls * Labels ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { var m map [ string ] string if err : = unmarshal ( & m ) ; err ! = nil { return err } * ls = From Map ( m ) return nil } 
func ( ls Labels ) Match Labels ( on bool , names . . . string ) Labels { matched Labels : = Labels { } name Set : = map [ string ] struct { } { } for _ , n : = range names { name Set [ n ] = struct { } { } } for _ , v : = range ls { if _ , ok : = name Set [ v . Name ] ; on = = ok { matched Labels = append ( matched Labels , v ) } } return matched Labels } 
func ( ls Labels ) Hash ( ) uint 6 4 { b : = make ( [ ] byte , 0 , 1 0 2 4 ) for _ , v : = range ls { b = append ( b , v . Name . . . ) b = append ( b , sep ) b = append ( b , v . Value . . . ) b = append ( b , sep ) } return xxhash . Sum 6 4 ( b ) } 
func ( ls Labels ) Hash For Labels ( names . . . string ) uint 6 4 { b : = make ( [ ] byte , 0 , 1 0 2 4 ) for _ , v : = range ls { for _ , n : = range names { if v . Name = = n { b = append ( b , v . Name . . . ) b = append ( b , sep ) b = append ( b , v . Value . . . ) b = append ( b , sep ) break } } } return xxhash . Sum 6 4 ( b ) } 
func ( ls Labels ) Copy ( ) Labels { res : = make ( Labels , len ( ls ) ) copy ( res , ls ) return res } 
func ( ls Labels ) Get ( name string ) string { for _ , l : = range ls { if l . Name = = name { return l . Value } } return " " } 
func ( ls Labels ) Has ( name string ) bool { for _ , l : = range ls { if l . Name = = name { return true } } return false } 
func Equal ( ls , o Labels ) bool { if len ( ls ) ! = len ( o ) { return false } for i , l : = range ls { if l . Name ! = o [ i ] . Name | | l . Value ! = o [ i ] . Value { return false } } return true } 
func ( ls Labels ) Map ( ) map [ string ] string { m : = make ( map [ string ] string , len ( ls ) ) for _ , l : = range ls { m [ l . Name ] = l . Value } return m } 
func New ( ls . . . Label ) Labels { set : = make ( Labels , 0 , len ( ls ) ) for _ , l : = range ls { set = append ( set , l ) } sort . Sort ( set ) return set } 
func From Strings ( ss . . . string ) Labels { if len ( ss ) % 2 ! = 0 { panic ( " " ) } var res Labels for i : = 0 ; i < len ( ss ) ; i + = 2 { res = append ( res , Label { Name : ss [ i ] , Value : ss [ i + 1 ] } ) } sort . Sort ( res ) return res } 
func Compare ( a , b Labels ) int { l : = len ( a ) if len ( b ) < l { l = len ( b ) } for i : = 0 ; i < l ; i + + { if d : = strings . Compare ( a [ i ] . Name , b [ i ] . Name ) ; d ! = 0 { return d } if d : = strings . Compare ( a [ i ] . Value , b [ i ] . Value ) ; d ! = 0 { return d } } } 
func New Builder ( base Labels ) * Builder { return & Builder { base : base , del : make ( [ ] string , 0 , 5 ) , add : make ( [ ] Label , 0 , 5 ) , } } 
func ( b * Builder ) Del ( ns . . . string ) * Builder { for _ , n : = range ns { for i , a : = range b . add { if a . Name = = n { b . add = append ( b . add [ : i ] , b . add [ i + 1 : ] . . . ) } } b . del = append ( b . del , n ) } return b } 
func ( b * Builder ) Set ( n , v string ) * Builder { for i , a : = range b . add { if a . Name = = n { b . add [ i ] . Value = v return b } } b . add = append ( b . add , Label { Name : n , Value : v } ) return b } 
func ( b * Builder ) Labels ( ) Labels { if len ( b . del ) = = 0 & & len ( b . add ) = = 0 { return b . base } Outer : for _ , l : = range b . base { for _ , n : = range b . del { if l . Name = = n { continue Outer } } for _ , la : = range b . add { if l . Name = = la . Name { continue Outer } } res = append ( res , l ) } res = append ( res , b . add . . . ) sort . Sort ( res ) return res } 
func New Storage ( l log . Logger , reg prometheus . Registerer , st Callback start Time Callback , wal Dir string , flush Deadline time . Duration ) * Storage { if l = = nil { l = log . New Nop Logger ( ) } s : = & Storage { logger : logging . Dedupe ( l , 1 * time . Minute ) , local Start Time Callback : st Callback , flush Deadline : flush Deadline , samples In : new EWMARate ( ewma Weight , shard Update Duration ) , wal Dir : wal Dir , } go s . run ( ) return s } 
func ( s * Storage ) Apply Config ( conf * config . Config ) error { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) cfg Bytes , err : = json . Marshal ( conf . Remote Write Configs ) if err ! = nil { return err } hash : = md 5 . Sum ( cfg Bytes ) if hash = = s . config Hash { level . Debug ( s . logger ) . Log ( " " , " " ) return nil } s . config Hash = hash if err ! = nil { return err } new Queues = append ( new Queues , New Queue Manager ( s . logger , s . wal Dir , s . samples In , rw Conf . Queue Config , conf . Global Config . External Labels , rw Conf . Write Relabel Configs , c , s . flush Deadline , ) ) } for _ , q : = range s . queues { q . Stop ( ) } s . queues = new Queues for _ , q : = range s . queues { q . Start ( ) } for i , rr Conf : = range conf . Remote Read Configs { c , err : = New Client ( i , & Client Config { URL : rr Conf . URL , Timeout : rr Conf . Remote Timeout , HTTPClient Config : rr Conf . HTTPClient Config , } ) if err ! = nil { return err } q : = Queryable Client ( c ) q = External Labels Handler ( q , conf . Global Config . External Labels ) if len ( rr Conf . Required Matchers ) > 0 { q = Required Matchers Filter ( q , labels To Equality Matchers ( rr Conf . Required Matchers ) ) } if ! rr Conf . Read Recent { q = Prefer Local Storage Filter ( q , s . local Start Time Callback ) } queryables = append ( queryables , q ) } s . queryables = queryables return nil } 
func ( s * Storage ) Querier ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { s . mtx . Lock ( ) queryables : = s . queryables s . mtx . Unlock ( ) queriers : = make ( [ ] storage . Querier , 0 , len ( queryables ) ) for _ , queryable : = range queryables { q , err : = queryable . Querier ( ctx , mint , maxt ) if err ! = nil { return nil , err } queriers = append ( queriers , q ) } return storage . New Merge Querier ( nil , queriers ) , nil } 
func ( s * Storage ) Close ( ) error { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) for _ , q : = range s . queues { q . Stop ( ) } return nil } 
func Rate Limit ( next log . Logger , limit rate . Limit ) log . Logger { return & ratelimiter { limiter : rate . New Limiter ( limit , int ( limit ) ) , next : next , } } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if len ( c . Names ) = = 0 { return errors . New ( " " ) } switch strings . To Upper ( c . Type ) { case " " : case " " , " " : if c . Port = = 0 { return errors . New ( " " ) } default : return errors . Errorf ( " " , c . Type ) } return nil } 
func New Discovery ( conf SDConfig , logger log . Logger ) * Discovery { if logger = = nil { logger = log . New Nop Logger ( ) } qtype : = dns . Type SRV switch strings . To Upper ( conf . Type ) { case " " : qtype = dns . Type A case " " : qtype = dns . Type AAAA case " " : qtype = dns . Type SRV } d : = & Discovery { names : conf . Names , qtype : qtype , port : conf . Port , logger : logger , lookup Fn : lookup With Search Path , } d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( conf . Refresh Interval ) , d . refresh , ) return d } 
func lookup With Search Path ( name string , qtype uint 1 6 , logger log . Logger ) ( * dns . Msg , error ) { conf , err : = dns . Client Config From File ( resolv Conf ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } all Responses Valid : = true for _ , lname : = range conf . Name List ( name ) { response , err : = lookup From Any Server ( lname , qtype , conf , logger ) if err ! = nil { } else if response . Rcode = = dns . Rcode Success { } } if all Responses Valid { } } 
func lookup From Any Server ( name string , qtype uint 1 6 , conf * dns . Client Config , logger log . Logger ) ( * dns . Msg , error ) { client : = & dns . Client { } for _ , server : = range conf . Servers { serv Addr : = net . Join Host Port ( server , conf . Port ) msg , err : = ask Server For Name ( name , qtype , client , serv Addr , true ) if err ! = nil { level . Warn ( logger ) . Log ( " " , " " , " " , server , " " , name , " " , err ) continue } if msg . Rcode = = dns . Rcode Success | | msg . Rcode = = dns . Rcode Name Error { } } return nil , errors . Errorf ( " " , name ) } 
func ask Server For Name ( name string , query Type uint 1 6 , client * dns . Client , serv Addr string , edns bool ) ( * dns . Msg , error ) { msg : = & dns . Msg { } msg . Set Question ( dns . Fqdn ( name ) , query Type ) if edns { msg . Set Edns 0 ( dns . Default Msg Size , false ) } response , _ , err : = client . Exchange ( msg , serv Addr ) if err ! = nil { return nil , err } if response . Truncated { if client . Net = = " " { return nil , errors . New ( " " ) } client . Net = " " return ask Server For Name ( name , query Type , client , serv Addr , false ) } return response , nil } 
func new Hypervisor Discovery ( provider * gophercloud . Provider Client , opts * gophercloud . Auth Options , port int , region string , l log . Logger ) * Hypervisor Discovery { return & Hypervisor Discovery { provider : provider , auth Opts : opts , region : region , port : port , logger : l } } 
func New ( db func ( ) * tsdb . DB , enable Admin bool , ) * API { return & API { db : db , enable Admin : enable Admin , } } 
func ( api * API ) Register GRPC ( srv * grpc . Server ) { if api . enable Admin { pb . Register Admin Server ( srv , New Admin ( api . db ) ) } else { pb . Register Admin Server ( srv , & Admin Disabled { } ) } } 
func ( api * API ) HTTPHandler ( ctx context . Context , grpc Addr string ) ( http . Handler , error ) { enc : = new ( protoutil . JSONPb ) mux : = runtime . New Serve Mux ( runtime . With Marshaler Option ( enc . Content Type ( ) , enc ) ) opts : = [ ] grpc . Dial Option { grpc . With Insecure ( ) , } ) , } err : = pb . Register Admin Handler From Endpoint ( ctx , mux , grpc Addr , opts ) if err ! = nil { return nil , err } return mux , nil } 
func extract Time Range ( min , max * time . Time ) ( mint , maxt time . Time , err error ) { if min = = nil { mint = min Time } else { mint = * min } if max = = nil { maxt = max Time } else { maxt = * max } if mint . After ( maxt ) { return mint , maxt , errors . Errorf ( " " ) } return mint , maxt , nil } 
func ( s * Admin Disabled ) TSDBSnapshot ( _ context . Context , _ * pb . TSDBSnapshot Request ) ( * pb . TSDBSnapshot Response , error ) { return nil , err Admin Disabled } 
func ( s * Admin Disabled ) TSDBClean Tombstones ( _ context . Context , _ * pb . TSDBClean Tombstones Request ) ( * pb . TSDBClean Tombstones Response , error ) { return nil , err Admin Disabled } 
func ( s * Admin Disabled ) Delete Series ( _ context . Context , r * pb . Series Delete Request ) ( * pb . Series Delete Response , error ) { return nil , err Admin Disabled } 
func ( s * Admin ) TSDBSnapshot ( _ context . Context , req * pb . TSDBSnapshot Request ) ( * pb . TSDBSnapshot Response , error ) { db : = s . db ( ) if db = = nil { return nil , err TSDBNot Ready } var ( snapdir = filepath . Join ( db . Dir ( ) , " " ) name = fmt . Sprintf ( " " , time . Now ( ) . UTC ( ) . Format ( " " ) , rand . Int ( ) ) dir = filepath . Join ( snapdir , name ) ) if err : = os . Mkdir All ( dir , 0 7 7 7 ) ; err ! = nil { return nil , status . Errorf ( codes . Internal , " " , err ) } if err : = db . Snapshot ( dir , ! req . Skip Head ) ; err ! = nil { return nil , status . Errorf ( codes . Internal , " " , err ) } return & pb . TSDBSnapshot Response { Name : name } , nil } 
func ( s * Admin ) TSDBClean Tombstones ( _ context . Context , _ * pb . TSDBClean Tombstones Request ) ( * pb . TSDBClean Tombstones Response , error ) { db : = s . db ( ) if db = = nil { return nil , err TSDBNot Ready } if err : = db . Clean Tombstones ( ) ; err ! = nil { return nil , status . Errorf ( codes . Internal , " " , err ) } return & pb . TSDBClean Tombstones Response { } , nil } 
func ( s * Admin ) Delete Series ( _ context . Context , r * pb . Series Delete Request ) ( * pb . Series Delete Response , error ) { mint , maxt , err : = extract Time Range ( r . Min Time , r . Max Time ) if err ! = nil { return nil , status . Error ( codes . Invalid Argument , err . Error ( ) ) } var matchers tsdb Labels . Selector for _ , m : = range r . Matchers { var lm tsdb Labels . Matcher var err error switch m . Type { case pb . Label Matcher _EQ : lm = tsdb Labels . New Equal Matcher ( m . Name , m . Value ) case pb . Label Matcher _NEQ : lm = tsdb Labels . Not ( tsdb Labels . New Equal Matcher ( m . Name , m . Value ) ) case pb . Label Matcher _RE : lm , err = tsdb Labels . New Regexp Matcher ( m . Name , m . Value ) if err ! = nil { return nil , status . Errorf ( codes . Invalid Argument , " " , err ) } case pb . Label Matcher _NRE : lm , err = tsdb Labels . New Regexp Matcher ( m . Name , m . Value ) if err ! = nil { return nil , status . Errorf ( codes . Invalid Argument , " " , err ) } lm = tsdb Labels . Not ( lm ) default : return nil , status . Error ( codes . Invalid Argument , " " ) } matchers = append ( matchers , lm ) } db : = s . db ( ) if db = = nil { return nil , err TSDBNot Ready } if err : = db . Delete ( timestamp . From Time ( mint ) , timestamp . From Time ( maxt ) , matchers . . . ) ; err ! = nil { return nil , status . Error ( codes . Internal , err . Error ( ) ) } return & pb . Series Delete Response { } , nil } 
func ( c * compressed Response Writer ) Write ( p [ ] byte ) ( int , error ) { return c . writer . Write ( p ) } 
func ( c * compressed Response Writer ) Close ( ) { if zlib Writer , ok : = c . writer . ( * zlib . Writer ) ; ok { zlib Writer . Flush ( ) } if gzip Writer , ok : = c . writer . ( * gzip . Writer ) ; ok { gzip Writer . Flush ( ) } if closer , ok : = c . writer . ( io . Closer ) ; ok { defer closer . Close ( ) } } 
func new Compressed Response Writer ( writer http . Response Writer , req * http . Request ) * compressed Response Writer { encodings : = strings . Split ( req . Header . Get ( accept Encoding Header ) , " " ) for _ , encoding : = range encodings { switch strings . Trim Space ( encoding ) { case gzip Encoding : writer . Header ( ) . Set ( content Encoding Header , gzip Encoding ) return & compressed Response Writer { Response Writer : writer , writer : gzip . New Writer ( writer ) , } case deflate Encoding : writer . Header ( ) . Set ( content Encoding Header , deflate Encoding ) return & compressed Response Writer { Response Writer : writer , writer : zlib . New Writer ( writer ) , } } } return & compressed Response Writer { Response Writer : writer , writer : writer , } } 
func ( c Compression Handler ) Serve HTTP ( writer http . Response Writer , req * http . Request ) { comp Writer : = new Compressed Response Writer ( writer , req ) c . Handler . Serve HTTP ( comp Writer , req ) comp Writer . Close ( ) } 
func New Template Expander ( ctx context . Context , text string , name string , data interface { } , timestamp model . Time , query Func Query Func , external URL * url . URL , ) * Expander { return & Expander { text : text , name : name , data : data , func Map : text _template . Func Map { " " : func ( q string ) ( query Result , error ) { return query ( ctx , q , timestamp . Time ( ) , query Func ) } , " " : func ( v query Result ) ( * sample , error ) { if len ( v ) > 0 { return v [ 0 ] , nil } return nil , errors . New ( " " ) } , " " : func ( label string , s * sample ) string { return s . Labels [ label ] } , " " : func ( s * sample ) float 6 4 { return s . Value } , " " : func ( s * sample ) string { return s . Labels [ " " ] } , " " : func ( args . . . interface { } ) map [ string ] interface { } { result : = make ( map [ string ] interface { } ) for i , a : = range args { result [ fmt . Sprintf ( " " , i ) ] = a } return result } , " " : func ( pattern , repl , text string ) string { re : = regexp . Must Compile ( pattern ) return re . Replace All String ( text , repl ) } , " " : func ( text string ) html _template . HTML { return html _template . HTML ( text ) } , " " : regexp . Match String , " " : strings . Title , " " : strings . To Upper , " " : strings . To Lower , " " : strutil . Graph Link For Expression , " " : strutil . Table Link For Expression , " " : func ( label string , v query Result ) query Result { sorter : = query Result By Label Sorter { v [ : ] , label } sort . Stable ( sorter ) return v } , " " : func ( v float 6 4 ) string { if v = = 0 | | math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } if math . Abs ( v ) > = 1 { prefix : = " " for _ , p : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) < 1 0 0 0 { break } prefix = p v / = 1 0 0 0 } return fmt . Sprintf ( " " , v , prefix ) } prefix : = " " for _ , p : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) > = 1 { break } prefix = p v * = 1 0 0 0 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float 6 4 ) string { if math . Abs ( v ) < = 1 | | math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } prefix : = " " for _ , p : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) < 1 0 2 4 { break } prefix = p v / = 1 0 2 4 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float 6 4 ) string { if math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } if v = = 0 { return fmt . Sprintf ( " " , v ) } if math . Abs ( v ) > = 1 { sign : = " " if v < 0 { sign = " " v = - v } seconds : = int 6 4 ( v ) % 6 0 minutes : = ( int 6 4 ( v ) / 6 0 ) % 6 0 hours : = ( int 6 4 ( v ) / 6 0 / 6 0 ) % 2 4 days : = ( int 6 4 ( v ) / 6 0 / 6 0 / 2 4 ) } if hours ! = 0 { return fmt . Sprintf ( " " , sign , hours , minutes , seconds ) } if minutes ! = 0 { return fmt . Sprintf ( " " , sign , minutes , seconds ) } } prefix : = " " for _ , p : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " } { if math . Abs ( v ) > = 1 { break } prefix = p v * = 1 0 0 0 } return fmt . Sprintf ( " " , v , prefix ) } , " " : func ( v float 6 4 ) string { if math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { return fmt . Sprintf ( " " , v ) } t : = model . Time From Unix Nano ( int 6 4 ( v * 1e 9 ) ) . Time ( ) . UTC ( ) return fmt . Sprint ( t ) } , " " : func ( ) string { return external URL . Path } , " " : func ( ) string { return external URL . String ( ) } , } , } } 
func Alert Template Data ( labels map [ string ] string , external Labels map [ string ] string , value float 6 4 ) interface { } { return struct { Labels map [ string ] string External Labels map [ string ] string Value float 6 4 } { Labels : labels , External Labels : external Labels , Value : value , } } 
func ( te Expander ) Funcs ( fm text _template . Func Map ) { for k , v : = range fm { te . func Map [ k ] = v } } 
func ( te Expander ) Expand ( ) ( result string , result Err error ) { result Err , ok = r . ( error ) if ! ok { result Err = errors . Errorf ( " " , te . name , r ) } } if result Err ! = nil { template Text Expansion Failures . Inc ( ) } } ( ) template Text Expansion Total . Inc ( ) tmpl , err : = text _template . New ( te . name ) . Funcs ( te . func Map ) . Option ( " " ) . Parse ( te . text ) if err ! = nil { return " " , errors . Wrapf ( err , " " , te . name ) } var buffer bytes . Buffer err = tmpl . Execute ( & buffer , te . data ) if err ! = nil { return " " , errors . Wrapf ( err , " " , te . name ) } return buffer . String ( ) , nil } 
func ( te Expander ) Expand HTML ( template Files [ ] string ) ( result string , result Err error ) { defer func ( ) { if r : = recover ( ) ; r ! = nil { var ok bool result Err , ok = r . ( error ) if ! ok { result Err = errors . Errorf ( " " , te . name , r ) } } } ( ) tmpl : = html _template . New ( te . name ) . Funcs ( html _template . Func Map ( te . func Map ) ) tmpl . Option ( " " ) tmpl . Funcs ( html _template . Func Map { " " : func ( name string , data interface { } ) ( html _template . HTML , error ) { var buffer bytes . Buffer err : = tmpl . Execute Template ( & buffer , name , data ) return html _template . HTML ( buffer . String ( ) ) , err } , } ) tmpl , err : = tmpl . Parse ( te . text ) if err ! = nil { return " " , errors . Wrapf ( err , " " , te . name ) } if len ( template Files ) > 0 { _ , err = tmpl . Parse Files ( template Files . . . ) if err ! = nil { return " " , errors . Wrapf ( err , " " , te . name ) } } var buffer bytes . Buffer err = tmpl . Execute ( & buffer , te . data ) if err ! = nil { return " " , errors . Wrapf ( err , " " , te . name ) } return buffer . String ( ) , nil } 
func New Target ( labels , discovered Labels labels . Labels , params url . Values ) * Target { return & Target { labels : labels , discovered Labels : discovered Labels , params : params , health : Health Unknown , } } 
func ( t * Target ) Metadata ( metric string ) ( Metric Metadata , bool ) { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) if t . metadata = = nil { return Metric Metadata { } , false } return t . metadata . get Metadata ( metric ) } 
func ( t * Target ) hash ( ) uint 6 4 { h : = fnv . New 6 4a ( ) h . Write ( [ ] byte ( fmt . Sprintf ( " " , t . labels . Hash ( ) ) ) ) h . Write ( [ ] byte ( t . URL ( ) . String ( ) ) ) return h . Sum 6 4 ( ) } 
func ( t * Target ) offset ( interval time . Duration , jitter Seed uint 6 4 ) time . Duration { now : = time . Now ( ) . Unix Nano ( ) offset = ( t . hash ( ) ^ jitter Seed ) % uint 6 4 ( interval ) next = base + int 6 4 ( offset ) ) if next > int 6 4 ( interval ) { next - = int 6 4 ( interval ) } return time . Duration ( next ) } 
func ( t * Target ) Labels ( ) labels . Labels { lset : = make ( labels . Labels , 0 , len ( t . labels ) ) for _ , l : = range t . labels { if ! strings . Has Prefix ( l . Name , model . Reserved Label Prefix ) { lset = append ( lset , l ) } } return lset } 
func ( t * Target ) Discovered Labels ( ) labels . Labels { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) lset : = make ( labels . Labels , len ( t . discovered Labels ) ) copy ( lset , t . discovered Labels ) return lset } 
func ( t * Target ) Set Discovered Labels ( l labels . Labels ) { t . mtx . Lock ( ) defer t . mtx . Unlock ( ) t . discovered Labels = l } 
func ( t * Target ) URL ( ) * url . URL { params : = url . Values { } for k , v : = range t . params { params [ k ] = make ( [ ] string , len ( v ) ) copy ( params [ k ] , v ) } for _ , l : = range t . labels { if ! strings . Has Prefix ( l . Name , model . Param Label Prefix ) { continue } ks : = l . Name [ len ( model . Param Label Prefix ) : ] if len ( params [ ks ] ) > 0 { params [ ks ] [ 0 ] = l . Value } else { params [ ks ] = [ ] string { l . Value } } } return & url . URL { Scheme : t . labels . Get ( model . Scheme Label ) , Host : t . labels . Get ( model . Address Label ) , Path : t . labels . Get ( model . Metrics Path Label ) , Raw Query : params . Encode ( ) , } } 
func ( t * Target ) Last Error ( ) error { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . last Error } 
func ( t * Target ) Last Scrape ( ) time . Time { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . last Scrape } 
func ( t * Target ) Last Scrape Duration ( ) time . Duration { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . last Scrape Duration } 
func ( t * Target ) Health ( ) Target Health { t . mtx . RLock ( ) defer t . mtx . RUnlock ( ) return t . health } 
func populate Labels ( lset labels . Labels , cfg * config . Scrape Config ) ( res , orig labels . Labels , err error ) { lb : = labels . New Builder ( lset ) for _ , l : = range scrape Labels { if lv : = lset . Get ( l . Name ) ; lv = = " " { lb . Set ( l . Name , l . Value ) } } } } pre Relabel Labels : = lb . Labels ( ) lset = relabel . Process ( pre Relabel Labels , cfg . Relabel Configs . . . ) } if v : = lset . Get ( model . Address Label ) ; v = = " " { return nil , nil , errors . New ( " " ) } lb = labels . New Builder ( lset ) } return err = = nil } addr : = lset . Get ( model . Address Label ) case " " : addr = addr + " " default : return nil , nil , errors . Errorf ( " " , cfg . Scheme ) } lb . Set ( model . Address Label , addr ) } if err : = config . Check Target Address ( model . Label Value ( addr ) ) ; err ! = nil { return nil , nil , err } } } } res = lb . Labels ( ) for _ , l : = range res { } } return res , pre Relabel Labels , nil } 
func targets From Group ( tg * targetgroup . Group , cfg * config . Scrape Config ) ( [ ] * Target , error ) { targets : = make ( [ ] * Target , 0 , len ( tg . Targets ) ) for i , tlset : = range tg . Targets { lbls : = make ( [ ] labels . Label , 0 , len ( tlset ) + len ( tg . Labels ) ) for ln , lv : = range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } for ln , lv : = range tg . Labels { if _ , ok : = tlset [ ln ] ; ! ok { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } } lset : = labels . New ( lbls . . . ) lbls , orig Labels , err : = populate Labels ( lset , cfg ) if err ! = nil { return nil , errors . Wrapf ( err , " " , i , tg ) } if lbls ! = nil | | orig Labels ! = nil { targets = append ( targets , New Target ( lbls , orig Labels , cfg . Params ) ) } } return targets , nil } 
func From Time ( t time . Time ) int 6 4 { return t . Unix ( ) * 1 0 0 0 + int 6 4 ( t . Nanosecond ( ) ) / int 6 4 ( time . Millisecond ) } 
func Time ( ts int 6 4 ) time . Time { return time . Unix ( ts / 1 0 0 0 , ( ts % 1 0 0 0 ) * int 6 4 ( time . Millisecond ) ) } 
func Set CORS ( w http . Response Writer , o * regexp . Regexp , r * http . Request ) { origin : = r . Header . Get ( " " ) if origin = = " " { return } for k , v : = range cors Headers { w . Header ( ) . Set ( k , v ) } if o . String ( ) = = " " { w . Header ( ) . Set ( " " , " " ) return } if o . Match String ( origin ) { w . Header ( ) . Set ( " " , origin ) } } 
func New Client ( index int , conf * Client Config ) ( * Client , error ) { http Client , err : = config _util . New Client From Config ( conf . HTTPClient Config , " " ) if err ! = nil { return nil , err } return & Client { index : index , url : conf . URL , client : http Client , timeout : time . Duration ( conf . Timeout ) , } , nil } 
func ( c * Client ) Store ( ctx context . Context , req [ ] byte ) error { http Req , err : = http . New Request ( " " , c . url . String ( ) , bytes . New Reader ( req ) ) if err ! = nil { } http Req . Header . Add ( " " , " " ) http Req . Header . Set ( " " , " " ) http Req . Header . Set ( " " , user Agent ) http Req . Header . Set ( " " , " " ) http Req = http Req . With Context ( ctx ) ctx , cancel : = context . With Timeout ( context . Background ( ) , c . timeout ) defer cancel ( ) http Resp , err : = c . client . Do ( http Req . With Context ( ctx ) ) if err ! = nil { } defer func ( ) { io . Copy ( ioutil . Discard , http Resp . Body ) http Resp . Body . Close ( ) } ( ) if http Resp . Status Code / 1 0 0 ! = 2 { scanner : = bufio . New Scanner ( io . Limit Reader ( http Resp . Body , max Err Msg Len ) ) line : = " " if scanner . Scan ( ) { line = scanner . Text ( ) } err = errors . Errorf ( " " , http Resp . Status , line ) } if http Resp . Status Code / 1 0 0 = = 5 { return recoverable Error { err } } return err } 
func ( c Client ) Name ( ) string { return fmt . Sprintf ( " " , c . index , c . url ) } 
func ( c * Client ) Read ( ctx context . Context , query * prompb . Query ) ( * prompb . Query Result , error ) { req : = & prompb . Read Request { data , err : = proto . Marshal ( req ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } compressed : = snappy . Encode ( nil , data ) http Req , err : = http . New Request ( " " , c . url . String ( ) , bytes . New Reader ( compressed ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } http Req . Header . Add ( " " , " " ) http Req . Header . Add ( " " , " " ) http Req . Header . Set ( " " , " " ) http Req . Header . Set ( " " , user Agent ) http Req . Header . Set ( " " , " " ) ctx , cancel : = context . With Timeout ( ctx , c . timeout ) defer cancel ( ) http Resp , err : = c . client . Do ( http Req . With Context ( ctx ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } defer func ( ) { io . Copy ( ioutil . Discard , http Resp . Body ) http Resp . Body . Close ( ) } ( ) if http Resp . Status Code / 1 0 0 ! = 2 { return nil , errors . Errorf ( " " , http Resp . Status ) } compressed , err = ioutil . Read All ( http Resp . Body ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } uncompressed , err : = snappy . Decode ( nil , compressed ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } var resp prompb . Read Response err = proto . Unmarshal ( uncompressed , & resp ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if len ( resp . Results ) ! = len ( req . Queries ) { return nil , errors . Errorf ( " " , len ( req . Queries ) , len ( resp . Results ) ) } return resp . Results [ 0 ] , nil } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if err = validate Auth Param ( c . Subscription ID , " " ) ; err ! = nil { return err } if c . Authentication Method = = auth Method OAuth { if err = validate Auth Param ( c . Tenant ID , " " ) ; err ! = nil { return err } if err = validate Auth Param ( c . Client ID , " " ) ; err ! = nil { return err } if err = validate Auth Param ( string ( c . Client Secret ) , " " ) ; err ! = nil { return err } } if c . Authentication Method ! = auth Method OAuth & & c . Authentication Method ! = auth Method Managed Identity { return errors . Errorf ( " " , c . Authentication Method , auth Method OAuth , auth Method Managed Identity ) } return nil } 
func New Discovery ( cfg * SDConfig , logger log . Logger ) * Discovery { if logger = = nil { logger = log . New Nop Logger ( ) } d : = & Discovery { cfg : cfg , port : cfg . Port , logger : logger , } d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( cfg . Refresh Interval ) , d . refresh , ) return d } 
func create Azure Client ( cfg SDConfig ) ( azure Client , error ) { env , err : = azure . Environment From Name ( cfg . Environment ) if err ! = nil { return azure Client { } , err } active Directory Endpoint : = env . Active Directory Endpoint resource Manager Endpoint : = env . Resource Manager Endpoint var c azure Client var spt * adal . Service Principal Token switch cfg . Authentication Method { case auth Method Managed Identity : msi Endpoint , err : = adal . Get MSIVMEndpoint ( ) if err ! = nil { return azure Client { } , err } spt , err = adal . New Service Principal Token From MSI ( msi Endpoint , resource Manager Endpoint ) if err ! = nil { return azure Client { } , err } case auth Method OAuth : oauth Config , err : = adal . New OAuth Config ( active Directory Endpoint , cfg . Tenant ID ) if err ! = nil { return azure Client { } , err } spt , err = adal . New Service Principal Token ( * oauth Config , cfg . Client ID , string ( cfg . Client Secret ) , resource Manager Endpoint ) if err ! = nil { return azure Client { } , err } } bearer Authorizer : = autorest . New Bearer Authorizer ( spt ) c . vm = compute . New Virtual Machines Client With Base URI ( resource Manager Endpoint , cfg . Subscription ID ) c . vm . Authorizer = bearer Authorizer c . nic = network . New Interfaces Client With Base URI ( resource Manager Endpoint , cfg . Subscription ID ) c . nic . Authorizer = bearer Authorizer c . vmss = compute . New Virtual Machine Scale Sets Client With Base URI ( resource Manager Endpoint , cfg . Subscription ID ) c . vmss . Authorizer = bearer Authorizer c . vmssvm = compute . New Virtual Machine Scale Set VMs Client With Base URI ( resource Manager Endpoint , cfg . Subscription ID ) c . vmssvm . Authorizer = bearer Authorizer return c , nil } 
func new Azure Resource From ID ( id string , logger log . Logger ) ( azure Resource , error ) { if len ( s ) ! = 9 & & len ( s ) ! = 1 1 { err : = errors . Errorf ( " " , id ) level . Error ( logger ) . Log ( " " , err ) return azure Resource { } , err } return azure Resource { Name : strings . To Lower ( s [ 8 ] ) , Resource Group : strings . To Lower ( s [ 4 ] ) , } , nil } 
func ( t * Timer ) String ( ) string { return fmt . Sprintf ( " " , t . name , t . duration ) } 
func ( t * Timer Group ) Get Timer ( name fmt . Stringer ) * Timer { if timer , exists : = t . timers [ name ] ; exists { return timer } timer : = & Timer { name : name , created : time . Now ( ) , } t . timers [ name ] = timer return timer } 
func ( t Timers ) Swap ( i , j int ) { t [ i ] , t [ j ] = t [ j ] , t [ i ] } 
func ( t * Timer Group ) String ( ) string { timers : = by Creation Time Sorter { } for _ , timer : = range t . timers { timers . Timers = append ( timers . Timers , timer ) } sort . Sort ( timers ) result : = & bytes . Buffer { } for _ , timer : = range timers . Timers { fmt . Fprintf ( result , " \n " , timer ) } return result . String ( ) } 
func Register Admin Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Admin Handler Client ( ctx , mux , New Admin Client ( conn ) ) } 
func Register Admin Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client Admin Client ) error { mux . Handle ( " " , pattern _Admin _TSDBSnapshot _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Admin _TSDBSnapshot _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Admin _TSDBSnapshot _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Admin _TSDBClean Tombstones _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Admin _TSDBClean Tombstones _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Admin _TSDBClean Tombstones _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Admin _Delete Series _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Admin _Delete Series _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Admin _Delete Series _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Parse Expr ( input string ) ( Expr , error ) { p : = new Parser ( input ) expr , err : = p . parse Expr ( ) if err ! = nil { return nil , err } err = p . typecheck ( expr ) return expr , err } 
func Parse Metric ( input string ) ( m labels . Labels , err error ) { p : = new Parser ( input ) defer p . recover ( & err ) m = p . metric ( ) if p . peek ( ) . typ ! = Item EOF { p . errorf ( " " , p . lex . input [ p . lex . last Pos : ] ) } return m , nil } 
func Parse Metric Selector ( input string ) ( m [ ] * labels . Matcher , err error ) { p : = new Parser ( input ) defer p . recover ( & err ) name : = " " if t : = p . peek ( ) . typ ; t = = Item Metric Identifier | | t = = Item Identifier { name = p . next ( ) . val } vs : = p . Vector Selector ( name ) if p . peek ( ) . typ ! = Item EOF { p . errorf ( " " , p . lex . input [ p . lex . last Pos : ] ) } return vs . Label Matchers , nil } 
func new Parser ( input string ) * parser { p : = & parser { lex : lex ( input ) , } return p } 
func ( p * parser ) parse Expr ( ) ( expr Expr , err error ) { defer p . recover ( & err ) for p . peek ( ) . typ ! = Item EOF { if p . peek ( ) . typ = = Item Comment { continue } if expr ! = nil { p . errorf ( " " , p . lex . input [ p . lex . last Pos : ] ) } expr = p . expr ( ) } if expr = = nil { p . errorf ( " " ) } return } 
func parse Series Desc ( input string ) ( labels . Labels , [ ] sequence Value , error ) { p : = new Parser ( input ) p . lex . series Desc = true return p . parse Series Desc ( ) } 
func ( p * parser ) parse Series Desc ( ) ( m labels . Labels , vals [ ] sequence Value , err error ) { defer p . recover ( & err ) m = p . metric ( ) const ctx = " " for { for p . peek ( ) . typ = = Item Space { p . next ( ) } if p . peek ( ) . typ = = Item EOF { break } times : = uint 6 4 ( 1 ) if p . peek ( ) . typ = = Item Times { p . next ( ) times , err = strconv . Parse Uint ( p . expect ( Item Number , ctx ) . val , 1 0 , 6 4 ) if err ! = nil { p . errorf ( " " , ctx , err ) } } for i : = uint 6 4 ( 0 ) ; i < times ; i + + { vals = append ( vals , sequence Value { omitted : true } ) } } continue } if t : = p . peek ( ) . typ ; t = = Item SUB | | t = = Item ADD { if p . next ( ) . typ = = Item SUB { sign = - 1 } } var k float 6 4 if t : = p . peek ( ) . typ ; t = = Item Number { k = sign * p . number ( p . expect ( Item Number , ctx ) . val ) } else if t = = Item Identifier & & p . peek ( ) . val = = " " { p . next ( ) k = math . Float 6 4frombits ( value . Stale Na N ) } else { p . errorf ( " " , ctx , t . desc ( ) , p . peek ( ) ) } vals = append ( vals , sequence Value { value : k , } ) } else if t . typ = = Item EOF { break } else if t . typ ! = Item ADD & & t . typ ! = Item SUB { p . errorf ( " " , ctx , t . desc ( ) , p . peek ( ) ) } if p . next ( ) . typ = = Item SUB { sign = - 1 . 0 } offset : = sign * p . number ( p . expect ( Item Number , ctx ) . val ) p . expect ( Item Times , ctx ) times , err : = strconv . Parse Uint ( p . expect ( Item Number , ctx ) . val , 1 0 , 6 4 ) if err ! = nil { p . errorf ( " " , ctx , err ) } for i : = uint 6 4 ( 0 ) ; i < times ; i + + { k + = offset vals = append ( vals , sequence Value { value : k , } ) } } } return m , vals , nil } 
func ( p * parser ) typecheck ( node Node ) ( err error ) { defer p . recover ( & err ) p . check Type ( node ) return nil } 
func ( p * parser ) next ( ) item { if p . peek Count > 0 { p . peek Count - - } else { t : = p . lex . next Item ( ) } p . token [ 0 ] = t } if p . token [ p . peek Count ] . typ = = Item Error { p . errorf ( " " , p . token [ p . peek Count ] . val ) } return p . token [ p . peek Count ] } 
func ( p * parser ) peek ( ) item { if p . peek Count > 0 { return p . token [ p . peek Count - 1 ] } p . peek Count = 1 t : = p . lex . next Item ( ) } p . token [ 0 ] = t return p . token [ 0 ] } 
func ( p * parser ) errorf ( format string , args . . . interface { } ) { p . error ( errors . Errorf ( format , args . . . ) ) } 
func ( p * parser ) error ( err error ) { perr : = & Parse Err { Line : p . lex . line Number ( ) , Pos : p . lex . line Position ( ) , Err : err , } if strings . Count ( strings . Trim Space ( p . lex . input ) , " \n " ) = = 0 { perr . Line = 0 } panic ( perr ) } 
func ( p * parser ) expect ( exp Item Type , context string ) item { token : = p . next ( ) if token . typ ! = exp { p . errorf ( " " , token . desc ( ) , context , exp . desc ( ) ) } return token } 
func ( p * parser ) expect One Of ( exp 1 , exp 2 Item Type , context string ) item { token : = p . next ( ) if token . typ ! = exp 1 & & token . typ ! = exp 2 { p . errorf ( " " , token . desc ( ) , context , exp 1 . desc ( ) , exp 2 . desc ( ) ) } return token } 
func ( p * parser ) recover ( errp * error ) { e : = recover ( ) if _ , ok : = e . ( runtime . Error ) ; ok { buf = buf [ : runtime . Stack ( buf , false ) ] fmt . Fprintf ( os . Stderr , " \n " , e , buf ) * errp = err Unexpected } else if e ! = nil { * errp = e . ( error ) } p . lex . close ( ) } 
func ( p * parser ) expr ( ) Expr { if ! op . is Operator ( ) { if s , ok : = expr . ( * Subquery Expr ) ; ok { s . Offset = offset } } } return expr } p . next ( ) if op . is Set Operator ( ) { vec Matching . Card = Card Many To Many } return Bool : = false } p . next ( ) return Bool = true } } p . next ( ) vec Matching . Matching Labels = p . labels ( ) if t = = Item Group Left { vec Matching . Card = Card Many To One } else { vec Matching . Card = Card One To Many } if p . peek ( ) . typ = = Item Left Paren { vec Matching . Include = p . labels ( ) } } } for _ , ln : = range vec Matching . Matching Labels { for _ , ln 2 : = range vec Matching . Include { if ln = = ln 2 & & vec Matching . On { p . errorf ( " " , ln ) } } } } } 
func ( p * parser ) unary Expr ( ) Expr { switch t : = p . peek ( ) ; t . typ { case Item ADD , Item SUB : p . next ( ) e : = p . unary Expr ( ) } return nl } return & Unary Expr { Op : t . typ , Expr : e } case Item Left Paren : p . next ( ) e : = p . expr ( ) p . expect ( Item Right Paren , " " ) return & Paren Expr { Expr : e } } e : = p . primary Expr ( ) } switch s : = e . ( type ) { case * Vector Selector : s . Offset = offset case * Matrix Selector : s . Offset = offset case * Subquery Expr : s . Offset = offset default : p . errorf ( " " , e ) } } return e } 
func ( p * parser ) subquery Or Range Selector ( expr Expr , check Range bool ) Expr { ctx : = " " if check Range { ctx = " " } p . next ( ) var erange time . Duration var err error erange Str : = p . expect ( Item Duration , ctx ) . val erange , err = parse Duration ( erange Str ) if err ! = nil { p . error ( err ) } var itm item if check Range { itm = p . expect One Of ( Item Right Bracket , Item Colon , ctx ) if itm . typ = = Item Right Bracket { if ! ok { p . errorf ( " " , expr ) } return & Matrix Selector { Name : vs . Name , Label Matchers : vs . Label Matchers , Range : erange , } } } else { itm = p . expect ( Item Colon , ctx ) } itm = p . expect One Of ( Item Right Bracket , Item Duration , ctx ) if itm . typ = = Item Duration { estep Str : = itm . val estep , err = parse Duration ( estep Str ) if err ! = nil { p . error ( err ) } p . expect ( Item Right Bracket , ctx ) } return & Subquery Expr { Expr : expr , Range : erange , Step : estep , } } 
func ( p * parser ) number ( val string ) float 6 4 { n , err : = strconv . Parse Int ( val , 0 , 6 4 ) f : = float 6 4 ( n ) if err ! = nil { f , err = strconv . Parse Float ( val , 6 4 ) } if err ! = nil { p . errorf ( " " , err ) } return f } 
func ( p * parser ) primary Expr ( ) Expr { switch t : = p . next ( ) ; { case t . typ = = Item Number : f : = p . number ( t . val ) return & Number Literal { f } case t . typ = = Item String : return & String Literal { p . unquote String ( t . val ) } case t . typ = = Item Left Brace : return p . Vector Selector ( " " ) case t . typ = = Item Identifier : } fallthrough case t . typ = = Item Metric Identifier : return p . Vector Selector ( t . val ) case t . typ . is Aggregator ( ) : p . backup ( ) return p . aggr Expr ( ) default : p . errorf ( " " ) } return nil } 
func ( p * parser ) labels ( ) [ ] string { const ctx = " " p . expect ( Item Left Paren , ctx ) labels : = [ ] string { } if p . peek ( ) . typ ! = Item Right Paren { for { id : = p . next ( ) if ! is Label ( id . val ) { p . errorf ( " " , id . desc ( ) , ctx ) } labels = append ( labels , id . val ) if p . peek ( ) . typ ! = Item Comma { break } p . next ( ) } } p . expect ( Item Right Paren , ctx ) return labels } 
func ( p * parser ) aggr Expr ( ) * Aggregate Expr { const ctx = " " agop : = p . next ( ) if ! agop . typ . is Aggregator ( ) { p . errorf ( " " , agop ) } var grouping [ ] string var without bool modifiers First : = false if t : = p . peek ( ) . typ ; t = = Item By | | t = = Item Without { if t = = Item Without { without = true } p . next ( ) grouping = p . labels ( ) modifiers First = true } p . expect ( Item Left Paren , ctx ) var param Expr if agop . typ . is Aggregator With Param ( ) { param = p . expr ( ) p . expect ( Item Comma , ctx ) } e : = p . expr ( ) p . expect ( Item Right Paren , ctx ) if ! modifiers First { if t : = p . peek ( ) . typ ; t = = Item By | | t = = Item Without { if len ( grouping ) > 0 { p . errorf ( " " ) } if t = = Item Without { without = true } p . next ( ) grouping = p . labels ( ) } } return & Aggregate Expr { Op : agop . typ , Expr : e , Param : param , Grouping : grouping , Without : without , } } 
func ( p * parser ) call ( name string ) * Call { const ctx = " " fn , exist : = get Function ( name ) if ! exist { p . errorf ( " " , name ) } p . expect ( Item Left Paren , ctx ) return & Call { fn , nil } } var args [ ] Expr for { e : = p . expr ( ) args = append ( args , e ) } p . next ( ) } return & Call { Func : fn , Args : args } } 
func ( p * parser ) label Set ( ) labels . Labels { set : = [ ] labels . Label { } for _ , lm : = range p . label Matchers ( Item EQL ) { set = append ( set , labels . Label { Name : lm . Name , Value : lm . Value } ) } return labels . New ( set . . . ) } 
func ( p * parser ) label Matchers ( operators . . . Item Type ) [ ] * labels . Matcher { const ctx = " " matchers : = [ ] * labels . Matcher { } p . expect ( Item Left Brace , ctx ) return matchers } for { label : = p . expect ( Item Identifier , ctx ) op : = p . next ( ) . typ if ! op . is Operator ( ) { p . errorf ( " " , op ) } var valid Op = false for _ , allowed Op : = range operators { if op = = allowed Op { valid Op = true } } if ! valid Op { p . errorf ( " " , operators , op ) } val : = p . unquote String ( p . expect ( Item String , ctx ) . val ) switch op { case Item EQL : match Type = labels . Match Equal case Item NEQ : match Type = labels . Match Not Equal case Item EQLRegex : match Type = labels . Match Regexp case Item NEQRegex : match Type = labels . Match Not Regexp default : p . errorf ( " " , op ) } m , err : = labels . New Matcher ( match Type , label . val , val ) if err ! = nil { p . error ( err ) } matchers = append ( matchers , m ) if p . peek ( ) . typ = = Item Identifier { p . errorf ( " " , p . peek ( ) . val ) } } p . next ( ) } } p . expect ( Item Right Brace , ctx ) return matchers } 
func ( p * parser ) metric ( ) labels . Labels { name : = " " var m labels . Labels t : = p . peek ( ) . typ if t = = Item Identifier | | t = = Item Metric Identifier { name = p . next ( ) . val t = p . peek ( ) . typ } if t ! = Item Left Brace & & name = = " " { p . errorf ( " " ) } if t = = Item Left Brace { m = p . label Set ( ) } if name ! = " " { m = append ( m , labels . Label { Name : labels . Metric Name , Value : name } ) sort . Sort ( m ) } return m } 
func ( p * parser ) offset ( ) time . Duration { const ctx = " " p . next ( ) offi : = p . expect ( Item Duration , ctx ) offset , err : = parse Duration ( offi . val ) if err ! = nil { p . error ( err ) } return offset } 
func ( p * parser ) Vector Selector ( name string ) * Vector Selector { var matchers [ ] * labels . Matcher } } } if err ! = nil { panic ( err ) } matchers = append ( matchers , m ) } if len ( matchers ) = = 0 { p . errorf ( " " ) } for _ , lm : = range matchers { if ! lm . Matches ( " " ) { not Empty = true break } } if ! not Empty { p . errorf ( " " ) } return & Vector Selector { Name : name , Label Matchers : matchers , } } 
func ( p * parser ) expect Type ( node Node , want Value Type , context string ) { t : = p . check Type ( node ) if t ! = want { p . errorf ( " " , documented Type ( want ) , context , documented Type ( t ) ) } } 
func ( p * parser ) check Type ( node Node ) ( typ Value Type ) { case Expr : typ = n . Type ( ) default : p . errorf ( " " , node ) } if ty = = Value Type None { p . errorf ( " " , documented Type ( ty ) ) } case Expressions : for _ , e : = range n { ty : = p . check Type ( e ) if ty = = Value Type None { p . errorf ( " " , documented Type ( ty ) ) } } case * Aggregate Expr : if ! n . Op . is Aggregator ( ) { p . errorf ( " " , n . Op ) } p . expect Type ( n . Expr , Value Type Vector , " " ) if n . Op = = Item Top K | | n . Op = = Item Bottom K | | n . Op = = Item Quantile { p . expect Type ( n . Param , Value Type Scalar , " " ) } if n . Op = = Item Count Values { p . expect Type ( n . Param , Value Type String , " " ) } case * Binary Expr : lt : = p . check Type ( n . LHS ) rt : = p . check Type ( n . RHS ) if ! n . Op . is Operator ( ) { p . errorf ( " " , n . Op ) } if ( lt ! = Value Type Scalar & & lt ! = Value Type Vector ) | | ( rt ! = Value Type Scalar & & rt ! = Value Type Vector ) { p . errorf ( " " ) } if ( lt ! = Value Type Vector | | rt ! = Value Type Vector ) & & n . Vector Matching ! = nil { if len ( n . Vector Matching . Matching Labels ) > 0 { p . errorf ( " " ) } n . Vector Matching = nil } else { } if n . Vector Matching . Card ! = Card Many To Many { p . errorf ( " " ) } } } if ( lt = = Value Type Scalar | | rt = = Value Type Scalar ) & & n . Op . is Set Operator ( ) { p . errorf ( " " , n . Op ) } case * Call : nargs : = len ( n . Func . Arg Types ) if n . Func . Variadic = = 0 { if nargs ! = len ( n . Args ) { p . errorf ( " " , nargs , n . Func . Name , len ( n . Args ) ) } } else { na : = nargs - 1 if na > len ( n . Args ) { p . errorf ( " " , na , n . Func . Name , len ( n . Args ) ) } else if nargsmax : = na + n . Func . Variadic ; n . Func . Variadic > 0 & & nargsmax < len ( n . Args ) { p . errorf ( " " , nargsmax , n . Func . Name , len ( n . Args ) ) } } for i , arg : = range n . Args { if i > = len ( n . Func . Arg Types ) { i = len ( n . Func . Arg Types ) - 1 } p . expect Type ( arg , n . Func . Arg Types [ i ] , fmt . Sprintf ( " " , n . Func . Name ) ) } case * Paren Expr : p . check Type ( n . Expr ) case * Unary Expr : if n . Op ! = Item ADD & & n . Op ! = Item SUB { p . errorf ( " " ) } if t : = p . check Type ( n . Expr ) ; t ! = Value Type Scalar & & t ! = Value Type Vector { p . errorf ( " " , documented Type ( t ) ) } case * Subquery Expr : ty : = p . check Type ( n . Expr ) if ty ! = Value Type Vector { p . errorf ( " " , ty , n . String ( ) ) } case * Number Literal , * Matrix Selector , * String Literal , * Vector Selector : } return } 
func ( s * Storage ) Appender ( ) ( storage . Appender , error ) { return & timestamp Tracker { storage : s , } , nil } 
func ( t * timestamp Tracker ) Add ( _ labels . Labels , ts int 6 4 , v float 6 4 ) ( uint 6 4 , error ) { t . samples + + if ts > t . highest Timestamp { t . highest Timestamp = ts } return 0 , nil } 
func ( t * timestamp Tracker ) Add Fast ( l labels . Labels , _ uint 6 4 , ts int 6 4 , v float 6 4 ) error { _ , err : = t . Add ( l , ts , v ) return err } 
func ( t * timestamp Tracker ) Commit ( ) error { t . storage . samples In . incr ( t . samples ) samples In . Add ( float 6 4 ( t . samples ) ) highest Timestamp . Set ( float 6 4 ( t . highest Timestamp / 1 0 0 0 ) ) return nil } 
func ( p * problems ) Add ( mf dto . Metric Family , text string ) { * p = append ( * p , Problem { Metric : mf . Get Name ( ) , Text : text , } ) } 
func ( l * Linter ) Lint ( ) ( [ ] Problem , error ) { var problems [ ] Problem var mf dto . Metric Family for { if err : = d . Decode ( & mf ) ; err ! = nil { if err = = io . EOF { break } return nil , err } problems = append ( problems , lint ( mf ) . . . ) } } return problems [ i ] . Text < problems [ j ] . Text } ) return problems , nil } 
func lint ( mf dto . Metric Family ) [ ] Problem { fns : = [ ] func ( mf dto . Metric Family ) [ ] Problem { lint Help , lint Metric Units , lint Counter , lint Histogram Summary Reserved , } var problems [ ] Problem for _ , fn : = range fns { problems = append ( problems , fn ( mf ) . . . ) } } 
func lint Help ( mf dto . Metric Family ) [ ] Problem { var problems problems } return problems } 
func lint Metric Units ( mf dto . Metric Family ) [ ] Problem { var problems problems unit , base , ok : = metric Units ( * mf . Name ) if ! ok { } } problems . Add ( mf , fmt . Sprintf ( " " , base , unit ) ) return problems } 
func lint Counter ( mf dto . Metric Family ) [ ] Problem { var problems problems is Counter : = mf . Get Type ( ) = = dto . Metric Type _COUNTER is Untyped : = mf . Get Type ( ) = = dto . Metric Type _UNTYPED has Total Suffix : = strings . Has Suffix ( mf . Get Name ( ) , " " ) switch { case is Counter & & ! has Total Suffix : problems . Add ( mf , `counter metrics should have " _total " suffix ` ) case ! is Untyped & & ! is Counter & & has Total Suffix : problems . Add ( mf , `non -counter metrics should not have " _total " suffix ` ) } return problems } 
func lint Histogram Summary Reserved ( mf dto . Metric Family ) [ ] Problem { if t = = dto . Metric Type _UNTYPED { return nil } var problems problems is Histogram : = t = = dto . Metric Type _HISTOGRAM is Summary : = t = = dto . Metric Type _SUMMARY n : = mf . Get Name ( ) if ! is Histogram & & strings . Has Suffix ( n , " " ) { problems . Add ( mf , `non -histogram metrics should not have " _bucket " suffix ` ) } if ! is Histogram & & ! is Summary & & strings . Has Suffix ( n , " " ) { problems . Add ( mf , `non -histogram and non -summary metrics should not have " _count " suffix ` ) } if ! is Histogram & & ! is Summary & & strings . Has Suffix ( n , " " ) { problems . Add ( mf , `non -histogram and non -summary metrics should not have " _sum " suffix ` ) } for _ , m : = range mf . Get Metric ( ) { for _ , l : = range m . Get Label ( ) { ln : = l . Get Name ( ) if ! is Histogram & & ln = = " " { problems . Add ( mf , `non -histogram metrics should not have "le " label ` ) } if ! is Summary & & ln = = " " { problems . Add ( mf , `non -summary metrics should not have "quantile " label ` ) } } } return problems } 
func metric Units ( m string ) ( unit string , base string , ok bool ) { ss : = strings . Split ( m , " " ) for _ , u : = range base Units { } } } } return " " , " " , false } 
func New Client ( logger log . Logger , address string , transport string , timeout time . Duration , prefix string ) * Client { if logger = = nil { logger = log . New Nop Logger ( ) } return & Client { logger : logger , address : address , transport : transport , timeout : timeout , prefix : prefix , } } 
func ( c * Client ) Write ( samples model . Samples ) error { conn , err : = net . Dial Timeout ( c . transport , c . address , c . timeout ) if err ! = nil { return err } defer conn . Close ( ) var buf bytes . Buffer for _ , s : = range samples { k : = path From Metric ( s . Metric , c . prefix ) t : = float 6 4 ( s . Timestamp . Unix Nano ( ) ) / 1e 9 v : = float 6 4 ( s . Value ) if math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) continue } fmt . Fprintf ( & buf , " \n " , k , v , t ) } _ , err = conn . Write ( buf . Bytes ( ) ) return err } 
func New ( min Size , max Size int , factor float 6 4 , make Func func ( int ) interface { } ) * Pool { if min Size < 1 { panic ( " " ) } if max Size < 1 { panic ( " " ) } if factor < 1 { panic ( " " ) } var sizes [ ] int for s : = min Size ; s < = max Size ; s = int ( float 6 4 ( s ) * factor ) { sizes = append ( sizes , s ) } p : = & Pool { buckets : make ( [ ] sync . Pool , len ( sizes ) ) , sizes : sizes , make : make Func , } return p } 
func ( p * Pool ) Get ( sz int ) interface { } { for i , bkt Size : = range p . sizes { if sz > bkt Size { continue } b : = p . buckets [ i ] . Get ( ) if b = = nil { b = p . make ( bkt Size ) } return b } return p . make ( sz ) } 
func ( p * Pool ) Put ( s interface { } ) { slice : = reflect . Value Of ( s ) if slice . Kind ( ) ! = reflect . Slice { panic ( fmt . Sprintf ( " " , slice ) ) } for i , size : = range p . sizes { if slice . Cap ( ) > size { continue } p . buckets [ i ] . Put ( slice . Slice ( 0 , 0 ) . Interface ( ) ) return } } 
func ( p Point ) Marshal JSON ( ) ( [ ] byte , error ) { v : = strconv . Format Float ( p . V , 'f ' , - 1 , 6 4 ) return json . Marshal ( [ . . . ] interface { } { float 6 4 ( p . T ) / 1 0 0 0 , v } ) } 
func ( vec Vector ) Contains Same Labelset ( ) bool { l : = make ( map [ uint 6 4 ] struct { } , len ( vec ) ) for _ , s : = range vec { hash : = s . Metric . Hash ( ) if _ , ok : = l [ hash ] ; ok { return true } l [ hash ] = struct { } { } } return false } 
func ( m Matrix ) Total Samples ( ) int { num Samples : = 0 for _ , series : = range m { num Samples + = len ( series . Points ) } return num Samples } 
func ( m Matrix ) Contains Same Labelset ( ) bool { l : = make ( map [ uint 6 4 ] struct { } , len ( m ) ) for _ , ss : = range m { hash : = ss . Metric . Hash ( ) if _ , ok : = l [ hash ] ; ok { return true } l [ hash ] = struct { } { } } return false } 
func ( r * Result ) Vector ( ) ( Vector , error ) { if r . Err ! = nil { return nil , r . Err } v , ok : = r . Value . ( Vector ) if ! ok { return nil , errors . New ( " " ) } return v , nil } 
func ( r * Result ) Scalar ( ) ( Scalar , error ) { if r . Err ! = nil { return Scalar { } , r . Err } v , ok : = r . Value . ( Scalar ) if ! ok { return Scalar { } , errors . New ( " " ) } return v , nil } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if c . Region = = " " { sess , err : = session . New Session ( ) if err ! = nil { return err } metadata : = ec 2metadata . New ( sess ) region , err : = metadata . Region ( ) if err ! = nil { return errors . New ( " " ) } c . Region = region } for _ , f : = range c . Filters { if len ( f . Values ) = = 0 { return errors . New ( " " ) } } return nil } 
func New Discovery ( conf * SDConfig , logger log . Logger ) * Discovery { creds : = credentials . New Static Credentials ( conf . Access Key , string ( conf . Secret Key ) , " " ) if conf . Access Key = = " " & & conf . Secret Key = = " " { creds = nil } if logger = = nil { logger = log . New Nop Logger ( ) } d : = & Discovery { aws : & aws . Config { Endpoint : & conf . Endpoint , Region : & conf . Region , Credentials : creds , } , profile : conf . Profile , role ARN : conf . Role ARN , filters : conf . Filters , interval : time . Duration ( conf . Refresh Interval ) , port : conf . Port , } d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( conf . Refresh Interval ) , d . refresh , ) return d } 
func ( d * discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { for c : = time . Tick ( time . Duration ( d . refresh Interval ) * time . Second ) ; ; { var srvs map [ string ] [ ] string resp , err : = http . Get ( fmt . Sprintf ( " " , d . address ) ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( d . refresh Interval ) * time . Second ) continue } dec : = json . New Decoder ( resp . Body ) err = dec . Decode ( & srvs ) resp . Body . Close ( ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( d . refresh Interval ) * time . Second ) continue } var tgs [ ] * targetgroup . Group for name : = range srvs { if name = = " " { continue } resp , err : = http . Get ( fmt . Sprintf ( " " , d . address , name ) ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , name , " " , err ) break } tg , err : = d . parse Service Nodes ( resp , name ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , name , " " , err ) break } tgs = append ( tgs , tg ) new Source List [ tg . Source ] = true } } } d . old Source List = new Source List if err = = nil { } case < - ctx . Done ( ) : return } } } 
func New Queue Manager ( logger log . Logger , wal Dir string , samples In * ewma Rate , cfg config . Queue Config , external Labels labels . Labels , relabel Configs [ ] * relabel . Config , client Storage Client , flush Deadline time . Duration ) * Queue Manager { if logger = = nil { logger = log . New Nop Logger ( ) } name : = client . Name ( ) logger = log . With ( logger , " " , name ) t : = & Queue Manager { logger : logger , flush Deadline : flush Deadline , cfg : cfg , external Labels : external Labels , relabel Configs : relabel Configs , client : client , series Labels : make ( map [ uint 6 4 ] [ ] prompb . Label ) , series Segment Indexes : make ( map [ uint 6 4 ] int ) , dropped Series : make ( map [ uint 6 4 ] struct { } ) , num Shards : cfg . Min Shards , reshard Chan : make ( chan int ) , quit : make ( chan struct { } ) , samples In : samples In , samples Dropped : new EWMARate ( ewma Weight , shard Update Duration ) , samples Out : new EWMARate ( ewma Weight , shard Update Duration ) , samples Out Duration : new EWMARate ( ewma Weight , shard Update Duration ) , } t . watcher = New WALWatcher ( logger , name , t , wal Dir ) t . shards = t . new Shards ( ) return t } 
func ( t * Queue Manager ) Append ( s [ ] tsdb . Ref Sample ) bool { type enqueuable struct { ts prompb . Time Series ref uint 6 4 } temp Samples : = make ( [ ] enqueuable , 0 , len ( s ) ) t . series Mtx . Lock ( ) for _ , sample : = range s { t . samples Dropped . incr ( 1 ) if _ , ok : = t . dropped Series [ sample . Ref ] ; ! ok { level . Info ( t . logger ) . Log ( " " , " " , " " , sample . Ref ) } continue } temp Samples = append ( temp Samples , enqueuable { ts : prompb . Time Series { Labels : t . series Labels [ sample . Ref ] , Samples : [ ] prompb . Sample { prompb . Sample { Value : float 6 4 ( sample . V ) , Timestamp : sample . T , } , } , } , ref : sample . Ref , } ) } t . series Mtx . Unlock ( ) outer : for _ , sample : = range temp Samples { for { select { case < - t . quit : return false default : } if t . shards . enqueue ( sample . ref , sample . ts ) { continue outer } t . enqueue Retries Metric . Inc ( ) time . Sleep ( time . Duration ( backoff ) ) backoff = backoff * 2 if backoff > t . cfg . Max Backoff { backoff = t . cfg . Max Backoff } } } return true } 
func ( t * Queue Manager ) Start ( ) { t . highest Sent Timestamp Metric = & max Gauge { Gauge : queue Highest Sent Timestamp . With Label Values ( name ) , } t . pending Samples Metric = queue Pending Samples . With Label Values ( name ) t . enqueue Retries Metric = enqueue Retries Total . With Label Values ( name ) t . dropped Samples Total = dropped Samples Total . With Label Values ( name ) t . num Shards Metric = num Shards . With Label Values ( name ) t . failed Samples Total = failed Samples Total . With Label Values ( name ) t . sent Batch Duration = sent Batch Duration . With Label Values ( name ) t . succeeded Samples Total = succeeded Samples Total . With Label Values ( name ) t . retried Samples Total = retried Samples Total . With Label Values ( name ) t . shard Capacity = shard Capacity . With Label Values ( name ) t . pending Samples Metric . Set ( 0 ) t . shards . start ( t . num Shards ) t . watcher . Start ( ) t . wg . Add ( 2 ) go t . update Shards Loop ( ) go t . reshard Loop ( ) } 
func ( t * Queue Manager ) Stop ( ) { level . Info ( t . logger ) . Log ( " " , " " ) defer level . Info ( t . logger ) . Log ( " " , " " ) close ( t . quit ) t . wg . Wait ( ) t . watcher . Stop ( ) defer t . series Mtx . Unlock ( ) for _ , labels : = range t . series Labels { release ( labels ) } queue Highest Sent Timestamp . Delete Label Values ( name ) queue Pending Samples . Delete Label Values ( name ) enqueue Retries Total . Delete Label Values ( name ) dropped Samples Total . Delete Label Values ( name ) num Shards . Delete Label Values ( name ) failed Samples Total . Delete Label Values ( name ) sent Batch Duration . Delete Label Values ( name ) succeeded Samples Total . Delete Label Values ( name ) retried Samples Total . Delete Label Values ( name ) shard Capacity . Delete Label Values ( name ) } 
func ( t * Queue Manager ) Store Series ( series [ ] tsdb . Ref Series , index int ) { defer t . series Mtx . Unlock ( ) temp : = make ( map [ uint 6 4 ] [ ] prompb . Label , len ( series ) ) for _ , s : = range series { ls : = process External Labels ( s . Labels , t . external Labels ) rl : = relabel . Process ( ls , t . relabel Configs . . . ) if len ( rl ) = = 0 { t . dropped Series [ s . Ref ] = struct { } { } continue } temp [ s . Ref ] = labels To Labels Proto ( rl ) } for ref , labels : = range temp { t . series Segment Indexes [ ref ] = index } t . series Labels [ ref ] = labels } } 
func ( t * Queue Manager ) Series Reset ( index int ) { t . series Mtx . Lock ( ) defer t . series Mtx . Unlock ( ) release ( t . series Labels [ k ] ) delete ( t . series Labels , k ) } } } 
func process External Labels ( ls tsdb Labels . Labels , external Labels labels . Labels ) labels . Labels { i , j , result : = 0 , 0 , make ( labels . Labels , 0 , len ( ls ) + len ( external Labels ) ) for i < len ( ls ) & & j < len ( external Labels ) { if ls [ i ] . Name < external Labels [ j ] . Name { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i + + } else if ls [ i ] . Name > external Labels [ j ] . Name { result = append ( result , external Labels [ j ] ) j + + } else { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) i + + j + + } } for ; i < len ( ls ) ; i + + { result = append ( result , labels . Label { Name : ls [ i ] . Name , Value : ls [ i ] . Value , } ) } result = append ( result , external Labels [ j : ] . . . ) return result } 
func ( s * shards ) start ( n int ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) new Queues : = make ( [ ] chan prompb . Time Series , n ) for i : = 0 ; i < n ; i + + { new Queues [ i ] = make ( chan prompb . Time Series , s . qm . cfg . Capacity ) } s . queues = new Queues var hard Shutdown Ctx context . Context hard Shutdown Ctx , s . hard Shutdown = context . With Cancel ( context . Background ( ) ) s . soft Shutdown = make ( chan struct { } ) s . running = int 3 2 ( n ) s . done = make ( chan struct { } ) for i : = 0 ; i < n ; i + + { go s . run Shard ( hard Shutdown Ctx , i , new Queues [ i ] ) } s . qm . num Shards Metric . Set ( float 6 4 ( n ) ) } 
func ( s * shards ) stop ( ) { close ( s . soft Shutdown ) s . mtx . RUnlock ( ) defer s . mtx . Unlock ( ) for _ , queue : = range s . queues { close ( queue ) } select { case < - s . done : return case < - time . After ( s . qm . flush Deadline ) : level . Error ( s . qm . logger ) . Log ( " " , " " ) } < - s . done } 
func ( s * shards ) enqueue ( ref uint 6 4 , sample prompb . Time Series ) bool { s . mtx . RLock ( ) defer s . mtx . RUnlock ( ) select { case < - s . soft Shutdown : return false default : } shard : = uint 6 4 ( ref ) % uint 6 4 ( len ( s . queues ) ) select { case < - s . soft Shutdown : return false case s . queues [ shard ] < - sample : return true } } 
func ( s * shards ) send Samples With Backoff ( ctx context . Context , samples [ ] prompb . Time Series ) error { backoff : = s . qm . cfg . Min Backoff req , highest , err : = build Write Request ( samples ) if err ! = nil { } for { select { case < - ctx . Done ( ) : return ctx . Err ( ) default : } begin : = time . Now ( ) err : = s . qm . client . Store ( ctx , req ) s . qm . sent Batch Duration . Observe ( time . Since ( begin ) . Seconds ( ) ) if err = = nil { s . qm . succeeded Samples Total . Add ( float 6 4 ( len ( samples ) ) ) s . qm . highest Sent Timestamp Metric . Set ( float 6 4 ( highest / 1 0 0 0 ) ) return nil } if _ , ok : = err . ( recoverable Error ) ; ! ok { return err } s . qm . retried Samples Total . Add ( float 6 4 ( len ( samples ) ) ) level . Debug ( s . qm . logger ) . Log ( " " , " " , " " , err ) time . Sleep ( time . Duration ( backoff ) ) backoff = backoff * 2 if backoff > s . qm . cfg . Max Backoff { backoff = s . qm . cfg . Max Backoff } } } 
func ( c * Role ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { if err : = unmarshal ( ( * string ) ( c ) ) ; err ! = nil { return err } switch * c { case Role Node , Role Pod , Role Service , Role Endpoint , Role Ingress : return nil default : return errors . Errorf ( " " , * c ) } } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = SDConfig { } type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if c . Role = = " " { return errors . Errorf ( " " ) } err = c . HTTPClient Config . Validate ( ) if err ! = nil { return err } if c . APIServer . URL = = nil & & ! reflect . Deep Equal ( c . HTTPClient Config , config _util . HTTPClient Config { } ) { return errors . Errorf ( " " ) } return nil } 
func ( c * Namespace Discovery ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Namespace Discovery { } type plain Namespace Discovery return unmarshal ( ( * plain ) ( c ) ) } 
func New ( l log . Logger , conf * SDConfig ) ( * Discovery , error ) { if l = = nil { l = log . New Nop Logger ( ) } var ( kcfg * rest . Config err error ) if conf . APIServer . URL = = nil { if err ! = nil { return nil , err } level . Info ( l ) . Log ( " " , " " ) } else { rt , err : = config _util . New Round Tripper From Config ( conf . HTTPClient Config , " " ) if err ! = nil { return nil , err } kcfg = & rest . Config { Host : conf . APIServer . String ( ) , Transport : rt , } } kcfg . User Agent = " " c , err : = kubernetes . New For Config ( kcfg ) if err ! = nil { return nil , err } return & Discovery { client : c , logger : l , role : conf . Role , namespace Discovery : & conf . Namespace Discovery , discoverers : make ( [ ] discoverer , 0 ) , } , nil } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { d . Lock ( ) namespaces : = d . get Namespaces ( ) switch d . role { case Role Endpoint : for _ , namespace : = range namespaces { e : = d . client . Core V 1 ( ) . Endpoints ( namespace ) elw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return e . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return e . Watch ( options ) } , } s : = d . client . Core V 1 ( ) . Services ( namespace ) slw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return s . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return s . Watch ( options ) } , } p : = d . client . Core V 1 ( ) . Pods ( namespace ) plw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return p . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return p . Watch ( options ) } , } eps : = New Endpoints ( log . With ( d . logger , " " , " " ) , cache . New Shared Informer ( slw , & apiv 1 . Service { } , resync Period ) , cache . New Shared Informer ( elw , & apiv 1 . Endpoints { } , resync Period ) , cache . New Shared Informer ( plw , & apiv 1 . Pod { } , resync Period ) , ) d . discoverers = append ( d . discoverers , eps ) go eps . endpoints Inf . Run ( ctx . Done ( ) ) go eps . service Inf . Run ( ctx . Done ( ) ) go eps . pod Inf . Run ( ctx . Done ( ) ) } case Role Pod : for _ , namespace : = range namespaces { p : = d . client . Core V 1 ( ) . Pods ( namespace ) plw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return p . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return p . Watch ( options ) } , } pod : = New Pod ( log . With ( d . logger , " " , " " ) , cache . New Shared Informer ( plw , & apiv 1 . Pod { } , resync Period ) , ) d . discoverers = append ( d . discoverers , pod ) go pod . informer . Run ( ctx . Done ( ) ) } case Role Service : for _ , namespace : = range namespaces { s : = d . client . Core V 1 ( ) . Services ( namespace ) slw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return s . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return s . Watch ( options ) } , } svc : = New Service ( log . With ( d . logger , " " , " " ) , cache . New Shared Informer ( slw , & apiv 1 . Service { } , resync Period ) , ) d . discoverers = append ( d . discoverers , svc ) go svc . informer . Run ( ctx . Done ( ) ) } case Role Ingress : for _ , namespace : = range namespaces { i : = d . client . Extensions V 1beta 1 ( ) . Ingresses ( namespace ) ilw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return i . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return i . Watch ( options ) } , } ingress : = New Ingress ( log . With ( d . logger , " " , " " ) , cache . New Shared Informer ( ilw , & extensionsv 1beta 1 . Ingress { } , resync Period ) , ) d . discoverers = append ( d . discoverers , ingress ) go ingress . informer . Run ( ctx . Done ( ) ) } case Role Node : nlw : = & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { return d . client . Core V 1 ( ) . Nodes ( ) . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { return d . client . Core V 1 ( ) . Nodes ( ) . Watch ( options ) } , } node : = New Node ( log . With ( d . logger , " " , " " ) , cache . New Shared Informer ( nlw , & apiv 1 . Node { } , resync Period ) , ) d . discoverers = append ( d . discoverers , node ) go node . informer . Run ( ctx . Done ( ) ) default : level . Error ( d . logger ) . Log ( " " , " " , " " , d . role ) } var wg sync . Wait Group for _ , dd : = range d . discoverers { wg . Add ( 1 ) go func ( d discoverer ) { defer wg . Done ( ) d . Run ( ctx , ch ) } ( dd ) } d . Unlock ( ) wg . Wait ( ) < - ctx . Done ( ) } 
func compile CORSRegex String ( s string ) ( * regexp . Regexp , error ) { r , err : = relabel . New Regexp ( s ) if err ! = nil { return nil , err } return r . Regexp , nil } 
func compute External URL ( u , listen Addr string ) ( * url . URL , error ) { if u = = " " { hostname , err : = os . Hostname ( ) if err ! = nil { return nil , err } _ , port , err : = net . Split Host Port ( listen Addr ) if err ! = nil { return nil , err } u = fmt . Sprintf ( " " , hostname , port ) } if starts Or Ends With Quote ( u ) { return nil , errors . New ( " " ) } eu , err : = url . Parse ( u ) if err ! = nil { return nil , err } ppref : = strings . Trim Right ( eu . Path , " " ) if ppref ! = " " & & ! strings . Has Prefix ( ppref , " " ) { ppref = " " + ppref } eu . Path = ppref return eu , nil } 
func send Alerts ( s sender , external URL string ) rules . Notify Func { return func ( ctx context . Context , expr string , alerts . . . * rules . Alert ) { var res [ ] * notifier . Alert for _ , alert : = range alerts { a : = & notifier . Alert { Starts At : alert . Fired At , Labels : alert . Labels , Annotations : alert . Annotations , Generator URL : external URL + strutil . Table Link For Expression ( expr ) , } if ! alert . Resolved At . Is Zero ( ) { a . Ends At = alert . Resolved At } else { a . Ends At = alert . Valid Until } res = append ( res , a ) } if len ( alerts ) > 0 { s . Send ( res . . . ) } } } 
func ( g * Rule Groups ) Validate ( ) ( errs [ ] error ) { set : = map [ string ] struct { } { } for _ , g : = range g . Groups { if g . Name = = " " { errs = append ( errs , errors . Errorf ( " " ) ) } if _ , ok : = set [ g . Name ] ; ok { errs = append ( errs , errors . Errorf ( " \ " \ " " , g . Name ) , ) } set [ g . Name ] = struct { } { } for i , r : = range g . Rules { for _ , err : = range r . Validate ( ) { var rule Name string if r . Alert ! = " " { rule Name = r . Alert } else { rule Name = r . Record } errs = append ( errs , & Error { Group : g . Name , Rule : i , Rule Name : rule Name , Err : err , } ) } } } return errs } 
func ( r * Rule ) Validate ( ) ( errs [ ] error ) { if r . Record ! = " " & & r . Alert ! = " " { errs = append ( errs , errors . Errorf ( " " ) ) } if r . Record = = " " & & r . Alert = = " " { errs = append ( errs , errors . Errorf ( " " ) ) } if r . Expr = = " " { errs = append ( errs , errors . Errorf ( " " ) ) } else if _ , err : = promql . Parse Expr ( r . Expr ) ; err ! = nil { errs = append ( errs , errors . Errorf ( " " , err ) ) } if r . Record ! = " " { if len ( r . Annotations ) > 0 { errs = append ( errs , errors . Errorf ( " " ) ) } if r . For ! = 0 { errs = append ( errs , errors . Errorf ( " " ) ) } if ! model . Is Valid Metric Name ( model . Label Value ( r . Record ) ) { errs = append ( errs , errors . Errorf ( " " , r . Record ) ) } } for k , v : = range r . Labels { if ! model . Label Name ( k ) . Is Valid ( ) { errs = append ( errs , errors . Errorf ( " " , k ) ) } if ! model . Label Value ( v ) . Is Valid ( ) { errs = append ( errs , errors . Errorf ( " " , v ) ) } } for k : = range r . Annotations { if ! model . Label Name ( k ) . Is Valid ( ) { errs = append ( errs , errors . Errorf ( " " , k ) ) } } errs = append ( errs , test Template Parsing ( r ) . . . ) return errs } 
func Parse ( content [ ] byte ) ( * Rule Groups , [ ] error ) { var groups Rule Groups if err : = yaml . Unmarshal Strict ( content , & groups ) ; err ! = nil { return nil , [ ] error { err } } return & groups , groups . Validate ( ) } 
func Parse File ( file string ) ( * Rule Groups , [ ] error ) { b , err : = ioutil . Read File ( file ) if err ! = nil { return nil , [ ] error { err } } return Parse ( b ) } 
func Table Link For Expression ( expr string ) string { escaped Expression : = url . Query Escape ( expr ) return fmt . Sprintf ( " " , escaped Expression ) } 
func Graph Link For Expression ( expr string ) string { escaped Expression : = url . Query Escape ( expr ) return fmt . Sprintf ( " " , escaped Expression ) } 
func New Fanout ( logger log . Logger , primary Storage , secondaries . . . Storage ) Storage { return & fanout { logger : logger , primary : primary , secondaries : secondaries , } } 
func ( f * fanout ) Start Time ( ) ( int 6 4 , error ) { if err ! = nil { return int 6 4 ( model . Latest ) , err } for _ , storage : = range f . secondaries { t , err : = storage . Start Time ( ) if err ! = nil { return int 6 4 ( model . Latest ) , err } if t < first Time { first Time = t } } return first Time , nil } 
func ( f * fanout ) Close ( ) error { if err : = f . primary . Close ( ) ; err ! = nil { return err } for _ , storage : = range f . secondaries { if err : = storage . Close ( ) ; err ! = nil { last Err = err } } return last Err } 
func New Merge Querier ( primary Querier Querier , queriers [ ] Querier ) Querier { filtered : = make ( [ ] Querier , 0 , len ( queriers ) ) for _ , querier : = range queriers { if querier ! = Noop Querier ( ) { filtered = append ( filtered , querier ) } } set Querier Map : = make ( map [ Series Set ] Querier ) failed Queriers : = make ( map [ Querier ] struct { } ) switch len ( filtered ) { case 0 : return Noop Querier ( ) case 1 : return filtered [ 0 ] default : return & merge Querier { primary Querier : primary Querier , queriers : filtered , failed Queriers : failed Queriers , set Querier Map : set Querier Map , } } } 
func ( q * merge Querier ) Select ( params * Select Params , matchers . . . * labels . Matcher ) ( Series Set , Warnings , error ) { series Sets : = make ( [ ] Series Set , 0 , len ( q . queriers ) ) var warnings Warnings for _ , querier : = range q . queriers { set , wrn , err : = querier . Select ( params , matchers . . . ) q . set Querier Map [ set ] = querier if wrn ! = nil { warnings = append ( warnings , wrn . . . ) } if err ! = nil { q . failed Queriers [ querier ] = struct { } { } continue } else { return nil , nil , err } } series Sets = append ( series Sets , set ) } return New Merge Series Set ( series Sets , q ) , warnings , nil } 
func ( q * merge Querier ) Label Values ( name string ) ( [ ] string , error ) { var results [ ] [ ] string for _ , querier : = range q . queriers { values , err : = querier . Label Values ( name ) if err ! = nil { return nil , err } results = append ( results , values ) } return merge String Slices ( results ) , nil } 
func ( q * merge Querier ) Label Names ( ) ( [ ] string , error ) { label Names Map : = make ( map [ string ] struct { } ) for _ , b : = range q . queriers { names , err : = b . Label Names ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , name : = range names { label Names Map [ name ] = struct { } { } } } label Names : = make ( [ ] string , 0 , len ( label Names Map ) ) for name : = range label Names Map { label Names = append ( label Names , name ) } sort . Strings ( label Names ) return label Names , nil } 
func ( q * merge Querier ) Close ( ) error { for _ , querier : = range q . queriers { if err : = querier . Close ( ) ; err ! = nil { last Err = err } } return last Err } 
func New Merge Series Set ( sets [ ] Series Set , querier * merge Querier ) Series Set { if len ( sets ) = = 1 { return sets [ 0 ] } for _ , set : = range sets { if set = = nil { continue } if set . Next ( ) { heap . Push ( & h , set ) } } return & merge Series Set { heap : h , sets : sets , querier : querier , } } 
func escape ( tv model . Label Value ) string { length : = len ( tv ) result : = bytes . New Buffer ( make ( [ ] byte , 0 , length ) ) for i : = 0 ; i < length ; i + + { b : = tv [ i ] switch { } } return result . String ( ) } 
func New Alerting Rule ( name string , vec promql . Expr , hold time . Duration , labels , annotations , external Labels labels . Labels , restored bool , logger log . Logger , ) * Alerting Rule { el : = make ( map [ string ] string , len ( external Labels ) ) for _ , lbl : = range external Labels { el [ lbl . Name ] = lbl . Value } return & Alerting Rule { name : name , vector : vec , hold Duration : hold , labels : labels , annotations : annotations , external Labels : el , health : Health Unknown , active : map [ uint 6 4 ] * Alert { } , logger : logger , restored : restored , } } 
func ( r * Alerting Rule ) Set Last Error ( err error ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . last Error = err } 
func ( r * Alerting Rule ) Last Error ( ) error { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . last Error } 
func ( r * Alerting Rule ) Set Health ( health Rule Health ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . health = health } 
func ( r * Alerting Rule ) Health ( ) Rule Health { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . health } 
func ( r * Alerting Rule ) for State Sample ( alert * Alert , ts time . Time , v float 6 4 ) promql . Sample { lb : = labels . New Builder ( r . labels ) for _ , l : = range alert . Labels { lb . Set ( l . Name , l . Value ) } lb . Set ( labels . Metric Name , alert For State Metric Name ) lb . Set ( labels . Alert Name , r . name ) s : = promql . Sample { Metric : lb . Labels ( ) , Point : promql . Point { T : timestamp . From Time ( ts ) , V : v } , } return s } 
func ( r * Alerting Rule ) Set Evaluation Duration ( dur time . Duration ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . evaluation Duration = dur } 
func ( r * Alerting Rule ) Get Evaluation Duration ( ) time . Duration { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . evaluation Duration } 
func ( r * Alerting Rule ) Set Evaluation Timestamp ( ts time . Time ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) r . evaluation Timestamp = ts } 
func ( r * Alerting Rule ) Get Evaluation Timestamp ( ) time . Time { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) return r . evaluation Timestamp } 
func ( r * Alerting Rule ) Eval ( ctx context . Context , ts time . Time , query Query Func , external URL * url . URL ) ( promql . Vector , error ) { res , err : = query ( ctx , r . vector . String ( ) , ts ) if err ! = nil { r . Set Health ( Health Bad ) r . Set Last Error ( err ) return nil , err } r . mtx . Lock ( ) defer r . mtx . Unlock ( ) var vec promql . Vector for _ , smpl : = range res { for _ , lbl : = range smpl . Metric { l [ lbl . Name ] = lbl . Value } tmpl Data : = template . Alert Template Data ( l , r . external Labels , smpl . V ) expand : = func ( text string ) string { tmpl : = template . New Template Expander ( ctx , strings . Join ( append ( defs , text ) , " " ) , " " + r . Name ( ) , tmpl Data , model . Time ( timestamp . From Time ( ts ) ) , template . Query Func ( query ) , external URL , ) result , err : = tmpl . Expand ( ) if err ! = nil { result = fmt . Sprintf ( " " , err ) level . Warn ( r . logger ) . Log ( " " , " " , " " , err , " " , tmpl Data ) } return result } lb : = labels . New Builder ( smpl . Metric ) . Del ( labels . Metric Name ) for _ , l : = range r . labels { lb . Set ( l . Name , expand ( l . Value ) ) } lb . Set ( labels . Alert Name , r . Name ( ) ) annotations : = make ( labels . Labels , 0 , len ( r . annotations ) ) for _ , a : = range r . annotations { annotations = append ( annotations , labels . Label { Name : a . Name , Value : expand ( a . Value ) } ) } lbs : = lb . Labels ( ) h : = lbs . Hash ( ) result FPs [ h ] = struct { } { } alert . Annotations = annotations continue } r . active [ h ] = & Alert { Labels : lbs , Annotations : annotations , Active At : ts , State : State Pending , Value : smpl . V , } } } if a . State ! = State Inactive { a . State = State Inactive a . Resolved At = ts } continue } if a . State = = State Pending & & ts . Sub ( a . Active At ) > = r . hold Duration { a . State = State Firing a . Fired At = ts } if r . restored { vec = append ( vec , r . sample ( a , ts ) ) vec = append ( vec , r . for State Sample ( a , ts , float 6 4 ( a . Active At . Unix ( ) ) ) ) } } r . last Error = err return vec , nil } 
func ( r * Alerting Rule ) State ( ) Alert State { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) max State : = State Inactive for _ , a : = range r . active { if a . State > max State { max State = a . State } } return max State } 
func ( r * Alerting Rule ) Active Alerts ( ) [ ] * Alert { var res [ ] * Alert for _ , a : = range r . current Alerts ( ) { if a . Resolved At . Is Zero ( ) { res = append ( res , a ) } } return res } 
func ( r * Alerting Rule ) current Alerts ( ) [ ] * Alert { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) alerts : = make ( [ ] * Alert , 0 , len ( r . active ) ) for _ , a : = range r . active { anew : = * a alerts = append ( alerts , & anew ) } return alerts } 
func ( r * Alerting Rule ) For Each Active Alert ( f func ( * Alert ) ) { r . mtx . Lock ( ) defer r . mtx . Unlock ( ) for _ , a : = range r . active { f ( a ) } } 
func ( r * Alerting Rule ) HTMLSnippet ( path Prefix string ) html _template . HTML { alert Metric : = model . Metric { model . Metric Name Label : alert Metric Name , alert Name Label : model . Label Value ( r . name ) , } labels Map : = make ( map [ string ] string , len ( r . labels ) ) for _ , l : = range r . labels { labels Map [ l . Name ] = html _template . HTMLEscape String ( l . Value ) } annotations Map : = make ( map [ string ] string , len ( r . annotations ) ) for _ , l : = range r . annotations { annotations Map [ l . Name ] = html _template . HTMLEscape String ( l . Value ) } ar : = rulefmt . Rule { Alert : fmt . Sprintf ( " " , path Prefix + strutil . Table Link For Expression ( alert Metric . String ( ) ) , r . name ) , Expr : fmt . Sprintf ( " " , path Prefix + strutil . Table Link For Expression ( r . vector . String ( ) ) , html _template . HTMLEscape String ( r . vector . String ( ) ) ) , For : model . Duration ( r . hold Duration ) , Labels : labels Map , Annotations : annotations Map , } byt , err : = yaml . Marshal ( ar ) if err ! = nil { return html _template . HTML ( fmt . Sprintf ( " " , html _template . HTMLEscape String ( err . Error ( ) ) ) ) } return html _template . HTML ( byt ) } 
func ( a * Adapter ) refresh Target Groups ( all Target Groups map [ string ] [ ] * targetgroup . Group ) { temp Groups : = generate Target Groups ( all Target Groups ) if ! reflect . Deep Equal ( a . groups , temp Groups ) { a . groups = temp Groups err : = a . write Output ( ) if err ! = nil { level . Error ( log . With ( a . logger , " " , " " ) ) . Log ( " " , err ) } } } 
func ( a * Adapter ) write Output ( ) error { arr : = map To Array ( a . groups ) b , _ : = json . Marshal Indent ( arr , " " , " " ) dir , _ : = filepath . Split ( a . output ) tmpfile , err : = ioutil . Temp File ( dir , " " ) if err ! = nil { return err } defer tmpfile . Close ( ) _ , err = tmpfile . Write ( b ) if err ! = nil { return err } err = os . Rename ( tmpfile . Name ( ) , a . output ) if err ! = nil { return err } return nil } 
func ( a * Adapter ) Run ( ) { go a . manager . Run ( ) a . manager . Start Custom Provider ( a . ctx , a . name , a . disc ) go a . run Custom SD ( a . ctx ) } 
func New Adapter ( ctx context . Context , file string , name string , d discovery . Discoverer , logger log . Logger ) * Adapter { return & Adapter { ctx : ctx , disc : d , groups : make ( map [ string ] * custom SD ) , manager : discovery . New Manager ( ctx , logger ) , output : file , name : name , logger : logger , } } 
func New Group Metrics ( reg prometheus . Registerer ) * Metrics { m : = & Metrics { eval Duration : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Name : " " , Help : " " , } ) , eval Failures : prometheus . New Counter ( prometheus . Counter Opts { Namespace : namespace , Name : " " , Help : " " , } ) , eval Total : prometheus . New Counter ( prometheus . Counter Opts { Namespace : namespace , Name : " " , Help : " " , } ) , iteration Duration : prometheus . New Summary ( prometheus . Summary Opts { Namespace : namespace , Name : " " , Help : " " , Objectives : map [ float 6 4 ] float 6 4 { 0 . 0 1 : 0 . 0 0 1 , 0 . 0 5 : 0 . 0 0 5 , 0 . 5 : 0 . 0 5 , 0 . 9 0 : 0 . 0 1 , 0 . 9 9 : 0 . 0 0 1 } , } ) , iterations Missed : prometheus . New Counter ( prometheus . Counter Opts { Namespace : namespace , Name : " " , Help : " " , } ) , iterations Scheduled : prometheus . New Counter ( prometheus . Counter Opts { Namespace : namespace , Name : " " , Help : " " , } ) , group Last Eval Time : prometheus . New Gauge Vec ( prometheus . Gauge Opts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , group Last Duration : prometheus . New Gauge Vec ( prometheus . Gauge Opts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , group Rules : prometheus . New Gauge Vec ( prometheus . Gauge Opts { Namespace : namespace , Name : " " , Help : " " , } , [ ] string { " " } , ) , } if reg ! = nil { reg . Must Register ( m . eval Duration , m . eval Failures , m . eval Total , m . iteration Duration , m . iterations Missed , m . iterations Scheduled , m . group Last Eval Time , m . group Last Duration , m . group Rules , ) } return m } 
func Engine Query Func ( engine * promql . Engine , q storage . Queryable ) Query Func { return func ( ctx context . Context , qs string , t time . Time ) ( promql . Vector , error ) { q , err : = engine . New Instant Query ( q , qs , t ) if err ! = nil { return nil , err } res : = q . Exec ( ctx ) if res . Err ! = nil { return nil , res . Err } switch v : = res . Value . ( type ) { case promql . Vector : return v , nil case promql . Scalar : return promql . Vector { promql . Sample { Point : promql . Point ( v ) , Metric : labels . Labels { } , } } , nil default : return nil , errors . New ( " " ) } } } 
func New Group ( name , file string , interval time . Duration , rules [ ] Rule , should Restore bool , opts * Manager Options ) * Group { metrics : = opts . Metrics if metrics = = nil { metrics = New Group Metrics ( opts . Registerer ) } metrics . group Last Eval Time . With Label Values ( group Key ( file , name ) ) metrics . group Last Duration . With Label Values ( group Key ( file , name ) ) metrics . group Rules . With Label Values ( group Key ( file , name ) ) . Set ( float 6 4 ( len ( rules ) ) ) return & Group { name : name , file : file , interval : interval , rules : rules , should Restore : should Restore , opts : opts , series In Previous Eval : make ( [ ] map [ string ] labels . Labels , len ( rules ) ) , done : make ( chan struct { } ) , terminated : make ( chan struct { } ) , logger : log . With ( opts . Logger , " " , name ) , metrics : metrics , } } 
func ( g * Group ) Get Evaluation Duration ( ) time . Duration { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluation Duration } 
func ( g * Group ) set Evaluation Duration ( dur time . Duration ) { g . metrics . group Last Duration . With Label Values ( group Key ( g . file , g . name ) ) . Set ( dur . Seconds ( ) ) g . mtx . Lock ( ) defer g . mtx . Unlock ( ) g . evaluation Duration = dur } 
func ( g * Group ) Get Evaluation Timestamp ( ) time . Time { g . mtx . Lock ( ) defer g . mtx . Unlock ( ) return g . evaluation Timestamp } 
func ( g * Group ) set Evaluation Timestamp ( ts time . Time ) { g . metrics . group Last Eval Time . With Label Values ( group Key ( g . file , g . name ) ) . Set ( float 6 4 ( ts . Unix Nano ( ) ) / 1e 9 ) g . mtx . Lock ( ) defer g . mtx . Unlock ( ) g . evaluation Timestamp = ts } 
func ( g * Group ) eval Timestamp ( ) time . Time { var ( offset = int 6 4 ( g . hash ( ) % uint 6 4 ( g . interval ) ) now = time . Now ( ) . Unix Nano ( ) adj Now = now - offset base = adj Now - ( adj Now % int 6 4 ( g . interval ) ) ) return time . Unix ( 0 , base + offset ) } 
func ( g * Group ) Copy State ( from * Group ) { g . evaluation Duration = from . evaluation Duration rule Map : = make ( map [ string ] [ ] int , len ( from . rules ) ) for fi , from Rule : = range from . rules { name And Labels : = name And Labels ( from Rule ) l : = rule Map [ name And Labels ] rule Map [ name And Labels ] = append ( l , fi ) } for i , rule : = range g . rules { name And Labels : = name And Labels ( rule ) indexes : = rule Map [ name And Labels ] if len ( indexes ) = = 0 { continue } fi : = indexes [ 0 ] g . series In Previous Eval [ i ] = from . series In Previous Eval [ fi ] rule Map [ name And Labels ] = indexes [ 1 : ] ar , ok : = rule . ( * Alerting Rule ) if ! ok { continue } far , ok : = from . rules [ fi ] . ( * Alerting Rule ) if ! ok { continue } for fp , a : = range far . active { ar . active [ fp ] = a } } } 
func ( g * Group ) Eval ( ctx context . Context , ts time . Time ) { for i , rule : = range g . rules { select { case < - g . done : return default : } func ( i int , rule Rule ) { sp , ctx : = opentracing . Start Span From Context ( ctx , " " ) sp . Set Tag ( " " , rule . Name ( ) ) defer func ( t time . Time ) { sp . Finish ( ) since : = time . Since ( t ) g . metrics . eval Duration . Observe ( since . Seconds ( ) ) rule . Set Evaluation Duration ( since ) rule . Set Evaluation Timestamp ( t ) } ( time . Now ( ) ) g . metrics . eval Total . Inc ( ) vector , err : = rule . Eval ( ctx , ts , g . opts . Query Func , g . opts . External URL ) if err ! = nil { } g . metrics . eval Failures . Inc ( ) return } if ar , ok : = rule . ( * Alerting Rule ) ; ok { ar . send Alerts ( ctx , ts , g . opts . Resend Delay , g . interval , g . opts . Notify Func ) } var ( num Out Of Order = 0 num Duplicates = 0 ) app , err : = g . opts . Appendable . Appender ( ) if err ! = nil { level . Warn ( g . logger ) . Log ( " " , " " , " " , err ) return } series Returned : = make ( map [ string ] labels . Labels , len ( g . series In Previous Eval [ i ] ) ) for _ , s : = range vector { if _ , err : = app . Add ( s . Metric , s . T , s . V ) ; err ! = nil { switch err { case storage . Err Out Of Order Sample : num Out Of Order + + level . Debug ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) case storage . Err Duplicate Sample For Timestamp : num Duplicates + + level . Debug ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) default : level . Warn ( g . logger ) . Log ( " " , " " , " " , err , " " , s ) } } else { series Returned [ s . Metric . String ( ) ] = s . Metric } } if num Out Of Order > 0 { level . Warn ( g . logger ) . Log ( " " , " " , " " , num Out Of Order ) } if num Duplicates > 0 { level . Warn ( g . logger ) . Log ( " " , " " , " " , num Duplicates ) } for metric , lset : = range g . series In Previous Eval [ i ] { if _ , ok : = series Returned [ metric ] ; ! ok { switch err { case nil : case storage . Err Out Of Order Sample , storage . Err Duplicate Sample For Timestamp : } } } if err : = app . Commit ( ) ; err ! = nil { level . Warn ( g . logger ) . Log ( " " , " " , " " , err ) } else { g . series In Previous Eval [ i ] = series Returned } } ( i , rule ) } } 
func ( g * Group ) Restore For State ( ts time . Time ) { maxt MS : = int 6 4 ( model . Time From Unix Nano ( ts . Unix Nano ( ) ) ) mint MS : = int 6 4 ( model . Time From Unix Nano ( mint . Unix Nano ( ) ) ) q , err : = g . opts . TSDB . Querier ( g . opts . Context , mint MS , maxt MS ) if err ! = nil { level . Error ( g . logger ) . Log ( " " , " " , " " , err ) return } defer func ( ) { if err : = q . Close ( ) ; err ! = nil { level . Error ( g . logger ) . Log ( " " , " " , " " , err ) } } ( ) for _ , rule : = range g . Rules ( ) { alert Rule , ok : = rule . ( * Alerting Rule ) if ! ok { continue } alert Hold Duration : = alert Rule . Hold Duration ( ) if alert Hold Duration < g . opts . For Grace Period { continue } alert Rule . For Each Active Alert ( func ( a * Alert ) { smpl : = alert Rule . for State Sample ( a , time . Now ( ) , 0 ) var matchers [ ] * labels . Matcher for _ , l : = range smpl . Metric { mt , err : = labels . New Matcher ( labels . Match Equal , l . Name , l . Value ) if err ! = nil { panic ( err ) } matchers = append ( matchers , mt ) } sset , err , _ : = q . Select ( nil , matchers . . . ) if err ! = nil { level . Error ( g . logger ) . Log ( " " , " " , labels . Alert Name , alert Rule . Name ( ) , " " , " " , " " , err ) return } series Found : = false var s storage . Series for sset . Next ( ) { series Found = true break } } if ! series Found { return } var v float 6 4 it : = s . Iterator ( ) for it . Next ( ) { t , v = it . At ( ) } if it . Err ( ) ! = nil { level . Error ( g . logger ) . Log ( " " , " " , labels . Alert Name , alert Rule . Name ( ) , " " , " " , " " , it . Err ( ) ) return } if value . Is Stale Na N ( v ) { } down At : = time . Unix ( t / 1 0 0 0 , 0 ) restored Active At : = time . Unix ( int 6 4 ( v ) , 0 ) time Spent Pending : = down At . Sub ( restored Active At ) time Remaining Pending : = alert Hold Duration - time Spent Pending if time Remaining Pending < = 0 { } else { restored Active At = restored Active At . Add ( down Duration ) } a . Active At = restored Active At level . Debug ( g . logger ) . Log ( " " , " " , labels . Alert Name , alert Rule . Name ( ) , " " , a . Active At . Format ( time . RFC 8 5 0 ) , " " , a . Labels . String ( ) ) } ) alert Rule . Set Restored ( true ) } } 
func New Manager ( o * Manager Options ) * Manager { if o . Metrics = = nil { o . Metrics = New Group Metrics ( o . Registerer ) } m : = & Manager { groups : map [ string ] * Group { } , opts : o , block : make ( chan struct { } ) , logger : o . Logger , } if o . Registerer ! = nil { o . Registerer . Must Register ( m ) } o . Metrics . iterations Missed . Inc ( ) return m } 
func ( m * Manager ) Stop ( ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) level . Info ( m . logger ) . Log ( " " , " " ) for _ , eg : = range m . groups { eg . stop ( ) } level . Info ( m . logger ) . Log ( " " , " " ) } 
func ( m * Manager ) Update ( interval time . Duration , files [ ] string , external Labels labels . Labels ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) groups , errs : = m . Load Groups ( interval , external Labels , files . . . ) if errs ! = nil { for _ , e : = range errs { level . Error ( m . logger ) . Log ( " " , " " , " " , e ) } return errors . New ( " " ) } m . restored = true var wg sync . Wait Group for _ , newg : = range groups { wg . Add ( 1 ) oldg , ok : = m . groups [ gn ] delete ( m . groups , gn ) go func ( newg * Group ) { if ok { oldg . stop ( ) newg . Copy State ( oldg ) } go func ( ) { newg . run ( m . opts . Context ) } ( ) wg . Done ( ) } ( newg ) } } wg . Wait ( ) m . groups = groups return nil } 
func ( m * Manager ) Load Groups ( interval time . Duration , external Labels labels . Labels , filenames . . . string , ) ( map [ string ] * Group , [ ] error ) { groups : = make ( map [ string ] * Group ) should Restore : = ! m . restored for _ , fn : = range filenames { rgs , errs : = rulefmt . Parse File ( fn ) if errs ! = nil { return nil , errs } for _ , rg : = range rgs . Groups { itv : = interval if rg . Interval ! = 0 { itv = time . Duration ( rg . Interval ) } rules : = make ( [ ] Rule , 0 , len ( rg . Rules ) ) for _ , r : = range rg . Rules { expr , err : = promql . Parse Expr ( r . Expr ) if err ! = nil { return nil , [ ] error { err } } if r . Alert ! = " " { rules = append ( rules , New Alerting Rule ( r . Alert , expr , time . Duration ( r . For ) , labels . From Map ( r . Labels ) , labels . From Map ( r . Annotations ) , external Labels , m . restored , log . With ( m . logger , " " , r . Alert ) , ) ) continue } rules = append ( rules , New Recording Rule ( r . Record , expr , labels . From Map ( r . Labels ) , ) ) } groups [ group Key ( rg . Name , fn ) ] = New Group ( rg . Name , fn , itv , rules , should Restore , m . opts ) } } return groups , nil } 
func ( m * Manager ) Rule Groups ( ) [ ] * Group { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) rgs : = make ( [ ] * Group , 0 , len ( m . groups ) ) for _ , g : = range m . groups { rgs = append ( rgs , g ) } } return rgs [ i ] . name < rgs [ j ] . name } ) return rgs } 
func ( m * Manager ) Rules ( ) [ ] Rule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) var rules [ ] Rule for _ , g : = range m . groups { rules = append ( rules , g . rules . . . ) } return rules } 
func ( m * Manager ) Alerting Rules ( ) [ ] * Alerting Rule { m . mtx . RLock ( ) defer m . mtx . RUnlock ( ) alerts : = [ ] * Alerting Rule { } for _ , rule : = range m . Rules ( ) { if alerting Rule , ok : = rule . ( * Alerting Rule ) ; ok { alerts = append ( alerts , alerting Rule ) } } return alerts } 
func ( m * Manager ) Collect ( ch chan < - prometheus . Metric ) { for _ , g : = range m . Rule Groups ( ) { ch < - prometheus . Must New Const Metric ( group Interval , prometheus . Gauge Value , g . interval . Seconds ( ) , group Key ( g . file , g . name ) ) } } 
func New WALWatcher ( logger log . Logger , name string , writer write To , wal Dir string ) * WALWatcher { if logger = = nil { logger = log . New Nop Logger ( ) } return & WALWatcher { logger : logger , writer : writer , wal Dir : path . Join ( wal Dir , " " ) , name : name , quit : make ( chan struct { } ) , done : make ( chan struct { } ) , max Segment : - 1 , } } 
func ( w * WALWatcher ) Start ( ) { w . set Metrics ( ) level . Info ( w . logger ) . Log ( " " , " " , " " , w . name ) go w . loop ( ) } 
func ( w * WALWatcher ) Stop ( ) { close ( w . quit ) < - w . done watcher Records Read . Delete Label Values ( w . name , " " ) watcher Record Decode Fails . Delete Label Values ( w . name ) watcher Samples Sent Pre Tailing . Delete Label Values ( w . name ) watcher Current Segment . Delete Label Values ( w . name ) level . Info ( w . logger ) . Log ( " " , " " , " " , w . name ) } 
func ( w * WALWatcher ) find Segment For Index ( index int ) ( int , error ) { refs , err : = w . segments ( w . wal Dir ) if err ! = nil { return - 1 , nil } for _ , r : = range refs { if r > = index { return r , nil } } return - 1 , errors . New ( " " ) } 
func ( w * WALWatcher ) segments ( dir string ) ( [ ] int , error ) { files , err : = fileutil . Read Dir ( dir ) if err ! = nil { return nil , err } var refs [ ] int var last int for _ , fn : = range files { k , err : = strconv . Atoi ( fn ) if err ! = nil { continue } if len ( refs ) > 0 & & k > last + 1 { return nil , errors . New ( " " ) } refs = append ( refs , k ) last = k } sort . Ints ( refs ) return refs , nil } 
func ( w * WALWatcher ) watch ( segment Num int , tail bool ) error { segment , err : = wal . Open Read Segment ( wal . Segment Name ( w . wal Dir , segment Num ) ) if err ! = nil { return err } defer segment . Close ( ) reader : = wal . New Live Reader ( w . logger , segment ) read Ticker : = time . New Ticker ( read Period ) defer read Ticker . Stop ( ) checkpoint Ticker : = time . New Ticker ( checkpoint Period ) defer checkpoint Ticker . Stop ( ) segment Ticker : = time . New Ticker ( segment Check Period ) defer segment Ticker . Stop ( ) if ! tail { segment Ticker . Stop ( ) checkpoint Ticker . Stop ( ) var err error size , err = get Segment Size ( w . wal Dir , segment Num ) if err ! = nil { return errors . Wrap ( err , " " ) } } for { select { case < - w . quit : return nil case < - checkpoint Ticker . C : } case < - segment Ticker . C : _ , last , err : = w . first And Last ( ) if err ! = nil { return errors . Wrap ( err , " " ) } } err = w . read Segment ( reader , segment Num , tail ) } else if reader . Offset ( ) ! = size { level . Warn ( w . logger ) . Log ( " " , " " , " " , segment Num , " " , reader . Offset ( ) , " " , size ) } return nil } } return nil case < - read Ticker . C : err = w . read Segment ( reader , segment Num , tail ) } else if reader . Offset ( ) ! = size { level . Warn ( w . logger ) . Log ( " " , " " , " " , segment Num , " " , reader . Offset ( ) , " " , size ) } return nil } } } } } 
func ( w * WALWatcher ) read Checkpoint ( checkpoint Dir string ) error { level . Debug ( w . logger ) . Log ( " " , " " , " " , checkpoint Dir ) index , err : = checkpoint Num ( checkpoint Dir ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } for _ , seg : = range segs { size , err : = get Segment Size ( checkpoint Dir , seg ) if err ! = nil { return errors . Wrap ( err , " " ) } sr , err : = wal . Open Read Segment ( wal . Segment Name ( checkpoint Dir , seg ) ) if err ! = nil { return errors . Wrap ( err , " " ) } defer sr . Close ( ) r : = wal . New Live Reader ( w . logger , sr ) if err : = w . read Segment ( r , index , false ) ; err ! = io . EOF & & err ! = nil { return errors . Wrap ( err , " " ) } if r . Offset ( ) ! = size { return fmt . Errorf ( " " , checkpoint Dir , seg , size , r . Offset ( ) ) } } level . Debug ( w . logger ) . Log ( " " , " " , " " , checkpoint Dir ) return nil } 
func get Segment Size ( dir string , index int ) ( int 6 4 , error ) { i : = int 6 4 ( - 1 ) fi , err : = os . Stat ( wal . Segment Name ( dir , index ) ) if err = = nil { i = fi . Size ( ) } return i , err } 
func ( zl Zookeeper Logger ) Printf ( s string , i . . . interface { } ) { level . Info ( zl . logger ) . Log ( " " , fmt . Sprintf ( s , i . . . ) ) } 
func New Zookeeper Tree Cache ( conn * zk . Conn , path string , events chan Zookeeper Tree Cache Event , logger log . Logger ) * Zookeeper Tree Cache { tc : = & Zookeeper Tree Cache { conn : conn , prefix : path , events : events , stop : make ( chan struct { } ) , logger : logger , } tc . head = & zookeeper Tree Cache Node { events : make ( chan zk . Event ) , children : map [ string ] * zookeeper Tree Cache Node { } , stopped : true , } go tc . loop ( path ) return tc } 
func New Manager ( ctx context . Context , logger log . Logger , options . . . func ( * Manager ) ) * Manager { if logger = = nil { logger = log . New Nop Logger ( ) } mgr : = & Manager { logger : logger , sync Ch : make ( chan map [ string ] [ ] * targetgroup . Group ) , targets : make ( map [ pool Key ] map [ string ] * targetgroup . Group ) , discover Cancel : [ ] context . Cancel Func { } , ctx : ctx , updatert : 5 * time . Second , trigger Send : make ( chan struct { } , 1 ) , } for _ , option : = range options { option ( mgr ) } return mgr } 
func Name ( n string ) func ( * Manager ) { return func ( m * Manager ) { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) m . name = n } } 
func ( m * Manager ) Run ( ) error { go m . sender ( ) for range m . ctx . Done ( ) { m . cancel Discoverers ( ) return m . ctx . Err ( ) } return nil } 
func ( m * Manager ) Apply Config ( cfg map [ string ] sd _config . Service Discovery Config ) error { m . mtx . Lock ( ) defer m . mtx . Unlock ( ) for pk : = range m . targets { if _ , ok : = cfg [ pk . set Name ] ; ! ok { discovered Targets . Delete Label Values ( m . name , pk . set Name ) } } m . cancel Discoverers ( ) for name , scfg : = range cfg { m . register Providers ( scfg , name ) discovered Targets . With Label Values ( m . name , name ) . Set ( 0 ) } for _ , prov : = range m . providers { m . start Provider ( m . ctx , prov ) } return nil } 
func ( m * Manager ) Start Custom Provider ( ctx context . Context , name string , worker Discoverer ) { p : = & provider { name : name , d : worker , subs : [ ] string { name } , } m . providers = append ( m . providers , p ) m . start Provider ( ctx , p ) } 
func ( sd * Static Provider ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { close ( ch ) } 
func New Discovery ( l log . Logger , mech string , interval time . Duration , refreshf func ( ctx context . Context ) ( [ ] * targetgroup . Group , error ) ) * Discovery { if l = = nil { l = log . New Nop Logger ( ) } return & Discovery { logger : l , interval : interval , refreshf : refreshf , failures : failures Count . With Label Values ( mech ) , duration : duration . With Label Values ( mech ) , } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err . Error ( ) ) } else { select { case ch < - tgs : case < - ctx . Done ( ) : return } } ticker : = time . New Ticker ( d . interval ) defer ticker . Stop ( ) for { select { case < - ticker . C : tgs , err : = d . refresh ( ctx ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err . Error ( ) ) continue } select { case ch < - tgs : case < - ctx . Done ( ) : return } case < - ctx . Done ( ) : return } } } 
func ( c * Serverset SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Serverset SDConfig type plain Serverset SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if len ( c . Servers ) = = 0 { return errors . New ( " " ) } if len ( c . Paths ) = = 0 { return errors . New ( " " ) } for _ , path : = range c . Paths { if ! strings . Has Prefix ( path , " " ) { return errors . Errorf ( " " , path ) } } return nil } 
func New Nerve Discovery ( conf * Nerve SDConfig , logger log . Logger ) ( * Discovery , error ) { return New Discovery ( conf . Servers , time . Duration ( conf . Timeout ) , conf . Paths , logger , parse Nerve Member ) } 
func New Serverset Discovery ( conf * Serverset SDConfig , logger log . Logger ) ( * Discovery , error ) { return New Discovery ( conf . Servers , time . Duration ( conf . Timeout ) , conf . Paths , logger , parse Serverset Member ) } 
func New Discovery ( srvs [ ] string , timeout time . Duration , paths [ ] string , logger log . Logger , pf func ( data [ ] byte , path string ) ( model . Label Set , error ) , ) ( * Discovery , error ) { if logger = = nil { logger = log . New Nop Logger ( ) } conn , _ , err : = zk . Connect ( srvs , timeout , func ( c * zk . Conn ) { c . Set Logger ( treecache . New Zookeeper Logger ( logger ) ) } ) if err ! = nil { return nil , err } updates : = make ( chan treecache . Zookeeper Tree Cache Event ) sd : = & Discovery { conn : conn , updates : updates , sources : map [ string ] * targetgroup . Group { } , parse : pf , logger : logger , } for _ , path : = range paths { sd . tree Caches = append ( sd . tree Caches , treecache . New Zookeeper Tree Cache ( conn , path , updates , logger ) ) } return sd , nil } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer func ( ) { for _ , tc : = range d . tree Caches { tc . Stop ( ) } d . conn . Close ( ) } ( ) for { select { case < - ctx . Done ( ) : return case event : = < - d . updates : tg : = & targetgroup . Group { Source : event . Path , } if event . Data ! = nil { label Set , err : = d . parse ( * event . Data , event . Path ) if err = = nil { tg . Targets = [ ] model . Label Set { label Set } d . sources [ event . Path ] = tg } else { delete ( d . sources , event . Path ) } } else { delete ( d . sources , event . Path ) } select { case < - ctx . Done ( ) : return case ch < - [ ] * targetgroup . Group { tg } : } } } } 
func Walk ( v Visitor , node Node , path [ ] Node ) error { var err error if v , err = v . Visit ( node , path ) ; v = = nil | | err ! = nil { return err } path = append ( path , node ) switch n : = node . ( type ) { case * Eval Stmt : if err : = Walk ( v , n . Expr , path ) ; err ! = nil { return err } case Expressions : for _ , e : = range n { if err : = Walk ( v , e , path ) ; err ! = nil { return err } } case * Aggregate Expr : if n . Param ! = nil { if err : = Walk ( v , n . Param , path ) ; err ! = nil { return err } } if err : = Walk ( v , n . Expr , path ) ; err ! = nil { return err } case * Binary Expr : if err : = Walk ( v , n . LHS , path ) ; err ! = nil { return err } if err : = Walk ( v , n . RHS , path ) ; err ! = nil { return err } case * Call : if err : = Walk ( v , n . Args , path ) ; err ! = nil { return err } case * Subquery Expr : if err : = Walk ( v , n . Expr , path ) ; err ! = nil { return err } case * Paren Expr : if err : = Walk ( v , n . Expr , path ) ; err ! = nil { return err } case * Unary Expr : if err : = Walk ( v , n . Expr , path ) ; err ! = nil { return err } case * Matrix Selector , * Number Literal , * String Literal , * Vector Selector : } _ , err = v . Visit ( nil , nil ) return err } 
func Inspect ( node Node , f inspector ) { Walk ( inspector ( f ) , node , nil ) } 
func ( l * open Metrics Lexer ) Lex ( ) token { if l . i > = len ( l . b ) { return t EOF } c : = l . b [ l . i ] l . start = l . i yystate 0 : switch yyt : = l . state ; yyt { default : panic ( errors . Errorf ( `invalid start condition %d ` , yyt ) ) case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : } goto yystate 0 goto yystate 1 yystate 1 : c = l . next ( ) yystart 1 : switch { default : goto yyabort case c = = ' # ' : goto yystate 2 case c = = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 4 } yystate 2 : c = l . next ( ) switch { default : goto yyabort case c = = ' ' : goto yystate 3 } yystate 3 : c = l . next ( ) goto yyrule 1 yystate 4 : c = l . next ( ) switch { default : goto yyrule 8 case c > = ' 0 ' & & c < = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 4 } goto yystate 5 yystate 5 : c = l . next ( ) yystart 5 : switch { default : goto yyabort case c = = 'E ' : goto yystate 6 case c = = 'H ' : goto yystate 1 0 case c = = 'T ' : goto yystate 1 5 case c = = 'U ' : goto yystate 2 0 } yystate 6 : c = l . next ( ) switch { default : goto yyabort case c = = 'O ' : goto yystate 7 } yystate 7 : c = l . next ( ) switch { default : goto yyabort case c = = 'F ' : goto yystate 8 } yystate 8 : c = l . next ( ) switch { default : goto yyrule 5 case c = = ' \n ' : goto yystate 9 } yystate 9 : c = l . next ( ) goto yyrule 5 yystate 1 0 : c = l . next ( ) switch { default : goto yyabort case c = = 'E ' : goto yystate 1 1 } yystate 1 1 : c = l . next ( ) switch { default : goto yyabort case c = = 'L ' : goto yystate 1 2 } yystate 1 2 : c = l . next ( ) switch { default : goto yyabort case c = = 'P ' : goto yystate 1 3 } yystate 1 3 : c = l . next ( ) switch { default : goto yyabort case c = = ' ' : goto yystate 1 4 } yystate 1 4 : c = l . next ( ) goto yyrule 2 yystate 1 5 : c = l . next ( ) switch { default : goto yyabort case c = = 'Y ' : goto yystate 1 6 } yystate 1 6 : c = l . next ( ) switch { default : goto yyabort case c = = 'P ' : goto yystate 1 7 } yystate 1 7 : c = l . next ( ) switch { default : goto yyabort case c = = 'E ' : goto yystate 1 8 } yystate 1 8 : c = l . next ( ) switch { default : goto yyabort case c = = ' ' : goto yystate 1 9 } yystate 1 9 : c = l . next ( ) goto yyrule 3 yystate 2 0 : c = l . next ( ) switch { default : goto yyabort case c = = 'N ' : goto yystate 2 1 } yystate 2 1 : c = l . next ( ) switch { default : goto yyabort case c = = 'I ' : goto yystate 2 2 } yystate 2 2 : c = l . next ( ) switch { default : goto yyabort case c = = 'T ' : goto yystate 2 3 } yystate 2 3 : c = l . next ( ) switch { default : goto yyabort case c = = ' ' : goto yystate 2 4 } yystate 2 4 : c = l . next ( ) goto yyrule 4 goto yystate 2 5 yystate 2 5 : c = l . next ( ) yystart 2 5 : switch { default : goto yyabort case c = = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 6 } yystate 2 6 : c = l . next ( ) switch { default : goto yyrule 6 case c > = ' 0 ' & & c < = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 6 } goto yystate 2 7 yystate 2 7 : c = l . next ( ) yystart 2 7 : switch { default : goto yyabort case c = = ' ' : goto yystate 2 8 } yystate 2 8 : c = l . next ( ) switch { default : goto yyabort case c = = ' \n ' : goto yystate 2 9 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ÿ ' : goto yystate 2 8 } yystate 2 9 : c = l . next ( ) goto yyrule 7 goto yystate 3 0 yystate 3 0 : c = l . next ( ) yystart 3 0 : switch { default : goto yyabort case c = = ' , ' : goto yystate 3 1 case c = = ' = ' : goto yystate 3 2 case c = = ' } ' : goto yystate 3 4 case c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 3 3 } yystate 3 1 : c = l . next ( ) goto yyrule 1 3 yystate 3 2 : c = l . next ( ) goto yyrule 1 2 yystate 3 3 : c = l . next ( ) switch { default : goto yyrule 1 0 case c > = ' 0 ' & & c < = ' 9 ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 3 3 } yystate 3 4 : c = l . next ( ) goto yyrule 1 1 goto yystate 3 5 yystate 3 5 : c = l . next ( ) yystart 3 5 : switch { default : goto yyabort case c = = ' " ' : goto yystate 3 6 } yystate 3 6 : c = l . next ( ) switch { default : goto yyabort case c = = ' " ' : goto yystate 3 7 case c = = ' \ \ ' : goto yystate 3 8 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ! ' | | c > = ' # ' & & c < = ' [ ' | | c > = ' ] ' & & c < = ' ÿ ' : goto yystate 3 6 } yystate 3 7 : c = l . next ( ) goto yyrule 1 4 yystate 3 8 : c = l . next ( ) switch { default : goto yyabort case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ÿ ' : goto yystate 3 6 } goto yystate 3 9 yystate 3 9 : c = l . next ( ) yystart 3 9 : switch { default : goto yyabort case c = = ' ' : goto yystate 4 0 case c = = ' { ' : goto yystate 4 2 } yystate 4 0 : c = l . next ( ) switch { default : goto yyabort case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 4 1 } yystate 4 1 : c = l . next ( ) switch { default : goto yyrule 1 5 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 4 1 } yystate 4 2 : c = l . next ( ) goto yyrule 9 goto yystate 4 3 yystate 4 3 : c = l . next ( ) yystart 4 3 : switch { default : goto yyabort case c = = ' ' : goto yystate 4 5 case c = = ' \n ' : goto yystate 4 4 } yystate 4 4 : c = l . next ( ) goto yyrule 1 8 yystate 4 5 : c = l . next ( ) switch { default : goto yyabort case c = = ' # ' : goto yystate 4 7 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c = = ' ! ' | | c = = ' " ' | | c > = ' $ ' & & c < = ' ÿ ' : goto yystate 4 6 } yystate 4 6 : c = l . next ( ) switch { default : goto yyrule 1 6 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 4 6 } yystate 4 7 : c = l . next ( ) switch { default : goto yyrule 1 6 case c = = ' ' : goto yystate 4 8 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 4 6 } yystate 4 8 : c = l . next ( ) switch { default : goto yyabort case c = = ' \n ' : goto yystate 4 9 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ÿ ' : goto yystate 4 8 } yystate 4 9 : c = l . next ( ) goto yyrule 1 7 yyrule 1 : goto yystate 0 } yyrule 2 : return t Help goto yystate 0 } yyrule 3 : return t Type goto yystate 0 } yyrule 4 : return t Unit goto yystate 0 } yyrule 5 : return t Eof Word goto yystate 0 } yyrule 6 : return t MName goto yystate 0 } yyrule 7 : return t Text goto yystate 0 } yyrule 8 : return t MName goto yystate 0 } yyrule 9 : return t Brace Open goto yystate 0 } yyrule 1 0 : } yyrule 1 1 : return t Brace Close goto yystate 0 } yyrule 1 2 : return t Equal goto yystate 0 } yyrule 1 3 : } yyrule 1 4 : return t LValue goto yystate 0 } yyrule 1 5 : return t Value goto yystate 0 } yyrule 1 6 : } yyrule 1 7 : return t Linebreak goto yystate 0 } yyrule 1 8 : return t Linebreak goto yystate 0 } panic ( " " ) goto yyabort yyabort : } 
func Fuzz Parse Metric ( in [ ] byte ) int { p : = textparse . New ( in ) for p . Next ( ) { } if p . Err ( ) = = nil { return fuzz Interesting } return fuzz Meh } 
func Fuzz Parse Metric Selector ( in [ ] byte ) int { _ , err : = Parse Metric Selector ( string ( in ) ) if err = = nil { return fuzz Interesting } return fuzz Meh } 
func Fuzz Parse Expr ( in [ ] byte ) int { _ , err : = Parse Expr ( string ( in ) ) if err = = nil { return fuzz Interesting } return fuzz Meh } 
func Fuzz Parse Stmts ( in [ ] byte ) int { _ , err : = Parse Stmts ( string ( in ) ) if err = = nil { return fuzz Interesting } return fuzz Meh } 
func ( s * Service ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer s . queue . Shut Down ( ) if ! cache . Wait For Cache Sync ( ctx . Done ( ) , s . informer . Has Synced ) { level . Error ( s . logger ) . Log ( " " , " " ) return } go func ( ) { for s . process ( ctx , ch ) { } } ( ) } 
func New Manager ( logger log . Logger , app Appendable ) * Manager { if logger = = nil { logger = log . New Nop Logger ( ) } return & Manager { append : app , logger : logger , scrape Configs : make ( map [ string ] * config . Scrape Config ) , scrape Pools : make ( map [ string ] * scrape Pool ) , grace Shut : make ( chan struct { } ) , trigger Reload : make ( chan struct { } , 1 ) , } } 
func ( m * Manager ) Run ( tsets < - chan map [ string ] [ ] * targetgroup . Group ) error { go m . reloader ( ) for { select { case ts : = < - tsets : m . update Tsets ( ts ) select { case m . trigger Reload < - struct { } { } : default : } case < - m . grace Shut : return nil } } } 
func ( m * Manager ) set Jitter Seed ( labels labels . Labels ) error { h : = fnv . New 6 4a ( ) hostname , err : = get Fqdn ( ) if err ! = nil { return err } if _ , err : = fmt . Fprintf ( h , " " , hostname , labels . String ( ) ) ; err ! = nil { return err } m . jitter Seed = h . Sum 6 4 ( ) return nil } 
func ( m * Manager ) Stop ( ) { m . mtx Scrape . Lock ( ) defer m . mtx Scrape . Unlock ( ) for _ , sp : = range m . scrape Pools { sp . stop ( ) } close ( m . grace Shut ) } 
func ( m * Manager ) Apply Config ( cfg * config . Config ) error { m . mtx Scrape . Lock ( ) defer m . mtx Scrape . Unlock ( ) c : = make ( map [ string ] * config . Scrape Config ) for _ , scfg : = range cfg . Scrape Configs { c [ scfg . Job Name ] = scfg } m . scrape Configs = c if err : = m . set Jitter Seed ( cfg . Global Config . External Labels ) ; err ! = nil { return err } for name , sp : = range m . scrape Pools { if cfg , ok : = m . scrape Configs [ name ] ; ! ok { sp . stop ( ) delete ( m . scrape Pools , name ) } else if ! reflect . Deep Equal ( sp . config , cfg ) { err : = sp . reload ( cfg ) if err ! = nil { level . Error ( m . logger ) . Log ( " " , " " , " " , err , " " , name ) failed = true } } } if failed { return errors . New ( " " ) } return nil } 
func ( m * Manager ) Targets All ( ) map [ string ] [ ] * Target { m . mtx Scrape . Lock ( ) defer m . mtx Scrape . Unlock ( ) targets : = make ( map [ string ] [ ] * Target , len ( m . scrape Pools ) ) for tset , sp : = range m . scrape Pools { targets [ tset ] = append ( sp . Active Targets ( ) , sp . Dropped Targets ( ) . . . ) } return targets } 
func ( m * Manager ) Targets Active ( ) map [ string ] [ ] * Target { m . mtx Scrape . Lock ( ) defer m . mtx Scrape . Unlock ( ) targets : = make ( map [ string ] [ ] * Target , len ( m . scrape Pools ) ) for tset , sp : = range m . scrape Pools { targets [ tset ] = sp . Active Targets ( ) } return targets } 
func ( m * Manager ) Targets Dropped ( ) map [ string ] [ ] * Target { m . mtx Scrape . Lock ( ) defer m . mtx Scrape . Unlock ( ) targets : = make ( map [ string ] [ ] * Target , len ( m . scrape Pools ) ) for tset , sp : = range m . scrape Pools { targets [ tset ] = sp . Dropped Targets ( ) } return targets } 
func get Fqdn ( ) ( string , error ) { hostname , err : = os . Hostname ( ) if err ! = nil { return " " , err } ips , err : = net . Lookup IP ( hostname ) if err ! = nil { } lookup : = func ( ip Str encoding . Text Marshaler ) ( string , error ) { ip , err : = ip Str . Marshal Text ( ) if err ! = nil { return " " , err } hosts , err : = net . Lookup Addr ( string ( ip ) ) if err ! = nil | | len ( hosts ) = = 0 { return " " , err } return hosts [ 0 ] , nil } for _ , addr : = range ips { if ip : = addr . To 4 ( ) ; ip ! = nil { if fqdn , err : = lookup ( ip ) ; err = = nil { return fqdn , nil } } if ip : = addr . To 1 6 ( ) ; ip ! = nil { if fqdn , err : = lookup ( ip ) ; err = = nil { return fqdn , nil } } } return hostname , nil } 
func New Client ( logger log . Logger , url string , timeout time . Duration ) * Client { return & Client { logger : logger , url : url , timeout : timeout , } } 
func tags From Metric ( m model . Metric ) map [ string ] Tag Value { tags : = make ( map [ string ] Tag Value , len ( m ) - 1 ) for l , v : = range m { if l = = model . Metric Name Label { continue } tags [ string ( l ) ] = Tag Value ( v ) } return tags } 
func ( c * Client ) Write ( samples model . Samples ) error { reqs : = make ( [ ] Store Samples Request , 0 , len ( samples ) ) for _ , s : = range samples { v : = float 6 4 ( s . Value ) if math . Is Na N ( v ) | | math . Is Inf ( v , 0 ) { level . Debug ( c . logger ) . Log ( " " , " " , " " , v , " " , s ) continue } metric : = Tag Value ( s . Metric [ model . Metric Name Label ] ) reqs = append ( reqs , Store Samples Request { Metric : metric , Timestamp : s . Timestamp . Unix ( ) , Value : v , Tags : tags From Metric ( s . Metric ) , } ) } u , err : = url . Parse ( c . url ) if err ! = nil { return err } u . Path = put Endpoint buf , err : = json . Marshal ( reqs ) if err ! = nil { return err } ctx , cancel : = context . With Timeout ( context . Background ( ) , c . timeout ) defer cancel ( ) req , err : = http . New Request ( " " , u . String ( ) , bytes . New Buffer ( buf ) ) if err ! = nil { return err } req . Header . Set ( " " , content Type JSON ) resp , err : = http . Default Client . Do ( req . With Context ( ctx ) ) if err ! = nil { return err } defer func ( ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } ( ) } if err ! = nil { return err } var r map [ string ] int if err : = json . Unmarshal ( buf , & r ) ; err ! = nil { return err } return errors . Errorf ( " " , r [ " " ] , r [ " " ] ) } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if c . Project = = " " { return errors . New ( " " ) } if c . Zone = = " " { return errors . New ( " " ) } return nil } 
func New Discovery ( conf SDConfig , logger log . Logger ) ( * Discovery , error ) { d : = & Discovery { project : conf . Project , zone : conf . Zone , filter : conf . Filter , port : conf . Port , tag Separator : conf . Tag Separator , } var err error d . client , err = google . Default Client ( context . Background ( ) , compute . Compute Readonly Scope ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } d . svc , err = compute . New Service ( context . Background ( ) , option . With HTTPClient ( d . client ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } d . isvc = compute . New Instances Service ( d . svc ) d . Discovery = refresh . New Discovery ( logger , " " , time . Duration ( conf . Refresh Interval ) , d . refresh , ) return d , nil } 
func Queryable Client ( c * Client ) storage . Queryable { remote Read Queries . With Label Values ( c . Name ( ) ) return storage . Queryable Func ( func ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { return & querier { ctx : ctx , mint : mint , maxt : maxt , client : c , } , nil } ) } 
func ( q * querier ) Select ( p * storage . Select Params , matchers . . . * labels . Matcher ) ( storage . Series Set , storage . Warnings , error ) { query , err : = To Query ( q . mint , q . maxt , matchers , p ) if err ! = nil { return nil , nil , err } remote Read Gauge : = remote Read Queries . With Label Values ( q . client . Name ( ) ) remote Read Gauge . Inc ( ) defer remote Read Gauge . Dec ( ) res , err : = q . client . Read ( q . ctx , query ) if err ! = nil { return nil , nil , err } return From Query Result ( res ) , nil , nil } 
func External Labels Handler ( next storage . Queryable , external Labels labels . Labels ) storage . Queryable { return storage . Queryable Func ( func ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { q , err : = next . Querier ( ctx , mint , maxt ) if err ! = nil { return nil , err } return & external Labels Querier { Querier : q , external Labels : external Labels } , nil } ) } 
func ( q external Labels Querier ) Select ( p * storage . Select Params , matchers . . . * labels . Matcher ) ( storage . Series Set , storage . Warnings , error ) { m , added : = q . add External Labels ( matchers ) s , warnings , err : = q . Querier . Select ( p , m . . . ) if err ! = nil { return nil , warnings , err } return new Series Set Filter ( s , added ) , warnings , nil } 
func Prefer Local Storage Filter ( next storage . Queryable , cb start Time Callback ) storage . Queryable { return storage . Queryable Func ( func ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { local Start Time , err : = cb ( ) if err ! = nil { return nil , err } cmaxt : = maxt } } return next . Querier ( ctx , mint , cmaxt ) } ) } 
func Required Matchers Filter ( next storage . Queryable , required [ ] * labels . Matcher ) storage . Queryable { return storage . Queryable Func ( func ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { q , err : = next . Querier ( ctx , mint , maxt ) if err ! = nil { return nil , err } return & required Matchers Querier { Querier : q , required Matchers : required } , nil } ) } 
func ( q required Matchers Querier ) Select ( p * storage . Select Params , matchers . . . * labels . Matcher ) ( storage . Series Set , storage . Warnings , error ) { ms : = q . required Matchers for _ , m : = range matchers { for i , r : = range ms { if m . Type = = labels . Match Equal & & m . Name = = r . Name & & m . Value = = r . Value { ms = append ( ms [ : i ] , ms [ i + 1 : ] . . . ) break } } if len ( ms ) = = 0 { break } } if len ( ms ) > 0 { return storage . Noop Series Set ( ) , nil , nil } return q . Querier . Select ( p , matchers . . . ) } 
func ( q external Labels Querier ) add External Labels ( ms [ ] * labels . Matcher ) ( [ ] * labels . Matcher , labels . Labels ) { el : = make ( labels . Labels , len ( q . external Labels ) ) copy ( el , q . external Labels ) continue } i + + } } for _ , l : = range el { m , err : = labels . New Matcher ( labels . Match Equal , l . Name , l . Value ) if err ! = nil { panic ( err ) } ms = append ( ms , m ) } return ms , el } 
func New ( b [ ] byte , content Type string ) Parser { media Type , _ , err : = mime . Parse Media Type ( content Type ) if err = = nil & & media Type = = " " { return New Open Metrics Parser ( b ) } return New Prom Parser ( b ) } 
func new Instance Discovery ( provider * gophercloud . Provider Client , opts * gophercloud . Auth Options , port int , region string , all Tenants bool , l log . Logger ) * Instance Discovery { if l = = nil { l = log . New Nop Logger ( ) } return & Instance Discovery { provider : provider , auth Opts : opts , region : region , port : port , all Tenants : all Tenants , logger : l } } 
func ( f Queryable Func ) Querier ( ctx context . Context , mint , maxt int 6 4 ) ( Querier , error ) { return f ( ctx , mint , maxt ) } 
func ( a * Alert ) Resolved At ( ts time . Time ) bool { if a . Ends At . Is Zero ( ) { return false } return ! a . Ends At . After ( ts ) } 
func New Manager ( o * Options , logger log . Logger ) * Manager { ctx , cancel : = context . With Cancel ( context . Background ( ) ) if o . Do = = nil { o . Do = do } if logger = = nil { logger = log . New Nop Logger ( ) } n : = & Manager { queue : make ( [ ] * Alert , 0 , o . Queue Capacity ) , ctx : ctx , cancel : cancel , more : make ( chan struct { } , 1 ) , opts : o , logger : logger , } queue Len Func : = func ( ) float 6 4 { return float 6 4 ( n . queue Len ( ) ) } alertmanagers Discovered Func : = func ( ) float 6 4 { return float 6 4 ( len ( n . Alertmanagers ( ) ) ) } n . metrics = new Alert Metrics ( o . Registerer , o . Queue Capacity , queue Len Func , alertmanagers Discovered Func , ) return n } 
func ( n * Manager ) Apply Config ( conf * config . Config ) error { n . mtx . Lock ( ) defer n . mtx . Unlock ( ) n . opts . External Labels = conf . Global Config . External Labels n . opts . Relabel Configs = conf . Alerting Config . Alert Relabel Configs am Sets : = make ( map [ string ] * alertmanager Set ) for _ , cfg : = range conf . Alerting Config . Alertmanager Configs { ams , err : = new Alertmanager Set ( cfg , n . logger ) if err ! = nil { return err } ams . metrics = n . metrics if err ! = nil { return err } am Sets [ fmt . Sprintf ( " " , md 5 . Sum ( b ) ) ] = ams } n . alertmanagers = am Sets return nil } 
func ( n * Manager ) Run ( tsets < - chan map [ string ] [ ] * targetgroup . Group ) { for { select { case < - n . ctx . Done ( ) : return case ts : = < - tsets : n . reload ( ts ) case < - n . more : } alerts : = n . next Batch ( ) if ! n . send All ( alerts . . . ) { n . metrics . dropped . Add ( float 6 4 ( len ( alerts ) ) ) } } } } 
func ( n * Manager ) Send ( alerts . . . * Alert ) { n . mtx . Lock ( ) defer n . mtx . Unlock ( ) for _ , l : = range n . opts . External Labels { if a . Labels . Get ( l . Name ) = = " " { lb . Set ( l . Name , l . Value ) } } a . Labels = lb . Labels ( ) } alerts = n . relabel Alerts ( alerts ) level . Warn ( n . logger ) . Log ( " " , " " , " " , d ) n . metrics . dropped . Add ( float 6 4 ( d ) ) } level . Warn ( n . logger ) . Log ( " " , " " , " " , d ) n . metrics . dropped . Add ( float 6 4 ( d ) ) } n . queue = append ( n . queue , alerts . . . ) } 
func ( n * Manager ) Alertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) am Sets : = n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams : = range am Sets { ams . mtx . RLock ( ) for _ , am : = range ams . ams { res = append ( res , am . url ( ) ) } ams . mtx . RUnlock ( ) } return res } 
func ( n * Manager ) Dropped Alertmanagers ( ) [ ] * url . URL { n . mtx . RLock ( ) am Sets : = n . alertmanagers n . mtx . RUnlock ( ) var res [ ] * url . URL for _ , ams : = range am Sets { ams . mtx . RLock ( ) for _ , dam : = range ams . dropped Ams { res = append ( res , dam . url ( ) ) } ams . mtx . RUnlock ( ) } return res } 
func ( n * Manager ) send All ( alerts . . . * Alert ) bool { begin : = time . Now ( ) b , err : = json . Marshal ( alerts ) if err ! = nil { level . Error ( n . logger ) . Log ( " " , " " , " " , err ) return false } n . mtx . RLock ( ) am Sets : = n . alertmanagers n . mtx . RUnlock ( ) var ( wg sync . Wait Group num Success uint 6 4 ) for _ , ams : = range am Sets { ams . mtx . RLock ( ) for _ , am : = range ams . ams { wg . Add ( 1 ) ctx , cancel : = context . With Timeout ( n . ctx , time . Duration ( ams . cfg . Timeout ) ) defer cancel ( ) go func ( ams * alertmanager Set , am alertmanager ) { u : = am . url ( ) . String ( ) if err : = n . send One ( ctx , ams . client , u , b ) ; err ! = nil { level . Error ( n . logger ) . Log ( " " , u , " " , len ( alerts ) , " " , " " , " " , err ) n . metrics . errors . With Label Values ( u ) . Inc ( ) } else { atomic . Add Uint 6 4 ( & num Success , 1 ) } n . metrics . latency . With Label Values ( u ) . Observe ( time . Since ( begin ) . Seconds ( ) ) n . metrics . sent . With Label Values ( u ) . Add ( float 6 4 ( len ( alerts ) ) ) wg . Done ( ) } ( ams , am ) } ams . mtx . RUnlock ( ) } wg . Wait ( ) return num Success > 0 } 
func ( n * Manager ) Stop ( ) { level . Info ( n . logger ) . Log ( " " , " " ) n . cancel ( ) } 
func ( s * alertmanager Set ) sync ( tgs [ ] * targetgroup . Group ) { all Ams : = [ ] alertmanager { } all Dropped Ams : = [ ] alertmanager { } for _ , tg : = range tgs { ams , dropped Ams , err : = alertmanager From Group ( tg , s . cfg ) if err ! = nil { level . Error ( s . logger ) . Log ( " " , " " , " " , err ) continue } all Ams = append ( all Ams , ams . . . ) all Dropped Ams = append ( all Dropped Ams , dropped Ams . . . ) } s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . dropped Ams = [ ] alertmanager { } s . dropped Ams = append ( s . dropped Ams , all Dropped Ams . . . ) seen : = map [ string ] struct { } { } for _ , am : = range all Ams { us : = am . url ( ) . String ( ) if _ , ok : = seen [ us ] ; ok { continue } s . metrics . errors . With Label Values ( us ) seen [ us ] = struct { } { } s . ams = append ( s . ams , am ) } } 
func alertmanager From Group ( tg * targetgroup . Group , cfg * config . Alertmanager Config ) ( [ ] alertmanager , [ ] alertmanager , error ) { var res [ ] alertmanager var dropped Alert Managers [ ] alertmanager for _ , tlset : = range tg . Targets { lbls : = make ( [ ] labels . Label , 0 , len ( tlset ) + 2 + len ( tg . Labels ) ) for ln , lv : = range tlset { lbls = append ( lbls , labels . Label { Name : string ( ln ) , Value : string ( lv ) } ) } lbls = append ( lbls , labels . Label { Name : path Label , Value : post Path ( cfg . Path Prefix ) } ) } } lset : = relabel . Process ( labels . New ( lbls . . . ) , cfg . Relabel Configs . . . ) if lset = = nil { dropped Alert Managers = append ( dropped Alert Managers , alertmanager Labels { lbls } ) continue } lb : = labels . New Builder ( lset ) } return err = = nil } addr : = lset . Get ( model . Address Label ) case " " : addr = addr + " " default : return nil , nil , errors . Errorf ( " " , cfg . Scheme ) } lb . Set ( model . Address Label , addr ) } if err : = config . Check Target Address ( model . Label Value ( addr ) ) ; err ! = nil { return nil , nil , err } } } res = append ( res , alertmanager Labels { lset } ) } return res , dropped Alert Managers , nil } 
func Unquote ( s string ) ( t string , err error ) { n : = len ( s ) if n < 2 { return " " , Err Syntax } quote : = s [ 0 ] if quote ! = s [ n - 1 ] { return " " , Err Syntax } s = s [ 1 : n - 1 ] if quote = = ' ` ' { if contains ( s , ' ` ' ) { return " " , Err Syntax } return s , nil } if quote ! = ' " ' & & quote ! = ' \ ' ' { return " " , Err Syntax } if contains ( s , ' \n ' ) { return " " , Err Syntax } } var rune Tmp [ utf 8 . UTFMax ] byte buf : = make ( [ ] byte , 0 , 3 * len ( s ) / 2 ) for len ( s ) > 0 { c , multibyte , ss , err : = unquote Char ( s , quote ) if err ! = nil { return " " , err } s = ss if c < utf 8 . Rune Self | | ! multibyte { buf = append ( buf , byte ( c ) ) } else { n : = utf 8 . Encode Rune ( rune Tmp [ : ] , c ) buf = append ( buf , rune Tmp [ : n ] . . . ) } } return string ( buf ) , nil } 
func ( i item ) String ( ) string { switch { case i . typ = = Item EOF : return " " case i . typ = = Item Error : return i . val case i . typ = = Item Identifier | | i . typ = = Item Metric Identifier : return fmt . Sprintf ( " " , i . val ) case i . typ . is Keyword ( ) : return fmt . Sprintf ( " " , i . val ) case i . typ . is Operator ( ) : return fmt . Sprintf ( " " , i . val ) case i . typ . is Aggregator ( ) : return fmt . Sprintf ( " " , i . val ) case len ( i . val ) > 1 0 : return fmt . Sprintf ( " " , i . val ) } return fmt . Sprintf ( " " , i . val ) } 
func ( i Item Type ) is Aggregator With Param ( ) bool { return i = = Item Top K | | i = = Item Bottom K | | i = = Item Count Values | | i = = Item Quantile } 
func ( i Item Type ) is Comparison Operator ( ) bool { switch i { case Item EQL , Item NEQ , Item LTE , Item LSS , Item GTE , Item GTR : return true default : return false } } 
func ( i Item Type ) is Set Operator ( ) bool { switch i { case Item LAND , Item LOR , Item LUnless : return true } return false } 
func ( i Item Type ) precedence ( ) int { switch i { case Item LOR : return 1 case Item LAND , Item LUnless : return 2 case Item EQL , Item NEQ , Item LTE , Item LSS , Item GTE , Item GTR : return 3 case Item ADD , Item SUB : return 4 case Item MUL , Item DIV , Item MOD : return 5 case Item POW : return 6 default : return Lowest Prec } } 
func ( l * lexer ) next ( ) rune { if int ( l . pos ) > = len ( l . input ) { l . width = 0 return eof } r , w : = utf 8 . Decode Rune In String ( l . input [ l . pos : ] ) l . width = Pos ( w ) l . pos + = l . width return r } 
func ( l * lexer ) peek ( ) rune { r : = l . next ( ) l . backup ( ) return r } 
func ( l * lexer ) emit ( t Item Type ) { l . items < - item { t , l . start , l . input [ l . start : l . pos ] } l . start = l . pos } 
func ( l * lexer ) line Position ( ) int { lb : = strings . Last Index ( l . input [ : l . last Pos ] , " \n " ) if lb = = - 1 { return 1 + int ( l . last Pos ) } return 1 + int ( l . last Pos ) - lb } 
func ( l * lexer ) next Item ( ) item { item : = < - l . items l . last Pos = item . pos return item } 
func lex ( input string ) * lexer { l : = & lexer { input : input , items : make ( chan item ) , } go l . run ( ) return l } 
func lex Statements ( l * lexer ) state Fn { if l . brace Open { return lex Inside Braces } if strings . Has Prefix ( l . input [ l . pos : ] , line Comment ) { return lex Line Comment } switch r : = l . next ( ) ; { case r = = eof : if l . paren Depth ! = 0 { return l . errorf ( " " ) } else if l . bracket Open { return l . errorf ( " " ) } l . emit ( Item EOF ) return nil case r = = ' , ' : l . emit ( Item Comma ) case is Space ( r ) : return lex Space case r = = ' * ' : l . emit ( Item MUL ) case r = = ' / ' : l . emit ( Item DIV ) case r = = ' % ' : l . emit ( Item MOD ) case r = = ' + ' : l . emit ( Item ADD ) case r = = ' - ' : l . emit ( Item SUB ) case r = = ' ^ ' : l . emit ( Item POW ) case r = = ' = ' : if t : = l . peek ( ) ; t = = ' = ' { l . next ( ) l . emit ( Item EQL ) } else if t = = ' ~ ' { return l . errorf ( " " , t ) } else { l . emit ( Item Assign ) } case r = = ' ! ' : if t : = l . next ( ) ; t = = ' = ' { l . emit ( Item NEQ ) } else { return l . errorf ( " " , t ) } case r = = ' < ' : if t : = l . peek ( ) ; t = = ' = ' { l . next ( ) l . emit ( Item LTE ) } else { l . emit ( Item LSS ) } case r = = ' > ' : if t : = l . peek ( ) ; t = = ' = ' { l . next ( ) l . emit ( Item GTE ) } else { l . emit ( Item GTR ) } case is Digit ( r ) | | ( r = = ' . ' & & is Digit ( l . peek ( ) ) ) : l . backup ( ) return lex Number Or Duration case r = = ' " ' | | r = = ' \ ' ' : l . string Open = r return lex String case r = = ' ` ' : l . string Open = r return lex Raw String case is Alpha ( r ) | | r = = ' : ' : if ! l . bracket Open { l . backup ( ) return lex Keyword Or Identifier } if l . got Colon { return l . errorf ( " " , r ) } l . emit ( Item Colon ) l . got Colon = true case r = = ' ( ' : l . emit ( Item Left Paren ) l . paren Depth + + return lex Statements case r = = ' ) ' : l . emit ( Item Right Paren ) l . paren Depth - - if l . paren Depth < 0 { return l . errorf ( " " , r ) } return lex Statements case r = = ' { ' : l . emit ( Item Left Brace ) l . brace Open = true return lex Inside Braces ( l ) case r = = ' [ ' : if l . bracket Open { return l . errorf ( " " , r ) } l . got Colon = false l . emit ( Item Left Bracket ) l . bracket Open = true return lex Duration case r = = ' ] ' : if ! l . bracket Open { return l . errorf ( " " , r ) } l . emit ( Item Right Bracket ) l . bracket Open = false default : return l . errorf ( " " , r ) } return lex Statements } 
func lex Inside Braces ( l * lexer ) state Fn { if strings . Has Prefix ( l . input [ l . pos : ] , line Comment ) { return lex Line Comment } switch r : = l . next ( ) ; { case r = = eof : return l . errorf ( " " ) case is Space ( r ) : return lex Space case is Alpha ( r ) : l . backup ( ) return lex Identifier case r = = ' , ' : l . emit ( Item Comma ) case r = = ' " ' | | r = = ' \ ' ' : l . string Open = r return lex String case r = = ' ` ' : l . string Open = r return lex Raw String case r = = ' = ' : if l . next ( ) = = ' ~ ' { l . emit ( Item EQLRegex ) break } l . backup ( ) l . emit ( Item EQL ) case r = = ' ! ' : switch nr : = l . next ( ) ; { case nr = = ' ~ ' : l . emit ( Item NEQRegex ) case nr = = ' = ' : l . emit ( Item NEQ ) default : return l . errorf ( " " , nr ) } case r = = ' { ' : return l . errorf ( " " , r ) case r = = ' } ' : l . emit ( Item Right Brace ) l . brace Open = false if l . series Desc { return lex Value Sequence } return lex Statements default : return l . errorf ( " " , r ) } return lex Inside Braces } 
func lex Value Sequence ( l * lexer ) state Fn { switch r : = l . next ( ) ; { case r = = eof : return lex Statements case is Space ( r ) : l . emit ( Item Space ) lex Space ( l ) case r = = ' + ' : l . emit ( Item ADD ) case r = = ' - ' : l . emit ( Item SUB ) case r = = 'x ' : l . emit ( Item Times ) case r = = ' _ ' : l . emit ( Item Blank ) case is Digit ( r ) | | ( r = = ' . ' & & is Digit ( l . peek ( ) ) ) : l . backup ( ) lex Number ( l ) case is Alpha ( r ) : l . backup ( ) default : return l . errorf ( " " , r ) } return lex Value Sequence } 
func lex Escape ( l * lexer ) { var n int var base , max uint 3 2 ch : = l . next ( ) switch ch { case 'a ' , 'b ' , 'f ' , 'n ' , 'r ' , 't ' , 'v ' , ' \ \ ' , l . string Open : return case ' 0 ' , ' 1 ' , ' 2 ' , ' 3 ' , ' 4 ' , ' 5 ' , ' 6 ' , ' 7 ' : n , base , max = 3 , 8 , 2 5 5 case 'x ' : ch = l . next ( ) n , base , max = 2 , 1 6 , 2 5 5 case 'u ' : ch = l . next ( ) n , base , max = 4 , 1 6 , unicode . Max Rune case 'U ' : ch = l . next ( ) n , base , max = 8 , 1 6 , unicode . Max Rune case eof : l . errorf ( " " ) default : l . errorf ( " " , ch ) } var x uint 3 2 for n > 0 { d : = uint 3 2 ( digit Val ( ch ) ) if d > = base { if ch = = eof { l . errorf ( " " ) } l . errorf ( " " , ch ) } x = x * base + d ch = l . next ( ) n - - } if x > max | | 0x D 8 0 0 < = x & & x < 0x E 0 0 0 { l . errorf ( " " ) } } 
func digit Val ( ch rune ) int { switch { case ' 0 ' < = ch & & ch < = ' 9 ' : return int ( ch - ' 0 ' ) case 'a ' < = ch & & ch < = 'f ' : return int ( ch - 'a ' + 1 0 ) case 'A ' < = ch & & ch < = 'F ' : return int ( ch - 'A ' + 1 0 ) } return 1 6 } 
func lex String ( l * lexer ) state Fn { Loop : for { switch l . next ( ) { case ' \ \ ' : lex Escape ( l ) case utf 8 . Rune Error : return l . errorf ( " " ) case eof , ' \n ' : return l . errorf ( " " ) case l . string Open : break Loop } } l . emit ( Item String ) return lex Statements } 
func lex Space ( l * lexer ) state Fn { for is Space ( l . peek ( ) ) { l . next ( ) } l . ignore ( ) return lex Statements } 
func lex Line Comment ( l * lexer ) state Fn { l . pos + = Pos ( len ( line Comment ) ) for r : = l . next ( ) ; ! is End Of Line ( r ) & & r ! = eof ; { r = l . next ( ) } l . backup ( ) l . emit ( Item Comment ) return lex Statements } 
func lex Number ( l * lexer ) state Fn { if ! l . scan Number ( ) { return l . errorf ( " " , l . input [ l . start : l . pos ] ) } l . emit ( Item Number ) return lex Statements } 
func lex Number Or Duration ( l * lexer ) state Fn { if l . scan Number ( ) { l . emit ( Item Number ) return lex Statements } } l . backup ( ) l . emit ( Item Duration ) return lex Statements } return l . errorf ( " " , l . input [ l . start : l . pos ] ) } 
func ( l * lexer ) scan Number ( ) bool { digits : = " " } l . accept Run ( digits ) if l . accept ( " " ) { l . accept Run ( digits ) } if l . accept ( " " ) { l . accept ( " " ) l . accept Run ( " " ) } } return false } 
func lex Identifier ( l * lexer ) state Fn { for is Alpha Numeric ( l . next ( ) ) { l . backup ( ) l . emit ( Item Identifier ) return lex Statements } 
func lex Keyword Or Identifier ( l * lexer ) state Fn { Loop : for { switch r : = l . next ( ) ; { case is Alpha Numeric ( r ) | | r = = ' : ' : word : = l . input [ l . start : l . pos ] if kw , ok : = key [ strings . To Lower ( word ) ] ; ok { l . emit ( kw ) } else if ! strings . Contains ( word , " " ) { l . emit ( Item Identifier ) } else { l . emit ( Item Metric Identifier ) } break Loop } } if l . series Desc & & l . peek ( ) ! = ' { ' { return lex Value Sequence } return lex Statements } 
func is Label ( s string ) bool { if len ( s ) = = 0 | | ! is Alpha ( rune ( s [ 0 ] ) ) { return false } for _ , c : = range s [ 1 : ] { if ! is Alpha Numeric ( c ) { return false } } return true } 
func ( l * promlexer ) buf ( ) [ ] byte { return l . b [ l . start : l . i ] } 
func New Prom Parser ( b [ ] byte ) Parser { return & Prom Parser { l : & promlexer { b : append ( b , ' \n ' ) } } } 
func ( p * Prom Parser ) Series ( ) ( [ ] byte , * int 6 4 , float 6 4 ) { if p . has TS { return p . series , & p . ts , p . val } return p . series , nil , p . val } 
func ( p * Prom Parser ) Help ( ) ( [ ] byte , [ ] byte ) { m : = p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] } return m , p . text } 
func ( p * Prom Parser ) Type ( ) ( [ ] byte , Metric Type ) { return p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] , p . mtype } 
func ( p * Prom Parser ) next Token ( ) token { for { if tok : = p . l . Lex ( ) ; tok ! = t Whitespace { return tok } } } 
func ( p * Prom Parser ) Next ( ) ( Entry , error ) { var err error p . start = p . l . i p . offsets = p . offsets [ : 0 ] switch t : = p . next Token ( ) ; t { case t EOF : return Entry Invalid , io . EOF case t Linebreak : case t Help , t Type : switch t : = p . next Token ( ) ; t { case t MName : p . offsets = append ( p . offsets , p . l . start , p . l . i ) default : return Entry Invalid , parse Error ( " " , t ) } switch t : = p . next Token ( ) ; t { case t Text : if len ( p . l . buf ( ) ) > 1 { p . text = p . l . buf ( ) [ 1 : ] } else { p . text = [ ] byte { } } default : return Entry Invalid , parse Error ( " " , t ) } switch t { case t Type : switch s : = yolo String ( p . text ) ; s { case " " : p . mtype = Metric Type Counter case " " : p . mtype = Metric Type Gauge case " " : p . mtype = Metric Type Histogram case " " : p . mtype = Metric Type Summary case " " : p . mtype = Metric Type Unknown default : return Entry Invalid , errors . Errorf ( " " , s ) } case t Help : if ! utf 8 . Valid ( p . text ) { return Entry Invalid , errors . Errorf ( " " ) } } if t : = p . next Token ( ) ; t ! = t Linebreak { return Entry Invalid , parse Error ( " " , t ) } switch t { case t Help : return Entry Help , nil case t Type : return Entry Type , nil } case t Comment : p . text = p . l . buf ( ) if t : = p . next Token ( ) ; t ! = t Linebreak { return Entry Invalid , parse Error ( " " , t ) } return Entry Comment , nil case t MName : p . offsets = append ( p . offsets , p . l . i ) p . series = p . l . b [ p . start : p . l . i ] t 2 : = p . next Token ( ) if t 2 = = t Brace Open { if err : = p . parse LVals ( ) ; err ! = nil { return Entry Invalid , err } p . series = p . l . b [ p . start : p . l . i ] t 2 = p . next Token ( ) } if t 2 ! = t Value { return Entry Invalid , parse Error ( " " , t ) } if p . val , err = strconv . Parse Float ( yolo String ( p . l . buf ( ) ) , 6 4 ) ; err ! = nil { return Entry Invalid , err } } p . has TS = false switch p . next Token ( ) { case t Linebreak : break case t Timestamp : p . has TS = true if p . ts , err = strconv . Parse Int ( yolo String ( p . l . buf ( ) ) , 1 0 , 6 4 ) ; err ! = nil { return Entry Invalid , err } if t 2 : = p . next Token ( ) ; t 2 ! = t Linebreak { return Entry Invalid , parse Error ( " " , t ) } default : return Entry Invalid , parse Error ( " " , t ) } return Entry Series , nil default : err = errors . Errorf ( " " , t ) } return Entry Invalid , err } 
func New API ( qe * promql . Engine , q storage . Queryable , tr target Retriever , ar alertmanager Retriever , config Func func ( ) config . Config , flags Map map [ string ] string , ready Func func ( http . Handler Func ) http . Handler Func , db func ( ) TSDBAdmin , enable Admin bool , logger log . Logger , rr rules Retriever , remote Read Sample Limit int , remote Read Concurrency Limit int , CORSOrigin * regexp . Regexp , ) * API { return & API { Query Engine : qe , Queryable : q , target Retriever : tr , alertmanager Retriever : ar , now : time . Now , config : config Func , flags Map : flags Map , ready : ready Func , db : db , enable Admin : enable Admin , rules Retriever : rr , remote Read Sample Limit : remote Read Sample Limit , remote Read Gate : gate . New ( remote Read Concurrency Limit ) , logger : logger , CORSOrigin : CORSOrigin , } } 
func ( api * API ) Register ( r * route . Router ) { wrap : = func ( f api Func ) http . Handler Func { hf : = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { httputil . Set CORS ( w , api . CORSOrigin , r ) result : = f ( r ) if result . err ! = nil { api . respond Error ( w , result . err , result . data ) } else if result . data ! = nil { api . respond ( w , result . data , result . warnings ) } else { w . Write Header ( http . Status No Content ) } if result . finalizer ! = nil { result . finalizer ( ) } } ) return api . ready ( httputil . Compression Handler { Handler : hf , } . Serve HTTP ) } r . Options ( " " , wrap ( api . options ) ) r . Get ( " " , wrap ( api . query ) ) r . Post ( " " , wrap ( api . query ) ) r . Get ( " " , wrap ( api . query Range ) ) r . Post ( " " , wrap ( api . query Range ) ) r . Get ( " " , wrap ( api . label Names ) ) r . Post ( " " , wrap ( api . label Names ) ) r . Get ( " " , wrap ( api . label Values ) ) r . Get ( " " , wrap ( api . series ) ) r . Post ( " " , wrap ( api . series ) ) r . Del ( " " , wrap ( api . drop Series ) ) r . Get ( " " , wrap ( api . targets ) ) r . Get ( " " , wrap ( api . target Metadata ) ) r . Get ( " " , wrap ( api . alertmanagers ) ) r . Get ( " " , wrap ( api . serve Config ) ) r . Get ( " " , wrap ( api . serve Flags ) ) r . Post ( " " , api . ready ( http . Handler Func ( api . remote Read ) ) ) r . Get ( " " , wrap ( api . alerts ) ) r . Get ( " " , wrap ( api . rules ) ) r . Post ( " " , wrap ( api . clean Tombstones ) ) r . Post ( " " , wrap ( api . snapshot ) ) r . Put ( " " , wrap ( api . delete Series ) ) r . Put ( " " , wrap ( api . clean Tombstones ) ) r . Put ( " " , wrap ( api . snapshot ) ) } 
func merge Labels ( primary , secondary [ ] prompb . Label ) [ ] prompb . Label { result : = make ( [ ] prompb . Label , 0 , len ( primary ) + len ( secondary ) ) i , j : = 0 , 0 for i < len ( primary ) & & j < len ( secondary ) { if primary [ i ] . Name < secondary [ j ] . Name { result = append ( result , primary [ i ] ) i + + } else if primary [ i ] . Name > secondary [ j ] . Name { result = append ( result , secondary [ j ] ) j + + } else { result = append ( result , primary [ i ] ) i + + j + + } } for ; i < len ( primary ) ; i + + { result = append ( result , primary [ i ] ) } for ; j < len ( secondary ) ; j + + { result = append ( result , secondary [ j ] ) } return result } 
func ( l * promlexer ) Lex ( ) token { if l . i > = len ( l . b ) { return t EOF } c : = l . b [ l . i ] l . start = l . i yystate 0 : switch yyt : = l . state ; yyt { default : panic ( errors . Errorf ( `invalid start condition %d ` , yyt ) ) case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : } goto yystate 0 goto yystate 1 yystate 1 : c = l . next ( ) yystart 1 : switch { default : goto yyabort case c = = ' # ' : goto yystate 5 case c = = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 7 case c = = ' \n ' : goto yystate 4 case c = = ' \t ' | | c = = ' ' : goto yystate 3 case c = = ' \x 0 0 ' : goto yystate 2 } yystate 2 : c = l . next ( ) goto yyrule 1 yystate 3 : c = l . next ( ) switch { default : goto yyrule 3 case c = = ' \t ' | | c = = ' ' : goto yystate 3 } yystate 4 : c = l . next ( ) goto yyrule 2 yystate 5 : c = l . next ( ) switch { default : goto yyrule 5 case c = = ' \t ' | | c = = ' ' : goto yystate 6 } yystate 6 : c = l . next ( ) switch { default : goto yyrule 4 case c = = ' \t ' | | c = = ' ' : goto yystate 6 } yystate 7 : c = l . next ( ) switch { default : goto yyrule 1 0 case c > = ' 0 ' & & c < = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 7 } goto yystate 8 yystate 8 : c = l . next ( ) yystart 8 : switch { default : goto yyabort case c = = 'H ' : goto yystate 9 case c = = 'T ' : goto yystate 1 4 case c = = ' \t ' | | c = = ' ' : goto yystate 3 } yystate 9 : c = l . next ( ) switch { default : goto yyabort case c = = 'E ' : goto yystate 1 0 } yystate 1 0 : c = l . next ( ) switch { default : goto yyabort case c = = 'L ' : goto yystate 1 1 } yystate 1 1 : c = l . next ( ) switch { default : goto yyabort case c = = 'P ' : goto yystate 1 2 } yystate 1 2 : c = l . next ( ) switch { default : goto yyabort case c = = ' \t ' | | c = = ' ' : goto yystate 1 3 } yystate 1 3 : c = l . next ( ) switch { default : goto yyrule 6 case c = = ' \t ' | | c = = ' ' : goto yystate 1 3 } yystate 1 4 : c = l . next ( ) switch { default : goto yyabort case c = = 'Y ' : goto yystate 1 5 } yystate 1 5 : c = l . next ( ) switch { default : goto yyabort case c = = 'P ' : goto yystate 1 6 } yystate 1 6 : c = l . next ( ) switch { default : goto yyabort case c = = 'E ' : goto yystate 1 7 } yystate 1 7 : c = l . next ( ) switch { default : goto yyabort case c = = ' \t ' | | c = = ' ' : goto yystate 1 8 } yystate 1 8 : c = l . next ( ) switch { default : goto yyrule 7 case c = = ' \t ' | | c = = ' ' : goto yystate 1 8 } goto yystate 1 9 yystate 1 9 : c = l . next ( ) yystart 1 9 : switch { default : goto yyabort case c = = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 0 case c = = ' \t ' | | c = = ' ' : goto yystate 3 } yystate 2 0 : c = l . next ( ) switch { default : goto yyrule 8 case c > = ' 0 ' & & c < = ' : ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 0 } goto yystate 2 1 yystate 2 1 : c = l . next ( ) yystart 2 1 : switch { default : goto yyrule 9 case c = = ' \t ' | | c = = ' ' : goto yystate 2 3 case c > = ' \x 0 1 ' & & c < = ' \b ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 2 2 } yystate 2 2 : c = l . next ( ) switch { default : goto yyrule 9 case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ÿ ' : goto yystate 2 2 } yystate 2 3 : c = l . next ( ) switch { default : goto yyrule 3 case c = = ' \t ' | | c = = ' ' : goto yystate 2 3 case c > = ' \x 0 1 ' & & c < = ' \b ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = ' ÿ ' : goto yystate 2 2 } goto yystate 2 4 yystate 2 4 : c = l . next ( ) yystart 2 4 : switch { default : goto yyabort case c = = ' , ' : goto yystate 2 5 case c = = ' = ' : goto yystate 2 6 case c = = ' \t ' | | c = = ' ' : goto yystate 3 case c = = ' } ' : goto yystate 2 8 case c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 7 } yystate 2 5 : c = l . next ( ) goto yyrule 1 5 yystate 2 6 : c = l . next ( ) goto yyrule 1 4 yystate 2 7 : c = l . next ( ) switch { default : goto yyrule 1 2 case c > = ' 0 ' & & c < = ' 9 ' | | c > = 'A ' & & c < = 'Z ' | | c = = ' _ ' | | c > = 'a ' & & c < = 'z ' : goto yystate 2 7 } yystate 2 8 : c = l . next ( ) goto yyrule 1 3 goto yystate 2 9 yystate 2 9 : c = l . next ( ) yystart 2 9 : switch { default : goto yyabort case c = = ' " ' : goto yystate 3 0 case c = = ' \t ' | | c = = ' ' : goto yystate 3 } yystate 3 0 : c = l . next ( ) switch { default : goto yyabort case c = = ' " ' : goto yystate 3 1 case c = = ' \ \ ' : goto yystate 3 2 case c > = ' \x 0 1 ' & & c < = ' ! ' | | c > = ' # ' & & c < = ' [ ' | | c > = ' ] ' & & c < = ' ÿ ' : goto yystate 3 0 } yystate 3 1 : c = l . next ( ) goto yyrule 1 6 yystate 3 2 : c = l . next ( ) switch { default : goto yyabort case c > = ' \x 0 1 ' & & c < = ' \t ' | | c > = ' \v ' & & c < = ' ÿ ' : goto yystate 3 0 } goto yystate 3 3 yystate 3 3 : c = l . next ( ) yystart 3 3 : switch { default : goto yyabort case c = = ' \t ' | | c = = ' ' : goto yystate 3 case c = = ' { ' : goto yystate 3 5 case c > = ' \x 0 1 ' & & c < = ' \b ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = 'z ' | | c > = ' | ' & & c < = ' ÿ ' : goto yystate 3 4 } yystate 3 4 : c = l . next ( ) switch { default : goto yyrule 1 7 case c > = ' \x 0 1 ' & & c < = ' \b ' | | c > = ' \v ' & & c < = ' \x 1f ' | | c > = ' ! ' & & c < = 'z ' | | c > = ' | ' & & c < = ' ÿ ' : goto yystate 3 4 } yystate 3 5 : c = l . next ( ) goto yyrule 1 1 goto yystate 3 6 yystate 3 6 : c = l . next ( ) yystart 3 6 : switch { default : goto yyabort case c = = ' \n ' : goto yystate 3 7 case c = = ' \t ' | | c = = ' ' : goto yystate 3 case c > = ' 0 ' & & c < = ' 9 ' : goto yystate 3 8 } yystate 3 7 : c = l . next ( ) goto yyrule 1 9 yystate 3 8 : c = l . next ( ) switch { default : goto yyrule 1 8 case c > = ' 0 ' & & c < = ' 9 ' : goto yystate 3 8 } yyrule 1 : } yyrule 2 : return t Linebreak goto yystate 0 } yyrule 3 : } yyrule 4 : goto yystate 0 } yyrule 5 : } yyrule 6 : return t Help goto yystate 0 } yyrule 7 : return t Type goto yystate 0 } yyrule 8 : return t MName goto yystate 0 } yyrule 9 : return t Text goto yystate 0 } yyrule 1 0 : return t MName goto yystate 0 } yyrule 1 1 : return t Brace Open goto yystate 0 } yyrule 1 2 : } yyrule 1 3 : return t Brace Close goto yystate 0 } yyrule 1 4 : return t Equal goto yystate 0 } yyrule 1 5 : } yyrule 1 6 : return t LValue goto yystate 0 } yyrule 1 7 : return t Value goto yystate 0 } yyrule 1 8 : } yyrule 1 9 : return t Linebreak goto yystate 0 } panic ( " " ) goto yyabort yyabort : } return t Invalid } 
func ( s * Ready Storage ) Set ( db * tsdb . DB , start Time Margin int 6 4 ) { s . mtx . Lock ( ) defer s . mtx . Unlock ( ) s . a = & adapter { db : db , start Time Margin : start Time Margin } } 
func ( s * Ready Storage ) Get ( ) * tsdb . DB { if x : = s . get ( ) ; x ! = nil { return x . db } return nil } 
func ( s * Ready Storage ) Start Time ( ) ( int 6 4 , error ) { if x : = s . get ( ) ; x ! = nil { return x . Start Time ( ) } return int 6 4 ( model . Latest ) , Err Not Ready } 
func ( s * Ready Storage ) Querier ( ctx context . Context , mint , maxt int 6 4 ) ( storage . Querier , error ) { if x : = s . get ( ) ; x ! = nil { return x . Querier ( ctx , mint , maxt ) } return nil , Err Not Ready } 
func ( s * Ready Storage ) Appender ( ) ( storage . Appender , error ) { if x : = s . get ( ) ; x ! = nil { return x . Appender ( ) } return nil , Err Not Ready } 
func ( s * Ready Storage ) Close ( ) error { if x : = s . Get ( ) ; x ! = nil { return x . Close ( ) } return nil } 
func Adapter ( db * tsdb . DB , start Time Margin int 6 4 ) storage . Storage { return & adapter { db : db , start Time Margin : start Time Margin } } 
func Open ( path string , l log . Logger , r prometheus . Registerer , opts * Options ) ( * tsdb . DB , error ) { if opts . Min Block Duration > opts . Max Block Duration { opts . Max Block Duration = opts . Min Block Duration } for i , v : = range rngs { if v > int 6 4 ( time . Duration ( opts . Max Block Duration ) . Seconds ( ) * 1 0 0 0 ) { rngs = rngs [ : i ] break } } db , err : = tsdb . Open ( path , l , r , & tsdb . Options { WALSegment Size : int ( opts . WALSegment Size ) , Retention Duration : uint 6 4 ( time . Duration ( opts . Retention Duration ) . Seconds ( ) * 1 0 0 0 ) , Max Bytes : int 6 4 ( opts . Max Bytes ) , Block Ranges : rngs , No Lockfile : opts . No Lockfile , Allow Overlapping Blocks : opts . Allow Overlapping Blocks , } ) if err ! = nil { return nil , err } register Metrics ( db , r ) return db , nil } 
func ( a adapter ) Start Time ( ) ( int 6 4 , error ) { var start Time int 6 4 if len ( a . db . Blocks ( ) ) > 0 { start Time = a . db . Blocks ( ) [ 0 ] . Meta ( ) . Min Time } else { start Time = time . Now ( ) . Unix ( ) * 1 0 0 0 } } 
func ( a adapter ) Appender ( ) ( storage . Appender , error ) { return appender { a : a . db . Appender ( ) } , nil } 
func ( a * Action ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { var s string if err : = unmarshal ( & s ) ; err ! = nil { return err } switch act : = Action ( strings . To Lower ( s ) ) ; act { case Replace , Keep , Drop , Hash Mod , Label Map , Label Drop , Label Keep : * a = act return nil } return errors . Errorf ( " " , s ) } 
func ( c * Config ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default Relabel Config type plain Config if err : = unmarshal ( ( * plain ) ( c ) ) ; err ! = nil { return err } if c . Regex . Regexp = = nil { c . Regex = Must New Regexp ( " " ) } if c . Modulus = = 0 & & c . Action = = Hash Mod { return errors . Errorf ( " " ) } if ( c . Action = = Replace | | c . Action = = Hash Mod ) & & c . Target Label = = " " { return errors . Errorf ( " " , c . Action ) } if c . Action = = Replace & & ! relabel Target . Match String ( c . Target Label ) { return errors . Errorf ( " " , c . Target Label , c . Action ) } if c . Action = = Label Map & & ! relabel Target . Match String ( c . Replacement ) { return errors . Errorf ( " " , c . Replacement , c . Action ) } if c . Action = = Hash Mod & & ! model . Label Name ( c . Target Label ) . Is Valid ( ) { return errors . Errorf ( " " , c . Target Label , c . Action ) } if c . Action = = Label Drop | | c . Action = = Label Keep { if c . Source Labels ! = nil | | c . Target Label ! = Default Relabel Config . Target Label | | c . Modulus ! = Default Relabel Config . Modulus | | c . Separator ! = Default Relabel Config . Separator | | c . Replacement ! = Default Relabel Config . Replacement { return errors . Errorf ( " " , c . Action ) } } return nil } 
func New Regexp ( s string ) ( Regexp , error ) { regex , err : = regexp . Compile ( " " + s + " " ) return Regexp { Regexp : regex , original : s , } , err } 
func Must New Regexp ( s string ) Regexp { re , err : = New Regexp ( s ) if err ! = nil { panic ( err ) } return re } 
func ( re * Regexp ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { var s string if err : = unmarshal ( & s ) ; err ! = nil { return err } r , err : = New Regexp ( s ) if err ! = nil { return err } * re = r return nil } 
func ( re Regexp ) Marshal YAML ( ) ( interface { } , error ) { if re . original ! = " " { return re . original , nil } return nil , nil } 
func Process ( labels labels . Labels , cfgs . . . * Config ) labels . Labels { for _ , cfg : = range cfgs { labels = relabel ( labels , cfg ) if labels = = nil { return nil } } return labels } 
func sum 6 4 ( hash [ md 5 . Size ] byte ) uint 6 4 { var s uint 6 4 for i , b : = range hash { shift : = uint 6 4 ( ( md 5 . Size - i - 1 ) * 8 ) s | = uint 6 4 ( b ) < < shift } return s } 
func ( sp * scrape Pool ) stop ( ) { sp . cancel ( ) var wg sync . Wait Group sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) for fp , l : = range sp . loops { wg . Add ( 1 ) go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( l ) delete ( sp . loops , fp ) delete ( sp . active Targets , fp ) } wg . Wait ( ) sp . client . Close Idle Connections ( ) } 
func ( sp * scrape Pool ) reload ( cfg * config . Scrape Config ) error { target Scrape Pool Reloads . Inc ( ) start : = time . Now ( ) sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) client , err : = config _util . New Client From Config ( cfg . HTTPClient Config , cfg . Job Name ) if err ! = nil { target Scrape Pool Reloads Failed . Inc ( ) return errors . Wrap ( err , " " ) } sp . config = cfg old Client : = sp . client sp . client = client var ( wg sync . Wait Group interval = time . Duration ( sp . config . Scrape Interval ) timeout = time . Duration ( sp . config . Scrape Timeout ) limit = int ( sp . config . Sample Limit ) honor Labels = sp . config . Honor Labels honor Timestamps = sp . config . Honor Timestamps mrc = sp . config . Metric Relabel Configs ) for fp , old Loop : = range sp . loops { var ( t = sp . active Targets [ fp ] s = & target Scraper { Target : t , client : sp . client , timeout : timeout } new Loop = sp . new Loop ( scrape Loop Options { target : t , scraper : s , limit : limit , honor Labels : honor Labels , honor Timestamps : honor Timestamps , mrc : mrc , } ) ) wg . Add ( 1 ) go func ( old Loop , new Loop loop ) { old Loop . stop ( ) wg . Done ( ) go new Loop . run ( interval , timeout , nil ) } ( old Loop , new Loop ) sp . loops [ fp ] = new Loop } wg . Wait ( ) old Client . Close Idle Connections ( ) target Reload Interval Length . With Label Values ( interval . String ( ) ) . Observe ( time . Since ( start ) . Seconds ( ) , ) return nil } 
func ( sp * scrape Pool ) Sync ( tgs [ ] * targetgroup . Group ) { start : = time . Now ( ) var all [ ] * Target sp . mtx . Lock ( ) sp . dropped Targets = [ ] * Target { } for _ , tg : = range tgs { targets , err : = targets From Group ( tg , sp . config ) if err ! = nil { level . Error ( sp . logger ) . Log ( " " , " " , " " , err ) continue } for _ , t : = range targets { if t . Labels ( ) . Len ( ) > 0 { all = append ( all , t ) } else if t . Discovered Labels ( ) . Len ( ) > 0 { sp . dropped Targets = append ( sp . dropped Targets , t ) } } } sp . mtx . Unlock ( ) sp . sync ( all ) target Sync Interval Length . With Label Values ( sp . config . Job Name ) . Observe ( time . Since ( start ) . Seconds ( ) , ) target Scrape Pool Syncs Counter . With Label Values ( sp . config . Job Name ) . Inc ( ) } 
func ( sp * scrape Pool ) sync ( targets [ ] * Target ) { sp . mtx . Lock ( ) defer sp . mtx . Unlock ( ) var ( unique Targets = map [ uint 6 4 ] struct { } { } interval = time . Duration ( sp . config . Scrape Interval ) timeout = time . Duration ( sp . config . Scrape Timeout ) limit = int ( sp . config . Sample Limit ) honor Labels = sp . config . Honor Labels honor Timestamps = sp . config . Honor Timestamps mrc = sp . config . Metric Relabel Configs ) for _ , t : = range targets { t : = t hash : = t . hash ( ) unique Targets [ hash ] = struct { } { } if _ , ok : = sp . active Targets [ hash ] ; ! ok { s : = & target Scraper { Target : t , client : sp . client , timeout : timeout } l : = sp . new Loop ( scrape Loop Options { target : t , scraper : s , limit : limit , honor Labels : honor Labels , honor Timestamps : honor Timestamps , mrc : mrc , } ) sp . active Targets [ hash ] = t sp . loops [ hash ] = l go l . run ( interval , timeout , nil ) } else { } } var wg sync . Wait Group go func ( l loop ) { l . stop ( ) wg . Done ( ) } ( sp . loops [ hash ] ) delete ( sp . loops , hash ) delete ( sp . active Targets , hash ) } } } 
func appender ( app storage . Appender , limit int ) storage . Appender { app = & time Limit Appender { Appender : app , max Time : timestamp . From Time ( time . Now ( ) . Add ( max Ahead Time ) ) , } } return app } 
func ( i * Ingress ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer i . queue . Shut Down ( ) if ! cache . Wait For Cache Sync ( ctx . Done ( ) , i . informer . Has Synced ) { level . Error ( i . logger ) . Log ( " " , " " ) return } go func ( ) { for i . process ( ctx , ch ) { } } ( ) } 
func Uname ( ) string { buf : = syscall . Utsname { } err : = syscall . Uname ( & buf ) if err ! = nil { panic ( " " + err . Error ( ) ) } str : = " " + chars To String ( buf . Sysname [ : ] ) str + = " " + chars To String ( buf . Release [ : ] ) str + = " " + chars To String ( buf . Version [ : ] ) str + = " " + chars To String ( buf . Machine [ : ] ) str + = " " + chars To String ( buf . Nodename [ : ] ) str + = " " + chars To String ( buf . Domainname [ : ] ) + " " return str } 
func Decode Read Request ( r * http . Request ) ( * prompb . Read Request , error ) { compressed , err : = ioutil . Read All ( io . Limit Reader ( r . Body , decode Read Limit ) ) if err ! = nil { return nil , err } req Buf , err : = snappy . Decode ( nil , compressed ) if err ! = nil { return nil , err } var req prompb . Read Request if err : = proto . Unmarshal ( req Buf , & req ) ; err ! = nil { return nil , err } return & req , nil } 
func Encode Read Response ( resp * prompb . Read Response , w http . Response Writer ) error { data , err : = proto . Marshal ( resp ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) compressed : = snappy . Encode ( nil , data ) _ , err = w . Write ( compressed ) return err } 
func To Query ( from , to int 6 4 , matchers [ ] * labels . Matcher , p * storage . Select Params ) ( * prompb . Query , error ) { ms , err : = to Label Matchers ( matchers ) if err ! = nil { return nil , err } var rp * prompb . Read Hints if p ! = nil { rp = & prompb . Read Hints { Step Ms : p . Step , Func : p . Func , Start Ms : p . Start , End Ms : p . End , } } return & prompb . Query { Start Timestamp Ms : from , End Timestamp Ms : to , Matchers : ms , Hints : rp , } , nil } 
func From Query ( req * prompb . Query ) ( int 6 4 , int 6 4 , [ ] * labels . Matcher , * storage . Select Params , error ) { matchers , err : = from Label Matchers ( req . Matchers ) if err ! = nil { return 0 , 0 , nil , nil , err } var select Params * storage . Select Params if req . Hints ! = nil { select Params = & storage . Select Params { Start : req . Hints . Start Ms , End : req . Hints . End Ms , Step : req . Hints . Step Ms , Func : req . Hints . Func , } } return req . Start Timestamp Ms , req . End Timestamp Ms , matchers , select Params , nil } 
func To Query Result ( ss storage . Series Set , sample Limit int ) ( * prompb . Query Result , error ) { num Samples : = 0 resp : = & prompb . Query Result { } for ss . Next ( ) { series : = ss . At ( ) iter : = series . Iterator ( ) samples : = [ ] prompb . Sample { } for iter . Next ( ) { num Samples + + if sample Limit > 0 & & num Samples > sample Limit { return nil , HTTPError { msg : fmt . Sprintf ( " " , sample Limit ) , status : http . Status Bad Request , } } ts , val : = iter . At ( ) samples = append ( samples , prompb . Sample { Timestamp : ts , Value : val , } ) } if err : = iter . Err ( ) ; err ! = nil { return nil , err } resp . Timeseries = append ( resp . Timeseries , & prompb . Time Series { Labels : labels To Labels Proto ( series . Labels ( ) ) , Samples : samples , } ) } if err : = ss . Err ( ) ; err ! = nil { return nil , err } return resp , nil } 
func From Query Result ( res * prompb . Query Result ) storage . Series Set { series : = make ( [ ] storage . Series , 0 , len ( res . Timeseries ) ) for _ , ts : = range res . Timeseries { labels : = label Protos To Labels ( ts . Labels ) if err : = validate Labels And Metric Name ( labels ) ; err ! = nil { return err Series Set { err : err } } series = append ( series , & concrete Series { labels : labels , samples : ts . Samples , } ) } sort . Sort ( by Label ( series ) ) return & concrete Series Set { series : series , } } 
func ( c * concrete Series Iterator ) Seek ( t int 6 4 ) bool { c . cur = sort . Search ( len ( c . series . samples ) , func ( n int ) bool { return c . series . samples [ n ] . Timestamp > = t } ) return c . cur < len ( c . series . samples ) } 
func ( c * concrete Series Iterator ) At ( ) ( t int 6 4 , v float 6 4 ) { s : = c . series . samples [ c . cur ] return s . Timestamp , s . Value } 
func ( c * concrete Series Iterator ) Next ( ) bool { c . cur + + return c . cur < len ( c . series . samples ) } 
func validate Labels And Metric Name ( ls labels . Labels ) error { for _ , l : = range ls { if l . Name = = labels . Metric Name & & ! model . Is Valid Metric Name ( model . Label Value ( l . Value ) ) { return errors . Errorf ( " " , l . Value ) } if ! model . Label Name ( l . Name ) . Is Valid ( ) { return errors . Errorf ( " " , l . Name ) } if ! model . Label Value ( l . Value ) . Is Valid ( ) { return errors . Errorf ( " " , l . Value ) } } return nil } 
func Label Protos To Metric ( label Pairs [ ] * prompb . Label ) model . Metric { metric : = make ( model . Metric , len ( label Pairs ) ) for _ , l : = range label Pairs { metric [ model . Label Name ( l . Name ) ] = model . Label Value ( l . Value ) } return metric } 
func New Buffer Iterator ( it Series Iterator , delta int 6 4 ) * Buffered Series Iterator { bit : = & Buffered Series Iterator { buf : new Sample Ring ( delta , 1 6 ) , delta : delta , } bit . Reset ( it ) return bit } 
func ( b * Buffered Series Iterator ) Reset ( it Series Iterator ) { b . it = it b . last Time = math . Min Int 6 4 b . ok = true b . buf . reset ( ) b . buf . delta = b . delta it . Next ( ) } 
func ( b * Buffered Series Iterator ) Reduce Delta ( delta int 6 4 ) bool { return b . buf . reduce Delta ( delta ) } 
func ( b * Buffered Series Iterator ) Peek Back ( n int ) ( t int 6 4 , v float 6 4 , ok bool ) { return b . buf . nth Last ( n ) } 
func ( b * Buffered Series Iterator ) Seek ( t int 6 4 ) bool { t 0 : = t - b . buf . delta b . ok = b . it . Seek ( t 0 ) if ! b . ok { return false } b . last Time , _ = b . Values ( ) } if b . last Time > = t { return true } for b . Next ( ) { if b . last Time > = t { return true } } return false } 
func ( b * Buffered Series Iterator ) Next ( ) bool { if ! b . ok { return false } b . ok = b . it . Next ( ) if b . ok { b . last Time , _ = b . Values ( ) } return b . ok } 
func ( r * sample Ring ) iterator ( ) Series Iterator { r . it . r = r r . it . i = - 1 return & r . it } 
func ( r * sample Ring ) reduce Delta ( delta int 6 4 ) bool { if delta > r . delta { return false } r . delta = delta if r . l = = 0 { return true } tmin : = r . buf [ r . i ] . t - delta for r . buf [ r . f ] . t < tmin { r . f + + if r . f > = l { r . f - = l } r . l - - } return true } 
func ( r * sample Ring ) nth Last ( n int ) ( int 6 4 , float 6 4 , bool ) { if n > r . l { return 0 , 0 , false } t , v : = r . at ( r . l - n ) return t , v , true } 
func ( l * open Metrics Lexer ) buf ( ) [ ] byte { return l . b [ l . start : l . i ] } 
func ( l * open Metrics Lexer ) next ( ) byte { l . i + + if l . i > = len ( l . b ) { l . err = io . EOF return byte ( t EOF ) } if l . i > = len ( l . b ) { l . err = io . EOF return byte ( t EOF ) } } return l . b [ l . i ] } 
func ( p * Open Metrics Parser ) Help ( ) ( [ ] byte , [ ] byte ) { m : = p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] } return m , p . text } 
func ( p * Open Metrics Parser ) Unit ( ) ( [ ] byte , [ ] byte ) { } 
func ( p * Open Metrics Parser ) Metric ( l * labels . Labels ) string { * l = append ( * l , labels . Label { Name : labels . Metric Name , Value : s [ : p . offsets [ 0 ] - p . start ] , } ) for i : = 1 ; i < len ( p . offsets ) ; i + = 4 { a : = p . offsets [ i ] - p . start b : = p . offsets [ i + 1 ] - p . start c : = p . offsets [ i + 2 ] - p . start d : = p . offsets [ i + 3 ] - p . start continue } * l = append ( * l , labels . Label { Name : s [ a : b ] , Value : s [ c : d ] } ) } return s } 
func ( p * Open Metrics Parser ) Next ( ) ( Entry , error ) { var err error p . start = p . l . i p . offsets = p . offsets [ : 0 ] switch t : = p . next Token ( ) ; t { case t Eof Word : if t : = p . next Token ( ) ; t ! = t EOF { return Entry Invalid , errors . New ( " " ) } return Entry Invalid , io . EOF case t EOF : return Entry Invalid , parse Error ( " " , t ) case t Help , t Type , t Unit : switch t : = p . next Token ( ) ; t { case t MName : p . offsets = append ( p . offsets , p . l . start , p . l . i ) default : return Entry Invalid , parse Error ( " " , t ) } switch t : = p . next Token ( ) ; t { case t Text : if len ( p . l . buf ( ) ) > 1 { p . text = p . l . buf ( ) [ 1 : len ( p . l . buf ( ) ) - 1 ] } else { p . text = [ ] byte { } } default : return Entry Invalid , parse Error ( " " , t ) } switch t { case t Type : switch s : = yolo String ( p . text ) ; s { case " " : p . mtype = Metric Type Counter case " " : p . mtype = Metric Type Gauge case " " : p . mtype = Metric Type Histogram case " " : p . mtype = Metric Type Gauge Histogram case " " : p . mtype = Metric Type Summary case " " : p . mtype = Metric Type Info case " " : p . mtype = Metric Type Stateset case " " : p . mtype = Metric Type Unknown default : return Entry Invalid , errors . Errorf ( " " , s ) } case t Help : if ! utf 8 . Valid ( p . text ) { return Entry Invalid , errors . New ( " " ) } } switch t { case t Help : return Entry Help , nil case t Type : return Entry Type , nil case t Unit : m : = yolo String ( p . l . b [ p . offsets [ 0 ] : p . offsets [ 1 ] ] ) u : = yolo String ( p . text ) if len ( u ) > 0 { if ! strings . Has Suffix ( m , u ) | | len ( m ) < len ( u ) + 1 | | p . l . b [ p . offsets [ 1 ] - len ( u ) - 1 ] ! = ' _ ' { return Entry Invalid , errors . Errorf ( " " , m ) } } return Entry Unit , nil } case t MName : p . offsets = append ( p . offsets , p . l . i ) p . series = p . l . b [ p . start : p . l . i ] t 2 : = p . next Token ( ) if t 2 = = t Brace Open { if err : = p . parse LVals ( ) ; err ! = nil { return Entry Invalid , err } p . series = p . l . b [ p . start : p . l . i ] t 2 = p . next Token ( ) } if t 2 ! = t Value { return Entry Invalid , parse Error ( " " , t ) } if p . val , err = strconv . Parse Float ( yolo String ( p . l . buf ( ) [ 1 : ] ) , 6 4 ) ; err ! = nil { return Entry Invalid , err } } p . has TS = false switch p . next Token ( ) { case t Linebreak : break case t Timestamp : p . has TS = true var ts float 6 4 } p . ts = int 6 4 ( ts * 1 0 0 0 ) if t 2 : = p . next Token ( ) ; t 2 ! = t Linebreak { return Entry Invalid , parse Error ( " " , t ) } default : return Entry Invalid , parse Error ( " " , t ) } return Entry Series , nil default : err = errors . Errorf ( " " , t , string ( p . l . cur ( ) ) ) } return Entry Invalid , err } 
func bucket Quantile ( q float 6 4 , buckets buckets ) float 6 4 { if q < 0 { return math . Inf ( - 1 ) } if q > 1 { return math . Inf ( + 1 ) } sort . Sort ( buckets ) if ! math . Is Inf ( buckets [ len ( buckets ) - 1 ] . upper Bound , + 1 ) { return math . Na N ( ) } buckets = coalesce Buckets ( buckets ) ensure Monotonic ( buckets ) if len ( buckets ) < 2 { return math . Na N ( ) } rank : = q * buckets [ len ( buckets ) - 1 ] . count b : = sort . Search ( len ( buckets ) - 1 , func ( i int ) bool { return buckets [ i ] . count > = rank } ) if b = = len ( buckets ) - 1 { return buckets [ len ( buckets ) - 2 ] . upper Bound } if b = = 0 & & buckets [ 0 ] . upper Bound < = 0 { return buckets [ 0 ] . upper Bound } var ( bucket Start float 6 4 bucket End = buckets [ b ] . upper Bound count = buckets [ b ] . count ) if b > 0 { bucket Start = buckets [ b - 1 ] . upper Bound count - = buckets [ b - 1 ] . count rank - = buckets [ b - 1 ] . count } return bucket Start + ( bucket End - bucket Start ) * ( rank / count ) } 
func coalesce Buckets ( buckets buckets ) buckets { last : = buckets [ 0 ] i : = 0 for _ , b : = range buckets [ 1 : ] { if b . upper Bound = = last . upper Bound { last . count + = b . count } else { buckets [ i ] = last last = b i + + } } buckets [ i ] = last return buckets [ : i + 1 ] } 
func ensure Monotonic ( buckets buckets ) { max : = buckets [ 0 ] . count for i : = range buckets [ 1 : ] { switch { case buckets [ i ] . count > max : max = buckets [ i ] . count case buckets [ i ] . count < max : buckets [ i ] . count = max } } } 
func quantile ( q float 6 4 , values vector By Value Heap ) float 6 4 { if len ( values ) = = 0 { return math . Na N ( ) } if q < 0 { return math . Inf ( - 1 ) } if q > 1 { return math . Inf ( + 1 ) } sort . Sort ( values ) n : = float 6 4 ( len ( values ) ) lower Index : = math . Max ( 0 , math . Floor ( rank ) ) upper Index : = math . Min ( n - 1 , lower Index + 1 ) weight : = rank - math . Floor ( rank ) return values [ int ( lower Index ) ] . V * ( 1 - weight ) + values [ int ( upper Index ) ] . V * weight } 
func ( c * SDConfig ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { * c = Default SDConfig type plain SDConfig err : = unmarshal ( ( * plain ) ( c ) ) if err ! = nil { return err } if len ( c . Files ) = = 0 { return errors . New ( " " ) } for _ , name : = range c . Files { if ! pat File SDName . Match String ( name ) { return errors . Errorf ( " " , name ) } } return nil } 
func ( t * Timestamp Collector ) Collect ( ch chan < - prometheus . Metric ) { t . lock . RLock ( ) for file SD : = range t . discoverers { file SD . lock . RLock ( ) for filename , timestamp : = range file SD . timestamps { unique Files [ filename ] = timestamp } file SD . lock . RUnlock ( ) } t . lock . RUnlock ( ) for filename , timestamp : = range unique Files { ch < - prometheus . Must New Const Metric ( t . Description , prometheus . Gauge Value , timestamp , filename , ) } } 
func New Timestamp Collector ( ) * Timestamp Collector { return & Timestamp Collector { Description : prometheus . New Desc ( " " , " " , [ ] string { " " } , nil , ) , discoverers : make ( map [ * Discovery ] struct { } ) , } } 
func New Discovery ( conf * SDConfig , logger log . Logger ) * Discovery { if logger = = nil { logger = log . New Nop Logger ( ) } disc : = & Discovery { paths : conf . Files , interval : time . Duration ( conf . Refresh Interval ) , timestamps : make ( map [ string ] float 6 4 ) , logger : logger , } file SDTime Stamp . add Discoverer ( disc ) return disc } 
func ( d * Discovery ) list Files ( ) [ ] string { var paths [ ] string for _ , p : = range d . paths { files , err : = filepath . Glob ( p ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) continue } paths = append ( paths , files . . . ) } return paths } 
func ( d * Discovery ) watch Files ( ) { if d . watcher = = nil { panic ( " " ) } for _ , p : = range d . paths { if idx : = strings . Last Index ( p , " " ) ; idx > - 1 { p = p [ : idx ] } else { p = " " } if err : = d . watcher . Add ( p ) ; err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) } } } 
func ( d * Discovery ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { watcher , err : = fsnotify . New Watcher ( ) if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) return } d . watcher = watcher defer d . stop ( ) d . refresh ( ctx , ch ) ticker : = time . New Ticker ( d . interval ) defer ticker . Stop ( ) for { select { case < - ctx . Done ( ) : return case event : = < - d . watcher . Events : } } case < - ticker . C : case err : = < - d . watcher . Errors : if err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , err ) } } } } 
func ( d * Discovery ) stop ( ) { level . Debug ( d . logger ) . Log ( " " , " " , " " , fmt . Sprintf ( " " , d . paths ) ) done : = make ( chan struct { } ) defer close ( done ) file SDTime Stamp . remove Discoverer ( d ) } } } ( ) if err : = d . watcher . Close ( ) ; err ! = nil { level . Error ( d . logger ) . Log ( " " , " " , " " , fmt . Sprintf ( " " , d . paths ) , " " , err ) } level . Debug ( d . logger ) . Log ( " " , " " ) } 
func ( d * Discovery ) refresh ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { t 0 : = time . Now ( ) defer func ( ) { file SDScan Duration . Observe ( time . Since ( t 0 ) . Seconds ( ) ) } ( ) ref : = map [ string ] int { } for _ , p : = range d . list Files ( ) { tgroups , err : = d . read File ( p ) if err ! = nil { file SDRead Errors Count . Inc ( ) level . Error ( d . logger ) . Log ( " " , " " , " " , p , " " , err ) continue } select { case ch < - tgroups : case < - ctx . Done ( ) : return } ref [ p ] = len ( tgroups ) } if ! ok | | n > m { level . Debug ( d . logger ) . Log ( " " , " " , " " , f ) d . delete Timestamp ( f ) for i : = m ; i < n ; i + + { select { case ch < - [ ] * targetgroup . Group { { Source : file Source ( f , i ) } } : case < - ctx . Done ( ) : return } } } } d . last Refresh = ref d . watch Files ( ) } 
func ( d * Discovery ) read File ( filename string ) ( [ ] * targetgroup . Group , error ) { fd , err : = os . Open ( filename ) if err ! = nil { return nil , err } defer fd . Close ( ) content , err : = ioutil . Read All ( fd ) if err ! = nil { return nil , err } info , err : = fd . Stat ( ) if err ! = nil { return nil , err } var target Groups [ ] * targetgroup . Group switch ext : = filepath . Ext ( filename ) ; strings . To Lower ( ext ) { case " " : if err : = json . Unmarshal ( content , & target Groups ) ; err ! = nil { return nil , err } case " " , " " : if err : = yaml . Unmarshal Strict ( content , & target Groups ) ; err ! = nil { return nil , err } default : panic ( errors . Errorf ( " " , ext ) ) } for i , tg : = range target Groups { if tg = = nil { err = errors . New ( " " ) return nil , err } tg . Source = file Source ( filename , i ) if tg . Labels = = nil { tg . Labels = model . Label Set { } } tg . Labels [ file SDFilepath Label ] = model . Label Value ( filename ) } d . write Timestamp ( filename , float 6 4 ( info . Mod Time ( ) . Unix ( ) ) ) return target Groups , nil } 
func file Source ( filename string , i int ) string { return fmt . Sprintf ( " " , filename , i ) } 
func New Recording Rule ( name string , vector promql . Expr , lset labels . Labels ) * Recording Rule { return & Recording Rule { name : name , vector : vector , health : Health Unknown , labels : lset , } } 
func ( rule * Recording Rule ) Eval ( ctx context . Context , ts time . Time , query Query Func , _ * url . URL ) ( promql . Vector , error ) { vector , err : = query ( ctx , rule . vector . String ( ) , ts ) if err ! = nil { rule . Set Health ( Health Bad ) rule . Set Last Error ( err ) return nil , err } lb : = labels . New Builder ( sample . Metric ) lb . Set ( labels . Metric Name , rule . name ) for _ , l : = range rule . labels { if l . Value = = " " { lb . Del ( l . Name ) } else { lb . Set ( l . Name , l . Value ) } } sample . Metric = lb . Labels ( ) } rule . Set Health ( Health Good ) rule . Set Last Error ( err ) return vector , nil } 
func ( rule * Recording Rule ) Set Evaluation Duration ( dur time . Duration ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . evaluation Duration = dur } 
func ( rule * Recording Rule ) Set Last Error ( err error ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . last Error = err } 
func ( rule * Recording Rule ) Last Error ( ) error { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . last Error } 
func ( rule * Recording Rule ) Set Health ( health Rule Health ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . health = health } 
func ( rule * Recording Rule ) Health ( ) Rule Health { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . health } 
func ( rule * Recording Rule ) Get Evaluation Duration ( ) time . Duration { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . evaluation Duration } 
func ( rule * Recording Rule ) Set Evaluation Timestamp ( ts time . Time ) { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) rule . evaluation Timestamp = ts } 
func ( rule * Recording Rule ) Get Evaluation Timestamp ( ) time . Time { rule . mtx . Lock ( ) defer rule . mtx . Unlock ( ) return rule . evaluation Timestamp } 
func ( rule * Recording Rule ) HTMLSnippet ( path Prefix string ) template . HTML { rule Expr : = rule . vector . String ( ) labels : = make ( map [ string ] string , len ( rule . labels ) ) for _ , l : = range rule . labels { labels [ l . Name ] = template . HTMLEscape String ( l . Value ) } r : = rulefmt . Rule { Record : fmt . Sprintf ( ` <a href = " %s " > %s < /a > ` , path Prefix + strutil . Table Link For Expression ( rule . name ) , rule . name ) , Expr : fmt . Sprintf ( ` <a href = " %s " > %s < /a > ` , path Prefix + strutil . Table Link For Expression ( rule Expr ) , template . HTMLEscape String ( rule Expr ) ) , Labels : labels , } byt , err : = yaml . Marshal ( r ) if err ! = nil { return template . HTML ( fmt . Sprintf ( " " , template . HTMLEscape String ( err . Error ( ) ) ) ) } return template . HTML ( byt ) } 
func new EWMARate ( alpha float 6 4 , interval time . Duration ) * ewma Rate { return & ewma Rate { alpha : alpha , interval : interval , } } 
func ( r * ewma Rate ) rate ( ) float 6 4 { r . mutex . Lock ( ) defer r . mutex . Unlock ( ) return r . last Rate } 
func ( r * ewma Rate ) tick ( ) { new Events : = atomic . Load Int 6 4 ( & r . new Events ) atomic . Add Int 6 4 ( & r . new Events , - new Events ) instant Rate : = float 6 4 ( new Events ) / r . interval . Seconds ( ) r . mutex . Lock ( ) defer r . mutex . Unlock ( ) if r . init { r . last Rate + = r . alpha * ( instant Rate - r . last Rate ) } else { r . init = true r . last Rate = instant Rate } } 
func ( r * ewma Rate ) incr ( incr int 6 4 ) { atomic . Add Int 6 4 ( & r . new Events , incr ) } 
func New Node ( l log . Logger , inf cache . Shared Informer ) * Node { if l = = nil { l = log . New Nop Logger ( ) } n : = & Node { logger : l , informer : inf , store : inf . Get Store ( ) , queue : workqueue . New Named ( " " ) } n . informer . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , Delete Func : func ( o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , Update Func : func ( _ , o interface { } ) { event Count . With Label Values ( " " , " " ) . Inc ( ) n . enqueue ( o ) } , } ) return n } 
func ( n * Node ) Run ( ctx context . Context , ch chan < - [ ] * targetgroup . Group ) { defer n . queue . Shut Down ( ) if ! cache . Wait For Cache Sync ( ctx . Done ( ) , n . informer . Has Synced ) { level . Error ( n . logger ) . Log ( " " , " " ) return } go func ( ) { for n . process ( ctx , ch ) { } } ( ) } 
func node Address ( node * apiv 1 . Node ) ( string , map [ apiv 1 . Node Address Type ] [ ] string , error ) { m : = map [ apiv 1 . Node Address Type ] [ ] string { } for _ , a : = range node . Status . Addresses { m [ a . Type ] = append ( m [ a . Type ] , a . Address ) } if addresses , ok : = m [ apiv 1 . Node Internal IP ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok : = m [ apiv 1 . Node External IP ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok : = m [ apiv 1 . Node Address Type ( Node Legacy Host IP ) ] ; ok { return addresses [ 0 ] , m , nil } if addresses , ok : = m [ apiv 1 . Node Host Name ] ; ok { return addresses [ 0 ] , m , nil } return " " , m , errors . New ( " " ) } 
func Check Config ( files . . . string ) int { failed : = false for _ , f : = range files { rule Files , err : = check Config ( f ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) failed = true } else { fmt . Printf ( " \n " , len ( rule Files ) ) } fmt . Println ( ) for _ , rf : = range rule Files { if n , err : = check Rules ( rf ) ; err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) failed = true } else { fmt . Printf ( " \n " , n ) } fmt . Println ( ) } } if failed { return 1 } return 0 } 
func Check Rules ( files . . . string ) int { failed : = false for _ , f : = range files { if n , errs : = check Rules ( f ) ; errs ! = nil { fmt . Fprintln ( os . Stderr , " " ) for _ , e : = range errs { fmt . Fprintln ( os . Stderr , e . Error ( ) ) } failed = true } else { fmt . Printf ( " \n " , n ) } fmt . Println ( ) } if failed { return 1 } return 0 } 
func Check Metrics ( ) int { l : = promlint . New ( os . Stdin ) problems , err : = l . Lint ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } for _ , p : = range problems { fmt . Fprintln ( os . Stderr , p . Metric , p . Text ) } if len ( problems ) > 0 { return 3 } return 0 } 
func Query Instant ( url , query string , p printer ) int { config : = api . Config { Address : url , } if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Minute ) val , err : = api . Query ( ctx , query , time . Now ( ) ) cancel ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . print Value ( val ) return 0 } 
func Query Range ( url , query , start , end string , step time . Duration , p printer ) int { config : = api . Config { Address : url , } if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } var stime , etime time . Time if end = = " " { etime = time . Now ( ) } else { etime , err = parse Time ( end ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } } if start = = " " { stime = etime . Add ( - 5 * time . Minute ) } else { stime , err = parse Time ( start ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) } } if ! stime . Before ( etime ) { fmt . Fprintln ( os . Stderr , " " ) } if step = = 0 { resolution : = math . Max ( math . Floor ( etime . Sub ( stime ) . Seconds ( ) / 2 5 0 ) , 1 ) } r : = v 1 . Range { Start : stime , End : etime , Step : step } ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Minute ) val , err : = api . Query Range ( ctx , query , r ) cancel ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . print Value ( val ) return 0 } 
func Query Series ( url * url . URL , matchers [ ] string , start , end string , p printer ) int { config : = api . Config { Address : url . String ( ) , } if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } max Time = time . Now ( ) . Add ( 9 9 9 9 * time . Hour ) ) var stime , etime time . Time if start = = " " { stime = min Time } else { stime , err = parse Time ( start ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) } } if end = = " " { etime = max Time } else { etime , err = parse Time ( end ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) } } ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Minute ) val , err : = api . Series ( ctx , matchers , stime , etime ) cancel ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . print Series ( val ) return 0 } 
func Query Labels ( url * url . URL , name string , p printer ) int { config : = api . Config { Address : url . String ( ) , } if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Minute ) val , err : = api . Label Values ( ctx , name ) cancel ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , " " , err ) return 1 } p . print Label Values ( val ) return 0 } 
func ( tg * Group ) Unmarshal YAML ( unmarshal func ( interface { } ) error ) error { g : = struct { Targets [ ] string `yaml : "targets " ` Labels model . Label Set `yaml : "labels " ` } { } if err : = unmarshal ( & g ) ; err ! = nil { return err } tg . Targets = make ( [ ] model . Label Set , 0 , len ( g . Targets ) ) for _ , t : = range g . Targets { tg . Targets = append ( tg . Targets , model . Label Set { model . Address Label : model . Label Value ( t ) , } ) } tg . Labels = g . Labels return nil } 
func ( tg Group ) Marshal YAML ( ) ( interface { } , error ) { g : = & struct { Targets [ ] string `yaml : "targets " ` Labels model . Label Set `yaml : "labels ,omitempty " ` } { Targets : make ( [ ] string , 0 , len ( tg . Targets ) ) , Labels : tg . Labels , } for _ , t : = range tg . Targets { g . Targets = append ( g . Targets , string ( t [ model . Address Label ] ) ) } return g , nil } 
func ( tg * Group ) Unmarshal JSON ( b [ ] byte ) error { g : = struct { Targets [ ] string `json : "targets " ` Labels model . Label Set `json : "labels " ` } { } dec : = json . New Decoder ( bytes . New Reader ( b ) ) dec . Disallow Unknown Fields ( ) if err : = dec . Decode ( & g ) ; err ! = nil { return err } tg . Targets = make ( [ ] model . Label Set , 0 , len ( g . Targets ) ) for _ , t : = range g . Targets { tg . Targets = append ( tg . Targets , model . Label Set { model . Address Label : model . Label Value ( t ) , } ) } tg . Labels = g . Labels return nil } 
func New Stream Reader ( sw Stream Writer ) io . Read Closer { pc : = fasthttputil . New Pipe Conns ( ) pw : = pc . Conn 1 ( ) pr : = pc . Conn 2 ( ) var bw * bufio . Writer v : = stream Writer Buf Pool . Get ( ) if v = = nil { bw = bufio . New Writer ( pw ) } else { bw = v . ( * bufio . Writer ) bw . Reset ( pw ) } go func ( ) { sw ( bw ) bw . Flush ( ) pw . Close ( ) stream Writer Buf Pool . Put ( bw ) } ( ) return pr } 
func Expvar Handler ( ctx * fasthttp . Request Ctx ) { expvar Handler Calls . Add ( 1 ) ctx . Response . Reset ( ) r , err : = get Expvar Regexp ( ctx ) if err ! = nil { expvar Regexp Errors . Add ( 1 ) fmt . Fprintf ( ctx , " " , err ) ctx . Set Status Code ( fasthttp . Status Bad Request ) return } fmt . Fprintf ( ctx , " \n " ) first : = true expvar . Do ( func ( kv expvar . Key Value ) { if r . Match String ( kv . Key ) { if ! first { fmt . Fprintf ( ctx , " \n " ) } first = false fmt . Fprintf ( ctx , " \t " , kv . Key , kv . Value ) } } ) fmt . Fprintf ( ctx , " \n \n " ) ctx . Set Content Type ( " " ) } 
func Status Message ( status Code int ) string { s : = status Messages [ status Code ] if s = = " " { s = " " } return s } 
func ( a * Args ) Copy To ( dst * Args ) { dst . Reset ( ) dst . args = copy Args ( dst . args , a . args ) } 
func ( a * Args ) Visit All ( f func ( key , value [ ] byte ) ) { visit Args ( a . args , f ) } 
func ( a * Args ) Parse ( s string ) { a . buf = append ( a . buf [ : 0 ] , s . . . ) a . Parse Bytes ( a . buf ) } 
func ( a * Args ) Parse Bytes ( b [ ] byte ) { a . Reset ( ) var s args Scanner s . b = b var kv * args KV a . args , kv = alloc Arg ( a . args ) for s . next ( kv ) { if len ( kv . key ) > 0 | | len ( kv . value ) > 0 { a . args , kv = alloc Arg ( a . args ) } } a . args = release Arg ( a . args ) } 
func ( a * Args ) Query String ( ) [ ] byte { a . buf = a . Append Bytes ( a . buf [ : 0 ] ) return a . buf } 
func ( a * Args ) Sort ( f func ( x , y [ ] byte ) int ) { sort . Slice Stable ( a . args , func ( i , j int ) bool { n : = f ( a . args [ i ] . key , a . args [ j ] . key ) if n = = 0 { return f ( a . args [ i ] . value , a . args [ j ] . value ) = = - 1 } return n = = - 1 } ) } 
func ( a * Args ) Append Bytes ( dst [ ] byte ) [ ] byte { for i , n : = 0 , len ( a . args ) ; i < n ; i + + { kv : = & a . args [ i ] dst = Append Quoted Arg ( dst , kv . key ) if ! kv . no Value { dst = append ( dst , ' = ' ) if len ( kv . value ) > 0 { dst = Append Quoted Arg ( dst , kv . value ) } } if i + 1 < n { dst = append ( dst , ' & ' ) } } return dst } 
func ( a * Args ) Write To ( w io . Writer ) ( int 6 4 , error ) { n , err : = w . Write ( a . Query String ( ) ) return int 6 4 ( n ) , err } 
func ( a * Args ) Del ( key string ) { a . args = del All Args ( a . args , key ) } 
func ( a * Args ) Del Bytes ( key [ ] byte ) { a . args = del All Args ( a . args , b 2s ( key ) ) } 
func ( a * Args ) Add ( key , value string ) { a . args = append Arg ( a . args , key , value , args Has Value ) } 
func ( a * Args ) Add Bytes K ( key [ ] byte , value string ) { a . args = append Arg ( a . args , b 2s ( key ) , value , args Has Value ) } 
func ( a * Args ) Add Bytes KV ( key , value [ ] byte ) { a . args = append Arg ( a . args , b 2s ( key ) , b 2s ( value ) , args Has Value ) } 
func ( a * Args ) Add No Value ( key string ) { a . args = append Arg ( a . args , key , " " , args No Value ) } 
func ( a * Args ) Add Bytes KNo Value ( key [ ] byte ) { a . args = append Arg ( a . args , b 2s ( key ) , " " , args No Value ) } 
func ( a * Args ) Set ( key , value string ) { a . args = set Arg ( a . args , key , value , args Has Value ) } 
func ( a * Args ) Set Bytes V ( key string , value [ ] byte ) { a . args = set Arg ( a . args , key , b 2s ( value ) , args Has Value ) } 
func ( a * Args ) Set Bytes KV ( key , value [ ] byte ) { a . args = set Arg Bytes ( a . args , key , value , args Has Value ) } 
func ( a * Args ) Set No Value ( key string ) { a . args = set Arg ( a . args , key , " " , args No Value ) } 
func ( a * Args ) Set Bytes KNo Value ( key [ ] byte ) { a . args = set Arg ( a . args , b 2s ( key ) , " " , args No Value ) } 
func ( a * Args ) Peek ( key string ) [ ] byte { return peek Arg Str ( a . args , key ) } 
func ( a * Args ) Peek Bytes ( key [ ] byte ) [ ] byte { return peek Arg Bytes ( a . args , key ) } 
func ( a * Args ) Peek Multi ( key string ) [ ] [ ] byte { var values [ ] [ ] byte a . Visit All ( func ( k , v [ ] byte ) { if string ( k ) = = key { values = append ( values , v ) } } ) return values } 
func ( a * Args ) Peek Multi Bytes ( key [ ] byte ) [ ] [ ] byte { return a . Peek Multi ( b 2s ( key ) ) } 
func ( a * Args ) Has ( key string ) bool { return has Arg ( a . args , key ) } 
func ( a * Args ) Has Bytes ( key [ ] byte ) bool { return has Arg ( a . args , b 2s ( key ) ) } 
func ( a * Args ) Get Uint ( key string ) ( int , error ) { value : = a . Peek ( key ) if len ( value ) = = 0 { return - 1 , Err No Arg Value } return Parse Uint ( value ) } 
func ( a * Args ) Set Uint ( key string , value int ) { bb : = bytebufferpool . Get ( ) bb . B = Append Uint ( bb . B [ : 0 ] , value ) a . Set Bytes V ( key , bb . B ) bytebufferpool . Put ( bb ) } 
func ( a * Args ) Set Uint Bytes ( key [ ] byte , value int ) { a . Set Uint ( b 2s ( key ) , value ) } 
func ( a * Args ) Get Uint Or Zero ( key string ) int { n , err : = a . Get Uint ( key ) if err ! = nil { n = 0 } return n } 
func ( a * Args ) Get Ufloat ( key string ) ( float 6 4 , error ) { value : = a . Peek ( key ) if len ( value ) = = 0 { return - 1 , Err No Arg Value } return Parse Ufloat ( value ) } 
func ( a * Args ) Get Ufloat Or Zero ( key string ) float 6 4 { f , err : = a . Get Ufloat ( key ) if err ! = nil { f = 0 } return f } 
func ( a * Args ) Get Bool ( key string ) bool { switch b 2s ( a . Peek ( key ) ) { default : return false } } 
func decode Arg Append No Plus ( dst , src [ ] byte ) [ ] byte { if bytes . Index Byte ( src , ' % ' ) < 0 { } if c = = ' % ' { if i + 2 > = len ( src ) { return append ( dst , src [ i : ] . . . ) } x 2 : = hex 2int Table [ src [ i + 2 ] ] x 1 : = hex 2int Table [ src [ i + 1 ] ] if x 1 = = 1 6 | | x 2 = = 1 6 { dst = append ( dst , ' % ' ) } else { dst = append ( dst , x 1 < < 4 | x 2 ) i + = 2 } } else { dst = append ( dst , c ) } } return dst } 
func Append HTMLEscape ( dst [ ] byte , s string ) [ ] byte { if strings . Index Byte ( s , ' < ' ) < 0 & & strings . Index Byte ( s , ' > ' ) < 0 & & strings . Index Byte ( s , ' " ' ) < 0 & & strings . Index Byte ( s , ' \ ' ' ) < 0 { } var sub string for i , n : = 0 , len ( s ) ; i < n ; i + + { sub = " " switch s [ i ] { case ' < ' : sub = " " case ' > ' : sub = " " case ' " ' : sub = " " case ' \ ' ' : sub = " " } if len ( sub ) > 0 { dst = append ( dst , s [ prev : i ] . . . ) dst = append ( dst , sub . . . ) prev = i + 1 } } return append ( dst , s [ prev : ] . . . ) } 
func Append IPv 4 ( dst [ ] byte , ip net . IP ) [ ] byte { ip = ip . To 4 ( ) if ip = = nil { return append ( dst , " " . . . ) } dst = Append Uint ( dst , int ( ip [ 0 ] ) ) for i : = 1 ; i < 4 ; i + + { dst = append ( dst , ' . ' ) dst = Append Uint ( dst , int ( ip [ i ] ) ) } return dst } 
func Parse IPv 4 ( dst net . IP , ip Str [ ] byte ) ( net . IP , error ) { if len ( ip Str ) = = 0 { return dst , err Empty IPStr } if len ( dst ) < net . IPv 4len { dst = make ( [ ] byte , net . IPv 4len ) } copy ( dst , net . IPv 4zero ) dst = dst . To 4 ( ) if dst = = nil { panic ( " " ) } b : = ip Str for i : = 0 ; i < 3 ; i + + { n : = bytes . Index Byte ( b , ' . ' ) if n < 0 { return dst , fmt . Errorf ( " " , ip Str ) } v , err : = Parse Uint ( b [ : n ] ) if err ! = nil { return dst , fmt . Errorf ( " " , ip Str , err ) } if v > 2 5 5 { return dst , fmt . Errorf ( " " , ip Str , v ) } dst [ i ] = byte ( v ) b = b [ n + 1 : ] } v , err : = Parse Uint ( b ) if err ! = nil { return dst , fmt . Errorf ( " " , ip Str , err ) } if v > 2 5 5 { return dst , fmt . Errorf ( " " , ip Str , v ) } dst [ 3 ] = byte ( v ) return dst , nil } 
func Append HTTPDate ( dst [ ] byte , date time . Time ) [ ] byte { dst = date . In ( time . UTC ) . Append Format ( dst , time . RFC 1 1 2 3 ) copy ( dst [ len ( dst ) - 3 : ] , str GMT ) return dst } 
func Parse HTTPDate ( date [ ] byte ) ( time . Time , error ) { return time . Parse ( time . RFC 1 1 2 3 , b 2s ( date ) ) } 
func Parse Uint ( buf [ ] byte ) ( int , error ) { v , n , err : = parse Uint Buf ( buf ) if n ! = len ( buf ) { return - 1 , err Unexpected Trailing Char } return v , err } 
func Parse Ufloat ( buf [ ] byte ) ( float 6 4 , error ) { if len ( buf ) = = 0 { return - 1 , err Empty Float } b : = buf var v uint 6 4 var offset = 1 . 0 var point Found bool for i , c : = range b { if c < ' 0 ' | | c > ' 9 ' { if c = = ' . ' { if point Found { return - 1 , err Duplicate Float Point } point Found = true continue } if c = = 'e ' | | c = = 'E ' { if i + 1 > = len ( b ) { return - 1 , err Unexpected Float End } b = b [ i + 1 : ] minus : = - 1 switch b [ 0 ] { case ' + ' : b = b [ 1 : ] minus = 1 case ' - ' : b = b [ 1 : ] default : minus = 1 } vv , err : = Parse Uint ( b ) if err ! = nil { return - 1 , err Invalid Float Exponent } return float 6 4 ( v ) * offset * math . Pow 1 0 ( minus * int ( vv ) ) , nil } return - 1 , err Unexpected Float Char } v = 1 0 * v + uint 6 4 ( c - ' 0 ' ) if point Found { offset / = 1 0 } } return float 6 4 ( v ) * offset , nil } 
func Append Quoted Arg ( dst , src [ ] byte ) [ ] byte { for _ , c : = range src { } else { dst = append ( dst , ' % ' , hex Char Upper ( c > > 4 ) , hex Char Upper ( c & 1 5 ) ) } } return dst } 
func ( u * URI ) Copy To ( dst * URI ) { dst . Reset ( ) dst . path Original = append ( dst . path Original [ : 0 ] , u . path Original . . . ) dst . scheme = append ( dst . scheme [ : 0 ] , u . scheme . . . ) dst . path = append ( dst . path [ : 0 ] , u . path . . . ) dst . query String = append ( dst . query String [ : 0 ] , u . query String . . . ) dst . hash = append ( dst . hash [ : 0 ] , u . hash . . . ) dst . host = append ( dst . host [ : 0 ] , u . host . . . ) u . query Args . Copy To ( & dst . query Args ) dst . parsed Query Args = u . parsed Query Args } 
func ( u * URI ) Set Hash ( hash string ) { u . hash = append ( u . hash [ : 0 ] , hash . . . ) } 
func ( u * URI ) Set Hash Bytes ( hash [ ] byte ) { u . hash = append ( u . hash [ : 0 ] , hash . . . ) } 
func ( u * URI ) Set Query String ( query String string ) { u . query String = append ( u . query String [ : 0 ] , query String . . . ) u . parsed Query Args = false } 
func ( u * URI ) Set Query String Bytes ( query String [ ] byte ) { u . query String = append ( u . query String [ : 0 ] , query String . . . ) u . parsed Query Args = false } 
func ( u * URI ) Path ( ) [ ] byte { path : = u . path if len ( path ) = = 0 { path = str Slash } return path } 
func ( u * URI ) Set Path ( path string ) { u . path Original = append ( u . path Original [ : 0 ] , path . . . ) u . path = normalize Path ( u . path , u . path Original ) } 
func ( u * URI ) Set Path Bytes ( path [ ] byte ) { u . path Original = append ( u . path Original [ : 0 ] , path . . . ) u . path = normalize Path ( u . path , u . path Original ) } 
func ( u * URI ) Scheme ( ) [ ] byte { scheme : = u . scheme if len ( scheme ) = = 0 { scheme = str HTTP } return scheme } 
func ( u * URI ) Set Scheme ( scheme string ) { u . scheme = append ( u . scheme [ : 0 ] , scheme . . . ) lowercase Bytes ( u . scheme ) } 
func ( u * URI ) Set Scheme Bytes ( scheme [ ] byte ) { u . scheme = append ( u . scheme [ : 0 ] , scheme . . . ) lowercase Bytes ( u . scheme ) } 
func ( u * URI ) Reset ( ) { u . path Original = u . path Original [ : 0 ] u . scheme = u . scheme [ : 0 ] u . path = u . path [ : 0 ] u . query String = u . query String [ : 0 ] u . hash = u . hash [ : 0 ] u . host = u . host [ : 0 ] u . query Args . Reset ( ) u . parsed Query Args = false } 
func ( u * URI ) Host ( ) [ ] byte { if len ( u . host ) = = 0 & & u . h ! = nil { u . host = append ( u . host [ : 0 ] , u . h . Host ( ) . . . ) lowercase Bytes ( u . host ) u . h = nil } return u . host } 
func ( u * URI ) Set Host ( host string ) { u . host = append ( u . host [ : 0 ] , host . . . ) lowercase Bytes ( u . host ) } 
func ( u * URI ) Set Host Bytes ( host [ ] byte ) { u . host = append ( u . host [ : 0 ] , host . . . ) lowercase Bytes ( u . host ) } 
func ( u * URI ) Parse ( host , uri [ ] byte ) { u . parse ( host , uri , nil ) } 
func ( u * URI ) Request URI ( ) [ ] byte { dst : = append Quoted Path ( u . request URI [ : 0 ] , u . Path ( ) ) if u . query Args . Len ( ) > 0 { dst = append ( dst , ' ? ' ) dst = u . query Args . Append Bytes ( dst ) } else if len ( u . query String ) > 0 { dst = append ( dst , ' ? ' ) dst = append ( dst , u . query String . . . ) } if len ( u . hash ) > 0 { dst = append ( dst , ' # ' ) dst = append ( dst , u . hash . . . ) } u . request URI = dst return u . request URI } 
func ( u * URI ) Last Path Segment ( ) [ ] byte { path : = u . Path ( ) n : = bytes . Last Index Byte ( path , ' / ' ) if n < 0 { return path } return path [ n + 1 : ] } 
func ( u * URI ) Update Bytes ( new URI [ ] byte ) { u . request URI = u . update Bytes ( new URI , u . request URI ) } 
func ( u * URI ) Full URI ( ) [ ] byte { u . full URI = u . Append Bytes ( u . full URI [ : 0 ] ) return u . full URI } 
func ( u * URI ) Append Bytes ( dst [ ] byte ) [ ] byte { dst = u . append Scheme Host ( dst ) return append ( dst , u . Request URI ( ) . . . ) } 
func ( u * URI ) Write To ( w io . Writer ) ( int 6 4 , error ) { n , err : = w . Write ( u . Full URI ( ) ) return int 6 4 ( n ) , err } 
func New Writer ( dst W io . Writer , new Writer New Writer Func ) Writer { w : = & writer { dst W : dst W , } w . zw = new Writer ( & w . xw ) return w } 
func New Pipe Conns ( ) * Pipe Conns { ch 1 : = make ( chan * byte Buffer , 4 ) ch 2 : = make ( chan * byte Buffer , 4 ) pc : = & Pipe Conns { stop Ch : make ( chan struct { } ) , } pc . c 1 . r Ch = ch 1 pc . c 1 . w Ch = ch 2 pc . c 2 . r Ch = ch 2 pc . c 2 . w Ch = ch 1 pc . c 1 . pc = pc pc . c 2 . pc = pc return pc } 
func ( pc * Pipe Conns ) Close ( ) error { pc . stop Ch Lock . Lock ( ) select { case < - pc . stop Ch : default : close ( pc . stop Ch ) } pc . stop Ch Lock . Unlock ( ) return nil } 
func Do ( req * Request , resp * Response ) error { return default Client . Do ( req , resp ) } 
func Do Timeout ( req * Request , resp * Response , timeout time . Duration ) error { return default Client . Do Timeout ( req , resp , timeout ) } 
func Do Deadline ( req * Request , resp * Response , deadline time . Time ) error { return default Client . Do Deadline ( req , resp , deadline ) } 
func Get ( dst [ ] byte , url string ) ( status Code int , body [ ] byte , err error ) { return default Client . Get ( dst , url ) } 
func Get Timeout ( dst [ ] byte , url string , timeout time . Duration ) ( status Code int , body [ ] byte , err error ) { return default Client . Get Timeout ( dst , url , timeout ) } 
func Get Deadline ( dst [ ] byte , url string , deadline time . Time ) ( status Code int , body [ ] byte , err error ) { return default Client . Get Deadline ( dst , url , deadline ) } 
func Post ( dst [ ] byte , url string , post Args * Args ) ( status Code int , body [ ] byte , err error ) { return default Client . Post ( dst , url , post Args ) } 
func ( c * Client ) Get Timeout ( dst [ ] byte , url string , timeout time . Duration ) ( status Code int , body [ ] byte , err error ) { return client Get URLTimeout ( dst , url , timeout , c ) } 
func ( c * Client ) Get Deadline ( dst [ ] byte , url string , deadline time . Time ) ( status Code int , body [ ] byte , err error ) { return client Get URLDeadline ( dst , url , deadline , c ) } 
func ( c * Client ) Post ( dst [ ] byte , url string , post Args * Args ) ( status Code int , body [ ] byte , err error ) { return client Post URL ( dst , url , post Args , c ) } 
func ( c * Client ) Do Timeout ( req * Request , resp * Response , timeout time . Duration ) error { return client Do Timeout ( req , resp , timeout , c ) } 
func ( c * Client ) Do Deadline ( req * Request , resp * Response , deadline time . Time ) error { return client Do Deadline ( req , resp , deadline , c ) } 
func ( c * Client ) Do ( req * Request , resp * Response ) error { uri : = req . URI ( ) host : = uri . Host ( ) is TLS : = false scheme : = uri . Scheme ( ) if bytes . Equal ( scheme , str HTTPS ) { is TLS = true } else if ! bytes . Equal ( scheme , str HTTP ) { return fmt . Errorf ( " " , scheme ) } start Cleaner : = false c . m Lock . Lock ( ) m : = c . m if is TLS { m = c . ms } if m = = nil { m = make ( map [ string ] * Host Client ) if is TLS { c . ms = m } else { c . m = m } } hc : = m [ string ( host ) ] if hc = = nil { hc = & Host Client { Addr : add Missing Port ( string ( host ) , is TLS ) , Name : c . Name , No Default User Agent Header : c . No Default User Agent Header , Dial : c . Dial , Dial Dual Stack : c . Dial Dual Stack , Is TLS : is TLS , TLSConfig : c . TLSConfig , Max Conns : c . Max Conns Per Host , Max Idle Conn Duration : c . Max Idle Conn Duration , Max Idemponent Call Attempts : c . Max Idemponent Call Attempts , Read Buffer Size : c . Read Buffer Size , Write Buffer Size : c . Write Buffer Size , Read Timeout : c . Read Timeout , Write Timeout : c . Write Timeout , Max Response Body Size : c . Max Response Body Size , Disable Header Names Normalizing : c . Disable Header Names Normalizing , } m [ string ( host ) ] = hc if len ( m ) = = 1 { start Cleaner = true } } c . m Lock . Unlock ( ) if start Cleaner { go c . m Cleaner ( m ) } return hc . Do ( req , resp ) } 
func ( c * Host Client ) Last Use Time ( ) time . Time { n : = atomic . Load Uint 3 2 ( & c . last Use Time ) return time . Unix ( start Time Unix + int 6 4 ( n ) , 0 ) } 
func ( c * Host Client ) Get ( dst [ ] byte , url string ) ( status Code int , body [ ] byte , err error ) { return client Get URL ( dst , url , c ) } 
func Acquire Request ( ) * Request { v : = request Pool . Get ( ) if v = = nil { return & Request { } } return v . ( * Request ) } 
func Acquire Response ( ) * Response { v : = response Pool . Get ( ) if v = = nil { return & Response { } } return v . ( * Response ) } 
func ( c * Host Client ) Do ( req * Request , resp * Response ) error { var err error var retry bool max Attempts : = c . Max Idemponent Call Attempts if max Attempts < = 0 { max Attempts = Default Max Idemponent Call Attempts } attempts : = 0 atomic . Add Int 3 2 ( & c . pending Requests , 1 ) for { retry , err = c . do ( req , resp ) if err = = nil | | ! retry { break } if ! is Idempotent ( req ) { } } attempts + + if attempts > = max Attempts { break } } atomic . Add Int 3 2 ( & c . pending Requests , - 1 ) if err = = io . EOF { err = Err Connection Closed } return err } 
func ( c * Pipeline Client ) Do Timeout ( req * Request , resp * Response , timeout time . Duration ) error { return c . Do Deadline ( req , resp , time . Now ( ) . Add ( timeout ) ) } 
func ( c * Pipeline Client ) Do Deadline ( req * Request , resp * Response , deadline time . Time ) error { return c . get Conn Client ( ) . Do Deadline ( req , resp , deadline ) } 
func ( c * Pipeline Client ) Do ( req * Request , resp * Response ) error { return c . get Conn Client ( ) . Do ( req , resp ) } 
func ( c * Pipeline Client ) Pending Requests ( ) int { c . conn Clients Lock . Lock ( ) n : = 0 for _ , cc : = range c . conn Clients { n + = cc . Pending Requests ( ) } c . conn Clients Lock . Unlock ( ) return n } 
func ( cc * LBClient ) Do Deadline ( req * Request , resp * Response , deadline time . Time ) error { return cc . get ( ) . Do Deadline ( req , resp , deadline ) } 
func ( cc * LBClient ) Do Timeout ( req * Request , resp * Response , timeout time . Duration ) error { deadline : = time . Now ( ) . Add ( timeout ) return cc . get ( ) . Do Deadline ( req , resp , deadline ) } 
func ( cc * LBClient ) Do ( req * Request , resp * Response ) error { timeout : = cc . Timeout if timeout < = 0 { timeout = Default LBClient Timeout } return cc . Do Timeout ( req , resp , timeout ) } 
func Serve Conn ( c net . Conn , handler Request Handler ) error { v : = server Pool . Get ( ) if v = = nil { v = & Server { } } s : = v . ( * Server ) s . Handler = handler err : = s . Serve Conn ( c ) s . Handler = nil server Pool . Put ( v ) return err } 
func Serve ( ln net . Listener , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Serve ( ln ) } 
func Serve TLS ( ln net . Listener , cert File , key File string , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Serve TLS ( ln , cert File , key File ) } 
func Serve TLSEmbed ( ln net . Listener , cert Data , key Data [ ] byte , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Serve TLSEmbed ( ln , cert Data , key Data ) } 
func Listen And Serve ( addr string , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Listen And Serve ( addr ) } 
func Listen And Serve UNIX ( addr string , mode os . File Mode , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Listen And Serve UNIX ( addr , mode ) } 
func Listen And Serve TLS ( addr , cert File , key File string , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Listen And Serve TLS ( addr , cert File , key File ) } 
func Listen And Serve TLSEmbed ( addr string , cert Data , key Data [ ] byte , handler Request Handler ) error { s : = & Server { Handler : handler , } return s . Listen And Serve TLSEmbed ( addr , cert Data , key Data ) } 
func Timeout Handler ( h Request Handler , timeout time . Duration , msg string ) Request Handler { if timeout < = 0 { return h } return func ( ctx * Request Ctx ) { concurrency Ch : = ctx . s . concurrency Ch select { case concurrency Ch < - struct { } { } : default : ctx . Error ( msg , Status Too Many Requests ) return } ch : = ctx . timeout Ch if ch = = nil { ch = make ( chan struct { } , 1 ) ctx . timeout Ch = ch } go func ( ) { h ( ctx ) ch < - struct { } { } < - concurrency Ch } ( ) ctx . timeout Timer = init Timer ( ctx . timeout Timer , timeout ) select { case < - ch : case < - ctx . timeout Timer . C : ctx . Timeout Error ( msg ) } stop Timer ( ctx . timeout Timer ) } } 
func Compress Handler Level ( h Request Handler , level int ) Request Handler { return func ( ctx * Request Ctx ) { h ( ctx ) if ctx . Request . Header . Has Accept Encoding Bytes ( str Gzip ) { ctx . Response . gzip Body ( level ) } else if ctx . Request . Header . Has Accept Encoding Bytes ( str Deflate ) { ctx . Response . deflate Body ( level ) } } } 
func ( ctx * Request Ctx ) Set User Value ( key string , value interface { } ) { ctx . user Values . Set ( key , value ) } 
func ( ctx * Request Ctx ) Set User Value Bytes ( key [ ] byte , value interface { } ) { ctx . user Values . Set Bytes ( key , value ) } 
func ( ctx * Request Ctx ) Visit User Values ( visitor func ( [ ] byte , interface { } ) ) { for i , n : = 0 , len ( ctx . user Values ) ; i < n ; i + + { kv : = & ctx . user Values [ i ] visitor ( kv . key , kv . value ) } } 
func ( ctx * Request Ctx ) Is TLS ( ) bool { return ok } 
func ( ctx * Request Ctx ) TLSConnection State ( ) * tls . Connection State { tls Conn , ok : = ctx . c . ( conn TLSer ) if ! ok { return nil } state : = tls Conn . Connection State ( ) return & state } 
func ( ctx * Request Ctx ) String ( ) string { return fmt . Sprintf ( " " , ctx . ID ( ) , ctx . Local Addr ( ) , ctx . Remote Addr ( ) , ctx . Request . Header . Method ( ) , ctx . URI ( ) . Full URI ( ) ) } 
func ( ctx * Request Ctx ) Set Content Type ( content Type string ) { ctx . Response . Header . Set Content Type ( content Type ) } 
func ( ctx * Request Ctx ) Set Content Type Bytes ( content Type [ ] byte ) { ctx . Response . Header . Set Content Type Bytes ( content Type ) } 
func ( ctx * Request Ctx ) Form File ( key string ) ( * multipart . File Header , error ) { mf , err : = ctx . Multipart Form ( ) if err ! = nil { return nil , err } if mf . File = = nil { return nil , err } fhh : = mf . File [ key ] if fhh = = nil { return nil , Err Missing File } return fhh [ 0 ] , nil } 
func Save Multipart File ( fh * multipart . File Header , path string ) error { f , err : = fh . Open ( ) if err ! = nil { return err } if ff , ok : = f . ( * os . File ) ; ok { } } if err ! = nil { return err } } defer f . Close ( ) ff , err : = os . Create ( path ) if err ! = nil { return err } defer ff . Close ( ) _ , err = copy Zero Alloc ( ff , f ) return err } 
func ( ctx * Request Ctx ) Form Value ( key string ) [ ] byte { v : = ctx . Query Args ( ) . Peek ( key ) if len ( v ) > 0 { return v } v = ctx . Post Args ( ) . Peek ( key ) if len ( v ) > 0 { return v } mf , err : = ctx . Multipart Form ( ) if err = = nil & & mf . Value ! = nil { vv : = mf . Value [ key ] if len ( vv ) > 0 { return [ ] byte ( vv [ 0 ] ) } } return nil } 
func ( ctx * Request Ctx ) Remote Addr ( ) net . Addr { if ctx . c = = nil { return zero TCPAddr } addr : = ctx . c . Remote Addr ( ) if addr = = nil { return zero TCPAddr } return addr } 
func ( ctx * Request Ctx ) Error ( msg string , status Code int ) { ctx . Response . Reset ( ) ctx . Set Status Code ( status Code ) ctx . Set Content Type Bytes ( default Content Type ) ctx . Set Body String ( msg ) } 
func ( ctx * Request Ctx ) Success ( content Type string , body [ ] byte ) { ctx . Set Content Type ( content Type ) ctx . Set Body ( body ) } 
func ( ctx * Request Ctx ) Success String ( content Type , body string ) { ctx . Set Content Type ( content Type ) ctx . Set Body String ( body ) } 
func ( ctx * Request Ctx ) Redirect ( uri string , status Code int ) { u : = Acquire URI ( ) ctx . URI ( ) . Copy To ( u ) u . Update ( uri ) ctx . redirect ( u . Full URI ( ) , status Code ) Release URI ( u ) } 
func ( ctx * Request Ctx ) Redirect Bytes ( uri [ ] byte , status Code int ) { s : = b 2s ( uri ) ctx . Redirect ( s , status Code ) } 
func ( ctx * Request Ctx ) If Modified Since ( last Modified time . Time ) bool { if Mod Str : = ctx . Request . Header . peek ( str If Modified Since ) if len ( if Mod Str ) = = 0 { return true } if Mod , err : = Parse HTTPDate ( if Mod Str ) if err ! = nil { return true } last Modified = last Modified . Truncate ( time . Second ) return if Mod . Before ( last Modified ) } 
func ( ctx * Request Ctx ) Not Found ( ) { ctx . Response . Reset ( ) ctx . Set Status Code ( Status Not Found ) ctx . Set Body String ( " " ) } 
func ( ctx * Request Ctx ) Write ( p [ ] byte ) ( int , error ) { ctx . Response . Append Body ( p ) return len ( p ) , nil } 
func ( ctx * Request Ctx ) Write String ( s string ) ( int , error ) { ctx . Response . Append Body String ( s ) return len ( s ) , nil } 
func ( ctx * Request Ctx ) Set Body Stream ( body Stream io . Reader , body Size int ) { ctx . Response . Set Body Stream ( body Stream , body Size ) } 
func ( ctx * Request Ctx ) Logger ( ) Logger { if ctx . logger . ctx = = nil { ctx . logger . ctx = ctx } if ctx . logger . logger = = nil { ctx . logger . logger = ctx . s . logger ( ) } return & ctx . logger } 
func ( ctx * Request Ctx ) Timeout Error With Code ( msg string , status Code int ) { var resp Response resp . Set Status Code ( status Code ) resp . Set Body String ( msg ) ctx . Timeout Error With Response ( & resp ) } 
func ( ctx * Request Ctx ) Timeout Error With Response ( resp * Response ) { resp Copy : = & Response { } resp . Copy To ( resp Copy ) ctx . timeout Response = resp Copy } 
func ( s * Server ) Next Proto ( key string , nph Serve Handler ) { if s . next Protos = = nil { s . next Protos = make ( map [ string ] Serve Handler ) } s . config TLS ( ) s . tls Config . Next Protos = append ( s . tls Config . Next Protos , key ) s . next Protos [ key ] = nph } 
func ( s * Server ) Listen And Serve ( addr string ) error { ln , err : = net . Listen ( " " , addr ) if err ! = nil { return err } if s . TCPKeepalive { if tcpln , ok : = ln . ( * net . TCPListener ) ; ok { return s . Serve ( tcp Keepalive Listener { TCPListener : tcpln , keepalive Period : s . TCPKeepalive Period , } ) } } return s . Serve ( ln ) } 
func ( s * Server ) Listen And Serve UNIX ( addr string , mode os . File Mode ) error { if err : = os . Remove ( addr ) ; err ! = nil & & ! os . Is Not Exist ( err ) { return fmt . Errorf ( " " , addr , err ) } ln , err : = net . Listen ( " " , addr ) if err ! = nil { return err } if err = os . Chmod ( addr , mode ) ; err ! = nil { return fmt . Errorf ( " " , mode , addr , err ) } return s . Serve ( ln ) } 
func ( s * Server ) Listen And Serve TLS ( addr , cert File , key File string ) error { ln , err : = net . Listen ( " " , addr ) if err ! = nil { return err } if s . TCPKeepalive { if tcpln , ok : = ln . ( * net . TCPListener ) ; ok { return s . Serve TLS ( tcp Keepalive Listener { TCPListener : tcpln , keepalive Period : s . TCPKeepalive Period , } , cert File , key File ) } } return s . Serve TLS ( ln , cert File , key File ) } 
func ( s * Server ) Listen And Serve TLSEmbed ( addr string , cert Data , key Data [ ] byte ) error { ln , err : = net . Listen ( " " , addr ) if err ! = nil { return err } if s . TCPKeepalive { if tcpln , ok : = ln . ( * net . TCPListener ) ; ok { return s . Serve TLSEmbed ( tcp Keepalive Listener { TCPListener : tcpln , keepalive Period : s . TCPKeepalive Period , } , cert Data , key Data ) } } return s . Serve TLSEmbed ( ln , cert Data , key Data ) } 
func ( s * Server ) Serve TLS ( ln net . Listener , cert File , key File string ) error { err : = s . Append Cert ( cert File , key File ) if err ! = nil & & err ! = err No Cert Or Key Provided { return err } if s . tls Config = = nil { return err No Cert Or Key Provided } s . tls Config . Build Name To Certificate ( ) return s . Serve ( tls . New Listener ( ln , s . tls Config ) , ) } 
func ( s * Server ) Serve TLSEmbed ( ln net . Listener , cert Data , key Data [ ] byte ) error { err : = s . Append Cert Embed ( cert Data , key Data ) if err ! = nil & & err ! = err No Cert Or Key Provided { return err } if s . tls Config = = nil { return err No Cert Or Key Provided } s . tls Config . Build Name To Certificate ( ) return s . Serve ( tls . New Listener ( ln , s . tls Config ) , ) } 
func ( s * Server ) Append Cert ( cert File , key File string ) error { if len ( cert File ) = = 0 & & len ( key File ) = = 0 { return err No Cert Or Key Provided } cert , err : = tls . Load X 5 0 9Key Pair ( cert File , key File ) if err ! = nil { return fmt . Errorf ( " " , cert File , key File , err ) } s . config TLS ( ) s . tls Config . Certificates = append ( s . tls Config . Certificates , cert ) return nil } 
func ( s * Server ) Append Cert Embed ( cert Data , key Data [ ] byte ) error { if len ( cert Data ) = = 0 & & len ( key Data ) = = 0 { return err No Cert Or Key Provided } cert , err : = tls . X 5 0 9Key Pair ( cert Data , key Data ) if err ! = nil { return fmt . Errorf ( " " , len ( cert Data ) , len ( key Data ) , err ) } s . config TLS ( ) s . tls Config . Certificates = append ( s . tls Config . Certificates , cert ) return nil } 
func ( s * Server ) Serve ( ln net . Listener ) error { var last Overflow Error Time time . Time var last Per IPError Time time . Time var c net . Conn var err error s . mu . Lock ( ) { if s . ln ! = nil { s . mu . Unlock ( ) return Err Already Serving } s . ln = ln s . done = make ( chan struct { } ) } s . mu . Unlock ( ) max Workers Count : = s . get Concurrency ( ) s . concurrency Ch = make ( chan struct { } , max Workers Count ) wp : = & worker Pool { Worker Func : s . serve Conn , Max Workers Count : max Workers Count , Log All Errors : s . Log All Errors , Logger : s . logger ( ) , conn State : s . set State , } wp . Start ( ) defer atomic . Add Int 3 2 ( & s . open , - 1 ) for { if c , err = accept Conn ( s , ln , & last Per IPError Time ) ; err ! = nil { wp . Stop ( ) if err = = io . EOF { return nil } return err } s . set State ( c , State New ) atomic . Add Int 3 2 ( & s . open , 1 ) if ! wp . Serve ( c ) { atomic . Add Int 3 2 ( & s . open , - 1 ) s . write Fast Error ( c , Status Service Unavailable , " " ) c . Close ( ) s . set State ( c , State Closed ) if time . Since ( last Overflow Error Time ) > time . Minute { s . logger ( ) . Printf ( " " + " " , max Workers Count ) last Overflow Error Time = time . Now ( ) } } } c = nil } } 
func ( s * Server ) Shutdown ( ) error { s . mu . Lock ( ) defer s . mu . Unlock ( ) atomic . Store Int 3 2 ( & s . stop , 1 ) defer atomic . Store Int 3 2 ( & s . stop , 0 ) if s . ln = = nil { return nil } if err : = s . ln . Close ( ) ; err ! = nil { return err } if s . done ! = nil { close ( s . done ) } } } s . ln = nil return nil } 
func ( s * Server ) Serve Conn ( c net . Conn ) error { if s . Max Conns Per IP > 0 { pic : = wrap Per IPConn ( s , c ) if pic = = nil { return Err Per IPConn Limit } c = pic } n : = atomic . Add Uint 3 2 ( & s . concurrency , 1 ) if n > uint 3 2 ( s . get Concurrency ( ) ) { atomic . Add Uint 3 2 ( & s . concurrency , ^ uint 3 2 ( 0 ) ) s . write Fast Error ( c , Status Service Unavailable , " " ) c . Close ( ) return Err Concurrency Limit } atomic . Add Int 3 2 ( & s . open , 1 ) err : = s . serve Conn ( c ) atomic . Add Uint 3 2 ( & s . concurrency , ^ uint 3 2 ( 0 ) ) if err ! = err Hijacked { err 1 : = c . Close ( ) s . set State ( c , State Closed ) if err = = nil { err = err 1 } } else { err = nil s . set State ( c , State Hijacked ) } return err } 
func ( ctx * Request Ctx ) Init 2 ( conn net . Conn , logger Logger , reduce Memory Usage bool ) { ctx . c = conn ctx . logger . logger = logger ctx . conn ID = next Conn ID ( ) ctx . s = fake Server ctx . conn Request Num = 0 ctx . conn Time = time . Now ( ) keep Body Buffer : = ! reduce Memory Usage ctx . Request . keep Body Buffer = keep Body Buffer ctx . Response . keep Body Buffer = keep Body Buffer } 
func ( ctx * Request Ctx ) Init ( req * Request , remote Addr net . Addr , logger Logger ) { if remote Addr = = nil { remote Addr = zero TCPAddr } c : = & fake Addrer { laddr : zero TCPAddr , raddr : remote Addr , } if logger = = nil { logger = default Logger } ctx . Init 2 ( c , logger , true ) req . Copy To ( & ctx . Request ) } 
func ( ctx * Request Ctx ) Err ( ) error { select { case < - ctx . s . done : return context . Canceled default : return nil } } 
func ( ctx * Request Ctx ) Value ( key interface { } ) interface { } { if key String , ok : = key . ( string ) ; ok { return ctx . User Value ( key String ) } return nil } 
func Append Gzip Bytes Level ( dst , src [ ] byte , level int ) [ ] byte { w : = & byte Slice Writer { dst } Write Gzip Level ( w , src , level ) return w . b } 
func Write Gzip Level ( w io . Writer , p [ ] byte , level int ) ( int , error ) { switch w . ( type ) { case * byte Slice Writer , * bytes . Buffer , * bytebufferpool . Byte Buffer : stackless Write Gzip ( ctx ) return len ( p ) , nil default : zw : = acquire Stackless Gzip Writer ( w , level ) n , err : = zw . Write ( p ) release Stackless Gzip Writer ( zw , level ) return n , err } } 
func Write Gzip ( w io . Writer , p [ ] byte ) ( int , error ) { return Write Gzip Level ( w , p , Compress Default Compression ) } 
func Write Gunzip ( w io . Writer , p [ ] byte ) ( int , error ) { r : = & byte Slice Reader { p } zr , err : = acquire Gzip Reader ( r ) if err ! = nil { return 0 , err } n , err : = copy Zero Alloc ( w , zr ) release Gzip Reader ( zr ) nn : = int ( n ) if int 6 4 ( nn ) ! = n { return 0 , fmt . Errorf ( " " , n ) } return nn , err } 
func Append Gunzip Bytes ( dst , src [ ] byte ) ( [ ] byte , error ) { w : = & byte Slice Writer { dst } _ , err : = Write Gunzip ( w , src ) return w . b , err } 
func Append Deflate Bytes Level ( dst , src [ ] byte , level int ) [ ] byte { w : = & byte Slice Writer { dst } Write Deflate Level ( w , src , level ) return w . b } 
func Write Deflate Level ( w io . Writer , p [ ] byte , level int ) ( int , error ) { switch w . ( type ) { case * byte Slice Writer , * bytes . Buffer , * bytebufferpool . Byte Buffer : stackless Write Deflate ( ctx ) return len ( p ) , nil default : zw : = acquire Stackless Deflate Writer ( w , level ) n , err : = zw . Write ( p ) release Stackless Deflate Writer ( zw , level ) return n , err } } 
func Write Deflate ( w io . Writer , p [ ] byte ) ( int , error ) { return Write Deflate Level ( w , p , Compress Default Compression ) } 
func Write Inflate ( w io . Writer , p [ ] byte ) ( int , error ) { r : = & byte Slice Reader { p } zr , err : = acquire Flate Reader ( r ) if err ! = nil { return 0 , err } n , err : = copy Zero Alloc ( w , zr ) release Flate Reader ( zr ) nn : = int ( n ) if int 6 4 ( nn ) ! = n { return 0 , fmt . Errorf ( " " , n ) } return nn , err } 
func Append Inflate Bytes ( dst , src [ ] byte ) ( [ ] byte , error ) { w : = & byte Slice Writer { dst } _ , err : = Write Inflate ( w , src ) return w . b , err } 
func New Func ( f func ( ctx interface { } ) ) func ( ctx interface { } ) bool { if f = = nil { panic ( " " ) } func Work Ch : = make ( chan * func Work , runtime . GOMAXPROCS ( - 1 ) * 2 0 4 8 ) once Init : = func ( ) { n : = runtime . GOMAXPROCS ( - 1 ) for i : = 0 ; i < n ; i + + { go func Worker ( func Work Ch , f ) } } var once sync . Once return func ( ctx interface { } ) bool { once . Do ( once Init ) fw : = get Func Work ( ) fw . ctx = ctx select { case func Work Ch < - fw : default : put Func Work ( fw ) return false } < - fw . done put Func Work ( fw ) return true } } 
func ( req * Request ) Set Request URI ( request URI string ) { req . Header . Set Request URI ( request URI ) req . parsed URI = false } 
func ( req * Request ) Set Request URIBytes ( request URI [ ] byte ) { req . Header . Set Request URIBytes ( request URI ) req . parsed URI = false } 
func ( req * Request ) Request URI ( ) [ ] byte { if req . parsed URI { request URI : = req . uri . Request URI ( ) req . Set Request URIBytes ( request URI ) } return req . Header . Request URI ( ) } 
func ( resp * Response ) Send File ( path string ) error { f , err : = os . Open ( path ) if err ! = nil { return err } file Info , err : = f . Stat ( ) if err ! = nil { f . Close ( ) return err } size 6 4 : = file Info . Size ( ) size : = int ( size 6 4 ) if int 6 4 ( size ) ! = size 6 4 { size = - 1 } resp . Header . Set Last Modified ( file Info . Mod Time ( ) ) resp . Set Body Stream ( f , size ) return nil } 
func ( req * Request ) Set Body Stream ( body Stream io . Reader , body Size int ) { req . Reset Body ( ) req . body Stream = body Stream req . Header . Set Content Length ( body Size ) } 
func ( resp * Response ) Set Body Stream ( body Stream io . Reader , body Size int ) { resp . Reset Body ( ) resp . body Stream = body Stream resp . Header . Set Content Length ( body Size ) } 
func ( req * Request ) Set Body Stream Writer ( sw Stream Writer ) { sr : = New Stream Reader ( sw ) req . Set Body Stream ( sr , - 1 ) } 
func ( resp * Response ) Set Body Stream Writer ( sw Stream Writer ) { sr : = New Stream Reader ( sw ) resp . Set Body Stream ( sr , - 1 ) } 
func ( resp * Response ) Body Writer ( ) io . Writer { resp . w . r = resp return & resp . w } 
func ( req * Request ) Body Writer ( ) io . Writer { req . w . r = req return & req . w } 
func ( resp * Response ) Body ( ) [ ] byte { if resp . body Stream ! = nil { body Buf : = resp . body Buffer ( ) body Buf . Reset ( ) _ , err : = copy Zero Alloc ( body Buf , resp . body Stream ) resp . close Body Stream ( ) if err ! = nil { body Buf . Set String ( err . Error ( ) ) } } return resp . body Bytes ( ) } 
func ( req * Request ) Body Write To ( w io . Writer ) error { if req . body Stream ! = nil { _ , err : = copy Zero Alloc ( w , req . body Stream ) req . close Body Stream ( ) return err } if req . only Multipart Form ( ) { return Write Multipart Form ( w , req . multipart Form , req . multipart Form Boundary ) } _ , err : = w . Write ( req . body Bytes ( ) ) return err } 
func ( resp * Response ) Body Write To ( w io . Writer ) error { if resp . body Stream ! = nil { _ , err : = copy Zero Alloc ( w , resp . body Stream ) resp . close Body Stream ( ) return err } _ , err : = w . Write ( resp . body Bytes ( ) ) return err } 
func ( resp * Response ) Append Body String ( s string ) { resp . close Body Stream ( ) resp . body Buffer ( ) . Write String ( s ) } 
func ( resp * Response ) Set Body String ( body string ) { resp . close Body Stream ( ) body Buf : = resp . body Buffer ( ) body Buf . Reset ( ) body Buf . Write String ( body ) } 
func ( resp * Response ) Reset Body ( ) { resp . body Raw = nil resp . close Body Stream ( ) if resp . body ! = nil { if resp . keep Body Buffer { resp . body . Reset ( ) } else { response Body Pool . Put ( resp . body ) resp . body = nil } } } 
func ( resp * Response ) Set Body Raw ( body [ ] byte ) { resp . Reset Body ( ) resp . body Raw = body } 
func ( resp * Response ) Release Body ( size int ) { resp . body Raw = nil if cap ( resp . body . B ) > size { resp . close Body Stream ( ) resp . body = nil } } 
func ( req * Request ) Release Body ( size int ) { if cap ( req . body . B ) > size { req . close Body Stream ( ) req . body = nil } } 
func ( resp * Response ) Swap Body ( body [ ] byte ) [ ] byte { bb : = resp . body Buffer ( ) if resp . body Stream ! = nil { bb . Reset ( ) _ , err : = copy Zero Alloc ( bb , resp . body Stream ) resp . close Body Stream ( ) if err ! = nil { bb . Reset ( ) bb . Set String ( err . Error ( ) ) } } resp . body Raw = nil old Body : = bb . B bb . B = body return old Body } 
func ( req * Request ) Swap Body ( body [ ] byte ) [ ] byte { bb : = req . body Buffer ( ) if req . body Stream ! = nil { bb . Reset ( ) _ , err : = copy Zero Alloc ( bb , req . body Stream ) req . close Body Stream ( ) if err ! = nil { bb . Reset ( ) bb . Set String ( err . Error ( ) ) } } old Body : = bb . B bb . B = body return old Body } 
func ( req * Request ) Body ( ) [ ] byte { if req . body Stream ! = nil { body Buf : = req . body Buffer ( ) body Buf . Reset ( ) _ , err : = copy Zero Alloc ( body Buf , req . body Stream ) req . close Body Stream ( ) if err ! = nil { body Buf . Set String ( err . Error ( ) ) } } else if req . only Multipart Form ( ) { body , err : = marshal Multipart Form ( req . multipart Form , req . multipart Form Boundary ) if err ! = nil { return [ ] byte ( err . Error ( ) ) } return body } return req . body Bytes ( ) } 
func ( req * Request ) Append Body String ( s string ) { req . Remove Multipart Form Files ( ) req . close Body Stream ( ) req . body Buffer ( ) . Write String ( s ) } 
func ( req * Request ) Set Body String ( body string ) { req . Remove Multipart Form Files ( ) req . close Body Stream ( ) req . body Buffer ( ) . Set String ( body ) } 
func ( req * Request ) Reset Body ( ) { req . Remove Multipart Form Files ( ) req . close Body Stream ( ) if req . body ! = nil { if req . keep Body Buffer { req . body . Reset ( ) } else { request Body Pool . Put ( req . body ) req . body = nil } } } 
func ( req * Request ) Copy To ( dst * Request ) { req . copy To Skip Body ( dst ) if req . body ! = nil { dst . body Buffer ( ) . Set ( req . body . B ) } else if dst . body ! = nil { dst . body . Reset ( ) } } 
func ( resp * Response ) Copy To ( dst * Response ) { resp . copy To Skip Body ( dst ) if resp . body Raw ! = nil { dst . body Raw = resp . body Raw if dst . body ! = nil { dst . body . Reset ( ) } } else if resp . body ! = nil { dst . body Buffer ( ) . Set ( resp . body . B ) } else if dst . body ! = nil { dst . body . Reset ( ) } } 
func ( req * Request ) Multipart Form ( ) ( * multipart . Form , error ) { if req . multipart Form ! = nil { return req . multipart Form , nil } req . multipart Form Boundary = string ( req . Header . Multipart Form Boundary ( ) ) if len ( req . multipart Form Boundary ) = = 0 { return nil , Err No Multipart Form } ce : = req . Header . peek ( str Content Encoding ) body : = req . body Bytes ( ) if bytes . Equal ( ce , str Gzip ) { if body , err = Append Gunzip Bytes ( nil , body ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } else if len ( ce ) > 0 { return nil , fmt . Errorf ( " " , ce ) } f , err : = read Multipart Form ( bytes . New Reader ( body ) , req . multipart Form Boundary , len ( body ) , len ( body ) ) if err ! = nil { return nil , err } req . multipart Form = f return f , nil } 
func Write Multipart Form ( w io . Writer , f * multipart . Form , boundary string ) error { } mw : = multipart . New Writer ( w ) if err : = mw . Set Boundary ( boundary ) ; err ! = nil { return fmt . Errorf ( " " , boundary , err ) } } } } if err ! = nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } fh , err : = fv . Open ( ) if err ! = nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } if _ , err = copy Zero Alloc ( vw , fh ) ; err ! = nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } if err = fh . Close ( ) ; err ! = nil { return fmt . Errorf ( " " , k , fv . Filename , err ) } } } if err : = mw . Close ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( req * Request ) Remove Multipart Form Files ( ) { if req . multipart Form ! = nil { req . multipart Form = nil } req . multipart Form Boundary = " " } 
func ( resp * Response ) Reset ( ) { resp . Header . Reset ( ) resp . reset Skip Header ( ) resp . Skip Body = false resp . raddr = nil resp . laddr = nil } 
func ( req * Request ) Read ( r * bufio . Reader ) error { return req . Read Limit Body ( r , 0 ) } 
func ( req * Request ) Read Limit Body ( r * bufio . Reader , max Body Size int ) error { req . reset Skip Header ( ) return req . read Limit Body ( r , max Body Size , false ) } 
func ( req * Request ) May Continue ( ) bool { return bytes . Equal ( req . Header . peek ( str Expect ) , str 1 0 0Continue ) } 
func ( req * Request ) Continue Read Body ( r * bufio . Reader , max Body Size int ) error { var err error content Length : = req . Header . real Content Length ( ) if content Length > 0 { if max Body Size > 0 & & content Length > max Body Size { return Err Body Too Large } if len ( req . multipart Form Boundary ) > 0 & & len ( req . Header . peek ( str Content Encoding ) ) = = 0 { req . multipart Form , err = read Multipart Form ( r , req . multipart Form Boundary , content Length , default Max In Memory File Size ) if err ! = nil { req . Reset ( ) } return err } } if content Length = = - 2 { return nil } body Buf : = req . body Buffer ( ) body Buf . Reset ( ) body Buf . B , err = read Body ( r , content Length , max Body Size , body Buf . B ) if err ! = nil { req . Reset ( ) return err } req . Header . Set Content Length ( len ( body Buf . B ) ) return nil } 
func ( resp * Response ) Read ( r * bufio . Reader ) error { return resp . Read Limit Body ( r , 0 ) } 
func ( resp * Response ) Read Limit Body ( r * bufio . Reader , max Body Size int ) error { resp . reset Skip Header ( ) err : = resp . Header . Read ( r ) if err ! = nil { return err } if resp . Header . Status Code ( ) = = Status Continue { } } if ! resp . must Skip Body ( ) { body Buf : = resp . body Buffer ( ) body Buf . Reset ( ) body Buf . B , err = read Body ( r , resp . Header . Content Length ( ) , max Body Size , body Buf . B ) if err ! = nil { return err } resp . Header . Set Content Length ( len ( body Buf . B ) ) } return nil } 
func ( req * Request ) Write To ( w io . Writer ) ( int 6 4 , error ) { return write Bufio ( req , w ) } 
func ( resp * Response ) Write To ( w io . Writer ) ( int 6 4 , error ) { return write Bufio ( resp , w ) } 
func ( req * Request ) Write ( w * bufio . Writer ) error { if len ( req . Header . Host ( ) ) = = 0 | | req . parsed URI { uri : = req . URI ( ) host : = uri . Host ( ) if len ( host ) = = 0 { return err Request Host Required } req . Header . Set Host Bytes ( host ) req . Header . Set Request URIBytes ( uri . Request URI ( ) ) } if req . body Stream ! = nil { return req . write Body Stream ( w ) } body : = req . body Bytes ( ) var err error if req . only Multipart Form ( ) { body , err = marshal Multipart Form ( req . multipart Form , req . multipart Form Boundary ) if err ! = nil { return fmt . Errorf ( " " , err ) } req . Header . Set Multipart Form Boundary ( req . multipart Form Boundary ) } has Body : = ! req . Header . ignore Body ( ) if has Body { if len ( body ) = = 0 { body = req . post Args . Query String ( ) } req . Header . Set Content Length ( len ( body ) ) } if err = req . Header . Write ( w ) ; err ! = nil { return err } if has Body { _ , err = w . Write ( body ) } else if len ( body ) > 0 { return fmt . Errorf ( " " , body ) } return err } 
func ( resp * Response ) Write Gzip ( w * bufio . Writer ) error { return resp . Write Gzip Level ( w , Compress Default Compression ) } 
func ( resp * Response ) Write Gzip Level ( w * bufio . Writer , level int ) error { if err : = resp . gzip Body ( level ) ; err ! = nil { return err } return resp . Write ( w ) } 
func ( resp * Response ) Write Deflate ( w * bufio . Writer ) error { return resp . Write Deflate Level ( w , Compress Default Compression ) } 
func ( resp * Response ) Write Deflate Level ( w * bufio . Writer , level int ) error { if err : = resp . deflate Body ( level ) ; err ! = nil { return err } return resp . Write ( w ) } 
func ( resp * Response ) Write ( w * bufio . Writer ) error { send Body : = ! resp . must Skip Body ( ) if resp . body Stream ! = nil { return resp . write Body Stream ( w , send Body ) } body : = resp . body Bytes ( ) body Len : = len ( body ) if send Body | | body Len > 0 { resp . Header . Set Content Length ( body Len ) } if err : = resp . Header . Write ( w ) ; err ! = nil { return err } if send Body { if _ , err : = w . Write ( body ) ; err ! = nil { return err } } return nil } 
func ( h * Response Header ) Set Content Range ( start Pos , end Pos , content Length int ) { b : = h . buf KV . value [ : 0 ] b = append ( b , str Bytes . . . ) b = append ( b , ' ' ) b = Append Uint ( b , start Pos ) b = append ( b , ' - ' ) b = Append Uint ( b , end Pos ) b = append ( b , ' / ' ) b = Append Uint ( b , content Length ) h . buf KV . value = b h . Set Canonical ( str Content Range , h . buf KV . value ) } 
func ( h * Request Header ) Set Byte Range ( start Pos , end Pos int ) { h . parse Raw Headers ( ) b : = h . buf KV . value [ : 0 ] b = append ( b , str Bytes . . . ) b = append ( b , ' = ' ) if start Pos > = 0 { b = Append Uint ( b , start Pos ) } else { end Pos = - start Pos } b = append ( b , ' - ' ) if end Pos > = 0 { b = Append Uint ( b , end Pos ) } h . buf KV . value = b h . Set Canonical ( str Range , h . buf KV . value ) } 
func ( h * Response Header ) Set Last Modified ( t time . Time ) { h . buf KV . value = Append HTTPDate ( h . buf KV . value [ : 0 ] , t ) h . Set Canonical ( str Last Modified , h . buf KV . value ) } 
func ( h * Response Header ) Reset Connection Close ( ) { if h . connection Close { h . connection Close = false h . h = del All Args Bytes ( h . h , str Connection ) } } 
func ( h * Request Header ) Reset Connection Close ( ) { h . parse Raw Headers ( ) if h . connection Close { h . connection Close = false h . h = del All Args Bytes ( h . h , str Connection ) } } 
func ( h * Request Header ) Connection Upgrade ( ) bool { h . parse Raw Headers ( ) return has Header Value ( h . Peek ( " " ) , str Upgrade ) } 
func ( h * Response Header ) Peek Cookie ( key string ) [ ] byte { return peek Arg Str ( h . cookies , key ) } 
func ( h * Response Header ) Set Content Length ( content Length int ) { if h . must Skip Content Length ( ) { return } h . content Length = content Length if content Length > = 0 { h . content Length Bytes = Append Uint ( h . content Length Bytes [ : 0 ] , content Length ) h . h = del All Args Bytes ( h . h , str Transfer Encoding ) } else { h . content Length Bytes = h . content Length Bytes [ : 0 ] value : = str Chunked if content Length = = - 2 { h . Set Connection Close ( ) value = str Identity } h . h = set Arg Bytes ( h . h , str Transfer Encoding , value , args Has Value ) } } 
func ( h * Request Header ) Set Content Length ( content Length int ) { h . parse Raw Headers ( ) h . content Length = content Length if content Length > = 0 { h . content Length Bytes = Append Uint ( h . content Length Bytes [ : 0 ] , content Length ) h . h = del All Args Bytes ( h . h , str Transfer Encoding ) } else { h . content Length Bytes = h . content Length Bytes [ : 0 ] h . h = set Arg Bytes ( h . h , str Transfer Encoding , str Chunked , args Has Value ) } } 
func ( h * Response Header ) Content Type ( ) [ ] byte { content Type : = h . content Type if ! h . no Default Content Type & & len ( h . content Type ) = = 0 { content Type = default Content Type } return content Type } 
func ( h * Response Header ) Set Content Type ( content Type string ) { h . content Type = append ( h . content Type [ : 0 ] , content Type . . . ) } 
func ( h * Response Header ) Set Content Type Bytes ( content Type [ ] byte ) { h . content Type = append ( h . content Type [ : 0 ] , content Type . . . ) } 
func ( h * Response Header ) Set Server ( server string ) { h . server = append ( h . server [ : 0 ] , server . . . ) } 
func ( h * Response Header ) Set Server Bytes ( server [ ] byte ) { h . server = append ( h . server [ : 0 ] , server . . . ) } 
func ( h * Request Header ) Set Content Type ( content Type string ) { h . parse Raw Headers ( ) h . content Type = append ( h . content Type [ : 0 ] , content Type . . . ) } 
func ( h * Request Header ) Set Content Type Bytes ( content Type [ ] byte ) { h . parse Raw Headers ( ) h . content Type = append ( h . content Type [ : 0 ] , content Type . . . ) } 
func ( h * Request Header ) Set Multipart Form Boundary ( boundary string ) { h . parse Raw Headers ( ) b : = h . buf KV . value [ : 0 ] b = append ( b , str Multipart Form Data . . . ) b = append ( b , ' ; ' , ' ' ) b = append ( b , str Boundary . . . ) b = append ( b , ' = ' ) b = append ( b , boundary . . . ) h . buf KV . value = b h . Set Content Type Bytes ( h . buf KV . value ) } 
func ( h * Request Header ) Set Multipart Form Boundary Bytes ( boundary [ ] byte ) { h . parse Raw Headers ( ) b : = h . buf KV . value [ : 0 ] b = append ( b , str Multipart Form Data . . . ) b = append ( b , ' ; ' , ' ' ) b = append ( b , str Boundary . . . ) b = append ( b , ' = ' ) b = append ( b , boundary . . . ) h . buf KV . value = b h . Set Content Type Bytes ( h . buf KV . value ) } 
func ( h * Request Header ) Multipart Form Boundary ( ) [ ] byte { b : = h . Content Type ( ) if ! bytes . Has Prefix ( b , str Multipart Form Data ) { return nil } b = b [ len ( str Multipart Form Data ) : ] if len ( b ) = = 0 | | b [ 0 ] ! = ' ; ' { return nil } var n int for len ( b ) > 0 { n + + for len ( b ) > n & & b [ n ] = = ' ' { n + + } b = b [ n : ] if ! bytes . Has Prefix ( b , str Boundary ) { if n = bytes . Index Byte ( b , ' ; ' ) ; n < 0 { return nil } continue } b = b [ len ( str Boundary ) : ] if len ( b ) = = 0 | | b [ 0 ] ! = ' = ' { return nil } b = b [ 1 : ] if n = bytes . Index Byte ( b , ' ; ' ) ; n > = 0 { b = b [ : n ] } if len ( b ) > 1 & & b [ 0 ] = = ' " ' & & b [ len ( b ) - 1 ] = = ' " ' { b = b [ 1 : len ( b ) - 1 ] } return b } return nil } 
func ( h * Request Header ) Host ( ) [ ] byte { if len ( h . host ) > 0 { return h . host } if ! h . raw Headers Parsed { if len ( host ) > 0 { h . host = append ( h . host [ : 0 ] , host . . . ) return h . host } } return h . host } 
func ( h * Request Header ) Set Host ( host string ) { h . parse Raw Headers ( ) h . host = append ( h . host [ : 0 ] , host . . . ) } 
func ( h * Request Header ) Set Host Bytes ( host [ ] byte ) { h . parse Raw Headers ( ) h . host = append ( h . host [ : 0 ] , host . . . ) } 
func ( h * Request Header ) Set User Agent ( user Agent string ) { h . parse Raw Headers ( ) h . user Agent = append ( h . user Agent [ : 0 ] , user Agent . . . ) } 
func ( h * Request Header ) Set User Agent Bytes ( user Agent [ ] byte ) { h . parse Raw Headers ( ) h . user Agent = append ( h . user Agent [ : 0 ] , user Agent . . . ) } 
func ( h * Request Header ) Method ( ) [ ] byte { if len ( h . method ) = = 0 { return str Get } return h . method } 
func ( h * Request Header ) Set Method ( method string ) { h . method = append ( h . method [ : 0 ] , method . . . ) } 
func ( h * Request Header ) Set Method Bytes ( method [ ] byte ) { h . method = append ( h . method [ : 0 ] , method . . . ) } 
func ( h * Request Header ) Request URI ( ) [ ] byte { request URI : = h . request URI if len ( request URI ) = = 0 { request URI = str Slash } return request URI } 
func ( h * Request Header ) Set Request URI ( request URI string ) { h . request URI = append ( h . request URI [ : 0 ] , request URI . . . ) } 
func ( h * Request Header ) Set Request URIBytes ( request URI [ ] byte ) { h . request URI = append ( h . request URI [ : 0 ] , request URI . . . ) } 
func ( h * Request Header ) Has Accept Encoding ( accept Encoding string ) bool { h . buf KV . value = append ( h . buf KV . value [ : 0 ] , accept Encoding . . . ) return h . Has Accept Encoding Bytes ( h . buf KV . value ) } 
func ( h * Request Header ) Has Accept Encoding Bytes ( accept Encoding [ ] byte ) bool { ae : = h . peek ( str Accept Encoding ) n : = bytes . Index ( ae , accept Encoding ) if n < 0 { return false } b : = ae [ n + len ( accept Encoding ) : ] if len ( b ) > 0 & & b [ 0 ] ! = ' , ' { return false } if n = = 0 { return true } return ae [ n - 1 ] = = ' ' } 
func ( h * Response Header ) Len ( ) int { n : = 0 h . Visit All ( func ( k , v [ ] byte ) { n + + } ) return n } 
func ( h * Response Header ) Reset ( ) { h . disable Normalizing = false h . no Default Content Type = false h . reset Skip Normalize ( ) } 
func ( h * Response Header ) Copy To ( dst * Response Header ) { dst . Reset ( ) dst . disable Normalizing = h . disable Normalizing dst . no HTTP 1 1 = h . no HTTP 1 1 dst . connection Close = h . connection Close dst . no Default Content Type = h . no Default Content Type dst . status Code = h . status Code dst . content Length = h . content Length dst . content Length Bytes = append ( dst . content Length Bytes [ : 0 ] , h . content Length Bytes . . . ) dst . content Type = append ( dst . content Type [ : 0 ] , h . content Type . . . ) dst . server = append ( dst . server [ : 0 ] , h . server . . . ) dst . h = copy Args ( dst . h , h . h ) dst . cookies = copy Args ( dst . cookies , h . cookies ) } 
func ( h * Request Header ) Copy To ( dst * Request Header ) { dst . Reset ( ) dst . disable Normalizing = h . disable Normalizing dst . no HTTP 1 1 = h . no HTTP 1 1 dst . connection Close = h . connection Close dst . content Length = h . content Length dst . content Length Bytes = append ( dst . content Length Bytes [ : 0 ] , h . content Length Bytes . . . ) dst . method = append ( dst . method [ : 0 ] , h . method . . . ) dst . request URI = append ( dst . request URI [ : 0 ] , h . request URI . . . ) dst . host = append ( dst . host [ : 0 ] , h . host . . . ) dst . content Type = append ( dst . content Type [ : 0 ] , h . content Type . . . ) dst . user Agent = append ( dst . user Agent [ : 0 ] , h . user Agent . . . ) dst . h = copy Args ( dst . h , h . h ) dst . cookies = copy Args ( dst . cookies , h . cookies ) dst . cookies Collected = h . cookies Collected dst . raw Headers = append ( dst . raw Headers [ : 0 ] , h . raw Headers . . . ) dst . raw Headers Parsed = h . raw Headers Parsed dst . raw Headers Copy = append ( dst . raw Headers Copy [ : 0 ] , h . raw Headers Copy . . . ) } 
func ( h * Response Header ) Visit All ( f func ( key , value [ ] byte ) ) { if len ( h . content Length Bytes ) > 0 { f ( str Content Length , h . content Length Bytes ) } content Type : = h . Content Type ( ) if len ( content Type ) > 0 { f ( str Content Type , content Type ) } server : = h . Server ( ) if len ( server ) > 0 { f ( str Server , server ) } if len ( h . cookies ) > 0 { visit Args ( h . cookies , func ( k , v [ ] byte ) { f ( str Set Cookie , v ) } ) } visit Args ( h . h , f ) if h . Connection Close ( ) { f ( str Connection , str Close ) } } 
func ( h * Response Header ) Visit All Cookie ( f func ( key , value [ ] byte ) ) { visit Args ( h . cookies , f ) } 
func ( h * Request Header ) Visit All Cookie ( f func ( key , value [ ] byte ) ) { h . parse Raw Headers ( ) h . collect Cookies ( ) visit Args ( h . cookies , f ) } 
func ( h * Request Header ) Visit All ( f func ( key , value [ ] byte ) ) { h . parse Raw Headers ( ) host : = h . Host ( ) if len ( host ) > 0 { f ( str Host , host ) } if len ( h . content Length Bytes ) > 0 { f ( str Content Length , h . content Length Bytes ) } content Type : = h . Content Type ( ) if len ( content Type ) > 0 { f ( str Content Type , content Type ) } user Agent : = h . User Agent ( ) if len ( user Agent ) > 0 { f ( str User Agent , user Agent ) } h . collect Cookies ( ) if len ( h . cookies ) > 0 { h . buf KV . value = append Request Cookie Bytes ( h . buf KV . value [ : 0 ] , h . cookies ) f ( str Cookie , h . buf KV . value ) } visit Args ( h . h , f ) if h . Connection Close ( ) { f ( str Connection , str Close ) } } 
func ( h * Request Header ) Visit All In Order ( f func ( key , value [ ] byte ) ) { h . parse Raw Headers ( ) var s header Scanner s . b = h . raw Headers s . disable Normalizing = h . disable Normalizing for s . next ( ) { if len ( s . key ) > 0 { f ( s . key , s . value ) } } } 
func ( h * Response Header ) Del ( key string ) { k : = get Header Key Bytes ( & h . buf KV , key , h . disable Normalizing ) h . del ( k ) } 
func ( h * Response Header ) Del Bytes ( key [ ] byte ) { h . buf KV . key = append ( h . buf KV . key [ : 0 ] , key . . . ) normalize Header Key ( h . buf KV . key , h . disable Normalizing ) h . del ( h . buf KV . key ) } 
func ( h * Request Header ) Del ( key string ) { h . parse Raw Headers ( ) k : = get Header Key Bytes ( & h . buf KV , key , h . disable Normalizing ) h . del ( k ) } 
func ( h * Request Header ) Del Bytes ( key [ ] byte ) { h . parse Raw Headers ( ) h . buf KV . key = append ( h . buf KV . key [ : 0 ] , key . . . ) normalize Header Key ( h . buf KV . key , h . disable Normalizing ) h . del ( h . buf KV . key ) } 
func ( h * Response Header ) Add Bytes KV ( key , value [ ] byte ) { h . Add ( b 2s ( key ) , b 2s ( value ) ) } 
func ( h * Response Header ) Set ( key , value string ) { init Header KV ( & h . buf KV , key , value , h . disable Normalizing ) h . Set Canonical ( h . buf KV . key , h . buf KV . value ) } 
func ( h * Response Header ) Set Bytes K ( key [ ] byte , value string ) { h . buf KV . value = append ( h . buf KV . value [ : 0 ] , value . . . ) h . Set Bytes KV ( key , h . buf KV . value ) } 
func ( h * Response Header ) Set Canonical ( key , value [ ] byte ) { switch string ( key ) { case " " : h . Set Content Type Bytes ( value ) case " " : h . Set Server Bytes ( value ) case " " : var kv * args KV h . cookies , kv = alloc Arg ( h . cookies ) kv . key = get Cookie Key ( kv . key , value ) kv . value = append ( kv . value [ : 0 ] , value . . . ) case " " : if content Length , err : = parse Content Length ( value ) ; err = = nil { h . content Length = content Length h . content Length Bytes = append ( h . content Length Bytes [ : 0 ] , value . . . ) } case " " : if bytes . Equal ( str Close , value ) { h . Set Connection Close ( ) } else { h . Reset Connection Close ( ) h . h = set Arg Bytes ( h . h , key , value , args Has Value ) } case " " : } } 
func ( h * Response Header ) Set Cookie ( cookie * Cookie ) { h . cookies = set Arg Bytes ( h . cookies , cookie . Key ( ) , cookie . Cookie ( ) , args Has Value ) } 
func ( h * Request Header ) Set Cookie ( key , value string ) { h . parse Raw Headers ( ) h . collect Cookies ( ) h . cookies = set Arg ( h . cookies , key , value , args Has Value ) } 
func ( h * Request Header ) Set Cookie Bytes K ( key [ ] byte , value string ) { h . Set Cookie ( b 2s ( key ) , value ) } 
func ( h * Request Header ) Set Cookie Bytes KV ( key , value [ ] byte ) { h . Set Cookie ( b 2s ( key ) , b 2s ( value ) ) } 
func ( h * Response Header ) Del Client Cookie ( key string ) { h . Del Cookie ( key ) c : = Acquire Cookie ( ) c . Set Key ( key ) c . Set Expire ( Cookie Expire Delete ) h . Set Cookie ( c ) Release Cookie ( c ) } 
func ( h * Response Header ) Del Cookie ( key string ) { h . cookies = del All Args ( h . cookies , key ) } 
func ( h * Request Header ) Del Cookie ( key string ) { h . parse Raw Headers ( ) h . collect Cookies ( ) h . cookies = del All Args ( h . cookies , key ) } 
func ( h * Request Header ) Del All Cookies ( ) { h . parse Raw Headers ( ) h . collect Cookies ( ) h . cookies = h . cookies [ : 0 ] } 
func ( h * Request Header ) Add ( key , value string ) { k : = get Header Key Bytes ( & h . buf KV , key , h . disable Normalizing ) h . h = append Arg ( h . h , b 2s ( k ) , value , args Has Value ) } 
func ( h * Request Header ) Add Bytes K ( key [ ] byte , value string ) { h . Add ( b 2s ( key ) , value ) } 
func ( h * Request Header ) Add Bytes KV ( key , value [ ] byte ) { h . Add ( b 2s ( key ) , b 2s ( value ) ) } 
func ( h * Request Header ) Set Bytes V ( key string , value [ ] byte ) { k : = get Header Key Bytes ( & h . buf KV , key , h . disable Normalizing ) h . Set Canonical ( k , value ) } 
func ( h * Request Header ) Set Bytes KV ( key , value [ ] byte ) { h . buf KV . key = append ( h . buf KV . key [ : 0 ] , key . . . ) normalize Header Key ( h . buf KV . key , h . disable Normalizing ) h . Set Canonical ( h . buf KV . key , value ) } 
func ( h * Request Header ) Set Canonical ( key , value [ ] byte ) { h . parse Raw Headers ( ) switch string ( key ) { case " " : h . Set Host Bytes ( value ) case " " : h . Set Content Type Bytes ( value ) case " " : h . Set User Agent Bytes ( value ) case " " : h . collect Cookies ( ) h . cookies = parse Request Cookies ( h . cookies , value ) case " " : if content Length , err : = parse Content Length ( value ) ; err = = nil { h . content Length = content Length h . content Length Bytes = append ( h . content Length Bytes [ : 0 ] , value . . . ) } case " " : if bytes . Equal ( str Close , value ) { h . Set Connection Close ( ) } else { h . Reset Connection Close ( ) h . h = set Arg Bytes ( h . h , key , value , args Has Value ) } case " " : } } 
func ( h * Response Header ) Peek ( key string ) [ ] byte { k : = get Header Key Bytes ( & h . buf KV , key , h . disable Normalizing ) return h . peek ( k ) } 
func ( h * Response Header ) Peek Bytes ( key [ ] byte ) [ ] byte { h . buf KV . key = append ( h . buf KV . key [ : 0 ] , key . . . ) normalize Header Key ( h . buf KV . key , h . disable Normalizing ) return h . peek ( h . buf KV . key ) } 
func ( h * Request Header ) Cookie ( key string ) [ ] byte { h . parse Raw Headers ( ) h . collect Cookies ( ) return peek Arg Str ( h . cookies , key ) } 
func ( h * Request Header ) Cookie Bytes ( key [ ] byte ) [ ] byte { h . parse Raw Headers ( ) h . collect Cookies ( ) return peek Arg Bytes ( h . cookies , key ) } 
func ( h * Response Header ) Cookie ( cookie * Cookie ) bool { v : = peek Arg Bytes ( h . cookies , cookie . Key ( ) ) if v = = nil { return false } cookie . Parse Bytes ( v ) return true } 
func ( h * Request Header ) Read ( r * bufio . Reader ) error { n : = 1 for { err : = h . try Read ( r , n ) if err = = nil { return nil } if err ! = err Need More { h . reset Skip Normalize ( ) return err } n = r . Buffered ( ) + 1 } } 
func ( h * Response Header ) Header ( ) [ ] byte { h . buf KV . value = h . Append Bytes ( h . buf KV . value [ : 0 ] ) return h . buf KV . value } 
func ( h * Response Header ) Append Bytes ( dst [ ] byte ) [ ] byte { status Code : = h . Status Code ( ) if status Code < 0 { status Code = Status OK } dst = append ( dst , status Line ( status Code ) . . . ) server : = h . Server ( ) if len ( server ) ! = 0 { dst = append Header Line ( dst , str Server , server ) } dst = append Header Line ( dst , str Date , server Date . Load ( ) . ( [ ] byte ) ) } if len ( h . content Length Bytes ) > 0 { dst = append Header Line ( dst , str Content Length , h . content Length Bytes ) } for i , n : = 0 , len ( h . h ) ; i < n ; i + + { kv : = & h . h [ i ] if ! bytes . Equal ( kv . key , str Date ) { dst = append Header Line ( dst , kv . key , kv . value ) } } n : = len ( h . cookies ) if n > 0 { for i : = 0 ; i < n ; i + + { kv : = & h . cookies [ i ] dst = append Header Line ( dst , str Set Cookie , kv . value ) } } if h . Connection Close ( ) { dst = append Header Line ( dst , str Connection , str Close ) } return append ( dst , str CRLF . . . ) } 
func ( h * Request Header ) Write ( w * bufio . Writer ) error { _ , err : = w . Write ( h . Header ( ) ) return err } 
func ( h * Request Header ) Write To ( w io . Writer ) ( int 6 4 , error ) { n , err : = w . Write ( h . Header ( ) ) return int 6 4 ( n ) , err } 
func ( h * Request Header ) Header ( ) [ ] byte { h . buf KV . value = h . Append Bytes ( h . buf KV . value [ : 0 ] ) return h . buf KV . value } 
func ( h * Request Header ) Append Bytes ( dst [ ] byte ) [ ] byte { dst = append ( dst , ' ' ) dst = append ( dst , h . Request URI ( ) . . . ) dst = append ( dst , ' ' ) dst = append ( dst , str HTTP 1 1 . . . ) dst = append ( dst , str CRLF . . . ) if ! h . raw Headers Parsed & & len ( h . raw Headers ) > 0 { return append ( dst , h . raw Headers . . . ) } user Agent : = h . User Agent ( ) if len ( user Agent ) > 0 { dst = append Header Line ( dst , str User Agent , user Agent ) } host : = h . Host ( ) if len ( host ) > 0 { dst = append Header Line ( dst , str Host , host ) } content Type : = h . Content Type ( ) if ! h . ignore Body ( ) { if len ( content Type ) = = 0 { content Type = str Post Args Content Type } dst = append Header Line ( dst , str Content Type , content Type ) if len ( h . content Length Bytes ) > 0 { dst = append Header Line ( dst , str Content Length , h . content Length Bytes ) } } else if len ( content Type ) > 0 { dst = append Header Line ( dst , str Content Type , content Type ) } for i , n : = 0 , len ( h . h ) ; i < n ; i + + { kv : = & h . h [ i ] dst = append Header Line ( dst , kv . key , kv . value ) } if n > 0 { dst = append ( dst , str Cookie . . . ) dst = append ( dst , str Colon Space . . . ) dst = append Request Cookie Bytes ( dst , h . cookies ) dst = append ( dst , str CRLF . . . ) } if h . Connection Close ( ) { dst = append Header Line ( dst , str Connection , str Close ) } return append ( dst , str CRLF . . . ) } 
func Append Normalized Header Key ( dst [ ] byte , key string ) [ ] byte { dst = append ( dst , key . . . ) normalize Header Key ( dst [ len ( dst ) - len ( key ) : ] , false ) return dst } 
func Fasthttp Socks Dialer ( proxy Addr string ) fasthttp . Dial Func { return func ( addr string ) ( net . Conn , error ) { dialer , err : = proxy . SOCKS 5 ( " " , proxy Addr , nil , proxy . Direct ) if err ! = nil { return nil , err } return dialer . Dial ( " " , addr ) } } 
func Serve File Uncompressed ( ctx * Request Ctx , path string ) { ctx . Request . Header . Del Bytes ( str Accept Encoding ) Serve File ( ctx , path ) } 
func Serve File ( ctx * Request Ctx , path string ) { root FSOnce . Do ( func ( ) { root FSHandler = root FS . New Request Handler ( ) } ) if len ( path ) = = 0 | | path [ 0 ] ! = ' / ' { if path , err = filepath . Abs ( path ) ; err ! = nil { ctx . Logger ( ) . Printf ( " " , path , err ) ctx . Error ( " " , Status Internal Server Error ) return } } ctx . Request . Set Request URI ( path ) root FSHandler ( ctx ) } 
func New VHost Path Rewriter ( slashes Count int ) Path Rewrite Func { return func ( ctx * Request Ctx ) [ ] byte { path : = strip Leading Slashes ( ctx . Path ( ) , slashes Count ) host : = ctx . Host ( ) if n : = bytes . Index Byte ( host , ' / ' ) ; n > = 0 { host = nil } if len ( host ) = = 0 { host = str Invalid Host } b : = bytebufferpool . Get ( ) b . B = append ( b . B , ' / ' ) b . B = append ( b . B , host . . . ) b . B = append ( b . B , path . . . ) ctx . URI ( ) . Set Path Bytes ( b . B ) bytebufferpool . Put ( b ) return ctx . Path ( ) } } 
func New Path Slashes Stripper ( slashes Count int ) Path Rewrite Func { return func ( ctx * Request Ctx ) [ ] byte { return strip Leading Slashes ( ctx . Path ( ) , slashes Count ) } } 
func New Path Prefix Stripper ( prefix Size int ) Path Rewrite Func { return func ( ctx * Request Ctx ) [ ] byte { path : = ctx . Path ( ) if len ( path ) > = prefix Size { path = path [ prefix Size : ] } return path } } 
func FSHandler ( root string , strip Slashes int ) Request Handler { fs : = & FS { Root : root , Index Names : [ ] string { " " } , Generate Index Pages : true , Accept Byte Range : true , } if strip Slashes > 0 { fs . Path Rewrite = New Path Slashes Stripper ( strip Slashes ) } return fs . New Request Handler ( ) } 
func ( fs * FS ) New Request Handler ( ) Request Handler { fs . once . Do ( fs . init Request Handler ) return fs . h } 
func Parse Byte Range ( byte Range [ ] byte , content Length int ) ( start Pos , end Pos int , err error ) { b : = byte Range if ! bytes . Has Prefix ( b , str Bytes ) { return 0 , 0 , fmt . Errorf ( " " , byte Range , str Bytes ) } b = b [ len ( str Bytes ) : ] if len ( b ) = = 0 | | b [ 0 ] ! = ' = ' { return 0 , 0 , fmt . Errorf ( " " , byte Range ) } b = b [ 1 : ] n : = bytes . Index Byte ( b , ' - ' ) if n < 0 { return 0 , 0 , fmt . Errorf ( " " , byte Range ) } if n = = 0 { v , err : = Parse Uint ( b [ n + 1 : ] ) if err ! = nil { return 0 , 0 , err } start Pos : = content Length - v if start Pos < 0 { start Pos = 0 } return start Pos , content Length - 1 , nil } if start Pos , err = Parse Uint ( b [ : n ] ) ; err ! = nil { return 0 , 0 , err } if start Pos > = content Length { return 0 , 0 , fmt . Errorf ( " " , content Length - 1 , byte Range ) } b = b [ n + 1 : ] if len ( b ) = = 0 { return start Pos , content Length - 1 , nil } if end Pos , err = Parse Uint ( b ) ; err ! = nil { return 0 , 0 , err } if end Pos > = content Length { end Pos = content Length - 1 } if end Pos < start Pos { return 0 , 0 , fmt . Errorf ( " " , byte Range ) } return start Pos , end Pos , nil } 
func File Last Modified ( path string ) ( time . Time , error ) { f , err : = os . Open ( path ) if err ! = nil { return zero Time , err } file Info , err : = f . Stat ( ) f . Close ( ) if err ! = nil { return zero Time , err } return fs Mod Time ( file Info . Mod Time ( ) ) , nil } 
func ( c * Cookie ) Copy To ( src * Cookie ) { c . Reset ( ) c . key = append ( c . key [ : 0 ] , src . key . . . ) c . value = append ( c . value [ : 0 ] , src . value . . . ) c . expire = src . expire c . max Age = src . max Age c . domain = append ( c . domain [ : 0 ] , src . domain . . . ) c . path = append ( c . path [ : 0 ] , src . path . . . ) c . http Only = src . http Only c . secure = src . secure c . same Site = src . same Site } 
func ( c * Cookie ) Set Path ( path string ) { c . buf = append ( c . buf [ : 0 ] , path . . . ) c . path = normalize Path ( c . path , c . buf ) } 
func ( c * Cookie ) Set Path Bytes ( path [ ] byte ) { c . buf = append ( c . buf [ : 0 ] , path . . . ) c . path = normalize Path ( c . path , c . buf ) } 
func ( c * Cookie ) Set Domain ( domain string ) { c . domain = append ( c . domain [ : 0 ] , domain . . . ) } 
func ( c * Cookie ) Set Domain Bytes ( domain [ ] byte ) { c . domain = append ( c . domain [ : 0 ] , domain . . . ) } 
func ( c * Cookie ) Expire ( ) time . Time { expire : = c . expire if expire . Is Zero ( ) { expire = Cookie Expire Unlimited } return expire } 
func ( c * Cookie ) Set Value ( value string ) { c . value = append ( c . value [ : 0 ] , value . . . ) } 
func ( c * Cookie ) Set Value Bytes ( value [ ] byte ) { c . value = append ( c . value [ : 0 ] , value . . . ) } 
func ( c * Cookie ) Set Key ( key string ) { c . key = append ( c . key [ : 0 ] , key . . . ) } 
func ( c * Cookie ) Set Key Bytes ( key [ ] byte ) { c . key = append ( c . key [ : 0 ] , key . . . ) } 
func ( c * Cookie ) Reset ( ) { c . key = c . key [ : 0 ] c . value = c . value [ : 0 ] c . expire = zero Time c . max Age = 0 c . domain = c . domain [ : 0 ] c . path = c . path [ : 0 ] c . http Only = false c . secure = false c . same Site = Cookie Same Site Disabled } 
func ( c * Cookie ) Append Bytes ( dst [ ] byte ) [ ] byte { if len ( c . key ) > 0 { dst = append ( dst , c . key . . . ) dst = append ( dst , ' = ' ) } dst = append ( dst , c . value . . . ) if c . max Age > 0 { dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Max Age . . . ) dst = append ( dst , ' = ' ) dst = Append Uint ( dst , c . max Age ) } else if ! c . expire . Is Zero ( ) { c . buf KV . value = Append HTTPDate ( c . buf KV . value [ : 0 ] , c . expire ) dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Expires . . . ) dst = append ( dst , ' = ' ) dst = append ( dst , c . buf KV . value . . . ) } if len ( c . domain ) > 0 { dst = append Cookie Part ( dst , str Cookie Domain , c . domain ) } if len ( c . path ) > 0 { dst = append Cookie Part ( dst , str Cookie Path , c . path ) } if c . http Only { dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie HTTPOnly . . . ) } if c . secure { dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Secure . . . ) } switch c . same Site { case Cookie Same Site Default Mode : dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Same Site . . . ) case Cookie Same Site Lax Mode : dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Same Site . . . ) dst = append ( dst , ' = ' ) dst = append ( dst , str Cookie Same Site Lax . . . ) case Cookie Same Site Strict Mode : dst = append ( dst , ' ; ' , ' ' ) dst = append ( dst , str Cookie Same Site . . . ) dst = append ( dst , ' = ' ) dst = append ( dst , str Cookie Same Site Strict . . . ) } return dst } 
func ( c * Cookie ) Cookie ( ) [ ] byte { c . buf = c . Append Bytes ( c . buf [ : 0 ] ) return c . buf } 
func ( c * Cookie ) Write To ( w io . Writer ) ( int 6 4 , error ) { n , err : = w . Write ( c . Cookie ( ) ) return int 6 4 ( n ) , err } 
func ( c * Cookie ) Parse ( src string ) error { c . buf = append ( c . buf [ : 0 ] , src . . . ) return c . Parse Bytes ( c . buf ) } 
func ( c * Cookie ) Parse Bytes ( src [ ] byte ) error { c . Reset ( ) var s cookie Scanner s . b = src kv : = & c . buf KV if ! s . next ( kv ) { return err No Cookies } c . key = append ( c . key [ : 0 ] , kv . key . . . ) c . value = append ( c . value [ : 0 ] , kv . value . . . ) for s . next ( kv ) { if len ( kv . key ) ! = 0 { if err ! = nil { return err } c . max Age = max Age } case 'e ' : if err ! = nil { exptime , err = time . Parse ( " " , v ) if err ! = nil { return err } } c . expire = exptime } case 'd ' : } case 'p ' : } case 's ' : } case 's ' : } } } } } else if len ( kv . value ) ! = 0 { } case 's ' : } else if case Insensitive Compare ( str Cookie Same Site , kv . value ) { c . same Site = Cookie Same Site Default Mode } } } } return nil } 
func append Response Cookie Bytes ( dst [ ] byte , cookies [ ] args KV ) [ ] byte { for i , n : = 0 , len ( cookies ) ; i < n ; i + + { kv : = & cookies [ i ] dst = append ( dst , kv . value . . . ) if i + 1 < n { dst = append ( dst , ' ; ' , ' ' ) } } return dst } 
func Pprof Handler ( ctx * fasthttp . Request Ctx ) { ctx . Response . Header . Set ( " " , " " ) if strings . Has Prefix ( string ( ctx . Path ( ) ) , " " ) { cmdline ( ctx ) } else if strings . Has Prefix ( string ( ctx . Path ( ) ) , " " ) { profile ( ctx ) } else if strings . Has Prefix ( string ( ctx . Path ( ) ) , " " ) { symbol ( ctx ) } else if strings . Has Prefix ( string ( ctx . Path ( ) ) , " " ) { trace ( ctx ) } else { for _ , v : = range rtp . Profiles ( ) { pp Name : = v . Name ( ) if strings . Has Prefix ( string ( ctx . Path ( ) ) , " " + pp Name ) { named Handler : = fasthttpadaptor . New Fast HTTPHandler Func ( pprof . Handler ( pp Name ) . Serve HTTP ) named Handler ( ctx ) return } } index ( ctx ) } } 
func Dial Timeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return default Dialer . Dial Timeout ( addr , timeout ) } 
func ( d * TCPDialer ) Dial ( addr string ) ( net . Conn , error ) { return d . dial ( addr , false , Default Dial Timeout ) } 
func ( d * TCPDialer ) Dial Timeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return d . dial ( addr , false , timeout ) } 
func ( d * TCPDialer ) Dial Dual Stack ( addr string ) ( net . Conn , error ) { return d . dial ( addr , true , Default Dial Timeout ) } 
func ( d * TCPDialer ) Dial Dual Stack Timeout ( addr string , timeout time . Duration ) ( net . Conn , error ) { return d . dial ( addr , true , timeout ) } 
func Acquire Timer ( timeout time . Duration ) * time . Timer { v : = timer Pool . Get ( ) if v = = nil { return time . New Timer ( timeout ) } t : = v . ( * time . Timer ) init Timer ( t , timeout ) return t } 
func ( ln * Inmemory Listener ) Accept ( ) ( net . Conn , error ) { c , ok : = < - ln . conns if ! ok { return nil , fmt . Errorf ( " " ) } close ( c . accepted ) return c . conn , nil } 
func ( ln * Inmemory Listener ) Close ( ) error { var err error ln . lock . Lock ( ) if ! ln . closed { close ( ln . conns ) ln . closed = true } else { err = fmt . Errorf ( " " ) } ln . lock . Unlock ( ) return err } 
func ( ln * Inmemory Listener ) Dial ( ) ( net . Conn , error ) { pc : = New Pipe Conns ( ) c Conn : = pc . Conn 1 ( ) s Conn : = pc . Conn 2 ( ) ln . lock . Lock ( ) accepted : = make ( chan struct { } ) if ! ln . closed { ln . conns < - accept Conn { s Conn , accepted } } else { s Conn . Close ( ) c Conn . Close ( ) c Conn = nil } ln . lock . Unlock ( ) if c Conn = = nil { return nil , fmt . Errorf ( " " ) } return c Conn , nil } 
func Listen ( network , addr string ) ( net . Listener , error ) { ln , err : = cfg . New Listener ( network , addr ) if err ! = nil & & strings . Contains ( err . Error ( ) , " " ) { return nil , & Err No Reuse Port { err } } return ln , err } 
func File Server ( r chi . Router , path string , root http . File System ) { if strings . Contains Any ( path , " " ) { panic ( " " ) } fs : = http . Strip Prefix ( path , http . File Server ( root ) ) if path ! = " " & & path [ len ( path ) - 1 ] ! = ' / ' { r . Get ( path , http . Redirect Handler ( path + " " , 3 0 1 ) . Serve HTTP ) path + = " " } path + = " " r . Get ( path , http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { fs . Serve HTTP ( w , r ) } ) ) } 
func ( x * Context ) Reset ( ) { x . Routes = nil x . Route Path = " " x . Route Method = " " x . Route Patterns = x . Route Patterns [ : 0 ] x . URLParams . Keys = x . URLParams . Keys [ : 0 ] x . URLParams . Values = x . URLParams . Values [ : 0 ] x . route Pattern = " " x . route Params . Keys = x . route Params . Keys [ : 0 ] x . route Params . Values = x . route Params . Values [ : 0 ] x . method Not Allowed = false } 
func ( x * Context ) URLParam ( key string ) string { for k : = len ( x . URLParams . Keys ) - 1 ; k > = 0 ; k - - { if x . URLParams . Keys [ k ] = = key { return x . URLParams . Values [ k ] } } return " " } 
func ( x * Context ) Route Pattern ( ) string { route Pattern : = strings . Join ( x . Route Patterns , " " ) return strings . Replace ( route Pattern , " " , " " , - 1 ) } 
func URLParam ( r * http . Request , key string ) string { if rctx : = Route Context ( r . Context ( ) ) ; rctx ! = nil { return rctx . URLParam ( key ) } return " " } 
func URLParam From Ctx ( ctx context . Context , key string ) string { if rctx : = Route Context ( ctx ) ; rctx ! = nil { return rctx . URLParam ( key ) } return " " } 
func ( s * Route Params ) Add ( key , value string ) { ( * s ) . Keys = append ( ( * s ) . Keys , key ) ( * s ) . Values = append ( ( * s ) . Values , value ) } 
func Server Base Context ( base Ctx context . Context , h http . Handler ) http . Handler { fn : = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { ctx : = r . Context ( ) base Ctx : = base Ctx } if v , ok : = ctx . Value ( http . Local Addr Context Key ) . ( net . Addr ) ; ok { base Ctx = context . With Value ( base Ctx , http . Local Addr Context Key , v ) } h . Serve HTTP ( w , r . With Context ( base Ctx ) ) } ) return fn } 
func Get Head ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if r . Method = = " " { rctx : = chi . Route Context ( r . Context ( ) ) route Path : = rctx . Route Path if route Path = = " " { if r . URL . Raw Path ! = " " { route Path = r . URL . Raw Path } else { route Path = r . URL . Path } } rctx . Route Path = route Path next . Serve HTTP ( w , r ) return } } next . Serve HTTP ( w , r ) } ) } 
func Heartbeat ( endpoint string ) func ( http . Handler ) http . Handler { f : = func ( h http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { if r . Method = = " " & & strings . Equal Fold ( r . URL . Path , endpoint ) { w . Header ( ) . Set ( " " , " " ) w . Write Header ( http . Status OK ) w . Write ( [ ] byte ( " " ) ) return } h . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } return f } 
func Real IP ( h http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { if rip : = real IP ( r ) ; rip ! = " " { r . Remote Addr = rip } h . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func Ping ( w http . Response Writer , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } 
func c W ( w io . Writer , use Color bool , color [ ] byte , s string , args . . . interface { } ) { if is TTY & & use Color { w . Write ( color ) } fmt . Fprintf ( w , s , args . . . ) if is TTY & & use Color { w . Write ( reset ) } } 
func Recoverer ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { defer func ( ) { if rvr : = recover ( ) ; rvr ! = nil { log Entry : = Get Log Entry ( r ) if log Entry ! = nil { log Entry . Panic ( rvr , debug . Stack ( ) ) } else { fmt . Fprintf ( os . Stderr , " \n " , rvr ) debug . Print Stack ( ) } http . Error ( w , http . Status Text ( http . Status Internal Server Error ) , http . Status Internal Server Error ) } } ( ) next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func Strip Slashes ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { var path string rctx : = chi . Route Context ( r . Context ( ) ) if rctx . Route Path ! = " " { path = rctx . Route Path } else { path = r . URL . Path } if len ( path ) > 1 & & path [ len ( path ) - 1 ] = = ' / ' { rctx . Route Path = path [ : len ( path ) - 1 ] } next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func Redirect Slashes ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { var path string rctx : = chi . Route Context ( r . Context ( ) ) if rctx . Route Path ! = " " { path = rctx . Route Path } else { path = r . URL . Path } if len ( path ) > 1 & & path [ len ( path ) - 1 ] = = ' / ' { if r . URL . Raw Query ! = " " { path = fmt . Sprintf ( " " , path [ : len ( path ) - 1 ] , r . URL . Raw Query ) } else { path = path [ : len ( path ) - 1 ] } http . Redirect ( w , r , path , 3 0 1 ) return } next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func Profiler ( ) http . Handler { r : = chi . New Router ( ) r . Use ( No Cache ) r . Get ( " " , func ( w http . Response Writer , r * http . Request ) { http . Redirect ( w , r , r . Request URI + " " , 3 0 1 ) } ) r . Handle Func ( " " , func ( w http . Response Writer , r * http . Request ) { http . Redirect ( w , r , r . Request URI + " " , 3 0 1 ) } ) r . Handle Func ( " " , pprof . Index ) r . Handle Func ( " " , pprof . Cmdline ) r . Handle Func ( " " , pprof . Profile ) r . Handle Func ( " " , pprof . Symbol ) r . Handle Func ( " " , pprof . Trace ) r . Handle Func ( " " , exp Vars ) return r } 
func Timeout ( timeout time . Duration ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { ctx , cancel : = context . With Timeout ( r . Context ( ) , timeout ) defer func ( ) { cancel ( ) if ctx . Err ( ) = = context . Deadline Exceeded { w . Write Header ( http . Status Gateway Timeout ) } } ( ) r = r . With Context ( ctx ) next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } } 
func Set Header ( key , value string ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { w . Header ( ) . Set ( key , value ) next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } } 
func Allow Content Type ( content Types . . . string ) func ( next http . Handler ) http . Handler { c T : = [ ] string { } for _ , t : = range content Types { c T = append ( c T , strings . To Lower ( t ) ) } return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { if r . Content Length = = 0 { return } s : = strings . To Lower ( strings . Trim Space ( r . Header . Get ( " " ) ) ) if i : = strings . Index ( s , " " ) ; i > - 1 { s = s [ 0 : i ] } for _ , t : = range c T { if t = = s { next . Serve HTTP ( w , r ) return } } w . Write Header ( http . Status Unsupported Media Type ) } return http . Handler Func ( fn ) } } 
func init ( ) { hostname , err : = os . Hostname ( ) if hostname = = " " | | err ! = nil { hostname = " " } var buf [ 1 2 ] byte var b 6 4 string for len ( b 6 4 ) < 1 0 { rand . Read ( buf [ : ] ) b 6 4 = base 6 4 . Std Encoding . Encode To String ( buf [ : ] ) b 6 4 = strings . New Replacer ( " " , " " , " " , " " ) . Replace ( b 6 4 ) } prefix = fmt . Sprintf ( " " , hostname , b 6 4 [ 0 : 1 0 ] ) } 
func Request ID ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { ctx : = r . Context ( ) request ID : = r . Header . Get ( " " ) if request ID = = " " { myid : = atomic . Add Uint 6 4 ( & reqid , 1 ) request ID = fmt . Sprintf ( " " , prefix , myid ) } ctx = context . With Value ( ctx , Request IDKey , request ID ) next . Serve HTTP ( w , r . With Context ( ctx ) ) } return http . Handler Func ( fn ) } 
func Get Req ID ( ctx context . Context ) string { if ctx = = nil { return " " } if req ID , ok : = ctx . Value ( Request IDKey ) . ( string ) ; ok { return req ID } return " " } 
func ( mws Middlewares ) Handler Func ( h http . Handler Func ) http . Handler { return & Chain Handler { mws , h , chain ( mws , h ) } } 
func chain ( middlewares [ ] func ( http . Handler ) http . Handler , endpoint http . Handler ) http . Handler { } for i : = len ( middlewares ) - 2 ; i > = 0 ; i - - { h = middlewares [ i ] ( h ) } return h } 
func New Mux ( ) * Mux { mux : = & Mux { tree : & node { } , pool : & sync . Pool { } } mux . pool . New = func ( ) interface { } { return New Route Context ( ) } return mux } 
func ( mx * Mux ) Serve HTTP ( w http . Response Writer , r * http . Request ) { return } if rctx ! = nil { mx . handler . Serve HTTP ( w , r ) return } rctx . Reset ( ) rctx . Routes = mx r = r . With Context ( context . With Value ( r . Context ( ) , Route Ctx Key , rctx ) ) mx . handler . Serve HTTP ( w , r ) mx . pool . Put ( rctx ) } 
func ( mx * Mux ) Use ( middlewares . . . func ( http . Handler ) http . Handler ) { if mx . handler ! = nil { panic ( " " ) } mx . middlewares = append ( mx . middlewares , middlewares . . . ) } 
func ( mx * Mux ) Handle ( pattern string , handler http . Handler ) { mx . handle ( m ALL , pattern , handler ) } 
func ( mx * Mux ) Handle Func ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m ALL , pattern , handler Fn ) } 
func ( mx * Mux ) Method ( method , pattern string , handler http . Handler ) { m , ok : = method Map [ strings . To Upper ( method ) ] if ! ok { panic ( fmt . Sprintf ( " " , method ) ) } mx . handle ( m , pattern , handler ) } 
func ( mx * Mux ) Method Func ( method , pattern string , handler Fn http . Handler Func ) { mx . Method ( method , pattern , handler Fn ) } 
func ( mx * Mux ) Connect ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m CONNECT , pattern , handler Fn ) } 
func ( mx * Mux ) Delete ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m DELETE , pattern , handler Fn ) } 
func ( mx * Mux ) Get ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m GET , pattern , handler Fn ) } 
func ( mx * Mux ) Head ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m HEAD , pattern , handler Fn ) } 
func ( mx * Mux ) Options ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m OPTIONS , pattern , handler Fn ) } 
func ( mx * Mux ) Patch ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m PATCH , pattern , handler Fn ) } 
func ( mx * Mux ) Post ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m POST , pattern , handler Fn ) } 
func ( mx * Mux ) Put ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m PUT , pattern , handler Fn ) } 
func ( mx * Mux ) Trace ( pattern string , handler Fn http . Handler Func ) { mx . handle ( m TRACE , pattern , handler Fn ) } 
func ( mx * Mux ) Not Found ( handler Fn http . Handler Func ) { h Fn : = handler Fn if mx . inline & & mx . parent ! = nil { m = mx . parent h Fn = Chain ( mx . middlewares . . . ) . Handler Func ( h Fn ) . Serve HTTP } m . update Sub Routes ( func ( sub Mux * Mux ) { if sub Mux . not Found Handler = = nil { sub Mux . Not Found ( h Fn ) } } ) } 
func ( mx * Mux ) Method Not Allowed ( handler Fn http . Handler Func ) { h Fn : = handler Fn if mx . inline & & mx . parent ! = nil { m = mx . parent h Fn = Chain ( mx . middlewares . . . ) . Handler Func ( h Fn ) . Serve HTTP } m . update Sub Routes ( func ( sub Mux * Mux ) { if sub Mux . method Not Allowed Handler = = nil { sub Mux . Method Not Allowed ( h Fn ) } } ) } 
func ( mx * Mux ) With ( middlewares . . . func ( http . Handler ) http . Handler ) Router { } if mx . inline { mws = make ( Middlewares , len ( mx . middlewares ) ) copy ( mws , mx . middlewares ) } mws = append ( mws , middlewares . . . ) im : = & Mux { pool : mx . pool , inline : true , parent : mx , tree : mx . tree , middlewares : mws } return im } 
func ( mx * Mux ) Group ( fn func ( r Router ) ) Router { im : = mx . With ( ) . ( * Mux ) if fn ! = nil { fn ( im ) } return im } 
func ( mx * Mux ) Route ( pattern string , fn func ( r Router ) ) Router { sub Router : = New Router ( ) if fn ! = nil { fn ( sub Router ) } mx . Mount ( pattern , sub Router ) return sub Router } 
func ( mx * Mux ) Mount ( pattern string , handler http . Handler ) { } if ok & & subr . not Found Handler = = nil & & mx . not Found Handler ! = nil { subr . Not Found ( mx . not Found Handler ) } if ok & & subr . method Not Allowed Handler = = nil & & mx . method Not Allowed Handler ! = nil { subr . Method Not Allowed ( mx . method Not Allowed Handler ) } rctx . Route Path = mx . next Route Path ( rctx ) handler . Serve HTTP ( w , r ) } ) if pattern = = " " | | pattern [ len ( pattern ) - 1 ] ! = ' / ' { mx . handle ( m ALL | m STUB , pattern , mount Handler ) mx . handle ( m ALL | m STUB , pattern + " " , mount Handler ) pattern + = " " } method : = m ALL subroutes , _ : = handler . ( Routes ) if subroutes ! = nil { method | = m STUB } n : = mx . handle ( method , pattern + " " , mount Handler ) if subroutes ! = nil { n . subroutes = subroutes } } 
func ( mx * Mux ) Match ( rctx * Context , method , path string ) bool { m , ok : = method Map [ method ] if ! ok { return false } node , _ , h : = mx . tree . Find Route ( rctx , m , path ) if node ! = nil & & node . subroutes ! = nil { rctx . Route Path = mx . next Route Path ( rctx ) return node . subroutes . Match ( rctx , method , rctx . Route Path ) } return h ! = nil } 
func ( mx * Mux ) Not Found Handler ( ) http . Handler Func { if mx . not Found Handler ! = nil { return mx . not Found Handler } return http . Not Found } 
func ( mx * Mux ) Method Not Allowed Handler ( ) http . Handler Func { if mx . method Not Allowed Handler ! = nil { return mx . method Not Allowed Handler } return method Not Allowed Handler } 
func ( mx * Mux ) build Route Handler ( ) { mx . handler = chain ( mx . middlewares , http . Handler Func ( mx . route HTTP ) ) } 
func ( mx * Mux ) handle ( method method Typ , pattern string , handler http . Handler ) * node { if len ( pattern ) = = 0 | | pattern [ 0 ] ! = ' / ' { panic ( fmt . Sprintf ( " " , pattern ) ) } } if mx . inline { mx . handler = http . Handler Func ( mx . route HTTP ) h = Chain ( mx . middlewares . . . ) . Handler ( handler ) } else { h = handler } } 
func ( mx * Mux ) route HTTP ( w http . Response Writer , r * http . Request ) { if route Path = = " " { if r . URL . Raw Path ! = " " { route Path = r . URL . Raw Path } else { route Path = r . URL . Path } } } method , ok : = method Map [ rctx . Route Method ] if ! ok { mx . Method Not Allowed Handler ( ) . Serve HTTP ( w , r ) return } return } if rctx . method Not Allowed { mx . Method Not Allowed Handler ( ) . Serve HTTP ( w , r ) } else { mx . Not Found Handler ( ) . Serve HTTP ( w , r ) } } 
func ( mx * Mux ) update Sub Routes ( fn func ( sub Mux * Mux ) ) { for _ , r : = range mx . tree . routes ( ) { sub Mux , ok : = r . Sub Routes . ( * Mux ) if ! ok { continue } fn ( sub Mux ) } } 
func method Not Allowed Handler ( w http . Response Writer , r * http . Request ) { w . Write Header ( 4 0 5 ) w . Write ( nil ) } 
func No Cache ( h http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { } } } h . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func Request Logger ( f Log Formatter ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { entry : = f . New Log Entry ( r ) ww : = New Wrap Response Writer ( w , r . Proto Major ) t 1 : = time . Now ( ) defer func ( ) { entry . Write ( ww . Status ( ) , ww . Bytes Written ( ) , time . Since ( t 1 ) ) } ( ) next . Serve HTTP ( ww , With Log Entry ( r , entry ) ) } return http . Handler Func ( fn ) } } 
func Get Log Entry ( r * http . Request ) Log Entry { entry , _ : = r . Context ( ) . Value ( Log Entry Ctx Key ) . ( Log Entry ) return entry } 
func With Log Entry ( r * http . Request , entry Log Entry ) * http . Request { r = r . With Context ( context . With Value ( r . Context ( ) , Log Entry Ctx Key , entry ) ) return r } 
func ( l * Default Log Formatter ) New Log Entry ( r * http . Request ) Log Entry { use Color : = ! l . No Color entry : = & default Log Entry { Default Log Formatter : l , request : r , buf : & bytes . Buffer { } , use Color : use Color , } req ID : = Get Req ID ( r . Context ( ) ) if req ID ! = " " { c W ( entry . buf , use Color , n Yellow , " " , req ID ) } c W ( entry . buf , use Color , n Cyan , " \ " " ) c W ( entry . buf , use Color , b Magenta , " " , r . Method ) scheme : = " " if r . TLS ! = nil { scheme = " " } c W ( entry . buf , use Color , n Cyan , " \ " " , scheme , r . Host , r . Request URI , r . Proto ) entry . buf . Write String ( " " ) entry . buf . Write String ( r . Remote Addr ) entry . buf . Write String ( " " ) return entry } 
func New Structured Logger ( logger * logrus . Logger ) func ( next http . Handler ) http . Handler { return middleware . Request Logger ( & Structured Logger { logger } ) } 
func Get Log Entry ( r * http . Request ) logrus . Field Logger { entry : = middleware . Get Log Entry ( r ) . ( * Structured Logger Entry ) return entry . Logger } 
func Content Charset ( charsets . . . string ) func ( next http . Handler ) http . Handler { for i , c : = range charsets { charsets [ i ] = strings . To Lower ( c ) } return func ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if ! content Encoding ( r . Header . Get ( " " ) , charsets . . . ) { w . Write Header ( http . Status Unsupported Media Type ) return } next . Serve HTTP ( w , r ) } ) } } 
func content Encoding ( ce string , charsets . . . string ) bool { _ , ce = split ( strings . To Lower ( ce ) , " " ) _ , ce = split ( ce , " " ) ce , _ = split ( ce , " " ) for _ , c : = range charsets { if ce = = c { return true } } return false } 
func split ( str , sep string ) ( string , string ) { var a , b string var parts = strings . Split N ( str , sep , 2 ) a = strings . Trim Space ( parts [ 0 ] ) if len ( parts ) = = 2 { b = strings . Trim Space ( parts [ 1 ] ) } return a , b } 
func Register Method ( method string ) { if method = = " " { return } method = strings . To Upper ( method ) if _ , ok : = method Map [ method ] ; ok { return } n : = len ( method Map ) if n > strconv . Int Size { panic ( fmt . Sprintf ( " " , strconv . Int Size ) ) } mt : = method Typ ( math . Exp 2 ( float 6 4 ( n ) ) ) method Map [ method ] = mt m ALL | = mt } 
func ( n * node ) add Child ( child * node , prefix string ) * node { search : = prefix if err ! = nil { panic ( fmt . Sprintf ( " " , seg Rexpat ) ) } child . prefix = seg Rexpat child . rex = rex } if seg Start Idx = = 0 { if seg Typ = = nt Catch All { seg Start Idx = - 1 } else { seg Start Idx = seg End Idx } if seg Start Idx < 0 { seg Start Idx = len ( search ) } child . tail = seg Tail if seg Start Idx ! = len ( search ) { nn : = & node { typ : nt Static , label : search [ 0 ] , prefix : search , } hn = child . add Child ( nn , search ) } } else if seg Start Idx > 0 { child . prefix = search [ : seg Start Idx ] child . rex = nil nn : = & node { typ : seg Typ , label : search [ 0 ] , tail : seg Tail , } hn = child . add Child ( nn , search ) } } n . children [ child . typ ] = append ( n . children [ child . typ ] , child ) n . children [ child . typ ] . Sort ( ) return hn } 
func ( n * node ) find Route ( rctx * Context , method method Typ , path string ) * node { nn : = n search : = path for t , nds : = range nn . children { ntyp : = node Typ ( t ) if len ( nds ) = = 0 { continue } var xn * node xsearch : = search var label byte if search ! = " " { label = search [ 0 ] } switch ntyp { case nt Static : xn = nds . find Edge ( label ) if xn = = nil | | ! strings . Has Prefix ( xsearch , xn . prefix ) { continue } xsearch = xsearch [ len ( xn . prefix ) : ] case nt Param , nt Regexp : } if p < 0 { if xn . tail = = ' / ' { p = len ( xsearch ) } else { continue } } if ntyp = = nt Regexp & & xn . rex ! = nil { if xn . rex . Match ( [ ] byte ( xsearch [ : p ] ) ) = = false { continue } } else if strings . Index Byte ( xsearch [ : p ] , ' / ' ) ! = - 1 { } rctx . route Params . Values = append ( rctx . route Params . Values , xsearch [ : p ] ) xsearch = xsearch [ p : ] break } default : xn = nds [ 0 ] xsearch = " " } if xn = = nil { continue } if h ! = nil & & h . handler ! = nil { rctx . route Params . Keys = append ( rctx . route Params . Keys , h . param Keys . . . ) return xn } } } if fin ! = nil { return fin } } } } return nil } 
func pat Next Segment ( pattern string ) ( node Typ , string , string , byte , int , int ) { ps : = strings . Index ( pattern , " " ) ws : = strings . Index ( pattern , " " ) if ps < 0 & & ws < 0 { return nt Static , " " , " " , 0 , 0 , len ( pattern ) } } var tail byte = ' / ' if ps > = 0 { pe : = ps for i , c : = range pattern [ ps : ] { if c = = ' { ' { cc + + } else if c = = ' } ' { cc - - if cc = = 0 { pe = ps + i break } } } if pe = = ps { panic ( " " ) } key : = pattern [ ps + 1 : pe ] pe + + if pe < len ( pattern ) { tail = pattern [ pe ] } var rexpat string if idx : = strings . Index ( key , " " ) ; idx > = 0 { nt = nt Regexp rexpat = key [ idx + 1 : ] key = key [ : idx ] } if len ( rexpat ) > 0 { if rexpat [ 0 ] ! = ' ^ ' { rexpat = " " + rexpat } if rexpat [ len ( rexpat ) - 1 ] ! = ' $ ' { rexpat = rexpat + " " } } return nt , key , rexpat , tail , ps , pe } } return nt Catch All , " " , " " , 0 , ws , len ( pattern ) } 
func ( ns nodes ) tail Sort ( ) { for i : = len ( ns ) - 1 ; i > = 0 ; i - - { if ns [ i ] . typ > nt Static & & ns [ i ] . tail = = ' / ' { ns . Swap ( i , len ( ns ) - 1 ) return } } } 
func Article Ctx ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { var article * Article var err error if article ID : = chi . URLParam ( r , " " ) ; article ID ! = " " { article , err = db Get Article ( article ID ) } else if article Slug : = chi . URLParam ( r , " " ) ; article Slug ! = " " { article , err = db Get Article By Slug ( article Slug ) } else { render . Render ( w , r , Err Not Found ) return } if err ! = nil { render . Render ( w , r , Err Not Found ) return } ctx : = context . With Value ( r . Context ( ) , " " , article ) next . Serve HTTP ( w , r . With Context ( ctx ) ) } ) } 
func Search Articles ( w http . Response Writer , r * http . Request ) { render . Render List ( w , r , New Article List Response ( articles ) ) } 
func Create Article ( w http . Response Writer , r * http . Request ) { data : = & Article Request { } if err : = render . Bind ( r , data ) ; err ! = nil { render . Render ( w , r , Err Invalid Request ( err ) ) return } article : = data . Article db New Article ( article ) render . Status ( r , http . Status Created ) render . Render ( w , r , New Article Response ( article ) ) } 
func Get Article ( w http . Response Writer , r * http . Request ) { if err : = render . Render ( w , r , New Article Response ( article ) ) ; err ! = nil { render . Render ( w , r , Err Render ( err ) ) return } } 
func Update Article ( w http . Response Writer , r * http . Request ) { article : = r . Context ( ) . Value ( " " ) . ( * Article ) data : = & Article Request { Article : article } if err : = render . Bind ( r , data ) ; err ! = nil { render . Render ( w , r , Err Invalid Request ( err ) ) return } article = data . Article db Update Article ( article . ID , article ) render . Render ( w , r , New Article Response ( article ) ) } 
func Delete Article ( w http . Response Writer , r * http . Request ) { var err error article , err = db Remove Article ( article . ID ) if err ! = nil { render . Render ( w , r , Err Invalid Request ( err ) ) return } render . Render ( w , r , New Article Response ( article ) ) } 
func admin Router ( ) chi . Router { r : = chi . New Router ( ) r . Use ( Admin Only ) r . Get ( " " , func ( w http . Response Writer , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } ) r . Get ( " " , func ( w http . Response Writer , r * http . Request ) { w . Write ( [ ] byte ( " " ) ) } ) r . Get ( " " , func ( w http . Response Writer , r * http . Request ) { w . Write ( [ ] byte ( fmt . Sprintf ( " " , chi . URLParam ( r , " " ) ) ) ) } ) return r } 
func Admin Only ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { is Admin , ok : = r . Context ( ) . Value ( " " ) . ( bool ) if ! ok | | ! is Admin { http . Error ( w , http . Status Text ( http . Status Forbidden ) , http . Status Forbidden ) return } next . Serve HTTP ( w , r ) } ) } 
func paginate ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { } ) } 
func init ( ) { render . Respond = func ( w http . Response Writer , r * http . Request , v interface { } ) { if err , ok : = v . ( error ) ; ok { } return } render . Default Responder ( w , r , v ) } } 
func New Compressor ( level int , types . . . string ) * Compressor { if len ( types ) > 0 { for _ , t : = range types { allowed Types [ t ] = true } } else { for _ , t : = range default Compressible Content Types { allowed Types [ t ] = true } } c : = & Compressor { level : level , encoders : make ( map [ string ] Encoder Func ) , pooled Encoders : make ( map [ string ] * sync . Pool ) , allowed Types : allowed Types , } } 
func ( c * Compressor ) Set Encoder ( encoding string , fn Encoder Func ) { encoding = strings . To Lower ( encoding ) if encoding = = " " { panic ( " " ) } if fn = = nil { panic ( " " ) } } if _ , ok : = c . encoders [ encoding ] ; ok { delete ( c . encoders , encoding ) } if encoder ! = nil { if _ , ok : = encoder . ( io Resetter Writer ) ; ok { pool : = & sync . Pool { New : func ( ) interface { } { return fn ( ioutil . Discard , c . level ) } , } c . pooled Encoders [ encoding ] = pool } } } for i , v : = range c . encoding Precedence { if v = = encoding { c . encoding Precedence = append ( c . encoding Precedence [ : i ] , c . encoding Precedence [ i + 1 : ] . . . ) } } c . encoding Precedence = append ( [ ] string { encoding } , c . encoding Precedence . . . ) } 
func ( c * Compressor ) Handler ( ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { encoder , encoding , cleanup : = c . select Encoder ( r . Header , w ) cw : = & compress Response Writer { Response Writer : w , w : w , content Types : c . allowed Types , encoding : encoding , } if encoder ! = nil { cw . w = encoder } defer cw . Close ( ) next . Serve HTTP ( cw , r ) } return http . Handler Func ( fn ) } } 
func ( c * Compressor ) select Encoder ( h http . Header , w io . Writer ) ( io . Writer , string , func ( ) ) { header : = h . Get ( " " ) cleanup : = func ( ) { pool . Put ( encoder ) } encoder . Reset ( w ) return encoder , name , cleanup } if fn , ok : = c . encoders [ name ] ; ok { return fn ( w , c . level ) , name , func ( ) { } } } } } 
func Set Encoder ( encoding string , fn Encoder Func ) { if default Compressor = = nil { panic ( " " ) } default Compressor . Set Encoder ( encoding , fn ) } 
func Default Compress ( next http . Handler ) http . Handler { return Compress ( flate . Default Compression ) ( next ) } 
func Compress ( level int , types . . . string ) func ( next http . Handler ) http . Handler { default Compressor = New Compressor ( level , types . . . ) return default Compressor . Handler ( ) } 
func Throttle ( limit int ) func ( http . Handler ) http . Handler { return Throttle Backlog ( limit , 0 , default Backlog Timeout ) } 
func Throttle Backlog ( limit int , backlog Limit int , backlog Timeout time . Duration ) func ( http . Handler ) http . Handler { if limit < 1 { panic ( " " ) } if backlog Limit < 0 { panic ( " " ) } t : = throttler { tokens : make ( chan token , limit ) , backlog Tokens : make ( chan token , limit + backlog Limit ) , backlog Timeout : backlog Timeout , } } t . backlog Tokens < - token { } } fn : = func ( h http . Handler ) http . Handler { t . h = h return & t } return fn } 
func ( t * throttler ) Serve HTTP ( w http . Response Writer , r * http . Request ) { ctx : = r . Context ( ) select { case < - ctx . Done ( ) : http . Error ( w , err Context Canceled , http . Status Service Unavailable ) return case btok : = < - t . backlog Tokens : timer : = time . New Timer ( t . backlog Timeout ) defer func ( ) { t . backlog Tokens < - btok } ( ) select { case < - timer . C : http . Error ( w , err Timed Out , http . Status Service Unavailable ) return case < - ctx . Done ( ) : http . Error ( w , err Context Canceled , http . Status Service Unavailable ) return case tok : = < - t . tokens : defer func ( ) { t . tokens < - tok } ( ) t . h . Serve HTTP ( w , r ) } return default : http . Error ( w , err Capacity Exceeded , http . Status Service Unavailable ) return } } 
func URLFormat ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { ctx : = r . Context ( ) var format string path : = r . URL . Path if strings . Index ( path , " " ) > 0 { base : = strings . Last Index ( path , " " ) idx : = strings . Index ( path [ base : ] , " " ) if idx > 0 { idx + = base format = path [ idx + 1 : ] rctx : = chi . Route Context ( r . Context ( ) ) rctx . Route Path = path [ : idx ] } } r = r . With Context ( context . With Value ( ctx , URLFormat Ctx Key , format ) ) next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } 
func New Wrap Response Writer ( w http . Response Writer , proto Major int ) Wrap Response Writer { _ , fl : = w . ( http . Flusher ) bw : = basic Writer { Response Writer : w } if proto Major = = 2 { _ , ps : = w . ( http . Pusher ) if fl & & ps { return & http 2Fancy Writer { bw } } } else { _ , hj : = w . ( http . Hijacker ) _ , rf : = w . ( io . Reader From ) if fl & & hj & & rf { return & http Fancy Writer { bw } } } if fl { return & flush Writer { bw } } return & bw } 
func With Value ( key interface { } , val interface { } ) func ( next http . Handler ) http . Handler { return func ( next http . Handler ) http . Handler { fn : = func ( w http . Response Writer , r * http . Request ) { r = r . With Context ( context . With Value ( r . Context ( ) , key , val ) ) next . Serve HTTP ( w , r ) } return http . Handler Func ( fn ) } } 
func ( rs todos Resource ) Routes ( ) chi . Router { r : = chi . New Router ( ) r . Post ( " " , rs . Create ) r . Put ( " " , rs . Delete ) r . Route ( " " , func ( r chi . Router ) { r . Put ( " " , rs . Update ) r . Delete ( " " , rs . Delete ) r . Get ( " " , rs . Sync ) } ) return r } 
func New AWSProvider ( aws Config AWSConfig ) ( * AWSProvider , error ) { config : = aws . New Config ( ) . With Max Retries ( aws Config . APIRetries ) config . With HTTPClient ( instrumented _http . New Client ( config . HTTPClient , & instrumented _http . Callbacks { Path Processor : func ( path string ) string { parts : = strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) , ) session , err : = session . New Session With Options ( session . Options { Config : * config , Shared Config State : session . Shared Config Enable , } ) if err ! = nil { return nil , err } if aws Config . Assume Role ! = " " { log . Infof ( " " , aws Config . Assume Role ) session . Config . With Credentials ( stscreds . New Credentials ( session , aws Config . Assume Role ) ) } provider : = & AWSProvider { client : route 5 3 . New ( session ) , domain Filter : aws Config . Domain Filter , zone IDFilter : aws Config . Zone IDFilter , zone Type Filter : aws Config . Zone Type Filter , zone Tag Filter : aws Config . Zone Tag Filter , batch Change Size : aws Config . Batch Change Size , batch Change Interval : aws Config . Batch Change Interval , evaluate Target Health : aws Config . Evaluate Target Health , dry Run : aws Config . Dry Run , } return provider , nil } 
func ( p * AWSProvider ) Zones ( ) ( map [ string ] * route 5 3 . Hosted Zone , error ) { zones : = make ( map [ string ] * route 5 3 . Hosted Zone ) var tag Err error f : = func ( resp * route 5 3 . List Hosted Zones Output , last Page bool ) ( should Continue bool ) { for _ , zone : = range resp . Hosted Zones { if ! p . zone IDFilter . Match ( aws . String Value ( zone . Id ) ) { continue } if ! p . zone Type Filter . Match ( zone ) { continue } if ! p . domain Filter . Match ( aws . String Value ( zone . Name ) ) { continue } if err ! = nil { tag Err = err return false } if ! p . zone Tag Filter . Match ( tags ) { continue } } zones [ aws . String Value ( zone . Id ) ] = zone } return true } err : = p . client . List Hosted Zones Pages ( & route 5 3 . List Hosted Zones Input { } , f ) if err ! = nil { return nil , err } if tag Err ! = nil { return nil , tag Err } for _ , zone : = range zones { log . Debugf ( " " , aws . String Value ( zone . Id ) , aws . String Value ( zone . Name ) ) } return zones , nil } 
func wildcard Unescape ( s string ) string { if strings . Contains ( s , " \ \ " ) { s = strings . Replace ( s , " \ \ " , " " , 1 ) } return s } 
func ( p * AWSProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } return p . records ( zones ) } 
func ( p * AWSProvider ) Create Records ( endpoints [ ] * endpoint . Endpoint ) error { return p . do Records ( route 5 3 . Change Action Create , endpoints ) } 
func ( p * AWSProvider ) Update Records ( endpoints , _ [ ] * endpoint . Endpoint ) error { return p . do Records ( route 5 3 . Change Action Upsert , endpoints ) } 
func ( p * AWSProvider ) Delete Records ( endpoints [ ] * endpoint . Endpoint ) error { return p . do Records ( route 5 3 . Change Action Delete , endpoints ) } 
func ( p * AWSProvider ) Apply Changes ( changes * plan . Changes ) error { zones , err : = p . Zones ( ) if err ! = nil { return err } records , err : = p . records ( zones ) if err ! = nil { log . Errorf ( " " , err ) } combined Changes : = make ( [ ] * route 5 3 . Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , p . new Changes ( route 5 3 . Change Action Create , changes . Create , records , zones ) . . . ) combined Changes = append ( combined Changes , p . new Changes ( route 5 3 . Change Action Upsert , changes . Update New , records , zones ) . . . ) combined Changes = append ( combined Changes , p . new Changes ( route 5 3 . Change Action Delete , changes . Delete , records , zones ) . . . ) return p . submit Changes ( combined Changes , zones ) } 
func ( p * AWSProvider ) submit Changes ( changes [ ] * route 5 3 . Change , zones map [ string ] * route 5 3 . Hosted Zone ) error { return nil } if len ( changes By Zone ) = = 0 { log . Info ( " " ) } var failed Zones [ ] string for z , cs : = range changes By Zone { var failed Update bool batch Cs : = batch Change Set ( cs , p . batch Change Size ) for i , b : = range batch Cs { for _ , c : = range b { log . Infof ( " " , * c . Action , * c . Resource Record Set . Name , * c . Resource Record Set . Type ) } if ! p . dry Run { params : = & route 5 3 . Change Resource Record Sets Input { Hosted Zone Id : aws . String ( z ) , Change Batch : & route 5 3 . Change Batch { Changes : b , } , } if _ , err : = p . client . Change Resource Record Sets ( params ) ; err ! = nil { log . Error ( err ) failed Update = true } else { log . Infof ( " " , len ( b ) , aws . String Value ( zones [ z ] . Name ) ) } if i ! = len ( batch Cs ) - 1 { time . Sleep ( p . batch Change Interval ) } } } if failed Update { failed Zones = append ( failed Zones , z ) } } if len ( failed Zones ) > 0 { return fmt . Errorf ( " " , failed Zones ) } return nil } 
func ( p * AWSProvider ) new Changes ( action string , endpoints [ ] * endpoint . Endpoint , records Cache [ ] * endpoint . Endpoint , zones map [ string ] * route 5 3 . Hosted Zone ) [ ] * route 5 3 . Change { changes : = make ( [ ] * route 5 3 . Change , 0 , len ( endpoints ) ) for _ , endpoint : = range endpoints { changes = append ( changes , p . new Change ( action , endpoint , records Cache , zones ) ) } return changes } 
func ( p * AWSProvider ) new Change ( action string , endpoint * endpoint . Endpoint , records Cache [ ] * endpoint . Endpoint , zones map [ string ] * route 5 3 . Hosted Zone ) * route 5 3 . Change { change : = & route 5 3 . Change { Action : aws . String ( action ) , Resource Record Set : & route 5 3 . Resource Record Set { Name : aws . String ( endpoint . DNSName ) , } , } if is AWSLoad Balancer ( endpoint ) { eval Target Health : = p . evaluate Target Health if prop , ok : = endpoint . Get Provider Specific Property ( provider Specific Evaluate Target Health ) ; ok { eval Target Health = prop . Value = = " " } change . Resource Record Set . Type = aws . String ( route 5 3 . RRType A ) change . Resource Record Set . Alias Target = & route 5 3 . Alias Target { DNSName : aws . String ( endpoint . Targets [ 0 ] ) , Hosted Zone Id : aws . String ( canonical Hosted Zone ( endpoint . Targets [ 0 ] ) ) , Evaluate Target Health : aws . Bool ( eval Target Health ) , } } else if hosted Zone : = is AWSAlias ( endpoint , records Cache ) ; hosted Zone ! = " " { for _ , zone : = range zones { change . Resource Record Set . Type = aws . String ( route 5 3 . RRType A ) change . Resource Record Set . Alias Target = & route 5 3 . Alias Target { DNSName : aws . String ( endpoint . Targets [ 0 ] ) , Hosted Zone Id : aws . String ( clean Zone ID ( * zone . Id ) ) , Evaluate Target Health : aws . Bool ( p . evaluate Target Health ) , } } } else { change . Resource Record Set . Type = aws . String ( endpoint . Record Type ) if ! endpoint . Record TTL . Is Configured ( ) { change . Resource Record Set . TTL = aws . Int 6 4 ( record TTL ) } else { change . Resource Record Set . TTL = aws . Int 6 4 ( int 6 4 ( endpoint . Record TTL ) ) } change . Resource Record Set . Resource Records = make ( [ ] * route 5 3 . Resource Record , len ( endpoint . Targets ) ) for idx , val : = range endpoint . Targets { change . Resource Record Set . Resource Records [ idx ] = & route 5 3 . Resource Record { Value : aws . String ( val ) , } } } return change } 
func changes By Zone ( zones map [ string ] * route 5 3 . Hosted Zone , change Set [ ] * route 5 3 . Change ) map [ string ] [ ] * route 5 3 . Change { changes : = make ( map [ string ] [ ] * route 5 3 . Change ) for _ , z : = range zones { changes [ aws . String Value ( z . Id ) ] = [ ] * route 5 3 . Change { } } for _ , c : = range change Set { hostname : = ensure Trailing Dot ( aws . String Value ( c . Resource Record Set . Name ) ) zones : = suitable Zones ( hostname , zones ) if len ( zones ) = = 0 { log . Debugf ( " " , c . String ( ) ) continue } for _ , z : = range zones { changes [ aws . String Value ( z . Id ) ] = append ( changes [ aws . String Value ( z . Id ) ] , c ) log . Debugf ( " " , hostname , aws . String Value ( z . Name ) , aws . String Value ( z . Id ) ) } } } } return changes } 
func suitable Zones ( hostname string , zones map [ string ] * route 5 3 . Hosted Zone ) [ ] * route 5 3 . Hosted Zone { var matching Zones [ ] * route 5 3 . Hosted Zone var public Zone * route 5 3 . Hosted Zone for _ , z : = range zones { if aws . String Value ( z . Name ) = = hostname | | strings . Has Suffix ( hostname , " " + aws . String Value ( z . Name ) ) { if z . Config = = nil | | ! aws . Bool Value ( z . Config . Private Zone ) { } } else { } } } if public Zone ! = nil { matching Zones = append ( matching Zones , public Zone ) } return matching Zones } 
func is AWSLoad Balancer ( ep * endpoint . Endpoint ) bool { if ep . Record Type = = endpoint . Record Type CNAME { return canonical Hosted Zone ( ep . Targets [ 0 ] ) ! = " " } return false } 
func is AWSAlias ( ep * endpoint . Endpoint , addrs [ ] * endpoint . Endpoint ) string { if prop , exists : = ep . Get Provider Specific Property ( " " ) ; ep . Record Type = = endpoint . Record Type CNAME & & exists & & prop . Value = = " " { for _ , addr : = range addrs { if addr . DNSName = = ep . Targets [ 0 ] { if hosted Zone : = canonical Hosted Zone ( addr . Targets [ 0 ] ) ; hosted Zone ! = " " { return hosted Zone } } } } return " " } 
func canonical Hosted Zone ( hostname string ) string { for suffix , zone : = range canonical Hosted Zones { if strings . Has Suffix ( hostname , suffix ) { return zone } } return " " } 
func clean Zone ID ( ID string ) string { if strings . Has Prefix ( ID , " " ) { ID = strings . Trim Prefix ( ID , " " ) } return ID } 
func New TXTRegistry ( provider provider . Provider , txt Prefix , owner ID string , cache Interval time . Duration ) ( * TXTRegistry , error ) { if owner ID = = " " { return nil , errors . New ( " " ) } mapper : = new Prefix Name Mapper ( txt Prefix ) return & TXTRegistry { provider : provider , owner ID : owner ID , mapper : mapper , cache Interval : cache Interval , } , nil } 
func ( im * TXTRegistry ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { return im . records Cache , nil } records , err : = im . provider . Records ( ) if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } label Map : = map [ string ] endpoint . Labels { } for _ , record : = range records { if record . Record Type ! = endpoint . Record Type TXT { endpoints = append ( endpoints , record ) continue } if err = = endpoint . Err Invalid Heritage { continue } if err ! = nil { return nil , err } endpoint DNSName : = im . mapper . to Endpoint Name ( record . DNSName ) label Map [ endpoint DNSName ] = labels } for _ , ep : = range endpoints { ep . Labels = endpoint . New Labels ( ) if labels , ok : = label Map [ ep . DNSName ] ; ok { for k , v : = range labels { ep . Labels [ k ] = v } } } im . records Cache Refresh Time = time . Now ( ) } return endpoints , nil } 
func ( im * TXTRegistry ) Apply Changes ( changes * plan . Changes ) error { filtered Changes : = & plan . Changes { Create : changes . Create , Update New : filter Owned Records ( im . owner ID , changes . Update New ) , Update Old : filter Owned Records ( im . owner ID , changes . Update Old ) , Delete : filter Owned Records ( im . owner ID , changes . Delete ) , } for _ , r : = range filtered Changes . Create { if r . Labels = = nil { r . Labels = make ( map [ string ] string ) } r . Labels [ endpoint . Owner Label Key ] = im . owner ID txt : = endpoint . New Endpoint ( im . mapper . to TXTName ( r . DNSName ) , endpoint . Record Type TXT , r . Labels . Serialize ( true ) ) filtered Changes . Create = append ( filtered Changes . Create , txt ) if im . cache Interval > 0 { im . add To Cache ( r ) } } for _ , r : = range filtered Changes . Delete { txt : = endpoint . New Endpoint ( im . mapper . to TXTName ( r . DNSName ) , endpoint . Record Type TXT , r . Labels . Serialize ( true ) ) if im . cache Interval > 0 { im . remove From Cache ( r ) } } } } filtered Changes . Update New = append ( filtered Changes . Update New , txt ) } } return im . provider . Apply Changes ( filtered Changes ) } 
func New Domain Filter ( domain Filters [ ] string ) Domain Filter { filters : = make ( [ ] string , len ( domain Filters ) ) } return Domain Filter { filters } } 
func ( df Domain Filter ) Match ( domain string ) bool { } for _ , filter : = range df . filters { stripped Domain : = strings . Trim Suffix ( domain , " " ) if filter = = " " { return true } else if strings . Has Prefix ( filter , " " ) & & strings . Has Suffix ( stripped Domain , filter ) { return true } else if strings . Count ( stripped Domain , " " ) = = strings . Count ( filter , " " ) { if stripped Domain = = filter { return true } } else if strings . Has Suffix ( stripped Domain , " " + filter ) { return true } } return false } 
func ( df Domain Filter ) Is Configured ( ) bool { if len ( df . filters ) = = 1 { return df . filters [ 0 ] ! = " " } return len ( df . filters ) > 0 } 
func In Memory With Logging ( ) In Memory Option { return func ( p * In Memory Provider ) { p . On Apply Changes = func ( changes * plan . Changes ) { for _ , v : = range changes . Create { log . Infof ( " " , v ) } for _ , v : = range changes . Update Old { log . Infof ( " " , v ) } for _ , v : = range changes . Update New { log . Infof ( " " , v ) } for _ , v : = range changes . Delete { log . Infof ( " " , v ) } } } } 
func In Memory Init Zones ( zones [ ] string ) In Memory Option { return func ( p * In Memory Provider ) { for _ , z : = range zones { if err : = p . Create Zone ( z ) ; err ! = nil { log . Warnf ( " " ) } } } } 
func New In Memory Provider ( opts . . . In Memory Option ) * In Memory Provider { im : = & In Memory Provider { filter : & filter { } , On Apply Changes : func ( changes * plan . Changes ) { } , On Records : func ( ) { } , domain : New Domain Filter ( [ ] string { " " } ) , client : new In Memory Client ( ) , } for _ , opt : = range opts { opt ( im ) } return im } 
func ( im * In Memory Provider ) Create Zone ( new Zone string ) error { return im . client . Create Zone ( new Zone ) } 
func ( im * In Memory Provider ) Zones ( ) map [ string ] string { return im . filter . Zones ( im . client . Zones ( ) ) } 
func ( im * In Memory Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { defer im . On Records ( ) endpoints : = make ( [ ] * endpoint . Endpoint , 0 ) for zone ID : = range im . Zones ( ) { records , err : = im . client . Records ( zone ID ) if err ! = nil { return nil , err } for _ , record : = range records { endpoints = append ( endpoints , endpoint . New Endpoint ( record . Name , record . Type , record . Target ) ) } } return endpoints , nil } 
func ( im * In Memory Provider ) Apply Changes ( changes * plan . Changes ) error { defer im . On Apply Changes ( changes ) per Zone Changes : = map [ string ] * plan . Changes { } zones : = im . Zones ( ) for zone ID : = range zones { per Zone Changes [ zone ID ] = & plan . Changes { } } for _ , ep : = range changes . Create { zone ID : = im . filter . Endpoint Zone ID ( ep , zones ) if zone ID = = " " { continue } per Zone Changes [ zone ID ] . Create = append ( per Zone Changes [ zone ID ] . Create , ep ) } for _ , ep : = range changes . Update New { zone ID : = im . filter . Endpoint Zone ID ( ep , zones ) if zone ID = = " " { continue } per Zone Changes [ zone ID ] . Update New = append ( per Zone Changes [ zone ID ] . Update New , ep ) } for _ , ep : = range changes . Update Old { zone ID : = im . filter . Endpoint Zone ID ( ep , zones ) if zone ID = = " " { continue } per Zone Changes [ zone ID ] . Update Old = append ( per Zone Changes [ zone ID ] . Update Old , ep ) } for _ , ep : = range changes . Delete { zone ID : = im . filter . Endpoint Zone ID ( ep , zones ) if zone ID = = " " { continue } per Zone Changes [ zone ID ] . Delete = append ( per Zone Changes [ zone ID ] . Delete , ep ) } for zone ID : = range per Zone Changes { change : = & in Memory Change { Create : convert To In Memory Record ( per Zone Changes [ zone ID ] . Create ) , Update New : convert To In Memory Record ( per Zone Changes [ zone ID ] . Update New ) , Update Old : convert To In Memory Record ( per Zone Changes [ zone ID ] . Update Old ) , Delete : convert To In Memory Record ( per Zone Changes [ zone ID ] . Delete ) , } err : = im . client . Apply Changes ( zone ID , change ) if err ! = nil { return err } } return nil } 
func ( f * filter ) Zones ( zones map [ string ] string ) map [ string ] string { result : = map [ string ] string { } for zone ID , zone Name : = range zones { if strings . Has Suffix ( zone Name , f . domain ) { result [ zone ID ] = zone Name } } return result } 
func ( f * filter ) Endpoint Zone ID ( endpoint * endpoint . Endpoint , zones map [ string ] string ) ( zone ID string ) { var match Zone ID , match Zone Name string for zone ID , zone Name : = range zones { if strings . Has Suffix ( endpoint . DNSName , zone Name ) & & len ( zone Name ) > len ( match Zone Name ) { match Zone Name = zone Name match Zone ID = zone ID } } return match Zone ID } 
func ( c * in Memory Client ) validate Change Batch ( zone string , changes * in Memory Change ) error { cur Zone , ok : = c . zones [ zone ] if ! ok { return Err Zone Not Found } mesh : = map [ string ] map [ string ] bool { } for _ , new Endpoint : = range changes . Create { if c . find By Type ( new Endpoint . Type , cur Zone [ new Endpoint . Name ] ) ! = nil { return Err Record Already Exists } if err : = c . update Mesh ( mesh , new Endpoint ) ; err ! = nil { return err } } for _ , update Endpoint : = range changes . Update New { if c . find By Type ( update Endpoint . Type , cur Zone [ update Endpoint . Name ] ) = = nil { return Err Record Not Found } if err : = c . update Mesh ( mesh , update Endpoint ) ; err ! = nil { return err } } for _ , update Old Endpoint : = range changes . Update Old { if rec : = c . find By Type ( update Old Endpoint . Type , cur Zone [ update Old Endpoint . Name ] ) ; rec = = nil | | rec . Target ! = update Old Endpoint . Target { return Err Record Not Found } } for _ , delete Endpoint : = range changes . Delete { if rec : = c . find By Type ( delete Endpoint . Type , cur Zone [ delete Endpoint . Name ] ) ; rec = = nil | | rec . Target ! = delete Endpoint . Target { return Err Record Not Found } if err : = c . update Mesh ( mesh , delete Endpoint ) ; err ! = nil { return err } } return nil } 
func New Zone Tag Filter ( tags [ ] string ) Zone Tag Filter { if len ( tags ) = = 1 & & len ( tags [ 0 ] ) = = 0 { tags = [ ] string { } } return Zone Tag Filter { zone Tags : tags } } 
func ( f Zone Tag Filter ) Match ( tags Map map [ string ] string ) bool { for _ , tag Filter : = range f . zone Tags { filter Parts : = strings . Split N ( tag Filter , " " , 2 ) switch len ( filter Parts ) { case 1 : if _ , has Tag : = tags Map [ filter Parts [ 0 ] ] ; ! has Tag { return false } case 2 : if value , has Tag : = tags Map [ filter Parts [ 0 ] ] ; ! has Tag | | value ! = filter Parts [ 1 ] { return false } } } return true } 
func New Ingress Source ( kube Client kubernetes . Interface , namespace , annotation Filter string , fqdn Template string , combine Fqdn Annotation bool , ignore Hostname Annotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdn Template ! = " " { tmpl , err = template . New ( " " ) . Funcs ( template . Func Map { " " : strings . Trim Prefix , } ) . Parse ( fqdn Template ) if err ! = nil { return nil , err } } ingress Informer : = informer Factory . Extensions ( ) . V 1beta 1 ( ) . Ingresses ( ) } ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } sc : = & ingress Source { client : kube Client , namespace : namespace , annotation Filter : annotation Filter , fqdn Template : tmpl , combine FQDNAnnotation : combine Fqdn Annotation , ignore Hostname Annotation : ignore Hostname Annotation , ingress Informer : ingress Informer , } return sc , nil } 
func ( sc * ingress Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { ingresses , err : = sc . ingress Informer . Lister ( ) . Ingresses ( sc . namespace ) . List ( labels . Everything ( ) ) if err ! = nil { return nil , err } ingresses , err = sc . filter By Annotations ( ingresses ) if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } for _ , ing : = range ingresses { if ok & & controller ! = controller Annotation Value { log . Debugf ( " " , ing . Namespace , ing . Name , controller , controller Annotation Value ) continue } ing Endpoints : = endpoints From Ingress ( ing , sc . ignore Hostname Annotation ) if err ! = nil { return nil , err } if sc . combine FQDNAnnotation { ing Endpoints = append ( ing Endpoints , i Endpoints . . . ) } else { ing Endpoints = i Endpoints } } if len ( ing Endpoints ) = = 0 { log . Debugf ( " " , ing . Namespace , ing . Name ) continue } log . Debugf ( " " , ing . Namespace , ing . Name , ing Endpoints ) sc . set Resource Label ( ing , ing Endpoints ) endpoints = append ( endpoints , ing Endpoints . . . ) } for _ , ep : = range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * ingress Source ) filter By Annotations ( ingresses [ ] * v 1beta 1 . Ingress ) ( [ ] * v 1beta 1 . Ingress , error ) { label Selector , err : = metav 1 . Parse To Label Selector ( sc . annotation Filter ) if err ! = nil { return nil , err } selector , err : = metav 1 . Label Selector As Selector ( label Selector ) if err ! = nil { return nil , err } } filtered List : = [ ] * v 1beta 1 . Ingress { } for _ , ingress : = range ingresses { } } return filtered List , nil } 
func endpoints From Ingress ( ing * v 1beta 1 . Ingress , ignore Hostname Annotation bool ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint ttl , err : = get TTLFrom Annotations ( ing . Annotations ) if err ! = nil { log . Warn ( err ) } targets : = get Targets From Target Annotation ( ing . Annotations ) if len ( targets ) = = 0 { targets = targets From Ingress Status ( ing . Status ) } provider Specific : = get Provider Specific Annotations ( ing . Annotations ) for _ , rule : = range ing . Spec . Rules { if rule . Host = = " " { continue } endpoints = append ( endpoints , endpoints For Hostname ( rule . Host , targets , ttl , provider Specific ) . . . ) } for _ , tls : = range ing . Spec . TLS { for _ , host : = range tls . Hosts { if host = = " " { continue } endpoints = append ( endpoints , endpoints For Hostname ( host , targets , ttl , provider Specific ) . . . ) } } for _ , hostname : = range hostname List { endpoints = append ( endpoints , endpoints For Hostname ( hostname , targets , ttl , provider Specific ) . . . ) } } return endpoints } 
func New Labels From String ( label Text string ) ( Labels , error ) { endpoint Labels : = map [ string ] string { } label Text = strings . Trim ( label Text , " \ " " ) tokens : = strings . Split ( label Text , " " ) found External DNSHeritage : = false for _ , token : = range tokens { if len ( strings . Split ( token , " " ) ) ! = 2 { continue } key : = strings . Split ( token , " " ) [ 0 ] val : = strings . Split ( token , " " ) [ 1 ] if key = = " " & & val ! = heritage { return nil , Err Invalid Heritage } if key = = " " { found External DNSHeritage = true continue } if strings . Has Prefix ( key , heritage ) { endpoint Labels [ strings . Trim Prefix ( key , heritage + " " ) ] = val } } if ! found External DNSHeritage { return nil , Err Invalid Heritage } return endpoint Labels , nil } 
func ( l Labels ) Serialize ( with Quotes bool ) string { var tokens [ ] string tokens = append ( tokens , fmt . Sprintf ( " " , heritage ) ) var keys [ ] string for key : = range l { keys = append ( keys , key ) } sort . Strings ( keys ) for _ , key : = range keys { tokens = append ( tokens , fmt . Sprintf ( " " , heritage , key , l [ key ] ) ) } if with Quotes { return fmt . Sprintf ( " \ " \ " " , strings . Join ( tokens , " " ) ) } return strings . Join ( tokens , " " ) } 
func ( p * Singleton Client Generator ) Kube Client ( ) ( kubernetes . Interface , error ) { var err error p . kube Once . Do ( func ( ) { p . kube Client , err = New Kube Client ( p . Kube Config , p . Kube Master , p . Request Timeout ) } ) return p . kube Client , err } 
func ( p * Singleton Client Generator ) Istio Client ( ) ( istiomodel . Config Store , error ) { var err error p . istio Once . Do ( func ( ) { p . istio Client , err = New Istio Client ( p . Kube Config ) } ) return p . istio Client , err } 
func By Names ( p Client Generator , names [ ] string , cfg * Config ) ( [ ] Source , error ) { sources : = [ ] Source { } for _ , name : = range names { source , err : = Build With Config ( name , p , cfg ) if err ! = nil { return nil , err } sources = append ( sources , source ) } return sources , nil } 
func Build With Config ( source string , p Client Generator , cfg * Config ) ( Source , error ) { switch source { case " " : client , err : = p . Kube Client ( ) if err ! = nil { return nil , err } return New Service Source ( client , cfg . Namespace , cfg . Annotation Filter , cfg . FQDNTemplate , cfg . Combine FQDNAnd Annotation , cfg . Compatibility , cfg . Publish Internal , cfg . Publish Host IP , cfg . Service Type Filter , cfg . Ignore Hostname Annotation ) case " " : client , err : = p . Kube Client ( ) if err ! = nil { return nil , err } return New Ingress Source ( client , cfg . Namespace , cfg . Annotation Filter , cfg . FQDNTemplate , cfg . Combine FQDNAnd Annotation , cfg . Ignore Hostname Annotation ) case " " : kubernetes Client , err : = p . Kube Client ( ) if err ! = nil { return nil , err } istio Client , err : = p . Istio Client ( ) if err ! = nil { return nil , err } return New Istio Gateway Source ( kubernetes Client , istio Client , cfg . Istio Ingress Gateway Services , cfg . Namespace , cfg . Annotation Filter , cfg . FQDNTemplate , cfg . Combine FQDNAnd Annotation , cfg . Ignore Hostname Annotation ) case " " : return New Fake Source ( cfg . FQDNTemplate ) case " " : return New Connector Source ( cfg . Connector Server ) case " " : client , err : = p . Kube Client ( ) if err ! = nil { return nil , err } crd Client , scheme , err : = New CRDClient For APIVersion Kind ( client , cfg . Kube Config , cfg . Kube Master , cfg . CRDSource APIVersion , cfg . CRDSource Kind ) if err ! = nil { return nil , err } return New CRDSource ( crd Client , cfg . Namespace , cfg . CRDSource Kind , scheme ) } return nil , Err Source Not Found } 
func New Kube Client ( kube Config , kube Master string , request Timeout time . Duration ) ( * kubernetes . Clientset , error ) { if kube Config = = " " { if _ , err : = os . Stat ( clientcmd . Recommended Home File ) ; err = = nil { kube Config = clientcmd . Recommended Home File } } config , err : = clientcmd . Build Config From Flags ( kube Master , kube Config ) if err ! = nil { return nil , err } config . Wrap Transport = func ( rt http . Round Tripper ) http . Round Tripper { return instrumented _http . New Transport ( rt , & instrumented _http . Callbacks { Path Processor : func ( path string ) string { parts : = strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) } config . Timeout = request Timeout client , err : = kubernetes . New For Config ( config ) if err ! = nil { return nil , err } log . Infof ( " " , config . Host ) return client , nil } 
func New Istio Client ( kube Config string ) ( * istiocrd . Client , error ) { if kube Config = = " " { if _ , err : = os . Stat ( clientcmd . Recommended Home File ) ; err = = nil { kube Config = clientcmd . Recommended Home File } } client , err : = istiocrd . New Client ( kube Config , " " , istiomodel . Config Descriptor { istiomodel . Gateway } , " " , ) if err ! = nil { return nil , err } log . Info ( " " ) return client , nil } 
func New CRDClient For APIVersion Kind ( client kubernetes . Interface , kube Config , kube Master , api Version , kind string ) ( * rest . RESTClient , * runtime . Scheme , error ) { if kube Config = = " " { if _ , err : = os . Stat ( clientcmd . Recommended Home File ) ; err = = nil { kube Config = clientcmd . Recommended Home File } } config , err : = clientcmd . Build Config From Flags ( kube Master , kube Config ) if err ! = nil { return nil , nil , err } group Version , err : = schema . Parse Group Version ( api Version ) if err ! = nil { return nil , nil , err } api Resource List , err : = client . Discovery ( ) . Server Resources For Group Version ( group Version . String ( ) ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , group Version . String ( ) , err ) } var crd APIResource * metav 1 . APIResource for _ , api Resource : = range api Resource List . APIResources { if api Resource . Kind = = kind { crd APIResource = & api Resource break } } if crd APIResource = = nil { return nil , nil , fmt . Errorf ( " " , kind , api Version ) } scheme : = runtime . New Scheme ( ) add Known Types ( scheme , group Version ) config . Content Config . Group Version = & group Version config . APIPath = " " config . Negotiated Serializer = serializer . Direct Codec Factory { Codec Factory : serializer . New Codec Factory ( scheme ) } crd Client , err : = rest . Unversioned RESTClient For ( config ) if err ! = nil { return nil , nil , err } return crd Client , scheme , nil } 
func New CRDSource ( crd Client rest . Interface , namespace , kind string , scheme * runtime . Scheme ) ( Source , error ) { return & crd Source { crd Resource : strings . To Lower ( kind ) + " " , namespace : namespace , crd Client : crd Client , codec : runtime . New Parameter Codec ( scheme ) , } , nil } 
func ( cs * crd Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints : = [ ] * endpoint . Endpoint { } result , err : = cs . List ( & metav 1 . List Options { } ) if err ! = nil { return nil , err } for _ , dns Endpoint : = range result . Items { endpoints = append ( endpoints , dns Endpoint . Spec . Endpoints . . . ) if dns Endpoint . Status . Observed Generation = = dns Endpoint . Generation { continue } dns Endpoint . Status . Observed Generation = dns Endpoint . Generation if err ! = nil { log . Warnf ( " " , err ) } } return endpoints , nil } 
func ( f Zone Type Filter ) Match ( zone * route 5 3 . Hosted Zone ) bool { } } case zone Type Private : return aws . Bool Value ( zone . Config . Private Zone ) } } 
func filter Owned Records ( owner ID string , eps [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { filtered : = [ ] * endpoint . Endpoint { } for _ , ep : = range eps { if endpoint Owner , ok : = ep . Labels [ endpoint . Owner Label Key ] ; ! ok | | endpoint Owner ! = owner ID { log . Debugf ( `Skipping endpoint %v because owner id does not match , found : " %s " , required : " %s " ` , ep , endpoint Owner , owner ID ) continue } filtered = append ( filtered , ep ) } return filtered } 
func New Infoblox Provider ( infoblox Config Infoblox Config ) ( * Infoblox Provider , error ) { host Config : = ibclient . Host Config { Host : infoblox Config . Host , Port : strconv . Itoa ( infoblox Config . Port ) , Username : infoblox Config . Username , Password : infoblox Config . Password , Version : infoblox Config . Version , } http Pool Connections : = lookup Env Atoi ( " " , 1 0 ) http Request Timeout : = lookup Env Atoi ( " " , 6 0 ) transport Config : = ibclient . New Transport Config ( strconv . Format Bool ( infoblox Config . SSLVerify ) , http Request Timeout , http Pool Connections , ) request Builder : = & ibclient . Wapi Request Builder { } requestor : = & ibclient . Wapi Http Requestor { } client , err : = ibclient . New Connector ( host Config , transport Config , request Builder , requestor ) if err ! = nil { return nil , err } provider : = & Infoblox Provider { client : client , domain Filter : infoblox Config . Domain Filter , zone IDFilter : infoblox Config . Zone IDFilter , dry Run : infoblox Config . Dry Run , view : infoblox Config . View , } return provider , nil } 
func ( p * Infoblox Provider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { zones , err : = p . zones ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , zone : = range zones { logrus . Debugf ( " " , zone . Fqdn ) var res A [ ] ibclient . Record A obj A : = ibclient . New Record A ( ibclient . Record A { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . Get Object ( obj A , " " , & res A ) if err ! = nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res : = range res A { endpoints = append ( endpoints , endpoint . New Endpoint ( res . Name , endpoint . Record Type A , res . Ipv 4Addr ) ) } obj H : = ibclient . New Host Record ( ibclient . Host Record { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . Get Object ( obj H , " " , & res H ) if err ! = nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res : = range res H { for _ , ip : = range res . Ipv 4Addrs { endpoints = append ( endpoints , endpoint . New Endpoint ( res . Name , endpoint . Record Type A , ip . Ipv 4Addr ) ) } } var res C [ ] ibclient . Record CNAME obj C : = ibclient . New Record CNAME ( ibclient . Record CNAME { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . Get Object ( obj C , " " , & res C ) if err ! = nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res : = range res C { endpoints = append ( endpoints , endpoint . New Endpoint ( res . Name , endpoint . Record Type CNAME , res . Canonical ) ) } var res T [ ] ibclient . Record TXT obj T : = ibclient . New Record TXT ( ibclient . Record TXT { Zone : zone . Fqdn , View : p . view , } , ) err = p . client . Get Object ( obj T , " " , & res T ) if err ! = nil { return nil , fmt . Errorf ( " " , zone . Fqdn , err ) } for _ , res : = range res T { } endpoints = append ( endpoints , endpoint . New Endpoint ( res . Name , endpoint . Record Type TXT , res . Text ) ) } } logrus . Debugf ( " " , len ( endpoints ) ) return endpoints , nil } 
func ( p * Infoblox Provider ) Apply Changes ( changes * plan . Changes ) error { zones , err : = p . zones ( ) if err ! = nil { return err } created , deleted : = p . map Changes ( zones , changes ) p . delete Records ( deleted ) p . create Records ( created ) return nil } 
func New Service Source ( kube Client kubernetes . Interface , namespace , annotation Filter string , fqdn Template string , combine Fqdn Annotation bool , compatibility string , publish Internal bool , publish Host IP bool , service Type Filter [ ] string , ignore Hostname Annotation bool ) ( Source , error ) { var ( tmpl * template . Template err error ) if fqdn Template ! = " " { tmpl , err = template . New ( " " ) . Funcs ( template . Func Map { " " : strings . Trim Prefix , } ) . Parse ( fqdn Template ) if err ! = nil { return nil , err } } service Informer : = informer Factory . Core ( ) . V 1 ( ) . Services ( ) pod Informer : = informer Factory . Core ( ) . V 1 ( ) . Pods ( ) node Informer : = informer Factory . Core ( ) . V 1 ( ) . Nodes ( ) } , } , ) pod Informer . Informer ( ) . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( obj interface { } ) { log . Debug ( " " ) } , } , ) node Informer . Informer ( ) . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( obj interface { } ) { log . Debug ( " " ) } , } , ) } ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , service Type : = range service Type Filter { service Types [ service Type ] = struct { } { } } return & service Source { client : kube Client , namespace : namespace , annotation Filter : annotation Filter , compatibility : compatibility , fqdn Template : tmpl , combine FQDNAnnotation : combine Fqdn Annotation , ignore Hostname Annotation : ignore Hostname Annotation , publish Internal : publish Internal , publish Host IP : publish Host IP , service Informer : service Informer , pod Informer : pod Informer , node Informer : node Informer , service Type Filter : service Types , } , nil } 
func ( sc * service Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { services , err : = sc . service Informer . Lister ( ) . Services ( sc . namespace ) . List ( labels . Everything ( ) ) if err ! = nil { return nil , err } services , err = sc . filter By Annotations ( services ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } for _ , svc : = range services { if ok & & controller ! = controller Annotation Value { log . Debugf ( " " , svc . Namespace , svc . Name , controller , controller Annotation Value ) continue } svc Endpoints : = sc . endpoints ( svc , node Targets ) } if err ! = nil { return nil , err } if sc . combine FQDNAnnotation { svc Endpoints = append ( svc Endpoints , s Endpoints . . . ) } else { svc Endpoints = s Endpoints } } if len ( svc Endpoints ) = = 0 { log . Debugf ( " " , svc . Namespace , svc . Name ) continue } log . Debugf ( " " , svc . Namespace , svc . Name , svc Endpoints ) sc . set Resource Label ( svc , svc Endpoints ) endpoints = append ( endpoints , svc Endpoints . . . ) } for _ , ep : = range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * service Source ) endpoints ( svc * v 1 . Service , node Targets endpoint . Targets ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint hostname List : = get Hostnames From Annotations ( svc . Annotations ) for _ , hostname : = range hostname List { endpoints = append ( endpoints , sc . generate Endpoints ( svc , hostname , node Targets , provider Specific ) . . . ) } } return endpoints } 
func ( sc * service Source ) filter By Annotations ( services [ ] * v 1 . Service ) ( [ ] * v 1 . Service , error ) { label Selector , err : = metav 1 . Parse To Label Selector ( sc . annotation Filter ) if err ! = nil { return nil , err } selector , err : = metav 1 . Label Selector As Selector ( label Selector ) if err ! = nil { return nil , err } } filtered List : = [ ] * v 1 . Service { } for _ , service : = range services { } } return filtered List , nil } 
func ( sc * service Source ) filter By Service Type ( services [ ] * v 1 . Service ) [ ] * v 1 . Service { filtered List : = [ ] * v 1 . Service { } for _ , service : = range services { } } return filtered List } 
func ( t plan Table ) get Updates ( ) ( update New [ ] * endpoint . Endpoint , update Old [ ] * endpoint . Endpoint ) { for _ , row : = range t . rows { if row . current ! = nil & & len ( row . candidates ) > 0 { update New = append ( update New , update ) update Old = append ( update Old , row . current ) } continue } } return } 
func ( p * Plan ) Calculate ( ) * Plan { t : = new Plan Table ( ) for _ , current : = range filter Records For Plan ( p . Current ) { t . add Current ( current ) } for _ , desired : = range filter Records For Plan ( p . Desired ) { t . add Candidate ( desired ) } changes : = & Changes { } changes . Create = t . get Creates ( ) changes . Delete = t . get Deletes ( ) changes . Update New , changes . Update Old = t . get Updates ( ) for _ , pol : = range p . Policies { changes = pol . Apply ( changes ) } plan : = & Plan { Current : p . Current , Desired : p . Desired , Changes : changes , } return plan } 
func filter Records For Plan ( records [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { filtered : = [ ] * endpoint . Endpoint { } for _ , record : = range records { default : continue } } return filtered } 
func normalize DNSName ( dns Name string ) string { s : = strings . Trim Space ( strings . To Lower ( dns Name ) ) if ! strings . Has Suffix ( s , " " ) { s + = " " } return s } 
func New Exoscale Provider ( endpoint , api Key , api Secret string , dry Run bool , opts . . . Exoscale Option ) * Exoscale Provider { client : = egoscale . New Client ( endpoint , api Key , api Secret ) return New Exoscale Provider With Client ( endpoint , api Key , api Secret , client , dry Run , opts . . . ) } 
func New Exoscale Provider With Client ( endpoint , api Key , api Secret string , client Egoscale Client I , dry Run bool , opts . . . Exoscale Option ) * Exoscale Provider { ep : = & Exoscale Provider { filter : & zone Filter { } , On Apply Changes : func ( changes * plan . Changes ) { } , domain : New Domain Filter ( [ ] string { " " } ) , client : client , dry Run : dry Run , } for _ , opt : = range opts { opt ( ep ) } return ep } 
func ( ep * Exoscale Provider ) Apply Changes ( changes * plan . Changes ) error { ep . On Apply Changes ( changes ) if ep . dry Run { log . Infof ( " " , changes . Delete ) log . Infof ( " " , changes . Create ) log . Infof ( " " , merge ( changes . Update Old , changes . Update New ) ) return nil } zones , err : = ep . get Zones ( ) if err ! = nil { return err } for _ , epoint : = range changes . Create { if ep . domain . Match ( epoint . DNSName ) { if zone ID , name : = ep . filter . Endpoint Zone ID ( epoint , zones ) ; zone ID ! = 0 { rec : = egoscale . DNSRecord { Name : name , Record Type : epoint . Record Type , TTL : int ( epoint . Record TTL ) , Content : epoint . Targets [ 0 ] , } _ , err : = ep . client . Create Record ( zones [ zone ID ] , rec ) if err ! = nil { return err } } } } for _ , epoint : = range changes . Update New { if ep . domain . Match ( epoint . DNSName ) { if zone ID , name : = ep . filter . Endpoint Zone ID ( epoint , zones ) ; zone ID ! = 0 { records , err : = ep . client . Get Records ( zones [ zone ID ] ) if err ! = nil { return err } for _ , r : = range records { if r . Name = = name { rec : = egoscale . Update DNSRecord { ID : r . ID , Domain ID : r . Domain ID , Name : name , Record Type : epoint . Record Type , TTL : int ( epoint . Record TTL ) , Content : epoint . Targets [ 0 ] , Prio : r . Prio , } if _ , err : = ep . client . Update Record ( zones [ zone ID ] , rec ) ; err ! = nil { return err } break } } } } } for _ , epoint : = range changes . Update Old { } for _ , epoint : = range changes . Delete { if ep . domain . Match ( epoint . DNSName ) { if zone ID , name : = ep . filter . Endpoint Zone ID ( epoint , zones ) ; zone ID ! = 0 { records , err : = ep . client . Get Records ( zones [ zone ID ] ) if err ! = nil { return err } for _ , r : = range records { if r . Name = = name { if err : = ep . client . Delete Record ( zones [ zone ID ] , r . ID ) ; err ! = nil { return err } break } } } } } return nil } 
func ( ep * Exoscale Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints : = make ( [ ] * endpoint . Endpoint , 0 ) domains , err : = ep . client . Get Domains ( ) if err ! = nil { return nil , err } for _ , d : = range domains { record , err : = ep . client . Get Records ( d . Name ) if err ! = nil { return nil , err } for _ , r : = range record { switch r . Record Type { case egoscale . A . String ( ) , egoscale . CNAME . String ( ) , egoscale . TXT . String ( ) : break default : continue } ep : = endpoint . New Endpoint With TTL ( r . Name + " " + d . Name , r . Record Type , endpoint . TTL ( r . TTL ) , r . Content ) endpoints = append ( endpoints , ep ) } } log . Infof ( " " , len ( endpoints ) ) return endpoints , nil } 
func Exoscale With Logging ( ) Exoscale Option { return func ( p * Exoscale Provider ) { p . On Apply Changes = func ( changes * plan . Changes ) { for _ , v : = range changes . Create { log . Infof ( " " , v ) } for _ , v : = range changes . Update Old { log . Infof ( " " , v ) } for _ , v : = range changes . Update New { log . Infof ( " " , v ) } for _ , v : = range changes . Delete { log . Infof ( " " , v ) } } } } 
func ( f * zone Filter ) Zones ( zones map [ int 6 4 ] string ) map [ int 6 4 ] string { result : = map [ int 6 4 ] string { } for zone ID , zone Name : = range zones { if strings . Has Suffix ( zone Name , f . domain ) { result [ zone ID ] = zone Name } } return result } 
func ( f * zone Filter ) Endpoint Zone ID ( endpoint * endpoint . Endpoint , zones map [ int 6 4 ] string ) ( zone ID int 6 4 , name string ) { var match Zone ID int 6 4 var match Zone Name string for zone ID , zone Name : = range zones { if strings . Has Suffix ( endpoint . DNSName , " " + zone Name ) & & len ( zone Name ) > len ( match Zone Name ) { match Zone Name = zone Name match Zone ID = zone ID name = strings . Trim Suffix ( endpoint . DNSName , " " + zone Name ) } } return match Zone ID , name } 
func New Linode Provider ( domain Filter Domain Filter , dry Run bool , app Version string ) ( * Linode Provider , error ) { token , ok : = os . Lookup Env ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } token Source : = oauth 2 . Static Token Source ( & oauth 2 . Token { Access Token : token } ) oauth 2Client : = & http . Client { Transport : & oauth 2 . Transport { Source : token Source , } , } linode Client : = linodego . New Client ( oauth 2Client ) linode Client . Set User Agent ( fmt . Sprintf ( " " , app Version , linodego . Version ) ) provider : = & Linode Provider { Client : & linode Client , domain Filter : domain Filter , Dry Run : dry Run , } return provider , nil } 
func ( p * Linode Provider ) Zones ( ) ( [ ] * linodego . Domain , error ) { zones , err : = p . fetch Zones ( ) if err ! = nil { return nil , err } return zones , nil } 
func ( p * Linode Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone : = range zones { records , err : = p . fetch Records ( zone . ID ) if err ! = nil { return nil , err } for _ , r : = range records { if supported Record Type ( string ( r . Type ) ) { name : = fmt . Sprintf ( " " , r . Name , zone . Domain ) } endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( name , string ( r . Type ) , endpoint . TTL ( r . TTLSec ) , r . Target ) ) } } } return endpoints , nil } 
func ( p * Linode Provider ) submit Changes ( changes Linode Changes ) error { for _ , change : = range changes . Creates { log Fields : = log . Fields { " " : change . Options . Name , " " : change . Options . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { log . With Fields ( log Fields ) . Info ( " " ) } else { if _ , err : = p . Client . Create Domain Record ( context . TODO ( ) , change . Domain . ID , change . Options ) ; err ! = nil { log . With Fields ( log Fields ) . Errorf ( " " , err , ) } } } for _ , change : = range changes . Deletes { log Fields : = log . Fields { " " : change . Domain Record . Name , " " : change . Domain Record . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { log . With Fields ( log Fields ) . Info ( " " ) } else { if err : = p . Client . Delete Domain Record ( context . TODO ( ) , change . Domain . ID , change . Domain Record . ID ) ; err ! = nil { log . With Fields ( log Fields ) . Errorf ( " " , err , ) } } } for _ , change : = range changes . Updates { log Fields : = log . Fields { " " : change . Options . Name , " " : change . Options . Type , " " : " " , " " : change . Domain . Domain , " " : change . Domain . ID , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { log . With Fields ( log Fields ) . Info ( " " ) } else { if _ , err : = p . Client . Update Domain Record ( context . TODO ( ) , change . Domain . ID , change . Domain Record . ID , change . Options ) ; err ! = nil { log . With Fields ( log Fields ) . Errorf ( " " , err , ) } } } return nil } 
func ( p * Linode Provider ) Apply Changes ( changes * plan . Changes ) error { records By Zone ID : = make ( map [ string ] [ ] * linodego . Domain Record ) zones , err : = p . fetch Zones ( ) if err ! = nil { return err } zones By ID : = make ( map [ string ] * linodego . Domain ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( strconv . Itoa ( z . ID ) , z . Domain ) zones By ID [ strconv . Itoa ( z . ID ) ] = z } if err ! = nil { return err } records By Zone ID [ strconv . Itoa ( zone . ID ) ] = append ( records By Zone ID [ strconv . Itoa ( zone . ID ) ] , records . . . ) } creates By Zone : = endpoints By Zone ( zone Name IDMapper , changes . Create ) updates By Zone : = endpoints By Zone ( zone Name IDMapper , changes . Update New ) deletes By Zone : = endpoints By Zone ( zone Name IDMapper , changes . Delete ) var linode Creates [ ] * Linode Change Create var linode Updates [ ] * Linode Change Update var linode Deletes [ ] * Linode Change Delete if len ( creates ) = = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : zone . Domain , } ) . Debug ( " " ) continue } records : = records By Zone ID [ zone ID ] for _ , ep : = range creates { matched Records : = get Record ID ( records , zone , ep ) if len ( matched Records ) ! = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : zone . Domain , " " : ep . DNSName , " " : ep . Record Type , } ) . Warn ( " " ) } record Type , err : = convert Record Type ( ep . Record Type ) if err ! = nil { return err } for _ , target : = range ep . Targets { linode Creates = append ( linode Creates , & Linode Change Create { Domain : zone , Options : linodego . Domain Record Create Options { Target : target , Name : get Stripped Record Name ( zone , ep ) , Type : record Type , Weight : get Weight ( ) , Port : get Port ( ) , Priority : get Priority ( ) , TTLSec : int ( ep . Record TTL ) , } , } ) } } } if len ( updates ) = = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : zone . Domain , } ) . Debug ( " " ) continue } records : = records By Zone ID [ zone ID ] for _ , ep : = range updates { matched Records : = get Record ID ( records , zone , ep ) if len ( matched Records ) = = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : ep . DNSName , " " : zone . Domain , " " : ep . Record Type , } ) . Warn ( " " ) } record Type , err : = convert Record Type ( ep . Record Type ) if err ! = nil { return err } matched Records By Target : = make ( map [ string ] * linodego . Domain Record ) for _ , record : = range matched Records { matched Records By Target [ record . Target ] = record } for _ , target : = range ep . Targets { if record , ok : = matched Records By Target [ target ] ; ok { log . With Fields ( log . Fields { " " : zone ID , " " : ep . DNSName , " " : zone . Domain , " " : ep . Record Type , " " : target , } ) . Warn ( " " ) linode Updates = append ( linode Updates , & Linode Change Update { Domain : zone , Domain Record : record , Options : linodego . Domain Record Update Options { Target : target , Name : get Stripped Record Name ( zone , ep ) , Type : record Type , Weight : get Weight ( ) , Port : get Port ( ) , Priority : get Priority ( ) , TTLSec : int ( ep . Record TTL ) , } , } ) delete ( matched Records By Target , target ) } else { linode Creates = append ( linode Creates , & Linode Change Create { Domain : zone , Options : linodego . Domain Record Create Options { Target : target , Name : get Stripped Record Name ( zone , ep ) , Type : record Type , Weight : get Weight ( ) , Port : get Port ( ) , Priority : get Priority ( ) , TTLSec : int ( ep . Record TTL ) , } , } ) } } linode Deletes = append ( linode Deletes , & Linode Change Delete { Domain : zone , Domain Record : record , } ) } } } if len ( deletes ) = = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : zone . Domain , } ) . Debug ( " " ) continue } records : = records By Zone ID [ zone ID ] for _ , ep : = range deletes { matched Records : = get Record ID ( records , zone , ep ) if len ( matched Records ) = = 0 { log . With Fields ( log . Fields { " " : zone ID , " " : ep . DNSName , " " : zone . Domain , " " : ep . Record Type , } ) . Warn ( " " ) } for _ , record : = range matched Records { linode Deletes = append ( linode Deletes , & Linode Change Delete { Domain : zone , Domain Record : record , } ) } } } return p . submit Changes ( Linode Changes { Creates : linode Creates , Deletes : linode Deletes , Updates : linode Updates , } ) } 
func New Targets ( target . . . string ) Targets { t : = make ( Targets , 0 , len ( target ) ) t = append ( t , target . . . ) return t } 
func ( t Targets ) Same ( o Targets ) bool { if len ( t ) ! = len ( o ) { return false } sort . Stable ( t ) sort . Stable ( o ) for i , e : = range t { if e ! = o [ i ] { return false } } return true } 
func ( t Targets ) Is Less ( o Targets ) bool { if len ( t ) < len ( o ) { return true } if len ( t ) > len ( o ) { return false } sort . Sort ( t ) sort . Sort ( o ) for i , e : = range t { if e ! = o [ i ] { return e < o [ i ] } } return false } 
func New Endpoint ( dns Name , record Type string , targets . . . string ) * Endpoint { return New Endpoint With TTL ( dns Name , record Type , TTL ( 0 ) , targets . . . ) } 
func New Endpoint With TTL ( dns Name , record Type string , ttl TTL , targets . . . string ) * Endpoint { clean Targets : = make ( [ ] string , len ( targets ) ) for idx , target : = range targets { clean Targets [ idx ] = strings . Trim Suffix ( target , " " ) } return & Endpoint { DNSName : strings . Trim Suffix ( dns Name , " " ) , Targets : clean Targets , Record Type : record Type , Labels : New Labels ( ) , Record TTL : ttl , } } 
func ( e * Endpoint ) With Provider Specific ( key , value string ) * Endpoint { if e . Provider Specific = = nil { e . Provider Specific = Provider Specific { } } e . Provider Specific = append ( e . Provider Specific , Provider Specific Property { Name : key , Value : value } ) return e } 
func ( e * Endpoint ) Get Provider Specific Property ( key string ) ( Provider Specific Property , bool ) { for _ , provider Specific : = range e . Provider Specific { if provider Specific . Name = = key { return provider Specific , true } } return Provider Specific Property { } , false } 
func ( f Zone IDFilter ) Match ( zone ID string ) bool { } for _ , id : = range f . zone IDs { if strings . Has Suffix ( zone ID , id ) { return true } } return false } 
func Validate Config ( cfg * externaldns . Config ) error { } if len ( cfg . Sources ) = = 0 { return errors . New ( " " ) } if cfg . Provider = = " " { return errors . New ( " " ) } } } } if cfg . Infoblox Wapi Password = = " " { return errors . New ( " " ) } } if cfg . Provider = = " " { if cfg . Dyn Username = = " " { return errors . New ( " " ) } if cfg . Dyn Customer Name = = " " { return errors . New ( " " ) } if cfg . Dyn Min TTLSeconds < 0 { return errors . New ( " " ) } } if cfg . Ignore Hostname Annotation & & cfg . FQDNTemplate = = " " { return errors . New ( " " ) } return nil } 
func ( n NS 1Domain Service ) Create Record ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Create ( r ) } 
func ( n NS 1Domain Service ) Delete Record ( zone string , domain string , t string ) ( * http . Response , error ) { return n . service . Records . Delete ( zone , domain , t ) } 
func ( n NS 1Domain Service ) Update Record ( r * dns . Record ) ( * http . Response , error ) { return n . service . Records . Update ( r ) } 
func ( n NS 1Domain Service ) Get Zone ( zone string ) ( * dns . Zone , * http . Response , error ) { return n . service . Zones . Get ( zone ) } 
func ( n NS 1Domain Service ) List Zones ( ) ( [ ] * dns . Zone , * http . Response , error ) { return n . service . Zones . List ( ) } 
func ( p * NS 1Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err : = p . zones Filtered ( ) if err ! = nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone : = range zones { if err ! = nil { return nil , err } for _ , record : = range zone Data . Records { if supported Record Type ( record . Type ) { endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( record . Domain , record . Type , endpoint . TTL ( record . TTL ) , record . Short Ans . . . , ) , ) } } } return endpoints , nil } 
func ns 1Build Record ( zone Name string , change * ns 1Change ) * dns . Record { record : = dns . New Record ( zone Name , change . Endpoint . DNSName , change . Endpoint . Record Type ) for _ , v : = range change . Endpoint . Targets { record . Add Answer ( dns . New Answer ( strings . Split ( v , " " ) ) ) } if change . Endpoint . Record TTL . Is Configured ( ) { ttl = int ( change . Endpoint . Record TTL ) } record . TTL = ttl return record } 
func ( p * NS 1Provider ) ns 1Submit Changes ( changes [ ] * ns 1Change ) error { } zones , err : = p . zones Filtered ( ) if err ! = nil { return err } for zone Name , changes : = range changes By Zone { for _ , change : = range changes { record : = ns 1Build Record ( zone Name , change ) log Fields : = log . Fields { " " : record . Domain , " " : record . Type , " " : record . TTL , " " : change . Action , " " : zone Name , } log . With Fields ( log Fields ) . Info ( " " ) if p . dry Run { continue } switch change . Action { case ns 1Create : _ , err : = p . client . Create Record ( record ) if err ! = nil { return err } case ns 1Delete : _ , err : = p . client . Delete Record ( zone Name , record . Domain , record . Type ) if err ! = nil { return err } case ns 1Update : _ , err : = p . client . Update Record ( record ) if err ! = nil { return err } } } } return nil } 
func ( p * NS 1Provider ) zones Filtered ( ) ( [ ] * dns . Zone , error ) { if err ! = nil { return nil , err } to Return : = [ ] * dns . Zone { } for _ , z : = range zones { if p . domain Filter . Match ( z . Zone ) & & p . zone IDFilter . Match ( z . ID ) { to Return = append ( to Return , z ) log . Debugf ( " " , z . Zone ) } else { log . Debugf ( " " , z . Zone ) } } return to Return , nil } 
func ( p * NS 1Provider ) Apply Changes ( changes * plan . Changes ) error { combined Changes : = make ( [ ] * ns 1Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , new NS 1Changes ( ns 1Create , changes . Create ) . . . ) combined Changes = append ( combined Changes , new NS 1Changes ( ns 1Update , changes . Update New ) . . . ) combined Changes = append ( combined Changes , new NS 1Changes ( ns 1Delete , changes . Delete ) . . . ) return p . ns 1Submit Changes ( combined Changes ) } 
func new NS 1Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * ns 1Change { changes : = make ( [ ] * ns 1Change , 0 , len ( endpoints ) ) for _ , endpoint : = range endpoints { changes = append ( changes , & ns 1Change { Action : action , Endpoint : endpoint , } , ) } return changes } 
func ns 1Changes By Zone ( zones [ ] * dns . Zone , change Sets [ ] * ns 1Change ) map [ string ] [ ] * ns 1Change { changes : = make ( map [ string ] [ ] * ns 1Change ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( z . Zone , z . Zone ) changes [ z . Zone ] = [ ] * ns 1Change { } } for _ , c : = range change Sets { zone , _ : = zone Name IDMapper . Find Zone ( c . Endpoint . DNSName ) if zone = = " " { log . Debugf ( " " , c . Endpoint . DNSName ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func all Log Levels As Strings ( ) [ ] string { var levels [ ] string for _ , level : = range logrus . All Levels { levels = append ( levels , level . String ( ) ) } return levels } 
func ( cfg * Config ) Parse Flags ( args [ ] string ) error { app : = kingpin . New ( " " , " \n \n " ) app . Version ( Version ) app . Default Envars ( ) app . Flag ( " " , " " ) . Default ( default Config . Kube Config ) . String Var ( & cfg . Kube Config ) app . Flag ( " " , " " ) . Default ( default Config . Request Timeout . String ( ) ) . Duration Var ( & cfg . Request Timeout ) app . Flag ( " " , " " ) . Default ( default Config . Namespace ) . String Var ( & cfg . Namespace ) app . Flag ( " " , " " ) . Default ( default Config . Annotation Filter ) . String Var ( & cfg . Annotation Filter ) app . Flag ( " " , " " ) . Default ( default Config . FQDNTemplate ) . String Var ( & cfg . FQDNTemplate ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Combine FQDNAnd Annotation ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Ignore Hostname Annotation ) app . Flag ( " " , " " ) . Default ( default Config . Compatibility ) . Enum Var ( & cfg . Compatibility , " " , " " , " " ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Publish Internal ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Publish Host IP ) app . Flag ( " " , " " ) . Default ( default Config . Connector Source Server ) . String Var ( & cfg . Connector Source Server ) app . Flag ( " " , " " ) . Default ( default Config . CRDSource APIVersion ) . String Var ( & cfg . CRDSource APIVersion ) app . Flag ( " " , " " ) . Default ( default Config . CRDSource Kind ) . String Var ( & cfg . CRDSource Kind ) app . Flag ( " " , " " ) . Strings Var ( & cfg . Service Type Filter ) app . Flag ( " " , " " ) . Default ( " " ) . Strings Var ( & cfg . Domain Filter ) app . Flag ( " " , " " ) . Default ( " " ) . Strings Var ( & cfg . Zone IDFilter ) app . Flag ( " " , " " ) . Default ( default Config . Google Project ) . String Var ( & cfg . Google Project ) app . Flag ( " " , " " ) . Default ( default Config . Alibaba Cloud Config File ) . String Var ( & cfg . Alibaba Cloud Config File ) app . Flag ( " " , " " ) . Default ( default Config . Alibaba Cloud Zone Type ) . Enum Var ( & cfg . Alibaba Cloud Zone Type , " " , " " , " " ) app . Flag ( " " , " " ) . Default ( default Config . AWSZone Type ) . Enum Var ( & cfg . AWSZone Type , " " , " " , " " ) app . Flag ( " " , " " ) . Default ( " " ) . Strings Var ( & cfg . AWSZone Tag Filter ) app . Flag ( " " , " " ) . Default ( default Config . AWSAssume Role ) . String Var ( & cfg . AWSAssume Role ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( default Config . AWSBatch Change Size ) ) . Int Var ( & cfg . AWSBatch Change Size ) app . Flag ( " " , " " ) . Default ( default Config . AWSBatch Change Interval . String ( ) ) . Duration Var ( & cfg . AWSBatch Change Interval ) app . Flag ( " " , " " ) . Default ( strconv . Format Bool ( default Config . AWSEvaluate Target Health ) ) . Bool Var ( & cfg . AWSEvaluate Target Health ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( default Config . AWSAPIRetries ) ) . Int Var ( & cfg . AWSAPIRetries ) app . Flag ( " " , " " ) . Default ( default Config . Azure Config File ) . String Var ( & cfg . Azure Config File ) app . Flag ( " " , " " ) . Default ( default Config . Azure Resource Group ) . String Var ( & cfg . Azure Resource Group ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Cloudflare Proxied ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( default Config . Cloudflare Zones Per Page ) ) . Int Var ( & cfg . Cloudflare Zones Per Page ) app . Flag ( " " , " " ) . Default ( default Config . Infoblox Grid Host ) . String Var ( & cfg . Infoblox Grid Host ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( default Config . Infoblox Wapi Port ) ) . Int Var ( & cfg . Infoblox Wapi Port ) app . Flag ( " " , " " ) . Default ( default Config . Infoblox Wapi Username ) . String Var ( & cfg . Infoblox Wapi Username ) app . Flag ( " " , " " ) . Default ( default Config . Infoblox Wapi Password ) . String Var ( & cfg . Infoblox Wapi Password ) app . Flag ( " " , " " ) . Default ( default Config . Infoblox Wapi Version ) . String Var ( & cfg . Infoblox Wapi Version ) app . Flag ( " " , " " ) . Default ( strconv . Format Bool ( default Config . Infoblox SSLVerify ) ) . Bool Var ( & cfg . Infoblox SSLVerify ) app . Flag ( " " , " \ " \ " " ) . Default ( default Config . Infoblox View ) . String Var ( & cfg . Infoblox View ) app . Flag ( " " , " " ) . Default ( " " ) . String Var ( & cfg . Dyn Customer Name ) app . Flag ( " " , " " ) . Default ( " " ) . String Var ( & cfg . Dyn Username ) app . Flag ( " " , " " ) . Default ( " " ) . String Var ( & cfg . Dyn Password ) app . Flag ( " " , " " ) . Int Var ( & cfg . Dyn Min TTLSeconds ) app . Flag ( " " , " " ) . Default ( default Config . OCIConfig File ) . String Var ( & cfg . OCIConfig File ) app . Flag ( " " , " " ) . Default ( strconv . Format Bool ( default Config . Rcodezero TXTEncrypt ) ) . Bool Var ( & cfg . Rcodezero TXTEncrypt ) app . Flag ( " " , " " ) . Default ( " " ) . Strings Var ( & cfg . In Memory Zones ) app . Flag ( " " , " " ) . Default ( default Config . PDNSServer ) . String Var ( & cfg . PDNSServer ) app . Flag ( " " , " " ) . Default ( default Config . PDNSAPIKey ) . String Var ( & cfg . PDNSAPIKey ) app . Flag ( " " , " " ) . Default ( strconv . Format Bool ( default Config . PDNSTLSEnabled ) ) . Bool Var ( & cfg . PDNSTLSEnabled ) app . Flag ( " " , " " ) . Default ( default Config . TLSClient Cert ) . String Var ( & cfg . TLSClient Cert ) app . Flag ( " " , " " ) . Default ( default Config . TLSClient Cert Key ) . String Var ( & cfg . TLSClient Cert Key ) app . Flag ( " " , " " ) . Default ( default Config . Exoscale Endpoint ) . String Var ( & cfg . Exoscale Endpoint ) app . Flag ( " " , " " ) . Default ( default Config . Exoscale APIKey ) . String Var ( & cfg . Exoscale APIKey ) app . Flag ( " " , " " ) . Default ( default Config . Exoscale APISecret ) . String Var ( & cfg . Exoscale APISecret ) app . Flag ( " " , " " ) . Default ( strconv . Itoa ( default Config . RFC 2 1 3 6Port ) ) . Int Var ( & cfg . RFC 2 1 3 6Port ) app . Flag ( " " , " " ) . Default ( default Config . RFC 2 1 3 6Zone ) . String Var ( & cfg . RFC 2 1 3 6Zone ) app . Flag ( " " , " " ) . Default ( strconv . Format Bool ( default Config . RFC 2 1 3 6Insecure ) ) . Bool Var ( & cfg . RFC 2 1 3 6Insecure ) app . Flag ( " " , " " ) . Default ( default Config . RFC 2 1 3 6TSIGKey Name ) . String Var ( & cfg . RFC 2 1 3 6TSIGKey Name ) app . Flag ( " " , " " ) . Default ( default Config . RFC 2 1 3 6TSIGSecret ) . String Var ( & cfg . RFC 2 1 3 6TSIGSecret ) app . Flag ( " " , " " ) . Default ( default Config . RFC 2 1 3 6TSIGSecret Alg ) . String Var ( & cfg . RFC 2 1 3 6TSIGSecret Alg ) app . Flag ( " " , " " ) . Bool Var ( & cfg . RFC 2 1 3 6TAXFR ) app . Flag ( " " , " " ) . Default ( default Config . TXTOwner ID ) . String Var ( & cfg . TXTOwner ID ) app . Flag ( " " , " " ) . Default ( default Config . TXTPrefix ) . String Var ( & cfg . TXTPrefix ) app . Flag ( " " , " " ) . Default ( default Config . Interval . String ( ) ) . Duration Var ( & cfg . Interval ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Once ) app . Flag ( " " , " " ) . Bool Var ( & cfg . Dry Run ) app . Flag ( " " , " " ) . Default ( default Config . Metrics Address ) . String Var ( & cfg . Metrics Address ) app . Flag ( " " , " " ) . Default ( default Config . Log Level ) . Enum Var ( & cfg . Log Level , all Log Levels As Strings ( ) . . . ) _ , err : = app . Parse ( args ) if err ! = nil { return err } return nil } 
func ( p * Upsert Only Policy ) Apply ( changes * Changes ) * Changes { return & Changes { Create : changes . Create , Update Old : changes . Update Old , Update New : changes . Update New , } } 
func ( c * Controller ) Run Once ( ) error { records , err : = c . Registry . Records ( ) if err ! = nil { registry Errors . Inc ( ) return err } registry Endpoints Total . Set ( float 6 4 ( len ( records ) ) ) endpoints , err : = c . Source . Endpoints ( ) if err ! = nil { source Errors . Inc ( ) return err } source Endpoints Total . Set ( float 6 4 ( len ( endpoints ) ) ) plan : = & plan . Plan { Policies : [ ] plan . Policy { c . Policy } , Current : records , Desired : endpoints , } plan = plan . Calculate ( ) err = c . Registry . Apply Changes ( plan . Changes ) if err ! = nil { registry Errors . Inc ( ) return err } return nil } 
func ( c * Controller ) Run ( stop Chan < - chan struct { } ) { ticker : = time . New Ticker ( c . Interval ) defer ticker . Stop ( ) for { err : = c . Run Once ( ) if err ! = nil { log . Error ( err ) } select { case < - ticker . C : case < - stop Chan : log . Info ( " " ) return } } } 
func New Cloud Flare Provider ( domain Filter Domain Filter , zone IDFilter Zone IDFilter , zones Per Page int , proxied By Default bool , dry Run bool ) ( * Cloud Flare Provider , error ) { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } provider : = & Cloud Flare Provider { return provider , nil } 
func ( p * Cloud Flare Provider ) Zones ( ) ( [ ] cloudflare . Zone , error ) { result : = [ ] cloudflare . Zone { } ctx : = context . TODO ( ) p . Pagination Options . Page = 1 for { zones Response , err : = p . Client . List Zones Context ( ctx , cloudflare . With Pagination ( p . Pagination Options ) ) if err ! = nil { return nil , err } for _ , zone : = range zones Response . Result { if ! p . domain Filter . Match ( zone . Name ) { continue } if ! p . zone IDFilter . Match ( zone . ID ) { continue } result = append ( result , zone ) } if p . Pagination Options . Page = = zones Response . Result Info . Total Pages { break } p . Pagination Options . Page + + } return result , nil } 
func ( p * Cloud Flare Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } for _ , zone : = range zones { records , err : = p . Client . DNSRecords ( zone . ID , cloudflare . DNSRecord { } ) if err ! = nil { return nil , err } for _ , r : = range records { if supported Record Type ( r . Type ) { endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , r . Content ) . With Provider Specific ( source . Cloudflare Proxied Key , strconv . Format Bool ( r . Proxied ) ) ) } } } return endpoints , nil } 
func ( p * Cloud Flare Provider ) Apply Changes ( changes * plan . Changes ) error { proxied By Default : = p . proxied By Default combined Changes : = make ( [ ] * cloud Flare Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , new Cloud Flare Changes ( cloud Flare Create , changes . Create , proxied By Default ) . . . ) combined Changes = append ( combined Changes , new Cloud Flare Changes ( cloud Flare Update , changes . Update New , proxied By Default ) . . . ) combined Changes = append ( combined Changes , new Cloud Flare Changes ( cloud Flare Delete , changes . Delete , proxied By Default ) . . . ) return p . submit Changes ( combined Changes ) } 
func ( p * Cloud Flare Provider ) submit Changes ( changes [ ] * cloud Flare Change ) error { } zones , err : = p . Zones ( ) if err ! = nil { return err } for zone ID , changes : = range changes By Zone { records , err : = p . Client . DNSRecords ( zone ID , cloudflare . DNSRecord { } ) if err ! = nil { return fmt . Errorf ( " " , err ) } for _ , change : = range changes { log Fields : = log . Fields { " " : change . Resource Record Set [ 0 ] . Name , " " : change . Resource Record Set [ 0 ] . Type , " " : change . Resource Record Set [ 0 ] . TTL , " " : len ( change . Resource Record Set ) , " " : change . Action , " " : zone ID , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { continue } record IDs : = p . get Record IDs ( records , change . Resource Record Set [ 0 ] ) if err ! = nil { log . With Fields ( log Fields ) . Errorf ( " " , err ) } } } if change . Action = = cloud Flare Create | | change . Action = = cloud Flare Update { for _ , record : = range change . Resource Record Set { _ , err : = p . Client . Create DNSRecord ( zone ID , record ) if err ! = nil { log . With Fields ( log Fields ) . Errorf ( " " , err ) } } } } } return nil } 
func ( p * Cloud Flare Provider ) changes By Zone ( zones [ ] cloudflare . Zone , change Set [ ] * cloud Flare Change ) map [ string ] [ ] * cloud Flare Change { changes : = make ( map [ string ] [ ] * cloud Flare Change ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( z . ID , z . Name ) changes [ z . ID ] = [ ] * cloud Flare Change { } } for _ , c : = range change Set { zone ID , _ : = zone Name IDMapper . Find Zone ( c . Resource Record Set [ 0 ] . Name ) if zone ID = = " " { log . Debugf ( " " , c . Resource Record Set [ 0 ] . Name ) continue } changes [ zone ID ] = append ( changes [ zone ID ] , c ) } return changes } 
func new Cloud Flare Changes ( action string , endpoints [ ] * endpoint . Endpoint , proxied By Default bool ) [ ] * cloud Flare Change { changes : = make ( [ ] * cloud Flare Change , 0 , len ( endpoints ) ) for _ , endpoint : = range endpoints { changes = append ( changes , new Cloud Flare Change ( action , endpoint , proxied By Default ) ) } return changes } 
func ( p * dnsimple Provider ) Get Account ID ( credentials dnsimple . Credentials , client dnsimple . Client ) ( account ID string , err error ) { if err ! = nil { return " " , err } return strconv . Itoa ( whoami Response . Data . Account . ID ) , nil } 
func New Dnsimple Provider ( domain Filter Domain Filter , zone IDFilter Zone IDFilter , dry Run bool ) ( Provider , error ) { oauth Token : = os . Getenv ( " " ) if len ( oauth Token ) = = 0 { return nil , fmt . Errorf ( " " ) } client : = dnsimple . New Client ( dnsimple . New Oauth Token Credentials ( oauth Token ) ) provider : = & dnsimple Provider { client : dnsimple Zone Service { service : client . Zones } , identity : identity Service { service : client . Identity } , domain Filter : domain Filter , zone IDFilter : zone IDFilter , dry Run : dry Run , } whoami Response , err : = provider . identity . service . Whoami ( ) if err ! = nil { return nil , err } provider . account ID = strconv . Itoa ( whoami Response . Data . Account . ID ) return provider , nil } 
func ( p * dnsimple Provider ) Zones ( ) ( map [ string ] dnsimple . Zone , error ) { zones : = make ( map [ string ] dnsimple . Zone ) page : = 1 list Options : = & dnsimple . Zone List Options { } for { list Options . Page = page zones Response , err : = p . client . List Zones ( p . account ID , list Options ) if err ! = nil { return nil , err } for _ , zone : = range zones Response . Data { if ! p . domain Filter . Match ( zone . Name ) { continue } if ! p . zone IDFilter . Match ( strconv . Itoa ( zone . ID ) ) { continue } zones [ strconv . Itoa ( zone . ID ) ] = zone } page + + if page > zones Response . Pagination . Total Pages { break } } return zones , nil } 
func ( p * dnsimple Provider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } for _ , zone : = range zones { page : = 1 list Options : = & dnsimple . Zone Record List Options { } for { list Options . Page = page records , err : = p . client . List Records ( p . account ID , zone . Name , list Options ) if err ! = nil { return nil , err } for _ , record : = range records . Data { switch record . Type { case " " , " " , " " : break default : continue } endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( record . Name + " " + record . Zone ID , record . Type , endpoint . TTL ( record . TTL ) , record . Content ) ) } page + + if page > records . Pagination . Total Pages { break } } } return endpoints , nil } 
func new Dnsimple Change ( action string , e * endpoint . Endpoint ) * dnsimple Change { ttl : = dnsimple Record TTL if e . Record TTL . Is Configured ( ) { ttl = int ( e . Record TTL ) } change : = & dnsimple Change { Action : action , Resource Record Set : dnsimple . Zone Record { Name : e . DNSName , Type : e . Record Type , Content : e . Targets [ 0 ] , TTL : ttl , } , } return change } 
func new Dnsimple Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * dnsimple Change { changes : = make ( [ ] * dnsimple Change , 0 , len ( endpoints ) ) for _ , e : = range endpoints { changes = append ( changes , new Dnsimple Change ( action , e ) ) } return changes } 
func ( p * dnsimple Provider ) submit Changes ( changes [ ] * dnsimple Change ) error { if len ( changes ) = = 0 { log . Infof ( " " ) return nil } zones , err : = p . Zones ( ) if err ! = nil { return err } for _ , change : = range changes { zone : = dnsimple Suitable Zone ( change . Resource Record Set . Name , zones ) if zone = = nil { log . Debugf ( " " , change . Resource Record Set . Name ) continue } log . Infof ( " " , change . Action , change . Resource Record Set , zone . Name ) change . Resource Record Set . Name = strings . Trim Suffix ( change . Resource Record Set . Name , " " + zone . Name ) if ! p . dry Run { switch change . Action { case dnsimple Create : _ , err : = p . client . Create Record ( p . account ID , zone . Name , change . Resource Record Set ) if err ! = nil { return err } case dnsimple Delete : record ID , err : = p . Get Record ID ( zone . Name , change . Resource Record Set . Name ) if err ! = nil { return err } _ , err = p . client . Delete Record ( p . account ID , zone . Name , record ID ) if err ! = nil { return err } case dnsimple Update : record ID , err : = p . Get Record ID ( zone . Name , change . Resource Record Set . Name ) if err ! = nil { return err } _ , err = p . client . Update Record ( p . account ID , zone . Name , record ID , change . Resource Record Set ) if err ! = nil { return err } } } } return nil } 
func ( p * dnsimple Provider ) Get Record ID ( zone string , record Name string ) ( record ID int , err error ) { page : = 1 list Options : = & dnsimple . Zone Record List Options { Name : record Name } for { list Options . Page = page records , err : = p . client . List Records ( p . account ID , zone , list Options ) if err ! = nil { return 0 , err } for _ , record : = range records . Data { if record . Name = = record Name { return record . ID , nil } } page + + if page > records . Pagination . Total Pages { break } } return 0 , fmt . Errorf ( " " ) } 
func dnsimple Suitable Zone ( hostname string , zones map [ string ] dnsimple . Zone ) * dnsimple . Zone { var zone * dnsimple . Zone for _ , z : = range zones { if strings . Has Suffix ( hostname , z . Name ) { if zone = = nil | | len ( z . Name ) > len ( zone . Name ) { new Z : = z zone = & new Z } } } return zone } 
func ( p * dnsimple Provider ) Create Records ( endpoints [ ] * endpoint . Endpoint ) error { return p . submit Changes ( new Dnsimple Changes ( dnsimple Create , endpoints ) ) } 
func ( p * dnsimple Provider ) Delete Records ( endpoints [ ] * endpoint . Endpoint ) error { return p . submit Changes ( new Dnsimple Changes ( dnsimple Delete , endpoints ) ) } 
func ( p * dnsimple Provider ) Update Records ( endpoints [ ] * endpoint . Endpoint ) error { return p . submit Changes ( new Dnsimple Changes ( dnsimple Update , endpoints ) ) } 
func ( p * dnsimple Provider ) Apply Changes ( changes * plan . Changes ) error { combined Changes : = make ( [ ] * dnsimple Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , new Dnsimple Changes ( dnsimple Create , changes . Create ) . . . ) combined Changes = append ( combined Changes , new Dnsimple Changes ( dnsimple Update , changes . Update New ) . . . ) combined Changes = append ( combined Changes , new Dnsimple Changes ( dnsimple Delete , changes . Delete ) . . . ) return p . submit Changes ( combined Changes ) } 
func New Google Provider ( project string , domain Filter Domain Filter , zone IDFilter Zone IDFilter , dry Run bool ) ( * Google Provider , error ) { gcloud , err : = google . Default Client ( context . TODO ( ) , dns . Ndev Clouddns Readwrite Scope ) if err ! = nil { return nil , err } gcloud = instrumented _http . New Client ( gcloud , & instrumented _http . Callbacks { Path Processor : func ( path string ) string { parts : = strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) dns Client , err : = dns . New ( gcloud ) if err ! = nil { return nil , err } if project = = " " { m Project , m Err : = metadata . Project ID ( ) if m Err = = nil { log . Infof ( " " , m Project ) project = m Project } } provider : = & Google Provider { project : project , dry Run : dry Run , domain Filter : domain Filter , zone IDFilter : zone IDFilter , resource Record Sets Client : resource Record Sets Service { dns Client . Resource Record Sets } , managed Zones Client : managed Zones Service { dns Client . Managed Zones } , changes Client : changes Service { dns Client . Changes } , } return provider , nil } 
func ( p * Google Provider ) Zones ( ) ( map [ string ] * dns . Managed Zone , error ) { zones : = make ( map [ string ] * dns . Managed Zone ) f : = func ( resp * dns . Managed Zones List Response ) error { for _ , zone : = range resp . Managed Zones { if p . domain Filter . Match ( zone . Dns Name ) & & p . zone IDFilter . Match ( fmt . Sprintf ( " " , zone . Id ) ) { zones [ zone . Name ] = zone log . Debugf ( " " , zone . Dns Name , zone . Name ) } else { log . Debugf ( " " , zone . Dns Name , zone . Name ) } } return nil } log . Debugf ( " " , p . domain Filter . filters ) if err : = p . managed Zones Client . List ( p . project ) . Pages ( context . TODO ( ) , f ) ; err ! = nil { return nil , err } if len ( zones ) = = 0 { if p . domain Filter . Is Configured ( ) { log . Warnf ( " " , p . project , p . domain Filter . filters ) } else { log . Warnf ( " " , p . project ) } } for _ , zone : = range zones { log . Debugf ( " " , zone . Name , zone . Dns Name ) } return zones , nil } 
func ( p * Google Provider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } f : = func ( resp * dns . Resource Record Sets List Response ) error { for _ , r : = range resp . Rrsets { if ! supported Record Type ( r . Type ) { continue } endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( r . Name , r . Type , endpoint . TTL ( r . Ttl ) , r . Rrdatas . . . ) ) } return nil } for _ , z : = range zones { if err : = p . resource Record Sets Client . List ( p . project , z . Name ) . Pages ( context . TODO ( ) , f ) ; err ! = nil { return nil , err } } return endpoints , nil } 
func ( p * Google Provider ) Create Records ( endpoints [ ] * endpoint . Endpoint ) error { change : = & dns . Change { } change . Additions = append ( change . Additions , p . new Filtered Records ( endpoints ) . . . ) return p . submit Change ( change ) } 
func ( p * Google Provider ) Update Records ( records , old Records [ ] * endpoint . Endpoint ) error { change : = & dns . Change { } change . Additions = append ( change . Additions , p . new Filtered Records ( records ) . . . ) change . Deletions = append ( change . Deletions , p . new Filtered Records ( old Records ) . . . ) return p . submit Change ( change ) } 
func ( p * Google Provider ) Delete Records ( endpoints [ ] * endpoint . Endpoint ) error { change : = & dns . Change { } change . Deletions = append ( change . Deletions , p . new Filtered Records ( endpoints ) . . . ) return p . submit Change ( change ) } 
func ( p * Google Provider ) Apply Changes ( changes * plan . Changes ) error { change : = & dns . Change { } change . Additions = append ( change . Additions , p . new Filtered Records ( changes . Create ) . . . ) change . Additions = append ( change . Additions , p . new Filtered Records ( changes . Update New ) . . . ) change . Deletions = append ( change . Deletions , p . new Filtered Records ( changes . Update Old ) . . . ) change . Deletions = append ( change . Deletions , p . new Filtered Records ( changes . Delete ) . . . ) return p . submit Change ( change ) } 
func ( p * Google Provider ) new Filtered Records ( endpoints [ ] * endpoint . Endpoint ) [ ] * dns . Resource Record Set { records : = [ ] * dns . Resource Record Set { } for _ , endpoint : = range endpoints { if p . domain Filter . Match ( endpoint . DNSName ) { records = append ( records , new Record ( endpoint ) ) } } return records } 
func ( p * Google Provider ) submit Change ( change * dns . Change ) error { if len ( change . Additions ) = = 0 & & len ( change . Deletions ) = = 0 { log . Info ( " " ) return nil } zones , err : = p . Zones ( ) if err ! = nil { return err } for z , c : = range changes { log . Infof ( " " , z ) for _ , del : = range c . Deletions { log . Infof ( " " , del . Name , del . Type , del . Rrdatas , del . Ttl ) } for _ , add : = range c . Additions { log . Infof ( " " , add . Name , add . Type , add . Rrdatas , add . Ttl ) } } if p . dry Run { return nil } for z , c : = range changes { if _ , err : = p . changes Client . Create ( p . project , z , c ) . Do ( ) ; err ! = nil { return err } } return nil } 
func separate Change ( zones map [ string ] * dns . Managed Zone , change * dns . Change ) map [ string ] * dns . Change { changes : = make ( map [ string ] * dns . Change ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper [ z . Name ] = z . Dns Name changes [ z . Name ] = & dns . Change { Additions : [ ] * dns . Resource Record Set { } , Deletions : [ ] * dns . Resource Record Set { } , } } for _ , a : = range change . Additions { if zone Name , _ : = zone Name IDMapper . Find Zone ( ensure Trailing Dot ( a . Name ) ) ; zone Name ! = " " { changes [ zone Name ] . Additions = append ( changes [ zone Name ] . Additions , a ) } else { log . Warnf ( " " , a . Name , a . Type , a . Rrdatas , a . Ttl ) } } for _ , d : = range change . Deletions { if zone Name , _ : = zone Name IDMapper . Find Zone ( ensure Trailing Dot ( d . Name ) ) ; zone Name ! = " " { changes [ zone Name ] . Deletions = append ( changes [ zone Name ] . Deletions , d ) } else { log . Warnf ( " " , d . Name , d . Type , d . Rrdatas , d . Ttl ) } } } } return changes } 
func new Record ( ep * endpoint . Endpoint ) * dns . Resource Record Set { copy ( targets , [ ] string ( ep . Targets ) ) if ep . Record Type = = endpoint . Record Type CNAME { targets [ 0 ] = ensure Trailing Dot ( targets [ 0 ] ) } if ep . Record TTL . Is Configured ( ) { ttl = int 6 4 ( ep . Record TTL ) } return & dns . Resource Record Set { Name : ensure Trailing Dot ( ep . DNSName ) , Rrdatas : targets , Ttl : ttl , Type : ep . Record Type , } } 
func New Rcode Zero Provider ( domain Filter Domain Filter , dry Run bool , txt Enc bool ) ( * Rcode Zero Provider , error ) { client , err : = rc 0 . New Client ( os . Getenv ( " " ) ) if err ! = nil { return nil , err } value : = os . Getenv ( " " ) if len ( value ) ! = 0 { client . Base URL , err = url . Parse ( os . Getenv ( " " ) ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } provider : = & Rcode Zero Provider { Client : client , Domain Filter : domain Filter , Dry Run : dry Run , TXTEncrypt : txt Enc , } if txt Enc { provider . Key = [ ] byte ( os . Getenv ( " " ) ) } return provider , nil } 
func ( p * Rcode Zero Provider ) Zones ( ) ( [ ] * rc 0 . Zone , error ) { var result [ ] * rc 0 . Zone zones , err : = p . fetch Zones ( ) if err ! = nil { return nil , err } for _ , zone : = range zones { if p . Domain Filter . Match ( zone . Domain ) { result = append ( result , zone ) } } return result , nil } 
func ( p * Rcode Zero Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } var endpoints [ ] * endpoint . Endpoint for _ , zone : = range zones { rrset , err : = p . fetch Records ( zone . Domain ) if err ! = nil { return nil , err } for _ , r : = range rrset { if supported Record Type ( r . Type ) { if p . TXTEncrypt & & ( p . Key ! = nil ) & & strings . Equal Fold ( r . Type , " " ) { p . Client . RRSet . Decrypt TXT ( p . Key , r ) } if len ( r . Records ) > 1 { for _ , _r : = range r . Records { if ! _r . Disabled { endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , _r . Content ) ) } } } else { if ! r . Records [ 0 ] . Disabled { endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( r . Name , r . Type , endpoint . TTL ( r . TTL ) , r . Records [ 0 ] . Content ) ) } } } } } return endpoints , nil } 
func ( p * Rcode Zero Provider ) Apply Changes ( changes * plan . Changes ) error { combined Changes : = make ( [ ] * rc 0 . RRSet Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , p . New Rcodezero Changes ( rc 0 . Change Type ADD , changes . Create ) . . . ) combined Changes = append ( combined Changes , p . New Rcodezero Changes ( rc 0 . Change Type UPDATE , changes . Update New ) . . . ) combined Changes = append ( combined Changes , p . New Rcodezero Changes ( rc 0 . Change Type DELETE , changes . Delete ) . . . ) return p . submit Changes ( combined Changes ) } 
func rcodezero Changes By Zone ( zones [ ] * rc 0 . Zone , change Set [ ] * rc 0 . RRSet Change ) map [ string ] [ ] * rc 0 . RRSet Change { changes : = make ( map [ string ] [ ] * rc 0 . RRSet Change ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( z . Domain , z . Domain ) changes [ z . Domain ] = [ ] * rc 0 . RRSet Change { } } for _ , c : = range change Set { zone , _ : = zone Name IDMapper . Find Zone ( c . Name ) if zone = = " " { log . Debugf ( " " , c . Name ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func ( p * Rcode Zero Provider ) fetch Records ( zone Name string ) ( [ ] * rc 0 . RRType , error ) { var all Records [ ] * rc 0 . RRType list Options : = rc 0 . New List Options ( ) for { records , page , err : = p . Client . RRSet . List ( zone Name , list Options ) if err ! = nil { return nil , err } all Records = append ( all Records , records . . . ) if page = = nil | | ( page . Current Page = = page . Last Page ) { break } list Options . Set Page Number ( page . Current Page + 1 ) } return all Records , nil } 
func ( p * Rcode Zero Provider ) fetch Zones ( ) ( [ ] * rc 0 . Zone , error ) { var all Zones [ ] * rc 0 . Zone list Options : = rc 0 . New List Options ( ) for { zones , page , err : = p . Client . Zones . List ( list Options ) if err ! = nil { return nil , err } all Zones = append ( all Zones , zones . . . ) if page = = nil | | page . Is Last Page ( ) { break } list Options . Set Page Number ( page . Current Page + 1 ) } return all Zones , nil } 
func ( p * Rcode Zero Provider ) submit Changes ( changes [ ] * rc 0 . RRSet Change ) error { if len ( changes ) = = 0 { return nil } zones , err : = p . Zones ( ) if err ! = nil { return err } for zone Name , changes : = range changes By Zone { for _ , change : = range changes { log Fields : = log . Fields { " " : change . Name , " " : change . Records [ 0 ] . Content , " " : change . Type , " " : change . Change Type , " " : zone Name , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { continue } switch change . Change Type { case rc 0 . Change Type ADD : sr , err : = p . Client . RRSet . Create ( zone Name , [ ] * rc 0 . RRSet Change { change } ) if err ! = nil { return err } if sr . Has Error ( ) { return fmt . Errorf ( " " , sr . Message ) } case rc 0 . Change Type UPDATE : sr , err : = p . Client . RRSet . Edit ( zone Name , [ ] * rc 0 . RRSet Change { change } ) if err ! = nil { return err } if sr . Has Error ( ) { return fmt . Errorf ( " " , sr . Message ) } case rc 0 . Change Type DELETE : sr , err : = p . Client . RRSet . Delete ( zone Name , [ ] * rc 0 . RRSet Change { change } ) if err ! = nil { return err } if sr . Has Error ( ) { return fmt . Errorf ( " " , sr . Message ) } default : return fmt . Errorf ( " " , change . Change Type ) } } } return nil } 
func ( p * Rcode Zero Provider ) New Rcodezero Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * rc 0 . RRSet Change { changes : = make ( [ ] * rc 0 . RRSet Change , 0 , len ( endpoints ) ) for _ , _endpoint : = range endpoints { changes = append ( changes , p . New Rcodezero Change ( action , _endpoint ) ) } return changes } 
func ( p * Rcode Zero Provider ) New Rcodezero Change ( action string , endpoint * endpoint . Endpoint ) * rc 0 . RRSet Change { change : = & rc 0 . RRSet Change { Type : endpoint . Record Type , Change Type : action , Name : endpoint . DNSName , Records : [ ] * rc 0 . Record { { Disabled : false , Content : endpoint . Targets [ 0 ] , } } , } if p . TXTEncrypt & & ( p . Key ! = nil ) & & strings . Equal Fold ( endpoint . Record Type , " " ) { p . Client . RRSet . Encrypt TXT ( p . Key , change ) } return change } 
func New Alibaba Cloud Provider ( config File string , domain Filter Domain Filter , zone IDFileter Zone IDFilter , zone Type string , dry Run bool ) ( * Alibaba Cloud Provider , error ) { cfg : = alibaba Cloud Config { } if config File ! = " " { contents , err : = ioutil . Read File ( config File ) if err ! = nil { return nil , fmt . Errorf ( " " , config File , err ) } err = yaml . Unmarshal ( contents , & cfg ) if err ! = nil { return nil , fmt . Errorf ( " " , config File , err ) } } else { var tmp Error error cfg , tmp Error = get Cloud Config From Sts Token ( ) if tmp Error ! = nil { return nil , fmt . Errorf ( " " , tmp Error ) } } var err error if cfg . Role Name = = " " { dns Client , err = alidns . New Client With Access Key ( cfg . Region ID , cfg . Access Key ID , cfg . Access Key Secret , ) } else { dns Client , err = alidns . New Client With Sts Token ( cfg . Region ID , cfg . Access Key ID , cfg . Access Key Secret , cfg . Sts Token , ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if cfg . Role Name = = " " { pvtz Client , err = pvtz . New Client With Access Key ( " " , } else { pvtz Client , err = pvtz . New Client With Sts Token ( cfg . Region ID , cfg . Access Key ID , cfg . Access Key Secret , cfg . Sts Token , ) } if err ! = nil { return nil , err } provider : = & Alibaba Cloud Provider { domain Filter : domain Filter , zone IDFilter : zone IDFileter , vpc ID : cfg . VPCID , dry Run : dry Run , dns Client : dns Client , pvtz Client : pvtz Client , private Zone : zone Type = = " " , } if cfg . Role Name ! = " " { provider . set Next Expire ( cfg . Expire Time ) go provider . refresh Sts Token ( 1 * time . Second ) } return provider , nil } 
func ( p * Alibaba Cloud Provider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { if p . private Zone { endpoints , err = p . private Zone Records ( ) } else { endpoints , err = p . records For DNS ( ) } return endpoints , err } 
func ( p * Alibaba Cloud Provider ) Apply Changes ( changes * plan . Changes ) error { if changes = = nil | | len ( changes . Create ) + len ( changes . Delete ) + len ( changes . Update New ) = = 0 { } if p . private Zone { return p . apply Changes For Private Zone ( changes ) } return p . apply Changes For DNS ( changes ) } 
func ( p * Alibaba Cloud Provider ) records For DNS ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { records , err : = p . records ( ) if err ! = nil { return nil , err } for _ , record List : = range p . group Records ( records ) { name : = p . get DNSName ( record List [ 0 ] . RR , record List [ 0 ] . Domain Name ) record Type : = record List [ 0 ] . Type ttl : = record List [ 0 ] . TTL if ttl = = default Alibaba Cloud Record TTL { ttl = 0 } var targets [ ] string for _ , record : = range record List { target : = record . Value if record Type = = " " { target = p . unescape TXTRecord Value ( target ) } targets = append ( targets , target ) } ep : = endpoint . New Endpoint With TTL ( name , record Type , endpoint . TTL ( ttl ) , targets . . . ) endpoints = append ( endpoints , ep ) } return endpoints , nil } 
func ( p * Alibaba Cloud Provider ) private Zone Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err : = p . get Private Zones ( ) if err ! = nil { return nil , err } for _ , zone : = range zones { record Map : = p . group Private Zone Records ( zone ) for _ , record List : = range record Map { name : = p . get DNSName ( record List [ 0 ] . Rr , zone . Zone Name ) record Type : = record List [ 0 ] . Type ttl : = record List [ 0 ] . Ttl if ttl = = default Alibaba Cloud Private Zone Record TTL { ttl = 0 } var targets [ ] string for _ , record : = range record List { target : = record . Value if record Type = = " " { target = p . unescape TXTRecord Value ( target ) } targets = append ( targets , target ) } ep : = endpoint . New Endpoint With TTL ( name , record Type , endpoint . TTL ( ttl ) , targets . . . ) endpoints = append ( endpoints , ep ) } } return endpoints , nil } 
func ( p * Alibaba Cloud Provider ) apply Changes For Private Zone ( changes * plan . Changes ) error { log . Infof ( " " , * changes ) zones , err : = p . get Private Zones ( ) if err ! = nil { return err } for zone Name , zone : = range zones { log . Debugf ( " " , zone Name , zone ) } p . create Private Zone Records ( zones , changes . Create ) p . delete Private Zone Records ( zones , changes . Delete ) p . update Private Zone Records ( zones , changes . Update New ) return nil } 
func ( c etcd Client ) Get Services ( prefix string ) ( [ ] * Service , error ) { ctx , cancel : = context . With Timeout ( c . ctx , etcd Timeout ) defer cancel ( ) path : = prefix r , err : = c . client . Get ( ctx , path , etcdcv 3 . With Prefix ( ) ) if err ! = nil { return nil , err } var svcs [ ] * Service bx : = make ( map [ Service ] bool ) for _ , n : = range r . Kvs { svc : = new ( Service ) if err : = json . Unmarshal ( n . Value , svc ) ; err ! = nil { return nil , fmt . Errorf ( " " , n . Key , err . Error ( ) ) } b : = Service { Host : svc . Host , Port : svc . Port , Priority : svc . Priority , Weight : svc . Weight , Text : svc . Text , Key : string ( n . Key ) } if _ , ok : = bx [ b ] ; ok { } bx [ b ] = true svc . Key = string ( n . Key ) if svc . Priority = = 0 { svc . Priority = priority } svcs = append ( svcs , svc ) } return svcs , nil } 
func ( c etcd Client ) Save Service ( service * Service ) error { ctx , cancel : = context . With Timeout ( c . ctx , etcd Timeout ) defer cancel ( ) value , err : = json . Marshal ( & service ) if err ! = nil { return err } _ , err = c . client . Put ( ctx , service . Key , string ( value ) ) if err ! = nil { return err } return nil } 
func ( c etcd Client ) Delete Service ( key string ) error { ctx , cancel : = context . With Timeout ( c . ctx , etcd Timeout ) defer cancel ( ) _ , err : = c . client . Delete ( ctx , key , etcdcv 3 . With Prefix ( ) ) return err } 
func new TLSConfig ( cert Path , key Path , ca Path , server Name string , insecure bool ) ( * tls . Config , error ) { if cert Path ! = " " & & key Path = = " " | | cert Path = = " " & & key Path ! = " " { return nil , errors . New ( " " ) } var certificates [ ] tls . Certificate if cert Path ! = " " { cert , err : = tls . Load X 5 0 9Key Pair ( cert Path , key Path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } certificates = append ( certificates , cert ) } roots , err : = load Roots ( ca Path ) if err ! = nil { return nil , err } return & tls . Config { Certificates : certificates , Root CAs : roots , Insecure Skip Verify : insecure , Server Name : server Name , } , nil } 
func get ETCDConfig ( ) ( * etcdcv 3 . Config , error ) { etcd URLs Str : = os . Getenv ( " " ) if etcd URLs Str = = " " { etcd URLs Str = " " } etcd URLs : = strings . Split ( etcd URLs Str , " " ) first URL : = strings . To Lower ( etcd URLs [ 0 ] ) if strings . Has Prefix ( first URL , " " ) { return & etcdcv 3 . Config { Endpoints : etcd URLs } , nil } else if strings . Has Prefix ( first URL , " " ) { ca File : = os . Getenv ( " " ) cert File : = os . Getenv ( " " ) key File : = os . Getenv ( " " ) server Name : = os . Getenv ( " " ) is Insecure Str : = strings . To Lower ( os . Getenv ( " " ) ) is Insecure : = is Insecure Str = = " " | | is Insecure Str = = " " | | is Insecure Str = = " " tls Config , err : = new TLSConfig ( cert File , key File , ca File , server Name , is Insecure ) if err ! = nil { return nil , err } return & etcdcv 3 . Config { Endpoints : etcd URLs , TLS : tls Config , } , nil } else { return nil , errors . New ( " " ) } } 
func new ETCDClient ( ) ( core DNSClient , error ) { cfg , err : = get ETCDConfig ( ) if err ! = nil { return nil , err } c , err : = etcdcv 3 . New ( * cfg ) if err ! = nil { return nil , err } return etcd Client { c , context . Background ( ) } , nil } 
func New Core DNSProvider ( domain Filter Domain Filter , dry Run bool ) ( Provider , error ) { client , err : = new ETCDClient ( ) if err ! = nil { return nil , err } return core DNSProvider { client : client , dry Run : dry Run , domain Filter : domain Filter , } , nil } 
func ( p core DNSProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { var result [ ] * endpoint . Endpoint services , err : = p . client . Get Services ( core DNSPrefix ) if err ! = nil { return nil , err } for _ , service : = range services { domains : = strings . Split ( strings . Trim Prefix ( service . Key , core DNSPrefix ) , " " ) reverse ( domains ) dns Name : = strings . Join ( domains [ service . Target Strip : ] , " " ) if ! p . domain Filter . Match ( dns Name ) { continue } prefix : = strings . Join ( domains [ : service . Target Strip ] , " " ) if service . Host ! = " " { ep : = endpoint . New Endpoint With TTL ( dns Name , guess Record Type ( service . Host ) , endpoint . TTL ( service . TTL ) , service . Host , ) ep . Labels [ " " ] = service . Text ep . Labels [ random Prefix Label ] = prefix result = append ( result , ep ) } if service . Text ! = " " { ep : = endpoint . New Endpoint ( dns Name , endpoint . Record Type TXT , service . Text , ) ep . Labels [ random Prefix Label ] = prefix result = append ( result , ep ) } } return result , nil } 
func ( p core DNSProvider ) Apply Changes ( changes * plan . Changes ) error { grouped : = map [ string ] [ ] * endpoint . Endpoint { } for _ , ep : = range changes . Create { grouped [ ep . DNSName ] = append ( grouped [ ep . DNSName ] , ep ) } for i , ep : = range changes . Update New { ep . Labels [ random Prefix Label ] = changes . Update Old [ i ] . Labels [ random Prefix Label ] grouped [ ep . DNSName ] = append ( grouped [ ep . DNSName ] , ep ) } for dns Name , group : = range grouped { if ! p . domain Filter . Match ( dns Name ) { log . Debugf ( " " , dns Name ) continue } var services [ ] Service for _ , ep : = range group { if ep . Record Type = = endpoint . Record Type TXT { continue } for _ , target : = range ep . Targets { prefix : = ep . Labels [ random Prefix Label ] if prefix = = " " { prefix = fmt . Sprintf ( " " , rand . Int 3 1 ( ) ) } service : = Service { Host : target , Text : ep . Labels [ " " ] , Key : etcd Key For ( prefix + " " + dns Name ) , Target Strip : strings . Count ( prefix , " " ) + 1 , TTL : uint 3 2 ( ep . Record TTL ) , } services = append ( services , service ) } } index : = 0 for _ , ep : = range group { if ep . Record Type ! = endpoint . Record Type TXT { continue } if index > = len ( services ) { prefix : = ep . Labels [ random Prefix Label ] if prefix = = " " { prefix = fmt . Sprintf ( " " , rand . Int 3 1 ( ) ) } services = append ( services , Service { Key : etcd Key For ( prefix + " " + dns Name ) , Target Strip : strings . Count ( prefix , " " ) + 1 , TTL : uint 3 2 ( ep . Record TTL ) , } ) } services [ index ] . Text = ep . Targets [ 0 ] index + + } for i : = index ; index > 0 & & i < len ( services ) ; i + + { services [ i ] . Text = " " } for _ , service : = range services { log . Infof ( " " , service . Key , service . Host , service . Text , service . TTL ) if ! p . dry Run { err : = p . client . Save Service ( & service ) if err ! = nil { return err } } } } for _ , ep : = range changes . Delete { dns Name : = ep . DNSName if ep . Labels [ random Prefix Label ] ! = " " { dns Name = ep . Labels [ random Prefix Label ] + " " + dns Name } key : = etcd Key For ( dns Name ) log . Infof ( " " , key ) if ! p . dry Run { err : = p . client . Delete Service ( key ) if err ! = nil { return err } } } return nil } 
func New Rfc 2 1 3 6Provider ( host string , port int , zone Name string , insecure bool , key Name string , secret string , secret Alg string , axfr bool , domain Filter Domain Filter , dry Run bool , actions rfc 2 1 3 6Actions ) ( Provider , error ) { secret Alg Checked , ok : = tsig Algs [ secret Alg ] if ! ok & & ! insecure { return nil , errors . Errorf ( " " , secret Alg ) } r : = & rfc 2 1 3 6Provider { nameserver : net . Join Host Port ( host , strconv . Itoa ( port ) ) , zone Name : dns . Fqdn ( zone Name ) , insecure : insecure , domain Filter : domain Filter , dry Run : dry Run , axfr : axfr , } if actions ! = nil { r . actions = actions } else { r . actions = r } if ! insecure { r . tsig Key Name = dns . Fqdn ( key Name ) r . tsig Secret = secret r . tsig Secret Alg = secret Alg Checked } log . Infof ( " " , r . zone Name , r . nameserver ) return r , nil } 
func ( r rfc 2 1 3 6Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { rrs , err : = r . List ( ) if err ! = nil { return nil , err } var eps [ ] * endpoint . Endpoint Outer Loop : for _ , rr : = range rrs { log . Debugf ( " " , rr ) if rr . Header ( ) . Class ! = dns . Class INET { continue } rr Fqdn : = rr . Header ( ) . Name rr TTL : = endpoint . TTL ( rr . Header ( ) . Ttl ) var rr Type string var rr Values [ ] string switch rr . Header ( ) . Rrtype { case dns . Type CNAME : rr Values = [ ] string { rr . ( * dns . CNAME ) . Target } rr Type = " " case dns . Type A : rr Values = [ ] string { rr . ( * dns . A ) . A . String ( ) } rr Type = " " case dns . Type AAAA : rr Values = [ ] string { rr . ( * dns . AAAA ) . AAAA . String ( ) } rr Type = " " case dns . Type TXT : rr Values = ( rr . ( * dns . TXT ) . Txt ) rr Type = " " default : continue } for idx , existing Endpoint : = range eps { if existing Endpoint . DNSName = = rr Fqdn & & existing Endpoint . Record Type = = rr Type { eps [ idx ] . Targets = append ( eps [ idx ] . Targets , rr Values . . . ) continue Outer Loop } } ep : = endpoint . New Endpoint With TTL ( rr Fqdn , rr Type , rr TTL , rr Values . . . , ) eps = append ( eps , ep ) } return eps , nil } 
func ( r rfc 2 1 3 6Provider ) Apply Changes ( changes * plan . Changes ) error { log . Debugf ( " " ) for _ , ep : = range changes . Create { if ! r . domain Filter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . Add Record ( ep ) } for _ , ep : = range changes . Update New { if ! r . domain Filter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . Update Record ( ep ) } for _ , ep : = range changes . Delete { if ! r . domain Filter . Match ( ep . DNSName ) { log . Debugf ( " " , ep . DNSName ) continue } r . Remove Record ( ep ) } return nil } 
func stringify HTTPResponse Body ( r * http . Response ) ( body string ) { if r = = nil { return " " } buf : = new ( bytes . Buffer ) buf . Read From ( r . Body ) body = buf . String ( ) return body } 
func ( c * PDNSAPIClient ) List Zones ( ) ( zones [ ] pgo . Zone , resp * http . Response , err error ) { for i : = 0 ; i < retry Limit ; i + + { zones , resp , err = c . client . Zones Api . List Zones ( c . auth Ctx , default Server ID ) if err ! = nil { log . Debugf ( " " , err ) log . Debugf ( " " , i ) time . Sleep ( retry After Time * ( 1 < < uint ( i ) ) ) continue } return zones , resp , err } log . Errorf ( " " , err ) return zones , resp , err } 
func ( c * PDNSAPIClient ) Partition Zones ( zones [ ] pgo . Zone ) ( filtered Zones [ ] pgo . Zone , residual Zones [ ] pgo . Zone ) { if c . domain Filter . Is Configured ( ) { for _ , zone : = range zones { if c . domain Filter . Match ( zone . Name ) { filtered Zones = append ( filtered Zones , zone ) } else { residual Zones = append ( residual Zones , zone ) } } } else { filtered Zones = zones } return filtered Zones , residual Zones } 
func ( c * PDNSAPIClient ) List Zone ( zone ID string ) ( zone pgo . Zone , resp * http . Response , err error ) { for i : = 0 ; i < retry Limit ; i + + { zone , resp , err = c . client . Zones Api . List Zone ( c . auth Ctx , default Server ID , zone ID ) if err ! = nil { log . Debugf ( " " , err ) log . Debugf ( " " , i ) time . Sleep ( retry After Time * ( 1 < < uint ( i ) ) ) continue } return zone , resp , err } log . Errorf ( " " , err ) return zone , resp , err } 
func New PDNSProvider ( config PDNSConfig ) ( * PDNSProvider , error ) { } } if config . Server = = " " { log . Warnf ( " " ) } pdns Client Config : = pgo . New Configuration ( ) pdns Client Config . Base Path = config . Server + api Base if err : = config . TLSConfig . set HTTPClient ( pdns Client Config ) ; err ! = nil { return nil , err } provider : = & PDNSProvider { client : & PDNSAPIClient { dry Run : config . Dry Run , auth Ctx : context . With Value ( context . TODO ( ) , pgo . Context APIKey , pgo . APIKey { Key : config . APIKey } ) , client : pgo . New APIClient ( pdns Client Config ) , domain Filter : config . Domain Filter , } , } return provider , nil } 
func ( p * PDNSProvider ) Convert Endpoints To Zones ( eps [ ] * endpoint . Endpoint , changetype pdns Change Type ) ( zonelist [ ] pgo . Zone , _ error ) { zonelist = [ ] pgo . Zone { } endpoints : = make ( [ ] * endpoint . Endpoint , len ( eps ) ) copy ( endpoints , eps ) } return endpoints [ i ] . DNSName < endpoints [ j ] . DNSName } ) zones , _ , err : = p . client . List Zones ( ) if err ! = nil { return nil , err } filtered Zones , residual Zones : = p . client . Partition Zones ( zones ) for i : = 0 ; i < len ( endpoints ) ; { ep : = endpoints [ i ] dnsname : = ensure Trailing Dot ( ep . DNSName ) if dnsname = = zone . Name | | strings . Has Suffix ( dnsname , " " + zone . Name ) { for _ , t : = range ep . Targets { if " " = = ep . Record Type { t = ensure Trailing Dot ( t ) } records = append ( records , pgo . Record { Content : t } ) } rrset : = pgo . Rr Set { Name : dnsname , Type _ : ep . Record Type , Records : records , Changetype : string ( changetype ) , } } if ep . Record TTL = = 0 { } else { rrset . Ttl = int 3 2 ( ep . Record TTL ) } } zone . Rrsets = append ( zone . Rrsets , rrset ) } else { } } if len ( zone . Rrsets ) > 0 { zonelist = append ( zonelist , zone ) } } dnsname : = ensure Trailing Dot ( ep . DNSName ) if dnsname = = zone . Name | | strings . Has Suffix ( dnsname , " " + zone . Name ) { endpoints = append ( endpoints [ 0 : i ] , endpoints [ i + 1 : ] . . . ) } else { i + + } } } } log . Debugf ( " " , zonelist ) return zonelist , nil } 
func ( p * PDNSProvider ) mutate Records ( endpoints [ ] * endpoint . Endpoint , changetype pdns Change Type ) error { zonelist , err : = p . Convert Endpoints To Zones ( endpoints , changetype ) if err ! = nil { return err } for _ , zone : = range zonelist { jso , err : = json . Marshal ( zone ) if err ! = nil { log . Errorf ( " " ) } else { log . Debugf ( " \n " , string ( jso ) ) } resp , err : = p . client . Patch Zone ( zone . Id , zone ) if err ! = nil { log . Debugf ( " " , stringify HTTPResponse Body ( resp ) ) return err } } return nil } 
func ( p * PDNSProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , _ , err : = p . client . List Zones ( ) if err ! = nil { return nil , err } filtered Zones , _ : = p . client . Partition Zones ( zones ) for _ , zone : = range filtered Zones { z , _ , err : = p . client . List Zone ( zone . Id ) if err ! = nil { log . Warnf ( " " ) return nil , err } for _ , rr : = range z . Rrsets { e , err : = p . convert RRSet To Endpoints ( rr ) if err ! = nil { return nil , err } endpoints = append ( endpoints , e . . . ) } } log . Debugf ( " \n " , endpoints ) return endpoints , nil } 
func ( p * PDNSProvider ) Apply Changes ( changes * plan . Changes ) error { start Time : = time . Now ( ) } if err ! = nil { return err } } } for _ , change : = range changes . Update New { log . Debugf ( " " , change ) } if len ( changes . Update New ) > 0 { err : = p . mutate Records ( changes . Update New , Pdns Replace ) if err ! = nil { return err } } } if len ( changes . Delete ) > 0 { err : = p . mutate Records ( changes . Delete , Pdns Delete ) if err ! = nil { return err } } log . Debugf ( " \n " , time . Since ( start Time ) ) return nil } 
func New AWSSDProvider ( domain Filter Domain Filter , namespace Type string , assume Role string , dry Run bool ) ( * AWSSDProvider , error ) { config : = aws . New Config ( ) config = config . With HTTPClient ( instrumented _http . New Client ( config . HTTPClient , & instrumented _http . Callbacks { Path Processor : func ( path string ) string { parts : = strings . Split ( path , " " ) return parts [ len ( parts ) - 1 ] } , } ) , ) sess , err : = session . New Session With Options ( session . Options { Config : * config , Shared Config State : session . Shared Config Enable , } ) if err ! = nil { return nil , err } if assume Role ! = " " { log . Infof ( " " , assume Role ) sess . Config . With Credentials ( stscreds . New Credentials ( sess , assume Role ) ) } sess . Handlers . Build . Push Back ( request . Make Add To User Agent Handler ( " " , externaldns . Version ) ) provider : = & AWSSDProvider { client : sd . New ( sess ) , namespace Filter : domain Filter , namespace Type Filter : new Sd Namespace Filter ( namespace Type ) , dry Run : dry Run , } return provider , nil } 
func new Sd Namespace Filter ( namespace Type Config string ) * sd . Namespace Filter { switch namespace Type Config { case sd Namespace Type Public : return & sd . Namespace Filter { Name : aws . String ( sd . Namespace Filter Name Type ) , Values : [ ] * string { aws . String ( sd . Namespace Type Dns Public ) } , } case sd Namespace Type Private : return & sd . Namespace Filter { Name : aws . String ( sd . Namespace Filter Name Type ) , Values : [ ] * string { aws . String ( sd . Namespace Type Dns Private ) } , } default : return nil } } 
func ( p * AWSSDProvider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , err error ) { namespaces , err : = p . List Namespaces ( ) if err ! = nil { return nil , err } for _ , ns : = range namespaces { services , err : = p . List Services By Namespace ID ( ns . Id ) if err ! = nil { return nil , err } for _ , srv : = range services { instances , err : = p . List Instances By Service ID ( srv . Id ) if err ! = nil { return nil , err } if len ( instances ) > 0 { ep : = p . instances To Endpoint ( ns , srv , instances ) endpoints = append ( endpoints , ep ) } } } return endpoints , nil } 
func ( p * AWSSDProvider ) Apply Changes ( changes * plan . Changes ) error { return nil } changes . Delete = append ( changes . Delete , deletes . . . ) changes . Create = append ( changes . Create , creates . . . ) namespaces , err : = p . List Namespaces ( ) if err ! = nil { return err } if err ! = nil { return err } err = p . submit Creates ( namespaces , changes . Create ) if err ! = nil { return err } return nil } 
func ( p * AWSSDProvider ) List Namespaces ( ) ( [ ] * sd . Namespace Summary , error ) { namespaces : = make ( [ ] * sd . Namespace Summary , 0 ) f : = func ( resp * sd . List Namespaces Output , last Page bool ) bool { for _ , ns : = range resp . Namespaces { if ! p . namespace Filter . Match ( aws . String Value ( ns . Name ) ) { continue } namespaces = append ( namespaces , ns ) } return true } err : = p . client . List Namespaces Pages ( & sd . List Namespaces Input { Filters : [ ] * sd . Namespace Filter { p . namespace Type Filter } , } , f ) if err ! = nil { return nil , err } return namespaces , nil } 
func ( p * AWSSDProvider ) List Services By Namespace ID ( namespace ID * string ) ( map [ string ] * sd . Service , error ) { service Ids : = make ( [ ] * string , 0 ) f : = func ( resp * sd . List Services Output , last Page bool ) bool { for _ , srv : = range resp . Services { service Ids = append ( service Ids , srv . Id ) } return true } err : = p . client . List Services Pages ( & sd . List Services Input { Filters : [ ] * sd . Service Filter { { Name : aws . String ( sd . Service Filter Name Namespace Id ) , Values : [ ] * string { namespace ID } , } } , } , f ) if err ! = nil { return nil , err } for _ , service ID : = range service Ids { service , err : = p . Get Service Detail ( service ID ) if err ! = nil { return nil , err } services [ aws . String Value ( service . Name ) ] = service } return services , nil } 
func ( p * AWSSDProvider ) Get Service Detail ( service ID * string ) ( * sd . Service , error ) { output , err : = p . client . Get Service ( & sd . Get Service Input { Id : service ID , } ) if err ! = nil { return nil , err } return output . Service , nil } 
func ( p * AWSSDProvider ) List Instances By Service ID ( service ID * string ) ( [ ] * sd . Instance Summary , error ) { instances : = make ( [ ] * sd . Instance Summary , 0 ) f : = func ( resp * sd . List Instances Output , last Page bool ) bool { instances = append ( instances , resp . Instances . . . ) return true } err : = p . client . List Instances Pages ( & sd . List Instances Input { Service Id : service ID , } , f ) if err ! = nil { return nil , err } return instances , nil } 
func ( p * AWSSDProvider ) Create Service ( namespace ID * string , srv Name * string , ep * endpoint . Endpoint ) ( * sd . Service , error ) { log . Infof ( " \ " \ " \ " \ " " , * srv Name , * namespace ID ) srv Type : = p . service Type From Endpoint ( ep ) routing Policy : = p . routing Policy From Endpoint ( ep ) ttl : = int 6 4 ( sd Default Record TTL ) if ep . Record TTL . Is Configured ( ) { ttl = int 6 4 ( ep . Record TTL ) } if ! p . dry Run { out , err : = p . client . Create Service ( & sd . Create Service Input { Name : srv Name , Description : aws . String ( ep . Labels [ endpoint . AWSSDDescription Label ] ) , Dns Config : & sd . Dns Config { Namespace Id : namespace ID , Routing Policy : aws . String ( routing Policy ) , Dns Records : [ ] * sd . Dns Record { { Type : aws . String ( srv Type ) , TTL : aws . Int 6 4 ( ttl ) , } } , } , } ) if err ! = nil { return nil , err } return out . Service , nil } } 
func ( p * AWSSDProvider ) Update Service ( service * sd . Service , ep * endpoint . Endpoint ) error { log . Infof ( " \ " \ " " , * service . Name ) srv Type : = p . service Type From Endpoint ( ep ) ttl : = int 6 4 ( sd Default Record TTL ) if ep . Record TTL . Is Configured ( ) { ttl = int 6 4 ( ep . Record TTL ) } if ! p . dry Run { _ , err : = p . client . Update Service ( & sd . Update Service Input { Id : service . Id , Service : & sd . Service Change { Description : aws . String ( ep . Labels [ endpoint . AWSSDDescription Label ] ) , Dns Config : & sd . Dns Config Change { Dns Records : [ ] * sd . Dns Record { { Type : aws . String ( srv Type ) , TTL : aws . Int 6 4 ( ttl ) , } } , } } } ) if err ! = nil { return err } } return nil } 
func ( p * AWSSDProvider ) Register Instance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target : = range ep . Targets { log . Infof ( " \ " \ " \ " \ " " , target , * service . Name , * service . Id ) attr : = make ( map [ string ] * string ) if ep . Record Type = = endpoint . Record Type CNAME { if p . is AWSLoad Balancer ( target ) { attr [ sd Instance Attr Alias ] = aws . String ( target ) } else { attr [ sd Instance Attr Cname ] = aws . String ( target ) } } else if ep . Record Type = = endpoint . Record Type A { attr [ sd Instance Attr IPV 4 ] = aws . String ( target ) } else { return fmt . Errorf ( " " , ep ) } if ! p . dry Run { _ , err : = p . client . Register Instance ( & sd . Register Instance Input { Service Id : service . Id , Attributes : attr , Instance Id : aws . String ( p . target To Instance ID ( target ) ) , } ) if err ! = nil { return err } } } return nil } 
func ( p * AWSSDProvider ) Deregister Instance ( service * sd . Service , ep * endpoint . Endpoint ) error { for _ , target : = range ep . Targets { log . Infof ( " \ " \ " \ " \ " " , target , * service . Name , * service . Id ) if ! p . dry Run { _ , err : = p . client . Deregister Instance ( & sd . Deregister Instance Input { Instance Id : aws . String ( p . target To Instance ID ( target ) ) , Service Id : service . Id , } ) if err ! = nil { return err } } } return nil } 
func ( p * AWSSDProvider ) target To Instance ID ( target string ) string { if len ( target ) > 6 4 { hash : = sha 2 5 6 . Sum 2 5 6 ( [ ] byte ( strings . To Lower ( target ) ) ) return hex . Encode To String ( hash [ : ] ) } return strings . To Lower ( target ) } 
func namespace To Namespace Summary ( namespace * sd . Namespace ) * sd . Namespace Summary { if namespace = = nil { return nil } return & sd . Namespace Summary { Id : namespace . Id , Type : namespace . Type , Name : namespace . Name , Arn : namespace . Arn , } } 
func service To Service Summary ( service * sd . Service ) * sd . Service Summary { if service = = nil { return nil } return & sd . Service Summary { Name : service . Name , Id : service . Id , Arn : service . Arn , Description : service . Description , Instance Count : service . Instance Count , } } 
func instance To Instance Summary ( instance * sd . Instance ) * sd . Instance Summary { if instance = = nil { return nil } return & sd . Instance Summary { Id : instance . Id , Attributes : instance . Attributes , } } 
func matching Namespaces ( hostname string , namespaces [ ] * sd . Namespace Summary ) [ ] * sd . Namespace Summary { matching Namespaces : = make ( [ ] * sd . Namespace Summary , 0 ) for _ , ns : = range namespaces { if * ns . Name = = hostname { matching Namespaces = append ( matching Namespaces , ns ) } } return matching Namespaces } 
func ( p * AWSSDProvider ) parse Hostname ( hostname string ) ( namespace string , service string ) { parts : = strings . Split ( hostname , " " ) service = parts [ 0 ] namespace = strings . Join ( parts [ 1 : ] , " " ) return } 
func ( p * AWSSDProvider ) routing Policy From Endpoint ( ep * endpoint . Endpoint ) string { if ep . Record Type = = endpoint . Record Type A { return sd . Routing Policy Multivalue } return sd . Routing Policy Weighted } 
func ( p * AWSSDProvider ) service Type From Endpoint ( ep * endpoint . Endpoint ) string { if ep . Record Type = = endpoint . Record Type CNAME { } return sd . Record Type Cname } return sd . Record Type A } 
func ( p * AWSSDProvider ) is AWSLoad Balancer ( hostname string ) bool { return strings . Has Suffix ( hostname , sd Elb Hostname Suffix ) } 
func ( s Per Resource ) Resolve Create ( candidates [ ] * endpoint . Endpoint ) * endpoint . Endpoint { var min * endpoint . Endpoint for _ , ep : = range candidates { if min = = nil | | s . less ( ep , min ) { min = ep } } return min } 
func ( s Per Resource ) Resolve Update ( current * endpoint . Endpoint , candidates [ ] * endpoint . Endpoint ) * endpoint . Endpoint { current Resource : = current . Labels [ endpoint . Resource Label Key ] } ) for _ , ep : = range candidates { if ep . Labels [ endpoint . Resource Label Key ] = = current Resource { return ep } } return s . Resolve Create ( candidates ) } 
func ( s Per Resource ) less ( x , y * endpoint . Endpoint ) bool { return x . Targets . Is Less ( y . Targets ) } 
func New Digital Ocean Provider ( domain Filter Domain Filter , dry Run bool ) ( * Digital Ocean Provider , error ) { token , ok : = os . Lookup Env ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } oauth Client : = oauth 2 . New Client ( oauth 2 . No Context , oauth 2 . Static Token Source ( & oauth 2 . Token { Access Token : token , } ) ) client : = godo . New Client ( oauth Client ) provider : = & Digital Ocean Provider { Client : client . Domains , domain Filter : domain Filter , Dry Run : dry Run , } return provider , nil } 
func ( p * Digital Ocean Provider ) Zones ( ) ( [ ] godo . Domain , error ) { result : = [ ] godo . Domain { } zones , err : = p . fetch Zones ( ) if err ! = nil { return nil , err } for _ , zone : = range zones { if p . domain Filter . Match ( zone . Name ) { result = append ( result , zone ) } } return result , nil } 
func ( p * Digital Ocean Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { zones , err : = p . Zones ( ) if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } for _ , zone : = range zones { records , err : = p . fetch Records ( zone . Name ) if err ! = nil { return nil , err } for _ , r : = range records { if supported Record Type ( r . Type ) { name : = r . Name + " " + zone . Name } endpoints = append ( endpoints , endpoint . New Endpoint ( name , r . Type , r . Data ) ) } } } return endpoints , nil } 
func ( p * Digital Ocean Provider ) submit Changes ( changes [ ] * Digital Ocean Change ) error { } zones , err : = p . Zones ( ) if err ! = nil { return err } for zone Name , changes : = range changes By Zone { records , err : = p . fetch Records ( zone Name ) if err ! = nil { log . Errorf ( " " , zone Name ) continue } for _ , change : = range changes { log Fields : = log . Fields { " " : change . Resource Record Set . Name , " " : change . Resource Record Set . Type , " " : change . Resource Record Set . TTL , " " : change . Action , " " : zone Name , } log . With Fields ( log Fields ) . Info ( " " ) if p . Dry Run { continue } change . Resource Record Set . Name = strings . Trim Suffix ( change . Resource Record Set . Name , " " + zone Name ) } } switch change . Action { case Digital Ocean Create : _ , _ , err = p . Client . Create Record ( context . TODO ( ) , zone Name , & godo . Domain Record Edit Request { Data : change . Resource Record Set . Data , Name : change . Resource Record Set . Name , Type : change . Resource Record Set . Type , TTL : change . Resource Record Set . TTL , } ) if err ! = nil { return err } case Digital Ocean Delete : record ID : = p . get Record ID ( records , change . Resource Record Set ) _ , err = p . Client . Delete Record ( context . TODO ( ) , zone Name , record ID ) if err ! = nil { return err } case Digital Ocean Update : record ID : = p . get Record ID ( records , change . Resource Record Set ) _ , _ , err = p . Client . Edit Record ( context . TODO ( ) , zone Name , record ID , & godo . Domain Record Edit Request { Data : change . Resource Record Set . Data , Name : change . Resource Record Set . Name , Type : change . Resource Record Set . Type , TTL : change . Resource Record Set . TTL , } ) if err ! = nil { return err } } } } return nil } 
func ( p * Digital Ocean Provider ) Apply Changes ( changes * plan . Changes ) error { combined Changes : = make ( [ ] * Digital Ocean Change , 0 , len ( changes . Create ) + len ( changes . Update New ) + len ( changes . Delete ) ) combined Changes = append ( combined Changes , new Digital Ocean Changes ( Digital Ocean Create , changes . Create ) . . . ) combined Changes = append ( combined Changes , new Digital Ocean Changes ( Digital Ocean Update , changes . Update New ) . . . ) combined Changes = append ( combined Changes , new Digital Ocean Changes ( Digital Ocean Delete , changes . Delete ) . . . ) return p . submit Changes ( combined Changes ) } 
func new Digital Ocean Changes ( action string , endpoints [ ] * endpoint . Endpoint ) [ ] * Digital Ocean Change { changes : = make ( [ ] * Digital Ocean Change , 0 , len ( endpoints ) ) for _ , endpoint : = range endpoints { changes = append ( changes , new Digital Ocean Change ( action , endpoint ) ) } return changes } 
func ( p * Digital Ocean Provider ) get Record ID ( records [ ] godo . Domain Record , record godo . Domain Record ) int { for _ , zone Record : = range records { if zone Record . Name = = record . Name & & zone Record . Type = = record . Type { return zone Record . ID } } return 0 } 
func digital Ocean Changes By Zone ( zones [ ] godo . Domain , change Set [ ] * Digital Ocean Change ) map [ string ] [ ] * Digital Ocean Change { changes : = make ( map [ string ] [ ] * Digital Ocean Change ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( z . Name , z . Name ) changes [ z . Name ] = [ ] * Digital Ocean Change { } } for _ , c : = range change Set { zone , _ : = zone Name IDMapper . Find Zone ( c . Resource Record Set . Name ) if zone = = " " { log . Debugf ( " " , c . Resource Record Set . Name ) continue } changes [ zone ] = append ( changes [ zone ] , c ) } return changes } 
func legacy Endpoints From Service ( svc * v 1 . Service , compatibility string ) [ ] * endpoint . Endpoint { switch compatibility { case " " : return legacy Endpoints From Mate Service ( svc ) case " " : return legacy Endpoints From Molecule Service ( svc ) } return [ ] * endpoint . Endpoint { } } 
func legacy Endpoints From Mate Service ( svc * v 1 . Service ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint if ! exists { return nil } } if lb . Hostname ! = " " { endpoints = append ( endpoints , endpoint . New Endpoint ( hostname , endpoint . Record Type CNAME , lb . Hostname ) ) } } return endpoints } 
func legacy Endpoints From Molecule Service ( svc * v 1 . Service ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint } if ! exists { return nil } hostname List : = strings . Split ( strings . Replace ( hostname Annotation , " " , " " , - 1 ) , " " ) for _ , hostname : = range hostname List { } if lb . Hostname ! = " " { endpoints = append ( endpoints , endpoint . New Endpoint ( hostname , endpoint . Record Type CNAME , lb . Hostname ) ) } } } return endpoints } 
func ( cs * connector Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints : = [ ] * endpoint . Endpoint { } conn , err : = net . Dial Timeout ( " " , cs . remote Server , dial Timeout ) if err ! = nil { log . Errorf ( " " , err ) return nil , err } defer conn . Close ( ) decoder : = gob . New Decoder ( conn ) if err : = decoder . Decode ( & endpoints ) ; err ! = nil { log . Errorf ( " " , err ) return nil , err } log . Debugf ( " " , endpoints ) return endpoints , nil } 
func get Targets From Target Annotation ( annotations map [ string ] string ) endpoint . Targets { var targets endpoint . Targets if exists & & target Annotation ! = " " { for _ , target Hostname : = range targets List { target Hostname = strings . Trim Suffix ( target Hostname , " " ) targets = append ( targets , target Hostname ) } } return targets } 
func suitable Type ( target string ) string { if net . Parse IP ( target ) ! = nil { return endpoint . Record Type A } return endpoint . Record Type CNAME } 
func endpoints For Hostname ( hostname string , targets endpoint . Targets , ttl endpoint . TTL , provider Specific endpoint . Provider Specific ) [ ] * endpoint . Endpoint { var endpoints [ ] * endpoint . Endpoint var a Targets endpoint . Targets var cname Targets endpoint . Targets for _ , t : = range targets { switch suitable Type ( t ) { case endpoint . Record Type A : a Targets = append ( a Targets , t ) default : cname Targets = append ( cname Targets , t ) } } if len ( a Targets ) > 0 { ep A : = & endpoint . Endpoint { DNSName : strings . Trim Suffix ( hostname , " " ) , Targets : a Targets , Record TTL : ttl , Record Type : endpoint . Record Type A , Labels : endpoint . New Labels ( ) , Provider Specific : provider Specific , } endpoints = append ( endpoints , ep A ) } if len ( cname Targets ) > 0 { ep CNAME : = & endpoint . Endpoint { DNSName : strings . Trim Suffix ( hostname , " " ) , Targets : cname Targets , Record TTL : ttl , Record Type : endpoint . Record Type CNAME , Labels : endpoint . New Labels ( ) , Provider Specific : provider Specific , } endpoints = append ( endpoints , ep CNAME ) } return endpoints } 
func ( snap * Zone Snapshot ) Get Records For Serial ( zone string , serial int ) [ ] * endpoint . Endpoint { last Serial , ok : = snap . serials [ zone ] if ! ok { } if last Serial ! = serial { } endpoints , ok : = snap . endpoints [ zone ] if ! ok { } return endpoints } 
func ( snap * Zone Snapshot ) Store Records For Serial ( zone string , serial int , records [ ] * endpoint . Endpoint ) { snap . serials [ zone ] = serial snap . endpoints [ zone ] = records } 
func New Dyn Provider ( config Dyn Config ) ( Provider , error ) { return & dyn Provider State { Dyn Config : config , Zone Snapshot : & Zone Snapshot { endpoints : map [ string ] [ ] * endpoint . Endpoint { } , serials : map [ string ] int { } , } , } , nil } 
func filter And Fix Links ( links [ ] string , filter Domain Filter ) [ ] string { var result [ ] string for _ , link : = range links { } if filter . Match ( domain ) { result = append ( result , link ) } } return result } 
func merge ( update Old , update New [ ] * endpoint . Endpoint ) [ ] * endpoint . Endpoint { find Match : = func ( template * endpoint . Endpoint ) * endpoint . Endpoint { for _ , new : = range update New { if template . DNSName = = new . DNSName & & template . Record Type = = new . Record Type { return new } } return nil } var result [ ] * endpoint . Endpoint for _ , old : = range update Old { matching New : = find Match ( old ) if matching New = = nil { } if ! matching New . Targets . Same ( old . Targets ) { continue } if matching New . Record TTL ! = 0 & & matching New . Record TTL ! = old . Record TTL { } } return result } 
func endpoint To Record ( ep * endpoint . Endpoint ) * dynect . Data Block { result : = dynect . Data Block { } if ep . Record Type = = endpoint . Record Type A { result . Address = ep . Targets [ 0 ] } else if ep . Record Type = = endpoint . Record Type CNAME { result . CName = ep . Targets [ 0 ] } else if ep . Record Type = = endpoint . Record Type TXT { result . Txt Data = ep . Targets [ 0 ] } return & result } 
func ( d * dyn Provider State ) fetch All Records In Zone ( zone string ) ( * dynectsoap . Get All Records Response Type , error ) { var err error client : = dynectsoap . New Client ( " " ) service : = dynectsoap . New Dynect ( client ) session Request : = dynectsoap . Session Login Request Type { Customer _name : d . Customer Name , User _name : d . Username , Password : d . Password , Fault _incompat : 0 , } resp : = dynectsoap . Session Login Response Type { } err = api Retry Loop ( func ( ) error { return service . Do ( & session Request , & resp ) } ) if err ! = nil { return nil , err } token : = resp . Data . Token logout Request : = dynectsoap . Session Logout Request Type { Token : token , Fault _incompat : 0 , } logout Response : = dynectsoap . Session Logout Response Type { } defer service . Do ( & logout Request , & logout Response ) req : = dynectsoap . Get All Records Request Type { Token : token , Zone : zone , Fault _incompat : 0 , } records : = dynectsoap . Get All Records Response Type { } err = api Retry Loop ( func ( ) error { return service . Do ( & req , & records ) } ) if err ! = nil { return nil , err } log . Debugf ( " " , records . Status ) if strings . To Lower ( records . Status ) = = " " { job Request : = dynectsoap . Get Job Request Type { Token : token , Job _id : records . Job _id , Fault _incompat : 0 , } job Results : = dynectsoap . Get Job Response Type { } err = api Retry Loop ( func ( ) error { return service . Get Job Retry ( & job Request , & job Results ) } ) if err ! = nil { return nil , err } return job Results . Data . ( * dynectsoap . Get All Records Response Type ) , nil } return & records , nil } 
func ( d * dyn Provider State ) fetch All Record Links In Zone ( client * dynect . Client , zone string ) ( [ ] string , error ) { var all Records dynect . All Records Response err : = client . Do ( " " , fmt . Sprintf ( " " , zone ) , nil , & all Records ) if err ! = nil { return nil , err } return filter And Fix Links ( all Records . Data , d . Domain Filter ) , nil } 
func ( d * dyn Provider State ) build Link To Record ( ep * endpoint . Endpoint ) string { if ep = = nil { return " " } var matching Zone = " " for _ , zone : = range d . Zone IDFilter . zone IDs { if strings . Has Suffix ( ep . DNSName , zone ) { matching Zone = zone break } } if matching Zone = = " " { } if ! d . Domain Filter . Match ( ep . DNSName ) { } return fmt . Sprintf ( " " , ep . Record Type , matching Zone , ep . DNSName ) } 
func ( d * dyn Provider State ) login ( ) ( * dynect . Client , error ) { if d . Last Login Error Time ! = 0 { seconds Since Last Error : = unix Now ( ) - d . Last Login Error Time if seconds Since Last Error < bad Login Min Interval Seconds { return nil , fmt . Errorf ( " " , seconds Since Last Error ) } } client : = dynect . New Client ( d . Customer Name ) var req = dynect . Login Block { Username : d . Username , Password : d . Password , Customer Name : d . Customer Name } var resp dynect . Login Response err : = client . Do ( " " , " " , req , & resp ) if err ! = nil { d . Last Login Error Time = unix Now ( ) return nil , err } d . Last Login Error Time = 0 client . Token = resp . Data . Token return client , nil } 
func ( d * dyn Provider State ) zones ( client * dynect . Client ) [ ] string { return d . Zone IDFilter . zone IDs } 
func ( d * dyn Provider State ) delete Record ( client * dynect . Client , ep * endpoint . Endpoint ) error { link : = d . build Link To Record ( ep ) if link = = " " { return nil } response : = dynect . Record Response { } err : = api Retry Loop ( func ( ) error { return client . Do ( " " , link , nil , & response ) } ) log . Debugf ( " " , link , error Or Value ( err , & response ) ) return err } 
func ( d * dyn Provider State ) replace Record ( client * dynect . Client , ep * endpoint . Endpoint ) error { link , record : = d . build Record Request ( ep ) if link = = " " { return nil } response : = dynect . Record Response { } err : = api Retry Loop ( func ( ) error { return client . Do ( " " , link , record , & response ) } ) log . Debugf ( " " , link , error Or Value ( err , & response ) ) return err } 
func ( d * dyn Provider State ) commit ( client * dynect . Client ) error { errs : = [ ] error { } for _ , zone : = range d . zones ( client ) { err : = client . Do ( " " , fmt . Sprintf ( " " , zone ) , nil , & response ) log . Debugf ( " " , zone , error Or Value ( err , & response ) ) } h , err : = os . Hostname ( ) if err ! = nil { h = " " } notes : = fmt . Sprintf ( " " , d . App Version , d . Dyn Version , time . Now ( ) . Format ( time . RFC 3 3 3 9 ) , h , ) zone Publish : = Zone Publish Request { Publish : true , Notes : notes , } response : = Zone Publish Response { } } ) log . Infof ( " " , zone , error Or Value ( err , & response ) ) } switch len ( errs ) { case 0 : return nil case 1 : return errs [ 0 ] default : return fmt . Errorf ( " " , errs ) } } 
func ( d * dyn Provider State ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { client , err : = d . login ( ) if err ! = nil { return nil , err } defer client . Logout ( ) log . Debugf ( " " , d . Dyn Version ) var result [ ] * endpoint . Endpoint zones : = d . zones ( client ) log . Infof ( " " , zones ) for _ , zone : = range zones { serial , err : = d . fetch Zone Serial ( client , zone ) if err ! = nil { if strings . Index ( err . Error ( ) , " " ) > = 0 { log . Infof ( " " , zone ) continue } return nil , err } relevant Records : = d . Zone Snapshot . Get Records For Serial ( zone , serial ) if relevant Records ! = nil { log . Infof ( " " , len ( relevant Records ) , zone , serial ) result = append ( result , relevant Records . . . ) continue } if err ! = nil { return nil , err } relevant Records = d . all Records To Endpoints ( records ) log . Debugf ( " " , relevant Records ) d . Zone Snapshot . Store Records For Serial ( zone , serial , relevant Records ) log . Infof ( " " , len ( relevant Records ) , zone , serial ) result = append ( result , relevant Records . . . ) } return result , nil } 
func ( d * dyn Provider State ) Apply Changes ( changes * plan . Changes ) error { log . Debugf ( " " , changes ) if d . Dry Run { log . Infof ( " " , changes . Delete ) log . Infof ( " " , changes . Create ) log . Infof ( " " , merge ( changes . Update Old , changes . Update New ) ) return nil } client , err : = d . login ( ) if err ! = nil { return err } defer client . Logout ( ) var errs [ ] error needs Commit : = false for _ , ep : = range changes . Delete { err : = d . delete Record ( client , ep ) if err ! = nil { errs = append ( errs , err ) } else { needs Commit = true } } for _ , ep : = range changes . Create { err : = d . create Record ( client , ep ) if err ! = nil { errs = append ( errs , err ) } else { needs Commit = true } } updates : = merge ( changes . Update Old , changes . Update New ) log . Debugf ( " " , updates ) for _ , ep : = range updates { err : = d . replace Record ( client , ep ) if err ! = nil { errs = append ( errs , err ) } else { needs Commit = true } } switch len ( errs ) { case 0 : case 1 : return errs [ 0 ] default : return fmt . Errorf ( " " , errs ) } if needs Commit { return d . commit ( client ) } return nil } 
func ( ms * multi Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { result : = [ ] * endpoint . Endpoint { } for _ , s : = range ms . children { endpoints , err : = s . Endpoints ( ) if err ! = nil { return nil , err } result = append ( result , endpoints . . . ) } return result , nil } 
func new Designate Client ( ) ( designate Client Interface , error ) { service Client , err : = create Designate Service Client ( ) if err ! = nil { return nil , err } return & designate Client { service Client } , nil } 
func remap Env ( mapping map [ string ] string ) { for k , v : = range mapping { current Val : = os . Getenv ( k ) new Val : = os . Getenv ( v ) if current Val = = " " & & new Val ! = " " { os . Setenv ( k , new Val ) } } } 
func get Auth Settings ( ) ( gophercloud . Auth Options , error ) { remap Env ( map [ string ] string { " " : " " , " " : " " , " " : " " , " " : " " , } ) opts , err : = openstack . Auth Options From Env ( ) if err ! = nil { return gophercloud . Auth Options { } , err } opts . Allow Reauth = true if ! strings . Has Suffix ( opts . Identity Endpoint , " " ) { opts . Identity Endpoint + = " " } if ! strings . Has Suffix ( opts . Identity Endpoint , " " ) & & ! strings . Has Suffix ( opts . Identity Endpoint , " " ) { opts . Identity Endpoint + = " " } return opts , nil } 
func create Designate Service Client ( ) ( * gophercloud . Service Client , error ) { opts , err : = get Auth Settings ( ) if err ! = nil { return nil , err } log . Infof ( " " , opts . Identity Endpoint ) auth Provider , err : = openstack . New Client ( opts . Identity Endpoint ) if err ! = nil { return nil , err } tls Config , err : = tlsutils . Create TLSConfig ( " " ) if err ! = nil { return nil , err } transport : = & http . Transport { Proxy : http . Proxy From Environment , Dial Context : ( & net . Dialer { Timeout : 3 0 * time . Second , Keep Alive : 3 0 * time . Second , } ) . Dial Context , Max Idle Conns : 1 0 0 , Idle Conn Timeout : 9 0 * time . Second , TLSHandshake Timeout : 1 0 * time . Second , Expect Continue Timeout : 1 * time . Second , TLSClient Config : tls Config , } auth Provider . HTTPClient . Transport = transport if err = openstack . Authenticate ( auth Provider , opts ) ; err ! = nil { return nil , err } eo : = gophercloud . Endpoint Opts { Region : os . Getenv ( " " ) , } client , err : = openstack . New DNSV 2 ( auth Provider , eo ) if err ! = nil { return nil , err } log . Infof ( " " , client . Endpoint ) return client , nil } 
func ( c designate Client ) For Each Zone ( handler func ( zone * zones . Zone ) error ) error { pager : = zones . List ( c . service Client , zones . List Opts { } ) return pager . Each Page ( func ( page pagination . Page ) ( bool , error ) { list , err : = zones . Extract Zones ( page ) if err ! = nil { return false , err } for _ , zone : = range list { err : = handler ( & zone ) if err ! = nil { return false , err } } return true , nil } , ) } 
func ( c designate Client ) For Each Record Set ( zone ID string , handler func ( record Set * recordsets . Record Set ) error ) error { pager : = recordsets . List By Zone ( c . service Client , zone ID , recordsets . List Opts { } ) return pager . Each Page ( func ( page pagination . Page ) ( bool , error ) { list , err : = recordsets . Extract Record Sets ( page ) if err ! = nil { return false , err } for _ , record Set : = range list { err : = handler ( & record Set ) if err ! = nil { return false , err } } return true , nil } , ) } 
func ( c designate Client ) Create Record Set ( zone ID string , opts recordsets . Create Opts ) ( string , error ) { r , err : = recordsets . Create ( c . service Client , zone ID , opts ) . Extract ( ) if err ! = nil { return " " , err } return r . ID , nil } 
func ( c designate Client ) Update Record Set ( zone ID , record Set ID string , opts recordsets . Update Opts ) error { _ , err : = recordsets . Update ( c . service Client , zone ID , record Set ID , opts ) . Extract ( ) return err } 
func ( c designate Client ) Delete Record Set ( zone ID , record Set ID string ) error { return recordsets . Delete ( c . service Client , zone ID , record Set ID ) . Extract Err ( ) } 
func New Designate Provider ( domain Filter Domain Filter , dry Run bool ) ( Provider , error ) { client , err : = new Designate Client ( ) if err ! = nil { return nil , err } return & designate Provider { client : client , domain Filter : domain Filter , dry Run : dry Run , } , nil } 
func canonicalize Domain Names ( domains [ ] string ) [ ] string { var c Domains [ ] string for _ , d : = range domains { if ! strings . Has Suffix ( d , " " ) { d + = " " c Domains = append ( c Domains , strings . To Lower ( d ) ) } } return c Domains } 
func canonicalize Domain Name ( d string ) string { if ! strings . Has Suffix ( d , " " ) { d + = " " } return strings . To Lower ( d ) } 
func ( p designate Provider ) get Zones ( ) ( map [ string ] string , error ) { result : = map [ string ] string { } err : = p . client . For Each Zone ( func ( zone * zones . Zone ) error { if zone . Type ! = " " & & strings . To Upper ( zone . Type ) ! = " " | | zone . Status ! = " " { return nil } zone Name : = canonicalize Domain Name ( zone . Name ) if ! p . domain Filter . Match ( zone Name ) { return nil } result [ zone . ID ] = zone Name return nil } , ) return result , err } 
func ( p designate Provider ) get Host Zone ID ( hostname string , managed Zones map [ string ] string ) ( string , error ) { longest Zone Length : = 0 result ID : = " " for zone ID , zone Name : = range managed Zones { if ! strings . Has Suffix ( hostname , zone Name ) { continue } ln : = len ( zone Name ) if ln > longest Zone Length { result ID = zone ID longest Zone Length = ln } } return result ID , nil } 
func ( p designate Provider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { var result [ ] * endpoint . Endpoint managed Zones , err : = p . get Zones ( ) if err ! = nil { return nil , err } for zone ID : = range managed Zones { err = p . client . For Each Record Set ( zone ID , func ( record Set * recordsets . Record Set ) error { if record Set . Type ! = endpoint . Record Type A & & record Set . Type ! = endpoint . Record Type TXT & & record Set . Type ! = endpoint . Record Type CNAME { return nil } for _ , record : = range record Set . Records { ep : = endpoint . New Endpoint ( record Set . Name , record Set . Type , record ) ep . Labels [ designate Record Set ID ] = record Set . ID ep . Labels [ designate Zone ID ] = record Set . Zone ID ep . Labels [ designate Original Records ] = strings . Join ( record Set . Records , " \ 0 0 0 " ) result = append ( result , ep ) } return nil } , ) if err ! = nil { return nil , err } } return result , nil } 
func add Endpoint ( ep * endpoint . Endpoint , record Sets map [ string ] * record Set , delete bool ) { key : = fmt . Sprintf ( " " , ep . DNSName , ep . Record Type ) rs : = record Sets [ key ] if rs = = nil { rs = & record Set { dns Name : canonicalize Domain Name ( ep . DNSName ) , record Type : ep . Record Type , names : make ( map [ string ] bool ) , } } if rs . zone ID = = " " { rs . zone ID = ep . Labels [ designate Zone ID ] } if rs . record Set ID = = " " { rs . record Set ID = ep . Labels [ designate Record Set ID ] } for _ , rec : = range strings . Split ( ep . Labels [ designate Original Records ] , " \ 0 0 0 " ) { if _ , ok : = rs . names [ rec ] ; ! ok & & rec ! = " " { rs . names [ rec ] = true } } targets : = ep . Targets if ep . Record Type = = endpoint . Record Type CNAME { targets = canonicalize Domain Names ( targets ) } for _ , t : = range targets { rs . names [ t ] = ! delete } record Sets [ key ] = rs } 
func ( p designate Provider ) Apply Changes ( changes * plan . Changes ) error { managed Zones , err : = p . get Zones ( ) if err ! = nil { return err } record Sets : = map [ string ] * record Set { } for _ , ep : = range changes . Create { add Endpoint ( ep , record Sets , false ) } for _ , ep : = range changes . Update New { add Endpoint ( ep , record Sets , false ) } for _ , ep : = range changes . Update Old { add Endpoint ( ep , record Sets , true ) } for _ , ep : = range changes . Delete { add Endpoint ( ep , record Sets , true ) } for _ , rs : = range record Sets { if err 2 : = p . upsert Record Set ( rs , managed Zones ) ; err = = nil { err = err 2 } } return err } 
func ( p designate Provider ) upsert Record Set ( rs * record Set , managed Zones map [ string ] string ) error { if rs . zone ID = = " " { var err error rs . zone ID , err = p . get Host Zone ID ( rs . dns Name , managed Zones ) if err ! = nil { return err } if rs . zone ID = = " " { log . Debugf ( " " , rs . dns Name ) return nil } } var records [ ] string for rec , v : = range rs . names { if v { records = append ( records , rec ) } } if rs . record Set ID = = " " & & records = = nil { return nil } if rs . record Set ID = = " " { opts : = recordsets . Create Opts { Name : rs . dns Name , Type : rs . record Type , Records : records , } log . Infof ( " " , rs . dns Name , rs . record Type , strings . Join ( records , " " ) ) if p . dry Run { return nil } _ , err : = p . client . Create Record Set ( rs . zone ID , opts ) return err } else if len ( records ) = = 0 { log . Infof ( " " , rs . dns Name , rs . record Type ) if p . dry Run { return nil } return p . client . Delete Record Set ( rs . zone ID , rs . record Set ID ) } else { opts : = recordsets . Update Opts { Records : records , } log . Infof ( " " , rs . dns Name , rs . record Type , strings . Join ( records , " " ) ) if p . dry Run { return nil } return p . client . Update Record Set ( rs . zone ID , rs . record Set ID , opts ) } } 
func New Istio Gateway Source ( kube Client kubernetes . Interface , istio Client istiomodel . Config Store , istio Ingress Gateway Services [ ] string , namespace string , annotation Filter string , fqdn Template string , combine Fqdn Annotation bool , ignore Hostname Annotation bool , ) ( Source , error ) { var ( tmpl * template . Template err error ) for _ , lb Service : = range istio Ingress Gateway Services { if _ , _ , err = parse Ingress Gateway ( lb Service ) ; err ! = nil { return nil , err } } if fqdn Template ! = " " { tmpl , err = template . New ( " " ) . Funcs ( template . Func Map { " " : strings . Trim Prefix , } ) . Parse ( fqdn Template ) if err ! = nil { return nil , err } } return & gateway Source { kube Client : kube Client , istio Client : istio Client , istio Ingress Gateway Services : istio Ingress Gateway Services , namespace : namespace , annotation Filter : annotation Filter , fqdn Template : tmpl , combine FQDNAnnotation : combine Fqdn Annotation , ignore Hostname Annotation : ignore Hostname Annotation , } , nil } 
func ( sc * gateway Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { configs , err : = sc . istio Client . List ( istiomodel . Gateway . Type , sc . namespace ) if err ! = nil { return nil , err } configs , err = sc . filter By Annotations ( configs ) if err ! = nil { return nil , err } endpoints : = [ ] * endpoint . Endpoint { } for _ , config : = range configs { if ok & & controller ! = controller Annotation Value { log . Debugf ( " " , config . Namespace , config . Name , controller , controller Annotation Value ) continue } gw Endpoints , err : = sc . endpoints From Gateway Config ( config ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } if sc . combine FQDNAnnotation { gw Endpoints = append ( gw Endpoints , i Endpoints . . . ) } else { gw Endpoints = i Endpoints } } if len ( gw Endpoints ) = = 0 { log . Debugf ( " " , config . Namespace , config . Name ) continue } log . Debugf ( " " , config . Namespace , config . Name , gw Endpoints ) sc . set Resource Label ( config , gw Endpoints ) endpoints = append ( endpoints , gw Endpoints . . . ) } for _ , ep : = range endpoints { sort . Sort ( ep . Targets ) } return endpoints , nil } 
func ( sc * gateway Source ) filter By Annotations ( configs [ ] istiomodel . Config ) ( [ ] istiomodel . Config , error ) { label Selector , err : = metav 1 . Parse To Label Selector ( sc . annotation Filter ) if err ! = nil { return nil , err } selector , err : = metav 1 . Label Selector As Selector ( label Selector ) if err ! = nil { return nil , err } } filtered List : = [ ] istiomodel . Config { } for _ , config : = range configs { } } return filtered List , nil } 
func ( sc * gateway Source ) endpoints From Gateway Config ( config istiomodel . Config ) ( [ ] * endpoint . Endpoint , error ) { var endpoints [ ] * endpoint . Endpoint ttl , err : = get TTLFrom Annotations ( config . Annotations ) if err ! = nil { log . Warn ( err ) } targets : = get Targets From Target Annotation ( config . Annotations ) if len ( targets ) = = 0 { targets , err = sc . targets From Istio Ingress Gateway Services ( ) if err ! = nil { return nil , err } } gateway : = config . Spec . ( * istionetworking . Gateway ) provider Specific : = get Provider Specific Annotations ( config . Annotations ) for _ , server : = range gateway . Servers { for _ , host : = range server . Hosts { if host = = " " { continue } endpoints = append ( endpoints , endpoints For Hostname ( host , targets , ttl , provider Specific ) . . . ) } } for _ , hostname : = range hostname List { endpoints = append ( endpoints , endpoints For Hostname ( hostname , targets , ttl , provider Specific ) . . . ) } } return endpoints , nil } 
func ( in * DNSEndpoint ) Deep Copy Into ( out * DNSEndpoint ) { * out = * in out . Type Meta = in . Type Meta in . Object Meta . Deep Copy Into ( & out . Object Meta ) in . Spec . Deep Copy Into ( & out . Spec ) out . Status = in . Status return } 
func ( in * DNSEndpoint ) Deep Copy ( ) * DNSEndpoint { if in = = nil { return nil } out : = new ( DNSEndpoint ) in . Deep Copy Into ( out ) return out } 
func ( in * DNSEndpoint ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * DNSEndpoint List ) Deep Copy Into ( out * DNSEndpoint List ) { * out = * in out . Type Meta = in . Type Meta out . List Meta = in . List Meta if in . Items ! = nil { in , out : = & in . Items , & out . Items * out = make ( [ ] DNSEndpoint , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . Deep Copy Into ( & ( * out ) [ i ] ) } } return } 
func ( in * DNSEndpoint List ) Deep Copy ( ) * DNSEndpoint List { if in = = nil { return nil } out : = new ( DNSEndpoint List ) in . Deep Copy Into ( out ) return out } 
func ( in * DNSEndpoint List ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * DNSEndpoint Spec ) Deep Copy Into ( out * DNSEndpoint Spec ) { * out = * in if in . Endpoints ! = nil { in , out : = & in . Endpoints , & out . Endpoints * out = make ( [ ] * Endpoint , len ( * in ) ) for i : = range * in { if ( * in ) [ i ] = = nil { ( * out ) [ i ] = nil } else { ( * out ) [ i ] = new ( Endpoint ) ( * in ) [ i ] . Deep Copy Into ( ( * out ) [ i ] ) } } } return } 
func ( in * DNSEndpoint Spec ) Deep Copy ( ) * DNSEndpoint Spec { if in = = nil { return nil } out : = new ( DNSEndpoint Spec ) in . Deep Copy Into ( out ) return out } 
func ( in * DNSEndpoint Status ) Deep Copy ( ) * DNSEndpoint Status { if in = = nil { return nil } out : = new ( DNSEndpoint Status ) in . Deep Copy Into ( out ) return out } 
func ( in * Endpoint ) Deep Copy Into ( out * Endpoint ) { * out = * in if in . Targets ! = nil { in , out : = & in . Targets , & out . Targets * out = make ( Targets , len ( * in ) ) copy ( * out , * in ) } if in . Labels ! = nil { in , out : = & in . Labels , & out . Labels * out = make ( Labels , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } } if in . Provider Specific ! = nil { in , out : = & in . Provider Specific , & out . Provider Specific * out = make ( Provider Specific , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } } return } 
func ( in * Endpoint ) Deep Copy ( ) * Endpoint { if in = = nil { return nil } out : = new ( Endpoint ) in . Deep Copy Into ( out ) return out } 
func ( in Labels ) Deep Copy Into ( out * Labels ) { { in : = & in * out = make ( Labels , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } return } } 
func ( in Labels ) Deep Copy ( ) Labels { if in = = nil { return nil } out : = new ( Labels ) in . Deep Copy Into ( out ) return * out } 
func ( in Provider Specific ) Deep Copy Into ( out * Provider Specific ) { { in : = & in * out = make ( Provider Specific , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } return } } 
func ( in Provider Specific ) Deep Copy ( ) Provider Specific { if in = = nil { return nil } out : = new ( Provider Specific ) in . Deep Copy Into ( out ) return * out } 
func ( in Targets ) Deep Copy Into ( out * Targets ) { { in : = & in * out = make ( Targets , len ( * in ) ) copy ( * out , * in ) return } } 
func ( in Targets ) Deep Copy ( ) Targets { if in = = nil { return nil } out : = new ( Targets ) in . Deep Copy Into ( out ) return * out } 
func ensure Trailing Dot ( hostname string ) string { if net . Parse IP ( hostname ) ! = nil { return hostname } return strings . Trim Suffix ( hostname , " " ) + " " } 
func New Noop Registry ( provider provider . Provider ) ( * Noop Registry , error ) { return & Noop Registry { provider : provider , } , nil } 
func ( im * Noop Registry ) Apply Changes ( changes * plan . Changes ) error { return im . provider . Apply Changes ( changes ) } 
func ( ms * dedup Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { result : = [ ] * endpoint . Endpoint { } collected : = map [ string ] bool { } endpoints , err : = ms . source . Endpoints ( ) if err ! = nil { return nil , err } for _ , ep : = range endpoints { identifier : = ep . DNSName + " " + ep . Targets . String ( ) if _ , ok : = collected [ identifier ] ; ok { log . Debugf ( " " , ep ) continue } collected [ identifier ] = true result = append ( result , ep ) } return result , nil } 
func New Fake Source ( fqdn Template string ) ( Source , error ) { if fqdn Template = = " " { fqdn Template = default FQDNTemplate } return & fake Source { dns Name : fqdn Template , } , nil } 
func ( sc * fake Source ) Endpoints ( ) ( [ ] * endpoint . Endpoint , error ) { endpoints : = make ( [ ] * endpoint . Endpoint , 1 0 ) for i : = 0 ; i < 1 0 ; i + + { endpoints [ i ] , _ = sc . generate Endpoint ( ) } return endpoints , nil } 
func Create TLSConfig ( prefix string ) ( * tls . Config , error ) { ca File : = os . Getenv ( fmt . Sprintf ( " " , prefix ) ) cert File : = os . Getenv ( fmt . Sprintf ( " " , prefix ) ) key File : = os . Getenv ( fmt . Sprintf ( " " , prefix ) ) server Name : = os . Getenv ( fmt . Sprintf ( " " , prefix ) ) is Insecure Str : = strings . To Lower ( os . Getenv ( fmt . Sprintf ( " " , prefix ) ) ) is Insecure : = is Insecure Str = = " " | | is Insecure Str = = " " | | is Insecure Str = = " " tls Config , err : = New TLSConfig ( cert File , key File , ca File , server Name , is Insecure , default Min Version ) if err ! = nil { return nil , err } return tls Config , nil } 
func New AWSSDRegistry ( provider provider . Provider , owner ID string ) ( * AWSSDRegistry , error ) { if owner ID = = " " { return nil , errors . New ( " " ) } return & AWSSDRegistry { provider : provider , owner ID : owner ID , } , nil } 
func ( sdr * AWSSDRegistry ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { records , err : = sdr . provider . Records ( ) if err ! = nil { return nil , err } for _ , record : = range records { labels , err : = endpoint . New Labels From String ( record . Labels [ endpoint . AWSSDDescription Label ] ) if err ! = nil { continue } record . Labels = labels } return records , nil } 
func ( sdr * AWSSDRegistry ) Apply Changes ( changes * plan . Changes ) error { filtered Changes : = & plan . Changes { Create : changes . Create , Update New : filter Owned Records ( sdr . owner ID , changes . Update New ) , Update Old : filter Owned Records ( sdr . owner ID , changes . Update Old ) , Delete : filter Owned Records ( sdr . owner ID , changes . Delete ) , } sdr . update Labels ( filtered Changes . Create ) sdr . update Labels ( filtered Changes . Update New ) sdr . update Labels ( filtered Changes . Update Old ) sdr . update Labels ( filtered Changes . Delete ) return sdr . provider . Apply Changes ( filtered Changes ) } 
func Load OCIConfig ( path string ) ( * OCIConfig , error ) { contents , err : = ioutil . Read File ( path ) if err ! = nil { return nil , errors . Wrapf ( err , " " , path ) } cfg : = OCIConfig { } if err : = yaml . Unmarshal ( contents , & cfg ) ; err ! = nil { return nil , errors . Wrapf ( err , " " , path ) } return & cfg , nil } 
func New OCIProvider ( cfg OCIConfig , domain Filter Domain Filter , zone IDFilter Zone IDFilter , dry Run bool ) ( * OCIProvider , error ) { var client oci DNSClient client , err : = dns . New Dns Client With Configuration Provider ( common . New Raw Configuration Provider ( cfg . Auth . Tenancy ID , cfg . Auth . User ID , cfg . Auth . Region , cfg . Auth . Fingerprint , cfg . Auth . Private Key , & cfg . Auth . Passphrase , ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return & OCIProvider { client : client , cfg : cfg , domain Filter : domain Filter , zone IDFilter : zone IDFilter , dry Run : dry Run , } , nil } 
func ( p * OCIProvider ) Records ( ) ( [ ] * endpoint . Endpoint , error ) { ctx : = context . Background ( ) zones , err : = p . zones ( ctx ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } endpoints : = [ ] * endpoint . Endpoint { } for _ , zone : = range zones { var page * string for { resp , err : = p . client . Get Zone Records ( ctx , dns . Get Zone Records Request { Zone Name Or Id : zone . Id , Page : page , Compartment Id : & p . cfg . Compartment ID , } ) if err ! = nil { return nil , errors . Wrapf ( err , " " , * zone . Id ) } for _ , record : = range resp . Items { if ! supported Record Type ( * record . Rtype ) { continue } endpoints = append ( endpoints , endpoint . New Endpoint With TTL ( * record . Domain , * record . Rtype , endpoint . TTL ( * record . Ttl ) , * record . Rdata , ) , ) } if page = resp . Opc Next Page ; resp . Opc Next Page = = nil { break } } } return endpoints , nil } 
func ( p * OCIProvider ) Apply Changes ( changes * plan . Changes ) error { log . Debugf ( " " , changes ) ops : = [ ] dns . Record Operation { } ops = append ( ops , p . new Filtered Record Operations ( changes . Create , dns . Record Operation Operation Add ) . . . ) ops = append ( ops , p . new Filtered Record Operations ( changes . Update New , dns . Record Operation Operation Add ) . . . ) ops = append ( ops , p . new Filtered Record Operations ( changes . Update Old , dns . Record Operation Operation Remove ) . . . ) ops = append ( ops , p . new Filtered Record Operations ( changes . Delete , dns . Record Operation Operation Remove ) . . . ) if len ( ops ) = = 0 { log . Info ( " " ) return nil } ctx : = context . Background ( ) zones , err : = p . zones ( ctx ) if err ! = nil { return errors . Wrap ( err , " " ) } for zone ID , ops : = range ops By Zone { log . Infof ( " " , zone ID ) for _ , op : = range ops { log . Info ( op ) } } if p . dry Run { return nil } for zone ID , ops : = range ops By Zone { if _ , err : = p . client . Patch Zone Records ( ctx , dns . Patch Zone Records Request { Compartment Id : & p . cfg . Compartment ID , Zone Name Or Id : & zone ID , Patch Zone Records Details : dns . Patch Zone Records Details { Items : ops } , } ) ; err ! = nil { return err } } return nil } 
func new Record Operation ( ep * endpoint . Endpoint , op Type dns . Record Operation Operation Enum ) dns . Record Operation { targets : = make ( [ ] string , len ( ep . Targets ) ) copy ( targets , [ ] string ( ep . Targets ) ) if ep . Record Type = = endpoint . Record Type CNAME { targets [ 0 ] = ensure Trailing Dot ( targets [ 0 ] ) } rdata : = strings . Join ( targets , " " ) ttl : = oci Record TTL if ep . Record TTL . Is Configured ( ) { ttl = int ( ep . Record TTL ) } return dns . Record Operation { Domain : & ep . DNSName , Rdata : & rdata , Ttl : & ttl , Rtype : & ep . Record Type , Operation : op Type , } } 
func operations By Zone ( zones map [ string ] * dns . Zone Summary , ops [ ] dns . Record Operation ) map [ string ] [ ] dns . Record Operation { changes : = make ( map [ string ] [ ] dns . Record Operation ) zone Name IDMapper : = zone IDName { } for _ , z : = range zones { zone Name IDMapper . Add ( * z . Id , * z . Name ) changes [ * z . Id ] = [ ] dns . Record Operation { } } for _ , op : = range ops { if zone ID , _ : = zone Name IDMapper . Find Zone ( * op . Domain ) ; zone ID ! = " " { changes [ zone ID ] = append ( changes [ zone ID ] , op ) } else { log . Warnf ( " " , op ) } } } } return changes } 
func New Azure Provider ( config File string , domain Filter Domain Filter , zone IDFilter Zone IDFilter , resource Group string , dry Run bool ) ( * Azure Provider , error ) { contents , err : = ioutil . Read File ( config File ) if err ! = nil { return nil , fmt . Errorf ( " " , config File , err ) } cfg : = config { } err = yaml . Unmarshal ( contents , & cfg ) if err ! = nil { return nil , fmt . Errorf ( " " , config File , err ) } } var environment azure . Environment if cfg . Cloud = = " " { environment = azure . Public Cloud } else { environment , err = azure . Environment From Name ( cfg . Cloud ) if err ! = nil { return nil , fmt . Errorf ( " " , cfg . Cloud , err ) } } token , err : = get Access Token ( cfg , environment ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } zones Client : = dns . New Zones Client With Base URI ( environment . Resource Manager Endpoint , cfg . Subscription ID ) zones Client . Authorizer = autorest . New Bearer Authorizer ( token ) records Client : = dns . New Record Sets Client With Base URI ( environment . Resource Manager Endpoint , cfg . Subscription ID ) records Client . Authorizer = autorest . New Bearer Authorizer ( token ) provider : = & Azure Provider { domain Filter : domain Filter , zone IDFilter : zone IDFilter , dry Run : dry Run , resource Group : cfg . Resource Group , zones Client : zones Client , records Client : records Client , } return provider , nil } 
func get Access Token ( cfg config , environment azure . Environment ) ( * adal . Service Principal Token , error ) { msi Endpoint , err : = adal . Get MSIVMEndpoint ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } token , err : = adal . New Service Principal Token From MSI ( msi Endpoint , environment . Service Management Endpoint ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return token , nil } oauth Config , err : = adal . New OAuth Config ( environment . Active Directory Endpoint , cfg . Tenant ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } token , err : = adal . New Service Principal Token ( * oauth Config , cfg . Client ID , cfg . Client Secret , environment . Resource Manager Endpoint ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return token , nil } return nil , fmt . Errorf ( " " ) } 
func ( p * Azure Provider ) Records ( ) ( endpoints [ ] * endpoint . Endpoint , _ error ) { zones , err : = p . zones ( ) if err ! = nil { return nil , err } for _ , zone : = range zones { err : = p . iterate Records ( * zone . Name , func ( record Set dns . Record Set ) bool { if record Set . Name = = nil | | record Set . Type = = nil { log . Error ( " " ) return true } record Type : = strings . Trim Left ( * record Set . Type , " " ) if ! supported Record Type ( record Type ) { return true } name : = format Azure DNSName ( * record Set . Name , * zone . Name ) targets : = extract Azure Targets ( & record Set ) if len ( targets ) = = 0 { log . Errorf ( " " , name , record Type ) return true } var ttl endpoint . TTL if record Set . TTL ! = nil { ttl = endpoint . TTL ( * record Set . TTL ) } ep : = endpoint . New Endpoint With TTL ( name , record Type , endpoint . TTL ( ttl ) , targets . . . ) log . Debugf ( " " , ep . Record Type , ep . DNSName , ep . Targets , ) endpoints = append ( endpoints , ep ) return true } ) if err ! = nil { return nil , err } } return endpoints , nil } 
func ( p * Azure Provider ) Apply Changes ( changes * plan . Changes ) error { zones , err : = p . zones ( ) if err ! = nil { return err } deleted , updated : = p . map Changes ( zones , changes ) p . delete Records ( deleted ) p . update Records ( updated ) return nil } 
func format Azure DNSName ( record Name , zone Name string ) string { if record Name = = " " { return zone Name } return fmt . Sprintf ( " " , record Name , zone Name ) } 
func extract Azure Targets ( record Set * dns . Record Set ) [ ] string { properties : = record Set . Record Set Properties if properties = = nil { return [ ] string { } } if a Records ! = nil & & len ( * a Records ) > 0 & & ( * a Records ) [ 0 ] . Ipv 4Address ! = nil { targets : = make ( [ ] string , len ( * a Records ) ) for i , a Record : = range * a Records { targets [ i ] = * a Record . Ipv 4Address } return targets } if cname Record ! = nil & & cname Record . Cname ! = nil { return [ ] string { * cname Record . Cname } } if txt Records ! = nil & & len ( * txt Records ) > 0 & & ( * txt Records ) [ 0 ] . Value ! = nil { values : = ( * txt Records ) [ 0 ] . Value if values ! = nil & & len ( * values ) > 0 { return [ ] string { ( * values ) [ 0 ] } } } return [ ] string { } } 
func ( c * default Disk Creator ) Create ( size int , public SSHKey Path , disk Path string ) error { log . Debugf ( " " , size ) tar Buf , err : = mcnutils . Make Disk Image ( public SSHKey Path ) if err ! = nil { return err } log . Debug ( " " ) return create Disk Image ( disk Path , size , tar Buf ) } 
func create Disk Image ( dest string , size int , r io . Reader ) error { log . Debug ( cmd ) if os . Getenv ( " " ) ! = " " { cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr } stdin , err : = cmd . Stdin Pipe ( ) if err ! = nil { return err } log . Debug ( " " ) if err : = cmd . Start ( ) ; err ! = nil { return err } log . Debug ( " " ) n , err : = io . Copy ( stdin , r ) if err ! = nil { return err } log . Debug ( " " ) } } log . Debug ( " " ) } log . Debug ( " " ) return cmd . Wait ( ) } 
func ( n * host Only Network ) Save ( vbox VBox Manager ) error { if err : = n . Save IPv 4 ( vbox ) ; err ! = nil { return err } if n . DHCP { vbox . vbm ( " " , " " , n . Name , " " ) } return nil } 
func ( n * host Only Network ) Save IPv 4 ( vbox VBox Manager ) error { if n . IPv 4 . IP ! = nil & & n . IPv 4 . Mask ! = nil { if runtime . GOOS = = " " { log . Warn ( " " ) } if err : = vbox . vbm ( " " , " " , n . Name , " " , n . IPv 4 . IP . String ( ) , " " , net . IP ( n . IPv 4 . Mask ) . String ( ) ) ; err ! = nil { return err } } return nil } 
func create Hostonly Adapter ( vbox VBox Manager ) ( * host Only Network , error ) { if runtime . GOOS = = " " { log . Warn ( " " ) } out , err : = vbox . vbm Out ( " " , " " ) if err ! = nil { return nil , err } res : = re Host Only Adapter Created . Find String Submatch ( string ( out ) ) if res = = nil { return nil , errors . New ( " " ) } return & host Only Network { Name : res [ 1 ] } , nil } 
func list Host Only Adapters ( vbox VBox Manager ) ( map [ string ] * host Only Network , error ) { out , err : = vbox . vbm Out ( " " , " " ) if err ! = nil { return nil , err } by Name : = map [ string ] * host Only Network { } by IP : = map [ string ] * host Only Network { } n : = & host Only Network { } err = parse Key Values ( out , re Colon Line , func ( key , val string ) error { switch key { case " " : n . Name = val case " " : n . GUID = val case " " : n . DHCP = ( val ! = " " ) case " " : n . IPv 4 . IP = net . Parse IP ( val ) case " " : n . IPv 4 . Mask = parse IPv 4Mask ( val ) case " " : mac , err : = net . Parse MAC ( val ) if err ! = nil { return err } n . Hw Addr = mac case " " : n . Medium = val case " " : n . Status = val case " " : n . Network Name = val if _ , present : = by Name [ n . Network Name ] ; present { return fmt . Errorf ( " " , n . Network Name ) } by Name [ n . Network Name ] = n if len ( n . IPv 4 . IP ) ! = 0 { if _ , present : = by IP [ n . IPv 4 . IP . String ( ) ] ; present { return fmt . Errorf ( " " , n . IPv 4 . IP ) } by IP [ n . IPv 4 . IP . String ( ) ] = n } n = & host Only Network { } } return nil } ) if err ! = nil { return nil , err } return by Name , nil } 
func remove Orphan DHCPServers ( vbox VBox Manager ) error { dhcps , err : = list DHCPServers ( vbox ) if err ! = nil { return err } if len ( dhcps ) = = 0 { return nil } log . Debug ( " " ) nets , err : = list Host Only Adapters ( vbox ) if err ! = nil { return err } for name : = range dhcps { if strings . Has Prefix ( name , dhcp Prefix ) { if _ , present : = nets [ name ] ; ! present { if err : = vbox . vbm ( " " , " " , " " , name ) ; err ! = nil { log . Warnf ( " " , name , err ) } } } } return nil } 
func add Host Only DHCPServer ( ifname string , d dhcp Server , vbox VBox Manager ) error { name : = dhcp Prefix + ifname dhcps , err : = list DHCPServers ( vbox ) if err ! = nil { return err } if dhcp , ok : = dhcps [ name ] ; ok { command = " " if ( dhcp . IPv 4 . IP . Equal ( d . IPv 4 . IP ) ) & & ( dhcp . IPv 4 . Mask . String ( ) = = d . IPv 4 . Mask . String ( ) ) & & ( dhcp . Lower IP . Equal ( d . Lower IP ) ) & & ( dhcp . Upper IP . Equal ( d . Upper IP ) ) & & ( dhcp . Enabled = = d . Enabled ) { } } args : = [ ] string { " " , command , " " , name , " " , d . IPv 4 . IP . String ( ) , " " , net . IP ( d . IPv 4 . Mask ) . String ( ) , " " , d . Lower IP . String ( ) , " " , d . Upper IP . String ( ) , } if d . Enabled { args = append ( args , " " ) } else { args = append ( args , " " ) } if runtime . GOOS = = " " { log . Warn ( " " ) } return vbox . vbm ( args . . . ) } 
func list DHCPServers ( vbox VBox Manager ) ( map [ string ] * dhcp Server , error ) { out , err : = vbox . vbm Out ( " " , " " ) if err ! = nil { return nil , err } m : = map [ string ] * dhcp Server { } dhcp : = & dhcp Server { } err = parse Key Values ( out , re Colon Line , func ( key , val string ) error { switch key { case " " : dhcp = & dhcp Server { } m [ val ] = dhcp dhcp . Network Name = val case " " : dhcp . IPv 4 . IP = net . Parse IP ( val ) case " " : dhcp . Upper IP = net . Parse IP ( val ) case " " : dhcp . Lower IP = net . Parse IP ( val ) case " " : dhcp . IPv 4 . Mask = parse IPv 4Mask ( val ) case " " : dhcp . Enabled = ( val = = " " ) } return nil } ) if err ! = nil { return nil , err } return m , nil } 
func list Host Interfaces ( hif Host Interfaces , exclude Nets map [ string ] * host Only Network ) ( map [ string ] * net . IPNet , error ) { ifaces , err : = hif . Interfaces ( ) if err ! = nil { return nil , err } m : = map [ string ] * net . IPNet { } for _ , iface : = range ifaces { addrs , err : = hif . Addrs ( & iface ) if err ! = nil { return nil , err } for _ , a : = range addrs { switch ipnet : = a . ( type ) { case * net . IPNet : _ , excluded : = exclude Nets [ ipnet . String ( ) ] if excluded { iface Excluded = true break } } } } } } } return m , nil } 
func check IPNet Collision ( hostonly * net . IPNet , host Ifaces map [ string ] * net . IPNet ) ( bool , error ) { for _ , iface Net : = range host Ifaces { if hostonly . IP . Equal ( iface Net . IP . Mask ( iface Net . Mask ) ) { return true , nil } } return false , nil } 
func parse IPv 4Mask ( s string ) net . IPMask { mask : = net . Parse IP ( s ) if mask = = nil { return nil } return net . IPv 4Mask ( mask [ 1 2 ] , mask [ 1 3 ] , mask [ 1 4 ] , mask [ 1 5 ] ) } 
func New Driver Not Supported ( driver Name , host Name , store Path string ) Driver { return & Driver Not Supported { Base Driver : & Base Driver { Machine Name : host Name , Store Path : store Path , } , Name : driver Name , } } 
func ( c * RPCClient Driver ) rpc String Call ( method string ) ( string , error ) { var info string if err : = c . Client . Call ( method , struct { } { } , & info ) ; err ! = nil { return " " , err } return info , nil } 
func ( c * RPCClient Driver ) Driver Name ( ) string { driver Name , err : = c . rpc String Call ( Driver Name Method ) if err ! = nil { log . Warnf ( " " , err ) } return driver Name } 
func ( c * RPCClient Driver ) Get SSHKey Path ( ) string { path , err : = c . rpc String Call ( Get SSHKey Path Method ) if err ! = nil { log . Warnf ( " " , err ) } return path } 
func Must Be Running ( d Driver ) error { s , err : = d . Get State ( ) if err ! = nil { return err } if s ! = state . Running { return Err Host Is Not Running } return nil } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . Int Flag { Name : " " , Usage : " " , Value : engine . Default Port , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : drivers . Default SSHUser , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : " " , Env Var : " " , } , mcnflag . Int Flag { Name : " " , Usage : " " , Value : drivers . Default SSHPort , Env Var : " " , } , } } 
func New Driver ( host Name , store Path string ) drivers . Driver { return & Driver { Engine Port : engine . Default Port , Base Driver : & drivers . Base Driver { Machine Name : host Name , Store Path : store Path , } , } } 
func power State From Instance View ( instance View * compute . Virtual Machine Instance View ) VMPower State { if instance View = = nil { log . Debug ( " " ) return Unknown } else if instance View . Statuses = = nil | | len ( * instance View . Statuses ) = = 0 { log . Debug ( " " ) return Unknown } statuses : = * instance View . Statuses for _ , v : = range statuses { log . Debugf ( " " , to . String ( v . Code ) ) if strings . Has Prefix ( to . String ( v . Code ) , power State Code Prefix ) { log . Debug ( " " ) s = & v break } } if s = = nil { log . Debug ( " " ) return Unknown } code : = strings . Trim Prefix ( to . String ( s . Code ) , power State Code Prefix ) switch code { case " " : return Stopped case " " : return Stopping case " " : return Starting case " " : return Running case " " : return Deallocated case " " : return Deallocating default : log . Warn ( " " , code ) return Unknown } } 
func migrate String To Slice ( value string , values [ ] string ) ( result [ ] string ) { if value ! = " " { result = append ( result , value ) } result = append ( result , values . . . ) return } 
func Docker Client ( docker Host Docker Host ) ( * dockerclient . Docker Client , error ) { url , err : = docker Host . URL ( ) if err ! = nil { return nil , err } tls Config , err : = cert . Read TLSConfig ( url , docker Host . Auth Options ( ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return dockerclient . New Docker Client ( url , tls Config ) } 
func Create Container ( docker Host Docker Host , config * dockerclient . Container Config , name string ) error { docker , err : = Docker Client ( docker Host ) if err ! = nil { return err } if err = docker . Pull Image ( config . Image , nil ) ; err ! = nil { return fmt . Errorf ( " " , err ) } var auth Config * dockerclient . Auth Config container ID , err : = docker . Create Container ( config , name , auth Config ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err = docker . Start Container ( container ID , & config . Host Config ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( a Azure Client ) cleanup Resource If Exists ( r cleanup Resource ) error { f : = r . Log Fields ( ) log . Info ( fmt . Sprintf ( " " , r . Resource Type ( ) ) , f ) err : = r . Get ( a ) if exists , err : = check Resource Exists From Error ( err ) ; err ! = nil { return err } else if ! exists { log . Debug ( fmt . Sprintf ( " " , r . Resource Type ( ) ) , f ) return nil } if ! r . Has Attached Resources ( ) { log . Debug ( fmt . Sprintf ( " " , r . Resource Type ( ) ) , f ) log . Info ( fmt . Sprintf ( " " , r . Resource Type ( ) ) , f ) return r . Delete ( a ) } log . Info ( fmt . Sprintf ( " " , r . Resource Type ( ) ) , f ) return nil } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Value : default Instance Profile , Usage : " " , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Value : default Disk Size , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Value : default Image , Usage : " " , } , mcnflag . String Slice Flag { Env Var : " " , Name : " " , Value : [ ] string { default Security Group } , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Value : default Availability Zone , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Value : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Value : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Slice Flag { Env Var : " " , Name : " " , Value : [ ] string { } , Usage : " " , } , } } 
func New Driver ( machine Name , store Path string ) drivers . Driver { return & Driver { Instance Profile : default Instance Profile , Disk Size : default Disk Size , Image : default Image , Availability Zone : default Availability Zone , Base Driver : & drivers . Base Driver { Machine Name : machine Name , Store Path : store Path , } , } } 
func ( d * Driver ) Get SSHUsername ( ) string { if d . SSHUser = = " " { name : = strings . To Lower ( d . Image ) if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } if strings . Contains ( name , " " ) { return " " } return default SSHUser } return d . SSHUser } 
func ( d * Driver ) Set Config From Flags ( flags drivers . Driver Options ) error { d . URL = flags . String ( " " ) d . APIKey = flags . String ( " " ) d . APISecret Key = flags . String ( " " ) d . Instance Profile = flags . String ( " " ) d . Disk Size = int 6 4 ( flags . Int ( " " ) ) d . Image = flags . String ( " " ) d . Security Groups = flags . String Slice ( " " ) d . Affinity Groups = flags . String Slice ( " " ) d . Availability Zone = flags . String ( " " ) d . SSHUser = flags . String ( " " ) d . SSHKey = flags . String ( " " ) d . User Data File = flags . String ( " " ) d . User Data = [ ] byte ( default Cloud Init ) d . Set Swarm Config From Flags ( flags ) if d . URL = = " " { d . URL = default APIEndpoint } if d . APIKey = = " " | | d . APISecret Key = = " " { return errors . New ( " " ) } return nil } 
func ( d * Driver ) Pre Create Check ( ) error { if d . User Data File ! = " " { if _ , err : = os . Stat ( d . User Data File ) ; os . Is Not Exist ( err ) { return fmt . Errorf ( " " , d . User Data File ) } } return nil } 
func ( d * Driver ) Get State ( ) ( state . State , error ) { vm , err : = d . virtual Machine ( ) if err ! = nil { return state . Error , err } switch vm . State { case " " : return state . Starting , nil case " " : return state . Running , nil case " " : return state . Running , nil case " " : return state . Stopped , nil case " " : return state . Stopped , nil case " " : return state . Stopped , nil case " " : return state . Paused , nil case " " : return state . Error , nil case " " : return state . Error , nil case " " : return state . Stopped , nil } return state . None , nil } 
func ( d * Driver ) Create ( ) error { cloud Init , err : = d . get Cloud Init ( ) if err ! = nil { return err } log . Infof ( " " ) client : = egoscale . New Client ( d . URL , d . APIKey , d . APISecret Key ) resp , err : = client . Request With Context ( context . TODO ( ) , & egoscale . List Zones { Name : d . Availability Zone , } ) if err ! = nil { return err } zones : = resp . ( * egoscale . List Zones Response ) if len ( zones . Zone ) ! = 1 { return fmt . Errorf ( " " , d . Availability Zone ) } zone : = zones . Zone [ 0 ] . ID log . Debugf ( " " , d . Availability Zone , zone ) templates , err : = client . List With Context ( context . TODO ( ) , & template ) if err ! = nil { return err } image : = strings . To Lower ( d . Image ) re : = regexp . Must Compile ( ` ^Linux ( ?P <name > . + ? ) ( ?P <version > [ 0 - 9 . ] + ) \b ` ) for _ , t : = range templates { tpl : = t . ( * egoscale . Template ) } fullname : = strings . To Lower ( tpl . Name ) if image = = fullname { template = * tpl break } submatch : = re . Find String Submatch ( tpl . Name ) if len ( submatch ) > 0 { name : = strings . Replace ( strings . To Lower ( submatch [ 1 ] ) , " " , " " , - 1 ) version : = submatch [ 2 ] shortname : = fmt . Sprintf ( " " , name , version ) if image = = shortname { template = * tpl break } } } if template . ID = = " " { return fmt . Errorf ( " " , d . Image ) } } log . Debugf ( " " , d . Image , template . ID , d . SSHUser ) if err ! = nil { return err } profiles : = resp . ( * egoscale . List Service Offerings Response ) if len ( profiles . Service Offering ) ! = 1 { return fmt . Errorf ( " " , d . Instance Profile ) } profile : = profiles . Service Offering [ 0 ] . ID log . Debugf ( " " , d . Instance Profile , profile ) for _ , group : = range d . Security Groups { if group = = " " { continue } sg : = & egoscale . Security Group { Name : group } if err : = client . Get ( sg ) ; err ! = nil { if _ , ok : = err . ( * egoscale . Error Response ) ; ! ok { return err } log . Infof ( " " , group ) security Group , err : = d . create Default Security Group ( group ) if err ! = nil { return err } sg . ID = security Group . ID } log . Debugf ( " " , group , sg . ID ) sgs = append ( sgs , sg . ID ) } for _ , group : = range d . Affinity Groups { if group = = " " { continue } ag : = & egoscale . Affinity Group { Name : group } if err : = client . Get ( ag ) ; err ! = nil { if _ , ok : = err . ( * egoscale . Error Response ) ; ! ok { return err } log . Infof ( " " , group ) affinity Group , err : = d . create Default Affinity Group ( group ) if err ! = nil { return err } ag . ID = affinity Group . ID } log . Debugf ( " " , group , ag . ID ) ags = append ( ags , ag . ID ) } key Pair Name = fmt . Sprintf ( " " , d . Machine Name ) log . Infof ( " " ) resp , err : = client . Request With Context ( context . TODO ( ) , & egoscale . Create SSHKey Pair { Name : key Pair Name , } ) if err ! = nil { return fmt . Errorf ( " " , err ) } key Pair : = resp . ( * egoscale . Create SSHKey Pair Response ) . Key Pair if err = os . Mkdir All ( filepath . Dir ( d . Get SSHKey Path ( ) ) , 0 7 5 0 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err = ioutil . Write File ( d . Get SSHKey Path ( ) , [ ] byte ( key Pair . Private Key ) , 0 6 0 0 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } d . Key Pair = key Pair Name } else { log . Infof ( " " , d . SSHKey ) ssh Key : = d . SSHKey if strings . Has Prefix ( ssh Key , " " ) { usr , _ : = user . Current ( ) ssh Key = filepath . Join ( usr . Home Dir , ssh Key [ 2 : ] ) } else { var err error if ssh Key , err = filepath . Abs ( ssh Key ) ; err ! = nil { return err } } if err ! = nil { return fmt . Errorf ( " " , err ) } ssh Authorized Keys : = ` ssh _authorized _keys : - ` cloud Init = bytes . Join ( [ ] [ ] byte { cloud Init , [ ] byte ( ssh Authorized Keys ) , pub Key } , [ ] byte ( " " ) ) } if err : = os . Chmod ( d . Get SSHKey Path ( ) , 0 6 0 0 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } log . Infof ( " " ) log . Debugf ( " " ) log . Debugf ( " " , string ( cloud Init ) ) encoded User Data : = base 6 4 . Std Encoding . Encode To String ( d . User Data ) req : = & egoscale . Deploy Virtual Machine { Template ID : template . ID , Service Offering ID : profile , User Data : encoded User Data , Zone ID : zone , Name : d . Machine Name , Key Pair : d . Key Pair , Display Name : d . Machine Name , Root Disk Size : d . Disk Size , Security Group IDs : sgs , Affinity Group IDs : ags , } log . Infof ( " " , req ) resp , err = client . Request With Context ( context . TODO ( ) , req ) if err ! = nil { return err } vm : = resp . ( * egoscale . Deploy Virtual Machine Response ) . Virtual Machine IPAddress : = vm . Nic [ 0 ] . IPAddress if IPAddress ! = nil { d . IPAddress = IPAddress . String ( ) } d . ID = vm . ID log . Infof ( " " , d . IPAddress , d . Get SSHUsername ( ) ) if vm . Password Enabled { d . Password = vm . Password } } key : = & egoscale . SSHKey Pair { Name : d . Key Pair , } if err : = client . Delete With Context ( context . TODO ( ) , key ) ; err ! = nil { return err } d . Key Pair = " " } return nil } 
func ( d * Driver ) Start ( ) error { cs : = d . client ( ) _ , err : = cs . Request With Context ( context . TODO ( ) , & egoscale . Start Virtual Machine { ID : d . ID , } ) return err } 
func ( d * Driver ) Stop ( ) error { cs : = d . client ( ) _ , err : = cs . Request With Context ( context . TODO ( ) , & egoscale . Stop Virtual Machine { ID : d . ID , } ) return err } 
func ( d * Driver ) Restart ( ) error { cs : = d . client ( ) _ , err : = cs . Request With Context ( context . TODO ( ) , & egoscale . Reboot Virtual Machine { ID : d . ID , } ) return err } 
func ( d * Driver ) Remove ( ) error { client : = d . client ( ) if err : = client . Delete With Context ( context . TODO ( ) , key ) ; err ! = nil { return err } } if err : = client . Delete With Context ( context . TODO ( ) , vm ) ; err ! = nil { return err } } log . Infof ( " " ) return nil } 
func ( d * Driver ) get Cloud Init ( ) ( [ ] byte , error ) { var err error if d . User Data File ! = " " { d . User Data , err = ioutil . Read File ( d . User Data File ) } return d . User Data , err } 
func ( xcg * X 5 0 9Cert Generator ) Generate CACertificate ( cert File , key File , org string , bits int ) error { template , err : = xcg . new Certificate ( org ) if err ! = nil { return err } template . Is CA = true template . Key Usage | = x 5 0 9 . Key Usage Cert Sign template . Key Usage | = x 5 0 9 . Key Usage Key Encipherment template . Key Usage | = x 5 0 9 . Key Usage Key Agreement priv , err : = rsa . Generate Key ( rand . Reader , bits ) if err ! = nil { return err } der Bytes , err : = x 5 0 9 . Create Certificate ( rand . Reader , template , template , & priv . Public Key , priv ) if err ! = nil { return err } cert Out , err : = os . Create ( cert File ) if err ! = nil { return err } pem . Encode ( cert Out , & pem . Block { Type : " " , Bytes : der Bytes } ) cert Out . Close ( ) key Out , err : = os . Open File ( key File , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 0 0 ) if err ! = nil { return err } pem . Encode ( key Out , & pem . Block { Type : " " , Bytes : x 5 0 9 . Marshal PKCS 1Private Key ( priv ) } ) key Out . Close ( ) return nil } 
func ( xcg * X 5 0 9Cert Generator ) Generate Cert ( opts * Options ) error { template , err : = xcg . new Certificate ( opts . Org ) if err ! = nil { return err } template . Key Usage = x 5 0 9 . Key Usage Digital Signature } else { if opts . Swarm Master { } for _ , h : = range opts . Hosts { if ip : = net . Parse IP ( h ) ; ip ! = nil { template . IPAddresses = append ( template . IPAddresses , ip ) } else { template . DNSNames = append ( template . DNSNames , h ) } } } tls Cert , err : = tls . Load X 5 0 9Key Pair ( opts . CAFile , opts . CAKey File ) if err ! = nil { return err } priv , err : = rsa . Generate Key ( rand . Reader , opts . Bits ) if err ! = nil { return err } x 5 0 9Cert , err : = x 5 0 9 . Parse Certificate ( tls Cert . Certificate [ 0 ] ) if err ! = nil { return err } der Bytes , err : = x 5 0 9 . Create Certificate ( rand . Reader , template , x 5 0 9Cert , & priv . Public Key , tls Cert . Private Key ) if err ! = nil { return err } cert Out , err : = os . Create ( opts . Cert File ) if err ! = nil { return err } pem . Encode ( cert Out , & pem . Block { Type : " " , Bytes : der Bytes } ) cert Out . Close ( ) key Out , err : = os . Open File ( opts . Key File , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 0 0 ) if err ! = nil { return err } pem . Encode ( key Out , & pem . Block { Type : " " , Bytes : x 5 0 9 . Marshal PKCS 1Private Key ( priv ) } ) key Out . Close ( ) return nil } 
func ( xcg * X 5 0 9Cert Generator ) Read TLSConfig ( addr string , auth Options * auth . Options ) ( * tls . Config , error ) { ca Cert Path : = auth Options . Ca Cert Path client Cert Path : = auth Options . Client Cert Path client Key Path : = auth Options . Client Key Path log . Debugf ( " " , ca Cert Path ) ca Cert , err : = ioutil . Read File ( ca Cert Path ) if err ! = nil { return nil , err } log . Debugf ( " " , client Cert Path ) client Cert , err : = ioutil . Read File ( client Cert Path ) if err ! = nil { return nil , err } log . Debugf ( " " , client Key Path ) client Key , err : = ioutil . Read File ( client Key Path ) if err ! = nil { return nil , err } return xcg . get TLSConfig ( ca Cert , client Cert , client Key , false ) } 
func ( xcg * X 5 0 9Cert Generator ) Validate Certificate ( addr string , auth Options * auth . Options ) ( bool , error ) { tls Config , err : = xcg . Read TLSConfig ( addr , auth Options ) if err ! = nil { return false , err } dialer : = & net . Dialer { Timeout : time . Second * 2 0 , } _ , err = tls . Dial With Dialer ( dialer , " " , addr , tls Config ) if err ! = nil { return false , err } return true , nil } 
func compare ( v 1 , v 2 string ) int { v 2 = strings . Replace ( v 2 , rc String , " " , - 1 ) } if ! strings . Contains ( v 1 , ce Edition ) & & strings . Contains ( v 2 , ce Edition ) { return - 1 } } return compare CE ( v 1 , v 2 ) } 
func compare CE ( v 1 , v 2 string ) int { return compare Numeric ( strings . Replace ( v 1 , ce Edition , " " , - 1 ) , strings . Replace ( v 2 , ce Edition , " " , - 1 ) , ) } 
func ( d * Driver ) Is VTXDisabled ( ) bool { if cpuid . Has Feature ( cpuid . VMX ) | | cpuid . Has Feature ( cpuid . SVM ) { return false } return true } 
func New VBox Manager ( ) * VBox Cmd Manager { return & VBox Cmd Manager { run Cmd : func ( cmd * exec . Cmd ) error { return cmd . Run ( ) } , } } 
func oauth Client ( ) autorest . Client { c : = autorest . New Client With User Agent ( fmt . Sprintf ( " " , version . Version ) ) c . Request Inspector = with Inspection ( ) c . Response Inspector = by Inspecting ( ) } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default CPU , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Memory , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Disk Size , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHUser , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHPass , } , mcnflag . Bool Flag { Env Var : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) Pre Create Check ( ) error { return b 2dutils . Update ISOCache ( d . Boot 2Docker URL ) } 
func execute SSHCommand ( command string , d * Driver ) error { log . Debugf ( " " , command ) config : = & cryptossh . Client Config { User : d . SSHUser , Auth : [ ] cryptossh . Auth Method { cryptossh . Password ( d . SSHPassword ) , } , } client , err : = cryptossh . Dial ( " " , fmt . Sprintf ( " " , d . IPAddress , d . SSHPort ) , config ) if err ! = nil { log . Debugf ( " " , err ) return err } session , err : = client . New Session ( ) if err ! = nil { log . Debugf ( " " + err . Error ( ) ) return err } defer session . Close ( ) var b bytes . Buffer session . Stdout = & b if err : = session . Run ( command ) ; err ! = nil { log . Debugf ( " " + err . Error ( ) ) return err } log . Debugf ( " " , b . String ( ) ) return nil } 
func driver Path ( driver Name string ) string { for _ , core Driver : = range Core Drivers { if core Driver = = driver Name { if Current Binary Is Docker Machine { return os . Args [ 0 ] } return " " } } return fmt . Sprintf ( " " , driver Name ) } 
func Authenticate Device Flow ( env azure . Environment , subscription ID string ) ( * azure . Service Principal Token , error ) { if err ! = nil { return nil , err } oauth Cfg , err : = env . OAuth Config For Tenant ( tenant ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } token Path : = token Cache Path ( tenant ID ) save Token : = mk Token Callback ( token Path ) save Token Callback : = func ( t azure . Token ) error { log . Debug ( " " ) return save Token ( t ) } f : = logutil . Fields { " " : token Path } app ID , ok : = app IDs [ env . Name ] if ! ok { return nil , fmt . Errorf ( " " , env . Name ) } scope : = get Scope ( env ) if err ! = nil { return nil , err } if spt ! = nil { log . Debug ( " " , f ) if err : = validate Token ( env , spt ) ; err ! = nil { log . Debug ( fmt . Sprintf ( " " , err ) ) log . Debug ( fmt . Sprintf ( " " , token Path ) ) if err : = os . Remove All ( token Path ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } else { log . Debug ( " " ) return spt , nil } } log . Debug ( " " , f ) spt , err = device Flow Auth ( * oauth Cfg , app ID , scope ) if err ! = nil { return nil , err } log . Debug ( " " ) if err : = save Token ( spt . Token ) ; err ! = nil { log . Error ( " " ) return nil , err } return spt , nil } 
func Authenticate Service Principal ( env azure . Environment , subscription ID , sp ID , sp Password string ) ( * azure . Service Principal Token , error ) { tenant ID , err : = load Or Find Tenant ID ( env , subscription ID ) if err ! = nil { return nil , err } oauth Cfg , err : = env . OAuth Config For Tenant ( tenant ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } spt , err : = azure . New Service Principal Token ( * oauth Cfg , sp ID , sp Password , get Scope ( env ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func token From File ( oauth Cfg azure . OAuth Config , token Path , client ID , resource string , callback azure . Token Refresh Callback ) ( * azure . Service Principal Token , error ) { log . Debug ( " " , logutil . Fields { " " : token Path } ) if _ , err : = os . Stat ( token Path ) ; err ! = nil { if os . Is Not Exist ( err ) { } return nil , err } token , err : = azure . Load Token ( token Path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } spt , err : = azure . New Service Principal Token From Manual Token ( oauth Cfg , client ID , resource , * token , callback ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func device Flow Auth ( oauth Cfg azure . OAuth Config , client ID , resource string ) ( * azure . Service Principal Token , error ) { cl : = oauth Client ( ) device Code , err : = azure . Initiate Device Auth ( & cl , oauth Cfg , client ID , resource ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Debug ( " " , logutil . Fields { " " : to . Int 6 4 ( device Code . Expires In ) , " " : to . Int 6 4 ( device Code . Interval ) , } ) token , err : = azure . Wait For User Completion ( & cl , device Code ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } spt , err : = azure . New Service Principal Token From Manual Token ( oauth Cfg , client ID , resource , * token ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return spt , nil } 
func token Cache Path ( tenant ID string ) string { return filepath . Join ( azure Creds Path ( ) , fmt . Sprintf ( " " , tenant ID ) ) } 
func tenant IDPath ( subscription ID string ) string { return filepath . Join ( azure Creds Path ( ) , fmt . Sprintf ( " " , subscription ID ) ) } 
func mk Token Callback ( path string ) azure . Token Refresh Callback { return func ( t azure . Token ) error { if err : = azure . Save Token ( path , 0 6 0 0 , t ) ; err ! = nil { return err } log . Debug ( " " ) return nil } } 
func validate Token ( env azure . Environment , token * azure . Service Principal Token ) error { c : = subscriptions Client ( env . Resource Manager Endpoint ) c . Authorizer = token _ , err : = c . List ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func New Fmt Machine Logger ( ) Machine Logger { return & Fmt Machine Logger { out Writer : os . Stdout , err Writer : os . Stderr , debug : false , history : New History Recorder ( ) , } } 
func new Compute Util ( driver * Driver ) ( * Compute Util , error ) { client , err : = google . Default Client ( oauth 2 . No Context , raw . Compute Scope ) if err ! = nil { return nil , err } service , err : = raw . New ( client ) if err ! = nil { return nil , err } return & Compute Util { zone : driver . Zone , instance Name : driver . Machine Name , user Name : driver . SSHUser , project : driver . Project , disk Type URL : driver . Disk Type , address : driver . Address , network : driver . Network , subnetwork : driver . Subnetwork , preemptible : driver . Preemptible , use Internal IP : driver . Use Internal IP , use Internal IPOnly : driver . Use Internal IPOnly , service : service , zone URL : api URL + driver . Project + " " + driver . Zone , global URL : api URL + driver . Project + " " , Swarm Master : driver . Swarm Master , Swarm Host : driver . Swarm Host , open Ports : driver . Open Ports , } , nil } 
func ( c * Compute Util ) disk ( ) ( * raw . Disk , error ) { return c . service . Disks . Get ( c . project , c . zone , c . disk Name ( ) ) . Do ( ) } 
func ( c * Compute Util ) delete Disk ( ) error { disk , _ : = c . disk ( ) if disk = = nil { return nil } log . Infof ( " " ) op , err : = c . service . Disks . Delete ( c . project , c . zone , c . disk Name ( ) ) . Do ( ) if err ! = nil { return err } log . Infof ( " " ) return c . wait For Regional Op ( op . Name ) } 
func ( c * Compute Util ) static Address ( ) ( string , error ) { if err ! = nil { return " " , err } if ! is Name { return c . address , nil } if err ! = nil { return " " , err } return external Address . Address , nil } 
func ( c * Compute Util ) open Firewall Ports ( d * Driver ) error { log . Infof ( " " ) create : = false rule , _ : = c . firewall Rule ( ) if rule = = nil { create = true rule = & raw . Firewall { Name : firewall Rule , Allowed : [ ] * raw . Firewall Allowed { } , Source Ranges : [ ] string { " " } , Target Tags : [ ] string { firewall Target Tag } , Network : c . global URL + " " + d . Network , } } ports Used , err : = c . ports Used ( ) if err ! = nil { return err } missing Ports : = missing Opened Ports ( rule , ports Used ) if len ( missing Ports ) = = 0 { return nil } for proto , ports : = range missing Ports { rule . Allowed = append ( rule . Allowed , & raw . Firewall Allowed { IPProtocol : proto , Ports : ports , } ) } var op * raw . Operation if create { op , err = c . service . Firewalls . Insert ( c . project , rule ) . Do ( ) } else { op , err = c . service . Firewalls . Update ( c . project , firewall Rule , rule ) . Do ( ) } if err ! = nil { return err } return c . wait For Global Op ( op . Name ) } 
func ( c * Compute Util ) instance ( ) ( * raw . Instance , error ) { return c . service . Instances . Get ( c . project , c . zone , c . instance Name ) . Do ( ) } 
func ( c * Compute Util ) create Instance ( d * Driver ) error { log . Infof ( " " ) var net string if strings . Contains ( d . Network , " " ) { net = d . Network } else { net = c . global URL + " " + d . Network } instance : = & raw . Instance { Name : c . instance Name , Description : " " , Machine Type : c . zone URL + " " + d . Machine Type , Disks : [ ] * raw . Attached Disk { { Boot : true , Auto Delete : true , Type : " " , Mode : " " , } , } , Network Interfaces : [ ] * raw . Network Interface { { Network : net , } , } , Tags : & raw . Tags { Items : parse Tags ( d ) , } , Service Accounts : [ ] * raw . Service Account { { Email : d . Service Account , Scopes : strings . Split ( d . Scopes , " " ) , } , } , Scheduling : & raw . Scheduling { Preemptible : c . preemptible , } , } if strings . Contains ( c . subnetwork , " " ) { instance . Network Interfaces [ 0 ] . Subnetwork = c . subnetwork } else if c . subnetwork ! = " " { instance . Network Interfaces [ 0 ] . Subnetwork = " " + c . project + " " + c . region ( ) + " " + c . subnetwork } if ! c . use Internal IPOnly { cfg : = & raw . Access Config { Type : " " , } instance . Network Interfaces [ 0 ] . Access Configs = append ( instance . Network Interfaces [ 0 ] . Access Configs , cfg ) } if c . address ! = " " { static Address , err : = c . static Address ( ) if err ! = nil { return err } instance . Network Interfaces [ 0 ] . Access Configs [ 0 ] . Nat IP = static Address } disk , err : = c . disk ( ) if disk = = nil | | err ! = nil { instance . Disks [ 0 ] . Initialize Params = & raw . Attached Disk Initialize Params { Disk Name : c . disk Name ( ) , Source Image : " " + d . Machine Image , } else { instance . Disks [ 0 ] . Source = c . zone URL + " " + c . instance Name + " " } op , err : = c . service . Instances . Insert ( c . project , c . zone , instance ) . Do ( ) if err ! = nil { return err } log . Infof ( " " ) if err = c . wait For Regional Op ( op . Name ) ; err ! = nil { return err } instance , err = c . instance ( ) if err ! = nil { return err } return c . upload SSHKey ( instance , d . Get SSHKey Path ( ) ) } 
func ( c * Compute Util ) configure Instance ( d * Driver ) error { log . Infof ( " " ) instance , err : = c . instance ( ) if err ! = nil { return err } if err : = c . add Firewall Tag ( instance ) ; err ! = nil { return err } return c . upload SSHKey ( instance , d . Get SSHKey Path ( ) ) } 
func ( c * Compute Util ) add Firewall Tag ( instance * raw . Instance ) error { log . Infof ( " " ) tags : = instance . Tags for _ , tag : = range tags . Items { if tag = = firewall Target Tag { return nil } } tags . Items = append ( tags . Items , firewall Target Tag ) op , err : = c . service . Instances . Set Tags ( c . project , c . zone , instance . Name , tags ) . Do ( ) if err ! = nil { return err } return c . wait For Regional Op ( op . Name ) } 
func ( c * Compute Util ) upload SSHKey ( instance * raw . Instance , ssh Key Path string ) error { log . Infof ( " " ) ssh Key , err : = ioutil . Read File ( ssh Key Path + " " ) if err ! = nil { return err } meta Data Value : = fmt . Sprintf ( " \n " , c . user Name , strings . Trim Space ( string ( ssh Key ) ) , c . user Name ) op , err : = c . service . Instances . Set Metadata ( c . project , c . zone , c . instance Name , & raw . Metadata { Fingerprint : instance . Metadata . Fingerprint , Items : [ ] * raw . Metadata Items { { Key : " " , Value : & meta Data Value , } , } , } ) . Do ( ) return c . wait For Regional Op ( op . Name ) } 
func parse Tags ( d * Driver ) [ ] string { tags : = [ ] string { firewall Target Tag } if d . Tags ! = " " { tags = append ( tags , strings . Split ( d . Tags , " " ) . . . ) } return tags } 
func ( c * Compute Util ) start Instance ( ) error { op , err : = c . service . Instances . Start ( c . project , c . zone , c . instance Name ) . Do ( ) if err ! = nil { return err } log . Infof ( " " ) return c . wait For Regional Op ( op . Name ) } 
func ( c * Compute Util ) wait For Op ( op Getter func ( ) ( * raw . Operation , error ) ) error { for { op , err : = op Getter ( ) if err ! = nil { return err } log . Debugf ( " " , op . Name , op . Status ) if op . Status = = " " { if op . Error ! = nil { return fmt . Errorf ( " " , * op . Error . Errors [ 0 ] ) } break } time . Sleep ( 1 * time . Second ) } return nil } 
func ( c * Compute Util ) wait For Regional Op ( name string ) error { return c . wait For Op ( func ( ) ( * raw . Operation , error ) { return c . service . Zone Operations . Get ( c . project , c . zone , name ) . Do ( ) } ) } 
func ( c * Compute Util ) wait For Global Op ( name string ) error { return c . wait For Op ( func ( ) ( * raw . Operation , error ) { return c . service . Global Operations . Get ( c . project , name ) . Do ( ) } ) } 
func ( c * Compute Util ) ip ( ) ( string , error ) { instance , err : = c . service . Instances . Get ( c . project , c . zone , c . instance Name ) . Do ( ) if err ! = nil { return " " , unwrap Google Error ( err ) } nic : = instance . Network Interfaces [ 0 ] if c . use Internal IP { return nic . Network IP , nil } return nic . Access Configs [ 0 ] . Nat IP , nil } 
func ( r * RPCServer Driver ) Get SSHPort ( _ * struct { } , reply * int ) error { port , err : = r . Actual Driver . Get SSHPort ( ) * reply = port return err } 
func cmd Output ( name string , args . . . string ) ( string , error ) { cmd : = exec . Command ( name , args . . . ) log . Debugf ( " " , name , strings . Join ( args , " " ) ) stdout , err : = cmd . Output ( ) if err ! = nil { return " " , err } log . Debugf ( " \n \n " , string ( stdout ) ) return string ( stdout ) , nil } 
func set Vmware Cmd ( cmd string ) string { if path , err : = exec . Look Path ( cmd ) ; err = = nil { return path } return filepath . Join ( " " , cmd ) } 
func vdiskmanager ( dest string , size int ) error { cmd : = exec . Command ( vdiskmanbin , " " , " " , " " , " " , fmt . Sprintf ( " " , size ) , " " , " " , dest ) if os . Getenv ( " " ) ! = " " { cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr } if stdout : = cmd . Run ( ) ; stdout ! = nil { if ee , ok : = stdout . ( * exec . Error ) ; ok & & ee = = exec . Err Not Found { return Err VMRUNNot Found } } return nil } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Catalog , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Catalog Item , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Cpus , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Memory , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHPort , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Docker Port , } , } } 
func generate VMName ( ) string { random ID : = mcnutils . Truncate ID ( mcnutils . Generate Random ID ( ) ) return fmt . Sprintf ( " " , random ID ) } 
func ( a Azure Client ) Register Resource Providers ( namespaces . . . string ) error { l , err : = a . providers Client ( ) . List ( nil , " " ) if err ! = nil { return err } if l . Value = = nil { return errors . New ( " " ) } m : = make ( map [ string ] bool ) for _ , p : = range * l . Value { m [ strings . To Lower ( to . String ( p . Namespace ) ) ] = to . String ( p . Registration State ) = = " " } for _ , ns : = range namespaces { registered , ok : = m [ strings . To Lower ( ns ) ] if ! ok { return fmt . Errorf ( " " , ns ) } if registered { log . Debugf ( " " , ns ) } else { log . Info ( " " , logutil . Fields { " " : ns , " " : a . subscription ID , } ) if _ , err : = a . providers Client ( ) . Register ( ns ) ; err ! = nil { return err } } } return nil } 
func ( a Azure Client ) Create Resource Group ( name , location string ) error { if ok , err : = a . resource Group Exists ( name ) ; err ! = nil { return err } else if ok { log . Infof ( " " , name ) return nil } log . Info ( " " , logutil . Fields { " " : name , " " : location } ) _ , err : = a . resource Groups Client ( ) . Create Or Update ( name , resources . Resource Group { Location : to . String Ptr ( location ) , } ) return err } 
func ( a Azure Client ) Cleanup Virtual Network If Exists ( resource Group , name string ) error { return a . cleanup Resource If Exists ( & vnet Cleanup { rg : resource Group , name : name } ) } 
func ( a Azure Client ) Create Subnet ( ctx * Deployment Context , resource Group , virtual Network , name , subnet Prefix string ) error { subnet , err : = a . Get Subnet ( resource Group , virtual Network , name ) if err = = nil { log . Info ( " " ) ctx . Subnet ID = to . String ( subnet . ID ) return err } _ , err = a . subnets Client ( ) . Create Or Update ( resource Group , virtual Network , name , network . Subnet { Properties : & network . Subnet Properties Format { Address Prefix : to . String Ptr ( subnet Prefix ) , } , } , nil ) if err ! = nil { return err } subnet , err = a . subnets Client ( ) . Get ( resource Group , virtual Network , name , " " ) ctx . Subnet ID = to . String ( subnet . ID ) return err } log . Warn ( " " , err ) return err } 
func ( a Azure Client ) Cleanup Subnet If Exists ( resource Group , virtual Network , name string ) error { return a . cleanup Resource If Exists ( & subnet Cleanup { rg : resource Group , vnet : virtual Network , name : name , } ) } 
func ( a Azure Client ) Cleanup Availability Set If Exists ( resource Group , name string ) error { return a . cleanup Resource If Exists ( & av Set Cleanup { rg : resource Group , name : name } ) } 
func ( a Azure Client ) Get Public IPAddress ( resource Group , name string , use Fqdn bool ) ( string , error ) { f : = logutil . Fields { " " : name } log . Debug ( " " , f ) ip , err : = a . public IPAddress Client ( ) . Get ( resource Group , name , " " ) if err ! = nil { return " " , err } if ip . Properties = = nil { log . Debug ( " " , f ) return " " , nil } if use Fqdn { if ip . Properties . DNSSettings = = nil | | ip . Properties . DNSSettings . Fqdn = = nil { return " " , errors . New ( " " ) } return to . String ( ip . Properties . DNSSettings . Fqdn ) , nil } return to . String ( ip . Properties . IPAddress ) , nil } 
func ( a Azure Client ) Get Private IPAddress ( resource Group , name string ) ( string , error ) { f : = logutil . Fields { " " : name } log . Debug ( " " , f ) nic , err : = a . network Interfaces Client ( ) . Get ( resource Group , name , " " ) if err ! = nil { return " " , err } if nic . Properties = = nil | | nic . Properties . IPConfigurations = = nil | | len ( * nic . Properties . IPConfigurations ) = = 0 { log . Debug ( " " , f ) return " " , nil } return to . String ( ( * nic . Properties . IPConfigurations ) [ 0 ] . Properties . Private IPAddress ) , nil } 
func ( a Azure Client ) Stop Virtual Machine ( resource Group , name string ) error { log . Info ( " " , logutil . Fields { " " : name } ) if _ , err : = a . virtual Machines Client ( ) . Power Off ( resource Group , name , nil ) ; err ! = nil { return err } return a . wait VMPower State ( resource Group , name , Stopped , wait Power Off Timeout ) } 
func ( a Azure Client ) Restart Virtual Machine ( resource Group , name string ) error { log . Info ( " " , logutil . Fields { " " : name } ) if _ , err : = a . virtual Machines Client ( ) . Restart ( resource Group , name , nil ) ; err ! = nil { return err } return a . wait VMPower State ( resource Group , name , Running , wait Start Timeout ) } 
func delete Resource If Exists ( resource Type , name string , get Func func ( ) error , delete Func func ( ) ( autorest . Response , error ) ) error { f : = logutil . Fields { " " : name } log . Debug ( fmt . Sprintf ( " " , resource Type ) , f ) if exists , err : = check Resource Exists From Error ( get Func ( ) ) ; err ! = nil { return err } else if ! exists { log . Info ( fmt . Sprintf ( " " , resource Type ) , f ) return nil } log . Info ( fmt . Sprintf ( " " , resource Type ) , f ) _ , err : = delete Func ( ) return err } 
func ( a Azure Client ) wait VMPower State ( resource Group , name string , goal State VMPower State , timeout time . Duration ) error { ch Err : = make ( chan error ) go func ( ch chan error ) { for { select { case < - ch : default : state , err : = a . Get Virtual Machine Power State ( resource Group , name ) if err ! = nil { ch < - err return } if state ! = goal State { log . Debug ( fmt . Sprintf ( " " , power State Polling Interval ) , logutil . Fields { " " : goal State , " " : state , } ) time . Sleep ( power State Polling Interval ) } else { log . Debug ( " " , logutil . Fields { " " : state } ) ch < - nil return } } } } ( ch Err ) select { case < - time . After ( timeout ) : close ( ch Err ) return fmt . Errorf ( " " , goal State , timeout ) case err : = < - ch Err : return err } } 
func check Resource Exists From Error ( err error ) ( bool , error ) { if err = = nil { return true , nil } v , ok : = err . ( autorest . Detailed Error ) if ok & & v . Status Code = = http . Status Not Found { return false , nil } return false , v } 
func os Disk Storage Blob URL ( account * storage . Account Properties , vm Name string ) string { container URL : = os Disk Storage Container URL ( account , vm Name ) blob Name : = fmt . Sprintf ( fmt OSDisk Blob Name , vm Name ) return container URL + blob Name } 
func os Disk Storage Container URL ( account * storage . Account Properties , vm Name string ) string { return fmt . Sprintf ( " " , to . String ( account . Primary Endpoints . Blob ) , os Disk Storage Container Name ( vm Name ) ) } 
func extract Storage Account From VHDURL ( vhd URL string ) ( string , string ) { u , err : = url . Parse ( vhd URL ) if err ! = nil { log . Warn ( fmt . Sprintf ( " " , err ) , logutil . Fields { " " : vhd URL } ) return " " , " " } parts : = strings . Split N ( u . Host , " " , 2 ) if len ( parts ) ! = 2 { log . Warnf ( " " , vhd URL ) return " " , " " } return parts [ 0 ] , strings . Trim Prefix ( parts [ 1 ] , " " ) } 
func New Key Pair ( ) ( key Pair * Key Pair , err error ) { priv , err : = rsa . Generate Key ( rand . Reader , 2 0 4 8 ) if err ! = nil { return nil , Err Key Generation } if err : = priv . Validate ( ) ; err ! = nil { return nil , Err Validation } priv Der : = x 5 0 9 . Marshal PKCS 1Private Key ( priv ) pub SSH , err : = gossh . New Public Key ( & priv . Public Key ) if err ! = nil { return nil , Err Public Key } return & Key Pair { Private Key : priv Der , Public Key : gossh . Marshal Authorized Key ( pub SSH ) , } , nil } 
func ( kp * Key Pair ) Fingerprint ( ) string { b , _ : = base 6 4 . Std Encoding . Decode String ( string ( kp . Public Key ) ) h : = md 5 . New ( ) io . Write String ( h , string ( b ) ) return fmt . Sprintf ( " " , h . Sum ( nil ) ) } 
func Generate SSHKey ( path string ) error { if _ , err : = os . Stat ( path ) ; err ! = nil { if ! os . Is Not Exist ( err ) { return fmt . Errorf ( " " , err ) } kp , err : = New Key Pair ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = kp . Write To File ( path , fmt . Sprintf ( " " , path ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } return nil } 
func load Or Find Tenant ID ( env azure . Environment , subscription ID string ) ( string , error ) { var tenant ID string log . Debug ( " " , logutil . Fields { " " : subscription ID } ) b , err : = ioutil . Read File ( fp ) if err = = nil { tenant ID = strings . Trim Space ( string ( b ) ) log . Debugf ( " " , fp ) } else if os . Is Not Exist ( err ) { log . Debugf ( " " , fp ) } else { return " " , fmt . Errorf ( " " , err ) } t , err : = find Tenant ID ( env , subscription ID ) if err ! = nil { return " " , err } tenant ID = t } log . Debugf ( " " , fp ) } log . Debug ( " " , logutil . Fields { " " : tenant ID , " " : subscription ID } ) return tenant ID , nil } 
func find Tenant ID ( env azure . Environment , subscription ID string ) ( string , error ) { const hdr Key = " " c : = subscriptions Client ( env . Resource Manager Endpoint ) if subs . Response . Response = = nil { return " " , fmt . Errorf ( " " , err ) } } hdr : = subs . Header . Get ( hdr Key ) if hdr = = " " { return " " , fmt . Errorf ( " " , hdr Key ) } m : = r . Find String Submatch ( hdr ) if m = = nil { return " " , fmt . Errorf ( " " , hdr Key , hdr ) } return m [ 1 ] , nil } 
func save Tenant ID ( path string , tenant ID string ) error { var perm os . File Mode = 0 6 0 0 dir : = filepath . Dir ( path ) if err : = os . Mkdir All ( dir , os . Mode Perm ) ; err ! = nil { return fmt . Errorf ( " " , dir , err ) } f , err : = ioutil . Temp File ( dir , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer f . Close ( ) fp : = f . Name ( ) if _ , err : = f . Write ( [ ] byte ( tenant ID ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } f . Close ( ) } if err : = os . Chmod ( path , perm ) ; err ! = nil { return fmt . Errorf ( " " , path , err ) } return nil } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHUser , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHPort , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Image , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Region , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Size , } , mcnflag . Bool Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . Bool Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . Bool Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . Bool Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , } } 
func ( r * Bugsnag Crash Reporter ) Send ( err Crash Error ) error { if r . no Report File Exist ( ) | | r . api Key = = noreport APIKey { log . Debug ( " " ) return nil } if r . api Key = = " " { return errors . New ( " " ) } bugsnag . Configure ( bugsnag . Configuration { APIKey : r . api Key , meta Data : = bugsnag . Meta Data { } meta Data . Add ( " " , " " , fmt . Sprintf ( " " , runtime . Compiler , runtime . Version ( ) ) ) meta Data . Add ( " " , " " , runtime . GOOS ) meta Data . Add ( " " , " " , runtime . GOARCH ) detect Running Shell ( & meta Data ) detect Uname ( & meta Data ) detect OSVersion ( & meta Data ) add File ( err . Log File Path , & meta Data ) var buffer bytes . Buffer for _ , message : = range log . History ( ) { buffer . Write String ( message + " \n " ) } meta Data . Add ( " " , " " , buffer . String ( ) ) return bugsnag . Notify ( err . Cause , meta Data , bugsnag . Severity Error , bugsnag . Context { String : err . Context } , bugsnag . Error Class { Name : fmt . Sprintf ( " " , err . Driver Name , err . Command ) } ) } 
func ( d * Serial Driver ) Create ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Create ( ) } 
func ( d * Serial Driver ) Driver Name ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Driver Name ( ) } 
func ( d * Serial Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get Create Flags ( ) } 
func ( d * Serial Driver ) Get IP ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get IP ( ) } 
func ( d * Serial Driver ) Get Machine Name ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get Machine Name ( ) } 
func ( d * Serial Driver ) Get SSHHostname ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get SSHHostname ( ) } 
func ( d * Serial Driver ) Get SSHKey Path ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get SSHKey Path ( ) } 
func ( d * Serial Driver ) Get SSHPort ( ) ( int , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get SSHPort ( ) } 
func ( d * Serial Driver ) Get SSHUsername ( ) string { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get SSHUsername ( ) } 
func ( d * Serial Driver ) Get URL ( ) ( string , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get URL ( ) } 
func ( d * Serial Driver ) Get State ( ) ( state . State , error ) { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Get State ( ) } 
func ( d * Serial Driver ) Kill ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Kill ( ) } 
func ( d * Serial Driver ) Pre Create Check ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Pre Create Check ( ) } 
func ( d * Serial Driver ) Remove ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Remove ( ) } 
func ( d * Serial Driver ) Restart ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Restart ( ) } 
func ( d * Serial Driver ) Set Config From Flags ( opts Driver Options ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Set Config From Flags ( opts ) } 
func ( d * Serial Driver ) Start ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Start ( ) } 
func ( d * Serial Driver ) Stop ( ) error { d . Lock ( ) defer d . Unlock ( ) return d . Driver . Stop ( ) } 
func Migrate Host V 0To Host V 1 ( host V 0 * V 0 ) * V 1 { host V 1 : = & V 1 { Driver : host V 0 . Driver , Driver Name : host V 0 . Driver Name , } host V 1 . Host Options = & Options V 1 { } host V 1 . Host Options . Engine Options = & engine . Options { TLSVerify : true , Install URL : " " , } host V 1 . Host Options . Swarm Options = & swarm . Options { Address : " " , Discovery : host V 0 . Swarm Discovery , Host : host V 0 . Swarm Host , Master : host V 0 . Swarm Master , } host V 1 . Host Options . Auth Options = & Auth Options V 1 { Store Path : host V 0 . Store Path , Ca Cert Path : host V 0 . Ca Cert Path , Ca Cert Remote Path : " " , Server Cert Path : host V 0 . Server Cert Path , Server Key Path : host V 0 . Server Key Path , Client Key Path : host V 0 . Client Key Path , Server Cert Remote Path : " " , Server Key Remote Path : " " , Private Key Path : host V 0 . Private Key Path , Client Cert Path : host V 0 . Client Cert Path , } return host V 1 } 
func Migrate Host Metadata V 0To Host Metadata V 1 ( m * Metadata V 0 ) * Metadata { host Metadata : = & Metadata { } host Metadata . Driver Name = m . Driver Name host Metadata . Host Options . Engine Options = & engine . Options { } host Metadata . Host Options . Auth Options = & auth . Options { Store Path : m . Store Path , Ca Cert Path : m . Ca Cert Path , Ca Cert Remote Path : " " , Server Cert Path : m . Server Cert Path , Server Key Path : m . Server Key Path , Client Key Path : " " , Server Cert Remote Path : " " , Server Key Remote Path : " " , Ca Private Key Path : m . Private Key Path , Client Cert Path : m . Client Cert Path , } host Metadata . Config Version = m . Config Version return host Metadata } 
func get Process Entry ( pid int ) ( pe * syscall . Process Entry 3 2 , err error ) { snapshot , err : = syscall . Create Toolhelp 3 2Snapshot ( syscall . TH 3 2CS _SNAPPROCESS , 0 ) if err ! = nil { return nil , err } defer syscall . Close Handle ( syscall . Handle ( snapshot ) ) var process Entry syscall . Process Entry 3 2 process Entry . Size = uint 3 2 ( unsafe . Sizeof ( process Entry ) ) err = syscall . Process 3 2First ( snapshot , & process Entry ) if err ! = nil { return nil , err } for { if process Entry . Process ID = = uint 3 2 ( pid ) { pe = & process Entry return } err = syscall . Process 3 2Next ( snapshot , & process Entry ) if err ! = nil { return nil , err } } } 
func get Name And Its Ppid ( pid int ) ( exefile string , parentid int , err error ) { pe , err : = get Process Entry ( pid ) if err ! = nil { return " " , 0 , err } name : = syscall . UTF 1 6To String ( pe . Exe File [ : ] ) return name , int ( pe . Parent Process ID ) , nil } 
func flag Hack Lookup ( flag Name string ) string { } } } } } return " " } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Name : " " , Usage : " " , Value : default Zone , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Machine Type , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Image Name , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default User , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Service Account , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Scopes , Env Var : " " , } , mcnflag . Int Flag { Name : " " , Usage : " " , Value : default Disk Size , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Disk Type , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Network , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Subnetwork , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Env Var : " " , Value : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Slice Flag { Name : " " , Usage : " " , } , } } 
func New Driver ( machine Name string , store Path string ) * Driver { return & Driver { Zone : default Zone , Disk Type : default Disk Type , Disk Size : default Disk Size , Machine Type : default Machine Type , Machine Image : default Image Name , Network : default Network , Subnetwork : default Subnetwork , Service Account : default Service Account , Scopes : default Scopes , Base Driver : & drivers . Base Driver { SSHUser : default User , Machine Name : machine Name , Store Path : store Path , } , } } 
func ( d * Driver ) Set Config From Flags ( flags drivers . Driver Options ) error { d . Project = flags . String ( " " ) if d . Project = = " " { return errors . New ( " " ) } d . Zone = flags . String ( " " ) d . Use Existing = flags . Bool ( " " ) if ! d . Use Existing { d . Machine Type = flags . String ( " " ) d . Machine Image = flags . String ( " " ) d . Machine Image = strings . Trim Prefix ( d . Machine Image , " " ) d . Disk Size = flags . Int ( " " ) d . Disk Type = flags . String ( " " ) d . Address = flags . String ( " " ) d . Network = flags . String ( " " ) d . Subnetwork = flags . String ( " " ) d . Preemptible = flags . Bool ( " " ) d . Use Internal IP = flags . Bool ( " " ) | | flags . Bool ( " " ) d . Use Internal IPOnly = flags . Bool ( " " ) d . Service Account = flags . String ( " " ) d . Scopes = flags . String ( " " ) d . Tags = flags . String ( " " ) d . Open Ports = flags . String Slice ( " " ) } d . SSHUser = flags . String ( " " ) d . SSHPort = 2 2 d . Set Swarm Config From Flags ( flags ) return nil } 
func ( d * Driver ) Pre Create Check ( ) error { c , err : = new Compute Util ( d ) if err ! = nil { return err } if _ , err = c . service . Projects . Get ( d . Project ) . Do ( ) ; err ! = nil { return fmt . Errorf ( " " , d . Project , err ) } instance , _ : = c . instance ( ) if d . Use Existing { if instance = = nil { return fmt . Errorf ( " " , d . Machine Name , d . Zone ) } } else { if instance ! = nil { return fmt . Errorf ( " " , d . Machine Name , d . Zone ) } } return nil } 
func ( d * Driver ) Create ( ) error { log . Infof ( " " ) if err : = ssh . Generate SSHKey ( d . Get SSHKey Path ( ) ) ; err ! = nil { return err } log . Infof ( " " ) c , err : = new Compute Util ( d ) if err ! = nil { return err } if err : = c . open Firewall Ports ( d ) ; err ! = nil { return err } if d . Use Existing { return c . configure Instance ( d ) } return c . create Instance ( d ) } 
func ( d * Driver ) Get IP ( ) ( string , error ) { c , err : = new Compute Util ( d ) if err ! = nil { return " " , err } ip , err : = c . ip ( ) if err ! = nil { return " " , err } if ip = = " " { return " " , drivers . Err Host Is Not Running } return ip , nil } 
func ( d * Driver ) Get State ( ) ( state . State , error ) { c , err : = new Compute Util ( d ) if err ! = nil { return state . None , err } if instance = = nil { disk , _ : = c . disk ( ) if disk = = nil { return state . None , nil } return state . Stopped , nil } switch instance . Status { case " " , " " : return state . Starting , nil case " " : return state . Running , nil case " " , " " , " " : return state . Stopped , nil } return state . None , nil } 
func ( d * Driver ) Start ( ) error { c , err : = new Compute Util ( d ) if err ! = nil { return err } instance , err : = c . instance ( ) if err ! = nil { if ! is Not Found ( err ) { return err } } if instance = = nil { if err = c . create Instance ( d ) ; err ! = nil { return err } } else { if err : = c . start Instance ( ) ; err ! = nil { return err } } d . IPAddress , err = d . Get IP ( ) return err } 
func ( d * Driver ) Stop ( ) error { c , err : = new Compute Util ( d ) if err ! = nil { return err } if err : = c . stop Instance ( ) ; err ! = nil { return err } d . IPAddress = " " return nil } 
func ( d * Driver ) Restart ( ) error { if err : = d . Stop ( ) ; err ! = nil { return err } return d . Start ( ) } 
func ( d * Driver ) Remove ( ) error { c , err : = new Compute Util ( d ) if err ! = nil { return err } if err : = c . delete Instance ( ) ; err ! = nil { if is Not Found ( err ) { log . Warn ( " " ) } else { return err } } if err : = c . delete Disk ( ) ; err ! = nil { if is Not Found ( err ) { log . Warn ( " " ) } else { return err } } return nil } 
func New Driver ( host Name , store Path string ) drivers . Driver { return d } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Name : fl Azure Environment , Usage : " " , Env Var : " " , Value : default Azure Environment , } , mcnflag . String Flag { Name : fl Azure Subscription ID , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : fl Azure Resource Group , Usage : " " , Env Var : " " , Value : default Azure Resource Group , } , mcnflag . String Flag { Name : fl Azure SSHUser , Usage : " " , Env Var : " " , Value : default SSHUser , } , mcnflag . Int Flag { Name : fl Azure Docker Port , Usage : " " , Env Var : " " , Value : default Docker Port , } , mcnflag . String Flag { Name : fl Azure Location , Usage : " " , Env Var : " " , Value : default Azure Location , } , mcnflag . String Flag { Name : fl Azure Size , Usage : " " , Env Var : " " , Value : default Azure Size , } , mcnflag . String Flag { Name : fl Azure Image , Usage : " " , Env Var : " " , Value : default Azure Image , } , mcnflag . String Flag { Name : fl Azure VNet , Usage : " " , Env Var : " " , Value : default Azure VNet , } , mcnflag . String Flag { Name : fl Azure Subnet , Usage : " " , Env Var : " " , Value : default Azure Subnet , } , mcnflag . String Flag { Name : fl Azure Subnet Prefix , Usage : " " , Env Var : " " , Value : default Azure Subnet Prefix , } , mcnflag . String Flag { Name : fl Azure Availability Set , Usage : " " , Env Var : " " , Value : default Azure Availability Set , } , mcnflag . String Flag { Name : fl Azure Custom Data , Env Var : " " , Usage : " " , } , mcnflag . String Flag { Name : fl Azure Private IPAddr , Usage : " " , } , mcnflag . String Flag { Name : fl Azure Storage Type , Usage : " " , Env Var : " " , Value : default Storage Type , } , mcnflag . Bool Flag { Name : fl Azure Use Private IP , Usage : " " , } , mcnflag . Bool Flag { Name : fl Azure No Public IP , Usage : " " , } , mcnflag . Bool Flag { Name : fl Azure Static Public IP , Usage : " " , } , mcnflag . String Flag { Name : fl Azure DNSLabel , Usage : " " , Env Var : " " , } , mcnflag . String Slice Flag { Name : fl Azure Ports , Usage : " " , } , mcnflag . String Flag { Name : fl Azure Client ID , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : fl Azure Client Secret , Usage : " " , Env Var : " " , } , } } 
func ( d * Driver ) Set Config From Flags ( fl drivers . Driver Options ) error { flag string } { { & d . Base Driver . SSHUser , fl Azure SSHUser } , { & d . Subscription ID , fl Azure Subscription ID } , { & d . Resource Group , fl Azure Resource Group } , { & d . Location , fl Azure Location } , { & d . Size , fl Azure Size } , { & d . Image , fl Azure Image } , { & d . Virtual Network , fl Azure VNet } , { & d . Subnet Name , fl Azure Subnet } , { & d . Subnet Prefix , fl Azure Subnet Prefix } , { & d . Availability Set , fl Azure Availability Set } , { & d . Storage Type , fl Azure Storage Type } , } for _ , f : = range flags { * f . target = fl . String ( f . flag ) if * f . target = = " " { return required Option Error ( f . flag ) } } d . Open Ports = fl . String Slice ( fl Azure Ports ) d . Private IPAddr = fl . String ( fl Azure Private IPAddr ) d . Use Private IP = fl . Bool ( fl Azure Use Private IP ) d . No Public IP = fl . Bool ( fl Azure No Public IP ) d . Static Public IP = fl . Bool ( fl Azure Static Public IP ) d . Docker Port = fl . Int ( fl Azure Docker Port ) d . DNSLabel = fl . String ( fl Azure DNSLabel ) d . Custom Data File = fl . String ( fl Azure Custom Data ) d . Client ID = fl . String ( fl Azure Client ID ) d . Client Secret = fl . String ( fl Azure Client Secret ) d . Set Swarm Config From Flags ( fl ) log . Debug ( " " ) return nil } 
func ( d * Driver ) Pre Create Check ( ) ( err error ) { if d . Custom Data File ! = " " { if _ , err : = os . Stat ( d . Custom Data File ) ; os . Is Not Exist ( err ) { return fmt . Errorf ( " " , d . Custom Data File ) } } c , err : = d . new Azure Client ( ) if err ! = nil { return err } } if err ! = nil { return err } if exists , err : = c . Virtual Machine Exists ( d . Resource Group , d . naming ( ) . VM ( ) ) ; err ! = nil { return err } else if exists { return fmt . Errorf ( " " , d . naming ( ) . VM ( ) , d . Resource Group ) } return nil } 
func ( d * Driver ) Create ( ) error { if err ! = nil { return err } var custom Data string if d . Custom Data File ! = " " { buf , err : = ioutil . Read File ( d . Custom Data File ) if err ! = nil { return err } custom Data = base 6 4 . Std Encoding . Encode To String ( buf ) } if err : = c . Create Resource Group ( d . Resource Group , d . Location ) ; err ! = nil { return err } if err : = c . Create Availability Set If Not Exists ( d . ctx , d . Resource Group , d . Availability Set , d . Location ) ; err ! = nil { return err } if err : = c . Create Network Security Group ( d . ctx , d . Resource Group , d . naming ( ) . NSG ( ) , d . Location , d . ctx . Firewall Rules ) ; err ! = nil { return err } vnet Resource Group , v Net Name : = parse Virtual Network ( d . Virtual Network , d . Resource Group ) if err : = c . Create Virtual Network If Not Exists ( vnet Resource Group , v Net Name , d . Location ) ; err ! = nil { return err } if err : = c . Create Subnet ( d . ctx , vnet Resource Group , v Net Name , d . Subnet Name , d . Subnet Prefix ) ; err ! = nil { return err } if d . No Public IP { log . Info ( " " ) } else { if err : = c . Create Public IPAddress ( d . ctx , d . Resource Group , d . naming ( ) . IP ( ) , d . Location , d . Static Public IP , d . DNSLabel ) ; err ! = nil { return err } } if err : = c . Create Network Interface ( d . ctx , d . Resource Group , d . naming ( ) . NIC ( ) , d . Location , d . ctx . Public IPAddress ID , d . ctx . Subnet ID , d . ctx . Network Security Group ID , d . Private IPAddr ) ; err ! = nil { return err } if err : = c . Create Storage Account ( d . ctx , d . Resource Group , d . Location , storage . Sku Name ( d . Storage Type ) ) ; err ! = nil { return err } if err : = d . generate SSHKey ( d . ctx ) ; err ! = nil { return err } err = c . Create Virtual Machine ( d . Resource Group , d . naming ( ) . VM ( ) , d . Location , d . Size , d . ctx . Availability Set ID , d . ctx . Network Interface ID , d . Base Driver . SSHUser , d . ctx . SSHPublic Key , d . Image , custom Data , d . ctx . Storage Account ) return err } 
func ( d * Driver ) Remove ( ) error { if err : = d . check Legacy Driver ( false ) ; err ! = nil { return err } c , err : = d . new Azure Client ( ) if err ! = nil { return err } if err : = c . Delete Virtual Machine If Exists ( d . Resource Group , d . naming ( ) . VM ( ) ) ; err ! = nil { return err } if err : = c . Delete Network Interface If Exists ( d . Resource Group , d . naming ( ) . NIC ( ) ) ; err ! = nil { return err } if err : = c . Delete Public IPAddress If Exists ( d . Resource Group , d . naming ( ) . IP ( ) ) ; err ! = nil { return err } if err : = c . Delete Network Security Group If Exists ( d . Resource Group , d . naming ( ) . NSG ( ) ) ; err ! = nil { return err } if err : = c . Cleanup Availability Set If Exists ( d . Resource Group , d . Availability Set ) ; err ! = nil { return err } if err : = c . Cleanup Subnet If Exists ( d . Resource Group , d . Virtual Network , d . Subnet Name ) ; err ! = nil { return err } err = c . Cleanup Virtual Network If Exists ( d . Resource Group , d . Virtual Network ) return err } 
func ( d * Driver ) Get IP ( ) ( string , error ) { if err : = d . check Legacy Driver ( true ) ; err ! = nil { return " " , err } if d . resolved IP = = " " { ip , err : = d . ip Address ( ) if err ! = nil { return " " , err } d . resolved IP = ip } log . Debugf ( " " , d . resolved IP ) return d . resolved IP , nil } 
func ( d * Driver ) Get URL ( ) ( string , error ) { if err : = drivers . Must Be Running ( d ) ; err ! = nil { return " " , err } if err ! = nil { return " " , err } u : = ( & url . URL { Scheme : " " , Host : net . Join Host Port ( ip , fmt . Sprintf ( " " , d . Docker Port ) ) , } ) . String ( ) log . Debugf ( " " , u ) return u , nil } 
func ( d * Driver ) Get State ( ) ( state . State , error ) { if err : = d . check Legacy Driver ( true ) ; err ! = nil { return state . None , err } c , err : = d . new Azure Client ( ) if err ! = nil { return state . None , err } power State , err : = c . Get Virtual Machine Power State ( d . Resource Group , d . naming ( ) . VM ( ) ) if err ! = nil { return state . None , err } machine State : = machine State For VMPower State ( power State ) log . Debugf ( " " , power State , machine State ) return machine State , nil } 
func ( d * Driver ) Start ( ) error { if err : = d . check Legacy Driver ( true ) ; err ! = nil { return err } c , err : = d . new Azure Client ( ) if err ! = nil { return err } return c . Start Virtual Machine ( d . Resource Group , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) Stop ( ) error { if err : = d . check Legacy Driver ( true ) ; err ! = nil { return err } c , err : = d . new Azure Client ( ) if err ! = nil { return err } log . Info ( " " ) log . Info ( " " ) return c . Stop Virtual Machine ( d . Resource Group , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) Restart ( ) error { if err : = d . check Legacy Driver ( true ) ; err ! = nil { return err } if err ! = nil { return err } return c . Restart Virtual Machine ( d . Resource Group , d . naming ( ) . VM ( ) ) } 
func ( d * Driver ) check Legacy Driver ( short bool ) error { if d . Resource Group = = " " { if short { return errors . New ( " " ) } return errors . New ( " " ) } return nil } 
func create ( ) { log . Set Debug ( true ) client : = libmachine . New Client ( " " , " " ) defer client . Close ( ) host Name : = " " driver . CPU = 2 driver . Memory = 2 0 4 8 data , err : = json . Marshal ( driver ) if err ! = nil { log . Error ( err ) return } h , err : = client . New Host ( " " , data ) if err ! = nil { log . Error ( err ) return } h . Host Options . Engine Options . Storage Driver = " " if err : = client . Create ( h ) ; err ! = nil { log . Error ( err ) return } out , err : = h . Run SSHCommand ( " " ) if err ! = nil { log . Error ( err ) return } fmt . Printf ( " \n \n " , out ) fmt . Println ( " " ) if err : = h . Stop ( ) ; err ! = nil { log . Error ( err ) return } } 
func streaming ( ) { log . Set Debug ( true ) client : = libmachine . New Client ( " " , " " ) defer client . Close ( ) host Name : = " " data , err : = json . Marshal ( driver ) if err ! = nil { log . Error ( err ) return } h , err : = client . New Host ( " " , data ) if err ! = nil { log . Error ( err ) return } if err : = client . Create ( h ) ; err ! = nil { log . Error ( err ) return } h . Host Options . Engine Options . Storage Driver = " " ssh Client , err : = h . Create SSHClient ( ) if err ! = nil { log . Error ( err ) return } stdout , stderr , err : = ssh Client . Start ( " " ) if err ! = nil { log . Error ( err ) return } defer func ( ) { _ = stdout . Close ( ) _ = stderr . Close ( ) } ( ) scanner : = bufio . New Scanner ( stdout ) for scanner . Scan ( ) { fmt . Println ( scanner . Text ( ) ) } if err : = scanner . Err ( ) ; err ! = nil { log . Error ( err ) } if err : = ssh Client . Wait ( ) ; err ! = nil { log . Error ( err ) } fmt . Println ( " " ) if err : = h . Stop ( ) ; err ! = nil { log . Error ( err ) return } } 
func New Driver ( host Name , store Path string ) * Driver { return & Driver { Disk Size : default Disk Size , Mem Size : default Memory , CPU : default CPU , Disable Dynamic Memory : default Disable Dynamic Memory , Base Driver : & drivers . Base Driver { Machine Name : host Name , Store Path : store Path , } , } } 
func ( d * Driver ) Pre Create Check ( ) error { } } if err ! = nil { return err } if ! is Admin { return Err Not Administrator } } err = b 2dutils . Update ISOCache ( d . Boot 2Docker URL ) return err } 
func ( d * Driver ) wait For IP ( ) ( string , error ) { log . Infof ( " " ) for { ip , _ : = d . Get IP ( ) if ip ! = " " { return ip , nil } time . Sleep ( 1 * time . Second ) } } 
func ( d * Driver ) wait Stopped ( ) error { log . Infof ( " " ) for { s , err : = d . Get State ( ) if err ! = nil { return err } if s ! = state . Running { return nil } time . Sleep ( 1 * time . Second ) } } 
func ( d * Driver ) Start ( ) error { if err : = cmd ( " \ \ " , d . Machine Name ) ; err ! = nil { return err } ip , err : = d . wait For IP ( ) if err ! = nil { return err } d . IPAddress = ip return nil } 
func ( d * Driver ) Stop ( ) error { if err : = cmd ( " \ \ " , d . Machine Name ) ; err ! = nil { return err } if err : = d . wait Stopped ( ) ; err ! = nil { return err } d . IPAddress = " " return nil } 
func ( d * Driver ) Remove ( ) error { s , err : = d . Get State ( ) if err ! = nil { return err } if s = = state . Running { if err : = d . Kill ( ) ; err ! = nil { return err } } return cmd ( " \ \ " , d . Machine Name , " " ) } 
func ( d * Driver ) generate Disk Image ( ) ( string , error ) { disk Image : = d . Resolve Store Path ( " " ) fixed : = d . Resolve Store Path ( " " ) if err ! = nil { return " " , err } fixed Disk Size : = " " if ! is Windows Admin { fixed Disk Size = to Mb ( d . Disk Size ) } log . Infof ( " " ) if err : = cmd ( " \ \ " , " " , quote ( fixed ) , " " , fixed Disk Size , " " ) ; err ! = nil { return " " , err } tar Buf , err : = mcnutils . Make Disk Image ( d . public SSHKey Path ( ) ) if err ! = nil { return " " , err } file , err : = os . Open File ( fixed , os . O _WRONLY , 0 6 4 4 ) if err ! = nil { return " " , err } defer file . Close ( ) file . Seek ( 0 , os . SEEK _SET ) _ , err = file . Write ( tar Buf . Bytes ( ) ) if err ! = nil { return " " , err } file . Close ( ) if err : = cmd ( " \ \ " , " " , quote ( fixed ) , " " , quote ( disk Image ) , " " , " " , " " ) ; err ! = nil { return " " , err } if is Windows Admin { if err : = cmd ( " \ \ " , " " , quote ( disk Image ) , " " , to Mb ( d . Disk Size ) ) ; err ! = nil { return " " , err } } return disk Image , nil } 
func ( d * Base Driver ) Get IP ( ) ( string , error ) { if d . IPAddress = = " " { return " " , errors . New ( " " ) } return d . IPAddress , nil } 
func ( d * Base Driver ) Get SSHKey Path ( ) string { if d . SSHKey Path = = " " { d . SSHKey Path = d . Resolve Store Path ( " " ) } return d . SSHKey Path } 
func ( d * Base Driver ) Get SSHPort ( ) ( int , error ) { if d . SSHPort = = 0 { d . SSHPort = Default SSHPort } return d . SSHPort , nil } 
func ( d * Base Driver ) Get SSHUsername ( ) string { if d . SSHUser = = " " { d . SSHUser = Default SSHUser } return d . SSHUser } 
func ( d * Base Driver ) Resolve Store Path ( file string ) string { return filepath . Join ( d . Store Path , " " , d . Machine Name , file ) } 
func ( d * Base Driver ) Set Swarm Config From Flags ( flags Driver Options ) { d . Swarm Master = flags . Bool ( " " ) d . Swarm Host = flags . String ( " " ) d . Swarm Discovery = flags . String ( " " ) } 
func ( d * Driver ) Is VTXDisabled In The VM ( ) ( bool , error ) { lines , err : = d . read VBox Log ( ) if err ! = nil { return true , err } for _ , line : = range lines { if strings . Contains ( line , " " ) & & ! strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) { return true , nil } if strings . Contains ( line , " " ) & & strings . Contains ( line , " " ) { return true , nil } } return false , nil } 
func ( * b 2d Release Getter ) get Release Tag ( api URL string ) ( string , error ) { if api URL = = " " { api URL = default URL } if ! version . RC ( ) { } client : = get Client ( ) req , err : = get Request ( api URL ) if err ! = nil { return " " , err } rsp , err : = client . Do ( req ) if err ! = nil { return " " , err } defer rsp . Body . Close ( ) } if err : = json . New Decoder ( rsp . Body ) . Decode ( & tags ) ; err ! = nil { return " " , err } t : = tags [ 0 ] if t . Tag Name = = " " { return " " , err Git Hub APIResponse } return t . Tag Name , nil } } if err : = json . New Decoder ( rsp . Body ) . Decode ( & t ) ; err ! = nil { return " " , err } if t . Tag Name = = " " { return " " , err Git Hub APIResponse } return t . Tag Name , nil } 
func ( b * b 2d Release Getter ) get Release URL ( api URL string ) ( string , error ) { if api URL = = " " { api URL = default URL } matches : = re . Find String Submatch ( api URL ) if len ( matches ) ! = 6 { } scheme , host , org , repo : = matches [ 1 ] , matches [ 2 ] , matches [ 4 ] , matches [ 5 ] if host = = " " { host = " " } tag , err : = b . get Release Tag ( api URL ) if err ! = nil { return " " , err } log . Infof ( " " , host , org , repo , tag ) bug URL , ok : = AUFSBug B 2DVersions [ tag ] if ok { log . Warnf ( ` Boot 2Docker %s has a known issue with AUFS . See here for more details : %s Consider specifying another storage driver (e .g . 'overlay ' ) using ' - -engine -storage -driver ' instead . ` , tag , bug URL ) } url : = fmt . Sprintf ( " " , scheme , host , org , repo , tag , b . iso Filename ) return url , nil } 
func ( b * b 2d ISO ) version ( ) ( string , error ) { if b = = nil { return " " , nil } iso , err : = os . Open ( b . common Iso Path ) if err ! = nil { return " " , err } defer iso . Close ( ) iso Metadata : = make ( [ ] byte , b . volume IDLength ) _ , err = iso . Read At ( iso Metadata , b . volume IDOffset ) if err ! = nil { return " " , err } trimmed Version : = strings . Trim Space ( string ( iso Metadata ) ) version Index : = strings . Index ( trimmed Version , version Prefix ) if version Index = = - 1 { return " " , fmt . Errorf ( " " , version Prefix ) } log . Debug ( " " , vers ) return vers , nil } 
func ( b * B 2d Utils ) Download ISO ( dir , file , iso URL string ) error { log . Infof ( " " , b . path ( ) , iso URL ) return b . download ( dir , file , iso URL ) } 
func Make Disk Image ( public SSHKey Path string ) ( * bytes . Buffer , error ) { magic String : = " " buf : = new ( bytes . Buffer ) tw : = tar . New Writer ( buf ) log . Debug ( " " ) if err : = tw . Write Header ( file ) ; err ! = nil { return nil , err } if _ , err : = tw . Write ( [ ] byte ( magic String ) ) ; err ! = nil { return nil , err } if err : = tw . Write Header ( file ) ; err ! = nil { return nil , err } log . Debug ( " " ) pub Key , err : = ioutil . Read File ( public SSHKey Path ) if err ! = nil { return nil , err } file = & tar . Header { Name : " " , Size : int 6 4 ( len ( pub Key ) ) , Mode : 0 6 4 4 } if err : = tw . Write Header ( file ) ; err ! = nil { return nil , err } if _ , err : = tw . Write ( [ ] byte ( pub Key ) ) ; err ! = nil { return nil , err } file = & tar . Header { Name : " " , Size : int 6 4 ( len ( pub Key ) ) , Mode : 0 6 4 4 } if err : = tw . Write Header ( file ) ; err ! = nil { return nil , err } if _ , err : = tw . Write ( [ ] byte ( pub Key ) ) ; err ! = nil { return nil , err } if err : = tw . Close ( ) ; err ! = nil { return nil , err } return buf , nil } 
func ( c * Client ) Authenticate ( d * openstack . Driver ) error { if c . Provider ! = nil { return nil } log . Debug ( " " , map [ string ] string { " " : d . Username , } ) api Key : = c . driver . APIKey opts : = gophercloud . Auth Options { Username : d . Username , APIKey : api Key , } provider , err : = rackspace . New Client ( rackspace . Rackspace USIdentity ) if err ! = nil { return err } provider . User Agent . Prepend ( fmt . Sprintf ( " " , version . APIVersion ) ) err = rackspace . Authenticate ( provider , opts ) if err ! = nil { return err } c . Provider = provider return nil } 
func ( c * Client ) Get Instance IPAddresses ( d * openstack . Driver ) ( [ ] openstack . IPAddress , error ) { server , err : = c . Get Server Detail ( d ) if err ! = nil { return nil , err } return [ ] openstack . IPAddress { { Network : " " , Address : server . Access IPv 4 , Address Type : openstack . Fixed , } , } , nil } 
func target Host ( c Command Line , api libmachine . API ) ( string , error ) { if len ( c . Args ( ) ) = = 0 { default Exists , err : = api . Exists ( default Machine Name ) if err ! = nil { return " " , fmt . Errorf ( " " , default Machine Name , err ) } if default Exists { return default Machine Name , nil } return " " , Err No Default } return c . Args ( ) [ 0 ] , nil } 
func machine Command ( action Name string , host * host . Host , error Chan chan < - error ) { log . Debugf ( " " , action Name , host . Name ) error Chan < - commands [ action Name ] ( ) } 
func run Action Foreach Machine ( action Name string , machines [ ] * host . Host ) [ ] error { var ( num Concurrent Actions = 0 error Chan = make ( chan error ) errs = [ ] error { } ) for _ , machine : = range machines { num Concurrent Actions + + go machine Command ( action Name , machine , error Chan ) } } } close ( error Chan ) return errs } 
func attempt Get Host State ( h * host . Host , state Query Chan chan < - Host List Item ) { request Beginning : = time . Now ( ) url : = " " current State : = state . None docker Version : = " " host Error : = " " url , err : = h . URL ( ) } else { current State , err = h . Driver . Get State ( ) } } else { current State , _ = h . Driver . Get State ( ) } if err = = nil & & url ! = " " { docker Version , err = mcndockerclient . Docker Version ( docker Host ) if err ! = nil { docker Version = " " } else { docker Version = fmt . Sprintf ( " " , docker Version ) } } if err ! = nil { host Error = err . Error ( ) } if host Error = = drivers . Err Host Is Not Running . Error ( ) { host Error = " " } var swarm Options * swarm . Options var engine Options * engine . Options if h . Host Options ! = nil { swarm Options = h . Host Options . Swarm Options engine Options = h . Host Options . Engine Options } is Master : = false swarm Host : = " " if swarm Options ! = nil { is Master = swarm Options . Master swarm Host = swarm Options . Host } active Host : = is Active ( current State , url ) active Swarm : = is Swarm Active ( current State , url , is Master , swarm Host ) active : = " " if active Host { active = " " } if active Swarm { active = " " } state Query Chan < - Host List Item { Name : h . Name , Active : active , Active Host : active Host , Active Swarm : active Swarm , Driver Name : h . Driver . Driver Name ( ) , State : current State , URL : url , Swarm Options : swarm Options , Engine Options : engine Options , Docker Version : docker Version , Error : host Error , Response Time : time . Now ( ) . Round ( time . Millisecond ) . Sub ( request Beginning . Round ( time . Millisecond ) ) , } } 
func Docker Client Version ( ssh SSHCommander ) ( string , error ) { if err ! = nil { return " " , err } words : = strings . Fields ( output ) if len ( words ) < 3 | | words [ 0 ] ! = " " | | words [ 1 ] ! = " " { return " " , fmt . Errorf ( " " , output ) } return strings . Trim Right ( words [ 2 ] , " " ) , nil } 
func Split Port Proto ( raw string ) ( port string , protocol string ) { parts : = strings . Split N ( raw , " " , 2 ) if len ( parts ) = = 1 { return parts [ 0 ] , " " } return parts [ 0 ] , parts [ 1 ] } 
func ( api * Client ) Create ( h * host . Host ) error { if err : = cert . Bootstrap Certificates ( h . Auth Options ( ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } log . Info ( " " ) if err : = h . Driver . Pre Create Check ( ) ; err ! = nil { return mcnerror . Err During Pre Create { Cause : err , } } if err : = api . Save ( h ) ; err ! = nil { return fmt . Errorf ( " " , err ) } log . Info ( " " ) if err : = api . perform Create ( h ) ; err ! = nil { return fmt . Errorf ( " " , err ) } log . Debug ( " " ) return nil } 
func Truncate ID ( id string ) string { short Len : = 1 2 if len ( id ) < short Len { short Len = len ( id ) } return id [ : short Len ] } 
func Generate Random ID ( ) string { for { id : = make ( [ ] byte , 3 2 ) if _ , err : = io . Read Full ( rand . Reader , id ) ; err ! = nil { panic ( err ) } value : = hex . Encode To String ( id ) } return value } } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Region Name , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Endpoint Type , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Flavor ID , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHUser , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SSHPort , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Docker Install , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Active Timeout , } , } } 
func New Driver ( machine Name , store Path string ) drivers . Driver { log . Debug ( " " , map [ string ] string { " " : machine Name } ) inner : = openstack . New Derived Driver ( machine Name , store Path ) driver : = & Driver { Driver : inner , } inner . Set Client ( & Client { driver : driver , } ) return driver } 
func ( d * Driver ) Set Config From Flags ( flags drivers . Driver Options ) error { d . Active Timeout = flags . Int ( " " ) d . Username = flags . String ( " " ) d . APIKey = flags . String ( " " ) d . Region = flags . String ( " " ) d . Endpoint Type = flags . String ( " " ) d . Image Id = flags . String ( " " ) d . Flavor Id = flags . String ( " " ) d . SSHUser = flags . String ( " " ) d . SSHPort = flags . Int ( " " ) d . Set Swarm Config From Flags ( flags ) if d . Region = = " " { return missing Env Or Option ( " " , " " , " " ) } if d . Username = = " " { return missing Env Or Option ( " " , " " , " " ) } if d . APIKey = = " " { return missing Env Or Option ( " " , " " , " " ) } if d . Image Id = = " " { } if d . Endpoint Type ! = " " & & d . Endpoint Type ! = " " & & d . Endpoint Type ! = " " { return fmt . Errorf ( " " , d . Endpoint Type ) } return nil } 
func ( rd * Remote Docker ) URL ( ) ( string , error ) { if rd . Host URL = = " " { return " " , fmt . Errorf ( " " ) } return rd . Host URL , nil } 
func ( d * Driver ) new Azure Client ( ) ( * azureutil . Azure Client , error ) { env , ok : = environments [ d . Environment ] if ! ok { valid : = make ( [ ] string , 0 , len ( environments ) ) for k : = range environments { valid = append ( valid , k ) } return nil , fmt . Errorf ( " " , d . Environment , strings . Join ( valid , " " ) ) } var ( token * azure . Service Principal Token err error ) if d . Client ID ! = " " & & d . Client Secret ! = " " { token , err = azureutil . Authenticate Service Principal ( env , d . Subscription ID , d . Client ID , d . Client Secret ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } else { token , err = azureutil . Authenticate Device Flow ( env , d . Subscription ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } return azureutil . New ( env , d . Subscription ID , token ) , nil } 
func ( d * Driver ) generate SSHKey ( ctx * azureutil . Deployment Context ) error { priv Path : = d . Get SSHKey Path ( ) pub Path : = priv Path + " " log . Debug ( " " , logutil . Fields { " " : pub Path , " " : priv Path , } ) if err : = ssh . Generate SSHKey ( priv Path ) ; err ! = nil { return err } log . Debug ( " " ) public Key , err : = ioutil . Read File ( pub Path ) ctx . SSHPublic Key = string ( public Key ) return err } 
func ( d * Driver ) get Security Rules ( extra Ports [ ] string ) ( * [ ] network . Security Rule , error ) { mk Rule : = func ( priority int , name , description , src Port , dst Port string , proto network . Security Rule Protocol ) network . Security Rule { return network . Security Rule { Name : to . String Ptr ( name ) , Properties : & network . Security Rule Properties Format { Description : to . String Ptr ( description ) , Source Address Prefix : to . String Ptr ( " " ) , Destination Address Prefix : to . String Ptr ( " " ) , Source Port Range : to . String Ptr ( src Port ) , Destination Port Range : to . String Ptr ( dst Port ) , Access : network . Allow , Direction : network . Inbound , Protocol : proto , Priority : to . Int 3 2Ptr ( int 3 2 ( priority ) ) , } , } } log . Debugf ( " " , d . Docker Port ) log . Debugf ( " " , swarm Host ) u , err : = url . Parse ( swarm Host ) if err ! = nil { return nil , fmt . Errorf ( " " , swarm Host , err ) } _ , swarm Port , err : = net . Split Host Port ( u . Host ) if err ! = nil { return nil , fmt . Errorf ( " " , u . Host , err ) } rl = append ( rl , mk Rule ( 5 0 0 , " " , " " , " " , swarm Port , network . TCP ) ) } else { log . Debug ( " " ) } for i , p : = range extra Ports { port , protocol : = driverutil . Split Port Proto ( p ) proto , err : = parse Security Rule Protocol ( protocol ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Debugf ( " " , port , proto ) name : = fmt . Sprintf ( " " , port , proto ) name = strings . Replace ( name , " " , " " , - 1 ) r : = mk Rule ( base Pri + i , name , " " , " " , port , proto ) rl = append ( rl , r ) } log . Debugf ( " " , len ( rl ) ) return & rl , nil } 
func ( d * Driver ) ip Address ( ) ( ip string , err error ) { c , err : = d . new Azure Client ( ) if err ! = nil { return " " , err } var ip Type string if d . Use Private IP | | d . No Public IP { ip Type = " " ip , err = c . Get Private IPAddress ( d . Resource Group , d . naming ( ) . NIC ( ) ) } else { ip Type = " " ip , err = c . Get Public IPAddress ( d . Resource Group , d . naming ( ) . IP ( ) , d . DNSLabel ! = " " ) } log . Debugf ( " " , ip Type ) if err ! = nil { return " " , fmt . Errorf ( " " , ip Type , err ) } if ip = = " " { log . Debugf ( " " , ip Type ) } return ip , nil } 
func parse Virtual Network ( name string , default RG string ) ( string , string ) { l : = strings . Split N ( name , " " , 2 ) if len ( l ) = = 2 { return l [ 0 ] , l [ 1 ] } return default RG , name } 
func parse Security Rule Protocol ( proto string ) ( network . Security Rule Protocol , error ) { switch strings . To Lower ( proto ) { case " " : return network . TCP , nil case " " : return network . UDP , nil case " " : return network . Asterisk , nil default : return " " , fmt . Errorf ( " " , proto ) } } 
func ( s State ) String ( ) string { if int ( s ) > = 0 & & int ( s ) < len ( states ) { return states [ s ] } return " " } 
func random Azure Storage Account Name ( ) string { const ( max Len = 2 4 chars = " " ) return storage Account Prefix + random String ( max Len - len ( storage Account Prefix ) , chars ) } 
func random String ( n int , alphabet string ) string { r : = time Seed ( ) b : = make ( [ ] byte , n ) for i : = range b { b [ i ] = alphabet [ r . Intn ( len ( alphabet ) ) ] } return string ( b ) } 
func parse Image Name ( image string ) ( image Name , error ) { l : = strings . Split ( image , " " ) if len ( l ) ! = 4 { return image Name { } , fmt . Errorf ( " " , image ) } return image Name { l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] } , nil } 
func parse Swarm ( host URL string , h * host . Host ) ( string , error ) { swarm Options : = h . Host Options . Swarm Options if ! swarm Options . Master { return " " , fmt . Errorf ( " " , h . Name ) } u , err : = url . Parse ( swarm Options . Host ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } parts : = strings . Split ( u . Host , " " ) swarm Port : = parts [ 1 ] if err ! = nil { return " " , fmt . Errorf ( " " , err ) } m Parts : = strings . Split ( m URL . Host , " " ) machine IP : = m Parts [ 0 ] host URL = fmt . Sprintf ( " " , machine IP , swarm Port ) return host URL , nil } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Cpus , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Memory , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default Disk Size , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . Int Flag { Env Var : " " , Name : " " , Usage : " " , Value : default SDKPort , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Slice Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Slice Flag { Env Var : " " , Name : " " , Usage : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) Pre Create Check ( ) error { log . Debug ( " " ) defer cancel ( ) c , err : = d . vsphere Login ( ctx ) if err ! = nil { return err } defer c . Logout ( ctx ) dc , err : = f . Datacenter Or Default ( ctx , d . Datacenter ) if err ! = nil { return err } f . Set Datacenter ( dc ) if err ! = nil { return err } folder , err : = f . Folder ( ctx , fmt . Sprintf ( " " , folders . Vm Folder . Inventory Path , d . Folder ) ) } if folder = = nil { return fmt . Errorf ( " " , d . Folder ) } } if _ , err : = f . Datastore Or Default ( ctx , d . Datastore ) ; err ! = nil { return err } } for _ , net Name : = range d . Networks { if _ , err : = f . Network Or Default ( ctx , net Name ) ; err ! = nil { return err } } var hs * object . Host System if d . Host System ! = " " { var err error hs , err = f . Host System Or Default ( ctx , d . Host System ) if err ! = nil { return err } } } } else if hs ! = nil { } } else { } } return nil } 
func ( d * Driver ) Create ( ) error { b 2dutils : = mcnutils . New B 2d Utils ( d . Store Path ) if err : = b 2dutils . Copy Iso To Machine Dir ( d . Boot 2Docker URL , d . Machine Name ) ; err ! = nil { return err } log . Infof ( " " ) if err : = ssh . Generate SSHKey ( d . Get SSHKey Path ( ) ) ; err ! = nil { return err } defer cancel ( ) c , err : = d . vsphere Login ( ctx ) if err ! = nil { return err } defer c . Logout ( ctx ) dc , err : = f . Datacenter Or Default ( ctx , d . Datacenter ) if err ! = nil { return err } f . Set Datacenter ( dc ) dss , err : = f . Datastore Or Default ( ctx , d . Datastore ) if err ! = nil { return err } networks : = make ( map [ string ] object . Network Reference ) for _ , net Name : = range d . Networks { net , err : = f . Network Or Default ( ctx , net Name ) if err ! = nil { return err } networks [ net Name ] = net } var hs * object . Host System if d . Host System ! = " " { var err error hs , err = f . Host System Or Default ( ctx , d . Host System ) if err ! = nil { return err } } var rp * object . Resource Pool if d . Pool ! = " " { if err ! = nil { return err } } else if d . Host System ! = " " { if err ! = nil { return err } } else { if err ! = nil { return err } } spec : = types . Virtual Machine Config Spec { Name : d . Machine Name , Guest Id : " " , Files : & types . Virtual Machine File Info { Vm Path Name : fmt . Sprintf ( " " , dss . Name ( ) ) } , Num CPUs : int 3 2 ( d . CPU ) , Memory MB : int 6 4 ( d . Memory ) , } scsi , err : = object . SCSIController Types ( ) . Create SCSIController ( " " ) if err ! = nil { return err } spec . Device Change = append ( spec . Device Change , & types . Virtual Device Config Spec { Operation : types . Virtual Device Config Spec Operation Add , Device : scsi , } ) log . Infof ( " " ) folders , err : = dc . Folders ( ctx ) folder : = folders . Vm Folder if d . Folder ! = " " { folder , err = f . Folder ( ctx , fmt . Sprintf ( " " , folders . Vm Folder . Inventory Path , d . Folder ) ) if err ! = nil { return err } } task , err : = folder . Create VM ( ctx , spec , rp , hs ) if err ! = nil { return err } info , err : = task . Wait For Result ( ctx , nil ) if err ! = nil { return err } log . Infof ( " " ) dsurl , err : = dss . URL ( ctx , dc , fmt . Sprintf ( " " , d . Machine Name , iso Filename ) ) if err ! = nil { return err } p : = soap . Default Upload if err = c . Client . Upload File ( d . ISO , dsurl , & p ) ; err ! = nil { return err } devices , err : = vm . Device ( ctx ) if err ! = nil { return err } var add [ ] types . Base Virtual Device controller , err : = devices . Find Disk Controller ( " " ) if err ! = nil { return err } disk : = devices . Create Disk ( controller , dss . Reference ( ) , dss . Path ( fmt . Sprintf ( " " , d . Machine Name , d . Machine Name ) ) ) add = append ( add , disk ) ide , err : = devices . Find IDEController ( " " ) if err ! = nil { return err } cdrom , err : = devices . Create Cdrom ( ide ) if err ! = nil { return err } add = append ( add , devices . Insert Iso ( cdrom , dss . Path ( fmt . Sprintf ( " " , d . Machine Name , iso Filename ) ) ) ) for _ , net Name : = range d . Networks { backing , err : = networks [ net Name ] . Ethernet Card Backing Info ( ctx ) if err ! = nil { return err } netdev , err : = object . Ethernet Card Types ( ) . Create Ethernet Card ( " " , backing ) if err ! = nil { return err } log . Infof ( " " , net Name ) add = append ( add , netdev ) } log . Infof ( " " ) if vm . Add Device ( ctx , add . . . ) ; err ! = nil { return err } for _ , param : = range d . Cfg Params { v : = strings . Split N ( param , " " , 2 ) key : = v [ 0 ] value : = " " if len ( v ) > 1 { value = v [ 1 ] } fmt . Printf ( " \n " , key , value ) opts = append ( opts , & types . Option Value { Key : key , Value : value , } ) } if d . Cloud Init ! = " " { if _ , err : = url . Parse Request URI ( d . Cloud Init ) ; err = = nil { log . Infof ( " \n " , d . Cloud Init ) opts = append ( opts , & types . Option Value { Key : " " , Value : d . Cloud Init , } ) } else { if _ , err : = os . Stat ( d . Cloud Init ) ; err = = nil { if value , err : = ioutil . Read File ( d . Cloud Init ) ; err = = nil { log . Infof ( " \n " , d . Cloud Init ) encoded : = base 6 4 . Std Encoding . Encode To String ( value ) opts = append ( opts , & types . Option Value { Key : " " , Value : encoded , } ) opts = append ( opts , & types . Option Value { Key : " " , Value : " " , } ) } } } } task , err = vm . Reconfigure ( ctx , types . Virtual Machine Config Spec { Extra Config : opts , } ) if err ! = nil { return err } task . Wait ( ctx ) if err : = d . Start ( ) ; err ! = nil { return err } log . Infof ( " " ) } opman : = guest . New Operations Manager ( c . Client , vm . Reference ( ) ) fileman , err : = opman . File Manager ( ctx ) if err ! = nil { return err } src : = d . Resolve Store Path ( " " ) s , err : = os . Stat ( src ) if err ! = nil { return err } auth : = Auth Flag { } flag : = File Attr Flag { } auth . auth . Username = B 2DUser auth . auth . Password = B 2DPass flag . Set Perms ( 0 , 0 , 6 6 0 ) url , err : = fileman . Initiate File Transfer To Guest ( ctx , auth . Auth ( ) , " " , flag . Attr ( ) , s . Size ( ) , true ) if err ! = nil { return err } u , err : = c . Client . Parse URL ( url ) if err ! = nil { return err } if err = c . Client . Upload File ( src , u , nil ) ; err ! = nil { return err } procman , err : = opman . Process Manager ( ctx ) if err ! = nil { return err } guestspec : = types . Guest Program Spec { Program Path : " " , Arguments : " \ " \ " " , Working Directory : " " , Env Variables : env , } _ , err = procman . Start Program ( ctx , auth . Auth ( ) , & guestspec ) if err ! = nil { return err } _ , err = procman . Start Program ( ctx , auth . Auth ( ) , & guestspec ) if err ! = nil { return err } return nil } 
func ( d * Driver ) generate Key Bundle ( ) error { log . Debugf ( " " ) magic String : = " " tf , err : = os . Create ( d . Resolve Store Path ( " " ) ) if err ! = nil { return err } defer tf . Close ( ) var file Writer = tf tw : = tar . New Writer ( file Writer ) defer tw . Close ( ) if err : = tw . Write Header ( file ) ; err ! = nil { return err } if _ , err : = tw . Write ( [ ] byte ( magic String ) ) ; err ! = nil { return err } if err : = tw . Write Header ( file ) ; err ! = nil { return err } pub Key , err : = ioutil . Read File ( d . public SSHKey Path ( ) ) if err ! = nil { return err } file = & tar . Header { Name : " " , Size : int 6 4 ( len ( pub Key ) ) , Mode : 0 6 4 4 } if err : = tw . Write Header ( file ) ; err ! = nil { return err } if _ , err : = tw . Write ( [ ] byte ( pub Key ) ) ; err ! = nil { return err } file = & tar . Header { Name : " " , Size : int 6 4 ( len ( pub Key ) ) , Mode : 0 6 4 4 } if err : = tw . Write Header ( file ) ; err ! = nil { return err } if _ , err : = tw . Write ( [ ] byte ( pub Key ) ) ; err ! = nil { return err } err = tw . Close ( ) return err } 
func New Driver ( host Name , store Path string ) * Driver { return & Driver { VBox Manager : New VBox Manager ( ) , b 2d Updater : New B 2DUpdater ( ) , ssh Key Generator : New SSHKey Generator ( ) , disk Creator : New Disk Creator ( ) , logs Reader : New Logs Reader ( ) , ip Waiter : New IPWaiter ( ) , random Inter : New Random Inter ( ) , sleeper : New Sleeper ( ) , Host Interfaces : New Host Interfaces ( ) , Memory : default Memory , CPU : default CPU , Disk Size : default Disk Size , Nat Nic Type : default Host Only Nictype , Host Only CIDR : default Host Only CIDR , Host Only Nic Type : default Host Only Nictype , Host Only Promisc Mode : default Host Only Promisc Mode , UIType : default UIType , Host Only No DHCP : default Host Only No DHCP , DNSProxy : default DNSProxy , Host DNSResolver : default DNSResolver , Base Driver : & drivers . Base Driver { Machine Name : host Name , Store Path : store Path , } , } } 
func ( d * Driver ) Get Create Flags ( ) [ ] mcnflag . Flag { return [ ] mcnflag . Flag { mcnflag . Int Flag { Name : " " , Usage : " " , Value : default Memory , Env Var : " " , } , mcnflag . Int Flag { Name : " " , Usage : " " , Value : default CPU , Env Var : " " , } , mcnflag . Int Flag { Name : " " , Usage : " " , Value : default Disk Size , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Boot 2Docker URL , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Boot 2Docker Import VM , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Host Only Nictype , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Host Only CIDR , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Host Only Nictype , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default Host Only Promisc Mode , Env Var : " " , } , mcnflag . String Flag { Name : " " , Usage : " " , Value : default UIType , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . Bool Flag { Name : " " , Usage : " " , Env Var : " " , } , mcnflag . String Flag { Env Var : " " , Name : " " , Usage : " " , } , } } 
func ( d * Driver ) Pre Create Check ( ) error { if err ! = nil { return err } } if ! d . No VTXCheck { if is Hyper VInstalled ( ) { return Err Not Compatible With Hyper V } if d . Is VTXDisabled ( ) { return Err Must Enable VTX } } } } return nil } 
func ( d * Driver ) Restart ( ) error { if err : = d . Stop ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = d . Start ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } d . IPAddress = " " return d . ip Waiter . Wait ( d ) } 
func validate No IPCollisions ( hif Host Interfaces , host Only Net * net . IPNet , curr Host Only Nets map [ string ] * host Only Network ) error { host Only By CIDR : = map [ string ] * host Only Network { } host Only By CIDR [ ipnet . String ( ) ] = n } m , err : = list Host Interfaces ( hif , host Only By CIDR ) if err ! = nil { return err } collision , err : = check IPNet Collision ( host Only Net , m ) if err ! = nil { return err } if collision { return Err Network Addr Collision } return nil } 
func get Available TCPPort ( port int ) ( int , error ) { for i : = 0 ; i < = 1 0 ; i + + { ln , err : = net . Listen ( " " , fmt . Sprintf ( " " , port ) ) if err ! = nil { return 0 , err } defer ln . Close ( ) addr : = ln . Addr ( ) . String ( ) addr Parts : = strings . Split N ( addr , " " , 2 ) p , err : = strconv . Atoi ( addr Parts [ 1 ] ) if err ! = nil { return 0 , err } if p ! = 0 { port = p return port , nil } port = 0 time . Sleep ( 1 ) } return 0 , fmt . Errorf ( " " ) } 
func set Port Forwarding ( d * Driver , interface Num int , map Name , protocol string , guest Port , desired Host Port int ) ( int , error ) { actual Host Port , err : = get Available TCPPort ( desired Host Port ) if err ! = nil { return - 1 , err } if desired Host Port ! = actual Host Port & & desired Host Port ! = 0 { log . Debugf ( " " , guest Port , map Name , desired Host Port , actual Host Port ) } cmd : = fmt . Sprintf ( " " , interface Num ) d . vbm ( " " , d . Machine Name , cmd , " " , map Name ) if err : = d . vbm ( " " , d . Machine Name , cmd , fmt . Sprintf ( " " , map Name , protocol , actual Host Port , guest Port ) ) ; err ! = nil { return - 1 , err } return actual Host Port , nil } 
func get Random IPin Subnet ( d * Driver , base IP net . IP ) ( net . IP , error ) { var dhcp Addr net . IP n Addr : = base IP . To 4 ( ) if byte ( n ) ! = n Addr [ 3 ] { dhcp Addr = net . IPv 4 ( n Addr [ 0 ] , n Addr [ 1 ] , n Addr [ 2 ] , byte ( n ) ) break } } if dhcp Addr = = nil { return nil , Err Unable To Generate Random IP } return dhcp Addr , nil } 
func Detect ( ) ( string , error ) { shell : = os . Getenv ( " " ) if shell = = " " { fmt . Printf ( " \n \n " ) return " " , Err Unknown Shell } return filepath . Base ( shell ) , nil } 
func vault Renew Duration ( s * Secret ) time . Duration { if s . Auth ! = nil & & s . Auth . Lease Duration > 0 { base = s . Auth . Lease Duration } } if vault Secret Renewable ( s ) { } else { } return time . Duration ( sleep ) } 
func print Vault Warnings ( d Dependency , warnings [ ] string ) { for _ , w : = range warnings { log . Printf ( " " , d , w ) } } 
func vault Secret Renewable ( s * Secret ) bool { if s . Auth ! = nil { return s . Auth . Renewable } return s . Renewable } 
func transform Secret ( theirs * api . Secret ) * Secret { var ours Secret update Secret ( & ours , theirs ) return & ours } 
func update Secret ( ours * Secret , theirs * api . Secret ) { if theirs . Request ID ! = " " { ours . Request ID = theirs . Request ID } if theirs . Lease ID ! = " " { ours . Lease ID = theirs . Lease ID } if theirs . Lease Duration ! = 0 { ours . Lease Duration = theirs . Lease Duration } if theirs . Renewable { ours . Renewable = theirs . Renewable } if len ( theirs . Data ) ! = 0 { ours . Data = theirs . Data } if len ( theirs . Warnings ) ! = 0 { ours . Warnings = theirs . Warnings } if theirs . Auth ! = nil { if ours . Auth = = nil { ours . Auth = & Secret Auth { } } if theirs . Auth . Client Token ! = " " { ours . Auth . Client Token = theirs . Auth . Client Token } if theirs . Auth . Accessor ! = " " { ours . Auth . Accessor = theirs . Auth . Accessor } if len ( theirs . Auth . Policies ) ! = 0 { ours . Auth . Policies = theirs . Auth . Policies } if len ( theirs . Auth . Metadata ) ! = 0 { ours . Auth . Metadata = theirs . Auth . Metadata } if theirs . Auth . Lease Duration ! = 0 { ours . Auth . Lease Duration = theirs . Auth . Lease Duration } if theirs . Auth . Renewable { ours . Auth . Renewable = theirs . Auth . Renewable } } if theirs . Wrap Info ! = nil { if ours . Wrap Info = = nil { ours . Wrap Info = & Secret Wrap Info { } } if theirs . Wrap Info . Token ! = " " { ours . Wrap Info . Token = theirs . Wrap Info . Token } if theirs . Wrap Info . TTL ! = 0 { ours . Wrap Info . TTL = theirs . Wrap Info . TTL } if ! theirs . Wrap Info . Creation Time . Is Zero ( ) { ours . Wrap Info . Creation Time = theirs . Wrap Info . Creation Time } if theirs . Wrap Info . Wrapped Accessor ! = " " { ours . Wrap Info . Wrapped Accessor = theirs . Wrap Info . Wrapped Accessor } } } 
func ( c * Template Config ) Copy ( ) * Template Config { if c = = nil { return nil } var o Template Config o . Backup = c . Backup o . Command = c . Command o . Command Timeout = c . Command Timeout o . Contents = c . Contents o . Create Dest Dirs = c . Create Dest Dirs o . Destination = c . Destination o . Err Missing Key = c . Err Missing Key if c . Exec ! = nil { o . Exec = c . Exec . Copy ( ) } o . Perms = c . Perms o . Source = c . Source if c . Wait ! = nil { o . Wait = c . Wait . Copy ( ) } o . Left Delim = c . Left Delim o . Right Delim = c . Right Delim return & o } 
func ( c * Template Config ) Merge ( o * Template Config ) * Template Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Backup ! = nil { r . Backup = o . Backup } if o . Command ! = nil { r . Command = o . Command } if o . Command Timeout ! = nil { r . Command Timeout = o . Command Timeout } if o . Contents ! = nil { r . Contents = o . Contents } if o . Create Dest Dirs ! = nil { r . Create Dest Dirs = o . Create Dest Dirs } if o . Destination ! = nil { r . Destination = o . Destination } if o . Err Missing Key ! = nil { r . Err Missing Key = o . Err Missing Key } if o . Exec ! = nil { r . Exec = r . Exec . Merge ( o . Exec ) } if o . Perms ! = nil { r . Perms = o . Perms } if o . Source ! = nil { r . Source = o . Source } if o . Wait ! = nil { r . Wait = r . Wait . Merge ( o . Wait ) } if o . Left Delim ! = nil { r . Left Delim = o . Left Delim } if o . Right Delim ! = nil { r . Right Delim = o . Right Delim } return r } 
func ( c * Template Config ) Finalize ( ) { if c . Backup = = nil { c . Backup = Bool ( false ) } if c . Command = = nil { c . Command = String ( " " ) } if c . Command Timeout = = nil { c . Command Timeout = Time Duration ( Default Template Command Timeout ) } if c . Contents = = nil { c . Contents = String ( " " ) } if c . Create Dest Dirs = = nil { c . Create Dest Dirs = Bool ( true ) } if c . Destination = = nil { c . Destination = String ( " " ) } if c . Err Missing Key = = nil { c . Err Missing Key = Bool ( false ) } if c . Exec = = nil { c . Exec = Default Exec Config ( ) } } if c . Exec . Timeout = = nil & & c . Command Timeout ! = nil { c . Exec . Timeout = c . Command Timeout } c . Exec . Finalize ( ) if c . Perms = = nil { c . Perms = File Mode ( 0 ) } if c . Source = = nil { c . Source = String ( " " ) } if c . Wait = = nil { c . Wait = Default Wait Config ( ) } c . Wait . Finalize ( ) if c . Left Delim = = nil { c . Left Delim = String ( " " ) } if c . Right Delim = = nil { c . Right Delim = String ( " " ) } } 
func ( c * Template Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , Bool Go String ( c . Backup ) , String Go String ( c . Command ) , Time Duration Go String ( c . Command Timeout ) , String Go String ( c . Contents ) , Bool Go String ( c . Create Dest Dirs ) , String Go String ( c . Destination ) , Bool Go String ( c . Err Missing Key ) , c . Exec , File Mode Go String ( c . Perms ) , String Go String ( c . Source ) , c . Wait , String Go String ( c . Left Delim ) , String Go String ( c . Right Delim ) , ) } 
func ( c * Template Config ) Display ( ) string { if c = = nil { return " " } source : = c . Source if String Present ( c . Contents ) { source = String ( " " ) } return fmt . Sprintf ( " " , String Val ( source ) , String Val ( c . Destination ) , ) } 
func ( c * Template Configs ) Copy ( ) * Template Configs { o : = make ( Template Configs , len ( * c ) ) for i , t : = range * c { o [ i ] = t . Copy ( ) } return & o } 
func ( c * Template Configs ) Merge ( o * Template Configs ) * Template Configs { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) * r = append ( * r , * o . . . ) return r } 
func ( c * Template Configs ) Finalize ( ) { if c = = nil { * c = * Default Template Configs ( ) } for _ , t : = range * c { t . Finalize ( ) } } 
func ( c * Template Configs ) Go String ( ) string { if c = = nil { return " " } s : = make ( [ ] string , len ( * c ) ) for i , t : = range * c { s [ i ] = t . Go String ( ) } return " " + strings . Join ( s , " " ) + " " } 
func Parse Template Config ( s string ) ( * Template Config , error ) { if len ( strings . Trim Space ( s ) ) < 1 { return nil , Err Template String Empty } var source , destination , command string parts : = config Template Re . Find All String ( s , - 1 ) switch len ( parts ) { case 1 : source = parts [ 0 ] case 2 : source , destination = parts [ 0 ] , parts [ 1 ] case 3 : source , destination , command = parts [ 0 ] , parts [ 1 ] , parts [ 2 ] default : source , destination = parts [ 0 ] , parts [ 1 ] command = strings . Join ( parts [ 2 : ] , " " ) } var source Ptr , destination Ptr , command Ptr * string if source ! = " " { source Ptr = String ( source ) } if destination ! = " " { destination Ptr = String ( destination ) } if command ! = " " { command Ptr = String ( command ) } return & Template Config { Source : source Ptr , Destination : destination Ptr , Command : command Ptr , } , nil } 
func New Vault Write Query ( s string , d map [ string ] interface { } ) ( * Vault Write Query , error ) { s = strings . Trim Space ( s ) s = strings . Trim ( s , " " ) if s = = " " { return nil , fmt . Errorf ( " " , s ) } return & Vault Write Query { stop Ch : make ( chan struct { } , 1 ) , path : s , data : d , data Hash : sha 1Map ( d ) , } , nil } 
func ( d * Vault Write Query ) String ( ) string { return fmt . Sprintf ( " " , d . path , d . data Hash ) } 
func sha 1Map ( m map [ string ] interface { } ) string { keys : = make ( [ ] string , 0 , len ( m ) ) for k , _ : = range m { keys = append ( keys , k ) } sort . Strings ( keys ) h : = sha 1 . New ( ) for _ , k : = range keys { io . Write String ( h , fmt . Sprintf ( " " , k , m [ k ] ) ) } return fmt . Sprintf ( " " , h . Sum ( nil ) ) } 
func New View ( i * New View Input ) ( * View , error ) { return & View { dependency : i . Dependency , clients : i . Clients , max Stale : i . Max Stale , once : i . Once , retry Func : i . Retry Func , stop Ch : make ( chan struct { } , 1 ) , vault Grace : i . Vault Grace , } , nil } 
func ( v * View ) Data ( ) interface { } { v . data Lock . RLock ( ) defer v . data Lock . RUnlock ( ) return v . data } 
func ( v * View ) Data And Last Index ( ) ( interface { } , uint 6 4 ) { v . data Lock . RLock ( ) defer v . data Lock . RUnlock ( ) return v . data , v . last Index } 
func ( v * View ) poll ( view Ch chan < - * View , err Ch chan < - error ) { var retries int for { done Ch : = make ( chan struct { } , 1 ) success Ch : = make ( chan struct { } , 1 ) fetch Err Ch : = make ( chan error , 1 ) go v . fetch ( done Ch , success Ch , fetch Err Ch ) WAIT : select { case < - done Ch : log . Printf ( " " , v . dependency ) select { case < - v . stop Ch : return case view Ch < - v : } } case < - success Ch : retries = 0 goto WAIT case err : = < - fetch Err Ch : if v . retry Func ! = nil { retry , sleep : = v . retry Func ( retries ) if retry { log . Printf ( " " , err , retries + 1 , sleep ) select { case < - time . After ( sleep ) : retries + + continue case < - v . stop Ch : return } } } log . Printf ( " " , err ) case err Ch < - err : return } case < - v . stop Ch : log . Printf ( " " , v . dependency ) return } } } 
func ( v * View ) fetch ( done Ch , success Ch chan < - struct { } , err Ch chan < - error ) { log . Printf ( " " , v . dependency ) var allow Stale bool if v . max Stale ! = 0 { allow Stale = true } for { default : } data , rm , err : = v . dependency . Fetch ( v . clients , & dep . Query Options { Allow Stale : allow Stale , Wait Time : default Wait Time , Wait Index : v . last Index , Vault Grace : v . vault Grace , } ) if err ! = nil { if err = = dep . Err Stopped { log . Printf ( " " , v . dependency ) } else { err Ch < - err } return } if rm = = nil { err Ch < - fmt . Errorf ( " " + " " ) return } select { case success Ch < - struct { } { } : default : } if allow Stale & & rm . Last Contact > v . max Stale { allow Stale = false log . Printf ( " " , v . dependency ) continue } if v . max Stale ! = 0 { allow Stale = true } if rm . Last Index = = v . last Index { log . Printf ( " " , v . dependency ) continue } v . data Lock . Lock ( ) if rm . Last Index < v . last Index { log . Printf ( " " , v . dependency ) v . last Index = 0 v . data Lock . Unlock ( ) continue } v . last Index = rm . Last Index if v . received Data & & reflect . Deep Equal ( data , v . data ) { log . Printf ( " " , v . dependency ) v . data Lock . Unlock ( ) continue } if data = = nil & & rm . Block { log . Printf ( " " , v . dependency ) v . data Lock . Unlock ( ) continue } v . data = data v . received Data = true v . data Lock . Unlock ( ) close ( done Ch ) return } } 
func New Catalog Node Query ( s string ) ( * Catalog Node Query , error ) { if s ! = " " & & ! Catalog Node Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( Catalog Node Query Re , s ) return & Catalog Node Query { dc : m [ " " ] , name : m [ " " ] , stop Ch : make ( chan struct { } , 1 ) , } , nil } 
func ( d * Catalog Node Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , } ) if name = = " " { log . Printf ( " " , d ) var err error name , err = clients . Consul ( ) . Agent ( ) . Node Name ( ) if err ! = nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } } log . Printf ( " " , d , & url . URL { Path : " " + name , Raw Query : opts . String ( ) , } ) node , qm , err : = clients . Consul ( ) . Catalog ( ) . Node ( name , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d ) rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } if node = = nil { log . Printf ( " " , d , name ) var node Catalog Node return & node , rm , nil } services : = make ( [ ] * Catalog Node Service , 0 , len ( node . Services ) ) for _ , v : = range node . Services { services = append ( services , & Catalog Node Service { ID : v . ID , Service : v . Service , Tags : Service Tags ( deep Copy And Sort Tags ( v . Tags ) ) , Meta : v . Meta , Port : v . Port , Address : v . Address , Enable Tag Override : v . Enable Tag Override , } ) } sort . Stable ( By Service ( services ) ) detail : = & Catalog Node { Node : & Node { ID : node . Node . ID , Node : node . Node . Node , Address : node . Node . Address , Datacenter : node . Node . Datacenter , Tagged Addresses : node . Node . Tagged Addresses , Meta : node . Node . Meta , } , Services : services , } return detail , rm , nil } 
func ( d * Catalog Node Query ) String ( ) string { name : = d . name if d . dc ! = " " { name = name + " " + d . dc } if name = = " " { return " " } return fmt . Sprintf ( " " , name ) } 
func Parse Auth Config ( s string ) ( * Auth Config , error ) { if s = = " " { return nil , Err Auth String Empty } var a Auth Config if strings . Contains ( s , " " ) { split : = strings . Split N ( s , " " , 2 ) a . Username = String ( split [ 0 ] ) a . Password = String ( split [ 1 ] ) } else { a . Username = String ( s ) } return & a , nil } 
func ( c * Auth Config ) Copy ( ) * Auth Config { if c = = nil { return nil } var o Auth Config o . Enabled = c . Enabled o . Username = c . Username o . Password = c . Password return & o } 
func ( c * Auth Config ) Merge ( o * Auth Config ) * Auth Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Username ! = nil { r . Username = o . Username } if o . Password ! = nil { r . Password = o . Password } return r } 
func ( c * Auth Config ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( false | | String Present ( c . Username ) | | String Present ( c . Password ) ) } if c . Username = = nil { c . Username = String ( " " ) } if c . Password = = nil { c . Password = String ( " " ) } if c . Enabled = = nil { c . Enabled = Bool ( * c . Username ! = " " | | * c . Password ! = " " ) } } 
func ( c * Auth Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " , Bool Go String ( c . Enabled ) , String Go String ( c . Username ) , String Go String ( c . Password ) , ) } 
func ( c * Auth Config ) String ( ) string { if ! Bool Val ( c . Enabled ) { return " " } if c . Password ! = nil { return fmt . Sprintf ( " " , String Val ( c . Username ) , String Val ( c . Password ) ) } return String Val ( c . Username ) } 
func New Vault List Query ( s string ) ( * Vault List Query , error ) { s = strings . Trim Space ( s ) s = strings . Trim ( s , " " ) if s = = " " { return nil , fmt . Errorf ( " " , s ) } return & Vault List Query { stop Ch : make ( chan struct { } , 1 ) , path : s , } , nil } 
func ( d * Vault List Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { } ) log . Printf ( " " , d , dur ) select { case < - d . stop Ch : return nil , nil , Err Stopped case < - time . After ( dur ) : } } secret , err : = clients . Vault ( ) . Logical ( ) . List ( d . path ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } var result [ ] string return resp With Metadata ( result ) } if ! ok { log . Printf ( " " , d ) return resp With Metadata ( result ) } list , ok : = keys . ( [ ] interface { } ) if ! ok { log . Printf ( " " , d ) return nil , nil , fmt . Errorf ( " " , d ) } for _ , v : = range list { typed , ok : = v . ( string ) if ! ok { return nil , nil , fmt . Errorf ( " " , d ) } result = append ( result , typed ) } sort . Strings ( result ) log . Printf ( " " , d , len ( result ) ) return resp With Metadata ( result ) } 
func ( b * Brain ) Remember ( d dep . Dependency , data interface { } ) { b . Lock ( ) defer b . Unlock ( ) b . data [ d . String ( ) ] = data b . received Data [ d . String ( ) ] = struct { } { } } 
func ( b * Brain ) Recall ( d dep . Dependency ) ( interface { } , bool ) { b . RLock ( ) defer b . RUnlock ( ) } return b . data [ d . String ( ) ] , true } 
func ( b * Brain ) Force Set ( hash Code string , data interface { } ) { b . Lock ( ) defer b . Unlock ( ) b . data [ hash Code ] = data b . received Data [ hash Code ] = struct { } { } } 
func ( b * Brain ) Forget ( d dep . Dependency ) { b . Lock ( ) defer b . Unlock ( ) delete ( b . data , d . String ( ) ) delete ( b . received Data , d . String ( ) ) } 
func New Catalog Datacenters Query ( ignore Failing bool ) ( * Catalog Datacenters Query , error ) { return & Catalog Datacenters Query { ignore Failing : ignore Failing , stop Ch : make ( chan struct { } , 1 ) , } , nil } 
func ( d * Catalog Datacenters Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { opts = opts . Merge ( & Query Options { } ) log . Printf ( " " , d , & url . URL { Path : " " , Raw Query : opts . String ( ) , } ) select { case < - d . stop Ch : return nil , nil , Err Stopped case < - time . After ( Catalog Datacenters Query Sleep Time ) : } } result , err : = clients . Consul ( ) . Catalog ( ) . Datacenters ( ) if err ! = nil { return nil , nil , errors . Wrapf ( err , d . String ( ) ) } for _ , dc : = range result { if _ , _ , err : = clients . Consul ( ) . Catalog ( ) . Services ( & api . Query Options { Datacenter : dc , Allow Stale : false , Require Consistent : true , } ) ; err = = nil { dcs = append ( dcs , dc ) } } result = dcs } log . Printf ( " " , d , len ( result ) ) sort . Strings ( result ) return resp With Metadata ( result ) } 
func New Catalog Nodes Query ( s string ) ( * Catalog Nodes Query , error ) { if ! Catalog Nodes Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( Catalog Nodes Query Re , s ) return & Catalog Nodes Query { dc : m [ " " ] , near : m [ " " ] , stop Ch : make ( chan struct { } , 1 ) , } , nil } 
func ( d * Catalog Nodes Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , Near : d . near , } ) log . Printf ( " " , d , & url . URL { Path : " " , Raw Query : opts . String ( ) , } ) n , qm , err : = clients . Consul ( ) . Catalog ( ) . Nodes ( opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( n ) ) nodes : = make ( [ ] * Node , 0 , len ( n ) ) for _ , node : = range n { nodes = append ( nodes , & Node { ID : node . ID , Node : node . Node , Address : node . Address , Datacenter : node . Datacenter , Tagged Addresses : node . Tagged Addresses , Meta : node . Meta , } ) } } rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return nodes , rm , nil } 
func ( d * Catalog Nodes Query ) String ( ) string { name : = " " if d . dc ! = " " { name = name + " " + d . dc } if d . near ! = " " { name = name + " " + d . near } if name = = " " { return " " } return fmt . Sprintf ( " " , name ) } 
func ( c * SSLConfig ) Copy ( ) * SSLConfig { if c = = nil { return nil } var o SSLConfig o . Ca Cert = c . Ca Cert o . Ca Path = c . Ca Path o . Cert = c . Cert o . Enabled = c . Enabled o . Key = c . Key o . Server Name = c . Server Name o . Verify = c . Verify return & o } 
func ( c * SSLConfig ) Merge ( o * SSLConfig ) * SSLConfig { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Cert ! = nil { r . Cert = o . Cert } if o . Ca Cert ! = nil { r . Ca Cert = o . Ca Cert } if o . Ca Path ! = nil { r . Ca Path = o . Ca Path } if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Key ! = nil { r . Key = o . Key } if o . Server Name ! = nil { r . Server Name = o . Server Name } if o . Verify ! = nil { r . Verify = o . Verify } return r } 
func ( c * SSLConfig ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( false | | String Present ( c . Cert ) | | String Present ( c . Ca Cert ) | | String Present ( c . Ca Path ) | | String Present ( c . Key ) | | String Present ( c . Server Name ) | | Bool Present ( c . Verify ) ) } if c . Cert = = nil { c . Cert = String ( " " ) } if c . Ca Cert = = nil { c . Ca Cert = String ( " " ) } if c . Ca Path = = nil { c . Ca Path = String ( " " ) } if c . Key = = nil { c . Key = String ( " " ) } if c . Server Name = = nil { c . Server Name = String ( " " ) } if c . Verify = = nil { c . Verify = Bool ( Default SSLVerify ) } } 
func ( c * SSLConfig ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " , String Go String ( c . Ca Cert ) , String Go String ( c . Ca Path ) , String Go String ( c . Cert ) , Bool Go String ( c . Enabled ) , String Go String ( c . Key ) , String Go String ( c . Server Name ) , Bool Go String ( c . Verify ) , ) } 
func Parse ( s string ) ( os . Signal , error ) { sig , ok : = Signal Lookup [ strings . To Upper ( s ) ] if ! ok { return nil , fmt . Errorf ( " " , s , Valid Signals ) } return sig , nil } 
func ( c * Transport Config ) Copy ( ) * Transport Config { if c = = nil { return nil } var o Transport Config o . Dial Keep Alive = c . Dial Keep Alive o . Dial Timeout = c . Dial Timeout o . Disable Keep Alives = c . Disable Keep Alives o . Idle Conn Timeout = c . Idle Conn Timeout o . Max Idle Conns = c . Max Idle Conns o . Max Idle Conns Per Host = c . Max Idle Conns Per Host o . TLSHandshake Timeout = c . TLSHandshake Timeout return & o } 
func ( c * Transport Config ) Merge ( o * Transport Config ) * Transport Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Dial Keep Alive ! = nil { r . Dial Keep Alive = o . Dial Keep Alive } if o . Dial Timeout ! = nil { r . Dial Timeout = o . Dial Timeout } if o . Disable Keep Alives ! = nil { r . Disable Keep Alives = o . Disable Keep Alives } if o . Idle Conn Timeout ! = nil { r . Idle Conn Timeout = o . Idle Conn Timeout } if o . Max Idle Conns ! = nil { r . Max Idle Conns = o . Max Idle Conns } if o . Max Idle Conns Per Host ! = nil { r . Max Idle Conns Per Host = o . Max Idle Conns Per Host } if o . TLSHandshake Timeout ! = nil { r . TLSHandshake Timeout = o . TLSHandshake Timeout } return r } 
func ( c * Transport Config ) Finalize ( ) { if c . Dial Keep Alive = = nil { c . Dial Keep Alive = Time Duration ( Default Dial Keep Alive ) } if c . Dial Timeout = = nil { c . Dial Timeout = Time Duration ( Default Dial Timeout ) } if c . Disable Keep Alives = = nil { c . Disable Keep Alives = Bool ( false ) } if c . Idle Conn Timeout = = nil { c . Idle Conn Timeout = Time Duration ( Default Idle Conn Timeout ) } if c . Max Idle Conns = = nil { c . Max Idle Conns = Int ( Default Max Idle Conns ) } if c . Max Idle Conns Per Host = = nil { c . Max Idle Conns Per Host = Int ( Default Max Idle Conns Per Host ) } if c . TLSHandshake Timeout = = nil { c . TLSHandshake Timeout = Time Duration ( Default TLSHandshake Timeout ) } } 
func ( c * Transport Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " , Time Duration Val ( c . Dial Keep Alive ) , Time Duration Val ( c . Dial Timeout ) , Bool Val ( c . Disable Keep Alives ) , Int Val ( c . Max Idle Conns Per Host ) , Time Duration Val ( c . TLSHandshake Timeout ) , ) } 
func Default Vault Config ( ) * Vault Config { v : = & Vault Config { Retry : Default Retry Config ( ) , SSL : Default SSLConfig ( ) , Transport : Default Transport Config ( ) , } return v } 
func ( c * Vault Config ) Copy ( ) * Vault Config { if c = = nil { return nil } var o Vault Config o . Address = c . Address o . Enabled = c . Enabled o . Grace = c . Grace o . Namespace = c . Namespace o . Renew Token = c . Renew Token if c . Retry ! = nil { o . Retry = c . Retry . Copy ( ) } if c . SSL ! = nil { o . SSL = c . SSL . Copy ( ) } o . Token = c . Token o . Vault Agent Token File = c . Vault Agent Token File if c . Transport ! = nil { o . Transport = c . Transport . Copy ( ) } o . Unwrap Token = c . Unwrap Token return & o } 
func ( c * Vault Config ) Merge ( o * Vault Config ) * Vault Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Address ! = nil { r . Address = o . Address } if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Grace ! = nil { r . Grace = o . Grace } if o . Namespace ! = nil { r . Namespace = o . Namespace } if o . Renew Token ! = nil { r . Renew Token = o . Renew Token } if o . Retry ! = nil { r . Retry = r . Retry . Merge ( o . Retry ) } if o . SSL ! = nil { r . SSL = r . SSL . Merge ( o . SSL ) } if o . Token ! = nil { r . Token = o . Token } if o . Vault Agent Token File ! = nil { r . Vault Agent Token File = o . Vault Agent Token File } if o . Transport ! = nil { r . Transport = r . Transport . Merge ( o . Transport ) } if o . Unwrap Token ! = nil { r . Unwrap Token = o . Unwrap Token } return r } 
func ( c * Vault Config ) Finalize ( ) { if c . Address = = nil { c . Address = string From Env ( [ ] string { api . Env Vault Address , } , " " ) } if c . Grace = = nil { c . Grace = Time Duration ( Default Vault Grace ) } if c . Namespace = = nil { c . Namespace = string From Env ( [ ] string { " " } , " " ) } if c . Renew Token = = nil { c . Renew Token = bool From Env ( [ ] string { " " , } , Default Vault Renew Token ) } if c . Retry = = nil { c . Retry = Default Retry Config ( ) } c . Retry . Finalize ( ) } if c . SSL . Enabled = = nil { c . SSL . Enabled = Bool ( true ) } if c . SSL . Ca Cert = = nil { c . SSL . Ca Cert = string From Env ( [ ] string { api . Env Vault CACert } , " " ) } if c . SSL . Ca Path = = nil { c . SSL . Ca Path = string From Env ( [ ] string { api . Env Vault CAPath } , " " ) } if c . SSL . Cert = = nil { c . SSL . Cert = string From Env ( [ ] string { api . Env Vault Client Cert } , " " ) } if c . SSL . Key = = nil { c . SSL . Key = string From Env ( [ ] string { api . Env Vault Client Key } , " " ) } if c . SSL . Server Name = = nil { c . SSL . Server Name = string From Env ( [ ] string { api . Env Vault TLSServer Name } , " " ) } if c . SSL . Verify = = nil { c . SSL . Verify = antibool From Env ( [ ] string { api . Env Vault Insecure } , true ) } c . SSL . Finalize ( ) } if c . Vault Agent Token File ! = nil { c . Token = string From File ( [ ] string { * c . Vault Agent Token File } , " " ) c . Renew Token = Bool ( false ) } if c . Transport = = nil { c . Transport = Default Transport Config ( ) } c . Transport . Finalize ( ) if c . Unwrap Token = = nil { c . Unwrap Token = bool From Env ( [ ] string { " " , } , Default Vault Unwrap Token ) } if c . Enabled = = nil { c . Enabled = Bool ( String Present ( c . Address ) ) } } 
func ( c * Vault Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , String Go String ( c . Address ) , Bool Go String ( c . Enabled ) , Time Duration Go String ( c . Grace ) , String Go String ( c . Namespace ) , Bool Go String ( c . Renew Token ) , c . Retry , c . SSL , String Present ( c . Token ) , String Present ( c . Vault Agent Token File ) , c . Transport , Bool Go String ( c . Unwrap Token ) , ) } 
func New Template ( i * New Template Input ) ( * Template , error ) { if i = = nil { i = & New Template Input { } } } else if i . Source = = " " & & i . Contents = = " " { return nil , Err Template Missing Contents And Source } var t Template t . source = i . Source t . contents = i . Contents t . left Delim = i . Left Delim t . right Delim = i . Right Delim t . err Missing Key = i . Err Missing Key if i . Source ! = " " { contents , err : = ioutil . Read File ( i . Source ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } t . contents = string ( contents ) } t . hex MD 5 = hex . Encode To String ( hash [ : ] ) return & t , nil } 
func ( t * Template ) Execute ( i * Execute Input ) ( * Execute Result , error ) { if i = = nil { i = & Execute Input { } } var used , missing dep . Set tmpl : = template . New ( " " ) tmpl . Delims ( t . left Delim , t . right Delim ) tmpl . Funcs ( func Map ( & func Map Input { t : tmpl , brain : i . Brain , env : i . Env , used : & used , missing : & missing , } ) ) if t . err Missing Key { tmpl . Option ( " " ) } else { tmpl . Option ( " " ) } tmpl , err : = tmpl . Parse ( t . contents ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err : = tmpl . Execute ( & b , nil ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return & Execute Result { Used : & used , Missing : & missing , Output : b . Bytes ( ) , } , nil } 
func func Map ( i * func Map Input ) template . Func Map { var scratch Scratch return template . Func Map { } 
func String To File Mode Func ( ) mapstructure . Decode Hook Func { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) ! = reflect . String { return data , nil } if t ! = reflect . Type Of ( os . File Mode ( 0 ) ) { return data , nil } if err ! = nil { return data , err } return os . File Mode ( v ) , nil } } 
func String To Wait Duration Hook Func ( ) mapstructure . Decode Hook Func { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) ! = reflect . String { return data , nil } if t ! = reflect . Type Of ( Wait Config { } ) { return data , nil } } } 
func Consul String To Struct Func ( ) mapstructure . Decode Hook Func { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if t = = reflect . Type Of ( Consul Config { } ) & & f . Kind ( ) = = reflect . String { log . Println ( " " + " \ " \ " " + " " ) return & Consul Config { Address : String ( data . ( string ) ) , } , nil } return data , nil } } 
func ( c * Dedup Config ) Copy ( ) * Dedup Config { if c = = nil { return nil } var o Dedup Config o . Enabled = c . Enabled o . Max Stale = c . Max Stale o . Prefix = c . Prefix o . TTL = c . TTL return & o } 
func ( c * Dedup Config ) Merge ( o * Dedup Config ) * Dedup Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Max Stale ! = nil { r . Max Stale = o . Max Stale } if o . Prefix ! = nil { r . Prefix = o . Prefix } if o . TTL ! = nil { r . TTL = o . TTL } return r } 
func ( c * Dedup Config ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( false | | Time Duration Present ( c . Max Stale ) | | String Present ( c . Prefix ) | | Time Duration Present ( c . TTL ) ) } if c . Max Stale = = nil { c . Max Stale = Time Duration ( Default Dedup Max Stale ) } if c . Prefix = = nil { c . Prefix = String ( Default Dedup Prefix ) } if c . TTL = = nil { c . TTL = Time Duration ( Default Dedup TTL ) } } 
func ( c * Dedup Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , Bool Go String ( c . Enabled ) , Time Duration Go String ( c . Max Stale ) , String Go String ( c . Prefix ) , Time Duration Go String ( c . TTL ) , ) } 
func ( s * Scratch ) Key ( k string ) bool { s . RLock ( ) defer s . RUnlock ( ) _ , ok : = s . values [ k ] return ok } 
func ( s * Scratch ) Get ( k string ) interface { } { s . RLock ( ) defer s . RUnlock ( ) return s . values [ k ] } 
func ( s * Scratch ) Set ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) s . values [ k ] = v return " " } 
func ( s * Scratch ) Set X ( k string , v interface { } ) string { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if _ , ok : = s . values [ k ] ; ! ok { s . values [ k ] = v } return " " } 
func ( s * Scratch ) Map Set ( k , mk string , v interface { } ) ( string , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) return s . map Set ( k , mk , v , true ) } 
func ( s * Scratch ) Map Set X ( k , mk string , v interface { } ) ( string , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) return s . map Set ( k , mk , v , false ) } 
func ( s * Scratch ) map Set ( k , mk string , v interface { } , o bool ) ( string , error ) { if _ , ok : = s . values [ k ] ; ! ok { s . values [ k ] = make ( map [ string ] interface { } ) } typed , ok : = s . values [ k ] . ( map [ string ] interface { } ) if ! ok { return " " , fmt . Errorf ( " " , k ) } if _ , ok : = typed [ mk ] ; o | | ! ok { typed [ mk ] = v } return " " , nil } 
func ( s * Scratch ) Map Values ( k string ) ( [ ] interface { } , error ) { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if s . values = = nil { return nil , nil } typed , ok : = s . values [ k ] . ( map [ string ] interface { } ) if ! ok { return nil , nil } keys : = make ( [ ] string , 0 , len ( typed ) ) for k : = range typed { keys = append ( keys , k ) } sort . Strings ( keys ) sorted : = make ( [ ] interface { } , len ( keys ) ) for i , k : = range keys { sorted [ i ] = typed [ k ] } return sorted , nil } 
func ( s * Scratch ) init ( ) { if s . values = = nil { s . values = make ( map [ string ] interface { } ) } } 
func Render ( i * Render Input ) ( * Render Result , error ) { existing , err : = ioutil . Read File ( i . Path ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , errors . Wrap ( err , " " ) } if bytes . Equal ( existing , i . Contents ) { return & Render Result { Did Render : false , Would Render : true , Contents : existing , } , nil } if i . Dry { fmt . Fprintf ( i . Dry Stream , " \n " , i . Path , i . Contents ) } else { if err : = Atomic Write ( i . Path , i . Create Dest Dirs , i . Contents , i . Perms , i . Backup ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } return & Render Result { Did Render : true , Would Render : true , Contents : i . Contents , } , nil } 
func Atomic Write ( path string , create Dest Dirs bool , contents [ ] byte , perms os . File Mode , backup bool ) error { if path = = " " { return Err Missing Dest } parent : = filepath . Dir ( path ) if _ , err : = os . Stat ( parent ) ; os . Is Not Exist ( err ) { if create Dest Dirs { if err : = os . Mkdir All ( parent , 0 7 5 5 ) ; err ! = nil { return err } } else { return Err No Parent Dir } } f , err : = ioutil . Temp File ( parent , " " ) if err ! = nil { return err } defer os . Remove ( f . Name ( ) ) if _ , err : = f . Write ( contents ) ; err ! = nil { return err } if err : = f . Sync ( ) ; err ! = nil { return err } if err : = f . Close ( ) ; err ! = nil { return err } if err ! = nil { if os . Is Not Exist ( err ) { perms = Default File Perms } else { return err } } else { perms = current Info . Mode ( ) } } } if err : = os . Chmod ( f . Name ( ) , perms ) ; err ! = nil { return err } } } } if err : = os . Rename ( f . Name ( ) , path ) ; err ! = nil { return err } return nil } 
func copy File ( src , dst string ) error { s , err : = os . Open ( src ) if err ! = nil { return err } defer s . Close ( ) stat , err : = s . Stat ( ) if err ! = nil { return err } d , err : = os . Open File ( dst , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , stat . Mode ( ) ) if err ! = nil { return err } if _ , err : = io . Copy ( d , s ) ; err ! = nil { d . Close ( ) return err } if err : = d . Close ( ) ; err ! = nil { return err } } 
func ( c * Config ) Copy ( ) * Config { var o Config o . Consul = c . Consul if c . Consul ! = nil { o . Consul = c . Consul . Copy ( ) } if c . Dedup ! = nil { o . Dedup = c . Dedup . Copy ( ) } if c . Exec ! = nil { o . Exec = c . Exec . Copy ( ) } o . Kill Signal = c . Kill Signal o . Log Level = c . Log Level o . Max Stale = c . Max Stale o . Pid File = c . Pid File o . Reload Signal = c . Reload Signal if c . Syslog ! = nil { o . Syslog = c . Syslog . Copy ( ) } if c . Templates ! = nil { o . Templates = c . Templates . Copy ( ) } if c . Vault ! = nil { o . Vault = c . Vault . Copy ( ) } if c . Wait ! = nil { o . Wait = c . Wait . Copy ( ) } return & o } 
func ( c * Config ) Merge ( o * Config ) * Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Consul ! = nil { r . Consul = r . Consul . Merge ( o . Consul ) } if o . Dedup ! = nil { r . Dedup = r . Dedup . Merge ( o . Dedup ) } if o . Exec ! = nil { r . Exec = r . Exec . Merge ( o . Exec ) } if o . Kill Signal ! = nil { r . Kill Signal = o . Kill Signal } if o . Log Level ! = nil { r . Log Level = o . Log Level } if o . Max Stale ! = nil { r . Max Stale = o . Max Stale } if o . Pid File ! = nil { r . Pid File = o . Pid File } if o . Reload Signal ! = nil { r . Reload Signal = o . Reload Signal } if o . Syslog ! = nil { r . Syslog = r . Syslog . Merge ( o . Syslog ) } if o . Templates ! = nil { r . Templates = r . Templates . Merge ( o . Templates ) } if o . Vault ! = nil { r . Vault = r . Vault . Merge ( o . Vault ) } if o . Wait ! = nil { r . Wait = r . Wait . Merge ( o . Wait ) } return r } 
func Parse ( s string ) ( * Config , error ) { var shadow interface { } if err : = hcl . Decode ( & shadow , s ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } if ! ok { return nil , errors . New ( " " ) } flatten Keys ( parsed , [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , } ) } } decoder , err : = mapstructure . New Decoder ( & mapstructure . Decoder Config { Decode Hook : mapstructure . Compose Decode Hook Func ( Consul String To Struct Func ( ) , String To File Mode Func ( ) , signals . String To Signal Func ( ) , String To Wait Duration Hook Func ( ) , mapstructure . String To Slice Hook Func ( " " ) , mapstructure . String To Time Duration Hook Func ( ) , ) , Error Unused : true , Metadata : & md , Result : & c , } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err : = decoder . Decode ( parsed ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return & c , nil } 
func Must ( s string ) * Config { c , err : = Parse ( s ) if err ! = nil { log . Fatal ( err ) } return c } 
func From File ( path string ) ( * Config , error ) { c , err : = ioutil . Read File ( path ) if err ! = nil { return nil , errors . Wrap ( err , " " + path ) } config , err : = Parse ( string ( c ) ) if err ! = nil { return nil , errors . Wrap ( err , " " + path ) } return config , nil } 
func From Path ( path string ) ( * Config , error ) { } if err ! = nil { return nil , errors . Wrap ( err , " " + path ) } if err ! = nil { return nil , errors . Wrap ( err , " " + path ) } } } if err ! = nil { return err } c = c . Merge ( new Config ) return nil } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return c , nil } else if stat . Mode ( ) . Is Regular ( ) { return From File ( path ) } return nil , fmt . Errorf ( " " , stat . Mode ( ) . String ( ) ) } 
func ( c * Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , c . Consul , c . Dedup , c . Exec , Signal Go String ( c . Kill Signal ) , String Go String ( c . Log Level ) , Time Duration Go String ( c . Max Stale ) , String Go String ( c . Pid File ) , Signal Go String ( c . Reload Signal ) , c . Syslog , c . Templates , c . Vault , c . Wait , ) } 
func Default Config ( ) * Config { return & Config { Consul : Default Consul Config ( ) , Dedup : Default Dedup Config ( ) , Exec : Default Exec Config ( ) , Syslog : Default Syslog Config ( ) , Templates : Default Template Configs ( ) , Vault : Default Vault Config ( ) , Wait : Default Wait Config ( ) , } } 
func ( c * Config ) Finalize ( ) { if c . Consul = = nil { c . Consul = Default Consul Config ( ) } c . Consul . Finalize ( ) if c . Dedup = = nil { c . Dedup = Default Dedup Config ( ) } c . Dedup . Finalize ( ) if c . Exec = = nil { c . Exec = Default Exec Config ( ) } c . Exec . Finalize ( ) if c . Kill Signal = = nil { c . Kill Signal = Signal ( Default Kill Signal ) } if c . Log Level = = nil { c . Log Level = string From Env ( [ ] string { " " , " " , } , Default Log Level ) } if c . Max Stale = = nil { c . Max Stale = Time Duration ( Default Max Stale ) } if c . Pid File = = nil { c . Pid File = String ( " " ) } if c . Reload Signal = = nil { c . Reload Signal = Signal ( Default Reload Signal ) } if c . Syslog = = nil { c . Syslog = Default Syslog Config ( ) } c . Syslog . Finalize ( ) if c . Templates = = nil { c . Templates = Default Template Configs ( ) } c . Templates . Finalize ( ) if c . Vault = = nil { c . Vault = Default Vault Config ( ) } c . Vault . Finalize ( ) if c . Wait = = nil { c . Wait = Default Wait Config ( ) } c . Wait . Finalize ( ) } 
func flatten Keys ( m map [ string ] interface { } , keys [ ] string ) { key Map : = make ( map [ string ] struct { } ) for _ , key : = range keys { key Map [ key ] = struct { } { } } var flatten func ( map [ string ] interface { } , string ) flatten = func ( m map [ string ] interface { } , parent string ) { for k , v : = range m { if parent ! = " " { map Key = parent + " " + k } if _ , ok : = key Map [ map Key ] ; ! ok { continue } switch typed : = v . ( type ) { case [ ] map [ string ] interface { } : if len ( typed ) > 0 { last : = typed [ len ( typed ) - 1 ] flatten ( last , map Key ) m [ k ] = last } else { m [ k ] = nil } case map [ string ] interface { } : flatten ( typed , map Key ) m [ k ] = typed default : m [ k ] = v } } } flatten ( m , " " ) } 
func New Watcher ( i * New Watcher Input ) ( * Watcher , error ) { w : = & Watcher { clients : i . Clients , dep View Map : make ( map [ string ] * View ) , data Ch : make ( chan * View , data Buffer Size ) , err Ch : make ( chan error ) , max Stale : i . Max Stale , once : i . Once , retry Func Consul : i . Retry Func Consul , retry Func Default : i . Retry Func Default , retry Func Vault : i . Retry Func Vault , vault Grace : i . Vault Grace , } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if _ , err : = w . Add ( vt ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } if len ( i . Vault Agent Token File ) > 0 { vag , err : = dep . New Vault Agent Token Query ( i . Vault Agent Token File ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if _ , err : = w . Add ( vag ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } return w , nil } 
func ( w * Watcher ) Add ( d dep . Dependency ) ( bool , error ) { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " , d ) if _ , ok : = w . dep View Map [ d . String ( ) ] ; ok { log . Printf ( " " , d ) return false , nil } switch d . Type ( ) { case dep . Type Consul : retry Func = w . retry Func Consul case dep . Type Vault : retry Func = w . retry Func Vault default : retry Func = w . retry Func Default } v , err : = New View ( & New View Input { Dependency : d , Clients : w . clients , Max Stale : w . max Stale , Once : w . once , Retry Func : retry Func , Vault Grace : w . vault Grace , } ) if err ! = nil { return false , errors . Wrap ( err , " " ) } log . Printf ( " " , d ) w . dep View Map [ d . String ( ) ] = v go v . poll ( w . data Ch , w . err Ch ) return true , nil } 
func ( w * Watcher ) Watching ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) _ , ok : = w . dep View Map [ d . String ( ) ] return ok } 
func ( w * Watcher ) Force Watching ( d dep . Dependency , enabled bool ) { w . Lock ( ) defer w . Unlock ( ) if enabled { w . dep View Map [ d . String ( ) ] = nil } else { delete ( w . dep View Map , d . String ( ) ) } } 
func ( w * Watcher ) Remove ( d dep . Dependency ) bool { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " , d ) if view , ok : = w . dep View Map [ d . String ( ) ] ; ok { log . Printf ( " " , d ) view . stop ( ) delete ( w . dep View Map , d . String ( ) ) return true } log . Printf ( " " , d ) return false } 
func ( w * Watcher ) Size ( ) int { w . Lock ( ) defer w . Unlock ( ) return len ( w . dep View Map ) } 
func ( w * Watcher ) Stop ( ) { w . Lock ( ) defer w . Unlock ( ) log . Printf ( " " ) for _ , view : = range w . dep View Map { if view = = nil { continue } log . Printf ( " " , view . Dependency ( ) ) view . stop ( ) } } 
func ( s * Set ) Add ( d Dependency ) bool { s . init ( ) s . Lock ( ) defer s . Unlock ( ) if _ , ok : = s . set [ d . String ( ) ] ; ! ok { s . list = append ( s . list , d . String ( ) ) s . set [ d . String ( ) ] = d return true } return false } 
func ( s * Set ) Get ( v string ) Dependency { s . RLock ( ) defer s . RUnlock ( ) return s . set [ v ] } 
func ( s * Set ) List ( ) [ ] Dependency { s . RLock ( ) defer s . RUnlock ( ) r : = make ( [ ] Dependency , len ( s . list ) ) for i , k : = range s . list { r [ i ] = s . set [ k ] } return r } 
func ( s * Set ) Len ( ) int { s . RLock ( ) defer s . RUnlock ( ) return len ( s . list ) } 
func ( s * Set ) String ( ) string { s . RLock ( ) defer s . RUnlock ( ) return strings . Join ( s . list , " " ) } 
func deep Copy And Sort Tags ( tags [ ] string ) [ ] string { new Tags : = make ( [ ] string , 0 , len ( tags ) ) for _ , tag : = range tags { new Tags = append ( new Tags , tag ) } sort . Strings ( new Tags ) return new Tags } 
func resp With Metadata ( i interface { } ) ( interface { } , * Response Metadata , error ) { return i , & Response Metadata { Last Contact : 0 , Last Index : uint 6 4 ( time . Now ( ) . Unix ( ) ) , } , nil } 
func regexp Match ( re * regexp . Regexp , q string ) map [ string ] string { names : = re . Subexp Names ( ) match : = re . Find All String Submatch ( q , - 1 ) if len ( match ) = = 0 { return map [ string ] string { } } m : = map [ string ] string { } for i , n : = range match [ 0 ] { if names [ i ] ! = " " { m [ names [ i ] ] = n } } return m } 
func New Catalog Service Query ( s string ) ( * Catalog Service Query , error ) { if ! Catalog Service Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( Catalog Service Query Re , s ) return & Catalog Service Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , name : m [ " " ] , near : m [ " " ] , tag : m [ " " ] , } , nil } 
func ( d * Catalog Service Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , Near : d . near , } ) u : = & url . URL { Path : " " + d . name , Raw Query : opts . String ( ) , } if d . tag ! = " " { q : = u . Query ( ) q . Set ( " " , d . tag ) u . Raw Query = q . Encode ( ) } log . Printf ( " " , d , u ) entries , qm , err : = clients . Consul ( ) . Catalog ( ) . Service ( d . name , d . tag , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) var list [ ] * Catalog Service for _ , s : = range entries { list = append ( list , & Catalog Service { ID : s . ID , Node : s . Node , Address : s . Address , Datacenter : s . Datacenter , Tagged Addresses : s . Tagged Addresses , Node Meta : s . Node Meta , Service ID : s . Service ID , Service Name : s . Service Name , Service Address : s . Service Address , Service Tags : Service Tags ( deep Copy And Sort Tags ( s . Service Tags ) ) , Service Meta : s . Service Meta , Service Port : s . Service Port , } ) } rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return list , rm , nil } 
func ( d * Catalog Service Query ) String ( ) string { name : = d . name if d . tag ! = " " { name = d . tag + " " + name } if d . dc ! = " " { name = name + " " + d . dc } if d . near ! = " " { name = name + " " + d . near } return fmt . Sprintf ( " " , name ) } 
func New KVList Query ( s string ) ( * KVList Query , error ) { if s ! = " " & & ! KVList Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( KVList Query Re , s ) return & KVList Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , prefix : m [ " " ] , } , nil } 
func ( d * KVList Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . prefix , Raw Query : opts . String ( ) , } ) list , qm , err : = clients . Consul ( ) . KV ( ) . List ( d . prefix , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( list ) ) pairs : = make ( [ ] * Key Pair , 0 , len ( list ) ) for _ , pair : = range list { key : = strings . Trim Prefix ( pair . Key , d . prefix ) key = strings . Trim Left ( key , " " ) pairs = append ( pairs , & Key Pair { Path : pair . Key , Key : key , Value : string ( pair . Value ) , Create Index : pair . Create Index , Modify Index : pair . Modify Index , Lock Index : pair . Lock Index , Flags : pair . Flags , Session : pair . Session , } ) } rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return pairs , rm , nil } 
func ( d * KVList Query ) String ( ) string { prefix : = d . prefix if d . dc ! = " " { prefix = prefix + " " + d . dc } return fmt . Sprintf ( " " , prefix ) } 
func New Dedup Manager ( config * config . Dedup Config , clients * dep . Client Set , brain * template . Brain , templates [ ] * template . Template ) ( * Dedup Manager , error ) { d : = & Dedup Manager { config : config , clients : clients , brain : brain , templates : templates , leader : make ( map [ * template . Template ] < - chan struct { } ) , last Write : make ( map [ * template . Template ] uint 6 4 ) , update Ch : make ( chan struct { } , 1 ) , stop Ch : make ( chan struct { } ) , } return d , nil } 
func ( d * Dedup Manager ) Start ( ) error { log . Printf ( " " ) client : = d . clients . Consul ( ) go d . create Session ( client ) } return nil } 
func ( d * Dedup Manager ) Stop ( ) error { d . stop Lock . Lock ( ) defer d . stop Lock . Unlock ( ) if d . stop { return nil } log . Printf ( " " ) d . stop = true close ( d . stop Ch ) d . wg . Wait ( ) return nil } 
func ( d * Dedup Manager ) create Session ( client * consulapi . Client ) { START : log . Printf ( " " ) session : = client . Session ( ) session Ch : = make ( chan struct { } ) ttl : = fmt . Sprintf ( " " , float 6 4 ( * d . config . TTL ) / float 6 4 ( time . Second ) ) se : = & consulapi . Session Entry { Name : " " , Behavior : " " , TTL : ttl , } id , _ , err : = session . Create ( se , nil ) if err ! = nil { log . Printf ( " " , err ) goto WAIT } log . Printf ( " " , id ) go d . attempt Lock ( client , id , session Ch , t ) } } close ( session Ch ) d . wg . Wait ( ) WAIT : select { case < - time . After ( session Create Retry ) : goto START case < - d . stop Ch : return } } 
func ( d * Dedup Manager ) Is Leader ( tmpl * template . Template ) bool { d . leader Lock . RLock ( ) defer d . leader Lock . RUnlock ( ) lock Ch , ok : = d . leader [ tmpl ] if ! ok { return false } select { case < - lock Ch : return false default : return true } } 
func ( d * Dedup Manager ) Update Deps ( t * template . Template , deps [ ] dep . Dependency ) error { for _ , dp : = range deps { } if ok { td . Data [ dp . String ( ) ] = val } } if err ! = nil { return fmt . Errorf ( " " , err ) } d . last Write Lock . RLock ( ) existing , ok : = d . last Write [ t ] d . last Write Lock . RUnlock ( ) if ok & & existing = = hash { log . Printf ( " " , data Path ) return nil } compress : = lzw . New Writer ( & buf , lzw . LSB , 8 ) enc : = gob . New Encoder ( compress ) if err : = enc . Encode ( & td ) ; err ! = nil { return fmt . Errorf ( " " , err ) } compress . Close ( ) client : = d . clients . Consul ( ) if _ , err : = client . KV ( ) . Put ( & kv Pair , nil ) ; err ! = nil { return fmt . Errorf ( " " , data Path , err ) } log . Printf ( " " , data Path ) d . last Write Lock . Lock ( ) d . last Write [ t ] = hash d . last Write Lock . Unlock ( ) return nil } 
func ( d * Dedup Manager ) set Leader ( tmpl * template . Template , lock Ch < - chan struct { } ) { if lock Ch ! = nil { d . leader [ tmpl ] = lock Ch } else { delete ( d . leader , tmpl ) } d . leader Lock . Unlock ( ) delete ( d . last Write , tmpl ) d . last Write Lock . Unlock ( ) } } 
func ( d * Dedup Manager ) parse Data ( path string , raw [ ] byte ) { decompress : = lzw . New Reader ( r , lzw . LSB , 8 ) defer decompress . Close ( ) dec : = gob . New Decoder ( decompress ) if err : = dec . Decode ( & td ) ; err ! = nil { log . Printf ( " " , path , err ) return } if td . Version ! = version . Version { log . Printf ( " " , td . Version , version . Version ) return } log . Printf ( " " , len ( td . Data ) , path ) } } 
func New File Query ( s string ) ( * File Query , error ) { s = strings . Trim Space ( s ) if s = = " " { return nil , fmt . Errorf ( " " , s ) } return & File Query { stop Ch : make ( chan struct { } , 1 ) , path : s , } , nil } 
func ( d * File Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { log . Printf ( " " , d , d . path ) select { case < - d . stop Ch : log . Printf ( " " , d ) return " " , nil , Err Stopped case r : = < - d . watch ( d . stat ) : if r . err ! = nil { return " " , nil , errors . Wrap ( r . err , d . String ( ) ) } log . Printf ( " " , d ) data , err : = ioutil . Read File ( d . path ) if err ! = nil { return " " , nil , errors . Wrap ( err , d . String ( ) ) } d . stat = r . stat return resp With Metadata ( string ( data ) ) } } 
func New CLI ( out , err io . Writer ) * CLI { return & CLI { out Stream : out , err Stream : err , signal Ch : make ( chan os . Signal , 1 ) , stop Ch : make ( chan struct { } ) , } } 
func ( cli * CLI ) Run ( args [ ] string ) int { if err ! = nil { if err = = flag . Err Help { fmt . Fprintf ( cli . err Stream , usage , version . Name ) return 0 } fmt . Fprintln ( cli . err Stream , err . Error ( ) ) return Exit Code Parse Flags Error } if err ! = nil { return log Error ( err , Exit Code Config Error ) } config . Finalize ( ) if err ! = nil { return log Error ( err , Exit Code Config Error ) } fmt . Fprintf ( cli . err Stream , " \n " , version . Human Version ) return Exit Code OK } if err ! = nil { return log Error ( err , Exit Code Runner Error ) } go runner . Start ( ) for { select { case err : = < - runner . Err Ch : if typed , ok : = err . ( manager . Err Exitable ) ; ok { code = typed . Exit Status ( ) } return log Error ( err , code ) case < - runner . Done Ch : return Exit Code OK case s : = < - cli . signal Ch : log . Printf ( " " , s ) switch s { case * config . Reload Signal : fmt . Fprintf ( cli . err Stream , " \n " ) runner . Stop ( ) if err ! = nil { return log Error ( err , Exit Code Config Error ) } config . Finalize ( ) if err ! = nil { return log Error ( err , Exit Code Config Error ) } runner , err = manager . New Runner ( config , dry , once ) if err ! = nil { return log Error ( err , Exit Code Runner Error ) } go runner . Start ( ) case * config . Kill Signal : fmt . Fprintf ( cli . err Stream , " \n " ) runner . Stop ( ) return Exit Code Interrupt case signals . Signal Lookup [ " " ] : } case < - cli . stop Ch : return Exit Code OK } } } 
func ( cli * CLI ) stop ( ) { cli . Lock ( ) defer cli . Unlock ( ) if cli . stopped { return } close ( cli . stop Ch ) cli . stopped = true } 
func ( cli * CLI ) Parse Flags ( args [ ] string ) ( * config . Config , [ ] string , bool , bool , bool , error ) { var dry , once , is Version bool c : = config . Default Config ( ) if s : = os . Getenv ( " " ) ; s ! = " " { env Config , err : = config . Parse ( s ) if err ! = nil { return nil , nil , false , false , false , err } c = c . Merge ( env Config ) } flags . Set Output ( ioutil . Discard ) flags . Usage = func ( ) { } flags . Var ( ( func Var ) ( func ( s string ) error { config Paths = append ( config Paths , s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . Address = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { a , err : = config . Parse Auth Config ( s ) if err ! = nil { return err } c . Consul . Auth = a return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Consul . Retry . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Int Var ) ( func ( i int ) error { c . Consul . Retry . Attempts = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Retry . Backoff = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Retry . Max Backoff = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Consul . SSL . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . SSL . Ca Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . SSL . Ca Path = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . SSL . Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . SSL . Key = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . SSL . Server Name = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Consul . SSL . Verify = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Consul . Token = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Transport . Dial Keep Alive = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Transport . Dial Timeout = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Consul . Transport . Disable Keep Alives = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Int Var ) ( func ( i int ) error { c . Consul . Transport . Max Idle Conns Per Host = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Transport . TLSHandshake Timeout = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Dedup . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Bool Var ( & dry , " " , false , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Exec . Enabled = config . Bool ( true ) c . Exec . Command = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { sig , err : = signals . Parse ( s ) if err ! = nil { return err } c . Exec . Kill Signal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Exec . Kill Timeout = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { sig , err : = signals . Parse ( s ) if err ! = nil { return err } c . Exec . Reload Signal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Exec . Splay = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { sig , err : = signals . Parse ( s ) if err ! = nil { return err } c . Kill Signal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Log Level = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Max Stale = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Bool Var ( & once , " " , false , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Pid File = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { sig , err : = signals . Parse ( s ) if err ! = nil { return err } c . Reload Signal = config . Signal ( sig ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Consul . Retry . Backoff = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Syslog . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Syslog . Facility = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { t , err : = config . Parse Template Config ( s ) if err ! = nil { return err } * c . Templates = append ( * c . Templates , t ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . Address = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( t time . Duration ) error { c . Vault . Grace = config . Time Duration ( t ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . Renew Token = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . Retry . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Int Var ) ( func ( i int ) error { c . Vault . Retry . Attempts = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Vault . Retry . Backoff = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Vault . Retry . Max Backoff = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . SSL . Enabled = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . SSL . Ca Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . SSL . Ca Path = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . SSL . Cert = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . SSL . Key = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . SSL . Server Name = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . SSL . Verify = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Vault . Transport . Dial Keep Alive = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Vault . Transport . Dial Timeout = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . Transport . Disable Keep Alives = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Int Var ) ( func ( i int ) error { c . Vault . Transport . Max Idle Conns Per Host = config . Int ( i ) return nil } ) , " " , " " ) flags . Var ( ( func Duration Var ) ( func ( d time . Duration ) error { c . Vault . Transport . TLSHandshake Timeout = config . Time Duration ( d ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . Token = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { c . Vault . Vault Agent Token File = config . String ( s ) return nil } ) , " " , " " ) flags . Var ( ( func Bool Var ) ( func ( b bool ) error { c . Vault . Unwrap Token = config . Bool ( b ) return nil } ) , " " , " " ) flags . Var ( ( func Var ) ( func ( s string ) error { w , err : = config . Parse Wait Config ( s ) if err ! = nil { return err } c . Wait = w return nil } ) , " " , " " ) flags . Bool Var ( & is Version , " " , false , " " ) flags . Bool Var ( & is Version , " " , false , " " ) } if len ( args ) > 0 { return nil , nil , false , false , false , fmt . Errorf ( " " , args ) } return c , config Paths , once , dry , is Version , nil } 
func load Configs ( paths [ ] string , o * config . Config ) ( * config . Config , error ) { final C : = config . Default Config ( ) for _ , path : = range paths { c , err : = config . From Path ( path ) if err ! = nil { return nil , err } final C = final C . Merge ( c ) } final C = final C . Merge ( o ) final C . Finalize ( ) return final C , nil } 
func log Error ( err error , status int ) int { log . Printf ( " " , err ) return status } 
func File Mode Go String ( o * os . File Mode ) string { if o = = nil { return " " } return fmt . Sprintf ( " " , * o ) } 
func Signal Val ( s * os . Signal ) os . Signal { if s = = nil { return ( os . Signal ) ( nil ) } return * s } 
func Signal Go String ( s * os . Signal ) string { if s = = nil { return " " } if * s = = nil { return " " } return fmt . Sprintf ( " " , * s ) } 
func Signal Present ( s * os . Signal ) bool { if s = = nil { return false } return * s ! = signals . SIGNIL } 
func Time Duration Val ( t * time . Duration ) time . Duration { if t = = nil { return time . Duration ( 0 ) } return * t } 
func Time Duration Go String ( t * time . Duration ) string { if t = = nil { return " " } return fmt . Sprintf ( " " , t ) } 
func ( c * Client Set ) Create Consul Client ( i * Create Consul Client Input ) error { consul Config : = consulapi . Default Config ( ) if i . Address ! = " " { consul Config . Address = i . Address } if i . Token ! = " " { consul Config . Token = i . Token } if i . Auth Enabled { consul Config . Http Auth = & consulapi . Http Basic Auth { Username : i . Auth Username , Password : i . Auth Password , } } var tls Config tls . Config if err ! = nil { return fmt . Errorf ( " " , err ) } tls Config . Certificates = [ ] tls . Certificate { cert } } else if i . SSLCert ! = " " { cert , err : = tls . Load X 5 0 9Key Pair ( i . SSLCert , i . SSLCert ) if err ! = nil { return fmt . Errorf ( " " , err ) } tls Config . Certificates = [ ] tls . Certificate { cert } } if err : = rootcerts . Configure TLS ( & tls Config , root Config ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } tls Config . Insecure Skip Verify = false } if ! i . SSLVerify { log . Printf ( " " ) tls Config . Insecure Skip Verify = true } } if err ! = nil { return fmt . Errorf ( " " , err ) } c . consul = & consul Client { client : client , transport : transport , } c . Unlock ( ) return nil } 
func ( c * Client Set ) Consul ( ) * consulapi . Client { c . RLock ( ) defer c . RUnlock ( ) return c . consul . client } 
func ( c * Client Set ) Vault ( ) * vaultapi . Client { c . RLock ( ) defer c . RUnlock ( ) return c . vault . client } 
func ( c * Client Set ) Stop ( ) { c . Lock ( ) defer c . Unlock ( ) if c . consul ! = nil { c . consul . transport . Close Idle Connections ( ) } if c . vault ! = nil { c . vault . http Client . Transport . ( * http . Transport ) . Close Idle Connections ( ) } } 
func New Vault Read Query ( s string ) ( * Vault Read Query , error ) { s = strings . Trim Space ( s ) s = strings . Trim ( s , " " ) if s = = " " { return nil , fmt . Errorf ( " " , s ) } secret URL , err : = url . Parse ( s ) if err ! = nil { return nil , err } return & Vault Read Query { stop Ch : make ( chan struct { } , 1 ) , raw Path : secret URL . Path , query Values : secret URL . Query ( ) , } , nil } 
func ( d * Vault Read Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { } ) if d . secret ! = nil { if vault Secret Renewable ( d . secret ) { log . Printf ( " " , d ) renewer , err : = clients . Vault ( ) . New Renewer ( & api . Renewer Input { Grace : opts . Vault Grace , Secret : d . vault Secret , } ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } go renewer . Renew ( ) defer renewer . Stop ( ) RENEW : for { select { case err : = < - renewer . Done Ch ( ) : if err ! = nil { log . Printf ( " " , d , err ) } log . Printf ( " " , d ) break RENEW case renewal : = < - renewer . Renew Ch ( ) : log . Printf ( " " , d ) print Vault Warnings ( d , renewal . Secret . Warnings ) update Secret ( d . secret , renewal . Secret ) case < - d . stop Ch : return nil , nil , Err Stopped } } } else { log . Printf ( " " , d , dur ) select { case < - time . After ( dur ) : } } } if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } d . secret = transform Secret ( vault Secret ) return resp With Metadata ( d . secret ) } 
func ( c * Exec Config ) Copy ( ) * Exec Config { if c = = nil { return nil } var o Exec Config o . Command = c . Command o . Enabled = c . Enabled if c . Env ! = nil { o . Env = c . Env . Copy ( ) } o . Kill Signal = c . Kill Signal o . Kill Timeout = c . Kill Timeout o . Reload Signal = c . Reload Signal o . Splay = c . Splay o . Timeout = c . Timeout return & o } 
func ( c * Exec Config ) Merge ( o * Exec Config ) * Exec Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Command ! = nil { r . Command = o . Command } if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Env ! = nil { r . Env = r . Env . Merge ( o . Env ) } if o . Kill Signal ! = nil { r . Kill Signal = o . Kill Signal } if o . Kill Timeout ! = nil { r . Kill Timeout = o . Kill Timeout } if o . Reload Signal ! = nil { r . Reload Signal = o . Reload Signal } if o . Splay ! = nil { r . Splay = o . Splay } if o . Timeout ! = nil { r . Timeout = o . Timeout } return r } 
func ( c * Exec Config ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( String Present ( c . Command ) ) } if c . Command = = nil { c . Command = String ( " " ) } if c . Env = = nil { c . Env = Default Env Config ( ) } c . Env . Finalize ( ) if c . Kill Signal = = nil { c . Kill Signal = Signal ( Default Exec Kill Signal ) } if c . Kill Timeout = = nil { c . Kill Timeout = Time Duration ( Default Exec Kill Timeout ) } if c . Reload Signal = = nil { c . Reload Signal = Signal ( Default Exec Reload Signal ) } if c . Splay = = nil { c . Splay = Time Duration ( 0 * time . Second ) } if c . Timeout = = nil { c . Timeout = Time Duration ( Default Exec Timeout ) } } 
func ( c * Exec Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , String Go String ( c . Command ) , Bool Go String ( c . Enabled ) , c . Env , Signal Go String ( c . Kill Signal ) , Time Duration Go String ( c . Kill Timeout ) , Signal Go String ( c . Reload Signal ) , Time Duration Go String ( c . Splay ) , Time Duration Go String ( c . Timeout ) , ) } 
func New KVGet Query ( s string ) ( * KVGet Query , error ) { if s ! = " " & & ! KVGet Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( KVGet Query Re , s ) return & KVGet Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , key : m [ " " ] , } , nil } 
func ( d * KVGet Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . key , Raw Query : opts . String ( ) , } ) pair , qm , err : = clients . Consul ( ) . KV ( ) . Get ( d . key , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , Block : d . block , } if pair = = nil { log . Printf ( " " , d ) return nil , rm , nil } value : = string ( pair . Value ) log . Printf ( " " , d , value ) return value , rm , nil } 
func ( d * KVGet Query ) String ( ) string { key : = d . key if d . dc ! = " " { key = key + " " + d . dc } if d . block { return fmt . Sprintf ( " " , key ) } return fmt . Sprintf ( " " , key ) } 
func New Vault Agent Token Query ( path string ) ( * Vault Agent Token Query , error ) { return & Vault Agent Token Query { stop Ch : make ( chan struct { } , 1 ) , path : path , } , nil } 
func ( d * Vault Agent Token Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { log . Printf ( " " , d , d . path ) select { case < - d . stop Ch : log . Printf ( " " , d ) return " " , nil , Err Stopped case r : = < - d . watch ( d . stat ) : if r . err ! = nil { return " " , nil , errors . Wrap ( r . err , d . String ( ) ) } log . Printf ( " " , d ) token , err : = ioutil . Read File ( d . path ) if err ! = nil { return " " , nil , errors . Wrap ( err , d . String ( ) ) } d . stat = r . stat clients . Vault ( ) . Set Token ( strings . Trim Space ( string ( token ) ) ) } return resp With Metadata ( " " ) } 
func ( d * Vault Agent Token Query ) watch ( last Stat os . File Info ) < - chan * watch Result { ch : = make ( chan * watch Result , 1 ) go func ( last Stat os . File Info ) { for { stat , err : = os . Stat ( d . path ) if err ! = nil { select { case < - d . stop Ch : return case ch < - & watch Result { err : err } : return } } changed : = last Stat = = nil | | last Stat . Size ( ) ! = stat . Size ( ) | | last Stat . Mod Time ( ) ! = stat . Mod Time ( ) if changed { select { case < - d . stop Ch : return case ch < - & watch Result { stat : stat } : return } } time . Sleep ( Vault Agent Token Sleep Time ) } } ( last Stat ) return ch } 
func New KVKeys Query ( s string ) ( * KVKeys Query , error ) { if s ! = " " & & ! KVKeys Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( KVKeys Query Re , s ) return & KVKeys Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , prefix : m [ " " ] , } , nil } 
func ( d * KVKeys Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " + d . prefix , Raw Query : opts . String ( ) , } ) list , qm , err : = clients . Consul ( ) . KV ( ) . Keys ( d . prefix , " " , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } keys : = make ( [ ] string , len ( list ) ) for i , v : = range list { v = strings . Trim Prefix ( v , d . prefix ) v = strings . Trim Left ( v , " " ) keys [ i ] = v } log . Printf ( " " , d , len ( list ) ) rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return keys , rm , nil } 
func ( d * KVKeys Query ) String ( ) string { prefix : = d . prefix if d . dc ! = " " { prefix = prefix + " " + d . dc } return fmt . Sprintf ( " " , prefix ) } 
func New ( i * New Input ) ( * Child , error ) { if i = = nil { i = new ( New Input ) } if len ( i . Command ) = = 0 { return nil , Err Missing Command } child : = & Child { stdin : i . Stdin , stdout : i . Stdout , stderr : i . Stderr , command : i . Command , args : i . Args , env : i . Env , timeout : i . Timeout , reload Signal : i . Reload Signal , kill Signal : i . Kill Signal , kill Timeout : i . Kill Timeout , splay : i . Splay , stop Ch : make ( chan struct { } , 1 ) , } return child , nil } 
func ( c * Child ) Exit Ch ( ) < - chan int { c . RLock ( ) defer c . RUnlock ( ) return c . exit Ch } 
func ( c * Child ) Pid ( ) int { c . RLock ( ) defer c . RUnlock ( ) return c . pid ( ) } 
func ( c * Child ) Command ( ) string { list : = append ( [ ] string { c . command } , c . args . . . ) return strings . Join ( list , " " ) } 
func ( c * Child ) Start ( ) error { log . Printf ( " " , c . Command ( ) ) c . Lock ( ) defer c . Unlock ( ) return c . start ( ) } 
func ( c * Child ) Signal ( s os . Signal ) error { log . Printf ( " " , s . String ( ) ) c . RLock ( ) defer c . RUnlock ( ) return c . signal ( s ) } 
func ( c * Child ) Reload ( ) error { if c . reload Signal = = nil { log . Printf ( " " ) defer c . Unlock ( ) c . kill ( ) return c . start ( ) } log . Printf ( " " ) defer c . RUnlock ( ) return c . reload ( ) } 
func ( c * Child ) Kill ( ) { log . Printf ( " " ) c . Lock ( ) defer c . Unlock ( ) c . kill ( ) } 
func ( c * Child ) Stop ( ) { log . Printf ( " " ) c . Lock ( ) defer c . Unlock ( ) c . stop Lock . Lock ( ) defer c . stop Lock . Unlock ( ) if c . stopped { log . Printf ( " " ) return } c . kill ( ) close ( c . stop Ch ) c . stopped = true } 
func ( c * Env Config ) Copy ( ) * Env Config { if c = = nil { return nil } var o Env Config if c . Blacklist ! = nil { o . Blacklist = append ( [ ] string { } , c . Blacklist . . . ) } if c . Custom ! = nil { o . Custom = append ( [ ] string { } , c . Custom . . . ) } o . Pristine = c . Pristine if c . Whitelist ! = nil { o . Whitelist = append ( [ ] string { } , c . Whitelist . . . ) } return & o } 
func ( c * Env Config ) Merge ( o * Env Config ) * Env Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Blacklist ! = nil { r . Blacklist = append ( r . Blacklist , o . Blacklist . . . ) } if o . Custom ! = nil { r . Custom = append ( r . Custom , o . Custom . . . ) } if o . Pristine ! = nil { r . Pristine = o . Pristine } if o . Whitelist ! = nil { r . Whitelist = append ( r . Whitelist , o . Whitelist . . . ) } return r } 
func ( c * Env Config ) Env ( ) [ ] string { } return [ ] string { } } keys : = make ( [ ] string , len ( environ ) ) env : = make ( map [ string ] string , len ( environ ) ) for i , v : = range environ { list : = strings . Split N ( v , " " , 2 ) keys [ i ] = list [ 0 ] env [ list [ 0 ] ] = list [ 1 ] } } } return false } for _ , k : = range keys { if any Glob Match ( k , c . Whitelist ) { new Keys = append ( new Keys , k ) } } keys = new Keys } for _ , k : = range keys { if ! any Glob Match ( k , c . Blacklist ) { new Keys = append ( new Keys , k ) } } keys = new Keys } for _ , k : = range keys { final Env = append ( final Env , k + " " + env [ k ] ) } return final Env } 
func ( c * Env Config ) Finalize ( ) { if c . Blacklist = = nil { c . Blacklist = [ ] string { } } if c . Custom = = nil { c . Custom = [ ] string { } } if c . Pristine = = nil { c . Pristine = Bool ( false ) } if c . Whitelist = = nil { c . Whitelist = [ ] string { } } } 
func ( c * Env Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , c . Blacklist , c . Custom , Bool Go String ( c . Pristine ) , c . Whitelist , ) } 
func New Health Service Query ( s string ) ( * Health Service Query , error ) { if ! Health Service Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( Health Service Query Re , s ) var filters [ ] string if filter : = m [ " " ] ; filter ! = " " { split : = strings . Split ( filter , " " ) for _ , f : = range split { f = strings . Trim Space ( f ) switch f { case Health Any , Health Passing , Health Warning , Health Critical , Health Maint : filters = append ( filters , f ) case " " : default : return nil , fmt . Errorf ( " " , f , s ) } } sort . Strings ( filters ) } else { filters = [ ] string { Health Passing } } return & Health Service Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , filters : filters , name : m [ " " ] , near : m [ " " ] , tag : m [ " " ] , } , nil } 
func ( d * Health Service Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , Near : d . near , } ) u : = & url . URL { Path : " " + d . name , Raw Query : opts . String ( ) , } if d . tag ! = " " { q : = u . Query ( ) q . Set ( " " , d . tag ) u . Raw Query = q . Encode ( ) } log . Printf ( " " , d , u ) entries , qm , err : = clients . Consul ( ) . Health ( ) . Service ( d . name , d . tag , passing Only , opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) list : = make ( [ ] * Health Service , 0 , len ( entries ) ) for _ , entry : = range entries { } if address = = " " { address = entry . Node . Address } list = append ( list , & Health Service { Node : entry . Node . Node , Node ID : entry . Node . ID , Node Address : entry . Node . Address , Node Tagged Addresses : entry . Node . Tagged Addresses , Node Meta : entry . Node . Meta , Service Meta : entry . Service . Meta , Address : address , ID : entry . Service . ID , Name : entry . Service . Service , Tags : Service Tags ( deep Copy And Sort Tags ( entry . Service . Tags ) ) , Status : status , Checks : entry . Checks , Port : entry . Service . Port , } ) } log . Printf ( " " , d , len ( list ) ) } rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return list , rm , nil } 
func ( d * Health Service Query ) String ( ) string { name : = d . name if d . tag ! = " " { name = d . tag + " " + name } if d . dc ! = " " { name = name + " " + d . dc } if d . near ! = " " { name = name + " " + d . near } if len ( d . filters ) > 0 { name = name + " " + strings . Join ( d . filters , " " ) } return fmt . Sprintf ( " " , name ) } 
func accept Status ( list [ ] string , s string ) bool { for _ , status : = range list { if status = = s | | status = = Health Any { return true } } return false } 
func ( c * Retry Config ) Copy ( ) * Retry Config { if c = = nil { return nil } var o Retry Config o . Attempts = c . Attempts o . Backoff = c . Backoff o . Max Backoff = c . Max Backoff o . Enabled = c . Enabled return & o } 
func ( c * Retry Config ) Merge ( o * Retry Config ) * Retry Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Attempts ! = nil { r . Attempts = o . Attempts } if o . Backoff ! = nil { r . Backoff = o . Backoff } if o . Max Backoff ! = nil { r . Max Backoff = o . Max Backoff } if o . Enabled ! = nil { r . Enabled = o . Enabled } return r } 
func ( c * Retry Config ) Retry Func ( ) Retry Func { return func ( retry int ) ( bool , time . Duration ) { if ! Bool Val ( c . Enabled ) { return false , 0 } if Int Val ( c . Attempts ) > 0 & & retry > Int Val ( c . Attempts ) - 1 { return false , 0 } base Sleep : = Time Duration Val ( c . Backoff ) max Sleep : = Time Duration Val ( c . Max Backoff ) if max Sleep > 0 { attempts Till Max Backoff : = int ( math . Log 2 ( max Sleep . Seconds ( ) / base Sleep . Seconds ( ) ) ) if retry > attempts Till Max Backoff { return true , max Sleep } } base : = math . Pow ( 2 , float 6 4 ( retry ) ) sleep : = time . Duration ( base ) * base Sleep return true , sleep } } 
func ( c * Retry Config ) Finalize ( ) { if c . Attempts = = nil { c . Attempts = Int ( Default Retry Attempts ) } if c . Backoff = = nil { c . Backoff = Time Duration ( Default Retry Backoff ) } if c . Max Backoff = = nil { c . Max Backoff = Time Duration ( Default Retry Max Backoff ) } if c . Enabled = = nil { c . Enabled = Bool ( true ) } } 
func ( c * Retry Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " , Int Go String ( c . Attempts ) , Time Duration Go String ( c . Backoff ) , Time Duration Go String ( c . Max Backoff ) , Bool Go String ( c . Enabled ) , ) } 
func New Runner ( config * config . Config , dry , once bool ) ( * Runner , error ) { log . Printf ( " " , dry , once ) runner : = & Runner { config : config , dry : dry , once : once , } if err : = runner . init ( ) ; err ! = nil { return nil , err } return runner , nil } 
func ( r * Runner ) Start ( ) { log . Printf ( " " ) return } if r . dedup ! = nil { if err : = r . dedup . Start ( ) ; err ! = nil { r . Err Ch < - err return } dedup Ch = r . dedup . Update Ch ( ) } if err : = r . Run ( ) ; err ! = nil { r . Err Ch < - err return } for { } for _ , c : = range r . template Configs For ( t ) { if * c . Wait . Enabled { log . Printf ( " " , t . ID ( ) ) r . quiescence Map [ t . ID ( ) ] = new Quiescence ( r . quiescence Ch , * c . Wait . Min , * c . Wait . Max , t ) continue NEXT _Q } } if * r . config . Wait . Enabled { log . Printf ( " " , t . ID ( ) ) r . quiescence Map [ t . ID ( ) ] = new Quiescence ( r . quiescence Ch , * r . config . Wait . Min , * r . config . Wait . Max , t ) continue NEXT _Q } } } else { log . Printf ( " " , r . watcher . Size ( ) ) } if r . all Templates Rendered ( ) { log . Printf ( " " ) log . Printf ( " " ) if r . child = = nil { env : = r . config . Exec . Env . Copy ( ) env . Custom = append ( r . child Env ( ) , env . Custom . . . ) child , err : = spawn Child ( & spawn Child Input { Stdin : r . in Stream , Stdout : r . out Stream , Stderr : r . err Stream , Command : config . String Val ( r . config . Exec . Command ) , Env : env . Env ( ) , Reload Signal : config . Signal Val ( r . config . Exec . Reload Signal ) , Kill Signal : config . Signal Val ( r . config . Exec . Kill Signal ) , Kill Timeout : config . Time Duration Val ( r . config . Exec . Kill Timeout ) , Splay : config . Time Duration Val ( r . config . Exec . Splay ) , } ) if err ! = nil { r . Err Ch < - err r . child Lock . Unlock ( ) return } r . child = child } if nexit Ch ! = nil { child Exit Ch = nexit Ch } } if r . child ! = nil { r . stop Dedup ( ) r . stop Watcher ( ) log . Printf ( " " ) select { case c : = < - child Exit Ch : log . Printf ( " " ) r . Err Ch < - New Err Child Died ( c ) return case < - r . Done Ch : } } r . Stop ( ) return } } OUTER : select { case view : = < - r . watcher . Data Ch ( ) : default : break OUTER } } case < - dedup Ch : break OUTER case err : = < - r . watcher . Err Ch ( ) : r . Err Ch < - err return case tmpl : = < - r . quiescence Ch : delete ( r . quiescence Map , tmpl . ID ( ) ) case c : = < - child Exit Ch : log . Printf ( " " ) r . Err Ch < - New Err Child Died ( c ) return case < - r . Done Ch : log . Printf ( " " ) return } return } } } 
func ( r * Runner ) Stop ( ) { r . stop Lock . Lock ( ) defer r . stop Lock . Unlock ( ) if r . stopped { return } log . Printf ( " " ) r . stop Dedup ( ) r . stop Watcher ( ) r . stop Child ( ) if err : = r . delete Pid ( ) ; err ! = nil { log . Printf ( " " , r . config . Pid File , err ) } r . stopped = true close ( r . Done Ch ) } 
func ( r * Runner ) Render Events ( ) map [ string ] * Render Event { r . render Events Lock . RLock ( ) defer r . render Events Lock . RUnlock ( ) times : = make ( map [ string ] * Render Event , len ( r . render Events ) ) for k , v : = range r . render Events { times [ k ] = v } return times } 
func ( r * Runner ) Receive ( d dep . Dependency , data interface { } ) { r . dependencies Lock . Lock ( ) defer r . dependencies Lock . Unlock ( ) r . brain . Remember ( d , data ) } } 
func ( r * Runner ) Signal ( s os . Signal ) error { r . child Lock . RLock ( ) defer r . child Lock . RUnlock ( ) if r . child = = nil { return nil } return r . child . Signal ( s ) } 
func ( r * Runner ) Run ( ) error { log . Printf ( " " ) var new Render Event , would Render Any , rendered Any bool run Ctx : = & template Run Ctx { deps Map : make ( map [ string ] dep . Dependency ) , } for _ , tmpl : = range r . templates { event , err : = r . run Template ( tmpl , run Ctx ) if err ! = nil { return err } r . render Events [ tmpl . ID ( ) ] = event r . render Events Lock . Unlock ( ) } } } } } } for _ , t : = range run Ctx . commands { command : = config . String Val ( t . Exec . Command ) log . Printf ( " " , command , t . Display ( ) ) env : = t . Exec . Env . Copy ( ) env . Custom = append ( r . child Env ( ) , env . Custom . . . ) if _ , err : = spawn Child ( & spawn Child Input { Stdin : r . in Stream , Stdout : r . out Stream , Stderr : r . err Stream , Command : command , Env : env . Env ( ) , Timeout : config . Time Duration Val ( t . Exec . Timeout ) , Reload Signal : config . Signal Val ( t . Exec . Reload Signal ) , Kill Signal : config . Signal Val ( t . Exec . Kill Signal ) , Kill Timeout : config . Time Duration Val ( t . Exec . Kill Timeout ) , Splay : config . Time Duration Val ( t . Exec . Splay ) , } ) ; err ! = nil { s : = fmt . Sprintf ( " " , command , t . Display ( ) ) errs = append ( errs , errors . Wrap ( err , s ) ) } } if err : = r . child . Reload ( ) ; err ! = nil { errs = append ( errs , err ) } r . child Lock . RUnlock ( ) } for _ , err : = range errs { result = multierror . Append ( result , err ) } return result . Error Or Nil ( ) } return nil } 
func ( r * Runner ) run Template ( tmpl * template . Template , run Ctx * template Run Ctx ) ( * Render Event , error ) { log . Printf ( " " , tmpl . ID ( ) ) last Event : = r . render Events [ tmpl . ID ( ) ] r . render Events Lock . RUnlock ( ) if last Event ! = nil { event . Last Would Render = last Event . Last Would Render event . Last Did Render = last Event . Last Did Render } if r . dedup ! = nil { is Leader = r . dedup . Is Leader ( tmpl ) } event , ok : = r . render Events [ tmpl . ID ( ) ] r . render Events Lock . RUnlock ( ) if ok & & ( event . Would Render | | event . Did Render ) { log . Printf ( " " ) return nil , nil } } if err ! = nil { return nil , errors . Wrap ( err , tmpl . Source ( ) ) } } if _ , ok : = run Ctx . deps Map [ d . String ( ) ] ; ! ok { run Ctx . deps Map [ d . String ( ) ] = d } } for _ , d : = range missing . List ( ) { if ! r . watcher . Watching ( d ) { unwatched . Add ( d ) } } event . Unwatched Deps = unwatched event . Used Deps = used event . Updated At = time . Now ( ) . UTC ( ) for _ , d : = range unwatched . List ( ) { } } return event , nil } return event , nil } } } return event , nil } if err ! = nil { return nil , errors . Wrap ( err , " " + template Config . Display ( ) ) } render Time : = time . Now ( ) . UTC ( ) event . Last Would Render = render Time } event . Last Did Render = render Time if ! r . dry { if existing ! = nil { log . Printf ( " " , c , template Config . Display ( ) , existing . Display ( ) ) } else { log . Printf ( " " , c , template Config . Display ( ) ) run Ctx . commands = append ( run Ctx . commands , template Config ) } } } } } return event , nil } 
func ( r * Runner ) init ( ) error { r . config . Finalize ( ) if err ! = nil { return err } log . Printf ( " " , result ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err ! = nil { return fmt . Errorf ( " " , err ) } r . watcher = watcher num Templates : = len ( * r . config . Templates ) templates : = make ( [ ] * template . Template , 0 , num Templates ) ctemplates Map : = make ( map [ string ] config . Template Configs ) if err ! = nil { return err } if _ , ok : = ctemplates Map [ tmpl . ID ( ) ] ; ! ok { templates = append ( templates , tmpl ) } if _ , ok : = ctemplates Map [ tmpl . ID ( ) ] ; ! ok { ctemplates Map [ tmpl . ID ( ) ] = make ( [ ] * config . Template Config , 0 , 1 ) } ctemplates Map [ tmpl . ID ( ) ] = append ( ctemplates Map [ tmpl . ID ( ) ] , ctmpl ) } r . render Events = make ( map [ string ] * Render Event , num Templates ) r . dependencies = make ( map [ string ] dep . Dependency ) r . rendered Ch = make ( chan struct { } , 1 ) r . render Event Ch = make ( chan struct { } , 1 ) r . ctemplates Map = ctemplates Map r . in Stream = os . Stdin r . out Stream = os . Stdout r . err Stream = os . Stderr r . brain = template . New Brain ( ) r . Err Ch = make ( chan error ) r . Done Ch = make ( chan struct { } ) r . quiescence Map = make ( map [ string ] * quiescence ) r . quiescence Ch = make ( chan * template . Template ) if * r . config . Dedup . Enabled { if r . once { log . Printf ( " " ) } else { r . dedup , err = New Dedup Manager ( r . config . Dedup , clients , r . brain , r . templates ) if err ! = nil { return err } } } return nil } 
func ( r * Runner ) diff And Update Deps ( deps Map map [ string ] dep . Dependency ) { r . dependencies Lock . Lock ( ) defer r . dependencies Lock . Unlock ( ) for key , d : = range r . dependencies { if _ , ok : = deps Map [ key ] ; ! ok { log . Printf ( " " , d ) r . watcher . Remove ( d ) r . brain . Forget ( d ) } else { log . Printf ( " " , d ) } } r . dependencies = deps Map } 
func ( r * Runner ) template Configs For ( tmpl * template . Template ) [ ] * config . Template Config { return r . ctemplates Map [ tmpl . ID ( ) ] } 
func ( r * Runner ) Template Config Mapping ( ) map [ string ] [ ] config . Template Config { m : = make ( map [ string ] [ ] config . Template Config , len ( r . ctemplates Map ) ) for id , set : = range r . ctemplates Map { ctmpls : = make ( [ ] config . Template Config , len ( set ) ) m [ id ] = ctmpls for i , ctmpl : = range set { ctmpls [ i ] = * ctmpl } } return m } 
func ( r * Runner ) all Templates Rendered ( ) bool { r . render Events Lock . RLock ( ) defer r . render Events Lock . RUnlock ( ) for _ , tmpl : = range r . templates { event , rendered : = r . render Events [ tmpl . ID ( ) ] if ! rendered { return false } } } } return true } 
func ( r * Runner ) child Env ( ) [ ] string { var m = make ( map [ string ] string ) if config . String Present ( r . config . Consul . Address ) { m [ " " ] = config . String Val ( r . config . Consul . Address ) } if config . Bool Val ( r . config . Consul . Auth . Enabled ) { m [ " " ] = r . config . Consul . Auth . String ( ) } m [ " " ] = strconv . Format Bool ( config . Bool Val ( r . config . Consul . SSL . Enabled ) ) m [ " " ] = strconv . Format Bool ( config . Bool Val ( r . config . Consul . SSL . Verify ) ) if config . String Present ( r . config . Vault . Address ) { m [ " " ] = config . String Val ( r . config . Vault . Address ) } if ! config . Bool Val ( r . config . Vault . SSL . Verify ) { m [ " " ] = " " } if config . String Present ( r . config . Vault . SSL . Cert ) { m [ " " ] = config . String Val ( r . config . Vault . SSL . Cert ) } if config . String Present ( r . config . Vault . SSL . Key ) { m [ " " ] = config . String Val ( r . config . Vault . SSL . Key ) } if config . String Present ( r . config . Vault . SSL . Ca Path ) { m [ " " ] = config . String Val ( r . config . Vault . SSL . Ca Path ) } if config . String Present ( r . config . Vault . SSL . Ca Cert ) { m [ " " ] = config . String Val ( r . config . Vault . SSL . Ca Cert ) } if config . String Present ( r . config . Vault . SSL . Server Name ) { m [ " " ] = config . String Val ( r . config . Vault . SSL . Server Name ) } } e : = make ( [ ] string , 0 , len ( m ) ) for k , v : = range m { e = append ( e , k + " " + v ) } return e } 
func ( r * Runner ) store Pid ( ) error { path : = config . String Val ( r . config . Pid File ) if path = = " " { return nil } log . Printf ( " " , path ) f , err : = os . Open File ( path , os . O _CREATE | os . O _WRONLY | os . O _TRUNC , 0 6 6 6 ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer f . Close ( ) pid : = os . Getpid ( ) _ , err = f . Write String ( fmt . Sprintf ( " " , pid ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( r * Runner ) delete Pid ( ) error { path : = config . String Val ( r . config . Pid File ) if path = = " " { return nil } log . Printf ( " " , path ) stat , err : = os . Stat ( path ) if err ! = nil { return fmt . Errorf ( " " , err ) } if stat . Is Dir ( ) { return fmt . Errorf ( " " ) } err = os . Remove ( path ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func spawn Child ( i * spawn Child Input ) ( * child . Child , error ) { p : = shellwords . New Parser ( ) p . Parse Env = true p . Parse Backtick = true args , err : = p . Parse ( i . Command ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } child , err : = child . New ( & child . New Input { Stdin : i . Stdin , Stdout : i . Stdout , Stderr : i . Stderr , Command : args [ 0 ] , Args : args [ 1 : ] , Env : i . Env , Timeout : i . Timeout , Reload Signal : i . Reload Signal , Kill Signal : i . Kill Signal , Kill Timeout : i . Kill Timeout , Splay : i . Splay , } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err : = child . Start ( ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return child , nil } 
func new Quiescence ( ch chan * template . Template , min , max time . Duration , t * template . Template ) * quiescence { return & quiescence { template : t , min : min , max : max , ch : ch , } } 
func ( q * quiescence ) tick ( ) { now : = time . Now ( ) go func ( ) { select { case < - q . timer . C : q . ch < - q . template } } ( ) q . deadline = now . Add ( q . max ) return } } else if dur : = q . deadline . Sub ( now ) ; dur > 0 { q . timer . Reset ( dur ) } } 
func find Command ( c * config . Template Config , templates [ ] * config . Template Config ) * config . Template Config { needle : = config . String Val ( c . Exec . Command ) for _ , t : = range templates { if needle = = config . String Val ( t . Exec . Command ) { return t } } return nil } 
func new Client Set ( c * config . Config ) ( * dep . Client Set , error ) { clients : = dep . New Client Set ( ) if err : = clients . Create Consul Client ( & dep . Create Consul Client Input { Address : config . String Val ( c . Consul . Address ) , Token : config . String Val ( c . Consul . Token ) , Auth Enabled : config . Bool Val ( c . Consul . Auth . Enabled ) , Auth Username : config . String Val ( c . Consul . Auth . Username ) , Auth Password : config . String Val ( c . Consul . Auth . Password ) , SSLEnabled : config . Bool Val ( c . Consul . SSL . Enabled ) , SSLVerify : config . Bool Val ( c . Consul . SSL . Verify ) , SSLCert : config . String Val ( c . Consul . SSL . Cert ) , SSLKey : config . String Val ( c . Consul . SSL . Key ) , SSLCACert : config . String Val ( c . Consul . SSL . Ca Cert ) , SSLCAPath : config . String Val ( c . Consul . SSL . Ca Path ) , Server Name : config . String Val ( c . Consul . SSL . Server Name ) , Transport Dial Keep Alive : config . Time Duration Val ( c . Consul . Transport . Dial Keep Alive ) , Transport Dial Timeout : config . Time Duration Val ( c . Consul . Transport . Dial Timeout ) , Transport Disable Keep Alives : config . Bool Val ( c . Consul . Transport . Disable Keep Alives ) , Transport Idle Conn Timeout : config . Time Duration Val ( c . Consul . Transport . Idle Conn Timeout ) , Transport Max Idle Conns : config . Int Val ( c . Consul . Transport . Max Idle Conns ) , Transport Max Idle Conns Per Host : config . Int Val ( c . Consul . Transport . Max Idle Conns Per Host ) , Transport TLSHandshake Timeout : config . Time Duration Val ( c . Consul . Transport . TLSHandshake Timeout ) , } ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err : = clients . Create Vault Client ( & dep . Create Vault Client Input { Address : config . String Val ( c . Vault . Address ) , Namespace : config . String Val ( c . Vault . Namespace ) , Token : config . String Val ( c . Vault . Token ) , Unwrap Token : config . Bool Val ( c . Vault . Unwrap Token ) , SSLEnabled : config . Bool Val ( c . Vault . SSL . Enabled ) , SSLVerify : config . Bool Val ( c . Vault . SSL . Verify ) , SSLCert : config . String Val ( c . Vault . SSL . Cert ) , SSLKey : config . String Val ( c . Vault . SSL . Key ) , SSLCACert : config . String Val ( c . Vault . SSL . Ca Cert ) , SSLCAPath : config . String Val ( c . Vault . SSL . Ca Path ) , Server Name : config . String Val ( c . Vault . SSL . Server Name ) , Transport Dial Keep Alive : config . Time Duration Val ( c . Vault . Transport . Dial Keep Alive ) , Transport Dial Timeout : config . Time Duration Val ( c . Vault . Transport . Dial Timeout ) , Transport Disable Keep Alives : config . Bool Val ( c . Vault . Transport . Disable Keep Alives ) , Transport Idle Conn Timeout : config . Time Duration Val ( c . Vault . Transport . Idle Conn Timeout ) , Transport Max Idle Conns : config . Int Val ( c . Vault . Transport . Max Idle Conns ) , Transport Max Idle Conns Per Host : config . Int Val ( c . Vault . Transport . Max Idle Conns Per Host ) , Transport TLSHandshake Timeout : config . Time Duration Val ( c . Vault . Transport . TLSHandshake Timeout ) , } ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return clients , nil } 
func new Watcher ( c * config . Config , clients * dep . Client Set , once bool ) ( * watch . Watcher , error ) { log . Printf ( " " ) w , err : = watch . New Watcher ( & watch . New Watcher Input { Clients : clients , Max Stale : config . Time Duration Val ( c . Max Stale ) , Once : once , Renew Vault : clients . Vault ( ) . Token ( ) ! = " " & & config . Bool Val ( c . Vault . Renew Token ) , Vault Agent Token File : config . String Val ( c . Vault . Vault Agent Token File ) , Retry Func Consul : watch . Retry Func ( c . Consul . Retry . Retry Func ( ) ) , if err ! = nil { return nil , errors . Wrap ( err , " " ) } return w , nil } 
func New Catalog Services Query ( s string ) ( * Catalog Services Query , error ) { if ! Catalog Services Query Re . Match String ( s ) { return nil , fmt . Errorf ( " " , s ) } m : = regexp Match ( Catalog Services Query Re , s ) return & Catalog Services Query { stop Ch : make ( chan struct { } , 1 ) , dc : m [ " " ] , } , nil } 
func ( d * Catalog Services Query ) Fetch ( clients * Client Set , opts * Query Options ) ( interface { } , * Response Metadata , error ) { select { case < - d . stop Ch : return nil , nil , Err Stopped default : } opts = opts . Merge ( & Query Options { Datacenter : d . dc , } ) log . Printf ( " " , d , & url . URL { Path : " " , Raw Query : opts . String ( ) , } ) entries , qm , err : = clients . Consul ( ) . Catalog ( ) . Services ( opts . To Consul Opts ( ) ) if err ! = nil { return nil , nil , errors . Wrap ( err , d . String ( ) ) } log . Printf ( " " , d , len ( entries ) ) var catalog Services [ ] * Catalog Snippet for name , tags : = range entries { catalog Services = append ( catalog Services , & Catalog Snippet { Name : name , Tags : Service Tags ( deep Copy And Sort Tags ( tags ) ) , } ) } sort . Stable ( By Name ( catalog Services ) ) rm : = & Response Metadata { Last Index : qm . Last Index , Last Contact : qm . Last Contact , } return catalog Services , rm , nil } 
func ( d * Catalog Services Query ) String ( ) string { if d . dc ! = " " { return fmt . Sprintf ( " " , d . dc ) } return " " } 
func Default Consul Config ( ) * Consul Config { return & Consul Config { Auth : Default Auth Config ( ) , Retry : Default Retry Config ( ) , SSL : Default SSLConfig ( ) , Transport : Default Transport Config ( ) , } } 
func ( c * Consul Config ) Copy ( ) * Consul Config { if c = = nil { return nil } var o Consul Config o . Address = c . Address if c . Auth ! = nil { o . Auth = c . Auth . Copy ( ) } if c . Retry ! = nil { o . Retry = c . Retry . Copy ( ) } if c . SSL ! = nil { o . SSL = c . SSL . Copy ( ) } o . Token = c . Token if c . Transport ! = nil { o . Transport = c . Transport . Copy ( ) } return & o } 
func ( c * Consul Config ) Merge ( o * Consul Config ) * Consul Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Address ! = nil { r . Address = o . Address } if o . Auth ! = nil { r . Auth = r . Auth . Merge ( o . Auth ) } if o . Retry ! = nil { r . Retry = r . Retry . Merge ( o . Retry ) } if o . SSL ! = nil { r . SSL = r . SSL . Merge ( o . SSL ) } if o . Token ! = nil { r . Token = o . Token } if o . Transport ! = nil { r . Transport = r . Transport . Merge ( o . Transport ) } return r } 
func ( c * Consul Config ) Finalize ( ) { if c . Address = = nil { c . Address = string From Env ( [ ] string { " " , } , " " ) } if c . Auth = = nil { c . Auth = Default Auth Config ( ) } c . Auth . Finalize ( ) if c . Retry = = nil { c . Retry = Default Retry Config ( ) } c . Retry . Finalize ( ) if c . SSL = = nil { c . SSL = Default SSLConfig ( ) } c . SSL . Finalize ( ) if c . Token = = nil { c . Token = string From Env ( [ ] string { " " , " " , } , " " ) } if c . Transport = = nil { c . Transport = Default Transport Config ( ) } c . Transport . Finalize ( ) } 
func ( c * Consul Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " , String Go String ( c . Address ) , c . Auth , c . Retry , c . SSL , String Present ( c . Token ) , c . Transport , ) } 
func String To Signal Func ( ) mapstructure . Decode Hook Func { return func ( f reflect . Type , t reflect . Type , data interface { } ) ( interface { } , error ) { if f . Kind ( ) ! = reflect . String { return data , nil } if t . String ( ) ! = " " { return data , nil } if data = = nil | | data . ( string ) = = " " { return SIGNIL , nil } return Parse ( data . ( string ) ) } } 
func ( c * Wait Config ) Copy ( ) * Wait Config { if c = = nil { return nil } var o Wait Config o . Enabled = c . Enabled o . Min = c . Min o . Max = c . Max return & o } 
func ( c * Wait Config ) Merge ( o * Wait Config ) * Wait Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Min ! = nil { r . Min = o . Min } if o . Max ! = nil { r . Max = o . Max } return r } 
func ( c * Wait Config ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( Time Duration Present ( c . Min ) ) } if c . Min = = nil { c . Min = Time Duration ( 0 * time . Second ) } if c . Max = = nil { c . Max = Time Duration ( 4 * * c . Min ) } } 
func ( c * Wait Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " + " " , Bool Go String ( c . Enabled ) , Time Duration Go String ( c . Min ) , Time Duration Go String ( c . Max ) , ) } 
func Parse Wait Config ( s string ) ( * Wait Config , error ) { s = strings . Trim Space ( s ) if len ( s ) < 1 { return nil , Err Wait String Empty } parts : = strings . Split ( s , " " ) var min , max time . Duration var err error switch len ( parts ) { case 1 : min , err = time . Parse Duration ( strings . Trim Space ( parts [ 0 ] ) ) if err ! = nil { return nil , err } max = 4 * min case 2 : min , err = time . Parse Duration ( strings . Trim Space ( parts [ 0 ] ) ) if err ! = nil { return nil , err } max , err = time . Parse Duration ( strings . Trim Space ( parts [ 1 ] ) ) if err ! = nil { return nil , err } default : return nil , Err Wait Invalid Format } if min < 0 | | max < 0 { return nil , Err Wait Negative } if max < min { return nil , Err Wait Min LTMax } var c Wait Config c . Min = Time Duration ( min ) c . Max = Time Duration ( max ) return & c , nil } 
func ( w * Wait Var ) Set ( value string ) error { wait , err : = Parse Wait Config ( value ) if err ! = nil { return err } w . Min = wait . Min w . Max = wait . Max return nil } 
func ( w * Wait Var ) String ( ) string { return fmt . Sprintf ( " " , w . Min , w . Max ) } 
func ( c * Syslog Config ) Copy ( ) * Syslog Config { if c = = nil { return nil } var o Syslog Config o . Enabled = c . Enabled o . Facility = c . Facility return & o } 
func ( c * Syslog Config ) Merge ( o * Syslog Config ) * Syslog Config { if c = = nil { if o = = nil { return nil } return o . Copy ( ) } if o = = nil { return c . Copy ( ) } r : = c . Copy ( ) if o . Enabled ! = nil { r . Enabled = o . Enabled } if o . Facility ! = nil { r . Facility = o . Facility } return r } 
func ( c * Syslog Config ) Finalize ( ) { if c . Enabled = = nil { c . Enabled = Bool ( String Present ( c . Facility ) ) } if c . Facility = = nil { c . Facility = String ( Default Syslog Facility ) } } 
func ( c * Syslog Config ) Go String ( ) string { if c = = nil { return " " } return fmt . Sprintf ( " " + " " + " " + " " , Bool Go String ( c . Enabled ) , String Go String ( c . Facility ) , ) } 
func New Vault Token Query ( token string ) ( * Vault Token Query , error ) { vault Secret : = & api . Secret { Auth : & api . Secret Auth { Client Token : token , Renewable : true , Lease Duration : 1 , } , } return & Vault Token Query { stop Ch : make ( chan struct { } , 1 ) , vault Secret : vault Secret , secret : transform Secret ( vault Secret ) , } , nil } 
func New Log Filter ( ) * logutils . Level Filter { return & logutils . Level Filter { Levels : Levels , Min Level : " " , Writer : ioutil . Discard , } } 
func Validate Level Filter ( min logutils . Log Level , filter * logutils . Level Filter ) bool { for _ , level : = range filter . Levels { if level = = min { return true } } return false } 
func datacenters Func ( b * Brain , used , missing * dep . Set ) func ( ignore . . . bool ) ( [ ] string , error ) { return func ( i . . . bool ) ( [ ] string , error ) { result : = [ ] string { } var ignore bool switch len ( i ) { case 0 : ignore = false case 1 : ignore = i [ 0 ] default : return result , fmt . Errorf ( " " + " " , len ( i ) ) } d , err : = dep . New Catalog Datacenters Query ( ignore ) if err ! = nil { return result , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value . ( [ ] string ) , nil } missing . Add ( d ) return result , nil } } 
func env Func ( env [ ] string ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { for _ , e : = range env { split : = strings . Split N ( e , " " , 2 ) k , v : = split [ 0 ] , split [ 1 ] if k = = s { return v , nil } } return os . Getenv ( s ) , nil } } 
func execute Template Func ( t * template . Template ) func ( string , . . . interface { } ) ( string , error ) { return func ( s string , data . . . interface { } ) ( string , error ) { var dot interface { } switch len ( data ) { case 0 : dot = nil case 1 : dot = data [ 0 ] default : return " " , fmt . Errorf ( " " + " " , len ( data ) + 1 ) } var b bytes . Buffer if err : = t . Execute Template ( & b , s , dot ) ; err ! = nil { return " " , err } return b . String ( ) , nil } } 
func file Func ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) = = 0 { return " " , nil } d , err : = dep . New File Query ( s ) if err ! = nil { return " " , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { if value = = nil { return " " , nil } return value . ( string ) , nil } missing . Add ( d ) return " " , nil } } 
func key Func ( b * Brain , used , missing * dep . Set ) func ( string ) ( string , error ) { return func ( s string ) ( string , error ) { if len ( s ) = = 0 { return " " , nil } d , err : = dep . New KVGet Query ( s ) if err ! = nil { return " " , err } d . Enable Blocking ( ) used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { if value = = nil { return " " , nil } return value . ( string ) , nil } missing . Add ( d ) return " " , nil } } 
func key Exists Func ( b * Brain , used , missing * dep . Set ) func ( string ) ( bool , error ) { return func ( s string ) ( bool , error ) { if len ( s ) = = 0 { return false , nil } d , err : = dep . New KVGet Query ( s ) if err ! = nil { return false , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value ! = nil , nil } missing . Add ( d ) return false , nil } } 
func node Func ( b * Brain , used , missing * dep . Set ) func ( . . . string ) ( * dep . Catalog Node , error ) { return func ( s . . . string ) ( * dep . Catalog Node , error ) { d , err : = dep . New Catalog Node Query ( strings . Join ( s , " " ) ) if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value . ( * dep . Catalog Node ) , nil } missing . Add ( d ) return nil , nil } } 
func nodes Func ( b * Brain , used , missing * dep . Set ) func ( . . . string ) ( [ ] * dep . Node , error ) { return func ( s . . . string ) ( [ ] * dep . Node , error ) { result : = [ ] * dep . Node { } d , err : = dep . New Catalog Nodes Query ( strings . Join ( s , " " ) ) if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value . ( [ ] * dep . Node ) , nil } missing . Add ( d ) return result , nil } } 
func secret Func ( b * Brain , used , missing * dep . Set ) func ( . . . string ) ( * dep . Secret , error ) { return func ( s . . . string ) ( * dep . Secret , error ) { var result * dep . Secret if len ( s ) = = 0 { return result , nil } data : = make ( map [ string ] interface { } ) for _ , str : = range rest { parts : = strings . Split N ( str , " " , 2 ) if len ( parts ) ! = 2 { return result , fmt . Errorf ( " " , str ) } k , v : = strings . Trim Space ( parts [ 0 ] ) , strings . Trim Space ( parts [ 1 ] ) data [ k ] = v } var d dep . Dependency var err error if len ( rest ) = = 0 { d , err = dep . New Vault Read Query ( path ) } else { d , err = dep . New Vault Write Query ( path , data ) } if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { result = value . ( * dep . Secret ) return result , nil } missing . Add ( d ) return result , nil } } 
func secrets Func ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] string , error ) { return func ( s string ) ( [ ] string , error ) { var result [ ] string if len ( s ) = = 0 { return result , nil } d , err : = dep . New Vault List Query ( s ) if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { result = value . ( [ ] string ) return result , nil } missing . Add ( d ) return result , nil } } 
func service Func ( b * Brain , used , missing * dep . Set ) func ( . . . string ) ( [ ] * dep . Health Service , error ) { return func ( s . . . string ) ( [ ] * dep . Health Service , error ) { result : = [ ] * dep . Health Service { } if len ( s ) = = 0 | | s [ 0 ] = = " " { return result , nil } d , err : = dep . New Health Service Query ( strings . Join ( s , " " ) ) if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value . ( [ ] * dep . Health Service ) , nil } missing . Add ( d ) return result , nil } } 
func services Func ( b * Brain , used , missing * dep . Set ) func ( . . . string ) ( [ ] * dep . Catalog Snippet , error ) { return func ( s . . . string ) ( [ ] * dep . Catalog Snippet , error ) { result : = [ ] * dep . Catalog Snippet { } d , err : = dep . New Catalog Services Query ( strings . Join ( s , " " ) ) if err ! = nil { return nil , err } used . Add ( d ) if value , ok : = b . Recall ( d ) ; ok { return value . ( [ ] * dep . Catalog Snippet ) , nil } missing . Add ( d ) return result , nil } } 
func tree Func ( b * Brain , used , missing * dep . Set ) func ( string ) ( [ ] * dep . Key Pair , error ) { return func ( s string ) ( [ ] * dep . Key Pair , error ) { result : = [ ] * dep . Key Pair { } if len ( s ) = = 0 { return result , nil } d , err : = dep . New KVList Query ( s ) if err ! = nil { return result , err } used . Add ( d ) if parts [ len ( parts ) - 1 ] ! = " " { result = append ( result , pair ) } } return result , nil } missing . Add ( d ) return result , nil } } 
func base 6 4Decode ( s string ) ( string , error ) { v , err : = base 6 4 . Std Encoding . Decode String ( s ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( v ) , nil } 
func base 6 4Encode ( s string ) ( string , error ) { return base 6 4 . Std Encoding . Encode To String ( [ ] byte ( s ) ) , nil } 
func base 6 4URLDecode ( s string ) ( string , error ) { v , err : = base 6 4 . URLEncoding . Decode String ( s ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( v ) , nil } 
func base 6 4URLEncode ( s string ) ( string , error ) { return base 6 4 . URLEncoding . Encode To String ( [ ] byte ( s ) ) , nil } 
func by Key ( pairs [ ] * dep . Key Pair ) ( map [ string ] map [ string ] * dep . Key Pair , error ) { m : = make ( map [ string ] map [ string ] * dep . Key Pair ) for _ , pair : = range pairs { parts : = strings . Split ( pair . Key , " " ) top : = parts [ 0 ] key : = strings . Join ( parts [ 1 : ] , " " ) if key = = " " { } if _ , ok : = m [ top ] ; ! ok { m [ top ] = make ( map [ string ] * dep . Key Pair ) } new Pair : = * pair new Pair . Key = key m [ top ] [ key ] = & new Pair } return m , nil } 
func by Tag ( in interface { } ) ( map [ string ] [ ] interface { } , error ) { m : = make ( map [ string ] [ ] interface { } ) switch typed : = in . ( type ) { case nil : case [ ] * dep . Catalog Snippet : for _ , s : = range typed { for _ , t : = range s . Tags { m [ t ] = append ( m [ t ] , s ) } } case [ ] * dep . Catalog Service : for _ , s : = range typed { for _ , t : = range s . Service Tags { m [ t ] = append ( m [ t ] , s ) } } case [ ] * dep . Health Service : for _ , s : = range typed { for _ , t : = range s . Tags { m [ t ] = append ( m [ t ] , s ) } } default : return nil , fmt . Errorf ( " " , in ) } return m , nil } 
func contains Some Func ( ret True , invert bool ) func ( [ ] interface { } , interface { } ) ( bool , error ) { return func ( v [ ] interface { } , l interface { } ) ( bool , error ) { for i : = 0 ; i < len ( v ) ; i + + { if ok , _ : = in ( l , v [ i ] ) ; ok ! = invert { return ! ret True , nil } } return ret True , nil } } 
func explode ( pairs [ ] * dep . Key Pair ) ( map [ string ] interface { } , error ) { m : = make ( map [ string ] interface { } ) for _ , pair : = range pairs { if err : = explode Helper ( m , pair . Key , pair . Value , pair . Key ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } return m , nil } 
func explode Helper ( m map [ string ] interface { } , k , v , p string ) error { if strings . Contains ( k , " " ) { parts : = strings . Split ( k , " " ) top : = parts [ 0 ] key : = strings . Join ( parts [ 1 : ] , " " ) if _ , ok : = m [ top ] ; ! ok { m [ top ] = make ( map [ string ] interface { } ) } nest , ok : = m [ top ] . ( map [ string ] interface { } ) if ! ok { return fmt . Errorf ( " " , p , top , m [ top ] ) } return explode Helper ( nest , key , v , k ) } if k ! = " " { m [ k ] = v } return nil } 
func in ( l , v interface { } ) ( bool , error ) { lv : = reflect . Value Of ( l ) vv : = reflect . Value Of ( v ) switch lv . Kind ( ) { case reflect . Array , reflect . Slice : if reflect . Type Of ( l ) . Elem ( ) . Kind ( ) = = reflect . Interface { interface Slice = l . ( [ ] interface { } ) } for i : = 0 ; i < lv . Len ( ) ; i + + { var lvv reflect . Value if interface Slice ! = nil { lvv = reflect . Value Of ( interface Slice [ i ] ) } else { lvv = lv . Index ( i ) } switch lvv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : switch vv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : if vv . Int ( ) = = lvv . Int ( ) { return true , nil } } case reflect . Float 3 2 , reflect . Float 6 4 : switch vv . Kind ( ) { case reflect . Float 3 2 , reflect . Float 6 4 : if vv . Float ( ) = = lvv . Float ( ) { return true , nil } } case reflect . String : if vv . Type ( ) = = lvv . Type ( ) & & vv . String ( ) = = lvv . String ( ) { return true , nil } } } case reflect . String : if vv . Type ( ) = = lv . Type ( ) & & strings . Contains ( lv . String ( ) , vv . String ( ) ) { return true , nil } } return false , nil } 
func indent ( spaces int , s string ) ( string , error ) { if spaces < 0 { return " " , fmt . Errorf ( " " ) } var output , prefix [ ] byte var sp bool var size int prefix = [ ] byte ( strings . Repeat ( " " , spaces ) ) sp = true for _ , c : = range [ ] byte ( s ) { if sp & & c ! = ' \n ' { output = append ( output , prefix . . . ) size + = spaces } output = append ( output , c ) sp = c = = ' \n ' size + + } return string ( output [ : size ] ) , nil } 
func loop ( ints . . . int 6 4 ) ( < - chan int 6 4 , error ) { var start , stop int 6 4 switch len ( ints ) { case 1 : start , stop = 0 , ints [ 0 ] case 2 : start , stop = ints [ 0 ] , ints [ 1 ] default : return nil , fmt . Errorf ( " " + " " , len ( ints ) ) } ch : = make ( chan int 6 4 ) go func ( ) { for i : = start ; i < stop ; i + + { ch < - i } close ( ch ) } ( ) return ch , nil } 
func join ( sep string , a [ ] string ) ( string , error ) { return strings . Join ( a , sep ) , nil } 
func parse Bool ( s string ) ( bool , error ) { if s = = " " { return false , nil } result , err : = strconv . Parse Bool ( s ) if err ! = nil { return false , errors . Wrap ( err , " " ) } return result , nil } 
func parse Float ( s string ) ( float 6 4 , error ) { if s = = " " { return 0 . 0 , nil } result , err : = strconv . Parse Float ( s , 1 0 ) if err ! = nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func parse Int ( s string ) ( int 6 4 , error ) { if s = = " " { return 0 , nil } result , err : = strconv . Parse Int ( s , 1 0 , 6 4 ) if err ! = nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func parse JSON ( s string ) ( interface { } , error ) { if s = = " " { return map [ string ] interface { } { } , nil } var data interface { } if err : = json . Unmarshal ( [ ] byte ( s ) , & data ) ; err ! = nil { return nil , err } return data , nil } 
func parse Uint ( s string ) ( uint 6 4 , error ) { if s = = " " { return 0 , nil } result , err : = strconv . Parse Uint ( s , 1 0 , 6 4 ) if err ! = nil { return 0 , errors . Wrap ( err , " " ) } return result , nil } 
func plugin ( name string , args . . . string ) ( string , error ) { if name = = " " { return " " , nil } stdout , stderr : = new ( bytes . Buffer ) , new ( bytes . Buffer ) for _ , arg : = range args { if v : = strings . Trim Space ( arg ) ; v ! = " " { jsons = append ( jsons , v ) } } cmd : = exec . Command ( name , jsons . . . ) cmd . Stdout = stdout cmd . Stderr = stderr if err : = cmd . Start ( ) ; err ! = nil { return " " , fmt . Errorf ( " \n \n \n \n \n \n \n \n " , name , err , stdout . Bytes ( ) , stderr . Bytes ( ) ) } done : = make ( chan error , 1 ) go func ( ) { done < - cmd . Wait ( ) } ( ) select { case < - time . After ( 3 0 * time . Second ) : if cmd . Process ! = nil { if err : = cmd . Process . Kill ( ) ; err ! = nil { return " " , fmt . Errorf ( " " , name ) } } < - done return " " , fmt . Errorf ( " " , name ) case err : = < - done : if err ! = nil { return " " , fmt . Errorf ( " \n \n \n \n \n \n \n \n " , name , err , stdout . Bytes ( ) , stderr . Bytes ( ) ) } } return strings . Trim Space ( stdout . String ( ) ) , nil } 
func replace All ( f , t , s string ) ( string , error ) { return strings . Replace ( s , f , t , - 1 ) , nil } 
func regex Replace All ( re , pl , s string ) ( string , error ) { compiled , err : = regexp . Compile ( re ) if err ! = nil { return " " , err } return compiled . Replace All String ( s , pl ) , nil } 
func regex Match ( re , s string ) ( bool , error ) { compiled , err : = regexp . Compile ( re ) if err ! = nil { return false , err } return compiled . Match String ( s ) , nil } 
func split ( sep , s string ) ( [ ] string , error ) { s = strings . Trim Space ( s ) if s = = " " { return [ ] string { } , nil } return strings . Split ( s , sep ) , nil } 
func timestamp ( s . . . string ) ( string , error ) { switch len ( s ) { case 0 : return now ( ) . Format ( time . RFC 3 3 3 9 ) , nil case 1 : if s [ 0 ] = = " " { return strconv . Format Int ( now ( ) . Unix ( ) , 1 0 ) , nil } return now ( ) . Format ( s [ 0 ] ) , nil default : return " " , fmt . Errorf ( " " + " " , len ( s ) ) } } 
func to JSON ( i interface { } ) ( string , error ) { result , err : = json . Marshal ( i ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . Trim Space ( result ) ) , err } 
func to JSONPretty ( m map [ string ] interface { } ) ( string , error ) { result , err : = json . Marshal Indent ( m , " " , " " ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . Trim Space ( result ) ) , err } 
func to YAML ( m map [ string ] interface { } ) ( string , error ) { result , err : = yaml . Marshal ( m ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . Trim Space ( result ) ) , nil } 
func to TOML ( m map [ string ] interface { } ) ( string , error ) { buf : = bytes . New Buffer ( [ ] byte { } ) enc : = toml . New Encoder ( buf ) if err : = enc . Encode ( m ) ; err ! = nil { return " " , errors . Wrap ( err , " " ) } result , err : = ioutil . Read All ( buf ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } return string ( bytes . Trim Space ( result ) ) , nil } 
func add ( b , a interface { } ) ( interface { } , error ) { av : = reflect . Value Of ( a ) bv : = reflect . Value Of ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : switch bv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return av . Int ( ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return av . Int ( ) + int 6 4 ( bv . Uint ( ) ) , nil case reflect . Float 3 2 , reflect . Float 6 4 : return float 6 4 ( av . Int ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : switch bv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return int 6 4 ( av . Uint ( ) ) + bv . Int ( ) , nil case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return av . Uint ( ) + bv . Uint ( ) , nil case reflect . Float 3 2 , reflect . Float 6 4 : return float 6 4 ( av . Uint ( ) ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Float 3 2 , reflect . Float 6 4 : switch bv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return av . Float ( ) + float 6 4 ( bv . Int ( ) ) , nil case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return av . Float ( ) + float 6 4 ( bv . Uint ( ) ) , nil case reflect . Float 3 2 , reflect . Float 6 4 : return av . Float ( ) + bv . Float ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } default : return nil , fmt . Errorf ( " " , av , a ) } } 
func modulo ( b , a interface { } ) ( interface { } , error ) { av : = reflect . Value Of ( a ) bv : = reflect . Value Of ( b ) switch av . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : switch bv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return av . Int ( ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return av . Int ( ) % int 6 4 ( bv . Uint ( ) ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : switch bv . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return int 6 4 ( av . Uint ( ) ) % bv . Int ( ) , nil case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return av . Uint ( ) % bv . Uint ( ) , nil default : return nil , fmt . Errorf ( " " , bv , b ) } default : return nil , fmt . Errorf ( " " , av , a ) } } 
func ( item Item ) Expired ( ) bool { if item . Expiration = = 0 { return false } return time . Now ( ) . Unix Nano ( ) > item . Expiration } 
func ( c * cache ) Set ( k string , x interface { } , d time . Duration ) { if d = = Default Expiration { d = c . default Expiration } if d > 0 { e = time . Now ( ) . Add ( d ) . Unix Nano ( ) } c . mu . Lock ( ) c . items [ k ] = Item { Object : x , Expiration : e , } } 
func ( c * cache ) Set Default ( k string , x interface { } ) { c . Set ( k , x , Default Expiration ) } 
func ( c * cache ) Add ( k string , x interface { } , d time . Duration ) error { c . mu . Lock ( ) _ , found : = c . get ( k ) if found { c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . set ( k , x , d ) c . mu . Unlock ( ) return nil } 
func ( c * cache ) Get ( k string ) ( interface { } , bool ) { c . mu . RLock ( ) if ! found { c . mu . RUnlock ( ) return nil , false } if item . Expiration > 0 { if time . Now ( ) . Unix Nano ( ) > item . Expiration { c . mu . RUnlock ( ) return nil , false } } c . mu . RUnlock ( ) return item . Object , true } 
func ( c * cache ) Get With Expiration ( k string ) ( interface { } , time . Time , bool ) { c . mu . RLock ( ) if ! found { c . mu . RUnlock ( ) return nil , time . Time { } , false } if item . Expiration > 0 { if time . Now ( ) . Unix Nano ( ) > item . Expiration { c . mu . RUnlock ( ) return nil , time . Time { } , false } return item . Object , time . Unix ( 0 , item . Expiration ) , true } return item . Object , time . Time { } , true } 
func ( c * cache ) Increment Int ( k string , n int ) ( int , error ) { c . mu . Lock ( ) v , found : = c . items [ k ] if ! found | | v . Expired ( ) { c . mu . Unlock ( ) return 0 , fmt . Errorf ( " " , k ) } rv , ok : = v . Object . ( int ) if ! ok { c . mu . Unlock ( ) return 0 , fmt . Errorf ( " " , k ) } nv : = rv + n v . Object = nv c . items [ k ] = v c . mu . Unlock ( ) return nv , nil } 
func ( c * cache ) Decrement ( k string , n int 6 4 ) error { v , found : = c . items [ k ] if ! found | | v . Expired ( ) { c . mu . Unlock ( ) return fmt . Errorf ( " " ) } switch v . Object . ( type ) { case int : v . Object = v . Object . ( int ) - int ( n ) case int 8 : v . Object = v . Object . ( int 8 ) - int 8 ( n ) case int 1 6 : v . Object = v . Object . ( int 1 6 ) - int 1 6 ( n ) case int 3 2 : v . Object = v . Object . ( int 3 2 ) - int 3 2 ( n ) case int 6 4 : v . Object = v . Object . ( int 6 4 ) - n case uint : v . Object = v . Object . ( uint ) - uint ( n ) case uintptr : v . Object = v . Object . ( uintptr ) - uintptr ( n ) case uint 8 : v . Object = v . Object . ( uint 8 ) - uint 8 ( n ) case uint 1 6 : v . Object = v . Object . ( uint 1 6 ) - uint 1 6 ( n ) case uint 3 2 : v . Object = v . Object . ( uint 3 2 ) - uint 3 2 ( n ) case uint 6 4 : v . Object = v . Object . ( uint 6 4 ) - uint 6 4 ( n ) case float 3 2 : v . Object = v . Object . ( float 3 2 ) - float 3 2 ( n ) case float 6 4 : v . Object = v . Object . ( float 6 4 ) - float 6 4 ( n ) default : c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . items [ k ] = v c . mu . Unlock ( ) return nil } 
func ( c * cache ) Decrement Float ( k string , n float 6 4 ) error { c . mu . Lock ( ) v , found : = c . items [ k ] if ! found | | v . Expired ( ) { c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } switch v . Object . ( type ) { case float 3 2 : v . Object = v . Object . ( float 3 2 ) - float 3 2 ( n ) case float 6 4 : v . Object = v . Object . ( float 6 4 ) - n default : c . mu . Unlock ( ) return fmt . Errorf ( " " , k ) } c . items [ k ] = v c . mu . Unlock ( ) return nil } 
func ( c * cache ) Delete ( k string ) { c . mu . Lock ( ) v , evicted : = c . delete ( k ) c . mu . Unlock ( ) if evicted { c . on Evicted ( k , v ) } } 
func ( c * cache ) Delete Expired ( ) { var evicted Items [ ] key And Value now : = time . Now ( ) . Unix Nano ( ) c . mu . Lock ( ) for k , v : = range c . items { if evicted { evicted Items = append ( evicted Items , key And Value { k , ov } ) } } } c . mu . Unlock ( ) for _ , v : = range evicted Items { c . on Evicted ( v . key , v . value ) } } 
func ( c * cache ) On Evicted ( f func ( string , interface { } ) ) { c . mu . Lock ( ) c . on Evicted = f c . mu . Unlock ( ) } 
func ( c * cache ) Save ( w io . Writer ) ( err error ) { enc : = gob . New Encoder ( w ) defer func ( ) { if x : = recover ( ) ; x ! = nil { err = fmt . Errorf ( " " ) } } ( ) c . mu . RLock ( ) defer c . mu . RUnlock ( ) for _ , v : = range c . items { gob . Register ( v . Object ) } err = enc . Encode ( & c . items ) return } 
func ( c * cache ) Save File ( fname string ) error { fp , err : = os . Create ( fname ) if err ! = nil { return err } err = c . Save ( fp ) if err ! = nil { fp . Close ( ) return err } return fp . Close ( ) } 
func ( c * cache ) Load ( r io . Reader ) error { dec : = gob . New Decoder ( r ) items : = map [ string ] Item { } err : = dec . Decode ( & items ) if err = = nil { c . mu . Lock ( ) defer c . mu . Unlock ( ) for k , v : = range items { ov , found : = c . items [ k ] if ! found | | ov . Expired ( ) { c . items [ k ] = v } } } return err } 
func ( c * cache ) Load File ( fname string ) error { fp , err : = os . Open ( fname ) if err ! = nil { return err } err = c . Load ( fp ) if err ! = nil { fp . Close ( ) return err } return fp . Close ( ) } 
func ( c * cache ) Items ( ) map [ string ] Item { c . mu . RLock ( ) defer c . mu . RUnlock ( ) m : = make ( map [ string ] Item , len ( c . items ) ) now : = time . Now ( ) . Unix Nano ( ) for k , v : = range c . items { } } m [ k ] = v } return m } 
func ( c * cache ) Item Count ( ) int { c . mu . RLock ( ) n : = len ( c . items ) c . mu . RUnlock ( ) return n } 
func ( c * cache ) Flush ( ) { c . mu . Lock ( ) c . items = map [ string ] Item { } c . mu . Unlock ( ) } 
func New ( default Expiration , cleanup Interval time . Duration ) * Cache { items : = make ( map [ string ] Item ) return new Cache With Janitor ( default Expiration , cleanup Interval , items ) } 
func New From ( default Expiration , cleanup Interval time . Duration , items map [ string ] Item ) * Cache { return new Cache With Janitor ( default Expiration , cleanup Interval , items ) } 
func djb 3 3 ( seed uint 3 2 , k string ) uint 3 2 { var ( l = uint 3 2 ( len ( k ) ) d = 5 3 8 1 + seed + l i = uint 3 2 ( 0 ) ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 1 ] ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 2 ] ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 3 ] ) i + = 4 } } switch l - i { case 1 : case 2 : d = ( d * 3 3 ) ^ uint 3 2 ( k [ i ] ) case 3 : d = ( d * 3 3 ) ^ uint 3 2 ( k [ i ] ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 1 ] ) case 4 : d = ( d * 3 3 ) ^ uint 3 2 ( k [ i ] ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 1 ] ) d = ( d * 3 3 ) ^ uint 3 2 ( k [ i + 2 ] ) } return d ^ ( d > > 1 6 ) } 
func ( sc * sharded Cache ) Items ( ) [ ] map [ string ] Item { res : = make ( [ ] map [ string ] Item , len ( sc . cs ) ) for i , v : = range sc . cs { res [ i ] = v . Items ( ) } return res } 
func ( Net Link Client ) Link By Name ( name string ) ( netlink . Link , error ) { return netlink . Link By Name ( name ) } 
func New Mock Task Engine ( ctrl * gomock . Controller ) * Mock Task Engine { mock : = & Mock Task Engine { ctrl : ctrl } mock . recorder = & Mock Task Engine Mock Recorder { mock } return mock } 
func ( m * Mock Task Engine ) Add Task ( arg 0 * task . Task ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Task Engine Mock Recorder ) Add Task ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Engine ) ( nil ) . Add Task ) , arg 0 ) } 
func ( m * Mock Task Engine ) Get Task By Arn ( arg 0 string ) ( * task . Task , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * task . Task ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine ) Init ( arg 0 context . Context ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Task Engine ) List Tasks ( ) ( [ ] * task . Task , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] * task . Task ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine ) Marshal JSON ( ) ( [ ] byte , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] byte ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine ) Must Init ( arg 0 context . Context ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine ) Set Saver ( arg 0 statemanager . Saver ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine ) State Change Events ( ) chan statechange . Event { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( chan statechange . Event ) return ret 0 } 
func ( m * Mock Task Engine ) Version ( ) ( string , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Task Engine Mock Recorder ) Version ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Engine ) ( nil ) . Version ) ) } 
func New Mock Image Manager ( ctrl * gomock . Controller ) * Mock Image Manager { mock : = & Mock Image Manager { ctrl : ctrl } mock . recorder = & Mock Image Manager Mock Recorder { mock } return mock } 
func ( m * Mock Image Manager ) Add All Image States ( arg 0 [ ] * image . Image State ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Image Manager Mock Recorder ) Add All Image States ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Image Manager ) ( nil ) . Add All Image States ) , arg 0 ) } 
func ( m * Mock Image Manager ) Get Image State From Image Name ( arg 0 string ) ( * image . Image State , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * image . Image State ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Image Manager ) Record Container Reference ( arg 0 * container . Container ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Image Manager ) Set Saver ( arg 0 statemanager . Saver ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Image Manager ) Start Image Cleanup Process ( arg 0 context . Context ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func New EC 2Metadata Client ( client Http Client ) EC 2Metadata Client { if client = = nil { return & ec 2Metadata Client Impl { client : ec 2metadata . New ( session . New ( ) , aws . New Config ( ) . With Max Retries ( metadata Retries ) ) , } } else { return & ec 2Metadata Client Impl { client : client } } } 
func ( c * ec 2Metadata Client Impl ) Default Credentials ( ) ( * Role Credentials , error ) { security Credential , err : = c . client . Get Metadata ( Security Crednetials Resource ) if err ! = nil { return nil , err } security Credential List : = strings . Split ( strings . Trim Space ( security Credential ) , " \n " ) if len ( security Credential List ) = = 0 { return nil , errors . New ( " " ) } default Credential Name : = security Credential List [ 0 ] default Credential Str , err : = c . client . Get Metadata ( Security Crednetials Resource + default Credential Name ) if err ! = nil { return nil , err } var credential Role Credentials err = json . Unmarshal ( [ ] byte ( default Credential Str ) , & credential ) if err ! = nil { return nil , err } return & credential , nil } 
func ( c * ec 2Metadata Client Impl ) Get Dynamic Data ( path string ) ( string , error ) { return c . client . Get Dynamic Data ( path ) } 
func ( c * ec 2Metadata Client Impl ) Get Metadata ( path string ) ( string , error ) { return c . client . Get Metadata ( path ) } 
func ( c * ec 2Metadata Client Impl ) VPCID ( mac string ) ( string , error ) { return c . client . Get Metadata ( fmt . Sprintf ( VPCIDResource Format , mac ) ) } 
func ( c * ec 2Metadata Client Impl ) Subnet ID ( mac string ) ( string , error ) { return c . client . Get Metadata ( fmt . Sprintf ( Subnet IDResource Format , mac ) ) } 
func new Refresh Credentials Handler ( ctx context . Context , cluster string , container Instance Arn string , acs Client wsclient . Client Server , credentials Manager credentials . Manager , task Engine engine . Task Engine ) refresh Credentials Handler { return refresh Credentials Handler { message Buffer : make ( chan * ecsacs . IAMRole Credentials Message ) , ack Request : make ( chan * ecsacs . IAMRole Credentials Ack Request ) , ctx : derived Context , cancel : cancel , cluster : aws . String ( cluster ) , container Instance : aws . String ( container Instance Arn ) , acs Client : acs Client , credentials Manager : credentials Manager , task Engine : task Engine , } } 
func ( refresh Handler * refresh Credentials Handler ) handler Func ( ) func ( message * ecsacs . IAMRole Credentials Message ) { } } 
func ( refresh Handler * refresh Credentials Handler ) send Acks ( ) { for { select { case ack : = < - refresh Handler . ack Request : refresh Handler . ack Message ( ack ) case < - refresh Handler . ctx . Done ( ) : return } } } 
func ( refresh Handler * refresh Credentials Handler ) ack Message ( ack * ecsacs . IAMRole Credentials Ack Request ) { err : = refresh Handler . acs Client . Make Request ( ack ) if err ! = nil { seelog . Warnf ( " " , aws . String Value ( ack . Message Id ) , err ) } seelog . Debugf ( " " , ack . String ( ) ) } 
func ( refresh Handler * refresh Credentials Handler ) handle Messages ( ) { for { select { case message : = < - refresh Handler . message Buffer : refresh Handler . handle Single Message ( message ) case < - refresh Handler . ctx . Done ( ) : return } } } 
func ( refresh Handler * refresh Credentials Handler ) handle Single Message ( message * ecsacs . IAMRole Credentials Message ) error { if err ! = nil { seelog . Errorf ( " " , err ) return err } task Arn : = aws . String Value ( message . Task Arn ) message Id : = aws . String Value ( message . Message Id ) task , ok : = refresh Handler . task Engine . Get Task By Arn ( task Arn ) if ! ok { seelog . Errorf ( " " , task Arn , message Id ) return fmt . Errorf ( " " , task Arn ) } role Type : = aws . String Value ( message . Role Type ) if ! valid Role Type ( role Type ) { seelog . Errorf ( " " , role Type , task Arn , message Id ) } else { err = refresh Handler . credentials Manager . Set Task Credentials ( & ( credentials . Task IAMRole Credentials { ARN : task Arn , IAMRole Credentials : credentials . IAMRole Credentials From ACS ( message . Role Credentials , role Type ) , } ) ) if err ! = nil { seelog . Errorf ( " " , err , message Id ) return fmt . Errorf ( " " , err ) } if role Type = = credentials . Application Role Type { task . Set Credentials ID ( aws . String Value ( message . Role Credentials . Credentials Id ) ) } if role Type = = credentials . Execution Role Type { task . Set Execution Role Credentials ID ( aws . String Value ( message . Role Credentials . Credentials Id ) ) } } go func ( ) { response : = & ecsacs . IAMRole Credentials Ack Request { Expiration : message . Role Credentials . Expiration , Message Id : message . Message Id , Credentials Id : message . Role Credentials . Credentials Id , } refresh Handler . ack Request < - response } ( ) return nil } 
func validate IAMRole Credentials Message ( message * ecsacs . IAMRole Credentials Message ) error { if message = = nil { return fmt . Errorf ( " " ) } message Id : = aws . String Value ( message . Message Id ) if message Id = = " " { return fmt . Errorf ( " " ) } if aws . String Value ( message . Task Arn ) = = " " { return fmt . Errorf ( " " ) } if message . Role Credentials = = nil { return fmt . Errorf ( " " , message Id ) } if aws . String Value ( message . Role Credentials . Credentials Id ) = = " " { return fmt . Errorf ( " " , message Id ) } return nil } 
func valid Role Type ( role Type string ) bool { switch role Type { case credentials . Application Role Type : return true case credentials . Execution Role Type : return true default : return false } } 
func ( ae * acs Error ) New Error ( err interface { } ) * wsclient . WSError { return & wsclient . WSError { Err Obj : err , Type : err Type , WSUnretriable Errors : & ACSUnretriable Errors { } } } 
func new Payload Request Handler ( ctx context . Context , task Engine engine . Task Engine , ecs Client api . ECSClient , cluster string , container Instance Arn string , acs Client wsclient . Client Server , saver statemanager . Saver , refresh Handler refresh Credentials Handler , credentials Manager credentials . Manager , task Handler * eventhandler . Task Handler ) payload Request Handler { return payload Request Handler { message Buffer : make ( chan * ecsacs . Payload Message , payload Message Buffer Size ) , ack Request : make ( chan string , payload Message Buffer Size ) , task Engine : task Engine , ecs Client : ecs Client , saver : saver , task Handler : task Handler , ctx : derived Context , cancel : cancel , cluster : cluster , container Instance Arn : container Instance Arn , acs Client : acs Client , refresh Handler : refresh Handler , credentials Manager : credentials Manager , } } 
func ( payload Handler * payload Request Handler ) handler Func ( ) func ( payload * ecsacs . Payload Message ) { } } 
func ( payload Handler * payload Request Handler ) send Acks ( ) { for { select { case mid : = < - payload Handler . ack Request : payload Handler . ack Message Id ( mid ) case < - payload Handler . ctx . Done ( ) : return } } } 
func ( payload Handler * payload Request Handler ) ack Message Id ( message ID string ) { seelog . Debugf ( " " , message ID ) err : = payload Handler . acs Client . Make Request ( & ecsacs . Ack Request { Cluster : aws . String ( payload Handler . cluster ) , Container Instance : aws . String ( payload Handler . container Instance Arn ) , Message Id : aws . String ( message ID ) , } ) if err ! = nil { seelog . Warnf ( " " , message ID , err ) } } 
func ( payload Handler * payload Request Handler ) handle Messages ( ) { for { select { case payload : = < - payload Handler . message Buffer : payload Handler . handle Single Message ( payload ) case < - payload Handler . ctx . Done ( ) : return } } } 
func ( payload Handler * payload Request Handler ) handle Single Message ( payload * ecsacs . Payload Message ) error { if aws . String Value ( payload . Message Id ) = = " " { seelog . Criticalf ( " " ) return fmt . Errorf ( " " ) } seelog . Debugf ( " " , aws . String Value ( payload . Message Id ) ) credentials Acks , all Tasks Handled : = payload Handler . add Payload Tasks ( payload ) if err ! = nil { seelog . Errorf ( " " , err , aws . String Value ( payload . Message Id ) ) } if ! all Tasks Handled { return fmt . Errorf ( " " ) } go func ( ) { } payload Handler . ack Request < - * payload . Message Id } ( ) return nil } 
func ( payload Handler * payload Request Handler ) add Payload Tasks ( payload * ecsacs . Payload Message ) ( [ ] * ecsacs . IAMRole Credentials Ack Request , bool ) { valid Tasks : = make ( [ ] * apitask . Task , 0 , len ( payload . Tasks ) ) for _ , task : = range payload . Tasks { if task = = nil { seelog . Criticalf ( " " , aws . String Value ( payload . Message Id ) ) all Tasks OK = false continue } api Task , err : = apitask . Task From ACS ( task , payload ) if err ! = nil { payload Handler . handle Unrecognized Task ( task , err , payload ) all Tasks OK = false continue } if task . Role Credentials ! = nil { err = payload Handler . credentials Manager . Set Task Credentials ( & ( credentials . Task IAMRole Credentials { ARN : aws . String Value ( task . Arn ) , IAMRole Credentials : task IAMRole Credentials , } ) ) if err ! = nil { payload Handler . handle Unrecognized Task ( task , err , payload ) all Tasks OK = false continue } api Task . Set Credentials ID ( task IAMRole Credentials . Credentials ID ) } if err ! = nil { payload Handler . handle Unrecognized Task ( task , err , payload ) all Tasks OK = false continue } api Task . Set Task ENI ( eni ) } if err ! = nil { payload Handler . handle Unrecognized Task ( task , err , payload ) all Tasks OK = false continue } api Task . Set App Mesh ( appmesh ) } if task . Execution Role Credentials ! = nil { err = payload Handler . credentials Manager . Set Task Credentials ( & ( credentials . Task IAMRole Credentials { ARN : aws . String Value ( task . Arn ) , IAMRole Credentials : task Execution IAMRole Credentials , } ) ) if err ! = nil { payload Handler . handle Unrecognized Task ( task , err , payload ) all Tasks OK = false continue } api Task . Set Execution Role Credentials ID ( task Execution IAMRole Credentials . Credentials ID ) } valid Tasks = append ( valid Tasks , api Task ) } new Tasks Credentials Acks , new Tasks Added OK : = payload Handler . add Tasks ( payload , valid Tasks , is Task Status Stopped ) if ! stopped Tasks Added OK | | ! new Tasks Added OK { all Tasks OK = false } credentials Acks = append ( stopped Tasks Credentials Acks , new Tasks Credentials Acks . . . ) return credentials Acks , all Tasks OK } 
func ( payload Handler * payload Request Handler ) add Tasks ( payload * ecsacs . Payload Message , tasks [ ] * apitask . Task , skip Add Task skip Add Task Comparator Func ) ( [ ] * ecsacs . IAMRole Credentials Ack Request , bool ) { all Tasks OK : = true var credentials Acks [ ] * ecsacs . IAMRole Credentials Ack Request for _ , task : = range tasks { if skip Add Task ( task . Get Desired Status ( ) ) { continue } payload Handler . task Engine . Add Task ( task ) ack Credentials : = func ( id string , description string ) { ack , err : = payload Handler . ack Credentials ( payload . Message Id , id ) if err ! = nil { all Tasks OK = false seelog . Errorf ( " " , description , task . String ( ) , err ) return } credentials Acks = append ( credentials Acks , ack ) } if task Credentials ID ! = " " { ack Credentials ( task Credentials ID , " " ) } task Execution Credentials ID : = task . Get Execution Credentials ID ( ) if task Execution Credentials ID ! = " " { ack Credentials ( task Execution Credentials ID , " " ) } } return credentials Acks , all Tasks OK } 
func ( payload Handler * payload Request Handler ) handle Unrecognized Task ( task * ecsacs . Task , err error , payload * ecsacs . Payload Message ) { seelog . Warnf ( " " , aws . String Value ( payload . Message Id ) , aws . String Value ( task . Arn ) , err ) if aws . String Value ( task . Arn ) = = " " { seelog . Criticalf ( " " , aws . String Value ( payload . Message Id ) ) return } payload Handler . task Handler . Add State Change Event ( task Event , payload Handler . ecs Client ) } 
func Build Type Decoder ( recognized Types [ ] interface { } ) Type Decoder { type Mappings : = make ( map [ string ] reflect . Type ) for _ , recognized Type : = range recognized Types { type Mappings [ reflect . Type Of ( recognized Type ) . Name ( ) ] = reflect . Type Of ( recognized Type ) } return & Type Decoder Impl { type Mappings : type Mappings } } 
func v 2Handlers Setup ( mux Router * mux . Router , state dockerstate . Task Engine State , ecs Client api . ECSClient , stats Engine stats . Engine , cluster string , credentials Manager credentials . Manager , audit Logger audit . Audit Logger , availability Zone string , container Instance Arn string ) { mux Router . Handle Func ( v 2 . Credentials Path , v 2 . Credentials Handler ( credentials Manager , audit Logger ) ) mux Router . Handle Func ( v 2 . Container Metadata Path , v 2 . Task Container Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , false ) ) mux Router . Handle Func ( v 2 . Task Metadata Path , v 2 . Task Container Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , false ) ) mux Router . Handle Func ( v 2 . Task With Tags Metadata Path , v 2 . Task Container Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , true ) ) mux Router . Handle Func ( v 2 . Task Metadata Path With Slash , v 2 . Task Container Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , false ) ) mux Router . Handle Func ( v 2 . Task With Tags Metadata Path With Slash , v 2 . Task Container Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , true ) ) mux Router . Handle Func ( v 2 . Container Stats Path , v 2 . Task Container Stats Handler ( state , stats Engine ) ) mux Router . Handle Func ( v 2 . Task Stats Path , v 2 . Task Container Stats Handler ( state , stats Engine ) ) mux Router . Handle Func ( v 2 . Task Stats Path With Slash , v 2 . Task Container Stats Handler ( state , stats Engine ) ) } 
func v 3Handlers Setup ( mux Router * mux . Router , state dockerstate . Task Engine State , ecs Client api . ECSClient , stats Engine stats . Engine , cluster string , availability Zone string , container Instance Arn string ) { mux Router . Handle Func ( v 3 . Container Metadata Path , v 3 . Container Metadata Handler ( state ) ) mux Router . Handle Func ( v 3 . Task Metadata Path , v 3 . Task Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , false ) ) mux Router . Handle Func ( v 3 . Task With Tags Metadata Path , v 3 . Task Metadata Handler ( state , ecs Client , cluster , availability Zone , container Instance Arn , true ) ) mux Router . Handle Func ( v 3 . Container Stats Path , v 3 . Container Stats Handler ( state , stats Engine ) ) mux Router . Handle Func ( v 3 . Task Stats Path , v 3 . Task Stats Handler ( state , stats Engine ) ) mux Router . Handle Func ( v 3 . Container Associations Path , v 3 . Container Associations Handler ( state ) ) mux Router . Handle Func ( v 3 . Container Association Path With Slash , v 3 . Container Association Handler ( state ) ) mux Router . Handle Func ( v 3 . Container Association Path , v 3 . Container Association Handler ( state ) ) } 
func Serve Task HTTPEndpoint ( credentials Manager credentials . Manager , state dockerstate . Task Engine State , ecs Client api . ECSClient , container Instance Arn string , cfg * config . Config , stats Engine stats . Engine , availability Zone string ) { if err ! = nil { seelog . Errorf ( " " , err ) } audit Logger : = audit . New Audit Log ( container Instance Arn , cfg , logger ) server : = task Server Setup ( credentials Manager , audit Logger , state , ecs Client , cfg . Cluster , stats Engine , cfg . Task Metadata Steady State Rate , cfg . Task Metadata Burst Rate , availability Zone , container Instance Arn ) for { retry . Retry With Backoff ( retry . New Exponential Backoff ( time . Second , time . Minute , 0 . 2 , 2 ) , func ( ) error { if err ! = nil { seelog . Errorf ( " " , err ) } return err } ) } } 
func Agent Metadata Handler ( container Instance Arn * string , cfg * config . Config ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { resp : = & Metadata Response { Cluster : cfg . Cluster , Container Instance Arn : container Instance Arn , Version : agentversion . String ( ) , } response JSON , _ : = json . Marshal ( resp ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Agent Metadata ) } } 
func New Mock Provider ( ctrl * gomock . Controller ) * Mock Provider { mock : = & Mock Provider { ctrl : ctrl } mock . recorder = & Mock Provider Mock Recorder { mock } return mock } 
func ( m * Mock Provider ) Is Expired ( ) bool { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( mr * Mock Provider Mock Recorder ) Is Expired ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Provider ) ( nil ) . Is Expired ) ) } 
func ( m * Mock Provider ) Retrieve ( ) ( credentials . Value , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( credentials . Value ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock Container Metadata Resolver ( ctrl * gomock . Controller ) * Mock Container Metadata Resolver { mock : = & Mock Container Metadata Resolver { ctrl : ctrl } mock . recorder = & Mock Container Metadata Resolver Mock Recorder { mock } return mock } 
func ( m * Mock Container Metadata Resolver ) Resolve Container ( arg 0 string ) ( * container . Docker Container , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * container . Docker Container ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Container Metadata Resolver Mock Recorder ) Resolve Container ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Container Metadata Resolver ) ( nil ) . Resolve Container ) , arg 0 ) } 
func ( m * Mock Container Metadata Resolver ) Resolve Task ( arg 0 string ) ( * task . Task , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * task . Task ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Sensitive Raw Message ( data json . Raw Message ) * Sensitive Raw Message { if len ( data ) = = 0 { return nil } return & Sensitive Raw Message { contents : data } } 
func New Task Response ( task ARN string , state dockerstate . Task Engine State , ecs Client api . ECSClient , cluster string , az string , container Instance Arn string , propagate Tags bool ) ( * Task Response , error ) { task , ok : = state . Task By Arn ( task ARN ) if ! ok { return nil , errors . Errorf ( " " , task ARN ) } resp : = & Task Response { Cluster : cluster , Task ARN : task . Arn , Family : task . Family , Revision : task . Version , Desired Status : task . Get Desired Status ( ) . String ( ) , Known Status : task . Get Known Status ( ) . String ( ) , Availability Zone : az , } task CPU : = task . CPU task Memory : = task . Memory if task CPU ! = 0 | | task Memory ! = 0 { task Limits : = & Limits Response { } if task CPU ! = 0 { task Limits . CPU = & task CPU } if task Memory ! = 0 { task Limits . Memory = & task Memory } resp . Limits = task Limits } if timestamp : = task . Get Pull Started At ( ) ; ! timestamp . Is Zero ( ) { resp . Pull Started At = aws . Time ( timestamp . UTC ( ) ) } if timestamp : = task . Get Pull Stopped At ( ) ; ! timestamp . Is Zero ( ) { resp . Pull Stopped At = aws . Time ( timestamp . UTC ( ) ) } if timestamp : = task . Get Execution Stopped At ( ) ; ! timestamp . Is Zero ( ) { resp . Execution Stopped At = aws . Time ( timestamp . UTC ( ) ) } container Name To Docker Container , ok : = state . Container Map By Arn ( task . Arn ) if ! ok { seelog . Warnf ( " " , task . Arn ) return resp , nil } eni : = task . Get Task ENI ( ) for _ , docker Container : = range container Name To Docker Container { container Response : = new Container Response ( docker Container , eni , state ) resp . Containers = append ( resp . Containers , container Response ) } if propagate Tags { propagate Tags To Metadata ( state , ecs Client , container Instance Arn , task ARN , resp ) } return resp , nil } 
func New Container Response ( container ID string , state dockerstate . Task Engine State ) ( * Container Response , error ) { docker Container , ok : = state . Container By ID ( container ID ) if ! ok { return nil , errors . Errorf ( " " , container ID ) } task , ok : = state . Task By ID ( container ID ) if ! ok { return nil , errors . Errorf ( " " , container ID ) } resp : = new Container Response ( docker Container , task . Get Task ENI ( ) , state ) return & resp , nil } 
func New ( arguments [ ] string ) ( * Args , error ) { flagset : = flag . New Flag Set ( " " , flag . Continue On Error ) args : = & Args { Version : flagset . Bool ( version Flag Name , false , version Usage ) , Log Level : flagset . String ( log Level Flag Name , " " , log Level Usage ) , Accept Insecure Cert : flagset . Bool ( accept Insecure Cert Flag Name , false , accept Insecure Cert Usage ) , License : flagset . Bool ( license Flag Name , false , license Usage ) , Blackhole EC 2Metadata : flagset . Bool ( blackhole EC 2Metadata Flag Name , false , blachole EC 2Metadata Usage ) , ECSAttributes : flagset . Bool ( ecs Attributes Flag Name , false , ecs Attributes Usage ) , Windows Service : flagset . Bool ( windows Service Flag Name , false , windows Service Usage ) , } err : = flagset . Parse ( arguments ) if err ! = nil { return nil , err } return args , nil } 
func Default Config ( ) Config { program Data : = utils . Default If Blank ( os . Getenv ( " " ) , `C : \Program Data ` ) ecs Root : = filepath . Join ( program Data , " " , " " ) data Dir : = filepath . Join ( ecs Root , " " ) platform Variables : = Platform Variables { CPUUnbounded : false , } return Config { Docker Endpoint : " " , Reserved Ports : [ ] uint 1 6 { Docker Reserved Port , Docker Reserved SSLPort , Agent Introspection Port , Agent Credentials Port , rdp Port , rpc Port , smb Port , win RMPort HTTP , win RMPort HTTPS , dns Port , net BIOSPort , } , Reserved Ports UDP : [ ] uint 1 6 { } , Data Dir : data Dir , } 
func New ( timeout time . Duration , insecure Skip Verify bool ) * http . Client { transport . TLSClient Config = & tls . Config { } cipher . With Supported Cipher Suites ( transport . TLSClient Config ) transport . TLSClient Config . Insecure Skip Verify = insecure Skip Verify client : = & http . Client { Transport : & ecs Round Tripper { insecure Skip Verify , transport } , Timeout : timeout , } return client } 
func Remove From Task Array ( arr [ ] * Task , ndx int ) [ ] * Task { if ndx < 0 | | ndx > = len ( arr ) { return arr } return append ( arr [ 0 : ndx ] , arr [ ndx + 1 : ] . . . ) } 
func ( task * Task ) adjust For Platform ( cfg * config . Config ) { task . downcase All Volume Paths ( ) platform Fields : = Platform Fields { Cpu Unbounded : cfg . Platform Variables . CPUUnbounded , } task . Platform Fields = platform Fields } 
func ( task * Task ) downcase All Volume Paths ( ) { for _ , volume : = range task . Volumes { if host Vol , ok : = volume . Volume . ( * taskresourcevolume . FSHost Volume ) ; ok { host Vol . FSSource Path = get Canonical Path ( host Vol . FSSource Path ) } } for _ , container : = range task . Containers { for i , mount Point : = range container . Mount Points { } } } 
func ( task * Task ) platform Host Config Override ( host Config * dockercontainer . Host Config ) error { if host Config . CPUPercent = = 0 & & host Config . CPUShares ! = 0 { } host Config . CPUShares = 0 return nil } 
func ( eni * ENIAttachment Status ) String ( ) string { for k , v : = range eni Attachment Status Map { if v = = * eni { return k } } return " " } 
func _main ( ) int { var types Only bool flag . Bool Var ( & types Only , " " , false , " " ) flag . Parse ( ) api File : = " " var err error if types Only { err = gen Types Only API ( api File ) } else { err = gen Full ( api File ) } if err ! = nil { fmt . Println ( err ) return 1 } return 0 } 
func new Submit State Change Client ( aws Config * aws . Config ) * ecs . ECS { ssc Config : = aws Config . Copy ( ) ssc Config . Retryer = & one Day Retrier { } client : = ecs . New ( session . New ( ssc Config ) ) return client } 
func ( retrier * one Day Retrier ) Retry Rules ( r * request . Request ) time . Duration { return time . Duration ( delay ) * time . Millisecond } return 5 * time . Minute } 
func ( vs Volume Status ) String ( ) string { for k , v : = range resource Status Map { if v = = vs { return k } } return " " } 
func ( vs * Volume Status ) Marshal JSON ( ) ( [ ] byte , error ) { if vs = = nil { return nil , nil } return [ ] byte ( ` " ` + vs . String ( ) + ` " ` ) , nil } 
func ( vs * Volume Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * vs = Volume Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * vs = Volume Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) stat , ok : = resource Status Map [ str Status ] if ! ok { * vs = Volume Status None return errors . New ( " " ) } * vs = stat return nil } 
func New Mock Time ( ctrl * gomock . Controller ) * Mock Time { mock : = & Mock Time { ctrl : ctrl } mock . recorder = & Mock Time Mock Recorder { mock } return mock } 
func ( m * Mock Time ) After ( arg 0 time . Duration ) < - chan time . Time { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( < - chan time . Time ) return ret 0 } 
func ( m * Mock Time ) After Func ( arg 0 time . Duration , arg 1 func ( ) ) ttime . Timer { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( ttime . Timer ) return ret 0 } 
func ( m * Mock Time ) Now ( ) time . Time { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( time . Time ) return ret 0 } 
func ( mr * Mock Time Mock Recorder ) Now ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Time ) ( nil ) . Now ) ) } 
func ( m * Mock Time ) Sleep ( arg 0 time . Duration ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Time Mock Recorder ) Sleep ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Time ) ( nil ) . Sleep ) , arg 0 ) } 
func New Mock Timer ( ctrl * gomock . Controller ) * Mock Timer { mock : = & Mock Timer { ctrl : ctrl } mock . recorder = & Mock Timer Mock Recorder { mock } return mock } 
func ( m * Mock Timer ) Reset ( arg 0 time . Duration ) bool { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( mr * Mock Timer Mock Recorder ) Reset ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Timer ) ( nil ) . Reset ) , arg 0 ) } 
func ( m * Mock Timer ) Stop ( ) bool { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( mr * Mock Timer Mock Recorder ) Stop ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Timer ) ( nil ) . Stop ) ) } 
func Add Agent Update Handlers ( cs wsclient . Client Server , cfg * config . Config , saver statemanager . Saver , task Engine engine . Task Engine ) { single Updater : = & updater { acs : cs , config : cfg , fs : os . Default , httpclient : httpclient . New ( update Download Timeout , false ) , } cs . Add Request Handler ( single Updater . stage Update Handler ( ) ) cs . Add Request Handler ( single Updater . perform Update Handler ( saver , task Engine ) ) } 
func New Docker Go Client ( sdkclient Factory sdkclientfactory . Factory , cfg * config . Config , ctx context . Context ) ( Docker Client , error ) { if err ! = nil { seelog . Errorf ( " " + " " , err ) return nil , err } if err ! = nil { seelog . Errorf ( " " + " " , err ) return nil , err } var docker Auth Data json . Raw Message if cfg . Engine Auth Data ! = nil { docker Auth Data = cfg . Engine Auth Data . Contents ( ) } return & docker Go Client { sdk Client Factory : sdkclient Factory , auth : dockerauth . New Docker Auth Provider ( cfg . Engine Auth Type , docker Auth Data ) , ecr Client Factory : ecr . New ECRFactory ( cfg . Accept Insecure Cert ) , ecr Token Cache : async . New LRUCache ( token Cache Size , token Cache TTL ) , config : cfg , context : ctx , image Pull Backoff : retry . New Exponential Backoff ( minimum Pull Retry Delay , maximum Pull Retry Delay , pull Retry Jitter Multiplier , pull Retry Delay Multiplier ) , } , nil } 
func ( dg * docker Go Client ) sdk Docker Client ( ) ( sdkclient . Client , error ) { if dg . version = = " " { return dg . sdk Client Factory . Get Default Client ( ) } return dg . sdk Client Factory . Get Client ( dg . version ) } 
func Docker State To State ( state * types . Container State ) apicontainerstatus . Container Status { if state . Running { return apicontainerstatus . Container Running } if state . Dead { return apicontainerstatus . Container Stopped } if start Time . Is Zero ( ) & & state . Error = = " " { return apicontainerstatus . Container Created } return apicontainerstatus . Container Stopped } 
func Metadata From Container ( docker Container * types . Container JSON ) Docker Container Metadata { var bindings [ ] apicontainer . Port Binding var err apierrors . Named Error if docker Container . Network Settings ! = nil { if err ! = nil { seelog . Criticalf ( " " , err ) return Docker Container Metadata { Error : apierrors . Named Error ( err ) } } } created Time , _ : = time . Parse ( time . RFC 3 3 3 9 , docker Container . Created ) started Time : = time . Time { } finished Time : = time . Time { } finished Time , _ = time . Parse ( time . RFC 3 3 3 9 , docker Container . State . Finished At ) } metadata : = Docker Container Metadata { Docker ID : docker Container . ID , Port Bindings : bindings , Volumes : docker Container . Mounts , Created At : created Time , Started At : started Time , Finished At : finished Time , } if docker Container . Network Settings ! = nil { metadata . Network Settings = docker Container . Network Settings } if docker Container . Host Config ! = nil { metadata . Network Mode = string ( docker Container . Host Config . Network Mode ) } if docker Container . Config ! = nil { metadata . Labels = docker Container . Config . Labels } if docker Container . State = = nil { return metadata } if ! docker Container . State . Running & & ! finished Time . Is Zero ( ) { } if docker Container . State . Error ! = " " { metadata . Error = New Docker State Error ( docker Container . State . Error ) } if docker Container . State . OOMKilled { metadata . Error = Out Of Memory Error { } } } return metadata } 
func ( dg * docker Go Client ) Container Events ( ctx context . Context ) ( < - chan Docker Container Change Event , error ) { client , err : = dg . sdk Docker Client ( ) if err ! = nil { return nil , err } events : = make ( chan * events . Message ) buffer : = New Infinite Buffer ( ) derived Ctx , cancel : = context . With Cancel ( ctx ) docker Events , event Err : = client . Events ( derived Ctx , types . Events Options { } ) cancel ( ) return } else { next Ctx , next Cancel : = context . With Cancel ( ctx ) docker Events , event Err = client . Events ( next Ctx , types . Events Options { } ) } case < - ctx . Done ( ) : return } } } ( ) changed Containers : = make ( chan Docker Container Change Event ) go dg . handle Container Events ( ctx , events , changed Containers ) return changed Containers , nil } 
func ( dg * docker Go Client ) List Containers ( ctx context . Context , all bool , timeout time . Duration ) List Containers Response { ctx , cancel : = context . With Timeout ( ctx , timeout ) defer cancel ( ) go func ( ) { response < - dg . list Containers ( ctx , all ) } ( ) select { case resp : = < - response : return resp case < - ctx . Done ( ) : if err = = context . Deadline Exceeded { return List Containers Response { Error : & Docker Timeout Error { timeout , " " } } } return List Containers Response { Error : & Cannot List Containers Error { err } } } } 
func ( dg * docker Go Client ) List Plugins With Filters ( ctx context . Context , enabled bool , capabilities [ ] string , timeout time . Duration ) ( [ ] string , error ) { for _ , capability : = range capabilities { filter List . Add ( " " , capability ) } var filtered Plugin Names [ ] string response : = dg . List Plugins ( ctx , timeout , filter List ) if response . Error ! = nil { return nil , response . Error } } return filtered Plugin Names , nil } 
func ( dg * docker Go Client ) APIVersion ( ) ( dockerclient . Docker Version , error ) { client , err : = dg . sdk Docker Client ( ) if err ! = nil { return " " , err } return dg . sdk Client Factory . Find Client APIVersion ( client ) , nil } 
func ( dg * docker Go Client ) Stats ( ctx context . Context , id string , inactivity Timeout time . Duration ) ( < - chan * types . Stats JSON , error ) { sub Ctx , cancel Request : = context . With Cancel ( ctx ) client , err : = dg . sdk Docker Client ( ) if err ! = nil { cancel Request ( ) return nil , err } var resp types . Container Stats if ! dg . config . Poll Metrics { go func ( ) { defer cancel Request ( ) defer close ( stats Chnl ) resp , err = client . Container Stats ( sub Ctx , id , stream ) if err ! = nil { seelog . Warnf ( " " , id , err ) return } var ch chan < - struct { } resp . Body , ch = handle Inactivity Timeout ( resp . Body , inactivity Timeout , cancel Request , & canceled ) defer resp . Body . Close ( ) defer close ( ch ) data : = new ( types . Stats JSON ) for err : = decoder . Decode ( data ) ; err ! = io . EOF ; err = decoder . Decode ( data ) { if err ! = nil { seelog . Warnf ( " " , id , err ) return } if atomic . Load Uint 3 2 ( & canceled ) ! = 0 { seelog . Warnf ( " " , id ) return } stats Chnl < - data data = new ( types . Stats JSON ) } } ( ) } else { seelog . Infof ( " " , id ) stat Poll Ticker : = time . New Ticker ( dg . config . Polling Metrics Wait Duration ) go func ( ) { defer cancel Request ( ) defer close ( stats Chnl ) defer stat Poll Ticker . Stop ( ) for range stat Poll Ticker . C { resp , err = client . Container Stats ( sub Ctx , id , stream ) if err ! = nil { seelog . Warnf ( " " , id , err ) return } data : = new ( types . Stats JSON ) err : = decoder . Decode ( data ) if err ! = nil { seelog . Warnf ( " " , id , err ) return } stats Chnl < - data data = new ( types . Stats JSON ) } } ( ) } return stats Chnl , nil } 
func ( dg * docker Go Client ) Load Image ( ctx context . Context , input Stream io . Reader , timeout time . Duration ) error { ctx , cancel : = context . With Timeout ( ctx , timeout ) defer cancel ( ) defer metrics . Metrics Engine Global . Record Docker Metric ( " " ) ( ) response : = make ( chan error , 1 ) go func ( ) { response < - dg . load Image ( ctx , input Stream ) } ( ) select { case resp : = < - response : return resp case < - ctx . Done ( ) : return & Docker Timeout Error { timeout , " " } } } 
func ( image State * Image State ) Update Container Reference ( container * apicontainer . Container ) { image State . lock . Lock ( ) defer image State . lock . Unlock ( ) seelog . Infof ( " " , container . Name , image State . Image . Image ID ) image State . Containers = append ( image State . Containers , container ) } 
func ( image State * Image State ) Add Image Name ( image Name string ) { image State . lock . Lock ( ) defer image State . lock . Unlock ( ) if ! image State . Has Image Name ( image Name ) { seelog . Infof ( " " , image Name , image State . Image . Image ID ) image State . Image . Names = append ( image State . Image . Names , image Name ) } } 
func ( image State * Image State ) Get Image Names Count ( ) int { image State . lock . RLock ( ) defer image State . lock . RUnlock ( ) return len ( image State . Image . Names ) } 
func ( image State * Image State ) Update Image State ( container * apicontainer . Container ) { image State . Add Image Name ( container . Image ) image State . Update Container Reference ( container ) } 
func ( image State * Image State ) Remove Image Name ( container Image Name string ) { image State . lock . Lock ( ) defer image State . lock . Unlock ( ) for i , image Name : = range image State . Image . Names { if image Name = = container Image Name { image State . Image . Names = append ( image State . Image . Names [ : i ] , image State . Image . Names [ i + 1 : ] . . . ) } } } 
func ( image State * Image State ) Has Image Name ( container Image Name string ) bool { for _ , image Name : = range image State . Image . Names { if image Name = = container Image Name { return true } } return false } 
func ( image State * Image State ) Remove Container Reference ( container * apicontainer . Container ) error { defer image State . lock . Unlock ( ) for i : = range image State . Containers { if image State . Containers [ i ] . Name = = container . Name { image State . Containers = append ( image State . Containers [ : i ] , image State . Containers [ i + 1 : ] . . . ) return nil } } return fmt . Errorf ( " " , container . String ( ) ) } 
func ( image State * Image State ) Set Pull Succeeded ( pull Succeeded bool ) { image State . lock . Lock ( ) defer image State . lock . Unlock ( ) image State . Pull Succeeded = pull Succeeded } 
func ( image State * Image State ) Get Pull Succeeded ( ) bool { image State . lock . RLock ( ) defer image State . lock . RUnlock ( ) return image State . Pull Succeeded } 
func ( image State * Image State ) Marshal JSON ( ) ( [ ] byte , error ) { image State . lock . Lock ( ) defer image State . lock . Unlock ( ) return json . Marshal ( & struct { Image * Image Pulled At time . Time Last Used At time . Time Pull Succeeded bool } { Image : image State . Image , Pulled At : image State . Pulled At , Last Used At : image State . Last Used At , Pull Succeeded : image State . Pull Succeeded , } ) } 
func ( ts Task Status ) String ( ) string { for k , v : = range task Status Map { if v = = ts { return k } } return " " } 
func ( ts * Task Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * ts = Task Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * ts = Task Status None return errors . New ( " " ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) return nil } if str Status = = " " { * ts = Task Stopped return nil } stat , ok : = task Status Map [ str Status ] if ! ok { * ts = Task Status None return errors . New ( " " ) } * ts = stat return nil } 
func ( ts * Task Status ) Marshal JSON ( ) ( [ ] byte , error ) { if ts = = nil { return nil , nil } return [ ] byte ( ` " ` + ts . String ( ) + ` " ` ) , nil } 
func New Client ( cfg * Config ) CNIClient { libcni Config : = & libcni . CNIConfig { Path : [ ] string { cfg . Plugins Path } , } return & cni Client { plugins Path : cfg . Plugins Path , cni Version : cfg . Min Supported CNIVersion , subnet : ecs Subnet , libcni : libcni Config , } } 
func ( client * cni Client ) Setup NS ( ctx context . Context , cfg * Config , timeout time . Duration ) ( * current . Result , error ) { derived Ctx , cancel : = context . With Timeout ( ctx , timeout ) defer cancel ( ) type output struct { result * current . Result err error } response : = make ( chan output ) go func ( response chan output ) { result , err : = client . setup NS ( cfg ) response < - output { result : result , err : err , } } ( response ) select { case < - derived Ctx . Done ( ) : return nil , errors . Wrap ( derived Ctx . Err ( ) , " " ) case result : = < - response : return result . result , result . err } } 
func ( client * cni Client ) Cleanup NS ( ctx context . Context , cfg * Config , timeout time . Duration ) error { derived Ctx , cancel : = context . With Timeout ( ctx , timeout ) defer cancel ( ) err : = make ( chan error ) go func ( err chan error ) { err < - client . cleanup NS ( cfg ) } ( err ) select { case < - derived Ctx . Done ( ) : return errors . Wrap ( derived Ctx . Err ( ) , " " ) case err : = < - err : return err } } 
func ( client * cni Client ) Release IPResource ( cfg * Config ) error { runtime Config : = libcni . Runtime Conf { Container ID : cfg . Container ID , Net NS : fmt . Sprintf ( netns Format , cfg . Container PID ) , } seelog . Debugf ( " " , cfg . ID , cfg . IPAMV 4Address ) os . Setenv ( " " , logger . Get Level ( ) ) defer os . Unsetenv ( " " ) return client . del ( runtime Config , cfg , client . create IPAMNetwork Config ) } 
func ( client * cni Client ) add ( runtime Config libcni . Runtime Conf , cfg * Config , plugin Config Func func ( * Config ) ( string , * libcni . Network Config , error ) ) ( cnitypes . Result , error ) { device Name , network Config , err : = plugin Config Func ( cfg ) if err ! = nil { return nil , err } runtime Config . If Name = device Name return client . libcni . Add Network ( network Config , & runtime Config ) } 
func ( client * cni Client ) del ( runtime Config libcni . Runtime Conf , cfg * Config , plugin Config Func func ( * Config ) ( string , * libcni . Network Config , error ) ) error { device Name , network Config , err : = plugin Config Func ( cfg ) if err ! = nil { return err } runtime Config . If Name = device Name return client . libcni . Del Network ( network Config , & runtime Config ) } 
func ( client * cni Client ) create Bridge Network Config With IPAM ( cfg * Config ) ( string , * libcni . Network Config , error ) { if err ! = nil { return " " , nil , errors . Wrap ( err , " " ) } bridge Config . IPAM = ipam Config network Config , err : = client . construct Network Config ( bridge Config , ECSBridge Plugin Name ) if err ! = nil { return " " , nil , errors . Wrap ( err , " " ) } return default Veth Name , network Config , nil } 
func ( client * cni Client ) create Bridge Network Config Without IPAM ( cfg * Config ) ( string , * libcni . Network Config , error ) { network Config , err : = client . construct Network Config ( client . create Bridge Config ( cfg ) , ECSBridge Plugin Name ) if err ! = nil { return " " , nil , errors . Wrap ( err , " " ) } return default Veth Name , network Config , nil } 
func ( client * cni Client ) construct Network Config ( cfg interface { } , plugin string ) ( * libcni . Network Config , error ) { config Bytes , err : = json . Marshal ( cfg ) if err ! = nil { seelog . Errorf ( " " , plugin , err ) return nil , err } network Config : = & libcni . Network Config { Network : & cnitypes . Net Conf { Type : plugin , } , Bytes : config Bytes , } return network Config , nil } 
func ( client * cni Client ) create IPAMNetwork Config ( cfg * Config ) ( string , * libcni . Network Config , error ) { ipam Config , err : = client . create IPAMConfig ( cfg ) if err ! = nil { return default Veth Name , nil , errors . Wrap ( err , " " ) } ipam Network Config : = IPAMNetwork Config { Name : ECSIPAMPlugin Name , CNIVersion : client . cni Version , IPAM : ipam Config , } network Config , err : = client . construct Network Config ( ipam Network Config , ECSIPAMPlugin Name ) if err ! = nil { return " " , nil , errors . Wrap ( err , " " ) } return default Veth Name , network Config , nil } 
func ( client * cni Client ) Version ( name string ) ( string , error ) { file : = filepath . Join ( client . plugins Path , name ) if err ! = nil { return " " , err } cmd : = exec . Command ( file , version Command ) version Info , err : = cmd . Output ( ) if err ! = nil { return " " , err } version : = & cni Plugin Version { } if err ! = nil { return " " , errors . Wrapf ( err , " " , version Info ) } return version . str ( ) , nil } 
func ( version * cni Plugin Version ) str ( ) string { ver : = " " if version . Dirty { ver = " " } return ver + version . Hash + " " + version . Version } 
func ( client * cni Client ) Capabilities ( name string ) ( [ ] string , error ) { file : = filepath . Join ( client . plugins Path , name ) if err ! = nil { return nil , errors . Wrapf ( err , " " , file ) } cmd : = exec . Command ( file , capabilities Command ) capabilities Info , err : = cmd . Output ( ) if err ! = nil { return nil , errors . Wrapf ( err , " " , name ) } capabilities : = & struct { Capabilities [ ] string `json : "capabilities " ` } { } err = json . Unmarshal ( capabilities Info , capabilities ) if err ! = nil { return nil , errors . Wrapf ( err , " " , name , capabilities Info ) } return capabilities . Capabilities , nil } 
func ( as SSMSecret Status ) String ( ) string { for k , v : = range ssm Secret Status Map { if v = = as { return k } } return " " } 
func ( as * SSMSecret Status ) Marshal JSON ( ) ( [ ] byte , error ) { if as = = nil { return nil , errors . New ( " " ) } return [ ] byte ( ` " ` + as . String ( ) + ` " ` ) , nil } 
func ( as * SSMSecret Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * as = SSMSecret Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * as = SSMSecret Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) stat , ok : = ssm Secret Status Map [ str Status ] if ! ok { * as = SSMSecret Status None return errors . New ( " " ) } * as = stat return nil } 
func New ( ctx context . Context , primary MAC string , udevwrap udevwrapper . Udev , state dockerstate . Task Engine State , state Change Events chan < - statechange . Event ) * Udev Watcher { return new Watcher ( ctx , primary MAC , netlinkwrapper . New ( ) , udevwrap , state , state Change Events ) } 
func new Watcher ( ctx context . Context , primary MAC string , nl Wrap netlinkwrapper . Net Link , udev Wrap udevwrapper . Udev , state dockerstate . Task Engine State , state Change Events chan < - statechange . Event ) * Udev Watcher { derived Context , cancel : = context . With Cancel ( ctx ) return & Udev Watcher { ctx : derived Context , cancel : cancel , netlink Client : nl Wrap , udev Monitor : udev Wrap , events : make ( chan * udev . UEvent ) , agent State : state , eni Change Event : state Change Events , primary MAC : primary MAC , } } 
func ( udev Watcher * Udev Watcher ) perform Periodic Reconciliation ( update Interval time . Duration ) { udev Watcher . update Interval Ticker = time . New Ticker ( update Interval ) for { select { case < - udev Watcher . update Interval Ticker . C : if err : = udev Watcher . reconcile Once ( ) ; err ! = nil { log . Warnf ( " " , err ) } case < - udev Watcher . ctx . Done ( ) : udev Watcher . update Interval Ticker . Stop ( ) return } } } 
func ( udev Watcher * Udev Watcher ) reconcile Once ( ) error { links , err : = udev Watcher . netlink Client . Link List ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } return nil } current State : = udev Watcher . build State ( links ) } } return nil } 
func ( udev Watcher * Udev Watcher ) send ENIState Change ( mac string ) error { if mac = = " " { return errors . New ( " " ) } if ! ok { return & unmanaged ENIError { mac } } if eni . Is Sent ( ) { return errors . Errorf ( " " , eni . String ( ) ) } if eni . Has Expired ( ) { return errors . Errorf ( " " , eni . String ( ) ) } log . Infof ( " " , eni . String ( ) ) udev Watcher . eni Change Event < - api . Task State Change { Task ARN : eni . Task ARN , Attachment : eni , } } ( eni ) return nil } 
func ( udev Watcher * Udev Watcher ) build State ( links [ ] netlink . Link ) map [ string ] string { state : = make ( map [ string ] string ) for _ , link : = range links { if link . Type ( ) ! = link Type Device { } if link . Attrs ( ) . Encap Type = = encap Type Loopback { } mac Address : = link . Attrs ( ) . Hardware Addr . String ( ) if mac Address ! = " " & & mac Address ! = udev Watcher . primary MAC { state [ mac Address ] = link . Attrs ( ) . Name } } return state } 
func ( udev Watcher * Udev Watcher ) event Handler ( ) { for { select { case event : = < - udev Watcher . events : subsystem , ok : = event . Env [ udev Subsystem ] if ! ok | | subsystem ! = udev Net Subsystem { continue } if event . Env [ udev Event Action ] ! = udev Add Event { continue } if ! networkutils . Is Valid Network Device ( event . Env [ udev Dev Path ] ) { log . Debugf ( " " , event . String ( ) ) continue } net Interface : = event . Env [ udev Interface ] mac Address , err : = networkutils . Get MACAddress ( udev Watcher . ctx , mac Address Retry Timeout , dev , udev Watcher . netlink Client ) if err ! = nil { log . Warnf ( " " , dev ) return } if err : = udev Watcher . send ENIState Change With Retries ( ctx , mac Address , timeout ) ; err ! = nil { log . Warnf ( " " , err ) } } ( udev Watcher . ctx , net Interface , send ENIState Change Retry Timeout ) case < - udev Watcher . ctx . Done ( ) : log . Info ( " " ) if err : = udev Watcher . udev Monitor . Close ( ) ; err ! = nil { log . Warnf ( " " , err ) } return } } } 
func ( udev Watcher * Udev Watcher ) send ENIState Change With Retries ( parent Ctx context . Context , mac Address string , timeout time . Duration ) error { backoff : = retry . New Exponential Backoff ( send ENIState Change Backoff Min , send ENIState Change Backoff Max , send ENIState Change Backoff Jitter , send ENIState Change Backoff Multiple ) ctx , cancel : = context . With Timeout ( parent Ctx , timeout ) defer cancel ( ) err : = retry . Retry With Backoff Ctx ( ctx , backoff , func ( ) error { send Err : = udev Watcher . send ENIState Change ( mac Address ) if send Err ! = nil { if _ , ok : = send Err . ( * unmanaged ENIError ) ; ok { log . Debugf ( " " , send Err ) return send Err } } return nil } ) if err ! = nil { return err } } return nil } 
func New ( url string , cfg * config . Config , credential Provider * credentials . Credentials , stats Engine stats . Engine , publish Metrics Interval time . Duration , rw Timeout time . Duration , disable Resource Metrics bool ) wsclient . Client Server { cs : = & client Server { stats Engine : stats Engine , publish Ticker : nil , publish Health Ticker : nil , publish Metrics Interval : publish Metrics Interval , } cs . URL = url cs . Agent Config = cfg cs . Credential Provider = credential Provider cs . Service Error = & tcs Error { } cs . Request Handlers = make ( map [ string ] wsclient . Request Handler ) cs . Make Request Hook = sign Request Func ( url , cs . Agent Config . AWSRegion , credential Provider ) cs . Type Decoder = New TCSDecoder ( ) cs . RWTimeout = rw Timeout cs . disable Resource Metrics = disable Resource Metrics return cs } 
func ( cs * client Server ) Serve ( ) error { seelog . Debug ( " " ) if ! cs . Is Ready ( ) { return fmt . Errorf ( " " ) } if cs . stats Engine = = nil { return fmt . Errorf ( " " ) } cs . publish Health Ticker = time . New Ticker ( cs . publish Metrics Interval ) if ! cs . disable Resource Metrics { go cs . publish Metrics ( ) } go cs . publish Health Metrics ( ) return cs . Consume Messages ( ) } 
func ( cs * client Server ) Close ( ) error { if cs . publish Ticker ! = nil { cs . publish Ticker . Stop ( ) } if cs . publish Health Ticker ! = nil { cs . publish Health Ticker . Stop ( ) } cs . cancel ( ) return cs . Disconnect ( ) } 
func sign Request Func ( url , region string , credential Provider * credentials . Credentials ) wsclient . Make Request Hook Func { return func ( payload [ ] byte ) ( [ ] byte , error ) { req Body : = bytes . New Reader ( payload ) request , err : = http . New Request ( " " , url , req Body ) if err ! = nil { return nil , err } err = utils . Sign HTTPRequest ( request , region , " " , credential Provider , req Body ) if err ! = nil { return nil , err } request . Header . Add ( " " , request . Host ) var data Buffer bytes . Buffer request . Header . Write ( & data Buffer ) io . Write String ( & data Buffer , " \r \n " ) data : = data Buffer . Bytes ( ) data = append ( data , payload . . . ) return data , nil } } 
func ( cs * client Server ) publish Metrics ( ) { if cs . publish Ticker = = nil { seelog . Debug ( " " ) return } if err ! = nil & & err ! = stats . Empty Metrics Error { seelog . Warnf ( " " , err ) } if err ! = nil { seelog . Warnf ( " " , err ) } case < - cs . ctx . Done ( ) : return } } } 
func ( cs * client Server ) publish Metrics Once ( ) error { if err ! = nil { return err } if err ! = nil { return err } } return nil } 
func ( cs * client Server ) metrics To Publish Metric Requests ( ) ( [ ] * ecstcs . Publish Metrics Request , error ) { metadata , task Metrics , err : = cs . stats Engine . Get Instance Metrics ( ) if err ! = nil { return nil , err } var requests [ ] * ecstcs . Publish Metrics Request if * metadata . Idle { metadata . Fin = aws . Bool ( true ) return requests , nil } var message Task Metrics [ ] * ecstcs . Task Metric num Tasks : = len ( task Metrics ) for i , task Metric : = range task Metrics { message Task Metrics = append ( message Task Metrics , task Metric ) var request Metadata * ecstcs . Metrics Metadata if ( i + 1 ) = = num Tasks { } else { request Metadata = copy Metrics Metadata ( metadata , false ) } if ( i + 1 ) % tasks In Metric Message = = 0 { message Task Metrics = message Task Metrics [ : 0 ] } } if len ( message Task Metrics ) > 0 { } return requests , nil } 
func ( cs * client Server ) publish Health Metrics ( ) { if cs . publish Ticker = = nil { seelog . Debug ( " " ) return } if err ! = nil { seelog . Warnf ( " " , err ) } for { select { case < - cs . publish Health Ticker . C : err : = cs . publish Health Metrics Once ( ) if err ! = nil { seelog . Warnf ( " " , err ) } case < - cs . ctx . Done ( ) : return } } } 
func ( cs * client Server ) publish Health Metrics Once ( ) error { if err ! = nil { return err } if err ! = nil { return err } } return nil } 
func ( cs * client Server ) create Publish Health Requests ( ) ( [ ] * ecstcs . Publish Health Request , error ) { metadata , task Health Metrics , err : = cs . stats Engine . Get Task Health Metrics ( ) if err ! = nil { return nil , err } if metadata = = nil | | task Health Metrics = = nil { seelog . Debug ( " " ) return nil , nil } var requests [ ] * ecstcs . Publish Health Request var task Healths [ ] * ecstcs . Task Health num Of Tasks : = len ( task Health Metrics ) for i , task Health : = range task Health Metrics { task Healths = append ( task Healths , task Health ) request Task Health : = copy Task Health Metrics ( task Healths ) request : = ecstcs . New Publish Health Metrics Request ( request Metadata , request Task Health ) requests = append ( requests , request ) task Healths = task Healths [ : 0 ] } } requests = append ( requests , ecstcs . New Publish Health Metrics Request ( request Metadata , task Healths ) ) } return requests , nil } 
func copy Metrics Metadata ( metadata * ecstcs . Metrics Metadata , fin bool ) * ecstcs . Metrics Metadata { return & ecstcs . Metrics Metadata { Cluster : aws . String ( * metadata . Cluster ) , Container Instance : aws . String ( * metadata . Container Instance ) , Idle : aws . Bool ( * metadata . Idle ) , Message Id : aws . String ( * metadata . Message Id ) , Fin : aws . Bool ( fin ) , } } 
func copy Task Metrics ( from [ ] * ecstcs . Task Metric ) [ ] * ecstcs . Task Metric { to : = make ( [ ] * ecstcs . Task Metric , len ( from ) ) copy ( to , from ) return to } 
func copy Health Metadata ( metadata * ecstcs . Health Metadata , fin bool ) * ecstcs . Health Metadata { return & ecstcs . Health Metadata { Cluster : aws . String ( aws . String Value ( metadata . Cluster ) ) , Container Instance : aws . String ( aws . String Value ( metadata . Container Instance ) ) , Fin : aws . Bool ( fin ) , Message Id : aws . String ( aws . String Value ( metadata . Message Id ) ) , } } 
func copy Task Health Metrics ( from [ ] * ecstcs . Task Health ) [ ] * ecstcs . Task Health { to : = make ( [ ] * ecstcs . Task Health , len ( from ) ) copy ( to , from ) return to } 
func Credentials Handler ( credentials Manager credentials . Manager , audit Logger audit . Audit Logger ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { credentials ID : = get Credentials ID ( r ) err Prefix : = fmt . Sprintf ( " " , api Version ) v 1 . Credentials Handler Impl ( w , r , audit Logger , credentials Manager , credentials ID , err Prefix ) } } 
func ( as ASMAuth Status ) String ( ) string { for k , v : = range asm Auth Status Map { if v = = as { return k } } return " " } 
func ( as * ASMAuth Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * as = ASMAuth Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * as = ASMAuth Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) stat , ok : = asm Auth Status Map [ str Status ] if ! ok { * as = ASMAuth Status None return errors . New ( " " ) } * as = stat return nil } 
func ( rm * Resources Map ) Unmarshal JSON ( data [ ] byte ) error { resources : = make ( map [ string ] json . Raw Message ) err : = json . Unmarshal ( data , & resources ) if err ! = nil { return err } result : = make ( map [ string ] [ ] taskresource . Task Resource ) for key , value : = range resources { switch key { case Cgroup Key : if unmarshl Cgroup ( key , value , result ) ! = nil { return err } case Docker Volume Key : if unmarshal Docker Volume ( key , value , result ) ! = nil { return err } case ASMAuth Key : if unmarshal ASMAuth Key ( key , value , result ) ! = nil { return err } case SSMSecret Key : if unmarshal SSMSecret Key ( key , value , result ) ! = nil { return err } case ASMSecret Key : if unmarshal ASMSecret Key ( key , value , result ) ! = nil { return err } default : return errors . New ( " " ) } } * rm = result return nil } 
func New ( url string , cfg * config . Config , credential Provider * credentials . Credentials , rw Timeout time . Duration ) wsclient . Client Server { cs : = & client Server { } cs . URL = url cs . Credential Provider = credential Provider cs . Agent Config = cfg cs . Service Error = & acs Error { } cs . Request Handlers = make ( map [ string ] wsclient . Request Handler ) cs . Type Decoder = New ACSDecoder ( ) cs . RWTimeout = rw Timeout return cs } 
func ( cs * client Server ) Serve ( ) error { seelog . Debug ( " " ) if ! cs . Is Ready ( ) { return errors . New ( " " ) } return cs . Consume Messages ( ) } 
func New Volume Resource ( ctx context . Context , name string , docker Volume Name string , scope string , autoprovision bool , driver string , driver Options map [ string ] string , labels map [ string ] string , client dockerapi . Docker Client ) ( * Volume Resource , error ) { if scope = = Task Scope & & autoprovision { return nil , errors . Errorf ( " " , name ) } v : = & Volume Resource { Name : name , Volume Config : Docker Volume Config { Scope : scope , Autoprovision : autoprovision , Driver : driver , Driver Opts : driver Options , Labels : labels , Docker Volume Name : docker Volume Name , } , client : client , ctx : ctx , } v . init Status To Transitions ( ) return v , nil } 
func ( vol * Volume Resource ) Desired Terminal ( ) bool { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . desired Status Unsafe = = resourcestatus . Resource Status ( Volume Removed ) } 
func ( vol * Volume Resource ) Set Desired Status ( status resourcestatus . Resource Status ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . desired Status Unsafe = status } 
func ( vol * Volume Resource ) Get Desired Status ( ) resourcestatus . Resource Status { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . desired Status Unsafe } 
func ( vol * Volume Resource ) Set Known Status ( status resourcestatus . Resource Status ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . known Status Unsafe = status } 
func ( vol * Volume Resource ) Get Known Status ( ) resourcestatus . Resource Status { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . known Status Unsafe } 
func ( vol * Volume Resource ) Known Created ( ) bool { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . known Status Unsafe = = resourcestatus . Resource Status ( Volume Created ) } 
func ( vol * Volume Resource ) Apply Transition ( next State resourcestatus . Resource Status ) error { transition Func , ok : = vol . status To Transitions [ next State ] if ! ok { return errors . Errorf ( " " , vol . Name , vol . Status String ( next State ) ) } return transition Func ( ) } 
func ( vol * Volume Resource ) Set Applied Status ( status resourcestatus . Resource Status ) bool { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) if vol . applied Status Unsafe ! = resourcestatus . Resource Status ( Volume Status None ) { } vol . applied Status Unsafe = status return true } 
func ( vol * Volume Resource ) Status String ( status resourcestatus . Resource Status ) string { return Volume Status ( status ) . String ( ) } 
func ( vol * Volume Resource ) Set Created At ( created At time . Time ) { if created At . Is Zero ( ) { return } vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . created At Unsafe = created At } 
func ( vol * Volume Resource ) Get Created At ( ) time . Time { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . created At Unsafe } 
func ( vol * Volume Resource ) set Mount Point ( mount Point string ) { vol . lock . Lock ( ) defer vol . lock . Unlock ( ) vol . Volume Config . Mountpoint = mount Point } 
func ( vol * Volume Resource ) Get Mount Point ( ) string { vol . lock . RLock ( ) defer vol . lock . RUnlock ( ) return vol . Volume Config . Mountpoint } 
func ( vol * Volume Resource ) Create ( ) error { seelog . Debugf ( " " , vol . Volume Config . Docker Volume Name , vol . Volume Config . Driver ) volume Response : = vol . client . Create Volume ( vol . ctx , vol . Volume Config . Docker Volume Name , vol . Volume Config . Driver , vol . Volume Config . Driver Opts , vol . Volume Config . Labels , dockerclient . Create Volume Timeout ) if volume Response . Error ! = nil { return volume Response . Error } return nil } 
func ( vol * Volume Resource ) Cleanup ( ) error { return nil } seelog . Debugf ( " " , vol . Name ) err : = vol . client . Remove Volume ( vol . ctx , vol . Volume Config . Docker Volume Name , dockerclient . Remove Volume Timeout ) if err ! = nil { return err } return nil } 
func ( vol * Volume Resource ) Marshal JSON ( ) ( [ ] byte , error ) { if vol = = nil { return nil , nil } return json . Marshal ( volume Resource JSON { vol . Name , vol . Volume Config , vol . Get Created At ( ) , func ( ) * Volume Status { desired State : = Volume Status ( vol . Get Desired Status ( ) ) ; return & desired State } ( ) , func ( ) * Volume Status { known State : = Volume Status ( vol . Get Known Status ( ) ) ; return & known State } ( ) , } ) } 
func ( vol * Volume Resource ) Unmarshal JSON ( b [ ] byte ) error { temp : = & volume Resource JSON { } if err : = json . Unmarshal ( b , & temp ) ; err ! = nil { return err } vol . Name = temp . Name vol . Volume Config = temp . Volume Config if temp . Desired Status ! = nil { vol . Set Desired Status ( resourcestatus . Resource Status ( * temp . Desired Status ) ) } if temp . Known Status ! = nil { vol . Set Known Status ( resourcestatus . Resource Status ( * temp . Known Status ) ) } return nil } 
func New Mock Client Creator ( ctrl * gomock . Controller ) * Mock Client Creator { mock : = & Mock Client Creator { ctrl : ctrl } mock . recorder = & Mock Client Creator Mock Recorder { mock } return mock } 
func ( m * Mock Client Creator ) New ASMClient ( arg 0 string , arg 1 credentials . IAMRole Credentials ) secretsmanageriface . Secrets Manager API { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( secretsmanageriface . Secrets Manager API ) return ret 0 } 
func ( mr * Mock Client Creator Mock Recorder ) New ASMClient ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Client Creator ) ( nil ) . New ASMClient ) , arg 0 , arg 1 ) } 
func New Transport Protocol ( protocol string ) ( Transport Protocol , error ) { switch protocol { case tcp : return Transport Protocol TCP , nil case udp : return Transport Protocol UDP , nil default : return Transport Protocol TCP , errors . New ( protocol + " " ) } } 
func ( tp * Transport Protocol ) String ( ) string { if tp = = nil { return tcp } switch * tp { case Transport Protocol UDP : return udp case Transport Protocol TCP : return tcp default : seelog . Critical ( " " ) return tcp } } 
func ( tp * Transport Protocol ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * tp = Transport Protocol TCP seelog . Warn ( " " ) return nil } switch string ( b ) { case ` "tcp " ` : * tp = Transport Protocol TCP case ` "udp " ` : * tp = Transport Protocol UDP default : * tp = Transport Protocol TCP return errors . New ( " \ " \ " \ " \ " " + string ( b ) ) } return nil } 
func ( tp * Transport Protocol ) Marshal JSON ( ) ( [ ] byte , error ) { if tp = = nil { return [ ] byte ( " " ) , nil } return [ ] byte ( ` " ` + tp . String ( ) + ` " ` ) , nil } 
func New Mock Manager ( ctrl * gomock . Controller ) * Mock Manager { mock : = & Mock Manager { ctrl : ctrl } mock . recorder = & Mock Manager Mock Recorder { mock } return mock } 
func ( m * Mock Manager ) Get Task Credentials ( arg 0 string ) ( credentials . Task IAMRole Credentials , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( credentials . Task IAMRole Credentials ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Manager ) Remove Credentials ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Manager ) Set Task Credentials ( arg 0 * credentials . Task IAMRole Credentials ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func Get Docker Auth From ASM ( secret ID string , client secretsmanageriface . Secrets Manager API ) ( types . Auth Config , error ) { in : = & secretsmanager . Get Secret Value Input { Secret Id : aws . String ( secret ID ) , } out , err : = client . Get Secret Value ( in ) if err ! = nil { return types . Auth Config { } , errors . Wrapf ( err , " " , secret ID ) } return extract ASMValue ( out ) } 
func Get Secret From ASM ( secret ID string , client secretsmanageriface . Secrets Manager API ) ( string , error ) { in : = & secretsmanager . Get Secret Value Input { Secret Id : aws . String ( secret ID ) , } out , err : = client . Get Secret Value ( in ) if err ! = nil { return " " , errors . Wrapf ( err , " " , secret ID ) } return aws . String Value ( out . Secret String ) , nil } 
func New Mock Cgroup Factory ( ctrl * gomock . Controller ) * Mock Cgroup Factory { mock : = & Mock Cgroup Factory { ctrl : ctrl } mock . recorder = & Mock Cgroup Factory Mock Recorder { mock } return mock } 
func ( m * Mock Cgroup Factory ) Load ( arg 0 cgroups . Hierarchy , arg 1 cgroups . Path ) ( cgroups . Cgroup , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( cgroups . Cgroup ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Cgroup Factory Mock Recorder ) Load ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Cgroup Factory ) ( nil ) . Load ) , arg 0 , arg 1 ) } 
func ( m * Mock Cgroup Factory ) New ( arg 0 cgroups . Hierarchy , arg 1 cgroups . Path , arg 2 * specs _go . Linux Resources ) ( cgroups . Cgroup , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( cgroups . Cgroup ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( * loader ) Load Image ( ctx context . Context , cfg * config . Config , docker Client dockerapi . Docker Client ) ( * types . Image Inspect , error ) { log . Debugf ( " " , cfg . Pause Container Tarball Path ) if err : = load From File ( ctx , cfg . Pause Container Tarball Path , docker Client , os . Default ) ; err ! = nil { return nil , err } return get Pause Container Image ( config . Default Pause Container Image Name , config . Default Pause Container Tag , docker Client ) } 
func New Cgroup Resource ( task ARN string , control control . Control , ioutil ioutilwrapper . IOUtil , cgroup Root string , cgroup Mount Path string , resource Spec specs . Linux Resources ) * Cgroup Resource { c : = & Cgroup Resource { task ARN : task ARN , control : control , ioutil : ioutil , cgroup Root : cgroup Root , cgroup Mount Path : cgroup Mount Path , resource Spec : resource Spec , } c . initialize Resource Status To Transition Function ( ) return c } 
func ( cgroup * Cgroup Resource ) Set Desired Status ( status resourcestatus . Resource Status ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . desired Status Unsafe = status } 
func ( cgroup * Cgroup Resource ) Get Desired Status ( ) resourcestatus . Resource Status { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . desired Status Unsafe } 
func ( cgroup * Cgroup Resource ) Get Name ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return resource Name } 
func ( cgroup * Cgroup Resource ) Desired Terminal ( ) bool { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . desired Status Unsafe = = resourcestatus . Resource Status ( Cgroup Removed ) } 
func ( cgroup * Cgroup Resource ) Known Created ( ) bool { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . known Status Unsafe = = resourcestatus . Resource Status ( Cgroup Created ) } 
func ( cgroup * Cgroup Resource ) Apply Transition ( next State resourcestatus . Resource Status ) error { transition Func , ok : = cgroup . status To Transitions [ next State ] if ! ok { seelog . Errorf ( " " , cgroup . task ARN , cgroup . Get Name ( ) , cgroup . Status String ( next State ) ) return errors . Errorf ( " " , cgroup . Get Name ( ) , cgroup . Status String ( next State ) ) } return transition Func ( ) } 
func ( cgroup * Cgroup Resource ) Set Known Status ( status resourcestatus . Resource Status ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . known Status Unsafe = status cgroup . update Applied Status Unsafe ( status ) } 
func ( cgroup * Cgroup Resource ) update Applied Status Unsafe ( known Status resourcestatus . Resource Status ) { if cgroup . applied Status = = resourcestatus . Resource Status ( Cgroup Status None ) { return } } } 
func ( cgroup * Cgroup Resource ) Set Applied Status ( status resourcestatus . Resource Status ) bool { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) if cgroup . applied Status ! = resourcestatus . Resource Status ( Cgroup Status None ) { } cgroup . applied Status = status return true } 
func ( cgroup * Cgroup Resource ) Get Known Status ( ) resourcestatus . Resource Status { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . known Status Unsafe } 
func ( cgroup * Cgroup Resource ) Status String ( status resourcestatus . Resource Status ) string { return Cgroup Status ( status ) . String ( ) } 
func ( cgroup * Cgroup Resource ) Set Created At ( created At time . Time ) { if created At . Is Zero ( ) { return } cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . created At = created At } 
func ( cgroup * Cgroup Resource ) Get Created At ( ) time . Time { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . created At } 
func ( cgroup * Cgroup Resource ) Create ( ) error { err : = cgroup . setup Task Cgroup ( ) if err ! = nil { seelog . Criticalf ( " " , cgroup . task ARN , err ) return err } return nil } 
func ( cgroup * Cgroup Resource ) Cleanup ( ) error { err : = cgroup . control . Remove ( cgroup . cgroup Root ) return nil } return errors . Wrapf ( err , " " , cgroup . cgroup Root ) } return nil } 
func ( cgroup * Cgroup Resource ) Marshal JSON ( ) ( [ ] byte , error ) { if cgroup = = nil { return nil , errors . New ( " " ) } return json . Marshal ( cgroup Resource JSON { cgroup . cgroup Root , cgroup . cgroup Mount Path , cgroup . Get Created At ( ) , func ( ) * Cgroup Status { desired State : = cgroup . Get Desired Status ( ) status : = Cgroup Status ( desired State ) return & status } ( ) , func ( ) * Cgroup Status { known State : = cgroup . Get Known Status ( ) status : = Cgroup Status ( known State ) return & status } ( ) , cgroup . resource Spec , } ) } 
func ( cgroup * Cgroup Resource ) Unmarshal JSON ( b [ ] byte ) error { temp : = cgroup Resource JSON { } if err : = json . Unmarshal ( b , & temp ) ; err ! = nil { return err } cgroup . cgroup Root = temp . Cgroup Root cgroup . cgroup Mount Path = temp . Cgroup Mount Path cgroup . resource Spec = temp . Linux Spec if temp . Desired Status ! = nil { cgroup . Set Desired Status ( resourcestatus . Resource Status ( * temp . Desired Status ) ) } if temp . Known Status ! = nil { cgroup . Set Known Status ( resourcestatus . Resource Status ( * temp . Known Status ) ) } return nil } 
func ( cgroup * Cgroup Resource ) Get Cgroup Root ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . cgroup Root } 
func ( cgroup * Cgroup Resource ) Get Cgroup Mount Path ( ) string { cgroup . lock . RLock ( ) defer cgroup . lock . RUnlock ( ) return cgroup . cgroup Mount Path } 
func ( cgroup * Cgroup Resource ) Initialize ( resource Fields * taskresource . Resource Fields , task Known Status status . Task Status , task Desired Status status . Task Status ) { cgroup . lock . Lock ( ) defer cgroup . lock . Unlock ( ) cgroup . initialize Resource Status To Transition Function ( ) cgroup . ioutil = resource Fields . IOUtil cgroup . control = resource Fields . Control } 
func ( * loader ) Load Image ( ctx context . Context , cfg * config . Config , docker Client dockerapi . Docker Client ) ( * types . Image Inspect , error ) { return nil , New Unsupported Platform Error ( errors . Errorf ( " " , runtime . GOOS , runtime . GOARCH ) ) } 
func New ECRFactory ( accept Insecure Cert bool ) ECRFactory { return & ecr Factory { http Client : httpclient . New ( roundtrip Timeout , accept Insecure Cert ) , } } 
func ( factory * ecr Factory ) Get Client ( auth Data * apicontainer . ECRAuth Data ) ( ECRClient , error ) { client Config , err : = get Client Config ( factory . http Client , auth Data ) if err ! = nil { return & ecr Client { } , err } return factory . new Client ( client Config ) , nil } 
func get Client Config ( http Client * http . Client , auth Data * apicontainer . ECRAuth Data ) ( * aws . Config , error ) { cfg : = aws . New Config ( ) . With Region ( auth Data . Region ) . With HTTPClient ( http Client ) if auth Data . Endpoint Override ! = " " { cfg . Endpoint = aws . String ( auth Data . Endpoint Override ) } if auth Data . Use Execution Role { if auth Data . Get Pull Credentials ( ) = = ( credentials . IAMRole Credentials { } ) { return nil , fmt . Errorf ( " " ) } creds : = awscreds . New Static Credentials ( auth Data . Get Pull Credentials ( ) . Access Key ID , auth Data . Get Pull Credentials ( ) . Secret Access Key , auth Data . Get Pull Credentials ( ) . Session Token ) cfg = cfg . With Credentials ( creds ) } return cfg , nil } 
func New Mock Audit Logger ( ctrl * gomock . Controller ) * Mock Audit Logger { mock : = & Mock Audit Logger { ctrl : ctrl } mock . recorder = & Mock Audit Logger Mock Recorder { mock } return mock } 
func ( m * Mock Audit Logger ) Get Container Instance Arn ( ) string { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( string ) return ret 0 } 
func ( mr * Mock Audit Logger Mock Recorder ) Get Container Instance Arn ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Audit Logger ) ( nil ) . Get Container Instance Arn ) ) } 
func ( m * Mock Audit Logger ) Log ( arg 0 request . Log Request , arg 1 int , arg 2 string ) { m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) } 
func ( mr * Mock Audit Logger Mock Recorder ) Log ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Audit Logger ) ( nil ) . Log ) , arg 0 , arg 1 , arg 2 ) } 
func New Mock Info Logger ( ctrl * gomock . Controller ) * Mock Info Logger { mock : = & Mock Info Logger { ctrl : ctrl } mock . recorder = & Mock Info Logger Mock Recorder { mock } return mock } 
func ( m * Mock Info Logger ) Info ( arg 0 . . . interface { } ) { varargs : = [ ] interface { } { } for _ , a : = range arg 0 { varargs = append ( varargs , a ) } m . ctrl . Call ( m , " " , varargs . . . ) } 
func ( mr * Mock Info Logger Mock Recorder ) Info ( arg 0 . . . interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Info Logger ) ( nil ) . Info ) , arg 0 . . . ) } 
func ( te * tcs Error ) New Error ( err interface { } ) * wsclient . WSError { return & wsclient . WSError { Err Obj : err , Type : err Type , WSUnretriable Errors : & Unretriable Errors { } } } 
func ( event * sendable Event ) task Should Be Sent ( ) bool { event . lock . RLock ( ) defer event . lock . RUnlock ( ) if event . is Container Event { return false } tevent : = event . task Change if event . task Sent { return false } } } if container . Get Sent Status ( ) < container . Get Known Status ( ) { } } return false } 
func ( event * sendable Event ) send ( send Status To ECS send Status Change To ECS , set Change Sent set Status Sent , event Type string , client api . ECSClient , event To Submit * list . Element , state Saver statemanager . Saver , backoff retry . Backoff , task Events * task Sendable Events ) error { seelog . Infof ( " " , event Type , event . to String ( ) ) return err } seelog . Debugf ( " " , event . to String ( ) ) task Events . events . Remove ( event To Submit ) backoff . Reset ( ) return nil } 
func send Container Status To ECS ( client api . ECSClient , event * sendable Event ) error { return client . Submit Container State Change ( event . container Change ) } 
func send Task Status To ECS ( client api . ECSClient , event * sendable Event ) error { return client . Submit Task State Change ( event . task Change ) } 
func set Container Change Sent ( event * sendable Event ) { container Change Status : = event . container Change . Status container : = event . container Change . Container if container ! = nil & & container . Get Sent Status ( ) < container Change Status { container . Set Sent Status ( container Change Status ) } } 
func set Task Change Sent ( event * sendable Event ) { task Change Status : = event . task Change . Status task : = event . task Change . Task if task ! = nil & & task . Get Sent Status ( ) < task Change Status { task . Set Sent Status ( task Change Status ) } for _ , container State Change : = range event . task Change . Containers { container : = container State Change . Container container Change Status : = container State Change . Status if container . Get Sent Status ( ) < container Change Status { container . Set Sent Status ( container State Change . Status ) } } } 
func set Task Attachment Sent ( event * sendable Event ) { if event . task Change . Attachment ! = nil { event . task Change . Attachment . Set Sent Status ( ) event . task Change . Attachment . Stop Ack Timer ( ) } } 
func Get Secrets From SSM ( names [ ] string , client SSMClient ) ( map [ string ] string , error ) { var secret Names [ ] * string for _ , name : = range names { secret Names = append ( secret Names , aws . String ( name ) ) } in : = & ssm . Get Parameters Input { Names : secret Names , With Decryption : aws . Bool ( true ) , } out , err : = client . Get Parameters ( in ) if err ! = nil { return nil , err } return extract SSMValues ( out ) } 
func main ( ) { version Str , _ : = ioutil . Read File ( filepath . Join ( " " , " " , " " ) ) if strings . Trim Space ( os . Getenv ( " " ) ) = = " " { } if os . Getenv ( " " ) = = " " { } out File , err : = os . Create ( " " ) if err ! = nil { log . Fatalf ( " " , err ) } t : = template . Must ( template . New ( " " ) . Parse ( versiongo Template ) ) err = t . Execute ( out File , info ) if err ! = nil { log . Fatalf ( " " , err ) } } 
func new Association Response ( task ARN , association Type , association Name string , state dockerstate . Task Engine State ) ( string , error ) { task , ok : = state . Task By Arn ( task ARN ) if ! ok { return " " , errors . Errorf ( " " , task ARN ) } association , ok : = task . Association By Type And Name ( association Type , association Name ) if ! ok { return " " , errors . Errorf ( " " , association Type , association Name ) } return association . Content . Value , nil } 
func ( err Cannot Stop Container Error ) Is Retriable Error ( ) bool { if _ , ok : = err . From Error . ( No Such Container Error ) ; ok { return false } return true } 
func New Mock File ( ctrl * gomock . Controller ) * Mock File { mock : = & Mock File { ctrl : ctrl } mock . recorder = & Mock File Mock Recorder { mock } return mock } 
func ( m * Mock File ) Chmod ( arg 0 os . File Mode ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock File Mock Recorder ) Chmod ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock File ) ( nil ) . Chmod ) , arg 0 ) } 
func ( mr * Mock File Mock Recorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock File ) ( nil ) . Close ) ) } 
func ( m * Mock File ) Write ( arg 0 [ ] byte ) ( int , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( int ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock OS ( ctrl * gomock . Controller ) * Mock OS { mock : = & Mock OS { ctrl : ctrl } mock . recorder = & Mock OSMock Recorder { mock } return mock } 
func ( m * Mock OS ) Create ( arg 0 string ) ( oswrapper . File , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( oswrapper . File ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock OSMock Recorder ) Create ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock OS ) ( nil ) . Create ) , arg 0 ) } 
func ( m * Mock OS ) Is Not Exist ( arg 0 error ) bool { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( m * Mock OS ) Open File ( arg 0 string , arg 1 int , arg 2 os . File Mode ) ( oswrapper . File , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( oswrapper . File ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock OS ) Remove All ( arg 0 string ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func New Mock SSMClient Creator ( ctrl * gomock . Controller ) * Mock SSMClient Creator { mock : = & Mock SSMClient Creator { ctrl : ctrl } mock . recorder = & Mock SSMClient Creator Mock Recorder { mock } return mock } 
func ( m * Mock SSMClient Creator ) New SSMClient ( arg 0 string , arg 1 credentials . IAMRole Credentials ) ssm . SSMClient { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( ssm . SSMClient ) return ret 0 } 
func ( mr * Mock SSMClient Creator Mock Recorder ) New SSMClient ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock SSMClient Creator ) ( nil ) . New SSMClient ) , arg 0 , arg 1 ) } 
func New Mock EC 2Metadata Client ( ctrl * gomock . Controller ) * Mock EC 2Metadata Client { mock : = & Mock EC 2Metadata Client { ctrl : ctrl } mock . recorder = & Mock EC 2Metadata Client Mock Recorder { mock } return mock } 
func ( m * Mock EC 2Metadata Client ) Default Credentials ( ) ( * ec 2 . Role Credentials , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( * ec 2 . Role Credentials ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock EC 2Metadata Client Mock Recorder ) Default Credentials ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock EC 2Metadata Client ) ( nil ) . Default Credentials ) ) } 
func ( m * Mock EC 2Metadata Client ) Get Dynamic Data ( arg 0 string ) ( string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock EC 2Metadata Client Mock Recorder ) Get Metadata ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock EC 2Metadata Client ) ( nil ) . Get Metadata ) , arg 0 ) } 
func ( m * Mock EC 2Metadata Client ) Instance Identity Document ( ) ( ec 2metadata . EC 2Instance Identity Document , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( ec 2metadata . EC 2Instance Identity Document ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock Http Client ( ctrl * gomock . Controller ) * Mock Http Client { mock : = & Mock Http Client { ctrl : ctrl } mock . recorder = & Mock Http Client Mock Recorder { mock } return mock } 
func ( m * Mock Http Client ) Get Instance Identity Document ( ) ( ec 2metadata . EC 2Instance Identity Document , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( ec 2metadata . EC 2Instance Identity Document ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Http Client Mock Recorder ) Get Metadata ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Http Client ) ( nil ) . Get Metadata ) , arg 0 ) } 
func ( m * Mock Http Client ) Get User Data ( ) ( string , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Http Client Mock Recorder ) Get User Data ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Http Client ) ( nil ) . Get User Data ) ) } 
func New Mock Client ( ctrl * gomock . Controller ) * Mock Client { mock : = & Mock Client { ctrl : ctrl } mock . recorder = & Mock Client Mock Recorder { mock } return mock } 
func ( m * Mock Client ) Describe ECSTags For Instance ( arg 0 string ) ( [ ] * ecs . Tag , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( [ ] * ecs . Tag ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock Client SDK ( ctrl * gomock . Controller ) * Mock Client SDK { mock : = & Mock Client SDK { ctrl : ctrl } mock . recorder = & Mock Client SDKMock Recorder { mock } return mock } 
func ( m * Mock Client SDK ) Create Tags ( arg 0 * ec 2 0 . Create Tags Input ) ( * ec 2 0 . Create Tags Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ec 2 0 . Create Tags Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client SDK ) Describe Tags ( arg 0 * ec 2 0 . Describe Tags Input ) ( * ec 2 0 . Describe Tags Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ec 2 0 . Describe Tags Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Client SDKMock Recorder ) Describe Tags ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Client SDK ) ( nil ) . Describe Tags ) , arg 0 ) } 
func New State Manager ( cfg * config . Config , options . . . Option ) ( State Manager , error ) { fi , err : = os . Stat ( cfg . Data Dir ) if err ! = nil { return nil , err } if ! fi . Is Dir ( ) { return nil , errors . New ( " " ) } state : = & state { Data : make ( saveable State ) , Version : ECSData Version , } manager : = & basic State Manager { state Path : cfg . Data Dir , state : state , } for _ , option : = range options { option ( manager ) } manager . platform Dependencies = new Platform Dependencies ( ) return manager , nil } 
func Add Saveable ( name string , saveable Saveable ) Option { return ( Option ) ( func ( m State Manager ) { manager , ok : = m . ( * basic State Manager ) if ! ok { log . Crit ( " " ) return } manager . state . Data [ name ] = & saveable } ) } 
func ( manager * basic State Manager ) Save ( ) error { defer metrics . Metrics Engine Global . Record State Manager Metric ( " " ) ( ) manager . save Times Lock . Lock ( ) defer manager . save Times Lock . Unlock ( ) if time . Since ( manager . last Save ) > = min Save Interval { manager . last Save = time . Now ( ) manager . next Planned Save = time . Time { } return err } else if manager . next Planned Save . Is Zero ( ) { manager . next Planned Save = next go func ( ) { time . Sleep ( next . Sub ( time . Now ( ) ) ) manager . Save ( ) } ( ) } } 
func ( manager * basic State Manager ) Force Save ( ) error { manager . saving Lock . Lock ( ) defer manager . saving Lock . Unlock ( ) log . Info ( " " ) s : = manager . state s . Version = ECSData Version data , err : = json . Marshal ( s ) if err ! = nil { log . Error ( " " , " " , err ) return err } return manager . write File ( data ) } 
func ( manager * basic State Manager ) Load ( ) error { s : = manager . state log . Info ( " " ) data , err : = manager . read File ( ) if err ! = nil { log . Error ( " " , " " , err ) return err } if data = = nil { return nil } if err ! = nil { return err } err = json . Unmarshal ( data , & intermediate ) if err ! = nil { log . Debug ( " " ) return err } for key , raw JSON : = range intermediate . Data { actual Pointer , ok : = manager . state . Data [ key ] if ! ok { log . Error ( " " + key ) continue } err = json . Unmarshal ( raw JSON , actual Pointer ) if err ! = nil { log . Debug ( " " ) return err } } log . Debug ( " " , " " , s ) return nil } 
func Valid Dependencies ( task * apitask . Task ) bool { unresolved : = make ( [ ] * apicontainer . Container , len ( task . Containers ) ) resolved : = make ( [ ] * apicontainer . Container , 0 , len ( task . Containers ) ) copy ( unresolved , task . Containers ) Outer Loop : for len ( unresolved ) > 0 { for i , try Resolve : = range unresolved { if dependencies Can Be Resolved ( try Resolve , resolved ) { resolved = append ( resolved , try Resolve ) unresolved = append ( unresolved [ : i ] , unresolved [ i + 1 : ] . . . ) } } log . Warnf ( " " , unresolved , task ) return false } return true } 
func dependencies Can Be Resolved ( target * apicontainer . Container , by [ ] * apicontainer . Container ) bool { name Map : = make ( map [ string ] * apicontainer . Container ) for _ , cont : = range by { name Map [ cont . Name ] = cont } if _ , err : = verify Container Ordering Status Resolvable ( target , name Map , container Ordering Dependencies Can Resolve ) ; err ! = nil { return false } return verify Status Resolvable ( target , name Map , target . Steady State Dependencies , on Steady State Can Resolve ) } 
func Dependencies Are Resolved ( target * apicontainer . Container , by [ ] * apicontainer . Container , id string , manager credentials . Manager , resources [ ] taskresource . Task Resource ) ( * apicontainer . Depends On , error ) { if ! execution Credentials Resolved ( target , id , manager ) { return nil , Credentials Not Resolved Err } name Map : = make ( map [ string ] * apicontainer . Container ) for _ , cont : = range by { name Map [ cont . Name ] = cont } needed Volume Containers : = make ( [ ] string , len ( target . Volumes From ) ) for i , volume : = range target . Volumes From { needed Volume Containers [ i ] = volume . Source Container } resources Map : = make ( map [ string ] taskresource . Task Resource ) for _ , resource : = range resources { resources Map [ resource . Get Name ( ) ] = resource } if blocked , err : = verify Container Ordering Status Resolvable ( target , name Map , container Ordering Dependencies Is Resolved ) ; err ! = nil { return blocked , err } if ! verify Status Resolvable ( target , name Map , target . Steady State Dependencies , on Steady State Is Resolved ) { return nil , Dependent Container Not Resolved Err } if err : = verify Transition Dependencies Resolved ( target , name Map , resources Map ) ; err ! = nil { return nil , err } } } return nil , nil } 
func verify Status Resolvable ( target * apicontainer . Container , existing Containers map [ string ] * apicontainer . Container , dependencies [ ] string , resolves func ( * apicontainer . Container , * apicontainer . Container ) bool ) bool { target Goal : = target . Get Desired Status ( ) if target Goal ! = target . Get Steady State Status ( ) & & target Goal ! = apicontainerstatus . Container Created { } for _ , dependency : = range dependencies { maybe Resolves , exists : = existing Containers [ dependency ] if ! exists { return false } if ! resolves ( target , maybe Resolves ) { return false } } return true } 
func verify Container Ordering Status Resolvable ( target * apicontainer . Container , existing Containers map [ string ] * apicontainer . Container , resolves func ( * apicontainer . Container , * apicontainer . Container , string ) bool ) ( * apicontainer . Depends On , error ) { target Goal : = target . Get Desired Status ( ) target Known : = target . Get Known Status ( ) if target Goal ! = target . Get Steady State Status ( ) & & target Goal ! = apicontainerstatus . Container Created { } for _ , dependency : = range target . Depends On { dependency Container , ok : = existing Containers [ dependency . Container Name ] if ! ok { return nil , fmt . Errorf ( " " , dependency Container , target ) } } } } } if ! resolves ( target , dependency Container , dependency . Condition ) { return & dependency , fmt . Errorf ( " " , dependency Container , target ) } } return nil , nil } 
func on Steady State Is Resolved ( target * apicontainer . Container , run * apicontainer . Container ) bool { return target . Get Desired Status ( ) > = apicontainerstatus . Container Created & & run . Get Known Status ( ) > = run . Get Steady State Status ( ) } 
func new Agent ( ctx context . Context , blackhole EC 2Metadata bool , accept Insecure Cert * bool ) ( agent , error ) { ec 2Metadata Client : = ec 2 . New EC 2Metadata Client ( nil ) if blackhole EC 2Metadata { ec 2Metadata Client = ec 2 . New Blackhole EC 2Metadata Client ( ) } seelog . Info ( " " ) cfg , err : = config . New Config ( ec 2Metadata Client ) if err ! = nil { return nil , err } cfg . Accept Insecure Cert = aws . Bool Value ( accept Insecure Cert ) if cfg . Accept Insecure Cert { seelog . Warn ( " " ) } seelog . Infof ( " " , version . Version , version . Git Short Hash ) seelog . Debugf ( " " , cfg . String ( ) ) ec 2Client : = ec 2 . New Client Impl ( cfg . AWSRegion ) docker Client , err : = dockerapi . New Docker Go Client ( sdkclientfactory . New Factory ( ctx , cfg . Docker Endpoint ) , cfg , ctx ) if err ! = nil { return nil , err } var metadata Manager containermetadata . Manager if cfg . Container Metadata Enabled { } return & ecs Agent { ctx : ctx , ec 2Metadata Client : ec 2Metadata Client , ec 2Client : ec 2Client , cfg : cfg , docker Client : docker Client , } 
func ( agent * ecs Agent ) print ECSAttributes ( ) int { capabilities , err : = agent . capabilities ( ) if err ! = nil { seelog . Warnf ( " " , err ) return exitcodes . Exit Error } for _ , attr : = range capabilities { fmt . Printf ( " \t \n " , aws . String Value ( attr . Name ) , aws . String Value ( attr . Value ) ) } return exitcodes . Exit Success } 
func ( agent * ecs Agent ) start ( ) int { sighandlers . Start Debug Handler ( ) container Change Event Stream : = eventstream . New Event Stream ( container Change Event Stream Name , agent . ctx ) credentials Manager : = credentials . New Manager ( ) state : = dockerstate . New Task Engine State ( ) image Manager : = engine . New Image Manager ( agent . cfg , agent . docker Client , state ) client : = ecsclient . New ECSClient ( agent . credential Provider , agent . cfg , agent . ec 2Metadata Client ) agent . initialize Resource Fields ( credentials Manager ) return agent . do Start ( container Change Event Stream , credentials Manager , state , image Manager , client ) } 
func ( agent * ecs Agent ) do Start ( container Change Event Stream * eventstream . Event Stream , credentials Manager credentials . Manager , state dockerstate . Task Engine State , image Manager engine . Image Manager , client api . ECSClient ) int { } return exitcodes . Exit Terminal } } if agent . cfg . GPUSupport Enabled { err : = agent . initialize GPUManager ( ) if err ! = nil { seelog . Criticalf ( " " , err ) return exitcodes . Exit Error } } if err ! = nil { return exitcodes . Exit Terminal } agent . init Metrics Engine ( ) if err ! = nil { seelog . Criticalf ( " " , err ) return exitcodes . Exit Terminal } var vpc Subnet Attributes [ ] * ecs . Attribute switch err { case nil : case instance Not Launched In VPCError : agent . cfg . Task ENIEnabled = false default : if terminal { return exitcodes . Exit Terminal } return exitcodes . Exit Error } } if err ! = nil { if is Transient ( err ) { return exitcodes . Exit Error } return exitcodes . Exit Terminal } agent . metadata Manager . Set Availability Zone ( agent . availability Zone ) agent . metadata Manager . Set Host Public IPv 4Address ( agent . get Host Public IPv 4Address From EC 2Metadata ( ) ) } image Manager . Set Saver ( state Manager ) task Engine . Must Init ( agent . ctx ) deregister Instance Event Stream . Start Listening ( ) task Handler : = eventhandler . New Task Handler ( agent . ctx , state Manager , state , client ) agent . start Async Routines ( container Change Event Stream , credentials Manager , image Manager , task Engine , state Manager , deregister Instance Event Stream , client , task Handler , state ) } 
func ( agent * ecs Agent ) new Task Engine ( container Change Event Stream * eventstream . Event Stream , credentials Manager credentials . Manager , state dockerstate . Task Engine State , image Manager engine . Image Manager ) ( engine . Task Engine , string , error ) { container Change Event Stream . Start Listening ( ) if ! agent . cfg . Checkpoint { seelog . Info ( " " ) return engine . New Task Engine ( agent . cfg , agent . docker Client , credentials Manager , container Change Event Stream , image Manager , state , agent . metadata Manager , agent . resource Fields ) , " " , nil } previous Task Engine : = engine . New Task Engine ( agent . cfg , agent . docker Client , credentials Manager , container Change Event Stream , image Manager , state , agent . metadata Manager , agent . resource Fields ) if err ! = nil { seelog . Criticalf ( " " , err ) return nil , " " , err } err = previous State Manager . Load ( ) if err ! = nil { seelog . Criticalf ( " " , err ) return nil , " " , err } err = agent . check Compatibility ( previous Task Engine ) if err ! = nil { seelog . Criticalf ( " " , err ) return nil , " " , err } current EC 2Instance ID : = agent . get EC 2Instance ID ( ) if previous EC 2Instance ID ! = " " & & previous EC 2Instance ID ! = current EC 2Instance ID { seelog . Warnf ( instance IDMismatch Error Format , previous EC 2Instance ID , current EC 2Instance ID ) } if previous Cluster ! = " " { if err : = agent . set Cluster In Config ( previous Cluster ) ; err ! = nil { return nil , " " , err } } return previous Task Engine , current EC 2Instance ID , nil } 
func ( agent * ecs Agent ) set Cluster In Config ( previous Cluster string ) error { if configured Cluster = = " " { seelog . Debug ( " " ) configured Cluster = config . Default Cluster Name } if previous Cluster ! = configured Cluster { err : = cluster Mismatch Error { fmt . Errorf ( cluster Mismatch Error Format , previous Cluster , configured Cluster ) , } seelog . Criticalf ( " " , err ) return err } agent . cfg . Cluster = previous Cluster seelog . Infof ( " " , agent . cfg . Cluster ) return nil } 
func ( agent * ecs Agent ) get EC 2Instance ID ( ) string { instance ID , err : = agent . ec 2Metadata Client . Instance ID ( ) if err ! = nil { seelog . Warnf ( " " , err ) return " " } return instance ID } 
func ( agent * ecs Agent ) new State Manager ( task Engine engine . Task Engine , cluster * string , container Instance Arn * string , saved Instance ID * string , availability Zone * string ) ( statemanager . State Manager , error ) { if ! agent . cfg . Checkpoint { return statemanager . New Noop State Manager ( ) , nil } return agent . state Manager Factory . New State Manager ( agent . cfg , statemanager . Add Saveable ( " " , task Engine ) , } 
func ( agent * ecs Agent ) construct VPCSubnet Attributes ( ) [ ] * ecs . Attribute { return [ ] * ecs . Attribute { { Name : aws . String ( vpc IDAttribute Name ) , Value : aws . String ( agent . vpc ) , } , { Name : aws . String ( subnet IDAttribute Name ) , Value : aws . String ( agent . subnet ) , } , } } 
func ( agent * ecs Agent ) register Container Instance ( state Manager statemanager . State Manager , client api . ECSClient , additional Attributes [ ] * ecs . Attribute ) error { } agent Capabilities , err : = agent . capabilities ( ) if err ! = nil { return err } capabilities : = append ( agent Capabilities , additional Attributes . . . ) if agent . cfg . Container Instance Propagate Tags From = = config . Container Instance Propagate Tags From EC 2Instance Type { ec 2Tags , err : = agent . get Container Instance Tags From EC 2API ( ) } seelog . Infof ( " \n " , ec 2Tags ) tags = merge Tags ( tags , ec 2Tags ) } platform Devices : = agent . get Platform Devices ( ) if agent . container Instance ARN ! = " " { seelog . Infof ( " " , agent . container Instance ARN , agent . cfg . Cluster ) return agent . reregister Container Instance ( client , capabilities , tags , uuid . New ( ) , platform Devices ) } seelog . Info ( " " ) container Instance Arn , availability Zone , err : = client . Register Container Instance ( " " , capabilities , tags , uuid . New ( ) , platform Devices ) if err ! = nil { seelog . Errorf ( " " , err ) if retriable , ok : = err . ( apierrors . Retriable ) ; ok & & ! retriable . Retry ( ) { return err } if utils . Is AWSError Code Equal ( err , ecs . Err Code Invalid Parameter Exception ) { seelog . Critical ( " " ) return err } if _ , ok : = err . ( apierrors . Attribute Error ) ; ok { seelog . Critical ( " " ) return err } return transient Error { err } } seelog . Infof ( " " , container Instance Arn , agent . cfg . Cluster ) agent . container Instance ARN = container Instance Arn agent . availability Zone = availability Zone return nil } 
func ( agent * ecs Agent ) reregister Container Instance ( client api . ECSClient , capabilities [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registration Token string , platform Devices [ ] * ecs . Platform Device ) error { _ , availability Zone , err : = client . Register Container Instance ( agent . container Instance ARN , capabilities , tags , registration Token , platform Devices ) if err = = nil { return nil } seelog . Errorf ( " " , err ) if apierrors . Is Instance Type Changed Error ( err ) { seelog . Criticalf ( instance Type Mismatch Error Format , err ) return err } if _ , ok : = err . ( apierrors . Attribute Error ) ; ok { seelog . Critical ( " " ) return err } return transient Error { err } } 
func ( agent * ecs Agent ) start Async Routines ( container Change Event Stream * eventstream . Event Stream , credentials Manager credentials . Manager , image Manager engine . Image Manager , task Engine engine . Task Engine , state Manager statemanager . State Manager , deregister Instance Event Stream * eventstream . Event Stream , client api . ECSClient , task Handler * eventhandler . Task Handler , state dockerstate . Task Engine State ) { } go agent . termination Handler ( state Manager , task Engine ) stats Engine : = stats . New Docker Stats Engine ( agent . cfg , agent . docker Client , container Change Event Stream ) } else { go handlers . Serve Task HTTPEndpoint ( credentials Manager , state , client , agent . container Instance ARN , agent . cfg , stats Engine , agent . availability Zone ) } telemetry Session Params : = tcshandler . Telemetry Session Params { Ctx : agent . ctx , Credential Provider : agent . credential Provider , Cfg : agent . cfg , Container Instance Arn : agent . container Instance ARN , Deregister Instance Event Stream : deregister Instance Event Stream , ECSClient : client , Task Engine : task Engine , Stats Engine : stats Engine , } } 
func ( agent * ecs Agent ) start ACSSession ( credentials Manager credentials . Manager , task Engine engine . Task Engine , state Manager statemanager . State Manager , deregister Instance Event Stream * eventstream . Event Stream , client api . ECSClient , state dockerstate . Task Engine State , task Handler * eventhandler . Task Handler ) int { acs Session : = acshandler . New Session ( agent . ctx , agent . cfg , deregister Instance Event Stream , agent . container Instance ARN , agent . credential Provider , client , state , state Manager , task Engine , credentials Manager , task Handler , ) seelog . Info ( " " ) err : = acs Session . Start ( ) if err ! = nil { seelog . Criticalf ( " " , err ) return exitcodes . Exit Terminal } seelog . Critical ( " " ) return exitcodes . Exit Error } 
func ( agent * ecs Agent ) verify Required Docker Version ( ) ( int , bool ) { supported Versions : = agent . docker Client . Supported Versions ( ) if len ( supported Versions ) = = 0 { seelog . Critical ( " " ) return exitcodes . Exit Error , false } } } return exitcodes . Exit Terminal , false } 
func ( agent * ecs Agent ) get Container Instance Tags From EC 2API ( ) ( [ ] * ecs . Tag , error ) { if err ! = nil { return nil , err } return agent . ec 2Client . Describe ECSTags For Instance ( instance ID ) } 
func merge Tags ( local Tags [ ] * ecs . Tag , ec 2Tags [ ] * ecs . Tag ) [ ] * ecs . Tag { tags Map : = make ( map [ string ] string ) for _ , ec 2Tag : = range ec 2Tags { tags Map [ aws . String Value ( ec 2Tag . Key ) ] = aws . String Value ( ec 2Tag . Value ) } for _ , local Tag : = range local Tags { tags Map [ aws . String Value ( local Tag . Key ) ] = aws . String Value ( local Tag . Value ) } return utils . Map To Tags ( tags Map ) } 
func ( agent * ecs Agent ) get Host Public IPv 4Address From EC 2Metadata ( ) string { if err ! = nil { seelog . Errorf ( " " , err ) return " " } return host Public IPv 4Address } 
func Slices Deep Equal ( slice 1 , slice 2 interface { } ) bool { s 1 : = reflect . Value Of ( slice 1 ) s 2 : = reflect . Value Of ( slice 2 ) if s 1 . Len ( ) ! = s 2 . Len ( ) { return false } if s 1 . Len ( ) = = 0 { return true } s 2found : = make ( [ ] int , s 2 . Len ( ) ) Outer Loop : for i : = 0 ; i < s 1 . Len ( ) ; i + + { s 1el : = s 1 . Slice ( i , i + 1 ) for j : = 0 ; j < s 2 . Len ( ) ; j + + { if s 2found [ j ] = = 1 { } s 2el : = s 2 . Slice ( j , j + 1 ) if reflect . Deep Equal ( s 1el . Interface ( ) , s 2el . Interface ( ) ) { s 2found [ j ] = 1 continue Outer Loop } } } return true } 
func Uint 1 6Slice To String Slice ( slice [ ] uint 1 6 ) [ ] * string { string Slice : = make ( [ ] * string , len ( slice ) ) for i , el : = range slice { str : = strconv . Itoa ( int ( el ) ) string Slice [ i ] = & str } return string Slice } 
func Is AWSError Code Equal ( err error , code string ) bool { aws Err , ok : = err . ( awserr . Error ) return ok & & aws Err . Code ( ) = = code } 
func Map To Tags ( tags Map map [ string ] string ) [ ] * ecs . Tag { tags : = make ( [ ] * ecs . Tag , 0 ) if tags Map = = nil { return tags } for key , value : = range tags Map { tags = append ( tags , & ecs . Tag { Key : aws . String ( key ) , Value : aws . String ( value ) , } ) } return tags } 
func Credentials Handler Impl ( w http . Response Writer , r * http . Request , audit Logger audit . Audit Logger , credentials Manager credentials . Manager , credentials ID string , err Prefix string ) { response JSON , arn , role Type , error Message , err : = process Credentials Request ( credentials Manager , r , credentials ID , err Prefix ) if err ! = nil { err Response JSON , _ : = json . Marshal ( error Message ) write Credentials Request Response ( w , r , error Message . HTTPError Code , audit . Get Credentials Event Type ( role Type ) , arn , audit Logger , err Response JSON ) return } write Credentials Request Response ( w , r , http . Status OK , audit . Get Credentials Event Type ( role Type ) , arn , audit Logger , response JSON ) } 
func process Credentials Request ( credentials Manager credentials . Manager , r * http . Request , credentials ID string , err Prefix string ) ( [ ] byte , string , string , * handlersutils . Error Message , error ) { if credentials ID = = " " { err Text : = err Prefix + " " seelog . Infof ( " " , err Text , r . Remote Addr ) msg : = & handlersutils . Error Message { Code : Err No IDIn Request , Message : err Text , HTTPError Code : http . Status Bad Request , } return nil , " " , " " , msg , errors . New ( err Text ) } credentials , ok : = credentials Manager . Get Task Credentials ( credentials ID ) if ! ok { err Text : = err Prefix + " " seelog . Infof ( " " , err Text , r . Remote Addr ) msg : = & handlersutils . Error Message { Code : Err Invalid IDIn Request , Message : err Text , HTTPError Code : http . Status Bad Request , } return nil , " " , " " , msg , errors . New ( err Text ) } if utils . Zero Or Nil ( credentials . ARN ) & & utils . Zero Or Nil ( credentials . IAMRole Credentials ) { seelog . Infof ( " " , err Text , r . Remote Addr ) msg : = & handlersutils . Error Message { Code : Err Credentials Uninitialized , Message : err Text , HTTPError Code : http . Status Service Unavailable , } return nil , " " , " " , msg , errors . New ( err Text ) } credentials JSON , err : = json . Marshal ( credentials . IAMRole Credentials ) if err ! = nil { err Text : = err Prefix + " " seelog . Errorf ( " " , err Text , r . Remote Addr ) msg : = & handlersutils . Error Message { Code : Err Internal Server , Message : " " , HTTPError Code : http . Status Internal Server Error , } return nil , " " , " " , msg , errors . New ( err Text ) } } 
func New Task Handler ( ctx context . Context , state Manager statemanager . Saver , state dockerstate . Task Engine State , client api . ECSClient ) * Task Handler { go task Handler . start Drain Events Ticker ( ) return task Handler } 
func ( handler * Task Handler ) Add State Change Event ( change statechange . Event , client api . ECSClient ) error { handler . lock . Lock ( ) defer handler . lock . Unlock ( ) switch change . Get Event Type ( ) { case statechange . Task Event : event , ok : = change . ( api . Task State Change ) if ! ok { return errors . New ( " " ) } return nil case statechange . Container Event : event , ok : = change . ( api . Container State Change ) if ! ok { return errors . New ( " " ) } handler . batch Container Event Unsafe ( event ) return nil default : return errors . New ( " " ) } } 
func ( handler * Task Handler ) start Drain Events Ticker ( ) { derived Ctx , cancel : = context . With Cancel ( handler . ctx ) defer cancel ( ) ticker : = utils . New Jittered Ticker ( derived Ctx , handler . min Drain Events Frequency , handler . max Drain Events Frequency ) for { select { case < - handler . ctx . Done ( ) : seelog . Infof ( " " ) return case < - ticker : } } } } 
func ( handler * Task Handler ) task State Changes To Send ( ) [ ] api . Task State Change { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) var events [ ] api . Task State Change for task ARN : = range handler . tasks To Container States { if known Status > = apitaskstatus . Task Stopped { continue } event : = api . Task State Change { Task ARN : task ARN , Status : task . Get Known Status ( ) , Task : task , } event . Set Task Timestamps ( ) events = append ( events , event ) } } return events } 
func ( handler * Task Handler ) batch Container Event Unsafe ( event api . Container State Change ) { seelog . Infof ( " " , event . String ( ) ) handler . tasks To Container States [ event . Task Arn ] = append ( handler . tasks To Container States [ event . Task Arn ] , event ) } 
func ( handler * Task Handler ) flush Batch Unsafe ( task State Change * api . Task State Change , client api . ECSClient ) { task State Change . Containers = append ( task State Change . Containers , handler . tasks To Container States [ task State Change . Task ARN ] . . . ) task Events : = handler . get Task Events Unsafe ( event ) } 
func ( handler * Task Handler ) get Task Events Unsafe ( event * sendable Event ) * task Sendable Events { task ARN : = event . task Arn ( ) task Events , ok : = handler . tasks To Events [ task ARN ] if ! ok { handler . tasks To Events [ task ARN ] = task Events seelog . Debugf ( " " , event . to String ( ) , task Events . to String Unsafe ( ) ) } return task Events } 
func ( handler * Task Handler ) submit Task Events ( task Events * task Sendable Events , client api . ECSClient , task ARN string ) { defer metrics . Metrics Engine Global . Record ECSClient Metric ( " " ) ( ) defer handler . remove Task Events ( task ARN ) backoff : = retry . New Exponential Backoff ( submit State Backoff Min , submit State Backoff Max , submit State Backoff Jitter Multiple , submit State Backoff Multiple ) retry . Retry With Backoff ( backoff , func ( ) error { handler . submit Semaphore . Wait ( ) defer handler . submit Semaphore . Post ( ) var err error done , err = task Events . submit First Event ( handler , backoff ) return err } ) } } 
func ( task Events * task Sendable Events ) send Change ( change * sendable Event , client api . ECSClient , handler * Task Handler ) { task Events . lock . Lock ( ) defer task Events . lock . Unlock ( ) task Events . events . Push Back ( change ) if ! task Events . sending { go handler . submit Task Events ( task Events , client , change . task Arn ( ) ) } else { seelog . Debugf ( " " , change . to String ( ) ) } } 
func ( task Events * task Sendable Events ) submit First Event ( handler * Task Handler , backoff retry . Backoff ) ( bool , error ) { seelog . Debug ( " " ) task Events . lock . Lock ( ) defer task Events . lock . Unlock ( ) seelog . Debugf ( " " , task Events . to String Unsafe ( ) ) if task Events . events . Len ( ) = = 0 { seelog . Debug ( " " ) task Events . sending = false return true , nil } event To Submit : = task Events . events . Front ( ) if event . container Should Be Sent ( ) { if err : = event . send ( send Container Status To ECS , set Container Change Sent , " " , handler . client , event To Submit , handler . state Saver , backoff , task Events ) ; err ! = nil { return false , err } } else if event . task Should Be Sent ( ) { if err : = event . send ( send Task Status To ECS , set Task Change Sent , " " , handler . client , event To Submit , handler . state Saver , backoff , task Events ) ; err ! = nil { handle Invalid Param Exception ( err , task Events . events , event To Submit ) return false , err } } else if event . task Attachment Should Be Sent ( ) { if err : = event . send ( send Task Status To ECS , set Task Attachment Sent , " " , handler . client , event To Submit , handler . state Saver , backoff , task Events ) ; err ! = nil { handle Invalid Param Exception ( err , task Events . events , event To Submit ) return false , err } } else { task Events . events . Remove ( event To Submit ) } if task Events . events . Len ( ) = = 0 { seelog . Debug ( " " ) task Events . sending = false return true , nil } return false , nil } 
func ( handler * Task Handler ) get Tasks To Events Len ( ) int { handler . lock . RLock ( ) defer handler . lock . RUnlock ( ) return len ( handler . tasks To Events ) } 
func handle Invalid Param Exception ( err error , events * list . List , event To Submit * list . Element ) { if utils . Is AWSError Code Equal ( err , ecs . Err Code Invalid Parameter Exception ) { event : = event To Submit . Value . ( * sendable Event ) seelog . Warnf ( " " , event . to String ( ) ) events . Remove ( event To Submit ) } } 
func New Mock Control ( ctrl * gomock . Controller ) * Mock Control { mock : = & Mock Control { ctrl : ctrl } mock . recorder = & Mock Control Mock Recorder { mock } return mock } 
func ( m * Mock Control ) Create ( arg 0 * control . Spec ) ( cgroups . Cgroup , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( cgroups . Cgroup ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Control ) Exists ( arg 0 string ) bool { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( m * Mock Control ) Init ( ) error { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock Control Mock Recorder ) Init ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Control ) ( nil ) . Init ) ) } 
func ( mr * Mock Control Mock Recorder ) Remove ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Control ) ( nil ) . Remove ) , arg 0 ) } 
func New Queue ( max Size int ) * Queue { return & Queue { buffer : make ( [ ] Usage Stats , 0 , max Size ) , max Size : max Size , } } 
func ( queue * Queue ) Reset ( ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queue . last Reset Time = time . Now ( ) queue . buffer = queue . buffer [ : 0 ] } 
func ( queue * Queue ) Add ( docker Stat * types . Stats JSON ) error { queue . set Last Stat ( docker Stat ) stat , err : = docker Stats To Container Stats ( docker Stat ) if err ! = nil { return err } queue . add ( stat ) return nil } 
func ( queue * Queue ) Get Last Stat ( ) * types . Stats JSON { queue . lock . RLock ( ) defer queue . lock . RUnlock ( ) return queue . last Stat } 
func ( queue * Queue ) Get Raw Usage Stats ( num Stats int ) ( [ ] Usage Stats , error ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queue Length : = len ( queue . buffer ) if queue Length = = 0 { return nil , fmt . Errorf ( " " ) } if num Stats > queue Length { num Stats = queue Length } usage Stats : = make ( [ ] Usage Stats , num Stats ) for i : = 0 ; i < num Stats ; i + + { usage Stats [ i ] = Usage Stats { CPUUsage Perc : raw Usage Stat . CPUUsage Perc , Memory Usage In Megs : raw Usage Stat . Memory Usage In Megs , Timestamp : raw Usage Stat . Timestamp , } } return usage Stats , nil } 
func ( queue * Queue ) get CWStats Set ( f get Usage Func ) ( * ecstcs . CWStats Set , error ) { queue . lock . Lock ( ) defer queue . lock . Unlock ( ) queue Length : = len ( queue . buffer ) if queue Length < 2 { } var min , max , sum float 6 4 var sample Count int 6 4 min = math . Max Float 6 4 max = - math . Max Float 6 4 sum = 0 sample Count = 0 for _ , stat : = range queue . buffer { perc : = f ( & stat ) if math . Is Na N ( perc ) { continue } min = math . Min ( min , perc ) max = math . Max ( max , perc ) sample Count + + sum + = perc } return & ecstcs . CWStats Set { Max : & max , Min : & min , Sample Count : & sample Count , Sum : & sum , } , nil } 
func ( as ASMSecret Status ) String ( ) string { for k , v : = range asm Secret Status Map { if v = = as { return k } } return " " } 
func ( as * ASMSecret Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * as = ASMSecret Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * as = ASMSecret Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) stat , ok : = asm Secret Status Map [ str Status ] if ! ok { * as = ASMSecret Status None return errors . New ( " " ) } * as = stat return nil } 
func New Mock CNIClient ( ctrl * gomock . Controller ) * Mock CNIClient { mock : = & Mock CNIClient { ctrl : ctrl } mock . recorder = & Mock CNIClient Mock Recorder { mock } return mock } 
func ( m * Mock CNIClient ) Capabilities ( arg 0 string ) ( [ ] string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( [ ] string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock CNIClient Mock Recorder ) Capabilities ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock CNIClient ) ( nil ) . Capabilities ) , arg 0 ) } 
func ( m * Mock CNIClient ) Cleanup NS ( arg 0 context . Context , arg 1 * ecscni . Config , arg 2 time . Duration ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock CNIClient ) Release IPResource ( arg 0 * ecscni . Config ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock CNIClient ) Setup NS ( arg 0 context . Context , arg 1 * ecscni . Config , arg 2 time . Duration ) ( * current . Result , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( * current . Result ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock CNIClient Mock Recorder ) Setup NS ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock CNIClient ) ( nil ) . Setup NS ) , arg 0 , arg 1 , arg 2 ) } 
func Container Associations Handler ( state dockerstate . Task Engine State ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { container ID , err : = get Container IDBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Associations ) return } task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Associations ) return } association Type , err : = get Association Type By Request ( r ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Associations ) return } seelog . Infof ( " " , container ID , association Type ) write Container Associations Response ( w , container ID , task ARN , association Type , state ) } } 
func Container Association Handler ( state dockerstate . Task Engine State ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Association ) return } association Type , err : = get Association Type By Request ( r ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Association ) return } association Name , err : = get Association Name By Request ( r ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Association ) return } seelog . Infof ( " " , association Name , association Type ) write Container Association Response ( w , task ARN , association Type , association Name , state ) } } 
func docker Stats To Container Stats ( docker Stats * types . Stats JSON ) ( * Container Stats , error ) { if num Cores = = uint 6 4 ( 0 ) { seelog . Error ( " " ) return nil , fmt . Errorf ( " " ) } cpu Usage : = ( docker Stats . CPUStats . CPUUsage . Total Usage * 1 0 0 ) / num Cores memory Usage : = docker Stats . Memory Stats . Private Working Set return & Container Stats { cpu Usage : cpu Usage , memory Usage : memory Usage , timestamp : docker Stats . Read , } , nil } 
func Get Mock Server ( close WS < - chan [ ] byte ) ( * httptest . Server , chan < - string , < - chan string , < - chan error , error ) { server Chan : = make ( chan string ) requests Chan : = make ( chan string ) err Chan : = make ( chan error ) stop Listen : = make ( chan bool ) upgrader : = websocket . Upgrader { Read Buffer Size : 1 0 2 4 , Write Buffer Size : 1 0 2 4 } handler : = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { ws , err : = upgrader . Upgrade ( w , r , nil ) go func ( ) { ws . Write Control ( websocket . Close Message , < - close WS , time . Now ( ) . Add ( time . Second ) ) close ( stop Listen ) } ( ) if err ! = nil { err Chan < - err } go func ( ) { for { select { case < - stop Listen : return default : _ , msg , err : = ws . Read Message ( ) if err ! = nil { err Chan < - err } else { requests Chan < - string ( msg ) } } } } ( ) for str : = range server Chan { err : = ws . Write Message ( websocket . Text Message , [ ] byte ( str ) ) if err ! = nil { err Chan < - err } } } ) server : = httptest . New Unstarted Server ( handler ) return server , server Chan , requests Chan , err Chan , nil } 
func ( cs Cgroup Status ) String ( ) string { for k , v : = range cgroup Status Map { if v = = cs { return k } } return " " } 
func ( cs * Cgroup Status ) Marshal JSON ( ) ( [ ] byte , error ) { if cs = = nil { return nil , nil } return [ ] byte ( ` " ` + cs . String ( ) + ` " ` ) , nil } 
func ( cs * Cgroup Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * cs = Cgroup Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * cs = Cgroup Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) stat , ok : = cgroup Status Map [ str Status ] if ! ok { * cs = Cgroup Status None return errors . New ( " " ) } * cs = stat return nil } 
func New Manager ( client Docker Metadata Client , cfg * config . Config ) Manager { return & metadata Manager { client : client , cluster : cfg . Cluster , data Dir : cfg . Data Dir , data Dir On Host : cfg . Data Dir On Host , os Wrap : oswrapper . New OS ( ) , ioutil Wrap : ioutilwrapper . New IOUtil ( ) , } } 
func ( manager * metadata Manager ) Create ( config * dockercontainer . Config , host Config * dockercontainer . Host Config , task * apitask . Task , container Name string ) error { } err = manager . os Wrap . Mkdir All ( metadata Directory Path , os . Mode Perm ) if err ! = nil { return fmt . Errorf ( " " , task . Arn , err ) } err = manager . marshal And Write ( metadata , task . Arn , container Name ) if err ! = nil { return err } config . Env = env host Config . Binds = binds return nil } 
func ( manager * metadata Manager ) Update ( ctx context . Context , docker ID string , task * apitask . Task , container Name string ) error { if err ! = nil { return err } } return manager . marshal And Write ( metadata , task . Arn , container Name ) } 
func ( manager * metadata Manager ) Clean ( task ARN string ) error { metadata Path , err : = get Task Metadata Dir ( task ARN , manager . data Dir ) if err ! = nil { return fmt . Errorf ( " " , task ARN , err ) } return manager . os Wrap . Remove All ( metadata Path ) } 
func ( auth Provider * docker Auth Provider ) Get Authconfig ( image string , registry Auth Data * apicontainer . Registry Authentication Data ) ( types . Auth Config , error ) { auth Data Map : = auth Provider . auth Map if is Dockerhub Hostname ( index Name ) { return auth Data Map [ docker Registry Key ] , nil } auth Config Key : = index Name } for registry : = range auth Data Map { name Parts : = strings . Split N ( registry , " " , 2 ) hostname : = name Parts [ 0 ] } else if len ( registry ) > len ( longest Key ) & & strings . Has Prefix ( image , registry ) { } } } if longest Key ! = " " { return auth Data Map [ longest Key ] , nil } return types . Auth Config { } , nil } 
func parse Auth Data ( auth Type string , auth Data json . Raw Message ) docker Auths { intermediate Auth Data : = make ( docker Auths ) switch auth Type { case " " : err : = json . Unmarshal ( auth Data , & intermediate Auth Data ) if err ! = nil { seelog . Warn ( " " ) return docker Auths { } } case " " : var base 6 4d Auth Info dockercfg Data err : = json . Unmarshal ( auth Data , & base 6 4d Auth Info ) if err ! = nil { seelog . Warn ( " " ) return docker Auths { } } for registry , auth : = range base 6 4d Auth Info { data , err : = base 6 4 . Std Encoding . Decode String ( auth . Auth ) if err ! = nil { seelog . Warnf ( " " , registry ) continue } username Pass : = strings . Split N ( string ( data ) , " " , 2 ) if len ( username Pass ) ! = 2 { seelog . Warnf ( " " , registry ) continue } intermediate Auth Data [ registry ] = types . Auth Config { Username : username Pass [ 0 ] , Password : username Pass [ 1 ] , } } case " " : default : seelog . Warnf ( " " , auth Type ) return docker Auths { } } for key , val : = range intermediate Auth Data { output [ strip Registry Schema ( key ) ] = val } return output } 
func strip Registry Schema ( registry string ) string { if strings . Has Prefix ( registry , " " ) { return strings . Trim Prefix ( registry , " " ) } else if strings . Has Prefix ( registry , " " ) { return strings . Trim Prefix ( registry , " " ) } return registry } 
func ( lh Logging Handler ) Serve HTTP ( w http . Response Writer , r * http . Request ) { seelog . Debug ( " " , " " , r . Method , " " , r . Remote Addr ) lh . h . Serve HTTP ( w , r ) } 
func New Jittered Ticker ( ctx context . Context , start , end time . Duration ) < - chan time . Time { ticker : = make ( chan time . Time , 1 ) go func ( ) { defer close ( ticker ) for { select { case < - ctx . Done ( ) : return default : time . Sleep ( random Duration ( start , end ) ) send Now ( ticker ) } } } ( ) return ticker } 
func ( agent * ecs Agent ) capabilities ( ) ( [ ] * ecs . Attribute , error ) { var capabilities [ ] * ecs . Attribute if ! agent . cfg . Privileged Disabled { capabilities = append Name Only Attribute ( capabilities , capability Prefix + " " ) } supported Versions : = make ( map [ dockerclient . Docker Version ] bool ) supported Versions [ version ] = true } capabilities = agent . append Logging Driver Capabilities ( capabilities ) if agent . cfg . SELinux Capable { capabilities = append Name Only Attribute ( capabilities , capability Prefix + " " ) } if agent . cfg . App Armor Capable { capabilities = append Name Only Attribute ( capabilities , capability Prefix + " " ) } capabilities = agent . append Task Iam Role Capabilities ( capabilities , supported Versions ) capabilities , err : = agent . append Task CPUMem Limit Capabilities ( capabilities , supported Versions ) if err ! = nil { return nil , err } capabilities = agent . append Task ENICapabilities ( capabilities ) capabilities = agent . append Docker Dependent Capabilities ( capabilities , supported Versions ) } capabilities = agent . append Volume Driver Capabilities ( capabilities ) if agent . cfg . GPUSupport Enabled { capabilities = agent . append Nvidia Driver Version Attribute ( capabilities ) } return capabilities , nil } 
func ( agent * ecs Agent ) get Task ENIPlugin Version Attribute ( ) ( * ecs . Attribute , error ) { version , err : = agent . cni Client . Version ( ecscni . ECSENIPlugin Name ) if err ! = nil { seelog . Warnf ( " " , ecscni . ECSENIPlugin Name , err ) return nil , err } return & ecs . Attribute { Name : aws . String ( attribute Prefix + cni Plugin Version Suffix ) , Value : aws . String ( version ) , } , nil } 
func New Mock ECSSDK ( ctrl * gomock . Controller ) * Mock ECSSDK { mock : = & Mock ECSSDK { ctrl : ctrl } mock . recorder = & Mock ECSSDKMock Recorder { mock } return mock } 
func ( m * Mock ECSSDK ) Create Cluster ( arg 0 * ecs . Create Cluster Input ) ( * ecs . Create Cluster Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . Create Cluster Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock ECSSDK ) Discover Poll Endpoint ( arg 0 * ecs . Discover Poll Endpoint Input ) ( * ecs . Discover Poll Endpoint Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . Discover Poll Endpoint Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock ECSSDK ) List Tags For Resource ( arg 0 * ecs . List Tags For Resource Input ) ( * ecs . List Tags For Resource Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . List Tags For Resource Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock ECSSDK ) Register Container Instance ( arg 0 * ecs . Register Container Instance Input ) ( * ecs . Register Container Instance Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . Register Container Instance Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECSSDKMock Recorder ) Register Container Instance ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECSSDK ) ( nil ) . Register Container Instance ) , arg 0 ) } 
func New Mock ECSSubmit State SDK ( ctrl * gomock . Controller ) * Mock ECSSubmit State SDK { mock : = & Mock ECSSubmit State SDK { ctrl : ctrl } mock . recorder = & Mock ECSSubmit State SDKMock Recorder { mock } return mock } 
func ( m * Mock ECSSubmit State SDK ) Submit Container State Change ( arg 0 * ecs . Submit Container State Change Input ) ( * ecs . Submit Container State Change Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . Submit Container State Change Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECSSubmit State SDKMock Recorder ) Submit Container State Change ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECSSubmit State SDK ) ( nil ) . Submit Container State Change ) , arg 0 ) } 
func ( m * Mock ECSSubmit State SDK ) Submit Task State Change ( arg 0 * ecs . Submit Task State Change Input ) ( * ecs . Submit Task State Change Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecs . Submit Task State Change Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock ECSClient ( ctrl * gomock . Controller ) * Mock ECSClient { mock : = & Mock ECSClient { ctrl : ctrl } mock . recorder = & Mock ECSClient Mock Recorder { mock } return mock } 
func ( m * Mock ECSClient ) Discover Poll Endpoint ( arg 0 string ) ( string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECSClient Mock Recorder ) Discover Poll Endpoint ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECSClient ) ( nil ) . Discover Poll Endpoint ) , arg 0 ) } 
func ( m * Mock ECSClient ) Get Resource Tags ( arg 0 string ) ( [ ] * ecs . Tag , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( [ ] * ecs . Tag ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock ECSClient ) Register Container Instance ( arg 0 string , arg 1 [ ] * ecs . Attribute , arg 2 [ ] * ecs . Tag , arg 3 string , arg 4 [ ] * ecs . Platform Device ) ( string , string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 , arg 4 ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( string ) ret 2 , _ : = ret [ 2 ] . ( error ) return ret 0 , ret 1 , ret 2 } 
func ( mr * Mock ECSClient Mock Recorder ) Register Container Instance ( arg 0 , arg 1 , arg 2 , arg 3 , arg 4 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECSClient ) ( nil ) . Register Container Instance ) , arg 0 , arg 1 , arg 2 , arg 3 , arg 4 ) } 
func ( m * Mock ECSClient ) Submit Container State Change ( arg 0 api . Container State Change ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock ECSClient ) Submit Task State Change ( arg 0 api . Task State Change ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func New Task Engine ( cfg * config . Config , client dockerapi . Docker Client , credentials Manager credentials . Manager , container Change Event Stream * eventstream . Event Stream , image Manager Image Manager , state dockerstate . Task Engine State , metadata Manager containermetadata . Manager , resource Fields * taskresource . Resource Fields ) Task Engine { task Engine : = New Docker Task Engine ( cfg , client , credentials Manager , container Change Event Stream , image Manager , state , metadata Manager , resource Fields ) return task Engine } 
func New Mock State Manager ( ctrl * gomock . Controller ) * Mock State Manager { mock : = & Mock State Manager { ctrl : ctrl } mock . recorder = & Mock State Manager Mock Recorder { mock } return mock } 
func ( m * Mock State Manager ) New State Manager ( arg 0 * config . Config , arg 1 . . . statemanager . Option ) ( statemanager . State Manager , error ) { varargs : = [ ] interface { } { arg 0 } for _ , a : = range arg 1 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( statemanager . State Manager ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock State Manager Mock Recorder ) New State Manager ( arg 0 interface { } , arg 1 . . . interface { } ) * gomock . Call { varargs : = append ( [ ] interface { } { arg 0 } , arg 1 . . . ) return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock State Manager ) ( nil ) . New State Manager ) , varargs . . . ) } 
func New Mock Saveable Option ( ctrl * gomock . Controller ) * Mock Saveable Option { mock : = & Mock Saveable Option { ctrl : ctrl } mock . recorder = & Mock Saveable Option Mock Recorder { mock } return mock } 
func ( m * Mock Saveable Option ) Add Saveable ( arg 0 string , arg 1 statemanager . Saveable ) statemanager . Option { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( statemanager . Option ) return ret 0 } 
func ( mr * Mock Saveable Option Mock Recorder ) Add Saveable ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Saveable Option ) ( nil ) . Add Saveable ) , arg 0 , arg 1 ) } 
func New ECSClient ( credential Provider * credentials . Credentials , config * config . Config , ec 2Metadata Client ec 2 . EC 2Metadata Client ) api . ECSClient { var ecs Config aws . Config ecs Config . Credentials = credential Provider ecs Config . Region = & config . AWSRegion ecs Config . HTTPClient = httpclient . New ( roundtrip Timeout , config . Accept Insecure Cert ) if config . APIEndpoint ! = " " { ecs Config . Endpoint = & config . APIEndpoint } standard Client : = ecs . New ( session . New ( & ecs Config ) ) submit State Change Client : = new Submit State Change Client ( & ecs Config ) poll Endpoin Cache : = async . New LRUCache ( poll Endpoint Cache Size , poll Endpoint Cache TTL ) return & APIECSClient { credential Provider : credential Provider , config : config , standard Client : standard Client , submit State Change Client : submit State Change Client , ec 2metadata : ec 2Metadata Client , poll Endpoin Cache : poll Endpoin Cache , } } 
func ( client * APIECSClient ) Create Cluster ( cluster Name string ) ( string , error ) { resp , err : = client . standard Client . Create Cluster ( & ecs . Create Cluster Input { Cluster Name : & cluster Name } ) if err ! = nil { seelog . Criticalf ( " " , err ) return " " , err } seelog . Infof ( " " , cluster Name ) return * resp . Cluster . Cluster Name , nil } 
func ( client * APIECSClient ) Register Container Instance ( container Instance Arn string , attributes [ ] * ecs . Attribute , tags [ ] * ecs . Tag , registration Token string , platform Devices [ ] * ecs . Platform Device ) ( string , string , error ) { cluster Ref : = client . config . Cluster defer func ( ) { } ( ) if err = = nil { return container Instance Arn , availabilityzone , nil } if err ! = nil { return " " , " " , err } } } return client . register Container Instance ( cluster Ref , container Instance Arn , attributes , tags , registration Token , platform Devices ) } 
func ( cs * Client Server Impl ) Connect ( ) error { seelog . Infof ( " " , cs . URL ) parsed URL , err : = url . Parse ( cs . URL ) if err ! = nil { return err } ws Scheme , err : = websocket Scheme ( parsed URL . Scheme ) if err ! = nil { return err } parsed URL . Scheme = ws Scheme if err ! = nil { return err } timeout Dialer : = & net . Dialer { Timeout : ws Connect Timeout } tls Config : = & tls . Config { Server Name : parsed URL . Host , Insecure Skip Verify : cs . Agent Config . Accept Insecure Cert } cipher . With Supported Cipher Suites ( tls Config ) if no Proxy = = " " { docker Host , err : = url . Parse ( cs . Agent Config . Docker Endpoint ) if err = = nil { docker Host . Scheme = " " os . Setenv ( " " , fmt . Sprintf ( " " , default No Proxy IP , docker Host . String ( ) ) ) seelog . Info ( " " , os . Getenv ( " " ) ) } else { seelog . Errorf ( " " ) } } dialer : = websocket . Dialer { Read Buffer Size : read Buf Size , Write Buffer Size : write Buf Size , TLSClient Config : tls Config , Proxy : http . Proxy From Environment , Net Dial : timeout Dialer . Dial , Handshake Timeout : ws Handshake Timeout , } websocket Conn , http Response , err : = dialer . Dial ( parsed URL . String ( ) , request . Header ) if http Response ! = nil { defer http Response . Body . Close ( ) } if err ! = nil { var resp [ ] byte if http Response ! = nil { var read Err error resp , read Err = ioutil . Read All ( http Response . Body ) if read Err ! = nil { return fmt . Errorf ( " " + read Err . Error ( ) + " " + err . Error ( ) ) } if decode Err = = nil { return cs . New Error ( possible Error ) } } seelog . Warnf ( " " , err ) return errors . Wrapf ( err , " " , parsed URL . Host , string ( resp ) ) } cs . write Lock . Lock ( ) defer cs . write Lock . Unlock ( ) cs . conn = websocket Conn seelog . Debugf ( " " , cs . URL ) return nil } 
func ( cs * Client Server Impl ) Is Ready ( ) bool { cs . write Lock . RLock ( ) defer cs . write Lock . RUnlock ( ) return cs . conn ! = nil } 
func ( cs * Client Server Impl ) Set Read Deadline ( t time . Time ) error { err : = cs . conn . Set Read Deadline ( t ) if err = = nil { return nil } seelog . Warnf ( " " , err , cs . URL ) return op Err } return err } 
func ( cs * Client Server Impl ) Disconnect ( . . . interface { } ) error { cs . write Lock . Lock ( ) defer cs . write Lock . Unlock ( ) if cs . conn = = nil { return fmt . Errorf ( " " ) } } return cs . conn . Close ( ) } 
func ( cs * Client Server Impl ) Add Request Handler ( f Request Handler ) { first Arg : = reflect . Type Of ( f ) . In ( 0 ) first Arg Type Str : = first Arg . Elem ( ) . Name ( ) recognized Types : = cs . Get Recognized Types ( ) _ , ok : = recognized Types [ first Arg Type Str ] if ! ok { panic ( " " + first Arg Type Str ) } cs . Request Handlers [ first Arg Type Str ] = f } 
func ( cs * Client Server Impl ) Make Request ( input interface { } ) error { send , err : = cs . Create Request Message ( input ) if err ! = nil { return err } if cs . Make Request Hook ! = nil { send , err = cs . Make Request Hook ( send ) if err ! = nil { return err } } } 
func ( cs * Client Server Impl ) Write Message ( send [ ] byte ) error { cs . write Lock . Lock ( ) defer cs . write Lock . Unlock ( ) } return cs . conn . Write Message ( websocket . Text Message , send ) } 
func ( cs * Client Server Impl ) Consume Messages ( ) error { for { if err : = cs . Set Read Deadline ( time . Now ( ) . Add ( cs . RWTimeout ) ) ; err ! = nil { return err } message Type , message , err : = cs . conn . Read Message ( ) switch { case err = = nil : if message Type ! = websocket . Text Message { } cs . handle Message ( message ) case permissible Close Code ( err ) : seelog . Debugf ( " " , err ) return io . EOF default : return err } } } 
func ( cs * Client Server Impl ) Create Request Message ( input interface { } ) ( [ ] byte , error ) { msg : = & Request Message { } recognized Types : = cs . Get Recognized Types ( ) for type Str , type Val : = range recognized Types { if reflect . Type Of ( input ) = = reflect . Ptr To ( type Val ) { msg . Type = type Str break } } if msg . Type = = " " { return nil , & Unrecognized WSRequest Type { reflect . Type Of ( input ) . String ( ) } } message Data , err : = jsonutil . Build JSON ( input ) if err ! = nil { return nil , & Not Marshallable WSRequest { msg . Type , err } } msg . Message = json . Raw Message ( message Data ) send , err : = json . Marshal ( msg ) if err ! = nil { return nil , & Not Marshallable WSRequest { msg . Type , err } } return send , nil } 
func ( cs * Client Server Impl ) handle Message ( data [ ] byte ) { typed Message , type Str , err : = Decode Data ( data , cs . Type Decoder ) if err ! = nil { seelog . Warnf ( " " , err ) return } seelog . Debugf ( " " , type Str ) if cs . Any Request Handler ! = nil { reflect . Value Of ( cs . Any Request Handler ) . Call ( [ ] reflect . Value { reflect . Value Of ( typed Message ) } ) } if handler , ok : = cs . Request Handlers [ type Str ] ; ok { reflect . Value Of ( handler ) . Call ( [ ] reflect . Value { reflect . Value Of ( typed Message ) } ) } else { seelog . Infof ( " " , type Str ) } } 
func permissible Close Code ( err error ) bool { return websocket . Is Close Error ( err , websocket . Close Normal Closure , } 
func ( state * Docker Task Engine State ) All Tasks ( ) [ ] * apitask . Task { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . all Tasks Unsafe ( ) } 
func ( state * Docker Task Engine State ) All Image States ( ) [ ] * image . Image State { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . all Image States Unsafe ( ) } 
func ( state * Docker Task Engine State ) All ENIAttachments ( ) [ ] * apieni . ENIAttachment { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . all ENIAttachments Unsafe ( ) } 
func ( state * Docker Task Engine State ) ENIBy Mac ( mac string ) ( * apieni . ENIAttachment , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) eni , ok : = state . eni Attachments [ mac ] return eni , ok } 
func ( state * Docker Task Engine State ) Add ENIAttachment ( eni Attachment * apieni . ENIAttachment ) { if eni Attachment = = nil { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok : = state . eni Attachments [ eni Attachment . MACAddress ] ; ! ok { state . eni Attachments [ eni Attachment . MACAddress ] = eni Attachment } else { seelog . Debugf ( " " , eni Attachment ) } } 
func ( state * Docker Task Engine State ) Remove ENIAttachment ( mac string ) { if mac = = " " { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) if _ , ok : = state . eni Attachments [ mac ] ; ok { delete ( state . eni Attachments , mac ) } else { seelog . Debugf ( " " , mac ) } } 
func ( state * Docker Task Engine State ) Get All Container IDs ( ) [ ] string { state . lock . RLock ( ) defer state . lock . RUnlock ( ) var ids [ ] string for id : = range state . id To Task { ids = append ( ids , id ) } return ids } 
func ( state * Docker Task Engine State ) Container By ID ( id string ) ( * apicontainer . Docker Container , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) c , ok : = state . id To Container [ id ] return c , ok } 
func ( state * Docker Task Engine State ) Container Map By Arn ( arn string ) ( map [ string ] * apicontainer . Docker Container , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) ret , ok : = state . task To ID [ arn ] for k , v : = range ret { mc [ k ] = v } return mc , ok } return ret , ok } 
func ( state * Docker Task Engine State ) Task By Short ID ( cid string ) ( [ ] * apitask . Task , bool ) { container IDs : = state . Get All Container IDs ( ) var tasks [ ] * apitask . Task for _ , id : = range container IDs { if strings . Has Prefix ( id , cid ) { if task , ok : = state . Task By ID ( id ) ; ok { tasks = append ( tasks , task ) } } } return tasks , len ( tasks ) > 0 } 
func ( state * Docker Task Engine State ) Task By ID ( cid string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) arn , found : = state . id To Task [ cid ] if ! found { return nil , false } return state . task By Arn ( arn ) } 
func ( state * Docker Task Engine State ) Task By Arn ( arn string ) ( * apitask . Task , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) return state . task By Arn ( arn ) } 
func ( state * Docker Task Engine State ) Add Task ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . tasks [ task . Arn ] = task } 
func ( state * Docker Task Engine State ) Add Container ( container * apicontainer . Docker Container , task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) if task = = nil | | container = = nil { log . Crit ( " " ) return } _ , exists : = state . tasks [ task . Arn ] if ! exists { log . Debug ( " " , " " , task . Arn ) state . tasks [ task . Arn ] = task } state . store IDTo Container Task Unsafe ( container , task ) docker ID : = container . Docker ID v 3Endpoint ID : = container . Container . V 3Endpoint ID state . store V 3Endpoint IDTo Docker IDUnsafe ( v 3Endpoint ID , docker ID ) } existing Map , exists : = state . task To ID [ task . Arn ] if ! exists { existing Map = make ( map [ string ] * apicontainer . Docker Container , len ( task . Containers ) ) state . task To ID [ task . Arn ] = existing Map } existing Map [ container . Container . Name ] = container } 
func ( state * Docker Task Engine State ) Add Image State ( image State * image . Image State ) { if image State = = nil { log . Debug ( " " ) return } if image State . Image . Image ID = = " " { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) state . image States [ image State . Image . Image ID ] = image State } 
func ( state * Docker Task Engine State ) Remove Task ( task * apitask . Task ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) task , ok : = state . tasks [ task . Arn ] if ! ok { seelog . Warnf ( " " , task . Arn ) return } delete ( state . tasks , task . Arn ) if ip , ok : = state . task To IPUnsafe ( task . Arn ) ; ok { delete ( state . ip To Task , ip ) } container Map , ok : = state . task To ID [ task . Arn ] if ! ok { seelog . Warnf ( " " , task . Arn ) return } delete ( state . task To ID , task . Arn ) for _ , docker Container : = range container Map { state . remove IDTo Container Task Unsafe ( docker Container ) } } 
func ( state * Docker Task Engine State ) task To IPUnsafe ( arn string ) ( string , bool ) { for ip , task ARN : = range state . ip To Task { if arn = = task ARN { return ip , true } } return " " , false } 
func ( state * Docker Task Engine State ) store IDTo Container Task Unsafe ( container * apicontainer . Docker Container , task * apitask . Task ) { if container . Docker ID ! = " " { state . id To Task [ container . Docker ID ] = task . Arn delete ( state . id To Task , container . Docker Name ) } else if container . Docker Name ! = " " { state . id To Task [ container . Docker Name ] = task . Arn } } 
func ( state * Docker Task Engine State ) remove IDTo Container Task Unsafe ( container * apicontainer . Docker Container ) { if key = = " " { key = container . Docker Name } delete ( state . id To Task , key ) delete ( state . id To Container , key ) } 
func ( state * Docker Task Engine State ) remove V 3Endpoint IDTo Task Container Unsafe ( v 3Endpoint ID string ) { if v 3Endpoint ID ! = " " { delete ( state . v 3Endpoint IDTo Task , v 3Endpoint ID ) delete ( state . v 3Endpoint IDTo Docker ID , v 3Endpoint ID ) } } 
func ( state * Docker Task Engine State ) Remove Image State ( image State * image . Image State ) { if image State = = nil { log . Debug ( " " ) return } state . lock . Lock ( ) defer state . lock . Unlock ( ) image State , ok : = state . image States [ image State . Image . Image ID ] if ! ok { log . Debug ( " " ) return } delete ( state . image States , image State . Image . Image ID ) } 
func ( state * Docker Task Engine State ) Add Task IPAddress ( addr string , task ARN string ) { state . lock . Lock ( ) defer state . lock . Unlock ( ) state . ip To Task [ addr ] = task ARN } 
func ( state * Docker Task Engine State ) Get Task By IPAddress ( addr string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) task ARN , ok : = state . ip To Task [ addr ] return task ARN , ok } 
func ( state * Docker Task Engine State ) store V 3Endpoint IDTo Task Unsafe ( v 3Endpoint ID , task ARN string ) { state . v 3Endpoint IDTo Task [ v 3Endpoint ID ] = task ARN } 
func ( state * Docker Task Engine State ) store V 3Endpoint IDTo Docker IDUnsafe ( v 3Endpoint ID , docker ID string ) { state . v 3Endpoint IDTo Docker ID [ v 3Endpoint ID ] = docker ID } 
func ( state * Docker Task Engine State ) Docker IDBy V 3Endpoint ID ( v 3Endpoint ID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) docker ID , ok : = state . v 3Endpoint IDTo Docker ID [ v 3Endpoint ID ] return docker ID , ok } 
func ( state * Docker Task Engine State ) Task ARNBy V 3Endpoint ID ( v 3Endpoint ID string ) ( string , bool ) { state . lock . RLock ( ) defer state . lock . RUnlock ( ) task Arn , ok : = state . v 3Endpoint IDTo Task [ v 3Endpoint ID ] return task Arn , ok } 
func v 1Handlers Setup ( server Mux * http . Serve Mux , container Instance Arn * string , task Engine handlersutils . Docker State Resolver , cfg * config . Config ) { server Mux . Handle Func ( v 1 . Agent Metadata Path , v 1 . Agent Metadata Handler ( container Instance Arn , cfg ) ) server Mux . Handle Func ( v 1 . Task Container Metadata Path , v 1 . Task Container Metadata Handler ( task Engine ) ) server Mux . Handle Func ( v 1 . License Path , v 1 . License Handler ) } 
func Serve Introspection HTTPEndpoint ( container Instance Arn * string , task Engine engine . Task Engine , cfg * config . Config ) { server : = introspection Server Setup ( container Instance Arn , docker Task Engine , cfg ) for { once : = sync . Once { } retry . Retry With Backoff ( retry . New Exponential Backoff ( time . Second , time . Minute , 0 . 2 , 2 ) , func ( ) error { once . Do ( func ( ) { seelog . Error ( " " , " " , err ) } ) return err } ) } } 
func ( dc * Docker Container ) String ( ) string { if dc = = nil { return " " } return fmt . Sprintf ( " " , dc . Docker ID , dc . Docker Name , dc . Container . String ( ) ) } 
func New Container With Steady State ( steady State apicontainerstatus . Container Status ) * Container { steady State Status : = steady State return & Container { Steady State Status Unsafe : & steady State Status , } } 
func ( c * Container ) Get Known Status ( ) apicontainerstatus . Container Status { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Known Status Unsafe } 
func ( c * Container ) Set Known Status ( status apicontainerstatus . Container Status ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Known Status Unsafe = status c . update Applied Status Unsafe ( status ) } 
func ( c * Container ) Get Desired Status ( ) apicontainerstatus . Container Status { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Desired Status Unsafe } 
func ( c * Container ) Set Desired Status ( status apicontainerstatus . Container Status ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Desired Status Unsafe = status } 
func ( c * Container ) Get Sent Status ( ) apicontainerstatus . Container Status { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Sent Status Unsafe } 
func ( c * Container ) Set Sent Status ( status apicontainerstatus . Container Status ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Sent Status Unsafe = status } 
func ( c * Container ) Set Known Exit Code ( i * int ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Known Exit Code Unsafe = i } 
func ( c * Container ) Get Known Exit Code ( ) * int { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Known Exit Code Unsafe } 
func ( c * Container ) Set Registry Auth Credentials ( credential credentials . IAMRole Credentials ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Registry Authentication . ECRAuth Data . Set Pull Credentials ( credential ) } 
func ( c * Container ) Should Pull With Execution Role ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Registry Authentication ! = nil & & c . Registry Authentication . Type = = Auth Type ECR & & c . Registry Authentication . ECRAuth Data ! = nil & & c . Registry Authentication . ECRAuth Data . Use Execution Role } 
func ( c * Container ) String ( ) string { ret : = fmt . Sprintf ( " " , c . Name , c . Image , c . Get Known Status ( ) . String ( ) , c . Get Desired Status ( ) . String ( ) ) if c . Get Known Exit Code ( ) ! = nil { ret + = " " + strconv . Itoa ( * c . Get Known Exit Code ( ) ) } return ret } 
func ( c * Container ) Get Steady State Status ( ) apicontainerstatus . Container Status { if c . Steady State Status Unsafe = = nil { return default Container Steady State Status } return * c . Steady State Status Unsafe } 
func ( c * Container ) Is Known Steady State ( ) bool { known Status : = c . Get Known Status ( ) return known Status = = c . Get Steady State Status ( ) } 
func ( c * Container ) Get Next Known State Progression ( ) apicontainerstatus . Container Status { if c . Is Known Steady State ( ) { return apicontainerstatus . Container Stopped } return c . Get Known Status ( ) + 1 } 
func ( c * Container ) Is Metadata File Updated ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Metadata File Updated } 
func ( c * Container ) Set Metadata File Updated ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Metadata File Updated = true } 
func ( c * Container ) Is Essential ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Essential } 
func ( c * Container ) Set Created At ( created At time . Time ) { if created At . Is Zero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . created At = created At } 
func ( c * Container ) Set Started At ( started At time . Time ) { if started At . Is Zero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . started At = started At } 
func ( c * Container ) Set Finished At ( finished At time . Time ) { if finished At . Is Zero ( ) { return } c . lock . Lock ( ) defer c . lock . Unlock ( ) c . finished At = finished At } 
func ( c * Container ) Get Created At ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . created At } 
func ( c * Container ) Get Started At ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . started At } 
func ( c * Container ) Get Finished At ( ) time . Time { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . finished At } 
func ( c * Container ) Set Labels ( labels map [ string ] string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . labels = labels } 
func ( c * Container ) Get Labels ( ) map [ string ] string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . labels } 
func ( c * Container ) Set Known Port Bindings ( ports [ ] Port Binding ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Known Port Bindings Unsafe = ports } 
func ( c * Container ) Get Known Port Bindings ( ) [ ] Port Binding { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Known Port Bindings Unsafe } 
func ( c * Container ) Set Volumes ( volumes [ ] types . Mount Point ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Volumes Unsafe = volumes } 
func ( c * Container ) Get Volumes ( ) [ ] types . Mount Point { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Volumes Unsafe } 
func ( c * Container ) Set Network Settings ( networks * types . Network Settings ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Network Settings Unsafe = networks } 
func ( c * Container ) Get Network Settings ( ) * types . Network Settings { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Network Settings Unsafe } 
func ( c * Container ) Set Network Mode ( network Mode string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . Network Mode Unsafe = network Mode } 
func ( c * Container ) Get Network Mode ( ) string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Network Mode Unsafe } 
func ( c * Container ) Set Health Status ( health Health Status ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . Health . Status = = health . Status { return } c . Health . Status = health . Status c . Health . Since = aws . Time ( time . Now ( ) ) c . Health . Output = health . Output } } 
func ( c * Container ) Get Health Status ( ) Health Status { c . lock . RLock ( ) defer c . lock . RUnlock ( ) if c . Health . Since ! = nil { copy Health . Since = aws . Time ( aws . Time Value ( c . Health . Since ) ) } return copy Health } 
func ( c * Container ) Build Container Dependency ( cont Name string , satisfied Status apicontainerstatus . Container Status , dependent Status apicontainerstatus . Container Status ) { cont Dep : = Container Dependency { Container Name : cont Name , Satisfied Status : satisfied Status , } if _ , ok : = c . Transition Dependencies Map [ dependent Status ] ; ! ok { c . Transition Dependencies Map [ dependent Status ] = Transition Dependency Set { } } deps : = c . Transition Dependencies Map [ dependent Status ] deps . Container Dependencies = append ( deps . Container Dependencies , cont Dep ) c . Transition Dependencies Map [ dependent Status ] = deps } 
func ( c * Container ) Build Resource Dependency ( resource Name string , required Status resourcestatus . Resource Status , dependent Status apicontainerstatus . Container Status ) { resource Dep : = Resource Dependency { Name : resource Name , Required Status : required Status , } if _ , ok : = c . Transition Dependencies Map [ dependent Status ] ; ! ok { c . Transition Dependencies Map [ dependent Status ] = Transition Dependency Set { } } deps : = c . Transition Dependencies Map [ dependent Status ] deps . Resource Dependencies = append ( deps . Resource Dependencies , resource Dep ) c . Transition Dependencies Map [ dependent Status ] = deps } 
func ( c * Container ) update Applied Status Unsafe ( known Status apicontainerstatus . Container Status ) { if c . Applied Status = = apicontainerstatus . Container Status None { return } } } 
func ( c * Container ) Set Applied Status ( status apicontainerstatus . Container Status ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) if c . Applied Status ! = apicontainerstatus . Container Status None { } c . Applied Status = status return true } 
func ( c * Container ) Get Applied Status ( ) apicontainerstatus . Container Status { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Applied Status } 
func ( c * Container ) Should Pull With ASMAuth ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . Registry Authentication ! = nil & & c . Registry Authentication . Type = = Auth Type ASM & & c . Registry Authentication . ASMAuth Data ! = nil } 
func ( c * Container ) Set ASMDocker Auth Config ( dac types . Auth Config ) { c . Registry Authentication . ASMAuth Data . Set Docker Auth Config ( dac ) } 
func ( c * Container ) Set V 3Endpoint ID ( v 3Endpoint ID string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . V 3Endpoint ID = v 3Endpoint ID } 
func ( c * Container ) Get V 3Endpoint ID ( ) string { c . lock . RLock ( ) defer c . lock . RUnlock ( ) return c . V 3Endpoint ID } 
func ( c * Container ) Inject V 3Metadata Endpoint ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) } c . Environment [ Metadata URIEnvironment Variable Name ] = fmt . Sprintf ( Metadata URIFormat , c . V 3Endpoint ID ) } 
func ( c * Container ) Should Create With SSMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } for _ , secret : = range c . Secrets { if secret . Provider = = Secret Provider SSM { return true } } return false } 
func ( c * Container ) Should Create With ASMSecret ( ) bool { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } for _ , secret : = range c . Secrets { if secret . Provider = = Secret Provider ASM { return true } } return false } 
func ( c * Container ) Merge Environment Variables ( env Vars map [ string ] string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) } for k , v : = range env Vars { c . Environment [ k ] = v } } 
func Decode Data ( data [ ] byte , dec Type Decoder ) ( interface { } , string , error ) { raw : = & Received Message { } if err ! = nil | | raw . Type = = " " { if decode Err = = nil & & conn Err Type ! = " " { return conn Err , conn Err Type , nil } return nil , " " , decode Err } req Message , ok : = dec . New Of Type ( raw . Type ) if ! ok { return nil , raw . Type , & Unrecognized WSRequest Type { raw . Type } } err = jsonutil . Unmarshal JSON ( req Message , bytes . New Reader ( raw . Message ) ) return req Message , raw . Type , err } 
func Decode Connection Error ( data [ ] byte , dec Type Decoder ) ( interface { } , string , error ) { var acs Err map [ string ] string err : = json . Unmarshal ( data , & acs Err ) if err ! = nil { return nil , " " , & Undecodable Message { string ( data ) } } if len ( acs Err ) ! = 1 { return nil , " " , & Undecodable Message { string ( data ) } } var type Str string for key : = range acs Err { type Str = key } err Type , ok : = dec . New Of Type ( type Str ) if ! ok { return nil , type Str , & Unrecognized WSRequest Type { } } val : = reflect . Value Of ( err Type ) if val . Kind ( ) ! = reflect . Ptr { return nil , type Str , & Unrecognized WSRequest Type { " " + val . Kind ( ) . String ( ) } } ret : = reflect . New ( val . Elem ( ) . Type ( ) ) ret Obj : = ret . Elem ( ) if ret Obj . Kind ( ) ! = reflect . Struct { return nil , type Str , & Unrecognized WSRequest Type { " " + ret Obj . Kind ( ) . String ( ) } } msg Field : = ret Obj . Field By Name ( " " ) if ! msg Field . Is Valid ( ) { return nil , type Str , & Unrecognized WSRequest Type { " " } } if msg Field . Is Valid ( ) & & msg Field . Can Set ( ) { msg Str : = acs Err [ type Str ] msg Str Val : = reflect . Value Of ( & msg Str ) if ! msg Str Val . Type ( ) . Assignable To ( msg Field . Type ( ) ) { return nil , type Str , & Unrecognized WSRequest Type { " " } } msg Field . Set ( msg Str Val ) return ret . Interface ( ) , type Str , nil } return nil , type Str , & Unrecognized WSRequest Type { " " } } 
func get Task IDfrom ARN ( task ARN string ) ( string , error ) { colon Split ARN : = strings . Split N ( task ARN , " " , 6 ) } arn Task Part Split : = strings . Split N ( colon Split ARN [ 5 ] , " " , 2 ) } return arn Task Part Split [ 1 ] , nil } 
func get Metadata File Path ( task ARN string , container Name string , data Dir string ) ( string , error ) { task ID , err : = get Task IDfrom ARN ( task ARN ) } return filepath . Join ( data Dir , metadata Join Suffix , task ID , container Name ) , nil } 
func get Task Metadata Dir ( task ARN string , data Dir string ) ( string , error ) { task ID , err : = get Task IDfrom ARN ( task ARN ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return filepath . Join ( data Dir , metadata Join Suffix , task ID ) , err } 
func ( b Conditional ) Marshal JSON ( ) ( [ ] byte , error ) { switch b { case Explicitly Enabled : return json . Marshal ( true ) case Explicitly Disabled : return json . Marshal ( false ) default : return json . Marshal ( nil ) } } 
func ( b * Conditional ) Unmarshal JSON ( json Data [ ] byte ) error { json String : = string ( json Data ) json Bool , err : = strconv . Parse Bool ( json String ) if err ! = nil & & json String ! = " " { return err } if json String = = " " | | json String = = " " { * b = Default Enabled } else if json Bool { * b = Explicitly Enabled } else { * b = Explicitly Disabled } return nil } 
func New ASMSecret Resource ( task ARN string , asm Secrets map [ string ] apicontainer . Secret , execution Credentials ID string , credentials Manager credentials . Manager , asm Client Creator factory . Client Creator ) * ASMSecret Resource { s : = & ASMSecret Resource { task ARN : task ARN , required Secrets : asm Secrets , credentials Manager : credentials Manager , execution Credentials ID : execution Credentials ID , asm Client Creator : asm Client Creator , } s . init Status To Transition ( ) return s } 
func ( secret * ASMSecret Resource ) Set Desired Status ( status resourcestatus . Resource Status ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . desired Status Unsafe = status } 
func ( secret * ASMSecret Resource ) Get Desired Status ( ) resourcestatus . Resource Status { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desired Status Unsafe } 
func ( secret * ASMSecret Resource ) Get Name ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return Resource Name } 
func ( secret * ASMSecret Resource ) Desired Terminal ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desired Status Unsafe = = resourcestatus . Resource Status ( ASMSecret Removed ) } 
func ( secret * ASMSecret Resource ) Known Created ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . known Status Unsafe = = resourcestatus . Resource Status ( ASMSecret Created ) } 
func ( secret * ASMSecret Resource ) Set Known Status ( status resourcestatus . Resource Status ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . known Status Unsafe = status secret . update Applied Status Unsafe ( status ) } 
func ( secret * ASMSecret Resource ) update Applied Status Unsafe ( known Status resourcestatus . Resource Status ) { if secret . applied Status = = resourcestatus . Resource Status ( ASMSecret Status None ) { return } } } 
func ( secret * ASMSecret Resource ) Set Applied Status ( status resourcestatus . Resource Status ) bool { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . applied Status ! = resourcestatus . Resource Status ( ASMSecret Status None ) { } secret . applied Status = status return true } 
func ( secret * ASMSecret Resource ) Get Known Status ( ) resourcestatus . Resource Status { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . known Status Unsafe } 
func ( secret * ASMSecret Resource ) Status String ( status resourcestatus . Resource Status ) string { return ASMSecret Status ( status ) . String ( ) } 
func ( secret * ASMSecret Resource ) Create ( ) error { if ! ok { secret . set Terminal Reason ( err . Error ( ) ) return err } iam Credentials : = execution Credentials . Get IAMRole Credentials ( ) var wg sync . Wait Group seelog . Infof ( " " , secret . task ARN ) secret . secret Data = make ( map [ string ] string ) for _ , asmsecret : = range secret . get Required Secrets ( ) { wg . Add ( 1 ) } wg . Wait ( ) close ( error Events ) if len ( error Events ) > 0 { var terminal Reasons [ ] string for err : = range error Events { terminal Reasons = append ( terminal Reasons , err . Error ( ) ) } error String : = strings . Join ( terminal Reasons , " " ) secret . set Terminal Reason ( error String ) return errors . New ( error String ) } return nil } 
func ( secret * ASMSecret Resource ) retrieve ASMSecret Value ( api Secret apicontainer . Secret , iam Credentials credentials . IAMRole Credentials , wg * sync . Wait Group , error Events chan error ) { defer wg . Done ( ) asm Client : = secret . asm Client Creator . New ASMClient ( api Secret . Region , iam Credentials ) seelog . Infof ( " " , api Secret . Value From , api Secret . Region , secret . task ARN ) if err ! = nil { error Events < - fmt . Errorf ( " " , api Secret . Region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . secret Data [ secret Key ] = secret Value } 
func ( secret * ASMSecret Resource ) get Required Secrets ( ) map [ string ] apicontainer . Secret { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . required Secrets } 
func ( secret * ASMSecret Resource ) get Execution Credentials ID ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . execution Credentials ID } 
func ( secret * ASMSecret Resource ) clear ASMSecret Value ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key : = range secret . secret Data { delete ( secret . secret Data , key ) } } 
func ( secret * ASMSecret Resource ) Marshal JSON ( ) ( [ ] byte , error ) { if secret = = nil { return nil , errors . New ( " " ) } created At : = secret . Get Created At ( ) return json . Marshal ( ASMSecret Resource JSON { Task ARN : secret . task ARN , Created At : & created At , Desired Status : func ( ) * ASMSecret Status { desired State : = secret . Get Desired Status ( ) s : = ASMSecret Status ( desired State ) return & s } ( ) , Known Status : func ( ) * ASMSecret Status { known State : = secret . Get Known Status ( ) s : = ASMSecret Status ( known State ) return & s } ( ) , Required Secrets : secret . get Required Secrets ( ) , Execution Credentials ID : secret . get Execution Credentials ID ( ) , } ) } 
func ( secret * ASMSecret Resource ) Unmarshal JSON ( b [ ] byte ) error { temp : = ASMSecret Resource JSON { } if err : = json . Unmarshal ( b , & temp ) ; err ! = nil { return err } if temp . Desired Status ! = nil { secret . Set Desired Status ( resourcestatus . Resource Status ( * temp . Desired Status ) ) } if temp . Known Status ! = nil { secret . Set Known Status ( resourcestatus . Resource Status ( * temp . Known Status ) ) } if temp . Created At ! = nil & & ! temp . Created At . Is Zero ( ) { secret . Set Created At ( * temp . Created At ) } if temp . Required Secrets ! = nil { secret . required Secrets = temp . Required Secrets } secret . task ARN = temp . Task ARN secret . execution Credentials ID = temp . Execution Credentials ID return nil } 
func ( c * control ) Create ( cgroup Spec * Spec ) ( cgroups . Cgroup , error ) { if err ! = nil { return nil , errors . Wrapf ( err , " " ) } controller , err : = c . New ( cgroups . V 1 , cgroups . Static Path ( cgroup Spec . Root ) , cgroup Spec . Specs ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } return controller , nil } 
func ( c * control ) Remove ( cgroup Path string ) error { seelog . Debugf ( " " , cgroup Path ) controller , err : = c . Load ( cgroups . V 1 , cgroups . Static Path ( cgroup Path ) ) if err ! = nil { return errors . Wrapf ( err , " " ) } if err ! = nil { return errors . Wrapf ( err , " " ) } return nil } 
func ( c * control ) Exists ( cgroup Path string ) bool { seelog . Debugf ( " " , cgroup Path ) controller , err : = c . Load ( cgroups . V 1 , cgroups . Static Path ( cgroup Path ) ) if err ! = nil | | controller = = nil { return false } return true } 
func validate Cgroup Spec ( cgroup Spec * Spec ) error { if cgroup Spec = = nil { return errors . New ( " " ) } if cgroup Spec . Root = = " " { return errors . New ( " " ) } } return nil } 
func handle Inactivity Timeout ( reader io . Read Closer , timeout time . Duration , cancel Request func ( ) , canceled * uint 3 2 ) ( io . Read Closer , chan < - struct { } ) { done : = make ( chan struct { } ) proxy Reader : = & proxy Reader { Read Closer : reader } go func ( ) { var last Call Count uint 6 4 for { select { case < - time . After ( timeout ) : case < - done : return } cur Call Count : = proxy Reader . call Count ( ) if cur Call Count = = last Call Count { atomic . Add Uint 3 2 ( canceled , 1 ) cancel Request ( ) return } last Call Count = cur Call Count } } ( ) return proxy Reader , done } 
func New Image Manager ( cfg * config . Config , client dockerapi . Docker Client , state dockerstate . Task Engine State ) Image Manager { return & docker Image Manager { client : client , state : state , minimum Age Before Deletion : cfg . Minimum Image Deletion Age , num Images To Delete : cfg . Num Images To Delete Per Cycle , image Cleanup Time Interval : cfg . Image Cleanup Interval , image Pull Behavior : cfg . Image Pull Behavior , image Cleanup Exclusion List : cfg . Image Cleanup Exclusion List , delete Non ECSImages Enabled : cfg . Delete Non ECSImages Enabled , non ECSContainer Cleanup Wait Duration : cfg . Task Cleanup Wait Duration , num Non ECSContainers To Delete : cfg . Num Non ECSContainers To Delete Per Cycle , } } 
func ( image Manager * docker Image Manager ) Record Container Reference ( container * apicontainer . Container ) error { } return nil } if container . Image = = " " { return fmt . Errorf ( " " ) } if err ! = nil { seelog . Errorf ( " " , container . Image , err ) return err } container . Image ID = image Inspected . ID added : = image Manager . add Container Reference To Existing Image State ( container ) if ! added { image Manager . add Container Reference To New Image State ( container , image Inspected . Size ) } return nil } 
func ( image Manager * docker Image Manager ) Remove Container Reference From Image State ( container * apicontainer . Container ) error { defer image Manager . update Lock . RUnlock ( ) if container . Image ID = = " " { return fmt . Errorf ( " " ) } if ! ok { return fmt . Errorf ( " " ) } } 
func ( image Manager * docker Image Manager ) get Image State ( container Image ID string ) ( * image . Image State , bool ) { for _ , image State : = range image Manager . get All Image States ( ) { if image State . Image . Image ID = = container Image ID { return image State , true } } return nil , false } 
func ( image Manager * docker Image Manager ) remove Image State ( image State To Be Removed * image . Image State ) { for i , image State : = range image Manager . image States { if image State . Image . Image ID = = image State To Be Removed . Image . Image ID { image Manager . image States = append ( image Manager . image States [ : i ] , image Manager . image States [ i + 1 : ] . . . ) return } } } 
func ( cfg * Config ) Merge ( rhs Config ) * Config { left : = reflect . Value Of ( cfg ) . Elem ( ) right : = reflect . Value Of ( & rhs ) . Elem ( ) for i : = 0 ; i < left . Num Field ( ) ; i + + { left Field : = left . Field ( i ) if utils . Zero Or Nil ( left Field . Interface ( ) ) { left Field . Set ( reflect . Value Of ( right . Field ( i ) . Interface ( ) ) ) } } return cfg } 
func New Config ( ec 2client ec 2 . EC 2Metadata Client ) ( * Config , error ) { var errs [ ] error env Config , err : = environment Config ( ) if err ! = nil { errs = append ( errs , err ) } config : = & env Config if config . complete ( ) { } fcfg , err : = file Config ( ) if err ! = nil { errs = append ( errs , err ) } config . Merge ( fcfg ) config . Merge ( user Data Config ( ec 2client ) ) if config . AWSRegion = = " " { if config . No IID { if err ! = nil { errs = append ( errs , err ) } config . AWSRegion = aws Region } else { } } return config , config . merge Default Config ( errs ) } 
func ( cfg * Config ) trim Whitespace ( ) { cfg Elem : = reflect . Value Of ( cfg ) . Elem ( ) cfg Struct Field : = reflect . Indirect ( reflect . Value Of ( cfg ) ) . Type ( ) for i : = 0 ; i < cfg Elem . Num Field ( ) ; i + + { cfg Field : = cfg Elem . Field ( i ) if ! cfg Field . Can Interface ( ) { continue } trim Tag : = cfg Struct Field . Field ( i ) . Tag . Get ( " " ) if len ( trim Tag ) = = 0 { continue } if cfg Field . Kind ( ) ! = reflect . String { seelog . Warnf ( " " , cfg Field . Kind ( ) . String ( ) , i ) continue } str : = cfg Field . Interface ( ) . ( string ) cfg Field . Set String ( strings . Trim Space ( str ) ) } } 
func ( cfg * Config ) validate And Override Bounds ( ) error { err : = cfg . check Missing And Depreciated ( ) if err ! = nil { return err } if cfg . Docker Stop Timeout < minimum Docker Stop Timeout { return fmt . Errorf ( " " , cfg . Docker Stop Timeout . String ( ) ) } if cfg . Container Start Timeout < minimum Container Start Timeout { return fmt . Errorf ( " " , cfg . Container Start Timeout . String ( ) ) } var bad Drivers [ ] string for _ , driver : = range cfg . Available Logging Drivers { _ , ok : = dockerclient . Logging Driver Minimum Version [ driver ] if ! ok { bad Drivers = append ( bad Drivers , string ( driver ) ) } } if len ( bad Drivers ) > 0 { return errors . New ( " " + strings . Join ( bad Drivers , " " ) ) } cfg . Task Cleanup Wait Duration = Default Task Cleanup Wait Duration } if cfg . Image Pull Inactivity Timeout < minimum Image Pull Inactivity Timeout { seelog . Warnf ( " " , default Image Pull Inactivity Timeout . String ( ) , cfg . Image Pull Inactivity Timeout , minimum Image Pull Inactivity Timeout ) cfg . Image Pull Inactivity Timeout = default Image Pull Inactivity Timeout } if cfg . Image Cleanup Interval < minimum Image Cleanup Interval { seelog . Warnf ( " " , Default Image Cleanup Time Interval . String ( ) , cfg . Image Cleanup Interval , minimum Image Cleanup Interval ) cfg . Image Cleanup Interval = Default Image Cleanup Time Interval } if cfg . Num Images To Delete Per Cycle < minimum Num Images To Delete Per Cycle { seelog . Warnf ( " " , Default Image Deletion Age , cfg . Num Images To Delete Per Cycle , minimum Num Images To Delete Per Cycle ) cfg . Num Images To Delete Per Cycle = Default Num Images To Delete Per Cycle } if cfg . Task Metadata Steady State Rate < = 0 | | cfg . Task Metadata Burst Rate < = 0 { seelog . Warnf ( " " , Default Task Metadata Steady State Rate , Default Task Metadata Burst Rate ) cfg . Task Metadata Steady State Rate = Default Task Metadata Steady State Rate cfg . Task Metadata Burst Rate = Default Task Metadata Burst Rate } cfg . platform Overrides ( ) return nil } 
func ( cfg * Config ) check Missing And Depreciated ( ) error { cfg Elem : = reflect . Value Of ( cfg ) . Elem ( ) cfg Struct Field : = reflect . Indirect ( reflect . Value Of ( cfg ) ) . Type ( ) fatal Fields : = [ ] string { } for i : = 0 ; i < cfg Elem . Num Field ( ) ; i + + { cfg Field : = cfg Elem . Field ( i ) if utils . Zero Or Nil ( cfg Field . Interface ( ) ) { missing Tag : = cfg Struct Field . Field ( i ) . Tag . Get ( " " ) if len ( missing Tag ) = = 0 { continue } switch missing Tag { case " " : seelog . Warnf ( " " , cfg Struct Field . Field ( i ) . Name ) case " " : seelog . Criticalf ( " " , cfg Struct Field . Field ( i ) . Name ) fatal Fields = append ( fatal Fields , cfg Struct Field . Field ( i ) . Name ) default : seelog . Warnf ( " " , missing Tag ) } } else { if len ( deprecated Tag ) = = 0 { continue } seelog . Warnf ( " " , cfg Struct Field . Field ( i ) . Name , deprecated Tag ) } } if len ( fatal Fields ) > 0 { return errors . New ( " " + strings . Join ( fatal Fields , " " ) ) } return nil } 
func ( cfg * Config ) complete ( ) bool { cfg Elem : = reflect . Value Of ( cfg ) . Elem ( ) for i : = 0 ; i < cfg Elem . Num Field ( ) ; i + + { if utils . Zero Or Nil ( cfg Elem . Field ( i ) . Interface ( ) ) { return false } } return true } 
func user Data Config ( ec 2Client ec 2 . EC 2Metadata Client ) Config { type user Data Parser struct { Config Config `json : "ECSAgent Configuration " ` } parsed User Data : = user Data Parser { Config : Config { } , } user Data , err : = ec 2Client . Get User Data ( ) if err ! = nil { seelog . Warnf ( " " , err ) } if err ! = nil { seelog . Debugf ( " " , err ) } return parsed User Data . Config } 
func environment Config ( ) ( Config , error ) { data Dir : = os . Getenv ( " " ) steady State Rate , burst Rate : = parse Task Metadata Throttles ( ) var errs [ ] error instance Attributes , errs : = parse Instance Attributes ( errs ) container Instance Tags , errs : = parse Container Instance Tags ( errs ) additional Local Routes , errs : = parse Additional Local Routes ( errs ) var err error if len ( errs ) > 0 { err = apierrors . New Multi Error ( errs . . . ) } return Config { Cluster : os . Getenv ( " " ) , APIEndpoint : os . Getenv ( " " ) , AWSRegion : os . Getenv ( " " ) , Docker Endpoint : os . Getenv ( " " ) , Reserved Ports : parse Reserved Ports ( " " ) , Reserved Ports UDP : parse Reserved Ports ( " " ) , Data Dir : data Dir , Checkpoint : parse Checkpoint ( data Dir ) , Engine Auth Type : os . Getenv ( " " ) , Engine Auth Data : New Sensitive Raw Message ( [ ] byte ( os . Getenv ( " " ) ) ) , Updates Enabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Update Download Dir : os . Getenv ( " " ) , Disable Metrics : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Reserved Memory : parse Env Variable Uint 1 6 ( " " ) , Available Logging Drivers : parse Available Logging Drivers ( ) , Privileged Disabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , SELinux Capable : utils . Parse Bool ( os . Getenv ( " " ) , false ) , App Armor Capable : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Task Cleanup Wait Duration : parse Env Variable Duration ( " " ) , Task ENIEnabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Task IAMRole Enabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Delete Non ECSImages Enabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Task CPUMem Limit : parse Task CPUMem Limit Enabled ( ) , Docker Stop Timeout : parse Docker Stop Timeout ( ) , Container Start Timeout : parse Container Start Timeout ( ) , Image Pull Inactivity Timeout : parse Image Pull Inactivity Timeout ( ) , Credentials Audit Log File : os . Getenv ( " " ) , Credentials Audit Log Disabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Task IAMRole Enabled For Network Host : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Image Cleanup Disabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Minimum Image Deletion Age : parse Env Variable Duration ( " " ) , Image Cleanup Interval : parse Env Variable Duration ( " " ) , Num Images To Delete Per Cycle : parse Num Images To Delete Per Cycle ( ) , Num Non ECSContainers To Delete Per Cycle : parse Num Non ECSContainers To Delete Per Cycle ( ) , Image Pull Behavior : parse Image Pull Behavior ( ) , Image Cleanup Exclusion List : parse Image Cleanup Exclusion List ( " " ) , Instance Attributes : instance Attributes , CNIPlugins Path : os . Getenv ( " " ) , AWSVPCBlock Instance Metdata : utils . Parse Bool ( os . Getenv ( " " ) , false ) , AWSVPCAdditional Local Routes : additional Local Routes , Container Metadata Enabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Data Dir On Host : os . Getenv ( " " ) , Override AWSLogs Execution Role : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Cgroup Path : os . Getenv ( " " ) , Task Metadata Steady State Rate : steady State Rate , Task Metadata Burst Rate : burst Rate , Shared Volume Match Full Config : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Container Instance Tags : container Instance Tags , Container Instance Propagate Tags From : parse Container Instance Propagate Tags From ( ) , Poll Metrics : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Polling Metrics Wait Duration : parse Env Variable Duration ( " " ) , Disable Docker Health Check : utils . Parse Bool ( os . Getenv ( " " ) , false ) , GPUSupport Enabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , Nvidia Runtime : os . Getenv ( " " ) , Task Metadata AZDisabled : utils . Parse Bool ( os . Getenv ( " " ) , false ) , } , err } 
func ( cfg * Config ) String ( ) string { return fmt . Sprintf ( " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " + " " , cfg . Cluster , cfg . AWSRegion , cfg . Data Dir , cfg . Checkpoint , cfg . Engine Auth Type , cfg . Updates Enabled , cfg . Disable Metrics , cfg . Poll Metrics , cfg . Polling Metrics Wait Duration , cfg . Reserved Memory , cfg . Task Cleanup Wait Duration , cfg . Docker Stop Timeout , cfg . Container Start Timeout , cfg . Task CPUMem Limit , cfg . platform String ( ) , ) } 
func New Task Stats Response ( task ARN string , state dockerstate . Task Engine State , stats Engine stats . Engine ) ( map [ string ] * types . Stats JSON , error ) { container Map , ok : = state . Container Map By Arn ( task ARN ) if ! ok { return nil , errors . Errorf ( " " , task ARN ) } resp : = make ( map [ string ] * types . Stats JSON ) for _ , docker Container : = range container Map { container ID : = docker Container . Docker ID docker Stats , err : = stats Engine . Container Docker Stats ( task ARN , container ID ) if err ! = nil { seelog . Warnf ( " " , container ID , task ARN , err ) resp [ container ID ] = nil continue } resp [ container ID ] = docker Stats } return resp , nil } 
func New Session ( ctx context . Context , config * config . Config , deregister Instance Event Stream * eventstream . Event Stream , container Instance Arn string , credentials Provider * credentials . Credentials , ecs Client api . ECSClient , task Engine State dockerstate . Task Engine State , state Manager statemanager . State Manager , task Engine engine . Task Engine , credentials Manager rolecredentials . Manager , task Handler * eventhandler . Task Handler ) Session { resources : = new Session Resources ( credentials Provider ) backoff : = retry . New Exponential Backoff ( connection Backoff Min , connection Backoff Max , connection Backoff Jitter , connection Backoff Multiplier ) derived Context , cancel : = context . With Cancel ( ctx ) return & session { agent Config : config , deregister Instance Event Stream : deregister Instance Event Stream , container Instance ARN : container Instance Arn , credentials Provider : credentials Provider , ecs Client : ecs Client , state : task Engine State , state Manager : state Manager , task Engine : task Engine , credentials Manager : credentials Manager , task Handler : task Handler , ctx : derived Context , cancel : cancel , backoff : backoff , resources : resources , _heartbeat Timeout : heartbeat Timeout , _heartbeat Jitter : heartbeat Jitter , _inactive Instance Reconnect Delay : inactive Instance Reconnect Delay , } } 
func ( acs Session * session ) Start ( ) error { } ( ) for { select { case < - connect To ACS : seelog . Debugf ( " " ) if is Inactive Instance { err : = acs Session . deregister Instance Event Stream . Write To Event Stream ( struct { } { } ) if err ! = nil { seelog . Debugf ( " " , err ) } } if should Reconnect Without Backoff ( acs Error ) { acs Session . backoff . Reset ( ) send Empty Message On Channel ( connect To ACS ) } else { seelog . Infof ( " " , reconnect Delay . String ( ) ) wait Complete : = acs Session . wait For Duration ( reconnect Delay ) if wait Complete { } else { } } case < - acs Session . ctx . Done ( ) : seelog . Debugf ( " " ) return acs Session . ctx . Err ( ) } } } 
func ( acs Session * session ) start Session Once ( ) error { acs Endpoint , err : = acs Session . ecs Client . Discover Poll Endpoint ( acs Session . container Instance ARN ) if err ! = nil { seelog . Errorf ( " " , err ) return err } url : = acs Ws URL ( acs Endpoint , acs Session . agent Config . Cluster , acs Session . container Instance ARN , acs Session . task Engine , acs Session . resources ) client : = acs Session . resources . create ACSClient ( url , acs Session . agent Config ) defer client . Close ( ) return acs Session . start ACSSession ( client ) } 
func ( acs Session * session ) start ACSSession ( client wsclient . Client Server ) error { cfg : = acs Session . agent Config refresh Creds Handler : = new Refresh Credentials Handler ( acs Session . ctx , cfg . Cluster , acs Session . container Instance ARN , client , acs Session . credentials Manager , acs Session . task Engine ) defer refresh Creds Handler . clear Acks ( ) refresh Creds Handler . start ( ) defer refresh Creds Handler . stop ( ) client . Add Request Handler ( refresh Creds Handler . handler Func ( ) ) eni Attach Handler . start ( ) defer eni Attach Handler . stop ( ) client . Add Request Handler ( eni Attach Handler . handler Func ( ) ) payload Handler . start ( ) defer payload Handler . stop ( ) client . Add Request Handler ( payload Handler . handler Func ( ) ) updater . Add Agent Update Handlers ( client , cfg , acs Session . state Manager , acs Session . task Engine ) err : = client . Connect ( ) if err ! = nil { seelog . Errorf ( " " , err ) return err } seelog . Info ( " " ) defer timer . Stop ( ) acs Session . resources . connected To ACS ( ) backoff Reset Timer : = time . After Func ( retry . Add Jitter ( acs Session . heartbeat Timeout ( ) , acs Session . heartbeat Jitter ( ) ) , func ( ) { } ) defer backoff Reset Timer . Stop ( ) serve Err : = make ( chan error , 1 ) go func ( ) { serve Err < - client . Serve ( ) } ( ) for { select { case < - acs Session . ctx . Done ( ) : case err : = < - serve Err : } } } 
func ( acs Session * session ) wait For Duration ( delay time . Duration ) bool { reconnect Timer : = time . New Timer ( delay ) select { case < - reconnect Timer . C : return true case < - acs Session . ctx . Done ( ) : reconnect Timer . Stop ( ) return false } } 
func ( acs Resources * acs Session Resources ) create ACSClient ( url string , cfg * config . Config ) wsclient . Client Server { return acsclient . New ( url , cfg , acs Resources . credentials Provider , ws RWTimeout ) } 
func acs Ws URL ( endpoint , cluster , container Instance Arn string , task Engine engine . Task Engine , acs Session State session State ) string { acs URL : = endpoint if endpoint [ len ( endpoint ) - 1 ] ! = ' / ' { acs URL + = " " } acs URL + = " " query : = url . Values { } query . Set ( " " , cluster ) query . Set ( " " , container Instance Arn ) query . Set ( " " , version . Git Hash String ( ) ) query . Set ( " " , version . Version ) query . Set ( " " , " " ) if docker Version , err : = task Engine . Version ( ) ; err = = nil { query . Set ( " " , " " + docker Version ) } query . Set ( send Credentials URLParameter Name , acs Session State . get Send Credentials URLParameter ( ) ) return acs URL + " " + query . Encode ( ) } 
func new Disconnection Timer ( client wsclient . Client Server , timeout time . Duration , jitter time . Duration ) ttime . Timer { timer : = time . After Func ( retry . Add Jitter ( timeout , jitter ) , func ( ) { seelog . Warn ( " " ) if err : = client . Close ( ) ; err ! = nil { seelog . Warnf ( " " , err ) } seelog . Info ( " " ) } ) return timer } 
func any Message Handler ( timer ttime . Timer , client wsclient . Client Server ) func ( interface { } ) { return func ( interface { } ) { seelog . Debug ( " " ) } } } 
func validate IPRules ( ) error { var iptable * iptables . IPTables var err error if iptable , err = iptables . New With Protocol ( iptables . Protocol IPv 4 ) ; err ! = nil { return err } fmt . Printf ( " " , str ) strs , _ : = iptable . Stats ( " " , ingress Chain ) for _ , str = range strs { fmt . Printf ( " " , str ) } strs , _ = iptable . Stats ( " " , egress Chain ) for _ , str = range strs { fmt . Printf ( " " , str ) } if exist , err : = iptable . Exists ( " " , ingress Chain , " " , " " , " " , " " , " " , app Ports , " " , " " , " " , proxy Ingress Port ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , ingress Chain ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , egress Chain , " " , " " , " " , gid , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , egress Chain , " " , " " , " " , " " , " " , egress Ignored Ports , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , egress Chain , " " , " " , " " , egress Ignored IPv 4Addresses , " " , " " ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , egress Chain , " " , " " , " " , " " , " " , proxy Egress Port ) ; ! exist { return fmt . Errorf ( " \n " , err ) } if exist , err : = iptable . Exists ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , egress Chain ) ; ! exist { return fmt . Errorf ( " \n " , err ) } return nil } 
func Write JSONTo Response ( w http . Response Writer , http Status Code int , response JSON [ ] byte , request Type string ) { w . Header ( ) . Set ( " " , " " ) w . Write Header ( http Status Code ) _ , err : = w . Write ( response JSON ) if err ! = nil { seelog . Errorf ( " " , request Type ) } } 
func Value From Request ( r * http . Request , field string ) ( string , bool ) { values : = r . URL . Query ( ) _ , exists : = values [ field ] return values . Get ( field ) , exists } 
func Get Mux Value From Request ( r * http . Request , gorilla Mux Name string ) ( string , bool ) { vars : = mux . Vars ( r ) val , ok : = vars [ gorilla Mux Name ] return val , ok } 
func Construct Mux Var ( name string , pattern string ) string { if pattern = = " " { return " " + name + " " } return " " + name + " " + pattern + " " } 
func Limit Reached Handler ( audit Logger audit . Audit Logger ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { log Request : = request . Log Request { Request : r , } audit Logger . Log ( log Request , http . Status Too Many Requests , " " ) } } 
func ( td * Transition Dependencies Map ) Unmarshal JSON ( b [ ] byte ) error { dep Map : = make ( map [ apicontainerstatus . Container Status ] Transition Dependency Set ) err : = json . Unmarshal ( b , & dep Map ) if err = = nil { * td = dep Map return nil } seelog . Debugf ( " " , string ( b ) , err ) if err : = json . Unmarshal ( b , & td Set ) ; err ! = nil { return errors . Wrapf ( err , " " ) } for _ , dep : = range td Set . Container Dependencies { dependent Status : = dep . Dependent Status if _ , ok : = dep Map [ dependent Status ] ; ! ok { dep Map [ dependent Status ] = Transition Dependency Set { } } deps : = dep Map [ dependent Status ] deps . Container Dependencies = append ( deps . Container Dependencies , dep ) dep Map [ dependent Status ] = deps } * td = dep Map return nil } 
func ( s * Sequential Wait Group ) Add ( sequence int 6 4 , delta int ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) _ , ok : = s . semaphores [ sequence ] if ok { s . semaphores [ sequence ] + = delta } else { s . semaphores [ sequence ] = delta } if s . semaphores [ sequence ] < = 0 { delete ( s . semaphores , sequence ) s . change . Broadcast ( ) } } 
func ( s * Sequential Wait Group ) Done ( sequence int 6 4 ) { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) _ , ok : = s . semaphores [ sequence ] if ok { s . semaphores [ sequence ] - - if s . semaphores [ sequence ] = = 0 { delete ( s . semaphores , sequence ) s . change . Broadcast ( ) } } } 
func ( s * Sequential Wait Group ) Wait ( sequence int 6 4 ) { wait Over : = func ( ) bool { s . mutex . Lock ( ) defer s . mutex . Unlock ( ) for stored Sequence : = range s . semaphores { if stored Sequence < = sequence { } } return true } s . change . L . Lock ( ) defer s . change . L . Unlock ( ) } } 
func New Mock Cgroup ( ctrl * gomock . Controller ) * Mock Cgroup { mock : = & Mock Cgroup { ctrl : ctrl } mock . recorder = & Mock Cgroup Mock Recorder { mock } return mock } 
func ( m * Mock Cgroup ) Add ( arg 0 cgroups . Process ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock Cgroup Mock Recorder ) Add ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Cgroup ) ( nil ) . Add ) , arg 0 ) } 
func ( mr * Mock Cgroup Mock Recorder ) Delete ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Cgroup ) ( nil ) . Delete ) ) } 
func ( m * Mock Cgroup ) Move To ( arg 0 cgroups . Cgroup ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Cgroup ) New ( arg 0 string , arg 1 * specs _go . Linux Resources ) ( cgroups . Cgroup , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( cgroups . Cgroup ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Cgroup ) OOMEvent FD ( ) ( uintptr , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( uintptr ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Cgroup ) Processes ( arg 0 cgroups . Name , arg 1 bool ) ( [ ] cgroups . Process , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( [ ] cgroups . Process ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Cgroup ) Stat ( arg 0 . . . cgroups . Error Handler ) ( * cgroups . Stats , error ) { varargs : = [ ] interface { } { } for _ , a : = range arg 0 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * cgroups . Stats ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Cgroup ) State ( ) cgroups . State { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( cgroups . State ) return ret 0 } 
func ( m * Mock Cgroup ) Subsystems ( ) [ ] cgroups . Subsystem { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] cgroups . Subsystem ) return ret 0 } 
func ( m * Mock Cgroup ) Update ( arg 0 * specs _go . Linux Resources ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func Task Stats Handler ( state dockerstate . Task Engine State , stats Engine stats . Engine ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Stats ) return } seelog . Infof ( " " , task ARN ) } } 
func Get Known APIVersions ( ) [ ] Docker Version { return [ ] Docker Version { Version _ 1 _ 1 7 , Version _ 1 _ 1 8 , Version _ 1 _ 1 9 , Version _ 1 _ 2 0 , Version _ 1 _ 2 1 , Version _ 1 _ 2 2 , Version _ 1 _ 2 3 , Version _ 1 _ 2 4 , Version _ 1 _ 2 5 , Version _ 1 _ 2 6 , Version _ 1 _ 2 7 , Version _ 1 _ 2 8 , Version _ 1 _ 2 9 , Version _ 1 _ 3 0 , Version _ 1 _ 3 1 , Version _ 1 _ 3 2 , } } 
func New Mock Udev ( ctrl * gomock . Controller ) * Mock Udev { mock : = & Mock Udev { ctrl : ctrl } mock . recorder = & Mock Udev Mock Recorder { mock } return mock } 
func ( mr * Mock Udev Mock Recorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Udev ) ( nil ) . Close ) ) } 
func ( m * Mock Udev ) Monitor ( arg 0 chan * udev . UEvent ) chan bool { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( chan bool ) return ret 0 } 
func ( mr * Mock Udev Mock Recorder ) Monitor ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Udev ) ( nil ) . Monitor ) , arg 0 ) } 
func ( s * Container Definition ) Validate ( ) error { invalid Params : = request . Err Invalid Params { Context : " " } if s . Depends On ! = nil { for i , v : = range s . Depends On { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if s . Extra Hosts ! = nil { for i , v : = range s . Extra Hosts { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if s . Health Check ! = nil { if err : = s . Health Check . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if s . Linux Parameters ! = nil { if err : = s . Linux Parameters . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if s . Log Configuration ! = nil { if err : = s . Log Configuration . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if s . Repository Credentials ! = nil { if err : = s . Repository Credentials . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if s . Secrets ! = nil { for i , v : = range s . Secrets { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if s . Ulimits ! = nil { for i , v : = range s . Ulimits { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if invalid Params . Len ( ) > 0 { return invalid Params } return nil } 
func ( s * Container Definition ) Set Inference Devices ( v [ ] * string ) * Container Definition { s . Inference Devices = v return s } 
func ( s * Container Instance ) Set Client Token ( v string ) * Container Instance { s . Client Token = & v return s } 
func ( s * Inference Accelerator ) Validate ( ) error { invalid Params : = request . Err Invalid Params { Context : " " } if s . Device Name = = nil { invalid Params . Add ( request . New Err Param Required ( " " ) ) } if s . Device Type = = nil { invalid Params . Add ( request . New Err Param Required ( " " ) ) } if invalid Params . Len ( ) > 0 { return invalid Params } return nil } 
func ( s * Inference Accelerator ) Set Device Name ( v string ) * Inference Accelerator { s . Device Name = & v return s } 
func ( s * Inference Accelerator ) Set Device Type ( v string ) * Inference Accelerator { s . Device Type = & v return s } 
func ( s * Register Container Instance Input ) Set Client Token ( v string ) * Register Container Instance Input { s . Client Token = & v return s } 
func ( s * Register Task Definition Input ) Validate ( ) error { invalid Params : = request . Err Invalid Params { Context : " " } if s . Container Definitions = = nil { invalid Params . Add ( request . New Err Param Required ( " " ) ) } if s . Family = = nil { invalid Params . Add ( request . New Err Param Required ( " " ) ) } if s . Container Definitions ! = nil { for i , v : = range s . Container Definitions { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if s . Inference Accelerators ! = nil { for i , v : = range s . Inference Accelerators { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if s . Proxy Configuration ! = nil { if err : = s . Proxy Configuration . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if s . Tags ! = nil { for i , v : = range s . Tags { if v = = nil { continue } if err : = v . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( fmt . Sprintf ( " " , " " , i ) , err . ( request . Err Invalid Params ) ) } } } if invalid Params . Len ( ) > 0 { return invalid Params } return nil } 
func ( s * Register Task Definition Input ) Set Inference Accelerators ( v [ ] * Inference Accelerator ) * Register Task Definition Input { s . Inference Accelerators = v return s } 
func ( s * Run Task Input ) Validate ( ) error { invalid Params : = request . Err Invalid Params { Context : " " } if s . Task Definition = = nil { invalid Params . Add ( request . New Err Param Required ( " " ) ) } if s . Network Configuration ! = nil { if err : = s . Network Configuration . Validate ( ) ; err ! = nil { invalid Params . Add Nested ( " " , err . ( request . Err Invalid Params ) ) } } if invalid Params . Len ( ) > 0 { return invalid Params } return nil } 
func ( s * Task Definition ) Set Inference Accelerators ( v [ ] * Inference Accelerator ) * Task Definition { s . Inference Accelerators = v return s } 
func Default Config ( ) Config { return Config { Docker Endpoint : " " , Reserved Ports : [ ] uint 1 6 { SSHPort , Docker Reserved Port , Docker Reserved SSLPort , Agent Introspection Port , Agent Credentials Port } , Reserved Ports UDP : [ ] uint 1 6 { } , Data Dir : " " , Data Dir On Host : " " , Disable Metrics : false , Reserved Memory : 0 , Available Logging Drivers : [ ] dockerclient . Logging Driver { dockerclient . JSONFile Driver , dockerclient . None Driver } , Task Cleanup Wait Duration : Default Task Cleanup Wait Duration , Docker Stop Timeout : default Docker Stop Timeout , Container Start Timeout : default Container Start Timeout , Credentials Audit Log File : default Credentials Audit Log File , Credentials Audit Log Disabled : false , Image Cleanup Disabled : false , Minimum Image Deletion Age : Default Image Deletion Age , Image Cleanup Interval : Default Image Cleanup Time Interval , Image Pull Inactivity Timeout : default Image Pull Inactivity Timeout , Num Images To Delete Per Cycle : Default Num Images To Delete Per Cycle , Num Non ECSContainers To Delete Per Cycle : Default Num Non ECSContainers To Delete Per Cycle , CNIPlugins Path : default CNIPlugins Path , Pause Container Tarball Path : pause Container Tarball Path , Pause Container Image Name : Default Pause Container Image Name , Pause Container Tag : Default Pause Container Tag , AWSVPCBlock Instance Metdata : false , Container Metadata Enabled : false , Task CPUMem Limit : Default Enabled , Cgroup Path : default Cgroup Path , Task Metadata Steady State Rate : Default Task Metadata Steady State Rate , Task Metadata Burst Rate : Default Task Metadata Burst Rate , Shared Volume Match Full Config : false , } 
func ( cfg * Config ) platform String ( ) string { } return " " } 
func Map Container To Task Status ( known State apicontainerstatus . Container Status , steady State apicontainerstatus . Container Status ) Task Status { switch known State { case apicontainerstatus . Container Status None : return Task Status None case steady State : return Task Running case apicontainerstatus . Container Created : return Task Created case apicontainerstatus . Container Stopped : return Task Stopped } if known State = = apicontainerstatus . Container Running & & steady State = = apicontainerstatus . Container Resources Provisioned { return Task Created } return Task Status None } 
func Map Task To Container Status ( desired State Task Status , steady State apicontainerstatus . Container Status ) apicontainerstatus . Container Status { switch desired State { case Task Status None : return apicontainerstatus . Container Status None case Task Created : return apicontainerstatus . Container Created case Task Running : return steady State case Task Stopped : return apicontainerstatus . Container Stopped } return apicontainerstatus . Container Status None } 
func ( me Multi Err ) Error ( ) string { ret : = make ( [ ] string , len ( me . errors ) + 1 ) ret [ 0 ] = " " for ndx , err : = range me . errors { ret [ ndx + 1 ] = fmt . Sprintf ( " \t " , ndx , err . Error ( ) ) } return strings . Join ( ret , " \n " ) } 
func New Multi Error ( errs . . . error ) error { errors : = make ( [ ] error , 0 , len ( errs ) ) for _ , err : = range errs { if err ! = nil { errors = append ( errors , err ) } } return Multi Err { errors } } 
func ( auth * ECRAuth Data ) Get Pull Credentials ( ) credentials . IAMRole Credentials { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . pull Credentials } 
func ( auth * ECRAuth Data ) Set Pull Credentials ( creds credentials . IAMRole Credentials ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . pull Credentials = creds } 
func ( auth * ASMAuth Data ) Get Docker Auth Config ( ) types . Auth Config { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . docker Auth Config } 
func ( auth * ASMAuth Data ) Set Docker Auth Config ( dac types . Auth Config ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . docker Auth Config = dac } 
func New Mock Secrets Manager API ( ctrl * gomock . Controller ) * Mock Secrets Manager API { mock : = & Mock Secrets Manager API { ctrl : ctrl } mock . recorder = & Mock Secrets Manager APIMock Recorder { mock } return mock } 
func ( m * Mock Secrets Manager API ) Cancel Rotate Secret ( arg 0 * secretsmanager . Cancel Rotate Secret Input ) ( * secretsmanager . Cancel Rotate Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Cancel Rotate Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Secrets Manager APIMock Recorder ) Cancel Rotate Secret ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Secrets Manager API ) ( nil ) . Cancel Rotate Secret ) , arg 0 ) } 
func ( m * Mock Secrets Manager API ) Cancel Rotate Secret Request ( arg 0 * secretsmanager . Cancel Rotate Secret Input ) ( * request . Request , * secretsmanager . Cancel Rotate Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Cancel Rotate Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Cancel Rotate Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Cancel Rotate Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Cancel Rotate Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Cancel Rotate Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Create Secret ( arg 0 * secretsmanager . Create Secret Input ) ( * secretsmanager . Create Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Create Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Create Secret Request ( arg 0 * secretsmanager . Create Secret Input ) ( * request . Request , * secretsmanager . Create Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Create Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Create Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Create Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Create Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Create Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Resource Policy ( arg 0 * secretsmanager . Delete Resource Policy Input ) ( * secretsmanager . Delete Resource Policy Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Delete Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Resource Policy Request ( arg 0 * secretsmanager . Delete Resource Policy Input ) ( * request . Request , * secretsmanager . Delete Resource Policy Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Delete Resource Policy Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Resource Policy With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Delete Resource Policy Input , arg 2 . . . request . Option ) ( * secretsmanager . Delete Resource Policy Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Delete Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Secret ( arg 0 * secretsmanager . Delete Secret Input ) ( * secretsmanager . Delete Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Delete Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Secret Request ( arg 0 * secretsmanager . Delete Secret Input ) ( * request . Request , * secretsmanager . Delete Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Delete Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Delete Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Delete Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Delete Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Delete Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Describe Secret ( arg 0 * secretsmanager . Describe Secret Input ) ( * secretsmanager . Describe Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Describe Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Describe Secret Request ( arg 0 * secretsmanager . Describe Secret Input ) ( * request . Request , * secretsmanager . Describe Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Describe Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Describe Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Describe Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Describe Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Describe Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Random Password ( arg 0 * secretsmanager . Get Random Password Input ) ( * secretsmanager . Get Random Password Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Random Password Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Random Password Request ( arg 0 * secretsmanager . Get Random Password Input ) ( * request . Request , * secretsmanager . Get Random Password Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Get Random Password Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Random Password With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Get Random Password Input , arg 2 . . . request . Option ) ( * secretsmanager . Get Random Password Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Random Password Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Resource Policy ( arg 0 * secretsmanager . Get Resource Policy Input ) ( * secretsmanager . Get Resource Policy Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Resource Policy Request ( arg 0 * secretsmanager . Get Resource Policy Input ) ( * request . Request , * secretsmanager . Get Resource Policy Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Get Resource Policy Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Resource Policy With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Get Resource Policy Input , arg 2 . . . request . Option ) ( * secretsmanager . Get Resource Policy Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Secret Value ( arg 0 * secretsmanager . Get Secret Value Input ) ( * secretsmanager . Get Secret Value Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Secret Value Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Secret Value Request ( arg 0 * secretsmanager . Get Secret Value Input ) ( * request . Request , * secretsmanager . Get Secret Value Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Get Secret Value Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Get Secret Value With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Get Secret Value Input , arg 2 . . . request . Option ) ( * secretsmanager . Get Secret Value Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Get Secret Value Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) List Secret Version Ids ( arg 0 * secretsmanager . List Secret Version Ids Input ) ( * secretsmanager . List Secret Version Ids Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . List Secret Version Ids Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) List Secret Version Ids Pages ( arg 0 * secretsmanager . List Secret Version Ids Input , arg 1 func ( * secretsmanager . List Secret Version Ids Output , bool ) bool ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Secrets Manager API ) List Secret Version Ids Pages With Context ( arg 0 aws . Context , arg 1 * secretsmanager . List Secret Version Ids Input , arg 2 func ( * secretsmanager . List Secret Version Ids Output , bool ) bool , arg 3 . . . request . Option ) error { varargs : = [ ] interface { } { arg 0 , arg 1 , arg 2 } for _ , a : = range arg 3 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Secrets Manager API ) List Secret Version Ids Request ( arg 0 * secretsmanager . List Secret Version Ids Input ) ( * request . Request , * secretsmanager . List Secret Version Ids Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . List Secret Version Ids Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) List Secrets ( arg 0 * secretsmanager . List Secrets Input ) ( * secretsmanager . List Secrets Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . List Secrets Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) List Secrets Pages ( arg 0 * secretsmanager . List Secrets Input , arg 1 func ( * secretsmanager . List Secrets Output , bool ) bool ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Secrets Manager API ) List Secrets Request ( arg 0 * secretsmanager . List Secrets Input ) ( * request . Request , * secretsmanager . List Secrets Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . List Secrets Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) List Secrets With Context ( arg 0 aws . Context , arg 1 * secretsmanager . List Secrets Input , arg 2 . . . request . Option ) ( * secretsmanager . List Secrets Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . List Secrets Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Resource Policy ( arg 0 * secretsmanager . Put Resource Policy Input ) ( * secretsmanager . Put Resource Policy Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Put Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Resource Policy Request ( arg 0 * secretsmanager . Put Resource Policy Input ) ( * request . Request , * secretsmanager . Put Resource Policy Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Put Resource Policy Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Resource Policy With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Put Resource Policy Input , arg 2 . . . request . Option ) ( * secretsmanager . Put Resource Policy Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Put Resource Policy Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Secret Value ( arg 0 * secretsmanager . Put Secret Value Input ) ( * secretsmanager . Put Secret Value Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Put Secret Value Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Secret Value Request ( arg 0 * secretsmanager . Put Secret Value Input ) ( * request . Request , * secretsmanager . Put Secret Value Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Put Secret Value Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Put Secret Value With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Put Secret Value Input , arg 2 . . . request . Option ) ( * secretsmanager . Put Secret Value Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Put Secret Value Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Restore Secret ( arg 0 * secretsmanager . Restore Secret Input ) ( * secretsmanager . Restore Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Restore Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Restore Secret Request ( arg 0 * secretsmanager . Restore Secret Input ) ( * request . Request , * secretsmanager . Restore Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Restore Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Restore Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Restore Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Restore Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Restore Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Rotate Secret ( arg 0 * secretsmanager . Rotate Secret Input ) ( * secretsmanager . Rotate Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Rotate Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Rotate Secret Request ( arg 0 * secretsmanager . Rotate Secret Input ) ( * request . Request , * secretsmanager . Rotate Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Rotate Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Rotate Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Rotate Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Rotate Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Rotate Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Tag Resource ( arg 0 * secretsmanager . Tag Resource Input ) ( * secretsmanager . Tag Resource Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Tag Resource Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Tag Resource Request ( arg 0 * secretsmanager . Tag Resource Input ) ( * request . Request , * secretsmanager . Tag Resource Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Tag Resource Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Untag Resource ( arg 0 * secretsmanager . Untag Resource Input ) ( * secretsmanager . Untag Resource Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Untag Resource Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Untag Resource Request ( arg 0 * secretsmanager . Untag Resource Input ) ( * request . Request , * secretsmanager . Untag Resource Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Untag Resource Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Untag Resource With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Untag Resource Input , arg 2 . . . request . Option ) ( * secretsmanager . Untag Resource Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Untag Resource Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Update Secret ( arg 0 * secretsmanager . Update Secret Input ) ( * secretsmanager . Update Secret Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Update Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Update Secret Request ( arg 0 * secretsmanager . Update Secret Input ) ( * request . Request , * secretsmanager . Update Secret Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Update Secret Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Update Secret Version Stage ( arg 0 * secretsmanager . Update Secret Version Stage Input ) ( * secretsmanager . Update Secret Version Stage Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Update Secret Version Stage Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Update Secret Version Stage Request ( arg 0 * secretsmanager . Update Secret Version Stage Input ) ( * request . Request , * secretsmanager . Update Secret Version Stage Output ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * request . Request ) ret 1 , _ : = ret [ 1 ] . ( * secretsmanager . Update Secret Version Stage Output ) return ret 0 , ret 1 } 
func ( m * Mock Secrets Manager API ) Update Secret Version Stage With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Update Secret Version Stage Input , arg 2 . . . request . Option ) ( * secretsmanager . Update Secret Version Stage Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Update Secret Version Stage Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Secrets Manager APIMock Recorder ) Update Secret Version Stage With Context ( arg 0 , arg 1 interface { } , arg 2 . . . interface { } ) * gomock . Call { varargs : = append ( [ ] interface { } { arg 0 , arg 1 } , arg 2 . . . ) return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Secrets Manager API ) ( nil ) . Update Secret Version Stage With Context ) , varargs . . . ) } 
func ( m * Mock Secrets Manager API ) Update Secret With Context ( arg 0 aws . Context , arg 1 * secretsmanager . Update Secret Input , arg 2 . . . request . Option ) ( * secretsmanager . Update Secret Output , error ) { varargs : = [ ] interface { } { arg 0 , arg 1 } for _ , a : = range arg 2 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( * secretsmanager . Update Secret Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func create Binds Env ( binds [ ] string , env [ ] string , data Dir On Host string , metadata Directory Path string ) ( [ ] string , [ ] string ) { rand ID : = uuid . New ( ) instance Bind : = fmt . Sprintf ( ` %s / %s : %s / %s ` , data Dir On Host , metadata Directory Path , mount Point , rand ID ) metadata Env Variable : = fmt . Sprintf ( " " , metadata Environment Variable , mount Point , rand ID , metadata File ) binds = append ( binds , instance Bind ) env = append ( env , metadata Env Variable ) return binds , env } 
func write To Metadata File ( os Wrap oswrapper . OS , ioutil Wrap ioutilwrapper . IOUtil , data [ ] byte , task ARN string , container Name string , data Dir string ) error { metadata File Dir , err : = get Metadata File Path ( task ARN , container Name , data Dir ) } metadata File Name : = filepath . Join ( metadata File Dir , metadata File ) temp , err : = ioutil Wrap . Temp File ( metadata File Dir , temp File ) if err ! = nil { return err } defer temp . Close ( ) _ , err = temp . Write ( data ) if err ! = nil { return err } err = temp . Chmod ( metadata Perm ) if err ! = nil { return err } return os Wrap . Rename ( temp . Name ( ) , metadata File Name ) } 
func ( manager * metadata Manager ) parse Metadata At Container Create ( task * apitask . Task , container Name string ) Metadata { return Metadata { cluster : manager . cluster , task Metadata : Task Metadata { container Name : container Name , task ARN : task . Arn , task Definition Family : task . Family , task Definition Revision : task . Version , } , container Instance ARN : manager . container Instance ARN , metadata Status : Metadata Initial , availability Zone : manager . availability Zone , host Public IPv 4Address : manager . host Public IPv 4Address , } } 
func ( manager * metadata Manager ) parse Metadata ( docker Container * types . Container JSON , task * apitask . Task , container Name string ) Metadata { docker MD : = parse Docker Container Metadata ( task . Arn , container Name , docker Container ) return Metadata { cluster : manager . cluster , task Metadata : Task Metadata { container Name : container Name , task ARN : task . Arn , task Definition Family : task . Family , task Definition Revision : task . Version , } , docker Container Metadata : docker MD , container Instance ARN : manager . container Instance ARN , metadata Status : Metadata Ready , availability Zone : manager . availability Zone , host Public IPv 4Address : manager . host Public IPv 4Address , } } 
func parse Docker Container Metadata ( task ARN string , container Name string , docker Container * types . Container JSON ) Docker Container Metadata { if docker Container = = nil { seelog . Warnf ( " " , task ARN , container Name ) return Docker Container Metadata { } } if docker Container . Config ! = nil { image Name From Config = docker Container . Config . Image } else { seelog . Warnf ( " " , task ARN , container Name ) } if docker Container . Container JSONBase = = nil { seelog . Warnf ( " " , task ARN , container Name ) return Docker Container Metadata { image Name : image Name From Config , } } network Metadata , err : = parse Network Metadata ( docker Container . Network Settings , docker Container . Host Config ) if err ! = nil { seelog . Warnf ( " " , task ARN , container Name , err ) } ports , err = apicontainer . Port Binding From Docker Port Binding ( docker Container . Network Settings . Ports ) if err ! = nil { seelog . Warnf ( " " , task ARN , container Name , err ) } return Docker Container Metadata { container ID : docker Container . ID , docker Container Name : docker Container . Name , image ID : docker Container . Image , image Name : image Name From Config , ports : ports , network Info : network Metadata , } } 
func parse Network Metadata ( settings * types . Network Settings , host Config * dockercontainer . Host Config ) ( Network Metadata , error ) { return Network Metadata { } , err } if host Config = = nil { err : = fmt . Errorf ( " " ) return Network Metadata { } , err } network Mode From Host Config : = string ( host Config . Network Mode ) if len ( settings . Networks ) > 0 { for mode From Settings , container Network : = range settings . Networks { network Mode : = mode From Settings ipv 4Addresses : = [ ] string { container Network . IPAddress } network : = Network { Network Mode : network Mode , IPv 4Addresses : ipv 4Addresses } network List = append ( network List , network ) } } else { ipv 4Addresses : = [ ] string { ipv 4Address From Settings } network : = Network { Network Mode : network Mode From Host Config , IPv 4Addresses : ipv 4Addresses } network List = append ( network List , network ) } return Network Metadata { networks : network List , } , nil } 
func ( n * Nvidia GPUManager ) Initialize ( ) error { if GPUInfo File Exists ( ) { if err ! = nil { return errors . Wrapf ( err , " " ) } var nvidia GPUInfo Nvidia GPUManager err = json . Unmarshal ( gpu JSON , & nvidia GPUInfo ) if err ! = nil { return errors . Wrapf ( err , " " ) } n . Set Driver Version ( nvidia GPUInfo . Get Driver Version ( ) ) nvidia GPUInfo . lock . RLock ( ) gpu IDs : = nvidia GPUInfo . Get GPUIDs Unsafe ( ) nvidia GPUInfo . lock . RUnlock ( ) n . Set GPUIDs ( gpu IDs ) n . Set Devices ( ) } else { seelog . Error ( " " ) } return nil } 
func ( n * Nvidia GPUManager ) Set GPUIDs ( gpu IDs [ ] string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . GPUIDs = gpu IDs } 
func ( n * Nvidia GPUManager ) Set Driver Version ( version string ) { n . lock . Lock ( ) defer n . lock . Unlock ( ) n . Driver Version = version } 
func ( n * Nvidia GPUManager ) Get Driver Version ( ) string { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . Driver Version } 
func ( n * Nvidia GPUManager ) Get Devices ( ) [ ] * ecs . Platform Device { n . lock . RLock ( ) defer n . lock . RUnlock ( ) return n . GPUDevices } 
func New Mock License Provider ( ctrl * gomock . Controller ) * Mock License Provider { mock : = & Mock License Provider { ctrl : ctrl } mock . recorder = & Mock License Provider Mock Recorder { mock } return mock } 
func ( m * Mock License Provider ) Get Text ( ) ( string , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock License Provider Mock Recorder ) Get Text ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock License Provider ) ( nil ) . Get Text ) ) } 
func New Mock Backoff ( ctrl * gomock . Controller ) * Mock Backoff { mock : = & Mock Backoff { ctrl : ctrl } mock . recorder = & Mock Backoff Mock Recorder { mock } return mock } 
func ( m * Mock Backoff ) Duration ( ) time . Duration { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( time . Duration ) return ret 0 } 
func ( mr * Mock Backoff Mock Recorder ) Duration ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Backoff ) ( nil ) . Duration ) ) } 
func ( status * Metadata Status ) Unmarshal Text ( text [ ] byte ) error { t : = string ( text ) switch t { case Metadata Initial Text : * status = Metadata Initial case Metadata Ready Text : * status = Metadata Ready default : return fmt . Errorf ( " " , text ) } return nil } 
func ( * Default Time ) After ( d time . Duration ) < - chan time . Time { return time . After ( d ) } 
func ( * Default Time ) After Func ( d time . Duration , f func ( ) ) Timer { return time . After Func ( d , f ) } 
func Since ( t time . Time ) time . Duration { return _time . Now ( ) . Sub ( t ) } 
func New Mock Task Resource ( ctrl * gomock . Controller ) * Mock Task Resource { mock : = & Mock Task Resource { ctrl : ctrl } mock . recorder = & Mock Task Resource Mock Recorder { mock } return mock } 
func ( m * Mock Task Resource ) Apply Transition ( arg 0 status 0 . Resource Status ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Task Resource ) Cleanup ( ) error { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Task Resource ) Get Created At ( ) time . Time { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( time . Time ) return ret 0 } 
func ( m * Mock Task Resource ) Get Terminal Reason ( ) string { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( string ) return ret 0 } 
func ( m * Mock Task Resource ) Initialize ( arg 0 * taskresource . Resource Fields , arg 1 , arg 2 status . Task Status ) { m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) } 
func ( mr * Mock Task Resource Mock Recorder ) Initialize ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Resource ) ( nil ) . Initialize ) , arg 0 , arg 1 , arg 2 ) } 
func ( m * Mock Task Resource ) Known Created ( ) bool { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( mr * Mock Task Resource Mock Recorder ) Marshal JSON ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Resource ) ( nil ) . Marshal JSON ) ) } 
func ( m * Mock Task Resource ) Next Known State ( ) status 0 . Resource Status { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( status 0 . Resource Status ) return ret 0 } 
func ( m * Mock Task Resource ) Set Applied Status ( arg 0 status 0 . Resource Status ) bool { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( mr * Mock Task Resource Mock Recorder ) Set Applied Status ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Resource ) ( nil ) . Set Applied Status ) , arg 0 ) } 
func ( m * Mock Task Resource ) Set Created At ( arg 0 time . Time ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Resource ) Set Desired Status ( arg 0 status 0 . Resource Status ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Resource ) Set Known Status ( arg 0 status 0 . Resource Status ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Resource ) Status String ( arg 0 status 0 . Resource Status ) string { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( string ) return ret 0 } 
func New Mock Loader ( ctrl * gomock . Controller ) * Mock Loader { mock : = & Mock Loader { ctrl : ctrl } mock . recorder = & Mock Loader Mock Recorder { mock } return mock } 
func ( m * Mock Loader ) Load Image ( arg 0 context . Context , arg 1 * config . Config , arg 2 dockerapi . Docker Client ) ( * types . Image Inspect , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( * types . Image Inspect ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Loader Mock Recorder ) Load Image ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Loader ) ( nil ) . Load Image ) , arg 0 , arg 1 , arg 2 ) } 
func ( cnferror Container Not Found ) Error ( ) string { return fmt . Sprintf ( " " , cnferror . Container Name , cnferror . Task Arn ) } 
func ( event * Docker Container Change Event ) String ( ) string { res : = fmt . Sprintf ( " " , event . Status . String ( ) , event . Docker ID ) res + = " " + event . Health . Status . String ( ) if event . Exit Code ! = nil { res + = fmt . Sprintf ( " " , aws . Int Value ( event . Exit Code ) ) } if len ( event . Port Bindings ) ! = 0 { res + = fmt . Sprintf ( " " , event . Port Bindings ) } if event . Error ! = nil { res + = " " + event . Error . Error ( ) } if len ( event . Volumes ) ! = 0 { res + = fmt . Sprintf ( " " , event . Volumes ) } if len ( event . Labels ) ! = 0 { res + = fmt . Sprintf ( " " , event . Labels ) } if ! event . Created At . Is Zero ( ) { res + = " " + event . Created At . String ( ) } if ! event . Started At . Is Zero ( ) { res + = " " + event . Started At . String ( ) } if ! event . Finished At . Is Zero ( ) { res + = " " + event . Finished At . String ( ) } return res } 
func ( tv * Task Volume ) Unmarshal JSON ( b [ ] byte ) error { if err : = json . Unmarshal ( b , & intermediate ) ; err ! = nil { return err } name , ok : = intermediate [ " " ] if ! ok { return errors . New ( " " ) } if err : = json . Unmarshal ( name , & tv . Name ) ; err ! = nil { return err } volume Type , ok : = intermediate [ " " ] if ! ok { volume Type = [ ] byte ( ` "host " ` ) seelog . Infof ( " " ) } if err : = json . Unmarshal ( volume Type , & tv . Type ) ; err ! = nil { return err } switch tv . Type { case Host Volume Type : return tv . unmarshal Host Volume ( intermediate [ " " ] ) case Docker Volume Type : return tv . unmarshal Docker Volume ( intermediate [ " " ] ) default : return errors . Errorf ( " " , tv . Type ) } } 
func ( tv * Task Volume ) Marshal JSON ( ) ( [ ] byte , error ) { result : = make ( map [ string ] interface { } ) if len ( tv . Type ) = = 0 { tv . Type = Host Volume Type } result [ " " ] = tv . Name result [ " " ] = tv . Type switch tv . Type { case Docker Volume Type : result [ " " ] = tv . Volume case Host Volume Type : result [ " " ] = tv . Volume default : return nil , errors . Errorf ( " " , tv . Type ) } return json . Marshal ( result ) } 
func ( agent * ecs Agent ) check Compatibility ( engine engine . Task Engine ) error { } tasks , err : = engine . List Tasks ( ) if err ! = nil { return err } for _ , task : = range tasks { if ! task . Memory CPULimits Enabled { seelog . Warnf ( " " , task . Arn ) compatible = false break } } if compatible { return nil } if agent . cfg . Task CPUMem Limit = = config . Explicitly Enabled { return errors . New ( " " ) } seelog . Warn ( " " ) agent . cfg . Task CPUMem Limit = config . Explicitly Disabled return nil } 
func ( * ssm Client Creator ) New SSMClient ( region string , creds credentials . IAMRole Credentials ) ssmclient . SSMClient { cfg : = aws . New Config ( ) . With HTTPClient ( httpclient . New ( roundtrip Timeout , false ) ) . With Region ( region ) . With Credentials ( awscreds . New Static Credentials ( creds . Access Key ID , creds . Secret Access Key , creds . Session Token ) ) sess : = session . Must ( session . New Session ( cfg ) ) return ssm . New ( sess ) } 
func ( f * factory ) Get Client ( version dockerclient . Docker Version ) ( sdkclient . Client , error ) { for _ , v : = range get Windows Replaceable Versions ( ) { if v = = version { version = min Docker APIVersion break } } return f . get Client ( version ) } 
func get Windows Replaceable Versions ( ) [ ] dockerclient . Docker Version { return [ ] dockerclient . Docker Version { dockerclient . Version _ 1 _ 1 7 , dockerclient . Version _ 1 _ 1 8 , dockerclient . Version _ 1 _ 1 9 , dockerclient . Version _ 1 _ 2 0 , dockerclient . Version _ 1 _ 2 1 , dockerclient . Version _ 1 _ 2 2 , dockerclient . Version _ 1 _ 2 3 , } } 
func get Windows Supported Versions ( ) [ ] dockerclient . Docker Version { return [ ] dockerclient . Docker Version { dockerclient . Version _ 1 _ 2 4 , dockerclient . Version _ 1 _ 2 5 , dockerclient . Version _ 1 _ 2 6 , dockerclient . Version _ 1 _ 2 7 , dockerclient . Version _ 1 _ 2 8 , dockerclient . Version _ 1 _ 2 9 , dockerclient . Version _ 1 _ 3 0 , } } 
func Port Binding From Docker Port Binding ( docker Port Bindings nat . Port Map ) ( [ ] Port Binding , apierrors . Named Error ) { port Bindings : = make ( [ ] Port Binding , 0 , len ( docker Port Bindings ) ) for port , bindings : = range docker Port Bindings { container Port , err : = nat . Parse Port ( port . Port ( ) ) if err ! = nil { return nil , & apierrors . Default Named Error { Name : Unparseable Port Error Name , Err : " " + err . Error ( ) } } protocol , err : = New Transport Protocol ( port . Proto ( ) ) if err ! = nil { return nil , & apierrors . Default Named Error { Name : Unrecognized Transport Protocol Error Name , Err : err . Error ( ) } } for _ , binding : = range bindings { host Port , err : = strconv . Atoi ( binding . Host Port ) if err ! = nil { return nil , & apierrors . Default Named Error { Name : Unparseable Port Error Name , Err : " " + err . Error ( ) } } port Bindings = append ( port Bindings , Port Binding { Container Port : uint 1 6 ( container Port ) , Host Port : uint 1 6 ( host Port ) , Bind IP : binding . Host IP , Protocol : protocol , } ) } } return port Bindings , nil } 
func New ASMAuth Resource ( task ARN string , asm Requirements [ ] * apicontainer . ASMAuth Data , execution Credentials ID string , credentials Manager credentials . Manager , asm Client Creator factory . Client Creator ) * ASMAuth Resource { c : = & ASMAuth Resource { task ARN : task ARN , required ASMResources : asm Requirements , credentials Manager : credentials Manager , execution Credentials ID : execution Credentials ID , asm Client Creator : asm Client Creator , } c . init Status To Transition ( ) return c } 
func ( auth * ASMAuth Resource ) Set Desired Status ( status resourcestatus . Resource Status ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . desired Status Unsafe = status } 
func ( auth * ASMAuth Resource ) Get Desired Status ( ) resourcestatus . Resource Status { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . desired Status Unsafe } 
func ( auth * ASMAuth Resource ) Get Name ( ) string { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return Resource Name } 
func ( auth * ASMAuth Resource ) Desired Terminal ( ) bool { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . desired Status Unsafe = = resourcestatus . Resource Status ( ASMAuth Status Removed ) } 
func ( auth * ASMAuth Resource ) Known Created ( ) bool { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . known Status Unsafe = = resourcestatus . Resource Status ( ASMAuth Status Created ) } 
func ( auth * ASMAuth Resource ) Apply Transition ( next State resourcestatus . Resource Status ) error { transition Func , ok : = auth . resource Status To Transition Function [ next State ] if ! ok { return errors . Errorf ( " " , auth . Get Name ( ) , auth . Status String ( next State ) ) } return transition Func ( ) } 
func ( auth * ASMAuth Resource ) Set Known Status ( status resourcestatus . Resource Status ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . known Status Unsafe = status auth . update Applied Status Unsafe ( status ) } 
func ( auth * ASMAuth Resource ) update Applied Status Unsafe ( known Status resourcestatus . Resource Status ) { if auth . applied Status = = resourcestatus . Resource Status ( ASMAuth Status None ) { return } } } 
func ( auth * ASMAuth Resource ) Set Applied Status ( status resourcestatus . Resource Status ) bool { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) if auth . applied Status ! = resourcestatus . Resource Status ( ASMAuth Status None ) { } auth . applied Status = status return true } 
func ( auth * ASMAuth Resource ) Get Known Status ( ) resourcestatus . Resource Status { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . known Status Unsafe } 
func ( auth * ASMAuth Resource ) Status String ( status resourcestatus . Resource Status ) string { return ASMAuth Status ( status ) . String ( ) } 
func ( auth * ASMAuth Resource ) Set Created At ( created At time . Time ) { if created At . Is Zero ( ) { return } auth . lock . Lock ( ) defer auth . lock . Unlock ( ) auth . created At = created At } 
func ( auth * ASMAuth Resource ) Get Created At ( ) time . Time { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . created At } 
func ( auth * ASMAuth Resource ) Create ( ) error { seelog . Infof ( " " , auth . task ARN ) if auth . docker Auth Data = = nil { auth . docker Auth Data = make ( map [ string ] types . Auth Config ) } for _ , a : = range auth . Get Required ASMResources ( ) { err : = auth . retrieve ASMDocker Auth Data ( a ) if err ! = nil { auth . set Terminal Reason ( err . Error ( ) ) return err } } return nil } 
func ( auth * ASMAuth Resource ) Get Required ASMResources ( ) [ ] * apicontainer . ASMAuth Data { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . required ASMResources } 
func ( auth * ASMAuth Resource ) Get Execution Credentials ID ( ) string { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) return auth . execution Credentials ID } 
func ( auth * ASMAuth Resource ) clear ASMDocker Auth Config ( ) { auth . lock . Lock ( ) defer auth . lock . Unlock ( ) for k : = range auth . docker Auth Data { delete ( auth . docker Auth Data , k ) } } 
func ( auth * ASMAuth Resource ) Get ASMDocker Auth Config ( secret ID string ) ( types . Auth Config , bool ) { auth . lock . RLock ( ) defer auth . lock . RUnlock ( ) d , ok : = auth . docker Auth Data [ secret ID ] return d , ok } 
func ( auth * ASMAuth Resource ) Marshal JSON ( ) ( [ ] byte , error ) { if auth = = nil { return nil , errors . New ( " " ) } created At : = auth . Get Created At ( ) return json . Marshal ( asm Auth Resource JSON { Task ARN : auth . task ARN , Created At : & created At , Desired Status : func ( ) * ASMAuth Status { desired State : = auth . Get Desired Status ( ) status : = ASMAuth Status ( desired State ) return & status } ( ) , Known Status : func ( ) * ASMAuth Status { known State : = auth . Get Known Status ( ) status : = ASMAuth Status ( known State ) return & status } ( ) , Required ASMResources : auth . Get Required ASMResources ( ) , Execution Credentials ID : auth . Get Execution Credentials ID ( ) , } ) } 
func ( auth * ASMAuth Resource ) Unmarshal JSON ( b [ ] byte ) error { temp : = asm Auth Resource JSON { } if err : = json . Unmarshal ( b , & temp ) ; err ! = nil { return err } if temp . Desired Status ! = nil { auth . Set Desired Status ( resourcestatus . Resource Status ( * temp . Desired Status ) ) } if temp . Known Status ! = nil { auth . Set Known Status ( resourcestatus . Resource Status ( * temp . Known Status ) ) } if temp . Created At ! = nil & & ! temp . Created At . Is Zero ( ) { auth . Set Created At ( * temp . Created At ) } if temp . Required ASMResources ! = nil { auth . required ASMResources = temp . Required ASMResources } auth . task ARN = temp . Task ARN auth . execution Credentials ID = temp . Execution Credentials ID return nil } 
func Container Metadata Handler ( state dockerstate . Task Engine State ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { container ID , err : = get Container IDBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Metadata ) return } container Response , err : = Get Container Response ( container ID , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( err . Error ( ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Container Metadata ) return } seelog . Infof ( " " , container ID ) response JSON , _ : = json . Marshal ( container Response ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Container Metadata ) } } 
func Get Container Response ( container ID string , state dockerstate . Task Engine State ) ( * v 2 . Container Response , error ) { container Response , err : = v 2 . New Container Response ( container ID , state ) if err ! = nil { return nil , errors . Errorf ( " " , container ID ) } } } return container Response , nil } 
func Get Container Network Metadata ( container ID string , state dockerstate . Task Engine State ) ( [ ] containermetadata . Network , error ) { docker Container , ok : = state . Container By ID ( container ID ) if ! ok { return nil , errors . Errorf ( " " , container ID ) } if settings = = nil { return nil , errors . Errorf ( " " , container ID ) } network Mode From Host Config : = docker Container . Container . Get Network Mode ( ) if len ( settings . Networks ) > 0 { for mode From Settings , container Network : = range settings . Networks { network Mode : = mode From Settings ipv 4Addresses : = [ ] string { container Network . IPAddress } network : = containermetadata . Network { Network Mode : network Mode , IPv 4Addresses : ipv 4Addresses } networks = append ( networks , network ) } } else { ipv 4Addresses : = [ ] string { ipv 4Address From Settings } network : = containermetadata . Network { Network Mode : network Mode From Host Config , IPv 4Addresses : ipv 4Addresses } networks = append ( networks , network ) } return networks , nil } 
func ( cgroup * Cgroup Resource ) Initialize ( resource Fields * taskresource . Resource Fields , task Known Status status . Task Status , task Desired Status status . Task Status ) { } 
func Start Default Termination Handler ( saver statemanager . Saver , task Engine engine . Task Engine ) { signal Channel : = make ( chan os . Signal , 2 ) signal . Notify ( signal Channel , os . Interrupt , syscall . SIGTERM ) sig : = < - signal Channel seelog . Debugf ( " " , sig . String ( ) ) err : = Final Save ( saver , task Engine ) if err ! = nil { seelog . Criticalf ( " " , err ) } os . Exit ( exitcodes . Exit Success ) } 
func Final Save ( saver statemanager . Saver , task Engine engine . Task Engine ) error { engine Disabled : = make ( chan error ) disable Timer : = time . After Func ( engine Disable Timeout , func ( ) { engine Disabled < - errors . New ( " " ) } ) go func ( ) { seelog . Debug ( " " ) task Engine . Disable ( ) disable Timer . Stop ( ) engine Disabled < - nil } ( ) disable Err : = < - engine Disabled state Saved : = make ( chan error ) save Timer : = time . After Func ( final Save Timeout , func ( ) { state Saved < - errors . New ( " " ) } ) go func ( ) { seelog . Debug ( " " ) state Saved < - saver . Force Save ( ) save Timer . Stop ( ) } ( ) save Err : = < - state Saved if disable Err ! = nil | | save Err ! = nil { return apierrors . New Multi Error ( disable Err , save Err ) } return nil } 
func ( key * cache Key ) String ( ) string { return fmt . Sprintf ( " " , key . role ARN , key . region , key . registry ID , key . endpoint Override ) } 
func New ECRAuth Provider ( ecr Factory ecr . ECRFactory , cache async . Cache ) Docker Auth Provider { return & ecr Auth Provider { token Cache : cache , factory : ecr Factory , } } 
func ( auth Provider * ecr Auth Provider ) Get Authconfig ( image string , registry Auth Data * apicontainer . Registry Authentication Data ) ( types . Auth Config , error ) { if registry Auth Data = = nil { return types . Auth Config { } , fmt . Errorf ( " " ) } auth Data : = registry Auth Data . ECRAuth Data if auth Data = = nil { return types . Auth Config { } , fmt . Errorf ( " " ) } } if auth ! = nil { return * auth , nil } } 
func ( auth Provider * ecr Auth Provider ) get Auth Config From Cache ( key cache Key ) * types . Auth Config { token , ok : = auth Provider . token Cache . Get ( key . String ( ) ) if ! ok { return nil } cached Token , ok : = token . ( * ecrapi . Authorization Data ) if ! ok { log . Warnf ( " " ) return nil } if auth Provider . Is Token Valid ( cached Token ) { auth , err : = extract Token ( cached Token ) if err ! = nil { log . Errorf ( " " , err ) return nil } return & auth } else { } return nil } 
func ( auth Provider * ecr Auth Provider ) get Auth Config From ECR ( image string , key cache Key , auth Data * apicontainer . ECRAuth Data ) ( types . Auth Config , error ) { if err ! = nil { return types . Auth Config { } , err } log . Debugf ( " " , image ) ecr Auth Data , err : = client . Get Authorization Token ( auth Data . Registry ID ) if err ! = nil { return types . Auth Config { } , err } if ecr Auth Data = = nil { return types . Auth Config { } , fmt . Errorf ( " " , image ) } return extract Token ( ecr Auth Data ) } return types . Auth Config { } , fmt . Errorf ( " " , image ) } 
func ( auth Provider * ecr Auth Provider ) Is Token Valid ( auth Data * ecrapi . Authorization Data ) bool { if auth Data = = nil | | auth Data . Expires At = = nil { return false } refresh Time : = aws . Time Value ( auth Data . Expires At ) . Add ( - 1 * retry . Add Jitter ( Minimum Jitter Duration , Minimum Jitter Duration ) ) return time . Now ( ) . Before ( refresh Time ) } 
func create Task Response ( task * apitask . Task , found bool , resource ID string , state dockerstate . Task Engine State ) ( [ ] byte , int ) { var response JSON [ ] byte status : = http . Status OK if found { container Map , _ : = state . Container Map By Arn ( task . Arn ) response JSON , _ = json . Marshal ( New Task Response ( task , container Map ) ) } else { seelog . Warn ( " " + resource ID ) response JSON , _ = json . Marshal ( & Task Response { } ) status = http . Status Not Found } return response JSON , status } 
func Task Container Metadata Handler ( task Engine utils . Docker State Resolver ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { var response JSON [ ] byte docker Task Engine State : = task Engine . State ( ) docker ID , docker IDExists : = utils . Value From Request ( r , docker IDQuery Field ) task Arn , task ARNExists : = utils . Value From Request ( r , task ARNQuery Field ) var status int if docker IDExists & & task ARNExists { seelog . Info ( " " , docker IDQuery Field , " " , task ARNQuery Field , " " ) w . Write Header ( http . Status Bad Request ) w . Write ( response JSON ) return } if docker IDExists { var found bool if len ( docker ID ) > docker Short IDLen { task , found = docker Task Engine State . Task By ID ( docker ID ) } else { tasks , _ : = docker Task Engine State . Task By Short ID ( docker ID ) if len ( tasks ) = = 0 { task = nil found = false } else if len ( tasks ) = = 1 { task = tasks [ 0 ] found = true } else { seelog . Info ( " " + docker ID ) w . Write Header ( http . Status Bad Request ) w . Write ( response JSON ) return } } response JSON , status = create Task Response ( task , found , docker ID , docker Task Engine State ) w . Write Header ( status ) } else if task ARNExists { response JSON , status = create Task Response ( task , found , task Arn , docker Task Engine State ) w . Write Header ( status ) } else { } w . Write ( response JSON ) } } 
func New Task State Change Event ( task * apitask . Task , reason string ) ( Task State Change , error ) { var event Task State Change task Known Status : = task . Get Known Status ( ) if ! task Known Status . Backend Recognized ( ) { return event , errors . Errorf ( " " , task Known Status ) } if task . Get Sent Status ( ) > = task Known Status { return event , errors . Errorf ( " " , task Known Status . String ( ) ) } event = Task State Change { Task ARN : task . Arn , Status : task Known Status , Reason : reason , Task : task , } event . Set Task Timestamps ( ) return event , nil } 
func New Container State Change Event ( task * apitask . Task , cont * apicontainer . Container , reason string ) ( Container State Change , error ) { var event Container State Change cont Known Status : = cont . Get Known Status ( ) if ! cont Known Status . Should Report To Backend ( cont . Get Steady State Status ( ) ) { return event , errors . Errorf ( " " , cont Known Status ) } if cont . Is Internal ( ) { return event , errors . Errorf ( " " , cont . Name ) } if cont . Get Sent Status ( ) > = cont Known Status { return event , errors . Errorf ( " " , cont Known Status . String ( ) , cont . Name , task . Arn ) } if reason = = " " & & cont . Applying Error ! = nil { reason = cont . Applying Error . Error ( ) } event = Container State Change { Task Arn : task . Arn , Container Name : cont . Name , Status : cont Known Status . Backend Status ( cont . Get Steady State Status ( ) ) , Exit Code : cont . Get Known Exit Code ( ) , Port Bindings : cont . Get Known Port Bindings ( ) , Reason : reason , Container : cont , } return event , nil } 
func ( c * Container State Change ) String ( ) string { res : = fmt . Sprintf ( " " , c . Task Arn , c . Container Name , c . Status . String ( ) ) if c . Exit Code ! = nil { res + = " " + strconv . Itoa ( * c . Exit Code ) + " " } if c . Reason ! = " " { res + = " " + c . Reason } if len ( c . Port Bindings ) ! = 0 { res + = fmt . Sprintf ( " " , c . Port Bindings ) } if c . Container ! = nil { res + = " " + c . Container . Get Sent Status ( ) . String ( ) } return res } 
func ( change * Task State Change ) Set Task Timestamps ( ) { if change . Task = = nil { return } } if timestamp : = change . Task . Get Pull Stopped At ( ) ; ! timestamp . Is Zero ( ) { change . Pull Stopped At = aws . Time ( timestamp . UTC ( ) ) } if timestamp : = change . Task . Get Execution Stopped At ( ) ; ! timestamp . Is Zero ( ) { change . Execution Stopped At = aws . Time ( timestamp . UTC ( ) ) } } 
func ( change * Task State Change ) Should Be Reported ( ) bool { } if len ( change . Containers ) ! = 0 { return true } return false } 
func ( change * Task State Change ) String ( ) string { res : = fmt . Sprintf ( " " , change . Task ARN , change . Status . String ( ) ) if change . Task ! = nil { res + = fmt . Sprintf ( " " , change . Task . Get Sent Status ( ) . String ( ) , change . Task . Get Pull Started At ( ) , change . Task . Get Pull Stopped At ( ) , change . Task . Get Execution Stopped At ( ) ) } if change . Attachment ! = nil { res + = " " + change . Attachment . String ( ) } for _ , container Change : = range change . Containers { res + = " " + container Change . String ( ) } return res } 
func ( eni * ENI ) Get IPV 4Addresses ( ) [ ] string { var addresses [ ] string for _ , addr : = range eni . IPV 4Addresses { addresses = append ( addresses , addr . Address ) } return addresses } 
func ( eni * ENI ) Get IPV 6Addresses ( ) [ ] string { var addresses [ ] string for _ , addr : = range eni . IPV 6Addresses { addresses = append ( addresses , addr . Address ) } return addresses } 
func ( eni * ENI ) String ( ) string { var ipv 4Addresses [ ] string for _ , addr : = range eni . IPV 4Addresses { ipv 4Addresses = append ( ipv 4Addresses , addr . Address ) } var ipv 6Addresses [ ] string for _ , addr : = range eni . IPV 6Addresses { ipv 6Addresses = append ( ipv 6Addresses , addr . Address ) } return fmt . Sprintf ( " " , eni . ID , eni . Mac Address , eni . Get Hostname ( ) , strings . Join ( ipv 4Addresses , " " ) , strings . Join ( ipv 6Addresses , " " ) , strings . Join ( eni . Domain Name Servers , " " ) , strings . Join ( eni . Domain Name Search List , " " ) , eni . Subnet Gateway IPV 4Address ) } 
func ENIFrom ACS ( acsenis [ ] * ecsacs . Elastic Network Interface ) ( * ENI , error ) { err : = Validate Task ENI ( acsenis ) if err ! = nil { return nil , err } var ipv 4 [ ] * ENIIPV 4Address var ipv 6 [ ] * ENIIPV 6Address } } eni : = & ENI { ID : aws . String Value ( acsenis [ 0 ] . Ec 2Id ) , IPV 4Addresses : ipv 4 , IPV 6Addresses : ipv 6 , Mac Address : aws . String Value ( acsenis [ 0 ] . Mac Address ) , Private DNSName : aws . String Value ( acsenis [ 0 ] . Private Dns Name ) , Subnet Gateway IPV 4Address : aws . String Value ( acsenis [ 0 ] . Subnet Gateway Ipv 4Address ) , } for _ , nameserver IP : = range acsenis [ 0 ] . Domain Name Servers { eni . Domain Name Servers = append ( eni . Domain Name Servers , aws . String Value ( nameserver IP ) ) } for _ , nameserver Domain : = range acsenis [ 0 ] . Domain Name { eni . Domain Name Search List = append ( eni . Domain Name Search List , aws . String Value ( nameserver Domain ) ) } return eni , nil } 
func Validate Task ENI ( acsenis [ ] * ecsacs . Elastic Network Interface ) error { } else if len ( acsenis [ 0 ] . Ipv 4Addresses ) ! = 1 { return errors . Errorf ( " " , len ( acsenis [ 0 ] . Ipv 4Addresses ) ) } else if len ( acsenis [ 0 ] . Ipv 6Addresses ) > 1 { return errors . Errorf ( " " , len ( acsenis [ 0 ] . Ipv 6Addresses ) ) } if acsenis [ 0 ] . Mac Address = = nil { return errors . Errorf ( " " ) } if acsenis [ 0 ] . Ec 2Id = = nil { return errors . Errorf ( " " ) } return nil } 
func New Mock Plugins ( ctrl * gomock . Controller ) * Mock Plugins { mock : = & Mock Plugins { ctrl : ctrl } mock . recorder = & Mock Plugins Mock Recorder { mock } return mock } 
func ( m * Mock Plugins ) Scan ( ) ( [ ] string , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Plugins Mock Recorder ) Scan ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Plugins ) ( nil ) . Scan ) ) } 
func Task From ACS ( acs Task * ecsacs . Task , envelope * ecsacs . Payload Message ) ( * Task , error ) { data , err : = jsonutil . Build JSON ( acs Task ) if err ! = nil { return nil , err } task : = & Task { } err = json . Unmarshal ( data , task ) if err ! = nil { return nil , err } if task . Get Desired Status ( ) = = apitaskstatus . Task Running & & envelope . Seq Num ! = nil { task . Start Sequence Number = * envelope . Seq Num } else if task . Get Desired Status ( ) = = apitaskstatus . Task Stopped & & envelope . Seq Num ! = nil { task . Stop Sequence Number = * envelope . Seq Num } } container . Transition Dependencies Map = make ( map [ apicontainerstatus . Container Status ] apicontainer . Transition Dependency Set ) } return task , nil } 
func ( task * Task ) Post Unmarshal Task ( cfg * config . Config , credentials Manager credentials . Manager , resource Fields * taskresource . Resource Fields , docker Client dockerapi . Docker Client , ctx context . Context ) error { if task . Memory CPULimits Enabled { err : = task . initialize Cgroup Resource Spec ( cfg . Cgroup Path , resource Fields ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . New Resource Init Error ( task . Arn , err ) } } err : = task . initialize Container Ordering For Volumes ( ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . New Resource Init Error ( task . Arn , err ) } err = task . initialize Container Ordering For Links ( ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . New Resource Init Error ( task . Arn , err ) } if task . requires ASMDocker Auth Data ( ) { task . initialize ASMAuth Resource ( credentials Manager , resource Fields ) } if task . requires SSMSecret ( ) { task . initialize SSMSecret Resource ( credentials Manager , resource Fields ) } if task . requires ASMSecret ( ) { task . initialize ASMSecret Resource ( credentials Manager , resource Fields ) } err = task . initialize Docker Local Volumes ( docker Client , ctx ) if err ! = nil { return apierrors . New Resource Init Error ( task . Arn , err ) } err = task . initialize Docker Volumes ( cfg . Shared Volume Match Full Config , docker Client , ctx ) if err ! = nil { return apierrors . New Resource Init Error ( task . Arn , err ) } if cfg . GPUSupport Enabled { err = task . add GPUResource ( ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . New Resource Init Error ( task . Arn , err ) } task . Nvidia Runtime = cfg . Nvidia Runtime } task . initialize Credentials Endpoint ( credentials Manager ) task . initialize Containers V 3Metadata Endpoint ( utils . New Dynamic UUIDProvider ( ) ) err = task . add Network Resource Provisioning Dependency ( cfg ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) return apierrors . New Resource Init Error ( task . Arn , err ) } return nil } 
func ( task * Task ) initialize Docker Volumes ( shared Volume Match Full Config bool , docker Client dockerapi . Docker Client , ctx context . Context ) error { for i , vol : = range task . Volumes { } docker Volume , ok : = vol . Volume . ( * taskresourcevolume . Docker Volume Config ) if ! ok { return errors . New ( " " ) } if err ! = nil { return err } } else { if err ! = nil { return err } } } return nil } 
func ( task * Task ) add Task Scoped Volumes ( ctx context . Context , docker Client dockerapi . Docker Client , vol * Task Volume ) error { volume Config : = vol . Volume . ( * taskresourcevolume . Docker Volume Config ) volume Resource , err : = taskresourcevolume . New Volume Resource ( ctx , vol . Name , task . volume Name ( vol . Name ) , volume Config . Scope , volume Config . Autoprovision , volume Config . Driver , volume Config . Driver Opts , volume Config . Labels , docker Client ) if err ! = nil { return err } vol . Volume = & volume Resource . Volume Config task . Add Resource ( resourcetype . Docker Volume Key , volume Resource ) task . update Container Volume Dependency ( vol . Name ) return nil } 
func ( task * Task ) add Shared Volumes ( Shared Volume Match Full Config bool , ctx context . Context , docker Client dockerapi . Docker Client , vol * Task Volume ) error { volume Config : = vol . Volume . ( * taskresourcevolume . Docker Volume Config ) volume Config . Docker Volume Name = vol . Name if volume Metadata . Error ! = nil { return errors . Wrapf ( volume Metadata . Error , " " , vol . Name ) } return nil } if volume Metadata . Error ! = nil { } seelog . Infof ( " " , task . Arn , vol . Name ) if err ! = nil { return err } task . Add Resource ( resourcetype . Docker Volume Key , volume Resource ) task . update Container Volume Dependency ( vol . Name ) return nil } seelog . Infof ( " " , task . Arn , volume Config . Docker Volume Name ) if ! Shared Volume Match Full Config { seelog . Infof ( " " , task . Arn , volume Config . Docker Volume Name ) return nil } } else if ! reflect . Deep Equal ( volume Metadata . Docker Volume . Labels , volume Config . Labels ) { return errors . Errorf ( " " , volume Metadata . Docker Volume . Labels , volume Config . Labels ) } if len ( volume Metadata . Docker Volume . Options ) = = 0 & & len ( volume Metadata . Docker Volume . Options ) = = len ( volume Config . Driver Opts ) { seelog . Infof ( " " , task . Arn , volume Config . Docker Volume Name ) } else if ! reflect . Deep Equal ( volume Metadata . Docker Volume . Options , volume Config . Driver Opts ) { return errors . Errorf ( " " , volume Metadata . Docker Volume . Options , volume Config . Driver Opts ) } } 
func ( task * Task ) update Container Volume Dependency ( name string ) { } } } } 
func ( task * Task ) initialize Credentials Endpoint ( credentials Manager credentials . Manager ) { id : = task . Get Credentials ID ( ) if id = = " " { } task Credentials , ok : = credentials Manager . Get Task Credentials ( id ) if ! ok { return } credentials Endpoint Relative URI : = task Credentials . IAMRole Credentials . Generate Credentials Endpoint Relative URI ( ) for _ , container : = range task . Containers { } container . Environment [ aws SDKCredentials Relative URIPath Environment Variable Name ] = credentials Endpoint Relative URI } } 
func ( task * Task ) initialize Containers V 3Metadata Endpoint ( uuid Provider utils . UUIDProvider ) { for _ , container : = range task . Containers { v 3Endpoint ID : = container . Get V 3Endpoint ID ( ) if v 3Endpoint ID = = " " { } container . Inject V 3Metadata Endpoint ( ) } } 
func ( task * Task ) requires ASMDocker Auth Data ( ) bool { for _ , container : = range task . Containers { if container . Should Pull With ASMAuth ( ) { return true } } return false } 
func ( task * Task ) initialize ASMAuth Resource ( credentials Manager credentials . Manager , resource Fields * taskresource . Resource Fields ) { asm Auth Resource : = asmauth . New ASMAuth Resource ( task . Arn , task . get All ASMAuth Data Requirements ( ) , task . Execution Credentials ID , credentials Manager , resource Fields . ASMClient Creator ) task . Add Resource ( asmauth . Resource Name , asm Auth Resource ) for _ , container : = range task . Containers { if container . Should Pull With ASMAuth ( ) { container . Build Resource Dependency ( asm Auth Resource . Get Name ( ) , resourcestatus . Resource Status ( asmauth . ASMAuth Status Created ) , apicontainerstatus . Container Pulled ) } } } 
func ( task * Task ) requires SSMSecret ( ) bool { for _ , container : = range task . Containers { if container . Should Create With SSMSecret ( ) { return true } } return false } 
func ( task * Task ) initialize SSMSecret Resource ( credentials Manager credentials . Manager , resource Fields * taskresource . Resource Fields ) { ssm Secret Resource : = ssmsecret . New SSMSecret Resource ( task . Arn , task . get All SSMSecret Requirements ( ) , task . Execution Credentials ID , credentials Manager , resource Fields . SSMClient Creator ) task . Add Resource ( ssmsecret . Resource Name , ssm Secret Resource ) } } } 
func ( task * Task ) get All SSMSecret Requirements ( ) map [ string ] [ ] apicontainer . Secret { reqs : = make ( map [ string ] [ ] apicontainer . Secret ) for _ , container : = range task . Containers { for _ , secret : = range container . Secrets { if secret . Provider = = apicontainer . Secret Provider SSM { if _ , ok : = reqs [ secret . Region ] ; ! ok { reqs [ secret . Region ] = [ ] apicontainer . Secret { } } reqs [ secret . Region ] = append ( reqs [ secret . Region ] , secret ) } } } return reqs } 
func ( task * Task ) requires ASMSecret ( ) bool { for _ , container : = range task . Containers { if container . Should Create With ASMSecret ( ) { return true } } return false } 
func ( task * Task ) initialize ASMSecret Resource ( credentials Manager credentials . Manager , resource Fields * taskresource . Resource Fields ) { asm Secret Resource : = asmsecret . New ASMSecret Resource ( task . Arn , task . get All ASMSecret Requirements ( ) , task . Execution Credentials ID , credentials Manager , resource Fields . ASMClient Creator ) task . Add Resource ( asmsecret . Resource Name , asm Secret Resource ) } } } 
func ( task * Task ) get All ASMSecret Requirements ( ) map [ string ] apicontainer . Secret { reqs : = make ( map [ string ] apicontainer . Secret ) for _ , container : = range task . Containers { for _ , secret : = range container . Secrets { if secret . Provider = = apicontainer . Secret Provider ASM { secret Key : = secret . Get Secret Resource Cache Key ( ) if _ , ok : = reqs [ secret Key ] ; ! ok { reqs [ secret Key ] = secret } } } } return reqs } 
func ( task * Task ) Build CNIConfig ( ) ( * ecscni . Config , error ) { if ! task . is Network Mode VPC ( ) { return nil , errors . New ( " " ) } cfg : = & ecscni . Config { } convert ENITo CNIConfig ( task . Get Task ENI ( ) , cfg ) if task . Get App Mesh ( ) ! = nil { convert App Mesh To CNIConfig ( task . Get App Mesh ( ) , cfg ) } return cfg , nil } 
func convert ENITo CNIConfig ( eni * apieni . ENI , cfg * ecscni . Config ) { cfg . ENIID = eni . ID cfg . ID = eni . Mac Address cfg . ENIMACAddress = eni . Mac Address cfg . Subnet Gateway IPV 4Address = eni . Get Subnet Gateway IPV 4Address ( ) for _ , ipv 4 : = range eni . IPV 4Addresses { if ipv 4 . Primary { cfg . ENIIPV 4Address = ipv 4 . Address break } } } } 
func convert App Mesh To CNIConfig ( app Mesh * apiappmesh . App Mesh , cfg * ecscni . Config ) { cfg . App Mesh CNIEnabled = true cfg . Ignored UID = app Mesh . Ignored UID cfg . Ignored GID = app Mesh . Ignored GID cfg . Proxy Ingress Port = app Mesh . Proxy Ingress Port cfg . Proxy Egress Port = app Mesh . Proxy Egress Port cfg . App Ports = app Mesh . App Ports cfg . Egress Ignored IPs = app Mesh . Egress Ignored IPs cfg . Egress Ignored Ports = app Mesh . Egress Ignored Ports } 
func ( task * Task ) Container By Name ( name string ) ( * apicontainer . Container , bool ) { for _ , container : = range task . Containers { if container . Name = = name { return container , true } } return nil , false } 
func ( task * Task ) Host Volume By Name ( name string ) ( taskresourcevolume . Volume , bool ) { for _ , v : = range task . Volumes { if v . Name = = name { return v . Volume , true } } return nil , false } 
func ( task * Task ) Update Mount Points ( cont * apicontainer . Container , vols [ ] types . Mount Point ) { for _ , mount Point : = range cont . Mount Points { container Path : = get Canonical Path ( mount Point . Container Path ) for _ , vol : = range vols { if strings . Compare ( vol . Destination , container Path ) = = 0 | | } } } } } } 
func ( task * Task ) update Task Known Status ( ) ( new Status apitaskstatus . Task Status ) { seelog . Debugf ( " " , task . String ( ) ) var earliest Known Status Container * apicontainer . Container essential Container Stopped : = false for _ , container : = range task . Containers { container Known Status : = container . Get Known Status ( ) if container Known Status = = apicontainerstatus . Container Stopped & & container . Essential { essential Container Stopped = true } if container Known Status < container Earliest Known Status { container Earliest Known Status = container Known Status earliest Known Status Container = container } } if earliest Known Status Container = = nil { seelog . Criticalf ( " " , container Earliest Known Status . String ( ) , task ) return apitaskstatus . Task Status None } seelog . Debugf ( " " , earliest Known Status Container . String ( ) , task . String ( ) ) return apitaskstatus . Task Status None } if task . Get Known Status ( ) < earliest Known Task Status { seelog . Debugf ( " " , earliest Known Task Status . String ( ) , task . String ( ) ) task . Set Known Status ( earliest Known Task Status ) return task . Get Known Status ( ) } return apitaskstatus . Task Status None } 
func ( task * Task ) get Earliest Known Task Status For Containers ( ) apitaskstatus . Task Status { if len ( task . Containers ) = = 0 { seelog . Criticalf ( " " , task . String ( ) ) return apitaskstatus . Task Status None } for _ , container : = range task . Containers { container Task Status : = apitaskstatus . Map Container To Task Status ( container . Get Known Status ( ) , container . Get Steady State Status ( ) ) if container Task Status < earliest { earliest = container Task Status } } return earliest } 
func ( task * Task ) Docker Config ( container * apicontainer . Container , api Version dockerclient . Docker Version ) ( * dockercontainer . Config , * apierrors . Docker Client Config Error ) { return task . docker Config ( container , api Version ) } 
func ( task * Task ) Docker Host Config ( container * apicontainer . Container , docker Container Map map [ string ] * apicontainer . Docker Container , api Version dockerclient . Docker Version ) ( * dockercontainer . Host Config , * apierrors . Host Config Error ) { return task . docker Host Config ( container , docker Container Map , api Version ) } 
func ( task * Task ) Apply Execution Role Logs Auth ( host Config * dockercontainer . Host Config , credentials Manager credentials . Manager ) * apierrors . Host Config Error { id : = task . Get Execution Credentials ID ( ) if id = = " " { } execution Role Credentials , ok : = credentials Manager . Get Task Credentials ( id ) if ! ok { } credentials Endpoint Relative URI : = execution Role Credentials . IAMRole Credentials . Generate Credentials Endpoint Relative URI ( ) host Config . Log Config . Config [ awslogs Creds Endpoint Opt ] = credentials Endpoint Relative URI return nil } 
func ( task * Task ) get Docker Resources ( container * apicontainer . Container ) dockercontainer . Resources { if docker Mem ! = 0 & & docker Mem < apicontainer . Docker Container Minimum Memory In Bytes { seelog . Warnf ( " " , task . Arn , container . Name , apicontainer . Docker Container Minimum Memory In Bytes ) docker Mem = apicontainer . Docker Container Minimum Memory In Bytes } resources : = dockercontainer . Resources { Memory : docker Mem , CPUShares : cpu Share , } return resources } 
func ( task * Task ) should Override Network Mode ( container * apicontainer . Container , docker Container Map map [ string ] * apicontainer . Docker Container ) ( bool , string ) { } } pause Cont Name : = " " for _ , cont : = range task . Containers { if cont . Type = = apicontainer . Container CNIPause { pause Cont Name = cont . Name break } } if pause Cont Name = = " " { seelog . Critical ( " " , task . String ( ) ) return false , " " } pause Container , ok : = docker Container Map [ pause Cont Name ] if ! ok | | pause Container = = nil { return false , " " } return true , docker Mapping Container Prefix + pause Container . Docker ID } 
func ( task * Task ) override DNS ( host Config * dockercontainer . Host Config ) * dockercontainer . Host Config { eni : = task . Get Task ENI ( ) if eni = = nil { return host Config } host Config . DNS = eni . Domain Name Servers host Config . DNSSearch = eni . Domain Name Search List return host Config } 
func ( task * Task ) apply ENIHostname ( docker Config * dockercontainer . Config ) * dockercontainer . Config { eni : = task . Get Task ENI ( ) if eni = = nil { return docker Config } hostname : = eni . Get Hostname ( ) if hostname = = " " { return docker Config } docker Config . Hostname = hostname return docker Config } 
func ( task * Task ) generate ENIExtra Hosts ( ) [ ] string { eni : = task . Get Task ENI ( ) if eni = = nil { return nil } hostname : = eni . Get Hostname ( ) if hostname = = " " { return nil } extra Hosts : = [ ] string { } for _ , ip : = range eni . Get IPV 4Addresses ( ) { host : = fmt . Sprintf ( " " , hostname , ip ) extra Hosts = append ( extra Hosts , host ) } return extra Hosts } 
func ( task * Task ) should Override PIDMode ( container * apicontainer . Container , docker Container Map map [ string ] * apicontainer . Docker Container ) ( bool , string ) { } switch task . get PIDMode ( ) { case pid Mode Host : return true , pid Mode Host case pid Mode Task : pause Cont , ok : = task . Container By Name ( Namespace Pause Container Name ) if ! ok { seelog . Criticalf ( " " , task . Arn ) task . Set Desired Status ( apitaskstatus . Task Stopped ) return false , " " } pause Docker ID , ok : = docker Container Map [ pause Cont . Name ] if ! ok | | pause Docker ID = = nil { task . Set Desired Status ( apitaskstatus . Task Stopped ) return false , " " } return true , docker Mapping Container Prefix + pause Docker ID . Docker ID } } 
func ( task * Task ) should Override IPCMode ( container * apicontainer . Container , docker Container Map map [ string ] * apicontainer . Docker Container ) ( bool , string ) { } } } switch task . get IPCMode ( ) { case ipc Mode Host : return true , ipc Mode Host case ipc Mode Task : pause Cont , ok : = task . Container By Name ( Namespace Pause Container Name ) if ! ok { seelog . Criticalf ( " " , task . Arn ) task . Set Desired Status ( apitaskstatus . Task Stopped ) return false , " " } pause Docker ID , ok : = docker Container Map [ pause Cont . Name ] if ! ok | | pause Docker ID = = nil { task . Set Desired Status ( apitaskstatus . Task Stopped ) return false , " " } return true , docker Mapping Container Prefix + pause Docker ID . Docker ID default : return false , " " } } 
func ( task * Task ) Update Status ( ) bool { change : = task . update Task Known Status ( ) return change ! = apitaskstatus . Task Status None } 
func ( task * Task ) Update Desired Status ( ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . update Task Desired Status Unsafe ( ) task . update Container Desired Status Unsafe ( task . Desired Status Unsafe ) task . update Resource Desired Status Unsafe ( task . Desired Status Unsafe ) } 
func ( task * Task ) update Task Desired Status Unsafe ( ) { seelog . Debugf ( " " , task . string Unsafe ( ) ) task . Desired Status Unsafe = apitaskstatus . Task Stopped } } } 
func ( task * Task ) update Container Desired Status Unsafe ( task Desired Status apitaskstatus . Task Status ) { for _ , container : = range task . Containers { task Desired Status To Container Status : = apitaskstatus . Map Task To Container Status ( task Desired Status , container . Get Steady State Status ( ) ) if container . Get Desired Status ( ) < task Desired Status To Container Status { container . Set Desired Status ( task Desired Status To Container Status ) } } } 
func ( task * Task ) update Resource Desired Status Unsafe ( task Desired Status apitaskstatus . Task Status ) { resources : = task . get Resources Unsafe ( ) for _ , r : = range resources { if task Desired Status = = apitaskstatus . Task Running { if r . Get Desired Status ( ) < r . Steady State ( ) { r . Set Desired Status ( r . Steady State ( ) ) } } else { if r . Get Desired Status ( ) < r . Terminal Status ( ) { r . Set Desired Status ( r . Terminal Status ( ) ) } } } } 
func ( task * Task ) Set Known Status ( status apitaskstatus . Task Status ) { task . set Known Status ( status ) task . update Known Status Time ( ) } 
func ( task * Task ) Get Known Status ( ) apitaskstatus . Task Status { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Known Status Unsafe } 
func ( task * Task ) Get Known Status Time ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Known Status Time Unsafe } 
func ( task * Task ) Set Credentials ID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . credentials ID = id } 
func ( task * Task ) Get Credentials ID ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . credentials ID } 
func ( task * Task ) Set Execution Role Credentials ID ( id string ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Execution Credentials ID = id } 
func ( task * Task ) Get Execution Credentials ID ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Execution Credentials ID } 
func ( task * Task ) Get Desired Status ( ) apitaskstatus . Task Status { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Desired Status Unsafe } 
func ( task * Task ) Set Desired Status ( status apitaskstatus . Task Status ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Desired Status Unsafe = status } 
func ( task * Task ) Get Sent Status ( ) apitaskstatus . Task Status { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Sent Status Unsafe } 
func ( task * Task ) Set Sent Status ( status apitaskstatus . Task Status ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Sent Status Unsafe = status } 
func ( task * Task ) Set Task ENI ( eni * apieni . ENI ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . ENI = eni } 
func ( task * Task ) Get Task ENI ( ) * apieni . ENI { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . ENI } 
func ( task * Task ) Set App Mesh ( app Mesh * apiappmesh . App Mesh ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . App Mesh = app Mesh } 
func ( task * Task ) Get App Mesh ( ) * apiappmesh . App Mesh { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . App Mesh } 
func ( task * Task ) Get Stop Sequence Number ( ) int 6 4 { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Stop Sequence Number } 
func ( task * Task ) Set Stop Sequence Number ( seqnum int 6 4 ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Stop Sequence Number = seqnum } 
func ( task * Task ) Set Pull Started At ( timestamp time . Time ) bool { task . lock . Lock ( ) defer task . lock . Unlock ( ) return true } return false } 
func ( task * Task ) Get Pull Started At ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Pull Started At Unsafe } 
func ( task * Task ) Set Pull Stopped At ( timestamp time . Time ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Pull Stopped At Unsafe = timestamp } 
func ( task * Task ) Get Pull Stopped At ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Pull Stopped At Unsafe } 
func ( task * Task ) Set Execution Stopped At ( timestamp time . Time ) bool { task . lock . Lock ( ) defer task . lock . Unlock ( ) if task . Execution Stopped At Unsafe . Is Zero ( ) { task . Execution Stopped At Unsafe = timestamp return true } return false } 
func ( task * Task ) Get Execution Stopped At ( ) time . Time { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . Execution Stopped At Unsafe } 
func ( task * Task ) String ( ) string { task . lock . Lock ( ) defer task . lock . Unlock ( ) return task . string Unsafe ( ) } 
func ( task * Task ) string Unsafe ( ) string { res : = fmt . Sprintf ( " " , task . Family , task . Version , task . Arn , task . Known Status Unsafe . String ( ) , task . Desired Status Unsafe . String ( ) ) res + = " " for _ , container : = range task . Containers { res + = fmt . Sprintf ( " " , container . Name , container . Get Known Status ( ) . String ( ) , container . Get Desired Status ( ) . String ( ) ) } if task . ENI ! = nil { res + = fmt . Sprintf ( " " , task . ENI . String ( ) ) } return res + " " } 
func ( task * Task ) Get ID ( ) ( string , error ) { if err ! = nil { return " " , errors . Wrapf ( err , " " , task . Arn ) } if ! strings . Contains ( resource , arn Resource Delimiter ) { return " " , errors . Errorf ( " " , resource ) } resource Split : = strings . Split N ( resource , arn Resource Delimiter , arn Resource Sections ) if len ( resource Split ) ! = arn Resource Sections { return " " , errors . Errorf ( " " , resource , arn Resource Sections , len ( resource Split ) ) } return resource Split [ 1 ] , nil } 
func ( task * Task ) Record Execution Stopped At ( container * apicontainer . Container ) { if ! container . Essential { return } if container . Get Known Status ( ) ! = apicontainerstatus . Container Stopped { return } ok : = task . Set Execution Stopped At ( now ) if ! ok { } seelog . Infof ( " " , task . Arn , container . Name , now . String ( ) ) } 
func ( task * Task ) Get Resources ( ) [ ] taskresource . Task Resource { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . get Resources Unsafe ( ) } 
func ( task * Task ) get Resources Unsafe ( ) [ ] taskresource . Task Resource { var resource List [ ] taskresource . Task Resource for _ , resources : = range task . Resources Map Unsafe { resource List = append ( resource List , resources . . . ) } return resource List } 
func ( task * Task ) Add Resource ( resource Type string , resource taskresource . Task Resource ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) task . Resources Map Unsafe [ resource Type ] = append ( task . Resources Map Unsafe [ resource Type ] , resource ) } 
func ( task * Task ) Set Terminal Reason ( reason string ) { seelog . Infof ( " " , task . Arn , reason ) task . terminal Reason Once . Do ( func ( ) { seelog . Infof ( " " , task . Arn , reason ) words [ 0 ] = strings . Title ( words [ 0 ] ) task . terminal Reason = strings . Join ( words , " " ) } ) } 
func ( task * Task ) Get Terminal Reason ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . terminal Reason } 
func ( task * Task ) Populate ASMAuth Data ( container * apicontainer . Container ) error { secret ID : = container . Registry Authentication . ASMAuth Data . Credentials Parameter resource , ok : = task . get ASMAuth Resource ( ) if ! ok { return errors . New ( " " ) } dac , ok : = asm Resource . Get ASMDocker Auth Config ( secret ID ) if ! ok { return errors . Errorf ( " " , secret ID ) } container . Set ASMDocker Auth Config ( dac ) return nil } 
func ( task * Task ) get SSMSecrets Resource ( ) ( [ ] taskresource . Task Resource , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) res , ok : = task . Resources Map Unsafe [ ssmsecret . Resource Name ] return res , ok } 
func ( task * Task ) Populate Secrets ( host Config * dockercontainer . Host Config , container * apicontainer . Container ) * apierrors . Docker Client Config Error { var ssm Res * ssmsecret . SSMSecret Resource var asm Res * asmsecret . ASMSecret Resource if container . Should Create With SSMSecret ( ) { resource , ok : = task . get SSMSecrets Resource ( ) if ! ok { return & apierrors . Docker Client Config Error { Msg : " " } } ssm Res = resource [ 0 ] . ( * ssmsecret . SSMSecret Resource ) } if container . Should Create With ASMSecret ( ) { resource , ok : = task . get ASMSecrets Resource ( ) if ! ok { return & apierrors . Docker Client Config Error { Msg : " " } } asm Res = resource [ 0 ] . ( * asmsecret . ASMSecret Resource ) } env Vars : = make ( map [ string ] string ) log Driver Token Name : = " " log Driver Token Secret Value : = " " for _ , secret : = range container . Secrets { secret Val : = " " if secret . Provider = = apicontainer . Secret Provider SSM { k : = secret . Get Secret Resource Cache Key ( ) if secret Value , ok : = ssm Res . Get Cached Secret Value ( k ) ; ok { secret Val = secret Value } } if secret . Provider = = apicontainer . Secret Provider ASM { k : = secret . Get Secret Resource Cache Key ( ) if secret Value , ok : = asm Res . Get Cached Secret Value ( k ) ; ok { secret Val = secret Value } } if secret . Type = = apicontainer . Secret Type Env { env Vars [ secret . Name ] = secret Val continue } if secret . Target = = apicontainer . Secret Target Log Driver { log Driver Token Name = secret . Name log Driver Token Secret Value = secret Val } } } container . Merge Environment Variables ( env Vars ) return nil } 
func ( task * Task ) get ASMSecrets Resource ( ) ( [ ] taskresource . Task Resource , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) res , ok : = task . Resources Map Unsafe [ asmsecret . Resource Name ] return res , ok } 
func ( task * Task ) Initialize Resources ( resource Fields * taskresource . Resource Fields ) { task . lock . Lock ( ) defer task . lock . Unlock ( ) for _ , resources : = range task . Resources Map Unsafe { for _ , resource : = range resources { resource . Initialize ( resource Fields , task . Known Status Unsafe , task . Desired Status Unsafe ) } } } 
func ( task * Task ) get PIDMode ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . PIDMode } 
func ( task * Task ) get IPCMode ( ) string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) return task . IPCMode } 
func ( task * Task ) Associations By Type And Container ( association Type , container Name string ) [ ] string { task . lock . RLock ( ) defer task . lock . RUnlock ( ) var association Names [ ] string for _ , association : = range task . Associations { if association . Type = = association Type { for _ , associated Container Name : = range association . Containers { if associated Container Name = = container Name { association Names = append ( association Names , association . Name ) } } } } return association Names } 
func ( task * Task ) Association By Type And Name ( association Type , association Name string ) ( * Association , bool ) { task . lock . RLock ( ) defer task . lock . RUnlock ( ) for _ , association : = range task . Associations { if association . Type = = association Type & & association . Name = = association Name { return & association , true } } return nil , false } 
func new Attach ENIHandler ( ctx context . Context , cluster string , container Instance Arn string , acs Client wsclient . Client Server , task Engine State dockerstate . Task Engine State , saver statemanager . Saver ) attach ENIHandler { return attach ENIHandler { message Buffer : make ( chan * ecsacs . Attach Task Network Interfaces Message ) , ctx : derived Context , cancel : cancel , cluster : aws . String ( cluster ) , container Instance : aws . String ( container Instance Arn ) , acs Client : acs Client , state : task Engine State , saver : saver , } } 
func ( attach ENIHandler * attach ENIHandler ) handler Func ( ) func ( message * ecsacs . Attach Task Network Interfaces Message ) { return func ( message * ecsacs . Attach Task Network Interfaces Message ) { attach ENIHandler . message Buffer < - message } } 
func ( attach ENIHandler * attach ENIHandler ) handle Messages ( ) { for { select { case message : = < - attach ENIHandler . message Buffer : if err : = attach ENIHandler . handle Single Message ( message ) ; err ! = nil { seelog . Warnf ( " " , message . String ( ) , err ) } case < - attach ENIHandler . ctx . Done ( ) : return } } } 
func ( handler * attach ENIHandler ) handle Single Message ( message * ecsacs . Attach Task Network Interfaces Message ) error { received At : = time . Now ( ) } } } ( message . Cluster Arn , message . Container Instance Arn , message . Message Id ) if eni Attachment , ok : = handler . state . ENIBy Mac ( mac ) ; ok { seelog . Infof ( " " , mac ) eni Ack Timeout Handler : = ack Timeout Handler { mac : mac , state : handler . state } return eni Attachment . Start Timer ( eni Ack Timeout Handler . handle ) } if err : = handler . add ENIAttachment To State ( message , received At ) ; err ! = nil { return errors . Wrapf ( err , " " ) } if err : = handler . saver . Save ( ) ; err ! = nil { return errors . Wrapf ( err , " " ) } return nil } 
func ( handler * attach ENIHandler ) add ENIAttachment To State ( message * ecsacs . Attach Task Network Interfaces Message , received At time . Time ) error { attachment ARN : = aws . String Value ( message . Elastic Network Interfaces [ 0 ] . Attachment Arn ) mac : = aws . String Value ( message . Elastic Network Interfaces [ 0 ] . Mac Address ) task ARN : = aws . String Value ( message . Task Arn ) eni Attachment : = & apieni . ENIAttachment { Task ARN : task ARN , Attachment ARN : attachment ARN , Attach Status Sent : false , MACAddress : mac , eni Ack Timeout Handler : = ack Timeout Handler { mac : mac , state : handler . state } if err : = eni Attachment . Start Timer ( eni Ack Timeout Handler . handle ) ; err ! = nil { return err } seelog . Infof ( " " , task ARN , attachment ARN , mac ) handler . state . Add ENIAttachment ( eni Attachment ) return nil } 
func validate Attach Task Network Interfaces Message ( message * ecsacs . Attach Task Network Interfaces Message ) error { if message = = nil { return errors . Errorf ( " " ) } message Id : = aws . String Value ( message . Message Id ) if message Id = = " " { return errors . Errorf ( " " ) } cluster Arn : = aws . String Value ( message . Cluster Arn ) if cluster Arn = = " " { return errors . Errorf ( " " ) } container Instance Arn : = aws . String Value ( message . Container Instance Arn ) if container Instance Arn = = " " { return errors . Errorf ( " " ) } enis : = message . Elastic Network Interfaces if len ( enis ) ! = 1 { return errors . Errorf ( " " , len ( enis ) ) } eni : = enis [ 0 ] if aws . String Value ( eni . Mac Address ) = = " " { return errors . Errorf ( " " ) } task Arn : = aws . String Value ( message . Task Arn ) if task Arn = = " " { return errors . Errorf ( " " ) } timeout : = aws . Int 6 4Value ( message . Wait Timeout Ms ) if timeout < = 0 { return errors . Errorf ( " " ) } return nil } 
func ( m * Mock State Manager ) Force Save ( ) error { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock State Manager Mock Recorder ) Force Save ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock State Manager ) ( nil ) . Force Save ) ) } 
func ( overrides * Container Overrides ) Unmarshal JSON ( b [ ] byte ) error { regular : = Container Overrides Copy { } if err = = nil { err = utils . Complete Json Unmarshal ( b , regular ) if err = = nil { * overrides = Container Overrides ( regular ) return nil } err = apierrors . New Multi Error ( errors . New ( " " ) , err ) } err 2 : = json . Unmarshal ( b , & str ) if err 2 ! = nil { return apierrors . New Multi Error ( errors . New ( " " ) , err , err 2 ) } if err 3 = = nil { err 3 = utils . Complete Json Unmarshal ( [ ] byte ( str ) , regular ) if err 3 = = nil { * overrides = Container Overrides ( regular ) return nil } err 3 = apierrors . New Multi Error ( errors . New ( " " ) , err 3 ) } return apierrors . New Multi Error ( errors . New ( " " ) , err , err 2 , err 3 ) } 
func New Mock Client Server ( ctrl * gomock . Controller ) * Mock Client Server { mock : = & Mock Client Server { ctrl : ctrl } mock . recorder = & Mock Client Server Mock Recorder { mock } return mock } 
func ( m * Mock Client Server ) Add Request Handler ( arg 0 wsclient . Request Handler ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Client Server Mock Recorder ) Add Request Handler ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Client Server ) ( nil ) . Add Request Handler ) , arg 0 ) } 
func ( mr * Mock Client Server Mock Recorder ) Connect ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Client Server ) ( nil ) . Connect ) ) } 
func ( m * Mock Client Server ) Disconnect ( arg 0 . . . interface { } ) error { varargs : = [ ] interface { } { } for _ , a : = range arg 0 { varargs = append ( varargs , a ) } ret : = m . ctrl . Call ( m , " " , varargs . . . ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client Server ) Is Connected ( ) bool { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( bool ) return ret 0 } 
func ( m * Mock Client Server ) Make Request ( arg 0 interface { } ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client Server ) Set Any Request Handler ( arg 0 wsclient . Request Handler ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Client Server ) Set Connection ( arg 0 wsconn . Websocket Conn ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Client Server ) Set Read Deadline ( arg 0 time . Time ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client Server ) Write Message ( arg 0 [ ] byte ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func New Exponential Backoff ( min , max time . Duration , jitter Multiple , multiple float 6 4 ) * Exponential Backoff { return & Exponential Backoff { start : min , current : min , max : max , jitter Multiple : jitter Multiple , multiple : multiple , } } 
func ( cs Container Status ) String ( ) string { for k , v : = range container Status Map { if v = = cs { return k } } return " " } 
func ( cs * Container Status ) Should Report To Backend ( steady State Status Container Status ) bool { return * cs = = steady State Status | | * cs = = Container Stopped } 
func ( cs * Container Status ) Backend Status ( steady State Status Container Status ) Container Status { if * cs = = steady State Status { return Container Running } if * cs = = Container Stopped { return Container Stopped } return Container Status None } 
func ( cs * Container Status ) Unmarshal JSON ( b [ ] byte ) error { if strings . To Lower ( string ( b ) ) = = " " { * cs = Container Status None return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * cs = Container Status None return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) return nil } if str Status = = " " { * cs = Container Stopped return nil } stat , ok : = container Status Map [ str Status ] if ! ok { * cs = Container Status None return errors . New ( " " ) } * cs = stat return nil } 
func ( cs * Container Status ) Marshal JSON ( ) ( [ ] byte , error ) { if cs = = nil { return nil , nil } return [ ] byte ( ` " ` + cs . String ( ) + ` " ` ) , nil } 
func ( health Status * Container Health Status ) Unmarshal JSON ( b [ ] byte ) error { * health Status = Container Health Unknown if strings . To Lower ( string ( b ) ) = = " " { return nil } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { return errors . New ( " " + string ( b ) ) } str Status : = string ( b [ 1 : len ( b ) - 1 ] ) switch str Status { case " " : case " " : * health Status = Container Unhealthy default : return errors . New ( " " + string ( b ) ) } return nil } 
func ( health Status * Container Health Status ) Marshal JSON ( ) ( [ ] byte , error ) { if health Status = = nil { return nil , nil } return [ ] byte ( ` " ` + health Status . String ( ) + ` " ` ) , nil } 
func Must Init ( cfg * config . Config , registry . . . * prometheus . Registry ) { if ! cfg . Prometheus Metrics Enabled { return } var registry To Use * prometheus . Registry if len ( registry ) > 0 { registry To Use = registry [ 0 ] } else { registry To Use = prometheus . Default Registerer . ( * prometheus . Registry ) } Metrics Engine Global = New Metrics Engine ( cfg , registry To Use ) Metrics Engine Global . collection = true } 
func New Metrics Engine ( cfg * config . Config , registry * prometheus . Registry ) * Metrics Engine { metrics Engine : = & Metrics Engine { cfg : cfg , Registry : registry , managed Metrics : make ( map [ APIType ] Metrics Client ) , } for managed API , _ : = range managed APIs { a Client : = New Metrics Client ( managed API , metrics Engine . Registry ) metrics Engine . managed Metrics [ managed API ] = a Client } return metrics Engine } 
func ( engine * Metrics Engine ) record Generic Metric ( api Type APIType , call Name string ) func ( ) { call Started : = make ( chan bool , 1 ) if engine = = nil | | ! engine . collection { return func ( ) { } } call ID : = engine . record Metric ( api Type , call Name , " " , call Started ) return func ( ) { engine . record Metric ( api Type , call Name , call ID , call Started ) } } 
func ( engine * Metrics Engine ) publish Metrics ( ) { go func ( ) { err : = http . Listen And Serve ( fmt . Sprintf ( " " , config . Agent Prometheus Exposition Port ) , nil ) if err ! = nil { seelog . Errorf ( " " , err . Error ( ) ) } } ( ) } 
func New Mock Docker Client ( ctrl * gomock . Controller ) * Mock Docker Client { mock : = & Mock Docker Client { ctrl : ctrl } mock . recorder = & Mock Docker Client Mock Recorder { mock } return mock } 
func ( m * Mock Docker Client ) APIVersion ( ) ( dockerclient . Docker Version , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( dockerclient . Docker Version ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) Container Events ( arg 0 context . Context ) ( < - chan dockerapi . Docker Container Change Event , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( < - chan dockerapi . Docker Container Change Event ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Docker Client Mock Recorder ) Container Events ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Docker Client ) ( nil ) . Container Events ) , arg 0 ) } 
func ( m * Mock Docker Client ) Create Container ( arg 0 context . Context , arg 1 * container 0 . Config , arg 2 * container 0 . Host Config , arg 3 string , arg 4 time . Duration ) dockerapi . Docker Container Metadata { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 , arg 4 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . Docker Container Metadata ) return ret 0 } 
func ( m * Mock Docker Client ) Create Volume ( arg 0 context . Context , arg 1 , arg 2 string , arg 3 , arg 4 map [ string ] string , arg 5 time . Duration ) dockerapi . SDKVolume Response { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 , arg 4 , arg 5 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . SDKVolume Response ) return ret 0 } 
func ( m * Mock Docker Client ) Describe Container ( arg 0 context . Context , arg 1 string ) ( status . Container Status , dockerapi . Docker Container Metadata ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( status . Container Status ) ret 1 , _ : = ret [ 1 ] . ( dockerapi . Docker Container Metadata ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) Inspect Container ( arg 0 context . Context , arg 1 string , arg 2 time . Duration ) ( * types . Container JSON , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( * types . Container JSON ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) Inspect Image ( arg 0 string ) ( * types . Image Inspect , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * types . Image Inspect ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) Known Versions ( ) [ ] dockerclient . Docker Version { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] dockerclient . Docker Version ) return ret 0 } 
func ( mr * Mock Docker Client Mock Recorder ) Known Versions ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Docker Client ) ( nil ) . Known Versions ) ) } 
func ( m * Mock Docker Client ) List Containers ( arg 0 context . Context , arg 1 bool , arg 2 time . Duration ) dockerapi . List Containers Response { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . List Containers Response ) return ret 0 } 
func ( m * Mock Docker Client ) List Images ( arg 0 context . Context , arg 1 time . Duration ) dockerapi . List Images Response { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . List Images Response ) return ret 0 } 
func ( m * Mock Docker Client ) List Plugins ( arg 0 context . Context , arg 1 time . Duration , arg 2 filters . Args ) dockerapi . List Plugins Response { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . List Plugins Response ) return ret 0 } 
func ( m * Mock Docker Client ) List Plugins With Filters ( arg 0 context . Context , arg 1 bool , arg 2 [ ] string , arg 3 time . Duration ) ( [ ] string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 ) ret 0 , _ : = ret [ 0 ] . ( [ ] string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) Load Image ( arg 0 context . Context , arg 1 io . Reader , arg 2 time . Duration ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Docker Client ) Pull Image ( arg 0 context . Context , arg 1 string , arg 2 * container . Registry Authentication Data , arg 3 time . Duration ) dockerapi . Docker Container Metadata { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . Docker Container Metadata ) return ret 0 } 
func ( m * Mock Docker Client ) Remove Image ( arg 0 context . Context , arg 1 string , arg 2 time . Duration ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Docker Client ) Stop Container ( arg 0 context . Context , arg 1 string , arg 2 time . Duration ) dockerapi . Docker Container Metadata { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . Docker Container Metadata ) return ret 0 } 
func ( m * Mock Docker Client ) Version ( arg 0 context . Context , arg 1 time . Duration ) ( string , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Docker Client ) With Version ( arg 0 dockerclient . Docker Version ) dockerapi . Docker Client { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( dockerapi . Docker Client ) return ret 0 } 
func New Mock Cache ( ctrl * gomock . Controller ) * Mock Cache { mock : = & Mock Cache { ctrl : ctrl } mock . recorder = & Mock Cache Mock Recorder { mock } return mock } 
func ( m * Mock Cache ) Delete ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Cache ) Get ( arg 0 string ) ( async . Value , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( async . Value ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Cache ) Set ( arg 0 string , arg 1 async . Value ) { m . ctrl . Call ( m , " " , arg 0 , arg 1 ) } 
func ( mr * Mock Cache Mock Recorder ) Set ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Cache ) ( nil ) . Set ) , arg 0 , arg 1 ) } 
func ( engine * Docker Task Engine ) new Managed Task ( task * apitask . Task ) * managed Task { ctx , cancel : = context . With Cancel ( engine . ctx ) t : = & managed Task { ctx : ctx , cancel : cancel , Task : task , acs Messages : make ( chan acs Transition ) , docker Messages : make ( chan docker Container Change ) , resource State Change Event : make ( chan resource State Change ) , engine : engine , cfg : engine . cfg , state Change Events : engine . state Change Events , container Change Event Stream : engine . container Change Event Stream , saver : engine . saver , credentials Manager : engine . credentials Manager , cni Client : engine . cni Client , task Stop WG : engine . task Stop Group , steady State Poll Interval : engine . task Steady State Poll Interval , } engine . managed Tasks [ task . Arn ] = t return t } 
func ( mtask * managed Task ) oversee Task ( ) { return default : } } if ! mtask . Get Known Status ( ) . Terminal ( ) { mtask . progress Task ( ) } if err ! = nil { seelog . Warnf ( " " , mtask . Arn , err ) } if mtask . Get Known Status ( ) . Terminal ( ) { break } } mtask . cleanup Credentials ( ) if mtask . Stop Sequence Number ! = 0 { seelog . Debugf ( " " , mtask . Arn , mtask . Stop Sequence Number ) mtask . task Stop WG . Done ( mtask . Stop Sequence Number ) } mtask . cleanup Task ( mtask . cfg . Task Cleanup Wait Duration ) } 
func ( mtask * managed Task ) emit Current Status ( ) { for _ , container : = range mtask . Containers { mtask . emit Container Event ( mtask . Task , container , " " ) } mtask . emit Task Event ( mtask . Task , " " ) } 
func ( mtask * managed Task ) wait For Host Resources ( ) { if mtask . Start Sequence Number = = 0 { } if mtask . Get Desired Status ( ) . Terminal ( ) { } seelog . Infof ( " " , mtask . Arn , mtask . Start Sequence Number ) others Stopped Ctx , cancel : = context . With Cancel ( mtask . ctx ) defer cancel ( ) go func ( ) { mtask . task Stop WG . Wait ( mtask . Start Sequence Number ) cancel ( ) } ( ) for ! mtask . wait Event ( others Stopped Ctx . Done ( ) ) { if mtask . Get Desired Status ( ) . Terminal ( ) { } } seelog . Infof ( " " , mtask . Arn , mtask . Get Desired Status ( ) . String ( ) ) } 
func ( mtask * managed Task ) wait Steady ( ) { seelog . Infof ( " " , mtask . Arn , mtask . Get Known Status ( ) . String ( ) ) timeout Ctx , cancel : = context . With Timeout ( mtask . ctx , mtask . steady State Poll Interval ) defer cancel ( ) timed Out : = mtask . wait Event ( timeout Ctx . Done ( ) ) if timed Out { seelog . Debugf ( " " , mtask . Arn ) go mtask . engine . check Task State ( mtask . Task ) } } 
func ( mtask * managed Task ) steady State ( ) bool { select { case < - mtask . ctx . Done ( ) : seelog . Info ( " " ) return false default : task Known Status : = mtask . Get Known Status ( ) return task Known Status = = apitaskstatus . Task Running & & task Known Status > = mtask . Get Desired Status ( ) } } 
func ( mtask * managed Task ) cleanup Credentials ( ) { task Credentials ID : = mtask . Get Credentials ID ( ) if task Credentials ID ! = " " { mtask . credentials Manager . Remove Credentials ( task Credentials ID ) } } 
func ( mtask * managed Task ) wait Event ( stop Waiting < - chan struct { } ) bool { seelog . Debugf ( " " , mtask . Arn ) select { case acs Transition : = < - mtask . acs Messages : seelog . Debugf ( " " , mtask . Arn ) mtask . handle Desired Status Change ( acs Transition . desired Status , acs Transition . seqnum ) return false case docker Change : = < - mtask . docker Messages : seelog . Debugf ( " " , mtask . Arn , docker Change . container . Name , docker Change . event . Status . String ( ) ) mtask . handle Container Change ( docker Change ) return false case res Change : = < - mtask . resource State Change Event : res : = res Change . resource seelog . Debugf ( " " , mtask . Arn , res . Get Name ( ) , res . Status String ( res Change . next State ) ) mtask . handle Resource State Change ( res Change ) return false case < - stop Waiting : seelog . Debugf ( " " , mtask . Arn ) return true } } 
func ( mtask * managed Task ) handle Desired Status Change ( desired Status apitaskstatus . Task Status , seqnum int 6 4 ) { if desired Status < = mtask . Get Desired Status ( ) { seelog . Debugf ( " " , mtask . Arn , mtask . Get Desired Status ( ) . String ( ) , desired Status . String ( ) ) return } if desired Status = = apitaskstatus . Task Stopped & & seqnum ! = 0 & & mtask . Get Stop Sequence Number ( ) = = 0 { seelog . Debugf ( " " , mtask . Arn , seqnum ) mtask . Set Stop Sequence Number ( seqnum ) mtask . task Stop WG . Add ( seqnum , 1 ) } mtask . Set Desired Status ( desired Status ) mtask . Update Desired Status ( ) } 
func ( mtask * managed Task ) handle Container Change ( container Change docker Container Change ) { found : = mtask . is Container Found ( container ) if ! found { seelog . Criticalf ( " " , mtask . Arn , container . Name ) return } event : = container Change . event seelog . Debugf ( " " , mtask . Arn , event , container . Name ) mtask . handle Stopped To Running Container Transition ( event . Status , container ) if event . Status < = container Known Status { seelog . Infof ( " " , mtask . Arn , container . Name , event . Status . String ( ) , container Known Status . String ( ) ) return } container . Set Known Status ( event . Status ) update Container Metadata ( & event . Docker Container Metadata , container , mtask . Task ) if event . Error ! = nil { proceed Anyway : = mtask . handle Event Error ( container Change , current Known Status ) if ! proceed Anyway { return } } } mtask . Record Execution Stopped At ( container ) seelog . Debugf ( " " , mtask . Arn , container . Name , event . Docker ID , event . Status . String ( ) ) err : = mtask . container Change Event Stream . Write To Event Stream ( event ) if err ! = nil { seelog . Warnf ( " " , mtask . Arn , container . Name , err ) } mtask . emit Container Event ( mtask . Task , container , " " ) if mtask . Update Status ( ) { seelog . Debugf ( " " , mtask . Arn , container . Name , mtask . Get Desired Status ( ) . String ( ) ) if mtask . Get Known Status ( ) . Terminal ( ) { task State Change Reason = mtask . Task . Get Terminal Reason ( ) } mtask . emit Task Event ( mtask . Task , task State Change Reason ) } seelog . Debugf ( " " , mtask . Arn , container . Name , mtask . Get Desired Status ( ) . String ( ) ) } 
func ( mtask * managed Task ) handle Resource State Change ( res Change resource State Change ) { if ! mtask . is Resource Found ( res ) { seelog . Criticalf ( " " , mtask . Arn , res . Get Name ( ) ) return } status : = res Change . next State err : = res Change . err current Known Status : = res . Get Known Status ( ) if status < = current Known Status { seelog . Infof ( " " , mtask . Arn , res . Get Name ( ) , res . Status String ( status ) , res . Status String ( current Known Status ) ) return } if err = = nil { res . Set Known Status ( status ) mtask . engine . saver . Save ( ) return } seelog . Debugf ( " " , mtask . Arn , res . Get Name ( ) , res . Status String ( status ) , err ) if status = = res . Steady State ( ) { seelog . Errorf ( " " , mtask . Arn , res . Get Name ( ) ) mtask . Set Desired Status ( apitaskstatus . Task Stopped ) mtask . Task . Set Terminal Reason ( res . Get Terminal Reason ( ) ) mtask . engine . saver . Save ( ) } } 
func ( mtask * managed Task ) emit Container Event ( task * apitask . Task , cont * apicontainer . Container , reason string ) { event , err : = api . New Container State Change Event ( task , cont , reason ) if err ! = nil { seelog . Debugf ( " " , task . Arn , cont . Name , err ) return } seelog . Infof ( " " , mtask . Arn , cont . Name , event . String ( ) ) mtask . state Change Events < - event seelog . Infof ( " " , mtask . Arn , cont . Name , event . String ( ) ) } 
func ( mtask * managed Task ) release IPIn IPAM ( ) { if mtask . ENI = = nil { return } seelog . Infof ( " " , mtask . Arn ) cfg , err : = mtask . Build CNIConfig ( ) if err ! = nil { seelog . Warnf ( " " , mtask . Arn , err ) return } err = mtask . cni Client . Release IPResource ( cfg ) if err ! = nil { seelog . Warnf ( " " , mtask . Arn , err ) return } } 
func ( mtask * managed Task ) handle Stopped To Running Container Transition ( status apicontainerstatus . Container Status , container * apicontainer . Container ) { container Known Status : = container . Get Known Status ( ) if status > container Known Status { } if container Known Status ! = apicontainerstatus . Container Stopped { } if ! status . Is Running ( ) { } go mtask . engine . transition Container ( mtask . Task , container , apicontainerstatus . Container Stopped ) } 
func ( mtask * managed Task ) handle Event Error ( container Change docker Container Change , current Known Status apicontainerstatus . Container Status ) bool { container : = container Change . container event : = container Change . event if container . Applying Error = = nil { container . Applying Error = apierrors . New Named Error ( event . Error ) } switch event . Status { return false } case apicontainerstatus . Container Stopped : case apicontainerstatus . Container Status None : fallthrough case apicontainerstatus . Container Created : container . Set Known Status ( current Known Status ) container . Set Desired Status ( apicontainerstatus . Container Stopped ) return false default : container . Set Known Status ( current Known Status ) container . Set Desired Status ( apicontainerstatus . Container Stopped ) error Name : = event . Error . Error Name ( ) if error Name = = dockerapi . Docker Timeout Error Name | | error Name = = dockerapi . Cannot Inspect Container Error Name { go mtask . engine . transition Container ( mtask . Task , container , apicontainerstatus . Container Stopped ) } } } 
func ( mtask * managed Task ) handle Container Stopped Transition Error ( event dockerapi . Docker Container Change Event , container * apicontainer . Container , current Known Status apicontainerstatus . Container Status ) bool { container . Set Known Status ( current Known Status ) return false } if ok & & cannot Stop Container Error . Is Retriable Error ( ) { seelog . Infof ( " " , mtask . Arn , container . Name , cannot Stop Container Error . Error ( ) ) container . Set Known Status ( current Known Status ) return false } container . Set Known Status ( apicontainerstatus . Container Stopped ) container . Set Desired Status ( apicontainerstatus . Container Stopped ) return true } 
func ( mtask * managed Task ) progress Task ( ) { seelog . Debugf ( " " , mtask . Arn ) transition Change : = make ( chan struct { } , len ( mtask . Containers ) + len ( resources ) ) transition Change Entity : = make ( chan string , len ( mtask . Containers ) + len ( resources ) ) transition Change < - struct { } { } transition Change Entity < - resource . Get Name ( ) } ) any Container Transition , blocked Dependencies , cont Transitions , reasons : = mtask . start Container Transitions ( func ( container * apicontainer . Container , next Status apicontainerstatus . Container Status ) { mtask . engine . transition Container ( mtask . Task , container , next Status ) transition Change < - struct { } { } transition Change Entity < - container . Name } ) at Least One Transition Started : = any Resource Transition | | any Container Transition blocked By Ordering Dependencies : = len ( blocked Dependencies ) > 0 } return } ctx , cancel : = context . With Timeout ( context . Background ( ) , transition Poll Time ) defer cancel ( ) for timeout : = mtask . wait Event ( ctx . Done ( ) ) ; ! timeout ; { timeout = mtask . wait Event ( ctx . Done ( ) ) } return } for k , v : = range res Transitions { transitions [ k ] = v } for k , v : = range cont Transitions { transitions [ k ] = v . String ( ) } if changed { seelog . Debugf ( " " , mtask . Arn ) if mtask . Get Known Status ( ) . Terminal ( ) { task State Change Reason = mtask . Task . Get Terminal Reason ( ) } mtask . emit Task Event ( mtask . Task , task State Change Reason ) } } 
func ( mtask * managed Task ) is Waiting For ACSExecution Credentials ( reasons [ ] error ) bool { for _ , reason : = range reasons { if reason = = dependencygraph . Credentials Not Resolved Err { seelog . Debugf ( " " , mtask . Arn ) timeout Ctx , timeout Cancel : = context . With Timeout ( mtask . ctx , wait For Pull Credentials Timeout ) defer timeout Cancel ( ) timed Out : = mtask . wait Event ( timeout Ctx . Done ( ) ) if timed Out { seelog . Debugf ( " " , mtask . Arn ) } return true } } return false } 
func ( mtask * managed Task ) start Container Transitions ( transition Func container Transition Func ) ( bool , map [ string ] apicontainer . Depends On , map [ string ] apicontainerstatus . Container Status , [ ] error ) { any Can Transition : = false var reasons [ ] error blocked : = make ( map [ string ] apicontainer . Depends On ) transitions : = make ( map [ string ] apicontainerstatus . Container Status ) for _ , cont : = range mtask . Containers { transition : = mtask . container Next State ( cont ) if transition . reason ! = nil { if transition . blocked On ! = nil { blocked [ cont . Name ] = * transition . blocked On } continue } continue } if ! transition . action Required { } ( cont , transition . next State ) continue } transitions [ cont . Name ] = transition . next State go transition Func ( cont , transition . next State ) } return any Can Transition , blocked , transitions , reasons } 
func ( mtask * managed Task ) start Resource Transitions ( transition Func resource Transition Func ) ( bool , map [ string ] string ) { any Can Transition : = false transitions : = make ( map [ string ] string ) for _ , res : = range mtask . Get Resources ( ) { known Status : = res . Get Known Status ( ) desired Status : = res . Get Desired Status ( ) if known Status > = desired Status { seelog . Debugf ( " " , mtask . Arn , res . Get Name ( ) , res . Status String ( desired Status ) , res . Status String ( known Status ) ) continue } any Can Transition = true transition : = mtask . resource Next State ( res ) } if ! transition . action Required { continue } go transition Func ( res , transition . next State ) } return any Can Transition , transitions } 
func ( mtask * managed Task ) transition Resource ( resource taskresource . Task Resource , to resourcestatus . Resource Status ) { err : = mtask . apply Resource State ( resource , to ) if mtask . engine . is Task Managed ( mtask . Arn ) { mtask . emit Resource Change ( resource State Change { resource : resource , next State : to , err : err , } ) } } 
func ( mtask * managed Task ) apply Resource State ( resource taskresource . Task Resource , next State resourcestatus . Resource Status ) error { res Name : = resource . Get Name ( ) res Status : = resource . Status String ( next State ) err : = resource . Apply Transition ( next State ) if err ! = nil { seelog . Infof ( " " , mtask . Arn , res Name , res Status , err ) return err } seelog . Debugf ( " " , mtask . Arn , res Name , res Status ) return nil } 
func ( mtask * managed Task ) container Next State ( container * apicontainer . Container ) * container Transition { container Known Status : = container . Get Known Status ( ) container Desired Status : = container . Get Desired Status ( ) if container Known Status = = container Desired Status { seelog . Debugf ( " " , mtask . Arn , container . Name , container Desired Status . String ( ) ) return & container Transition { next State : apicontainerstatus . Container Status None , action Required : false , reason : dependencygraph . Container Past Desired Status Err , } } if container Known Status > container Desired Status { seelog . Debugf ( " " , mtask . Arn , container . Name , container Known Status . String ( ) , container Desired Status . String ( ) ) return & container Transition { next State : apicontainerstatus . Container Status None , action Required : false , reason : dependencygraph . Container Past Desired Status Err , } } if blocked , err : = dependencygraph . Dependencies Are Resolved ( container , mtask . Containers , mtask . Task . Get Execution Credentials ID ( ) , mtask . credentials Manager , mtask . Get Resources ( ) ) ; err ! = nil { seelog . Debugf ( " " , mtask . Arn , container . Name , err ) return & container Transition { next State : apicontainerstatus . Container Status None , action Required : false , reason : err , blocked On : blocked , } } var next State apicontainerstatus . Container Status if container . Desired Terminal ( ) { next State = apicontainerstatus . Container Stopped } return & container Transition { next State : next State , action Required : false , } } } else { next State = container . Get Next Known State Progression ( ) } return & container Transition { next State : next State , action Required : true , } } 
func ( mtask * managed Task ) wait For Stop Reported ( ) bool { stopped Sent Bool : = make ( chan struct { } ) task Stopped : = false go func ( ) { for i : = 0 ; i < _max Stopped Wait Times ; i + + { if sent Status > = apitaskstatus . Task Stopped { task Stopped = true break } seelog . Warnf ( " " , mtask . Arn , sent Status . String ( ) , i + 1 , _max Stopped Wait Times ) mtask . _time . Sleep ( _stopped Sent Wait Interval ) } stopped Sent Bool < - struct { } { } close ( stopped Sent Bool ) } ( ) return task Stopped } 
func New Factory ( ctx context . Context , endpoint string ) Factory { return & factory { endpoint : endpoint , clients : find Docker Versions ( ctx , endpoint ) , } } 
func ( f * factory ) Find Client APIVersion ( client sdkclient . Client ) dockerclient . Docker Version { return dockerclient . Docker Version ( client . Client Version ( ) ) } 
func ( f * factory ) get Client ( version dockerclient . Docker Version ) ( sdkclient . Client , error ) { client , ok : = f . clients [ version ] if ! ok { return nil , errors . New ( " " + string ( version ) ) } return client , nil } 
func find Docker Versions ( ctx context . Context , endpoint string ) map [ dockerclient . Docker Version ] sdkclient . Client { if err = = nil { derived Ctx , cancel : = context . With Timeout ( ctx , dockerclient . Version Timeout ) defer cancel ( ) server Version , err : = client . Server Version ( derived Ctx ) if err = = nil { api Version = server Version . APIVersion } } } clients : = make ( map [ dockerclient . Docker Version ] sdkclient . Client ) for _ , version : = range dockerclient . Get Known APIVersions ( ) { docker Client , err : = get Docker Client For Version ( endpoint , string ( version ) , min APIVersion , api Version , ctx ) if err ! = nil { log . Infof ( " " , version , err ) continue } clients [ version ] = docker Client } return clients } 
func ( h * handler ) Execute ( args [ ] string , requests < - chan svc . Change Request , responses chan < - svc . Status ) ( bool , uint 3 2 ) { defer seelog . Flush ( ) agent Done : = make ( chan struct { } ) windows Done : = make ( chan struct { } ) wg : = sync . Wait Group { } wg . Add ( 2 ) go func ( ) { defer close ( windows Done ) defer wg . Done ( ) h . handle Windows Requests ( ctx , requests , responses ) } ( ) var agent Exit Code uint 3 2 go func ( ) { defer close ( agent Done ) defer wg . Done ( ) agent Exit Code = h . run Agent ( ctx ) } ( ) case < - agent Done : } cancel ( ) wg . Wait ( ) seelog . Infof ( " " , agent Exit Code ) return true , agent Exit Code } 
func ( h * handler ) handle Windows Requests ( ctx context . Context , requests < - chan svc . Change Request , responses chan < - svc . Status ) { seelog . Info ( " " ) defer func ( ) { responses < - svc . Status { State : svc . Stop Pending } } ( ) for { select { case < - ctx . Done ( ) : return case r : = < - requests : switch r . Cmd { case svc . Interrogate : case svc . Stop , svc . Shutdown : return default : continue } } } } 
func ( h * handler ) run Agent ( ctx context . Context ) uint 3 2 { agent Ctx , cancel : = context . With Cancel ( ctx ) indicator : = new Term Handler Indicator ( ) termination Handler : = func ( saver statemanager . Saver , task Engine engine . Task Engine ) { indicator . set Invoked ( ) < - agent Ctx . Done ( ) if ! indicator . is Agent Running ( ) { return } seelog . Info ( " " ) err : = sighandlers . Final Save ( saver , task Engine ) if err ! = nil { seelog . Criticalf ( " " , err ) } } h . ecs Agent . set Termination Handler ( termination Handler ) go func ( ) { defer cancel ( ) exit Code : = h . ecs Agent . start ( ) if exit Code = = exitcodes . Exit Terminal { seelog . Critical ( " " ) } indicator . agent Stopped ( exit Code ) } ( ) sleep Ctx ( agent Ctx , time . Minute ) } 
func sleep Ctx ( ctx context . Context , duration time . Duration ) { derived Ctx , _ : = context . With Deadline ( ctx , time . Now ( ) . Add ( duration ) ) < - derived Ctx . Done ( ) } 
func Task Metadata Handler ( state dockerstate . Task Engine State , ecs Client api . ECSClient , cluster , az , container Instance Arn string , propagate Tags bool ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Task Metadata ) return } seelog . Infof ( " " , task ARN ) task Response , err : = v 2 . New Task Response ( task ARN , state , ecs Client , cluster , az , container Instance Arn , propagate Tags ) if err ! = nil { err Response JSON , _ : = json . Marshal ( " " + task ARN + " " ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Metadata ) return } task , _ : = state . Task By Arn ( task ARN ) if task . Get Task ENI ( ) = = nil { for _ , container Response : = range task Response . Containers { networks , err : = Get Container Network Metadata ( container Response . ID , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( err . Error ( ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Container Metadata ) return } container Response . Networks = networks responses = append ( responses , container Response ) } task Response . Containers = responses } response JSON , _ : = json . Marshal ( task Response ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Task Metadata ) } } 
func ( event Stream * Event Stream ) Subscribe ( name string , handler event Handler ) error { event Stream . handlers Lock . Lock ( ) defer event Stream . handlers Lock . Unlock ( ) if _ , ok : = event Stream . handlers [ name ] ; ok { return fmt . Errorf ( " " , name ) } event Stream . handlers [ name ] = handler return nil } 
func ( event Stream * Event Stream ) broadcast ( event interface { } ) { event Stream . handlers Lock . RLock ( ) defer event Stream . handlers Lock . RUnlock ( ) seelog . Debugf ( " " , event Stream . name ) for _ , handler Func : = range event Stream . handlers { go handler Func ( event ) } } 
func ( event Stream * Event Stream ) Unsubscribe ( name string ) { event Stream . handlers Lock . Lock ( ) defer event Stream . handlers Lock . Unlock ( ) for handler : = range event Stream . handlers { if handler = = name { seelog . Debugf ( " " , handler , event Stream . name ) delete ( event Stream . handlers , handler ) return } } } 
func ( event Stream * Event Stream ) Write To Event Stream ( event interface { } ) error { event Stream . status Lock . RLock ( ) defer event Stream . status Lock . RUnlock ( ) if ! event Stream . open { return fmt . Errorf ( " " ) } event Stream . event < - event return nil } 
func ( event Stream * Event Stream ) listen ( ) { seelog . Infof ( " " , event Stream . name ) for { select { case event : = < - event Stream . event : event Stream . broadcast ( event ) case < - event Stream . ctx . Done ( ) : seelog . Infof ( " " , event Stream . name ) event Stream . status Lock . Lock ( ) event Stream . open = false close ( event Stream . event ) event Stream . status Lock . Unlock ( ) return } } } 
func ( event Stream * Event Stream ) Start Listening ( ) { event Stream . status Lock . Lock ( ) defer event Stream . status Lock . Unlock ( ) event Stream . open = true go event Stream . listen ( ) } 
func Set Level ( log Level string ) { parsed Level , ok : = levels [ strings . To Lower ( log Level ) ] if ok { level Lock . Lock ( ) defer level Lock . Unlock ( ) level = parsed Level reload Config ( ) } } 
func For Module ( module string ) Old Logger { once . Do ( init Logger ) return logger . New ( " " , module ) } 
func New Mock Websocket Conn ( ctrl * gomock . Controller ) * Mock Websocket Conn { mock : = & Mock Websocket Conn { ctrl : ctrl } mock . recorder = & Mock Websocket Conn Mock Recorder { mock } return mock } 
func ( mr * Mock Websocket Conn Mock Recorder ) Close ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Websocket Conn ) ( nil ) . Close ) ) } 
func ( m * Mock Websocket Conn ) Read Message ( ) ( int , [ ] byte , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( int ) ret 1 , _ : = ret [ 1 ] . ( [ ] byte ) ret 2 , _ : = ret [ 2 ] . ( error ) return ret 0 , ret 1 , ret 2 } 
func ( mr * Mock Websocket Conn Mock Recorder ) Set Write Deadline ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Websocket Conn ) ( nil ) . Set Write Deadline ) , arg 0 ) } 
func ( m * Mock Websocket Conn ) Write Message ( arg 0 int , arg 1 [ ] byte ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func docker Stats To Container Stats ( docker Stats * types . Stats JSON ) ( * Container Stats , error ) { return nil , fmt . Errorf ( " " ) } cpu Usage : = docker Stats . CPUStats . CPUUsage . Total Usage / num Cores memory Usage : = docker Stats . Memory Stats . Usage - docker Stats . Memory Stats . Stats [ " " ] return & Container Stats { cpu Usage : cpu Usage , memory Usage : memory Usage , timestamp : docker Stats . Read , } , nil } 
func ( mr * Mock Client Mock Recorder ) Get ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Client ) ( nil ) . Get ) , arg 0 ) } 
func New SSMSecret Resource ( task ARN string , ssm Secrets map [ string ] [ ] apicontainer . Secret , execution Credentials ID string , credentials Manager credentials . Manager , ssm Client Creator factory . SSMClient Creator ) * SSMSecret Resource { s : = & SSMSecret Resource { task ARN : task ARN , required Secrets : ssm Secrets , credentials Manager : credentials Manager , execution Credentials ID : execution Credentials ID , ssm Client Creator : ssm Client Creator , } s . init Status To Transition ( ) return s } 
func ( secret * SSMSecret Resource ) Get Name ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return Resource Name } 
func ( secret * SSMSecret Resource ) Desired Terminal ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . desired Status Unsafe = = resourcestatus . Resource Status ( SSMSecret Removed ) } 
func ( secret * SSMSecret Resource ) Known Created ( ) bool { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . known Status Unsafe = = resourcestatus . Resource Status ( SSMSecret Created ) } 
func ( secret * SSMSecret Resource ) Apply Transition ( next State resourcestatus . Resource Status ) error { transition Func , ok : = secret . resource Status To Transition Function [ next State ] if ! ok { return errors . Errorf ( " " , secret . Get Name ( ) , secret . Status String ( next State ) ) } return transition Func ( ) } 
func ( secret * SSMSecret Resource ) update Applied Status Unsafe ( known Status resourcestatus . Resource Status ) { if secret . applied Status = = resourcestatus . Resource Status ( SSMSecret Status None ) { return } } } 
func ( secret * SSMSecret Resource ) Set Applied Status ( status resourcestatus . Resource Status ) bool { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . applied Status ! = resourcestatus . Resource Status ( SSMSecret Status None ) { } secret . applied Status = status return true } 
func ( secret * SSMSecret Resource ) Status String ( status resourcestatus . Resource Status ) string { return SSMSecret Status ( status ) . String ( ) } 
func ( secret * SSMSecret Resource ) Set Created At ( created At time . Time ) { if created At . Is Zero ( ) { return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . created At = created At } 
func ( secret * SSMSecret Resource ) Get Created At ( ) time . Time { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . created At } 
func ( secret * SSMSecret Resource ) Create ( ) error { if ! ok { secret . set Terminal Reason ( err . Error ( ) ) return err } iam Credentials : = execution Credentials . Get IAMRole Credentials ( ) var wg sync . Wait Group error Events : = make ( chan error , chan Len ) seelog . Infof ( " " , secret . task ARN ) secret . secret Data = make ( map [ string ] string ) for region , secrets : = range secret . get Required Secrets ( ) { wg . Add ( 1 ) } wg . Wait ( ) return err default : return nil } } 
func ( secret * SSMSecret Resource ) get Go Routine Max Num ( ) int { total : = 0 for _ , secrets : = range secret . required Secrets { total + = len ( secrets ) / Max Batch Num + 1 } return total } 
func ( secret * SSMSecret Resource ) retrieve SSMSecret Values By Region ( region string , secrets [ ] apicontainer . Secret , iam Credentials credentials . IAMRole Credentials , wg * sync . Wait Group , error Events chan error ) { seelog . Infof ( " " , region , secret . task ARN ) defer wg . Done ( ) var wg Per Region sync . Wait Group var secret Names [ ] string for _ , s : = range secrets { secret Key : = s . Get Secret Resource Cache Key ( ) if _ , ok : = secret . Get Cached Secret Value ( secret Key ) ; ok { continue } secret Names = append ( secret Names , s . Value From ) if len ( secret Names ) = = Max Batch Num { secret Names Tmp : = make ( [ ] string , Max Batch Num ) copy ( secret Names Tmp , secret Names ) wg Per Region . Add ( 1 ) go secret . retrieve SSMSecret Values ( region , secret Names Tmp , iam Credentials , & wg Per Region , error Events ) secret Names = [ ] string { } } } if len ( secret Names ) > 0 { wg Per Region . Add ( 1 ) go secret . retrieve SSMSecret Values ( region , secret Names , iam Credentials , & wg Per Region , error Events ) } wg Per Region . Wait ( ) } 
func ( secret * SSMSecret Resource ) retrieve SSMSecret Values ( region string , names [ ] string , iam Credentials credentials . IAMRole Credentials , wg * sync . Wait Group , error Events chan error ) { defer wg . Done ( ) ssm Client : = secret . ssm Client Creator . New SSMClient ( region , iam Credentials ) seelog . Infof ( " " , names , region , secret . task ARN ) sec Value Map , err : = ssm . Get Secrets From SSM ( names , ssm Client ) if err ! = nil { error Events < - fmt . Errorf ( " " , region , err ) return } secret . lock . Lock ( ) defer secret . lock . Unlock ( ) secret . secret Data [ secret Key ] = secret Value } } 
func ( secret * SSMSecret Resource ) get Execution Credentials ID ( ) string { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) return secret . execution Credentials ID } 
func ( secret * SSMSecret Resource ) clear SSMSecret Value ( ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) for key : = range secret . secret Data { delete ( secret . secret Data , key ) } } 
func ( secret * SSMSecret Resource ) Get Cached Secret Value ( secret Key string ) ( string , bool ) { secret . lock . RLock ( ) defer secret . lock . RUnlock ( ) s , ok : = secret . secret Data [ secret Key ] return s , ok } 
func ( secret * SSMSecret Resource ) Set Cached Secret Value ( secret Key string , secret Value string ) { secret . lock . Lock ( ) defer secret . lock . Unlock ( ) if secret . secret Data = = nil { secret . secret Data = make ( map [ string ] string ) } secret . secret Data [ secret Key ] = secret Value } 
func ( m * Mock Manager ) Clean ( arg 0 string ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Manager ) Create ( arg 0 * container . Config , arg 1 * container . Host Config , arg 2 * task . Task , arg 3 string ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Manager ) Set Availability Zone ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Manager ) Set Container Instance ARN ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Manager ) Set Host Public IPv 4Address ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Manager ) Update ( arg 0 context . Context , arg 1 string , arg 2 * task . Task , arg 3 string ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func New Mock Docker Metadata Client ( ctrl * gomock . Controller ) * Mock Docker Metadata Client { mock : = & Mock Docker Metadata Client { ctrl : ctrl } mock . recorder = & Mock Docker Metadata Client Mock Recorder { mock } return mock } 
func ( mr * Mock Docker Metadata Client Mock Recorder ) Inspect Container ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Docker Metadata Client ) ( nil ) . Inspect Container ) , arg 0 , arg 1 , arg 2 ) } 
func Json Keys ( b [ ] byte ) ( [ ] string , error ) { var key Map map [ string ] interface { } err : = json . Unmarshal ( b , & key Map ) if err ! = nil { return [ ] string { } , err } keys : = make ( [ ] string , len ( key Map ) ) ndx : = 0 for k : = range key Map { keys [ ndx ] = k ndx + + } return keys , nil } 
func Complete Json Unmarshal ( b [ ] byte , iface interface { } ) error { keys , err : = Json Keys ( b ) if err ! = nil { return err } struct Type : = reflect . Value Of ( iface ) . Type ( ) for _ , key : = range keys { _ , found : = struct Type . Field By Name Func ( func ( name string ) bool { struct Field , _ : = struct Type . Field By Name ( name ) json Tag : = struct Field . Tag . Get ( " " ) json Name : = strings . Split ( json Tag , " " ) [ 0 ] if json Name = = key { return true } if strings . Equal Fold ( key , struct Field . Name ) { return true } return false } ) if ! found { } } return nil } 
func Task Container Metadata Handler ( state dockerstate . Task Engine State , ecs Client api . ECSClient , cluster , az , container Instance Arn string , propagate Tags bool ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Task Metadata ) return } if container ID , ok : = utils . Get Mux Value From Request ( r , metadata Container IDMux Name ) ; ok { seelog . Infof ( " " , container ID ) Write Container Metadata Response ( w , container ID , state ) return } seelog . Infof ( " " , task ARN ) Write Task Metadata Response ( w , task ARN , cluster , state , ecs Client , az , container Instance Arn , propagate Tags ) } } 
func Write Container Metadata Response ( w http . Response Writer , container ID string , state dockerstate . Task Engine State ) { container Response , err : = New Container Response ( container ID , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( " " + container ID + " " ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Container Metadata ) return } response JSON , _ : = json . Marshal ( container Response ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Container Metadata ) } 
func Write Task Metadata Response ( w http . Response Writer , task ARN string , cluster string , state dockerstate . Task Engine State , ecs Client api . ECSClient , az , container Instance Arn string , propagate Tags bool ) { if err ! = nil { err Response JSON , _ : = json . Marshal ( " " + task ARN + " " ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Metadata ) return } response JSON , _ : = json . Marshal ( task Response ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Task Metadata ) } 
func ( c * control ) Init ( ) error { seelog . Infof ( " " , config . Default Task Cgroup Prefix ) _ , err : = c . Create ( cgroup Spec ) return err } 
func write To Metadata File ( os Wrap oswrapper . OS , ioutil Wrap ioutilwrapper . IOUtil , data [ ] byte , task ARN string , container Name string , data Dir string ) error { metadata File Dir , err : = get Metadata File Path ( task ARN , container Name , data Dir ) } metadata File Name : = filepath . Join ( metadata File Dir , metadata File ) file , err : = os Wrap . Open File ( metadata File Name , os . O _WRONLY | os . O _CREATE , metadata Perm ) if err ! = nil { return err } defer file . Close ( ) _ , err = file . Write ( data ) if err ! = nil { return err } return file . Sync ( ) } 
func ( err * WSError ) Error ( ) string { val : = reflect . Value Of ( err . Err Obj ) if val . Kind ( ) = = reflect . Ptr { val = val . Elem ( ) } var type Str = " " if val . Is Valid ( ) { type Str = val . Type ( ) . Name ( ) msg : = val . Field By Name ( " " ) if msg . Is Valid ( ) & & msg . Can Interface ( ) { str , ok : = msg . Interface ( ) . ( * string ) if ok { if str = = nil { return type Str + " " } return type Str + " " + * str } } } if as Err , ok : = err . Err Obj . ( error ) ; ok { return err . Type + " " + as Err . Error ( ) } return err . Type + " " + type Str + " " } 
func ( err * WSError ) Retry ( ) bool { for _ , unretriable : = range err . Get ( ) { if reflect . Type Of ( err . Err Obj ) = = reflect . Type Of ( unretriable ) { return false } } return true } 
func New Mock Docker State Resolver ( ctrl * gomock . Controller ) * Mock Docker State Resolver { mock : = & Mock Docker State Resolver { ctrl : ctrl } mock . recorder = & Mock Docker State Resolver Mock Recorder { mock } return mock } 
func ( m * Mock Docker State Resolver ) State ( ) dockerstate . Task Engine State { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( dockerstate . Task Engine State ) return ret 0 } 
func ( mr * Mock Docker State Resolver Mock Recorder ) State ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Docker State Resolver ) ( nil ) . State ) ) } 
func print License ( ) int { license : = utils . New License Provider ( ) text , err : = license . Get Text ( ) if err ! = nil { fmt . Fprintln ( os . Stderr , err ) return exitcodes . Exit Error } fmt . Println ( text ) return exitcodes . Exit Success } 
func ( c * Global Cgroup Factory ) Load ( hierarchy cgroups . Hierarchy , path cgroups . Path ) ( cgroups . Cgroup , error ) { return cgroups . Load ( hierarchy , path ) } 
func ( c * Global Cgroup Factory ) New ( hierarchy cgroups . Hierarchy , path cgroups . Path , specs * specs . Linux Resources ) ( cgroups . Cgroup , error ) { return cgroups . New ( hierarchy , path , specs ) } 
func Print Version ( ) int { cleanliness : = " " if Git Dirty { cleanliness = " \t \n " } fmt . Printf ( `Amazon ECS Agent : Version : %v Commit : %v %v ` , Version , Git Short Hash , cleanliness ) return exitcodes . Exit Success } 
func timeout And Move On ( fp loiter Func , timeout time . Duration ) { ch : = time . After ( timeout ) for { select { case < - ch : return default : fp ( ) } } } 
func New Docker Task Engine ( cfg * config . Config , client dockerapi . Docker Client , credentials Manager credentials . Manager , container Change Event Stream * eventstream . Event Stream , image Manager Image Manager , state dockerstate . Task Engine State , metadata Manager containermetadata . Manager , resource Fields * taskresource . Resource Fields ) * Docker Task Engine { docker Task Engine : = & Docker Task Engine { cfg : cfg , client : client , saver : statemanager . New Noop State Manager ( ) , state : state , managed Tasks : make ( map [ string ] * managed Task ) , task Stop Group : utilsync . New Sequential Wait Group ( ) , state Change Events : make ( chan statechange . Event ) , credentials Manager : credentials Manager , container Change Event Stream : container Change Event Stream , image Manager : image Manager , cni Client : ecscni . New Client ( & ecscni . Config { Plugins Path : cfg . CNIPlugins Path , Min Supported CNIVersion : config . Default Min Supported CNIVersion , } ) , metadata Manager : metadata Manager , task Steady State Poll Interval : default Task Steady State Poll Interval , resource Fields : resource Fields , } docker Task Engine . initialize Container Status To Transition Function ( ) return docker Task Engine } 
func ( engine * Docker Task Engine ) Unmarshal JSON ( data [ ] byte ) error { return engine . state . Unmarshal JSON ( data ) } 
func ( engine * Docker Task Engine ) Init ( ctx context . Context ) error { engine . stop Engine = cancel engine . ctx = derived Ctx if err ! = nil { return err } engine . synchronize State ( ) engine . initialized = true return nil } 
func ( engine * Docker Task Engine ) Must Init ( ctx context . Context ) { if engine . initialized { return } engine . must Init Lock . Lock ( ) defer engine . must Init Lock . Unlock ( ) error Once : = sync . Once { } task Engine Connect Backoff : = retry . New Exponential Backoff ( min Engine Connect Retry Delay , max Engine Connect Retry Delay , engine Connect Retry Jitter Multiplier , engine Connect Retry Delay Multiplier ) retry . Retry With Backoff ( task Engine Connect Backoff , func ( ) error { if engine . initialized { return nil } err : = engine . Init ( ctx ) if err ! = nil { error Once . Do ( func ( ) { seelog . Errorf ( " " , err ) } ) } return err } ) } 
func ( engine * Docker Task Engine ) is Task Managed ( arn string ) bool { engine . tasks Lock . RLock ( ) defer engine . tasks Lock . RUnlock ( ) _ , ok : = engine . managed Tasks [ arn ] return ok } 
func ( engine * Docker Task Engine ) synchronize State ( ) { engine . tasks Lock . Lock ( ) defer engine . tasks Lock . Unlock ( ) image States : = engine . state . All Image States ( ) if len ( image States ) ! = 0 { engine . image Manager . Add All Image States ( image States ) } tasks : = engine . state . All Tasks ( ) tasks To Start : = engine . filter Tasks To Start Unsafe ( tasks ) for _ , task : = range tasks { task . Initialize Resources ( engine . resource Fields ) } for _ , task : = range tasks To Start { engine . start Task ( task ) } engine . saver . Save ( ) } 
func ( engine * Docker Task Engine ) filter Tasks To Start Unsafe ( tasks [ ] * apitask . Task ) [ ] * apitask . Task { var tasks To Start [ ] * apitask . Task for _ , task : = range tasks { conts , ok : = engine . state . Container Map By Arn ( task . Arn ) if ! ok { continue } for _ , cont : = range conts { engine . synchronize Container Status ( cont , task ) } tasks To Start = append ( tasks To Start , task ) } } return tasks To Start } 
func update Container Metadata ( metadata * dockerapi . Docker Container Metadata , container * apicontainer . Container , task * apitask . Task ) { container . Set Created At ( metadata . Created At ) container . Set Started At ( metadata . Started At ) container . Set Finished At ( metadata . Finished At ) } } else { container . Set Volumes ( metadata . Volumes ) } } } } } container . Set Network Mode ( metadata . Network Mode ) container . Set Network Settings ( metadata . Network Settings ) } 
func ( engine * Docker Task Engine ) synchronize Container Status ( container * apicontainer . Docker Container , task * apitask . Task ) { if container . Docker ID = = " " { seelog . Debugf ( " " , task . Arn , container . Docker Name ) if err ! = nil { seelog . Warnf ( " " , task . Arn , container . Docker Name , err ) } else { update Container Metadata ( & metadata , container . Container , task ) container . Docker ID = described Container . ID container . Container . Set Known Status ( dockerapi . Docker State To State ( described Container . State ) ) engine . image Manager . Record Container Reference ( container . Container ) } return } current State , metadata : = engine . client . Describe Container ( engine . ctx , container . Docker ID ) if metadata . Error ! = nil { current State = apicontainerstatus . Container Stopped if ! container . Container . Known Terminal ( ) { container . Container . Applying Error = apierrors . New Named Error ( & Container Vanished Error { } ) engine . image Manager . Remove Container Reference From Image State ( container . Container ) } } else { container . Container . Applying Error = apierrors . New Named Error ( metadata . Error ) } } else { engine . image Manager . Record Container Reference ( container . Container ) if engine . cfg . Container Metadata Enabled & & ! container . Container . Is Metadata File Updated ( ) { go engine . update Metadata File ( task , container ) } } if current State > container . Container . Get Known Status ( ) { } } 
func ( engine * Docker Task Engine ) check Task State ( task * apitask . Task ) { defer metrics . Metrics Engine Global . Record Task Engine Metric ( " " ) ( ) task Containers , ok : = engine . state . Container Map By Arn ( task . Arn ) if ! ok { seelog . Warnf ( " " , task . Arn ) return } for _ , container : = range task . Containers { docker Container , ok : = task Containers [ container . Name ] if ! ok { continue } status , metadata : = engine . client . Describe Container ( engine . ctx , docker Container . Docker ID ) engine . tasks Lock . RLock ( ) managed Task , ok : = engine . managed Tasks [ task . Arn ] engine . tasks Lock . RUnlock ( ) if ok { managed Task . emit Docker Container Change ( docker Container Change { container : container , event : dockerapi . Docker Container Change Event { Status : status , Docker Container Metadata : metadata , } , } ) } } } 
func ( engine * Docker Task Engine ) sweep Task ( task * apitask . Task ) { for _ , cont : = range task . Containers { err : = engine . remove Container ( task , cont ) if err ! = nil { seelog . Debugf ( " " , task . Arn , cont . Name , err ) } } err = engine . image Manager . Remove Container Reference From Image State ( cont ) if err ! = nil { seelog . Errorf ( " " , task . Arn , cont . Name , err ) } } if err ! = nil { seelog . Warnf ( " " , task . Arn , err ) } } engine . saver . Save ( ) } 
func ( engine * Docker Task Engine ) start Task ( task * apitask . Task ) { this Task . _time = engine . time ( ) go this Task . oversee Task ( ) } 
func ( engine * Docker Task Engine ) open Eventstream ( ctx context . Context ) error { events , err : = engine . client . Container Events ( ctx ) if err ! = nil { return err } engine . events = events return nil } 
func ( engine * Docker Task Engine ) handle Docker Events ( ctx context . Context ) { for { select { case < - ctx . Done ( ) : return case event : = < - engine . events : engine . handle Docker Event ( event ) } } } 
func ( engine * Docker Task Engine ) handle Docker Event ( event dockerapi . Docker Container Change Event ) { seelog . Debugf ( " " , event . String ( ) ) task , ok : = engine . state . Task By ID ( event . Docker ID ) if ! ok { seelog . Debugf ( " " , event . Docker ID ) return } cont , ok : = engine . state . Container By ID ( event . Docker ID ) if ! ok { seelog . Debugf ( " " , event . Docker ID ) return } cont . Container . Set Health Status ( event . Docker Container Metadata . Health ) } return } engine . tasks Lock . RLock ( ) managed Task , ok : = engine . managed Tasks [ task . Arn ] if ! ok { seelog . Criticalf ( " " , task . Arn , event . String ( ) ) return } seelog . Debugf ( " " , task . Arn , event . String ( ) ) managed Task . emit Docker Container Change ( docker Container Change { container : cont . Container , event : event } ) seelog . Debugf ( " " , task . Arn , event . String ( ) ) } 
func ( engine * Docker Task Engine ) Add Task ( task * apitask . Task ) { defer metrics . Metrics Engine Global . Record Task Engine Metric ( " " ) ( ) err : = task . Post Unmarshal Task ( engine . cfg , engine . credentials Manager , engine . resource Fields , engine . client , engine . ctx ) if err ! = nil { seelog . Errorf ( " " , task . Arn , err ) task . Set Known Status ( apitaskstatus . Task Stopped ) task . Set Desired Status ( apitaskstatus . Task Stopped ) engine . emit Task Event ( task , err . Error ( ) ) return } engine . tasks Lock . Lock ( ) defer engine . tasks Lock . Unlock ( ) existing Task , exists : = engine . state . Task By Arn ( task . Arn ) if ! exists { engine . state . Add Task ( task ) if dependencygraph . Valid Dependencies ( task ) { engine . start Task ( task ) } else { seelog . Errorf ( " " , task . Arn ) task . Set Known Status ( apitaskstatus . Task Stopped ) task . Set Desired Status ( apitaskstatus . Task Stopped ) err : = Task Dependency Error { task . Arn } engine . emit Task Event ( task , err . Error ( ) ) } return } } 
func ( engine * Docker Task Engine ) List Tasks ( ) ( [ ] * apitask . Task , error ) { return engine . state . All Tasks ( ) , nil } 
func ( engine * Docker Task Engine ) Get Task By Arn ( arn string ) ( * apitask . Task , bool ) { return engine . state . Task By Arn ( arn ) } 
func ( engine * Docker Task Engine ) image Pull Required ( image Pull Behavior config . Image Pull Behavior Type , container * apicontainer . Container , task Arn string ) bool { switch image Pull Behavior { case config . Image Pull Once Behavior : if ok & & image State . Get Pull Succeeded ( ) { seelog . Infof ( " " , task Arn , container . Image , container . Name ) return false } return true case config . Image Pull Prefer Cached Behavior : if err ! = nil { return true } seelog . Infof ( " " , task Arn , container . Image , container . Name ) return false default : } } 
func ( engine * Docker Task Engine ) cleanup Pause Container Network ( task * apitask . Task , container * apicontainer . Container ) error { seelog . Infof ( " " , task . Arn ) cni Config , err : = engine . build CNIConfig From Task Container ( task , container ) if err ! = nil { return errors . Wrapf ( err , " " , task . String ( ) ) } return engine . cni Client . Cleanup NS ( engine . ctx , cni Config , cni Cleanup Timeout ) } 
func ( engine * Docker Task Engine ) update Task Unsafe ( task * apitask . Task , update * apitask . Task ) { managed Task , ok : = engine . managed Tasks [ task . Arn ] if ! ok { seelog . Criticalf ( " " , task . Arn ) return } seelog . Debugf ( " " , task . Arn , update Desired Status . String ( ) , update . Stop Sequence Number ) managed Task . emit ACSTransition ( acs Transition { desired Status : update Desired Status , seqnum : update . Stop Sequence Number , } ) seelog . Debugf ( " " , task . Arn , update Desired Status . String ( ) , update . Stop Sequence Number ) } 
func ( engine * Docker Task Engine ) transition Container ( task * apitask . Task , container * apicontainer . Container , to apicontainerstatus . Container Status ) { engine . tasks Lock . RLock ( ) managed Task , ok : = engine . managed Tasks [ task . Arn ] engine . tasks Lock . RUnlock ( ) if ok { managed Task . emit Docker Container Change ( docker Container Change { container : container , event : dockerapi . Docker Container Change Event { Status : to , Docker Container Metadata : metadata , } , } ) } } 
func ( engine * Docker Task Engine ) apply Container State ( task * apitask . Task , container * apicontainer . Container , next State apicontainerstatus . Container Status ) dockerapi . Docker Container Metadata { transition Function , ok : = engine . transition Function Map ( ) [ next State ] if ! ok { seelog . Criticalf ( " " , task . Arn , container . Name , next State . String ( ) ) return dockerapi . Docker Container Metadata { Error : & impossible Transition Error { next State } } } metadata : = transition Function ( task , container ) if metadata . Error ! = nil { seelog . Infof ( " " , task . Arn , container . Name , next State . String ( ) , metadata . Error ) } else { seelog . Debugf ( " " , task . Arn , container . Name , next State . String ( ) ) engine . saver . Save ( ) } return metadata } 
func ( engine * Docker Task Engine ) Version ( ) ( string , error ) { return engine . client . Version ( engine . ctx , dockerclient . Version Timeout ) } 
func New Mock SSMClient ( ctrl * gomock . Controller ) * Mock SSMClient { mock : = & Mock SSMClient { ctrl : ctrl } mock . recorder = & Mock SSMClient Mock Recorder { mock } return mock } 
func ( m * Mock SSMClient ) Get Parameters ( arg 0 * ssm . Get Parameters Input ) ( * ssm . Get Parameters Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ssm . Get Parameters Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock SSMClient Mock Recorder ) Get Parameters ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock SSMClient ) ( nil ) . Get Parameters ) , arg 0 ) } 
func New Mock Factory ( ctrl * gomock . Controller ) * Mock Factory { mock : = & Mock Factory { ctrl : ctrl } mock . recorder = & Mock Factory Mock Recorder { mock } return mock } 
func ( m * Mock Factory ) Find Client APIVersion ( arg 0 sdkclient . Client ) dockerclient . Docker Version { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( dockerclient . Docker Version ) return ret 0 } 
func ( m * Mock Factory ) Find Known APIVersions ( ) [ ] dockerclient . Docker Version { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] dockerclient . Docker Version ) return ret 0 } 
func ( m * Mock Factory ) Get Client ( arg 0 dockerclient . Docker Version ) ( sdkclient . Client , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( sdkclient . Client ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Factory ) Get Default Client ( ) ( sdkclient . Client , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( sdkclient . Client ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func New Mock File System ( ctrl * gomock . Controller ) * Mock File System { mock : = & Mock File System { ctrl : ctrl } mock . recorder = & Mock File System Mock Recorder { mock } return mock } 
func ( m * Mock File System ) Copy ( arg 0 io . Writer , arg 1 io . Reader ) ( int 6 4 , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( int 6 4 ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock File System ) Exit ( arg 0 int ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock File System ) Mkdir All ( arg 0 string , arg 1 os . File Mode ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock File System ) Open ( arg 0 string ) ( io . Read Write Closer , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( io . Read Write Closer ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock File System ) Read All ( arg 0 io . Reader ) ( [ ] byte , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( [ ] byte ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock File System ) Remove ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock File System Mock Recorder ) Remove ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock File System ) ( nil ) . Remove ) , arg 0 ) } 
func ( m * Mock File System ) Rename ( arg 0 , arg 1 string ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock File System ) Tee Reader ( arg 0 io . Reader , arg 1 io . Writer ) io . Reader { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( io . Reader ) return ret 0 } 
func ( m * Mock File System ) Temp File ( arg 0 , arg 1 string ) ( * os . File , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( * os . File ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( agent * ecs Agent ) initialize Task ENIDependencies ( state dockerstate . Task Engine State , task Engine engine . Task Engine ) ( error , bool ) { } } } } return err , false } if err : = agent . start Udev Watcher ( state , task Engine . State Change Events ( ) ) ; err ! = nil { } return nil , false } 
func ( agent * ecs Agent ) set VPCSubnet ( ) ( error , bool ) { mac , err : = agent . ec 2Metadata Client . Primary ENIMAC ( ) if err ! = nil { return fmt . Errorf ( " " , err ) , false } vpc ID , err : = agent . ec 2Metadata Client . VPCID ( mac ) if err ! = nil { if is Instance Launched In VPC ( err ) { return fmt . Errorf ( " " , err ) , true } return instance Not Launched In VPCError , false } subnet ID , err : = agent . ec 2Metadata Client . Subnet ID ( mac ) if err ! = nil { return fmt . Errorf ( " " , err ) , false } agent . vpc = vpc ID agent . subnet = subnet ID agent . mac = mac return nil , false } 
func is Instance Launched In VPC ( err error ) bool { if metadata Err , ok : = err . ( * ec 2 . Metadata Error ) ; ok & & metadata Err . Get Status Code ( ) = = http . Status Not Found { return false } return true } 
func ( agent * ecs Agent ) verify CNIPlugins Capabilities ( ) error { if err ! = nil { return err } } if ! contains ( capabilities , ecscni . Capability AWSVPCNetworking Mode ) { return errors . Errorf ( " " , plugin , ecscni . Capability AWSVPCNetworking Mode ) } } return nil } 
func ( agent * ecs Agent ) start Udev Watcher ( state dockerstate . Task Engine State , state Change Events chan < - statechange . Event ) error { seelog . Debug ( " " ) udev Monitor , err : = udevwrapper . New ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } if err : = eni Watcher . Init ( ) ; err ! = nil { return errors . Wrapf ( err , " " ) } go eni Watcher . Start ( ) return nil } 
func ( agent * ecs Agent ) initialize Resource Fields ( credentials Manager credentials . Manager ) { agent . resource Fields = & taskresource . Resource Fields { Control : cgroup . New ( ) , Resource Fields Common : & taskresource . Resource Fields Common { IOUtil : ioutilwrapper . New IOUtil ( ) , ASMClient Creator : asmfactory . New Client Creator ( ) , SSMClient Creator : ssmfactory . New SSMClient Creator ( ) , Credentials Manager : credentials Manager , } , Ctx : agent . ctx , Docker Client : agent . docker Client , Nvidia GPUManager : gpu . New Nvidia GPUManager ( ) , } } 
func ( gm * Generic Metrics ) Record Call ( call ID , call Name string , call Time time . Time , call Started chan bool ) string { if call ID = = " " { hash Data : = [ ] byte ( " " + call Name + strconv . Format Float ( float 6 4 ( rand . Float 3 2 ( ) ) , 'f ' , - 1 , 3 2 ) ) hash : = fmt . Sprintf ( " " , md 5 . Sum ( hash Data ) ) go gm . Increment Call Count ( call Name ) return hash } else { go gm . Fire Call End ( call ID , call Name , call Time , call Started ) return " " } } 
func ( gm * Generic Metrics ) Increment Call Count ( call Name string ) { defer func ( ) { if r : = recover ( ) ; r ! = nil { seelog . Errorf ( " " , call Name , r ) } } ( ) gm . lock . Lock ( ) defer gm . lock . Unlock ( ) gm . counter Vec . With Label Values ( call Name ) . Inc ( ) } 
func New Mock Task Engine State ( ctrl * gomock . Controller ) * Mock Task Engine State { mock : = & Mock Task Engine State { ctrl : ctrl } mock . recorder = & Mock Task Engine State Mock Recorder { mock } return mock } 
func ( m * Mock Task Engine State ) Add Container ( arg 0 * container . Docker Container , arg 1 * task . Task ) { m . ctrl . Call ( m , " " , arg 0 , arg 1 ) } 
func ( m * Mock Task Engine State ) Add ENIAttachment ( arg 0 * eni . ENIAttachment ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine State ) Add Image State ( arg 0 * image . Image State ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine State ) Add Task ( arg 0 * task . Task ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine State ) Add Task IPAddress ( arg 0 , arg 1 string ) { m . ctrl . Call ( m , " " , arg 0 , arg 1 ) } 
func ( m * Mock Task Engine State ) All Image States ( ) [ ] * image . Image State { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] * image . Image State ) return ret 0 } 
func ( mr * Mock Task Engine State Mock Recorder ) All Image States ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Engine State ) ( nil ) . All Image States ) ) } 
func ( m * Mock Task Engine State ) All Tasks ( ) [ ] * task . Task { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] * task . Task ) return ret 0 } 
func ( m * Mock Task Engine State ) Container By ID ( arg 0 string ) ( * container . Docker Container , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * container . Docker Container ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine State ) ENIBy Mac ( arg 0 string ) ( * eni . ENIAttachment , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * eni . ENIAttachment ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine State ) Get All Container IDs ( ) [ ] string { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] string ) return ret 0 } 
func ( m * Mock Task Engine State ) Remove ENIAttachment ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine State ) Remove Image State ( arg 0 * image . Image State ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock Task Engine State ) Remove Task ( arg 0 * task . Task ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Task Engine State Mock Recorder ) Remove Task ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Task Engine State ) ( nil ) . Remove Task ) , arg 0 ) } 
func ( m * Mock Task Engine State ) Task ARNBy V 3Endpoint ID ( arg 0 string ) ( string , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( string ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine State ) Task By Arn ( arg 0 string ) ( * task . Task , bool ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * task . Task ) ret 1 , _ : = ret [ 1 ] . ( bool ) return ret 0 , ret 1 } 
func ( m * Mock Task Engine State ) Unmarshal JSON ( arg 0 [ ] byte ) error { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( container Type Container Type ) String ( ) string { for str , cont Type : = range string To Container Type { if cont Type = = container Type { return str } } return " " } 
func ( container Type * Container Type ) Unmarshal JSON ( b [ ] byte ) error { str Type : = string ( b ) switch str Type { case " " : * container Type = Container Normal seelog . Warn ( " " ) return nil return nil case " " : * container Type = Container Normal return nil } if len ( str Type ) < 2 { * container Type = Container Normal return errors . New ( " " + string ( b ) ) } if b [ 0 ] ! = ' " ' | | b [ len ( b ) - 1 ] ! = ' " ' { * container Type = Container Normal return errors . New ( " " + string ( b ) ) } str Type = string ( b [ 1 : len ( b ) - 1 ] ) cont Type , ok : = string To Container Type [ str Type ] if ! ok { * container Type = Container Normal return errors . New ( " " + str Type ) } * container Type = cont Type return nil } 
func ( container Type * Container Type ) Marshal JSON ( ) ( [ ] byte , error ) { if container Type = = nil { return [ ] byte ( " " ) , nil } return [ ] byte ( ` " ` + container Type . String ( ) + ` " ` ) , nil } 
func parse Nano Time ( value string ) time . Time { ts , _ : = time . Parse ( time . RFC 3 3 3 9Nano , value ) return ts } 
func is Network Stats Error ( err error ) bool { matched , m Err : = regexp . Match String ( network Stats Error Pattern , err . Error ( ) ) if m Err ! = nil { seelog . Debugf ( " " , m Err ) return false } return matched } 
func New Mock Response Writer ( ctrl * gomock . Controller ) * Mock Response Writer { mock : = & Mock Response Writer { ctrl : ctrl } mock . recorder = & Mock Response Writer Mock Recorder { mock } return mock } 
func ( m * Mock Response Writer ) Header ( ) http . Header { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( http . Header ) return ret 0 } 
func ( mr * Mock Response Writer Mock Recorder ) Header ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Response Writer ) ( nil ) . Header ) ) } 
func ( m * Mock Response Writer ) Write Header ( arg 0 int ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock Response Writer Mock Recorder ) Write Header ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Response Writer ) ( nil ) . Write Header ) , arg 0 ) } 
func ( lhs Docker APIVersion ) Matches ( selector string ) ( bool , error ) { lhs Version , err : = parse Docker Versions ( string ( lhs ) ) if err ! = nil { return false , err } if strings . Contains ( selector , " " ) { or Elements : = strings . Split ( selector , " " ) for _ , el : = range or Elements { if el Matches , err : = lhs . Matches ( el ) ; err ! = nil { return false , err } else if el Matches { return true , nil } } } if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Docker Versions ( selector [ 2 : ] ) if err ! = nil { return false , err } return compare Docker Versions ( lhs Version , rhs Version ) > = 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Docker Versions ( selector [ 1 : ] ) if err ! = nil { return false , err } return compare Docker Versions ( lhs Version , rhs Version ) > 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Docker Versions ( selector [ 2 : ] ) if err ! = nil { return false , err } return compare Docker Versions ( lhs Version , rhs Version ) < = 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Docker Versions ( selector [ 1 : ] ) if err ! = nil { return false , err } return compare Docker Versions ( lhs Version , rhs Version ) < 0 , nil } rhs Version , err : = parse Docker Versions ( selector ) if err ! = nil { return false , err } return compare Docker Versions ( lhs Version , rhs Version ) = = 0 , nil } 
func compare Docker Versions ( lhs , rhs docker Version ) int { switch { case lhs . major < rhs . major : return - 1 case lhs . major > rhs . major : return 1 case lhs . minor < rhs . minor : return - 1 case lhs . minor > rhs . minor : return 1 } return 0 } 
func Sign HTTPRequest ( req * http . Request , region , service string , creds * credentials . Credentials , body io . Read Seeker ) error { signer : = v 4 . New Signer ( creds ) _ , err : = signer . Sign ( req , body , service , region , time . Now ( ) ) if err ! = nil { seelog . Warnf ( " " , err ) return errors . Wrap ( err , " " ) } return nil } 
func ( f * factory ) Get Client ( version dockerclient . Docker Version ) ( sdkclient . Client , error ) { return f . get Client ( version ) } 
func get Agent Versions ( ) [ ] dockerclient . Docker Version { return [ ] dockerclient . Docker Version { dockerclient . Version _ 1 _ 1 7 , dockerclient . Version _ 1 _ 1 8 , dockerclient . Version _ 1 _ 1 9 , dockerclient . Version _ 1 _ 2 0 , dockerclient . Version _ 1 _ 2 1 , dockerclient . Version _ 1 _ 2 2 , dockerclient . Version _ 1 _ 2 3 , dockerclient . Version _ 1 _ 2 4 , dockerclient . Version _ 1 _ 2 5 , dockerclient . Version _ 1 _ 2 6 , dockerclient . Version _ 1 _ 2 7 , dockerclient . Version _ 1 _ 2 8 , dockerclient . Version _ 1 _ 2 9 , dockerclient . Version _ 1 _ 3 0 , dockerclient . Version _ 1 _ 3 1 , dockerclient . Version _ 1 _ 3 2 , } } 
func ( a * audit Log ) Log ( r request . Log Request , http Response Code int , event Type string ) { if ! a . cfg . Credentials Audit Log Disabled { audit Log Entry : = construct Audit Log Entry ( r , http Response Code , event Type , a . Get Cluster ( ) , a . Get Container Instance Arn ( ) ) a . logger . Info ( audit Log Entry ) } } 
func ( task * Task ) docker CPUShares ( container CPU uint ) int 6 4 { if container CPU < = 1 { seelog . Debugf ( " " , task . Arn , container CPU ) return 2 } return int 6 4 ( container CPU ) } 
func verify Tasks Metadata ( tasks Metadata Raw Msg json . Raw Message ) error { var tasks Metadata Map map [ string ] json . Raw Message json . Unmarshal ( tasks Metadata Raw Msg , & tasks Metadata Map ) if tasks Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } var tasks Metadata Array [ ] json . Raw Message json . Unmarshal ( tasks Metadata Map [ " " ] , & tasks Metadata Array ) if len ( tasks Metadata Array ) ! = 1 { return fmt . Errorf ( " " , len ( tasks Metadata Array ) ) } return verify Task Metadata ( tasks Metadata Array [ 0 ] ) } 
func verify Task Metadata ( task Metadata Raw Msg json . Raw Message ) error { task Metadata Map : = make ( map [ string ] json . Raw Message ) json . Unmarshal ( task Metadata Raw Msg , & task Metadata Map ) if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if task Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } var containers Metadata Array [ ] json . Raw Message json . Unmarshal ( task Metadata Map [ " " ] , & containers Metadata Array ) if len ( containers Metadata Array ) ! = 1 { return fmt . Errorf ( " " , len ( containers Metadata Array ) ) } return verify Container Metadata ( containers Metadata Array [ 0 ] ) } 
func verify Container Metadata ( container Metadata Raw Msg json . Raw Message ) error { container Metadata Map : = make ( map [ string ] json . Raw Message ) json . Unmarshal ( container Metadata Raw Msg , & container Metadata Map ) if container Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } var actual Container Name string json . Unmarshal ( container Metadata Map [ " " ] , & actual Container Name ) if actual Container Name ! = container Name { return fmt . Errorf ( " " , container Name , actual Container Name ) } if container Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if container Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } if container Metadata Map [ " " ] = = nil { return not Empty Err Msg ( " " ) } return nil } 
func New Mock Result ( ctrl * gomock . Controller ) * Mock Result { mock : = & Mock Result { ctrl : ctrl } mock . recorder = & Mock Result Mock Recorder { mock } return mock } 
func ( m * Mock Result ) Get As Version ( arg 0 string ) ( types . Result , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( types . Result ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Result Mock Recorder ) Get As Version ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Result ) ( nil ) . Get As Version ) , arg 0 ) } 
func ( m * Mock Result ) Print ( ) error { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock Result Mock Recorder ) Print ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Result ) ( nil ) . Print ) ) } 
func ( m * Mock Client ) Container Create ( arg 0 context . Context , arg 1 * container . Config , arg 2 * container . Host Config , arg 3 * network . Networking Config , arg 4 string ) ( container . Container Create Created Body , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 , arg 4 ) ret 0 , _ : = ret [ 0 ] . ( container . Container Create Created Body ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Container Inspect ( arg 0 context . Context , arg 1 string ) ( types . Container JSON , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Container JSON ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Container List ( arg 0 context . Context , arg 1 types . Container List Options ) ( [ ] types . Container , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( [ ] types . Container ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Container Remove ( arg 0 context . Context , arg 1 string , arg 2 types . Container Remove Options ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client ) Container Start ( arg 0 context . Context , arg 1 string , arg 2 types . Container Start Options ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client ) Container Stats ( arg 0 context . Context , arg 1 string , arg 2 bool ) ( types . Container Stats , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( types . Container Stats ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Container Stop ( arg 0 context . Context , arg 1 string , arg 2 * time . Duration ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( m * Mock Client ) Events ( arg 0 context . Context , arg 1 types . Events Options ) ( < - chan events . Message , < - chan error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( < - chan events . Message ) ret 1 , _ : = ret [ 1 ] . ( < - chan error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Image Import ( arg 0 context . Context , arg 1 types . Image Import Source , arg 2 string , arg 3 types . Image Import Options ) ( io . Read Closer , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 , arg 3 ) ret 0 , _ : = ret [ 0 ] . ( io . Read Closer ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Image Inspect With Raw ( arg 0 context . Context , arg 1 string ) ( types . Image Inspect , [ ] byte , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Image Inspect ) ret 1 , _ : = ret [ 1 ] . ( [ ] byte ) ret 2 , _ : = ret [ 2 ] . ( error ) return ret 0 , ret 1 , ret 2 } 
func ( m * Mock Client ) Image List ( arg 0 context . Context , arg 1 types . Image List Options ) ( [ ] types . Image Summary , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( [ ] types . Image Summary ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Image Load ( arg 0 context . Context , arg 1 io . Reader , arg 2 bool ) ( types . Image Load Response , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( types . Image Load Response ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Image Pull ( arg 0 context . Context , arg 1 string , arg 2 types . Image Pull Options ) ( io . Read Closer , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( io . Read Closer ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Image Remove ( arg 0 context . Context , arg 1 string , arg 2 types . Image Remove Options ) ( [ ] types . Image Delete Response Item , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( [ ] types . Image Delete Response Item ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Ping ( arg 0 context . Context ) ( types . Ping , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( types . Ping ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Plugin List ( arg 0 context . Context , arg 1 filters . Args ) ( types . Plugins List Response , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Plugins List Response ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Volume Create ( arg 0 context . Context , arg 1 volume . Volume Create Body ) ( types . Volume , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Volume ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Volume Inspect ( arg 0 context . Context , arg 1 string ) ( types . Volume , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Volume ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock Client ) Volume Remove ( arg 0 context . Context , arg 1 string , arg 2 bool ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( resolver * Docker Container Metadata Resolver ) Resolve Task ( docker ID string ) ( * apitask . Task , error ) { if resolver . docker Task Engine = = nil { return nil , fmt . Errorf ( " " ) } task , found : = resolver . docker Task Engine . State ( ) . Task By ID ( docker ID ) if ! found { return nil , fmt . Errorf ( " " , docker ID ) } return task , nil } 
func ( resolver * Docker Container Metadata Resolver ) Resolve Container ( docker ID string ) ( * apicontainer . Docker Container , error ) { if resolver . docker Task Engine = = nil { return nil , fmt . Errorf ( " " ) } container , found : = resolver . docker Task Engine . State ( ) . Container By ID ( docker ID ) if ! found { return nil , fmt . Errorf ( " " , docker ID ) } return container , nil } 
func New Docker Stats Engine ( cfg * config . Config , client dockerapi . Docker Client , container Change Event Stream * eventstream . Event Stream ) * Docker Stats Engine { return & Docker Stats Engine { client : client , resolver : nil , disable Metrics : cfg . Disable Metrics , tasks To Containers : make ( map [ string ] map [ string ] * Stats Container ) , tasks To Health Check Containers : make ( map [ string ] map [ string ] * Stats Container ) , tasks To Definitions : make ( map [ string ] * task Definition ) , container Change Event Stream : container Change Event Stream , } } 
func ( engine * Docker Stats Engine ) synchronize State ( ) error { list Containers Response : = engine . client . List Containers ( engine . ctx , false , dockerclient . List Containers Timeout ) if list Containers Response . Error ! = nil { return list Containers Response . Error } for _ , container ID : = range list Containers Response . Docker IDs { engine . add And Start Stats Container ( container ID ) } return nil } 
func ( engine * Docker Stats Engine ) add And Start Stats Container ( container ID string ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) stats Container , err : = engine . add Container Unsafe ( container ID ) if err ! = nil { seelog . Debugf ( " " , container ID , err ) return } if engine . disable Metrics | | stats Container = = nil { return } stats Container . Start Stats Collection ( ) } 
func ( engine * Docker Stats Engine ) Must Init ( ctx context . Context , task Engine ecsengine . Task Engine , cluster string , container Instance Arn string ) error { derived Ctx , cancel : = context . With Cancel ( ctx ) engine . stop Engine = cancel engine . ctx = derived Ctx engine . cluster = cluster engine . container Instance Arn = container Instance Arn var err error engine . resolver , err = new Docker Container Metadata Resolver ( task Engine ) if err ! = nil { return err } if err ! = nil { return fmt . Errorf ( " " , err ) } err = engine . synchronize State ( ) if err ! = nil { seelog . Warnf ( " " , err ) } go engine . wait To Stop ( ) return nil } 
func ( engine * Docker Stats Engine ) wait To Stop ( ) { select { case < - ctx . Done ( ) : seelog . Debug ( " " ) engine . container Change Event Stream . Unsubscribe ( container Change Handler ) engine . remove All ( ) } } 
func ( engine * Docker Stats Engine ) remove All ( ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) for task , containers : = range engine . tasks To Containers { for _ , stats Container : = range containers { stats Container . Stop Stats Collection ( ) } delete ( engine . tasks To Containers , task ) } for task : = range engine . tasks To Health Check Containers { delete ( engine . tasks To Containers , task ) } } 
func ( engine * Docker Stats Engine ) add Container Unsafe ( docker ID string ) ( * Stats Container , error ) { if err ! = nil { return nil , errors . Wrapf ( err , " " , docker ID ) } if len ( task . Arn ) = = 0 | | len ( task . Family ) = = 0 { return nil , errors . Errorf ( " " , task . Arn , task . Family ) } if task . Get Known Status ( ) . Terminal ( ) { return nil , errors . Errorf ( " " , docker ID , task . Arn ) } seelog . Debugf ( " " , docker ID , task . Arn ) stats Container : = new Stats Container ( docker ID , engine . client , engine . resolver ) engine . tasks To Definitions [ task . Arn ] = & task Definition { family : task . Family , version : task . Version } watch Stats Container : = false if ! engine . disable Metrics { } if docker Container , err : = engine . resolver . Resolve Container ( docker ID ) ; err ! = nil { seelog . Debugf ( " " , docker ID , err ) } else if docker Container . Container . Health Status Should Be Reported ( ) { seelog . Debugf ( " " , docker ID , task . Arn ) } if ! watch Stats Container { return nil , nil } return stats Container , nil } 
func ( engine * Docker Stats Engine ) add To Stats Container Map Unsafe ( task ARN , container ID string , stats Container * Stats Container , stats Map To Update func ( ) map [ string ] map [ string ] * Stats Container ) bool { task To Container Map : = stats Map To Update ( ) if task Exists { if container Exists { return false } } else { } task To Container Map [ task ARN ] [ container ID ] = stats Container return true } 
func ( engine * Docker Stats Engine ) Get Instance Metrics ( ) ( * ecstcs . Metrics Metadata , [ ] * ecstcs . Task Metric , error ) { var task Metrics [ ] * ecstcs . Task Metric idle : = engine . is Idle ( ) metrics Metadata : = & ecstcs . Metrics Metadata { Cluster : aws . String ( engine . cluster ) , Container Instance : aws . String ( engine . container Instance Arn ) , Idle : aws . Bool ( idle ) , Message Id : aws . String ( uuid . New Random ( ) . String ( ) ) , } if idle { seelog . Debug ( " " ) fin : = true metrics Metadata . Fin = & fin return metrics Metadata , task Metrics , nil } engine . lock . Lock ( ) defer engine . lock . Unlock ( ) for task Arn : = range engine . tasks To Containers { container Metrics , err : = engine . task Container Metrics Unsafe ( task Arn ) if err ! = nil { seelog . Debugf ( " " , task Arn , err ) continue } if len ( container Metrics ) = = 0 { seelog . Debugf ( " " , task Arn ) continue } task Def , exists : = engine . tasks To Definitions [ task Arn ] if ! exists { seelog . Debugf ( " " , task Arn ) continue } metric Task Arn : = task Arn task Metric : = & ecstcs . Task Metric { Task Arn : & metric Task Arn , Task Definition Family : & task Def . family , Task Definition Version : & task Def . version , Container Metrics : container Metrics , } task Metrics = append ( task Metrics , task Metric ) } if len ( task Metrics ) = = 0 { } return metrics Metadata , task Metrics , nil } 
func ( engine * Docker Stats Engine ) Get Task Health Metrics ( ) ( * ecstcs . Health Metadata , [ ] * ecstcs . Task Health , error ) { var task Healths [ ] * ecstcs . Task Health metadata : = & ecstcs . Health Metadata { Cluster : aws . String ( engine . cluster ) , Container Instance : aws . String ( engine . container Instance Arn ) , Message Id : aws . String ( uuid . New Random ( ) . String ( ) ) , } if ! engine . container Healths To Monitor ( ) { return metadata , task Healths , nil } engine . lock . RLock ( ) defer engine . lock . RUnlock ( ) for task ARN : = range engine . tasks To Health Check Containers { task Health : = engine . get Task Health Unsafe ( task ARN ) if task Health = = nil { continue } task Healths = append ( task Healths , task Health ) } if len ( task Healths ) = = 0 { return nil , nil , Empty Health Metrics Error } return metadata , task Healths , nil } 
func ( engine * Docker Stats Engine ) stop Tracking Container Unsafe ( container * Stats Container , task ARN string ) bool { terminal , err : = container . terminal ( ) if err ! = nil { engine . do Remove Container Unsafe ( container , task ARN ) return true } if terminal { engine . do Remove Container Unsafe ( container , task ARN ) return true } return false } 
func ( engine * Docker Stats Engine ) handle Docker Events ( events . . . interface { } ) error { for _ , event : = range events { docker Container Change Event , ok : = event . ( dockerapi . Docker Container Change Event ) if ! ok { return fmt . Errorf ( " " ) } switch docker Container Change Event . Status { case apicontainerstatus . Container Running : engine . add And Start Stats Container ( docker Container Change Event . Docker ID ) case apicontainerstatus . Container Stopped : engine . remove Container ( docker Container Change Event . Docker ID ) default : seelog . Debugf ( " " , docker Container Change Event . Docker ID , docker Container Change Event . Status ) } } return nil } 
func ( engine * Docker Stats Engine ) remove Container ( docker ID string ) { engine . lock . Lock ( ) defer engine . lock . Unlock ( ) if err ! = nil { seelog . Debugf ( " " , err , docker ID ) return } _ , task Exists : = engine . tasks To Containers [ task . Arn ] if ! task Exists { seelog . Debugf ( " " , docker ID ) return } if ! container Exists { return } engine . do Remove Container Unsafe ( container , task . Arn ) } 
func new Docker Container Metadata Resolver ( task Engine ecsengine . Task Engine ) ( * Docker Container Metadata Resolver , error ) { docker Task Engine , ok : = task Engine . ( * ecsengine . Docker Task Engine ) if ! ok { } resolver : = & Docker Container Metadata Resolver { docker Task Engine : docker Task Engine , } return resolver , nil } 
func ( engine * Docker Stats Engine ) task Container Metrics Unsafe ( task Arn string ) ( [ ] * ecstcs . Container Metric , error ) { container Map , task Exists : = engine . tasks To Containers [ task Arn ] if ! task Exists { return nil , fmt . Errorf ( " " ) } var container Metrics [ ] * ecstcs . Container Metric for _ , container : = range container Map { docker ID : = container . container Metadata . Docker ID } if ! container . stats Queue . enough Datapoints In Buffer ( ) & & ! container . stats Queue . reset Threshold Elapsed ( queue Reset Threshold ) { seelog . Debugf ( " " , docker ID ) continue } if err ! = nil { seelog . Warnf ( " " , err , docker ID ) continue } if err ! = nil { seelog . Warnf ( " " , err , docker ID ) continue } container Metrics = append ( container Metrics , & ecstcs . Container Metric { Cpu Stats Set : cpu Stats Set , Memory Stats Set : memory Stats Set , } ) } return container Metrics , nil } 
func ( engine * Docker Stats Engine ) reset Stats Unsafe ( ) { for _ , container Map : = range engine . tasks To Containers { for _ , container : = range container Map { container . stats Queue . Reset ( ) } } } 
func ( engine * Docker Stats Engine ) Container Docker Stats ( task ARN string , container ID string ) ( * types . Stats JSON , error ) { engine . lock . RLock ( ) defer engine . lock . RUnlock ( ) container IDTo Stats Container , ok : = engine . tasks To Containers [ task ARN ] if ! ok { return nil , errors . Errorf ( " " , task ARN , container ID ) } container , ok : = container IDTo Stats Container [ container ID ] if ! ok { return nil , errors . Errorf ( " " , container ID ) } return container . stats Queue . Get Last Stat ( ) , nil } 
func new Metrics Metadata ( cluster * string , container Instance * string ) * ecstcs . Metrics Metadata { return & ecstcs . Metrics Metadata { Cluster : cluster , Container Instance : container Instance , } } 
func ( lhs Version ) Matches ( selector string ) ( bool , error ) { lhs Version , err : = parse Semver ( string ( lhs ) ) if err ! = nil { return false , err } if strings . Contains ( selector , " " ) { or Elements : = strings . Split ( selector , " " ) for _ , el : = range or Elements { if el Matches , err : = lhs . Matches ( el ) ; err ! = nil { return false , err } else if el Matches { return true , nil } } } if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Semver ( selector [ 2 : ] ) if err ! = nil { return false , err } return compare Semver ( lhs Version , rhs Version ) > = 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Semver ( selector [ 1 : ] ) if err ! = nil { return false , err } return compare Semver ( lhs Version , rhs Version ) > 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Semver ( selector [ 2 : ] ) if err ! = nil { return false , err } return compare Semver ( lhs Version , rhs Version ) < = 0 , nil } else if strings . Has Prefix ( selector , " " ) { rhs Version , err : = parse Semver ( selector [ 1 : ] ) if err ! = nil { return false , err } return compare Semver ( lhs Version , rhs Version ) < 0 , nil } rhs Version , err : = parse Semver ( selector ) if err ! = nil { return false , err } return compare Semver ( lhs Version , rhs Version ) = = 0 , nil } 
func compare Semver ( lhs , rhs semver ) int { if lhs . major < rhs . major { return - 1 } if lhs . major > rhs . major { return 1 } if lhs . minor < rhs . minor { return - 1 } if lhs . minor > rhs . minor { return 1 } if lhs . patch < rhs . patch { return - 1 } if lhs . patch > rhs . patch { return 1 } if lhs . pre Release Version ! = " " & & rhs . pre Release Version = = " " { return - 1 } if lhs . pre Release Version = = " " & & rhs . pre Release Version ! = " " { return 1 } if lhs . pre Release Version < rhs . pre Release Version { return - 1 } if lhs . pre Release Version > rhs . pre Release Version { return 1 } return 0 } 
func Extract Version ( input string ) string { version Number Regex : = regexp . Must Compile ( ` v ( \d + \ . \d + \ . \d + ( \ - [ \S \ . \ - ] + ) ? ( \ + [ \S \ . \ - ] + ) ? ) ` ) version Number Str : = version Number Regex . Find String Submatch ( input ) if len ( version Number Str ) > = 2 { return string ( version Number Str [ 1 ] ) } return " " } 
func ( role * Task IAMRole Credentials ) Get IAMRole Credentials ( ) IAMRole Credentials { role . lock . RLock ( ) defer role . lock . RUnlock ( ) return role . IAMRole Credentials } 
func ( role Credentials * IAMRole Credentials ) Generate Credentials Endpoint Relative URI ( ) string { return fmt . Sprintf ( credentials Endpoint Relative URIFormat , Credentials Path , role Credentials . Credentials ID ) } 
func IAMRole Credentials From ACS ( role Credentials * ecsacs . IAMRole Credentials , role Type string ) IAMRole Credentials { return IAMRole Credentials { Credentials ID : aws . String Value ( role Credentials . Credentials Id ) , Session Token : aws . String Value ( role Credentials . Session Token ) , Role Arn : aws . String Value ( role Credentials . Role Arn ) , Access Key ID : aws . String Value ( role Credentials . Access Key Id ) , Secret Access Key : aws . String Value ( role Credentials . Secret Access Key ) , Expiration : aws . String Value ( role Credentials . Expiration ) , Role Type : role Type , } } 
func ( manager * credentials Manager ) Set Task Credentials ( task Credentials * Task IAMRole Credentials ) error { manager . task Credentials Lock . Lock ( ) defer manager . task Credentials Lock . Unlock ( ) credentials : = task Credentials . IAMRole Credentials } } manager . id To Task Credentials [ credentials . Credentials ID ] = Task IAMRole Credentials { ARN : task Credentials . ARN , IAMRole Credentials : task Credentials . Get IAMRole Credentials ( ) , } return nil } 
func ( manager * credentials Manager ) Get Task Credentials ( id string ) ( Task IAMRole Credentials , bool ) { manager . task Credentials Lock . RLock ( ) defer manager . task Credentials Lock . RUnlock ( ) task Credentials , ok : = manager . id To Task Credentials [ id ] if ! ok { return Task IAMRole Credentials { } , ok } return Task IAMRole Credentials { ARN : task Credentials . ARN , IAMRole Credentials : task Credentials . Get IAMRole Credentials ( ) , } , ok } 
func ( manager * credentials Manager ) Remove Credentials ( id string ) { manager . task Credentials Lock . Lock ( ) defer manager . task Credentials Lock . Unlock ( ) delete ( manager . id To Task Credentials , id ) } 
func verify Response Field Names ( expected Fields [ ] string , response Body [ ] byte , response Name string ) error { var response Map map [ string ] json . Raw Message if err : = json . Unmarshal ( response Body , & response Map ) ; err ! = nil { fmt . Errorf ( " " , response Name ) } for _ , field : = range expected Fields { if _ , ok : = response Map [ field ] ; ! ok { return fmt . Errorf ( " " , field , response Name ) } } return nil } 
func match Without Order ( a 1 , a 2 [ ] string ) bool { if len ( a 1 ) ! = len ( a 2 ) { return false } m : = make ( map [ string ] bool ) for _ , x : = range a 1 { m [ x ] = true } for _ , y : = range a 2 { if _ , ok : = m [ y ] ; ! ok { return false } } return true } 
func ( m * Mock OS ) Getpid ( ) int { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( int ) return ret 0 } 
func ( mr * Mock OSMock Recorder ) Getpid ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock OS ) ( nil ) . Getpid ) ) } 
func Run ( arguments [ ] string ) int { defer log . Flush ( ) parsed Args , err : = args . New ( arguments ) if err ! = nil { return exitcodes . Exit Terminal } if * parsed Args . License { return print License ( ) } else if * parsed Args . Version { return version . Print Version ( ) } logger . Set Level ( * parsed Args . Log Level ) if err ! = nil { } switch { case * parsed Args . ECSAttributes : case * parsed Args . Windows Service : default : } } 
func App Mesh From ACS ( proxy Config * ecsacs . Proxy Configuration ) ( * App Mesh , error ) { if * proxy Config . Type ! = app Mesh { return nil , fmt . Errorf ( " " ) } return & App Mesh { Container Name : aws . String Value ( proxy Config . Container Name ) , Ignored UID : aws . String Value ( proxy Config . Properties [ ignored UID ] ) , Ignored GID : aws . String Value ( proxy Config . Properties [ ignored GID ] ) , Proxy Ingress Port : aws . String Value ( proxy Config . Properties [ proxy Ingress Port ] ) , Proxy Egress Port : aws . String Value ( proxy Config . Properties [ proxy Egress Port ] ) , App Ports : build App Ports ( proxy Config ) , Egress Ignored IPs : build Egress Ignored IPs ( proxy Config ) , Egress Ignored Ports : build Egress Ignored Ports ( proxy Config ) , } , nil } 
func build App Ports ( proxy Config * ecsacs . Proxy Configuration ) [ ] string { var input App Ports [ ] string if proxy Config . Properties [ app Ports ] ! = nil { input App Ports = strings . Split ( * proxy Config . Properties [ app Ports ] , splitter ) } return input App Ports } 
func build Egress Ignored IPs ( proxy Config * ecsacs . Proxy Configuration ) [ ] string { var input Egress Ignored IPs [ ] string if proxy Config . Properties [ egress Ignored IPs ] ! = nil { input Egress Ignored IPs = strings . Split ( * proxy Config . Properties [ egress Ignored IPs ] , splitter ) } } 
func build Egress Ignored Ports ( proxy Config * ecsacs . Proxy Configuration ) [ ] string { var input Egress Ignored Ports [ ] string if proxy Config . Properties [ egress Ignored Ports ] ! = nil { input Egress Ignored Ports = strings . Split ( * proxy Config . Properties [ egress Ignored Ports ] , splitter ) } return input Egress Ignored Ports } 
func append Default Egress Ignored IPs ( egress Ignored IPs [ ] string ) [ ] string { has Task Metadata Endpoint IP : = false has Instance Metadata Endpoint IP : = false for _ , egress Ignored IP : = range egress Ignored IPs { if strings . Trim Space ( egress Ignored IP ) = = task Metadata Endpoint IP { has Task Metadata Endpoint IP = true } if strings . Trim Space ( egress Ignored IP ) = = instance Metadata Endpoint IP { has Instance Metadata Endpoint IP = true } } if ! has Task Metadata Endpoint IP { egress Ignored IPs = append ( egress Ignored IPs , task Metadata Endpoint IP ) } if ! has Instance Metadata Endpoint IP { egress Ignored IPs = append ( egress Ignored IPs , instance Metadata Endpoint IP ) } return egress Ignored IPs } 
func Is Instance Type Changed Error ( err error ) bool { if awserr , ok : = err . ( awserr . Error ) ; ok { return strings . Contains ( awserr . Message ( ) , Instance Type Changed Error Message ) } return false } 
func ( err * Default Named Error ) Error ( ) string { if err . Name = = " " { return " " + err . Err } return err . Name + " " + err . Err } 
func New Named Error ( err error ) * Default Named Error { if named Err , ok : = err . ( Named Error ) ; ok { return & Default Named Error { Err : named Err . Error ( ) , Name : named Err . Error Name ( ) } } return & Default Named Error { Err : err . Error ( ) } } 
func ( err * Resource Init Error ) Error ( ) string { return fmt . Sprintf ( " " , err . task ARN , err . orig Err ) } 
func ( u * Not Marshallable WSRequest ) Error ( ) string { ret : = " " if u . Type ! = " " { ret + = " " + u . Type + " " } return ret + " " + u . Err . Error ( ) } 
func ( task * Task ) Build Cgroup Root ( ) ( string , error ) { task ID , err : = task . Get ID ( ) if err ! = nil { return " " , errors . Wrapf ( err , " " , task . Arn ) } return filepath . Join ( config . Default Task Cgroup Prefix , task ID ) , nil } 
func ( task * Task ) Build Linux Resource Spec ( ) ( specs . Linux Resources , error ) { linux Resource Spec : = specs . Linux Resources { } if err ! = nil { return specs . Linux Resources { } , err } linux Resource Spec . CPU = & linux CPUSpec } else { linux CPUSpec : = task . build Implicit Linux CPUSpec ( ) linux Resource Spec . CPU = & linux CPUSpec } if err ! = nil { return specs . Linux Resources { } , err } linux Resource Spec . Memory = & linux Memory Spec } return linux Resource Spec , nil } 
func ( task * Task ) build Explicit Linux CPUSpec ( ) ( specs . Linux CPU , error ) { if task . CPU > max Task VCPULimit { return specs . Linux CPU { } , errors . Errorf ( " " , task . CPU , max Task VCPULimit ) } task CPUPeriod : = uint 6 4 ( default CPUPeriod / time . Microsecond ) task CPUQuota : = int 6 4 ( task . CPU * float 6 4 ( task CPUPeriod ) ) } 
func ( task * Task ) build Implicit Linux CPUSpec ( ) specs . Linux CPU { for _ , container : = range task . Containers { if container . CPU > 0 { task CPUShares + = uint 6 4 ( container . CPU ) } } } return specs . Linux CPU { Shares : & task CPUShares , } } 
func ( task * Task ) build Linux Memory Spec ( ) ( specs . Linux Memory , error ) { if container Memory Limit > task . Memory { return specs . Linux Memory { } , errors . Errorf ( " " , container Memory Limit , task . Memory ) } } return specs . Linux Memory { Limit : & memory Bytes , } , nil } 
func ( task * Task ) platform Host Config Override ( host Config * dockercontainer . Host Config ) error { } 
func ( task * Task ) override Cgroup Parent ( host Config * dockercontainer . Host Config ) error { task . lock . RLock ( ) defer task . lock . RUnlock ( ) if task . Memory CPULimits Enabled { cgroup Root , err : = task . Build Cgroup Root ( ) if err ! = nil { return errors . Wrapf ( err , " " , task . Arn ) } host Config . Cgroup Parent = cgroup Root } return nil } 
func Get MACAddress ( ctx context . Context , timeout time . Duration , dev string , netlink Client netlinkwrapper . Net Link ) ( string , error ) { retriever : = & mac Address Retriever { dev : dev , netlink Client : netlink Client , ctx : ctx , timeout : timeout , } return retriever . retrieve ( ) } 
func ( retriever * mac Address Retriever ) retrieve ( ) ( string , error ) { backoff : = retry . New Exponential Backoff ( mac Address Backoff Min , mac Address Backoff Max , mac Address Backoff Jitter , mac Address Backoff Multiple ) ctx , cancel : = context . With Timeout ( retriever . ctx , retriever . timeout ) defer cancel ( ) err : = retry . Retry With Backoff Ctx ( ctx , backoff , func ( ) error { ret Err : = retriever . retrieve Once ( ) if ret Err ! = nil { seelog . Warnf ( " " , retriever . dev , ret Err ) return ret Err } if retriever . mac Address = = " " { seelog . Debugf ( " " , retriever . dev ) } return nil } ) if err ! = nil { return " " , err } } return retriever . mac Address , nil } 
func ( retriever * mac Address Retriever ) retrieve Once ( ) error { dev : = filepath . Base ( retriever . dev ) link , err : = retriever . netlink Client . Link By Name ( dev ) if err ! = nil { return apierrors . New Retriable Error ( apierrors . New Retriable ( false ) , err ) } retriever . mac Address = link . Attrs ( ) . Hardware Addr . String ( ) return nil } 
func Is Valid Network Device ( device Path string ) bool { split Dev Link : = strings . Split N ( device Path , " " , 2 ) if len ( split Dev Link ) ! = 2 { seelog . Warnf ( " " , device Path ) return false } if strings . Has Prefix ( split Dev Link [ 1 ] , pci Device Prefix ) | | strings . Has Prefix ( split Dev Link [ 1 ] , vif Device Prefix ) { return true } if strings . Has Prefix ( split Dev Link [ 1 ] , virtual Device Prefix ) { return false } return false } 
func ( r * event Log Receiver ) Receive Message ( message string , level seelog . Log Level , context seelog . Log Context Interface ) error { switch level { case seelog . Debug Lvl , seelog . Info Lvl : return event Log . Info ( event Log ID , message ) case seelog . Warn Lvl : return event Log . Warning ( event Log ID , message ) case seelog . Error Lvl , seelog . Critical Lvl : return event Log . Error ( event Log ID , message ) } return nil } 
func ( client * ecr Client ) Get Authorization Token ( registry Id string ) ( * ecrapi . Authorization Data , error ) { log . Debugf ( " " , registry Id ) output , err : = client . sdk Client . Get Authorization Token ( & ecrapi . Get Authorization Token Input { Registry Ids : [ ] * string { aws . String ( registry Id ) } , } ) if err ! = nil { return nil , err } if len ( output . Authorization Data ) ! = 1 { return nil , fmt . Errorf ( " " , len ( output . Authorization Data ) ) } return output . Authorization Data [ 0 ] , nil } 
func New Mock Engine ( ctrl * gomock . Controller ) * Mock Engine { mock : = & Mock Engine { ctrl : ctrl } mock . recorder = & Mock Engine Mock Recorder { mock } return mock } 
func ( m * Mock Engine ) Container Docker Stats ( arg 0 , arg 1 string ) ( * types . Stats JSON , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( * types . Stats JSON ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Engine Mock Recorder ) Container Docker Stats ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Engine ) ( nil ) . Container Docker Stats ) , arg 0 , arg 1 ) } 
func ( m * Mock Engine ) Get Instance Metrics ( ) ( * ecstcs . Metrics Metadata , [ ] * ecstcs . Task Metric , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( * ecstcs . Metrics Metadata ) ret 1 , _ : = ret [ 1 ] . ( [ ] * ecstcs . Task Metric ) ret 2 , _ : = ret [ 2 ] . ( error ) return ret 0 , ret 1 , ret 2 } 
func ( mr * Mock Engine Mock Recorder ) Get Instance Metrics ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Engine ) ( nil ) . Get Instance Metrics ) ) } 
func ( m * Mock Engine ) Get Task Health Metrics ( ) ( * ecstcs . Health Metadata , [ ] * ecstcs . Task Health , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( * ecstcs . Health Metadata ) ret 1 , _ : = ret [ 1 ] . ( [ ] * ecstcs . Task Health ) ret 2 , _ : = ret [ 2 ] . ( error ) return ret 0 , ret 1 , ret 2 } 
func Retry With Backoff ( backoff Backoff , fn func ( ) error ) error { return Retry With Backoff Ctx ( context . Background ( ) , backoff , fn ) } 
func Retry With Backoff Ctx ( ctx context . Context , backoff Backoff , fn func ( ) error ) error { var err error for { select { case < - ctx . Done ( ) : return nil default : } err = fn ( ) retriable Err , is Retriable Err : = err . ( apierrors . Retriable ) if err = = nil | | ( is Retriable Err & & ! retriable Err . Retry ( ) ) { return err } _time . Sleep ( backoff . Duration ( ) ) } } 
func Retry NWith Backoff ( backoff Backoff , n int , fn func ( ) error ) error { return Retry NWith Backoff Ctx ( context . Background ( ) , backoff , n , fn ) } 
func Retry NWith Backoff Ctx ( ctx context . Context , backoff Backoff , n int , fn func ( ) error ) error { var err error Retry With Backoff Ctx ( ctx , backoff , func ( ) error { err = fn ( ) n - - if n = = 0 { } return err } ) return err } 
func Add Jitter ( duration time . Duration , jitter time . Duration ) time . Duration { var rand Jitter int 6 4 if jitter . Nanoseconds ( ) = = 0 { rand Jitter = 0 } else { rand Jitter = rand . Int 6 3n ( jitter . Nanoseconds ( ) ) } return time . Duration ( duration . Nanoseconds ( ) + rand Jitter ) } 
func License Handler ( w http . Response Writer , h * http . Request ) { text , err : = license Provider . Get Text ( ) if err ! = nil { w . Write Header ( http . Status Internal Server Error ) } else { w . Write ( [ ] byte ( text ) ) } } 
func New Mock IOUtil ( ctrl * gomock . Controller ) * Mock IOUtil { mock : = & Mock IOUtil { ctrl : ctrl } mock . recorder = & Mock IOUtil Mock Recorder { mock } return mock } 
func ( m * Mock IOUtil ) Temp File ( arg 0 , arg 1 string ) ( oswrapper . File , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( oswrapper . File ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock IOUtil ) Write File ( arg 0 string , arg 1 [ ] byte , arg 2 os . File Mode ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 , arg 2 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock IOUtil Mock Recorder ) Write File ( arg 0 , arg 1 , arg 2 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock IOUtil ) ( nil ) . Write File ) , arg 0 , arg 1 , arg 2 ) } 
func ( c * Client Impl ) Describe ECSTags For Instance ( instance ID string ) ( [ ] * ecs . Tag , error ) { describe Tags Input : = ec 2sdk . Describe Tags Input { Filters : [ ] * ec 2sdk . Filter { { Name : aws . String ( Resource IDFilter Name ) , Values : [ ] * string { aws . String ( instance ID ) } , } , { Name : aws . String ( Resource Type Filter Name ) , Values : [ ] * string { aws . String ( Resource Type Filter Value Instance ) } , } , } , Max Results : aws . Int 6 4 ( Instance Max Tags Num ) , } res , err : = c . client . Describe Tags ( & describe Tags Input ) if err ! = nil { seelog . Criticalf ( " " , err ) return nil , err } var tags [ ] * ecs . Tag } } return tags , nil } 
func Task Container Stats Handler ( state dockerstate . Task Engine State , stats Engine stats . Engine ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Stats ) return } if container ID , ok : = utils . Get Mux Value From Request ( r , stats Container IDMux Name ) ; ok { seelog . Infof ( " " , container ID ) Write Container Stats Response ( w , task ARN , container ID , stats Engine ) return } seelog . Infof ( " " , task ARN ) Write Task Stats Response ( w , task ARN , state , stats Engine ) } } 
func Write Task Stats Response ( w http . Response Writer , task ARN string , state dockerstate . Task Engine State , stats Engine stats . Engine ) { task Stats Response , err : = New Task Stats Response ( task ARN , state , stats Engine ) if err ! = nil { seelog . Warnf ( " " , task ARN , err ) err Response JSON , _ : = json . Marshal ( " " + task ARN ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Stats ) return } response JSON , _ : = json . Marshal ( task Stats Response ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Task Stats ) } 
func Write Container Stats Response ( w http . Response Writer , task ARN string , container ID string , stats Engine stats . Engine ) { docker Stats , err : = stats Engine . Container Docker Stats ( task ARN , container ID ) if err ! = nil { err Response JSON , _ : = json . Marshal ( " " + container ID ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Container Stats ) return } response JSON , _ : = json . Marshal ( docker Stats ) utils . Write JSONTo Response ( w , http . Status OK , response JSON , utils . Request Type Container Stats ) } 
func New Task Response ( task * apitask . Task , container Map map [ string ] * apicontainer . Docker Container ) * Task Response { containers : = [ ] Container Response { } for _ , container : = range container Map { if container . Container . Is Internal ( ) { continue } container Response : = New Container Response ( container , task . Get Task ENI ( ) ) containers = append ( containers , container Response ) } known Status : = task . Get Known Status ( ) known Backend Status : = known Status . Backend Status ( ) desired Status In Agent : = task . Get Desired Status ( ) desired Status : = desired Status In Agent . Backend Status ( ) if ( known Backend Status = = " " & & desired Status ! = " " ) | | ( known Backend Status = = " " & & desired Status = = " " ) { desired Status = " " } return & Task Response { Arn : task . Arn , Desired Status : desired Status , Known Status : known Backend Status , Family : task . Family , Version : task . Version , Containers : containers , } } 
func New Container Response ( docker Container * apicontainer . Docker Container , eni * apieni . ENI ) Container Response { container : = docker Container . Container resp : = Container Response { Name : container . Name , Docker ID : docker Container . Docker ID , Docker Name : docker Container . Docker Name , } resp . Ports = New Port Bindings Response ( docker Container , eni ) resp . Volumes = New Volumes Response ( docker Container ) if eni ! = nil { resp . Networks = [ ] containermetadata . Network { { Network Mode : utils . Network Mode AWSVPC , IPv 4Addresses : eni . Get IPV 4Addresses ( ) , IPv 6Addresses : eni . Get IPV 6Addresses ( ) , } , } } return resp } 
func New Port Bindings Response ( docker Container * apicontainer . Docker Container , eni * apieni . ENI ) [ ] Port Response { container : = docker Container . Container resp : = [ ] Port Response { } bindings : = container . Get Known Port Bindings ( ) } for _ , binding : = range bindings { port : = Port Response { Container Port : binding . Container Port , Protocol : binding . Protocol . String ( ) , } if eni = = nil { port . Host Port = binding . Host Port } else { port . Host Port = port . Container Port } resp = append ( resp , port ) } return resp } 
func New Volumes Response ( docker Container * apicontainer . Docker Container ) [ ] Volume Response { container : = docker Container . Container var resp [ ] Volume Response volumes : = container . Get Volumes ( ) for _ , volume : = range volumes { vol Resp : = Volume Response { Docker Name : volume . Name , Source : volume . Source , Destination : volume . Destination , } resp = append ( resp , vol Resp ) } return resp } 
func New Tasks Response ( state dockerstate . Task Engine State ) * Tasks Response { all Tasks : = state . All Tasks ( ) task Responses : = make ( [ ] * Task Response , len ( all Tasks ) ) for ndx , task : = range all Tasks { container Map , _ : = state . Container Map By Arn ( task . Arn ) task Responses [ ndx ] = New Task Response ( task , container Map ) } return & Tasks Response { Tasks : task Responses } } 
func New Publish Metrics Request ( metadata * Metrics Metadata , task Metrics [ ] * Task Metric ) * Publish Metrics Request { return & Publish Metrics Request { Metadata : metadata , Task Metrics : task Metrics , Timestamp : aws . Time ( time . Now ( ) ) , } } 
func New Publish Health Metrics Request ( metadata * Health Metadata , health Metrics [ ] * Task Health ) * Publish Health Request { return & Publish Health Request { Metadata : metadata , Tasks : health Metrics , Timestamp : aws . Time ( time . Now ( ) ) , } } 
func ( buffer * Infinite Buffer ) Start Listening ( ctx context . Context , event Chan < - chan events . Message ) { for { select { go buffer . Copy Events ( & event ) } return case event : = < - event Chan : go buffer . Copy Events ( & event ) } } } 
func ( buffer * Infinite Buffer ) Copy Events ( event * events . Message ) { if event . ID = = " " | | event . Type ! = container Type Event { return } defer buffer . lock . Unlock ( ) buffer . events = append ( buffer . events , event ) } return } } } 
func ( buffer * Infinite Buffer ) Consume ( in chan < - * events . Message ) { for { buffer . lock . Lock ( ) if len ( buffer . events ) = = 0 { buffer . wait For Event . Add ( 1 ) buffer . lock . Unlock ( ) buffer . wait For Event . Wait ( ) } else { event : = buffer . events [ 0 ] buffer . events = buffer . events [ 1 : ] buffer . lock . Unlock ( ) } } } 
func Container Stats Handler ( state dockerstate . Task Engine State , stats Engine stats . Engine ) func ( http . Response Writer , * http . Request ) { return func ( w http . Response Writer , r * http . Request ) { task ARN , err : = get Task ARNBy Request ( r , state ) if err ! = nil { err Response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , err Response JSON , utils . Request Type Task Stats ) return } container ID , err : = get Container IDBy Request ( r , state ) if err ! = nil { response JSON , _ : = json . Marshal ( fmt . Sprintf ( " " , err . Error ( ) ) ) utils . Write JSONTo Response ( w , http . Status Bad Request , response JSON , utils . Request Type Container Stats ) return } seelog . Infof ( " " , container ID ) } } 
func New Metrics Client ( api APIType , registry * prometheus . Registry ) Metrics Client { switch api { case Docker API : return New Generic Metrics Client ( Docker Subsystem , registry ) case Task Engine : return New Generic Metrics Client ( Task Engine Subsystem , registry ) case State Manager : return New Generic Metrics Client ( State Manager Subsystem , registry ) case ECSClient : return New Generic Metrics Client ( ECSClient Subsystem , registry ) default : seelog . Error ( " " ) return nil } } 
func New Mock ECRSDK ( ctrl * gomock . Controller ) * Mock ECRSDK { mock : = & Mock ECRSDK { ctrl : ctrl } mock . recorder = & Mock ECRSDKMock Recorder { mock } return mock } 
func ( m * Mock ECRSDK ) Get Authorization Token ( arg 0 * ecr 0 . Get Authorization Token Input ) ( * ecr 0 . Get Authorization Token Output , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecr 0 . Get Authorization Token Output ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECRSDKMock Recorder ) Get Authorization Token ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECRSDK ) ( nil ) . Get Authorization Token ) , arg 0 ) } 
func New Mock ECRFactory ( ctrl * gomock . Controller ) * Mock ECRFactory { mock : = & Mock ECRFactory { ctrl : ctrl } mock . recorder = & Mock ECRFactory Mock Recorder { mock } return mock } 
func ( m * Mock ECRFactory ) Get Client ( arg 0 * container . ECRAuth Data ) ( ecr . ECRClient , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( ecr . ECRClient ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECRFactory Mock Recorder ) Get Client ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECRFactory ) ( nil ) . Get Client ) , arg 0 ) } 
func New Mock ECRClient ( ctrl * gomock . Controller ) * Mock ECRClient { mock : = & Mock ECRClient { ctrl : ctrl } mock . recorder = & Mock ECRClient Mock Recorder { mock } return mock } 
func ( m * Mock ECRClient ) Get Authorization Token ( arg 0 string ) ( * ecr 0 . Authorization Data , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * ecr 0 . Authorization Data ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock ECRClient Mock Recorder ) Get Authorization Token ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock ECRClient ) ( nil ) . Get Authorization Token ) , arg 0 ) } 
func Get Credentials Event Type ( role Type string ) string { switch role Type { case credentials . Application Role Type : return get Credentials Event Type case credentials . Execution Role Type : return get Credentials Task Execution Event Type default : return get Credentials Invalid Role Type Event Type } } 
func New Mock GPUManager ( ctrl * gomock . Controller ) * Mock GPUManager { mock : = & Mock GPUManager { ctrl : ctrl } mock . recorder = & Mock GPUManager Mock Recorder { mock } return mock } 
func ( m * Mock GPUManager ) Get Devices ( ) [ ] * ecs . Platform Device { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] * ecs . Platform Device ) return ret 0 } 
func ( m * Mock GPUManager ) Get GPUIDs Unsafe ( ) [ ] string { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] string ) return ret 0 } 
func ( m * Mock GPUManager ) Initialize ( ) error { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock GPUManager Mock Recorder ) Set Devices ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock GPUManager ) ( nil ) . Set Devices ) ) } 
func ( m * Mock GPUManager ) Set Driver Version ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( mr * Mock GPUManager Mock Recorder ) Set Driver Version ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock GPUManager ) ( nil ) . Set Driver Version ) , arg 0 ) } 
func ( m * Mock GPUManager ) Set GPUIDs ( arg 0 [ ] string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func ( m * Mock GPUManager ) Set Runtime Version ( arg 0 string ) { m . ctrl . Call ( m , " " , arg 0 ) } 
func New Mock Round Tripper ( ctrl * gomock . Controller ) * Mock Round Tripper { mock : = & Mock Round Tripper { ctrl : ctrl } mock . recorder = & Mock Round Tripper Mock Recorder { mock } return mock } 
func ( m * Mock Round Tripper ) Round Trip ( arg 0 * http . Request ) ( * http . Response , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( * http . Response ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Round Tripper Mock Recorder ) Round Trip ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Round Tripper ) ( nil ) . Round Trip ) , arg 0 ) } 
func New Mock Net Link ( ctrl * gomock . Controller ) * Mock Net Link { mock : = & Mock Net Link { ctrl : ctrl } mock . recorder = & Mock Net Link Mock Recorder { mock } return mock } 
func ( m * Mock Net Link ) Link By Name ( arg 0 string ) ( netlink . Link , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 ) ret 0 , _ : = ret [ 0 ] . ( netlink . Link ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Net Link Mock Recorder ) Link By Name ( arg 0 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Net Link ) ( nil ) . Link By Name ) , arg 0 ) } 
func ( m * Mock Net Link ) Link List ( ) ( [ ] netlink . Link , error ) { ret : = m . ctrl . Call ( m , " " ) ret 0 , _ : = ret [ 0 ] . ( [ ] netlink . Link ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( mr * Mock Net Link Mock Recorder ) Link List ( ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock Net Link ) ( nil ) . Link List ) ) } 
func New Mock CNI ( ctrl * gomock . Controller ) * Mock CNI { mock : = & Mock CNI { ctrl : ctrl } mock . recorder = & Mock CNIMock Recorder { mock } return mock } 
func ( m * Mock CNI ) Add Network ( arg 0 * libcni . Network Config , arg 1 * libcni . Runtime Conf ) ( types . Result , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Result ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock CNI ) Add Network List ( arg 0 * libcni . Network Config List , arg 1 * libcni . Runtime Conf ) ( types . Result , error ) { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( types . Result ) ret 1 , _ : = ret [ 1 ] . ( error ) return ret 0 , ret 1 } 
func ( m * Mock CNI ) Del Network ( arg 0 * libcni . Network Config , arg 1 * libcni . Runtime Conf ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func ( mr * Mock CNIMock Recorder ) Del Network ( arg 0 , arg 1 interface { } ) * gomock . Call { return mr . mock . ctrl . Record Call With Method Type ( mr . mock , " " , reflect . Type Of ( ( * Mock CNI ) ( nil ) . Del Network ) , arg 0 , arg 1 ) } 
func ( m * Mock CNI ) Del Network List ( arg 0 * libcni . Network Config List , arg 1 * libcni . Runtime Conf ) error { ret : = m . ctrl . Call ( m , " " , arg 0 , arg 1 ) ret 0 , _ : = ret [ 0 ] . ( error ) return ret 0 } 
func New LRUCache ( size int , ttl time . Duration ) Cache { lru : = & lru Cache { size : size , ttl : ttl , cache : make ( map [ string ] * entry ) , evict List : list . New ( ) , } return lru } 
func ( lru * lru Cache ) Get ( key string ) ( Value , bool ) { lru . Lock ( ) defer lru . Unlock ( ) entry , ok : = lru . cache [ key ] if ! ok { return nil , false } ok = lru . evict Stale ( entry , key ) if ! ok { return nil , false } lru . update Accessed ( key ) return entry . value , true } 
func ( lru * lru Cache ) Set ( key string , value Value ) { lru . Lock ( ) defer lru . Unlock ( ) lru . cache [ key ] = & entry { value : value , added : time . Now ( ) } lru . evict List . Push Back ( key ) lru . purge Size ( ) } 
func ( lru * lru Cache ) Delete ( key string ) { lru . Lock ( ) defer lru . Unlock ( ) lru . remove From Evict List ( key ) delete ( lru . cache , key ) } 
func ( eni * ENIAttachment ) Start Timer ( timeout Func func ( ) ) error { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) if eni . ack Timer ! = nil { } now : = time . Now ( ) duration : = eni . Expires At . Sub ( now ) if duration < = 0 { return errors . Errorf ( " " , eni . Expires At . String ( ) , now . String ( ) ) } seelog . Infof ( " " , duration . String ( ) , eni . string Unsafe ( ) ) eni . ack Timer = time . After Func ( duration , timeout Func ) return nil } 
func ( eni * ENIAttachment ) Is Sent ( ) bool { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return eni . Attach Status Sent } 
func ( eni * ENIAttachment ) Set Sent Status ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . Attach Status Sent = true } 
func ( eni * ENIAttachment ) Stop Ack Timer ( ) { eni . guard . Lock ( ) defer eni . guard . Unlock ( ) eni . ack Timer . Stop ( ) } 
func ( eni * ENIAttachment ) Has Expired ( ) bool { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return time . Now ( ) . After ( eni . Expires At ) } 
func ( eni * ENIAttachment ) String ( ) string { eni . guard . RLock ( ) defer eni . guard . RUnlock ( ) return eni . string Unsafe ( ) } 
func ( eni * ENIAttachment ) string Unsafe ( ) string { return fmt . Sprintf ( " " , eni . Task ARN , eni . Attachment ARN , eni . Attach Status Sent , eni . MACAddress , eni . Status . String ( ) , eni . Expires At . String ( ) ) } 
func Start Metrics Session ( params * Telemetry Session Params ) { ok , err : = params . is Container Health Metrics Disabled ( ) if err ! = nil { seelog . Warnf ( " " , err ) return } if ok { seelog . Warnf ( " " ) return } err = params . Stats Engine . Must Init ( params . Ctx , params . Task Engine , params . Cfg . Cluster , params . Container Instance Arn ) if err ! = nil { seelog . Warnf ( " " , err ) return } err = Start Session ( params , params . Stats Engine ) if err ! = nil { seelog . Warnf ( " " , err ) } } 
func Start Session ( params * Telemetry Session Params , stats Engine stats . Engine ) error { backoff : = retry . New Exponential Backoff ( time . Second , 1 * time . Minute , 0 . 2 , 2 ) for { tcs Error : = start Telemetry Session ( params , stats Engine ) if tcs Error = = nil | | tcs Error = = io . EOF { seelog . Info ( " " ) backoff . Reset ( ) } else { seelog . Infof ( " " , tcs Error ) params . time ( ) . Sleep ( backoff . Duration ( ) ) } } } 
func heartbeat Handler ( timer * time . Timer ) func ( * ecstcs . Heartbeat Message ) { return func ( * ecstcs . Heartbeat Message ) { seelog . Debug ( " " ) timer . Reset ( retry . Add Jitter ( default Heartbeat Timeout , default Heartbeat Jitter ) ) } } 
func ack Publish Metric Handler ( timer * time . Timer ) func ( * ecstcs . Ack Publish Metric ) { return func ( * ecstcs . Ack Publish Metric ) { seelog . Debug ( " " ) timer . Reset ( retry . Add Jitter ( default Heartbeat Timeout , default Heartbeat Jitter ) ) } } 
func ack Publish Health Metric Handler ( timer * time . Timer ) func ( * ecstcs . Ack Publish Health ) { return func ( * ecstcs . Ack Publish Health ) { seelog . Debug ( " " ) timer . Reset ( retry . Add Jitter ( default Heartbeat Timeout , default Heartbeat Jitter ) ) } } 
func any Message Handler ( client wsclient . Client Server ) func ( interface { } ) { return func ( interface { } ) { seelog . Trace ( " " ) } } } 
func format URL ( endpoint string , cluster string , container Instance string ) string { tcs URL : = endpoint if ! strings . Has Suffix ( tcs URL , " " ) { tcs URL + = " " } query : = url . Values { } query . Set ( " " , cluster ) query . Set ( " " , container Instance ) return tcs URL + " " + query . Encode ( ) } 
func ( a * Box ) Set Center Widget ( child IWidget ) { if child = = nil { C . gtk _box _set _center _widget ( a . native ( ) , nil ) } else { C . gtk _box _set _center _widget ( a . native ( ) , child . to Widget ( ) ) } } 
func ( a * Box ) Get Center Widget ( ) * Widget { w : = C . gtk _box _get _center _widget ( a . native ( ) ) if w = = nil { return nil } return & Widget { glib . Initially Unowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func ( v * Stack Switcher ) native ( ) * C . Gtk Stack Switcher { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Stack Switcher ( p ) } 
func Stack Switcher New ( ) ( * Stack Switcher , error ) { c : = C . gtk _stack _switcher _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Stack Switcher ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Stack Switcher ) Set Stack ( stack * Stack ) { C . gtk _stack _switcher _set _stack ( v . native ( ) , stack . native ( ) ) } 
func ( v * Stack Switcher ) Get Stack ( ) * Stack { c : = C . gtk _stack _switcher _get _stack ( v . native ( ) ) if c = = nil { return nil } return wrap Stack ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Combo Box ) native ( ) * C . Gtk Combo Box { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Combo Box ( p ) } 
func Combo Box New ( ) ( * Combo Box , error ) { c : = C . gtk _combo _box _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Combo Box ( obj ) , nil } 
func Combo Box New With Entry ( ) ( * Combo Box , error ) { c : = C . gtk _combo _box _new _with _entry ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Combo Box ( obj ) , nil } 
func Combo Box New With Model ( model ITree Model ) ( * Combo Box , error ) { c : = C . gtk _combo _box _new _with _model ( model . to Tree Model ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Combo Box ( obj ) , nil } 
func ( v * Combo Box ) Get Active ( ) int { c : = C . gtk _combo _box _get _active ( v . native ( ) ) return int ( c ) } 
func ( v * Combo Box ) Set Active ( index int ) { C . gtk _combo _box _set _active ( v . native ( ) , C . gint ( index ) ) } 
func ( v * Combo Box ) Get Active Iter ( ) ( * Tree Iter , error ) { var c Iter C . Gtk Tree Iter c : = C . gtk _combo _box _get _active _iter ( v . native ( ) , & c Iter ) if ! gobool ( c ) { return nil , errors . New ( " " ) } return & Tree Iter { c Iter } , nil } 
func ( v * Combo Box ) Set Active Iter ( iter * Tree Iter ) { var c Iter * C . Gtk Tree Iter if iter ! = nil { c Iter = & iter . Gtk Tree Iter } C . gtk _combo _box _set _active _iter ( v . native ( ) , c Iter ) } 
func ( v * Combo Box ) Get Active ID ( ) string { c : = C . gtk _combo _box _get _active _id ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Combo Box ) Set Active ID ( id string ) bool { cid : = C . CString ( id ) defer C . free ( unsafe . Pointer ( cid ) ) c : = C . gtk _combo _box _set _active _id ( v . native ( ) , ( * C . gchar ) ( cid ) ) return gobool ( c ) } 
func ( v * Combo Box ) Get Model ( ) ( * Tree Model , error ) { c : = C . gtk _combo _box _get _model ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Tree Model ( obj ) , nil } 
func ( v * Combo Box ) Set Model ( model ITree Model ) { var mptr * C . Gtk Tree Model if model ! = nil { mptr = model . to Tree Model ( ) } C . gtk _combo _box _set _model ( v . native ( ) , mptr ) } 
func ( v * Combo Box Text ) native ( ) * C . Gtk Combo Box Text { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Combo Box Text ( p ) } 
func Combo Box Text New ( ) ( * Combo Box Text , error ) { c : = C . gtk _combo _box _text _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Combo Box Text ( obj ) , nil } 
func Combo Box Text New With Entry ( ) ( * Combo Box Text , error ) { c : = C . gtk _combo _box _text _new _with _entry ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Combo Box Text ( obj ) , nil } 
func ( v * Combo Box Text ) Append ( id , text string ) { cid : = C . CString ( id ) ctext : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk _combo _box _text _append ( v . native ( ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * Combo Box Text ) Prepend ( id , text string ) { cid : = C . CString ( id ) ctext : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk _combo _box _text _prepend ( v . native ( ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * Combo Box Text ) Insert ( position int , id , text string ) { cid : = C . CString ( id ) ctext : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cid ) ) defer C . free ( unsafe . Pointer ( ctext ) ) C . gtk _combo _box _text _insert ( v . native ( ) , C . gint ( position ) , ( * C . gchar ) ( cid ) , ( * C . gchar ) ( ctext ) ) } 
func ( v * Combo Box Text ) Append Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _combo _box _text _append _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Combo Box Text ) Prepend Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _combo _box _text _prepend _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Combo Box Text ) Insert Text ( position int , text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _combo _box _text _insert _text ( v . native ( ) , C . gint ( position ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Combo Box Text ) Remove ( position int ) { C . gtk _combo _box _text _remove ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Combo Box Text ) Get Active Text ( ) string { c : = ( * C . char ) ( C . gtk _combo _box _text _get _active _text ( v . native ( ) ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . Go String ( c ) } 
func ( inclusive * Rectangle ) Extents To Pixels ( nearest * Rectangle ) { C . pango _extents _to _pixels ( inclusive . native ( ) , nearest . native ( ) ) } 
func ( v * Menu ) Popup At Pointer ( _ * gdk . Event ) { C . gtk _menu _popup ( v . native ( ) , nil , nil , nil , nil , C . guint ( 0 ) , C . gtk _get _current _event _time ( ) ) } 
func ( v * Application ) native ( ) * C . GApplication { if v = = nil | | v . GObject = = nil { return nil } return C . to GApplication ( unsafe . Pointer ( v . GObject ) ) } 
func Application IDIs Valid ( id string ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _application _id _is _valid ( cstr 1 ) ) } 
func Application New ( app ID string , flags Application Flags ) * Application { cstr 1 : = ( * C . gchar ) ( C . CString ( app ID ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . g _application _new ( cstr 1 , C . GApplication Flags ( flags ) ) if c = = nil { return nil } return wrap Application ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Get Application ID ( ) string { c : = C . g _application _get _application _id ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Application ) Set Application ID ( id string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _application _set _application _id ( v . native ( ) , cstr 1 ) } 
func ( v * Application ) Set Inactivity Timeout ( timeout uint ) { C . g _application _set _inactivity _timeout ( v . native ( ) , C . guint ( timeout ) ) } 
func ( v * Application ) Set Flags ( flags Application Flags ) { C . g _application _set _flags ( v . native ( ) , C . GApplication Flags ( flags ) ) } 
func ( v * Application ) Get Dbus Object Path ( ) string { c : = C . g _application _get _dbus _object _path ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Application ) Send Notification ( id string , notification * Notification ) { cstr 1 : = ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _application _send _notification ( v . native ( ) , cstr 1 , notification . native ( ) ) } 
func ( v * Application ) Withdraw Notification ( id string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _application _withdraw _notification ( v . native ( ) , cstr 1 ) } 
func Application Get Default ( ) * Application { c : = C . g _application _get _default ( ) if c = = nil { return nil } return wrap Application ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Run ( args [ ] string ) int { cargs : = C . make _strings ( C . int ( len ( args ) ) ) defer C . destroy _strings ( cargs ) for i , arg : = range args { cstr : = C . CString ( arg ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set _string ( cargs , C . int ( i ) , ( * C . char ) ( cstr ) ) } return int ( C . g _application _run ( v . native ( ) , C . int ( len ( args ) ) , cargs ) ) } 
func ( v * App Chooser ) native ( ) * C . Gtk App Chooser { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk App Chooser ( p ) } 
func ( v * App Chooser ) Get Content Type ( ) string { cstr : = C . gtk _app _chooser _get _content _type ( v . native ( ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return C . Go String ( ( * C . char ) ( cstr ) ) } 
func ( v * App Chooser Button ) native ( ) * C . Gtk App Chooser Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk App Chooser Button ( p ) } 
func App Chooser Button New ( content _type string ) ( * App Chooser Button , error ) { cstr : = C . CString ( content _type ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _app _chooser _button _new ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap App Chooser Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * App Chooser Button ) Set Active Custom Item ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _app _chooser _button _set _active _custom _item ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * App Chooser Button ) Set Show Default Item ( setting bool ) { C . gtk _app _chooser _button _set _show _default _item ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Button ) Set Show Dialog Item ( setting bool ) { C . gtk _app _chooser _button _set _show _dialog _item ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Button ) Get Heading ( ) ( string , error ) { cstr : = C . gtk _app _chooser _button _get _heading ( v . native ( ) ) if cstr = = nil { return " " , nil Ptr Err } defer C . free ( unsafe . Pointer ( cstr ) ) return C . Go String ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * App Chooser Button ) Set Heading ( heading string ) { cstr : = C . CString ( heading ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _app _chooser _button _set _heading ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * App Chooser Widget ) native ( ) * C . Gtk App Chooser Widget { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk App Chooser Widget ( p ) } 
func App Chooser Widget New ( content _type string ) ( * App Chooser Widget , error ) { cstr : = C . CString ( content _type ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _app _chooser _widget _new ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap App Chooser Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * App Chooser Widget ) Set Show Default ( setting bool ) { C . gtk _app _chooser _widget _set _show _default ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Widget ) Set Show Recommended ( setting bool ) { C . gtk _app _chooser _widget _set _show _recommended ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Widget ) Set Show Fallback ( setting bool ) { C . gtk _app _chooser _widget _set _show _fallback ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Widget ) Set Show Other ( setting bool ) { C . gtk _app _chooser _widget _set _show _other ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Widget ) Set Show All ( setting bool ) { C . gtk _app _chooser _widget _set _show _all ( v . native ( ) , gbool ( setting ) ) } 
func ( v * App Chooser Widget ) Get Default Text ( ) ( string , error ) { cstr : = C . gtk _app _chooser _widget _get _default _text ( v . native ( ) ) if cstr = = nil { return " " , nil Ptr Err } defer C . free ( unsafe . Pointer ( cstr ) ) return C . Go String ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * App Chooser Widget ) Set Default Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _app _chooser _widget _set _default _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * App Chooser Dialog ) native ( ) * C . Gtk App Chooser Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk App Chooser Dialog ( p ) } 
func App Chooser Dialog New For Content Type ( parent * Window , flags Dialog Flags , content _type string ) ( * App Chooser Dialog , error ) { cstr : = C . CString ( content _type ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _app _chooser _dialog _new _for _content _type ( parent . native ( ) , C . Gtk Dialog Flags ( flags ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap App Chooser Dialog ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * App Chooser Dialog ) Get Widget ( ) * App Chooser Widget { c : = C . gtk _app _chooser _dialog _get _widget ( v . native ( ) ) return wrap App Chooser Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * App Chooser Dialog ) Get Heading ( ) ( string , error ) { cstr : = C . gtk _app _chooser _dialog _get _heading ( v . native ( ) ) if cstr = = nil { return " " , nil Ptr Err } defer C . free ( unsafe . Pointer ( cstr ) ) return C . Go String ( ( * C . char ) ( cstr ) ) , nil } 
func ( v * App Chooser Dialog ) Set Heading ( heading string ) { cstr : = C . CString ( heading ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _app _chooser _dialog _set _heading ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Pixbuf Format ) native ( ) * C . Gdk Pixbuf Format { if v = = nil { return nil } return v . format } 
func ( f * Pixbuf Format ) Get Mime Types ( ) [ ] string { var types [ ] string c : = C . gdk _pixbuf _format _get _mime _types ( f . native ( ) ) if c = = nil { return nil } for * c ! = nil { types = append ( types , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return types } 
func ( f * Pixbuf Format ) Get Extensions ( ) [ ] string { var extensions [ ] string c : = C . gdk _pixbuf _format _get _extensions ( f . native ( ) ) if c = = nil { return nil } for * c ! = nil { extensions = append ( extensions , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return extensions } 
func ( v * Window ) Resize Grip Is Visible ( ) bool { c : = C . gtk _window _resize _grip _is _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Set Has Resize Grip ( setting bool ) { C . gtk _window _set _has _resize _grip ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Get Has Resize Grip ( ) bool { c : = C . gtk _window _get _has _resize _grip ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Reparent ( new Parent IWidget ) { C . gtk _widget _reparent ( v . native ( ) , new Parent . to Widget ( ) ) } 
func ( v * Alignment ) Get Padding ( ) ( top , bottom , left , right uint ) { var ctop , cbottom , cleft , cright C . guint C . gtk _alignment _get _padding ( v . native ( ) , & ctop , & cbottom , & cleft , & cright ) return uint ( ctop ) , uint ( cbottom ) , uint ( cleft ) , uint ( cright ) } 
func ( v * Alignment ) Set Padding ( top , bottom , left , right uint ) { C . gtk _alignment _set _padding ( v . native ( ) , C . guint ( top ) , C . guint ( bottom ) , C . guint ( left ) , C . guint ( right ) ) } 
func Alignment New ( xalign , yalign , xscale , yscale float 3 2 ) ( * Alignment , error ) { c : = C . gtk _alignment _new ( C . gfloat ( xalign ) , C . gfloat ( yalign ) , C . gfloat ( xscale ) , C . gfloat ( yscale ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Alignment ( obj ) , nil } 
func ( v * Alignment ) Set ( xalign , yalign , xscale , yscale float 3 2 ) { C . gtk _alignment _set ( v . native ( ) , C . gfloat ( xalign ) , C . gfloat ( yalign ) , C . gfloat ( xscale ) , C . gfloat ( yscale ) ) } 
func Arrow New ( arrow Type Arrow Type , shadow Type Shadow Type ) ( * Arrow , error ) { c : = C . gtk _arrow _new ( C . Gtk Arrow Type ( arrow Type ) , C . Gtk Shadow Type ( shadow Type ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Arrow ( obj ) , nil } 
func ( v * Arrow ) Set ( arrow Type Arrow Type , shadow Type Shadow Type ) { C . gtk _arrow _set ( v . native ( ) , C . Gtk Arrow Type ( arrow Type ) , C . Gtk Shadow Type ( shadow Type ) ) } 
func ( v * Button ) Set Alignment ( xalign , yalign float 3 2 ) { C . gtk _button _set _alignment ( v . native ( ) , ( C . gfloat ) ( xalign ) , ( C . gfloat ) ( yalign ) ) } 
func ( v * Button ) Get Alignment ( ) ( xalign , yalign float 3 2 ) { var x , y C . gfloat C . gtk _button _get _alignment ( v . native ( ) , & x , & y ) return float 3 2 ( x ) , float 3 2 ( y ) } 
func ( v * Container ) Set Reallocate Redraws ( needs Redraws bool ) { C . gtk _container _set _reallocate _redraws ( v . native ( ) , gbool ( needs Redraws ) ) } 
func ( v * Misc ) Get Alignment ( ) ( x Align , y Align float 3 2 ) { var x , y C . gfloat C . gtk _misc _get _alignment ( v . native ( ) , & x , & y ) return float 3 2 ( x ) , float 3 2 ( y ) } 
func ( v * Misc ) Set Alignment ( x Align , y Align float 3 2 ) { C . gtk _misc _set _alignment ( v . native ( ) , C . gfloat ( x Align ) , C . gfloat ( y Align ) ) } 
func ( v * Misc ) Get Padding ( ) ( xpad , ypad int ) { var x , y C . gint C . gtk _misc _get _padding ( v . native ( ) , & x , & y ) return int ( x ) , int ( y ) } 
func ( v * Misc ) Set Padding ( x Pad , y Pad int ) { C . gtk _misc _set _padding ( v . native ( ) , C . gint ( x Pad ) , C . gint ( y Pad ) ) } 
func ( v * Widget ) Set Double Buffered ( double Buffered bool ) { C . gtk _widget _set _double _buffered ( v . native ( ) , gbool ( double Buffered ) ) } 
func ( v * Widget ) Get Double Buffered ( ) bool { c : = C . gtk _widget _get _double _buffered ( v . native ( ) ) return gobool ( c ) } 
func ( v * Arrow ) native ( ) * C . Gtk Arrow { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Arrow ( p ) } 
func ( v * Alignment ) native ( ) * C . Gtk Alignment { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Alignment ( p ) } 
func Status Icon New ( ) ( * Status Icon , error ) { c : = C . gtk _status _icon _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Status Icon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Status Icon New From File ( filename string ) ( * Status Icon , error ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _status _icon _new _from _file ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Status Icon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Status Icon New From Icon Name ( icon Name string ) ( * Status Icon , error ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _status _icon _new _from _icon _name ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Status Icon ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Status Icon New From Pixbuf ( pixbuf * gdk . Pixbuf ) ( * Status Icon , error ) { c : = C . gtk _status _icon _new _from _pixbuf ( C . to Gdk Pixbuf ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Status Icon ( obj ) , nil } 
func ( v * Status Icon ) Set From File ( filename string ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _from _file ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Set From Icon Name ( icon Name string ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _from _icon _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Set From Pixbuf ( pixbuf * gdk . Pixbuf ) { C . gtk _status _icon _set _from _pixbuf ( v . native ( ) , C . to Gdk Pixbuf ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Status Icon ) Set Tooltip Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _tooltip _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Get Tooltip Text ( ) string { c : = C . gtk _status _icon _get _tooltip _text ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Status Icon ) Set Tooltip Markup ( markup string ) { cstr : = C . CString ( markup ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _tooltip _markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Get Tooltip Markup ( ) string { c : = C . gtk _status _icon _get _tooltip _markup ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Status Icon ) Set Has Tooltip ( has Tooltip bool ) { C . gtk _status _icon _set _has _tooltip ( v . native ( ) , gbool ( has Tooltip ) ) } 
func ( v * Status Icon ) Get Title ( ) string { c : = C . gtk _status _icon _get _title ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Status Icon ) Set Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Set Visible ( visible bool ) { C . gtk _status _icon _set _visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Status Icon ) Set Title ( title string ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Get Icon Name ( ) string { c : = C . gtk _status _icon _get _icon _name ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Menu ) Popup At Status Icon ( status Icon * Status Icon , button uint , activate Time uint 3 2 ) { C . gotk _menu _popup _at _status _icon ( v . native ( ) , status Icon . native ( ) , C . guint ( button ) , C . guint 3 2 ( activate Time ) ) } 
func ( v * Misc ) native ( ) * C . Gtk Misc { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Misc ( p ) } 
func Cairo Create Context ( cr * cairo . Context ) * Context { c : = C . pango _cairo _create _context ( cairo _context ( cr ) ) context : = new ( Context ) context . pango Context = ( * C . Pango Context ) ( c ) return context } 
func Cairo Create Layout ( cr * cairo . Context ) * Layout { c : = C . pango _cairo _create _layout ( cairo _context ( cr ) ) layout : = new ( Layout ) layout . pango Layout = ( * C . Pango Layout ) ( c ) return layout } 
func Cairo Update Layout ( cr * cairo . Context , v * Layout ) { C . pango _cairo _update _layout ( cairo _context ( cr ) , v . native ( ) ) } 
func Cairo Show Glyph String ( cr * cairo . Context , font * Font , glyphs * Glyph String ) { C . pango _cairo _show _glyph _string ( cairo _context ( cr ) , font . native ( ) , glyphs . native ( ) ) } 
func Cairo Show Glyph Item ( cr * cairo . Context , text string , glyph _item * Glyph Item ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango _cairo _show _glyph _item ( cairo _context ( cr ) , ( * C . char ) ( cstr ) , glyph _item . native ( ) ) } 
func Cairo Show Layout Line ( cr * cairo . Context , line * Layout Line ) { C . pango _cairo _show _layout _line ( cairo _context ( cr ) , line . native ( ) ) } 
func Cairo Show Layout ( cr * cairo . Context , layout * Layout ) { C . pango _cairo _show _layout ( cairo _context ( cr ) , layout . native ( ) ) } 
func Cairo Glyph String Path ( cr * cairo . Context , font * Font , glyphs * Glyph String ) { C . pango _cairo _glyph _string _path ( cairo _context ( cr ) , font . native ( ) , glyphs . native ( ) ) } 
func Cairo Layout Line Path ( cr * cairo . Context , line * Layout Line ) { C . pango _cairo _layout _line _path ( cairo _context ( cr ) , line . native ( ) ) } 
func Cairo Layout Path ( cr * cairo . Context , layout * Layout ) { C . pango _cairo _layout _path ( cairo _context ( cr ) , layout . native ( ) ) } 
func Cairo Error Underline Path ( cr * cairo . Context , x , y , width , height float 6 4 ) { C . pango _cairo _error _underline _path ( cairo _context ( cr ) , C . double ( x ) , C . double ( y ) , C . double ( width ) , C . double ( height ) ) } 
func ( v * Application Window ) native ( ) * C . Gtk Application Window { if v = = nil | | v . Window . GObject = = nil { } p : = unsafe . Pointer ( v . Window . GObject ) return C . to Gtk Application Window ( p ) } 
func Application Window New ( app * Application ) ( * Application Window , error ) { c : = C . gtk _application _window _new ( app . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Application Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Application Window ) Set Show Menubar ( b bool ) { C . gtk _application _window _set _show _menubar ( v . native ( ) , gbool ( b ) ) } 
func ( v * Widget ) Is Visible ( ) bool { c : = C . gtk _widget _is _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Opacity ( opacity float 6 4 ) { C . gtk _widget _set _opacity ( v . native ( ) , C . double ( opacity ) ) } 
func ( v * Widget ) Get Opacity ( ) float 6 4 { c : = C . gtk _widget _get _opacity ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Widget ) Get Frame Clock ( ) * gdk . Frame Clock { c : = C . gtk _widget _get _frame _clock ( v . native ( ) ) return gdk . Wrap Frame Clock ( unsafe . Pointer ( c ) ) } 
func ( v * Widget ) Add Tick Callback ( fn Tick Callback , user Data uintptr ) int { tick Callback Registry . Lock ( ) id : = tick Callback Registry . next tick Callback Registry . next + + tick Callback Registry . m [ id ] = tick Callback Data { fn : fn , user Data : user Data } tick Callback Registry . Unlock ( ) return int ( C . _gtk _widget _add _tick _callback ( v . native ( ) , C . gpointer ( uintptr ( id ) ) ) ) } 
func ( v * Widget ) Remove Tick Callback ( id int ) { C . gtk _widget _remove _tick _callback ( v . native ( ) , C . guint ( id ) ) } 
func go List Box Filter Funcs ( row * C . Gtk List Box Row , user Data C . gpointer ) C . gboolean { id : = int ( uintptr ( user Data ) ) list Box Filter Func Registry . Lock ( ) r : = list Box Filter Func Registry . m [ id ] return gbool ( r . fn ( wrap List Box Row ( glib . Take ( unsafe . Pointer ( row ) ) ) , r . user Data ) ) } 
func ( v * Variant ) To GVariant ( ) * C . GVariant { if v = = nil { return nil } return v . native ( ) } 
func ( v * Variant ) native ( ) * C . GVariant { if v = = nil | | v . GVariant = = nil { return nil } return v . GVariant } 
func ( v * Variant ) Type String ( ) string { } 
func ( v * Variant ) Get String ( ) string { var len C . gsize gc : = C . g _variant _get _string ( v . native ( ) , & len ) defer C . g _free ( C . gpointer ( gc ) ) return C . Go String N ( ( * C . char ) ( gc ) , ( C . int ) ( len ) ) } 
func ( v * Variant ) Get Strv ( ) [ ] string { gstrv : = C . g _variant _get _strv ( v . native ( ) , nil ) defer C . g _free ( C . gpointer ( gstrv ) ) var strs [ ] string for * c ! = nil { strs = append ( strs , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return strs } 
func ( v * Variant ) Get Int ( ) ( int 6 4 , error ) { t : = v . Type ( ) . String ( ) var i int 6 4 switch t { case " " : i = int 6 4 ( C . g _variant _get _byte ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _int 1 6 ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _uint 1 6 ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _int 3 2 ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _uint 3 2 ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _int 6 4 ( v . native ( ) ) ) case " " : i = int 6 4 ( C . g _variant _get _uint 6 4 ( v . native ( ) ) ) default : return 0 , fmt . Errorf ( " " , t ) } return i , nil } 
func ( v * Variant ) Is Type ( t * Variant Type ) bool { return gobool ( C . g _variant _is _of _type ( v . native ( ) , t . native ( ) ) ) } 
func ( v * Variant ) String ( ) string { gc : = C . g _variant _print ( v . native ( ) , gbool ( false ) ) defer C . g _free ( C . gpointer ( gc ) ) return C . Go String ( ( * C . char ) ( gc ) ) } 
func ( v * Variant ) Annotated String ( ) string { gc : = C . g _variant _print ( v . native ( ) , gbool ( true ) ) defer C . g _free ( C . gpointer ( gc ) ) return C . Go String ( ( * C . char ) ( gc ) ) } 
func ( p * Popover ) Set Default Widget ( widget IWidget ) { C . gtk _popover _set _default _widget ( p . native ( ) , widget . to Widget ( ) ) } 
func ( p * Popover ) Get Default Widget ( ) * Widget { w : = C . gtk _popover _get _default _widget ( p . native ( ) ) if w = = nil { return nil } return & Widget { glib . Initially Unowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func Layout New ( context * Context ) * Layout { c : = C . pango _layout _new ( context . native ( ) ) layout : = new ( Layout ) layout . pango Layout = ( * C . Pango Layout ) ( c ) return layout } 
func ( v * Layout ) Copy ( ) * Layout { c : = C . pango _layout _copy ( v . native ( ) ) layout : = new ( Layout ) layout . pango Layout = ( * C . Pango Layout ) ( c ) return layout } 
func ( v * Layout ) Get Context ( ) * Context { c : = C . pango _layout _get _context ( v . native ( ) ) context : = new ( Context ) context . pango Context = ( * C . Pango Context ) ( c ) return context } 
func ( v * Layout ) Set Attributes ( attrs * Attr List ) { C . pango _layout _set _attributes ( v . native ( ) , attrs . native ( ) ) } 
func ( v * Layout ) Get Attributes ( ) * Attr List { c : = C . pango _layout _get _attributes ( v . native ( ) ) attr List : = new ( Attr List ) attr List . pango Attr List = ( * C . Pango Attr List ) ( c ) return attr List } 
func ( v * Layout ) Set Text ( text string , length int ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango _layout _set _text ( v . native ( ) , ( * C . char ) ( cstr ) , ( C . int ) ( length ) ) } 
func ( v * Layout ) Get Text ( ) string { c : = C . pango _layout _get _text ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Layout ) Get Character Count ( ) int { c : = C . pango _layout _get _character _count ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) Set Markup ( text string , length int ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango _layout _set _markup ( v . native ( ) , ( * C . char ) ( cstr ) , ( C . int ) ( length ) ) } 
func ( v * Layout ) Set Font Description ( desc * Font Description ) { C . pango _layout _set _font _description ( v . native ( ) , desc . native ( ) ) } 
func ( v * Layout ) Get Font Description ( ) * Font Description { c : = C . pango _layout _get _font _description ( v . native ( ) ) desc : = new ( Font Description ) desc . pango Font Description = ( * C . Pango Font Description ) ( c ) return desc } 
func ( v * Layout ) Set Width ( width int ) { C . pango _layout _set _width ( v . native ( ) , C . int ( width ) ) } 
func ( v * Layout ) Get Width ( ) int { c : = C . pango _layout _get _width ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) Set Height ( width int ) { C . pango _layout _set _height ( v . native ( ) , C . int ( width ) ) } 
func ( v * Layout ) Get Height ( ) int { c : = C . pango _layout _get _height ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) Set Wrap ( wrap Wrap Mode ) { C . pango _layout _set _wrap ( v . native ( ) , C . Pango Wrap Mode ( wrap ) ) } 
func ( v * Layout ) Get Wrap ( ) Wrap Mode { c : = C . pango _layout _get _wrap ( v . native ( ) ) return Wrap Mode ( c ) } 
func ( v * Layout ) Is Wrapped ( ) bool { c : = C . pango _layout _is _wrapped ( v . native ( ) ) return gobool ( c ) } 
func ( v * Layout ) Set Indent ( indent int ) { C . pango _layout _set _indent ( v . native ( ) , C . int ( indent ) ) } 
func ( v * Layout ) Get Indent ( ) int { c : = C . pango _layout _get _indent ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) Get Size ( ) ( int , int ) { var w , h C . int C . pango _layout _get _size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func Button New From Stock ( stock Stock ) ( * Button , error ) { cstr : = C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _button _new _from _stock ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Button ) Set Use Stock ( use Stock bool ) { C . gtk _button _set _use _stock ( v . native ( ) , gbool ( use Stock ) ) } 
func ( v * Button ) Get Use Stock ( ) bool { c : = C . gtk _button _get _use _stock ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) Get Icon Stock ( icon Pos Entry Icon Position ) ( string , error ) { c : = C . gtk _entry _get _icon _stock ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Entry ) Set Icon From Stock ( icon Pos Entry Icon Position , stock ID string ) { cstr : = C . CString ( stock ID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _icon _from _stock ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , ( * C . gchar ) ( cstr ) ) } 
func Image New From Stock ( stock Stock , size Icon Size ) ( * Image , error ) { cstr : = C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _image _new _from _stock ( ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) if c = = nil { return nil , nil Ptr Err } return wrap Image ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Image ) Set From Stock ( stock Stock , size Icon Size ) { cstr : = C . CString ( string ( stock ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _image _set _from _stock ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) } 
func Status Icon New From Stock ( stock Id string ) ( * Status Icon , error ) { cstr : = C . CString ( stock Id ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _status _icon _new _from _file ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Status Icon ( obj ) , nil } 
func ( v * Status Icon ) Set From Stock ( stock ID string ) { cstr : = C . CString ( stock ID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _status _icon _set _from _stock ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Status Icon ) Get Stock ( ) string { c : = C . gtk _status _icon _get _stock ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Container ) Get Focus Chain ( ) ( [ ] * Widget , bool ) { var cwlist * C . GList c : = C . gtk _container _get _focus _chain ( v . native ( ) , & cwlist ) var widgets [ ] * Widget wlist : = glib . Wrap List ( uintptr ( unsafe . Pointer ( cwlist ) ) ) for ; wlist . Data ( ) ! = nil ; wlist = wlist . Next ( ) { widgets = append ( widgets , wrap Widget ( glib . Take ( wlist . Data ( ) . ( unsafe . Pointer ) ) ) ) } return widgets , gobool ( c ) } 
func ( v * Container ) Set Focus Chain ( focusable Widgets [ ] IWidget ) { var list * glib . List for _ , w : = range focusable Widgets { data : = uintptr ( unsafe . Pointer ( w . to Widget ( ) ) ) list = list . Append ( data ) } glist : = ( * C . GList ) ( unsafe . Pointer ( list ) ) C . gtk _container _set _focus _chain ( v . native ( ) , glist ) } 
func Css Provider Get Default ( ) ( * Css Provider , error ) { c : = C . gtk _css _provider _get _default ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Css Provider ( obj ) , nil } 
func ( v * Menu Model ) native ( ) * C . GMenu Model { if v = = nil | | v . GObject = = nil { return nil } return C . to GMenu Model ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * Menu Model ) Get Item Link ( index int , link string ) * Menu Model { cstr : = ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . g _menu _model _get _item _link ( v . native ( ) , C . gint ( index ) , cstr ) if c = = nil { return nil } return wrap Menu Model ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Model ) Items Changed ( position , removed , added int ) { C . g _menu _model _items _changed ( v . native ( ) , C . gint ( position ) , C . gint ( removed ) , C . gint ( added ) ) } 
func ( m * Menu ) native ( ) * C . GMenu { if m = = nil | | m . GObject = = nil { return nil } p : = unsafe . Pointer ( m . GObject ) return C . to GMenu ( p ) } 
func Menu New ( ) * Menu { c : = C . g _menu _new ( ) if c = = nil { return nil } return wrap Menu ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) Insert ( position int , label , detailed _action string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( detailed _action ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) C . g _menu _insert ( v . native ( ) , C . gint ( position ) , cstr 1 , cstr 2 ) } 
func ( v * Menu ) Prepend ( label , detailed _action string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( detailed _action ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) C . g _menu _prepend ( v . native ( ) , cstr 1 , cstr 2 ) } 
func ( v * Menu ) Append ( label , detailed _action string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( detailed _action ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) C . g _menu _append ( v . native ( ) , cstr 1 , cstr 2 ) } 
func ( v * Menu ) Insert Item ( position int , item * Menu Item ) { C . g _menu _insert _item ( v . native ( ) , C . gint ( position ) , item . native ( ) ) } 
func ( v * Menu ) Append Item ( item * Menu Item ) { C . g _menu _append _item ( v . native ( ) , item . native ( ) ) } 
func ( v * Menu ) Prepend Item ( item * Menu Item ) { C . g _menu _prepend _item ( v . native ( ) , item . native ( ) ) } 
func ( v * Menu ) Insert Section ( position int , label string , section * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _insert _section ( v . native ( ) , C . gint ( position ) , cstr 1 , section . native ( ) ) } 
func ( v * Menu ) Prepend Section ( label string , section * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _prepend _section ( v . native ( ) , cstr 1 , section . native ( ) ) } 
func ( v * Menu ) Append Section ( label string , section * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _append _section ( v . native ( ) , cstr 1 , section . native ( ) ) } 
func ( v * Menu ) Insert Section Without Label ( position int , section * Menu Model ) { C . g _menu _insert _section ( v . native ( ) , C . gint ( position ) , nil , section . native ( ) ) } 
func ( v * Menu ) Prepend Section Without Label ( section * Menu Model ) { C . g _menu _prepend _section ( v . native ( ) , nil , section . native ( ) ) } 
func ( v * Menu ) Append Section Without Label ( section * Menu Model ) { C . g _menu _append _section ( v . native ( ) , nil , section . native ( ) ) } 
func ( v * Menu ) Insert Submenu ( position int , label string , submenu * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _insert _submenu ( v . native ( ) , C . gint ( position ) , cstr 1 , submenu . native ( ) ) } 
func ( v * Menu ) Prepend Submenu ( label string , submenu * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _prepend _submenu ( v . native ( ) , cstr 1 , submenu . native ( ) ) } 
func ( v * Menu ) Append Submenu ( label string , submenu * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _append _submenu ( v . native ( ) , cstr 1 , submenu . native ( ) ) } 
func ( v * Menu ) Remove ( position int ) { C . g _menu _remove ( v . native ( ) , C . gint ( position ) ) } 
func ( m * Menu Item ) native ( ) * C . GMenu Item { if m = = nil | | m . GObject = = nil { return nil } p : = unsafe . Pointer ( m . GObject ) return C . to GMenu Item ( p ) } 
func Menu Item New ( label , detailed _action string ) * Menu Item { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( detailed _action ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) c : = C . g _menu _item _new ( cstr 1 , cstr 2 ) if c = = nil { return nil } return wrap Menu Item ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func Menu Item New Section ( label string , section * Menu Model ) * Menu Item { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . g _menu _item _new _section ( cstr 1 , section . native ( ) ) if c = = nil { return nil } return wrap Menu Item ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func Menu Item New Submenu ( label string , submenu * Menu Model ) * Menu Item { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . g _menu _item _new _submenu ( cstr 1 , submenu . native ( ) ) if c = = nil { return nil } return wrap Menu Item ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func Menu Item New From Model ( model * Menu Model , index int ) * Menu Item { c : = C . g _menu _item _new _from _model ( model . native ( ) , C . gint ( index ) ) if c = = nil { return nil } return wrap Menu Item ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Item ) Set Label ( label string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _item _set _label ( v . native ( ) , cstr 1 ) } 
func ( v * Menu Item ) Set Detailed Action ( act string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _item _set _detailed _action ( v . native ( ) , cstr 1 ) } 
func ( v * Menu Item ) Set Section ( section * Menu Model ) { C . g _menu _item _set _section ( v . native ( ) , section . native ( ) ) } 
func ( v * Menu Item ) Set Submenu ( submenu * Menu Model ) { C . g _menu _item _set _submenu ( v . native ( ) , submenu . native ( ) ) } 
func ( v * Menu Item ) Get Link ( link string ) * Menu Model { cstr 1 : = ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . g _menu _item _get _link ( v . native ( ) , cstr 1 ) if c = = nil { return nil } return wrap Menu Model ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Item ) Set Link ( link string , model * Menu Model ) { cstr 1 : = ( * C . gchar ) ( C . CString ( link ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _menu _item _set _link ( v . native ( ) , cstr 1 , model . native ( ) ) } 
func ( v * Scrolled Window ) Set Overlay Scrolling ( scrolling bool ) { C . gtk _scrolled _window _set _overlay _scrolling ( v . native ( ) , gbool ( scrolling ) ) } 
func ( v * Paned ) Set Wide Handle ( wide bool ) { C . gtk _paned _set _wide _handle ( v . native ( ) , gbool ( wide ) ) } 
func ( v * Label ) Get XAlign ( ) float 6 4 { c : = C . gtk _label _get _xalign ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Label ) Get YAlign ( ) float 6 4 { c : = C . gtk _label _get _yalign ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Label ) Set XAlign ( n float 6 4 ) { C . gtk _label _set _xalign ( v . native ( ) , C . gfloat ( n ) ) } 
func ( v * Label ) Set YAlign ( n float 6 4 ) { C . gtk _label _set _yalign ( v . native ( ) , C . gfloat ( n ) ) } 
func ( v * Stack Sidebar ) native ( ) * C . Gtk Stack Sidebar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Stack Sidebar ( p ) } 
func Stack Sidebar New ( ) ( * Stack Sidebar , error ) { c : = C . gtk _stack _sidebar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Stack Sidebar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Overlay ) Reorder Overlay ( child IWidget , position int ) { C . gtk _overlay _reorder _overlay ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func ( v * Overlay ) Get Overlay Pass Through ( widget IWidget ) bool { c : = C . gtk _overlay _get _overlay _pass _through ( v . native ( ) , widget . to Widget ( ) ) return gobool ( c ) } 
func ( v * Overlay ) Set Overlay Pass Through ( widget IWidget , pass Through bool ) { C . gtk _overlay _set _overlay _pass _through ( v . native ( ) , widget . to Widget ( ) , gbool ( pass Through ) ) } 
func ( v * Frame Clock ) native ( ) * C . Gdk Frame Clock { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Frame Clock ( p ) } 
func ( v * Frame Clock ) Get Timings ( frame Counter int 6 4 ) ( * Frame Timings , error ) { c : = C . gdk _frame _clock _get _timings ( v . native ( ) , C . gint 6 4 ( frame Counter ) ) if c = = nil { return nil , nil Ptr Err } return wrap Frame Timings ( unsafe . Pointer ( c ) ) , nil } 
func ( v * Frame Clock ) Get Current Timings ( ) ( * Frame Timings , error ) { c : = C . gdk _frame _clock _get _current _timings ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Frame Timings ( unsafe . Pointer ( c ) ) , nil } 
func ( v * Frame Clock ) Get Refresh Info ( base Time int 6 4 ) ( int 6 4 , int 6 4 ) { var cr , cp ( * C . gint 6 4 ) defer C . free ( unsafe . Pointer ( cr ) ) ; defer C . free ( unsafe . Pointer ( cp ) ) b : = C . gint 6 4 ( base Time ) C . gdk _frame _clock _get _refresh _info ( v . native ( ) , b , cr , cp ) r , p : = int 6 4 ( * cr ) , int 6 4 ( * cp ) return r , p } 
func ( v * Frame Clock ) Request Phase ( phase Clock Phase ) { C . gdk _frame _clock _request _phase ( v . native ( ) , C . Gdk Frame Clock Phase ( phase ) ) } 
func ( v * Frame Timings ) native ( ) * C . Gdk Frame Timings { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Frame Timings ( p ) } 
func ( v * Frame Timings ) Ref ( ) { c : = C . gdk _frame _timings _ref ( v . native ( ) ) v = wrap Frame Timings ( unsafe . Pointer ( c ) ) } 
func ( v * Display ) Get NMonitors ( ) int { c : = C . gdk _display _get _n _monitors ( v . native ( ) ) return int ( c ) } 
func ( v * Display ) Get Primary Monitor ( ) ( * Monitor , error ) { c : = C . gdk _display _get _primary _monitor ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Monitor { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Monitor ) native ( ) * C . Gdk Monitor { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Monitor ( p ) } 
func ( v * Monitor ) Get Geometry ( ) * Rectangle { var rect C . Gdk Rectangle C . gdk _monitor _get _geometry ( v . native ( ) , & rect ) return Wrap Rectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * GLContext ) Set Use ES ( es int ) { C . gdk _gl _context _set _use _es ( v . native ( ) , ( C . int ) ( es ) ) } 
func ( v * Screen ) native ( ) * C . Gdk Screen { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Screen ( p ) } 
func ( v * Screen ) Get RGBAVisual ( ) ( * Visual , error ) { c : = C . gdk _screen _get _rgba _visual ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Visual { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Screen ) Get System Visual ( ) ( * Visual , error ) { c : = C . gdk _screen _get _system _visual ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Visual { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Screen ) Get Root Window ( ) ( * Window , error ) { return to Window ( C . gdk _screen _get _root _window ( v . native ( ) ) ) } 
func ( v * Screen ) Get Display ( ) ( * Display , error ) { return to Display ( C . gdk _screen _get _display ( v . native ( ) ) ) } 
func ( v * Screen ) Set Resolution ( r float 6 4 ) { C . gdk _screen _set _resolution ( v . native ( ) , C . gdouble ( r ) ) } 
func ( v * Variant Builder ) native ( ) * C . GVariant Builder { if v = = nil | | v . GVariant Builder = = nil { return nil } p : = unsafe . Pointer ( v . GVariant Builder ) return C . to GVariant Builder ( p ) } 
func ( v * Window ) Get Opacity ( ) float 6 4 { c : = C . gtk _window _get _opacity ( v . native ( ) ) return float 6 4 ( c ) } 
func ( s Status ) String ( ) string { str : = Status To String ( s ) str = strings . Replace ( str , " " , " " , 1 ) str = strings . Replace ( str , " " , " " , 0 ) return strings . To Lower ( str ) } 
func ( s Status ) To Error ( ) error { if s = = STATUS _SUCCESS { return nil } return errors . New ( s . String ( ) ) } 
func ( v * Level Bar ) native ( ) * C . Gtk Level Bar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Level Bar ( p ) } 
func Level Bar New ( ) ( * Level Bar , error ) { c : = C . gtk _level _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Level Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Level Bar New For Interval ( min _value , max _value float 6 4 ) ( * Level Bar , error ) { c : = C . gtk _level _bar _new _for _interval ( C . gdouble ( min _value ) , C . gdouble ( max _value ) ) if c = = nil { return nil , nil Ptr Err } return wrap Level Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Level Bar ) Set Mode ( m Level Bar Mode ) { C . gtk _level _bar _set _mode ( v . native ( ) , C . Gtk Level Bar Mode ( m ) ) } 
func ( v * Level Bar ) Set Value ( value float 6 4 ) { C . gtk _level _bar _set _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Level Bar ) Get Value ( ) float 6 4 { c : = C . gtk _level _bar _get _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Level Bar ) Set Min Value ( value float 6 4 ) { C . gtk _level _bar _set _min _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Level Bar ) Get Min Value ( ) float 6 4 { c : = C . gtk _level _bar _get _min _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Level Bar ) Set Max Value ( value float 6 4 ) { C . gtk _level _bar _set _max _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Level Bar ) Get Max Value ( ) float 6 4 { c : = C . gtk _level _bar _get _max _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Level Bar ) Add Offset Value ( name string , value float 6 4 ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _level _bar _add _offset _value ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) ) } 
func ( v * Level Bar ) Remove Offset Value ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _level _bar _remove _offset _value ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Level Bar ) Get Offset Value ( name string ) ( float 6 4 , bool ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var value C . gdouble c : = C . gtk _level _bar _get _offset _value ( v . native ( ) , ( * C . gchar ) ( cstr ) , & value ) return float 6 4 ( value ) , gobool ( c ) } 
func Accelerator Name ( key uint , mods gdk . Modifier Type ) string { c : = C . gtk _accelerator _name ( C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Accelerator Valid ( key uint , mods gdk . Modifier Type ) bool { return gobool ( C . gtk _accelerator _valid ( C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) ) } 
func Accelerator Parse ( acc string ) ( key uint , mods gdk . Modifier Type ) { cstr : = C . CString ( acc ) defer C . free ( unsafe . Pointer ( cstr ) ) k : = C . guint ( 0 ) m : = C . Gdk Modifier Type ( 0 ) C . gtk _accelerator _parse ( ( * C . gchar ) ( cstr ) , & k , & m ) return uint ( k ) , gdk . Modifier Type ( m ) } 
func Accelerator Get Label ( key uint , mods gdk . Modifier Type ) string { c : = C . gtk _accelerator _get _label ( C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Accel Group ) native ( ) * C . Gtk Accel Group { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Accel Group ( p ) } 
func Accel Group New ( ) ( * Accel Group , error ) { c : = C . gtk _accel _group _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Accel Group ( obj ) , nil } 
func ( v * Accel Group ) Connect ( key uint , mods gdk . Modifier Type , flags Accel Flags , f interface { } ) { closure , _ : = glib . Closure New ( f ) cl : = ( * C . struct _ _GClosure ) ( unsafe . Pointer ( closure ) ) C . gtk _accel _group _connect ( v . native ( ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) , C . Gtk Accel Flags ( flags ) , cl ) } 
func ( v * Accel Group ) Connect By Path ( path string , f interface { } ) { closure , _ : = glib . Closure New ( f ) cl : = ( * C . struct _ _GClosure ) ( unsafe . Pointer ( closure ) ) cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _group _connect _by _path ( v . native ( ) , ( * C . gchar ) ( cstr ) , cl ) } 
func ( v * Accel Group ) Disconnect ( f interface { } ) { closure , _ : = glib . Closure New ( f ) cl : = ( * C . struct _ _GClosure ) ( unsafe . Pointer ( closure ) ) C . gtk _accel _group _disconnect ( v . native ( ) , cl ) } 
func ( v * Accel Group ) Disconnect Key ( key uint , mods gdk . Modifier Type ) { C . gtk _accel _group _disconnect _key ( v . native ( ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) } 
func Accel Group From Closure ( f interface { } ) * Accel Group { closure , _ : = glib . Closure New ( f ) cl : = ( * C . struct _ _GClosure ) ( unsafe . Pointer ( closure ) ) c : = C . gtk _accel _group _from _accel _closure ( cl ) if c = = nil { return nil } return wrap Accel Group ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Accel Group ) Get Modifier Mask ( ) gdk . Modifier Type { return gdk . Modifier Type ( C . gtk _accel _group _get _modifier _mask ( v . native ( ) ) ) } 
func Accel Groups Activate ( obj * glib . Object , key uint , mods gdk . Modifier Type ) bool { return gobool ( C . gtk _accel _groups _activate ( ( * C . GObject ) ( unsafe . Pointer ( obj . Native ( ) ) ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) ) } 
func ( v * Accel Group ) Activate ( quark glib . Quark , acceleratable * glib . Object , key uint , mods gdk . Modifier Type ) bool { return gobool ( C . gtk _accel _group _activate ( v . native ( ) , C . GQuark ( quark ) , ( * C . GObject ) ( unsafe . Pointer ( acceleratable . Native ( ) ) ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) ) } 
func Accel Groups From Object ( obj * glib . Object ) * glib . SList { res : = C . gtk _accel _groups _from _object ( ( * C . GObject ) ( unsafe . Pointer ( obj . Native ( ) ) ) ) if res = = nil { return nil } return ( * glib . SList ) ( unsafe . Pointer ( res ) ) } 
func ( v * Accel Map ) native ( ) * C . Gtk Accel Map { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Accel Map ( p ) } 
func Accel Map Add Entry ( path string , key uint , mods gdk . Modifier Type ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _add _entry ( ( * C . gchar ) ( cstr ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) } 
func Accel Map Lookup Entry ( path string ) * Accel Key { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) var v * C . struct _ _Gtk Accel Key C . gtk _accel _map _lookup _entry ( ( * C . gchar ) ( cstr ) , v ) return wrap Accel Key ( v ) } 
func Accel Map Change Entry ( path string , key uint , mods gdk . Modifier Type , replace bool ) bool { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gtk _accel _map _change _entry ( ( * C . gchar ) ( cstr ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) , gbool ( replace ) ) ) } 
func Accel Map Load ( file Name string ) { cstr : = C . CString ( file Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _load ( ( * C . gchar ) ( cstr ) ) } 
func Accel Map Save ( file Name string ) { cstr : = C . CString ( file Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _save ( ( * C . gchar ) ( cstr ) ) } 
func Accel Map Add Filter ( filter string ) { cstr : = C . CString ( filter ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _add _filter ( ( * C . gchar ) ( cstr ) ) } 
func Accel Map Get ( ) * Accel Map { c : = C . gtk _accel _map _get ( ) if c = = nil { return nil } return wrap Accel Map ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func Accel Map Lock Path ( path string ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _lock _path ( ( * C . gchar ) ( cstr ) ) } 
func Accel Map Unlock Path ( path string ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _accel _map _unlock _path ( ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu ) Set Accel Group ( accel Group * Accel Group ) { C . gtk _menu _set _accel _group ( v . native ( ) , accel Group . native ( ) ) } 
func ( v * Menu ) Get Accel Group ( ) * Accel Group { c : = C . gtk _menu _get _accel _group ( v . native ( ) ) if c = = nil { return nil } return wrap Accel Group ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) Set Accel Path ( path string ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _menu _set _accel _path ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu ) Get Accel Path ( ) string { c : = C . gtk _menu _get _accel _path ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Menu Item ) Set Accel Path ( path string ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _menu _item _set _accel _path ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu Item ) Get Accel Path ( ) string { c : = C . gtk _menu _item _get _accel _path ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Widget ) Add Accelerator ( signal string , group * Accel Group , key uint , mods gdk . Modifier Type , flags Accel Flags ) { csignal : = ( * C . gchar ) ( C . CString ( signal ) ) defer C . free ( unsafe . Pointer ( csignal ) ) C . gtk _widget _add _accelerator ( v . native ( ) , csignal , group . native ( ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) , C . Gtk Accel Flags ( flags ) ) } 
func ( v * Widget ) Remove Accelerator ( group * Accel Group , key uint , mods gdk . Modifier Type ) bool { return gobool ( C . gtk _widget _remove _accelerator ( v . native ( ) , group . native ( ) , C . guint ( key ) , C . Gdk Modifier Type ( mods ) ) ) } 
func ( v * Widget ) Set Accel Path ( path string , group * Accel Group ) { cstr : = ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _widget _set _accel _path ( v . native ( ) , cstr , group . native ( ) ) } 
func ( v * Widget ) Can Activate Accel ( signal Id uint ) bool { return gobool ( C . gtk _widget _can _activate _accel ( v . native ( ) , C . guint ( signal Id ) ) ) } 
func ( v * Window ) Add Accel Group ( accel Group * Accel Group ) { C . gtk _window _add _accel _group ( v . native ( ) , accel Group . native ( ) ) } 
func ( v * Window ) Remove Accel Group ( accel Group * Accel Group ) { C . gtk _window _remove _accel _group ( v . native ( ) , accel Group . native ( ) ) } 
func ( v * List ) Data Wrapper ( fn func ( unsafe . Pointer ) interface { } ) { if v = = nil { return } v . data Wrap = fn } 
func ( v * List ) Append ( data uintptr ) * List { glist : = C . g _list _append ( v . native ( ) , C . gpointer ( data ) ) return v . wrap New Head ( glist ) } 
func ( v * List ) Prepend ( data uintptr ) * List { glist : = C . g _list _prepend ( v . native ( ) , C . gpointer ( data ) ) return v . wrap New Head ( glist ) } 
func ( v * List ) Insert ( data uintptr , position int ) * List { glist : = C . g _list _insert ( v . native ( ) , C . gpointer ( data ) , C . gint ( position ) ) return v . wrap New Head ( glist ) } 
func ( v * List ) nth Data Raw ( n uint ) unsafe . Pointer { return unsafe . Pointer ( C . g _list _nth _data ( v . native ( ) , C . guint ( n ) ) ) } 
func ( v * List ) Nth ( n uint ) * List { list : = wrap List ( C . g _list _nth ( v . native ( ) , C . guint ( n ) ) ) list . Data Wrapper ( v . data Wrap ) return list } 
func ( v * List ) Nth Data ( n uint ) interface { } { ptr : = v . nth Data Raw ( n ) if v . data Wrap ! = nil { return v . data Wrap ( ptr ) } return ptr } 
func ( v * List ) data Raw ( ) unsafe . Pointer { return unsafe . Pointer ( v . native ( ) . data ) } 
func ( v * List ) Data ( ) interface { } { ptr : = v . data Raw ( ) if v . data Wrap ! = nil { return v . data Wrap ( ptr ) } return ptr } 
func ( v * List ) Foreach ( fn func ( item interface { } ) ) { for l : = v ; l ! = nil ; l = l . Next ( ) { fn ( l . Data ( ) ) } } 
func ( v * List ) Free Full ( fn func ( item interface { } ) ) { v . Foreach ( fn ) v . Free ( ) } 
func Wrap Context ( p uintptr ) * Context { context : = new ( Context ) context . pango Context = ( * C . Pango Context ) ( unsafe . Pointer ( p ) ) return context } 
func Context New ( ) * Context { c : = C . pango _context _new ( ) context : = new ( Context ) context . pango Context = ( * C . Pango Context ) ( c ) return context } 
func ( v * Dialog ) Get Header Bar ( ) * Widget { c : = C . gtk _dialog _get _header _bar ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Entry ) Set Max Width Chars ( n Chars int ) { C . gtk _entry _set _max _width _chars ( v . native ( ) , C . gint ( n Chars ) ) } 
func ( v * Entry ) Get Max Width Chars ( ) int { c : = C . gtk _entry _get _max _width _chars ( v . native ( ) ) return int ( c ) } 
func ( v * Header Bar ) Get Decoration Layout ( ) string { c : = C . gtk _header _bar _get _decoration _layout ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Header Bar ) Set Decoration Layout ( layout string ) { cstr : = C . CString ( layout ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _header _bar _set _decoration _layout ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Header Bar ) Get Has Subtitle ( ) bool { c : = C . gtk _header _bar _get _has _subtitle ( v . native ( ) ) return gobool ( c ) } 
func ( v * Header Bar ) Set Has Subtitle ( setting bool ) { C . gtk _header _bar _set _has _subtitle ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Menu Button ) Set Popover ( popover * Popover ) { C . gtk _menu _button _set _popover ( v . native ( ) , popover . to Widget ( ) ) } 
func ( v * Menu Button ) Get Popover ( ) * Popover { c : = C . gtk _menu _button _get _popover ( v . native ( ) ) if c = = nil { return nil } return wrap Popover ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Button ) Get Use Popover ( ) bool { c : = C . gtk _menu _button _get _use _popover ( v . native ( ) ) return gobool ( c ) } 
func ( v * Menu Button ) Set Use Popover ( setting bool ) { C . gtk _menu _button _set _use _popover ( v . native ( ) , gbool ( setting ) ) } 
func Flow Box New ( ) ( * Flow Box , error ) { c : = C . gtk _flow _box _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Flow Box ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( fb * Flow Box ) Insert ( widget IWidget , position int ) { C . gtk _flow _box _insert ( fb . native ( ) , widget . to Widget ( ) , C . gint ( position ) ) } 
func ( fb * Flow Box ) Get Child At Index ( idx int ) * Flow Box Child { c : = C . gtk _flow _box _get _child _at _index ( fb . native ( ) , C . gint ( idx ) ) if c = = nil { return nil } return wrap Flow Box Child ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( fb * Flow Box ) Set HAdjustment ( adjustment * Adjustment ) { C . gtk _flow _box _set _hadjustment ( fb . native ( ) , adjustment . native ( ) ) } 
func ( fb * Flow Box ) Set VAdjustment ( adjustment * Adjustment ) { C . gtk _flow _box _set _vadjustment ( fb . native ( ) , adjustment . native ( ) ) } 
func ( fb * Flow Box ) Set Homogeneous ( homogeneous bool ) { C . gtk _flow _box _set _homogeneous ( fb . native ( ) , gbool ( homogeneous ) ) } 
func ( fb * Flow Box ) Get Homogeneous ( ) bool { c : = C . gtk _flow _box _get _homogeneous ( fb . native ( ) ) return gobool ( c ) } 
func ( fb * Flow Box ) Set Row Spacing ( spacing uint ) { C . gtk _flow _box _set _row _spacing ( fb . native ( ) , C . guint ( spacing ) ) } 
func ( fb * Flow Box ) Get Row Spacing ( ) uint { c : = C . gtk _flow _box _get _row _spacing ( fb . native ( ) ) return uint ( c ) } 
func ( fb * Flow Box ) Set Column Spacing ( spacing uint ) { C . gtk _flow _box _set _column _spacing ( fb . native ( ) , C . guint ( spacing ) ) } 
func ( fb * Flow Box ) Get Column Spacing ( ) uint { c : = C . gtk _flow _box _get _column _spacing ( fb . native ( ) ) return uint ( c ) } 
func ( fb * Flow Box ) Set Min Children Per Line ( n _children uint ) { C . gtk _flow _box _set _min _children _per _line ( fb . native ( ) , C . guint ( n _children ) ) } 
func ( fb * Flow Box ) Get Min Children Per Line ( ) uint { c : = C . gtk _flow _box _get _min _children _per _line ( fb . native ( ) ) return uint ( c ) } 
func ( fb * Flow Box ) Set Max Children Per Line ( n _children uint ) { C . gtk _flow _box _set _max _children _per _line ( fb . native ( ) , C . guint ( n _children ) ) } 
func ( fb * Flow Box ) Get Max Children Per Line ( ) uint { c : = C . gtk _flow _box _get _max _children _per _line ( fb . native ( ) ) return uint ( c ) } 
func ( fb * Flow Box ) Set Activate On Single Click ( single bool ) { C . gtk _flow _box _set _activate _on _single _click ( fb . native ( ) , gbool ( single ) ) } 
func ( fb * Flow Box ) Get Activate On Single Click ( ) bool { c : = C . gtk _flow _box _get _activate _on _single _click ( fb . native ( ) ) return gobool ( c ) } 
func ( fb * Flow Box ) Get Selected Children ( ) ( rv [ ] * Flow Box Child ) { c : = C . gtk _flow _box _get _selected _children ( fb . native ( ) ) if c = = nil { return } list : = glib . Wrap List ( uintptr ( unsafe . Pointer ( c ) ) ) for l : = list ; l ! = nil ; l = l . Next ( ) { o : = wrap Flow Box Child ( glib . Take ( l . Data ( ) . ( unsafe . Pointer ) ) ) rv = append ( rv , o ) } return } 
func ( fb * Flow Box ) Select Child ( child * Flow Box Child ) { C . gtk _flow _box _select _child ( fb . native ( ) , child . native ( ) ) } 
func ( fb * Flow Box ) Unselect Child ( child * Flow Box Child ) { C . gtk _flow _box _unselect _child ( fb . native ( ) , child . native ( ) ) } 
func ( fb * Flow Box ) Set Selection Mode ( mode Selection Mode ) { C . gtk _flow _box _set _selection _mode ( fb . native ( ) , C . Gtk Selection Mode ( mode ) ) } 
func ( fb * Flow Box ) Get Selection Mode ( ) Selection Mode { c : = C . gtk _flow _box _get _selection _mode ( fb . native ( ) ) return Selection Mode ( c ) } 
func Flow Box Child New ( ) ( * Flow Box Child , error ) { c : = C . gtk _flow _box _child _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Flow Box Child ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( fbc * Flow Box Child ) Get Index ( ) int { c : = C . gtk _flow _box _child _get _index ( fbc . native ( ) ) return int ( c ) } 
func ( fbc * Flow Box Child ) Is Selected ( ) bool { c : = C . gtk _flow _box _child _is _selected ( fbc . native ( ) ) return gobool ( c ) } 
func ( v * Context ) native ( ) * C . cairo _t { if v = = nil { return nil } return v . context } 
func Create ( target * Surface ) * Context { c : = C . cairo _create ( target . native ( ) ) ctx : = wrap Context ( c ) runtime . Set Finalizer ( ctx , ( * Context ) . destroy ) return ctx } 
func ( v * Context ) destroy ( ) { if v . context ! = nil { C . cairo _destroy ( v . native ( ) ) v . context = nil } } 
func ( v * Context ) Status ( ) Status { c : = C . cairo _status ( v . native ( ) ) return Status ( c ) } 
func ( v * Context ) Get Target ( ) * Surface { c : = C . cairo _get _target ( v . native ( ) ) s : = wrap Surface ( c ) s . reference ( ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Context ) Push Group With Content ( content Content ) { C . cairo _push _group _with _content ( v . native ( ) , C . cairo _content _t ( content ) ) } 
func ( v * Context ) Get Group Target ( ) * Surface { c : = C . cairo _get _group _target ( v . native ( ) ) s : = wrap Surface ( c ) s . reference ( ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Context ) Set Source ( p * Pattern ) { C . cairo _set _source ( v . native ( ) , p . native ( ) ) } 
func ( v * Context ) Set Source RGB ( red , green , blue float 6 4 ) { C . cairo _set _source _rgb ( v . native ( ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) ) } 
func ( v * Context ) Set Source RGBA ( red , green , blue , alpha float 6 4 ) { C . cairo _set _source _rgba ( v . native ( ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) } 
func ( v * Context ) Set Source Surface ( surface * Surface , x , y float 6 4 ) { C . cairo _set _source _surface ( v . native ( ) , surface . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) Set Antialias ( antialias Antialias ) { C . cairo _set _antialias ( v . native ( ) , C . cairo _antialias _t ( antialias ) ) } 
func ( v * Context ) Get Antialias ( ) Antialias { c : = C . cairo _get _antialias ( v . native ( ) ) return Antialias ( c ) } 
func ( v * Context ) Set Dash ( dashes [ ] float 6 4 , offset float 6 4 ) { header : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & dashes ) ) cdashes : = ( * C . double ) ( unsafe . Pointer ( header . Data ) ) C . cairo _set _dash ( v . native ( ) , cdashes , C . int ( header . Len ) , C . double ( offset ) ) } 
func ( v * Context ) Get Dash Count ( ) int { c : = C . cairo _get _dash _count ( v . native ( ) ) return int ( c ) } 
func ( v * Context ) Get Dash ( ) ( dashes [ ] float 6 4 , offset float 6 4 ) { dash Count : = v . Get Dash Count ( ) cdashes : = ( * C . double ) ( C . calloc ( 8 , C . size _t ( dash Count ) ) ) var coffset C . double C . cairo _get _dash ( v . native ( ) , cdashes , & coffset ) header : = ( * reflect . Slice Header ) ( ( unsafe . Pointer ( & dashes ) ) ) header . Data = uintptr ( unsafe . Pointer ( cdashes ) ) header . Len = dash Count header . Cap = dash Count return dashes , float 6 4 ( coffset ) } 
func ( v * Context ) Set Fill Rule ( fill Rule Fill Rule ) { C . cairo _set _fill _rule ( v . native ( ) , C . cairo _fill _rule _t ( fill Rule ) ) } 
func ( v * Context ) Get Fill Rule ( ) Fill Rule { c : = C . cairo _get _fill _rule ( v . native ( ) ) return Fill Rule ( c ) } 
func ( v * Context ) Set Line Cap ( line Cap Line Cap ) { C . cairo _set _line _cap ( v . native ( ) , C . cairo _line _cap _t ( line Cap ) ) } 
func ( v * Context ) Get Line Cap ( ) Line Cap { c : = C . cairo _get _line _cap ( v . native ( ) ) return Line Cap ( c ) } 
func ( v * Context ) Set Line Join ( line Join Line Join ) { C . cairo _set _line _join ( v . native ( ) , C . cairo _line _join _t ( line Join ) ) } 
func ( v * Context ) Get Line Join ( ) Line Join { c : = C . cairo _get _line _join ( v . native ( ) ) return Line Join ( c ) } 
func ( v * Context ) Set Line Width ( width float 6 4 ) { C . cairo _set _line _width ( v . native ( ) , C . double ( width ) ) } 
func ( v * Context ) Get Line Width ( ) float 6 4 { c : = C . cairo _get _line _width ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Context ) Set Miter Limit ( limit float 6 4 ) { C . cairo _set _miter _limit ( v . native ( ) , C . double ( limit ) ) } 
func ( v * Context ) Get Miter Limit ( ) float 6 4 { c : = C . cairo _get _miter _limit ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Context ) Set Operator ( op Operator ) { C . cairo _set _operator ( v . native ( ) , C . cairo _operator _t ( op ) ) } 
func ( v * Context ) Get Operator ( ) Operator { c : = C . cairo _get _operator ( v . native ( ) ) return Operator ( c ) } 
func ( v * Context ) Set Tolerance ( tolerance float 6 4 ) { C . cairo _set _tolerance ( v . native ( ) , C . double ( tolerance ) ) } 
func ( v * Context ) Get Tolerance ( ) float 6 4 { c : = C . cairo _get _tolerance ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Context ) Clip Extents ( ) ( x 1 , y 1 , x 2 , y 2 float 6 4 ) { var cx 1 , cy 1 , cx 2 , cy 2 C . double C . cairo _clip _extents ( v . native ( ) , & cx 1 , & cy 1 , & cx 2 , & cy 2 ) return float 6 4 ( cx 1 ) , float 6 4 ( cy 1 ) , float 6 4 ( cx 2 ) , float 6 4 ( cy 2 ) } 
func ( v * Context ) In Clip ( x , y float 6 4 ) bool { c : = C . cairo _in _clip ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * Context ) Rectangle ( x , y , w , h float 6 4 ) { C . cairo _rectangle ( v . native ( ) , C . double ( x ) , C . double ( y ) , C . double ( w ) , C . double ( h ) ) } 
func ( v * Context ) Arc ( xc , yc , radius , angle 1 , angle 2 float 6 4 ) { C . cairo _arc ( v . native ( ) , C . double ( xc ) , C . double ( yc ) , C . double ( radius ) , C . double ( angle 1 ) , C . double ( angle 2 ) ) } 
func ( v * Context ) Arc Negative ( xc , yc , radius , angle 1 , angle 2 float 6 4 ) { C . cairo _arc _negative ( v . native ( ) , C . double ( xc ) , C . double ( yc ) , C . double ( radius ) , C . double ( angle 1 ) , C . double ( angle 2 ) ) } 
func ( v * Context ) Line To ( x , y float 6 4 ) { C . cairo _line _to ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) Curve To ( x 1 , y 1 , x 2 , y 2 , x 3 , y 3 float 6 4 ) { C . cairo _curve _to ( v . native ( ) , C . double ( x 1 ) , C . double ( y 1 ) , C . double ( x 2 ) , C . double ( y 2 ) , C . double ( x 3 ) , C . double ( y 3 ) ) } 
func ( v * Context ) Move To ( x , y float 6 4 ) { C . cairo _move _to ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Context ) Get Current Point ( ) ( x , y float 6 4 ) { C . cairo _get _current _point ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return } 
func ( v * Context ) Fill Extents ( ) ( x 1 , y 1 , x 2 , y 2 float 6 4 ) { var cx 1 , cy 1 , cx 2 , cy 2 C . double C . cairo _fill _extents ( v . native ( ) , & cx 1 , & cy 1 , & cx 2 , & cy 2 ) return float 6 4 ( cx 1 ) , float 6 4 ( cy 1 ) , float 6 4 ( cx 2 ) , float 6 4 ( cy 2 ) } 
func ( v * Context ) In Fill ( x , y float 6 4 ) bool { c : = C . cairo _in _fill ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * Context ) Mask Surface ( surface * Surface , surface X , surface Y float 6 4 ) { C . cairo _mask _surface ( v . native ( ) , surface . native ( ) , C . double ( surface X ) , C . double ( surface Y ) ) } 
func ( v * Context ) Paint With Alpha ( alpha float 6 4 ) { C . cairo _paint _with _alpha ( v . native ( ) , C . double ( alpha ) ) } 
func ( v * Context ) Stroke Extents ( ) ( x 1 , y 1 , x 2 , y 2 float 6 4 ) { var cx 1 , cy 1 , cx 2 , cy 2 C . double C . cairo _stroke _extents ( v . native ( ) , & cx 1 , & cy 1 , & cx 2 , & cy 2 ) return float 6 4 ( cx 1 ) , float 6 4 ( cy 1 ) , float 6 4 ( cx 2 ) , float 6 4 ( cy 2 ) } 
func ( v * Context ) In Stroke ( x , y float 6 4 ) bool { c : = C . cairo _in _stroke ( v . native ( ) , C . double ( x ) , C . double ( y ) ) return gobool ( c ) } 
func ( v * Text View ) native ( ) * C . Gtk Text View { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Text View ( p ) } 
func Text View New ( ) ( * Text View , error ) { c : = C . gtk _text _view _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Text View ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Text View New With Buffer ( buf * Text Buffer ) ( * Text View , error ) { cbuf : = buf . native ( ) c : = C . gtk _text _view _new _with _buffer ( cbuf ) return wrap Text View ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Text View ) Get Buffer ( ) ( * Text Buffer , error ) { c : = C . gtk _text _view _get _buffer ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Text Buffer ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Text View ) Set Buffer ( buffer * Text Buffer ) { C . gtk _text _view _set _buffer ( v . native ( ) , buffer . native ( ) ) } 
func ( v * Text View ) Set Editable ( editable bool ) { C . gtk _text _view _set _editable ( v . native ( ) , gbool ( editable ) ) } 
func ( v * Text View ) Get Editable ( ) bool { c : = C . gtk _text _view _get _editable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Text View ) Set Wrap Mode ( wrap Mode Wrap Mode ) { C . gtk _text _view _set _wrap _mode ( v . native ( ) , C . Gtk Wrap Mode ( wrap Mode ) ) } 
func ( v * Text View ) Set Cursor Visible ( visible bool ) { C . gtk _text _view _set _cursor _visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Text View ) Get Cursor Visible ( ) bool { c : = C . gtk _text _view _get _cursor _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Text View ) Get Overwrite ( ) bool { c : = C . gtk _text _view _get _overwrite ( v . native ( ) ) return gobool ( c ) } 
func ( v * Text View ) Set Justification ( justify Justification ) { C . gtk _text _view _set _justification ( v . native ( ) , C . Gtk Justification ( justify ) ) } 
func ( v * Text View ) Get Justification ( ) Justification { c : = C . gtk _text _view _get _justification ( v . native ( ) ) return Justification ( c ) } 
func ( v * Text View ) Set Accepts Tab ( accepts Tab bool ) { C . gtk _text _view _set _accepts _tab ( v . native ( ) , gbool ( accepts Tab ) ) } 
func ( v * Text View ) Get Accepts Tab ( ) bool { c : = C . gtk _text _view _get _accepts _tab ( v . native ( ) ) return gobool ( c ) } 
func ( v * Text View ) Set Pixels Above Lines ( px int ) { C . gtk _text _view _set _pixels _above _lines ( v . native ( ) , C . gint ( px ) ) } 
func ( v * Text View ) Get Pixels Above Lines ( ) int { c : = C . gtk _text _view _get _pixels _above _lines ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Pixels Below Lines ( px int ) { C . gtk _text _view _set _pixels _below _lines ( v . native ( ) , C . gint ( px ) ) } 
func ( v * Text View ) Get Pixels Below Lines ( ) int { c : = C . gtk _text _view _get _pixels _below _lines ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Pixels Inside Wrap ( px int ) { C . gtk _text _view _set _pixels _inside _wrap ( v . native ( ) , C . gint ( px ) ) } 
func ( v * Text View ) Get Pixels Inside Wrap ( ) int { c : = C . gtk _text _view _get _pixels _inside _wrap ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Left Margin ( margin int ) { C . gtk _text _view _set _left _margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Text View ) Get Left Margin ( ) int { c : = C . gtk _text _view _get _left _margin ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Right Margin ( margin int ) { C . gtk _text _view _set _right _margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Text View ) Get Right Margin ( ) int { c : = C . gtk _text _view _get _right _margin ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Indent ( indent int ) { C . gtk _text _view _set _indent ( v . native ( ) , C . gint ( indent ) ) } 
func ( v * Text View ) Get Indent ( ) int { c : = C . gtk _text _view _get _indent ( v . native ( ) ) return int ( c ) } 
func ( v * Text View ) Set Input Hints ( hints Input Hints ) { C . gtk _text _view _set _input _hints ( v . native ( ) , C . Gtk Input Hints ( hints ) ) } 
func ( v * Text View ) Get Input Hints ( ) Input Hints { c : = C . gtk _text _view _get _input _hints ( v . native ( ) ) return Input Hints ( c ) } 
func ( v * Text View ) Set Input Purpose ( purpose Input Purpose ) { C . gtk _text _view _set _input _purpose ( v . native ( ) , C . Gtk Input Purpose ( purpose ) ) } 
func ( v * Text View ) Get Input Purpose ( ) Input Purpose { c : = C . gtk _text _view _get _input _purpose ( v . native ( ) ) return Input Purpose ( c ) } 
func ( v * Text View ) Scroll To Mark ( mark * Text Mark , within _margin float 6 4 , use _align bool , xalign , yalign float 6 4 ) { C . gtk _text _view _scroll _to _mark ( v . native ( ) , mark . native ( ) , C . gdouble ( within _margin ) , gbool ( use _align ) , C . gdouble ( xalign ) , C . gdouble ( yalign ) ) } 
func ( v * Text View ) Scroll To Iter ( iter * Text Iter , within _margin float 6 4 , use _align bool , xalign , yalign float 6 4 ) bool { return gobool ( C . gtk _text _view _scroll _to _iter ( v . native ( ) , iter . native ( ) , C . gdouble ( within _margin ) , gbool ( use _align ) , C . gdouble ( xalign ) , C . gdouble ( yalign ) ) ) } 
func ( v * Text View ) Scroll Mark Onscreen ( mark * Text Mark ) { C . gtk _text _view _scroll _mark _onscreen ( v . native ( ) , mark . native ( ) ) } 
func ( v * Text View ) Move Mark Onscreen ( mark * Text Mark ) bool { return gobool ( C . gtk _text _view _move _mark _onscreen ( v . native ( ) , mark . native ( ) ) ) } 
func ( v * Text View ) Get Visible Rect ( ) * gdk . Rectangle { var rect C . Gdk Rectangle C . gtk _text _view _get _visible _rect ( v . native ( ) , & rect ) return gdk . Wrap Rectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * Text View ) Get Iter Location ( iter * Text Iter ) * gdk . Rectangle { var rect C . Gdk Rectangle C . gtk _text _view _get _iter _location ( v . native ( ) , iter . native ( ) , & rect ) return gdk . Wrap Rectangle ( uintptr ( unsafe . Pointer ( & rect ) ) ) } 
func ( v * Text View ) Get Cursor Locations ( iter * Text Iter ) ( strong , weak * gdk . Rectangle ) { var strong Rect , weak Rect C . Gdk Rectangle C . gtk _text _view _get _cursor _locations ( v . native ( ) , iter . native ( ) , & strong Rect , & weak Rect ) return gdk . Wrap Rectangle ( uintptr ( unsafe . Pointer ( & strong Rect ) ) ) , gdk . Wrap Rectangle ( uintptr ( unsafe . Pointer ( & weak Rect ) ) ) } 
func ( v * Text View ) Get Line At Y ( y int ) ( * Text Iter , int ) { var iter Text Iter var line _top C . gint iiter : = ( C . Gtk Text Iter ) ( iter ) C . gtk _text _view _get _line _at _y ( v . native ( ) , & iiter , C . gint ( y ) , & line _top ) return & iter , int ( line _top ) } 
func ( v * Text View ) Get Line Yrange ( iter * Text Iter ) ( y , height int ) { var yx , heightx C . gint C . gtk _text _view _get _line _yrange ( v . native ( ) , iter . native ( ) , & yx , & heightx ) return int ( yx ) , int ( heightx ) } 
func ( v * Text View ) Get Iter At Location ( x , y int ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _view _get _iter _at _location ( v . native ( ) , & iter , C . gint ( x ) , C . gint ( y ) ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text View ) Get Iter At Position ( x , y int ) ( * Text Iter , int ) { var iter C . Gtk Text Iter var trailing C . gint C . gtk _text _view _get _iter _at _position ( v . native ( ) , & iter , & trailing , C . gint ( x ) , C . gint ( y ) ) return ( * Text Iter ) ( & iter ) , int ( trailing ) } 
func ( v * Text View ) Buffer To Window Coords ( win Text Window Type , buffer _x , buffer _y int ) ( window _x , window _y int ) { var wx , wy C . gint C . gtk _text _view _buffer _to _window _coords ( v . native ( ) , C . Gtk Text Window Type ( win ) , C . gint ( buffer _x ) , C . gint ( buffer _y ) , & wx , & wy ) return int ( wx ) , int ( wy ) } 
func ( v * Text View ) Window To Buffer Coords ( win Text Window Type , window _x , window _y int ) ( buffer _x , buffer _y int ) { var bx , by C . gint C . gtk _text _view _window _to _buffer _coords ( v . native ( ) , C . Gtk Text Window Type ( win ) , C . gint ( window _x ) , C . gint ( window _y ) , & bx , & by ) return int ( bx ) , int ( by ) } 
func ( v * Text View ) Get Window ( win Text Window Type ) * gdk . Window { c : = C . gtk _text _view _get _window ( v . native ( ) , C . Gtk Text Window Type ( win ) ) if c = = nil { return nil } return & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Text View ) Get Window Type ( w * gdk . Window ) Text Window Type { return Text Window Type ( C . gtk _text _view _get _window _type ( v . native ( ) , ( * C . Gdk Window ) ( unsafe . Pointer ( w . Native ( ) ) ) ) ) } 
func ( v * Text View ) Set Border Window Size ( tp Text Window Type , size int ) { C . gtk _text _view _set _border _window _size ( v . native ( ) , C . Gtk Text Window Type ( tp ) , C . gint ( size ) ) } 
func ( v * Text View ) Get Border Window Size ( tp Text Window Type ) int { return int ( C . gtk _text _view _get _border _window _size ( v . native ( ) , C . Gtk Text Window Type ( tp ) ) ) } 
func ( v * Text View ) Forward Display Line ( iter * Text Iter ) bool { return gobool ( C . gtk _text _view _forward _display _line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * Text View ) Backward Display Line ( iter * Text Iter ) bool { return gobool ( C . gtk _text _view _backward _display _line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * Text View ) Forward Display Line End ( iter * Text Iter ) bool { return gobool ( C . gtk _text _view _forward _display _line _end ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * Text View ) Backward Display Line Start ( iter * Text Iter ) bool { return gobool ( C . gtk _text _view _backward _display _line _start ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * Text View ) Starts Display Line ( iter * Text Iter ) bool { return gobool ( C . gtk _text _view _starts _display _line ( v . native ( ) , iter . native ( ) ) ) } 
func ( v * Text View ) Move Visually ( iter * Text Iter , count int ) bool { return gobool ( C . gtk _text _view _move _visually ( v . native ( ) , iter . native ( ) , C . gint ( count ) ) ) } 
func ( v * Text View ) Add Child In Window ( child IWidget , tp Text Window Type , xpos , ypos int ) { C . gtk _text _view _add _child _in _window ( v . native ( ) , child . to Widget ( ) , C . Gtk Text Window Type ( tp ) , C . gint ( xpos ) , C . gint ( ypos ) ) } 
func ( v * Text View ) Move Child ( child IWidget , xpos , ypos int ) { C . gtk _text _view _move _child ( v . native ( ) , child . to Widget ( ) , C . gint ( xpos ) , C . gint ( ypos ) ) } 
func ( v * Text View ) Im Context Filter Keypress ( event * gdk . Event Key ) bool { return gobool ( C . gtk _text _view _im _context _filter _keypress ( v . native ( ) , ( * C . Gdk Event Key ) ( unsafe . Pointer ( event . Native ( ) ) ) ) ) } 
func ( v * Text View ) Add Child At Anchor ( child IWidget , anchor * Text Child Anchor ) { C . gtk _text _view _add _child _at _anchor ( v . native ( ) , child . to Widget ( ) , anchor . native ( ) ) } 
func ( v * Settings Backend ) native ( ) * C . GSettings Backend { if v = = nil | | v . GObject = = nil { return nil } return C . to GSettings Backend ( unsafe . Pointer ( v . GObject ) ) } 
func Keyfile Settings Backend New ( filename , root Path , root Group string ) * Settings Backend { cstr 1 : = ( * C . gchar ) ( C . CString ( filename ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( root Path ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) cstr 3 : = ( * C . gchar ) ( C . CString ( root Group ) ) defer C . free ( unsafe . Pointer ( cstr 3 ) ) return wrap Settings Backend ( wrap Object ( unsafe . Pointer ( C . g _keyfile _settings _backend _new ( cstr 1 , cstr 2 , cstr 3 ) ) ) ) } 
func ( v * Stack ) Get Child By Name ( name string ) * Widget { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _stack _get _child _by _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Stack ) Get Transition Running ( ) bool { c : = C . gtk _stack _get _transition _running ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Get Clip ( ) * Allocation { var clip Allocation C . gtk _widget _get _clip ( v . native ( ) , clip . native ( ) ) return & clip } 
func ( v * Widget ) Set Clip ( clip * Allocation ) { C . gtk _widget _set _clip ( v . native ( ) , clip . native ( ) ) } 
func ( v * Color ) Copy ( c * Color ) * Color { w : = new ( Color ) w . pango Color = C . pango _color _copy ( v . native ( ) ) return w } 
func ( v * Color ) Parse ( spec string ) bool { cstr : = C . CString ( spec ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . pango _color _parse ( v . native ( ) , ( * C . char ) ( cstr ) ) return gobool ( c ) } 
func ( v * Color ) To String ( ) string { c : = C . pango _color _to _string ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Screen ) Get Active Window ( ) ( * Window , error ) { return to Window ( C . gdk _screen _get _active _window ( v . native ( ) ) ) } 
func ( v * Screen ) Get Height ( ) int { c : = C . gdk _screen _get _height ( v . native ( ) ) return int ( c ) } 
func ( v * Screen ) Get Monitor At Point ( x , y int ) int { return int ( C . gdk _screen _get _monitor _at _point ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) ) } 
func ( v * Screen ) Get Monitor At Window ( w * Window ) int { return int ( C . gdk _screen _get _monitor _at _window ( v . native ( ) , w . native ( ) ) ) } 
func ( v * Screen ) Get Monitor Height MM ( m int ) int { return int ( C . gdk _screen _get _monitor _height _mm ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) Get Monitor Plug Name ( m int ) ( string , error ) { return to String ( C . gdk _screen _get _monitor _plug _name ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) Get Monitor Scale Factor ( m int ) int { return int ( C . gdk _screen _get _monitor _scale _factor ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) Get Monitor Width MM ( m int ) int { return int ( C . gdk _screen _get _monitor _width _mm ( v . native ( ) , C . gint ( m ) ) ) } 
func ( v * Screen ) Get Width ( ) int { c : = C . gdk _screen _get _width ( v . native ( ) ) return int ( c ) } 
func ( v * Screen ) Make Display Name ( ) ( string , error ) { return to String ( C . gdk _screen _make _display _name ( v . native ( ) ) ) } 
func ( v * Variant Type ) String ( ) string { ch : = C . g _variant _type _dup _string ( v . native ( ) ) defer C . g _free ( C . gpointer ( ch ) ) return C . Go String ( ( * C . char ) ( ch ) ) } 
func ( v * Application ) native ( ) * C . Gtk Application { if v = = nil | | v . GObject = = nil { return nil } return C . to Gtk Application ( unsafe . Pointer ( v . GObject ) ) } 
func Application New ( app Id string , flags glib . Application Flags ) ( * Application , error ) { cstr : = ( * C . gchar ) ( C . CString ( app Id ) ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _application _new ( cstr , C . GApplication Flags ( flags ) ) if c = = nil { return nil , nil Ptr Err } return wrap Application ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Application ) Add Window ( w * Window ) { C . gtk _application _add _window ( v . native ( ) , w . native ( ) ) } 
func ( v * Application ) Remove Window ( w * Window ) { C . gtk _application _remove _window ( v . native ( ) , w . native ( ) ) } 
func ( v * Application ) Get Window By ID ( id uint ) * Window { c : = C . gtk _application _get _window _by _id ( v . native ( ) , C . guint ( id ) ) if c = = nil { return nil } return wrap Window ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Get Active Window ( ) * Window { c : = C . gtk _application _get _active _window ( v . native ( ) ) if c = = nil { return nil } return wrap Window ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Application ) Uninhibit ( cookie uint ) { C . gtk _application _uninhibit ( v . native ( ) , C . guint ( cookie ) ) } 
func ( v * Application ) Get App Menu ( ) * glib . Menu Model { c : = C . gtk _application _get _app _menu ( v . native ( ) ) if c = = nil { return nil } return & glib . Menu Model { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Application ) Set App Menu ( m * glib . Menu Model ) { mptr : = ( * C . GMenu Model ) ( unsafe . Pointer ( m . Native ( ) ) ) C . gtk _application _set _app _menu ( v . native ( ) , mptr ) } 
func ( v * Application ) Get Menubar ( ) * glib . Menu Model { c : = C . gtk _application _get _menubar ( v . native ( ) ) if c = = nil { return nil } return & glib . Menu Model { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Application ) Set Menubar ( m * glib . Menu Model ) { mptr : = ( * C . GMenu Model ) ( unsafe . Pointer ( m . Native ( ) ) ) C . gtk _application _set _menubar ( v . native ( ) , mptr ) } 
func ( v * Application ) Is Inhibited ( flags Application Inhibit Flags ) bool { return gobool ( C . gtk _application _is _inhibited ( v . native ( ) , C . Gtk Application Inhibit Flags ( flags ) ) ) } 
func ( v * Application ) Inhibited ( w * Window , flags Application Inhibit Flags , reason string ) uint { cstr 1 : = ( * C . gchar ) ( C . CString ( reason ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return uint ( C . gtk _application _inhibit ( v . native ( ) , w . native ( ) , C . Gtk Application Inhibit Flags ( flags ) , cstr 1 ) ) } 
func ( v * Application ) Get Windows ( ) * glib . List { glist : = C . gtk _application _get _windows ( v . native ( ) ) list : = glib . Wrap List ( uintptr ( unsafe . Pointer ( glist ) ) ) list . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return wrap Window ( glib . Take ( ptr ) ) } ) runtime . Set Finalizer ( list , func ( l * glib . List ) { l . Free ( ) } ) return list } 
func ( v * Display ) Supports Composite ( ) bool { c : = C . gdk _display _supports _composite ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Is Maximized ( ) bool { c : = C . gtk _window _is _maximized ( v . native ( ) ) return gobool ( c ) } 
func ( v * Menu Shell ) native ( ) * C . Gtk Menu Shell { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Menu Shell ( p ) } 
func ( v * Menu Shell ) Append ( child IMenu Item ) { C . gtk _menu _shell _append ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Menu Shell ) Prepend ( child IMenu Item ) { C . gtk _menu _shell _prepend ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Menu Shell ) Insert ( child IMenu Item , position int ) { C . gtk _menu _shell _insert ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func ( v * Menu Shell ) Select Item ( child IMenu Item ) { C . gtk _menu _shell _select _item ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Menu Shell ) Select First ( search Sensitive bool ) { C . gtk _menu _shell _select _first ( v . native ( ) , gbool ( search Sensitive ) ) } 
func ( v * Menu Shell ) Activate Item ( child IMenu Item , force Deactivate bool ) { C . gtk _menu _shell _activate _item ( v . native ( ) , child . to Widget ( ) , gbool ( force Deactivate ) ) } 
func ( v * Menu Shell ) Set Take Focus ( take Focus bool ) { C . gtk _menu _shell _set _take _focus ( v . native ( ) , gbool ( take Focus ) ) } 
func gbool ( b bool ) C . gboolean { if b { return C . gboolean ( 1 ) } return C . gboolean ( 0 ) } 
func ( v * Style Context ) native ( ) * C . Gtk Style Context { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Style Context ( p ) } 
func ( v * Widget ) Get Style Context ( ) ( * Style Context , error ) { return from Native Style Context ( C . gtk _widget _get _style _context ( v . native ( ) ) ) } 
func ( v * Style Context ) Get Parent ( ) ( * Style Context , error ) { return from Native Style Context ( C . gtk _style _context _get _parent ( v . native ( ) ) ) } 
func ( v * Style Context ) Get Property ( property string , state State Flags ) ( interface { } , error ) { cstr : = ( * C . gchar ) ( C . CString ( property ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var gval C . GValue C . gtk _style _context _get _property ( v . native ( ) , cstr , C . Gtk State Flags ( state ) , & gval ) val : = glib . Value From Native ( unsafe . Pointer ( & gval ) ) return val . Go Value ( ) } 
func ( v * Style Context ) Get Style Property ( property string ) ( interface { } , error ) { cstr : = ( * C . gchar ) ( C . CString ( property ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var gval C . GValue C . gtk _style _context _get _style _property ( v . native ( ) , cstr , & gval ) val : = glib . Value From Native ( unsafe . Pointer ( & gval ) ) return val . Go Value ( ) } 
func ( v * Style Context ) Get Screen ( ) ( * gdk . Screen , error ) { c : = C . gtk _style _context _get _screen ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } d : = & gdk . Screen { glib . Take ( unsafe . Pointer ( c ) ) } return d , nil } 
func ( v * Style Context ) Get Color ( state State Flags ) * gdk . RGBA { gdk Color : = gdk . New RGBA ( ) C . gtk _style _context _get _color ( v . native ( ) , C . Gtk State Flags ( state ) , ( * C . Gdk RGBA ) ( unsafe . Pointer ( gdk Color . Native ( ) ) ) ) return gdk Color } 
func ( v * Style Context ) Lookup Color ( color Name string ) ( * gdk . RGBA , bool ) { cstr : = ( * C . gchar ) ( C . CString ( color Name ) ) defer C . free ( unsafe . Pointer ( cstr ) ) gdk Color : = gdk . New RGBA ( ) ret : = C . gtk _style _context _lookup _color ( v . native ( ) , cstr , ( * C . Gdk RGBA ) ( unsafe . Pointer ( gdk Color . Native ( ) ) ) ) return gdk Color , gobool ( ret ) } 
func Style Context Reset Widgets ( v * gdk . Screen ) { C . gtk _style _context _reset _widgets ( ( * C . Gdk Screen ) ( unsafe . Pointer ( v . Native ( ) ) ) ) } 
func ( v * Style Context ) Set Parent ( p * Style Context ) { C . gtk _style _context _set _parent ( v . native ( ) , p . native ( ) ) } 
func ( v * Style Context ) Has Class ( class Name string ) bool { cstr : = C . CString ( class Name ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gtk _style _context _has _class ( v . native ( ) , ( * C . gchar ) ( cstr ) ) ) } 
func ( v * Style Context ) Set Screen ( s * gdk . Screen ) { C . gtk _style _context _set _screen ( v . native ( ) , ( * C . Gdk Screen ) ( unsafe . Pointer ( s . Native ( ) ) ) ) } 
func ( v * Style Context ) Set State ( state State Flags ) { C . gtk _style _context _set _state ( v . native ( ) , C . Gtk State Flags ( state ) ) } 
func ( v * Style Context ) Add Provider ( provider IStyle Provider , prio uint ) { C . gtk _style _context _add _provider ( v . native ( ) , provider . to Style Provider ( ) , C . guint ( prio ) ) } 
func Add Provider For Screen ( s * gdk . Screen , provider IStyle Provider , prio uint ) { C . gtk _style _context _add _provider _for _screen ( ( * C . Gdk Screen ) ( unsafe . Pointer ( s . Native ( ) ) ) , provider . to Style Provider ( ) , C . guint ( prio ) ) } 
func ( v * Style Context ) Remove Provider ( provider IStyle Provider ) { C . gtk _style _context _remove _provider ( v . native ( ) , provider . to Style Provider ( ) ) } 
func Remove Provider For Screen ( s * gdk . Screen , provider IStyle Provider ) { C . gtk _style _context _remove _provider _for _screen ( ( * C . Gdk Screen ) ( unsafe . Pointer ( s . Native ( ) ) ) , provider . to Style Provider ( ) ) } 
func New Matrix ( xx , yx , xy , yy , x 0 , y 0 float 6 4 ) * Matrix { return & Matrix { Xx : xx , Yx : yx , Xy : xy , Yy : yy , X 0 : x 0 , Y 0 : y 0 , } } 
func ( m * Matrix ) native ( ) * C . cairo _matrix _t { return ( * C . cairo _matrix _t ) ( unsafe . Pointer ( m ) ) } 
func ( m * Matrix ) Init Translate ( tx , ty float 6 4 ) { C . cairo _matrix _init _translate ( m . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( m * Matrix ) Init Scale ( sx , sy float 6 4 ) { C . cairo _matrix _init _scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( m * Matrix ) Init Rotate ( radians float 6 4 ) { C . cairo _matrix _init _rotate ( m . native ( ) , C . double ( radians ) ) } 
func ( m * Matrix ) Translate ( tx , ty float 6 4 ) { C . cairo _matrix _translate ( m . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( m * Matrix ) Scale ( sx , sy float 6 4 ) { C . cairo _matrix _scale ( m . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( m * Matrix ) Rotate ( radians float 6 4 ) { C . cairo _matrix _rotate ( m . native ( ) , C . double ( radians ) ) } 
func ( m * Matrix ) Multiply ( a , b Matrix ) { C . cairo _matrix _multiply ( m . native ( ) , a . native ( ) , b . native ( ) ) } 
func ( m * Matrix ) Transform Distance ( dx , dy float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _matrix _transform _distance ( m . native ( ) , ( * C . double ) ( unsafe . Pointer ( & dx ) ) , ( * C . double ) ( unsafe . Pointer ( & dy ) ) ) return dx , dy } 
func ( m * Matrix ) Transform Point ( x , y float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _matrix _transform _point ( m . native ( ) , ( * C . double ) ( unsafe . Pointer ( & x ) ) , ( * C . double ) ( unsafe . Pointer ( & y ) ) ) return x , y } 
func ( v * Menu ) native ( ) * C . Gtk Menu { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Menu ( p ) } 
func Menu New ( ) ( * Menu , error ) { c : = C . gtk _menu _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Menu ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Menu ) Reorder Child ( child IWidget , position int ) { C . gtk _menu _reorder _child ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func Page Setup New ( ) ( * Page Setup , error ) { c : = C . gtk _page _setup _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Page Setup ( obj ) , nil } 
func ( ps * Page Setup ) Copy ( ) ( * Page Setup , error ) { c : = C . gtk _page _setup _copy ( ps . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Page Setup ( obj ) , nil } 
func ( ps * Page Setup ) Get Orientation ( ) Page Orientation { c : = C . gtk _page _setup _get _orientation ( ps . native ( ) ) return Page Orientation ( c ) } 
func ( ps * Page Setup ) Set Orientation ( orientation Page Orientation ) { C . gtk _page _setup _set _orientation ( ps . native ( ) , C . Gtk Page Orientation ( orientation ) ) } 
func ( ps * Page Setup ) Get Paper Size ( ) * Paper Size { c : = C . gtk _page _setup _get _paper _size ( ps . native ( ) ) p : = & Paper Size { c } runtime . Set Finalizer ( p , ( * Paper Size ) . free ) return p } 
func ( ps * Page Setup ) Set Paper Size ( size * Paper Size ) { C . gtk _page _setup _set _paper _size ( ps . native ( ) , size . native ( ) ) } 
func ( ps * Page Setup ) Get Top Margin ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _top _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Set Top Margin ( margin float 6 4 , unit Unit ) { C . gtk _page _setup _set _top _margin ( ps . native ( ) , C . gdouble ( margin ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Page Setup ) Get Bottom Margin ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _bottom _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Set Bottom Margin ( margin float 6 4 , unit Unit ) { C . gtk _page _setup _set _bottom _margin ( ps . native ( ) , C . gdouble ( margin ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Page Setup ) Get Left Margin ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _left _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Set Left Margin ( margin float 6 4 , unit Unit ) { C . gtk _page _setup _set _left _margin ( ps . native ( ) , C . gdouble ( margin ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Page Setup ) Get Right Margin ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _right _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Set Right Margin ( margin float 6 4 , unit Unit ) { C . gtk _page _setup _set _right _margin ( ps . native ( ) , C . gdouble ( margin ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Page Setup ) Set Paper Size And Default Margins ( size * Paper Size ) { C . gtk _page _setup _set _paper _size _and _default _margins ( ps . native ( ) , size . native ( ) ) } 
func ( ps * Page Setup ) Get Paper Width ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _paper _width ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Get Paper Height ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _paper _height ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Get Page Width ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _page _width ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Page Setup ) Get Page Height ( unit Unit ) float 6 4 { c : = C . gtk _page _setup _get _page _height ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func Page Setup New From File ( file Name string ) ( * Page Setup , error ) { cstr : = C . CString ( file Name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c : = C . gtk _page _setup _new _from _file ( ( * C . gchar ) ( cstr ) , & err ) if c = = nil { defer C . g _error _free ( err ) return nil , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Page Setup { obj } , nil } 
func ( ps * Page Setup ) Page Setup To File ( name string ) error { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res : = C . gtk _page _setup _to _file ( ps . native ( ) , cstr , & err ) if ! gobool ( res ) { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( ps * Paper Size ) native ( ) * C . Gtk Paper Size { if ps = = nil { return nil } return ps . Gtk Paper Size } 
func Paper Size New ( name string ) ( * Paper Size , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var g Name * C . gchar if name = = " " { g Name = nil } else { g Name = ( * C . gchar ) ( cstr ) } c : = C . gtk _paper _size _new ( g Name ) if c = = nil { return nil , nil Ptr Err } t : = & Paper Size { c } runtime . Set Finalizer ( t , ( * Paper Size ) . free ) return t , nil } 
func Paper Size New From PPD ( name , display Name string , width , height float 6 4 ) ( * Paper Size , error ) { c Name : = C . CString ( name ) defer C . free ( unsafe . Pointer ( c Name ) ) c Display Name : = C . CString ( display Name ) defer C . free ( unsafe . Pointer ( c Display Name ) ) c : = C . gtk _paper _size _new _from _ppd ( ( * C . gchar ) ( c Name ) , ( * C . gchar ) ( c Display Name ) , C . gdouble ( width ) , C . gdouble ( height ) ) if c = = nil { return nil , nil Ptr Err } t : = & Paper Size { c } runtime . Set Finalizer ( t , ( * Paper Size ) . free ) return t , nil } 
func Paper Size New Custom ( name , display Name string , width , height float 6 4 , unit Unit ) ( * Paper Size , error ) { c Name : = C . CString ( name ) defer C . free ( unsafe . Pointer ( c Name ) ) c Display Name : = C . CString ( display Name ) defer C . free ( unsafe . Pointer ( c Display Name ) ) c : = C . gtk _paper _size _new _custom ( ( * C . gchar ) ( c Name ) , ( * C . gchar ) ( c Display Name ) , C . gdouble ( width ) , C . gdouble ( height ) , C . Gtk Unit ( unit ) ) if c = = nil { return nil , nil Ptr Err } t : = & Paper Size { c } runtime . Set Finalizer ( t , ( * Paper Size ) . free ) return t , nil } 
func ( ps * Paper Size ) Copy ( ) ( * Paper Size , error ) { c : = C . gtk _paper _size _copy ( ps . native ( ) ) if c = = nil { return nil , nil Ptr Err } t : = & Paper Size { c } runtime . Set Finalizer ( t , ( * Paper Size ) . free ) return t , nil } 
func ( ps * Paper Size ) Is Equal ( other * Paper Size ) bool { c : = C . gtk _paper _size _is _equal ( ps . native ( ) , other . native ( ) ) return gobool ( c ) } 
func Paper Size Get Paper Sizes ( include Custom bool ) * glib . List { clist : = C . gtk _paper _size _get _paper _sizes ( gbool ( include Custom ) ) if clist = = nil { return nil } glist : = glib . Wrap List ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return & Paper Size { ( * C . Gtk Paper Size ) ( ptr ) } } ) runtime . Set Finalizer ( glist , func ( glist * glib . List ) { glist . Free Full ( func ( item interface { } ) { ps : = item . ( * Paper Size ) C . gtk _paper _size _free ( ps . Gtk Paper Size ) } ) } ) return glist } 
func ( ps * Paper Size ) Get Name ( ) string { c : = C . gtk _paper _size _get _name ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Paper Size ) Get Display Name ( ) string { c : = C . gtk _paper _size _get _display _name ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Paper Size ) Get PPDName ( ) ( string , error ) { c : = C . gtk _paper _size _get _ppd _name ( ps . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( ps * Paper Size ) Get Width ( unit Unit ) float 6 4 { c : = C . gtk _paper _size _get _width ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Paper Size ) Is Custom ( ) bool { c : = C . gtk _paper _size _is _custom ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * Paper Size ) Set Size ( width , height float 6 4 , unit Unit ) { C . gtk _paper _size _set _size ( ps . native ( ) , C . gdouble ( width ) , C . gdouble ( height ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Paper Size ) Get Default Top Margin ( unit Unit ) float 6 4 { c : = C . gtk _paper _size _get _default _top _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Paper Size ) Get Default Bottom Margin ( unit Unit ) float 6 4 { c : = C . gtk _paper _size _get _default _bottom _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Paper Size ) Get Default Left Margin ( unit Unit ) float 6 4 { c : = C . gtk _paper _size _get _default _left _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Paper Size ) Get Default Right Margin ( unit Unit ) float 6 4 { c : = C . gtk _paper _size _get _default _right _margin ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func Paper Size Get Default Right Margin ( unit Unit ) string { c : = C . gtk _paper _size _get _default ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( pc * Print Context ) native ( ) * C . Gtk Print Context { if pc = = nil | | pc . GObject = = nil { return nil } p : = unsafe . Pointer ( pc . GObject ) return C . to Gtk Print Context ( p ) } 
func ( pc * Print Context ) Get Cairo Context ( ) * cairo . Context { c : = C . gtk _print _context _get _cairo _context ( pc . native ( ) ) return cairo . Wrap Context ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * Print Context ) Set Cairo Context ( cr * cairo . Context , dpi X , dpi Y float 6 4 ) { C . gtk _print _context _set _cairo _context ( pc . native ( ) , ( * C . cairo _t ) ( unsafe . Pointer ( cr . Native ( ) ) ) , C . double ( dpi X ) , C . double ( dpi Y ) ) } 
func ( pc * Print Context ) Get Page Setup ( ) * Page Setup { c : = C . gtk _print _context _get _page _setup ( pc . native ( ) ) obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Page Setup ( obj ) } 
func ( pc * Print Context ) Get Width ( ) float 6 4 { c : = C . gtk _print _context _get _width ( pc . native ( ) ) return float 6 4 ( c ) } 
func ( pc * Print Context ) Get Height ( ) float 6 4 { c : = C . gtk _print _context _get _height ( pc . native ( ) ) return float 6 4 ( c ) } 
func ( pc * Print Context ) Get Dpi X ( ) float 6 4 { c : = C . gtk _print _context _get _dpi _x ( pc . native ( ) ) return float 6 4 ( c ) } 
func ( pc * Print Context ) Get Dpi Y ( ) float 6 4 { c : = C . gtk _print _context _get _dpi _y ( pc . native ( ) ) return float 6 4 ( c ) } 
func ( pc * Print Context ) Get Pango Font Map ( ) * pango . Font Map { c : = C . gtk _print _context _get _pango _fontmap ( pc . native ( ) ) return pango . Wrap Font Map ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * Print Context ) Create Pango Context ( ) * pango . Context { c : = C . gtk _print _context _create _pango _context ( pc . native ( ) ) return pango . Wrap Context ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * Print Context ) Create Pango Layout ( ) * pango . Layout { c : = C . gtk _print _context _create _pango _layout ( pc . native ( ) ) return pango . Wrap Layout ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( pc * Print Context ) Get Hard Margins ( ) ( float 6 4 , float 6 4 , float 6 4 , float 6 4 , error ) { var top , bottom , left , right C . gdouble c : = C . gtk _print _context _get _hard _margins ( pc . native ( ) , & top , & bottom , & left , & right ) if gobool ( c ) = = false { return 0 . 0 , 0 . 0 , 0 . 0 , 0 . 0 , errors . New ( " " ) } return float 6 4 ( top ) , float 6 4 ( bottom ) , float 6 4 ( left ) , float 6 4 ( right ) , nil } 
func Print Operation New ( ) ( * Print Operation , error ) { c : = C . gtk _print _operation _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Print Operation ( obj ) , nil } 
func ( po * Print Operation ) Print Operation Set Allow Async ( allow Sync bool ) { C . gtk _print _operation _set _allow _async ( po . native ( ) , gbool ( allow Sync ) ) } 
func ( po * Print Operation ) Print Operation Get Error ( ) error { var err * C . GError = nil C . gtk _print _operation _get _error ( po . native ( ) , & err ) defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } 
func ( po * Print Operation ) Set Default Page Setup ( ps * Page Setup ) { C . gtk _print _operation _set _default _page _setup ( po . native ( ) , ps . native ( ) ) } 
func ( po * Print Operation ) Get Default Page Setup ( ) ( * Page Setup , error ) { c : = C . gtk _print _operation _get _default _page _setup ( po . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Page Setup ( obj ) , nil } 
func ( po * Print Operation ) Set Print Settings ( ps * Print Settings ) { C . gtk _print _operation _set _print _settings ( po . native ( ) , ps . native ( ) ) } 
func ( po * Print Operation ) Get Print Settings ( ps * Page Setup ) ( * Print Settings , error ) { c : = C . gtk _print _operation _get _print _settings ( po . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Print Settings ( obj ) , nil } 
func ( po * Print Operation ) Set Job Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _operation _set _job _name ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * Print Operation ) Set NPages ( pages int ) { C . gtk _print _operation _set _n _pages ( po . native ( ) , C . gint ( pages ) ) } 
func ( po * Print Operation ) Get NPages To Print ( ) int { c : = C . gtk _print _operation _get _n _pages _to _print ( po . native ( ) ) return int ( c ) } 
func ( po * Print Operation ) Set Current Page ( page int ) { C . gtk _print _operation _set _current _page ( po . native ( ) , C . gint ( page ) ) } 
func ( po * Print Operation ) Set Use Full Page ( full bool ) { C . gtk _print _operation _set _use _full _page ( po . native ( ) , gbool ( full ) ) } 
func ( po * Print Operation ) Set Unit ( unit Unit ) { C . gtk _print _operation _set _unit ( po . native ( ) , C . Gtk Unit ( unit ) ) } 
func ( po * Print Operation ) Set Export Filename ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _operation _set _export _filename ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * Print Operation ) Set Show Progress ( show bool ) { C . gtk _print _operation _set _show _progress ( po . native ( ) , gbool ( show ) ) } 
func ( po * Print Operation ) Set Track Print Status ( progress bool ) { C . gtk _print _operation _set _track _print _status ( po . native ( ) , gbool ( progress ) ) } 
func ( po * Print Operation ) Set Custom Tab Label ( label string ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _operation _set _custom _tab _label ( po . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( po * Print Operation ) Run ( action Print Operation Action , parent * Window ) ( Print Operation Result , error ) { var err * C . GError = nil c : = C . gtk _print _operation _run ( po . native ( ) , C . Gtk Print Operation Action ( action ) , parent . native ( ) , & err ) res : = Print Operation Result ( c ) if res = = PRINT _OPERATION _RESULT _ERROR { defer C . g _error _free ( err ) return res , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return res , nil } 
func ( po * Print Operation ) Get Status ( ) Print Status { c : = C . gtk _print _operation _get _status ( po . native ( ) ) return Print Status ( c ) } 
func ( po * Print Operation ) Get Status String ( ) string { c : = C . gtk _print _operation _get _status _string ( po . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( po * Print Operation ) Is Finished ( ) bool { c : = C . gtk _print _operation _is _finished ( po . native ( ) ) return gobool ( c ) } 
func ( po * Print Operation ) Set Support Selection ( selection bool ) { C . gtk _print _operation _set _support _selection ( po . native ( ) , gbool ( selection ) ) } 
func ( po * Print Operation ) Get Support Selection ( ) bool { c : = C . gtk _print _operation _get _support _selection ( po . native ( ) ) return gobool ( c ) } 
func ( po * Print Operation ) Set Has Selection ( selection bool ) { C . gtk _print _operation _set _has _selection ( po . native ( ) , gbool ( selection ) ) } 
func ( po * Print Operation ) Get Has Selection ( ) bool { c : = C . gtk _print _operation _get _has _selection ( po . native ( ) ) return gobool ( c ) } 
func ( po * Print Operation ) Set Embed Page Setup ( embed bool ) { C . gtk _print _operation _set _embed _page _setup ( po . native ( ) , gbool ( embed ) ) } 
func ( po * Print Operation ) Get Embed Page Setup ( ) bool { c : = C . gtk _print _operation _get _embed _page _setup ( po . native ( ) ) return gobool ( c ) } 
func Print Run Page Setup Dialog ( parent * Window , page Setup * Page Setup , settings * Print Settings ) * Page Setup { c : = C . gtk _print _run _page _setup _dialog ( parent . native ( ) , page Setup . native ( ) , settings . native ( ) ) obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Page Setup ( obj ) } 
func Print Run Page Setup Dialog Async ( parent * Window , setup * Page Setup , settings * Print Settings , cb Page Setup Done Callback , data uintptr ) { page Setup Done Callback Registry . Lock ( ) id : = page Setup Done Callback Registry . next page Setup Done Callback Registry . next + + page Setup Done Callback Registry . m [ id ] = page Setup Done Callback Data { fn : cb , data : data } page Setup Done Callback Registry . Unlock ( ) C . _gtk _print _run _page _setup _dialog _async ( parent . native ( ) , setup . native ( ) , settings . native ( ) , C . gpointer ( uintptr ( id ) ) ) } 
func ( v * Print Operation Preview ) native ( ) * C . Gtk Print Operation Preview { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Print Operation Preview ( p ) } 
func ( pop * Print Operation Preview ) Render Page ( page int ) { C . gtk _print _operation _preview _render _page ( pop . native ( ) , C . gint ( page ) ) } 
func ( pop * Print Operation Preview ) Is Selected ( page int ) bool { c : = C . gtk _print _operation _preview _is _selected ( pop . native ( ) , C . gint ( page ) ) return gobool ( c ) } 
func Print Settings New ( ) ( * Print Settings , error ) { c : = C . gtk _print _settings _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Print Settings ( obj ) , nil } 
func ( ps * Print Settings ) Copy ( ) ( * Print Settings , error ) { c : = C . gtk _print _settings _copy ( ps . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Print Settings ( obj ) , nil } 
func ( ps * Print Settings ) Has Key ( key string ) bool { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _has _key ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( ps * Print Settings ) Get ( key string ) string { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set ( key , value string ) { c Key : = C . CString ( key ) defer C . free ( unsafe . Pointer ( c Key ) ) c Value : = C . CString ( value ) defer C . free ( unsafe . Pointer ( c Value ) ) C . gtk _print _settings _set ( ps . native ( ) , ( * C . gchar ) ( c Key ) , ( * C . gchar ) ( c Value ) ) } 
func ( ps * Print Settings ) Unset ( key string ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _unset ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) For Each ( cb Print Settings Callback , user Data uintptr ) { print Settings Callback Registry . Lock ( ) id : = print Settings Callback Registry . next print Settings Callback Registry . next + + print Settings Callback Registry . m [ id ] = print Settings Callback Data { fn : cb , user Data : user Data } print Settings Callback Registry . Unlock ( ) C . _gtk _print _settings _foreach ( ps . native ( ) , C . gpointer ( uintptr ( id ) ) ) } 
func ( ps * Print Settings ) Get Bool ( key string ) bool { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _bool ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( ps * Print Settings ) Set Bool ( key string , value bool ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _bool ( ps . native ( ) , ( * C . gchar ) ( cstr ) , gbool ( value ) ) } 
func ( ps * Print Settings ) Get Double ( key string ) float 6 4 { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _double ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Get Double With Default ( key string , def float 6 4 ) float 6 4 { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _double _with _default ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( def ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Double ( key string , value float 6 4 ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _double ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) ) } 
func ( ps * Print Settings ) Get Length ( key string , unit Unit ) float 6 4 { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _length ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Length ( key string , value float 6 4 , unit Unit ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _length ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gdouble ( value ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Print Settings ) Get Int ( key string ) int { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _int ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) return int ( c ) } 
func ( ps * Print Settings ) Get Int With Default ( key string , def int ) int { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _print _settings _get _int _with _default ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( def ) ) return int ( c ) } 
func ( ps * Print Settings ) Set Int ( key string , value int ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _int ( ps . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( value ) ) } 
func ( ps * Print Settings ) Get Printer ( ) string { c : = C . gtk _print _settings _get _printer ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Printer ( printer string ) { cstr : = C . CString ( printer ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _printer ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) Get Orientation ( ) Page Orientation { c : = C . gtk _print _settings _get _orientation ( ps . native ( ) ) return Page Orientation ( c ) } 
func ( ps * Print Settings ) Set Orientation ( orientation Page Orientation ) { C . gtk _print _settings _set _orientation ( ps . native ( ) , C . Gtk Page Orientation ( orientation ) ) } 
func ( ps * Print Settings ) Get Paper Size ( ) ( * Paper Size , error ) { c : = C . gtk _print _settings _get _paper _size ( ps . native ( ) ) if c = = nil { return nil , nil Ptr Err } p : = & Paper Size { c } runtime . Set Finalizer ( p , ( * Paper Size ) . free ) return p , nil } 
func ( ps * Print Settings ) Set Paper Size ( size * Paper Size ) { C . gtk _print _settings _set _paper _size ( ps . native ( ) , size . native ( ) ) } 
func ( ps * Print Settings ) Get Paper Width ( unit Unit ) float 6 4 { c : = C . gtk _print _settings _get _paper _width ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Paper Width ( width float 6 4 , unit Unit ) { C . gtk _print _settings _set _paper _width ( ps . native ( ) , C . gdouble ( width ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Print Settings ) Get Paper Height ( unit Unit ) float 6 4 { c : = C . gtk _print _settings _get _paper _height ( ps . native ( ) , C . Gtk Unit ( unit ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Paper Height ( width float 6 4 , unit Unit ) { C . gtk _print _settings _set _paper _height ( ps . native ( ) , C . gdouble ( width ) , C . Gtk Unit ( unit ) ) } 
func ( ps * Print Settings ) Get Use Color ( ) bool { c : = C . gtk _print _settings _get _use _color ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * Print Settings ) Set Use Color ( color bool ) { C . gtk _print _settings _set _use _color ( ps . native ( ) , gbool ( color ) ) } 
func ( ps * Print Settings ) Get Collate ( ) bool { c : = C . gtk _print _settings _get _collate ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * Print Settings ) Set Collate ( collate bool ) { C . gtk _print _settings _set _collate ( ps . native ( ) , gbool ( collate ) ) } 
func ( ps * Print Settings ) Get Reverse ( ) bool { c : = C . gtk _print _settings _get _reverse ( ps . native ( ) ) return gobool ( c ) } 
func ( ps * Print Settings ) Set Reverse ( reverse bool ) { C . gtk _print _settings _set _reverse ( ps . native ( ) , gbool ( reverse ) ) } 
func ( ps * Print Settings ) Get Duplex ( ) Print Duplex { c : = C . gtk _print _settings _get _duplex ( ps . native ( ) ) return Print Duplex ( c ) } 
func ( ps * Print Settings ) Set Duplex ( duplex Print Duplex ) { C . gtk _print _settings _set _duplex ( ps . native ( ) , C . Gtk Print Duplex ( duplex ) ) } 
func ( ps * Print Settings ) Get Quality ( ) Print Quality { c : = C . gtk _print _settings _get _quality ( ps . native ( ) ) return Print Quality ( c ) } 
func ( ps * Print Settings ) Set Quality ( quality Print Quality ) { C . gtk _print _settings _set _quality ( ps . native ( ) , C . Gtk Print Quality ( quality ) ) } 
func ( ps * Print Settings ) Get NCopies ( ) int { c : = C . gtk _print _settings _get _n _copies ( ps . native ( ) ) return int ( c ) } 
func ( ps * Print Settings ) Set NCopies ( copies int ) { C . gtk _print _settings _set _n _copies ( ps . native ( ) , C . gint ( copies ) ) } 
func ( ps * Print Settings ) Get Nmber Up ( ) int { c : = C . gtk _print _settings _get _number _up ( ps . native ( ) ) return int ( c ) } 
func ( ps * Print Settings ) Set Number Up ( number Up int ) { C . gtk _print _settings _set _number _up ( ps . native ( ) , C . gint ( number Up ) ) } 
func ( ps * Print Settings ) Get Number Up Layout ( ) Number Up Layout { c : = C . gtk _print _settings _get _number _up _layout ( ps . native ( ) ) return Number Up Layout ( c ) } 
func ( ps * Print Settings ) Set Number Up Layout ( number Up Layout Number Up Layout ) { C . gtk _print _settings _set _number _up _layout ( ps . native ( ) , C . Gtk Number Up Layout ( number Up Layout ) ) } 
func ( ps * Print Settings ) Get Resolution ( ) int { c : = C . gtk _print _settings _get _resolution ( ps . native ( ) ) return int ( c ) } 
func ( ps * Print Settings ) Set Resolution ( resolution int ) { C . gtk _print _settings _set _resolution ( ps . native ( ) , C . gint ( resolution ) ) } 
func ( ps * Print Settings ) Set Resolution XY ( resolution X , resolution Y int ) { C . gtk _print _settings _set _resolution _xy ( ps . native ( ) , C . gint ( resolution X ) , C . gint ( resolution Y ) ) } 
func ( ps * Print Settings ) Get Resolution X ( ) int { c : = C . gtk _print _settings _get _resolution _x ( ps . native ( ) ) return int ( c ) } 
func ( ps * Print Settings ) Get Resolution Y ( ) int { c : = C . gtk _print _settings _get _resolution _y ( ps . native ( ) ) return int ( c ) } 
func ( ps * Print Settings ) Get Printer Lpi ( ) float 6 4 { c : = C . gtk _print _settings _get _printer _lpi ( ps . native ( ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Printer Lpi ( lpi float 6 4 ) { C . gtk _print _settings _set _printer _lpi ( ps . native ( ) , C . gdouble ( lpi ) ) } 
func ( ps * Print Settings ) Get Scale ( ) float 6 4 { c : = C . gtk _print _settings _get _scale ( ps . native ( ) ) return float 6 4 ( c ) } 
func ( ps * Print Settings ) Set Scale ( scale float 6 4 ) { C . gtk _print _settings _set _scale ( ps . native ( ) , C . gdouble ( scale ) ) } 
func ( ps * Print Settings ) Get Print Pages ( ) Print Pages { c : = C . gtk _print _settings _get _print _pages ( ps . native ( ) ) return Print Pages ( c ) } 
func ( ps * Print Settings ) Set Print Pages ( pages Print Pages ) { C . gtk _print _settings _set _print _pages ( ps . native ( ) , C . Gtk Print Pages ( pages ) ) } 
func ( ps * Print Settings ) Get Page Set ( pages Print Pages ) Page Set { c : = C . gtk _print _settings _get _page _set ( ps . native ( ) ) return Page Set ( c ) } 
func ( ps * Print Settings ) Set Page Set ( page Set Page Set ) { C . gtk _print _settings _set _page _set ( ps . native ( ) , C . Gtk Page Set ( page Set ) ) } 
func ( ps * Print Settings ) Get Default Source ( ) string { c : = C . gtk _print _settings _get _default _source ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Sefault Source ( default Source string ) { cstr : = C . CString ( default Source ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _default _source ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) Get Media Type ( ) string { c : = C . gtk _print _settings _get _media _type ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Media Type ( media Type string ) { cstr : = C . CString ( media Type ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _media _type ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) Get Dither ( ) string { c : = C . gtk _print _settings _get _dither ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Dither ( dither string ) { cstr : = C . CString ( dither ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _dither ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) Get Finishings ( ) string { c : = C . gtk _print _settings _get _finishings ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Finishings ( dither string ) { cstr : = C . CString ( dither ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _finishings ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( ps * Print Settings ) Get Output Bin ( ) string { c : = C . gtk _print _settings _get _output _bin ( ps . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( ps * Print Settings ) Set Output Bin ( bin string ) { cstr : = C . CString ( bin ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _print _settings _set _output _bin ( ps . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func Print Settings New From File ( name string ) ( * Print Settings , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c : = C . gtk _print _settings _new _from _file ( ( * C . gchar ) ( cstr ) , & err ) if c = = nil { defer C . g _error _free ( err ) return nil , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Print Settings ( obj ) , nil } 
func ( ps * Print Settings ) Load File ( name string ) error { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c : = C . gtk _print _settings _load _file ( ps . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if gobool ( c ) = = false { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func substring _match _equal _func ( model * C . Gtk Tree Model , column C . gint , key * C . gchar , iter * C . Gtk Tree Iter , data C . gpointer ) C . gboolean { go Model : = & Tree Model { glib . Take ( unsafe . Pointer ( model ) ) } go Iter : = & Tree Iter { ( C . Gtk Tree Iter ) ( * iter ) } value , err : = go Model . Get Value ( go Iter , int ( column ) ) if err ! = nil { return gbool ( true ) } str , _ : = value . Get String ( ) if str = = " " { return gbool ( true ) } sub Str : = C . Go String ( ( * C . char ) ( key ) ) res : = strings . Contains ( str , sub Str ) return gbool ( ! res ) } 
func go Builder Connect ( builder * C . Gtk Builder , object * C . GObject , signal _name * C . gchar , handler _name * C . gchar , connect _object * C . GObject , flags C . GConnect Flags , user _data C . gpointer ) { builder Signals . Lock ( ) signals , ok : = builder Signals . m [ builder ] builder Signals . Unlock ( ) if ! ok { panic ( " " ) } h : = C . Go String ( ( * C . char ) ( handler _name ) ) s : = C . Go String ( ( * C . char ) ( signal _name ) ) handler , ok : = signals [ h ] if ! ok { return } if object = = nil { panic ( " " ) } gobj . Connect ( s , handler ) } 
func go Page Setup Done ( setup * C . Gtk Page Setup , data C . gpointer ) { id : = int ( uintptr ( data ) ) page Setup Done Callback Registry . Lock ( ) r : = page Setup Done Callback Registry . m [ id ] delete ( page Setup Done Callback Registry . m , id ) page Setup Done Callback Registry . Unlock ( ) obj : = glib . Take ( unsafe . Pointer ( setup ) ) r . fn ( wrap Page Setup ( obj ) , r . data ) } 
func go Print Settings ( key * C . gchar , value * C . gchar , user Data C . gpointer ) { id : = int ( uintptr ( user Data ) ) print Settings Callback Registry . Lock ( ) r : = print Settings Callback Registry . m [ id ] r . fn ( C . Go String ( ( * C . char ) ( key ) ) , C . Go String ( ( * C . char ) ( value ) ) , r . user Data ) } 
func go Tree Model Filter Funcs ( filter * C . Gtk Tree Model Filter , iter * C . Gtk Tree Iter , data C . gpointer ) C . gboolean { id : = int ( uintptr ( data ) ) tree Model Visible Filter Func Registry . Lock ( ) r : = tree Model Visible Filter Func Registry . m [ id ] tree Model Visible Filter Func Registry . Unlock ( ) go Iter : = & Tree Iter { ( C . Gtk Tree Iter ) ( * iter ) } return gbool ( r . fn ( wrap Tree Model Filter ( glib . Take ( unsafe . Pointer ( filter ) ) ) , go Iter , r . user Data ) ) } 
func ( v * Dialog ) Get Action Area ( ) ( * Widget , error ) { c : = C . gtk _dialog _get _action _area ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Message Dialog ) Get Image ( ) ( * Widget , error ) { c : = C . gtk _message _dialog _get _image ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Message Dialog ) Set Image ( image IWidget ) { C . gtk _message _dialog _set _image ( v . native ( ) , image . to Widget ( ) ) } 
func ( v * Widget ) Get Margin Left ( ) int { c : = C . gtk _widget _get _margin _left ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) Set Margin Left ( margin int ) { C . gtk _widget _set _margin _left ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) Get Margin Right ( ) int { c : = C . gtk _widget _get _margin _right ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) Set Margin Right ( margin int ) { C . gtk _widget _set _margin _right ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * GLContext ) native ( ) * C . Gdk GLContext { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk GLContext ( p ) } 
func ( v * GLContext ) Get Display ( ) ( * Display , error ) { c : = C . gdk _gl _context _get _display ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) Get Surface ( ) ( * Window , error ) { c : = C . gdk _gl _context _get _window ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Window { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) Get Shared Context ( ) ( * GLContext , error ) { c : = C . gdk _gl _context _get _shared _context ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & GLContext { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * GLContext ) Get Version ( ) ( Major Version , Minor Version ) { var major , minor int C . gdk _gl _context _get _version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return Major Version ( major ) , Minor Version ( minor ) } 
func ( v * GLContext ) Get Required Version ( ) ( Major Version , Minor Version ) { var major , minor int C . gdk _gl _context _get _required _version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return Major Version ( major ) , Minor Version ( minor ) } 
func ( v * GLContext ) Set Required Version ( major , minor int ) { C . gdk _gl _context _set _required _version ( v . native ( ) , ( C . int ) ( major ) , ( C . int ) ( minor ) ) } 
func ( v * GLContext ) Set Debug Enabled ( enabled bool ) { C . gdk _gl _context _set _debug _enabled ( v . native ( ) , gbool ( enabled ) ) } 
func ( v * GLContext ) Set Forward Compatible ( compatible bool ) { C . gdk _gl _context _set _forward _compatible ( v . native ( ) , gbool ( compatible ) ) } 
func ( v * GLContext ) Realize ( ) ( bool , error ) { var err * C . GError r : = gobool ( C . gdk _gl _context _realize ( v . native ( ) , & err ) ) if ! r { defer C . g _error _free ( err ) return r , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return r , nil } 
func Get Current ( ) ( * GLContext , error ) { c : = C . gdk _gl _context _get _current ( ) if c = = nil { return nil , nil Ptr Err } return & GLContext { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Button Box ) native ( ) * C . Gtk Button Box { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Button Box ( p ) } 
func Button Box New ( o Orientation ) ( * Button Box , error ) { c : = C . gtk _button _box _new ( C . Gtk Orientation ( o ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Button Box ( obj ) , nil } 
func ( v * Button Box ) Get Layout ( ) Button Box Style { c : = C . gtk _button _box _get _layout ( v . native ( ) ) return Button Box Style ( c ) } 
func ( v * Button Box ) Get Child Secondary ( child IWidget ) bool { c : = C . gtk _button _box _get _child _secondary ( v . native ( ) , child . to Widget ( ) ) return gobool ( c ) } 
func ( v * Button Box ) Get Child Non Homogeneous ( child IWidget ) bool { c : = C . gtk _button _box _get _child _non _homogeneous ( v . native ( ) , child . to Widget ( ) ) return gobool ( c ) } 
func ( v * Button Box ) Set Layout ( style Button Box Style ) { C . gtk _button _box _set _layout ( v . native ( ) , C . Gtk Button Box Style ( style ) ) } 
func ( v * Button Box ) Set Child Secondary ( child IWidget , is Secondary bool ) { C . gtk _button _box _set _child _secondary ( v . native ( ) , child . to Widget ( ) , gbool ( is Secondary ) ) } 
func ( v * Button Box ) Set Child Non Homogeneous ( child IWidget , non Homogeneous bool ) { C . gtk _button _box _set _child _non _homogeneous ( v . native ( ) , child . to Widget ( ) , gbool ( non Homogeneous ) ) } 
func ( t * Tooltip ) native ( ) * C . Gtk Tooltip { if t = = nil | | t . GObject = = nil { return nil } p : = unsafe . Pointer ( t . GObject ) return C . to Gtk Tooltip ( p ) } 
func ( t * Tooltip ) Set Markup ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tooltip _set _markup ( t . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( t * Tooltip ) Set Text ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tooltip _set _text ( t . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( t * Tooltip ) Set Icon ( pixbuf * gdk . Pixbuf ) { C . gtk _tooltip _set _icon ( t . native ( ) , ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( t * Tooltip ) Set Icon From Icon Name ( icon Name string , size Icon Size ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tooltip _set _icon _from _icon _name ( t . native ( ) , ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) } 
func ( t * Tooltip ) Set Custom ( w * Widget ) { C . gtk _tooltip _set _custom ( t . native ( ) , w . native ( ) ) } 
func ( t * Tooltip ) Set Tip Area ( rect gdk . Rectangle ) { C . gtk _tooltip _set _tip _area ( t . native ( ) , native Gdk Rectangle ( rect ) ) } 
func ( v * Device ) Grab ( w * Window , ownership Grab Ownership , owner _events bool , event _mask Event Mask , cursor * Cursor , time uint 3 2 ) Grab Status { ret : = C . gdk _device _grab ( v . native ( ) , w . native ( ) , C . Gdk Grab Ownership ( ownership ) , gbool ( owner _events ) , C . Gdk Event Mask ( event _mask ) , cursor . native ( ) , C . guint 3 2 ( time ) , ) return Grab Status ( ret ) } 
func ( v * Device Manager ) Get Client Pointer ( ) ( * Device , error ) { c : = C . gdk _device _manager _get _client _pointer ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Device { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Device Manager ) List Devices ( tp Device Type ) * glib . List { clist : = C . gdk _device _manager _list _devices ( v . native ( ) , C . Gdk Device Type ( tp ) ) if clist = = nil { return nil } glist . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return & Device { & glib . Object { glib . To GObject ( ptr ) } } } ) runtime . Set Finalizer ( glist , func ( glist * glib . List ) { glist . Free ( ) } ) return glist } 
func ( v * Device ) Ungrab ( time uint 3 2 ) { C . gdk _device _ungrab ( v . native ( ) , C . guint 3 2 ( time ) ) } 
func ( v * Display ) Get Device Manager ( ) ( * Device Manager , error ) { c : = C . gdk _display _get _device _manager ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Device Manager { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) Get Screen ( screen Num int ) ( * Screen , error ) { c : = C . gdk _display _get _screen ( v . native ( ) , C . gint ( screen Num ) ) if c = = nil { return nil , nil Ptr Err } return & Screen { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Window ) Set Titlebar ( titlebar IWidget ) { C . gtk _window _set _titlebar ( v . native ( ) , titlebar . to Widget ( ) ) } 
func ( v * Text Iter ) native ( ) * C . Gtk Text Iter { if v = = nil { return nil } return ( * C . Gtk Text Iter ) ( v ) } 
func ( v * Text Iter ) Get Buffer ( ) * Text Buffer { c : = C . gtk _text _iter _get _buffer ( v . native ( ) ) if c = = nil { return nil } return wrap Text Buffer ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Text Iter ) Get Slice ( end * Text Iter ) string { c : = C . gtk _text _iter _get _slice ( v . native ( ) , end . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Text Iter ) Get Text ( end * Text Iter ) string { c : = C . gtk _text _iter _get _text ( v . native ( ) , end . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Text Iter ) Get Visible Slice ( end * Text Iter ) string { c : = C . gtk _text _iter _get _visible _slice ( v . native ( ) , end . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Text Iter ) Get Visible Text ( end * Text Iter ) string { c : = C . gtk _text _iter _get _visible _text ( v . native ( ) , end . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Text Iter ) Ends Tag ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _ends _tag ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Toggles Tag ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _toggles _tag ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Has Tag ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _has _tag ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Editable ( v 1 bool ) bool { return gobool ( C . gtk _text _iter _editable ( v . native ( ) , gbool ( v 1 ) ) ) } 
func ( v * Text Iter ) Can Insert ( v 1 bool ) bool { return gobool ( C . gtk _text _iter _can _insert ( v . native ( ) , gbool ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Chars ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _chars ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Backward Chars ( v 1 int ) bool { return gobool ( C . gtk _text _iter _backward _chars ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Lines ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _lines ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Backward Lines ( v 1 int ) bool { return gobool ( C . gtk _text _iter _backward _lines ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Word Ends ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _word _ends ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Cursor Positions ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _cursor _positions ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Backward Cursor Positions ( v 1 int ) bool { return gobool ( C . gtk _text _iter _backward _cursor _positions ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Sentence Ends ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _sentence _ends ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Visible Cursor Positions ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _visible _cursor _positions ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Backward Visible Cursor Positions ( v 1 int ) bool { return gobool ( C . gtk _text _iter _backward _visible _cursor _positions ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Forward Visible Lines ( v 1 int ) bool { return gobool ( C . gtk _text _iter _forward _visible _lines ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Backward Visible Lines ( v 1 int ) bool { return gobool ( C . gtk _text _iter _backward _visible _lines ( v . native ( ) , C . gint ( v 1 ) ) ) } 
func ( v * Text Iter ) Set Offset ( v 1 int ) { C . gtk _text _iter _set _offset ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Set Line ( v 1 int ) { C . gtk _text _iter _set _line ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Set Line Offset ( v 1 int ) { C . gtk _text _iter _set _line _offset ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Set Line Index ( v 1 int ) { C . gtk _text _iter _set _line _index ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Set Visible Line Offset ( v 1 int ) { C . gtk _text _iter _set _visible _line _offset ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Set Visible Line Index ( v 1 int ) { C . gtk _text _iter _set _visible _line _index ( v . native ( ) , C . gint ( v 1 ) ) } 
func ( v * Text Iter ) Forward To Tag Toggle ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _forward _to _tag _toggle ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Backward To Tag Toggle ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _backward _to _tag _toggle ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Equal ( v 1 * Text Iter ) bool { return gobool ( C . gtk _text _iter _equal ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) Compare ( v 1 * Text Iter ) int { return int ( C . gtk _text _iter _compare ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Text Iter ) In Range ( v 1 * Text Iter , v 2 * Text Iter ) bool { return gobool ( C . gtk _text _iter _in _range ( v . native ( ) , v 1 . native ( ) , v 2 . native ( ) ) ) } 
func ( v * Main Context ) native ( ) * C . GMain Context { if v = = nil { return nil } return ( * C . GMain Context ) ( v ) } 
func Main Context Default ( ) * Main Context { c : = C . g _main _context _default ( ) if c = = nil { return nil } return ( * Main Context ) ( c ) } 
func ( v * Tree View Column ) native ( ) * C . Gtk Tree View Column { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tree View Column ( p ) } 
func Tree View Column New ( ) ( * Tree View Column , error ) { c : = C . gtk _tree _view _column _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Tree View Column ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Tree View Column New With Attribute ( title string , renderer ICell Renderer , attribute string , column int ) ( * Tree View Column , error ) { t _cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( t _cstr ) ) a _cstr : = C . CString ( attribute ) defer C . free ( unsafe . Pointer ( a _cstr ) ) c : = C . _gtk _tree _view _column _new _with _attributes _one ( ( * C . gchar ) ( t _cstr ) , renderer . to Cell Renderer ( ) , ( * C . gchar ) ( a _cstr ) , C . gint ( column ) ) if c = = nil { return nil , nil Ptr Err } return wrap Tree View Column ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Tree View Column ) Add Attribute ( renderer ICell Renderer , attribute string , column int ) { cstr : = C . CString ( attribute ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tree _view _column _add _attribute ( v . native ( ) , renderer . to Cell Renderer ( ) , ( * C . gchar ) ( cstr ) , C . gint ( column ) ) } 
func ( v * Tree View Column ) Set Expand ( expand bool ) { C . gtk _tree _view _column _set _expand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * Tree View Column ) Get Expand ( ) bool { c : = C . gtk _tree _view _column _get _expand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tree View Column ) Set Min Width ( min Width int ) { C . gtk _tree _view _column _set _min _width ( v . native ( ) , C . gint ( min Width ) ) } 
func ( v * Tree View Column ) Get Min Width ( ) int { c : = C . gtk _tree _view _column _get _min _width ( v . native ( ) ) return int ( c ) } 
func ( v * Tree View Column ) Pack Start ( cell ICell Renderer , expand bool ) { C . gtk _tree _view _column _pack _start ( v . native ( ) , cell . to Cell Renderer ( ) , gbool ( expand ) ) } 
func ( v * Tree View Column ) Pack End ( cell ICell Renderer , expand bool ) { C . gtk _tree _view _column _pack _end ( v . native ( ) , cell . to Cell Renderer ( ) , gbool ( expand ) ) } 
func ( v * Tree View Column ) Clear Attributes ( cell * Cell Renderer ) { C . gtk _tree _view _column _clear _attributes ( v . native ( ) , cell . native ( ) ) } 
func ( v * Tree View Column ) Set Spacing ( spacing int ) { C . gtk _tree _view _column _set _spacing ( v . native ( ) , C . gint ( spacing ) ) } 
func ( v * Tree View Column ) Set Visible ( visible bool ) { C . gtk _tree _view _column _set _visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Tree View Column ) Set Fixed Width ( w int ) { C . gtk _tree _view _column _set _fixed _width ( v . native ( ) , C . gint ( w ) ) } 
func ( v * Tree View Column ) Set Title ( t string ) { cstr : = ( * C . gchar ) ( C . CString ( t ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tree _view _column _set _title ( v . native ( ) , cstr ) } 
func ( v * Tree View Column ) Get Title ( ) string { return C . Go String ( ( * C . char ) ( C . gtk _tree _view _column _get _title ( v . native ( ) ) ) ) } 
func ( v * Tree View Column ) Set Reorderable ( reorderable bool ) { C . gtk _tree _view _column _set _reorderable ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * Tree View Column ) Set Sort Indicator ( reorderable bool ) { C . gtk _tree _view _column _set _sort _indicator ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * Tree View Column ) Set Sort Column ID ( w int ) { C . gtk _tree _view _column _set _sort _column _id ( v . native ( ) , C . gint ( w ) ) } 
func ( v * Tree View Column ) Focus Cell ( cell * Cell Renderer ) { C . gtk _tree _view _column _focus _cell ( v . native ( ) , cell . native ( ) ) } 
func ( v * Tree View Column ) Set Sizing ( sizing Tree View Column Sizing ) { C . gtk _tree _view _column _set _sizing ( v . native ( ) , C . Gtk Tree View Column Sizing ( sizing ) ) } 
func ( v * Tree View Column ) Set Widget ( widget IWidget ) { C . gtk _tree _view _column _set _widget ( v . native ( ) , widget . to Widget ( ) ) } 
func ( v * Tree View Column ) Get Widget ( ) ( * Widget , error ) { widget : = C . gtk _tree _view _column _get _widget ( v . native ( ) ) if widget = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( widget ) ) return wrap Widget ( obj ) , nil } 
func ( v * Tree View Column ) Set Sort Order ( order Sort Type ) { C . gtk _tree _view _column _set _sort _order ( v . native ( ) , C . Gtk Sort Type ( order ) ) } 
func ( v * Variant Iter ) native ( ) * C . GVariant Iter { if v = = nil | | v . GVariant Iter = = nil { return nil } p : = unsafe . Pointer ( v . GVariant Iter ) return C . to GVariant Iter ( p ) } 
func ( v * SList ) Next ( ) * SList { n : = v . native ( ) if n = = nil { return nil } return wrap SList ( n . next ) } 
func ( v * SList ) Foreach ( fn func ( ptr unsafe . Pointer ) ) { for l : = v ; l ! = nil ; l = l . Next ( ) { fn ( unsafe . Pointer ( l . native ( ) . data ) ) } } 
func ( v * SList ) Free ( ) { C . g _slist _free ( v . native ( ) ) v . list = nil } 
func ( v * SList ) Free Full ( ) { v . list = nil } 
func ( v * Application ) Get Accels For Action ( act string ) [ ] string { cstr 1 : = ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) var descs [ ] string c : = C . gtk _application _get _accels _for _action ( v . native ( ) , cstr 1 ) originalc : = c defer C . g _strfreev ( originalc ) for * c ! = nil { descs = append ( descs , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return descs } 
func ( v * Application ) Set Accels For Action ( act string , accels [ ] string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( act ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) caccels : = C . make _strings ( C . int ( len ( accels ) + 1 ) ) defer C . destroy _strings ( caccels ) for i , accel : = range accels { cstr : = C . CString ( accel ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set _string ( caccels , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set _string ( caccels , C . int ( len ( accels ) ) , nil ) C . gtk _application _set _accels _for _action ( v . native ( ) , cstr 1 , caccels ) } 
func ( v * Application ) List Action Descriptions ( ) [ ] string { var descs [ ] string c : = C . gtk _application _list _action _descriptions ( v . native ( ) ) originalc : = c defer C . g _strfreev ( originalc ) for * c ! = nil { descs = append ( descs , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return descs } 
func ( v * Settings ) native ( ) * C . GSettings { if v = = nil | | v . GObject = = nil { return nil } return C . to GSettings ( unsafe . Pointer ( v . GObject ) ) } 
func Settings New ( schema ID string ) * Settings { cstr : = ( * C . gchar ) ( C . CString ( schema ID ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrap Full Settings ( C . g _settings _new ( cstr ) ) } 
func Settings New With Path ( schema ID , path string ) * Settings { cstr 1 : = ( * C . gchar ) ( C . CString ( schema ID ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) return wrap Full Settings ( C . g _settings _new _with _path ( cstr 1 , cstr 2 ) ) } 
func Settings New With Backend ( schema ID string , backend * Settings Backend ) * Settings { cstr 1 : = ( * C . gchar ) ( C . CString ( schema ID ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return wrap Full Settings ( C . g _settings _new _with _backend ( cstr 1 , backend . native ( ) ) ) } 
func Settings New With Backend And Path ( schema ID string , backend * Settings Backend , path string ) * Settings { cstr 1 : = ( * C . gchar ) ( C . CString ( schema ID ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) return wrap Full Settings ( C . g _settings _new _with _backend _and _path ( cstr 1 , backend . native ( ) , cstr 2 ) ) } 
func Settings New Full ( schema * Settings Schema , backend * Settings Backend , path string ) * Settings { cstr 1 : = ( * C . gchar ) ( C . CString ( path ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return wrap Full Settings ( C . g _settings _new _full ( schema . native ( ) , backend . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Is Writable ( name string ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _is _writable ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Get Child ( name string ) * Settings { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return wrap Full Settings ( C . g _settings _get _child ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Reset ( name string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _settings _reset ( v . native ( ) , cstr 1 ) } 
func ( v * Settings ) Get Boolean ( name string ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _get _boolean ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Set Boolean ( name string , value bool ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _set _boolean ( v . native ( ) , cstr 1 , gbool ( value ) ) ) } 
func ( v * Settings ) Get Int ( name string ) int { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return int ( C . g _settings _get _int ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Set Int ( name string , value int ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _set _int ( v . native ( ) , cstr 1 , C . gint ( value ) ) ) } 
func ( v * Settings ) Get UInt ( name string ) uint { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return uint ( C . g _settings _get _uint ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Set UInt ( name string , value uint ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _set _uint ( v . native ( ) , cstr 1 , C . guint ( value ) ) ) } 
func ( v * Settings ) Get Double ( name string ) float 6 4 { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return float 6 4 ( C . g _settings _get _double ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Set Double ( name string , value float 6 4 ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return gobool ( C . g _settings _set _double ( v . native ( ) , cstr 1 , C . gdouble ( value ) ) ) } 
func ( v * Settings ) Get String ( name string ) string { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return C . Go String ( ( * C . char ) ( C . g _settings _get _string ( v . native ( ) , cstr 1 ) ) ) } 
func ( v * Settings ) Set String ( name string , value string ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( value ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) return gobool ( C . g _settings _set _string ( v . native ( ) , cstr 1 , cstr 2 ) ) } 
func ( v * Settings ) Get Enum ( name string ) int { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return int ( C . g _settings _get _enum ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Get Strv ( name string ) [ ] string { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return to Go String Array ( C . g _settings _get _strv ( v . native ( ) , cstr 1 ) ) } 
func ( v * Settings ) Set Strv ( name string , values [ ] string ) bool { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cvalues : = make ( [ ] * C . gchar , len ( values ) ) for i , accel : = range values { cvalues [ i ] = ( * C . gchar ) ( C . CString ( accel ) ) defer C . free ( unsafe . Pointer ( cvalues [ i ] ) ) } cvalues = append ( cvalues , nil ) return gobool ( C . g _settings _set _strv ( v . native ( ) , cstr 1 , & cvalues [ 0 ] ) ) } 
func ( v * Settings ) Get Flags ( name string ) uint { cstr 1 : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) return uint ( C . g _settings _get _flags ( v . native ( ) , cstr 1 ) ) } 
func ( v * Action Map ) native ( ) * C . GAction Map { if v = = nil | | v . GObject = = nil { return nil } return C . to GAction Map ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * Action Map ) Lookup Action ( action Name string ) * Action { c : = C . g _action _map _lookup _action ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) if c = = nil { return nil } return wrap Action ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Action Map ) Add Action ( action IAction ) { C . g _action _map _add _action ( v . native ( ) , action . to GAction ( ) ) } 
func ( v * Action Map ) Remove Action ( action Name string ) { C . g _action _map _remove _action ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) } 
func ( v * Menu ) Popup At Mouse Cursor ( parent Menu Shell IMenu , parent Menu Item IMenu Item , button int , activate Time uint 3 2 ) { wshell : = nullable Widget ( parent Menu Shell ) witem : = nullable Widget ( parent Menu Item ) C . gtk _menu _popup ( v . native ( ) , wshell , witem , nil , nil , C . guint ( button ) , C . guint 3 2 ( activate Time ) ) } 
func ( v * Window ) Set WMClass ( name , class string ) { c Name : = C . CString ( name ) defer C . free ( unsafe . Pointer ( c Name ) ) c Class : = C . CString ( class ) defer C . free ( unsafe . Pointer ( c Class ) ) C . gtk _window _set _wmclass ( v . native ( ) , ( * C . gchar ) ( c Name ) , ( * C . gchar ) ( c Class ) ) } 
func ( v * Font Button ) Get Font Name ( ) string { c : = C . gtk _font _button _get _font _name ( v . native ( ) ) return go String ( c ) } 
func ( v * Font Button ) Set Font Name ( fontname string ) bool { cstr : = C . CString ( fontname ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _font _button _set _font _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( v * Context ) Show Text ( utf 8 string ) { cstr : = C . CString ( utf 8 ) defer C . free ( unsafe . Pointer ( cstr ) ) C . cairo _show _text ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func Create Image Surface ( format Format , width , height int ) * Surface { c : = C . cairo _image _surface _create ( C . cairo _format _t ( format ) , C . int ( width ) , C . int ( height ) ) s : = wrap Surface ( c ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s } 
func Create PDFSurface ( file Name string , width float 6 4 , height float 6 4 ) ( * Surface , error ) { cstr : = C . CString ( file Name ) defer C . free ( unsafe . Pointer ( cstr ) ) surface Native : = C . cairo _pdf _surface _create ( cstr , C . double ( width ) , C . double ( height ) ) status : = Status ( C . cairo _surface _status ( surface Native ) ) if status ! = STATUS _SUCCESS { return nil , Error Status ( status ) } s : = wrap Surface ( surface Native ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s , nil } 
func ( v * Surface ) native ( ) * C . cairo _surface _t { if v = = nil { return nil } return v . surface } 
func New Surface ( s uintptr , needs Ref bool ) * Surface { surface : = Wrap Surface ( s ) if needs Ref { surface . reference ( ) } runtime . Set Finalizer ( surface , ( * Surface ) . destroy ) return surface } 
func ( v * Surface ) Create Similar ( content Content , width , height int ) * Surface { c : = C . cairo _surface _create _similar ( v . native ( ) , C . cairo _content _t ( content ) , C . int ( width ) , C . int ( height ) ) s : = wrap Surface ( c ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Surface ) Create For Rectangle ( x , y , width , height float 6 4 ) * Surface { c : = C . cairo _surface _create _for _rectangle ( v . native ( ) , C . double ( x ) , C . double ( y ) , C . double ( width ) , C . double ( height ) ) s : = wrap Surface ( c ) runtime . Set Finalizer ( s , ( * Surface ) . destroy ) return s } 
func ( v * Surface ) destroy ( ) { if v . surface ! = nil { C . cairo _surface _destroy ( v . native ( ) ) v . surface = nil } } 
func ( v * Surface ) Status ( ) Status { c : = C . cairo _surface _status ( v . native ( ) ) return Status ( c ) } 
func ( v * Surface ) Mark Dirty Rectangle ( x , y , width , height int ) { C . cairo _surface _mark _dirty _rectangle ( v . native ( ) , C . int ( x ) , C . int ( y ) , C . int ( width ) , C . int ( height ) ) } 
func ( v * Surface ) Set Device Offset ( x , y float 6 4 ) { C . cairo _surface _set _device _offset ( v . native ( ) , C . double ( x ) , C . double ( y ) ) } 
func ( v * Surface ) Get Device Offset ( ) ( x , y float 6 4 ) { var x Offset , y Offset C . double C . cairo _surface _get _device _offset ( v . native ( ) , & x Offset , & y Offset ) return float 6 4 ( x Offset ) , float 6 4 ( y Offset ) } 
func ( v * Surface ) Set Fallback Resolution ( x PPI , y PPI float 6 4 ) { C . cairo _surface _set _fallback _resolution ( v . native ( ) , C . double ( x PPI ) , C . double ( y PPI ) ) } 
func ( v * Surface ) Get Fallback Resolution ( ) ( x PPI , y PPI float 6 4 ) { var x , y C . double C . cairo _surface _get _fallback _resolution ( v . native ( ) , & x , & y ) return float 6 4 ( x ) , float 6 4 ( y ) } 
func ( v * Surface ) Get Type ( ) Surface Type { c : = C . cairo _surface _get _type ( v . native ( ) ) return Surface Type ( c ) } 
func ( v * Surface ) Has Show Text Glyphs ( ) bool { c : = C . cairo _surface _has _show _text _glyphs ( v . native ( ) ) return gobool ( c ) } 
func ( v * Surface ) Get Mime Data ( mime Type Mime Type ) [ ] byte { cstr : = C . CString ( string ( mime Type ) ) defer C . free ( unsafe . Pointer ( cstr ) ) var data * C . uchar var length C . ulong C . cairo _surface _get _mime _data ( v . native ( ) , cstr , & data , & length ) return C . Go Bytes ( unsafe . Pointer ( data ) , C . int ( length ) ) } 
func ( v * Surface ) Write To PNG ( file Name string ) error { cstr : = C . CString ( file Name ) defer C . free ( unsafe . Pointer ( cstr ) ) status : = Status ( C . cairo _surface _write _to _png ( v . surface , cstr ) ) if status ! = STATUS _SUCCESS { return Error Status ( status ) } return nil } 
func ( v * Surface ) Get Data ( ) unsafe . Pointer { return unsafe . Pointer ( C . cairo _image _surface _get _data ( v . surface ) ) } 
func Fixed New ( ) ( * Fixed , error ) { c : = C . gtk _fixed _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Fixed ( obj ) , nil } 
func ( v * Fixed ) Put ( w IWidget , x , y int ) { C . gtk _fixed _put ( v . native ( ) , w . to Widget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Fixed ) Move ( w IWidget , x , y int ) { C . gtk _fixed _move ( v . native ( ) , w . to Widget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * About Dialog ) native ( ) * C . Gtk About Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk About Dialog ( p ) } 
func About Dialog New ( ) ( * About Dialog , error ) { c : = C . gtk _about _dialog _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap About Dialog ( obj ) , nil } 
func ( v * About Dialog ) Get Comments ( ) string { c : = C . gtk _about _dialog _get _comments ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Comments ( comments string ) { cstr : = C . CString ( comments ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _comments ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Copyright ( ) string { c : = C . gtk _about _dialog _get _copyright ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Copyright ( copyright string ) { cstr : = C . CString ( copyright ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _copyright ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get License ( ) string { c : = C . gtk _about _dialog _get _license ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set License ( license string ) { cstr : = C . CString ( license ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _license ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get License Type ( ) License { c : = C . gtk _about _dialog _get _license _type ( v . native ( ) ) return License ( c ) } 
func ( v * About Dialog ) Set License Type ( license License ) { C . gtk _about _dialog _set _license _type ( v . native ( ) , C . Gtk License ( license ) ) } 
func ( v * About Dialog ) Get Logo ( ) ( * gdk . Pixbuf , error ) { c : = C . gtk _about _dialog _get _logo ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } p : = & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * About Dialog ) Set Logo ( logo * gdk . Pixbuf ) { logo Ptr : = ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( logo . Native ( ) ) ) C . gtk _about _dialog _set _logo ( v . native ( ) , logo Ptr ) } 
func ( v * About Dialog ) Get Logo Icon Name ( ) string { c : = C . gtk _about _dialog _get _logo _icon _name ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Logo Icon Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _logo _icon _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Program Name ( ) string { c : = C . gtk _about _dialog _get _program _name ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Program Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _program _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Authors ( ) [ ] string { var authors [ ] string cauthors : = C . gtk _about _dialog _get _authors ( v . native ( ) ) if cauthors = = nil { return nil } for { if * cauthors = = nil { break } authors = append ( authors , C . Go String ( ( * C . char ) ( * cauthors ) ) ) cauthors = C . next _gcharptr ( cauthors ) } return authors } 
func ( v * About Dialog ) Set Authors ( authors [ ] string ) { cauthors : = C . make _strings ( C . int ( len ( authors ) + 1 ) ) for i , author : = range authors { cstr : = C . CString ( author ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set _string ( cauthors , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set _string ( cauthors , C . int ( len ( authors ) ) , nil ) C . gtk _about _dialog _set _authors ( v . native ( ) , cauthors ) C . destroy _strings ( cauthors ) } 
func ( v * About Dialog ) Get Artists ( ) [ ] string { var artists [ ] string cartists : = C . gtk _about _dialog _get _artists ( v . native ( ) ) if cartists = = nil { return nil } for { if * cartists = = nil { break } artists = append ( artists , C . Go String ( ( * C . char ) ( * cartists ) ) ) cartists = C . next _gcharptr ( cartists ) } return artists } 
func ( v * About Dialog ) Set Artists ( artists [ ] string ) { cartists : = C . make _strings ( C . int ( len ( artists ) + 1 ) ) for i , artist : = range artists { cstr : = C . CString ( artist ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set _string ( cartists , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set _string ( cartists , C . int ( len ( artists ) ) , nil ) C . gtk _about _dialog _set _artists ( v . native ( ) , cartists ) C . destroy _strings ( cartists ) } 
func ( v * About Dialog ) Get Documenters ( ) [ ] string { var documenters [ ] string cdocumenters : = C . gtk _about _dialog _get _documenters ( v . native ( ) ) if cdocumenters = = nil { return nil } for { if * cdocumenters = = nil { break } documenters = append ( documenters , C . Go String ( ( * C . char ) ( * cdocumenters ) ) ) cdocumenters = C . next _gcharptr ( cdocumenters ) } return documenters } 
func ( v * About Dialog ) Set Documenters ( documenters [ ] string ) { cdocumenters : = C . make _strings ( C . int ( len ( documenters ) + 1 ) ) for i , doc : = range documenters { cstr : = C . CString ( doc ) defer C . free ( unsafe . Pointer ( cstr ) ) C . set _string ( cdocumenters , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } C . set _string ( cdocumenters , C . int ( len ( documenters ) ) , nil ) C . gtk _about _dialog _set _documenters ( v . native ( ) , cdocumenters ) C . destroy _strings ( cdocumenters ) } 
func ( v * About Dialog ) Get Translator Credits ( ) string { c : = C . gtk _about _dialog _get _translator _credits ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Translator Credits ( translator Credits string ) { cstr : = C . CString ( translator Credits ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _translator _credits ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Version ( ) string { c : = C . gtk _about _dialog _get _version ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Version ( version string ) { cstr : = C . CString ( version ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _version ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Website ( ) string { c : = C . gtk _about _dialog _get _website ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Website ( website string ) { cstr : = C . CString ( website ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _website ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Get Website Label ( ) string { c : = C . gtk _about _dialog _get _website _label ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * About Dialog ) Set Website Label ( website Label string ) { cstr : = C . CString ( website Label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _about _dialog _set _website _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * About Dialog ) Set Wrap License ( wrap License bool ) { C . gtk _about _dialog _set _wrap _license ( v . native ( ) , gbool ( wrap License ) ) } 
func ( v * About Dialog ) Add Credit Section ( section Name string , people [ ] string ) { cname : = ( * C . gchar ) ( C . CString ( section Name ) ) defer C . free ( unsafe . Pointer ( cname ) ) cpeople : = C . make _strings ( C . int ( len ( people ) ) + 1 ) defer C . destroy _strings ( cpeople ) for i , p : = range people { cp : = ( * C . gchar ) ( C . CString ( p ) ) defer C . free ( unsafe . Pointer ( cp ) ) C . set _string ( cpeople , C . int ( i ) , cp ) } C . set _string ( cpeople , C . int ( len ( people ) ) , nil ) C . gtk _about _dialog _add _credit _section ( v . native ( ) , cname , cpeople ) } 
func Add Font ( font Path string ) { path : = ( * C . uchar ) ( unsafe . Pointer ( C . CString ( font Path ) ) ) C . add Font ( path ) } 
func marshal Font Description ( p uintptr ) ( interface { } , error ) { c : = C . g _value _get _boxed ( ( * C . GValue ) ( unsafe . Pointer ( p ) ) ) c 2 : = ( * C . Pango Font Description ) ( unsafe . Pointer ( c ) ) return wrap Font Description ( c 2 ) , nil } 
func Font Description New ( ) * Font Description { c : = C . pango _font _description _new ( ) v : = new ( Font Description ) v . pango Font Description = c return v } 
func ( v * Font Description ) Copy ( ) * Font Description { c : = C . pango _font _description _copy ( v . native ( ) ) v 2 : = new ( Font Description ) v 2 . pango Font Description = c return v 2 } 
func ( v * Font Description ) Copy Static ( ) * Font Description { c : = C . pango _font _description _copy _static ( v . native ( ) ) v 2 : = new ( Font Description ) v 2 . pango Font Description = c return v 2 } 
func ( v * Font Description ) Hash ( ) uint { c : = C . pango _font _description _hash ( v . native ( ) ) return uint ( c ) } 
func ( v * Font Description ) Equal ( v 2 * Font Description ) bool { c : = C . pango _font _description _equal ( v . native ( ) , v 2 . native ( ) ) return gobool ( c ) } 
func ( v * Font Description ) Set Family ( family string ) { cstr : = C . CString ( family ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango _font _description _set _family ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * Font Description ) Set Family Static ( family string ) { cstr : = C . CString ( family ) defer C . free ( unsafe . Pointer ( cstr ) ) C . pango _font _description _set _family _static ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * Font Description ) Get Family ( ) string { c : = C . pango _font _description _get _family ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Font Description ) Set Style ( style Style ) { C . pango _font _description _set _style ( v . native ( ) , ( C . Pango Style ) ( style ) ) } 
func ( v * Font Description ) Get Style ( ) Style { c : = C . pango _font _description _get _style ( v . native ( ) ) return Style ( c ) } 
func ( v * Font Description ) Set Weight ( weight Weight ) { C . pango _font _description _set _weight ( v . native ( ) , ( C . Pango Weight ) ( weight ) ) } 
func ( v * Font Description ) Get Weight ( ) Weight { c : = C . pango _font _description _get _weight ( v . native ( ) ) return Weight ( c ) } 
func ( v * Font Description ) Set Stretch ( stretch Stretch ) { C . pango _font _description _set _stretch ( v . native ( ) , ( C . Pango Stretch ) ( stretch ) ) } 
func ( v * Font Description ) Get Stretch ( ) Stretch { c : = C . pango _font _description _get _stretch ( v . native ( ) ) return Stretch ( c ) } 
func ( v * Font Description ) Set Size ( size int ) { C . pango _font _description _set _size ( v . native ( ) , ( C . gint ) ( size ) ) } 
func ( v * Font Description ) Get Size ( ) int { c : = C . pango _font _description _get _size ( v . native ( ) ) return int ( c ) } 
func ( v * Font Description ) Set Absolute Size ( size float 6 4 ) { C . pango _font _description _set _absolute _size ( v . native ( ) , ( C . double ) ( size ) ) } 
func ( v * Font Description ) Get Size Is Absolute ( ) bool { c : = C . pango _font _description _get _size _is _absolute ( v . native ( ) ) return gobool ( c ) } 
func ( v * Font Description ) Set Gravity ( gravity Gravity ) { C . pango _font _description _set _gravity ( v . native ( ) , ( C . Pango Gravity ) ( gravity ) ) } 
func ( v * Font Description ) Get Gravity ( ) Gravity { c : = C . pango _font _description _get _gravity ( v . native ( ) ) return Gravity ( c ) } 
func ( v * Font Description ) Get Set Fields ( ) Font Mask { c : = C . pango _font _description _get _set _fields ( v . native ( ) ) return Font Mask ( c ) } 
func ( v * Font Description ) Get Unset Fields ( to _unset Font Mask ) { C . pango _font _description _unset _fields ( v . native ( ) , ( C . Pango Font Mask ) ( to _unset ) ) } 
func ( v * Font Description ) Merge ( desc _to _merge * Font Description , replace _existing bool ) { C . pango _font _description _merge ( v . native ( ) , desc _to _merge . native ( ) , gbool ( replace _existing ) ) } 
func ( v * Font Description ) Merge Static ( desc _to _merge * Font Description , replace _existing bool ) { C . pango _font _description _merge _static ( v . native ( ) , desc _to _merge . native ( ) , gbool ( replace _existing ) ) } 
func ( v * Font Description ) Better Match ( old _match , new _match * Font Description ) bool { c : = C . pango _font _description _better _match ( v . native ( ) , old _match . native ( ) , new _match . native ( ) ) return gobool ( c ) } 
func Font Description From String ( str string ) * Font Description { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . pango _font _description _from _string ( ( * C . char ) ( cstr ) ) v : = new ( Font Description ) v . pango Font Description = c return v } 
func ( v * Font Description ) To String ( ) string { c : = C . pango _font _description _to _string ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Font Description ) To Filename ( ) string { c : = C . pango _font _description _to _filename ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Button ) Get Focus On Click ( ) bool { c : = C . gtk _button _get _focus _on _click ( v . native ( ) ) return gobool ( c ) } 
func ( v * Text Iter ) Begins Tag ( v 1 * Text Tag ) bool { return gobool ( C . gtk _text _iter _begins _tag ( v . native ( ) , v 1 . native ( ) ) ) } 
func ( v * Window ) Resize To Geometry ( width , height int ) { C . gtk _window _resize _to _geometry ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Window ) Set Default Geometry ( width , height int ) { C . gtk _window _set _default _geometry ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Button ) Set Focus On Click ( focus On Click bool ) { C . gtk _button _set _focus _on _click ( v . native ( ) , gbool ( focus On Click ) ) } 
func Action Bar New ( ) ( * Action Bar , error ) { c : = C . gtk _action _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Action Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( a * Action Bar ) Pack Start ( child IWidget ) { C . gtk _action _bar _pack _start ( a . native ( ) , child . to Widget ( ) ) } 
func ( a * Action Bar ) Pack End ( child IWidget ) { C . gtk _action _bar _pack _end ( a . native ( ) , child . to Widget ( ) ) } 
func ( a * Action Bar ) Set Center Widget ( child IWidget ) { if child = = nil { C . gtk _action _bar _set _center _widget ( a . native ( ) , nil ) } else { C . gtk _action _bar _set _center _widget ( a . native ( ) , child . to Widget ( ) ) } } 
func ( a * Action Bar ) Get Center Widget ( ) * Widget { w : = C . gtk _action _bar _get _center _widget ( a . native ( ) ) if w = = nil { return nil } return & Widget { glib . Initially Unowned { glib . Take ( unsafe . Pointer ( w ) ) } } } 
func ( v * Label ) native ( ) * C . Gtk Label { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Label ( p ) } 
func ( v * Label ) Set Text ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _label _set _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) Set Markup ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _label _set _markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) Set Markup With Mnemonic ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _label _set _markup _with _mnemonic ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) Set Pattern ( patern string ) { cstr : = C . CString ( patern ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _label _set _pattern ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) Set Justify ( jtype Justification ) { C . gtk _label _set _justify ( v . native ( ) , C . Gtk Justification ( jtype ) ) } 
func ( v * Label ) Set Ellipsize ( mode pango . Ellipsize Mode ) { C . gtk _label _set _ellipsize ( v . native ( ) , C . Pango Ellipsize Mode ( mode ) ) } 
func ( v * Label ) Get Width Chars ( ) int { c : = C . gtk _label _get _width _chars ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) Set Width Chars ( n Chars int ) { C . gtk _label _set _width _chars ( v . native ( ) , C . gint ( n Chars ) ) } 
func ( v * Label ) Get Max Width Chars ( ) int { c : = C . gtk _label _get _max _width _chars ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) Set Max Width Chars ( n Chars int ) { C . gtk _label _set _max _width _chars ( v . native ( ) , C . gint ( n Chars ) ) } 
func ( v * Label ) Get Line Wrap ( ) bool { c : = C . gtk _label _get _line _wrap ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Set Line Wrap ( wrap bool ) { C . gtk _label _set _line _wrap ( v . native ( ) , gbool ( wrap ) ) } 
func ( v * Label ) Set Line Wrap Mode ( wrap Mode pango . Wrap Mode ) { C . gtk _label _set _line _wrap _mode ( v . native ( ) , C . Pango Wrap Mode ( wrap Mode ) ) } 
func ( v * Label ) Get Selectable ( ) bool { c : = C . gtk _label _get _selectable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Get Text ( ) ( string , error ) { c : = C . gtk _label _get _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Label ) Get Justify ( ) Justification { c : = C . gtk _label _get _justify ( v . native ( ) ) return Justification ( c ) } 
func ( v * Label ) Get Ellipsize ( ) pango . Ellipsize Mode { c : = C . gtk _label _get _ellipsize ( v . native ( ) ) return pango . Ellipsize Mode ( c ) } 
func ( v * Label ) Get Current Uri ( ) string { c : = C . gtk _label _get _current _uri ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Label ) Get Track Visited Links ( ) bool { c : = C . gtk _label _get _track _visited _links ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Set Track Visited Links ( track Links bool ) { C . gtk _label _set _track _visited _links ( v . native ( ) , gbool ( track Links ) ) } 
func ( v * Label ) Get Angle ( ) float 6 4 { c : = C . gtk _label _get _angle ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Label ) Get Selection Bounds ( ) ( start , end int , non Empty bool ) { var cstart , cend C . gint c : = C . gtk _label _get _selection _bounds ( v . native ( ) , & cstart , & cend ) return int ( cstart ) , int ( cend ) , gobool ( c ) } 
func ( v * Label ) Get Single Line Mode ( ) bool { c : = C . gtk _label _get _single _line _mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Set Single Line Mode ( mode bool ) { C . gtk _label _set _single _line _mode ( v . native ( ) , gbool ( mode ) ) } 
func ( v * Label ) Get Use Markup ( ) bool { c : = C . gtk _label _get _use _markup ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Set Use Markup ( use bool ) { C . gtk _label _set _use _markup ( v . native ( ) , gbool ( use ) ) } 
func ( v * Label ) Get Use Underline ( ) bool { c : = C . gtk _label _get _use _underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Set Use Underline ( use bool ) { C . gtk _label _set _use _underline ( v . native ( ) , gbool ( use ) ) } 
func Label New With Mnemonic ( str string ) ( * Label , error ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _label _new _with _mnemonic ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Label ( obj ) , nil } 
func ( v * Label ) Select Region ( start Offset , end Offset int ) { C . gtk _label _select _region ( v . native ( ) , C . gint ( start Offset ) , C . gint ( end Offset ) ) } 
func ( v * Label ) Set Selectable ( setting bool ) { C . gtk _label _set _selectable ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Label ) Set Label ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _label _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Label ) Get Label ( ) string { c : = C . gtk _label _get _label ( v . native ( ) ) if c = = nil { return " " } return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Label ) Set Mnemonic Widget ( widget IWidget ) { C . gtk _label _set _mnemonic _widget ( v . native ( ) , widget . to Widget ( ) ) } 
func go Tick Callbacks ( widget * C . Gtk Widget , frame Clock * C . Gdk Frame Clock , user Data C . gpointer ) C . gboolean { id : = int ( uintptr ( user Data ) ) tick Callback Registry . Lock ( ) r : = tick Callback Registry . m [ id ] tick Callback Registry . Unlock ( ) return gbool ( r . fn ( wrap Widget ( glib . Take ( unsafe . Pointer ( widget ) ) ) , gdk . Wrap Frame Clock ( unsafe . Pointer ( frame Clock ) ) , r . user Data , ) ) } 
func ( v * Variant Dict ) native ( ) * C . GVariant Dict { if v = = nil | | v . GVariant Dict = = nil { return nil } p : = unsafe . Pointer ( v . GVariant Dict ) return C . to GVariant Dict ( p ) } 
func ( v * Actionable ) native ( ) * C . Gtk Actionable { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Actionable ( p ) } 
func ( v * Actionable ) Set Action Name ( action _name string ) { cstr : = C . CString ( action _name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _actionable _set _action _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Actionable ) Get Action Name ( ) ( string , error ) { c : = C . gtk _actionable _get _action _name ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Actionable ) Set Detailed Action Name ( detailed _action _name string ) { cstr : = C . CString ( detailed _action _name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _actionable _set _detailed _action _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func Button New From Icon Name ( icon Name string , size Icon Size ) ( * Button , error ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _button _new _from _icon _name ( ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) if c = = nil { return nil , nil Ptr Err } return wrap Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Grid ) Remove Row ( position int ) { C . gtk _grid _remove _row ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) Remove Column ( position int ) { C . gtk _grid _remove _column ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Header Bar ) native ( ) * C . Gtk Header Bar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Header Bar ( p ) } 
func Header Bar New ( ) ( * Header Bar , error ) { c : = C . gtk _header _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Header Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Header Bar ) Set Title ( title string ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _header _bar _set _title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Header Bar ) Get Title ( ) string { cstr : = C . gtk _header _bar _get _title ( v . native ( ) ) return C . Go String ( ( * C . char ) ( cstr ) ) } 
func ( v * Header Bar ) Set Subtitle ( subtitle string ) { cstr : = C . CString ( subtitle ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _header _bar _set _subtitle ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Header Bar ) Get Subtitle ( ) string { cstr : = C . gtk _header _bar _get _subtitle ( v . native ( ) ) return C . Go String ( ( * C . char ) ( cstr ) ) } 
func ( v * Header Bar ) Set Custom Title ( title Widget IWidget ) { C . gtk _header _bar _set _custom _title ( v . native ( ) , title Widget . to Widget ( ) ) } 
func ( v * Header Bar ) Get Custom Title ( ) ( * Widget , error ) { c : = C . gtk _header _bar _get _custom _title ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Header Bar ) Pack Start ( child IWidget ) { C . gtk _header _bar _pack _start ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Header Bar ) Pack End ( child IWidget ) { C . gtk _header _bar _pack _end ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Header Bar ) Set Show Close Button ( setting bool ) { C . gtk _header _bar _set _show _close _button ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Header Bar ) Get Show Close Button ( ) bool { c : = C . gtk _header _bar _get _show _close _button ( v . native ( ) ) return gobool ( c ) } 
func ( v * Label ) Get Lines ( ) int { c : = C . gtk _label _get _lines ( v . native ( ) ) return int ( c ) } 
func ( v * Label ) Set Lines ( lines int ) { C . gtk _label _set _lines ( v . native ( ) , C . gint ( lines ) ) } 
func ( v * List Box ) native ( ) * C . Gtk List Box { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk List Box ( p ) } 
func List Box New ( ) ( * List Box , error ) { c : = C . gtk _list _box _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap List Box ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * List Box ) Prepend ( child IWidget ) { C . gtk _list _box _prepend ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * List Box ) Insert ( child IWidget , position int ) { C . gtk _list _box _insert ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func ( v * List Box ) Select Row ( row * List Box Row ) { C . gtk _list _box _select _row ( v . native ( ) , row . native ( ) ) } 
func ( v * List Box ) Get Selected Row ( ) * List Box Row { c : = C . gtk _list _box _get _selected _row ( v . native ( ) ) if c = = nil { return nil } return wrap List Box Row ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * List Box ) Set Selection Mode ( mode Selection Mode ) { C . gtk _list _box _set _selection _mode ( v . native ( ) , C . Gtk Selection Mode ( mode ) ) } 
func ( v * List Box ) Get Selection Mode ( ) Selection Mode { c : = C . gtk _list _box _get _selection _mode ( v . native ( ) ) return Selection Mode ( c ) } 
func ( v * List Box ) Set Activate On Single Click ( single bool ) { C . gtk _list _box _set _activate _on _single _click ( v . native ( ) , gbool ( single ) ) } 
func ( v * List Box ) Get Activate On Single Click ( ) bool { c : = C . gtk _list _box _get _activate _on _single _click ( v . native ( ) ) return gobool ( c ) } 
func ( v * List Box ) Get Adjustment ( ) * Adjustment { c : = C . gtk _list _box _get _adjustment ( v . native ( ) ) obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . Initially Unowned { obj } } } 
func ( v * List Box ) Set Adjustment ( adjustment * Adjustment ) { C . gtk _list _box _set _adjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * List Box ) Set Placeholder ( placeholder IWidget ) { C . gtk _list _box _set _placeholder ( v . native ( ) , placeholder . to Widget ( ) ) } 
func ( v * List Box ) Get Row At Index ( index int ) * List Box Row { c : = C . gtk _list _box _get _row _at _index ( v . native ( ) , C . gint ( index ) ) if c = = nil { return nil } return wrap List Box Row ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * List Box ) Get Row At Y ( y int ) * List Box Row { c : = C . gtk _list _box _get _row _at _y ( v . native ( ) , C . gint ( y ) ) if c = = nil { return nil } return wrap List Box Row ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * List Box ) Drag Highlight Row ( row * List Box Row ) { C . gtk _list _box _drag _highlight _row ( v . native ( ) , row . native ( ) ) } 
func ( v * List Box Row ) native ( ) * C . Gtk List Box Row { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk List Box Row ( p ) } 
func ( v * List Box Row ) Get Header ( ) * Widget { c : = C . gtk _list _box _row _get _header ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * List Box Row ) Set Header ( header IWidget ) { C . gtk _list _box _row _set _header ( v . native ( ) , header . to Widget ( ) ) } 
func ( v * List Box Row ) Get Index ( ) int { c : = C . gtk _list _box _row _get _index ( v . native ( ) ) return int ( c ) } 
func ( v * Revealer ) native ( ) * C . Gtk Revealer { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Revealer ( p ) } 
func Revealer New ( ) ( * Revealer , error ) { c : = C . gtk _revealer _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Revealer ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Revealer ) Get Reveal Child ( ) bool { c : = C . gtk _revealer _get _reveal _child ( v . native ( ) ) return gobool ( c ) } 
func ( v * Revealer ) Set Reveal Child ( reveal Child bool ) { C . gtk _revealer _set _reveal _child ( v . native ( ) , gbool ( reveal Child ) ) } 
func ( v * Revealer ) Get Child Revealed ( ) bool { c : = C . gtk _revealer _get _child _revealed ( v . native ( ) ) return gobool ( c ) } 
func ( v * Revealer ) Get Transition Duration ( ) uint { c : = C . gtk _revealer _get _transition _duration ( v . native ( ) ) return uint ( c ) } 
func ( v * Revealer ) Set Transition Duration ( duration uint ) { C . gtk _revealer _set _transition _duration ( v . native ( ) , C . guint ( duration ) ) } 
func ( v * Revealer ) Get Transition Type ( ) Revealer Transition Type { c : = C . gtk _revealer _get _transition _type ( v . native ( ) ) return Revealer Transition Type ( c ) } 
func ( v * Revealer ) Set Transition Type ( transition Revealer Transition Type ) { t : = C . Gtk Revealer Transition Type ( transition ) C . gtk _revealer _set _transition _type ( v . native ( ) , t ) } 
func ( v * Search Bar ) native ( ) * C . Gtk Search Bar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Search Bar ( p ) } 
func Search Bar New ( ) ( * Search Bar , error ) { c : = C . gtk _search _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Search Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Search Bar ) Connect Entry ( entry IEntry ) { C . gtk _search _bar _connect _entry ( v . native ( ) , entry . to Entry ( ) ) } 
func ( v * Search Bar ) Get Search Mode ( ) bool { c : = C . gtk _search _bar _get _search _mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Search Bar ) Set Search Mode ( search Mode bool ) { C . gtk _search _bar _set _search _mode ( v . native ( ) , gbool ( search Mode ) ) } 
func ( v * Search Bar ) Get Show Close Button ( ) bool { c : = C . gtk _search _bar _get _show _close _button ( v . native ( ) ) return gobool ( c ) } 
func ( v * Search Bar ) Set Show Close Button ( visible bool ) { C . gtk _search _bar _set _show _close _button ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Search Bar ) Handle Event ( event * gdk . Event ) { e : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . Native ( ) ) ) C . gtk _search _bar _handle _event ( v . native ( ) , e ) } 
func ( v * Stack ) native ( ) * C . Gtk Stack { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Stack ( p ) } 
func Stack New ( ) ( * Stack , error ) { c : = C . gtk _stack _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Stack ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Stack ) Add Named ( child IWidget , name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _stack _add _named ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Stack ) Add Titled ( child IWidget , name , title string ) { c Name : = C . CString ( name ) defer C . free ( unsafe . Pointer ( c Name ) ) c Title : = C . CString ( title ) defer C . free ( unsafe . Pointer ( c Title ) ) C . gtk _stack _add _titled ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( c Name ) , ( * C . gchar ) ( c Title ) ) } 
func ( v * Stack ) Set Visible Child ( child IWidget ) { C . gtk _stack _set _visible _child ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Stack ) Get Visible Child ( ) * Widget { c : = C . gtk _stack _get _visible _child ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Stack ) Set Visible Child Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _stack _set _visible _child _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Stack ) Get Visible Child Name ( ) string { c : = C . gtk _stack _get _visible _child _name ( v . native ( ) ) return C . Go String ( ( * C . char ) ( c ) ) } 
func ( v * Stack ) Set Visible Child Full ( name string , transaction Stack Transition Type ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _stack _set _visible _child _full ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . Gtk Stack Transition Type ( transaction ) ) } 
func ( v * Stack ) Set Homogeneous ( homogeneous bool ) { C . gtk _stack _set _homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Stack ) Get Homogeneous ( ) bool { c : = C . gtk _stack _get _homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Stack ) Set Transition Duration ( duration uint ) { C . gtk _stack _set _transition _duration ( v . native ( ) , C . guint ( duration ) ) } 
func ( v * Stack ) Get Transition Duration ( ) uint { c : = C . gtk _stack _get _transition _duration ( v . native ( ) ) return uint ( c ) } 
func ( v * Stack ) Set Transition Type ( transition Stack Transition Type ) { C . gtk _stack _set _transition _type ( v . native ( ) , C . Gtk Stack Transition Type ( transition ) ) } 
func ( v * Stack ) Get Transition Type ( ) Stack Transition Type { c : = C . gtk _stack _get _transition _type ( v . native ( ) ) return Stack Transition Type ( c ) } 
func Bind Property ( source * Object , source Property string , target * Object , target Property string , flags Binding Flags ) * Binding { src Str : = ( * C . gchar ) ( C . CString ( source Property ) ) defer C . free ( unsafe . Pointer ( src Str ) ) tgt Str : = ( * C . gchar ) ( C . CString ( target Property ) ) defer C . free ( unsafe . Pointer ( tgt Str ) ) obj : = C . g _object _bind _property ( C . gpointer ( source . GObject ) , src Str , C . gpointer ( target . GObject ) , tgt Str , C . GBinding Flags ( flags ) , ) if obj = = nil { return nil } return & Binding { wrap Object ( unsafe . Pointer ( obj ) ) } } 
func ( v * Binding ) Get Source ( ) * Object { obj : = C . g _binding _get _source ( v . native ( ) ) if obj = = nil { return nil } return wrap Object ( unsafe . Pointer ( obj ) ) } 
func ( v * Binding ) Get Source Property ( ) string { s : = C . g _binding _get _source _property ( v . native ( ) ) return C . Go String ( ( * C . char ) ( s ) ) } 
func ( v * Binding ) Get Target ( ) * Object { obj : = C . g _binding _get _target ( v . native ( ) ) if obj = = nil { return nil } return wrap Object ( unsafe . Pointer ( obj ) ) } 
func ( v * Binding ) Get Target Property ( ) string { s : = C . g _binding _get _target _property ( v . native ( ) ) return C . Go String ( ( * C . char ) ( s ) ) } 
func ( v * Binding ) Get Flags ( ) Binding Flags { flags : = C . g _binding _get _flags ( v . native ( ) ) return Binding Flags ( flags ) } 
func ( v * Font Chooser ) native ( ) * C . Gtk Font Chooser { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Font Chooser ( p ) } 
func ( v * Font Chooser ) Get Font ( ) string { c : = C . gtk _font _chooser _get _font ( v . native ( ) ) return go String ( c ) } 
func ( v * Font Chooser ) Set Font ( font string ) { cstr : = C . CString ( font ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _font _chooser _set _font ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Font Button ) native ( ) * C . Gtk Font Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Font Button ( p ) } 
func Font Button New ( ) ( * Font Button , error ) { c : = C . gtk _font _button _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Font Button ( obj ) , nil } 
func Font Button New With Font ( fontname string ) ( * Font Button , error ) { cstr : = C . CString ( fontname ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _font _button _new _with _font ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Font Button ( obj ) , nil } 
func ( v * Action Group ) native ( ) * C . GAction Group { if v = = nil | | v . GObject = = nil { return nil } return C . to GAction Group ( unsafe . Pointer ( v . GObject ) ) } 
func ( v * Action Group ) Has Action ( action Name string ) bool { return gobool ( C . g _action _group _has _action ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) ) } 
func ( v * Action Group ) Get Action Enabled ( action Name string ) bool { return gobool ( C . g _action _group _get _action _enabled ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) ) } 
func ( v * Action Group ) Get Action Parameter Type ( action Name string ) * Variant Type { c : = C . g _action _group _get _action _parameter _type ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) if c = = nil { return nil } return new Variant Type ( ( * C . GVariant Type ) ( c ) ) } 
func ( v * Action Group ) Get Action State Type ( action Name string ) * Variant Type { c : = C . g _action _group _get _action _state _type ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) if c = = nil { return nil } return new Variant Type ( ( * C . GVariant Type ) ( c ) ) } 
func ( v * Action Group ) Get Action State ( action Name string ) * Variant { c : = C . g _action _group _get _action _state ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) if c = = nil { return nil } return new Variant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action Group ) Get Action State Hint ( action Name string ) * Variant { c : = C . g _action _group _get _action _state _hint ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) ) if c = = nil { return nil } return new Variant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action Group ) Change Action State ( action Name string , value * Variant ) { C . g _action _group _change _action _state ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) , value . native ( ) ) } 
func ( v * Action Group ) Activate ( action Name string , parameter * Variant ) { C . g _action _group _activate _action ( v . native ( ) , ( * C . gchar ) ( C . CString ( action Name ) ) , parameter . native ( ) ) } 
func Gravity To Rotation ( gravity Gravity ) float 6 4 { c : = C . pango _gravity _to _rotation ( ( C . Pango Gravity ) ( gravity ) ) return float 6 4 ( c ) } 
func ( v * Widget ) native ( ) * C . Gtk Widget { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Widget ( p ) } 
func ( v * Widget ) Get Can Focus ( ) bool { c : = C . gtk _widget _get _can _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Can Focus ( can Focus bool ) { C . gtk _widget _set _can _focus ( v . native ( ) , gbool ( can Focus ) ) } 
func ( v * Widget ) Get Can Default ( ) bool { c : = C . gtk _widget _get _can _default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Can Default ( can Default bool ) { C . gtk _widget _set _can _default ( v . native ( ) , gbool ( can Default ) ) } 
func ( v * Widget ) Get Mapped ( ) bool { c : = C . gtk _widget _get _mapped ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Mapped ( mapped bool ) { C . gtk _widget _set _can _focus ( v . native ( ) , gbool ( mapped ) ) } 
func ( v * Widget ) Get Realized ( ) bool { c : = C . gtk _widget _get _realized ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Realized ( realized bool ) { C . gtk _widget _set _realized ( v . native ( ) , gbool ( realized ) ) } 
func ( v * Widget ) Get Has Window ( ) bool { c : = C . gtk _widget _get _has _window ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Has Window ( has Window bool ) { C . gtk _widget _set _has _window ( v . native ( ) , gbool ( has Window ) ) } 
func ( v * Widget ) Set No Show All ( no Show All bool ) { C . gtk _widget _set _no _show _all ( v . native ( ) , gbool ( no Show All ) ) } 
func ( v * Widget ) Get No Show All ( ) bool { c : = C . gtk _widget _get _no _show _all ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Queue Draw Area ( x , y , w , h int ) { C . gtk _widget _queue _draw _area ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , C . gint ( w ) , C . gint ( h ) ) } 
func ( v * Allocation ) native ( ) * C . Gtk Allocation { return ( * C . Gtk Allocation ) ( unsafe . Pointer ( & v . Gdk Rectangle ) ) } 
func ( v * Widget ) Event ( event * gdk . Event ) bool { c : = C . gtk _widget _event ( v . native ( ) , ( * C . Gdk Event ) ( unsafe . Pointer ( event . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Widget ) Set Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _widget _set _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Widget ) Get Name ( ) ( string , error ) { c : = C . gtk _widget _get _name ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Widget ) Get Sensitive ( ) bool { c : = C . gtk _widget _get _sensitive ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Is Sensitive ( ) bool { c : = C . gtk _widget _is _sensitive ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Sensitive ( sensitive bool ) { C . gtk _widget _set _sensitive ( v . native ( ) , gbool ( sensitive ) ) } 
func ( v * Widget ) Get Visible ( ) bool { c : = C . gtk _widget _get _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Visible ( visible bool ) { C . gtk _widget _set _visible ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Widget ) Set Parent ( parent IWidget ) { C . gtk _widget _set _parent ( v . native ( ) , parent . to Widget ( ) ) } 
func ( v * Widget ) Get Parent ( ) ( * Widget , error ) { c : = C . gtk _widget _get _parent ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Widget ) Set Size Request ( width , height int ) { C . gtk _widget _set _size _request ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Widget ) Set Parent Window ( parent Window * gdk . Window ) { C . gtk _widget _set _parent _window ( v . native ( ) , ( * C . Gdk Window ) ( unsafe . Pointer ( parent Window . Native ( ) ) ) ) } 
func ( v * Widget ) Get Parent Window ( ) ( * gdk . Window , error ) { c : = C . gtk _widget _get _parent _window ( v . native ( ) ) if v = = nil { return nil , nil Ptr Err } w : = & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * Widget ) Set Events ( events int ) { C . gtk _widget _set _events ( v . native ( ) , C . gint ( events ) ) } 
func ( v * Widget ) Add Events ( events int ) { C . gtk _widget _add _events ( v . native ( ) , C . gint ( events ) ) } 
func ( v * Widget ) Has Default ( ) bool { c : = C . gtk _widget _has _default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Has Focus ( ) bool { c : = C . gtk _widget _has _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Has Visible Focus ( ) bool { c : = C . gtk _widget _has _visible _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Has Grab ( ) bool { c : = C . gtk _widget _has _grab ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Is Drawable ( ) bool { c : = C . gtk _widget _is _drawable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Is Toplevel ( ) bool { c : = C . gtk _widget _is _toplevel ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set Device Enabled ( device * gdk . Device , enabled bool ) { C . gtk _widget _set _device _enabled ( v . native ( ) , ( * C . Gdk Device ) ( unsafe . Pointer ( device . Native ( ) ) ) , gbool ( enabled ) ) } 
func ( v * Widget ) Get Device Enabled ( device * gdk . Device ) bool { c : = C . gtk _widget _get _device _enabled ( v . native ( ) , ( * C . Gdk Device ) ( unsafe . Pointer ( device . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Widget ) Get Toplevel ( ) ( * Widget , error ) { c : = C . gtk _widget _get _toplevel ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Widget ) Get Tooltip Text ( ) ( string , error ) { c : = C . gtk _widget _get _tooltip _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Widget ) Set Tooltip Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _widget _set _tooltip _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Widget ) Get HAlign ( ) Align { c : = C . gtk _widget _get _halign ( v . native ( ) ) return Align ( c ) } 
func ( v * Widget ) Set HAlign ( align Align ) { C . gtk _widget _set _halign ( v . native ( ) , C . Gtk Align ( align ) ) } 
func ( v * Widget ) Get VAlign ( ) Align { c : = C . gtk _widget _get _valign ( v . native ( ) ) return Align ( c ) } 
func ( v * Widget ) Set VAlign ( align Align ) { C . gtk _widget _set _valign ( v . native ( ) , C . Gtk Align ( align ) ) } 
func ( v * Widget ) Get Margin Top ( ) int { c : = C . gtk _widget _get _margin _top ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) Set Margin Top ( margin int ) { C . gtk _widget _set _margin _top ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) Get Margin Bottom ( ) int { c : = C . gtk _widget _get _margin _bottom ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) Set Margin Bottom ( margin int ) { C . gtk _widget _set _margin _bottom ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Widget ) Get HExpand ( ) bool { c : = C . gtk _widget _get _hexpand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set HExpand ( expand bool ) { C . gtk _widget _set _hexpand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * Widget ) Get VExpand ( ) bool { c : = C . gtk _widget _get _vexpand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Set VExpand ( expand bool ) { C . gtk _widget _set _vexpand ( v . native ( ) , gbool ( expand ) ) } 
func ( v * Widget ) Translate Coordinates ( dest IWidget , src X , src Y int ) ( dest X , dest Y int , e error ) { cdest : = nullable Widget ( dest ) var cdest X , cdest Y C . gint c : = C . gtk _widget _translate _coordinates ( v . native ( ) , cdest , C . gint ( src X ) , C . gint ( src Y ) , & cdest X , & cdest Y ) if ! gobool ( c ) { return 0 , 0 , errors . New ( " " ) } return int ( cdest X ) , int ( cdest Y ) , nil } 
func ( v * Widget ) Set Visual ( visual * gdk . Visual ) { C . gtk _widget _set _visual ( v . native ( ) , ( * C . Gdk Visual ) ( unsafe . Pointer ( visual . Native ( ) ) ) ) } 
func ( v * Widget ) Set App Paintable ( paintable bool ) { C . gtk _widget _set _app _paintable ( v . native ( ) , gbool ( paintable ) ) } 
func ( v * Widget ) Get App Paintable ( ) bool { c : = C . gtk _widget _get _app _paintable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Widget ) Get Allocation ( ) * Allocation { var a Allocation C . gtk _widget _get _allocation ( v . native ( ) , a . native ( ) ) return & a } 
func ( v * Widget ) Set Allocation ( allocation * Allocation ) { C . gtk _widget _set _allocation ( v . native ( ) , allocation . native ( ) ) } 
func ( v * Widget ) Size Allocate ( allocation * Allocation ) { C . gtk _widget _size _allocate ( v . native ( ) , allocation . native ( ) ) } 
func ( v * Widget ) Set State Flags ( state Flags State Flags , clear bool ) { C . gtk _widget _set _state _flags ( v . native ( ) , C . Gtk State Flags ( state Flags ) , gbool ( clear ) ) } 
func ( v * Widget ) Get Window ( ) ( * gdk . Window , error ) { c : = C . gtk _widget _get _window ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } w : = & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * Widget ) Get Preferred Height ( ) ( int , int ) { var minimum , natural C . gint C . gtk _widget _get _preferred _height ( v . native ( ) , & minimum , & natural ) return int ( minimum ) , int ( natural ) } 
func ( v * Widget ) Get Preferred Width ( ) ( int , int ) { var minimum , natural C . gint C . gtk _widget _get _preferred _width ( v . native ( ) , & minimum , & natural ) return int ( minimum ) , int ( natural ) } 
func ( v * Widget ) Get Screen ( ) ( * gdk . Screen , error ) { c : = C . gtk _widget _get _screen ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } s : = & gdk . Screen { glib . Take ( unsafe . Pointer ( c ) ) } return s , nil } 
func ( v * GLArea ) native ( ) * C . Gtk GLArea { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk GLArea ( p ) } 
func GLArea New ( ) ( * GLArea , error ) { c : = C . gtk _gl _area _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap GLArea ( obj ) , nil } 
func ( v * GLArea ) Get Required Version ( ) ( Major Version , Minor Version ) { var major , minor int C . gtk _gl _area _get _required _version ( v . native ( ) , ( * C . int ) ( unsafe . Pointer ( & major ) ) , ( * C . int ) ( unsafe . Pointer ( & minor ) ) ) return Major Version ( major ) , Minor Version ( minor ) } 
func ( v * GLArea ) Set Required Version ( major , minor int ) { C . gtk _gl _area _set _required _version ( v . native ( ) , ( C . int ) ( major ) , ( C . int ) ( minor ) ) } 
func ( v * GLArea ) Set Has Depth Buffer ( has Depth Buffer bool ) { C . gtk _gl _area _set _has _depth _buffer ( v . native ( ) , gbool ( has Depth Buffer ) ) } 
func ( v * GLArea ) Set Has Stencil Buffer ( has Stencil Buffer bool ) { C . gtk _gl _area _set _has _stencil _buffer ( v . native ( ) , gbool ( has Stencil Buffer ) ) } 
func ( v * GLArea ) Set Auto Render ( auto Render bool ) { C . gtk _gl _area _set _auto _render ( v . native ( ) , gbool ( auto Render ) ) } 
func ( v * GLArea ) Get Context ( ) ( * gdk . GLContext , error ) { c : = C . gtk _gl _area _get _context ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } return & ( gdk . GLContext { obj } ) , nil } 
func ( v * GLArea ) Get Error ( ) error { var err * C . GError = nil err = C . gtk _gl _area _get _error ( v . native ( ) ) if err ! = nil { defer C . g _error _free ( err ) return errors . New ( go String ( err . message ) ) } return nil } 
func ( v * Tree View ) native ( ) * C . Gtk Tree View { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tree View ( p ) } 
func Tree View New With Model ( model ITree Model ) ( * Tree View , error ) { return setup Tree View ( unsafe . Pointer ( C . gtk _tree _view _new _with _model ( model . to Tree Model ( ) ) ) ) } 
func ( v * Tree View ) Get Model ( ) ( * Tree Model , error ) { c : = C . gtk _tree _view _get _model ( v . native ( ) ) if c = = nil { return nil , nil } return wrap Tree Model ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Tree View ) Set Model ( model ITree Model ) { var mptr * C . Gtk Tree Model if model ! = nil { mptr = model . to Tree Model ( ) } C . gtk _tree _view _set _model ( v . native ( ) , mptr ) } 
func ( v * Tree View ) Get Selection ( ) ( * Tree Selection , error ) { c : = C . gtk _tree _view _get _selection ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Tree Selection ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Tree View ) Append Column ( column * Tree View Column ) int { c : = C . gtk _tree _view _append _column ( v . native ( ) , column . native ( ) ) return int ( c ) } 
func ( v * Tree View ) Get Path At Pos ( x , y int , path * Tree Path , column * Tree View Column , cell X , cell Y * int ) bool { var ctp * * C . Gtk Tree Path if path ! = nil { ctp = ( * * C . Gtk Tree Path ) ( unsafe . Pointer ( & path . Gtk Tree Path ) ) } else { ctp = nil } var pctvcol * * C . Gtk Tree View Column if column ! = nil { ctvcol : = column . native ( ) pctvcol = & ctvcol } else { pctvcol = nil } return 0 ! = C . gtk _tree _view _get _path _at _pos ( v . native ( ) , ( C . gint ) ( x ) , ( C . gint ) ( y ) , ctp , pctvcol , ( * C . gint ) ( unsafe . Pointer ( cell X ) ) , ( * C . gint ) ( unsafe . Pointer ( cell Y ) ) ) } 
func ( v * Tree View ) Set Level Indentation ( indent int ) { C . gtk _tree _view _set _level _indentation ( v . native ( ) , C . gint ( indent ) ) } 
func ( v * Tree View ) Set Show Expanders ( show bool ) { C . gtk _tree _view _set _show _expanders ( v . native ( ) , gbool ( show ) ) } 
func ( v * Tree View ) Set Headers Visible ( show bool ) { C . gtk _tree _view _set _headers _visible ( v . native ( ) , gbool ( show ) ) } 
func ( v * Tree View ) Set Headers Clickable ( show bool ) { C . gtk _tree _view _set _headers _clickable ( v . native ( ) , gbool ( show ) ) } 
func ( v * Tree View ) Set Activate On Single Click ( show bool ) { C . gtk _tree _view _set _activate _on _single _click ( v . native ( ) , gbool ( show ) ) } 
func ( v * Tree View ) Remove Column ( column * Tree View Column ) int { return int ( C . gtk _tree _view _remove _column ( v . native ( ) , column . native ( ) ) ) } 
func ( v * Tree View ) Insert Column ( column * Tree View Column , pos int ) int { return int ( C . gtk _tree _view _insert _column ( v . native ( ) , column . native ( ) , C . gint ( pos ) ) ) } 
func ( v * Tree View ) Get Column ( n int ) * Tree View Column { c : = C . gtk _tree _view _get _column ( v . native ( ) , C . gint ( n ) ) if c = = nil { return nil } return wrap Tree View Column ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Tree View ) Move Column After ( column * Tree View Column , base Column * Tree View Column ) { C . gtk _tree _view _move _column _after ( v . native ( ) , column . native ( ) , base Column . native ( ) ) } 
func ( v * Tree View ) Set Expander Column ( column * Tree View Column ) { C . gtk _tree _view _set _expander _column ( v . native ( ) , column . native ( ) ) } 
func ( v * Tree View ) Get Expander Column ( ) * Tree View Column { c : = C . gtk _tree _view _get _expander _column ( v . native ( ) ) if c = = nil { return nil } return wrap Tree View Column ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Tree View ) Scroll To Point ( tree X , tree Y int ) { C . gtk _tree _view _scroll _to _point ( v . native ( ) , C . gint ( tree X ) , C . gint ( tree Y ) ) } 
func ( v * Tree View ) Set Cursor ( path * Tree Path , focus Column * Tree View Column , start Editing bool ) { C . gtk _tree _view _set _cursor ( v . native ( ) , path . native ( ) , focus Column . native ( ) , gbool ( start Editing ) ) } 
func ( v * Tree View ) Set Cursor On Cell ( path * Tree Path , focus Column * Tree View Column , focus Cell * Cell Renderer , start Editing bool ) { C . gtk _tree _view _set _cursor _on _cell ( v . native ( ) , path . native ( ) , focus Column . native ( ) , focus Cell . native ( ) , gbool ( start Editing ) ) } 
func ( v * Tree View ) Get Cursor ( ) ( p * Tree Path , c * Tree View Column ) { var path * C . Gtk Tree Path var col * C . Gtk Tree View Column C . gtk _tree _view _get _cursor ( v . native ( ) , & path , & col ) if path ! = nil { p = & Tree Path { path } runtime . Set Finalizer ( p , ( * Tree Path ) . free ) } if col ! = nil { c = wrap Tree View Column ( glib . Take ( unsafe . Pointer ( col ) ) ) } return } 
func ( v * Tree View ) Row Activated ( path * Tree Path , column * Tree View Column ) { C . gtk _tree _view _row _activated ( v . native ( ) , path . native ( ) , column . native ( ) ) } 
func ( v * Tree View ) Expand To Path ( path * Tree Path ) { C . gtk _tree _view _expand _to _path ( v . native ( ) , path . native ( ) ) } 
func ( v * Tree View ) Expand Row ( path * Tree Path , open All bool ) bool { return gobool ( C . gtk _tree _view _expand _row ( v . native ( ) , path . native ( ) , gbool ( open All ) ) ) } 
func ( v * Tree View ) Collapse Row ( path * Tree Path ) bool { return gobool ( C . gtk _tree _view _collapse _row ( v . native ( ) , path . native ( ) ) ) } 
func ( v * Tree View ) Row Expanded ( path * Tree Path ) bool { return gobool ( C . gtk _tree _view _row _expanded ( v . native ( ) , path . native ( ) ) ) } 
func ( v * Tree View ) Set Reorderable ( b bool ) { C . gtk _tree _view _set _reorderable ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Get Bin Window ( ) * gdk . Window { c : = C . gtk _tree _view _get _bin _window ( v . native ( ) ) if c = = nil { return nil } w : = & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w } 
func ( v * Tree View ) Set Enable Search ( b bool ) { C . gtk _tree _view _set _enable _search ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Search Column ( c int ) { C . gtk _tree _view _set _search _column ( v . native ( ) , C . gint ( c ) ) } 
func ( v * Tree View ) Get Search Entry ( ) * Entry { c : = C . gtk _tree _view _get _search _entry ( v . native ( ) ) if c = = nil { return nil } return wrap Entry ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Tree View ) Set Search Entry ( e * Entry ) { C . gtk _tree _view _set _search _entry ( v . native ( ) , e . native ( ) ) } 
func ( v * Tree View ) Set Search Equal Substring Match ( ) { C . gtk _tree _view _set _search _equal _func ( v . native ( ) , ( C . Gtk Tree View Search Equal Func ) ( unsafe . Pointer ( C . substring _match _equal _func ) ) , nil , nil ) } 
func ( v * Tree View ) Set Fixed Height Mode ( b bool ) { C . gtk _tree _view _set _fixed _height _mode ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Hover Selection ( b bool ) { C . gtk _tree _view _set _hover _selection ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Hover Expand ( b bool ) { C . gtk _tree _view _set _hover _expand ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Rubber Banding ( b bool ) { C . gtk _tree _view _set _rubber _banding ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Enable Tree Lines ( b bool ) { C . gtk _tree _view _set _enable _tree _lines ( v . native ( ) , gbool ( b ) ) } 
func ( v * Tree View ) Set Tooltip Column ( c int ) { C . gtk _tree _view _set _tooltip _column ( v . native ( ) , C . gint ( c ) ) } 
func ( v * Tree View ) Set Grid Lines ( grid Lines Tree View Grid Lines ) { C . gtk _tree _view _set _grid _lines ( v . native ( ) , C . Gtk Tree View Grid Lines ( grid Lines ) ) } 
func ( t Type ) Name ( ) string { return C . Go String ( ( * C . char ) ( C . g _type _name ( C . GType ( t ) ) ) ) } 
func ( t Type ) Depth ( ) uint { return uint ( C . g _type _depth ( C . GType ( t ) ) ) } 
func ( t Type ) Parent ( ) Type { return Type ( C . g _type _parent ( C . GType ( t ) ) ) } 
func go Marshal ( closure * C . GClosure , ret Value * C . GValue , n Params C . guint , params * C . GValue , invocation Hint C . gpointer , marshal Data * C . GValue ) { cc : = closures . m [ closure ] closures . RUnlock ( ) n Total Params : = n GLib Params if cc . user Data . Is Valid ( ) { n Total Params + + } if n Cb Params > n Total Params { fmt . Fprintf ( os . Stderr , " \n " , n Cb Params , n Total Params ) return } args : = make ( [ ] reflect . Value , 0 , n Cb Params ) val , err : = v . Go Value ( ) if err ! = nil { fmt . Fprintf ( os . Stderr , " \n " , i , err ) return } if err ! = nil { } else { val = inner Val } } rv : = reflect . Value Of ( val ) args = append ( args , rv . Convert ( cc . rf . Type ( ) . In ( i ) ) ) } } if ret Value ! = nil & & len ( rv ) > 0 { if g , err : = GValue ( rv [ 0 ] . Interface ( ) ) ; err ! = nil { fmt . Fprintf ( os . Stderr , " " , err ) } else { * ret Value = * g . native ( ) } } } 
func g Value Slice ( values * C . GValue , n Values int ) ( slice [ ] C . GValue ) { header : = ( * reflect . Slice Header ) ( ( unsafe . Pointer ( & slice ) ) ) header . Cap = n Values header . Len = n Values header . Data = uintptr ( unsafe . Pointer ( values ) ) return } 
func Idle Add ( f interface { } , args . . . interface { } ) ( Source Handle , error ) { if rf . Type ( ) . Kind ( ) ! = reflect . Func { return 0 , errors . New ( " " ) } if idle Src = = nil { return 0 , err Nil Ptr } return source Attach ( idle Src , rf , args . . . ) } 
func Timeout Add ( timeout uint , f interface { } , args . . . interface { } ) ( Source Handle , error ) { if rf . Type ( ) . Kind ( ) ! = reflect . Func { return 0 , errors . New ( " " ) } if timeout Src = = nil { return 0 , err Nil Ptr } return source Attach ( timeout Src , rf , args . . . ) } 
func source Attach ( src * C . struct _ _GSource , rf reflect . Value , args . . . interface { } ) ( Source Handle , error ) { if src = = nil { return 0 , err Nil Ptr } return 0 , errors . New ( " " ) } closure , _ = Closure New ( rf . Interface ( ) , args . . . ) return Source Handle ( cid ) , nil } 
func Get Home Dir ( ) string { c : = C . g _get _home _dir ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Get User Cache Dir ( ) string { c : = C . g _get _user _cache _dir ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Get User Data Dir ( ) string { c : = C . g _get _user _data _dir ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Get User Config Dir ( ) string { c : = C . g _get _user _config _dir ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Get User Runtime Dir ( ) string { c : = C . g _get _user _runtime _dir ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Get User Special Dir ( directory User Directory ) ( string , error ) { c : = C . g _get _user _special _dir ( C . GUser Directory ( directory ) ) if c = = nil { return " " , err Nil Ptr } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Object ) native ( ) * C . GObject { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to GObject ( p ) } 
func ( v * Object ) go Value ( ) ( interface { } , error ) { obj Type : = Type ( C . _g _type _from _instance ( C . gpointer ( v . native ( ) ) ) ) f , err : = g Value Marshalers . lookup Type ( obj Type ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } val . Set Instance ( uintptr ( unsafe . Pointer ( v . GObject ) ) ) rv , err : = f ( uintptr ( unsafe . Pointer ( val . native ( ) ) ) ) return rv , err } 
func Take ( ptr unsafe . Pointer ) * Object { obj : = new Object ( To GObject ( ptr ) ) if obj . Is Floating ( ) { obj . Ref Sink ( ) } else { obj . Ref ( ) } runtime . Set Finalizer ( obj , ( * Object ) . Unref ) return obj } 
func ( v * Object ) Is A ( typ Type ) bool { return gobool ( C . g _type _is _a ( C . GType ( v . Type From Instance ( ) ) , C . GType ( typ ) ) ) } 
func ( v * Object ) Type From Instance ( ) Type { c : = C . _g _type _from _instance ( C . gpointer ( unsafe . Pointer ( v . native ( ) ) ) ) return Type ( c ) } 
func ( v * Object ) Is Floating ( ) bool { c : = C . g _object _is _floating ( C . gpointer ( v . GObject ) ) return gobool ( c ) } 
func ( v * Object ) Stop Emission ( s string ) { cstr : = C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g _signal _stop _emission _by _name ( ( C . gpointer ) ( v . GObject ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Object ) Set ( name string , value interface { } ) error { return v . Set Property ( name , value ) } 
func ( v * Object ) Get Property Type ( name string ) ( Type , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) param Spec : = C . g _object _class _find _property ( C . _g _object _get _class ( v . native ( ) ) , ( * C . gchar ) ( cstr ) ) if param Spec = = nil { return TYPE _INVALID , errors . New ( " " ) } return Type ( param Spec . value _type ) , nil } 
func ( v * Object ) Get Property ( name string ) ( interface { } , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) t , err : = v . Get Property Type ( name ) if err ! = nil { return nil , err } p , err : = Value Init ( t ) if err ! = nil { return nil , errors . New ( " " ) } C . g _object _get _property ( v . GObject , ( * C . gchar ) ( cstr ) , p . native ( ) ) return p . Go Value ( ) } 
func ( v * Object ) Set Property ( name string , value interface { } ) error { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) if _ , ok : = value . ( Object ) ; ok { value = value . ( Object ) . GObject } p , err : = GValue ( value ) if err ! = nil { return errors . New ( " " ) } C . g _object _set _property ( v . GObject , ( * C . gchar ) ( cstr ) , p . native ( ) ) return nil } 
func ( v * Object ) Emit ( s string , args . . . interface { } ) ( interface { } , error ) { cstr : = C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) defer C . free ( unsafe . Pointer ( valv ) ) if err ! = nil { return nil , errors . New ( " " + err . Error ( ) ) } C . val _list _insert ( valv , C . int ( 0 ) , val . native ( ) ) for i : = range args { val , err : = GValue ( args [ i ] ) if err ! = nil { return nil , fmt . Errorf ( " " , i , err . Error ( ) ) } C . val _list _insert ( valv , C . int ( i + 1 ) , val . native ( ) ) } t : = v . Type From Instance ( ) ret , err : = Value Alloc ( ) if err ! = nil { return nil , errors . New ( " " ) } C . g _signal _emitv ( valv , id , C . GQuark ( 0 ) , ret . native ( ) ) return ret . Go Value ( ) } 
func ( v * Object ) Handler Block ( handle Signal Handle ) { C . g _signal _handler _block ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) } 
func ( v * Object ) Handler Unblock ( handle Signal Handle ) { C . g _signal _handler _unblock ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) } 
func ( v * Object ) Handler Disconnect ( handle Signal Handle ) { C . g _signal _handler _disconnect ( C . gpointer ( v . GObject ) , C . gulong ( handle ) ) C . g _closure _invalidate ( signals [ handle ] ) delete ( closures . m , signals [ handle ] ) delete ( signals , handle ) } 
func ( v * Initially Unowned ) Native ( ) uintptr { if v = = nil | | v . Object = = nil { return uintptr ( unsafe . Pointer ( nil ) ) } return v . Object . Native ( ) } 
func Value Alloc ( ) ( * Value , error ) { c : = C . _g _value _alloc ( ) if c = = nil { return nil , err Nil Ptr } v : = & Value { c } return } f . unset ( ) } ) return v , nil } 
func Value Init ( t Type ) ( * Value , error ) { c : = C . _g _value _init ( C . GType ( t ) ) if c = = nil { return nil , err Nil Ptr } v : = & Value { c } runtime . Set Finalizer ( v , ( * Value ) . unset ) return v , nil } 
func ( v * Value ) Type ( ) ( actual Type , fundamental Type , err error ) { if ! gobool ( C . _g _is _value ( v . native ( ) ) ) { return actual , fundamental , errors . New ( " " ) } c Actual : = C . _g _value _type ( v . native ( ) ) c Fundamental : = C . _g _value _fundamental ( c Actual ) return Type ( c Actual ) , Type ( c Fundamental ) , nil } 
func GValue ( v interface { } ) ( gvalue * Value , err error ) { if v = = nil { val , err : = Value Init ( TYPE _POINTER ) if err ! = nil { return nil , err } val . Set Pointer ( uintptr ( unsafe . Pointer ( nil ) ) ) return val , nil } switch e : = v . ( type ) { case bool : val , err : = Value Init ( TYPE _BOOLEAN ) if err ! = nil { return nil , err } val . Set Bool ( e ) return val , nil case int 8 : val , err : = Value Init ( TYPE _CHAR ) if err ! = nil { return nil , err } val . Set SChar ( e ) return val , nil case int 6 4 : val , err : = Value Init ( TYPE _INT 6 4 ) if err ! = nil { return nil , err } val . Set Int 6 4 ( e ) return val , nil case int : val , err : = Value Init ( TYPE _INT ) if err ! = nil { return nil , err } val . Set Int ( e ) return val , nil case uint 8 : val , err : = Value Init ( TYPE _UCHAR ) if err ! = nil { return nil , err } val . Set UChar ( e ) return val , nil case uint 6 4 : val , err : = Value Init ( TYPE _UINT 6 4 ) if err ! = nil { return nil , err } val . Set UInt 6 4 ( e ) return val , nil case uint : val , err : = Value Init ( TYPE _UINT ) if err ! = nil { return nil , err } val . Set UInt ( e ) return val , nil case float 3 2 : val , err : = Value Init ( TYPE _FLOAT ) if err ! = nil { return nil , err } val . Set Float ( e ) return val , nil case float 6 4 : val , err : = Value Init ( TYPE _DOUBLE ) if err ! = nil { return nil , err } val . Set Double ( e ) return val , nil case string : val , err : = Value Init ( TYPE _STRING ) if err ! = nil { return nil , err } val . Set String ( e ) return val , nil case * Object : val , err : = Value Init ( TYPE _OBJECT ) if err ! = nil { return nil , err } val . Set Instance ( uintptr ( unsafe . Pointer ( e . GObject ) ) ) return val , nil default : rval : = reflect . Value Of ( v ) switch rval . Kind ( ) { case reflect . Int 8 : val , err : = Value Init ( TYPE _CHAR ) if err ! = nil { return nil , err } val . Set SChar ( int 8 ( rval . Int ( ) ) ) return val , nil case reflect . Int 1 6 : return nil , errors . New ( " " ) case reflect . Int 3 2 : return nil , errors . New ( " " ) case reflect . Int 6 4 : val , err : = Value Init ( TYPE _INT 6 4 ) if err ! = nil { return nil , err } val . Set Int 6 4 ( rval . Int ( ) ) return val , nil case reflect . Int : val , err : = Value Init ( TYPE _INT ) if err ! = nil { return nil , err } val . Set Int ( int ( rval . Int ( ) ) ) return val , nil case reflect . Uintptr , reflect . Ptr : val , err : = Value Init ( TYPE _POINTER ) if err ! = nil { return nil , err } val . Set Pointer ( rval . Pointer ( ) ) return val , nil } } return nil , errors . New ( " " ) } 
func ( v * Value ) Go Value ( ) ( interface { } , error ) { f , err : = g Value Marshalers . lookup ( v ) if err ! = nil { return nil , err } return rv , err } 
func ( v * Value ) Set Bool ( val bool ) { C . g _value _set _boolean ( v . native ( ) , gbool ( val ) ) } 
func ( v * Value ) Set SChar ( val int 8 ) { C . g _value _set _schar ( v . native ( ) , C . gint 8 ( val ) ) } 
func ( v * Value ) Set Int 6 4 ( val int 6 4 ) { C . g _value _set _int 6 4 ( v . native ( ) , C . gint 6 4 ( val ) ) } 
func ( v * Value ) Set Int ( val int ) { C . g _value _set _int ( v . native ( ) , C . gint ( val ) ) } 
func ( v * Value ) Set UChar ( val uint 8 ) { C . g _value _set _uchar ( v . native ( ) , C . guchar ( val ) ) } 
func ( v * Value ) Set UInt 6 4 ( val uint 6 4 ) { C . g _value _set _uint 6 4 ( v . native ( ) , C . guint 6 4 ( val ) ) } 
func ( v * Value ) Set UInt ( val uint ) { C . g _value _set _uint ( v . native ( ) , C . guint ( val ) ) } 
func ( v * Value ) Set Float ( val float 3 2 ) { C . g _value _set _float ( v . native ( ) , C . gfloat ( val ) ) } 
func ( v * Value ) Set Double ( val float 6 4 ) { C . g _value _set _double ( v . native ( ) , C . gdouble ( val ) ) } 
func ( v * Value ) Set String ( val string ) { cstr : = C . CString ( val ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g _value _set _string ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Value ) Set Instance ( instance uintptr ) { C . g _value _set _instance ( v . native ( ) , C . gpointer ( instance ) ) } 
func ( v * Value ) Set Pointer ( p uintptr ) { C . g _value _set _pointer ( v . native ( ) , C . gpointer ( p ) ) } 
func ( v * Value ) Get Pointer ( ) unsafe . Pointer { return unsafe . Pointer ( C . g _value _get _pointer ( v . native ( ) ) ) } 
func ( v * Value ) Get String ( ) ( string , error ) { c : = C . g _value _get _string ( v . native ( ) ) if c = = nil { return " " , err Nil Ptr } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func Get Application Name ( ) string { c : = C . g _get _application _name ( ) return C . Go String ( ( * C . char ) ( c ) ) } 
func Set Application Name ( name string ) { cstr : = ( * C . gchar ) ( C . CString ( name ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . g _set _application _name ( cstr ) } 
func Init I 1 8n ( domain string , dir string ) { domain Str : = C . CString ( domain ) defer C . free ( unsafe . Pointer ( domain Str ) ) dir Str : = C . CString ( dir ) defer C . free ( unsafe . Pointer ( dir Str ) ) C . init _i 1 8n ( domain Str , dir Str ) } 
func Local ( input string ) string { cstr : = C . CString ( input ) defer C . free ( unsafe . Pointer ( cstr ) ) return C . Go String ( C . localize ( cstr ) ) } 
func ( v * Level Bar ) Set Inverted ( inverted bool ) { C . gtk _level _bar _set _inverted ( v . native ( ) , gbool ( inverted ) ) } 
func ( v * Level Bar ) Get Inverted ( ) bool { c : = C . gtk _level _bar _get _inverted ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Get NScreens ( ) int { c : = C . gdk _display _get _n _screens ( v . native ( ) ) return int ( c ) } 
func ( v * Widget ) Override Font ( description string ) { cstr : = C . CString ( description ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . pango _font _description _from _string ( cstr ) C . gtk _widget _override _font ( v . native ( ) , c ) } 
func ( v * Shortcuts Section ) native ( ) * C . Gtk Shortcuts Section { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Shortcuts Section ( p ) } 
func ( v * Shortcuts Group ) native ( ) * C . Gtk Shortcuts Group { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Shortcuts Group ( p ) } 
func ( v * Shortcuts Shortcut ) native ( ) * C . Gtk Shortcuts Shortcut { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Shortcuts Shortcut ( p ) } 
func ( v * Native Dialog ) native ( ) * C . Gtk Native Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Native Dialog ( p ) } 
func ( v * Native Dialog ) Run ( ) int { c : = C . gtk _native _dialog _run ( v . native ( ) ) return int ( c ) } 
func ( v * Native Dialog ) Set Modal ( modal bool ) { C . gtk _native _dialog _set _modal ( v . native ( ) , gbool ( modal ) ) } 
func ( v * Native Dialog ) Get Modal ( ) bool { c : = C . gtk _native _dialog _get _modal ( v . native ( ) ) return gobool ( c ) } 
func ( v * Native Dialog ) Set Title ( title string ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _native _dialog _set _title ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * Native Dialog ) Get Title ( ) ( string , error ) { return string Return ( ( * C . gchar ) ( C . gtk _native _dialog _get _title ( v . native ( ) ) ) ) } 
func ( v * Native Dialog ) Set Transient For ( parent IWindow ) { var pw * C . Gtk Window = nil if parent ! = nil { pw = parent . to Window ( ) } C . gtk _native _dialog _set _transient _for ( v . native ( ) , pw ) } 
func ( v * Native Dialog ) Get Visible ( ) bool { c : = C . gtk _native _dialog _get _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * File Chooser Native Dialog ) native ( ) * C . Gtk File Chooser Native { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Chooser Native ( p ) } 
func File Chooser Native Dialog New ( title string , parent * Window , action File Chooser Action , accept _label string , cancel _label string ) ( * File Chooser Native Dialog , error ) { c _title : = C . CString ( title ) defer C . free ( unsafe . Pointer ( c _title ) ) c _accept _label : = C . CString ( accept _label ) defer C . free ( unsafe . Pointer ( c _accept _label ) ) c _cancel _label : = C . CString ( cancel _label ) defer C . free ( unsafe . Pointer ( c _cancel _label ) ) c : = C . gtk _file _chooser _native _new ( ( * C . gchar ) ( c _title ) , parent . native ( ) , C . Gtk File Chooser Action ( action ) , ( * C . gchar ) ( c _accept _label ) , ( * C . gchar ) ( c _cancel _label ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap File Chooser Native Dialog ( obj ) , nil } 
func Open File Chooser Native ( title string , parent _window * Window ) * string { c _title : = C . CString ( title ) var native * C . Gtk File Chooser Native native = C . gtk _file _chooser _native _new ( ( * C . gchar ) ( c _title ) , parent _window . native ( ) , C . Gtk File Chooser Action ( FILE _CHOOSER _ACTION _OPEN ) , ( * C . gchar ) ( C . CString ( " " ) ) , ( * C . gchar ) ( C . CString ( " " ) ) ) p : = unsafe . Pointer ( unsafe . Pointer ( native ) ) dlg : = C . to Gtk Native Dialog ( p ) res : = C . gtk _native _dialog _run ( dlg ) if res = = C . GTK _RESPONSE _ACCEPT { c : = C . gtk _file _chooser _get _filename ( C . to Gtk File Chooser ( p ) ) s : = go String ( c ) defer C . g _free ( ( C . gpointer ) ( c ) ) return & s } return nil } 
func ( v * File Chooser Native Dialog ) Set Accept Label ( accept _label string ) { cstr : = C . CString ( accept _label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _file _chooser _native _set _accept _label ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * File Chooser Native Dialog ) Get Accept Label ( ) ( string , error ) { return string Return ( ( * C . gchar ) ( C . gtk _file _chooser _native _get _accept _label ( v . native ( ) ) ) ) } 
func ( v * File Chooser Native Dialog ) Set Cancel Label ( cancel _label string ) { cstr : = C . CString ( cancel _label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _file _chooser _native _set _cancel _label ( v . native ( ) , ( * C . char ) ( cstr ) ) } 
func ( v * File Chooser Native Dialog ) Get Cancel Label ( ) ( string , error ) { return string Return ( ( * C . gchar ) ( C . gtk _file _chooser _native _get _cancel _label ( v . native ( ) ) ) ) } 
func ( v * Simple Action Group ) native ( ) * C . GSimple Action Group { if v = = nil | | v . GObject = = nil { return nil } return C . to GSimple Action Group ( unsafe . Pointer ( v . GObject ) ) } 
func Simple Action Group New ( ) * Simple Action Group { c : = C . g _simple _action _group _new ( ) if c = = nil { return nil } return wrap Simple Action Group ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Action ) native ( ) * C . GAction { if v = = nil | | v . GObject = = nil { return nil } return C . to GAction ( unsafe . Pointer ( v . GObject ) ) } 
func Action Name Is Valid ( action Name string ) bool { cstr : = ( * C . gchar ) ( C . CString ( action Name ) ) return gobool ( C . g _action _name _is _valid ( cstr ) ) } 
func ( v * Action ) Get Name ( ) string { return C . Go String ( ( * C . char ) ( C . g _action _get _name ( v . native ( ) ) ) ) } 
func ( v * Action ) Get State ( ) * Variant { c : = C . g _action _get _state ( v . native ( ) ) if c = = nil { return nil } return new Variant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action ) Get State Hint ( ) * Variant { c : = C . g _action _get _state _hint ( v . native ( ) ) if c = = nil { return nil } return new Variant ( ( * C . GVariant ) ( c ) ) } 
func ( v * Action ) Get Parameter Type ( ) * Variant Type { c : = C . g _action _get _parameter _type ( v . native ( ) ) if c = = nil { return nil } return new Variant Type ( ( * C . GVariant Type ) ( c ) ) } 
func ( v * Action ) Get State Type ( ) * Variant Type { c : = C . g _action _get _state _type ( v . native ( ) ) if c = = nil { return nil } return new Variant Type ( ( * C . GVariant Type ) ( c ) ) } 
func ( v * Action ) Change State ( value * Variant ) { C . g _action _change _state ( v . native ( ) , value . native ( ) ) } 
func ( v * Action ) Activate ( parameter * Variant ) { C . g _action _activate ( v . native ( ) , parameter . native ( ) ) } 
func Simple Action New ( name string , parameter Type * Variant Type ) * Simple Action { c : = C . g _simple _action _new ( ( * C . gchar ) ( C . CString ( name ) ) , parameter Type . native ( ) ) if c = = nil { return nil } return wrap Simple Action ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func Simple Action New Stateful ( name string , parameter Type * Variant Type , state * Variant ) * Simple Action { c : = C . g _simple _action _new _stateful ( ( * C . gchar ) ( C . CString ( name ) ) , parameter Type . native ( ) , state . native ( ) ) if c = = nil { return nil } return wrap Simple Action ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Simple Action ) Set Enabled ( enabled bool ) { C . g _simple _action _set _enabled ( v . native ( ) , gbool ( enabled ) ) } 
func ( v * Simple Action ) Set State ( value * Variant ) { C . g _simple _action _set _state ( v . native ( ) , value . native ( ) ) } 
func Property Action New ( name string , object * Object , property Name string ) * Property Action { c : = C . g _property _action _new ( ( * C . gchar ) ( C . CString ( name ) ) , C . gpointer ( unsafe . Pointer ( object . native ( ) ) ) , ( * C . gchar ) ( C . CString ( property Name ) ) ) if c = = nil { return nil } return wrap Property Action ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu ) Popup At Pointer ( trigger Event * gdk . Event ) { e : = ( * C . Gdk Event ) ( unsafe . Pointer ( trigger Event . Native ( ) ) ) C . gtk _menu _popup _at _pointer ( v . native ( ) , e ) } 
func ( v * Menu ) Popup At Widget ( widget IWidget , widget Anchor gdk . Gdk Gravity , menu Anchor gdk . Gdk Gravity , trigger Event * gdk . Event ) { e : = ( * C . Gdk Event ) ( unsafe . Pointer ( trigger Event . Native ( ) ) ) C . gtk _menu _popup _at _widget ( v . native ( ) , widget . to Widget ( ) , C . Gdk Gravity ( widget Anchor ) , C . Gdk Gravity ( menu Anchor ) , e ) } 
func Init Check ( args * [ ] string ) error { success : = false if args ! = nil { argc : = C . int ( len ( * args ) ) argv : = C . make _strings ( argc ) defer C . destroy _strings ( argv ) for i , arg : = range * args { cstr : = C . CString ( arg ) C . set _string ( argv , C . int ( i ) , ( * C . gchar ) ( cstr ) ) } success = gobool ( C . gtk _init _check ( ( * C . int ) ( unsafe . Pointer ( & argc ) ) , ( * * * C . char ) ( unsafe . Pointer ( & argv ) ) ) ) unhandled : = make ( [ ] string , argc ) for i : = 0 ; i < int ( argc ) ; i + + { cstr : = C . get _string ( argv , C . int ( i ) ) unhandled [ i ] = go String ( cstr ) C . free ( unsafe . Pointer ( cstr ) ) } * args = unhandled } else { success = gobool ( C . gtk _init _check ( nil , nil ) ) } if success { return nil } else { return errors . New ( " " ) } } 
func ( v * Adjustment ) native ( ) * C . Gtk Adjustment { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Adjustment ( p ) } 
func Adjustment New ( value , lower , upper , step Increment , page Increment , page Size float 6 4 ) ( * Adjustment , error ) { c : = C . gtk _adjustment _new ( C . gdouble ( value ) , C . gdouble ( lower ) , C . gdouble ( upper ) , C . gdouble ( step Increment ) , C . gdouble ( page Increment ) , C . gdouble ( page Size ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Adjustment ( obj ) , nil } 
func ( v * Adjustment ) Get Value ( ) float 6 4 { c : = C . gtk _adjustment _get _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Adjustment ) Get Lower ( ) float 6 4 { c : = C . gtk _adjustment _get _lower ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Adjustment ) Set Page Size ( value float 6 4 ) { C . gtk _adjustment _set _page _size ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Configure ( value , lower , upper , step Increment , page Increment , page Size float 6 4 ) { C . gtk _adjustment _configure ( v . native ( ) , C . gdouble ( value ) , C . gdouble ( lower ) , C . gdouble ( upper ) , C . gdouble ( step Increment ) , C . gdouble ( page Increment ) , C . gdouble ( page Size ) ) } 
func ( v * Adjustment ) Set Lower ( value float 6 4 ) { C . gtk _adjustment _set _lower ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Get Upper ( ) float 6 4 { c : = C . gtk _adjustment _get _upper ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Adjustment ) Set Upper ( value float 6 4 ) { C . gtk _adjustment _set _upper ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Get Page Increment ( ) float 6 4 { c : = C . gtk _adjustment _get _page _increment ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Adjustment ) Set Page Increment ( value float 6 4 ) { C . gtk _adjustment _set _page _increment ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Get Step Increment ( ) float 6 4 { c : = C . gtk _adjustment _get _step _increment ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Adjustment ) Set Step Increment ( value float 6 4 ) { C . gtk _adjustment _set _step _increment ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Adjustment ) Get Minimum Increment ( ) float 6 4 { c : = C . gtk _adjustment _get _minimum _increment ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Assistant ) native ( ) * C . Gtk Assistant { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Assistant ( p ) } 
func Assistant New ( ) ( * Assistant , error ) { c : = C . gtk _assistant _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Assistant ( obj ) , nil } 
func ( v * Assistant ) Get Current Page ( ) int { c : = C . gtk _assistant _get _current _page ( v . native ( ) ) return int ( c ) } 
func ( v * Assistant ) Set Current Page ( page Num int ) { C . gtk _assistant _set _current _page ( v . native ( ) , C . gint ( page Num ) ) } 
func ( v * Assistant ) Get NPages ( ) int { c : = C . gtk _assistant _get _n _pages ( v . native ( ) ) return int ( c ) } 
func ( v * Assistant ) Get Nth Page ( page Num int ) ( * Widget , error ) { c : = C . gtk _assistant _get _nth _page ( v . native ( ) , C . gint ( page Num ) ) if c = = nil { return nil , fmt . Errorf ( " " , page Num ) } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( v * Assistant ) Prepend Page ( page IWidget ) int { c : = C . gtk _assistant _prepend _page ( v . native ( ) , page . to Widget ( ) ) return int ( c ) } 
func ( v * Assistant ) Append Page ( page IWidget ) int { c : = C . gtk _assistant _append _page ( v . native ( ) , page . to Widget ( ) ) return int ( c ) } 
func ( v * Assistant ) Insert Page ( page IWidget , position int ) int { c : = C . gtk _assistant _insert _page ( v . native ( ) , page . to Widget ( ) , C . gint ( position ) ) return int ( c ) } 
func ( v * Assistant ) Remove Page ( page Num int ) { C . gtk _assistant _remove _page ( v . native ( ) , C . gint ( page Num ) ) } 
func ( v * Assistant ) Set Page Type ( page IWidget , ptype Assistant Page Type ) { C . gtk _assistant _set _page _type ( v . native ( ) , page . to Widget ( ) , C . Gtk Assistant Page Type ( ptype ) ) } 
func ( v * Assistant ) Get Page Type ( page IWidget ) Assistant Page Type { c : = C . gtk _assistant _get _page _type ( v . native ( ) , page . to Widget ( ) ) return Assistant Page Type ( c ) } 
func ( v * Assistant ) Set Page Title ( page IWidget , title string ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _assistant _set _page _title ( v . native ( ) , page . to Widget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Assistant ) Get Page Title ( page IWidget ) string { return go String ( C . gtk _assistant _get _page _title ( v . native ( ) , page . to Widget ( ) ) ) } 
func ( v * Assistant ) Set Page Complete ( page IWidget , complete bool ) { C . gtk _assistant _set _page _complete ( v . native ( ) , page . to Widget ( ) , gbool ( complete ) ) } 
func ( v * Assistant ) Get Page Complete ( page IWidget ) bool { c : = C . gtk _assistant _get _page _complete ( v . native ( ) , page . to Widget ( ) ) return gobool ( c ) } 
func ( v * Assistant ) Add Action Widget ( child IWidget ) { C . gtk _assistant _add _action _widget ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Assistant ) Remove Action Widget ( child IWidget ) { C . gtk _assistant _remove _action _widget ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Bin ) native ( ) * C . Gtk Bin { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Bin ( p ) } 
func ( v * Bin ) Get Child ( ) ( * Widget , error ) { c : = C . gtk _bin _get _child ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( b * Builder ) native ( ) * C . Gtk Builder { if b = = nil | | b . GObject = = nil { return nil } p : = unsafe . Pointer ( b . GObject ) return C . to Gtk Builder ( p ) } 
func Builder New ( ) ( * Builder , error ) { c : = C . gtk _builder _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func Builder New From File ( file Path string ) ( * Builder , error ) { cstr : = C . CString ( file Path ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _builder _new _from _file ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func Builder New From Resource ( resource Path string ) ( * Builder , error ) { cstr : = C . CString ( resource Path ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _builder _new _from _resource ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Builder { obj } , nil } 
func ( b * Builder ) Add From File ( filename string ) error { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res : = C . gtk _builder _add _from _file ( b . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res = = 0 { defer C . g _error _free ( err ) return errors . New ( go String ( err . message ) ) } return nil } 
func ( b * Builder ) Add From Resource ( path string ) error { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res : = C . gtk _builder _add _from _resource ( b . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res = = 0 { defer C . g _error _free ( err ) return errors . New ( go String ( err . message ) ) } return nil } 
func ( b * Builder ) Add From String ( str string ) error { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) length : = ( C . gsize ) ( len ( str ) ) var err * C . GError = nil res : = C . gtk _builder _add _from _string ( b . native ( ) , ( * C . gchar ) ( cstr ) , length , & err ) if res = = 0 { defer C . g _error _free ( err ) return errors . New ( go String ( err . message ) ) } return nil } 
func ( b * Builder ) Get Object ( name string ) ( glib . IObject , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _builder _get _object ( b . native ( ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , errors . New ( " " + name + " " ) } obj , err : = cast ( c ) if err ! = nil { return nil , err } return obj , nil } 
func ( b * Builder ) Connect Signals ( signals map [ string ] interface { } ) { builder Signals . Lock ( ) builder Signals . m [ b . native ( ) ] = signals builder Signals . Unlock ( ) C . _gtk _builder _connect _signals _full ( b . native ( ) ) } 
func ( v * Button ) native ( ) * C . Gtk Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Button ( p ) } 
func Button New ( ) ( * Button , error ) { c : = C . gtk _button _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Button ( obj ) , nil } 
func Button New With Label ( label string ) ( * Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _button _new _with _label ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Button ( obj ) , nil } 
func ( v * Button ) Set Relief ( new Style Relief Style ) { C . gtk _button _set _relief ( v . native ( ) , C . Gtk Relief Style ( new Style ) ) } 
func ( v * Button ) Get Relief ( ) Relief Style { c : = C . gtk _button _get _relief ( v . native ( ) ) return Relief Style ( c ) } 
func ( v * Button ) Set Label ( label string ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _button _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Button ) Get Label ( ) ( string , error ) { c : = C . gtk _button _get _label ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Button ) Set Use Underline ( use Underline bool ) { C . gtk _button _set _use _underline ( v . native ( ) , gbool ( use Underline ) ) } 
func ( v * Button ) Get Use Underline ( ) bool { c : = C . gtk _button _get _use _underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * Button ) Set Image ( image IWidget ) { C . gtk _button _set _image ( v . native ( ) , image . to Widget ( ) ) } 
func ( v * Button ) Get Image ( ) ( * Widget , error ) { c : = C . gtk _button _get _image ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( v * Button ) Set Image Position ( position Position Type ) { C . gtk _button _set _image _position ( v . native ( ) , C . Gtk Position Type ( position ) ) } 
func ( v * Button ) Get Image Position ( ) Position Type { c : = C . gtk _button _get _image _position ( v . native ( ) ) return Position Type ( c ) } 
func ( v * Button ) Set Always Show Image ( always Show bool ) { C . gtk _button _set _always _show _image ( v . native ( ) , gbool ( always Show ) ) } 
func ( v * Button ) Get Always Show Image ( ) bool { c : = C . gtk _button _get _always _show _image ( v . native ( ) ) return gobool ( c ) } 
func ( v * Button ) Get Event Window ( ) ( * gdk . Window , error ) { c : = C . gtk _button _get _event _window ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } w : = & gdk . Window { glib . Take ( unsafe . Pointer ( c ) ) } return w , nil } 
func ( v * Color Button ) native ( ) * C . Gtk Color Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Color Button ( p ) } 
func Color Button New ( ) ( * Color Button , error ) { c : = C . gtk _color _button _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Color Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Color Button New With RGBA ( gdk Color * gdk . RGBA ) ( * Color Button , error ) { c : = C . gtk _color _button _new _with _rgba ( ( * C . Gdk RGBA ) ( unsafe . Pointer ( gdk Color . Native ( ) ) ) ) if c = = nil { return nil , nil Ptr Err } return wrap Color Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Box ) native ( ) * C . Gtk Box { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Box ( p ) } 
func ( v * Box ) Set Orientation ( o Orientation ) { C . gtk _orientable _set _orientation ( v . to Orientable ( ) , C . Gtk Orientation ( o ) ) } 
func Box New ( orientation Orientation , spacing int ) ( * Box , error ) { c : = C . gtk _box _new ( C . Gtk Orientation ( orientation ) , C . gint ( spacing ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Box ( obj ) , nil } 
func ( v * Box ) Pack Start ( child IWidget , expand , fill bool , padding uint ) { C . gtk _box _pack _start ( v . native ( ) , child . to Widget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) ) } 
func ( v * Box ) Pack End ( child IWidget , expand , fill bool , padding uint ) { C . gtk _box _pack _end ( v . native ( ) , child . to Widget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) ) } 
func ( v * Box ) Get Homogeneous ( ) bool { c : = C . gtk _box _get _homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Box ) Set Homogeneous ( homogeneous bool ) { C . gtk _box _set _homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Box ) Get Spacing ( ) int { c : = C . gtk _box _get _spacing ( v . native ( ) ) return int ( c ) } 
func ( v * Box ) Reorder Child ( child IWidget , position int ) { C . gtk _box _reorder _child ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func ( v * Box ) Query Child Packing ( child IWidget ) ( expand , fill bool , padding uint , pack Type Pack Type ) { var cexpand , cfill C . gboolean var cpadding C . guint var cpack Type C . Gtk Pack Type C . gtk _box _query _child _packing ( v . native ( ) , child . to Widget ( ) , & cexpand , & cfill , & cpadding , & cpack Type ) return gobool ( cexpand ) , gobool ( cfill ) , uint ( cpadding ) , Pack Type ( cpack Type ) } 
func ( v * Box ) Set Child Packing ( child IWidget , expand , fill bool , padding uint , pack Type Pack Type ) { C . gtk _box _set _child _packing ( v . native ( ) , child . to Widget ( ) , gbool ( expand ) , gbool ( fill ) , C . guint ( padding ) , C . Gtk Pack Type ( pack Type ) ) } 
func ( v * Calendar ) native ( ) * C . Gtk Calendar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Calendar ( p ) } 
func Calendar New ( ) ( * Calendar , error ) { c : = C . gtk _calendar _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Calendar ( obj ) , nil } 
func ( v * Calendar ) Select Month ( month , year uint ) { C . gtk _calendar _select _month ( v . native ( ) , C . guint ( month ) , C . guint ( year ) ) } 
func ( v * Calendar ) Select Day ( day uint ) { C . gtk _calendar _select _day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) Mark Day ( day uint ) { C . gtk _calendar _mark _day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) Unmark Day ( day uint ) { C . gtk _calendar _unmark _day ( v . native ( ) , C . guint ( day ) ) } 
func ( v * Calendar ) Get Day Is Marked ( day uint ) bool { c : = C . gtk _calendar _get _day _is _marked ( v . native ( ) , C . guint ( day ) ) return gobool ( c ) } 
func ( v * Calendar ) Get Display Options ( ) Calendar Display Options { c : = C . gtk _calendar _get _display _options ( v . native ( ) ) return Calendar Display Options ( c ) } 
func ( v * Calendar ) Set Display Options ( flags Calendar Display Options ) { C . gtk _calendar _set _display _options ( v . native ( ) , C . Gtk Calendar Display Options ( flags ) ) } 
func ( v * Calendar ) Get Date ( ) ( year , month , day uint ) { var cyear , cmonth , cday C . guint C . gtk _calendar _get _date ( v . native ( ) , & cyear , & cmonth , & cday ) return uint ( cyear ) , uint ( cmonth ) , uint ( cday ) } 
func ( v * Calendar ) Get Detail Width Chars ( ) int { c : = C . gtk _calendar _get _detail _width _chars ( v . native ( ) ) return int ( c ) } 
func ( v * Calendar ) Set Detail Width Chars ( chars int ) { C . gtk _calendar _set _detail _width _chars ( v . native ( ) , C . gint ( chars ) ) } 
func ( v * Calendar ) Get Detail Height Rows ( ) int { c : = C . gtk _calendar _get _detail _height _rows ( v . native ( ) ) return int ( c ) } 
func ( v * Calendar ) Set Detail Height Rows ( rows int ) { C . gtk _calendar _set _detail _height _rows ( v . native ( ) , C . gint ( rows ) ) } 
func ( v * Cell Layout ) native ( ) * C . Gtk Cell Layout { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Layout ( p ) } 
func ( v * Cell Layout ) Pack Start ( cell ICell Renderer , expand bool ) { C . gtk _cell _layout _pack _start ( v . native ( ) , cell . to Cell Renderer ( ) , gbool ( expand ) ) } 
func ( v * Cell Layout ) Add Attribute ( cell ICell Renderer , attribute string , column int ) { cstr : = C . CString ( attribute ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _cell _layout _add _attribute ( v . native ( ) , cell . to Cell Renderer ( ) , ( * C . gchar ) ( cstr ) , C . gint ( column ) ) } 
func ( v * Cell Renderer ) native ( ) * C . Gtk Cell Renderer { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Renderer ( p ) } 
func ( v * Cell Renderer Spinner ) native ( ) * C . Gtk Cell Renderer Spinner { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Renderer Spinner ( p ) } 
func Cell Renderer Spinner New ( ) ( * Cell Renderer Spinner , error ) { c : = C . gtk _cell _renderer _spinner _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Cell Renderer Spinner ( obj ) , nil } 
func ( v * Cell Renderer Pixbuf ) native ( ) * C . Gtk Cell Renderer Pixbuf { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Renderer Pixbuf ( p ) } 
func Cell Renderer Pixbuf New ( ) ( * Cell Renderer Pixbuf , error ) { c : = C . gtk _cell _renderer _pixbuf _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Cell Renderer Pixbuf ( obj ) , nil } 
func ( v * Cell Renderer Text ) native ( ) * C . Gtk Cell Renderer Text { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Renderer Text ( p ) } 
func Cell Renderer Text New ( ) ( * Cell Renderer Text , error ) { c : = C . gtk _cell _renderer _text _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Cell Renderer Text ( obj ) , nil } 
func ( v * Cell Renderer Toggle ) native ( ) * C . Gtk Cell Renderer Toggle { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Cell Renderer Toggle ( p ) } 
func Cell Renderer Toggle New ( ) ( * Cell Renderer Toggle , error ) { c : = C . gtk _cell _renderer _toggle _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Cell Renderer Toggle ( obj ) , nil } 
func ( v * Cell Renderer Toggle ) Set Radio ( set bool ) { C . gtk _cell _renderer _toggle _set _radio ( v . native ( ) , gbool ( set ) ) } 
func ( v * Cell Renderer Toggle ) Get Radio ( ) bool { c : = C . gtk _cell _renderer _toggle _get _radio ( v . native ( ) ) return gobool ( c ) } 
func ( v * Cell Renderer Toggle ) Set Active ( active bool ) { C . gtk _cell _renderer _toggle _set _active ( v . native ( ) , gbool ( active ) ) } 
func ( v * Cell Renderer Toggle ) Get Active ( ) bool { c : = C . gtk _cell _renderer _toggle _get _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Cell Renderer Toggle ) Set Activatable ( activatable bool ) { C . gtk _cell _renderer _toggle _set _activatable ( v . native ( ) , gbool ( activatable ) ) } 
func ( v * Cell Renderer Toggle ) Get Activatable ( ) bool { c : = C . gtk _cell _renderer _toggle _get _activatable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Check Button ) native ( ) * C . Gtk Check Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Check Button ( p ) } 
func Check Button New ( ) ( * Check Button , error ) { c : = C . gtk _check _button _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Check Button ( obj ) , nil } 
func Check Button New With Label ( label string ) ( * Check Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _check _button _new _with _label ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Check Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Check Button New With Mnemonic ( label string ) ( * Check Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _check _button _new _with _mnemonic ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Check Button ( obj ) , nil } 
func ( v * Check Menu Item ) native ( ) * C . Gtk Check Menu Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Check Menu Item ( p ) } 
func Check Menu Item New ( ) ( * Check Menu Item , error ) { c : = C . gtk _check _menu _item _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Check Menu Item ( obj ) , nil } 
func Check Menu Item New With Label ( label string ) ( * Check Menu Item , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _check _menu _item _new _with _label ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Check Menu Item ( obj ) , nil } 
func ( v * Check Menu Item ) Get Active ( ) bool { c : = C . gtk _check _menu _item _get _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Check Menu Item ) Set Active ( is Active bool ) { C . gtk _check _menu _item _set _active ( v . native ( ) , gbool ( is Active ) ) } 
func ( v * Check Menu Item ) Get Inconsistent ( ) bool { c : = C . gtk _check _menu _item _get _inconsistent ( v . native ( ) ) return gobool ( c ) } 
func ( v * Check Menu Item ) Set Inconsistent ( setting bool ) { C . gtk _check _menu _item _set _inconsistent ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Check Menu Item ) Set Draw As Radio ( draw As Radio bool ) { C . gtk _check _menu _item _set _draw _as _radio ( v . native ( ) , gbool ( draw As Radio ) ) } 
func ( v * Check Menu Item ) Get Draw As Radio ( ) bool { c : = C . gtk _check _menu _item _get _draw _as _radio ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) native ( ) * C . Gtk Clipboard { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Clipboard ( p ) } 
func Clipboard Get ( atom gdk . Atom ) ( * Clipboard , error ) { c : = C . gtk _clipboard _get ( C . Gdk Atom ( unsafe . Pointer ( atom ) ) ) if c = = nil { return nil , nil Ptr Err } cb : = & Clipboard { glib . Take ( unsafe . Pointer ( c ) ) } return cb , nil } 
func Clipboard Get For Display ( display * gdk . Display , atom gdk . Atom ) ( * Clipboard , error ) { display Ptr : = ( * C . Gdk Display ) ( unsafe . Pointer ( display . Native ( ) ) ) c : = C . gtk _clipboard _get _for _display ( display Ptr , C . Gdk Atom ( unsafe . Pointer ( atom ) ) ) if c = = nil { return nil , nil Ptr Err } cb : = & Clipboard { glib . Take ( unsafe . Pointer ( c ) ) } return cb , nil } 
func ( v * Clipboard ) Wait Is Text Available ( ) bool { c : = C . gtk _clipboard _wait _is _text _available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) Wait For Text ( ) ( string , error ) { c : = C . gtk _clipboard _wait _for _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } defer C . g _free ( C . gpointer ( c ) ) return go String ( c ) , nil } 
func ( v * Clipboard ) Set Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _clipboard _set _text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * Clipboard ) Wait Is Rich Text Available ( buf * Text Buffer ) bool { c : = C . gtk _clipboard _wait _is _rich _text _available ( v . native ( ) , buf . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) Wait Is Uris Available ( ) bool { c : = C . gtk _clipboard _wait _is _uris _available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) Wait Is Image Available ( ) bool { c : = C . gtk _clipboard _wait _is _image _available ( v . native ( ) ) return gobool ( c ) } 
func ( v * Clipboard ) Set Image ( pixbuf * gdk . Pixbuf ) { C . gtk _clipboard _set _image ( v . native ( ) , ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Clipboard ) Wait For Image ( ) ( * gdk . Pixbuf , error ) { c : = C . gtk _clipboard _wait _for _image ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } p : = & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * Clipboard ) Wait Is Target Available ( target gdk . Atom ) bool { c : = C . gtk _clipboard _wait _is _target _available ( v . native ( ) , C . Gdk Atom ( unsafe . Pointer ( target ) ) ) return gobool ( c ) } 
func ( v * Clipboard ) Wait For Contents ( target gdk . Atom ) ( * Selection Data , error ) { c : = C . gtk _clipboard _wait _for _contents ( v . native ( ) , C . Gdk Atom ( unsafe . Pointer ( target ) ) ) if c = = nil { return nil , nil Ptr Err } p : = & Selection Data { c } runtime . Set Finalizer ( p , ( * Selection Data ) . free ) return p , nil } 
func ( v * Container ) native ( ) * C . Gtk Container { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Container ( p ) } 
func ( v * Container ) Add ( w IWidget ) { C . gtk _container _add ( v . native ( ) , w . to Widget ( ) ) } 
func ( v * Container ) Remove ( w IWidget ) { C . gtk _container _remove ( v . native ( ) , w . to Widget ( ) ) } 
func ( v * Container ) Get Children ( ) * glib . List { clist : = C . gtk _container _get _children ( v . native ( ) ) glist : = glib . Wrap List ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return wrap Widget ( glib . Take ( ptr ) ) } ) return glist } 
func ( v * Container ) Get Focus Child ( ) * Widget { c : = C . gtk _container _get _focus _child ( v . native ( ) ) if c = = nil { return nil } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) } 
func ( v * Container ) Set Focus Child ( child IWidget ) { C . gtk _container _set _focus _child ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Container ) Get Focus VAdjustment ( ) * Adjustment { c : = C . gtk _container _get _focus _vadjustment ( v . native ( ) ) if c = = nil { return nil } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Adjustment ( obj ) } 
func ( v * Container ) Set Focus VAdjustment ( adjustment * Adjustment ) { C . gtk _container _set _focus _vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Container ) Get Focus HAdjustment ( ) * Adjustment { c : = C . gtk _container _get _focus _hadjustment ( v . native ( ) ) if c = = nil { return nil } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Adjustment ( obj ) } 
func ( v * Container ) Set Focus HAdjustment ( adjustment * Adjustment ) { C . gtk _container _set _focus _hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Container ) Child Type ( ) glib . Type { c : = C . gtk _container _child _type ( v . native ( ) ) return glib . Type ( c ) } 
func ( v * Container ) Child Notify ( child IWidget , child Property string ) { cstr : = C . CString ( child Property ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _container _child _notify ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Container ) Child Get Property ( child IWidget , name string , value Type glib . Type ) ( interface { } , error ) { gv , e : = glib . Value Init ( value Type ) if e ! = nil { return nil , e } cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _container _child _get _property ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) return gv . Go Value ( ) } 
func ( v * Container ) Child Set Property ( child IWidget , name string , value interface { } ) error { gv , e : = glib . GValue ( value ) if e ! = nil { return e } cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _container _child _set _property ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) return nil } 
func ( v * Container ) Get Border Width ( ) uint { c : = C . gtk _container _get _border _width ( v . native ( ) ) return uint ( c ) } 
func ( v * Container ) Set Border Width ( border Width uint ) { C . gtk _container _set _border _width ( v . native ( ) , C . guint ( border Width ) ) } 
func ( v * Container ) Propagate Draw ( child IWidget , cr * cairo . Context ) { context : = ( * C . cairo _t ) ( unsafe . Pointer ( cr . Native ( ) ) ) C . gtk _container _propagate _draw ( v . native ( ) , child . to Widget ( ) , context ) } 
func Gdk Cairo Set Source Pix Buf ( cr * cairo . Context , pixbuf * gdk . Pixbuf , pixbuf X , pixbuf Y float 6 4 ) { context : = ( * C . cairo _t ) ( unsafe . Pointer ( cr . Native ( ) ) ) ptr : = ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) C . gdk _cairo _set _source _pixbuf ( context , ptr , C . gdouble ( pixbuf X ) , C . gdouble ( pixbuf Y ) ) } 
func ( v * Css Provider ) native ( ) * C . Gtk Css Provider { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Css Provider ( p ) } 
func Css Provider New ( ) ( * Css Provider , error ) { c : = C . gtk _css _provider _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Css Provider ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Css Provider ) Load From Path ( path string ) error { cpath : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cpath ) ) var gerr * C . GError if C . gtk _css _provider _load _from _path ( v . native ( ) , ( * C . gchar ) ( cpath ) , & gerr ) = = 0 { defer C . g _error _free ( gerr ) return errors . New ( go String ( gerr . message ) ) } return nil } 
func ( v * Css Provider ) Load From Data ( data string ) error { cdata : = C . CString ( data ) defer C . free ( unsafe . Pointer ( cdata ) ) var gerr * C . GError if C . gtk _css _provider _load _from _data ( v . native ( ) , ( * C . gchar ) ( unsafe . Pointer ( cdata ) ) , C . gssize ( len ( data ) ) , & gerr ) = = 0 { defer C . g _error _free ( gerr ) return errors . New ( go String ( gerr . message ) ) } return nil } 
func ( v * Css Provider ) To String ( ) ( string , error ) { c : = C . gtk _css _provider _to _string ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( c ) , nil } 
func Css Provider Get Named ( name string , variant string ) ( * Css Provider , error ) { cname : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) cvariant : = C . CString ( variant ) defer C . free ( unsafe . Pointer ( cvariant ) ) c : = C . gtk _css _provider _get _named ( ( * C . gchar ) ( cname ) , ( * C . gchar ) ( cvariant ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Css Provider ( obj ) , nil } 
func ( v * Dialog ) native ( ) * C . Gtk Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Dialog ( p ) } 
func Dialog New ( ) ( * Dialog , error ) { c : = C . gtk _dialog _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Dialog ( obj ) , nil } 
func ( v * Dialog ) Run ( ) Response Type { c : = C . gtk _dialog _run ( v . native ( ) ) return Response Type ( c ) } 
func ( v * Dialog ) Response ( response Response Type ) { C . gtk _dialog _response ( v . native ( ) , C . gint ( response ) ) } 
func ( v * Dialog ) Add Button ( text string , id Response Type ) ( * Button , error ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _dialog _add _button ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( id ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Button ( obj ) , nil } 
func ( v * Dialog ) Add Action Widget ( child IWidget , id Response Type ) { C . gtk _dialog _add _action _widget ( v . native ( ) , child . to Widget ( ) , C . gint ( id ) ) } 
func ( v * Dialog ) Set Default Response ( id Response Type ) { C . gtk _dialog _set _default _response ( v . native ( ) , C . gint ( id ) ) } 
func ( v * Dialog ) Set Response Sensitive ( id Response Type , setting bool ) { C . gtk _dialog _set _response _sensitive ( v . native ( ) , C . gint ( id ) , gbool ( setting ) ) } 
func ( v * Dialog ) Get Response For Widget ( widget IWidget ) Response Type { c : = C . gtk _dialog _get _response _for _widget ( v . native ( ) , widget . to Widget ( ) ) return Response Type ( c ) } 
func ( v * Dialog ) Get Widget For Response ( id Response Type ) ( * Widget , error ) { c : = C . gtk _dialog _get _widget _for _response ( v . native ( ) , C . gint ( id ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( v * Dialog ) Get Content Area ( ) ( * Box , error ) { c : = C . gtk _dialog _get _content _area ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) b : = & Box { Container { Widget { glib . Initially Unowned { obj } } } } return b , nil } 
func ( v * Drawing Area ) native ( ) * C . Gtk Drawing Area { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Drawing Area ( p ) } 
func Drawing Area New ( ) ( * Drawing Area , error ) { c : = C . gtk _drawing _area _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Drawing Area ( obj ) , nil } 
func ( v * Editable ) native ( ) * C . Gtk Editable { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Editable ( p ) } 
func ( v * Editable ) Select Region ( start Pos , end Pos int ) { C . gtk _editable _select _region ( v . native ( ) , C . gint ( start Pos ) , C . gint ( end Pos ) ) } 
func ( v * Editable ) Get Selection Bounds ( ) ( start , end int , non Empty bool ) { var cstart , cend C . gint c : = C . gtk _editable _get _selection _bounds ( v . native ( ) , & cstart , & cend ) return int ( cstart ) , int ( cend ) , gobool ( c ) } 
func ( v * Editable ) Insert Text ( new Text string , position int ) int { cstr : = C . CString ( new Text ) defer C . free ( unsafe . Pointer ( cstr ) ) pos : = new ( C . gint ) * pos = C . gint ( position ) C . gtk _editable _insert _text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( new Text ) ) , pos ) return int ( * pos ) } 
func ( v * Editable ) Delete Text ( start Pos , end Pos int ) { C . gtk _editable _delete _text ( v . native ( ) , C . gint ( start Pos ) , C . gint ( end Pos ) ) } 
func ( v * Editable ) Get Chars ( start Pos , end Pos int ) string { c : = C . gtk _editable _get _chars ( v . native ( ) , C . gint ( start Pos ) , C . gint ( end Pos ) ) defer C . free ( unsafe . Pointer ( c ) ) return go String ( c ) } 
func ( v * Editable ) Get Position ( ) int { c : = C . gtk _editable _get _position ( v . native ( ) ) return int ( c ) } 
func ( v * Editable ) Set Editable ( is Editable bool ) { C . gtk _editable _set _editable ( v . native ( ) , gbool ( is Editable ) ) } 
func ( v * Editable ) Get Editable ( ) bool { c : = C . gtk _editable _get _editable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) native ( ) * C . Gtk Entry { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Entry ( p ) } 
func Entry New ( ) ( * Entry , error ) { c : = C . gtk _entry _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Entry ( obj ) , nil } 
func Entry New With Buffer ( buffer * Entry Buffer ) ( * Entry , error ) { c : = C . gtk _entry _new _with _buffer ( buffer . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Entry ( obj ) , nil } 
func ( v * Entry ) Get Buffer ( ) ( * Entry Buffer , error ) { c : = C . gtk _entry _get _buffer ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Entry Buffer { obj } , nil } 
func ( v * Entry ) Set Buffer ( buffer * Entry Buffer ) { C . gtk _entry _set _buffer ( v . native ( ) , buffer . native ( ) ) } 
func ( v * Entry ) Set Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) Get Text ( ) ( string , error ) { c : = C . gtk _entry _get _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry ) Get Text Length ( ) uint 1 6 { c : = C . gtk _entry _get _text _length ( v . native ( ) ) return uint 1 6 ( c ) } 
func ( v * Entry ) Set Visibility ( visible bool ) { C . gtk _entry _set _visibility ( v . native ( ) , gbool ( visible ) ) } 
func ( v * Entry ) Set Invisible Char ( ch rune ) { C . gtk _entry _set _invisible _char ( v . native ( ) , C . gunichar ( ch ) ) } 
func ( v * Entry ) Set Max Length ( len int ) { C . gtk _entry _set _max _length ( v . native ( ) , C . gint ( len ) ) } 
func ( v * Entry ) Get Activates Default ( ) bool { c : = C . gtk _entry _get _activates _default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) Get Has Frame ( ) bool { c : = C . gtk _entry _get _has _frame ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) Get Width Chars ( ) int { c : = C . gtk _entry _get _width _chars ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) Set Activates Default ( setting bool ) { C . gtk _entry _set _activates _default ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Entry ) Set Width Chars ( n Chars int ) { C . gtk _entry _set _width _chars ( v . native ( ) , C . gint ( n Chars ) ) } 
func ( v * Entry ) Get Invisible Char ( ) rune { c : = C . gtk _entry _get _invisible _char ( v . native ( ) ) return rune ( c ) } 
func ( v * Entry ) Set Alignment ( xalign float 3 2 ) { C . gtk _entry _set _alignment ( v . native ( ) , C . gfloat ( xalign ) ) } 
func ( v * Entry ) Get Alignment ( ) float 3 2 { c : = C . gtk _entry _get _alignment ( v . native ( ) ) return float 3 2 ( c ) } 
func ( v * Entry ) Set Placeholder Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _placeholder _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) Get Placeholder Text ( ) ( string , error ) { c : = C . gtk _entry _get _placeholder _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry ) Set Overwrite Mode ( overwrite bool ) { C . gtk _entry _set _overwrite _mode ( v . native ( ) , gbool ( overwrite ) ) } 
func ( v * Entry ) Get Overwrite Mode ( ) bool { c : = C . gtk _entry _get _overwrite _mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) Get Layout Offsets ( ) ( x , y int ) { var gx , gy C . gint C . gtk _entry _get _layout _offsets ( v . native ( ) , & gx , & gy ) return int ( gx ) , int ( gy ) } 
func ( v * Entry ) Layout Index To Text Index ( layout Index int ) int { c : = C . gtk _entry _layout _index _to _text _index ( v . native ( ) , C . gint ( layout Index ) ) return int ( c ) } 
func ( v * Entry ) Text Index To Layout Index ( text Index int ) int { c : = C . gtk _entry _text _index _to _layout _index ( v . native ( ) , C . gint ( text Index ) ) return int ( c ) } 
func ( v * Entry ) Get Max Length ( ) int { c : = C . gtk _entry _get _max _length ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) Get Visibility ( ) bool { c : = C . gtk _entry _get _visibility ( v . native ( ) ) return gobool ( c ) } 
func ( v * Entry ) Set Completion ( completion * Entry Completion ) { C . gtk _entry _set _completion ( v . native ( ) , completion . native ( ) ) } 
func ( v * Entry ) Get Completion ( ) ( * Entry Completion , error ) { c : = C . gtk _entry _get _completion ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } e : = & Entry Completion { glib . Take ( unsafe . Pointer ( c ) ) } return e , nil } 
func ( v * Entry ) Set Cursor HAdjustment ( adjustment * Adjustment ) { C . gtk _entry _set _cursor _hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Entry ) Get Cursor HAdjustment ( ) ( * Adjustment , error ) { c : = C . gtk _entry _get _cursor _hadjustment ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . Initially Unowned { obj } } , nil } 
func ( v * Entry ) Set Progress Fraction ( fraction float 6 4 ) { C . gtk _entry _set _progress _fraction ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * Entry ) Get Progress Fraction ( ) float 6 4 { c : = C . gtk _entry _get _progress _fraction ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Entry ) Set Progress Pulse Step ( fraction float 6 4 ) { C . gtk _entry _set _progress _pulse _step ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * Entry ) Get Progress Pulse Step ( ) float 6 4 { c : = C . gtk _entry _get _progress _pulse _step ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Entry ) Set Icon From Pixbuf ( icon Pos Entry Icon Position , pixbuf * gdk . Pixbuf ) { C . gtk _entry _set _icon _from _pixbuf ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Entry ) Set Icon From Icon Name ( icon Pos Entry Icon Position , name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _icon _from _icon _name ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) Remove Icon ( icon Pos Entry Icon Position ) { C . gtk _entry _set _icon _from _icon _name ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , nil ) } 
func ( v * Entry ) Get Icon Storage Type ( icon Pos Entry Icon Position ) Image Type { c : = C . gtk _entry _get _icon _storage _type ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) return Image Type ( c ) } 
func ( v * Entry ) Get Icon Name ( icon Pos Entry Icon Position ) ( string , error ) { c : = C . gtk _entry _get _icon _name ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry ) Set Icon Activatable ( icon Pos Entry Icon Position , activatable bool ) { C . gtk _entry _set _icon _activatable ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , gbool ( activatable ) ) } 
func ( v * Entry ) Get Icon Activatable ( icon Pos Entry Icon Position ) bool { c : = C . gtk _entry _get _icon _activatable ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) return gobool ( c ) } 
func ( v * Entry ) Set Icon Sensitive ( icon Pos Entry Icon Position , sensitive bool ) { C . gtk _entry _set _icon _sensitive ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , gbool ( sensitive ) ) } 
func ( v * Entry ) Get Icon Sensitive ( icon Pos Entry Icon Position ) bool { c : = C . gtk _entry _get _icon _sensitive ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) return gobool ( c ) } 
func ( v * Entry ) Get Icon At Pos ( x , y int ) int { c : = C . gtk _entry _get _icon _at _pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) return int ( c ) } 
func ( v * Entry ) Set Icon Tooltip Text ( icon Pos Entry Icon Position , tooltip string ) { cstr : = C . CString ( tooltip ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _icon _tooltip _text ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) Get Icon Tooltip Text ( icon Pos Entry Icon Position ) ( string , error ) { c : = C . gtk _entry _get _icon _tooltip _text ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry ) Set Icon Tooltip Markup ( icon Pos Entry Icon Position , tooltip string ) { cstr : = C . CString ( tooltip ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _set _icon _tooltip _markup ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Entry ) Get Icon Tooltip Markup ( icon Pos Entry Icon Position ) ( string , error ) { c : = C . gtk _entry _get _icon _tooltip _markup ( v . native ( ) , C . Gtk Entry Icon Position ( icon Pos ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry ) Get Current Icon Drag Source ( ) int { c : = C . gtk _entry _get _current _icon _drag _source ( v . native ( ) ) return int ( c ) } 
func ( v * Entry ) Set Input Purpose ( purpose Input Purpose ) { C . gtk _entry _set _input _purpose ( v . native ( ) , C . Gtk Input Purpose ( purpose ) ) } 
func ( v * Entry ) Get Input Purpose ( ) Input Purpose { c : = C . gtk _entry _get _input _purpose ( v . native ( ) ) return Input Purpose ( c ) } 
func ( v * Entry ) Set Input Hints ( hints Input Hints ) { C . gtk _entry _set _input _hints ( v . native ( ) , C . Gtk Input Hints ( hints ) ) } 
func ( v * Entry ) Get Input Hints ( ) Input Hints { c : = C . gtk _entry _get _input _hints ( v . native ( ) ) return Input Hints ( c ) } 
func ( v * Entry Buffer ) native ( ) * C . Gtk Entry Buffer { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Entry Buffer ( p ) } 
func Entry Buffer New ( initial Chars string , n Initial Chars int ) ( * Entry Buffer , error ) { cstr : = C . CString ( initial Chars ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _entry _buffer _new ( ( * C . gchar ) ( cstr ) , C . gint ( n Initial Chars ) ) if c = = nil { return nil , nil Ptr Err } e : = wrap Entry Buffer ( glib . Take ( unsafe . Pointer ( c ) ) ) return e , nil } 
func ( v * Entry Buffer ) Get Text ( ) ( string , error ) { c : = C . gtk _entry _buffer _get _text ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return go String ( c ) , nil } 
func ( v * Entry Buffer ) Set Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _buffer _set _text ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * Entry Buffer ) Get Bytes ( ) uint { c : = C . gtk _entry _buffer _get _bytes ( v . native ( ) ) return uint ( c ) } 
func ( v * Entry Buffer ) Get Length ( ) uint { c : = C . gtk _entry _buffer _get _length ( v . native ( ) ) return uint ( c ) } 
func ( v * Entry Buffer ) Get Max Length ( ) int { c : = C . gtk _entry _buffer _get _max _length ( v . native ( ) ) return int ( c ) } 
func ( v * Entry Buffer ) Set Max Length ( max Length int ) { C . gtk _entry _buffer _set _max _length ( v . native ( ) , C . gint ( max Length ) ) } 
func ( v * Entry Buffer ) Insert Text ( position uint , text string ) uint { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _entry _buffer _insert _text ( v . native ( ) , C . guint ( position ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) return uint ( c ) } 
func ( v * Entry Buffer ) Delete Text ( position uint , n Chars int ) uint { c : = C . gtk _entry _buffer _delete _text ( v . native ( ) , C . guint ( position ) , C . gint ( n Chars ) ) return uint ( c ) } 
func ( v * Entry Buffer ) Emit Deleted Text ( pos , n Chars uint ) { C . gtk _entry _buffer _emit _deleted _text ( v . native ( ) , C . guint ( pos ) , C . guint ( n Chars ) ) } 
func ( v * Entry Buffer ) Emit Inserted Text ( pos uint , text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _entry _buffer _emit _inserted _text ( v . native ( ) , C . guint ( pos ) , ( * C . gchar ) ( cstr ) , C . guint ( len ( text ) ) ) } 
func ( v * Entry Completion ) native ( ) * C . Gtk Entry Completion { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Entry Completion ( p ) } 
func ( v * Event Box ) native ( ) * C . Gtk Event Box { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Event Box ( p ) } 
func Event Box New ( ) ( * Event Box , error ) { c : = C . gtk _event _box _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Event Box ( obj ) , nil } 
func ( v * Event Box ) Set Above Child ( above Child bool ) { C . gtk _event _box _set _above _child ( v . native ( ) , gbool ( above Child ) ) } 
func ( v * Event Box ) Get Above Child ( ) bool { c : = C . gtk _event _box _get _above _child ( v . native ( ) ) return gobool ( c ) } 
func ( v * Event Box ) Set Visible Window ( visible Window bool ) { C . gtk _event _box _set _visible _window ( v . native ( ) , gbool ( visible Window ) ) } 
func ( v * Event Box ) Get Visible Window ( ) bool { c : = C . gtk _event _box _get _visible _window ( v . native ( ) ) return gobool ( c ) } 
func ( v * Expander ) native ( ) * C . Gtk Expander { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Expander ( p ) } 
func Expander New ( label string ) ( * Expander , error ) { var cstr * C . gchar if label ! = " " { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } c : = C . gtk _expander _new ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Expander ( obj ) , nil } 
func ( v * Expander ) Get Expanded ( ) bool { c : = C . gtk _expander _get _expanded ( v . native ( ) ) return gobool ( c ) } 
func ( v * Expander ) Set Label ( label string ) { var cstr * C . char if label ! = " " { cstr = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } C . gtk _expander _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Expander ) Get Label ( ) string { c : = C . gtk _expander _get _label ( v . native ( ) ) return go String ( c ) } 
func ( v * Expander ) Set Label Widget ( widget IWidget ) { C . gtk _expander _set _label _widget ( v . native ( ) , widget . to Widget ( ) ) } 
func ( v * File Chooser ) native ( ) * C . Gtk File Chooser { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Chooser ( p ) } 
func ( v * File Chooser ) Set Filename ( filename string ) bool { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _file _chooser _set _filename ( v . native ( ) , cstr ) return gobool ( c ) } 
func ( v * File Chooser ) Get Filename ( ) string { c : = C . gtk _file _chooser _get _filename ( v . native ( ) ) s : = go String ( c ) defer C . g _free ( ( C . gpointer ) ( c ) ) return s } 
func ( v * File Chooser ) Get Filenames ( ) ( * glib . SList , error ) { c : = C . gtk _file _chooser _get _filenames ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return glib . Wrap SList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v File Chooser ) Get URIs ( ) ( * glib . SList , error ) { c : = C . gtk _file _chooser _get _uris ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return glib . Wrap SList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * File Chooser ) Set Do Overwrite Confirmation ( value bool ) { C . gtk _file _chooser _set _do _overwrite _confirmation ( v . native ( ) , gbool ( value ) ) } 
func ( v * File Chooser ) Get Do Overwrite Confirmation ( ) bool { c : = C . gtk _file _chooser _get _do _overwrite _confirmation ( v . native ( ) ) return gobool ( c ) } 
func ( v * File Chooser ) Set Create Folders ( value bool ) { C . gtk _file _chooser _set _create _folders ( v . native ( ) , gbool ( value ) ) } 
func ( v * File Chooser ) Get Create Folders ( ) bool { c : = C . gtk _file _chooser _get _create _folders ( v . native ( ) ) return gobool ( c ) } 
func ( v * File Chooser ) Set Current Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _file _chooser _set _current _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return } 
func ( v * File Chooser ) Set Current Folder ( folder string ) bool { cstr : = C . CString ( folder ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _file _chooser _set _current _folder ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( c ) } 
func ( v * File Chooser ) Get Current Folder ( ) ( string , error ) { c : = C . gtk _file _chooser _get _current _folder ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } defer C . free ( unsafe . Pointer ( c ) ) return go String ( c ) , nil } 
func ( v * File Chooser ) Set Preview Widget ( widget IWidget ) { C . gtk _file _chooser _set _preview _widget ( v . native ( ) , widget . to Widget ( ) ) } 
func ( v * File Chooser ) Set Preview Widget Active ( active bool ) { C . gtk _file _chooser _set _preview _widget _active ( v . native ( ) , gbool ( active ) ) } 
func ( v * File Chooser ) Get Preview Filename ( ) string { c : = C . gtk _file _chooser _get _preview _filename ( v . native ( ) ) defer C . free ( unsafe . Pointer ( c ) ) return C . Go String ( c ) } 
func ( v * File Chooser ) Get URI ( ) string { c : = C . gtk _file _chooser _get _uri ( v . native ( ) ) s : = go String ( c ) defer C . g _free ( ( C . gpointer ) ( c ) ) return s } 
func ( v * File Chooser ) Add Filter ( filter * File Filter ) { C . gtk _file _chooser _add _filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * File Chooser ) Remove Filter ( filter * File Filter ) { C . gtk _file _chooser _remove _filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * File Chooser ) Set Filter ( filter * File Filter ) { C . gtk _file _chooser _set _filter ( v . native ( ) , filter . native ( ) ) } 
func ( v * File Chooser ) Add Shortcut Folder ( folder string ) bool { cstr : = C . CString ( folder ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _file _chooser _add _shortcut _folder ( v . native ( ) , cstr , nil ) return gobool ( c ) } 
func ( v * File Chooser ) Set Local Only ( value bool ) { C . gtk _file _chooser _set _local _only ( v . native ( ) , gbool ( value ) ) } 
func ( v * File Chooser ) Get Local Only ( ) bool { c : = C . gtk _file _chooser _get _local _only ( v . native ( ) ) return gobool ( c ) } 
func ( v * File Chooser ) Set Select Multiple ( value bool ) { C . gtk _file _chooser _set _select _multiple ( v . native ( ) , gbool ( value ) ) } 
func ( v * File Chooser ) Get Select Multiple ( ) bool { c : = C . gtk _file _chooser _get _select _multiple ( v . native ( ) ) return gobool ( c ) } 
func ( v * File Chooser Button ) native ( ) * C . Gtk File Chooser Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Chooser Button ( p ) } 
func File Chooser Button New ( title string , action File Chooser Action ) ( * File Chooser Button , error ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _file _chooser _button _new ( ( * C . gchar ) ( cstr ) , ( C . Gtk File Chooser Action ) ( action ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap File Chooser Button ( obj ) , nil } 
func ( v * File Chooser Dialog ) native ( ) * C . Gtk File Chooser Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Chooser Dialog ( p ) } 
func File Chooser Dialog New With 1Button ( title string , parent * Window , action File Chooser Action , first _button _text string , first _button _id Response Type ) ( * File Chooser Dialog , error ) { c _title : = C . CString ( title ) defer C . free ( unsafe . Pointer ( c _title ) ) c _first _button _text : = C . CString ( first _button _text ) defer C . free ( unsafe . Pointer ( c _first _button _text ) ) c : = C . gtk _file _chooser _dialog _new _ 1 ( ( * C . gchar ) ( c _title ) , parent . native ( ) , C . Gtk File Chooser Action ( action ) , ( * C . gchar ) ( c _first _button _text ) , C . int ( first _button _id ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap File Chooser Dialog ( obj ) , nil } 
func ( v * File Chooser Widget ) native ( ) * C . Gtk File Chooser Widget { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Chooser Widget ( p ) } 
func File Chooser Widget New ( action File Chooser Action ) ( * File Chooser Widget , error ) { c : = C . gtk _file _chooser _widget _new ( ( C . Gtk File Chooser Action ) ( action ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap File Chooser Widget ( obj ) , nil } 
func ( v * File Filter ) native ( ) * C . Gtk File Filter { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk File Filter ( p ) } 
func File Filter New ( ) ( * File Filter , error ) { c : = C . gtk _file _filter _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap File Filter ( obj ) , nil } 
func ( v * File Filter ) Set Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _file _filter _set _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * File Filter ) Add Pattern ( pattern string ) { cstr : = C . CString ( pattern ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _file _filter _add _pattern ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Frame ) native ( ) * C . Gtk Frame { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Frame ( p ) } 
func Frame New ( label string ) ( * Frame , error ) { var cstr * C . char if label ! = " " { cstr = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) } c : = C . gtk _frame _new ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Frame ( obj ) , nil } 
func ( v * Frame ) Set Label ( label string ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _frame _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Frame ) Set Label Widget ( label Widget IWidget ) { C . gtk _frame _set _label _widget ( v . native ( ) , label Widget . to Widget ( ) ) } 
func ( v * Frame ) Set Label Align ( x Align , y Align float 3 2 ) { C . gtk _frame _set _label _align ( v . native ( ) , C . gfloat ( x Align ) , C . gfloat ( y Align ) ) } 
func ( v * Frame ) Set Shadow Type ( t Shadow Type ) { C . gtk _frame _set _shadow _type ( v . native ( ) , C . Gtk Shadow Type ( t ) ) } 
func ( v * Frame ) Get Label ( ) string { c : = C . gtk _frame _get _label ( v . native ( ) ) return go String ( c ) } 
func ( v * Frame ) Get Label Align ( ) ( x Align , y Align float 3 2 ) { var x , y C . gfloat C . gtk _frame _get _label _align ( v . native ( ) , & x , & y ) return float 3 2 ( x ) , float 3 2 ( y ) } 
func ( v * Frame ) Get Label Widget ( ) ( * Widget , error ) { c : = C . gtk _frame _get _label _widget ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( v * Frame ) Get Shadow Type ( ) Shadow Type { c : = C . gtk _frame _get _shadow _type ( v . native ( ) ) return Shadow Type ( c ) } 
func ( v * Aspect Frame ) native ( ) * C . Gtk Aspect Frame { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Aspect Frame ( p ) } 
func ( v * Grid ) native ( ) * C . Gtk Grid { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Grid ( p ) } 
func Grid New ( ) ( * Grid , error ) { c : = C . gtk _grid _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Grid ( obj ) , nil } 
func ( v * Grid ) Attach ( child IWidget , left , top , width , height int ) { C . gtk _grid _attach ( v . native ( ) , child . to Widget ( ) , C . gint ( left ) , C . gint ( top ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Grid ) Attach Next To ( child , sibling IWidget , side Position Type , width , height int ) { C . gtk _grid _attach _next _to ( v . native ( ) , child . to Widget ( ) , sibling . to Widget ( ) , C . Gtk Position Type ( side ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Grid ) Get Child At ( left , top int ) ( * Widget , error ) { c : = C . gtk _grid _get _child _at ( v . native ( ) , C . gint ( left ) , C . gint ( top ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) , nil } 
func ( v * Grid ) Insert Row ( position int ) { C . gtk _grid _insert _row ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) Insert Column ( position int ) { C . gtk _grid _insert _column ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Grid ) Insert Next To ( sibling IWidget , side Position Type ) { C . gtk _grid _insert _next _to ( v . native ( ) , sibling . to Widget ( ) , C . Gtk Position Type ( side ) ) } 
func ( v * Grid ) Set Row Homogeneous ( homogeneous bool ) { C . gtk _grid _set _row _homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Grid ) Get Row Homogeneous ( ) bool { c : = C . gtk _grid _get _row _homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Grid ) Set Row Spacing ( spacing uint ) { C . gtk _grid _set _row _spacing ( v . native ( ) , C . guint ( spacing ) ) } 
func ( v * Grid ) Get Row Spacing ( ) uint { c : = C . gtk _grid _get _row _spacing ( v . native ( ) ) return uint ( c ) } 
func ( v * Grid ) Set Column Homogeneous ( homogeneous bool ) { C . gtk _grid _set _column _homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Grid ) Get Column Homogeneous ( ) bool { c : = C . gtk _grid _get _column _homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Grid ) Set Column Spacing ( spacing uint ) { C . gtk _grid _set _column _spacing ( v . native ( ) , C . guint ( spacing ) ) } 
func ( v * Grid ) Get Column Spacing ( ) uint { c : = C . gtk _grid _get _column _spacing ( v . native ( ) ) return uint ( c ) } 
func Icon Theme Get Default ( ) ( * Icon Theme , error ) { c : = C . gtk _icon _theme _get _default ( ) if c = = nil { return nil , nil Ptr Err } return & Icon Theme { c } , nil } 
func Icon Theme Get For Screen ( screen gdk . Screen ) ( * Icon Theme , error ) { c Screen : = ( * C . Gdk Screen ) ( unsafe . Pointer ( screen . Native ( ) ) ) c : = C . gtk _icon _theme _get _for _screen ( c Screen ) if c = = nil { return nil , nil Ptr Err } return & Icon Theme { c } , nil } 
func ( v * Icon Theme ) Load Icon ( icon Name string , size int , flags Icon Lookup Flags ) ( * gdk . Pixbuf , error ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c : = C . gtk _icon _theme _load _icon ( v . Theme , ( * C . gchar ) ( cstr ) , C . gint ( size ) , C . Gtk Icon Lookup Flags ( flags ) , & err ) if c = = nil { defer C . g _error _free ( err ) return nil , errors . New ( go String ( err . message ) ) } return & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Image ) native ( ) * C . Gtk Image { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Image ( p ) } 
func Image New ( ) ( * Image , error ) { c : = C . gtk _image _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Image ( obj ) , nil } 
func Image New From File ( filename string ) ( * Image , error ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _image _new _from _file ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Image ( obj ) , nil } 
func Image New From Resource ( resource Path string ) ( * Image , error ) { cstr : = C . CString ( resource Path ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _image _new _from _resource ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Image ( obj ) , nil } 
func Image New From Pixbuf ( pixbuf * gdk . Pixbuf ) ( * Image , error ) { c : = C . gtk _image _new _from _pixbuf ( ( * C . Gdk Pixbuf ) ( pixbuf . Native Private ( ) ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Image ( obj ) , nil } 
func Image New From Icon Name ( icon Name string , size Icon Size ) ( * Image , error ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _image _new _from _icon _name ( ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Image ( obj ) , nil } 
func ( v * Image ) Set From File ( filename string ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _image _set _from _file ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Image ) Set From Resource ( resource Path string ) { cstr : = C . CString ( resource Path ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _image _set _from _resource ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Image ) Set From Pixbuf ( pixbuf * gdk . Pixbuf ) { pbptr : = ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) C . gtk _image _set _from _pixbuf ( v . native ( ) , pbptr ) } 
func ( v * Image ) Set From Icon Name ( icon Name string , size Icon Size ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _image _set _from _icon _name ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . Gtk Icon Size ( size ) ) } 
func ( v * Image ) Set Pixel Size ( pixel Size int ) { C . gtk _image _set _pixel _size ( v . native ( ) , C . gint ( pixel Size ) ) } 
func ( v * Image ) Get Storage Type ( ) Image Type { c : = C . gtk _image _get _storage _type ( v . native ( ) ) return Image Type ( c ) } 
func ( v * Image ) Get Pixbuf ( ) * gdk . Pixbuf { c : = C . gtk _image _get _pixbuf ( v . native ( ) ) if c = = nil { return nil } pb : = & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return pb } 
func ( v * Image ) Get Icon Name ( ) ( string , Icon Size ) { var icon Name * C . gchar var size C . Gtk Icon Size C . gtk _image _get _icon _name ( v . native ( ) , & icon Name , & size ) return go String ( icon Name ) , Icon Size ( size ) } 
func ( v * Image ) Get Pixel Size ( ) int { c : = C . gtk _image _get _pixel _size ( v . native ( ) ) return int ( c ) } 
func ( v * Layout ) native ( ) * C . Gtk Layout { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Layout ( p ) } 
func Layout New ( hadjustment , vadjustment * Adjustment ) ( * Layout , error ) { c : = C . gtk _layout _new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Layout ( obj ) , nil } 
func ( v * Layout ) Put ( w IWidget , x , y int ) { C . gtk _layout _put ( v . native ( ) , w . to Widget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Layout ) Move ( w IWidget , x , y int ) { C . gtk _layout _move ( v . native ( ) , w . to Widget ( ) , C . gint ( x ) , C . gint ( y ) ) } 
func ( v * Layout ) Set Size ( width , height uint ) { C . gtk _layout _set _size ( v . native ( ) , C . guint ( width ) , C . guint ( height ) ) } 
func ( v * Layout ) Get Size ( ) ( width , height uint ) { var w , h C . guint C . gtk _layout _get _size ( v . native ( ) , & w , & h ) return uint ( w ) , uint ( h ) } 
func ( v * Link Button ) native ( ) * C . Gtk Link Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Link Button ( p ) } 
func Link Button New ( label string ) ( * Link Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _link _button _new ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Link Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Link Button New With Label ( uri , label string ) ( * Link Button , error ) { curi : = C . CString ( uri ) defer C . free ( unsafe . Pointer ( curi ) ) clabel : = C . CString ( label ) defer C . free ( unsafe . Pointer ( clabel ) ) c : = C . gtk _link _button _new _with _label ( ( * C . gchar ) ( curi ) , ( * C . gchar ) ( clabel ) ) if c = = nil { return nil , nil Ptr Err } return wrap Link Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Link Button ) Get Uri ( ) string { c : = C . gtk _link _button _get _uri ( v . native ( ) ) return go String ( c ) } 
func ( v * Link Button ) Set Uri ( uri string ) { cstr : = C . CString ( uri ) C . gtk _link _button _set _uri ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * List Store ) native ( ) * C . Gtk List Store { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk List Store ( p ) } 
func List Store New ( types . . . glib . Type ) ( * List Store , error ) { gtypes : = C . alloc _types ( C . int ( len ( types ) ) ) for n , val : = range types { C . set _type ( gtypes , C . int ( n ) , C . GType ( val ) ) } defer C . g _free ( C . gpointer ( gtypes ) ) c : = C . gtk _list _store _newv ( C . gint ( len ( types ) ) , gtypes ) if c = = nil { return nil , nil Ptr Err } ls : = wrap List Store ( glib . Take ( unsafe . Pointer ( c ) ) ) return ls , nil } 
func ( v * List Store ) Remove ( iter * Tree Iter ) bool { c : = C . gtk _list _store _remove ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * List Store ) Set ( iter * Tree Iter , columns [ ] int , values [ ] interface { } ) error { if len ( columns ) ! = len ( values ) { return errors . New ( " " ) } for i , val : = range values { v . Set Value ( iter , columns [ i ] , val ) } return nil } 
func ( v * List Store ) Set Value ( iter * Tree Iter , column int , value interface { } ) error { switch value . ( type ) { case * gdk . Pixbuf : pix : = value . ( * gdk . Pixbuf ) C . _gtk _list _store _set ( v . native ( ) , iter . native ( ) , C . gint ( column ) , unsafe . Pointer ( pix . Native ( ) ) ) default : gv , err : = glib . GValue ( value ) if err ! = nil { return err } C . gtk _list _store _set _value ( v . native ( ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( unsafe . Pointer ( gv . Native ( ) ) ) ) } return nil } 
func ( v * List Store ) Insert With Values ( iter * Tree Iter , position int , in Columns [ ] int , in Values [ ] interface { } ) error { length : = len ( in Columns ) if len ( in Values ) < length { length = len ( in Values ) } var c Columns [ ] C . gint var c Values [ ] C . GValue for i : = 0 ; i < length ; i + + { c Columns = append ( c Columns , C . gint ( in Columns [ i ] ) ) gv , err : = glib . GValue ( in Values [ i ] ) if err ! = nil { return err } var cvp * C . GValue = ( * C . GValue ) ( gv . Native ( ) ) c Values = append ( c Values , * cvp ) } var c Columns Pointer * C . gint = & c Columns [ 0 ] var c Values Pointer * C . GValue = & c Values [ 0 ] C . gtk _list _store _insert _with _valuesv ( v . native ( ) , iter . native ( ) , C . gint ( position ) , c Columns Pointer , c Values Pointer , C . gint ( length ) ) return nil } 
func ( v * List Store ) Insert Before ( sibling * Tree Iter ) * Tree Iter { var ti C . Gtk Tree Iter C . gtk _list _store _insert _before ( v . native ( ) , & ti , sibling . native ( ) ) iter : = & Tree Iter { ti } return iter } 
func ( v * List Store ) Insert After ( sibling * Tree Iter ) * Tree Iter { var ti C . Gtk Tree Iter C . gtk _list _store _insert _after ( v . native ( ) , & ti , sibling . native ( ) ) iter : = & Tree Iter { ti } return iter } 
func ( v * List Store ) Prepend ( ) * Tree Iter { var ti C . Gtk Tree Iter C . gtk _list _store _prepend ( v . native ( ) , & ti ) iter : = & Tree Iter { ti } return iter } 
func ( v * List Store ) Append ( ) * Tree Iter { var ti C . Gtk Tree Iter C . gtk _list _store _append ( v . native ( ) , & ti ) iter : = & Tree Iter { ti } return iter } 
func ( v * List Store ) Iter Is Valid ( iter * Tree Iter ) bool { c : = C . gtk _list _store _iter _is _valid ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * List Store ) Swap ( a , b * Tree Iter ) { C . gtk _list _store _swap ( v . native ( ) , a . native ( ) , b . native ( ) ) } 
func ( v * List Store ) Move Before ( iter , position * Tree Iter ) { C . gtk _list _store _move _before ( v . native ( ) , iter . native ( ) , position . native ( ) ) } 
func ( v * List Store ) Move After ( iter , position * Tree Iter ) { C . gtk _list _store _move _after ( v . native ( ) , iter . native ( ) , position . native ( ) ) } 
func ( v * Menu Bar ) native ( ) * C . Gtk Menu Bar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Menu Bar ( p ) } 
func Menu Bar New ( ) ( * Menu Bar , error ) { c : = C . gtk _menu _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Menu Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Menu Button ) native ( ) * C . Gtk Menu Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Menu Button ( p ) } 
func Menu Button New ( ) ( * Menu Button , error ) { c : = C . gtk _menu _button _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Menu Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Menu Button ) Set Popup ( menu IMenu ) { C . gtk _menu _button _set _popup ( v . native ( ) , menu . to Widget ( ) ) } 
func ( v * Menu Button ) Get Popup ( ) * Menu { c : = C . gtk _menu _button _get _popup ( v . native ( ) ) if c = = nil { return nil } return wrap Menu ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Button ) Set Menu Model ( menu Model * glib . Menu Model ) { C . gtk _menu _button _set _menu _model ( v . native ( ) , C . to GMenu Model ( unsafe . Pointer ( menu Model . Native ( ) ) ) ) } 
func ( v * Menu Button ) Get Menu Model ( ) * glib . Menu Model { c : = C . gtk _menu _button _get _menu _model ( v . native ( ) ) if c = = nil { return nil } return & glib . Menu Model { glib . Take ( unsafe . Pointer ( c ) ) } } 
func ( v * Menu Button ) Set Direction ( direction Arrow Type ) { C . gtk _menu _button _set _direction ( v . native ( ) , C . Gtk Arrow Type ( direction ) ) } 
func ( v * Menu Button ) Get Direction ( ) Arrow Type { c : = C . gtk _menu _button _get _direction ( v . native ( ) ) return Arrow Type ( c ) } 
func ( v * Menu Button ) Set Align Widget ( align Widget IWidget ) { C . gtk _menu _button _set _align _widget ( v . native ( ) , align Widget . to Widget ( ) ) } 
func ( v * Menu Button ) Get Align Widget ( ) * Widget { c : = C . gtk _menu _button _get _align _widget ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Menu Item ) native ( ) * C . Gtk Menu Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Menu Item ( p ) } 
func Menu Item New ( ) ( * Menu Item , error ) { c : = C . gtk _menu _item _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Menu Item New With Label ( label string ) ( * Menu Item , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _menu _item _new _with _label ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Menu Item ) Set Submenu ( submenu IWidget ) { C . gtk _menu _item _set _submenu ( v . native ( ) , submenu . to Widget ( ) ) } 
func ( v * Menu Item ) Set Label ( label string ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _menu _item _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Menu Item ) Get Label ( ) string { l : = C . gtk _menu _item _get _label ( v . native ( ) ) return go String ( l ) } 
func ( v * Message Dialog ) native ( ) * C . Gtk Message Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Message Dialog ( p ) } 
func Message Dialog New ( parent IWindow , flags Dialog Flags , m Type Message Type , buttons Buttons Type , format string , a . . . interface { } ) * Message Dialog { s : = fmt . Sprintf ( format , a . . . ) cstr : = C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) var w * C . Gtk Window = nil if parent ! = nil { w = parent . to Window ( ) } c : = C . _gtk _message _dialog _new ( w , C . Gtk Dialog Flags ( flags ) , C . Gtk Message Type ( m Type ) , C . Gtk Buttons Type ( buttons ) , cstr ) return wrap Message Dialog ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Message Dialog ) Set Markup ( str string ) { cstr : = C . CString ( str ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _message _dialog _set _markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Message Dialog ) Format Secondary Text ( format string , a . . . interface { } ) { s : = fmt . Sprintf ( format , a . . . ) cstr : = C . CString ( s ) defer C . free ( unsafe . Pointer ( cstr ) ) C . _gtk _message _dialog _format _secondary _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) native ( ) * C . Gtk Notebook { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Notebook ( p ) } 
func Notebook New ( ) ( * Notebook , error ) { c : = C . gtk _notebook _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Notebook ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) Append Page ( child IWidget , tab Label IWidget ) int { c Tab Label : = nullable Widget ( tab Label ) c : = C . gtk _notebook _append _page ( v . native ( ) , child . to Widget ( ) , c Tab Label ) return int ( c ) } 
func ( v * Notebook ) Append Page Menu ( child IWidget , tab Label IWidget , menu Label IWidget ) int { c : = C . gtk _notebook _append _page _menu ( v . native ( ) , child . to Widget ( ) , tab Label . to Widget ( ) , menu Label . to Widget ( ) ) return int ( c ) } 
func ( v * Notebook ) Prepend Page ( child IWidget , tab Label IWidget ) int { c Tab Label : = nullable Widget ( tab Label ) c : = C . gtk _notebook _prepend _page ( v . native ( ) , child . to Widget ( ) , c Tab Label ) return int ( c ) } 
func ( v * Notebook ) Prepend Page Menu ( child IWidget , tab Label IWidget , menu Label IWidget ) int { c : = C . gtk _notebook _prepend _page _menu ( v . native ( ) , child . to Widget ( ) , tab Label . to Widget ( ) , menu Label . to Widget ( ) ) return int ( c ) } 
func ( v * Notebook ) Insert Page ( child IWidget , tab Label IWidget , position int ) int { label : = nullable Widget ( tab Label ) c : = C . gtk _notebook _insert _page ( v . native ( ) , child . to Widget ( ) , label , C . gint ( position ) ) return int ( c ) } 
func ( v * Notebook ) Insert Page Menu ( child IWidget , tab Label IWidget , menu Label IWidget , position int ) int { c : = C . gtk _notebook _insert _page _menu ( v . native ( ) , child . to Widget ( ) , tab Label . to Widget ( ) , menu Label . to Widget ( ) , C . gint ( position ) ) return int ( c ) } 
func ( v * Notebook ) Remove Page ( page Num int ) { C . gtk _notebook _remove _page ( v . native ( ) , C . gint ( page Num ) ) } 
func ( v * Notebook ) Page Num ( child IWidget ) int { c : = C . gtk _notebook _page _num ( v . native ( ) , child . to Widget ( ) ) return int ( c ) } 
func ( v * Notebook ) Reorder Child ( child IWidget , position int ) { C . gtk _notebook _reorder _child ( v . native ( ) , child . to Widget ( ) , C . gint ( position ) ) } 
func ( v * Notebook ) Set Tab Pos ( pos Position Type ) { C . gtk _notebook _set _tab _pos ( v . native ( ) , C . Gtk Position Type ( pos ) ) } 
func ( v * Notebook ) Set Show Tabs ( show Tabs bool ) { C . gtk _notebook _set _show _tabs ( v . native ( ) , gbool ( show Tabs ) ) } 
func ( v * Notebook ) Set Show Border ( show Border bool ) { C . gtk _notebook _set _show _border ( v . native ( ) , gbool ( show Border ) ) } 
func ( v * Notebook ) Get Current Page ( ) int { c : = C . gtk _notebook _get _current _page ( v . native ( ) ) return int ( c ) } 
func ( v * Notebook ) Get Menu Label ( child IWidget ) ( * Widget , error ) { c : = C . gtk _notebook _get _menu _label ( v . native ( ) , child . to Widget ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) Get Nth Page ( page Num int ) ( * Widget , error ) { c : = C . gtk _notebook _get _nth _page ( v . native ( ) , C . gint ( page Num ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Notebook ) Get NPages ( ) int { c : = C . gtk _notebook _get _n _pages ( v . native ( ) ) return int ( c ) } 
func ( v * Notebook ) Set Menu Label ( child , menu Label IWidget ) { C . gtk _notebook _set _menu _label ( v . native ( ) , child . to Widget ( ) , menu Label . to Widget ( ) ) } 
func ( v * Notebook ) Set Menu Label Text ( child IWidget , menu Text string ) { cstr : = C . CString ( menu Text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _notebook _set _menu _label _text ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) Set Tab Label ( child , tab Label IWidget ) { C . gtk _notebook _set _tab _label ( v . native ( ) , child . to Widget ( ) , tab Label . to Widget ( ) ) } 
func ( v * Notebook ) Set Tab Label Text ( child IWidget , tab Text string ) { cstr : = C . CString ( tab Text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _notebook _set _tab _label _text ( v . native ( ) , child . to Widget ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) Set Tab Reorderable ( child IWidget , reorderable bool ) { C . gtk _notebook _set _tab _reorderable ( v . native ( ) , child . to Widget ( ) , gbool ( reorderable ) ) } 
func ( v * Notebook ) Set Tab Detachable ( child IWidget , detachable bool ) { C . gtk _notebook _set _tab _detachable ( v . native ( ) , child . to Widget ( ) , gbool ( detachable ) ) } 
func ( v * Notebook ) Get Menu Label Text ( child IWidget ) ( string , error ) { c : = C . gtk _notebook _get _menu _label _text ( v . native ( ) , child . to Widget ( ) ) if c = = nil { return " " , errors . New ( " " ) } return go String ( c ) , nil } 
func ( v * Notebook ) Get Scrollable ( ) bool { c : = C . gtk _notebook _get _scrollable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) Get Show Border ( ) bool { c : = C . gtk _notebook _get _show _border ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) Get Show Tabs ( ) bool { c : = C . gtk _notebook _get _show _tabs ( v . native ( ) ) return gobool ( c ) } 
func ( v * Notebook ) Get Tab Label Text ( child IWidget ) ( string , error ) { c : = C . gtk _notebook _get _tab _label _text ( v . native ( ) , child . to Widget ( ) ) if c = = nil { return " " , errors . New ( " " ) } return go String ( c ) , nil } 
func ( v * Notebook ) Get Tab Pos ( ) Position Type { c : = C . gtk _notebook _get _tab _pos ( v . native ( ) ) return Position Type ( c ) } 
func ( v * Notebook ) Get Tab Reorderable ( child IWidget ) bool { c : = C . gtk _notebook _get _tab _reorderable ( v . native ( ) , child . to Widget ( ) ) return gobool ( c ) } 
func ( v * Notebook ) Get Tab Detachable ( child IWidget ) bool { c : = C . gtk _notebook _get _tab _detachable ( v . native ( ) , child . to Widget ( ) ) return gobool ( c ) } 
func ( v * Notebook ) Set Group Name ( group Name string ) { cstr : = C . CString ( group Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _notebook _set _group _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Notebook ) Get Group Name ( ) ( string , error ) { c : = C . gtk _notebook _get _group _name ( v . native ( ) ) if c = = nil { return " " , errors . New ( " " ) } return go String ( c ) , nil } 
func ( v * Notebook ) Set Action Widget ( widget IWidget , pack Type Pack Type ) { C . gtk _notebook _set _action _widget ( v . native ( ) , widget . to Widget ( ) , C . Gtk Pack Type ( pack Type ) ) } 
func ( v * Notebook ) Get Action Widget ( pack Type Pack Type ) ( * Widget , error ) { c : = C . gtk _notebook _get _action _widget ( v . native ( ) , C . Gtk Pack Type ( pack Type ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Offscreen Window ) native ( ) * C . Gtk Offscreen Window { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Offscreen Window ( p ) } 
func Offscreen Window New ( ) ( * Offscreen Window , error ) { c : = C . gtk _offscreen _window _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Offscreen Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Offscreen Window ) Get Surface ( ) ( * cairo . Surface , error ) { c : = C . gtk _offscreen _window _get _surface ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } cairo Ptr : = ( uintptr ) ( unsafe . Pointer ( c ) ) s : = cairo . New Surface ( cairo Ptr , true ) return s , nil } 
func ( v * Offscreen Window ) Get Pixbuf ( ) ( * gdk . Pixbuf , error ) { c : = C . gtk _offscreen _window _get _pixbuf ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return pb , nil } 
func ( v * Orientable ) native ( ) * C . Gtk Orientable { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Orientable ( p ) } 
func ( v * Orientable ) Get Orientation ( ) Orientation { c : = C . gtk _orientable _get _orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * Orientable ) Set Orientation ( orientation Orientation ) { C . gtk _orientable _set _orientation ( v . native ( ) , C . Gtk Orientation ( orientation ) ) } 
func ( v * Overlay ) native ( ) * C . Gtk Overlay { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Overlay ( p ) } 
func Overlay New ( ) ( * Overlay , error ) { c : = C . gtk _overlay _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Overlay ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Overlay ) Add Overlay ( widget IWidget ) { C . gtk _overlay _add _overlay ( v . native ( ) , widget . to Widget ( ) ) } 
func ( v * Paned ) native ( ) * C . Gtk Paned { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Paned ( p ) } 
func Paned New ( orientation Orientation ) ( * Paned , error ) { c : = C . gtk _paned _new ( C . Gtk Orientation ( orientation ) ) if c = = nil { return nil , nil Ptr Err } return wrap Paned ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) Add 1 ( child IWidget ) { C . gtk _paned _add 1 ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Paned ) Add 2 ( child IWidget ) { C . gtk _paned _add 2 ( v . native ( ) , child . to Widget ( ) ) } 
func ( v * Paned ) Pack 1 ( child IWidget , resize , shrink bool ) { C . gtk _paned _pack 1 ( v . native ( ) , child . to Widget ( ) , gbool ( resize ) , gbool ( shrink ) ) } 
func ( v * Paned ) Pack 2 ( child IWidget , resize , shrink bool ) { C . gtk _paned _pack 2 ( v . native ( ) , child . to Widget ( ) , gbool ( resize ) , gbool ( shrink ) ) } 
func ( v * Paned ) Set Position ( position int ) { C . gtk _paned _set _position ( v . native ( ) , C . gint ( position ) ) } 
func ( v * Paned ) Get Child 1 ( ) ( * Widget , error ) { c : = C . gtk _paned _get _child 1 ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) Get Child 2 ( ) ( * Widget , error ) { c : = C . gtk _paned _get _child 2 ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Paned ) Get Handle Window ( ) ( * Window , error ) { c : = C . gtk _paned _get _handle _window ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Progress Bar ) native ( ) * C . Gtk Progress Bar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Progress Bar ( p ) } 
func Progress Bar New ( ) ( * Progress Bar , error ) { c : = C . gtk _progress _bar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Progress Bar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Progress Bar ) Set Fraction ( fraction float 6 4 ) { C . gtk _progress _bar _set _fraction ( v . native ( ) , C . gdouble ( fraction ) ) } 
func ( v * Progress Bar ) Get Fraction ( ) float 6 4 { c : = C . gtk _progress _bar _get _fraction ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Progress Bar ) Set Show Text ( show Text bool ) { C . gtk _progress _bar _set _show _text ( v . native ( ) , gbool ( show Text ) ) } 
func ( v * Progress Bar ) Get Show Text ( ) bool { c : = C . gtk _progress _bar _get _show _text ( v . native ( ) ) return gobool ( c ) } 
func ( v * Progress Bar ) Set Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _progress _bar _set _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Progress Bar ) Get Pulse Step ( ) float 6 4 { c : = C . gtk _progress _bar _get _pulse _step ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Progress Bar ) Set Inverted ( inverted bool ) { C . gtk _progress _bar _set _inverted ( v . native ( ) , gbool ( inverted ) ) } 
func ( v * Progress Bar ) Get Inverted ( ) bool { c : = C . gtk _progress _bar _get _inverted ( v . native ( ) ) return gobool ( c ) } 
func ( v * Radio Button ) native ( ) * C . Gtk Radio Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Radio Button ( p ) } 
func Radio Button New ( group * glib . SList ) ( * Radio Button , error ) { c : = C . gtk _radio _button _new ( c GSList ( group ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Button New From Widget ( radio Group Member * Radio Button ) ( * Radio Button , error ) { c : = C . gtk _radio _button _new _from _widget ( radio Group Member . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Button New With Label ( group * glib . SList , label string ) ( * Radio Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _radio _button _new _with _label ( c GSList ( group ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Button New With Label From Widget ( radio Group Member * Radio Button , label string ) ( * Radio Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) var cradio * C . Gtk Radio Button if radio Group Member ! = nil { cradio = radio Group Member . native ( ) } c : = C . gtk _radio _button _new _with _label _from _widget ( cradio , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Radio Button ) Set Group ( group * glib . SList ) { C . gtk _radio _button _set _group ( v . native ( ) , c GSList ( group ) ) } 
func ( v * Radio Button ) Get Group ( ) ( * glib . SList , error ) { c : = C . gtk _radio _button _get _group ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return glib . Wrap SList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Radio Button ) Join Group ( group Source * Radio Button ) { var cgroup * C . Gtk Radio Button if group Source ! = nil { cgroup = group Source . native ( ) } C . gtk _radio _button _join _group ( v . native ( ) , cgroup ) } 
func ( v * Radio Menu Item ) native ( ) * C . Gtk Radio Menu Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Radio Menu Item ( p ) } 
func Radio Menu Item New ( group * glib . SList ) ( * Radio Menu Item , error ) { c : = C . gtk _radio _menu _item _new ( c GSList ( group ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Menu Item New With Label ( group * glib . SList , label string ) ( * Radio Menu Item , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _radio _menu _item _new _with _label ( c GSList ( group ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Menu Item New From Widget ( group * Radio Menu Item ) ( * Radio Menu Item , error ) { c : = C . gtk _radio _menu _item _new _from _widget ( group . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Radio Menu Item New With Label From Widget ( group * Radio Menu Item , label string ) ( * Radio Menu Item , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _radio _menu _item _new _with _label _from _widget ( group . native ( ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Radio Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Radio Menu Item ) Set Group ( group * glib . SList ) { C . gtk _radio _menu _item _set _group ( v . native ( ) , c GSList ( group ) ) } 
func ( v * Radio Menu Item ) Get Group ( ) ( * glib . SList , error ) { c : = C . gtk _radio _menu _item _get _group ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return glib . Wrap SList ( uintptr ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Range ) native ( ) * C . Gtk Range { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Range ( p ) } 
func ( v * Range ) Get Value ( ) float 6 4 { c : = C . gtk _range _get _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Range ) Set Value ( value float 6 4 ) { C . gtk _range _set _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Range ) Set Increments ( step , page float 6 4 ) { C . gtk _range _set _increments ( v . native ( ) , C . gdouble ( step ) , C . gdouble ( page ) ) } 
func ( v * Range ) Set Range ( min , max float 6 4 ) { C . gtk _range _set _range ( v . native ( ) , C . gdouble ( min ) , C . gdouble ( max ) ) } 
func ( v * Recent Chooser ) native ( ) * C . Gtk Recent Chooser { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Recent Chooser ( p ) } 
func ( v * Recent Chooser Menu ) native ( ) * C . Gtk Recent Chooser Menu { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Recent Chooser Menu ( p ) } 
func ( v * Recent Filter ) native ( ) * C . Gtk Recent Filter { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Recent Filter ( p ) } 
func Recent Filter New ( ) ( * Recent Filter , error ) { c : = C . gtk _recent _filter _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Recent Filter ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Recent Manager ) native ( ) * C . Gtk Recent Manager { if v = = nil | | v . Object = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Recent Manager ( p ) } 
func Recent Manager Get Default ( ) ( * Recent Manager , error ) { c : = C . gtk _recent _manager _get _default ( ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) v : = wrap Recent Manager ( obj ) return v , nil } 
func ( v * Recent Manager ) Add Item ( file URI string ) bool { cstr : = C . CString ( file URI ) defer C . free ( unsafe . Pointer ( cstr ) ) cok : = C . gtk _recent _manager _add _item ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return gobool ( cok ) } 
func ( v * Scale ) native ( ) * C . Gtk Scale { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Scale ( p ) } 
func Scale New ( orientation Orientation , adjustment * Adjustment ) ( * Scale , error ) { c : = C . gtk _scale _new ( C . Gtk Orientation ( orientation ) , adjustment . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Scale ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Scale New With Range ( orientation Orientation , min , max , step float 6 4 ) ( * Scale , error ) { c : = C . gtk _scale _new _with _range ( C . Gtk Orientation ( orientation ) , C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) ) if c = = nil { return nil , nil Ptr Err } return wrap Scale ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scale ) Set Draw Value ( draw Value bool ) { C . gtk _scale _set _draw _value ( v . native ( ) , gbool ( draw Value ) ) } 
func ( v * Scale Button ) native ( ) * C . Gtk Scale Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Scale Button ( p ) } 
func Scale Button New ( size Icon Size , min , max , step float 6 4 , icons [ ] string ) ( * Scale Button , error ) { cicons : = make ( [ ] * C . gchar , len ( icons ) ) for i , icon : = range icons { cicons [ i ] = ( * C . gchar ) ( C . CString ( icon ) ) defer C . free ( unsafe . Pointer ( cicons [ i ] ) ) } cicons = append ( cicons , nil ) c : = C . gtk _scale _button _new ( C . Gtk Icon Size ( size ) , C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) , & cicons [ 0 ] ) if c = = nil { return nil , nil Ptr Err } return wrap Scale Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scale Button ) Get Adjustment ( ) * Adjustment { c : = C . gtk _scale _button _get _adjustment ( v . native ( ) ) obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Adjustment { glib . Initially Unowned { obj } } } 
func ( v * Scale Button ) Get Popup ( ) ( * Widget , error ) { c : = C . gtk _scale _button _get _popup ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scale Button ) Set Adjustment ( adjustment * Adjustment ) { C . gtk _scale _button _set _adjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scale Button ) Set Value ( value float 6 4 ) { C . gtk _scale _button _set _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Scrollable ) native ( ) * C . Gtk Scrollable { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Scrollable ( p ) } 
func ( v * Scrollable ) Set HAdjustment ( adjustment * Adjustment ) { C . gtk _scrollable _set _hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrollable ) Get HAdjustment ( ) ( * Adjustment , error ) { c : = C . gtk _scrollable _get _hadjustment ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Adjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrollable ) Set VAdjustment ( adjustment * Adjustment ) { C . gtk _scrollable _set _vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrollable ) Get VAdjustment ( ) ( * Adjustment , error ) { c : = C . gtk _scrollable _get _vadjustment ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Adjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrollbar ) native ( ) * C . Gtk Scrollbar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Scrollbar ( p ) } 
func Scrollbar New ( orientation Orientation , adjustment * Adjustment ) ( * Scrollbar , error ) { c : = C . gtk _scrollbar _new ( C . Gtk Orientation ( orientation ) , adjustment . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Scrollbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrolled Window ) native ( ) * C . Gtk Scrolled Window { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Scrolled Window ( p ) } 
func Scrolled Window New ( hadjustment , vadjustment * Adjustment ) ( * Scrolled Window , error ) { c : = C . gtk _scrolled _window _new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Scrolled Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Scrolled Window ) Set Policy ( h Scrollbar Policy , v Scrollbar Policy Policy Type ) { C . gtk _scrolled _window _set _policy ( v . native ( ) , C . Gtk Policy Type ( h Scrollbar Policy ) , C . Gtk Policy Type ( v Scrollbar Policy ) ) } 
func ( v * Scrolled Window ) Get HAdjustment ( ) * Adjustment { c : = C . gtk _scrolled _window _get _hadjustment ( v . native ( ) ) if c = = nil { return nil } return wrap Adjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Scrolled Window ) Set HAdjustment ( adjustment * Adjustment ) { C . gtk _scrolled _window _set _hadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrolled Window ) Get VAdjustment ( ) * Adjustment { c : = C . gtk _scrolled _window _get _vadjustment ( v . native ( ) ) if c = = nil { return nil } return wrap Adjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Scrolled Window ) Set VAdjustment ( adjustment * Adjustment ) { C . gtk _scrolled _window _set _vadjustment ( v . native ( ) , adjustment . native ( ) ) } 
func ( v * Scrolled Window ) Get Shadow Type ( ) Shadow Type { c : = C . gtk _scrolled _window _get _shadow _type ( v . native ( ) ) return Shadow Type ( c ) } 
func ( v * Scrolled Window ) Set Shadow Type ( t Shadow Type ) { C . gtk _scrolled _window _set _shadow _type ( v . native ( ) , C . Gtk Shadow Type ( t ) ) } 
func ( v * Search Entry ) native ( ) * C . Gtk Search Entry { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Search Entry ( p ) } 
func Search Entry New ( ) ( * Search Entry , error ) { c : = C . gtk _search _entry _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Search Entry ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Selection Data ) native ( ) * C . Gtk Selection Data { if v = = nil { return nil } return v . Gtk Selection Data } 
func ( v * Selection Data ) Get Data ( ) ( data [ ] byte ) { var length C . gint c : = C . gtk _selection _data _get _data _with _length ( v . native ( ) , & length ) slice Header : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & data ) ) slice Header . Data = uintptr ( unsafe . Pointer ( c ) ) slice Header . Len = int ( length ) slice Header . Cap = int ( length ) return } 
func Get Data ( pointer uintptr ) ( data [ ] byte ) { c : = ( * C . GValue ) ( unsafe . Pointer ( pointer ) ) p : = ( * C . Gtk Selection Data ) ( unsafe . Pointer ( c ) ) C . gtk _selection _data _get _text ( p ) var byte Data [ ] byte var length C . gint cptr : = C . gtk _selection _data _get _data _with _length ( p , & length ) slice Header : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & byte Data ) ) slice Header . Data = uintptr ( unsafe . Pointer ( cptr ) ) slice Header . Len = int ( length ) slice Header . Cap = int ( length ) return byte Data } 
func Set Data ( pointer uintptr , atom gdk . Atom , data [ ] byte ) { c : = ( * C . GValue ) ( unsafe . Pointer ( pointer ) ) p : = ( * C . Gtk Selection Data ) ( unsafe . Pointer ( c ) ) C . gtk _selection _data _set ( p , C . Gdk Atom ( unsafe . Pointer ( atom ) ) , C . gint ( 8 ) , ( * C . guchar ) ( unsafe . Pointer ( & data [ 0 ] ) ) , C . gint ( len ( data ) ) ) } 
func Drag Set Icon Pixbuf ( context * gdk . Drag Context , pixbuf * gdk . Pixbuf , hot _x int , hot _y int ) { ctx : = unsafe . Pointer ( context . Native ( ) ) pix : = unsafe . Pointer ( pixbuf . Native ( ) ) C . gtk _drag _set _icon _pixbuf ( ( * C . Gdk Drag Context ) ( ctx ) , ( * C . Gdk Pixbuf ) ( pix ) , C . gint ( hot _x ) , C . gint ( hot _y ) ) } 
func ( v * Separator ) native ( ) * C . Gtk Separator { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Separator ( p ) } 
func Separator New ( orientation Orientation ) ( * Separator , error ) { c : = C . gtk _separator _new ( C . Gtk Orientation ( orientation ) ) if c = = nil { return nil , nil Ptr Err } return wrap Separator ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Separator Menu Item ) native ( ) * C . Gtk Separator Menu Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Separator Menu Item ( p ) } 
func Separator Menu Item New ( ) ( * Separator Menu Item , error ) { c : = C . gtk _separator _menu _item _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Separator Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Separator Tool Item ) native ( ) * C . Gtk Separator Tool Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Separator Tool Item ( p ) } 
func Separator Tool Item New ( ) ( * Separator Tool Item , error ) { c : = C . gtk _separator _tool _item _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Separator Tool Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Separator Tool Item ) Set Draw ( draw bool ) { C . gtk _separator _tool _item _set _draw ( v . native ( ) , gbool ( draw ) ) } 
func ( v * Separator Tool Item ) Get Draw ( ) bool { c : = C . gtk _separator _tool _item _get _draw ( v . native ( ) ) return gobool ( c ) } 
func ( v * Size Group ) native ( ) * C . Gtk Size Group { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Size Group ( p ) } 
func Size Group New ( mode Size Group Mode ) ( * Size Group , error ) { c : = C . gtk _size _group _new ( C . Gtk Size Group Mode ( mode ) ) if c = = nil { return nil , nil Ptr Err } return wrap Size Group ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Spin Button ) native ( ) * C . Gtk Spin Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Spin Button ( p ) } 
func ( v * Spin Button ) Configure ( adjustment * Adjustment , climb Rate float 6 4 , digits uint ) { C . gtk _spin _button _configure ( v . native ( ) , adjustment . native ( ) , C . gdouble ( climb Rate ) , C . guint ( digits ) ) } 
func Spin Button New ( adjustment * Adjustment , climb Rate float 6 4 , digits uint ) ( * Spin Button , error ) { c : = C . gtk _spin _button _new ( adjustment . native ( ) , C . gdouble ( climb Rate ) , C . guint ( digits ) ) if c = = nil { return nil , nil Ptr Err } return wrap Spin Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Spin Button New With Range ( min , max , step float 6 4 ) ( * Spin Button , error ) { c : = C . gtk _spin _button _new _with _range ( C . gdouble ( min ) , C . gdouble ( max ) , C . gdouble ( step ) ) if c = = nil { return nil , nil Ptr Err } return wrap Spin Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Spin Button ) Get Value As Int ( ) int { c : = C . gtk _spin _button _get _value _as _int ( v . native ( ) ) return int ( c ) } 
func ( v * Spin Button ) Set Value ( value float 6 4 ) { C . gtk _spin _button _set _value ( v . native ( ) , C . gdouble ( value ) ) } 
func ( v * Spin Button ) Get Value ( ) float 6 4 { c : = C . gtk _spin _button _get _value ( v . native ( ) ) return float 6 4 ( c ) } 
func ( v * Spin Button ) Get Adjustment ( ) * Adjustment { c : = C . gtk _spin _button _get _adjustment ( v . native ( ) ) if c = = nil { return nil } return wrap Adjustment ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Spin Button ) Set Range ( min , max float 6 4 ) { C . gtk _spin _button _set _range ( v . native ( ) , C . gdouble ( min ) , C . gdouble ( max ) ) } 
func ( v * Spinner ) native ( ) * C . Gtk Spinner { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Spinner ( p ) } 
func Spinner New ( ) ( * Spinner , error ) { c : = C . gtk _spinner _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Spinner ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Statusbar ) native ( ) * C . Gtk Statusbar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Statusbar ( p ) } 
func Statusbar New ( ) ( * Statusbar , error ) { c : = C . gtk _statusbar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Statusbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Statusbar ) Get Context Id ( context Description string ) uint { cstr : = C . CString ( context Description ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _statusbar _get _context _id ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return uint ( c ) } 
func ( v * Statusbar ) Push ( context ID uint , text string ) uint { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _statusbar _push ( v . native ( ) , C . guint ( context ID ) , ( * C . gchar ) ( cstr ) ) return uint ( c ) } 
func ( v * Statusbar ) Pop ( context ID uint ) { C . gtk _statusbar _pop ( v . native ( ) , C . guint ( context ID ) ) } 
func ( v * Statusbar ) Get Message Area ( ) ( * Box , error ) { c : = C . gtk _statusbar _get _message _area ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return & Box { Container { Widget { glib . Initially Unowned { obj } } } } , nil } 
func ( v * Switch ) native ( ) * C . Gtk Switch { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Switch ( p ) } 
func Switch New ( ) ( * Switch , error ) { c : = C . gtk _switch _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Switch ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Switch ) Get Active ( ) bool { c : = C . gtk _switch _get _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Switch ) Set Active ( is Active bool ) { C . gtk _switch _set _active ( v . native ( ) , gbool ( is Active ) ) } 
func Target Entry New ( target string , flags Target Flags , info uint ) ( * Target Entry , error ) { cstr : = C . CString ( target ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _target _entry _new ( ( * C . gchar ) ( cstr ) , C . guint ( flags ) , C . guint ( info ) ) if c = = nil { return nil , nil Ptr Err } t : = ( * Target Entry ) ( unsafe . Pointer ( c ) ) } 
func ( v * Text Tag ) native ( ) * C . Gtk Text Tag { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Text Tag ( p ) } 
func ( v * Text Tag ) Event ( event Object * glib . Object , event * gdk . Event , iter * Text Iter ) bool { ok : = C . gtk _text _tag _event ( v . native ( ) , ( * C . GObject ) ( unsafe . Pointer ( event Object . Native ( ) ) ) , ( * C . Gdk Event ) ( unsafe . Pointer ( event . Native ( ) ) ) , ( * C . Gtk Text Iter ) ( iter ) , ) return gobool ( ok ) } 
func ( v * Text Tag Table ) native ( ) * C . Gtk Text Tag Table { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Text Tag Table ( p ) } 
func ( v * Text Tag Table ) Add ( tag * Text Tag ) { C . gtk _text _tag _table _add ( v . native ( ) , tag . native ( ) ) / /return gobool (c ) / / TODO version -separate } 
func ( v * Text Tag Table ) Lookup ( name string ) ( * Text Tag , error ) { cname : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) c : = C . gtk _text _tag _table _lookup ( v . native ( ) , ( * C . gchar ) ( cname ) ) if c = = nil { return nil , nil Ptr Err } return wrap Text Tag ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Text Tag Table ) Remove ( tag * Text Tag ) { C . gtk _text _tag _table _remove ( v . native ( ) , tag . native ( ) ) } 
func ( v * Text Buffer ) native ( ) * C . Gtk Text Buffer { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Text Buffer ( p ) } 
func Text Buffer New ( table * Text Tag Table ) ( * Text Buffer , error ) { c : = C . gtk _text _buffer _new ( table . native ( ) ) if c = = nil { return nil , nil Ptr Err } e : = wrap Text Buffer ( glib . Take ( unsafe . Pointer ( c ) ) ) return e , nil } 
func ( v * Text Buffer ) Apply Tag ( tag * Text Tag , start , end * Text Iter ) { C . gtk _text _buffer _apply _tag ( v . native ( ) , tag . native ( ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Apply Tag By Name ( name string , start , end * Text Iter ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _text _buffer _apply _tag _by _name ( v . native ( ) , ( * C . gchar ) ( cstr ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Select Range ( start , end * Text Iter ) { C . gtk _text _buffer _select _range ( v . native ( ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Create Child Anchor ( iter * Text Iter ) * Text Child Anchor { ret : = C . gtk _text _buffer _create _child _anchor ( v . native ( ) , iter . native ( ) ) return ( * Text Child Anchor ) ( ret ) } 
func ( v * Text Buffer ) Delete ( start , end * Text Iter ) { C . gtk _text _buffer _delete ( v . native ( ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Get Iter At Offset ( char Offset int ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _buffer _get _iter _at _offset ( v . native ( ) , & iter , C . gint ( char Offset ) ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text Buffer ) Get Iter At Line ( line int ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _buffer _get _iter _at _line ( v . native ( ) , & iter , C . gint ( line ) ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text Buffer ) Get Start Iter ( ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _buffer _get _start _iter ( v . native ( ) , & iter ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text Buffer ) Get End Iter ( ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _buffer _get _end _iter ( v . native ( ) , & iter ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text Buffer ) Get Tag Table ( ) ( * Text Tag Table , error ) { c : = C . gtk _text _buffer _get _tag _table ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Text Tag Table ( obj ) , nil } 
func ( v * Text Buffer ) Insert ( iter * Text Iter , text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _text _buffer _insert ( v . native ( ) , ( * C . Gtk Text Iter ) ( iter ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * Text Buffer ) Insert Pixbuf ( iter * Text Iter , pixbuf * gdk . Pixbuf ) { C . gtk _text _buffer _insert _pixbuf ( v . native ( ) , ( * C . Gtk Text Iter ) ( iter ) , ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( pixbuf . Native ( ) ) ) ) } 
func ( v * Text Buffer ) Insert At Cursor ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _text _buffer _insert _at _cursor ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . gint ( len ( text ) ) ) } 
func ( v * Text Buffer ) Remove Tag ( tag * Text Tag , start , end * Text Iter ) { C . gtk _text _buffer _remove _tag ( v . native ( ) , tag . native ( ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Remove All Tags ( start , end * Text Iter ) { C . gtk _text _buffer _remove _all _tags ( v . native ( ) , ( * C . Gtk Text Iter ) ( start ) , ( * C . Gtk Text Iter ) ( end ) ) } 
func ( v * Text Buffer ) Get Iter At Mark ( mark * Text Mark ) * Text Iter { var iter C . Gtk Text Iter C . gtk _text _buffer _get _iter _at _mark ( v . native ( ) , & iter , ( * C . Gtk Text Mark ) ( mark ) ) return ( * Text Iter ) ( & iter ) } 
func ( v * Text Buffer ) Create Mark ( mark _name string , where * Text Iter , left _gravity bool ) * Text Mark { cstr : = C . CString ( mark _name ) defer C . free ( unsafe . Pointer ( cstr ) ) ret : = C . gtk _text _buffer _create _mark ( v . native ( ) , ( * C . gchar ) ( cstr ) , ( * C . Gtk Text Iter ) ( where ) , gbool ( left _gravity ) ) return ( * Text Mark ) ( ret ) } 
func ( v * Text Buffer ) Get Mark ( mark _name string ) * Text Mark { cstr : = C . CString ( mark _name ) defer C . free ( unsafe . Pointer ( cstr ) ) ret : = C . gtk _text _buffer _get _mark ( v . native ( ) , ( * C . gchar ) ( cstr ) ) return ( * Text Mark ) ( ret ) } 
func ( v * Toggle Button ) native ( ) * C . Gtk Toggle Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Toggle Button ( p ) } 
func Toggle Button New ( ) ( * Toggle Button , error ) { c : = C . gtk _toggle _button _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Toggle Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Toggle Button New With Label ( label string ) ( * Toggle Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _toggle _button _new _with _label ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Toggle Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Toggle Button ) Get Active ( ) bool { c : = C . gtk _toggle _button _get _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Toggle Button ) Set Active ( is Active bool ) { C . gtk _toggle _button _set _active ( v . native ( ) , gbool ( is Active ) ) } 
func ( v * Toggle Button ) Get Mode ( ) bool { c : = C . gtk _toggle _button _get _mode ( v . native ( ) ) return gobool ( c ) } 
func ( v * Toggle Button ) Set Mode ( draw Indicator bool ) { C . gtk _toggle _button _set _mode ( v . native ( ) , gbool ( draw Indicator ) ) } 
func ( v * Toolbar ) native ( ) * C . Gtk Toolbar { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Toolbar ( p ) } 
func Toolbar New ( ) ( * Toolbar , error ) { c : = C . gtk _toolbar _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Toolbar ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Toolbar ) Insert ( item ITool Item , pos int ) { C . gtk _toolbar _insert ( v . native ( ) , item . to Tool Item ( ) , C . gint ( pos ) ) } 
func ( v * Toolbar ) Get Item Index ( item ITool Item ) int { c : = C . gtk _toolbar _get _item _index ( v . native ( ) , item . to Tool Item ( ) ) return int ( c ) } 
func ( v * Toolbar ) Get NItems ( ) int { c : = C . gtk _toolbar _get _n _items ( v . native ( ) ) return int ( c ) } 
func ( v * Toolbar ) Get Nth Item ( n int ) * Tool Item { c : = C . gtk _toolbar _get _nth _item ( v . native ( ) , C . gint ( n ) ) if c = = nil { return nil } return wrap Tool Item ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Toolbar ) Get Drop Index ( x , y int ) int { c : = C . gtk _toolbar _get _drop _index ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) return int ( c ) } 
func ( v * Toolbar ) Set Drop Highlight Item ( tool Item ITool Item , index int ) { C . gtk _toolbar _set _drop _highlight _item ( v . native ( ) , tool Item . to Tool Item ( ) , C . gint ( index ) ) } 
func ( v * Toolbar ) Set Show Arrow ( show Arrow bool ) { C . gtk _toolbar _set _show _arrow ( v . native ( ) , gbool ( show Arrow ) ) } 
func ( v * Toolbar ) Get Show Arrow ( ) bool { c : = C . gtk _toolbar _get _show _arrow ( v . native ( ) ) return gobool ( c ) } 
func ( v * Toolbar ) Get Style ( ) Toolbar Style { c : = C . gtk _toolbar _get _style ( v . native ( ) ) return Toolbar Style ( c ) } 
func ( v * Toolbar ) Get Icon Size ( ) Icon Size { c : = C . gtk _toolbar _get _icon _size ( v . native ( ) ) return Icon Size ( c ) } 
func ( v * Toolbar ) Get Relief Style ( ) Relief Style { c : = C . gtk _toolbar _get _relief _style ( v . native ( ) ) return Relief Style ( c ) } 
func ( v * Toolbar ) Set Style ( style Toolbar Style ) { C . gtk _toolbar _set _style ( v . native ( ) , C . Gtk Toolbar Style ( style ) ) } 
func ( v * Toolbar ) Set Icon Size ( icon Size Icon Size ) { C . gtk _toolbar _set _icon _size ( v . native ( ) , C . Gtk Icon Size ( icon Size ) ) } 
func ( v * Tool Button ) native ( ) * C . Gtk Tool Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tool Button ( p ) } 
func Tool Button New ( icon Widget IWidget , label string ) ( * Tool Button , error ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) w : = nullable Widget ( icon Widget ) c : = C . gtk _tool _button _new ( w , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return wrap Tool Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Tool Button ) Set Label ( label string ) { cstr : = C . CString ( label ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tool _button _set _label ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Tool Button ) Get Label ( ) string { c : = C . gtk _tool _button _get _label ( v . native ( ) ) return go String ( c ) } 
func ( v * Tool Button ) Set Get Underline ( use Underline bool ) { C . gtk _tool _button _set _use _underline ( v . native ( ) , gbool ( use Underline ) ) } 
func ( v * Tool Button ) Getuse Underline ( ) bool { c : = C . gtk _tool _button _get _use _underline ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Button ) Set Icon Name ( icon Name string ) { cstr : = C . CString ( icon Name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tool _button _set _icon _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Tool Button ) Get Icon Name ( ) string { c : = C . gtk _tool _button _get _icon _name ( v . native ( ) ) return go String ( c ) } 
func ( v * Tool Button ) Set Icon Widget ( icon Widget IWidget ) { C . gtk _tool _button _set _icon _widget ( v . native ( ) , icon Widget . to Widget ( ) ) } 
func ( v * Tool Button ) Get Icon Widget ( ) * Widget { c : = C . gtk _tool _button _get _icon _widget ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Tool Button ) Set Label Widget ( label Widget IWidget ) { C . gtk _tool _button _set _label _widget ( v . native ( ) , label Widget . to Widget ( ) ) } 
func ( v * Tool Button ) Get Label Widget ( ) * Widget { c : = C . gtk _tool _button _get _label _widget ( v . native ( ) ) if c = = nil { return nil } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Toggle Tool Button ) native ( ) * C . Gtk Toggle Tool Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Toggle Tool Button ( p ) } 
func Toggle Tool Button New ( ) ( * Toggle Tool Button , error ) { c : = C . gtk _toggle _tool _button _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Toggle Tool Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Toggle Tool Button ) Get Active ( ) bool { c : = C . gtk _toggle _tool _button _get _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Toggle Tool Button ) Set Active ( is Active bool ) { C . gtk _toggle _tool _button _set _active ( v . native ( ) , gbool ( is Active ) ) } 
func ( v * Tool Item ) native ( ) * C . Gtk Tool Item { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tool Item ( p ) } 
func Tool Item New ( ) ( * Tool Item , error ) { c : = C . gtk _tool _item _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Tool Item ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Tool Item ) Set Homogeneous ( homogeneous bool ) { C . gtk _tool _item _set _homogeneous ( v . native ( ) , gbool ( homogeneous ) ) } 
func ( v * Tool Item ) Get Homogeneous ( ) bool { c : = C . gtk _tool _item _get _homogeneous ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Get Expand ( ) bool { c : = C . gtk _tool _item _get _expand ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Set Tooltip Text ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tool _item _set _tooltip _text ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Tool Item ) Set Tooltip Markup ( text string ) { cstr : = C . CString ( text ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tool _item _set _tooltip _markup ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Tool Item ) Set Use Drag Window ( use Drag Window bool ) { C . gtk _tool _item _set _use _drag _window ( v . native ( ) , gbool ( use Drag Window ) ) } 
func ( v * Tool Item ) Get Use Drag Window ( ) bool { c : = C . gtk _tool _item _get _use _drag _window ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Set Visible Horizontal ( visible Horizontal bool ) { C . gtk _tool _item _set _visible _horizontal ( v . native ( ) , gbool ( visible Horizontal ) ) } 
func ( v * Tool Item ) Get Visible Horizontal ( ) bool { c : = C . gtk _tool _item _get _visible _horizontal ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Set Visible Vertical ( visible Vertical bool ) { C . gtk _tool _item _set _visible _vertical ( v . native ( ) , gbool ( visible Vertical ) ) } 
func ( v * Tool Item ) Get Visible Vertical ( ) bool { c : = C . gtk _tool _item _get _visible _vertical ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Set Is Important ( is Important bool ) { C . gtk _tool _item _set _is _important ( v . native ( ) , gbool ( is Important ) ) } 
func ( v * Tool Item ) Get Is Important ( ) bool { c : = C . gtk _tool _item _get _is _important ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tool Item ) Get Icon Size ( ) Icon Size { c : = C . gtk _tool _item _get _icon _size ( v . native ( ) ) return Icon Size ( c ) } 
func ( v * Tool Item ) Get Orientation ( ) Orientation { c : = C . gtk _tool _item _get _orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * Tool Item ) gtk _tool _item _get _toolbar _style ( ) Toolbar Style { c : = C . gtk _tool _item _get _toolbar _style ( v . native ( ) ) return Toolbar Style ( c ) } 
func ( v * Tool Item ) Get Relief Style ( ) Relief Style { c : = C . gtk _tool _item _get _relief _style ( v . native ( ) ) return Relief Style ( c ) } 
func ( v * Tool Item ) Get Text Alignment ( ) float 3 2 { c : = C . gtk _tool _item _get _text _alignment ( v . native ( ) ) return float 3 2 ( c ) } 
func ( v * Tool Item ) Get Text Orientation ( ) Orientation { c : = C . gtk _tool _item _get _text _orientation ( v . native ( ) ) return Orientation ( c ) } 
func ( v * Tool Item ) Retrieve Proxy Menu Item ( ) * Menu Item { c : = C . gtk _tool _item _retrieve _proxy _menu _item ( v . native ( ) ) if c = = nil { return nil } return wrap Menu Item ( glib . Take ( unsafe . Pointer ( c ) ) ) } 
func ( v * Tool Item ) Set Proxy Menu Item ( menu Item Id string , menu Item IMenu Item ) { cstr : = C . CString ( menu Item Id ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _tool _item _set _proxy _menu _item ( v . native ( ) , ( * C . gchar ) ( cstr ) , C . to Gtk Widget ( unsafe . Pointer ( menu Item . to Menu Item ( ) ) ) ) } 
func ( v * Tree Iter ) native ( ) * C . Gtk Tree Iter { if v = = nil { return nil } return & v . Gtk Tree Iter } 
func ( v * Tree Iter ) Copy ( ) ( * Tree Iter , error ) { c : = C . gtk _tree _iter _copy ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } t : = & Tree Iter { * c } runtime . Set Finalizer ( t , ( * Tree Iter ) . free ) return t , nil } 
func ( v * Tree Model ) native ( ) * C . Gtk Tree Model { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tree Model ( p ) } 
func ( v * Tree Model ) Get Flags ( ) Tree Model Flags { c : = C . gtk _tree _model _get _flags ( v . native ( ) ) return Tree Model Flags ( c ) } 
func ( v * Tree Model ) Get NColumns ( ) int { c : = C . gtk _tree _model _get _n _columns ( v . native ( ) ) return int ( c ) } 
func ( v * Tree Model ) Get Column Type ( index int ) glib . Type { c : = C . gtk _tree _model _get _column _type ( v . native ( ) , C . gint ( index ) ) return glib . Type ( c ) } 
func ( v * Tree Model ) Get Iter ( path * Tree Path ) ( * Tree Iter , error ) { var iter C . Gtk Tree Iter c : = C . gtk _tree _model _get _iter ( v . native ( ) , & iter , path . native ( ) ) if ! gobool ( c ) { return nil , errors . New ( " " ) } t : = & Tree Iter { iter } return t , nil } 
func ( v * Tree Model ) Get Iter From String ( path string ) ( * Tree Iter , error ) { var iter C . Gtk Tree Iter cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _tree _model _get _iter _from _string ( v . native ( ) , & iter , ( * C . gchar ) ( cstr ) ) if ! gobool ( c ) { return nil , errors . New ( " " ) } t : = & Tree Iter { iter } return t , nil } 
func ( v * Tree Model ) Get Iter First ( ) ( * Tree Iter , bool ) { var iter C . Gtk Tree Iter c : = C . gtk _tree _model _get _iter _first ( v . native ( ) , & iter ) if ! gobool ( c ) { return nil , false } t : = & Tree Iter { iter } return t , true } 
func ( v * Tree Model ) Get Path ( iter * Tree Iter ) ( * Tree Path , error ) { c : = C . gtk _tree _model _get _path ( v . native ( ) , iter . native ( ) ) if c = = nil { return nil , nil Ptr Err } p : = & Tree Path { c } runtime . Set Finalizer ( p , ( * Tree Path ) . free ) return p , nil } 
func ( v * Tree Model ) Get Value ( iter * Tree Iter , column int ) ( * glib . Value , error ) { val , err : = glib . Value Alloc ( ) if err ! = nil { return nil , err } C . gtk _tree _model _get _value ( ( * C . Gtk Tree Model ) ( unsafe . Pointer ( v . native ( ) ) ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( unsafe . Pointer ( val . Native ( ) ) ) ) return val , nil } 
func ( v * Tree Model ) Iter Has Child ( iter * Tree Iter ) bool { c : = C . gtk _tree _model _iter _has _child ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * Tree Model ) Iter Next ( iter * Tree Iter ) bool { c : = C . gtk _tree _model _iter _next ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * Tree Model ) Iter Previous ( iter * Tree Iter ) bool { c : = C . gtk _tree _model _iter _previous ( v . native ( ) , iter . native ( ) ) return gobool ( c ) } 
func ( v * Tree Model ) Iter Parent ( iter , child * Tree Iter ) bool { c : = C . gtk _tree _model _iter _parent ( v . native ( ) , iter . native ( ) , child . native ( ) ) return gobool ( c ) } 
func ( v * Tree Model ) Iter Nth Child ( iter * Tree Iter , parent * Tree Iter , n int ) bool { c : = C . gtk _tree _model _iter _nth _child ( v . native ( ) , iter . native ( ) , parent . native ( ) , C . gint ( n ) ) return gobool ( c ) } 
func ( v * Tree Model ) Iter Children ( iter , child * Tree Iter ) bool { var c Iter , c Child * C . Gtk Tree Iter if iter ! = nil { c Iter = iter . native ( ) } c Child = child . native ( ) c : = C . gtk _tree _model _iter _children ( v . native ( ) , c Child , c Iter ) return gobool ( c ) } 
func ( v * Tree Model ) Iter NChildren ( iter * Tree Iter ) int { var c Iter * C . Gtk Tree Iter if iter ! = nil { c Iter = iter . native ( ) } c : = C . gtk _tree _model _iter _n _children ( v . native ( ) , c Iter ) return int ( c ) } 
func ( v * Tree Model ) Filter New ( root * Tree Path ) ( * Tree Model Filter , error ) { c : = C . gtk _tree _model _filter _new ( v . native ( ) , root . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Tree Model Filter ( obj ) , nil } 
func ( v * Tree Model Filter ) Set Visible Column ( column int ) { C . gtk _tree _model _filter _set _visible _column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * Tree Model Filter ) Convert Iter To Child Iter ( filter Iter * Tree Iter ) * Tree Iter { var iter C . Gtk Tree Iter C . gtk _tree _model _filter _convert _iter _to _child _iter ( v . native ( ) , & iter , filter Iter . native ( ) ) t : = & Tree Iter { iter } return t } 
func ( v * Tree Model Filter ) Convert Path To Child Path ( filter Path * Tree Path ) * Tree Path { path : = C . gtk _tree _model _filter _convert _path _to _child _path ( v . native ( ) , filter Path . native ( ) ) if path = = nil { return nil } p : = & Tree Path { path } runtime . Set Finalizer ( p , ( * Tree Path ) . free ) return p } 
func ( v * Tree Model Filter ) Set Visible Func ( f Tree Model Filter Visible Func , user Data . . . interface { } ) error { if len ( user Data ) > 1 { return errors . New ( " " ) } t : = tree Model Filter Visible Func Data { fn : f } if len ( user Data ) > 0 { t . user Data = user Data [ 0 ] } tree Model Visible Filter Func Registry . Lock ( ) id : = tree Model Visible Filter Func Registry . next tree Model Visible Filter Func Registry . next + + tree Model Visible Filter Func Registry . m [ id ] = t tree Model Visible Filter Func Registry . Unlock ( ) C . _gtk _tree _model _filter _set _visible _func ( v . native ( ) , C . gpointer ( uintptr ( id ) ) ) return nil } 
func Tree Path From List ( list * glib . List ) * Tree Path { if list = = nil { return nil } return & Tree Path { ( * C . Gtk Tree Path ) ( list . Data ( ) . ( unsafe . Pointer ) ) } } 
func ( v * Tree Path ) native ( ) * C . Gtk Tree Path { if v = = nil { return nil } return v . Gtk Tree Path } 
func ( v * Tree Path ) Get Indices ( ) [ ] int { var depth C . gint var goindices [ ] int var ginthelp C . gint indices : = uintptr ( unsafe . Pointer ( C . gtk _tree _path _get _indices _with _depth ( v . native ( ) , & depth ) ) ) size : = unsafe . Sizeof ( ginthelp ) for i : = 0 ; i < int ( depth ) ; i + + { goind : = int ( * ( ( * C . gint ) ( unsafe . Pointer ( indices ) ) ) ) goindices = append ( goindices , goind ) indices + = size } return goindices } 
func ( v * Tree Path ) String ( ) string { c : = C . gtk _tree _path _to _string ( v . native ( ) ) return go String ( c ) } 
func Tree Path New From String ( path string ) ( * Tree Path , error ) { cstr : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _tree _path _new _from _string ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } t : = & Tree Path { c } runtime . Set Finalizer ( t , ( * Tree Path ) . free ) return t , nil } 
func ( v * Tree Selection ) native ( ) * C . Gtk Tree Selection { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tree Selection ( p ) } 
func ( v * Tree Selection ) Get Selected ( ) ( model ITree Model , iter * Tree Iter , ok bool ) { var cmodel * C . Gtk Tree Model var citer C . Gtk Tree Iter c : = C . gtk _tree _selection _get _selected ( v . native ( ) , & cmodel , & citer ) model = wrap Tree Model ( glib . Take ( unsafe . Pointer ( cmodel ) ) ) iter = & Tree Iter { citer } ok = gobool ( c ) return } 
func ( v * Tree Selection ) Select Path ( path * Tree Path ) { C . gtk _tree _selection _select _path ( v . native ( ) , path . native ( ) ) } 
func ( v * Tree Selection ) Unselect Path ( path * Tree Path ) { C . gtk _tree _selection _unselect _path ( v . native ( ) , path . native ( ) ) } 
func ( v * Tree Selection ) Get Selected Rows ( model ITree Model ) * glib . List { var pcmodel * * C . Gtk Tree Model if model ! = nil { cmodel : = model . to Tree Model ( ) pcmodel = & cmodel } clist : = C . gtk _tree _selection _get _selected _rows ( v . native ( ) , pcmodel ) if clist = = nil { return nil } glist : = glib . Wrap List ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return & Tree Path { ( * C . Gtk Tree Path ) ( ptr ) } } ) runtime . Set Finalizer ( glist , func ( glist * glib . List ) { glist . Free Full ( func ( item interface { } ) { path : = item . ( * Tree Path ) C . gtk _tree _path _free ( path . Gtk Tree Path ) } ) } ) return glist } 
func ( v * Tree Selection ) Select Iter ( iter * Tree Iter ) { C . gtk _tree _selection _select _iter ( v . native ( ) , iter . native ( ) ) } 
func ( v * Tree Selection ) Set Mode ( m Selection Mode ) { C . gtk _tree _selection _set _mode ( v . native ( ) , C . Gtk Selection Mode ( m ) ) } 
func Tree Row Reference New ( model * Tree Model , path * Tree Path ) ( * Tree Row Reference , error ) { c : = C . gtk _tree _row _reference _new ( model . native ( ) , path . native ( ) ) if c = = nil { return nil , nil Ptr Err } r : = & Tree Row Reference { c } runtime . Set Finalizer ( r , ( * Tree Row Reference ) . free ) return r , nil } 
func ( v * Tree Row Reference ) Get Path ( ) * Tree Path { c : = C . gtk _tree _row _reference _get _path ( v . native ( ) ) if c = = nil { return nil } t : = & Tree Path { c } runtime . Set Finalizer ( t , ( * Tree Path ) . free ) return t } 
func ( v * Tree Row Reference ) Get Model ( ) ITree Model { c : = C . gtk _tree _row _reference _get _model ( v . native ( ) ) if c = = nil { return nil } m : = wrap Tree Model ( glib . Take ( unsafe . Pointer ( c ) ) ) return m } 
func ( v * Tree Row Reference ) Valid ( ) bool { c : = C . gtk _tree _row _reference _valid ( v . native ( ) ) return gobool ( c ) } 
func ( v * Tree Store ) native ( ) * C . Gtk Tree Store { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Tree Store ( p ) } 
func Tree Store New ( types . . . glib . Type ) ( * Tree Store , error ) { gtypes : = C . alloc _types ( C . int ( len ( types ) ) ) for n , val : = range types { C . set _type ( gtypes , C . int ( n ) , C . GType ( val ) ) } defer C . g _free ( C . gpointer ( gtypes ) ) c : = C . gtk _tree _store _newv ( C . gint ( len ( types ) ) , gtypes ) if c = = nil { return nil , nil Ptr Err } ts : = wrap Tree Store ( glib . Take ( unsafe . Pointer ( c ) ) ) return ts , nil } 
func ( v * Tree Store ) Append ( parent * Tree Iter ) * Tree Iter { var ti C . Gtk Tree Iter var c Parent * C . Gtk Tree Iter if parent ! = nil { c Parent = parent . native ( ) } C . gtk _tree _store _append ( v . native ( ) , & ti , c Parent ) iter : = & Tree Iter { ti } return iter } 
func ( v * Tree Store ) Insert ( parent * Tree Iter , position int ) * Tree Iter { var ti C . Gtk Tree Iter var c Parent * C . Gtk Tree Iter if parent ! = nil { c Parent = parent . native ( ) } C . gtk _tree _store _insert ( v . native ( ) , & ti , c Parent , C . gint ( position ) ) iter : = & Tree Iter { ti } return iter } 
func ( v * Tree Store ) Set Value ( iter * Tree Iter , column int , value interface { } ) error { switch value . ( type ) { case * gdk . Pixbuf : pix : = value . ( * gdk . Pixbuf ) C . _gtk _tree _store _set ( v . native ( ) , iter . native ( ) , C . gint ( column ) , unsafe . Pointer ( pix . Native ( ) ) ) default : gv , err : = glib . GValue ( value ) if err ! = nil { return err } C . gtk _tree _store _set _value ( v . native ( ) , iter . native ( ) , C . gint ( column ) , ( * C . GValue ) ( C . gpointer ( gv . Native ( ) ) ) ) } return nil } 
func ( v * Tree Store ) Remove ( iter * Tree Iter ) bool { var ti * C . Gtk Tree Iter if iter ! = nil { ti = iter . native ( ) } return 0 ! = C . gtk _tree _store _remove ( v . native ( ) , ti ) } 
func ( v * Tree Store ) Set Sort Column Id ( column int , order Sort Type ) { sort : = C . to Gtk Tree Sortable ( unsafe . Pointer ( v . Native ( ) ) ) C . gtk _tree _sortable _set _sort _column _id ( sort , C . gint ( column ) , C . Gtk Sort Type ( order ) ) } 
func ( v * Viewport ) native ( ) * C . Gtk Viewport { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Viewport ( p ) } 
func Viewport New ( hadjustment , vadjustment * Adjustment ) ( * Viewport , error ) { c : = C . gtk _viewport _new ( hadjustment . native ( ) , vadjustment . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Viewport ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Volume Button ) native ( ) * C . Gtk Volume Button { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Volume Button ( p ) } 
func Volume Button New ( ) ( * Volume Button , error ) { c : = C . gtk _volume _button _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Volume Button ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func cast ( c * C . GObject ) ( glib . IObject , error ) { var ( class Name = go String ( C . object _get _class _name ( c ) ) obj = glib . Take ( unsafe . Pointer ( c ) ) ) fn , ok : = Wrap Map [ class Name ] if ! ok { return nil , errors . New ( " " + class Name + " " ) } rf : = reflect . Value Of ( fn ) if rf . Type ( ) . Kind ( ) ! = reflect . Func { return nil , errors . New ( " " ) } v : = reflect . Value Of ( obj ) rv : = rf . Call ( [ ] reflect . Value { v } ) if len ( rv ) ! = 1 { return nil , errors . New ( " " ) } if k : = rv [ 0 ] . Kind ( ) ; k ! = reflect . Ptr { return nil , fmt . Errorf ( " " , k ) } ret , ok : = rv [ 0 ] . Interface ( ) . ( glib . IObject ) if ! ok { return nil , errors . New ( " " ) } return ret , nil } 
func ( v * GLArea ) Set Use ES ( es bool ) { C . gtk _gl _area _set _use _es ( v . native ( ) , gbool ( es ) ) } 
func Settings Get Default ( ) ( * Settings , error ) { c : = C . gtk _settings _get _default ( ) if c = = nil { return nil , nil Ptr Err } return wrap Settings ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Text Mark ) native ( ) * C . Gtk Text Mark { if v = = nil { return nil } return ( * C . Gtk Text Mark ) ( v ) } 
func New Pattern From RGB ( red , green , blue float 6 4 ) ( * Pattern , error ) { c : = C . cairo _pattern _create _rgb ( C . double ( red ) , C . double ( green ) , C . double ( blue ) ) return new Pattern From Native ( c ) } 
func New Pattern From RGBA ( red , green , blue , alpha float 6 4 ) ( * Pattern , error ) { c : = C . cairo _pattern _create _rgba ( C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) return new Pattern From Native ( c ) } 
func New Pattern For Surface ( s * Surface ) ( * Pattern , error ) { c : = C . cairo _pattern _create _for _surface ( s . native ( ) ) return new Pattern From Native ( c ) } 
func New Pattern Linear ( x 0 , y 0 , x 1 , y 1 float 6 4 ) ( * Pattern , error ) { c : = C . cairo _pattern _create _linear ( C . double ( x 0 ) , C . double ( y 0 ) , C . double ( x 1 ) , C . double ( y 1 ) ) return new Pattern From Native ( c ) } 
func New Pattern Radial ( x 0 , y 0 , r 0 , x 1 , y 1 , r 1 float 6 4 ) ( * Pattern , error ) { c : = C . cairo _pattern _create _radial ( C . double ( x 0 ) , C . double ( y 0 ) , C . double ( r 0 ) , C . double ( x 1 ) , C . double ( y 1 ) , C . double ( r 1 ) ) return new Pattern From Native ( c ) } 
func ( v * Pattern ) native ( ) * C . cairo _pattern _t { if v = = nil { return nil } return v . pattern } 
func ( v * Pattern ) Status ( ) Status { c : = C . cairo _pattern _status ( v . native ( ) ) return Status ( c ) } 
func ( v * Pattern ) Add Color Stop RGB ( offset , red , green , blue float 6 4 ) error { C . cairo _pattern _add _color _stop _rgb ( v . native ( ) , C . double ( offset ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) ) return v . Status ( ) . To Error ( ) } 
func ( v * Pattern ) Add Color Stop RGBA ( offset , red , green , blue , alpha float 6 4 ) error { C . cairo _pattern _add _color _stop _rgba ( v . native ( ) , C . double ( offset ) , C . double ( red ) , C . double ( green ) , C . double ( blue ) , C . double ( alpha ) ) return v . Status ( ) . To Error ( ) } 
func ( v * Application ) Get Actions For Accel ( acc string ) [ ] string { cstr 1 : = ( * C . gchar ) ( C . CString ( acc ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) var acts [ ] string c : = C . gtk _application _get _actions _for _accel ( v . native ( ) , cstr 1 ) originalc : = c defer C . g _strfreev ( originalc ) for * c ! = nil { acts = append ( acts , C . Go String ( ( * C . char ) ( * c ) ) ) c = C . next _gcharptr ( c ) } return acts } 
func ( v * Application ) Get Menu By ID ( id string ) * glib . Menu { cstr 1 : = ( * C . gchar ) ( C . CString ( id ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . gtk _application _get _menu _by _id ( v . native ( ) , cstr 1 ) if c = = nil { return nil } return & glib . Menu { glib . Menu Model { glib . Take ( unsafe . Pointer ( c ) ) } } } 
func ( v * Window ) native ( ) * C . Gtk Window { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Window ( p ) } 
func Window New ( t Window Type ) ( * Window , error ) { c : = C . gtk _window _new ( C . Gtk Window Type ( t ) ) if c = = nil { return nil , nil Ptr Err } return wrap Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) Set Title ( title string ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _window _set _title ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Window ) Get Resizable ( ) bool { c : = C . gtk _window _get _resizable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Activate Focus ( ) bool { c : = C . gtk _window _activate _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Activate Default ( ) bool { c : = C . gtk _window _activate _default ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Set Modal ( modal bool ) { C . gtk _window _set _modal ( v . native ( ) , gbool ( modal ) ) } 
func ( v * Window ) Set Default Size ( width , height int ) { C . gtk _window _set _default _size ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func ( v * Window ) Set Icon ( icon * gdk . Pixbuf ) { icon Ptr : = ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( icon . Native ( ) ) ) C . gtk _window _set _icon ( v . native ( ) , icon Ptr ) } 
func Window Set Default Icon ( icon * gdk . Pixbuf ) { icon Ptr : = ( * C . Gdk Pixbuf ) ( unsafe . Pointer ( icon . Native ( ) ) ) C . gtk _window _set _default _icon ( icon Ptr ) } 
func ( v * Window ) Set Gravity ( gravity gdk . Gdk Gravity ) { C . gtk _window _set _gravity ( v . native ( ) , C . Gdk Gravity ( gravity ) ) } 
func ( v * Window ) Set Transient For ( parent IWindow ) { var pw * C . Gtk Window = nil if parent ! = nil { pw = parent . to Window ( ) } C . gtk _window _set _transient _for ( v . native ( ) , pw ) } 
func ( v * Window ) Set Hide Titlebar When Maximized ( setting bool ) { C . gtk _window _set _hide _titlebar _when _maximized ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Is Active ( ) bool { c : = C . gtk _window _is _active ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Has Toplevel Focus ( ) bool { c : = C . gtk _window _has _toplevel _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Focus ( ) ( * Widget , error ) { c : = C . gtk _window _get _focus ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) Set Focus ( w * Widget ) { C . gtk _window _set _focus ( v . native ( ) , w . native ( ) ) } 
func ( v * Window ) Get Default Widget ( ) * Widget { c : = C . gtk _window _get _default _widget ( v . native ( ) ) if c = = nil { return nil } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Widget ( obj ) } 
func ( v * Window ) Set Default ( widget IWidget ) { C . gtk _window _set _default ( v . native ( ) , widget . to Widget ( ) ) } 
func ( v * Window ) Present With Time ( ts uint 3 2 ) { C . gtk _window _present _with _time ( v . native ( ) , C . guint 3 2 ( ts ) ) } 
func ( v * Window ) Set Keep Above ( setting bool ) { C . gtk _window _set _keep _above ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Keep Below ( setting bool ) { C . gtk _window _set _keep _below ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Decorated ( setting bool ) { C . gtk _window _set _decorated ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Deletable ( setting bool ) { C . gtk _window _set _deletable ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Type Hint ( type Hint gdk . Window Type Hint ) { C . gtk _window _set _type _hint ( v . native ( ) , C . Gdk Window Type Hint ( type Hint ) ) } 
func ( v * Window ) Set Skip Pager Hint ( setting bool ) { C . gtk _window _set _skip _pager _hint ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Urgency Hint ( setting bool ) { C . gtk _window _set _urgency _hint ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Focus On Map ( setting bool ) { C . gtk _window _set _focus _on _map ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Set Startup ID ( sid string ) { cstr : = ( * C . gchar ) ( C . CString ( sid ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _window _set _startup _id ( v . native ( ) , cstr ) } 
func ( v * Window ) Set Role ( s string ) { cstr : = ( * C . gchar ) ( C . CString ( s ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _window _set _role ( v . native ( ) , cstr ) } 
func ( v * Window ) Get Decorated ( ) bool { c : = C . gtk _window _get _decorated ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Deletable ( ) bool { c : = C . gtk _window _get _deletable ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Default Size ( ) ( width , height int ) { var w , h C . gint C . gtk _window _get _default _size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func ( v * Window ) Get Destroy With Parent ( ) bool { c : = C . gtk _window _get _destroy _with _parent ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Hide Titlebar When Maximized ( ) bool { c : = C . gtk _window _get _hide _titlebar _when _maximized ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Icon ( ) ( * gdk . Pixbuf , error ) { c : = C . gtk _window _get _icon ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } p : = & gdk . Pixbuf { glib . Take ( unsafe . Pointer ( c ) ) } return p , nil } 
func ( v * Window ) Get Icon Name ( ) ( string , error ) { return string Return ( C . gtk _window _get _icon _name ( v . native ( ) ) ) } 
func ( v * Window ) Get Modal ( ) bool { c : = C . gtk _window _get _modal ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Position ( ) ( root _x , root _y int ) { var x , y C . gint C . gtk _window _get _position ( v . native ( ) , & x , & y ) return int ( x ) , int ( y ) } 
func ( v * Window ) Get Role ( ) ( string , error ) { return string Return ( C . gtk _window _get _role ( v . native ( ) ) ) } 
func ( v * Window ) Get Size ( ) ( width , height int ) { var w , h C . gint C . gtk _window _get _size ( v . native ( ) , & w , & h ) return int ( w ) , int ( h ) } 
func ( v * Window ) Get Title ( ) ( string , error ) { return string Return ( C . gtk _window _get _title ( v . native ( ) ) ) } 
func ( v * Window ) Get Transient For ( ) ( * Window , error ) { c : = C . gtk _window _get _transient _for ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Window ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) Get Attached To ( ) ( * Widget , error ) { c : = C . gtk _window _get _attached _to ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Widget ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) Get Type Hint ( ) gdk . Window Type Hint { c : = C . gtk _window _get _type _hint ( v . native ( ) ) return gdk . Window Type Hint ( c ) } 
func ( v * Window ) Get Skip Taskbar Hint ( ) bool { c : = C . gtk _window _get _skip _taskbar _hint ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Urgency Hint ( ) bool { c : = C . gtk _window _get _urgency _hint ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Accept Focus ( ) bool { c : = C . gtk _window _get _accept _focus ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Get Focus On Map ( ) bool { c : = C . gtk _window _get _focus _on _map ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Has Group ( ) bool { c : = C . gtk _window _has _group ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Resize ( width , height int ) { C . gtk _window _resize ( v . native ( ) , C . gint ( width ) , C . gint ( height ) ) } 
func Window Set Default Icon From File ( file string ) error { cstr : = C . CString ( file ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res : = C . gtk _window _set _default _icon _from _file ( ( * C . gchar ) ( cstr ) , & err ) if res = = 0 { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func Window Set Default Icon Name ( s string ) { cstr : = ( * C . gchar ) ( C . CString ( s ) ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _window _set _default _icon _name ( cstr ) } 
func ( v * Window ) Set Icon From File ( file string ) error { cstr : = C . CString ( file ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil res : = C . gtk _window _set _icon _from _file ( v . native ( ) , ( * C . gchar ) ( cstr ) , & err ) if res = = 0 { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * Window ) Set Icon Name ( name string ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gtk _window _set _icon _name ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func ( v * Window ) Get Mnemonics Visible ( ) bool { c : = C . gtk _window _get _mnemonics _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Set Mnemonics Visible ( setting bool ) { C . gtk _window _set _mnemonics _visible ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Get Focus Visible ( ) bool { c : = C . gtk _window _get _focus _visible ( v . native ( ) ) return gobool ( c ) } 
func ( v * Window ) Set Focus Visible ( setting bool ) { C . gtk _window _set _focus _visible ( v . native ( ) , gbool ( setting ) ) } 
func ( v * Window ) Get Application ( ) ( * Application , error ) { c : = C . gtk _window _get _application ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Application ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Window ) Set Application ( a * Application ) { C . gtk _window _set _application ( v . native ( ) , a . native ( ) ) } 
func ( v * Window ) Activate Key ( event * gdk . Event Key ) bool { c : = C . gtk _window _activate _key ( v . native ( ) , ( * C . Gdk Event Key ) ( unsafe . Pointer ( event . Native ( ) ) ) ) return gobool ( c ) } 
func ( v * Window ) Add Mnemonic ( keyval uint , target * Widget ) { C . gtk _window _add _mnemonic ( v . native ( ) , C . guint ( keyval ) , target . native ( ) ) } 
func ( v * Window ) Remove Mnemonic ( keyval uint , target * Widget ) { C . gtk _window _remove _mnemonic ( v . native ( ) , C . guint ( keyval ) , target . native ( ) ) } 
func ( v * Window ) Activate Mnemonic ( keyval uint , mods gdk . Modifier Type ) bool { c : = C . gtk _window _mnemonic _activate ( v . native ( ) , C . guint ( keyval ) , C . Gdk Modifier Type ( mods ) ) return gobool ( c ) } 
func ( v * Window ) Get Mnemonic Modifier ( ) gdk . Modifier Type { c : = C . gtk _window _get _mnemonic _modifier ( v . native ( ) ) return gdk . Modifier Type ( c ) } 
func ( v * Window ) Set Mnemonic Modifier ( mods gdk . Modifier Type ) { C . gtk _window _set _mnemonic _modifier ( v . native ( ) , C . Gdk Modifier Type ( mods ) ) } 
func ( v Atom ) native ( ) C . Gdk Atom { return C . to Gdk Atom ( unsafe . Pointer ( uintptr ( v ) ) ) } 
func Gdk Atom Intern ( atom Name string , only If Exists bool ) Atom { cstr : = C . CString ( atom Name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gdk _atom _intern ( ( * C . gchar ) ( cstr ) , gbool ( only If Exists ) ) return Atom ( uintptr ( unsafe . Pointer ( c ) ) ) } 
func ( v * Device ) native ( ) * C . Gdk Device { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Device ( p ) } 
func Cursor New From Name ( display * Display , name string ) ( * Cursor , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gdk _cursor _new _from _name ( display . native ( ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return & Cursor { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Cursor ) native ( ) * C . Gdk Cursor { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Cursor ( p ) } 
func ( v * Device Manager ) native ( ) * C . Gdk Device Manager { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Device Manager ( p ) } 
func ( v * Device Manager ) Get Display ( ) ( * Display , error ) { c : = C . gdk _device _manager _get _display ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) native ( ) * C . Gdk Display { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Display ( p ) } 
func Display Open ( display Name string ) ( * Display , error ) { cstr : = C . CString ( display Name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gdk _display _open ( ( * C . gchar ) ( cstr ) ) if c = = nil { return nil , nil Ptr Err } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func Display Get Default ( ) ( * Display , error ) { c : = C . gdk _display _get _default ( ) if c = = nil { return nil , nil Ptr Err } return & Display { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) Get Name ( ) ( string , error ) { c : = C . gdk _display _get _name ( v . native ( ) ) if c = = nil { return " " , nil Ptr Err } return C . Go String ( ( * C . char ) ( c ) ) , nil } 
func ( v * Display ) Get Default Screen ( ) ( * Screen , error ) { c : = C . gdk _display _get _default _screen ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Screen { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) Device Is Grabbed ( device * Device ) bool { c : = C . gdk _display _device _is _grabbed ( v . native ( ) , device . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Is Closed ( ) bool { c : = C . gdk _display _is _closed ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Get Event ( ) ( * Event , error ) { c : = C . gdk _display _get _event ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } runtime . Set Finalizer ( e , ( * Event ) . free ) return e , nil } 
func ( v * Display ) Peek Event ( ) ( * Event , error ) { c : = C . gdk _display _peek _event ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } runtime . Set Finalizer ( e , ( * Event ) . free ) return e , nil } 
func ( v * Display ) Put Event ( event * Event ) { C . gdk _display _put _event ( v . native ( ) , event . native ( ) ) } 
func ( v * Display ) Has Pending ( ) bool { c : = C . gdk _display _has _pending ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Set Double Click Time ( msec uint ) { C . gdk _display _set _double _click _time ( v . native ( ) , C . guint ( msec ) ) } 
func ( v * Display ) Set Double Click Distance ( distance uint ) { C . gdk _display _set _double _click _distance ( v . native ( ) , C . guint ( distance ) ) } 
func ( v * Display ) Supports Color Cursor ( ) bool { c : = C . gdk _display _supports _cursor _color ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Supports Cursor Alpha ( ) bool { c : = C . gdk _display _supports _cursor _alpha ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Get Default Cursor Size ( ) uint { c : = C . gdk _display _get _default _cursor _size ( v . native ( ) ) return uint ( c ) } 
func ( v * Display ) Get Maximal Cursor Size ( ) ( width , height uint ) { var w , h C . guint C . gdk _display _get _maximal _cursor _size ( v . native ( ) , & w , & h ) return uint ( w ) , uint ( h ) } 
func ( v * Display ) Get Default Group ( ) ( * Window , error ) { c : = C . gdk _display _get _default _group ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } return & Window { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Display ) Supports Selection Notification ( ) bool { c : = C . gdk _display _supports _selection _notification ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Request Selection Notification ( selection Atom ) bool { c : = C . gdk _display _request _selection _notification ( v . native ( ) , selection . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Supports Clipboard Persistence ( ) bool { c : = C . gdk _display _supports _clipboard _persistence ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Store Clipboard ( clipboard Window * Window , time uint 3 2 , targets . . . Atom ) { panic ( " " ) } 
func ( v * Display ) Supports Shapes ( ) bool { c : = C . gdk _display _supports _shapes ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Supports Input Shapes ( ) bool { c : = C . gdk _display _supports _input _shapes ( v . native ( ) ) return gobool ( c ) } 
func ( v * Display ) Notify Startup Complete ( startup ID string ) { cstr : = C . CString ( startup ID ) defer C . free ( unsafe . Pointer ( cstr ) ) C . gdk _display _notify _startup _complete ( v . native ( ) , ( * C . gchar ) ( cstr ) ) } 
func Keyval From Name ( keyval Name string ) uint { str : = ( * C . gchar ) ( C . CString ( keyval Name ) ) defer C . free ( unsafe . Pointer ( str ) ) return uint ( C . gdk _keyval _from _name ( str ) ) } 
func ( v * Drag Context ) native ( ) * C . Gdk Drag Context { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Drag Context ( p ) } 
func ( v * Event ) native ( ) * C . Gdk Event { if v = = nil { return nil } return v . Gdk Event } 
func Event Button New From Event ( event * Event ) * Event Button { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Button { & ev } } 
func ( v * Event Button ) XRoot ( ) float 6 4 { c : = v . native ( ) . x _root return float 6 4 ( c ) } 
func ( v * Event Button ) YRoot ( ) float 6 4 { c : = v . native ( ) . y _root return float 6 4 ( c ) } 
func ( v * Event Button ) Time ( ) uint 3 2 { c : = v . native ( ) . time return uint 3 2 ( c ) } 
func Event Key New From Event ( event * Event ) * Event Key { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Key { & ev } } 
func Event Motion New From Event ( event * Event ) * Event Motion { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Motion { & ev } } 
func ( v * Event Motion ) Time ( ) uint 3 2 { c : = v . native ( ) . time return uint 3 2 ( c ) } 
func ( v * Event Motion ) State ( ) Modifier Type { c : = v . native ( ) . state return Modifier Type ( c ) } 
func Event Scroll New From Event ( event * Event ) * Event Scroll { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Scroll { & ev } } 
func Event Window State New From Event ( event * Event ) * Event Window State { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Window State { & ev } } 
func Event Configure New From Event ( event * Event ) * Event Configure { ee : = ( * C . Gdk Event ) ( unsafe . Pointer ( event . native ( ) ) ) ev : = Event { ee } return & Event Configure { & ev } } 
func ( v * Pixbuf ) Get Colorspace ( ) Colorspace { c : = C . gdk _pixbuf _get _colorspace ( v . native ( ) ) return Colorspace ( c ) } 
func ( v * Pixbuf ) Get NChannels ( ) int { c : = C . gdk _pixbuf _get _n _channels ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Has Alpha ( ) bool { c : = C . gdk _pixbuf _get _has _alpha ( v . native ( ) ) return gobool ( c ) } 
func ( v * Pixbuf ) Get Bits Per Sample ( ) int { c : = C . gdk _pixbuf _get _bits _per _sample ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Pixels ( ) ( channels [ ] byte ) { var length C . guint c : = C . gdk _pixbuf _get _pixels _with _length ( v . native ( ) , & length ) slice Header : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & channels ) ) slice Header . Data = uintptr ( unsafe . Pointer ( c ) ) slice Header . Len = int ( length ) slice Header . Cap = int ( length ) runtime . Set Finalizer ( & channels , func ( _ * [ ] byte ) { v . Unref ( ) } ) return } 
func ( v * Pixbuf ) Get Width ( ) int { c : = C . gdk _pixbuf _get _width ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Height ( ) int { c : = C . gdk _pixbuf _get _height ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Rowstride ( ) int { c : = C . gdk _pixbuf _get _rowstride ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Byte Length ( ) int { c : = C . gdk _pixbuf _get _byte _length ( v . native ( ) ) return int ( c ) } 
func ( v * Pixbuf ) Get Option ( key string ) ( value string , ok bool ) { cstr : = C . CString ( key ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gdk _pixbuf _get _option ( v . native ( ) , ( * C . gchar ) ( cstr ) ) if c = = nil { return " " , false } return C . Go String ( ( * C . char ) ( c ) ) , true } 
func Pixbuf New ( colorspace Colorspace , has Alpha bool , bits Per Sample , width , height int ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _new ( C . Gdk Colorspace ( colorspace ) , gbool ( has Alpha ) , C . int ( bits Per Sample ) , C . int ( width ) , C . int ( height ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func Pixbuf New From File ( filename string ) ( * Pixbuf , error ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError c : = C . gdk _pixbuf _new _from _file ( ( * C . char ) ( cstr ) , & err ) if c = = nil { defer C . g _error _free ( err ) return nil , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func Pixbuf New From File At Scale ( filename string , width , height int , preserve Aspect Ratio bool ) ( * Pixbuf , error ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var err * C . GError = nil c : = C . gdk _pixbuf _new _from _file _at _scale ( cstr , C . int ( width ) , C . int ( height ) , gbool ( preserve Aspect Ratio ) , & err ) if err ! = nil { defer C . g _error _free ( err ) return nil , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Scale Simple ( dest Width , dest Height int , interp Type Interp Type ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _scale _simple ( v . native ( ) , C . int ( dest Width ) , C . int ( dest Height ) , C . Gdk Interp Type ( interp Type ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Rotate Simple ( angle Pixbuf Rotation ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _rotate _simple ( v . native ( ) , C . Gdk Pixbuf Rotation ( angle ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Apply Embedded Orientation ( ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _apply _embedded _orientation ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Flip ( horizontal bool ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _flip ( v . native ( ) , gbool ( horizontal ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( v * Pixbuf ) Save JPEG ( path string , quality int ) error { cpath : = C . CString ( path ) cquality : = C . CString ( strconv . Itoa ( quality ) ) defer C . free ( unsafe . Pointer ( cpath ) ) defer C . free ( unsafe . Pointer ( cquality ) ) var err * C . GError c : = C . _gdk _pixbuf _save _jpeg ( v . native ( ) , cpath , & err , cquality ) if ! gobool ( c ) { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * Pixbuf ) Save PNG ( path string , compression int ) error { cpath : = C . CString ( path ) ccompression : = C . CString ( strconv . Itoa ( compression ) ) defer C . free ( unsafe . Pointer ( cpath ) ) defer C . free ( unsafe . Pointer ( ccompression ) ) var err * C . GError c : = C . _gdk _pixbuf _save _png ( v . native ( ) , cpath , & err , ccompression ) if ! gobool ( c ) { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func Pixbuf Get File Info ( filename string ) ( format interface { } , width , height int ) { cstr : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( cstr ) ) var cw , ch C . gint format = C . gdk _pixbuf _get _file _info ( ( * C . gchar ) ( cstr ) , & cw , & ch ) } 
func ( v * Pixbuf Loader ) native ( ) * C . Gdk Pixbuf Loader { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Pixbuf Loader ( p ) } 
func Pixbuf Loader New ( ) ( * Pixbuf Loader , error ) { c : = C . gdk _pixbuf _loader _new ( ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf Loader { obj } obj . Ref ( ) runtime . Set Finalizer ( p , func ( _ interface { } ) { obj . Unref ( ) } ) return p , nil } 
func Pixbuf Loader New With Type ( t string ) ( * Pixbuf Loader , error ) { var err * C . GError cstr : = C . CString ( t ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gdk _pixbuf _loader _new _with _type ( ( * C . char ) ( cstr ) , & err ) if err ! = nil { defer C . g _error _free ( err ) return nil , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } if c = = nil { return nil , nil Ptr Err } return & Pixbuf Loader { glib . Take ( unsafe . Pointer ( c ) ) } , nil } 
func ( v * Pixbuf Loader ) Write ( data [ ] byte ) ( int , error ) { } var err * C . GError c : = C . gdk _pixbuf _loader _write ( v . native ( ) , ( * C . guchar ) ( unsafe . Pointer ( & data [ 0 ] ) ) , C . gsize ( len ( data ) ) , & err ) if ! gobool ( c ) { defer C . g _error _free ( err ) return 0 , errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return len ( data ) , nil } 
func ( v * Pixbuf Loader ) Close ( ) error { var err * C . GError if ok : = gobool ( C . gdk _pixbuf _loader _close ( v . native ( ) , & err ) ) ; ! ok { defer C . g _error _free ( err ) return errors . New ( C . Go String ( ( * C . char ) ( err . message ) ) ) } return nil } 
func ( v * Pixbuf Loader ) Set Size ( width , height int ) { C . gdk _pixbuf _loader _set _size ( v . native ( ) , C . int ( width ) , C . int ( height ) ) } 
func ( v * Pixbuf Loader ) Get Pixbuf ( ) ( * Pixbuf , error ) { c : = C . gdk _pixbuf _loader _get _pixbuf ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = & glib . Object { glib . To GObject ( unsafe . Pointer ( c ) ) } p : = & Pixbuf { obj } return p , nil } 
func ( c * RGBA ) Set Colors ( r , g , b , a float 6 4 ) { c . rgba . red = C . gdouble ( r ) c . rgba . green = C . gdouble ( g ) c . rgba . blue = C . gdouble ( b ) c . rgba . alpha = C . gdouble ( a ) } 
func ( v * RGBA ) Parse ( spec string ) bool { cstr : = ( * C . gchar ) ( C . CString ( spec ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . gdk _rgba _parse ( v . rgba , cstr ) ) } 
func ( v * RGBA ) String ( ) string { return C . Go String ( ( * C . char ) ( C . gdk _rgba _to _string ( v . rgba ) ) ) } 
func ( v * Window ) Set Cursor ( cursor * Cursor ) { C . gdk _window _set _cursor ( v . native ( ) , cursor . native ( ) ) } 
func ( v * Window ) native ( ) * C . Gdk Window { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gdk Window ( p ) } 
func ( v * Icon View ) native ( ) * C . Gtk Icon View { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Icon View ( p ) } 
func Icon View New ( ) ( * Icon View , error ) { c : = C . gtk _icon _view _new ( ) if c = = nil { return nil , nil Ptr Err } return wrap Icon View ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func Icon View New With Model ( model ITree Model ) ( * Icon View , error ) { c : = C . gtk _icon _view _new _with _model ( model . to Tree Model ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Icon View ( obj ) , nil } 
func ( v * Icon View ) Set Model ( model ITree Model ) { var mptr * C . Gtk Tree Model if model ! = nil { mptr = model . to Tree Model ( ) } C . gtk _icon _view _set _model ( v . native ( ) , mptr ) } 
func ( v * Icon View ) Get Model ( ) ( * Tree Model , error ) { c : = C . gtk _icon _view _get _model ( v . native ( ) ) if c = = nil { return nil , nil Ptr Err } obj : = glib . Take ( unsafe . Pointer ( c ) ) return wrap Tree Model ( obj ) , nil } 
func ( v * Icon View ) Set Text Column ( column int ) { C . gtk _icon _view _set _text _column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * Icon View ) Set Markup Column ( column int ) { C . gtk _icon _view _set _markup _column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * Icon View ) Set Pixbuf Column ( column int ) { C . gtk _icon _view _set _pixbuf _column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * Icon View ) Get Path At Pos ( x , y int ) * Tree Path { var ( cpath * C . Gtk Tree Path path * Tree Path ) cpath = C . gtk _icon _view _get _path _at _pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) ) if cpath ! = nil { path = & Tree Path { cpath } runtime . Set Finalizer ( path , ( * Tree Path ) . free ) } return path } 
func ( v * Icon View ) Get Item At Pos ( x , y int ) ( * Tree Path , * Cell Renderer ) { var ( cpath * C . Gtk Tree Path ccell * C . Gtk Cell Renderer path * Tree Path cell * Cell Renderer ) C . gtk _icon _view _get _item _at _pos ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , & cpath , & ccell ) if cpath ! = nil { path = & Tree Path { cpath } runtime . Set Finalizer ( path , ( * Tree Path ) . free ) } if ccell ! = nil { cell = wrap Cell Renderer ( glib . Take ( unsafe . Pointer ( ccell ) ) ) } return path , cell } 
func ( v * Icon View ) Convert Widget To Bin Window Coords ( x , y int ) ( int , int ) { var bx , by C . gint C . gtk _icon _view _convert _widget _to _bin _window _coords ( v . native ( ) , C . gint ( x ) , C . gint ( y ) , & bx , & by ) return int ( bx ) , int ( by ) } 
func ( v * Icon View ) Set Cursor ( path * Tree Path , cell * Cell Renderer , start Editing bool ) { C . gtk _icon _view _set _cursor ( v . native ( ) , path . native ( ) , cell . native ( ) , gbool ( start Editing ) ) } 
func ( v * Icon View ) Get Cursor ( ) ( * Tree Path , * Cell Renderer ) { var ( cpath * C . Gtk Tree Path ccell * C . Gtk Cell Renderer path * Tree Path cell * Cell Renderer ) C . gtk _icon _view _get _cursor ( v . native ( ) , & cpath , & ccell ) if cpath ! = nil { path = & Tree Path { cpath } runtime . Set Finalizer ( path , ( * Tree Path ) . free ) } if ccell ! = nil { cell = wrap Cell Renderer ( glib . Take ( unsafe . Pointer ( ccell ) ) ) } return path , cell } 
func ( v * Icon View ) Set Selection Mode ( mode Selection Mode ) { C . gtk _icon _view _set _selection _mode ( v . native ( ) , C . Gtk Selection Mode ( mode ) ) } 
func ( v * Icon View ) Set Item Orientation ( orientation Orientation ) { C . gtk _icon _view _set _item _orientation ( v . native ( ) , C . Gtk Orientation ( orientation ) ) } 
func ( v * Icon View ) Set Columns ( columns int ) { C . gtk _icon _view _set _columns ( v . native ( ) , C . gint ( columns ) ) } 
func ( v * Icon View ) Set Item Width ( width int ) { C . gtk _icon _view _set _item _width ( v . native ( ) , C . gint ( width ) ) } 
func ( v * Icon View ) Set Spacing ( spacing int ) { C . gtk _icon _view _set _spacing ( v . native ( ) , C . gint ( spacing ) ) } 
func ( v * Icon View ) Set Row Spacing ( row Spacing int ) { C . gtk _icon _view _set _row _spacing ( v . native ( ) , C . gint ( row Spacing ) ) } 
func ( v * Icon View ) Set Column Spacing ( column Spacing int ) { C . gtk _icon _view _set _column _spacing ( v . native ( ) , C . gint ( column Spacing ) ) } 
func ( v * Icon View ) Set Margin ( margin int ) { C . gtk _icon _view _set _margin ( v . native ( ) , C . gint ( margin ) ) } 
func ( v * Icon View ) Set Item Padding ( item Padding int ) { C . gtk _icon _view _set _item _padding ( v . native ( ) , C . gint ( item Padding ) ) } 
func ( v * Icon View ) Set Activate On Single Click ( single bool ) { C . gtk _icon _view _set _activate _on _single _click ( v . native ( ) , gbool ( single ) ) } 
func ( v * Icon View ) Get Cell Rect ( path * Tree Path , cell * Cell Renderer ) * gdk . Rectangle { var crect C . Gdk Rectangle C . gtk _icon _view _get _cell _rect ( v . native ( ) , path . native ( ) , cell . native ( ) , & crect ) return gdk . Wrap Rectangle ( uintptr ( unsafe . Pointer ( & crect ) ) ) } 
func ( v * Icon View ) Select Path ( path * Tree Path ) { C . gtk _icon _view _select _path ( v . native ( ) , path . native ( ) ) } 
func ( v * Icon View ) Unselect Path ( path * Tree Path ) { C . gtk _icon _view _unselect _path ( v . native ( ) , path . native ( ) ) } 
func ( v * Icon View ) Path Is Selected ( path * Tree Path ) bool { return gobool ( C . gtk _icon _view _path _is _selected ( v . native ( ) , path . native ( ) ) ) } 
func ( v * Icon View ) Get Selected Items ( ) * glib . List { clist : = C . gtk _icon _view _get _selected _items ( v . native ( ) ) if clist = = nil { return nil } glist : = glib . Wrap List ( uintptr ( unsafe . Pointer ( clist ) ) ) glist . Data Wrapper ( func ( ptr unsafe . Pointer ) interface { } { return & Tree Path { ( * C . Gtk Tree Path ) ( ptr ) } } ) runtime . Set Finalizer ( glist , func ( glist * glib . List ) { glist . Free Full ( func ( item interface { } ) { path : = item . ( * Tree Path ) C . gtk _tree _path _free ( path . Gtk Tree Path ) } ) } ) return glist } 
func ( v * Icon View ) Item Activated ( path * Tree Path ) { C . gtk _icon _view _item _activated ( v . native ( ) , path . native ( ) ) } 
func ( v * Icon View ) Scroll To Path ( path * Tree Path , use Align bool , row Align , col Align float 6 4 ) { C . gtk _icon _view _scroll _to _path ( v . native ( ) , path . native ( ) , gbool ( use Align ) , C . gfloat ( row Align ) , C . gfloat ( col Align ) ) } 
func ( v * Icon View ) Get Visible Range ( ) ( * Tree Path , * Tree Path ) { var ( cpath Start , cpath End * C . Gtk Tree Path path Start , path End * Tree Path ) C . gtk _icon _view _get _visible _range ( v . native ( ) , & cpath Start , & cpath End ) if cpath Start ! = nil { path Start = & Tree Path { cpath Start } runtime . Set Finalizer ( path Start , ( * Tree Path ) . free ) } if cpath End ! = nil { path End = & Tree Path { cpath End } runtime . Set Finalizer ( path End , ( * Tree Path ) . free ) } return path Start , path End } 
func ( v * Icon View ) Set Tooltip Item ( tooltip * Tooltip , path * Tree Path ) { C . gtk _icon _view _set _tooltip _item ( v . native ( ) , tooltip . native ( ) , path . native ( ) ) } 
func ( v * Icon View ) Set Tooltip Cell ( tooltip * Tooltip , path * Tree Path , cell * Cell Renderer ) { C . gtk _icon _view _set _tooltip _cell ( v . native ( ) , tooltip . native ( ) , path . native ( ) , cell . native ( ) ) } 
func ( v * Icon View ) Get Tooltip Context ( x , y int , keyboard Tip bool ) ( * Tree Model , * Tree Path , * Tree Iter ) { var ( cmodel * C . Gtk Tree Model cpath * C . Gtk Tree Path citer * C . Gtk Tree Iter model * Tree Model path * Tree Path iter * Tree Iter ) px : = C . gint ( x ) py : = C . gint ( y ) if ! gobool ( C . gtk _icon _view _get _tooltip _context ( v . native ( ) , & px , & py , gbool ( keyboard Tip ) , & cmodel , & cpath , citer , ) ) { return nil , nil , nil } if cmodel ! = nil { model = wrap Tree Model ( glib . Take ( unsafe . Pointer ( cmodel ) ) ) } if cpath ! = nil { path = & Tree Path { cpath } runtime . Set Finalizer ( path , ( * Tree Path ) . free ) } if citer ! = nil { iter = & Tree Iter { * citer } runtime . Set Finalizer ( iter , ( * Tree Iter ) . free ) } return model , path , iter } 
func ( v * Icon View ) Set Tooltip Column ( column int ) { C . gtk _icon _view _set _tooltip _column ( v . native ( ) , C . gint ( column ) ) } 
func ( v * Icon View ) Get Item Row ( path * Tree Path ) int { return int ( C . gtk _icon _view _get _item _row ( v . native ( ) , path . native ( ) ) ) } 
func ( v * Icon View ) Set Reorderable ( reorderable bool ) { C . gtk _icon _view _set _reorderable ( v . native ( ) , gbool ( reorderable ) ) } 
func ( v * Window ) Move To Desktop ( d uint 3 2 ) { C . gdk _x 1 1 _window _move _to _desktop ( v . native ( ) , C . guint 3 2 ( d ) ) } 
func Paper Size New From IPP ( name string , width , height float 6 4 ) ( * Paper Size , error ) { cstr : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _paper _size _new _from _ipp ( ( * C . gchar ) ( cstr ) , C . gdouble ( width ) , C . gdouble ( height ) ) if c = = nil { return nil , nil Ptr Err } t : = & Paper Size { c } runtime . Set Finalizer ( t , ( * Paper Size ) . free ) return t , nil } 
func ( ps * Paper Size ) Is IPP ( ) bool { c : = C . gtk _paper _size _is _ipp ( ps . native ( ) ) return gobool ( c ) } 
func ( v * Notification ) native ( ) * C . GNotification { if v = = nil | | v . GObject = = nil { return nil } return C . to GNotification ( unsafe . Pointer ( v . GObject ) ) } 
func Notification New ( title string ) * Notification { cstr 1 : = ( * C . gchar ) ( C . CString ( title ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) c : = C . g _notification _new ( cstr 1 ) if c = = nil { return nil } return wrap Notification ( wrap Object ( unsafe . Pointer ( c ) ) ) } 
func ( v * Notification ) Set Title ( title string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( title ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _notification _set _title ( v . native ( ) , cstr 1 ) } 
func ( v * Notification ) Set Body ( body string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( body ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _notification _set _body ( v . native ( ) , cstr 1 ) } 
func ( v * Notification ) Set Default Action ( detailed Action string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( detailed Action ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) C . g _notification _set _default _action ( v . native ( ) , cstr 1 ) } 
func ( v * Notification ) Add Button ( label , detailed Action string ) { cstr 1 : = ( * C . gchar ) ( C . CString ( label ) ) defer C . free ( unsafe . Pointer ( cstr 1 ) ) cstr 2 : = ( * C . gchar ) ( C . CString ( detailed Action ) ) defer C . free ( unsafe . Pointer ( cstr 2 ) ) C . g _notification _add _button ( v . native ( ) , cstr 1 , cstr 2 ) } 
func Popover New ( relative IWidget ) ( * Popover , error ) { if relative = = nil { c = C . gtk _popover _new ( nil ) } else { c = C . gtk _popover _new ( relative . to Widget ( ) ) } if c = = nil { return nil , nil Ptr Err } return wrap Popover ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Settings Schema ) Get ID ( ) string { return C . Go String ( ( * C . char ) ( C . g _settings _schema _get _id ( v . native ( ) ) ) ) } 
func ( v * Settings Schema ) Get Path ( ) string { return C . Go String ( ( * C . char ) ( C . g _settings _schema _get _path ( v . native ( ) ) ) ) } 
func ( v * Settings Schema ) Has Key ( v 1 string ) bool { cstr : = ( * C . gchar ) ( C . CString ( v 1 ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return gobool ( C . g _settings _schema _has _key ( v . native ( ) , cstr ) ) } 
func ( v * Object ) Connect ( detailed Signal string , f interface { } , user Data . . . interface { } ) ( Signal Handle , error ) { return v . connect Closure ( false , detailed Signal , f , user Data . . . ) } 
func ( v * Object ) Connect After ( detailed Signal string , f interface { } , user Data . . . interface { } ) ( Signal Handle , error ) { return v . connect Closure ( true , detailed Signal , f , user Data . . . ) } 
func Closure New ( f interface { } , marshal Data . . . interface { } ) ( * C . GClosure , error ) { } if len ( marshal Data ) > 0 { cc . user Data = reflect . Value Of ( marshal Data [ 0 ] ) } c : = C . _g _closure _new ( ) closures . m [ c ] = cc closures . Unlock ( ) return c , nil } 
func remove Closure ( _ C . gpointer , closure * C . GClosure ) { closures . Lock ( ) delete ( closures . m , closure ) closures . Unlock ( ) } 
func Settings Schema Source New From Directory ( dir string , parent * Settings Schema Source , trusted bool ) * Settings Schema Source { cstr : = ( * C . gchar ) ( C . CString ( dir ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrap Settings Schema Source ( C . g _settings _schema _source _new _from _directory ( cstr , parent . native ( ) , gbool ( trusted ) , nil ) ) } 
func ( v * Settings Schema Source ) Lookup ( schema string , recursive bool ) * Settings Schema { cstr : = ( * C . gchar ) ( C . CString ( schema ) ) defer C . free ( unsafe . Pointer ( cstr ) ) return wrap Settings Schema ( C . g _settings _schema _source _lookup ( v . native ( ) , cstr , gbool ( recursive ) ) ) } 
func ( v * Settings Schema Source ) List Schemas ( recursive bool ) ( non Reolcatable , relocatable [ ] string ) { var non Rel , rel * * C . gchar C . g _settings _schema _source _list _schemas ( v . native ( ) , gbool ( recursive ) , & non Rel , & rel ) return to Go String Array ( non Rel ) , to Go String Array ( rel ) } 
func ( v * Color Chooser ) native ( ) * C . Gtk Color Chooser { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Color Chooser ( p ) } 
func ( v * Color Chooser ) Get RGBA ( ) * gdk . RGBA { gdk Color : = gdk . New RGBA ( ) C . gtk _color _chooser _get _rgba ( v . native ( ) , ( * C . Gdk RGBA ) ( unsafe . Pointer ( gdk Color . Native ( ) ) ) ) return gdk Color } 
func ( v * Color Chooser ) Set RGBA ( gdk Color * gdk . RGBA ) { C . gtk _color _chooser _set _rgba ( v . native ( ) , ( * C . Gdk RGBA ) ( unsafe . Pointer ( gdk Color . Native ( ) ) ) ) } 
func ( v * Color Chooser ) Set Use Alpha ( use _alpha bool ) { C . gtk _color _chooser _set _use _alpha ( v . native ( ) , gbool ( use _alpha ) ) } 
func ( v * Color Chooser ) Add Palette ( orientation Orientation , colors _per _line int , colors [ ] * gdk . RGBA ) { n _colors : = len ( colors ) var c _colors [ ] C . Gdk RGBA for _ , c : = range colors { c _colors = append ( c _colors , * ( * C . Gdk RGBA ) ( unsafe . Pointer ( c . Native ( ) ) ) ) } C . gtk _color _chooser _add _palette ( v . native ( ) , C . Gtk Orientation ( orientation ) , C . gint ( colors _per _line ) , C . gint ( n _colors ) , & c _colors [ 0 ] , ) } 
func ( v * Color Chooser Dialog ) native ( ) * C . Gtk Color Chooser Dialog { if v = = nil | | v . GObject = = nil { return nil } p : = unsafe . Pointer ( v . GObject ) return C . to Gtk Color Chooser Dialog ( p ) } 
func Color Chooser Dialog New ( title string , parent * Window ) ( * Color Chooser Dialog , error ) { cstr : = C . CString ( title ) defer C . free ( unsafe . Pointer ( cstr ) ) c : = C . gtk _color _chooser _dialog _new ( ( * C . gchar ) ( cstr ) , parent . native ( ) ) if c = = nil { return nil , nil Ptr Err } return wrap Color Chooser Dialog ( glib . Take ( unsafe . Pointer ( c ) ) ) , nil } 
func ( v * Source ) native ( ) * C . GSource { if v = = nil { return nil } return ( * C . GSource ) ( v ) } 
func Main Current Source ( ) * Source { c : = C . g _main _current _source ( ) if c = = nil { return nil } return ( * Source ) ( c ) } 
func ( v * Context ) Translate ( tx , ty float 6 4 ) { C . cairo _translate ( v . native ( ) , C . double ( tx ) , C . double ( ty ) ) } 
func ( v * Context ) Scale ( sx , sy float 6 4 ) { C . cairo _scale ( v . native ( ) , C . double ( sx ) , C . double ( sy ) ) } 
func ( v * Context ) Rotate ( angle float 6 4 ) { C . cairo _rotate ( v . native ( ) , C . double ( angle ) ) } 
func ( v * Context ) Transform ( matrix * Matrix ) { C . cairo _transform ( v . native ( ) , matrix . native ( ) ) } 
func ( v * Context ) Set Matrix ( matrix * Matrix ) { C . cairo _set _matrix ( v . native ( ) , matrix . native ( ) ) } 
func ( v * Context ) Get Matrix ( ) * Matrix { var matrix C . cairo _matrix _t C . cairo _get _matrix ( v . native ( ) , & matrix ) return & Matrix { Xx : float 6 4 ( matrix . xx ) , Yx : float 6 4 ( matrix . yx ) , Xy : float 6 4 ( matrix . xy ) , Yy : float 6 4 ( matrix . yy ) , X 0 : float 6 4 ( matrix . x 0 ) , Y 0 : float 6 4 ( matrix . y 0 ) , } } 
func ( v * Context ) User To Device ( x , y float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _user _to _device ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( v * Context ) User To Device Distance ( dx , dy float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _user _to _device _distance ( v . native ( ) , ( * C . double ) ( & dx ) , ( * C . double ) ( & dy ) ) return dx , dy } 
func ( v * Context ) Device To User ( x , y float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _device _to _user ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( v * Context ) Device To User Distance ( x , y float 6 4 ) ( float 6 4 , float 6 4 ) { C . cairo _device _to _user _distance ( v . native ( ) , ( * C . double ) ( & x ) , ( * C . double ) ( & y ) ) return x , y } 
func ( p * Piece ) is Blocked ( i , j int , angle Angle ) bool { size : = len ( p . blocks ) i 2 , j 2 : = i , j switch angle { case Angle 0 : case Angle 9 0 : i 2 = j j 2 = size - 1 - i case Angle 1 8 0 : i 2 = size - 1 - i j 2 = size - 1 - j case Angle 2 7 0 : i 2 = size - 1 - j j 2 = i } return p . blocks [ i 2 ] [ j 2 ] } 
func ( p * Piece ) collides ( field * Field , x , y int , angle Angle ) bool { size : = len ( p . blocks ) for i : = 0 ; i < size ; i + + { for j : = 0 ; j < size ; j + + { if field . Is Blocked ( x + i , y + j ) & & p . is Blocked ( i , j , angle ) { return true } } } return false } 
func ( s * Sprite ) In ( x , y int ) bool { } 
func ( s * Sprite ) Move By ( x , y int ) { w , h : = s . image . Size ( ) s . x + = x s . y + = y if s . x < 0 { s . x = 0 } if s . x > screen Width - w { s . x = screen Width - w } if s . y < 0 { s . y = 0 } if s . y > screen Height - h { s . y = screen Height - h } } 
func ( s * Sprite ) Draw ( screen * ebiten . Image , dx , dy int , alpha float 6 4 ) { op : = & ebiten . Draw Image Options { } op . Geo M . Translate ( float 6 4 ( s . x + dx ) , float 6 4 ( s . y + dy ) ) op . Color M . Scale ( 1 , 1 , 1 , alpha ) screen . Draw Image ( s . image , op ) screen . Draw Image ( s . image , op ) } 
func ( s * Stream ) Read ( buf [ ] byte ) ( int , error ) { if s . resampling ! = nil { return s . resampling . Read ( buf ) } return s . orig . Read ( buf ) } 
func ( s * Stream ) Seek ( offset int 6 4 , whence int ) ( int 6 4 , error ) { if s . resampling ! = nil { return s . resampling . Seek ( offset , whence ) } return s . orig . Seek ( offset , whence ) } 
func ( s * Stream ) Close ( ) error { runtime . Set Finalizer ( s , nil ) return s . to Close . Close ( ) } 
func ( s * Stream ) Length ( ) int 6 4 { if s . resampling ! = nil { return s . resampling . Length ( ) } return s . orig . Length ( ) } 
func Decode ( context * audio . Context , src audio . Read Seek Closer ) ( * Stream , error ) { d , err : = mp 3 . New Decoder ( src ) if err ! = nil { return nil , err } var r * convert . Resampling if d . Sample Rate ( ) ! = context . Sample Rate ( ) { r = convert . New Resampling ( d , d . Length ( ) , d . Sample Rate ( ) , context . Sample Rate ( ) ) } s : = & Stream { orig : d , resampling : r , to Close : src , } runtime . Set Finalizer ( s , ( * Stream ) . Close ) return s , nil } 
func Input Chars ( ) [ ] rune { rb : = ui Driver ( ) . Input ( ) . Rune Buffer ( ) return append ( make ( [ ] rune , 0 , len ( rb ) ) , rb . . . ) } 
func Is Key Pressed ( key Key ) bool { return ui Driver ( ) . Input ( ) . Is Key Pressed ( driver . Key ( key ) ) } 
func Is Mouse Button Pressed ( mouse Button Mouse Button ) bool { return ui Driver ( ) . Input ( ) . Is Mouse Button Pressed ( driver . Mouse Button ( mouse Button ) ) } 
func Gamepad Axis ( id int , axis int ) float 6 4 { return ui Driver ( ) . Input ( ) . Gamepad Axis ( id , axis ) } 
func Is Gamepad Button Pressed ( id int , button Gamepad Button ) bool { return ui Driver ( ) . Input ( ) . Is Gamepad Button Pressed ( id , driver . Gamepad Button ( button ) ) } 
func Touch Position ( id int ) ( int , int ) { found : = false for _ , i : = range ui Driver ( ) . Input ( ) . Touch IDs ( ) { if id = = i { found = true break } } if ! found { return 0 , 0 } return ui Driver ( ) . Input ( ) . Touch Position ( id ) } 
func Touches ( ) [ ] Touch { var ts [ ] Touch for _ , id : = range Touch IDs ( ) { x , y : = Touch Position ( id ) ts = append ( ts , & touch { id : id , x : x , y : y , } ) } return ts } 
func paeth ( a , b , c uint 8 ) uint 8 { pa : = int ( b ) - pc pb : = int ( a ) - pc pc = abs ( pa + pb ) pa = abs ( pa ) pb = abs ( pb ) if pa < = pb & & pa < = pc { return a } else if pb < = pc { return b } return c } 
func filter Paeth ( cdat , pdat [ ] byte , bytes Per Pixel int ) { var a , b , c , pa , pb , pc int for i : = 0 ; i < bytes Per Pixel ; i + + { a , c = 0 , 0 for j : = i ; j < len ( cdat ) ; j + = bytes Per Pixel { b = int ( pdat [ j ] ) pa = b - c pb = a - c pc = abs ( pa + pb ) pa = abs ( pa ) pb = abs ( pb ) if pa < = pb & & pa < = pc { } else { a = c } a + = int ( cdat [ j ] ) a & = 0xff cdat [ j ] = uint 8 ( a ) c = b } } } 
func Mipmap Level ( det float 3 2 ) int { if math . Is Na N ( float 6 4 ( det ) ) { panic ( " " ) } if det = = 0 { return - 1 } d : = math . Abs ( float 6 4 ( det ) ) level : = 0 for d < 0 . 2 5 { level + + d * = 4 } return level } 
func hide Console Window On Windows ( ) { pid , err : = get Current Process Id ( ) if err ! = nil { } w , err : = get Console Window ( ) if err ! = nil { } if err ! = nil { } if pid = = cpid { } } 
func Accum ( op uint 3 2 , value float 3 2 ) { C . glow Accum ( gp Accum , ( C . GLenum ) ( op ) , ( C . GLfloat ) ( value ) ) } 
func Active Shader Program ( pipeline uint 3 2 , program uint 3 2 ) { C . glow Active Shader Program ( gp Active Shader Program , ( C . GLuint ) ( pipeline ) , ( C . GLuint ) ( program ) ) } 
func Alpha Func ( xfunc uint 3 2 , ref float 3 2 ) { C . glow Alpha Func ( gp Alpha Func , ( C . GLenum ) ( xfunc ) , ( C . GLfloat ) ( ref ) ) } 
func Are Textures Resident ( n int 3 2 , textures * uint 3 2 , residences * bool ) bool { ret : = C . glow Are Textures Resident ( gp Are Textures Resident , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) , ( * C . GLboolean ) ( unsafe . Pointer ( residences ) ) ) return ret = = TRUE } 
func Attach Shader ( program uint 3 2 , shader uint 3 2 ) { C . glow Attach Shader ( gp Attach Shader , ( C . GLuint ) ( program ) , ( C . GLuint ) ( shader ) ) } 
func Begin Query ( target uint 3 2 , id uint 3 2 ) { C . glow Begin Query ( gp Begin Query , ( C . GLenum ) ( target ) , ( C . GLuint ) ( id ) ) } 
func Bind Attrib Location ( program uint 3 2 , index uint 3 2 , name * uint 8 ) { C . glow Bind Attrib Location ( gp Bind Attrib Location , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Bind Buffer ( target uint 3 2 , buffer uint 3 2 ) { C . glow Bind Buffer ( gp Bind Buffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( buffer ) ) } 
func Bind Buffer Base ( target uint 3 2 , index uint 3 2 , buffer uint 3 2 ) { C . glow Bind Buffer Base ( gp Bind Buffer Base , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) ) } 
func Bind Buffer Range ( target uint 3 2 , index uint 3 2 , buffer uint 3 2 , offset int , size int ) { C . glow Bind Buffer Range ( gp Bind Buffer Range , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Bind Buffers Base ( target uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 ) { C . glow Bind Buffers Base ( gp Bind Buffers Base , ( C . GLenum ) ( target ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func Bind Buffers Range ( target uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , sizes * int ) { C . glow Bind Buffers Range ( gp Bind Buffers Range , ( C . GLenum ) ( target ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizeiptr ) ( unsafe . Pointer ( sizes ) ) ) } 
func Bind Frag Data Location Indexed ( program uint 3 2 , color Number uint 3 2 , index uint 3 2 , name * uint 8 ) { C . glow Bind Frag Data Location Indexed ( gp Bind Frag Data Location Indexed , ( C . GLuint ) ( program ) , ( C . GLuint ) ( color Number ) , ( C . GLuint ) ( index ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Bind Framebuffer ( target uint 3 2 , framebuffer uint 3 2 ) { C . glow Bind Framebuffer ( gp Bind Framebuffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( framebuffer ) ) } 
func Bind Image Texture ( unit uint 3 2 , texture uint 3 2 , level int 3 2 , layered bool , layer int 3 2 , access uint 3 2 , format uint 3 2 ) { C . glow Bind Image Texture ( gp Bind Image Texture , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLboolean ) ( bool To Int ( layered ) ) , ( C . GLint ) ( layer ) , ( C . GLenum ) ( access ) , ( C . GLenum ) ( format ) ) } 
func Bind Image Textures ( first uint 3 2 , count int 3 2 , textures * uint 3 2 ) { C . glow Bind Image Textures ( gp Bind Image Textures , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func Bind Renderbuffer ( target uint 3 2 , renderbuffer uint 3 2 ) { C . glow Bind Renderbuffer ( gp Bind Renderbuffer , ( C . GLenum ) ( target ) , ( C . GLuint ) ( renderbuffer ) ) } 
func Bind Sampler ( unit uint 3 2 , sampler uint 3 2 ) { C . glow Bind Sampler ( gp Bind Sampler , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( sampler ) ) } 
func Bind Samplers ( first uint 3 2 , count int 3 2 , samplers * uint 3 2 ) { C . glow Bind Samplers ( gp Bind Samplers , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func Bind Texture ( target uint 3 2 , texture uint 3 2 ) { C . glow Bind Texture ( gp Bind Texture , ( C . GLenum ) ( target ) , ( C . GLuint ) ( texture ) ) } 
func Bind Texture Unit ( unit uint 3 2 , texture uint 3 2 ) { C . glow Bind Texture Unit ( gp Bind Texture Unit , ( C . GLuint ) ( unit ) , ( C . GLuint ) ( texture ) ) } 
func Bind Textures ( first uint 3 2 , count int 3 2 , textures * uint 3 2 ) { C . glow Bind Textures ( gp Bind Textures , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func Bind Transform Feedback ( target uint 3 2 , id uint 3 2 ) { C . glow Bind Transform Feedback ( gp Bind Transform Feedback , ( C . GLenum ) ( target ) , ( C . GLuint ) ( id ) ) } 
func Bind Vertex Buffer ( bindingindex uint 3 2 , buffer uint 3 2 , offset int , stride int 3 2 ) { C . glow Bind Vertex Buffer ( gp Bind Vertex Buffer , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizei ) ( stride ) ) } 
func Bind Vertex Buffers ( first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , strides * int 3 2 ) { C . glow Bind Vertex Buffers ( gp Bind Vertex Buffers , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( strides ) ) ) } 
func Bitmap ( width int 3 2 , height int 3 2 , xorig float 3 2 , yorig float 3 2 , xmove float 3 2 , ymove float 3 2 , bitmap * uint 8 ) { C . glow Bitmap ( gp Bitmap , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLfloat ) ( xorig ) , ( C . GLfloat ) ( yorig ) , ( C . GLfloat ) ( xmove ) , ( C . GLfloat ) ( ymove ) , ( * C . GLubyte ) ( unsafe . Pointer ( bitmap ) ) ) } 
func Blend Color ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { C . glow Blend Color ( gp Blend Color , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func Blend Equation Separate ( mode RGB uint 3 2 , mode Alpha uint 3 2 ) { C . glow Blend Equation Separate ( gp Blend Equation Separate , ( C . GLenum ) ( mode RGB ) , ( C . GLenum ) ( mode Alpha ) ) } 
func Blend Func ( sfactor uint 3 2 , dfactor uint 3 2 ) { C . glow Blend Func ( gp Blend Func , ( C . GLenum ) ( sfactor ) , ( C . GLenum ) ( dfactor ) ) } 
func Blend Func Separate ( sfactor RGB uint 3 2 , dfactor RGB uint 3 2 , sfactor Alpha uint 3 2 , dfactor Alpha uint 3 2 ) { C . glow Blend Func Separate ( gp Blend Func Separate , ( C . GLenum ) ( sfactor RGB ) , ( C . GLenum ) ( dfactor RGB ) , ( C . GLenum ) ( sfactor Alpha ) , ( C . GLenum ) ( dfactor Alpha ) ) } 
func Blit Framebuffer ( src X 0 int 3 2 , src Y 0 int 3 2 , src X 1 int 3 2 , src Y 1 int 3 2 , dst X 0 int 3 2 , dst Y 0 int 3 2 , dst X 1 int 3 2 , dst Y 1 int 3 2 , mask uint 3 2 , filter uint 3 2 ) { C . glow Blit Framebuffer ( gp Blit Framebuffer , ( C . GLint ) ( src X 0 ) , ( C . GLint ) ( src Y 0 ) , ( C . GLint ) ( src X 1 ) , ( C . GLint ) ( src Y 1 ) , ( C . GLint ) ( dst X 0 ) , ( C . GLint ) ( dst Y 0 ) , ( C . GLint ) ( dst X 1 ) , ( C . GLint ) ( dst Y 1 ) , ( C . GLbitfield ) ( mask ) , ( C . GLenum ) ( filter ) ) } 
func Blit Named Framebuffer ( read Framebuffer uint 3 2 , draw Framebuffer uint 3 2 , src X 0 int 3 2 , src Y 0 int 3 2 , src X 1 int 3 2 , src Y 1 int 3 2 , dst X 0 int 3 2 , dst Y 0 int 3 2 , dst X 1 int 3 2 , dst Y 1 int 3 2 , mask uint 3 2 , filter uint 3 2 ) { C . glow Blit Named Framebuffer ( gp Blit Named Framebuffer , ( C . GLuint ) ( read Framebuffer ) , ( C . GLuint ) ( draw Framebuffer ) , ( C . GLint ) ( src X 0 ) , ( C . GLint ) ( src Y 0 ) , ( C . GLint ) ( src X 1 ) , ( C . GLint ) ( src Y 1 ) , ( C . GLint ) ( dst X 0 ) , ( C . GLint ) ( dst Y 0 ) , ( C . GLint ) ( dst X 1 ) , ( C . GLint ) ( dst Y 1 ) , ( C . GLbitfield ) ( mask ) , ( C . GLenum ) ( filter ) ) } 
func Buffer Data ( target uint 3 2 , size int , data unsafe . Pointer , usage uint 3 2 ) { C . glow Buffer Data ( gp Buffer Data , ( C . GLenum ) ( target ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLenum ) ( usage ) ) } 
func Buffer Storage ( target uint 3 2 , size int , data unsafe . Pointer , flags uint 3 2 ) { C . glow Buffer Storage ( gp Buffer Storage , ( C . GLenum ) ( target ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLbitfield ) ( flags ) ) } 
func Buffer Storage External EXT ( target uint 3 2 , offset int , size int , client Buffer unsafe . Pointer , flags uint 3 2 ) { C . glow Buffer Storage External EXT ( gp Buffer Storage External EXT , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLegl Client Buffer EXT ) ( client Buffer ) , ( C . GLbitfield ) ( flags ) ) } 
func Buffer Sub Data ( target uint 3 2 , offset int , size int , data unsafe . Pointer ) { C . glow Buffer Sub Data ( gp Buffer Sub Data , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func Call Lists ( n int 3 2 , xtype uint 3 2 , lists unsafe . Pointer ) { C . glow Call Lists ( gp Call Lists , ( C . GLsizei ) ( n ) , ( C . GLenum ) ( xtype ) , lists ) } 
func Check Framebuffer Status ( target uint 3 2 ) uint 3 2 { ret : = C . glow Check Framebuffer Status ( gp Check Framebuffer Status , ( C . GLenum ) ( target ) ) return ( uint 3 2 ) ( ret ) } 
func Check Named Framebuffer Status ( framebuffer uint 3 2 , target uint 3 2 ) uint 3 2 { ret : = C . glow Check Named Framebuffer Status ( gp Check Named Framebuffer Status , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( target ) ) return ( uint 3 2 ) ( ret ) } 
func Clear Accum ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { C . glow Clear Accum ( gp Clear Accum , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func Clear Buffer Data ( target uint 3 2 , internalformat uint 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Buffer Data ( gp Clear Buffer Data , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Clear Buffer Sub Data ( target uint 3 2 , internalformat uint 3 2 , offset int , size int , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Buffer Sub Data ( gp Clear Buffer Sub Data , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Clear Color ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { C . glow Clear Color ( gp Clear Color , ( C . GLfloat ) ( red ) , ( C . GLfloat ) ( green ) , ( C . GLfloat ) ( blue ) , ( C . GLfloat ) ( alpha ) ) } 
func Clear Named Buffer Data ( buffer uint 3 2 , internalformat uint 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Named Buffer Data ( gp Clear Named Buffer Data , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Clear Named Buffer Sub Data ( buffer uint 3 2 , internalformat uint 3 2 , offset int , size int , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Named Buffer Sub Data ( gp Clear Named Buffer Sub Data , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Clear Tex Image ( texture uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Tex Image ( gp Clear Tex Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Clear Tex Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { C . glow Clear Tex Sub Image ( gp Clear Tex Sub Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , data ) } 
func Client Wait Sync ( sync uintptr , flags uint 3 2 , timeout uint 6 4 ) uint 3 2 { ret : = C . glow Client Wait Sync ( gp Client Wait Sync , ( C . GLsync ) ( sync ) , ( C . GLbitfield ) ( flags ) , ( C . GLuint 6 4 ) ( timeout ) ) return ( uint 3 2 ) ( ret ) } 
func Clip Control ( origin uint 3 2 , depth uint 3 2 ) { C . glow Clip Control ( gp Clip Control , ( C . GLenum ) ( origin ) , ( C . GLenum ) ( depth ) ) } 
func Clip Plane ( plane uint 3 2 , equation * float 6 4 ) { C . glow Clip Plane ( gp Clip Plane , ( C . GLenum ) ( plane ) , ( * C . GLdouble ) ( unsafe . Pointer ( equation ) ) ) } 
func Color Material ( face uint 3 2 , mode uint 3 2 ) { C . glow Color Material ( gp Color Material , ( C . GLenum ) ( face ) , ( C . GLenum ) ( mode ) ) } 
func Color Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Color Pointer ( gp Color Pointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Compressed Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Image 1D ( gp Compressed Tex Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Image 2D ( gp Compressed Tex Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Tex Image 3D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Image 3D ( gp Compressed Tex Image 3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLint ) ( border ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Sub Image 1D ( gp Compressed Tex Sub Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Tex Sub Image 2D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Sub Image 2D ( gp Compressed Tex Sub Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Tex Sub Image 3D ( gp Compressed Tex Sub Image 3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Texture Sub Image 1D ( gp Compressed Texture Sub Image 1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Texture Sub Image 2D ( gp Compressed Texture Sub Image 2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Compressed Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { C . glow Compressed Texture Sub Image 3D ( gp Compressed Texture Sub Image 3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( image Size ) , data ) } 
func Copy Buffer Sub Data ( read Target uint 3 2 , write Target uint 3 2 , read Offset int , write Offset int , size int ) { C . glow Copy Buffer Sub Data ( gp Copy Buffer Sub Data , ( C . GLenum ) ( read Target ) , ( C . GLenum ) ( write Target ) , ( C . GLintptr ) ( read Offset ) , ( C . GLintptr ) ( write Offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Copy Image Sub Data ( src Name uint 3 2 , src Target uint 3 2 , src Level int 3 2 , src X int 3 2 , src Y int 3 2 , src Z int 3 2 , dst Name uint 3 2 , dst Target uint 3 2 , dst Level int 3 2 , dst X int 3 2 , dst Y int 3 2 , dst Z int 3 2 , src Width int 3 2 , src Height int 3 2 , src Depth int 3 2 ) { C . glow Copy Image Sub Data ( gp Copy Image Sub Data , ( C . GLuint ) ( src Name ) , ( C . GLenum ) ( src Target ) , ( C . GLint ) ( src Level ) , ( C . GLint ) ( src X ) , ( C . GLint ) ( src Y ) , ( C . GLint ) ( src Z ) , ( C . GLuint ) ( dst Name ) , ( C . GLenum ) ( dst Target ) , ( C . GLint ) ( dst Level ) , ( C . GLint ) ( dst X ) , ( C . GLint ) ( dst Y ) , ( C . GLint ) ( dst Z ) , ( C . GLsizei ) ( src Width ) , ( C . GLsizei ) ( src Height ) , ( C . GLsizei ) ( src Depth ) ) } 
func Copy Named Buffer Sub Data ( read Buffer uint 3 2 , write Buffer uint 3 2 , read Offset int , write Offset int , size int ) { C . glow Copy Named Buffer Sub Data ( gp Copy Named Buffer Sub Data , ( C . GLuint ) ( read Buffer ) , ( C . GLuint ) ( write Buffer ) , ( C . GLintptr ) ( read Offset ) , ( C . GLintptr ) ( write Offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Copy Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , xtype uint 3 2 ) { C . glow Copy Pixels ( gp Copy Pixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( xtype ) ) } 
func Copy Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , border int 3 2 ) { C . glow Copy Tex Image 1D ( gp Copy Tex Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) ) } 
func Copy Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , border int 3 2 ) { C . glow Copy Tex Image 2D ( gp Copy Tex Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( internalformat ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) ) } 
func Copy Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 ) { C . glow Copy Tex Sub Image 1D ( gp Copy Tex Sub Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) ) } 
func Copy Tex Sub Image 2D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Copy Tex Sub Image 2D ( gp Copy Tex Sub Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Copy Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Copy Tex Sub Image 3D ( gp Copy Tex Sub Image 3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Copy Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 ) { C . glow Copy Texture Sub Image 1D ( gp Copy Texture Sub Image 1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) ) } 
func Copy Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Copy Texture Sub Image 2D ( gp Copy Texture Sub Image 2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Copy Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Copy Texture Sub Image 3D ( gp Copy Texture Sub Image 3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Create Buffers ( n int 3 2 , buffers * uint 3 2 ) { C . glow Create Buffers ( gp Create Buffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func Create Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { C . glow Create Framebuffers ( gp Create Framebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func Create Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { C . glow Create Program Pipelines ( gp Create Program Pipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func Create Queries ( target uint 3 2 , n int 3 2 , ids * uint 3 2 ) { C . glow Create Queries ( gp Create Queries , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Create Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { C . glow Create Renderbuffers ( gp Create Renderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func Create Samplers ( n int 3 2 , samplers * uint 3 2 ) { C . glow Create Samplers ( gp Create Samplers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func Create Shader ( xtype uint 3 2 ) uint 3 2 { ret : = C . glow Create Shader ( gp Create Shader , ( C . GLenum ) ( xtype ) ) return ( uint 3 2 ) ( ret ) } 
func Create Shader Programv ( xtype uint 3 2 , count int 3 2 , strings * * uint 8 ) uint 3 2 { ret : = C . glow Create Shader Programv ( gp Create Shader Programv , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( count ) , ( * * C . GLchar ) ( unsafe . Pointer ( strings ) ) ) return ( uint 3 2 ) ( ret ) } 
func Create Sync From CLevent ARB ( context unsafe . Pointer , event unsafe . Pointer , flags uint 3 2 ) uintptr { ret : = C . glow Create Sync From CLevent ARB ( gp Create Sync From CLevent ARB , ( * C . struct _ _cl _context ) ( context ) , ( * C . struct _ _cl _event ) ( event ) , ( C . GLbitfield ) ( flags ) ) return ( uintptr ) ( ret ) } 
func Create Textures ( target uint 3 2 , n int 3 2 , textures * uint 3 2 ) { C . glow Create Textures ( gp Create Textures , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func Create Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { C . glow Create Transform Feedbacks ( gp Create Transform Feedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Create Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { C . glow Create Vertex Arrays ( gp Create Vertex Arrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func Debug Message Callback AMD ( callback unsafe . Pointer , user Param unsafe . Pointer ) { C . glow Debug Message Callback AMD ( gp Debug Message Callback AMD , ( C . GLDEBUGPROCAMD ) ( callback ) , user Param ) } 
func Debug Message Callback ARB ( callback unsafe . Pointer , user Param unsafe . Pointer ) { C . glow Debug Message Callback ARB ( gp Debug Message Callback ARB , ( C . GLDEBUGPROCARB ) ( unsafe . Pointer ( & callback ) ) , user Param ) } 
func Debug Message Callback KHR ( callback unsafe . Pointer , user Param unsafe . Pointer ) { C . glow Debug Message Callback KHR ( gp Debug Message Callback KHR , ( C . GLDEBUGPROCKHR ) ( unsafe . Pointer ( & callback ) ) , user Param ) } 
func Debug Message Control ( source uint 3 2 , xtype uint 3 2 , severity uint 3 2 , count int 3 2 , ids * uint 3 2 , enabled bool ) { C . glow Debug Message Control ( gp Debug Message Control , ( C . GLenum ) ( source ) , ( C . GLenum ) ( xtype ) , ( C . GLenum ) ( severity ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) , ( C . GLboolean ) ( bool To Int ( enabled ) ) ) } 
func Debug Message Insert ( source uint 3 2 , xtype uint 3 2 , id uint 3 2 , severity uint 3 2 , length int 3 2 , buf * uint 8 ) { C . glow Debug Message Insert ( gp Debug Message Insert , ( C . GLenum ) ( source ) , ( C . GLenum ) ( xtype ) , ( C . GLuint ) ( id ) , ( C . GLenum ) ( severity ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( buf ) ) ) } 
func Delete Buffers ( n int 3 2 , buffers * uint 3 2 ) { C . glow Delete Buffers ( gp Delete Buffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func Delete Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { C . glow Delete Framebuffers ( gp Delete Framebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func Delete Lists ( list uint 3 2 , xrange int 3 2 ) { C . glow Delete Lists ( gp Delete Lists , ( C . GLuint ) ( list ) , ( C . GLsizei ) ( xrange ) ) } 
func Delete Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { C . glow Delete Program Pipelines ( gp Delete Program Pipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func Delete Queries ( n int 3 2 , ids * uint 3 2 ) { C . glow Delete Queries ( gp Delete Queries , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Delete Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { C . glow Delete Renderbuffers ( gp Delete Renderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func Delete Samplers ( count int 3 2 , samplers * uint 3 2 ) { C . glow Delete Samplers ( gp Delete Samplers , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func Delete Textures ( n int 3 2 , textures * uint 3 2 ) { C . glow Delete Textures ( gp Delete Textures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func Delete Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { C . glow Delete Transform Feedbacks ( gp Delete Transform Feedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Delete Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { C . glow Delete Vertex Arrays ( gp Delete Vertex Arrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func Depth Mask ( flag bool ) { C . glow Depth Mask ( gp Depth Mask , ( C . GLboolean ) ( bool To Int ( flag ) ) ) } 
func Depth Range ( n float 6 4 , f float 6 4 ) { C . glow Depth Range ( gp Depth Range , ( C . GLdouble ) ( n ) , ( C . GLdouble ) ( f ) ) } 
func Depth Range Indexed ( index uint 3 2 , n float 6 4 , f float 6 4 ) { C . glow Depth Range Indexed ( gp Depth Range Indexed , ( C . GLuint ) ( index ) , ( C . GLdouble ) ( n ) , ( C . GLdouble ) ( f ) ) } 
func Depth Rangef ( n float 3 2 , f float 3 2 ) { C . glow Depth Rangef ( gp Depth Rangef , ( C . GLfloat ) ( n ) , ( C . GLfloat ) ( f ) ) } 
func Detach Shader ( program uint 3 2 , shader uint 3 2 ) { C . glow Detach Shader ( gp Detach Shader , ( C . GLuint ) ( program ) , ( C . GLuint ) ( shader ) ) } 
func Disable Vertex Array Attrib ( vaobj uint 3 2 , index uint 3 2 ) { C . glow Disable Vertex Array Attrib ( gp Disable Vertex Array Attrib , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( index ) ) } 
func Dispatch Compute ( num _groups _x uint 3 2 , num _groups _y uint 3 2 , num _groups _z uint 3 2 ) { C . glow Dispatch Compute ( gp Dispatch Compute , ( C . GLuint ) ( num _groups _x ) , ( C . GLuint ) ( num _groups _y ) , ( C . GLuint ) ( num _groups _z ) ) } 
func Draw Arrays ( mode uint 3 2 , first int 3 2 , count int 3 2 ) { C . glow Draw Arrays ( gp Draw Arrays , ( C . GLenum ) ( mode ) , ( C . GLint ) ( first ) , ( C . GLsizei ) ( count ) ) } 
func Draw Arrays Indirect ( mode uint 3 2 , indirect unsafe . Pointer ) { C . glow Draw Arrays Indirect ( gp Draw Arrays Indirect , ( C . GLenum ) ( mode ) , indirect ) } 
func Draw Arrays Instanced Base Instance ( mode uint 3 2 , first int 3 2 , count int 3 2 , instancecount int 3 2 , baseinstance uint 3 2 ) { C . glow Draw Arrays Instanced Base Instance ( gp Draw Arrays Instanced Base Instance , ( C . GLenum ) ( mode ) , ( C . GLint ) ( first ) , ( C . GLsizei ) ( count ) , ( C . GLsizei ) ( instancecount ) , ( C . GLuint ) ( baseinstance ) ) } 
func Draw Buffers ( n int 3 2 , bufs * uint 3 2 ) { C . glow Draw Buffers ( gp Draw Buffers , ( C . GLsizei ) ( n ) , ( * C . GLenum ) ( unsafe . Pointer ( bufs ) ) ) } 
func Draw Elements ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer ) { C . glow Draw Elements ( gp Draw Elements , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices ) } 
func Draw Elements Base Vertex ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , basevertex int 3 2 ) { C . glow Draw Elements Base Vertex ( gp Draw Elements Base Vertex , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLint ) ( basevertex ) ) } 
func Draw Elements Indirect ( mode uint 3 2 , xtype uint 3 2 , indirect unsafe . Pointer ) { C . glow Draw Elements Indirect ( gp Draw Elements Indirect , ( C . GLenum ) ( mode ) , ( C . GLenum ) ( xtype ) , indirect ) } 
func Draw Elements Instanced Base Instance ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , baseinstance uint 3 2 ) { C . glow Draw Elements Instanced Base Instance ( gp Draw Elements Instanced Base Instance , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLuint ) ( baseinstance ) ) } 
func Draw Elements Instanced Base Vertex ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , basevertex int 3 2 ) { C . glow Draw Elements Instanced Base Vertex ( gp Draw Elements Instanced Base Vertex , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLint ) ( basevertex ) ) } 
func Draw Elements Instanced Base Vertex Base Instance ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , basevertex int 3 2 , baseinstance uint 3 2 ) { C . glow Draw Elements Instanced Base Vertex Base Instance ( gp Draw Elements Instanced Base Vertex Base Instance , ( C . GLenum ) ( mode ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( instancecount ) , ( C . GLint ) ( basevertex ) , ( C . GLuint ) ( baseinstance ) ) } 
func Draw Pixels ( width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Draw Pixels ( gp Draw Pixels , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Draw Range Elements ( mode uint 3 2 , start uint 3 2 , end uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer ) { C . glow Draw Range Elements ( gp Draw Range Elements , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( start ) , ( C . GLuint ) ( end ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices ) } 
func Draw Range Elements Base Vertex ( mode uint 3 2 , start uint 3 2 , end uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , basevertex int 3 2 ) { C . glow Draw Range Elements Base Vertex ( gp Draw Range Elements Base Vertex , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( start ) , ( C . GLuint ) ( end ) , ( C . GLsizei ) ( count ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLint ) ( basevertex ) ) } 
func Draw Transform Feedback ( mode uint 3 2 , id uint 3 2 ) { C . glow Draw Transform Feedback ( gp Draw Transform Feedback , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) ) } 
func Draw Transform Feedback Instanced ( mode uint 3 2 , id uint 3 2 , instancecount int 3 2 ) { C . glow Draw Transform Feedback Instanced ( gp Draw Transform Feedback Instanced , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLsizei ) ( instancecount ) ) } 
func Draw Transform Feedback Stream ( mode uint 3 2 , id uint 3 2 , stream uint 3 2 ) { C . glow Draw Transform Feedback Stream ( gp Draw Transform Feedback Stream , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLuint ) ( stream ) ) } 
func Draw Transform Feedback Stream Instanced ( mode uint 3 2 , id uint 3 2 , stream uint 3 2 , instancecount int 3 2 ) { C . glow Draw Transform Feedback Stream Instanced ( gp Draw Transform Feedback Stream Instanced , ( C . GLenum ) ( mode ) , ( C . GLuint ) ( id ) , ( C . GLuint ) ( stream ) , ( C . GLsizei ) ( instancecount ) ) } 
func EGLImage Target Tex Storage EXT ( target uint 3 2 , image unsafe . Pointer , attrib _list * int 3 2 ) { C . glow EGLImage Target Tex Storage EXT ( gp EGLImage Target Tex Storage EXT , ( C . GLenum ) ( target ) , ( C . GLegl Image OES ) ( image ) , ( * C . GLint ) ( unsafe . Pointer ( attrib _list ) ) ) } 
func EGLImage Target Texture Storage EXT ( texture uint 3 2 , image unsafe . Pointer , attrib _list * int 3 2 ) { C . glow EGLImage Target Texture Storage EXT ( gp EGLImage Target Texture Storage EXT , ( C . GLuint ) ( texture ) , ( C . GLegl Image OES ) ( image ) , ( * C . GLint ) ( unsafe . Pointer ( attrib _list ) ) ) } 
func Edge Flag ( flag bool ) { C . glow Edge Flag ( gp Edge Flag , ( C . GLboolean ) ( bool To Int ( flag ) ) ) } 
func Edge Flag Pointer ( stride int 3 2 , pointer unsafe . Pointer ) { C . glow Edge Flag Pointer ( gp Edge Flag Pointer , ( C . GLsizei ) ( stride ) , pointer ) } 
func Enable Vertex Array Attrib ( vaobj uint 3 2 , index uint 3 2 ) { C . glow Enable Vertex Array Attrib ( gp Enable Vertex Array Attrib , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( index ) ) } 
func Feedback Buffer ( size int 3 2 , xtype uint 3 2 , buffer * float 3 2 ) { C . glow Feedback Buffer ( gp Feedback Buffer , ( C . GLsizei ) ( size ) , ( C . GLenum ) ( xtype ) , ( * C . GLfloat ) ( unsafe . Pointer ( buffer ) ) ) } 
func Fence Sync ( condition uint 3 2 , flags uint 3 2 ) uintptr { ret : = C . glow Fence Sync ( gp Fence Sync , ( C . GLenum ) ( condition ) , ( C . GLbitfield ) ( flags ) ) return ( uintptr ) ( ret ) } 
func Flush Mapped Buffer Range ( target uint 3 2 , offset int , length int ) { C . glow Flush Mapped Buffer Range ( gp Flush Mapped Buffer Range , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func Flush Mapped Named Buffer Range ( buffer uint 3 2 , offset int , length int ) { C . glow Flush Mapped Named Buffer Range ( gp Flush Mapped Named Buffer Range , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func Fog Coord Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Fog Coord Pointer ( gp Fog Coord Pointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Framebuffer Parameteri ( target uint 3 2 , pname uint 3 2 , param int 3 2 ) { C . glow Framebuffer Parameteri ( gp Framebuffer Parameteri , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func Framebuffer Renderbuffer ( target uint 3 2 , attachment uint 3 2 , renderbuffertarget uint 3 2 , renderbuffer uint 3 2 ) { C . glow Framebuffer Renderbuffer ( gp Framebuffer Renderbuffer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( renderbuffertarget ) , ( C . GLuint ) ( renderbuffer ) ) } 
func Framebuffer Texture 2D ( target uint 3 2 , attachment uint 3 2 , textarget uint 3 2 , texture uint 3 2 , level int 3 2 ) { C . glow Framebuffer Texture 2D ( gp Framebuffer Texture 2D , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( textarget ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) ) } 
func Framebuffer Texture Layer ( target uint 3 2 , attachment uint 3 2 , texture uint 3 2 , level int 3 2 , layer int 3 2 ) { C . glow Framebuffer Texture Layer ( gp Framebuffer Texture Layer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( layer ) ) } 
func Frustum ( left float 6 4 , right float 6 4 , bottom float 6 4 , top float 6 4 , z Near float 6 4 , z Far float 6 4 ) { C . glow Frustum ( gp Frustum , ( C . GLdouble ) ( left ) , ( C . GLdouble ) ( right ) , ( C . GLdouble ) ( bottom ) , ( C . GLdouble ) ( top ) , ( C . GLdouble ) ( z Near ) , ( C . GLdouble ) ( z Far ) ) } 
func Gen Buffers ( n int 3 2 , buffers * uint 3 2 ) { C . glow Gen Buffers ( gp Gen Buffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) ) } 
func Gen Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { C . glow Gen Framebuffers ( gp Gen Framebuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( framebuffers ) ) ) } 
func Gen Lists ( xrange int 3 2 ) uint 3 2 { ret : = C . glow Gen Lists ( gp Gen Lists , ( C . GLsizei ) ( xrange ) ) return ( uint 3 2 ) ( ret ) } 
func Gen Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { C . glow Gen Program Pipelines ( gp Gen Program Pipelines , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( pipelines ) ) ) } 
func Gen Queries ( n int 3 2 , ids * uint 3 2 ) { C . glow Gen Queries ( gp Gen Queries , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Gen Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { C . glow Gen Renderbuffers ( gp Gen Renderbuffers , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( renderbuffers ) ) ) } 
func Gen Samplers ( count int 3 2 , samplers * uint 3 2 ) { C . glow Gen Samplers ( gp Gen Samplers , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( samplers ) ) ) } 
func Gen Textures ( n int 3 2 , textures * uint 3 2 ) { C . glow Gen Textures ( gp Gen Textures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) ) } 
func Gen Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { C . glow Gen Transform Feedbacks ( gp Gen Transform Feedbacks , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) ) } 
func Gen Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { C . glow Gen Vertex Arrays ( gp Gen Vertex Arrays , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( arrays ) ) ) } 
func Get Active Atomic Counter Bufferiv ( program uint 3 2 , buffer Index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Active Atomic Counter Bufferiv ( gp Get Active Atomic Counter Bufferiv , ( C . GLuint ) ( program ) , ( C . GLuint ) ( buffer Index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Active Attrib ( program uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , size * int 3 2 , xtype * uint 3 2 , name * uint 8 ) { C . glow Get Active Attrib ( gp Get Active Attrib , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( size ) ) , ( * C . GLenum ) ( unsafe . Pointer ( xtype ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Get Active Subroutine Name ( program uint 3 2 , shadertype uint 3 2 , index uint 3 2 , bufsize int 3 2 , length * int 3 2 , name * uint 8 ) { C . glow Get Active Subroutine Name ( gp Get Active Subroutine Name , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufsize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Get Active Subroutine Uniform Name ( program uint 3 2 , shadertype uint 3 2 , index uint 3 2 , bufsize int 3 2 , length * int 3 2 , name * uint 8 ) { C . glow Get Active Subroutine Uniform Name ( gp Get Active Subroutine Uniform Name , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( bufsize ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Get Active Uniform ( program uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , size * int 3 2 , xtype * uint 3 2 , name * uint 8 ) { C . glow Get Active Uniform ( gp Get Active Uniform , ( C . GLuint ) ( program ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( size ) ) , ( * C . GLenum ) ( unsafe . Pointer ( xtype ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Get Active Uniform Block Name ( program uint 3 2 , uniform Block Index uint 3 2 , buf Size int 3 2 , length * int 3 2 , uniform Block Name * uint 8 ) { C . glow Get Active Uniform Block Name ( gp Get Active Uniform Block Name , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniform Block Index ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( uniform Block Name ) ) ) } 
func Get Active Uniform Blockiv ( program uint 3 2 , uniform Block Index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Active Uniform Blockiv ( gp Get Active Uniform Blockiv , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniform Block Index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Active Uniform Name ( program uint 3 2 , uniform Index uint 3 2 , buf Size int 3 2 , length * int 3 2 , uniform Name * uint 8 ) { C . glow Get Active Uniform Name ( gp Get Active Uniform Name , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniform Index ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( uniform Name ) ) ) } 
func Get Active Uniformsiv ( program uint 3 2 , uniform Count int 3 2 , uniform Indices * uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Active Uniformsiv ( gp Get Active Uniformsiv , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( uniform Count ) , ( * C . GLuint ) ( unsafe . Pointer ( uniform Indices ) ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Attached Shaders ( program uint 3 2 , max Count int 3 2 , count * int 3 2 , shaders * uint 3 2 ) { C . glow Get Attached Shaders ( gp Get Attached Shaders , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( max Count ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( * C . GLuint ) ( unsafe . Pointer ( shaders ) ) ) } 
func Get Attrib Location ( program uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Attrib Location ( gp Get Attrib Location , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Buffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Buffer Parameteriv ( gp Get Buffer Parameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Buffer Pointerv ( target uint 3 2 , pname uint 3 2 , params * unsafe . Pointer ) { C . glow Get Buffer Pointerv ( gp Get Buffer Pointerv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , params ) } 
func Get Buffer Sub Data ( target uint 3 2 , offset int , size int , data unsafe . Pointer ) { C . glow Get Buffer Sub Data ( gp Get Buffer Sub Data , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func Get Clip Plane ( plane uint 3 2 , equation * float 6 4 ) { C . glow Get Clip Plane ( gp Get Clip Plane , ( C . GLenum ) ( plane ) , ( * C . GLdouble ) ( unsafe . Pointer ( equation ) ) ) } 
func Get Compressed Tex Image ( target uint 3 2 , level int 3 2 , img unsafe . Pointer ) { C . glow Get Compressed Tex Image ( gp Get Compressed Tex Image , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , img ) } 
func Get Compressed Texture Image ( texture uint 3 2 , level int 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { C . glow Get Compressed Texture Image ( gp Get Compressed Texture Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLsizei ) ( buf Size ) , pixels ) } 
func Get Compressed Texture Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { C . glow Get Compressed Texture Sub Image ( gp Get Compressed Texture Sub Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLsizei ) ( buf Size ) , pixels ) } 
func Get Debug Message Log ( count uint 3 2 , buf Size int 3 2 , sources * uint 3 2 , types * uint 3 2 , ids * uint 3 2 , severities * uint 3 2 , lengths * int 3 2 , message Log * uint 8 ) uint 3 2 { ret : = C . glow Get Debug Message Log ( gp Get Debug Message Log , ( C . GLuint ) ( count ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLenum ) ( unsafe . Pointer ( sources ) ) , ( * C . GLenum ) ( unsafe . Pointer ( types ) ) , ( * C . GLuint ) ( unsafe . Pointer ( ids ) ) , ( * C . GLenum ) ( unsafe . Pointer ( severities ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( lengths ) ) , ( * C . GLchar ) ( unsafe . Pointer ( message Log ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Frag Data Index ( program uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Frag Data Index ( gp Get Frag Data Index , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Framebuffer Attachment Parameteriv ( target uint 3 2 , attachment uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Framebuffer Attachment Parameteriv ( gp Get Framebuffer Attachment Parameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Framebuffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Framebuffer Parameteriv ( gp Get Framebuffer Parameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Internalformativ ( target uint 3 2 , internalformat uint 3 2 , pname uint 3 2 , buf Size int 3 2 , params * int 3 2 ) { C . glow Get Internalformativ ( gp Get Internalformativ , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLenum ) ( pname ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Multisamplefv ( pname uint 3 2 , index uint 3 2 , val * float 3 2 ) { C . glow Get Multisamplefv ( gp Get Multisamplefv , ( C . GLenum ) ( pname ) , ( C . GLuint ) ( index ) , ( * C . GLfloat ) ( unsafe . Pointer ( val ) ) ) } 
func Get Named Buffer Parameteri 6 4v ( buffer uint 3 2 , pname uint 3 2 , params * int 6 4 ) { C . glow Get Named Buffer Parameteri 6 4v ( gp Get Named Buffer Parameteri 6 4v , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint 6 4 ) ( unsafe . Pointer ( params ) ) ) } 
func Get Named Buffer Parameteriv ( buffer uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Named Buffer Parameteriv ( gp Get Named Buffer Parameteriv , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Named Buffer Pointerv ( buffer uint 3 2 , pname uint 3 2 , params * unsafe . Pointer ) { C . glow Get Named Buffer Pointerv ( gp Get Named Buffer Pointerv , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( pname ) , params ) } 
func Get Named Buffer Sub Data ( buffer uint 3 2 , offset int , size int , data unsafe . Pointer ) { C . glow Get Named Buffer Sub Data ( gp Get Named Buffer Sub Data , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func Get Named Framebuffer Attachment Parameteriv ( framebuffer uint 3 2 , attachment uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Named Framebuffer Attachment Parameteriv ( gp Get Named Framebuffer Attachment Parameteriv , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Named Framebuffer Parameteriv ( framebuffer uint 3 2 , pname uint 3 2 , param * int 3 2 ) { C . glow Get Named Framebuffer Parameteriv ( gp Get Named Framebuffer Parameteriv , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func Get Named Renderbuffer Parameteriv ( renderbuffer uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Named Renderbuffer Parameteriv ( gp Get Named Renderbuffer Parameteriv , ( C . GLuint ) ( renderbuffer ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Object Label ( identifier uint 3 2 , name uint 3 2 , buf Size int 3 2 , length * int 3 2 , label * uint 8 ) { C . glow Get Object Label ( gp Get Object Label , ( C . GLenum ) ( identifier ) , ( C . GLuint ) ( name ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func Get Object Ptr Label ( ptr unsafe . Pointer , buf Size int 3 2 , length * int 3 2 , label * uint 8 ) { C . glow Get Object Ptr Label ( gp Get Object Ptr Label , ptr , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func Get Pointerv ( pname uint 3 2 , params * unsafe . Pointer ) { C . glow Get Pointerv ( gp Get Pointerv , ( C . GLenum ) ( pname ) , params ) } 
func Get Polygon Stipple ( mask * uint 8 ) { C . glow Get Polygon Stipple ( gp Get Polygon Stipple , ( * C . GLubyte ) ( unsafe . Pointer ( mask ) ) ) } 
func Get Program Binary ( program uint 3 2 , buf Size int 3 2 , length * int 3 2 , binary Format * uint 3 2 , binary unsafe . Pointer ) { C . glow Get Program Binary ( gp Get Program Binary , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLenum ) ( unsafe . Pointer ( binary Format ) ) , binary ) } 
func Get Program Info Log ( program uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { C . glow Get Program Info Log ( gp Get Program Info Log , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( info Log ) ) ) } 
func Get Program Pipeline Info Log ( pipeline uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { C . glow Get Program Pipeline Info Log ( gp Get Program Pipeline Info Log , ( C . GLuint ) ( pipeline ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( info Log ) ) ) } 
func Get Program Resource Index ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) uint 3 2 { ret : = C . glow Get Program Resource Index ( gp Get Program Resource Index , ( C . GLuint ) ( program ) , ( C . GLenum ) ( program Interface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Program Resource Location ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Program Resource Location ( gp Get Program Resource Location , ( C . GLuint ) ( program ) , ( C . GLenum ) ( program Interface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Program Resource Location Index ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Program Resource Location Index ( gp Get Program Resource Location Index , ( C . GLuint ) ( program ) , ( C . GLenum ) ( program Interface ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Program Resource Name ( program uint 3 2 , program Interface uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , name * uint 8 ) { C . glow Get Program Resource Name ( gp Get Program Resource Name , ( C . GLuint ) ( program ) , ( C . GLenum ) ( program Interface ) , ( C . GLuint ) ( index ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) } 
func Get Programiv ( program uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Programiv ( gp Get Programiv , ( C . GLuint ) ( program ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Query Indexediv ( target uint 3 2 , index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Query Indexediv ( gp Get Query Indexediv , ( C . GLenum ) ( target ) , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Query Objectuiv ( id uint 3 2 , pname uint 3 2 , params * uint 3 2 ) { C . glow Get Query Objectuiv ( gp Get Query Objectuiv , ( C . GLuint ) ( id ) , ( C . GLenum ) ( pname ) , ( * C . GLuint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Queryiv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Queryiv ( gp Get Queryiv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Renderbuffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Renderbuffer Parameteriv ( gp Get Renderbuffer Parameteriv , ( C . GLenum ) ( target ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Shader Info Log ( shader uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { C . glow Get Shader Info Log ( gp Get Shader Info Log , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( info Log ) ) ) } 
func Get Shader Precision Format ( shadertype uint 3 2 , precisiontype uint 3 2 , xrange * int 3 2 , precision * int 3 2 ) { C . glow Get Shader Precision Format ( gp Get Shader Precision Format , ( C . GLenum ) ( shadertype ) , ( C . GLenum ) ( precisiontype ) , ( * C . GLint ) ( unsafe . Pointer ( xrange ) ) , ( * C . GLint ) ( unsafe . Pointer ( precision ) ) ) } 
func Get Shader Source ( shader uint 3 2 , buf Size int 3 2 , length * int 3 2 , source * uint 8 ) { C . glow Get Shader Source ( gp Get Shader Source , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLchar ) ( unsafe . Pointer ( source ) ) ) } 
func Get Shaderiv ( shader uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Shaderiv ( gp Get Shaderiv , ( C . GLuint ) ( shader ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get String ( name uint 3 2 ) * uint 8 { ret : = C . glow Get String ( gp Get String , ( C . GLenum ) ( name ) ) return ( * uint 8 ) ( ret ) } 
func Get Subroutine Index ( program uint 3 2 , shadertype uint 3 2 , name * uint 8 ) uint 3 2 { ret : = C . glow Get Subroutine Index ( gp Get Subroutine Index , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Subroutine Uniform Location ( program uint 3 2 , shadertype uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Subroutine Uniform Location ( gp Get Subroutine Uniform Location , ( C . GLuint ) ( program ) , ( C . GLenum ) ( shadertype ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Synciv ( sync uintptr , pname uint 3 2 , buf Size int 3 2 , length * int 3 2 , values * int 3 2 ) { C . glow Get Synciv ( gp Get Synciv , ( C . GLsync ) ( sync ) , ( C . GLenum ) ( pname ) , ( C . GLsizei ) ( buf Size ) , ( * C . GLsizei ) ( unsafe . Pointer ( length ) ) , ( * C . GLint ) ( unsafe . Pointer ( values ) ) ) } 
func Get Tex Image ( target uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Get Tex Image ( gp Get Tex Image , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Get Texture Image ( texture uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { C . glow Get Texture Image ( gp Get Texture Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( buf Size ) , pixels ) } 
func Get Texture Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { C . glow Get Texture Sub Image ( gp Get Texture Sub Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( buf Size ) , pixels ) } 
func Get Transform Feedbackiv ( xfb uint 3 2 , pname uint 3 2 , param * int 3 2 ) { C . glow Get Transform Feedbackiv ( gp Get Transform Feedbackiv , ( C . GLuint ) ( xfb ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func Get Uniform Block Index ( program uint 3 2 , uniform Block Name * uint 8 ) uint 3 2 { ret : = C . glow Get Uniform Block Index ( gp Get Uniform Block Index , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( uniform Block Name ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Uniform Indices ( program uint 3 2 , uniform Count int 3 2 , uniform Names * * uint 8 , uniform Indices * uint 3 2 ) { C . glow Get Uniform Indices ( gp Get Uniform Indices , ( C . GLuint ) ( program ) , ( C . GLsizei ) ( uniform Count ) , ( * * C . GLchar ) ( unsafe . Pointer ( uniform Names ) ) , ( * C . GLuint ) ( unsafe . Pointer ( uniform Indices ) ) ) } 
func Get Uniform Location ( program uint 3 2 , name * uint 8 ) int 3 2 { ret : = C . glow Get Uniform Location ( gp Get Uniform Location , ( C . GLuint ) ( program ) , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Uniformfv ( program uint 3 2 , location int 3 2 , params * float 3 2 ) { C . glow Get Uniformfv ( gp Get Uniformfv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( * C . GLfloat ) ( unsafe . Pointer ( params ) ) ) } 
func Get Uniformiv ( program uint 3 2 , location int 3 2 , params * int 3 2 ) { C . glow Get Uniformiv ( gp Get Uniformiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Arrayiv ( vaobj uint 3 2 , pname uint 3 2 , param * int 3 2 ) { C . glow Get Vertex Arrayiv ( gp Get Vertex Arrayiv , ( C . GLuint ) ( vaobj ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( param ) ) ) } 
func Get Vertex Attrib Ldv ( index uint 3 2 , pname uint 3 2 , params * float 6 4 ) { C . glow Get Vertex Attrib Ldv ( gp Get Vertex Attrib Ldv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLdouble ) ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attrib Pointerv ( index uint 3 2 , pname uint 3 2 , pointer * unsafe . Pointer ) { C . glow Get Vertex Attrib Pointerv ( gp Get Vertex Attrib Pointerv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , pointer ) } 
func Get Vertex Attribdv ( index uint 3 2 , pname uint 3 2 , params * float 6 4 ) { C . glow Get Vertex Attribdv ( gp Get Vertex Attribdv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLdouble ) ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attribfv ( index uint 3 2 , pname uint 3 2 , params * float 3 2 ) { C . glow Get Vertex Attribfv ( gp Get Vertex Attribfv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLfloat ) ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attribiv ( index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { C . glow Get Vertex Attribiv ( gp Get Vertex Attribiv , ( C . GLuint ) ( index ) , ( C . GLenum ) ( pname ) , ( * C . GLint ) ( unsafe . Pointer ( params ) ) ) } 
func Get Vk Proc Addr NV ( name * uint 8 ) unsafe . Pointer { ret : = C . glow Get Vk Proc Addr NV ( gp Get Vk Proc Addr NV , ( * C . GLchar ) ( unsafe . Pointer ( name ) ) ) return ( unsafe . Pointer ) ( ret ) } 
func Hint ( target uint 3 2 , mode uint 3 2 ) { C . glow Hint ( gp Hint , ( C . GLenum ) ( target ) , ( C . GLenum ) ( mode ) ) } 
func Index Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Index Pointer ( gp Index Pointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Interleaved Arrays ( format uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Interleaved Arrays ( gp Interleaved Arrays , ( C . GLenum ) ( format ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Invalidate Buffer Sub Data ( buffer uint 3 2 , offset int , length int ) { C . glow Invalidate Buffer Sub Data ( gp Invalidate Buffer Sub Data , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) ) } 
func Invalidate Framebuffer ( target uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 ) { C . glow Invalidate Framebuffer ( gp Invalidate Framebuffer , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( num Attachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) ) } 
func Invalidate Named Framebuffer Data ( framebuffer uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 ) { C . glow Invalidate Named Framebuffer Data ( gp Invalidate Named Framebuffer Data , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( num Attachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) ) } 
func Invalidate Named Framebuffer Sub Data ( framebuffer uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Invalidate Named Framebuffer Sub Data ( gp Invalidate Named Framebuffer Sub Data , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( num Attachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Invalidate Sub Framebuffer ( target uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Invalidate Sub Framebuffer ( gp Invalidate Sub Framebuffer , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( num Attachments ) , ( * C . GLenum ) ( unsafe . Pointer ( attachments ) ) , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Invalidate Tex Image ( texture uint 3 2 , level int 3 2 ) { C . glow Invalidate Tex Image ( gp Invalidate Tex Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) ) } 
func Invalidate Tex Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { C . glow Invalidate Tex Sub Image ( gp Invalidate Tex Sub Image , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func Is Buffer ( buffer uint 3 2 ) bool { ret : = C . glow Is Buffer ( gp Is Buffer , ( C . GLuint ) ( buffer ) ) return ret = = TRUE } 
func Is Framebuffer ( framebuffer uint 3 2 ) bool { ret : = C . glow Is Framebuffer ( gp Is Framebuffer , ( C . GLuint ) ( framebuffer ) ) return ret = = TRUE } 
func Is List ( list uint 3 2 ) bool { ret : = C . glow Is List ( gp Is List , ( C . GLuint ) ( list ) ) return ret = = TRUE } 
func Is Program ( program uint 3 2 ) bool { ret : = C . glow Is Program ( gp Is Program , ( C . GLuint ) ( program ) ) return ret = = TRUE } 
func Is Program Pipeline ( pipeline uint 3 2 ) bool { ret : = C . glow Is Program Pipeline ( gp Is Program Pipeline , ( C . GLuint ) ( pipeline ) ) return ret = = TRUE } 
func Is Query ( id uint 3 2 ) bool { ret : = C . glow Is Query ( gp Is Query , ( C . GLuint ) ( id ) ) return ret = = TRUE } 
func Is Renderbuffer ( renderbuffer uint 3 2 ) bool { ret : = C . glow Is Renderbuffer ( gp Is Renderbuffer , ( C . GLuint ) ( renderbuffer ) ) return ret = = TRUE } 
func Is Sampler ( sampler uint 3 2 ) bool { ret : = C . glow Is Sampler ( gp Is Sampler , ( C . GLuint ) ( sampler ) ) return ret = = TRUE } 
func Is Shader ( shader uint 3 2 ) bool { ret : = C . glow Is Shader ( gp Is Shader , ( C . GLuint ) ( shader ) ) return ret = = TRUE } 
func Is Sync ( sync uintptr ) bool { ret : = C . glow Is Sync ( gp Is Sync , ( C . GLsync ) ( sync ) ) return ret = = TRUE } 
func Is Texture ( texture uint 3 2 ) bool { ret : = C . glow Is Texture ( gp Is Texture , ( C . GLuint ) ( texture ) ) return ret = = TRUE } 
func Is Transform Feedback ( id uint 3 2 ) bool { ret : = C . glow Is Transform Feedback ( gp Is Transform Feedback , ( C . GLuint ) ( id ) ) return ret = = TRUE } 
func Is Vertex Array ( array uint 3 2 ) bool { ret : = C . glow Is Vertex Array ( gp Is Vertex Array , ( C . GLuint ) ( array ) ) return ret = = TRUE } 
func Line Stipple ( factor int 3 2 , pattern uint 1 6 ) { C . glow Line Stipple ( gp Line Stipple , ( C . GLint ) ( factor ) , ( C . GLushort ) ( pattern ) ) } 
func Map Buffer ( target uint 3 2 , access uint 3 2 ) unsafe . Pointer { ret : = C . glow Map Buffer ( gp Map Buffer , ( C . GLenum ) ( target ) , ( C . GLenum ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func Map Buffer Range ( target uint 3 2 , offset int , length int , access uint 3 2 ) unsafe . Pointer { ret : = C . glow Map Buffer Range ( gp Map Buffer Range , ( C . GLenum ) ( target ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) , ( C . GLbitfield ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func Map Named Buffer ( buffer uint 3 2 , access uint 3 2 ) unsafe . Pointer { ret : = C . glow Map Named Buffer ( gp Map Named Buffer , ( C . GLuint ) ( buffer ) , ( C . GLenum ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func Map Named Buffer Range ( buffer uint 3 2 , offset int , length int , access uint 3 2 ) unsafe . Pointer { ret : = C . glow Map Named Buffer Range ( gp Map Named Buffer Range , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( length ) , ( C . GLbitfield ) ( access ) ) return ( unsafe . Pointer ) ( ret ) } 
func Multi Draw Arrays ( mode uint 3 2 , first * int 3 2 , count * int 3 2 , drawcount int 3 2 ) { C . glow Multi Draw Arrays ( gp Multi Draw Arrays , ( C . GLenum ) ( mode ) , ( * C . GLint ) ( unsafe . Pointer ( first ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLsizei ) ( drawcount ) ) } 
func Multi Draw Arrays Indirect ( mode uint 3 2 , indirect unsafe . Pointer , drawcount int 3 2 , stride int 3 2 ) { C . glow Multi Draw Arrays Indirect ( gp Multi Draw Arrays Indirect , ( C . GLenum ) ( mode ) , indirect , ( C . GLsizei ) ( drawcount ) , ( C . GLsizei ) ( stride ) ) } 
func Multi Draw Elements ( mode uint 3 2 , count * int 3 2 , xtype uint 3 2 , indices * unsafe . Pointer , drawcount int 3 2 ) { C . glow Multi Draw Elements ( gp Multi Draw Elements , ( C . GLenum ) ( mode ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( drawcount ) ) } 
func Multi Draw Elements Base Vertex ( mode uint 3 2 , count * int 3 2 , xtype uint 3 2 , indices * unsafe . Pointer , drawcount int 3 2 , basevertex * int 3 2 ) { C . glow Multi Draw Elements Base Vertex ( gp Multi Draw Elements Base Vertex , ( C . GLenum ) ( mode ) , ( * C . GLsizei ) ( unsafe . Pointer ( count ) ) , ( C . GLenum ) ( xtype ) , indices , ( C . GLsizei ) ( drawcount ) , ( * C . GLint ) ( unsafe . Pointer ( basevertex ) ) ) } 
func Multi Draw Elements Indirect ( mode uint 3 2 , xtype uint 3 2 , indirect unsafe . Pointer , drawcount int 3 2 , stride int 3 2 ) { C . glow Multi Draw Elements Indirect ( gp Multi Draw Elements Indirect , ( C . GLenum ) ( mode ) , ( C . GLenum ) ( xtype ) , indirect , ( C . GLsizei ) ( drawcount ) , ( C . GLsizei ) ( stride ) ) } 
func Named Buffer Data ( buffer uint 3 2 , size int , data unsafe . Pointer , usage uint 3 2 ) { C . glow Named Buffer Data ( gp Named Buffer Data , ( C . GLuint ) ( buffer ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLenum ) ( usage ) ) } 
func Named Buffer Storage ( buffer uint 3 2 , size int , data unsafe . Pointer , flags uint 3 2 ) { C . glow Named Buffer Storage ( gp Named Buffer Storage , ( C . GLuint ) ( buffer ) , ( C . GLsizeiptr ) ( size ) , data , ( C . GLbitfield ) ( flags ) ) } 
func Named Buffer Storage External EXT ( buffer uint 3 2 , offset int , size int , client Buffer unsafe . Pointer , flags uint 3 2 ) { C . glow Named Buffer Storage External EXT ( gp Named Buffer Storage External EXT , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , ( C . GLegl Client Buffer EXT ) ( client Buffer ) , ( C . GLbitfield ) ( flags ) ) } 
func Named Buffer Sub Data ( buffer uint 3 2 , offset int , size int , data unsafe . Pointer ) { C . glow Named Buffer Sub Data ( gp Named Buffer Sub Data , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) , data ) } 
func Named Framebuffer Draw Buffer ( framebuffer uint 3 2 , buf uint 3 2 ) { C . glow Named Framebuffer Draw Buffer ( gp Named Framebuffer Draw Buffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( buf ) ) } 
func Named Framebuffer Draw Buffers ( framebuffer uint 3 2 , n int 3 2 , bufs * uint 3 2 ) { C . glow Named Framebuffer Draw Buffers ( gp Named Framebuffer Draw Buffers , ( C . GLuint ) ( framebuffer ) , ( C . GLsizei ) ( n ) , ( * C . GLenum ) ( unsafe . Pointer ( bufs ) ) ) } 
func Named Framebuffer Parameteri ( framebuffer uint 3 2 , pname uint 3 2 , param int 3 2 ) { C . glow Named Framebuffer Parameteri ( gp Named Framebuffer Parameteri , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func Named Framebuffer Read Buffer ( framebuffer uint 3 2 , src uint 3 2 ) { C . glow Named Framebuffer Read Buffer ( gp Named Framebuffer Read Buffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( src ) ) } 
func Named Framebuffer Renderbuffer ( framebuffer uint 3 2 , attachment uint 3 2 , renderbuffertarget uint 3 2 , renderbuffer uint 3 2 ) { C . glow Named Framebuffer Renderbuffer ( gp Named Framebuffer Renderbuffer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLenum ) ( renderbuffertarget ) , ( C . GLuint ) ( renderbuffer ) ) } 
func Named Framebuffer Texture Layer ( framebuffer uint 3 2 , attachment uint 3 2 , texture uint 3 2 , level int 3 2 , layer int 3 2 ) { C . glow Named Framebuffer Texture Layer ( gp Named Framebuffer Texture Layer , ( C . GLuint ) ( framebuffer ) , ( C . GLenum ) ( attachment ) , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( layer ) ) } 
func Named Renderbuffer Storage ( renderbuffer uint 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Named Renderbuffer Storage ( gp Named Renderbuffer Storage , ( C . GLuint ) ( renderbuffer ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Named Renderbuffer Storage Multisample ( renderbuffer uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Named Renderbuffer Storage Multisample ( gp Named Renderbuffer Storage Multisample , ( C . GLuint ) ( renderbuffer ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func New List ( list uint 3 2 , mode uint 3 2 ) { C . glow New List ( gp New List , ( C . GLuint ) ( list ) , ( C . GLenum ) ( mode ) ) } 
func Normal Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Normal Pointer ( gp Normal Pointer , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Object Label ( identifier uint 3 2 , name uint 3 2 , length int 3 2 , label * uint 8 ) { C . glow Object Label ( gp Object Label , ( C . GLenum ) ( identifier ) , ( C . GLuint ) ( name ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func Object Ptr Label ( ptr unsafe . Pointer , length int 3 2 , label * uint 8 ) { C . glow Object Ptr Label ( gp Object Ptr Label , ptr , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( label ) ) ) } 
func Ortho ( left float 6 4 , right float 6 4 , bottom float 6 4 , top float 6 4 , z Near float 6 4 , z Far float 6 4 ) { C . glow Ortho ( gp Ortho , ( C . GLdouble ) ( left ) , ( C . GLdouble ) ( right ) , ( C . GLdouble ) ( bottom ) , ( C . GLdouble ) ( top ) , ( C . GLdouble ) ( z Near ) , ( C . GLdouble ) ( z Far ) ) } 
func Patch Parameteri ( pname uint 3 2 , value int 3 2 ) { C . glow Patch Parameteri ( gp Patch Parameteri , ( C . GLenum ) ( pname ) , ( C . GLint ) ( value ) ) } 
func Pixel Storei ( pname uint 3 2 , param int 3 2 ) { C . glow Pixel Storei ( gp Pixel Storei , ( C . GLenum ) ( pname ) , ( C . GLint ) ( param ) ) } 
func Pixel Zoom ( xfactor float 3 2 , yfactor float 3 2 ) { C . glow Pixel Zoom ( gp Pixel Zoom , ( C . GLfloat ) ( xfactor ) , ( C . GLfloat ) ( yfactor ) ) } 
func Polygon Mode ( face uint 3 2 , mode uint 3 2 ) { C . glow Polygon Mode ( gp Polygon Mode , ( C . GLenum ) ( face ) , ( C . GLenum ) ( mode ) ) } 
func Polygon Offset ( factor float 3 2 , units float 3 2 ) { C . glow Polygon Offset ( gp Polygon Offset , ( C . GLfloat ) ( factor ) , ( C . GLfloat ) ( units ) ) } 
func Polygon Stipple ( mask * uint 8 ) { C . glow Polygon Stipple ( gp Polygon Stipple , ( * C . GLubyte ) ( unsafe . Pointer ( mask ) ) ) } 
func Prioritize Textures ( n int 3 2 , textures * uint 3 2 , priorities * float 3 2 ) { C . glow Prioritize Textures ( gp Prioritize Textures , ( C . GLsizei ) ( n ) , ( * C . GLuint ) ( unsafe . Pointer ( textures ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( priorities ) ) ) } 
func Program Binary ( program uint 3 2 , binary Format uint 3 2 , binary unsafe . Pointer , length int 3 2 ) { C . glow Program Binary ( gp Program Binary , ( C . GLuint ) ( program ) , ( C . GLenum ) ( binary Format ) , binary , ( C . GLsizei ) ( length ) ) } 
func Program Parameteri ( program uint 3 2 , pname uint 3 2 , value int 3 2 ) { C . glow Program Parameteri ( gp Program Parameteri , ( C . GLuint ) ( program ) , ( C . GLenum ) ( pname ) , ( C . GLint ) ( value ) ) } 
func Program Uniform 1f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 ) { C . glow Program Uniform 1f ( gp Program Uniform 1f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) ) } 
func Program Uniform 1fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Program Uniform 1fv ( gp Program Uniform 1fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 1i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 ) { C . glow Program Uniform 1i ( gp Program Uniform 1i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) ) } 
func Program Uniform 1iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Program Uniform 1iv ( gp Program Uniform 1iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 1ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 ) { C . glow Program Uniform 1ui ( gp Program Uniform 1ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v 0 ) ) } 
func Program Uniform 1uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { C . glow Program Uniform 1uiv ( gp Program Uniform 1uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 2f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 ) { C . glow Program Uniform 2f ( gp Program Uniform 2f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) ) } 
func Program Uniform 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Program Uniform 2fv ( gp Program Uniform 2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 2i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 ) { C . glow Program Uniform 2i ( gp Program Uniform 2i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) ) } 
func Program Uniform 2iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Program Uniform 2iv ( gp Program Uniform 2iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 2ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 ) { C . glow Program Uniform 2ui ( gp Program Uniform 2ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v 0 ) , ( C . GLuint ) ( v 1 ) ) } 
func Program Uniform 2uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { C . glow Program Uniform 2uiv ( gp Program Uniform 2uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 3f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 ) { C . glow Program Uniform 3f ( gp Program Uniform 3f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) , ( C . GLfloat ) ( v 2 ) ) } 
func Program Uniform 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Program Uniform 3fv ( gp Program Uniform 3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 3i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 ) { C . glow Program Uniform 3i ( gp Program Uniform 3i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) , ( C . GLint ) ( v 2 ) ) } 
func Program Uniform 3iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Program Uniform 3iv ( gp Program Uniform 3iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 3ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 , v 2 uint 3 2 ) { C . glow Program Uniform 3ui ( gp Program Uniform 3ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v 0 ) , ( C . GLuint ) ( v 1 ) , ( C . GLuint ) ( v 2 ) ) } 
func Program Uniform 3uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { C . glow Program Uniform 3uiv ( gp Program Uniform 3uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 4f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 , v 3 float 3 2 ) { C . glow Program Uniform 4f ( gp Program Uniform 4f , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) , ( C . GLfloat ) ( v 2 ) , ( C . GLfloat ) ( v 3 ) ) } 
func Program Uniform 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Program Uniform 4fv ( gp Program Uniform 4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 4i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 , v 3 int 3 2 ) { C . glow Program Uniform 4i ( gp Program Uniform 4i , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) , ( C . GLint ) ( v 2 ) , ( C . GLint ) ( v 3 ) ) } 
func Program Uniform 4iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Program Uniform 4iv ( gp Program Uniform 4iv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform 4ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 , v 2 uint 3 2 , v 3 uint 3 2 ) { C . glow Program Uniform 4ui ( gp Program Uniform 4ui , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLuint ) ( v 0 ) , ( C . GLuint ) ( v 1 ) , ( C . GLuint ) ( v 2 ) , ( C . GLuint ) ( v 3 ) ) } 
func Program Uniform 4uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { C . glow Program Uniform 4uiv ( gp Program Uniform 4uiv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 2fv ( gp Program Uniform Matrix 2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 2x 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 2x 3fv ( gp Program Uniform Matrix 2x 3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 2x 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 2x 4fv ( gp Program Uniform Matrix 2x 4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 3fv ( gp Program Uniform Matrix 3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 3x 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 3x 2fv ( gp Program Uniform Matrix 3x 2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 3x 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 3x 4fv ( gp Program Uniform Matrix 3x 4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 4fv ( gp Program Uniform Matrix 4fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 4x 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 4x 2fv ( gp Program Uniform Matrix 4x 2fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Program Uniform Matrix 4x 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Program Uniform Matrix 4x 3fv ( gp Program Uniform Matrix 4x 3fv , ( C . GLuint ) ( program ) , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Push Debug Group ( source uint 3 2 , id uint 3 2 , length int 3 2 , message * uint 8 ) { C . glow Push Debug Group ( gp Push Debug Group , ( C . GLenum ) ( source ) , ( C . GLuint ) ( id ) , ( C . GLsizei ) ( length ) , ( * C . GLchar ) ( unsafe . Pointer ( message ) ) ) } 
func Query Counter ( id uint 3 2 , target uint 3 2 ) { C . glow Query Counter ( gp Query Counter , ( C . GLuint ) ( id ) , ( C . GLenum ) ( target ) ) } 
func Query Matrixx OES ( mantissa * int 3 2 , exponent * int 3 2 ) uint 3 2 { ret : = C . glow Query Matrixx OES ( gp Query Matrixx OES , ( * C . GLfixed ) ( unsafe . Pointer ( mantissa ) ) , ( * C . GLint ) ( unsafe . Pointer ( exponent ) ) ) return ( uint 3 2 ) ( ret ) } 
func Read Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Read Pixels ( gp Read Pixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Readn Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , data unsafe . Pointer ) { C . glow Readn Pixels ( gp Readn Pixels , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( buf Size ) , data ) } 
func Render Mode ( mode uint 3 2 ) int 3 2 { ret : = C . glow Render Mode ( gp Render Mode , ( C . GLenum ) ( mode ) ) return ( int 3 2 ) ( ret ) } 
func Renderbuffer Storage ( target uint 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Renderbuffer Storage ( gp Renderbuffer Storage , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Renderbuffer Storage Multisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Renderbuffer Storage Multisample ( gp Renderbuffer Storage Multisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Sample Coverage ( value float 3 2 , invert bool ) { C . glow Sample Coverage ( gp Sample Coverage , ( C . GLfloat ) ( value ) , ( C . GLboolean ) ( bool To Int ( invert ) ) ) } 
func Sample Maski ( mask Number uint 3 2 , mask uint 3 2 ) { C . glow Sample Maski ( gp Sample Maski , ( C . GLuint ) ( mask Number ) , ( C . GLbitfield ) ( mask ) ) } 
func Scissor ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Scissor ( gp Scissor , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Scissor Indexed ( index uint 3 2 , left int 3 2 , bottom int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Scissor Indexed ( gp Scissor Indexed , ( C . GLuint ) ( index ) , ( C . GLint ) ( left ) , ( C . GLint ) ( bottom ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Secondary Color Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Secondary Color Pointer ( gp Secondary Color Pointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Select Buffer ( size int 3 2 , buffer * uint 3 2 ) { C . glow Select Buffer ( gp Select Buffer , ( C . GLsizei ) ( size ) , ( * C . GLuint ) ( unsafe . Pointer ( buffer ) ) ) } 
func Shader Binary ( count int 3 2 , shaders * uint 3 2 , binaryformat uint 3 2 , binary unsafe . Pointer , length int 3 2 ) { C . glow Shader Binary ( gp Shader Binary , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( shaders ) ) , ( C . GLenum ) ( binaryformat ) , binary , ( C . GLsizei ) ( length ) ) } 
func Shader Source ( shader uint 3 2 , count int 3 2 , xstring * * uint 8 , length * int 3 2 ) { C . glow Shader Source ( gp Shader Source , ( C . GLuint ) ( shader ) , ( C . GLsizei ) ( count ) , ( * * C . GLchar ) ( unsafe . Pointer ( xstring ) ) , ( * C . GLint ) ( unsafe . Pointer ( length ) ) ) } 
func Shader Storage Block Binding ( program uint 3 2 , storage Block Index uint 3 2 , storage Block Binding uint 3 2 ) { C . glow Shader Storage Block Binding ( gp Shader Storage Block Binding , ( C . GLuint ) ( program ) , ( C . GLuint ) ( storage Block Index ) , ( C . GLuint ) ( storage Block Binding ) ) } 
func Stencil Func ( xfunc uint 3 2 , ref int 3 2 , mask uint 3 2 ) { C . glow Stencil Func ( gp Stencil Func , ( C . GLenum ) ( xfunc ) , ( C . GLint ) ( ref ) , ( C . GLuint ) ( mask ) ) } 
func Stencil Func Separate ( face uint 3 2 , xfunc uint 3 2 , ref int 3 2 , mask uint 3 2 ) { C . glow Stencil Func Separate ( gp Stencil Func Separate , ( C . GLenum ) ( face ) , ( C . GLenum ) ( xfunc ) , ( C . GLint ) ( ref ) , ( C . GLuint ) ( mask ) ) } 
func Stencil Mask Separate ( face uint 3 2 , mask uint 3 2 ) { C . glow Stencil Mask Separate ( gp Stencil Mask Separate , ( C . GLenum ) ( face ) , ( C . GLuint ) ( mask ) ) } 
func Stencil Op ( fail uint 3 2 , zfail uint 3 2 , zpass uint 3 2 ) { C . glow Stencil Op ( gp Stencil Op , ( C . GLenum ) ( fail ) , ( C . GLenum ) ( zfail ) , ( C . GLenum ) ( zpass ) ) } 
func Stencil Op Separate ( face uint 3 2 , sfail uint 3 2 , dpfail uint 3 2 , dppass uint 3 2 ) { C . glow Stencil Op Separate ( gp Stencil Op Separate , ( C . GLenum ) ( face ) , ( C . GLenum ) ( sfail ) , ( C . GLenum ) ( dpfail ) , ( C . GLenum ) ( dppass ) ) } 
func Tex Buffer Range ( target uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 , offset int , size int ) { C . glow Tex Buffer Range ( gp Tex Buffer Range , ( C . GLenum ) ( target ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Tex Coord Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Tex Coord Pointer ( gp Tex Coord Pointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat int 3 2 , width int 3 2 , border int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Image 1D ( gp Tex Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat int 3 2 , width int 3 2 , height int 3 2 , border int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Image 2D ( gp Tex Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Tex Image 2DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { C . glow Tex Image 2DMultisample ( gp Tex Image 2DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Tex Image 3D ( target uint 3 2 , level int 3 2 , internalformat int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , border int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Image 3D ( gp Tex Image 3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLint ) ( border ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Tex Image 3DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { C . glow Tex Image 3DMultisample ( gp Tex Image 3DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Tex Storage 1D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 ) { C . glow Tex Storage 1D ( gp Tex Storage 1D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) ) } 
func Tex Storage 2D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Tex Storage 2D ( gp Tex Storage 2D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Tex Storage 2DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { C . glow Tex Storage 2DMultisample ( gp Tex Storage 2DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Tex Storage 3D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { C . glow Tex Storage 3D ( gp Tex Storage 3D , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func Tex Storage 3DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { C . glow Tex Storage 3DMultisample ( gp Tex Storage 3DMultisample , ( C . GLenum ) ( target ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Sub Image 1D ( gp Tex Sub Image 1D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Tex Sub Image 2D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Sub Image 2D ( gp Tex Sub Image 2D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Tex Sub Image 3D ( gp Tex Sub Image 3D , ( C . GLenum ) ( target ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Texture Buffer ( texture uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 ) { C . glow Texture Buffer ( gp Texture Buffer , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) ) } 
func Texture Buffer Range ( texture uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 , offset int , size int ) { C . glow Texture Buffer Range ( gp Texture Buffer Range , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Texture Storage 1D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 ) { C . glow Texture Storage 1D ( gp Texture Storage 1D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) ) } 
func Texture Storage 2D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { C . glow Texture Storage 2D ( gp Texture Storage 2D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Texture Storage 2DMultisample ( texture uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { C . glow Texture Storage 2DMultisample ( gp Texture Storage 2DMultisample , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Texture Storage 3D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { C . glow Texture Storage 3D ( gp Texture Storage 3D , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( levels ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) ) } 
func Texture Storage 3DMultisample ( texture uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { C . glow Texture Storage 3DMultisample ( gp Texture Storage 3DMultisample , ( C . GLuint ) ( texture ) , ( C . GLsizei ) ( samples ) , ( C . GLenum ) ( internalformat ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLboolean ) ( bool To Int ( fixedsamplelocations ) ) ) } 
func Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Texture Sub Image 1D ( gp Texture Sub Image 1D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLsizei ) ( width ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Texture Sub Image 2D ( gp Texture Sub Image 2D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { C . glow Texture Sub Image 3D ( gp Texture Sub Image 3D , ( C . GLuint ) ( texture ) , ( C . GLint ) ( level ) , ( C . GLint ) ( xoffset ) , ( C . GLint ) ( yoffset ) , ( C . GLint ) ( zoffset ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) , ( C . GLsizei ) ( depth ) , ( C . GLenum ) ( format ) , ( C . GLenum ) ( xtype ) , pixels ) } 
func Texture View ( texture uint 3 2 , target uint 3 2 , origtexture uint 3 2 , internalformat uint 3 2 , minlevel uint 3 2 , numlevels uint 3 2 , minlayer uint 3 2 , numlayers uint 3 2 ) { C . glow Texture View ( gp Texture View , ( C . GLuint ) ( texture ) , ( C . GLenum ) ( target ) , ( C . GLuint ) ( origtexture ) , ( C . GLenum ) ( internalformat ) , ( C . GLuint ) ( minlevel ) , ( C . GLuint ) ( numlevels ) , ( C . GLuint ) ( minlayer ) , ( C . GLuint ) ( numlayers ) ) } 
func Transform Feedback Buffer Base ( xfb uint 3 2 , index uint 3 2 , buffer uint 3 2 ) { C . glow Transform Feedback Buffer Base ( gp Transform Feedback Buffer Base , ( C . GLuint ) ( xfb ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) ) } 
func Transform Feedback Buffer Range ( xfb uint 3 2 , index uint 3 2 , buffer uint 3 2 , offset int , size int ) { C . glow Transform Feedback Buffer Range ( gp Transform Feedback Buffer Range , ( C . GLuint ) ( xfb ) , ( C . GLuint ) ( index ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizeiptr ) ( size ) ) } 
func Uniform 1f ( location int 3 2 , v 0 float 3 2 ) { C . glow Uniform 1f ( gp Uniform 1f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) ) } 
func Uniform 1fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Uniform 1fv ( gp Uniform 1fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 1i ( location int 3 2 , v 0 int 3 2 ) { C . glow Uniform 1i ( gp Uniform 1i , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) ) } 
func Uniform 1iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Uniform 1iv ( gp Uniform 1iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 2f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 ) { C . glow Uniform 2f ( gp Uniform 2f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) ) } 
func Uniform 2fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Uniform 2fv ( gp Uniform 2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 2i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 ) { C . glow Uniform 2i ( gp Uniform 2i , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) ) } 
func Uniform 2iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Uniform 2iv ( gp Uniform 2iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 3f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 ) { C . glow Uniform 3f ( gp Uniform 3f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) , ( C . GLfloat ) ( v 2 ) ) } 
func Uniform 3fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Uniform 3fv ( gp Uniform 3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 3i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 ) { C . glow Uniform 3i ( gp Uniform 3i , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) , ( C . GLint ) ( v 2 ) ) } 
func Uniform 3iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Uniform 3iv ( gp Uniform 3iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 4f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 , v 3 float 3 2 ) { C . glow Uniform 4f ( gp Uniform 4f , ( C . GLint ) ( location ) , ( C . GLfloat ) ( v 0 ) , ( C . GLfloat ) ( v 1 ) , ( C . GLfloat ) ( v 2 ) , ( C . GLfloat ) ( v 3 ) ) } 
func Uniform 4fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { C . glow Uniform 4fv ( gp Uniform 4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform 4i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 , v 3 int 3 2 ) { C . glow Uniform 4i ( gp Uniform 4i , ( C . GLint ) ( location ) , ( C . GLint ) ( v 0 ) , ( C . GLint ) ( v 1 ) , ( C . GLint ) ( v 2 ) , ( C . GLint ) ( v 3 ) ) } 
func Uniform 4iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { C . glow Uniform 4iv ( gp Uniform 4iv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( * C . GLint ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Block Binding ( program uint 3 2 , uniform Block Index uint 3 2 , uniform Block Binding uint 3 2 ) { C . glow Uniform Block Binding ( gp Uniform Block Binding , ( C . GLuint ) ( program ) , ( C . GLuint ) ( uniform Block Index ) , ( C . GLuint ) ( uniform Block Binding ) ) } 
func Uniform Matrix 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 2fv ( gp Uniform Matrix 2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 2x 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 2x 3fv ( gp Uniform Matrix 2x 3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 2x 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 2x 4fv ( gp Uniform Matrix 2x 4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 3fv ( gp Uniform Matrix 3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 3x 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 3x 2fv ( gp Uniform Matrix 3x 2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 3x 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 3x 4fv ( gp Uniform Matrix 3x 4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 4fv ( gp Uniform Matrix 4fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 4x 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 4x 2fv ( gp Uniform Matrix 4x 2fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Uniform Matrix 4x 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { C . glow Uniform Matrix 4x 3fv ( gp Uniform Matrix 4x 3fv , ( C . GLint ) ( location ) , ( C . GLsizei ) ( count ) , ( C . GLboolean ) ( bool To Int ( transpose ) ) , ( * C . GLfloat ) ( unsafe . Pointer ( value ) ) ) } 
func Unmap Buffer ( target uint 3 2 ) bool { ret : = C . glow Unmap Buffer ( gp Unmap Buffer , ( C . GLenum ) ( target ) ) return ret = = TRUE } 
func Unmap Named Buffer ( buffer uint 3 2 ) bool { ret : = C . glow Unmap Named Buffer ( gp Unmap Named Buffer , ( C . GLuint ) ( buffer ) ) return ret = = TRUE } 
func Use Program Stages ( pipeline uint 3 2 , stages uint 3 2 , program uint 3 2 ) { C . glow Use Program Stages ( gp Use Program Stages , ( C . GLuint ) ( pipeline ) , ( C . GLbitfield ) ( stages ) , ( C . GLuint ) ( program ) ) } 
func Vertex Array Attrib Format ( vaobj uint 3 2 , attribindex uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , relativeoffset uint 3 2 ) { C . glow Vertex Array Attrib Format ( gp Vertex Array Attrib Format , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( attribindex ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( bool To Int ( normalized ) ) , ( C . GLuint ) ( relativeoffset ) ) } 
func Vertex Array Binding Divisor ( vaobj uint 3 2 , bindingindex uint 3 2 , divisor uint 3 2 ) { C . glow Vertex Array Binding Divisor ( gp Vertex Array Binding Divisor , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( divisor ) ) } 
func Vertex Array Element Buffer ( vaobj uint 3 2 , buffer uint 3 2 ) { C . glow Vertex Array Element Buffer ( gp Vertex Array Element Buffer , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( buffer ) ) } 
func Vertex Array Vertex Buffer ( vaobj uint 3 2 , bindingindex uint 3 2 , buffer uint 3 2 , offset int , stride int 3 2 ) { C . glow Vertex Array Vertex Buffer ( gp Vertex Array Vertex Buffer , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( buffer ) , ( C . GLintptr ) ( offset ) , ( C . GLsizei ) ( stride ) ) } 
func Vertex Array Vertex Buffers ( vaobj uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , strides * int 3 2 ) { C . glow Vertex Array Vertex Buffers ( gp Vertex Array Vertex Buffers , ( C . GLuint ) ( vaobj ) , ( C . GLuint ) ( first ) , ( C . GLsizei ) ( count ) , ( * C . GLuint ) ( unsafe . Pointer ( buffers ) ) , ( * C . GLintptr ) ( unsafe . Pointer ( offsets ) ) , ( * C . GLsizei ) ( unsafe . Pointer ( strides ) ) ) } 
func Vertex Attrib Binding ( attribindex uint 3 2 , bindingindex uint 3 2 ) { C . glow Vertex Attrib Binding ( gp Vertex Attrib Binding , ( C . GLuint ) ( attribindex ) , ( C . GLuint ) ( bindingindex ) ) } 
func Vertex Attrib Format ( attribindex uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , relativeoffset uint 3 2 ) { C . glow Vertex Attrib Format ( gp Vertex Attrib Format , ( C . GLuint ) ( attribindex ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( bool To Int ( normalized ) ) , ( C . GLuint ) ( relativeoffset ) ) } 
func Vertex Attrib Pointer ( index uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Vertex Attrib Pointer ( gp Vertex Attrib Pointer , ( C . GLuint ) ( index ) , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLboolean ) ( bool To Int ( normalized ) ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Vertex Binding Divisor ( bindingindex uint 3 2 , divisor uint 3 2 ) { C . glow Vertex Binding Divisor ( gp Vertex Binding Divisor , ( C . GLuint ) ( bindingindex ) , ( C . GLuint ) ( divisor ) ) } 
func Vertex Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { C . glow Vertex Pointer ( gp Vertex Pointer , ( C . GLint ) ( size ) , ( C . GLenum ) ( xtype ) , ( C . GLsizei ) ( stride ) , pointer ) } 
func Viewport ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { C . glow Viewport ( gp Viewport , ( C . GLint ) ( x ) , ( C . GLint ) ( y ) , ( C . GLsizei ) ( width ) , ( C . GLsizei ) ( height ) ) } 
func Wait Sync ( sync uintptr , flags uint 3 2 , timeout uint 6 4 ) { C . glow Wait Sync ( gp Wait Sync , ( C . GLsync ) ( sync ) , ( C . GLbitfield ) ( flags ) , ( C . GLuint 6 4 ) ( timeout ) ) } 
func ( i * Image ) Quad Vertices ( sx 0 , sy 0 , sx 1 , sy 1 int , a , b , c , d , tx , ty float 3 2 , cr , cg , cb , ca float 3 2 ) [ ] float 3 2 { if i . backend = = nil { i . allocate ( true ) } ox , oy , _ , _ : = i . region ( ) return i . backend . restorable . Quad Vertices ( sx 0 + ox , sy 0 + oy , sx 1 + ox , sy 1 + oy , a , b , c , d , tx , ty , cr , cg , cb , ca ) } 
func ( i * Image ) Put Vertex ( dest [ ] float 3 2 , dx , dy , sx , sy float 3 2 , bx 0 , by 0 , bx 1 , by 1 float 3 2 , cr , cg , cb , ca float 3 2 ) { if i . backend = = nil { i . allocate ( true ) } ox , oy , _ , _ : = i . region ( ) oxf , oyf : = float 3 2 ( ox ) , float 3 2 ( oy ) i . backend . restorable . Put Vertex ( dest , dx , dy , sx + oxf , sy + oyf , bx 0 + oxf , by 0 + oyf , bx 1 + oxf , by 1 + oyf , cr , cg , cb , ca ) } 
func ( i * Image ) Fill ( r , g , b , a uint 8 ) { backends M . Lock ( ) if i . disposed { panic ( " " ) } i . ensure Not Shared ( ) i . backend . restorable . Fill ( r , g , b , a ) backends M . Unlock ( ) } 
func scale Updater ( ) { for { s : = getscale ( 0 , 0 ) atomic . Store Uint 6 4 ( & cached Scale , math . Float 6 4bits ( s ) ) time . Sleep ( cache Update Wait ) } } 
func Draw ( dst * ebiten . Image , text string , face font . Face , x , y int , clr color . Color ) { text M . Lock ( ) fx : = fixed . I ( x ) prev R : = rune ( - 1 ) runes : = [ ] rune ( text ) glyph Imgs : = get Glyph Images ( face , runes ) colorm : = color To Color M ( clr ) for i , r : = range runes { if prev R > = 0 { fx + = face . Kern ( prev R , r ) } draw Glyph ( dst , face , r , glyph Imgs [ i ] , fx , fixed . I ( y ) , colorm ) fx + = glyph Advance ( face , r ) prev R = r } text M . Unlock ( ) } 
func Run ( f func ( * Image ) error , width , height int , scale float 6 4 , title string ) error { f = ( & image Dumper { f : f } ) . update c : = new UIContext ( f ) the UIContext . Store ( c ) atomic . Store Int 3 2 ( & is Running , 1 ) } if err : = ui Driver ( ) . Run ( width , height , scale , title , c , graphics Driver ( ) ) ; err ! = nil { if err = = driver . Regular Termination { return nil } return err } return nil } 
func Run Without Main Loop ( f func ( * Image ) error , width , height int , scale float 6 4 , title string ) < - chan error { f = ( & image Dumper { f : f } ) . update c : = new UIContext ( f ) the UIContext . Store ( c ) atomic . Store Int 3 2 ( & is Running , 1 ) return ui Driver ( ) . Run Without Main Loop ( width , height , scale , title , c , graphics Driver ( ) ) } 
func Set Screen Size ( width , height int ) { if width < = 0 | | height < = 0 { panic ( " " ) } ui Driver ( ) . Set Screen Size ( width , height ) } 
func Set Max TPS ( tps int ) { if tps < 0 & & tps ! = Uncapped TPS { panic ( " " ) } atomic . Store Int 3 2 ( & current Max TPS , int 3 2 ( tps ) ) } 
func New Board ( size int ) ( * Board , error ) { b : = & Board { size : size , tiles : map [ * Tile ] struct { } { } , } for i : = 0 ; i < 2 ; i + + { if err : = add Random Tile ( b . tiles , b . size ) ; err ! = nil { return nil , err } } return b , nil } 
func ( b * Board ) Update ( input * Input ) error { for t : = range b . tiles { if err : = t . Update ( ) ; err ! = nil { return err } } if 0 < len ( b . tasks ) { t : = b . tasks [ 0 ] if err : = t ( ) ; err = = task Terminated { b . tasks = b . tasks [ 1 : ] } else if err ! = nil { return err } return nil } if dir , ok : = input . Dir ( ) ; ok { if err : = b . Move ( dir ) ; err ! = nil { return err } } return nil } 
func ( b * Board ) Move ( dir Dir ) error { for t : = range b . tiles { t . stop Animation ( ) } if ! Move Tiles ( b . tiles , b . size , dir ) { return nil } b . tasks = append ( b . tasks , func ( ) error { for t : = range b . tiles { if t . Is Moving ( ) { return nil } } return task Terminated } ) b . tasks = append ( b . tasks , func ( ) error { next Tiles : = map [ * Tile ] struct { } { } for t : = range b . tiles { if t . Is Moving ( ) { panic ( " " ) } if t . next . value ! = 0 { panic ( " " ) } if t . current . value = = 0 { continue } next Tiles [ t ] = struct { } { } } b . tiles = next Tiles if err : = add Random Tile ( b . tiles , b . size ) ; err ! = nil { return err } return task Terminated } ) return nil } 
func ( b * Board ) Size ( ) ( int , int ) { x : = b . size * tile Size + ( b . size + 1 ) * tile Margin y : = x return x , y } 
func ( b * Board ) Draw ( board Image * ebiten . Image ) { board Image . Fill ( frame Color ) for j : = 0 ; j < b . size ; j + + { for i : = 0 ; i < b . size ; i + + { v : = 0 op : = & ebiten . Draw Image Options { } x : = i * tile Size + ( i + 1 ) * tile Margin y : = j * tile Size + ( j + 1 ) * tile Margin op . Geo M . Translate ( float 6 4 ( x ) , float 6 4 ( y ) ) r , g , b , a : = color To Scale ( tile Background Color ( v ) ) op . Color M . Scale ( r , g , b , a ) board Image . Draw Image ( tile Image , op ) } } animating Tiles : = map [ * Tile ] struct { } { } non Animating Tiles : = map [ * Tile ] struct { } { } for t : = range b . tiles { if t . Is Moving ( ) { animating Tiles [ t ] = struct { } { } } else { non Animating Tiles [ t ] = struct { } { } } } for t : = range non Animating Tiles { t . Draw ( board Image ) } for t : = range animating Tiles { t . Draw ( board Image ) } } 
func Accum ( op uint 3 2 , value float 3 2 ) { syscall . Syscall ( gp Accum , 2 , uintptr ( op ) , uintptr ( math . Float 3 2bits ( value ) ) , 0 ) } 
func Active Shader Program ( pipeline uint 3 2 , program uint 3 2 ) { syscall . Syscall ( gp Active Shader Program , 2 , uintptr ( pipeline ) , uintptr ( program ) , 0 ) } 
func Alpha Func ( xfunc uint 3 2 , ref float 3 2 ) { syscall . Syscall ( gp Alpha Func , 2 , uintptr ( xfunc ) , uintptr ( math . Float 3 2bits ( ref ) ) , 0 ) } 
func Are Textures Resident ( n int 3 2 , textures * uint 3 2 , residences * bool ) bool { ret , _ , _ : = syscall . Syscall ( gp Are Textures Resident , 3 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , uintptr ( unsafe . Pointer ( residences ) ) ) return ret ! = 0 } 
func Attach Shader ( program uint 3 2 , shader uint 3 2 ) { syscall . Syscall ( gp Attach Shader , 2 , uintptr ( program ) , uintptr ( shader ) , 0 ) } 
func Begin Query ( target uint 3 2 , id uint 3 2 ) { syscall . Syscall ( gp Begin Query , 2 , uintptr ( target ) , uintptr ( id ) , 0 ) } 
func Bind Attrib Location ( program uint 3 2 , index uint 3 2 , name * uint 8 ) { syscall . Syscall ( gp Bind Attrib Location , 3 , uintptr ( program ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func Bind Buffer ( target uint 3 2 , buffer uint 3 2 ) { syscall . Syscall ( gp Bind Buffer , 2 , uintptr ( target ) , uintptr ( buffer ) , 0 ) } 
func Bind Buffer Base ( target uint 3 2 , index uint 3 2 , buffer uint 3 2 ) { syscall . Syscall ( gp Bind Buffer Base , 3 , uintptr ( target ) , uintptr ( index ) , uintptr ( buffer ) ) } 
func Bind Buffer Range ( target uint 3 2 , index uint 3 2 , buffer uint 3 2 , offset int , size int ) { syscall . Syscall 6 ( gp Bind Buffer Range , 5 , uintptr ( target ) , uintptr ( index ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func Bind Buffers Base ( target uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 ) { syscall . Syscall 6 ( gp Bind Buffers Base , 4 , uintptr ( target ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 , 0 ) } 
func Bind Buffers Range ( target uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , sizes * int ) { syscall . Syscall 6 ( gp Bind Buffers Range , 6 , uintptr ( target ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( sizes ) ) ) } 
func Bind Frag Data Location Indexed ( program uint 3 2 , color Number uint 3 2 , index uint 3 2 , name * uint 8 ) { syscall . Syscall 6 ( gp Bind Frag Data Location Indexed , 4 , uintptr ( program ) , uintptr ( color Number ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func Bind Framebuffer ( target uint 3 2 , framebuffer uint 3 2 ) { syscall . Syscall ( gp Bind Framebuffer , 2 , uintptr ( target ) , uintptr ( framebuffer ) , 0 ) } 
func Bind Image Texture ( unit uint 3 2 , texture uint 3 2 , level int 3 2 , layered bool , layer int 3 2 , access uint 3 2 , format uint 3 2 ) { syscall . Syscall 9 ( gp Bind Image Texture , 7 , uintptr ( unit ) , uintptr ( texture ) , uintptr ( level ) , bool To Uintptr ( layered ) , uintptr ( layer ) , uintptr ( access ) , uintptr ( format ) , 0 , 0 ) } 
func Bind Image Textures ( first uint 3 2 , count int 3 2 , textures * uint 3 2 ) { syscall . Syscall ( gp Bind Image Textures , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func Bind Renderbuffer ( target uint 3 2 , renderbuffer uint 3 2 ) { syscall . Syscall ( gp Bind Renderbuffer , 2 , uintptr ( target ) , uintptr ( renderbuffer ) , 0 ) } 
func Bind Sampler ( unit uint 3 2 , sampler uint 3 2 ) { syscall . Syscall ( gp Bind Sampler , 2 , uintptr ( unit ) , uintptr ( sampler ) , 0 ) } 
func Bind Samplers ( first uint 3 2 , count int 3 2 , samplers * uint 3 2 ) { syscall . Syscall ( gp Bind Samplers , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) ) } 
func Bind Texture ( target uint 3 2 , texture uint 3 2 ) { syscall . Syscall ( gp Bind Texture , 2 , uintptr ( target ) , uintptr ( texture ) , 0 ) } 
func Bind Texture Unit ( unit uint 3 2 , texture uint 3 2 ) { syscall . Syscall ( gp Bind Texture Unit , 2 , uintptr ( unit ) , uintptr ( texture ) , 0 ) } 
func Bind Textures ( first uint 3 2 , count int 3 2 , textures * uint 3 2 ) { syscall . Syscall ( gp Bind Textures , 3 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func Bind Transform Feedback ( target uint 3 2 , id uint 3 2 ) { syscall . Syscall ( gp Bind Transform Feedback , 2 , uintptr ( target ) , uintptr ( id ) , 0 ) } 
func Bind Vertex Buffer ( bindingindex uint 3 2 , buffer uint 3 2 , offset int , stride int 3 2 ) { syscall . Syscall 6 ( gp Bind Vertex Buffer , 4 , uintptr ( bindingindex ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( stride ) , 0 , 0 ) } 
func Bind Vertex Buffers ( first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , strides * int 3 2 ) { syscall . Syscall 6 ( gp Bind Vertex Buffers , 5 , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( strides ) ) , 0 ) } 
func Bitmap ( width int 3 2 , height int 3 2 , xorig float 3 2 , yorig float 3 2 , xmove float 3 2 , ymove float 3 2 , bitmap * uint 8 ) { syscall . Syscall 9 ( gp Bitmap , 7 , uintptr ( width ) , uintptr ( height ) , uintptr ( math . Float 3 2bits ( xorig ) ) , uintptr ( math . Float 3 2bits ( yorig ) ) , uintptr ( math . Float 3 2bits ( xmove ) ) , uintptr ( math . Float 3 2bits ( ymove ) ) , uintptr ( unsafe . Pointer ( bitmap ) ) , 0 , 0 ) } 
func Blend Color ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { syscall . Syscall 6 ( gp Blend Color , 4 , uintptr ( math . Float 3 2bits ( red ) ) , uintptr ( math . Float 3 2bits ( green ) ) , uintptr ( math . Float 3 2bits ( blue ) ) , uintptr ( math . Float 3 2bits ( alpha ) ) , 0 , 0 ) } 
func Blend Equation Separate ( mode RGB uint 3 2 , mode Alpha uint 3 2 ) { syscall . Syscall ( gp Blend Equation Separate , 2 , uintptr ( mode RGB ) , uintptr ( mode Alpha ) , 0 ) } 
func Blend Func ( sfactor uint 3 2 , dfactor uint 3 2 ) { syscall . Syscall ( gp Blend Func , 2 , uintptr ( sfactor ) , uintptr ( dfactor ) , 0 ) } 
func Blend Func Separate ( sfactor RGB uint 3 2 , dfactor RGB uint 3 2 , sfactor Alpha uint 3 2 , dfactor Alpha uint 3 2 ) { syscall . Syscall 6 ( gp Blend Func Separate , 4 , uintptr ( sfactor RGB ) , uintptr ( dfactor RGB ) , uintptr ( sfactor Alpha ) , uintptr ( dfactor Alpha ) , 0 , 0 ) } 
func Blit Framebuffer ( src X 0 int 3 2 , src Y 0 int 3 2 , src X 1 int 3 2 , src Y 1 int 3 2 , dst X 0 int 3 2 , dst Y 0 int 3 2 , dst X 1 int 3 2 , dst Y 1 int 3 2 , mask uint 3 2 , filter uint 3 2 ) { syscall . Syscall 1 2 ( gp Blit Framebuffer , 1 0 , uintptr ( src X 0 ) , uintptr ( src Y 0 ) , uintptr ( src X 1 ) , uintptr ( src Y 1 ) , uintptr ( dst X 0 ) , uintptr ( dst Y 0 ) , uintptr ( dst X 1 ) , uintptr ( dst Y 1 ) , uintptr ( mask ) , uintptr ( filter ) , 0 , 0 ) } 
func Blit Named Framebuffer ( read Framebuffer uint 3 2 , draw Framebuffer uint 3 2 , src X 0 int 3 2 , src Y 0 int 3 2 , src X 1 int 3 2 , src Y 1 int 3 2 , dst X 0 int 3 2 , dst Y 0 int 3 2 , dst X 1 int 3 2 , dst Y 1 int 3 2 , mask uint 3 2 , filter uint 3 2 ) { syscall . Syscall 1 2 ( gp Blit Named Framebuffer , 1 2 , uintptr ( read Framebuffer ) , uintptr ( draw Framebuffer ) , uintptr ( src X 0 ) , uintptr ( src Y 0 ) , uintptr ( src X 1 ) , uintptr ( src Y 1 ) , uintptr ( dst X 0 ) , uintptr ( dst Y 0 ) , uintptr ( dst X 1 ) , uintptr ( dst Y 1 ) , uintptr ( mask ) , uintptr ( filter ) ) } 
func Buffer Data ( target uint 3 2 , size int , data unsafe . Pointer , usage uint 3 2 ) { syscall . Syscall 6 ( gp Buffer Data , 4 , uintptr ( target ) , uintptr ( size ) , uintptr ( data ) , uintptr ( usage ) , 0 , 0 ) } 
func Buffer Storage ( target uint 3 2 , size int , data unsafe . Pointer , flags uint 3 2 ) { syscall . Syscall 6 ( gp Buffer Storage , 4 , uintptr ( target ) , uintptr ( size ) , uintptr ( data ) , uintptr ( flags ) , 0 , 0 ) } 
func Buffer Storage External EXT ( target uint 3 2 , offset int , size int , client Buffer unsafe . Pointer , flags uint 3 2 ) { syscall . Syscall 6 ( gp Buffer Storage External EXT , 5 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( client Buffer ) , uintptr ( flags ) , 0 ) } 
func Buffer Sub Data ( target uint 3 2 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Buffer Sub Data , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func Call Lists ( n int 3 2 , xtype uint 3 2 , lists unsafe . Pointer ) { syscall . Syscall ( gp Call Lists , 3 , uintptr ( n ) , uintptr ( xtype ) , uintptr ( lists ) ) } 
func Check Framebuffer Status ( target uint 3 2 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Check Framebuffer Status , 1 , uintptr ( target ) , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Check Named Framebuffer Status ( framebuffer uint 3 2 , target uint 3 2 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Check Named Framebuffer Status , 2 , uintptr ( framebuffer ) , uintptr ( target ) , 0 ) return ( uint 3 2 ) ( ret ) } 
func Clear Accum ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { syscall . Syscall 6 ( gp Clear Accum , 4 , uintptr ( math . Float 3 2bits ( red ) ) , uintptr ( math . Float 3 2bits ( green ) ) , uintptr ( math . Float 3 2bits ( blue ) ) , uintptr ( math . Float 3 2bits ( alpha ) ) , 0 , 0 ) } 
func Clear Buffer Data ( target uint 3 2 , internalformat uint 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Clear Buffer Data , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func Clear Buffer Sub Data ( target uint 3 2 , internalformat uint 3 2 , offset int , size int , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Clear Buffer Sub Data , 7 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 , 0 ) } 
func Clear Color ( red float 3 2 , green float 3 2 , blue float 3 2 , alpha float 3 2 ) { syscall . Syscall 6 ( gp Clear Color , 4 , uintptr ( math . Float 3 2bits ( red ) ) , uintptr ( math . Float 3 2bits ( green ) ) , uintptr ( math . Float 3 2bits ( blue ) ) , uintptr ( math . Float 3 2bits ( alpha ) ) , 0 , 0 ) } 
func Clear Depth ( depth float 6 4 ) { syscall . Syscall ( gp Clear Depth , 1 , uintptr ( math . Float 6 4bits ( depth ) ) , 0 , 0 ) } 
func Clear Depthf ( d float 3 2 ) { syscall . Syscall ( gp Clear Depthf , 1 , uintptr ( math . Float 3 2bits ( d ) ) , 0 , 0 ) } 
func Clear Index ( c float 3 2 ) { syscall . Syscall ( gp Clear Index , 1 , uintptr ( math . Float 3 2bits ( c ) ) , 0 , 0 ) } 
func Clear Named Buffer Data ( buffer uint 3 2 , internalformat uint 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Clear Named Buffer Data , 5 , uintptr ( buffer ) , uintptr ( internalformat ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func Clear Named Buffer Sub Data ( buffer uint 3 2 , internalformat uint 3 2 , offset int , size int , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Clear Named Buffer Sub Data , 7 , uintptr ( buffer ) , uintptr ( internalformat ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 , 0 ) } 
func Clear Tex Image ( texture uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Clear Tex Image , 5 , uintptr ( texture ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func Clear Tex Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , data unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Clear Tex Sub Image , 1 1 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( data ) , 0 ) } 
func Client Wait Sync ( sync uintptr , flags uint 3 2 , timeout uint 6 4 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Client Wait Sync , 3 , uintptr ( sync ) , uintptr ( flags ) , uintptr ( timeout ) ) return ( uint 3 2 ) ( ret ) } 
func Clip Control ( origin uint 3 2 , depth uint 3 2 ) { syscall . Syscall ( gp Clip Control , 2 , uintptr ( origin ) , uintptr ( depth ) , 0 ) } 
func Clip Plane ( plane uint 3 2 , equation * float 6 4 ) { syscall . Syscall ( gp Clip Plane , 2 , uintptr ( plane ) , uintptr ( unsafe . Pointer ( equation ) ) , 0 ) } 
func Color Material ( face uint 3 2 , mode uint 3 2 ) { syscall . Syscall ( gp Color Material , 2 , uintptr ( face ) , uintptr ( mode ) , 0 ) } 
func Color Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall 6 ( gp Color Pointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func Compressed Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Tex Image 1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( border ) , uintptr ( image Size ) , uintptr ( data ) , 0 , 0 ) } 
func Compressed Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Tex Image 2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , uintptr ( image Size ) , uintptr ( data ) , 0 ) } 
func Compressed Tex Image 3D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , border int 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Tex Image 3D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( border ) , uintptr ( image Size ) , uintptr ( data ) ) } 
func Compressed Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Tex Sub Image 1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( image Size ) , uintptr ( data ) , 0 , 0 ) } 
func Compressed Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Compressed Tex Sub Image 3D , 1 1 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( image Size ) , uintptr ( data ) , 0 ) } 
func Compressed Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Texture Sub Image 1D , 7 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( image Size ) , uintptr ( data ) , 0 , 0 ) } 
func Compressed Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Compressed Texture Sub Image 2D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( image Size ) , uintptr ( data ) ) } 
func Compressed Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , image Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Compressed Texture Sub Image 3D , 1 1 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( image Size ) , uintptr ( data ) , 0 ) } 
func Copy Buffer Sub Data ( read Target uint 3 2 , write Target uint 3 2 , read Offset int , write Offset int , size int ) { syscall . Syscall 6 ( gp Copy Buffer Sub Data , 5 , uintptr ( read Target ) , uintptr ( write Target ) , uintptr ( read Offset ) , uintptr ( write Offset ) , uintptr ( size ) , 0 ) } 
func Copy Image Sub Data ( src Name uint 3 2 , src Target uint 3 2 , src Level int 3 2 , src X int 3 2 , src Y int 3 2 , src Z int 3 2 , dst Name uint 3 2 , dst Target uint 3 2 , dst Level int 3 2 , dst X int 3 2 , dst Y int 3 2 , dst Z int 3 2 , src Width int 3 2 , src Height int 3 2 , src Depth int 3 2 ) { syscall . Syscall 1 5 ( gp Copy Image Sub Data , 1 5 , uintptr ( src Name ) , uintptr ( src Target ) , uintptr ( src Level ) , uintptr ( src X ) , uintptr ( src Y ) , uintptr ( src Z ) , uintptr ( dst Name ) , uintptr ( dst Target ) , uintptr ( dst Level ) , uintptr ( dst X ) , uintptr ( dst Y ) , uintptr ( dst Z ) , uintptr ( src Width ) , uintptr ( src Height ) , uintptr ( src Depth ) ) } 
func Copy Named Buffer Sub Data ( read Buffer uint 3 2 , write Buffer uint 3 2 , read Offset int , write Offset int , size int ) { syscall . Syscall 6 ( gp Copy Named Buffer Sub Data , 5 , uintptr ( read Buffer ) , uintptr ( write Buffer ) , uintptr ( read Offset ) , uintptr ( write Offset ) , uintptr ( size ) , 0 ) } 
func Copy Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , xtype uint 3 2 ) { syscall . Syscall 6 ( gp Copy Pixels , 5 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( xtype ) , 0 ) } 
func Copy Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , border int 3 2 ) { syscall . Syscall 9 ( gp Copy Tex Image 1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( border ) , 0 , 0 ) } 
func Copy Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , border int 3 2 ) { syscall . Syscall 9 ( gp Copy Tex Image 2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , 0 ) } 
func Copy Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 ) { syscall . Syscall 6 ( gp Copy Tex Sub Image 1D , 6 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) ) } 
func Copy Tex Sub Image 2D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Copy Tex Sub Image 2D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Copy Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Copy Tex Sub Image 3D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) ) } 
func Copy Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 ) { syscall . Syscall 6 ( gp Copy Texture Sub Image 1D , 6 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) ) } 
func Copy Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Copy Texture Sub Image 2D , 8 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Copy Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Copy Texture Sub Image 3D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) ) } 
func Create Buffers ( n int 3 2 , buffers * uint 3 2 ) { syscall . Syscall ( gp Create Buffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func Create Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { syscall . Syscall ( gp Create Framebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func Create Program ( ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Create Program , 0 , 0 , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Create Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { syscall . Syscall ( gp Create Program Pipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func Create Queries ( target uint 3 2 , n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Create Queries , 3 , uintptr ( target ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) ) } 
func Create Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { syscall . Syscall ( gp Create Renderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func Create Samplers ( n int 3 2 , samplers * uint 3 2 ) { syscall . Syscall ( gp Create Samplers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func Create Shader ( xtype uint 3 2 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Create Shader , 1 , uintptr ( xtype ) , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Create Shader Programv ( xtype uint 3 2 , count int 3 2 , strings * * uint 8 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Create Shader Programv , 3 , uintptr ( xtype ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( strings ) ) ) return ( uint 3 2 ) ( ret ) } 
func Create Sync From CLevent ARB ( context unsafe . Pointer , event unsafe . Pointer , flags uint 3 2 ) uintptr { ret , _ , _ : = syscall . Syscall ( gp Create Sync From CLevent ARB , 3 , uintptr ( context ) , uintptr ( event ) , uintptr ( flags ) ) return ( uintptr ) ( ret ) } 
func Create Textures ( target uint 3 2 , n int 3 2 , textures * uint 3 2 ) { syscall . Syscall ( gp Create Textures , 3 , uintptr ( target ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) ) } 
func Create Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Create Transform Feedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func Create Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { syscall . Syscall ( gp Create Vertex Arrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func Debug Message Callback ( callback unsafe . Pointer , user Param unsafe . Pointer ) { syscall . Syscall ( gp Debug Message Callback , 2 , syscall . New Callback ( callback ) , uintptr ( user Param ) , 0 ) } 
func Debug Message Callback AMD ( callback unsafe . Pointer , user Param unsafe . Pointer ) { syscall . Syscall ( gp Debug Message Callback AMD , 2 , uintptr ( callback ) , uintptr ( user Param ) , 0 ) } 
func Debug Message Callback ARB ( callback unsafe . Pointer , user Param unsafe . Pointer ) { syscall . Syscall ( gp Debug Message Callback ARB , 2 , syscall . New Callback ( callback ) , uintptr ( user Param ) , 0 ) } 
func Debug Message Callback KHR ( callback unsafe . Pointer , user Param unsafe . Pointer ) { syscall . Syscall ( gp Debug Message Callback KHR , 2 , syscall . New Callback ( callback ) , uintptr ( user Param ) , 0 ) } 
func Debug Message Control ( source uint 3 2 , xtype uint 3 2 , severity uint 3 2 , count int 3 2 , ids * uint 3 2 , enabled bool ) { syscall . Syscall 6 ( gp Debug Message Control , 6 , uintptr ( source ) , uintptr ( xtype ) , uintptr ( severity ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( ids ) ) , bool To Uintptr ( enabled ) ) } 
func Debug Message Insert ( source uint 3 2 , xtype uint 3 2 , id uint 3 2 , severity uint 3 2 , length int 3 2 , buf * uint 8 ) { syscall . Syscall 6 ( gp Debug Message Insert , 6 , uintptr ( source ) , uintptr ( xtype ) , uintptr ( id ) , uintptr ( severity ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( buf ) ) ) } 
func Delete Buffers ( n int 3 2 , buffers * uint 3 2 ) { syscall . Syscall ( gp Delete Buffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func Delete Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { syscall . Syscall ( gp Delete Framebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func Delete Lists ( list uint 3 2 , xrange int 3 2 ) { syscall . Syscall ( gp Delete Lists , 2 , uintptr ( list ) , uintptr ( xrange ) , 0 ) } 
func Delete Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { syscall . Syscall ( gp Delete Program Pipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func Delete Queries ( n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Delete Queries , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func Delete Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { syscall . Syscall ( gp Delete Renderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func Delete Samplers ( count int 3 2 , samplers * uint 3 2 ) { syscall . Syscall ( gp Delete Samplers , 2 , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func Delete Textures ( n int 3 2 , textures * uint 3 2 ) { syscall . Syscall ( gp Delete Textures , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , 0 ) } 
func Delete Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Delete Transform Feedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func Delete Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { syscall . Syscall ( gp Delete Vertex Arrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func Depth Range ( n float 6 4 , f float 6 4 ) { syscall . Syscall ( gp Depth Range , 2 , uintptr ( math . Float 6 4bits ( n ) ) , uintptr ( math . Float 6 4bits ( f ) ) , 0 ) } 
func Depth Range Indexed ( index uint 3 2 , n float 6 4 , f float 6 4 ) { syscall . Syscall ( gp Depth Range Indexed , 3 , uintptr ( index ) , uintptr ( math . Float 6 4bits ( n ) ) , uintptr ( math . Float 6 4bits ( f ) ) ) } 
func Depth Rangef ( n float 3 2 , f float 3 2 ) { syscall . Syscall ( gp Depth Rangef , 2 , uintptr ( math . Float 3 2bits ( n ) ) , uintptr ( math . Float 3 2bits ( f ) ) , 0 ) } 
func Detach Shader ( program uint 3 2 , shader uint 3 2 ) { syscall . Syscall ( gp Detach Shader , 2 , uintptr ( program ) , uintptr ( shader ) , 0 ) } 
func Disable Vertex Array Attrib ( vaobj uint 3 2 , index uint 3 2 ) { syscall . Syscall ( gp Disable Vertex Array Attrib , 2 , uintptr ( vaobj ) , uintptr ( index ) , 0 ) } 
func Dispatch Compute ( num _groups _x uint 3 2 , num _groups _y uint 3 2 , num _groups _z uint 3 2 ) { syscall . Syscall ( gp Dispatch Compute , 3 , uintptr ( num _groups _x ) , uintptr ( num _groups _y ) , uintptr ( num _groups _z ) ) } 
func Draw Arrays ( mode uint 3 2 , first int 3 2 , count int 3 2 ) { syscall . Syscall ( gp Draw Arrays , 3 , uintptr ( mode ) , uintptr ( first ) , uintptr ( count ) ) } 
func Draw Arrays Indirect ( mode uint 3 2 , indirect unsafe . Pointer ) { syscall . Syscall ( gp Draw Arrays Indirect , 2 , uintptr ( mode ) , uintptr ( indirect ) , 0 ) } 
func Draw Arrays Instanced Base Instance ( mode uint 3 2 , first int 3 2 , count int 3 2 , instancecount int 3 2 , baseinstance uint 3 2 ) { syscall . Syscall 6 ( gp Draw Arrays Instanced Base Instance , 5 , uintptr ( mode ) , uintptr ( first ) , uintptr ( count ) , uintptr ( instancecount ) , uintptr ( baseinstance ) , 0 ) } 
func Draw Buffers ( n int 3 2 , bufs * uint 3 2 ) { syscall . Syscall ( gp Draw Buffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( bufs ) ) , 0 ) } 
func Draw Elements ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer ) { syscall . Syscall 6 ( gp Draw Elements , 4 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , 0 , 0 ) } 
func Draw Elements Base Vertex ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , basevertex int 3 2 ) { syscall . Syscall 6 ( gp Draw Elements Base Vertex , 5 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( basevertex ) , 0 ) } 
func Draw Elements Indirect ( mode uint 3 2 , xtype uint 3 2 , indirect unsafe . Pointer ) { syscall . Syscall ( gp Draw Elements Indirect , 3 , uintptr ( mode ) , uintptr ( xtype ) , uintptr ( indirect ) ) } 
func Draw Elements Instanced Base Instance ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , baseinstance uint 3 2 ) { syscall . Syscall 6 ( gp Draw Elements Instanced Base Instance , 6 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( baseinstance ) ) } 
func Draw Elements Instanced Base Vertex ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , basevertex int 3 2 ) { syscall . Syscall 6 ( gp Draw Elements Instanced Base Vertex , 6 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( basevertex ) ) } 
func Draw Elements Instanced Base Vertex Base Instance ( mode uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , instancecount int 3 2 , basevertex int 3 2 , baseinstance uint 3 2 ) { syscall . Syscall 9 ( gp Draw Elements Instanced Base Vertex Base Instance , 7 , uintptr ( mode ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( instancecount ) , uintptr ( basevertex ) , uintptr ( baseinstance ) , 0 , 0 ) } 
func Draw Pixels ( width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 6 ( gp Draw Pixels , 5 , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func Draw Range Elements ( mode uint 3 2 , start uint 3 2 , end uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer ) { syscall . Syscall 6 ( gp Draw Range Elements , 6 , uintptr ( mode ) , uintptr ( start ) , uintptr ( end ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) ) } 
func Draw Range Elements Base Vertex ( mode uint 3 2 , start uint 3 2 , end uint 3 2 , count int 3 2 , xtype uint 3 2 , indices unsafe . Pointer , basevertex int 3 2 ) { syscall . Syscall 9 ( gp Draw Range Elements Base Vertex , 7 , uintptr ( mode ) , uintptr ( start ) , uintptr ( end ) , uintptr ( count ) , uintptr ( xtype ) , uintptr ( indices ) , uintptr ( basevertex ) , 0 , 0 ) } 
func Draw Transform Feedback ( mode uint 3 2 , id uint 3 2 ) { syscall . Syscall ( gp Draw Transform Feedback , 2 , uintptr ( mode ) , uintptr ( id ) , 0 ) } 
func Draw Transform Feedback Instanced ( mode uint 3 2 , id uint 3 2 , instancecount int 3 2 ) { syscall . Syscall ( gp Draw Transform Feedback Instanced , 3 , uintptr ( mode ) , uintptr ( id ) , uintptr ( instancecount ) ) } 
func Draw Transform Feedback Stream ( mode uint 3 2 , id uint 3 2 , stream uint 3 2 ) { syscall . Syscall ( gp Draw Transform Feedback Stream , 3 , uintptr ( mode ) , uintptr ( id ) , uintptr ( stream ) ) } 
func Draw Transform Feedback Stream Instanced ( mode uint 3 2 , id uint 3 2 , stream uint 3 2 , instancecount int 3 2 ) { syscall . Syscall 6 ( gp Draw Transform Feedback Stream Instanced , 4 , uintptr ( mode ) , uintptr ( id ) , uintptr ( stream ) , uintptr ( instancecount ) , 0 , 0 ) } 
func EGLImage Target Tex Storage EXT ( target uint 3 2 , image unsafe . Pointer , attrib _list * int 3 2 ) { syscall . Syscall ( gp EGLImage Target Tex Storage EXT , 3 , uintptr ( target ) , uintptr ( image ) , uintptr ( unsafe . Pointer ( attrib _list ) ) ) } 
func EGLImage Target Texture Storage EXT ( texture uint 3 2 , image unsafe . Pointer , attrib _list * int 3 2 ) { syscall . Syscall ( gp EGLImage Target Texture Storage EXT , 3 , uintptr ( texture ) , uintptr ( image ) , uintptr ( unsafe . Pointer ( attrib _list ) ) ) } 
func Edge Flag Pointer ( stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall ( gp Edge Flag Pointer , 2 , uintptr ( stride ) , uintptr ( pointer ) , 0 ) } 
func Enable Vertex Array Attrib ( vaobj uint 3 2 , index uint 3 2 ) { syscall . Syscall ( gp Enable Vertex Array Attrib , 2 , uintptr ( vaobj ) , uintptr ( index ) , 0 ) } 
func Feedback Buffer ( size int 3 2 , xtype uint 3 2 , buffer * float 3 2 ) { syscall . Syscall ( gp Feedback Buffer , 3 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( buffer ) ) ) } 
func Fence Sync ( condition uint 3 2 , flags uint 3 2 ) uintptr { ret , _ , _ : = syscall . Syscall ( gp Fence Sync , 2 , uintptr ( condition ) , uintptr ( flags ) , 0 ) return ( uintptr ) ( ret ) } 
func Flush Mapped Buffer Range ( target uint 3 2 , offset int , length int ) { syscall . Syscall ( gp Flush Mapped Buffer Range , 3 , uintptr ( target ) , uintptr ( offset ) , uintptr ( length ) ) } 
func Flush Mapped Named Buffer Range ( buffer uint 3 2 , offset int , length int ) { syscall . Syscall ( gp Flush Mapped Named Buffer Range , 3 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) ) } 
func Fog Coord Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall ( gp Fog Coord Pointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func Framebuffer Parameteri ( target uint 3 2 , pname uint 3 2 , param int 3 2 ) { syscall . Syscall ( gp Framebuffer Parameteri , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( param ) ) } 
func Framebuffer Renderbuffer ( target uint 3 2 , attachment uint 3 2 , renderbuffertarget uint 3 2 , renderbuffer uint 3 2 ) { syscall . Syscall 6 ( gp Framebuffer Renderbuffer , 4 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( renderbuffertarget ) , uintptr ( renderbuffer ) , 0 , 0 ) } 
func Framebuffer Texture 2D ( target uint 3 2 , attachment uint 3 2 , textarget uint 3 2 , texture uint 3 2 , level int 3 2 ) { syscall . Syscall 6 ( gp Framebuffer Texture 2D , 5 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( textarget ) , uintptr ( texture ) , uintptr ( level ) , 0 ) } 
func Framebuffer Texture Layer ( target uint 3 2 , attachment uint 3 2 , texture uint 3 2 , level int 3 2 , layer int 3 2 ) { syscall . Syscall 6 ( gp Framebuffer Texture Layer , 5 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( texture ) , uintptr ( level ) , uintptr ( layer ) , 0 ) } 
func Frustum ( left float 6 4 , right float 6 4 , bottom float 6 4 , top float 6 4 , z Near float 6 4 , z Far float 6 4 ) { syscall . Syscall 6 ( gp Frustum , 6 , uintptr ( math . Float 6 4bits ( left ) ) , uintptr ( math . Float 6 4bits ( right ) ) , uintptr ( math . Float 6 4bits ( bottom ) ) , uintptr ( math . Float 6 4bits ( top ) ) , uintptr ( math . Float 6 4bits ( z Near ) ) , uintptr ( math . Float 6 4bits ( z Far ) ) ) } 
func Gen Buffers ( n int 3 2 , buffers * uint 3 2 ) { syscall . Syscall ( gp Gen Buffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( buffers ) ) , 0 ) } 
func Gen Framebuffers ( n int 3 2 , framebuffers * uint 3 2 ) { syscall . Syscall ( gp Gen Framebuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( framebuffers ) ) , 0 ) } 
func Gen Lists ( xrange int 3 2 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Gen Lists , 1 , uintptr ( xrange ) , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Gen Program Pipelines ( n int 3 2 , pipelines * uint 3 2 ) { syscall . Syscall ( gp Gen Program Pipelines , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( pipelines ) ) , 0 ) } 
func Gen Queries ( n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Gen Queries , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func Gen Renderbuffers ( n int 3 2 , renderbuffers * uint 3 2 ) { syscall . Syscall ( gp Gen Renderbuffers , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( renderbuffers ) ) , 0 ) } 
func Gen Samplers ( count int 3 2 , samplers * uint 3 2 ) { syscall . Syscall ( gp Gen Samplers , 2 , uintptr ( count ) , uintptr ( unsafe . Pointer ( samplers ) ) , 0 ) } 
func Gen Textures ( n int 3 2 , textures * uint 3 2 ) { syscall . Syscall ( gp Gen Textures , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , 0 ) } 
func Gen Transform Feedbacks ( n int 3 2 , ids * uint 3 2 ) { syscall . Syscall ( gp Gen Transform Feedbacks , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( ids ) ) , 0 ) } 
func Gen Vertex Arrays ( n int 3 2 , arrays * uint 3 2 ) { syscall . Syscall ( gp Gen Vertex Arrays , 2 , uintptr ( n ) , uintptr ( unsafe . Pointer ( arrays ) ) , 0 ) } 
func Get Active Atomic Counter Bufferiv ( program uint 3 2 , buffer Index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Active Atomic Counter Bufferiv , 4 , uintptr ( program ) , uintptr ( buffer Index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func Get Active Attrib ( program uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , size * int 3 2 , xtype * uint 3 2 , name * uint 8 ) { syscall . Syscall 9 ( gp Get Active Attrib , 7 , uintptr ( program ) , uintptr ( index ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( size ) ) , uintptr ( unsafe . Pointer ( xtype ) ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func Get Active Subroutine Name ( program uint 3 2 , shadertype uint 3 2 , index uint 3 2 , bufsize int 3 2 , length * int 3 2 , name * uint 8 ) { syscall . Syscall 6 ( gp Get Active Subroutine Name , 6 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( index ) , uintptr ( bufsize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func Get Active Subroutine Uniform Name ( program uint 3 2 , shadertype uint 3 2 , index uint 3 2 , bufsize int 3 2 , length * int 3 2 , name * uint 8 ) { syscall . Syscall 6 ( gp Get Active Subroutine Uniform Name , 6 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( index ) , uintptr ( bufsize ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func Get Active Uniform ( program uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , size * int 3 2 , xtype * uint 3 2 , name * uint 8 ) { syscall . Syscall 9 ( gp Get Active Uniform , 7 , uintptr ( program ) , uintptr ( index ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( size ) ) , uintptr ( unsafe . Pointer ( xtype ) ) , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) } 
func Get Active Uniform Block Name ( program uint 3 2 , uniform Block Index uint 3 2 , buf Size int 3 2 , length * int 3 2 , uniform Block Name * uint 8 ) { syscall . Syscall 6 ( gp Get Active Uniform Block Name , 5 , uintptr ( program ) , uintptr ( uniform Block Index ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( uniform Block Name ) ) , 0 ) } 
func Get Active Uniform Blockiv ( program uint 3 2 , uniform Block Index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Active Uniform Blockiv , 4 , uintptr ( program ) , uintptr ( uniform Block Index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func Get Active Uniform Name ( program uint 3 2 , uniform Index uint 3 2 , buf Size int 3 2 , length * int 3 2 , uniform Name * uint 8 ) { syscall . Syscall 6 ( gp Get Active Uniform Name , 5 , uintptr ( program ) , uintptr ( uniform Index ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( uniform Name ) ) , 0 ) } 
func Get Active Uniformsiv ( program uint 3 2 , uniform Count int 3 2 , uniform Indices * uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Active Uniformsiv , 5 , uintptr ( program ) , uintptr ( uniform Count ) , uintptr ( unsafe . Pointer ( uniform Indices ) ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func Get Attached Shaders ( program uint 3 2 , max Count int 3 2 , count * int 3 2 , shaders * uint 3 2 ) { syscall . Syscall 6 ( gp Get Attached Shaders , 4 , uintptr ( program ) , uintptr ( max Count ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( unsafe . Pointer ( shaders ) ) , 0 , 0 ) } 
func Get Attrib Location ( program uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Attrib Location , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int 3 2 ) ( ret ) } 
func Get Buffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Buffer Parameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Buffer Pointerv ( target uint 3 2 , pname uint 3 2 , params * unsafe . Pointer ) { syscall . Syscall ( gp Get Buffer Pointerv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Buffer Sub Data ( target uint 3 2 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Buffer Sub Data , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func Get Clip Plane ( plane uint 3 2 , equation * float 6 4 ) { syscall . Syscall ( gp Get Clip Plane , 2 , uintptr ( plane ) , uintptr ( unsafe . Pointer ( equation ) ) , 0 ) } 
func Get Compressed Tex Image ( target uint 3 2 , level int 3 2 , img unsafe . Pointer ) { syscall . Syscall ( gp Get Compressed Tex Image , 3 , uintptr ( target ) , uintptr ( level ) , uintptr ( img ) ) } 
func Get Compressed Texture Image ( texture uint 3 2 , level int 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Compressed Texture Image , 4 , uintptr ( texture ) , uintptr ( level ) , uintptr ( buf Size ) , uintptr ( pixels ) , 0 , 0 ) } 
func Get Compressed Texture Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Get Compressed Texture Sub Image , 1 0 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( buf Size ) , uintptr ( pixels ) , 0 , 0 ) } 
func Get Debug Message Log ( count uint 3 2 , buf Size int 3 2 , sources * uint 3 2 , types * uint 3 2 , ids * uint 3 2 , severities * uint 3 2 , lengths * int 3 2 , message Log * uint 8 ) uint 3 2 { ret , _ , _ : = syscall . Syscall 9 ( gp Get Debug Message Log , 8 , uintptr ( count ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( sources ) ) , uintptr ( unsafe . Pointer ( types ) ) , uintptr ( unsafe . Pointer ( ids ) ) , uintptr ( unsafe . Pointer ( severities ) ) , uintptr ( unsafe . Pointer ( lengths ) ) , uintptr ( unsafe . Pointer ( message Log ) ) , 0 ) return ( uint 3 2 ) ( ret ) } 
func Get Error ( ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Error , 0 , 0 , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Get Frag Data Index ( program uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Frag Data Index , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int 3 2 ) ( ret ) } 
func Get Framebuffer Attachment Parameteriv ( target uint 3 2 , attachment uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Framebuffer Attachment Parameteriv , 4 , uintptr ( target ) , uintptr ( attachment ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func Get Framebuffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Framebuffer Parameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Graphics Reset Status ( ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Graphics Reset Status , 0 , 0 , 0 , 0 ) return ( uint 3 2 ) ( ret ) } 
func Get Internalformativ ( target uint 3 2 , internalformat uint 3 2 , pname uint 3 2 , buf Size int 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Internalformativ , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( pname ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func Get Multisamplefv ( pname uint 3 2 , index uint 3 2 , val * float 3 2 ) { syscall . Syscall ( gp Get Multisamplefv , 3 , uintptr ( pname ) , uintptr ( index ) , uintptr ( unsafe . Pointer ( val ) ) ) } 
func Get Named Buffer Parameteri 6 4v ( buffer uint 3 2 , pname uint 3 2 , params * int 6 4 ) { syscall . Syscall ( gp Get Named Buffer Parameteri 6 4v , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Named Buffer Parameteriv ( buffer uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Named Buffer Parameteriv , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Named Buffer Pointerv ( buffer uint 3 2 , pname uint 3 2 , params * unsafe . Pointer ) { syscall . Syscall ( gp Get Named Buffer Pointerv , 3 , uintptr ( buffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Named Buffer Sub Data ( buffer uint 3 2 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Named Buffer Sub Data , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func Get Named Framebuffer Attachment Parameteriv ( framebuffer uint 3 2 , attachment uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Named Framebuffer Attachment Parameteriv , 4 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func Get Named Framebuffer Parameteriv ( framebuffer uint 3 2 , pname uint 3 2 , param * int 3 2 ) { syscall . Syscall ( gp Get Named Framebuffer Parameteriv , 3 , uintptr ( framebuffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func Get Named Renderbuffer Parameteriv ( renderbuffer uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Named Renderbuffer Parameteriv , 3 , uintptr ( renderbuffer ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Object Label ( identifier uint 3 2 , name uint 3 2 , buf Size int 3 2 , length * int 3 2 , label * uint 8 ) { syscall . Syscall 6 ( gp Get Object Label , 5 , uintptr ( identifier ) , uintptr ( name ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( label ) ) , 0 ) } 
func Get Object Ptr Label ( ptr unsafe . Pointer , buf Size int 3 2 , length * int 3 2 , label * uint 8 ) { syscall . Syscall 6 ( gp Get Object Ptr Label , 4 , uintptr ( ptr ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( label ) ) , 0 , 0 ) } 
func Get Pointerv ( pname uint 3 2 , params * unsafe . Pointer ) { syscall . Syscall ( gp Get Pointerv , 2 , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 ) } 
func Get Polygon Stipple ( mask * uint 8 ) { syscall . Syscall ( gp Get Polygon Stipple , 1 , uintptr ( unsafe . Pointer ( mask ) ) , 0 , 0 ) } 
func Get Program Binary ( program uint 3 2 , buf Size int 3 2 , length * int 3 2 , binary Format * uint 3 2 , binary unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Program Binary , 5 , uintptr ( program ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( binary Format ) ) , uintptr ( binary ) , 0 ) } 
func Get Program Info Log ( program uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { syscall . Syscall 6 ( gp Get Program Info Log , 4 , uintptr ( program ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( info Log ) ) , 0 , 0 ) } 
func Get Program Pipeline Info Log ( pipeline uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { syscall . Syscall 6 ( gp Get Program Pipeline Info Log , 4 , uintptr ( pipeline ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( info Log ) ) , 0 , 0 ) } 
func Get Program Resource Index ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Program Resource Index , 3 , uintptr ( program ) , uintptr ( program Interface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Program Resource Location ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Program Resource Location , 3 , uintptr ( program ) , uintptr ( program Interface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Program Resource Location Index ( program uint 3 2 , program Interface uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Program Resource Location Index , 3 , uintptr ( program ) , uintptr ( program Interface ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Program Resource Name ( program uint 3 2 , program Interface uint 3 2 , index uint 3 2 , buf Size int 3 2 , length * int 3 2 , name * uint 8 ) { syscall . Syscall 6 ( gp Get Program Resource Name , 6 , uintptr ( program ) , uintptr ( program Interface ) , uintptr ( index ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( name ) ) ) } 
func Get Programiv ( program uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Programiv , 3 , uintptr ( program ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Query Indexediv ( target uint 3 2 , index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall 6 ( gp Get Query Indexediv , 4 , uintptr ( target ) , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) , 0 , 0 ) } 
func Get Query Objectuiv ( id uint 3 2 , pname uint 3 2 , params * uint 3 2 ) { syscall . Syscall ( gp Get Query Objectuiv , 3 , uintptr ( id ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Queryiv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Queryiv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Renderbuffer Parameteriv ( target uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Renderbuffer Parameteriv , 3 , uintptr ( target ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Shader Info Log ( shader uint 3 2 , buf Size int 3 2 , length * int 3 2 , info Log * uint 8 ) { syscall . Syscall 6 ( gp Get Shader Info Log , 4 , uintptr ( shader ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( info Log ) ) , 0 , 0 ) } 
func Get Shader Precision Format ( shadertype uint 3 2 , precisiontype uint 3 2 , xrange * int 3 2 , precision * int 3 2 ) { syscall . Syscall 6 ( gp Get Shader Precision Format , 4 , uintptr ( shadertype ) , uintptr ( precisiontype ) , uintptr ( unsafe . Pointer ( xrange ) ) , uintptr ( unsafe . Pointer ( precision ) ) , 0 , 0 ) } 
func Get Shader Source ( shader uint 3 2 , buf Size int 3 2 , length * int 3 2 , source * uint 8 ) { syscall . Syscall 6 ( gp Get Shader Source , 4 , uintptr ( shader ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( source ) ) , 0 , 0 ) } 
func Get Shaderiv ( shader uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Shaderiv , 3 , uintptr ( shader ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get String ( name uint 3 2 ) * uint 8 { ret , _ , _ : = syscall . Syscall ( gp Get String , 1 , uintptr ( name ) , 0 , 0 ) return ( * uint 8 ) ( unsafe . Pointer ( ret ) ) } 
func Get Subroutine Index ( program uint 3 2 , shadertype uint 3 2 , name * uint 8 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Subroutine Index , 3 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( uint 3 2 ) ( ret ) } 
func Get Subroutine Uniform Location ( program uint 3 2 , shadertype uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Subroutine Uniform Location , 3 , uintptr ( program ) , uintptr ( shadertype ) , uintptr ( unsafe . Pointer ( name ) ) ) return ( int 3 2 ) ( ret ) } 
func Get Synciv ( sync uintptr , pname uint 3 2 , buf Size int 3 2 , length * int 3 2 , values * int 3 2 ) { syscall . Syscall 6 ( gp Get Synciv , 5 , uintptr ( sync ) , uintptr ( pname ) , uintptr ( buf Size ) , uintptr ( unsafe . Pointer ( length ) ) , uintptr ( unsafe . Pointer ( values ) ) , 0 ) } 
func Get Tex Image ( target uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Tex Image , 5 , uintptr ( target ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func Get Texture Image ( texture uint 3 2 , level int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 6 ( gp Get Texture Image , 6 , uintptr ( texture ) , uintptr ( level ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( buf Size ) , uintptr ( pixels ) ) } 
func Get Texture Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Get Texture Sub Image , 1 2 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( buf Size ) , uintptr ( pixels ) ) } 
func Get Transform Feedbackiv ( xfb uint 3 2 , pname uint 3 2 , param * int 3 2 ) { syscall . Syscall ( gp Get Transform Feedbackiv , 3 , uintptr ( xfb ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func Get Uniform Block Index ( program uint 3 2 , uniform Block Name * uint 8 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Uniform Block Index , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( uniform Block Name ) ) , 0 ) return ( uint 3 2 ) ( ret ) } 
func Get Uniform Indices ( program uint 3 2 , uniform Count int 3 2 , uniform Names * * uint 8 , uniform Indices * uint 3 2 ) { syscall . Syscall 6 ( gp Get Uniform Indices , 4 , uintptr ( program ) , uintptr ( uniform Count ) , uintptr ( unsafe . Pointer ( uniform Names ) ) , uintptr ( unsafe . Pointer ( uniform Indices ) ) , 0 , 0 ) } 
func Get Uniform Location ( program uint 3 2 , name * uint 8 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Get Uniform Location , 2 , uintptr ( program ) , uintptr ( unsafe . Pointer ( name ) ) , 0 ) return ( int 3 2 ) ( ret ) } 
func Get Uniformfv ( program uint 3 2 , location int 3 2 , params * float 3 2 ) { syscall . Syscall ( gp Get Uniformfv , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Uniformiv ( program uint 3 2 , location int 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Uniformiv , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Arrayiv ( vaobj uint 3 2 , pname uint 3 2 , param * int 3 2 ) { syscall . Syscall ( gp Get Vertex Arrayiv , 3 , uintptr ( vaobj ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( param ) ) ) } 
func Get Vertex Attrib Ldv ( index uint 3 2 , pname uint 3 2 , params * float 6 4 ) { syscall . Syscall ( gp Get Vertex Attrib Ldv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attrib Pointerv ( index uint 3 2 , pname uint 3 2 , pointer * unsafe . Pointer ) { syscall . Syscall ( gp Get Vertex Attrib Pointerv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( pointer ) ) ) } 
func Get Vertex Attribdv ( index uint 3 2 , pname uint 3 2 , params * float 6 4 ) { syscall . Syscall ( gp Get Vertex Attribdv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attribfv ( index uint 3 2 , pname uint 3 2 , params * float 3 2 ) { syscall . Syscall ( gp Get Vertex Attribfv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Vertex Attribiv ( index uint 3 2 , pname uint 3 2 , params * int 3 2 ) { syscall . Syscall ( gp Get Vertex Attribiv , 3 , uintptr ( index ) , uintptr ( pname ) , uintptr ( unsafe . Pointer ( params ) ) ) } 
func Get Vk Proc Addr NV ( name * uint 8 ) unsafe . Pointer { ret , _ , _ : = syscall . Syscall ( gp Get Vk Proc Addr NV , 1 , uintptr ( unsafe . Pointer ( name ) ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Hint ( target uint 3 2 , mode uint 3 2 ) { syscall . Syscall ( gp Hint , 2 , uintptr ( target ) , uintptr ( mode ) , 0 ) } 
func Index Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall ( gp Index Pointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func Interleaved Arrays ( format uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall ( gp Interleaved Arrays , 3 , uintptr ( format ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func Invalidate Buffer Sub Data ( buffer uint 3 2 , offset int , length int ) { syscall . Syscall ( gp Invalidate Buffer Sub Data , 3 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) ) } 
func Invalidate Framebuffer ( target uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 ) { syscall . Syscall ( gp Invalidate Framebuffer , 3 , uintptr ( target ) , uintptr ( num Attachments ) , uintptr ( unsafe . Pointer ( attachments ) ) ) } 
func Invalidate Named Framebuffer Data ( framebuffer uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 ) { syscall . Syscall ( gp Invalidate Named Framebuffer Data , 3 , uintptr ( framebuffer ) , uintptr ( num Attachments ) , uintptr ( unsafe . Pointer ( attachments ) ) ) } 
func Invalidate Named Framebuffer Sub Data ( framebuffer uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Invalidate Named Framebuffer Sub Data , 7 , uintptr ( framebuffer ) , uintptr ( num Attachments ) , uintptr ( unsafe . Pointer ( attachments ) ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Invalidate Sub Framebuffer ( target uint 3 2 , num Attachments int 3 2 , attachments * uint 3 2 , x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 9 ( gp Invalidate Sub Framebuffer , 7 , uintptr ( target ) , uintptr ( num Attachments ) , uintptr ( unsafe . Pointer ( attachments ) ) , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Invalidate Tex Image ( texture uint 3 2 , level int 3 2 ) { syscall . Syscall ( gp Invalidate Tex Image , 2 , uintptr ( texture ) , uintptr ( level ) , 0 ) } 
func Invalidate Tex Sub Image ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { syscall . Syscall 9 ( gp Invalidate Tex Sub Image , 8 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , 0 ) } 
func Is Buffer ( buffer uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Buffer , 1 , uintptr ( buffer ) , 0 , 0 ) return ret ! = 0 } 
func Is Framebuffer ( framebuffer uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Framebuffer , 1 , uintptr ( framebuffer ) , 0 , 0 ) return ret ! = 0 } 
func Is List ( list uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is List , 1 , uintptr ( list ) , 0 , 0 ) return ret ! = 0 } 
func Is Program ( program uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Program , 1 , uintptr ( program ) , 0 , 0 ) return ret ! = 0 } 
func Is Program Pipeline ( pipeline uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Program Pipeline , 1 , uintptr ( pipeline ) , 0 , 0 ) return ret ! = 0 } 
func Is Query ( id uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Query , 1 , uintptr ( id ) , 0 , 0 ) return ret ! = 0 } 
func Is Renderbuffer ( renderbuffer uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Renderbuffer , 1 , uintptr ( renderbuffer ) , 0 , 0 ) return ret ! = 0 } 
func Is Sampler ( sampler uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Sampler , 1 , uintptr ( sampler ) , 0 , 0 ) return ret ! = 0 } 
func Is Shader ( shader uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Shader , 1 , uintptr ( shader ) , 0 , 0 ) return ret ! = 0 } 
func Is Sync ( sync uintptr ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Sync , 1 , uintptr ( sync ) , 0 , 0 ) return ret ! = 0 } 
func Is Texture ( texture uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Texture , 1 , uintptr ( texture ) , 0 , 0 ) return ret ! = 0 } 
func Is Transform Feedback ( id uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Transform Feedback , 1 , uintptr ( id ) , 0 , 0 ) return ret ! = 0 } 
func Is Vertex Array ( array uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Is Vertex Array , 1 , uintptr ( array ) , 0 , 0 ) return ret ! = 0 } 
func Line Stipple ( factor int 3 2 , pattern uint 1 6 ) { syscall . Syscall ( gp Line Stipple , 2 , uintptr ( factor ) , uintptr ( pattern ) , 0 ) } 
func Line Width ( width float 3 2 ) { syscall . Syscall ( gp Line Width , 1 , uintptr ( math . Float 3 2bits ( width ) ) , 0 , 0 ) } 
func Map Buffer ( target uint 3 2 , access uint 3 2 ) unsafe . Pointer { ret , _ , _ : = syscall . Syscall ( gp Map Buffer , 2 , uintptr ( target ) , uintptr ( access ) , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Map Buffer Range ( target uint 3 2 , offset int , length int , access uint 3 2 ) unsafe . Pointer { ret , _ , _ : = syscall . Syscall 6 ( gp Map Buffer Range , 4 , uintptr ( target ) , uintptr ( offset ) , uintptr ( length ) , uintptr ( access ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Map Named Buffer ( buffer uint 3 2 , access uint 3 2 ) unsafe . Pointer { ret , _ , _ : = syscall . Syscall ( gp Map Named Buffer , 2 , uintptr ( buffer ) , uintptr ( access ) , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Map Named Buffer Range ( buffer uint 3 2 , offset int , length int , access uint 3 2 ) unsafe . Pointer { ret , _ , _ : = syscall . Syscall 6 ( gp Map Named Buffer Range , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( length ) , uintptr ( access ) , 0 , 0 ) return ( unsafe . Pointer ) ( ret ) } 
func Multi Draw Arrays ( mode uint 3 2 , first * int 3 2 , count * int 3 2 , drawcount int 3 2 ) { syscall . Syscall 6 ( gp Multi Draw Arrays , 4 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( first ) ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( drawcount ) , 0 , 0 ) } 
func Multi Draw Arrays Indirect ( mode uint 3 2 , indirect unsafe . Pointer , drawcount int 3 2 , stride int 3 2 ) { syscall . Syscall 6 ( gp Multi Draw Arrays Indirect , 4 , uintptr ( mode ) , uintptr ( indirect ) , uintptr ( drawcount ) , uintptr ( stride ) , 0 , 0 ) } 
func Multi Draw Elements ( mode uint 3 2 , count * int 3 2 , xtype uint 3 2 , indices * unsafe . Pointer , drawcount int 3 2 ) { syscall . Syscall 6 ( gp Multi Draw Elements , 5 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( indices ) ) , uintptr ( drawcount ) , 0 ) } 
func Multi Draw Elements Base Vertex ( mode uint 3 2 , count * int 3 2 , xtype uint 3 2 , indices * unsafe . Pointer , drawcount int 3 2 , basevertex * int 3 2 ) { syscall . Syscall 6 ( gp Multi Draw Elements Base Vertex , 6 , uintptr ( mode ) , uintptr ( unsafe . Pointer ( count ) ) , uintptr ( xtype ) , uintptr ( unsafe . Pointer ( indices ) ) , uintptr ( drawcount ) , uintptr ( unsafe . Pointer ( basevertex ) ) ) } 
func Multi Draw Elements Indirect ( mode uint 3 2 , xtype uint 3 2 , indirect unsafe . Pointer , drawcount int 3 2 , stride int 3 2 ) { syscall . Syscall 6 ( gp Multi Draw Elements Indirect , 5 , uintptr ( mode ) , uintptr ( xtype ) , uintptr ( indirect ) , uintptr ( drawcount ) , uintptr ( stride ) , 0 ) } 
func Named Buffer Data ( buffer uint 3 2 , size int , data unsafe . Pointer , usage uint 3 2 ) { syscall . Syscall 6 ( gp Named Buffer Data , 4 , uintptr ( buffer ) , uintptr ( size ) , uintptr ( data ) , uintptr ( usage ) , 0 , 0 ) } 
func Named Buffer Storage ( buffer uint 3 2 , size int , data unsafe . Pointer , flags uint 3 2 ) { syscall . Syscall 6 ( gp Named Buffer Storage , 4 , uintptr ( buffer ) , uintptr ( size ) , uintptr ( data ) , uintptr ( flags ) , 0 , 0 ) } 
func Named Buffer Storage External EXT ( buffer uint 3 2 , offset int , size int , client Buffer unsafe . Pointer , flags uint 3 2 ) { syscall . Syscall 6 ( gp Named Buffer Storage External EXT , 5 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( client Buffer ) , uintptr ( flags ) , 0 ) } 
func Named Buffer Sub Data ( buffer uint 3 2 , offset int , size int , data unsafe . Pointer ) { syscall . Syscall 6 ( gp Named Buffer Sub Data , 4 , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , uintptr ( data ) , 0 , 0 ) } 
func Named Framebuffer Draw Buffer ( framebuffer uint 3 2 , buf uint 3 2 ) { syscall . Syscall ( gp Named Framebuffer Draw Buffer , 2 , uintptr ( framebuffer ) , uintptr ( buf ) , 0 ) } 
func Named Framebuffer Draw Buffers ( framebuffer uint 3 2 , n int 3 2 , bufs * uint 3 2 ) { syscall . Syscall ( gp Named Framebuffer Draw Buffers , 3 , uintptr ( framebuffer ) , uintptr ( n ) , uintptr ( unsafe . Pointer ( bufs ) ) ) } 
func Named Framebuffer Parameteri ( framebuffer uint 3 2 , pname uint 3 2 , param int 3 2 ) { syscall . Syscall ( gp Named Framebuffer Parameteri , 3 , uintptr ( framebuffer ) , uintptr ( pname ) , uintptr ( param ) ) } 
func Named Framebuffer Read Buffer ( framebuffer uint 3 2 , src uint 3 2 ) { syscall . Syscall ( gp Named Framebuffer Read Buffer , 2 , uintptr ( framebuffer ) , uintptr ( src ) , 0 ) } 
func Named Framebuffer Renderbuffer ( framebuffer uint 3 2 , attachment uint 3 2 , renderbuffertarget uint 3 2 , renderbuffer uint 3 2 ) { syscall . Syscall 6 ( gp Named Framebuffer Renderbuffer , 4 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( renderbuffertarget ) , uintptr ( renderbuffer ) , 0 , 0 ) } 
func Named Framebuffer Texture Layer ( framebuffer uint 3 2 , attachment uint 3 2 , texture uint 3 2 , level int 3 2 , layer int 3 2 ) { syscall . Syscall 6 ( gp Named Framebuffer Texture Layer , 5 , uintptr ( framebuffer ) , uintptr ( attachment ) , uintptr ( texture ) , uintptr ( level ) , uintptr ( layer ) , 0 ) } 
func Named Renderbuffer Storage ( renderbuffer uint 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Named Renderbuffer Storage , 4 , uintptr ( renderbuffer ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Named Renderbuffer Storage Multisample ( renderbuffer uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Named Renderbuffer Storage Multisample , 5 , uintptr ( renderbuffer ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func New List ( list uint 3 2 , mode uint 3 2 ) { syscall . Syscall ( gp New List , 2 , uintptr ( list ) , uintptr ( mode ) , 0 ) } 
func Normal Pointer ( xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall ( gp Normal Pointer , 3 , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func Object Label ( identifier uint 3 2 , name uint 3 2 , length int 3 2 , label * uint 8 ) { syscall . Syscall 6 ( gp Object Label , 4 , uintptr ( identifier ) , uintptr ( name ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( label ) ) , 0 , 0 ) } 
func Object Ptr Label ( ptr unsafe . Pointer , length int 3 2 , label * uint 8 ) { syscall . Syscall ( gp Object Ptr Label , 3 , uintptr ( ptr ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( label ) ) ) } 
func Ortho ( left float 6 4 , right float 6 4 , bottom float 6 4 , top float 6 4 , z Near float 6 4 , z Far float 6 4 ) { syscall . Syscall 6 ( gp Ortho , 6 , uintptr ( math . Float 6 4bits ( left ) ) , uintptr ( math . Float 6 4bits ( right ) ) , uintptr ( math . Float 6 4bits ( bottom ) ) , uintptr ( math . Float 6 4bits ( top ) ) , uintptr ( math . Float 6 4bits ( z Near ) ) , uintptr ( math . Float 6 4bits ( z Far ) ) ) } 
func Pass Through ( token float 3 2 ) { syscall . Syscall ( gp Pass Through , 1 , uintptr ( math . Float 3 2bits ( token ) ) , 0 , 0 ) } 
func Patch Parameteri ( pname uint 3 2 , value int 3 2 ) { syscall . Syscall ( gp Patch Parameteri , 2 , uintptr ( pname ) , uintptr ( value ) , 0 ) } 
func Pixel Storei ( pname uint 3 2 , param int 3 2 ) { syscall . Syscall ( gp Pixel Storei , 2 , uintptr ( pname ) , uintptr ( param ) , 0 ) } 
func Pixel Zoom ( xfactor float 3 2 , yfactor float 3 2 ) { syscall . Syscall ( gp Pixel Zoom , 2 , uintptr ( math . Float 3 2bits ( xfactor ) ) , uintptr ( math . Float 3 2bits ( yfactor ) ) , 0 ) } 
func Point Size ( size float 3 2 ) { syscall . Syscall ( gp Point Size , 1 , uintptr ( math . Float 3 2bits ( size ) ) , 0 , 0 ) } 
func Polygon Mode ( face uint 3 2 , mode uint 3 2 ) { syscall . Syscall ( gp Polygon Mode , 2 , uintptr ( face ) , uintptr ( mode ) , 0 ) } 
func Polygon Offset ( factor float 3 2 , units float 3 2 ) { syscall . Syscall ( gp Polygon Offset , 2 , uintptr ( math . Float 3 2bits ( factor ) ) , uintptr ( math . Float 3 2bits ( units ) ) , 0 ) } 
func Polygon Stipple ( mask * uint 8 ) { syscall . Syscall ( gp Polygon Stipple , 1 , uintptr ( unsafe . Pointer ( mask ) ) , 0 , 0 ) } 
func Prioritize Textures ( n int 3 2 , textures * uint 3 2 , priorities * float 3 2 ) { syscall . Syscall ( gp Prioritize Textures , 3 , uintptr ( n ) , uintptr ( unsafe . Pointer ( textures ) ) , uintptr ( unsafe . Pointer ( priorities ) ) ) } 
func Program Binary ( program uint 3 2 , binary Format uint 3 2 , binary unsafe . Pointer , length int 3 2 ) { syscall . Syscall 6 ( gp Program Binary , 4 , uintptr ( program ) , uintptr ( binary Format ) , uintptr ( binary ) , uintptr ( length ) , 0 , 0 ) } 
func Program Parameteri ( program uint 3 2 , pname uint 3 2 , value int 3 2 ) { syscall . Syscall ( gp Program Parameteri , 3 , uintptr ( program ) , uintptr ( pname ) , uintptr ( value ) ) } 
func Program Uniform 1f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 ) { syscall . Syscall ( gp Program Uniform 1f , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) ) } 
func Program Uniform 1fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 1fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 1i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 ) { syscall . Syscall ( gp Program Uniform 1i , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) ) } 
func Program Uniform 1iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 1iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 1ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 ) { syscall . Syscall ( gp Program Uniform 1ui , 3 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) ) } 
func Program Uniform 1uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 1uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 2f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2f , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) , 0 , 0 ) } 
func Program Uniform 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 2i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2i , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , 0 , 0 ) } 
func Program Uniform 2iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 2ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2ui , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , 0 , 0 ) } 
func Program Uniform 2uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 2uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 3f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3f , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) , uintptr ( math . Float 3 2bits ( v 2 ) ) , 0 ) } 
func Program Uniform 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 3i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3i , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , 0 ) } 
func Program Uniform 3iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 3ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 , v 2 uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3ui , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , 0 ) } 
func Program Uniform 3uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 3uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 4f ( program uint 3 2 , location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 , v 3 float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4f , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) , uintptr ( math . Float 3 2bits ( v 2 ) ) , uintptr ( math . Float 3 2bits ( v 3 ) ) ) } 
func Program Uniform 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4fv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 4i ( program uint 3 2 , location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 , v 3 int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4i , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , uintptr ( v 3 ) ) } 
func Program Uniform 4iv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4iv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform 4ui ( program uint 3 2 , location int 3 2 , v 0 uint 3 2 , v 1 uint 3 2 , v 2 uint 3 2 , v 3 uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4ui , 6 , uintptr ( program ) , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , uintptr ( v 3 ) ) } 
func Program Uniform 4uiv ( program uint 3 2 , location int 3 2 , count int 3 2 , value * uint 3 2 ) { syscall . Syscall 6 ( gp Program Uniform 4uiv , 4 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Program Uniform Matrix 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 2x 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 2x 3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 2x 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 2x 4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 3x 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 3x 2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 3x 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 3x 4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 4fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 4fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 4x 2fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 4x 2fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Program Uniform Matrix 4x 3fv ( program uint 3 2 , location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Program Uniform Matrix 4x 3fv , 5 , uintptr ( program ) , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 ) } 
func Push Debug Group ( source uint 3 2 , id uint 3 2 , length int 3 2 , message * uint 8 ) { syscall . Syscall 6 ( gp Push Debug Group , 4 , uintptr ( source ) , uintptr ( id ) , uintptr ( length ) , uintptr ( unsafe . Pointer ( message ) ) , 0 , 0 ) } 
func Query Counter ( id uint 3 2 , target uint 3 2 ) { syscall . Syscall ( gp Query Counter , 2 , uintptr ( id ) , uintptr ( target ) , 0 ) } 
func Query Matrixx OES ( mantissa * int 3 2 , exponent * int 3 2 ) uint 3 2 { ret , _ , _ : = syscall . Syscall ( gp Query Matrixx OES , 2 , uintptr ( unsafe . Pointer ( mantissa ) ) , uintptr ( unsafe . Pointer ( exponent ) ) , 0 ) return ( uint 3 2 ) ( ret ) } 
func Read Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Read Pixels , 7 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func Readn Pixels ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , buf Size int 3 2 , data unsafe . Pointer ) { syscall . Syscall 9 ( gp Readn Pixels , 8 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( buf Size ) , uintptr ( data ) , 0 ) } 
func Render Mode ( mode uint 3 2 ) int 3 2 { ret , _ , _ : = syscall . Syscall ( gp Render Mode , 1 , uintptr ( mode ) , 0 , 0 ) return ( int 3 2 ) ( ret ) } 
func Renderbuffer Storage ( target uint 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Renderbuffer Storage , 4 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Renderbuffer Storage Multisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Renderbuffer Storage Multisample , 5 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Sample Coverage ( value float 3 2 , invert bool ) { syscall . Syscall ( gp Sample Coverage , 2 , uintptr ( math . Float 3 2bits ( value ) ) , bool To Uintptr ( invert ) , 0 ) } 
func Sample Maski ( mask Number uint 3 2 , mask uint 3 2 ) { syscall . Syscall ( gp Sample Maski , 2 , uintptr ( mask Number ) , uintptr ( mask ) , 0 ) } 
func Scissor ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Scissor , 4 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Scissor Indexed ( index uint 3 2 , left int 3 2 , bottom int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Scissor Indexed , 5 , uintptr ( index ) , uintptr ( left ) , uintptr ( bottom ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Secondary Color Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall 6 ( gp Secondary Color Pointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func Select Buffer ( size int 3 2 , buffer * uint 3 2 ) { syscall . Syscall ( gp Select Buffer , 2 , uintptr ( size ) , uintptr ( unsafe . Pointer ( buffer ) ) , 0 ) } 
func Shader Binary ( count int 3 2 , shaders * uint 3 2 , binaryformat uint 3 2 , binary unsafe . Pointer , length int 3 2 ) { syscall . Syscall 6 ( gp Shader Binary , 5 , uintptr ( count ) , uintptr ( unsafe . Pointer ( shaders ) ) , uintptr ( binaryformat ) , uintptr ( binary ) , uintptr ( length ) , 0 ) } 
func Shader Source ( shader uint 3 2 , count int 3 2 , xstring * * uint 8 , length * int 3 2 ) { syscall . Syscall 6 ( gp Shader Source , 4 , uintptr ( shader ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( xstring ) ) , uintptr ( unsafe . Pointer ( length ) ) , 0 , 0 ) } 
func Shader Storage Block Binding ( program uint 3 2 , storage Block Index uint 3 2 , storage Block Binding uint 3 2 ) { syscall . Syscall ( gp Shader Storage Block Binding , 3 , uintptr ( program ) , uintptr ( storage Block Index ) , uintptr ( storage Block Binding ) ) } 
func Stencil Func ( xfunc uint 3 2 , ref int 3 2 , mask uint 3 2 ) { syscall . Syscall ( gp Stencil Func , 3 , uintptr ( xfunc ) , uintptr ( ref ) , uintptr ( mask ) ) } 
func Stencil Func Separate ( face uint 3 2 , xfunc uint 3 2 , ref int 3 2 , mask uint 3 2 ) { syscall . Syscall 6 ( gp Stencil Func Separate , 4 , uintptr ( face ) , uintptr ( xfunc ) , uintptr ( ref ) , uintptr ( mask ) , 0 , 0 ) } 
func Stencil Mask Separate ( face uint 3 2 , mask uint 3 2 ) { syscall . Syscall ( gp Stencil Mask Separate , 2 , uintptr ( face ) , uintptr ( mask ) , 0 ) } 
func Stencil Op ( fail uint 3 2 , zfail uint 3 2 , zpass uint 3 2 ) { syscall . Syscall ( gp Stencil Op , 3 , uintptr ( fail ) , uintptr ( zfail ) , uintptr ( zpass ) ) } 
func Stencil Op Separate ( face uint 3 2 , sfail uint 3 2 , dpfail uint 3 2 , dppass uint 3 2 ) { syscall . Syscall 6 ( gp Stencil Op Separate , 4 , uintptr ( face ) , uintptr ( sfail ) , uintptr ( dpfail ) , uintptr ( dppass ) , 0 , 0 ) } 
func Tex Buffer Range ( target uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 , offset int , size int ) { syscall . Syscall 6 ( gp Tex Buffer Range , 5 , uintptr ( target ) , uintptr ( internalformat ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func Tex Coord Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall 6 ( gp Tex Coord Pointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func Tex Image 1D ( target uint 3 2 , level int 3 2 , internalformat int 3 2 , width int 3 2 , border int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Tex Image 1D , 8 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( border ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func Tex Image 2D ( target uint 3 2 , level int 3 2 , internalformat int 3 2 , width int 3 2 , height int 3 2 , border int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Tex Image 2D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( border ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func Tex Image 2DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 6 ( gp Tex Image 2DMultisample , 6 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , bool To Uintptr ( fixedsamplelocations ) ) } 
func Tex Image 3DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 9 ( gp Tex Image 3DMultisample , 7 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , bool To Uintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func Tex Storage 1D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 ) { syscall . Syscall 6 ( gp Tex Storage 1D , 4 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , 0 , 0 ) } 
func Tex Storage 2D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Tex Storage 2D , 5 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Tex Storage 2DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 6 ( gp Tex Storage 2DMultisample , 6 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , bool To Uintptr ( fixedsamplelocations ) ) } 
func Tex Storage 3D ( target uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { syscall . Syscall 6 ( gp Tex Storage 3D , 6 , uintptr ( target ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) ) } 
func Tex Storage 3DMultisample ( target uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 9 ( gp Tex Storage 3DMultisample , 7 , uintptr ( target ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , bool To Uintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func Tex Sub Image 1D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Tex Sub Image 1D , 7 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func Tex Sub Image 2D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Tex Sub Image 2D , 9 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func Tex Sub Image 3D ( target uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Tex Sub Image 3D , 1 1 , uintptr ( target ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func Texture Buffer ( texture uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 ) { syscall . Syscall ( gp Texture Buffer , 3 , uintptr ( texture ) , uintptr ( internalformat ) , uintptr ( buffer ) ) } 
func Texture Buffer Range ( texture uint 3 2 , internalformat uint 3 2 , buffer uint 3 2 , offset int , size int ) { syscall . Syscall 6 ( gp Texture Buffer Range , 5 , uintptr ( texture ) , uintptr ( internalformat ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func Texture Storage 1D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 ) { syscall . Syscall 6 ( gp Texture Storage 1D , 4 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , 0 , 0 ) } 
func Texture Storage 2D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Texture Storage 2D , 5 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , 0 ) } 
func Texture Storage 2DMultisample ( texture uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 6 ( gp Texture Storage 2DMultisample , 6 , uintptr ( texture ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , bool To Uintptr ( fixedsamplelocations ) ) } 
func Texture Storage 3D ( texture uint 3 2 , levels int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 ) { syscall . Syscall 6 ( gp Texture Storage 3D , 6 , uintptr ( texture ) , uintptr ( levels ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) ) } 
func Texture Storage 3DMultisample ( texture uint 3 2 , samples int 3 2 , internalformat uint 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , fixedsamplelocations bool ) { syscall . Syscall 9 ( gp Texture Storage 3DMultisample , 7 , uintptr ( texture ) , uintptr ( samples ) , uintptr ( internalformat ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , bool To Uintptr ( fixedsamplelocations ) , 0 , 0 ) } 
func Texture Sub Image 1D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , width int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Texture Sub Image 1D , 7 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( width ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 , 0 ) } 
func Texture Sub Image 2D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , width int 3 2 , height int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 9 ( gp Texture Sub Image 2D , 9 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) ) } 
func Texture Sub Image 3D ( texture uint 3 2 , level int 3 2 , xoffset int 3 2 , yoffset int 3 2 , zoffset int 3 2 , width int 3 2 , height int 3 2 , depth int 3 2 , format uint 3 2 , xtype uint 3 2 , pixels unsafe . Pointer ) { syscall . Syscall 1 2 ( gp Texture Sub Image 3D , 1 1 , uintptr ( texture ) , uintptr ( level ) , uintptr ( xoffset ) , uintptr ( yoffset ) , uintptr ( zoffset ) , uintptr ( width ) , uintptr ( height ) , uintptr ( depth ) , uintptr ( format ) , uintptr ( xtype ) , uintptr ( pixels ) , 0 ) } 
func Texture View ( texture uint 3 2 , target uint 3 2 , origtexture uint 3 2 , internalformat uint 3 2 , minlevel uint 3 2 , numlevels uint 3 2 , minlayer uint 3 2 , numlayers uint 3 2 ) { syscall . Syscall 9 ( gp Texture View , 8 , uintptr ( texture ) , uintptr ( target ) , uintptr ( origtexture ) , uintptr ( internalformat ) , uintptr ( minlevel ) , uintptr ( numlevels ) , uintptr ( minlayer ) , uintptr ( numlayers ) , 0 ) } 
func Transform Feedback Buffer Base ( xfb uint 3 2 , index uint 3 2 , buffer uint 3 2 ) { syscall . Syscall ( gp Transform Feedback Buffer Base , 3 , uintptr ( xfb ) , uintptr ( index ) , uintptr ( buffer ) ) } 
func Transform Feedback Buffer Range ( xfb uint 3 2 , index uint 3 2 , buffer uint 3 2 , offset int , size int ) { syscall . Syscall 6 ( gp Transform Feedback Buffer Range , 5 , uintptr ( xfb ) , uintptr ( index ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( size ) , 0 ) } 
func Uniform 1f ( location int 3 2 , v 0 float 3 2 ) { syscall . Syscall ( gp Uniform 1f , 2 , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , 0 ) } 
func Uniform 1fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall ( gp Uniform 1fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 1i ( location int 3 2 , v 0 int 3 2 ) { syscall . Syscall ( gp Uniform 1i , 2 , uintptr ( location ) , uintptr ( v 0 ) , 0 ) } 
func Uniform 1iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall ( gp Uniform 1iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 2f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 ) { syscall . Syscall ( gp Uniform 2f , 3 , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) ) } 
func Uniform 2fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall ( gp Uniform 2fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 2i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 ) { syscall . Syscall ( gp Uniform 2i , 3 , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) ) } 
func Uniform 2iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall ( gp Uniform 2iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 3f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 ) { syscall . Syscall 6 ( gp Uniform 3f , 4 , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) , uintptr ( math . Float 3 2bits ( v 2 ) ) , 0 , 0 ) } 
func Uniform 3fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall ( gp Uniform 3fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 3i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 ) { syscall . Syscall 6 ( gp Uniform 3i , 4 , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , 0 , 0 ) } 
func Uniform 3iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall ( gp Uniform 3iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 4f ( location int 3 2 , v 0 float 3 2 , v 1 float 3 2 , v 2 float 3 2 , v 3 float 3 2 ) { syscall . Syscall 6 ( gp Uniform 4f , 5 , uintptr ( location ) , uintptr ( math . Float 3 2bits ( v 0 ) ) , uintptr ( math . Float 3 2bits ( v 1 ) ) , uintptr ( math . Float 3 2bits ( v 2 ) ) , uintptr ( math . Float 3 2bits ( v 3 ) ) , 0 ) } 
func Uniform 4fv ( location int 3 2 , count int 3 2 , value * float 3 2 ) { syscall . Syscall ( gp Uniform 4fv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform 4i ( location int 3 2 , v 0 int 3 2 , v 1 int 3 2 , v 2 int 3 2 , v 3 int 3 2 ) { syscall . Syscall 6 ( gp Uniform 4i , 5 , uintptr ( location ) , uintptr ( v 0 ) , uintptr ( v 1 ) , uintptr ( v 2 ) , uintptr ( v 3 ) , 0 ) } 
func Uniform 4iv ( location int 3 2 , count int 3 2 , value * int 3 2 ) { syscall . Syscall ( gp Uniform 4iv , 3 , uintptr ( location ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( value ) ) ) } 
func Uniform Block Binding ( program uint 3 2 , uniform Block Index uint 3 2 , uniform Block Binding uint 3 2 ) { syscall . Syscall ( gp Uniform Block Binding , 3 , uintptr ( program ) , uintptr ( uniform Block Index ) , uintptr ( uniform Block Binding ) ) } 
func Uniform Matrix 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 2fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 2x 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 2x 3fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 2x 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 2x 4fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 3fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 3x 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 3x 2fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 3x 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 3x 4fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 4fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 4fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 4x 2fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 4x 2fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Uniform Matrix 4x 3fv ( location int 3 2 , count int 3 2 , transpose bool , value * float 3 2 ) { syscall . Syscall 6 ( gp Uniform Matrix 4x 3fv , 4 , uintptr ( location ) , uintptr ( count ) , bool To Uintptr ( transpose ) , uintptr ( unsafe . Pointer ( value ) ) , 0 , 0 ) } 
func Unmap Buffer ( target uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Unmap Buffer , 1 , uintptr ( target ) , 0 , 0 ) return ret ! = 0 } 
func Unmap Named Buffer ( buffer uint 3 2 ) bool { ret , _ , _ : = syscall . Syscall ( gp Unmap Named Buffer , 1 , uintptr ( buffer ) , 0 , 0 ) return ret ! = 0 } 
func Use Program Stages ( pipeline uint 3 2 , stages uint 3 2 , program uint 3 2 ) { syscall . Syscall ( gp Use Program Stages , 3 , uintptr ( pipeline ) , uintptr ( stages ) , uintptr ( program ) ) } 
func Vertex Array Attrib Format ( vaobj uint 3 2 , attribindex uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , relativeoffset uint 3 2 ) { syscall . Syscall 6 ( gp Vertex Array Attrib Format , 6 , uintptr ( vaobj ) , uintptr ( attribindex ) , uintptr ( size ) , uintptr ( xtype ) , bool To Uintptr ( normalized ) , uintptr ( relativeoffset ) ) } 
func Vertex Array Binding Divisor ( vaobj uint 3 2 , bindingindex uint 3 2 , divisor uint 3 2 ) { syscall . Syscall ( gp Vertex Array Binding Divisor , 3 , uintptr ( vaobj ) , uintptr ( bindingindex ) , uintptr ( divisor ) ) } 
func Vertex Array Element Buffer ( vaobj uint 3 2 , buffer uint 3 2 ) { syscall . Syscall ( gp Vertex Array Element Buffer , 2 , uintptr ( vaobj ) , uintptr ( buffer ) , 0 ) } 
func Vertex Array Vertex Buffer ( vaobj uint 3 2 , bindingindex uint 3 2 , buffer uint 3 2 , offset int , stride int 3 2 ) { syscall . Syscall 6 ( gp Vertex Array Vertex Buffer , 5 , uintptr ( vaobj ) , uintptr ( bindingindex ) , uintptr ( buffer ) , uintptr ( offset ) , uintptr ( stride ) , 0 ) } 
func Vertex Array Vertex Buffers ( vaobj uint 3 2 , first uint 3 2 , count int 3 2 , buffers * uint 3 2 , offsets * int , strides * int 3 2 ) { syscall . Syscall 6 ( gp Vertex Array Vertex Buffers , 6 , uintptr ( vaobj ) , uintptr ( first ) , uintptr ( count ) , uintptr ( unsafe . Pointer ( buffers ) ) , uintptr ( unsafe . Pointer ( offsets ) ) , uintptr ( unsafe . Pointer ( strides ) ) ) } 
func Vertex Attrib Binding ( attribindex uint 3 2 , bindingindex uint 3 2 ) { syscall . Syscall ( gp Vertex Attrib Binding , 2 , uintptr ( attribindex ) , uintptr ( bindingindex ) , 0 ) } 
func Vertex Attrib Format ( attribindex uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , relativeoffset uint 3 2 ) { syscall . Syscall 6 ( gp Vertex Attrib Format , 5 , uintptr ( attribindex ) , uintptr ( size ) , uintptr ( xtype ) , bool To Uintptr ( normalized ) , uintptr ( relativeoffset ) , 0 ) } 
func Vertex Attrib Pointer ( index uint 3 2 , size int 3 2 , xtype uint 3 2 , normalized bool , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall 6 ( gp Vertex Attrib Pointer , 6 , uintptr ( index ) , uintptr ( size ) , uintptr ( xtype ) , bool To Uintptr ( normalized ) , uintptr ( stride ) , uintptr ( pointer ) ) } 
func Vertex Binding Divisor ( bindingindex uint 3 2 , divisor uint 3 2 ) { syscall . Syscall ( gp Vertex Binding Divisor , 2 , uintptr ( bindingindex ) , uintptr ( divisor ) , 0 ) } 
func Vertex Pointer ( size int 3 2 , xtype uint 3 2 , stride int 3 2 , pointer unsafe . Pointer ) { syscall . Syscall 6 ( gp Vertex Pointer , 4 , uintptr ( size ) , uintptr ( xtype ) , uintptr ( stride ) , uintptr ( pointer ) , 0 , 0 ) } 
func Viewport ( x int 3 2 , y int 3 2 , width int 3 2 , height int 3 2 ) { syscall . Syscall 6 ( gp Viewport , 4 , uintptr ( x ) , uintptr ( y ) , uintptr ( width ) , uintptr ( height ) , 0 , 0 ) } 
func Wait Sync ( sync uintptr , flags uint 3 2 , timeout uint 6 4 ) { syscall . Syscall ( gp Wait Sync , 3 , uintptr ( sync ) , uintptr ( flags ) , uintptr ( timeout ) ) } 
func Init With Proc Addr Func ( get Proc Addr func ( name string ) unsafe . Pointer ) error { gp Accum = uintptr ( get Proc Addr ( " " ) ) if gp Accum = = 0 { return errors . New ( " " ) } gp Accumx OES = uintptr ( get Proc Addr ( " " ) ) gp Acquire Keyed Mutex Win 3 2EXT = uintptr ( get Proc Addr ( " " ) ) gp Active Program EXT = uintptr ( get Proc Addr ( " " ) ) gp Active Shader Program = uintptr ( get Proc Addr ( " " ) ) gp Active Shader Program EXT = uintptr ( get Proc Addr ( " " ) ) gp Active Stencil Face EXT = uintptr ( get Proc Addr ( " " ) ) gp Active Texture = uintptr ( get Proc Addr ( " " ) ) if gp Active Texture = = 0 { return errors . New ( " " ) } gp Active Texture ARB = uintptr ( get Proc Addr ( " " ) ) gp Active Varying NV = uintptr ( get Proc Addr ( " " ) ) gp Alpha Fragment Op 1ATI = uintptr ( get Proc Addr ( " " ) ) gp Alpha Fragment Op 2ATI = uintptr ( get Proc Addr ( " " ) ) gp Alpha Fragment Op 3ATI = uintptr ( get Proc Addr ( " " ) ) gp Alpha Func = uintptr ( get Proc Addr ( " " ) ) if gp Alpha Func = = 0 { return errors . New ( " " ) } gp Alpha Funcx OES = uintptr ( get Proc Addr ( " " ) ) gp Alpha To Coverage Dither Control NV = uintptr ( get Proc Addr ( " " ) ) gp Apply Framebuffer Attachment CMAAINTEL = uintptr ( get Proc Addr ( " " ) ) gp Apply Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Are Programs Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Are Textures Resident = uintptr ( get Proc Addr ( " " ) ) if gp Are Textures Resident = = 0 { return errors . New ( " " ) } gp Are Textures Resident EXT = uintptr ( get Proc Addr ( " " ) ) gp Array Element = uintptr ( get Proc Addr ( " " ) ) if gp Array Element = = 0 { return errors . New ( " " ) } gp Array Element EXT = uintptr ( get Proc Addr ( " " ) ) gp Array Object ATI = uintptr ( get Proc Addr ( " " ) ) gp Async Marker SGIX = uintptr ( get Proc Addr ( " " ) ) gp Attach Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Attach Shader = uintptr ( get Proc Addr ( " " ) ) if gp Attach Shader = = 0 { return errors . New ( " " ) } gp Begin = uintptr ( get Proc Addr ( " " ) ) if gp Begin = = 0 { return errors . New ( " " ) } gp Begin Conditional Render NV = uintptr ( get Proc Addr ( " " ) ) gp Begin Conditional Render NVX = uintptr ( get Proc Addr ( " " ) ) gp Begin Fragment Shader ATI = uintptr ( get Proc Addr ( " " ) ) gp Begin Occlusion Query NV = uintptr ( get Proc Addr ( " " ) ) gp Begin Perf Monitor AMD = uintptr ( get Proc Addr ( " " ) ) gp Begin Perf Query INTEL = uintptr ( get Proc Addr ( " " ) ) gp Begin Query = uintptr ( get Proc Addr ( " " ) ) if gp Begin Query = = 0 { return errors . New ( " " ) } gp Begin Query ARB = uintptr ( get Proc Addr ( " " ) ) gp Begin Query Indexed = uintptr ( get Proc Addr ( " " ) ) gp Begin Transform Feedback EXT = uintptr ( get Proc Addr ( " " ) ) gp Begin Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Begin Vertex Shader EXT = uintptr ( get Proc Addr ( " " ) ) gp Begin Video Capture NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Attrib Location = uintptr ( get Proc Addr ( " " ) ) if gp Bind Attrib Location = = 0 { return errors . New ( " " ) } gp Bind Attrib Location ARB = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Bind Buffer = = 0 { return errors . New ( " " ) } gp Bind Buffer ARB = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Base = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Base EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Base NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Offset NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Range EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffer Range NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffers Base = uintptr ( get Proc Addr ( " " ) ) gp Bind Buffers Range = uintptr ( get Proc Addr ( " " ) ) gp Bind Frag Data Location EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Frag Data Location Indexed = uintptr ( get Proc Addr ( " " ) ) gp Bind Fragment Shader ATI = uintptr ( get Proc Addr ( " " ) ) gp Bind Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Bind Framebuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Image Texture = uintptr ( get Proc Addr ( " " ) ) gp Bind Image Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Image Textures = uintptr ( get Proc Addr ( " " ) ) gp Bind Light Parameter EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Material Parameter EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Multi Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Parameter EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Program ARB = uintptr ( get Proc Addr ( " " ) ) gp Bind Program NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Program Pipeline = uintptr ( get Proc Addr ( " " ) ) gp Bind Program Pipeline EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Renderbuffer = uintptr ( get Proc Addr ( " " ) ) gp Bind Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Sampler = uintptr ( get Proc Addr ( " " ) ) gp Bind Samplers = uintptr ( get Proc Addr ( " " ) ) gp Bind Tex Gen Parameter EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Texture = uintptr ( get Proc Addr ( " " ) ) if gp Bind Texture = = 0 { return errors . New ( " " ) } gp Bind Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Texture Unit = uintptr ( get Proc Addr ( " " ) ) gp Bind Texture Unit Parameter EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Textures = uintptr ( get Proc Addr ( " " ) ) gp Bind Transform Feedback = uintptr ( get Proc Addr ( " " ) ) gp Bind Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Vertex Array = uintptr ( get Proc Addr ( " " ) ) gp Bind Vertex Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Bind Vertex Buffer = uintptr ( get Proc Addr ( " " ) ) gp Bind Vertex Buffers = uintptr ( get Proc Addr ( " " ) ) gp Bind Vertex Shader EXT = uintptr ( get Proc Addr ( " " ) ) gp Bind Video Capture Stream Buffer NV = uintptr ( get Proc Addr ( " " ) ) gp Bind Video Capture Stream Texture NV = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3b EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3bv EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3d EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3f EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3i EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3s EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal 3sv EXT = uintptr ( get Proc Addr ( " " ) ) gp Binormal Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Bitmap = uintptr ( get Proc Addr ( " " ) ) if gp Bitmap = = 0 { return errors . New ( " " ) } gp Bitmapx OES = uintptr ( get Proc Addr ( " " ) ) gp Blend Barrier KHR = uintptr ( get Proc Addr ( " " ) ) gp Blend Barrier NV = uintptr ( get Proc Addr ( " " ) ) gp Blend Color = uintptr ( get Proc Addr ( " " ) ) if gp Blend Color = = 0 { return errors . New ( " " ) } gp Blend Color EXT = uintptr ( get Proc Addr ( " " ) ) gp Blend Colorx OES = uintptr ( get Proc Addr ( " " ) ) gp Blend Equation = uintptr ( get Proc Addr ( " " ) ) if gp Blend Equation = = 0 { return errors . New ( " " ) } gp Blend Equation EXT = uintptr ( get Proc Addr ( " " ) ) gp Blend Equation Indexed AMD = uintptr ( get Proc Addr ( " " ) ) gp Blend Equation Separate = uintptr ( get Proc Addr ( " " ) ) if gp Blend Equation Separate = = 0 { return errors . New ( " " ) } gp Blend Equation Separate EXT = uintptr ( get Proc Addr ( " " ) ) gp Blend Equation Separate Indexed AMD = uintptr ( get Proc Addr ( " " ) ) gp Blend Equation Separatei ARB = uintptr ( get Proc Addr ( " " ) ) gp Blend Equationi ARB = uintptr ( get Proc Addr ( " " ) ) gp Blend Func = uintptr ( get Proc Addr ( " " ) ) if gp Blend Func = = 0 { return errors . New ( " " ) } gp Blend Func Indexed AMD = uintptr ( get Proc Addr ( " " ) ) gp Blend Func Separate = uintptr ( get Proc Addr ( " " ) ) if gp Blend Func Separate = = 0 { return errors . New ( " " ) } gp Blend Func Separate EXT = uintptr ( get Proc Addr ( " " ) ) gp Blend Func Separate INGR = uintptr ( get Proc Addr ( " " ) ) gp Blend Func Separate Indexed AMD = uintptr ( get Proc Addr ( " " ) ) gp Blend Func Separatei ARB = uintptr ( get Proc Addr ( " " ) ) gp Blend Funci ARB = uintptr ( get Proc Addr ( " " ) ) gp Blend Parameteri NV = uintptr ( get Proc Addr ( " " ) ) gp Blit Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Blit Framebuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Blit Named Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Buffer Address Range NV = uintptr ( get Proc Addr ( " " ) ) gp Buffer Data = uintptr ( get Proc Addr ( " " ) ) if gp Buffer Data = = 0 { return errors . New ( " " ) } gp Buffer Data ARB = uintptr ( get Proc Addr ( " " ) ) gp Buffer Page Commitment ARB = uintptr ( get Proc Addr ( " " ) ) gp Buffer Parameteri APPLE = uintptr ( get Proc Addr ( " " ) ) gp Buffer Storage = uintptr ( get Proc Addr ( " " ) ) gp Buffer Storage External EXT = uintptr ( get Proc Addr ( " " ) ) gp Buffer Storage Mem EXT = uintptr ( get Proc Addr ( " " ) ) gp Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) if gp Buffer Sub Data = = 0 { return errors . New ( " " ) } gp Buffer Sub Data ARB = uintptr ( get Proc Addr ( " " ) ) gp Call Command List NV = uintptr ( get Proc Addr ( " " ) ) gp Call List = uintptr ( get Proc Addr ( " " ) ) if gp Call List = = 0 { return errors . New ( " " ) } gp Call Lists = uintptr ( get Proc Addr ( " " ) ) if gp Call Lists = = 0 { return errors . New ( " " ) } gp Check Framebuffer Status = uintptr ( get Proc Addr ( " " ) ) gp Check Framebuffer Status EXT = uintptr ( get Proc Addr ( " " ) ) gp Check Named Framebuffer Status = uintptr ( get Proc Addr ( " " ) ) gp Check Named Framebuffer Status EXT = uintptr ( get Proc Addr ( " " ) ) gp Clamp Color ARB = uintptr ( get Proc Addr ( " " ) ) gp Clear = uintptr ( get Proc Addr ( " " ) ) if gp Clear = = 0 { return errors . New ( " " ) } gp Clear Accum = uintptr ( get Proc Addr ( " " ) ) if gp Clear Accum = = 0 { return errors . New ( " " ) } gp Clear Accumx OES = uintptr ( get Proc Addr ( " " ) ) gp Clear Buffer Data = uintptr ( get Proc Addr ( " " ) ) gp Clear Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Clear Color = uintptr ( get Proc Addr ( " " ) ) if gp Clear Color = = 0 { return errors . New ( " " ) } gp Clear Color Ii EXT = uintptr ( get Proc Addr ( " " ) ) gp Clear Color Iui EXT = uintptr ( get Proc Addr ( " " ) ) gp Clear Colorx OES = uintptr ( get Proc Addr ( " " ) ) gp Clear Depth = uintptr ( get Proc Addr ( " " ) ) if gp Clear Depth = = 0 { return errors . New ( " " ) } gp Clear Depthd NV = uintptr ( get Proc Addr ( " " ) ) gp Clear Depthf = uintptr ( get Proc Addr ( " " ) ) gp Clear Depthf OES = uintptr ( get Proc Addr ( " " ) ) gp Clear Depthx OES = uintptr ( get Proc Addr ( " " ) ) gp Clear Index = uintptr ( get Proc Addr ( " " ) ) if gp Clear Index = = 0 { return errors . New ( " " ) } gp Clear Named Buffer Data = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Buffer Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Buffer Sub Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Framebufferfi = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Framebufferfv = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Framebufferiv = uintptr ( get Proc Addr ( " " ) ) gp Clear Named Framebufferuiv = uintptr ( get Proc Addr ( " " ) ) gp Clear Stencil = uintptr ( get Proc Addr ( " " ) ) if gp Clear Stencil = = 0 { return errors . New ( " " ) } gp Clear Tex Image = uintptr ( get Proc Addr ( " " ) ) gp Clear Tex Sub Image = uintptr ( get Proc Addr ( " " ) ) gp Client Active Texture = uintptr ( get Proc Addr ( " " ) ) if gp Client Active Texture = = 0 { return errors . New ( " " ) } gp Client Active Texture ARB = uintptr ( get Proc Addr ( " " ) ) gp Client Active Vertex Stream ATI = uintptr ( get Proc Addr ( " " ) ) gp Client Attrib Default EXT = uintptr ( get Proc Addr ( " " ) ) gp Client Wait Sync = uintptr ( get Proc Addr ( " " ) ) gp Clip Control = uintptr ( get Proc Addr ( " " ) ) gp Clip Plane = uintptr ( get Proc Addr ( " " ) ) if gp Clip Plane = = 0 { return errors . New ( " " ) } gp Clip Planef OES = uintptr ( get Proc Addr ( " " ) ) gp Clip Planex OES = uintptr ( get Proc Addr ( " " ) ) gp Color 3b = uintptr ( get Proc Addr ( " " ) ) if gp Color 3b = = 0 { return errors . New ( " " ) } gp Color 3bv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3bv = = 0 { return errors . New ( " " ) } gp Color 3d = uintptr ( get Proc Addr ( " " ) ) if gp Color 3d = = 0 { return errors . New ( " " ) } gp Color 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3dv = = 0 { return errors . New ( " " ) } gp Color 3f = uintptr ( get Proc Addr ( " " ) ) if gp Color 3f = = 0 { return errors . New ( " " ) } gp Color 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3fv = = 0 { return errors . New ( " " ) } gp Color 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Color 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Color 3i = uintptr ( get Proc Addr ( " " ) ) if gp Color 3i = = 0 { return errors . New ( " " ) } gp Color 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3iv = = 0 { return errors . New ( " " ) } gp Color 3s = uintptr ( get Proc Addr ( " " ) ) if gp Color 3s = = 0 { return errors . New ( " " ) } gp Color 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3sv = = 0 { return errors . New ( " " ) } gp Color 3ub = uintptr ( get Proc Addr ( " " ) ) if gp Color 3ub = = 0 { return errors . New ( " " ) } gp Color 3ubv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3ubv = = 0 { return errors . New ( " " ) } gp Color 3ui = uintptr ( get Proc Addr ( " " ) ) if gp Color 3ui = = 0 { return errors . New ( " " ) } gp Color 3uiv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3uiv = = 0 { return errors . New ( " " ) } gp Color 3us = uintptr ( get Proc Addr ( " " ) ) if gp Color 3us = = 0 { return errors . New ( " " ) } gp Color 3usv = uintptr ( get Proc Addr ( " " ) ) if gp Color 3usv = = 0 { return errors . New ( " " ) } gp Color 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Color 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Color 4b = uintptr ( get Proc Addr ( " " ) ) if gp Color 4b = = 0 { return errors . New ( " " ) } gp Color 4bv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4bv = = 0 { return errors . New ( " " ) } gp Color 4d = uintptr ( get Proc Addr ( " " ) ) if gp Color 4d = = 0 { return errors . New ( " " ) } gp Color 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4dv = = 0 { return errors . New ( " " ) } gp Color 4f = uintptr ( get Proc Addr ( " " ) ) if gp Color 4f = = 0 { return errors . New ( " " ) } gp Color 4f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4fv = = 0 { return errors . New ( " " ) } gp Color 4h NV = uintptr ( get Proc Addr ( " " ) ) gp Color 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Color 4i = uintptr ( get Proc Addr ( " " ) ) if gp Color 4i = = 0 { return errors . New ( " " ) } gp Color 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4iv = = 0 { return errors . New ( " " ) } gp Color 4s = uintptr ( get Proc Addr ( " " ) ) if gp Color 4s = = 0 { return errors . New ( " " ) } gp Color 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4sv = = 0 { return errors . New ( " " ) } gp Color 4ub = uintptr ( get Proc Addr ( " " ) ) if gp Color 4ub = = 0 { return errors . New ( " " ) } gp Color 4ub Vertex 2f SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4ub Vertex 2fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4ub Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4ub Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Color 4ubv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4ubv = = 0 { return errors . New ( " " ) } gp Color 4ui = uintptr ( get Proc Addr ( " " ) ) if gp Color 4ui = = 0 { return errors . New ( " " ) } gp Color 4uiv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4uiv = = 0 { return errors . New ( " " ) } gp Color 4us = uintptr ( get Proc Addr ( " " ) ) if gp Color 4us = = 0 { return errors . New ( " " ) } gp Color 4usv = uintptr ( get Proc Addr ( " " ) ) if gp Color 4usv = = 0 { return errors . New ( " " ) } gp Color 4x OES = uintptr ( get Proc Addr ( " " ) ) gp Color 4xv OES = uintptr ( get Proc Addr ( " " ) ) gp Color Format NV = uintptr ( get Proc Addr ( " " ) ) gp Color Fragment Op 1ATI = uintptr ( get Proc Addr ( " " ) ) gp Color Fragment Op 2ATI = uintptr ( get Proc Addr ( " " ) ) gp Color Fragment Op 3ATI = uintptr ( get Proc Addr ( " " ) ) gp Color Mask = uintptr ( get Proc Addr ( " " ) ) if gp Color Mask = = 0 { return errors . New ( " " ) } gp Color Mask Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Color Material = uintptr ( get Proc Addr ( " " ) ) if gp Color Material = = 0 { return errors . New ( " " ) } gp Color Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Color Pointer = = 0 { return errors . New ( " " ) } gp Color Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Color Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Color Pointerv INTEL = uintptr ( get Proc Addr ( " " ) ) gp Color Sub Table EXT = uintptr ( get Proc Addr ( " " ) ) gp Color Table EXT = uintptr ( get Proc Addr ( " " ) ) gp Color Table Parameterfv SGI = uintptr ( get Proc Addr ( " " ) ) gp Color Table Parameteriv SGI = uintptr ( get Proc Addr ( " " ) ) gp Color Table SGI = uintptr ( get Proc Addr ( " " ) ) gp Combiner Input NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Output NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Parameterf NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Parameteri NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Combiner Stage Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Command List Segments NV = uintptr ( get Proc Addr ( " " ) ) gp Compile Command List NV = uintptr ( get Proc Addr ( " " ) ) gp Compile Shader = uintptr ( get Proc Addr ( " " ) ) if gp Compile Shader = = 0 { return errors . New ( " " ) } gp Compile Shader ARB = uintptr ( get Proc Addr ( " " ) ) gp Compile Shader Include ARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Multi Tex Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Image 1D = = 0 { return errors . New ( " " ) } gp Compressed Tex Image 1DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Image 2D = = 0 { return errors . New ( " " ) } gp Compressed Tex Image 2DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Image 3D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Image 3D = = 0 { return errors . New ( " " ) } gp Compressed Tex Image 3DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Sub Image 1D = = 0 { return errors . New ( " " ) } gp Compressed Tex Sub Image 1DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Sub Image 2D = = 0 { return errors . New ( " " ) } gp Compressed Tex Sub Image 2DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Tex Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) if gp Compressed Tex Sub Image 3D = = 0 { return errors . New ( " " ) } gp Compressed Tex Sub Image 3DARB = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) gp Compressed Texture Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Conservative Raster Parameterf NV = uintptr ( get Proc Addr ( " " ) ) gp Conservative Raster Parameteri NV = uintptr ( get Proc Addr ( " " ) ) gp Convolution Filter 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Filter 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameterf EXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameterx OES = uintptr ( get Proc Addr ( " " ) ) gp Convolution Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Copy Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Copy Color Sub Table EXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Color Table SGI = uintptr ( get Proc Addr ( " " ) ) gp Copy Convolution Filter 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Convolution Filter 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Image Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Copy Image Sub Data NV = uintptr ( get Proc Addr ( " " ) ) gp Copy Multi Tex Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Multi Tex Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Multi Tex Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Multi Tex Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Multi Tex Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Named Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Copy Path NV = uintptr ( get Proc Addr ( " " ) ) gp Copy Pixels = uintptr ( get Proc Addr ( " " ) ) if gp Copy Pixels = = 0 { return errors . New ( " " ) } gp Copy Tex Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Copy Tex Image 1D = = 0 { return errors . New ( " " ) } gp Copy Tex Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Tex Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Copy Tex Image 2D = = 0 { return errors . New ( " " ) } gp Copy Tex Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Tex Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Copy Tex Sub Image 1D = = 0 { return errors . New ( " " ) } gp Copy Tex Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Tex Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Copy Tex Sub Image 2D = = 0 { return errors . New ( " " ) } gp Copy Tex Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Tex Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) if gp Copy Tex Sub Image 3D = = 0 { return errors . New ( " " ) } gp Copy Tex Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) gp Copy Texture Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Cover Fill Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Cover Fill Path NV = uintptr ( get Proc Addr ( " " ) ) gp Cover Stroke Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Cover Stroke Path NV = uintptr ( get Proc Addr ( " " ) ) gp Coverage Modulation NV = uintptr ( get Proc Addr ( " " ) ) gp Coverage Modulation Table NV = uintptr ( get Proc Addr ( " " ) ) gp Create Buffers = uintptr ( get Proc Addr ( " " ) ) gp Create Command Lists NV = uintptr ( get Proc Addr ( " " ) ) gp Create Framebuffers = uintptr ( get Proc Addr ( " " ) ) gp Create Memory Objects EXT = uintptr ( get Proc Addr ( " " ) ) gp Create Perf Query INTEL = uintptr ( get Proc Addr ( " " ) ) gp Create Program = uintptr ( get Proc Addr ( " " ) ) if gp Create Program = = 0 { return errors . New ( " " ) } gp Create Program Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Create Program Pipelines = uintptr ( get Proc Addr ( " " ) ) gp Create Queries = uintptr ( get Proc Addr ( " " ) ) gp Create Renderbuffers = uintptr ( get Proc Addr ( " " ) ) gp Create Samplers = uintptr ( get Proc Addr ( " " ) ) gp Create Shader = uintptr ( get Proc Addr ( " " ) ) if gp Create Shader = = 0 { return errors . New ( " " ) } gp Create Shader Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Create Shader Program EXT = uintptr ( get Proc Addr ( " " ) ) gp Create Shader Programv = uintptr ( get Proc Addr ( " " ) ) gp Create Shader Programv EXT = uintptr ( get Proc Addr ( " " ) ) gp Create States NV = uintptr ( get Proc Addr ( " " ) ) gp Create Sync From CLevent ARB = uintptr ( get Proc Addr ( " " ) ) gp Create Textures = uintptr ( get Proc Addr ( " " ) ) gp Create Transform Feedbacks = uintptr ( get Proc Addr ( " " ) ) gp Create Vertex Arrays = uintptr ( get Proc Addr ( " " ) ) gp Cull Face = uintptr ( get Proc Addr ( " " ) ) if gp Cull Face = = 0 { return errors . New ( " " ) } gp Cull Parameterdv EXT = uintptr ( get Proc Addr ( " " ) ) gp Cull Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Current Palette Matrix ARB = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Callback = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Callback AMD = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Callback ARB = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Callback KHR = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Control = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Control ARB = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Control KHR = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Enable AMD = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Insert = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Insert AMD = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Insert ARB = uintptr ( get Proc Addr ( " " ) ) gp Debug Message Insert KHR = uintptr ( get Proc Addr ( " " ) ) gp Deform SGIX = uintptr ( get Proc Addr ( " " ) ) gp Deformation Map 3d SGIX = uintptr ( get Proc Addr ( " " ) ) gp Deformation Map 3f SGIX = uintptr ( get Proc Addr ( " " ) ) gp Delete Async Markers SGIX = uintptr ( get Proc Addr ( " " ) ) gp Delete Buffers = uintptr ( get Proc Addr ( " " ) ) if gp Delete Buffers = = 0 { return errors . New ( " " ) } gp Delete Buffers ARB = uintptr ( get Proc Addr ( " " ) ) gp Delete Command Lists NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Fences APPLE = uintptr ( get Proc Addr ( " " ) ) gp Delete Fences NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Fragment Shader ATI = uintptr ( get Proc Addr ( " " ) ) gp Delete Framebuffers = uintptr ( get Proc Addr ( " " ) ) gp Delete Framebuffers EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Lists = uintptr ( get Proc Addr ( " " ) ) if gp Delete Lists = = 0 { return errors . New ( " " ) } gp Delete Memory Objects EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Named String ARB = uintptr ( get Proc Addr ( " " ) ) gp Delete Names AMD = uintptr ( get Proc Addr ( " " ) ) gp Delete Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Delete Occlusion Queries NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Paths NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Perf Monitors AMD = uintptr ( get Proc Addr ( " " ) ) gp Delete Perf Query INTEL = uintptr ( get Proc Addr ( " " ) ) gp Delete Program = uintptr ( get Proc Addr ( " " ) ) if gp Delete Program = = 0 { return errors . New ( " " ) } gp Delete Program Pipelines = uintptr ( get Proc Addr ( " " ) ) gp Delete Program Pipelines EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Programs ARB = uintptr ( get Proc Addr ( " " ) ) gp Delete Programs NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Queries = uintptr ( get Proc Addr ( " " ) ) if gp Delete Queries = = 0 { return errors . New ( " " ) } gp Delete Queries ARB = uintptr ( get Proc Addr ( " " ) ) gp Delete Query Resource Tag NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Renderbuffers = uintptr ( get Proc Addr ( " " ) ) gp Delete Renderbuffers EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Samplers = uintptr ( get Proc Addr ( " " ) ) gp Delete Semaphores EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Shader = uintptr ( get Proc Addr ( " " ) ) if gp Delete Shader = = 0 { return errors . New ( " " ) } gp Delete States NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Sync = uintptr ( get Proc Addr ( " " ) ) gp Delete Textures = uintptr ( get Proc Addr ( " " ) ) if gp Delete Textures = = 0 { return errors . New ( " " ) } gp Delete Textures EXT = uintptr ( get Proc Addr ( " " ) ) gp Delete Transform Feedbacks = uintptr ( get Proc Addr ( " " ) ) gp Delete Transform Feedbacks NV = uintptr ( get Proc Addr ( " " ) ) gp Delete Vertex Arrays = uintptr ( get Proc Addr ( " " ) ) gp Delete Vertex Arrays APPLE = uintptr ( get Proc Addr ( " " ) ) gp Delete Vertex Shader EXT = uintptr ( get Proc Addr ( " " ) ) gp Depth Bounds EXT = uintptr ( get Proc Addr ( " " ) ) gp Depth Boundsd NV = uintptr ( get Proc Addr ( " " ) ) gp Depth Func = uintptr ( get Proc Addr ( " " ) ) if gp Depth Func = = 0 { return errors . New ( " " ) } gp Depth Mask = uintptr ( get Proc Addr ( " " ) ) if gp Depth Mask = = 0 { return errors . New ( " " ) } gp Depth Range = uintptr ( get Proc Addr ( " " ) ) if gp Depth Range = = 0 { return errors . New ( " " ) } gp Depth Range Arrayv = uintptr ( get Proc Addr ( " " ) ) gp Depth Range Indexed = uintptr ( get Proc Addr ( " " ) ) gp Depth Ranged NV = uintptr ( get Proc Addr ( " " ) ) gp Depth Rangef = uintptr ( get Proc Addr ( " " ) ) gp Depth Rangef OES = uintptr ( get Proc Addr ( " " ) ) gp Depth Rangex OES = uintptr ( get Proc Addr ( " " ) ) gp Detach Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Detach Shader = uintptr ( get Proc Addr ( " " ) ) if gp Detach Shader = = 0 { return errors . New ( " " ) } gp Detail Tex Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Disable = uintptr ( get Proc Addr ( " " ) ) if gp Disable = = 0 { return errors . New ( " " ) } gp Disable Client State = uintptr ( get Proc Addr ( " " ) ) if gp Disable Client State = = 0 { return errors . New ( " " ) } gp Disable Client State Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Client Statei EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Variant Client State EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Vertex Array Attrib = uintptr ( get Proc Addr ( " " ) ) gp Disable Vertex Array Attrib EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Vertex Array EXT = uintptr ( get Proc Addr ( " " ) ) gp Disable Vertex Attrib APPLE = uintptr ( get Proc Addr ( " " ) ) gp Disable Vertex Attrib Array = uintptr ( get Proc Addr ( " " ) ) if gp Disable Vertex Attrib Array = = 0 { return errors . New ( " " ) } gp Disable Vertex Attrib Array ARB = uintptr ( get Proc Addr ( " " ) ) gp Dispatch Compute = uintptr ( get Proc Addr ( " " ) ) gp Dispatch Compute Group Size ARB = uintptr ( get Proc Addr ( " " ) ) gp Dispatch Compute Indirect = uintptr ( get Proc Addr ( " " ) ) gp Draw Arrays = uintptr ( get Proc Addr ( " " ) ) if gp Draw Arrays = = 0 { return errors . New ( " " ) } gp Draw Arrays EXT = uintptr ( get Proc Addr ( " " ) ) gp Draw Arrays Indirect = uintptr ( get Proc Addr ( " " ) ) gp Draw Arrays Instanced ARB = uintptr ( get Proc Addr ( " " ) ) gp Draw Arrays Instanced Base Instance = uintptr ( get Proc Addr ( " " ) ) gp Draw Arrays Instanced EXT = uintptr ( get Proc Addr ( " " ) ) gp Draw Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Draw Buffer = = 0 { return errors . New ( " " ) } gp Draw Buffers = uintptr ( get Proc Addr ( " " ) ) if gp Draw Buffers = = 0 { return errors . New ( " " ) } gp Draw Buffers ARB = uintptr ( get Proc Addr ( " " ) ) gp Draw Buffers ATI = uintptr ( get Proc Addr ( " " ) ) gp Draw Commands Address NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Commands NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Commands States Address NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Commands States NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Element Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Draw Element Array ATI = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements = uintptr ( get Proc Addr ( " " ) ) if gp Draw Elements = = 0 { return errors . New ( " " ) } gp Draw Elements Base Vertex = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Indirect = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Instanced ARB = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Instanced Base Instance = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Instanced Base Vertex = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Instanced Base Vertex Base Instance = uintptr ( get Proc Addr ( " " ) ) gp Draw Elements Instanced EXT = uintptr ( get Proc Addr ( " " ) ) gp Draw Mesh Arrays SUN = uintptr ( get Proc Addr ( " " ) ) gp Draw Pixels = uintptr ( get Proc Addr ( " " ) ) if gp Draw Pixels = = 0 { return errors . New ( " " ) } gp Draw Range Element Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Draw Range Element Array ATI = uintptr ( get Proc Addr ( " " ) ) gp Draw Range Elements = uintptr ( get Proc Addr ( " " ) ) if gp Draw Range Elements = = 0 { return errors . New ( " " ) } gp Draw Range Elements Base Vertex = uintptr ( get Proc Addr ( " " ) ) gp Draw Range Elements EXT = uintptr ( get Proc Addr ( " " ) ) gp Draw Texture NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Transform Feedback = uintptr ( get Proc Addr ( " " ) ) gp Draw Transform Feedback Instanced = uintptr ( get Proc Addr ( " " ) ) gp Draw Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Draw Transform Feedback Stream = uintptr ( get Proc Addr ( " " ) ) gp Draw Transform Feedback Stream Instanced = uintptr ( get Proc Addr ( " " ) ) gp Draw Vk Image NV = uintptr ( get Proc Addr ( " " ) ) gp EGLImage Target Tex Storage EXT = uintptr ( get Proc Addr ( " " ) ) gp EGLImage Target Texture Storage EXT = uintptr ( get Proc Addr ( " " ) ) gp Edge Flag = uintptr ( get Proc Addr ( " " ) ) if gp Edge Flag = = 0 { return errors . New ( " " ) } gp Edge Flag Format NV = uintptr ( get Proc Addr ( " " ) ) gp Edge Flag Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Edge Flag Pointer = = 0 { return errors . New ( " " ) } gp Edge Flag Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Edge Flag Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Edge Flagv = uintptr ( get Proc Addr ( " " ) ) if gp Edge Flagv = = 0 { return errors . New ( " " ) } gp Element Pointer APPLE = uintptr ( get Proc Addr ( " " ) ) gp Element Pointer ATI = uintptr ( get Proc Addr ( " " ) ) gp Enable = uintptr ( get Proc Addr ( " " ) ) if gp Enable = = 0 { return errors . New ( " " ) } gp Enable Client State = uintptr ( get Proc Addr ( " " ) ) if gp Enable Client State = = 0 { return errors . New ( " " ) } gp Enable Client State Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Client Statei EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Variant Client State EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Vertex Array Attrib = uintptr ( get Proc Addr ( " " ) ) gp Enable Vertex Array Attrib EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Vertex Array EXT = uintptr ( get Proc Addr ( " " ) ) gp Enable Vertex Attrib APPLE = uintptr ( get Proc Addr ( " " ) ) gp Enable Vertex Attrib Array = uintptr ( get Proc Addr ( " " ) ) if gp Enable Vertex Attrib Array = = 0 { return errors . New ( " " ) } gp Enable Vertex Attrib Array ARB = uintptr ( get Proc Addr ( " " ) ) gp End = uintptr ( get Proc Addr ( " " ) ) if gp End = = 0 { return errors . New ( " " ) } gp End Conditional Render NV = uintptr ( get Proc Addr ( " " ) ) gp End Conditional Render NVX = uintptr ( get Proc Addr ( " " ) ) gp End Fragment Shader ATI = uintptr ( get Proc Addr ( " " ) ) gp End List = uintptr ( get Proc Addr ( " " ) ) if gp End List = = 0 { return errors . New ( " " ) } gp End Occlusion Query NV = uintptr ( get Proc Addr ( " " ) ) gp End Perf Monitor AMD = uintptr ( get Proc Addr ( " " ) ) gp End Perf Query INTEL = uintptr ( get Proc Addr ( " " ) ) gp End Query = uintptr ( get Proc Addr ( " " ) ) if gp End Query = = 0 { return errors . New ( " " ) } gp End Query ARB = uintptr ( get Proc Addr ( " " ) ) gp End Query Indexed = uintptr ( get Proc Addr ( " " ) ) gp End Transform Feedback EXT = uintptr ( get Proc Addr ( " " ) ) gp End Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp End Vertex Shader EXT = uintptr ( get Proc Addr ( " " ) ) gp End Video Capture NV = uintptr ( get Proc Addr ( " " ) ) gp Eval Coord 1d = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 1d = = 0 { return errors . New ( " " ) } gp Eval Coord 1dv = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 1dv = = 0 { return errors . New ( " " ) } gp Eval Coord 1f = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 1f = = 0 { return errors . New ( " " ) } gp Eval Coord 1fv = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 1fv = = 0 { return errors . New ( " " ) } gp Eval Coord 1x OES = uintptr ( get Proc Addr ( " " ) ) gp Eval Coord 1xv OES = uintptr ( get Proc Addr ( " " ) ) gp Eval Coord 2d = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 2d = = 0 { return errors . New ( " " ) } gp Eval Coord 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 2dv = = 0 { return errors . New ( " " ) } gp Eval Coord 2f = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 2f = = 0 { return errors . New ( " " ) } gp Eval Coord 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Eval Coord 2fv = = 0 { return errors . New ( " " ) } gp Eval Coord 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Eval Coord 2xv OES = uintptr ( get Proc Addr ( " " ) ) gp Eval Maps NV = uintptr ( get Proc Addr ( " " ) ) gp Eval Mesh 1 = uintptr ( get Proc Addr ( " " ) ) if gp Eval Mesh 1 = = 0 { return errors . New ( " " ) } gp Eval Mesh 2 = uintptr ( get Proc Addr ( " " ) ) if gp Eval Mesh 2 = = 0 { return errors . New ( " " ) } gp Eval Point 1 = uintptr ( get Proc Addr ( " " ) ) if gp Eval Point 1 = = 0 { return errors . New ( " " ) } gp Eval Point 2 = uintptr ( get Proc Addr ( " " ) ) if gp Eval Point 2 = = 0 { return errors . New ( " " ) } gp Evaluate Depth Values ARB = uintptr ( get Proc Addr ( " " ) ) gp Execute Program NV = uintptr ( get Proc Addr ( " " ) ) gp Extract Component EXT = uintptr ( get Proc Addr ( " " ) ) gp Feedback Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Feedback Buffer = = 0 { return errors . New ( " " ) } gp Feedback Bufferx OES = uintptr ( get Proc Addr ( " " ) ) gp Fence Sync = uintptr ( get Proc Addr ( " " ) ) gp Final Combiner Input NV = uintptr ( get Proc Addr ( " " ) ) gp Finish = uintptr ( get Proc Addr ( " " ) ) if gp Finish = = 0 { return errors . New ( " " ) } gp Finish Async SGIX = uintptr ( get Proc Addr ( " " ) ) gp Finish Fence APPLE = uintptr ( get Proc Addr ( " " ) ) gp Finish Fence NV = uintptr ( get Proc Addr ( " " ) ) gp Finish Object APPLE = uintptr ( get Proc Addr ( " " ) ) gp Finish Texture SUNX = uintptr ( get Proc Addr ( " " ) ) gp Flush = uintptr ( get Proc Addr ( " " ) ) if gp Flush = = 0 { return errors . New ( " " ) } gp Flush Mapped Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Flush Mapped Buffer Range APPLE = uintptr ( get Proc Addr ( " " ) ) gp Flush Mapped Named Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Flush Mapped Named Buffer Range EXT = uintptr ( get Proc Addr ( " " ) ) gp Flush Pixel Data Range NV = uintptr ( get Proc Addr ( " " ) ) gp Flush Raster SGIX = uintptr ( get Proc Addr ( " " ) ) gp Flush Static Data IBM = uintptr ( get Proc Addr ( " " ) ) gp Flush Vertex Array Range APPLE = uintptr ( get Proc Addr ( " " ) ) gp Flush Vertex Array Range NV = uintptr ( get Proc Addr ( " " ) ) gp Fog Coord Format NV = uintptr ( get Proc Addr ( " " ) ) gp Fog Coord Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Fog Coord Pointer = = 0 { return errors . New ( " " ) } gp Fog Coord Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Fog Coord Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Fog Coordd = uintptr ( get Proc Addr ( " " ) ) if gp Fog Coordd = = 0 { return errors . New ( " " ) } gp Fog Coordd EXT = uintptr ( get Proc Addr ( " " ) ) gp Fog Coorddv = uintptr ( get Proc Addr ( " " ) ) if gp Fog Coorddv = = 0 { return errors . New ( " " ) } gp Fog Coorddv EXT = uintptr ( get Proc Addr ( " " ) ) gp Fog Coordf = uintptr ( get Proc Addr ( " " ) ) if gp Fog Coordf = = 0 { return errors . New ( " " ) } gp Fog Coordf EXT = uintptr ( get Proc Addr ( " " ) ) gp Fog Coordfv = uintptr ( get Proc Addr ( " " ) ) if gp Fog Coordfv = = 0 { return errors . New ( " " ) } gp Fog Coordfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Fog Coordh NV = uintptr ( get Proc Addr ( " " ) ) gp Fog Coordhv NV = uintptr ( get Proc Addr ( " " ) ) gp Fog Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Fogf = uintptr ( get Proc Addr ( " " ) ) if gp Fogf = = 0 { return errors . New ( " " ) } gp Fogfv = uintptr ( get Proc Addr ( " " ) ) if gp Fogfv = = 0 { return errors . New ( " " ) } gp Fogi = uintptr ( get Proc Addr ( " " ) ) if gp Fogi = = 0 { return errors . New ( " " ) } gp Fogiv = uintptr ( get Proc Addr ( " " ) ) if gp Fogiv = = 0 { return errors . New ( " " ) } gp Fogx OES = uintptr ( get Proc Addr ( " " ) ) gp Fogxv OES = uintptr ( get Proc Addr ( " " ) ) gp Fragment Color Material SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Coverage Color NV = uintptr ( get Proc Addr ( " " ) ) gp Fragment Light Modelf SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Light Modelfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Light Modeli SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Light Modeliv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Lightf SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Lightfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Lighti SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Lightiv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Materialf SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Materialfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Materiali SGIX = uintptr ( get Proc Addr ( " " ) ) gp Fragment Materialiv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Frame Terminator GREMEDY = uintptr ( get Proc Addr ( " " ) ) gp Frame Zoom SGIX = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Draw Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Draw Buffers EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Fetch Barrier EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Read Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Renderbuffer = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Sample Locationsfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Sample Locationsfv NV = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Sample Positionsfv AMD = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 1D = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 2D = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 3D = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture ARB = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Face ARB = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Face EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Layer = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Layer ARB = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Layer EXT = uintptr ( get Proc Addr ( " " ) ) gp Framebuffer Texture Multiview OVR = uintptr ( get Proc Addr ( " " ) ) gp Free Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Front Face = uintptr ( get Proc Addr ( " " ) ) if gp Front Face = = 0 { return errors . New ( " " ) } gp Frustum = uintptr ( get Proc Addr ( " " ) ) if gp Frustum = = 0 { return errors . New ( " " ) } gp Frustumf OES = uintptr ( get Proc Addr ( " " ) ) gp Frustumx OES = uintptr ( get Proc Addr ( " " ) ) gp Gen Async Markers SGIX = uintptr ( get Proc Addr ( " " ) ) gp Gen Buffers = uintptr ( get Proc Addr ( " " ) ) if gp Gen Buffers = = 0 { return errors . New ( " " ) } gp Gen Buffers ARB = uintptr ( get Proc Addr ( " " ) ) gp Gen Fences APPLE = uintptr ( get Proc Addr ( " " ) ) gp Gen Fences NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Fragment Shaders ATI = uintptr ( get Proc Addr ( " " ) ) gp Gen Framebuffers = uintptr ( get Proc Addr ( " " ) ) gp Gen Framebuffers EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Lists = uintptr ( get Proc Addr ( " " ) ) if gp Gen Lists = = 0 { return errors . New ( " " ) } gp Gen Names AMD = uintptr ( get Proc Addr ( " " ) ) gp Gen Occlusion Queries NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Paths NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Perf Monitors AMD = uintptr ( get Proc Addr ( " " ) ) gp Gen Program Pipelines = uintptr ( get Proc Addr ( " " ) ) gp Gen Program Pipelines EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Programs ARB = uintptr ( get Proc Addr ( " " ) ) gp Gen Programs NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Queries = uintptr ( get Proc Addr ( " " ) ) if gp Gen Queries = = 0 { return errors . New ( " " ) } gp Gen Queries ARB = uintptr ( get Proc Addr ( " " ) ) gp Gen Query Resource Tag NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Renderbuffers = uintptr ( get Proc Addr ( " " ) ) gp Gen Renderbuffers EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Samplers = uintptr ( get Proc Addr ( " " ) ) gp Gen Semaphores EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Symbols EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Textures = uintptr ( get Proc Addr ( " " ) ) if gp Gen Textures = = 0 { return errors . New ( " " ) } gp Gen Textures EXT = uintptr ( get Proc Addr ( " " ) ) gp Gen Transform Feedbacks = uintptr ( get Proc Addr ( " " ) ) gp Gen Transform Feedbacks NV = uintptr ( get Proc Addr ( " " ) ) gp Gen Vertex Arrays = uintptr ( get Proc Addr ( " " ) ) gp Gen Vertex Arrays APPLE = uintptr ( get Proc Addr ( " " ) ) gp Gen Vertex Shaders EXT = uintptr ( get Proc Addr ( " " ) ) gp Generate Mipmap = uintptr ( get Proc Addr ( " " ) ) gp Generate Mipmap EXT = uintptr ( get Proc Addr ( " " ) ) gp Generate Multi Tex Mipmap EXT = uintptr ( get Proc Addr ( " " ) ) gp Generate Texture Mipmap = uintptr ( get Proc Addr ( " " ) ) gp Generate Texture Mipmap EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Active Atomic Counter Bufferiv = uintptr ( get Proc Addr ( " " ) ) gp Get Active Attrib = uintptr ( get Proc Addr ( " " ) ) if gp Get Active Attrib = = 0 { return errors . New ( " " ) } gp Get Active Attrib ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Active Subroutine Name = uintptr ( get Proc Addr ( " " ) ) gp Get Active Subroutine Uniform Name = uintptr ( get Proc Addr ( " " ) ) gp Get Active Subroutine Uniformiv = uintptr ( get Proc Addr ( " " ) ) gp Get Active Uniform = uintptr ( get Proc Addr ( " " ) ) if gp Get Active Uniform = = 0 { return errors . New ( " " ) } gp Get Active Uniform ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Active Uniform Block Name = uintptr ( get Proc Addr ( " " ) ) gp Get Active Uniform Blockiv = uintptr ( get Proc Addr ( " " ) ) gp Get Active Uniform Name = uintptr ( get Proc Addr ( " " ) ) gp Get Active Uniformsiv = uintptr ( get Proc Addr ( " " ) ) gp Get Active Varying NV = uintptr ( get Proc Addr ( " " ) ) gp Get Array Objectfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Array Objectiv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Attached Objects ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Attached Shaders = uintptr ( get Proc Addr ( " " ) ) if gp Get Attached Shaders = = 0 { return errors . New ( " " ) } gp Get Attrib Location = uintptr ( get Proc Addr ( " " ) ) if gp Get Attrib Location = = 0 { return errors . New ( " " ) } gp Get Attrib Location ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Boolean Indexedv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Booleanv = uintptr ( get Proc Addr ( " " ) ) if gp Get Booleanv = = 0 { return errors . New ( " " ) } gp Get Buffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) if gp Get Buffer Parameteriv = = 0 { return errors . New ( " " ) } gp Get Buffer Parameteriv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Buffer Parameterui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Buffer Pointerv = uintptr ( get Proc Addr ( " " ) ) if gp Get Buffer Pointerv = = 0 { return errors . New ( " " ) } gp Get Buffer Pointerv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) if gp Get Buffer Sub Data = = 0 { return errors . New ( " " ) } gp Get Buffer Sub Data ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Clip Plane = uintptr ( get Proc Addr ( " " ) ) if gp Get Clip Plane = = 0 { return errors . New ( " " ) } gp Get Clip Planef OES = uintptr ( get Proc Addr ( " " ) ) gp Get Clip Planex OES = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table Parameterfv SGI = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table Parameteriv SGI = uintptr ( get Proc Addr ( " " ) ) gp Get Color Table SGI = uintptr ( get Proc Addr ( " " ) ) gp Get Combiner Input Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Combiner Input Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Combiner Output Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Combiner Output Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Combiner Stage Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Command Header NV = uintptr ( get Proc Addr ( " " ) ) gp Get Compressed Multi Tex Image EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Compressed Tex Image = uintptr ( get Proc Addr ( " " ) ) if gp Get Compressed Tex Image = = 0 { return errors . New ( " " ) } gp Get Compressed Tex Image ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Compressed Texture Image = uintptr ( get Proc Addr ( " " ) ) gp Get Compressed Texture Image EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Compressed Texture Sub Image = uintptr ( get Proc Addr ( " " ) ) gp Get Convolution Filter EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Convolution Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Convolution Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Convolution Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Coverage Modulation Table NV = uintptr ( get Proc Addr ( " " ) ) gp Get Debug Message Log = uintptr ( get Proc Addr ( " " ) ) gp Get Debug Message Log AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Debug Message Log ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Debug Message Log KHR = uintptr ( get Proc Addr ( " " ) ) gp Get Detail Tex Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Double Indexedv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Doublei _v = uintptr ( get Proc Addr ( " " ) ) gp Get Doublei _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Doublev = uintptr ( get Proc Addr ( " " ) ) if gp Get Doublev = = 0 { return errors . New ( " " ) } gp Get Error = uintptr ( get Proc Addr ( " " ) ) if gp Get Error = = 0 { return errors . New ( " " ) } gp Get Fenceiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Final Combiner Input Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Final Combiner Input Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get First Perf Query Id INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Fixedv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Float Indexedv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Floati _v = uintptr ( get Proc Addr ( " " ) ) gp Get Floati _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Floatv = uintptr ( get Proc Addr ( " " ) ) if gp Get Floatv = = 0 { return errors . New ( " " ) } gp Get Fog Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Frag Data Index = uintptr ( get Proc Addr ( " " ) ) gp Get Frag Data Location EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Fragment Lightfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Fragment Lightiv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Fragment Materialfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Fragment Materialiv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Framebuffer Attachment Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Framebuffer Attachment Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Framebuffer Parameterfv AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Framebuffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Framebuffer Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Graphics Reset Status = uintptr ( get Proc Addr ( " " ) ) gp Get Graphics Reset Status ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Graphics Reset Status KHR = uintptr ( get Proc Addr ( " " ) ) gp Get Handle ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Histogram EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Histogram Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Histogram Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Histogram Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Image Handle ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Image Handle NV = uintptr ( get Proc Addr ( " " ) ) gp Get Image Transform Parameterfv HP = uintptr ( get Proc Addr ( " " ) ) gp Get Image Transform Parameteriv HP = uintptr ( get Proc Addr ( " " ) ) gp Get Info Log ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Instruments SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Integer 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Integer Indexedv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Integeri _v = uintptr ( get Proc Addr ( " " ) ) gp Get Integerui 6 4i _v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Integerui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Integerv = uintptr ( get Proc Addr ( " " ) ) if gp Get Integerv = = 0 { return errors . New ( " " ) } gp Get Internalformat Sampleiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Internalformati 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Internalformativ = uintptr ( get Proc Addr ( " " ) ) gp Get Invariant Booleanv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Invariant Floatv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Invariant Integerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Lightfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Lightfv = = 0 { return errors . New ( " " ) } gp Get Lightiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Lightiv = = 0 { return errors . New ( " " ) } gp Get Lightx OES = uintptr ( get Proc Addr ( " " ) ) gp Get Lightxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get List Parameterfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get List Parameteriv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Get Local Constant Booleanv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Local Constant Floatv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Local Constant Integerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Map Attrib Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Map Attrib Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Map Control Points NV = uintptr ( get Proc Addr ( " " ) ) gp Get Map Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Map Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Mapdv = uintptr ( get Proc Addr ( " " ) ) if gp Get Mapdv = = 0 { return errors . New ( " " ) } gp Get Mapfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Mapfv = = 0 { return errors . New ( " " ) } gp Get Mapiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Mapiv = = 0 { return errors . New ( " " ) } gp Get Mapxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Materialfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Materialfv = = 0 { return errors . New ( " " ) } gp Get Materialiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Materialiv = = 0 { return errors . New ( " " ) } gp Get Materialx OES = uintptr ( get Proc Addr ( " " ) ) gp Get Materialxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Memory Object Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Minmax EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Minmax Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Minmax Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Envfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Enviv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Gendv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Genfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Geniv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Image EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Level Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Level Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multi Tex Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Multisamplefv = uintptr ( get Proc Addr ( " " ) ) gp Get Multisamplefv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Parameteri 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Parameterui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Pointerv = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Pointerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Get Named Buffer Sub Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Framebuffer Attachment Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Named Framebuffer Attachment Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Framebuffer Parameterfv AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Named Framebuffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Named Framebuffer Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Program Local Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Program Local Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Program Local Parameterdv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Program Local Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Program String EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Programiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named Renderbuffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Named Renderbuffer Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Named String ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Named Stringiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Next Perf Query Id INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Object Bufferfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Object Bufferiv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Object Label = uintptr ( get Proc Addr ( " " ) ) gp Get Object Label EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Object Label KHR = uintptr ( get Proc Addr ( " " ) ) gp Get Object Parameterfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Object Parameteriv APPLE = uintptr ( get Proc Addr ( " " ) ) gp Get Object Parameteriv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Object Ptr Label = uintptr ( get Proc Addr ( " " ) ) gp Get Object Ptr Label KHR = uintptr ( get Proc Addr ( " " ) ) gp Get Occlusion Queryiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Occlusion Queryuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Commands NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Coords NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Dash Array NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Length NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Metric Range NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Metrics NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Path Spacing NV = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Counter Info INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Counter Data AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Counter Info AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Counter String AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Counters AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Group String AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Monitor Groups AMD = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Query Data INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Query Id By Name INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Perf Query Info INTEL = uintptr ( get Proc Addr ( " " ) ) gp Get Pixel Mapfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Pixel Mapfv = = 0 { return errors . New ( " " ) } gp Get Pixel Mapuiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Pixel Mapuiv = = 0 { return errors . New ( " " ) } gp Get Pixel Mapusv = uintptr ( get Proc Addr ( " " ) ) if gp Get Pixel Mapusv = = 0 { return errors . New ( " " ) } gp Get Pixel Mapxv = uintptr ( get Proc Addr ( " " ) ) gp Get Pixel Tex Gen Parameterfv SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Pixel Tex Gen Parameteriv SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Pixel Transform Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Pixel Transform Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Pointer Indexedv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Pointeri _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Pointerv = uintptr ( get Proc Addr ( " " ) ) if gp Get Pointerv = = 0 { return errors . New ( " " ) } gp Get Pointerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Pointerv KHR = uintptr ( get Proc Addr ( " " ) ) gp Get Polygon Stipple = uintptr ( get Proc Addr ( " " ) ) if gp Get Polygon Stipple = = 0 { return errors . New ( " " ) } gp Get Program Binary = uintptr ( get Proc Addr ( " " ) ) gp Get Program Env Parameter Iiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Env Parameter Iuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Env Parameterdv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Program Env Parameterfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Program Info Log = uintptr ( get Proc Addr ( " " ) ) if gp Get Program Info Log = = 0 { return errors . New ( " " ) } gp Get Program Interfaceiv = uintptr ( get Proc Addr ( " " ) ) gp Get Program Local Parameter Iiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Local Parameter Iuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Local Parameterdv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Program Local Parameterfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Program Named Parameterdv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Named Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Parameterdv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Pipeline Info Log = uintptr ( get Proc Addr ( " " ) ) gp Get Program Pipeline Info Log EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Program Pipelineiv = uintptr ( get Proc Addr ( " " ) ) gp Get Program Pipelineiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resource Index = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resource Location = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resource Location Index = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resource Name = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resourcefv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Resourceiv = uintptr ( get Proc Addr ( " " ) ) gp Get Program Stageiv = uintptr ( get Proc Addr ( " " ) ) gp Get Program String ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Program String NV = uintptr ( get Proc Addr ( " " ) ) gp Get Program Subroutine Parameteruiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Programiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Programiv = = 0 { return errors . New ( " " ) } gp Get Programiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Programiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Query Buffer Objecti 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Query Buffer Objectiv = uintptr ( get Proc Addr ( " " ) ) gp Get Query Buffer Objectui 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Query Buffer Objectuiv = uintptr ( get Proc Addr ( " " ) ) gp Get Query Indexediv = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objecti 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objecti 6 4v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objectiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Query Objectiv = = 0 { return errors . New ( " " ) } gp Get Query Objectiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objectui 6 4v = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objectui 6 4v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Query Objectuiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Query Objectuiv = = 0 { return errors . New ( " " ) } gp Get Query Objectuiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Queryiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Queryiv = = 0 { return errors . New ( " " ) } gp Get Queryiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Renderbuffer Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Renderbuffer Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Sampler Parameter Iiv = uintptr ( get Proc Addr ( " " ) ) gp Get Sampler Parameter Iuiv = uintptr ( get Proc Addr ( " " ) ) gp Get Sampler Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Get Sampler Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Semaphore Parameterui 6 4v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Separable Filter EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Shader Info Log = uintptr ( get Proc Addr ( " " ) ) if gp Get Shader Info Log = = 0 { return errors . New ( " " ) } gp Get Shader Precision Format = uintptr ( get Proc Addr ( " " ) ) gp Get Shader Source = uintptr ( get Proc Addr ( " " ) ) if gp Get Shader Source = = 0 { return errors . New ( " " ) } gp Get Shader Source ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Shaderiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Shaderiv = = 0 { return errors . New ( " " ) } gp Get Sharpen Tex Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Stage Index NV = uintptr ( get Proc Addr ( " " ) ) gp Get String = uintptr ( get Proc Addr ( " " ) ) if gp Get String = = 0 { return errors . New ( " " ) } gp Get Subroutine Index = uintptr ( get Proc Addr ( " " ) ) gp Get Subroutine Uniform Location = uintptr ( get Proc Addr ( " " ) ) gp Get Synciv = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Bump Parameterfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Bump Parameteriv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Envfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Envfv = = 0 { return errors . New ( " " ) } gp Get Tex Enviv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Enviv = = 0 { return errors . New ( " " ) } gp Get Tex Envxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Filter Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Gendv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Gendv = = 0 { return errors . New ( " " ) } gp Get Tex Genfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Genfv = = 0 { return errors . New ( " " ) } gp Get Tex Geniv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Geniv = = 0 { return errors . New ( " " ) } gp Get Tex Genxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Image = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Image = = 0 { return errors . New ( " " ) } gp Get Tex Level Parameterfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Level Parameterfv = = 0 { return errors . New ( " " ) } gp Get Tex Level Parameteriv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Level Parameteriv = = 0 { return errors . New ( " " ) } gp Get Tex Level Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Parameter Pointerv APPLE = uintptr ( get Proc Addr ( " " ) ) gp Get Tex Parameterfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Parameterfv = = 0 { return errors . New ( " " ) } gp Get Tex Parameteriv = uintptr ( get Proc Addr ( " " ) ) if gp Get Tex Parameteriv = = 0 { return errors . New ( " " ) } gp Get Tex Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Handle ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Handle NV = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Image = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Image EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Level Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Level Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Level Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Level Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameter Iiv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameter Iuiv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Sampler Handle ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Sampler Handle NV = uintptr ( get Proc Addr ( " " ) ) gp Get Texture Sub Image = uintptr ( get Proc Addr ( " " ) ) gp Get Track Matrixiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Transform Feedback Varying EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Transform Feedback Varying NV = uintptr ( get Proc Addr ( " " ) ) gp Get Transform Feedbacki 6 4 _v = uintptr ( get Proc Addr ( " " ) ) gp Get Transform Feedbacki _v = uintptr ( get Proc Addr ( " " ) ) gp Get Transform Feedbackiv = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Block Index = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Buffer Size EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Indices = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Location = uintptr ( get Proc Addr ( " " ) ) if gp Get Uniform Location = = 0 { return errors . New ( " " ) } gp Get Uniform Location ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Uniform Subroutineuiv = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformdv = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Uniformfv = = 0 { return errors . New ( " " ) } gp Get Uniformfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformi 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformi 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Uniformiv = = 0 { return errors . New ( " " ) } gp Get Uniformiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Uniformuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Unsigned Bytei _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Unsigned Bytev EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Array Objectfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Array Objectiv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Booleanv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Floatv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Integerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Variant Pointerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Varying Location NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Indexed 6 4iv = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Indexediv = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Integeri _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Integerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Pointeri _v EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Array Pointerv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Arrayiv = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Array Objectfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Array Objectiv ATI = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Ldv = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Ldv EXT = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Li 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Lui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Lui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Pointerv = uintptr ( get Proc Addr ( " " ) ) if gp Get Vertex Attrib Pointerv = = 0 { return errors . New ( " " ) } gp Get Vertex Attrib Pointerv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attrib Pointerv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribdv = uintptr ( get Proc Addr ( " " ) ) if gp Get Vertex Attribdv = = 0 { return errors . New ( " " ) } gp Get Vertex Attribdv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribdv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribfv = uintptr ( get Proc Addr ( " " ) ) if gp Get Vertex Attribfv = = 0 { return errors . New ( " " ) } gp Get Vertex Attribfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribiv = uintptr ( get Proc Addr ( " " ) ) if gp Get Vertex Attribiv = = 0 { return errors . New ( " " ) } gp Get Vertex Attribiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Get Vertex Attribiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Video Capture Streamdv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Video Capture Streamfv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Video Capture Streamiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Video Captureiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Videoi 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Videoiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Videoui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Get Videouiv NV = uintptr ( get Proc Addr ( " " ) ) gp Get Vk Proc Addr NV = uintptr ( get Proc Addr ( " " ) ) gp Getn Compressed Tex Image ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Tex Image ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformdv ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformfv = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformfv KHR = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformi 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformiv = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformiv KHR = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformuiv = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformuiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Getn Uniformuiv KHR = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factorb SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factord SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factorf SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factori SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factors SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factorub SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factorui SUN = uintptr ( get Proc Addr ( " " ) ) gp Global Alpha Factorus SUN = uintptr ( get Proc Addr ( " " ) ) gp Hint = uintptr ( get Proc Addr ( " " ) ) if gp Hint = = 0 { return errors . New ( " " ) } gp Hint PGI = uintptr ( get Proc Addr ( " " ) ) gp Histogram EXT = uintptr ( get Proc Addr ( " " ) ) gp Igloo Interface SGIX = uintptr ( get Proc Addr ( " " ) ) gp Image Transform Parameterf HP = uintptr ( get Proc Addr ( " " ) ) gp Image Transform Parameterfv HP = uintptr ( get Proc Addr ( " " ) ) gp Image Transform Parameteri HP = uintptr ( get Proc Addr ( " " ) ) gp Image Transform Parameteriv HP = uintptr ( get Proc Addr ( " " ) ) gp Import Memory Fd EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Memory Win 3 2Handle EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Memory Win 3 2Name EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Semaphore Fd EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Semaphore Win 3 2Handle EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Semaphore Win 3 2Name EXT = uintptr ( get Proc Addr ( " " ) ) gp Import Sync EXT = uintptr ( get Proc Addr ( " " ) ) gp Index Format NV = uintptr ( get Proc Addr ( " " ) ) gp Index Func EXT = uintptr ( get Proc Addr ( " " ) ) gp Index Mask = uintptr ( get Proc Addr ( " " ) ) if gp Index Mask = = 0 { return errors . New ( " " ) } gp Index Material EXT = uintptr ( get Proc Addr ( " " ) ) gp Index Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Index Pointer = = 0 { return errors . New ( " " ) } gp Index Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Index Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Indexd = uintptr ( get Proc Addr ( " " ) ) if gp Indexd = = 0 { return errors . New ( " " ) } gp Indexdv = uintptr ( get Proc Addr ( " " ) ) if gp Indexdv = = 0 { return errors . New ( " " ) } gp Indexf = uintptr ( get Proc Addr ( " " ) ) if gp Indexf = = 0 { return errors . New ( " " ) } gp Indexfv = uintptr ( get Proc Addr ( " " ) ) if gp Indexfv = = 0 { return errors . New ( " " ) } gp Indexi = uintptr ( get Proc Addr ( " " ) ) if gp Indexi = = 0 { return errors . New ( " " ) } gp Indexiv = uintptr ( get Proc Addr ( " " ) ) if gp Indexiv = = 0 { return errors . New ( " " ) } gp Indexs = uintptr ( get Proc Addr ( " " ) ) if gp Indexs = = 0 { return errors . New ( " " ) } gp Indexsv = uintptr ( get Proc Addr ( " " ) ) if gp Indexsv = = 0 { return errors . New ( " " ) } gp Indexub = uintptr ( get Proc Addr ( " " ) ) if gp Indexub = = 0 { return errors . New ( " " ) } gp Indexubv = uintptr ( get Proc Addr ( " " ) ) if gp Indexubv = = 0 { return errors . New ( " " ) } gp Indexx OES = uintptr ( get Proc Addr ( " " ) ) gp Indexxv OES = uintptr ( get Proc Addr ( " " ) ) gp Init Names = uintptr ( get Proc Addr ( " " ) ) if gp Init Names = = 0 { return errors . New ( " " ) } gp Insert Component EXT = uintptr ( get Proc Addr ( " " ) ) gp Insert Event Marker EXT = uintptr ( get Proc Addr ( " " ) ) gp Instruments Buffer SGIX = uintptr ( get Proc Addr ( " " ) ) gp Interleaved Arrays = uintptr ( get Proc Addr ( " " ) ) if gp Interleaved Arrays = = 0 { return errors . New ( " " ) } gp Interpolate Paths NV = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Buffer Data = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Named Framebuffer Data = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Named Framebuffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Sub Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Tex Image = uintptr ( get Proc Addr ( " " ) ) gp Invalidate Tex Sub Image = uintptr ( get Proc Addr ( " " ) ) gp Is Async Marker SGIX = uintptr ( get Proc Addr ( " " ) ) gp Is Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Is Buffer = = 0 { return errors . New ( " " ) } gp Is Buffer ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Buffer Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Is Command List NV = uintptr ( get Proc Addr ( " " ) ) gp Is Enabled = uintptr ( get Proc Addr ( " " ) ) if gp Is Enabled = = 0 { return errors . New ( " " ) } gp Is Enabled Indexed EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Fence APPLE = uintptr ( get Proc Addr ( " " ) ) gp Is Fence NV = uintptr ( get Proc Addr ( " " ) ) gp Is Framebuffer = uintptr ( get Proc Addr ( " " ) ) gp Is Framebuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Image Handle Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Image Handle Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Is List = uintptr ( get Proc Addr ( " " ) ) if gp Is List = = 0 { return errors . New ( " " ) } gp Is Memory Object EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Name AMD = uintptr ( get Proc Addr ( " " ) ) gp Is Named Buffer Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Is Named String ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Is Occlusion Query NV = uintptr ( get Proc Addr ( " " ) ) gp Is Path NV = uintptr ( get Proc Addr ( " " ) ) gp Is Point In Fill Path NV = uintptr ( get Proc Addr ( " " ) ) gp Is Point In Stroke Path NV = uintptr ( get Proc Addr ( " " ) ) gp Is Program = uintptr ( get Proc Addr ( " " ) ) if gp Is Program = = 0 { return errors . New ( " " ) } gp Is Program ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Program NV = uintptr ( get Proc Addr ( " " ) ) gp Is Program Pipeline = uintptr ( get Proc Addr ( " " ) ) gp Is Program Pipeline EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Query = uintptr ( get Proc Addr ( " " ) ) if gp Is Query = = 0 { return errors . New ( " " ) } gp Is Query ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Renderbuffer = uintptr ( get Proc Addr ( " " ) ) gp Is Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Sampler = uintptr ( get Proc Addr ( " " ) ) gp Is Semaphore EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Shader = uintptr ( get Proc Addr ( " " ) ) if gp Is Shader = = 0 { return errors . New ( " " ) } gp Is State NV = uintptr ( get Proc Addr ( " " ) ) gp Is Sync = uintptr ( get Proc Addr ( " " ) ) gp Is Texture = uintptr ( get Proc Addr ( " " ) ) if gp Is Texture = = 0 { return errors . New ( " " ) } gp Is Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Texture Handle Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Is Texture Handle Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Is Transform Feedback = uintptr ( get Proc Addr ( " " ) ) gp Is Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Is Variant Enabled EXT = uintptr ( get Proc Addr ( " " ) ) gp Is Vertex Array = uintptr ( get Proc Addr ( " " ) ) gp Is Vertex Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Is Vertex Attrib Enabled APPLE = uintptr ( get Proc Addr ( " " ) ) gp LGPUCopy Image Sub Data NVX = uintptr ( get Proc Addr ( " " ) ) gp LGPUInterlock NVX = uintptr ( get Proc Addr ( " " ) ) gp LGPUNamed Buffer Sub Data NVX = uintptr ( get Proc Addr ( " " ) ) gp Label Object EXT = uintptr ( get Proc Addr ( " " ) ) gp Light Envi SGIX = uintptr ( get Proc Addr ( " " ) ) gp Light Modelf = uintptr ( get Proc Addr ( " " ) ) if gp Light Modelf = = 0 { return errors . New ( " " ) } gp Light Modelfv = uintptr ( get Proc Addr ( " " ) ) if gp Light Modelfv = = 0 { return errors . New ( " " ) } gp Light Modeli = uintptr ( get Proc Addr ( " " ) ) if gp Light Modeli = = 0 { return errors . New ( " " ) } gp Light Modeliv = uintptr ( get Proc Addr ( " " ) ) if gp Light Modeliv = = 0 { return errors . New ( " " ) } gp Light Modelx OES = uintptr ( get Proc Addr ( " " ) ) gp Light Modelxv OES = uintptr ( get Proc Addr ( " " ) ) gp Lightf = uintptr ( get Proc Addr ( " " ) ) if gp Lightf = = 0 { return errors . New ( " " ) } gp Lightfv = uintptr ( get Proc Addr ( " " ) ) if gp Lightfv = = 0 { return errors . New ( " " ) } gp Lighti = uintptr ( get Proc Addr ( " " ) ) if gp Lighti = = 0 { return errors . New ( " " ) } gp Lightiv = uintptr ( get Proc Addr ( " " ) ) if gp Lightiv = = 0 { return errors . New ( " " ) } gp Lightx OES = uintptr ( get Proc Addr ( " " ) ) gp Lightxv OES = uintptr ( get Proc Addr ( " " ) ) gp Line Stipple = uintptr ( get Proc Addr ( " " ) ) if gp Line Stipple = = 0 { return errors . New ( " " ) } gp Line Width = uintptr ( get Proc Addr ( " " ) ) if gp Line Width = = 0 { return errors . New ( " " ) } gp Line Widthx OES = uintptr ( get Proc Addr ( " " ) ) gp Link Program = uintptr ( get Proc Addr ( " " ) ) if gp Link Program = = 0 { return errors . New ( " " ) } gp Link Program ARB = uintptr ( get Proc Addr ( " " ) ) gp List Base = uintptr ( get Proc Addr ( " " ) ) if gp List Base = = 0 { return errors . New ( " " ) } gp List Draw Commands States Client NV = uintptr ( get Proc Addr ( " " ) ) gp List Parameterf SGIX = uintptr ( get Proc Addr ( " " ) ) gp List Parameterfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp List Parameteri SGIX = uintptr ( get Proc Addr ( " " ) ) gp List Parameteriv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Load Identity = uintptr ( get Proc Addr ( " " ) ) if gp Load Identity = = 0 { return errors . New ( " " ) } gp Load Identity Deformation Map SGIX = uintptr ( get Proc Addr ( " " ) ) gp Load Matrixd = uintptr ( get Proc Addr ( " " ) ) if gp Load Matrixd = = 0 { return errors . New ( " " ) } gp Load Matrixf = uintptr ( get Proc Addr ( " " ) ) if gp Load Matrixf = = 0 { return errors . New ( " " ) } gp Load Matrixx OES = uintptr ( get Proc Addr ( " " ) ) gp Load Name = uintptr ( get Proc Addr ( " " ) ) if gp Load Name = = 0 { return errors . New ( " " ) } gp Load Program NV = uintptr ( get Proc Addr ( " " ) ) gp Load Transpose Matrixd = uintptr ( get Proc Addr ( " " ) ) if gp Load Transpose Matrixd = = 0 { return errors . New ( " " ) } gp Load Transpose Matrixd ARB = uintptr ( get Proc Addr ( " " ) ) gp Load Transpose Matrixf = uintptr ( get Proc Addr ( " " ) ) if gp Load Transpose Matrixf = = 0 { return errors . New ( " " ) } gp Load Transpose Matrixf ARB = uintptr ( get Proc Addr ( " " ) ) gp Load Transpose Matrixx OES = uintptr ( get Proc Addr ( " " ) ) gp Lock Arrays EXT = uintptr ( get Proc Addr ( " " ) ) gp Logic Op = uintptr ( get Proc Addr ( " " ) ) if gp Logic Op = = 0 { return errors . New ( " " ) } gp Make Buffer Non Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Buffer Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Image Handle Non Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Make Image Handle Non Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Image Handle Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Make Image Handle Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Named Buffer Non Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Named Buffer Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Texture Handle Non Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Make Texture Handle Non Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Make Texture Handle Resident ARB = uintptr ( get Proc Addr ( " " ) ) gp Make Texture Handle Resident NV = uintptr ( get Proc Addr ( " " ) ) gp Map 1d = uintptr ( get Proc Addr ( " " ) ) if gp Map 1d = = 0 { return errors . New ( " " ) } gp Map 1f = uintptr ( get Proc Addr ( " " ) ) if gp Map 1f = = 0 { return errors . New ( " " ) } gp Map 1x OES = uintptr ( get Proc Addr ( " " ) ) gp Map 2d = uintptr ( get Proc Addr ( " " ) ) if gp Map 2d = = 0 { return errors . New ( " " ) } gp Map 2f = uintptr ( get Proc Addr ( " " ) ) if gp Map 2f = = 0 { return errors . New ( " " ) } gp Map 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Map Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Map Buffer = = 0 { return errors . New ( " " ) } gp Map Buffer ARB = uintptr ( get Proc Addr ( " " ) ) gp Map Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Map Control Points NV = uintptr ( get Proc Addr ( " " ) ) gp Map Grid 1d = uintptr ( get Proc Addr ( " " ) ) if gp Map Grid 1d = = 0 { return errors . New ( " " ) } gp Map Grid 1f = uintptr ( get Proc Addr ( " " ) ) if gp Map Grid 1f = = 0 { return errors . New ( " " ) } gp Map Grid 1x OES = uintptr ( get Proc Addr ( " " ) ) gp Map Grid 2d = uintptr ( get Proc Addr ( " " ) ) if gp Map Grid 2d = = 0 { return errors . New ( " " ) } gp Map Grid 2f = uintptr ( get Proc Addr ( " " ) ) if gp Map Grid 2f = = 0 { return errors . New ( " " ) } gp Map Grid 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Map Named Buffer = uintptr ( get Proc Addr ( " " ) ) gp Map Named Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Map Named Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Map Named Buffer Range EXT = uintptr ( get Proc Addr ( " " ) ) gp Map Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Map Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Map Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Map Texture 2DINTEL = uintptr ( get Proc Addr ( " " ) ) gp Map Vertex Attrib 1d APPLE = uintptr ( get Proc Addr ( " " ) ) gp Map Vertex Attrib 1f APPLE = uintptr ( get Proc Addr ( " " ) ) gp Map Vertex Attrib 2d APPLE = uintptr ( get Proc Addr ( " " ) ) gp Map Vertex Attrib 2f APPLE = uintptr ( get Proc Addr ( " " ) ) gp Materialf = uintptr ( get Proc Addr ( " " ) ) if gp Materialf = = 0 { return errors . New ( " " ) } gp Materialfv = uintptr ( get Proc Addr ( " " ) ) if gp Materialfv = = 0 { return errors . New ( " " ) } gp Materiali = uintptr ( get Proc Addr ( " " ) ) if gp Materiali = = 0 { return errors . New ( " " ) } gp Materialiv = uintptr ( get Proc Addr ( " " ) ) if gp Materialiv = = 0 { return errors . New ( " " ) } gp Materialx OES = uintptr ( get Proc Addr ( " " ) ) gp Materialxv OES = uintptr ( get Proc Addr ( " " ) ) gp Matrix Frustum EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Index Pointer ARB = uintptr ( get Proc Addr ( " " ) ) gp Matrix Indexubv ARB = uintptr ( get Proc Addr ( " " ) ) gp Matrix Indexuiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Matrix Indexusv ARB = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load 3x 2f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load 3x 3f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load Identity EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load Transpose 3x 3f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load Transposed EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Load Transposef EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Loadd EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Loadf EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Mode = uintptr ( get Proc Addr ( " " ) ) if gp Matrix Mode = = 0 { return errors . New ( " " ) } gp Matrix Mult 3x 2f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Mult 3x 3f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Mult Transpose 3x 3f NV = uintptr ( get Proc Addr ( " " ) ) gp Matrix Mult Transposed EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Mult Transposef EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Multd EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Multf EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Ortho EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Pop EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Push EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Rotated EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Rotatef EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Scaled EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Scalef EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Translated EXT = uintptr ( get Proc Addr ( " " ) ) gp Matrix Translatef EXT = uintptr ( get Proc Addr ( " " ) ) gp Max Shader Compiler Threads ARB = uintptr ( get Proc Addr ( " " ) ) gp Max Shader Compiler Threads KHR = uintptr ( get Proc Addr ( " " ) ) gp Memory Barrier = uintptr ( get Proc Addr ( " " ) ) gp Memory Barrier By Region = uintptr ( get Proc Addr ( " " ) ) gp Memory Barrier EXT = uintptr ( get Proc Addr ( " " ) ) gp Memory Object Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Min Sample Shading ARB = uintptr ( get Proc Addr ( " " ) ) gp Minmax EXT = uintptr ( get Proc Addr ( " " ) ) gp Mult Matrixd = uintptr ( get Proc Addr ( " " ) ) if gp Mult Matrixd = = 0 { return errors . New ( " " ) } gp Mult Matrixf = uintptr ( get Proc Addr ( " " ) ) if gp Mult Matrixf = = 0 { return errors . New ( " " ) } gp Mult Matrixx OES = uintptr ( get Proc Addr ( " " ) ) gp Mult Transpose Matrixd = uintptr ( get Proc Addr ( " " ) ) if gp Mult Transpose Matrixd = = 0 { return errors . New ( " " ) } gp Mult Transpose Matrixd ARB = uintptr ( get Proc Addr ( " " ) ) gp Mult Transpose Matrixf = uintptr ( get Proc Addr ( " " ) ) if gp Mult Transpose Matrixf = = 0 { return errors . New ( " " ) } gp Mult Transpose Matrixf ARB = uintptr ( get Proc Addr ( " " ) ) gp Mult Transpose Matrixx OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays = uintptr ( get Proc Addr ( " " ) ) if gp Multi Draw Arrays = = 0 { return errors . New ( " " ) } gp Multi Draw Arrays EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays Indirect = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays Indirect AMD = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays Indirect Bindless Count NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays Indirect Bindless NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Arrays Indirect Count ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Element Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements = uintptr ( get Proc Addr ( " " ) ) if gp Multi Draw Elements = = 0 { return errors . New ( " " ) } gp Multi Draw Elements Base Vertex = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements Indirect = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements Indirect AMD = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements Indirect Bindless Count NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements Indirect Bindless NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Elements Indirect Count ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Draw Range Element Array APPLE = uintptr ( get Proc Addr ( " " ) ) gp Multi Mode Draw Arrays IBM = uintptr ( get Proc Addr ( " " ) ) gp Multi Mode Draw Elements IBM = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1b OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1bv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1d = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1d = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1d ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1dv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1dv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1f = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1f = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1f ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1fv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1fv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1h NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1hv NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1i = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1i = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1i ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1iv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1iv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1s = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1s = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1s ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1sv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 1sv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 1sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1x OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 1xv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2b OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2bv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2d = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2d = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2d ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2dv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2f = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2f = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2f ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2fv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2h NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2hv NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2i = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2i = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2i ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2iv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2s = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2s = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2s ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 2sv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 2sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 2xv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3b OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3bv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3d = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3d = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3d ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3dv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3f = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3f = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3f ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3fv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3i = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3i = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3i ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3iv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3s = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3s = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3s ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 3sv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 3sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4b OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4bv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4d = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4d = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4d ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4dv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4f = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4f = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4f ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4fv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4h NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4i = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4i = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4i ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4iv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4s = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4s = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4s ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Multi Tex Coord 4sv = = 0 { return errors . New ( " " ) } gp Multi Tex Coord 4sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4x OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord 4xv OES = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Coord Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Envf EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Envfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Envi EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Enviv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Gend EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Gendv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Genf EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Genfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Geni EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Geniv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameterf EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multi Tex Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Multicast Barrier NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Blit Framebuffer NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Buffer Sub Data NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Copy Buffer Sub Data NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Copy Image Sub Data NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Framebuffer Sample Locationsfv NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Get Query Objecti 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Get Query Objectiv NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Get Query Objectui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Get Query Objectuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Multicast Wait Sync NV = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Data = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Page Commitment ARB = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Page Commitment EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Storage = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Storage EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Storage External EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Storage Mem EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Sub Data = uintptr ( get Proc Addr ( " " ) ) gp Named Buffer Sub Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Copy Buffer Sub Data EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Draw Buffer = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Draw Buffers = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Read Buffer = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Renderbuffer = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Sample Locationsfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Sample Locationsfv NV = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Sample Positionsfv AMD = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture Face EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture Layer = uintptr ( get Proc Addr ( " " ) ) gp Named Framebuffer Texture Layer EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter 4d EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter 4f EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter I 4i EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter I 4iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter I 4ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameter I 4uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameters 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameters I 4iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program Local Parameters I 4uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Program String EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Renderbuffer Storage = uintptr ( get Proc Addr ( " " ) ) gp Named Renderbuffer Storage EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Renderbuffer Storage Multisample = uintptr ( get Proc Addr ( " " ) ) gp Named Renderbuffer Storage Multisample Coverage EXT = uintptr ( get Proc Addr ( " " ) ) gp Named Renderbuffer Storage Multisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Named String ARB = uintptr ( get Proc Addr ( " " ) ) gp New List = uintptr ( get Proc Addr ( " " ) ) if gp New List = = 0 { return errors . New ( " " ) } gp New Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal 3b = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3b = = 0 { return errors . New ( " " ) } gp Normal 3bv = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3bv = = 0 { return errors . New ( " " ) } gp Normal 3d = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3d = = 0 { return errors . New ( " " ) } gp Normal 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3dv = = 0 { return errors . New ( " " ) } gp Normal 3f = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3f = = 0 { return errors . New ( " " ) } gp Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Normal 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3fv = = 0 { return errors . New ( " " ) } gp Normal 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Normal 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Normal 3i = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3i = = 0 { return errors . New ( " " ) } gp Normal 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3iv = = 0 { return errors . New ( " " ) } gp Normal 3s = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3s = = 0 { return errors . New ( " " ) } gp Normal 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Normal 3sv = = 0 { return errors . New ( " " ) } gp Normal 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Normal 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Normal Format NV = uintptr ( get Proc Addr ( " " ) ) gp Normal Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Normal Pointer = = 0 { return errors . New ( " " ) } gp Normal Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Normal Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Normal Pointerv INTEL = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3b ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3bv ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3d ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3dv ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3f ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3fv ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3i ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3iv ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3s ATI = uintptr ( get Proc Addr ( " " ) ) gp Normal Stream 3sv ATI = uintptr ( get Proc Addr ( " " ) ) gp Object Label = uintptr ( get Proc Addr ( " " ) ) gp Object Label KHR = uintptr ( get Proc Addr ( " " ) ) gp Object Ptr Label = uintptr ( get Proc Addr ( " " ) ) gp Object Ptr Label KHR = uintptr ( get Proc Addr ( " " ) ) gp Object Purgeable APPLE = uintptr ( get Proc Addr ( " " ) ) gp Object Unpurgeable APPLE = uintptr ( get Proc Addr ( " " ) ) gp Ortho = uintptr ( get Proc Addr ( " " ) ) if gp Ortho = = 0 { return errors . New ( " " ) } gp Orthof OES = uintptr ( get Proc Addr ( " " ) ) gp Orthox OES = uintptr ( get Proc Addr ( " " ) ) gp PNTrianglesf ATI = uintptr ( get Proc Addr ( " " ) ) gp PNTrianglesi ATI = uintptr ( get Proc Addr ( " " ) ) gp Pass Tex Coord ATI = uintptr ( get Proc Addr ( " " ) ) gp Pass Through = uintptr ( get Proc Addr ( " " ) ) if gp Pass Through = = 0 { return errors . New ( " " ) } gp Pass Throughx OES = uintptr ( get Proc Addr ( " " ) ) gp Patch Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Patch Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Path Commands NV = uintptr ( get Proc Addr ( " " ) ) gp Path Coords NV = uintptr ( get Proc Addr ( " " ) ) gp Path Cover Depth Func NV = uintptr ( get Proc Addr ( " " ) ) gp Path Dash Array NV = uintptr ( get Proc Addr ( " " ) ) gp Path Glyph Index Array NV = uintptr ( get Proc Addr ( " " ) ) gp Path Glyph Index Range NV = uintptr ( get Proc Addr ( " " ) ) gp Path Glyph Range NV = uintptr ( get Proc Addr ( " " ) ) gp Path Glyphs NV = uintptr ( get Proc Addr ( " " ) ) gp Path Memory Glyph Index Array NV = uintptr ( get Proc Addr ( " " ) ) gp Path Parameterf NV = uintptr ( get Proc Addr ( " " ) ) gp Path Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Path Parameteri NV = uintptr ( get Proc Addr ( " " ) ) gp Path Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Path Stencil Depth Offset NV = uintptr ( get Proc Addr ( " " ) ) gp Path Stencil Func NV = uintptr ( get Proc Addr ( " " ) ) gp Path String NV = uintptr ( get Proc Addr ( " " ) ) gp Path Sub Commands NV = uintptr ( get Proc Addr ( " " ) ) gp Path Sub Coords NV = uintptr ( get Proc Addr ( " " ) ) gp Pause Transform Feedback = uintptr ( get Proc Addr ( " " ) ) gp Pause Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Pixel Data Range NV = uintptr ( get Proc Addr ( " " ) ) gp Pixel Mapfv = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Mapfv = = 0 { return errors . New ( " " ) } gp Pixel Mapuiv = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Mapuiv = = 0 { return errors . New ( " " ) } gp Pixel Mapusv = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Mapusv = = 0 { return errors . New ( " " ) } gp Pixel Mapx = uintptr ( get Proc Addr ( " " ) ) gp Pixel Storef = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Storef = = 0 { return errors . New ( " " ) } gp Pixel Storei = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Storei = = 0 { return errors . New ( " " ) } gp Pixel Storex = uintptr ( get Proc Addr ( " " ) ) gp Pixel Tex Gen Parameterf SGIS = uintptr ( get Proc Addr ( " " ) ) gp Pixel Tex Gen Parameterfv SGIS = uintptr ( get Proc Addr ( " " ) ) gp Pixel Tex Gen Parameteri SGIS = uintptr ( get Proc Addr ( " " ) ) gp Pixel Tex Gen Parameteriv SGIS = uintptr ( get Proc Addr ( " " ) ) gp Pixel Tex Gen SGIX = uintptr ( get Proc Addr ( " " ) ) gp Pixel Transferf = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Transferf = = 0 { return errors . New ( " " ) } gp Pixel Transferi = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Transferi = = 0 { return errors . New ( " " ) } gp Pixel Transferx OES = uintptr ( get Proc Addr ( " " ) ) gp Pixel Transform Parameterf EXT = uintptr ( get Proc Addr ( " " ) ) gp Pixel Transform Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Pixel Transform Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Pixel Transform Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Pixel Zoom = uintptr ( get Proc Addr ( " " ) ) if gp Pixel Zoom = = 0 { return errors . New ( " " ) } gp Pixel Zoomx OES = uintptr ( get Proc Addr ( " " ) ) gp Point Along Path NV = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterf = uintptr ( get Proc Addr ( " " ) ) if gp Point Parameterf = = 0 { return errors . New ( " " ) } gp Point Parameterf ARB = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterf EXT = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterf SGIS = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterfv = uintptr ( get Proc Addr ( " " ) ) if gp Point Parameterfv = = 0 { return errors . New ( " " ) } gp Point Parameterfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterfv SGIS = uintptr ( get Proc Addr ( " " ) ) gp Point Parameteri = uintptr ( get Proc Addr ( " " ) ) if gp Point Parameteri = = 0 { return errors . New ( " " ) } gp Point Parameteri NV = uintptr ( get Proc Addr ( " " ) ) gp Point Parameteriv = uintptr ( get Proc Addr ( " " ) ) if gp Point Parameteriv = = 0 { return errors . New ( " " ) } gp Point Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterx OES = uintptr ( get Proc Addr ( " " ) ) gp Point Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Point Size = uintptr ( get Proc Addr ( " " ) ) if gp Point Size = = 0 { return errors . New ( " " ) } gp Point Sizex OES = uintptr ( get Proc Addr ( " " ) ) gp Poll Async SGIX = uintptr ( get Proc Addr ( " " ) ) gp Poll Instruments SGIX = uintptr ( get Proc Addr ( " " ) ) gp Polygon Mode = uintptr ( get Proc Addr ( " " ) ) if gp Polygon Mode = = 0 { return errors . New ( " " ) } gp Polygon Offset = uintptr ( get Proc Addr ( " " ) ) if gp Polygon Offset = = 0 { return errors . New ( " " ) } gp Polygon Offset Clamp = uintptr ( get Proc Addr ( " " ) ) gp Polygon Offset Clamp EXT = uintptr ( get Proc Addr ( " " ) ) gp Polygon Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Polygon Offsetx OES = uintptr ( get Proc Addr ( " " ) ) gp Polygon Stipple = uintptr ( get Proc Addr ( " " ) ) if gp Polygon Stipple = = 0 { return errors . New ( " " ) } gp Pop Attrib = uintptr ( get Proc Addr ( " " ) ) if gp Pop Attrib = = 0 { return errors . New ( " " ) } gp Pop Client Attrib = uintptr ( get Proc Addr ( " " ) ) if gp Pop Client Attrib = = 0 { return errors . New ( " " ) } gp Pop Debug Group = uintptr ( get Proc Addr ( " " ) ) gp Pop Debug Group KHR = uintptr ( get Proc Addr ( " " ) ) gp Pop Group Marker EXT = uintptr ( get Proc Addr ( " " ) ) gp Pop Matrix = uintptr ( get Proc Addr ( " " ) ) if gp Pop Matrix = = 0 { return errors . New ( " " ) } gp Pop Name = uintptr ( get Proc Addr ( " " ) ) if gp Pop Name = = 0 { return errors . New ( " " ) } gp Present Frame Dual Fill NV = uintptr ( get Proc Addr ( " " ) ) gp Present Frame Keyed NV = uintptr ( get Proc Addr ( " " ) ) gp Primitive Bounding Box ARB = uintptr ( get Proc Addr ( " " ) ) gp Primitive Restart Index NV = uintptr ( get Proc Addr ( " " ) ) gp Primitive Restart NV = uintptr ( get Proc Addr ( " " ) ) gp Prioritize Textures = uintptr ( get Proc Addr ( " " ) ) if gp Prioritize Textures = = 0 { return errors . New ( " " ) } gp Prioritize Textures EXT = uintptr ( get Proc Addr ( " " ) ) gp Prioritize Texturesx OES = uintptr ( get Proc Addr ( " " ) ) gp Program Binary = uintptr ( get Proc Addr ( " " ) ) gp Program Buffer Parameters Iiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Buffer Parameters Iuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Buffer Parametersfv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter 4d ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter 4dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter 4f ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter I 4i NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter I 4iv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter I 4ui NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameter I 4uiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameters 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameters I 4iv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Env Parameters I 4uiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter 4d ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter 4dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter 4f ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter I 4i NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter I 4iv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter I 4ui NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameter I 4uiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameters 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameters I 4iv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Local Parameters I 4uiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Named Parameter 4d NV = uintptr ( get Proc Addr ( " " ) ) gp Program Named Parameter 4dv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Named Parameter 4f NV = uintptr ( get Proc Addr ( " " ) ) gp Program Named Parameter 4fv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameter 4d NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameter 4dv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameter 4f NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameter 4fv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Program Parameteri ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Parameters 4dv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Parameters 4fv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Path Fragment Input Gen NV = uintptr ( get Proc Addr ( " " ) ) gp Program String ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Subroutine Parametersuiv NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1d = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1d EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1f = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1f EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1i EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1iv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1uiv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 1uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2d = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2d EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2f = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2f EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2i EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2iv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2uiv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 2uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3d = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3d EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3f = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3f EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3i EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3iv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3uiv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 3uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4d = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4d EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4f = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4f EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4i EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4iv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4uiv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform 4uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Handleui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Handleui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Handleui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Handleui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 3dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 3fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 4dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 4fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 2x 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 2dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 2dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 2fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 2fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 4dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 4fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 3x 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 2dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 2dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 2fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 2fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 3dv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 3fv = uintptr ( get Proc Addr ( " " ) ) gp Program Uniform Matrix 4x 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Program Uniformui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Program Uniformui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Program Vertex Limit NV = uintptr ( get Proc Addr ( " " ) ) gp Provoking Vertex = uintptr ( get Proc Addr ( " " ) ) gp Provoking Vertex EXT = uintptr ( get Proc Addr ( " " ) ) gp Push Attrib = uintptr ( get Proc Addr ( " " ) ) if gp Push Attrib = = 0 { return errors . New ( " " ) } gp Push Client Attrib = uintptr ( get Proc Addr ( " " ) ) if gp Push Client Attrib = = 0 { return errors . New ( " " ) } gp Push Client Attrib Default EXT = uintptr ( get Proc Addr ( " " ) ) gp Push Debug Group = uintptr ( get Proc Addr ( " " ) ) gp Push Debug Group KHR = uintptr ( get Proc Addr ( " " ) ) gp Push Group Marker EXT = uintptr ( get Proc Addr ( " " ) ) gp Push Matrix = uintptr ( get Proc Addr ( " " ) ) if gp Push Matrix = = 0 { return errors . New ( " " ) } gp Push Name = uintptr ( get Proc Addr ( " " ) ) if gp Push Name = = 0 { return errors . New ( " " ) } gp Query Counter = uintptr ( get Proc Addr ( " " ) ) gp Query Matrixx OES = uintptr ( get Proc Addr ( " " ) ) gp Query Object Parameterui AMD = uintptr ( get Proc Addr ( " " ) ) gp Query Resource NV = uintptr ( get Proc Addr ( " " ) ) gp Query Resource Tag NV = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 2d = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2d = = 0 { return errors . New ( " " ) } gp Raster Pos 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2dv = = 0 { return errors . New ( " " ) } gp Raster Pos 2f = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2f = = 0 { return errors . New ( " " ) } gp Raster Pos 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2fv = = 0 { return errors . New ( " " ) } gp Raster Pos 2i = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2i = = 0 { return errors . New ( " " ) } gp Raster Pos 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2iv = = 0 { return errors . New ( " " ) } gp Raster Pos 2s = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2s = = 0 { return errors . New ( " " ) } gp Raster Pos 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 2sv = = 0 { return errors . New ( " " ) } gp Raster Pos 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 2xv OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 3d = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3d = = 0 { return errors . New ( " " ) } gp Raster Pos 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3dv = = 0 { return errors . New ( " " ) } gp Raster Pos 3f = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3f = = 0 { return errors . New ( " " ) } gp Raster Pos 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3fv = = 0 { return errors . New ( " " ) } gp Raster Pos 3i = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3i = = 0 { return errors . New ( " " ) } gp Raster Pos 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3iv = = 0 { return errors . New ( " " ) } gp Raster Pos 3s = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3s = = 0 { return errors . New ( " " ) } gp Raster Pos 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 3sv = = 0 { return errors . New ( " " ) } gp Raster Pos 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 4d = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4d = = 0 { return errors . New ( " " ) } gp Raster Pos 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4dv = = 0 { return errors . New ( " " ) } gp Raster Pos 4f = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4f = = 0 { return errors . New ( " " ) } gp Raster Pos 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4fv = = 0 { return errors . New ( " " ) } gp Raster Pos 4i = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4i = = 0 { return errors . New ( " " ) } gp Raster Pos 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4iv = = 0 { return errors . New ( " " ) } gp Raster Pos 4s = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4s = = 0 { return errors . New ( " " ) } gp Raster Pos 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Raster Pos 4sv = = 0 { return errors . New ( " " ) } gp Raster Pos 4x OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Pos 4xv OES = uintptr ( get Proc Addr ( " " ) ) gp Raster Samples EXT = uintptr ( get Proc Addr ( " " ) ) gp Read Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Read Buffer = = 0 { return errors . New ( " " ) } gp Read Instruments SGIX = uintptr ( get Proc Addr ( " " ) ) gp Read Pixels = uintptr ( get Proc Addr ( " " ) ) if gp Read Pixels = = 0 { return errors . New ( " " ) } gp Readn Pixels = uintptr ( get Proc Addr ( " " ) ) gp Readn Pixels ARB = uintptr ( get Proc Addr ( " " ) ) gp Readn Pixels KHR = uintptr ( get Proc Addr ( " " ) ) gp Rectd = uintptr ( get Proc Addr ( " " ) ) if gp Rectd = = 0 { return errors . New ( " " ) } gp Rectdv = uintptr ( get Proc Addr ( " " ) ) if gp Rectdv = = 0 { return errors . New ( " " ) } gp Rectf = uintptr ( get Proc Addr ( " " ) ) if gp Rectf = = 0 { return errors . New ( " " ) } gp Rectfv = uintptr ( get Proc Addr ( " " ) ) if gp Rectfv = = 0 { return errors . New ( " " ) } gp Recti = uintptr ( get Proc Addr ( " " ) ) if gp Recti = = 0 { return errors . New ( " " ) } gp Rectiv = uintptr ( get Proc Addr ( " " ) ) if gp Rectiv = = 0 { return errors . New ( " " ) } gp Rects = uintptr ( get Proc Addr ( " " ) ) if gp Rects = = 0 { return errors . New ( " " ) } gp Rectsv = uintptr ( get Proc Addr ( " " ) ) if gp Rectsv = = 0 { return errors . New ( " " ) } gp Rectx OES = uintptr ( get Proc Addr ( " " ) ) gp Rectxv OES = uintptr ( get Proc Addr ( " " ) ) gp Reference Plane SGIX = uintptr ( get Proc Addr ( " " ) ) gp Release Keyed Mutex Win 3 2EXT = uintptr ( get Proc Addr ( " " ) ) gp Release Shader Compiler = uintptr ( get Proc Addr ( " " ) ) gp Render Gpu Mask NV = uintptr ( get Proc Addr ( " " ) ) gp Render Mode = uintptr ( get Proc Addr ( " " ) ) if gp Render Mode = = 0 { return errors . New ( " " ) } gp Renderbuffer Storage = uintptr ( get Proc Addr ( " " ) ) gp Renderbuffer Storage EXT = uintptr ( get Proc Addr ( " " ) ) gp Renderbuffer Storage Multisample = uintptr ( get Proc Addr ( " " ) ) gp Renderbuffer Storage Multisample Coverage NV = uintptr ( get Proc Addr ( " " ) ) gp Renderbuffer Storage Multisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Replacement Code Pointer SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeub SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeubv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 4f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 4f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 4ub Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Color 4ub Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Color 4f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Color 4f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Tex Coord 2f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeui Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeuiv SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeus SUN = uintptr ( get Proc Addr ( " " ) ) gp Replacement Codeusv SUN = uintptr ( get Proc Addr ( " " ) ) gp Request Resident Programs NV = uintptr ( get Proc Addr ( " " ) ) gp Reset Histogram EXT = uintptr ( get Proc Addr ( " " ) ) gp Reset Minmax EXT = uintptr ( get Proc Addr ( " " ) ) gp Resize Buffers MESA = uintptr ( get Proc Addr ( " " ) ) gp Resolve Depth Values NV = uintptr ( get Proc Addr ( " " ) ) gp Resume Transform Feedback = uintptr ( get Proc Addr ( " " ) ) gp Resume Transform Feedback NV = uintptr ( get Proc Addr ( " " ) ) gp Rotated = uintptr ( get Proc Addr ( " " ) ) if gp Rotated = = 0 { return errors . New ( " " ) } gp Rotatef = uintptr ( get Proc Addr ( " " ) ) if gp Rotatef = = 0 { return errors . New ( " " ) } gp Rotatex OES = uintptr ( get Proc Addr ( " " ) ) gp Sample Coverage = uintptr ( get Proc Addr ( " " ) ) if gp Sample Coverage = = 0 { return errors . New ( " " ) } gp Sample Coverage ARB = uintptr ( get Proc Addr ( " " ) ) gp Sample Coveragex OES = uintptr ( get Proc Addr ( " " ) ) gp Sample Map ATI = uintptr ( get Proc Addr ( " " ) ) gp Sample Mask EXT = uintptr ( get Proc Addr ( " " ) ) gp Sample Mask Indexed NV = uintptr ( get Proc Addr ( " " ) ) gp Sample Mask SGIS = uintptr ( get Proc Addr ( " " ) ) gp Sample Maski = uintptr ( get Proc Addr ( " " ) ) gp Sample Pattern EXT = uintptr ( get Proc Addr ( " " ) ) gp Sample Pattern SGIS = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameter Iiv = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameter Iuiv = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameterf = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Sampler Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Scaled = uintptr ( get Proc Addr ( " " ) ) if gp Scaled = = 0 { return errors . New ( " " ) } gp Scalef = uintptr ( get Proc Addr ( " " ) ) if gp Scalef = = 0 { return errors . New ( " " ) } gp Scalex OES = uintptr ( get Proc Addr ( " " ) ) gp Scissor = uintptr ( get Proc Addr ( " " ) ) if gp Scissor = = 0 { return errors . New ( " " ) } gp Scissor Arrayv = uintptr ( get Proc Addr ( " " ) ) gp Scissor Indexed = uintptr ( get Proc Addr ( " " ) ) gp Scissor Indexedv = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3b = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3b = = 0 { return errors . New ( " " ) } gp Secondary Color 3b EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3bv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3bv = = 0 { return errors . New ( " " ) } gp Secondary Color 3bv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3d = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3d = = 0 { return errors . New ( " " ) } gp Secondary Color 3d EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3dv = = 0 { return errors . New ( " " ) } gp Secondary Color 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3f = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3f = = 0 { return errors . New ( " " ) } gp Secondary Color 3f EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3fv = = 0 { return errors . New ( " " ) } gp Secondary Color 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3i = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3i = = 0 { return errors . New ( " " ) } gp Secondary Color 3i EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3iv = = 0 { return errors . New ( " " ) } gp Secondary Color 3iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3s = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3s = = 0 { return errors . New ( " " ) } gp Secondary Color 3s EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3sv = = 0 { return errors . New ( " " ) } gp Secondary Color 3sv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3ub = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3ub = = 0 { return errors . New ( " " ) } gp Secondary Color 3ub EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3ubv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3ubv = = 0 { return errors . New ( " " ) } gp Secondary Color 3ubv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3ui = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3ui = = 0 { return errors . New ( " " ) } gp Secondary Color 3ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3uiv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3uiv = = 0 { return errors . New ( " " ) } gp Secondary Color 3uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3us = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3us = = 0 { return errors . New ( " " ) } gp Secondary Color 3us EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color 3usv = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color 3usv = = 0 { return errors . New ( " " ) } gp Secondary Color 3usv EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color Format NV = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Secondary Color Pointer = = 0 { return errors . New ( " " ) } gp Secondary Color Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Secondary Color Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Select Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Select Buffer = = 0 { return errors . New ( " " ) } gp Select Perf Monitor Counters AMD = uintptr ( get Proc Addr ( " " ) ) gp Semaphore Parameterui 6 4v EXT = uintptr ( get Proc Addr ( " " ) ) gp Separable Filter 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Set Fence APPLE = uintptr ( get Proc Addr ( " " ) ) gp Set Fence NV = uintptr ( get Proc Addr ( " " ) ) gp Set Fragment Shader Constant ATI = uintptr ( get Proc Addr ( " " ) ) gp Set Invariant EXT = uintptr ( get Proc Addr ( " " ) ) gp Set Local Constant EXT = uintptr ( get Proc Addr ( " " ) ) gp Set Multisamplefv AMD = uintptr ( get Proc Addr ( " " ) ) gp Shade Model = uintptr ( get Proc Addr ( " " ) ) if gp Shade Model = = 0 { return errors . New ( " " ) } gp Shader Binary = uintptr ( get Proc Addr ( " " ) ) gp Shader Op 1EXT = uintptr ( get Proc Addr ( " " ) ) gp Shader Op 2EXT = uintptr ( get Proc Addr ( " " ) ) gp Shader Op 3EXT = uintptr ( get Proc Addr ( " " ) ) gp Shader Source = uintptr ( get Proc Addr ( " " ) ) if gp Shader Source = = 0 { return errors . New ( " " ) } gp Shader Source ARB = uintptr ( get Proc Addr ( " " ) ) gp Shader Storage Block Binding = uintptr ( get Proc Addr ( " " ) ) gp Sharpen Tex Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Signal Semaphore EXT = uintptr ( get Proc Addr ( " " ) ) gp Signal Vk Fence NV = uintptr ( get Proc Addr ( " " ) ) gp Signal Vk Semaphore NV = uintptr ( get Proc Addr ( " " ) ) gp Specialize Shader ARB = uintptr ( get Proc Addr ( " " ) ) gp Sprite Parameterf SGIX = uintptr ( get Proc Addr ( " " ) ) gp Sprite Parameterfv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Sprite Parameteri SGIX = uintptr ( get Proc Addr ( " " ) ) gp Sprite Parameteriv SGIX = uintptr ( get Proc Addr ( " " ) ) gp Start Instruments SGIX = uintptr ( get Proc Addr ( " " ) ) gp State Capture NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Clear Tag EXT = uintptr ( get Proc Addr ( " " ) ) gp Stencil Fill Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Fill Path NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Func = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Func = = 0 { return errors . New ( " " ) } gp Stencil Func Separate = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Func Separate = = 0 { return errors . New ( " " ) } gp Stencil Func Separate ATI = uintptr ( get Proc Addr ( " " ) ) gp Stencil Mask = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Mask = = 0 { return errors . New ( " " ) } gp Stencil Mask Separate = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Mask Separate = = 0 { return errors . New ( " " ) } gp Stencil Op = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Op = = 0 { return errors . New ( " " ) } gp Stencil Op Separate = uintptr ( get Proc Addr ( " " ) ) if gp Stencil Op Separate = = 0 { return errors . New ( " " ) } gp Stencil Op Separate ATI = uintptr ( get Proc Addr ( " " ) ) gp Stencil Op Value AMD = uintptr ( get Proc Addr ( " " ) ) gp Stencil Stroke Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Stroke Path NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Then Cover Fill Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Then Cover Fill Path NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Then Cover Stroke Path Instanced NV = uintptr ( get Proc Addr ( " " ) ) gp Stencil Then Cover Stroke Path NV = uintptr ( get Proc Addr ( " " ) ) gp Stop Instruments SGIX = uintptr ( get Proc Addr ( " " ) ) gp String Marker GREMEDY = uintptr ( get Proc Addr ( " " ) ) gp Subpixel Precision Bias NV = uintptr ( get Proc Addr ( " " ) ) gp Swizzle EXT = uintptr ( get Proc Addr ( " " ) ) gp Sync Texture INTEL = uintptr ( get Proc Addr ( " " ) ) gp Tag Sample Buffer SGIX = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3b EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3bv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3d EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3f EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3fv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3i EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3s EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent 3sv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tangent Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Tbuffer Mask 3DFX = uintptr ( get Proc Addr ( " " ) ) gp Tessellation Factor AMD = uintptr ( get Proc Addr ( " " ) ) gp Tessellation Mode AMD = uintptr ( get Proc Addr ( " " ) ) gp Test Fence APPLE = uintptr ( get Proc Addr ( " " ) ) gp Test Fence NV = uintptr ( get Proc Addr ( " " ) ) gp Test Object APPLE = uintptr ( get Proc Addr ( " " ) ) gp Tex Buffer ARB = uintptr ( get Proc Addr ( " " ) ) gp Tex Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Tex Bump Parameterfv ATI = uintptr ( get Proc Addr ( " " ) ) gp Tex Bump Parameteriv ATI = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1b OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1bv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1d = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1d = = 0 { return errors . New ( " " ) } gp Tex Coord 1dv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1dv = = 0 { return errors . New ( " " ) } gp Tex Coord 1f = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1f = = 0 { return errors . New ( " " ) } gp Tex Coord 1fv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1fv = = 0 { return errors . New ( " " ) } gp Tex Coord 1h NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1hv NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1i = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1i = = 0 { return errors . New ( " " ) } gp Tex Coord 1iv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1iv = = 0 { return errors . New ( " " ) } gp Tex Coord 1s = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1s = = 0 { return errors . New ( " " ) } gp Tex Coord 1sv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 1sv = = 0 { return errors . New ( " " ) } gp Tex Coord 1x OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 1xv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2b OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2bv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2d = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2d = = 0 { return errors . New ( " " ) } gp Tex Coord 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2dv = = 0 { return errors . New ( " " ) } gp Tex Coord 2f = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2f = = 0 { return errors . New ( " " ) } gp Tex Coord 2f Color 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Color 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Color 4f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Color 4f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Color 4ub Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Color 4ub Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Normal 3f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Normal 3f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Vertex 3f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2f Vertex 3fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2fv = = 0 { return errors . New ( " " ) } gp Tex Coord 2h NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2hv NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2i = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2i = = 0 { return errors . New ( " " ) } gp Tex Coord 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2iv = = 0 { return errors . New ( " " ) } gp Tex Coord 2s = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2s = = 0 { return errors . New ( " " ) } gp Tex Coord 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 2sv = = 0 { return errors . New ( " " ) } gp Tex Coord 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 2xv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3b OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3bv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3d = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3d = = 0 { return errors . New ( " " ) } gp Tex Coord 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3dv = = 0 { return errors . New ( " " ) } gp Tex Coord 3f = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3f = = 0 { return errors . New ( " " ) } gp Tex Coord 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3fv = = 0 { return errors . New ( " " ) } gp Tex Coord 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3i = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3i = = 0 { return errors . New ( " " ) } gp Tex Coord 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3iv = = 0 { return errors . New ( " " ) } gp Tex Coord 3s = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3s = = 0 { return errors . New ( " " ) } gp Tex Coord 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 3sv = = 0 { return errors . New ( " " ) } gp Tex Coord 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4b OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4bv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4d = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4d = = 0 { return errors . New ( " " ) } gp Tex Coord 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4dv = = 0 { return errors . New ( " " ) } gp Tex Coord 4f = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4f = = 0 { return errors . New ( " " ) } gp Tex Coord 4f Color 4f Normal 3f Vertex 4f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4f Color 4f Normal 3f Vertex 4fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4f Vertex 4f SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4f Vertex 4fv SUN = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4fv = = 0 { return errors . New ( " " ) } gp Tex Coord 4h NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4i = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4i = = 0 { return errors . New ( " " ) } gp Tex Coord 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4iv = = 0 { return errors . New ( " " ) } gp Tex Coord 4s = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4s = = 0 { return errors . New ( " " ) } gp Tex Coord 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord 4sv = = 0 { return errors . New ( " " ) } gp Tex Coord 4x OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord 4xv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord Format NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Tex Coord Pointer = = 0 { return errors . New ( " " ) } gp Tex Coord Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Tex Coord Pointerv INTEL = uintptr ( get Proc Addr ( " " ) ) gp Tex Envf = uintptr ( get Proc Addr ( " " ) ) if gp Tex Envf = = 0 { return errors . New ( " " ) } gp Tex Envfv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Envfv = = 0 { return errors . New ( " " ) } gp Tex Envi = uintptr ( get Proc Addr ( " " ) ) if gp Tex Envi = = 0 { return errors . New ( " " ) } gp Tex Enviv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Enviv = = 0 { return errors . New ( " " ) } gp Tex Envx OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Envxv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Filter Func SGIS = uintptr ( get Proc Addr ( " " ) ) gp Tex Gend = uintptr ( get Proc Addr ( " " ) ) if gp Tex Gend = = 0 { return errors . New ( " " ) } gp Tex Gendv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Gendv = = 0 { return errors . New ( " " ) } gp Tex Genf = uintptr ( get Proc Addr ( " " ) ) if gp Tex Genf = = 0 { return errors . New ( " " ) } gp Tex Genfv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Genfv = = 0 { return errors . New ( " " ) } gp Tex Geni = uintptr ( get Proc Addr ( " " ) ) if gp Tex Geni = = 0 { return errors . New ( " " ) } gp Tex Geniv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Geniv = = 0 { return errors . New ( " " ) } gp Tex Genx OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Genxv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Image 1D = = 0 { return errors . New ( " " ) } gp Tex Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Image 2D = = 0 { return errors . New ( " " ) } gp Tex Image 2DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 2DMultisample Coverage NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 3D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Image 3D = = 0 { return errors . New ( " " ) } gp Tex Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 3DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 3DMultisample Coverage NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Image 4DSGIS = uintptr ( get Proc Addr ( " " ) ) gp Tex Page Commitment ARB = uintptr ( get Proc Addr ( " " ) ) gp Tex Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Parameterf = uintptr ( get Proc Addr ( " " ) ) if gp Tex Parameterf = = 0 { return errors . New ( " " ) } gp Tex Parameterfv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Parameterfv = = 0 { return errors . New ( " " ) } gp Tex Parameteri = uintptr ( get Proc Addr ( " " ) ) if gp Tex Parameteri = = 0 { return errors . New ( " " ) } gp Tex Parameteriv = uintptr ( get Proc Addr ( " " ) ) if gp Tex Parameteriv = = 0 { return errors . New ( " " ) } gp Tex Parameterx OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Parameterxv OES = uintptr ( get Proc Addr ( " " ) ) gp Tex Renderbuffer NV = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage 1D = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage 2D = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage 2DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage 3D = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage 3DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Mem 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Mem 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Mem 2DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Mem 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Mem 3DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Storage Sparse AMD = uintptr ( get Proc Addr ( " " ) ) gp Tex Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Sub Image 1D = = 0 { return errors . New ( " " ) } gp Tex Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Sub Image 2D = = 0 { return errors . New ( " " ) } gp Tex Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) if gp Tex Sub Image 3D = = 0 { return errors . New ( " " ) } gp Tex Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Tex Sub Image 4DSGIS = uintptr ( get Proc Addr ( " " ) ) gp Texture Barrier = uintptr ( get Proc Addr ( " " ) ) gp Texture Barrier NV = uintptr ( get Proc Addr ( " " ) ) gp Texture Buffer = uintptr ( get Proc Addr ( " " ) ) gp Texture Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Texture Buffer Range EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Color Mask SGIS = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 2DMultisample Coverage NV = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 2DMultisample NV = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 3DMultisample Coverage NV = uintptr ( get Proc Addr ( " " ) ) gp Texture Image 3DMultisample NV = uintptr ( get Proc Addr ( " " ) ) gp Texture Light EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Material EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Normal EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Page Commitment EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameter Iiv = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameter Iiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameter Iuiv = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameter Iuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameterf = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameterf EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameterfv = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameterfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameteri = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameteri EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameteriv = uintptr ( get Proc Addr ( " " ) ) gp Texture Parameteriv EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Range APPLE = uintptr ( get Proc Addr ( " " ) ) gp Texture Renderbuffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 1D = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 2D = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 2DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 2DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 3D = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 3DMultisample = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage 3DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Mem 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Mem 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Mem 2DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Mem 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Mem 3DMultisample EXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Storage Sparse AMD = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 1D = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 1DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 2D = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 2DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 3D = uintptr ( get Proc Addr ( " " ) ) gp Texture Sub Image 3DEXT = uintptr ( get Proc Addr ( " " ) ) gp Texture View = uintptr ( get Proc Addr ( " " ) ) gp Track Matrix NV = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Attribs NV = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Buffer Base = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Buffer Range = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Stream Attribs NV = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Varyings EXT = uintptr ( get Proc Addr ( " " ) ) gp Transform Feedback Varyings NV = uintptr ( get Proc Addr ( " " ) ) gp Transform Path NV = uintptr ( get Proc Addr ( " " ) ) gp Translated = uintptr ( get Proc Addr ( " " ) ) if gp Translated = = 0 { return errors . New ( " " ) } gp Translatef = uintptr ( get Proc Addr ( " " ) ) if gp Translatef = = 0 { return errors . New ( " " ) } gp Translatex OES = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1d = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1f = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 1f = = 0 { return errors . New ( " " ) } gp Uniform 1f ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 1fv = = 0 { return errors . New ( " " ) } gp Uniform 1fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1i = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 1i = = 0 { return errors . New ( " " ) } gp Uniform 1i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1i ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1iv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 1iv = = 0 { return errors . New ( " " ) } gp Uniform 1iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 1uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2d = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2f = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 2f = = 0 { return errors . New ( " " ) } gp Uniform 2f ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 2fv = = 0 { return errors . New ( " " ) } gp Uniform 2fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2i = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 2i = = 0 { return errors . New ( " " ) } gp Uniform 2i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2i ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 2iv = = 0 { return errors . New ( " " ) } gp Uniform 2iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 2uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3d = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3f = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 3f = = 0 { return errors . New ( " " ) } gp Uniform 3f ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 3fv = = 0 { return errors . New ( " " ) } gp Uniform 3fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3i = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 3i = = 0 { return errors . New ( " " ) } gp Uniform 3i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3i ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 3iv = = 0 { return errors . New ( " " ) } gp Uniform 3iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 3uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4d = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4f = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 4f = = 0 { return errors . New ( " " ) } gp Uniform 4f ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 4fv = = 0 { return errors . New ( " " ) } gp Uniform 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4i = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 4i = = 0 { return errors . New ( " " ) } gp Uniform 4i 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4i 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4i ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform 4iv = = 0 { return errors . New ( " " ) } gp Uniform 4iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform 4uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform Block Binding = uintptr ( get Proc Addr ( " " ) ) gp Uniform Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Uniform Handleui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform Handleui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform Handleui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform Handleui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 2dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 2fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 2fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 2x 3dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 2x 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 2x 3fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 2x 4dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 2x 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 2x 4fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 3dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 3fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 3fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 3x 2dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 3x 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 3x 2fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 3x 4dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 3x 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 3x 4fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 4dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 4fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 4x 2dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 4x 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 4x 2fv = = 0 { return errors . New ( " " ) } gp Uniform Matrix 4x 3dv = uintptr ( get Proc Addr ( " " ) ) gp Uniform Matrix 4x 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Uniform Matrix 4x 3fv = = 0 { return errors . New ( " " ) } gp Uniform Subroutinesuiv = uintptr ( get Proc Addr ( " " ) ) gp Uniformui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Uniformui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Unlock Arrays EXT = uintptr ( get Proc Addr ( " " ) ) gp Unmap Buffer = uintptr ( get Proc Addr ( " " ) ) if gp Unmap Buffer = = 0 { return errors . New ( " " ) } gp Unmap Buffer ARB = uintptr ( get Proc Addr ( " " ) ) gp Unmap Named Buffer = uintptr ( get Proc Addr ( " " ) ) gp Unmap Named Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Unmap Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Unmap Texture 2DINTEL = uintptr ( get Proc Addr ( " " ) ) gp Update Object Buffer ATI = uintptr ( get Proc Addr ( " " ) ) gp Use Program = uintptr ( get Proc Addr ( " " ) ) if gp Use Program = = 0 { return errors . New ( " " ) } gp Use Program Object ARB = uintptr ( get Proc Addr ( " " ) ) gp Use Program Stages = uintptr ( get Proc Addr ( " " ) ) gp Use Program Stages EXT = uintptr ( get Proc Addr ( " " ) ) gp Use Shader Program EXT = uintptr ( get Proc Addr ( " " ) ) gp VDPAUFini NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUGet Surfaceiv NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUInit NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUIs Surface NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUMap Surfaces NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAURegister Output Surface NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAURegister Video Surface NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUSurface Access NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUUnmap Surfaces NV = uintptr ( get Proc Addr ( " " ) ) gp VDPAUUnregister Surface NV = uintptr ( get Proc Addr ( " " ) ) gp Validate Program = uintptr ( get Proc Addr ( " " ) ) if gp Validate Program = = 0 { return errors . New ( " " ) } gp Validate Program ARB = uintptr ( get Proc Addr ( " " ) ) gp Validate Program Pipeline = uintptr ( get Proc Addr ( " " ) ) gp Validate Program Pipeline EXT = uintptr ( get Proc Addr ( " " ) ) gp Variant Array Object ATI = uintptr ( get Proc Addr ( " " ) ) gp Variant Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantbv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantdv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantsv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantubv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantuiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Variantusv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2b OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2bv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2d = = 0 { return errors . New ( " " ) } gp Vertex 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2dv = = 0 { return errors . New ( " " ) } gp Vertex 2f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2f = = 0 { return errors . New ( " " ) } gp Vertex 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2fv = = 0 { return errors . New ( " " ) } gp Vertex 2h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2i = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2i = = 0 { return errors . New ( " " ) } gp Vertex 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2iv = = 0 { return errors . New ( " " ) } gp Vertex 2s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2s = = 0 { return errors . New ( " " ) } gp Vertex 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 2sv = = 0 { return errors . New ( " " ) } gp Vertex 2x OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 2xv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3b OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3bv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3d = = 0 { return errors . New ( " " ) } gp Vertex 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3dv = = 0 { return errors . New ( " " ) } gp Vertex 3f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3f = = 0 { return errors . New ( " " ) } gp Vertex 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3fv = = 0 { return errors . New ( " " ) } gp Vertex 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3i = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3i = = 0 { return errors . New ( " " ) } gp Vertex 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3iv = = 0 { return errors . New ( " " ) } gp Vertex 3s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3s = = 0 { return errors . New ( " " ) } gp Vertex 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 3sv = = 0 { return errors . New ( " " ) } gp Vertex 3x OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 3xv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4b OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4bv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4d = = 0 { return errors . New ( " " ) } gp Vertex 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4dv = = 0 { return errors . New ( " " ) } gp Vertex 4f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4f = = 0 { return errors . New ( " " ) } gp Vertex 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4fv = = 0 { return errors . New ( " " ) } gp Vertex 4h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4i = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4i = = 0 { return errors . New ( " " ) } gp Vertex 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4iv = = 0 { return errors . New ( " " ) } gp Vertex 4s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4s = = 0 { return errors . New ( " " ) } gp Vertex 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex 4sv = = 0 { return errors . New ( " " ) } gp Vertex 4x OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex 4xv OES = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Attrib Binding = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Attrib Format = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Attrib IFormat = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Attrib LFormat = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Bind Vertex Buffer EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Binding Divisor = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Color Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Edge Flag Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Element Buffer = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Fog Coord Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Index Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Multi Tex Coord Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Normal Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Parameteri APPLE = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Range APPLE = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Range NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Secondary Color Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Tex Coord Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib Binding EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib Divisor EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib Format EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib IFormat EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib IOffset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib LFormat EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib LOffset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Attrib Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Binding Divisor EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Buffer = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Buffers = uintptr ( get Proc Addr ( " " ) ) gp Vertex Array Vertex Offset EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1d = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1d ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1d NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1dv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1f = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1f ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1f NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1fv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1s = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1s ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1s NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 1sv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 1sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 1sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2d = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2d ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2d NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2dv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2f = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2f ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2f NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2fv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2s = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2s ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2s NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 2sv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 2sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 2sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3d = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3d ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3d NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3dv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3f = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3f ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3f NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3fv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3s = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3s ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3s NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 3sv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 3sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 3sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nbv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nbv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nbv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Niv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Niv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Niv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nsv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nsv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nsv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nub = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nub = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nub ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nubv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nubv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nubv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nuiv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nuiv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nuiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4Nusv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4Nusv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4Nusv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4bv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4bv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4bv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4d = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4d = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4d ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4d NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4dv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4dv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4f = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4f = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4f ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4f NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4fv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4fv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4h NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4iv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4iv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4s = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4s = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4s ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4s NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4sv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4sv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4ub NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4ubv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4ubv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4ubv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4ubv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4uiv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4uiv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4uiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib 4usv = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib 4usv = = 0 { return errors . New ( " " ) } gp Vertex Attrib 4usv ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Array Object ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Binding = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Divisor ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Format = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Format NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 1i EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 1iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 1ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 1uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 2i EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 2iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 2ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 2uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 3i EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 3iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 3ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 3uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4bv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4i EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4iv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4sv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4ubv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4ui EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4uiv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib I 4usv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib IFormat = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib IFormat NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib IPointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1d = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1d EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1dv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1ui 6 4ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1ui 6 4v ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 1ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2d = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2d EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2dv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 2ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3d = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3d EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3dv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 3ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4d = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4d EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4dv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4dv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4i 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4i 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4ui 6 4NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib L 4ui 6 4v NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib LFormat = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib LFormat NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib LPointer = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib LPointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 1ui = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 1uiv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 2ui = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 2uiv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 3ui = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 3uiv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 4ui = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib P 4uiv = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Parameteri AMD = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Attrib Pointer = = 0 { return errors . New ( " " ) } gp Vertex Attrib Pointer ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attrib Pointer NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 1dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 1fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 1hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 1sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 2dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 2fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 2hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 2sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 3dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 3fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 3hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 3sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 4dv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 4fv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 4hv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 4sv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Attribs 4ubv NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Binding Divisor = uintptr ( get Proc Addr ( " " ) ) gp Vertex Blend ARB = uintptr ( get Proc Addr ( " " ) ) gp Vertex Blend Envf ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Blend Envi ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Format NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Pointer = uintptr ( get Proc Addr ( " " ) ) if gp Vertex Pointer = = 0 { return errors . New ( " " ) } gp Vertex Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Pointer List IBM = uintptr ( get Proc Addr ( " " ) ) gp Vertex Pointerv INTEL = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1d ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1dv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1f ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1fv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1i ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1iv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1s ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 1sv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2d ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2dv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2f ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2fv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2i ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2iv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2s ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 2sv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3d ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3dv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3f ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3fv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3i ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3iv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3s ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 3sv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4d ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4dv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4f ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4fv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4i ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4iv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4s ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Stream 4sv ATI = uintptr ( get Proc Addr ( " " ) ) gp Vertex Weight Pointer EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Weightf EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Weightfv EXT = uintptr ( get Proc Addr ( " " ) ) gp Vertex Weighth NV = uintptr ( get Proc Addr ( " " ) ) gp Vertex Weighthv NV = uintptr ( get Proc Addr ( " " ) ) gp Video Capture NV = uintptr ( get Proc Addr ( " " ) ) gp Video Capture Stream Parameterdv NV = uintptr ( get Proc Addr ( " " ) ) gp Video Capture Stream Parameterfv NV = uintptr ( get Proc Addr ( " " ) ) gp Video Capture Stream Parameteriv NV = uintptr ( get Proc Addr ( " " ) ) gp Viewport = uintptr ( get Proc Addr ( " " ) ) if gp Viewport = = 0 { return errors . New ( " " ) } gp Viewport Arrayv = uintptr ( get Proc Addr ( " " ) ) gp Viewport Indexedf = uintptr ( get Proc Addr ( " " ) ) gp Viewport Indexedfv = uintptr ( get Proc Addr ( " " ) ) gp Viewport Position WScale NV = uintptr ( get Proc Addr ( " " ) ) gp Viewport Swizzle NV = uintptr ( get Proc Addr ( " " ) ) gp Wait Semaphore EXT = uintptr ( get Proc Addr ( " " ) ) gp Wait Sync = uintptr ( get Proc Addr ( " " ) ) gp Wait Vk Semaphore NV = uintptr ( get Proc Addr ( " " ) ) gp Weight Paths NV = uintptr ( get Proc Addr ( " " ) ) gp Weight Pointer ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightbv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightdv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightfv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightsv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightubv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightuiv ARB = uintptr ( get Proc Addr ( " " ) ) gp Weightusv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2d = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2d = = 0 { return errors . New ( " " ) } gp Window Pos 2d ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2d MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2dv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2dv = = 0 { return errors . New ( " " ) } gp Window Pos 2dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2dv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2f = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2f = = 0 { return errors . New ( " " ) } gp Window Pos 2f ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2f MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2fv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2fv = = 0 { return errors . New ( " " ) } gp Window Pos 2fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2fv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2i = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2i = = 0 { return errors . New ( " " ) } gp Window Pos 2i ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2i MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2iv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2iv = = 0 { return errors . New ( " " ) } gp Window Pos 2iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2iv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2s = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2s = = 0 { return errors . New ( " " ) } gp Window Pos 2s ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2s MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2sv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 2sv = = 0 { return errors . New ( " " ) } gp Window Pos 2sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 2sv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3d = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3d = = 0 { return errors . New ( " " ) } gp Window Pos 3d ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3d MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3dv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3dv = = 0 { return errors . New ( " " ) } gp Window Pos 3dv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3dv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3f = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3f = = 0 { return errors . New ( " " ) } gp Window Pos 3f ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3f MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3fv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3fv = = 0 { return errors . New ( " " ) } gp Window Pos 3fv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3fv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3i = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3i = = 0 { return errors . New ( " " ) } gp Window Pos 3i ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3i MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3iv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3iv = = 0 { return errors . New ( " " ) } gp Window Pos 3iv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3iv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3s = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3s = = 0 { return errors . New ( " " ) } gp Window Pos 3s ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3s MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3sv = uintptr ( get Proc Addr ( " " ) ) if gp Window Pos 3sv = = 0 { return errors . New ( " " ) } gp Window Pos 3sv ARB = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 3sv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4d MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4dv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4f MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4fv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4i MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4iv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4s MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Pos 4sv MESA = uintptr ( get Proc Addr ( " " ) ) gp Window Rectangles EXT = uintptr ( get Proc Addr ( " " ) ) gp Write Mask EXT = uintptr ( get Proc Addr ( " " ) ) return nil } 
func New Context ( sample Rate int ) ( * Context , error ) { the Context Lock . Lock ( ) defer the Context Lock . Unlock ( ) if the Context ! = nil { panic ( " " ) } c : = & Context { sample Rate : sample Rate , c : new Context ( sample Rate ) , players : map [ * player Impl ] struct { } { } , inited : make ( chan struct { } ) , } the Context = c h : = get Hook ( ) h . On Suspend Audio ( func ( ) { c . m . Lock ( ) c . suspended = true c . m . Unlock ( ) } ) h . On Resume Audio ( func ( ) { c . m . Lock ( ) c . suspended = false c . m . Unlock ( ) } ) h . Append Hook On Before Update ( func ( ) error { c . inited Once . Do ( func ( ) { close ( c . inited ) } ) var err error the Context Lock . Lock ( ) if the Context ! = nil { the Context . m . Lock ( ) err = the Context . err the Context . m . Unlock ( ) } the Context Lock . Unlock ( ) return err } ) return c , nil } 
func ( c * Context ) Is Ready ( ) bool { c . m . Lock ( ) r : = c . ready c . m . Unlock ( ) return r } 
func New Player ( context * Context , src io . Read Closer ) ( * Player , error ) { p : = & Player { & player Impl { context : context , src : src , sample Rate : context . sample Rate , volume : 1 , } , } if seeker , ok : = p . p . src . ( io . Seeker ) ; ok { if err ! = nil { return nil , err } p . p . pos = pos } runtime . Set Finalizer ( p , ( * Player ) . finalize ) return p , nil } 
func New Player From Bytes ( context * Context , src [ ] byte ) ( * Player , error ) { b : = Bytes Read Seek Closer ( src ) p , err : = New Player ( context , b ) if err ! = nil { } return p , nil } 
func ( p * Player ) Close ( ) error { runtime . Set Finalizer ( p , nil ) return p . p . Close ( ) } 
func ( p * Player ) Seek ( offset time . Duration ) error { return p . p . Seek ( offset ) } 
func ( d * decoder ) Read ( p [ ] byte ) ( int , error ) { if len ( p ) = = 0 { return 0 , nil } for d . idat Length = = 0 { } } d . idat Length = binary . Big Endian . Uint 3 2 ( d . tmp [ : 4 ] ) if string ( d . tmp [ 4 : 8 ] ) ! = " " { return 0 , Format Error ( " " ) } d . crc . Reset ( ) d . crc . Write ( d . tmp [ 4 : 8 ] ) } if int ( d . idat Length ) < 0 { return 0 , Unsupported Error ( " " ) } n , err : = d . r . Read ( p [ : min ( len ( p ) , int ( d . idat Length ) ) ] ) d . crc . Write ( p [ : n ] ) d . idat Length - = uint 3 2 ( n ) return n , err } 
func ( d * decoder ) decode ( ) ( image . Image , error ) { r , err : = zlib . New Reader ( d ) if err ! = nil { return nil , err } defer r . Close ( ) var img image . Image if d . interlace = = it None { img , err = d . read Image Pass ( r , 0 , false ) if err ! = nil { return nil , err } } else if d . interlace = = it Adam 7 { if err ! = nil { return nil , err } for pass : = 0 ; pass < 7 ; pass + + { image Pass , err : = d . read Image Pass ( r , pass , false ) if err ! = nil { return nil , err } if image Pass ! = nil { d . merge Pass Into ( img , image Pass , pass ) } } } for i : = 0 ; n = = 0 & & err = = nil ; i + + { if i = = 1 0 0 { return nil , io . Err No Progress } n , err = r . Read ( d . tmp [ : 1 ] ) } if err ! = nil & & err ! = io . EOF { return nil , Format Error ( err . Error ( ) ) } if n ! = 0 | | d . idat Length ! = 0 { return nil , Format Error ( " " ) } return img , nil } 
func ( d * decoder ) read Image Pass ( r io . Reader , pass int , allocate Only bool ) ( image . Image , error ) { bits Per Pixel : = 0 pix Offset : = 0 var ( gray * image . Gray rgba * image . RGBA paletted * image . Paletted nrgba * image . NRGBA gray 1 6 * image . Gray 1 6 rgba 6 4 * image . RGBA 6 4 nrgba 6 4 * image . NRGBA 6 4 img image . Image ) width , height : = d . width , d . height if d . interlace = = it Adam 7 & & ! allocate Only { p : = interlacing [ pass ] height = ( height - p . y Offset + p . y Factor - 1 ) / p . y Factor } } switch d . cb { case cb G 1 , cb G 2 , cb G 4 , cb G 8 : bits Per Pixel = d . depth if d . use Transparent { nrgba = image . New NRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba } else { gray = image . New Gray ( image . Rect ( 0 , 0 , width , height ) ) img = gray } case cb GA 8 : bits Per Pixel = 1 6 nrgba = image . New NRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba case cb TC 8 : bits Per Pixel = 2 4 if d . use Transparent { nrgba = image . New NRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba } else { rgba = image . New RGBA ( image . Rect ( 0 , 0 , width , height ) ) img = rgba } case cb P 1 , cb P 2 , cb P 4 , cb P 8 : bits Per Pixel = d . depth paletted = image . New Paletted ( image . Rect ( 0 , 0 , width , height ) , d . palette ) img = paletted case cb TCA 8 : bits Per Pixel = 3 2 nrgba = image . New NRGBA ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba case cb G 1 6 : bits Per Pixel = 1 6 if d . use Transparent { nrgba 6 4 = image . New NRGBA 6 4 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba 6 4 } else { gray 1 6 = image . New Gray 1 6 ( image . Rect ( 0 , 0 , width , height ) ) img = gray 1 6 } case cb GA 1 6 : bits Per Pixel = 3 2 nrgba 6 4 = image . New NRGBA 6 4 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba 6 4 case cb TC 1 6 : bits Per Pixel = 4 8 if d . use Transparent { nrgba 6 4 = image . New NRGBA 6 4 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba 6 4 } else { rgba 6 4 = image . New RGBA 6 4 ( image . Rect ( 0 , 0 , width , height ) ) img = rgba 6 4 } case cb TCA 1 6 : bits Per Pixel = 6 4 nrgba 6 4 = image . New NRGBA 6 4 ( image . Rect ( 0 , 0 , width , height ) ) img = nrgba 6 4 } if allocate Only { return img , nil } bytes Per Pixel : = ( bits Per Pixel + 7 ) / 8 pr : = make ( [ ] uint 8 , row Size ) for y : = 0 ; y < height ; y + + { if err ! = nil { if err = = io . EOF | | err = = io . Err Unexpected EOF { return nil , Format Error ( " " ) } return nil , err } pdat : = pr [ 1 : ] switch cr [ 0 ] { case ft None : } case ft Up : for i , p : = range pdat { cdat [ i ] + = p } case ft Average : } for i : = bytes Per Pixel ; i < len ( cdat ) ; i + + { cdat [ i ] + = uint 8 ( ( int ( cdat [ i - bytes Per Pixel ] ) + int ( pdat [ i ] ) ) / 2 ) } case ft Paeth : filter Paeth ( cdat , pdat , bytes Per Pixel ) default : return nil , Format Error ( " " ) } for x : = 0 ; x < width ; x + = 8 { b : = cdat [ x / 8 ] for x 2 : = 0 ; x 2 < 8 & & x + x 2 < width ; x 2 + + { ycol : = ( b > > 7 ) * 0xff acol : = uint 8 ( 0xff ) if ycol = = ty { acol = 0x 0 0 } nrgba . Set NRGBA ( x + x 2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b < < = 1 } } } else { for x : = 0 ; x < width ; x + = 8 { b : = cdat [ x / 8 ] for x 2 : = 0 ; x 2 < 8 & & x + x 2 < width ; x 2 + + { gray . Set Gray ( x + x 2 , y , color . Gray { ( b > > 7 ) * 0xff } ) b < < = 1 } } } case cb G 2 : if d . use Transparent { ty : = d . transparent [ 1 ] for x : = 0 ; x < width ; x + = 4 { b : = cdat [ x / 4 ] for x 2 : = 0 ; x 2 < 4 & & x + x 2 < width ; x 2 + + { ycol : = ( b > > 6 ) * 0x 5 5 acol : = uint 8 ( 0xff ) if ycol = = ty { acol = 0x 0 0 } nrgba . Set NRGBA ( x + x 2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b < < = 2 } } } else { for x : = 0 ; x < width ; x + = 4 { b : = cdat [ x / 4 ] for x 2 : = 0 ; x 2 < 4 & & x + x 2 < width ; x 2 + + { gray . Set Gray ( x + x 2 , y , color . Gray { ( b > > 6 ) * 0x 5 5 } ) b < < = 2 } } } case cb G 4 : if d . use Transparent { ty : = d . transparent [ 1 ] for x : = 0 ; x < width ; x + = 2 { b : = cdat [ x / 2 ] for x 2 : = 0 ; x 2 < 2 & & x + x 2 < width ; x 2 + + { ycol : = ( b > > 4 ) * 0x 1 1 acol : = uint 8 ( 0xff ) if ycol = = ty { acol = 0x 0 0 } nrgba . Set NRGBA ( x + x 2 , y , color . NRGBA { ycol , ycol , ycol , acol } ) b < < = 4 } } } else { for x : = 0 ; x < width ; x + = 2 { b : = cdat [ x / 2 ] for x 2 : = 0 ; x 2 < 2 & & x + x 2 < width ; x 2 + + { gray . Set Gray ( x + x 2 , y , color . Gray { ( b > > 4 ) * 0x 1 1 } ) b < < = 4 } } } case cb G 8 : if d . use Transparent { ty : = d . transparent [ 1 ] for x : = 0 ; x < width ; x + + { ycol : = cdat [ x ] acol : = uint 8 ( 0xff ) if ycol = = ty { acol = 0x 0 0 } nrgba . Set NRGBA ( x , y , color . NRGBA { ycol , ycol , ycol , acol } ) } } else { copy ( gray . Pix [ pix Offset : ] , cdat ) pix Offset + = gray . Stride } case cb GA 8 : for x : = 0 ; x < width ; x + + { ycol : = cdat [ 2 * x + 0 ] nrgba . Set NRGBA ( x , y , color . NRGBA { ycol , ycol , ycol , cdat [ 2 * x + 1 ] } ) } case cb TC 8 : if d . use Transparent { pix , i , j : = nrgba . Pix , pix Offset , 0 tr , tg , tb : = d . transparent [ 1 ] , d . transparent [ 3 ] , d . transparent [ 5 ] for x : = 0 ; x < width ; x + + { r : = cdat [ j + 0 ] g : = cdat [ j + 1 ] b : = cdat [ j + 2 ] a : = uint 8 ( 0xff ) if r = = tr & & g = = tg & & b = = tb { a = 0x 0 0 } pix [ i + 0 ] = r pix [ i + 1 ] = g pix [ i + 2 ] = b pix [ i + 3 ] = a i + = 4 j + = 3 } pix Offset + = nrgba . Stride } else { pix , i , j : = rgba . Pix , pix Offset , 0 for x : = 0 ; x < width ; x + + { pix [ i + 0 ] = cdat [ j + 0 ] pix [ i + 1 ] = cdat [ j + 1 ] pix [ i + 2 ] = cdat [ j + 2 ] pix [ i + 3 ] = 0xff i + = 4 j + = 3 } pix Offset + = rgba . Stride } case cb P 1 : for x : = 0 ; x < width ; x + = 8 { b : = cdat [ x / 8 ] for x 2 : = 0 ; x 2 < 8 & & x + x 2 < width ; x 2 + + { idx : = b > > 7 if len ( paletted . Palette ) < = int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . Set Color Index ( x + x 2 , y , idx ) b < < = 1 } } case cb P 2 : for x : = 0 ; x < width ; x + = 4 { b : = cdat [ x / 4 ] for x 2 : = 0 ; x 2 < 4 & & x + x 2 < width ; x 2 + + { idx : = b > > 6 if len ( paletted . Palette ) < = int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . Set Color Index ( x + x 2 , y , idx ) b < < = 2 } } case cb P 4 : for x : = 0 ; x < width ; x + = 2 { b : = cdat [ x / 2 ] for x 2 : = 0 ; x 2 < 2 & & x + x 2 < width ; x 2 + + { idx : = b > > 4 if len ( paletted . Palette ) < = int ( idx ) { paletted . Palette = paletted . Palette [ : int ( idx ) + 1 ] } paletted . Set Color Index ( x + x 2 , y , idx ) b < < = 4 } } case cb P 8 : if len ( paletted . Palette ) ! = 2 5 5 { for x : = 0 ; x < width ; x + + { if len ( paletted . Palette ) < = int ( cdat [ x ] ) { paletted . Palette = paletted . Palette [ : int ( cdat [ x ] ) + 1 ] } } } copy ( paletted . Pix [ pix Offset : ] , cdat ) pix Offset + = paletted . Stride case cb TCA 8 : copy ( nrgba . Pix [ pix Offset : ] , cdat ) pix Offset + = nrgba . Stride case cb G 1 6 : if d . use Transparent { ty : = uint 1 6 ( d . transparent [ 0 ] ) < < 8 | uint 1 6 ( d . transparent [ 1 ] ) for x : = 0 ; x < width ; x + + { ycol : = uint 1 6 ( cdat [ 2 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 2 * x + 1 ] ) acol : = uint 1 6 ( 0xffff ) if ycol = = ty { acol = 0x 0 0 0 0 } nrgba 6 4 . Set NRGBA 6 4 ( x , y , color . NRGBA 6 4 { ycol , ycol , ycol , acol } ) } } else { for x : = 0 ; x < width ; x + + { ycol : = uint 1 6 ( cdat [ 2 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 2 * x + 1 ] ) gray 1 6 . Set Gray 1 6 ( x , y , color . Gray 1 6 { ycol } ) } } case cb GA 1 6 : for x : = 0 ; x < width ; x + + { ycol : = uint 1 6 ( cdat [ 4 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 4 * x + 1 ] ) acol : = uint 1 6 ( cdat [ 4 * x + 2 ] ) < < 8 | uint 1 6 ( cdat [ 4 * x + 3 ] ) nrgba 6 4 . Set NRGBA 6 4 ( x , y , color . NRGBA 6 4 { ycol , ycol , ycol , acol } ) } case cb TC 1 6 : if d . use Transparent { tr : = uint 1 6 ( d . transparent [ 0 ] ) < < 8 | uint 1 6 ( d . transparent [ 1 ] ) tg : = uint 1 6 ( d . transparent [ 2 ] ) < < 8 | uint 1 6 ( d . transparent [ 3 ] ) tb : = uint 1 6 ( d . transparent [ 4 ] ) < < 8 | uint 1 6 ( d . transparent [ 5 ] ) for x : = 0 ; x < width ; x + + { rcol : = uint 1 6 ( cdat [ 6 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 1 ] ) gcol : = uint 1 6 ( cdat [ 6 * x + 2 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 3 ] ) bcol : = uint 1 6 ( cdat [ 6 * x + 4 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 5 ] ) acol : = uint 1 6 ( 0xffff ) if rcol = = tr & & gcol = = tg & & bcol = = tb { acol = 0x 0 0 0 0 } nrgba 6 4 . Set NRGBA 6 4 ( x , y , color . NRGBA 6 4 { rcol , gcol , bcol , acol } ) } } else { for x : = 0 ; x < width ; x + + { rcol : = uint 1 6 ( cdat [ 6 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 1 ] ) gcol : = uint 1 6 ( cdat [ 6 * x + 2 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 3 ] ) bcol : = uint 1 6 ( cdat [ 6 * x + 4 ] ) < < 8 | uint 1 6 ( cdat [ 6 * x + 5 ] ) rgba 6 4 . Set RGBA 6 4 ( x , y , color . RGBA 6 4 { rcol , gcol , bcol , 0xffff } ) } } case cb TCA 1 6 : for x : = 0 ; x < width ; x + + { rcol : = uint 1 6 ( cdat [ 8 * x + 0 ] ) < < 8 | uint 1 6 ( cdat [ 8 * x + 1 ] ) gcol : = uint 1 6 ( cdat [ 8 * x + 2 ] ) < < 8 | uint 1 6 ( cdat [ 8 * x + 3 ] ) bcol : = uint 1 6 ( cdat [ 8 * x + 4 ] ) < < 8 | uint 1 6 ( cdat [ 8 * x + 5 ] ) acol : = uint 1 6 ( cdat [ 8 * x + 6 ] ) < < 8 | uint 1 6 ( cdat [ 8 * x + 7 ] ) nrgba 6 4 . Set NRGBA 6 4 ( x , y , color . NRGBA 6 4 { rcol , gcol , bcol , acol } ) } } } return img , nil } 
func ( d * decoder ) merge Pass Into ( dst image . Image , src image . Image , pass int ) { p : = interlacing [ pass ] var ( src Pix [ ] uint 8 dst Pix [ ] uint 8 stride int rect image . Rectangle bytes Per Pixel int ) switch target : = dst . ( type ) { case * image . Alpha : src Pix = src . ( * image . Alpha ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 1 case * image . Alpha 1 6 : src Pix = src . ( * image . Alpha 1 6 ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 2 case * image . Gray : src Pix = src . ( * image . Gray ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 1 case * image . Gray 1 6 : src Pix = src . ( * image . Gray 1 6 ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 2 case * image . NRGBA : src Pix = src . ( * image . NRGBA ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 4 case * image . NRGBA 6 4 : src Pix = src . ( * image . NRGBA 6 4 ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 8 case * image . Paletted : src Pix = src . ( * image . Paletted ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 1 case * image . RGBA : src Pix = src . ( * image . RGBA ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 4 case * image . RGBA 6 4 : src Pix = src . ( * image . RGBA 6 4 ) . Pix dst Pix , stride , rect = target . Pix , target . Stride , target . Rect bytes Per Pixel = 8 } s , bounds : = 0 , src . Bounds ( ) for y : = bounds . Min . Y ; y < bounds . Max . Y ; y + + { d Base : = ( y * p . y Factor + p . y Offset - rect . Min . Y ) * stride + ( p . x Offset - rect . Min . X ) * bytes Per Pixel for x : = bounds . Min . X ; x < bounds . Max . X ; x + + { d : = d Base + x * p . x Factor * bytes Per Pixel copy ( dst Pix [ d : ] , src Pix [ s : s + bytes Per Pixel ] ) s + = bytes Per Pixel } } } 
func Decode ( r io . Reader ) ( image . Image , error ) { d : = & decoder { r : r , crc : crc 3 2 . New IEEE ( ) , } if err : = d . check Header ( ) ; err ! = nil { if err = = io . EOF { err = io . Err Unexpected EOF } return nil , err } for d . stage ! = ds Seen IEND { if err : = d . parse Chunk ( ) ; err ! = nil { if err = = io . EOF { err = io . Err Unexpected EOF } return nil , err } } return d . img , nil } 
func Decode Config ( r io . Reader ) ( image . Config , error ) { d : = & decoder { r : r , crc : crc 3 2 . New IEEE ( ) , } if err : = d . check Header ( ) ; err ! = nil { if err = = io . EOF { err = io . Err Unexpected EOF } return image . Config { } , err } for { if err : = d . parse Chunk ( ) ; err ! = nil { if err = = io . EOF { err = io . Err Unexpected EOF } return image . Config { } , err } paletted : = cb Paletted ( d . cb ) if d . stage = = ds Seen IHDR & & ! paletted { break } if d . stage = = ds Seen PLTE & & paletted { break } } var cm color . Model switch d . cb { case cb G 1 , cb G 2 , cb G 4 , cb G 8 : cm = color . Gray Model case cb GA 8 : cm = color . NRGBAModel case cb TC 8 : cm = color . RGBAModel case cb P 1 , cb P 2 , cb P 4 , cb P 8 : cm = d . palette case cb TCA 8 : cm = color . NRGBAModel case cb G 1 6 : cm = color . Gray 1 6Model case cb GA 1 6 : cm = color . NRGBA 6 4Model case cb TC 1 6 : cm = color . RGBA 6 4Model case cb TCA 1 6 : cm = color . NRGBA 6 4Model } return image . Config { Color Model : cm , Width : d . width , Height : d . height , } , nil } 
func ( c * Color M ) Set Element ( i , j int , element float 3 2 ) * Color M { new C : = & Color M { body : make ( [ ] float 3 2 , 1 6 ) , translate : make ( [ ] float 3 2 , 4 ) , } copy ( new C . body , color MIdentity Body ) copy ( new C . translate , color MIdentity Translate ) if c . is Inited ( ) { if c . body ! = nil { copy ( new C . body , c . body ) } if c . translate ! = nil { copy ( new C . translate , c . translate ) } } if j < ( Color MDim - 1 ) { new C . body [ i + j * ( Color MDim - 1 ) ] = element } else { new C . translate [ i ] = element } return new C } 
func ( c * Color M ) Concat ( other * Color M ) * Color M { if ! c . is Inited ( ) { return other } if ! other . is Inited ( ) { return c } lhsb : = color MIdentity Body lhst : = color MIdentity Translate rhsb : = color MIdentity Body rhst : = color MIdentity Translate if other . is Inited ( ) { if other . body ! = nil { lhsb = other . body } if other . translate ! = nil { lhst = other . translate } } if c . is Inited ( ) { if c . body ! = nil { rhsb = c . body } if c . translate ! = nil { rhst = c . translate } } return & Color M { } 
func ( c * Color M ) Add ( other * Color M ) * Color M { lhsb : = color MIdentity Body lhst : = color MIdentity Translate rhsb : = color MIdentity Body rhst : = color MIdentity Translate if other . is Inited ( ) { if other . body ! = nil { lhsb = other . body } if other . translate ! = nil { lhst = other . translate } } if c . is Inited ( ) { if c . body ! = nil { rhsb = c . body } if c . translate ! = nil { rhst = c . translate } } new C : = & Color M { body : make ( [ ] float 3 2 , 1 6 ) , translate : make ( [ ] float 3 2 , 4 ) , } for i : = range lhsb { new C . body [ i ] = lhsb [ i ] + rhsb [ i ] } for i : = range lhst { new C . translate [ i ] = lhst [ i ] + rhst [ i ] } return new C } 
func ( c * Color M ) Scale ( r , g , b , a float 3 2 ) * Color M { if ! c . is Inited ( ) { return & Color M { body : [ ] float 3 2 { r , 0 , 0 , 0 , 0 , g , 0 , 0 , 0 , 0 , b , 0 , 0 , 0 , 0 , a , } , } } eb : = make ( [ ] float 3 2 , len ( color MIdentity Body ) ) if c . body ! = nil { copy ( eb , c . body ) for i : = 0 ; i < Color MDim - 1 ; i + + { eb [ i * ( Color MDim - 1 ) ] * = r eb [ i * ( Color MDim - 1 ) + 1 ] * = g eb [ i * ( Color MDim - 1 ) + 2 ] * = b eb [ i * ( Color MDim - 1 ) + 3 ] * = a } } else { eb [ 0 ] = r eb [ 5 ] = g eb [ 1 0 ] = b eb [ 1 5 ] = a } et : = make ( [ ] float 3 2 , len ( color MIdentity Translate ) ) if c . translate ! = nil { et [ 0 ] = c . translate [ 0 ] * r et [ 1 ] = c . translate [ 1 ] * g et [ 2 ] = c . translate [ 2 ] * b et [ 3 ] = c . translate [ 3 ] * a } return & Color M { body : eb , translate : et , } } 
func ( c * Color M ) Translate ( r , g , b , a float 3 2 ) * Color M { if ! c . is Inited ( ) { return & Color M { translate : [ ] float 3 2 { r , g , b , a } , } } es : = make ( [ ] float 3 2 , len ( color MIdentity Translate ) ) if c . translate ! = nil { copy ( es , c . translate ) } es [ 0 ] + = r es [ 1 ] + = g es [ 2 ] + = b es [ 3 ] + = a return & Color M { body : c . body , translate : es , } } 
func ( c * Color M ) Change HSV ( hue Theta float 6 4 , saturation Scale float 3 2 , value Scale float 3 2 ) * Color M { sin , cos : = math . Sincos ( hue Theta ) s 3 2 , c 3 2 : = float 3 2 ( sin ) , float 3 2 ( cos ) c = c . Concat ( rgb To YCb Cr ) c = c . Concat ( & Color M { body : [ ] float 3 2 { 1 , 0 , 0 , 0 , 0 , c 3 2 , s 3 2 , 0 , 0 , - s 3 2 , c 3 2 , 0 , 0 , 0 , 0 , 1 , } , } ) s : = saturation Scale v : = value Scale c = c . Scale ( v , s * v , s * v , 1 ) c = c . Concat ( y Cb Cr To Rgb ) return c } 
func ( c * gamepad Config ) Scan ( b virtual Gamepad Button ) bool { if ! c . gamepad IDInitialized { panic ( " " ) } c . initialize If Needed ( ) delete ( c . buttons , b ) delete ( c . axes , b ) ebn : = ebiten . Gamepad Button ( ebiten . Gamepad Button Num ( c . gamepad ID ) ) for eb : = ebiten . Gamepad Button ( 0 ) ; eb < ebn ; eb + + { if _ , ok : = c . assigned Buttons [ eb ] ; ok { continue } if inpututil . Is Gamepad Button Just Pressed ( c . gamepad ID , eb ) { c . buttons [ b ] = eb c . assigned Buttons [ eb ] = struct { } { } return true } } na : = ebiten . Gamepad Axis Num ( c . gamepad ID ) for a : = 0 ; a < na ; a + + { v : = ebiten . Gamepad Axis ( c . gamepad ID , a ) const delta = 0 . 2 5 c . assigned Axes [ axis { a , true } ] = struct { } { } return true } } if - 1 . 0 < = v & & v < = - axis Threshold & & ( v < c . default Axes Values [ a ] - delta | | c . default Axes Values [ a ] + delta < v ) { if _ , ok : = c . assigned Axes [ axis { a , false } ] ; ! ok { c . axes [ b ] = axis { a , false } c . assigned Axes [ axis { a , false } ] = struct { } { } return true } } } return false } 
func ( c * gamepad Config ) Is Button Pressed ( b virtual Gamepad Button ) bool { if ! c . gamepad IDInitialized { panic ( " " ) } c . initialize If Needed ( ) bb , ok : = c . buttons [ b ] if ok { return ebiten . Is Gamepad Button Pressed ( c . gamepad ID , bb ) } a , ok : = c . axes [ b ] if ok { v : = ebiten . Gamepad Axis ( c . gamepad ID , a . id ) if a . positive { return axis Threshold < = v & & v < = 1 . 0 } else { return - 1 . 0 < = v & & v < = - axis Threshold } } return false } 
func ( c * gamepad Config ) Button Name ( b virtual Gamepad Button ) string { if ! c . gamepad IDInitialized { panic ( " " ) } c . initialize If Needed ( ) bb , ok : = c . buttons [ b ] if ok { return fmt . Sprintf ( " " , bb ) } a , ok : = c . axes [ b ] if ok { if a . positive { return fmt . Sprintf ( " " , a . id ) } else { return fmt . Sprintf ( " " , a . id ) } } return " " } 
func paint ( canvas * ebiten . Image , x , y int ) { op : = & ebiten . Draw Image Options { } op . Geo M . Translate ( float 6 4 ( x ) , float 6 4 ( y ) ) tps : = ebiten . Max TPS ( ) theta : = 2 . 0 * math . Pi * float 6 4 ( count % tps ) / float 6 4 ( tps ) op . Color M . Rotate Hue ( theta ) canvas . Draw Image ( brush Image , op ) } 
func Append Hook On Before Update ( f func ( ) error ) { m . Lock ( ) on Before Update Hooks = append ( on Before Update Hooks , f ) m . Unlock ( ) } 
func ( k Key ) String ( ) string { switch k { case Key 0 : return " " case Key 1 : return " " case Key 2 : return " " case Key 3 : return " " case Key 4 : return " " case Key 5 : return " " case Key 6 : return " " case Key 7 : return " " case Key 8 : return " " case Key 9 : return " " case Key A : return " " case Key B : return " " case Key C : return " " case Key D : return " " case Key E : return " " case Key F : return " " case Key G : return " " case Key H : return " " case Key I : return " " case Key J : return " " case Key K : return " " case Key L : return " " case Key M : return " " case Key N : return " " case Key O : return " " case Key P : return " " case Key Q : return " " case Key R : return " " case Key S : return " " case Key T : return " " case Key U : return " " case Key V : return " " case Key W : return " " case Key X : return " " case Key Y : return " " case Key Z : return " " case Key Alt : return " " case Key Apostrophe : return " " case Key Backslash : return " " case Key Backspace : return " " case Key Caps Lock : return " " case Key Comma : return " " case Key Control : return " " case Key Delete : return " " case Key Down : return " " case Key End : return " " case Key Enter : return " " case Key Equal : return " " case Key Escape : return " " case Key F 1 : return " " case Key F 2 : return " " case Key F 3 : return " " case Key F 4 : return " " case Key F 5 : return " " case Key F 6 : return " " case Key F 7 : return " " case Key F 8 : return " " case Key F 9 : return " " case Key F 1 0 : return " " case Key F 1 1 : return " " case Key F 1 2 : return " " case Key Grave Accent : return " " case Key Home : return " " case Key Insert : return " " case Key KP 0 : return " " case Key KP 1 : return " " case Key KP 2 : return " " case Key KP 3 : return " " case Key KP 4 : return " " case Key KP 5 : return " " case Key KP 6 : return " " case Key KP 7 : return " " case Key KP 8 : return " " case Key KP 9 : return " " case Key KPAdd : return " " case Key KPDecimal : return " " case Key KPDivide : return " " case Key KPEnter : return " " case Key KPEqual : return " " case Key KPMultiply : return " " case Key KPSubtract : return " " case Key Left : return " " case Key Left Bracket : return " " case Key Menu : return " " case Key Minus : return " " case Key Num Lock : return " " case Key Page Down : return " " case Key Page Up : return " " case Key Pause : return " " case Key Period : return " " case Key Print Screen : return " " case Key Right : return " " case Key Right Bracket : return " " case Key Scroll Lock : return " " case Key Semicolon : return " " case Key Shift : return " " case Key Slash : return " " case Key Space : return " " case Key Tab : return " " case Key Up : return " " } return " " } 
func Debug Print ( image * ebiten . Image , str string ) error { Debug Print At ( image , str , 0 , 0 ) return nil } 
func Debug Print At ( image * ebiten . Image , str string , x , y int ) { draw Debug Text ( image , str , x + 1 , y + 1 , true ) draw Debug Text ( image , str , x , y , false ) } 
func ( i * Input ) Gamepad IDButton Pressed ( ) int { for _ , id : = range ebiten . Gamepad IDs ( ) { for b : = ebiten . Gamepad Button ( 0 ) ; b < = ebiten . Gamepad Button Max ; b + + { if ebiten . Is Gamepad Button Pressed ( id , b ) { return id } } } return - 1 } 
func ( s * Stream ) Read ( p [ ] byte ) ( int , error ) { return s . decoded . Read ( p ) } 
func ( s * Stream ) Seek ( offset int 6 4 , whence int ) ( int 6 4 , error ) { return s . decoded . Seek ( offset , whence ) } 
func ( s * Stream ) Close ( ) error { runtime . Set Finalizer ( s , nil ) if err : = s . decoded . Close ( ) ; err ! = nil { return err } return nil } 
func decode ( in audio . Read Seek Closer ) ( * decoded , int , int , error ) { r , err : = new Decoder ( in ) if err ! = nil { return nil , 0 , 0 , err } d : = & decoded { runtime . Set Finalizer ( d , ( * decoded ) . Close ) if _ , err : = d . Read ( make ( [ ] byte , 6 5 5 3 6 ) ) ; err ! = nil & & err ! = io . EOF { return nil , 0 , 0 , err } if _ , err : = d . Seek ( 0 , io . Seek Start ) ; err ! = nil { return nil , 0 , 0 , err } return d , r . Channels ( ) , r . Sample Rate ( ) , nil } 
func Decode ( context * audio . Context , src audio . Read Seek Closer ) ( * Stream , error ) { decoded , channel Num , sample Rate , err : = decode ( src ) if err ! = nil { return nil , err } if channel Num ! = 1 & & channel Num ! = 2 { return nil , fmt . Errorf ( " " , channel Num ) } var s audio . Read Seek Closer = decoded size : = decoded . Length ( ) if channel Num = = 1 { s = convert . New Stereo 1 6 ( s , true , false ) size * = 2 } if sample Rate ! = context . Sample Rate ( ) { r : = convert . New Resampling ( s , size , sample Rate , context . Sample Rate ( ) ) s = r size = r . Length ( ) } stream : = & Stream { decoded : s , size : size } runtime . Set Finalizer ( stream , ( * Stream ) . Close ) return stream , nil } 
func Start ( f func ( * ebiten . Image ) error , width , height int , scale float 6 4 , title string ) error { mobile Mutex . Lock ( ) defer mobile Mutex . Unlock ( ) start ( f , width , height , scale , title ) return nil } 
func Update Touches On Android ( action int , id int , x , y int ) { mobile Mutex . Lock ( ) defer mobile Mutex . Unlock ( ) update Touches On Android ( action , id , x , y ) } 
func Update Touches On IOS ( phase int , ptr int 6 4 , x , y int ) { mobile Mutex . Lock ( ) defer mobile Mutex . Unlock ( ) update Touches On IOSImpl ( phase , ptr , x , y ) } 
func ( f * Field ) Is Blocked ( x , y int ) bool { if x < 0 | | field Block Num X < = x { return true } if y < 0 { return false } if field Block Num Y < = y { return true } return f . blocks [ x ] [ y ] ! = Block Type None } 
func ( f * Field ) Move Piece To Left ( piece * Piece , x , y int , angle Angle ) int { if piece . collides ( f , x - 1 , y , angle ) { return x } return x - 1 } 
func ( f * Field ) Piece Droppable ( piece * Piece , x , y int , angle Angle ) bool { return ! piece . collides ( f , x , y + 1 , angle ) } 
func ( f * Field ) Rotate Piece Right ( piece * Piece , x , y int , angle Angle ) Angle { if piece . collides ( f , x , y , angle . Rotate Right ( ) ) { return angle } return angle . Rotate Right ( ) } 
func ( f * Field ) Rotate Piece Left ( piece * Piece , x , y int , angle Angle ) Angle { if piece . collides ( f , x , y , angle . Rotate Left ( ) ) { return angle } return angle . Rotate Left ( ) } 
func ( f * Field ) Absorb Piece ( piece * Piece , x , y int , angle Angle ) { piece . Absorb Into ( f , x , y , angle ) if f . flushable ( ) { f . flush Count = max Flush Count } } 
func ( f * Field ) flushable ( ) bool { for j : = field Block Num Y - 1 ; 0 < = j ; j - - { if f . flushable Line ( j ) { return true } } return false } 
func ( f * Field ) flushable Line ( j int ) bool { for i : = 0 ; i < field Block Num X ; i + + { if f . blocks [ i ] [ j ] = = Block Type None { return false } } return true } 
func ( f * Field ) flush Line ( j int ) bool { for i : = 0 ; i < field Block Num X ; i + + { if f . blocks [ i ] [ j ] = = Block Type None { return false } } for j 2 : = j ; 1 < = j 2 ; j 2 - - { for i : = 0 ; i < field Block Num X ; i + + { f . blocks [ i ] [ j 2 ] = f . blocks [ i ] [ j 2 - 1 ] } } for i : = 0 ; i < field Block Num X ; i + + { f . blocks [ i ] [ 0 ] = Block Type None } return true } 
func intersection ( l 1 , l 2 line ) ( float 6 4 , float 6 4 , bool ) { t Num : = ( l 1 . X 1 - l 2 . X 1 ) * ( l 2 . Y 1 - l 2 . Y 2 ) - ( l 1 . Y 1 - l 2 . Y 1 ) * ( l 2 . X 1 - l 2 . X 2 ) u Num : = - ( ( l 1 . X 1 - l 1 . X 2 ) * ( l 1 . Y 1 - l 2 . Y 1 ) - ( l 1 . Y 1 - l 1 . Y 2 ) * ( l 1 . X 1 - l 2 . X 1 ) ) if denom = = 0 { return 0 , 0 , false } t : = t Num / denom if t > 1 | | t < 0 { return 0 , 0 , false } u : = u Num / denom if u > 1 | | u < 0 { return 0 , 0 , false } x : = l 1 . X 1 + t * ( l 1 . X 2 - l 1 . X 1 ) y : = l 1 . Y 1 + t * ( l 1 . Y 2 - l 1 . Y 1 ) return x , y , true } 
func ray Casting ( cx , cy float 6 4 , objects [ ] object ) [ ] line { const ray Length = 1 0 0 0 var rays [ ] line for _ , obj : = range objects { angle : = l . angle ( ) for _ , offset : = range [ ] float 6 4 { - 0 . 0 0 5 , 0 . 0 0 5 } { points : = [ ] [ 2 ] float 6 4 { } ray : = new Ray ( cx , cy , ray Length , angle + offset ) } } } min I : = - 1 for i , p : = range points { d 2 : = ( cx - p [ 0 ] ) * ( cx - p [ 0 ] ) + ( cy - p [ 1 ] ) * ( cy - p [ 1 ] ) if d 2 < min { min = d 2 min I = i } } rays = append ( rays , line { cx , cy , points [ min I ] [ 0 ] , points [ min I ] [ 1 ] } ) } } } } ) return rays } 
func square ( width , height int ) float 6 4 { if width = = 0 & & height = = 0 { return 0 } if width < = height { return float 6 4 ( width ) / float 6 4 ( height ) } return float 6 4 ( height ) / float 6 4 ( width ) } 
func Record Screen As GIF ( update func ( * ebiten . Image ) error , out io . Writer , frame Num int ) func ( * ebiten . Image ) error { r : = & recorder { inner : update , writer : out , frame Num : frame Num , skips : 1 0 , } return r . update } 
func Ptr ( data interface { } ) unsafe . Pointer { if data = = nil { return unsafe . Pointer ( nil ) } var addr unsafe . Pointer v : = reflect . Value Of ( data ) switch v . Type ( ) . Kind ( ) { case reflect . Ptr : e : = v . Elem ( ) switch e . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 , reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Float 3 2 , reflect . Float 6 4 : addr = unsafe . Pointer ( e . Unsafe Addr ( ) ) default : panic ( fmt . Errorf ( " " , e . Kind ( ) ) ) } case reflect . Uintptr : addr = unsafe . Pointer ( v . Pointer ( ) ) case reflect . Slice : addr = unsafe . Pointer ( v . Index ( 0 ) . Unsafe Addr ( ) ) default : panic ( fmt . Errorf ( " " , v . Type ( ) ) ) } return addr } 
func Str ( str string ) * uint 8 { if ! strings . Has Suffix ( str , " \x 0 0 " ) { panic ( " " + str ) } header : = ( * reflect . String Header ) ( unsafe . Pointer ( & str ) ) return ( * uint 8 ) ( unsafe . Pointer ( header . Data ) ) } 
func Go Str ( cstr * uint 8 ) string { return C . Go String ( ( * C . char ) ( unsafe . Pointer ( cstr ) ) ) } 
func Strs ( strs . . . string ) ( cstrs * * uint 8 , free func ( ) ) { if len ( strs ) = = 0 { panic ( " " ) } for i : = range strs { n + = len ( strs [ i ] ) } data : = C . malloc ( C . size _t ( n ) ) css : = make ( [ ] * uint 8 , len ( strs ) ) offset : = 0 for i : = range strs { copy ( data Slice [ offset : offset + len ( strs [ i ] ) ] , strs [ i ] [ : ] ) css [ i ] = ( * uint 8 ) ( unsafe . Pointer ( & data Slice [ offset ] ) ) offset + = len ( strs [ i ] ) } return ( * * uint 8 ) ( & css [ 0 ] ) , func ( ) { C . free ( data ) } } 
func Open File ( path string ) ( Read Seek Closer , error ) { return os . Open ( filepath . From Slash ( path ) ) } 
func Create System Default Device ( ) ( Device , error ) { d : = C . Create System Default Device ( ) if d . Device = = nil { return Device { } , errors . New ( " " ) } return Device { device : d . Device , Headless : d . Headless ! = 0 , Low Power : d . Low Power ! = 0 , Name : C . Go String ( d . Name ) , } , nil } 
func Copy All Devices ( ) [ ] Device { d : = C . Copy All Devices ( ) defer C . free ( unsafe . Pointer ( d . Devices ) ) ds : = make ( [ ] Device , d . Length ) for i : = 0 ; i < len ( ds ) ; i + + { d : = ( * C . struct _Device ) ( unsafe . Pointer ( uintptr ( unsafe . Pointer ( d . Devices ) ) + uintptr ( i ) * C . sizeof _struct _Device ) ) ds [ i ] . device = d . Device ds [ i ] . Headless = d . Headless ! = 0 ds [ i ] . Low Power = d . Low Power ! = 0 ds [ i ] . Name = C . Go String ( d . Name ) } return ds } 
func ( d Device ) Supports Feature Set ( fs Feature Set ) bool { return C . Device _Supports Feature Set ( d . device , C . uint 1 6 _t ( fs ) ) ! = 0 } 
func ( d Device ) Make Library ( source string , opt Compile Options ) ( Library , error ) { l : = C . Go _Device _Make Library ( d . device , source ) if l . Library = = nil { return Library { } , errors . New ( C . Go String ( l . Error ) ) } return Library { l . Library } , nil } 
func ( d Device ) Make Render Pipeline State ( rpd Render Pipeline Descriptor ) ( Render Pipeline State , error ) { blending Enabled : = C . BOOL ( 0 ) if rpd . Color Attachments [ 0 ] . Blending Enabled { blending Enabled = C . BOOL ( 1 ) } c : = & rpd . Color Attachments [ 0 ] descriptor : = C . struct _Render Pipeline Descriptor { Vertex Function : rpd . Vertex Function . function , Fragment Function : rpd . Fragment Function . function , Color Attachment 0Pixel Format : C . uint 1 6 _t ( c . Pixel Format ) , Color Attachment 0Blending Enabled : C . BOOL ( blending Enabled ) , Color Attachment 0Destination Alpha Blend Factor : C . uint 8 _t ( c . Destination Alpha Blend Factor ) , Color Attachment 0Destination RGBBlend Factor : C . uint 8 _t ( c . Destination RGBBlend Factor ) , Color Attachment 0Source Alpha Blend Factor : C . uint 8 _t ( c . Source Alpha Blend Factor ) , Color Attachment 0Source RGBBlend Factor : C . uint 8 _t ( c . Source RGBBlend Factor ) , } rps : = C . Device _Make Render Pipeline State ( d . device , descriptor ) if rps . Render Pipeline State = = nil { return Render Pipeline State { } , errors . New ( C . Go String ( rps . Error ) ) } return Render Pipeline State { rps . Render Pipeline State } , nil } 
func ( d Device ) Make Buffer With Bytes ( bytes unsafe . Pointer , length uintptr , opt Resource Options ) Buffer { return Buffer { C . Device _Make Buffer With Bytes ( d . device , bytes , C . size _t ( length ) , C . uint 1 6 _t ( opt ) ) } } 
func ( d Device ) Make Buffer With Length ( length uintptr , opt Resource Options ) Buffer { return Buffer { C . Device _Make Buffer With Length ( d . device , C . size _t ( length ) , C . uint 1 6 _t ( opt ) ) } } 
func ( d Device ) Make Texture ( td Texture Descriptor ) Texture { descriptor : = C . struct _Texture Descriptor { Pixel Format : C . uint 1 6 _t ( td . Pixel Format ) , Width : C . uint _t ( td . Width ) , Height : C . uint _t ( td . Height ) , Storage Mode : C . uint 8 _t ( td . Storage Mode ) , Usage : C . uint 8 _t ( td . Usage ) , } return Texture { texture : C . Device _Make Texture ( d . device , descriptor ) , Width : td . Width , } 
func ( cb Command Buffer ) Present Drawable ( d Drawable ) { C . Command Buffer _Present Drawable ( cb . command Buffer , d . Drawable ( ) ) } 
func ( cb Command Buffer ) Make Render Command Encoder ( rpd Render Pass Descriptor ) Render Command Encoder { descriptor : = C . struct _Render Pass Descriptor { Color Attachment 0Load Action : C . uint 8 _t ( rpd . Color Attachments [ 0 ] . Load Action ) , Color Attachment 0Store Action : C . uint 8 _t ( rpd . Color Attachments [ 0 ] . Store Action ) , Color Attachment 0Clear Color : C . struct _Clear Color { Red : C . double ( rpd . Color Attachments [ 0 ] . Clear Color . Red ) , Green : C . double ( rpd . Color Attachments [ 0 ] . Clear Color . Green ) , Blue : C . double ( rpd . Color Attachments [ 0 ] . Clear Color . Blue ) , Alpha : C . double ( rpd . Color Attachments [ 0 ] . Clear Color . Alpha ) , } , Color Attachment 0Texture : rpd . Color Attachments [ 0 ] . Texture . texture , } return Render Command Encoder { Command Encoder { C . Command Buffer _Make Render Command Encoder ( cb . command Buffer , descriptor ) } } } 
func ( cb Command Buffer ) Make Blit Command Encoder ( ) Blit Command Encoder { return Blit Command Encoder { Command Encoder { C . Command Buffer _Make Blit Command Encoder ( cb . command Buffer ) } } } 
func ( rce Render Command Encoder ) Set Render Pipeline State ( rps Render Pipeline State ) { C . Render Command Encoder _Set Render Pipeline State ( rce . command Encoder , rps . render Pipeline State ) } 
func ( rce Render Command Encoder ) Set Vertex Buffer ( buf Buffer , offset , index int ) { C . Render Command Encoder _Set Vertex Buffer ( rce . command Encoder , buf . buffer , C . uint _t ( offset ) , C . uint _t ( index ) ) } 
func ( rce Render Command Encoder ) Set Vertex Bytes ( bytes unsafe . Pointer , length uintptr , index int ) { C . Render Command Encoder _Set Vertex Bytes ( rce . command Encoder , bytes , C . size _t ( length ) , C . uint _t ( index ) ) } 
func ( rce Render Command Encoder ) Set Fragment Texture ( texture Texture , index int ) { C . Render Command Encoder _Set Fragment Texture ( rce . command Encoder , texture . texture , C . uint _t ( index ) ) } 
func ( rce Render Command Encoder ) Draw Primitives ( typ Primitive Type , vertex Start , vertex Count int ) { C . Render Command Encoder _Draw Primitives ( rce . command Encoder , C . uint 8 _t ( typ ) , C . uint _t ( vertex Start ) , C . uint _t ( vertex Count ) ) } 
func ( rce Render Command Encoder ) Draw Indexed Primitives ( typ Primitive Type , index Count int , index Type Index Type , index Buffer Buffer , index Buffer Offset int ) { C . Render Command Encoder _Draw Indexed Primitives ( rce . command Encoder , C . uint 8 _t ( typ ) , C . uint _t ( index Count ) , C . uint 8 _t ( index Type ) , index Buffer . buffer , C . uint _t ( index Buffer Offset ) ) } 
func ( bce Blit Command Encoder ) Synchronize ( resource Resource ) { C . Blit Command Encoder _Synchronize ( bce . command Encoder , resource . resource ( ) ) } 
func ( l Library ) Make Function ( name string ) ( Function , error ) { f : = C . Library _Make Function ( l . library , C . CString ( name ) ) if f = = nil { return Function { } , fmt . Errorf ( " " , name ) } return Function { f } , nil } 
func ( t Texture ) Get Bytes ( pixel Bytes * byte , bytes Per Row uintptr , region Region , level int ) { r : = region . c ( ) C . Texture _Get Bytes ( t . texture , unsafe . Pointer ( pixel Bytes ) , C . size _t ( bytes Per Row ) , r , C . uint _t ( level ) ) } 
func ( t Texture ) Replace Region ( region Region , level int , pixel Bytes unsafe . Pointer , bytes Per Row int ) { r : = region . c ( ) C . Texture _Replace Region ( t . texture , r , C . uint _t ( level ) , pixel Bytes , C . uint _t ( bytes Per Row ) ) } 
func Region Make 2D ( x , y , width , height int ) Region { return Region { Origin : Origin { x , y , 0 } , Size : Size { width , height , 1 } , } } 
func ( s * Stream ) Read ( p [ ] byte ) ( int , error ) { return s . inner . Read ( p ) } 
func ( s * Stream ) Close ( ) error { runtime . Set Finalizer ( s , nil ) return s . inner . Close ( ) } 
func ( s * stream ) Read ( p [ ] byte ) ( int , error ) { if s . remaining < = 0 { return 0 , io . EOF } if s . remaining < int 6 4 ( len ( p ) ) { p = p [ 0 : s . remaining ] } n , err : = s . src . Read ( p ) s . remaining - = int 6 4 ( n ) return n , err } 
func ( s * stream ) Seek ( offset int 6 4 , whence int ) ( int 6 4 , error ) { switch whence { case io . Seek Start : offset = offset + s . header Size case io . Seek Current : case io . Seek End : offset = s . header Size + s . data Size + offset whence = io . Seek Start } n , err : = s . src . Seek ( offset , whence ) if err ! = nil { return 0 , err } if n - s . header Size < 0 { return 0 , fmt . Errorf ( " " ) } s . remaining = s . data Size - ( n - s . header Size ) return s . data Size , nil } return n - s . header Size , nil } 
func ( s * stream ) Close ( ) error { runtime . Set Finalizer ( s , nil ) return s . src . Close ( ) } 
func New World ( width , height int , max Init Live Cells int ) * World { w : = & World { area : make ( [ ] bool , width * height ) , width : width , height : height , } w . init ( max Init Live Cells ) return w } 
func ( w * World ) init ( max Live Cells int ) { for i : = 0 ; i < max Live Cells ; i + + { x : = rand . Intn ( w . width ) y : = rand . Intn ( w . height ) w . area [ y * w . width + x ] = true } } 
func ( w * World ) Update ( ) { width : = w . width height : = w . height next : = make ( [ ] bool , width * height ) for y : = 0 ; y < height ; y + + { for x : = 0 ; x < width ; x + + { pop : = neighbour Count ( w . area , width , height , x , y ) switch { case pop < 2 : case ( pop = = 2 | | pop = = 3 ) & & w . area [ y * width + x ] : case pop > 3 : case pop = = 3 : } } } w . area = next } 
func ( w * World ) Draw ( pix [ ] byte ) { for i , v : = range w . area { if v { pix [ 4 * i ] = 0xff pix [ 4 * i + 1 ] = 0xff pix [ 4 * i + 2 ] = 0xff pix [ 4 * i + 3 ] = 0xff } else { pix [ 4 * i ] = 0 pix [ 4 * i + 1 ] = 0 pix [ 4 * i + 2 ] = 0 pix [ 4 * i + 3 ] = 0 } } } 
func neighbour Count ( a [ ] bool , width , height , x , y int ) int { c : = 0 for j : = - 1 ; j < = 1 ; j + + { for i : = - 1 ; i < = 1 ; i + + { if i = = 0 & & j = = 0 { continue } x 2 : = x + i y 2 : = y + j if x 2 < 0 | | y 2 < 0 | | width < = x 2 | | height < = y 2 { continue } if a [ y 2 * width + x 2 ] { c + + } } } return c } 
func ( ml Metal Layer ) Pixel Format ( ) mtl . Pixel Format { return mtl . Pixel Format ( C . Metal Layer _Pixel Format ( ml . metal Layer ) ) } 
func ( ml Metal Layer ) Set Device ( device mtl . Device ) { C . Metal Layer _Set Device ( ml . metal Layer , device . Device ( ) ) } 
func ( ml Metal Layer ) Set Pixel Format ( pf mtl . Pixel Format ) { e : = C . Metal Layer _Set Pixel Format ( ml . metal Layer , C . uint 1 6 _t ( pf ) ) if e ! = nil { panic ( errors . New ( C . Go String ( e ) ) ) } } 
func ( ml Metal Layer ) Set Maximum Drawable Count ( count int ) { e : = C . Metal Layer _Set Maximum Drawable Count ( ml . metal Layer , C . uint _t ( count ) ) if e ! = nil { panic ( errors . New ( C . Go String ( e ) ) ) } } 
func ( ml Metal Layer ) Set Display Sync Enabled ( enabled bool ) { switch enabled { case true : C . Metal Layer _Set Display Sync Enabled ( ml . metal Layer , 1 ) case false : C . Metal Layer _Set Display Sync Enabled ( ml . metal Layer , 0 ) } } 
func ( ml Metal Layer ) Set Drawable Size ( width , height int ) { C . Metal Layer _Set Drawable Size ( ml . metal Layer , C . double ( width ) , C . double ( height ) ) } 
func ( ml Metal Layer ) Next Drawable ( ) ( Metal Drawable , error ) { md : = C . Metal Layer _Next Drawable ( ml . metal Layer ) if md = = nil { return Metal Drawable { } , errors . New ( " " ) } return Metal Drawable { md } , nil } 
func ( md Metal Drawable ) Texture ( ) mtl . Texture { return mtl . New Texture ( C . Metal Drawable _Texture ( md . metal Drawable ) ) } 
func Draw Line ( dst * ebiten . Image , x 1 , y 1 , x 2 , y 2 float 6 4 , clr color . Color ) { ew , eh : = empty Image . Size ( ) length : = math . Hypot ( x 2 - x 1 , y 2 - y 1 ) op : = & ebiten . Draw Image Options { } op . Geo M . Scale ( length / float 6 4 ( ew ) , 1 / float 6 4 ( eh ) ) op . Geo M . Rotate ( math . Atan 2 ( y 2 - y 1 , x 2 - x 1 ) ) op . Geo M . Translate ( x 1 , y 1 ) op . Color M . Scale ( color Scale ( clr ) ) } 
func Draw Rect ( dst * ebiten . Image , x , y , width , height float 6 4 , clr color . Color ) { ew , eh : = empty Image . Size ( ) op : = & ebiten . Draw Image Options { } op . Geo M . Scale ( width / float 6 4 ( ew ) , height / float 6 4 ( eh ) ) op . Geo M . Translate ( x , y ) op . Color M . Scale ( color Scale ( clr ) ) } 
func New Game ( ) ( * Game , error ) { g : = & Game { input : New Input ( ) , } var err error g . board , err = New Board ( board Size ) if err ! = nil { return nil , err } return g , nil } 
func ( g * Game ) Update ( ) error { g . input . Update ( ) if err : = g . board . Update ( g . input ) ; err ! = nil { return err } return nil } 
func ( g * Game ) Draw ( screen * ebiten . Image ) { if g . board Image = = nil { w , h : = g . board . Size ( ) g . board Image , _ = ebiten . New Image ( w , h , ebiten . Filter Default ) } screen . Fill ( background Color ) g . board . Draw ( g . board Image ) op : = & ebiten . Draw Image Options { } sw , sh : = screen . Size ( ) bw , bh : = g . board Image . Size ( ) x : = ( sw - bw ) / 2 y : = ( sh - bh ) / 2 op . Geo M . Translate ( float 6 4 ( x ) , float 6 4 ( y ) ) screen . Draw Image ( g . board Image , op ) } 
func Is Key Just Released ( key ebiten . Key ) bool { the Input State . m . RLock ( ) r : = the Input State . key Durations [ key ] = = 0 & & the Input State . prev Key Durations [ key ] > 0 the Input State . m . RUnlock ( ) return r } 
func Key Press Duration ( key ebiten . Key ) int { the Input State . m . RLock ( ) s : = the Input State . key Durations [ key ] the Input State . m . RUnlock ( ) return s } 
func Is Mouse Button Just Released ( button ebiten . Mouse Button ) bool { the Input State . m . RLock ( ) r : = the Input State . mouse Button Durations [ button ] = = 0 & & the Input State . prev Mouse Button Durations [ button ] > 0 the Input State . m . RUnlock ( ) return r } 
func Mouse Button Press Duration ( button ebiten . Mouse Button ) int { the Input State . m . RLock ( ) s : = the Input State . mouse Button Durations [ button ] the Input State . m . RUnlock ( ) return s } 
func Just Connected Gamepad IDs ( ) [ ] int { var ids [ ] int the Input State . m . RLock ( ) for id : = range the Input State . gamepad IDs { if _ , ok : = the Input State . prev Gamepad IDs [ id ] ; ! ok { ids = append ( ids , id ) } } the Input State . m . RUnlock ( ) sort . Ints ( ids ) return ids } 
func Is Gamepad Just Disconnected ( id int ) bool { the Input State . m . RLock ( ) _ , prev : = the Input State . prev Gamepad IDs [ id ] _ , current : = the Input State . gamepad IDs [ id ] the Input State . m . RUnlock ( ) return prev & & ! current } 
func Is Gamepad Button Just Pressed ( id int , button ebiten . Gamepad Button ) bool { return Gamepad Button Press Duration ( id , button ) = = 1 } 
func Is Gamepad Button Just Released ( id int , button ebiten . Gamepad Button ) bool { the Input State . m . RLock ( ) prev : = 0 if _ , ok : = the Input State . prev Gamepad Button Durations [ id ] ; ok { prev = the Input State . prev Gamepad Button Durations [ id ] [ button ] } current : = 0 if _ , ok : = the Input State . gamepad Button Durations [ id ] ; ok { current = the Input State . gamepad Button Durations [ id ] [ button ] } the Input State . m . RUnlock ( ) return current = = 0 & & prev > 0 } 
func Gamepad Button Press Duration ( id int , button ebiten . Gamepad Button ) int { the Input State . m . RLock ( ) s : = 0 if _ , ok : = the Input State . gamepad Button Durations [ id ] ; ok { s = the Input State . gamepad Button Durations [ id ] [ button ] } the Input State . m . RUnlock ( ) return s } 
func Just Pressed Touch IDs ( ) [ ] int { var ids [ ] int the Input State . m . RLock ( ) for id , s : = range the Input State . touch Durations { if s = = 1 { ids = append ( ids , id ) } } the Input State . m . RUnlock ( ) sort . Ints ( ids ) return ids } 
func Is Touch Just Released ( id int ) bool { the Input State . m . RLock ( ) r : = the Input State . touch Durations [ id ] = = 0 & & the Input State . prev Touch Durations [ id ] > 0 the Input State . m . RUnlock ( ) return r } 
func Touch Press Duration ( id int ) int { the Input State . m . RLock ( ) s : = the Input State . touch Durations [ id ] the Input State . m . RUnlock ( ) return s } 
func ( i * Image ) viewport Size ( ) ( int , int ) { if i . screen { return i . width , i . height } return graphics . Internal Image Size ( i . width ) , graphics . Internal Image Size ( i . height ) } 
func Loop ( ch < - chan error ) error { atomic . Store Int 3 2 ( & started , 1 ) for { select { case f : = < - funcs : f ( ) case err : = < - ch : } } } 
func Run ( f func ( ) error ) error { if atomic . Load Int 3 2 ( & started ) = = 0 { ch : = make ( chan struct { } ) var err error funcs < - func ( ) { err = f ( ) close ( ch ) } < - ch return err } 
func Update ( tps int ) int { m . Lock ( ) defer m . Unlock ( ) n : = now ( ) c : = 0 if tps = = Uncapped TPS { c = 1 } else if tps > 0 { c = calc Count From TPS ( int 6 4 ( tps ) , n ) } update FPSAnd TPS ( n , c ) return c } 
func ( v View ) Set Layer ( l ca . Layer ) { C . View _Set Layer ( v . view , l . Layer ( ) ) } 
func ( v View ) Set Wants Layer ( wants Layer bool ) { if wants Layer { C . View _Set Wants Layer ( v . view , 1 ) } else { C . View _Set Wants Layer ( v . view , 0 ) } } 
func Internal Image Size ( x int ) int { if x < = 0 { panic ( " " ) } if x < min Internal Image Size { return min Internal Image Size } r : = 1 for r < x { r < < = 1 } return r } 
func square ( out [ ] int 1 6 , volume float 6 4 , freq float 6 4 , sequence float 6 4 ) { if freq = = 0 { for i : = 0 ; i < len ( out ) ; i + + { out [ i ] = 0 } return } length : = int ( float 6 4 ( sample Rate ) / freq ) if length = = 0 { panic ( " " ) } for i : = 0 ; i < len ( out ) ; i + + { a : = int 1 6 ( volume * math . Max Int 1 6 ) if i % length < int ( float 6 4 ( length ) * sequence ) { a = - a } out [ i ] = a } } 
func to Bytes ( l , r [ ] int 1 6 ) [ ] byte { if len ( l ) ! = len ( r ) { panic ( " " ) } b : = make ( [ ] byte , len ( l ) * 4 ) for i : = range l { b [ 4 * i ] = byte ( l [ i ] ) b [ 4 * i + 1 ] = byte ( l [ i ] > > 8 ) b [ 4 * i + 2 ] = byte ( r [ i ] ) b [ 4 * i + 3 ] = byte ( r [ i ] > > 8 ) } return b } 
func play Note ( score Index int ) rune { note : = score [ score Index ] } freqs : = [ ] float 6 4 { freq C , freq D , freq E , freq F , freq G , freq A * 2 , freq B * 2 } freq : = 0 . 0 switch { case 'A ' < = note & & note < = 'B ' : freq = freqs [ int ( note ) + len ( freqs ) - int ( 'C ' ) ] case 'C ' < = note & & note < = 'G ' : freq = freqs [ note - 'C ' ] default : panic ( " " ) } const vol = 1 . 0 / 1 6 . 0 size : = ( ebiten . Max TPS ( ) / 2 - 2 ) * sample Rate / ebiten . Max TPS ( ) l : = make ( [ ] int 1 6 , size ) r : = make ( [ ] int 1 6 , size ) square ( l , vol , freq , 0 . 2 5 ) square ( r , vol , freq , 0 . 2 5 ) p , _ : = audio . New Player From Bytes ( audio Context , to Bytes ( l , r ) ) p . Play ( ) return rune ( note ) } 
func New Image From URL ( url string ) ( * ebiten . Image , error ) { res , err : = http . Get ( url ) if err ! = nil { return nil , err } defer res . Body . Close ( ) img , _ , err : = image . Decode ( res . Body ) if err ! = nil { return nil , err } eimg , _ : = ebiten . New Image From Image ( img , ebiten . Filter Default ) return eimg , nil } 
func piano At ( i int , freq float 6 4 ) float 6 4 { x : = [ ] float 6 4 { 4 . 0 , 2 . 0 , 1 . 0 , 0 . 5 , 0 . 2 5 } v : = 0 . 0 for j : = 0 ; j < len ( amp ) ; j + + { v + = a * math . Sin ( 2 . 0 * math . Pi * float 6 4 ( i ) * freq * float 6 4 ( j + 1 ) / sample Rate ) } return v / 5 . 0 } 
func play Note ( freq float 6 4 ) { f : = int ( freq ) p , _ : = audio . New Player From Bytes ( audio Context , piano Note Samples [ f ] ) p . Play ( ) } 
func ( p * Path ) Move To ( x , y float 3 2 ) { p . cur = math . Point { x , y } if len ( p . segs ) > 0 & & len ( p . segs [ len ( p . segs ) - 1 ] ) = = 0 { return } p . segs = append ( p . segs , [ ] math . Segment { } ) } 
func ( p * Path ) Line To ( x , y float 3 2 ) { if len ( p . segs ) = = 0 { p . segs = append ( p . segs , [ ] math . Segment { } ) } p . segs [ len ( p . segs ) - 1 ] = append ( p . segs [ len ( p . segs ) - 1 ] , math . Segment { p . cur , math . Point { x , y } } ) p . cur = math . Point { x , y } } 
func ( p * Path ) Draw ( target * ebiten . Image , op * Draw Path Options ) { if op = = nil { return } op : = & ebiten . Draw Triangles Options { } op . Address = ebiten . Address Repeat target . Draw Triangles ( vs , is , empty Image , op ) } } 
func seek Next Frame ( buf [ ] byte ) ( [ ] byte , bool ) { } buf = buf [ 1 : ] for { if buf [ 0 ] = = 0xff & & buf [ 1 ] & 0xfe = = 0xfe { break } buf = buf [ 1 : ] if len ( buf ) < 2 { return nil , false } } return buf , true } 
func ( g * Geo M ) String ( ) string { return fmt . Sprintf ( " " , g . a _ 1 + 1 , g . b , g . tx , g . c , g . d _ 1 + 1 , g . ty ) } 
func ( g * Geo M ) Reset ( ) { g . a _ 1 = 0 g . b = 0 g . c = 0 g . d _ 1 = 0 g . tx = 0 g . ty = 0 } 
func ( g * Geo M ) Apply ( x , y float 6 4 ) ( float 6 4 , float 6 4 ) { x 2 , y 2 : = g . apply 3 2 ( float 3 2 ( x ) , float 3 2 ( y ) ) return float 6 4 ( x 2 ) , float 6 4 ( y 2 ) } 
func ( g * Geo M ) Element ( i , j int ) float 6 4 { switch { case i = = 0 & & j = = 0 : return float 6 4 ( g . a _ 1 ) + 1 case i = = 0 & & j = = 1 : return float 6 4 ( g . b ) case i = = 0 & & j = = 2 : return float 6 4 ( g . tx ) case i = = 1 & & j = = 0 : return float 6 4 ( g . c ) case i = = 1 & & j = = 1 : return float 6 4 ( g . d _ 1 ) + 1 case i = = 1 & & j = = 2 : return float 6 4 ( g . ty ) default : panic ( " " ) } } 
func ( g * Geo M ) Concat ( other Geo M ) { a : = ( other . a _ 1 + 1 ) * ( g . a _ 1 + 1 ) + other . b * g . c b : = ( other . a _ 1 + 1 ) * g . b + other . b * ( g . d _ 1 + 1 ) tx : = ( other . a _ 1 + 1 ) * g . tx + other . b * g . ty + other . tx c : = other . c * ( g . a _ 1 + 1 ) + ( other . d _ 1 + 1 ) * g . c d : = other . c * g . b + ( other . d _ 1 + 1 ) * ( g . d _ 1 + 1 ) ty : = other . c * g . tx + ( other . d _ 1 + 1 ) * g . ty + other . ty g . a _ 1 = a - 1 g . b = b g . c = c g . d _ 1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * Geo M ) Add ( other Geo M ) { g . a _ 1 + = other . a _ 1 g . b + = other . b g . c + = other . c g . d _ 1 + = other . d _ 1 g . tx + = other . tx g . ty + = other . ty } 
func ( g * Geo M ) Scale ( x , y float 6 4 ) { a : = ( float 6 4 ( g . a _ 1 ) + 1 ) * x b : = float 6 4 ( g . b ) * x tx : = float 6 4 ( g . tx ) * x c : = float 6 4 ( g . c ) * y d : = ( float 6 4 ( g . d _ 1 ) + 1 ) * y ty : = float 6 4 ( g . ty ) * y g . a _ 1 = float 3 2 ( a ) - 1 g . b = float 3 2 ( b ) g . c = float 3 2 ( c ) g . d _ 1 = float 3 2 ( d ) - 1 g . tx = float 3 2 ( tx ) g . ty = float 3 2 ( ty ) } 
func ( g * Geo M ) Translate ( tx , ty float 6 4 ) { g . tx + = float 3 2 ( tx ) g . ty + = float 3 2 ( ty ) } 
func ( g * Geo M ) Rotate ( theta float 6 4 ) { if theta = = 0 { return } sin 6 4 , cos 6 4 : = math . Sincos ( theta ) sin , cos : = float 3 2 ( sin 6 4 ) , float 3 2 ( cos 6 4 ) a : = cos * ( g . a _ 1 + 1 ) - sin * g . c b : = cos * g . b - sin * ( g . d _ 1 + 1 ) tx : = cos * g . tx - sin * g . ty c : = sin * ( g . a _ 1 + 1 ) + cos * g . c d : = sin * g . b + cos * ( g . d _ 1 + 1 ) ty : = sin * g . tx + cos * g . ty g . a _ 1 = a - 1 g . b = b g . c = c g . d _ 1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * Geo M ) Skew ( skew X , skew Y float 6 4 ) { sx 6 4 : = math . Tan ( skew X ) sy 6 4 : = math . Tan ( skew Y ) sx , sy : = float 3 2 ( sx 6 4 ) , float 3 2 ( sy 6 4 ) a : = ( g . a _ 1 + 1 ) + g . c * sx b : = g . b + ( g . d _ 1 + 1 ) * sx c : = ( g . a _ 1 + 1 ) * sy + g . c d : = g . b * sy + ( g . d _ 1 + 1 ) tx : = g . tx + g . ty * sx ty : = g . ty + g . tx * sy g . a _ 1 = a - 1 g . b = b g . c = c g . d _ 1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * Geo M ) Invert ( ) { det : = g . det ( ) if det = = 0 { panic ( " " ) } a : = ( g . d _ 1 + 1 ) / det b : = - g . b / det c : = - g . c / det d : = ( g . a _ 1 + 1 ) / det tx : = ( - ( g . d _ 1 + 1 ) * g . tx + g . b * g . ty ) / det ty : = ( g . c * g . tx + - ( g . a _ 1 + 1 ) * g . ty ) / det g . a _ 1 = a - 1 g . b = b g . c = c g . d _ 1 = d - 1 g . tx = tx g . ty = ty } 
func ( g * Geo M ) Set Element ( i , j int , element float 6 4 ) { e : = float 3 2 ( element ) switch { case i = = 0 & & j = = 0 : g . a _ 1 = e - 1 case i = = 0 & & j = = 1 : g . b = e case i = = 0 & & j = = 2 : g . tx = e case i = = 1 & & j = = 0 : g . c = e case i = = 1 & & j = = 1 : g . d _ 1 = e - 1 case i = = 1 & & j = = 2 : g . ty = e default : panic ( " " ) } } 
func Scale Geo ( x , y float 6 4 ) Geo M { g : = Geo M { } g . Scale ( x , y ) return g } 
func Translate Geo ( tx , ty float 6 4 ) Geo M { g : = Geo M { } g . Translate ( tx , ty ) return g } 
func Rotate Geo ( theta float 6 4 ) Geo M { g : = Geo M { } g . Rotate ( theta ) return g } 
func clamp ( v , min , max int ) int { if min > max { panic ( " " ) } if v < min { return min } if max < v { return max } return v } 
func new Framebuffer From Texture ( context * context , texture texture Native , width , height int ) ( * framebuffer , error ) { native , err : = context . new Framebuffer ( texture ) if err ! = nil { return nil , err } return & framebuffer { native : native , width : width , height : height , } , nil } 
func new Screen Framebuffer ( context * context , width , height int ) * framebuffer { return & framebuffer { native : context . get Screen Framebuffer ( ) , width : width , height : height , } } 
func opaque ( m image . Image ) bool { if o , ok : = m . ( opaquer ) ; ok { return o . Opaque ( ) } b : = m . Bounds ( ) for y : = b . Min . Y ; y < b . Max . Y ; y + + { for x : = b . Min . X ; x < b . Max . X ; x + + { _ , _ , _ , a : = m . At ( x , y ) . RGBA ( ) if a ! = 0xffff { return false } } } return true } 
func ( e * encoder ) Write ( b [ ] byte ) ( int , error ) { e . write Chunk ( b , " " ) if e . err ! = nil { return 0 , e . err } return len ( b ) , nil } 
func filter ( cr * [ n Filter ] [ ] byte , pr [ ] byte , bpp int ) int { cdat 1 : = cr [ 1 ] [ 1 : ] cdat 2 : = cr [ 2 ] [ 1 : ] cdat 3 : = cr [ 3 ] [ 1 : ] cdat 4 : = cr [ 4 ] [ 1 : ] pdat : = pr [ 1 : ] n : = len ( cdat 0 ) for i : = 0 ; i < n ; i + + { cdat 2 [ i ] = cdat 0 [ i ] - pdat [ i ] sum + = abs 8 ( cdat 2 [ i ] ) } best : = sum filter : = ft Up for i : = 0 ; i < bpp ; i + + { cdat 4 [ i ] = cdat 0 [ i ] - pdat [ i ] sum + = abs 8 ( cdat 4 [ i ] ) } for i : = bpp ; i < n ; i + + { cdat 4 [ i ] = cdat 0 [ i ] - paeth ( cdat 0 [ i - bpp ] , pdat [ i ] , pdat [ i - bpp ] ) sum + = abs 8 ( cdat 4 [ i ] ) if sum > = best { break } } if sum < best { best = sum filter = ft Paeth } for i : = 0 ; i < n ; i + + { sum + = abs 8 ( cdat 0 [ i ] ) if sum > = best { break } } if sum < best { best = sum filter = ft None } for i : = 0 ; i < bpp ; i + + { cdat 1 [ i ] = cdat 0 [ i ] sum + = abs 8 ( cdat 1 [ i ] ) } for i : = bpp ; i < n ; i + + { cdat 1 [ i ] = cdat 0 [ i ] - cdat 0 [ i - bpp ] sum + = abs 8 ( cdat 1 [ i ] ) if sum > = best { break } } if sum < best { best = sum filter = ft Sub } for i : = 0 ; i < bpp ; i + + { cdat 3 [ i ] = cdat 0 [ i ] - pdat [ i ] / 2 sum + = abs 8 ( cdat 3 [ i ] ) } for i : = bpp ; i < n ; i + + { cdat 3 [ i ] = cdat 0 [ i ] - uint 8 ( ( int ( cdat 0 [ i - bpp ] ) + int ( pdat [ i ] ) ) / 2 ) sum + = abs 8 ( cdat 3 [ i ] ) if sum > = best { break } } if sum < best { best = sum filter = ft Average } return filter } 
func ( e * encoder ) write IDATs ( ) { if e . err ! = nil { return } if e . bw = = nil { e . bw = bufio . New Writer Size ( e , 1 < < 1 5 ) } else { e . bw . Reset ( e ) } e . err = e . write Image ( e . bw , e . m , e . cb , level To Zlib ( e . enc . Compression Level ) ) if e . err ! = nil { return } e . err = e . bw . Flush ( ) } 
func level To Zlib ( l Compression Level ) int { switch l { case Default Compression : return zlib . Default Compression case No Compression : return zlib . No Compression case Best Speed : return zlib . Best Speed case Best Compression : return zlib . Best Compression default : return zlib . Default Compression } } 
func Encode ( w io . Writer , m image . Image ) error { var e Encoder return e . Encode ( w , m ) } 
func ( enc * Encoder ) Encode ( w io . Writer , m image . Image ) error { if mw < = 0 | | mh < = 0 | | mw > = 1 < < 3 2 | | mh > = 1 < < 3 2 { return Format Error ( " " + strconv . Format Int ( mw , 1 0 ) + " " + strconv . Format Int ( mh , 1 0 ) ) } var e * encoder if enc . Buffer Pool ! = nil { buffer : = enc . Buffer Pool . Get ( ) e = ( * encoder ) ( buffer ) } if e = = nil { e = & encoder { } } if enc . Buffer Pool ! = nil { defer enc . Buffer Pool . Put ( ( * Encoder Buffer ) ( e ) ) } e . enc = enc e . w = w e . m = m var pal color . Palette } if pal ! = nil { if len ( pal ) < = 2 { e . cb = cb P 1 } else if len ( pal ) < = 4 { e . cb = cb P 2 } else if len ( pal ) < = 1 6 { e . cb = cb P 4 } else { e . cb = cb P 8 } } else { switch m . Color Model ( ) { case color . Gray Model : e . cb = cb G 8 case color . Gray 1 6Model : e . cb = cb G 1 6 case color . RGBAModel , color . NRGBAModel , color . Alpha Model : if opaque ( m ) { e . cb = cb TC 8 } else { e . cb = cb TCA 8 } default : if opaque ( m ) { e . cb = cb TC 1 6 } else { e . cb = cb TCA 1 6 } } } _ , e . err = io . Write String ( w , png Header ) e . write IHDR ( ) if pal ! = nil { e . write PLTEAnd TRNS ( pal ) } e . write IDATs ( ) e . write IEND ( ) return e . err } 
func New Image ( width , height int ) * Image { i : = & Image { image : graphicscommand . New Image ( width , height ) , } i . clear ( ) the Images . add ( i ) return i } 
func New Screen Framebuffer Image ( width , height int ) * Image { i : = & Image { image : graphicscommand . New Screen Framebuffer Image ( width , height ) , screen : true , } i . clear ( ) the Images . add ( i ) return i } 
func ( i * Image ) internal Size ( ) ( int , int ) { if i . w 2 = = 0 | | i . h 2 = = 0 { w , h : = i . image . Size ( ) i . w 2 = graphics . Internal Image Size ( w ) i . h 2 = graphics . Internal Image Size ( h ) } return i . w 2 , i . h 2 } 
func ( i * Image ) make Stale ( ) { i . base Pixels = nil i . draw Triangles History = nil i . stale = true / / Don 't have to call make Stale recursively here . / / Restoring is done after topological sorting is done . / / If an image depends on another stale image , this means that / / the former image can be restored from the latest state of the latter image . } 
func ( i * Image ) Replace Pixels ( pixels [ ] byte , x , y , width , height int ) { w , h : = i . image . Size ( ) if width < = 0 | | height < = 0 { panic ( " " ) } if x < 0 | | y < 0 | | w < = x | | h < = y | | x + width < = 0 | | y + height < = 0 | | w < x + width | | h < y + height { panic ( fmt . Sprintf ( " " , x , y , width , height ) ) } if pixels = = nil { pixels = make ( [ ] byte , 4 * width * height ) } i . image . Replace Pixels ( pixels , x , y , width , height ) if ! Is Restoring Enabled ( ) { i . make Stale ( ) return } if x = = 0 & & y = = 0 & & width = = w & & height = = h { if pixels ! = nil { if i . base Pixels = = nil { i . base Pixels = & Pixels { length : 4 * w * h , } } i . base Pixels . Copy From ( pixels , 0 ) } else { } i . draw Triangles History = nil i . stale = false return } if len ( i . draw Triangles History ) > 0 { panic ( " " ) } if i . stale { return } idx : = 4 * ( y * w + x ) if pixels ! = nil { if i . base Pixels = = nil { i . base Pixels = & Pixels { length : 4 * w * h , } } for j : = 0 ; j < height ; j + + { i . base Pixels . Copy From ( pixels [ 4 * j * width : 4 * ( j + 1 ) * width ] , idx ) idx + = 4 * w } } else if i . base Pixels ! = nil { zeros : = make ( [ ] byte , 4 * width ) for j : = 0 ; j < height ; j + + { i . base Pixels . Copy From ( zeros , idx ) idx + = 4 * w } } } 
func ( i * Image ) Draw Triangles ( img * Image , vertices [ ] float 3 2 , indices [ ] uint 1 6 , colorm * affine . Color M , mode graphics . Composite Mode , filter graphics . Filter , address graphics . Address ) { if i . priority { panic ( " " ) } if len ( vertices ) = = 0 { return } the Images . make Stale If Depending On ( i ) if img . stale | | img . volatile | | i . screen | | ! Is Restoring Enabled ( ) | | i . volatile { i . make Stale ( ) } else { i . append Draw Triangles History ( img , vertices , indices , colorm , mode , filter , address ) } i . image . Draw Triangles ( img . image , vertices , indices , colorm , mode , filter , address ) } 
func ( i * Image ) append Draw Triangles History ( image * Image , vertices [ ] float 3 2 , indices [ ] uint 1 6 , colorm * affine . Color M , mode graphics . Composite Mode , filter graphics . Filter , address graphics . Address ) { if i . stale | | i . volatile | | i . screen { return } if len ( i . draw Triangles History ) + 1 > max Draw Triangles History Num { i . make Stale ( ) return } i . draw Triangles History = append ( i . draw Triangles History , item ) } 
func ( i * Image ) At ( x , y int ) ( byte , byte , byte , byte ) { w , h : = i . image . Size ( ) if x < 0 | | y < 0 | | w < = x | | h < = y { return 0 , 0 , 0 , 0 } i . read Pixels From GPUIf Needed ( ) } idx : = 4 * x + 4 * y * w return i . base Pixels . At ( idx ) , i . base Pixels . At ( idx + 1 ) , i . base Pixels . At ( idx + 2 ) , i . base Pixels . At ( idx + 3 ) } 
func ( i * Image ) make Stale If Depending On ( target * Image ) { if i . stale { return } if i . depends On ( target ) { i . make Stale ( ) } } 
func ( i * Image ) read Pixels From GPU ( ) { pix : = i . image . Pixels ( ) i . base Pixels = & Pixels { pixels : pix , length : len ( pix ) , } i . draw Triangles History = nil i . stale = false } 
func ( i * Image ) resolve Stale ( ) { if ! Is Restoring Enabled ( ) { return } if i . volatile { return } if i . screen { return } if ! i . stale { return } i . read Pixels From GPU ( ) } 
func ( i * Image ) depends On ( target * Image ) bool { for _ , c : = range i . draw Triangles History { if c . image = = target { return true } } return false } 
func ( i * Image ) depending Images ( ) map [ * Image ] struct { } { r : = map [ * Image ] struct { } { } for _ , c : = range i . draw Triangles History { r [ c . image ] = struct { } { } } return r } 
func ( i * Image ) has Dependency ( ) bool { if i . stale { return false } return len ( i . draw Triangles History ) > 0 } 
func ( i * Image ) restore ( ) error { w , h : = i . image . Size ( ) if i . screen { i . base Pixels = nil i . draw Triangles History = nil i . stale = false return nil } if i . volatile { i . image = graphicscommand . New Image ( w , h ) i . clear ( ) return nil } if i . stale { } gimg : = graphicscommand . New Image ( w , h ) if i . base Pixels ! = nil { gimg . Replace Pixels ( i . base Pixels . Slice ( ) , 0 , 0 , w , h ) } else { gimg . Replace Pixels ( pix , 0 , 0 , w , h ) } for _ , c : = range i . draw Triangles History { if c . image . has Dependency ( ) { panic ( " " ) } gimg . Draw Triangles ( c . image . image , c . vertices , c . indices , c . colorm , c . mode , c . filter , c . address ) } i . image = gimg pix : = gimg . Pixels ( ) i . base Pixels = & Pixels { pixels : pix , length : len ( pix ) , } i . draw Triangles History = nil i . stale = false return nil } 
func ( i * Image ) Dispose ( ) { the Images . remove ( i ) i . image . Dispose ( ) i . image = nil i . base Pixels = nil i . draw Triangles History = nil i . stale = false } 
func ( i * Image ) Is Invalidated ( ) ( bool , error ) { if ! Is Restoring Enabled ( ) { return false , nil } return i . image . Is Invalidated ( ) , nil } 
func New Image ( width , height int ) * Image { i : = & Image { width : width , height : height , } c : = & new Image Command { result : i , width : width , height : height , } the Command Queue . Enqueue ( c ) return i } 
func ( i * Image ) Pixels ( ) [ ] byte { c : = & pixels Command { result : nil , img : i , } the Command Queue . Enqueue ( c ) the Command Queue . Flush ( ) return c . result } 
func ( i * Image ) Copy Pixels ( src * Image ) { if i . last Command = = last Command Draw Triangles { if i . width ! = src . width | | i . height ! = src . height { panic ( " " ) } } c : = & copy Pixels Command { dst : i , src : src , } the Command Queue . Enqueue ( c ) } 
func ( t * Tile ) Pos ( ) ( int , int ) { return t . current . x , t . current . y } 
func ( t * Tile ) Next Pos ( ) ( int , int ) { return t . next . x , t . next . y } 
func New Tile ( value int , x , y int ) * Tile { return & Tile { current : Tile Data { value : value , x : x , y : y , } , start Popping Count : max Popping Count , } } 
func Move Tiles ( tiles map [ * Tile ] struct { } , size int , dir Dir ) bool { vx , vy : = dir . Vector ( ) tx : = [ ] int { } ty : = [ ] int { } for i : = 0 ; i < size ; i + + { tx = append ( tx , i ) ty = append ( ty , i ) } if vx > 0 { sort . Sort ( sort . Reverse ( sort . Int Slice ( tx ) ) ) } if vy > 0 { sort . Sort ( sort . Reverse ( sort . Int Slice ( ty ) ) ) } moved : = false for _ , j : = range ty { for _ , i : = range tx { t : = tile At ( tiles , i , j ) if t = = nil { continue } if t . next ! = ( Tile Data { } ) { panic ( " " ) } if t . Is Moving ( ) { panic ( " " ) } jj : = j for { ni : = ii + vx nj : = jj + vy if ni < 0 | | ni > = size | | nj < 0 | | nj > = size { break } tt : = current Or Next Tile At ( tiles , ni , nj ) if tt = = nil { ii = ni jj = nj moved = true continue } if t . current . value ! = tt . current . value { break } if 0 < tt . moving Count & & tt . current . value ! = tt . next . value { } ii = ni jj = nj moved = true break } next . value = t . current . value tt . next . value = 0 tt . next . x = ii tt . next . y = jj tt . moving Count = max Moving Count } next . x = ii next . y = jj if t . current ! = next { t . next = next t . moving Count = max Moving Count } } } if ! moved { for t : = range tiles { t . next = Tile Data { } t . moving Count = 0 } } return moved } 
func ( t * Tile ) Update ( ) error { switch { case 0 < t . moving Count : t . moving Count - - if t . moving Count = = 0 { if t . current . value ! = t . next . value & & 0 < t . next . value { t . popping Count = max Popping Count } t . current = t . next t . next = Tile Data { } } case 0 < t . start Popping Count : t . start Popping Count - - case 0 < t . popping Count : t . popping Count - - } return nil } 
func ( t * Tile ) Draw ( board Image * ebiten . Image ) { i , j : = t . current . x , t . current . y ni , nj : = t . next . x , t . next . y v : = t . current . value if v = = 0 { return } op : = & ebiten . Draw Image Options { } x : = i * tile Size + ( i + 1 ) * tile Margin y : = j * tile Size + ( j + 1 ) * tile Margin nx : = ni * tile Size + ( ni + 1 ) * tile Margin ny : = nj * tile Size + ( nj + 1 ) * tile Margin switch { case 0 < t . moving Count : rate : = 1 - float 6 4 ( t . moving Count ) / max Moving Count x = mean ( x , nx , rate ) y = mean ( y , ny , rate ) case 0 < t . start Popping Count : rate : = 1 - float 6 4 ( t . start Popping Count ) / float 6 4 ( max Popping Count ) scale : = mean F ( 0 . 0 , 1 . 0 , rate ) op . Geo M . Translate ( float 6 4 ( - tile Size / 2 ) , float 6 4 ( - tile Size / 2 ) ) op . Geo M . Scale ( scale , scale ) op . Geo M . Translate ( float 6 4 ( tile Size / 2 ) , float 6 4 ( tile Size / 2 ) ) case 0 < t . popping Count : const max Scale = 1 . 2 rate : = 0 . 0 if max Popping Count * 2 / 3 < = t . popping Count { } else { } scale : = mean F ( 1 . 0 , max Scale , rate ) op . Geo M . Translate ( float 6 4 ( - tile Size / 2 ) , float 6 4 ( - tile Size / 2 ) ) op . Geo M . Scale ( scale , scale ) op . Geo M . Translate ( float 6 4 ( tile Size / 2 ) , float 6 4 ( tile Size / 2 ) ) } op . Geo M . Translate ( float 6 4 ( x ) , float 6 4 ( y ) ) r , g , b , a : = color To Scale ( tile Background Color ( v ) ) op . Color M . Scale ( r , g , b , a ) board Image . Draw Image ( tile Image , op ) str : = strconv . Itoa ( v ) f : = mplus Big Font switch { case 3 < len ( str ) : f = mplus Small Font case 2 < len ( str ) : f = mplus Normal Font } bound , _ : = font . Bound String ( f , str ) w : = ( bound . Max . X - bound . Min . X ) . Ceil ( ) h : = ( bound . Max . Y - bound . Min . Y ) . Ceil ( ) x = x + ( tile Size - w ) / 2 y = y + ( tile Size - h ) / 2 + h text . Draw ( board Image , str , f , x , y , tile Color ( v ) ) } 
func ( c * Color M ) String ( ) string { b , t : = c . impl . Unsafe Elements ( ) return fmt . Sprintf ( " " , b [ 0 ] , b [ 4 ] , b [ 8 ] , b [ 1 2 ] , t [ 0 ] , b [ 1 ] , b [ 5 ] , b [ 9 ] , b [ 1 3 ] , t [ 1 ] , b [ 2 ] , b [ 6 ] , b [ 1 0 ] , b [ 1 4 ] , t [ 2 ] , b [ 3 ] , b [ 7 ] , b [ 1 1 ] , b [ 1 5 ] , t [ 3 ] ) } 
func ( c * Color M ) Apply ( clr color . Color ) color . Color { return c . impl . Apply ( clr ) } 
func ( c * Color M ) Concat ( other Color M ) { c . impl = c . impl . Concat ( other . impl ) } 
func ( c * Color M ) Add ( other Color M ) { c . impl = c . impl . Add ( other . impl ) } 
func ( c * Color M ) Scale ( r , g , b , a float 6 4 ) { c . impl = c . impl . Scale ( float 3 2 ( r ) , float 3 2 ( g ) , float 3 2 ( b ) , float 3 2 ( a ) ) } 
func ( c * Color M ) Change HSV ( hue Theta float 6 4 , saturation Scale float 6 4 , value Scale float 6 4 ) { c . impl = c . impl . Change HSV ( hue Theta , float 3 2 ( saturation Scale ) , float 3 2 ( value Scale ) ) } 
func ( c * Color M ) Element ( i , j int ) float 6 4 { b , t : = c . impl . Unsafe Elements ( ) if j < Color MDim - 1 { return float 6 4 ( b [ i + j * ( Color MDim - 1 ) ] ) } return float 6 4 ( t [ i ] ) } 
func ( c * Color M ) Set Element ( i , j int , element float 6 4 ) { c . impl = c . impl . Set Element ( i , j , float 3 2 ( element ) ) } 
func Scale Color ( r , g , b , a float 6 4 ) Color M { c : = Color M { } c . Scale ( r , g , b , a ) return c } 
func Translate Color ( r , g , b , a float 6 4 ) Color M { c : = Color M { } c . Translate ( r , g , b , a ) return c } 
func Rotate Hue ( theta float 6 4 ) Color M { c : = Color M { } c . Rotate Hue ( theta ) return c } 
func available Filename ( prefix , postfix string ) ( string , error ) { const datetime Format = " " now : = time . Now ( ) name : = fmt . Sprintf ( " " , prefix , now . Format ( datetime Format ) , postfix ) for i : = 1 ; ; i + + { if _ , err : = os . Stat ( name ) ; err ! = nil { if os . Is Not Exist ( err ) { break } if ! os . Is Not Exist ( err ) { return " " , err } } name = fmt . Sprintf ( " " , prefix , now . Format ( datetime Format ) , i , postfix ) } return name , nil } 
func New Image From File ( path string , filter ebiten . Filter ) ( * ebiten . Image , image . Image , error ) { file , err : = Open File ( path ) if err ! = nil { return nil , nil , err } defer func ( ) { _ = file . Close ( ) } ( ) img , _ , err : = image . Decode ( file ) if err ! = nil { return nil , nil , err } img 2 , err : = ebiten . New Image From Image ( img , filter ) if err ! = nil { return nil , nil , err } return img 2 , img , err } 
func ( u * User Interface ) app Main ( a app . App ) { var glctx gl . Context touches : = map [ touch . Sequence ] * Touch { } for e : = range a . Events ( ) { switch e : = a . Filter ( e ) . ( type ) { case lifecycle . Event : switch e . Crosses ( lifecycle . Stage Visible ) { case lifecycle . Cross On : glctx , _ = e . Draw Context . ( gl . Context ) gl Context Ch = nil } a . Send ( paint . Event { } ) case lifecycle . Cross Off : glctx = nil } case size . Event : u . set Fullscreen Impl ( e . Width Px , e . Height Px ) case paint . Event : if glctx = = nil | | e . External { continue } render Ch < - struct { } { } < - render Ch End a . Publish ( ) a . Send ( paint . Event { } ) case touch . Event : switch e . Type { case touch . Type Begin , touch . Type Move : s : = get Device Scale ( ) x , y : = float 6 4 ( e . X ) / s , float 6 4 ( e . Y ) / s case touch . Type End : delete ( touches , e . Sequence ) } ts : = [ ] * Touch { } for _ , t : = range touches { ts = append ( ts , t ) } u . input . update ( ts ) } } } 
func repeating Key Pressed ( key ebiten . Key ) bool { const ( delay = 3 0 interval = 3 ) d : = inpututil . Key Press Duration ( key ) if d = = 1 { return true } if d > = delay & & ( d - delay ) % interval = = 0 { return true } return false } 
func ( a * array Buffer Layout ) total Bytes ( ) int { if a . total ! = 0 { return a . total } t : = 0 for _ , p : = range a . parts { t + = float . Size In Bytes ( ) * p . num } a . total = t return a . total } 
func ( a * array Buffer Layout ) new Array Buffer ( context * context ) buffer { return context . new Array Buffer ( a . total Bytes ( ) * graphics . Indices Num ) } 
func ( a * array Buffer Layout ) enable ( context * context , program program ) { for i : = range a . parts { context . enable Vertex Attrib Array ( program , i ) } total : = a . total Bytes ( ) offset : = 0 for i , p : = range a . parts { context . vertex Attrib Pointer ( program , i , p . num , float , total , offset ) offset + = float . Size In Bytes ( ) * p . num } } 
func ( a * array Buffer Layout ) disable ( context * context , program program ) { } } 
func ( s * open GLState ) reset ( context * context ) error { if err : = context . reset ( ) ; err ! = nil { return err } s . last Program = zero Program s . last Viewport Width = 0 s . last Viewport Height = 0 s . last Color Matrix = nil s . last Color Matrix Translation = nil s . last Source Width = 0 s . last Source Height = 0 s . last Filter = nil s . last Address = nil } else { for k , p : = range s . programs { context . delete Program ( p ) delete ( s . programs , k ) } } } if s . element Array Buffer ! = zero Buffer { context . delete Buffer ( s . element Array Buffer ) } } shader Vertex Modelview Native , err : = context . new Shader ( vertex Shader , vertex Shader Str ( ) ) if err ! = nil { panic ( fmt . Sprintf ( " \n " , err ) ) } defer context . delete Shader ( shader Vertex Modelview Native ) for _ , c : = range [ ] bool { false , true } { for _ , a : = range [ ] graphics . Address { graphics . Address Clamp To Zero , graphics . Address Repeat , } { for _ , f : = range [ ] graphics . Filter { graphics . Filter Nearest , graphics . Filter Linear , graphics . Filter Screen , } { shader Fragment Color Matrix Native , err : = context . new Shader ( fragment Shader , fragment Shader Str ( c , f , a ) ) if err ! = nil { panic ( fmt . Sprintf ( " \n " , err ) ) } defer context . delete Shader ( shader Fragment Color Matrix Native ) program , err : = context . new Program ( [ ] shader { shader Vertex Modelview Native , shader Fragment Color Matrix Native , } , the Array Buffer Layout . names ( ) ) if err ! = nil { return err } s . programs [ program Key { use Color M : c , filter : f , address : a , } ] = program } } } s . array Buffer = the Array Buffer Layout . new Array Buffer ( context ) return nil } 
func are Same Float 3 2Array ( a , b [ ] float 3 2 ) bool { if len ( a ) ! = len ( b ) { return false } for i : = 0 ; i < len ( a ) ; i + + { if a [ i ] ! = b [ i ] { return false } } return true } 
func ( d * Driver ) use Program ( mode graphics . Composite Mode , color M * affine . Color M , filter graphics . Filter , address graphics . Address ) error { destination : = d . state . destination if destination = = nil { panic ( " " ) } source : = d . state . source if source = = nil { panic ( " " ) } if err : = destination . set Viewport ( ) ; err ! = nil { return err } dst W : = destination . width src W , src H : = source . width , source . height d . context . blend Func ( mode ) program : = d . state . programs [ program Key { use Color M : color M ! = nil , filter : filter , address : address , } ] if d . state . last Program ! = program { d . context . use Program ( program ) if d . state . last Program = = zero Program { the Array Buffer Layout . enable ( & d . context , program ) d . context . bind Buffer ( array Buffer , d . state . array Buffer ) d . context . bind Buffer ( element Array Buffer , d . state . element Array Buffer ) d . context . uniform Int ( program , " " , 0 ) } d . state . last Program = program d . state . last Viewport Width = 0 d . state . last Viewport Height = 0 d . state . last Color Matrix = nil d . state . last Color Matrix Translation = nil d . state . last Source Width = 0 d . state . last Source Height = 0 } vw : = destination . framebuffer . width vh : = destination . framebuffer . height if d . state . last Viewport Width ! = vw | | d . state . last Viewport Height ! = vh { d . context . uniform Floats ( program , " " , [ ] float 3 2 { float 3 2 ( vw ) , float 3 2 ( vh ) } ) d . state . last Viewport Width = vw d . state . last Viewport Height = vh } if color M ! = nil { es Body , es Translate : = color M . Unsafe Elements ( ) if ! are Same Float 3 2Array ( d . state . last Color Matrix , es Body ) { d . context . uniform Floats ( program , " " , es Body ) } if ! are Same Float 3 2Array ( d . state . last Color Matrix Translation , es Translate ) { d . context . uniform Floats ( program , " " , es Translate ) } } if filter ! = graphics . Filter Nearest { sw : = graphics . Internal Image Size ( src W ) sh : = graphics . Internal Image Size ( src H ) if d . state . last Source Width ! = sw | | d . state . last Source Height ! = sh { d . context . uniform Floats ( program , " " , [ ] float 3 2 { float 3 2 ( sw ) , float 3 2 ( sh ) } ) d . state . last Source Width = sw d . state . last Source Height = sh } } if filter = = graphics . Filter Screen { scale : = float 3 2 ( dst W ) / float 3 2 ( src W ) d . context . uniform Float ( program , " " , scale ) } d . state . source = nil d . state . destination = nil return nil } 
func New Infinite Loop With Intro ( src Read Seek Closer , intro Length int 6 4 , loop Length int 6 4 ) * Infinite Loop { return & Infinite Loop { src : src , lstart : intro Length , llength : loop Length , pos : - 1 , } } 
func ( i * Infinite Loop ) Read ( b [ ] byte ) ( int , error ) { if err : = i . ensure Pos ( ) ; err ! = nil { return 0 , err } if i . pos + int 6 4 ( len ( b ) ) > i . length ( ) { b = b [ : i . length ( ) - i . pos ] } n , err : = i . src . Read ( b ) i . pos + = int 6 4 ( n ) if i . pos > i . length ( ) { panic ( fmt . Sprintf ( " " , i . pos , i . length ( ) ) ) } if err ! = nil & & err ! = io . EOF { return 0 , err } if err = = io . EOF | | i . pos = = i . length ( ) { pos , err : = i . Seek ( i . lstart , io . Seek Start ) if err ! = nil { return 0 , err } i . pos = pos } return n , nil } 
func ( i * Infinite Loop ) Seek ( offset int 6 4 , whence int ) ( int 6 4 , error ) { if err : = i . ensure Pos ( ) ; err ! = nil { return 0 , err } next : = int 6 4 ( 0 ) switch whence { case io . Seek Start : next = offset case io . Seek Current : next = i . pos + offset case io . Seek End : return 0 , fmt . Errorf ( " " ) } if next < 0 { return 0 , fmt . Errorf ( " " ) } if next > = i . lstart { next = ( ( next - i . lstart ) % i . llength ) + i . lstart } } i . pos = next return i . pos , nil } 
func Go Str ( cstr * uint 8 ) string { str : = " " for { if * cstr = = 0 { break } str + = string ( * cstr ) cstr = ( * uint 8 ) ( unsafe . Pointer ( uintptr ( unsafe . Pointer ( cstr ) ) + 1 ) ) } return str } 
func Strs ( strs . . . string ) ( cstrs * * uint 8 , free func ( ) ) { if len ( strs ) = = 0 { panic ( " " ) } var pinned [ ] string var ptrs [ ] * uint 8 for _ , str : = range strs { if ! strings . Has Suffix ( str , " \x 0 0 " ) { str + = " \x 0 0 " } pinned = append ( pinned , str ) ptrs = append ( ptrs , Str ( str ) ) } return & ptrs [ 0 ] , func ( ) { runtime . Keep Alive ( pinned ) pinned = nil } } 
func Restore ( ) error { if err : = graphicscommand . Reset Graphics Driver State ( ) ; err ! = nil { return err } return the Images . restore ( ) } 
func ( i * images ) remove ( img * Image ) { i . make Stale If Depending On Impl ( img ) delete ( i . images , img ) } 
func ( i * images ) resolve Stale Images ( ) { i . last Target = nil for img : = range i . images { img . resolve Stale ( ) } } 
func ( i * images ) restore ( ) error { if ! Is Restoring Enabled ( ) { panic ( " " ) } target * Image } images : = map [ * Image ] struct { } { } for i : = range i . images { if ! i . priority { images [ i ] = struct { } { } } } edges : = map [ edge ] struct { } { } for t : = range images { for s : = range t . depending Images ( ) { edges [ edge { source : s , target : t } ] = struct { } { } } } sorted : = [ ] * Image { } for i : = range i . images { if i . priority { sorted = append ( sorted , i ) } } for len ( images ) > 0 { for i : = range images { current [ i ] = struct { } { } } for e : = range edges { if _ , ok : = current [ e . target ] ; ok { delete ( current , e . target ) } } for i : = range current { delete ( images , i ) sorted = append ( sorted , i ) } removed : = [ ] edge { } for e : = range edges { if _ , ok : = current [ e . source ] ; ok { removed = append ( removed , e ) } } for _ , e : = range removed { delete ( edges , e ) } } for _ , img : = range sorted { if err : = img . restore ( ) ; err ! = nil { return err } } return nil } 
func ( p * player ) Move Forward ( ) { w , h : = gophers Image . Size ( ) mx : = w * 1 6 my : = h * 1 6 s , c : = math . Sincos ( float 6 4 ( p . angle ) * 2 * math . Pi / max Angle ) p . x 1 6 + = int ( round ( 1 6 * c ) * 2 ) p . y 1 6 + = int ( round ( 1 6 * s ) * 2 ) for mx < = p . x 1 6 { p . x 1 6 - = mx } for my < = p . y 1 6 { p . y 1 6 - = my } for p . x 1 6 < 0 { p . x 1 6 + = mx } for p . y 1 6 < 0 { p . y 1 6 + = my } } 
func ( p * player ) Rotate Right ( ) { p . angle + + if max Angle < = p . angle { p . angle - = max Angle } p . lean + + if max Lean < p . lean { p . lean = max Lean } } 
func ( p * player ) Rotate Left ( ) { p . angle - - if p . angle < 0 { p . angle + = max Angle } p . lean - - if p . lean < - max Lean { p . lean = - max Lean } } 
func ( p * player ) Stabilize ( ) { if 0 < p . lean { p . lean - - } if p . lean < 0 { p . lean + + } } 
func update Ground Image ( ground * ebiten . Image ) { ground . Clear ( ) x 1 6 , y 1 6 : = the Player . Position ( ) a : = the Player . Angle ( ) gw , gh : = ground . Size ( ) w , h : = gophers Image . Size ( ) op : = & ebiten . Draw Image Options { } op . Geo M . Translate ( float 6 4 ( - x 1 6 ) / 1 6 , float 6 4 ( - y 1 6 ) / 1 6 ) op . Geo M . Translate ( float 6 4 ( - w * 2 ) , float 6 4 ( - h * 2 ) ) op . Geo M . Rotate ( float 6 4 ( - a ) * 2 * math . Pi / max Angle + math . Pi * 3 . 0 / 2 . 0 ) op . Geo M . Translate ( float 6 4 ( gw ) / 2 , float 6 4 ( gh ) - 3 2 ) ground . Draw Image ( repeated Gophers Image , op ) } 
func draw Ground Image ( screen * ebiten . Image , ground * ebiten . Image ) { perspective Ground Image . Clear ( ) gw , _ : = ground . Size ( ) pw , ph : = perspective Ground Image . Size ( ) for j : = 0 ; j < ph ; j + + { z : = ( 1 - rate ) * 2 + rate * - 1 if z < = 0 { break } op : = & ebiten . Draw Image Options { } op . Geo M . Translate ( - float 6 4 ( pw ) / 2 , 0 ) op . Geo M . Scale ( 1 / z , 8 ) op . Geo M . Translate ( float 6 4 ( pw ) / 2 , float 6 4 ( j ) / z ) perspective Ground Image . Draw Image ( ground . Sub Image ( image . Rect ( 0 , j , gw , j + 1 ) ) . ( * ebiten . Image ) , op ) } perspective Ground Image . Draw Image ( fog Image , nil ) op : = & ebiten . Draw Image Options { } op . Geo M . Translate ( - float 6 4 ( pw ) / 2 , 0 ) op . Geo M . Rotate ( - 1 * float 6 4 ( the Player . lean ) / max Lean * math . Pi / 8 ) op . Geo M . Translate ( float 6 4 ( screen Width ) / 2 , screen Height / 3 ) screen . Draw Image ( perspective Ground Image , op ) } 
func ( d Dir ) String ( ) string { switch d { case Dir Up : return " " case Dir Right : return " " case Dir Down : return " " case Dir Left : return " " } panic ( " " ) } 
func ( d Dir ) Vector ( ) ( x , y int ) { switch d { case Dir Up : return 0 , - 1 case Dir Right : return 1 , 0 case Dir Down : return 0 , 1 case Dir Left : return - 1 , 0 } panic ( " " ) } 
func ( i * Input ) Update ( ) { switch i . mouse State { case mouse State None : if ebiten . Is Mouse Button Pressed ( ebiten . Mouse Button Left ) { x , y : = ebiten . Cursor Position ( ) i . mouse Init Pos X = x i . mouse Init Pos Y = y i . mouse State = mouse State Pressing } case mouse State Pressing : if ! ebiten . Is Mouse Button Pressed ( ebiten . Mouse Button Left ) { x , y : = ebiten . Cursor Position ( ) dx : = x - i . mouse Init Pos X dy : = y - i . mouse Init Pos Y d , ok : = vec To Dir ( dx , dy ) if ! ok { i . mouse State = mouse State None break } i . mouse Dir = d i . mouse State = mouse State Settled } case mouse State Settled : i . mouse State = mouse State None } switch i . touch State { case touch State None : ts : = ebiten . Touch IDs ( ) if len ( ts ) = = 1 { i . touch ID = ts [ 0 ] x , y : = ebiten . Touch Position ( ts [ 0 ] ) i . touch Init Pos X = x i . touch Init Pos Y = y i . touch Last Pos X = x i . touch Last Pos X = y i . touch State = touch State Pressing } case touch State Pressing : ts : = ebiten . Touch IDs ( ) if len ( ts ) > = 2 { break } if len ( ts ) = = 1 { if ts [ 0 ] ! = i . touch ID { i . touch State = touch State Invalid } else { x , y : = ebiten . Touch Position ( ts [ 0 ] ) i . touch Last Pos X = x i . touch Last Pos Y = y } break } if len ( ts ) = = 0 { dx : = i . touch Last Pos X - i . touch Init Pos X dy : = i . touch Last Pos Y - i . touch Init Pos Y d , ok : = vec To Dir ( dx , dy ) if ! ok { i . touch State = touch State None break } i . touch Dir = d i . touch State = touch State Settled } case touch State Settled : i . touch State = touch State None case touch State Invalid : if len ( ebiten . Touch IDs ( ) ) = = 0 { i . touch State = touch State None } } } 
func ( i * Input ) Dir ( ) ( Dir , bool ) { if inpututil . Is Key Just Pressed ( ebiten . Key Up ) { return Dir Up , true } if inpututil . Is Key Just Pressed ( ebiten . Key Left ) { return Dir Left , true } if inpututil . Is Key Just Pressed ( ebiten . Key Right ) { return Dir Right , true } if inpututil . Is Key Just Pressed ( ebiten . Key Down ) { return Dir Down , true } if i . mouse State = = mouse State Settled { return i . mouse Dir , true } if i . touch State = = touch State Settled { return i . touch Dir , true } return 0 , false } 
func ( s * stream ) Read ( buf [ ] byte ) ( int , error ) { if len ( s . remaining ) > 0 { n : = copy ( buf , s . remaining ) s . remaining = s . remaining [ n : ] return n , nil } var orig Buf [ ] byte if len ( buf ) % 4 > 0 { orig Buf = buf buf = make ( [ ] byte , len ( orig Buf ) + 4 - len ( orig Buf ) % 4 ) } const length = int 6 4 ( sample Rate / frequency ) p : = s . position / 4 for i : = 0 ; i < len ( buf ) / 4 ; i + + { const max = 3 2 7 6 7 b : = int 1 6 ( math . Sin ( 2 * math . Pi * float 6 4 ( p ) / float 6 4 ( length ) ) * max ) buf [ 4 * i ] = byte ( b ) buf [ 4 * i + 1 ] = byte ( b > > 8 ) buf [ 4 * i + 2 ] = byte ( b ) buf [ 4 * i + 3 ] = byte ( b > > 8 ) p + + } s . position + = int 6 4 ( len ( buf ) ) s . position % = length * 4 if orig Buf ! = nil { n : = copy ( orig Buf , buf ) s . remaining = buf [ n : ] return n , nil } return len ( buf ) , nil } 
func ( i * Image ) Size ( ) ( width , height int ) { s : = i . Bounds ( ) . Size ( ) return s . X , s . Y } 
func ( i * Image ) Fill ( clr color . Color ) error { i . copy Check ( ) if i . is Disposed ( ) { return nil } } i . resolve Pending Pixels ( false ) r 1 6 , g 1 6 , b 1 6 , a 1 6 : = clr . RGBA ( ) r , g , b , a : = uint 8 ( r 1 6 > > 8 ) , uint 8 ( g 1 6 > > 8 ) , uint 8 ( b 1 6 > > 8 ) , uint 8 ( a 1 6 > > 8 ) i . mipmap . original ( ) . Fill ( r , g , b , a ) i . dispose Mipmaps ( ) return nil } 
func ( i * Image ) Draw Image ( img * Image , options * Draw Image Options ) error { i . draw Image ( img , options ) return nil } 
func ( i * Image ) Draw Triangles ( vertices [ ] Vertex , indices [ ] uint 1 6 , img * Image , options * Draw Triangles Options ) { i . copy Check ( ) if i . is Disposed ( ) { return } if i . is Sub Image ( ) { panic ( " " ) } img . resolve Pending Pixels ( true ) i . resolve Pending Pixels ( true ) if len ( indices ) % 3 ! = 0 { panic ( " " ) } if len ( indices ) > Max Indices Num { panic ( " " ) } } mode : = graphics . Composite Mode ( options . Composite Mode ) filter : = graphics . Filter Nearest if options . Filter ! = Filter Default { filter = graphics . Filter ( options . Filter ) } else if img . filter ! = Filter Default { filter = graphics . Filter ( img . filter ) } vs : = make ( [ ] float 3 2 , len ( vertices ) * graphics . Vertex Float Num ) src : = img . mipmap . original ( ) r : = img . Bounds ( ) for idx , v : = range vertices { src . Put Vertex ( vs [ idx * graphics . Vertex Float Num : ( idx + 1 ) * graphics . Vertex Float Num ] , float 3 2 ( v . Dst X ) , float 3 2 ( v . Dst Y ) , v . Src X , v . Src Y , float 3 2 ( r . Min . X ) , float 3 2 ( r . Min . Y ) , float 3 2 ( r . Max . X ) , float 3 2 ( r . Max . Y ) , v . Color R , v . Color G , v . Color B , v . Color A ) } i . mipmap . original ( ) . Draw Triangles ( img . mipmap . original ( ) , vs , indices , options . Color M . impl , mode , filter , graphics . Address ( options . Address ) ) i . dispose Mipmaps ( ) } 
func ( i * Image ) Sub Image ( r image . Rectangle ) image . Image { i . copy Check ( ) if i . is Disposed ( ) { return nil } img : = & Image { mipmap : i . mipmap , filter : i . filter , } } else { img . original = i } img . addr = img r = r . Intersect ( i . Bounds ( ) ) } else { img . bounds = r } return img } 
func ( i * Image ) Bounds ( ) image . Rectangle { if ! i . is Sub Image ( ) { w , h : = i . mipmap . original ( ) . Size ( ) return image . Rect ( 0 , 0 , w , h ) } return i . bounds } 
func ( i * Image ) At ( x , y int ) color . Color { if atomic . Load Int 3 2 ( & is Running ) = = 0 { panic ( " " ) } if i . is Disposed ( ) { return color . RGBA { } } if i . is Sub Image ( ) & & ! image . Pt ( x , y ) . In ( i . bounds ) { return color . RGBA { } } i . resolve Pending Pixels ( true ) r , g , b , a : = i . mipmap . original ( ) . At ( x , y ) return color . RGBA { r , g , b , a } } 
func ( img * Image ) Set ( x , y int , clr color . Color ) { if atomic . Load Int 3 2 ( & is Running ) = = 0 { panic ( " " ) } img . copy Check ( ) if img . is Disposed ( ) { return } if img . is Sub Image ( ) & & ! image . Pt ( x , y ) . In ( img . bounds ) { return } if img . is Sub Image ( ) { img = img . original } w , h : = img . Size ( ) if img . pending Pixels = = nil { pix : = make ( [ ] byte , 4 * w * h ) idx : = 0 for j : = 0 ; j < h ; j + + { for i : = 0 ; i < w ; i + + { r , g , b , a : = img . mipmap . original ( ) . At ( i , j ) pix [ 4 * idx ] = r pix [ 4 * idx + 1 ] = g pix [ 4 * idx + 2 ] = b pix [ 4 * idx + 3 ] = a idx + + } } img . pending Pixels = pix } r , g , b , a : = clr . RGBA ( ) img . pending Pixels [ 4 * ( x + y * w ) ] = byte ( r > > 8 ) img . pending Pixels [ 4 * ( x + y * w ) + 1 ] = byte ( g > > 8 ) img . pending Pixels [ 4 * ( x + y * w ) + 2 ] = byte ( b > > 8 ) img . pending Pixels [ 4 * ( x + y * w ) + 3 ] = byte ( a > > 8 ) } 
func ( i * Image ) Dispose ( ) error { i . copy Check ( ) if i . is Disposed ( ) { return nil } if i . is Sub Image ( ) { return nil } i . mipmap . dispose ( ) i . resolve Pending Pixels ( false ) return nil } 
func ( i * Image ) Replace Pixels ( p [ ] byte ) error { i . copy Check ( ) if i . is Disposed ( ) { return nil } } i . resolve Pending Pixels ( false ) s : = i . Bounds ( ) . Size ( ) if l : = 4 * s . X * s . Y ; len ( p ) ! = l { panic ( fmt . Sprintf ( " " , len ( p ) , l ) ) } i . mipmap . original ( ) . Replace Pixels ( p ) i . dispose Mipmaps ( ) return nil } 
func New Image ( width , height int , filter Filter ) ( * Image , error ) { s : = shareable . New Image ( width , height ) i : = & Image { mipmap : new Mipmap ( s ) , filter : filter , } i . addr = i return i , nil } 
func ( i * Image ) make Volatile ( ) { if i . is Disposed ( ) { return } i . mipmap . orig . Make Volatile ( ) i . dispose Mipmaps ( ) } 
func New Image From Image ( source image . Image , filter Filter ) ( * Image , error ) { size : = source . Bounds ( ) . Size ( ) width , height : = size . X , size . Y s : = shareable . New Image ( width , height ) i : = & Image { mipmap : new Mipmap ( s ) , filter : filter , } i . addr = i _ = i . Replace Pixels ( graphics . Copy Image ( source ) ) return i , nil } 
func get Cached Monitor ( wx , wy int ) ( * cached Monitor , bool ) { for _ , m : = range monitors { if m . x < = wx & & wx < m . x + m . vm . Width & & m . y < = wy & & wy < m . y + m . vm . Height { return m , true } } return nil , false } 
func ( u * User Interface ) is Fullscreen ( ) bool { if ! u . is Running ( ) { panic ( " " ) } return u . window . Get Monitor ( ) ! = nil } 
func ( u * User Interface ) glfw Size ( ) ( int , int ) { w : = int ( float 6 4 ( u . window Width ) * u . get Scale ( ) * u . glfw Scale ( ) ) h : = int ( float 6 4 ( u . height ) * u . get Scale ( ) * u . glfw Scale ( ) ) return w , h } 
func ( u * User Interface ) get Scale ( ) float 6 4 { if ! u . is Fullscreen ( ) { return u . scale } if u . fullscreen Scale = = 0 { v : = u . window . Get Monitor ( ) . Get Video Mode ( ) sw : = float 6 4 ( v . Width ) / u . glfw Scale ( ) / float 6 4 ( u . width ) sh : = float 6 4 ( v . Height ) / u . glfw Scale ( ) / float 6 4 ( u . height ) s : = sw if s > sh { s = sh } u . fullscreen Scale = s } return u . fullscreen Scale } 
func ( u * User Interface ) actual Screen Scale ( ) float 6 4 { } return u . get Scale ( ) * devicescale . Get At ( u . current Monitor ( ) . Get Pos ( ) ) } 
func ( u * User Interface ) set Screen Size ( width , height int , scale float 6 4 , fullscreen bool , vsync bool ) bool { if u . width = = width & & u . height = = height & & u . scale = = scale & & u . is Fullscreen ( ) = = fullscreen & & u . vsync = = vsync { return false } u . force Set Screen Size ( width , height , scale , fullscreen , vsync ) return true } 
func ( u * User Interface ) force Set Screen Size ( width , height int , scale float 6 4 , fullscreen bool , vsync bool ) { if u . window . Get Attrib ( glfw . Decorated ) = = glfw . False { min Window Width = 1 } if width < 1 { width = 1 } if height < 1 { height = 1 } u . width = width u . window Width = width s : = scale * devicescale . Get At ( u . current Monitor ( ) . Get Pos ( ) ) if int ( float 6 4 ( width ) * s ) < min Window Width { u . window Width = int ( math . Ceil ( float 6 4 ( min Window Width ) / s ) ) } u . height = height u . scale = scale u . fullscreen Scale = 0 u . vsync = vsync if fullscreen { if u . orig Pos X = = invalid Pos | | u . orig Pos Y = = invalid Pos { u . orig Pos X , u . orig Pos Y = u . window . Get Pos ( ) } m : = u . current Monitor ( ) v : = m . Get Video Mode ( ) u . window . Set Monitor ( m , 0 , 0 , v . Width , v . Height , v . Refresh Rate ) } else { if u . window . Get Monitor ( ) ! = nil { } old W , old H : = u . window . Get Size ( ) new W , new H : = u . glfw Size ( ) if old W ! = new W | | old H ! = new H { ch : = make ( chan struct { } ) u . window . Set Framebuffer Size Callback ( func ( _ * glfw . Window , _ , _ int ) { u . window . Set Framebuffer Size Callback ( nil ) close ( ch ) } ) u . window . Set Size ( u . glfw Size ( ) ) event : for { glfw . Poll Events ( ) select { case < - ch : break event default : } } } if u . orig Pos X ! = invalid Pos & & u . orig Pos Y ! = invalid Pos { x : = u . orig Pos X y : = u . orig Pos Y u . window . Set Pos ( x , y ) u . window . Set Pos ( x , y ) } u . orig Pos X = invalid Pos u . orig Pos Y = invalid Pos } } if u . graphics . Is GL ( ) { } else { glfw . Swap Interval ( 0 ) } } u . graphics . Set Vsync Enabled ( vsync ) u . to Change Size = true } 
func ( u * User Interface ) current Monitor ( ) * glfw . Monitor { w : = u . window if m : = w . Get Monitor ( ) ; m ! = nil { return m } } 
func Copy Image ( img image . Image ) [ ] byte { size : = img . Bounds ( ) . Size ( ) w , h : = size . X , size . Y bs : = make ( [ ] byte , 4 * w * h ) switch img : = img . ( type ) { case * image . Paletted : b : = img . Bounds ( ) x 0 : = b . Min . X y 0 : = b . Min . Y x 1 : = b . Max . X y 1 : = b . Max . Y palette : = make ( [ ] uint 8 , len ( img . Palette ) * 4 ) for i , c : = range img . Palette { rgba : = color . RGBAModel . Convert ( c ) . ( color . RGBA ) palette [ 4 * i ] = rgba . R palette [ 4 * i + 1 ] = rgba . G palette [ 4 * i + 2 ] = rgba . B palette [ 4 * i + 3 ] = rgba . A } idx 1 : = 0 d : = img . Stride - ( x 1 - x 0 ) for j : = 0 ; j < y 1 - y 0 ; j + + { for i : = 0 ; i < x 1 - x 0 ; i + + { p : = int ( img . Pix [ idx 0 ] ) bs [ idx 1 ] = palette [ 4 * p ] bs [ idx 1 + 1 ] = palette [ 4 * p + 1 ] bs [ idx 1 + 2 ] = palette [ 4 * p + 2 ] bs [ idx 1 + 3 ] = palette [ 4 * p + 3 ] idx 0 + + idx 1 + = 4 } idx 0 + = d } default : dst Img : = & image . RGBA { Pix : bs , Stride : 4 * w , Rect : image . Rect ( 0 , 0 , w , h ) , } draw . Draw ( dst Img , image . Rect ( 0 , 0 , w , h ) , img , img . Bounds ( ) . Min , draw . Src ) } return bs } 
func ( q * command Queue ) append Vertices ( vertices [ ] float 3 2 ) { if len ( q . vertices ) < q . nvertices + len ( vertices ) { n : = q . nvertices + len ( vertices ) - len ( q . vertices ) q . vertices = append ( q . vertices , make ( [ ] float 3 2 , n ) . . . ) } copy ( q . vertices [ q . nvertices : ] , vertices ) q . nvertices + = len ( vertices ) } 
func ( q * command Queue ) Enqueue Draw Triangles Command ( dst , src * Image , vertices [ ] float 3 2 , indices [ ] uint 1 6 , color * affine . Color M , mode graphics . Composite Mode , filter graphics . Filter , address graphics . Address ) { if len ( indices ) > graphics . Indices Num { panic ( fmt . Sprintf ( " " , len ( indices ) , graphics . Indices Num ) ) } split : = false if q . tmp Num Indices + len ( indices ) > graphics . Indices Num { q . tmp Num Indices = 0 q . next Index = 0 split = true } q . append Vertices ( vertices ) q . append Indices ( indices , uint 1 6 ( q . next Index ) ) q . next Index + = len ( vertices ) / graphics . Vertex Float Num q . tmp Num Indices + = len ( indices ) } 
func ( q * command Queue ) Enqueue ( command command ) { } 
func ( q * command Queue ) Flush ( ) { if q . err ! = nil { return } es : = q . indices vs : = q . vertices if record Log ( ) { fmt . Println ( " " ) } the Graphics Driver . Begin ( ) for len ( q . commands ) > 0 { nv : = 0 ne : = 0 nc : = 0 for _ , c : = range q . commands { if c . Num Indices ( ) > graphics . Indices Num { panic ( fmt . Sprintf ( " " , c . Num Indices ( ) , graphics . Indices Num ) ) } if ne + c . Num Indices ( ) > graphics . Indices Num { break } nv + = c . Num Vertices ( ) ne + = c . Num Indices ( ) nc + + } if 0 < ne { the Graphics Driver . Set Vertices ( vs [ : nv ] , es [ : ne ] ) es = es [ ne : ] vs = vs [ nv : ] } index Offset : = 0 for _ , c : = range q . commands [ : nc ] { if err : = c . Exec ( index Offset ) ; err ! = nil { q . err = err return } if record Log ( ) { fmt . Printf ( " \n " , c ) } } if 0 < nc { } q . commands = q . commands [ nc : ] } the Graphics Driver . End ( ) q . commands = nil q . nvertices = 0 q . nindices = 0 q . tmp Num Indices = 0 q . next Index = 0 } 
func ( c * draw Triangles Command ) Exec ( index Offset int ) error { } c . dst . image . Set As Destination ( ) c . src . image . Set As Source ( ) if err : = the Graphics Driver . Draw ( c . nindices , index Offset , c . mode , c . color , c . filter , c . address ) ; err ! = nil { return err } return nil } 
func ( c * draw Triangles Command ) Can Merge ( dst , src * Image , color * affine . Color M , mode graphics . Composite Mode , filter graphics . Filter , address graphics . Address ) bool { if c . dst ! = dst { return false } if c . src ! = src { return false } if ! c . color . Equals ( color ) { return false } if c . mode ! = mode { return false } if c . filter ! = filter { return false } if c . address ! = address { return false } return true } 
func ( c * replace Pixels Command ) Exec ( index Offset int ) error { c . dst . image . Replace Pixels ( c . pixels , c . x , c . y , c . width , c . height ) return nil } 
func ( c * pixels Command ) Exec ( index Offset int ) error { p , err : = c . img . image . Pixels ( ) if err ! = nil { return err } c . result = p return nil } 
func ( c * dispose Command ) Exec ( index Offset int ) error { c . target . image . Dispose ( ) return nil } 
func ( c * new Image Command ) Exec ( index Offset int ) error { i , err : = the Graphics Driver . New Image ( c . width , c . height ) if err ! = nil { return err } c . result . image = i return nil } 
func ( c * new Screen Framebuffer Image Command ) Exec ( index Offset int ) error { var err error c . result . image , err = the Graphics Driver . New Screen Framebuffer Image ( c . width , c . height ) return err } 
func Opaque Network From Network ID ( client * govmomi . Client , id string ) ( * object . Opaque Network , error ) { vctx , vcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer vcancel ( ) v , err : = m . Create Container View ( vctx , client . Service Content . Root Folder , [ ] string { " " } , true ) if err ! = nil { return nil , err } defer func ( ) { dctx , dcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer dcancel ( ) v . Destroy ( dctx ) } ( ) var networks [ ] mo . Opaque Network err = v . Retrieve ( vctx , [ ] string { " " } , nil , & networks ) if err ! = nil { return nil , err } for _ , net : = range networks { if net . Summary . ( * types . Opaque Network Summary ) . Opaque Network Id = = id { ref : = net . Reference ( ) finder : = find . New Finder ( client . Client , false ) fctx , fcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer fcancel ( ) nref , err : = finder . Object Reference ( fctx , ref ) if err ! = nil { return nil , err } } } return nil , fmt . Errorf ( " " , id ) } 
func schema Host Network Policy ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expand Host Nic Failure Criteria ( d * schema . Resource Data ) * types . Host Nic Failure Criteria { obj : = & types . Host Nic Failure Criteria { } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Check Beacon = structure . Bool Ptr ( v . ( bool ) ) } obj . Speed = 1 0 obj . Check Duplex = structure . Bool Ptr ( false ) obj . Full Duplex = structure . Bool Ptr ( false ) obj . Check Error Percent = structure . Bool Ptr ( false ) obj . Percentage = 0 return obj } 
func flatten Host Nic Failure Criteria ( d * schema . Resource Data , obj * types . Host Nic Failure Criteria ) error { if obj . Check Beacon ! = nil { d . Set ( " " , obj . Check Beacon ) } return nil } 
func expand Host Nic Order Policy ( d * schema . Resource Data ) * types . Host Nic Order Policy { obj : = & types . Host Nic Order Policy { } active Nics , active Ok : = d . Get Ok Exists ( " " ) standby Nics , standby Ok : = d . Get Ok Exists ( " " ) if ! active Ok & & ! standby Ok { return nil } obj . Active Nic = structure . Slice Interfaces To Strings ( active Nics . ( [ ] interface { } ) ) obj . Standby Nic = structure . Slice Interfaces To Strings ( standby Nics . ( [ ] interface { } ) ) return obj } 
func flatten Host Nic Order Policy ( d * schema . Resource Data , obj * types . Host Nic Order Policy ) error { if obj = = nil { return nil } if err : = d . Set ( " " , structure . Slice Strings To Interfaces ( obj . Active Nic ) ) ; err ! = nil { return err } if err : = d . Set ( " " , structure . Slice Strings To Interfaces ( obj . Standby Nic ) ) ; err ! = nil { return err } return nil } 
func expand Host Nic Teaming Policy ( d * schema . Resource Data ) * types . Host Nic Teaming Policy { obj : = & types . Host Nic Teaming Policy { Policy : d . Get ( " " ) . ( string ) , } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Rolling Order = structure . Bool Ptr ( ! v . ( bool ) ) } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Notify Switches = structure . Bool Ptr ( v . ( bool ) ) } obj . Failure Criteria = expand Host Nic Failure Criteria ( d ) obj . Nic Order = expand Host Nic Order Policy ( d ) return obj } 
func flatten Host Nic Teaming Policy ( d * schema . Resource Data , obj * types . Host Nic Teaming Policy ) error { if obj . Rolling Order ! = nil { v : = * obj . Rolling Order d . Set ( " " , ! v ) } if obj . Notify Switches ! = nil { d . Set ( " " , obj . Notify Switches ) } d . Set ( " " , obj . Policy ) if err : = flatten Host Nic Failure Criteria ( d , obj . Failure Criteria ) ; err ! = nil { return err } if err : = flatten Host Nic Order Policy ( d , obj . Nic Order ) ; err ! = nil { return err } return nil } 
func expand Host Network Security Policy ( d * schema . Resource Data ) * types . Host Network Security Policy { obj : = & types . Host Network Security Policy { } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Allow Promiscuous = structure . Bool Ptr ( v . ( bool ) ) } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Forged Transmits = structure . Bool Ptr ( v . ( bool ) ) } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Mac Changes = structure . Bool Ptr ( v . ( bool ) ) } return obj } 
func flatten Host Network Security Policy ( d * schema . Resource Data , obj * types . Host Network Security Policy ) error { if obj . Allow Promiscuous ! = nil { d . Set ( " " , * obj . Allow Promiscuous ) } if obj . Forged Transmits ! = nil { d . Set ( " " , * obj . Forged Transmits ) } if obj . Mac Changes ! = nil { d . Set ( " " , * obj . Mac Changes ) } return nil } 
func expand Host Network Traffic Shaping Policy ( d * schema . Resource Data ) * types . Host Network Traffic Shaping Policy { obj : = & types . Host Network Traffic Shaping Policy { Average Bandwidth : int 6 4 ( d . Get ( " " ) . ( int ) ) , Burst Size : int 6 4 ( d . Get ( " " ) . ( int ) ) , Peak Bandwidth : int 6 4 ( d . Get ( " " ) . ( int ) ) , } if v , ok : = d . Get Ok Exists ( " " ) ; ok { obj . Enabled = structure . Bool Ptr ( v . ( bool ) ) } return obj } 
func flatten Host Network Traffic Shaping Policy ( d * schema . Resource Data , obj * types . Host Network Traffic Shaping Policy ) error { if obj . Enabled ! = nil { d . Set ( " " , * obj . Enabled ) } d . Set ( " " , obj . Average Bandwidth ) d . Set ( " " , obj . Burst Size ) d . Set ( " " , obj . Peak Bandwidth ) return nil } 
func expand Host Network Policy ( d * schema . Resource Data ) * types . Host Network Policy { obj : = & types . Host Network Policy { Security : expand Host Network Security Policy ( d ) , Nic Teaming : expand Host Nic Teaming Policy ( d ) , Shaping Policy : expand Host Network Traffic Shaping Policy ( d ) , } return obj } 
func flatten Host Network Policy ( d * schema . Resource Data , obj * types . Host Network Policy ) error { if err : = flatten Host Network Security Policy ( d , obj . Security ) ; err ! = nil { return err } if err : = flatten Host Nic Teaming Policy ( d , obj . Nic Teaming ) ; err ! = nil { return err } if err : = flatten Host Network Traffic Shaping Policy ( d , obj . Shaping Policy ) ; err ! = nil { return err } return nil } 
func schema Host Nas Volume Spec ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expand Host Nas Volume Spec ( d * schema . Resource Data ) * types . Host Nas Volume Spec { obj : = & types . Host Nas Volume Spec { Access Mode : d . Get ( " " ) . ( string ) , Local Path : d . Get ( " " ) . ( string ) , Remote Host : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) [ 0 ] , Remote Host Names : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) , Remote Path : d . Get ( " " ) . ( string ) , Security Type : d . Get ( " " ) . ( string ) , Type : d . Get ( " " ) . ( string ) , } return obj } 
func flatten Host Nas Volume ( d * schema . Resource Data , obj * types . Host Nas Volume ) error { d . Set ( " " , obj . Remote Path ) d . Set ( " " , obj . Security Type ) d . Set ( " " , obj . Protocol Endpoint ) if err : = d . Set ( " " , obj . Remote Host Names ) ; err ! = nil { return err } return nil } 
func is Nas Volume ( t types . Host File System Volume File System Type ) bool { switch t { case types . Host File System Volume File System Type NFS , types . Host File System Volume File System Type NFS 4 1 : return true } return false } 
func schema DVPortgroup Config Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema VMware DVSPort Setting ( ) ) return s } 
func expand VMware DVSPortgroup Policy ( d * schema . Resource Data ) * types . VMware DVSPortgroup Policy { obj : = & types . VMware DVSPortgroup Policy { DVPortgroup Policy : types . DVPortgroup Policy { Block Override Allowed : d . Get ( " " ) . ( bool ) , Shaping Override Allowed : d . Get ( " " ) . ( bool ) , Live Port Moving Allowed : d . Get ( " " ) . ( bool ) , Port Config Reset At Disconnect : d . Get ( " " ) . ( bool ) , Network Resource Pool Override Allowed : structure . Get Bool Ptr ( d , " " ) , Traffic Filter Override Allowed : structure . Get Bool Ptr ( d , " " ) , } , Vlan Override Allowed : d . Get ( " " ) . ( bool ) , Uplink Teaming Override Allowed : d . Get ( " " ) . ( bool ) , Security Policy Override Allowed : d . Get ( " " ) . ( bool ) , Ipfix Override Allowed : structure . Get Bool Ptr ( d , " " ) , } return obj } 
func flatten VMware DVSPortgroup Policy ( d * schema . Resource Data , obj * types . VMware DVSPortgroup Policy ) error { d . Set ( " " , obj . Block Override Allowed ) d . Set ( " " , obj . Shaping Override Allowed ) d . Set ( " " , obj . Live Port Moving Allowed ) d . Set ( " " , obj . Port Config Reset At Disconnect ) d . Set ( " " , obj . Vlan Override Allowed ) d . Set ( " " , obj . Uplink Teaming Override Allowed ) d . Set ( " " , obj . Security Policy Override Allowed ) structure . Set Bool Ptr ( d , " " , obj . Network Resource Pool Override Allowed ) structure . Set Bool Ptr ( d , " " , obj . Traffic Filter Override Allowed ) structure . Set Bool Ptr ( d , " " , obj . Ipfix Override Allowed ) return nil } 
func expand DVPortgroup Config Spec ( d * schema . Resource Data ) types . DVPortgroup Config Spec { obj : = types . DVPortgroup Config Spec { Config Version : d . Get ( " " ) . ( string ) , Name : d . Get ( " " ) . ( string ) , Num Ports : int 3 2 ( d . Get ( " " ) . ( int ) ) , Port Name Format : d . Get ( " " ) . ( string ) , Default Port Config : expand VMware DVSPort Setting ( d ) , Description : d . Get ( " " ) . ( string ) , Type : d . Get ( " " ) . ( string ) , Policy : expand VMware DVSPortgroup Policy ( d ) , Auto Expand : structure . Get Bool Ptr ( d , " " ) , Vm Vnic Network Resource Pool Key : d . Get ( " " ) . ( string ) , } return obj } 
func flatten DVPortgroup Config Info ( d * schema . Resource Data , obj types . DVPortgroup Config Info ) error { d . Set ( " " , obj . Config Version ) d . Set ( " " , obj . Name ) d . Set ( " " , obj . Num Ports ) d . Set ( " " , obj . Port Name Format ) d . Set ( " " , obj . Description ) d . Set ( " " , obj . Type ) structure . Set Bool Ptr ( d , " " , obj . Auto Expand ) d . Set ( " " , obj . Vm Vnic Network Resource Pool Key ) if err : = flatten VMware DVSPort Setting ( d , obj . Default Port Config . ( * types . VMware DVSPort Setting ) ) ; err ! = nil { return err } if err : = flatten VMware DVSPortgroup Policy ( d , obj . Policy . ( * types . VMware DVSPortgroup Policy ) ) ; err ! = nil { return err } return nil } 
func expand Cluster Host Group ( d * schema . Resource Data , name string ) ( * types . Cluster Host Group , error ) { obj : = & types . Cluster Host Group { Cluster Group Info : types . Cluster Group Info { Name : name , User Created : structure . Bool Ptr ( true ) , } , Host : structure . Slice Interfaces To Managed Object References ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " ) , } return obj , nil } 
func flatten Cluster Host Group ( d * schema . Resource Data , obj * types . Cluster Host Group ) error { var host IDs [ ] string for _ , v : = range obj . Host { host IDs = append ( host IDs , v . Value ) } return structure . Set Batch ( d , map [ string ] interface { } { " " : host IDs , } ) } 
func resource VSphere Compute Cluster Host Group Flatten ID ( cluster * object . Cluster Compute Resource , name string ) ( string , error ) { cluster ID : = cluster . Reference ( ) . Value return strings . Join ( [ ] string { cluster ID , name } , " " ) , nil } 
func resource VSphere Compute Cluster Host Group Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , string , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster Host Group Objects From ID ( d , meta ) } return resource VSphere Compute Cluster Host Group Objects From Attributes ( d , meta ) } 
func resource VSphere Compute Cluster Host Group Fetch Objects ( meta interface { } , cluster ID string , name string , ) ( * object . Cluster Compute Resource , string , error ) { client , err : = resource VSphere Compute Cluster Host Group Client ( meta ) if err ! = nil { return nil , " " , err } cluster , err : = clustercomputeresource . From ID ( client , cluster ID ) if err ! = nil { return nil , " " , fmt . Errorf ( " " , err ) } return cluster , name , nil } 
func netif Key ( key string , n int ) string { return fmt . Sprintf ( " " , c Netif Key Prefix , n , key ) } 
func match Gateway ( a string , m int , g string ) bool { ip : = net . Parse IP ( a ) gw : = net . Parse IP ( g ) var mask net . IPMask if ip . To 4 ( ) ! = nil { mask = net . CIDRMask ( m , 3 2 ) } else { mask = net . CIDRMask ( m , 1 2 8 ) } if ip . Mask ( mask ) . Equal ( gw . Mask ( mask ) ) { return true } return false } 
func Virtual Machine Customize Schema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expand Customization Global IPSettings ( d * schema . Resource Data ) types . Customization Global IPSettings { obj : = types . Customization Global IPSettings { Dns Suffix List : structure . Slice Interfaces To Strings ( d . Get ( c Key Prefix + " " + " " ) . ( [ ] interface { } ) ) , Dns Server List : structure . Slice Interfaces To Strings ( d . Get ( c Key Prefix + " " + " " ) . ( [ ] interface { } ) ) , } return obj } 
func expand Customization Linux Prep ( d * schema . Resource Data ) * types . Customization Linux Prep { obj : = & types . Customization Linux Prep { Host Name : & types . Customization Fixed Name { Name : d . Get ( c Linux Key Prefix + " " + " " ) . ( string ) , } , Domain : d . Get ( c Linux Key Prefix + " " + " " ) . ( string ) , Time Zone : d . Get ( c Linux Key Prefix + " " + " " ) . ( string ) , Hw Clock UTC : structure . Get Bool Ptr ( d , c Linux Key Prefix + " " + " " ) , } return obj } 
func expand Customization Gui Run Once ( d * schema . Resource Data ) * types . Customization Gui Run Once { obj : = & types . Customization Gui Run Once { Command List : structure . Slice Interfaces To Strings ( d . Get ( c Windows Key Prefix + " " + " " ) . ( [ ] interface { } ) ) , } if len ( obj . Command List ) < 1 { return nil } return obj } 
func expand Customization Gui Unattended ( d * schema . Resource Data ) types . Customization Gui Unattended { obj : = types . Customization Gui Unattended { Time Zone : int 3 2 ( d . Get ( c Windows Key Prefix + " " + " " ) . ( int ) ) , Auto Logon : d . Get ( c Windows Key Prefix + " " + " " ) . ( bool ) , Auto Logon Count : int 3 2 ( d . Get ( c Windows Key Prefix + " " + " " ) . ( int ) ) , } if v , ok : = d . Get Ok ( c Windows Key Prefix + " " + " " ) ; ok { obj . Password = & types . Customization Password { Value : v . ( string ) , Plain Text : true , } } return obj } 
func expand Customization Identification ( d * schema . Resource Data ) types . Customization Identification { obj : = types . Customization Identification { Join Workgroup : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , Join Domain : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , Domain Admin : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , } if v , ok : = d . Get Ok ( c Windows Key Prefix + " " + " " ) ; ok { obj . Domain Admin Password = & types . Customization Password { Value : v . ( string ) , Plain Text : true , } } return obj } 
func expand Customization User Data ( d * schema . Resource Data ) types . Customization User Data { obj : = types . Customization User Data { Full Name : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , Org Name : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , Computer Name : & types . Customization Fixed Name { Name : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , } , Product Id : d . Get ( c Windows Key Prefix + " " + " " ) . ( string ) , } return obj } 
func expand Customization Sysprep ( d * schema . Resource Data ) * types . Customization Sysprep { obj : = & types . Customization Sysprep { Gui Unattended : expand Customization Gui Unattended ( d ) , User Data : expand Customization User Data ( d ) , Gui Run Once : expand Customization Gui Run Once ( d ) , Identification : expand Customization Identification ( d ) , } return obj } 
func expand Customization Sysprep Text ( d * schema . Resource Data ) * types . Customization Sysprep Text { obj : = & types . Customization Sysprep Text { Value : d . Get ( c Key Prefix + " " + " " ) . ( string ) , } return obj } 
func expand Base Customization Identity Settings ( d * schema . Resource Data , family string ) types . Base Customization Identity Settings { var obj types . Base Customization Identity Settings _ , windows Exists : = d . Get Ok Exists ( c Key Prefix + " " + " " ) _ , sysprep Exists : = d . Get Ok Exists ( c Key Prefix + " " + " " ) switch { case family = = string ( types . Virtual Machine Guest Os Family Linux Guest ) : obj = expand Customization Linux Prep ( d ) case family = = string ( types . Virtual Machine Guest Os Family Windows Guest ) & & windows Exists : obj = expand Customization Sysprep ( d ) case family = = string ( types . Virtual Machine Guest Os Family Windows Guest ) & & sysprep Exists : obj = expand Customization Sysprep Text ( d ) default : obj = & types . Customization Identity Settings { } } return obj } 
func expand Customization IPSettings IPV 6Address Spec ( d * schema . Resource Data , n int , gw Add bool ) ( * types . Customization IPSettings Ip V 6Address Spec , bool ) { v , ok : = d . Get Ok ( netif Key ( " " , n ) ) var gw Found bool if ! ok { return nil , gw Found } addr : = v . ( string ) mask : = d . Get ( netif Key ( " " , n ) ) . ( int ) gw , gw Ok : = d . Get ( c Key Prefix + " " + " " ) . ( string ) obj : = & types . Customization IPSettings Ip V 6Address Spec { Ip : [ ] types . Base Customization Ip V 6Generator { & types . Customization Fixed Ip V 6 { Ip Address : addr , Subnet Mask : int 3 2 ( mask ) , } , } , } if gw Add & & gw Ok & & match Gateway ( addr , mask , gw ) { obj . Gateway = [ ] string { gw } gw Found = true } return obj , gw Found } 
func expand Customization IPSettings ( d * schema . Resource Data , n int , v 4gw Add , v 6gw Add bool ) ( types . Customization IPSettings , bool , bool ) { var v 4gw Found , v 6gw Found bool v 4addr , v 4addr Ok : = d . Get Ok ( netif Key ( " " , n ) ) v 4mask : = d . Get ( netif Key ( " " , n ) ) . ( int ) v 4gw , v 4gw Ok : = d . Get ( c Key Prefix + " " + " " ) . ( string ) var obj types . Customization IPSettings switch { case v 4addr Ok : obj . Ip = & types . Customization Fixed Ip { Ip Address : v 4addr . ( string ) , } obj . Subnet Mask = v 4CIDRMask To Dotted ( v 4mask ) v 4gw Found = true } default : obj . Ip = & types . Customization Dhcp Ip Generator { } } obj . Dns Server List = structure . Slice Interfaces To Strings ( d . Get ( netif Key ( " " , n ) ) . ( [ ] interface { } ) ) obj . Dns Domain = d . Get ( netif Key ( " " , n ) ) . ( string ) obj . Ip V 6Spec , v 6gw Found = expand Customization IPSettings IPV 6Address Spec ( d , n , v 6gw Add ) return obj , v 4gw Found , v 6gw Found } 
func expand Slice Of Customization Adapter Mapping ( d * schema . Resource Data ) [ ] types . Customization Adapter Mapping { s : = d . Get ( c Key Prefix + " " + " " ) . ( [ ] interface { } ) if len ( s ) < 1 { return nil } result : = make ( [ ] types . Customization Adapter Mapping , len ( s ) ) var v 4gw Found , v 6gw Found bool for i : = range s { var adapter types . Customization IPSettings adapter , v 4gw Found , v 6gw Found = expand Customization IPSettings ( d , i , ! v 4gw Found , ! v 6gw Found ) obj : = types . Customization Adapter Mapping { Adapter : adapter , } result [ i ] = obj } return result } 
func Expand Customization Spec ( d * schema . Resource Data , family string ) types . Customization Spec { obj : = types . Customization Spec { Identity : expand Base Customization Identity Settings ( d , family ) , Global IPSettings : expand Customization Global IPSettings ( d ) , Nic Setting Map : expand Slice Of Customization Adapter Mapping ( d ) , } return obj } 
func Validate Customization Spec ( d * schema . Resource Diff , family string ) error { windows Exists : = len ( d . Get ( c Key Prefix + " " + " " ) . ( [ ] interface { } ) ) > 0 sysprep Exists : = d . Get ( c Key Prefix + " " + " " ) . ( string ) ! = " " switch { case family = = string ( types . Virtual Machine Guest Os Family Linux Guest ) & & ! linux Exists : return errors . New ( " " ) case family = = string ( types . Virtual Machine Guest Os Family Windows Guest ) & & ! windows Exists & & ! sysprep Exists : return errors . New ( " " ) } return nil } 
func schema Host Virtual Switch Bond Bridge ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expand Host Virtual Switch Beacon Config ( d * schema . Resource Data ) * types . Host Virtual Switch Beacon Config { obj : = & types . Host Virtual Switch Beacon Config { Interval : int 3 2 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flatten Host Virtual Switch Beacon Config ( d * schema . Resource Data , obj * types . Host Virtual Switch Beacon Config ) error { d . Set ( " " , obj . Interval ) return nil } 
func expand Link Discovery Protocol Config ( d * schema . Resource Data ) * types . Link Discovery Protocol Config { obj : = & types . Link Discovery Protocol Config { Operation : d . Get ( " " ) . ( string ) , Protocol : d . Get ( " " ) . ( string ) , } return obj } 
func flatten Link Discovery Protocol Config ( d * schema . Resource Data , obj * types . Link Discovery Protocol Config ) error { d . Set ( " " , obj . Operation ) d . Set ( " " , obj . Protocol ) return nil } 
func expand Host Virtual Switch Bond Bridge ( d * schema . Resource Data ) * types . Host Virtual Switch Bond Bridge { obj : = & types . Host Virtual Switch Bond Bridge { Nic Device : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } obj . Beacon = expand Host Virtual Switch Beacon Config ( d ) obj . Link Discovery Protocol Config = expand Link Discovery Protocol Config ( d ) return obj } 
func flatten Host Virtual Switch Bond Bridge ( d * schema . Resource Data , obj * types . Host Virtual Switch Bond Bridge ) error { if err : = d . Set ( " " , structure . Slice Strings To Interfaces ( obj . Nic Device ) ) ; err ! = nil { return err } if err : = flatten Host Virtual Switch Beacon Config ( d , obj . Beacon ) ; err ! = nil { return err } if err : = flatten Link Discovery Protocol Config ( d , obj . Link Discovery Protocol Config ) ; err ! = nil { return err } return nil } 
func schema Host Virtual Switch Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema Host Virtual Switch Bond Bridge ( ) ) structure . Merge Schema ( s , schema Host Network Policy ( ) ) return s } 
func expand Host Virtual Switch Spec ( d * schema . Resource Data ) * types . Host Virtual Switch Spec { obj : = & types . Host Virtual Switch Spec { Mtu : int 3 2 ( d . Get ( " " ) . ( int ) ) , Num Ports : int 3 2 ( d . Get ( " " ) . ( int ) ) , Bridge : expand Host Virtual Switch Bond Bridge ( d ) , Policy : expand Host Network Policy ( d ) , } } return obj } 
func flatten Host Virtual Switch Spec ( d * schema . Resource Data , obj * types . Host Virtual Switch Spec ) error { d . Set ( " " , obj . Mtu ) d . Set ( " " , obj . Num Ports ) if obj . Bridge ! = nil { if err : = flatten Host Virtual Switch Bond Bridge ( d , obj . Bridge . ( * types . Host Virtual Switch Bond Bridge ) ) ; err ! = nil { return err } } if err : = flatten Host Network Policy ( d , obj . Policy ) ; err ! = nil { return err } return nil } 
func save Host Virtual Switch ID ( d * schema . Resource Data , hs ID , name string ) { d . Set Id ( fmt . Sprintf ( " " , host Virtual Switch IDPrefix , hs ID , name ) ) } 
func split Host Virtual Switch ID ( raw string ) ( string , string , error ) { s : = strings . Split N ( raw , " " , 3 ) if len ( s ) ! = 3 | | s [ 0 ] ! = host Virtual Switch IDPrefix | | s [ 1 ] = = " " | | s [ 2 ] = = " " { return " " , " " , fmt . Errorf ( " " , raw ) } return s [ 1 ] , s [ 2 ] , nil } 
func virtual Switch IDs From Resource ID ( d * schema . Resource Data ) ( string , string , error ) { return split Host Virtual Switch ID ( d . Id ( ) ) } 
func expand Storage Drs VMConfig Info ( d * schema . Resource Data , vm * object . Virtual Machine ) ( * types . Storage Drs Vm Config Info , error ) { enabled , err : = structure . Get Bool String Ptr ( d , " " ) if err ! = nil { return nil , fmt . Errorf ( " \ " \ " " , err ) } intra VMAffinity , err : = structure . Get Bool String Ptr ( d , " " ) if err ! = nil { return nil , fmt . Errorf ( " \ " \ " " , err ) } obj : = & types . Storage Drs Vm Config Info { Behavior : d . Get ( " " ) . ( string ) , Enabled : enabled , Intra Vm Affinity : intra VMAffinity , Vm : types . New Reference ( vm . Reference ( ) ) , } return obj , nil } 
func flatten Storage Drs VMConfig Info ( d * schema . Resource Data , obj * types . Storage Drs Vm Config Info ) error { if err : = d . Set ( " " , obj . Behavior ) ; err ! = nil { return fmt . Errorf ( " \ " \ " " , err ) } if err : = structure . Set Bool String Ptr ( d , " " , obj . Enabled ) ; err ! = nil { return fmt . Errorf ( " \ " \ " " , err ) } if err : = structure . Set Bool String Ptr ( d , " " , obj . Intra Vm Affinity ) ; err ! = nil { return fmt . Errorf ( " \ " \ " " , err ) } return nil } 
func resource VSphere Storage Drs VMOverride Flatten ID ( pod * object . Storage Pod , vm * object . Virtual Machine ) ( string , error ) { pod ID : = pod . Reference ( ) . Value props , err : = virtualmachine . Properties ( vm ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } vm ID : = props . Config . Uuid return strings . Join ( [ ] string { pod ID , vm ID } , " " ) , nil } 
func resource VSphere Storage Drs VMOverride Find Entry ( pod * object . Storage Pod , vm * object . Virtual Machine , ) ( * types . Storage Drs Vm Config Info , error ) { props , err : = storagepod . Properties ( pod ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Pod Storage Drs Entry . Storage Drs Config . Vm Config { if * info . Vm = = vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , pod . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , pod . Name ( ) ) return nil , nil } 
func resource VSphere Storage Drs VMOverride Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Storage Pod , * object . Virtual Machine , error ) { if d . Id ( ) ! = " " { return resource VSphere Storage Drs VMOverride Objects From ID ( d , meta ) } return resource VSphere Storage Drs VMOverride Objects From Attributes ( d , meta ) } 
func Network Interface Subresource Schema ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , subresource Schema ( ) ) return s } 
func New Network Interface Subresource ( client * govmomi . Client , rdd resource Data Diff , d , old map [ string ] interface { } , idx int ) * Network Interface Subresource { sr : = & Network Interface Subresource { Subresource : & Subresource { schema : Network Interface Subresource Schema ( ) , client : client , srtype : subresource Type Network Interface , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func Network Interface Refresh Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) error { log . Printf ( " " ) devices : = l . Select ( func ( device types . Base Virtual Device ) bool { if _ , ok : = device . ( types . Base Virtual Ethernet Card ) ; ok { return true } return false } ) log . Printf ( " " , Device List String ( devices ) ) cur Set : = d . Get ( subresource Type Network Interface ) . ( [ ] interface { } ) log . Printf ( " " , subresource List String ( cur Set ) ) urange , err : = nic Unit Range ( devices ) if err ! = nil { return fmt . Errorf ( " " , err ) } new Set : = make ( [ ] interface { } , urange ) log . Printf ( " " , len ( devices ) , urange ) for n , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r : = New Network Interface Subresource ( c , d , m , nil , n ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } _ , _ , idx , err : = split Dev Addr ( r . Get ( " " ) . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , r , err ) } new Set [ idx - network Interface Pci Device Offset ] = r . Data ( ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] if device . Get Virtual Device ( ) . Key = = int 3 2 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } } } log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( new Set ) ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] for n , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 0 { } if device . Get Virtual Device ( ) . Key ! = int 3 2 ( m [ " " ] . ( int ) ) { } if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if err ! = nil { return fmt . Errorf ( " " , r , err ) } new Set [ idx - network Interface Pci Device Offset ] = r . Data ( ) devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " , Device List String ( devices ) ) for n , device : = range devices { m : = make ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } r : = New Network Interface Subresource ( c , d , m , nil , n ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } _ , _ , idx , err : = split Dev Addr ( r . Get ( " " ) . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , r , err ) } new Set [ idx - network Interface Pci Device Offset ] = r . Data ( ) } i - - } } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " ) return d . Set ( subresource Type Network Interface , new Set ) } 
func Network Interface Diff Operation ( d * schema . Resource Diff , c * govmomi . Client ) error { log . Printf ( " " ) for ni , ne : = range n . ( [ ] interface { } ) { nm : = ne . ( map [ string ] interface { } ) r : = New Network Interface Subresource ( c , d , nm , nil , ni ) if err : = r . Validate Diff ( ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } log . Printf ( " " ) return nil } 
func Network Interface Post Clone Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( object . Virtual Device List , [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " ) devices : = l . Select ( func ( device types . Base Virtual Device ) bool { if _ , ok : = device . ( types . Base Virtual Ethernet Card ) ; ok { return true } return false } ) log . Printf ( " " , Device List String ( devices ) ) cur Set : = d . Get ( subresource Type Network Interface ) . ( [ ] interface { } ) log . Printf ( " " , subresource List String ( cur Set ) ) urange , err : = nic Unit Range ( devices ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } src Set : = make ( [ ] interface { } , urange ) log . Printf ( " " , len ( devices ) , urange ) for n , device : = range devices { m : = make ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return nil , nil , fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } r : = New Network Interface Subresource ( c , d , m , nil , n ) if err : = r . Read ( l ) ; err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } _ , _ , idx , err : = split Dev Addr ( r . Get ( " " ) . ( string ) ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r , err ) } src Set [ idx - network Interface Pci Device Offset ] = r . Data ( ) } var updates [ ] interface { } for i , ci : = range cur Set { cm : = ci . ( map [ string ] interface { } ) if i > len ( src Set ) - 1 | | src Set [ i ] = = nil { cspec , err : = r . Create ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , cspec ) spec = append ( spec , cspec . . . ) updates = append ( updates , r . Data ( ) ) continue } sm : = src Set [ i ] . ( map [ string ] interface { } ) nc , err : = copystructure . Copy ( sm ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , i , err ) } nm : = nc . ( map [ string ] interface { } ) for k , v : = range cm { } nm [ k ] = v } r : = New Network Interface Subresource ( c , d , nm , sm , i ) if ! reflect . Deep Equal ( sm , nm ) { if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , cspec ) spec = append ( spec , cspec . . . ) } updates = append ( updates , r . Data ( ) ) } r : = New Network Interface Subresource ( c , d , sm , nil , i + len ( cur Set ) ) dspec , err : = r . Delete ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , dspec ) spec = append ( spec , dspec . . . ) } } log . Printf ( " " , subresource List String ( updates ) ) } log . Printf ( " " , Device List String ( l ) ) log . Printf ( " " , Device Change String ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func Read Network Interface Types ( l object . Virtual Device List ) ( [ ] string , error ) { log . Printf ( " " ) devices : = l . Select ( func ( device types . Base Virtual Device ) bool { if _ , ok : = device . ( types . Base Virtual Ethernet Card ) ; ok { return true } return false } ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) var out [ ] string for _ , device : = range devices { out = append ( out , virtual Ethernet Card String ( device . ( types . Base Virtual Ethernet Card ) ) ) } log . Printf ( " " , out ) return out , nil } 
func base Virtual Ethernet Card To Base Virtual Device ( v types . Base Virtual Ethernet Card ) types . Base Virtual Device { switch t : = v . ( type ) { case * types . Virtual E 1 0 0 0 : return types . Base Virtual Device ( t ) case * types . Virtual E 1 0 0 0e : return types . Base Virtual Device ( t ) case * types . Virtual PCNet 3 2 : return types . Base Virtual Device ( t ) case * types . Virtual Sriov Ethernet Card : return types . Base Virtual Device ( t ) case * types . Virtual Vmxnet 2 : return types . Base Virtual Device ( t ) case * types . Virtual Vmxnet 3 : return types . Base Virtual Device ( t ) } panic ( fmt . Errorf ( " " , v ) ) } 
func base Virtual Device To Base Virtual Ethernet Card ( v types . Base Virtual Device ) ( types . Base Virtual Ethernet Card , error ) { if bve , ok : = v . ( types . Base Virtual Ethernet Card ) ; ok { return bve , nil } return nil , fmt . Errorf ( " " , v ) } 
func virtual Ethernet Card String ( d types . Base Virtual Ethernet Card ) string { switch d . ( type ) { case * types . Virtual E 1 0 0 0 : return network Interface Subresource Type E 1 0 0 0 case * types . Virtual E 1 0 0 0e : return network Interface Subresource Type E 1 0 0 0e case * types . Virtual PCNet 3 2 : return network Interface Subresource Type PCNet 3 2 case * types . Virtual Sriov Ethernet Card : return network Interface Subresource Type Sriov case * types . Virtual Vmxnet 2 : return network Interface Subresource Type Vmxnet 2 case * types . Virtual Vmxnet 3 : return network Interface Subresource Type Vmxnet 3 } return network Interface Subresource Type Unknown } 
func ( r * Network Interface Subresource ) Create ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) var spec [ ] types . Base Virtual Device Config Spec ctlr , err : = r . Controller For Create Update ( l , Subresource Controller Type PCI , 0 ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } bctx , bcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer bcancel ( ) backing , err : = net . Ethernet Card Backing Info ( bctx ) if err ! = nil { return nil , err } device , err : = l . Create Ethernet Card ( r . Get ( " " ) . ( string ) , backing ) if err ! = nil { return nil , err } } card . Key = l . New Key ( ) card . Mac Address = r . Get ( " " ) . ( string ) } version : = viapi . Parse Version From Client ( r . client ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { alloc : = & types . Virtual Ethernet Card Resource Allocation { Limit : structure . Int 6 4Ptr ( int 6 4 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int 6 4Ptr ( int 6 4 ( r . Get ( " " ) . ( int ) ) ) , Share : types . Shares Info { Shares : int 3 2 ( r . Get ( " " ) . ( int ) ) , Level : types . Shares Level ( r . Get ( " " ) . ( string ) ) , } , } card . Resource Allocation = alloc } } dspec , err : = object . Virtual Device List { device } . Config Spec ( types . Virtual Device Config Spec Operation Add ) if err ! = nil { return nil , err } spec = append ( spec , dspec . . . ) log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Network Interface Subresource ) Read ( l object . Virtual Device List ) error { log . Printf ( " " , r ) vd , err : = r . Find Virtual Device ( l ) if err ! = nil { return fmt . Errorf ( " " , err ) } device , err : = base Virtual Device To Base Virtual Ethernet Card ( vd ) if err ! = nil { return err } switch backing : = card . Backing . ( type ) { case * types . Virtual Ethernet Card Network Backing Info : if backing . Network = = nil { return fmt . Errorf ( " " ) } net ID = backing . Network . Value case * types . Virtual Ethernet Card Opaque Network Backing Info : onet , err : = nsx . Opaque Network From Network ID ( r . client , backing . Opaque Network Id ) if err ! = nil { return err } net ID = onet . Reference ( ) . Value case * types . Virtual Ethernet Card Distributed Virtual Port Backing Info : pg , err : = dvportgroup . From Key ( r . client , backing . Port . Switch Uuid , backing . Port . Portgroup Key ) if err ! = nil { return err } net ID = pg . Reference ( ) . Value default : return fmt . Errorf ( " " , card . Backing ) } r . Set ( " " , net ID ) r . Set ( " " , card . Address Type = = string ( types . Virtual Ethernet Card Mac Type Manual ) ) r . Set ( " " , card . Mac Address ) version : = viapi . Parse Version From Client ( r . client ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { if card . Resource Allocation ! = nil { r . Set ( " " , card . Resource Allocation . Limit ) r . Set ( " " , card . Resource Allocation . Reservation ) r . Set ( " " , card . Resource Allocation . Share . Shares ) r . Set ( " " , card . Resource Allocation . Share . Level ) } } if err ! = nil { return err } if err : = r . Save Dev IDs ( vd , ctlr ) ; err ! = nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * Network Interface Subresource ) Update ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) vd , err : = r . Find Virtual Device ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } device , err : = base Virtual Device To Base Virtual Ethernet Card ( vd ) if err ! = nil { return nil , err } card : = device . Get Virtual Ethernet Card ( ) new Device , err : = l . Create Ethernet Card ( r . Get ( " " ) . ( string ) , card . Backing ) if err ! = nil { return nil , err } new Card : = new Device . ( types . Base Virtual Ethernet Card ) . Get Virtual Ethernet Card ( ) if card . Unit Number ! = nil { var un int 3 2 un = * card . Unit Number new Card . Unit Number = & un } } dspec , err : = object . Virtual Device List { bvd } . Config Spec ( types . Virtual Device Config Spec Operation Remove ) if err ! = nil { return nil , err } spec = append ( spec , dspec . . . ) if err ! = nil { return nil , err } } card : = device . Get Virtual Ethernet Card ( ) if err ! = nil { return nil , err } bctx , bcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer bcancel ( ) backing , err : = net . Ethernet Card Backing Info ( bctx ) if err ! = nil { return nil , err } card . Backing = backing } if r . Has Change ( " " ) { if r . Get ( " " ) . ( bool ) { card . Address Type = string ( types . Virtual Ethernet Card Mac Type Manual ) card . Mac Address = r . Get ( " " ) . ( string ) } else { } else { } card . Mac Address = " " } } version : = viapi . Parse Version From Client ( r . client ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { alloc : = & types . Virtual Ethernet Card Resource Allocation { Limit : structure . Int 6 4Ptr ( int 6 4 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int 6 4Ptr ( int 6 4 ( r . Get ( " " ) . ( int ) ) ) , Share : types . Shares Info { Shares : int 3 2 ( r . Get ( " " ) . ( int ) ) , Level : types . Shares Level ( r . Get ( " " ) . ( string ) ) , } , } card . Resource Allocation = alloc } var op types . Virtual Device Config Spec Operation if card . Key < 0 { } else { op = types . Virtual Device Config Spec Operation Edit } bvd : = base Virtual Ethernet Card To Base Virtual Device ( device ) uspec , err : = object . Virtual Device List { bvd } . Config Spec ( op ) if err ! = nil { return nil , err } spec = append ( spec , uspec . . . ) log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Network Interface Subresource ) Delete ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) vd , err : = r . Find Virtual Device ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } device , err : = base Virtual Device To Base Virtual Ethernet Card ( vd ) if err ! = nil { return nil , err } } bvd : = base Virtual Ethernet Card To Base Virtual Device ( device ) spec , err : = object . Virtual Device List { bvd } . Config Spec ( types . Virtual Device Config Spec Operation Remove ) if err ! = nil { return nil , err } log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Network Interface Subresource ) Validate Diff ( ) error { log . Printf ( " " , r ) if version . Older ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { if err : = r . restrict Resource Allocation Settings ( ) ; err ! = nil { return err } } log . Printf ( " " , r ) return nil } 
func ( r * Network Interface Subresource ) assign Ethernet Card ( l object . Virtual Device List , device types . Base Virtual Device , c types . Base Virtual Controller ) error { ckey : = c . Get Virtual Controller ( ) . Key for _ , device : = range l { d : = device . Get Virtual Device ( ) if d . Controller Key ! = ckey | | d . Unit Number = = nil | | * d . Unit Number < pci Device Offset | | * d . Unit Number > = pci Device Offset + 1 0 { continue } units [ * d . Unit Number - pci Device Offset ] = true } if units [ new Unit - pci Device Offset ] { return fmt . Errorf ( " " , new Unit ) } d : = device . Get Virtual Device ( ) d . Controller Key = c . Get Virtual Controller ( ) . Key d . Unit Number = & new Unit if d . Key = = 0 { d . Key = - 1 } return nil } 
func nic Unit Range ( l object . Virtual Device List ) ( int , error ) { } high : = int 3 2 ( network Interface Pci Device Offset ) for _ , v : = range l { d : = v . Get Virtual Device ( ) if d . Unit Number = = nil { return 0 , fmt . Errorf ( " " , d . Key ) } if * d . Unit Number > high { high = * d . Unit Number } } return int ( high - network Interface Pci Device Offset + 1 ) , nil } 
func host Storage System From Host System ID ( client * govmomi . Client , hs ID string ) ( * object . Host Storage System , error ) { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return nil , err } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) return hs . Config Manager ( ) . Storage System ( ctx ) } 
func From UUID ( client * govmomi . Client , uuid string ) ( * object . Virtual Machine , error ) { log . Printf ( " " , uuid ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var result object . Reference var err error version : = viapi . Parse Version From Client ( client ) expected : = vm UUIDSearch Index Version expected . Product = version . Product if version . Older ( expected ) { result , err = virtual Machine From Container View ( ctx , client , uuid ) } else { result , err = virtual Machine From Search Index ( ctx , client , uuid ) } if err ! = nil { return nil , err } vm , err : = finder . Object Reference ( ctx , result . Reference ( ) ) if err ! = nil { return nil , err } return vm . ( * object . Virtual Machine ) , nil } 
func virtual Machine From Search Index ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( " " , uuid ) search : = object . New Search Index ( client . Client ) result , err : = search . Find By Uuid ( ctx , nil , uuid , true , structure . Bool Ptr ( false ) ) if err ! = nil { return nil , err } if result = = nil { return nil , new UUIDNot Found Error ( fmt . Sprintf ( " " , uuid ) ) } return result , nil } 
func virtual Machine From Container View ( ctx context . Context , client * govmomi . Client , uuid string ) ( object . Reference , error ) { log . Printf ( " " , uuid ) m : = view . New Manager ( client . Client ) v , err : = m . Create Container View ( ctx , client . Service Content . Root Folder , [ ] string { " " } , true ) if err ! = nil { return nil , err } defer func ( ) { if err = v . Destroy ( ctx ) ; err ! = nil { log . Printf ( " " , err ) } } ( ) var vms , results [ ] mo . Virtual Machine err = v . Retrieve ( ctx , [ ] string { " " } , [ ] string { " " } , & results ) if err ! = nil { return nil , err } for _ , result : = range results { if result . Config = = nil { continue } if result . Config . Uuid = = uuid { vms = append ( vms , result ) } } switch { case len ( vms ) < 1 : return nil , new UUIDNot Found Error ( fmt . Sprintf ( " " , uuid ) ) case len ( vms ) > 1 : return nil , fmt . Errorf ( " " , uuid ) } return object . New Reference ( client . Client , vms [ 0 ] . Self ) , nil } 
func Properties ( vm * object . Virtual Machine ) ( * mo . Virtual Machine , error ) { log . Printf ( " " , vm . Inventory Path ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Virtual Machine if err : = vm . Properties ( ctx , vm . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Wait For Guest IP ( client * govmomi . Client , vm * object . Virtual Machine , timeout int , ignored Guest IPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( " " , vm . Inventory Path ) return nil } log . Printf ( " " , vm . Inventory Path , timeout , ) p : = client . Property Collector ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err : = property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { " " } , func ( pc [ ] types . Property Change ) bool { for _ , c : = range pc { if c . Op ! = types . Property Change Op Assign { continue } if c . Val = = nil { continue } ip : = net . Parse IP ( c . Val . ( string ) ) if skip IPAddr For Waiter ( ip , ignored Guest IPs ) { continue } return true } return false } ) if err ! = nil { } return err } log . Printf ( " " , vm . Inventory Path ) return nil } 
func Wait For Guest Net ( client * govmomi . Client , vm * object . Virtual Machine , routable bool , timeout int , ignored Guest IPs [ ] interface { } ) error { if timeout < 1 { log . Printf ( " " , vm . Inventory Path ) return nil } log . Printf ( " " , vm . Inventory Path , routable , timeout , ) var v 4gw , v 6gw net . IP p : = client . Property Collector ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) err : = property . Wait ( ctx , p , vm . Reference ( ) , [ ] string { " " , " " } , func ( pc [ ] types . Property Change ) bool { for _ , c : = range pc { if c . Op ! = types . Property Change Op Assign { continue } switch v : = c . Val . ( type ) { case types . Array Of Guest Stack Info : for _ , s : = range v . Guest Stack Info { if s . Ip Route Config ! = nil { for _ , r : = range s . Ip Route Config . Ip Route { switch r . Network { case " " : v 4gw = net . Parse IP ( r . Gateway . Ip Address ) case " " : v 6gw = net . Parse IP ( r . Gateway . Ip Address ) } } } } case types . Array Of Guest Nic Info : for _ , n : = range v . Guest Nic Info { if n . Ip Config ! = nil { for _ , addr : = range n . Ip Config . Ip Address { ip : = net . Parse IP ( addr . Ip Address ) if skip IPAddr For Waiter ( ip , ignored Guest IPs ) { continue } if ! routable { } var mask net . IPMask if ip . To 4 ( ) ! = nil { mask = net . CIDRMask ( int ( addr . Prefix Length ) , 3 2 ) } else { mask = net . CIDRMask ( int ( addr . Prefix Length ) , 1 2 8 ) } if ip . Mask ( mask ) . Equal ( v 4gw . Mask ( mask ) ) | | ip . Mask ( mask ) . Equal ( v 6gw . Mask ( mask ) ) { return true } } } } } } return false } ) if err ! = nil { } return err } log . Printf ( " " , vm . Inventory Path ) return nil } 
func Create ( c * govmomi . Client , f * object . Folder , s types . Virtual Machine Config Spec , p * object . Resource Pool , h * object . Host System ) ( * object . Virtual Machine , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , s . Name ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var task * object . Task if err ! = nil { if ! viapi . Is Managed Object Not Found Error ( err ) { return nil , err } task , err = f . Create VM ( ctx , s , p , h ) } else { task , err = vc . Create Child VM ( ctx , s , h ) } if err ! = nil { return nil , err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) result , err : = task . Wait For Result ( tctx , nil ) if err ! = nil { return nil , err } log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , s . Name ) , result . Result . ( types . Managed Object Reference ) . Value ) return From MOID ( c , result . Result . ( types . Managed Object Reference ) . Value ) } 
func Clone ( c * govmomi . Client , src * object . Virtual Machine , f * object . Folder , name string , spec types . Virtual Machine Clone Spec , timeout int ) ( * object . Virtual Machine , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , name ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err : = src . Clone ( ctx , f , name , spec ) if err ! = nil { if ctx . Err ( ) = = context . Deadline Exceeded { err = errors . New ( " " ) } return nil , err } result , err : = task . Wait For Result ( ctx , nil ) if err ! = nil { if ctx . Err ( ) = = context . Deadline Exceeded { err = errors . New ( " " ) } return nil , err } log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , name ) , result . Result . ( types . Managed Object Reference ) . Value ) return From MOID ( c , result . Result . ( types . Managed Object Reference ) . Value ) } 
func Customize ( vm * object . Virtual Machine , spec types . Customization Spec ) error { log . Printf ( " " , vm . Inventory Path ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = vm . Customize ( ctx , spec ) if err ! = nil { return err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) return task . Wait ( tctx ) } 
func Shutdown Guest ( client * govmomi . Client , vm * object . Virtual Machine , timeout int ) error { log . Printf ( " " , vm . Inventory Path ) sctx , scancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer scancel ( ) if err : = vm . Shutdown Guest ( sctx ) ; err ! = nil { return err } if timeout < 1 { timeout = 1 } pctx , pcancel : = context . With Timeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer pcancel ( ) err : = property . Wait ( pctx , p , vm . Reference ( ) , [ ] string { " " } , func ( pc [ ] types . Property Change ) bool { for _ , c : = range pc { if c . Op ! = types . Property Change Op Assign { continue } switch v : = c . Val . ( type ) { case types . Virtual Machine Power State : if v = = types . Virtual Machine Power State Powered Off { return true } } } return false } ) if err ! = nil { } return err } return nil } 
func Graceful Power Off ( client * govmomi . Client , vm * object . Virtual Machine , timeout int , force bool ) error { vprops , err : = Properties ( vm ) if err ! = nil { return err } } } else { return nil } } } 
func Move To Folder ( client * govmomi . Client , vm * object . Virtual Machine , relative string ) error { log . Printf ( " " , vm . Inventory Path , relative ) f , err : = folder . Virtual Machine Folder From Object ( client , vm , relative ) if err ! = nil { return err } return folder . Move Object To ( vm . Reference ( ) , f ) } 
func Relocate ( vm * object . Virtual Machine , spec types . Virtual Machine Relocate Spec , timeout int ) error { log . Printf ( " " , vm . Inventory Path , timeout ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Minute * time . Duration ( timeout ) ) defer cancel ( ) task , err : = vm . Relocate ( ctx , spec , " " ) if err ! = nil { return err } if err : = task . Wait ( ctx ) ; err ! = nil { } } return nil } 
func MOIDFor UUID ( client * govmomi . Client , uuid string ) ( MOIDFor UUIDResult , error ) { vm , err : = From UUID ( client , uuid ) if err ! = nil { return MOIDFor UUIDResult { } , err } return MOIDFor UUIDResult { UUID : uuid , MOID : vm . Reference ( ) . Value , } , nil } 
func UUIDFor MOID ( client * govmomi . Client , moid string ) ( MOIDFor UUIDResult , error ) { vm , err : = From MOID ( client , moid ) if err ! = nil { return MOIDFor UUIDResult { } , err } props , err : = Properties ( vm ) if err ! = nil { return MOIDFor UUIDResult { } , err } return MOIDFor UUIDResult { UUID : props . Config . Uuid , MOID : vm . Reference ( ) . Value , } , nil } 
func MOIDs For UUIDs ( client * govmomi . Client , uuids [ ] string ) ( MOIDFor UUIDResults , error ) { var results MOIDFor UUIDResults for _ , uuid : = range uuids { result , err : = MOIDFor UUID ( client , uuid ) if err ! = nil { return nil , err } results = append ( results , result ) } return results , nil } 
func UUIDs For MOIDs ( client * govmomi . Client , moids [ ] string ) ( MOIDFor UUIDResults , error ) { var results MOIDFor UUIDResults for _ , uuid : = range moids { result , err : = UUIDFor MOID ( client , uuid ) if err ! = nil { return nil , err } results = append ( results , result ) } return results , nil } 
func UUIDs For Managed Object References ( client * govmomi . Client , refs [ ] types . Managed Object Reference ) ( MOIDFor UUIDResults , error ) { var moids [ ] string for _ , ref : = range refs { moids = append ( moids , ref . Value ) } return UUIDs For MOIDs ( client , moids ) } 
func ( r MOIDFor UUIDResults ) MOIDs ( ) [ ] string { var moids [ ] string for _ , result : = range r { moids = append ( moids , result . MOID ) } return moids } 
func ( r MOIDFor UUIDResults ) Managed Object References ( ) [ ] types . Managed Object Reference { var refs [ ] types . Managed Object Reference for _ , result : = range r { refs = append ( refs , types . Managed Object Reference { Type : " " , Value : result . MOID , } ) } return refs } 
func ( r MOIDFor UUIDResults ) UUIDs ( ) [ ] string { var uuids [ ] string for _ , result : = range r { uuids = append ( uuids , result . UUID ) } return uuids } 
func From Key ( client * govmomi . Client , dvs UUID , pg Key string ) ( * object . Distributed Virtual Portgroup , error ) { dvsm : = types . Managed Object Reference { Type : " " , Value : " " } req : = & types . DVSManager Lookup Dv Port Group { This : dvsm , Switch Uuid : dvs UUID , Portgroup Key : pg Key , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) resp , err : = methods . DVSManager Lookup Dv Port Group ( ctx , client , req ) if err ! = nil { return nil , err } if resp . Returnval = = nil { return nil , New Missing Port Group Reference Error ( fmt . Sprintf ( " " , dvs UUID , pg Key , ) , ) } return From MOID ( client , resp . Returnval . Reference ( ) . Value ) } 
func From MOID ( client * govmomi . Client , id string ) ( * object . Distributed Virtual Portgroup , error ) { finder : = find . New Finder ( client . Client , false ) ref : = types . Managed Object Reference { Type : " " , Value : id , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) ds , err : = finder . Object Reference ( ctx , ref ) if err ! = nil { return nil , err } } 
func From Path ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . Distributed Virtual Portgroup , error ) { finder : = find . New Finder ( client . Client , false ) if dc ! = nil { finder . Set Datacenter ( dc ) } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) net , err : = finder . Network ( ctx , name ) if err ! = nil { return nil , err } if net . Reference ( ) . Type ! = " " { return nil , fmt . Errorf ( " " , name , net . Reference ( ) . Type ) } return From MOID ( client , net . Reference ( ) . Value ) } 
func Properties ( pg * object . Distributed Virtual Portgroup ) ( * mo . Distributed Virtual Portgroup , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Distributed Virtual Portgroup if err : = pg . Properties ( ctx , pg . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Create ( client * govmomi . Client , dvs * object . Vmware Distributed Virtual Switch , spec types . DVPortgroup Config Spec ) ( * object . Task , error ) { req : = & types . Create DVPortgroup _Task { This : dvs . Reference ( ) , Spec : spec , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) resp , err : = methods . Create DVPortgroup _Task ( ctx , client , req ) if err ! = nil { return nil , err } return object . New Task ( client . Client , resp . Returnval . Reference ( ) ) , nil } 
func Properties ( ds * object . Datastore ) ( * mo . Datastore , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Datastore if err : = ds . Properties ( ctx , ds . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Move To Folder ( client * govmomi . Client , ds * object . Datastore , relative string ) error { f , err : = folder . Datastore Folder From Object ( client , ds , relative ) if err ! = nil { return err } return folder . Move Object To ( ds . Reference ( ) , f ) } 
func Move To Folder Relative Host System ID ( client * govmomi . Client , ds * object . Datastore , hs ID , relative string ) error { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return err } f , err : = folder . Datastore Folder From Object ( client , hs , relative ) if err ! = nil { return err } return folder . Move Object To ( ds . Reference ( ) , f ) } 
func Browser ( ds * object . Datastore ) ( * object . Host Datastore Browser , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return ds . Browser ( ctx ) } 
func Search Datastore ( ds * object . Datastore , name string ) ( [ ] * types . File Info , error ) { result , err : = search Datastore ( ds , name ) if err ! = nil { return nil , err } var files [ ] * types . File Info for _ , bfi : = range result . File { files = append ( files , bfi . Get File Info ( ) ) } return files , nil } 
func File Exists ( ds * object . Datastore , name string ) ( bool , error ) { files , err : = Search Datastore ( ds , name ) if err ! = nil { return false , err } if len ( files ) > 1 { return false , fmt . Errorf ( " " , name , ds ) } if len ( files ) < 1 { return false , nil } return path . Base ( name ) = = files [ 0 ] . Path , nil } 
func From Path ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . Virtual App , error ) { finder : = find . New Finder ( client . Client , false ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) if dc ! = nil { finder . Set Datacenter ( dc ) } return finder . Virtual App ( ctx , name ) } 
func From ID ( client * govmomi . Client , id string ) ( * object . Virtual App , error ) { log . Printf ( " " , id ) finder : = find . New Finder ( client . Client , false ) ref : = types . Managed Object Reference { Type : " " , Value : id , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) obj , err : = finder . Object Reference ( ctx , ref ) if err ! = nil { return nil , err } log . Printf ( " " , obj . Reference ( ) . Value ) return obj . ( * object . Virtual App ) , nil } 
func Is VApp ( client * govmomi . Client , rp string ) bool { _ , err : = From ID ( client , rp ) if err ! = nil { return false } return true } 
func Create ( rp * object . Resource Pool , name string , res Spec * types . Resource Config Spec , v Spec * types . VApp Config Spec , folder * object . Folder ) ( * object . Virtual App , error ) { log . Printf ( " " , rp . Inventory Path , name ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) nva , err : = rp . Create VApp ( ctx , name , * res Spec , * v Spec , folder ) if err ! = nil { return nil , err } return nva , nil } 
func Update ( vc * object . Virtual App , spec types . VApp Config Spec ) error { log . Printf ( " " , vc . Inventory Path ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return vc . Update Config ( ctx , spec ) } 
func Resource IDString ( d Resource IDStringer , name string ) string { id : = d . Id ( ) if id = = " " { id = " " } return fmt . Sprintf ( " " , name , id ) } 
func Slice Interfaces To Strings ( s [ ] interface { } ) [ ] string { var d [ ] string for _ , v : = range s { if o , ok : = v . ( string ) ; ok { d = append ( d , o ) } } return d } 
func Slice Strings To Interfaces ( s [ ] string ) [ ] interface { } { var d [ ] interface { } for _ , v : = range s { d = append ( d , v ) } return d } 
func Slice Interfaces To Managed Object References ( s [ ] interface { } , t string ) [ ] types . Managed Object Reference { var d [ ] types . Managed Object Reference for _ , v : = range s { d = append ( d , types . Managed Object Reference { Type : t , Value : v . ( string ) , } ) } return d } 
func Merge Schema ( dst , src map [ string ] * schema . Schema ) { for k , v : = range src { if _ , ok : = dst [ k ] ; ok { panic ( fmt . Errorf ( " " , k ) ) } dst [ k ] = v } } 
func Get String Ptr ( d * schema . Resource Data , key string ) * string { v , e : = d . Get Ok Exists ( key ) if e { return String Ptr ( v . ( string ) ) } return nil } 
func Get String ( d * schema . Resource Data , key string ) * string { return String Ptr ( d . Get ( key ) . ( string ) ) } 
func Set String Ptr ( d * schema . Resource Data , key string , val * string ) error { if val = = nil { return nil } err : = d . Set ( key , val ) return err } 
func Get Bool Ptr ( d * schema . Resource Data , key string ) * bool { v , e : = d . Get Ok Exists ( key ) if e { return Bool Ptr ( v . ( bool ) ) } return nil } 
func Get Bool ( d * schema . Resource Data , key string ) * bool { return Bool Ptr ( d . Get ( key ) . ( bool ) ) } 
func Set Bool Ptr ( d * schema . Resource Data , key string , val * bool ) error { if val = = nil { return nil } err : = d . Set ( key , val ) return err } 
func Get Bool String Ptr ( d * schema . Resource Data , key string ) ( * bool , error ) { v , ok : = d . Get Ok ( key ) if ! ok { return nil , nil } b , err : = strconv . Parse Bool ( v . ( string ) ) if err ! = nil { return nil , err } return & b , nil } 
func Set Bool String Ptr ( d * schema . Resource Data , key string , val * bool ) error { var s string if val ! = nil { s = strconv . Format Bool ( * val ) } return d . Set ( key , s ) } 
func Bool String Ptr State ( v interface { } ) string { b , err : = strconv . Parse Bool ( v . ( string ) ) if err ! = nil { return " " } return strconv . Format Bool ( b ) } 
func Validate Bool String Ptr ( ) schema . Schema Validate Func { return func ( i interface { } , k string ) ( s [ ] string , es [ ] error ) { v : = i . ( string ) if v = = " " { return } if _ , err : = strconv . Parse Bool ( v ) ; err ! = nil { es = append ( es , err ) } return } } 
func Get Int 6 4Ptr ( d * schema . Resource Data , key string ) * int 6 4 { v , e : = d . Get Ok Exists ( key ) if e { return Int 6 4Ptr ( int 6 4 ( v . ( int ) ) ) } return nil } 
func Get Int 6 4Ptr Empty Zero ( d * schema . Resource Data , key string ) * int 6 4 { i : = Get Int 6 4Ptr ( d , key ) if i ! = nil { return i } return Int 6 4Ptr ( int 6 4 ( 0 ) ) } 
func Set Int 6 4Ptr ( d * schema . Resource Data , key string , val * int 6 4 ) error { if val = = nil { return nil } err : = d . Set ( key , val ) return err } 
func Gi BTo Byte ( n interface { } ) int 6 4 { switch v : = n . ( type ) { case int : return int 6 4 ( v * int ( math . Pow ( 1 0 2 4 , 3 ) ) ) case int 3 2 : return int 6 4 ( v * int 3 2 ( math . Pow ( 1 0 2 4 , 3 ) ) ) case int 6 4 : return v * int 6 4 ( math . Pow ( 1 0 2 4 , 3 ) ) } panic ( fmt . Errorf ( " " , n ) ) } 
func GBTo Byte ( n interface { } ) int 6 4 { switch v : = n . ( type ) { case int : return int 6 4 ( v * 1 0 0 0 0 0 0 0 0 0 ) case int 3 2 : return int 6 4 ( v * 1 0 0 0 0 0 0 0 0 0 ) case int 6 4 : return v * 1 0 0 0 0 0 0 0 0 0 } panic ( fmt . Errorf ( " " , n ) ) } 
func Bool Policy ( b bool ) * types . Bool Policy { bp : = & types . Bool Policy { Value : Bool Ptr ( b ) , } return bp } 
func Get Bool Policy ( d * schema . Resource Data , key string ) * types . Bool Policy { v , e : = d . Get Ok Exists ( key ) if e { return Bool Policy ( v . ( bool ) ) } return nil } 
func Set Bool Policy ( d * schema . Resource Data , key string , val * types . Bool Policy ) error { if val = = nil { return nil } err : = d . Set ( key , val . Value ) return err } 
func String Policy ( s string ) * types . String Policy { sp : = & types . String Policy { Value : s , } return sp } 
func Get String Policy ( d * schema . Resource Data , key string ) * types . String Policy { v , e : = d . Get Ok Exists ( key ) if e { return String Policy ( v . ( string ) ) } return nil } 
func Set String Policy ( d * schema . Resource Data , key string , val * types . String Policy ) error { if val = = nil { return nil } err : = d . Set ( key , val . Value ) return err } 
func Long Policy ( n interface { } ) * types . Long Policy { lp : = & types . Long Policy { } switch v : = n . ( type ) { case int : lp . Value = int 6 4 ( v ) case int 8 : lp . Value = int 6 4 ( v ) case int 1 6 : lp . Value = int 6 4 ( v ) case int 3 2 : lp . Value = int 6 4 ( v ) case uint : lp . Value = int 6 4 ( v ) case uint 8 : lp . Value = int 6 4 ( v ) case uint 1 6 : lp . Value = int 6 4 ( v ) case uint 3 2 : lp . Value = int 6 4 ( v ) case int 6 4 : lp . Value = v default : panic ( fmt . Errorf ( " " , n ) ) } return lp } 
func Get Long Policy ( d * schema . Resource Data , key string ) * types . Long Policy { v , e : = d . Get Ok Exists ( key ) if e { return Long Policy ( v ) } return nil } 
func Set Long Policy ( d * schema . Resource Data , key string , val * types . Long Policy ) error { if val = = nil { return nil } err : = d . Set ( key , val . Value ) return err } 
func All Fields Empty ( v interface { } ) bool { if v = = nil { return true } t : = reflect . Type Of ( v ) if t . Kind ( ) ! = reflect . Struct & & ( t . Kind ( ) = = reflect . Ptr & & t . Elem ( ) . Kind ( ) ! = reflect . Struct ) { if reflect . Zero ( t ) . Interface ( ) ! = reflect . Value Of ( v ) . Interface ( ) { return false } return true } if t . Kind ( ) = = reflect . Ptr { t = t . Elem ( ) } for i : = 0 ; i < t . Num Field ( ) ; i + + { var fv reflect . Value if reflect . Value Of ( v ) . Kind ( ) = = reflect . Ptr { fv = reflect . Value Of ( v ) . Elem ( ) . Field ( i ) } else { fv = reflect . Value Of ( v ) . Elem ( ) . Field ( i ) } ft : = t . Field ( i ) . Type fz : = reflect . Zero ( ft ) switch ft . Kind ( ) { case reflect . Map , reflect . Slice : if fv . Len ( ) > 0 { return false } default : if fz . Interface ( ) ! = fv . Interface ( ) { return false } } } return true } 
func De Ref ( v interface { } ) interface { } { if v = = nil { return nil } k : = reflect . Type Of ( v ) . Kind ( ) if k ! = reflect . Ptr { return v } if reflect . Value Of ( v ) = = reflect . Zero ( reflect . Type Of ( v ) ) { } return reflect . Value Of ( v ) . Elem ( ) . Interface ( ) } 
func Normalize Value ( v interface { } ) interface { } { v = De Ref ( v ) if v = = nil { return nil } k : = reflect . Type Of ( v ) . Kind ( ) switch { case k > = reflect . Int 8 & & k < = reflect . Uint 6 4 : v = reflect . Value Of ( v ) . Convert ( reflect . Type Of ( int ( 0 ) ) ) . Interface ( ) case k = = reflect . Float 3 2 : v = reflect . Value Of ( v ) . Convert ( reflect . Type Of ( float 6 4 ( 0 ) ) ) . Interface ( ) } return v } 
func Set Batch ( d * schema . Resource Data , attrs map [ string ] interface { } ) error { for k , v : = range attrs { if err : = d . Set ( k , v ) ; err ! = nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func ( s Mo Ref Sorter ) Less ( i , j int ) bool { return s [ i ] . Value < s [ j ] . Value } 
func ( s Mo Ref Sorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] } 
func host Datastore System From Host System ID ( client * govmomi . Client , hs ID string ) ( * object . Host Datastore System , error ) { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return nil , err } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) return hs . Config Manager ( ) . Datastore System ( ctx ) } 
func available Scsi Disk ( dss * object . Host Datastore System , name string ) ( * types . Host Scsi Disk , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) disks , err : = dss . Query Available Disks For Vmfs ( ctx ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } var disk * types . Host Scsi Disk for _ , d : = range disks { if d . Canonical Name = = name { disk = & d break } } if disk = = nil { return nil , fmt . Errorf ( " " , name ) } return disk , nil } 
func disk Spec For Create ( dss * object . Host Datastore System , name string ) ( * types . Vmfs Datastore Create Spec , error ) { disk , err : = available Scsi Disk ( dss , name ) if err ! = nil { return nil , err } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) options , err : = dss . Query Vmfs Datastore Create Options ( ctx , disk . Device Path ) if err ! = nil { return nil , fmt . Errorf ( " " , name , err ) } var option * types . Vmfs Datastore Option for _ , o : = range options { if _ , ok : = o . Info . ( * types . Vmfs Datastore All Extent Option ) ; ok { option = & o break } } if option = = nil { return nil , fmt . Errorf ( " " , name ) } return option . Spec . ( * types . Vmfs Datastore Create Spec ) , nil } 
func disk Spec For Extend ( dss * object . Host Datastore System , ds * object . Datastore , name string ) ( * types . Vmfs Datastore Extend Spec , error ) { disk , err : = available Scsi Disk ( dss , name ) if err ! = nil { return nil , err } props , err : = datastore . Properties ( ds ) if err ! = nil { return nil , fmt . Errorf ( " " , ds . Reference ( ) . Value , err ) } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) options , err : = query Vmfs Datastore Extend Options ( ctx , dss , ds , disk . Device Path , true ) if err ! = nil { return nil , fmt . Errorf ( " " , name , err ) } var option * types . Vmfs Datastore Option for _ , o : = range options { if _ , ok : = o . Info . ( * types . Vmfs Datastore All Extent Option ) ; ok { option = & o break } } if option = = nil { return nil , fmt . Errorf ( " " , name , props . Summary . Name ) } return option . Spec . ( * types . Vmfs Datastore Extend Spec ) , nil } 
func remove Datastore ( s * object . Host Datastore System , ds * object . Datastore ) error { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) return s . Remove ( ctx , ds ) } 
func query Vmfs Datastore Extend Options ( ctx context . Context , s * object . Host Datastore System , ds * object . Datastore , device Path string , suppress Expand Candidates bool ) ( [ ] types . Vmfs Datastore Option , error ) { req : = types . Query Vmfs Datastore Extend Options { This : s . Reference ( ) , Datastore : ds . Reference ( ) , Device Path : device Path , Suppress Expand Candidates : & suppress Expand Candidates , } res , err : = methods . Query Vmfs Datastore Extend Options ( ctx , s . Client ( ) , & req ) if err ! = nil { return nil , err } return res . Returnval , nil } 
func extend Vmfs Datastore ( ctx context . Context , s * object . Host Datastore System , ds * object . Datastore , spec types . Vmfs Datastore Extend Spec ) ( * object . Datastore , error ) { req : = types . Extend Vmfs Datastore { This : s . Reference ( ) , Datastore : ds . Reference ( ) , Spec : spec , } res , err : = methods . Extend Vmfs Datastore ( ctx , s . Client ( ) , & req ) if err ! = nil { return nil , err } return object . New Datastore ( s . Client ( ) , res . Returnval ) , nil } 
func resource VSphere Compute Cluster Import Set Defaults ( d * schema . Resource Data ) error { s : = resource VSphere Compute Cluster ( ) . Schema return structure . Set Batch ( d , map [ string ] interface { } { " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , " " : s [ " " ] . Default , } ) } 
func resource VSphere Compute Cluster Apply Create ( d * schema . Resource Data , meta interface { } ) ( * object . Cluster Compute Resource , error ) { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return nil , err } dc , err : = datacenter From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return cluster , nil } 
func resource VSphere Compute Cluster Process Host Update ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return err } o , n : = d . Get Change ( " " ) new Hosts , err : = resource VSphere Compute Cluster Get Host System Objects ( client , structure . Slice Interfaces To Strings ( n . ( * schema . Set ) . Difference ( o . ( * schema . Set ) ) . List ( ) ) , ) if err ! = nil { return err } old Hosts , err : = resource VSphere Compute Cluster Get Host System Objects ( client , structure . Slice Interfaces To Strings ( o . ( * schema . Set ) . Difference ( n . ( * schema . Set ) ) . List ( ) ) , ) if err ! = nil { return err } } } } return nil } 
func resource VSphere Compute Cluster Apply Tags ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource ) error { tags Client , err : = tags Client If Defined ( d , meta ) if err ! = nil { return err } return nil } log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) return process Tag Diff ( tags Client , d , cluster ) } 
func resource VSphere Compute Cluster Read Tags ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource ) error { if tags Client , _ : = meta . ( * VSphere Client ) . Tags Client ( ) ; tags Client ! = nil { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) if err : = read Tags For Resource ( tags Client , cluster , d ) ; err ! = nil { return err } } else { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) } return nil } 
func resource VSphere Compute Cluster Apply Custom Attributes ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { client : = meta . ( * VSphere Client ) . vim Client if err ! = nil { return err } if attrs Processor = = nil { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) return nil } log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) return attrs Processor . Process Diff ( cluster ) } 
func resource VSphere Compute Cluster Read Custom Attributes ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { client : = meta . ( * VSphere Client ) . vim Client props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return err } customattribute . Read From Resource ( client , props . Entity ( ) , d ) } else { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) } return nil } 
func resource VSphere Compute Cluster Get Cluster ( d structure . Resource IDStringer , meta interface { } , ) ( * object . Cluster Compute Resource , error ) { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return nil , err } return clustercomputeresource . From ID ( client , d . Id ( ) ) } 
func resource VSphere Compute Cluster Get Cluster From Path ( meta interface { } , path string , dc ID string , ) ( * object . Cluster Compute Resource , error ) { client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return nil , err } var dc * object . Datacenter if dc ID ! = " " { var err error dc , err = datacenter From ID ( client , dc ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , path , dc . Inventory Path ) } else { log . Printf ( " " , path ) } return clustercomputeresource . From Path ( client , path , dc ) } 
func resource VSphere Compute Cluster Save Datacenter ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return err } p , err : = folder . Root Path Particle Host . Split Datacenter ( cluster . Inventory Path ) if err ! = nil { return fmt . Errorf ( " " , err ) } dc , err : = get Datacenter ( client , p ) if err ! = nil { return fmt . Errorf ( " " , err ) } return d . Set ( " " , dc . Reference ( ) . Value ) } 
func resource VSphere Compute Cluster Save Name And Path ( d * schema . Resource Data , cluster * object . Cluster Compute Resource ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) , cluster . Inventory Path , ) if err : = d . Set ( " " , cluster . Name ( ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } f , err : = folder . Root Path Particle Host . Split Relative Folder ( cluster . Inventory Path ) if err ! = nil { return fmt . Errorf ( " " , cluster . Inventory Path , err ) } if err : = d . Set ( " " , folder . Normalize Path ( f ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func resource VSphere Compute Cluster Apply Name Change ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) ( * object . Cluster Compute Resource , error ) { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) , cluster . Inventory Path , ) var changed bool var err error if d . Has Change ( " " ) { if err = clustercomputeresource . Rename ( cluster , d . Get ( " " ) . ( string ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } changed = true } if changed { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) , cluster . Inventory Path , ) } return cluster , nil } 
func resource VSphere Compute Cluster Apply Folder Change ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) ( * object . Cluster Compute Resource , error ) { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) , cluster . Inventory Path , ) var changed bool var err error if d . Has Change ( " " ) { f : = d . Get ( " " ) . ( string ) client : = meta . ( * VSphere Client ) . vim Client if err = clustercomputeresource . Move To Folder ( client , cluster , f ) ; err ! = nil { return nil , fmt . Errorf ( " " , f , err ) } changed = true } if changed { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) , cluster . Inventory Path , ) } return cluster , nil } 
func resource VSphere Compute Cluster Validate Empty Cluster ( d structure . Resource IDStringer , cluster * object . Cluster Compute Resource , ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) ne , err : = clustercomputeresource . Has Children ( cluster ) if err ! = nil { return fmt . Errorf ( " " , err ) } if ne { return fmt . Errorf ( " " , cluster . Inventory Path , ) } return nil } 
func resource VSphere Compute Cluster Delete Process Force Remove Hosts ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { if ! d . Get ( " " ) . ( bool ) { return nil } client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return err } log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) hosts , err : = resource VSphere Compute Cluster Get Host System Objects ( client , structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err ! = nil { return err } if err : = clustercomputeresource . Move Hosts Out Of ( cluster , hosts , d . Get ( " " ) . ( int ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func resource VSphere Compute Cluster Apply Delete ( d structure . Resource IDStringer , cluster * object . Cluster Compute Resource ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) if err : = clustercomputeresource . Delete ( cluster ) ; err ! = nil { return err } return nil } 
func resource VSphere Compute Cluster Flatten Data ( d * schema . Resource Data , meta interface { } , cluster * object . Cluster Compute Resource , ) error { log . Printf ( " " , resource VSphere Compute Cluster IDString ( d ) ) client , err : = resource VSphere Compute Cluster Client ( meta ) if err ! = nil { return err } props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return err } } return flatten Cluster Config Spec Ex ( d , props . Configuration Ex . ( * types . Cluster Config Info Ex ) , version ) } 
func expand Cluster Config Spec Ex ( d * schema . Resource Data , version viapi . VSphere Version ) * types . Cluster Config Spec Ex { obj : = & types . Cluster Config Spec Ex { Das Config : expand Cluster Das Config Info ( d , version ) , Dpm Config : expand Cluster Dpm Config Info ( d ) , Drs Config : expand Cluster Drs Config Info ( d ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Infra Update Ha Config = expand Cluster Infra Update Ha Config Info ( d ) obj . Orchestration = expand Cluster Orchestration Info ( d ) obj . Proactive Drs Config = expand Cluster Proactive Drs Config Info ( d ) } return obj } 
func flatten Cluster Config Spec Ex ( d * schema . Resource Data , obj * types . Cluster Config Info Ex , version viapi . VSphere Version ) error { if err : = flatten Cluster Das Config Info ( d , obj . Das Config , version ) ; err ! = nil { return err } if err : = flatten Cluster Dpm Config Info ( d , obj . Dpm Config Info ) ; err ! = nil { return err } if err : = flatten Cluster Drs Config Info ( d , obj . Drs Config ) ; err ! = nil { return err } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { if err : = flatten Cluster Infra Update Ha Config Info ( d , obj . Infra Update Ha Config ) ; err ! = nil { return err } } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { if err : = flatten Cluster Orchestration Info ( d , obj . Orchestration ) ; err ! = nil { return err } } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { return flatten Cluster Proactive Drs Config Info ( d , obj . Proactive Drs Config ) } return nil } 
func expand Cluster Das Config Info ( d * schema . Resource Data , version viapi . VSphere Version ) * types . Cluster Das Config Info { obj : = & types . Cluster Das Config Info { Default Vm Settings : expand Cluster Das VMSettings ( d , version ) , Enabled : structure . Get Bool ( d , " " ) , HBDatastore Candidate Policy : d . Get ( " " ) . ( string ) , Host Monitoring : d . Get ( " " ) . ( string ) , Option : expand Resource VSphere Compute Cluster Das Advanced Options ( d ) , Vm Monitoring : d . Get ( " " ) . ( string ) , Heartbeat Datastore : structure . Slice Interfaces To Managed Object References ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " , ) , } policy : = d . Get ( " " ) . ( string ) if policy ! = cluster Admission Control Type Disabled { obj . Admission Control Enabled = structure . Bool Ptr ( true ) } else { obj . Admission Control Enabled = structure . Bool Ptr ( false ) } obj . Admission Control Policy = expand Base Cluster Das Admission Control Policy ( d , policy , version ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { obj . Vm Component Protecting = d . Get ( " " ) . ( string ) } return obj } 
func flatten Cluster Das Config Info ( d * schema . Resource Data , obj types . Cluster Das Config Info , version viapi . VSphere Version ) error { var ds IDs [ ] string for _ , v : = range obj . Heartbeat Datastore { ds IDs = append ( ds IDs , v . Value ) } err : = structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . HBDatastore Candidate Policy , " " : obj . Host Monitoring , " " : obj . Vm Monitoring , " " : ds IDs , } ) if err ! = nil { return err } if err : = flatten Cluster Das VMSettings ( d , obj . Default Vm Settings , version ) ; err ! = nil { return err } if err : = flatten Resource VSphere Compute Cluster Das Advanced Options ( d , obj . Option ) ; err ! = nil { return err } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { if err : = d . Set ( " " , obj . Vm Component Protecting ) ; err ! = nil { return err } } } return flatten Base Cluster Das Admission Control Policy ( d , obj . Admission Control Policy , version ) } 
func expand Base Cluster Das Admission Control Policy ( d * schema . Resource Data , policy string , version viapi . VSphere Version , ) types . Base Cluster Das Admission Control Policy { var obj types . Base Cluster Das Admission Control Policy switch policy { case cluster Admission Control Type Resource Percentage : obj = expand Cluster Failover Resources Admission Control Policy ( d , version ) case cluster Admission Control Type Slot Policy : obj = expand Cluster Failover Level Admission Control Policy ( d ) case cluster Admission Control Type Failover Hosts : obj = expand Cluster Failover Host Admission Control Policy ( d , version ) case cluster Admission Control Type Disabled : return nil } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Get Cluster Das Admission Control Policy ( ) . Resource Reduction To Tolerate Percent = int 3 2 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flatten Base Cluster Das Admission Control Policy ( d * schema . Resource Data , obj types . Base Cluster Das Admission Control Policy , version viapi . VSphere Version , ) error { var policy string switch t : = obj . ( type ) { case * types . Cluster Failover Resources Admission Control Policy : if err : = flatten Cluster Failover Resources Admission Control Policy ( d , t , version ) ; err ! = nil { return err } policy = cluster Admission Control Type Resource Percentage case * types . Cluster Failover Level Admission Control Policy : if err : = flatten Cluster Failover Level Admission Control Policy ( d , t ) ; err ! = nil { return err } policy = cluster Admission Control Type Slot Policy case * types . Cluster Failover Host Admission Control Policy : if err : = flatten Cluster Failover Host Admission Control Policy ( d , t , version ) ; err ! = nil { return err } policy = cluster Admission Control Type Failover Hosts default : policy = cluster Admission Control Type Disabled } return d . Set ( " " , policy ) } 
func expand Cluster Failover Resources Admission Control Policy ( d * schema . Resource Data , version viapi . VSphere Version , ) * types . Cluster Failover Resources Admission Control Policy { obj : = & types . Cluster Failover Resources Admission Control Policy { Cpu Failover Resources Percent : int 3 2 ( d . Get ( " " ) . ( int ) ) , Memory Failover Resources Percent : int 3 2 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Auto Compute Percentages = structure . Get Bool ( d , " " ) obj . Failover Level = int 3 2 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flatten Cluster Failover Resources Admission Control Policy ( d * schema . Resource Data , obj * types . Cluster Failover Resources Admission Control Policy , version viapi . VSphere Version , ) error { if err ! = nil { return err } } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Auto Compute Percentages , " " : obj . Failover Level , } ) } return nil } 
func expand Cluster Failover Level Admission Control Policy ( d * schema . Resource Data ) * types . Cluster Failover Level Admission Control Policy { obj : = & types . Cluster Failover Level Admission Control Policy { Failover Level : int 3 2 ( d . Get ( " " ) . ( int ) ) , } if d . Get ( " " ) . ( bool ) { obj . Slot Policy = & types . Cluster Fixed Size Slot Policy { Cpu : int 3 2 ( d . Get ( " " ) . ( int ) ) , Memory : int 3 2 ( d . Get ( " " ) . ( int ) ) , } } return obj } 
func flatten Cluster Failover Level Admission Control Policy ( d * schema . Resource Data , obj * types . Cluster Failover Level Admission Control Policy , ) error { if err : = d . Set ( " " , obj . Failover Level ) ; err ! = nil { return err } if obj . Slot Policy ! = nil { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Slot Policy . ( * types . Cluster Fixed Size Slot Policy ) . Cpu , " " : obj . Slot Policy . ( * types . Cluster Fixed Size Slot Policy ) . Memory , } ) } return nil } 
func expand Cluster Failover Host Admission Control Policy ( d * schema . Resource Data , version viapi . VSphere Version , ) * types . Cluster Failover Host Admission Control Policy { obj : = & types . Cluster Failover Host Admission Control Policy { Failover Hosts : structure . Slice Interfaces To Managed Object References ( d . Get ( " " ) . ( * schema . Set ) . List ( ) , " " , ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Failover Level = int 3 2 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flatten Cluster Failover Host Admission Control Policy ( d * schema . Resource Data , obj * types . Cluster Failover Host Admission Control Policy , version viapi . VSphere Version , ) error { var hs IDs [ ] string for _ , v : = range obj . Failover Hosts { hs IDs = append ( hs IDs , v . Value ) } if err : = d . Set ( " " , hs IDs ) ; err ! = nil { return err } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( " " , obj . Failover Level ) } return nil } 
func expand Cluster Das VMSettings ( d * schema . Resource Data , version viapi . VSphere Version ) * types . Cluster Das Vm Settings { obj : = & types . Cluster Das Vm Settings { Isolation Response : d . Get ( " " ) . ( string ) , Restart Priority : d . Get ( " " ) . ( string ) , Vm Tools Monitoring Settings : expand Cluster VMTools Monitoring Settings ( d ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { obj . Vm Component Protection Settings = expand Cluster VMComponent Protection Settings ( d ) } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Restart Priority Timeout = int 3 2 ( d . Get ( " " ) . ( int ) ) } return obj } 
func flatten Cluster Das VMSettings ( d * schema . Resource Data , obj * types . Cluster Das Vm Settings , version viapi . VSphere Version ) error { err : = structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Isolation Response , " " : obj . Restart Priority , } ) if err ! = nil { return err } if err : = flatten Cluster VMTools Monitoring Settings ( d , obj . Vm Tools Monitoring Settings ) ; err ! = nil { return err } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { if err : = flatten Cluster VMComponent Protection Settings ( d , obj . Vm Component Protection Settings ) ; err ! = nil { return err } } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { return d . Set ( " " , obj . Restart Priority Timeout ) } return nil } 
func expand Cluster VMComponent Protection Settings ( d * schema . Resource Data ) * types . Cluster Vm Component Protection Settings { obj : = & types . Cluster Vm Component Protection Settings { Vm Reaction On APDCleared : d . Get ( " " ) . ( string ) , Vm Storage Protection For APD : d . Get ( " " ) . ( string ) , Vm Storage Protection For PDL : d . Get ( " " ) . ( string ) , Vm Terminate Delay For APDSec : int 3 2 ( d . Get ( " " ) . ( int ) ) , } if d . Get ( " " ) . ( string ) ! = string ( types . Cluster Vm Component Protection Settings Storage Vm Reaction Disabled ) { } return obj } 
func flatten Cluster VMComponent Protection Settings ( d * schema . Resource Data , obj * types . Cluster Vm Component Protection Settings ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Vm Reaction On APDCleared , " " : obj . Vm Storage Protection For APD , " " : obj . Vm Storage Protection For PDL , " " : obj . Vm Terminate Delay For APDSec , } ) } 
func expand Cluster VMTools Monitoring Settings ( d * schema . Resource Data ) * types . Cluster Vm Tools Monitoring Settings { obj : = & types . Cluster Vm Tools Monitoring Settings { Failure Interval : int 3 2 ( d . Get ( " " ) . ( int ) ) , Max Failures : int 3 2 ( d . Get ( " " ) . ( int ) ) , Max Failure Window : int 3 2 ( d . Get ( " " ) . ( int ) ) , Min Up Time : int 3 2 ( d . Get ( " " ) . ( int ) ) , Vm Monitoring : d . Get ( " " ) . ( string ) , } return obj } 
func flatten Cluster VMTools Monitoring Settings ( d * schema . Resource Data , obj * types . Cluster Vm Tools Monitoring Settings ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Failure Interval , " " : obj . Max Failures , " " : obj . Max Failure Window , " " : obj . Min Up Time , " " : obj . Vm Monitoring , } ) } 
func expand Cluster Dpm Config Info ( d * schema . Resource Data ) * types . Cluster Dpm Config Info { obj : = & types . Cluster Dpm Config Info { Default Dpm Behavior : types . Dpm Behavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . Get Bool ( d , " " ) , Host Power Action Rate : int 3 2 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flatten Cluster Dpm Config Info ( d * schema . Resource Data , obj * types . Cluster Dpm Config Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Default Dpm Behavior , " " : obj . Enabled , " " : obj . Host Power Action Rate , } ) } 
func expand Cluster Drs Config Info ( d * schema . Resource Data ) * types . Cluster Drs Config Info { obj : = & types . Cluster Drs Config Info { Default Vm Behavior : types . Drs Behavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . Get Bool ( d , " " ) , Enable Vm Behavior Overrides : structure . Get Bool ( d , " " ) , Vmotion Rate : int 3 2 ( d . Get ( " " ) . ( int ) ) , Option : expand Resource VSphere Compute Cluster Drs Advanced Options ( d ) , } return obj } 
func flatten Cluster Drs Config Info ( d * schema . Resource Data , obj types . Cluster Drs Config Info ) error { err : = structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Default Vm Behavior , " " : obj . Enabled , " " : obj . Enable Vm Behavior Overrides , " " : obj . Vmotion Rate , } ) if err ! = nil { return err } return flatten Resource VSphere Compute Cluster Drs Advanced Options ( d , obj . Option ) } 
func expand Resource VSphere Compute Cluster Drs Advanced Options ( d * schema . Resource Data ) [ ] types . Base Option Value { var opts [ ] types . Base Option Value m : = d . Get ( " " ) . ( map [ string ] interface { } ) for k , v : = range m { opts = append ( opts , & types . Option Value { Key : k , Value : types . Any Type ( v ) , } ) } return opts } 
func expand Cluster Infra Update Ha Config Info ( d * schema . Resource Data ) * types . Cluster Infra Update Ha Config Info { obj : = & types . Cluster Infra Update Ha Config Info { Behavior : d . Get ( " " ) . ( string ) , Enabled : structure . Get Bool ( d , " " ) , Moderate Remediation : d . Get ( " " ) . ( string ) , Providers : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , Severe Remediation : d . Get ( " " ) . ( string ) , } return obj } 
func flatten Cluster Infra Update Ha Config Info ( d * schema . Resource Data , obj * types . Cluster Infra Update Ha Config Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , " " : obj . Moderate Remediation , " " : obj . Providers , " " : obj . Severe Remediation , } ) } 
func expand Cluster Orchestration Info ( d * schema . Resource Data ) * types . Cluster Orchestration Info { obj : = & types . Cluster Orchestration Info { Default Vm Readiness : & types . Cluster Vm Readiness { Post Ready Delay : int 3 2 ( d . Get ( " " ) . ( int ) ) , Ready Condition : d . Get ( " " ) . ( string ) , } , } return obj } 
func flatten Cluster Orchestration Info ( d * schema . Resource Data , obj * types . Cluster Orchestration Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Default Vm Readiness . Post Ready Delay , " " : obj . Default Vm Readiness . Ready Condition , } ) } 
func expand Cluster Proactive Drs Config Info ( d * schema . Resource Data ) * types . Cluster Proactive Drs Config Info { obj : = & types . Cluster Proactive Drs Config Info { Enabled : structure . Get Bool ( d , " " ) , } return obj } 
func flatten Cluster Proactive Drs Config Info ( d * schema . Resource Data , obj * types . Cluster Proactive Drs Config Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Enabled , } ) } 
func resource VSphere Compute Cluster Has Cluster Config Change ( d * schema . Resource Data ) bool { for k : = range resource VSphere Compute Cluster ( ) . Schema { switch { case resource VSphere Compute Cluster Has Cluster Config Change Excluded ( k ) : continue case d . Has Change ( k ) : return true } } return false } 
func Properties ( pod * object . Storage Pod ) ( * mo . Storage Pod , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Storage Pod if err : = pod . Properties ( ctx , pod . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Create ( f * object . Folder , name string ) ( * object . Storage Pod , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , name ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) pod , err : = f . Create Storage Pod ( ctx , name ) if err ! = nil { return nil , err } return pod , nil } 
func Apply DRSConfiguration ( client * govmomi . Client , pod * object . Storage Pod , spec types . Storage Drs Config Spec ) error { log . Printf ( " " , pod . Inventory Path ) mgr : = object . New Storage Resource Manager ( client . Client ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = mgr . Configure Storage Drs For Pod ( ctx , pod , spec , true ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func Rename ( pod * object . Storage Pod , name string ) error { log . Printf ( " " , pod . Inventory Path , name ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = pod . Rename ( ctx , name ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func Move To Folder ( client * govmomi . Client , pod * object . Storage Pod , relative string ) error { f , err : = folder . Datastore Folder From Object ( client , pod , relative ) if err ! = nil { return err } return folder . Move Object To ( pod . Reference ( ) , f ) } 
func Has Children ( pod * object . Storage Pod ) ( bool , error ) { return folder . Has Children ( pod . Folder ) } 
func Storage DRSEnabled ( pod * object . Storage Pod ) ( bool , error ) { props , err : = Properties ( pod ) if err ! = nil { return false , err } if props . Pod Storage Drs Entry = = nil { return false , nil } return props . Pod Storage Drs Entry . Storage Drs Config . Pod Config . Enabled , nil } 
func Create VM ( client * govmomi . Client , fo * object . Folder , spec types . Virtual Machine Config Spec , pool * object . Resource Pool , host * object . Host System , pod * object . Storage Pod , ) ( * object . Virtual Machine , error ) { sdrs Enabled , err : = Storage DRSEnabled ( pod ) if err ! = nil { return nil , err } if ! sdrs Enabled { return nil , fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , fmt . Sprintf ( " " , fo . Inventory Path , spec . Name ) , pod . Name ( ) , ) sps : = types . Storage Placement Spec { Type : string ( types . Storage Placement Spec Placement Type Create ) , Resource Pool : types . New Reference ( pool . Reference ( ) ) , Pod Selection Spec : types . Storage Drs Pod Selection Spec { Storage Pod : types . New Reference ( pod . Reference ( ) ) , Initial Vm Config : expand VMPod Config For Placement ( spec . Device Change , pod ) , } , Config Spec : & spec , Folder : types . New Reference ( fo . Reference ( ) ) , } if host ! = nil { sps . Host = types . New Reference ( host . Reference ( ) ) } placement , err : = recommend SDRS ( client , sps , provider . Default APITimeout ) if err ! = nil { return nil , err } switch { case viapi . Is Managed Object Not Found Error ( err ) : default : return nil , err } } return apply SDRS ( client , placement , provider . Default APITimeout ) } 
func Clone VM ( client * govmomi . Client , src * object . Virtual Machine , fo * object . Folder , name string , spec types . Virtual Machine Clone Spec , timeout int , pod * object . Storage Pod , ) ( * object . Virtual Machine , error ) { sdrs Enabled , err : = Storage DRSEnabled ( pod ) if err ! = nil { return nil , err } if ! sdrs Enabled { return nil , fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , src . Inventory Path , fmt . Sprintf ( " " , fo . Inventory Path , name ) , pod . Name ( ) , ) sps : = types . Storage Placement Spec { Folder : types . New Reference ( fo . Reference ( ) ) , Vm : types . New Reference ( src . Reference ( ) ) , Clone Name : name , Clone Spec : & spec , Pod Selection Spec : types . Storage Drs Pod Selection Spec { Storage Pod : types . New Reference ( pod . Reference ( ) ) , } , Type : string ( types . Storage Placement Spec Placement Type Clone ) , } return recommend And Apply SDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) } 
func Reconfigure VM ( client * govmomi . Client , vm * object . Virtual Machine , spec types . Virtual Machine Config Spec , pod * object . Storage Pod , ) error { sdrs Enabled , err : = Storage DRSEnabled ( pod ) if err ! = nil { return err } if ! sdrs Enabled { return fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , vm . Inventory Path , pod . Name ( ) , ) sps : = types . Storage Placement Spec { Type : string ( types . Storage Placement Spec Placement Type Reconfigure ) , Pod Selection Spec : types . Storage Drs Pod Selection Spec { Initial Vm Config : expand VMPod Config For Placement ( spec . Device Change , pod ) , } , Vm : types . New Reference ( vm . Reference ( ) ) , Config Spec : & spec , } _ , err = recommend And Apply SDRS ( client , sps , provider . Default APITimeout ) return err } 
func Relocate VM ( client * govmomi . Client , vm * object . Virtual Machine , spec types . Virtual Machine Relocate Spec , timeout int , pod * object . Storage Pod , ) error { sdrs Enabled , err : = Storage DRSEnabled ( pod ) if err ! = nil { return err } if ! sdrs Enabled { return fmt . Errorf ( " " , pod . Name ( ) ) } log . Printf ( " " , vm . Inventory Path , pod . Name ( ) , ) sps : = types . Storage Placement Spec { Vm : types . New Reference ( vm . Reference ( ) ) , Pod Selection Spec : types . Storage Drs Pod Selection Spec { Storage Pod : types . New Reference ( pod . Reference ( ) ) , } , Priority : types . Virtual Machine Move Priority Default Priority , Relocate Spec : & spec , Type : string ( types . Storage Placement Spec Placement Type Relocate ) , } _ , err = recommend And Apply SDRS ( client , sps , time . Minute * time . Duration ( timeout ) ) return err } 
func Has Disk Creation Operations ( dc [ ] types . Base Virtual Device Config Spec ) bool { for _ , device Config Spec : = range dc { if _ , ok : = virtual Disk From Device Config Spec For Placement ( device Config Spec ) ; ok { return true } } return false } 
func Is Member ( pod * object . Storage Pod , ds * object . Datastore ) ( bool , error ) { dprops , err : = datastore . Properties ( ds ) if err ! = nil { return false , fmt . Errorf ( " " , ds . Name ( ) , err ) } if dprops . Parent = = nil { return false , nil } if * dprops . Parent ! = pod . Reference ( ) { return false , nil } return true , nil } 
func ( c * VSphere Client ) Tags Client ( ) ( * tags . Rest Client , error ) { if err : = viapi . Validate Virtual Center ( c . vim Client ) ; err ! = nil { return nil , err } if c . tags Client = = nil { return nil , fmt . Errorf ( " " , tags Min Version ) } return c . tags Client , nil } 
func New Config ( d * schema . Resource Data ) ( * Config , error ) { if server = = " " { server = d . Get ( " " ) . ( string ) } if server = = " " { return nil , fmt . Errorf ( " " ) } c : = & Config { User : d . Get ( " " ) . ( string ) , Password : d . Get ( " " ) . ( string ) , Insecure Flag : d . Get ( " " ) . ( bool ) , VSphere Server : server , Debug : d . Get ( " " ) . ( bool ) , Debug Path Run : d . Get ( " " ) . ( string ) , Debug Path : d . Get ( " " ) . ( string ) , Persist : d . Get ( " " ) . ( bool ) , Vim Session Path : d . Get ( " " ) . ( string ) , Rest Session Path : d . Get ( " " ) . ( string ) , } return c , nil } 
func ( c * Config ) vim URL ( ) ( * url . URL , error ) { u , err : = url . Parse ( " " + c . VSphere Server + " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } u . User = url . User Password ( c . User , c . Password ) return u , nil } 
func ( c * Config ) Client ( ) ( * VSphere Client , error ) { client : = new ( VSphere Client ) u , err : = c . vim URL ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } err = c . Enable Debug ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , err } log . Printf ( " " , c . VSphere Server ) if is Eligible Tag Endpoint ( client . vim Client ) { if err ! = nil { return nil , err } log . Println ( " " ) } else { } } if err : = c . Save Rest Client ( client . tags Client ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return client , nil } 
func ( c * Config ) Enable Debug ( ) error { if ! c . Debug { return nil } if r = = " " { r = filepath . Join ( os . Getenv ( " " ) , " " ) } r = filepath . Join ( r , " " ) if run = = " " { now : = time . Now ( ) . Format ( " " ) r = filepath . Join ( r , now ) } else { _ = os . Remove All ( r ) } err : = os . Mkdir All ( r , 0 7 0 0 ) if err ! = nil { log . Printf ( " " , err ) return err } p : = debug . File Provider { Path : r , } debug . Set Provider ( & p ) return nil } 
func ( c * Config ) session File ( ) ( string , error ) { u , err : = c . vim URLWithout Password ( ) if err ! = nil { return " " , err } name : = fmt . Sprintf ( " " , sha 1 . Sum ( [ ] byte ( key ) ) ) return name , nil } 
func ( c * Config ) vim Session File ( ) ( string , error ) { p , err : = c . session File ( ) if err ! = nil { return " " , err } return filepath . Join ( c . Vim Session Path , p ) , nil } 
func ( c * Config ) rest Session File ( ) ( string , error ) { p , err : = c . session File ( ) if err ! = nil { return " " , err } return filepath . Join ( c . Rest Session Path , p ) , nil } 
func ( c * Config ) Save Vim Client ( client * govmomi . Client ) error { if ! c . Persist { return nil } p , err : = c . vim Session File ( ) if err ! = nil { return err } log . Printf ( " " , p ) err = os . Mkdir All ( filepath . Dir ( p ) , 0 7 0 0 ) if err ! = nil { return err } f , err : = os . Open File ( p , os . O _CREATE | os . O _WRONLY , 0 6 0 0 ) if err ! = nil { return err } defer func ( ) { if err = f . Close ( ) ; err ! = nil { log . Printf ( " " , p , err ) } } ( ) err = json . New Encoder ( f ) . Encode ( client . Client ) if err ! = nil { return err } return nil } 
func ( c * Config ) Save Rest Client ( client * tags . Rest Client ) error { if ! c . Persist { return nil } p , err : = c . rest Session File ( ) if err ! = nil { return err } log . Printf ( " " , p ) err = os . Mkdir All ( filepath . Dir ( p ) , 0 7 0 0 ) if err ! = nil { return err } err = ioutil . Write File ( p , [ ] byte ( client . Session ID ( ) ) , 0 6 0 0 ) if err ! = nil { return err } return nil } 
func ( c * Config ) restore Vim Client ( client * vim 2 5 . Client ) ( bool , error ) { if ! c . Persist { return false , nil } p , err : = c . vim Session File ( ) if err ! = nil { return false , err } log . Printf ( " " , p ) f , err : = os . Open ( p ) if err ! = nil { if os . Is Not Exist ( err ) { log . Printf ( " " , p ) return false , nil } return false , err } defer func ( ) { if err = f . Close ( ) ; err ! = nil { log . Printf ( " " , p , err ) } } ( ) dec : = json . New Decoder ( f ) err = dec . Decode ( client ) if err ! = nil { return false , err } return true , nil } 
func ( c * Config ) read Rest Session ID ( ) ( string , error ) { if ! c . Persist { return " " , nil } p , err : = c . rest Session File ( ) if err ! = nil { return " " , err } log . Printf ( " " , p ) id , err : = ioutil . Read File ( p ) if err ! = nil { if os . Is Not Exist ( err ) { log . Printf ( " " , p ) return " " , nil } return " " , err } return string ( id ) , nil } 
func ( c * Config ) Load Vim Client ( ) ( * govmomi . Client , error ) { client : = new ( vim 2 5 . Client ) ok , err : = c . restore Vim Client ( client ) if err ! = nil { return nil , err } if ! ok | | ! client . Valid ( ) { log . Println ( " " ) return nil , nil } m : = session . New Manager ( client ) u , err : = m . User Session ( context . TODO ( ) ) if err ! = nil { if soap . Is Soap Fault ( err ) { fault : = soap . To Soap Fault ( err ) . Vim Fault ( ) return nil , nil } } return nil , err } return nil , nil } log . Println ( " " ) return & govmomi . Client { Client : client , Session Manager : m , } , nil } 
func ( c * Config ) Load Rest Client ( ctx context . Context , u * url . URL ) ( * tags . Rest Client , bool , error ) { id , err : = c . read Rest Session ID ( ) if err ! = nil { return nil , false , err } client : = tags . New Client With Session ID ( u , c . Insecure Flag , " " , id ) if id = = " " { log . Println ( " " ) return client , false , nil } if ! client . Valid ( ctx ) { log . Println ( " " ) return client , false , nil } log . Println ( " " ) return client , true , nil } 
func ( c * Config ) Saved Vim Session Or New ( u * url . URL ) ( * govmomi . Client , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) client , err : = c . Load Vim Client ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if client = = nil { log . Printf ( " " , c . VSphere Server ) client , err = govmomi . New Client ( ctx , u , c . Insecure Flag ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Println ( " " ) } return client , nil } 
func ( c * Config ) Saved Rest Session Or New ( u * url . URL ) ( * tags . Rest Client , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) client , valid , err : = c . Load Rest Client ( ctx , u ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if ! valid { log . Printf ( " " , c . VSphere Server ) if err : = client . Login ( ctx ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Println ( " " ) } return client , nil } 
func new Virtual Machine Customization Waiter ( client * govmomi . Client , vm * object . Virtual Machine , timeout int ) * virtual Machine Customization Waiter { w : = & virtual Machine Customization Waiter { done : make ( chan struct { } ) , } go func ( ) { w . err = w . wait ( client , vm , timeout ) close ( w . done ) } ( ) return w } 
func ( w * virtual Machine Customization Waiter ) wait ( client * govmomi . Client , vm * object . Virtual Machine , timeout int ) error { } cb : = func ( obj types . Managed Object Reference , page [ ] types . Base Event ) error { for _ , be : = range page { switch e : = be . ( type ) { case types . Base Customization Failed : cb Err < - errors . New ( e . Get Customization Failed ( ) . Get Event ( ) . Full Formatted Message ) case * types . Customization Succeeded : close ( cb Err ) } } return nil } mgr : = event . New Manager ( client . Client ) mgr Err : = make ( chan error , 1 ) defer pcancel ( ) go func ( ) { mgr Err < - mgr . Events ( pctx , [ ] types . Managed Object Reference { vm . Reference ( ) } , 1 0 , true , false , cb ) } ( ) defer cancel ( ) var err error select { case < - ctx . Done ( ) : if ctx . Err ( ) = = context . Deadline Exceeded { err = fmt . Errorf ( " " ) } case err = < - mgr Err : case err = < - cb Err : } return err } 
func select Events For Reference ( client * govmomi . Client , ref types . Managed Object Reference , event Types [ ] string ) ( [ ] types . Base Event , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) filter : = types . Event Filter Spec { Entity : & types . Event Filter Spec By Entity { Entity : ref , Recursion : types . Event Filter Spec Recursion Option All , } , Event Type Id : event Types , } mgr : = event . New Manager ( client . Client ) return mgr . Query Events ( ctx , filter ) } 
func get Datastore ( f * find . Finder , ds string ) ( * object . Datastore , error ) { if ds ! = " " { dso , err : = f . Datastore ( context . TODO ( ) , ds ) return dso , err } else { dso , err : = f . Default Datastore ( context . TODO ( ) ) return dso , err } } 
func resource VSphere Virtual Machine Update Reconfigure With SDRS ( d * schema . Resource Data , meta interface { } , vm * object . Virtual Machine , spec types . Virtual Machine Config Spec , ) error { return virtualmachine . Reconfigure ( vm , spec ) } client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) pod , err : = storagepod . From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } err = storagepod . Reconfigure VM ( client , vm , spec , pod ) if err ! = nil { return fmt . Errorf ( " " , pod . Name ( ) , err ) } return nil } 
func resource VSphere Virtual Machine Create Bare ( d * schema . Resource Data , meta interface { } ) ( * object . Virtual Machine , error ) { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client pool ID : = d . Get ( " " ) . ( string ) pool , err : = resourcepool . From ID ( client , pool ID ) if err ! = nil { return nil , fmt . Errorf ( " " , pool ID , err ) } if err ! = nil { return nil , err } var hs * object . Host System if v , ok : = d . Get Ok ( " " ) ; ok { hs ID : = v . ( string ) var err error if hs , err = hostsystem . From ID ( client , hs ID ) ; err ! = nil { return nil , fmt . Errorf ( " " , hs ID , err ) } } } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , virtualdevice . Device List String ( devices ) ) if spec . Device Change , err = apply Virtual Devices ( d , client , devices ) ; err ! = nil { return nil , err } if _ , ok : = d . Get Ok ( " " ) ; ok { vm , err = resource VSphere Virtual Machine Create Bare With SDRS ( d , meta , fo , spec , pool , hs ) } else { vm , err = resource VSphere Virtual Machine Create Bare Standard ( d , meta , fo , spec , pool , hs ) } if err ! = nil { return nil , err } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , vm . Inventory Path , vprops . Config . Uuid ) d . Set Id ( vprops . Config . Uuid ) } return vm , nil } 
func resource VSphere Virtual Machine Create Bare With SDRS ( d * schema . Resource Data , meta interface { } , fo * object . Folder , spec types . Virtual Machine Config Spec , pool * object . Resource Pool , hs * object . Host System , ) ( * object . Virtual Machine , error ) { client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) pod , err : = storagepod . From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } vm , err : = storagepod . Create VM ( client , fo , spec , pool , hs , pod ) if err ! = nil { return nil , fmt . Errorf ( " " , pod . Name ( ) , err ) } return vm , nil } 
func resource VSphere Virtual Machine Create Bare Standard ( d * schema . Resource Data , meta interface { } , fo * object . Folder , spec types . Virtual Machine Config Spec , pool * object . Resource Pool , hs * object . Host System , ) ( * object . Virtual Machine , error ) { client : = meta . ( * VSphere Client ) . vim Client if err ! = nil { return nil , fmt . Errorf ( " " , err ) } spec . Files = & types . Virtual Machine File Info { Vm Path Name : fmt . Sprintf ( " " , ds . Name ( ) ) , } vm , err : = virtualmachine . Create ( client , fo , spec , pool , hs ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return vm , nil } 
func resource VSphere Virtual Machine Create Clone ( d * schema . Resource Data , meta interface { } ) ( * object . Virtual Machine , error ) { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client pool , err : = resourcepool . From ID ( client , pool ID ) if err ! = nil { return nil , fmt . Errorf ( " " , pool ID , err ) } fo , err : = folder . Virtual Machine Folder From Object ( client , pool , d . Get ( " " ) . ( string ) ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } timeout : = d . Get ( " " ) . ( int ) var vm * object . Virtual Machine if _ , ok : = d . Get Ok ( " " ) ; ok { vm , err = resource VSphere Virtual Machine Create Clone With SDRS ( d , meta , src VM , fo , name , clone Spec , timeout ) } else { vm , err = virtualmachine . Clone ( client , src VM , fo , name , clone Spec , timeout ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } log . Printf ( " " , vm . Inventory Path , vprops . Config . Uuid ) d . Set Id ( vprops . Config . Uuid ) if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } var delta [ ] types . Base Virtual Device Config Spec if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfg Spec . Device Change = virtualdevice . Append Device Change Spec ( cfg Spec . Device Change , delta . . . ) if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfg Spec . Device Change = virtualdevice . Append Device Change Spec ( cfg Spec . Device Change , delta . . . ) if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfg Spec . Device Change = virtualdevice . Append Device Change Spec ( cfg Spec . Device Change , delta . . . ) if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } cfg Spec . Device Change = virtualdevice . Append Device Change Spec ( cfg Spec . Device Change , delta . . . ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , virtualdevice . Device List String ( devices ) ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , virtualdevice . Device Change String ( cfg Spec . Device Change ) ) } else { err = virtualmachine . Reconfigure ( vm , cfg Spec ) } if err ! = nil { return nil , resource VSphere Virtual Machine Rollback Create ( d , meta , vm , fmt . Errorf ( " " , err ) , ) } var cw * virtual Machine Customization Waiter if err ! = nil { return nil , fmt . Errorf ( " " , d . Get ( " " ) . ( string ) , err ) } cust Spec : = vmworkflow . Expand Customization Spec ( d , family ) cw = new Virtual Machine Customization Waiter ( client , vm , d . Get ( " " ) . ( int ) ) if err : = virtualmachine . Customize ( vm , cust Spec ) ; err ! = nil { } d . Set Id ( " " ) return nil , fmt . Errorf ( " " , err ) } } } < - cw . Done ( ) if err : = cw . Err ( ) ; err ! = nil { return nil , fmt . Errorf ( format Virtual Machine Customization Wait Error , vm . Inventory Path , err ) } } } 
func resource VSphere Virtual Machine Create Clone With SDRS ( d * schema . Resource Data , meta interface { } , src VM * object . Virtual Machine , fo * object . Folder , name string , spec types . Virtual Machine Clone Spec , timeout int , ) ( * object . Virtual Machine , error ) { client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) pod , err : = storagepod . From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } vm , err : = storagepod . Clone VM ( client , src VM , fo , name , spec , timeout , pod ) if err ! = nil { return nil , fmt . Errorf ( " " , pod . Name ( ) , err ) } return vm , nil } 
func resource VSphere Virtual Machine Rollback Create ( d * schema . Resource Data , meta interface { } , vm * object . Virtual Machine , orig Err error , ) error { defer d . Set Id ( " " ) } return fmt . Errorf ( " " , orig Err ) } 
func resource VSphere Virtual Machine Update Location ( d * schema . Resource Data , meta interface { } ) error { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client vm , err : = virtualmachine . From UUID ( client , id ) if err ! = nil { return fmt . Errorf ( " " , id , err ) } if err ! = nil { return fmt . Errorf ( " " , err ) } devices : = object . Virtual Device List ( vprops . Config . Hardware . Device ) relocators , disk Relocate OK , err : = virtualdevice . Disk Migrate Relocate Operation ( d , client , devices ) if err ! = nil { return err } return nil } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) pool , err : = resourcepool . From ID ( client , pool ID ) if err ! = nil { return fmt . Errorf ( " " , pool ID , err ) } var hs * object . Host System if v , ok : = d . Get Ok ( " " ) ; ok { hs ID : = v . ( string ) var err error if hs , err = hostsystem . From ID ( client , hs ID ) ; err ! = nil { return fmt . Errorf ( " " , hs ID , err ) } } if err : = resourcepool . Validate Host ( client , pool , hs ) ; err ! = nil { return err } if err ! = nil { return fmt . Errorf ( " " , err ) } spec . Datastore = types . New Reference ( ds . Reference ( ) ) } if hs ! = nil { hs Ref : = hs . Reference ( ) spec . Host = & hs Ref } spec . Disk = relocators if _ , ok : = d . Get Ok ( " " ) ; ok { err = resource VSphere Virtual Machine Update Location Relocate With SDRS ( d , meta , vm , spec , timeout ) } else { err = virtualmachine . Relocate ( vm , spec , timeout ) } return err } 
func resource VSphere Virtual Machine Update Location Relocate With SDRS ( d * schema . Resource Data , meta interface { } , vm * object . Virtual Machine , spec types . Virtual Machine Relocate Spec , timeout int , ) error { client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) pod , err : = storagepod . From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } err = storagepod . Relocate VM ( client , vm , spec , timeout , pod ) if err ! = nil { return fmt . Errorf ( " " , pod . Name ( ) , err ) } return nil } 
func apply Virtual Devices ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { var err error if err ! = nil { return nil , err } if len ( delta ) > 0 { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) d . Set ( " " , true ) } spec = virtualdevice . Append Device Change Spec ( spec , delta . . . ) if err ! = nil { return nil , err } spec = virtualdevice . Append Device Change Spec ( spec , delta . . . ) if err ! = nil { return nil , err } spec = virtualdevice . Append Device Change Spec ( spec , delta . . . ) if err ! = nil { return nil , err } spec = virtualdevice . Append Device Change Spec ( spec , delta . . . ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , virtualdevice . Device List String ( l ) ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , virtualdevice . Device Change String ( spec ) ) return spec , nil } 
func expand Cluster Dpm Host Config Info ( d * schema . Resource Data , host * object . Host System ) ( * types . Cluster Dpm Host Config Info , error ) { obj : = & types . Cluster Dpm Host Config Info { Behavior : types . Dpm Behavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . Get Bool ( d , " " ) , Key : host . Reference ( ) , } return obj , nil } 
func flatten Cluster Dpm Host Config Info ( d * schema . Resource Data , obj * types . Cluster Dpm Host Config Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , } ) } 
func resource VSphere DPMHost Override Flatten ID ( cluster * object . Cluster Compute Resource , host * object . Host System ) ( string , error ) { return strings . Join ( [ ] string { cluster . Reference ( ) . Value , host . Reference ( ) . Value } , " " ) , nil } 
func resource VSphere DPMHost Override Find Entry ( cluster * object . Cluster Compute Resource , host * object . Host System , ) ( * types . Cluster Dpm Host Config Info , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Dpm Host Config { if info . Key = = host . Reference ( ) { log . Printf ( " " , host . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , host . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resource VSphere DPMHost Override Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , * object . Host System , error ) { if d . Id ( ) ! = " " { return resource VSphere DPMHost Override Objects From ID ( d , meta ) } return resource VSphere DPMHost Override Objects From Attributes ( d , meta ) } 
func resource VSphere Virtual Disk ( ) * schema . Resource { return & schema . Resource { Create : resource VSphere Virtual Disk Create , Read : resource VSphere Virtual Disk Read , Delete : resource VSphere Virtual Disk Delete , Schema : map [ string ] * schema . Schema { if value ! = " " & & value ! = " " & & value ! = " " { errors = append ( errors , fmt . Errorf ( " " ) ) } return } , } , " " : { Type : schema . Type String , Optional : true , Force New : true , Default : " " , if value ! = " " & & value ! = " " & & value ! = " " { errors = append ( errors , fmt . Errorf ( " " ) ) } return } , } , " " : { Type : schema . Type String , Optional : true , Force New : true , } , " " : { Type : schema . Type Bool , Optional : true , Force New : true , } , } , } } 
func create Hard Disk ( client * govmomi . Client , size int , disk Path string , disk Type string , adapter Type string , dc string ) error { var v Disk Type string switch disk Type { case " " : v Disk Type = " " case " " : v Disk Type = " " case " " : v Disk Type = " " } virtual Disk Manager : = object . New Virtual Disk Manager ( client . Client ) spec : = & types . File Backed Virtual Disk Spec { Virtual Disk Spec : types . Virtual Disk Spec { Adapter Type : adapter Type , Disk Type : v Disk Type , } , Capacity Kb : int 6 4 ( 1 0 2 4 * 1 0 2 4 * size ) , } datacenter , err : = get Datacenter ( client , dc ) if err ! = nil { return err } log . Printf ( " " , spec ) task , err : = virtual Disk Manager . Create Virtual Disk ( context . TODO ( ) , disk Path , datacenter , spec ) if err ! = nil { return err } _ , err = task . Wait For Result ( context . TODO ( ) , nil ) if err ! = nil { log . Printf ( " " , err ) return err } log . Printf ( " " ) return nil } 
func search For Directory ( client * govmomi . Client , datacenter string , datastore string , directory Path string ) error { log . Printf ( " " ) finder : = find . New Finder ( client . Client , true ) dc , err : = get Datacenter ( client , datacenter ) if err ! = nil { return fmt . Errorf ( " " , datacenter , err ) } finder = finder . Set Datacenter ( dc ) ds , err : = finder . Datastore ( context . TODO ( ) , datastore ) if err ! = nil { return fmt . Errorf ( " " , datastore , err ) } ctx : = context . TODO ( ) b , err : = ds . Browser ( ctx ) if err ! = nil { return err } spec : = types . Host Datastore Browser Search Spec { Query : [ ] types . Base File Query { & types . Folder File Query { } } , Details : & types . File Query Flags { File Size : true , File Type : true , Modification : true , File Owner : types . New Bool ( true ) , } , Match Pattern : [ ] string { path . Base ( directory Path ) } , } ds Path : = ds . Path ( path . Dir ( directory Path ) ) task , err : = b . Search Datastore ( context . TODO ( ) , ds Path , & spec ) if err ! = nil { log . Printf ( " " , directory Path ) return err } info , err : = task . Wait For Result ( context . TODO ( ) , nil ) if err ! = nil { if info = = nil | | info . Error ! = nil { _ , ok : = info . Error . Fault . ( * types . File Not Found ) if ok { log . Printf ( " " , directory Path ) return nil } } log . Printf ( " " , directory Path ) return err } res : = info . Result . ( types . Host Datastore Browser Search Results ) log . Printf ( " " , len ( res . File ) ) if len ( res . File ) = = 0 { log . Printf ( " " , directory Path ) return nil } if len ( res . File ) ! = 1 { return errors . New ( " " ) } file Info : = res . File [ 0 ] log . Printf ( " " , file Info ) return nil } 
func ( p * nas Datastore Mount Processor ) diff Old New ( ) [ ] string { return p . diff ( p . old HSIDs , p . new HSIDs ) } 
func ( p * nas Datastore Mount Processor ) diff New Old ( ) [ ] string { return p . diff ( p . new HSIDs , p . old HSIDs ) } 
func ( p * nas Datastore Mount Processor ) process Mount Operations ( ) ( * object . Datastore , error ) { hosts : = p . diff New Old ( ) if len ( hosts ) < 1 { } } } for _ , hs ID : = range hosts { dss , err : = host Datastore System From Host System ID ( p . client , hs ID ) if err ! = nil { return p . ds , fmt . Errorf ( " " , hostsystem . Name Or ID ( p . client , hs ID ) , err ) } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) ds , err : = dss . Create Nas Datastore ( ctx , * p . vol Spec ) if err ! = nil { return p . ds , fmt . Errorf ( " " , hostsystem . Name Or ID ( p . client , hs ID ) , err ) } if err : = p . validate Datastore ( ds ) ; err ! = nil { return p . ds , fmt . Errorf ( " " , hostsystem . Name Or ID ( p . client , hs ID ) , err ) } } return p . ds , nil } 
func ( p * nas Datastore Mount Processor ) process Unmount Operations ( ) error { hosts : = p . diff Old New ( ) if len ( hosts ) < 1 | | p . ds = = nil { } for _ , hs ID : = range hosts { dss , err : = host Datastore System From Host System ID ( p . client , hs ID ) if err ! = nil { return fmt . Errorf ( " " , hostsystem . Name Or ID ( p . client , hs ID ) , err ) } if err : = remove Datastore ( dss , p . ds ) ; err ! = nil { return fmt . Errorf ( " " , hostsystem . Name Or ID ( p . client , hs ID ) , err ) } } return nil } 
func ( p * nas Datastore Mount Processor ) validate Datastore ( ds * object . Datastore ) error { if p . ds = = nil { p . ds = ds return nil } expected : = p . ds . Reference ( ) . Value actual : = ds . Reference ( ) . Value if expected ! = actual { return fmt . Errorf ( " " , expected , actual ) } return nil } 
func is Eligible Tag Endpoint ( client * govmomi . Client ) bool { if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return false } client Ver : = viapi . Parse Version From Client ( client ) if ! client Ver . Product Equal ( tags Min Version ) | | client Ver . Older ( tags Min Version ) { return false } return true } 
func tag Category By Name ( client * tags . Rest Client , name string ) ( string , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) cats , err : = client . Get Categories By Name ( ctx , name ) if err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( cats ) < 1 { return " " , fmt . Errorf ( " " , name ) } if len ( cats ) > 1 { } return cats [ 0 ] . ID , nil } 
func tag By Name ( client * tags . Rest Client , name , category ID string ) ( string , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) tags , err : = client . Get Tag By Name For Category ( ctx , name , category ID ) if err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( tags ) < 1 { return " " , fmt . Errorf ( " " , name , category ID ) } if len ( tags ) > 1 { } return tags [ 0 ] . ID , nil } 
func tags Schema ( ) * schema . Schema { return & schema . Schema { Type : schema . Type Set , Description : " " , Optional : true , Elem : & schema . Schema { Type : schema . Type String } , } } 
func tag Type For Object ( obj object . Reference ) ( string , error ) { switch obj . ( type ) { case * object . Virtual Machine : return v Sphere Tag Type Virtual Machine , nil case * object . Datastore : return v Sphere Tag Type Datastore , nil case * object . Network : return v Sphere Tag Type Network , nil case * object . Folder : return v Sphere Tag Type Folder , nil case * object . Vmware Distributed Virtual Switch : return v Sphere Tag Type Vmware Distributed Virtual Switch , nil case * object . Distributed Virtual Switch : return v Sphere Tag Type Distributed Virtual Switch , nil case * object . Distributed Virtual Portgroup : return v Sphere Tag Type Distributed Virtual Portgroup , nil case * object . Datacenter : return v Sphere Tag Type Datacenter , nil case * object . Cluster Compute Resource : return v Sphere Tag Type Cluster Compute Resource , nil case * object . Host System : return v Sphere Tag Type Host System , nil case * object . Storage Pod : return v Sphere Tag Type Storage Pod , nil case * object . Resource Pool : return v Sphere Tag Type Resource Pool , nil case * object . Virtual App : return v Sphere Tag Type Virtual App , nil } return " " , fmt . Errorf ( " " , obj ) } 
func read Tags For Resource ( client * tags . Rest Client , obj object . Reference , d * schema . Resource Data ) error { log . Printf ( " " , obj . Reference ( ) . Value ) obj ID : = obj . Reference ( ) . Value obj Type , err : = tag Type For Object ( obj ) if err ! = nil { return err } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) ids , err : = client . List Attached Tags ( ctx , obj ID , obj Type ) log . Printf ( " " , obj ID , strings . Join ( ids , " " ) ) if err ! = nil { return err } if err : = d . Set ( v Sphere Tag Attribute Key , ids ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * tag Diff Processor ) diff Old New ( ) [ ] string { return p . diff ( p . old Tag IDs , p . new Tag IDs ) } 
func ( p * tag Diff Processor ) diff New Old ( ) [ ] string { return p . diff ( p . new Tag IDs , p . old Tag IDs ) } 
func ( p * tag Diff Processor ) diff ( a , b [ ] string ) [ ] string { var found bool c : = make ( [ ] string , 0 ) for _ , v 1 : = range a { for _ , v 2 : = range b { if v 1 = = v 2 { found = true } } if ! found { c = append ( c , v 1 ) } found = false } return c } 
func ( p * tag Diff Processor ) process Attach Operations ( ) error { tag IDs : = p . diff New Old ( ) if len ( tag IDs ) < 1 { } for _ , tag ID : = range tag IDs { obj ID : = p . subject . Reference ( ) . Value obj Type , err : = tag Type For Object ( p . subject ) if err ! = nil { return err } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) log . Printf ( " " , tag ID , obj ID ) if err : = p . client . Attach Tag To Object ( ctx , tag ID , obj ID , obj Type ) ; err ! = nil { return err } } return nil } 
func tags Client If Defined ( d * schema . Resource Data , meta interface { } ) ( * tags . Rest Client , error ) { old , new : = d . Get Change ( v Sphere Tag Attribute Key ) if len ( old . ( * schema . Set ) . List ( ) ) > 0 | | len ( new . ( * schema . Set ) . List ( ) ) > 0 { log . Printf ( " " ) client , err : = meta . ( * VSphere Client ) . Tags Client ( ) if err ! = nil { return nil , err } return client , nil } log . Printf ( " " ) return nil , nil } 
func process Tag Diff ( client * tags . Rest Client , d * schema . Resource Data , obj object . Reference ) error { log . Printf ( " " , obj . Reference ( ) . Value ) old , new : = d . Get Change ( v Sphere Tag Attribute Key ) tdp : = & tag Diff Processor { client : client , subject : obj , old Tag IDs : structure . Slice Interfaces To Strings ( old . ( * schema . Set ) . List ( ) ) , new Tag IDs : structure . Slice Interfaces To Strings ( new . ( * schema . Set ) . List ( ) ) , } if err : = tdp . process Detach Operations ( ) ; err ! = nil { return fmt . Errorf ( " " , obj . Reference ( ) . Value , err ) } if err : = tdp . process Attach Operations ( ) ; err ! = nil { return fmt . Errorf ( " " , obj . Reference ( ) . Value , err ) } return nil } 
func schema VMware DVSConfig Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema VMware DVSPort Setting ( ) ) structure . Merge Schema ( s , schema Dvs Host Infrastructure Traffic Resource ( ) ) return s } 
func expand DVSContact Info ( d * schema . Resource Data ) * types . DVSContact Info { obj : = & types . DVSContact Info { Name : d . Get ( " " ) . ( string ) , Contact : d . Get ( " " ) . ( string ) , } return obj } 
func flatten DVSContact Info ( d * schema . Resource Data , obj types . DVSContact Info ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . Contact ) return nil } 
func expand Distributed Virtual Switch Host Member Config Spec ( d map [ string ] interface { } ) types . Distributed Virtual Switch Host Member Config Spec { host Ref : = & types . Managed Object Reference { Type : " " , Value : d [ " " ] . ( string ) , } var pn Specs [ ] types . Distributed Virtual Switch Host Member Pnic Spec nics : = structure . Slice Interfaces To Strings ( d [ " " ] . ( [ ] interface { } ) ) for _ , nic : = range nics { pn Spec : = types . Distributed Virtual Switch Host Member Pnic Spec { Pnic Device : nic , } pn Specs = append ( pn Specs , pn Spec ) } backing : = types . Distributed Virtual Switch Host Member Pnic Backing { Pnic Spec : pn Specs , } obj : = types . Distributed Virtual Switch Host Member Config Spec { Host : * host Ref , Backing : & backing , } return obj } 
func flatten Distributed Virtual Switch Host Member ( obj types . Distributed Virtual Switch Host Member ) map [ string ] interface { } { d : = make ( map [ string ] interface { } ) d [ " " ] = obj . Config . Host . Value var devices [ ] string backing : = obj . Config . Backing . ( * types . Distributed Virtual Switch Host Member Pnic Backing ) for _ , spec : = range backing . Pnic Spec { devices = append ( devices , spec . Pnic Device ) } d [ " " ] = devices return d } 
func expand Slice Of Distributed Virtual Switch Host Member Config Spec ( d * schema . Resource Data ) [ ] types . Distributed Virtual Switch Host Member Config Spec { var specs [ ] types . Distributed Virtual Switch Host Member Config Spec o , n : = d . Get Change ( " " ) os : = o . ( * schema . Set ) ns : = n . ( * schema . Set ) os = os . Difference ( is ) ns = ns . Difference ( is ) var found bool for _ , ne : = range ns . List ( ) { nm : = ne . ( map [ string ] interface { } ) if nm [ " " ] = = om [ " " ] { found = true } } if ! found { spec : = expand Distributed Virtual Switch Host Member Config Spec ( om ) spec . Operation = string ( types . Config Spec Operation Remove ) specs = append ( specs , spec ) } } var found bool for _ , oe : = range os . List ( ) { om : = oe . ( map [ string ] interface { } ) if om [ " " ] = = nm [ " " ] { found = true } } spec : = expand Distributed Virtual Switch Host Member Config Spec ( nm ) if ! found { spec . Operation = string ( types . Config Spec Operation Add ) } else { spec . Operation = string ( types . Config Spec Operation Edit ) } specs = append ( specs , spec ) } } 
func flatten Slice Of Distributed Virtual Switch Host Member ( d * schema . Resource Data , members [ ] types . Distributed Virtual Switch Host Member ) error { var hosts [ ] map [ string ] interface { } for _ , m : = range members { hosts = append ( hosts , flatten Distributed Virtual Switch Host Member ( m ) ) } if err : = d . Set ( " " , hosts ) ; err ! = nil { return err } return nil } 
func expand VMware Ipfix Config ( d * schema . Resource Data ) * types . VMware Ipfix Config { obj : = & types . VMware Ipfix Config { Active Flow Timeout : int 3 2 ( d . Get ( " " ) . ( int ) ) , Collector Ip Address : d . Get ( " " ) . ( string ) , Collector Port : int 3 2 ( d . Get ( " " ) . ( int ) ) , Idle Flow Timeout : int 3 2 ( d . Get ( " " ) . ( int ) ) , Internal Flows Only : d . Get ( " " ) . ( bool ) , Observation Domain Id : int 6 4 ( d . Get ( " " ) . ( int ) ) , Sampling Rate : int 3 2 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flatten VMware Ipfix Config ( d * schema . Resource Data , obj * types . VMware Ipfix Config ) error { d . Set ( " " , obj . Active Flow Timeout ) d . Set ( " " , obj . Collector Ip Address ) d . Set ( " " , obj . Collector Port ) d . Set ( " " , obj . Idle Flow Timeout ) d . Set ( " " , obj . Internal Flows Only ) d . Set ( " " , obj . Observation Domain Id ) d . Set ( " " , obj . Sampling Rate ) return nil } 
func schema Dvs Host Infrastructure Traffic Resource ( ) map [ string ] * schema . Schema { s : = make ( map [ string ] * schema . Schema ) share Level Fmt : = " " share Count Fmt : = " " max Mbit Fmt : = " " res Mbit Fmt : = " " for _ , class : = range infrastructure Traffic Class Values { share Level Key : = fmt . Sprintf ( " " , strings . To Lower ( class ) ) share Count Key : = fmt . Sprintf ( " " , strings . To Lower ( class ) ) max Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( class ) ) res Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( class ) ) s [ share Level Key ] = & schema . Schema { Type : schema . Type String , Optional : true , Computed : true , Description : fmt . Sprintf ( share Level Fmt , class ) , Validate Func : validation . String In Slice ( shares Level Allowed Values , false ) , } s [ share Count Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Computed : true , Description : fmt . Sprintf ( share Count Fmt , class ) , Validate Func : validation . Int At Least ( 0 ) , } s [ max Mbit Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Computed : true , Description : fmt . Sprintf ( max Mbit Fmt , class ) , Validate Func : validation . Int At Least ( - 1 ) , } s [ res Mbit Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Computed : true , Description : fmt . Sprintf ( res Mbit Fmt , class ) , Validate Func : validation . Int At Least ( - 1 ) , } } return s } 
func expand Dvs Host Infrastructure Traffic Resource ( d * schema . Resource Data , key string ) * types . Dvs Host Infrastructure Traffic Resource { share Level Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) share Count Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) max Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) res Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) obj : = & types . Dvs Host Infrastructure Traffic Resource { Allocation Info : types . Dvs Host Infrastructure Traffic Resource Allocation { Limit : structure . Get Int 6 4Ptr ( d , max Mbit Key ) , Reservation : structure . Get Int 6 4Ptr ( d , res Mbit Key ) , } , } shares : = & types . Shares Info { Level : types . Shares Level ( d . Get ( share Level Key ) . ( string ) ) , Shares : int 3 2 ( d . Get ( share Count Key ) . ( int ) ) , } if ! structure . All Fields Empty ( shares ) { obj . Allocation Info . Shares = shares } if structure . All Fields Empty ( obj ) { return nil } obj . Key = key return obj } 
func flatten Dvs Host Infrastructure Traffic Resource ( d * schema . Resource Data , obj types . Dvs Host Infrastructure Traffic Resource , key string ) error { share Level Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) share Count Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) max Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) res Mbit Key : = fmt . Sprintf ( " " , strings . To Lower ( key ) ) structure . Set Int 6 4Ptr ( d , max Mbit Key , obj . Allocation Info . Limit ) structure . Set Int 6 4Ptr ( d , res Mbit Key , obj . Allocation Info . Reservation ) if obj . Allocation Info . Shares ! = nil { d . Set ( share Level Key , obj . Allocation Info . Shares . Level ) d . Set ( share Count Key , obj . Allocation Info . Shares . Shares ) } return nil } 
func expand Slice Of Dvs Host Infrastructure Traffic Resource ( d * schema . Resource Data ) [ ] types . Dvs Host Infrastructure Traffic Resource { var s [ ] types . Dvs Host Infrastructure Traffic Resource for _ , key : = range infrastructure Traffic Class Values { v : = expand Dvs Host Infrastructure Traffic Resource ( d , key ) if v ! = nil { s = append ( s , * v ) } } return s } 
func flatten Slice Of Dvs Host Infrastructure Traffic Resource ( d * schema . Resource Data , s [ ] types . Dvs Host Infrastructure Traffic Resource ) error { for _ , v : = range s { if err : = flatten Dvs Host Infrastructure Traffic Resource ( d , v , v . Key ) ; err ! = nil { return err } } return nil } 
func expand DVSName Array Uplink Port Policy ( d * schema . Resource Data ) * types . DVSName Array Uplink Port Policy { obj : = & types . DVSName Array Uplink Port Policy { Uplink Port Name : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten DVSName Array Uplink Port Policy ( d * schema . Resource Data , obj * types . DVSName Array Uplink Port Policy ) error { if err : = d . Set ( " " , obj . Uplink Port Name ) ; err ! = nil { return err } return nil } 
func expand VMware DVSConfig Spec ( d * schema . Resource Data ) * types . VMware DVSConfig Spec { obj : = & types . VMware DVSConfig Spec { DVSConfig Spec : types . DVSConfig Spec { Name : d . Get ( " " ) . ( string ) , Config Version : d . Get ( " " ) . ( string ) , Default Port Config : expand VMware DVSPort Setting ( d ) , Host : expand Slice Of Distributed Virtual Switch Host Member Config Spec ( d ) , Description : d . Get ( " " ) . ( string ) , Contact : expand DVSContact Info ( d ) , Switch Ip Address : d . Get ( " " ) . ( string ) , Infrastructure Traffic Resource Config : expand Slice Of Dvs Host Infrastructure Traffic Resource ( d ) , Network Resource Control Version : d . Get ( " " ) . ( string ) , Uplink Port Policy : expand DVSName Array Uplink Port Policy ( d ) , } , Max Mtu : int 3 2 ( d . Get ( " " ) . ( int ) ) , Link Discovery Protocol Config : expand Link Discovery Protocol Config ( d ) , Ipfix Config : expand VMware Ipfix Config ( d ) , Lacp Api Version : d . Get ( " " ) . ( string ) , Multicast Filtering Mode : d . Get ( " " ) . ( string ) , } return obj } 
func flatten VMware DVSConfig Info ( d * schema . Resource Data , obj * types . VMware DVSConfig Info ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . Config Version ) d . Set ( " " , obj . Description ) d . Set ( " " , obj . Switch Ip Address ) d . Set ( " " , obj . Max Mtu ) d . Set ( " " , obj . Lacp Api Version ) d . Set ( " " , obj . Multicast Filtering Mode ) d . Set ( " " , obj . Network Resource Control Version ) if err : = flatten DVSName Array Uplink Port Policy ( d , obj . Uplink Port Policy . ( * types . DVSName Array Uplink Port Policy ) ) ; err ! = nil { return err } if err : = flatten VMware DVSPort Setting ( d , obj . Default Port Config . ( * types . VMware DVSPort Setting ) ) ; err ! = nil { return err } if err : = flatten Slice Of Distributed Virtual Switch Host Member ( d , obj . Host ) ; err ! = nil { return err } if err : = flatten Slice Of Dvs Host Infrastructure Traffic Resource ( d , obj . Infrastructure Traffic Resource Config ) ; err ! = nil { return err } if err : = flatten DVSContact Info ( d , obj . Contact ) ; err ! = nil { return err } if err : = flatten Link Discovery Protocol Config ( d , obj . Link Discovery Protocol Config ) ; err ! = nil { return err } if err : = flatten VMware Ipfix Config ( d , obj . Ipfix Config ) ; err ! = nil { return err } return nil } 
func schema DVSCreate Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema VMware DVSConfig Spec ( ) ) return s } 
func expand DVSCreate Spec ( d * schema . Resource Data ) types . DVSCreate Spec { return obj } 
func get With Restart ( d * schema . Resource Data , key string ) interface { } { if d . Has Change ( key ) { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , key ) d . Set ( " " , true ) } return d . Get ( key ) } 
func get Bool With Restart ( d * schema . Resource Data , key string ) * bool { if d . Has Change ( key ) { d . Set ( " " , true ) } return structure . Get Bool ( d , key ) } 
func schema Virtual Machine Config Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema Virtual Machine Resource Allocation ( ) ) return s } 
func v App Subresource Schema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . Type Map , Optional : true , Description : " " , Elem : & schema . Schema { Type : schema . Type String } , } , } } 
func expand Virtual Machine Boot Options ( d * schema . Resource Data , client * govmomi . Client ) * types . Virtual Machine Boot Options { obj : = & types . Virtual Machine Boot Options { Boot Delay : int 6 4 ( d . Get ( " " ) . ( int ) ) , Boot Retry Enabled : structure . Get Bool ( d , " " ) , Boot Retry Delay : int 6 4 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 , Minor : 5 } ) { obj . Efi Secure Boot Enabled = get Bool With Restart ( d , " " ) } return obj } 
func flatten Virtual Machine Boot Options ( d * schema . Resource Data , obj * types . Virtual Machine Boot Options ) error { d . Set ( " " , obj . Boot Delay ) structure . Set Bool Ptr ( d , " " , obj . Efi Secure Boot Enabled ) structure . Set Bool Ptr ( d , " " , obj . Boot Retry Enabled ) d . Set ( " " , obj . Boot Retry Delay ) return nil } 
func expand Virtual Machine Flag Info ( d * schema . Resource Data ) * types . Virtual Machine Flag Info { obj : = & types . Virtual Machine Flag Info { Disk Uuid Enabled : get Bool With Restart ( d , " " ) , Virtual Exec Usage : get With Restart ( d , " " ) . ( string ) , Virtual Mmu Usage : get With Restart ( d , " " ) . ( string ) , Enable Logging : get Bool With Restart ( d , " " ) , } return obj } 
func flatten Virtual Machine Flag Info ( d * schema . Resource Data , obj * types . Virtual Machine Flag Info ) error { d . Set ( " " , obj . Disk Uuid Enabled ) d . Set ( " " , obj . Virtual Exec Usage ) d . Set ( " " , obj . Virtual Mmu Usage ) d . Set ( " " , obj . Enable Logging ) return nil } 
func expand Tools Config Info ( d * schema . Resource Data ) * types . Tools Config Info { obj : = & types . Tools Config Info { Sync Time With Host : structure . Get Bool ( d , " " ) , After Power On : get Bool With Restart ( d , " " ) , After Resume : get Bool With Restart ( d , " " ) , Before Guest Standby : get Bool With Restart ( d , " " ) , Before Guest Shutdown : get Bool With Restart ( d , " " ) , Before Guest Reboot : get Bool With Restart ( d , " " ) , } return obj } 
func flatten Tools Config Info ( d * schema . Resource Data , obj * types . Tools Config Info ) error { d . Set ( " " , obj . Sync Time With Host ) d . Set ( " " , obj . After Power On ) d . Set ( " " , obj . After Resume ) d . Set ( " " , obj . Before Guest Standby ) d . Set ( " " , obj . Before Guest Shutdown ) d . Set ( " " , obj . Before Guest Reboot ) return nil } 
func schema Virtual Machine Resource Allocation ( ) map [ string ] * schema . Schema { s : = make ( map [ string ] * schema . Schema ) share Level Fmt : = " " share Count Fmt : = " " limit Fmt : = " " reservation Fmt : = " " for _ , t : = range virtual Machine Resource Allocation Type Values { share Level Key : = fmt . Sprintf ( " " , t ) share Count Key : = fmt . Sprintf ( " " , t ) limit Key : = fmt . Sprintf ( " " , t ) reservation Key : = fmt . Sprintf ( " " , t ) s [ share Level Key ] = & schema . Schema { Type : schema . Type String , Optional : true , Default : string ( types . Shares Level Normal ) , Description : fmt . Sprintf ( share Level Fmt , t ) , Validate Func : validation . String In Slice ( shares Level Allowed Values , false ) , } s [ share Count Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Computed : true , Description : fmt . Sprintf ( share Count Fmt , t ) , Validate Func : validation . Int At Least ( 0 ) , } s [ limit Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Default : - 1 , Description : fmt . Sprintf ( limit Fmt , t ) , Validate Func : validation . Int At Least ( - 1 ) , } s [ reservation Key ] = & schema . Schema { Type : schema . Type Int , Optional : true , Description : fmt . Sprintf ( reservation Fmt , t ) , Validate Func : validation . Int At Least ( 0 ) , } } return s } 
func expand Virtual Machine Resource Allocation ( d * schema . Resource Data , key string ) * types . Resource Allocation Info { share Level Key : = fmt . Sprintf ( " " , key ) share Count Key : = fmt . Sprintf ( " " , key ) limit Key : = fmt . Sprintf ( " " , key ) reservation Key : = fmt . Sprintf ( " " , key ) obj : = & types . Resource Allocation Info { Limit : structure . Get Int 6 4Ptr Empty Zero ( d , limit Key ) , Reservation : structure . Get Int 6 4Ptr Empty Zero ( d , reservation Key ) , } shares : = & types . Shares Info { Level : types . Shares Level ( d . Get ( share Level Key ) . ( string ) ) , Shares : int 3 2 ( d . Get ( share Count Key ) . ( int ) ) , } obj . Shares = shares return obj } 
func expand Latency Sensitivity ( d * schema . Resource Data ) * types . Latency Sensitivity { obj : = & types . Latency Sensitivity { Level : types . Latency Sensitivity Sensitivity Level ( d . Get ( " " ) . ( string ) ) , } return obj } 
func flatten Latency Sensitivity ( d * schema . Resource Data , obj * types . Latency Sensitivity ) error { if obj = = nil { log . Printf ( " " ) return nil } return d . Set ( " " , obj . Level ) } 
func flatten Virtual Machine Resource Allocation ( d * schema . Resource Data , obj * types . Resource Allocation Info , key string ) error { share Level Key : = fmt . Sprintf ( " " , key ) share Count Key : = fmt . Sprintf ( " " , key ) limit Key : = fmt . Sprintf ( " " , key ) reservation Key : = fmt . Sprintf ( " " , key ) structure . Set Int 6 4Ptr ( d , limit Key , obj . Limit ) structure . Set Int 6 4Ptr ( d , reservation Key , obj . Reservation ) if obj . Shares ! = nil { d . Set ( share Level Key , obj . Shares . Level ) d . Set ( share Count Key , obj . Shares . Shares ) } return nil } 
func expand Extra Config ( d * schema . Resource Data ) [ ] types . Base Option Value { if d . Has Change ( " " ) { } else { } var opts [ ] types . Base Option Value for k 1 : = range old . ( map [ string ] interface { } ) { var found bool for k 2 : = range new . ( map [ string ] interface { } ) { if k 1 = = k 2 { found = true } } if ! found { ov : = & types . Option Value { Key : k 1 , Value : " " , } opts = append ( opts , ov ) } } for k 2 , v 2 : = range old . ( map [ string ] interface { } ) { if k 1 = = k 2 { found = true if v 1 ! = v 2 { opts = append ( opts , ov ) } } } if ! found { opts = append ( opts , ov ) } } } 
func flatten Extra Config ( d * schema . Resource Data , opts [ ] types . Base Option Value ) error { if len ( opts ) < 1 { } ec : = make ( map [ string ] interface { } ) for _ , v : = range opts { ov : = v . Get Option Value ( ) for k : = range d . Get ( " " ) . ( map [ string ] interface { } ) { if ov . Key = = k { ec [ ov . Key ] = ov . Value } } } return d . Set ( " " , ec ) } 
func expand VApp Config ( d * schema . Resource Data , client * govmomi . Client ) ( * types . Vm Config Spec , error ) { if ! d . Has Change ( " " ) { return nil , nil } var props [ ] types . VApp Property Spec _ , new : = d . Get Change ( " " ) new Map : = make ( map [ string ] interface { } ) new VApps : = new . ( [ ] interface { } ) if new VApps ! = nil & & len ( new VApps ) > 0 & & new VApps [ 0 ] ! = nil { new VApp : = new VApps [ 0 ] . ( map [ string ] interface { } ) if props , ok : = new VApp [ " " ] . ( map [ string ] interface { } ) ; ok { new Map = props } } uuid : = d . Id ( ) if uuid = = " " { } return nil , nil } vm , _ : = virtualmachine . From UUID ( client , d . Id ( ) ) vm Props , _ : = virtualmachine . Properties ( vm ) if vm Props . Config . VApp Config = = nil { return nil , fmt . Errorf ( " " ) } all Properties : = vm Props . Config . VApp Config . Get Vm Config Info ( ) . Property for _ , p : = range all Properties { default Value : = " " if p . Default Value ! = " " { default Value = p . Default Value } prop : = types . VApp Property Spec { Array Update Spec : types . Array Update Spec { Operation : types . Array Update Operation Edit , } , Info : & types . VApp Property Info { Key : p . Key , Id : p . Id , Value : default Value , } , } new Value , ok : = new Map [ p . Id ] if ok { prop . Info . Value = new Value . ( string ) delete ( new Map , p . Id ) } props = append ( props , prop ) } if len ( new Map ) > 0 { return nil , fmt . Errorf ( " " , reflect . Value Of ( new Map ) . Map Keys ( ) ) } return & types . Vm Config Spec { Property : props , } , nil } 
func flatten VApp Config ( d * schema . Resource Data , config types . Base Vm Config Info ) error { if config = = nil { d . Set ( " " , [ ] string { } ) return nil } props : = config . Get Vm Config Info ( ) . Property if len ( props ) < 1 { } vac : = make ( map [ string ] interface { } ) for _ , v : = range props { if v . Value ! = " " & & v . Value ! = v . Default Value { vac [ v . Id ] = v . Value } } } return nil } 
func expand CPUCount Config ( d * schema . Resource Data ) int 3 2 { occ , ncc : = d . Get Change ( " " ) cha , _ : = d . Get Change ( " " ) current Hot Add : = cha . ( bool ) chr , _ : = d . Get Change ( " " ) current Hot Remove : = chr . ( bool ) old CPUCount : = int 3 2 ( occ . ( int ) ) new CPUCount : = int 3 2 ( ncc . ( int ) ) switch { case old CPUCount < new CPUCount : d . Set ( " " , true ) } case old CPUCount > new CPUCount : d . Set ( " " , true ) } } return new CPUCount } 
func expand Memory Size Config ( d * schema . Resource Data ) int 6 4 { om , nm : = d . Get Change ( " " ) cha , _ : = d . Get Change ( " " ) current Hot Add : = cha . ( bool ) old Mem : = int 6 4 ( om . ( int ) ) new Mem : = int 6 4 ( nm . ( int ) ) switch { case old Mem < new Mem : d . Set ( " " , true ) } case old Mem > new Mem : d . Set ( " " , true ) } return new Mem } 
func expand Virtual Machine Config Spec ( d * schema . Resource Data , client * govmomi . Client ) ( types . Virtual Machine Config Spec , error ) { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) vapp Config , err : = expand VApp Config ( d , client ) if err ! = nil { return types . Virtual Machine Config Spec { } , err } obj : = types . Virtual Machine Config Spec { Name : d . Get ( " " ) . ( string ) , Guest Id : get With Restart ( d , " " ) . ( string ) , Alternate Guest Name : get With Restart ( d , " " ) . ( string ) , Annotation : d . Get ( " " ) . ( string ) , Tools : expand Tools Config Info ( d ) , Flags : expand Virtual Machine Flag Info ( d ) , Num CPUs : expand CPUCount Config ( d ) , Num Cores Per Socket : int 3 2 ( get With Restart ( d , " " ) . ( int ) ) , Memory MB : expand Memory Size Config ( d ) , Memory Hot Add Enabled : get Bool With Restart ( d , " " ) , Cpu Hot Add Enabled : get Bool With Restart ( d , " " ) , Cpu Hot Remove Enabled : get Bool With Restart ( d , " " ) , Cpu Allocation : expand Virtual Machine Resource Allocation ( d , " " ) , Memory Allocation : expand Virtual Machine Resource Allocation ( d , " " ) , Memory Reservation Locked To Max : get Memory Reservation Locked To Max ( d ) , Extra Config : expand Extra Config ( d ) , Swap Placement : get With Restart ( d , " " ) . ( string ) , Boot Options : expand Virtual Machine Boot Options ( d , client ) , VApp Config : vapp Config , Firmware : get With Restart ( d , " " ) . ( string ) , Nested HVEnabled : get Bool With Restart ( d , " " ) , VPMCEnabled : get Bool With Restart ( d , " " ) , Latency Sensitivity : expand Latency Sensitivity ( d ) , } return obj , nil } 
func flatten Virtual Machine Config Info ( d * schema . Resource Data , obj * types . Virtual Machine Config Info ) error { d . Set ( " " , obj . Name ) d . Set ( " " , obj . Guest Id ) d . Set ( " " , obj . Alternate Guest Name ) d . Set ( " " , obj . Annotation ) d . Set ( " " , obj . Hardware . Num CPU ) d . Set ( " " , obj . Hardware . Num Cores Per Socket ) d . Set ( " " , obj . Hardware . Memory MB ) d . Set ( " " , obj . Memory Hot Add Enabled ) d . Set ( " " , obj . Cpu Hot Add Enabled ) d . Set ( " " , obj . Cpu Hot Remove Enabled ) d . Set ( " " , obj . Swap Placement ) d . Set ( " " , obj . Firmware ) d . Set ( " " , obj . Nested HVEnabled ) d . Set ( " " , obj . VPMCEnabled ) d . Set ( " " , obj . Change Version ) d . Set ( " " , obj . Uuid ) if err : = flatten Tools Config Info ( d , obj . Tools ) ; err ! = nil { return err } if err : = flatten Virtual Machine Flag Info ( d , & obj . Flags ) ; err ! = nil { return err } if err : = flatten Virtual Machine Resource Allocation ( d , obj . Cpu Allocation , " " ) ; err ! = nil { return err } if err : = flatten Virtual Machine Resource Allocation ( d , obj . Memory Allocation , " " ) ; err ! = nil { return err } if err : = flatten Extra Config ( d , obj . Extra Config ) ; err ! = nil { return err } if err : = flatten VApp Config ( d , obj . VApp Config ) ; err ! = nil { return err } if err : = flatten Latency Sensitivity ( d , obj . Latency Sensitivity ) ; err ! = nil { return err } } 
func expand Virtual Machine Config Spec Changed ( d * schema . Resource Data , client * govmomi . Client , info * types . Virtual Machine Config Info ) ( types . Virtual Machine Config Spec , bool , error ) { old Data . Set Id ( d . Id ( ) ) old Spec , err : = expand Virtual Machine Config Spec ( old Data , client ) if err ! = nil { return types . Virtual Machine Config Spec { } , false , err } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) new Spec , err : = expand Virtual Machine Config Spec ( d , client ) if err ! = nil { return types . Virtual Machine Config Spec { } , false , err } } 
func get Memory Reservation Locked To Max ( d * schema . Resource Data ) * bool { if d . Get ( " " ) . ( int ) ! = d . Get ( " " ) . ( int ) { return structure . Bool Ptr ( false ) } return nil } 
func From Path Or Default ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . Resource Pool , error ) { finder : = find . New Finder ( client . Client , false ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) t : = client . Service Content . About . Api Type switch t { case " " : ddc , err : = finder . Default Datacenter ( ctx ) if err ! = nil { return nil , err } finder . Set Datacenter ( ddc ) return finder . Default Resource Pool ( ctx ) case " " : if dc ! = nil { finder . Set Datacenter ( dc ) } if name ! = " " { return finder . Resource Pool ( ctx , name ) } return finder . Default Resource Pool ( ctx ) } return nil , fmt . Errorf ( " " , t ) } 
func Properties ( obj * object . Resource Pool ) ( * mo . Resource Pool , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Resource Pool if err : = obj . Properties ( ctx , obj . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Validate Host ( client * govmomi . Client , pool * object . Resource Pool , host * object . Host System ) error { if host = = nil { return nil } log . Printf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) pprops , err : = Properties ( pool ) if err ! = nil { return err } cprops , err : = computeresource . Base Properties From Reference ( client , pprops . Owner ) if err ! = nil { return err } for _ , href : = range cprops . Host { if href . Value = = host . Reference ( ) . Value { log . Printf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) return nil } } return fmt . Errorf ( " " , host . Reference ( ) . Value , pool . Reference ( ) . Value ) } 
func Default Devices ( client * govmomi . Client , pool * object . Resource Pool , guest string ) ( object . Virtual Device List , error ) { log . Printf ( " " , pool . Reference ( ) . Value , guest ) pprops , err : = Properties ( pool ) if err ! = nil { return nil , err } return computeresource . Default Devices From Reference ( client , pprops . Owner , guest ) } 
func OSFamily ( client * govmomi . Client , pool * object . Resource Pool , guest string ) ( string , error ) { log . Printf ( " " , guest ) pprops , err : = Properties ( pool ) if err ! = nil { return " " , err } return computeresource . OSFamily ( client , pprops . Owner , guest ) } 
func Create ( rp * object . Resource Pool , name string , spec * types . Resource Config Spec ) ( * object . Resource Pool , error ) { log . Printf ( " " , fmt . Sprintf ( " " , rp . Inventory Path , name ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) nrp , err : = rp . Create ( ctx , name , * spec ) if err ! = nil { return nil , err } return nrp , nil } 
func Update ( rp * object . Resource Pool , name string , spec * types . Resource Config Spec ) error { log . Printf ( " " , fmt . Sprintf ( " " , rp . Inventory Path ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return rp . Update Config ( ctx , name , spec ) } 
func Move Into Resource Pool ( p * object . Resource Pool , c types . Managed Object Reference ) error { req : = types . Move Into Resource Pool { This : p . Reference ( ) , List : [ ] types . Managed Object Reference { c } , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) _ , err : = methods . Move Into Resource Pool ( ctx , p . Client ( ) , & req ) return err } 
func Has Children ( rp * object . Resource Pool ) ( bool , error ) { props , err : = Properties ( rp ) if err ! = nil { return false , err } if len ( props . Vm ) > 0 | | len ( props . Resource Pool ) > 0 { return true , nil } return false , nil } 
func expand Cluster Das VMConfig Info ( d * schema . Resource Data , meta interface { } , vm * object . Virtual Machine , ) ( * types . Cluster Das Vm Config Info , error ) { client , err : = resource VSphere HAVMOverride Client ( meta ) if err ! = nil { return nil , err } version : = viapi . Parse Version From Client ( client ) obj : = & types . Cluster Das Vm Config Info { Das Settings : expand Cluster Das VMSettings ( d , version ) , Key : vm . Reference ( ) , } return obj , nil } 
func flatten Cluster Das VMConfig Info ( d * schema . Resource Data , meta interface { } , obj * types . Cluster Das Vm Config Info ) error { client , err : = resource VSphere HAVMOverride Client ( meta ) if err ! = nil { return err } version : = viapi . Parse Version From Client ( client ) } return flatten Cluster Das VMSettings ( d , obj . Das Settings , version ) } 
func resource VSphere HAVMOverride Flatten ID ( cluster * object . Cluster Compute Resource , vm * object . Virtual Machine ) ( string , error ) { cluster ID : = cluster . Reference ( ) . Value props , err : = virtualmachine . Properties ( vm ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } vm ID : = props . Config . Uuid return strings . Join ( [ ] string { cluster ID , vm ID } , " " ) , nil } 
func resource VSphere HAVMOverride Find Entry ( cluster * object . Cluster Compute Resource , vm * object . Virtual Machine , ) ( * types . Cluster Das Vm Config Info , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Das Vm Config { if info . Key = = vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resource VSphere HAVMOverride Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , * object . Virtual Machine , error ) { if d . Id ( ) ! = " " { return resource VSphere HAVMOverride Objects From ID ( d , meta ) } return resource VSphere HAVMOverride Objects From Attributes ( d , meta ) } 
func schema Host Port Group Spec ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , schema Host Network Policy ( ) ) return s } 
func expand Host Port Group Spec ( d * schema . Resource Data ) * types . Host Port Group Spec { obj : = & types . Host Port Group Spec { Name : d . Get ( " " ) . ( string ) , Vlan Id : int 3 2 ( d . Get ( " " ) . ( int ) ) , Vswitch Name : d . Get ( " " ) . ( string ) , Policy : * expand Host Network Policy ( d ) , } return obj } 
func flatten Host Port Group Spec ( d * schema . Resource Data , obj * types . Host Port Group Spec ) error { d . Set ( " " , obj . Vlan Id ) if err : = flatten Host Network Policy ( d , & obj . Policy ) ; err ! = nil { return err } return nil } 
func calculate Computed Policy ( policy types . Host Network Policy ) ( map [ string ] string , error ) { cpr : = & schema . Resource { Schema : schema Host Network Policy ( ) } cpd : = cpr . Data ( & terraform . Instance State { } ) cpd . Set Id ( " " ) if err : = flatten Host Network Policy ( cpd , & policy ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } cpm : = cpd . State ( ) . Attributes delete ( cpm , " " ) return cpm , nil } 
func calculate Ports ( ports [ ] types . Host Port Group Port ) * schema . Set { s : = make ( [ ] interface { } , 0 ) for _ , port : = range ports { m : = make ( map [ string ] interface { } ) m [ " " ] = port . Key m [ " " ] = structure . Slice Strings To Interfaces ( port . Mac ) m [ " " ] = port . Type s = append ( s , m ) } return schema . New Set ( schema . Hash Resource ( port Group Port Schema ( ) ) , s ) } 
func port Group Port Schema ( ) * schema . Resource { return & schema . Resource { Schema : map [ string ] * schema . Schema { " " : { Type : schema . Type String , Description : " " , Computed : true , } , " " : { Type : schema . Type List , Description : " " , Computed : true , Elem : & schema . Schema { Type : schema . Type String } , } , " " : { Type : schema . Type String , Description : " " , Computed : true , } , } , } } 
func save Host Port Group ID ( d * schema . Resource Data , hs ID , name string ) { d . Set Id ( fmt . Sprintf ( " " , host Port Group IDPrefix , hs ID , name ) ) } 
func split Host Port Group ID ( raw string ) ( string , string , error ) { s : = strings . Split N ( raw , " " , 3 ) if len ( s ) ! = 3 | | s [ 0 ] ! = host Port Group IDPrefix | | s [ 1 ] = = " " | | s [ 2 ] = = " " { return " " , " " , fmt . Errorf ( " " , raw ) } return s [ 1 ] , s [ 2 ] , nil } 
func port Group IDs From Resource ID ( d * schema . Resource Data ) ( string , string , error ) { return split Host Port Group ID ( d . Id ( ) ) } 
func Base From Path ( client * govmomi . Client , path string ) ( Base Compute Resource , error ) { finder : = find . New Finder ( client . Client , false ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) list , err : = finder . Managed Object List ( ctx , path , " " , " " ) if err ! = nil { return nil , err } if len ( list ) < 1 { return nil , fmt . Errorf ( " " , path ) } if len ( list ) > 1 { return nil , fmt . Errorf ( " " , path ) } if ! strings . Has Suffix ( list [ 0 ] . Path , path ) { return nil , fmt . Errorf ( " " , list [ 0 ] . Path , path ) } return Base From Reference ( client , list [ 0 ] . Object . Reference ( ) ) } 
func Base From Reference ( client * govmomi . Client , ref types . Managed Object Reference ) ( Base Compute Resource , error ) { switch ref . Type { case " " : return Standalone From ID ( client , ref . Value ) case " " : return Standalone From ID ( client , ref . Value ) } return nil , fmt . Errorf ( " " , ref . Type ) } 
func Base Properties ( obj Base Compute Resource ) ( * mo . Compute Resource , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Compute Resource if err : = obj . Properties ( ctx , obj . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Base Properties From Reference ( client * govmomi . Client , ref types . Managed Object Reference ) ( * mo . Compute Resource , error ) { obj , err : = Base From Reference ( client , ref ) if err ! = nil { return nil , err } return Base Properties ( obj ) } 
func Default Devices From Reference ( client * govmomi . Client , ref types . Managed Object Reference , guest string ) ( object . Virtual Device List , error ) { log . Printf ( " " , ref . Value , guest ) b , err : = Environment Browser From Reference ( client , ref ) if err ! = nil { return nil , err } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return b . Default Devices ( ctx , " " , nil ) } 
func OSFamily ( client * govmomi . Client , ref types . Managed Object Reference , guest string ) ( string , error ) { b , err : = Environment Browser From Reference ( client , ref ) if err ! = nil { return " " , err } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return b . OSFamily ( ctx , guest ) } 
func Environment Browser From Reference ( client * govmomi . Client , ref types . Managed Object Reference ) ( * envbrowse . Environment Browser , error ) { cr , err : = Base From Reference ( client , ref ) if err ! = nil { return nil , err } props , err : = Base Properties ( cr ) if err ! = nil { return nil , err } if props . Environment Browser = = nil { return nil , fmt . Errorf ( " " , cr , ) } return envbrowse . New Environment Browser ( client . Client , * props . Environment Browser ) , nil } 
func Reconfigure ( obj Base Compute Resource , spec types . Base Compute Resource Config Spec ) error { var c * object . Compute Resource switch t : = obj . ( type ) { case * object . Compute Resource : log . Printf ( " " , t . Name ( ) ) c = t case * object . Cluster Compute Resource : log . Printf ( " " , t . Name ( ) ) c = & t . Compute Resource default : return fmt . Errorf ( " " , t ) } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = c . Reconfigure ( ctx , spec , true ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func Has Children ( obj Base Compute Resource ) ( bool , error ) { props , err : = Base Properties ( obj ) if err ! = nil { return false , err } } 
func Properties ( cluster * object . Cluster Compute Resource ) ( * mo . Cluster Compute Resource , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Cluster Compute Resource if err : = cluster . Properties ( ctx , cluster . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Create ( f * object . Folder , name string , spec types . Cluster Config Spec Ex ) ( * object . Cluster Compute Resource , error ) { log . Printf ( " " , fmt . Sprintf ( " " , f . Inventory Path , name ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) cluster , err : = f . Create Cluster ( ctx , name , spec ) if err ! = nil { return nil , err } return cluster , nil } 
func Move To Folder ( client * govmomi . Client , cluster * object . Cluster Compute Resource , relative string ) error { f , err : = folder . Host Folder From Object ( client , cluster , relative ) if err ! = nil { return err } return folder . Move Object To ( cluster . Reference ( ) , f ) } 
func Reconfigure ( cluster * object . Cluster Compute Resource , spec * types . Cluster Config Spec Ex ) error { return computeresource . Reconfigure ( cluster , spec ) } 
func Delete ( cluster * object . Cluster Compute Resource ) error { log . Printf ( " " , cluster . Inventory Path ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = cluster . Destroy ( ctx ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func Is Member ( cluster * object . Cluster Compute Resource , host * object . Host System ) ( bool , error ) { hprops , err : = hostsystem . Properties ( host ) if err ! = nil { return false , fmt . Errorf ( " " , host . Name ( ) , err ) } if hprops . Parent = = nil { return false , nil } if * hprops . Parent ! = cluster . Reference ( ) { return false , nil } return true , nil } 
func Move Hosts Into ( cluster * object . Cluster Compute Resource , hosts [ ] * object . Host System ) error { var hs Names [ ] string var hs Refs [ ] types . Managed Object Reference for _ , hs : = range hosts { hs Names = append ( hs Names , hs . Name ( ) ) hs Refs = append ( hs Refs , hs . Reference ( ) ) } log . Printf ( " " , cluster . Name ( ) , strings . Join ( hs Names , " " ) ) req : = types . Move Into _Task { This : cluster . Reference ( ) , Host : hs Refs , } ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) resp , err : = methods . Move Into _Task ( ctx , cluster . Client ( ) , & req ) if err ! = nil { return err } task : = object . New Task ( cluster . Client ( ) , resp . Returnval ) return task . Wait ( ctx ) } 
func Move Hosts Out Of ( cluster * object . Cluster Compute Resource , hosts [ ] * object . Host System , timeout int ) error { for _ , host : = range hosts { if err : = move Host Out Of ( cluster , host , timeout ) ; err ! = nil { return err } } return nil } 
func schema VMware DVSPort Setting ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func expand Vmware Distributed Virtual Switch Vlan IDSpec ( d * schema . Resource Data ) * types . Vmware Distributed Virtual Switch Vlan Id Spec { obj : = & types . Vmware Distributed Virtual Switch Vlan Id Spec { Vlan Id : int 3 2 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flatten Vmware Distributed Virtual Switch Vlan IDSpec ( d * schema . Resource Data , obj * types . Vmware Distributed Virtual Switch Vlan Id Spec ) error { d . Set ( " " , obj . Vlan Id ) return nil } 
func expand Vmware Distributed Virtual Switch Trunk Vlan Spec ( d * schema . Resource Data ) * types . Vmware Distributed Virtual Switch Trunk Vlan Spec { var ranges [ ] types . Numeric Range data : = d . Get ( " " ) . ( * schema . Set ) . List ( ) for _ , v : = range data { log . Printf ( " " , v ) r : = v . ( map [ string ] interface { } ) min : = r [ " " ] . ( int ) max : = r [ " " ] . ( int ) rng : = types . Numeric Range { Start : int 3 2 ( min ) , End : int 3 2 ( max ) , } ranges = append ( ranges , rng ) } if len ( ranges ) < 1 { return nil } obj : = & types . Vmware Distributed Virtual Switch Trunk Vlan Spec { Vlan Id : ranges , } return obj } 
func flatten Vmware Distributed Virtual Switch Trunk Vlan Spec ( d * schema . Resource Data , obj * types . Vmware Distributed Virtual Switch Trunk Vlan Spec ) error { var s [ ] interface { } for _ , rng : = range obj . Vlan Id { m : = make ( map [ string ] interface { } ) m [ " " ] = rng . Start m [ " " ] = rng . End s = append ( s , m ) } if err : = d . Set ( " " , s ) ; err ! = nil { return err } return nil } 
func expand Vmware Distributed Virtual Switch Pvlan Spec ( d * schema . Resource Data ) * types . Vmware Distributed Virtual Switch Pvlan Spec { obj : = & types . Vmware Distributed Virtual Switch Pvlan Spec { Pvlan Id : int 3 2 ( d . Get ( " " ) . ( int ) ) , } return obj } 
func flatten Vmware Distributed Virtual Switch Pvlan Spec ( d * schema . Resource Data , obj * types . Vmware Distributed Virtual Switch Pvlan Spec ) error { d . Set ( " " , obj . Pvlan Id ) return nil } 
func expand Base Vmware Distributed Virtual Switch Vlan Spec ( d * schema . Resource Data ) types . Base Vmware Distributed Virtual Switch Vlan Spec { var obj types . Base Vmware Distributed Virtual Switch Vlan Spec _ , ide : = d . Get Ok Exists ( " " ) _ , pvid : = d . Get Ok Exists ( " " ) vte List , vte OK : = d . Get Ok Exists ( " " ) vte : = vte OK & & len ( vte List . ( * schema . Set ) . List ( ) ) > 0 switch { case vte : obj = expand Vmware Distributed Virtual Switch Trunk Vlan Spec ( d ) case pvid : obj = expand Vmware Distributed Virtual Switch Pvlan Spec ( d ) case ide : obj = expand Vmware Distributed Virtual Switch Vlan IDSpec ( d ) } return obj } 
func flatten Base Vmware Distributed Virtual Switch Vlan Spec ( d * schema . Resource Data , obj types . Base Vmware Distributed Virtual Switch Vlan Spec ) error { if obj = = nil { return nil } var err error switch t : = obj . ( type ) { case * types . Vmware Distributed Virtual Switch Vlan Id Spec : err = flatten Vmware Distributed Virtual Switch Vlan IDSpec ( d , t ) case * types . Vmware Distributed Virtual Switch Trunk Vlan Spec : err = flatten Vmware Distributed Virtual Switch Trunk Vlan Spec ( d , t ) case * types . Vmware Distributed Virtual Switch Pvlan Spec : err = flatten Vmware Distributed Virtual Switch Pvlan Spec ( d , t ) } return err } 
func expand DVSFailure Criteria ( d * schema . Resource Data ) * types . DVSFailure Criteria { obj : = & types . DVSFailure Criteria { Check Beacon : structure . Get Bool Policy ( d , " " ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten DVSFailure Criteria ( d * schema . Resource Data , obj * types . DVSFailure Criteria ) error { if obj = = nil { return nil } structure . Set Bool Policy ( d , " " , obj . Check Beacon ) return nil } 
func expand VMware Uplink Port Order Policy ( d * schema . Resource Data ) * types . VMware Uplink Port Order Policy { obj : = & types . VMware Uplink Port Order Policy { Active Uplink Port : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) , Standby Uplink Port : structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( [ ] interface { } ) ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten VMware Uplink Port Order Policy ( d * schema . Resource Data , obj * types . VMware Uplink Port Order Policy ) error { if obj = = nil { return nil } if err : = d . Set ( " " , obj . Active Uplink Port ) ; err ! = nil { return err } if err : = d . Set ( " " , obj . Standby Uplink Port ) ; err ! = nil { return err } return nil } 
func expand Vmware Uplink Port Teaming Policy ( d * schema . Resource Data ) * types . Vmware Uplink Port Teaming Policy { obj : = & types . Vmware Uplink Port Teaming Policy { Policy : structure . Get String Policy ( d , " " ) , Notify Switches : structure . Get Bool Policy ( d , " " ) , Rolling Order : structure . Get Bool Policy Reverse ( d , " " ) , Failure Criteria : expand DVSFailure Criteria ( d ) , Uplink Port Order : expand VMware Uplink Port Order Policy ( d ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten Vmware Uplink Port Teaming Policy ( d * schema . Resource Data , obj * types . Vmware Uplink Port Teaming Policy ) error { if obj = = nil { return nil } structure . Set String Policy ( d , " " , obj . Policy ) structure . Set Bool Policy ( d , " " , obj . Notify Switches ) structure . Set Bool Policy Reverse ( d , " " , obj . Rolling Order ) if err : = flatten DVSFailure Criteria ( d , obj . Failure Criteria ) ; err ! = nil { return err } if err : = flatten VMware Uplink Port Order Policy ( d , obj . Uplink Port Order ) ; err ! = nil { return err } return nil } 
func expand DVSSecurity Policy ( d * schema . Resource Data ) * types . DVSSecurity Policy { obj : = & types . DVSSecurity Policy { Allow Promiscuous : structure . Get Bool Policy ( d , " " ) , Mac Changes : structure . Get Bool Policy ( d , " " ) , Forged Transmits : structure . Get Bool Policy ( d , " " ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten DVSSecurity Policy ( d * schema . Resource Data , obj * types . DVSSecurity Policy ) error { if obj = = nil { return nil } structure . Set Bool Policy ( d , " " , obj . Allow Promiscuous ) structure . Set Bool Policy ( d , " " , obj . Mac Changes ) structure . Set Bool Policy ( d , " " , obj . Forged Transmits ) return nil } 
func expand VMware Uplink Lacp Policy ( d * schema . Resource Data ) * types . VMware Uplink Lacp Policy { obj : = & types . VMware Uplink Lacp Policy { Enable : structure . Get Bool Policy ( d , " " ) , Mode : structure . Get String Policy ( d , " " ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten VMware Uplink Lacp Policy ( d * schema . Resource Data , obj * types . VMware Uplink Lacp Policy ) error { if obj = = nil { return nil } structure . Set Bool Policy ( d , " " , obj . Enable ) structure . Set String Policy ( d , " " , obj . Mode ) return nil } 
func expand DVSTraffic Shaping Policy Ingress ( d * schema . Resource Data ) * types . DVSTraffic Shaping Policy { obj : = & types . DVSTraffic Shaping Policy { Enabled : structure . Get Bool Policy ( d , " " ) , Average Bandwidth : structure . Get Long Policy ( d , " " ) , Peak Bandwidth : structure . Get Long Policy ( d , " " ) , Burst Size : structure . Get Long Policy ( d , " " ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten DVSTraffic Shaping Policy Ingress ( d * schema . Resource Data , obj * types . DVSTraffic Shaping Policy ) error { if obj = = nil { return nil } structure . Set Bool Policy ( d , " " , obj . Enabled ) structure . Set Long Policy ( d , " " , obj . Average Bandwidth ) structure . Set Long Policy ( d , " " , obj . Peak Bandwidth ) structure . Set Long Policy ( d , " " , obj . Burst Size ) return nil } 
func expand VMware DVSPort Setting ( d * schema . Resource Data ) * types . VMware DVSPort Setting { obj : = & types . VMware DVSPort Setting { DVPort Setting : types . DVPort Setting { Blocked : structure . Get Bool Policy ( d , " " ) , In Shaping Policy : expand DVSTraffic Shaping Policy Ingress ( d ) , Out Shaping Policy : expand DVSTraffic Shaping Policy Egress ( d ) , Vm Direct Path Gen 2Allowed : structure . Get Bool Policy ( d , " " ) , } , Vlan : expand Base Vmware Distributed Virtual Switch Vlan Spec ( d ) , Uplink Teaming Policy : expand Vmware Uplink Port Teaming Policy ( d ) , Security Policy : expand DVSSecurity Policy ( d ) , Ipfix Enabled : structure . Get Bool Policy ( d , " " ) , Tx Uplink : structure . Get Bool Policy ( d , " " ) , Lacp Policy : expand VMware Uplink Lacp Policy ( d ) , } if structure . All Fields Empty ( obj ) { return nil } return obj } 
func flatten VMware DVSPort Setting ( d * schema . Resource Data , obj * types . VMware DVSPort Setting ) error { if obj = = nil { return nil } structure . Set Bool Policy ( d , " " , obj . Blocked ) structure . Set Bool Policy ( d , " " , obj . Ipfix Enabled ) structure . Set Bool Policy ( d , " " , obj . Tx Uplink ) structure . Set Bool Policy ( d , " " , obj . Vm Direct Path Gen 2Allowed ) if err : = flatten DVSTraffic Shaping Policy Ingress ( d , obj . In Shaping Policy ) ; err ! = nil { return err } if err : = flatten DVSTraffic Shaping Policy Egress ( d , obj . Out Shaping Policy ) ; err ! = nil { return err } if err : = flatten Base Vmware Distributed Virtual Switch Vlan Spec ( d , obj . Vlan ) ; err ! = nil { return err } if err : = flatten Vmware Uplink Port Teaming Policy ( d , obj . Uplink Teaming Policy ) ; err ! = nil { return err } if err : = flatten DVSSecurity Policy ( d , obj . Security Policy ) ; err ! = nil { return err } if err : = flatten VMware Uplink Lacp Policy ( d , obj . Lacp Policy ) ; err ! = nil { return err } return nil } 
func expand Cluster Drs VMConfig Info ( d * schema . Resource Data , vm * object . Virtual Machine ) ( * types . Cluster Drs Vm Config Info , error ) { obj : = & types . Cluster Drs Vm Config Info { Behavior : types . Drs Behavior ( d . Get ( " " ) . ( string ) ) , Enabled : structure . Get Bool ( d , " " ) , Key : vm . Reference ( ) , } return obj , nil } 
func flatten Cluster Drs VMConfig Info ( d * schema . Resource Data , obj * types . Cluster Drs Vm Config Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Behavior , " " : obj . Enabled , } ) } 
func resource VSphere DRSVMOverride Parse ID ( id string ) ( string , string , error ) { parts : = strings . Split N ( id , " " , 3 ) if len ( parts ) < 2 { return " " , " " , fmt . Errorf ( " " , id ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func resource VSphere DRSVMOverride Find Entry ( cluster * object . Cluster Compute Resource , vm * object . Virtual Machine , ) ( * types . Cluster Drs Vm Config Info , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Drs Vm Config { if info . Key = = vm . Reference ( ) { log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return & info , nil } } log . Printf ( " " , vm . Name ( ) , cluster . Name ( ) ) return nil , nil } 
func resource VSphere DRSVMOverride Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , * object . Virtual Machine , error ) { if d . Id ( ) ! = " " { return resource VSphere DRSVMOverride Objects From ID ( d , meta ) } return resource VSphere DRSVMOverride Objects From Attributes ( d , meta ) } 
func schema Virtual Machine Guest Info ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . Type String , Computed : true , Description : " " , } , " " : { Type : schema . Type List , Computed : true , Description : " " , Elem : & schema . Schema { Type : schema . Type String } , } , } } 
func build And Select Guest IPs ( d * schema . Resource Data , guest types . Guest Info ) error { log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) var v 4primary , v 6primary , v 4gw , v 6gw net . IP var v 4addrs , v 6addrs [ ] string case " " : v 6gw = net . Parse IP ( r . Gateway . Ip Address ) } } } } var mask net . IPMask if ip . To 4 ( ) ! = nil { v 4addrs = append ( v 4addrs , addr . Ip Address ) mask = net . CIDRMask ( int ( addr . Prefix Length ) , 3 2 ) if ip . Mask ( mask ) . Equal ( v 4gw . Mask ( mask ) ) & & v 4primary = = nil { v 4primary = ip } } else { v 6addrs = append ( v 6addrs , addr . Ip Address ) mask = net . CIDRMask ( int ( addr . Prefix Length ) , 1 2 8 ) if ip . Mask ( mask ) . Equal ( v 6gw . Mask ( mask ) ) & & v 6primary = = nil { v 6primary = ip } } } } } addrs : = make ( [ ] string , 0 ) addrs = append ( addrs , v 4addrs . . . ) addrs = append ( addrs , v 6addrs . . . ) } if len ( addrs ) < 1 { return d . Set ( " " , addrs ) } var primary string switch { case v 4primary ! = nil : primary = v 4primary . String ( ) case v 6primary ! = nil : primary = v 6primary . String ( ) default : primary = addrs [ 0 ] } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , primary ) d . Set ( " " , primary ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) , strings . Join ( addrs , " " ) ) if err : = d . Set ( " " , addrs ) ; err ! = nil { return err } d . Set Conn Info ( map [ string ] string { " " : " " , " " : primary , } ) return nil } 
func resource VSphere Compute Cluster VMAnti Affinity Rule Flatten ID ( cluster * object . Cluster Compute Resource , key int 3 2 ) ( string , error ) { cluster ID : = cluster . Reference ( ) . Value return strings . Join ( [ ] string { cluster ID , strconv . Itoa ( int ( key ) ) } , " " ) , nil } 
func resource VSphere Compute Cluster VMAnti Affinity Rule Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , int 3 2 , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster VMAnti Affinity Rule Objects From ID ( d , meta ) } return resource VSphere Compute Cluster VMAnti Affinity Rule Objects From Attributes ( d , meta ) } 
func schema Datastore Summary ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { } 
func flatten Datastore Summary ( d * schema . Resource Data , obj * types . Datastore Summary ) error { d . Set ( " " , obj . Accessible ) d . Set ( " " , structure . Byte To MB ( obj . Capacity ) ) d . Set ( " " , structure . Byte To MB ( obj . Free Space ) ) d . Set ( " " , obj . Maintenance Mode ) d . Set ( " " , obj . Multiple Host Access ) d . Set ( " " , structure . Byte To MB ( obj . Uncommitted ) ) d . Set ( " " , obj . Url ) } return nil } 
func resource VSphere Datastore Apply Folder Or Storage Cluster Path ( d * schema . Resource Data , meta interface { } ) ( string , error ) { var path string fvalue , fok : = d . Get Ok ( " " ) cvalue , cok : = d . Get Ok ( " " ) switch { case fok : path = fvalue . ( string ) case cok : return resource VSphere Datastore Storage Cluster Path Normalized ( meta , cvalue . ( string ) ) } return path , nil } 
func resource VSphere Datastore Read Folder Or Storage Cluster Path ( d * schema . Resource Data , ds * object . Datastore ) error { props , err : = datastore . Properties ( ds ) if err ! = nil { return fmt . Errorf ( " " , err ) } switch props . Parent . Type { case " " : return resource VSphere Datastore Read Folder Or Storage Cluster Path As Folder ( d , ds ) case " " : return resource VSphere Datastore Read Folder Or Storage Cluster Path Set Attributes ( d , " " , props . Parent . Value ) } return fmt . Errorf ( " " , props . Parent . Type ) } 
func Cdrom Subresource Schema ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { structure . Merge Schema ( s , subresource Schema ( ) ) return s } 
func New Cdrom Subresource ( client * govmomi . Client , rdd resource Data Diff , d , old map [ string ] interface { } , idx int ) * Cdrom Subresource { sr : = & Cdrom Subresource { Subresource : & Subresource { schema : Cdrom Subresource Schema ( ) , client : client , srtype : subresource Type Cdrom , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func Cdrom Apply Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( object . Virtual Device List , [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " ) ods : = o . ( [ ] interface { } ) nds : = n . ( [ ] interface { } ) var spec [ ] types . Base Virtual Device Config Spec next Old : for n , oe : = range ods { om : = oe . ( map [ string ] interface { } ) for _ , ne : = range nds { nm : = ne . ( map [ string ] interface { } ) if om [ " " ] = = nm [ " " ] { continue next Old } } r : = New Cdrom Subresource ( c , d , om , nil , n ) dspec , err : = r . Delete ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , dspec ) spec = append ( spec , dspec . . . ) } log . Printf ( " " ) for n , ne : = range nds { nm : = ne . ( map [ string ] interface { } ) if n < len ( ods ) { om : = oe . ( map [ string ] interface { } ) if nm [ " " ] ! = om [ " " ] { return nil , nil , fmt . Errorf ( " " , subresource Type Cdrom , n , nm [ " " ] . ( int ) , om [ " " ] . ( int ) ) } if reflect . Deep Equal ( nm , om ) { log . Printf ( " " , nm [ " " ] . ( int ) ) continue } r : = New Cdrom Subresource ( c , d , nm , om , n ) uspec , err : = r . Update ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , uspec ) spec = append ( spec , uspec . . . ) updates = append ( updates , r . Data ( ) ) continue } cspec , err : = r . Create ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , cspec ) spec = append ( spec , cspec . . . ) updates = append ( updates , r . Data ( ) ) } log . Printf ( " " , subresource List String ( updates ) ) } log . Printf ( " " , Device List String ( l ) ) log . Printf ( " " , Device Change String ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func Cdrom Refresh Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) error { log . Printf ( " " ) } return false } ) log . Printf ( " " , Device List String ( devices ) ) cur Set : = d . Get ( subresource Type Cdrom ) . ( [ ] interface { } ) log . Printf ( " " , subresource List String ( cur Set ) ) var new Set [ ] interface { } for n , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r : = New Cdrom Subresource ( c , d , m , nil , n ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } new Set = append ( new Set , r . Data ( ) ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] if device . Get Virtual Device ( ) . Key = = int 3 2 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } } } log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( new Set ) ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] for n , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 0 { } if device . Get Virtual Device ( ) . Key ! = int 3 2 ( m [ " " ] . ( int ) ) { } v App , err : = verify VApp Cdrom Iso ( d , device . ( * types . Virtual Cdrom ) , l , c ) if err ! = nil { return err } if v App = = true & & r . Get ( " " ) = = true { log . Printf ( " " , r ) r . Set ( " " , " " ) r . Set ( " " , " " ) } else { if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " , Device List String ( devices ) ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } r : = New Cdrom Subresource ( c , d , m , nil , n ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } new Set = append ( new Set , r . Data ( ) ) } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " ) return d . Set ( subresource Type Cdrom , new Set ) } 
func Cdrom Diff Operation ( d * schema . Resource Diff , c * govmomi . Client ) error { log . Printf ( " " ) cr : = d . Get ( subresource Type Cdrom ) for ci , ce : = range cr . ( [ ] interface { } ) { cm : = ce . ( map [ string ] interface { } ) r : = New Cdrom Subresource ( c , d , cm , nil , ci ) if err : = r . Validate Diff ( ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } log . Printf ( " " ) return nil } 
func ( r * Cdrom Subresource ) Validate Diff ( ) error { log . Printf ( " " , r ) ds ID : = r . Get ( " " ) . ( string ) path : = r . Get ( " " ) . ( string ) client Device : = r . Get ( " " ) . ( bool ) switch { case client Device & & ( ds ID ! = " " | | path ! = " " ) : return fmt . Errorf ( " " ) case ! client Device & & ( ds ID = = " " | | path = = " " ) : return fmt . Errorf ( " " ) } log . Printf ( " " , r ) return nil } 
func ( r * Cdrom Subresource ) Create ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) var spec [ ] types . Base Virtual Device Config Spec var ctlr types . Base Virtual Controller ctlr , err : = r . Controller For Create Update ( l , Subresource Controller Type IDE , 0 ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } } dspec , err : = object . Virtual Device List { device } . Config Spec ( types . Virtual Device Config Spec Operation Add ) if err ! = nil { return nil , err } spec = append ( spec , dspec . . . ) log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Cdrom Subresource ) Read ( l object . Virtual Device List ) error { log . Printf ( " " , r ) d , err : = r . Find Virtual Device ( l ) if err ! = nil { return fmt . Errorf ( " " , err ) } device , ok : = d . ( * types . Virtual Cdrom ) if ! ok { return fmt . Errorf ( " " , l . Name ( d ) ) } case * types . Virtual Cdrom Iso Backing Info : dp : = & object . Datastore Path { } if ok : = dp . From String ( backing . File Name ) ; ! ok { return fmt . Errorf ( " " , backing . File Name ) } } r . Set ( " " , dp . Path ) default : r . Set ( " " , " " ) r . Set ( " " , " " ) r . Set ( " " , false ) } if err ! = nil { return err } if err : = r . Save Dev IDs ( d , ctlr ) ; err ! = nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * Cdrom Subresource ) Update ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) d , err : = r . Find Virtual Device ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } device , ok : = d . ( * types . Virtual Cdrom ) if ! ok { return nil , fmt . Errorf ( " " , l . Name ( d ) ) } spec , err : = object . Virtual Device List { device } . Config Spec ( types . Virtual Device Config Spec Operation Edit ) if err ! = nil { return nil , err } log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Cdrom Subresource ) Delete ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) d , err : = r . Find Virtual Device ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } device , ok : = d . ( * types . Virtual Cdrom ) if ! ok { return nil , fmt . Errorf ( " " , l . Name ( d ) ) } delete Spec , err : = object . Virtual Device List { device } . Config Spec ( types . Virtual Device Config Spec Operation Remove ) if err ! = nil { return nil , err } log . Printf ( " " , r , Device Change String ( delete Spec ) ) log . Printf ( " " , r ) return delete Spec , nil } 
func ( r * Cdrom Subresource ) map Cdrom ( device * types . Virtual Cdrom , l object . Virtual Device List ) error { ds ID : = r . Get ( " " ) . ( string ) path : = r . Get ( " " ) . ( string ) client Device : = r . Get ( " " ) . ( bool ) switch { case ds ID ! = " " & & path ! = " " : if err ! = nil { return fmt . Errorf ( " " , err ) } ds Props , err : = datastore . Properties ( ds ) if err ! = nil { return fmt . Errorf ( " " , err ) } ds Name : = ds Props . Name ds Path : = & object . Datastore Path { Datastore : ds Name , Path : path , } device = l . Insert Iso ( device , ds Path . String ( ) ) l . Connect ( device ) return nil case client Device = = true : return nil } panic ( fmt . Sprintf ( " " , r ) ) } 
func Verify VApp Transport ( d * schema . Resource Diff , c * govmomi . Client ) error { log . Printf ( " " ) for _ , c : = range cl . ( [ ] interface { } ) { if c . ( map [ string ] interface { } ) [ " " ] . ( bool ) = = true { return nil } } for _ , m : = range tm { if m . ( string ) = = v App Transport Iso & & len ( tm ) = = 1 { return fmt . Errorf ( " " ) } } log . Printf ( " " ) return nil } 
func verify VApp Cdrom Iso ( d * schema . Resource Data , device * types . Virtual Cdrom , l object . Virtual Device List , c * govmomi . Client ) ( bool , error ) { log . Printf ( " " ) if ok : = dp . From String ( backing . File Name ) ; ! ok { return false , nil } if ! re . Match String ( dp . Path ) { log . Printf ( " " , dp . Path ) return false , nil } } else { return false , nil } log . Printf ( " " ) for _ , t : = range tm { if t . ( string ) = = " " { log . Printf ( " " ) return true , nil } } log . Printf ( " " ) return false , nil } 
func Datastore Path From String ( p string ) ( * object . Datastore Path , bool ) { dp : = new ( object . Datastore Path ) success : = dp . From String ( p ) log . Printf ( " " , success , p ) return dp , success } 
func Is Vmdk Datastore Path ( p string ) bool { dp , success : = Datastore Path From String ( p ) if ! success { log . Printf ( " " , p ) return false } is VMDK : = dp . Is VMDK ( ) log . Printf ( " " , p , structure . Log Cond ( is VMDK , " " , " " ) ) return is VMDK } 
func Move ( client * govmomi . Client , src Path string , src DC * object . Datacenter , dst Path string , dst DC * object . Datacenter ) ( string , error ) { vdm : = object . New Virtual Disk Manager ( client . Client ) if src DC = = nil { return " " , fmt . Errorf ( " " ) } if ! Is Vmdk Datastore Path ( src Path ) { return " " , fmt . Errorf ( " " , src Path ) } if ! Is Vmdk Datastore Path ( dst Path ) { ddp : = dst Data Store Path From Local Src ( src Path , dst Path ) } dst Path = ddp dst DC = nil } log . Printf ( " " , src Path , src DC , dst Path , structure . Log Cond ( dst DC ! = nil , fmt . Sprintf ( " " , dst DC ) , " " ) , ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = vdm . Move Virtual Disk ( ctx , src Path , src DC , dst Path , dst DC , false ) if err ! = nil { return " " , err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) if err : = task . Wait ( tctx ) ; err ! = nil { return " " , err } log . Printf ( " " , src Path , src DC , dst Path , structure . Log Cond ( dst DC ! = nil , fmt . Sprintf ( " " , dst DC ) , " " ) , ) return dst Path , nil } 
func Query Disk Type ( client * govmomi . Client , name string , dc * object . Datacenter ) ( types . Virtual Disk Type , error ) { vdm : = object . New Virtual Disk Manager ( client . Client ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) di , err : = vdm . Query Virtual Disk Info ( ctx , name , dc , false ) if err ! = nil { return types . Virtual Disk Type ( " " ) , err } t : = di [ 0 ] . Disk Type log . Printf ( " " , name , t ) return types . Virtual Disk Type ( t ) , nil } 
func Delete ( client * govmomi . Client , name string , dc * object . Datacenter ) error { if dc = = nil { return fmt . Errorf ( " " ) } log . Printf ( " " , name , dc ) vdm : = object . New Virtual Disk Manager ( client . Client ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = vdm . Delete Virtual Disk ( ctx , name , dc ) if err ! = nil { return err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) if err : = task . Wait ( tctx ) ; err ! = nil { return err } log . Printf ( " " , name , dc ) return nil } 
func soap Fault ( err error ) ( * soap . Fault , bool ) { if soap . Is Soap Fault ( err ) { return soap . To Soap Fault ( err ) , true } return nil , false } 
func vim Soap Fault ( err error ) ( types . Any Type , bool ) { if sf , ok : = soap Fault ( err ) ; ok { return sf . Vim Fault ( ) , true } return nil , false } 
func task Fault ( err error ) ( types . Base Method Fault , bool ) { if te , ok : = err . ( task . Error ) ; ok { return te . Fault ( ) , true } return nil , false } 
func Is Managed Object Not Found Error ( err error ) bool { if f , ok : = vim Soap Fault ( err ) ; ok { if _ , ok : = f . ( types . Managed Object Not Found ) ; ok { return true } } return false } 
func is Not Found Error ( err error ) bool { if f , ok : = vim Soap Fault ( err ) ; ok { if _ , ok : = f . ( types . Not Found ) ; ok { return true } } return false } 
func Is Any Not Found Error ( err error ) bool { switch { case Is Managed Object Not Found Error ( err ) : fallthrough case is Not Found Error ( err ) : return true } return false } 
func Is Resource In Use Error ( err error ) bool { if f , ok : = vim Soap Fault ( err ) ; ok { if _ , ok : = f . ( types . Resource In Use ) ; ok { return true } } return false } 
func is Concurrent Access Error ( err error ) bool { var ok bool f , ok = vim Soap Fault ( err ) if ! ok { f , ok = task Fault ( err ) } if ok { switch f . ( type ) { case types . Concurrent Access , * types . Concurrent Access : return true } } return false } 
func Rename Object ( client * govmomi . Client , ref types . Managed Object Reference , new string ) error { req : = types . Rename _Task { This : ref , New Name : new , } rctx , rcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer rcancel ( ) res , err : = methods . Rename _Task ( rctx , client . Client , & req ) if err ! = nil { return err } t : = object . New Task ( client . Client , res . Returnval ) tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) return t . Wait ( tctx ) } 
func Vim Validate Virtual Center ( c * vim 2 5 . Client ) error { if c . Service Content . About . Api Type ! = " " { return errors . New ( Err Virtual Center Only ) } return nil } 
func parse Version ( name , version , build string ) ( VSphere Version , error ) { v : = VSphere Version { Product : name , } s : = strings . Split ( version , " " ) if len ( s ) > 3 { return v , fmt . Errorf ( " " , version ) } var err error v . Major , err = strconv . Atoi ( s [ 0 ] ) if err ! = nil { return v , fmt . Errorf ( " " , s [ 0 ] , version ) } v . Minor , err = strconv . Atoi ( s [ 1 ] ) if err ! = nil { return v , fmt . Errorf ( " " , s [ 1 ] , version ) } v . Patch , err = strconv . Atoi ( s [ 2 ] ) if err ! = nil { return v , fmt . Errorf ( " " , s [ 2 ] , version ) } v . Build , err = strconv . Atoi ( build ) if err ! = nil { return v , fmt . Errorf ( " " , build ) } return v , nil } 
func parse Version From About Info ( info types . About Info ) VSphere Version { v , err : = parse Version ( info . Name , info . Version , info . Build ) if err ! = nil { panic ( err ) } return v } 
func Parse Version From Client ( client * govmomi . Client ) VSphere Version { return parse Version From About Info ( client . Client . Service Content . About ) } 
func ( v VSphere Version ) String ( ) string { return fmt . Sprintf ( " " , v . Product , v . Major , v . Minor , v . Patch , v . Build ) } 
func ( v VSphere Version ) Product Equal ( other VSphere Version ) bool { return v . Product = = other . Product } 
func ( v VSphere Version ) older Version ( other VSphere Version ) bool { vo : = other . Major < < 1 6 + other . Minor < < 8 + other . Patch return vc < vo } 
func ( v VSphere Version ) Older ( other VSphere Version ) bool { if ! v . Product Equal ( other ) { return false } if v . older Version ( other ) { return true } } if v . Build < other . Build { return true } return false } 
func ( v VSphere Version ) Equal ( other VSphere Version ) bool { return v . Product Equal ( other ) & & ! v . Older ( other ) & & ! v . Newer ( other ) } 
func expand Cluster VMGroup ( d * schema . Resource Data , meta interface { } , name string ) ( * types . Cluster Vm Group , error ) { client , err : = resource VSphere Compute Cluster VMGroup Client ( meta ) if err ! = nil { return nil , err } results , err : = virtualmachine . MOIDs For UUIDs ( client , structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err ! = nil { return nil , err } obj : = & types . Cluster Vm Group { Cluster Group Info : types . Cluster Group Info { Name : name , User Created : structure . Bool Ptr ( true ) , } , Vm : results . Managed Object References ( ) , } return obj , nil } 
func flatten Cluster VMGroup ( d * schema . Resource Data , meta interface { } , obj * types . Cluster Vm Group ) error { client , err : = resource VSphere Compute Cluster VMGroup Client ( meta ) if err ! = nil { return err } results , err : = virtualmachine . UUIDs For Managed Object References ( client , obj . Vm , ) if err ! = nil { return err } return structure . Set Batch ( d , map [ string ] interface { } { " " : results . UUIDs ( ) , } ) } 
func resource VSphere Compute Cluster VMGroup Find Entry ( cluster * object . Cluster Compute Resource , name string , ) ( * types . Cluster Vm Group , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Group { if info . Get Cluster Group Info ( ) . Name = = name { if vm Info , ok : = info . ( * types . Cluster Vm Group ) ; ok { log . Printf ( " " , name , cluster . Name ( ) ) return vm Info , nil } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } } log . Printf ( " " , name , cluster . Name ( ) ) return nil , nil } 
func resource VSphere Compute Cluster VMGroup Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , string , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster VMGroup Objects From ID ( d , meta ) } return resource VSphere Compute Cluster VMGroup Objects From Attributes ( d , meta ) } 
func resource VSphere Compute Cluster VMGroup Fetch Objects ( meta interface { } , cluster ID string , name string , ) ( * object . Cluster Compute Resource , string , error ) { client , err : = resource VSphere Compute Cluster VMGroup Client ( meta ) if err ! = nil { return nil , " " , err } cluster , err : = clustercomputeresource . From ID ( client , cluster ID ) if err ! = nil { return nil , " " , fmt . Errorf ( " " , err ) } return cluster , name , nil } 
func resource VSphere Resource Pool Apply Tags ( d * schema . Resource Data , meta interface { } , rp * object . Resource Pool ) error { tags Client , err : = tags Client If Defined ( d , meta ) if err ! = nil { return err } return nil } log . Printf ( " " , resource VSphere Resource Pool IDString ( d ) ) return process Tag Diff ( tags Client , d , rp ) } 
func resource VSphere Resource Pool Read Tags ( d * schema . Resource Data , meta interface { } , rp * object . Resource Pool ) error { if tags Client , _ : = meta . ( * VSphere Client ) . Tags Client ( ) ; tags Client ! = nil { log . Printf ( " " , resource VSphere Resource Pool IDString ( d ) ) if err : = read Tags For Resource ( tags Client , rp , d ) ; err ! = nil { return err } } else { log . Printf ( " " , resource VSphere Resource Pool IDString ( d ) ) } return nil } 
func expand Cluster Affinity Rule Spec ( d * schema . Resource Data , meta interface { } ) ( * types . Cluster Affinity Rule Spec , error ) { client , err : = resource VSphere Compute Cluster VMGroup Client ( meta ) if err ! = nil { return nil , err } results , err : = virtualmachine . MOIDs For UUIDs ( client , structure . Slice Interfaces To Strings ( d . Get ( " " ) . ( * schema . Set ) . List ( ) ) , ) if err ! = nil { return nil , err } obj : = & types . Cluster Affinity Rule Spec { Cluster Rule Info : types . Cluster Rule Info { Enabled : structure . Get Bool ( d , " " ) , Mandatory : structure . Get Bool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , User Created : structure . Bool Ptr ( true ) , } , Vm : results . Managed Object References ( ) , } return obj , nil } 
func flatten Cluster Affinity Rule Spec ( d * schema . Resource Data , meta interface { } , obj * types . Cluster Affinity Rule Spec ) error { client , err : = resource VSphere Compute Cluster VMGroup Client ( meta ) if err ! = nil { return err } results , err : = virtualmachine . UUIDs For Managed Object References ( client , obj . Vm , ) if err ! = nil { return err } return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : results . UUIDs ( ) , } ) } 
func resource VSphere Compute Cluster VMAffinity Rule Find Entry ( cluster * object . Cluster Compute Resource , key int 3 2 , ) ( * types . Cluster Affinity Rule Spec , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Rule { if info . Get Cluster Rule Info ( ) . Key = = key { if vm Affinity Rule Info , ok : = info . ( * types . Cluster Affinity Rule Spec ) ; ok { log . Printf ( " " , key , cluster . Name ( ) ) return vm Affinity Rule Info , nil } return nil , fmt . Errorf ( " " , key , cluster . Name ( ) ) } } log . Printf ( " " , key , cluster . Name ( ) ) return nil , nil } 
func resource VSphere Compute Cluster VMAffinity Rule Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , int 3 2 , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster VMAffinity Rule Objects From ID ( d , meta ) } return resource VSphere Compute Cluster VMAffinity Rule Objects From Attributes ( d , meta ) } 
func Config Schema ( ) * schema . Schema { return & schema . Schema { Type : schema . Type Map , Description : " " , Optional : true , } } 
func Read From Resource ( client * govmomi . Client , entity * mo . Managed Entity , d * schema . Resource Data ) { custom Attrs : = make ( map [ string ] interface { } ) if len ( entity . Custom Value ) > 0 { for _ , fv : = range entity . Custom Value { value : = fv . ( * types . Custom Field String Value ) . Value if value ! = " " { custom Attrs [ fmt . Sprint ( fv . Get Custom Field Value ( ) . Key ) ] = value } } } d . Set ( Config Key , custom Attrs ) } 
func Virtual Machine Clone Schema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . Type String , Required : true , Description : " " , } , " " : { Type : schema . Type Bool , Optional : true , Description : " " , } , " " : { Type : schema . Type Int , Optional : true , Default : 3 0 , Description : " " , Validate Func : validation . Int At Least ( 1 0 ) , } , " " : { Type : schema . Type List , Optional : true , Max Items : 1 , Description : " " , Elem : & schema . Resource { Schema : Virtual Machine Customize Schema ( ) } , } , } } 
func Validate Virtual Machine Clone ( d * schema . Resource Diff , c * govmomi . Client ) error { t UUID : = d . Get ( " " ) . ( string ) log . Printf ( " " , t UUID ) vm , err : = virtualmachine . From UUID ( c , t UUID ) if err ! = nil { return fmt . Errorf ( " " , t UUID , err ) } vprops , err : = virtualmachine . Properties ( vm ) if err ! = nil { return fmt . Errorf ( " " , err ) } } a Guest ID : = d . Get ( " " ) . ( string ) if e Guest ID ! = a Guest ID { return fmt . Errorf ( " " , a Guest ID , e Guest ID ) } if linked { log . Printf ( " " , t UUID ) if err : = validate Clone Snapshots ( vprops ) ; err ! = nil { return err } } if err : = virtualdevice . Disk Clone Validate Operation ( d , c , l , linked ) ; err ! = nil { return err } if err ! = nil { return fmt . Errorf ( " " , pool ID , err ) } family , err : = resourcepool . OSFamily ( c , pool , d . Get ( " " ) . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , d . Get ( " " ) . ( string ) , err ) } if err : = Validate Customization Spec ( d , family ) ; err ! = nil { return err } } else { log . Printf ( " " ) } } vconfig : = vprops . Config . VApp Config if vconfig ! = nil { } log . Printf ( " " , t UUID ) return nil } 
func validate Clone Snapshots ( props * mo . Virtual Machine ) error { if props . Snapshot = = nil { return fmt . Errorf ( " " , props . Config . Uuid ) } } } } return nil } 
func Expand Virtual Machine Clone Spec ( d * schema . Resource Data , c * govmomi . Client ) ( types . Virtual Machine Clone Spec , * object . Virtual Machine , error ) { var spec types . Virtual Machine Clone Spec log . Printf ( " " ) if err ! = nil { return spec , nil , fmt . Errorf ( " " , err ) } spec . Location . Datastore = types . New Reference ( ds . Reference ( ) ) } t UUID : = d . Get ( " " ) . ( string ) log . Printf ( " " , t UUID ) vm , err : = virtualmachine . From UUID ( c , t UUID ) if err ! = nil { return spec , nil , fmt . Errorf ( " " , t UUID , err ) } vprops , err : = virtualmachine . Properties ( vm ) if err ! = nil { return spec , nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , t UUID ) if err : = validate Clone Snapshots ( vprops ) ; err ! = nil { return spec , nil , err } spec . Snapshot = vprops . Snapshot . Current Snapshot spec . Location . Disk Move Type = string ( types . Virtual Machine Relocate Disk Move Options Create New Child Disk Backing ) log . Printf ( " " , vprops . Snapshot . Current Snapshot . Value ) } pool , err : = resourcepool . From ID ( c , pool ID ) if err ! = nil { return spec , nil , fmt . Errorf ( " " , pool ID , err ) } var hs * object . Host System if v , ok : = d . Get Ok ( " " ) ; ok { hs ID : = v . ( string ) var err error if hs , err = hostsystem . From ID ( c , hs ID ) ; err ! = nil { return spec , nil , fmt . Errorf ( " " , hs ID , err ) } } } pool Ref : = pool . Reference ( ) spec . Location . Pool = & pool Ref if hs ! = nil { hs Ref : = hs . Reference ( ) spec . Location . Host = & hs Ref } relocators , err : = virtualdevice . Disk Clone Relocate Operation ( d , c , l ) if err ! = nil { return spec , nil , err } spec . Location . Disk = relocators log . Printf ( " " ) return spec , vm , nil } 
func Reference Properties ( client * govmomi . Client , net object . Network Reference ) ( * mo . Network , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Network nc : = object . New Common ( client . Client , net . Reference ( ) ) if err : = nc . Properties ( ctx , nc . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Properties ( net * object . Network ) ( * mo . Network , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Network if err : = net . Properties ( ctx , net . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func System Or Default ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . Host System , error ) { finder : = find . New Finder ( client . Client , false ) finder . Set Datacenter ( dc ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) t : = client . Service Content . About . Api Type switch t { case " " : return finder . Default Host System ( ctx ) case " " : if name ! = " " { return finder . Host System ( ctx , name ) } return finder . Default Host System ( ctx ) } return nil , fmt . Errorf ( " " , t ) } 
func Properties ( host * object . Host System ) ( * mo . Host System , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Host System if err : = host . Properties ( ctx , host . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Resource Pool ( host * object . Host System ) ( * object . Resource Pool , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) return host . Resource Pool ( ctx ) } 
func host System Name From ID ( client * govmomi . Client , id string ) ( string , error ) { hs , err : = From ID ( client , id ) if err ! = nil { return " " , err } return hs . Name ( ) , nil } 
func Name Or ID ( client * govmomi . Client , id string ) string { name , err : = host System Name From ID ( client , id ) if err ! = nil { return id } return name } 
func Enter Maintenance Mode ( host * object . Host System , timeout int , evacuate bool ) error { if err : = viapi . Vim Validate Virtual Center ( host . Client ( ) ) ; err ! = nil { evacuate = false } log . Printf ( " " , host . Name ( ) , evacuate ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Second * time . Duration ( timeout ) ) defer cancel ( ) task , err : = host . Enter Maintenance Mode ( ctx , int 3 2 ( timeout ) , evacuate , nil ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func Exit Maintenance Mode ( host * object . Host System , timeout int ) error { log . Printf ( " " , host . Name ( ) ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Second * time . Duration ( ctx Timeout ) ) defer cancel ( ) task , err : = host . Exit Maintenance Mode ( ctx , int 3 2 ( timeout ) ) if err ! = nil { return err } return task . Wait ( ctx ) } 
func dvs From UUID ( client * govmomi . Client , uuid string ) ( * object . Vmware Distributed Virtual Switch , error ) { dvsm : = types . Managed Object Reference { Type : " " , Value : " " } req : = & types . Query Dvs By Uuid { This : dvsm , Uuid : uuid , } resp , err : = methods . Query Dvs By Uuid ( context . TODO ( ) , client , req ) if err ! = nil { return nil , err } return dvs From MOID ( client , resp . Returnval . Reference ( ) . Value ) } 
func dvs From Path ( client * govmomi . Client , name string , dc * object . Datacenter ) ( * object . Vmware Distributed Virtual Switch , error ) { net , err : = network . From Path ( client , name , dc ) if err ! = nil { return nil , err } if net . Reference ( ) . Type ! = " " { return nil , fmt . Errorf ( " " , name , net . Reference ( ) . Type ) } return dvs From MOID ( client , net . Reference ( ) . Value ) } 
func dvs Properties ( dvs * object . Vmware Distributed Virtual Switch ) ( * mo . Vmware Distributed Virtual Switch , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) var props mo . Vmware Distributed Virtual Switch if err : = dvs . Properties ( ctx , dvs . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func upgrade DVS ( client * govmomi . Client , dvs * object . Vmware Distributed Virtual Switch , version string ) error { req : = & types . Perform Dvs Product Spec Operation _Task { This : dvs . Reference ( ) , Operation : " " , Product Spec : & types . Distributed Virtual Switch Product Spec { Version : version , } , } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) resp , err : = methods . Perform Dvs Product Spec Operation _Task ( ctx , client , req ) if err ! = nil { return err } task : = object . New Task ( client . Client , resp . Returnval ) tctx , tcancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer tcancel ( ) if err : = task . Wait ( tctx ) ; err ! = nil { return err } return nil } 
func update DVSConfiguration ( client * govmomi . Client , dvs * object . Vmware Distributed Virtual Switch , spec * types . VMware DVSConfig Spec ) error { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) task , err : = dvs . Reconfigure ( ctx , spec ) if err ! = nil { return err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer tcancel ( ) if err : = task . Wait ( tctx ) ; err ! = nil { return err } return nil } 
func enable DVSNetwork Resource Management ( client * govmomi . Client , dvs * object . Vmware Distributed Virtual Switch , enabled bool ) error { req : = & types . Enable Network Resource Management { This : dvs . Reference ( ) , Enable : enabled , } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) _ , err : = methods . Enable Network Resource Management ( ctx , client , req ) if err ! = nil { return err } return nil } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Flatten ID ( pod * object . Storage Pod , key int 3 2 ) ( string , error ) { pod ID : = pod . Reference ( ) . Value return strings . Join ( [ ] string { pod ID , strconv . Itoa ( int ( key ) ) } , " " ) , nil } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Find Entry ( pod * object . Storage Pod , key int 3 2 , ) ( * types . Cluster Anti Affinity Rule Spec , error ) { props , err : = storagepod . Properties ( pod ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Pod Storage Drs Entry . Storage Drs Config . Pod Config . Rule { if info . Get Cluster Rule Info ( ) . Key = = key { if vm Anti Affinity Rule Info , ok : = info . ( * types . Cluster Anti Affinity Rule Spec ) ; ok { log . Printf ( " " , key , pod . Name ( ) ) return vm Anti Affinity Rule Info , nil } return nil , fmt . Errorf ( " " , key , pod . Name ( ) ) } } log . Printf ( " " , key , pod . Name ( ) ) return nil , nil } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Find Entry By Name ( pod * object . Storage Pod , name string , ) ( * types . Cluster Anti Affinity Rule Spec , error ) { props , err : = storagepod . Properties ( pod ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Pod Storage Drs Entry . Storage Drs Config . Pod Config . Rule { if info . Get Cluster Rule Info ( ) . Name = = name { if vm Anti Affinity Rule Info , ok : = info . ( * types . Cluster Anti Affinity Rule Spec ) ; ok { log . Printf ( " " , name , pod . Name ( ) ) return vm Anti Affinity Rule Info , nil } return nil , fmt . Errorf ( " " , name , pod . Name ( ) ) } } return nil , fmt . Errorf ( " " , name , pod . Name ( ) ) } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Storage Pod , int 3 2 , error ) { if d . Id ( ) ! = " " { return resource VSphere Datastore Cluster VMAnti Affinity Rule Objects From ID ( d , meta ) } return resource VSphere Datastore Cluster VMAnti Affinity Rule Objects From Attributes ( d , meta ) } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Fetch Objects ( meta interface { } , pod ID string , key int 3 2 , ) ( * object . Storage Pod , int 3 2 , error ) { client , err : = resource VSphere Datastore Cluster VMAnti Affinity Rule Client ( meta ) if err ! = nil { return nil , 0 , err } pod , err : = storagepod . From ID ( client , pod ID ) if err ! = nil { return nil , 0 , fmt . Errorf ( " " , err ) } return pod , key , nil } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Apply SDRSConfig Spec ( pod * object . Storage Pod , spec types . Storage Drs Config Spec , ) error { return storagepod . Apply DRSConfiguration ( & govmomi . Client { Client : pod . Client ( ) , } , pod , spec , ) } 
func resource VSphere Datastore Cluster VMAnti Affinity Rule Validate Rule VMCount ( d * schema . Resource Data ) error { if d . Get ( " " ) . ( * schema . Set ) . Len ( ) < 2 { return errors . New ( " " ) } return nil } 
func controller Type To Class ( c types . Base Virtual Controller ) ( string , error ) { var t string switch c . ( type ) { case * types . Virtual IDEController : t = Subresource Controller Type IDE case * types . Virtual AHCIController : t = Subresource Controller Type SATA case * types . Virtual PCIController : t = Subresource Controller Type PCI case * types . Para Virtual SCSIController , * types . Virtual Bus Logic Controller , * types . Virtual Lsi Logic Controller , * types . Virtual Lsi Logic SASController : t = Subresource Controller Type SCSI default : return subresource Controller Type Unknown , fmt . Errorf ( " " , c ) } return t , nil } 
func subresource Schema ( ) map [ string ] * schema . Schema { return map [ string ] * schema . Schema { " " : { Type : schema . Type Int , Computed : true , Description : " " , } , " " : { Type : schema . Type String , Computed : true , Description : " " , } , } } 
func ( r * Subresource ) Addr ( ) string { return fmt . Sprintf ( " " , r . srtype , r . Index ) } 
func ( r * Subresource ) Set ( key string , value interface { } ) { if v : = structure . Normalize Value ( value ) ; v ! = nil { r . data [ key ] = v } } 
func ( r * Subresource ) Has Change ( key string ) bool { o , n : = r . Get Change ( key ) return ! reflect . Deep Equal ( o , n ) } 
func ( r * Subresource ) Get Change ( key string ) ( interface { } , interface { } ) { new : = r . data [ key ] if r . olddata ! = nil { old = r . olddata [ key ] } return old , new } 
func ( r * Subresource ) Get With Restart ( key string ) interface { } { if r . Has Change ( key ) { r . Set Restart ( key ) } return r . Get ( key ) } 
func ( r * Subresource ) Get With Veto ( key string ) ( interface { } , error ) { if r . Has Change ( key ) { old , new : = r . Get Change ( key ) return r . Get ( key ) , fmt . Errorf ( " " , key , old , new ) } return r . Get ( key ) , nil } 
func ( r * Subresource ) Set Restart ( key string ) { log . Printf ( " " , r , key ) switch d : = r . rdd . ( type ) { case * schema . Resource Data : d . Set ( " " , true ) case * schema . Resource Diff : d . Set New ( " " , true ) default : } } 
func ( r * Subresource ) Hash ( ) int { hf : = schema . Hash Resource ( & schema . Resource { Schema : r . schema } ) return hf ( r . data ) } 
func compute Dev Addr ( device types . Base Virtual Device , ctlr types . Base Virtual Controller ) ( string , error ) { vd : = device . Get Virtual Device ( ) vc : = ctlr . Get Virtual Controller ( ) ctype , err : = controller Type To Class ( ctlr ) if err ! = nil { return " " , err } parts : = [ ] string { ctype , strconv . Itoa ( int ( vc . Bus Number ) ) , strconv . Itoa ( int ( structure . De Ref ( vd . Unit Number ) . ( int 3 2 ) ) ) , } return strings . Join ( parts , " " ) , nil } 
func ( r * Subresource ) Save Dev IDs ( device types . Base Virtual Device , ctlr types . Base Virtual Controller ) error { r . Set ( " " , device . Get Virtual Device ( ) . Key ) addr , err : = compute Dev Addr ( device , ctlr ) if err ! = nil { return err } r . Set ( " " , addr ) return nil } 
func split Dev Addr ( id string ) ( string , int , int , error ) { parts : = strings . Split ( id , " " ) if len ( parts ) < 3 { return " " , 0 , 0 , fmt . Errorf ( " " , id ) } ct , cbs , dus : = parts [ 0 ] , parts [ 1 ] , parts [ 2 ] cb , cbe : = strconv . Atoi ( cbs ) du , due : = strconv . Atoi ( dus ) var found bool for _ , v : = range subresource IDController Type Allowed Values { if v = = ct { found = true } } if ! found { return ct , cb , du , fmt . Errorf ( " " , ct ) } if cbe ! = nil { return ct , cb , du , fmt . Errorf ( " " , cbs ) } if due ! = nil { return ct , cb , du , fmt . Errorf ( " " , dus ) } return ct , cb , du , nil } 
func find Virtual Device In List Controller Select Func ( ct string , cb int ) func ( types . Base Virtual Device ) bool { return func ( device types . Base Virtual Device ) bool { switch ct { case Subresource Controller Type IDE : if _ , ok : = device . ( * types . Virtual IDEController ) ; ! ok { return false } case Subresource Controller Type SATA : if _ , ok : = device . ( * types . Virtual AHCIController ) ; ! ok { return false } case Subresource Controller Type SCSI : if _ , ok : = device . ( types . Base Virtual SCSIController ) ; ! ok { return false } case Subresource Controller Type PCI : if _ , ok : = device . ( * types . Virtual PCIController ) ; ! ok { return false } } vc : = device . ( types . Base Virtual Controller ) . Get Virtual Controller ( ) if vc . Bus Number = = int 3 2 ( cb ) { return true } return false } } 
func find Virtual Device In List Device Select Func ( ckey int 3 2 , du int ) func ( types . Base Virtual Device ) bool { return func ( d types . Base Virtual Device ) bool { vd : = d . Get Virtual Device ( ) if vd . Controller Key = = ckey & & vd . Unit Number ! = nil & & * vd . Unit Number = = int 3 2 ( du ) { return true } return false } } 
func find Controller For Device ( l object . Virtual Device List , bvd types . Base Virtual Device ) ( types . Base Virtual Controller , error ) { vd : = bvd . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return nil , fmt . Errorf ( " " , vd . Controller Key , vd . Key ) } return ctlr . ( types . Base Virtual Controller ) , nil } 
func ( r * Subresource ) Find Virtual Device By Addr ( l object . Virtual Device List ) ( types . Base Virtual Device , error ) { log . Printf ( " " , r . Dev Addr ( ) ) ct , cb , du , err : = split Dev Addr ( r . Dev Addr ( ) ) if err ! = nil { return nil , err } ctlrs : = l . Select ( csf ) if len ( ctlrs ) ! = 1 { return nil , fmt . Errorf ( " " , len ( ctlrs ) , ct , cb ) } ctlr : = ctlrs [ 0 ] dsf : = find Virtual Device In List Device Select Func ( ckey , du ) devices : = l . Select ( dsf ) if len ( devices ) ! = 1 { return nil , fmt . Errorf ( " " , len ( devices ) , ckey , du ) } device : = devices [ 0 ] log . Printf ( " " , l . Name ( device ) ) return device , nil } 
func ( r * Subresource ) Find Virtual Device ( l object . Virtual Device List ) ( types . Base Virtual Device , error ) { if key : = r . Get ( " " ) . ( int ) ; key > 0 { log . Printf ( " " , key ) if dev : = l . Find By Key ( int 3 2 ( key ) ) ; dev ! = nil { log . Printf ( " " , l . Name ( dev ) ) return dev , nil } return nil , fmt . Errorf ( " " , key ) } return r . Find Virtual Device By Addr ( l ) } 
func ( r * Subresource ) String ( ) string { devaddr : = r . Get ( " " ) . ( string ) if devaddr = = " " { devaddr = " " } return fmt . Sprintf ( " " , r . Addr ( ) , r . Get ( " " ) . ( int ) , devaddr ) } 
func swap SCSIDevice ( l object . Virtual Device List , device types . Base Virtual SCSIController , ct string , st string ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , ct , l . Name ( device . ( types . Base Virtual Device ) ) ) var spec [ ] types . Base Virtual Device Config Spec bvd : = device . ( types . Base Virtual Device ) cspec , err : = object . Virtual Device List { bvd } . Config Spec ( types . Virtual Device Config Spec Operation Remove ) if err ! = nil { return nil , err } spec = append ( spec , cspec . . . ) nsd , err : = l . Create SCSIController ( ct ) if err ! = nil { return nil , err } nsd . ( types . Base Virtual SCSIController ) . Get Virtual SCSIController ( ) . Shared Bus = types . Virtual SCSISharing ( st ) nsd . ( types . Base Virtual SCSIController ) . Get Virtual SCSIController ( ) . Bus Number = device . Get Virtual SCSIController ( ) . Bus Number cspec , err = object . Virtual Device List { nsd } . Config Spec ( types . Virtual Device Config Spec Operation Add ) if err ! = nil { return nil , err } spec = append ( spec , cspec . . . ) ockey : = device . Get Virtual SCSIController ( ) . Key nckey : = nsd . Get Virtual Device ( ) . Key for _ , vd : = range l { if vd . Get Virtual Device ( ) . Controller Key = = ockey { vd . Get Virtual Device ( ) . Controller Key = nckey cspec , err : = object . Virtual Device List { vd } . Config Spec ( types . Virtual Device Config Spec Operation Edit ) if err ! = nil { return nil , err } if len ( cspec ) ! = 1 { return nil , fmt . Errorf ( " " , len ( cspec ) ) } spec = append ( spec , cspec . . . ) } } log . Printf ( " " , Device Change String ( spec ) ) return spec , nil } 
func Normalize SCSIBus ( l object . Virtual Device List , ct string , count int , st string ) ( object . Virtual Device List , [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , count , ct ) var spec [ ] types . Base Virtual Device Config Spec ctlrs : = make ( [ ] types . Base Virtual SCSIController , count ) for _ , dev : = range l { if sc , ok : = dev . ( types . Base Virtual SCSIController ) ; ok { if bus Number : = sc . Get Virtual SCSIController ( ) . Bus Number ; bus Number < i Count { ctlrs [ bus Number ] = sc } } } log . Printf ( " " , scsi Controller List String ( ctlrs ) ) cspec , err : = create SCSIController ( & l , ct , st ) if err ! = nil { return nil , nil , err } spec = append ( spec , cspec . . . ) continue } if l . Type ( ctlr . ( types . Base Virtual Device ) ) = = ct { cspec , err : = set SCSIBus Sharing ( & l , ctlr , st ) if err ! = nil { return nil , nil , err } spec = append ( spec , cspec . . . ) continue } cspec , err : = swap SCSIDevice ( l , ctlr , ct , st ) if err ! = nil { return nil , nil , err } spec = append ( spec , cspec . . . ) l = apply Device Change ( l , cspec ) continue } log . Printf ( " " , Device List String ( l ) ) log . Printf ( " " , Device Change String ( spec ) ) return l , spec , nil } 
func set SCSIBus Sharing ( l * object . Virtual Device List , ctlr types . Base Virtual SCSIController , st string ) ( [ ] types . Base Virtual Device Config Spec , error ) { var cspec [ ] types . Base Virtual Device Config Spec if ctlr . Get Virtual SCSIController ( ) . Shared Bus ! = types . Virtual SCSISharing ( st ) { ctlr . Get Virtual SCSIController ( ) . Shared Bus = types . Virtual SCSISharing ( st ) var err error cspec , err = object . Virtual Device List { ctlr . ( types . Base Virtual Device ) } . Config Spec ( types . Virtual Device Config Spec Operation Edit ) if err ! = nil { return nil , err } * l = apply Device Change ( * l , cspec ) } return cspec , nil } 
func create SCSIController ( l * object . Virtual Device List , ct string , st string ) ( [ ] types . Base Virtual Device Config Spec , error ) { nc , err : = l . Create SCSIController ( ct ) if err ! = nil { return nil , err } nc . ( types . Base Virtual SCSIController ) . Get Virtual SCSIController ( ) . Shared Bus = types . Virtual SCSISharing ( st ) cspec , err : = object . Virtual Device List { nc } . Config Spec ( types . Virtual Device Config Spec Operation Add ) * l = apply Device Change ( * l , cspec ) return cspec , err } 
func Read SCSIBus Type ( l object . Virtual Device List , count int ) string { ctlrs : = make ( [ ] types . Base Virtual SCSIController , count ) for _ , dev : = range l { if sc , ok : = dev . ( types . Base Virtual SCSIController ) ; ok & & sc . Get Virtual SCSIController ( ) . Bus Number < int 3 2 ( count ) { ctlrs [ sc . Get Virtual SCSIController ( ) . Bus Number ] = sc } } log . Printf ( " " , count , scsi Controller List String ( ctlrs ) ) if ctlrs [ 0 ] = = nil { return subresource Controller Type Unknown } last : = l . Type ( ctlrs [ 0 ] . ( types . Base Virtual Device ) ) for _ , ctlr : = range ctlrs [ 1 : ] { if ctlr = = nil | | l . Type ( ctlr . ( types . Base Virtual Device ) ) ! = last { return subresource Controller Type Mixed } } return last } 
func Read SCSIBus Sharing ( l object . Virtual Device List , count int ) string { ctlrs : = make ( [ ] types . Base Virtual SCSIController , count ) for _ , dev : = range l { if sc , ok : = dev . ( types . Base Virtual SCSIController ) ; ok & & sc . Get Virtual SCSIController ( ) . Bus Number < int 3 2 ( count ) { ctlrs [ sc . Get Virtual SCSIController ( ) . Bus Number ] = sc } } log . Printf ( " " , count , scsi Controller List String ( ctlrs ) ) if ctlrs [ 0 ] = = nil { return subresource Controller Sharing Unknown } last : = ctlrs [ 0 ] . ( types . Base Virtual SCSIController ) . Get Virtual SCSIController ( ) . Shared Bus for _ , ctlr : = range ctlrs [ 1 : ] { if ctlr = = nil | | ctlr . ( types . Base Virtual SCSIController ) . Get Virtual SCSIController ( ) . Shared Bus ! = last { return subresource Controller Sharing Mixed } } return string ( last ) } 
func pick SCSIController ( l object . Virtual Device List , bus int ) ( types . Base Virtual Controller , error ) { log . Printf ( " " , bus ) l = l . Select ( func ( device types . Base Virtual Device ) bool { switch d : = device . ( type ) { case types . Base Virtual SCSIController : return d . Get Virtual SCSIController ( ) . Bus Number = = int 3 2 ( bus ) } return false } ) if len ( l ) = = 0 { return nil , fmt . Errorf ( " " , bus ) } log . Printf ( " " , l . Name ( l [ 0 ] ) ) return l [ 0 ] . ( types . Base Virtual Controller ) , nil } 
func ( r * Subresource ) Controller For Create Update ( l object . Virtual Device List , ct string , bus int ) ( types . Base Virtual Controller , error ) { log . Printf ( " " , ct ) var ctlr types . Base Virtual Controller var err error switch ct { case Subresource Controller Type IDE : ctlr = l . Pick Controller ( & types . Virtual IDEController { } ) case Subresource Controller Type SATA : ctlr = l . Pick Controller ( & types . Virtual AHCIController { } ) case Subresource Controller Type SCSI : ctlr , err = pick SCSIController ( l , bus ) case Subresource Controller Type PCI : ctlr = l . Pick Controller ( & types . Virtual PCIController { } ) default : return nil , fmt . Errorf ( " " , ct ) } if err ! = nil { return nil , err } if ctlr = = nil { return nil , fmt . Errorf ( " " , ct ) } } log . Printf ( " " , l . Name ( ctlr . ( types . Base Virtual Device ) ) ) return ctlr , nil } 
func apply Device Change ( l object . Virtual Device List , cs [ ] types . Base Virtual Device Config Spec ) object . Virtual Device List { log . Printf ( " " , Device Change String ( cs ) ) log . Printf ( " " , Device List String ( l ) ) for _ , s : = range cs { spec : = s . Get Virtual Device Config Spec ( ) switch spec . Operation { case types . Virtual Device Config Spec Operation Add : l = append ( l , spec . Device ) case types . Virtual Device Config Spec Operation Edit : } } case types . Virtual Device Config Spec Operation Remove : for i : = 0 ; i < len ( l ) ; i + + { dev : = l [ i ] if dev . Get Virtual Device ( ) . Key = = spec . Device . Get Virtual Device ( ) . Key { l = append ( l [ : i ] , l [ i + 1 : ] . . . ) i - - } } default : panic ( " " ) } } log . Printf ( " " , Device List String ( l ) ) return l } 
func Device List String ( l object . Virtual Device List ) string { var names [ ] string for _ , d : = range l { if d = = nil { names = append ( names , " " ) } else { names = append ( names , l . Name ( d ) ) } } return strings . Join ( names , " " ) } 
func Device Change String ( specs [ ] types . Base Virtual Device Config Spec ) string { var strs [ ] string for _ , v : = range specs { spec : = v . Get Virtual Device Config Spec ( ) strs = append ( strs , fmt . Sprintf ( " " , string ( spec . Operation ) , spec . Device , spec . Device . Get Virtual Device ( ) . Key ) ) } return strings . Join ( strs , " " ) } 
func subresource List String ( data [ ] interface { } ) string { var strs [ ] string for _ , v : = range data { if v = = nil { strs = append ( strs , " " ) continue } m : = v . ( map [ string ] interface { } ) devaddr : = m [ " " ] . ( string ) if devaddr = = " " { devaddr = " " } strs = append ( strs , fmt . Sprintf ( " " , m [ " " ] . ( int ) , devaddr ) ) } return strings . Join ( strs , " " ) } 
func scsi Controller List String ( ctlrs [ ] types . Base Virtual SCSIController ) string { var l object . Virtual Device List for _ , ctlr : = range ctlrs { if ctlr = = nil { l = append ( l , types . Base Virtual Device ( nil ) ) } else { l = append ( l , ctlr . ( types . Base Virtual Device ) ) } } return Device List String ( l ) } 
func Append Device Change Spec ( spec [ ] types . Base Virtual Device Config Spec , ops . . . types . Base Virtual Device Config Spec , ) [ ] types . Base Virtual Device Config Spec { for _ , op : = range ops { c : = copystructure . Must ( copystructure . Copy ( op ) ) . ( types . Base Virtual Device Config Spec ) spec = append ( spec , c ) } return spec } 
func expand Cluster Dependency Rule Info ( d * schema . Resource Data ) ( * types . Cluster Dependency Rule Info , error ) { obj : = & types . Cluster Dependency Rule Info { Cluster Rule Info : types . Cluster Rule Info { Enabled : structure . Get Bool ( d , " " ) , Mandatory : structure . Get Bool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , User Created : structure . Bool Ptr ( true ) , } , Depends On Vm Group : d . Get ( " " ) . ( string ) , Vm Group : d . Get ( " " ) . ( string ) , } return obj , nil } 
func flatten Cluster Dependency Rule Info ( d * schema . Resource Data , obj * types . Cluster Dependency Rule Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : obj . Depends On Vm Group , " " : obj . Vm Group , } ) } 
func resource VSphere Compute Cluster VMDependency Rule Parse ID ( id string ) ( string , int 3 2 , error ) { parts : = strings . Split N ( id , " " , 3 ) if len ( parts ) < 2 { return " " , 0 , fmt . Errorf ( " " , id ) } key , err : = strconv . Atoi ( parts [ 1 ] ) if err ! = nil { return " " , 0 , fmt . Errorf ( " " , parts [ 1 ] , err ) } return parts [ 0 ] , int 3 2 ( key ) , nil } 
func resource VSphere Compute Cluster VMDependency Rule Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , int 3 2 , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster VMDependency Rule Objects From ID ( d , meta ) } return resource VSphere Compute Cluster VMDependency Rule Objects From Attributes ( d , meta ) } 
func resource VSphere Compute Cluster VMDependency Rule Fetch Objects ( meta interface { } , cluster ID string , key int 3 2 , ) ( * object . Cluster Compute Resource , int 3 2 , error ) { client , err : = resource VSphere Compute Cluster VMDependency Rule Client ( meta ) if err ! = nil { return nil , 0 , err } cluster , err : = clustercomputeresource . From ID ( client , cluster ID ) if err ! = nil { return nil , 0 , fmt . Errorf ( " " , err ) } return cluster , key , nil } 
func Provider ( ) terraform . Resource Provider { return & schema . Provider { Schema : map [ string ] * schema . Schema { " " : { Type : schema . Type String , Required : true , Default Func : schema . Env Default Func ( " " , nil ) , Description : " " , } , " " : { Type : schema . Type String , Required : true , Default Func : schema . Env Default Func ( " " , nil ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , nil ) , Description : " " , } , " " : { Type : schema . Type Bool , Optional : true , Default Func : schema . Env Default Func ( " " , false ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , nil ) , Deprecated : " " , } , " " : { Type : schema . Type Bool , Optional : true , Default Func : schema . Env Default Func ( " " , false ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , " " ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , " " ) , Description : " " , } , " " : { Type : schema . Type Bool , Optional : true , Default Func : schema . Env Default Func ( " " , false ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , filepath . Join ( os . Getenv ( " " ) , " " , " " ) ) , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default Func : schema . Env Default Func ( " " , filepath . Join ( os . Getenv ( " " ) , " " , " " ) ) , Description : " " , } , } , Resources Map : map [ string ] * schema . Resource { " " : resource VSphere Compute Cluster ( ) , " " : resource VSphere Compute Cluster Host Group ( ) , " " : resource VSphere Compute Cluster VMAffinity Rule ( ) , " " : resource VSphere Compute Cluster VMAnti Affinity Rule ( ) , " " : resource VSphere Compute Cluster VMDependency Rule ( ) , " " : resource VSphere Compute Cluster VMGroup ( ) , " " : resource VSphere Compute Cluster VMHost Rule ( ) , " " : resource VSphere Custom Attribute ( ) , " " : resource VSphere Datacenter ( ) , " " : resource VSphere Datastore Cluster ( ) , " " : resource VSphere Datastore Cluster VMAnti Affinity Rule ( ) , " " : resource VSphere Distributed Port Group ( ) , " " : resource VSphere Distributed Virtual Switch ( ) , " " : resource VSphere DRSVMOverride ( ) , " " : resource VSphere DPMHost Override ( ) , " " : resource VSphere File ( ) , " " : resource VSphere Folder ( ) , " " : resource VSphere HAVMOverride ( ) , " " : resource VSphere Host Port Group ( ) , " " : resource VSphere Host Virtual Switch ( ) , " " : resource VSphere License ( ) , " " : resource VSphere Resource Pool ( ) , " " : resource VSphere Tag ( ) , " " : resource VSphere Tag Category ( ) , " " : resource VSphere Virtual Disk ( ) , " " : resource VSphere Virtual Machine ( ) , " " : resource VSphere Nas Datastore ( ) , " " : resource VSphere Storage Drs VMOverride ( ) , " " : resource VSphere VApp Container ( ) , " " : resource VSphere VApp Entity ( ) , " " : resource VSphere Vmfs Datastore ( ) , " " : resource VSphere Virtual Machine Snapshot ( ) , } , Data Sources Map : map [ string ] * schema . Resource { " " : data Source VSphere Compute Cluster ( ) , " " : data Source VSphere Custom Attribute ( ) , " " : data Source VSphere Datacenter ( ) , " " : data Source VSphere Datastore ( ) , " " : data Source VSphere Datastore Cluster ( ) , " " : data Source VSphere Distributed Virtual Switch ( ) , " " : data Source VSphere Folder ( ) , " " : data Source VSphere Host ( ) , " " : data Source VSphere Network ( ) , " " : data Source VSphere Resource Pool ( ) , " " : data Source VSphere Tag ( ) , " " : data Source VSphere Tag Category ( ) , " " : data Source VSphere VApp Container ( ) , " " : data Source VSphere Virtual Machine ( ) , " " : data Source VSphere Vmfs Disks ( ) , } , Configure Func : provider Configure , } } 
func resource VSphere Datastore Cluster Apply Create ( d * schema . Resource Data , meta interface { } ) ( * object . Storage Pod , error ) { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return nil , err } dc , err : = datacenter From ID ( client , d . Get ( " " ) . ( string ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return pod , nil } 
func resource VSphere Datastore Cluster Apply Tags ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { tags Client , err : = tags Client If Defined ( d , meta ) if err ! = nil { return err } return nil } log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) return process Tag Diff ( tags Client , d , pod ) } 
func resource VSphere Datastore Cluster Read Tags ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { if tags Client , _ : = meta . ( * VSphere Client ) . Tags Client ( ) ; tags Client ! = nil { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) if err : = read Tags For Resource ( tags Client , pod , d ) ; err ! = nil { return err } } else { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) } return nil } 
func resource VSphere Datastore Cluster Apply Custom Attributes ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { client : = meta . ( * VSphere Client ) . vim Client if err ! = nil { return err } if attrs Processor = = nil { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) return nil } log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) return attrs Processor . Process Diff ( pod ) } 
func resource VSphere Datastore Cluster Read Custom Attributes ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { client : = meta . ( * VSphere Client ) . vim Client props , err : = storagepod . Properties ( pod ) if err ! = nil { return err } customattribute . Read From Resource ( client , props . Entity ( ) , d ) } else { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) } return nil } 
func resource VSphere Datastore Cluster Apply SDRSConfig ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { return nil } log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return err } return storagepod . Apply DRSConfiguration ( client , pod , spec ) } 
func resource VSphere Datastore Cluster Has SDRSConfig Change ( d * schema . Resource Data ) bool { for k : = range resource VSphere Datastore Cluster ( ) . Schema { switch { case resource VSphere Datastore Cluster Has SDRSConfig Change Excluded ( k ) : continue case d . Has Change ( k ) : return true } } return false } 
func resource VSphere Datastore Cluster Get Pod ( d structure . Resource IDStringer , meta interface { } ) ( * object . Storage Pod , error ) { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return nil , err } return storagepod . From ID ( client , d . Id ( ) ) } 
func resource VSphere Datastore Cluster Get Pod From Path ( meta interface { } , path string , dc ID string ) ( * object . Storage Pod , error ) { client : = meta . ( * VSphere Client ) . vim Client var dc * object . Datacenter if dc ID ! = " " { var err error dc , err = datacenter From ID ( client , dc ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , path , dc . Inventory Path ) } else { log . Printf ( " " , path ) } if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return nil , err } return storagepod . From Path ( client , path , dc ) } 
func resource VSphere Datastore Cluster Save Name And Path ( d * schema . Resource Data , pod * object . Storage Pod ) error { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) , pod . Inventory Path , ) if err : = d . Set ( " " , pod . Name ( ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } f , err : = folder . Root Path Particle Datastore . Split Relative Folder ( pod . Inventory Path ) if err ! = nil { return fmt . Errorf ( " " , pod . Inventory Path , err ) } if err : = d . Set ( " " , folder . Normalize Path ( f ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func resource VSphere Datastore Cluster Apply Name Change ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod , ) ( * object . Storage Pod , error ) { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) , pod . Inventory Path , ) var changed bool var err error if d . Has Change ( " " ) { if err = storagepod . Rename ( pod , d . Get ( " " ) . ( string ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } changed = true } if changed { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) , pod . Inventory Path , ) } return pod , nil } 
func resource VSphere Datastore Cluster Apply Folder Change ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod , ) ( * object . Storage Pod , error ) { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) , pod . Inventory Path , ) var changed bool var err error if d . Has Change ( " " ) { f : = d . Get ( " " ) . ( string ) client : = meta . ( * VSphere Client ) . vim Client if err = storagepod . Move To Folder ( client , pod , f ) ; err ! = nil { return nil , fmt . Errorf ( " " , f , err ) } changed = true } if changed { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) , pod . Inventory Path , ) } return pod , nil } 
func resource VSphere Datastore Cluster Validate Empty Cluster ( d structure . Resource IDStringer , pod * object . Storage Pod ) error { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) ne , err : = storagepod . Has Children ( pod ) if err ! = nil { return fmt . Errorf ( " " , err ) } if ne { return fmt . Errorf ( " " , pod . Inventory Path , ) } return nil } 
func resource VSphere Datastore Cluster Apply Delete ( d * schema . Resource Data , pod * object . Storage Pod ) error { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) if err : = storagepod . Delete ( pod ) ; err ! = nil { return err } d . Set Id ( " " ) return nil } 
func resource VSphere Datastore Cluster Flatten SDRSData ( d * schema . Resource Data , meta interface { } , pod * object . Storage Pod ) error { log . Printf ( " " , resource VSphere Datastore Cluster IDString ( d ) ) client : = meta . ( * VSphere Client ) . vim Client if err : = viapi . Validate Virtual Center ( client ) ; err ! = nil { return err } props , err : = storagepod . Properties ( pod ) if err ! = nil { return err } return flatten Storage Drs Pod Config Info ( d , props . Pod Storage Drs Entry . Storage Drs Config . Pod Config , version ) } 
func expand Storage Drs Pod Config Spec ( d * schema . Resource Data , version viapi . VSphere Version ) * types . Storage Drs Pod Config Spec { obj : = & types . Storage Drs Pod Config Spec { Default Intra Vm Affinity : structure . Get Bool ( d , " " ) , Default Vm Behavior : d . Get ( " " ) . ( string ) , Enabled : structure . Get Bool ( d , " " ) , Io Load Balance Config : expand Storage Drs Io Load Balance Config ( d , version ) , Io Load Balance Enabled : structure . Get Bool ( d , " " ) , Load Balance Interval : int 3 2 ( d . Get ( " " ) . ( int ) ) , Space Load Balance Config : expand Storage Drs Space Load Balance Config ( d , version ) , Option : expand Storage Drs Option Spec ( d ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { obj . Automation Overrides = expand Storage Drs Automation Config ( d ) } return obj } 
func flatten Storage Drs Pod Config Info ( d * schema . Resource Data , obj types . Storage Drs Pod Config Info , version viapi . VSphere Version ) error { attrs : = map [ string ] interface { } { " " : obj . Default Intra Vm Affinity , " " : obj . Default Vm Behavior , " " : obj . Enabled , " " : obj . Io Load Balance Enabled , " " : obj . Load Balance Interval , } for k , v : = range attrs { if err : = d . Set ( k , v ) ; err ! = nil { return fmt . Errorf ( " " , k , err ) } } if err : = flatten Storage Drs Io Load Balance Config ( d , obj . Io Load Balance Config , version ) ; err ! = nil { return err } if err : = flatten Storage Drs Space Load Balance Config ( d , obj . Space Load Balance Config , version ) ; err ! = nil { return err } if err : = flatten Storage Drs Option Spec ( d , obj . Option ) ; err ! = nil { return err } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { if err : = flatten Storage Drs Automation Config ( d , obj . Automation Overrides ) ; err ! = nil { return err } } return nil } 
func expand Storage Drs Automation Config ( d * schema . Resource Data ) * types . Storage Drs Automation Config { obj : = & types . Storage Drs Automation Config { Io Load Balance Automation Mode : d . Get ( " " ) . ( string ) , Policy Enforcement Automation Mode : d . Get ( " " ) . ( string ) , Rule Enforcement Automation Mode : d . Get ( " " ) . ( string ) , Space Load Balance Automation Mode : d . Get ( " " ) . ( string ) , Vm Evacuation Automation Mode : d . Get ( " " ) . ( string ) , } return obj } 
func flatten Storage Drs Automation Config ( d * schema . Resource Data , obj * types . Storage Drs Automation Config ) error { attrs : = map [ string ] interface { } { " " : obj . Io Load Balance Automation Mode , " " : obj . Policy Enforcement Automation Mode , " " : obj . Rule Enforcement Automation Mode , " " : obj . Space Load Balance Automation Mode , " " : obj . Vm Evacuation Automation Mode , } for k , v : = range attrs { if err : = d . Set ( k , v ) ; err ! = nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expand Storage Drs Io Load Balance Config ( d * schema . Resource Data , version viapi . VSphere Version ) * types . Storage Drs Io Load Balance Config { obj : = & types . Storage Drs Io Load Balance Config { Io Latency Threshold : int 3 2 ( d . Get ( " " ) . ( int ) ) , Io Load Imbalance Threshold : int 3 2 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { obj . Reservable Iops Threshold = int 3 2 ( d . Get ( " " ) . ( int ) ) obj . Reservable Percent Threshold = int 3 2 ( d . Get ( " " ) . ( int ) ) obj . Reservable Threshold Mode = d . Get ( " " ) . ( string ) } return obj } 
func flatten Storage Drs Io Load Balance Config ( d * schema . Resource Data , obj * types . Storage Drs Io Load Balance Config , version viapi . VSphere Version , ) error { attrs : = map [ string ] interface { } { " " : obj . Io Latency Threshold , " " : obj . Io Load Imbalance Threshold , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { attrs [ " " ] = obj . Reservable Threshold Mode if obj . Reservable Threshold Mode = = string ( types . Storage Drs Pod Config Info Behavior Manual ) { attrs [ " " ] = obj . Reservable Iops Threshold } else { attrs [ " " ] = obj . Reservable Percent Threshold } } for k , v : = range attrs { if err : = d . Set ( k , v ) ; err ! = nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expand Storage Drs Space Load Balance Config ( d * schema . Resource Data , version viapi . VSphere Version , ) * types . Storage Drs Space Load Balance Config { obj : = & types . Storage Drs Space Load Balance Config { Min Space Utilization Difference : int 3 2 ( d . Get ( " " ) . ( int ) ) , Space Utilization Threshold : int 3 2 ( d . Get ( " " ) . ( int ) ) , } if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { obj . Free Space Threshold GB = int 3 2 ( d . Get ( " " ) . ( int ) ) obj . Space Threshold Mode = d . Get ( " " ) . ( string ) } return obj } 
func flatten Storage Drs Space Load Balance Config ( d * schema . Resource Data , obj * types . Storage Drs Space Load Balance Config , version viapi . VSphere Version , ) error { attrs : = map [ string ] interface { } { " " : obj . Min Space Utilization Difference , " " : obj . Space Threshold Mode , } free Space Supported : = version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) if free Space Supported & & obj . Space Threshold Mode = = string ( types . Storage Drs Space Load Balance Config Space Threshold Mode Free Space ) { attrs [ " " ] = obj . Free Space Threshold GB } else { attrs [ " " ] = obj . Space Utilization Threshold } for k , v : = range attrs { if err : = d . Set ( k , v ) ; err ! = nil { return fmt . Errorf ( " " , k , err ) } } return nil } 
func expand Storage Drs Option Spec ( d * schema . Resource Data ) [ ] types . Storage Drs Option Spec { var opts [ ] types . Storage Drs Option Spec m : = d . Get ( " " ) . ( map [ string ] interface { } ) for k , v : = range m { opts = append ( opts , types . Storage Drs Option Spec { Option : & types . Option Value { Key : k , Value : types . Any Type ( v ) , } , } ) } return opts } 
func flatten Storage Drs Option Spec ( d * schema . Resource Data , opts [ ] types . Base Option Value ) error { m : = make ( map [ string ] interface { } ) for _ , opt : = range opts { m [ opt . Get Option Value ( ) . Key ] = opt . Get Option Value ( ) . Value } return d . Set ( " " , m ) } 
func resource VSphere Folder Migrate State ( version int , os * terraform . Instance State , meta interface { } ) ( * terraform . Instance State , error ) { } } var migrate Func func ( * terraform . Instance State , interface { } ) error switch version { case 0 : log . Printf ( " " , version , os ) migrate Func = resource VSphere Folder Migrate State V 1 default : return os , nil } if err : = migrate Func ( os , meta ) ; err ! = nil { return nil , err } version + + log . Printf ( " " , version , os ) return resource VSphere Folder Migrate State ( version , os , meta ) } 
func resource VSphere Folder Migrate State V 1 ( s * terraform . Instance State , meta interface { } ) error { p : = folder . Normalize Path ( s . Attributes [ " " ] ) dc , err : = get Datacenter ( client , dcp ) if err ! = nil { return err } folder , err : = folder . From Absolute Path ( client , fp ) if err ! = nil { return err } s . ID = folder . Reference ( ) . Value return nil } 
func get Datacenter ( c * govmomi . Client , dc string ) ( * object . Datacenter , error ) { finder : = find . New Finder ( c . Client , true ) t : = c . Service Content . About . Api Type switch t { case " " : return finder . Default Datacenter ( context . TODO ( ) ) case " " : if dc ! = " " { return finder . Datacenter ( context . TODO ( ) , dc ) } return finder . Default Datacenter ( context . TODO ( ) ) } return nil , fmt . Errorf ( " " , t ) } 
func datacenter From ID ( client * govmomi . Client , id string ) ( * object . Datacenter , error ) { finder : = find . New Finder ( client . Client , false ) ref : = types . Managed Object Reference { Type : " " , Value : id , } ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) ds , err : = finder . Object Reference ( ctx , ref ) if err ! = nil { return nil , fmt . Errorf ( " " , id , err ) } return ds . ( * object . Datacenter ) , nil } 
func Disk Subresource Schema ( ) map [ string ] * schema . Schema { s : = map [ string ] * schema . Schema { } return nil , nil } , Deprecated : disk Name Deprecation Notice , } , " " : { Type : schema . Type String , Optional : true , Computed : true , Conflicts With : [ ] string { " " } , Description : " " , Validate Func : func ( v interface { } , _ string ) ( [ ] string , [ ] error ) { if path . Ext ( v . ( string ) ) ! = " " { return nil , [ ] error { fmt . Errorf ( " " , v . ( string ) ) } } return nil , nil } , } , " " : { Type : schema . Type String , Optional : true , Default : string ( types . Virtual Disk Mode Persistent ) , Description : " " , Validate Func : validation . String In Slice ( disk Subresource Mode Allowed Values , false ) , } , " " : { Type : schema . Type Bool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . Type String , Optional : true , Default : string ( types . Virtual Disk Sharing Sharing None ) , Description : " " , Validate Func : validation . String In Slice ( disk Subresource Sharing Allowed Values , false ) , } , " " : { Type : schema . Type Bool , Optional : true , Default : true , Description : " " , } , " " : { Type : schema . Type Bool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . Type String , Computed : true , Description : " " , } , } return nil , nil } , } , " " : { Type : schema . Type Int , Optional : true , Default : 0 , Description : " " , Validate Func : validation . Int Between ( 0 , 5 9 ) , } , " " : { Type : schema . Type Bool , Optional : true , Default : false , Description : " " , } , " " : { Type : schema . Type Bool , Optional : true , Default : false , Conflicts With : [ ] string { " " } , Description : " " , } , } structure . Merge Schema ( s , subresource Schema ( ) ) return s } 
func New Disk Subresource ( client * govmomi . Client , rdd resource Data Diff , d , old map [ string ] interface { } , idx int ) * Disk Subresource { sr : = & Disk Subresource { Subresource : & Subresource { schema : Disk Subresource Schema ( ) , client : client , srtype : subresource Type Disk , data : d , olddata : old , rdd : rdd , } , } sr . Index = idx return sr } 
func Disk Apply Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( object . Virtual Device List , [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " ) o , n : = d . Get Change ( subresource Type Disk ) ods : = o . ( [ ] interface { } ) nds : = n . ( [ ] interface { } ) var spec [ ] types . Base Virtual Device Config Spec for oi , oe : = range ods { om : = oe . ( map [ string ] interface { } ) if err : = disk Apply Operation Delete ( oi , om , nds , c , d , & l , & spec ) ; err ! = nil { return nil , nil , err } } log . Printf ( " " ) log . Printf ( " " , subresource List String ( updates ) ) for ni , ne : = range nds { nm : = ne . ( map [ string ] interface { } ) if err : = disk Apply Operation Create Update ( ni , nm , ods , c , d , & l , & spec , & updates ) ; err ! = nil { return nil , nil , err } } log . Printf ( " " , subresource List String ( updates ) ) } log . Printf ( " " , Device List String ( l ) ) log . Printf ( " " , Device Change String ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func disk Apply Operation Delete ( index int , old Data map [ string ] interface { } , new Data Set [ ] interface { } , c * govmomi . Client , d * schema . Resource Data , l * object . Virtual Device List , spec * [ ] types . Base Virtual Device Config Spec , ) error { didx : = - 1 for ni , ne : = range new Data Set { new Data : = ne . ( map [ string ] interface { } ) var name string var err error if name , err = disk Label Or Name ( new Data ) ; err ! = nil { return err } if ( name = = disk Deleted Name | | name = = disk Detached Name ) & & old Data [ " " ] = = new Data [ " " ] { didx = ni break } } if didx < 0 { } r : = New Disk Subresource ( c , d , old Data , nil , index ) dspec , err : = r . Delete ( * l ) if err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = apply Device Change ( * l , dspec ) * spec = append ( * spec , dspec . . . ) return nil } 
func disk Apply Operation Create Update ( index int , new Data map [ string ] interface { } , old Data Set [ ] interface { } , c * govmomi . Client , d * schema . Resource Data , l * object . Virtual Device List , spec * [ ] types . Base Virtual Device Config Spec , updates * [ ] interface { } , ) error { var name string var err error if name , err = disk Label Or Name ( new Data ) ; err ! = nil { return err } if name = = disk Deleted Name | | name = = disk Detached Name { } for _ , oe : = range old Data Set { old Data : = oe . ( map [ string ] interface { } ) if new Data [ " " ] = = old Data [ " " ] { if err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } old Copy : = omc . ( map [ string ] interface { } ) old Copy [ " " ] = new Data [ " " ] old Copy [ " " ] = new Data [ " " ] old Copy [ " " ] = new Data [ " " ] if reflect . Deep Equal ( old Copy , new Data ) { * updates = append ( * updates , r . Data ( ) ) return nil } uspec , err : = r . Update ( * l ) if err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = apply Device Change ( * l , uspec ) * spec = append ( * spec , uspec . . . ) * updates = append ( * updates , r . Data ( ) ) return nil } } cspec , err : = r . Create ( * l ) if err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } * l = apply Device Change ( * l , cspec ) * spec = append ( * spec , cspec . . . ) * updates = append ( * updates , r . Data ( ) ) return nil } 
func Disk Refresh Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) error { log . Printf ( " " ) devices : = Select Disks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , Device List String ( devices ) ) cur Set : = d . Get ( subresource Type Disk ) . ( [ ] interface { } ) log . Printf ( " " , subresource List String ( cur Set ) ) var new Set [ ] interface { } for i , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { r : = New Disk Subresource ( c , d , m , nil , i ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } if r . Get ( " " ) . ( int ) < 1 { } new Set = append ( new Set , r . Data ( ) ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] if device . Get Virtual Device ( ) . Key = = int 3 2 ( r . Get ( " " ) . ( int ) ) { devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } } } log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( new Set ) ) for i : = 0 ; i < len ( devices ) ; i + + { device : = devices [ i ] for n , item : = range cur Set { m : = item . ( map [ string ] interface { } ) if m [ " " ] . ( int ) < 1 { } if ! disk UUIDMatch ( device , m [ " " ] . ( string ) ) { } if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } devices = append ( devices [ : i ] , devices [ i + 1 : ] . . . ) i - - } } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " , Device List String ( devices ) ) for i , device : = range devices { m : = make ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } r : = New Disk Subresource ( c , d , m , nil , len ( new Set ) ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } new Set = append ( new Set , r . Data ( ) ) } log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " , subresource List String ( new Set ) ) log . Printf ( " " ) return d . Set ( subresource Type Disk , new Set ) } 
func Disk Destroy Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " ) var spec [ ] types . Base Virtual Device Config Spec log . Printf ( " " ) for oi , oe : = range ds { m : = oe . ( map [ string ] interface { } ) if ! m [ " " ] . ( bool ) & & ! m [ " " ] . ( bool ) { } r : = New Disk Subresource ( c , d , m , nil , oi ) dspec , err : = r . Delete ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , dspec ) spec = append ( spec , dspec . . . ) } log . Printf ( " " , Device Change String ( spec ) ) return spec , nil } 
func Disk Diff Operation ( d * schema . Resource Diff , c * govmomi . Client ) error { log . Printf ( " " ) o , n : = d . Get Change ( subresource Type Disk ) names : = make ( map [ string ] struct { } ) attachments : = make ( map [ string ] struct { } ) units : = make ( map [ int ] struct { } ) if len ( n . ( [ ] interface { } ) ) < 1 { return errors . New ( " " ) } for ni , ne : = range n . ( [ ] interface { } ) { nm : = ne . ( map [ string ] interface { } ) name , err : = disk Label Or Name ( nm ) if err ! = nil { return fmt . Errorf ( " " , ni , err ) } if _ , ok : = names [ name ] ; ok { return fmt . Errorf ( " " , name ) } if path = = " " { return fmt . Errorf ( " " , ni ) } if _ , ok : = attachments [ path ] ; ok { return fmt . Errorf ( " " , path ) } attachments [ path ] = struct { } { } } if _ , ok : = units [ nm [ " " ] . ( int ) ] ; ok { return fmt . Errorf ( " " , nm [ " " ] . ( int ) ) } names [ name ] = struct { } { } units [ nm [ " " ] . ( int ) ] = struct { } { } r : = New Disk Subresource ( c , d , nm , nil , ni ) if err : = r . Diff General ( ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } } if _ , ok : = units [ 0 ] ; ! ok { return errors . New ( " " ) } ods : = o . ( [ ] interface { } ) nds : = n . ( [ ] interface { } ) normalized : = make ( [ ] interface { } , len ( ods ) ) next New : for _ , ne : = range nds { nm : = ne . ( map [ string ] interface { } ) for oi , oe : = range ods { om : = oe . ( map [ string ] interface { } ) var oname , nname string var err error if oname , err = disk Label Or Name ( om ) ; err ! = nil { return fmt . Errorf ( " " , oi , err ) } if nname , err = disk Label Or Name ( nm ) ; err ! = nil { return fmt . Errorf ( " " , oi , err ) } if err : = r . Diff Existing ( ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } normalized [ oi ] = r . Data ( ) continue next New } } nm [ " " ] = " " nm [ " " ] = " " if a , ok : = nm [ " " ] ; ! ok | | ! a . ( bool ) { nm [ " " ] = " " } else { _ , ok : = nm [ " " ] if ok { delete ( nm , " " ) } } if ds ID , ok : = nm [ " " ] ; ! ok | | ds ID = = " " { nm [ " " ] = disk Datastore Computed Name } normalized = append ( normalized , nm ) } } nv , err : = copystructure . Copy ( ods [ ni ] ) if err ! = nil { return fmt . Errorf ( " " , ni , err ) } nm : = nv . ( map [ string ] interface { } ) switch { case nm [ " " ] . ( bool ) : fallthrough case nm [ " " ] . ( bool ) : nm [ " " ] = disk Detached Name default : nm [ " " ] = disk Deleted Name } normalized [ ni ] = nm } log . Printf ( " " ) return d . Set New ( subresource Type Disk , normalized ) } 
func Disk Clone Validate Operation ( d * schema . Resource Diff , c * govmomi . Client , l object . Virtual Device List , linked bool ) error { log . Printf ( " " ) devices : = Select Disks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( cur Set ) ) sort . Sort ( virtual Disk Subresource Sorter ( cur Set ) ) log . Printf ( " " , subresource List String ( cur Set ) ) } for i , device : = range devices { m : = make ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } r : = New Disk Subresource ( c , d , m , nil , i ) if err : = r . Read ( l ) ; err ! = nil { return fmt . Errorf ( " " , r . Addr ( ) , err ) } tr : = New Disk Subresource ( c , d , target M , nil , i ) if err ! = nil { return fmt . Errorf ( " " , tr . Addr ( ) , err ) } target Path : = r . Get ( " " ) . ( string ) source Size : = r . Get ( " " ) . ( int ) target Size : = tr . Get ( " " ) . ( int ) target Thin : = tr . Get ( " " ) . ( bool ) target Eager : = tr . Get ( " " ) . ( bool ) var source Thin , source Eager bool if b : = r . Get ( " " ) ; b ! = nil { source Thin = b . ( bool ) } if b : = r . Get ( " " ) ; b ! = nil { source Eager = b . ( bool ) } switch { case linked : switch { case source Size ! = target Size : return fmt . Errorf ( " " , tr . Addr ( ) , target Name , source Size ) case source Thin ! = target Thin : return fmt . Errorf ( " " , tr . Addr ( ) , target Name , source Thin ) case source Eager ! = target Eager : return fmt . Errorf ( " " , tr . Addr ( ) , target Name , source Eager ) } default : if source Size > target Size { return fmt . Errorf ( " " , tr . Addr ( ) , target Name , source Size ) } } if err ! = nil { return fmt . Errorf ( " " , tr . Addr ( ) , target Path , err ) } if ct ! = Subresource Controller Type SCSI { return fmt . Errorf ( " " , tr . Addr ( ) , ct , target Path ) } } log . Printf ( " " ) return nil } 
func Disk Migrate Relocate Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( [ ] types . Virtual Machine Relocate Spec Disk Locator , bool , error ) { log . Printf ( " " ) ods , nds : = d . Get Change ( subresource Type Disk ) var relocators [ ] types . Virtual Machine Relocate Spec Disk Locator var relocate OK bool var name string var err error if name , err = disk Label Or Name ( nm ) ; err ! = nil { return nil , false , fmt . Errorf ( " " , ni , err ) } if name = = disk Deleted Name | | name = = disk Detached Name { continue } for _ , oe : = range ods . ( [ ] interface { } ) { om : = oe . ( map [ string ] interface { } ) if nm [ " " ] = = om [ " " ] { } } r : = New Disk Subresource ( c , d , nm , om , ni ) relocator , err : = r . Relocate ( l , false ) if err ! = nil { return nil , false , fmt . Errorf ( " " , r . Addr ( ) , err ) } if d . Get ( " " ) . ( string ) = = relocator . Datastore . Value { log . Printf ( " " , r . Addr ( ) ) break } relocators = append ( relocators , relocator ) } } } if ! relocate OK { log . Printf ( " " ) return nil , false , nil } log . Printf ( " " , disk Relocate List String ( relocators ) ) log . Printf ( " " ) return relocators , true , nil } 
func Disk Clone Relocate Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( [ ] types . Virtual Machine Relocate Spec Disk Locator , error ) { log . Printf ( " " ) devices : = Select Disks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( cur Set ) ) sort . Sort ( virtual Disk Subresource Sorter ( cur Set ) ) log . Printf ( " " , subresource List String ( cur Set ) ) log . Printf ( " " ) var relocators [ ] types . Virtual Machine Relocate Spec Disk Locator for i , device : = range devices { m : = cur Set [ i ] . ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return nil , fmt . Errorf ( " " , vd . Key ) } m [ " " ] = int ( vd . Key ) var err error m [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } r : = New Disk Subresource ( c , d , m , nil , i ) } if err ! = nil { return nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } relocators = append ( relocators , relocator ) } log . Printf ( " " , disk Relocate List String ( relocators ) ) log . Printf ( " " ) return relocators , nil } 
func Disk Post Clone Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) ( object . Virtual Device List , [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " ) devices : = Select Disks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " , subresource List String ( cur Set ) ) sort . Sort ( virtual Disk Subresource Sorter ( cur Set ) ) log . Printf ( " " , subresource List String ( cur Set ) ) var spec [ ] types . Base Virtual Device Config Spec var updates [ ] interface { } log . Printf ( " " ) for i , device : = range devices { src : = cur Set [ i ] . ( map [ string ] interface { } ) vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return nil , nil , fmt . Errorf ( " " , vd . Key ) } src [ " " ] = int ( vd . Key ) var err error src [ " " ] , err = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , nil , fmt . Errorf ( " " , src [ " " ] . ( int ) , err ) } r Old : = New Disk Subresource ( c , d , old . ( map [ string ] interface { } ) , nil , i ) if err : = r Old . Read ( l ) ; err ! = nil { return nil , nil , fmt . Errorf ( " " , r Old . Addr ( ) , err ) } new , err : = copystructure . Copy ( r Old . Data ( ) ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , src [ " " ] . ( int ) , err ) } for k , v : = range src { case " " : if src [ " " ] ! = string ( types . Shares Level Custom ) { continue } } new . ( map [ string ] interface { } ) [ k ] = v } r New : = New Disk Subresource ( c , d , new . ( map [ string ] interface { } ) , r Old . Data ( ) , i ) if ! reflect . Deep Equal ( r New . Data ( ) , r Old . Data ( ) ) { uspec , err : = r New . Update ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r New . Addr ( ) , err ) } l = apply Device Change ( l , uspec ) spec = append ( spec , uspec . . . ) } updates = append ( updates , r New . Data ( ) ) } cspec , err : = r . Create ( l ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , r . Addr ( ) , err ) } l = apply Device Change ( l , cspec ) spec = append ( spec , cspec . . . ) updates = append ( updates , r . Data ( ) ) } log . Printf ( " " , subresource List String ( updates ) ) if err : = d . Set ( subresource Type Disk , updates ) ; err ! = nil { return nil , nil , err } log . Printf ( " " , Device List String ( l ) ) log . Printf ( " " , Device Change String ( spec ) ) log . Printf ( " " ) return l , spec , nil } 
func Disk Import Operation ( d * schema . Resource Data , c * govmomi . Client , l object . Virtual Device List ) error { log . Printf ( " " ) devices : = Select Disks ( l , d . Get ( " " ) . ( int ) ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) log . Printf ( " " ) for i , device : = range devices { vd : = device . Get Virtual Device ( ) ctlr : = l . Find By Key ( vd . Controller Key ) if ctlr = = nil { return fmt . Errorf ( " " , vd . Key ) } addr , err : = compute Dev Addr ( vd , ctlr . ( types . Base Virtual Controller ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } ct , _ , _ , err : = split Dev Addr ( addr ) if err ! = nil { return fmt . Errorf ( " " , i , addr , err ) } if ct ! = Subresource Controller Type SCSI { return fmt . Errorf ( " " , i , ct , addr ) } } m : = make ( map [ string ] interface { } ) m [ " " ] = addr cur Set = append ( cur Set , m ) } log . Printf ( " " , subresource List String ( cur Set ) ) if err : = d . Set ( subresource Type Disk , cur Set ) ; err ! = nil { return err } log . Printf ( " " ) return nil } 
func Read Disk Attrs For Data Source ( l object . Virtual Device List , count int ) ( [ ] map [ string ] interface { } , error ) { log . Printf ( " " , count ) devices : = Select Disks ( l , count ) log . Printf ( " " , Device List String ( devices ) ) sort . Sort ( dev Sort ) devices = dev Sort . Sort log . Printf ( " " , Device List String ( devices ) ) var out [ ] map [ string ] interface { } for i , device : = range devices { disk : = device . ( * types . Virtual Disk ) backing , ok : = disk . Backing . ( * types . Virtual Disk Flat Ver 2Backing Info ) if ! ok { return nil , fmt . Errorf ( " " , i , disk . Backing ) } m : = make ( map [ string ] interface { } ) var eager , thin bool if backing . Eagerly Scrub ! = nil { eager = * backing . Eagerly Scrub } if backing . Thin Provisioned ! = nil { thin = * backing . Thin Provisioned } m [ " " ] = disk Capacity In Gi B ( disk ) m [ " " ] = eager m [ " " ] = thin out = append ( out , m ) } log . Printf ( " " , out ) return out , nil } 
func ( r * Disk Subresource ) Create ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) var spec [ ] types . Base Virtual Device Config Spec disk , err : = r . create Disk ( l ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err : = r . expand Disk Settings ( disk ) ; err ! = nil { return nil , err } } dspec , err : = object . Virtual Device List { disk } . Config Spec ( types . Virtual Device Config Spec Operation Add ) if err ! = nil { return nil , err } if len ( dspec ) ! = 1 { return nil , fmt . Errorf ( " " , len ( dspec ) ) } } spec = append ( spec , dspec . . . ) log . Printf ( " " , r , Device Change String ( spec ) ) log . Printf ( " " , r ) return spec , nil } 
func ( r * Disk Subresource ) Read ( l object . Virtual Device List ) error { log . Printf ( " " , r ) disk , err : = r . find Virtual Disk ( l , true ) if err ! = nil { return fmt . Errorf ( " " , err ) } unit , ctlr , err : = r . find Controller Info ( l , disk ) if err ! = nil { return err } r . Set ( " " , unit ) if err : = r . Save Dev IDs ( disk , ctlr ) ; err ! = nil { return err } if r . Get ( " " ) ! = nil { attach = r . Get ( " " ) . ( bool ) } if ! ok { return fmt . Errorf ( " " , r . Get ( " " ) . ( string ) , disk . Backing ) } r . Set ( " " , b . Uuid ) r . Set ( " " , b . Disk Mode ) r . Set ( " " , b . Write Through ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) & & b . Sharing ! = " " { r . Set ( " " , b . Sharing ) } if ! attach { r . Set ( " " , b . Thin Provisioned ) r . Set ( " " , b . Eagerly Scrub ) } r . Set ( " " , b . Datastore . Value ) if ok : = dp . From String ( b . File Name ) ; ! ok { return fmt . Errorf ( " " , b . File Name ) } r . Set ( " " , dp . Path ) r . Set ( " " , disk Capacity In Gi B ( disk ) ) } if allocation : = disk . Storage IOAllocation ; allocation ! = nil { r . Set ( " " , allocation . Limit ) r . Set ( " " , allocation . Reservation ) if shares : = allocation . Shares ; shares ! = nil { r . Set ( " " , string ( shares . Level ) ) r . Set ( " " , shares . Shares ) } } log . Printf ( " " , r ) return nil } 
func ( r * Disk Subresource ) Update ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) disk , err : = r . find Virtual Disk ( l , false ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } r . Set Restart ( " " ) if err : = r . Save Dev IDs ( disk , ctlr ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } } dspec , err : = object . Virtual Device List { disk } . Config Spec ( types . Virtual Device Config Spec Operation Edit ) if err ! = nil { return nil , err } if len ( dspec ) ! = 1 { return nil , fmt . Errorf ( " " , len ( dspec ) ) } log . Printf ( " " , r , Device Change String ( dspec ) ) log . Printf ( " " , r ) return dspec , nil } 
func ( r * Disk Subresource ) Delete ( l object . Virtual Device List ) ( [ ] types . Base Virtual Device Config Spec , error ) { log . Printf ( " " , r ) disk , err : = r . find Virtual Disk ( l , false ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } delete Spec , err : = object . Virtual Device List { disk } . Config Spec ( types . Virtual Device Config Spec Operation Remove ) if err ! = nil { return nil , err } if len ( delete Spec ) ! = 1 { return nil , fmt . Errorf ( " " , len ( delete Spec ) ) } if r . Get ( " " ) . ( bool ) | | r . Get ( " " ) . ( bool ) { } log . Printf ( " " , r , Device Change String ( delete Spec ) ) log . Printf ( " " , r ) return delete Spec , nil } 
func ( r * Disk Subresource ) Diff Existing ( ) error { log . Printf ( " " , r ) name , err : = disk Label Or Name ( r . data ) if err ! = nil { return err } if olabel ! = " " & & nlabel = = " " { return errors . New ( " " ) } r . Set ( " " , oname . ( string ) ) } odaddr , _ : = r . Get Change ( " " ) ouuid , _ : = r . Get Change ( " " ) r . Set ( " " , okey ) r . Set ( " " , odaddr ) r . Set ( " " , ouuid ) if ! r . Get ( " " ) . ( bool ) { r . Set ( " " , opath . ( string ) ) } if ds ID = = " " { r . Set ( " " , disk Datastore Computed Name ) } else { r . Set ( " " , ds ID ) } default : if err = r . normalize Disk Datastore ( ) ; err ! = nil { return err } } } if r . Get ( " " ) . ( string ) ! = string ( types . Shares Level Custom ) { r . Set ( " " , osc ) } if osize . ( int ) > nsize . ( int ) { return fmt . Errorf ( " " , name , osize . ( int ) , nsize . ( int ) ) } } if _ , err = r . Get With Veto ( " " ) ; err ! = nil { return fmt . Errorf ( " " , name , err ) } } } } log . Printf ( " " , r ) return nil } 
func ( r * Disk Subresource ) Diff General ( ) error { log . Printf ( " " , r ) name , err : = disk Label Or Name ( r . data ) if err ! = nil { return err } max Unit : = ctlr Count * 1 5 - 1 current Unit : = r . Get ( " " ) . ( int ) if current Unit > max Unit { return fmt . Errorf ( " " , name , current Unit , max Unit , ctlr Count ) } if r . Get ( " " ) . ( bool ) { switch { case r . Get ( " " ) . ( string ) = = " " : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( int ) > 0 : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( bool ) : return fmt . Errorf ( " " , name ) case r . Get ( " " ) . ( bool ) : return fmt . Errorf ( " " , name ) } } else { } } if r . Get ( " " ) . ( string ) ! = string ( types . Virtual Disk Sharing Sharing None ) { if version . Older ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { return fmt . Errorf ( " " ) } } } log . Printf ( " " , r ) return nil } 
func ( r * Disk Subresource ) normalize Disk Datastore ( ) error { pod ID : = r . rdd . Get ( " " ) . ( string ) ds ID , _ : = r . Get Change ( " " ) if pod ID = = " " { return nil } log . Printf ( " " , r ) pod , err : = storagepod . From ID ( r . client , pod ID ) if err ! = nil { return fmt . Errorf ( " " , pod ID , err ) } ds , err : = datastore . From ID ( r . client , ds ID . ( string ) ) if err ! = nil { return fmt . Errorf ( " " , ds ID , err ) } is Member , err : = storagepod . Is Member ( pod , ds ) if err ! = nil { return fmt . Errorf ( " " , err ) } if ! is Member { log . Printf ( " " , r , ds . Name ( ) , pod . Name ( ) , ) ds ID = disk Datastore Computed Name } r . Set ( " " , ds ID ) return nil } 
func ( r * Disk Subresource ) validate Storage Relocate Diff ( ) error { log . Printf ( " " , r ) if err : = r . block Relocate Attached Disks ( ) ; err ! = nil { return err } log . Printf ( " " , r ) return nil } 
func ( r * Disk Subresource ) Relocate ( l object . Virtual Device List , clone bool ) ( types . Virtual Machine Relocate Spec Disk Locator , error ) { log . Printf ( " " , r ) disk , err : = r . find Virtual Disk ( l , clone ) var relocate types . Virtual Machine Relocate Spec Disk Locator if err ! = nil { return relocate , fmt . Errorf ( " " , err ) } } relocate . Disk Id = disk . Key if ds ID = = " " { } ds , err : = datastore . From ID ( r . client , ds ID ) if err ! = nil { return relocate , err } dsref : = ds . Reference ( ) relocate . Datastore = dsref backing : = disk . Backing . ( * types . Virtual Disk Flat Ver 2Backing Info ) backing . File Name = ds . Path ( " " ) backing . Datastore = & dsref relocate . Disk Backing Info = backing } log . Printf ( " " , r ) return relocate , nil } 
func ( r * Disk Subresource ) String ( ) string { p : = disk Path Or Name ( r . data ) if p = = " " { p = " " } return fmt . Sprintf ( " " , r . Subresource . String ( ) , p ) } 
func ( r * Disk Subresource ) expand Disk Settings ( disk * types . Virtual Disk ) error { b . Disk Mode = r . Get With Restart ( " " ) . ( string ) b . Write Through = structure . Bool Ptr ( r . Get With Restart ( " " ) . ( bool ) ) if version . Newer ( viapi . VSphere Version { Product : version . Product , Major : 6 } ) { b . Sharing = r . Get With Restart ( " " ) . ( string ) } var v interface { } if v , err = r . Get With Veto ( " " ) ; err ! = nil { return err } b . Thin Provisioned = structure . Bool Ptr ( v . ( bool ) ) if v , err = r . Get With Veto ( " " ) ; err ! = nil { return err } b . Eagerly Scrub = structure . Bool Ptr ( v . ( bool ) ) if os . ( int ) > ns . ( int ) { return fmt . Errorf ( " " ) } disk . Capacity In Bytes = structure . Gi BTo Byte ( ns . ( int ) ) disk . Capacity In KB = disk . Capacity In Bytes / 1 0 2 4 } alloc : = & types . Storage IOAllocation Info { Limit : structure . Int 6 4Ptr ( int 6 4 ( r . Get ( " " ) . ( int ) ) ) , Reservation : structure . Int 3 2Ptr ( int 3 2 ( r . Get ( " " ) . ( int ) ) ) , Shares : & types . Shares Info { Shares : int 3 2 ( r . Get ( " " ) . ( int ) ) , Level : types . Shares Level ( r . Get ( " " ) . ( string ) ) , } , } disk . Storage IOAllocation = alloc return nil } 
func ( r * Disk Subresource ) create Disk ( l object . Virtual Device List ) ( * types . Virtual Disk , error ) { disk : = new ( types . Virtual Disk ) disk . Backing = new ( types . Virtual Disk Flat Ver 2Backing Info ) } } return disk , nil } 
func ( r * Disk Subresource ) assign Disk ( l object . Virtual Device List , disk * types . Virtual Disk ) ( types . Base Virtual Controller , error ) { number : = r . Get ( " " ) . ( int ) if err ! = nil { return nil , err } units [ scsi Unit ] = true ckey : = ctlr . Get Virtual Controller ( ) . Key for _ , device : = range l { d : = device . Get Virtual Device ( ) if d . Controller Key ! = ckey | | d . Unit Number = = nil { continue } units [ * d . Unit Number ] = true } } if units [ unit ] { return nil , fmt . Errorf ( " " , unit , bus ) } disk . Unit Number = & unit return ctlr , nil } 
func ( r * Subresource ) find Controller Info ( l object . Virtual Device List , disk * types . Virtual Disk ) ( int , types . Base Virtual Controller , error ) { ctlr : = l . Find By Key ( disk . Controller Key ) if ctlr = = nil { return - 1 , nil , fmt . Errorf ( " " , disk . Controller Key , disk . Key ) } if disk . Unit Number = = nil { return - 1 , nil , fmt . Errorf ( " " , disk . Key ) } sc , ok : = ctlr . ( types . Base Virtual SCSIController ) if ! ok { return - 1 , nil , fmt . Errorf ( " " , ctlr . Get Virtual Device ( ) . Key , ctlr ) } unit : = * disk . Unit Number if unit > sc . Get Virtual SCSIController ( ) . Scsi Ctlr Unit Number { unit - - } unit = unit + 1 5 * sc . Get Virtual SCSIController ( ) . Bus Number return int ( unit ) , ctlr . ( types . Base Virtual Controller ) , nil } 
func disk Relocate List String ( relocators [ ] types . Virtual Machine Relocate Spec Disk Locator ) string { var out [ ] string for _ , relocate : = range relocators { out = append ( out , disk Relocate String ( relocate ) ) } return strings . Join ( out , " " ) } 
func disk Relocate String ( relocate types . Virtual Machine Relocate Spec Disk Locator ) string { key : = relocate . Disk Id var locstring string if backing , ok : = relocate . Disk Backing Info . ( * types . Virtual Disk Flat Ver 2Backing Info ) ; ok & & backing ! = nil { locstring = backing . File Name } else { locstring = relocate . Datastore . Value } return fmt . Sprintf ( " " , key , locstring ) } 
func ( l virtual Device List Sorter ) Less ( i , j int ) bool { li : = l . Sort [ i ] lj : = l . Sort [ j ] li Ctlr : = l . Device List . Find By Key ( li . Get Virtual Device ( ) . Controller Key ) lj Ctlr : = l . Device List . Find By Key ( lj . Get Virtual Device ( ) . Controller Key ) if li Ctlr = = nil | | lj Ctlr = = nil { panic ( errors . New ( " " ) ) } if li Ctlr . ( types . Base Virtual Controller ) . Get Virtual Controller ( ) . Bus Number < li Ctlr . ( types . Base Virtual Controller ) . Get Virtual Controller ( ) . Bus Number { return true } li Unit : = li . Get Virtual Device ( ) . Unit Number lj Unit : = lj . Get Virtual Device ( ) . Unit Number if li Unit = = nil | | lj Unit = = nil { panic ( errors . New ( " " ) ) } return * li Unit < * lj Unit } 
func ( l virtual Device List Sorter ) Swap ( i , j int ) { l . Sort [ i ] , l . Sort [ j ] = l . Sort [ j ] , l . Sort [ i ] } 
func ( s virtual Disk Subresource Sorter ) Less ( i , j int ) bool { mi : = s [ i ] . ( map [ string ] interface { } ) mj : = s [ j ] . ( map [ string ] interface { } ) return mi [ " " ] . ( int ) < mj [ " " ] . ( int ) } 
func ( s virtual Disk Subresource Sorter ) Swap ( i , j int ) { s [ i ] , s [ j ] = s [ j ] , s [ i ] } 
func datastore Path Has Base ( p , b string ) bool { dp : = & object . Datastore Path { } if ok : = dp . From String ( p ) ; ! ok { return false } return path . Base ( dp . Path ) = = path . Base ( b ) } 
func Select Disks ( l object . Virtual Device List , count int ) object . Virtual Device List { devices : = l . Select ( func ( device types . Base Virtual Device ) bool { if disk , ok : = device . ( * types . Virtual Disk ) ; ok { ctlr , err : = find Controller For Device ( l , disk ) if err ! = nil { log . Printf ( " " , l . Name ( disk ) , err ) return false } if sc , ok : = ctlr . ( types . Base Virtual SCSIController ) ; ok & & sc . Get Virtual SCSIController ( ) . Bus Number < int 3 2 ( count ) { cd : = sc . ( types . Base Virtual Device ) log . Printf ( " " , l . Name ( cd ) , l . Name ( disk ) ) return true } } return false } ) return devices } 
func disk Label Or Name ( data map [ string ] interface { } ) ( string , error ) { var label , name string if v , ok : = data [ " " ] ; ok & & v ! = nil { label = v . ( string ) } if v , ok : = data [ " " ] ; ok & & v ! = nil { name = v . ( string ) } if name ! = " " { name = path . Base ( name ) } log . Printf ( " " , label , name ) switch { case label = = " " & & name = = " " : return " " , errors . New ( " " ) case label ! = " " & & name ! = " " : return " " , errors . New ( " " ) case label ! = " " : log . Printf ( " " , label ) return label , nil } log . Printf ( " " , name ) return name , nil } 
func disk Path Or Name ( data map [ string ] interface { } ) string { var path , name string if v , ok : = data [ " " ] ; ok & & v ! = nil { path = v . ( string ) } if v , ok : = data [ " " ] ; ok & & v ! = nil { name = v . ( string ) } if path ! = " " { log . Printf ( " " , path ) return path } log . Printf ( " " , name ) return name } 
func ( r * Disk Subresource ) find Virtual Disk ( l object . Virtual Device List , fallback bool ) ( * types . Virtual Disk , error ) { device , err : = r . find Virtual Disk By UUIDOr Address ( l , fallback ) if err ! = nil { return nil , err } return device . ( * types . Virtual Disk ) , nil } 
func disk Capacity In Gi B ( disk * types . Virtual Disk ) int { if disk . Capacity In Bytes > 0 { return int ( structure . Byte To Gi B ( disk . Capacity In Bytes ) . ( int 6 4 ) ) } log . Printf ( " " , object . Virtual Device List { } . Name ( disk ) , ) return int ( structure . Byte To Gi B ( disk . Capacity In KB * 1 0 2 4 ) . ( int 6 4 ) ) } 
func host Network System From Host System ( hs * object . Host System ) ( * object . Host Network System , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) return hs . Config Manager ( ) . Network System ( ctx ) } 
func host Network System From Host System ID ( client * govmomi . Client , hs ID string ) ( * object . Host Network System , error ) { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return nil , err } return host Network System From Host System ( hs ) } 
func host VSwitch From Name ( client * govmomi . Client , ns * object . Host Network System , name string ) ( * types . Host Virtual Switch , error ) { var mns mo . Host Network System pc : = client . Property Collector ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) if err : = pc . Retrieve One ( ctx , ns . Reference ( ) , [ ] string { " " } , & mns ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , sw : = range mns . Network Info . Vswitch { if sw . Name = = name { return & sw , nil } } return nil , fmt . Errorf ( " " , name ) } 
func host Port Group From Name ( client * govmomi . Client , ns * object . Host Network System , name string ) ( * types . Host Port Group , error ) { var mns mo . Host Network System pc : = client . Property Collector ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) if err : = pc . Retrieve One ( ctx , ns . Reference ( ) , [ ] string { " " } , & mns ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , pg : = range mns . Network Info . Portgroup { if pg . Spec . Name = = name { return & pg , nil } } return nil , fmt . Errorf ( " " , name ) } 
func network Object From Host System ( client * govmomi . Client , hs * object . Host System , name string ) ( * object . Network , error ) { } finder : = find . New Finder ( client . Client , false ) ctx , cancel : = context . With Timeout ( context . Background ( ) , default APITimeout ) defer cancel ( ) nets , err : = finder . Network List ( ctx , " " + name ) if err ! = nil { return nil , err } for _ , n : = range nets { net , ok : = n . ( * object . Network ) if ! ok { } props , err : = network . Properties ( net ) if err ! = nil { return nil , err } for _ , hs Ref : = range props . Host { if hs Ref . Value = = hs . Reference ( ) . Value { } } } return nil , fmt . Errorf ( " " , name , hs . Reference ( ) . Value ) } 
func resource VSphere License Update ( d * schema . Resource Data , meta interface { } ) error { log . Println ( " " ) client : = meta . ( * VSphere Client ) . vim Client manager : = license . New Manager ( client . Client ) if key , ok : = d . Get Ok ( " " ) ; ok { license Key : = key . ( string ) if ! is Key Present ( license Key , manager ) { return Err No Such Key Found } if d . Has Change ( " " ) { label Map : = d . Get ( " " ) . ( map [ string ] interface { } ) err : = update Labels ( manager , license Key , label Map ) if err ! = nil { return err } } } return resource VSphere License Read ( d , meta ) } 
func is Key Present ( key string , manager * license . Manager ) bool { info List , _ : = manager . List ( context . TODO ( ) ) for _ , info : = range info List { if info . License Key = = key { return true } } return false } 
func Update Label ( ctx context . Context , m * license . Manager , license Key string , key string , val string ) error { req : = types . Update License Label { This : m . Reference ( ) , License Key : license Key , Label Key : key , Label Value : val , } _ , err : = methods . Update License Label ( ctx , m . Client ( ) , & req ) return err } 
func Decode Error ( info types . License Manager License Info ) error { for _ , property : = range info . Properties { if property . Key = = " " { return errors . New ( property . Value . ( string ) ) } } return nil } 
func resource VSphere VApp Container Apply Tags ( d * schema . Resource Data , meta interface { } , va * object . Virtual App ) error { tags Client , err : = tags Client If Defined ( d , meta ) if err ! = nil { return err } return nil } log . Printf ( " " , resource VSphere VApp Container IDString ( d ) ) return process Tag Diff ( tags Client , d , va ) } 
func resource VSphere VApp Container Read Tags ( d * schema . Resource Data , meta interface { } , va * object . Virtual App ) error { if tags Client , _ : = meta . ( * VSphere Client ) . Tags Client ( ) ; tags Client ! = nil { log . Printf ( " " , resource VSphere VApp Container IDString ( d ) ) if err : = read Tags For Resource ( tags Client , va , d ) ; err ! = nil { return err } } else { log . Printf ( " " , resource VSphere VApp Container IDString ( d ) ) } return nil } 
func expand Cluster VMHost Rule Info ( d * schema . Resource Data ) ( * types . Cluster Vm Host Rule Info , error ) { obj : = & types . Cluster Vm Host Rule Info { Cluster Rule Info : types . Cluster Rule Info { Enabled : structure . Get Bool ( d , " " ) , Mandatory : structure . Get Bool ( d , " " ) , Name : d . Get ( " " ) . ( string ) , User Created : structure . Bool Ptr ( true ) , } , Affine Host Group Name : d . Get ( " " ) . ( string ) , Anti Affine Host Group Name : d . Get ( " " ) . ( string ) , Vm Group Name : d . Get ( " " ) . ( string ) , } return obj , nil } 
func flatten Cluster VMHost Rule Info ( d * schema . Resource Data , obj * types . Cluster Vm Host Rule Info ) error { return structure . Set Batch ( d , map [ string ] interface { } { " " : obj . Enabled , " " : obj . Mandatory , " " : obj . Name , " " : obj . Affine Host Group Name , " " : obj . Anti Affine Host Group Name , " " : obj . Vm Group Name , } ) } 
func resource VSphere Compute Cluster VMHost Rule Find Entry By Name ( cluster * object . Cluster Compute Resource , name string , ) ( * types . Cluster Vm Host Rule Info , error ) { props , err : = clustercomputeresource . Properties ( cluster ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , info : = range props . Configuration Ex . ( * types . Cluster Config Info Ex ) . Rule { if info . Get Cluster Rule Info ( ) . Name = = name { if vm Host Rule Info , ok : = info . ( * types . Cluster Vm Host Rule Info ) ; ok { log . Printf ( " " , name , cluster . Name ( ) ) return vm Host Rule Info , nil } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } } return nil , fmt . Errorf ( " " , name , cluster . Name ( ) ) } 
func resource VSphere Compute Cluster VMHost Rule Objects ( d * schema . Resource Data , meta interface { } , ) ( * object . Cluster Compute Resource , int 3 2 , error ) { if d . Id ( ) ! = " " { return resource VSphere Compute Cluster VMHost Rule Objects From ID ( d , meta ) } return resource VSphere Compute Cluster VMHost Rule Objects From Attributes ( d , meta ) } 
func resource VSphere Virtual Machine Migrate State ( version int , os * terraform . Instance State , meta interface { } ) ( * terraform . Instance State , error ) { } } var migrate Func func ( * terraform . Instance State , interface { } ) error switch version { case 2 : log . Printf ( " " , version , os ) migrate Func = migrate VSphere Virtual Machine State V 3 case 1 : log . Printf ( " " , version , os ) migrate Func = migrate VSphere Virtual Machine State V 2 case 0 : log . Printf ( " " , version , os ) migrate Func = migrate VSphere Virtual Machine State V 1 default : return os , nil } if err : = migrate Func ( os , meta ) ; err ! = nil { return nil , err } version + + log . Printf ( " " , version , os ) return resource VSphere Virtual Machine Migrate State ( version , os , meta ) } 
func migrate VSphere Virtual Machine State V 3 ( is * terraform . Instance State , meta interface { } ) error { id : = is . ID log . Printf ( " " , id ) vm , err : = virtualmachine . From UUID ( client , id ) if err ! = nil { return fmt . Errorf ( " " , err ) } props , err : = virtualmachine . Properties ( vm ) if err ! = nil { return fmt . Errorf ( " " , err ) } l : = object . Virtual Device List ( props . Config . Hardware . Device ) for i : = 0 ; i < disk Cnt ; i + + { v , ok : = is . Attributes [ fmt . Sprintf ( " " , i ) ] if ! ok { return fmt . Errorf ( " " , i ) } key , err : = strconv . Atoi ( v ) if err ! = nil { return fmt . Errorf ( " " , i , err ) } if key < 1 { } device : = l . Find By Key ( int 3 2 ( key ) ) if device = = nil { } disk , ok : = device . ( * types . Virtual Disk ) if ! ok { } backing , ok : = disk . Backing . ( * types . Virtual Disk Flat Ver 2Backing Info ) if ! ok { } is . Attributes [ fmt . Sprintf ( " " , i ) ] = backing . Uuid } d : = resource VSphere Virtual Machine ( ) . Data ( & terraform . Instance State { } ) log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) return nil } 
func migrate VSphere Virtual Machine State V 2 ( is * terraform . Instance State , meta interface { } ) error { name : = is . ID id : = is . Attributes [ " " ] if id = = " " { return fmt . Errorf ( " " , name ) } log . Printf ( " " , name , id ) vm , err : = virtualmachine . From UUID ( client , id ) if err ! = nil { return fmt . Errorf ( " " , err ) } props , err : = virtualmachine . Properties ( vm ) if err ! = nil { return fmt . Errorf ( " " , err ) } max Bus : = disk Cnt / 1 5 l : = object . Virtual Device List ( props . Config . Hardware . Device ) for k , v : = range is . Attributes { if ! regexp . Must Compile ( " \ \ \ \ " ) . Match String ( k ) { continue } key , _ : = strconv . Atoi ( v ) if key < 1 { continue } device : = l . Find By Key ( int 3 2 ( key ) ) if device = = nil { continue } ctlr : = l . Find By Key ( device . Get Virtual Device ( ) . Controller Key ) if ctlr = = nil { continue } if sc , ok : = ctlr . ( types . Base Virtual SCSIController ) ; ok & & sc . Get Virtual SCSIController ( ) . Bus Number > int 3 2 ( max Bus ) { max Bus = int ( sc . Get Virtual SCSIController ( ) . Bus Number ) } } d : = resource VSphere Virtual Machine ( ) . Data ( & terraform . Instance State { } ) d . Set ( " " , max Bus + 1 ) if err : = virtualdevice . Disk Import Operation ( d , client , object . Virtual Device List ( props . Config . Hardware . Device ) ) ; err ! = nil { return err } rs : = resource VSphere Virtual Machine ( ) . Schema var guest Net Timeout string switch is . Attributes [ " " ] { case " " : guest Net Timeout = " " default : guest Net Timeout = fmt . Sprintf ( " " , rs [ " " ] . Default ) } is . ID = id is . Attributes [ " " ] = " " is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = guest Net Timeout is . Attributes [ " " ] = fmt . Sprintf ( " " , rs [ " " ] . Default ) is . Attributes [ " " ] = fmt . Sprintf ( " " , max Bus + 1 ) for k , v : = range d . State ( ) . Attributes { if strings . Has Prefix ( k , " " ) { is . Attributes [ k ] = v } } log . Printf ( " " , resource VSphere Virtual Machine IDString ( d ) ) return nil } 
func New Environment Browser ( c * vim 2 5 . Client , ref types . Managed Object Reference ) * Environment Browser { return & Environment Browser { Common : object . New Common ( c , ref ) , } } 
func ( b * Environment Browser ) Default Devices ( ctx context . Context , key string , host * object . Host System ) ( object . Virtual Device List , error ) { var eb mo . Environment Browser err : = b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err ! = nil { return nil , err } req : = types . Query Config Option { This : b . Reference ( ) , Key : key , } if host ! = nil { ref : = host . Reference ( ) req . Host = & ref } res , err : = methods . Query Config Option ( ctx , b . Client ( ) , & req ) if err ! = nil { return nil , err } if res . Returnval = = nil { return nil , errors . New ( " " ) } return object . Virtual Device List ( res . Returnval . Default Device ) , nil } 
func ( b * Environment Browser ) OSFamily ( ctx context . Context , guest string ) ( string , error ) { var eb mo . Environment Browser err : = b . Properties ( ctx , b . Reference ( ) , nil , & eb ) if err ! = nil { return " " , err } req : = types . Query Config Option { This : b . Reference ( ) , } res , err : = methods . Query Config Option ( ctx , b . Client ( ) , & req ) if err ! = nil { return " " , err } if res . Returnval = = nil { return " " , errors . New ( " " ) } for _ , osd : = range res . Returnval . Guest OSDescriptor { if osd . Id = = guest { family : = osd . Family log . Printf ( " " , guest , family ) return family , nil } } return " " , fmt . Errorf ( " " , guest ) } 
func ( b * Environment Browser ) Query Config Option Descriptor ( ctx context . Context ) ( [ ] types . Virtual Machine Config Option Descriptor , error ) { req : = types . Query Config Option Descriptor { This : b . Reference ( ) , } res , err : = methods . Query Config Option Descriptor ( ctx , b . Client ( ) , & req ) if err ! = nil { return nil , err } return res . Returnval , nil } 
func ( p Root Path Particle ) Root From Datacenter ( dc * object . Datacenter ) string { return dc . Inventory Path + " " + string ( p ) } 
func ( p Root Path Particle ) Path From Datacenter ( dc * object . Datacenter , relative string ) string { return p . Root From Datacenter ( dc ) + " " + relative } 
func ( p Root Path Particle ) Split Datacenter ( inventory Path string ) ( string , error ) { s : = strings . Split N ( inventory Path , p . Delimiter ( ) , 2 ) if len ( s ) ! = 2 { return inventory Path , fmt . Errorf ( " " , inventory Path , p . Delimiter ( ) ) } return s [ 0 ] , nil } 
func ( p Root Path Particle ) Split Relative Folder ( inventory Path string ) ( string , error ) { relative , err : = p . Split Relative ( inventory Path ) if err ! = nil { return inventory Path , err } return path . Dir ( relative ) , nil } 
func ( p Root Path Particle ) New Root From Path ( inventory Path string , new Particle Root Path Particle ) ( string , error ) { dc Path , err : = p . Split Datacenter ( inventory Path ) if err ! = nil { return inventory Path , err } return fmt . Sprintf ( " " , dc Path , new Particle ) , nil } 
func ( p Root Path Particle ) Path From New Root ( inventory Path string , new Particle Root Path Particle , relative string ) ( string , error ) { root Path , err : = p . New Root From Path ( inventory Path , new Particle ) if err ! = nil { return inventory Path , err } return path . Clean ( fmt . Sprintf ( " " , root Path , relative ) ) , nil } 
func datacenter Path From Host System ID ( client * govmomi . Client , hs ID string ) ( string , error ) { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return " " , err } return Root Path Particle Host . Split Datacenter ( hs . Inventory Path ) } 
func datastore Root Path From Host System ID ( client * govmomi . Client , hs ID string ) ( string , error ) { hs , err : = hostsystem . From ID ( client , hs ID ) if err ! = nil { return " " , err } return Root Path Particle Host . New Root From Path ( hs . Inventory Path , Root Path Particle Datastore ) } 
func From Absolute Path ( client * govmomi . Client , path string ) ( * object . Folder , error ) { finder : = find . New Finder ( client . Client , false ) ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) folder , err : = finder . Folder ( ctx , path ) if err ! = nil { return nil , err } return folder , nil } 
func folder From Object ( client * govmomi . Client , obj interface { } , folder Type Root Path Particle , relative string ) ( * object . Folder , error ) { } var p string var err error switch o : = obj . ( type ) { case * object . Vmware Distributed Virtual Switch : p , err = Root Path Particle Network . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Datastore : p , err = Root Path Particle Datastore . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Storage Pod : p , err = Root Path Particle Datastore . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Host System : p , err = Root Path Particle Host . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Resource Pool : p , err = Root Path Particle Host . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Compute Resource : p , err = Root Path Particle Host . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Cluster Compute Resource : p , err = Root Path Particle Host . Path From New Root ( o . Inventory Path , folder Type , relative ) case * object . Virtual Machine : p , err = Root Path Particle VM . Path From New Root ( o . Inventory Path , folder Type , relative ) default : return nil , fmt . Errorf ( " " , o ) } if err ! = nil { return nil , err } return From Absolute Path ( client , p ) } 
func Datastore Folder From Object ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err : = folder From Object ( client , obj , Root Path Particle Datastore , relative ) if err ! = nil { return nil , err } return validate Datastore Folder ( folder ) } 
func Host Folder From Object ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err : = folder From Object ( client , obj , Root Path Particle Host , relative ) if err ! = nil { return nil , err } return validate Host Folder ( folder ) } 
func Virtual Machine Folder From Object ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { log . Printf ( " " , relative ) folder , err : = folder From Object ( client , obj , Root Path Particle VM , relative ) if err ! = nil { return nil , err } return validate Virtual Machine Folder ( folder ) } 
func network Folder From Object ( client * govmomi . Client , obj interface { } , relative string ) ( * object . Folder , error ) { folder , err : = folder From Object ( client , obj , Root Path Particle Network , relative ) if err ! = nil { return nil , err } return validate Network Folder ( folder ) } 
func validate Datastore Folder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err : = Find Type ( folder ) if err ! = nil { return nil , err } if ft ! = VSphere Folder Type Datastore { return nil , fmt . Errorf ( " " , folder . Inventory Path ) } return folder , nil } 
func validate Host Folder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err : = Find Type ( folder ) if err ! = nil { return nil , err } if ft ! = VSphere Folder Type Host { return nil , fmt . Errorf ( " " , folder . Inventory Path ) } return folder , nil } 
func validate Virtual Machine Folder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err : = Find Type ( folder ) if err ! = nil { return nil , err } if ft ! = VSphere Folder Type VM { return nil , fmt . Errorf ( " " , folder . Inventory Path ) } log . Printf ( " " , folder . Inventory Path ) return folder , nil } 
func validate Network Folder ( folder * object . Folder ) ( * object . Folder , error ) { ft , err : = Find Type ( folder ) if err ! = nil { return nil , err } if ft ! = VSphere Folder Type Network { return nil , fmt . Errorf ( " " , folder . Inventory Path ) } return folder , nil } 
func Normalize Path ( v interface { } ) string { p : = v . ( string ) if Path Is Empty ( p ) { return " " } return strings . Trim Prefix ( path . Clean ( p ) , " " ) } 
func Move Object To ( ref types . Managed Object Reference , folder * object . Folder ) error { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) task , err : = folder . Move Into ( ctx , [ ] types . Managed Object Reference { ref } ) if err ! = nil { return err } tctx , tcancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer tcancel ( ) return task . Wait ( tctx ) } 
func From Path ( c * govmomi . Client , p string , ft VSphere Folder Type , dc * object . Datacenter ) ( * object . Folder , error ) { var fp string if ft = = VSphere Folder Type Datacenter { fp = " " + p } else { pt : = Root Path Particle ( ft ) fp = pt . Path From Datacenter ( dc , p ) } return From Absolute Path ( c , fp ) } 
func Parent From Path ( c * govmomi . Client , p string , ft VSphere Folder Type , dc * object . Datacenter ) ( * object . Folder , error ) { return From Path ( c , path . Dir ( p ) , ft , dc ) } 
func Properties ( folder * object . Folder ) ( * mo . Folder , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) var props mo . Folder if err : = folder . Properties ( ctx , folder . Reference ( ) , nil , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func Find Type ( folder * object . Folder ) ( VSphere Folder Type , error ) { var ft VSphere Folder Type props , err : = Properties ( folder ) if err ! = nil { return ft , err } if props . Child Type [ 0 ] ! = " " { ct = props . Child Type [ 0 ] } else { ct = props . Child Type [ 1 ] } switch ct { case " " : ft = VSphere Folder Type Datacenter case " " : ft = VSphere Folder Type Host case " " : ft = VSphere Folder Type VM case " " : ft = VSphere Folder Type Datastore case " " : ft = VSphere Folder Type Network default : return ft , fmt . Errorf ( " " , ct ) } return ft , nil } 
func Has Children ( f * object . Folder ) ( bool , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , provider . Default APITimeout ) defer cancel ( ) children , err : = f . Children ( ctx ) if err ! = nil { return false , err } return len ( children ) > 0 , nil } 
func ( opts List Opts ) To Server List Query ( ) ( string , error ) { q , err : = gophercloud . Build Query String ( opts ) return q . String ( ) , err } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { auth Token : = args Or Env ( args , " " , " " ) project ID : = args Or Env ( args , " " , " " ) packet URL : = args Or Env ( args , " " , " " ) address Type : = args [ " " ] packet Facilities : = args [ " " ] packet Tags : = args [ " " ] if address Type ! = " " & & address Type ! = " " & & address Type ! = " " { l . Printf ( " " , address Type ) address Type = " " } include Facilities : = include Args ( packet Facilities ) include Tags : = include Args ( packet Tags ) c , err : = client ( p . user Agent , packet URL , auth Token ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } var devices [ ] packngo . Device if project ID = = " " { return nil , fmt . Errorf ( " " ) } devices , _ , err = c . Devices . List ( project ID , nil ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } var addrs [ ] string for _ , d : = range devices { if len ( include Facilities ) > 0 & & ! Include ( include Facilities , d . Facility . Code ) { continue } if len ( include Tags ) > 0 & & ! Any ( d . Tags , func ( v string ) bool { return Include ( include Tags , v ) } ) { continue } address Family : = 4 if address Type = = " " { address Family = 6 } for _ , n : = range d . Network { if ( n . Public = = ( address Type = = " " | | address Type = = " " ) ) & & n . Address Family = = address Family { addrs = append ( addrs , n . Address ) } } } return addrs , nil } 
func Index ( vs [ ] string , t string ) int { for i , v : = range vs { if v = = t { return i } } return - 1 } 
func Any ( vs [ ] string , f func ( string ) bool ) bool { for _ , v : = range vs { if f ( v ) { return true } } return false } 
func client ( path string ) ( * http . Client , error ) { if path = = " " { return google . Default Client ( oauth 2 . No Context , compute . Compute Scope ) } key , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } jwt Config , err : = google . JWTConfig From JSON ( key , compute . Compute Scope ) if err ! = nil { return nil , err } return jwt Config . Client ( oauth 2 . No Context ) , nil } 
func lookup Project ( ) ( string , error ) { req , err : = http . New Request ( " " , " " , nil ) if err ! = nil { return " " , err } req . Header . Add ( " " , " " ) resp , err : = http . Default Client . Do ( req ) if err ! = nil { return " " , err } defer resp . Body . Close ( ) if resp . Status Code ! = 2 0 0 { return " " , fmt . Errorf ( " " , resp . Status Code ) } project , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return " " , err } return string ( project ) , nil } 
func lookup Zones ( svc * compute . Service , project , pattern string ) ( [ ] string , error ) { call : = svc . Zones . List ( project ) if pattern ! = " " { call = call . Filter ( " " + pattern ) } var zones [ ] string f : = func ( page * compute . Zone List ) error { for _ , v : = range page . Items { zones = append ( zones , v . Name ) } return nil } if err : = call . Pages ( oauth 2 . No Context , f ) ; err ! = nil { return nil , err } return zones , nil } 
func lookup Addrs ( svc * compute . Service , project , zone , tag string ) ( [ ] string , error ) { var addrs [ ] string f : = func ( page * compute . Instance List ) error { for _ , v : = range page . Items { if len ( v . Network Interfaces ) = = 0 | | v . Network Interfaces [ 0 ] . Network IP = = " " { continue } for _ , t : = range v . Tags . Items { if t = = tag { addrs = append ( addrs , v . Network Interfaces [ 0 ] . Network IP ) break } } } return nil } call : = svc . Instances . List ( project , zone ) if err : = call . Pages ( oauth 2 . No Context , f ) ; err ! = nil { return nil , err } return addrs , nil } 
func New ( opts . . . Option ) ( * Discover , error ) { d : = new ( Discover ) for _ , opt : = range opts { if err : = opt ( d ) ; err ! = nil { return nil , err } } d . once . Do ( d . init Providers ) return d , nil } 
func With User Agent ( agent string ) Option { return func ( d * Discover ) error { d . user Agent = agent return nil } } 
func With Providers ( m map [ string ] Provider ) Option { return func ( d * Discover ) error { d . Providers = m return nil } } 
func ( d * Discover ) Names ( ) [ ] string { d . once . Do ( d . init Providers ) var names [ ] string for n : = range d . Providers { names = append ( names , n ) } sort . Strings ( names ) return names } 
func ( d * Discover ) Help ( ) string { d . once . Do ( d . init Providers ) h : = [ ] string { global Help } for _ , name : = range d . Names ( ) { h = append ( h , d . Providers [ name ] . Help ( ) ) } return strings . Join ( h , " \n " ) } 
func ( d * Discover ) Addrs ( cfg string , l * log . Logger ) ( [ ] string , error ) { d . once . Do ( d . init Providers ) args , err : = Parse ( cfg ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } name : = args [ " " ] if name = = " " { return nil , fmt . Errorf ( " " ) } providers : = d . Providers if providers = = nil { providers = Providers } p : = providers [ name ] if p = = nil { return nil , fmt . Errorf ( " " + name ) } l . Printf ( " " , name ) if typ , ok : = p . ( Provider With User Agent ) ; ok { typ . Set User Agent ( d . user Agent ) return p . Addrs ( args , l ) } return p . Addrs ( args , l ) } 
func ( c Config ) String ( ) string { for k : = range c { if k ! = " " { keys = append ( keys , k ) } } sort . Strings ( keys ) keys = append ( [ ] string { " " } , keys . . . ) quote : = func ( s string ) string { if strings . Contains Any ( s , ` " \ ` ) { return strconv . Quote ( s ) } return s } var vals [ ] string for _ , k : = range keys { v : = c [ k ] if v = = " " { continue } vals = append ( vals , quote ( k ) + " " + quote ( v ) ) } return strings . Join ( vals , " " ) } 
func Pod Addrs ( pods * corev 1 . Pod List , args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { host Network : = false if v : = args [ " " ] ; v ! = " " { var err error host Network , err = strconv . Parse Bool ( v ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } var addrs [ ] string Pod Loop : for _ , pod : = range pods . Items { if pod . Status . Phase ! = corev 1 . Pod Running { l . Printf ( " " , pod . Name , pod . Status . Phase ) continue } continue Pod Loop } } if host Network { addr = pod . Status . Host IP } if addr = = " " { continue } if err ! = nil { l . Printf ( " " , pod . Name , err ) continue } addr = fmt . Sprintf ( " " , addr , port ) } addrs = append ( addrs , addr ) } return addrs , nil } 
func pod Port ( pod * corev 1 . Pod , annotation string , host bool ) ( int 3 2 , error ) { } return port Def . Host Port , nil } return port Def . Container Port , nil } } } return int 3 2 ( v ) , err } 
func args Or Env ( args map [ string ] string , key , env string ) string { if value , ok : = args [ key ] ; ok { return value } return os . Getenv ( env ) } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { var params * m . Query Param var ch chan * m . Service Entry var v 6 , v 4 bool var addrs [ ] string var err error } } params . Service = args [ " " ] } else { params . Domain = " " } } } else { params . Timeout = 5 * time . Second } } } else { v 6 = true } } } else { v 4 = true } defer close ( ch ) params . Entries = ch for e : = range ch { addr = " " if v 6 & & e . Addr V 6 ! = nil { addr = net . Join Host Port ( e . Addr V 6 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr = = " " & & v 4 & & e . Addr V 4 ! = nil { addr = net . Join Host Port ( e . Addr V 4 . String ( ) , strconv . Itoa ( e . Port ) ) } if addr ! = " " { l . Printf ( " " , e . Host , addr ) } } } ( ) } 
func set Log ( l * log . Logger ) { if l ! = nil { logger = l } else { logger = log . New ( ioutil . Discard , " " , 0 ) } } 
func discover Err ( format string , a . . . interface { } ) error { var s string if len ( a ) > 1 { s = fmt . Sprintf ( format , a . . . ) } else { s = format } return fmt . Errorf ( " " , s ) } 
func value Or Env ( config map [ string ] string , key , env string ) string { if v : = config [ key ] ; v ! = " " { return v } if v : = os . Getenv ( env ) ; v ! = " " { logger . Printf ( " " , env , key ) return v } return " " } 
func vim URL ( server , user , password string ) ( * url . URL , error ) { u , err : = url . Parse ( " " + server + " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } u . User = url . User Password ( user , password ) return u , nil } 
func new VSphere Client ( ctx context . Context , host , user , password string , insecure bool ) ( * v Sphere Client , error ) { logger . Println ( " " ) client : = new ( v Sphere Client ) u , err : = vim URL ( host , user , password ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , err } client . Tags Client , err = new Rest Session ( ctx , u , insecure ) if err ! = nil { return nil , err } logger . Println ( " " ) return client , nil } 
func new Vim Session ( ctx context . Context , u * url . URL , insecure bool ) ( * govmomi . Client , error ) { logger . Printf ( " " , u . Host ) client , err : = govmomi . New Client ( ctx , u , insecure ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } logger . Println ( " " ) return client , nil } 
func new Rest Session ( ctx context . Context , u * url . URL , insecure bool ) ( * tags . Rest Client , error ) { logger . Printf ( " " , u . Host ) client : = tags . New Client ( u , insecure , " " ) if err : = client . Login ( ctx ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } logger . Println ( " " ) return client , nil } 
func ( p * Provider ) Addrs ( args map [ string ] string , l * log . Logger ) ( [ ] string , error ) { if args [ " " ] ! = " " { return nil , discover Err ( " " , args [ " " ] ) } set Log ( l ) tag Name : = args [ " " ] category Name : = args [ " " ] host : = value Or Env ( args , " " , " " ) user : = value Or Env ( args , " " , " " ) password : = value Or Env ( args , " " , " " ) insecure , err : = strconv . Parse Bool ( value Or Env ( args , " " , " " ) ) if err ! = nil { logger . Println ( " " ) } timeout , err : = time . Parse Duration ( args [ " " ] ) if err ! = nil { logger . Println ( " " ) timeout = time . Minute * 1 0 } ctx , cancel : = context . With Timeout ( context . Background ( ) , timeout ) defer cancel ( ) client , err : = new VSphere Client ( ctx , host , user , password , insecure ) if err ! = nil { return nil , discover Err ( err . Error ( ) ) } if tag Name = = " " | | category Name = = " " { return nil , discover Err ( " " ) } logger . Printf ( " " , tag Name , category Name ) tag ID , err : = tag IDFrom Name ( ctx , client . Tags Client , tag Name , category Name ) if err ! = nil { return nil , discover Err ( err . Error ( ) ) } addrs , err : = virtual Machine IPs For Tag ( ctx , client , tag ID ) if err ! = nil { return nil , discover Err ( err . Error ( ) ) } logger . Printf ( " " , strings . Join ( addrs , " " ) ) return addrs , nil } 
func tag IDFrom Name ( ctx context . Context , client * tags . Rest Client , name , category string ) ( string , error ) { logger . Printf ( " " , name , category ) category ID , err : = tag Category By Name ( ctx , client , category ) if err ! = nil { return " " , err } return tag By Name ( ctx , client , name , category ID ) } 
func tag Category By Name ( ctx context . Context , client * tags . Rest Client , name string ) ( string , error ) { cats , err : = client . Get Categories By Name ( ctx , name ) if err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( cats ) < 1 { return " " , fmt . Errorf ( " " , name ) } if len ( cats ) > 1 { } return cats [ 0 ] . ID , nil } 
func tag By Name ( ctx context . Context , client * tags . Rest Client , name , category ID string ) ( string , error ) { tids , err : = client . Get Tag By Name For Category ( ctx , name , category ID ) if err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } if len ( tids ) < 1 { return " " , fmt . Errorf ( " " , name , category ID ) } if len ( tids ) > 1 { } logger . Printf ( " " , tids [ 0 ] . ID ) return tids [ 0 ] . ID , nil } 
func virtual Machine IPs For Tag ( ctx context . Context , client * v Sphere Client , id string ) ( [ ] string , error ) { vms , err : = virtual Machines For Tag ( ctx , client , id ) if err ! = nil { return nil , err } return ip Addrs For Virtual Machines ( ctx , client , vms ) } 
func virtual Machines For Tag ( ctx context . Context , client * v Sphere Client , id string ) ( [ ] * object . Virtual Machine , error ) { logger . Printf ( " " , id ) var vms [ ] * object . Virtual Machine objs , err : = client . Tags Client . List Attached Objects ( ctx , id ) if err ! = nil { return nil , err } for i , obj : = range objs { switch { case obj . Type = = nil | | obj . ID = = nil : logger . Printf ( " " , i ) continue case * obj . Type ! = " " : logger . Printf ( " " , * obj . ID ) continue } vm , err : = virtual Machine From MOID ( ctx , client . Vim Client , * obj . ID ) if err ! = nil { return nil , fmt . Errorf ( " " , * obj . ID , err ) } vms = append ( vms , vm ) } logger . Printf ( " " , virtual Machine Names ( vms ) ) return vms , nil } 
func ip Addrs For Virtual Machines ( ctx context . Context , client * v Sphere Client , vms [ ] * object . Virtual Machine ) ( [ ] string , error ) { var addrs [ ] string for _ , vm : = range vms { as , err : = build And Select Guest IPs ( ctx , vm ) if err ! = nil { return nil , err } addrs = append ( addrs , as . . . ) } return addrs , nil } 
func virtual Machine From MOID ( ctx context . Context , client * govmomi . Client , id string ) ( * object . Virtual Machine , error ) { logger . Printf ( " " , id ) finder : = find . New Finder ( client . Client , false ) ref : = types . Managed Object Reference { Type : " " , Value : id , } vm , err : = finder . Object Reference ( ctx , ref ) if err ! = nil { return nil , err } } 
func virtual Machine Properties ( ctx context . Context , vm * object . Virtual Machine , keys [ ] string ) ( * mo . Virtual Machine , error ) { logger . Printf ( " " , vm . Name ( ) ) var props mo . Virtual Machine if err : = vm . Properties ( ctx , vm . Reference ( ) , keys , & props ) ; err ! = nil { return nil , err } return & props , nil } 
func build And Select Guest IPs ( ctx context . Context , vm * object . Virtual Machine ) ( [ ] string , error ) { logger . Printf ( " " , vm . Name ( ) ) var addrs [ ] string props , err : = virtual Machine Properties ( ctx , vm , [ ] string { " " } ) if err ! = nil { return nil , fmt . Errorf ( " " , vm . Name ( ) , err ) } if props . Guest = = nil | | props . Guest . Net = = nil { logger . Printf ( " " , vm . Name ( ) ) return nil , nil } } addrs = append ( addrs , addr . Ip Address ) } } } logger . Printf ( " " , vm . Name ( ) , strings . Join ( addrs , " " ) ) return addrs , nil } 
func skip IPAddr ( ip net . IP ) bool { switch { case ip . Is Link Local Multicast ( ) : fallthrough case ip . Is Link Local Unicast ( ) : fallthrough case ip . Is Loopback ( ) : fallthrough case ip . Is Multicast ( ) : return true } return false } 
func virtual Machine Names ( vms [ ] * object . Virtual Machine ) string { var s [ ] string for _ , vm : = range vms { s = append ( s , vm . Name ( ) ) } return strings . Join ( s , " " ) } 
func validate And Wrap Handler ( h Handler ) Handler { if reflect . Type Of ( h ) . Kind ( ) ! = reflect . Func { panic ( " " ) } if ! inject . Is Fast Invoker ( h ) { switch v : = h . ( type ) { case func ( * Context ) : return Context Invoker ( v ) case func ( * Context , * log . Logger ) : return Logger Invoker ( v ) case func ( http . Response Writer , * http . Request ) : return handler Func Invoker ( v ) case func ( http . Response Writer , error ) : return internal Server Error Invoker ( v ) } } return h } 
func validate And Wrap Handlers ( handlers [ ] Handler , wrappers . . . func ( Handler ) Handler ) [ ] Handler { var wrapper func ( Handler ) Handler if len ( wrappers ) > 0 { wrapper = wrappers [ 0 ] } wrapped Handlers : = make ( [ ] Handler , len ( handlers ) ) for i , h : = range handlers { h = validate And Wrap Handler ( h ) if wrapper ! = nil & & ! inject . Is Fast Invoker ( h ) { h = wrapper ( h ) } wrapped Handlers [ i ] = h } return wrapped Handlers } 
func New With Logger ( out io . Writer ) * Macaron { m : = & Macaron { Injector : inject . New ( ) , action : func ( ) { } , Router : New Router ( ) , logger : log . New ( out , " " , 0 ) , } m . Router . m = m m . Map ( m . logger ) m . Map ( default Return Handler ( ) ) m . Not Found ( http . Not Found ) m . Internal Server Error ( func ( rw http . Response Writer , err error ) { http . Error ( rw , err . Error ( ) , 5 0 0 ) } ) return m } 
func Classic ( ) * Macaron { m : = New ( ) m . Use ( Logger ( ) ) m . Use ( Recovery ( ) ) m . Use ( Static ( " " ) ) return m } 
func ( m * Macaron ) Handlers ( handlers . . . Handler ) { m . handlers = make ( [ ] Handler , 0 ) for _ , handler : = range handlers { m . Use ( handler ) } } 
func ( m * Macaron ) Action ( handler Handler ) { handler = validate And Wrap Handler ( handler ) m . action = handler } 
func ( m * Macaron ) Use ( handler Handler ) { handler = validate And Wrap Handler ( handler ) m . handlers = append ( m . handlers , handler ) } 
func ( m * Macaron ) Serve HTTP ( rw http . Response Writer , req * http . Request ) { if m . has URLPrefix { req . URL . Path = strings . Trim Prefix ( req . URL . Path , m . url Prefix ) } for _ , h : = range m . befores { if h ( rw , req ) { return } } m . Router . Serve HTTP ( rw , req ) } 
func ( m * Macaron ) Run ( args . . . interface { } ) { host , port : = Get Default Listen Info ( ) if len ( args ) = = 1 { switch arg : = args [ 0 ] . ( type ) { case string : host = arg case int : port = arg } } else if len ( args ) > = 2 { if arg , ok : = args [ 0 ] . ( string ) ; ok { host = arg } if arg , ok : = args [ 1 ] . ( int ) ; ok { port = arg } } addr : = host + " " + com . To Str ( port ) logger : = m . Get Val ( reflect . Type Of ( m . logger ) ) . Interface ( ) . ( * log . Logger ) logger . Printf ( " \n " , addr , safe Env ( ) ) logger . Fatalln ( http . Listen And Serve ( addr , m ) ) } 
func ( m * Macaron ) Set URLPrefix ( prefix string ) { m . url Prefix = prefix m . has URLPrefix = len ( m . url Prefix ) > 0 } 
func Set Config ( source interface { } , others . . . interface { } ) ( _ * ini . File , err error ) { cfg , err = ini . Load ( source , others . . . ) return Config ( ) , err } 
func ( rb * Request Body ) String ( ) ( string , error ) { data , err : = rb . Bytes ( ) return string ( data ) , err } 
func ( ctx * Context ) Remote Addr ( ) string { addr : = ctx . Req . Header . Get ( " " ) if len ( addr ) = = 0 { addr = ctx . Req . Header . Get ( " " ) if addr = = " " { addr = ctx . Req . Remote Addr if i : = strings . Last Index ( addr , " " ) ; i > - 1 { addr = addr [ : i ] } } } return addr } 
func ( ctx * Context ) HTML ( status int , name string , data . . . interface { } ) { ctx . render HTML ( status , DEFAULT _TPL _SET _NAME , name , data . . . ) } 
func ( ctx * Context ) HTMLSet ( status int , set Name , tpl Name string , data . . . interface { } ) { ctx . render HTML ( status , set Name , tpl Name , data . . . ) } 
func ( ctx * Context ) Query ( name string ) string { ctx . parse Form ( ) return ctx . Req . Form . Get ( name ) } 
func ( ctx * Context ) Query Trim ( name string ) string { return strings . Trim Space ( ctx . Query ( name ) ) } 
func ( ctx * Context ) Query Strings ( name string ) [ ] string { ctx . parse Form ( ) vals , ok : = ctx . Req . Form [ name ] if ! ok { return [ ] string { } } return vals } 
func ( ctx * Context ) Query Escape ( name string ) string { return template . HTMLEscape String ( ctx . Query ( name ) ) } 
func ( ctx * Context ) Query Bool ( name string ) bool { v , _ : = strconv . Parse Bool ( ctx . Query ( name ) ) return v } 
func ( ctx * Context ) Query Int ( name string ) int { return com . Str To ( ctx . Query ( name ) ) . Must Int ( ) } 
func ( ctx * Context ) Query Int 6 4 ( name string ) int 6 4 { return com . Str To ( ctx . Query ( name ) ) . Must Int 6 4 ( ) } 
func ( ctx * Context ) Query Float 6 4 ( name string ) float 6 4 { v , _ : = strconv . Parse Float ( ctx . Query ( name ) , 6 4 ) return v } 
func ( ctx * Context ) Params ( name string ) string { if len ( name ) = = 0 { return " " } if len ( name ) > 1 & & name [ 0 ] ! = ' : ' { name = " " + name } return ctx . params [ name ] } 
func ( ctx * Context ) Set Params ( name , val string ) { if name ! = " " & & ! strings . Has Prefix ( name , " " ) { name = " " + name } ctx . params [ name ] = val } 
func ( ctx * Context ) Params Escape ( name string ) string { return template . HTMLEscape String ( ctx . Params ( name ) ) } 
func ( ctx * Context ) Params Int ( name string ) int { return com . Str To ( ctx . Params ( name ) ) . Must Int ( ) } 
func ( ctx * Context ) Params Int 6 4 ( name string ) int 6 4 { return com . Str To ( ctx . Params ( name ) ) . Must Int 6 4 ( ) } 
func ( ctx * Context ) Params Float 6 4 ( name string ) float 6 4 { v , _ : = strconv . Parse Float ( ctx . Params ( name ) , 6 4 ) return v } 
func ( ctx * Context ) Get File ( name string ) ( multipart . File , * multipart . File Header , error ) { return ctx . Req . Form File ( name ) } 
func ( ctx * Context ) Save To File ( name , save Path string ) error { fr , _ , err : = ctx . Get File ( name ) if err ! = nil { return err } defer fr . Close ( ) fw , err : = os . Open File ( save Path , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 6 6 ) if err ! = nil { return err } defer fw . Close ( ) _ , err = io . Copy ( fw , fr ) return err } 
func ( ctx * Context ) Set Cookie ( name string , value string , others . . . interface { } ) { cookie : = http . Cookie { } cookie . Name = name cookie . Value = url . Query Escape ( value ) if len ( others ) > 0 { switch v : = others [ 0 ] . ( type ) { case int : cookie . Max Age = v case int 6 4 : cookie . Max Age = int ( v ) case int 3 2 : cookie . Max Age = int ( v ) } } cookie . Path = " " if len ( others ) > 1 { if v , ok : = others [ 1 ] . ( string ) ; ok & & len ( v ) > 0 { cookie . Path = v } } if len ( others ) > 2 { if v , ok : = others [ 2 ] . ( string ) ; ok & & len ( v ) > 0 { cookie . Domain = v } } if len ( others ) > 3 { switch v : = others [ 3 ] . ( type ) { case bool : cookie . Secure = v default : if others [ 3 ] ! = nil { cookie . Secure = true } } } if len ( others ) > 4 { if v , ok : = others [ 4 ] . ( bool ) ; ok & & v { cookie . Http Only = true } } if len ( others ) > 5 { if v , ok : = others [ 5 ] . ( time . Time ) ; ok { cookie . Expires = v cookie . Raw Expires = v . Format ( time . Unix Date ) } } ctx . Resp . Header ( ) . Add ( " " , cookie . String ( ) ) } 
func ( ctx * Context ) Get Cookie ( name string ) string { cookie , err : = ctx . Req . Cookie ( name ) if err ! = nil { return " " } val , _ : = url . Query Unescape ( cookie . Value ) return val } 
func ( ctx * Context ) Get Cookie Int ( name string ) int { return com . Str To ( ctx . Get Cookie ( name ) ) . Must Int ( ) } 
func ( ctx * Context ) Get Cookie Int 6 4 ( name string ) int 6 4 { return com . Str To ( ctx . Get Cookie ( name ) ) . Must Int 6 4 ( ) } 
func ( ctx * Context ) Get Cookie Float 6 4 ( name string ) float 6 4 { v , _ : = strconv . Parse Float ( ctx . Get Cookie ( name ) , 6 4 ) return v } 
func ( ctx * Context ) Set Secure Cookie ( name , value string , others . . . interface { } ) { ctx . Set Super Secure Cookie ( default Cookie Secret , name , value , others . . . ) } 
func ( ctx * Context ) Get Secure Cookie ( key string ) ( string , bool ) { return ctx . Get Super Secure Cookie ( default Cookie Secret , key ) } 
func ( ctx * Context ) Set Super Secure Cookie ( secret , name , value string , others . . . interface { } ) { key : = pbkdf 2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1 0 0 0 , 1 6 , sha 2 5 6 . New ) text , err : = com . AESGCMEncrypt ( key , [ ] byte ( value ) ) if err ! = nil { panic ( " " + err . Error ( ) ) } ctx . Set Cookie ( name , hex . Encode To String ( text ) , others . . . ) } 
func ( ctx * Context ) Get Super Secure Cookie ( secret , name string ) ( string , bool ) { val : = ctx . Get Cookie ( name ) if val = = " " { return " " , false } text , err : = hex . Decode String ( val ) if err ! = nil { return " " , false } key : = pbkdf 2 . Key ( [ ] byte ( secret ) , [ ] byte ( secret ) , 1 0 0 0 , 1 6 , sha 2 5 6 . New ) text , err = com . AESGCMDecrypt ( key , text ) return string ( text ) , err = = nil } 
func ( ctx * Context ) Serve Content ( name string , r io . Read Seeker , params . . . interface { } ) { modtime : = time . Now ( ) for _ , p : = range params { switch v : = p . ( type ) { case time . Time : modtime = v } } ctx . set Raw Content Header ( ) http . Serve Content ( ctx . Resp , ctx . Req . Request , name , modtime , r ) } 
func ( ctx * Context ) Serve File Content ( file string , names . . . string ) { var name string if len ( names ) > 0 { name = names [ 0 ] } else { name = path . Base ( file ) } f , err : = os . Open ( file ) if err ! = nil { if Env = = PROD { http . Error ( ctx . Resp , " " , 5 0 0 ) } else { http . Error ( ctx . Resp , err . Error ( ) , 5 0 0 ) } return } defer f . Close ( ) ctx . set Raw Content Header ( ) http . Serve Content ( ctx . Resp , ctx . Req . Request , name , time . Now ( ) , f ) } 
func ( ctx * Context ) Serve File ( file string , names . . . string ) { var name string if len ( names ) > 0 { name = names [ 0 ] } else { name = path . Base ( file ) } ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " + name ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) ctx . Resp . Header ( ) . Set ( " " , " " ) http . Serve File ( ctx . Resp , ctx . Req . Request , file ) } 
func ( ctx * Context ) Change Static Path ( old Path , new Path string ) { if ! filepath . Is Abs ( old Path ) { old Path = filepath . Join ( Root , old Path ) } dir : = statics . Get ( old Path ) if dir ! = nil { statics . Delete ( old Path ) if ! filepath . Is Abs ( new Path ) { new Path = filepath . Join ( Root , new Path ) } * dir = http . Dir ( new Path ) statics . Set ( dir ) } } 
func get Next Wildcard ( pattern string ) ( wildcard , _ string ) { pos : = wildcard Pattern . Find String Index ( pattern ) if pos = = nil { return " " , pattern } wildcard = pattern [ pos [ 0 ] : pos [ 1 ] ] } else if pattern [ pos [ 1 ] ] ! = ' ( ' { switch { case is Special Regexp ( pattern , " " , pos ) : pattern = strings . Replace ( pattern , " " , " " , 1 ) case is Special Regexp ( pattern , " " , pos ) : pattern = strings . Replace ( pattern , " " , " \ \ " , 1 ) default : return wildcard , strings . Replace ( pattern , wildcard , ` ( . + ) ` , 1 ) } } } 
func get Raw Pattern ( raw Pattern string ) string { raw Pattern = strings . Replace ( raw Pattern , " " , " " , - 1 ) raw Pattern = strings . Replace ( raw Pattern , " " , " " , - 1 ) for { start Idx : = strings . Index ( raw Pattern , " " ) if start Idx = = - 1 { break } close Idx : = strings . Index ( raw Pattern , " " ) if close Idx > - 1 { raw Pattern = raw Pattern [ : start Idx ] + raw Pattern [ close Idx + 1 : ] } } return raw Pattern } 
func ( l * Leaf ) URLPath ( pairs . . . string ) string { if len ( pairs ) % 2 ! = 0 { panic ( " " ) } url Path : = l . raw Pattern parent : = l . parent for parent ! = nil { url Path = parent . raw Pattern + " " + url Path parent = parent . parent } for i : = 0 ; i < len ( pairs ) ; i + = 2 { if len ( pairs [ i ] ) = = 0 { panic ( " " + com . To Str ( i ) ) } else if pairs [ i ] [ 0 ] ! = ' : ' & & pairs [ i ] ! = " " & & pairs [ i ] ! = " " { pairs [ i ] = " " + pairs [ i ] } url Path = strings . Replace ( url Path , pairs [ i ] , pairs [ i + 1 ] , 1 ) } return url Path } 
func New Route Map ( ) * route Map { rm : = & route Map { routes : make ( map [ string ] map [ string ] * Leaf ) , } for m : = range _HTTP _METHODS { rm . routes [ m ] = make ( map [ string ] * Leaf ) } return rm } 
func ( rm * route Map ) get Leaf ( method , pattern string ) * Leaf { rm . lock . RLock ( ) defer rm . lock . RUnlock ( ) return rm . routes [ method ] [ pattern ] } 
func ( rm * route Map ) add ( method , pattern string , leaf * Leaf ) { rm . lock . Lock ( ) defer rm . lock . Unlock ( ) rm . routes [ method ] [ pattern ] = leaf } 
func ( r * Route ) Name ( name string ) { if len ( name ) = = 0 { panic ( " " ) } else if r . router . named Routes [ name ] ! = nil { panic ( " " + name ) } r . router . named Routes [ name ] = r . leaf } 
func ( r * Router ) handle ( method , pattern string , handle Handle ) * Route { method = strings . To Upper ( method ) var leaf * Leaf } } if method = = " " { for m : = range _HTTP _METHODS { methods [ m ] = true } } else { methods [ method ] = true } } else { t : = New Tree ( ) leaf = t . Add ( pattern , handle ) r . routers [ m ] = t } r . add ( m , pattern , leaf ) } return & Route { r , leaf } } 
func ( r * Router ) Handle ( method string , pattern string , handlers [ ] Handler ) * Route { if len ( r . groups ) > 0 { group Pattern : = " " h : = make ( [ ] Handler , 0 ) for _ , g : = range r . groups { group Pattern + = g . pattern h = append ( h , g . handlers . . . ) } pattern = group Pattern + pattern h = append ( h , handlers . . . ) handlers = h } handlers = validate And Wrap Handlers ( handlers , r . handler Wrapper ) return r . handle ( method , pattern , func ( resp http . Response Writer , req * http . Request , params Params ) { c : = r . m . create Context ( resp , req ) c . params = params c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers . . . ) c . handlers = append ( c . handlers , handlers . . . ) c . run ( ) } ) } 
func ( r * Router ) Get ( pattern string , h . . . Handler ) ( leaf * Route ) { leaf = r . Handle ( " " , pattern , h ) if r . auto Head { r . Head ( pattern , h . . . ) } return leaf } 
func ( r * Router ) Patch ( pattern string , h . . . Handler ) * Route { return r . Handle ( " " , pattern , h ) } 
func ( r * Router ) Route ( pattern , methods string , h . . . Handler ) ( route * Route ) { for _ , m : = range strings . Split ( methods , " " ) { route = r . Handle ( strings . Trim Space ( m ) , pattern , h ) } return route } 
func ( r * Router ) Combo ( pattern string , h . . . Handler ) * Combo Router { return & Combo Router { r , pattern , h , map [ string ] bool { } , nil } } 
func ( r * Router ) Not Found ( handlers . . . Handler ) { handlers = validate And Wrap Handlers ( handlers ) r . not Found = func ( rw http . Response Writer , req * http . Request ) { c : = r . m . create Context ( rw , req ) c . handlers = make ( [ ] Handler , 0 , len ( r . m . handlers ) + len ( handlers ) ) c . handlers = append ( c . handlers , r . m . handlers . . . ) c . handlers = append ( c . handlers , handlers . . . ) c . run ( ) } } 
func ( r * Router ) Internal Server Error ( handlers . . . Handler ) { handlers = validate And Wrap Handlers ( handlers ) r . internal Server Error = func ( c * Context , err error ) { c . index = 0 c . handlers = handlers c . Map ( err ) c . run ( ) } } 
func ( r * Router ) URLFor ( name string , pairs . . . string ) string { leaf , ok : = r . named Routes [ name ] if ! ok { panic ( " " + name ) } return leaf . URLPath ( pairs . . . ) } 
func ( cr * Combo Router ) Name ( name string ) { if cr . last Route = = nil { panic ( " " ) } cr . last Route . Name ( name ) } 
func New Response Writer ( method string , rw http . Response Writer ) Response Writer { return & response Writer { method , rw , 0 , 0 , nil } } 
func Logger ( ) Handler { return func ( ctx * Context , log * log . Logger ) { start : = time . Now ( ) log . Printf ( " " , time . Now ( ) . Format ( Log Time Format ) , ctx . Req . Method , ctx . Req . Request URI , ctx . Remote Addr ( ) ) rw : = ctx . Resp . ( Response Writer ) ctx . Next ( ) content : = fmt . Sprintf ( " " , time . Now ( ) . Format ( Log Time Format ) , ctx . Req . Method , ctx . Req . Request URI , rw . Status ( ) , http . Status Text ( rw . Status ( ) ) , time . Since ( start ) ) if Color Log { switch rw . Status ( ) { case 2 0 0 , 2 0 1 , 2 0 2 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) case 3 0 1 , 3 0 2 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) case 3 0 4 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) case 4 0 1 , 4 0 3 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) case 4 0 4 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) case 5 0 0 : content = fmt . Sprintf ( " \ 0 3 3 \ 0 3 3 " , content ) } } log . Println ( content ) } } 
func New Tpl File ( name string , data [ ] byte , ext string ) * Tpl File { return & Tpl File { name , data , ext } } 
func New Template File System ( opt Render Options , omit Data bool ) Tpl File System { fs : = Tpl File System { } fs . files = make ( [ ] Template File , 0 , 1 0 ) for i : = len ( opt . Append Directories ) - 1 ; i > = 0 ; i - - { dirs = append ( dirs , opt . Append Directories [ i ] ) } dirs = append ( dirs , opt . Directory ) var err error for i : = range dirs { } dirs [ i ] , err = filepath . Eval Symlinks ( dirs [ i ] ) if err ! = nil { panic ( " " + dirs [ i ] + " " + err . Error ( ) ) } } last Dir : = dirs [ len ( dirs ) - 1 ] if err ! = nil { return err } ext : = Get Ext ( r ) for _ , extension : = range opt . Extensions { if ext ! = extension { continue } var data [ ] byte if ! omit Data { if ! com . Is File ( path ) { continue } data , err = ioutil . Read File ( path ) if err ! = nil { return err } break } } name : = filepath . To Slash ( ( r [ 0 : len ( r ) - len ( ext ) ] ) ) fs . files = append ( fs . files , New Tpl File ( name , data , ext ) ) } return nil } ) ; err ! = nil { panic ( " " + err . Error ( ) ) } return fs } 
func New Template Set ( ) * Template Set { return & Template Set { sets : make ( map [ string ] * template . Template ) , dirs : make ( map [ string ] string ) , } } 
func Generate ETag ( file Size , file Name , mod Time string ) string { etag : = file Size + file Name + mod Time return base 6 4 . Std Encoding . Encode To String ( [ ] byte ( etag ) ) } 
func Populate ( values . . . interface { } ) error { var g Graph for _ , v : = range values { if err : = g . Provide ( & Object { Value : v } ) ; err ! = nil { return err } } return g . Populate ( ) } 
func ( o * Object ) String ( ) string { var buf bytes . Buffer fmt . Fprint ( & buf , o . reflect Type ) if o . Name ! = " " { fmt . Fprintf ( & buf , " " , o . Name ) } return buf . String ( ) } 
func ( g * Graph ) Provide ( objects . . . * Object ) error { for _ , o : = range objects { o . reflect Type = reflect . Type Of ( o . Value ) o . reflect Value = reflect . Value Of ( o . Value ) if o . Fields ! = nil { return fmt . Errorf ( " " , o , ) } if o . Name = = " " { if ! is Struct Ptr ( o . reflect Type ) { return fmt . Errorf ( " " + " " , o . reflect Type , o . Value , ) } if ! o . private { if g . unnamed Type = = nil { g . unnamed Type = make ( map [ reflect . Type ] bool ) } if g . unnamed Type [ o . reflect Type ] { return fmt . Errorf ( " " , o . reflect Type . Elem ( ) . Pkg Path ( ) , o . reflect Type . Elem ( ) . Name ( ) , ) } g . unnamed Type [ o . reflect Type ] = true } g . unnamed = append ( g . unnamed , o ) } else { if g . named = = nil { g . named = make ( map [ string ] * Object ) } if g . named [ o . Name ] ! = nil { return fmt . Errorf ( " " , o . Name ) } g . named [ o . Name ] = o } if g . Logger ! = nil { if o . created { g . Logger . Debugf ( " " , o ) } else if o . embedded { g . Logger . Debugf ( " " , o ) } else { g . Logger . Debugf ( " " , o ) } } } return nil } 
func ( g * Graph ) Populate ( ) error { for _ , o : = range g . named { if o . Complete { continue } if err : = g . populate Explicit ( o ) ; err ! = nil { return err } } for { if i = = len ( g . unnamed ) { break } o : = g . unnamed [ i ] i + + if o . Complete { continue } if err : = g . populate Explicit ( o ) ; err ! = nil { return err } } } if err : = g . populate Unnamed Interface ( o ) ; err ! = nil { return err } } for _ , o : = range g . named { if o . Complete { continue } if err : = g . populate Unnamed Interface ( o ) ; err ! = nil { return err } } return nil } 
func ( g * Graph ) Objects ( ) [ ] * Object { objects : = make ( [ ] * Object , 0 , len ( g . unnamed ) + len ( g . named ) ) for _ , o : = range g . unnamed { if ! o . embedded { objects = append ( objects , o ) } } for _ , o : = range g . named { if ! o . embedded { objects = append ( objects , o ) } } objects [ i ] , objects [ j ] = objects [ j ] , objects [ i ] } return objects } 
func new Pub Sub ( client * pubsub . Client , name string , options * Options , store func ( * points . Points ) ) ( * Pub Sub , error ) { logger : = zapwriter . Logger ( name ) logger . Info ( " " , zap . String ( " " , options . Project ) , zap . String ( " " , options . Subscription ) , ) if options . Project = = " " { return nil , fmt . Errorf ( " " ) } ctx : = context . Background ( ) if client = = nil { c , err : = pubsub . New Client ( ctx , options . Project ) if err ! = nil { return nil , err } client = c } sub : = client . Subscription ( options . Subscription ) exists , err : = sub . Exists ( ctx ) if err ! = nil { return nil , err } if ! exists { } if options . Receiver Go Routines ! = 0 { sub . Receive Settings . Num Goroutines = options . Receiver Go Routines } if options . Receiver Max Bytes ! = 0 { sub . Receive Settings . Max Outstanding Bytes = options . Receiver Max Bytes } if options . Receiver Max Messages ! = 0 { sub . Receive Settings . Max Outstanding Messages = options . Receiver Max Messages } rcv : = & Pub Sub { out : store , name : name , client : client , cancel : cancel , subscription : sub , logger : logger , closed : make ( chan struct { } ) , } m . Ack ( ) } ) if err = = context . Canceled { close ( rcv . closed ) rcv . Stop ( ) break } if err ! = nil { rcv . logger . Error ( err . Error ( ) ) } time . Sleep ( 1 * time . Second ) } } ( ) return rcv , nil } 
func ( rcv * Pub Sub ) Stat ( send helper . Stat Callback ) { messages Received : = atomic . Load Uint 3 2 ( & rcv . messages Received ) send ( " " , float 6 4 ( messages Received ) ) metrics Received : = atomic . Load Uint 3 2 ( & rcv . metrics Received ) send ( " " , float 6 4 ( metrics Received ) ) errors : = atomic . Load Uint 3 2 ( & rcv . errors ) send ( " " , float 6 4 ( errors ) ) if ! rcv . stats As Counters { atomic . Add Uint 3 2 ( & rcv . messages Received , - messages Received ) atomic . Add Uint 3 2 ( & rcv . metrics Received , - metrics Received ) atomic . Add Uint 3 2 ( & rcv . errors , - errors ) } } 
func acquire Gzip Reader ( r io . Reader ) ( * gzip . Reader , error ) { v : = gzip Pool . Get ( ) if v = = nil { return gzip . New Reader ( r ) } zr : = v . ( * gzip . Reader ) if err : = zr . Reset ( r ) ; err ! = nil { return nil , err } return zr , nil } 
func ( api * Api ) Addr ( ) net . Addr { if api . listener = = nil { return nil } return api . listener . Addr ( ) } 
func ( api * Api ) Stat ( send helper . Stat Callback ) { helper . Send And Substract Uint 3 2 ( " " , & api . stat . cache Requests , send ) helper . Send And Substract Uint 3 2 ( " " , & api . stat . cache Request Metrics , send ) helper . Send And Substract Uint 3 2 ( " " , & api . stat . cache Response Metrics , send ) helper . Send And Substract Uint 3 2 ( " " , & api . stat . cache Response Points , send ) } 
func ( api * Api ) Listen ( addr * net . TCPAddr ) error { return api . Start Func ( func ( ) error { tcp Listener , err : = net . Listen TCP ( " " , addr ) if err ! = nil { return err } s : = grpc . New Server ( ) carbonpb . Register Carbon Server ( s , api ) api . Go ( func ( exit chan struct { } ) { < - exit s . Stop ( ) } ) api . Go ( func ( exit chan struct { } ) { defer s . Stop ( ) if err : = s . Serve ( tcp Listener ) ; err ! = nil { } ) api . listener = tcp Listener return nil } ) } 
func New ( config Filename string ) * App { app : = & App { Config Filename : config Filename , Config : New Config ( ) , Prom Registry : prometheus . New Pedantic Registry ( ) , exit : make ( chan bool ) , } return app } 
func ( app * App ) configure ( ) error { var err error cfg , err : = Read Config ( app . Config Filename ) if err ! = nil { return err } cfg . Common . Graph Prefix = strings . Replace ( cfg . Common . Graph Prefix , " " , hostname , - 1 ) } else { cfg . Common . Graph Prefix = strings . Replace ( cfg . Common . Graph Prefix , " " , " " , - 1 ) } if cfg . Whisper . Enabled { cfg . Whisper . Schemas , err = persister . Read Whisper Schemas ( cfg . Whisper . Schemas Filename ) if err ! = nil { return err } if cfg . Whisper . Aggregation Filename ! = " " { cfg . Whisper . Aggregation , err = persister . Read Whisper Aggregation ( cfg . Whisper . Aggregation Filename ) if err ! = nil { return err } } else { cfg . Whisper . Aggregation = persister . New Whisper Aggregation ( ) } } if ! ( cfg . Cache . Write Strategy = = " " | | cfg . Cache . Write Strategy = = " " | | cfg . Cache . Write Strategy = = " " ) { return fmt . Errorf ( " \ " \ " \ " \ " \ " \ " " ) } if cfg . Common . Metric Endpoint = = " " { cfg . Common . Metric Endpoint = Metric Endpoint Local } if cfg . Common . Metric Endpoint ! = Metric Endpoint Local { u , err : = url . Parse ( cfg . Common . Metric Endpoint ) if err ! = nil { return fmt . Errorf ( " " , err . Error ( ) ) } if u . Scheme ! = " " & & u . Scheme ! = " " { return fmt . Errorf ( " " , u . Scheme ) } } app . Config = cfg return nil } 
func ( app * App ) Parse Config ( ) error { app . Lock ( ) defer app . Unlock ( ) err : = app . configure ( ) if app . Prom Registerer = = nil { app . Prom Registerer = prometheus . Wrap Registerer With ( prometheus . Labels ( app . Config . Prometheus . Labels ) , app . Prom Registry , ) } return err } 
func ( app * App ) Reload Config ( ) error { app . Lock ( ) defer app . Unlock ( ) var err error if err = app . configure ( ) ; err ! = nil { return err } runtime . GOMAXPROCS ( app . Config . Common . Max CPU ) app . Cache . Set Max Size ( app . Config . Cache . Max Size ) app . Cache . Set Write Strategy ( app . Config . Cache . Write Strategy ) app . Cache . Set Tags Enabled ( app . Config . Tags . Enabled ) if app . Persister ! = nil { app . Persister . Stop ( ) app . Persister = nil } if app . Tags ! = nil { app . Tags . Stop ( ) app . Tags = nil } app . start Persister ( ) if app . Collector ! = nil { app . Collector . Stop ( ) app . Collector = nil } app . Collector = New Collector ( app ) return nil } 
func ( app * App ) stop Listeners ( ) { logger : = zapwriter . Logger ( " " ) if app . Api ! = nil { app . Api . Stop ( ) app . Api = nil logger . Debug ( " " ) } if app . Carbon Link ! = nil { app . Carbon Link . Stop ( ) app . Carbon Link = nil logger . Debug ( " " ) } if app . Carbonserver ! = nil { carbonserver : = app . Carbonserver go func ( ) { carbonserver . Stop ( ) logger . Debug ( " " ) } ( ) app . Carbonserver = nil } if app . Receivers ! = nil { for i : = 0 ; i < len ( app . Receivers ) ; i + + { app . Receivers [ i ] . Stop ( ) logger . Debug ( " " , zap . String ( " " , app . Receivers [ i ] . Name ) ) } app . Receivers = nil } } 
func ( app * App ) Start ( ) ( err error ) { app . Lock ( ) defer app . Unlock ( ) defer func ( ) { if err ! = nil { app . stop All ( ) } } ( ) conf : = app . Config runtime . GOMAXPROCS ( conf . Common . Max CPU ) core : = cache . New ( ) core . Set Max Size ( conf . Cache . Max Size ) core . Set Write Strategy ( conf . Cache . Write Strategy ) core . Set Tags Enabled ( conf . Tags . Enabled ) app . Cache = core if conf . Grpc . Enabled { var grpc Addr * net . TCPAddr grpc Addr , err = net . Resolve TCPAddr ( " " , conf . Grpc . Listen ) if err ! = nil { return } grpc Api : = api . New ( core ) if err = grpc Api . Listen ( grpc Addr ) ; err ! = nil { return } app . Api = grpc Api } app . start Persister ( ) app . Receivers = make ( [ ] * Named Receiver , 0 ) var rcv receiver . Receiver var rcv Options map [ string ] interface { } if conf . Udp . Enabled { if rcv Options , err = receiver . With Protocol ( conf . Udp , " " ) ; err ! = nil { return } if rcv , err = receiver . New ( " " , rcv Options , core . Add ) ; err ! = nil { return } app . Receivers = append ( app . Receivers , & Named Receiver { Receiver : rcv , Name : " " , } ) } if conf . Tcp . Enabled { if rcv Options , err = receiver . With Protocol ( conf . Tcp , " " ) ; err ! = nil { return } if rcv , err = receiver . New ( " " , rcv Options , core . Add ) ; err ! = nil { return } app . Receivers = append ( app . Receivers , & Named Receiver { Receiver : rcv , Name : " " , } ) } if conf . Pickle . Enabled { if rcv Options , err = receiver . With Protocol ( conf . Pickle , " " ) ; err ! = nil { return } if rcv , err = receiver . New ( " " , rcv Options , core . Add ) ; err ! = nil { return } app . Receivers = append ( app . Receivers , & Named Receiver { Receiver : rcv , Name : " " , } ) } for receiver Name , receiver Options : = range conf . Receiver { if rcv , err = receiver . New ( receiver Name , receiver Options , core . Add ) ; err ! = nil { return } app . Receivers = append ( app . Receivers , & Named Receiver { Receiver : rcv , Name : receiver Name , } ) } if conf . Carbonserver . Enabled { if err ! = nil { return } carbonserver : = carbonserver . New Carbonserver Listener ( core . Get ) carbonserver . Set Whisper Data ( conf . Whisper . Data Dir ) carbonserver . Set Max Globs ( conf . Carbonserver . Max Globs ) carbonserver . Set FLock ( app . Config . Whisper . FLock ) carbonserver . Set Fail On Max Globs ( conf . Carbonserver . Fail On Max Globs ) carbonserver . Set Buckets ( conf . Carbonserver . Buckets ) carbonserver . Set Metrics As Counters ( conf . Carbonserver . Metrics As Counters ) carbonserver . Set Scan Frequency ( conf . Carbonserver . Scan Frequency . Value ( ) ) carbonserver . Set Read Timeout ( conf . Carbonserver . Read Timeout . Value ( ) ) carbonserver . Set Idle Timeout ( conf . Carbonserver . Idle Timeout . Value ( ) ) carbonserver . Set Write Timeout ( conf . Carbonserver . Write Timeout . Value ( ) ) carbonserver . Set Query Cache Enabled ( conf . Carbonserver . Query Cache Enabled ) carbonserver . Set Find Cache Enabled ( conf . Carbonserver . Find Cache Enabled ) carbonserver . Set Query Cache Size MB ( conf . Carbonserver . Query Cache Size MB ) carbonserver . Set Trigram Index ( conf . Carbonserver . Trigram Index ) carbonserver . Set Internal Stats Dir ( conf . Carbonserver . Internal Stats Dir ) carbonserver . Set Percentiles ( conf . Carbonserver . Percentiles ) } if err = carbonserver . Listen ( conf . Carbonserver . Listen ) ; err ! = nil { return } app . Carbonserver = carbonserver } if conf . Carbonlink . Enabled { var link Addr * net . TCPAddr link Addr , err = net . Resolve TCPAddr ( " " , conf . Carbonlink . Listen ) if err ! = nil { return } carbonlink : = cache . New Carbonlink Listener ( core ) carbonlink . Set Read Timeout ( conf . Carbonlink . Read Timeout . Value ( ) ) } app . Carbon Link = carbonlink } if conf . Dump . Enabled { go app . Restore ( core . Add , conf . Dump . Path , conf . Dump . Restore Per Second ) } app . Collector = New Collector ( app ) return } 
func ( app * App ) Loop ( ) { app . RLock ( ) exit Chan : = app . exit app . RUnlock ( ) if exit Chan ! = nil { < - app . exit } } 
func ( rcv * HTTP ) Addr ( ) net . Addr { if rcv . listener = = nil { return nil } return rcv . listener . Addr ( ) } 
func ( o * Offset ) Marshal Text ( ) ( [ ] byte , error ) { switch * o { case Offset Newest : return [ ] byte ( " " ) , nil case Offset Oldest : return [ ] byte ( " " ) , nil } return [ ] byte ( fmt . Sprintf ( " " , * o ) ) , nil } 
func ( o * Offset ) Unmarshal Text ( text [ ] byte ) error { offset Name : = string ( text ) switch strings . To Lower ( offset Name ) { case " " : * o = Offset Newest case " " : * o = Offset Oldest default : d , err : = time . Parse Duration ( offset Name ) if err ! = nil { return err } * o = Offset ( time . Now ( ) . Add ( d ) . Unix Nano ( ) ) } return nil } 
func ( p * Protocol ) Marshal Text ( ) ( [ ] byte , error ) { switch * p { case Protocol Plain : return [ ] byte ( " " ) , nil case Protocol Protobuf : return [ ] byte ( " " ) , nil case Protocol Pickle : return [ ] byte ( " " ) , nil } return nil , fmt . Errorf ( " " , p , supported Protocols ) } 
func ( p * Protocol ) Unmarshal Text ( text [ ] byte ) error { protocol Name : = string ( text ) switch strings . To Lower ( protocol Name ) { case " " : * p = Protocol Plain case " " : * p = Protocol Protobuf case " " : * p = Protocol Pickle default : return fmt . Errorf ( " " , protocol Name , supported Protocols ) } return nil } 
func ( d * Duration ) Unmarshal Text ( text [ ] byte ) error { var err error d . Duration , err = time . Parse Duration ( string ( text ) ) return err } 
func New Options ( ) * Options { return & Options { Brokers : [ ] string { " " } , Topic : " " , Partition : 0 , Protocol : Protocol Plain , Initial Offset : Offset Oldest , State Save Interval : & Duration { Duration : 6 0 * time . Second } , Reconnect Interval : & Duration { Duration : 6 0 * time . Second } , Fetch Interval : & Duration { Duration : 2 5 0 * time . Millisecond } , Kafka Version : " " , } } 
func ( rcv * Kafka ) Stat ( send helper . Stat Callback ) { metrics Received : = atomic . Load Uint 6 4 ( & rcv . metrics Received ) send ( " " , float 6 4 ( metrics Received ) ) errors : = atomic . Load Uint 6 4 ( & rcv . errors ) send ( " " , float 6 4 ( errors ) ) if ! rcv . stats As Counters { atomic . Add Uint 6 4 ( & rcv . metrics Received , - metrics Received ) atomic . Add Uint 6 4 ( & rcv . errors , - errors ) } } 
func ( rcv * TCP ) Addr ( ) net . Addr { if rcv . listener = = nil { return nil } return rcv . listener . Addr ( ) } 
func ( rcv * TCP ) Listen ( addr * net . TCPAddr ) error { return rcv . Start Func ( func ( ) error { tcp Listener , err : = net . Listen TCP ( " " , addr ) if err ! = nil { return err } rcv . Go ( func ( exit chan bool ) { < - exit tcp Listener . Close ( ) } ) handler : = rcv . Handle Connection if rcv . is Framing { handler = rcv . handle Framing } if rcv . buffer ! = nil { original Out : = rcv . out rcv . Go ( func ( exit chan bool ) { for { select { case < - exit : return case p : = < - rcv . buffer : original Out ( p ) } } } ) rcv . out = func ( p * points . Points ) { rcv . buffer < - p } } rcv . Go ( func ( exit chan bool ) { defer tcp Listener . Close ( ) for { conn , err : = tcp Listener . Accept ( ) if err ! = nil { if strings . Contains ( err . Error ( ) , " " ) { break } rcv . logger . Warn ( " " , zap . Error ( err ) , ) continue } rcv . Go ( func ( exit chan bool ) { handler ( conn ) } ) } } ) rcv . listener = tcp Listener return nil } ) } 
func With Protocol ( options interface { } , protocol string ) ( map [ string ] interface { } , error ) { buf : = new ( bytes . Buffer ) encoder : = toml . New Encoder ( buf ) encoder . Indent = " " if err : = encoder . Encode ( options ) ; err ! = nil { return nil , err } res : = make ( map [ string ] interface { } ) if _ , err : = toml . Decode ( buf . String ( ) , & res ) ; err ! = nil { return nil , err } res [ " " ] = protocol return res , nil } 
func New ( ) * Cache { c : = & Cache { data : make ( [ ] * Shard , shard Count ) , write Strategy : Noop , } for i : = 0 ; i < shard Count ; i + + { c . data [ i ] = & Shard { items : make ( map [ string ] * points . Points ) , not Confirmed : make ( [ ] * points . Points , 4 ) , } } settings : = cache Settings { max Size : 1 0 0 0 0 0 0 , tags Enabled : false , xlog : nil , } c . settings . Store ( & settings ) c . writeout Queue = New Writeout Queue ( c ) return c } 
func ( c * Cache ) Set Write Strategy ( s string ) ( err error ) { c . Lock ( ) defer c . Unlock ( ) switch s { case " " : c . write Strategy = Maximum Length case " " : c . write Strategy = Timestamp Order case " " : c . write Strategy = Noop default : return fmt . Errorf ( " " , s ) } return nil } 
func ( c * Cache ) Set Max Size ( max Size uint 3 2 ) { s : = c . settings . Load ( ) . ( * cache Settings ) new Settings : = * s new Settings . max Size = int 3 2 ( max Size ) c . settings . Store ( & new Settings ) } 
func ( c * Cache ) Stat ( send helper . Stat Callback ) { s : = c . settings . Load ( ) . ( * cache Settings ) send ( " " , float 6 4 ( c . Size ( ) ) ) send ( " " , float 6 4 ( c . Len ( ) ) ) send ( " " , float 6 4 ( s . max Size ) ) helper . Send And Substract Uint 3 2 ( " " , & c . stat . query Cnt , send ) helper . Send And Substract Uint 3 2 ( " " , & c . stat . tags Normalize Errors , send ) helper . Send And Substract Uint 3 2 ( " " , & c . stat . overflow Cnt , send ) helper . Send And Substract Uint 3 2 ( " " , & c . stat . queue Build Cnt , send ) helper . Send And Substract Uint 3 2 ( " " , & c . stat . queue Build Time Ms , send ) helper . Send Uint 3 2 ( " " , & c . stat . queue Writeout Time , send ) } 
func fnv 3 2 ( key string ) uint 3 2 { hash : = uint 3 2 ( 2 1 6 6 1 3 6 2 6 1 ) const prime 3 2 = uint 3 2 ( 1 6 7 7 7 6 1 9 ) for i : = 0 ; i < len ( key ) ; i + + { hash * = prime 3 2 hash ^ = uint 3 2 ( key [ i ] ) } return hash } 
func ( c * Cache ) Get Shard ( key string ) * Shard { } 
func ( c * Cache ) Add ( p * points . Points ) { s : = c . settings . Load ( ) . ( * cache Settings ) if s . xlog ! = nil { p . Write To ( s . xlog ) return } if s . tags Enabled { var err error p . Metric , err = tags . Normalize ( p . Metric ) if err ! = nil { atomic . Add Uint 3 2 ( & c . stat . tags Normalize Errors , 1 ) return } } if s . max Size > 0 & & c . Size ( ) > s . max Size { atomic . Add Uint 3 2 ( & c . stat . overflow Cnt , uint 3 2 ( count ) ) return } shard : = c . Get Shard ( p . Metric ) shard . Lock ( ) if values , exists : = shard . items [ p . Metric ] ; exists { values . Data = append ( values . Data , p . Data . . . ) } else { shard . items [ p . Metric ] = p } shard . Unlock ( ) atomic . Add Int 3 2 ( & c . stat . size , int 3 2 ( count ) ) } 
func ( c * Cache ) Pop ( key string ) ( p * points . Points , exists bool ) { shard . Lock ( ) p , exists = shard . items [ key ] delete ( shard . items , key ) shard . Unlock ( ) if exists { atomic . Add Int 3 2 ( & c . stat . size , - int 3 2 ( len ( p . Data ) ) ) } return p , exists } 
func ( s * Stoppable ) Stop Func ( callable func ( ) ) { s . Lock ( ) defer s . Unlock ( ) } s . do Stop ( callable ) } 
func Parse Carbonlink Request ( d [ ] byte ) ( * Carbonlink Request , error ) { if ! ( expect Bytes ( & d , [ ] byte ( " \x 8 0 \x 0 2 " ) ) & & pickle Maybe Memo ( & d ) & & expect Bytes ( & d , [ ] byte ( " " ) ) ) { return nil , bad Err } req : = New Carbonlink Request ( ) var Metric , Type string var ok bool if expect Bytes ( & d , [ ] byte ( " \x 0 6 " ) ) { if ! pickle Maybe Memo ( & d ) { return nil , bad Err } if Metric , ok = pickle Get Str ( & d ) ; ! ok { return nil , bad Err } if ! ( pickle Maybe Memo ( & d ) & & expect Bytes ( & d , [ ] byte ( " \x 0 4 " ) ) & & pickle Maybe Memo ( & d ) ) { return nil , bad Err } if Type , ok = pickle Get Str ( & d ) ; ! ok { return nil , bad Err } if ! pickle Maybe Memo ( & d ) { return nil , bad Err } req . Metric = Metric req . Type = Type } else if expect Bytes ( & d , [ ] byte ( " \x 0 4 " ) ) { if ! pickle Maybe Memo ( & d ) { return nil , bad Err } if Type , ok = pickle Get Str ( & d ) ; ! ok { return nil , bad Err } if ! ( pickle Maybe Memo ( & d ) & & expect Bytes ( & d , [ ] byte ( " \x 0 6 " ) ) & & pickle Maybe Memo ( & d ) ) { return nil , bad Err } if Metric , ok = pickle Get Str ( & d ) ; ! ok { return nil , bad Err } if ! pickle Maybe Memo ( & d ) { return nil , bad Err } req . Metric = Metric req . Type = Type } else { return nil , bad Err } return req , nil } 
func New Carbonlink Listener ( cache * Cache ) * Carbonlink Listener { return & Carbonlink Listener { cache : cache , read Timeout : 3 0 * time . Second , } } 
func ( listener * Carbonlink Listener ) Addr ( ) net . Addr { if listener . tcp Listener = = nil { return nil } return listener . tcp Listener . Addr ( ) } 
func ( listener * Carbonlink Listener ) Listen ( addr * net . TCPAddr ) error { return listener . Start Func ( func ( ) error { tcp Listener , err : = net . Listen TCP ( " " , addr ) if err ! = nil { return err } listener . tcp Listener = tcp Listener listener . Go ( func ( exit chan bool ) { select { case < - exit : tcp Listener . Close ( ) } } ) listener . Go ( func ( exit chan bool ) { defer tcp Listener . Close ( ) for { conn , err : = tcp Listener . Accept ( ) if err ! = nil { if strings . Contains ( err . Error ( ) , " " ) { break } zapwriter . Logger ( " " ) . Error ( " " , zap . Error ( err ) ) continue } framed Conn , _ : = framing . New Conn ( conn , byte ( 4 ) , binary . Big Endian ) framed Conn . Max Frame Size = 1 0 4 8 5 7 6 go listener . Handle Connection ( * framed Conn ) } } ) return nil } ) } 
func One Point ( metric string , value float 6 4 , timestamp int 6 4 ) * Points { return & Points { Metric : metric , Data : [ ] Point { Point { Value : value , Timestamp : timestamp , } , } , } } 
func Now Point ( metric string , value float 6 4 ) * Points { return One Point ( metric , value , time . Now ( ) . Unix ( ) ) } 
func ( p * Points ) Copy ( ) * Points { return & Points { Metric : p . Metric , Data : p . Data , } } 
func Parse Text ( line string ) ( * Points , error ) { row : = strings . Split ( strings . Trim ( line , " \n \t \r " ) , " " ) if len ( row ) ! = 3 { return nil , fmt . Errorf ( " " , line ) } if err ! = nil | | math . Is Na N ( value ) { return nil , fmt . Errorf ( " " , line ) } tsf , err : = strconv . Parse Float ( row [ 2 ] , 6 4 ) if err ! = nil | | math . Is Na N ( tsf ) { return nil , fmt . Errorf ( " " , line ) } } 
func ( p * Points ) Append ( one Point Point ) * Points { p . Data = append ( p . Data , one Point ) return p } 
func ( p * Points ) Add ( value float 6 4 , timestamp int 6 4 ) * Points { p . Data = append ( p . Data , Point { Value : value , Timestamp : timestamp , } ) return p } 
func ( p * Points ) Eq ( other * Points ) bool { if other = = nil { return false } if p . Metric ! = other . Metric { return false } if p . Data = = nil & & other . Data = = nil { return true } if ( p . Data = = nil | | other . Data = = nil ) & & ( p . Data ! = nil | | other . Data ! = nil ) { return false } if len ( p . Data ) ! = len ( other . Data ) { return false } for i : = 0 ; i < len ( p . Data ) ; i + + { if p . Data [ i ] . Value ! = other . Data [ i ] . Value { return false } if p . Data [ i ] . Timestamp ! = other . Data [ i ] . Timestamp { return false } } return true } 
func New Config ( ) * Config { cfg : = & Config { Common : common Config { Graph Prefix : " " , Metric Interval : & Duration { Duration : time . Minute , } , Metric Endpoint : Metric Endpoint Local , Max CPU : 1 , User : " " , } , Whisper : whisper Config { Data Dir : " " , Schemas Filename : " " , Aggregation Filename : " " , Max Updates Per Second : 0 , Enabled : true , Workers : 1 , Sparse : false , FLock : false , Hash Filenames : true , } , Cache : cache Config { Max Size : 1 0 0 0 0 0 0 , Write Strategy : " " , } , Udp : udp . New Options ( ) , Tcp : tcp . New Options ( ) , Pickle : tcp . New Framing Options ( ) , Carbonserver : carbonserver Config { Listen : " " , Enabled : false , Buckets : 1 0 , Max Globs : 1 0 0 , Fail On Max Globs : false , Metrics As Counters : false , Scan Frequency : & Duration { Duration : 3 0 0 * time . Second , } , Read Timeout : & Duration { Duration : 6 0 * time . Second , } , Idle Timeout : & Duration { Duration : 6 0 * time . Second , } , Write Timeout : & Duration { Duration : 6 0 * time . Second , } , Query Cache Enabled : true , Query Cache Size MB : 0 , Find Cache Enabled : true , Trigram Index : true , } , Carbonlink : carbonlink Config { Listen : " " , Enabled : true , Read Timeout : & Duration { Duration : 3 0 * time . Second , } , } , Grpc : grpc Config { Listen : " " , Enabled : true , } , Tags : tags Config { Enabled : false , Tag DB : " " , Tag DBTimeout : & Duration { Duration : time . Second , } , Tag DBChunk Size : 3 2 , Tag DBUpdate Interval : 1 0 0 , Local Dir : " " , } , Pprof : pprof Config { Listen : " " , Enabled : false , } , Dump : dump Config { Path : " " , } , Prometheus : prometheus Config { Enabled : false , Endpoint : " " , Labels : make ( map [ string ] string ) , } , Logging : nil , } return cfg } 
func Print Default Config ( ) error { cfg : = New Config ( ) buf : = new ( bytes . Buffer ) if cfg . Logging = = nil { cfg . Logging = make ( [ ] zapwriter . Config , 0 ) } if len ( cfg . Logging ) = = 0 { cfg . Logging = append ( cfg . Logging , New Logging Config ( ) ) } encoder : = toml . New Encoder ( buf ) encoder . Indent = " " if err : = encoder . Encode ( cfg ) ; err ! = nil { return err } fmt . Print ( buf . String ( ) ) return nil } 
func Read Config ( filename string ) ( * Config , error ) { cfg : = New Config ( ) if filename ! = " " { b , err : = ioutil . Read File ( filename ) if err ! = nil { return nil , err } body : = string ( b ) if _ , err : = toml . Decode ( body , cfg ) ; err ! = nil { return nil , err } } if cfg . Logging = = nil { cfg . Logging = make ( [ ] zapwriter . Config , 0 ) } if cfg . Common . Log Level ! = nil | | cfg . Common . Logfile ! = nil { log . Println ( " " ) l : = New Logging Config ( ) if cfg . Common . Logfile ! = nil { l . File = * cfg . Common . Logfile } if cfg . Common . Log Level ! = nil { l . Level = * cfg . Common . Log Level } cfg . Logging = [ ] zapwriter . Config { l } } if len ( cfg . Logging ) = = 0 { cfg . Logging = append ( cfg . Logging , New Logging Config ( ) ) } if err : = zapwriter . Check Config ( cfg . Logging , nil ) ; err ! = nil { return nil , err } return cfg , nil } 
func ( s Whisper Schemas ) Match ( metric string ) ( Schema , bool ) { for _ , schema : = range s { if schema . Pattern . Match String ( metric ) { return schema , true } } return Schema { } , false } 
func Parse Retention Defs ( retention Defs string ) ( whisper . Retentions , error ) { retentions : = make ( whisper . Retentions , 0 ) for _ , retention Def : = range strings . Split ( retention Defs , " " ) { retention Def = strings . Trim Space ( retention Def ) parts : = strings . Split ( retention Def , " " ) if len ( parts ) ! = 2 { return nil , fmt . Errorf ( " " , retention Def ) } val 2 , err 2 : = strconv . Parse Int ( parts [ 1 ] , 1 0 , 0 ) if err 1 = = nil & & err 2 = = nil { retention : = whisper . New Retention ( int ( val 1 ) , int ( val 2 ) ) retentions = append ( retentions , & retention ) continue } if err ! = nil { return nil , err } retentions = append ( retentions , retention ) } return retentions , nil } 
func Read Whisper Schemas ( filename string ) ( Whisper Schemas , error ) { config , err : = parse Ini File ( filename ) if err ! = nil { return nil , err } var schemas Whisper Schemas for i , section : = range config { schema : = Schema { } schema . Name = section [ " " ] if section [ " " ] = = " " { return nil , fmt . Errorf ( " " , schema . Name ) } schema . Pattern , err = regexp . Compile ( section [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , section [ " " ] , schema . Name , err . Error ( ) ) } schema . Retention Str = section [ " " ] schema . Retentions , err = Parse Retention Defs ( schema . Retention Str ) if err ! = nil { return nil , fmt . Errorf ( " " , schema . Retention Str , schema . Name , err . Error ( ) ) } p : = int 6 4 ( 0 ) if section [ " " ] ! = " " { p , err = strconv . Parse Int ( section [ " " ] , 1 0 , 0 ) if err ! = nil { return nil , fmt . Errorf ( " " , section [ " " ] , schema . Name , err ) } } schema . Priority = int 6 4 ( p ) < < 3 2 - int 6 4 ( i ) schemas = append ( schemas , schema ) } sort . Sort ( schemas ) return schemas , nil } 
func ( app * App ) Dump Stop ( ) error { app . Lock ( ) defer app . Unlock ( ) if ! app . Config . Dump . Enabled { return nil } if app . Persister ! = nil { app . Persister . Stop ( ) app . Persister = nil } logger : = zapwriter . Logger ( " " ) logger . Info ( " " ) filename Postfix : = fmt . Sprintf ( " " , os . Getpid ( ) , time . Now ( ) . Unix Nano ( ) ) dump Filename : = path . Join ( app . Config . Dump . Path , fmt . Sprintf ( " " , filename Postfix ) ) xlog Filename : = path . Join ( app . Config . Dump . Path , fmt . Sprintf ( " " , filename Postfix ) ) logger . Info ( " " , zap . String ( " " , xlog Filename ) ) if err ! = nil { return err } dump Writer : = bufio . New Writer Size ( dump , 1 0 4 8 5 7 6 ) if err ! = nil { return err } xlog Writer : = & Sync Writer { w : bufio . New Writer Size ( xlog , 4 0 9 6 ) } app . Cache . Divert To Xlog ( xlog Writer ) cache Size : = app . Cache . Size ( ) if err ! = nil { logger . Info ( " " , zap . Error ( err ) ) return err } logger . Info ( " " , zap . Int ( " " , int ( cache Size ) ) , zap . Duration ( " " , time . Since ( dump Start ) ) , ) if err = dump Writer . Flush ( ) ; err ! = nil { logger . Info ( " " , zap . Error ( err ) ) return err } if err = dump . Close ( ) ; err ! = nil { logger . Info ( " " , zap . Error ( err ) ) return err } logger . Info ( " " ) stopped : = make ( chan struct { } ) go func ( ) { app . stop Listeners ( ) if err : = xlog Writer . Flush ( ) ; err ! = nil { logger . Info ( " " , zap . Error ( err ) ) return } if err : = xlog . Close ( ) ; err ! = nil { logger . Info ( " " , zap . Error ( err ) ) return } close ( stopped ) } ( ) select { case < - time . After ( 5 * time . Second ) : logger . Info ( " " ) case < - stopped : logger . Info ( " " ) } } 
func ( app * App ) Restore From File ( filename string , store Func func ( * points . Points ) ) error { var points Count int start Time : = time . Now ( ) logger : = zapwriter . Logger ( " " ) . With ( zap . String ( " " , filename ) ) logger . Info ( " " ) defer func ( ) { logger . Info ( " " , zap . Int ( " " , points Count ) , zap . Duration ( " " , time . Since ( start Time ) ) , ) } ( ) err : = points . Read From File ( filename , func ( p * points . Points ) { points Count + = len ( p . Data ) store Func ( p ) } ) return err } 
func ( app * App ) Restore From Dir ( dump Dir string , store Func func ( * points . Points ) ) { start Time : = time . Now ( ) logger : = zapwriter . Logger ( " " ) . With ( zap . String ( " " , dump Dir ) ) defer func ( ) { logger . Info ( " " , zap . Duration ( " " , time . Since ( start Time ) ) , ) } ( ) files , err : = ioutil . Read Dir ( dump Dir ) if err ! = nil { logger . Error ( " " , zap . Error ( err ) ) return } Files Loop : for _ , file : = range files { if file . Is Dir ( ) { continue } r : = strings . Split ( file . Name ( ) , " " ) if len ( r ) < 3 { } var file With Sort Prefix string switch r [ 0 ] { case " " : file With Sort Prefix = fmt . Sprintf ( " " , r [ 2 ] , " " , file . Name ( ) ) case " " : file With Sort Prefix = fmt . Sprintf ( " " , r [ 2 ] , " " , file . Name ( ) ) default : continue Files Loop } list = append ( list , file With Sort Prefix ) } if len ( list ) = = 0 { logger . Info ( " " ) return } sort . Strings ( list ) for index , file With Sort Prefix : = range list { list [ index ] = strings . Split N ( file With Sort Prefix , " " , 2 ) [ 1 ] } logger . Info ( " " , zap . Int ( " " , len ( list ) ) ) for _ , fn : = range list { filename : = path . Join ( dump Dir , fn ) app . Restore From File ( filename , store Func ) err = os . Remove ( filename ) if err ! = nil { logger . Error ( " " , zap . String ( " " , filename ) , zap . Error ( err ) ) } } } 
func ( app * App ) Restore ( store Func func ( * points . Points ) , path string , rps int ) { if rps > 0 { ticker : = persister . New Throttle Ticker ( rps ) defer ticker . Stop ( ) throttled Store Func : = func ( p * points . Points ) { for i : = 0 ; i < len ( p . Data ) ; i + + { < - ticker . C } store Func ( p ) } app . Restore From Dir ( path , throttled Store Func ) } else { app . Restore From Dir ( path , store Func ) } } 
func Get Stat ( i os . File Info ) File Stats { res : = File Stats { Size : i . Size ( ) , MTime : i . Mod Time ( ) . Unix ( ) , CTime : i . Mod Time ( ) . Unix ( ) , } s : = i . Sys ( ) . ( * syscall . Stat _t ) if s ! = nil { res . Real Size = s . Blocks * 5 1 2 } return res } 
func Root ( t * testing . T , callback func ( dir string ) ) { tmp Dir , err : = ioutil . Temp Dir ( " " , " " ) if err ! = nil { t . Fatal ( err ) } defer func ( ) { if err : = os . Remove All ( tmp Dir ) ; err ! = nil { t . Fatal ( err ) } } ( ) callback ( tmp Dir ) } 
func ( rcv * UDP ) Addr ( ) net . Addr { if rcv . conn = = nil { return nil } return rcv . conn . Local Addr ( ) } 
func ( rcv * UDP ) Listen ( addr * net . UDPAddr ) error { return rcv . Start Func ( func ( ) error { var err error rcv . conn , err = net . Listen UDP ( " " , addr ) if err ! = nil { return err } rcv . Go ( func ( exit chan bool ) { < - exit rcv . conn . Close ( ) } ) if rcv . buffer ! = nil { original Out : = rcv . out rcv . Go ( func ( exit chan bool ) { for { select { case < - exit : return case p : = < - rcv . buffer : original Out ( p ) } } } ) rcv . out = func ( p * points . Points ) { rcv . buffer < - p } } rcv . Go ( rcv . receive Worker ) return nil } ) } 
func ( q * Queue ) delete ( key [ ] byte ) { err : = q . db . Delete ( [ ] byte ( key ) , nil ) atomic . Add Uint 3 2 ( & q . stat . delete Count , 1 ) if err ! = nil { atomic . Add Uint 3 2 ( & q . stat . delete Errors , 1 ) q . logger . Error ( " " , zap . Error ( err ) ) } } 
func New Whisper ( root Path string , schemas Whisper Schemas , aggregation * Whisper Aggregation , recv func ( chan bool ) string , pop func ( string ) ( * points . Points , bool ) , confirm func ( * points . Points ) ) * Whisper { return & Whisper { recv : recv , pop : pop , confirm : confirm , schemas : schemas , aggregation : aggregation , workers Count : 1 , root Path : root Path , max Updates Per Second : 0 , logger : zapwriter . Logger ( " " ) , create Logger : zapwriter . Logger ( " " ) , } } 
func ( p * Whisper ) Set Workers ( count int ) { if count > = 1 { p . workers Count = count } else { p . workers Count = 1 } } 
func ( p * Whisper ) Stat ( send helper . Stat Callback ) { update Operations : = atomic . Load Uint 3 2 ( & p . update Operations ) committed Points : = atomic . Load Uint 3 2 ( & p . committed Points ) atomic . Add Uint 3 2 ( & p . update Operations , - update Operations ) atomic . Add Uint 3 2 ( & p . committed Points , - committed Points ) created : = atomic . Load Uint 3 2 ( & p . created ) atomic . Add Uint 3 2 ( & p . created , - created ) throttled Creates : = atomic . Load Uint 3 2 ( & p . throttled Creates ) atomic . Add Uint 3 2 ( & p . throttled Creates , - throttled Creates ) send ( " " , float 6 4 ( update Operations ) ) send ( " " , float 6 4 ( committed Points ) ) if update Operations > 0 { send ( " " , float 6 4 ( committed Points ) / float 6 4 ( update Operations ) ) } else { send ( " " , 0 . 0 ) } send ( " " , float 6 4 ( created ) ) send ( " " , float 6 4 ( throttled Creates ) ) send ( " " , float 6 4 ( p . max Creates Per Second ) ) send ( " " , float 6 4 ( p . max Updates Per Second ) ) send ( " " , float 6 4 ( p . workers Count ) ) / / helper .Send And Substract Uint 6 4 ( "block Throttle Ns " , &p .block Throttle Ns , send ) / / helper .Send And Substract Uint 6 4 ( "block Queue Get Ns " , &p .block Queue Get Ns , send ) / / helper .Send And Substract Uint 6 4 ( "block Avoid Concurrent Ns " , &p .block Avoid Concurrent Ns , send ) / / helper .Send And Substract Uint 6 4 ( "block Update Many Ns " , &p .block Update Many Ns , send ) } 
func ( p * Whisper ) Start ( ) error { return p . Start Func ( func ( ) error { p . throttle Ticker = New Throttle Ticker ( p . max Updates Per Second ) if p . hard Max Creates Per Second { p . max Creates Ticker = New Hard Throttle Ticker ( p . max Creates Per Second ) } else { p . max Creates Ticker = New Throttle Ticker ( p . max Creates Per Second ) } for i : = 0 ; i < p . workers Count ; i + + { p . Go ( p . worker ) } return nil } ) } 
func New Whisper Aggregation ( ) * Whisper Aggregation { return & Whisper Aggregation { Data : make ( [ ] * whisper Aggregation Item , 0 ) , Default : & whisper Aggregation Item { name : " " , pattern : nil , x Files Factor : 0 . 5 , aggregation Method Str : " " , aggregation Method : whisper . Average , } , } } 
func Read Whisper Aggregation ( filename string ) ( * Whisper Aggregation , error ) { config , err : = parse Ini File ( filename ) if err ! = nil { return nil , err } result : = New Whisper Aggregation ( ) for _ , section : = range config { item : = & whisper Aggregation Item { } item . pattern , err = regexp . Compile ( section [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , section [ " " ] , item . name , err . Error ( ) ) } item . x Files Factor , err = strconv . Parse Float ( section [ " " ] , 6 4 ) if err ! = nil { return nil , fmt . Errorf ( " " , section [ " " ] , item . name , err . Error ( ) ) } item . aggregation Method Str = section [ " " ] switch item . aggregation Method Str { case " " , " " : item . aggregation Method = whisper . Average case " " : item . aggregation Method = whisper . Sum case " " : item . aggregation Method = whisper . Last case " " : item . aggregation Method = whisper . Max case " " : item . aggregation Method = whisper . Min default : return nil , fmt . Errorf ( " " , section [ " " ] ) } result . Data = append ( result . Data , item ) } return result , nil } 
func ( a * Whisper Aggregation ) match ( metric string ) * whisper Aggregation Item { for _ , s : = range a . Data { if s . pattern . Match String ( metric ) { return s } } return a . Default } 
func old Plain ( body [ ] byte ) ( [ ] * points . Points , error ) { result : = make ( [ ] * points . Points , 4 ) reader : = bytes . New Buffer ( body ) for { line , err : = reader . Read Bytes ( ' \n ' ) if err ! = nil & & err ! = io . EOF { return result , err } if len ( line ) = = 0 { break } if line [ len ( line ) - 1 ] ! = ' \n ' { return result , errors . New ( " " ) } p , err : = points . Parse Text ( string ( line ) ) if err ! = nil { return result , err } result = append ( result , p ) } return result , nil } 
func ( t * Tags ) Stat ( send helper . Stat Callback ) { helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . put Errors , send ) helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . put Count , send ) helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . delete Errors , send ) helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . delete Count , send ) helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . send Fail , send ) helper . Send And Substract Uint 3 2 ( " " , & t . q . stat . send Success , send ) send ( " " , t . q . Lag ( ) . Seconds ( ) ) } 
func normalize Original ( s string ) ( string , error ) { arr : = strings . Split ( s , " " ) if len ( arr [ 0 ] ) = = 0 { return " " , fmt . Errorf ( " " , s ) } tags : = make ( map [ string ] string ) for i : = 1 ; i < len ( arr ) ; i + + { kv : = strings . Split N ( arr [ i ] , " " , 2 ) if len ( kv ) ! = 2 | | len ( kv [ 0 ] ) = = 0 { return " " , fmt . Errorf ( " " , s , arr [ i ] ) } tags [ kv [ 0 ] ] = kv [ 1 ] } tmp : = make ( [ ] string , len ( tags ) ) i : = 0 for k , v : = range tags { tmp [ i ] = fmt . Sprintf ( " " , k , v ) i + + } sort . Strings ( tmp ) result : = arr [ 0 ] + strings . Join ( tmp , " " ) return result , nil } 
func ( client * Client ) Create Integration PD ( pd Integration * Integration PDRequest ) error { return client . do Json Request ( " " , " " , pd Integration , nil ) } 
func ( client * Client ) Update Integration PD ( pd Integration * Integration PDRequest ) error { return client . do Json Request ( " " , " " , pd Integration , nil ) } 
func ( client * Client ) Get Integration PD ( ) ( * integration PD , error ) { var out integration PD if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Create Integration Slack ( slack Integration * Integration Slack Request ) error { return client . do Json Request ( " " , " " , slack Integration , nil ) } 
func ( client * Client ) Update Integration Slack ( slack Integration * Integration Slack Request ) error { return client . do Json Request ( " " , " " , slack Integration , nil ) } 
func ( client * Client ) Get Integration Slack ( ) ( * Integration Slack Request , error ) { var out Integration Slack Request if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Create Integration AWS ( aws Account * Integration AWSAccount ) ( * Integration AWSAccount Create Response , error ) { var out Integration AWSAccount Create Response if err : = client . do Json Request ( " " , " " , aws Account , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Get Integration AWS ( ) ( * [ ] Integration AWSAccount , error ) { var response Integration AWSAccount Get Response if err : = client . do Json Request ( " " , " " , nil , & response ) ; err ! = nil { return nil , err } return & response . Accounts , nil } 
func ( client * Client ) Delete Integration AWS ( aws Account * Integration AWSAccount Delete Request ) error { return client . do Json Request ( " " , " " , aws Account , nil ) } 
func ( client * Client ) List Integration GCP ( ) ( [ ] * Integration GCP , error ) { var list [ ] * Integration GCP if err : = client . do Json Request ( " " , " " , nil , & list ) ; err ! = nil { return nil , err } return list , nil } 
func ( client * Client ) Create Integration GCP ( cir * Integration GCPCreate Request ) error { return client . do Json Request ( " " , " " , cir , nil ) } 
func ( client * Client ) Update Integration GCP ( cir * Integration GCPUpdate Request ) error { return client . do Json Request ( " " , " " , cir , nil ) } 
func ( client * Client ) Delete Integration GCP ( cir * Integration GCPDelete Request ) error { return client . do Json Request ( " " , " " , cir , nil ) } 
func ( client * Client ) Get Dashboard List ( id int ) ( * Dashboard List , error ) { var out Dashboard List if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Get Dashboard Lists ( ) ( [ ] Dashboard List , error ) { var out req Get Dashboard Lists if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return out . Dashboard Lists , nil } 
func ( client * Client ) Create Dashboard List ( list * Dashboard List ) ( * Dashboard List , error ) { var out Dashboard List if err : = client . do Json Request ( " " , " " , list , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Update Dashboard List ( list * Dashboard List ) error { req : = req Update Dashboard List { list . Get Name ( ) } return client . do Json Request ( " " , fmt . Sprintf ( " " , * list . Id ) , req , nil ) } 
func ( client * Client ) Get Dashboard List Items ( id int ) ( [ ] Dashboard List Item , error ) { var out req Dashboard List Items if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err ! = nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) Add Dashboard List Items ( dashboard List Id int , items [ ] Dashboard List Item ) ( [ ] Dashboard List Item , error ) { req : = req Dashboard List Items { items } var out req Added Dashboard List Items if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , dashboard List Id ) , req , & out ) ; err ! = nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) Snapshot ( query string , start , end time . Time , event Query string ) ( string , error ) { options : = map [ string ] string { " " : query , " " : event Query } return client . Snapshot Generic ( options , start , end ) } 
func ( client * Client ) Snapshot Generic ( options map [ string ] string , start , end time . Time ) ( string , error ) { v : = url . Values { } v . Add ( " " , fmt . Sprintf ( " " , start . Unix ( ) ) ) v . Add ( " " , fmt . Sprintf ( " " , end . Unix ( ) ) ) for opt , val : = range options { v . Add ( opt , val ) } return client . do Snapshot Request ( v ) } 
func ( p * Precision T ) Unmarshal JSON ( data [ ] byte ) error { var err error var precision Num json . Number if err = json . Unmarshal ( data , & precision Num ) ; err = = nil { * p = Precision T ( precision Num ) return nil } var precision Str string if err = json . Unmarshal ( data , & precision Str ) ; err = = nil { * p = Precision T ( precision Str ) return nil } var p 0 Precision T * p = p 0 return err } 
func ( client * Client ) Search Hosts ( search string ) ( [ ] string , error ) { var out req Search if err : = client . do Json Request ( " " , " " + search , nil , & out ) ; err ! = nil { return nil , err } return out . Results . Hosts , nil } 
func ( client * Client ) Search Metrics ( search string ) ( [ ] string , error ) { var out req Search if err : = client . do Json Request ( " " , " " + search , nil , & out ) ; err ! = nil { return nil , err } return out . Results . Metrics , nil } 
func ( client * Client ) Create Alert ( alert * Alert ) ( * Alert , error ) { var out Alert if err : = client . do Json Request ( " " , " " , alert , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Update Alert ( alert * Alert ) error { return client . do Json Request ( " " , fmt . Sprintf ( " " , alert . Id ) , alert , nil ) } 
func ( client * Client ) Get Alert ( id int ) ( * Alert , error ) { var out Alert if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Get Alerts ( ) ( [ ] Alert , error ) { var out req Alerts if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return out . Alerts , nil } 
func ( client * Client ) Create Comment ( handle , message string ) ( * Comment , error ) { var out req Comment comment : = Comment { Message : String ( message ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } if err : = client . do Json Request ( " " , " " , & comment , & out ) ; err ! = nil { return nil , err } return out . Comment , nil } 
func ( client * Client ) Create Related Comment ( handle , message string , relid int ) ( * Comment , error ) { var out req Comment comment : = Comment { Message : String ( message ) , Related Id : Int ( relid ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } if err : = client . do Json Request ( " " , " " , & comment , & out ) ; err ! = nil { return nil , err } return out . Comment , nil } 
func ( client * Client ) Edit Comment ( id int , handle , message string ) error { comment : = Comment { Message : String ( message ) } if len ( handle ) > 0 { comment . Handle = String ( handle ) } return client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , & comment , nil ) } 
func ( client * Client ) Create Monitor ( monitor * Monitor ) ( * Monitor , error ) { var out Monitor } return & out , nil } 
func ( client * Client ) Update Monitor ( monitor * Monitor ) error { return client . do Json Request ( " " , fmt . Sprintf ( " " , * monitor . Id ) , monitor , nil ) } 
func ( client * Client ) Get Monitor ( id int ) ( * Monitor , error ) { var out Monitor if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( self * Client ) Get Monitors By Name ( name string ) ( [ ] Monitor , error ) { var out req Monitors query , err : = url . Parse Query ( fmt . Sprintf ( " " , name ) ) if err ! = nil { return nil , err } err = self . do Json Request ( " " , fmt . Sprintf ( " " , query . Encode ( ) ) , nil , & out . Monitors ) if err ! = nil { return nil , err } return out . Monitors , nil } 
func ( self * Client ) Get Monitors By Tags ( tags [ ] string ) ( [ ] Monitor , error ) { var out req Monitors query , err : = url . Parse Query ( fmt . Sprintf ( " " , strings . Join ( tags , " " ) ) ) if err ! = nil { return nil , err } err = self . do Json Request ( " " , fmt . Sprintf ( " " , query . Encode ( ) ) , nil , & out . Monitors ) if err ! = nil { return nil , err } return out . Monitors , nil } 
func ( client * Client ) Get Monitors ( ) ( [ ] Monitor , error ) { var out req Monitors if err : = client . do Json Request ( " " , " " , nil , & out . Monitors ) ; err ! = nil { return nil , err } return out . Monitors , nil } 
func ( client * Client ) Get Synthetics Locations ( ) ( [ ] Synthetics Location , error ) { var out struct { Locations [ ] Synthetics Location `json : "locations ,omitempty " ` } if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return out . Locations , nil } 
func ( client * Client ) Get Synthetics Browser Devices ( ) ( [ ] Synthetics Device , error ) { var out struct { Devices [ ] Synthetics Device `json : "devices ,omitempty " ` } if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return out . Devices , nil } 
func Get Bool ( v * bool ) ( bool , bool ) { if v ! = nil { return * v , true } return false , false } 
func Get Int Ok ( v * int ) ( int , bool ) { if v ! = nil { return * v , true } return 0 , false } 
func Get String Ok ( v * string ) ( string , bool ) { if v ! = nil { return * v , true } return " " , false } 
func Get Json Number Ok ( v * json . Number ) ( json . Number , bool ) { if v ! = nil { return * v , true } return " " , false } 
func Get Precision ( v * Precision T ) ( Precision T , bool ) { if v ! = nil { return * v , true } return Precision T ( " " ) , false } 
func Get String Id ( id interface { } ) ( string , error ) { switch v : = id . ( type ) { case int : return strconv . Itoa ( v ) , nil case string : return v , nil default : return " " , errors . New ( " " ) } } 
func ( y * Yaxis ) Unmarshal JSON ( data [ ] byte ) error { type Alias Yaxis wrapper : = & struct { Min * json . Number `json : "min ,omitempty " ` Max * json . Number `json : "max ,omitempty " ` * Alias } { Alias : ( * Alias ) ( y ) , } if err : = json . Unmarshal ( data , & wrapper ) ; err ! = nil { return err } if wrapper . Min ! = nil { if * wrapper . Min = = " " { y . Auto Min = true y . Min = nil } else { f , err : = wrapper . Min . Float 6 4 ( ) if err ! = nil { return err } y . Min = & f } } if wrapper . Max ! = nil { if * wrapper . Max = = " " { y . Auto Max = true y . Max = nil } else { f , err : = wrapper . Max . Float 6 4 ( ) if err ! = nil { return err } y . Max = & f } } return nil } 
func ( client * Client ) Get Dashboard ( id interface { } ) ( * Dashboard , error ) { string Id , err : = Get String Id ( id ) if err ! = nil { return nil , err } var out req Get Dashboard if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , string Id ) , nil , & out ) ; err ! = nil { return nil , err } return out . Dashboard , nil } 
func ( client * Client ) Get Dashboards ( ) ( [ ] Dashboard Lite , error ) { var out req Get Dashboards if err : = client . do Json Request ( " " , " " , nil , & out ) ; err ! = nil { return nil , err } return out . Dashboards , nil } 
func ( client * Client ) Create Dashboard ( dash * Dashboard ) ( * Dashboard , error ) { var out req Get Dashboard if err : = client . do Json Request ( " " , " " , dash , & out ) ; err ! = nil { return nil , err } return out . Dashboard , nil } 
func ( client * Client ) Update Dashboard ( dash * Dashboard ) error { return client . do Json Request ( " " , fmt . Sprintf ( " " , * dash . Id ) , dash , nil ) } 
func ( client * Client ) Invite Users ( emails [ ] string ) error { return client . do Json Request ( " " , " " , req Invite Users { Emails : emails } , nil ) } 
func ( self * Client ) Create User ( handle , name * string ) ( * User , error ) { in : = struct { Handle * string `json : "handle " ` Name * string `json : "name " ` } { Handle : handle , Name : name , } out : = struct { * User `json : "user " ` } { } if err : = self . do Json Request ( " " , " " , in , & out ) ; err ! = nil { return nil , err } return out . User , nil } 
func ( client * Client ) Get Users ( ) ( users [ ] User , err error ) { var udata users Data uri : = " " err = client . do Json Request ( " " , uri , nil , & udata ) users = udata . Users return } 
func ( client * Client ) Get User ( handle string ) ( user User , err error ) { var udata user Data uri : = " " + handle err = client . do Json Request ( " " , uri , nil , & udata ) user = udata . User return } 
func ( client * Client ) Update User ( user User ) error { uri : = " " + * user . Handle return client . do Json Request ( " " , uri , user , nil ) } 
func ( client * Client ) Delete User ( handle string ) error { uri : = " " + handle return client . do Json Request ( " " , uri , nil , nil ) } 
func ( client * Client ) Get Board ( id string ) ( * Board , error ) { var board Board if err : = client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , & board ) ; err ! = nil { return nil , err } return & board , nil } 
func ( client * Client ) Delete Board ( id string ) error { return client . do Json Request ( " " , fmt . Sprintf ( " " , id ) , nil , nil ) } 
func ( client * Client ) Create Board ( board * Board ) ( * Board , error ) { var created Board Board if err : = client . do Json Request ( " " , " " , board , & created Board ) ; err ! = nil { return nil , err } return & created Board , nil } 
func ( client * Client ) Update Board ( board * Board ) error { return client . do Json Request ( " " , fmt . Sprintf ( " " , * board . Id ) , board , nil ) } 
func New Client ( api Key , app Key string ) * Client { base Url : = os . Getenv ( " " ) if base Url = = " " { base Url = " " } return & Client { api Key : api Key , app Key : app Key , base Url : base Url , Http Client : http . Default Client , Retry Timeout : time . Duration ( 6 0 * time . Second ) , } } 
func ( c * Client ) Set Keys ( api Key , app Key string ) { c . api Key = api Key c . app Key = app Key } 
func ( client * Client ) Validate ( ) ( bool , error ) { var out valid var resp * http . Response uri , err : = client . uri For API ( " " ) if err ! = nil { return false , err } req , err : = http . New Request ( " " , uri , nil ) if err ! = nil { return false , err } resp , err = client . do Request With Retries ( req , client . Retry Timeout ) if err ! = nil { return false , err } defer resp . Body . Close ( ) body , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return false , err } if err = json . Unmarshal ( body , & out ) ; err ! = nil { return false , err } return out . Is Valid , nil } 
func ( widget * Board Widget ) Unmarshal JSON ( data [ ] byte ) error { var widget Handler struct { Definition * struct { Type * string `json : "type " ` } `json : "definition " ` Id * int `json : "id ,omitempty " ` Layout * Widget Layout `json : "layout ,omitempty " ` } if err : = json . Unmarshal ( data , & widget Handler ) ; err ! = nil { return err } } if err : = json . Unmarshal ( data , & alert Graph Widget ) ; err ! = nil { return err } widget . Definition = alert Graph Widget . Definition case ALERT _VALUE _WIDGET : var alert Value Widget struct { Definition Alert Value Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & alert Value Widget ) ; err ! = nil { return err } widget . Definition = alert Value Widget . Definition case CHANGE _WIDGET : var change Widget struct { Definition Change Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & change Widget ) ; err ! = nil { return err } widget . Definition = change Widget . Definition case CHECK _STATUS _WIDGET : var check Status Widget struct { Definition Check Status Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & check Status Widget ) ; err ! = nil { return err } widget . Definition = check Status Widget . Definition case DISTRIBUTION _WIDGET : var distribution Widget struct { Definition Distribution Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & distribution Widget ) ; err ! = nil { return err } widget . Definition = distribution Widget . Definition case EVENT _STREAM _WIDGET : var event Stream Widget struct { Definition Event Stream Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & event Stream Widget ) ; err ! = nil { return err } widget . Definition = event Stream Widget . Definition case EVENT _TIMELINE _WIDGET : var event Timeline Widget struct { Definition Event Timeline Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & event Timeline Widget ) ; err ! = nil { return err } widget . Definition = event Timeline Widget . Definition case FREE _TEXT _WIDGET : var free Text Widget struct { Definition Free Text Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & free Text Widget ) ; err ! = nil { return err } widget . Definition = free Text Widget . Definition case GROUP _WIDGET : var group Widget struct { Definition Group Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & group Widget ) ; err ! = nil { return err } widget . Definition = group Widget . Definition case HEATMAP _WIDGET : var heatmap Widget struct { Definition Heatmap Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & heatmap Widget ) ; err ! = nil { return err } widget . Definition = heatmap Widget . Definition case HOSTMAP _WIDGET : var hostmap Widget struct { Definition Hostmap Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & hostmap Widget ) ; err ! = nil { return err } widget . Definition = hostmap Widget . Definition case IFRAME _WIDGET : var iframe Widget struct { Definition Iframe Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & iframe Widget ) ; err ! = nil { return err } widget . Definition = iframe Widget . Definition case IMAGE _WIDGET : var image Widget struct { Definition Image Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & image Widget ) ; err ! = nil { return err } widget . Definition = image Widget . Definition case LOG _STREAM _WIDGET : var log Stream Widget struct { Definition Log Stream Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & log Stream Widget ) ; err ! = nil { return err } widget . Definition = log Stream Widget . Definition case MANAGE _STATUS _WIDGET : var manage Status Widget struct { Definition Manage Status Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & manage Status Widget ) ; err ! = nil { return err } widget . Definition = manage Status Widget . Definition case NOTE _WIDGET : var note Widget struct { Definition Note Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & note Widget ) ; err ! = nil { return err } widget . Definition = note Widget . Definition case QUERY _VALUE _WIDGET : var query Value Widget struct { Definition Query Value Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & query Value Widget ) ; err ! = nil { return err } widget . Definition = query Value Widget . Definition case SCATTERPLOT _WIDGET : var scatterplot Widget struct { Definition Scatterplot Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & scatterplot Widget ) ; err ! = nil { return err } widget . Definition = scatterplot Widget . Definition case TIMESERIES _WIDGET : var timeseries Widget struct { Definition Timeseries Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & timeseries Widget ) ; err ! = nil { return err } widget . Definition = timeseries Widget . Definition case TOPLIST _WIDGET : var toplist Widget struct { Definition Toplist Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & toplist Widget ) ; err ! = nil { return err } widget . Definition = toplist Widget . Definition case TRACE _SERVICE _WIDGET : var trace Service Widget struct { Definition Trace Service Definition `json : "definition " ` } if err : = json . Unmarshal ( data , & trace Service Widget ) ; err ! = nil { return err } widget . Definition = trace Service Widget . Definition default : return fmt . Errorf ( " " , * widget Handler . Definition . Type ) } return nil } 
func ( client * Client ) Mute Host ( host string , action * Host Action Mute ) ( * Host Action Resp , error ) { var out Host Action Resp uri : = " " + host + " " if err : = client . do Json Request ( " " , uri , action , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( client * Client ) Unmute Host ( host string ) ( * Host Action Resp , error ) { var out Host Action Resp uri : = " " + host + " " if err : = client . do Json Request ( " " , uri , nil , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( a * Alert ) Get Creator ( ) int { if a = = nil | | a . Creator = = nil { return 0 } return * a . Creator } 
func ( a * Alert ) Get Creator Ok ( ) ( int , bool ) { if a = = nil | | a . Creator = = nil { return 0 , false } return * a . Creator , true } 
func ( a * Alert ) Has Creator ( ) bool { if a ! = nil & & a . Creator ! = nil { return true } return false } 
func ( a * Alert ) Get Id ( ) int { if a = = nil | | a . Id = = nil { return 0 } return * a . Id } 
func ( a * Alert ) Get Id Ok ( ) ( int , bool ) { if a = = nil | | a . Id = = nil { return 0 , false } return * a . Id , true } 
func ( a * Alert ) Has Id ( ) bool { if a ! = nil & & a . Id ! = nil { return true } return false } 
func ( a * Alert ) Get Message ( ) string { if a = = nil | | a . Message = = nil { return " " } return * a . Message } 
func ( a * Alert ) Get Message Ok ( ) ( string , bool ) { if a = = nil | | a . Message = = nil { return " " , false } return * a . Message , true } 
func ( a * Alert ) Has Message ( ) bool { if a ! = nil & & a . Message ! = nil { return true } return false } 
func ( a * Alert ) Get Name ( ) string { if a = = nil | | a . Name = = nil { return " " } return * a . Name } 
func ( a * Alert ) Get Name Ok ( ) ( string , bool ) { if a = = nil | | a . Name = = nil { return " " , false } return * a . Name , true } 
func ( a * Alert ) Has Name ( ) bool { if a ! = nil & & a . Name ! = nil { return true } return false } 
func ( a * Alert ) Get Notify No Data ( ) bool { if a = = nil | | a . Notify No Data = = nil { return false } return * a . Notify No Data } 
func ( a * Alert ) Get Notify No Data Ok ( ) ( bool , bool ) { if a = = nil | | a . Notify No Data = = nil { return false , false } return * a . Notify No Data , true } 
func ( a * Alert ) Has Notify No Data ( ) bool { if a ! = nil & & a . Notify No Data ! = nil { return true } return false } 
func ( a * Alert ) Get Query ( ) string { if a = = nil | | a . Query = = nil { return " " } return * a . Query } 
func ( a * Alert ) Get Query Ok ( ) ( string , bool ) { if a = = nil | | a . Query = = nil { return " " , false } return * a . Query , true } 
func ( a * Alert ) Has Query ( ) bool { if a ! = nil & & a . Query ! = nil { return true } return false } 
func ( a * Alert ) Get Silenced ( ) bool { if a = = nil | | a . Silenced = = nil { return false } return * a . Silenced } 
func ( a * Alert ) Get Silenced Ok ( ) ( bool , bool ) { if a = = nil | | a . Silenced = = nil { return false , false } return * a . Silenced , true } 
func ( a * Alert ) Has Silenced ( ) bool { if a ! = nil & & a . Silenced ! = nil { return true } return false } 
func ( a * Alert ) Get State ( ) string { if a = = nil | | a . State = = nil { return " " } return * a . State } 
func ( a * Alert ) Get State Ok ( ) ( string , bool ) { if a = = nil | | a . State = = nil { return " " , false } return * a . State , true } 
func ( a * Alert ) Has State ( ) bool { if a ! = nil & & a . State ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Alert Id ( ) string { if a = = nil | | a . Alert Id = = nil { return " " } return * a . Alert Id } 
func ( a * Alert Graph Definition ) Has Alert Id ( ) bool { if a ! = nil & & a . Alert Id ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Time ( ) Widget Time { if a = = nil | | a . Time = = nil { return Widget Time { } } return * a . Time } 
func ( a * Alert Graph Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if a = = nil | | a . Time = = nil { return Widget Time { } , false } return * a . Time , true } 
func ( a * Alert Graph Definition ) Has Time ( ) bool { if a ! = nil & & a . Time ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Title ( ) string { if a = = nil | | a . Title = = nil { return " " } return * a . Title } 
func ( a * Alert Graph Definition ) Get Title Ok ( ) ( string , bool ) { if a = = nil | | a . Title = = nil { return " " , false } return * a . Title , true } 
func ( a * Alert Graph Definition ) Has Title ( ) bool { if a ! = nil & & a . Title ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Title Align ( ) string { if a = = nil | | a . Title Align = = nil { return " " } return * a . Title Align } 
func ( a * Alert Graph Definition ) Get Title Align Ok ( ) ( string , bool ) { if a = = nil | | a . Title Align = = nil { return " " , false } return * a . Title Align , true } 
func ( a * Alert Graph Definition ) Has Title Align ( ) bool { if a ! = nil & & a . Title Align ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Title Size ( ) string { if a = = nil | | a . Title Size = = nil { return " " } return * a . Title Size } 
func ( a * Alert Graph Definition ) Get Title Size Ok ( ) ( string , bool ) { if a = = nil | | a . Title Size = = nil { return " " , false } return * a . Title Size , true } 
func ( a * Alert Graph Definition ) Has Title Size ( ) bool { if a ! = nil & & a . Title Size ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Type ( ) string { if a = = nil | | a . Type = = nil { return " " } return * a . Type } 
func ( a * Alert Graph Definition ) Get Type Ok ( ) ( string , bool ) { if a = = nil | | a . Type = = nil { return " " , false } return * a . Type , true } 
func ( a * Alert Graph Definition ) Has Type ( ) bool { if a ! = nil & & a . Type ! = nil { return true } return false } 
func ( a * Alert Graph Definition ) Get Viz Type ( ) string { if a = = nil | | a . Viz Type = = nil { return " " } return * a . Viz Type } 
func ( a * Alert Graph Definition ) Get Viz Type Ok ( ) ( string , bool ) { if a = = nil | | a . Viz Type = = nil { return " " , false } return * a . Viz Type , true } 
func ( a * Alert Graph Definition ) Has Viz Type ( ) bool { if a ! = nil & & a . Viz Type ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Alert Id ( ) string { if a = = nil | | a . Alert Id = = nil { return " " } return * a . Alert Id } 
func ( a * Alert Value Definition ) Get Alert Id Ok ( ) ( string , bool ) { if a = = nil | | a . Alert Id = = nil { return " " , false } return * a . Alert Id , true } 
func ( a * Alert Value Definition ) Has Alert Id ( ) bool { if a ! = nil & & a . Alert Id ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Precision ( ) int { if a = = nil | | a . Precision = = nil { return 0 } return * a . Precision } 
func ( a * Alert Value Definition ) Get Precision Ok ( ) ( int , bool ) { if a = = nil | | a . Precision = = nil { return 0 , false } return * a . Precision , true } 
func ( a * Alert Value Definition ) Has Precision ( ) bool { if a ! = nil & & a . Precision ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Text Align ( ) string { if a = = nil | | a . Text Align = = nil { return " " } return * a . Text Align } 
func ( a * Alert Value Definition ) Get Text Align Ok ( ) ( string , bool ) { if a = = nil | | a . Text Align = = nil { return " " , false } return * a . Text Align , true } 
func ( a * Alert Value Definition ) Has Text Align ( ) bool { if a ! = nil & & a . Text Align ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Title ( ) string { if a = = nil | | a . Title = = nil { return " " } return * a . Title } 
func ( a * Alert Value Definition ) Has Title ( ) bool { if a ! = nil & & a . Title ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Title Align ( ) string { if a = = nil | | a . Title Align = = nil { return " " } return * a . Title Align } 
func ( a * Alert Value Definition ) Has Title Align ( ) bool { if a ! = nil & & a . Title Align ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Title Size ( ) string { if a = = nil | | a . Title Size = = nil { return " " } return * a . Title Size } 
func ( a * Alert Value Definition ) Has Title Size ( ) bool { if a ! = nil & & a . Title Size ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Type ( ) string { if a = = nil | | a . Type = = nil { return " " } return * a . Type } 
func ( a * Alert Value Definition ) Has Type ( ) bool { if a ! = nil & & a . Type ! = nil { return true } return false } 
func ( a * Alert Value Definition ) Get Unit ( ) string { if a = = nil | | a . Unit = = nil { return " " } return * a . Unit } 
func ( a * Alert Value Definition ) Get Unit Ok ( ) ( string , bool ) { if a = = nil | | a . Unit = = nil { return " " , false } return * a . Unit , true } 
func ( a * Alert Value Definition ) Has Unit ( ) bool { if a ! = nil & & a . Unit ! = nil { return true } return false } 
func ( a * APIKey ) Get Created ( ) time . Time { if a = = nil | | a . Created = = nil { return time . Time { } } return * a . Created } 
func ( a * APIKey ) Get Created Ok ( ) ( time . Time , bool ) { if a = = nil | | a . Created = = nil { return time . Time { } , false } return * a . Created , true } 
func ( a * APIKey ) Has Created ( ) bool { if a ! = nil & & a . Created ! = nil { return true } return false } 
func ( a * APIKey ) Get Created By ( ) string { if a = = nil | | a . Created By = = nil { return " " } return * a . Created By } 
func ( a * APIKey ) Get Created By Ok ( ) ( string , bool ) { if a = = nil | | a . Created By = = nil { return " " , false } return * a . Created By , true } 
func ( a * APIKey ) Has Created By ( ) bool { if a ! = nil & & a . Created By ! = nil { return true } return false } 
func ( a * APIKey ) Get Key ( ) string { if a = = nil | | a . Key = = nil { return " " } return * a . Key } 
func ( a * APIKey ) Get Key Ok ( ) ( string , bool ) { if a = = nil | | a . Key = = nil { return " " , false } return * a . Key , true } 
func ( a * APIKey ) Has Key ( ) bool { if a ! = nil & & a . Key ! = nil { return true } return false } 
func ( a * APIKey ) Get Name ( ) string { if a = = nil | | a . Name = = nil { return " " } return * a . Name } 
func ( a * APIKey ) Has Name ( ) bool { if a ! = nil & & a . Name ! = nil { return true } return false } 
func ( a * Apm Or Log Query Compute ) Get Aggregation ( ) string { if a = = nil | | a . Aggregation = = nil { return " " } return * a . Aggregation } 
func ( a * Apm Or Log Query Compute ) Get Aggregation Ok ( ) ( string , bool ) { if a = = nil | | a . Aggregation = = nil { return " " , false } return * a . Aggregation , true } 
func ( a * Apm Or Log Query Compute ) Has Aggregation ( ) bool { if a ! = nil & & a . Aggregation ! = nil { return true } return false } 
func ( a * Apm Or Log Query Compute ) Get Facet ( ) string { if a = = nil | | a . Facet = = nil { return " " } return * a . Facet } 
func ( a * Apm Or Log Query Compute ) Has Facet ( ) bool { if a ! = nil & & a . Facet ! = nil { return true } return false } 
func ( a * Apm Or Log Query Compute ) Get Interval ( ) int { if a = = nil | | a . Interval = = nil { return 0 } return * a . Interval } 
func ( a * Apm Or Log Query Compute ) Get Interval Ok ( ) ( int , bool ) { if a = = nil | | a . Interval = = nil { return 0 , false } return * a . Interval , true } 
func ( a * Apm Or Log Query Compute ) Has Interval ( ) bool { if a ! = nil & & a . Interval ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By ) Get Facet ( ) string { if a = = nil | | a . Facet = = nil { return " " } return * a . Facet } 
func ( a * Apm Or Log Query Group By ) Get Facet Ok ( ) ( string , bool ) { if a = = nil | | a . Facet = = nil { return " " , false } return * a . Facet , true } 
func ( a * Apm Or Log Query Group By ) Has Facet ( ) bool { if a ! = nil & & a . Facet ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By ) Get Limit ( ) int { if a = = nil | | a . Limit = = nil { return 0 } return * a . Limit } 
func ( a * Apm Or Log Query Group By ) Get Limit Ok ( ) ( int , bool ) { if a = = nil | | a . Limit = = nil { return 0 , false } return * a . Limit , true } 
func ( a * Apm Or Log Query Group By ) Has Limit ( ) bool { if a ! = nil & & a . Limit ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By ) Get Sort ( ) Apm Or Log Query Group By Sort { if a = = nil | | a . Sort = = nil { return Apm Or Log Query Group By Sort { } } return * a . Sort } 
func ( a * Apm Or Log Query Group By ) Get Sort Ok ( ) ( Apm Or Log Query Group By Sort , bool ) { if a = = nil | | a . Sort = = nil { return Apm Or Log Query Group By Sort { } , false } return * a . Sort , true } 
func ( a * Apm Or Log Query Group By ) Has Sort ( ) bool { if a ! = nil & & a . Sort ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By Sort ) Get Aggregation ( ) string { if a = = nil | | a . Aggregation = = nil { return " " } return * a . Aggregation } 
func ( a * Apm Or Log Query Group By Sort ) Has Aggregation ( ) bool { if a ! = nil & & a . Aggregation ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By Sort ) Get Facet ( ) string { if a = = nil | | a . Facet = = nil { return " " } return * a . Facet } 
func ( a * Apm Or Log Query Group By Sort ) Has Facet ( ) bool { if a ! = nil & & a . Facet ! = nil { return true } return false } 
func ( a * Apm Or Log Query Group By Sort ) Get Order ( ) string { if a = = nil | | a . Order = = nil { return " " } return * a . Order } 
func ( a * Apm Or Log Query Group By Sort ) Get Order Ok ( ) ( string , bool ) { if a = = nil | | a . Order = = nil { return " " , false } return * a . Order , true } 
func ( a * Apm Or Log Query Group By Sort ) Has Order ( ) bool { if a ! = nil & & a . Order ! = nil { return true } return false } 
func ( a * Apm Or Log Query Search ) Get Query ( ) string { if a = = nil | | a . Query = = nil { return " " } return * a . Query } 
func ( a * Apm Or Log Query Search ) Has Query ( ) bool { if a ! = nil & & a . Query ! = nil { return true } return false } 
func ( b * Board ) Get Author Handle ( ) string { if b = = nil | | b . Author Handle = = nil { return " " } return * b . Author Handle } 
func ( b * Board ) Get Author Handle Ok ( ) ( string , bool ) { if b = = nil | | b . Author Handle = = nil { return " " , false } return * b . Author Handle , true } 
func ( b * Board ) Has Author Handle ( ) bool { if b ! = nil & & b . Author Handle ! = nil { return true } return false } 
func ( b * Board ) Get Created At ( ) string { if b = = nil | | b . Created At = = nil { return " " } return * b . Created At } 
func ( b * Board ) Get Created At Ok ( ) ( string , bool ) { if b = = nil | | b . Created At = = nil { return " " , false } return * b . Created At , true } 
func ( b * Board ) Has Created At ( ) bool { if b ! = nil & & b . Created At ! = nil { return true } return false } 
func ( b * Board ) Get Description ( ) string { if b = = nil | | b . Description = = nil { return " " } return * b . Description } 
func ( b * Board ) Get Description Ok ( ) ( string , bool ) { if b = = nil | | b . Description = = nil { return " " , false } return * b . Description , true } 
func ( b * Board ) Has Description ( ) bool { if b ! = nil & & b . Description ! = nil { return true } return false } 
func ( b * Board ) Get Id ( ) string { if b = = nil | | b . Id = = nil { return " " } return * b . Id } 
func ( b * Board ) Get Id Ok ( ) ( string , bool ) { if b = = nil | | b . Id = = nil { return " " , false } return * b . Id , true } 
func ( b * Board ) Has Id ( ) bool { if b ! = nil & & b . Id ! = nil { return true } return false } 
func ( b * Board ) Get Is Read Only ( ) bool { if b = = nil | | b . Is Read Only = = nil { return false } return * b . Is Read Only } 
func ( b * Board ) Get Is Read Only Ok ( ) ( bool , bool ) { if b = = nil | | b . Is Read Only = = nil { return false , false } return * b . Is Read Only , true } 
func ( b * Board ) Has Is Read Only ( ) bool { if b ! = nil & & b . Is Read Only ! = nil { return true } return false } 
func ( b * Board ) Get Layout Type ( ) string { if b = = nil | | b . Layout Type = = nil { return " " } return * b . Layout Type } 
func ( b * Board ) Get Layout Type Ok ( ) ( string , bool ) { if b = = nil | | b . Layout Type = = nil { return " " , false } return * b . Layout Type , true } 
func ( b * Board ) Has Layout Type ( ) bool { if b ! = nil & & b . Layout Type ! = nil { return true } return false } 
func ( b * Board ) Get Modified At ( ) string { if b = = nil | | b . Modified At = = nil { return " " } return * b . Modified At } 
func ( b * Board ) Get Modified At Ok ( ) ( string , bool ) { if b = = nil | | b . Modified At = = nil { return " " , false } return * b . Modified At , true } 
func ( b * Board ) Has Modified At ( ) bool { if b ! = nil & & b . Modified At ! = nil { return true } return false } 
func ( b * Board ) Get Title ( ) string { if b = = nil | | b . Title = = nil { return " " } return * b . Title } 
func ( b * Board ) Get Title Ok ( ) ( string , bool ) { if b = = nil | | b . Title = = nil { return " " , false } return * b . Title , true } 
func ( b * Board ) Has Title ( ) bool { if b ! = nil & & b . Title ! = nil { return true } return false } 
func ( b * Board ) Get Url ( ) string { if b = = nil | | b . Url = = nil { return " " } return * b . Url } 
func ( b * Board ) Get Url Ok ( ) ( string , bool ) { if b = = nil | | b . Url = = nil { return " " , false } return * b . Url , true } 
func ( b * Board ) Has Url ( ) bool { if b ! = nil & & b . Url ! = nil { return true } return false } 
func ( b * Board Widget ) Get Id ( ) int { if b = = nil | | b . Id = = nil { return 0 } return * b . Id } 
func ( b * Board Widget ) Get Id Ok ( ) ( int , bool ) { if b = = nil | | b . Id = = nil { return 0 , false } return * b . Id , true } 
func ( b * Board Widget ) Has Id ( ) bool { if b ! = nil & & b . Id ! = nil { return true } return false } 
func ( b * Board Widget ) Get Layout ( ) Widget Layout { if b = = nil | | b . Layout = = nil { return Widget Layout { } } return * b . Layout } 
func ( b * Board Widget ) Get Layout Ok ( ) ( Widget Layout , bool ) { if b = = nil | | b . Layout = = nil { return Widget Layout { } , false } return * b . Layout , true } 
func ( b * Board Widget ) Has Layout ( ) bool { if b ! = nil & & b . Layout ! = nil { return true } return false } 
func ( c * Change Definition ) Get Time ( ) Widget Time { if c = = nil | | c . Time = = nil { return Widget Time { } } return * c . Time } 
func ( c * Change Definition ) Has Time ( ) bool { if c ! = nil & & c . Time ! = nil { return true } return false } 
func ( c * Change Definition ) Get Title ( ) string { if c = = nil | | c . Title = = nil { return " " } return * c . Title } 
func ( c * Change Definition ) Has Title ( ) bool { if c ! = nil & & c . Title ! = nil { return true } return false } 
func ( c * Change Definition ) Get Title Align ( ) string { if c = = nil | | c . Title Align = = nil { return " " } return * c . Title Align } 
func ( c * Change Definition ) Has Title Align ( ) bool { if c ! = nil & & c . Title Align ! = nil { return true } return false } 
func ( c * Change Definition ) Get Title Size ( ) string { if c = = nil | | c . Title Size = = nil { return " " } return * c . Title Size } 
func ( c * Change Definition ) Has Title Size ( ) bool { if c ! = nil & & c . Title Size ! = nil { return true } return false } 
func ( c * Change Definition ) Get Type ( ) string { if c = = nil | | c . Type = = nil { return " " } return * c . Type } 
func ( c * Change Definition ) Has Type ( ) bool { if c ! = nil & & c . Type ! = nil { return true } return false } 
func ( c * Change Request ) Get Apm Query ( ) Widget Apm Or Log Query { if c = = nil | | c . Apm Query = = nil { return Widget Apm Or Log Query { } } return * c . Apm Query } 
func ( c * Change Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if c = = nil | | c . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * c . Apm Query , true } 
func ( c * Change Request ) Has Apm Query ( ) bool { if c ! = nil & & c . Apm Query ! = nil { return true } return false } 
func ( c * Change Request ) Get Change Type ( ) string { if c = = nil | | c . Change Type = = nil { return " " } return * c . Change Type } 
func ( c * Change Request ) Get Change Type Ok ( ) ( string , bool ) { if c = = nil | | c . Change Type = = nil { return " " , false } return * c . Change Type , true } 
func ( c * Change Request ) Has Change Type ( ) bool { if c ! = nil & & c . Change Type ! = nil { return true } return false } 
func ( c * Change Request ) Get Compare To ( ) string { if c = = nil | | c . Compare To = = nil { return " " } return * c . Compare To } 
func ( c * Change Request ) Get Compare To Ok ( ) ( string , bool ) { if c = = nil | | c . Compare To = = nil { return " " , false } return * c . Compare To , true } 
func ( c * Change Request ) Has Compare To ( ) bool { if c ! = nil & & c . Compare To ! = nil { return true } return false } 
func ( c * Change Request ) Get Increase Good ( ) bool { if c = = nil | | c . Increase Good = = nil { return false } return * c . Increase Good } 
func ( c * Change Request ) Get Increase Good Ok ( ) ( bool , bool ) { if c = = nil | | c . Increase Good = = nil { return false , false } return * c . Increase Good , true } 
func ( c * Change Request ) Has Increase Good ( ) bool { if c ! = nil & & c . Increase Good ! = nil { return true } return false } 
func ( c * Change Request ) Get Log Query ( ) Widget Apm Or Log Query { if c = = nil | | c . Log Query = = nil { return Widget Apm Or Log Query { } } return * c . Log Query } 
func ( c * Change Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if c = = nil | | c . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * c . Log Query , true } 
func ( c * Change Request ) Has Log Query ( ) bool { if c ! = nil & & c . Log Query ! = nil { return true } return false } 
func ( c * Change Request ) Get Metric Query ( ) string { if c = = nil | | c . Metric Query = = nil { return " " } return * c . Metric Query } 
func ( c * Change Request ) Get Metric Query Ok ( ) ( string , bool ) { if c = = nil | | c . Metric Query = = nil { return " " , false } return * c . Metric Query , true } 
func ( c * Change Request ) Has Metric Query ( ) bool { if c ! = nil & & c . Metric Query ! = nil { return true } return false } 
func ( c * Change Request ) Get Order By ( ) string { if c = = nil | | c . Order By = = nil { return " " } return * c . Order By } 
func ( c * Change Request ) Get Order By Ok ( ) ( string , bool ) { if c = = nil | | c . Order By = = nil { return " " , false } return * c . Order By , true } 
func ( c * Change Request ) Has Order By ( ) bool { if c ! = nil & & c . Order By ! = nil { return true } return false } 
func ( c * Change Request ) Get Order Dir ( ) string { if c = = nil | | c . Order Dir = = nil { return " " } return * c . Order Dir } 
func ( c * Change Request ) Get Order Dir Ok ( ) ( string , bool ) { if c = = nil | | c . Order Dir = = nil { return " " , false } return * c . Order Dir , true } 
func ( c * Change Request ) Has Order Dir ( ) bool { if c ! = nil & & c . Order Dir ! = nil { return true } return false } 
func ( c * Change Request ) Get Process Query ( ) Widget Process Query { if c = = nil | | c . Process Query = = nil { return Widget Process Query { } } return * c . Process Query } 
func ( c * Change Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if c = = nil | | c . Process Query = = nil { return Widget Process Query { } , false } return * c . Process Query , true } 
func ( c * Change Request ) Has Process Query ( ) bool { if c ! = nil & & c . Process Query ! = nil { return true } return false } 
func ( c * Change Request ) Get Show Present ( ) bool { if c = = nil | | c . Show Present = = nil { return false } return * c . Show Present } 
func ( c * Change Request ) Get Show Present Ok ( ) ( bool , bool ) { if c = = nil | | c . Show Present = = nil { return false , false } return * c . Show Present , true } 
func ( c * Change Request ) Has Show Present ( ) bool { if c ! = nil & & c . Show Present ! = nil { return true } return false } 
func ( c * Channel Slack Request ) Get Account ( ) string { if c = = nil | | c . Account = = nil { return " " } return * c . Account } 
func ( c * Channel Slack Request ) Get Account Ok ( ) ( string , bool ) { if c = = nil | | c . Account = = nil { return " " , false } return * c . Account , true } 
func ( c * Channel Slack Request ) Has Account ( ) bool { if c ! = nil & & c . Account ! = nil { return true } return false } 
func ( c * Channel Slack Request ) Get Channel Name ( ) string { if c = = nil | | c . Channel Name = = nil { return " " } return * c . Channel Name } 
func ( c * Channel Slack Request ) Get Channel Name Ok ( ) ( string , bool ) { if c = = nil | | c . Channel Name = = nil { return " " , false } return * c . Channel Name , true } 
func ( c * Channel Slack Request ) Has Channel Name ( ) bool { if c ! = nil & & c . Channel Name ! = nil { return true } return false } 
func ( c * Channel Slack Request ) Get Transfer All User Comments ( ) bool { if c = = nil | | c . Transfer All User Comments = = nil { return false } return * c . Transfer All User Comments } 
func ( c * Channel Slack Request ) Get Transfer All User Comments Ok ( ) ( bool , bool ) { if c = = nil | | c . Transfer All User Comments = = nil { return false , false } return * c . Transfer All User Comments , true } 
func ( c * Channel Slack Request ) Has Transfer All User Comments ( ) bool { if c ! = nil & & c . Transfer All User Comments ! = nil { return true } return false } 
func ( c * Check ) Get Check ( ) string { if c = = nil | | c . Check = = nil { return " " } return * c . Check } 
func ( c * Check ) Get Host Name ( ) string { if c = = nil | | c . Host Name = = nil { return " " } return * c . Host Name } 
func ( c * Check ) Get Host Name Ok ( ) ( string , bool ) { if c = = nil | | c . Host Name = = nil { return " " , false } return * c . Host Name , true } 
func ( c * Check ) Has Host Name ( ) bool { if c ! = nil & & c . Host Name ! = nil { return true } return false } 
func ( c * Check ) Get Message ( ) string { if c = = nil | | c . Message = = nil { return " " } return * c . Message } 
func ( c * Check ) Has Message ( ) bool { if c ! = nil & & c . Message ! = nil { return true } return false } 
func ( c * Check ) Get Status ( ) Status { if c = = nil | | c . Status = = nil { return 0 } return * c . Status } 
func ( c * Check ) Get Status Ok ( ) ( Status , bool ) { if c = = nil | | c . Status = = nil { return 0 , false } return * c . Status , true } 
func ( c * Check ) Has Status ( ) bool { if c ! = nil & & c . Status ! = nil { return true } return false } 
func ( c * Check ) Get Timestamp ( ) string { if c = = nil | | c . Timestamp = = nil { return " " } return * c . Timestamp } 
func ( c * Check ) Get Timestamp Ok ( ) ( string , bool ) { if c = = nil | | c . Timestamp = = nil { return " " , false } return * c . Timestamp , true } 
func ( c * Check ) Has Timestamp ( ) bool { if c ! = nil & & c . Timestamp ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Check Ok ( ) ( string , bool ) { if c = = nil | | c . Check = = nil { return " " , false } return * c . Check , true } 
func ( c * Check Status Definition ) Has Check ( ) bool { if c ! = nil & & c . Check ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Group ( ) string { if c = = nil | | c . Group = = nil { return " " } return * c . Group } 
func ( c * Check Status Definition ) Get Group Ok ( ) ( string , bool ) { if c = = nil | | c . Group = = nil { return " " , false } return * c . Group , true } 
func ( c * Check Status Definition ) Has Group ( ) bool { if c ! = nil & & c . Group ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Grouping ( ) string { if c = = nil | | c . Grouping = = nil { return " " } return * c . Grouping } 
func ( c * Check Status Definition ) Get Grouping Ok ( ) ( string , bool ) { if c = = nil | | c . Grouping = = nil { return " " , false } return * c . Grouping , true } 
func ( c * Check Status Definition ) Has Grouping ( ) bool { if c ! = nil & & c . Grouping ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Time ( ) Widget Time { if c = = nil | | c . Time = = nil { return Widget Time { } } return * c . Time } 
func ( c * Check Status Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if c = = nil | | c . Time = = nil { return Widget Time { } , false } return * c . Time , true } 
func ( c * Check Status Definition ) Has Time ( ) bool { if c ! = nil & & c . Time ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Title ( ) string { if c = = nil | | c . Title = = nil { return " " } return * c . Title } 
func ( c * Check Status Definition ) Get Title Ok ( ) ( string , bool ) { if c = = nil | | c . Title = = nil { return " " , false } return * c . Title , true } 
func ( c * Check Status Definition ) Has Title ( ) bool { if c ! = nil & & c . Title ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Title Align ( ) string { if c = = nil | | c . Title Align = = nil { return " " } return * c . Title Align } 
func ( c * Check Status Definition ) Get Title Align Ok ( ) ( string , bool ) { if c = = nil | | c . Title Align = = nil { return " " , false } return * c . Title Align , true } 
func ( c * Check Status Definition ) Has Title Align ( ) bool { if c ! = nil & & c . Title Align ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Title Size ( ) string { if c = = nil | | c . Title Size = = nil { return " " } return * c . Title Size } 
func ( c * Check Status Definition ) Get Title Size Ok ( ) ( string , bool ) { if c = = nil | | c . Title Size = = nil { return " " , false } return * c . Title Size , true } 
func ( c * Check Status Definition ) Has Title Size ( ) bool { if c ! = nil & & c . Title Size ! = nil { return true } return false } 
func ( c * Check Status Definition ) Get Type ( ) string { if c = = nil | | c . Type = = nil { return " " } return * c . Type } 
func ( c * Check Status Definition ) Get Type Ok ( ) ( string , bool ) { if c = = nil | | c . Type = = nil { return " " , false } return * c . Type , true } 
func ( c * Check Status Definition ) Has Type ( ) bool { if c ! = nil & & c . Type ! = nil { return true } return false } 
func ( c * Comment ) Get Handle ( ) string { if c = = nil | | c . Handle = = nil { return " " } return * c . Handle } 
func ( c * Comment ) Get Handle Ok ( ) ( string , bool ) { if c = = nil | | c . Handle = = nil { return " " , false } return * c . Handle , true } 
func ( c * Comment ) Has Handle ( ) bool { if c ! = nil & & c . Handle ! = nil { return true } return false } 
func ( c * Comment ) Get Id ( ) int { if c = = nil | | c . Id = = nil { return 0 } return * c . Id } 
func ( c * Comment ) Get Id Ok ( ) ( int , bool ) { if c = = nil | | c . Id = = nil { return 0 , false } return * c . Id , true } 
func ( c * Comment ) Has Id ( ) bool { if c ! = nil & & c . Id ! = nil { return true } return false } 
func ( c * Comment ) Get Message ( ) string { if c = = nil | | c . Message = = nil { return " " } return * c . Message } 
func ( c * Comment ) Get Message Ok ( ) ( string , bool ) { if c = = nil | | c . Message = = nil { return " " , false } return * c . Message , true } 
func ( c * Comment ) Has Message ( ) bool { if c ! = nil & & c . Message ! = nil { return true } return false } 
func ( c * Comment ) Get Related Id ( ) int { if c = = nil | | c . Related Id = = nil { return 0 } return * c . Related Id } 
func ( c * Comment ) Get Related Id Ok ( ) ( int , bool ) { if c = = nil | | c . Related Id = = nil { return 0 , false } return * c . Related Id , true } 
func ( c * Comment ) Has Related Id ( ) bool { if c ! = nil & & c . Related Id ! = nil { return true } return false } 
func ( c * Comment ) Get Resource ( ) string { if c = = nil | | c . Resource = = nil { return " " } return * c . Resource } 
func ( c * Comment ) Get Resource Ok ( ) ( string , bool ) { if c = = nil | | c . Resource = = nil { return " " , false } return * c . Resource , true } 
func ( c * Comment ) Has Resource ( ) bool { if c ! = nil & & c . Resource ! = nil { return true } return false } 
func ( c * Comment ) Get Url ( ) string { if c = = nil | | c . Url = = nil { return " " } return * c . Url } 
func ( c * Comment ) Get Url Ok ( ) ( string , bool ) { if c = = nil | | c . Url = = nil { return " " , false } return * c . Url , true } 
func ( c * Comment ) Has Url ( ) bool { if c ! = nil & & c . Url ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Color ( ) string { if c = = nil | | c . Color = = nil { return " " } return * c . Color } 
func ( c * Conditional Format ) Get Color Ok ( ) ( string , bool ) { if c = = nil | | c . Color = = nil { return " " , false } return * c . Color , true } 
func ( c * Conditional Format ) Has Color ( ) bool { if c ! = nil & & c . Color ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Comparator ( ) string { if c = = nil | | c . Comparator = = nil { return " " } return * c . Comparator } 
func ( c * Conditional Format ) Get Comparator Ok ( ) ( string , bool ) { if c = = nil | | c . Comparator = = nil { return " " , false } return * c . Comparator , true } 
func ( c * Conditional Format ) Has Comparator ( ) bool { if c ! = nil & & c . Comparator ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Image URL ( ) string { if c = = nil | | c . Image URL = = nil { return " " } return * c . Image URL } 
func ( c * Conditional Format ) Get Image URLOk ( ) ( string , bool ) { if c = = nil | | c . Image URL = = nil { return " " , false } return * c . Image URL , true } 
func ( c * Conditional Format ) Has Image URL ( ) bool { if c ! = nil & & c . Image URL ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Invert ( ) bool { if c = = nil | | c . Invert = = nil { return false } return * c . Invert } 
func ( c * Conditional Format ) Get Invert Ok ( ) ( bool , bool ) { if c = = nil | | c . Invert = = nil { return false , false } return * c . Invert , true } 
func ( c * Conditional Format ) Has Invert ( ) bool { if c ! = nil & & c . Invert ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Palette ( ) string { if c = = nil | | c . Palette = = nil { return " " } return * c . Palette } 
func ( c * Conditional Format ) Get Palette Ok ( ) ( string , bool ) { if c = = nil | | c . Palette = = nil { return " " , false } return * c . Palette , true } 
func ( c * Conditional Format ) Has Palette ( ) bool { if c ! = nil & & c . Palette ! = nil { return true } return false } 
func ( c * Conditional Format ) Get Value ( ) string { if c = = nil | | c . Value = = nil { return " " } return * c . Value } 
func ( c * Conditional Format ) Get Value Ok ( ) ( string , bool ) { if c = = nil | | c . Value = = nil { return " " , false } return * c . Value , true } 
func ( c * Conditional Format ) Has Value ( ) bool { if c ! = nil & & c . Value ! = nil { return true } return false } 
func ( c * Created By ) Get Access Role ( ) string { if c = = nil | | c . Access Role = = nil { return " " } return * c . Access Role } 
func ( c * Created By ) Get Access Role Ok ( ) ( string , bool ) { if c = = nil | | c . Access Role = = nil { return " " , false } return * c . Access Role , true } 
func ( c * Created By ) Has Access Role ( ) bool { if c ! = nil & & c . Access Role ! = nil { return true } return false } 
func ( c * Created By ) Get Disabled ( ) bool { if c = = nil | | c . Disabled = = nil { return false } return * c . Disabled } 
func ( c * Created By ) Get Disabled Ok ( ) ( bool , bool ) { if c = = nil | | c . Disabled = = nil { return false , false } return * c . Disabled , true } 
func ( c * Created By ) Has Disabled ( ) bool { if c ! = nil & & c . Disabled ! = nil { return true } return false } 
func ( c * Created By ) Get Email ( ) string { if c = = nil | | c . Email = = nil { return " " } return * c . Email } 
func ( c * Created By ) Get Email Ok ( ) ( string , bool ) { if c = = nil | | c . Email = = nil { return " " , false } return * c . Email , true } 
func ( c * Created By ) Has Email ( ) bool { if c ! = nil & & c . Email ! = nil { return true } return false } 
func ( c * Created By ) Get Handle ( ) string { if c = = nil | | c . Handle = = nil { return " " } return * c . Handle } 
func ( c * Created By ) Has Handle ( ) bool { if c ! = nil & & c . Handle ! = nil { return true } return false } 
func ( c * Created By ) Get Icon ( ) string { if c = = nil | | c . Icon = = nil { return " " } return * c . Icon } 
func ( c * Created By ) Get Icon Ok ( ) ( string , bool ) { if c = = nil | | c . Icon = = nil { return " " , false } return * c . Icon , true } 
func ( c * Created By ) Has Icon ( ) bool { if c ! = nil & & c . Icon ! = nil { return true } return false } 
func ( c * Created By ) Get Is Admin ( ) bool { if c = = nil | | c . Is Admin = = nil { return false } return * c . Is Admin } 
func ( c * Created By ) Get Is Admin Ok ( ) ( bool , bool ) { if c = = nil | | c . Is Admin = = nil { return false , false } return * c . Is Admin , true } 
func ( c * Created By ) Has Is Admin ( ) bool { if c ! = nil & & c . Is Admin ! = nil { return true } return false } 
func ( c * Created By ) Get Name ( ) string { if c = = nil | | c . Name = = nil { return " " } return * c . Name } 
func ( c * Created By ) Has Name ( ) bool { if c ! = nil & & c . Name ! = nil { return true } return false } 
func ( c * Created By ) Get Role ( ) string { if c = = nil | | c . Role = = nil { return " " } return * c . Role } 
func ( c * Created By ) Get Role Ok ( ) ( string , bool ) { if c = = nil | | c . Role = = nil { return " " , false } return * c . Role , true } 
func ( c * Created By ) Has Role ( ) bool { if c ! = nil & & c . Role ! = nil { return true } return false } 
func ( c * Created By ) Get Verified ( ) bool { if c = = nil | | c . Verified = = nil { return false } return * c . Verified } 
func ( c * Created By ) Get Verified Ok ( ) ( bool , bool ) { if c = = nil | | c . Verified = = nil { return false , false } return * c . Verified , true } 
func ( c * Created By ) Has Verified ( ) bool { if c ! = nil & & c . Verified ! = nil { return true } return false } 
func ( c * Creator ) Get Email ( ) string { if c = = nil | | c . Email = = nil { return " " } return * c . Email } 
func ( c * Creator ) Has Email ( ) bool { if c ! = nil & & c . Email ! = nil { return true } return false } 
func ( c * Creator ) Get Handle ( ) string { if c = = nil | | c . Handle = = nil { return " " } return * c . Handle } 
func ( c * Creator ) Has Handle ( ) bool { if c ! = nil & & c . Handle ! = nil { return true } return false } 
func ( c * Creator ) Get Id ( ) int { if c = = nil | | c . Id = = nil { return 0 } return * c . Id } 
func ( c * Creator ) Has Id ( ) bool { if c ! = nil & & c . Id ! = nil { return true } return false } 
func ( c * Creator ) Get Name ( ) string { if c = = nil | | c . Name = = nil { return " " } return * c . Name } 
func ( c * Creator ) Get Name Ok ( ) ( string , bool ) { if c = = nil | | c . Name = = nil { return " " , false } return * c . Name , true } 
func ( c * Creator ) Has Name ( ) bool { if c ! = nil & & c . Name ! = nil { return true } return false } 
func ( d * Dashboard ) Get Description ( ) string { if d = = nil | | d . Description = = nil { return " " } return * d . Description } 
func ( d * Dashboard ) Has Description ( ) bool { if d ! = nil & & d . Description ! = nil { return true } return false } 
func ( d * Dashboard ) Get Id ( ) int { if d = = nil | | d . Id = = nil { return 0 } return * d . Id } 
func ( d * Dashboard ) Has Id ( ) bool { if d ! = nil & & d . Id ! = nil { return true } return false } 
func ( d * Dashboard ) Get New Id ( ) string { if d = = nil | | d . New Id = = nil { return " " } return * d . New Id } 
func ( d * Dashboard ) Get New Id Ok ( ) ( string , bool ) { if d = = nil | | d . New Id = = nil { return " " , false } return * d . New Id , true } 
func ( d * Dashboard ) Has New Id ( ) bool { if d ! = nil & & d . New Id ! = nil { return true } return false } 
func ( d * Dashboard ) Get Read Only ( ) bool { if d = = nil | | d . Read Only = = nil { return false } return * d . Read Only } 
func ( d * Dashboard ) Get Read Only Ok ( ) ( bool , bool ) { if d = = nil | | d . Read Only = = nil { return false , false } return * d . Read Only , true } 
func ( d * Dashboard ) Has Read Only ( ) bool { if d ! = nil & & d . Read Only ! = nil { return true } return false } 
func ( d * Dashboard ) Get Title ( ) string { if d = = nil | | d . Title = = nil { return " " } return * d . Title } 
func ( d * Dashboard ) Has Title ( ) bool { if d ! = nil & & d . Title ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Comparator ( ) string { if d = = nil | | d . Comparator = = nil { return " " } return * d . Comparator } 
func ( d * Dashboard Conditional Format ) Get Comparator Ok ( ) ( string , bool ) { if d = = nil | | d . Comparator = = nil { return " " , false } return * d . Comparator , true } 
func ( d * Dashboard Conditional Format ) Has Comparator ( ) bool { if d ! = nil & & d . Comparator ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Custom Bg Color ( ) string { if d = = nil | | d . Custom Bg Color = = nil { return " " } return * d . Custom Bg Color } 
func ( d * Dashboard Conditional Format ) Get Custom Bg Color Ok ( ) ( string , bool ) { if d = = nil | | d . Custom Bg Color = = nil { return " " , false } return * d . Custom Bg Color , true } 
func ( d * Dashboard Conditional Format ) Has Custom Bg Color ( ) bool { if d ! = nil & & d . Custom Bg Color ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Custom Fg Color ( ) string { if d = = nil | | d . Custom Fg Color = = nil { return " " } return * d . Custom Fg Color } 
func ( d * Dashboard Conditional Format ) Get Custom Fg Color Ok ( ) ( string , bool ) { if d = = nil | | d . Custom Fg Color = = nil { return " " , false } return * d . Custom Fg Color , true } 
func ( d * Dashboard Conditional Format ) Has Custom Fg Color ( ) bool { if d ! = nil & & d . Custom Fg Color ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Custom Image Url ( ) string { if d = = nil | | d . Custom Image Url = = nil { return " " } return * d . Custom Image Url } 
func ( d * Dashboard Conditional Format ) Get Custom Image Url Ok ( ) ( string , bool ) { if d = = nil | | d . Custom Image Url = = nil { return " " , false } return * d . Custom Image Url , true } 
func ( d * Dashboard Conditional Format ) Has Custom Image Url ( ) bool { if d ! = nil & & d . Custom Image Url ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Inverted ( ) bool { if d = = nil | | d . Inverted = = nil { return false } return * d . Inverted } 
func ( d * Dashboard Conditional Format ) Get Inverted Ok ( ) ( bool , bool ) { if d = = nil | | d . Inverted = = nil { return false , false } return * d . Inverted , true } 
func ( d * Dashboard Conditional Format ) Has Inverted ( ) bool { if d ! = nil & & d . Inverted ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Palette ( ) string { if d = = nil | | d . Palette = = nil { return " " } return * d . Palette } 
func ( d * Dashboard Conditional Format ) Get Palette Ok ( ) ( string , bool ) { if d = = nil | | d . Palette = = nil { return " " , false } return * d . Palette , true } 
func ( d * Dashboard Conditional Format ) Has Palette ( ) bool { if d ! = nil & & d . Palette ! = nil { return true } return false } 
func ( d * Dashboard Conditional Format ) Get Value ( ) json . Number { if d = = nil | | d . Value = = nil { return " " } return * d . Value } 
func ( d * Dashboard Conditional Format ) Get Value Ok ( ) ( json . Number , bool ) { if d = = nil | | d . Value = = nil { return " " , false } return * d . Value , true } 
func ( d * Dashboard Conditional Format ) Has Value ( ) bool { if d ! = nil & & d . Value ! = nil { return true } return false } 
func ( d * Dashboard List ) Get Dashboard Count ( ) int { if d = = nil | | d . Dashboard Count = = nil { return 0 } return * d . Dashboard Count } 
func ( d * Dashboard List ) Get Dashboard Count Ok ( ) ( int , bool ) { if d = = nil | | d . Dashboard Count = = nil { return 0 , false } return * d . Dashboard Count , true } 
func ( d * Dashboard List ) Has Dashboard Count ( ) bool { if d ! = nil & & d . Dashboard Count ! = nil { return true } return false } 
func ( d * Dashboard List ) Get Id ( ) int { if d = = nil | | d . Id = = nil { return 0 } return * d . Id } 
func ( d * Dashboard List ) Get Id Ok ( ) ( int , bool ) { if d = = nil | | d . Id = = nil { return 0 , false } return * d . Id , true } 
func ( d * Dashboard List ) Has Id ( ) bool { if d ! = nil & & d . Id ! = nil { return true } return false } 
func ( d * Dashboard List ) Get Name ( ) string { if d = = nil | | d . Name = = nil { return " " } return * d . Name } 
func ( d * Dashboard List ) Get Name Ok ( ) ( string , bool ) { if d = = nil | | d . Name = = nil { return " " , false } return * d . Name , true } 
func ( d * Dashboard List ) Has Name ( ) bool { if d ! = nil & & d . Name ! = nil { return true } return false } 
func ( d * Dashboard List Item ) Get Id ( ) int { if d = = nil | | d . Id = = nil { return 0 } return * d . Id } 
func ( d * Dashboard List Item ) Has Id ( ) bool { if d ! = nil & & d . Id ! = nil { return true } return false } 
func ( d * Dashboard List Item ) Get Type ( ) string { if d = = nil | | d . Type = = nil { return " " } return * d . Type } 
func ( d * Dashboard List Item ) Has Type ( ) bool { if d ! = nil & & d . Type ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Created ( ) string { if d = = nil | | d . Created = = nil { return " " } return * d . Created } 
func ( d * Dashboard Lite ) Get Created Ok ( ) ( string , bool ) { if d = = nil | | d . Created = = nil { return " " , false } return * d . Created , true } 
func ( d * Dashboard Lite ) Has Created ( ) bool { if d ! = nil & & d . Created ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Created By ( ) Created By { if d = = nil | | d . Created By = = nil { return Created By { } } return * d . Created By } 
func ( d * Dashboard Lite ) Get Created By Ok ( ) ( Created By , bool ) { if d = = nil | | d . Created By = = nil { return Created By { } , false } return * d . Created By , true } 
func ( d * Dashboard Lite ) Has Created By ( ) bool { if d ! = nil & & d . Created By ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Description ( ) string { if d = = nil | | d . Description = = nil { return " " } return * d . Description } 
func ( d * Dashboard Lite ) Get Description Ok ( ) ( string , bool ) { if d = = nil | | d . Description = = nil { return " " , false } return * d . Description , true } 
func ( d * Dashboard Lite ) Has Description ( ) bool { if d ! = nil & & d . Description ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Id ( ) int { if d = = nil | | d . Id = = nil { return 0 } return * d . Id } 
func ( d * Dashboard Lite ) Has Id ( ) bool { if d ! = nil & & d . Id ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Modified ( ) string { if d = = nil | | d . Modified = = nil { return " " } return * d . Modified } 
func ( d * Dashboard Lite ) Get Modified Ok ( ) ( string , bool ) { if d = = nil | | d . Modified = = nil { return " " , false } return * d . Modified , true } 
func ( d * Dashboard Lite ) Has Modified ( ) bool { if d ! = nil & & d . Modified ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Read Only ( ) bool { if d = = nil | | d . Read Only = = nil { return false } return * d . Read Only } 
func ( d * Dashboard Lite ) Get Read Only Ok ( ) ( bool , bool ) { if d = = nil | | d . Read Only = = nil { return false , false } return * d . Read Only , true } 
func ( d * Dashboard Lite ) Has Read Only ( ) bool { if d ! = nil & & d . Read Only ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Resource ( ) string { if d = = nil | | d . Resource = = nil { return " " } return * d . Resource } 
func ( d * Dashboard Lite ) Get Resource Ok ( ) ( string , bool ) { if d = = nil | | d . Resource = = nil { return " " , false } return * d . Resource , true } 
func ( d * Dashboard Lite ) Has Resource ( ) bool { if d ! = nil & & d . Resource ! = nil { return true } return false } 
func ( d * Dashboard Lite ) Get Title ( ) string { if d = = nil | | d . Title = = nil { return " " } return * d . Title } 
func ( d * Dashboard Lite ) Get Title Ok ( ) ( string , bool ) { if d = = nil | | d . Title = = nil { return " " , false } return * d . Title , true } 
func ( d * Dashboard Lite ) Has Title ( ) bool { if d ! = nil & & d . Title ! = nil { return true } return false } 
func ( d * Distribution Definition ) Get Time ( ) Widget Time { if d = = nil | | d . Time = = nil { return Widget Time { } } return * d . Time } 
func ( d * Distribution Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if d = = nil | | d . Time = = nil { return Widget Time { } , false } return * d . Time , true } 
func ( d * Distribution Definition ) Has Time ( ) bool { if d ! = nil & & d . Time ! = nil { return true } return false } 
func ( d * Distribution Definition ) Get Title ( ) string { if d = = nil | | d . Title = = nil { return " " } return * d . Title } 
func ( d * Distribution Definition ) Has Title ( ) bool { if d ! = nil & & d . Title ! = nil { return true } return false } 
func ( d * Distribution Definition ) Get Title Align ( ) string { if d = = nil | | d . Title Align = = nil { return " " } return * d . Title Align } 
func ( d * Distribution Definition ) Get Title Align Ok ( ) ( string , bool ) { if d = = nil | | d . Title Align = = nil { return " " , false } return * d . Title Align , true } 
func ( d * Distribution Definition ) Has Title Align ( ) bool { if d ! = nil & & d . Title Align ! = nil { return true } return false } 
func ( d * Distribution Definition ) Get Title Size ( ) string { if d = = nil | | d . Title Size = = nil { return " " } return * d . Title Size } 
func ( d * Distribution Definition ) Get Title Size Ok ( ) ( string , bool ) { if d = = nil | | d . Title Size = = nil { return " " , false } return * d . Title Size , true } 
func ( d * Distribution Definition ) Has Title Size ( ) bool { if d ! = nil & & d . Title Size ! = nil { return true } return false } 
func ( d * Distribution Definition ) Get Type ( ) string { if d = = nil | | d . Type = = nil { return " " } return * d . Type } 
func ( d * Distribution Definition ) Get Type Ok ( ) ( string , bool ) { if d = = nil | | d . Type = = nil { return " " , false } return * d . Type , true } 
func ( d * Distribution Definition ) Has Type ( ) bool { if d ! = nil & & d . Type ! = nil { return true } return false } 
func ( d * Distribution Request ) Get Apm Query ( ) Widget Apm Or Log Query { if d = = nil | | d . Apm Query = = nil { return Widget Apm Or Log Query { } } return * d . Apm Query } 
func ( d * Distribution Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if d = = nil | | d . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * d . Apm Query , true } 
func ( d * Distribution Request ) Has Apm Query ( ) bool { if d ! = nil & & d . Apm Query ! = nil { return true } return false } 
func ( d * Distribution Request ) Get Log Query ( ) Widget Apm Or Log Query { if d = = nil | | d . Log Query = = nil { return Widget Apm Or Log Query { } } return * d . Log Query } 
func ( d * Distribution Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if d = = nil | | d . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * d . Log Query , true } 
func ( d * Distribution Request ) Has Log Query ( ) bool { if d ! = nil & & d . Log Query ! = nil { return true } return false } 
func ( d * Distribution Request ) Get Metric Query ( ) string { if d = = nil | | d . Metric Query = = nil { return " " } return * d . Metric Query } 
func ( d * Distribution Request ) Get Metric Query Ok ( ) ( string , bool ) { if d = = nil | | d . Metric Query = = nil { return " " , false } return * d . Metric Query , true } 
func ( d * Distribution Request ) Has Metric Query ( ) bool { if d ! = nil & & d . Metric Query ! = nil { return true } return false } 
func ( d * Distribution Request ) Get Process Query ( ) Widget Process Query { if d = = nil | | d . Process Query = = nil { return Widget Process Query { } } return * d . Process Query } 
func ( d * Distribution Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if d = = nil | | d . Process Query = = nil { return Widget Process Query { } , false } return * d . Process Query , true } 
func ( d * Distribution Request ) Has Process Query ( ) bool { if d ! = nil & & d . Process Query ! = nil { return true } return false } 
func ( d * Distribution Request ) Get Style ( ) Widget Request Style { if d = = nil | | d . Style = = nil { return Widget Request Style { } } return * d . Style } 
func ( d * Distribution Request ) Get Style Ok ( ) ( Widget Request Style , bool ) { if d = = nil | | d . Style = = nil { return Widget Request Style { } , false } return * d . Style , true } 
func ( d * Distribution Request ) Has Style ( ) bool { if d ! = nil & & d . Style ! = nil { return true } return false } 
func ( d * Downtime ) Get Active ( ) bool { if d = = nil | | d . Active = = nil { return false } return * d . Active } 
func ( d * Downtime ) Get Active Ok ( ) ( bool , bool ) { if d = = nil | | d . Active = = nil { return false , false } return * d . Active , true } 
func ( d * Downtime ) Has Active ( ) bool { if d ! = nil & & d . Active ! = nil { return true } return false } 
func ( d * Downtime ) Get Canceled ( ) int { if d = = nil | | d . Canceled = = nil { return 0 } return * d . Canceled } 
func ( d * Downtime ) Get Canceled Ok ( ) ( int , bool ) { if d = = nil | | d . Canceled = = nil { return 0 , false } return * d . Canceled , true } 
func ( d * Downtime ) Has Canceled ( ) bool { if d ! = nil & & d . Canceled ! = nil { return true } return false } 
func ( d * Downtime ) Get Disabled ( ) bool { if d = = nil | | d . Disabled = = nil { return false } return * d . Disabled } 
func ( d * Downtime ) Get Disabled Ok ( ) ( bool , bool ) { if d = = nil | | d . Disabled = = nil { return false , false } return * d . Disabled , true } 
func ( d * Downtime ) Has Disabled ( ) bool { if d ! = nil & & d . Disabled ! = nil { return true } return false } 
func ( d * Downtime ) Get End ( ) int { if d = = nil | | d . End = = nil { return 0 } return * d . End } 
func ( d * Downtime ) Get End Ok ( ) ( int , bool ) { if d = = nil | | d . End = = nil { return 0 , false } return * d . End , true } 
func ( d * Downtime ) Has End ( ) bool { if d ! = nil & & d . End ! = nil { return true } return false } 
func ( d * Downtime ) Get Id ( ) int { if d = = nil | | d . Id = = nil { return 0 } return * d . Id } 
func ( d * Downtime ) Has Id ( ) bool { if d ! = nil & & d . Id ! = nil { return true } return false } 
func ( d * Downtime ) Get Message ( ) string { if d = = nil | | d . Message = = nil { return " " } return * d . Message } 
func ( d * Downtime ) Get Message Ok ( ) ( string , bool ) { if d = = nil | | d . Message = = nil { return " " , false } return * d . Message , true } 
func ( d * Downtime ) Has Message ( ) bool { if d ! = nil & & d . Message ! = nil { return true } return false } 
func ( d * Downtime ) Get Monitor Id ( ) int { if d = = nil | | d . Monitor Id = = nil { return 0 } return * d . Monitor Id } 
func ( d * Downtime ) Get Monitor Id Ok ( ) ( int , bool ) { if d = = nil | | d . Monitor Id = = nil { return 0 , false } return * d . Monitor Id , true } 
func ( d * Downtime ) Has Monitor Id ( ) bool { if d ! = nil & & d . Monitor Id ! = nil { return true } return false } 
func ( d * Downtime ) Get Parent Id ( ) int { if d = = nil | | d . Parent Id = = nil { return 0 } return * d . Parent Id } 
func ( d * Downtime ) Get Parent Id Ok ( ) ( int , bool ) { if d = = nil | | d . Parent Id = = nil { return 0 , false } return * d . Parent Id , true } 
func ( d * Downtime ) Has Parent Id ( ) bool { if d ! = nil & & d . Parent Id ! = nil { return true } return false } 
func ( d * Downtime ) Get Recurrence ( ) Recurrence { if d = = nil | | d . Recurrence = = nil { return Recurrence { } } return * d . Recurrence } 
func ( d * Downtime ) Get Recurrence Ok ( ) ( Recurrence , bool ) { if d = = nil | | d . Recurrence = = nil { return Recurrence { } , false } return * d . Recurrence , true } 
func ( d * Downtime ) Has Recurrence ( ) bool { if d ! = nil & & d . Recurrence ! = nil { return true } return false } 
func ( d * Downtime ) Get Start ( ) int { if d = = nil | | d . Start = = nil { return 0 } return * d . Start } 
func ( d * Downtime ) Get Start Ok ( ) ( int , bool ) { if d = = nil | | d . Start = = nil { return 0 , false } return * d . Start , true } 
func ( d * Downtime ) Has Start ( ) bool { if d ! = nil & & d . Start ! = nil { return true } return false } 
func ( d * Downtime ) Get Timezone ( ) string { if d = = nil | | d . Timezone = = nil { return " " } return * d . Timezone } 
func ( d * Downtime ) Get Timezone Ok ( ) ( string , bool ) { if d = = nil | | d . Timezone = = nil { return " " , false } return * d . Timezone , true } 
func ( d * Downtime ) Has Timezone ( ) bool { if d ! = nil & & d . Timezone ! = nil { return true } return false } 
func ( e * Event ) Get Aggregation ( ) string { if e = = nil | | e . Aggregation = = nil { return " " } return * e . Aggregation } 
func ( e * Event ) Get Aggregation Ok ( ) ( string , bool ) { if e = = nil | | e . Aggregation = = nil { return " " , false } return * e . Aggregation , true } 
func ( e * Event ) Has Aggregation ( ) bool { if e ! = nil & & e . Aggregation ! = nil { return true } return false } 
func ( e * Event ) Get Alert Type ( ) string { if e = = nil | | e . Alert Type = = nil { return " " } return * e . Alert Type } 
func ( e * Event ) Get Alert Type Ok ( ) ( string , bool ) { if e = = nil | | e . Alert Type = = nil { return " " , false } return * e . Alert Type , true } 
func ( e * Event ) Has Alert Type ( ) bool { if e ! = nil & & e . Alert Type ! = nil { return true } return false } 
func ( e * Event ) Get Event Type ( ) string { if e = = nil | | e . Event Type = = nil { return " " } return * e . Event Type } 
func ( e * Event ) Get Event Type Ok ( ) ( string , bool ) { if e = = nil | | e . Event Type = = nil { return " " , false } return * e . Event Type , true } 
func ( e * Event ) Has Event Type ( ) bool { if e ! = nil & & e . Event Type ! = nil { return true } return false } 
func ( e * Event ) Get Host ( ) string { if e = = nil | | e . Host = = nil { return " " } return * e . Host } 
func ( e * Event ) Get Host Ok ( ) ( string , bool ) { if e = = nil | | e . Host = = nil { return " " , false } return * e . Host , true } 
func ( e * Event ) Has Host ( ) bool { if e ! = nil & & e . Host ! = nil { return true } return false } 
func ( e * Event ) Get Id ( ) int { if e = = nil | | e . Id = = nil { return 0 } return * e . Id } 
func ( e * Event ) Get Id Ok ( ) ( int , bool ) { if e = = nil | | e . Id = = nil { return 0 , false } return * e . Id , true } 
func ( e * Event ) Has Id ( ) bool { if e ! = nil & & e . Id ! = nil { return true } return false } 
func ( e * Event ) Get Priority ( ) string { if e = = nil | | e . Priority = = nil { return " " } return * e . Priority } 
func ( e * Event ) Get Priority Ok ( ) ( string , bool ) { if e = = nil | | e . Priority = = nil { return " " , false } return * e . Priority , true } 
func ( e * Event ) Has Priority ( ) bool { if e ! = nil & & e . Priority ! = nil { return true } return false } 
func ( e * Event ) Get Resource ( ) string { if e = = nil | | e . Resource = = nil { return " " } return * e . Resource } 
func ( e * Event ) Get Resource Ok ( ) ( string , bool ) { if e = = nil | | e . Resource = = nil { return " " , false } return * e . Resource , true } 
func ( e * Event ) Has Resource ( ) bool { if e ! = nil & & e . Resource ! = nil { return true } return false } 
func ( e * Event ) Get Source Type ( ) string { if e = = nil | | e . Source Type = = nil { return " " } return * e . Source Type } 
func ( e * Event ) Get Source Type Ok ( ) ( string , bool ) { if e = = nil | | e . Source Type = = nil { return " " , false } return * e . Source Type , true } 
func ( e * Event ) Has Source Type ( ) bool { if e ! = nil & & e . Source Type ! = nil { return true } return false } 
func ( e * Event ) Get Text ( ) string { if e = = nil | | e . Text = = nil { return " " } return * e . Text } 
func ( e * Event ) Get Text Ok ( ) ( string , bool ) { if e = = nil | | e . Text = = nil { return " " , false } return * e . Text , true } 
func ( e * Event ) Has Text ( ) bool { if e ! = nil & & e . Text ! = nil { return true } return false } 
func ( e * Event ) Get Time ( ) int { if e = = nil | | e . Time = = nil { return 0 } return * e . Time } 
func ( e * Event ) Get Time Ok ( ) ( int , bool ) { if e = = nil | | e . Time = = nil { return 0 , false } return * e . Time , true } 
func ( e * Event ) Has Time ( ) bool { if e ! = nil & & e . Time ! = nil { return true } return false } 
func ( e * Event ) Get Title ( ) string { if e = = nil | | e . Title = = nil { return " " } return * e . Title } 
func ( e * Event ) Has Title ( ) bool { if e ! = nil & & e . Title ! = nil { return true } return false } 
func ( e * Event ) Get Url ( ) string { if e = = nil | | e . Url = = nil { return " " } return * e . Url } 
func ( e * Event ) Get Url Ok ( ) ( string , bool ) { if e = = nil | | e . Url = = nil { return " " , false } return * e . Url , true } 
func ( e * Event ) Has Url ( ) bool { if e ! = nil & & e . Url ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Event Size ( ) string { if e = = nil | | e . Event Size = = nil { return " " } return * e . Event Size } 
func ( e * Event Stream Definition ) Get Event Size Ok ( ) ( string , bool ) { if e = = nil | | e . Event Size = = nil { return " " , false } return * e . Event Size , true } 
func ( e * Event Stream Definition ) Has Event Size ( ) bool { if e ! = nil & & e . Event Size ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Query ( ) string { if e = = nil | | e . Query = = nil { return " " } return * e . Query } 
func ( e * Event Stream Definition ) Get Query Ok ( ) ( string , bool ) { if e = = nil | | e . Query = = nil { return " " , false } return * e . Query , true } 
func ( e * Event Stream Definition ) Has Query ( ) bool { if e ! = nil & & e . Query ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Time ( ) Widget Time { if e = = nil | | e . Time = = nil { return Widget Time { } } return * e . Time } 
func ( e * Event Stream Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if e = = nil | | e . Time = = nil { return Widget Time { } , false } return * e . Time , true } 
func ( e * Event Stream Definition ) Has Time ( ) bool { if e ! = nil & & e . Time ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Title ( ) string { if e = = nil | | e . Title = = nil { return " " } return * e . Title } 
func ( e * Event Stream Definition ) Get Title Ok ( ) ( string , bool ) { if e = = nil | | e . Title = = nil { return " " , false } return * e . Title , true } 
func ( e * Event Stream Definition ) Has Title ( ) bool { if e ! = nil & & e . Title ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Title Align ( ) string { if e = = nil | | e . Title Align = = nil { return " " } return * e . Title Align } 
func ( e * Event Stream Definition ) Get Title Align Ok ( ) ( string , bool ) { if e = = nil | | e . Title Align = = nil { return " " , false } return * e . Title Align , true } 
func ( e * Event Stream Definition ) Has Title Align ( ) bool { if e ! = nil & & e . Title Align ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Title Size ( ) string { if e = = nil | | e . Title Size = = nil { return " " } return * e . Title Size } 
func ( e * Event Stream Definition ) Get Title Size Ok ( ) ( string , bool ) { if e = = nil | | e . Title Size = = nil { return " " , false } return * e . Title Size , true } 
func ( e * Event Stream Definition ) Has Title Size ( ) bool { if e ! = nil & & e . Title Size ! = nil { return true } return false } 
func ( e * Event Stream Definition ) Get Type ( ) string { if e = = nil | | e . Type = = nil { return " " } return * e . Type } 
func ( e * Event Stream Definition ) Get Type Ok ( ) ( string , bool ) { if e = = nil | | e . Type = = nil { return " " , false } return * e . Type , true } 
func ( e * Event Stream Definition ) Has Type ( ) bool { if e ! = nil & & e . Type ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Query ( ) string { if e = = nil | | e . Query = = nil { return " " } return * e . Query } 
func ( e * Event Timeline Definition ) Has Query ( ) bool { if e ! = nil & & e . Query ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Time ( ) Widget Time { if e = = nil | | e . Time = = nil { return Widget Time { } } return * e . Time } 
func ( e * Event Timeline Definition ) Has Time ( ) bool { if e ! = nil & & e . Time ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Title ( ) string { if e = = nil | | e . Title = = nil { return " " } return * e . Title } 
func ( e * Event Timeline Definition ) Has Title ( ) bool { if e ! = nil & & e . Title ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Title Align ( ) string { if e = = nil | | e . Title Align = = nil { return " " } return * e . Title Align } 
func ( e * Event Timeline Definition ) Has Title Align ( ) bool { if e ! = nil & & e . Title Align ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Title Size ( ) string { if e = = nil | | e . Title Size = = nil { return " " } return * e . Title Size } 
func ( e * Event Timeline Definition ) Has Title Size ( ) bool { if e ! = nil & & e . Title Size ! = nil { return true } return false } 
func ( e * Event Timeline Definition ) Get Type ( ) string { if e = = nil | | e . Type = = nil { return " " } return * e . Type } 
func ( e * Event Timeline Definition ) Has Type ( ) bool { if e ! = nil & & e . Type ! = nil { return true } return false } 
func ( f * Free Text Definition ) Get Color ( ) string { if f = = nil | | f . Color = = nil { return " " } return * f . Color } 
func ( f * Free Text Definition ) Get Color Ok ( ) ( string , bool ) { if f = = nil | | f . Color = = nil { return " " , false } return * f . Color , true } 
func ( f * Free Text Definition ) Has Color ( ) bool { if f ! = nil & & f . Color ! = nil { return true } return false } 
func ( f * Free Text Definition ) Get Font Size ( ) string { if f = = nil | | f . Font Size = = nil { return " " } return * f . Font Size } 
func ( f * Free Text Definition ) Get Font Size Ok ( ) ( string , bool ) { if f = = nil | | f . Font Size = = nil { return " " , false } return * f . Font Size , true } 
func ( f * Free Text Definition ) Has Font Size ( ) bool { if f ! = nil & & f . Font Size ! = nil { return true } return false } 
func ( f * Free Text Definition ) Get Text ( ) string { if f = = nil | | f . Text = = nil { return " " } return * f . Text } 
func ( f * Free Text Definition ) Get Text Ok ( ) ( string , bool ) { if f = = nil | | f . Text = = nil { return " " , false } return * f . Text , true } 
func ( f * Free Text Definition ) Has Text ( ) bool { if f ! = nil & & f . Text ! = nil { return true } return false } 
func ( f * Free Text Definition ) Get Text Align ( ) string { if f = = nil | | f . Text Align = = nil { return " " } return * f . Text Align } 
func ( f * Free Text Definition ) Get Text Align Ok ( ) ( string , bool ) { if f = = nil | | f . Text Align = = nil { return " " , false } return * f . Text Align , true } 
func ( f * Free Text Definition ) Has Text Align ( ) bool { if f ! = nil & & f . Text Align ! = nil { return true } return false } 
func ( f * Free Text Definition ) Get Type ( ) string { if f = = nil | | f . Type = = nil { return " " } return * f . Type } 
func ( f * Free Text Definition ) Get Type Ok ( ) ( string , bool ) { if f = = nil | | f . Type = = nil { return " " , false } return * f . Type , true } 
func ( f * Free Text Definition ) Has Type ( ) bool { if f ! = nil & & f . Type ! = nil { return true } return false } 
func ( g * Graph ) Get Definition ( ) Graph Definition { if g = = nil | | g . Definition = = nil { return Graph Definition { } } return * g . Definition } 
func ( g * Graph ) Get Definition Ok ( ) ( Graph Definition , bool ) { if g = = nil | | g . Definition = = nil { return Graph Definition { } , false } return * g . Definition , true } 
func ( g * Graph ) Has Definition ( ) bool { if g ! = nil & & g . Definition ! = nil { return true } return false } 
func ( g * Graph ) Get Title ( ) string { if g = = nil | | g . Title = = nil { return " " } return * g . Title } 
func ( g * Graph ) Get Title Ok ( ) ( string , bool ) { if g = = nil | | g . Title = = nil { return " " , false } return * g . Title , true } 
func ( g * Graph ) Has Title ( ) bool { if g ! = nil & & g . Title ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Autoscale ( ) bool { if g = = nil | | g . Autoscale = = nil { return false } return * g . Autoscale } 
func ( g * Graph Definition ) Get Autoscale Ok ( ) ( bool , bool ) { if g = = nil | | g . Autoscale = = nil { return false , false } return * g . Autoscale , true } 
func ( g * Graph Definition ) Has Autoscale ( ) bool { if g ! = nil & & g . Autoscale ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Custom Unit ( ) string { if g = = nil | | g . Custom Unit = = nil { return " " } return * g . Custom Unit } 
func ( g * Graph Definition ) Get Custom Unit Ok ( ) ( string , bool ) { if g = = nil | | g . Custom Unit = = nil { return " " , false } return * g . Custom Unit , true } 
func ( g * Graph Definition ) Has Custom Unit ( ) bool { if g ! = nil & & g . Custom Unit ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Include No Metric Hosts ( ) bool { if g = = nil | | g . Include No Metric Hosts = = nil { return false } return * g . Include No Metric Hosts } 
func ( g * Graph Definition ) Get Include No Metric Hosts Ok ( ) ( bool , bool ) { if g = = nil | | g . Include No Metric Hosts = = nil { return false , false } return * g . Include No Metric Hosts , true } 
func ( g * Graph Definition ) Has Include No Metric Hosts ( ) bool { if g ! = nil & & g . Include No Metric Hosts ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Include Ungrouped Hosts ( ) bool { if g = = nil | | g . Include Ungrouped Hosts = = nil { return false } return * g . Include Ungrouped Hosts } 
func ( g * Graph Definition ) Get Include Ungrouped Hosts Ok ( ) ( bool , bool ) { if g = = nil | | g . Include Ungrouped Hosts = = nil { return false , false } return * g . Include Ungrouped Hosts , true } 
func ( g * Graph Definition ) Has Include Ungrouped Hosts ( ) bool { if g ! = nil & & g . Include Ungrouped Hosts ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Node Type ( ) string { if g = = nil | | g . Node Type = = nil { return " " } return * g . Node Type } 
func ( g * Graph Definition ) Get Node Type Ok ( ) ( string , bool ) { if g = = nil | | g . Node Type = = nil { return " " , false } return * g . Node Type , true } 
func ( g * Graph Definition ) Has Node Type ( ) bool { if g ! = nil & & g . Node Type ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Precision ( ) Precision T { if g = = nil | | g . Precision = = nil { return " " } return * g . Precision } 
func ( g * Graph Definition ) Get Precision Ok ( ) ( Precision T , bool ) { if g = = nil | | g . Precision = = nil { return " " , false } return * g . Precision , true } 
func ( g * Graph Definition ) Has Precision ( ) bool { if g ! = nil & & g . Precision ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Style ( ) Style { if g = = nil | | g . Style = = nil { return Style { } } return * g . Style } 
func ( g * Graph Definition ) Get Style Ok ( ) ( Style , bool ) { if g = = nil | | g . Style = = nil { return Style { } , false } return * g . Style , true } 
func ( g * Graph Definition ) Has Style ( ) bool { if g ! = nil & & g . Style ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Text Align ( ) string { if g = = nil | | g . Text Align = = nil { return " " } return * g . Text Align } 
func ( g * Graph Definition ) Get Text Align Ok ( ) ( string , bool ) { if g = = nil | | g . Text Align = = nil { return " " , false } return * g . Text Align , true } 
func ( g * Graph Definition ) Has Text Align ( ) bool { if g ! = nil & & g . Text Align ! = nil { return true } return false } 
func ( g * Graph Definition ) Get Viz ( ) string { if g = = nil | | g . Viz = = nil { return " " } return * g . Viz } 
func ( g * Graph Definition ) Get Viz Ok ( ) ( string , bool ) { if g = = nil | | g . Viz = = nil { return " " , false } return * g . Viz , true } 
func ( g * Graph Definition ) Has Viz ( ) bool { if g ! = nil & & g . Viz ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Label ( ) string { if g = = nil | | g . Label = = nil { return " " } return * g . Label } 
func ( g * Graph Definition Marker ) Get Label Ok ( ) ( string , bool ) { if g = = nil | | g . Label = = nil { return " " , false } return * g . Label , true } 
func ( g * Graph Definition Marker ) Has Label ( ) bool { if g ! = nil & & g . Label ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Max ( ) json . Number { if g = = nil | | g . Max = = nil { return " " } return * g . Max } 
func ( g * Graph Definition Marker ) Get Max Ok ( ) ( json . Number , bool ) { if g = = nil | | g . Max = = nil { return " " , false } return * g . Max , true } 
func ( g * Graph Definition Marker ) Has Max ( ) bool { if g ! = nil & & g . Max ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Min ( ) json . Number { if g = = nil | | g . Min = = nil { return " " } return * g . Min } 
func ( g * Graph Definition Marker ) Get Min Ok ( ) ( json . Number , bool ) { if g = = nil | | g . Min = = nil { return " " , false } return * g . Min , true } 
func ( g * Graph Definition Marker ) Has Min ( ) bool { if g ! = nil & & g . Min ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Type ( ) string { if g = = nil | | g . Type = = nil { return " " } return * g . Type } 
func ( g * Graph Definition Marker ) Has Type ( ) bool { if g ! = nil & & g . Type ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Val ( ) json . Number { if g = = nil | | g . Val = = nil { return " " } return * g . Val } 
func ( g * Graph Definition Marker ) Get Val Ok ( ) ( json . Number , bool ) { if g = = nil | | g . Val = = nil { return " " , false } return * g . Val , true } 
func ( g * Graph Definition Marker ) Has Val ( ) bool { if g ! = nil & & g . Val ! = nil { return true } return false } 
func ( g * Graph Definition Marker ) Get Value ( ) string { if g = = nil | | g . Value = = nil { return " " } return * g . Value } 
func ( g * Graph Definition Marker ) Get Value Ok ( ) ( string , bool ) { if g = = nil | | g . Value = = nil { return " " , false } return * g . Value , true } 
func ( g * Graph Definition Marker ) Has Value ( ) bool { if g ! = nil & & g . Value ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Aggregator ( ) string { if g = = nil | | g . Aggregator = = nil { return " " } return * g . Aggregator } 
func ( g * Graph Definition Request ) Get Aggregator Ok ( ) ( string , bool ) { if g = = nil | | g . Aggregator = = nil { return " " , false } return * g . Aggregator , true } 
func ( g * Graph Definition Request ) Has Aggregator ( ) bool { if g ! = nil & & g . Aggregator ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Change Type ( ) string { if g = = nil | | g . Change Type = = nil { return " " } return * g . Change Type } 
func ( g * Graph Definition Request ) Get Change Type Ok ( ) ( string , bool ) { if g = = nil | | g . Change Type = = nil { return " " , false } return * g . Change Type , true } 
func ( g * Graph Definition Request ) Has Change Type ( ) bool { if g ! = nil & & g . Change Type ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Compare To ( ) string { if g = = nil | | g . Compare To = = nil { return " " } return * g . Compare To } 
func ( g * Graph Definition Request ) Get Compare To Ok ( ) ( string , bool ) { if g = = nil | | g . Compare To = = nil { return " " , false } return * g . Compare To , true } 
func ( g * Graph Definition Request ) Has Compare To ( ) bool { if g ! = nil & & g . Compare To ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Extra Col ( ) string { if g = = nil | | g . Extra Col = = nil { return " " } return * g . Extra Col } 
func ( g * Graph Definition Request ) Get Extra Col Ok ( ) ( string , bool ) { if g = = nil | | g . Extra Col = = nil { return " " , false } return * g . Extra Col , true } 
func ( g * Graph Definition Request ) Has Extra Col ( ) bool { if g ! = nil & & g . Extra Col ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Increase Good ( ) bool { if g = = nil | | g . Increase Good = = nil { return false } return * g . Increase Good } 
func ( g * Graph Definition Request ) Get Increase Good Ok ( ) ( bool , bool ) { if g = = nil | | g . Increase Good = = nil { return false , false } return * g . Increase Good , true } 
func ( g * Graph Definition Request ) Has Increase Good ( ) bool { if g ! = nil & & g . Increase Good ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Order By ( ) string { if g = = nil | | g . Order By = = nil { return " " } return * g . Order By } 
func ( g * Graph Definition Request ) Get Order By Ok ( ) ( string , bool ) { if g = = nil | | g . Order By = = nil { return " " , false } return * g . Order By , true } 
func ( g * Graph Definition Request ) Has Order By ( ) bool { if g ! = nil & & g . Order By ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Order Direction ( ) string { if g = = nil | | g . Order Direction = = nil { return " " } return * g . Order Direction } 
func ( g * Graph Definition Request ) Get Order Direction Ok ( ) ( string , bool ) { if g = = nil | | g . Order Direction = = nil { return " " , false } return * g . Order Direction , true } 
func ( g * Graph Definition Request ) Has Order Direction ( ) bool { if g ! = nil & & g . Order Direction ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Query ( ) string { if g = = nil | | g . Query = = nil { return " " } return * g . Query } 
func ( g * Graph Definition Request ) Has Query ( ) bool { if g ! = nil & & g . Query ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Stacked ( ) bool { if g = = nil | | g . Stacked = = nil { return false } return * g . Stacked } 
func ( g * Graph Definition Request ) Get Stacked Ok ( ) ( bool , bool ) { if g = = nil | | g . Stacked = = nil { return false , false } return * g . Stacked , true } 
func ( g * Graph Definition Request ) Has Stacked ( ) bool { if g ! = nil & & g . Stacked ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Style ( ) Graph Definition Request Style { if g = = nil | | g . Style = = nil { return Graph Definition Request Style { } } return * g . Style } 
func ( g * Graph Definition Request ) Get Style Ok ( ) ( Graph Definition Request Style , bool ) { if g = = nil | | g . Style = = nil { return Graph Definition Request Style { } , false } return * g . Style , true } 
func ( g * Graph Definition Request ) Has Style ( ) bool { if g ! = nil & & g . Style ! = nil { return true } return false } 
func ( g * Graph Definition Request ) Get Type ( ) string { if g = = nil | | g . Type = = nil { return " " } return * g . Type } 
func ( g * Graph Definition Request ) Get Type Ok ( ) ( string , bool ) { if g = = nil | | g . Type = = nil { return " " , false } return * g . Type , true } 
func ( g * Graph Definition Request ) Has Type ( ) bool { if g ! = nil & & g . Type ! = nil { return true } return false } 
func ( g * Graph Definition Request Style ) Get Palette ( ) string { if g = = nil | | g . Palette = = nil { return " " } return * g . Palette } 
func ( g * Graph Definition Request Style ) Get Palette Ok ( ) ( string , bool ) { if g = = nil | | g . Palette = = nil { return " " , false } return * g . Palette , true } 
func ( g * Graph Definition Request Style ) Has Palette ( ) bool { if g ! = nil & & g . Palette ! = nil { return true } return false } 
func ( g * Graph Definition Request Style ) Get Type ( ) string { if g = = nil | | g . Type = = nil { return " " } return * g . Type } 
func ( g * Graph Definition Request Style ) Has Type ( ) bool { if g ! = nil & & g . Type ! = nil { return true } return false } 
func ( g * Graph Definition Request Style ) Get Width ( ) string { if g = = nil | | g . Width = = nil { return " " } return * g . Width } 
func ( g * Graph Definition Request Style ) Get Width Ok ( ) ( string , bool ) { if g = = nil | | g . Width = = nil { return " " , false } return * g . Width , true } 
func ( g * Graph Definition Request Style ) Has Width ( ) bool { if g ! = nil & & g . Width ! = nil { return true } return false } 
func ( g * Graph Event ) Get Query ( ) string { if g = = nil | | g . Query = = nil { return " " } return * g . Query } 
func ( g * Graph Event ) Get Query Ok ( ) ( string , bool ) { if g = = nil | | g . Query = = nil { return " " , false } return * g . Query , true } 
func ( g * Graph Event ) Has Query ( ) bool { if g ! = nil & & g . Query ! = nil { return true } return false } 
func ( g * Group Data ) Get Last No Data Ts ( ) int { if g = = nil | | g . Last No Data Ts = = nil { return 0 } return * g . Last No Data Ts } 
func ( g * Group Data ) Get Last No Data Ts Ok ( ) ( int , bool ) { if g = = nil | | g . Last No Data Ts = = nil { return 0 , false } return * g . Last No Data Ts , true } 
func ( g * Group Data ) Has Last No Data Ts ( ) bool { if g ! = nil & & g . Last No Data Ts ! = nil { return true } return false } 
func ( g * Group Data ) Get Last Notified Ts ( ) int { if g = = nil | | g . Last Notified Ts = = nil { return 0 } return * g . Last Notified Ts } 
func ( g * Group Data ) Get Last Notified Ts Ok ( ) ( int , bool ) { if g = = nil | | g . Last Notified Ts = = nil { return 0 , false } return * g . Last Notified Ts , true } 
func ( g * Group Data ) Has Last Notified Ts ( ) bool { if g ! = nil & & g . Last Notified Ts ! = nil { return true } return false } 
func ( g * Group Data ) Get Last Resolved Ts ( ) int { if g = = nil | | g . Last Resolved Ts = = nil { return 0 } return * g . Last Resolved Ts } 
func ( g * Group Data ) Get Last Resolved Ts Ok ( ) ( int , bool ) { if g = = nil | | g . Last Resolved Ts = = nil { return 0 , false } return * g . Last Resolved Ts , true } 
func ( g * Group Data ) Has Last Resolved Ts ( ) bool { if g ! = nil & & g . Last Resolved Ts ! = nil { return true } return false } 
func ( g * Group Data ) Get Last Triggered Ts ( ) int { if g = = nil | | g . Last Triggered Ts = = nil { return 0 } return * g . Last Triggered Ts } 
func ( g * Group Data ) Get Last Triggered Ts Ok ( ) ( int , bool ) { if g = = nil | | g . Last Triggered Ts = = nil { return 0 , false } return * g . Last Triggered Ts , true } 
func ( g * Group Data ) Has Last Triggered Ts ( ) bool { if g ! = nil & & g . Last Triggered Ts ! = nil { return true } return false } 
func ( g * Group Data ) Get Name ( ) string { if g = = nil | | g . Name = = nil { return " " } return * g . Name } 
func ( g * Group Data ) Get Name Ok ( ) ( string , bool ) { if g = = nil | | g . Name = = nil { return " " , false } return * g . Name , true } 
func ( g * Group Data ) Has Name ( ) bool { if g ! = nil & & g . Name ! = nil { return true } return false } 
func ( g * Group Data ) Get Status ( ) string { if g = = nil | | g . Status = = nil { return " " } return * g . Status } 
func ( g * Group Data ) Get Status Ok ( ) ( string , bool ) { if g = = nil | | g . Status = = nil { return " " , false } return * g . Status , true } 
func ( g * Group Data ) Has Status ( ) bool { if g ! = nil & & g . Status ! = nil { return true } return false } 
func ( g * Group Data ) Get Triggering Value ( ) Triggering Value { if g = = nil | | g . Triggering Value = = nil { return Triggering Value { } } return * g . Triggering Value } 
func ( g * Group Data ) Get Triggering Value Ok ( ) ( Triggering Value , bool ) { if g = = nil | | g . Triggering Value = = nil { return Triggering Value { } , false } return * g . Triggering Value , true } 
func ( g * Group Data ) Has Triggering Value ( ) bool { if g ! = nil & & g . Triggering Value ! = nil { return true } return false } 
func ( g * Group Definition ) Get Layout Type ( ) string { if g = = nil | | g . Layout Type = = nil { return " " } return * g . Layout Type } 
func ( g * Group Definition ) Get Layout Type Ok ( ) ( string , bool ) { if g = = nil | | g . Layout Type = = nil { return " " , false } return * g . Layout Type , true } 
func ( g * Group Definition ) Has Layout Type ( ) bool { if g ! = nil & & g . Layout Type ! = nil { return true } return false } 
func ( g * Group Definition ) Get Title ( ) string { if g = = nil | | g . Title = = nil { return " " } return * g . Title } 
func ( g * Group Definition ) Has Title ( ) bool { if g ! = nil & & g . Title ! = nil { return true } return false } 
func ( g * Group Definition ) Get Type ( ) string { if g = = nil | | g . Type = = nil { return " " } return * g . Type } 
func ( g * Group Definition ) Has Type ( ) bool { if g ! = nil & & g . Type ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Time ( ) Widget Time { if h = = nil | | h . Time = = nil { return Widget Time { } } return * h . Time } 
func ( h * Heatmap Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if h = = nil | | h . Time = = nil { return Widget Time { } , false } return * h . Time , true } 
func ( h * Heatmap Definition ) Has Time ( ) bool { if h ! = nil & & h . Time ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Title ( ) string { if h = = nil | | h . Title = = nil { return " " } return * h . Title } 
func ( h * Heatmap Definition ) Get Title Ok ( ) ( string , bool ) { if h = = nil | | h . Title = = nil { return " " , false } return * h . Title , true } 
func ( h * Heatmap Definition ) Has Title ( ) bool { if h ! = nil & & h . Title ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Title Align ( ) string { if h = = nil | | h . Title Align = = nil { return " " } return * h . Title Align } 
func ( h * Heatmap Definition ) Has Title Align ( ) bool { if h ! = nil & & h . Title Align ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Title Size ( ) string { if h = = nil | | h . Title Size = = nil { return " " } return * h . Title Size } 
func ( h * Heatmap Definition ) Has Title Size ( ) bool { if h ! = nil & & h . Title Size ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Type ( ) string { if h = = nil | | h . Type = = nil { return " " } return * h . Type } 
func ( h * Heatmap Definition ) Get Type Ok ( ) ( string , bool ) { if h = = nil | | h . Type = = nil { return " " , false } return * h . Type , true } 
func ( h * Heatmap Definition ) Has Type ( ) bool { if h ! = nil & & h . Type ! = nil { return true } return false } 
func ( h * Heatmap Definition ) Get Yaxis ( ) Widget Axis { if h = = nil | | h . Yaxis = = nil { return Widget Axis { } } return * h . Yaxis } 
func ( h * Heatmap Definition ) Get Yaxis Ok ( ) ( Widget Axis , bool ) { if h = = nil | | h . Yaxis = = nil { return Widget Axis { } , false } return * h . Yaxis , true } 
func ( h * Heatmap Definition ) Has Yaxis ( ) bool { if h ! = nil & & h . Yaxis ! = nil { return true } return false } 
func ( h * Heatmap Request ) Get Apm Query ( ) Widget Apm Or Log Query { if h = = nil | | h . Apm Query = = nil { return Widget Apm Or Log Query { } } return * h . Apm Query } 
func ( h * Heatmap Request ) Has Apm Query ( ) bool { if h ! = nil & & h . Apm Query ! = nil { return true } return false } 
func ( h * Heatmap Request ) Get Log Query ( ) Widget Apm Or Log Query { if h = = nil | | h . Log Query = = nil { return Widget Apm Or Log Query { } } return * h . Log Query } 
func ( h * Heatmap Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if h = = nil | | h . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * h . Log Query , true } 
func ( h * Heatmap Request ) Has Log Query ( ) bool { if h ! = nil & & h . Log Query ! = nil { return true } return false } 
func ( h * Heatmap Request ) Get Metric Query ( ) string { if h = = nil | | h . Metric Query = = nil { return " " } return * h . Metric Query } 
func ( h * Heatmap Request ) Has Metric Query ( ) bool { if h ! = nil & & h . Metric Query ! = nil { return true } return false } 
func ( h * Heatmap Request ) Get Process Query ( ) Widget Process Query { if h = = nil | | h . Process Query = = nil { return Widget Process Query { } } return * h . Process Query } 
func ( h * Heatmap Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if h = = nil | | h . Process Query = = nil { return Widget Process Query { } , false } return * h . Process Query , true } 
func ( h * Heatmap Request ) Has Process Query ( ) bool { if h ! = nil & & h . Process Query ! = nil { return true } return false } 
func ( h * Heatmap Request ) Get Style ( ) Widget Request Style { if h = = nil | | h . Style = = nil { return Widget Request Style { } } return * h . Style } 
func ( h * Heatmap Request ) Get Style Ok ( ) ( Widget Request Style , bool ) { if h = = nil | | h . Style = = nil { return Widget Request Style { } , false } return * h . Style , true } 
func ( h * Heatmap Request ) Has Style ( ) bool { if h ! = nil & & h . Style ! = nil { return true } return false } 
func ( h * Host Action Mute ) Get End Time ( ) string { if h = = nil | | h . End Time = = nil { return " " } return * h . End Time } 
func ( h * Host Action Mute ) Get End Time Ok ( ) ( string , bool ) { if h = = nil | | h . End Time = = nil { return " " , false } return * h . End Time , true } 
func ( h * Host Action Mute ) Has End Time ( ) bool { if h ! = nil & & h . End Time ! = nil { return true } return false } 
func ( h * Host Action Mute ) Get Message ( ) string { if h = = nil | | h . Message = = nil { return " " } return * h . Message } 
func ( h * Host Action Mute ) Get Message Ok ( ) ( string , bool ) { if h = = nil | | h . Message = = nil { return " " , false } return * h . Message , true } 
func ( h * Host Action Mute ) Has Message ( ) bool { if h ! = nil & & h . Message ! = nil { return true } return false } 
func ( h * Host Action Mute ) Get Override ( ) bool { if h = = nil | | h . Override = = nil { return false } return * h . Override } 
func ( h * Host Action Mute ) Get Override Ok ( ) ( bool , bool ) { if h = = nil | | h . Override = = nil { return false , false } return * h . Override , true } 
func ( h * Host Action Mute ) Has Override ( ) bool { if h ! = nil & & h . Override ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Node Type ( ) string { if h = = nil | | h . Node Type = = nil { return " " } return * h . Node Type } 
func ( h * Hostmap Definition ) Get Node Type Ok ( ) ( string , bool ) { if h = = nil | | h . Node Type = = nil { return " " , false } return * h . Node Type , true } 
func ( h * Hostmap Definition ) Has Node Type ( ) bool { if h ! = nil & & h . Node Type ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get No Group Hosts ( ) bool { if h = = nil | | h . No Group Hosts = = nil { return false } return * h . No Group Hosts } 
func ( h * Hostmap Definition ) Get No Group Hosts Ok ( ) ( bool , bool ) { if h = = nil | | h . No Group Hosts = = nil { return false , false } return * h . No Group Hosts , true } 
func ( h * Hostmap Definition ) Has No Group Hosts ( ) bool { if h ! = nil & & h . No Group Hosts ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get No Metric Hosts ( ) bool { if h = = nil | | h . No Metric Hosts = = nil { return false } return * h . No Metric Hosts } 
func ( h * Hostmap Definition ) Get No Metric Hosts Ok ( ) ( bool , bool ) { if h = = nil | | h . No Metric Hosts = = nil { return false , false } return * h . No Metric Hosts , true } 
func ( h * Hostmap Definition ) Has No Metric Hosts ( ) bool { if h ! = nil & & h . No Metric Hosts ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Requests ( ) Hostmap Requests { if h = = nil | | h . Requests = = nil { return Hostmap Requests { } } return * h . Requests } 
func ( h * Hostmap Definition ) Get Requests Ok ( ) ( Hostmap Requests , bool ) { if h = = nil | | h . Requests = = nil { return Hostmap Requests { } , false } return * h . Requests , true } 
func ( h * Hostmap Definition ) Has Requests ( ) bool { if h ! = nil & & h . Requests ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Style ( ) Hostmap Style { if h = = nil | | h . Style = = nil { return Hostmap Style { } } return * h . Style } 
func ( h * Hostmap Definition ) Get Style Ok ( ) ( Hostmap Style , bool ) { if h = = nil | | h . Style = = nil { return Hostmap Style { } , false } return * h . Style , true } 
func ( h * Hostmap Definition ) Has Style ( ) bool { if h ! = nil & & h . Style ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Title ( ) string { if h = = nil | | h . Title = = nil { return " " } return * h . Title } 
func ( h * Hostmap Definition ) Has Title ( ) bool { if h ! = nil & & h . Title ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Title Align ( ) string { if h = = nil | | h . Title Align = = nil { return " " } return * h . Title Align } 
func ( h * Hostmap Definition ) Get Title Align Ok ( ) ( string , bool ) { if h = = nil | | h . Title Align = = nil { return " " , false } return * h . Title Align , true } 
func ( h * Hostmap Definition ) Has Title Align ( ) bool { if h ! = nil & & h . Title Align ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Title Size ( ) string { if h = = nil | | h . Title Size = = nil { return " " } return * h . Title Size } 
func ( h * Hostmap Definition ) Get Title Size Ok ( ) ( string , bool ) { if h = = nil | | h . Title Size = = nil { return " " , false } return * h . Title Size , true } 
func ( h * Hostmap Definition ) Has Title Size ( ) bool { if h ! = nil & & h . Title Size ! = nil { return true } return false } 
func ( h * Hostmap Definition ) Get Type ( ) string { if h = = nil | | h . Type = = nil { return " " } return * h . Type } 
func ( h * Hostmap Definition ) Has Type ( ) bool { if h ! = nil & & h . Type ! = nil { return true } return false } 
func ( h * Hostmap Request ) Get Apm Query ( ) Widget Apm Or Log Query { if h = = nil | | h . Apm Query = = nil { return Widget Apm Or Log Query { } } return * h . Apm Query } 
func ( h * Hostmap Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if h = = nil | | h . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * h . Apm Query , true } 
func ( h * Hostmap Request ) Has Apm Query ( ) bool { if h ! = nil & & h . Apm Query ! = nil { return true } return false } 
func ( h * Hostmap Request ) Get Log Query ( ) Widget Apm Or Log Query { if h = = nil | | h . Log Query = = nil { return Widget Apm Or Log Query { } } return * h . Log Query } 
func ( h * Hostmap Request ) Has Log Query ( ) bool { if h ! = nil & & h . Log Query ! = nil { return true } return false } 
func ( h * Hostmap Request ) Get Metric Query ( ) string { if h = = nil | | h . Metric Query = = nil { return " " } return * h . Metric Query } 
func ( h * Hostmap Request ) Get Metric Query Ok ( ) ( string , bool ) { if h = = nil | | h . Metric Query = = nil { return " " , false } return * h . Metric Query , true } 
func ( h * Hostmap Request ) Has Metric Query ( ) bool { if h ! = nil & & h . Metric Query ! = nil { return true } return false } 
func ( h * Hostmap Request ) Get Process Query ( ) Widget Process Query { if h = = nil | | h . Process Query = = nil { return Widget Process Query { } } return * h . Process Query } 
func ( h * Hostmap Request ) Has Process Query ( ) bool { if h ! = nil & & h . Process Query ! = nil { return true } return false } 
func ( h * Hostmap Requests ) Get Fill ( ) Hostmap Request { if h = = nil | | h . Fill = = nil { return Hostmap Request { } } return * h . Fill } 
func ( h * Hostmap Requests ) Get Fill Ok ( ) ( Hostmap Request , bool ) { if h = = nil | | h . Fill = = nil { return Hostmap Request { } , false } return * h . Fill , true } 
func ( h * Hostmap Requests ) Has Fill ( ) bool { if h ! = nil & & h . Fill ! = nil { return true } return false } 
func ( h * Hostmap Requests ) Get Size ( ) Hostmap Request { if h = = nil | | h . Size = = nil { return Hostmap Request { } } return * h . Size } 
func ( h * Hostmap Requests ) Get Size Ok ( ) ( Hostmap Request , bool ) { if h = = nil | | h . Size = = nil { return Hostmap Request { } , false } return * h . Size , true } 
func ( h * Hostmap Requests ) Has Size ( ) bool { if h ! = nil & & h . Size ! = nil { return true } return false } 
func ( h * Hostmap Style ) Get Fill Max ( ) string { if h = = nil | | h . Fill Max = = nil { return " " } return * h . Fill Max } 
func ( h * Hostmap Style ) Get Fill Max Ok ( ) ( string , bool ) { if h = = nil | | h . Fill Max = = nil { return " " , false } return * h . Fill Max , true } 
func ( h * Hostmap Style ) Has Fill Max ( ) bool { if h ! = nil & & h . Fill Max ! = nil { return true } return false } 
func ( h * Hostmap Style ) Get Fill Min ( ) string { if h = = nil | | h . Fill Min = = nil { return " " } return * h . Fill Min } 
func ( h * Hostmap Style ) Get Fill Min Ok ( ) ( string , bool ) { if h = = nil | | h . Fill Min = = nil { return " " , false } return * h . Fill Min , true } 
func ( h * Hostmap Style ) Has Fill Min ( ) bool { if h ! = nil & & h . Fill Min ! = nil { return true } return false } 
func ( h * Hostmap Style ) Get Palette ( ) string { if h = = nil | | h . Palette = = nil { return " " } return * h . Palette } 
func ( h * Hostmap Style ) Get Palette Ok ( ) ( string , bool ) { if h = = nil | | h . Palette = = nil { return " " , false } return * h . Palette , true } 
func ( h * Hostmap Style ) Has Palette ( ) bool { if h ! = nil & & h . Palette ! = nil { return true } return false } 
func ( h * Hostmap Style ) Get Palette Flip ( ) bool { if h = = nil | | h . Palette Flip = = nil { return false } return * h . Palette Flip } 
func ( h * Hostmap Style ) Get Palette Flip Ok ( ) ( bool , bool ) { if h = = nil | | h . Palette Flip = = nil { return false , false } return * h . Palette Flip , true } 
func ( h * Hostmap Style ) Has Palette Flip ( ) bool { if h ! = nil & & h . Palette Flip ! = nil { return true } return false } 
func ( i * Iframe Definition ) Get Type ( ) string { if i = = nil | | i . Type = = nil { return " " } return * i . Type } 
func ( i * Iframe Definition ) Get Type Ok ( ) ( string , bool ) { if i = = nil | | i . Type = = nil { return " " , false } return * i . Type , true } 
func ( i * Iframe Definition ) Has Type ( ) bool { if i ! = nil & & i . Type ! = nil { return true } return false } 
func ( i * Iframe Definition ) Get Url ( ) string { if i = = nil | | i . Url = = nil { return " " } return * i . Url } 
func ( i * Iframe Definition ) Has Url ( ) bool { if i ! = nil & & i . Url ! = nil { return true } return false } 
func ( i * Image Definition ) Get Margin ( ) string { if i = = nil | | i . Margin = = nil { return " " } return * i . Margin } 
func ( i * Image Definition ) Get Margin Ok ( ) ( string , bool ) { if i = = nil | | i . Margin = = nil { return " " , false } return * i . Margin , true } 
func ( i * Image Definition ) Has Margin ( ) bool { if i ! = nil & & i . Margin ! = nil { return true } return false } 
func ( i * Image Definition ) Get Sizing ( ) string { if i = = nil | | i . Sizing = = nil { return " " } return * i . Sizing } 
func ( i * Image Definition ) Get Sizing Ok ( ) ( string , bool ) { if i = = nil | | i . Sizing = = nil { return " " , false } return * i . Sizing , true } 
func ( i * Image Definition ) Has Sizing ( ) bool { if i ! = nil & & i . Sizing ! = nil { return true } return false } 
func ( i * Image Definition ) Get Type ( ) string { if i = = nil | | i . Type = = nil { return " " } return * i . Type } 
func ( i * Image Definition ) Has Type ( ) bool { if i ! = nil & & i . Type ! = nil { return true } return false } 
func ( i * Image Definition ) Get Url ( ) string { if i = = nil | | i . Url = = nil { return " " } return * i . Url } 
func ( i * Image Definition ) Get Url Ok ( ) ( string , bool ) { if i = = nil | | i . Url = = nil { return " " , false } return * i . Url , true } 
func ( i * Image Definition ) Has Url ( ) bool { if i ! = nil & & i . Url ! = nil { return true } return false } 
func ( i * Integration AWSAccount ) Get Account ID ( ) string { if i = = nil | | i . Account ID = = nil { return " " } return * i . Account ID } 
func ( i * Integration AWSAccount ) Has Account ID ( ) bool { if i ! = nil & & i . Account ID ! = nil { return true } return false } 
func ( i * Integration AWSAccount ) Get Role Name ( ) string { if i = = nil | | i . Role Name = = nil { return " " } return * i . Role Name } 
func ( i * Integration AWSAccount ) Get Role Name Ok ( ) ( string , bool ) { if i = = nil | | i . Role Name = = nil { return " " , false } return * i . Role Name , true } 
func ( i * Integration AWSAccount ) Has Role Name ( ) bool { if i ! = nil & & i . Role Name ! = nil { return true } return false } 
func ( i * Integration AWSAccount Delete Request ) Get Account ID ( ) string { if i = = nil | | i . Account ID = = nil { return " " } return * i . Account ID } 
func ( i * Integration AWSAccount Delete Request ) Get Account IDOk ( ) ( string , bool ) { if i = = nil | | i . Account ID = = nil { return " " , false } return * i . Account ID , true } 
func ( i * Integration AWSAccount Delete Request ) Has Account ID ( ) bool { if i ! = nil & & i . Account ID ! = nil { return true } return false } 
func ( i * Integration AWSAccount Delete Request ) Get Role Name ( ) string { if i = = nil | | i . Role Name = = nil { return " " } return * i . Role Name } 
func ( i * Integration AWSAccount Delete Request ) Has Role Name ( ) bool { if i ! = nil & & i . Role Name ! = nil { return true } return false } 
func ( i * Integration GCP ) Get Client Email ( ) string { if i = = nil | | i . Client Email = = nil { return " " } return * i . Client Email } 
func ( i * Integration GCP ) Has Client Email ( ) bool { if i ! = nil & & i . Client Email ! = nil { return true } return false } 
func ( i * Integration GCP ) Get Host Filters ( ) string { if i = = nil | | i . Host Filters = = nil { return " " } return * i . Host Filters } 
func ( i * Integration GCP ) Has Host Filters ( ) bool { if i ! = nil & & i . Host Filters ! = nil { return true } return false } 
func ( i * Integration GCP ) Get Project ID ( ) string { if i = = nil | | i . Project ID = = nil { return " " } return * i . Project ID } 
func ( i * Integration GCP ) Has Project ID ( ) bool { if i ! = nil & & i . Project ID ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Auth Provider X 5 0 9Cert URL ( ) string { if i = = nil | | i . Auth Provider X 5 0 9Cert URL = = nil { return " " } return * i . Auth Provider X 5 0 9Cert URL } 
func ( i * Integration GCPCreate Request ) Get Auth Provider X 5 0 9Cert URLOk ( ) ( string , bool ) { if i = = nil | | i . Auth Provider X 5 0 9Cert URL = = nil { return " " , false } return * i . Auth Provider X 5 0 9Cert URL , true } 
func ( i * Integration GCPCreate Request ) Has Auth Provider X 5 0 9Cert URL ( ) bool { if i ! = nil & & i . Auth Provider X 5 0 9Cert URL ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Auth URI ( ) string { if i = = nil | | i . Auth URI = = nil { return " " } return * i . Auth URI } 
func ( i * Integration GCPCreate Request ) Get Auth URIOk ( ) ( string , bool ) { if i = = nil | | i . Auth URI = = nil { return " " , false } return * i . Auth URI , true } 
func ( i * Integration GCPCreate Request ) Has Auth URI ( ) bool { if i ! = nil & & i . Auth URI ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Client Email ( ) string { if i = = nil | | i . Client Email = = nil { return " " } return * i . Client Email } 
func ( i * Integration GCPCreate Request ) Has Client Email ( ) bool { if i ! = nil & & i . Client Email ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Client ID ( ) string { if i = = nil | | i . Client ID = = nil { return " " } return * i . Client ID } 
func ( i * Integration GCPCreate Request ) Get Client IDOk ( ) ( string , bool ) { if i = = nil | | i . Client ID = = nil { return " " , false } return * i . Client ID , true } 
func ( i * Integration GCPCreate Request ) Has Client ID ( ) bool { if i ! = nil & & i . Client ID ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Client X 5 0 9Cert URL ( ) string { if i = = nil | | i . Client X 5 0 9Cert URL = = nil { return " " } return * i . Client X 5 0 9Cert URL } 
func ( i * Integration GCPCreate Request ) Get Client X 5 0 9Cert URLOk ( ) ( string , bool ) { if i = = nil | | i . Client X 5 0 9Cert URL = = nil { return " " , false } return * i . Client X 5 0 9Cert URL , true } 
func ( i * Integration GCPCreate Request ) Has Client X 5 0 9Cert URL ( ) bool { if i ! = nil & & i . Client X 5 0 9Cert URL ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Host Filters ( ) string { if i = = nil | | i . Host Filters = = nil { return " " } return * i . Host Filters } 
func ( i * Integration GCPCreate Request ) Get Host Filters Ok ( ) ( string , bool ) { if i = = nil | | i . Host Filters = = nil { return " " , false } return * i . Host Filters , true } 
func ( i * Integration GCPCreate Request ) Has Host Filters ( ) bool { if i ! = nil & & i . Host Filters ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Private Key ( ) string { if i = = nil | | i . Private Key = = nil { return " " } return * i . Private Key } 
func ( i * Integration GCPCreate Request ) Get Private Key Ok ( ) ( string , bool ) { if i = = nil | | i . Private Key = = nil { return " " , false } return * i . Private Key , true } 
func ( i * Integration GCPCreate Request ) Has Private Key ( ) bool { if i ! = nil & & i . Private Key ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Private Key ID ( ) string { if i = = nil | | i . Private Key ID = = nil { return " " } return * i . Private Key ID } 
func ( i * Integration GCPCreate Request ) Get Private Key IDOk ( ) ( string , bool ) { if i = = nil | | i . Private Key ID = = nil { return " " , false } return * i . Private Key ID , true } 
func ( i * Integration GCPCreate Request ) Has Private Key ID ( ) bool { if i ! = nil & & i . Private Key ID ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Project ID ( ) string { if i = = nil | | i . Project ID = = nil { return " " } return * i . Project ID } 
func ( i * Integration GCPCreate Request ) Has Project ID ( ) bool { if i ! = nil & & i . Project ID ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Token URI ( ) string { if i = = nil | | i . Token URI = = nil { return " " } return * i . Token URI } 
func ( i * Integration GCPCreate Request ) Get Token URIOk ( ) ( string , bool ) { if i = = nil | | i . Token URI = = nil { return " " , false } return * i . Token URI , true } 
func ( i * Integration GCPCreate Request ) Has Token URI ( ) bool { if i ! = nil & & i . Token URI ! = nil { return true } return false } 
func ( i * Integration GCPCreate Request ) Get Type ( ) string { if i = = nil | | i . Type = = nil { return " " } return * i . Type } 
func ( i * Integration GCPCreate Request ) Has Type ( ) bool { if i ! = nil & & i . Type ! = nil { return true } return false } 
func ( i * Integration GCPDelete Request ) Get Client Email ( ) string { if i = = nil | | i . Client Email = = nil { return " " } return * i . Client Email } 
func ( i * Integration GCPDelete Request ) Get Client Email Ok ( ) ( string , bool ) { if i = = nil | | i . Client Email = = nil { return " " , false } return * i . Client Email , true } 
func ( i * Integration GCPDelete Request ) Has Client Email ( ) bool { if i ! = nil & & i . Client Email ! = nil { return true } return false } 
func ( i * Integration GCPDelete Request ) Get Project ID ( ) string { if i = = nil | | i . Project ID = = nil { return " " } return * i . Project ID } 
func ( i * Integration GCPDelete Request ) Has Project ID ( ) bool { if i ! = nil & & i . Project ID ! = nil { return true } return false } 
func ( i * Integration GCPUpdate Request ) Get Client Email ( ) string { if i = = nil | | i . Client Email = = nil { return " " } return * i . Client Email } 
func ( i * Integration GCPUpdate Request ) Has Client Email ( ) bool { if i ! = nil & & i . Client Email ! = nil { return true } return false } 
func ( i * Integration GCPUpdate Request ) Get Host Filters ( ) string { if i = = nil | | i . Host Filters = = nil { return " " } return * i . Host Filters } 
func ( i * Integration GCPUpdate Request ) Has Host Filters ( ) bool { if i ! = nil & & i . Host Filters ! = nil { return true } return false } 
func ( i * Integration GCPUpdate Request ) Get Project ID ( ) string { if i = = nil | | i . Project ID = = nil { return " " } return * i . Project ID } 
func ( i * Integration GCPUpdate Request ) Get Project IDOk ( ) ( string , bool ) { if i = = nil | | i . Project ID = = nil { return " " , false } return * i . Project ID , true } 
func ( i * Integration GCPUpdate Request ) Has Project ID ( ) bool { if i ! = nil & & i . Project ID ! = nil { return true } return false } 
func ( i * integration PD ) Get APIToken ( ) string { if i = = nil | | i . APIToken = = nil { return " " } return * i . APIToken } 
func ( i * integration PD ) Get APIToken Ok ( ) ( string , bool ) { if i = = nil | | i . APIToken = = nil { return " " , false } return * i . APIToken , true } 
func ( i * integration PD ) Has APIToken ( ) bool { if i ! = nil & & i . APIToken ! = nil { return true } return false } 
func ( i * integration PD ) Get Subdomain ( ) string { if i = = nil | | i . Subdomain = = nil { return " " } return * i . Subdomain } 
func ( i * integration PD ) Get Subdomain Ok ( ) ( string , bool ) { if i = = nil | | i . Subdomain = = nil { return " " , false } return * i . Subdomain , true } 
func ( i * integration PD ) Has Subdomain ( ) bool { if i ! = nil & & i . Subdomain ! = nil { return true } return false } 
func ( i * Integration PDRequest ) Get APIToken ( ) string { if i = = nil | | i . APIToken = = nil { return " " } return * i . APIToken } 
func ( i * Integration PDRequest ) Has APIToken ( ) bool { if i ! = nil & & i . APIToken ! = nil { return true } return false } 
func ( i * Integration PDRequest ) Get Run Check ( ) bool { if i = = nil | | i . Run Check = = nil { return false } return * i . Run Check } 
func ( i * Integration PDRequest ) Get Run Check Ok ( ) ( bool , bool ) { if i = = nil | | i . Run Check = = nil { return false , false } return * i . Run Check , true } 
func ( i * Integration PDRequest ) Has Run Check ( ) bool { if i ! = nil & & i . Run Check ! = nil { return true } return false } 
func ( i * Integration PDRequest ) Get Subdomain ( ) string { if i = = nil | | i . Subdomain = = nil { return " " } return * i . Subdomain } 
func ( i * Integration PDRequest ) Has Subdomain ( ) bool { if i ! = nil & & i . Subdomain ! = nil { return true } return false } 
func ( i * Integration Slack Request ) Get Run Check ( ) bool { if i = = nil | | i . Run Check = = nil { return false } return * i . Run Check } 
func ( i * Integration Slack Request ) Get Run Check Ok ( ) ( bool , bool ) { if i = = nil | | i . Run Check = = nil { return false , false } return * i . Run Check , true } 
func ( i * Integration Slack Request ) Has Run Check ( ) bool { if i ! = nil & & i . Run Check ! = nil { return true } return false } 
func ( l * Log Set ) Get ID ( ) json . Number { if l = = nil | | l . ID = = nil { return " " } return * l . ID } 
func ( l * Log Set ) Get IDOk ( ) ( json . Number , bool ) { if l = = nil | | l . ID = = nil { return " " , false } return * l . ID , true } 
func ( l * Log Set ) Has ID ( ) bool { if l ! = nil & & l . ID ! = nil { return true } return false } 
func ( l * Log Set ) Get Name ( ) string { if l = = nil | | l . Name = = nil { return " " } return * l . Name } 
func ( l * Log Set ) Get Name Ok ( ) ( string , bool ) { if l = = nil | | l . Name = = nil { return " " , false } return * l . Name , true } 
func ( l * Log Set ) Has Name ( ) bool { if l ! = nil & & l . Name ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Logset ( ) string { if l = = nil | | l . Logset = = nil { return " " } return * l . Logset } 
func ( l * Log Stream Definition ) Get Logset Ok ( ) ( string , bool ) { if l = = nil | | l . Logset = = nil { return " " , false } return * l . Logset , true } 
func ( l * Log Stream Definition ) Has Logset ( ) bool { if l ! = nil & & l . Logset ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Query ( ) string { if l = = nil | | l . Query = = nil { return " " } return * l . Query } 
func ( l * Log Stream Definition ) Get Query Ok ( ) ( string , bool ) { if l = = nil | | l . Query = = nil { return " " , false } return * l . Query , true } 
func ( l * Log Stream Definition ) Has Query ( ) bool { if l ! = nil & & l . Query ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Time ( ) Widget Time { if l = = nil | | l . Time = = nil { return Widget Time { } } return * l . Time } 
func ( l * Log Stream Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if l = = nil | | l . Time = = nil { return Widget Time { } , false } return * l . Time , true } 
func ( l * Log Stream Definition ) Has Time ( ) bool { if l ! = nil & & l . Time ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Title ( ) string { if l = = nil | | l . Title = = nil { return " " } return * l . Title } 
func ( l * Log Stream Definition ) Get Title Ok ( ) ( string , bool ) { if l = = nil | | l . Title = = nil { return " " , false } return * l . Title , true } 
func ( l * Log Stream Definition ) Has Title ( ) bool { if l ! = nil & & l . Title ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Title Align ( ) string { if l = = nil | | l . Title Align = = nil { return " " } return * l . Title Align } 
func ( l * Log Stream Definition ) Get Title Align Ok ( ) ( string , bool ) { if l = = nil | | l . Title Align = = nil { return " " , false } return * l . Title Align , true } 
func ( l * Log Stream Definition ) Has Title Align ( ) bool { if l ! = nil & & l . Title Align ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Title Size ( ) string { if l = = nil | | l . Title Size = = nil { return " " } return * l . Title Size } 
func ( l * Log Stream Definition ) Get Title Size Ok ( ) ( string , bool ) { if l = = nil | | l . Title Size = = nil { return " " , false } return * l . Title Size , true } 
func ( l * Log Stream Definition ) Has Title Size ( ) bool { if l ! = nil & & l . Title Size ! = nil { return true } return false } 
func ( l * Log Stream Definition ) Get Type ( ) string { if l = = nil | | l . Type = = nil { return " " } return * l . Type } 
func ( l * Log Stream Definition ) Get Type Ok ( ) ( string , bool ) { if l = = nil | | l . Type = = nil { return " " , false } return * l . Type , true } 
func ( l * Log Stream Definition ) Has Type ( ) bool { if l ! = nil & & l . Type ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Color Preference ( ) string { if m = = nil | | m . Color Preference = = nil { return " " } return * m . Color Preference } 
func ( m * Manage Status Definition ) Get Color Preference Ok ( ) ( string , bool ) { if m = = nil | | m . Color Preference = = nil { return " " , false } return * m . Color Preference , true } 
func ( m * Manage Status Definition ) Has Color Preference ( ) bool { if m ! = nil & & m . Color Preference ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Count ( ) int { if m = = nil | | m . Count = = nil { return 0 } return * m . Count } 
func ( m * Manage Status Definition ) Get Count Ok ( ) ( int , bool ) { if m = = nil | | m . Count = = nil { return 0 , false } return * m . Count , true } 
func ( m * Manage Status Definition ) Has Count ( ) bool { if m ! = nil & & m . Count ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Display Format ( ) string { if m = = nil | | m . Display Format = = nil { return " " } return * m . Display Format } 
func ( m * Manage Status Definition ) Get Display Format Ok ( ) ( string , bool ) { if m = = nil | | m . Display Format = = nil { return " " , false } return * m . Display Format , true } 
func ( m * Manage Status Definition ) Has Display Format ( ) bool { if m ! = nil & & m . Display Format ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Hide Zero Counts ( ) bool { if m = = nil | | m . Hide Zero Counts = = nil { return false } return * m . Hide Zero Counts } 
func ( m * Manage Status Definition ) Get Hide Zero Counts Ok ( ) ( bool , bool ) { if m = = nil | | m . Hide Zero Counts = = nil { return false , false } return * m . Hide Zero Counts , true } 
func ( m * Manage Status Definition ) Has Hide Zero Counts ( ) bool { if m ! = nil & & m . Hide Zero Counts ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Query ( ) string { if m = = nil | | m . Query = = nil { return " " } return * m . Query } 
func ( m * Manage Status Definition ) Get Query Ok ( ) ( string , bool ) { if m = = nil | | m . Query = = nil { return " " , false } return * m . Query , true } 
func ( m * Manage Status Definition ) Has Query ( ) bool { if m ! = nil & & m . Query ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Sort ( ) string { if m = = nil | | m . Sort = = nil { return " " } return * m . Sort } 
func ( m * Manage Status Definition ) Get Sort Ok ( ) ( string , bool ) { if m = = nil | | m . Sort = = nil { return " " , false } return * m . Sort , true } 
func ( m * Manage Status Definition ) Has Sort ( ) bool { if m ! = nil & & m . Sort ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Start ( ) int { if m = = nil | | m . Start = = nil { return 0 } return * m . Start } 
func ( m * Manage Status Definition ) Get Start Ok ( ) ( int , bool ) { if m = = nil | | m . Start = = nil { return 0 , false } return * m . Start , true } 
func ( m * Manage Status Definition ) Has Start ( ) bool { if m ! = nil & & m . Start ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Title ( ) string { if m = = nil | | m . Title = = nil { return " " } return * m . Title } 
func ( m * Manage Status Definition ) Get Title Ok ( ) ( string , bool ) { if m = = nil | | m . Title = = nil { return " " , false } return * m . Title , true } 
func ( m * Manage Status Definition ) Has Title ( ) bool { if m ! = nil & & m . Title ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Title Align ( ) string { if m = = nil | | m . Title Align = = nil { return " " } return * m . Title Align } 
func ( m * Manage Status Definition ) Get Title Align Ok ( ) ( string , bool ) { if m = = nil | | m . Title Align = = nil { return " " , false } return * m . Title Align , true } 
func ( m * Manage Status Definition ) Has Title Align ( ) bool { if m ! = nil & & m . Title Align ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Title Size ( ) string { if m = = nil | | m . Title Size = = nil { return " " } return * m . Title Size } 
func ( m * Manage Status Definition ) Get Title Size Ok ( ) ( string , bool ) { if m = = nil | | m . Title Size = = nil { return " " , false } return * m . Title Size , true } 
func ( m * Manage Status Definition ) Has Title Size ( ) bool { if m ! = nil & & m . Title Size ! = nil { return true } return false } 
func ( m * Manage Status Definition ) Get Type ( ) string { if m = = nil | | m . Type = = nil { return " " } return * m . Type } 
func ( m * Manage Status Definition ) Get Type Ok ( ) ( string , bool ) { if m = = nil | | m . Type = = nil { return " " , false } return * m . Type , true } 
func ( m * Manage Status Definition ) Has Type ( ) bool { if m ! = nil & & m . Type ! = nil { return true } return false } 
func ( m * Metric ) Get Host ( ) string { if m = = nil | | m . Host = = nil { return " " } return * m . Host } 
func ( m * Metric ) Get Host Ok ( ) ( string , bool ) { if m = = nil | | m . Host = = nil { return " " , false } return * m . Host , true } 
func ( m * Metric ) Has Host ( ) bool { if m ! = nil & & m . Host ! = nil { return true } return false } 
func ( m * Metric ) Get Metric ( ) string { if m = = nil | | m . Metric = = nil { return " " } return * m . Metric } 
func ( m * Metric ) Get Metric Ok ( ) ( string , bool ) { if m = = nil | | m . Metric = = nil { return " " , false } return * m . Metric , true } 
func ( m * Metric ) Has Metric ( ) bool { if m ! = nil & & m . Metric ! = nil { return true } return false } 
func ( m * Metric ) Get Type ( ) string { if m = = nil | | m . Type = = nil { return " " } return * m . Type } 
func ( m * Metric ) Has Type ( ) bool { if m ! = nil & & m . Type ! = nil { return true } return false } 
func ( m * Metric ) Get Unit ( ) string { if m = = nil | | m . Unit = = nil { return " " } return * m . Unit } 
func ( m * Metric ) Has Unit ( ) bool { if m ! = nil & & m . Unit ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Description ( ) string { if m = = nil | | m . Description = = nil { return " " } return * m . Description } 
func ( m * Metric Metadata ) Get Description Ok ( ) ( string , bool ) { if m = = nil | | m . Description = = nil { return " " , false } return * m . Description , true } 
func ( m * Metric Metadata ) Has Description ( ) bool { if m ! = nil & & m . Description ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Per Unit ( ) string { if m = = nil | | m . Per Unit = = nil { return " " } return * m . Per Unit } 
func ( m * Metric Metadata ) Get Per Unit Ok ( ) ( string , bool ) { if m = = nil | | m . Per Unit = = nil { return " " , false } return * m . Per Unit , true } 
func ( m * Metric Metadata ) Has Per Unit ( ) bool { if m ! = nil & & m . Per Unit ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Short Name ( ) string { if m = = nil | | m . Short Name = = nil { return " " } return * m . Short Name } 
func ( m * Metric Metadata ) Get Short Name Ok ( ) ( string , bool ) { if m = = nil | | m . Short Name = = nil { return " " , false } return * m . Short Name , true } 
func ( m * Metric Metadata ) Has Short Name ( ) bool { if m ! = nil & & m . Short Name ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Statsd Interval ( ) int { if m = = nil | | m . Statsd Interval = = nil { return 0 } return * m . Statsd Interval } 
func ( m * Metric Metadata ) Get Statsd Interval Ok ( ) ( int , bool ) { if m = = nil | | m . Statsd Interval = = nil { return 0 , false } return * m . Statsd Interval , true } 
func ( m * Metric Metadata ) Has Statsd Interval ( ) bool { if m ! = nil & & m . Statsd Interval ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Type ( ) string { if m = = nil | | m . Type = = nil { return " " } return * m . Type } 
func ( m * Metric Metadata ) Has Type ( ) bool { if m ! = nil & & m . Type ! = nil { return true } return false } 
func ( m * Metric Metadata ) Get Unit ( ) string { if m = = nil | | m . Unit = = nil { return " " } return * m . Unit } 
func ( m * Metric Metadata ) Get Unit Ok ( ) ( string , bool ) { if m = = nil | | m . Unit = = nil { return " " , false } return * m . Unit , true } 
func ( m * Metric Metadata ) Has Unit ( ) bool { if m ! = nil & & m . Unit ! = nil { return true } return false } 
func ( m * Monitor ) Get Creator ( ) Creator { if m = = nil | | m . Creator = = nil { return Creator { } } return * m . Creator } 
func ( m * Monitor ) Get Creator Ok ( ) ( Creator , bool ) { if m = = nil | | m . Creator = = nil { return Creator { } , false } return * m . Creator , true } 
func ( m * Monitor ) Has Creator ( ) bool { if m ! = nil & & m . Creator ! = nil { return true } return false } 
func ( m * Monitor ) Get Id ( ) int { if m = = nil | | m . Id = = nil { return 0 } return * m . Id } 
func ( m * Monitor ) Get Id Ok ( ) ( int , bool ) { if m = = nil | | m . Id = = nil { return 0 , false } return * m . Id , true } 
func ( m * Monitor ) Has Id ( ) bool { if m ! = nil & & m . Id ! = nil { return true } return false } 
func ( m * Monitor ) Get Message ( ) string { if m = = nil | | m . Message = = nil { return " " } return * m . Message } 
func ( m * Monitor ) Get Message Ok ( ) ( string , bool ) { if m = = nil | | m . Message = = nil { return " " , false } return * m . Message , true } 
func ( m * Monitor ) Has Message ( ) bool { if m ! = nil & & m . Message ! = nil { return true } return false } 
func ( m * Monitor ) Get Name ( ) string { if m = = nil | | m . Name = = nil { return " " } return * m . Name } 
func ( m * Monitor ) Get Name Ok ( ) ( string , bool ) { if m = = nil | | m . Name = = nil { return " " , false } return * m . Name , true } 
func ( m * Monitor ) Has Name ( ) bool { if m ! = nil & & m . Name ! = nil { return true } return false } 
func ( m * Monitor ) Get Options ( ) Options { if m = = nil | | m . Options = = nil { return Options { } } return * m . Options } 
func ( m * Monitor ) Get Options Ok ( ) ( Options , bool ) { if m = = nil | | m . Options = = nil { return Options { } , false } return * m . Options , true } 
func ( m * Monitor ) Has Options ( ) bool { if m ! = nil & & m . Options ! = nil { return true } return false } 
func ( m * Monitor ) Get Overall State ( ) string { if m = = nil | | m . Overall State = = nil { return " " } return * m . Overall State } 
func ( m * Monitor ) Get Overall State Ok ( ) ( string , bool ) { if m = = nil | | m . Overall State = = nil { return " " , false } return * m . Overall State , true } 
func ( m * Monitor ) Has Overall State ( ) bool { if m ! = nil & & m . Overall State ! = nil { return true } return false } 
func ( m * Monitor ) Get Overall State Modified ( ) string { if m = = nil | | m . Overall State Modified = = nil { return " " } return * m . Overall State Modified } 
func ( m * Monitor ) Get Overall State Modified Ok ( ) ( string , bool ) { if m = = nil | | m . Overall State Modified = = nil { return " " , false } return * m . Overall State Modified , true } 
func ( m * Monitor ) Has Overall State Modified ( ) bool { if m ! = nil & & m . Overall State Modified ! = nil { return true } return false } 
func ( m * Monitor ) Get Query ( ) string { if m = = nil | | m . Query = = nil { return " " } return * m . Query } 
func ( m * Monitor ) Has Query ( ) bool { if m ! = nil & & m . Query ! = nil { return true } return false } 
func ( m * Monitor ) Get Type ( ) string { if m = = nil | | m . Type = = nil { return " " } return * m . Type } 
func ( m * Monitor ) Has Type ( ) bool { if m ! = nil & & m . Type ! = nil { return true } return false } 
func ( n * Note Definition ) Get Background Color ( ) string { if n = = nil | | n . Background Color = = nil { return " " } return * n . Background Color } 
func ( n * Note Definition ) Get Background Color Ok ( ) ( string , bool ) { if n = = nil | | n . Background Color = = nil { return " " , false } return * n . Background Color , true } 
func ( n * Note Definition ) Has Background Color ( ) bool { if n ! = nil & & n . Background Color ! = nil { return true } return false } 
func ( n * Note Definition ) Get Content ( ) string { if n = = nil | | n . Content = = nil { return " " } return * n . Content } 
func ( n * Note Definition ) Get Content Ok ( ) ( string , bool ) { if n = = nil | | n . Content = = nil { return " " , false } return * n . Content , true } 
func ( n * Note Definition ) Has Content ( ) bool { if n ! = nil & & n . Content ! = nil { return true } return false } 
func ( n * Note Definition ) Get Font Size ( ) string { if n = = nil | | n . Font Size = = nil { return " " } return * n . Font Size } 
func ( n * Note Definition ) Get Font Size Ok ( ) ( string , bool ) { if n = = nil | | n . Font Size = = nil { return " " , false } return * n . Font Size , true } 
func ( n * Note Definition ) Has Font Size ( ) bool { if n ! = nil & & n . Font Size ! = nil { return true } return false } 
func ( n * Note Definition ) Get Show Tick ( ) bool { if n = = nil | | n . Show Tick = = nil { return false } return * n . Show Tick } 
func ( n * Note Definition ) Get Show Tick Ok ( ) ( bool , bool ) { if n = = nil | | n . Show Tick = = nil { return false , false } return * n . Show Tick , true } 
func ( n * Note Definition ) Has Show Tick ( ) bool { if n ! = nil & & n . Show Tick ! = nil { return true } return false } 
func ( n * Note Definition ) Get Text Align ( ) string { if n = = nil | | n . Text Align = = nil { return " " } return * n . Text Align } 
func ( n * Note Definition ) Get Text Align Ok ( ) ( string , bool ) { if n = = nil | | n . Text Align = = nil { return " " , false } return * n . Text Align , true } 
func ( n * Note Definition ) Has Text Align ( ) bool { if n ! = nil & & n . Text Align ! = nil { return true } return false } 
func ( n * Note Definition ) Get Tick Edge ( ) string { if n = = nil | | n . Tick Edge = = nil { return " " } return * n . Tick Edge } 
func ( n * Note Definition ) Get Tick Edge Ok ( ) ( string , bool ) { if n = = nil | | n . Tick Edge = = nil { return " " , false } return * n . Tick Edge , true } 
func ( n * Note Definition ) Has Tick Edge ( ) bool { if n ! = nil & & n . Tick Edge ! = nil { return true } return false } 
func ( n * Note Definition ) Get Tick Pos ( ) string { if n = = nil | | n . Tick Pos = = nil { return " " } return * n . Tick Pos } 
func ( n * Note Definition ) Get Tick Pos Ok ( ) ( string , bool ) { if n = = nil | | n . Tick Pos = = nil { return " " , false } return * n . Tick Pos , true } 
func ( n * Note Definition ) Has Tick Pos ( ) bool { if n ! = nil & & n . Tick Pos ! = nil { return true } return false } 
func ( n * Note Definition ) Get Type ( ) string { if n = = nil | | n . Type = = nil { return " " } return * n . Type } 
func ( n * Note Definition ) Get Type Ok ( ) ( string , bool ) { if n = = nil | | n . Type = = nil { return " " , false } return * n . Type , true } 
func ( n * Note Definition ) Has Type ( ) bool { if n ! = nil & & n . Type ! = nil { return true } return false } 
func ( o * Options ) Get Enable Logs Sample ( ) bool { if o = = nil | | o . Enable Logs Sample = = nil { return false } return * o . Enable Logs Sample } 
func ( o * Options ) Get Enable Logs Sample Ok ( ) ( bool , bool ) { if o = = nil | | o . Enable Logs Sample = = nil { return false , false } return * o . Enable Logs Sample , true } 
func ( o * Options ) Has Enable Logs Sample ( ) bool { if o ! = nil & & o . Enable Logs Sample ! = nil { return true } return false } 
func ( o * Options ) Get Escalation Message ( ) string { if o = = nil | | o . Escalation Message = = nil { return " " } return * o . Escalation Message } 
func ( o * Options ) Get Escalation Message Ok ( ) ( string , bool ) { if o = = nil | | o . Escalation Message = = nil { return " " , false } return * o . Escalation Message , true } 
func ( o * Options ) Has Escalation Message ( ) bool { if o ! = nil & & o . Escalation Message ! = nil { return true } return false } 
func ( o * Options ) Get Evaluation Delay ( ) int { if o = = nil | | o . Evaluation Delay = = nil { return 0 } return * o . Evaluation Delay } 
func ( o * Options ) Get Evaluation Delay Ok ( ) ( int , bool ) { if o = = nil | | o . Evaluation Delay = = nil { return 0 , false } return * o . Evaluation Delay , true } 
func ( o * Options ) Has Evaluation Delay ( ) bool { if o ! = nil & & o . Evaluation Delay ! = nil { return true } return false } 
func ( o * Options ) Get Include Tags ( ) bool { if o = = nil | | o . Include Tags = = nil { return false } return * o . Include Tags } 
func ( o * Options ) Get Include Tags Ok ( ) ( bool , bool ) { if o = = nil | | o . Include Tags = = nil { return false , false } return * o . Include Tags , true } 
func ( o * Options ) Has Include Tags ( ) bool { if o ! = nil & & o . Include Tags ! = nil { return true } return false } 
func ( o * Options ) Get Locked ( ) bool { if o = = nil | | o . Locked = = nil { return false } return * o . Locked } 
func ( o * Options ) Get Locked Ok ( ) ( bool , bool ) { if o = = nil | | o . Locked = = nil { return false , false } return * o . Locked , true } 
func ( o * Options ) Has Locked ( ) bool { if o ! = nil & & o . Locked ! = nil { return true } return false } 
func ( o * Options ) Get New Host Delay ( ) int { if o = = nil | | o . New Host Delay = = nil { return 0 } return * o . New Host Delay } 
func ( o * Options ) Get New Host Delay Ok ( ) ( int , bool ) { if o = = nil | | o . New Host Delay = = nil { return 0 , false } return * o . New Host Delay , true } 
func ( o * Options ) Has New Host Delay ( ) bool { if o ! = nil & & o . New Host Delay ! = nil { return true } return false } 
func ( o * Options ) Get Notify Audit ( ) bool { if o = = nil | | o . Notify Audit = = nil { return false } return * o . Notify Audit } 
func ( o * Options ) Get Notify Audit Ok ( ) ( bool , bool ) { if o = = nil | | o . Notify Audit = = nil { return false , false } return * o . Notify Audit , true } 
func ( o * Options ) Has Notify Audit ( ) bool { if o ! = nil & & o . Notify Audit ! = nil { return true } return false } 
func ( o * Options ) Get Notify No Data ( ) bool { if o = = nil | | o . Notify No Data = = nil { return false } return * o . Notify No Data } 
func ( o * Options ) Get Notify No Data Ok ( ) ( bool , bool ) { if o = = nil | | o . Notify No Data = = nil { return false , false } return * o . Notify No Data , true } 
func ( o * Options ) Has Notify No Data ( ) bool { if o ! = nil & & o . Notify No Data ! = nil { return true } return false } 
func ( o * Options ) Get Query Config ( ) Query Config { if o = = nil | | o . Query Config = = nil { return Query Config { } } return * o . Query Config } 
func ( o * Options ) Get Query Config Ok ( ) ( Query Config , bool ) { if o = = nil | | o . Query Config = = nil { return Query Config { } , false } return * o . Query Config , true } 
func ( o * Options ) Has Query Config ( ) bool { if o ! = nil & & o . Query Config ! = nil { return true } return false } 
func ( o * Options ) Get Renotify Interval ( ) int { if o = = nil | | o . Renotify Interval = = nil { return 0 } return * o . Renotify Interval } 
func ( o * Options ) Get Renotify Interval Ok ( ) ( int , bool ) { if o = = nil | | o . Renotify Interval = = nil { return 0 , false } return * o . Renotify Interval , true } 
func ( o * Options ) Has Renotify Interval ( ) bool { if o ! = nil & & o . Renotify Interval ! = nil { return true } return false } 
func ( o * Options ) Get Require Full Window ( ) bool { if o = = nil | | o . Require Full Window = = nil { return false } return * o . Require Full Window } 
func ( o * Options ) Get Require Full Window Ok ( ) ( bool , bool ) { if o = = nil | | o . Require Full Window = = nil { return false , false } return * o . Require Full Window , true } 
func ( o * Options ) Has Require Full Window ( ) bool { if o ! = nil & & o . Require Full Window ! = nil { return true } return false } 
func ( o * Options ) Get Thresholds ( ) Threshold Count { if o = = nil | | o . Thresholds = = nil { return Threshold Count { } } return * o . Thresholds } 
func ( o * Options ) Get Thresholds Ok ( ) ( Threshold Count , bool ) { if o = = nil | | o . Thresholds = = nil { return Threshold Count { } , false } return * o . Thresholds , true } 
func ( o * Options ) Has Thresholds ( ) bool { if o ! = nil & & o . Thresholds ! = nil { return true } return false } 
func ( o * Options ) Get Threshold Windows ( ) Threshold Windows { if o = = nil | | o . Threshold Windows = = nil { return Threshold Windows { } } return * o . Threshold Windows } 
func ( o * Options ) Get Threshold Windows Ok ( ) ( Threshold Windows , bool ) { if o = = nil | | o . Threshold Windows = = nil { return Threshold Windows { } , false } return * o . Threshold Windows , true } 
func ( o * Options ) Has Threshold Windows ( ) bool { if o ! = nil & & o . Threshold Windows ! = nil { return true } return false } 
func ( o * Options ) Get Timeout H ( ) int { if o = = nil | | o . Timeout H = = nil { return 0 } return * o . Timeout H } 
func ( o * Options ) Get Timeout HOk ( ) ( int , bool ) { if o = = nil | | o . Timeout H = = nil { return 0 , false } return * o . Timeout H , true } 
func ( o * Options ) Has Timeout H ( ) bool { if o ! = nil & & o . Timeout H ! = nil { return true } return false } 
func ( p * Params ) Get Count ( ) string { if p = = nil | | p . Count = = nil { return " " } return * p . Count } 
func ( p * Params ) Get Count Ok ( ) ( string , bool ) { if p = = nil | | p . Count = = nil { return " " , false } return * p . Count , true } 
func ( p * Params ) Has Count ( ) bool { if p ! = nil & & p . Count ! = nil { return true } return false } 
func ( p * Params ) Get Sort ( ) string { if p = = nil | | p . Sort = = nil { return " " } return * p . Sort } 
func ( p * Params ) Get Sort Ok ( ) ( string , bool ) { if p = = nil | | p . Sort = = nil { return " " , false } return * p . Sort , true } 
func ( p * Params ) Has Sort ( ) bool { if p ! = nil & & p . Sort ! = nil { return true } return false } 
func ( p * Params ) Get Start ( ) string { if p = = nil | | p . Start = = nil { return " " } return * p . Start } 
func ( p * Params ) Get Start Ok ( ) ( string , bool ) { if p = = nil | | p . Start = = nil { return " " , false } return * p . Start , true } 
func ( p * Params ) Has Start ( ) bool { if p ! = nil & & p . Start ! = nil { return true } return false } 
func ( p * Params ) Get Text ( ) string { if p = = nil | | p . Text = = nil { return " " } return * p . Text } 
func ( p * Params ) Has Text ( ) bool { if p ! = nil & & p . Text ! = nil { return true } return false } 
func ( p * Period ) Get Name ( ) string { if p = = nil | | p . Name = = nil { return " " } return * p . Name } 
func ( p * Period ) Get Name Ok ( ) ( string , bool ) { if p = = nil | | p . Name = = nil { return " " , false } return * p . Name , true } 
func ( p * Period ) Has Name ( ) bool { if p ! = nil & & p . Name ! = nil { return true } return false } 
func ( p * Period ) Get Seconds ( ) json . Number { if p = = nil | | p . Seconds = = nil { return " " } return * p . Seconds } 
func ( p * Period ) Get Seconds Ok ( ) ( json . Number , bool ) { if p = = nil | | p . Seconds = = nil { return " " , false } return * p . Seconds , true } 
func ( p * Period ) Has Seconds ( ) bool { if p ! = nil & & p . Seconds ! = nil { return true } return false } 
func ( p * Period ) Get Text ( ) string { if p = = nil | | p . Text = = nil { return " " } return * p . Text } 
func ( p * Period ) Get Text Ok ( ) ( string , bool ) { if p = = nil | | p . Text = = nil { return " " , false } return * p . Text , true } 
func ( p * Period ) Has Text ( ) bool { if p ! = nil & & p . Text ! = nil { return true } return false } 
func ( p * Period ) Get Unit ( ) string { if p = = nil | | p . Unit = = nil { return " " } return * p . Unit } 
func ( p * Period ) Get Unit Ok ( ) ( string , bool ) { if p = = nil | | p . Unit = = nil { return " " , false } return * p . Unit , true } 
func ( p * Period ) Has Unit ( ) bool { if p ! = nil & & p . Unit ! = nil { return true } return false } 
func ( p * Period ) Get Value ( ) string { if p = = nil | | p . Value = = nil { return " " } return * p . Value } 
func ( p * Period ) Get Value Ok ( ) ( string , bool ) { if p = = nil | | p . Value = = nil { return " " , false } return * p . Value , true } 
func ( p * Period ) Has Value ( ) bool { if p ! = nil & & p . Value ! = nil { return true } return false } 
func ( q * Query Config ) Get Log Set ( ) Log Set { if q = = nil | | q . Log Set = = nil { return Log Set { } } return * q . Log Set } 
func ( q * Query Config ) Get Log Set Ok ( ) ( Log Set , bool ) { if q = = nil | | q . Log Set = = nil { return Log Set { } , false } return * q . Log Set , true } 
func ( q * Query Config ) Has Log Set ( ) bool { if q ! = nil & & q . Log Set ! = nil { return true } return false } 
func ( q * Query Config ) Get Query Is Failed ( ) bool { if q = = nil | | q . Query Is Failed = = nil { return false } return * q . Query Is Failed } 
func ( q * Query Config ) Get Query Is Failed Ok ( ) ( bool , bool ) { if q = = nil | | q . Query Is Failed = = nil { return false , false } return * q . Query Is Failed , true } 
func ( q * Query Config ) Has Query Is Failed ( ) bool { if q ! = nil & & q . Query Is Failed ! = nil { return true } return false } 
func ( q * Query Config ) Get Query String ( ) string { if q = = nil | | q . Query String = = nil { return " " } return * q . Query String } 
func ( q * Query Config ) Get Query String Ok ( ) ( string , bool ) { if q = = nil | | q . Query String = = nil { return " " , false } return * q . Query String , true } 
func ( q * Query Config ) Has Query String ( ) bool { if q ! = nil & & q . Query String ! = nil { return true } return false } 
func ( q * Query Config ) Get Time Range ( ) Time Range { if q = = nil | | q . Time Range = = nil { return Time Range { } } return * q . Time Range } 
func ( q * Query Config ) Get Time Range Ok ( ) ( Time Range , bool ) { if q = = nil | | q . Time Range = = nil { return Time Range { } , false } return * q . Time Range , true } 
func ( q * Query Config ) Has Time Range ( ) bool { if q ! = nil & & q . Time Range ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Autoscale ( ) bool { if q = = nil | | q . Autoscale = = nil { return false } return * q . Autoscale } 
func ( q * Query Value Definition ) Get Autoscale Ok ( ) ( bool , bool ) { if q = = nil | | q . Autoscale = = nil { return false , false } return * q . Autoscale , true } 
func ( q * Query Value Definition ) Has Autoscale ( ) bool { if q ! = nil & & q . Autoscale ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Custom Unit ( ) string { if q = = nil | | q . Custom Unit = = nil { return " " } return * q . Custom Unit } 
func ( q * Query Value Definition ) Get Custom Unit Ok ( ) ( string , bool ) { if q = = nil | | q . Custom Unit = = nil { return " " , false } return * q . Custom Unit , true } 
func ( q * Query Value Definition ) Has Custom Unit ( ) bool { if q ! = nil & & q . Custom Unit ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Precision ( ) int { if q = = nil | | q . Precision = = nil { return 0 } return * q . Precision } 
func ( q * Query Value Definition ) Get Precision Ok ( ) ( int , bool ) { if q = = nil | | q . Precision = = nil { return 0 , false } return * q . Precision , true } 
func ( q * Query Value Definition ) Has Precision ( ) bool { if q ! = nil & & q . Precision ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Text Align ( ) string { if q = = nil | | q . Text Align = = nil { return " " } return * q . Text Align } 
func ( q * Query Value Definition ) Get Text Align Ok ( ) ( string , bool ) { if q = = nil | | q . Text Align = = nil { return " " , false } return * q . Text Align , true } 
func ( q * Query Value Definition ) Has Text Align ( ) bool { if q ! = nil & & q . Text Align ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Time ( ) Widget Time { if q = = nil | | q . Time = = nil { return Widget Time { } } return * q . Time } 
func ( q * Query Value Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if q = = nil | | q . Time = = nil { return Widget Time { } , false } return * q . Time , true } 
func ( q * Query Value Definition ) Has Time ( ) bool { if q ! = nil & & q . Time ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Title ( ) string { if q = = nil | | q . Title = = nil { return " " } return * q . Title } 
func ( q * Query Value Definition ) Get Title Ok ( ) ( string , bool ) { if q = = nil | | q . Title = = nil { return " " , false } return * q . Title , true } 
func ( q * Query Value Definition ) Has Title ( ) bool { if q ! = nil & & q . Title ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Title Align ( ) string { if q = = nil | | q . Title Align = = nil { return " " } return * q . Title Align } 
func ( q * Query Value Definition ) Get Title Align Ok ( ) ( string , bool ) { if q = = nil | | q . Title Align = = nil { return " " , false } return * q . Title Align , true } 
func ( q * Query Value Definition ) Has Title Align ( ) bool { if q ! = nil & & q . Title Align ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Title Size ( ) string { if q = = nil | | q . Title Size = = nil { return " " } return * q . Title Size } 
func ( q * Query Value Definition ) Get Title Size Ok ( ) ( string , bool ) { if q = = nil | | q . Title Size = = nil { return " " , false } return * q . Title Size , true } 
func ( q * Query Value Definition ) Has Title Size ( ) bool { if q ! = nil & & q . Title Size ! = nil { return true } return false } 
func ( q * Query Value Definition ) Get Type ( ) string { if q = = nil | | q . Type = = nil { return " " } return * q . Type } 
func ( q * Query Value Definition ) Get Type Ok ( ) ( string , bool ) { if q = = nil | | q . Type = = nil { return " " , false } return * q . Type , true } 
func ( q * Query Value Definition ) Has Type ( ) bool { if q ! = nil & & q . Type ! = nil { return true } return false } 
func ( q * Query Value Request ) Get Aggregator ( ) string { if q = = nil | | q . Aggregator = = nil { return " " } return * q . Aggregator } 
func ( q * Query Value Request ) Get Aggregator Ok ( ) ( string , bool ) { if q = = nil | | q . Aggregator = = nil { return " " , false } return * q . Aggregator , true } 
func ( q * Query Value Request ) Has Aggregator ( ) bool { if q ! = nil & & q . Aggregator ! = nil { return true } return false } 
func ( q * Query Value Request ) Get Apm Query ( ) Widget Apm Or Log Query { if q = = nil | | q . Apm Query = = nil { return Widget Apm Or Log Query { } } return * q . Apm Query } 
func ( q * Query Value Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if q = = nil | | q . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * q . Apm Query , true } 
func ( q * Query Value Request ) Has Apm Query ( ) bool { if q ! = nil & & q . Apm Query ! = nil { return true } return false } 
func ( q * Query Value Request ) Get Log Query ( ) Widget Apm Or Log Query { if q = = nil | | q . Log Query = = nil { return Widget Apm Or Log Query { } } return * q . Log Query } 
func ( q * Query Value Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if q = = nil | | q . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * q . Log Query , true } 
func ( q * Query Value Request ) Has Log Query ( ) bool { if q ! = nil & & q . Log Query ! = nil { return true } return false } 
func ( q * Query Value Request ) Get Metric Query ( ) string { if q = = nil | | q . Metric Query = = nil { return " " } return * q . Metric Query } 
func ( q * Query Value Request ) Get Metric Query Ok ( ) ( string , bool ) { if q = = nil | | q . Metric Query = = nil { return " " , false } return * q . Metric Query , true } 
func ( q * Query Value Request ) Has Metric Query ( ) bool { if q ! = nil & & q . Metric Query ! = nil { return true } return false } 
func ( q * Query Value Request ) Get Process Query ( ) Widget Process Query { if q = = nil | | q . Process Query = = nil { return Widget Process Query { } } return * q . Process Query } 
func ( q * Query Value Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if q = = nil | | q . Process Query = = nil { return Widget Process Query { } , false } return * q . Process Query , true } 
func ( q * Query Value Request ) Has Process Query ( ) bool { if q ! = nil & & q . Process Query ! = nil { return true } return false } 
func ( r * Recurrence ) Get Period ( ) int { if r = = nil | | r . Period = = nil { return 0 } return * r . Period } 
func ( r * Recurrence ) Get Period Ok ( ) ( int , bool ) { if r = = nil | | r . Period = = nil { return 0 , false } return * r . Period , true } 
func ( r * Recurrence ) Has Period ( ) bool { if r ! = nil & & r . Period ! = nil { return true } return false } 
func ( r * Recurrence ) Get Type ( ) string { if r = = nil | | r . Type = = nil { return " " } return * r . Type } 
func ( r * Recurrence ) Get Type Ok ( ) ( string , bool ) { if r = = nil | | r . Type = = nil { return " " , false } return * r . Type , true } 
func ( r * Recurrence ) Has Type ( ) bool { if r ! = nil & & r . Type ! = nil { return true } return false } 
func ( r * Recurrence ) Get Until Date ( ) int { if r = = nil | | r . Until Date = = nil { return 0 } return * r . Until Date } 
func ( r * Recurrence ) Get Until Date Ok ( ) ( int , bool ) { if r = = nil | | r . Until Date = = nil { return 0 , false } return * r . Until Date , true } 
func ( r * Recurrence ) Has Until Date ( ) bool { if r ! = nil & & r . Until Date ! = nil { return true } return false } 
func ( r * Recurrence ) Get Until Occurrences ( ) int { if r = = nil | | r . Until Occurrences = = nil { return 0 } return * r . Until Occurrences } 
func ( r * Recurrence ) Get Until Occurrences Ok ( ) ( int , bool ) { if r = = nil | | r . Until Occurrences = = nil { return 0 , false } return * r . Until Occurrences , true } 
func ( r * Recurrence ) Has Until Occurrences ( ) bool { if r ! = nil & & r . Until Occurrences ! = nil { return true } return false } 
func ( r * req APIKey ) Get APIKey ( ) APIKey { if r = = nil | | r . APIKey = = nil { return APIKey { } } return * r . APIKey } 
func ( r * req APIKey ) Get APIKey Ok ( ) ( APIKey , bool ) { if r = = nil | | r . APIKey = = nil { return APIKey { } , false } return * r . APIKey , true } 
func ( r * req APIKey ) Has APIKey ( ) bool { if r ! = nil & & r . APIKey ! = nil { return true } return false } 
func ( r * req Comment ) Get Comment ( ) Comment { if r = = nil | | r . Comment = = nil { return Comment { } } return * r . Comment } 
func ( r * req Comment ) Get Comment Ok ( ) ( Comment , bool ) { if r = = nil | | r . Comment = = nil { return Comment { } , false } return * r . Comment , true } 
func ( r * req Comment ) Has Comment ( ) bool { if r ! = nil & & r . Comment ! = nil { return true } return false } 
func ( r * req Get Dashboard ) Get Dashboard ( ) Dashboard { if r = = nil | | r . Dashboard = = nil { return Dashboard { } } return * r . Dashboard } 
func ( r * req Get Dashboard ) Get Dashboard Ok ( ) ( Dashboard , bool ) { if r = = nil | | r . Dashboard = = nil { return Dashboard { } , false } return * r . Dashboard , true } 
func ( r * req Get Dashboard ) Has Dashboard ( ) bool { if r ! = nil & & r . Dashboard ! = nil { return true } return false } 
func ( r * req Get Dashboard ) Get Resource ( ) string { if r = = nil | | r . Resource = = nil { return " " } return * r . Resource } 
func ( r * req Get Dashboard ) Get Resource Ok ( ) ( string , bool ) { if r = = nil | | r . Resource = = nil { return " " , false } return * r . Resource , true } 
func ( r * req Get Dashboard ) Has Resource ( ) bool { if r ! = nil & & r . Resource ! = nil { return true } return false } 
func ( r * req Get Dashboard ) Get Url ( ) string { if r = = nil | | r . Url = = nil { return " " } return * r . Url } 
func ( r * req Get Dashboard ) Get Url Ok ( ) ( string , bool ) { if r = = nil | | r . Url = = nil { return " " , false } return * r . Url , true } 
func ( r * req Get Dashboard ) Has Url ( ) bool { if r ! = nil & & r . Url ! = nil { return true } return false } 
func ( r * req Get Event ) Get Event ( ) Event { if r = = nil | | r . Event = = nil { return Event { } } return * r . Event } 
func ( r * req Get Event ) Get Event Ok ( ) ( Event , bool ) { if r = = nil | | r . Event = = nil { return Event { } , false } return * r . Event , true } 
func ( r * req Get Event ) Has Event ( ) bool { if r ! = nil & & r . Event ! = nil { return true } return false } 
func ( r * req Get Tags ) Get Tags ( ) Tag Map { if r = = nil | | r . Tags = = nil { return Tag Map { } } return * r . Tags } 
func ( r * req Get Tags ) Get Tags Ok ( ) ( Tag Map , bool ) { if r = = nil | | r . Tags = = nil { return Tag Map { } , false } return * r . Tags , true } 
func ( r * req Get Tags ) Has Tags ( ) bool { if r ! = nil & & r . Tags ! = nil { return true } return false } 
func ( r * Rule ) Get Color ( ) string { if r = = nil | | r . Color = = nil { return " " } return * r . Color } 
func ( r * Rule ) Get Color Ok ( ) ( string , bool ) { if r = = nil | | r . Color = = nil { return " " , false } return * r . Color , true } 
func ( r * Rule ) Has Color ( ) bool { if r ! = nil & & r . Color ! = nil { return true } return false } 
func ( r * Rule ) Get Threshold ( ) json . Number { if r = = nil | | r . Threshold = = nil { return " " } return * r . Threshold } 
func ( r * Rule ) Get Threshold Ok ( ) ( json . Number , bool ) { if r = = nil | | r . Threshold = = nil { return " " , false } return * r . Threshold , true } 
func ( r * Rule ) Has Threshold ( ) bool { if r ! = nil & & r . Threshold ! = nil { return true } return false } 
func ( r * Rule ) Get Timeframe ( ) string { if r = = nil | | r . Timeframe = = nil { return " " } return * r . Timeframe } 
func ( r * Rule ) Get Timeframe Ok ( ) ( string , bool ) { if r = = nil | | r . Timeframe = = nil { return " " , false } return * r . Timeframe , true } 
func ( r * Rule ) Has Timeframe ( ) bool { if r ! = nil & & r . Timeframe ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Requests ( ) Scatterplot Requests { if s = = nil | | s . Requests = = nil { return Scatterplot Requests { } } return * s . Requests } 
func ( s * Scatterplot Definition ) Get Requests Ok ( ) ( Scatterplot Requests , bool ) { if s = = nil | | s . Requests = = nil { return Scatterplot Requests { } , false } return * s . Requests , true } 
func ( s * Scatterplot Definition ) Has Requests ( ) bool { if s ! = nil & & s . Requests ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Time ( ) Widget Time { if s = = nil | | s . Time = = nil { return Widget Time { } } return * s . Time } 
func ( s * Scatterplot Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if s = = nil | | s . Time = = nil { return Widget Time { } , false } return * s . Time , true } 
func ( s * Scatterplot Definition ) Has Time ( ) bool { if s ! = nil & & s . Time ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Title ( ) string { if s = = nil | | s . Title = = nil { return " " } return * s . Title } 
func ( s * Scatterplot Definition ) Has Title ( ) bool { if s ! = nil & & s . Title ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Title Align ( ) string { if s = = nil | | s . Title Align = = nil { return " " } return * s . Title Align } 
func ( s * Scatterplot Definition ) Get Title Align Ok ( ) ( string , bool ) { if s = = nil | | s . Title Align = = nil { return " " , false } return * s . Title Align , true } 
func ( s * Scatterplot Definition ) Has Title Align ( ) bool { if s ! = nil & & s . Title Align ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Title Size ( ) string { if s = = nil | | s . Title Size = = nil { return " " } return * s . Title Size } 
func ( s * Scatterplot Definition ) Get Title Size Ok ( ) ( string , bool ) { if s = = nil | | s . Title Size = = nil { return " " , false } return * s . Title Size , true } 
func ( s * Scatterplot Definition ) Has Title Size ( ) bool { if s ! = nil & & s . Title Size ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Type ( ) string { if s = = nil | | s . Type = = nil { return " " } return * s . Type } 
func ( s * Scatterplot Definition ) Get Type Ok ( ) ( string , bool ) { if s = = nil | | s . Type = = nil { return " " , false } return * s . Type , true } 
func ( s * Scatterplot Definition ) Has Type ( ) bool { if s ! = nil & & s . Type ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Xaxis ( ) Widget Axis { if s = = nil | | s . Xaxis = = nil { return Widget Axis { } } return * s . Xaxis } 
func ( s * Scatterplot Definition ) Get Xaxis Ok ( ) ( Widget Axis , bool ) { if s = = nil | | s . Xaxis = = nil { return Widget Axis { } , false } return * s . Xaxis , true } 
func ( s * Scatterplot Definition ) Has Xaxis ( ) bool { if s ! = nil & & s . Xaxis ! = nil { return true } return false } 
func ( s * Scatterplot Definition ) Get Yaxis ( ) Widget Axis { if s = = nil | | s . Yaxis = = nil { return Widget Axis { } } return * s . Yaxis } 
func ( s * Scatterplot Definition ) Get Yaxis Ok ( ) ( Widget Axis , bool ) { if s = = nil | | s . Yaxis = = nil { return Widget Axis { } , false } return * s . Yaxis , true } 
func ( s * Scatterplot Definition ) Has Yaxis ( ) bool { if s ! = nil & & s . Yaxis ! = nil { return true } return false } 
func ( s * Scatterplot Request ) Get Aggregator ( ) string { if s = = nil | | s . Aggregator = = nil { return " " } return * s . Aggregator } 
func ( s * Scatterplot Request ) Get Aggregator Ok ( ) ( string , bool ) { if s = = nil | | s . Aggregator = = nil { return " " , false } return * s . Aggregator , true } 
func ( s * Scatterplot Request ) Has Aggregator ( ) bool { if s ! = nil & & s . Aggregator ! = nil { return true } return false } 
func ( s * Scatterplot Request ) Get Apm Query ( ) Widget Apm Or Log Query { if s = = nil | | s . Apm Query = = nil { return Widget Apm Or Log Query { } } return * s . Apm Query } 
func ( s * Scatterplot Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if s = = nil | | s . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * s . Apm Query , true } 
func ( s * Scatterplot Request ) Has Apm Query ( ) bool { if s ! = nil & & s . Apm Query ! = nil { return true } return false } 
func ( s * Scatterplot Request ) Get Log Query ( ) Widget Apm Or Log Query { if s = = nil | | s . Log Query = = nil { return Widget Apm Or Log Query { } } return * s . Log Query } 
func ( s * Scatterplot Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if s = = nil | | s . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * s . Log Query , true } 
func ( s * Scatterplot Request ) Has Log Query ( ) bool { if s ! = nil & & s . Log Query ! = nil { return true } return false } 
func ( s * Scatterplot Request ) Get Metric Query ( ) string { if s = = nil | | s . Metric Query = = nil { return " " } return * s . Metric Query } 
func ( s * Scatterplot Request ) Get Metric Query Ok ( ) ( string , bool ) { if s = = nil | | s . Metric Query = = nil { return " " , false } return * s . Metric Query , true } 
func ( s * Scatterplot Request ) Has Metric Query ( ) bool { if s ! = nil & & s . Metric Query ! = nil { return true } return false } 
func ( s * Scatterplot Request ) Get Process Query ( ) Widget Process Query { if s = = nil | | s . Process Query = = nil { return Widget Process Query { } } return * s . Process Query } 
func ( s * Scatterplot Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if s = = nil | | s . Process Query = = nil { return Widget Process Query { } , false } return * s . Process Query , true } 
func ( s * Scatterplot Request ) Has Process Query ( ) bool { if s ! = nil & & s . Process Query ! = nil { return true } return false } 
func ( s * Scatterplot Requests ) Get X ( ) Scatterplot Request { if s = = nil | | s . X = = nil { return Scatterplot Request { } } return * s . X } 
func ( s * Scatterplot Requests ) Get XOk ( ) ( Scatterplot Request , bool ) { if s = = nil | | s . X = = nil { return Scatterplot Request { } , false } return * s . X , true } 
func ( s * Scatterplot Requests ) Has X ( ) bool { if s ! = nil & & s . X ! = nil { return true } return false } 
func ( s * Scatterplot Requests ) Get Y ( ) Scatterplot Request { if s = = nil | | s . Y = = nil { return Scatterplot Request { } } return * s . Y } 
func ( s * Scatterplot Requests ) Get YOk ( ) ( Scatterplot Request , bool ) { if s = = nil | | s . Y = = nil { return Scatterplot Request { } , false } return * s . Y , true } 
func ( s * Scatterplot Requests ) Has Y ( ) bool { if s ! = nil & & s . Y ! = nil { return true } return false } 
func ( s * Screenboard ) Get Height ( ) int { if s = = nil | | s . Height = = nil { return 0 } return * s . Height } 
func ( s * Screenboard ) Get Height Ok ( ) ( int , bool ) { if s = = nil | | s . Height = = nil { return 0 , false } return * s . Height , true } 
func ( s * Screenboard ) Has Height ( ) bool { if s ! = nil & & s . Height ! = nil { return true } return false } 
func ( s * Screenboard ) Get Id ( ) int { if s = = nil | | s . Id = = nil { return 0 } return * s . Id } 
func ( s * Screenboard ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Screenboard ) Get New Id ( ) string { if s = = nil | | s . New Id = = nil { return " " } return * s . New Id } 
func ( s * Screenboard ) Get New Id Ok ( ) ( string , bool ) { if s = = nil | | s . New Id = = nil { return " " , false } return * s . New Id , true } 
func ( s * Screenboard ) Has New Id ( ) bool { if s ! = nil & & s . New Id ! = nil { return true } return false } 
func ( s * Screenboard ) Get Read Only ( ) bool { if s = = nil | | s . Read Only = = nil { return false } return * s . Read Only } 
func ( s * Screenboard ) Get Read Only Ok ( ) ( bool , bool ) { if s = = nil | | s . Read Only = = nil { return false , false } return * s . Read Only , true } 
func ( s * Screenboard ) Has Read Only ( ) bool { if s ! = nil & & s . Read Only ! = nil { return true } return false } 
func ( s * Screenboard ) Get Shared ( ) bool { if s = = nil | | s . Shared = = nil { return false } return * s . Shared } 
func ( s * Screenboard ) Get Shared Ok ( ) ( bool , bool ) { if s = = nil | | s . Shared = = nil { return false , false } return * s . Shared , true } 
func ( s * Screenboard ) Has Shared ( ) bool { if s ! = nil & & s . Shared ! = nil { return true } return false } 
func ( s * Screenboard ) Get Title ( ) string { if s = = nil | | s . Title = = nil { return " " } return * s . Title } 
func ( s * Screenboard ) Get Title Ok ( ) ( string , bool ) { if s = = nil | | s . Title = = nil { return " " , false } return * s . Title , true } 
func ( s * Screenboard ) Has Title ( ) bool { if s ! = nil & & s . Title ! = nil { return true } return false } 
func ( s * Screenboard ) Get Width ( ) int { if s = = nil | | s . Width = = nil { return 0 } return * s . Width } 
func ( s * Screenboard ) Get Width Ok ( ) ( int , bool ) { if s = = nil | | s . Width = = nil { return 0 , false } return * s . Width , true } 
func ( s * Screenboard ) Has Width ( ) bool { if s ! = nil & & s . Width ! = nil { return true } return false } 
func ( s * Screenboard Lite ) Get Id ( ) int { if s = = nil | | s . Id = = nil { return 0 } return * s . Id } 
func ( s * Screenboard Lite ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Screenboard Lite ) Get Resource ( ) string { if s = = nil | | s . Resource = = nil { return " " } return * s . Resource } 
func ( s * Screenboard Lite ) Get Resource Ok ( ) ( string , bool ) { if s = = nil | | s . Resource = = nil { return " " , false } return * s . Resource , true } 
func ( s * Screenboard Lite ) Has Resource ( ) bool { if s ! = nil & & s . Resource ! = nil { return true } return false } 
func ( s * Screenboard Lite ) Get Title ( ) string { if s = = nil | | s . Title = = nil { return " " } return * s . Title } 
func ( s * Screenboard Lite ) Has Title ( ) bool { if s ! = nil & & s . Title ! = nil { return true } return false } 
func ( s * Screenboard Monitor ) Get Id ( ) int { if s = = nil | | s . Id = = nil { return 0 } return * s . Id } 
func ( s * Screenboard Monitor ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Series ) Get Aggr ( ) string { if s = = nil | | s . Aggr = = nil { return " " } return * s . Aggr } 
func ( s * Series ) Get Aggr Ok ( ) ( string , bool ) { if s = = nil | | s . Aggr = = nil { return " " , false } return * s . Aggr , true } 
func ( s * Series ) Has Aggr ( ) bool { if s ! = nil & & s . Aggr ! = nil { return true } return false } 
func ( s * Series ) Get Display Name ( ) string { if s = = nil | | s . Display Name = = nil { return " " } return * s . Display Name } 
func ( s * Series ) Get Display Name Ok ( ) ( string , bool ) { if s = = nil | | s . Display Name = = nil { return " " , false } return * s . Display Name , true } 
func ( s * Series ) Has Display Name ( ) bool { if s ! = nil & & s . Display Name ! = nil { return true } return false } 
func ( s * Series ) Get End ( ) float 6 4 { if s = = nil | | s . End = = nil { return 0 } return * s . End } 
func ( s * Series ) Get End Ok ( ) ( float 6 4 , bool ) { if s = = nil | | s . End = = nil { return 0 , false } return * s . End , true } 
func ( s * Series ) Has End ( ) bool { if s ! = nil & & s . End ! = nil { return true } return false } 
func ( s * Series ) Get Expression ( ) string { if s = = nil | | s . Expression = = nil { return " " } return * s . Expression } 
func ( s * Series ) Get Expression Ok ( ) ( string , bool ) { if s = = nil | | s . Expression = = nil { return " " , false } return * s . Expression , true } 
func ( s * Series ) Has Expression ( ) bool { if s ! = nil & & s . Expression ! = nil { return true } return false } 
func ( s * Series ) Get Interval ( ) int { if s = = nil | | s . Interval = = nil { return 0 } return * s . Interval } 
func ( s * Series ) Get Interval Ok ( ) ( int , bool ) { if s = = nil | | s . Interval = = nil { return 0 , false } return * s . Interval , true } 
func ( s * Series ) Has Interval ( ) bool { if s ! = nil & & s . Interval ! = nil { return true } return false } 
func ( s * Series ) Get Length ( ) int { if s = = nil | | s . Length = = nil { return 0 } return * s . Length } 
func ( s * Series ) Get Length Ok ( ) ( int , bool ) { if s = = nil | | s . Length = = nil { return 0 , false } return * s . Length , true } 
func ( s * Series ) Has Length ( ) bool { if s ! = nil & & s . Length ! = nil { return true } return false } 
func ( s * Series ) Get Metric ( ) string { if s = = nil | | s . Metric = = nil { return " " } return * s . Metric } 
func ( s * Series ) Get Metric Ok ( ) ( string , bool ) { if s = = nil | | s . Metric = = nil { return " " , false } return * s . Metric , true } 
func ( s * Series ) Has Metric ( ) bool { if s ! = nil & & s . Metric ! = nil { return true } return false } 
func ( s * Series ) Get Scope ( ) string { if s = = nil | | s . Scope = = nil { return " " } return * s . Scope } 
func ( s * Series ) Get Scope Ok ( ) ( string , bool ) { if s = = nil | | s . Scope = = nil { return " " , false } return * s . Scope , true } 
func ( s * Series ) Has Scope ( ) bool { if s ! = nil & & s . Scope ! = nil { return true } return false } 
func ( s * Series ) Get Start ( ) float 6 4 { if s = = nil | | s . Start = = nil { return 0 } return * s . Start } 
func ( s * Series ) Get Start Ok ( ) ( float 6 4 , bool ) { if s = = nil | | s . Start = = nil { return 0 , false } return * s . Start , true } 
func ( s * Series ) Has Start ( ) bool { if s ! = nil & & s . Start ! = nil { return true } return false } 
func ( s * Series ) Get Units ( ) Unit Pair { if s = = nil | | s . Units = = nil { return Unit Pair { } } return * s . Units } 
func ( s * Series ) Get Units Ok ( ) ( Unit Pair , bool ) { if s = = nil | | s . Units = = nil { return Unit Pair { } , false } return * s . Units , true } 
func ( s * Series ) Has Units ( ) bool { if s ! = nil & & s . Units ! = nil { return true } return false } 
func ( s * Service Hook Slack Request ) Get Account ( ) string { if s = = nil | | s . Account = = nil { return " " } return * s . Account } 
func ( s * Service Hook Slack Request ) Get Account Ok ( ) ( string , bool ) { if s = = nil | | s . Account = = nil { return " " , false } return * s . Account , true } 
func ( s * Service Hook Slack Request ) Has Account ( ) bool { if s ! = nil & & s . Account ! = nil { return true } return false } 
func ( s * Service Hook Slack Request ) Get Url ( ) string { if s = = nil | | s . Url = = nil { return " " } return * s . Url } 
func ( s * Service Hook Slack Request ) Get Url Ok ( ) ( string , bool ) { if s = = nil | | s . Url = = nil { return " " , false } return * s . Url , true } 
func ( s * Service Hook Slack Request ) Has Url ( ) bool { if s ! = nil & & s . Url ! = nil { return true } return false } 
func ( s * service PD ) Get Service Key ( ) string { if s = = nil | | s . Service Key = = nil { return " " } return * s . Service Key } 
func ( s * service PD ) Has Service Key ( ) bool { if s ! = nil & & s . Service Key ! = nil { return true } return false } 
func ( s * service PD ) Get Service Name ( ) string { if s = = nil | | s . Service Name = = nil { return " " } return * s . Service Name } 
func ( s * service PD ) Get Service Name Ok ( ) ( string , bool ) { if s = = nil | | s . Service Name = = nil { return " " , false } return * s . Service Name , true } 
func ( s * service PD ) Has Service Name ( ) bool { if s ! = nil & & s . Service Name ! = nil { return true } return false } 
func ( s * Service PDRequest ) Get Service Key ( ) string { if s = = nil | | s . Service Key = = nil { return " " } return * s . Service Key } 
func ( s * Service PDRequest ) Get Service Key Ok ( ) ( string , bool ) { if s = = nil | | s . Service Key = = nil { return " " , false } return * s . Service Key , true } 
func ( s * Service PDRequest ) Has Service Key ( ) bool { if s ! = nil & & s . Service Key ! = nil { return true } return false } 
func ( s * Service PDRequest ) Get Service Name ( ) string { if s = = nil | | s . Service Name = = nil { return " " } return * s . Service Name } 
func ( s * Service PDRequest ) Has Service Name ( ) bool { if s ! = nil & & s . Service Name ! = nil { return true } return false } 
func ( s * Style ) Get Fill Max ( ) json . Number { if s = = nil | | s . Fill Max = = nil { return " " } return * s . Fill Max } 
func ( s * Style ) Get Fill Max Ok ( ) ( json . Number , bool ) { if s = = nil | | s . Fill Max = = nil { return " " , false } return * s . Fill Max , true } 
func ( s * Style ) Has Fill Max ( ) bool { if s ! = nil & & s . Fill Max ! = nil { return true } return false } 
func ( s * Style ) Get Fill Min ( ) json . Number { if s = = nil | | s . Fill Min = = nil { return " " } return * s . Fill Min } 
func ( s * Style ) Get Fill Min Ok ( ) ( json . Number , bool ) { if s = = nil | | s . Fill Min = = nil { return " " , false } return * s . Fill Min , true } 
func ( s * Style ) Has Fill Min ( ) bool { if s ! = nil & & s . Fill Min ! = nil { return true } return false } 
func ( s * Style ) Get Palette ( ) string { if s = = nil | | s . Palette = = nil { return " " } return * s . Palette } 
func ( s * Style ) Get Palette Ok ( ) ( string , bool ) { if s = = nil | | s . Palette = = nil { return " " , false } return * s . Palette , true } 
func ( s * Style ) Has Palette ( ) bool { if s ! = nil & & s . Palette ! = nil { return true } return false } 
func ( s * Style ) Get Palette Flip ( ) bool { if s = = nil | | s . Palette Flip = = nil { return false } return * s . Palette Flip } 
func ( s * Style ) Get Palette Flip Ok ( ) ( bool , bool ) { if s = = nil | | s . Palette Flip = = nil { return false , false } return * s . Palette Flip , true } 
func ( s * Style ) Has Palette Flip ( ) bool { if s ! = nil & & s . Palette Flip ! = nil { return true } return false } 
func ( s * Synthetics Assertion ) Get Operator ( ) string { if s = = nil | | s . Operator = = nil { return " " } return * s . Operator } 
func ( s * Synthetics Assertion ) Get Operator Ok ( ) ( string , bool ) { if s = = nil | | s . Operator = = nil { return " " , false } return * s . Operator , true } 
func ( s * Synthetics Assertion ) Has Operator ( ) bool { if s ! = nil & & s . Operator ! = nil { return true } return false } 
func ( s * Synthetics Assertion ) Get Property ( ) string { if s = = nil | | s . Property = = nil { return " " } return * s . Property } 
func ( s * Synthetics Assertion ) Get Property Ok ( ) ( string , bool ) { if s = = nil | | s . Property = = nil { return " " , false } return * s . Property , true } 
func ( s * Synthetics Assertion ) Has Property ( ) bool { if s ! = nil & & s . Property ! = nil { return true } return false } 
func ( s * Synthetics Assertion ) Get Type ( ) string { if s = = nil | | s . Type = = nil { return " " } return * s . Type } 
func ( s * Synthetics Assertion ) Has Type ( ) bool { if s ! = nil & & s . Type ! = nil { return true } return false } 
func ( s * Synthetics Config ) Get Request ( ) Synthetics Request { if s = = nil | | s . Request = = nil { return Synthetics Request { } } return * s . Request } 
func ( s * Synthetics Config ) Get Request Ok ( ) ( Synthetics Request , bool ) { if s = = nil | | s . Request = = nil { return Synthetics Request { } , false } return * s . Request , true } 
func ( s * Synthetics Config ) Has Request ( ) bool { if s ! = nil & & s . Request ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Height ( ) int { if s = = nil | | s . Height = = nil { return 0 } return * s . Height } 
func ( s * Synthetics Device ) Has Height ( ) bool { if s ! = nil & & s . Height ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Id ( ) string { if s = = nil | | s . Id = = nil { return " " } return * s . Id } 
func ( s * Synthetics Device ) Get Id Ok ( ) ( string , bool ) { if s = = nil | | s . Id = = nil { return " " , false } return * s . Id , true } 
func ( s * Synthetics Device ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Is Landscape ( ) bool { if s = = nil | | s . Is Landscape = = nil { return false } return * s . Is Landscape } 
func ( s * Synthetics Device ) Get Is Landscape Ok ( ) ( bool , bool ) { if s = = nil | | s . Is Landscape = = nil { return false , false } return * s . Is Landscape , true } 
func ( s * Synthetics Device ) Has Is Landscape ( ) bool { if s ! = nil & & s . Is Landscape ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Is Mobile ( ) bool { if s = = nil | | s . Is Mobile = = nil { return false } return * s . Is Mobile } 
func ( s * Synthetics Device ) Get Is Mobile Ok ( ) ( bool , bool ) { if s = = nil | | s . Is Mobile = = nil { return false , false } return * s . Is Mobile , true } 
func ( s * Synthetics Device ) Has Is Mobile ( ) bool { if s ! = nil & & s . Is Mobile ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Name ( ) string { if s = = nil | | s . Name = = nil { return " " } return * s . Name } 
func ( s * Synthetics Device ) Get Name Ok ( ) ( string , bool ) { if s = = nil | | s . Name = = nil { return " " , false } return * s . Name , true } 
func ( s * Synthetics Device ) Has Name ( ) bool { if s ! = nil & & s . Name ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get User Agent ( ) string { if s = = nil | | s . User Agent = = nil { return " " } return * s . User Agent } 
func ( s * Synthetics Device ) Get User Agent Ok ( ) ( string , bool ) { if s = = nil | | s . User Agent = = nil { return " " , false } return * s . User Agent , true } 
func ( s * Synthetics Device ) Has User Agent ( ) bool { if s ! = nil & & s . User Agent ! = nil { return true } return false } 
func ( s * Synthetics Device ) Get Width ( ) int { if s = = nil | | s . Width = = nil { return 0 } return * s . Width } 
func ( s * Synthetics Device ) Has Width ( ) bool { if s ! = nil & & s . Width ! = nil { return true } return false } 
func ( s * Synthetics Location ) Get Display Name ( ) string { if s = = nil | | s . Display Name = = nil { return " " } return * s . Display Name } 
func ( s * Synthetics Location ) Has Display Name ( ) bool { if s ! = nil & & s . Display Name ! = nil { return true } return false } 
func ( s * Synthetics Location ) Get Id ( ) int { if s = = nil | | s . Id = = nil { return 0 } return * s . Id } 
func ( s * Synthetics Location ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Synthetics Location ) Get Is Landscape ( ) bool { if s = = nil | | s . Is Landscape = = nil { return false } return * s . Is Landscape } 
func ( s * Synthetics Location ) Get Is Landscape Ok ( ) ( bool , bool ) { if s = = nil | | s . Is Landscape = = nil { return false , false } return * s . Is Landscape , true } 
func ( s * Synthetics Location ) Has Is Landscape ( ) bool { if s ! = nil & & s . Is Landscape ! = nil { return true } return false } 
func ( s * Synthetics Location ) Get Name ( ) string { if s = = nil | | s . Name = = nil { return " " } return * s . Name } 
func ( s * Synthetics Location ) Has Name ( ) bool { if s ! = nil & & s . Name ! = nil { return true } return false } 
func ( s * Synthetics Location ) Get Region ( ) string { if s = = nil | | s . Region = = nil { return " " } return * s . Region } 
func ( s * Synthetics Location ) Get Region Ok ( ) ( string , bool ) { if s = = nil | | s . Region = = nil { return " " , false } return * s . Region , true } 
func ( s * Synthetics Location ) Has Region ( ) bool { if s ! = nil & & s . Region ! = nil { return true } return false } 
func ( s * Synthetics Options ) Get Follow Redirects ( ) bool { if s = = nil | | s . Follow Redirects = = nil { return false } return * s . Follow Redirects } 
func ( s * Synthetics Options ) Get Follow Redirects Ok ( ) ( bool , bool ) { if s = = nil | | s . Follow Redirects = = nil { return false , false } return * s . Follow Redirects , true } 
func ( s * Synthetics Options ) Has Follow Redirects ( ) bool { if s ! = nil & & s . Follow Redirects ! = nil { return true } return false } 
func ( s * Synthetics Options ) Get Min Failure Duration ( ) int { if s = = nil | | s . Min Failure Duration = = nil { return 0 } return * s . Min Failure Duration } 
func ( s * Synthetics Options ) Get Min Failure Duration Ok ( ) ( int , bool ) { if s = = nil | | s . Min Failure Duration = = nil { return 0 , false } return * s . Min Failure Duration , true } 
func ( s * Synthetics Options ) Has Min Failure Duration ( ) bool { if s ! = nil & & s . Min Failure Duration ! = nil { return true } return false } 
func ( s * Synthetics Options ) Get Min Location Failed ( ) int { if s = = nil | | s . Min Location Failed = = nil { return 0 } return * s . Min Location Failed } 
func ( s * Synthetics Options ) Get Min Location Failed Ok ( ) ( int , bool ) { if s = = nil | | s . Min Location Failed = = nil { return 0 , false } return * s . Min Location Failed , true } 
func ( s * Synthetics Options ) Has Min Location Failed ( ) bool { if s ! = nil & & s . Min Location Failed ! = nil { return true } return false } 
func ( s * Synthetics Options ) Get Tick Every ( ) int { if s = = nil | | s . Tick Every = = nil { return 0 } return * s . Tick Every } 
func ( s * Synthetics Options ) Get Tick Every Ok ( ) ( int , bool ) { if s = = nil | | s . Tick Every = = nil { return 0 , false } return * s . Tick Every , true } 
func ( s * Synthetics Options ) Has Tick Every ( ) bool { if s ! = nil & & s . Tick Every ! = nil { return true } return false } 
func ( s * Synthetics Request ) Get Body ( ) string { if s = = nil | | s . Body = = nil { return " " } return * s . Body } 
func ( s * Synthetics Request ) Get Body Ok ( ) ( string , bool ) { if s = = nil | | s . Body = = nil { return " " , false } return * s . Body , true } 
func ( s * Synthetics Request ) Has Body ( ) bool { if s ! = nil & & s . Body ! = nil { return true } return false } 
func ( s * Synthetics Request ) Get Method ( ) string { if s = = nil | | s . Method = = nil { return " " } return * s . Method } 
func ( s * Synthetics Request ) Get Method Ok ( ) ( string , bool ) { if s = = nil | | s . Method = = nil { return " " , false } return * s . Method , true } 
func ( s * Synthetics Request ) Has Method ( ) bool { if s ! = nil & & s . Method ! = nil { return true } return false } 
func ( s * Synthetics Request ) Get Timeout ( ) int { if s = = nil | | s . Timeout = = nil { return 0 } return * s . Timeout } 
func ( s * Synthetics Request ) Get Timeout Ok ( ) ( int , bool ) { if s = = nil | | s . Timeout = = nil { return 0 , false } return * s . Timeout , true } 
func ( s * Synthetics Request ) Has Timeout ( ) bool { if s ! = nil & & s . Timeout ! = nil { return true } return false } 
func ( s * Synthetics Request ) Get Url ( ) string { if s = = nil | | s . Url = = nil { return " " } return * s . Url } 
func ( s * Synthetics Request ) Has Url ( ) bool { if s ! = nil & & s . Url ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Config ( ) Synthetics Config { if s = = nil | | s . Config = = nil { return Synthetics Config { } } return * s . Config } 
func ( s * Synthetics Test ) Get Config Ok ( ) ( Synthetics Config , bool ) { if s = = nil | | s . Config = = nil { return Synthetics Config { } , false } return * s . Config , true } 
func ( s * Synthetics Test ) Has Config ( ) bool { if s ! = nil & & s . Config ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Created At ( ) string { if s = = nil | | s . Created At = = nil { return " " } return * s . Created At } 
func ( s * Synthetics Test ) Get Created At Ok ( ) ( string , bool ) { if s = = nil | | s . Created At = = nil { return " " , false } return * s . Created At , true } 
func ( s * Synthetics Test ) Has Created At ( ) bool { if s ! = nil & & s . Created At ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Created By ( ) Synthetics User { if s = = nil | | s . Created By = = nil { return Synthetics User { } } return * s . Created By } 
func ( s * Synthetics Test ) Get Created By Ok ( ) ( Synthetics User , bool ) { if s = = nil | | s . Created By = = nil { return Synthetics User { } , false } return * s . Created By , true } 
func ( s * Synthetics Test ) Has Created By ( ) bool { if s ! = nil & & s . Created By ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Deleted At ( ) string { if s = = nil | | s . Deleted At = = nil { return " " } return * s . Deleted At } 
func ( s * Synthetics Test ) Get Deleted At Ok ( ) ( string , bool ) { if s = = nil | | s . Deleted At = = nil { return " " , false } return * s . Deleted At , true } 
func ( s * Synthetics Test ) Has Deleted At ( ) bool { if s ! = nil & & s . Deleted At ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Message ( ) string { if s = = nil | | s . Message = = nil { return " " } return * s . Message } 
func ( s * Synthetics Test ) Get Message Ok ( ) ( string , bool ) { if s = = nil | | s . Message = = nil { return " " , false } return * s . Message , true } 
func ( s * Synthetics Test ) Has Message ( ) bool { if s ! = nil & & s . Message ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Modified At ( ) string { if s = = nil | | s . Modified At = = nil { return " " } return * s . Modified At } 
func ( s * Synthetics Test ) Get Modified At Ok ( ) ( string , bool ) { if s = = nil | | s . Modified At = = nil { return " " , false } return * s . Modified At , true } 
func ( s * Synthetics Test ) Has Modified At ( ) bool { if s ! = nil & & s . Modified At ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Modified By ( ) Synthetics User { if s = = nil | | s . Modified By = = nil { return Synthetics User { } } return * s . Modified By } 
func ( s * Synthetics Test ) Get Modified By Ok ( ) ( Synthetics User , bool ) { if s = = nil | | s . Modified By = = nil { return Synthetics User { } , false } return * s . Modified By , true } 
func ( s * Synthetics Test ) Has Modified By ( ) bool { if s ! = nil & & s . Modified By ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Monitor Status ( ) string { if s = = nil | | s . Monitor Status = = nil { return " " } return * s . Monitor Status } 
func ( s * Synthetics Test ) Get Monitor Status Ok ( ) ( string , bool ) { if s = = nil | | s . Monitor Status = = nil { return " " , false } return * s . Monitor Status , true } 
func ( s * Synthetics Test ) Has Monitor Status ( ) bool { if s ! = nil & & s . Monitor Status ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Name ( ) string { if s = = nil | | s . Name = = nil { return " " } return * s . Name } 
func ( s * Synthetics Test ) Has Name ( ) bool { if s ! = nil & & s . Name ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Options ( ) Synthetics Options { if s = = nil | | s . Options = = nil { return Synthetics Options { } } return * s . Options } 
func ( s * Synthetics Test ) Get Options Ok ( ) ( Synthetics Options , bool ) { if s = = nil | | s . Options = = nil { return Synthetics Options { } , false } return * s . Options , true } 
func ( s * Synthetics Test ) Has Options ( ) bool { if s ! = nil & & s . Options ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Public Id ( ) string { if s = = nil | | s . Public Id = = nil { return " " } return * s . Public Id } 
func ( s * Synthetics Test ) Get Public Id Ok ( ) ( string , bool ) { if s = = nil | | s . Public Id = = nil { return " " , false } return * s . Public Id , true } 
func ( s * Synthetics Test ) Has Public Id ( ) bool { if s ! = nil & & s . Public Id ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Status ( ) string { if s = = nil | | s . Status = = nil { return " " } return * s . Status } 
func ( s * Synthetics Test ) Get Status Ok ( ) ( string , bool ) { if s = = nil | | s . Status = = nil { return " " , false } return * s . Status , true } 
func ( s * Synthetics Test ) Has Status ( ) bool { if s ! = nil & & s . Status ! = nil { return true } return false } 
func ( s * Synthetics Test ) Get Type ( ) string { if s = = nil | | s . Type = = nil { return " " } return * s . Type } 
func ( s * Synthetics Test ) Has Type ( ) bool { if s ! = nil & & s . Type ! = nil { return true } return false } 
func ( s * Synthetics User ) Get Email ( ) string { if s = = nil | | s . Email = = nil { return " " } return * s . Email } 
func ( s * Synthetics User ) Get Email Ok ( ) ( string , bool ) { if s = = nil | | s . Email = = nil { return " " , false } return * s . Email , true } 
func ( s * Synthetics User ) Has Email ( ) bool { if s ! = nil & & s . Email ! = nil { return true } return false } 
func ( s * Synthetics User ) Get Handle ( ) string { if s = = nil | | s . Handle = = nil { return " " } return * s . Handle } 
func ( s * Synthetics User ) Get Handle Ok ( ) ( string , bool ) { if s = = nil | | s . Handle = = nil { return " " , false } return * s . Handle , true } 
func ( s * Synthetics User ) Has Handle ( ) bool { if s ! = nil & & s . Handle ! = nil { return true } return false } 
func ( s * Synthetics User ) Get Id ( ) int { if s = = nil | | s . Id = = nil { return 0 } return * s . Id } 
func ( s * Synthetics User ) Get Id Ok ( ) ( int , bool ) { if s = = nil | | s . Id = = nil { return 0 , false } return * s . Id , true } 
func ( s * Synthetics User ) Has Id ( ) bool { if s ! = nil & & s . Id ! = nil { return true } return false } 
func ( s * Synthetics User ) Get Name ( ) string { if s = = nil | | s . Name = = nil { return " " } return * s . Name } 
func ( s * Synthetics User ) Has Name ( ) bool { if s ! = nil & & s . Name ! = nil { return true } return false } 
func ( t * Template Variable ) Get Default ( ) string { if t = = nil | | t . Default = = nil { return " " } return * t . Default } 
func ( t * Template Variable ) Get Default Ok ( ) ( string , bool ) { if t = = nil | | t . Default = = nil { return " " , false } return * t . Default , true } 
func ( t * Template Variable ) Has Default ( ) bool { if t ! = nil & & t . Default ! = nil { return true } return false } 
func ( t * Template Variable ) Get Name ( ) string { if t = = nil | | t . Name = = nil { return " " } return * t . Name } 
func ( t * Template Variable ) Get Name Ok ( ) ( string , bool ) { if t = = nil | | t . Name = = nil { return " " , false } return * t . Name , true } 
func ( t * Template Variable ) Has Name ( ) bool { if t ! = nil & & t . Name ! = nil { return true } return false } 
func ( t * Template Variable ) Get Prefix ( ) string { if t = = nil | | t . Prefix = = nil { return " " } return * t . Prefix } 
func ( t * Template Variable ) Get Prefix Ok ( ) ( string , bool ) { if t = = nil | | t . Prefix = = nil { return " " , false } return * t . Prefix , true } 
func ( t * Template Variable ) Has Prefix ( ) bool { if t ! = nil & & t . Prefix ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Critical ( ) json . Number { if t = = nil | | t . Critical = = nil { return " " } return * t . Critical } 
func ( t * Threshold Count ) Get Critical Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Critical = = nil { return " " , false } return * t . Critical , true } 
func ( t * Threshold Count ) Has Critical ( ) bool { if t ! = nil & & t . Critical ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Critical Recovery ( ) json . Number { if t = = nil | | t . Critical Recovery = = nil { return " " } return * t . Critical Recovery } 
func ( t * Threshold Count ) Get Critical Recovery Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Critical Recovery = = nil { return " " , false } return * t . Critical Recovery , true } 
func ( t * Threshold Count ) Has Critical Recovery ( ) bool { if t ! = nil & & t . Critical Recovery ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Ok ( ) json . Number { if t = = nil | | t . Ok = = nil { return " " } return * t . Ok } 
func ( t * Threshold Count ) Get Ok Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Ok = = nil { return " " , false } return * t . Ok , true } 
func ( t * Threshold Count ) Has Ok ( ) bool { if t ! = nil & & t . Ok ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Period ( ) Period { if t = = nil | | t . Period = = nil { return Period { } } return * t . Period } 
func ( t * Threshold Count ) Get Period Ok ( ) ( Period , bool ) { if t = = nil | | t . Period = = nil { return Period { } , false } return * t . Period , true } 
func ( t * Threshold Count ) Has Period ( ) bool { if t ! = nil & & t . Period ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Time Aggregator ( ) string { if t = = nil | | t . Time Aggregator = = nil { return " " } return * t . Time Aggregator } 
func ( t * Threshold Count ) Get Time Aggregator Ok ( ) ( string , bool ) { if t = = nil | | t . Time Aggregator = = nil { return " " , false } return * t . Time Aggregator , true } 
func ( t * Threshold Count ) Has Time Aggregator ( ) bool { if t ! = nil & & t . Time Aggregator ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Unknown ( ) json . Number { if t = = nil | | t . Unknown = = nil { return " " } return * t . Unknown } 
func ( t * Threshold Count ) Get Unknown Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Unknown = = nil { return " " , false } return * t . Unknown , true } 
func ( t * Threshold Count ) Has Unknown ( ) bool { if t ! = nil & & t . Unknown ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Warning ( ) json . Number { if t = = nil | | t . Warning = = nil { return " " } return * t . Warning } 
func ( t * Threshold Count ) Get Warning Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Warning = = nil { return " " , false } return * t . Warning , true } 
func ( t * Threshold Count ) Has Warning ( ) bool { if t ! = nil & & t . Warning ! = nil { return true } return false } 
func ( t * Threshold Count ) Get Warning Recovery ( ) json . Number { if t = = nil | | t . Warning Recovery = = nil { return " " } return * t . Warning Recovery } 
func ( t * Threshold Count ) Get Warning Recovery Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Warning Recovery = = nil { return " " , false } return * t . Warning Recovery , true } 
func ( t * Threshold Count ) Has Warning Recovery ( ) bool { if t ! = nil & & t . Warning Recovery ! = nil { return true } return false } 
func ( t * Threshold Windows ) Get Recovery Window ( ) string { if t = = nil | | t . Recovery Window = = nil { return " " } return * t . Recovery Window } 
func ( t * Threshold Windows ) Get Recovery Window Ok ( ) ( string , bool ) { if t = = nil | | t . Recovery Window = = nil { return " " , false } return * t . Recovery Window , true } 
func ( t * Threshold Windows ) Has Recovery Window ( ) bool { if t ! = nil & & t . Recovery Window ! = nil { return true } return false } 
func ( t * Threshold Windows ) Get Trigger Window ( ) string { if t = = nil | | t . Trigger Window = = nil { return " " } return * t . Trigger Window } 
func ( t * Threshold Windows ) Get Trigger Window Ok ( ) ( string , bool ) { if t = = nil | | t . Trigger Window = = nil { return " " , false } return * t . Trigger Window , true } 
func ( t * Threshold Windows ) Has Trigger Window ( ) bool { if t ! = nil & & t . Trigger Window ! = nil { return true } return false } 
func ( t * Tile Def ) Get Autoscale ( ) bool { if t = = nil | | t . Autoscale = = nil { return false } return * t . Autoscale } 
func ( t * Tile Def ) Get Autoscale Ok ( ) ( bool , bool ) { if t = = nil | | t . Autoscale = = nil { return false , false } return * t . Autoscale , true } 
func ( t * Tile Def ) Has Autoscale ( ) bool { if t ! = nil & & t . Autoscale ! = nil { return true } return false } 
func ( t * Tile Def ) Get Custom Unit ( ) string { if t = = nil | | t . Custom Unit = = nil { return " " } return * t . Custom Unit } 
func ( t * Tile Def ) Get Custom Unit Ok ( ) ( string , bool ) { if t = = nil | | t . Custom Unit = = nil { return " " , false } return * t . Custom Unit , true } 
func ( t * Tile Def ) Has Custom Unit ( ) bool { if t ! = nil & & t . Custom Unit ! = nil { return true } return false } 
func ( t * Tile Def ) Get Node Type ( ) string { if t = = nil | | t . Node Type = = nil { return " " } return * t . Node Type } 
func ( t * Tile Def ) Get Node Type Ok ( ) ( string , bool ) { if t = = nil | | t . Node Type = = nil { return " " , false } return * t . Node Type , true } 
func ( t * Tile Def ) Has Node Type ( ) bool { if t ! = nil & & t . Node Type ! = nil { return true } return false } 
func ( t * Tile Def ) Get No Group Hosts ( ) bool { if t = = nil | | t . No Group Hosts = = nil { return false } return * t . No Group Hosts } 
func ( t * Tile Def ) Get No Group Hosts Ok ( ) ( bool , bool ) { if t = = nil | | t . No Group Hosts = = nil { return false , false } return * t . No Group Hosts , true } 
func ( t * Tile Def ) Has No Group Hosts ( ) bool { if t ! = nil & & t . No Group Hosts ! = nil { return true } return false } 
func ( t * Tile Def ) Get No Metric Hosts ( ) bool { if t = = nil | | t . No Metric Hosts = = nil { return false } return * t . No Metric Hosts } 
func ( t * Tile Def ) Get No Metric Hosts Ok ( ) ( bool , bool ) { if t = = nil | | t . No Metric Hosts = = nil { return false , false } return * t . No Metric Hosts , true } 
func ( t * Tile Def ) Has No Metric Hosts ( ) bool { if t ! = nil & & t . No Metric Hosts ! = nil { return true } return false } 
func ( t * Tile Def ) Get Precision ( ) Precision T { if t = = nil | | t . Precision = = nil { return " " } return * t . Precision } 
func ( t * Tile Def ) Get Precision Ok ( ) ( Precision T , bool ) { if t = = nil | | t . Precision = = nil { return " " , false } return * t . Precision , true } 
func ( t * Tile Def ) Has Precision ( ) bool { if t ! = nil & & t . Precision ! = nil { return true } return false } 
func ( t * Tile Def ) Get Style ( ) Tile Def Style { if t = = nil | | t . Style = = nil { return Tile Def Style { } } return * t . Style } 
func ( t * Tile Def ) Get Style Ok ( ) ( Tile Def Style , bool ) { if t = = nil | | t . Style = = nil { return Tile Def Style { } , false } return * t . Style , true } 
func ( t * Tile Def ) Has Style ( ) bool { if t ! = nil & & t . Style ! = nil { return true } return false } 
func ( t * Tile Def ) Get Text Align ( ) string { if t = = nil | | t . Text Align = = nil { return " " } return * t . Text Align } 
func ( t * Tile Def ) Get Text Align Ok ( ) ( string , bool ) { if t = = nil | | t . Text Align = = nil { return " " , false } return * t . Text Align , true } 
func ( t * Tile Def ) Has Text Align ( ) bool { if t ! = nil & & t . Text Align ! = nil { return true } return false } 
func ( t * Tile Def ) Get Viz ( ) string { if t = = nil | | t . Viz = = nil { return " " } return * t . Viz } 
func ( t * Tile Def ) Get Viz Ok ( ) ( string , bool ) { if t = = nil | | t . Viz = = nil { return " " , false } return * t . Viz , true } 
func ( t * Tile Def ) Has Viz ( ) bool { if t ! = nil & & t . Viz ! = nil { return true } return false } 
func ( t * Tile Def Event ) Get Query ( ) string { if t = = nil | | t . Query = = nil { return " " } return * t . Query } 
func ( t * Tile Def Event ) Get Query Ok ( ) ( string , bool ) { if t = = nil | | t . Query = = nil { return " " , false } return * t . Query , true } 
func ( t * Tile Def Event ) Has Query ( ) bool { if t ! = nil & & t . Query ! = nil { return true } return false } 
func ( t * Tile Def Marker ) Get Label ( ) string { if t = = nil | | t . Label = = nil { return " " } return * t . Label } 
func ( t * Tile Def Marker ) Get Label Ok ( ) ( string , bool ) { if t = = nil | | t . Label = = nil { return " " , false } return * t . Label , true } 
func ( t * Tile Def Marker ) Has Label ( ) bool { if t ! = nil & & t . Label ! = nil { return true } return false } 
func ( t * Tile Def Marker ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Tile Def Marker ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Tile Def Marker ) Get Value ( ) string { if t = = nil | | t . Value = = nil { return " " } return * t . Value } 
func ( t * Tile Def Marker ) Get Value Ok ( ) ( string , bool ) { if t = = nil | | t . Value = = nil { return " " , false } return * t . Value , true } 
func ( t * Tile Def Marker ) Has Value ( ) bool { if t ! = nil & & t . Value ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Aggregator ( ) string { if t = = nil | | t . Aggregator = = nil { return " " } return * t . Aggregator } 
func ( t * Tile Def Request ) Get Aggregator Ok ( ) ( string , bool ) { if t = = nil | | t . Aggregator = = nil { return " " , false } return * t . Aggregator , true } 
func ( t * Tile Def Request ) Has Aggregator ( ) bool { if t ! = nil & & t . Aggregator ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Change Type ( ) string { if t = = nil | | t . Change Type = = nil { return " " } return * t . Change Type } 
func ( t * Tile Def Request ) Get Change Type Ok ( ) ( string , bool ) { if t = = nil | | t . Change Type = = nil { return " " , false } return * t . Change Type , true } 
func ( t * Tile Def Request ) Has Change Type ( ) bool { if t ! = nil & & t . Change Type ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Compare To ( ) string { if t = = nil | | t . Compare To = = nil { return " " } return * t . Compare To } 
func ( t * Tile Def Request ) Get Compare To Ok ( ) ( string , bool ) { if t = = nil | | t . Compare To = = nil { return " " , false } return * t . Compare To , true } 
func ( t * Tile Def Request ) Has Compare To ( ) bool { if t ! = nil & & t . Compare To ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Extra Col ( ) string { if t = = nil | | t . Extra Col = = nil { return " " } return * t . Extra Col } 
func ( t * Tile Def Request ) Get Extra Col Ok ( ) ( string , bool ) { if t = = nil | | t . Extra Col = = nil { return " " , false } return * t . Extra Col , true } 
func ( t * Tile Def Request ) Has Extra Col ( ) bool { if t ! = nil & & t . Extra Col ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Increase Good ( ) bool { if t = = nil | | t . Increase Good = = nil { return false } return * t . Increase Good } 
func ( t * Tile Def Request ) Get Increase Good Ok ( ) ( bool , bool ) { if t = = nil | | t . Increase Good = = nil { return false , false } return * t . Increase Good , true } 
func ( t * Tile Def Request ) Has Increase Good ( ) bool { if t ! = nil & & t . Increase Good ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Limit ( ) int { if t = = nil | | t . Limit = = nil { return 0 } return * t . Limit } 
func ( t * Tile Def Request ) Get Limit Ok ( ) ( int , bool ) { if t = = nil | | t . Limit = = nil { return 0 , false } return * t . Limit , true } 
func ( t * Tile Def Request ) Has Limit ( ) bool { if t ! = nil & & t . Limit ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Metric ( ) string { if t = = nil | | t . Metric = = nil { return " " } return * t . Metric } 
func ( t * Tile Def Request ) Get Metric Ok ( ) ( string , bool ) { if t = = nil | | t . Metric = = nil { return " " , false } return * t . Metric , true } 
func ( t * Tile Def Request ) Has Metric ( ) bool { if t ! = nil & & t . Metric ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Order By ( ) string { if t = = nil | | t . Order By = = nil { return " " } return * t . Order By } 
func ( t * Tile Def Request ) Get Order By Ok ( ) ( string , bool ) { if t = = nil | | t . Order By = = nil { return " " , false } return * t . Order By , true } 
func ( t * Tile Def Request ) Has Order By ( ) bool { if t ! = nil & & t . Order By ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Order Dir ( ) string { if t = = nil | | t . Order Dir = = nil { return " " } return * t . Order Dir } 
func ( t * Tile Def Request ) Get Order Dir Ok ( ) ( string , bool ) { if t = = nil | | t . Order Dir = = nil { return " " , false } return * t . Order Dir , true } 
func ( t * Tile Def Request ) Has Order Dir ( ) bool { if t ! = nil & & t . Order Dir ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Query ( ) string { if t = = nil | | t . Query = = nil { return " " } return * t . Query } 
func ( t * Tile Def Request ) Has Query ( ) bool { if t ! = nil & & t . Query ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Query Type ( ) string { if t = = nil | | t . Query Type = = nil { return " " } return * t . Query Type } 
func ( t * Tile Def Request ) Get Query Type Ok ( ) ( string , bool ) { if t = = nil | | t . Query Type = = nil { return " " , false } return * t . Query Type , true } 
func ( t * Tile Def Request ) Has Query Type ( ) bool { if t ! = nil & & t . Query Type ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Style ( ) Tile Def Request Style { if t = = nil | | t . Style = = nil { return Tile Def Request Style { } } return * t . Style } 
func ( t * Tile Def Request ) Get Style Ok ( ) ( Tile Def Request Style , bool ) { if t = = nil | | t . Style = = nil { return Tile Def Request Style { } , false } return * t . Style , true } 
func ( t * Tile Def Request ) Has Style ( ) bool { if t ! = nil & & t . Style ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Text Filter ( ) string { if t = = nil | | t . Text Filter = = nil { return " " } return * t . Text Filter } 
func ( t * Tile Def Request ) Get Text Filter Ok ( ) ( string , bool ) { if t = = nil | | t . Text Filter = = nil { return " " , false } return * t . Text Filter , true } 
func ( t * Tile Def Request ) Has Text Filter ( ) bool { if t ! = nil & & t . Text Filter ! = nil { return true } return false } 
func ( t * Tile Def Request ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Tile Def Request ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Tile Def Request Style ) Get Palette ( ) string { if t = = nil | | t . Palette = = nil { return " " } return * t . Palette } 
func ( t * Tile Def Request Style ) Get Palette Ok ( ) ( string , bool ) { if t = = nil | | t . Palette = = nil { return " " , false } return * t . Palette , true } 
func ( t * Tile Def Request Style ) Has Palette ( ) bool { if t ! = nil & & t . Palette ! = nil { return true } return false } 
func ( t * Tile Def Request Style ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Tile Def Request Style ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Tile Def Request Style ) Get Width ( ) string { if t = = nil | | t . Width = = nil { return " " } return * t . Width } 
func ( t * Tile Def Request Style ) Get Width Ok ( ) ( string , bool ) { if t = = nil | | t . Width = = nil { return " " , false } return * t . Width , true } 
func ( t * Tile Def Request Style ) Has Width ( ) bool { if t ! = nil & & t . Width ! = nil { return true } return false } 
func ( t * Tile Def Style ) Get Fill Max ( ) json . Number { if t = = nil | | t . Fill Max = = nil { return " " } return * t . Fill Max } 
func ( t * Tile Def Style ) Get Fill Max Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Fill Max = = nil { return " " , false } return * t . Fill Max , true } 
func ( t * Tile Def Style ) Has Fill Max ( ) bool { if t ! = nil & & t . Fill Max ! = nil { return true } return false } 
func ( t * Tile Def Style ) Get Fill Min ( ) json . Number { if t = = nil | | t . Fill Min = = nil { return " " } return * t . Fill Min } 
func ( t * Tile Def Style ) Get Fill Min Ok ( ) ( json . Number , bool ) { if t = = nil | | t . Fill Min = = nil { return " " , false } return * t . Fill Min , true } 
func ( t * Tile Def Style ) Has Fill Min ( ) bool { if t ! = nil & & t . Fill Min ! = nil { return true } return false } 
func ( t * Tile Def Style ) Get Palette ( ) string { if t = = nil | | t . Palette = = nil { return " " } return * t . Palette } 
func ( t * Tile Def Style ) Has Palette ( ) bool { if t ! = nil & & t . Palette ! = nil { return true } return false } 
func ( t * Tile Def Style ) Get Palette Flip ( ) string { if t = = nil | | t . Palette Flip = = nil { return " " } return * t . Palette Flip } 
func ( t * Tile Def Style ) Get Palette Flip Ok ( ) ( string , bool ) { if t = = nil | | t . Palette Flip = = nil { return " " , false } return * t . Palette Flip , true } 
func ( t * Tile Def Style ) Has Palette Flip ( ) bool { if t ! = nil & & t . Palette Flip ! = nil { return true } return false } 
func ( t * Time ) Get Live Span ( ) string { if t = = nil | | t . Live Span = = nil { return " " } return * t . Live Span } 
func ( t * Time ) Get Live Span Ok ( ) ( string , bool ) { if t = = nil | | t . Live Span = = nil { return " " , false } return * t . Live Span , true } 
func ( t * Time ) Has Live Span ( ) bool { if t ! = nil & & t . Live Span ! = nil { return true } return false } 
func ( t * Time Range ) Get From ( ) json . Number { if t = = nil | | t . From = = nil { return " " } return * t . From } 
func ( t * Time Range ) Get From Ok ( ) ( json . Number , bool ) { if t = = nil | | t . From = = nil { return " " , false } return * t . From , true } 
func ( t * Time Range ) Has From ( ) bool { if t ! = nil & & t . From ! = nil { return true } return false } 
func ( t * Time Range ) Get Live ( ) bool { if t = = nil | | t . Live = = nil { return false } return * t . Live } 
func ( t * Time Range ) Get Live Ok ( ) ( bool , bool ) { if t = = nil | | t . Live = = nil { return false , false } return * t . Live , true } 
func ( t * Time Range ) Has Live ( ) bool { if t ! = nil & & t . Live ! = nil { return true } return false } 
func ( t * Time Range ) Get To ( ) json . Number { if t = = nil | | t . To = = nil { return " " } return * t . To } 
func ( t * Time Range ) Get To Ok ( ) ( json . Number , bool ) { if t = = nil | | t . To = = nil { return " " , false } return * t . To , true } 
func ( t * Time Range ) Has To ( ) bool { if t ! = nil & & t . To ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Legend Size ( ) string { if t = = nil | | t . Legend Size = = nil { return " " } return * t . Legend Size } 
func ( t * Timeseries Definition ) Get Legend Size Ok ( ) ( string , bool ) { if t = = nil | | t . Legend Size = = nil { return " " , false } return * t . Legend Size , true } 
func ( t * Timeseries Definition ) Has Legend Size ( ) bool { if t ! = nil & & t . Legend Size ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Show Legend ( ) bool { if t = = nil | | t . Show Legend = = nil { return false } return * t . Show Legend } 
func ( t * Timeseries Definition ) Get Show Legend Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Legend = = nil { return false , false } return * t . Show Legend , true } 
func ( t * Timeseries Definition ) Has Show Legend ( ) bool { if t ! = nil & & t . Show Legend ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Time ( ) Widget Time { if t = = nil | | t . Time = = nil { return Widget Time { } } return * t . Time } 
func ( t * Timeseries Definition ) Has Time ( ) bool { if t ! = nil & & t . Time ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Title ( ) string { if t = = nil | | t . Title = = nil { return " " } return * t . Title } 
func ( t * Timeseries Definition ) Get Title Ok ( ) ( string , bool ) { if t = = nil | | t . Title = = nil { return " " , false } return * t . Title , true } 
func ( t * Timeseries Definition ) Has Title ( ) bool { if t ! = nil & & t . Title ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Title Align ( ) string { if t = = nil | | t . Title Align = = nil { return " " } return * t . Title Align } 
func ( t * Timeseries Definition ) Has Title Align ( ) bool { if t ! = nil & & t . Title Align ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Title Size ( ) string { if t = = nil | | t . Title Size = = nil { return " " } return * t . Title Size } 
func ( t * Timeseries Definition ) Get Title Size Ok ( ) ( string , bool ) { if t = = nil | | t . Title Size = = nil { return " " , false } return * t . Title Size , true } 
func ( t * Timeseries Definition ) Has Title Size ( ) bool { if t ! = nil & & t . Title Size ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Timeseries Definition ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Timeseries Definition ) Get Yaxis ( ) Widget Axis { if t = = nil | | t . Yaxis = = nil { return Widget Axis { } } return * t . Yaxis } 
func ( t * Timeseries Definition ) Get Yaxis Ok ( ) ( Widget Axis , bool ) { if t = = nil | | t . Yaxis = = nil { return Widget Axis { } , false } return * t . Yaxis , true } 
func ( t * Timeseries Definition ) Has Yaxis ( ) bool { if t ! = nil & & t . Yaxis ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Apm Query ( ) Widget Apm Or Log Query { if t = = nil | | t . Apm Query = = nil { return Widget Apm Or Log Query { } } return * t . Apm Query } 
func ( t * Timeseries Request ) Has Apm Query ( ) bool { if t ! = nil & & t . Apm Query ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Display Type ( ) string { if t = = nil | | t . Display Type = = nil { return " " } return * t . Display Type } 
func ( t * Timeseries Request ) Get Display Type Ok ( ) ( string , bool ) { if t = = nil | | t . Display Type = = nil { return " " , false } return * t . Display Type , true } 
func ( t * Timeseries Request ) Has Display Type ( ) bool { if t ! = nil & & t . Display Type ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Log Query ( ) Widget Apm Or Log Query { if t = = nil | | t . Log Query = = nil { return Widget Apm Or Log Query { } } return * t . Log Query } 
func ( t * Timeseries Request ) Get Log Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if t = = nil | | t . Log Query = = nil { return Widget Apm Or Log Query { } , false } return * t . Log Query , true } 
func ( t * Timeseries Request ) Has Log Query ( ) bool { if t ! = nil & & t . Log Query ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Metric Query ( ) string { if t = = nil | | t . Metric Query = = nil { return " " } return * t . Metric Query } 
func ( t * Timeseries Request ) Get Metric Query Ok ( ) ( string , bool ) { if t = = nil | | t . Metric Query = = nil { return " " , false } return * t . Metric Query , true } 
func ( t * Timeseries Request ) Has Metric Query ( ) bool { if t ! = nil & & t . Metric Query ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Process Query ( ) Widget Process Query { if t = = nil | | t . Process Query = = nil { return Widget Process Query { } } return * t . Process Query } 
func ( t * Timeseries Request ) Get Process Query Ok ( ) ( Widget Process Query , bool ) { if t = = nil | | t . Process Query = = nil { return Widget Process Query { } , false } return * t . Process Query , true } 
func ( t * Timeseries Request ) Has Process Query ( ) bool { if t ! = nil & & t . Process Query ! = nil { return true } return false } 
func ( t * Timeseries Request ) Get Style ( ) Timeseries Request Style { if t = = nil | | t . Style = = nil { return Timeseries Request Style { } } return * t . Style } 
func ( t * Timeseries Request ) Get Style Ok ( ) ( Timeseries Request Style , bool ) { if t = = nil | | t . Style = = nil { return Timeseries Request Style { } , false } return * t . Style , true } 
func ( t * Timeseries Request ) Has Style ( ) bool { if t ! = nil & & t . Style ! = nil { return true } return false } 
func ( t * Timeseries Request Style ) Get Line Type ( ) string { if t = = nil | | t . Line Type = = nil { return " " } return * t . Line Type } 
func ( t * Timeseries Request Style ) Get Line Type Ok ( ) ( string , bool ) { if t = = nil | | t . Line Type = = nil { return " " , false } return * t . Line Type , true } 
func ( t * Timeseries Request Style ) Has Line Type ( ) bool { if t ! = nil & & t . Line Type ! = nil { return true } return false } 
func ( t * Timeseries Request Style ) Get Line Width ( ) string { if t = = nil | | t . Line Width = = nil { return " " } return * t . Line Width } 
func ( t * Timeseries Request Style ) Get Line Width Ok ( ) ( string , bool ) { if t = = nil | | t . Line Width = = nil { return " " , false } return * t . Line Width , true } 
func ( t * Timeseries Request Style ) Has Line Width ( ) bool { if t ! = nil & & t . Line Width ! = nil { return true } return false } 
func ( t * Timeseries Request Style ) Get Palette ( ) string { if t = = nil | | t . Palette = = nil { return " " } return * t . Palette } 
func ( t * Timeseries Request Style ) Has Palette ( ) bool { if t ! = nil & & t . Palette ! = nil { return true } return false } 
func ( t * Toggle Status ) Get New Status ( ) string { if t = = nil | | t . New Status = = nil { return " " } return * t . New Status } 
func ( t * Toggle Status ) Get New Status Ok ( ) ( string , bool ) { if t = = nil | | t . New Status = = nil { return " " , false } return * t . New Status , true } 
func ( t * Toggle Status ) Has New Status ( ) bool { if t ! = nil & & t . New Status ! = nil { return true } return false } 
func ( t * Toplist Definition ) Get Time ( ) Widget Time { if t = = nil | | t . Time = = nil { return Widget Time { } } return * t . Time } 
func ( t * Toplist Definition ) Has Time ( ) bool { if t ! = nil & & t . Time ! = nil { return true } return false } 
func ( t * Toplist Definition ) Get Title ( ) string { if t = = nil | | t . Title = = nil { return " " } return * t . Title } 
func ( t * Toplist Definition ) Has Title ( ) bool { if t ! = nil & & t . Title ! = nil { return true } return false } 
func ( t * Toplist Definition ) Get Title Align ( ) string { if t = = nil | | t . Title Align = = nil { return " " } return * t . Title Align } 
func ( t * Toplist Definition ) Has Title Align ( ) bool { if t ! = nil & & t . Title Align ! = nil { return true } return false } 
func ( t * Toplist Definition ) Get Title Size ( ) string { if t = = nil | | t . Title Size = = nil { return " " } return * t . Title Size } 
func ( t * Toplist Definition ) Has Title Size ( ) bool { if t ! = nil & & t . Title Size ! = nil { return true } return false } 
func ( t * Toplist Definition ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Toplist Definition ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Toplist Request ) Get Apm Query ( ) Widget Apm Or Log Query { if t = = nil | | t . Apm Query = = nil { return Widget Apm Or Log Query { } } return * t . Apm Query } 
func ( t * Toplist Request ) Get Apm Query Ok ( ) ( Widget Apm Or Log Query , bool ) { if t = = nil | | t . Apm Query = = nil { return Widget Apm Or Log Query { } , false } return * t . Apm Query , true } 
func ( t * Toplist Request ) Has Apm Query ( ) bool { if t ! = nil & & t . Apm Query ! = nil { return true } return false } 
func ( t * Toplist Request ) Get Log Query ( ) Widget Apm Or Log Query { if t = = nil | | t . Log Query = = nil { return Widget Apm Or Log Query { } } return * t . Log Query } 
func ( t * Toplist Request ) Has Log Query ( ) bool { if t ! = nil & & t . Log Query ! = nil { return true } return false } 
func ( t * Toplist Request ) Get Metric Query ( ) string { if t = = nil | | t . Metric Query = = nil { return " " } return * t . Metric Query } 
func ( t * Toplist Request ) Has Metric Query ( ) bool { if t ! = nil & & t . Metric Query ! = nil { return true } return false } 
func ( t * Toplist Request ) Get Process Query ( ) Widget Process Query { if t = = nil | | t . Process Query = = nil { return Widget Process Query { } } return * t . Process Query } 
func ( t * Toplist Request ) Has Process Query ( ) bool { if t ! = nil & & t . Process Query ! = nil { return true } return false } 
func ( t * Toplist Request ) Get Style ( ) Widget Request Style { if t = = nil | | t . Style = = nil { return Widget Request Style { } } return * t . Style } 
func ( t * Toplist Request ) Get Style Ok ( ) ( Widget Request Style , bool ) { if t = = nil | | t . Style = = nil { return Widget Request Style { } , false } return * t . Style , true } 
func ( t * Toplist Request ) Has Style ( ) bool { if t ! = nil & & t . Style ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Display Format ( ) string { if t = = nil | | t . Display Format = = nil { return " " } return * t . Display Format } 
func ( t * Trace Service Definition ) Get Display Format Ok ( ) ( string , bool ) { if t = = nil | | t . Display Format = = nil { return " " , false } return * t . Display Format , true } 
func ( t * Trace Service Definition ) Has Display Format ( ) bool { if t ! = nil & & t . Display Format ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Env ( ) string { if t = = nil | | t . Env = = nil { return " " } return * t . Env } 
func ( t * Trace Service Definition ) Get Env Ok ( ) ( string , bool ) { if t = = nil | | t . Env = = nil { return " " , false } return * t . Env , true } 
func ( t * Trace Service Definition ) Has Env ( ) bool { if t ! = nil & & t . Env ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Service ( ) string { if t = = nil | | t . Service = = nil { return " " } return * t . Service } 
func ( t * Trace Service Definition ) Get Service Ok ( ) ( string , bool ) { if t = = nil | | t . Service = = nil { return " " , false } return * t . Service , true } 
func ( t * Trace Service Definition ) Has Service ( ) bool { if t ! = nil & & t . Service ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Breakdown ( ) bool { if t = = nil | | t . Show Breakdown = = nil { return false } return * t . Show Breakdown } 
func ( t * Trace Service Definition ) Get Show Breakdown Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Breakdown = = nil { return false , false } return * t . Show Breakdown , true } 
func ( t * Trace Service Definition ) Has Show Breakdown ( ) bool { if t ! = nil & & t . Show Breakdown ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Distribution ( ) bool { if t = = nil | | t . Show Distribution = = nil { return false } return * t . Show Distribution } 
func ( t * Trace Service Definition ) Get Show Distribution Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Distribution = = nil { return false , false } return * t . Show Distribution , true } 
func ( t * Trace Service Definition ) Has Show Distribution ( ) bool { if t ! = nil & & t . Show Distribution ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Errors ( ) bool { if t = = nil | | t . Show Errors = = nil { return false } return * t . Show Errors } 
func ( t * Trace Service Definition ) Get Show Errors Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Errors = = nil { return false , false } return * t . Show Errors , true } 
func ( t * Trace Service Definition ) Has Show Errors ( ) bool { if t ! = nil & & t . Show Errors ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Hits ( ) bool { if t = = nil | | t . Show Hits = = nil { return false } return * t . Show Hits } 
func ( t * Trace Service Definition ) Get Show Hits Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Hits = = nil { return false , false } return * t . Show Hits , true } 
func ( t * Trace Service Definition ) Has Show Hits ( ) bool { if t ! = nil & & t . Show Hits ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Latency ( ) bool { if t = = nil | | t . Show Latency = = nil { return false } return * t . Show Latency } 
func ( t * Trace Service Definition ) Get Show Latency Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Latency = = nil { return false , false } return * t . Show Latency , true } 
func ( t * Trace Service Definition ) Has Show Latency ( ) bool { if t ! = nil & & t . Show Latency ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Show Resource List ( ) bool { if t = = nil | | t . Show Resource List = = nil { return false } return * t . Show Resource List } 
func ( t * Trace Service Definition ) Get Show Resource List Ok ( ) ( bool , bool ) { if t = = nil | | t . Show Resource List = = nil { return false , false } return * t . Show Resource List , true } 
func ( t * Trace Service Definition ) Has Show Resource List ( ) bool { if t ! = nil & & t . Show Resource List ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Size Format ( ) string { if t = = nil | | t . Size Format = = nil { return " " } return * t . Size Format } 
func ( t * Trace Service Definition ) Get Size Format Ok ( ) ( string , bool ) { if t = = nil | | t . Size Format = = nil { return " " , false } return * t . Size Format , true } 
func ( t * Trace Service Definition ) Has Size Format ( ) bool { if t ! = nil & & t . Size Format ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Span Name ( ) string { if t = = nil | | t . Span Name = = nil { return " " } return * t . Span Name } 
func ( t * Trace Service Definition ) Get Span Name Ok ( ) ( string , bool ) { if t = = nil | | t . Span Name = = nil { return " " , false } return * t . Span Name , true } 
func ( t * Trace Service Definition ) Has Span Name ( ) bool { if t ! = nil & & t . Span Name ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Time ( ) Widget Time { if t = = nil | | t . Time = = nil { return Widget Time { } } return * t . Time } 
func ( t * Trace Service Definition ) Get Time Ok ( ) ( Widget Time , bool ) { if t = = nil | | t . Time = = nil { return Widget Time { } , false } return * t . Time , true } 
func ( t * Trace Service Definition ) Has Time ( ) bool { if t ! = nil & & t . Time ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Title ( ) string { if t = = nil | | t . Title = = nil { return " " } return * t . Title } 
func ( t * Trace Service Definition ) Has Title ( ) bool { if t ! = nil & & t . Title ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Title Align ( ) string { if t = = nil | | t . Title Align = = nil { return " " } return * t . Title Align } 
func ( t * Trace Service Definition ) Get Title Align Ok ( ) ( string , bool ) { if t = = nil | | t . Title Align = = nil { return " " , false } return * t . Title Align , true } 
func ( t * Trace Service Definition ) Has Title Align ( ) bool { if t ! = nil & & t . Title Align ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Title Size ( ) string { if t = = nil | | t . Title Size = = nil { return " " } return * t . Title Size } 
func ( t * Trace Service Definition ) Has Title Size ( ) bool { if t ! = nil & & t . Title Size ! = nil { return true } return false } 
func ( t * Trace Service Definition ) Get Type ( ) string { if t = = nil | | t . Type = = nil { return " " } return * t . Type } 
func ( t * Trace Service Definition ) Get Type Ok ( ) ( string , bool ) { if t = = nil | | t . Type = = nil { return " " , false } return * t . Type , true } 
func ( t * Trace Service Definition ) Has Type ( ) bool { if t ! = nil & & t . Type ! = nil { return true } return false } 
func ( t * Triggering Value ) Get From Ts ( ) int { if t = = nil | | t . From Ts = = nil { return 0 } return * t . From Ts } 
func ( t * Triggering Value ) Get From Ts Ok ( ) ( int , bool ) { if t = = nil | | t . From Ts = = nil { return 0 , false } return * t . From Ts , true } 
func ( t * Triggering Value ) Has From Ts ( ) bool { if t ! = nil & & t . From Ts ! = nil { return true } return false } 
func ( t * Triggering Value ) Get To Ts ( ) int { if t = = nil | | t . To Ts = = nil { return 0 } return * t . To Ts } 
func ( t * Triggering Value ) Get To Ts Ok ( ) ( int , bool ) { if t = = nil | | t . To Ts = = nil { return 0 , false } return * t . To Ts , true } 
func ( t * Triggering Value ) Has To Ts ( ) bool { if t ! = nil & & t . To Ts ! = nil { return true } return false } 
func ( t * Triggering Value ) Get Value ( ) int { if t = = nil | | t . Value = = nil { return 0 } return * t . Value } 
func ( t * Triggering Value ) Get Value Ok ( ) ( int , bool ) { if t = = nil | | t . Value = = nil { return 0 , false } return * t . Value , true } 
func ( t * Triggering Value ) Has Value ( ) bool { if t ! = nil & & t . Value ! = nil { return true } return false } 
func ( u * User ) Get Access Role ( ) string { if u = = nil | | u . Access Role = = nil { return " " } return * u . Access Role } 
func ( u * User ) Get Access Role Ok ( ) ( string , bool ) { if u = = nil | | u . Access Role = = nil { return " " , false } return * u . Access Role , true } 
func ( u * User ) Has Access Role ( ) bool { if u ! = nil & & u . Access Role ! = nil { return true } return false } 
func ( u * User ) Get Disabled ( ) bool { if u = = nil | | u . Disabled = = nil { return false } return * u . Disabled } 
func ( u * User ) Get Disabled Ok ( ) ( bool , bool ) { if u = = nil | | u . Disabled = = nil { return false , false } return * u . Disabled , true } 
func ( u * User ) Has Disabled ( ) bool { if u ! = nil & & u . Disabled ! = nil { return true } return false } 
func ( u * User ) Get Email Ok ( ) ( string , bool ) { if u = = nil | | u . Email = = nil { return " " , false } return * u . Email , true } 
func ( u * User ) Has Email ( ) bool { if u ! = nil & & u . Email ! = nil { return true } return false } 
func ( u * User ) Get Handle ( ) string { if u = = nil | | u . Handle = = nil { return " " } return * u . Handle } 
func ( u * User ) Get Handle Ok ( ) ( string , bool ) { if u = = nil | | u . Handle = = nil { return " " , false } return * u . Handle , true } 

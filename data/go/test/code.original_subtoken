func must Wait Pin Ready ( t * testing . T , cli * clientv 3 . Client ) { _ , err : = cli . Get ( ctx , " " ) cancel ( ) if err ! = nil { t . Fatal ( err ) } } 
func new Gateway Command ( ) * cobra . Command { lpc : = & cobra . Command { Use : " " , Short : " " , } lpc . Add Command ( new Gateway Start Command ( ) ) return lpc } 
func New Limited Buffer Reader ( r io . Reader , n int ) io . Reader { return & limited Buffer Reader { r : r , n : n , } } 
func With Abort Context ( ctx context . Context ) stm Option { return func ( so * stm Options ) { so . ctx = ctx } } 
func With Prefetch ( keys . . . string ) stm Option { return func ( so * stm Options ) { so . prefetch = append ( so . prefetch , keys . . . ) } } 
func New STM ( c * v 3 . Client , apply func ( STM ) error , so . . . stm Option ) ( * v 3 . Txn Response , error ) { opts : = & stm Options { ctx : c . Ctx ( ) } for _ , f : = range so { f ( opts ) } if len ( opts . prefetch ) ! = 0 { f : = apply apply = func ( s STM ) error { s . Get ( opts . prefetch . . . ) return f ( s ) } } return run STM ( mk STM ( c , opts ) , apply ) } 
func ( rs read Set ) first ( ) int 6 4 { ret : = int 6 4 ( math . Max Int 6 4 - 1 ) for _ , resp : = range rs { if rev : = resp . Header . Revision ; rev < ret { ret = rev } } return ret } 
func ( rs read Set ) cmps ( ) [ ] v 3 . Cmp { cmps : = make ( [ ] v 3 . Cmp , 0 , len ( rs ) ) for k , rk : = range rs { cmps = append ( cmps , is Key Current ( k , rk ) ) } return cmps } 
func ( ws write Set ) cmps ( rev int 6 4 ) [ ] v 3 . Cmp { cmps : = make ( [ ] v 3 . Cmp , 0 , len ( ws ) ) for key : = range ws { cmps = append ( cmps , v 3 . Compare ( v 3 . Mod Revision ( key ) , " " , rev ) ) } return cmps } 
func ( ws write Set ) puts ( ) [ ] v 3 . Op { puts : = make ( [ ] v 3 . Op , 0 , len ( ws ) ) for _ , v : = range ws { puts = append ( puts , v . op ) } return puts } 
func New STMRepeatable ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { return New STM ( c , apply , With Abort Context ( ctx ) , With Isolation ( Repeatable Reads ) ) } 
func New STMSerializable ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { return New STM ( c , apply , With Abort Context ( ctx ) , With Isolation ( Serializable ) ) } 
func New STMRead Committed ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { return New STM ( c , apply , With Abort Context ( ctx ) , With Isolation ( Read Committed ) ) } 
func New Cert Pool ( CAFiles [ ] string ) ( * x 5 0 9 . Cert Pool , error ) { cert Pool : = x 5 0 9 . New Cert Pool ( ) for _ , CAFile : = range CAFiles { pem Byte , err : = ioutil . Read File ( CAFile ) if err ! = nil { return nil , err } for { var block * pem . Block block , pem Byte = pem . Decode ( pem Byte ) if block = = nil { break } cert , err : = x 5 0 9 . Parse Certificate ( block . Bytes ) if err ! = nil { return nil , err } cert Pool . Add Cert ( cert ) } } return cert Pool , nil } 
func New Cert ( certfile , keyfile string , parse Func func ( [ ] byte , [ ] byte ) ( tls . Certificate , error ) ) ( * tls . Certificate , error ) { cert , err : = ioutil . Read File ( certfile ) if err ! = nil { return nil , err } key , err : = ioutil . Read File ( keyfile ) if err ! = nil { return nil , err } if parse Func = = nil { parse Func = tls . X 5 0 9Key Pair } tls Cert , err : = parse Func ( cert , key ) if err ! = nil { return nil , err } return & tls Cert , nil } 
func New GRPCLogger V 2 ( lcfg zap . Config ) ( grpclog . Logger V 2 , error ) { lg , err : = lcfg . Build ( zap . Add Caller Skip ( 1 ) ) if err ! = nil { return nil , err } return & zap GRPCLogger { lg : lg , sugar : lg . Sugar ( ) } , nil } 
func New GRPCLogger V 2From Zap Core ( cr zapcore . Core , syncer zapcore . Write Syncer ) grpclog . Logger V 2 { return & zap GRPCLogger { lg : lg , sugar : lg . Sugar ( ) } } 
func ( p * peer ) Pause ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = true p . msg App Reader . pause ( ) p . msg App V 2Reader . pause ( ) } 
func ( p * peer ) Resume ( ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) p . paused = false p . msg App Reader . resume ( ) p . msg App V 2Reader . resume ( ) } 
func ( p * peer ) pick ( m raftpb . Message ) ( writec chan < - raftpb . Message , picked string ) { var ok bool } else if writec , ok = p . msg App V 2Writer . writec ( ) ; ok & & is Msg App ( m ) { return writec , stream App V 2 } else if writec , ok = p . writer . writec ( ) ; ok { return writec , stream Msg } return p . pipeline . msgc , pipeline Msg } 
func ( s * snapshot Sender ) post ( req * http . Request ) ( err error ) { ctx , cancel : = context . With Cancel ( context . Background ( ) ) req = req . With Context ( ctx ) defer cancel ( ) type response And Error struct { resp * http . Response body [ ] byte err error } result : = make ( chan response And Error , 1 ) go func ( ) { resp , err : = s . tr . pipeline Rt . Round Trip ( req ) if err ! = nil { result < - response And Error { resp , nil , err } return } body , err : = ioutil . Read All ( resp . Body ) result < - response And Error { resp , body , err } } ( ) select { case < - s . stopc : return err Stopped case r : = < - result : if r . err ! = nil { return r . err } return check Post Response ( r . resp , r . body , req , s . to ) } } 
func new Txn Resp ( rt * pb . Txn Request , txn Path [ ] bool ) ( txn Resp * pb . Txn Response , txn Count int ) { reqs : = rt . Success if ! txn Path [ 0 ] { reqs = rt . Failure } resps : = make ( [ ] * pb . Response Op , len ( reqs ) ) txn Resp = & pb . Txn Response { Responses : resps , Succeeded : txn Path [ 0 ] , Header : & pb . Response Header { } , } for i , req : = range reqs { switch tv : = req . Request . ( type ) { case * pb . Request Op _Request Range : resps [ i ] = & pb . Response Op { Response : & pb . Response Op _Response Range { } } case * pb . Request Op _Request Put : resps [ i ] = & pb . Response Op { Response : & pb . Response Op _Response Put { } } case * pb . Request Op _Request Delete Range : resps [ i ] = & pb . Response Op { Response : & pb . Response Op _Response Delete Range { } } case * pb . Request Op _Request Txn : resp , txns : = new Txn Resp ( tv . Request Txn , txn Path [ 1 : ] ) resps [ i ] = & pb . Response Op { Response : & pb . Response Op _Response Txn { Response Txn : resp } } txn Path = txn Path [ 1 + txns : ] txn Count + = txns + 1 default : } } return txn Resp , txn Count } 
func apply Compare ( rv mvcc . Read View , c * pb . Compare ) bool { if err ! = nil { return false } if len ( rr . KVs ) = = 0 { if c . Target = = pb . Compare _VALUE { } return compare KV ( c , mvccpb . Key Value { } ) } for _ , kv : = range rr . KVs { if ! compare KV ( c , kv ) { return false } } return true } 
func Op Compact ( rev int 6 4 , opts . . . Compact Option ) Compact Op { ret : = Compact Op { revision : rev } ret . apply Compact Opts ( opts ) return ret } 
func New Priority Queue ( client * v 3 . Client , key string ) * Priority Queue { return & Priority Queue { client , context . TODO ( ) , key + " " } } 
func ( q * Priority Queue ) Enqueue ( val string , pr uint 1 6 ) error { prefix : = fmt . Sprintf ( " " , q . key , pr ) _ , err : = new Sequential KV ( q . client , prefix , val ) return err } 
func New Leader Stats ( id string ) * Leader Stats { return & Leader Stats { leader Stats : leader Stats { Leader : id , Followers : make ( map [ string ] * Follower Stats ) , } , } } 
func ( fs * Follower Stats ) Succ ( d time . Duration ) { fs . Lock ( ) defer fs . Unlock ( ) total : = float 6 4 ( fs . Counts . Success ) * fs . Latency . Average total Square : = float 6 4 ( fs . Counts . Success ) * fs . Latency . average Square fs . Counts . Success + + fs . Latency . Current = float 6 4 ( d ) / ( 1 0 0 0 0 0 0 . 0 ) if fs . Latency . Current > fs . Latency . Maximum { fs . Latency . Maximum = fs . Latency . Current } if fs . Latency . Current < fs . Latency . Minimum { fs . Latency . Minimum = fs . Latency . Current } fs . Latency . Average = ( total + fs . Latency . Current ) / float 6 4 ( fs . Counts . Success ) fs . Latency . average Square = ( total Square + fs . Latency . Current * fs . Latency . Current ) / float 6 4 ( fs . Counts . Success ) } 
func ( fs * Follower Stats ) Fail ( ) { fs . Lock ( ) defer fs . Unlock ( ) fs . Counts . Fail + + } 
func ( wbs * watch Broadcasts ) delete ( w * watcher ) int { wbs . mu . Lock ( ) defer wbs . mu . Unlock ( ) wb , ok : = wbs . watchers [ w ] if ! ok { panic ( " " ) } delete ( wbs . watchers , w ) wb . delete ( w ) if wb . empty ( ) { delete ( wbs . bcasts , wb ) wb . stop ( ) } return len ( wbs . bcasts ) } 
func start Stream Writer ( lg * zap . Logger , local , id types . ID , status * peer Status , fs * stats . Follower Stats , r Raft ) * stream Writer { w : = & stream Writer { lg : lg , local ID : local , peer ID : id , status : status , fs : fs , r : r , msgc : make ( chan raftpb . Message , stream Buf Size ) , connc : make ( chan * outgoing Conn ) , stopc : make ( chan struct { } ) , done : make ( chan struct { } ) , } go w . run ( ) return w } 
func check Stream Support ( v * semver . Version , t stream Type ) bool { nv : = & semver . Version { Major : v . Major , Minor : v . Minor } for _ , s : = range supported Stream [ nv . String ( ) ] { if s = = t { return true } } return false } 
func ( pr * Progress ) maybe Update ( n uint 6 4 ) bool { var updated bool if pr . Match < n { pr . Match = n updated = true pr . resume ( ) } if pr . Next < n + 1 { pr . Next = n + 1 } return updated } 
func ( pr * Progress ) maybe Decr To ( rejected , last uint 6 4 ) bool { if pr . State = = Progress State Replicate { } return true } } if pr . Next = min ( rejected , last + 1 ) ; pr . Next < 1 { pr . Next = 1 } pr . resume ( ) return true } 
func ( pr * Progress ) Is Paused ( ) bool { switch pr . State { case Progress State Probe : return pr . Paused case Progress State Replicate : return pr . ins . full ( ) case Progress State Snapshot : return true default : panic ( " " ) } } 
func ( pr * Progress ) need Snapshot Abort ( ) bool { return pr . State = = Progress State Snapshot & & pr . Match > = pr . Pending Snapshot } 
func ( in * inflights ) add ( inflight uint 6 4 ) { if in . full ( ) { panic ( " " ) } next : = in . start + in . count size : = in . size if next > = size { next - = size } if next > = len ( in . buffer ) { in . grow Buf ( ) } in . buffer [ next ] = inflight in . count + + } 
func ( in * inflights ) grow Buf ( ) { new Size : = len ( in . buffer ) * 2 if new Size = = 0 { new Size = 1 } else if new Size > in . size { new Size = in . size } new Buffer : = make ( [ ] uint 6 4 , new Size ) copy ( new Buffer , in . buffer ) in . buffer = new Buffer } 
func ( in * inflights ) free To ( to uint 6 4 ) { if in . count = = 0 | | to < in . buffer [ in . start ] { } idx : = in . start var i int for i = 0 ; i < in . count ; i + + { if to < in . buffer [ idx ] { } if idx + + ; idx > = size { idx - = size } } in . start = idx if in . count = = 0 { } } 
func Canonical URLPath ( p string ) string { if p = = " " { return " " } if p [ 0 ] ! = ' / ' { p = " " + p } np : = path . Clean ( p ) } return np } 
func ( s * Snapshotter ) Save DBFrom ( r io . Reader , id uint 6 4 ) ( int 6 4 , error ) { start : = time . Now ( ) f , err : = ioutil . Temp File ( s . dir , " " ) if err ! = nil { return 0 , err } var n int 6 4 n , err = io . Copy ( f , r ) if err = = nil { fsync Start : = time . Now ( ) err = fileutil . Fsync ( f ) snap DBFsync Sec . Observe ( time . Since ( fsync Start ) . Seconds ( ) ) } f . Close ( ) if err ! = nil { os . Remove ( f . Name ( ) ) return n , err } fn : = s . db File Path ( id ) if fileutil . Exist ( fn ) { os . Remove ( f . Name ( ) ) return n , nil } err = os . Rename ( f . Name ( ) , fn ) if err ! = nil { os . Remove ( f . Name ( ) ) return n , err } if s . lg ! = nil { s . lg . Info ( " " , zap . String ( " " , fn ) , zap . Int 6 4 ( " " , n ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( n ) ) ) , ) } else { plog . Infof ( " " , n ) } snap DBSave Sec . Observe ( time . Since ( start ) . Seconds ( ) ) return n , nil } 
func ( s * Snapshotter ) DBFile Path ( id uint 6 4 ) ( string , error ) { if _ , err : = fileutil . Read Dir ( s . dir ) ; err ! = nil { return " " , err } fn : = s . db File Path ( id ) if fileutil . Exist ( fn ) { return fn , nil } if s . lg ! = nil { s . lg . Warn ( " " , zap . Uint 6 4 ( " " , id ) , zap . String ( " " , fn ) , zap . Error ( Err No DBSnapshot ) , ) } return " " , Err No DBSnapshot } 
func ( us * Unique Strings Value ) Set ( s string ) error { us . Values = make ( map [ string ] struct { } ) for _ , v : = range strings . Split ( s , " " ) { us . Values [ v ] = struct { } { } } return nil } 
func New Unique Strings Value ( s string ) ( us * Unique Strings Value ) { us = & Unique Strings Value { Values : make ( map [ string ] struct { } ) } if s = = " " { return us } if err : = us . Set ( s ) ; err ! = nil { plog . Panicf ( " " , err ) } return us } 
func Unique Strings From Flag ( fs * flag . Flag Set , flag Name string ) [ ] string { return ( * fs . Lookup ( flag Name ) . Value . ( * Unique Strings Value ) ) . string Slice ( ) } 
func Unique Strings Map From Flag ( fs * flag . Flag Set , flag Name string ) map [ string ] struct { } { return ( * fs . Lookup ( flag Name ) . Value . ( * Unique Strings Value ) ) . Values } 
func Percentiles ( nums [ ] float 6 4 ) ( pcs [ ] float 6 4 , data [ ] float 6 4 ) { return pctls , percentiles ( nums ) } 
func ( c * Server Config ) Verify Bootstrap ( ) error { if err : = c . has Local Member ( ) ; err ! = nil { return err } if err : = c . advertise Matches Cluster ( ) ; err ! = nil { return err } if check Duplicate URL ( c . Initial Peer URLs Map ) { return fmt . Errorf ( " " , c . Initial Peer URLs Map ) } if c . Initial Peer URLs Map . String ( ) = = " " & & c . Discovery URL = = " " { return fmt . Errorf ( " " ) } return nil } 
func ( c * Server Config ) Verify Join Existing ( ) error { } if check Duplicate URL ( c . Initial Peer URLs Map ) { return fmt . Errorf ( " " , c . Initial Peer URLs Map ) } if c . Discovery URL ! = " " { return fmt . Errorf ( " " ) } return nil } 
func ( c * Server Config ) has Local Member ( ) error { if urls : = c . Initial Peer URLs Map [ c . Name ] ; urls = = nil { return fmt . Errorf ( " " , c . Name ) } return nil } 
func ( c * Server Config ) advertise Matches Cluster ( ) error { urls , apurls : = c . Initial Peer URLs Map [ c . Name ] , c . Peer URLs . String Slice ( ) urls . Sort ( ) sort . Strings ( apurls ) ctx , cancel : = context . With Timeout ( context . TODO ( ) , 3 0 * time . Second ) defer cancel ( ) ok , err : = netutil . URLStrings Equal ( ctx , c . Logger , apurls , urls . String Slice ( ) ) if ok { return nil } init Map , ap Map : = make ( map [ string ] struct { } ) , make ( map [ string ] struct { } ) for _ , url : = range c . Peer URLs { ap Map [ url . String ( ) ] = struct { } { } } for _ , url : = range c . Initial Peer URLs Map [ c . Name ] { init Map [ url . String ( ) ] = struct { } { } } missing : = [ ] string { } for url : = range init Map { if _ , ok : = ap Map [ url ] ; ! ok { missing = append ( missing , url ) } } if len ( missing ) > 0 { for i : = range missing { missing [ i ] = c . Name + " " + missing [ i ] } mstr : = strings . Join ( missing , " " ) ap Str : = strings . Join ( apurls , " " ) return fmt . Errorf ( " " , mstr , ap Str , err ) } for url : = range ap Map { if _ , ok : = init Map [ url ] ; ! ok { missing = append ( missing , url ) } } if len ( missing ) > 0 { mstr : = strings . Join ( missing , " " ) umap : = types . URLs Map ( map [ string ] types . URLs { c . Name : c . Peer URLs } ) return fmt . Errorf ( " " , mstr , umap . String ( ) ) } umap : = types . URLs Map ( map [ string ] types . URLs { c . Name : c . Peer URLs } ) return fmt . Errorf ( " " , ap Str , umap . String ( ) , err ) } 
func ( c * Server Config ) Req Timeout ( ) time . Duration { } 
func get Status ( r * raft ) Status { s : = get Status Without Progress ( r ) if s . Raft State = = State Leader { s . Progress = get Progress Copy ( r ) } return s } 
func ( s Status ) Marshal JSON ( ) ( [ ] byte , error ) { j : = fmt . Sprintf ( ` { "id " : " %x " , "term " : %d , "vote " : " %x " , "commit " : %d , "lead " : " %x " , "raft State " : %q , "applied " : %d , "progress " : { ` , s . ID , s . Term , s . Vote , s . Commit , s . Lead , s . Raft State , s . Applied ) if len ( s . Progress ) = = 0 { j + = " " } else { for k , v : = range s . Progress { subj : = fmt . Sprintf ( ` " %x " : { "match " : %d , "next " : %d , "state " : %q } , ` , k , v . Match , v . Next , v . State ) j + = subj } } j + = fmt . Sprintf ( ` "leadtransferee " : " %x " } ` , s . Lead Transferee ) return [ ] byte ( j ) , nil } 
func Get Default Host ( ) ( string , error ) { rmsgs , rerr : = get Default Routes ( ) if rerr ! = nil { return " " , rerr } } delete ( rmsgs , syscall . AF _INET ) } for family : = range rmsgs { families = append ( families , int ( family ) ) } sort . Ints ( families ) for _ , f : = range families { family : = uint 8 ( f ) if host , err : = choose Host ( family , rmsgs [ family ] ) ; host ! = " " | | err ! = nil { return host , err } } return " " , err No Default Host } 
func get Iface Addr ( idx uint 3 2 , family uint 8 ) ( * syscall . Netlink Message , error ) { dat , err : = syscall . Netlink RIB ( syscall . RTM _GETADDR , int ( family ) ) if err ! = nil { return nil , err } msgs , msg Err : = syscall . Parse Netlink Message ( dat ) if msg Err ! = nil { return nil , msg Err } ifaddrmsg : = syscall . If Addrmsg { } for _ , m : = range msgs { if m . Header . Type ! = syscall . RTM _NEWADDR { continue } buf : = bytes . New Buffer ( m . Data [ : syscall . Sizeof If Addrmsg ] ) if rerr : = binary . Read ( buf , cpuutil . Byte Order ( ) , & ifaddrmsg ) ; rerr ! = nil { continue } if ifaddrmsg . Index = = idx { return & m , nil } } return nil , fmt . Errorf ( " " , idx ) } 
func get Iface Link ( idx uint 3 2 ) ( * syscall . Netlink Message , error ) { dat , err : = syscall . Netlink RIB ( syscall . RTM _GETLINK , syscall . AF _UNSPEC ) if err ! = nil { return nil , err } msgs , msg Err : = syscall . Parse Netlink Message ( dat ) if msg Err ! = nil { return nil , msg Err } ifinfomsg : = syscall . If Infomsg { } for _ , m : = range msgs { if m . Header . Type ! = syscall . RTM _NEWLINK { continue } buf : = bytes . New Buffer ( m . Data [ : syscall . Sizeof If Infomsg ] ) if rerr : = binary . Read ( buf , cpuutil . Byte Order ( ) , & ifinfomsg ) ; rerr ! = nil { continue } if ifinfomsg . Index = = int 3 2 ( idx ) { return & m , nil } } return nil , fmt . Errorf ( " " , idx ) } 
func Get Default Interfaces ( ) ( map [ string ] uint 8 , error ) { interfaces : = make ( map [ string ] uint 8 ) rmsgs , rerr : = get Default Routes ( ) if rerr ! = nil { return interfaces , rerr } for family , rmsg : = range rmsgs { _ , oif , err : = parse PREFSRC ( rmsg ) if err ! = nil { return interfaces , err } ifmsg , ierr : = get Iface Link ( oif ) if ierr ! = nil { return interfaces , ierr } attrs , aerr : = syscall . Parse Netlink Route Attr ( ifmsg ) if aerr ! = nil { return interfaces , aerr } for _ , attr : = range attrs { if attr . Attr . Type = = syscall . IFLA _IFNAME { } } } if len ( interfaces ) > 0 { return interfaces , nil } return interfaces , err No Default Interface } 
func parse PREFSRC ( m * syscall . Netlink Message ) ( host string , oif uint 3 2 , err error ) { var attrs [ ] syscall . Netlink Route Attr attrs , err = syscall . Parse Netlink Route Attr ( m ) if err ! = nil { return " " , 0 , err } for _ , attr : = range attrs { if attr . Attr . Type = = syscall . RTA _PREFSRC { host = net . IP ( attr . Value ) . String ( ) } if attr . Attr . Type = = syscall . RTA _OIF { oif = cpuutil . Byte Order ( ) . Uint 3 2 ( attr . Value ) } if host ! = " " & & oif ! = uint 3 2 ( 0 ) { break } } if oif = = 0 { err = err No Default Route } return host , oif , err } 
func ls Command Func ( c * cli . Context , ki client . Keys API ) { key : = " " if len ( c . Args ( ) ) ! = 0 { key = c . Args ( ) [ 0 ] } sort : = c . Bool ( " " ) recursive : = c . Bool ( " " ) quorum : = c . Bool ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Get ( ctx , key , & client . Get Options { Sort : sort , Recursive : recursive , Quorum : quorum } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } print Ls ( c , resp ) } 
func print Ls ( c * cli . Context , resp * client . Response ) { if c . Global String ( " " ) = = " " { if ! resp . Node . Dir { fmt . Println ( resp . Node . Key ) } for _ , node : = range resp . Node . Nodes { r Print ( c , node ) } } else { } } 
func r Print ( c * cli . Context , n * client . Node ) { if n . Dir & & c . Bool ( " " ) { fmt . Println ( fmt . Sprintf ( " " , n . Key ) ) } else { fmt . Println ( n . Key ) } for _ , node : = range n . Nodes { r Print ( c , node ) } } 
func New Lease Renewer Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : run Lease Renewer Func , } cmd . Flags ( ) . Int 6 4Var ( & lease TTL , " " , 5 , " " ) return cmd } 
func Read ( lg * zap . Logger , snapname string ) ( * raftpb . Snapshot , error ) { b , err : = ioutil . Read File ( snapname ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , snapname , err ) } return nil , err } if len ( b ) = = 0 { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) ) } else { plog . Errorf ( " " ) } return nil , Err Empty Snapshot } var serialized Snap snappb . Snapshot if err = serialized Snap . Unmarshal ( b ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , snapname , err ) } return nil , err } if len ( serialized Snap . Data ) = = 0 | | serialized Snap . Crc = = 0 { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) ) } else { plog . Errorf ( " " ) } return nil , Err Empty Snapshot } crc : = crc 3 2 . Update ( 0 , crc Table , serialized Snap . Data ) if crc ! = serialized Snap . Crc { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) , zap . Uint 3 2 ( " " , serialized Snap . Crc ) , zap . Uint 3 2 ( " " , crc ) , ) } else { plog . Errorf ( " " , snapname ) } return nil , Err CRCMismatch } var snap raftpb . Snapshot if err = snap . Unmarshal ( serialized Snap . Data ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , snapname ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , snapname , err ) } return nil , err } return & snap , nil } 
func ( s * Snapshotter ) snap Names ( ) ( [ ] string , error ) { dir , err : = os . Open ( s . dir ) if err ! = nil { return nil , err } defer dir . Close ( ) names , err : = dir . Readdirnames ( - 1 ) if err ! = nil { return nil , err } snaps : = check Suffix ( s . lg , names ) if len ( snaps ) = = 0 { return nil , Err No Snapshot } sort . Sort ( sort . Reverse ( sort . String Slice ( snaps ) ) ) return snaps , nil } 
func Graceful Close ( resp * http . Response ) { io . Copy ( ioutil . Discard , resp . Body ) resp . Body . Close ( ) } 
func Get Hostname ( req * http . Request ) string { if req = = nil { return " " } h , _ , err : = net . Split Host Port ( req . Host ) if err ! = nil { return req . Host } return h } 
func ( q * Queue ) Dequeue ( ) ( string , error ) { if err ! = nil { return " " , err } kv , err : = claim First Key ( q . client , resp . Kvs ) if err ! = nil { return " " , err } else if kv ! = nil { return string ( kv . Value ) , nil } else if resp . More { } if err ! = nil { return " " , err } ok , err : = delete Rev Key ( q . client , string ( ev . Kv . Key ) , ev . Kv . Mod Revision ) if err ! = nil { return " " , err } else if ! ok { return q . Dequeue ( ) } return string ( ev . Kv . Value ) , err } 
func Get Cipher Suite ( s string ) ( uint 1 6 , bool ) { v , ok : = cipher Suites [ s ] return v , ok } 
func ( p * pipeline ) post ( data [ ] byte ) ( err error ) { u : = p . picker . pick ( ) req : = create Post Request ( u , Raft Prefix , bytes . New Buffer ( data ) , " " , p . tr . URLs , p . tr . ID , p . tr . Cluster ID ) done : = make ( chan struct { } , 1 ) ctx , cancel : = context . With Cancel ( context . Background ( ) ) req = req . With Context ( ctx ) go func ( ) { select { case < - done : case < - p . stopc : wait Schedule ( ) cancel ( ) } } ( ) resp , err : = p . tr . pipeline Rt . Round Trip ( req ) done < - struct { } { } if err ! = nil { p . picker . unreachable ( u ) return err } defer resp . Body . Close ( ) b , err : = ioutil . Read All ( resp . Body ) if err ! = nil { p . picker . unreachable ( u ) return err } err = check Post Response ( resp , b , req , p . peer ID ) if err ! = nil { p . picker . unreachable ( u ) } return err } return nil } 
func ( * Request Op ) XXX _Oneof Funcs ( ) ( func ( msg proto . Message , b * proto . Buffer ) error , func ( msg proto . Message , tag , wire int , b * proto . Buffer ) ( bool , error ) , func ( msg proto . Message ) ( n int ) , [ ] interface { } ) { return _Request Op _Oneof Marshaler , _Request Op _Oneof Unmarshaler , _Request Op _Oneof Sizer , [ ] interface { } { ( * Request Op _Request Range ) ( nil ) , ( * Request Op _Request Put ) ( nil ) , ( * Request Op _Request Delete Range ) ( nil ) , ( * Request Op _Request Txn ) ( nil ) , } } 
func ( * Response Op ) XXX _Oneof Funcs ( ) ( func ( msg proto . Message , b * proto . Buffer ) error , func ( msg proto . Message , tag , wire int , b * proto . Buffer ) ( bool , error ) , func ( msg proto . Message ) ( n int ) , [ ] interface { } ) { return _Response Op _Oneof Marshaler , _Response Op _Oneof Unmarshaler , _Response Op _Oneof Sizer , [ ] interface { } { ( * Response Op _Response Range ) ( nil ) , ( * Response Op _Response Put ) ( nil ) , ( * Response Op _Response Delete Range ) ( nil ) , ( * Response Op _Response Txn ) ( nil ) , } } 
func ( * Compare ) XXX _Oneof Funcs ( ) ( func ( msg proto . Message , b * proto . Buffer ) error , func ( msg proto . Message , tag , wire int , b * proto . Buffer ) ( bool , error ) , func ( msg proto . Message ) ( n int ) , [ ] interface { } ) { return _Compare _Oneof Marshaler , _Compare _Oneof Unmarshaler , _Compare _Oneof Sizer , [ ] interface { } { ( * Compare _Version ) ( nil ) , ( * Compare _Create Revision ) ( nil ) , ( * Compare _Mod Revision ) ( nil ) , ( * Compare _Value ) ( nil ) , ( * Compare _Lease ) ( nil ) , } } 
func ( * Watch Request ) XXX _Oneof Funcs ( ) ( func ( msg proto . Message , b * proto . Buffer ) error , func ( msg proto . Message , tag , wire int , b * proto . Buffer ) ( bool , error ) , func ( msg proto . Message ) ( n int ) , [ ] interface { } ) { return _Watch Request _Oneof Marshaler , _Watch Request _Oneof Unmarshaler , _Watch Request _Oneof Sizer , [ ] interface { } { ( * Watch Request _Create Request ) ( nil ) , ( * Watch Request _Cancel Request ) ( nil ) , ( * Watch Request _Progress Request ) ( nil ) , } } 
func ( r * raft ) send ( m pb . Message ) { m . From = r . id if m . Type = = pb . Msg Vote | | m . Type = = pb . Msg Vote Resp | | m . Type = = pb . Msg Pre Vote | | m . Type = = pb . Msg Pre Vote Resp { if m . Term = = 0 { } } else { if m . Term ! = 0 { panic ( fmt . Sprintf ( " " , m . Type , m . Term ) ) } } } r . msgs = append ( r . msgs , m ) } 
func ( r * raft ) maybe Send Append ( to uint 6 4 , send If Empty bool ) bool { pr : = r . get Progress ( to ) if pr . Is Paused ( ) { return false } m : = pb . Message { } m . To = to term , errt : = r . raft Log . term ( pr . Next - 1 ) ents , erre : = r . raft Log . entries ( pr . Next , r . max Msg Size ) if len ( ents ) = = 0 & & ! send If Empty { return false } if errt ! = nil | | erre ! = nil { return false } m . Type = pb . Msg Snap snapshot , err : = r . raft Log . snapshot ( ) if err ! = nil { if err = = Err Snapshot Temporarily Unavailable { r . logger . Debugf ( " " , r . id , to ) return false } panic ( err ) } if Is Empty Snap ( snapshot ) { panic ( " " ) } m . Snapshot = snapshot sindex , sterm : = snapshot . Metadata . Index , snapshot . Metadata . Term r . logger . Debugf ( " " , r . id , r . raft Log . first Index ( ) , r . raft Log . committed , sindex , sterm , to , pr ) pr . become Snapshot ( sindex ) r . logger . Debugf ( " " , r . id , to , pr ) } else { m . Type = pb . Msg App m . Index = pr . Next - 1 m . Log Term = term m . Entries = ents m . Commit = r . raft Log . committed if n : = len ( m . Entries ) ; n ! = 0 { switch pr . State { pr . optimistic Update ( last ) pr . ins . add ( last ) case Progress State Probe : pr . pause ( ) default : r . logger . Panicf ( " " , r . id , pr . State ) } } } r . send ( m ) return true } 
func ( r * raft ) send Heartbeat ( to uint 6 4 , ctx [ ] byte ) { m : = pb . Message { To : to , Type : pb . Msg Heartbeat , Commit : commit , Context : ctx , } r . send ( m ) } 
func ( r * raft ) bcast Append ( ) { r . for Each Progress ( func ( id uint 6 4 , _ * Progress ) { if id = = r . id { return } r . send Append ( id ) } ) } 
func ( r * raft ) bcast Heartbeat ( ) { last Ctx : = r . read Only . last Pending Request Ctx ( ) if len ( last Ctx ) = = 0 { r . bcast Heartbeat With Ctx ( nil ) } else { r . bcast Heartbeat With Ctx ( [ ] byte ( last Ctx ) ) } } 
func ( r * raft ) maybe Commit ( ) bool { } r . match Buf = r . match Buf [ : len ( r . prs ) ] idx : = 0 for _ , p : = range r . prs { r . match Buf [ idx ] = p . Match idx + + } sort . Sort ( & r . match Buf ) mci : = r . match Buf [ len ( r . match Buf ) - r . quorum ( ) ] return r . raft Log . maybe Commit ( mci , r . Term ) } 
func ( r * raft ) tick Election ( ) { r . election Elapsed + + if r . promotable ( ) & & r . past Election Timeout ( ) { r . election Elapsed = 0 r . Step ( pb . Message { From : r . id , Type : pb . Msg Hup } ) } } 
func ( r * raft ) tick Heartbeat ( ) { r . heartbeat Elapsed + + r . election Elapsed + + if r . election Elapsed > = r . election Timeout { r . election Elapsed = 0 if r . check Quorum { r . Step ( pb . Message { From : r . id , Type : pb . Msg Check Quorum } ) } } } if r . state ! = State Leader { return } if r . heartbeat Elapsed > = r . heartbeat Timeout { r . heartbeat Elapsed = 0 r . Step ( pb . Message { From : r . id , Type : pb . Msg Beat } ) } } 
func step Candidate ( r * raft , m pb . Message ) error { if r . state = = State Pre Candidate { my Vote Resp Type = pb . Msg Pre Vote Resp } else { my Vote Resp Type = pb . Msg Vote Resp } switch m . Type { case pb . Msg Prop : r . logger . Infof ( " " , r . id , r . Term ) return Err Proposal Dropped case pb . Msg App : r . become Follower ( m . Term , m . From ) r . handle Append Entries ( m ) case pb . Msg Heartbeat : r . become Follower ( m . Term , m . From ) r . handle Heartbeat ( m ) case pb . Msg Snap : r . become Follower ( m . Term , m . From ) r . handle Snapshot ( m ) case my Vote Resp Type : gr : = r . poll ( m . From , m . Type , ! m . Reject ) r . logger . Infof ( " " , r . id , r . quorum ( ) , gr , m . Type , len ( r . votes ) - gr ) switch r . quorum ( ) { case gr : if r . state = = State Pre Candidate { r . campaign ( campaign Election ) } else { r . become Leader ( ) r . bcast Append ( ) } case len ( r . votes ) - gr : } case pb . Msg Timeout Now : r . logger . Debugf ( " " , r . id , r . Term , r . state , m . From ) } return nil } 
func ( r * raft ) restore ( s pb . Snapshot ) bool { if s . Metadata . Index < = r . raft Log . committed { return false } if r . raft Log . match Term ( s . Metadata . Index , s . Metadata . Term ) { r . logger . Infof ( " " , r . id , r . raft Log . committed , r . raft Log . last Index ( ) , r . raft Log . last Term ( ) , s . Metadata . Index , s . Metadata . Term ) r . raft Log . commit To ( s . Metadata . Index ) return false } return false } } } r . logger . Infof ( " " , r . id , r . raft Log . committed , r . raft Log . last Index ( ) , r . raft Log . last Term ( ) , s . Metadata . Index , s . Metadata . Term ) r . raft Log . restore ( s ) r . prs = make ( map [ uint 6 4 ] * Progress ) r . learner Prs = make ( map [ uint 6 4 ] * Progress ) r . restore Node ( s . Metadata . Conf State . Nodes , false ) r . restore Node ( s . Metadata . Conf State . Learners , true ) return true } 
func ( r * raft ) promotable ( ) bool { _ , ok : = r . prs [ r . id ] return ok } 
func ( r * raft ) check Quorum Active ( ) bool { var act int r . for Each Progress ( func ( id uint 6 4 , pr * Progress ) { if id = = r . id { return } if pr . Recent Active & & ! pr . Is Learner { act + + } pr . Recent Active = false } ) return act > = r . quorum ( ) } 
func ( r * raft ) increase Uncommitted Size ( ents [ ] pb . Entry ) bool { var s uint 6 4 for _ , e : = range ents { s + = uint 6 4 ( Payload Size ( e ) ) } if r . uncommitted Size > 0 & & r . uncommitted Size + s > r . max Uncommitted Size { } r . uncommitted Size + = s return true } 
func ( r * raft ) reduce Uncommitted Size ( ents [ ] pb . Entry ) { if r . uncommitted Size = = 0 { } var s uint 6 4 for _ , e : = range ents { s + = uint 6 4 ( Payload Size ( e ) ) } if s > r . uncommitted Size { } else { r . uncommitted Size - = s } } 
func new Periodic ( lg * zap . Logger , clock clockwork . Clock , h time . Duration , rg Rev Getter , c Compactable ) * Periodic { pc : = & Periodic { lg : lg , clock : clock , period : h , rg : rg , c : c , revs : make ( [ ] int 6 4 , 0 ) , } pc . ctx , pc . cancel = context . With Cancel ( context . Background ( ) ) return pc } 
func ( pc * Periodic ) Run ( ) { compact Interval : = pc . get Compact Interval ( ) retry Interval : = pc . get Retry Interval ( ) retentions : = pc . get Retentions ( ) go func ( ) { last Success : = pc . clock . Now ( ) base Interval : = pc . period for { pc . revs = append ( pc . revs , pc . rg . Rev ( ) ) if len ( pc . revs ) > retentions { pc . revs = pc . revs [ 1 : ] } select { case < - pc . ctx . Done ( ) : return case < - pc . clock . After ( retry Interval ) : pc . mu . Lock ( ) p : = pc . paused pc . mu . Unlock ( ) if p { continue } } if pc . clock . Now ( ) . Sub ( last Success ) < base Interval { continue } } rev : = pc . revs [ 0 ] if pc . lg ! = nil { pc . lg . Info ( " " , zap . Int 6 4 ( " " , rev ) , zap . Duration ( " " , pc . period ) , ) } else { plog . Noticef ( " " , rev , pc . period ) } _ , err : = pc . c . Compact ( pc . ctx , & pb . Compaction Request { Revision : rev } ) if err = = nil | | err = = mvcc . Err Compacted { if pc . lg ! = nil { pc . lg . Info ( " " , zap . Int 6 4 ( " " , rev ) , zap . Duration ( " " , pc . period ) , zap . Duration ( " " , time . Since ( last Success ) ) , ) } else { plog . Noticef ( " " , rev ) } last Success = pc . clock . Now ( ) } else { if pc . lg ! = nil { pc . lg . Warn ( " " , zap . Int 6 4 ( " " , rev ) , zap . Duration ( " " , pc . period ) , zap . Duration ( " " , retry Interval ) , zap . Error ( err ) , ) } else { plog . Noticef ( " " , rev , err ) plog . Noticef ( " " , retry Interval ) } } } } ( ) } 
func ( pc * Periodic ) get Compact Interval ( ) time . Duration { itv : = pc . period if itv > time . Hour { itv = time . Hour } return itv } 
func ( pc * Periodic ) Pause ( ) { pc . mu . Lock ( ) pc . paused = true pc . mu . Unlock ( ) } 
func ( pc * Periodic ) Resume ( ) { pc . mu . Lock ( ) pc . paused = false pc . mu . Unlock ( ) } 
func ( m * Mutex ) Lock ( ctx context . Context ) error { s : = m . s client : = m . s . Client ( ) m . my Key = fmt . Sprintf ( " " , m . pfx , s . Lease ( ) ) cmp : = v 3 . Compare ( v 3 . Create Revision ( m . my Key ) , " " , 0 ) resp , err : = client . Txn ( ctx ) . If ( cmp ) . Then ( put , get Owner ) . Else ( get , get Owner ) . Commit ( ) if err ! = nil { return err } m . my Rev = resp . Header . Revision if ! resp . Succeeded { m . my Rev = resp . Responses [ 0 ] . Get Response Range ( ) . Kvs [ 0 ] . Create Revision } if len ( owner Key ) = = 0 | | owner Key [ 0 ] . Create Revision = = m . my Rev { m . hdr = resp . Header return nil } } else { m . hdr = hdr } return werr } 
func New Locker ( s * Session , pfx string ) sync . Locker { return & locker Mutex { New Mutex ( s , pfx ) } } 
func New FIFOScheduler ( ) Scheduler { f : = & fifo { resume : make ( chan struct { } , 1 ) , donec : make ( chan struct { } , 1 ) , } f . finish Cond = sync . New Cond ( & f . mu ) f . ctx , f . cancel = context . With Cancel ( context . Background ( ) ) go f . run ( ) return f } 
func ( f * fifo ) Schedule ( j Job ) { f . mu . Lock ( ) defer f . mu . Unlock ( ) if f . cancel = = nil { panic ( " " ) } if len ( f . pendings ) = = 0 { select { case f . resume < - struct { } { } : default : } } f . pendings = append ( f . pendings , j ) } 
func ( f * fifo ) Stop ( ) { f . mu . Lock ( ) f . cancel ( ) f . cancel = nil f . mu . Unlock ( ) < - f . donec } 
func New Server ( lg * zap . Logger , network string , address string , ) * Server { return & Server { lg : lg , network : network , address : address , last : rpcpb . Operation _NOT _STARTED , advertise Client Port To Proxy : make ( map [ int ] proxy . Server ) , advertise Peer Port To Proxy : make ( map [ int ] proxy . Server ) , } } 
func ( srv * Server ) Start Serve ( ) error { var err error srv . ln , err = net . Listen ( srv . network , srv . address ) if err ! = nil { return err } var opts [ ] grpc . Server Option opts = append ( opts , grpc . Max Recv Msg Size ( int ( max Request Bytes + grpc Overhead Bytes ) ) ) opts = append ( opts , grpc . Max Send Msg Size ( max Send Bytes ) ) opts = append ( opts , grpc . Max Concurrent Streams ( max Streams ) ) srv . grpc Server = grpc . New Server ( opts . . . ) rpcpb . Register Transport Server ( srv . grpc Server , srv ) srv . lg . Info ( " " , zap . String ( " " , srv . address ) , zap . String ( " " , srv . ln . Addr ( ) . String ( ) ) , ) err = srv . grpc Server . Serve ( srv . ln ) if err ! = nil & & strings . Contains ( err . Error ( ) , " " ) { srv . lg . Info ( " " , zap . String ( " " , srv . address ) , zap . Error ( err ) , ) } else { srv . lg . Warn ( " " , zap . String ( " " , srv . address ) , zap . Error ( err ) , ) } return err } 
func ( srv * Server ) Stop ( ) { srv . lg . Info ( " " , zap . String ( " " , srv . address ) ) srv . grpc Server . Stop ( ) srv . lg . Info ( " " , zap . String ( " " , srv . address ) ) } 
func ( srv * Server ) Transport ( stream rpcpb . Transport _Transport Server ) ( err error ) { errc : = make ( chan error ) go func ( ) { for { var req * rpcpb . Request req , err = stream . Recv ( ) if err ! = nil { errc < - err } if req . Member ! = nil { srv . Member = req . Member } if req . Tester ! = nil { srv . Tester = req . Tester } var resp * rpcpb . Response resp , err = srv . handle Tester Request ( req ) if err ! = nil { errc < - err } if err = stream . Send ( resp ) ; err ! = nil { errc < - err } } } ( ) select { case err = < - errc : case < - stream . Context ( ) . Done ( ) : err = stream . Context ( ) . Err ( ) } return err } 
func Register Interrupt Handler ( h Interrupt Handler ) { interrupt Register Mu . Lock ( ) defer interrupt Register Mu . Unlock ( ) interrupt Handlers = append ( interrupt Handlers , h ) } 
func Handle Interrupts ( lg * zap . Logger ) { notifier : = make ( chan os . Signal , 1 ) signal . Notify ( notifier , syscall . SIGINT , syscall . SIGTERM ) go func ( ) { sig : = < - notifier interrupt Register Mu . Lock ( ) ihs : = make ( [ ] Interrupt Handler , len ( interrupt Handlers ) ) copy ( ihs , interrupt Handlers ) interrupt Register Mu . Unlock ( ) interrupt Exit Mu . Lock ( ) if lg ! = nil { lg . Info ( " " , zap . String ( " " , sig . String ( ) ) ) } else { plog . Noticef ( " " , sig ) } for _ , h : = range ihs { h ( ) } signal . Stop ( notifier ) pid : = syscall . Getpid ( ) } set Dfl Signal ( sig . ( syscall . Signal ) ) syscall . Kill ( pid , sig . ( syscall . Signal ) ) } ( ) } 
func ( op Op ) Txn ( ) ( [ ] Cmp , [ ] Op , [ ] Op ) { return op . cmps , op . then Ops , op . else Ops } 
func Op Get ( key string , opts . . . Op Option ) Op { } ret : = Op { t : t Range , key : [ ] byte ( key ) } ret . apply Opts ( opts ) return ret } 
func Op Delete ( key string , opts . . . Op Option ) Op { } ret : = Op { t : t Delete Range , key : [ ] byte ( key ) } ret . apply Opts ( opts ) switch { case ret . lease ID ! = 0 : panic ( " " ) case ret . limit ! = 0 : panic ( " " ) case ret . rev ! = 0 : panic ( " " ) case ret . sort ! = nil : panic ( " " ) case ret . serializable : panic ( " " ) case ret . count Only : panic ( " " ) case ret . min Mod Rev ! = 0 , ret . max Mod Rev ! = 0 : panic ( " " ) case ret . min Create Rev ! = 0 , ret . max Create Rev ! = 0 : panic ( " " ) case ret . filter Delete , ret . filter Put : panic ( " " ) case ret . created Notify : panic ( " " ) } return ret } 
func Op Put ( key , val string , opts . . . Op Option ) Op { ret : = Op { t : t Put , key : [ ] byte ( key ) , val : [ ] byte ( val ) } ret . apply Opts ( opts ) switch { case ret . end ! = nil : panic ( " " ) case ret . limit ! = 0 : panic ( " " ) case ret . rev ! = 0 : panic ( " " ) case ret . sort ! = nil : panic ( " " ) case ret . serializable : panic ( " " ) case ret . count Only : panic ( " " ) case ret . min Mod Rev ! = 0 , ret . max Mod Rev ! = 0 : panic ( " " ) case ret . min Create Rev ! = 0 , ret . max Create Rev ! = 0 : panic ( " " ) case ret . filter Delete , ret . filter Put : panic ( " " ) case ret . created Notify : panic ( " " ) } return ret } 
func Op Txn ( cmps [ ] Cmp , then Ops [ ] Op , else Ops [ ] Op ) Op { return Op { t : t Txn , cmps : cmps , then Ops : then Ops , else Ops : else Ops } } 
func With Sort ( target Sort Target , order Sort Order ) Op Option { return func ( op * Op ) { if target = = Sort By Key & & order = = Sort Ascend { } op . sort = & Sort Option { target , order } } } 
func With Prefix ( ) Op Option { return func ( op * Op ) { if len ( op . key ) = = 0 { op . key , op . end = [ ] byte { 0 } , [ ] byte { 0 } return } op . end = get Prefix ( op . key ) } } 
func With Range ( end Key string ) Op Option { return func ( op * Op ) { op . end = [ ] byte ( end Key ) } } 
func With From Key ( ) Op Option { return func ( op * Op ) { if len ( op . key ) = = 0 { op . key = [ ] byte { 0 } } op . end = [ ] byte ( " \x 0 0 " ) } } 
func with Top ( target Sort Target , order Sort Order ) [ ] Op Option { return [ ] Op Option { With Prefix ( ) , With Sort ( target , order ) , With Limit ( 1 ) } } 
func Exist ( dir string ) bool { names , err : = fileutil . Read Dir ( dir , fileutil . With Ext ( " " ) ) if err ! = nil { return false } return len ( names ) ! = 0 } 
func search Index ( lg * zap . Logger , names [ ] string , index uint 6 4 ) ( int , bool ) { for i : = len ( names ) - 1 ; i > = 0 ; i - - { name : = names [ i ] _ , cur Index , err : = parse WALName ( name ) if err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , name ) , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if index > = cur Index { return i , true } } return - 1 , false } 
func is Valid Seq ( lg * zap . Logger , names [ ] string ) bool { var last Seq uint 6 4 for _ , name : = range names { cur Seq , _ , err : = parse WALName ( name ) if err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , name ) , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if last Seq ! = 0 & & last Seq ! = cur Seq - 1 { return false } last Seq = cur Seq } return true } 
func New Listener ( addr , scheme string , tlsinfo * TLSInfo ) ( l net . Listener , err error ) { if l , err = new Listener ( addr , scheme ) ; err ! = nil { return nil , err } return wrap TLS ( scheme , tlsinfo , l ) } 
func ( info TLSInfo ) base Config ( ) ( * tls . Config , error ) { if info . Key File = = " " | | info . Cert File = = " " { return nil , fmt . Errorf ( " " , info . Key File , info . Cert File ) } if info . Logger = = nil { info . Logger = zap . New Nop ( ) } _ , err : = tlsutil . New Cert ( info . Cert File , info . Key File , info . parse Func ) if err ! = nil { return nil , err } cfg : = & tls . Config { Min Version : tls . Version TLS 1 2 , Server Name : info . Server Name , } if len ( info . Cipher Suites ) > 0 { cfg . Cipher Suites = info . Cipher Suites } if info . Allowed CN ! = " " { cfg . Verify Peer Certificate = func ( raw Certs [ ] [ ] byte , verified Chains [ ] [ ] * x 5 0 9 . Certificate ) error { for _ , chains : = range verified Chains { if len ( chains ) ! = 0 { if info . Allowed CN = = chains [ 0 ] . Subject . Common Name { return nil } } } return errors . New ( " " ) } } if os . Is Not Exist ( err ) { if info . Logger ! = nil { info . Logger . Warn ( " " , zap . String ( " " , info . Cert File ) , zap . String ( " " , info . Key File ) , zap . Error ( err ) , ) } } else if err ! = nil { if info . Logger ! = nil { info . Logger . Warn ( " " , zap . String ( " " , info . Cert File ) , zap . String ( " " , info . Key File ) , zap . Error ( err ) , ) } } return cert , err } cfg . Get Client Certificate = func ( unused * tls . Certificate Request Info ) ( cert * tls . Certificate , err error ) { cert , err = tlsutil . New Cert ( info . Cert File , info . Key File , info . parse Func ) if os . Is Not Exist ( err ) { if info . Logger ! = nil { info . Logger . Warn ( " " , zap . String ( " " , info . Cert File ) , zap . String ( " " , info . Key File ) , zap . Error ( err ) , ) } } else if err ! = nil { if info . Logger ! = nil { info . Logger . Warn ( " " , zap . String ( " " , info . Cert File ) , zap . String ( " " , info . Key File ) , zap . Error ( err ) , ) } } return cert , err } return cfg , nil } 
func ( info TLSInfo ) cafiles ( ) [ ] string { cs : = make ( [ ] string , 0 ) if info . Trusted CAFile ! = " " { cs = append ( cs , info . Trusted CAFile ) } return cs } 
func ( info TLSInfo ) Server Config ( ) ( * tls . Config , error ) { cfg , err : = info . base Config ( ) if err ! = nil { return nil , err } cfg . Client Auth = tls . No Client Cert if info . Trusted CAFile ! = " " | | info . Client Cert Auth { cfg . Client Auth = tls . Require And Verify Client Cert } cs : = info . cafiles ( ) if len ( cs ) > 0 { cp , err : = tlsutil . New Cert Pool ( cs ) if err ! = nil { return nil , err } cfg . Client CAs = cp } return cfg , nil } 
func ( info TLSInfo ) Client Config ( ) ( * tls . Config , error ) { var cfg * tls . Config var err error if ! info . Empty ( ) { cfg , err = info . base Config ( ) if err ! = nil { return nil , err } } else { cfg = & tls . Config { Server Name : info . Server Name } } cfg . Insecure Skip Verify = info . Insecure Skip Verify cs : = info . cafiles ( ) if len ( cs ) > 0 { cfg . Root CAs , err = tlsutil . New Cert Pool ( cs ) if err ! = nil { return nil , err } } if info . self Cert { cfg . Insecure Skip Verify = true } if info . Empty CN { has Non Empty CN : = false cn : = " " tlsutil . New Cert ( info . Cert File , info . Key File , func ( cert PEMBlock [ ] byte , key PEMBlock [ ] byte ) ( tls . Certificate , error ) { var block * pem . Block block , _ = pem . Decode ( cert PEMBlock ) cert , err : = x 5 0 9 . Parse Certificate ( block . Bytes ) if err ! = nil { return tls . Certificate { } , err } if len ( cert . Subject . Common Name ) ! = 0 { has Non Empty CN = true cn = cert . Subject . Common Name } return tls . X 5 0 9Key Pair ( cert PEMBlock , key PEMBlock ) } ) if has Non Empty CN { return nil , fmt . Errorf ( " " , cn ) } } return cfg , nil } 
func Is Closed Conn Error ( err error ) bool { } 
func New Keep Alive Listener ( l net . Listener , scheme string , tlscfg * tls . Config ) ( net . Listener , error ) { if scheme = = " " { if tlscfg = = nil { return nil , fmt . Errorf ( " " ) } return new TLSKeepalive Listener ( l , tlscfg ) , nil } return & keepalive Listener { Listener : l , } , nil } 
func ( l * tls Keepalive Listener ) Accept ( ) ( c net . Conn , err error ) { c , err = l . Listener . Accept ( ) if err ! = nil { return } kac : = c . ( keep Alive Conn ) kac . Set Keep Alive Period ( 3 0 * time . Second ) c = tls . Server ( c , l . config ) return c , nil } 
func new TLSKeepalive Listener ( inner net . Listener , config * tls . Config ) net . Listener { l : = & tls Keepalive Listener { } l . Listener = inner l . config = config return l } 
func ( s * Etcd Server ) apply V 2Request ( r * Request V 2 ) Response { defer warn Of Expensive Request ( s . get Logger ( ) , time . Now ( ) , r , nil , nil ) switch r . Method { case " " : return s . apply V 2 . Post ( r ) case " " : return s . apply V 2 . Put ( r ) case " " : return s . apply V 2 . Delete ( r ) case " " : return s . apply V 2 . QGet ( r ) case " " : return s . apply V 2 . Sync ( r ) default : } } 
func New Role Command ( ) * cobra . Command { ac : = & cobra . Command { Use : " " , Short : " " , } ac . Add Command ( new Role Add Command ( ) ) ac . Add Command ( new Role Delete Command ( ) ) ac . Add Command ( new Role Get Command ( ) ) ac . Add Command ( new Role List Command ( ) ) ac . Add Command ( new Role Grant Permission Command ( ) ) ac . Add Command ( new Role Revoke Permission Command ( ) ) return ac } 
func role Add Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } resp , err : = must Client From Cmd ( cmd ) . Auth . Role Add ( context . TODO ( ) , args [ 0 ] ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Role Add ( args [ 0 ] , * resp ) } 
func role Get Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } name : = args [ 0 ] resp , err : = must Client From Cmd ( cmd ) . Auth . Role Get ( context . TODO ( ) , name ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Role Get ( name , * resp ) } 
func role Grant Permission Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 3 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } perm , err : = clientv 3 . Str To Permission Type ( args [ 1 ] ) if err ! = nil { Exit With Error ( Exit Bad Args , err ) } key , range End : = perm Range ( args [ 2 : ] ) resp , err : = must Client From Cmd ( cmd ) . Auth . Role Grant Permission ( context . TODO ( ) , args [ 0 ] , key , range End , perm ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Role Grant Permission ( args [ 0 ] , * resp ) } 
func role Revoke Permission Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 2 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } key , range End : = perm Range ( args [ 1 : ] ) resp , err : = must Client From Cmd ( cmd ) . Auth . Role Revoke Permission ( context . TODO ( ) , args [ 0 ] , key , range End ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Role Revoke Permission ( args [ 0 ] , args [ 1 ] , range End , * resp ) } 
func Dial Journal ( ) error { conn , err : = net . Dial ( " " , " " ) if conn ! = nil { defer conn . Close ( ) } return err } 
func New Cluster ( t testing . TB , size int ) * cluster { return new Cluster ( t , & Cluster Config { Size : size } ) } 
func New Cluster By Config ( t testing . TB , cfg * Cluster Config ) * cluster { return new Cluster ( t , cfg ) } 
func ( c * cluster ) HTTPMembers ( ) [ ] client . Member { ms : = [ ] client . Member { } for _ , m : = range c . Members { p Scheme : = scheme From TLSInfo ( m . Peer TLSInfo ) c Scheme : = scheme From TLSInfo ( m . Client TLSInfo ) cm : = client . Member { Name : m . Name } for _ , ln : = range m . Peer Listeners { cm . Peer URLs = append ( cm . Peer URLs , p Scheme + " " + ln . Addr ( ) . String ( ) ) } for _ , ln : = range m . Client Listeners { cm . Client URLs = append ( cm . Client URLs , c Scheme + " " + ln . Addr ( ) . String ( ) ) } ms = append ( ms , cm ) } return ms } 
func ( c * cluster ) wait Leader ( t testing . TB , membs [ ] * member ) int { possible Lead : = make ( map [ uint 6 4 ] bool ) var lead uint 6 4 for _ , m : = range membs { possible Lead [ uint 6 4 ( m . s . ID ( ) ) ] = true } cc : = Must New HTTPClient ( t , get Members URLs ( membs ) , nil ) kapi : = client . New Keys API ( cc ) _ , err : = kapi . Get ( ctx , " " , & client . Get Options { Quorum : true } ) cancel ( ) if err = = nil | | strings . Contains ( err . Error ( ) , " " ) { break } } for lead = = 0 | | ! possible Lead [ lead ] { lead = 0 for _ , m : = range membs { select { case < - m . s . Stop Notify ( ) : continue default : } if lead ! = 0 & & lead ! = m . s . Lead ( ) { lead = 0 time . Sleep ( 1 0 * tick Duration ) break } lead = m . s . Lead ( ) } } for i , m : = range membs { if uint 6 4 ( m . s . ID ( ) ) = = lead { return i } } return - 1 } 
func ( c * cluster ) wait No Leader ( membs [ ] * member ) { no Leader : = false for ! no Leader { no Leader = true for _ , m : = range membs { select { case < - m . s . Stop Notify ( ) : continue default : } if m . s . Lead ( ) ! = 0 { no Leader = false time . Sleep ( 1 0 * tick Duration ) break } } } } 
func is Members Equal ( membs [ ] client . Member , wmembs [ ] client . Member ) bool { sort . Sort ( Sortable Member Slice By Peer URLs ( membs ) ) sort . Sort ( Sortable Member Slice By Peer URLs ( wmembs ) ) for i : = range membs { membs [ i ] . ID = " " } return reflect . Deep Equal ( membs , wmembs ) } 
func must New Member ( t testing . TB , mcfg member Config ) * member { var err error m : = & member { } peer Scheme : = scheme From TLSInfo ( mcfg . peer TLS ) client Scheme : = scheme From TLSInfo ( mcfg . client TLS ) pln : = new Local Listener ( t ) m . Peer Listeners = [ ] net . Listener { pln } m . Peer URLs , err = types . New URLs ( [ ] string { peer Scheme + " " + pln . Addr ( ) . String ( ) } ) if err ! = nil { t . Fatal ( err ) } m . Peer TLSInfo = mcfg . peer TLS cln : = new Local Listener ( t ) m . Client Listeners = [ ] net . Listener { cln } m . Client URLs , err = types . New URLs ( [ ] string { client Scheme + " " + cln . Addr ( ) . String ( ) } ) if err ! = nil { t . Fatal ( err ) } m . Client TLSInfo = mcfg . client TLS m . Name = mcfg . name m . Data Dir , err = ioutil . Temp Dir ( os . Temp Dir ( ) , " " ) if err ! = nil { t . Fatal ( err ) } cluster Str : = fmt . Sprintf ( " " , mcfg . name , peer Scheme , pln . Addr ( ) . String ( ) ) m . Initial Peer URLs Map , err = types . New URLs Map ( cluster Str ) if err ! = nil { t . Fatal ( err ) } m . Initial Cluster Token = cluster Name m . New Cluster = true m . Bootstrap Timeout = 1 0 * time . Millisecond if m . Peer TLSInfo ! = nil { m . Server Config . Peer TLSInfo = * m . Peer TLSInfo } m . Election Ticks = election Ticks m . Initial Election Tick Advance = true m . Tick Ms = uint ( tick Duration / time . Millisecond ) m . Quota Backend Bytes = mcfg . quota Backend Bytes m . Max Txn Ops = mcfg . max Txn Ops if m . Max Txn Ops = = 0 { m . Max Txn Ops = embed . Default Max Txn Ops } m . Max Request Bytes = mcfg . max Request Bytes if m . Max Request Bytes = = 0 { m . Max Request Bytes = embed . Default Max Request Bytes } m . Snapshot Count = etcdserver . Default Snapshot Count if mcfg . snapshot Count ! = 0 { m . Snapshot Count = mcfg . snapshot Count } m . Snapshot Catch Up Entries = etcdserver . Default Snapshot Catch Up Entries if mcfg . snapshot Catch Up Entries ! = 0 { m . Snapshot Catch Up Entries = mcfg . snapshot Catch Up Entries } if mcfg . auth Token ! = " " { m . Auth Token = mcfg . auth Token } m . Bcrypt Cost = uint ( bcrypt . Min Cost ) m . grpc Server Opts = [ ] grpc . Server Option { } if mcfg . grpc Keep Alive Min Time > time . Duration ( 0 ) { m . grpc Server Opts = append ( m . grpc Server Opts , grpc . Keepalive Enforcement Policy ( keepalive . Enforcement Policy { Min Time : mcfg . grpc Keep Alive Min Time , Permit Without Stream : false , } ) ) } if mcfg . grpc Keep Alive Interval > time . Duration ( 0 ) & & mcfg . grpc Keep Alive Timeout > time . Duration ( 0 ) { m . grpc Server Opts = append ( m . grpc Server Opts , grpc . Keepalive Params ( keepalive . Server Parameters { Time : mcfg . grpc Keep Alive Interval , Timeout : mcfg . grpc Keep Alive Timeout , } ) ) } m . client Max Call Send Msg Size = mcfg . client Max Call Send Msg Size m . client Max Call Recv Msg Size = mcfg . client Max Call Recv Msg Size m . use IP = mcfg . use IP m . Lease Checkpoint Interval = mcfg . lease Checkpoint Interval m . Initial Corrupt Check = true lcfg : = logutil . Default Zap Logger Config m . Logger Config = & lcfg m . Logger Config . Output Paths = [ ] string { " " } m . Logger Config . Error Output Paths = [ ] string { " " } if os . Getenv ( " " ) ! = " " { m . Logger Config . Output Paths = [ ] string { " " } m . Logger Config . Error Output Paths = [ ] string { " " } } m . Logger , err = m . Logger Config . Build ( ) if err ! = nil { t . Fatal ( err ) } return m } 
func ( m * member ) listen GRPC ( ) error { if m . use IP { } l , err : = transport . New Unix Listener ( m . grpc Addr ) if err ! = nil { return fmt . Errorf ( " " , m . grpc Addr , err ) } m . grpc Bridge , err = new Bridge ( m . grpc Addr ) if err ! = nil { l . Close ( ) return err } m . grpc Addr = scheme From TLSInfo ( m . Client TLSInfo ) + " " + m . grpc Bridge . inaddr m . grpc Listener = l return nil } 
func New Client V 3 ( m * member ) ( * clientv 3 . Client , error ) { if m . grpc Addr = = " " { return nil , fmt . Errorf ( " " ) } cfg : = clientv 3 . Config { Endpoints : [ ] string { m . grpc Addr } , Dial Timeout : 5 * time . Second , Dial Options : [ ] grpc . Dial Option { grpc . With Block ( ) } , Max Call Send Msg Size : m . client Max Call Send Msg Size , Max Call Recv Msg Size : m . client Max Call Recv Msg Size , } if m . Client TLSInfo ! = nil { tls , err : = m . Client TLSInfo . Client Config ( ) if err ! = nil { return nil , err } cfg . TLS = tls } if m . Dial Options ! = nil { cfg . Dial Options = append ( cfg . Dial Options , m . Dial Options . . . ) } return new Client V 3 ( cfg ) } 
func ( m * member ) Clone ( t testing . TB ) * member { mm : = & member { } mm . Server Config = m . Server Config var err error client URLStrs : = m . Client URLs . String Slice ( ) mm . Client URLs , err = types . New URLs ( client URLStrs ) if err ! = nil { } peer URLStrs : = m . Peer URLs . String Slice ( ) mm . Peer URLs , err = types . New URLs ( peer URLStrs ) if err ! = nil { } cluster Str : = m . Initial Peer URLs Map . String ( ) mm . Initial Peer URLs Map , err = types . New URLs Map ( cluster Str ) if err ! = nil { } mm . Initial Cluster Token = m . Initial Cluster Token mm . Election Ticks = m . Election Ticks mm . Peer TLSInfo = m . Peer TLSInfo mm . Client TLSInfo = m . Client TLSInfo return mm } 
func ( m * member ) Launch ( ) error { lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) var err error if m . s , err = etcdserver . New Server ( m . Server Config ) ; err ! = nil { return fmt . Errorf ( " " , err ) } m . s . Sync Ticker = time . New Ticker ( 5 0 0 * time . Millisecond ) m . s . Start ( ) var peer TLScfg * tls . Config if m . Peer TLSInfo ! = nil & & ! m . Peer TLSInfo . Empty ( ) { if peer TLScfg , err = m . Peer TLSInfo . Server Config ( ) ; err ! = nil { return err } } if m . grpc Listener ! = nil { var ( tlscfg * tls . Config ) if m . Client TLSInfo ! = nil & & ! m . Client TLSInfo . Empty ( ) { tlscfg , err = m . Client TLSInfo . Server Config ( ) if err ! = nil { return err } } m . grpc Server = v 3rpc . Server ( m . s , tlscfg , m . grpc Server Opts . . . ) m . grpc Server Peer = v 3rpc . Server ( m . s , peer TLScfg ) m . server Client = v 3client . New ( m . s ) lockpb . Register Lock Server ( m . grpc Server , v 3lock . New Lock Server ( m . server Client ) ) epb . Register Election Server ( m . grpc Server , v 3election . New Election Server ( m . server Client ) ) go m . grpc Server . Serve ( m . grpc Listener ) } m . raft Handler = & testutil . Pauseable Handler { Next : etcdhttp . New Peer Handler ( m . Logger , m . s ) } h : = ( http . Handler ) ( m . raft Handler ) if m . grpc Listener ! = nil { h = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if r . Proto Major = = 2 & & strings . Contains ( r . Header . Get ( " " ) , " " ) { m . grpc Server Peer . Serve HTTP ( w , r ) } else { m . raft Handler . Serve HTTP ( w , r ) } } ) } for _ , ln : = range m . Peer Listeners { cm : = cmux . New ( ln ) if m . grpc Server ! = nil { grpcl : = cm . Match ( cmux . HTTP 2 ( ) ) go m . grpc Server Peer . Serve ( grpcl ) } if peer TLScfg ! = nil { if ll , err = transport . New TLSListener ( ll , m . Peer TLSInfo ) ; err ! = nil { return err } } hs : = & httptest . Server { Listener : ll , Config : & http . Server { Handler : h , TLSConfig : peer TLScfg , Error Log : log . New ( ioutil . Discard , " " , 0 ) , } , TLS : peer TLScfg , } hs . Start ( ) donec : = make ( chan struct { } ) go func ( ) { defer close ( donec ) cm . Serve ( ) } ( ) closer : = func ( ) { ll . Close ( ) hs . Close Client Connections ( ) hs . Close ( ) < - donec } m . server Closers = append ( m . server Closers , closer ) } for _ , ln : = range m . Client Listeners { hs : = & httptest . Server { Listener : ln , Config : & http . Server { Handler : v 2http . New Client Handler ( m . Logger , m . s , m . Server Config . Req Timeout ( ) , ) , Error Log : log . New ( ioutil . Discard , " " , 0 ) , } , } if m . Client TLSInfo = = nil { hs . Start ( ) } else { info : = m . Client TLSInfo hs . TLS , err = info . Server Config ( ) if err ! = nil { return err } if err ! = nil { return err } hs . TLS . Certificates = [ ] tls . Certificate { * tls Cert } hs . Start TLS ( ) } closer : = func ( ) { ln . Close ( ) hs . Close Client Connections ( ) hs . Close ( ) } m . server Closers = append ( m . server Closers , closer ) } lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) return nil } 
func ( m * member ) Close ( ) { if m . grpc Bridge ! = nil { m . grpc Bridge . Close ( ) m . grpc Bridge = nil } if m . server Client ! = nil { m . server Client . Close ( ) m . server Client = nil } if m . grpc Server ! = nil { m . grpc Server . Stop ( ) m . grpc Server . Graceful Stop ( ) m . grpc Server = nil m . grpc Server Peer . Stop ( ) m . grpc Server Peer . Graceful Stop ( ) m . grpc Server Peer = nil } m . s . Hard Stop ( ) for _ , f : = range m . server Closers { f ( ) } } 
func ( m * member ) Stop ( t testing . TB ) { lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) m . Close ( ) m . server Closers = nil lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) } 
func check Leader Transition ( m * member , old Lead uint 6 4 ) uint 6 4 { interval : = time . Duration ( m . s . Cfg . Tick Ms ) * time . Millisecond for m . s . Lead ( ) = = 0 | | ( m . s . Lead ( ) = = old Lead ) { time . Sleep ( interval ) } return m . s . Lead ( ) } 
func ( m * member ) Restart ( t testing . TB ) error { lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) new Peer Listeners : = make ( [ ] net . Listener , 0 ) for _ , ln : = range m . Peer Listeners { new Peer Listeners = append ( new Peer Listeners , New Listener With Addr ( t , ln . Addr ( ) . String ( ) ) ) } m . Peer Listeners = new Peer Listeners new Client Listeners : = make ( [ ] net . Listener , 0 ) for _ , ln : = range m . Client Listeners { new Client Listeners = append ( new Client Listeners , New Listener With Addr ( t , ln . Addr ( ) . String ( ) ) ) } m . Client Listeners = new Client Listeners if m . grpc Listener ! = nil { if err : = m . listen GRPC ( ) ; err ! = nil { t . Fatal ( err ) } } err : = m . Launch ( ) lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , zap . Error ( err ) , ) return err } 
func ( m * member ) Terminate ( t testing . TB ) { lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) m . Close ( ) if ! m . keep Data Dir Terminate { if err : = os . Remove All ( m . Server Config . Data Dir ) ; err ! = nil { t . Fatal ( err ) } } lg . Info ( " " , zap . String ( " " , m . Name ) , zap . Strings ( " " , m . Peer URLs . String Slice ( ) ) , zap . Strings ( " " , m . Client URLs . String Slice ( ) ) , zap . String ( " " , m . grpc Addr ) , ) } 
func ( m * member ) Metric ( metric Name string ) ( string , error ) { cfgtls : = transport . TLSInfo { } tr , err : = transport . New Timeout Transport ( cfgtls , time . Second , time . Second , time . Second ) if err ! = nil { return " " , err } cli : = & http . Client { Transport : tr } resp , err : = cli . Get ( m . Client URLs [ 0 ] . String ( ) + " " ) if err ! = nil { return " " , err } defer resp . Body . Close ( ) b , rerr : = ioutil . Read All ( resp . Body ) if rerr ! = nil { return " " , rerr } lines : = strings . Split ( string ( b ) , " \n " ) for _ , l : = range lines { if strings . Has Prefix ( l , metric Name ) { return strings . Split ( l , " " ) [ 1 ] , nil } } return " " , nil } 
func ( m * member ) Inject Partition ( t testing . TB , others . . . * member ) { for _ , other : = range others { m . s . Cut Peer ( other . s . ID ( ) ) other . s . Cut Peer ( m . s . ID ( ) ) } } 
func ( m * member ) Recover Partition ( t testing . TB , others . . . * member ) { for _ , other : = range others { m . s . Mend Peer ( other . s . ID ( ) ) other . s . Mend Peer ( m . s . ID ( ) ) } } 
func New Cluster V 3 ( t testing . TB , cfg * Cluster Config ) * Cluster V 3 { cfg . Use GRPC = true if os . Getenv ( " " ) ! = " " { clientv 3 . Set Logger ( grpclog . New Logger V 2With Verbosity ( os . Stderr , os . Stderr , os . Stderr , 4 ) ) } clus : = & Cluster V 3 { cluster : New Cluster By Config ( t , cfg ) , } clus . Launch ( t ) if ! cfg . Skip Creating Client { for _ , m : = range clus . Members { client , err : = New Client V 3 ( m ) if err ! = nil { t . Fatalf ( " " , err ) } clus . clients = append ( clus . clients , client ) } } return clus } 
func ( opts * jwt Options ) Parse With Defaults ( opt Map map [ string ] string ) error { if opts . TTL = = 0 & & opt Map [ opt TTL ] = = " " { opts . TTL = Default TTL } return opts . Parse ( opt Map ) } 
func ( opts * jwt Options ) Parse ( opt Map map [ string ] string ) error { var err error if ttl : = opt Map [ opt TTL ] ; ttl ! = " " { opts . TTL , err = time . Parse Duration ( ttl ) if err ! = nil { return err } } if file : = opt Map [ opt Public Key ] ; file ! = " " { opts . Public Key , err = ioutil . Read File ( file ) if err ! = nil { return err } } if file : = opt Map [ opt Private Key ] ; file ! = " " { opts . Private Key , err = ioutil . Read File ( file ) if err ! = nil { return err } } opts . Sign Method = jwt . Get Signing Method ( method ) if opts . Sign Method = = nil { return Err Invalid Auth Method } return nil } 
func ( opts * jwt Options ) Key ( ) ( interface { } , error ) { switch opts . Sign Method . ( type ) { case * jwt . Signing Method RSA , * jwt . Signing Method RSAPSS : return opts . rsa Key ( ) case * jwt . Signing Method ECDSA : return opts . ec Key ( ) case * jwt . Signing Method HMAC : return opts . hmac Key ( ) default : return nil , fmt . Errorf ( " " , opts . Sign Method ) } } 
func ( h * header ) fill ( rh * pb . Response Header ) { if rh = = nil { plog . Panic ( " " ) } rh . Cluster Id = uint 6 4 ( h . cluster ID ) rh . Member Id = uint 6 4 ( h . member ID ) rh . Raft Term = h . sg . Term ( ) if rh . Revision = = 0 { rh . Revision = h . rev ( ) } } 
func ( wb * watch Broadcast ) add ( w * watcher ) bool { wb . mu . Lock ( ) defer wb . mu . Unlock ( ) if wb . nextrev > w . nextrev | | ( wb . nextrev = = 0 & & w . nextrev ! = 0 ) { } if wb . responses = = 0 { return true } if ! ok { return false } wb . receivers [ w ] = struct { } { } watchers Coalescing . Inc ( ) return true } 
func ( ws * watch Stream ) Watch ( id Watch ID , key , end [ ] byte , start Rev int 6 4 , fcs . . . Filter Func ) ( Watch ID , error ) { } ws . mu . Lock ( ) defer ws . mu . Unlock ( ) if ws . closed { return - 1 , Err Empty Watcher Range } if id = = Auto Watch ID { for ws . watchers [ ws . next ID ] ! = nil { ws . next ID + + } id = ws . next ID ws . next ID + + } else if _ , ok : = ws . watchers [ id ] ; ok { return - 1 , Err Watcher Duplicate ID } w , c : = ws . watchable . watch ( key , end , start Rev , id , ws . ch , fcs . . . ) ws . cancels [ id ] = c ws . watchers [ id ] = w return id , nil } 
func new File Encoder ( f * os . File , prev Crc uint 3 2 ) ( * encoder , error ) { offset , err : = f . Seek ( 0 , io . Seek Current ) if err ! = nil { return nil , err } return new Encoder ( f , prev Crc , int ( offset ) ) , nil } 
func purge File ( lg * zap . Logger , dirname string , suffix string , max uint , interval time . Duration , stop < - chan struct { } , purgec chan < - string ) < - chan error { err C : = make ( chan error , 1 ) go func ( ) { for { fnames , err : = Read Dir ( dirname ) if err ! = nil { err C < - err return } newfnames : = make ( [ ] string , 0 ) for _ , fname : = range fnames { if strings . Has Suffix ( fname , suffix ) { newfnames = append ( newfnames , fname ) } } sort . Strings ( newfnames ) fnames = newfnames for len ( newfnames ) > int ( max ) { f : = filepath . Join ( dirname , newfnames [ 0 ] ) l , err : = Try Lock File ( f , os . O _WRONLY , Private File Mode ) if err ! = nil { break } if err = os . Remove ( f ) ; err ! = nil { err C < - err return } if err = l . Close ( ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , l . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , l . Name ( ) , err ) } err C < - err return } if lg ! = nil { lg . Info ( " " , zap . String ( " " , f ) ) } else { plog . Infof ( " " , f ) } newfnames = newfnames [ 1 : ] } if purgec ! = nil { for i : = 0 ; i < len ( fnames ) - len ( newfnames ) ; i + + { purgec < - fnames [ i ] } } select { case < - time . After ( interval ) : case < - stop : return } } } ( ) return err C } 
func ( ss * Strings Value ) Set ( s string ) error { * ss = strings . Split ( s , " " ) return nil } 
func New Strings Value ( s string ) ( ss * Strings Value ) { if s = = " " { return & Strings Value { } } ss = new ( Strings Value ) if err : = ss . Set ( s ) ; err ! = nil { plog . Panicf ( " " , err ) } return ss } 
func Strings From Flag ( fs * flag . Flag Set , flag Name string ) [ ] string { return [ ] string ( * fs . Lookup ( flag Name ) . Value . ( * Strings Value ) ) } 
func Cluster ( v string ) string { vs : = strings . Split ( v , " " ) if len ( vs ) < = 2 { return v } return fmt . Sprintf ( " " , vs [ 0 ] , vs [ 1 ] ) } 
func New Page Writer ( w io . Writer , page Bytes , page Offset int ) * Page Writer { return & Page Writer { w : w , page Offset : page Offset , page Bytes : page Bytes , buf : make ( [ ] byte , default Buffer Bytes + page Bytes ) , buf Watermark Bytes : default Buffer Bytes , } } 
func new Watch Hub ( capacity int ) * watcher Hub { return & watcher Hub { watchers : make ( map [ string ] * list . List ) , Event History : new Event History ( capacity ) , } } 
func ( wh * watcher Hub ) watch ( key string , recursive , stream bool , index , store Index uint 6 4 ) ( Watcher , * v 2error . Error ) { report Watch Request ( ) event , err : = wh . Event History . scan ( key , recursive , index ) if err ! = nil { err . Index = store Index return nil , err } w : = & watcher { event Chan : make ( chan * Event , 1 0 0 ) , wh . mutex . Lock ( ) defer wh . mutex . Unlock ( ) ne . Etcd Index = store Index w . event Chan < - ne return w , nil } l , ok : = wh . watchers [ key ] var elem * list . Element if ok { } else { elem = l . Push Back ( w ) wh . watchers [ key ] = l } w . remove = func ( ) { if w . removed { } w . removed = true l . Remove ( elem ) atomic . Add Int 6 4 ( & wh . count , - 1 ) report Watcher Removed ( ) if l . Len ( ) = = 0 { delete ( wh . watchers , key ) } } atomic . Add Int 6 4 ( & wh . count , 1 ) report Watcher Added ( ) return w , nil } 
func ( wh * watcher Hub ) notify ( e * Event ) { e = wh . Event History . add Event ( e ) segments : = strings . Split ( e . Node . Key , " " ) curr Path : = " " } } 
func ( wh * watcher Hub ) clone ( ) * watcher Hub { cloned History : = wh . Event History . clone ( ) return & watcher Hub { Event History : cloned History , } } 
func is Hidden ( watch Path , key Path string ) bool { } return strings . Contains ( after Path , " " ) } 
func New Timeout Listener ( addr string , scheme string , tlsinfo * TLSInfo , rdtimeoutd , wtimeoutd time . Duration ) ( net . Listener , error ) { ln , err : = new Listener ( addr , scheme ) if err ! = nil { return nil , err } ln = & rw Timeout Listener { Listener : ln , rdtimeoutd : rdtimeoutd , wtimeoutd : wtimeoutd , } if ln , err = wrap TLS ( scheme , tlsinfo , ln ) ; err ! = nil { return nil , err } return ln , nil } 
func ( srv * Server ) create Etcd Log File ( ) error { var err error srv . etcd Log File , err = os . Create ( srv . Member . Etcd . Log Outputs [ 0 ] ) if err ! = nil { return err } srv . lg . Info ( " " , zap . String ( " " , srv . Member . Etcd . Log Outputs [ 0 ] ) ) return nil } 
func ( srv * Server ) run Etcd ( ) error { errc : = make ( chan error ) go func ( ) { time . Sleep ( 5 * time . Second ) } ( ) if srv . etcd Cmd ! = nil { srv . lg . Info ( " " , zap . String ( " " , srv . etcd Cmd . Path ) , ) err : = srv . etcd Cmd . Start ( ) perr : = < - errc srv . lg . Info ( " " , zap . String ( " " , srv . etcd Cmd . Path ) , zap . Errors ( " " , [ ] error { err , perr } ) , ) if err ! = nil { return err } return perr } select { case < - srv . etcd Server . Server . Ready Notify ( ) : srv . lg . Info ( " " ) case < - time . After ( time . Minute ) : srv . etcd Server . Close ( ) return fmt . Errorf ( " " , < - srv . etcd Server . Err ( ) ) } return < - errc } 
func ( srv * Server ) stop Etcd ( sig os . Signal ) error { srv . stop Proxy ( ) if srv . etcd Cmd ! = nil { srv . lg . Info ( " " , zap . String ( " " , srv . etcd Cmd . Path ) , zap . String ( " " , sig . String ( ) ) , ) err : = srv . etcd Cmd . Process . Signal ( sig ) if err ! = nil { return err } errc : = make ( chan error ) go func ( ) { _ , ew : = srv . etcd Cmd . Process . Wait ( ) errc < - ew close ( errc ) } ( ) select { case < - time . After ( 5 * time . Second ) : srv . etcd Cmd . Process . Kill ( ) case e : = < - errc : return e } err = < - errc srv . lg . Info ( " " , zap . String ( " " , srv . etcd Cmd . Path ) , zap . String ( " " , sig . String ( ) ) , zap . Error ( err ) , ) return err } srv . lg . Info ( " " ) srv . etcd Server . Server . Hard Stop ( ) srv . etcd Server . Close ( ) srv . lg . Info ( " " ) return nil } 
func ( srv * Server ) save TLSAssets ( ) error { if srv . Member . Peer Cert Path ! = " " { if srv . Member . Peer Cert Data = = " " { return fmt . Errorf ( " " , srv . Member . Peer Cert Path ) } if err : = ioutil . Write File ( srv . Member . Peer Cert Path , [ ] byte ( srv . Member . Peer Cert Data ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Peer Key Path ! = " " { if srv . Member . Peer Key Data = = " " { return fmt . Errorf ( " " , srv . Member . Peer Key Path ) } if err : = ioutil . Write File ( srv . Member . Peer Key Path , [ ] byte ( srv . Member . Peer Key Data ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Peer Trusted CAPath ! = " " { if srv . Member . Peer Trusted CAData = = " " { return fmt . Errorf ( " " , srv . Member . Peer Trusted CAPath ) } if err : = ioutil . Write File ( srv . Member . Peer Trusted CAPath , [ ] byte ( srv . Member . Peer Trusted CAData ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Peer Cert Path ! = " " & & srv . Member . Peer Key Path ! = " " & & srv . Member . Peer Trusted CAPath ! = " " { srv . lg . Info ( " " , zap . String ( " " , srv . Member . Peer Cert Path ) , zap . String ( " " , srv . Member . Peer Key Path ) , zap . String ( " " , srv . Member . Peer Trusted CAPath ) , ) } if srv . Member . Client Cert Path ! = " " { if srv . Member . Client Cert Data = = " " { return fmt . Errorf ( " " , srv . Member . Client Cert Path ) } if err : = ioutil . Write File ( srv . Member . Client Cert Path , [ ] byte ( srv . Member . Client Cert Data ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Client Key Path ! = " " { if srv . Member . Client Key Data = = " " { return fmt . Errorf ( " " , srv . Member . Client Key Path ) } if err : = ioutil . Write File ( srv . Member . Client Key Path , [ ] byte ( srv . Member . Client Key Data ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Client Trusted CAPath ! = " " { if srv . Member . Client Trusted CAData = = " " { return fmt . Errorf ( " " , srv . Member . Client Trusted CAPath ) } if err : = ioutil . Write File ( srv . Member . Client Trusted CAPath , [ ] byte ( srv . Member . Client Trusted CAData ) , 0 6 4 4 ) ; err ! = nil { return err } } if srv . Member . Client Cert Path ! = " " & & srv . Member . Client Key Path ! = " " & & srv . Member . Client Trusted CAPath ! = " " { srv . lg . Info ( " " , zap . String ( " " , srv . Member . Client Cert Path ) , zap . String ( " " , srv . Member . Client Key Path ) , zap . String ( " " , srv . Member . Client Trusted CAPath ) , ) } return nil } 
func ( srv * Server ) handle _SIGQUIT _ETCD _AND _REMOVE _DATA _AND _STOP _AGENT ( ) ( * rpcpb . Response , error ) { err : = srv . stop Etcd ( syscall . SIGQUIT ) if err ! = nil { return nil , err } if srv . etcd Server ! = nil { srv . etcd Server . Get Logger ( ) . Sync ( ) } else { srv . etcd Log File . Sync ( ) srv . etcd Log File . Close ( ) } err = os . Remove All ( srv . Member . Base Dir ) if err ! = nil { return nil , err } srv . lg . Info ( " " , zap . String ( " " , srv . Member . Base Dir ) ) return & rpcpb . Response { Success : true , Status : " " , } , nil } 
func Limit Listener ( l net . Listener , n int ) net . Listener { return & limit Listener { l , make ( chan struct { } , n ) } } 
func allow Method ( w http . Response Writer , m string , ms . . . string ) bool { for _ , meth : = range ms { if m = = meth { return true } } w . Header ( ) . Set ( " " , strings . Join ( ms , " " ) ) http . Error ( w , " " , http . Status Method Not Allowed ) return false } 
func New Watch Server ( s * etcdserver . Etcd Server ) pb . Watch Server { return & watch Server { lg : s . Cfg . Logger , cluster ID : int 6 4 ( s . Cluster ( ) . ID ( ) ) , member ID : int 6 4 ( s . ID ( ) ) , max Request Bytes : int ( s . Cfg . Max Request Bytes + grpc Overhead Bytes ) , sg : s , watchable : s . Watchable ( ) , ag : s , } } 
func Get Progress Report Interval ( ) time . Duration { progress Report Interval Mu . RLock ( ) interval : = progress Report Interval progress Report Interval Mu . RUnlock ( ) return interval + jitter } 
func Set Progress Report Interval ( new Timeout time . Duration ) { progress Report Interval Mu . Lock ( ) progress Report Interval = new Timeout progress Report Interval Mu . Unlock ( ) } 
func Filters From Request ( creq * pb . Watch Create Request ) [ ] mvcc . Filter Func { filters : = make ( [ ] mvcc . Filter Func , 0 , len ( creq . Filters ) ) for _ , ft : = range creq . Filters { switch ft { case pb . Watch Create Request _NOPUT : filters = append ( filters , filter No Put ) case pb . Watch Create Request _NODELETE : filters = append ( filters , filter No Delete ) default : } } return filters } 
func new Pipeline Handler ( t * Transport , r Raft , cid types . ID ) http . Handler { return & pipeline Handler { lg : t . Logger , local ID : t . ID , tr : t , r : r , cid : cid , } } 
func ( h * snapshot Handler ) Serve HTTP ( w http . Response Writer , r * http . Request ) { start : = time . Now ( ) if r . Method ! = " " { w . Header ( ) . Set ( " " , " " ) http . Error ( w , " " , http . Status Method Not Allowed ) snapshot Receive Failures . With Label Values ( unknown Snapshot Sender ) . Inc ( ) return } w . Header ( ) . Set ( " " , h . cid . String ( ) ) if err : = check Cluster Compatibility From Header ( h . lg , h . local ID , r . Header , h . cid ) ; err ! = nil { http . Error ( w , err . Error ( ) , http . Status Precondition Failed ) snapshot Receive Failures . With Label Values ( unknown Snapshot Sender ) . Inc ( ) return } add Remote From Request ( h . tr , r ) dec : = & message Decoder { r : r . Body } from : = types . ID ( m . From ) . String ( ) if err ! = nil { msg : = fmt . Sprintf ( " " , err ) if h . lg ! = nil { h . lg . Warn ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . Error ( err ) , ) } else { plog . Error ( msg ) } http . Error ( w , msg , http . Status Bad Request ) recv Failures . With Label Values ( r . Remote Addr ) . Inc ( ) snapshot Receive Failures . With Label Values ( from ) . Inc ( ) return } msg Size : = m . Size ( ) received Bytes . With Label Values ( from ) . Add ( float 6 4 ( msg Size ) ) if m . Type ! = raftpb . Msg Snap { if h . lg ! = nil { h . lg . Warn ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . String ( " " , m . Type . String ( ) ) , ) } else { plog . Errorf ( " " , m . Type ) } http . Error ( w , " " , http . Status Bad Request ) snapshot Receive Failures . With Label Values ( from ) . Inc ( ) return } if h . lg ! = nil { h . lg . Info ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . Uint 6 4 ( " " , m . Snapshot . Metadata . Index ) , zap . Int ( " " , msg Size ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( msg Size ) ) ) , ) } else { plog . Infof ( " " , m . Snapshot . Metadata . Index , types . ID ( m . From ) ) } if err ! = nil { msg : = fmt . Sprintf ( " " , err ) if h . lg ! = nil { h . lg . Warn ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . Uint 6 4 ( " " , m . Snapshot . Metadata . Index ) , zap . Error ( err ) , ) } else { plog . Error ( msg ) } http . Error ( w , msg , http . Status Internal Server Error ) snapshot Receive Failures . With Label Values ( from ) . Inc ( ) return } received Bytes . With Label Values ( from ) . Add ( float 6 4 ( n ) ) if h . lg ! = nil { h . lg . Info ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . Uint 6 4 ( " " , m . Snapshot . Metadata . Index ) , zap . Int 6 4 ( " " , n ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( n ) ) ) , ) } else { plog . Infof ( " " , m . Snapshot . Metadata . Index , types . ID ( m . From ) ) } if err : = h . r . Process ( context . TODO ( ) , m ) ; err ! = nil { switch v : = err . ( type ) { default : msg : = fmt . Sprintf ( " " , err ) if h . lg ! = nil { h . lg . Warn ( " " , zap . String ( " " , h . local ID . String ( ) ) , zap . String ( " " , from ) , zap . Error ( err ) , ) } else { plog . Error ( msg ) } http . Error ( w , msg , http . Status Internal Server Error ) snapshot Receive Failures . With Label Values ( from ) . Inc ( ) } return } snapshot Receive . With Label Values ( from ) . Inc ( ) snapshot Receive Seconds . With Label Values ( from ) . Observe ( time . Since ( start ) . Seconds ( ) ) } 
func check Cluster Compatibility From Header ( lg * zap . Logger , local ID types . ID , header http . Header , cid types . ID ) error { remote Name : = header . Get ( " " ) remote Server : = server Version ( header ) remote Vs : = " " if remote Server ! = nil { remote Vs = remote Server . String ( ) } remote Min Cluster Ver : = min Cluster Version ( header ) remote Min Cluster Vs : = " " if remote Min Cluster Ver ! = nil { remote Min Cluster Vs = remote Min Cluster Ver . String ( ) } local Server , local Min Cluster , err : = check Version Compatibility ( remote Name , remote Server , remote Min Cluster Ver ) local Vs : = " " if local Server ! = nil { local Vs = local Server . String ( ) } local Min Cluster Vs : = " " if local Min Cluster ! = nil { local Min Cluster Vs = local Min Cluster . String ( ) } if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , local ID . String ( ) ) , zap . String ( " " , cid . String ( ) ) , zap . String ( " " , local Vs ) , zap . String ( " " , local Min Cluster Vs ) , zap . String ( " " , remote Name ) , zap . String ( " " , remote Vs ) , zap . String ( " " , remote Min Cluster Vs ) , zap . Error ( err ) , ) } else { plog . Errorf ( " " , err ) } return err Incompatible Version } if gcid : = header . Get ( " " ) ; gcid ! = cid . String ( ) { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , local ID . String ( ) ) , zap . String ( " " , cid . String ( ) ) , zap . String ( " " , local Vs ) , zap . String ( " " , local Min Cluster Vs ) , zap . String ( " " , remote Name ) , zap . String ( " " , remote Vs ) , zap . String ( " " , remote Min Cluster Vs ) , zap . String ( " " , gcid ) , ) } else { plog . Errorf ( " " , gcid , cid ) } return err Cluster IDMismatch } return nil } 
func Key Exists ( key string ) clientv 3 . Cmp { return clientv 3 . Compare ( clientv 3 . Version ( key ) , " " , 0 ) } 
func Key Missing ( key string ) clientv 3 . Cmp { return clientv 3 . Compare ( clientv 3 . Version ( key ) , " " , 0 ) } 
func Validate Secure Endpoints ( tls Info TLSInfo , eps [ ] string ) ( [ ] string , error ) { t , err : = New Transport ( tls Info , 5 * time . Second ) if err ! = nil { return nil , err } var errs [ ] string var endpoints [ ] string for _ , ep : = range eps { if ! strings . Has Prefix ( ep , " " ) { errs = append ( errs , fmt . Sprintf ( " " , ep ) ) continue } conn , cerr : = t . Dial ( " " , ep [ len ( " " ) : ] ) if cerr ! = nil { errs = append ( errs , fmt . Sprintf ( " " , ep , cerr ) ) continue } conn . Close ( ) endpoints = append ( endpoints , ep ) } if len ( errs ) ! = 0 { err = fmt . Errorf ( " " , strings . Join ( errs , " " ) ) } return endpoints , err } 
func put New KV ( kv v 3 . KV , key , val string , lease ID v 3 . Lease ID ) ( int 6 4 , error ) { cmp : = v 3 . Compare ( v 3 . Version ( key ) , " " , 0 ) req : = v 3 . Op Put ( key , val , v 3 . With Lease ( lease ID ) ) txnresp , err : = kv . Txn ( context . TODO ( ) ) . If ( cmp ) . Then ( req ) . Commit ( ) if err ! = nil { return 0 , err } if ! txnresp . Succeeded { return 0 , Err Key Exists } return txnresp . Header . Revision , nil } 
func new Sequential KV ( kv v 3 . KV , prefix , val string ) ( * Remote KV , error ) { resp , err : = kv . Get ( context . TODO ( ) , prefix , v 3 . With Last Key ( ) . . . ) if err ! = nil { return nil , err } if len ( resp . Kvs ) ! = 0 { fields : = strings . Split ( string ( resp . Kvs [ 0 ] . Key ) , " " ) _ , serr : = fmt . Sscanf ( fields [ len ( fields ) - 1 ] , " " , & new Seq Num ) if serr ! = nil { return nil , serr } new Seq Num + + } new Key : = fmt . Sprintf ( " " , prefix , new Seq Num ) req Prefix : = v 3 . Op Put ( base Key , " " ) reqnew Key : = v 3 . Op Put ( new Key , val ) txn : = kv . Txn ( context . TODO ( ) ) txnresp , err : = txn . If ( cmp ) . Then ( req Prefix , reqnew Key ) . Commit ( ) if err ! = nil { return nil , err } if ! txnresp . Succeeded { return new Sequential KV ( kv , prefix , val ) } return & Remote KV { kv , new Key , txnresp . Header . Revision , val } , nil } 
func new Ephemeral KV ( s * concurrency . Session , key , val string ) ( * Ephemeral KV , error ) { k , err : = new KV ( s . Client ( ) , key , val , s . Lease ( ) ) if err ! = nil { return nil , err } return & Ephemeral KV { * k } , nil } 
func new Unique Ephemeral Key ( s * concurrency . Session , prefix string ) ( * Ephemeral KV , error ) { return new Unique Ephemeral KV ( s , prefix , " " ) } 
func new Unique Ephemeral KV ( s * concurrency . Session , prefix , val string ) ( ek * Ephemeral KV , err error ) { for { new Key : = fmt . Sprintf ( " " , prefix , time . Now ( ) . Unix Nano ( ) ) ek , err = new Ephemeral KV ( s , new Key , val ) if err = = nil | | err ! = Err Key Exists { break } } return ek , err } 
func New Update Dir Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , } , Action : func ( c * cli . Context ) error { updatedir Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func updatedir Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] ttl : = c . Int ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Set ( ctx , key , " " , & client . Set Options { TTL : time . Duration ( ttl ) * time . Second , Dir : true , Prev Exist : client . Prev Exist } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if c . Global String ( " " ) ! = " " { print Response Key ( resp , c . Global String ( " " ) ) } } 
func handle Backup ( c * cli . Context ) error { var src WAL string var dest WAL string with V 3 : = c . Bool ( " " ) src Snap : = filepath . Join ( c . String ( " " ) , " " , " " ) dest Snap : = filepath . Join ( c . String ( " " ) , " " , " " ) if c . String ( " " ) ! = " " { src WAL = c . String ( " " ) } else { src WAL = filepath . Join ( c . String ( " " ) , " " , " " ) } if c . String ( " " ) ! = " " { dest WAL = c . String ( " " ) } else { dest WAL = filepath . Join ( c . String ( " " ) , " " , " " ) } if err : = fileutil . Create Dir All ( dest Snap ) ; err ! = nil { log . Fatalf ( " " , dest Snap , err ) } walsnap : = save Snap ( dest Snap , src Snap ) metadata , state , ents : = load WAL ( src WAL , walsnap , with V 3 ) save DB ( filepath . Join ( dest Snap , " " ) , filepath . Join ( src Snap , " " ) , state . Commit , with V 3 ) idgen : = idutil . New Generator ( 0 , time . Now ( ) ) metadata . Node ID = idgen . Next ( ) metadata . Cluster ID = idgen . Next ( ) neww , err : = wal . Create ( zap . New Example ( ) , dest WAL , pbutil . Must Marshal ( & metadata ) ) if err ! = nil { log . Fatal ( err ) } defer neww . Close ( ) if err : = neww . Save ( state , ents ) ; err ! = nil { log . Fatal ( err ) } if err : = neww . Save Snapshot ( walsnap ) ; err ! = nil { log . Fatal ( err ) } return nil } 
func save DB ( dest DB , src DB string , idx uint 6 4 , v 3 bool ) { ch : = make ( chan * bolt . DB , 1 ) go func ( ) { db , err : = bolt . Open ( src DB , 0 4 4 4 , & bolt . Options { Read Only : true } ) if err ! = nil { log . Fatal ( err ) } ch < - db } ( ) select { case src = < - ch : case < - time . After ( time . Second ) : log . Println ( " " , src DB ) src = < - ch } defer src . Close ( ) tx , err : = src . Begin ( false ) if err ! = nil { log . Fatal ( err ) } if err ! = nil { log . Fatal ( err ) } if _ , err : = tx . Write To ( dest ) ; err ! = nil { log . Fatal ( err ) } dest . Close ( ) if err : = tx . Rollback ( ) ; err ! = nil { log . Fatal ( err ) } } db , err : = bolt . Open ( dest DB , 0 6 4 4 , & bolt . Options { } ) if err ! = nil { log . Fatal ( err ) } tx , err : = db . Begin ( true ) if err ! = nil { log . Fatal ( err ) } } binary . Big Endian . Put Uint 6 4 ( idx Bytes , idx ) b , err : = tx . Create Bucket If Not Exists ( [ ] byte ( " " ) ) if err ! = nil { log . Fatal ( err ) } b . Put ( [ ] byte ( " " ) , idx Bytes ) } if err : = tx . Commit ( ) ; err ! = nil { log . Fatal ( err ) } if err : = db . Close ( ) ; err ! = nil { log . Fatal ( err ) } } 
func New Watch Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : run Watcher Func , } cmd . Flags ( ) . Duration Var ( & running Time , " " , 6 0 , " " ) cmd . Flags ( ) . String Var ( & watch Prefix , " " , " " , " " ) cmd . Flags ( ) . Int Var ( & no Of Prefixes , " " , 1 0 , " " ) cmd . Flags ( ) . Int Var ( & watch Per Prefix , " " , 1 0 , " " ) cmd . Flags ( ) . Int Var ( & total Keys , " " , 1 0 0 0 , " " ) return cmd } 
func New V 3 ( lg * zap . Logger ) Manager { if lg = = nil { lg = zap . New Example ( ) } return & v 3Manager { lg : lg } } 
func ( s * v 3Manager ) Save ( ctx context . Context , cfg clientv 3 . Config , db Path string ) error { if len ( cfg . Endpoints ) ! = 1 { return fmt . Errorf ( " " , cfg . Endpoints ) } cli , err : = clientv 3 . New ( cfg ) if err ! = nil { return err } defer cli . Close ( ) partpath : = db Path + " " defer os . Remove All ( partpath ) var f * os . File f , err = os . Open File ( partpath , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , fileutil . Private File Mode ) if err ! = nil { return fmt . Errorf ( " " , partpath , err ) } s . lg . Info ( " " , zap . String ( " " , partpath ) , ) now : = time . Now ( ) var rd io . Read Closer rd , err = cli . Snapshot ( ctx ) if err ! = nil { return err } s . lg . Info ( " " , zap . String ( " " , cfg . Endpoints [ 0 ] ) , ) if _ , err = io . Copy ( f , rd ) ; err ! = nil { return err } if err = fileutil . Fsync ( f ) ; err ! = nil { return err } if err = f . Close ( ) ; err ! = nil { return err } s . lg . Info ( " " , zap . String ( " " , cfg . Endpoints [ 0 ] ) , zap . Duration ( " " , time . Since ( now ) ) , ) if err = os . Rename ( partpath , db Path ) ; err ! = nil { return fmt . Errorf ( " " , partpath , db Path , err ) } s . lg . Info ( " " , zap . String ( " " , db Path ) ) return nil } 
func ( s * v 3Manager ) Status ( db Path string ) ( ds Status , err error ) { if _ , err = os . Stat ( db Path ) ; err ! = nil { return ds , err } db , err : = bolt . Open ( db Path , 0 4 0 0 , & bolt . Options { Read Only : true } ) if err ! = nil { return ds , err } defer db . Close ( ) h : = crc 3 2 . New ( crc 3 2 . Make Table ( crc 3 2 . Castagnoli ) ) if err = db . View ( func ( tx * bolt . Tx ) error { for db Err : = range tx . Check ( ) { db Err Strings = append ( db Err Strings , db Err . Error ( ) ) } if len ( db Err Strings ) > 0 { return fmt . Errorf ( " \n " + strings . Join ( db Err Strings , " \n " ) , len ( db Err Strings ) ) } ds . Total Size = tx . Size ( ) c : = tx . Cursor ( ) for next , _ : = c . First ( ) ; next ! = nil ; next , _ = c . Next ( ) { b : = tx . Bucket ( next ) if b = = nil { return fmt . Errorf ( " " , string ( next ) ) } h . Write ( next ) iskeyb : = ( string ( next ) = = " " ) b . For Each ( func ( k , v [ ] byte ) error { h . Write ( k ) h . Write ( v ) if iskeyb { rev : = bytes To Rev ( k ) ds . Revision = rev . main } ds . Total Key + + return nil } ) } return nil } ) ; err ! = nil { return ds , err } ds . Hash = h . Sum 3 2 ( ) return ds , nil } 
func ( s * v 3Manager ) Restore ( cfg Restore Config ) error { p URLs , err : = types . New URLs ( cfg . Peer URLs ) if err ! = nil { return err } var ics types . URLs Map ics , err = types . New URLs Map ( cfg . Initial Cluster ) if err ! = nil { return err } srv : = etcdserver . Server Config { Logger : s . lg , Name : cfg . Name , Peer URLs : p URLs , Initial Peer URLs Map : ics , Initial Cluster Token : cfg . Initial Cluster Token , } if err = srv . Verify Bootstrap ( ) ; err ! = nil { return err } s . cl , err = membership . New Cluster From URLs Map ( s . lg , cfg . Initial Cluster Token , ics ) if err ! = nil { return err } data Dir : = cfg . Output Data Dir if data Dir = = " " { data Dir = cfg . Name + " " } if fileutil . Exist ( data Dir ) { return fmt . Errorf ( " " , data Dir ) } wal Dir : = cfg . Output WALDir if wal Dir = = " " { wal Dir = filepath . Join ( data Dir , " " , " " ) } else if fileutil . Exist ( wal Dir ) { return fmt . Errorf ( " " , wal Dir ) } s . name = cfg . Name s . db Path = cfg . Snapshot Path s . wal Dir = wal Dir s . snap Dir = filepath . Join ( data Dir , " " , " " ) s . skip Hash Check = cfg . Skip Hash Check s . lg . Info ( " " , zap . String ( " " , s . db Path ) , zap . String ( " " , s . wal Dir ) , zap . String ( " " , data Dir ) , zap . String ( " " , s . snap Dir ) , ) if err = s . save DB ( ) ; err ! = nil { return err } if err = s . save WALAnd Snap ( ) ; err ! = nil { return err } s . lg . Info ( " " , zap . String ( " " , s . db Path ) , zap . String ( " " , s . wal Dir ) , zap . String ( " " , data Dir ) , zap . String ( " " , s . snap Dir ) , ) return nil } 
func ( s * v 3Manager ) save DB ( ) error { f , ferr : = os . Open File ( s . db Path , os . O _RDONLY , 0 6 0 0 ) if ferr ! = nil { return ferr } defer f . Close ( ) } sha : = make ( [ ] byte , sha 2 5 6 . Size ) if _ , err : = f . Read ( sha ) ; err ! = nil { return err } if _ , err : = f . Seek ( 0 , io . Seek Start ) ; err ! = nil { return err } if err : = fileutil . Create Dir All ( s . snap Dir ) ; err ! = nil { return err } dbpath : = filepath . Join ( s . snap Dir , " " ) db , dberr : = os . Open File ( dbpath , os . O _RDWR | os . O _CREATE , 0 6 0 0 ) if dberr ! = nil { return dberr } if _ , err : = io . Copy ( db , f ) ; err ! = nil { return err } if serr ! = nil { return serr } has Hash : = ( off % 5 1 2 ) = = sha 2 5 6 . Size if has Hash { if err : = db . Truncate ( off - sha 2 5 6 . Size ) ; err ! = nil { return err } } if ! has Hash & & ! s . skip Hash Check { return fmt . Errorf ( " " ) } if has Hash & & ! s . skip Hash Check { } h : = sha 2 5 6 . New ( ) if _ , err : = io . Copy ( h , db ) ; err ! = nil { return err } dbsha : = h . Sum ( nil ) if ! reflect . Deep Equal ( sha , dbsha ) { return fmt . Errorf ( " " , sha , dbsha ) } } commit : = len ( s . cl . Members ( ) ) mvs : = mvcc . New Store ( s . lg , be , lessor , ( * init Index ) ( & commit ) ) txn : = mvs . Write ( ) btx : = be . Batch Tx ( ) del : = func ( k , v [ ] byte ) error { txn . Delete Range ( k , nil ) return nil } mvs . Commit ( ) mvs . Close ( ) be . Close ( ) return nil } 
func ( s * v 3Manager ) save WALAnd Snap ( ) error { if err : = fileutil . Create Dir All ( s . wal Dir ) ; err ! = nil { return err } s . cl . Set Store ( st ) for _ , m : = range s . cl . Members ( ) { s . cl . Add Member ( m ) } m : = s . cl . Member By Name ( s . name ) md : = & etcdserverpb . Metadata { Node ID : uint 6 4 ( m . ID ) , Cluster ID : uint 6 4 ( s . cl . ID ( ) ) } metadata , merr : = md . Marshal ( ) if merr ! = nil { return merr } w , walerr : = wal . Create ( s . lg , s . wal Dir , metadata ) if walerr ! = nil { return walerr } defer w . Close ( ) peers : = make ( [ ] raft . Peer , len ( s . cl . Member IDs ( ) ) ) for i , id : = range s . cl . Member IDs ( ) { ctx , err : = json . Marshal ( ( * s . cl ) . Member ( id ) ) if err ! = nil { return err } peers [ i ] = raft . Peer { ID : uint 6 4 ( id ) , Context : ctx } } ents : = make ( [ ] raftpb . Entry , len ( peers ) ) node IDs : = make ( [ ] uint 6 4 , len ( peers ) ) for i , p : = range peers { node IDs [ i ] = p . ID cc : = raftpb . Conf Change { Type : raftpb . Conf Change Add Node , Node ID : p . ID , Context : p . Context , } d , err : = cc . Marshal ( ) if err ! = nil { return err } ents [ i ] = raftpb . Entry { Type : raftpb . Entry Conf Change , Term : 1 , Index : uint 6 4 ( i + 1 ) , Data : d , } } commit , term : = uint 6 4 ( len ( ents ) ) , uint 6 4 ( 1 ) if err : = w . Save ( raftpb . Hard State { Term : term , Vote : peers [ 0 ] . ID , Commit : commit , } , ents ) ; err ! = nil { return err } b , berr : = st . Save ( ) if berr ! = nil { return berr } raft Snap : = raftpb . Snapshot { Data : b , Metadata : raftpb . Snapshot Metadata { Index : commit , Term : term , Conf State : raftpb . Conf State { Nodes : node IDs , } , } , } sn : = snap . New ( s . lg , s . snap Dir ) if err : = sn . Save Snap ( raft Snap ) ; err ! = nil { return err } return w . Save Snapshot ( walpb . Snapshot { Index : commit , Term : term } ) } 
func New Auth Store ( lg * zap . Logger , be backend . Backend , tp Token Provider , bcrypt Cost int ) * auth Store { if bcrypt Cost < bcrypt . Min Cost | | bcrypt Cost > bcrypt . Max Cost { if lg ! = nil { lg . Warn ( " " , zap . Int ( " " , bcrypt . Min Cost ) , zap . Int ( " " , bcrypt . Max Cost ) , zap . Int ( " " , bcrypt . Default Cost ) , zap . Int ( " " , bcrypt Cost ) ) } else { plog . Warningf ( " " , bcrypt . Default Cost , bcrypt Cost ) } bcrypt Cost = bcrypt . Default Cost } tx : = be . Batch Tx ( ) tx . Lock ( ) tx . Unsafe Create Bucket ( auth Bucket Name ) tx . Unsafe Create Bucket ( auth Users Bucket Name ) tx . Unsafe Create Bucket ( auth Roles Bucket Name ) enabled : = false _ , vs : = tx . Unsafe Range ( auth Bucket Name , enable Flag Key , nil , 0 ) if len ( vs ) = = 1 { if bytes . Equal ( vs [ 0 ] , auth Enabled ) { enabled = true } } as : = & auth Store { revision : get Revision ( tx ) , lg : lg , be : be , enabled : enabled , range Perm Cache : make ( map [ string ] * unified Range Permissions ) , token Provider : tp , bcrypt Cost : bcrypt Cost , } if enabled { as . token Provider . enable ( ) } if as . Revision ( ) = = 0 { as . commit Revision ( tx ) } tx . Unlock ( ) be . Force Commit ( ) return as } 
func New Token Provider ( lg * zap . Logger , token Opts string , index Waiter func ( uint 6 4 ) < - chan struct { } ) ( Token Provider , error ) { token Type , type Specific Opts , err : = decompose Opts ( lg , token Opts ) if err ! = nil { return nil , Err Invalid Auth Opts } switch token Type { case token Type Simple : if lg ! = nil { lg . Warn ( " " ) } else { plog . Warningf ( " " ) } return new Token Provider Simple ( lg , index Waiter ) , nil case token Type JWT : return new Token Provider JWT ( lg , type Specific Opts ) case " " : return new Token Provider Nop ( ) default : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , token Type ) , zap . Error ( Err Invalid Auth Opts ) , ) } else { plog . Errorf ( " " , token Type ) } return nil , Err Invalid Auth Opts } } 
func ( t * Transport ) Cut Peer ( id types . ID ) { t . mu . RLock ( ) p , pok : = t . peers [ id ] g , gok : = t . remotes [ id ] t . mu . RUnlock ( ) if pok { p . ( Pausable ) . Pause ( ) } if gok { g . Pause ( ) } } 
func ( t * Transport ) Mend Peer ( id types . ID ) { t . mu . RLock ( ) p , pok : = t . peers [ id ] g , gok : = t . remotes [ id ] t . mu . RUnlock ( ) if pok { p . ( Pausable ) . Resume ( ) } if gok { g . Resume ( ) } } 
func ( t * Transport ) remove Peer ( id types . ID ) { if peer , ok : = t . peers [ id ] ; ok { peer . stop ( ) } else { if t . Logger ! = nil { t . Logger . Panic ( " " , zap . String ( " " , id . String ( ) ) ) } else { plog . Panicf ( " " , id ) } } delete ( t . peers , id ) delete ( t . Leader Stats . Followers , id . String ( ) ) t . pipeline Prober . Remove ( id . String ( ) ) t . stream Prober . Remove ( id . String ( ) ) if t . Logger ! = nil { t . Logger . Info ( " " , zap . String ( " " , t . ID . String ( ) ) , zap . String ( " " , id . String ( ) ) , ) } else { plog . Infof ( " " , id ) } } 
func ( t * Transport ) Active Peers ( ) ( cnt int ) { t . mu . RLock ( ) defer t . mu . RUnlock ( ) for _ , p : = range t . peers { if ! p . active Since ( ) . Is Zero ( ) { cnt + + } } return cnt } 
func resolve TCPAddr Default ( ctx context . Context , addr string ) ( * net . TCPAddr , error ) { host , port , serr : = net . Split Host Port ( addr ) if serr ! = nil { return nil , serr } portnum , perr : = net . Default Resolver . Lookup Port ( ctx , " " , port ) if perr ! = nil { return nil , perr } var ips [ ] net . IPAddr if ip : = net . Parse IP ( host ) ; ip ! = nil { ips = [ ] net . IPAddr { { IP : ip } } } else { if err ! = nil { return nil , err } ips = ipss } return & net . TCPAddr { IP : ip . IP , Port : portnum , Zone : ip . Zone } , nil } 
func resolve TCPAddrs ( ctx context . Context , lg * zap . Logger , urls [ ] [ ] url . URL ) ( [ ] [ ] url . URL , error ) { newurls : = make ( [ ] [ ] url . URL , 0 ) for _ , us : = range urls { nus : = make ( [ ] url . URL , len ( us ) ) for i , u : = range us { nu , err : = url . Parse ( u . String ( ) ) if err ! = nil { return nil , fmt . Errorf ( " " , u . String ( ) , err ) } nus [ i ] = * nu } for i , u : = range nus { h , err : = resolve URL ( ctx , lg , u ) if err ! = nil { return nil , fmt . Errorf ( " " , u . String ( ) , err ) } if h ! = " " { nus [ i ] . Host = h } } newurls = append ( newurls , nus ) } return newurls , nil } 
func urls Equal ( ctx context . Context , lg * zap . Logger , a [ ] url . URL , b [ ] url . URL ) ( bool , error ) { if len ( a ) ! = len ( b ) { return false , fmt . Errorf ( " " , urls To Strings ( a ) , urls To Strings ( b ) ) } urls , err : = resolve TCPAddrs ( ctx , lg , [ ] [ ] url . URL { a , b } ) if err ! = nil { return false , err } preva , prevb : = a , b a , b = urls [ 0 ] , urls [ 1 ] sort . Sort ( types . URLs ( a ) ) sort . Sort ( types . URLs ( b ) ) for i : = range a { if ! reflect . Deep Equal ( a [ i ] , b [ i ] ) { return false , fmt . Errorf ( " " , a [ i ] . String ( ) , preva [ i ] . String ( ) , b [ i ] . String ( ) , prevb [ i ] . String ( ) , ) } } return true , nil } 
func URLStrings Equal ( ctx context . Context , lg * zap . Logger , a [ ] string , b [ ] string ) ( bool , error ) { if len ( a ) ! = len ( b ) { return false , fmt . Errorf ( " " , a , b ) } urls A : = make ( [ ] url . URL , 0 ) for _ , str : = range a { u , err : = url . Parse ( str ) if err ! = nil { return false , fmt . Errorf ( " " , str ) } urls A = append ( urls A , * u ) } urls B : = make ( [ ] url . URL , 0 ) for _ , str : = range b { u , err : = url . Parse ( str ) if err ! = nil { return false , fmt . Errorf ( " " , str ) } urls B = append ( urls B , * u ) } if lg = = nil { lg , _ = zap . New Production ( ) if lg = = nil { lg = zap . New Example ( ) } } return urls Equal ( ctx , lg , urls A , urls B ) } 
func New Lease Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , } lc . Add Command ( New Lease Grant Command ( ) ) lc . Add Command ( New Lease Revoke Command ( ) ) lc . Add Command ( New Lease Time To Live Command ( ) ) lc . Add Command ( New Lease List Command ( ) ) lc . Add Command ( New Lease Keep Alive Command ( ) ) return lc } 
func New Lease Grant Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , Run : lease Grant Command Func , } return lc } 
func lease Grant Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } ttl , err : = strconv . Parse Int ( args [ 0 ] , 1 0 , 6 4 ) if err ! = nil { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " , err ) ) } ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Grant ( ctx , ttl ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , fmt . Errorf ( " " , err ) ) } display . Grant ( * resp ) } 
func New Lease Revoke Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , Run : lease Revoke Command Func , } return lc } 
func lease Revoke Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } id : = lease From Args ( args [ 0 ] ) ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Revoke ( ctx , id ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , fmt . Errorf ( " " , err ) ) } display . Revoke ( id , * resp ) } 
func New Lease Time To Live Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , Run : lease Time To Live Command Func , } lc . Flags ( ) . Bool Var ( & time To Live Keys , " " , false , " " ) return lc } 
func lease Time To Live Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } var opts [ ] v 3 . Lease Option if time To Live Keys { opts = append ( opts , v 3 . With Attached Keys ( ) ) } resp , rerr : = must Client From Cmd ( cmd ) . Time To Live ( context . TODO ( ) , lease From Args ( args [ 0 ] ) , opts . . . ) if rerr ! = nil { Exit With Error ( Exit Bad Connection , rerr ) } display . Time To Live ( * resp , time To Live Keys ) } 
func New Lease List Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , Run : lease List Command Func , } return lc } 
func lease List Command Func ( cmd * cobra . Command , args [ ] string ) { resp , rerr : = must Client From Cmd ( cmd ) . Leases ( context . TODO ( ) ) if rerr ! = nil { Exit With Error ( Exit Bad Connection , rerr ) } display . Leases ( * resp ) } 
func New Lease Keep Alive Command ( ) * cobra . Command { lc : = & cobra . Command { Use : " " , Short : " " , Run : lease Keep Alive Command Func , } lc . Flags ( ) . Bool Var ( & lease Keep Alive Once , " " , false , " " ) return lc } 
func lease Keep Alive Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } id : = lease From Args ( args [ 0 ] ) if lease Keep Alive Once { respc , kerr : = must Client From Cmd ( cmd ) . Keep Alive Once ( context . TODO ( ) , id ) if kerr ! = nil { Exit With Error ( Exit Bad Connection , kerr ) } display . Keep Alive ( * respc ) return } respc , kerr : = must Client From Cmd ( cmd ) . Keep Alive ( context . TODO ( ) , id ) if kerr ! = nil { Exit With Error ( Exit Bad Connection , kerr ) } for resp : = range respc { display . Keep Alive ( * resp ) } if _ , ok : = ( display ) . ( * simple Printer ) ; ok { fmt . Printf ( " \n " , id ) } } 
func ( s * Etcd Server ) Check Initial Hash KV ( ) error { if ! s . Cfg . Initial Corrupt Check { return nil } lg : = s . get Logger ( ) if lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . Duration ( " " , s . Cfg . Req Timeout ( ) ) , ) } else { plog . Infof ( " " , s . ID ( ) , s . Cfg . Req Timeout ( ) ) } h , rev , crev , err : = s . kv . Hash By Rev ( 0 ) if err ! = nil { return fmt . Errorf ( " " , s . ID ( ) , err ) } peers : = s . get Peer Hash KVs ( rev ) mismatch : = 0 for _ , p : = range peers { if p . resp ! = nil { peer ID : = types . ID ( p . resp . Header . Member Id ) fields : = [ ] zap . Field { zap . String ( " " , s . ID ( ) . String ( ) ) , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , crev ) , zap . Uint 3 2 ( " " , h ) , zap . String ( " " , peer ID . String ( ) ) , zap . Strings ( " " , p . eps ) , zap . Int 6 4 ( " " , p . resp . Header . Revision ) , zap . Int 6 4 ( " " , p . resp . Compact Revision ) , zap . Uint 3 2 ( " " , p . resp . Hash ) , } if h ! = p . resp . Hash { if crev = = p . resp . Compact Revision { if lg ! = nil { lg . Warn ( " " , fields . . . ) } else { plog . Errorf ( " " , s . ID ( ) , h , peer ID , p . resp . Hash , rev , p . resp . Header . Revision , crev ) } mismatch + + } else { if lg ! = nil { lg . Warn ( " " , fields . . . ) } else { plog . Warningf ( " " , s . ID ( ) , peer ID , p . resp . Compact Revision , rev ) } } } continue } if p . err ! = nil { switch p . err { case rpctypes . Err Future Rev : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , crev ) , zap . Uint 3 2 ( " " , h ) , zap . String ( " " , p . id . String ( ) ) , zap . Strings ( " " , p . eps ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , s . ID ( ) , p . eps , rev , p . err . Error ( ) ) } case rpctypes . Err Compacted : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , crev ) , zap . Uint 3 2 ( " " , h ) , zap . String ( " " , p . id . String ( ) ) , zap . Strings ( " " , p . eps ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , s . ID ( ) , p . eps , rev , p . err . Error ( ) ) } } } } if mismatch > 0 { return fmt . Errorf ( " " , s . ID ( ) ) } if lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , ) } else { plog . Infof ( " " , s . ID ( ) ) } return nil } 
func New Alarm Command ( ) * cobra . Command { ac : = & cobra . Command { Use : " " , Short : " " , } ac . Add Command ( New Alarm Disarm Command ( ) ) ac . Add Command ( New Alarm List Command ( ) ) return ac } 
func alarm Disarm Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Alarm Disarm ( ctx , & v 3 . Alarm Member { } ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Alarm ( * resp ) } 
func alarm List Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Alarm List ( ctx ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Alarm ( * resp ) } 
func ( e * Etcd ) Flags ( ) ( fs [ ] string ) { tp : = reflect . Type Of ( * e ) vo : = reflect . Value Of ( * e ) for _ , name : = range etcd Fields { field , ok : = tp . Field By Name ( name ) if ! ok { panic ( fmt . Errorf ( " " , name ) ) } fv : = reflect . Indirect ( vo ) . Field By Name ( name ) var sv string switch fv . Type ( ) . Kind ( ) { case reflect . String : sv = fv . String ( ) case reflect . Slice : n : = fv . Len ( ) sl : = make ( [ ] string , n ) for i : = 0 ; i < n ; i + + { sl [ i ] = fv . Index ( i ) . String ( ) } sv = strings . Join ( sl , " " ) case reflect . Int 6 4 : sv = fmt . Sprintf ( " " , fv . Int ( ) ) case reflect . Bool : sv = fmt . Sprintf ( " " , fv . Bool ( ) ) default : panic ( fmt . Errorf ( " " , name , fv . Type ( ) . Kind ( ) ) ) } fname : = field . Tag . Get ( " " ) } if sv ! = " " { fs = append ( fs , fmt . Sprintf ( " " , fname , sv ) ) } } return fs } 
func ( e * Etcd ) Embed Config ( ) ( cfg * embed . Config , err error ) { var lc URLs types . URLs lc URLs , err = types . New URLs ( e . Listen Client URLs ) if err ! = nil { return nil , err } var ac URLs types . URLs ac URLs , err = types . New URLs ( e . Advertise Client URLs ) if err ! = nil { return nil , err } var lp URLs types . URLs lp URLs , err = types . New URLs ( e . Listen Peer URLs ) if err ! = nil { return nil , err } var ap URLs types . URLs ap URLs , err = types . New URLs ( e . Advertise Peer URLs ) if err ! = nil { return nil , err } cfg = embed . New Config ( ) cfg . Name = e . Name cfg . Dir = e . Data Dir cfg . Wal Dir = e . WALDir cfg . Tick Ms = uint ( e . Heartbeat Interval Ms ) cfg . Election Ms = uint ( e . Election Timeout Ms ) cfg . LCUrls = lc URLs cfg . ACUrls = ac URLs cfg . Client Auto TLS = e . Client Auto TLS cfg . Client TLSInfo = transport . TLSInfo { Client Cert Auth : e . Client Cert Auth , Cert File : e . Client Cert File , Key File : e . Client Key File , Trusted CAFile : e . Client Trusted CAFile , } cfg . LPUrls = lp URLs cfg . APUrls = ap URLs cfg . Peer Auto TLS = e . Peer Auto TLS cfg . Peer TLSInfo = transport . TLSInfo { Client Cert Auth : e . Peer Client Cert Auth , Cert File : e . Peer Cert File , Key File : e . Peer Key File , Trusted CAFile : e . Peer Trusted CAFile , } cfg . Initial Cluster = e . Initial Cluster cfg . Cluster State = e . Initial Cluster State cfg . Initial Cluster Token = e . Initial Cluster Token cfg . Snapshot Count = uint 6 4 ( e . Snapshot Count ) cfg . Quota Backend Bytes = e . Quota Backend Bytes cfg . Pre Vote = e . Pre Vote cfg . Experimental Initial Corrupt Check = e . Initial Corrupt Check cfg . Logger = e . Logger cfg . Log Outputs = e . Log Outputs cfg . Debug = e . Debug return cfg , nil } 
func PProf Handlers ( ) map [ string ] http . Handler { } m : = make ( map [ string ] http . Handler ) m [ HTTPPrefix PProf + " " ] = http . Handler Func ( pprof . Index ) m [ HTTPPrefix PProf + " " ] = http . Handler Func ( pprof . Profile ) m [ HTTPPrefix PProf + " " ] = http . Handler Func ( pprof . Symbol ) m [ HTTPPrefix PProf + " " ] = http . Handler Func ( pprof . Cmdline ) m [ HTTPPrefix PProf + " " ] = http . Handler Func ( pprof . Trace ) m [ HTTPPrefix PProf + " " ] = pprof . Handler ( " " ) m [ HTTPPrefix PProf + " " ] = pprof . Handler ( " " ) m [ HTTPPrefix PProf + " " ] = pprof . Handler ( " " ) m [ HTTPPrefix PProf + " " ] = pprof . Handler ( " " ) m [ HTTPPrefix PProf + " " ] = pprof . Handler ( " " ) return m } 
func New Backend Quota ( s * Etcd Server , name string ) Quota { lg : = s . get Logger ( ) quota Backend Bytes . Set ( float 6 4 ( s . Cfg . Quota Backend Bytes ) ) if s . Cfg . Quota Backend Bytes < 0 { } else { plog . Warningf ( " " ) } } ) return & passthrough Quota { } } if s . Cfg . Quota Backend Bytes = = 0 { } } ) quota Backend Bytes . Set ( float 6 4 ( Default Quota Bytes ) ) return & backend Quota { s , Default Quota Bytes } } quota Log Once . Do ( func ( ) { if s . Cfg . Quota Backend Bytes > Max Quota Bytes { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , name ) , zap . Int 6 4 ( " " , s . Cfg . Quota Backend Bytes ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( s . Cfg . Quota Backend Bytes ) ) ) , zap . Int 6 4 ( " " , Max Quota Bytes ) , zap . String ( " " , max Quota Size ) , ) } else { plog . Warningf ( " " , s . Cfg . Quota Backend Bytes , Max Quota Bytes ) } } if lg ! = nil { lg . Info ( " " , zap . String ( " " , name ) , zap . Int 6 4 ( " " , s . Cfg . Quota Backend Bytes ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( s . Cfg . Quota Backend Bytes ) ) ) , ) } } ) return & backend Quota { s , s . Cfg . Quota Backend Bytes } } 
func New Cluster Proxy ( c * clientv 3 . Client , advaddr string , prefix string ) ( pb . Cluster Server , < - chan struct { } ) { cp : = & cluster Proxy { clus : c . Cluster , ctx : c . Ctx ( ) , gr : & naming . GRPCResolver { Client : c } , advaddr : advaddr , prefix : prefix , umap : make ( map [ string ] gnaming . Update ) , } donec : = make ( chan struct { } ) if advaddr ! = " " & & prefix ! = " " { go func ( ) { defer close ( donec ) cp . resolve ( prefix ) } ( ) return cp , donec } close ( donec ) return cp , donec } 
func ( cp * cluster Proxy ) Member List ( ctx context . Context , r * pb . Member List Request ) ( * pb . Member List Response , error ) { if cp . advaddr ! = " " { if cp . prefix ! = " " { mbs , err : = cp . members From Updates ( ) if err ! = nil { return nil , err } if len ( mbs ) > 0 { return & pb . Member List Response { Members : mbs } , nil } } return & pb . Member List Response { Members : [ ] * pb . Member { { Name : hostname , Client URLs : [ ] string { cp . advaddr } } } } , nil } mresp , err : = cp . clus . Member List ( ctx ) if err ! = nil { return nil , err } resp : = ( pb . Member List Response ) ( * mresp ) return & resp , err } 
func New Handler ( l lease . Lessor , waitch func ( ) < - chan struct { } ) http . Handler { return & lease Handler { l , waitch } } 
func Renew HTTP ( ctx context . Context , id lease . Lease ID , url string , rt http . Round Tripper ) ( int 6 4 , error ) { if err ! = nil { return - 1 , err } cc : = & http . Client { Transport : rt } req , err : = http . New Request ( " " , url , bytes . New Reader ( lreq ) ) if err ! = nil { return - 1 , err } req . Header . Set ( " " , " " ) req . Cancel = ctx . Done ( ) resp , err : = cc . Do ( req ) if err ! = nil { return - 1 , err } b , err : = read Response ( resp ) if err ! = nil { return - 1 , err } if resp . Status Code = = http . Status Request Timeout { return - 1 , Err Lease HTTPTimeout } if resp . Status Code = = http . Status Not Found { return - 1 , lease . Err Lease Not Found } if resp . Status Code ! = http . Status OK { return - 1 , fmt . Errorf ( " " , string ( b ) ) } lresp : = & pb . Lease Keep Alive Response { } if err : = lresp . Unmarshal ( b ) ; err ! = nil { return - 1 , fmt . Errorf ( `lease : %v . data = " %s " ` , err , string ( b ) ) } if lresp . ID ! = int 6 4 ( id ) { return - 1 , fmt . Errorf ( " " ) } return lresp . TTL , nil } 
func Time To Live HTTP ( ctx context . Context , id lease . Lease ID , keys bool , url string , rt http . Round Tripper ) ( * leasepb . Lease Internal Response , error ) { if err ! = nil { return nil , err } req , err : = http . New Request ( " " , url , bytes . New Reader ( lreq ) ) if err ! = nil { return nil , err } req . Header . Set ( " " , " " ) req = req . With Context ( ctx ) cc : = & http . Client { Transport : rt } var b [ ] byte if err ! = nil { return nil , err } b , err = read Response ( resp ) if err ! = nil { return nil , err } if resp . Status Code = = http . Status Request Timeout { return nil , Err Lease HTTPTimeout } if resp . Status Code = = http . Status Not Found { return nil , lease . Err Lease Not Found } if resp . Status Code ! = http . Status OK { return nil , fmt . Errorf ( " " , string ( b ) ) } lresp : = & leasepb . Lease Internal Response { } if err : = lresp . Unmarshal ( b ) ; err ! = nil { return nil , fmt . Errorf ( `lease : %v . data = " %s " ` , err , string ( b ) ) } if lresp . Lease Time To Live Response . ID ! = int 6 4 ( id ) { return nil , fmt . Errorf ( " " ) } return lresp , nil } 
func new Watcher Batch ( wg * watcher Group , evs [ ] mvccpb . Event ) watcher Batch { if len ( wg . watchers ) = = 0 { return nil } wb : = make ( watcher Batch ) for _ , ev : = range evs { for w : = range wg . watcher Set By Key ( string ( ev . Kv . Key ) ) { if ev . Kv . Mod Revision > = w . min Rev { } } } return wb } 
func ( wg * watcher Group ) add ( wa * watcher ) { wg . watchers . add ( wa ) if wa . end = = nil { wg . key Watchers . add ( wa ) return } if iv : = wg . ranges . Find ( ivl ) ; iv ! = nil { iv . Val . ( watcher Set ) . add ( wa ) return } ws . add ( wa ) wg . ranges . Insert ( ivl , ws ) } 
func ( wg * watcher Group ) contains ( key string ) bool { _ , ok : = wg . key Watchers [ key ] return ok | | wg . ranges . Intersects ( adt . New String Affine Point ( key ) ) } 
func ( wg * watcher Group ) delete ( wa * watcher ) bool { if _ , ok : = wg . watchers [ wa ] ; ! ok { return false } wg . watchers . delete ( wa ) if wa . end = = nil { wg . key Watchers . delete ( wa ) return true } ivl : = adt . New String Affine Interval ( string ( wa . key ) , string ( wa . end ) ) iv : = wg . ranges . Find ( ivl ) if iv = = nil { return false } ws : = iv . Val . ( watcher Set ) delete ( ws , wa ) if len ( ws ) = = 0 { } } return true } 
func ( wg * watcher Group ) choose ( max Watchers int , cur Rev , compact Rev int 6 4 ) ( * watcher Group , int 6 4 ) { if len ( wg . watchers ) < max Watchers { return wg , wg . choose All ( cur Rev , compact Rev ) } ret : = new Watcher Group ( ) for w : = range wg . watchers { if max Watchers < = 0 { break } max Watchers - - ret . add ( w ) } return & ret , ret . choose All ( cur Rev , compact Rev ) } 
func ( wg * watcher Group ) watcher Set By Key ( key string ) watcher Set { wkeys : = wg . key Watchers [ key ] wranges : = wg . ranges . Stab ( adt . New String Affine Point ( key ) ) case len ( wranges ) = = 0 & & len ( wkeys ) = = 0 : return nil case len ( wranges ) = = 1 & & len ( wkeys ) = = 0 : return wranges [ 0 ] . Val . ( watcher Set ) } ret . union ( wg . key Watchers [ key ] ) for _ , item : = range wranges { ret . union ( item . Val . ( watcher Set ) ) } return ret } 
func ( ivl * Interval ) Compare ( c Comparable ) int { ivl 2 : = c . ( * Interval ) ivb Cmp Begin : = ivl . Begin . Compare ( ivl 2 . Begin ) ivb Cmp End : = ivl . Begin . Compare ( ivl 2 . End ) ive Cmp Begin : = ivl . End . Compare ( ivl 2 . Begin ) } } return 0 } 
func ( x * interval Node ) successor ( ) * interval Node { if x . right ! = nil { return x . right . min ( ) } y : = x . parent for y ! = nil & & x = = y . right { x = y y = y . parent } return y } 
func ( x * interval Node ) update Max ( ) { for x ! = nil { oldmax : = x . max max : = x . iv . Ivl . End if x . left ! = nil & & x . left . max . Compare ( max ) > 0 { max = x . left . max } if x . right ! = nil & & x . right . max . Compare ( max ) > 0 { max = x . right . max } if oldmax . Compare ( max ) = = 0 { break } x . max = max x = x . parent } } 
func ( x * interval Node ) visit ( iv * Interval , nv node Visitor ) bool { if x = = nil { return true } v : = iv . Compare ( & x . iv . Ivl ) switch { case v < 0 : if ! x . left . visit ( iv , nv ) { return false } case v > 0 : maxiv : = Interval { x . iv . Ivl . Begin , x . max } if maxiv . Compare ( iv ) = = 0 { if ! x . left . visit ( iv , nv ) | | ! x . right . visit ( iv , nv ) { return false } } default : if ! x . left . visit ( iv , nv ) | | ! nv ( x ) | | ! x . right . visit ( iv , nv ) { return false } } return true } 
func ( ivt * Interval Tree ) Delete ( ivl Interval ) bool { z : = ivt . find ( ivl ) if z = = nil { return false } y : = z if z . left ! = nil & & z . right ! = nil { y = z . successor ( ) } x : = y . left if x = = nil { x = y . right } if x ! = nil { x . parent = y . parent } if y . parent = = nil { ivt . root = x } else { if y = = y . parent . left { y . parent . left = x } else { y . parent . right = x } y . parent . update Max ( ) } if y ! = z { z . iv = y . iv z . update Max ( ) } if y . color ( ) = = black & & x ! = nil { ivt . delete Fixup ( x ) } ivt . count - - return true } 
func ( ivt * Interval Tree ) Insert ( ivl Interval , val interface { } ) { var y * interval Node z : = & interval Node { iv : Interval Value { ivl , val } , max : ivl . End , c : red } x : = ivt . root for x ! = nil { y = x if z . iv . Ivl . Begin . Compare ( x . iv . Ivl . Begin ) < 0 { x = x . left } else { x = x . right } } z . parent = y if y = = nil { ivt . root = z } else { if z . iv . Ivl . Begin . Compare ( y . iv . Ivl . Begin ) < 0 { y . left = z } else { y . right = z } y . update Max ( ) } z . c = red ivt . insert Fixup ( z ) ivt . count + + } 
func ( ivt * Interval Tree ) rotate Left ( x * interval Node ) { y : = x . right x . right = y . left if y . left ! = nil { y . left . parent = x } x . update Max ( ) ivt . replace Parent ( x , y ) y . left = x y . update Max ( ) } 
func ( ivt * Interval Tree ) replace Parent ( x * interval Node , y * interval Node ) { y . parent = x . parent if x . parent = = nil { ivt . root = y } else { if x = = x . parent . left { x . parent . left = y } else { x . parent . right = y } x . parent . update Max ( ) } x . parent = y } 
func ( ivt * Interval Tree ) Max Height ( ) int { return int ( ( 2 * math . Log 2 ( float 6 4 ( ivt . Len ( ) + 1 ) ) ) + 0 . 5 ) } 
func ( ivt * Interval Tree ) Visit ( ivl Interval , ivv Interval Visitor ) { ivt . root . visit ( & ivl , func ( n * interval Node ) bool { return ivv ( & n . iv ) } ) } 
func ( ivt * Interval Tree ) find ( ivl Interval ) ( ret * interval Node ) { f : = func ( n * interval Node ) bool { if n . iv . Ivl ! = ivl { return true } ret = n return false } ivt . root . visit ( & ivl , f ) return ret } 
func ( ivt * Interval Tree ) Find ( ivl Interval ) ( ret * Interval Value ) { n : = ivt . find ( ivl ) if n = = nil { return nil } return & n . iv } 
func ( ivt * Interval Tree ) Intersects ( iv Interval ) bool { x : = ivt . root for x ! = nil & & iv . Compare ( & x . iv . Ivl ) ! = 0 { if x . left ! = nil & & x . left . max . Compare ( iv . Begin ) > 0 { x = x . left } else { x = x . right } } return x ! = nil } 
func ( ivt * Interval Tree ) Contains ( ivl Interval ) bool { var max End , min Begin Comparable is Contiguous : = true ivt . Visit ( ivl , func ( n * Interval Value ) bool { if min Begin = = nil { min Begin = n . Ivl . Begin max End = n . Ivl . End return true } if max End . Compare ( n . Ivl . Begin ) < 0 { is Contiguous = false return false } if n . Ivl . End . Compare ( max End ) > 0 { max End = n . Ivl . End } return true } ) return is Contiguous & & min Begin ! = nil & & max End . Compare ( ivl . End ) > = 0 & & min Begin . Compare ( ivl . Begin ) < = 0 } 
func ( ivt * Interval Tree ) Stab ( iv Interval ) ( ivs [ ] * Interval Value ) { if ivt . count = = 0 { return nil } f : = func ( n * Interval Value ) bool { ivs = append ( ivs , n ) ; return true } ivt . Visit ( iv , f ) return ivs } 
func ( ivt * Interval Tree ) Union ( in Ivt Interval Tree , ivl Interval ) { f : = func ( n * Interval Value ) bool { ivt . Insert ( n . Ivl , n . Val ) return true } in Ivt . Visit ( ivl , f ) } 
func New Exact Read Closer ( rc io . Read Closer , total Bytes int 6 4 ) io . Read Closer { return & exact Read Closer { rc : rc , total Bytes : total Bytes } } 
func New Election ( s * Session , pfx string ) * Election { return & Election { session : s , key Prefix : pfx + " " } } 
func Resume Election ( s * Session , pfx string , leader Key string , leader Rev int 6 4 ) * Election { return & Election { key Prefix : pfx , session : s , leader Key : leader Key , leader Rev : leader Rev , leader Session : s , } } 
func ( e * Election ) Campaign ( ctx context . Context , val string ) error { s : = e . session client : = e . session . Client ( ) k : = fmt . Sprintf ( " " , e . key Prefix , s . Lease ( ) ) txn : = client . Txn ( ctx ) . If ( v 3 . Compare ( v 3 . Create Revision ( k ) , " " , 0 ) ) txn = txn . Then ( v 3 . Op Put ( k , val , v 3 . With Lease ( s . Lease ( ) ) ) ) txn = txn . Else ( v 3 . Op Get ( k ) ) resp , err : = txn . Commit ( ) if err ! = nil { return err } e . leader Key , e . leader Rev , e . leader Session = k , resp . Header . Revision , s if ! resp . Succeeded { kv : = resp . Responses [ 0 ] . Get Response Range ( ) . Kvs [ 0 ] e . leader Rev = kv . Create Revision if string ( kv . Value ) ! = val { if err = e . Proclaim ( ctx , val ) ; err ! = nil { e . Resign ( ctx ) return err } } } _ , err = wait Deletes ( ctx , client , e . key Prefix , e . leader Rev - 1 ) if err ! = nil { default : e . leader Session = nil } return err } e . hdr = resp . Header return nil } 
func ( e * Election ) Proclaim ( ctx context . Context , val string ) error { if e . leader Session = = nil { return Err Election Not Leader } client : = e . session . Client ( ) cmp : = v 3 . Compare ( v 3 . Create Revision ( e . leader Key ) , " " , e . leader Rev ) txn : = client . Txn ( ctx ) . If ( cmp ) txn = txn . Then ( v 3 . Op Put ( e . leader Key , val , v 3 . With Lease ( e . leader Session . Lease ( ) ) ) ) tresp , terr : = txn . Commit ( ) if terr ! = nil { return terr } if ! tresp . Succeeded { e . leader Key = " " return Err Election Not Leader } e . hdr = tresp . Header return nil } 
func ( e * Election ) Resign ( ctx context . Context ) ( err error ) { if e . leader Session = = nil { return nil } client : = e . session . Client ( ) cmp : = v 3 . Compare ( v 3 . Create Revision ( e . leader Key ) , " " , e . leader Rev ) resp , err : = client . Txn ( ctx ) . If ( cmp ) . Then ( v 3 . Op Delete ( e . leader Key ) ) . Commit ( ) if err = = nil { e . hdr = resp . Header } e . leader Key = " " e . leader Session = nil return err } 
func ( e * Election ) Leader ( ctx context . Context ) ( * v 3 . Get Response , error ) { client : = e . session . Client ( ) resp , err : = client . Get ( ctx , e . key Prefix , v 3 . With First Create ( ) . . . ) if err ! = nil { return nil , err } else if len ( resp . Kvs ) = = 0 { } return resp , nil } 
func ( e * Election ) Observe ( ctx context . Context ) < - chan v 3 . Get Response { retc : = make ( chan v 3 . Get Response ) go e . observe ( ctx , retc ) return retc } 
func ( qa * quota Alarmer ) check ( ctx context . Context , r interface { } ) error { if qa . q . Available ( r ) { return nil } req : = & pb . Alarm Request { Member ID : uint 6 4 ( qa . id ) , Action : pb . Alarm Request _ACTIVATE , Alarm : pb . Alarm Type _NOSPACE , } qa . a . Alarm ( ctx , req ) return rpctypes . Err GRPCNo Space } 
func New Exec Watch Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , cli . Bool Flag { Name : " " , Usage : " " } , } , Action : func ( c * cli . Context ) error { exec Watch Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func exec Watch Command Func ( c * cli . Context , ki client . Keys API ) { args : = c . Args ( ) argslen : = len ( args ) if argslen < 2 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } var ( key string cmd Args [ ] string ) found Sep : = false for i : = range args { if args [ i ] = = " " & & i ! = 0 { found Sep = true break } } if found Sep { key = args [ 0 ] cmd Args = args [ 2 : ] } else { cmd Args = args [ : argslen - 1 ] } index : = 0 if c . Int ( " " ) ! = 0 { index = c . Int ( " " ) } recursive : = c . Bool ( " " ) sigch : = make ( chan os . Signal , 1 ) signal . Notify ( sigch , os . Interrupt ) go func ( ) { < - sigch os . Exit ( 0 ) } ( ) w : = ki . Watcher ( key , & client . Watcher Options { After Index : uint 6 4 ( index ) , Recursive : recursive } ) for { resp , err : = w . Next ( context . TODO ( ) ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if resp . Node . Dir { fmt . Fprintf ( os . Stderr , " \n " , resp . Node . Key ) continue } cmd : = exec . Command ( cmd Args [ 0 ] , cmd Args [ 1 : ] . . . ) cmd . Env = environ Response ( resp , os . Environ ( ) ) cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr go func ( ) { err : = cmd . Start ( ) if err ! = nil { fmt . Fprintf ( os . Stderr , err . Error ( ) ) os . Exit ( 1 ) } cmd . Wait ( ) } ( ) } } 
func New Listener ( u url . URL , tlsinfo * transport . TLSInfo ) ( net . Listener , error ) { return transport . New Timeout Listener ( u . Host , u . Scheme , tlsinfo , Conn Read Timeout , Conn Write Timeout ) } 
func New Round Tripper ( tls Info transport . TLSInfo , dial Timeout time . Duration ) ( http . Round Tripper , error ) { } 
func new Stream Round Tripper ( tls Info transport . TLSInfo , dial Timeout time . Duration ) ( http . Round Tripper , error ) { return transport . New Timeout Transport ( tls Info , dial Timeout , Conn Read Timeout , Conn Write Timeout ) } 
func create Post Request ( u url . URL , path string , body io . Reader , ct string , urls types . URLs , from , cid types . ID ) * http . Request { uu : = u uu . Path = path req , err : = http . New Request ( " " , uu . String ( ) , body ) if err ! = nil { plog . Panicf ( " " , err ) } req . Header . Set ( " " , ct ) req . Header . Set ( " " , from . String ( ) ) req . Header . Set ( " " , version . Version ) req . Header . Set ( " " , version . Min Cluster Version ) req . Header . Set ( " " , cid . String ( ) ) set Peer URLs Header ( req , urls ) return req } 
func check Post Response ( resp * http . Response , body [ ] byte , req * http . Request , to types . ID ) error { switch resp . Status Code { case http . Status Precondition Failed : switch strings . Trim Suffix ( string ( body ) , " \n " ) { case err Incompatible Version . Error ( ) : plog . Errorf ( " " , to ) return err Incompatible Version case err Cluster IDMismatch . Error ( ) : plog . Errorf ( " " , to , resp . Header . Get ( " " ) , req . Header . Get ( " " ) ) return err Cluster IDMismatch default : return fmt . Errorf ( " " , string ( body ) ) } case http . Status Forbidden : return err Member Removed case http . Status No Content : return nil default : return fmt . Errorf ( " " , http . Status Text ( resp . Status Code ) , req . URL . String ( ) ) } } 
func compare Major Minor Version ( a , b * semver . Version ) int { na : = & semver . Version { Major : a . Major , Minor : a . Minor } nb : = & semver . Version { Major : b . Major , Minor : b . Minor } switch { case na . Less Than ( * nb ) : return - 1 case nb . Less Than ( * na ) : return 1 default : return 0 } } 
func server Version ( h http . Header ) * semver . Version { ver Str : = h . Get ( " " ) } return semver . Must ( semver . New Version ( ver Str ) ) } 
func check Version Compatibility ( name string , server , min Cluster * semver . Version ) ( local Server * semver . Version , local Min Cluster * semver . Version , err error ) { local Server = semver . Must ( semver . New Version ( version . Version ) ) local Min Cluster = semver . Must ( semver . New Version ( version . Min Cluster Version ) ) if compare Major Minor Version ( server , local Min Cluster ) = = - 1 { return local Server , local Min Cluster , fmt . Errorf ( " " , name , server , local Server ) } if compare Major Minor Version ( min Cluster , local Server ) = = 1 { return local Server , local Min Cluster , fmt . Errorf ( " " , name , server , local Server ) } return local Server , local Min Cluster , nil } 
func set Peer URLs Header ( req * http . Request , urls types . URLs ) { if urls = = nil { } peer URLs : = make ( [ ] string , urls . Len ( ) ) for i : = range urls { peer URLs [ i ] = urls [ i ] . String ( ) } req . Header . Set ( " " , strings . Join ( peer URLs , " " ) ) } 
func add Remote From Request ( tr Transporter , r * http . Request ) { if from , err : = types . IDFrom String ( r . Header . Get ( " " ) ) ; err = = nil { if urls : = r . Header . Get ( " " ) ; urls ! = " " { tr . Add Remote ( from , strings . Split ( urls , " " ) ) } } } 
func New Keys APIWith Prefix ( c Client , p string ) Keys API { return & http Keys API { client : c , prefix : p , } } 
func ( n * Node ) TTLDuration ( ) time . Duration { return time . Duration ( n . TTL ) * time . Second } 
func v 2Keys URL ( ep url . URL , prefix , key string ) * url . URL { } if key ! = " " & & key [ 0 ] ! = ' / ' { key = " " + key } ep . Path = pathutil . Canonical URLPath ( ep . Path + prefix + key ) return & ep } 
func Set Flags From Env ( prefix string , fs * flag . Flag Set ) error { var err error already Set : = make ( map [ string ] bool ) fs . Visit ( func ( f * flag . Flag ) { already Set [ Flag To Env ( prefix , f . Name ) ] = true } ) used Env Key : = make ( map [ string ] bool ) fs . Visit All ( func ( f * flag . Flag ) { if serr : = set Flag From Env ( fs , prefix , f . Name , used Env Key , already Set , true ) ; serr ! = nil { err = serr } } ) verify Env ( prefix , used Env Key , already Set ) return err } 
func Set Pflags From Env ( prefix string , fs * pflag . Flag Set ) error { var err error already Set : = make ( map [ string ] bool ) used Env Key : = make ( map [ string ] bool ) fs . Visit All ( func ( f * pflag . Flag ) { if f . Changed { already Set [ Flag To Env ( prefix , f . Name ) ] = true } if serr : = set Flag From Env ( fs , prefix , f . Name , used Env Key , already Set , false ) ; serr ! = nil { err = serr } } ) verify Env ( prefix , used Env Key , already Set ) return err } 
func Flag To Env ( prefix , name string ) string { return prefix + " " + strings . To Upper ( strings . Replace ( name , " " , " " , - 1 ) ) } 
func excerpt ( str string , pre , suf int ) string { if pre + suf > len ( str ) { return fmt . Sprintf ( " " , str ) } return fmt . Sprintf ( " " , str [ : pre ] , str [ len ( str ) - suf : ] ) } 
func pass Conf Change ( entry raftpb . Entry ) ( bool , string ) { return entry . Type = = raftpb . Entry Conf Change , " " } 
func print Internal Raft Request ( entry raftpb . Entry ) { var rr etcdserverpb . Internal Raft Request if err : = rr . Unmarshal ( entry . Data ) ; err = = nil { fmt . Printf ( " \t \t \t " , entry . Term , entry . Index , rr . String ( ) ) } } 
func evaluate Entrytype Flag ( entrytype string ) [ ] Entry Filter { var entrytypelist [ ] string if entrytype ! = " " { entrytypelist = strings . Split ( entrytype , " " ) } valid Request : = map [ string ] [ ] Entry Filter { " " : { pass Conf Change } , " " : { pass Internal Raft Request , pass Request , pass Unknown Normal } , " " : { pass Request } , " " : { pass Internal Raft Request } , " " : { pass IRRRange } , " " : { pass IRRPut } , " " : { pass IRRDelete Range } , " " : { pass IRRTxn } , " " : { pass IRRCompaction } , " " : { pass IRRLease Grant } , " " : { pass IRRLease Revoke } , " " : { pass IRRLease Checkpoint } , } filters : = make ( [ ] Entry Filter , 0 ) if len ( entrytypelist ) = = 0 { filters = append ( filters , pass Internal Raft Request ) filters = append ( filters , pass Request ) filters = append ( filters , pass Unknown Normal ) filters = append ( filters , pass Conf Change ) } for _ , et : = range entrytypelist { if f , ok : = valid Request [ et ] ; ok { filters = append ( filters , f . . . ) } else { log . Printf ( ` [ % +v ] is not a valid entry -type , ignored . Please set entry -type to one or more of the following : Config Change , Normal , Request , Internal Raft Request , IRRRange , IRRPut , IRRDelete Range , IRRTxn , IRRCompaction , IRRLease Grant , IRRLease Revoke , IRRLease Checkpoint ` , et ) } } return filters } 
func list Entries Type ( entrytype string , streamdecoder string , ents [ ] raftpb . Entry ) { entry Filters : = evaluate Entrytype Flag ( entrytype ) printer Map : = map [ string ] Entry Printer { " " : print Internal Raft Request , " " : print Request , " " : print Conf Change , " " : print Unknown Normal } var stderr bytes . Buffer args : = strings . Split ( streamdecoder , " " ) cmd : = exec . Command ( args [ 0 ] , args [ 1 : ] . . . ) stdin , err : = cmd . Stdin Pipe ( ) if err ! = nil { log . Panic ( err ) } stdout , err : = cmd . Stdout Pipe ( ) if err ! = nil { log . Panic ( err ) } cmd . Stderr = & stderr if streamdecoder ! = " " { err = cmd . Start ( ) if err ! = nil { log . Panic ( err ) } } cnt : = 0 for _ , e : = range ents { passed : = false currtype : = " " for _ , filter : = range entry Filters { passed , currtype = filter ( e ) if passed { cnt + + break } } if passed { printer : = printer Map [ currtype ] printer ( e ) if streamdecoder = = " " { fmt . Println ( ) continue } io . Write String ( stdin , " \n " ) output Reader : = bufio . New Reader ( stdout ) decoderoutput , currerr : = output Reader . Read String ( ' \n ' ) if currerr ! = nil { fmt . Println ( currerr ) return } decoder _status , decoded _data : = parse Decoder Output ( decoderoutput ) fmt . Printf ( " \t \t " , decoder _status , decoded _data ) } } stdin . Close ( ) err = cmd . Wait ( ) if streamdecoder ! = " " { if err ! = nil { log . Panic ( err ) } if stderr . String ( ) ! = " " { os . Stderr . Write String ( " " + stderr . String ( ) ) } } fmt . Printf ( " \n " , entrytype , cnt ) } 
func new Log ( storage Storage , logger Logger ) * raft Log { return new Log With Size ( storage , logger , no Limit ) } 
func new Log With Size ( storage Storage , logger Logger , max Next Ents Size uint 6 4 ) * raft Log { if storage = = nil { log . Panic ( " " ) } log : = & raft Log { storage : storage , logger : logger , max Next Ents Size : max Next Ents Size , } first Index , err : = storage . First Index ( ) if err ! = nil { panic ( err ) } last Index , err : = storage . Last Index ( ) if err ! = nil { panic ( err ) } log . unstable . offset = last Index + 1 log . unstable . logger = logger log . applied = first Index - 1 return log } 
func ( l * raft Log ) maybe Append ( index , log Term , committed uint 6 4 , ents . . . pb . Entry ) ( lastnewi uint 6 4 , ok bool ) { if l . match Term ( index , log Term ) { lastnewi = index + uint 6 4 ( len ( ents ) ) ci : = l . find Conflict ( ents ) switch { case ci = = 0 : case ci < = l . committed : l . logger . Panicf ( " " , ci , l . committed ) default : offset : = index + 1 l . append ( ents [ ci - offset : ] . . . ) } l . commit To ( min ( committed , lastnewi ) ) return lastnewi , true } return 0 , false } 
func ( l * raft Log ) find Conflict ( ents [ ] pb . Entry ) uint 6 4 { for _ , ne : = range ents { if ! l . match Term ( ne . Index , ne . Term ) { if ne . Index < = l . last Index ( ) { l . logger . Infof ( " " , ne . Index , l . zero Term On Err Compacted ( l . term ( ne . Index ) ) , ne . Term ) } return ne . Index } } return 0 } 
func ( l * raft Log ) next Ents ( ) ( ents [ ] pb . Entry ) { off : = max ( l . applied + 1 , l . first Index ( ) ) if l . committed + 1 > off { ents , err : = l . slice ( off , l . committed + 1 , l . max Next Ents Size ) if err ! = nil { l . logger . Panicf ( " " , err ) } return ents } return nil } 
func ( l * raft Log ) has Next Ents ( ) bool { off : = max ( l . applied + 1 , l . first Index ( ) ) return l . committed + 1 > off } 
func ( l * raft Log ) all Entries ( ) [ ] pb . Entry { ents , err : = l . entries ( l . first Index ( ) , no Limit ) if err = = nil { return ents } if err = = Err Compacted { } } 
func ( l * raft Log ) is Up To Date ( lasti , term uint 6 4 ) bool { return term > l . last Term ( ) | | ( term = = l . last Term ( ) & & lasti > = l . last Index ( ) ) } 
func ( l * raft Log ) slice ( lo , hi , max Size uint 6 4 ) ( [ ] pb . Entry , error ) { err : = l . must Check Out Of Bounds ( lo , hi ) if err ! = nil { return nil , err } if lo = = hi { return nil , nil } var ents [ ] pb . Entry if lo < l . unstable . offset { stored Ents , err : = l . storage . Entries ( lo , min ( hi , l . unstable . offset ) , max Size ) if err = = Err Compacted { return nil , err } else if err = = Err Unavailable { l . logger . Panicf ( " " , lo , min ( hi , l . unstable . offset ) ) } else if err ! = nil { panic ( err ) } } ents = stored Ents } if hi > l . unstable . offset { unstable : = l . unstable . slice ( max ( lo , l . unstable . offset ) , hi ) if len ( ents ) > 0 { combined : = make ( [ ] pb . Entry , len ( ents ) + len ( unstable ) ) n : = copy ( combined , ents ) copy ( combined [ n : ] , unstable ) ents = combined } else { ents = unstable } } return limit Size ( ents , max Size ) , nil } 
func ( l * raft Log ) must Check Out Of Bounds ( lo , hi uint 6 4 ) error { if lo > hi { l . logger . Panicf ( " " , lo , hi ) } fi : = l . first Index ( ) if lo < fi { return Err Compacted } length : = l . last Index ( ) + 1 - fi if lo < fi | | hi > fi + length { l . logger . Panicf ( " " , lo , hi , fi , l . last Index ( ) ) } return nil } 
func New Session ( client * v 3 . Client , opts . . . Session Option ) ( * Session , error ) { ops : = & session Options { ttl : default Session TTL , ctx : client . Ctx ( ) } for _ , opt : = range opts { opt ( ops ) } id : = ops . lease ID if id = = v 3 . No Lease { resp , err : = client . Grant ( ops . ctx , int 6 4 ( ops . ttl ) ) if err ! = nil { return nil , err } id = v 3 . Lease ID ( resp . ID ) } ctx , cancel : = context . With Cancel ( ops . ctx ) keep Alive , err : = client . Keep Alive ( ctx , id ) if err ! = nil | | keep Alive = = nil { cancel ( ) return nil , err } donec : = make ( chan struct { } ) s : = & Session { client : client , opts : ops , id : id , cancel : cancel , donec : donec } for range keep Alive { } ( ) return s , nil } 
func ( s * Session ) Close ( ) error { s . Orphan ( ) _ , err : = s . client . Revoke ( ctx , s . id ) cancel ( ) return err } 
func With TTL ( ttl int ) Session Option { return func ( so * session Options ) { if ttl > 0 { so . ttl = ttl } } } 
func With Lease ( lease ID v 3 . Lease ID ) Session Option { return func ( so * session Options ) { so . lease ID = lease ID } } 
func With Context ( ctx context . Context ) Session Option { return func ( so * session Options ) { so . ctx = ctx } } 
func ( ro * read Only ) add Request ( index uint 6 4 , m pb . Message ) { ctx : = string ( m . Entries [ 0 ] . Data ) if _ , ok : = ro . pending Read Index [ ctx ] ; ok { return } ro . pending Read Index [ ctx ] = & read Index Status { index : index , req : m , acks : make ( map [ uint 6 4 ] struct { } ) } ro . read Index Queue = append ( ro . read Index Queue , ctx ) } 
func ( ro * read Only ) recv Ack ( m pb . Message ) int { rs , ok : = ro . pending Read Index [ string ( m . Context ) ] if ! ok { return 0 } rs . acks [ m . From ] = struct { } { } } 
func ( ro * read Only ) advance ( m pb . Message ) [ ] * read Index Status { var ( i int found bool ) ctx : = string ( m . Context ) rss : = [ ] * read Index Status { } for _ , okctx : = range ro . read Index Queue { i + + rs , ok : = ro . pending Read Index [ okctx ] if ! ok { panic ( " " ) } rss = append ( rss , rs ) if okctx = = ctx { found = true break } } if found { ro . read Index Queue = ro . read Index Queue [ i : ] for _ , rs : = range rss { delete ( ro . pending Read Index , string ( rs . req . Entries [ 0 ] . Data ) ) } return rss } return nil } 
func ( ro * read Only ) last Pending Request Ctx ( ) string { if len ( ro . read Index Queue ) = = 0 { return " " } return ro . read Index Queue [ len ( ro . read Index Queue ) - 1 ] } 
func New Server ( cfg Server Config ) ( srv * Etcd Server , err error ) { st : = v 2store . New ( Store Cluster Prefix , Store Keys Prefix ) var ( w * wal . WAL n raft . Node s * raft . Memory Storage id types . ID cl * membership . Raft Cluster ) if cfg . Max Request Bytes > recommended Max Request Bytes { if cfg . Logger ! = nil { cfg . Logger . Warn ( " " , zap . Uint ( " " , cfg . Max Request Bytes ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( cfg . Max Request Bytes ) ) ) , zap . Int ( " " , recommended Max Request Bytes ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( recommended Max Request Bytes ) ) ) , ) } else { plog . Warningf ( " " , cfg . Max Request Bytes , recommended Max Request Bytes ) } } if terr : = fileutil . Touch Dir All ( cfg . Data Dir ) ; terr ! = nil { return nil , fmt . Errorf ( " " , terr ) } have WAL : = wal . Exist ( cfg . WALDir ( ) ) if err = fileutil . Touch Dir All ( cfg . Snap Dir ( ) ) ; err ! = nil { if cfg . Logger ! = nil { cfg . Logger . Fatal ( " " , zap . String ( " " , cfg . Snap Dir ( ) ) , zap . Error ( err ) , ) } else { plog . Fatalf ( " " , err ) } } ss : = snap . New ( cfg . Logger , cfg . Snap Dir ( ) ) bepath : = cfg . backend Path ( ) be Exist : = fileutil . Exist ( bepath ) be : = open Backend ( cfg ) defer func ( ) { if err ! = nil { be . Close ( ) } } ( ) prt , err : = rafthttp . New Round Tripper ( cfg . Peer TLSInfo , cfg . peer Dial Timeout ( ) ) if err ! = nil { return nil , err } var ( remotes [ ] * membership . Member snapshot * raftpb . Snapshot ) switch { case ! have WAL & & ! cfg . New Cluster : if err = cfg . Verify Join Existing ( ) ; err ! = nil { return nil , err } cl , err = membership . New Cluster From URLs Map ( cfg . Logger , cfg . Initial Cluster Token , cfg . Initial Peer URLs Map ) if err ! = nil { return nil , err } existing Cluster , gerr : = Get Cluster From Remote Peers ( cfg . Logger , get Remote Peer URLs ( cl , cfg . Name ) , prt ) if gerr ! = nil { return nil , fmt . Errorf ( " " , gerr ) } if err = membership . Validate Cluster And Assign IDs ( cfg . Logger , cl , existing Cluster ) ; err ! = nil { return nil , fmt . Errorf ( " " , existing Cluster , err ) } if ! is Compatible With Cluster ( cfg . Logger , cl , cl . Member By Name ( cfg . Name ) . ID , prt ) { return nil , fmt . Errorf ( " " ) } remotes = existing Cluster . Members ( ) cl . Set ID ( types . ID ( 0 ) , existing Cluster . ID ( ) ) cl . Set Store ( st ) cl . Set Backend ( be ) id , n , s , w = start Node ( cfg , cl , nil ) cl . Set ID ( id , existing Cluster . ID ( ) ) case ! have WAL & & cfg . New Cluster : if err = cfg . Verify Bootstrap ( ) ; err ! = nil { return nil , err } cl , err = membership . New Cluster From URLs Map ( cfg . Logger , cfg . Initial Cluster Token , cfg . Initial Peer URLs Map ) if err ! = nil { return nil , err } m : = cl . Member By Name ( cfg . Name ) if is Member Bootstrapped ( cfg . Logger , cl , cfg . Name , prt , cfg . bootstrap Timeout ( ) ) { return nil , fmt . Errorf ( " " , m . ID ) } if cfg . Should Discover ( ) { var str string str , err = v 2discovery . Join Cluster ( cfg . Logger , cfg . Discovery URL , cfg . Discovery Proxy , m . ID , cfg . Initial Peer URLs Map . String ( ) ) if err ! = nil { return nil , & Discovery Error { Op : " " , Err : err } } var urlsmap types . URLs Map urlsmap , err = types . New URLs Map ( str ) if err ! = nil { return nil , err } if check Duplicate URL ( urlsmap ) { return nil , fmt . Errorf ( " " , urlsmap ) } if cl , err = membership . New Cluster From URLs Map ( cfg . Logger , cfg . Initial Cluster Token , urlsmap ) ; err ! = nil { return nil , err } } cl . Set Store ( st ) cl . Set Backend ( be ) id , n , s , w = start Node ( cfg , cl , cl . Member IDs ( ) ) cl . Set ID ( id , cl . ID ( ) ) case have WAL : if err = fileutil . Is Dir Writeable ( cfg . Member Dir ( ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err = fileutil . Is Dir Writeable ( cfg . WALDir ( ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if cfg . Should Discover ( ) { if cfg . Logger ! = nil { cfg . Logger . Warn ( " " , zap . String ( " " , cfg . WALDir ( ) ) , ) } else { plog . Warningf ( " " , cfg . WALDir ( ) ) } } snapshot , err = ss . Load ( ) if err ! = nil & & err ! = snap . Err No Snapshot { return nil , err } if snapshot ! = nil { if err = st . Recovery ( snapshot . Data ) ; err ! = nil { if cfg . Logger ! = nil { cfg . Logger . Panic ( " " ) } else { plog . Panicf ( " " , err ) } } if cfg . Logger ! = nil { cfg . Logger . Info ( " " , zap . Uint 6 4 ( " " , snapshot . Metadata . Index ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( snapshot . Size ( ) ) ) ) , ) } else { plog . Infof ( " " , snapshot . Metadata . Index ) } if be , err = recover Snapshot Backend ( cfg , be , * snapshot ) ; err ! = nil { if cfg . Logger ! = nil { cfg . Logger . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if cfg . Logger ! = nil { s 1 , s 2 : = be . Size ( ) , be . Size In Use ( ) cfg . Logger . Info ( " " , zap . Int 6 4 ( " " , s 1 ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( s 1 ) ) ) , zap . Int 6 4 ( " " , s 2 ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( s 2 ) ) ) , ) } } if ! cfg . Force New Cluster { id , cl , n , s , w = restart Node ( cfg , snapshot ) } else { id , cl , n , s , w = restart As Standalone Node ( cfg , snapshot ) } cl . Set Store ( st ) cl . Set Backend ( be ) cl . Recover ( api . Update Capability ) if cl . Version ( ) ! = nil & & ! cl . Version ( ) . Less Than ( semver . Version { Major : 3 } ) & & ! be Exist { os . Remove All ( bepath ) return nil , fmt . Errorf ( " " , bepath ) } default : return nil , fmt . Errorf ( " " ) } if terr : = fileutil . Touch Dir All ( cfg . Member Dir ( ) ) ; terr ! = nil { return nil , fmt . Errorf ( " " , terr ) } sstats : = stats . New Server Stats ( cfg . Name , id . String ( ) ) lstats : = stats . New Leader Stats ( id . String ( ) ) heartbeat : = time . Duration ( cfg . Tick Ms ) * time . Millisecond srv = & Etcd Server { readych : make ( chan struct { } ) , Cfg : cfg , lg Mu : new ( sync . RWMutex ) , lg : cfg . Logger , errorc : make ( chan error , 1 ) , v 2store : st , snapshotter : ss , r : * new Raft Node ( raft Node Config { lg : cfg . Logger , is IDRemoved : func ( id uint 6 4 ) bool { return cl . Is IDRemoved ( types . ID ( id ) ) } , Node : n , heartbeat : heartbeat , raft Storage : s , storage : New Storage ( w , ss ) , } , ) , id : id , attributes : membership . Attributes { Name : cfg . Name , Client URLs : cfg . Client URLs . String Slice ( ) } , cluster : cl , stats : sstats , lstats : lstats , Sync Ticker : time . New Ticker ( 5 0 0 * time . Millisecond ) , peer Rt : prt , req IDGen : idutil . New Generator ( uint 1 6 ( id ) , time . Now ( ) ) , force Version C : make ( chan struct { } ) , Access Controller : & Access Controller { CORS : cfg . CORS , Host Whitelist : cfg . Host Whitelist } , } server ID . With ( prometheus . Labels { " " : id . String ( ) } ) . Set ( 1 ) srv . apply V 2 = & applier V 2store { store : srv . v 2store , cluster : srv . cluster } srv . be = be min TTL : = time . Duration ( ( 3 * cfg . Election Ticks ) / 2 ) * heartbeat srv . kv = mvcc . New ( srv . get Logger ( ) , srv . be , srv . lessor , & srv . consist Index ) if be Exist { kvindex : = srv . kv . Consistent Index ( ) } if cfg . Logger ! = nil { cfg . Logger . Warn ( " " , zap . Uint 6 4 ( " " , snapshot . Metadata . Index ) , ) } else { plog . Warningf ( " " , snapshot . Metadata . Index ) } } } new Srv : = srv defer func ( ) { } } ( ) srv . consist Index . set Consistent Index ( srv . kv . Consistent Index ( ) ) tp , err : = auth . New Token Provider ( cfg . Logger , cfg . Auth Token , func ( index uint 6 4 ) < - chan struct { } { return srv . apply Wait . Wait ( index ) } , ) if err ! = nil { if cfg . Logger ! = nil { cfg . Logger . Warn ( " " , zap . Error ( err ) ) } else { plog . Errorf ( " " , err ) } return nil , err } srv . auth Store = auth . New Auth Store ( srv . get Logger ( ) , srv . be , tp , int ( cfg . Bcrypt Cost ) ) if num : = cfg . Auto Compaction Retention ; num ! = 0 { srv . compactor , err = v 3compactor . New ( cfg . Logger , cfg . Auto Compaction Mode , num , srv . kv , srv ) if err ! = nil { return nil , err } srv . compactor . Run ( ) } srv . apply V 3Base = srv . new Applier V 3Backend ( ) if err = srv . restore Alarms ( ) ; err ! = nil { return nil , err } srv . lessor . Set Checkpointer ( func ( ctx context . Context , cp * pb . Lease Checkpoint Request ) { srv . raft Request Once ( ctx , pb . Internal Raft Request { Lease Checkpoint : cp } ) } ) if err = tr . Start ( ) ; err ! = nil { return nil , err } } } for _ , m : = range cl . Members ( ) { if m . ID ! = id { tr . Add Peer ( m . ID , m . Peer URLs ) } } srv . r . transport = tr return srv , nil } 
func ( s * Etcd Server ) Start ( ) { s . start ( ) s . go Attach ( func ( ) { s . adjust Ticks ( ) } ) s . go Attach ( func ( ) { s . publish ( s . Cfg . Req Timeout ( ) ) } ) s . go Attach ( s . purge File ) s . go Attach ( func ( ) { monitor File Descriptor ( s . get Logger ( ) , s . stopping ) } ) s . go Attach ( s . monitor Versions ) s . go Attach ( s . linearizable Read Loop ) s . go Attach ( s . monitor KVHash ) } 
func ( s * Etcd Server ) start ( ) { lg : = s . get Logger ( ) if s . Cfg . Snapshot Count = = 0 { if lg ! = nil { lg . Info ( " " , zap . Uint 6 4 ( " " , s . Cfg . Snapshot Count ) , zap . Uint 6 4 ( " " , Default Snapshot Count ) , ) } else { plog . Infof ( " " , Default Snapshot Count ) } s . Cfg . Snapshot Count = Default Snapshot Count } if s . Cfg . Snapshot Catch Up Entries = = 0 { if lg ! = nil { lg . Info ( " " , zap . Uint 6 4 ( " " , s . Cfg . Snapshot Catch Up Entries ) , zap . Uint 6 4 ( " " , Default Snapshot Catch Up Entries ) , ) } s . Cfg . Snapshot Catch Up Entries = Default Snapshot Catch Up Entries } s . w = wait . New ( ) s . apply Wait = wait . New Time List ( ) s . done = make ( chan struct { } ) s . stop = make ( chan struct { } ) s . stopping = make ( chan struct { } ) s . ctx , s . cancel = context . With Cancel ( context . Background ( ) ) s . readwaitc = make ( chan struct { } , 1 ) s . read Notifier = new Notifier ( ) s . leader Changed = make ( chan struct { } ) if s . Cluster Version ( ) ! = nil { if lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , version . Version ) , zap . String ( " " , s . Cluster ( ) . ID ( ) . String ( ) ) , zap . String ( " " , version . Cluster ( s . Cluster Version ( ) . String ( ) ) ) , ) } else { plog . Infof ( " " , version . Version , version . Cluster ( s . Cluster Version ( ) . String ( ) ) ) } membership . Cluster Version Metrics . With ( prometheus . Labels { " " : s . Cluster Version ( ) . String ( ) } ) . Set ( 1 ) } else { if lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , version . Version ) , zap . String ( " " , " " ) , ) } else { plog . Infof ( " " , version . Version ) } } } 
func ( s * Etcd Server ) Process ( ctx context . Context , m raftpb . Message ) error { if s . cluster . Is IDRemoved ( types . ID ( m . From ) ) { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , types . ID ( m . From ) . String ( ) ) , ) } else { plog . Warningf ( " " , types . ID ( m . From ) . String ( ) ) } return httptypes . New HTTPError ( http . Status Forbidden , " " ) } if m . Type = = raftpb . Msg App { s . stats . Recv Append Req ( types . ID ( m . From ) . String ( ) , m . Size ( ) ) } return s . r . Step ( ctx , m ) } 
func ( s * Etcd Server ) Report Snapshot ( id uint 6 4 , status raft . Snapshot Status ) { s . r . Report Snapshot ( id , status ) } 
func ( s * Etcd Server ) Move Leader ( ctx context . Context , lead , transferee uint 6 4 ) error { now : = time . Now ( ) interval : = time . Duration ( s . Cfg . Tick Ms ) * time . Millisecond if lg : = s . get Logger ( ) ; lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , types . ID ( lead ) . String ( ) ) , zap . String ( " " , types . ID ( transferee ) . String ( ) ) , ) } else { plog . Infof ( " " , s . ID ( ) , types . ID ( lead ) , types . ID ( transferee ) ) } s . r . Transfer Leadership ( ctx , lead , transferee ) for s . Lead ( ) ! = transferee { select { case < - ctx . Done ( ) : case < - time . After ( interval ) : } } } else { plog . Infof ( " " , s . ID ( ) , types . ID ( lead ) , types . ID ( transferee ) , time . Since ( now ) ) } return nil } 
func ( s * Etcd Server ) Transfer Leadership ( ) error { if ! s . is Leader ( ) { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , types . ID ( s . Lead ( ) ) . String ( ) ) , ) } else { plog . Printf ( " " ) } return nil } if ! s . is Multi Node ( ) { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , types . ID ( s . Lead ( ) ) . String ( ) ) , ) } else { plog . Printf ( " " ) } return nil } transferee , ok : = longest Connected ( s . r . transport , s . cluster . Member IDs ( ) ) if ! ok { return Err Unhealthy } tm : = s . Cfg . Req Timeout ( ) ctx , cancel : = context . With Timeout ( s . ctx , tm ) err : = s . Move Leader ( ctx , s . Lead ( ) , uint 6 4 ( transferee ) ) cancel ( ) return err } 
func ( s * Etcd Server ) Stop ( ) { if err : = s . Transfer Leadership ( ) ; err ! = nil { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . Error ( err ) ) } else { plog . Warningf ( " " , s . ID ( ) , err ) } } s . Hard Stop ( ) } 
func ( s * Etcd Server ) configure ( ctx context . Context , cc raftpb . Conf Change ) ( [ ] * membership . Member , error ) { cc . ID = s . req IDGen . Next ( ) ch : = s . w . Register ( cc . ID ) start : = time . Now ( ) if err : = s . r . Propose Conf Change ( ctx , cc ) ; err ! = nil { s . w . Trigger ( cc . ID , nil ) return nil , err } select { case x : = < - ch : if x = = nil { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Panic ( " " ) } else { plog . Panicf ( " " ) } } resp : = x . ( * conf Change Response ) if lg : = s . get Logger ( ) ; lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , cc . Type . String ( ) ) , zap . String ( " " , types . ID ( cc . Node ID ) . String ( ) ) , ) } return resp . membs , resp . err case < - ctx . Done ( ) : s . w . Trigger ( cc . ID , nil ) return nil , s . parse Propose Ctx Err ( ctx . Err ( ) , start ) case < - s . stopping : return nil , Err Stopped } } 
func ( s * Etcd Server ) sync ( timeout time . Duration ) { req : = pb . Request { Method : " " , ID : s . req IDGen . Next ( ) , Time : time . Now ( ) . Unix Nano ( ) , } data : = pbutil . Must Marshal ( & req ) s . go Attach ( func ( ) { s . r . Propose ( ctx , data ) cancel ( ) } ) } 
func ( s * Etcd Server ) publish ( timeout time . Duration ) { b , err : = json . Marshal ( s . attributes ) if err ! = nil { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } return } req : = pb . Request { Method : " " , Path : membership . Member Attributes Store Path ( s . id ) , Val : string ( b ) , } for { ctx , cancel : = context . With Timeout ( s . ctx , timeout ) _ , err : = s . Do ( ctx , req ) cancel ( ) switch err { case nil : close ( s . readych ) if lg : = s . get Logger ( ) ; lg ! = nil { lg . Info ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , fmt . Sprintf ( " " , s . attributes ) ) , zap . String ( " " , req . Path ) , zap . String ( " " , s . cluster . ID ( ) . String ( ) ) , zap . Duration ( " " , timeout ) , ) } else { plog . Infof ( " " , s . attributes , s . cluster . ID ( ) ) } return case Err Stopped : if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , fmt . Sprintf ( " " , s . attributes ) ) , zap . Duration ( " " , timeout ) , zap . Error ( err ) , ) } else { plog . Infof ( " " ) } return default : if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " , zap . String ( " " , s . ID ( ) . String ( ) ) , zap . String ( " " , fmt . Sprintf ( " " , s . attributes ) ) , zap . String ( " " , req . Path ) , zap . Duration ( " " , timeout ) , zap . Error ( err ) , ) } else { plog . Errorf ( " " , err ) } } } } 
func ( s * Etcd Server ) apply ( es [ ] raftpb . Entry , conf State * raftpb . Conf State , ) ( appliedt uint 6 4 , appliedi uint 6 4 , should Stop bool ) { for i : = range es { e : = es [ i ] switch e . Type { case raftpb . Entry Normal : s . apply Entry Normal ( & e ) s . set Applied Index ( e . Index ) s . set Term ( e . Term ) case raftpb . Entry Conf Change : } var cc raftpb . Conf Change pbutil . Must Unmarshal ( & cc , e . Data ) removed Self , err : = s . apply Conf Change ( cc , conf State ) s . set Applied Index ( e . Index ) s . set Term ( e . Term ) should Stop = should Stop | | removed Self s . w . Trigger ( cc . ID , & conf Change Response { s . cluster . Members ( ) , err } ) default : if lg : = s . get Logger ( ) ; lg ! = nil { lg . Panic ( " " , zap . String ( " " , e . Type . String ( ) ) , ) } else { plog . Panicf ( " " ) } } appliedi , appliedt = e . Index , e . Term } return appliedt , appliedi , should Stop } 
func ( s * Etcd Server ) apply Entry Normal ( e * raftpb . Entry ) { should Apply V 3 : = false if e . Index > s . consist Index . Consistent Index ( ) { should Apply V 3 = true } } return } var raft Req pb . Internal Raft Request if ! pbutil . Maybe Unmarshal ( & raft Req , e . Data ) { rp : = & r pbutil . Must Unmarshal ( rp , e . Data ) s . w . Trigger ( r . ID , s . apply V 2Request ( ( * Request V 2 ) ( rp ) ) ) return } if raft Req . V 2 ! = nil { req : = ( * Request V 2 ) ( raft Req . V 2 ) s . w . Trigger ( req . ID , s . apply V 2Request ( req ) ) return } } id : = raft Req . ID if id = = 0 { id = raft Req . Header . ID } var ar * apply Result need Result : = s . w . Is Registered ( id ) if need Result | | ! no Side Effect ( & raft Req ) { if ! need Result & & raft Req . Txn ! = nil { remove Needless Range Reqs ( raft Req . Txn ) } ar = s . apply V 3 . Apply ( & raft Req ) } if ar = = nil { return } if ar . err ! = Err No Space | | len ( s . alarm Store . Get ( pb . Alarm Type _NOSPACE ) ) > 0 { s . w . Trigger ( id , ar ) return } if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " , zap . Int 6 4 ( " " , s . Cfg . Quota Backend Bytes ) , zap . String ( " " , humanize . Bytes ( uint 6 4 ( s . Cfg . Quota Backend Bytes ) ) ) , zap . Error ( ar . err ) , ) } else { plog . Errorf ( " " ) } s . go Attach ( func ( ) { a : = & pb . Alarm Request { Member ID : uint 6 4 ( s . ID ( ) ) , Action : pb . Alarm Request _ACTIVATE , Alarm : pb . Alarm Type _NOSPACE , } s . raft Request ( s . ctx , pb . Internal Raft Request { Alarm : a } ) s . w . Trigger ( id , ar ) } ) } 
func ( s * Etcd Server ) apply Conf Change ( cc raftpb . Conf Change , conf State * raftpb . Conf State ) ( bool , error ) { if err : = s . cluster . Validate Configuration Change ( cc ) ; err ! = nil { cc . Node ID = raft . None s . r . Apply Conf Change ( cc ) return false , err } lg : = s . get Logger ( ) * conf State = * s . r . Apply Conf Change ( cc ) switch cc . Type { case raftpb . Conf Change Add Node : m : = new ( membership . Member ) if err : = json . Unmarshal ( cc . Context , m ) ; err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if cc . Node ID ! = uint 6 4 ( m . ID ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , types . ID ( cc . Node ID ) . String ( ) ) , zap . String ( " " , m . ID . String ( ) ) , ) } else { plog . Panicf ( " " ) } } s . cluster . Add Member ( m ) if m . ID ! = s . id { s . r . transport . Add Peer ( m . ID , m . Peer URLs ) } case raftpb . Conf Change Remove Node : id : = types . ID ( cc . Node ID ) s . cluster . Remove Member ( id ) if id = = s . id { return true , nil } s . r . transport . Remove Peer ( id ) case raftpb . Conf Change Update Node : m : = new ( membership . Member ) if err : = json . Unmarshal ( cc . Context , m ) ; err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if cc . Node ID ! = uint 6 4 ( m . ID ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , types . ID ( cc . Node ID ) . String ( ) ) , zap . String ( " " , m . ID . String ( ) ) , ) } else { plog . Panicf ( " " ) } } s . cluster . Update Raft Attributes ( m . ID , m . Raft Attributes ) if m . ID ! = s . id { s . r . transport . Update Peer ( m . ID , m . Peer URLs ) } } return false , nil } 
func ( s * Etcd Server ) snapshot ( snapi uint 6 4 , conf State raftpb . Conf State ) { clone : = s . v 2store . Clone ( ) s . go Attach ( func ( ) { lg : = s . get Logger ( ) d , err : = clone . Save No Copy ( ) } else { plog . Panicf ( " " , err ) } } snap , err : = s . r . raft Storage . Create Snapshot ( snapi , & conf State , d ) if err ! = nil { } if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } } else { plog . Fatalf ( " " , err ) } } if lg ! = nil { lg . Info ( " " , zap . Uint 6 4 ( " " , snap . Metadata . Index ) , ) } else { plog . Infof ( " " , snap . Metadata . Index ) } } else { plog . Infof ( " " ) } return } if snapi > s . Cfg . Snapshot Catch Up Entries { compacti = snapi - s . Cfg . Snapshot Catch Up Entries } err = s . r . raft Storage . Compact ( compacti ) if err ! = nil { } if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if lg ! = nil { lg . Info ( " " , zap . Uint 6 4 ( " " , compacti ) , ) } else { plog . Infof ( " " , compacti ) } } ) } 
func ( s * Etcd Server ) Cut Peer ( id types . ID ) { tr , ok : = s . r . transport . ( * rafthttp . Transport ) if ok { tr . Cut Peer ( id ) } } 
func ( s * Etcd Server ) monitor Versions ( ) { for { select { case < - s . force Version C : case < - time . After ( monitor Version Interval ) : case < - s . stopping : return } if s . Leader ( ) ! = s . ID ( ) { continue } v : = decide Cluster Version ( s . get Logger ( ) , get Versions ( s . get Logger ( ) , s . cluster , s . id , s . peer Rt ) ) if v ! = nil { } if v ! = nil { ver Str = v . String ( ) } s . go Attach ( func ( ) { s . update Cluster Version ( ver Str ) } ) continue } } } } 
func ( s * Etcd Server ) go Attach ( f func ( ) ) { s . wg Mu . RLock ( ) defer s . wg Mu . RUnlock ( ) select { case < - s . stopping : if lg : = s . get Logger ( ) ; lg ! = nil { lg . Warn ( " " ) } else { plog . Warning ( " " ) } return default : } go func ( ) { defer s . wg . Done ( ) f ( ) } ( ) } 
func New Roundrobin Balanced ( lg * zap . Logger , scs [ ] balancer . Sub Conn , addr To Sc map [ resolver . Address ] balancer . Sub Conn , sc To Addr map [ balancer . Sub Conn ] resolver . Address , ) Picker { return & rr Balanced { lg : lg , scs : scs , addr To Sc : addr To Sc , sc To Addr : sc To Addr , } } 
func ( rb * rr Balanced ) Pick ( ctx context . Context , opts balancer . Pick Options ) ( balancer . Sub Conn , func ( balancer . Done Info ) , error ) { rb . mu . RLock ( ) n : = len ( rb . scs ) rb . mu . RUnlock ( ) if n = = 0 { return nil , nil , balancer . Err No Sub Conn Available } rb . mu . Lock ( ) cur : = rb . next sc : = rb . scs [ cur ] picked : = rb . sc To Addr [ sc ] . Addr rb . next = ( rb . next + 1 ) % len ( rb . scs ) rb . mu . Unlock ( ) rb . lg . Debug ( " " , zap . String ( " " , picked ) , zap . Int ( " " , cur ) , zap . Int ( " " , n ) , ) done Func : = func ( info balancer . Done Info ) { if info . Err = = nil { rb . lg . Debug ( " " , fss . . . ) } else { rb . lg . Warn ( " " , fss . . . ) } } return sc , done Func , nil } 
func New TLSListener ( l net . Listener , tlsinfo * TLSInfo ) ( net . Listener , error ) { check : = func ( context . Context , * tls . Conn ) error { return nil } return new TLSListener ( l , tlsinfo , check ) } 
func ( l * tls Listener ) accept Loop ( ) { var wg sync . Wait Group var pending Mu sync . Mutex pending : = make ( map [ net . Conn ] struct { } ) ctx , cancel : = context . With Cancel ( context . Background ( ) ) defer func ( ) { cancel ( ) pending Mu . Lock ( ) for c : = range pending { c . Close ( ) } pending Mu . Unlock ( ) wg . Wait ( ) close ( l . donec ) } ( ) for { conn , err : = l . Listener . Accept ( ) if err ! = nil { l . err = err return } pending Mu . Lock ( ) pending [ conn ] = struct { } { } pending Mu . Unlock ( ) wg . Add ( 1 ) go func ( ) { defer func ( ) { if conn ! = nil { conn . Close ( ) } wg . Done ( ) } ( ) tls Conn : = conn . ( * tls . Conn ) herr : = tls Conn . Handshake ( ) pending Mu . Lock ( ) delete ( pending , conn ) pending Mu . Unlock ( ) if herr ! = nil { l . handshake Failure ( tls Conn , herr ) return } if err : = l . check ( ctx , tls Conn ) ; err ! = nil { l . handshake Failure ( tls Conn , err ) return } select { case l . connc < - tls Conn : conn = nil case < - ctx . Done ( ) : } } ( ) } } 
func ( e * Resolver Group ) Set Endpoints ( endpoints [ ] string ) { addrs : = eps To Addrs ( endpoints . . . ) e . mu . Lock ( ) e . endpoints = endpoints for _ , r : = range e . resolvers { r . cc . New Address ( addrs ) } e . mu . Unlock ( ) } 
func ( e * Resolver Group ) Target ( endpoint string ) string { return Target ( e . id , endpoint ) } 
func Target ( id , endpoint string ) string { return fmt . Sprintf ( " " , scheme , id , endpoint ) } 
func ( b * builder ) Build ( target resolver . Target , cc resolver . Client Conn , opts resolver . Build Option ) ( resolver . Resolver , error ) { if len ( target . Authority ) < 1 { return nil , fmt . Errorf ( " " ) } id : = target . Authority es , err : = b . get Resolver Group ( id ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } r : = & Resolver { endpoint ID : id , cc : cc , } es . add Resolver ( r ) return r , nil } 
func eps To Addrs ( eps . . . string ) ( addrs [ ] resolver . Address ) { addrs = make ( [ ] resolver . Address , 0 , len ( eps ) ) for _ , ep : = range eps { addrs = append ( addrs , resolver . Address { Addr : ep } ) } return addrs } 
func Parse Endpoint ( endpoint string ) ( proto string , host string , scheme string ) { proto = " " host = endpoint url , uerr : = url . Parse ( endpoint ) if uerr ! = nil | | ! strings . Contains ( endpoint , " " ) { return proto , host , scheme } scheme = url . Scheme switch url . Scheme { case " " , " " : case " " , " " : proto = " " host = url . Host + url . Path default : proto , host = " " , " " } return proto , host , scheme } 
func Parse Target ( target string ) ( string , string , error ) { no Prefix : = strings . Trim Prefix ( target , target Prefix ) if no Prefix = = target { return " " , " " , fmt . Errorf ( " " , target Prefix , target ) } parts : = strings . Split N ( no Prefix , " " , 2 ) if len ( parts ) ! = 2 { return " " , " " , fmt . Errorf ( " " , scheme , target ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func Parse Host Port ( host Port string ) ( host string , port string ) { parts : = strings . Split N ( host Port , " " , 2 ) host = parts [ 0 ] if len ( parts ) > 1 { port = parts [ 1 ] } return host , port } 
func ( r * Request V 2 ) Handle ( ctx context . Context , v 2api Request V 2Handler ) ( Response , error ) { if r . Method = = " " & & r . Quorum { r . Method = " " } switch r . Method { case " " : return v 2api . Post ( ctx , r ) case " " : return v 2api . Put ( ctx , r ) case " " : return v 2api . Delete ( ctx , r ) case " " : return v 2api . QGet ( ctx , r ) case " " : return v 2api . Get ( ctx , r ) case " " : return v 2api . Head ( ctx , r ) } return Response { } , Err Unknown Method } 
func New Election Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : run Election Func , } cmd . Flags ( ) . Int Var ( & total Client Connections , " " , 1 0 , " " ) return cmd } 
func node To Member ( n * v 2store . Node Extern ) ( * Member , error ) { m : = & Member { ID : Must Parse Member IDFrom Key ( n . Key ) } attrs : = make ( map [ string ] [ ] byte ) raft Attr Key : = path . Join ( n . Key , raft Attributes Suffix ) attr Key : = path . Join ( n . Key , attributes Suffix ) for _ , nn : = range n . Nodes { if nn . Key ! = raft Attr Key & & nn . Key ! = attr Key { return nil , fmt . Errorf ( " " , nn . Key ) } attrs [ nn . Key ] = [ ] byte ( * nn . Value ) } if data : = attrs [ raft Attr Key ] ; data ! = nil { if err : = json . Unmarshal ( data , & m . Raft Attributes ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } else { return nil , fmt . Errorf ( " " ) } if data : = attrs [ attr Key ] ; data ! = nil { if err : = json . Unmarshal ( data , & m . Attributes ) ; err ! = nil { return m , fmt . Errorf ( " " , err ) } } return m , nil } 
func New Tmp Backend ( batch Interval time . Duration , batch Limit int ) ( * backend , string ) { dir , err : = ioutil . Temp Dir ( os . Temp Dir ( ) , " " ) if err ! = nil { panic ( err ) } tmp Path : = filepath . Join ( dir , " " ) bcfg : = Default Backend Config ( ) bcfg . Path , bcfg . Batch Interval , bcfg . Batch Limit = tmp Path , batch Interval , batch Limit return new Backend ( bcfg ) , tmp Path } 
func new Revision ( lg * zap . Logger , clock clockwork . Clock , retention int 6 4 , rg Rev Getter , c Compactable ) * Revision { rc : = & Revision { lg : lg , clock : clock , retention : retention , rg : rg , c : c , } rc . ctx , rc . cancel = context . With Cancel ( context . Background ( ) ) return rc } 
func ( rc * Revision ) Run ( ) { prev : = int 6 4 ( 0 ) go func ( ) { for { select { case < - rc . ctx . Done ( ) : return case < - rc . clock . After ( rev Interval ) : rc . mu . Lock ( ) p : = rc . paused rc . mu . Unlock ( ) if p { continue } } rev : = rc . rg . Rev ( ) - rc . retention if rev < = 0 | | rev = = prev { continue } now : = time . Now ( ) if rc . lg ! = nil { rc . lg . Info ( " " , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , rc . retention ) , ) } else { plog . Noticef ( " " , rev , rc . retention ) } _ , err : = rc . c . Compact ( rc . ctx , & pb . Compaction Request { Revision : rev } ) if err = = nil | | err = = mvcc . Err Compacted { prev = rev if rc . lg ! = nil { rc . lg . Info ( " " , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , rc . retention ) , zap . Duration ( " " , time . Since ( now ) ) , ) } else { plog . Noticef ( " " , rev ) } } else { if rc . lg ! = nil { rc . lg . Warn ( " " , zap . Int 6 4 ( " " , rev ) , zap . Int 6 4 ( " " , rc . retention ) , zap . Duration ( " " , rev Interval ) , zap . Error ( err ) , ) } else { plog . Noticef ( " " , rev , err ) plog . Noticef ( " " , rev Interval ) } } } } ( ) } 
func ( rc * Revision ) Pause ( ) { rc . mu . Lock ( ) rc . paused = true rc . mu . Unlock ( ) } 
func ( rc * Revision ) Resume ( ) { rc . mu . Lock ( ) rc . paused = false rc . mu . Unlock ( ) } 
func vote Resp Msg Type ( msgt pb . Message Type ) pb . Message Type { switch msgt { case pb . Msg Vote : return pb . Msg Vote Resp case pb . Msg Pre Vote : return pb . Msg Pre Vote Resp default : panic ( fmt . Sprintf ( " " , msgt ) ) } } 
func Describe Message ( m pb . Message , f Entry Formatter ) string { var buf bytes . Buffer fmt . Fprintf ( & buf , " " , m . From , m . To , m . Type , m . Term , m . Log Term , m . Index ) if m . Reject { fmt . Fprintf ( & buf , " " , m . Reject Hint ) } if m . Commit ! = 0 { fmt . Fprintf ( & buf , " " , m . Commit ) } if len ( m . Entries ) > 0 { fmt . Fprintf ( & buf , " " ) for i , e : = range m . Entries { if i ! = 0 { buf . Write String ( " " ) } buf . Write String ( Describe Entry ( e , f ) ) } fmt . Fprintf ( & buf , " " ) } if ! Is Empty Snap ( m . Snapshot ) { fmt . Fprintf ( & buf , " " , m . Snapshot ) } return buf . String ( ) } 
func Describe Entry ( e pb . Entry , f Entry Formatter ) string { var formatted string if e . Type = = pb . Entry Normal & & f ! = nil { formatted = f ( e . Data ) } else { formatted = fmt . Sprintf ( " " , e . Data ) } return fmt . Sprintf ( " " , e . Term , e . Index , e . Type , formatted ) } 
func Describe Entries ( ents [ ] pb . Entry , f Entry Formatter ) string { var buf bytes . Buffer for _ , e : = range ents { _ , _ = buf . Write String ( Describe Entry ( e , f ) + " \n " ) } return buf . String ( ) } 
func watch Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] recursive : = c . Bool ( " " ) forever : = c . Bool ( " " ) index : = c . Int ( " " ) stop : = false w : = ki . Watcher ( key , & client . Watcher Options { After Index : uint 6 4 ( index ) , Recursive : recursive } ) sigch : = make ( chan os . Signal , 1 ) signal . Notify ( sigch , os . Interrupt ) go func ( ) { < - sigch os . Exit ( 0 ) } ( ) for ! stop { resp , err : = w . Next ( context . TODO ( ) ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if resp . Node . Dir { continue } if recursive { fmt . Printf ( " \n " , resp . Action , resp . Node . Key ) } print Response Key ( resp , c . Global String ( " " ) ) if ! forever { stop = true } } } 
func Set Logger ( l grpclog . Logger V 2 ) { lg Mu . Lock ( ) lg = logutil . New Logger ( l ) lg Mu . Unlock ( ) } 
func Get Logger ( ) logutil . Logger { lg Mu . RLock ( ) l : = lg lg Mu . RUnlock ( ) return l } 
func New ( s * etcdserver . Etcd Server ) * clientv 3 . Client { c : = clientv 3 . New Ctx Client ( context . Background ( ) ) kvc : = adapter . Kv Server To Kv Client ( v 3rpc . New Quota KVServer ( s ) ) c . KV = clientv 3 . New KVFrom KVClient ( kvc , c ) lc : = adapter . Lease Server To Lease Client ( v 3rpc . New Quota Lease Server ( s ) ) c . Lease = clientv 3 . New Lease From Lease Client ( lc , c , time . Second ) wc : = adapter . Watch Server To Watch Client ( v 3rpc . New Watch Server ( s ) ) c . Watcher = & watch Wrapper { clientv 3 . New Watch From Watch Client ( wc , c ) } mc : = adapter . Maintenance Server To Maintenance Client ( v 3rpc . New Maintenance Server ( s ) ) c . Maintenance = clientv 3 . New Maintenance From Maintenance Client ( mc , c ) clc : = adapter . Cluster Server To Cluster Client ( v 3rpc . New Cluster Server ( s ) ) c . Cluster = clientv 3 . New Cluster From Cluster Client ( clc , c ) } 
func ( u * unstable ) maybe First Index ( ) ( uint 6 4 , bool ) { if u . snapshot ! = nil { return u . snapshot . Metadata . Index + 1 , true } return 0 , false } 
func ( u * unstable ) maybe Last Index ( ) ( uint 6 4 , bool ) { if l : = len ( u . entries ) ; l ! = 0 { return u . offset + uint 6 4 ( l ) - 1 , true } if u . snapshot ! = nil { return u . snapshot . Metadata . Index , true } return 0 , false } 
func ( u * unstable ) maybe Term ( i uint 6 4 ) ( uint 6 4 , bool ) { if i < u . offset { if u . snapshot = = nil { return 0 , false } if u . snapshot . Metadata . Index = = i { return u . snapshot . Metadata . Term , true } return 0 , false } last , ok : = u . maybe Last Index ( ) if ! ok { return 0 , false } if i > last { return 0 , false } return u . entries [ i - u . offset ] . Term , true } 
func ( u * unstable ) shrink Entries Array ( ) { if len ( u . entries ) = = 0 { u . entries = nil } else if len ( u . entries ) * len Multiple < cap ( u . entries ) { new Entries : = make ( [ ] pb . Entry , len ( u . entries ) ) copy ( new Entries , u . entries ) u . entries = new Entries } } 
func ( u * unstable ) must Check Out Of Bounds ( lo , hi uint 6 4 ) { if lo > hi { u . logger . Panicf ( " " , lo , hi ) } upper : = u . offset + uint 6 4 ( len ( u . entries ) ) if lo < u . offset | | hi > upper { u . logger . Panicf ( " " , lo , hi , u . offset , upper ) } } 
func Handle Metrics ( mux * http . Serve Mux , c * http . Client , eps [ ] string ) { if len ( eps ) > 1 { eps = shuffle Endpoints ( r , eps ) } path Metrics : = etcdhttp . Path Metrics mux . Handle Func ( path Metrics , func ( w http . Response Writer , r * http . Request ) { target : = fmt . Sprintf ( " " , eps [ 0 ] , path Metrics ) if ! strings . Has Prefix ( target , " " ) { scheme : = " " if r . TLS ! = nil { scheme = " " } target = fmt . Sprintf ( " " , scheme , target ) } resp , err : = c . Get ( target ) if err ! = nil { http . Error ( w , " " , http . Status Internal Server Error ) } defer resp . Body . Close ( ) w . Header ( ) . Set ( " " , " " ) body , _ : = ioutil . Read All ( resp . Body ) fmt . Fprintf ( w , " " , body ) } ) } 
func ( st * storage ) Save Snap ( snap raftpb . Snapshot ) error { walsnap : = walpb . Snapshot { Index : snap . Metadata . Index , Term : snap . Metadata . Term , } err : = st . WAL . Save Snapshot ( walsnap ) if err ! = nil { return err } err = st . Snapshotter . Save Snap ( snap ) if err ! = nil { return err } return st . WAL . Release Lock To ( snap . Metadata . Index ) } 
func New ( cfg Config ) ( * Client , error ) { if len ( cfg . Endpoints ) = = 0 { return nil , Err No Available Endpoints } return new Client ( & cfg ) } 
func New Ctx Client ( ctx context . Context ) * Client { cctx , cancel : = context . With Cancel ( ctx ) return & Client { ctx : cctx , cancel : cancel } } 
func New From URL ( url string ) ( * Client , error ) { return New ( Config { Endpoints : [ ] string { url } } ) } 
func ( c * Client ) Close ( ) error { c . cancel ( ) c . Watcher . Close ( ) c . Lease . Close ( ) if c . resolver Group ! = nil { c . resolver Group . Close ( ) } if c . conn ! = nil { return to Err ( c . ctx , c . conn . Close ( ) ) } return c . ctx . Err ( ) } 
func ( c * Client ) Endpoints ( ) [ ] string { defer c . mu . RUnlock ( ) eps : = make ( [ ] string , len ( c . cfg . Endpoints ) ) copy ( eps , c . cfg . Endpoints ) return eps } 
func ( c * Client ) Set Endpoints ( eps . . . string ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) c . cfg . Endpoints = eps c . resolver Group . Set Endpoints ( eps ) } 
func ( c * Client ) Sync ( ctx context . Context ) error { mresp , err : = c . Member List ( ctx ) if err ! = nil { return err } var eps [ ] string for _ , m : = range mresp . Members { eps = append ( eps , m . Client URLs . . . ) } c . Set Endpoints ( eps . . . ) return nil } 
func ( c * Client ) dial Setup Opts ( creds * credentials . Transport Credentials , dopts . . . grpc . Dial Option ) ( opts [ ] grpc . Dial Option , err error ) { if c . cfg . Dial Keep Alive Time > 0 { params : = keepalive . Client Parameters { Time : c . cfg . Dial Keep Alive Time , Timeout : c . cfg . Dial Keep Alive Timeout , Permit Without Stream : c . cfg . Permit Without Stream , } opts = append ( opts , grpc . With Keepalive Params ( params ) ) } opts = append ( opts , dopts . . . ) select { case < - c . ctx . Done ( ) : return nil , c . ctx . Err ( ) default : } dialer : = & net . Dialer { Timeout : t } return dialer . Dial Context ( c . ctx , proto , host ) } opts = append ( opts , grpc . With Dialer ( f ) ) if creds ! = nil { opts = append ( opts , grpc . With Transport Credentials ( * creds ) ) } else { opts = append ( opts , grpc . With Insecure ( ) ) } opts = append ( opts , return opts , nil } 
func ( c * Client ) Dial ( ep string ) ( * grpc . Client Conn , error ) { creds : = c . direct Dial Creds ( ep ) } 
func ( c * Client ) dial With Balancer ( ep string , dopts . . . grpc . Dial Option ) ( * grpc . Client Conn , error ) { _ , host , _ : = endpoint . Parse Endpoint ( ep ) target : = c . resolver Group . Target ( host ) creds : = c . dial With Balancer Creds ( ep ) return c . dial ( target , creds , dopts . . . ) } 
func ( c * Client ) dial ( target string , creds * credentials . Transport Credentials , dopts . . . grpc . Dial Option ) ( * grpc . Client Conn , error ) { opts , err : = c . dial Setup Opts ( creds , dopts . . . ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if c . Username ! = " " & & c . Password ! = " " { c . token Cred = & auth Token Credential { token Mu : & sync . RWMutex { } , } ctx , cancel : = c . ctx , func ( ) { } if c . cfg . Dial Timeout > 0 { ctx , cancel = context . With Timeout ( ctx , c . cfg . Dial Timeout ) } err = c . get Token ( ctx ) if err ! = nil { if to Err ( ctx , err ) ! = rpctypes . Err Auth Not Enabled { if err = = ctx . Err ( ) & & ctx . Err ( ) ! = c . ctx . Err ( ) { err = context . Deadline Exceeded } cancel ( ) return nil , err } } else { opts = append ( opts , grpc . With Per RPCCredentials ( c . token Cred ) ) } cancel ( ) } opts = append ( opts , c . cfg . Dial Options . . . ) dctx : = c . ctx if c . cfg . Dial Timeout > 0 { var cancel context . Cancel Func dctx , cancel = context . With Timeout ( c . ctx , c . cfg . Dial Timeout ) defer cancel ( ) } conn , err : = grpc . Dial Context ( dctx , target , opts . . . ) if err ! = nil { return nil , err } return conn , nil } 
func With Require Leader ( ctx context . Context ) context . Context { md : = metadata . Pairs ( rpctypes . Metadata Require Leader Key , rpctypes . Metadata Has Leader ) return metadata . New Outgoing Context ( ctx , md ) } 
func ( c * Client ) round Robin Quorum Backoff ( wait Between time . Duration , jitter Fraction float 6 4 ) backoff Func { return func ( attempt uint ) time . Duration { quorum : = ( n / 2 + 1 ) if attempt % quorum = = 0 { c . lg . Debug ( " " , zap . Uint ( " " , attempt ) , zap . Uint ( " " , quorum ) , zap . Duration ( " " , wait Between ) , zap . Float 6 4 ( " " , jitter Fraction ) ) return jitter Up ( wait Between , jitter Fraction ) } c . lg . Debug ( " " , zap . Uint ( " " , attempt ) , zap . Uint ( " " , quorum ) ) return 0 } } 
func is Halt Err ( ctx context . Context , err error ) bool { if ctx ! = nil & & ctx . Err ( ) ! = nil { return true } if err = = nil { return false } ev , _ : = status . From Error ( err ) } 
func Is Conn Canceled ( err error ) bool { if err = = nil { return false } if ok { } } } 
func New Lease ( l clientv 3 . Lease , prefix string ) clientv 3 . Lease { return & lease Prefix { l , [ ] byte ( prefix ) } } 
func serve Http KVAPI ( kv * kvstore , port int , conf Change C chan < - raftpb . Conf Change , error C < - chan error ) { srv : = http . Server { Addr : " " + strconv . Itoa ( port ) , Handler : & http KVAPI { store : kv , conf Change C : conf Change C , } , } go func ( ) { if err : = srv . Listen And Serve ( ) ; err ! = nil { log . Fatal ( err ) } } ( ) } } 
func ( e * Event ) Is Create ( ) bool { return e . Type = = Event Type Put & & e . Kv . Create Revision = = e . Kv . Mod Revision } 
func ( wr * Watch Response ) Err ( ) error { switch { case wr . close Err ! = nil : return v 3rpc . Error ( wr . close Err ) case wr . Compact Revision ! = 0 : return v 3rpc . Err Compacted case wr . Canceled : if len ( wr . cancel Reason ) ! = 0 { return v 3rpc . Error ( status . Error ( codes . Failed Precondition , wr . cancel Reason ) ) } return v 3rpc . Err Future Rev } return nil } 
func ( wr * Watch Response ) Is Progress Notify ( ) bool { return len ( wr . Events ) = = 0 & & ! wr . Canceled & & ! wr . Created & & wr . Compact Revision = = 0 & & wr . Header . Revision ! = 0 } 
func ( w * watcher ) Watch ( ctx context . Context , key string , opts . . . Op Option ) Watch Chan { ow : = op Watch ( key , opts . . . ) var filters [ ] pb . Watch Create Request _Filter Type if ow . filter Put { filters = append ( filters , pb . Watch Create Request _NOPUT ) } if ow . filter Delete { filters = append ( filters , pb . Watch Create Request _NODELETE ) } wr : = & watch Request { ctx : ctx , created Notify : ow . created Notify , key : string ( ow . key ) , end : string ( ow . end ) , rev : ow . rev , progress Notify : ow . progress Notify , fragment : ow . fragment , filters : filters , prev KV : ow . prev KV , retc : make ( chan chan Watch Response , 1 ) , } ok : = false ctx Key : = stream Key From Ctx ( ctx ) if w . streams = = nil { ch : = make ( chan Watch Response ) close ( ch ) return ch } wgs : = w . streams [ ctx Key ] if wgs = = nil { wgs = w . new Watcher Grpc Stream ( ctx ) w . streams [ ctx Key ] = wgs } donec : = wgs . donec reqc : = wgs . reqc w . mu . Unlock ( ) case < - wr . ctx . Done ( ) : case < - donec : if wgs . close Err ! = nil { close Ch < - Watch Response { Canceled : true , close Err : wgs . close Err } break } } case < - ctx . Done ( ) : case < - donec : if wgs . close Err ! = nil { close Ch < - Watch Response { Canceled : true , close Err : wgs . close Err } break } } } close ( close Ch ) return close Ch } 
func ( w * watcher ) Request Progress ( ctx context . Context ) ( err error ) { ctx Key : = stream Key From Ctx ( ctx ) w . mu . Lock ( ) if w . streams = = nil { return fmt . Errorf ( " " ) } wgs : = w . streams [ ctx Key ] if wgs = = nil { wgs = w . new Watcher Grpc Stream ( ctx ) w . streams [ ctx Key ] = wgs } donec : = wgs . donec reqc : = wgs . reqc w . mu . Unlock ( ) pr : = & progress Request { } select { case reqc < - pr : return nil case < - ctx . Done ( ) : if err = = nil { return ctx . Err ( ) } return err case < - donec : if wgs . close Err ! = nil { return wgs . close Err } } } 
func ( w * watch Grpc Stream ) run ( ) { var wc pb . Watch _Watch Client var close Err error defer func ( ) { w . close Err = close Err closing [ ws ] = struct { } { } } } for _ , ws : = range w . resuming { if _ , ok : = closing [ ws ] ; ws ! = nil & & ! ok { close ( ws . recvc ) closing [ ws ] = struct { } { } } } w . join Substreams ( ) for range closing { w . close Substream ( < - w . closingc ) } w . wg . Wait ( ) w . owner . close Stream ( w ) } ( ) } cancel Set : = make ( map [ int 6 4 ] struct { } ) var cur * pb . Watch Response for { select { ws . donec = make ( chan struct { } ) w . wg . Add ( 1 ) go w . serve Substream ( ws , w . resumec ) if len ( w . resuming ) = = 1 { } case * progress Request : wc . Send ( wreq . to PB ( ) ) } } else if cur ! = nil & & cur . Watch Id = = pbresp . Watch Id { } switch { case pbresp . Created : w . dispatch Event ( pbresp ) w . resuming [ 0 ] = nil } if ws : = w . next Resume ( ) ; ws ! = nil { wc . Send ( ws . init Req . to PB ( ) ) } case pbresp . Canceled & & pbresp . Compact Revision = = 0 : delete ( cancel Set , pbresp . Watch Id ) if ws , ok : = w . substreams [ pbresp . Watch Id ] ; ok { closing [ ws ] = struct { } { } } case cur . Fragment : default : if ok { break } } cancel Set [ pbresp . Watch Id ] = struct { } { } cr : = & pb . Watch Request _Cancel Request { Cancel Request : & pb . Watch Cancel Request { Watch Id : pbresp . Watch Id , } , } req : = & pb . Watch Request { Request Union : cr } wc . Send ( req ) } return } if wc , close Err = w . new Watch Client ( ) ; close Err ! = nil { return } if ws : = w . next Resume ( ) ; ws ! = nil { wc . Send ( ws . init Req . to PB ( ) ) } cancel Set = make ( map [ int 6 4 ] struct { } ) case < - w . ctx . Done ( ) : return case ws : = < - w . closingc : w . close Substream ( ws ) delete ( closing , ws ) } } } } 
func ( w * watch Grpc Stream ) next Resume ( ) * watcher Stream { for len ( w . resuming ) ! = 0 { if w . resuming [ 0 ] ! = nil { return w . resuming [ 0 ] } w . resuming = w . resuming [ 1 : len ( w . resuming ) ] } return nil } 
func ( w * watch Grpc Stream ) dispatch Event ( pbresp * pb . Watch Response ) bool { events : = make ( [ ] * Event , len ( pbresp . Events ) ) for i , ev : = range pbresp . Events { events [ i ] = ( * Event ) ( ev ) } } return w . unicast Response ( wr , pbresp . Watch Id ) } 
func ( w * watch Grpc Stream ) broadcast Response ( wr * Watch Response ) bool { for _ , ws : = range w . substreams { select { case ws . recvc < - wr : case < - ws . donec : } } return true } 
func ( w * watch Grpc Stream ) unicast Response ( wr * Watch Response , watch Id int 6 4 ) bool { ws , ok : = w . substreams [ watch Id ] if ! ok { return false } select { case ws . recvc < - wr : case < - ws . donec : return false } return true } 
func ( w * watch Grpc Stream ) serve Watch Client ( wc pb . Watch _Watch Client ) { for { resp , err : = wc . Recv ( ) if err ! = nil { select { case w . errc < - err : case < - w . donec : } return } select { case w . respc < - resp : case < - w . donec : return } } } 
func ( w * watch Grpc Stream ) serve Substream ( ws * watcher Stream , resumec chan struct { } ) { if ws . closing { panic ( " " ) } resuming : = false defer func ( ) { if ! resuming { ws . closing = true } close ( ws . donec ) if ! resuming { w . closingc < - ws } w . wg . Done ( ) } ( ) empty Wr : = & Watch Response { } for { cur Wr : = empty Wr outc : = ws . outc if len ( ws . buf ) > 0 { cur Wr = ws . buf [ 0 ] } else { outc = nil } select { case outc < - * cur Wr : if ws . buf [ 0 ] . Err ( ) ! = nil { return } ws . buf [ 0 ] = nil ws . buf = ws . buf [ 1 : ] case wr , ok : = < - ws . recvc : if ! ok { } if wr . Created { if ws . init Req . retc ! = nil { ws . init Req . retc < - ws . outc } } } } else { } if len ( wr . Events ) > 0 { next Rev = wr . Events [ len ( wr . Events ) - 1 ] . Kv . Mod Revision + 1 } ws . init Req . rev = next Rev } case < - w . ctx . Done ( ) : return case < - ws . init Req . ctx . Done ( ) : return case < - resumec : resuming = true return } } 
func ( w * watch Grpc Stream ) join Substreams ( ) { for _ , ws : = range w . substreams { < - ws . donec } for _ , ws : = range w . resuming { if ws ! = nil { < - ws . donec } } } 
func ( w * watch Grpc Stream ) open Watch Client ( ) ( ws pb . Watch _Watch Client , err error ) { backoff : = time . Millisecond for { select { case < - w . ctx . Done ( ) : if err = = nil { return nil , w . ctx . Err ( ) } return nil , err default : } if ws , err = w . remote . Watch ( w . ctx , w . call Opts . . . ) ; ws ! = nil & & err = = nil { break } if is Halt Err ( w . ctx , err ) { return nil , v 3rpc . Error ( err ) } if is Unavailable Err ( w . ctx , err ) { if backoff > max Backoff { backoff = max Backoff } } time . Sleep ( backoff ) } } return ws , nil } 
func ( wr * watch Request ) to PB ( ) * pb . Watch Request { req : = & pb . Watch Create Request { Start Revision : wr . rev , Key : [ ] byte ( wr . key ) , Range End : [ ] byte ( wr . end ) , Progress Notify : wr . progress Notify , Filters : wr . filters , Prev Kv : wr . prev KV , Fragment : wr . fragment , } cr : = & pb . Watch Request _Create Request { Create Request : req } return & pb . Watch Request { Request Union : cr } } 
func ( pr * progress Request ) to PB ( ) * pb . Watch Request { req : = & pb . Watch Progress Request { } cr : = & pb . Watch Request _Progress Request { Progress Request : req } return & pb . Watch Request { Request Union : cr } } 
func ( us * unsafe Set ) Contains ( value string ) ( exists bool ) { _ , exists = us . d [ value ] return exists } 
func ( us * unsafe Set ) Contains All ( values [ ] string ) bool { for _ , s : = range values { if ! us . Contains ( s ) { return false } } return true } 
func ( us * unsafe Set ) Equals ( other Set ) bool { v 1 : = sort . String Slice ( us . Values ( ) ) v 2 : = sort . String Slice ( other . Values ( ) ) v 1 . Sort ( ) v 2 . Sort ( ) return reflect . Deep Equal ( v 1 , v 2 ) } 
func ( us * unsafe Set ) Values ( ) ( values [ ] string ) { values = make ( [ ] string , 0 ) for val : = range us . d { values = append ( values , val ) } return values } 
func ( us * unsafe Set ) Copy ( ) Set { cp : = New Unsafe Set ( ) for val : = range us . d { cp . Add ( val ) } return cp } 
func ( us * unsafe Set ) Sub ( other Set ) Set { o Values : = other . Values ( ) result : = us . Copy ( ) . ( * unsafe Set ) for _ , val : = range o Values { if _ , ok : = result . d [ val ] ; ! ok { continue } delete ( result . d , val ) } return result } 
func v 2Members URL ( ep url . URL ) * url . URL { ep . Path = path . Join ( ep . Path , default V 2Members Prefix ) return & ep } 
func New Migrate Command ( ) * cobra . Command { mc : = & cobra . Command { Use : " " , Short : " " , Run : migrate Command Func , } mc . Flags ( ) . Bool Var ( & migrate Exclude TTLKey , " " , false , " " ) mc . Flags ( ) . String Var ( & migrate Datadir , " " , " " , " " ) mc . Flags ( ) . String Var ( & migrate WALdir , " " , " " , " " ) mc . Flags ( ) . String Var ( & migrate Transformer , " " , " " , " " ) return mc } 
func new Raft Node ( id int , peers [ ] string , join bool , get Snapshot func ( ) ( [ ] byte , error ) , propose C < - chan string , conf Change C < - chan raftpb . Conf Change ) ( < - chan * string , < - chan error , < - chan * snap . Snapshotter ) { commit C : = make ( chan * string ) error C : = make ( chan error ) rc : = & raft Node { propose C : propose C , conf Change C : conf Change C , commit C : commit C , error C : error C , id : id , peers : peers , join : join , waldir : fmt . Sprintf ( " " , id ) , snapdir : fmt . Sprintf ( " " , id ) , get Snapshot : get Snapshot , snap Count : default Snapshot Count , stopc : make ( chan struct { } ) , httpstopc : make ( chan struct { } ) , httpdonec : make ( chan struct { } ) , snapshotter Ready : make ( chan * snap . Snapshotter , 1 ) , go rc . start Raft ( ) return commit C , error C , rc . snapshotter Ready } 
func ( rc * raft Node ) publish Entries ( ents [ ] raftpb . Entry ) bool { for i : = range ents { switch ents [ i ] . Type { case raftpb . Entry Normal : if len ( ents [ i ] . Data ) = = 0 { } s : = string ( ents [ i ] . Data ) select { case rc . commit C < - & s : case < - rc . stopc : return false } case raftpb . Entry Conf Change : var cc raftpb . Conf Change cc . Unmarshal ( ents [ i ] . Data ) rc . conf State = * rc . node . Apply Conf Change ( cc ) switch cc . Type { case raftpb . Conf Change Add Node : if len ( cc . Context ) > 0 { rc . transport . Add Peer ( types . ID ( cc . Node ID ) , [ ] string { string ( cc . Context ) } ) } case raftpb . Conf Change Remove Node : if cc . Node ID = = uint 6 4 ( rc . id ) { log . Println ( " " ) return false } rc . transport . Remove Peer ( types . ID ( cc . Node ID ) ) } } } } } return true } 
func ( rc * raft Node ) open WAL ( snapshot * raftpb . Snapshot ) * wal . WAL { if ! wal . Exist ( rc . waldir ) { if err : = os . Mkdir ( rc . waldir , 0 7 5 0 ) ; err ! = nil { log . Fatalf ( " " , err ) } w , err : = wal . Create ( zap . New Example ( ) , rc . waldir , nil ) if err ! = nil { log . Fatalf ( " " , err ) } w . Close ( ) } walsnap : = walpb . Snapshot { } if snapshot ! = nil { walsnap . Index , walsnap . Term = snapshot . Metadata . Index , snapshot . Metadata . Term } log . Printf ( " " , walsnap . Term , walsnap . Index ) w , err : = wal . Open ( zap . New Example ( ) , rc . waldir , walsnap ) if err ! = nil { log . Fatalf ( " " , err ) } return w } 
func ( rc * raft Node ) replay WAL ( ) * wal . WAL { log . Printf ( " " , rc . id ) snapshot : = rc . load Snapshot ( ) w : = rc . open WAL ( snapshot ) _ , st , ents , err : = w . Read All ( ) if err ! = nil { log . Fatalf ( " " , err ) } rc . raft Storage = raft . New Memory Storage ( ) if snapshot ! = nil { rc . raft Storage . Apply Snapshot ( * snapshot ) } rc . raft Storage . Set Hard State ( st ) } else { rc . commit C < - nil } return w } 
func ( rc * raft Node ) stop ( ) { rc . stop HTTP ( ) close ( rc . commit C ) close ( rc . error C ) rc . node . Stop ( ) } 
func New Watch Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : watch Command Func , } cmd . Flags ( ) . Bool Var P ( & watch Interactive , " " , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & watch Prefix , " " , false , " " ) cmd . Flags ( ) . Int 6 4Var ( & watch Rev , " " , 0 , " " ) cmd . Flags ( ) . Bool Var ( & watch Prev Key , " " , false , " " ) return cmd } 
func watch Command Func ( cmd * cobra . Command , args [ ] string ) { env Key , env Range : = os . Getenv ( " " ) , os . Getenv ( " " ) if env Key = = " " & & env Range ! = " " { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " , env Range ) ) } if watch Interactive { watch Interactive Func ( cmd , os . Args , env Key , env Range ) return } watch Args , exec Args , err : = parse Watch Args ( os . Args , args , env Key , env Range , false ) if err ! = nil { Exit With Error ( Exit Bad Args , err ) } c : = must Client From Cmd ( cmd ) wc , err : = get Watch Chan ( c , watch Args ) if err ! = nil { Exit With Error ( Exit Bad Args , err ) } print Watch Ch ( c , wc , exec Args ) if err = c . Close ( ) ; err ! = nil { Exit With Error ( Exit Bad Connection , err ) } Exit With Error ( Exit Interrupted , fmt . Errorf ( " " ) ) } 
func parse Watch Args ( os Args , command Args [ ] string , env Key , env Range string , interactive bool ) ( watch Args [ ] string , exec Args [ ] string , err error ) { raw Args : = make ( [ ] string , len ( os Args ) ) copy ( raw Args , os Args ) watch Args = make ( [ ] string , len ( command Args ) ) copy ( watch Args , command Args ) break } } return nil , nil , err Bad Args Interactive Watch } watch Args = watch Args [ 1 : ] } exec Idx , exec Exist : = 0 , false if ! interactive { for exec Idx = range raw Args { if raw Args [ exec Idx ] = = " " { exec Exist = true break } } if exec Exist & & exec Idx = = len ( raw Args ) - 1 { } } if exec Exist & & env Key ! = " " { for ; widx > = 0 ; widx - - { if watch Args [ widx ] = = raw Args [ ridx ] { ridx - - continue } } } } } } else { for exec Idx = range watch Args { if watch Args [ exec Idx ] = = " " { exec Exist = true break } } if exec Exist & & exec Idx = = len ( watch Args ) - 1 { return nil , nil , err Bad Args Num Separator } flagset : = New Watch Command ( ) . Flags ( ) if perr : = flagset . Parse ( watch Args ) ; perr ! = nil { watch Prefix , watch Rev , watch Prev Key = false , 0 , false return nil , nil , perr } p Args : = flagset . Args ( ) return nil , nil , err Bad Args Num } return nil , nil , err Bad Args Num Conflict Env } } args With Sep : = raw Args if interactive { } idx , found Sep : = 0 , false for idx = range args With Sep { if args With Sep [ idx ] = = " " { found Sep = true break } } if found Sep { exec Args = args With Sep [ idx + 1 : ] } if interactive { flagset : = New Watch Command ( ) . Flags ( ) if perr : = flagset . Parse ( args With Sep ) ; perr ! = nil { return nil , nil , perr } watch Args = flagset . Args ( ) watch Prefix , err = flagset . Get Bool ( " " ) if err ! = nil { return nil , nil , err } watch Rev , err = flagset . Get Int 6 4 ( " " ) if err ! = nil { return nil , nil , err } watch Prev Key , err = flagset . Get Bool ( " " ) if err ! = nil { return nil , nil , err } } if env Range ! = " " { ranges = append ( ranges , env Range ) } watch Args = append ( ranges , watch Args . . . ) } if ! found Sep { return watch Args , nil , nil } for end Idx = len ( watch Args ) - 1 ; end Idx > = 0 ; end Idx - - { if watch Args [ end Idx ] = = args With Sep [ idx + 1 ] { break } } watch Args = watch Args [ : end Idx ] return watch Args , exec Args , nil } 
func ( ms * Memory Storage ) Initial State ( ) ( pb . Hard State , pb . Conf State , error ) { return ms . hard State , ms . snapshot . Metadata . Conf State , nil } 
func ( ms * Memory Storage ) Set Hard State ( st pb . Hard State ) error { ms . Lock ( ) defer ms . Unlock ( ) ms . hard State = st return nil } 
func ( ms * Memory Storage ) Entries ( lo , hi , max Size uint 6 4 ) ( [ ] pb . Entry , error ) { ms . Lock ( ) defer ms . Unlock ( ) offset : = ms . ents [ 0 ] . Index if lo < = offset { return nil , Err Compacted } if hi > ms . last Index ( ) + 1 { raft Logger . Panicf ( " " , hi , ms . last Index ( ) ) } } ents : = ms . ents [ lo - offset : hi - offset ] return limit Size ( ents , max Size ) , nil } 
func ( ms * Memory Storage ) Term ( i uint 6 4 ) ( uint 6 4 , error ) { ms . Lock ( ) defer ms . Unlock ( ) offset : = ms . ents [ 0 ] . Index if i < offset { return 0 , Err Compacted } if int ( i - offset ) > = len ( ms . ents ) { return 0 , Err Unavailable } return ms . ents [ i - offset ] . Term , nil } 
func ( ms * Memory Storage ) Last Index ( ) ( uint 6 4 , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . last Index ( ) , nil } 
func ( ms * Memory Storage ) First Index ( ) ( uint 6 4 , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . first Index ( ) , nil } 
func ( ms * Memory Storage ) Snapshot ( ) ( pb . Snapshot , error ) { ms . Lock ( ) defer ms . Unlock ( ) return ms . snapshot , nil } 
func ( ms * Memory Storage ) Apply Snapshot ( snap pb . Snapshot ) error { ms . Lock ( ) defer ms . Unlock ( ) snap Index : = snap . Metadata . Index if ms Index > = snap Index { return Err Snap Out Of Date } ms . snapshot = snap ms . ents = [ ] pb . Entry { { Term : snap . Metadata . Term , Index : snap . Metadata . Index } } return nil } 
func ( ms * Memory Storage ) Create Snapshot ( i uint 6 4 , cs * pb . Conf State , data [ ] byte ) ( pb . Snapshot , error ) { ms . Lock ( ) defer ms . Unlock ( ) if i < = ms . snapshot . Metadata . Index { return pb . Snapshot { } , Err Snap Out Of Date } offset : = ms . ents [ 0 ] . Index if i > ms . last Index ( ) { raft Logger . Panicf ( " " , i , ms . last Index ( ) ) } ms . snapshot . Metadata . Index = i ms . snapshot . Metadata . Term = ms . ents [ i - offset ] . Term if cs ! = nil { ms . snapshot . Metadata . Conf State = * cs } ms . snapshot . Data = data return ms . snapshot , nil } 
func ( ms * Memory Storage ) Compact ( compact Index uint 6 4 ) error { ms . Lock ( ) defer ms . Unlock ( ) offset : = ms . ents [ 0 ] . Index if compact Index < = offset { return Err Compacted } if compact Index > ms . last Index ( ) { raft Logger . Panicf ( " " , compact Index , ms . last Index ( ) ) } i : = compact Index - offset ents : = make ( [ ] pb . Entry , 1 , 1 + uint 6 4 ( len ( ms . ents ) ) - i ) ents [ 0 ] . Index = ms . ents [ i ] . Index ents [ 0 ] . Term = ms . ents [ i ] . Term ents = append ( ents , ms . ents [ i + 1 : ] . . . ) ms . ents = ents return nil } 
func ( ms * Memory Storage ) Append ( entries [ ] pb . Entry ) error { if len ( entries ) = = 0 { return nil } ms . Lock ( ) defer ms . Unlock ( ) first : = ms . first Index ( ) last : = entries [ 0 ] . Index + uint 6 4 ( len ( entries ) ) - 1 } } offset : = entries [ 0 ] . Index - ms . ents [ 0 ] . Index switch { case uint 6 4 ( len ( ms . ents ) ) > offset : ms . ents = append ( [ ] pb . Entry { } , ms . ents [ : offset ] . . . ) ms . ents = append ( ms . ents , entries . . . ) case uint 6 4 ( len ( ms . ents ) ) = = offset : ms . ents = append ( ms . ents , entries . . . ) default : raft Logger . Panicf ( " " , ms . last Index ( ) , entries [ 0 ] . Index ) } return nil } 
func ( p * url Picker ) unreachable ( u url . URL ) { p . mu . Lock ( ) defer p . mu . Unlock ( ) if u = = p . urls [ p . picked ] { p . picked = ( p . picked + 1 ) % len ( p . urls ) } } 
func New Endpoint Command ( ) * cobra . Command { ec : = & cobra . Command { Use : " " , Short : " " , } ec . Persistent Flags ( ) . Bool Var ( & ep Cluster Endpoints , " " , false , " " ) ec . Add Command ( new Ep Health Command ( ) ) ec . Add Command ( new Ep Status Command ( ) ) ec . Add Command ( new Ep Hash KVCommand ( ) ) return ec } 
func ep Health Command Func ( cmd * cobra . Command , args [ ] string ) { flags . Set Pflags From Env ( " " , cmd . Inherited Flags ( ) ) init Display From Cmd ( cmd ) sec : = secure Cfg From Cmd ( cmd ) dt : = dial Timeout From Cmd ( cmd ) ka : = keep Alive Time From Cmd ( cmd ) kat : = keep Alive Timeout From Cmd ( cmd ) auth : = auth Cfg From Cmd ( cmd ) cfgs : = [ ] * v 3 . Config { } for _ , ep : = range endpoints From Cluster ( cmd ) { cfg , err : = new Client Cfg ( [ ] string { ep } , dt , ka , kat , sec , auth ) if err ! = nil { Exit With Error ( Exit Bad Args , err ) } cfgs = append ( cfgs , cfg ) } var wg sync . Wait Group hch : = make ( chan ep Health , len ( cfgs ) ) for _ , cfg : = range cfgs { wg . Add ( 1 ) go func ( cfg * v 3 . Config ) { defer wg . Done ( ) ep : = cfg . Endpoints [ 0 ] cli , err : = v 3 . New ( * cfg ) if err ! = nil { hch < - ep Health { Ep : ep , Health : false , Error : err . Error ( ) } return } st : = time . Now ( ) _ , err = cli . Get ( ctx , " " ) cancel ( ) eh : = ep Health { Ep : ep , Health : false , Took : time . Since ( st ) . String ( ) } } else { eh . Error = err . Error ( ) } hch < - eh } ( cfg ) } wg . Wait ( ) close ( hch ) errs : = false health List : = [ ] ep Health { } for h : = range hch { health List = append ( health List , h ) if h . Error ! = " " { errs = true } } display . Endpoint Health ( health List ) if errs { Exit With Error ( Exit Error , fmt . Errorf ( " " ) ) } } 
func New Elect Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : elect Command Func , } cmd . Flags ( ) . Bool Var P ( & elect Listen , " " , " " , false , " " ) return cmd } 
func New Defrag Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : defrag Command Func , } cmd . Persistent Flags ( ) . Bool Var ( & ep Cluster Endpoints , " " , false , " " ) cmd . Flags ( ) . String Var ( & defrag Data Dir , " " , " " , " " ) return cmd } 
func Register Builder ( cfg Config ) { bb : = & builder { cfg } balancer . Register ( bb ) bb . cfg . Logger . Debug ( " " , zap . String ( " " , bb . cfg . Policy . String ( ) ) , zap . String ( " " , bb . cfg . Name ) , ) } 
func ( b * builder ) Build ( cc balancer . Client Conn , opt balancer . Build Options ) balancer . Balancer { bb : = & base Balancer { id : strconv . Format Int ( time . Now ( ) . Unix Nano ( ) , 3 6 ) , policy : b . cfg . Policy , name : b . cfg . Name , lg : b . cfg . Logger , addr To Sc : make ( map [ resolver . Address ] balancer . Sub Conn ) , sc To Addr : make ( map [ balancer . Sub Conn ] resolver . Address ) , sc To St : make ( map [ balancer . Sub Conn ] connectivity . State ) , current Conn : nil , cs Evltr : & connectivity State Evaluator { } , if bb . lg = = nil { bb . lg = zap . New Nop ( ) } bb . current Conn = cc bb . mu . Unlock ( ) bb . lg . Info ( " " , zap . String ( " " , bb . id ) , zap . String ( " " , bb . policy . String ( ) ) , zap . String ( " " , cc . Target ( ) ) , ) return bb } 
func ( bb * base Balancer ) Handle Resolved Addrs ( addrs [ ] resolver . Address , err error ) { if err ! = nil { bb . lg . Warn ( " " , zap . String ( " " , bb . id ) , zap . Error ( err ) ) return } bb . lg . Info ( " " , zap . String ( " " , bb . id ) , zap . Strings ( " " , addrs To Strings ( addrs ) ) ) bb . mu . Lock ( ) defer bb . mu . Unlock ( ) resolved : = make ( map [ resolver . Address ] struct { } ) for _ , addr : = range addrs { resolved [ addr ] = struct { } { } if _ , ok : = bb . addr To Sc [ addr ] ; ! ok { sc , err : = bb . current Conn . New Sub Conn ( [ ] resolver . Address { addr } , balancer . New Sub Conn Options { } ) if err ! = nil { bb . lg . Warn ( " " , zap . String ( " " , bb . id ) , zap . Error ( err ) , zap . String ( " " , addr . Addr ) ) continue } bb . addr To Sc [ addr ] = sc bb . sc To Addr [ sc ] = addr bb . sc To St [ sc ] = connectivity . Idle sc . Connect ( ) } } for addr , sc : = range bb . addr To Sc { if _ , ok : = resolved [ addr ] ; ! ok { delete ( bb . addr To Sc , addr ) bb . lg . Info ( " " , zap . String ( " " , bb . id ) , zap . String ( " " , addr . Addr ) , zap . String ( " " , sc To String ( sc ) ) , ) } } 
func ( bb * base Balancer ) Handle Sub Conn State Change ( sc balancer . Sub Conn , s connectivity . State ) { bb . mu . Lock ( ) defer bb . mu . Unlock ( ) old , ok : = bb . sc To St [ sc ] if ! ok { bb . lg . Warn ( " " , zap . String ( " " , bb . id ) , zap . String ( " " , sc To String ( sc ) ) , zap . String ( " " , s . String ( ) ) , ) return } bb . lg . Info ( " " , zap . String ( " " , bb . id ) , zap . Bool ( " " , s = = connectivity . Ready ) , zap . String ( " " , sc To String ( sc ) ) , zap . String ( " " , bb . sc To Addr [ sc ] . Addr ) , zap . String ( " " , old . String ( ) ) , zap . String ( " " , s . String ( ) ) , ) bb . sc To St [ sc ] = s switch s { case connectivity . Idle : sc . Connect ( ) case connectivity . Shutdown : delete ( bb . sc To St , sc ) } old Aggr State : = bb . current State bb . current State = bb . cs Evltr . record Transition ( old , s ) } bb . current Conn . Update Balancer State ( bb . current State , bb . Picker ) return } 
func ( cse * connectivity State Evaluator ) record Transition ( old State , new State connectivity . State ) connectivity . State { switch state { case connectivity . Ready : cse . num Ready + = update Val case connectivity . Connecting : cse . num Connecting + = update Val case connectivity . Transient Failure : cse . num Transient Failure + = update Val } } } if cse . num Connecting > 0 { return connectivity . Connecting } return connectivity . Transient Failure } 
func ( s * Etcd Server ) do Serialize ( ctx context . Context , chk func ( * auth . Auth Info ) error , get func ( ) ) error { ai , err : = s . Auth Info From Ctx ( ctx ) if err ! = nil { return err } if ai = = nil { } if err = chk ( ai ) ; err ! = nil { return err } } return nil } 
func ( w * watcher ) send ( wr clientv 3 . Watch Response ) { if wr . Is Progress Notify ( ) & & ! w . progress { return } if w . nextrev > wr . Header . Revision & & len ( wr . Events ) > 0 { return } if w . nextrev = = 0 { } events : = make ( [ ] * mvccpb . Event , 0 , len ( wr . Events ) ) var last Rev int 6 4 for i : = range wr . Events { ev : = ( * mvccpb . Event ) ( wr . Events [ i ] ) if ev . Kv . Mod Revision < w . nextrev { continue } else { } filtered : = false for _ , filter : = range w . filters { if filter ( * ev ) { filtered = true break } } if filtered { continue } if ! w . prev KV { ev Copy : = * ev ev Copy . Prev Kv = nil ev = & ev Copy } events = append ( events , ev ) } if last Rev > = w . nextrev { w . nextrev = last Rev + 1 } } w . last Header = wr . Header w . post ( & pb . Watch Response { Header : & wr . Header , Created : wr . Created , Compact Revision : wr . Compact Revision , Canceled : wr . Canceled , Watch Id : w . id , Events : events , } ) } 
func ( w * watcher ) post ( wr * pb . Watch Response ) bool { select { case w . wps . watch Ch < - wr : case < - time . After ( 5 0 * time . Millisecond ) : w . wps . cancel ( ) return false } return true } 
func ( ac * Access Controller ) Origin Allowed ( origin string ) bool { ac . cors Mu . RLock ( ) defer ac . cors Mu . RUnlock ( ) if len ( ac . CORS ) = = 0 { } _ , ok : = ac . CORS [ " " ] if ok { return true } _ , ok = ac . CORS [ origin ] return ok } 
func ( ac * Access Controller ) Is Host Whitelisted ( host string ) bool { ac . host Whitelist Mu . RLock ( ) defer ac . host Whitelist Mu . RUnlock ( ) if len ( ac . Host Whitelist ) = = 0 { } _ , ok : = ac . Host Whitelist [ " " ] if ok { return true } _ , ok = ac . Host Whitelist [ host ] return ok } 
func ( ss * Selective String Value ) Set ( s string ) error { if _ , ok : = ss . valids [ s ] ; ok { ss . v = s return nil } return errors . New ( " " ) } 
func ( ss * Selective String Value ) Valids ( ) [ ] string { s : = make ( [ ] string , 0 , len ( ss . valids ) ) for k : = range ss . valids { s = append ( s , k ) } sort . Strings ( s ) return s } 
func New Selective String Value ( valids . . . string ) * Selective String Value { vm : = make ( map [ string ] struct { } ) for _ , v : = range valids { vm [ v ] = struct { } { } } return & Selective String Value { valids : vm , v : valids [ 0 ] } } 
func ( ss * Selective Strings Value ) Set ( s string ) error { vs : = strings . Split ( s , " " ) for i : = range vs { if _ , ok : = ss . valids [ vs [ i ] ] ; ok { ss . vs = append ( ss . vs , vs [ i ] ) } else { return fmt . Errorf ( " " , vs [ i ] ) } } sort . Strings ( ss . vs ) return nil } 
func New Selective Strings Value ( valids . . . string ) * Selective Strings Value { vm : = make ( map [ string ] struct { } ) for _ , v : = range valids { vm [ v ] = struct { } { } } return & Selective Strings Value { valids : vm , vs : [ ] string { } } } 
func New KV ( kv clientv 3 . KV , prefix string ) clientv 3 . KV { return & kv Prefix { kv , prefix } } 
func New Timeout Transport ( info TLSInfo , dialtimeoutd , rdtimeoutd , wtimeoutd time . Duration ) ( * http . Transport , error ) { tr , err : = New Transport ( info , dialtimeoutd ) if err ! = nil { return nil , err } if rdtimeoutd ! = 0 | | wtimeoutd ! = 0 { } else { } tr . Dial = ( & rw Timeout Dialer { Dialer : net . Dialer { Timeout : dialtimeoutd , Keep Alive : 3 0 * time . Second , } , rdtimeoutd : rdtimeoutd , wtimeoutd : wtimeoutd , } ) . Dial return tr , nil } 
func ( us * URLs Value ) Set ( s string ) error { ss , err : = types . New URLs ( strings . Split ( s , " " ) ) if err ! = nil { return err } * us = URLs Value ( ss ) return nil } 
func ( us * URLs Value ) String ( ) string { all : = make ( [ ] string , len ( * us ) ) for i , u : = range * us { all [ i ] = u . String ( ) } return strings . Join ( all , " " ) } 
func New URLs Value ( s string ) * URLs Value { if s = = " " { return & URLs Value { } } v : = & URLs Value { } if err : = v . Set ( s ) ; err ! = nil { plog . Panicf ( " " , err ) } return v } 
func URLs From Flag ( fs * flag . Flag Set , urls Flag Name string ) [ ] url . URL { return [ ] url . URL ( * fs . Lookup ( urls Flag Name ) . Value . ( * URLs Value ) ) } 
func Start Etcd ( in Cfg * Config ) ( e * Etcd , err error ) { if err = in Cfg . Validate ( ) ; err ! = nil { return nil , err } serving : = false e = & Etcd { cfg : * in Cfg , stopc : make ( chan struct { } ) } cfg : = & e . cfg defer func ( ) { if e = = nil | | err = = nil { return } if ! serving { } } e . Close ( ) e = nil } ( ) if e . cfg . logger ! = nil { e . cfg . logger . Info ( " " , zap . Strings ( " " , e . cfg . get LPURLs ( ) ) , ) } if e . Peers , err = configure Peer Listeners ( cfg ) ; err ! = nil { return e , err } if e . cfg . logger ! = nil { e . cfg . logger . Info ( " " , zap . Strings ( " " , e . cfg . get LCURLs ( ) ) , ) } if e . sctxs , err = configure Client Listeners ( cfg ) ; err ! = nil { return e , err } for _ , sctx : = range e . sctxs { e . Clients = append ( e . Clients , sctx . l ) } var ( urlsmap types . URLs Map token string ) member Initialized : = true if ! is Member Initialized ( cfg ) { member Initialized = false urlsmap , token , err = cfg . Peer URLs Map And Token ( " " ) if err ! = nil { return e , fmt . Errorf ( " " , err ) } } } auto Compaction Retention , err : = parse Compaction Retention ( cfg . Auto Compaction Mode , cfg . Auto Compaction Retention ) if err ! = nil { return e , err } backend Freelist Type : = parse Backend Freelist Type ( cfg . Experimental Backend Freelist Type ) srvcfg : = etcdserver . Server Config { Name : cfg . Name , Client URLs : cfg . ACUrls , Peer URLs : cfg . APUrls , Data Dir : cfg . Dir , Dedicated WALDir : cfg . Wal Dir , Snapshot Count : cfg . Snapshot Count , Snapshot Catch Up Entries : cfg . Snapshot Catch Up Entries , Max Snap Files : cfg . Max Snap Files , Max WALFiles : cfg . Max Wal Files , Initial Peer URLs Map : urlsmap , Initial Cluster Token : token , Discovery URL : cfg . Durl , Discovery Proxy : cfg . Dproxy , New Cluster : cfg . Is New Cluster ( ) , Peer TLSInfo : cfg . Peer TLSInfo , Tick Ms : cfg . Tick Ms , Election Ticks : cfg . Election Ticks ( ) , Initial Election Tick Advance : cfg . Initial Election Tick Advance , Auto Compaction Retention : auto Compaction Retention , Auto Compaction Mode : cfg . Auto Compaction Mode , Quota Backend Bytes : cfg . Quota Backend Bytes , Backend Batch Limit : cfg . Backend Batch Limit , Backend Freelist Type : backend Freelist Type , Backend Batch Interval : cfg . Backend Batch Interval , Max Txn Ops : cfg . Max Txn Ops , Max Request Bytes : cfg . Max Request Bytes , Strict Reconfig Check : cfg . Strict Reconfig Check , Client Cert Auth Enabled : cfg . Client TLSInfo . Client Cert Auth , Auth Token : cfg . Auth Token , Bcrypt Cost : cfg . Bcrypt Cost , CORS : cfg . CORS , Host Whitelist : cfg . Host Whitelist , Initial Corrupt Check : cfg . Experimental Initial Corrupt Check , Corrupt Check Time : cfg . Experimental Corrupt Check Time , Pre Vote : cfg . Pre Vote , Logger : cfg . logger , Logger Config : cfg . logger Config , Logger Core : cfg . logger Core , Logger Write Syncer : cfg . logger Write Syncer , Debug : cfg . Debug , Force New Cluster : cfg . Force New Cluster , Enable GRPCGateway : cfg . Enable GRPCGateway , } print ( e . cfg . logger , * cfg , srvcfg , member Initialized ) if e . Server , err = etcdserver . New Server ( srvcfg ) ; err ! = nil { return e , err } return e , err } } e . Server . Start ( ) if err = e . serve Peers ( ) ; err ! = nil { return e , err } if err = e . serve Clients ( ) ; err ! = nil { return e , err } if err = e . serve Metrics ( ) ; err ! = nil { return e , err } if e . cfg . logger ! = nil { e . cfg . logger . Info ( " " , zap . String ( " " , e . Server . ID ( ) . String ( ) ) , zap . Strings ( " " , e . cfg . get APURLs ( ) ) , zap . Strings ( " " , e . cfg . get LPURLs ( ) ) , zap . Strings ( " " , e . cfg . get ACURLs ( ) ) , zap . Strings ( " " , e . cfg . get LCURLs ( ) ) , zap . Strings ( " " , e . cfg . get Metrics URLs ( ) ) , ) } serving = true return e , nil } 
func ( e * Etcd ) Close ( ) { fields : = [ ] zap . Field { zap . String ( " " , e . cfg . Name ) , zap . String ( " " , e . cfg . Dir ) , zap . Strings ( " " , e . cfg . get APURLs ( ) ) , zap . Strings ( " " , e . cfg . get ACURLs ( ) ) , } lg : = e . Get Logger ( ) if lg ! = nil { lg . Info ( " " , fields . . . ) } defer func ( ) { if lg ! = nil { lg . Info ( " " , fields . . . ) lg . Sync ( ) } } ( ) e . close Once . Do ( func ( ) { close ( e . stopc ) } ) if e . Server ! = nil { timeout = e . Server . Cfg . Req Timeout ( ) } for _ , sctx : = range e . sctxs { for ss : = range sctx . servers C { ctx , cancel : = context . With Timeout ( context . Background ( ) , timeout ) stop Servers ( ctx , ss ) cancel ( ) } } for _ , sctx : = range e . sctxs { sctx . cancel ( ) } for i : = range e . Clients { if e . Clients [ i ] ! = nil { e . Clients [ i ] . Close ( ) } } for i : = range e . metrics Listeners { e . metrics Listeners [ i ] . Close ( ) } } e . Peers [ i ] . close ( ctx ) cancel ( ) } } } 
func ( e * Etcd ) serve Peers ( ) ( err error ) { ph : = etcdhttp . New Peer Handler ( e . Get Logger ( ) , e . Server ) var peer TLScfg * tls . Config if ! e . cfg . Peer TLSInfo . Empty ( ) { if peer TLScfg , err = e . cfg . Peer TLSInfo . Server Config ( ) ; err ! = nil { return err } } for _ , p : = range e . Peers { u : = p . Listener . Addr ( ) . String ( ) gs : = v 3rpc . Server ( e . Server , peer TLScfg ) m : = cmux . New ( p . Listener ) go gs . Serve ( m . Match ( cmux . HTTP 2 ( ) ) ) srv : = & http . Server { Handler : grpc Handler Func ( gs , ph ) , Read Timeout : 5 * time . Minute , Error Log : default Log . New ( ioutil . Discard , " " , 0 ) , go srv . Serve ( m . Match ( cmux . Any ( ) ) ) p . serve = func ( ) error { return m . Serve ( ) } p . close = func ( ctx context . Context ) error { } stop Servers ( ctx , & servers { secure : peer TLScfg ! = nil , grpc : gs , http : srv } ) if e . cfg . logger ! = nil { e . cfg . logger . Info ( " " , zap . String ( " " , u ) , ) } return nil } } if e . cfg . logger ! = nil { e . cfg . logger . Info ( " " , zap . String ( " " , u ) , ) } else { plog . Info ( " " , u ) } e . err Handler ( l . serve ( ) ) } ( pl ) } return nil } 
func ( e * Etcd ) Get Logger ( ) * zap . Logger { e . cfg . logger Mu . RLock ( ) l : = e . cfg . logger e . cfg . logger Mu . RUnlock ( ) return l } 
func New Store ( lg * zap . Logger , b backend . Backend , le lease . Lessor , ig Consistent Index Getter ) * store { s : = & store { b : b , ig : ig , kvindex : new Tree Index ( lg ) , le : le , current Rev : 1 , compact Main Rev : - 1 , bytes Buf 8 : make ( [ ] byte , 8 ) , fifo Sched : schedule . New FIFOScheduler ( ) , stopc : make ( chan struct { } ) , lg : lg , } s . Read View = & read View { s } s . Write View = & write View { s } if s . le ! = nil { s . le . Set Range Deleter ( func ( ) lease . Txn Delete { return s . Write ( ) } ) } tx : = s . b . Batch Tx ( ) tx . Lock ( ) tx . Unsafe Create Bucket ( key Bucket Name ) tx . Unsafe Create Bucket ( meta Bucket Name ) tx . Unlock ( ) s . b . Force Commit ( ) s . mu . Lock ( ) defer s . mu . Unlock ( ) if err : = s . restore ( ) ; err ! = nil { } return s } 
func append Mark Tombstone ( lg * zap . Logger , b [ ] byte ) [ ] byte { if len ( b ) ! = rev Bytes Len { if lg ! = nil { lg . Panic ( " " , zap . Int ( " " , rev Bytes Len ) , zap . Int ( " " , len ( b ) ) , ) } else { plog . Panicf ( " " ) } } return append ( b , mark Tombstone ) } 
func Is Dir Writeable ( dir string ) error { f : = filepath . Join ( dir , " " ) if err : = ioutil . Write File ( f , [ ] byte ( " " ) , Private File Mode ) ; err ! = nil { return err } return os . Remove ( f ) } 
func Touch Dir All ( dir string ) error { if err ! = nil { } return Is Dir Writeable ( dir ) } 
func Create Dir All ( dir string ) error { err : = Touch Dir All ( dir ) if err = = nil { var ns [ ] string ns , err = Read Dir ( dir ) if err ! = nil { return err } if len ( ns ) ! = 0 { err = fmt . Errorf ( " " , dir , ns ) } } return err } 
func Zero To End ( f * os . File ) error { if err ! = nil { return err } lenf , lerr : = f . Seek ( 0 , io . Seek End ) if lerr ! = nil { return lerr } if err = f . Truncate ( off ) ; err ! = nil { return err } } _ , err = f . Seek ( off , io . Seek Start ) return err } 
func ( fp * file Pipeline ) Open ( ) ( f * fileutil . Locked File , err error ) { select { case f = < - fp . filec : case err = < - fp . errc : } return f , err } 
func New Raft Logger ( lcfg * zap . Config ) ( raft . Logger , error ) { if lcfg = = nil { return nil , errors . New ( " " ) } lg , err : = lcfg . Build ( zap . Add Caller Skip ( 1 ) ) if err ! = nil { return nil , err } return & zap Raft Logger { lg : lg , sugar : lg . Sugar ( ) } , nil } 
func New Raft Logger From Zap Core ( cr zapcore . Core , syncer zapcore . Write Syncer ) raft . Logger { return & zap Raft Logger { lg : lg , sugar : lg . Sugar ( ) } } 
func New Config ( fpath string ) ( * clientv 3 . Config , error ) { b , err : = ioutil . Read File ( fpath ) if err ! = nil { return nil , err } yc : = & yaml Config { } err = yaml . Unmarshal ( b , yc ) if err ! = nil { return nil , err } if yc . Insecure Transport { return & yc . Config , nil } var ( cert * tls . Certificate cp * x 5 0 9 . Cert Pool ) if yc . Certfile ! = " " & & yc . Keyfile ! = " " { cert , err = tlsutil . New Cert ( yc . Certfile , yc . Keyfile , nil ) if err ! = nil { return nil , err } } if yc . Trusted CAfile ! = " " { cp , err = tlsutil . New Cert Pool ( [ ] string { yc . Trusted CAfile } ) if err ! = nil { return nil , err } } tlscfg : = & tls . Config { Min Version : tls . Version TLS 1 2 , Insecure Skip Verify : yc . Insecure Skip TLSVerify , Root CAs : cp , } if cert ! = nil { tlscfg . Certificates = [ ] tls . Certificate { * cert } } yc . Config . TLS = tlscfg return & yc . Config , nil } 
func Register Election Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Election Handler Client ( ctx , mux , v 3electionpb . New Election Client ( conn ) ) } 
func Register Election Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client v 3electionpb . Election Client ) error { mux . Handle ( " " , pattern _Election _Campaign _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Election _Campaign _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Election _Campaign _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Election _Proclaim _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Election _Proclaim _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Election _Proclaim _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Election _Leader _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Election _Leader _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Election _Leader _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Election _Observe _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Election _Observe _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Election _Observe _ 0 ( ctx , mux , outbound Marshaler , w , req , func ( ) ( proto . Message , error ) { return resp . Recv ( ) } , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Election _Resign _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Election _Resign _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Election _Resign _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Update Capability ( lg * zap . Logger , v * semver . Version ) { if v = = nil { } enable Map Mu . Lock ( ) if cur Version ! = nil & & ! cur Version . Less Than ( * v ) { enable Map Mu . Unlock ( ) return } cur Version = v enabled Map = capability Maps [ cur Version . String ( ) ] enable Map Mu . Unlock ( ) if lg ! = nil { lg . Info ( " " , zap . String ( " " , version . Cluster ( v . String ( ) ) ) , ) } else { plog . Infof ( " " , version . Cluster ( v . String ( ) ) ) } } 
func New Lock Command ( ) * cobra . Command { c : = & cobra . Command { Use : " " , Short : " " , Run : lock Command Func , } c . Flags ( ) . Int Var P ( & lock TTL , " " , " " , lock TTL , " " ) return c } 
func ( r * raft Node ) tick ( ) { r . tick Mu . Lock ( ) r . Tick ( ) r . tick Mu . Unlock ( ) } 
func ( r * raft Node ) start ( rh * raft Ready Handler ) { internal Timeout : = time . Second go func ( ) { defer r . on Stop ( ) islead : = false for { select { case < - r . ticker . C : r . tick ( ) case rd : = < - r . Ready ( ) : if rd . Soft State ! = nil { new Leader : = rd . Soft State . Lead ! = raft . None & & rh . get Lead ( ) ! = rd . Soft State . Lead if new Leader { leader Changes . Inc ( ) } if rd . Soft State . Lead = = raft . None { has Leader . Set ( 0 ) } else { has Leader . Set ( 1 ) } rh . update Lead ( rd . Soft State . Lead ) islead = rd . Raft State = = raft . State Leader if islead { is Leader . Set ( 1 ) } else { is Leader . Set ( 0 ) } rh . update Leadership ( new Leader ) r . td . Reset ( ) } if len ( rd . Read States ) ! = 0 { select { case r . read State C < - rd . Read States [ len ( rd . Read States ) - 1 ] : case < - time . After ( internal Timeout ) : if r . lg ! = nil { r . lg . Warn ( " " , zap . Duration ( " " , internal Timeout ) ) } else { plog . Warningf ( " " ) } case < - r . stopped : return } } notifyc : = make ( chan struct { } , 1 ) ap : = apply { entries : rd . Committed Entries , snapshot : rd . Snapshot , notifyc : notifyc , } update Committed Index ( & ap , rh ) select { case r . applyc < - ap : case < - r . stopped : return } } } else { plog . Fatalf ( " " , err ) } } if ! raft . Is Empty Hard State ( rd . Hard State ) { proposals Committed . Set ( float 6 4 ( rd . Hard State . Commit ) ) } } else { plog . Fatalf ( " " , err ) } } if r . lg ! = nil { r . lg . Info ( " " , zap . Uint 6 4 ( " " , rd . Snapshot . Metadata . Index ) ) } else { plog . Infof ( " " , rd . Snapshot . Metadata . Index ) } r . raft Storage . Append ( rd . Entries ) if ! islead { for _ , ent : = range rd . Committed Entries { if ent . Type = = raftpb . Entry Conf Change { wait Apply = true break } } if wait Apply { } } } else { } r . Advance ( ) case < - r . stopped : return } } } ( ) } 
func ( r * raft Node ) pause Sending ( ) { p : = r . transport . ( rafthttp . Pausable ) p . Pause ( ) } 
func ( r * raft Node ) advance Ticks ( ticks int ) { for i : = 0 ; i < ticks ; i + + { r . tick ( ) } } 
func get IDs ( lg * zap . Logger , snap * raftpb . Snapshot , ents [ ] raftpb . Entry ) [ ] uint 6 4 { ids : = make ( map [ uint 6 4 ] bool ) if snap ! = nil { for _ , id : = range snap . Metadata . Conf State . Nodes { ids [ id ] = true } } for _ , e : = range ents { if e . Type ! = raftpb . Entry Conf Change { continue } var cc raftpb . Conf Change pbutil . Must Unmarshal ( & cc , e . Data ) switch cc . Type { case raftpb . Conf Change Add Node : ids [ cc . Node ID ] = true case raftpb . Conf Change Remove Node : delete ( ids , cc . Node ID ) case raftpb . Conf Change Update Node : } else { plog . Panicf ( " " ) } } } sids : = make ( types . Uint 6 4Slice , 0 , len ( ids ) ) for id : = range ids { sids = append ( sids , id ) } sort . Sort ( sids ) return [ ] uint 6 4 ( sids ) } 
func create Config Change Ents ( lg * zap . Logger , ids [ ] uint 6 4 , self uint 6 4 , term , index uint 6 4 ) [ ] raftpb . Entry { ents : = make ( [ ] raftpb . Entry , 0 ) next : = index + 1 found : = false for _ , id : = range ids { if id = = self { found = true continue } cc : = & raftpb . Conf Change { Type : raftpb . Conf Change Remove Node , Node ID : id , } e : = raftpb . Entry { Type : raftpb . Entry Conf Change , Data : pbutil . Must Marshal ( cc ) , Term : term , Index : next , } ents = append ( ents , e ) next + + } if ! found { m : = membership . Member { ID : types . ID ( self ) , Raft Attributes : membership . Raft Attributes { Peer URLs : [ ] string { " " } } , } ctx , err : = json . Marshal ( m ) if err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } cc : = & raftpb . Conf Change { Type : raftpb . Conf Change Add Node , Node ID : self , Context : ctx , } e : = raftpb . Entry { Type : raftpb . Entry Conf Change , Data : pbutil . Must Marshal ( cc ) , Term : term , Index : next , } ents = append ( ents , e ) } return ents } 
func New Auth Command ( ) * cobra . Command { ac : = & cobra . Command { Use : " " , Short : " " , } ac . Add Command ( new Auth Enable Command ( ) ) ac . Add Command ( new Auth Disable Command ( ) ) return ac } 
func auth Enable Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } ctx , cancel : = command Ctx ( cmd ) cli : = must Client From Cmd ( cmd ) var err error for err = = nil { if _ , err = cli . Auth Enable ( ctx ) ; err = = nil { break } if err = = rpctypes . Err Root Role Not Exist { if _ , err = cli . Role Add ( ctx , " " ) ; err ! = nil { break } if _ , err = cli . User Grant Role ( ctx , " " , " " ) ; err ! = nil { break } } } cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } fmt . Println ( " " ) } 
func auth Disable Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } ctx , cancel : = command Ctx ( cmd ) _ , err : = must Client From Cmd ( cmd ) . Auth . Auth Disable ( ctx ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } fmt . Println ( " " ) } 
func is Safe Retry Immutable RPC ( err error ) bool { e Err : = rpctypes . Error ( err ) if server Err , ok : = e Err . ( rpctypes . Etcd Error ) ; ok & & server Err . Code ( ) ! = codes . Unavailable { } if ! ok { } return ev . Code ( ) = = codes . Unavailable } 
func is Safe Retry Mutable RPC ( err error ) bool { if ev , ok : = status . From Error ( err ) ; ok & & ev . Code ( ) ! = codes . Unavailable { } desc : = rpctypes . Error Desc ( err ) return desc = = " " | | desc = = " " } 
func Retry KVClient ( c * Client ) pb . KVClient { return & retry KVClient { kc : pb . New KVClient ( c . conn ) , } } 
func Retry Lease Client ( c * Client ) pb . Lease Client { return & retry Lease Client { lc : pb . New Lease Client ( c . conn ) , } } 
func Retry Cluster Client ( c * Client ) pb . Cluster Client { return & retry Cluster Client { cc : pb . New Cluster Client ( c . conn ) , } } 
func Retry Maintenance Client ( c * Client , conn * grpc . Client Conn ) pb . Maintenance Client { return & retry Maintenance Client { mc : pb . New Maintenance Client ( conn ) , } } 
func Retry Auth Client ( c * Client ) pb . Auth Client { return & retry Auth Client { ac : pb . New Auth Client ( c . conn ) , } } 
func New Set Dir Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , } , Action : func ( c * cli . Context ) error { mkdir Command Func ( c , must New Key API ( c ) , client . Prev Ignore ) return nil } , } } 
func ( b * Double Barrier ) Enter ( ) error { client : = b . s . Client ( ) ek , err : = new Unique Ephemeral Key ( b . s , b . key + " " ) if err ! = nil { return err } b . my Key = ek resp , err : = client . Get ( b . ctx , b . key + " " , clientv 3 . With Prefix ( ) ) if err ! = nil { return err } if len ( resp . Kvs ) > b . count { return Err Too Many Clients } if len ( resp . Kvs ) = = b . count { return err } _ , err = Wait Events ( client , b . key + " " , ek . Revision ( ) , [ ] mvccpb . Event _Event Type { mvccpb . PUT } ) return err } 
func ( b * Double Barrier ) Leave ( ) error { client : = b . s . Client ( ) resp , err : = client . Get ( b . ctx , b . key + " " , clientv 3 . With Prefix ( ) ) if err ! = nil { return err } if len ( resp . Kvs ) = = 0 { return nil } lowest , highest : = resp . Kvs [ 0 ] , resp . Kvs [ 0 ] for _ , k : = range resp . Kvs { if k . Mod Revision < lowest . Mod Revision { lowest = k } if k . Mod Revision > highest . Mod Revision { highest = k } } is Lowest : = string ( lowest . Key ) = = b . my Key . Key ( ) if len ( resp . Kvs ) = = 1 { } return b . my Key . Delete ( ) } if err ! = nil { return err } return b . Leave ( ) } } key : = string ( lowest . Key ) _ , err = Wait Events ( client , key , lowest . Mod Revision , [ ] mvccpb . Event _Event Type { mvccpb . DELETE } ) if err ! = nil { return err } return b . Leave ( ) } 
func Handle Basic ( mux * http . Serve Mux , server etcdserver . Server Peer ) { mux . Handle Func ( vars Path , serve Vars ) Handle Metrics Health ( mux , server ) mux . Handle Func ( version Path , version Handler ( server . Cluster ( ) , serve Version ) ) } 
func log Handle Func ( w http . Response Writer , r * http . Request ) { if ! allow Method ( w , r , " " ) { return } in : = struct { Level string } { } d : = json . New Decoder ( r . Body ) if err : = d . Decode ( & in ) ; err ! = nil { Write Error ( nil , w , r , httptypes . New HTTPError ( http . Status Bad Request , " " ) ) return } logl , err : = capnslog . Parse Level ( strings . To Upper ( in . Level ) ) if err ! = nil { Write Error ( nil , w , r , httptypes . New HTTPError ( http . Status Bad Request , " " + in . Level ) ) return } plog . Noticef ( " " , logl . String ( ) ) capnslog . Set Global Log Level ( logl ) w . Write Header ( http . Status No Content ) } 
func Write Error ( lg * zap . Logger , w http . Response Writer , r * http . Request , err error ) { if err = = nil { return } switch e : = err . ( type ) { case * v 2error . Error : e . Write To ( w ) case * httptypes . HTTPError : if et : = e . Write To ( w ) ; et ! = nil { if lg ! = nil { lg . Debug ( " " , zap . String ( " " , r . Remote Addr ) , zap . String ( " " , e . Error ( ) ) , zap . Error ( et ) , ) } else { plog . Debugf ( " " , et , r . Remote Addr ) } } default : switch err { case etcdserver . Err Timeout Due To Leader Fail , etcdserver . Err Timeout Due To Connection Lost , etcdserver . Err Not Enough Started Members , etcdserver . Err Unhealthy : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , r . Remote Addr ) , zap . String ( " " , err . Error ( ) ) , ) } else { mlog . Merge Error ( err ) } default : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , r . Remote Addr ) , zap . String ( " " , err . Error ( ) ) , ) } else { mlog . Merge Errorf ( " " , err ) } } herr : = httptypes . New HTTPError ( http . Status Internal Server Error , " " ) if et : = herr . Write To ( w ) ; et ! = nil { if lg ! = nil { lg . Debug ( " " , zap . String ( " " , r . Remote Addr ) , zap . String ( " " , err . Error ( ) ) , zap . Error ( et ) , ) } else { plog . Debugf ( " " , et , r . Remote Addr ) } } } } 
func ( c * Raft Cluster ) Member By Name ( name string ) * Member { c . Lock ( ) defer c . Unlock ( ) var memb * Member for _ , m : = range c . members { if m . Name = = name { if memb ! = nil { if c . lg ! = nil { c . lg . Panic ( " " , zap . String ( " " , name ) ) } else { plog . Panicf ( " " , name ) } } memb = m } } return memb . Clone ( ) } 
func ( c * Raft Cluster ) Peer URLs ( ) [ ] string { c . Lock ( ) defer c . Unlock ( ) urls : = make ( [ ] string , 0 ) for _ , p : = range c . members { urls = append ( urls , p . Peer URLs . . . ) } sort . Strings ( urls ) return urls } 
func ( c * Raft Cluster ) Validate Configuration Change ( cc raftpb . Conf Change ) error { members , removed : = members From Store ( c . lg , c . v 2store ) id : = types . ID ( cc . Node ID ) if removed [ id ] { return Err IDRemoved } switch cc . Type { case raftpb . Conf Change Add Node : if members [ id ] ! = nil { return Err IDExists } urls : = make ( map [ string ] bool ) for _ , m : = range members { for _ , u : = range m . Peer URLs { urls [ u ] = true } } m : = new ( Member ) if err : = json . Unmarshal ( cc . Context , m ) ; err ! = nil { if c . lg ! = nil { c . lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } for _ , u : = range m . Peer URLs { if urls [ u ] { return Err Peer URLexists } } case raftpb . Conf Change Remove Node : if members [ id ] = = nil { return Err IDNot Found } case raftpb . Conf Change Update Node : if members [ id ] = = nil { return Err IDNot Found } urls : = make ( map [ string ] bool ) for _ , m : = range members { if m . ID = = id { continue } for _ , u : = range m . Peer URLs { urls [ u ] = true } } m : = new ( Member ) if err : = json . Unmarshal ( cc . Context , m ) ; err ! = nil { if c . lg ! = nil { c . lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } for _ , u : = range m . Peer URLs { if urls [ u ] { return Err Peer URLexists } } default : if c . lg ! = nil { c . lg . Panic ( " " , zap . String ( " " , cc . Type . String ( ) ) ) } else { plog . Panicf ( " " ) } } return nil } 
func ( c * Raft Cluster ) Add Member ( m * Member ) { c . Lock ( ) defer c . Unlock ( ) if c . v 2store ! = nil { must Save Member To Store ( c . v 2store , m ) } if c . be ! = nil { must Save Member To Backend ( c . be , m ) } c . members [ m . ID ] = m if c . lg ! = nil { c . lg . Info ( " " , zap . String ( " " , c . cid . String ( ) ) , zap . String ( " " , c . local ID . String ( ) ) , zap . String ( " " , m . ID . String ( ) ) , zap . Strings ( " " , m . Peer URLs ) , ) } else { plog . Infof ( " " , m . ID , m . Peer URLs , c . cid ) } } 
func ( c * Raft Cluster ) Remove Member ( id types . ID ) { c . Lock ( ) defer c . Unlock ( ) if c . v 2store ! = nil { must Delete Member From Store ( c . v 2store , id ) } if c . be ! = nil { must Delete Member From Backend ( c . be , id ) } m , ok : = c . members [ id ] delete ( c . members , id ) c . removed [ id ] = true if c . lg ! = nil { if ok { c . lg . Info ( " " , zap . String ( " " , c . cid . String ( ) ) , zap . String ( " " , c . local ID . String ( ) ) , zap . String ( " " , id . String ( ) ) , zap . Strings ( " " , m . Peer URLs ) , ) } else { c . lg . Warn ( " " , zap . String ( " " , c . cid . String ( ) ) , zap . String ( " " , c . local ID . String ( ) ) , zap . String ( " " , id . String ( ) ) , ) } } else { plog . Infof ( " " , id , c . cid ) } } 
func Validate Cluster And Assign IDs ( lg * zap . Logger , local * Raft Cluster , existing * Raft Cluster ) error { ems : = existing . Members ( ) lms : = local . Members ( ) if len ( ems ) ! = len ( lms ) { return fmt . Errorf ( " " ) } sort . Sort ( Members By Peer URLs ( ems ) ) sort . Sort ( Members By Peer URLs ( lms ) ) ctx , cancel : = context . With Timeout ( context . TODO ( ) , 3 0 * time . Second ) defer cancel ( ) for i : = range ems { if ok , err : = netutil . URLStrings Equal ( ctx , lg , ems [ i ] . Peer URLs , lms [ i ] . Peer URLs ) ; ! ok { return fmt . Errorf ( " " , err ) } lms [ i ] . ID = ems [ i ] . ID } local . members = make ( map [ types . ID ] * Member ) for _ , m : = range lms { local . members [ m . ID ] = m } return nil } 
func ( ti * tree Index ) Range Since ( key , end [ ] byte , rev int 6 4 ) [ ] revision { keyi : = & key Index { key : key } ti . RLock ( ) defer ti . RUnlock ( ) if end = = nil { item : = ti . tree . Get ( keyi ) if item = = nil { return nil } keyi = item . ( * key Index ) return keyi . since ( ti . lg , rev ) } endi : = & key Index { key : end } var revs [ ] revision ti . tree . Ascend Greater Or Equal ( keyi , func ( item btree . Item ) bool { if len ( endi . key ) > 0 & & ! item . Less ( endi ) { return false } cur Keyi : = item . ( * key Index ) revs = append ( revs , cur Keyi . since ( ti . lg , rev ) . . . ) return true } ) sort . Sort ( revisions ( revs ) ) return revs } 
func ( ti * tree Index ) Keep ( rev int 6 4 ) map [ revision ] struct { } { available : = make ( map [ revision ] struct { } ) ti . RLock ( ) defer ti . RUnlock ( ) ti . tree . Ascend ( func ( i btree . Item ) bool { keyi : = i . ( * key Index ) keyi . keep ( rev , available ) return true } ) return available } 
func ( l * lessor ) close Require Leader ( ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) for _ , ka : = range l . keep Alives { req Idxs : = 0 if ! ok { continue } ks : = md [ rpctypes . Metadata Require Leader Key ] if len ( ks ) < 1 | | ks [ 0 ] ! = rpctypes . Metadata Has Leader { continue } close ( ka . chs [ i ] ) ka . chs [ i ] = nil req Idxs + + } if req Idxs = = 0 { continue } new Ctxs : = make ( [ ] context . Context , len ( new Chs ) ) new Idx : = 0 for i : = range ka . chs { if ka . chs [ i ] = = nil { continue } new Chs [ new Idx ] , new Ctxs [ new Idx ] = ka . chs [ i ] , ka . ctxs [ new Idx ] new Idx + + } ka . chs , ka . ctxs = new Chs , new Ctxs } } 
func ( l * lessor ) reset Recv ( ) ( pb . Lease _Lease Keep Alive Client , error ) { sctx , cancel : = context . With Cancel ( l . stop Ctx ) stream , err : = l . remote . Lease Keep Alive ( sctx , append ( l . call Opts , with Max ( 0 ) ) . . . ) if err ! = nil { cancel ( ) return nil , err } l . mu . Lock ( ) defer l . mu . Unlock ( ) if l . stream ! = nil & & l . stream Cancel ! = nil { l . stream Cancel ( ) } l . stream Cancel = cancel l . stream = stream go l . send Keep Alive Loop ( stream ) return stream , nil } 
func ( l * lessor ) recv Keep Alive ( resp * pb . Lease Keep Alive Response ) { karesp : = & Lease Keep Alive Response { Response Header : resp . Get Header ( ) , ID : Lease ID ( resp . ID ) , TTL : resp . TTL , } l . mu . Lock ( ) defer l . mu . Unlock ( ) ka , ok : = l . keep Alives [ karesp . ID ] if ! ok { return } if karesp . TTL < = 0 { ka . close ( ) return } ka . deadline = time . Now ( ) . Add ( time . Duration ( karesp . TTL ) * time . Second ) for _ , ch : = range ka . chs { select { case ch < - karesp : default : if l . lg ! = nil { l . lg . Warn ( " " , zap . Int ( " " , len ( ch ) ) , zap . Int ( " " , cap ( ch ) ) , ) } } } } 
func ( l * lessor ) deadline Loop ( ) { for { select { case < - time . After ( time . Second ) : case < - l . donec : return } now : = time . Now ( ) l . mu . Lock ( ) for id , ka : = range l . keep Alives { if ka . deadline . Before ( now ) { delete ( l . keep Alives , id ) } } l . mu . Unlock ( ) } } 
func ( l * lessor ) send Keep Alive Loop ( stream pb . Lease _Lease Keep Alive Client ) { for { var tosend [ ] Lease ID now : = time . Now ( ) l . mu . Lock ( ) for id , ka : = range l . keep Alives { if ka . next Keep Alive . Before ( now ) { tosend = append ( tosend , id ) } } l . mu . Unlock ( ) for _ , id : = range tosend { r : = & pb . Lease Keep Alive Request { ID : int 6 4 ( id ) } if err : = stream . Send ( r ) ; err ! = nil { } } select { case < - time . After ( retry Conn Wait ) : case < - stream . Context ( ) . Done ( ) : return case < - l . donec : return case < - l . stop Ctx . Done ( ) : return } } } 
func New KV ( cl * v 3 . Client , pfx string , opts . . . concurrency . Session Option ) ( v 3 . KV , func ( ) , error ) { cctx , cancel : = context . With Cancel ( cl . Ctx ( ) ) lkv : = & leasing KV { cl : cl , kv : cl . KV , pfx : pfx , leases : lease Cache { revokes : make ( map [ string ] time . Time ) } , ctx : cctx , cancel : cancel , session Opts : opts , sessionc : make ( chan struct { } ) , } lkv . wg . Add ( 2 ) go func ( ) { defer lkv . wg . Done ( ) lkv . monitor Session ( ) } ( ) go func ( ) { defer lkv . wg . Done ( ) lkv . leases . clear Old Revokes ( cctx ) } ( ) return lkv , lkv . Close , lkv . wait Session ( cctx ) } 
func ( lkv * leasing KV ) rescind ( ctx context . Context , key string , rev int 6 4 ) { if lkv . leases . Evict ( key ) > rev { return } cmp : = v 3 . Compare ( v 3 . Create Revision ( lkv . pfx + key ) , " " , rev ) op : = v 3 . Op Delete ( lkv . pfx + key ) for ctx . Err ( ) = = nil { if _ , err : = lkv . kv . Txn ( ctx ) . If ( cmp ) . Then ( op ) . Commit ( ) ; err = = nil { return } } } 
func Lease Value ( key string ) Cmp { return Cmp { Key : [ ] byte ( key ) , Target : pb . Compare _LEASE } } 
func ( cmp * Cmp ) Value Bytes ( ) [ ] byte { if tu , ok : = cmp . Target Union . ( * pb . Compare _Value ) ; ok { return tu . Value } return nil } 
func ( cmp Cmp ) With Range ( end string ) Cmp { cmp . Range End = [ ] byte ( end ) return cmp } 
func ( cmp Cmp ) With Prefix ( ) Cmp { cmp . Range End = get Prefix ( cmp . Key ) return cmp } 
func must Int 6 4 ( val interface { } ) int 6 4 { if v , ok : = val . ( int 6 4 ) ; ok { return v } if v , ok : = val . ( int ) ; ok { return int 6 4 ( v ) } panic ( " " ) } 
func must Int 6 4or Lease ID ( val interface { } ) int 6 4 { if v , ok : = val . ( Lease ID ) ; ok { return int 6 4 ( v ) } return must Int 6 4 ( val ) } 
func ( gw * g RPCWatcher ) Next ( ) ( [ ] * naming . Update , error ) { if gw . wch = = nil { } if gw . err ! = nil { return nil , gw . err } if ! ok { gw . err = status . Error ( codes . Unavailable , Err Watcher Closed . Error ( ) ) return nil , gw . err } if gw . err = wr . Err ( ) ; gw . err ! = nil { return nil , gw . err } updates : = make ( [ ] * naming . Update , 0 , len ( wr . Events ) ) for _ , e : = range wr . Events { var jupdate naming . Update var err error switch e . Type { case etcd . Event Type Put : err = json . Unmarshal ( e . Kv . Value , & jupdate ) jupdate . Op = naming . Add case etcd . Event Type Delete : err = json . Unmarshal ( e . Prev Kv . Value , & jupdate ) jupdate . Op = naming . Delete default : continue } if err = = nil { updates = append ( updates , & jupdate ) } } return updates , nil } 
func get Journal Write Syncer ( ) ( zapcore . Write Syncer , error ) { jw , err : = logutil . New Journal Writer ( os . Stderr ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return zapcore . Add Sync ( jw ) , nil } 
func new KV ( store * store , node Path string , value string , created Index uint 6 4 , parent * node , expire Time time . Time ) * node { return & node { Path : node Path , Created Index : created Index , Modified Index : created Index , Parent : parent , store : store , Expire Time : expire Time , Value : value , } } 
func new Dir ( store * store , node Path string , created Index uint 6 4 , parent * node , expire Time time . Time ) * node { return & node { Path : node Path , Created Index : created Index , Modified Index : created Index , Parent : parent , Expire Time : expire Time , Children : make ( map [ string ] * node ) , store : store , } } 
func ( n * node ) Is Hidden ( ) bool { _ , name : = path . Split ( n . Path ) return name [ 0 ] = = ' _ ' } 
func ( n * node ) Read ( ) ( string , * v 2error . Error ) { if n . Is Dir ( ) { return " " , v 2error . New Error ( v 2error . Ecode Not File , " " , n . store . Current Index ) } return n . Value , nil } 
func ( n * node ) Write ( value string , index uint 6 4 ) * v 2error . Error { if n . Is Dir ( ) { return v 2error . New Error ( v 2error . Ecode Not File , " " , n . store . Current Index ) } n . Value = value n . Modified Index = index return nil } 
func ( n * node ) List ( ) ( [ ] * node , * v 2error . Error ) { if ! n . Is Dir ( ) { return nil , v 2error . New Error ( v 2error . Ecode Not Dir , " " , n . store . Current Index ) } nodes : = make ( [ ] * node , len ( n . Children ) ) i : = 0 for _ , node : = range n . Children { nodes [ i ] = node i + + } return nodes , nil } 
func ( n * node ) Get Child ( name string ) ( * node , * v 2error . Error ) { if ! n . Is Dir ( ) { return nil , v 2error . New Error ( v 2error . Ecode Not Dir , n . Path , n . store . Current Index ) } child , ok : = n . Children [ name ] if ok { return child , nil } return nil , nil } 
func ( n * node ) Add ( child * node ) * v 2error . Error { if ! n . Is Dir ( ) { return v 2error . New Error ( v 2error . Ecode Not Dir , " " , n . store . Current Index ) } _ , name : = path . Split ( child . Path ) if _ , ok : = n . Children [ name ] ; ok { return v 2error . New Error ( v 2error . Ecode Node Exist , " " , n . store . Current Index ) } n . Children [ name ] = child return nil } 
func ( n * node ) Remove ( dir , recursive bool , callback func ( path string ) ) * v 2error . Error { if ! n . Is Dir ( ) { } if callback ! = nil { callback ( n . Path ) } if ! n . Is Permanent ( ) { n . store . ttl Key Heap . remove ( n ) } return nil } if ! dir { } if len ( n . Children ) ! = 0 & & ! recursive { } for _ , child : = range n . Children { } if n . Parent ! = nil & & n . Parent . Children [ name ] = = n { delete ( n . Parent . Children , name ) if callback ! = nil { callback ( n . Path ) } if ! n . Is Permanent ( ) { n . store . ttl Key Heap . remove ( n ) } } return nil } 
func ( n * node ) Compare ( prev Value string , prev Index uint 6 4 ) ( ok bool , which int ) { index Match : = prev Index = = 0 | | n . Modified Index = = prev Index value Match : = prev Value = = " " | | n . Value = = prev Value ok = value Match & & index Match switch { case value Match & & index Match : which = Compare Match case index Match & & ! value Match : which = Compare Value Not Match case value Match & & ! index Match : which = Compare Index Not Match default : which = Compare Not Match } return ok , which } 
func ( n * node ) Clone ( ) * node { if ! n . Is Dir ( ) { newkv : = new KV ( n . store , n . Path , n . Value , n . Created Index , n . Parent , n . Expire Time ) newkv . Modified Index = n . Modified Index return newkv } clone : = new Dir ( n . store , n . Path , n . Created Index , n . Parent , n . Expire Time ) clone . Modified Index = n . Modified Index for key , child : = range n . Children { clone . Children [ key ] = child . Clone ( ) } return clone } 
func ( n * node ) recover Andclean ( ) { if n . Is Dir ( ) { for _ , child : = range n . Children { child . Parent = n child . store = n . store child . recover Andclean ( ) } } if ! n . Expire Time . Is Zero ( ) { n . store . ttl Key Heap . push ( n ) } } 
func is Connected To Quorum Since ( transport rafthttp . Transporter , since time . Time , self types . ID , members [ ] * membership . Member ) bool { return num Connected Since ( transport , since , self , members ) > = ( len ( members ) / 2 ) + 1 } 
func is Connected Since ( transport rafthttp . Transporter , since time . Time , remote types . ID ) bool { t : = transport . Active Since ( remote ) return ! t . Is Zero ( ) & & t . Before ( since ) } 
func num Connected Since ( transport rafthttp . Transporter , since time . Time , self types . ID , members [ ] * membership . Member ) int { connected Num : = 0 for _ , m : = range members { if m . ID = = self | | is Connected Since ( transport , since , m . ID ) { connected Num + + } } return connected Num } 
func longest Connected ( tp rafthttp . Transporter , membs [ ] types . ID ) ( types . ID , bool ) { var longest types . ID var oldest time . Time for _ , id : = range membs { tm : = tp . Active Since ( id ) if tm . Is Zero ( ) { } if oldest . Is Zero ( ) { longest = id } if tm . Before ( oldest ) { oldest = tm longest = id } } if uint 6 4 ( longest ) = = 0 { return longest , false } return longest , true } 
func ( d * decoder ) is Torn Entry ( data [ ] byte ) bool { if len ( d . brs ) ! = 1 { return false } file Off : = d . last Valid Off + frame Size Bytes cur Off : = 0 chunks : = [ ] [ ] byte { } if chunk Len > len ( data ) - cur Off { chunk Len = len ( data ) - cur Off } chunks = append ( chunks , data [ cur Off : cur Off + chunk Len ] ) file Off + = int 6 4 ( chunk Len ) cur Off + = chunk Len } for _ , v : = range sect { if v ! = 0 { is Zero = false break } } if is Zero { return true } } return false } 
func Start Mock Servers On Network ( count int , network string ) ( ms * Mock Servers , err error ) { switch network { case " " : return start Mock Servers Tcp ( count ) case " " : return start Mock Servers Unix ( count ) default : return nil , fmt . Errorf ( " " , network ) } } 
func ( ms * Mock Servers ) Start At ( idx int ) ( err error ) { ms . mu . Lock ( ) defer ms . mu . Unlock ( ) if ms . Servers [ idx ] . ln = = nil { ms . Servers [ idx ] . ln , err = net . Listen ( ms . Servers [ idx ] . Network , ms . Servers [ idx ] . Address ) if err ! = nil { return fmt . Errorf ( " " , err ) } } svr : = grpc . New Server ( ) pb . Register KVServer ( svr , & mock KVServer { } ) ms . Servers [ idx ] . Grpc Server = svr ms . wg . Add ( 1 ) go func ( svr * grpc . Server , l net . Listener ) { svr . Serve ( l ) } ( ms . Servers [ idx ] . Grpc Server , ms . Servers [ idx ] . ln ) return nil } 
func ( ms * Mock Servers ) Stop At ( idx int ) { ms . mu . Lock ( ) defer ms . mu . Unlock ( ) if ms . Servers [ idx ] . ln = = nil { return } ms . Servers [ idx ] . Grpc Server . Stop ( ) ms . Servers [ idx ] . Grpc Server = nil ms . Servers [ idx ] . ln = nil ms . wg . Done ( ) } 
func ( ms * Mock Servers ) Stop ( ) { for idx : = range ms . Servers { ms . Stop At ( idx ) } ms . wg . Wait ( ) } 
func New Check Command ( ) * cobra . Command { cc : = & cobra . Command { Use : " " , Short : " " , } cc . Add Command ( New Check Perf Command ( ) ) cc . Add Command ( New Check Datascale Command ( ) ) return cc } 
func New Check Perf Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : new Check Perf Command , } cmd . Flags ( ) . String Var ( & check Perf Prefix , " " , " " , " " ) cmd . Flags ( ) . Bool Var ( & auto Compact , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & auto Defrag , " " , false , " " ) return cmd } 
func new Check Perf Command ( cmd * cobra . Command , args [ ] string ) { var check Perf Alias = map [ string ] string { " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , } model , ok : = check Perf Alias [ check Perf Load ] if ! ok { Exit With Error ( Exit Bad Feature , fmt . Errorf ( " " , check Perf Load ) ) } cfg : = check Perf Cfg Map [ model ] requests : = make ( chan v 3 . Op , cfg . clients ) limit : = rate . New Limiter ( rate . Limit ( cfg . limit ) , 1 ) cc : = client Config From Cmd ( cmd ) clients : = make ( [ ] * v 3 . Client , cfg . clients ) for i : = 0 ; i < cfg . clients ; i + + { clients [ i ] = cc . must Client ( ) } ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Duration ( cfg . duration ) * time . Second ) resp , err : = clients [ 0 ] . Get ( ctx , check Perf Prefix , v 3 . With Prefix ( ) , v 3 . With Limit ( 1 ) ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } if len ( resp . Kvs ) > 0 { Exit With Error ( Exit Invalid Input , fmt . Errorf ( " " , check Perf Prefix , check Perf Prefix ) ) } ksize , vsize : = 2 5 6 , 1 0 2 4 k , v : = make ( [ ] byte , ksize ) , string ( make ( [ ] byte , vsize ) ) bar : = pb . New ( cfg . duration ) bar . Format ( " " ) bar . Start ( ) r : = report . New Report ( " " ) var wg sync . Wait Group wg . Add ( len ( clients ) ) for i : = range clients { go func ( c * v 3 . Client ) { defer wg . Done ( ) for op : = range requests { st : = time . Now ( ) _ , derr : = c . Do ( context . Background ( ) , op ) r . Results ( ) < - report . Result { Err : derr , Start : st , End : time . Now ( ) } } } ( clients [ i ] ) } go func ( ) { cctx , ccancel : = context . With Timeout ( context . Background ( ) , time . Duration ( cfg . duration ) * time . Second ) defer ccancel ( ) for limit . Wait ( cctx ) = = nil { binary . Put Varint ( k , rand . Int 6 3n ( math . Max Int 6 4 ) ) requests < - v 3 . Op Put ( check Perf Prefix + string ( k ) , v ) } close ( requests ) } ( ) go func ( ) { for i : = 0 ; i < cfg . duration ; i + + { time . Sleep ( time . Second ) bar . Add ( 1 ) } bar . Finish ( ) } ( ) sc : = r . Stats ( ) wg . Wait ( ) close ( r . Results ( ) ) s : = < - sc ctx , cancel = context . With Timeout ( context . Background ( ) , 3 0 * time . Second ) dresp , err : = clients [ 0 ] . Delete ( ctx , check Perf Prefix , v 3 . With Prefix ( ) ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } if auto Compact { compact ( clients [ 0 ] , dresp . Header . Revision ) } if auto Defrag { for _ , ep : = range clients [ 0 ] . Endpoints ( ) { defrag ( clients [ 0 ] , ep ) } } ok = true if len ( s . Error Dist ) ! = 0 { fmt . Println ( " " ) for k , v : = range s . Error Dist { fmt . Printf ( " \n " , k , v ) } ok = false } if s . RPS / float 6 4 ( cfg . limit ) < = 0 . 9 { fmt . Printf ( " \n " , int ( s . RPS ) + 1 ) ok = false } else { fmt . Printf ( " \n " , int ( s . RPS ) + 1 ) } if s . Slowest > 0 . 5 { ok = false } else { fmt . Printf ( " \n " , s . Slowest ) } if s . Stddev > 0 . 1 { ok = false } else { fmt . Printf ( " \n " , s . Stddev ) } if ok { fmt . Println ( " " ) } else { fmt . Println ( " " ) os . Exit ( Exit Error ) } } 
func New Check Datascale Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : new Check Datascale Command , } cmd . Flags ( ) . String Var ( & check Datascale Load , " " , " " , " " ) cmd . Flags ( ) . String Var ( & check Datascale Prefix , " " , " " , " " ) cmd . Flags ( ) . Bool Var ( & auto Compact , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & auto Defrag , " " , false , " " ) return cmd } 
func new Check Datascale Command ( cmd * cobra . Command , args [ ] string ) { var check Datascale Alias = map [ string ] string { " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , " " : " " , } model , ok : = check Datascale Alias [ check Datascale Load ] if ! ok { Exit With Error ( Exit Bad Feature , fmt . Errorf ( " " , check Datascale Load ) ) } cfg : = check Datascale Cfg Map [ model ] requests : = make ( chan v 3 . Op , cfg . clients ) cc : = client Config From Cmd ( cmd ) clients : = make ( [ ] * v 3 . Client , cfg . clients ) for i : = 0 ; i < cfg . clients ; i + + { clients [ i ] = cc . must Client ( ) } if err Endpoints ! = nil { Exit With Error ( Exit Error , err Endpoints ) } ctx , cancel : = context . With Cancel ( context . Background ( ) ) resp , err : = clients [ 0 ] . Get ( ctx , check Datascale Prefix , v 3 . With Prefix ( ) , v 3 . With Limit ( 1 ) ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } if len ( resp . Kvs ) > 0 { Exit With Error ( Exit Invalid Input , fmt . Errorf ( " " , check Datascale Prefix , check Datascale Prefix ) ) } ksize , vsize : = 5 1 2 , 5 1 2 k , v : = make ( [ ] byte , ksize ) , string ( make ( [ ] byte , vsize ) ) r : = report . New Report ( " " ) var wg sync . Wait Group wg . Add ( len ( clients ) ) if bytes Before = = 0 { fmt . Println ( " " ) os . Exit ( Exit Error ) } fmt . Println ( fmt . Sprintf ( " " , cfg . limit , cfg . kv Size , cfg . clients ) ) bar : = pb . New ( cfg . limit ) bar . Format ( " " ) bar . Start ( ) for i : = range clients { go func ( c * v 3 . Client ) { defer wg . Done ( ) for op : = range requests { st : = time . Now ( ) _ , derr : = c . Do ( context . Background ( ) , op ) r . Results ( ) < - report . Result { Err : derr , Start : st , End : time . Now ( ) } bar . Increment ( ) } } ( clients [ i ] ) } go func ( ) { for i : = 0 ; i < cfg . limit ; i + + { binary . Put Varint ( k , rand . Int 6 3n ( math . Max Int 6 4 ) ) requests < - v 3 . Op Put ( check Datascale Prefix + string ( k ) , v ) } close ( requests ) } ( ) sc : = r . Stats ( ) wg . Wait ( ) close ( r . Results ( ) ) bar . Finish ( ) s : = < - sc if bytes After = = 0 { fmt . Println ( " " ) os . Exit ( Exit Error ) } dresp , derr : = clients [ 0 ] . Delete ( ctx , check Datascale Prefix , v 3 . With Prefix ( ) ) defer cancel ( ) if derr ! = nil { Exit With Error ( Exit Error , derr ) } if auto Compact { compact ( clients [ 0 ] , dresp . Header . Revision ) } if auto Defrag { for _ , ep : = range clients [ 0 ] . Endpoints ( ) { defrag ( clients [ 0 ] , ep ) } } if bytes After = = 0 { fmt . Println ( " " ) os . Exit ( Exit Error ) } bytes Used : = bytes After - bytes Before mb Used : = bytes Used / ( 1 0 2 4 * 1 0 2 4 ) if len ( s . Error Dist ) ! = 0 { fmt . Println ( " " ) for k , v : = range s . Error Dist { fmt . Printf ( " \n " , k , v ) } os . Exit ( Exit Error ) } else { fmt . Println ( fmt . Sprintf ( " " , strconv . Format Float ( mb Used , 'f ' , 2 , 6 4 ) ) ) } } 
func New Get Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : get Command Func , } cmd . Flags ( ) . String Var ( & get Consistency , " " , " " , " " ) cmd . Flags ( ) . String Var ( & get Sort Order , " " , " " , " " ) cmd . Flags ( ) . String Var ( & get Sort Target , " " , " " , " " ) cmd . Flags ( ) . Int 6 4Var ( & get Limit , " " , 0 , " " ) cmd . Flags ( ) . Bool Var ( & get Prefix , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & get From Key , " " , false , " " ) cmd . Flags ( ) . Int 6 4Var ( & get Rev , " " , 0 , " " ) cmd . Flags ( ) . Bool Var ( & get Keys Only , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & print Value Only , " " , false , `Only write values when using the "simple " output format ` ) return cmd } 
func get Command Func ( cmd * cobra . Command , args [ ] string ) { key , opts : = get Get Op ( args ) ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Get ( ctx , key , opts . . . ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } if print Value Only { dp , simple : = ( display ) . ( * simple Printer ) if ! simple { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } dp . value Only = true } display . Get ( * resp ) } 
func New Get Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Bool Flag { Name : " " , Usage : " " } , cli . Bool Flag { Name : " " , Usage : " " } , } , Action : func ( c * cli . Context ) error { get Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func get Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] sorted : = c . Bool ( " " ) quorum : = c . Bool ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Get ( ctx , key , & client . Get Options { Sort : sorted , Quorum : quorum } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if resp . Node . Dir { fmt . Fprintln ( os . Stderr , fmt . Sprintf ( " " , resp . Node . Key ) ) os . Exit ( 1 ) } print Response Key ( resp , c . Global String ( " " ) ) } 
func New Member ( name string , peer URLs types . URLs , cluster Name string , now * time . Time ) * Member { m : = & Member { Raft Attributes : Raft Attributes { Peer URLs : peer URLs . String Slice ( ) } , Attributes : Attributes { Name : name } , } var b [ ] byte sort . Strings ( m . Peer URLs ) for _ , p : = range m . Peer URLs { b = append ( b , [ ] byte ( p ) . . . ) } b = append ( b , [ ] byte ( cluster Name ) . . . ) if now ! = nil { b = append ( b , [ ] byte ( fmt . Sprintf ( " " , now . Unix ( ) ) ) . . . ) } hash : = sha 1 . Sum ( b ) m . ID = types . ID ( binary . Big Endian . Uint 6 4 ( hash [ : 8 ] ) ) return m } 
func ( m * Member ) Pick Peer URL ( ) string { if len ( m . Peer URLs ) = = 0 { panic ( " " ) } return m . Peer URLs [ rand . Intn ( len ( m . Peer URLs ) ) ] } 
func Handle Metrics Health ( mux * http . Serve Mux , srv etcdserver . Server V 2 ) { mux . Handle ( Path Metrics , promhttp . Handler ( ) ) mux . Handle ( Path Health , New Health Handler ( func ( ) Health { return check Health ( srv ) } ) ) } 
func New Health Handler ( hfunc func ( ) Health ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { if r . Method ! = http . Method Get { w . Header ( ) . Set ( " " , http . Method Get ) http . Error ( w , " " , http . Status Method Not Allowed ) return } h : = hfunc ( ) d , _ : = json . Marshal ( h ) if h . Health ! = " " { http . Error ( w , string ( d ) , http . Status Service Unavailable ) return } w . Write Header ( http . Status OK ) w . Write ( d ) } } 
func check Health ( srv etcdserver . Server V 2 ) Health { h : = Health { Health : " " } as : = srv . Alarms ( ) if len ( as ) > 0 { h . Health = " " } if h . Health = = " " { if uint 6 4 ( srv . Leader ( ) ) = = raft . None { h . Health = " " } } if h . Health = = " " { ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Second ) _ , err : = srv . Do ( ctx , etcdserverpb . Request { Method : " " } ) cancel ( ) if err ! = nil { h . Health = " " } } if h . Health = = " " { health Success . Inc ( ) } else { health Failed . Inc ( ) } return h } 
func New Remove Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Bool Flag { Name : " " , Usage : " " } , cli . Bool Flag { Name : " " , Usage : " " } , cli . String Flag { Name : " " , Value : " " , Usage : " " } , cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , } , Action : func ( c * cli . Context ) error { rm Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func rm Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] recursive : = c . Bool ( " " ) dir : = c . Bool ( " " ) prev Value : = c . String ( " " ) prev Index : = c . Int ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Delete ( ctx , key , & client . Delete Options { Prev Index : uint 6 4 ( prev Index ) , Prev Value : prev Value , Dir : dir , Recursive : recursive } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if ! resp . Node . Dir | | c . Global String ( " " ) ! = " " { print Response Key ( resp , c . Global String ( " " ) ) } } 
func check Intervals ( reqs [ ] * pb . Request Op ) ( map [ string ] struct { } , adt . Interval Tree , error ) { var dels adt . Interval Tree if ! ok { continue } dreq : = tv . Request Delete Range if dreq = = nil { continue } var iv adt . Interval if len ( dreq . Range End ) ! = 0 { iv = adt . New String Affine Interval ( string ( dreq . Key ) , string ( dreq . Range End ) ) } else { iv = adt . New String Affine Point ( string ( dreq . Key ) ) } dels . Insert ( iv , struct { } { } ) } for _ , req : = range reqs { tv , ok : = req . Request . ( * pb . Request Op _Request Txn ) if ! ok { continue } puts Then , dels Then , err : = check Intervals ( tv . Request Txn . Success ) if err ! = nil { return nil , dels , err } puts Else , dels Else , err : = check Intervals ( tv . Request Txn . Failure ) if err ! = nil { return nil , dels , err } for k : = range puts Then { if _ , ok : = puts [ k ] ; ok { return nil , dels , rpctypes . Err GRPCDuplicate Key } if dels . Intersects ( adt . New String Affine Point ( k ) ) { return nil , dels , rpctypes . Err GRPCDuplicate Key } puts [ k ] = struct { } { } } for k : = range puts Else { if _ , ok : = puts [ k ] ; ok { } } if dels . Intersects ( adt . New String Affine Point ( k ) ) { return nil , dels , rpctypes . Err GRPCDuplicate Key } puts [ k ] = struct { } { } } dels . Union ( dels Then , adt . New String Affine Interval ( " \x 0 0 " , " " ) ) dels . Union ( dels Else , adt . New String Affine Interval ( " \x 0 0 " , " " ) ) } if ! ok | | tv . Request Put = = nil { continue } k : = string ( tv . Request Put . Key ) if _ , ok : = puts [ k ] ; ok { return nil , dels , rpctypes . Err GRPCDuplicate Key } if dels . Intersects ( adt . New String Affine Point ( k ) ) { return nil , dels , rpctypes . Err GRPCDuplicate Key } puts [ k ] = struct { } { } } return puts , dels , nil } 
func Report Event Received ( n int ) { pending Events Gauge . Sub ( float 6 4 ( n ) ) total Events Counter . Add ( float 6 4 ( n ) ) } 
func Register KVHandler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register KVHandler Client ( ctx , mux , etcdserverpb . New KVClient ( conn ) ) } 
func Register KVHandler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . KVClient ) error { mux . Handle ( " " , pattern _KV _Range _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _KV _Range _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _KV _Range _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _KV _Put _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _KV _Put _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _KV _Put _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _KV _Delete Range _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _KV _Delete Range _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _KV _Delete Range _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _KV _Txn _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _KV _Txn _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _KV _Txn _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _KV _Compact _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _KV _Compact _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _KV _Compact _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Register Watch Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Watch Handler Client ( ctx , mux , etcdserverpb . New Watch Client ( conn ) ) } 
func Register Watch Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . Watch Client ) error { mux . Handle ( " " , pattern _Watch _Watch _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Watch _Watch _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Watch _Watch _ 0 ( ctx , mux , outbound Marshaler , w , req , func ( ) ( proto . Message , error ) { return resp . Recv ( ) } , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Register Lease Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Lease Handler Client ( ctx , mux , etcdserverpb . New Lease Client ( conn ) ) } 
func Register Lease Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . Lease Client ) error { mux . Handle ( " " , pattern _Lease _Lease Grant _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Grant _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Grant _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Revoke _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Revoke _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Revoke _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Revoke _ 1 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Revoke _ 1 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Revoke _ 1 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Keep Alive _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Keep Alive _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Keep Alive _ 0 ( ctx , mux , outbound Marshaler , w , req , func ( ) ( proto . Message , error ) { return resp . Recv ( ) } , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Time To Live _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Time To Live _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Time To Live _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Time To Live _ 1 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Time To Live _ 1 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Time To Live _ 1 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Leases _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Leases _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Leases _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lease _Lease Leases _ 1 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lease _Lease Leases _ 1 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lease _Lease Leases _ 1 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Register Cluster Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Cluster Handler Client ( ctx , mux , etcdserverpb . New Cluster Client ( conn ) ) } 
func Register Cluster Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . Cluster Client ) error { mux . Handle ( " " , pattern _Cluster _Member Add _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Cluster _Member Add _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Cluster _Member Add _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Cluster _Member Remove _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Cluster _Member Remove _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Cluster _Member Remove _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Cluster _Member Update _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Cluster _Member Update _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Cluster _Member Update _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Cluster _Member List _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Cluster _Member List _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Cluster _Member List _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Register Maintenance Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Maintenance Handler Client ( ctx , mux , etcdserverpb . New Maintenance Client ( conn ) ) } 
func Register Maintenance Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . Maintenance Client ) error { mux . Handle ( " " , pattern _Maintenance _Alarm _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Alarm _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Alarm _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Status _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Status _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Status _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Defragment _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Defragment _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Defragment _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Hash _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Hash _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Hash _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Hash KV _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Hash KV _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Hash KV _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Snapshot _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Snapshot _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Snapshot _ 0 ( ctx , mux , outbound Marshaler , w , req , func ( ) ( proto . Message , error ) { return resp . Recv ( ) } , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Maintenance _Move Leader _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Maintenance _Move Leader _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Maintenance _Move Leader _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func Register Auth Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Auth Handler Client ( ctx , mux , etcdserverpb . New Auth Client ( conn ) ) } 
func Register Auth Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client etcdserverpb . Auth Client ) error { mux . Handle ( " " , pattern _Auth _Auth Enable _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Auth Enable _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Auth Enable _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Auth Disable _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Auth Disable _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Auth Disable _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Authenticate _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Authenticate _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Authenticate _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Add _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Add _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Add _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Get _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Get _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Get _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User List _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User List _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User List _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Delete _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Delete _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Delete _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Change Password _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Change Password _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Change Password _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Grant Role _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Grant Role _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Grant Role _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _User Revoke Role _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _User Revoke Role _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _User Revoke Role _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role Add _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role Add _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role Add _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role Get _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role Get _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role Get _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role List _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role List _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role List _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role Delete _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role Delete _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role Delete _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role Grant Permission _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role Grant Permission _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role Grant Permission _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Auth _Role Revoke Permission _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Auth _Role Revoke Permission _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Auth _Role Revoke Permission _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func start Etcd ( cfg * embed . Config ) ( < - chan struct { } , < - chan error , error ) { e , err : = embed . Start Etcd ( cfg ) if err ! = nil { return nil , nil , err } osutil . Register Interrupt Handler ( e . Close ) select { case < - e . Server . Ready Notify ( ) : return e . Server . Stop Notify ( ) , e . Err ( ) , nil } 
func start Proxy ( cfg * config ) error { lg : = cfg . ec . Get Logger ( ) if lg ! = nil { lg . Info ( " " ) } else { plog . Notice ( " " ) } client TLSInfo : = cfg . ec . Client TLSInfo if client TLSInfo . Empty ( ) { } client TLSInfo . Insecure Skip Verify = cfg . ec . Client Auto TLS cfg . ec . Peer TLSInfo . Insecure Skip Verify = cfg . ec . Peer Auto TLS pt , err : = transport . New Timeout Transport ( client TLSInfo , time . Duration ( cfg . cp . Proxy Dial Timeout Ms ) * time . Millisecond , time . Duration ( cfg . cp . Proxy Read Timeout Ms ) * time . Millisecond , time . Duration ( cfg . cp . Proxy Write Timeout Ms ) * time . Millisecond , ) if err ! = nil { return err } pt . Max Idle Conns Per Host = httpproxy . Default Max Idle Conns Per Host if err = cfg . ec . Peer Self Cert ( ) ; err ! = nil { if lg ! = nil { lg . Fatal ( " " , zap . Error ( err ) ) } else { plog . Fatalf ( " " , err ) } } tr , err : = transport . New Timeout Transport ( cfg . ec . Peer TLSInfo , time . Duration ( cfg . cp . Proxy Dial Timeout Ms ) * time . Millisecond , time . Duration ( cfg . cp . Proxy Read Timeout Ms ) * time . Millisecond , time . Duration ( cfg . cp . Proxy Write Timeout Ms ) * time . Millisecond , ) if err ! = nil { return err } cfg . ec . Dir = filepath . Join ( cfg . ec . Dir , " " ) err = os . Mkdir All ( cfg . ec . Dir , fileutil . Private Dir Mode ) if err ! = nil { return err } var peer URLs [ ] string clusterfile : = filepath . Join ( cfg . ec . Dir , " " ) b , err : = ioutil . Read File ( clusterfile ) switch { case err = = nil : if cfg . ec . Durl ! = " " { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , clusterfile ) , ) } else { plog . Warningf ( " " , clusterfile ) } } if cfg . ec . DNSCluster ! = " " { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , clusterfile ) , ) } else { plog . Warningf ( " " , clusterfile ) } } urls : = struct { Peer URLs [ ] string } { } err = json . Unmarshal ( b , & urls ) if err ! = nil { return err } peer URLs = urls . Peer URLs if lg ! = nil { lg . Info ( " " , zap . Strings ( " " , peer URLs ) , zap . String ( " " , clusterfile ) , ) } else { plog . Infof ( " " , peer URLs , clusterfile ) } case os . Is Not Exist ( err ) : var urlsmap types . URLs Map urlsmap , _ , err = cfg . ec . Peer URLs Map And Token ( " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } if cfg . ec . Durl ! = " " { var s string s , err = v 2discovery . Get Cluster ( lg , cfg . ec . Durl , cfg . ec . Dproxy ) if err ! = nil { return err } if urlsmap , err = types . New URLs Map ( s ) ; err ! = nil { return err } } peer URLs = urlsmap . URLs ( ) if lg ! = nil { lg . Info ( " " , zap . Strings ( " " , peer URLs ) ) } else { plog . Infof ( " " , peer URLs ) } default : return err } client URLs : = [ ] string { } uf : = func ( ) [ ] string { gcls , gerr : = etcdserver . Get Cluster From Remote Peers ( lg , peer URLs , tr ) if gerr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . Strings ( " " , peer URLs ) , zap . Error ( gerr ) , ) } else { plog . Warningf ( " " , gerr ) } return [ ] string { } } client URLs = gcls . Client URLs ( ) urls : = struct { Peer URLs [ ] string } { gcls . Peer URLs ( ) } b , jerr : = json . Marshal ( urls ) if jerr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . Error ( jerr ) ) } else { plog . Warningf ( " " , jerr ) } return client URLs } err = pkgioutil . Write And Sync File ( clusterfile + " " , b , 0 6 0 0 ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . Error ( err ) ) } else { plog . Warningf ( " " , err ) } return client URLs } err = os . Rename ( clusterfile + " " , clusterfile ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , clusterfile ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , err ) } return client URLs } if ! reflect . Deep Equal ( gcls . Peer URLs ( ) , peer URLs ) { if lg ! = nil { lg . Info ( " " , zap . Strings ( " " , peer URLs ) , zap . Strings ( " " , gcls . Peer URLs ( ) ) , ) } else { plog . Noticef ( " " , peer URLs , gcls . Peer URLs ( ) ) } } peer URLs = gcls . Peer URLs ( ) return client URLs } ph : = httpproxy . New Handler ( pt , uf , time . Duration ( cfg . cp . Proxy Failure Wait Ms ) * time . Millisecond , time . Duration ( cfg . cp . Proxy Refresh Interval Ms ) * time . Millisecond ) ph = embed . Wrap CORS ( cfg . ec . CORS , ph ) if cfg . is Readonly Proxy ( ) { ph = httpproxy . New Readonly Handler ( ph ) } for _ , u : = range cfg . ec . LCUrls { c Hosts = append ( c Hosts , u . Host ) c TLS = c TLS | | u . Scheme = = " " } for _ , u : = range cfg . ec . ACUrls { c Hosts = append ( c Hosts , u . Host ) c TLS = c TLS | | u . Scheme = = " " } listener TLS : = cfg . ec . Client TLSInfo if cfg . ec . Client Auto TLS & & c TLS { listener TLS , err = transport . Self Cert ( cfg . ec . Get Logger ( ) , filepath . Join ( cfg . ec . Dir , " " ) , c Hosts ) if err ! = nil { if lg ! = nil { lg . Fatal ( " " , zap . Error ( err ) ) } else { plog . Fatalf ( " " , err ) } } } if err ! = nil { return err } host : = u . String ( ) go func ( ) { if lg ! = nil { lg . Info ( " " , zap . String ( " " , host ) ) } else { plog . Infof ( " " , host ) } mux : = http . New Serve Mux ( ) etcdhttp . Handle Prometheus ( mux ) mux . Handle ( " " , ph ) plog . Fatal ( http . Serve ( l , mux ) ) } ( ) } return nil } 
func identify Data Dir Or Die ( lg * zap . Logger , dir string ) dir Type { names , err : = fileutil . Read Dir ( dir ) if err ! = nil { if os . Is Not Exist ( err ) { return dir Empty } if lg ! = nil { lg . Fatal ( " " , zap . String ( " " , dir ) , zap . Error ( err ) ) } else { plog . Fatalf ( " " , dir ) } } var m , p bool for _ , name : = range names { switch dir Type ( name ) { case dir Member : m = true case dir Proxy : p = true default : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , name ) , zap . String ( " " , dir ) , ) } else { plog . Warningf ( " " , name , dir ) } } } if m & & p { if lg ! = nil { lg . Fatal ( " " ) } else { plog . Fatal ( " " ) } } if m { return dir Member } if p { return dir Proxy } return dir Empty } 
func Repair ( lg * zap . Logger , dirpath string ) bool { f , err : = open Last ( lg , dirpath ) if err ! = nil { return false } defer f . Close ( ) if lg ! = nil { lg . Info ( " " , zap . String ( " " , f . Name ( ) ) ) } else { plog . Noticef ( " " , f . Name ( ) ) } rec : = & walpb . Record { } decoder : = new Decoder ( f ) for { last Offset : = decoder . last Offset ( ) err : = decoder . decode ( rec ) switch err { case nil : } decoder . update CRC ( rec . Crc ) } continue case io . EOF : if lg ! = nil { lg . Info ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( io . EOF ) ) } return true case io . Err Unexpected EOF : bf , bferr : = os . Create ( f . Name ( ) + " " ) if bferr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) + " " ) , zap . Error ( bferr ) ) } else { plog . Errorf ( " " , f . Name ( ) ) } return false } defer bf . Close ( ) if _ , err = f . Seek ( 0 , io . Seek Start ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , f . Name ( ) ) } return false } if _ , err = io . Copy ( bf , f ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) + " " ) , zap . String ( " " , f . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , f . Name ( ) ) } return false } if err = f . Truncate ( last Offset ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , f . Name ( ) ) } return false } if err = fileutil . Fsync ( f . File ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , f . Name ( ) ) } return false } if lg ! = nil { lg . Info ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( io . Err Unexpected EOF ) ) } return true default : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , f . Name ( ) ) , zap . Error ( err ) ) } else { plog . Errorf ( " " , err ) } return false } } } 
func open Last ( lg * zap . Logger , dirpath string ) ( * fileutil . Locked File , error ) { names , err : = read WALNames ( lg , dirpath ) if err ! = nil { return nil , err } last : = filepath . Join ( dirpath , names [ len ( names ) - 1 ] ) return fileutil . Lock File ( last , os . O _RDWR , fileutil . Private File Mode ) } 
func ( b * bridge ) io Copy ( dst io . Writer , src io . Reader ) ( err error ) { buf : = make ( [ ] byte , 3 2 * 1 0 2 4 ) for { select { case < - b . blackholec : io . Copy ( ioutil . Discard , src ) return nil default : } nr , er : = src . Read ( buf ) if nr > 0 { nw , ew : = dst . Write ( buf [ 0 : nr ] ) if ew ! = nil { return ew } if nr ! = nw { return io . Err Short Write } } if er ! = nil { err = er break } } return err } 
func ( l * leader ) got Leader ( ) { l . mu . Lock ( ) defer l . mu . Unlock ( ) select { case < - l . leaderc : l . leaderc = make ( chan struct { } ) default : } } 
func ( l * leader ) lost Notify ( ) < - chan struct { } { l . mu . RLock ( ) defer l . mu . RUnlock ( ) return l . leaderc } 
func new GRPCProxy Command ( ) * cobra . Command { lpc : = & cobra . Command { Use : " " , Short : " " , } lpc . Add Command ( new GRPCProxy Start Command ( ) ) return lpc } 
func New Member Command ( ) * cobra . Command { mc : = & cobra . Command { Use : " " , Short : " " , } mc . Add Command ( New Member Add Command ( ) ) mc . Add Command ( New Member Remove Command ( ) ) mc . Add Command ( New Member Update Command ( ) ) mc . Add Command ( New Member List Command ( ) ) return mc } 
func New Member Add Command ( ) * cobra . Command { cc : = & cobra . Command { Use : " " , Short : " " , Run : member Add Command Func , } cc . Flags ( ) . String Var ( & member Peer URLs , " " , " " , " " ) return cc } 
func New Member Remove Command ( ) * cobra . Command { cc : = & cobra . Command { Use : " " , Short : " " , Run : member Remove Command Func , } return cc } 
func New Member Update Command ( ) * cobra . Command { cc : = & cobra . Command { Use : " " , Short : " " , Run : member Update Command Func , } cc . Flags ( ) . String Var ( & member Peer URLs , " " , " " , " " ) return cc } 
func New Member List Command ( ) * cobra . Command { cc : = & cobra . Command { Use : " " , Short : " " , Long : `When - -write -out is set to simple , this command prints out comma -separated member lists for each endpoint . The items in the lists are ID , Status , Name , Peer Addrs , Client Addrs . ` , Run : member List Command Func , } return cc } 
func member Add Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < 1 { Exit With Error ( Exit Bad Args , errors . New ( " " ) ) } if len ( args ) > 1 { ev : = " " for _ , s : = range args { if strings . Has Prefix ( strings . To Lower ( s ) , " " ) { ev + = fmt . Sprintf ( ` , did you mean - -peer -urls = %s ` , s ) } } Exit With Error ( Exit Bad Args , errors . New ( ev ) ) } new Member Name : = args [ 0 ] if len ( member Peer URLs ) = = 0 { Exit With Error ( Exit Bad Args , errors . New ( " " ) ) } urls : = strings . Split ( member Peer URLs , " " ) ctx , cancel : = command Ctx ( cmd ) cli : = must Client From Cmd ( cmd ) resp , err : = cli . Member Add ( ctx , urls ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } new ID : = resp . Member . ID display . Member Add ( * resp ) if _ , ok : = ( display ) . ( * simple Printer ) ; ok { ctx , cancel = command Ctx ( cmd ) list Resp , err : = cli . Member List ( ctx ) } if list Resp . Header . Member Id = = resp . Header . Member Id { break } if gerr ! = nil { Exit With Error ( Exit Error , err ) } resp . Header . Member Id = gresp . Header . Member Id list Resp , err = cli . Member List ( ctx ) } cancel ( ) conf : = [ ] string { } for _ , memb : = range list Resp . Members { for _ , u : = range memb . Peer URLs { n : = memb . Name if memb . ID = = new ID { n = new Member Name } conf = append ( conf , fmt . Sprintf ( " " , n , u ) ) } } fmt . Print ( " \n " ) fmt . Printf ( " \n " , new Member Name ) fmt . Printf ( " \n " , strings . Join ( conf , " " ) ) fmt . Printf ( " \n " , member Peer URLs ) fmt . Printf ( " \ " \ " \n " ) } } 
func member Remove Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } id , err : = strconv . Parse Uint ( args [ 0 ] , 1 6 , 6 4 ) if err ! = nil { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " , err ) ) } ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Member Remove ( ctx , id ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Member Remove ( id , * resp ) } 
func member Update Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } id , err : = strconv . Parse Uint ( args [ 0 ] , 1 6 , 6 4 ) if err ! = nil { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " , err ) ) } if len ( member Peer URLs ) = = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } urls : = strings . Split ( member Peer URLs , " " ) ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Member Update ( ctx , id , urls ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Member Update ( id , * resp ) } 
func member List Command Func ( cmd * cobra . Command , args [ ] string ) { ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Member List ( ctx ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Member List ( * resp ) } 
func Create ( lg * zap . Logger , dirpath string , metadata [ ] byte ) ( * WAL , error ) { if Exist ( dirpath ) { return nil , os . Err Exist } if fileutil . Exist ( tmpdirpath ) { if err : = os . Remove All ( tmpdirpath ) ; err ! = nil { return nil , err } } if err : = fileutil . Create Dir All ( tmpdirpath ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , tmpdirpath ) , zap . String ( " " , dirpath ) , zap . Error ( err ) , ) } return nil , err } p : = filepath . Join ( tmpdirpath , wal Name ( 0 , 0 ) ) f , err : = fileutil . Lock File ( p , os . O _WRONLY | os . O _CREATE , fileutil . Private File Mode ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , p ) , zap . Error ( err ) , ) } return nil , err } if _ , err = f . Seek ( 0 , io . Seek End ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , p ) , zap . Error ( err ) , ) } return nil , err } if err = fileutil . Preallocate ( f . File , Segment Size Bytes , true ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , p ) , zap . Int 6 4 ( " " , Segment Size Bytes ) , zap . Error ( err ) , ) } return nil , err } w : = & WAL { lg : lg , dir : dirpath , metadata : metadata , } w . encoder , err = new File Encoder ( f . File , 0 ) if err ! = nil { return nil , err } w . locks = append ( w . locks , f ) if err = w . save Crc ( 0 ) ; err ! = nil { return nil , err } if err = w . encoder . encode ( & walpb . Record { Type : metadata Type , Data : metadata } ) ; err ! = nil { return nil , err } if err = w . Save Snapshot ( walpb . Snapshot { } ) ; err ! = nil { return nil , err } if w , err = w . rename WAL ( tmpdirpath ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , tmpdirpath ) , zap . String ( " " , w . dir ) , zap . Error ( err ) , ) } return nil , err } if perr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , filepath . Dir ( w . dir ) ) , zap . String ( " " , w . dir ) , zap . Error ( perr ) , ) } return nil , perr } if perr = fileutil . Fsync ( pdir ) ; perr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , filepath . Dir ( w . dir ) ) , zap . String ( " " , w . dir ) , zap . Error ( perr ) , ) } return nil , perr } if perr = pdir . Close ( ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , filepath . Dir ( w . dir ) ) , zap . String ( " " , w . dir ) , zap . Error ( perr ) , ) } return nil , perr } return w , nil } 
func Open ( lg * zap . Logger , dirpath string , snap walpb . Snapshot ) ( * WAL , error ) { w , err : = open At Index ( lg , dirpath , snap , true ) if err ! = nil { return nil , err } if w . dir File , err = fileutil . Open Dir ( w . dir ) ; err ! = nil { return nil , err } return w , nil } 
func Open For Read ( lg * zap . Logger , dirpath string , snap walpb . Snapshot ) ( * WAL , error ) { return open At Index ( lg , dirpath , snap , false ) } 
func ( w * WAL ) Read All ( ) ( metadata [ ] byte , state raftpb . Hard State , ents [ ] raftpb . Entry , err error ) { w . mu . Lock ( ) defer w . mu . Unlock ( ) rec : = & walpb . Record { } decoder : = w . decoder var match bool for err = decoder . decode ( rec ) ; err = = nil ; err = decoder . decode ( rec ) { switch rec . Type { case entry Type : e : = must Unmarshal Entry ( rec . Data ) if e . Index > w . start . Index { ents = append ( ents [ : e . Index - w . start . Index - 1 ] , e ) } w . enti = e . Index case state Type : state = must Unmarshal State ( rec . Data ) case metadata Type : if metadata ! = nil & & ! bytes . Equal ( metadata , rec . Data ) { state . Reset ( ) return nil , state , nil , Err Metadata Conflict } metadata = rec . Data case crc Type : crc : = decoder . crc . Sum 3 2 ( ) return nil , state , nil , Err CRCMismatch } decoder . update CRC ( rec . Crc ) case snapshot Type : var snap walpb . Snapshot pbutil . Must Unmarshal ( & snap , rec . Data ) if snap . Index = = w . start . Index { if snap . Term ! = w . start . Term { state . Reset ( ) return nil , state , nil , Err Snapshot Mismatch } match = true } default : state . Reset ( ) return nil , state , nil , fmt . Errorf ( " " , rec . Type ) } } switch w . tail ( ) { case nil : return nil , state , nil , err } default : return nil , state , nil , err } } if err = fileutil . Zero To End ( w . tail ( ) . File ) ; err ! = nil { return nil , state , nil , err } } err = nil if ! match { err = Err Snapshot Not Found } w . read Close = nil } w . start = walpb . Snapshot { } w . metadata = metadata if w . tail ( ) ! = nil { if err ! = nil { return } } w . decoder = nil return metadata , state , ents , err } 
func Verify ( lg * zap . Logger , wal Dir string , snap walpb . Snapshot ) error { var metadata [ ] byte var err error var match bool rec : = & walpb . Record { } names , name Index , err : = select WALFiles ( lg , wal Dir , snap ) if err ! = nil { return err } if err ! = nil { return err } for err = decoder . decode ( rec ) ; err = = nil ; err = decoder . decode ( rec ) { switch rec . Type { case metadata Type : if metadata ! = nil & & ! bytes . Equal ( metadata , rec . Data ) { return Err Metadata Conflict } metadata = rec . Data case crc Type : crc : = decoder . crc . Sum 3 2 ( ) } decoder . update CRC ( rec . Crc ) case snapshot Type : var loaded Snap walpb . Snapshot pbutil . Must Unmarshal ( & loaded Snap , rec . Data ) if loaded Snap . Index = = snap . Index { if loaded Snap . Term ! = snap . Term { return Err Snapshot Mismatch } match = true } } } if closer ! = nil { closer ( ) } } if ! match { return Err Snapshot Not Found } return nil } 
func ( w * WAL ) cut ( ) error { if serr ! = nil { return serr } if err : = w . tail ( ) . Truncate ( off ) ; err ! = nil { return err } if err : = w . sync ( ) ; err ! = nil { return err } fpath : = filepath . Join ( w . dir , wal Name ( w . seq ( ) + 1 , w . enti + 1 ) ) if err ! = nil { return err } prev Crc : = w . encoder . crc . Sum 3 2 ( ) w . encoder , err = new File Encoder ( w . tail ( ) . File , prev Crc ) if err ! = nil { return err } if err = w . save Crc ( prev Crc ) ; err ! = nil { return err } if err = w . encoder . encode ( & walpb . Record { Type : metadata Type , Data : w . metadata } ) ; err ! = nil { return err } if err = w . save State ( & w . state ) ; err ! = nil { return err } } off , err = w . tail ( ) . Seek ( 0 , io . Seek Current ) if err ! = nil { return err } if err = os . Rename ( new Tail . Name ( ) , fpath ) ; err ! = nil { return err } if err = fileutil . Fsync ( w . dir File ) ; err ! = nil { return err } if new Tail , err = fileutil . Lock File ( fpath , os . O _WRONLY , fileutil . Private File Mode ) ; err ! = nil { return err } if _ , err = new Tail . Seek ( off , io . Seek Start ) ; err ! = nil { return err } w . locks [ len ( w . locks ) - 1 ] = new Tail prev Crc = w . encoder . crc . Sum 3 2 ( ) w . encoder , err = new File Encoder ( w . tail ( ) . File , prev Crc ) if err ! = nil { return err } if w . lg ! = nil { w . lg . Info ( " " , zap . String ( " " , fpath ) ) } else { plog . Infof ( " " , fpath ) } return nil } 
func ( w * WAL ) Close ( ) error { w . mu . Lock ( ) defer w . mu . Unlock ( ) if w . fp ! = nil { w . fp . Close ( ) w . fp = nil } if w . tail ( ) ! = nil { if err : = w . sync ( ) ; err ! = nil { return err } } for _ , l : = range w . locks { if l = = nil { continue } if err : = l . Close ( ) ; err ! = nil { if w . lg ! = nil { w . lg . Warn ( " " , zap . Error ( err ) ) } else { plog . Errorf ( " " , err ) } } } return w . dir File . Close ( ) } 
func ( w * watcher ) notify ( e * Event , original Path bool , deleted bool ) bool { } return true } return false } 
func ( w * watcher ) Remove ( ) { w . hub . mutex . Lock ( ) defer w . hub . mutex . Unlock ( ) close ( w . event Chan ) if w . remove ! = nil { w . remove ( ) } } 
func Preallocate ( f * os . File , size In Bytes int 6 4 , extend File bool ) error { if size In Bytes = = 0 { } if extend File { return prealloc Extend ( f , size In Bytes ) } return prealloc Fixed ( f , size In Bytes ) } 
func ( s * v 2v 3Store ) mk Path Depth ( node Path string , depth int ) string { normal Form : = path . Clean ( path . Join ( " " , node Path ) ) n : = strings . Count ( normal Form , " " ) + depth return fmt . Sprintf ( " " , s . pfx , n , normal Form ) } 
func ( s * v 2v 3Store ) mk V 2Node ( kv * mvccpb . Key Value ) * v 2store . Node Extern { if kv = = nil { return nil } n : = & v 2store . Node Extern { Key : s . mk Node Path ( string ( kv . Key ) ) , Dir : kv . Key [ len ( kv . Key ) - 1 ] = = ' / ' , Created Index : mk V 2Rev ( kv . Create Revision ) , Modified Index : mk V 2Rev ( kv . Mod Revision ) , } if ! n . Dir { v : = string ( kv . Value ) n . Value = & v } return n } 
func prev Key From Puts ( resp * clientv 3 . Txn Response ) * mvccpb . Key Value { for _ , r : = range resp . Responses { pkv : = r . Get Response Put ( ) . Prev Kv if pkv ! = nil & & pkv . Create Revision > 0 { return pkv } } return nil } 
func New Weighted Report ( r Report , precision string ) Report { return & weighted Report { base Report : r , report : new Report ( precision ) , results : make ( chan Result , 1 6 ) , } } 
func Handle Health ( mux * http . Serve Mux , c * clientv 3 . Client ) { mux . Handle ( etcdhttp . Path Health , etcdhttp . New Health Handler ( func ( ) etcdhttp . Health { return check Health ( c ) } ) ) } 
func New URLs Map ( s string ) ( URLs Map , error ) { m : = parse ( s ) cl : = URLs Map { } for name , urls : = range m { us , err : = New URLs ( urls ) if err ! = nil { return nil , err } cl [ name ] = us } return cl , nil } 
func New URLs Map From String Map ( m map [ string ] string , sep string ) ( URLs Map , error ) { var err error um : = URLs Map { } for k , v : = range m { um [ k ] , err = New URLs ( strings . Split ( v , sep ) ) if err ! = nil { return nil , err } } return um , nil } 
func ( c URLs Map ) String ( ) string { var pairs [ ] string for name , urls : = range c { for _ , url : = range urls { pairs = append ( pairs , fmt . Sprintf ( " " , name , url . String ( ) ) ) } } sort . Strings ( pairs ) return strings . Join ( pairs , " " ) } 
func ( c URLs Map ) URLs ( ) [ ] string { var urls [ ] string for _ , us : = range c { for _ , u : = range us { urls = append ( urls , u . String ( ) ) } } sort . Strings ( urls ) return urls } 
func parse ( s string ) map [ string ] [ ] string { m : = make ( map [ string ] [ ] string ) for s ! = " " { key : = s if i : = strings . Index Any ( key , " " ) ; i > = 0 { key , s = key [ : i ] , key [ i + 1 : ] } else { s = " " } if key = = " " { continue } value : = " " if i : = strings . Index ( key , " " ) ; i > = 0 { key , value = key [ : i ] , key [ i + 1 : ] } m [ key ] = append ( m [ key ] , value ) } return m } 
func New Client Handler ( lg * zap . Logger , server etcdserver . Server Peer , timeout time . Duration ) http . Handler { mux : = http . New Serve Mux ( ) etcdhttp . Handle Basic ( mux , server ) handle V 2 ( lg , mux , server , timeout ) return request Logger ( lg , mux ) } 
func parse Key Request ( r * http . Request , clock clockwork . Clock ) ( etcdserverpb . Request , bool , error ) { var no Value On Success bool empty Req : = etcdserverpb . Request { } err : = r . Parse Form ( ) if err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Form , err . Error ( ) , ) } if ! strings . Has Prefix ( r . URL . Path , keys Prefix ) { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Form , " " , ) } p : = path . Join ( etcdserver . Store Keys Prefix , r . URL . Path [ len ( keys Prefix ) : ] ) var p Idx , w Idx uint 6 4 if p Idx , err = get Uint 6 4 ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Index Na N , `invalid value for "prev Index " ` , ) } if w Idx , err = get Uint 6 4 ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Index Na N , `invalid value for "wait Index " ` , ) } var rec , sort , wait , dir , quorum , stream bool if rec , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "recursive " ` , ) } if sort , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "sorted " ` , ) } if wait , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "wait " ` , ) } } if quorum , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "quorum " ` , ) } if stream , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "stream " ` , ) } if wait & & r . Method ! = " " { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , ` "wait " can only be used with GET requests ` , ) } p V : = r . Form Value ( " " ) if _ , ok : = r . Form [ " " ] ; ok & & p V = = " " { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Prev Value Required , ` "prev Value " cannot be empty ` , ) } if no Value On Success , err = get Bool ( r . Form , " " ) ; err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , `invalid value for "no Value On Success " ` , ) } if len ( r . Form Value ( " " ) ) > 0 { i , err : = get Uint 6 4 ( r . Form , " " ) if err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode TTLNa N , `invalid value for "ttl " ` , ) } ttl = & i } if _ , ok : = r . Form [ " " ] ; ok { bv , err : = get Bool ( r . Form , " " ) if err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , " " , ) } pe = & bv } if _ , ok : = r . Form [ " " ] ; ok { bv , err : = get Bool ( r . Form , " " ) if err ! = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Invalid Field , " " , ) } refresh = & bv if refresh ! = nil & & * refresh { val : = r . Form Value ( " " ) if _ , ok : = r . Form [ " " ] ; ok & & val ! = " " { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Refresh Value , `A value was provided on a refresh ` , ) } if ttl = = nil { return empty Req , false , v 2error . New Request Error ( v 2error . Ecode Refresh TTLRequired , `No TTL value set ` , ) } } } rr : = etcdserverpb . Request { Method : r . Method , Path : p , Val : r . Form Value ( " " ) , Dir : dir , Prev Value : p V , Prev Index : p Idx , Prev Exist : pe , Wait : wait , Since : w Idx , Recursive : rec , Sorted : sort , Quorum : quorum , Stream : stream , } if pe ! = nil { rr . Prev Exist = pe } if refresh ! = nil { rr . Refresh = refresh } rr . Expiration = clock . Now ( ) . Add ( expr ) . Unix Nano ( ) } return rr , no Value On Success , nil } 
func write Key Event ( w http . Response Writer , resp etcdserver . Response , no Value On Success bool ) error { ev : = resp . Event if ev = = nil { return errors . New ( " " ) } w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , fmt . Sprint ( ev . Etcd Index ) ) w . Header ( ) . Set ( " " , fmt . Sprint ( resp . Index ) ) w . Header ( ) . Set ( " " , fmt . Sprint ( resp . Term ) ) if ev . Is Created ( ) { w . Write Header ( http . Status Created ) } ev = trim Event Prefix ( ev , etcdserver . Store Keys Prefix ) if no Value On Success & & ( ev . Action = = v 2store . Set | | ev . Action = = v 2store . Compare And Swap | | ev . Action = = v 2store . Create | | ev . Action = = v 2store . Update ) { ev . Node = nil ev . Prev Node = nil } return json . New Encoder ( w ) . Encode ( ev ) } 
func write Key Error ( lg * zap . Logger , w http . Response Writer , err error ) { if err = = nil { return } switch e : = err . ( type ) { case * v 2error . Error : e . Write To ( w ) default : switch err { case etcdserver . Err Timeout Due To Leader Fail , etcdserver . Err Timeout Due To Connection Lost : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , err . Error ( ) ) , ) } else { mlog . Merge Error ( err ) } default : if lg ! = nil { lg . Warn ( " " , zap . String ( " " , err . Error ( ) ) , ) } else { mlog . Merge Errorf ( " " , err ) } } ee : = v 2error . New Error ( v 2error . Ecode Raft Internal , err . Error ( ) , 0 ) ee . Write To ( w ) } } 
func get Uint 6 4 ( form url . Values , key string ) ( i uint 6 4 , err error ) { if vals , ok : = form [ key ] ; ok { i , err = strconv . Parse Uint ( vals [ 0 ] , 1 0 , 6 4 ) } return } 
func get Bool ( form url . Values , key string ) ( b bool , err error ) { if vals , ok : = form [ key ] ; ok { b , err = strconv . Parse Bool ( vals [ 0 ] ) } return } 
func trim Prefix ( p , prefix string ) ( s string ) { s = strings . Trim Prefix ( p , prefix ) s = strings . Trim Prefix ( s , " " ) return } 
func wait Deletes ( ctx context . Context , client * v 3 . Client , pfx string , max Create Rev int 6 4 ) ( * pb . Response Header , error ) { get Opts : = append ( v 3 . With Last Create ( ) , v 3 . With Max Create Rev ( max Create Rev ) ) for { resp , err : = client . Get ( ctx , pfx , get Opts . . . ) if err ! = nil { return nil , err } if len ( resp . Kvs ) = = 0 { return resp . Header , nil } last Key : = string ( resp . Kvs [ 0 ] . Key ) if err = wait Delete ( ctx , client , last Key , resp . Header . Revision ) ; err ! = nil { return nil , err } } } 
func Add Output Paths ( cfg zap . Config , output Paths , error Output Paths [ ] string ) zap . Config { outputs : = make ( map [ string ] struct { } ) for _ , v : = range cfg . Output Paths { outputs [ v ] = struct { } { } } for _ , v : = range output Paths { outputs [ v ] = struct { } { } } output Slice : = make ( [ ] string , 0 ) if _ , ok : = outputs [ " " ] ; ok { } else { for k : = range outputs { output Slice = append ( output Slice , k ) } } cfg . Output Paths = output Slice sort . Strings ( cfg . Output Paths ) err Outputs : = make ( map [ string ] struct { } ) for _ , v : = range cfg . Error Output Paths { err Outputs [ v ] = struct { } { } } for _ , v : = range error Output Paths { err Outputs [ v ] = struct { } { } } err Output Slice : = make ( [ ] string , 0 ) if _ , ok : = err Outputs [ " " ] ; ok { } else { for k : = range err Outputs { err Output Slice = append ( err Output Slice , k ) } } cfg . Error Output Paths = err Output Slice sort . Strings ( cfg . Error Output Paths ) return cfg } 
func New Config ( ) * Config { lpurl , _ : = url . Parse ( Default Listen Peer URLs ) apurl , _ : = url . Parse ( Default Initial Advertise Peer URLs ) lcurl , _ : = url . Parse ( Default Listen Client URLs ) acurl , _ : = url . Parse ( Default Advertise Client URLs ) cfg : = & Config { Max Snap Files : Default Max Snapshots , Max Wal Files : Default Max WALs , Name : Default Name , Snapshot Count : etcdserver . Default Snapshot Count , Snapshot Catch Up Entries : etcdserver . Default Snapshot Catch Up Entries , Max Txn Ops : Default Max Txn Ops , Max Request Bytes : Default Max Request Bytes , GRPCKeep Alive Min Time : Default GRPCKeep Alive Min Time , GRPCKeep Alive Interval : Default GRPCKeep Alive Interval , GRPCKeep Alive Timeout : Default GRPCKeep Alive Timeout , Tick Ms : 1 0 0 , Election Ms : 1 0 0 0 , Initial Election Tick Advance : true , LPUrls : [ ] url . URL { * lpurl } , LCUrls : [ ] url . URL { * lcurl } , APUrls : [ ] url . URL { * apurl } , ACUrls : [ ] url . URL { * acurl } , Cluster State : Cluster State Flag New , Initial Cluster Token : " " , Strict Reconfig Check : Default Strict Reconfig Check , Metrics : " " , Enable V 2 : Default Enable V 2 , CORS : map [ string ] struct { } { " " : { } } , Host Whitelist : map [ string ] struct { } { " " : { } } , Auth Token : " " , Bcrypt Cost : uint ( bcrypt . Default Cost ) , Pre Vote : false , cfg . Initial Cluster = cfg . Initial Cluster From Name ( cfg . Name ) return cfg } 
func ( cfg * Config ) Validate ( ) error { if err : = cfg . setup Logging ( ) ; err ! = nil { return err } if err : = check Bind URLs ( cfg . LPUrls ) ; err ! = nil { return err } if err : = check Bind URLs ( cfg . LCUrls ) ; err ! = nil { return err } if err : = check Bind URLs ( cfg . Listen Metrics Urls ) ; err ! = nil { return err } if err : = check Host URLs ( cfg . APUrls ) ; err ! = nil { addrs : = cfg . get APURLs ( ) return fmt . Errorf ( ` - -initial -advertise -peer -urls %q must be "host :port " ( %v ) ` , strings . Join ( addrs , " " ) , err ) } if err : = check Host URLs ( cfg . ACUrls ) ; err ! = nil { addrs : = cfg . get ACURLs ( ) return fmt . Errorf ( ` - -advertise -client -urls %q must be "host :port " ( %v ) ` , strings . Join ( addrs , " " ) , err ) } for _ , v : = range [ ] bool { cfg . Durl ! = " " , cfg . Initial Cluster ! = " " , cfg . DNSCluster ! = " " } { if v { n Set + + } } if cfg . Cluster State ! = Cluster State Flag New & & cfg . Cluster State ! = Cluster State Flag Existing { return fmt . Errorf ( " " , cfg . Cluster State ) } if n Set > 1 { return Err Conflict Bootstrap Flags } if cfg . Tick Ms < = 0 { return fmt . Errorf ( " " , cfg . Tick Ms ) } if cfg . Election Ms < = 0 { return fmt . Errorf ( " " , cfg . Election Ms ) } if 5 * cfg . Tick Ms > cfg . Election Ms { return fmt . Errorf ( " " , cfg . Election Ms , cfg . Tick Ms ) } if cfg . Election Ms > max Election Ms { return fmt . Errorf ( " " , cfg . Election Ms , max Election Ms ) } } switch cfg . Auto Compaction Mode { case " " : case Compactor Mode Revision , Compactor Mode Periodic : default : return fmt . Errorf ( " " , cfg . Auto Compaction Mode ) } return nil } 
func ( cfg * Config ) Peer URLs Map And Token ( which string ) ( urlsmap types . URLs Map , token string , err error ) { token = cfg . Initial Cluster Token switch { case cfg . Durl ! = " " : urlsmap = types . URLs Map { } token = cfg . Durl case cfg . DNSCluster ! = " " : cluster Strs , cerr : = cfg . Get DNSCluster Names ( ) lg : = cfg . logger if cerr ! = nil { if lg ! = nil { lg . Warn ( " " , zap . Error ( cerr ) ) } else { plog . Errorf ( " " , cerr ) } return nil , " " , cerr } for _ , s : = range cluster Strs { if lg ! = nil { lg . Info ( " " , zap . String ( " " , s ) ) } else { plog . Noticef ( " " , s ) } } cluster Str : = strings . Join ( cluster Strs , " " ) if strings . Contains ( cluster Str , " " ) & & cfg . Peer TLSInfo . Trusted CAFile = = " " { cfg . Peer TLSInfo . Server Name = cfg . DNSCluster } urlsmap , err = types . New URLs Map ( cluster Str ) } } default : } return urlsmap , token , err } 
func ( cfg * Config ) Get DNSCluster Names ( ) ( [ ] string , error ) { var ( cluster Strs [ ] string cerr error service Name Suffix string ) if cfg . DNSCluster Service Name ! = " " { service Name Suffix = " " + cfg . DNSCluster Service Name } lg : = cfg . Get Logger ( ) if cerr ! = nil { cluster Strs = make ( [ ] string , 0 ) } if lg ! = nil { lg . Info ( " " , zap . String ( " " , " " ) , zap . String ( " " , " " + service Name Suffix ) , zap . String ( " " , cfg . Name ) , zap . String ( " " , cfg . DNSCluster ) , zap . Strings ( " " , cfg . get APURLs ( ) ) , zap . Strings ( " " , cluster Strs ) , zap . Error ( cerr ) , ) } default HTTPCluster Strs , http Cerr : = srv . Get Cluster ( " " , " " + service Name Suffix , cfg . Name , cfg . DNSCluster , cfg . APUrls ) if http Cerr ! = nil { cluster Strs = append ( cluster Strs , default HTTPCluster Strs . . . ) } if lg ! = nil { lg . Info ( " " , zap . String ( " " , " " ) , zap . String ( " " , " " + service Name Suffix ) , zap . String ( " " , cfg . Name ) , zap . String ( " " , cfg . DNSCluster ) , zap . Strings ( " " , cfg . get APURLs ( ) ) , zap . Strings ( " " , cluster Strs ) , zap . Error ( http Cerr ) , ) } return cluster Strs , cerr } 
func ( cfg * Config ) Update Default Cluster From Name ( default Initial Cluster string ) ( string , error ) { if default Hostname = = " " | | default Host Status ! = nil { } return " " , default Host Status } used : = false pip , pport : = cfg . LPUrls [ 0 ] . Hostname ( ) , cfg . LPUrls [ 0 ] . Port ( ) if cfg . default Peer Host ( ) & & pip = = " " { cfg . APUrls [ 0 ] = url . URL { Scheme : cfg . APUrls [ 0 ] . Scheme , Host : fmt . Sprintf ( " " , default Hostname , pport ) } used = true } } cip , cport : = cfg . LCUrls [ 0 ] . Hostname ( ) , cfg . LCUrls [ 0 ] . Port ( ) if cfg . default Client Host ( ) & & cip = = " " { cfg . ACUrls [ 0 ] = url . URL { Scheme : cfg . ACUrls [ 0 ] . Scheme , Host : fmt . Sprintf ( " " , default Hostname , cport ) } used = true } dhost : = default Hostname if ! used { dhost = " " } return dhost , default Host Status } 
func check Bind URLs ( urls [ ] url . URL ) error { for _ , url : = range urls { if url . Scheme = = " " | | url . Scheme = = " " { continue } host , _ , err : = net . Split Host Port ( url . Host ) if err ! = nil { return err } if host = = " " { } if net . Parse IP ( host ) = = nil { return fmt . Errorf ( " " , url . String ( ) ) } } return nil } 
func Get Cluster ( service Scheme , service , name , dns string , apurls types . URLs ) ( [ ] string , error ) { temp Name : = int ( 0 ) tcp 2ap : = make ( map [ string ] url . URL ) if err ! = nil { return nil , err } tcp 2ap [ tcp Addr . String ( ) ] = url } string Parts : = [ ] string { } update Node Map : = func ( service , scheme string ) error { _ , addrs , err : = lookup SRV ( service , " " , dns ) if err ! = nil { return err } for _ , srv : = range addrs { port : = fmt . Sprintf ( " " , srv . Port ) host : = net . Join Host Port ( srv . Target , port ) tcp Addr , terr : = resolve TCPAddr ( " " , host ) if terr ! = nil { err = terr continue } n : = " " url , ok : = tcp 2ap [ tcp Addr . String ( ) ] if ok { n = name } if n = = " " { n = fmt . Sprintf ( " " , temp Name ) temp Name + + } url Host : = net . Join Host Port ( short Host , port ) if ok & & url . Scheme ! = scheme { err = fmt . Errorf ( " " , scheme + " " + url Host , service , url . String ( ) ) } else { string Parts = append ( string Parts , fmt . Sprintf ( " " , n , scheme , url Host ) ) } } if len ( string Parts ) = = 0 { return err } return nil } err : = update Node Map ( service , service Scheme ) if err ! = nil { return nil , fmt . Errorf ( " " , service , err ) } return string Parts , nil } 
func Get Client ( service , domain string , service Name string ) ( * SRVClients , error ) { var urls [ ] * url . URL var srvs [ ] * net . SRV update URLs : = func ( service , scheme string ) error { _ , addrs , err : = lookup SRV ( service , " " , domain ) if err ! = nil { return err } for _ , srv : = range addrs { urls = append ( urls , & url . URL { Scheme : scheme , Host : net . Join Host Port ( srv . Target , fmt . Sprintf ( " " , srv . Port ) ) , } ) } srvs = append ( srvs , addrs . . . ) return nil } err HTTPS : = update URLs ( Get SRVService ( service , service Name , " " ) , " " ) err HTTP : = update URLs ( Get SRVService ( service , service Name , " " ) , " " ) if err HTTPS ! = nil & & err HTTP ! = nil { return nil , fmt . Errorf ( " " , err HTTPS , err HTTP ) } endpoints : = make ( [ ] string , len ( urls ) ) for i : = range urls { endpoints [ i ] = urls [ i ] . String ( ) } return & SRVClients { Endpoints : endpoints , SRVs : srvs } , nil } 
func Get SRVService ( service , service Name string , scheme string ) ( SRVService string ) { if scheme = = " " { service = fmt . Sprintf ( " " , service ) } if service Name ! = " " { return fmt . Sprintf ( " " , service , service Name ) } return service } 
func Read Dir ( d string , opts . . . Read Dir Option ) ( [ ] string , error ) { op : = & Read Dir Op { } op . apply Opts ( opts ) dir , err : = os . Open ( d ) if err ! = nil { return nil , err } defer dir . Close ( ) names , err : = dir . Readdirnames ( - 1 ) if err ! = nil { return nil , err } sort . Strings ( names ) if op . ext ! = " " { tss : = make ( [ ] string , 0 ) for _ , v : = range names { if filepath . Ext ( v ) = = op . ext { tss = append ( tss , v ) } } names = tss } return names , nil } 
func New Journal Writer ( wr io . Writer ) ( io . Writer , error ) { return & journal Writer { Writer : wr } , systemd . Dial Journal ( ) } 
func ( s * Etcd Server ) create Merged Snapshot Message ( m raftpb . Message , snapt , snapi uint 6 4 , conf State raftpb . Conf State ) snap . Message { d , err : = clone . Save No Copy ( ) if err ! = nil { if lg : = s . get Logger ( ) ; lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } dbsnap : = s . be . Snapshot ( ) m . Snapshot = snapshot return * snap . New Message ( m , rc , dbsnap . Size ( ) ) } 
func endpoint Memory Metrics ( host string ) float 6 4 { resident Memory Key : = " " var resident Memory Value string if ! strings . Has Prefix ( host , `http : } url : = host + " " resp , err : = http . Get ( url ) if err ! = nil { fmt . Println ( fmt . Sprintf ( " " , err ) ) return 0 . 0 } byts , readerr : = ioutil . Read All ( resp . Body ) resp . Body . Close ( ) if readerr ! = nil { fmt . Println ( fmt . Sprintf ( " " , url , readerr ) ) return 0 . 0 } for _ , line : = range strings . Split ( string ( byts ) , " \n " ) { if strings . Has Prefix ( line , resident Memory Key ) { resident Memory Value = strings . Trim Space ( strings . Trim Prefix ( line , resident Memory Key ) ) break } } if resident Memory Value = = " " { fmt . Println ( fmt . Sprintf ( " " , resident Memory Key ) ) return 0 . 0 } resident Memory Bytes , parse Err : = strconv . Parse Float ( resident Memory Value , 6 4 ) if parse Err ! = nil { fmt . Println ( fmt . Sprintf ( " " , parse Err ) ) return 0 . 0 } return resident Memory Bytes } 
func compact ( c * v 3 . Client , rev int 6 4 ) { fmt . Printf ( " \n " , rev ) ctx , cancel : = context . With Timeout ( context . Background ( ) , 3 0 * time . Second ) _ , err : = c . Compact ( ctx , rev , v 3 . With Compact Physical ( ) ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } fmt . Printf ( " \n " , rev ) } 
func defrag ( c * v 3 . Client , ep string ) { fmt . Printf ( " \n " , ep ) ctx , cancel : = context . With Timeout ( context . Background ( ) , 3 0 * time . Second ) _ , err : = c . Defragment ( ctx , ep ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } fmt . Printf ( " \n " , ep ) } 
func New User Command ( ) * cobra . Command { ac : = & cobra . Command { Use : " " , Short : " " , } ac . Add Command ( new User Add Command ( ) ) ac . Add Command ( new User Delete Command ( ) ) ac . Add Command ( new User Get Command ( ) ) ac . Add Command ( new User List Command ( ) ) ac . Add Command ( new User Change Password Command ( ) ) ac . Add Command ( new User Grant Role Command ( ) ) ac . Add Command ( new User Revoke Role Command ( ) ) return ac } 
func user Add Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } var password string var user string if password From Flag ! = " " { user = args [ 0 ] password = password From Flag } else { splitted : = strings . Split N ( args [ 0 ] , " " , 2 ) if len ( splitted ) < 2 { user = args [ 0 ] if ! password Interactive { fmt . Scanf ( " " , & password ) } else { password = read Password Interactive ( args [ 0 ] ) } } else { user = splitted [ 0 ] password = splitted [ 1 ] if len ( user ) = = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } } } resp , err : = must Client From Cmd ( cmd ) . Auth . User Add ( context . TODO ( ) , user , password ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . User Add ( user , * resp ) } 
func user Get Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } name : = args [ 0 ] client : = must Client From Cmd ( cmd ) resp , err : = client . Auth . User Get ( context . TODO ( ) , name ) if err ! = nil { Exit With Error ( Exit Error , err ) } if user Show Detail { fmt . Printf ( " \n " , name ) for _ , role : = range resp . Roles { fmt . Printf ( " \n " ) role Resp , err : = client . Auth . Role Get ( context . TODO ( ) , role ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Role Get ( role , * role Resp ) } } else { display . User Get ( name , * resp ) } } 
func user Change Password Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } var password string if ! password Interactive { fmt . Scanf ( " " , & password ) } else { password = read Password Interactive ( args [ 0 ] ) } resp , err : = must Client From Cmd ( cmd ) . Auth . User Change Password ( context . TODO ( ) , args [ 0 ] , password ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . User Change Password ( * resp ) } 
func ( eh * Event History ) add Event ( e * Event ) * Event { eh . rwl . Lock ( ) defer eh . rwl . Unlock ( ) eh . Queue . insert ( e ) eh . Last Index = e . Index ( ) eh . Start Index = eh . Queue . Events [ eh . Queue . Front ] . Index ( ) return e } 
func ( eh * Event History ) scan ( key string , recursive bool , index uint 6 4 ) ( * Event , * v 2error . Error ) { eh . rwl . RLock ( ) defer eh . rwl . RUnlock ( ) } } offset : = index - eh . Start Index i : = ( eh . Queue . Front + int ( offset ) ) % eh . Queue . Capacity for { e : = eh . Queue . Events [ i ] if ! e . Refresh { ok : = e . Node . Key = = key if recursive { if nkey [ len ( nkey ) - 1 ] ! = ' / ' { nkey = nkey + " " } ok = ok | | strings . Has Prefix ( e . Node . Key , nkey ) } if ( e . Action = = Delete | | e . Action = = Expire ) & & e . Prev Node ! = nil & & e . Prev Node . Dir { ok = ok | | strings . Has Prefix ( key , e . Prev Node . Key ) } if ok { return e , nil } } i = ( i + 1 ) % eh . Queue . Capacity if i = = eh . Queue . Back { return nil , nil } } } 
func ( eh * Event History ) clone ( ) * Event History { cloned Queue : = event Queue { Capacity : eh . Queue . Capacity , Events : make ( [ ] * Event , eh . Queue . Capacity ) , Size : eh . Queue . Size , Front : eh . Queue . Front , Back : eh . Queue . Back , } copy ( cloned Queue . Events , eh . Queue . Events ) return & Event History { Start Index : eh . Start Index , Queue : cloned Queue , Last Index : eh . Last Index , } } 
func open Snapshot Backend ( cfg Server Config , ss * snap . Snapshotter , snapshot raftpb . Snapshot ) ( backend . Backend , error ) { snap Path , err : = ss . DBFile Path ( snapshot . Metadata . Index ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err : = os . Rename ( snap Path , cfg . backend Path ( ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return open Backend ( cfg ) , nil } 
func open Backend ( cfg Server Config ) backend . Backend { fn : = cfg . backend Path ( ) now , be Opened : = time . Now ( ) , make ( chan backend . Backend ) go func ( ) { be Opened < - new Backend ( cfg ) } ( ) select { case be : = < - be Opened : if cfg . Logger ! = nil { cfg . Logger . Info ( " " , zap . String ( " " , fn ) , zap . Duration ( " " , time . Since ( now ) ) ) } return be case < - time . After ( 1 0 * time . Second ) : if cfg . Logger ! = nil { cfg . Logger . Info ( " " , zap . String ( " " , fn ) , zap . Duration ( " " , time . Since ( now ) ) , ) } else { plog . Warningf ( " " , fn ) plog . Warningf ( " " ) } } return < - be Opened } 
func recover Snapshot Backend ( cfg Server Config , oldbe backend . Backend , snapshot raftpb . Snapshot ) ( backend . Backend , error ) { var c Index consistent Index kv : = mvcc . New ( cfg . Logger , oldbe , & lease . Fake Lessor { } , & c Index ) defer kv . Close ( ) if snapshot . Metadata . Index < = kv . Consistent Index ( ) { return oldbe , nil } oldbe . Close ( ) return open Snapshot Backend ( cfg , snap . New ( cfg . Logger , cfg . Snap Dir ( ) ) , snapshot ) } 
func New Update Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Flags : [ ] cli . Flag { cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , } , Action : func ( c * cli . Context ) error { update Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func update Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] value , err : = arg Or Stdin ( c . Args ( ) , os . Stdin , 1 ) if err ! = nil { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } ttl : = c . Int ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Set ( ctx , key , value , & client . Set Options { TTL : time . Duration ( ttl ) * time . Second , Prev Exist : client . Prev Exist } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } print Response Key ( resp , c . Global String ( " " ) ) } 
func ( q * stats Queue ) front And Back ( ) ( * Request Stats , * Request Stats ) { q . rwl . RLock ( ) defer q . rwl . RUnlock ( ) if q . size ! = 0 { return q . items [ q . front ] , q . items [ q . back ] } return nil , nil } 
func ( q * stats Queue ) Insert ( p * Request Stats ) { q . rwl . Lock ( ) defer q . rwl . Unlock ( ) q . back = ( q . back + 1 ) % queue Capacity if q . size = = queue Capacity { q . front = ( q . back + 1 ) % queue Capacity } else { q . size + + } q . items [ q . back ] = p q . total Req Size + = q . items [ q . back ] . Size } 
func ( q * stats Queue ) Rate ( ) ( float 6 4 , float 6 4 ) { front , back : = q . front And Back ( ) if front = = nil | | back = = nil { return 0 , 0 } if time . Since ( back . Sending Time ) > time . Second { q . Clear ( ) return 0 , 0 } sample Duration : = back . Sending Time . Sub ( front . Sending Time ) pr : = float 6 4 ( q . Len ( ) ) / float 6 4 ( sample Duration ) * float 6 4 ( time . Second ) br : = float 6 4 ( q . Req Size ( ) ) / float 6 4 ( sample Duration ) * float 6 4 ( time . Second ) return pr , br } 
func ( q * stats Queue ) Clear ( ) { q . rwl . Lock ( ) defer q . rwl . Unlock ( ) q . back = - 1 q . front = 0 q . size = 0 q . total Req Size = 0 } 
func Unique Strings ( slen uint , n int ) ( ss [ ] string ) { exist : = make ( map [ string ] struct { } ) ss = make ( [ ] string , 0 , n ) for len ( ss ) < n { s : = rand String ( slen ) if _ , ok : = exist [ s ] ; ! ok { ss = append ( ss , s ) exist [ s ] = struct { } { } } } return ss } 
func Random Strings ( slen uint , n int ) ( ss [ ] string ) { ss = make ( [ ] string , 0 , n ) for i : = 0 ; i < n ; i + + { ss = append ( ss , rand String ( slen ) ) } return ss } 
func Is Key Not Found ( err error ) bool { if c Err , ok : = err . ( Error ) ; ok { return c Err . Code = = Error Code Key Not Found } return false } 
func Is Role Not Found ( err error ) bool { if ae , ok : = err . ( auth Error ) ; ok { return role Not Found Reg Exp . Match String ( ae . Message ) } return false } 
func Is User Not Found ( err error ) bool { if ae , ok : = err . ( auth Error ) ; ok { return user Not Found Reg Exp . Match String ( ae . Message ) } return false } 
func Join Cluster ( lg * zap . Logger , durl , dproxyurl string , id types . ID , config string ) ( string , error ) { d , err : = new Discovery ( lg , durl , dproxyurl , id ) if err ! = nil { return " " , err } return d . join Cluster ( config ) } 
func Get Cluster ( lg * zap . Logger , durl , dproxyurl string ) ( string , error ) { d , err : = new Discovery ( lg , durl , dproxyurl , 0 ) if err ! = nil { return " " , err } return d . get Cluster ( ) } 
func new Proxy Func ( lg * zap . Logger , proxy string ) ( func ( * http . Request ) ( * url . URL , error ) , error ) { if proxy = = " " { return nil , nil } if err ! = nil | | ! strings . Has Prefix ( proxy URL . Scheme , " " ) { proxy URL , err 2 = url . Parse ( " " + proxy ) if err 2 = = nil { err = nil } } if err ! = nil { return nil , fmt . Errorf ( " " , proxy , err ) } if lg ! = nil { lg . Info ( " " , zap . String ( " " , proxy URL . String ( ) ) ) } else { plog . Infof ( " " , proxy URL . String ( ) ) } return http . Proxy URL ( proxy URL ) , nil } 
func ( c * Client ) unary Client Interceptor ( logger * zap . Logger , opt Funcs . . . retry Option ) grpc . Unary Client Interceptor { int Opts : = reuse Or New With Call Options ( default Options , opt Funcs ) return func ( ctx context . Context , method string , req , reply interface { } , cc * grpc . Client Conn , invoker grpc . Unary Invoker , opts . . . grpc . Call Option ) error { grpc Opts , retry Opts : = filter Call Options ( opts ) call Opts : = reuse Or New With Call Options ( int Opts , retry Opts ) } var last Err error for attempt : = uint ( 0 ) ; attempt < call Opts . max ; attempt + + { if err : = wait Retry Backoff ( ctx , attempt , call Opts ) ; err ! = nil { return err } logger . Debug ( " " , zap . String ( " " , cc . Target ( ) ) , zap . Uint ( " " , attempt ) , ) last Err = invoker ( ctx , method , req , reply , cc , grpc Opts . . . ) if last Err = = nil { return nil } logger . Warn ( " " , zap . String ( " " , cc . Target ( ) ) , zap . Uint ( " " , attempt ) , zap . Error ( last Err ) , ) if is Context Error ( last Err ) { if ctx . Err ( ) ! = nil { } } if call Opts . retry Auth & & rpctypes . Error ( last Err ) = = rpctypes . Err Invalid Auth Token { gterr : = c . get Token ( ctx ) if gterr ! = nil { logger . Warn ( " " , zap . String ( " " , cc . Target ( ) ) , zap . Error ( gterr ) , ) return last Err } continue } if ! is Safe Retry ( c . lg , last Err , call Opts ) { return last Err } } return last Err } } 
func ( c * Client ) stream Client Interceptor ( logger * zap . Logger , opt Funcs . . . retry Option ) grpc . Stream Client Interceptor { int Opts : = reuse Or New With Call Options ( default Options , opt Funcs ) return func ( ctx context . Context , desc * grpc . Stream Desc , cc * grpc . Client Conn , method string , streamer grpc . Streamer , opts . . . grpc . Call Option ) ( grpc . Client Stream , error ) { grpc Opts , retry Opts : = filter Call Options ( opts ) call Opts : = reuse Or New With Call Options ( int Opts , retry Opts ) } if desc . Client Streams { return nil , grpc . Errorf ( codes . Unimplemented , " " ) } new Streamer , err : = streamer ( ctx , desc , cc , method , grpc Opts . . . ) logger . Warn ( " " , zap . Error ( err ) ) if err ! = nil { } retrying Streamer : = & server Streaming Retrying Stream { client : c , Client Stream : new Streamer , call Opts : call Opts , ctx : ctx , streamer Call : func ( ctx context . Context ) ( grpc . Client Stream , error ) { return streamer ( ctx , desc , cc , method , grpc Opts . . . ) } , } return retrying Streamer , nil } } 
func is Safe Retry ( lg * zap . Logger , err error , call Opts * options ) bool { if is Context Error ( err ) { return false } switch call Opts . retry Policy { case repeatable : return is Safe Retry Immutable RPC ( err ) case non Repeatable : return is Safe Retry Mutable RPC ( err ) default : lg . Warn ( " " , zap . String ( " " , call Opts . retry Policy . String ( ) ) ) return false } } 
func with Retry Policy ( rp retry Policy ) retry Option { return retry Option { apply Func : func ( o * options ) { o . retry Policy = rp } } } 
func with Auth Retry ( retry Auth bool ) retry Option { return retry Option { apply Func : func ( o * options ) { o . retry Auth = retry Auth } } } 
func with Max ( max Retries uint ) retry Option { return retry Option { apply Func : func ( o * options ) { o . max = max Retries } } } 
func with Backoff ( bf backoff Func ) retry Option { return retry Option { apply Func : func ( o * options ) { o . backoff Func = bf } } } 
func backoff Linear With Jitter ( wait Between time . Duration , jitter Fraction float 6 4 ) backoff Func { return func ( attempt uint ) time . Duration { return jitter Up ( wait Between , jitter Fraction ) } } 
func ( ss * Server Stats ) Recv Append Req ( leader string , req Size int ) { ss . Lock ( ) defer ss . Unlock ( ) now : = time . Now ( ) ss . State = raft . State Follower if leader ! = ss . Leader Info . Name { ss . Leader Info . Name = leader ss . Leader Info . Start Time = now } ss . recv Rate Queue . Insert ( & Request Stats { Sending Time : now , Size : req Size , } , ) ss . Recv Append Request Cnt + + } 
func ( ss * Server Stats ) Send Append Req ( req Size int ) { ss . Lock ( ) defer ss . Unlock ( ) ss . become Leader ( ) ss . send Rate Queue . Insert ( & Request Stats { Sending Time : time . Now ( ) , Size : req Size , } , ) ss . Send Append Request Cnt + + } 
func New Package Logger ( repo , pkg string ) Logger { return & package Logger { p : capnslog . New Package Logger ( repo , pkg ) } } 
func ( bb * bucket Buffer ) merge ( bbsrc * bucket Buffer ) { for i : = 0 ; i < bbsrc . used ; i + + { bb . add ( bbsrc . buf [ i ] . key , bbsrc . buf [ i ] . val ) } if bb . used = = bbsrc . used { return } if bytes . Compare ( bb . buf [ ( bb . used - bbsrc . used ) - 1 ] . key , bbsrc . buf [ 0 ] . key ) < 0 { return } sort . Stable ( bb ) for ridx : = 1 ; ridx < bb . used ; ridx + + { if ! bytes . Equal ( bb . buf [ ridx ] . key , bb . buf [ widx ] . key ) { widx + + } bb . buf [ widx ] = bb . buf [ ridx ] } bb . used = widx + 1 } 
func delete Rev Key ( kv v 3 . KV , key string , rev int 6 4 ) ( bool , error ) { cmp : = v 3 . Compare ( v 3 . Mod Revision ( key ) , " " , rev ) req : = v 3 . Op Delete ( key ) txnresp , err : = kv . Txn ( context . TODO ( ) ) . If ( cmp ) . Then ( req ) . Commit ( ) if err ! = nil { return false , err } else if ! txnresp . Succeeded { return false , nil } return true , nil } 
func is Member Bootstrapped ( lg * zap . Logger , cl * membership . Raft Cluster , member string , rt http . Round Tripper , timeout time . Duration ) bool { rcl , err : = get Cluster From Remote Peers ( lg , get Remote Peer URLs ( cl , member ) , timeout , false , rt ) if err ! = nil { return false } id : = cl . Member By Name ( member ) . ID m : = rcl . Member ( id ) if m = = nil { return false } if len ( m . Client URLs ) > 0 { return true } return false } 
func Get Cluster From Remote Peers ( lg * zap . Logger , urls [ ] string , rt http . Round Tripper ) ( * membership . Raft Cluster , error ) { return get Cluster From Remote Peers ( lg , urls , 1 0 * time . Second , true , rt ) } 
func get Cluster From Remote Peers ( lg * zap . Logger , urls [ ] string , timeout time . Duration , logerr bool , rt http . Round Tripper ) ( * membership . Raft Cluster , error ) { cc : = & http . Client { Transport : rt , Timeout : timeout , } for _ , u : = range urls { addr : = u + " " resp , err : = cc . Get ( addr ) if err ! = nil { if logerr { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( " " , u , err ) } } continue } b , err : = ioutil . Read All ( resp . Body ) resp . Body . Close ( ) if err ! = nil { if logerr { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( " " , err ) } } continue } var membs [ ] * membership . Member if err = json . Unmarshal ( b , & membs ) ; err ! = nil { if logerr { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . Error ( err ) ) } else { plog . Warningf ( " " , err ) } } continue } id , err : = types . IDFrom String ( resp . Header . Get ( " " ) ) if err ! = nil { if logerr { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . String ( " " , resp . Header . Get ( " " ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , err ) } } continue } } return nil , fmt . Errorf ( " " ) } return nil , fmt . Errorf ( " " ) } 
func get Remote Peer URLs ( cl * membership . Raft Cluster , local string ) [ ] string { us : = make ( [ ] string , 0 ) for _ , m : = range cl . Members ( ) { if m . Name = = local { continue } us = append ( us , m . Peer URLs . . . ) } sort . Strings ( us ) return us } 
func get Versions ( lg * zap . Logger , cl * membership . Raft Cluster , local types . ID , rt http . Round Tripper ) map [ string ] * version . Versions { members : = cl . Members ( ) vers : = make ( map [ string ] * version . Versions ) for _ , m : = range members { if m . ID = = local { cv : = " " if cl . Version ( ) ! = nil { cv = cl . Version ( ) . String ( ) } vers [ m . ID . String ( ) ] = & version . Versions { Server : version . Version , Cluster : cv } continue } ver , err : = get Version ( lg , m , rt ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , m . ID . String ( ) ) , zap . Error ( err ) ) } else { plog . Warningf ( " " , m . ID , err ) } vers [ m . ID . String ( ) ] = nil } else { vers [ m . ID . String ( ) ] = ver } } return vers } 
func decide Cluster Version ( lg * zap . Logger , vers map [ string ] * version . Versions ) * semver . Version { var cv * semver . Version lv : = semver . Must ( semver . New Version ( version . Version ) ) for mid , ver : = range vers { if ver = = nil { return nil } v , err : = semver . New Version ( ver . Server ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , mid ) , zap . String ( " " , ver . Server ) , zap . Error ( err ) , ) } else { plog . Errorf ( " " , mid , err ) } return nil } if lv . Less Than ( * v ) { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , lv . String ( ) ) , zap . String ( " " , mid ) , zap . String ( " " , ver . Server ) , ) } else { plog . Warningf ( " " , lv . String ( ) ) plog . Warningf ( " " , mid , ver . Server ) } } if cv = = nil { cv = v } else if v . Less Than ( * cv ) { cv = v } } return cv } 
func is Compatible With Cluster ( lg * zap . Logger , cl * membership . Raft Cluster , local types . ID , rt http . Round Tripper ) bool { vers : = get Versions ( lg , cl , local , rt ) min V : = semver . Must ( semver . New Version ( version . Min Cluster Version ) ) max V : = semver . Must ( semver . New Version ( version . Version ) ) max V = & semver . Version { Major : max V . Major , Minor : max V . Minor , } return is Compatible With Vers ( lg , vers , local , min V , max V ) } 
func get Version ( lg * zap . Logger , m * membership . Member , rt http . Round Tripper ) ( * version . Versions , error ) { cc : = & http . Client { Transport : rt , } var ( err error resp * http . Response ) for _ , u : = range m . Peer URLs { addr : = u + " " resp , err = cc . Get ( addr ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . String ( " " , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , u , m . ID , err ) } continue } var b [ ] byte b , err = ioutil . Read All ( resp . Body ) resp . Body . Close ( ) if err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . String ( " " , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , u , m . ID , err ) } continue } var vers version . Versions if err = json . Unmarshal ( b , & vers ) ; err ! = nil { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , addr ) , zap . String ( " " , m . ID . String ( ) ) , zap . Error ( err ) , ) } else { plog . Warningf ( " " , u , m . ID , err ) } continue } return & vers , nil } return nil , err } 
func New Timeout Detector ( max Duration time . Duration ) * Timeout Detector { return & Timeout Detector { max Duration : max Duration , records : make ( map [ uint 6 4 ] time . Time ) , } } 
func ( td * Timeout Detector ) Reset ( ) { td . mu . Lock ( ) defer td . mu . Unlock ( ) td . records = make ( map [ uint 6 4 ] time . Time ) } 
func ( td * Timeout Detector ) Observe ( which uint 6 4 ) ( bool , time . Duration ) { td . mu . Lock ( ) defer td . mu . Unlock ( ) ok : = true now : = time . Now ( ) exceed : = time . Duration ( 0 ) if pt , found : = td . records [ which ] ; found { exceed = now . Sub ( pt ) - td . max Duration if exceed > 0 { ok = false } } td . records [ which ] = now return ok , exceed } 
func New Peer Handler ( lg * zap . Logger , s etcdserver . Server Peer ) http . Handler { return new Peer Handler ( lg , s . Cluster ( ) , s . Raft Handler ( ) , s . Lease Handler ( ) ) } 
func ( ki * key Index ) put ( lg * zap . Logger , main int 6 4 , sub int 6 4 ) { rev : = revision { main : main , sub : sub } if ! rev . Greater Than ( ki . modified ) { if lg ! = nil { lg . Panic ( " " , zap . Int 6 4 ( " " , rev . main ) , zap . Int 6 4 ( " " , rev . sub ) , zap . Int 6 4 ( " " , ki . modified . main ) , zap . Int 6 4 ( " " , ki . modified . sub ) , ) } else { plog . Panicf ( " " , rev , ki . modified ) } } if len ( ki . generations ) = = 0 { ki . generations = append ( ki . generations , generation { } ) } g : = & ki . generations [ len ( ki . generations ) - 1 ] if len ( g . revs ) = = 0 { g . created = rev } g . revs = append ( g . revs , rev ) g . ver + + ki . modified = rev } 
func ( ki * key Index ) tombstone ( lg * zap . Logger , main int 6 4 , sub int 6 4 ) error { if ki . is Empty ( ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , string ( ki . key ) ) , ) } else { plog . Panicf ( " " , string ( ki . key ) ) } } if ki . generations [ len ( ki . generations ) - 1 ] . is Empty ( ) { return Err Revision Not Found } ki . put ( lg , main , sub ) ki . generations = append ( ki . generations , generation { } ) keys Gauge . Dec ( ) return nil } 
func ( ki * key Index ) get ( lg * zap . Logger , at Rev int 6 4 ) ( modified , created revision , ver int 6 4 , err error ) { if ki . is Empty ( ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , string ( ki . key ) ) , ) } else { plog . Panicf ( " " , string ( ki . key ) ) } } g : = ki . find Generation ( at Rev ) if g . is Empty ( ) { return revision { } , revision { } , 0 , Err Revision Not Found } n : = g . walk ( func ( rev revision ) bool { return rev . main > at Rev } ) if n ! = - 1 { return g . revs [ n ] , g . created , g . ver - int 6 4 ( len ( g . revs ) - n - 1 ) , nil } return revision { } , revision { } , 0 , Err Revision Not Found } 
func ( ki * key Index ) since ( lg * zap . Logger , rev int 6 4 ) [ ] revision { if ki . is Empty ( ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , string ( ki . key ) ) , ) } else { plog . Panicf ( " " , string ( ki . key ) ) } } since : = revision { rev , 0 } var gi int if g . is Empty ( ) { continue } if since . Greater Than ( g . created ) { break } } var revs [ ] revision var last int 6 4 for ; gi < len ( ki . generations ) ; gi + + { for _ , r : = range ki . generations [ gi ] . revs { if since . Greater Than ( r ) { continue } if r . main = = last { continue } revs = append ( revs , r ) last = r . main } } return revs } 
func ( ki * key Index ) compact ( lg * zap . Logger , at Rev int 6 4 , available map [ revision ] struct { } ) { if ki . is Empty ( ) { if lg ! = nil { lg . Panic ( " " , zap . String ( " " , string ( ki . key ) ) , ) } else { plog . Panicf ( " " , string ( ki . key ) ) } } gen Idx , rev Index : = ki . do Compact ( at Rev , available ) g : = & ki . generations [ gen Idx ] if ! g . is Empty ( ) { } gen Idx + + } } } 
func ( ki * key Index ) keep ( at Rev int 6 4 , available map [ revision ] struct { } ) { if ki . is Empty ( ) { return } gen Idx , rev Index : = ki . do Compact ( at Rev , available ) g : = & ki . generations [ gen Idx ] if ! g . is Empty ( ) { } } } 
func ( ki * key Index ) find Generation ( rev int 6 4 ) * generation { lastg : = len ( ki . generations ) - 1 cg : = lastg for cg > = 0 { if len ( ki . generations [ cg ] . revs ) = = 0 { cg - - continue } g : = ki . generations [ cg ] if cg ! = lastg { if tomb : = g . revs [ len ( g . revs ) - 1 ] . main ; tomb < = rev { return nil } } if g . revs [ 0 ] . main < = rev { return & ki . generations [ cg ] } cg - - } return nil } 
func ( g * generation ) walk ( f func ( rev revision ) bool ) int { l : = len ( g . revs ) for i : = range g . revs { ok : = f ( g . revs [ l - i - 1 ] ) if ! ok { return l - i - 1 } } return - 1 } 
func ( s * store ) Create Or Update User ( user User ) ( out User , created bool , err error ) { _ , err = s . get User ( user . User , true ) if err = = nil { out , err = s . Update User ( user ) return out , false , err } u , err : = s . Create User ( user ) return u , true , err } 
func ( ou User ) merge ( lg * zap . Logger , nu User , s Password Store ) ( User , error ) { var out User if ou . User ! = nu . User { return out , auth Err ( http . Status Conflict , " " , ou . User , nu . User ) } out . User = ou . User if nu . Password ! = " " { hash , err : = s . Hash Password ( nu . Password ) if err ! = nil { return ou , err } out . Password = hash } else { out . Password = ou . Password } current Roles : = types . New Unsafe Set ( ou . Roles . . . ) for _ , g : = range nu . Grant { if current Roles . Contains ( g ) { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , nu . User ) , zap . String ( " " , g ) , ) } else { plog . Noticef ( " " , g , nu . User ) } return User { } , auth Err ( http . Status Conflict , fmt . Sprintf ( " " , g , nu . User ) ) } current Roles . Add ( g ) } for _ , r : = range nu . Revoke { if ! current Roles . Contains ( r ) { if lg ! = nil { lg . Warn ( " " , zap . String ( " " , nu . User ) , zap . String ( " " , r ) , ) } else { plog . Noticef ( " " , r , nu . User ) } return User { } , auth Err ( http . Status Conflict , fmt . Sprintf ( " " , r , nu . User ) ) } current Roles . Remove ( r ) } out . Roles = current Roles . Values ( ) sort . Strings ( out . Roles ) return out , nil } 
func ( r Role ) merge ( lg * zap . Logger , n Role ) ( Role , error ) { var out Role var err error if r . Role ! = n . Role { return out , auth Err ( http . Status Conflict , " " , r . Role , n . Role ) } out . Role = r . Role out . Permissions , err = r . Permissions . Grant ( n . Grant ) if err ! = nil { return out , err } out . Permissions , err = out . Permissions . Revoke ( lg , n . Revoke ) return out , err } 
func ( p Permissions ) Grant ( n * Permissions ) ( Permissions , error ) { var out Permissions var err error if n = = nil { return p , nil } out . KV , err = p . KV . Grant ( n . KV ) return out , err } 
func ( p Permissions ) Revoke ( lg * zap . Logger , n * Permissions ) ( Permissions , error ) { var out Permissions var err error if n = = nil { return p , nil } out . KV , err = p . KV . Revoke ( lg , n . KV ) return out , err } 
func ( rw RWPermission ) Grant ( n RWPermission ) ( RWPermission , error ) { var out RWPermission current Read : = types . New Unsafe Set ( rw . Read . . . ) for _ , r : = range n . Read { if current Read . Contains ( r ) { return out , auth Err ( http . Status Conflict , " " , r ) } current Read . Add ( r ) } current Write : = types . New Unsafe Set ( rw . Write . . . ) for _ , w : = range n . Write { if current Write . Contains ( w ) { return out , auth Err ( http . Status Conflict , " " , w ) } current Write . Add ( w ) } out . Read = current Read . Values ( ) out . Write = current Write . Values ( ) sort . Strings ( out . Read ) sort . Strings ( out . Write ) return out , nil } 
func ( rw RWPermission ) Revoke ( lg * zap . Logger , n RWPermission ) ( RWPermission , error ) { var out RWPermission current Read : = types . New Unsafe Set ( rw . Read . . . ) for _ , r : = range n . Read { if ! current Read . Contains ( r ) { if lg ! = nil { lg . Info ( " " , zap . String ( " " , r ) , ) } else { plog . Noticef ( " " , r ) } continue } current Read . Remove ( r ) } current Write : = types . New Unsafe Set ( rw . Write . . . ) for _ , w : = range n . Write { if ! current Write . Contains ( w ) { if lg ! = nil { lg . Info ( " " , zap . String ( " " , w ) , ) } else { plog . Noticef ( " " , w ) } continue } current Write . Remove ( w ) } out . Read = current Read . Values ( ) out . Write = current Write . Values ( ) sort . Strings ( out . Read ) sort . Strings ( out . Write ) return out , nil } 
func ( s * watchable Store ) cancel Watcher ( wa * watcher ) { for { s . mu . Lock ( ) if s . unsynced . delete ( wa ) { slow Watcher Gauge . Dec ( ) break } else if s . synced . delete ( wa ) { break } else if wa . compacted { break } else if wa . ch = = nil { } if ! wa . victim { panic ( " " ) } var victim Batch watcher Batch for _ , wb : = range s . victims { if wb [ wa ] ! = nil { victim Batch = wb break } } if victim Batch ! = nil { slow Watcher Gauge . Dec ( ) delete ( victim Batch , wa ) break } time . Sleep ( time . Millisecond ) } watcher Gauge . Dec ( ) wa . ch = nil s . mu . Unlock ( ) } 
func ( s * watchable Store ) sync Watchers Loop ( ) { defer s . wg . Done ( ) for { s . mu . RLock ( ) st : = time . Now ( ) last Unsynced Watchers : = s . unsynced . size ( ) s . mu . RUnlock ( ) unsynced Watchers : = 0 if last Unsynced Watchers > 0 { unsynced Watchers = s . sync Watchers ( ) } sync Duration : = time . Since ( st ) wait Duration : = 1 0 0 * time . Millisecond } select { case < - time . After ( wait Duration ) : case < - s . stopc : return } } } 
func ( s * watchable Store ) sync Victims Loop ( ) { defer s . wg . Done ( ) for { for s . move Victims ( ) ! = 0 { s . mu . RLock ( ) is Empty : = len ( s . victims ) = = 0 s . mu . RUnlock ( ) var tickc < - chan time . Time if ! is Empty { tickc = time . After ( 1 0 * time . Millisecond ) } select { case < - tickc : case < - s . victimc : case < - s . stopc : return } } } 
func ( s * watchable Store ) move Victims ( ) ( moved int ) { s . mu . Lock ( ) victims : = s . victims s . victims = nil s . mu . Unlock ( ) var new Victim watcher Batch for _ , wb : = range victims { if w . send ( Watch Response { Watch ID : w . id , Events : eb . evs , Revision : rev } ) { pending Events Gauge . Add ( float 6 4 ( len ( eb . evs ) ) ) } else { if new Victim = = nil { new Victim = make ( watcher Batch ) } new Victim [ w ] = eb continue } moved + + } s . store . rev Mu . RLock ( ) cur Rev : = s . store . current Rev for w , eb : = range wb { if new Victim ! = nil & & new Victim [ w ] ! = nil { } w . victim = false if eb . more Rev ! = 0 { w . min Rev = eb . more Rev } if w . min Rev < = cur Rev { s . unsynced . add ( w ) } else { slow Watcher Gauge . Dec ( ) s . synced . add ( w ) } } s . store . rev Mu . RUnlock ( ) s . mu . Unlock ( ) } if len ( new Victim ) > 0 { s . mu . Lock ( ) s . victims = append ( s . victims , new Victim ) s . mu . Unlock ( ) } return moved } 
func ( s * watchable Store ) sync Watchers ( ) int { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . unsynced . size ( ) = = 0 { return 0 } s . store . rev Mu . RLock ( ) defer s . store . rev Mu . RUnlock ( ) compaction Rev : = s . store . compact Main Rev wg , min Rev : = s . unsynced . choose ( max Watchers Per Sync , cur Rev , compaction Rev ) min Bytes , max Bytes : = new Rev Bytes ( ) , new Rev Bytes ( ) rev To Bytes ( revision { main : min Rev } , min Bytes ) rev To Bytes ( revision { main : cur Rev + 1 } , max Bytes ) tx . RLock ( ) revs , vs : = tx . Unsafe Range ( key Bucket Name , min Bytes , max Bytes , 0 ) var evs [ ] mvccpb . Event if s . store ! = nil & & s . store . lg ! = nil { evs = kvs To Events ( s . store . lg , wg , revs , vs ) } else { } tx . RUnlock ( ) var victims watcher Batch wb : = new Watcher Batch ( wg , evs ) for w : = range wg . watchers { w . min Rev = cur Rev + 1 eb , ok : = wb [ w ] if ! ok { s . unsynced . delete ( w ) continue } if eb . more Rev ! = 0 { w . min Rev = eb . more Rev } if w . send ( Watch Response { Watch ID : w . id , Events : eb . evs , Revision : cur Rev } ) { pending Events Gauge . Add ( float 6 4 ( len ( eb . evs ) ) ) } else { if victims = = nil { victims = make ( watcher Batch ) } w . victim = true } if w . victim { victims [ w ] = eb } else { if eb . more Rev ! = 0 { } s . synced . add ( w ) } s . unsynced . delete ( w ) } s . add Victim ( victims ) vsz : = 0 for _ , v : = range s . victims { vsz + = len ( v ) } slow Watcher Gauge . Set ( float 6 4 ( s . unsynced . size ( ) + vsz ) ) return s . unsynced . size ( ) } 
func kvs To Events ( lg * zap . Logger , wg * watcher Group , revs , vals [ ] [ ] byte ) ( evs [ ] mvccpb . Event ) { for i , v : = range vals { var kv mvccpb . Key Value if err : = kv . Unmarshal ( v ) ; err ! = nil { if lg ! = nil { lg . Panic ( " " , zap . Error ( err ) ) } else { plog . Panicf ( " " , err ) } } if ! wg . contains ( string ( kv . Key ) ) { continue } ty : = mvccpb . PUT if is Tombstone ( revs [ i ] ) { ty = mvccpb . DELETE } evs = append ( evs , mvccpb . Event { Kv : & kv , Type : ty } ) } return evs } 
func ( s * watchable Store ) notify ( rev int 6 4 , evs [ ] mvccpb . Event ) { var victim watcher Batch for w , eb : = range new Watcher Batch ( & s . synced , evs ) { if eb . revs ! = 1 { if s . store ! = nil & & s . store . lg ! = nil { s . store . lg . Panic ( " " , zap . Int ( " " , eb . revs ) , ) } else { plog . Panicf ( " " ) } } if w . send ( Watch Response { Watch ID : w . id , Events : eb . evs , Revision : rev } ) { pending Events Gauge . Add ( float 6 4 ( len ( eb . evs ) ) ) } else { if victim = = nil { victim = make ( watcher Batch ) } w . victim = true victim [ w ] = eb s . synced . delete ( w ) slow Watcher Gauge . Inc ( ) } } s . add Victim ( victim ) } 
func jitter Up ( duration time . Duration , jitter float 6 4 ) time . Duration { multiplier : = jitter * ( rand . Float 6 4 ( ) * 2 - 1 ) return time . Duration ( float 6 4 ( duration ) * ( 1 + multiplier ) ) } 
func is Op Func Called ( op string , opts [ ] Op Option ) bool { for _ , opt : = range opts { v : = reflect . Value Of ( opt ) if v . Kind ( ) = = reflect . Func { if op Func : = runtime . Func For PC ( v . Pointer ( ) ) ; op Func ! = nil { if strings . Contains ( op Func . Name ( ) , op ) { return true } } } } return false } 
func ( t * batch Tx ) Unsafe Put ( bucket Name [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafe Put ( bucket Name , key , value , false ) } 
func ( t * batch Tx ) Unsafe Seq Put ( bucket Name [ ] byte , key [ ] byte , value [ ] byte ) { t . unsafe Put ( bucket Name , key , value , true ) } 
func ( t * batch Tx ) Unsafe Range ( bucket Name , key , end Key [ ] byte , limit int 6 4 ) ( [ ] [ ] byte , [ ] [ ] byte ) { bucket : = t . tx . Bucket ( bucket Name ) if bucket = = nil { if t . backend . lg ! = nil { t . backend . lg . Fatal ( " " , zap . String ( " " , string ( bucket Name ) ) , ) } else { plog . Fatalf ( " " , bucket Name ) } } return unsafe Range ( bucket . Cursor ( ) , key , end Key , limit ) } 
func ( t * batch Tx ) Unsafe Delete ( bucket Name [ ] byte , key [ ] byte ) { bucket : = t . tx . Bucket ( bucket Name ) if bucket = = nil { if t . backend . lg ! = nil { t . backend . lg . Fatal ( " " , zap . String ( " " , string ( bucket Name ) ) , ) } else { plog . Fatalf ( " " , bucket Name ) } } err : = bucket . Delete ( key ) if err ! = nil { if t . backend . lg ! = nil { t . backend . lg . Fatal ( " " , zap . String ( " " , string ( bucket Name ) ) , zap . Error ( err ) , ) } else { plog . Fatalf ( " " , err ) } } t . pending + + } 
func ( t * batch Tx ) Unsafe For Each ( bucket Name [ ] byte , visitor func ( k , v [ ] byte ) error ) error { return unsafe For Each ( t . tx , bucket Name , visitor ) } 
func ( t * batch Tx ) Commit ( ) { t . Lock ( ) t . commit ( false ) t . Unlock ( ) } 
func ( t * batch Tx ) Commit And Stop ( ) { t . Lock ( ) t . commit ( true ) t . Unlock ( ) } 
func ( le * lessor ) Renew ( id Lease ID ) ( int 6 4 , error ) { le . mu . RLock ( ) if ! le . is Primary ( ) { return - 1 , Err Not Primary } demotec : = le . demotec l : = le . lease Map [ id ] if l = = nil { le . mu . RUnlock ( ) return - 1 , Err Lease Not Found } le . mu . RUnlock ( ) if l . expired ( ) { select { case < - le . stop C : return - 1 , Err Not Primary } } } le . mu . Lock ( ) l . refresh ( 0 ) item : = & Lease With Time { id : l . ID , time : l . expiry . Unix Nano ( ) } heap . Push ( & le . lease Heap , item ) le . mu . Unlock ( ) lease Renewed . Inc ( ) return l . ttl , nil } 
func ( le * lessor ) Attach ( id Lease ID , items [ ] Lease Item ) error { le . mu . Lock ( ) defer le . mu . Unlock ( ) l : = le . lease Map [ id ] if l = = nil { return Err Lease Not Found } l . mu . Lock ( ) for _ , it : = range items { l . item Set [ it ] = struct { } { } le . item Map [ it ] = id } l . mu . Unlock ( ) return nil } 
func ( le * lessor ) revoke Expired Leases ( ) { var ls [ ] * Lease le . mu . RLock ( ) if le . is Primary ( ) { ls = le . find Expired Leases ( revoke Limit ) } le . mu . RUnlock ( ) if len ( ls ) ! = 0 { select { case < - le . stop C : return case le . expired C < - ls : default : } } 
func ( le * lessor ) checkpoint Scheduled Leases ( ) { var cps [ ] * pb . Lease Checkpoint if le . is Primary ( ) { cps = le . find Due Scheduled Checkpoints ( max Lease Checkpoint Batch Size ) } le . mu . Unlock ( ) if len ( cps ) ! = 0 { le . cp ( context . Background ( ) , & pb . Lease Checkpoint Request { Checkpoints : cps } ) } if len ( cps ) < max Lease Checkpoint Batch Size { return } } } 
func ( le * lessor ) expire Exists ( ) ( l * Lease , ok bool , next bool ) { if le . lease Heap . Len ( ) = = 0 { return nil , false , false } item : = le . lease Heap [ 0 ] l = le . lease Map [ item . id ] if l = = nil { return nil , false , true } if time . Now ( ) . Unix Nano ( ) < item . time { } return l , true , false } 
func ( le * lessor ) find Expired Leases ( limit int ) [ ] * Lease { leases : = make ( [ ] * Lease , 0 , 1 6 ) for { l , ok , next : = le . expire Exists ( ) if ! ok & & ! next { break } if ! ok { continue } if next { continue } if l . expired ( ) { leases = append ( leases , l ) } } } return leases } 
func ( l * Lease ) Remaining TTL ( ) int 6 4 { if l . remaining TTL > 0 { return l . remaining TTL } return l . ttl } 
func ( l * Lease ) refresh ( extend time . Duration ) { new Expiry : = time . Now ( ) . Add ( extend + time . Duration ( l . Remaining TTL ( ) ) * time . Second ) l . expiry Mu . Lock ( ) defer l . expiry Mu . Unlock ( ) l . expiry = new Expiry } 
func ( l * Lease ) forever ( ) { l . expiry Mu . Lock ( ) defer l . expiry Mu . Unlock ( ) l . expiry = forever } 
func ( l * Lease ) Keys ( ) [ ] string { l . mu . RLock ( ) keys : = make ( [ ] string , 0 , len ( l . item Set ) ) for k : = range l . item Set { keys = append ( keys , k . Key ) } l . mu . RUnlock ( ) return keys } 
func ( l * Lease ) Remaining ( ) time . Duration { l . expiry Mu . RLock ( ) defer l . expiry Mu . RUnlock ( ) if l . expiry . Is Zero ( ) { return time . Duration ( math . Max Int 6 4 ) } return time . Until ( l . expiry ) } 
func New Compaction Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : compaction Command Func , } cmd . Flags ( ) . Bool Var ( & compact Physical , " " , false , " " ) return cmd } 
func compaction Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } rev , err : = strconv . Parse Int ( args [ 0 ] , 1 0 , 6 4 ) if err ! = nil { Exit With Error ( Exit Error , err ) } var opts [ ] clientv 3 . Compact Option if compact Physical { opts = append ( opts , clientv 3 . With Compact Physical ( ) ) } c : = must Client From Cmd ( cmd ) ctx , cancel : = command Ctx ( cmd ) _ , cerr : = c . Compact ( ctx , rev , opts . . . ) cancel ( ) if cerr ! = nil { Exit With Error ( Exit Error , cerr ) } fmt . Println ( " " , rev ) } 
func case Sensitive Json Iterator ( ) jsoniter . API { config : = jsoniter . Config { Escape HTML : true , Sort Map Keys : true , Validate Json Raw Message : true , Case Sensitive : true , } . Froze ( ) return config } 
func New Put Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Long : ` Puts the given key into the store . When <value > begins with ' - ' , <value > is interpreted as a flag . Insert ' - - ' for workaround : $ put <key > - - <value > $ put - - <key > <value > If <value > isn 't given as a command line argument and ' - -ignore -value ' is not specified , this command tries to read the value from standard input . If <lease > isn 't given as a command line argument and ' - -ignore -lease ' is not specified , this command tries to read the value from standard input . For example , $ cat file | put <key > will store the content of the file to <key > . ` , Run : put Command Func , } cmd . Flags ( ) . String Var ( & lease Str , " " , " " , " " ) cmd . Flags ( ) . Bool Var ( & put Prev KV , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & put Ignore Val , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & put Ignore Lease , " " , false , " " ) return cmd } 
func put Command Func ( cmd * cobra . Command , args [ ] string ) { key , value , opts : = get Put Op ( args ) ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Put ( ctx , key , value , opts . . . ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Put ( * resp ) } 
func New Handler ( t * http . Transport , urls Func Get Proxy URLs , failure Wait time . Duration , refresh Interval time . Duration ) http . Handler { if t . TLSClient Config ! = nil { if err ! = nil { plog . Infof ( " " , err ) } } p : = & reverse Proxy { director : new Director ( urls Func , failure Wait , refresh Interval ) , transport : t , } mux : = http . New Serve Mux ( ) mux . Handle ( " " , p ) mux . Handle Func ( " " , p . config Handler ) return mux } 
func New Readonly Handler ( hdlr http . Handler ) http . Handler { readonly : = readonly Handler Func ( hdlr ) return http . Handler Func ( readonly ) } 
func New Set Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Description : `Set sets the value of a key . When <value > begins with ' - ' , <value > is interpreted as a flag . Insert ' - - ' for workaround : $ set - - <key > <value > ` , Flags : [ ] cli . Flag { cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , cli . String Flag { Name : " " , Value : " " , Usage : " " } , cli . Int Flag { Name : " " , Value : 0 , Usage : " " } , } , Action : func ( c * cli . Context ) error { set Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func set Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] value , err : = arg Or Stdin ( c . Args ( ) , os . Stdin , 1 ) if err ! = nil { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } ttl : = c . Int ( " " ) prev Value : = c . String ( " " ) prev Index : = c . Int ( " " ) ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Set ( ctx , key , value , & client . Set Options { TTL : time . Duration ( ttl ) * time . Second , Prev Index : uint 6 4 ( prev Index ) , Prev Value : prev Value } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } print Response Key ( resp , c . Global String ( " " ) ) } 
func ( rwm * RWMutex ) wait On Last Rev ( pfx string ) ( bool , error ) { client : = rwm . s . Client ( ) last Key , err : = client . Get ( rwm . ctx , pfx , opts . . . ) if err ! = nil { return false , err } if len ( last Key . Kvs ) = = 0 { return true , nil } return false , err } 
func Get Default Interfaces ( ) ( map [ string ] uint 8 , error ) { return nil , fmt . Errorf ( " " , runtime . GOOS , runtime . GOARCH ) } 
func New Snapshot Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , } cmd . Add Command ( New Snapshot Save Command ( ) ) cmd . Add Command ( New Snapshot Restore Command ( ) ) cmd . Add Command ( new Snapshot Status Command ( ) ) return cmd } 
func New Move Leader Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : transfer Leadership Command Func , } return cmd } 
func transfer Leadership Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 1 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } target , err : = strconv . Parse Uint ( args [ 0 ] , 1 6 , 6 4 ) if err ! = nil { Exit With Error ( Exit Bad Args , err ) } c : = must Client From Cmd ( cmd ) eps : = c . Endpoints ( ) c . Close ( ) ctx , cancel : = command Ctx ( cmd ) var leader ID uint 6 4 for _ , ep : = range eps { cfg : = client Config From Cmd ( cmd ) cfg . endpoints = [ ] string { ep } cli : = cfg . must Client ( ) resp , serr : = cli . Status ( ctx , ep ) if serr ! = nil { Exit With Error ( Exit Error , serr ) } if resp . Header . Get Member Id ( ) = = resp . Leader { leader Cli = cli leader ID = resp . Leader break } cli . Close ( ) } if leader Cli = = nil { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " , eps ) ) } var resp * clientv 3 . Move Leader Response resp , err = leader Cli . Move Leader ( ctx , target ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Move Leader ( leader ID , target , * resp ) } 
func Open Dir ( path string ) ( * os . File , error ) { fd , err : = open Dir ( path ) if err ! = nil { return nil , err } return os . New File ( uintptr ( fd ) , path ) , nil } 
func New Remove Dir Command ( ) cli . Command { return cli . Command { Name : " " , Usage : " " , Args Usage : " " , Action : func ( c * cli . Context ) error { rmdir Command Func ( c , must New Key API ( c ) ) return nil } , } } 
func rmdir Command Func ( c * cli . Context , ki client . Keys API ) { if len ( c . Args ( ) ) = = 0 { handle Error ( c , Exit Bad Args , errors . New ( " " ) ) } key : = c . Args ( ) [ 0 ] ctx , cancel : = context With Total Timeout ( c ) resp , err : = ki . Delete ( ctx , key , & client . Delete Options { Dir : true } ) cancel ( ) if err ! = nil { handle Error ( c , Exit Server Error , err ) } if ! resp . Node . Dir | | c . Global String ( " " ) ! = " " { print Response Key ( resp , c . Global String ( " " ) ) } } 
func New Del Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : del Command Func , } cmd . Flags ( ) . Bool Var ( & del Prefix , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & del Prev KV , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & del From Key , " " , false , " " ) return cmd } 
func del Command Func ( cmd * cobra . Command , args [ ] string ) { key , opts : = get Del Op ( args ) ctx , cancel : = command Ctx ( cmd ) resp , err : = must Client From Cmd ( cmd ) . Delete ( ctx , key , opts . . . ) cancel ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Del ( * resp ) } 
func archive ( base Dir , etcd Log Path , data Dir string ) error { dir : = filepath . Join ( base Dir , " " , time . Now ( ) . Format ( time . RFC 3 3 3 9 ) ) if exist Dir ( dir ) { dir = filepath . Join ( base Dir , " " , time . Now ( ) . Add ( time . Second ) . Format ( time . RFC 3 3 3 9 ) ) } if err : = fileutil . Touch Dir All ( dir ) ; err ! = nil { return err } if err : = os . Rename ( etcd Log Path , filepath . Join ( dir , " " ) ) ; err ! = nil { if ! os . Is Not Exist ( err ) { return err } } if err : = os . Rename ( data Dir , filepath . Join ( dir , filepath . Base ( data Dir ) ) ) ; err ! = nil { if ! os . Is Not Exist ( err ) { return err } } return nil } 
func New Expect ( name string , arg . . . string ) ( ep * Expect Process , err error ) { } 
func New Expect With Env ( name string , args [ ] string , env [ ] string ) ( ep * Expect Process , err error ) { cmd : = exec . Command ( name , args . . . ) cmd . Env = env ep = & Expect Process { cmd : cmd , Stop Signal : syscall . SIGKILL , } ep . cond = sync . New Cond ( & ep . mu ) ep . cmd . Stderr = ep . cmd . Stdout ep . cmd . Stdin = nil if ep . fpty , err = pty . Start ( ep . cmd ) ; err ! = nil { return nil , err } ep . wg . Add ( 1 ) go ep . read ( ) return ep , nil } 
func ( ep * Expect Process ) Expect Func ( f func ( string ) bool ) ( string , error ) { ep . mu . Lock ( ) for { for len ( ep . lines ) = = 0 & & ep . err = = nil { ep . cond . Wait ( ) } if len ( ep . lines ) = = 0 { break } l : = ep . lines [ 0 ] ep . lines = ep . lines [ 1 : ] if f ( l ) { ep . mu . Unlock ( ) return l , nil } } ep . mu . Unlock ( ) return " " , ep . err } 
func ( ep * Expect Process ) Expect ( s string ) ( string , error ) { return ep . Expect Func ( func ( txt string ) bool { return strings . Contains ( txt , s ) } ) } 
func ( ep * Expect Process ) Line Count ( ) int { ep . mu . Lock ( ) defer ep . mu . Unlock ( ) return ep . count } 
func ( ep * Expect Process ) Signal ( sig os . Signal ) error { return ep . cmd . Process . Signal ( sig ) } 
func ready Wait ( rpc Ctx , client Ctx context . Context , ready < - chan struct { } ) error { select { case < - ready : return nil case < - rpc Ctx . Done ( ) : return rpc Ctx . Err ( ) case < - client Ctx . Done ( ) : return client Ctx . Err ( ) } } 
func key Func ( req * pb . Range Request ) string { if err ! = nil { panic ( err ) } return string ( b ) } 
func ( c * cache ) Add ( req * pb . Range Request , resp * pb . Range Response ) { key : = key Func ( req ) c . mu . Lock ( ) defer c . mu . Unlock ( ) if req . Revision > c . compacted Rev { c . lru . Add ( key , resp ) } } var ( iv * adt . Interval Value ivl adt . Interval ) if len ( req . Range End ) ! = 0 { ivl = adt . New String Affine Interval ( string ( req . Key ) , string ( req . Range End ) ) } else { ivl = adt . New String Affine Point ( string ( req . Key ) ) } iv = c . cached Ranges . Find ( ivl ) if iv = = nil { val : = map [ string ] struct { } { key : { } } c . cached Ranges . Insert ( ivl , val ) } else { val : = iv . Val . ( map [ string ] struct { } ) val [ key ] = struct { } { } iv . Val = val } } 
func ( c * cache ) Get ( req * pb . Range Request ) ( * pb . Range Response , error ) { key : = key Func ( req ) c . mu . Lock ( ) defer c . mu . Unlock ( ) if req . Revision > 0 & & req . Revision < c . compacted Rev { c . lru . Remove ( key ) return nil , Err Compacted } if resp , ok : = c . lru . Get ( key ) ; ok { return resp . ( * pb . Range Response ) , nil } return nil , errors . New ( " " ) } 
func ( c * cache ) Invalidate ( key , endkey [ ] byte ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) var ( ivs [ ] * adt . Interval Value ivl adt . Interval ) if len ( endkey ) = = 0 { ivl = adt . New String Affine Point ( string ( key ) ) } else { ivl = adt . New String Affine Interval ( string ( key ) , string ( endkey ) ) } ivs = c . cached Ranges . Stab ( ivl ) for _ , iv : = range ivs { keys : = iv . Val . ( map [ string ] struct { } ) for key : = range keys { c . lru . Remove ( key ) } } } 
func ( c * cache ) Compact ( revision int 6 4 ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if revision > c . compacted Rev { c . compacted Rev = revision } } 
func ( us * Unique URLs ) Set ( s string ) error { if _ , ok : = us . Values [ s ] ; ok { return nil } if _ , ok : = us . Allowed [ s ] ; ok { us . Values [ s ] = struct { } { } return nil } ss , err : = types . New URLs ( strings . Split ( s , " " ) ) if err ! = nil { return err } us . Values = make ( map [ string ] struct { } ) us . uss = make ( [ ] url . URL , 0 ) for _ , v : = range ss { us . Values [ v . String ( ) ] = struct { } { } us . uss = append ( us . uss , v ) } return nil } 
func ( us * Unique URLs ) String ( ) string { all : = make ( [ ] string , 0 , len ( us . Values ) ) for u : = range us . Values { all = append ( all , u ) } sort . Strings ( all ) return strings . Join ( all , " " ) } 
func New Unique URLs With Exceptions ( s string , exceptions . . . string ) * Unique URLs { us : = & Unique URLs { Values : make ( map [ string ] struct { } ) , Allowed : make ( map [ string ] struct { } ) } for _ , v : = range exceptions { us . Allowed [ v ] = struct { } { } } if s = = " " { return us } if err : = us . Set ( s ) ; err ! = nil { plog . Panicf ( " " , err ) } return us } 
func Unique URLs From Flag ( fs * flag . Flag Set , urls Flag Name string ) [ ] url . URL { return ( * fs . Lookup ( urls Flag Name ) . Value . ( * Unique URLs ) ) . uss } 
func Unique URLs Map From Flag ( fs * flag . Flag Set , urls Flag Name string ) map [ string ] struct { } { return ( * fs . Lookup ( urls Flag Name ) . Value . ( * Unique URLs ) ) . Values } 
func ( b * Barrier ) Hold ( ) error { _ , err : = new Key ( b . client , b . key , v 3 . No Lease ) return err } 
func ( b * Barrier ) Release ( ) error { _ , err : = b . client . Delete ( b . ctx , b . key ) return err } 
func ( b * Barrier ) Wait ( ) error { resp , err : = b . client . Get ( b . ctx , b . key , v 3 . With First Key ( ) . . . ) if err ! = nil { return err } if len ( resp . Kvs ) = = 0 { } _ , err = Wait Events ( b . client , b . key , resp . Header . Revision , [ ] mvccpb . Event _Event Type { mvccpb . PUT , mvccpb . DELETE } ) return err } 
func New Lock Racer Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : run Racer Func , } cmd . Flags ( ) . Int Var ( & total Client Connections , " " , 1 0 , " " ) return cmd } 
func ( m * Member ) Election Timeout ( ) time . Duration { return time . Duration ( m . Etcd . Election Timeout Ms ) * time . Millisecond } 
func ( m * Member ) Dial Etcd GRPCServer ( opts . . . grpc . Dial Option ) ( * grpc . Client Conn , error ) { dial Opts : = [ ] grpc . Dial Option { grpc . With Timeout ( 5 * time . Second ) , grpc . With Block ( ) , } secure : = false for _ , cu : = range m . Etcd . Advertise Client URLs { u , err : = url . Parse ( cu ) if err ! = nil { return nil , err } if u . Scheme = = " " { } } if secure { tls Config , err : = tls Info . Client Config ( ) if err ! = nil { return nil , err } creds : = credentials . New TLS ( tls Config ) dial Opts = append ( dial Opts , grpc . With Transport Credentials ( creds ) ) } else { dial Opts = append ( dial Opts , grpc . With Insecure ( ) ) } dial Opts = append ( dial Opts , opts . . . ) return grpc . Dial ( m . Etcd Client Endpoint , dial Opts . . . ) } 
func ( m * Member ) Create Etcd Client Config ( opts . . . grpc . Dial Option ) ( cfg * clientv 3 . Config , err error ) { secure : = false for _ , cu : = range m . Etcd . Advertise Client URLs { var u * url . URL u , err = url . Parse ( cu ) if err ! = nil { return nil , err } if u . Scheme = = " " { } } cfg = & clientv 3 . Config { Endpoints : [ ] string { m . Etcd Client Endpoint } , Dial Timeout : 1 0 * time . Second , Dial Options : opts , } if secure { var tls Config * tls . Config tls Config , err = tls Info . Client Config ( ) if err ! = nil { return nil , err } cfg . TLS = tls Config } return cfg , err } 
func ( m * Member ) Create Etcd Client ( opts . . . grpc . Dial Option ) ( * clientv 3 . Client , error ) { cfg , err : = m . Create Etcd Client Config ( opts . . . ) if err ! = nil { return nil , err } return clientv 3 . New ( * cfg ) } 
func ( m * Member ) Check Compact ( rev int 6 4 ) error { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , 5 * time . Second ) wch : = cli . Watch ( ctx , " \x 0 0 " , clientv 3 . With From Key ( ) , clientv 3 . With Rev ( rev - 1 ) ) wr , ok : = < - wch cancel ( ) if ! ok { return fmt . Errorf ( " " , m . Etcd Client Endpoint ) } if wr . Compact Revision ! = rev { return fmt . Errorf ( " " , wr . Compact Revision , rev , m . Etcd Client Endpoint ) } return nil } 
func ( m * Member ) Defrag ( ) error { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , 5 * time . Minute ) _ , err = cli . Defragment ( ctx , m . Etcd Client Endpoint ) cancel ( ) return err } 
func ( m * Member ) Rev Hash ( ) ( int 6 4 , int 6 4 , error ) { conn , err : = m . Dial Etcd GRPCServer ( ) if err ! = nil { return 0 , 0 , err } defer conn . Close ( ) mt : = pb . New Maintenance Client ( conn ) ctx , cancel : = context . With Timeout ( context . Background ( ) , 5 * time . Second ) resp , err : = mt . Hash ( ctx , & pb . Hash Request { } , grpc . Fail Fast ( false ) ) cancel ( ) if err ! = nil { return 0 , 0 , err } return resp . Header . Revision , int 6 4 ( resp . Hash ) , nil } 
func ( m * Member ) Rev ( ctx context . Context ) ( int 6 4 , error ) { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) resp , err : = cli . Status ( ctx , m . Etcd Client Endpoint ) if err ! = nil { return 0 , err } return resp . Header . Revision , nil } 
func ( m * Member ) Compact ( rev int 6 4 , timeout time . Duration ) error { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , timeout ) _ , err = cli . Compact ( ctx , rev , clientv 3 . With Compact Physical ( ) ) cancel ( ) return err } 
func ( m * Member ) Is Leader ( ) ( bool , error ) { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return false , fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) resp , err : = cli . Status ( context . Background ( ) , m . Etcd Client Endpoint ) if err ! = nil { return false , err } return resp . Header . Member Id = = resp . Leader , nil } 
func ( m * Member ) Write Health Key ( ) error { cli , err : = m . Create Etcd Client ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } defer cli . Close ( ) _ , err = cli . Put ( ctx , " " , " " ) cancel ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } return nil } 
func ( m * Member ) Save Snapshot ( lg * zap . Logger ) ( err error ) { } var ccfg * clientv 3 . Config ccfg , err = m . Create Etcd Client Config ( ) if err ! = nil { return fmt . Errorf ( " " , err , m . Etcd Client Endpoint ) } lg . Info ( " " , zap . String ( " " , m . Etcd . Name ) , zap . Strings ( " " , m . Etcd . Advertise Client URLs ) , zap . String ( " " , m . Snapshot Path ) , ) now : = time . Now ( ) mgr : = snapshot . New V 3 ( lg ) if err = mgr . Save ( context . Background ( ) , * ccfg , m . Snapshot Path ) ; err ! = nil { return err } took : = time . Since ( now ) var fi os . File Info fi , err = os . Stat ( m . Snapshot Path ) if err ! = nil { return err } var st snapshot . Status st , err = mgr . Status ( m . Snapshot Path ) if err ! = nil { return err } m . Snapshot Info = & Snapshot Info { Member Name : m . Etcd . Name , Member Client URLs : m . Etcd . Advertise Client URLs , Snapshot Path : m . Snapshot Path , Snapshot File Size : humanize . Bytes ( uint 6 4 ( fi . Size ( ) ) ) , Snapshot Total Size : humanize . Bytes ( uint 6 4 ( st . Total Size ) ) , Snapshot Total Key : int 6 4 ( st . Total Key ) , Snapshot Hash : int 6 4 ( st . Hash ) , Snapshot Revision : st . Revision , Took : fmt . Sprintf ( " " , took ) , } lg . Info ( " " , zap . String ( " " , m . Snapshot Info . Member Name ) , zap . Strings ( " " , m . Snapshot Info . Member Client URLs ) , zap . String ( " " , m . Snapshot Path ) , zap . String ( " " , m . Snapshot Info . Snapshot File Size ) , zap . String ( " " , m . Snapshot Info . Snapshot Total Size ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Total Key ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Hash ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Revision ) , zap . String ( " " , m . Snapshot Info . Took ) , ) return nil } 
func ( m * Member ) Restore Snapshot ( lg * zap . Logger ) ( err error ) { if err = os . Remove All ( m . Etcd On Snapshot Restore . Data Dir ) ; err ! = nil { return err } if err = os . Remove All ( m . Etcd On Snapshot Restore . WALDir ) ; err ! = nil { return err } lg . Info ( " " , zap . String ( " " , m . Etcd . Name ) , zap . Strings ( " " , m . Etcd . Advertise Client URLs ) , zap . String ( " " , m . Snapshot Path ) , ) now : = time . Now ( ) mgr : = snapshot . New V 3 ( lg ) err = mgr . Restore ( snapshot . Restore Config { Snapshot Path : m . Snapshot Info . Snapshot Path , Name : m . Etcd On Snapshot Restore . Name , Output Data Dir : m . Etcd On Snapshot Restore . Data Dir , Output WALDir : m . Etcd On Snapshot Restore . WALDir , Peer URLs : m . Etcd On Snapshot Restore . Advertise Peer URLs , Initial Cluster : m . Etcd On Snapshot Restore . Initial Cluster , Initial Cluster Token : m . Etcd On Snapshot Restore . Initial Cluster Token , Skip Hash Check : false , took : = time . Since ( now ) lg . Info ( " " , zap . String ( " " , m . Snapshot Info . Member Name ) , zap . Strings ( " " , m . Snapshot Info . Member Client URLs ) , zap . String ( " " , m . Snapshot Path ) , zap . String ( " " , m . Snapshot Info . Snapshot File Size ) , zap . String ( " " , m . Snapshot Info . Snapshot Total Size ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Total Key ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Hash ) , zap . Int 6 4 ( " " , m . Snapshot Info . Snapshot Revision ) , zap . String ( " " , took . String ( ) ) , zap . Error ( err ) , ) return err } 
func New Watcher ( w clientv 3 . Watcher , prefix string ) clientv 3 . Watcher { return & watcher Prefix { Watcher : w , pfx : prefix , stopc : make ( chan struct { } ) } } 
func Register ( c * clientv 3 . Client , prefix string , addr string , ttl int ) < - chan struct { } { rm : = rate . New Limiter ( rate . Limit ( register Retry Rate ) , register Retry Rate ) donec : = make ( chan struct { } ) go func ( ) { defer close ( donec ) for rm . Wait ( c . Ctx ( ) ) = = nil { ss , err : = register Session ( c , prefix , addr , ttl ) if err ! = nil { plog . Warningf ( " " , err ) continue } select { case < - c . Ctx ( ) . Done ( ) : ss . Close ( ) return case < - ss . Done ( ) : plog . Warning ( " " ) plog . Warning ( " " ) continue } } } ( ) return donec } 
func New Raw Node ( config * Config , peers [ ] Peer ) ( * Raw Node , error ) { if config . ID = = 0 { panic ( " " ) } r : = new Raft ( config ) rn : = & Raw Node { raft : r , } last Index , err : = config . Storage . Last Index ( ) if err ! = nil { panic ( err ) } ents : = make ( [ ] pb . Entry , len ( peers ) ) for i , peer : = range peers { cc : = pb . Conf Change { Type : pb . Conf Change Add Node , Node ID : peer . ID , Context : peer . Context } data , err : = cc . Marshal ( ) if err ! = nil { panic ( " " ) } ents [ i ] = pb . Entry { Type : pb . Entry Conf Change , Term : 1 , Index : uint 6 4 ( i + 1 ) , Data : data } } r . raft Log . append ( ents . . . ) r . raft Log . committed = uint 6 4 ( len ( ents ) ) for _ , peer : = range peers { r . add Node ( peer . ID ) } } if last Index = = 0 { rn . prev Hard St = empty State } else { rn . prev Hard St = r . hard State ( ) } return rn , nil } 
func ( rn * Raw Node ) Campaign ( ) error { return rn . raft . Step ( pb . Message { Type : pb . Msg Hup , } ) } 
func ( rn * Raw Node ) Propose ( data [ ] byte ) error { return rn . raft . Step ( pb . Message { Type : pb . Msg Prop , From : rn . raft . id , Entries : [ ] pb . Entry { { Data : data } , } } ) } 
func ( rn * Raw Node ) Propose Conf Change ( cc pb . Conf Change ) error { data , err : = cc . Marshal ( ) if err ! = nil { return err } return rn . raft . Step ( pb . Message { Type : pb . Msg Prop , Entries : [ ] pb . Entry { { Type : pb . Entry Conf Change , Data : data } , } , } ) } 
func ( rn * Raw Node ) Apply Conf Change ( cc pb . Conf Change ) * pb . Conf State { if cc . Node ID = = None { return & pb . Conf State { Nodes : rn . raft . nodes ( ) , Learners : rn . raft . learner Nodes ( ) } } switch cc . Type { case pb . Conf Change Add Node : rn . raft . add Node ( cc . Node ID ) case pb . Conf Change Add Learner Node : rn . raft . add Learner ( cc . Node ID ) case pb . Conf Change Remove Node : rn . raft . remove Node ( cc . Node ID ) case pb . Conf Change Update Node : default : panic ( " " ) } return & pb . Conf State { Nodes : rn . raft . nodes ( ) , Learners : rn . raft . learner Nodes ( ) } } 
func ( rn * Raw Node ) Step ( m pb . Message ) error { } if pr : = rn . raft . get Progress ( m . From ) ; pr ! = nil | | ! Is Response Msg ( m . Type ) { return rn . raft . Step ( m ) } return Err Step Peer Not Found } 
func ( rn * Raw Node ) Ready ( ) Ready { rd : = rn . new Ready ( ) rn . raft . msgs = nil rn . raft . reduce Uncommitted Size ( rd . Committed Entries ) return rd } 
func ( rn * Raw Node ) Has Ready ( ) bool { r : = rn . raft if ! r . soft State ( ) . equal ( rn . prev Soft St ) { return true } if hard St : = r . hard State ( ) ; ! Is Empty Hard State ( hard St ) & & ! is Hard State Equal ( hard St , rn . prev Hard St ) { return true } if r . raft Log . unstable . snapshot ! = nil & & ! Is Empty Snap ( * r . raft Log . unstable . snapshot ) { return true } if len ( r . msgs ) > 0 | | len ( r . raft Log . unstable Entries ( ) ) > 0 | | r . raft Log . has Next Ents ( ) { return true } if len ( r . read States ) ! = 0 { return true } return false } 
func ( rn * Raw Node ) With Progress ( visitor func ( id uint 6 4 , typ Progress Type , pr Progress ) ) { for id , pr : = range rn . raft . prs { pr : = * pr pr . ins = nil visitor ( id , Progress Type Peer , pr ) } for id , pr : = range rn . raft . learner Prs { pr : = * pr pr . ins = nil visitor ( id , Progress Type Learner , pr ) } } 
func ( rn * Raw Node ) Report Unreachable ( id uint 6 4 ) { _ = rn . raft . Step ( pb . Message { Type : pb . Msg Unreachable , From : id } ) } 
func ( rn * Raw Node ) Report Snapshot ( id uint 6 4 , status Snapshot Status ) { rej : = status = = Snapshot Failure _ = rn . raft . Step ( pb . Message { Type : pb . Msg Snap Status , From : id , Reject : rej } ) } 
func ( rn * Raw Node ) Transfer Leader ( transferee uint 6 4 ) { _ = rn . raft . Step ( pb . Message { Type : pb . Msg Transfer Leader , From : transferee } ) } 
func ( rn * Raw Node ) Read Index ( rctx [ ] byte ) { _ = rn . raft . Step ( pb . Message { Type : pb . Msg Read Index , Entries : [ ] pb . Entry { { Data : rctx } } } ) } 
func printc URL ( req * http . Request ) error { if ! c URLDebug { return nil } var ( command string b [ ] byte err error ) if req . URL ! = nil { command = fmt . Sprintf ( " " , req . Method , req . URL . String ( ) ) } if req . Body ! = nil { b , err = ioutil . Read All ( req . Body ) if err ! = nil { return err } command + = fmt . Sprintf ( " " , string ( b ) ) } fmt . Fprintf ( os . Stderr , " \n " , command ) req . Body = ioutil . Nop Closer ( body ) return nil } 
func Fsync ( f * os . File ) error { _ , _ , errno : = syscall . Syscall ( syscall . SYS _FCNTL , f . Fd ( ) , uintptr ( syscall . F _FULLFSYNC ) , uintptr ( 0 ) ) if errno = = 0 { return nil } return errno } 
func ( rd Ready ) applied Cursor ( ) uint 6 4 { if n : = len ( rd . Committed Entries ) ; n > 0 { return rd . Committed Entries [ n - 1 ] . Index } if index : = rd . Snapshot . Metadata . Index ; index > 0 { return index } return 0 } 
func Start Node ( c * Config , peers [ ] Peer ) Node { r : = new Raft ( c ) for _ , peer : = range peers { cc : = pb . Conf Change { Type : pb . Conf Change Add Node , Node ID : peer . ID , Context : peer . Context } d , err : = cc . Marshal ( ) if err ! = nil { panic ( " " ) } e : = pb . Entry { Type : pb . Entry Conf Change , Term : 1 , Index : r . raft Log . last Index ( ) + 1 , Data : d } r . raft Log . append ( e ) } } n : = new Node ( ) n . logger = c . Logger go n . run ( r ) return & n } 
func Restart Node ( c * Config ) Node { r : = new Raft ( c ) n : = new Node ( ) n . logger = c . Logger go n . run ( r ) return & n } 
func ( n * node ) Tick ( ) { select { case n . tickc < - struct { } { } : case < - n . done : default : n . logger . Warningf ( " " ) } } 
func ( n * node ) step With Wait Option ( ctx context . Context , m pb . Message , wait bool ) error { if m . Type ! = pb . Msg Prop { select { case n . recvc < - m : return nil case < - ctx . Done ( ) : return ctx . Err ( ) case < - n . done : return Err Stopped } } ch : = n . propc pm : = msg With Result { m : m } if wait { pm . result = make ( chan error , 1 ) } select { case ch < - pm : if ! wait { return nil } case < - ctx . Done ( ) : return ctx . Err ( ) case < - n . done : return Err Stopped } select { case err : = < - pm . result : if err ! = nil { return err } case < - ctx . Done ( ) : return ctx . Err ( ) case < - n . done : return Err Stopped } return nil } 
func Must Sync ( st , prevst pb . Hard State , entsnum int ) bool { } 
func New GRPC 1 7Health ( eps [ ] string , timeout time . Duration , dial Func Dial Func , ) * GRPC 1 7Health { notify Ch : = make ( chan [ ] grpc . Address ) addrs : = eps 2addrs ( eps ) hb : = & GRPC 1 7Health { addrs : addrs , eps : eps , notify Ch : notify Ch , readyc : make ( chan struct { } ) , health Check : func ( ep string ) ( bool , error ) { return grpc Health Check ( ep , dial Func ) } , unhealthy Host Ports : make ( map [ string ] time . Time ) , upc : make ( chan struct { } ) , stopc : make ( chan struct { } ) , downc : make ( chan struct { } ) , donec : make ( chan struct { } ) , update Addrs C : make ( chan Notify Msg ) , host Port 2ep : get Host Port 2ep ( eps ) , } if timeout < min Health Retry Duration { timeout = min Health Retry Duration } hb . health Check Timeout = timeout close ( hb . downc ) go hb . update Notify Loop ( ) hb . wg . Add ( 1 ) go func ( ) { defer hb . wg . Done ( ) hb . update Unhealthy ( ) } ( ) return hb } 
func ( b * GRPC 1 7Health ) Need Update ( ) bool { update : = ! has Addr ( b . addrs , b . pin Addr ) b . mu . RUnlock ( ) return update } 
func dfl Signal ( sig syscall . Signal ) { ptr : = unsafe . Pointer ( & sigact Buf ) syscall . Syscall 6 ( uintptr ( syscall . SYS _RT _SIGACTION ) , uintptr ( sig ) , uintptr ( ptr ) , 0 , 8 , 0 , 0 ) } 
func New ( namespaces . . . string ) Store { s : = new Store ( namespaces . . . ) s . clock = clockwork . New Real Clock ( ) return s } 
func ( s * store ) Index ( ) uint 6 4 { s . world Lock . RLock ( ) defer s . world Lock . RUnlock ( ) return s . Current Index } 
func ( s * store ) Get ( node Path string , recursive , sorted bool ) ( * Event , error ) { var err * v 2error . Error s . world Lock . RLock ( ) defer s . world Lock . RUnlock ( ) defer func ( ) { if err = = nil { s . Stats . Inc ( Get Success ) if recursive { report Read Success ( Get Recursive ) } else { report Read Success ( Get ) } return } s . Stats . Inc ( Get Fail ) if recursive { report Read Failure ( Get Recursive ) } else { report Read Failure ( Get ) } } ( ) n , err : = s . internal Get ( node Path ) if err ! = nil { return nil , err } e : = new Event ( Get , node Path , n . Modified Index , n . Created Index ) e . Etcd Index = s . Current Index e . Node . load Internal Node ( n , recursive , sorted , s . clock ) return e , nil } 
func ( s * store ) Create ( node Path string , dir bool , value string , unique bool , expire Opts TTLOption Set ) ( * Event , error ) { var err * v 2error . Error s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) defer func ( ) { if err = = nil { s . Stats . Inc ( Create Success ) report Write Success ( Create ) return } s . Stats . Inc ( Create Fail ) report Write Failure ( Create ) } ( ) e , err : = s . internal Create ( node Path , dir , value , unique , false , expire Opts . Expire Time , Create ) if err ! = nil { return nil , err } e . Etcd Index = s . Current Index s . Watcher Hub . notify ( e ) return e , nil } 
func ( s * store ) Set ( node Path string , dir bool , value string , expire Opts TTLOption Set ) ( * Event , error ) { var err * v 2error . Error s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) defer func ( ) { if err = = nil { s . Stats . Inc ( Set Success ) report Write Success ( Set ) return } s . Stats . Inc ( Set Fail ) report Write Failure ( Set ) } ( ) if get Err ! = nil & & get Err . Error Code ! = v 2error . Ecode Key Not Found { err = get Err return nil , err } if expire Opts . Refresh { if get Err ! = nil { err = get Err return nil , err } value = n . Value } if err ! = nil { return nil , err } e . Etcd Index = s . Current Index prev . Node . load Internal Node ( n , false , false , s . clock ) e . Prev Node = prev . Node } if ! expire Opts . Refresh { s . Watcher Hub . notify ( e ) } else { e . Set Refresh ( ) s . Watcher Hub . add ( e ) } return e , nil } 
func get Compare Fail Cause ( n * node , which int , prev Value string , prev Index uint 6 4 ) string { switch which { case Compare Index Not Match : return fmt . Sprintf ( " " , prev Index , n . Modified Index ) case Compare Value Not Match : return fmt . Sprintf ( " " , prev Value , n . Value ) default : return fmt . Sprintf ( " " , prev Value , n . Value , prev Index , n . Modified Index ) } } 
func ( s * store ) Delete ( node Path string , dir , recursive bool ) ( * Event , error ) { var err * v 2error . Error s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) defer func ( ) { if err = = nil { s . Stats . Inc ( Delete Success ) report Write Success ( Delete ) return } s . Stats . Inc ( Delete Fail ) report Write Failure ( Delete ) } ( ) node Path = path . Clean ( path . Join ( " " , node Path ) ) } } n , err : = s . internal Get ( node Path ) if err ! = nil { } next Index : = s . Current Index + 1 e : = new Event ( Delete , node Path , next Index , n . Created Index ) e . Etcd Index = next Index e . Prev Node = n . Repr ( false , false , s . clock ) e Node : = e . Node if n . Is Dir ( ) { e Node . Dir = true } callback : = func ( path string ) { } err = n . Remove ( dir , recursive , callback ) if err ! = nil { return nil , err } s . Watcher Hub . notify ( e ) return e , nil } 
func ( s * store ) walk ( node Path string , walk Func func ( prev * node , component string ) ( * node , * v 2error . Error ) ) ( * node , * v 2error . Error ) { components : = strings . Split ( node Path , " " ) curr : = s . Root var err * v 2error . Error for i : = 1 ; i < len ( components ) ; i + + { if len ( components [ i ] ) = = 0 { } curr , err = walk Func ( curr , components [ i ] ) if err ! = nil { return nil , err } } return curr , nil } 
func ( s * store ) Update ( node Path string , new Value string , expire Opts TTLOption Set ) ( * Event , error ) { var err * v 2error . Error s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) defer func ( ) { if err = = nil { s . Stats . Inc ( Update Success ) report Write Success ( Update ) return } s . Stats . Inc ( Update Fail ) report Write Failure ( Update ) } ( ) node Path = path . Clean ( path . Join ( " " , node Path ) ) } curr Index , next Index : = s . Current Index , s . Current Index + 1 n , err : = s . internal Get ( node Path ) if err ! = nil { } if n . Is Dir ( ) & & len ( new Value ) ! = 0 { } if expire Opts . Refresh { new Value = n . Value } e : = new Event ( Update , node Path , next Index , n . Created Index ) e . Etcd Index = next Index e . Prev Node = n . Repr ( false , false , s . clock ) e Node : = e . Node n . Write ( new Value , next Index ) if n . Is Dir ( ) { e Node . Dir = true } else { e Node . Value = & new Value Copy } e Node . Expiration , e Node . TTL = n . expiration And TTL ( s . clock ) if ! expire Opts . Refresh { s . Watcher Hub . notify ( e ) } else { e . Set Refresh ( ) s . Watcher Hub . add ( e ) } s . Current Index = next Index return e , nil } 
func ( s * store ) internal Get ( node Path string ) ( * node , * v 2error . Error ) { node Path = path . Clean ( path . Join ( " " , node Path ) ) walk Func : = func ( parent * node , name string ) ( * node , * v 2error . Error ) { if ! parent . Is Dir ( ) { err : = v 2error . New Error ( v 2error . Ecode Not Dir , parent . Path , s . Current Index ) return nil , err } child , ok : = parent . Children [ name ] if ok { return child , nil } return nil , v 2error . New Error ( v 2error . Ecode Key Not Found , path . Join ( parent . Path , name ) , s . Current Index ) } f , err : = s . walk ( node Path , walk Func ) if err ! = nil { return nil , err } return f , nil } 
func ( s * store ) Delete Expired Keys ( cutoff time . Time ) { s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) for { node : = s . ttl Key Heap . top ( ) if node = = nil | | node . Expire Time . After ( cutoff ) { break } s . Current Index + + e : = new Event ( Expire , node . Path , s . Current Index , node . Created Index ) e . Etcd Index = s . Current Index e . Prev Node = node . Repr ( false , false , s . clock ) if node . Is Dir ( ) { e . Node . Dir = true } callback : = func ( path string ) { } s . ttl Key Heap . pop ( ) node . Remove ( true , true , callback ) report Expired Key ( ) s . Stats . Inc ( Expire Count ) s . Watcher Hub . notify ( e ) } } 
func ( s * store ) check Dir ( parent * node , dir Name string ) ( * node , * v 2error . Error ) { node , ok : = parent . Children [ dir Name ] if ok { if node . Is Dir ( ) { return node , nil } return nil , v 2error . New Error ( v 2error . Ecode Not Dir , node . Path , s . Current Index ) } n : = new Dir ( s , path . Join ( parent . Path , dir Name ) , s . Current Index + 1 , parent , Permanent ) parent . Children [ dir Name ] = n return n , nil } 
func ( s * store ) Save ( ) ( [ ] byte , error ) { b , err : = json . Marshal ( s . Clone ( ) ) if err ! = nil { return nil , err } return b , nil } 
func ( s * store ) Recovery ( state [ ] byte ) error { s . world Lock . Lock ( ) defer s . world Lock . Unlock ( ) err : = json . Unmarshal ( state , s ) if err ! = nil { return err } s . ttl Key Heap = new Ttl Key Heap ( ) s . Root . recover Andclean ( ) return nil } 
func ( g * Generator ) Next ( ) uint 6 4 { suffix : = atomic . Add Uint 6 4 ( & g . suffix , 1 ) id : = g . prefix | lowbit ( suffix , suffix Len ) return id } 
func New Make Mirror Command ( ) * cobra . Command { c : = & cobra . Command { Use : " " , Short : " " , Run : make Mirror Command Func , } c . Flags ( ) . String Var ( & mmprefix , " " , " " , " " ) c . Flags ( ) . String Var ( & mmdestprefix , " " , " " , " " ) c . Flags ( ) . Bool Var ( & mmnodestprefix , " " , false , " " ) c . Flags ( ) . String Var ( & mmcert , " " , " " , " " ) c . Flags ( ) . String Var ( & mmkey , " " , " " , " " ) c . Flags ( ) . String Var ( & mmcacert , " " , " " , " " ) return c } 
func ( cfg Config ) Get Logger ( ) * zap . Logger { cfg . logger Mu . RLock ( ) l : = cfg . logger cfg . logger Mu . RUnlock ( ) return l } 
func ( cfg * Config ) setup Logging ( ) error { len 2 : = len ( cfg . Log Outputs ) if len 1 ! = len 2 { switch { case len 1 > len 2 : cfg . Log Outputs = cfg . Deprecated Log Output case len 1 < len 2 : } } else { if len 1 > 1 { return errors . New ( " " ) } if len 1 < 1 { return errors . New ( " " ) } if reflect . Deep Equal ( cfg . Deprecated Log Output , cfg . Log Outputs ) & & cfg . Deprecated Log Output [ 0 ] ! = Default Log Output { return fmt . Errorf ( " " , cfg . Deprecated Log Output , cfg . Log Outputs ) } if ! reflect . Deep Equal ( cfg . Deprecated Log Output , [ ] string { Default Log Output } ) { fmt . Fprintf ( os . Stderr , " \n " , cfg . Deprecated Log Output ) fmt . Fprintln ( os . Stderr , " " ) } } switch cfg . Logger { case " " : cfg . Peer TLSInfo . Handshake Failure = log TLSHandshake Failure if cfg . Debug { capnslog . Set Global Log Level ( capnslog . DEBUG ) grpc . Enable Tracing = true } else { capnslog . Set Global Log Level ( capnslog . INFO ) } settings , err : = repo Log . Parse Log Level Config ( cfg . Log Pkg Levels ) if err ! = nil { plog . Warningf ( " " , err . Error ( ) ) return nil } repo Log . Set Log Level ( settings ) } if len ( cfg . Log Outputs ) ! = 1 { return fmt . Errorf ( " " , cfg . Log Outputs ) } switch output { case Std Err Log Output : capnslog . Set Formatter ( capnslog . New Pretty Formatter ( os . Stderr , cfg . Debug ) ) case Std Out Log Output : capnslog . Set Formatter ( capnslog . New Pretty Formatter ( os . Stdout , cfg . Debug ) ) case Default Log Output : default : return fmt . Errorf ( " " , output , Default Log Output , Std Err Log Output , Std Out Log Output ) } case " " : if len ( cfg . Log Outputs ) = = 0 { cfg . Log Outputs = [ ] string { Default Log Output } } if len ( cfg . Log Outputs ) > 1 { for _ , v : = range cfg . Log Outputs { if v = = Default Log Output { return fmt . Errorf ( " " , Default Log Output ) } } } output Paths , err Output Paths : = make ( [ ] string , 0 ) , make ( [ ] string , 0 ) is Journal : = false for _ , v : = range cfg . Log Outputs { switch v { case Default Log Output : output Paths = append ( output Paths , Std Err Log Output ) err Output Paths = append ( err Output Paths , Std Err Log Output ) case Journal Log Output : is Journal = true case Std Err Log Output : output Paths = append ( output Paths , Std Err Log Output ) err Output Paths = append ( err Output Paths , Std Err Log Output ) case Std Out Log Output : output Paths = append ( output Paths , Std Out Log Output ) err Output Paths = append ( err Output Paths , Std Out Log Output ) default : output Paths = append ( output Paths , v ) err Output Paths = append ( err Output Paths , v ) } } if ! is Journal { copied : = logutil . Add Output Paths ( logutil . Default Zap Logger Config , output Paths , err Output Paths ) if cfg . Debug { copied . Level = zap . New Atomic Level At ( zap . Debug Level ) grpc . Enable Tracing = true } if cfg . Zap Logger Builder = = nil { cfg . Zap Logger Builder = func ( c * Config ) error { var err error c . logger , err = copied . Build ( ) if err ! = nil { return err } c . logger Mu . Lock ( ) defer c . logger Mu . Unlock ( ) c . logger Config = & copied c . logger Core = nil c . logger Write Syncer = nil grpc Log Once . Do ( func ( ) { gl , err = logutil . New GRPCLogger V 2 ( copied ) if err = = nil { grpclog . Set Logger V 2 ( gl ) } } ) return nil } } } else { if len ( cfg . Log Outputs ) > 1 { for _ , v : = range cfg . Log Outputs { if v ! = Default Log Output { return fmt . Errorf ( " " , cfg . Log Outputs ) } } } if lerr ! = nil { return lerr } lvl : = zap . New Atomic Level At ( zap . Info Level ) if cfg . Debug { lvl = zap . New Atomic Level At ( zap . Debug Level ) grpc . Enable Tracing = true } if cfg . Zap Logger Builder = = nil { cfg . Zap Logger Builder = func ( c * Config ) error { c . logger = zap . New ( cr , zap . Add Caller ( ) , zap . Error Output ( syncer ) ) c . logger Mu . Lock ( ) defer c . logger Mu . Unlock ( ) c . logger Config = nil c . logger Core = cr c . logger Write Syncer = syncer grpc Log Once . Do ( func ( ) { grpclog . Set Logger V 2 ( logutil . New GRPCLogger V 2From Zap Core ( cr , syncer ) ) } ) return nil } } } err : = cfg . Zap Logger Builder ( cfg ) if err ! = nil { return err } log TLSHandshake Failure : = func ( conn * tls . Conn , err error ) { state : = conn . Connection State ( ) remote Addr : = conn . Remote Addr ( ) . String ( ) server Name : = state . Server Name if len ( state . Peer Certificates ) > 0 { cert : = state . Peer Certificates [ 0 ] ips : = make ( [ ] string , 0 , len ( cert . IPAddresses ) ) for i : = range cert . IPAddresses { ips [ i ] = cert . IPAddresses [ i ] . String ( ) } cfg . logger . Warn ( " " , zap . String ( " " , remote Addr ) , zap . String ( " " , server Name ) , zap . Strings ( " " , ips ) , zap . Strings ( " " , cert . DNSNames ) , zap . Error ( err ) , ) } else { cfg . logger . Warn ( " " , zap . String ( " " , remote Addr ) , zap . String ( " " , server Name ) , zap . Error ( err ) , ) } } cfg . Client TLSInfo . Handshake Failure = log TLSHandshake Failure cfg . Peer TLSInfo . Handshake Failure = log TLSHandshake Failure default : return fmt . Errorf ( " " , cfg . Logger ) } return nil } 
func New Zap Core Logger Builder ( lg * zap . Logger , cr zapcore . Core , syncer zapcore . Write Syncer ) func ( * Config ) error { return func ( cfg * Config ) error { cfg . logger Mu . Lock ( ) defer cfg . logger Mu . Unlock ( ) cfg . logger = lg cfg . logger Config = nil cfg . logger Core = cr cfg . logger Write Syncer = syncer grpc Log Once . Do ( func ( ) { grpclog . Set Logger V 2 ( logutil . New GRPCLogger V 2From Zap Core ( cr , syncer ) ) } ) return nil } } 
func New Syncer ( c * clientv 3 . Client , prefix string , rev int 6 4 ) Syncer { return & syncer { c : c , prefix : prefix , rev : rev } } 
func Drop Port ( port int ) error { cmd Str : = fmt . Sprintf ( " " , port ) if _ , err : = exec . Command ( " " , " " , cmd Str ) . Output ( ) ; err ! = nil { return err } cmd Str = fmt . Sprintf ( " " , port ) _ , err : = exec . Command ( " " , " " , cmd Str ) . Output ( ) return err } 
func Set Latency ( ms , rv int ) error { ifces , err : = Get Default Interfaces ( ) if err ! = nil { return err } if rv > ms { rv = 1 } for ifce : = range ifces { cmd Str : = fmt . Sprintf ( " " , ifce , ms , rv ) _ , err = exec . Command ( " " , " " , cmd Str ) . Output ( ) if err ! = nil { _ , err = exec . Command ( " " , " " , cmd Str ) . Output ( ) if err ! = nil { return err } } } return nil } 
func Remove Latency ( ) error { ifces , err : = Get Default Interfaces ( ) if err ! = nil { return err } for ifce : = range ifces { _ , err = exec . Command ( " " , " " , fmt . Sprintf ( " " , ifce ) ) . Output ( ) if err ! = nil { return err } } return nil } 
func New Txn Command ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run : txn Command Func , } cmd . Flags ( ) . Bool Var P ( & txn Interactive , " " , " " , false , " " ) return cmd } 
func txn Command Func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = 0 { Exit With Error ( Exit Bad Args , fmt . Errorf ( " " ) ) } reader : = bufio . New Reader ( os . Stdin ) txn : = must Client From Cmd ( cmd ) . Txn ( context . Background ( ) ) prompt Interactive ( " " ) txn . If ( read Compares ( reader ) . . . ) prompt Interactive ( " " ) txn . Then ( read Ops ( reader ) . . . ) prompt Interactive ( " " ) txn . Else ( read Ops ( reader ) . . . ) resp , err : = txn . Commit ( ) if err ! = nil { Exit With Error ( Exit Error , err ) } display . Txn ( * resp ) } 
func New ( lg * zap . Logger , mode string , retention time . Duration , rg Rev Getter , c Compactable , ) ( Compactor , error ) { switch mode { case Mode Periodic : return new Periodic ( lg , clockwork . New Real Clock ( ) , retention , rg , c ) , nil case Mode Revision : return new Revision ( lg , clockwork . New Real Clock ( ) , int 6 4 ( retention ) , rg , c ) , nil default : return nil , fmt . Errorf ( " " , mode ) } } 
func print Response Key ( resp * client . Response , format string ) { } else { fmt . Println ( " " , resp . Prev Node . Value ) } case " " : fmt . Println ( " " , resp . Node . Created Index ) fmt . Println ( " " , resp . Node . Modified Index ) if resp . Prev Node ! = nil { fmt . Println ( " " , resp . Prev Node . Value ) } fmt . Println ( " " , resp . Node . TTL ) fmt . Println ( " " , resp . Index ) if resp . Action ! = " " { fmt . Println ( " " ) fmt . Println ( resp . Node . Value ) } case " " : b , err : = json . Marshal ( resp ) if err ! = nil { panic ( err ) } fmt . Println ( string ( b ) ) default : fmt . Fprintln ( os . Stderr , " " , format ) } } 
func Register Lock Handler ( ctx context . Context , mux * runtime . Serve Mux , conn * grpc . Client Conn ) error { return Register Lock Handler Client ( ctx , mux , v 3lockpb . New Lock Client ( conn ) ) } 
func Register Lock Handler Client ( ctx context . Context , mux * runtime . Serve Mux , client v 3lockpb . Lock Client ) error { mux . Handle ( " " , pattern _Lock _Lock _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lock _Lock _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lock _Lock _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) mux . Handle ( " " , pattern _Lock _Unlock _ 0 , func ( w http . Response Writer , req * http . Request , path Params map [ string ] string ) { ctx , cancel : = context . With Cancel ( req . Context ( ) ) defer cancel ( ) if cn , ok : = w . ( http . Close Notifier ) ; ok { go func ( done < - chan struct { } , closed < - chan bool ) { select { case < - done : case < - closed : cancel ( ) } } ( ctx . Done ( ) , cn . Close Notify ( ) ) } inbound Marshaler , outbound Marshaler : = runtime . Marshaler For Request ( mux , req ) rctx , err : = runtime . Annotate Context ( ctx , mux , req ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } resp , md , err : = request _Lock _Unlock _ 0 ( rctx , inbound Marshaler , client , req , path Params ) ctx = runtime . New Server Metadata Context ( ctx , md ) if err ! = nil { runtime . HTTPError ( ctx , mux , outbound Marshaler , w , req , err ) return } forward _Lock _Unlock _ 0 ( ctx , mux , outbound Marshaler , w , req , resp , mux . Get Forward Response Options ( ) . . . ) } ) return nil } 
func New Server ( cfg Server Config ) Server { s : = & server { lg : cfg . Logger , from : cfg . From , to : cfg . To , tls Info : cfg . TLSInfo , dial Timeout : cfg . Dial Timeout , buffer Size : cfg . Buffer Size , retry Interval : cfg . Retry Interval , readyc : make ( chan struct { } ) , donec : make ( chan struct { } ) , errc : make ( chan error , 1 6 ) , pause Acceptc : make ( chan struct { } ) , pause Txc : make ( chan struct { } ) , pause Rxc : make ( chan struct { } ) , } _ , from Port , err : = net . Split Host Port ( cfg . From . Host ) if err = = nil { s . from Port , _ = strconv . Atoi ( from Port ) } var to Port string _ , to Port , err = net . Split Host Port ( cfg . To . Host ) if err = = nil { s . to Port , _ = strconv . Atoi ( to Port ) } if s . dial Timeout = = 0 { s . dial Timeout = default Dial Timeout } if s . buffer Size = = 0 { s . buffer Size = default Buffer Size } if s . retry Interval = = 0 { s . retry Interval = default Retry Interval } if s . lg = = nil { s . lg = default Logger } close ( s . pause Acceptc ) close ( s . pause Txc ) close ( s . pause Rxc ) if strings . Has Prefix ( s . from . Scheme , " " ) { s . from . Scheme = " " } if strings . Has Prefix ( s . to . Scheme , " " ) { s . to . Scheme = " " } addr : = fmt . Sprintf ( " " , s . from Port ) if s . from Port = = 0 { } var ln net . Listener if ! s . tls Info . Empty ( ) { ln , err = transport . New Listener ( addr , s . from . Scheme , & s . tls Info ) } else { ln , err = net . Listen ( s . from . Scheme , addr ) } if err ! = nil { s . errc < - err s . Close ( ) return s } s . listener = ln s . close Wg . Add ( 1 ) go s . listen And Serve ( ) s . lg . Info ( " " , zap . String ( " " , s . From ( ) ) , zap . String ( " " , s . To ( ) ) ) return s } 
func ( s * server ) listen And Serve ( ) { defer s . close Wg . Done ( ) s . lg . Info ( " " , zap . String ( " " , s . From ( ) ) ) close ( s . readyc ) for { s . pause Accept Mu . Lock ( ) pausec : = s . pause Acceptc s . pause Accept Mu . Unlock ( ) select { case < - pausec : case < - s . donec : return } s . latency Accept Mu . RLock ( ) lat : = s . latency Accept s . latency Accept Mu . RUnlock ( ) if lat > 0 { select { case < - time . After ( lat ) : case < - s . donec : return } } s . listener Mu . RLock ( ) ln : = s . listener s . listener Mu . RUnlock ( ) in , err : = ln . Accept ( ) if err ! = nil { select { case s . errc < - err : select { case < - s . donec : return default : } case < - s . donec : return } s . lg . Debug ( " " , zap . Error ( err ) ) if strings . Has Suffix ( err . Error ( ) , " " ) { select { case < - time . After ( s . retry Interval ) : case < - s . donec : return } s . lg . Debug ( " " , zap . String ( " " , s . From ( ) ) ) if err = s . Reset Listener ( ) ; err ! = nil { select { case s . errc < - err : select { case < - s . donec : return default : } case < - s . donec : return } s . lg . Warn ( " " , zap . Error ( err ) ) } } continue } var out net . Conn if ! s . tls Info . Empty ( ) { var tp * http . Transport tp , err = transport . New Transport ( s . tls Info , s . dial Timeout ) if err ! = nil { select { case s . errc < - err : select { case < - s . donec : return default : } case < - s . donec : return } continue } out , err = tp . Dial ( s . to . Scheme , s . to . Host ) } else { out , err = net . Dial ( s . to . Scheme , s . to . Host ) } if err ! = nil { select { case s . errc < - err : select { case < - s . donec : return default : } case < - s . donec : return } s . lg . Debug ( " " , zap . Error ( err ) ) continue } go func ( ) { out . Close ( ) in . Close ( ) } ( ) go func ( ) { in . Close ( ) out . Close ( ) } ( ) } } 
func ( sctx * serve Ctx ) serve ( s * etcdserver . Etcd Server , tlsinfo * transport . TLSInfo , handler http . Handler , err Handler func ( error ) , gopts . . . grpc . Server Option ) ( err error ) { logger : = default Log . New ( ioutil . Discard , " " , 0 ) < - s . Ready Notify ( ) if sctx . lg = = nil { plog . Info ( " " ) } m : = cmux . New ( sctx . l ) v 3c : = v 3client . New ( s ) serv Election : = v 3election . New Election Server ( v 3c ) serv Lock : = v 3lock . New Lock Server ( v 3c ) var gs * grpc . Server defer func ( ) { if err ! = nil & & gs ! = nil { gs . Stop ( ) } } ( ) if sctx . insecure { gs = v 3rpc . Server ( s , nil , gopts . . . ) v 3electionpb . Register Election Server ( gs , serv Election ) v 3lockpb . Register Lock Server ( gs , serv Lock ) if sctx . service Register ! = nil { sctx . service Register ( gs ) } grpcl : = m . Match ( cmux . HTTP 2 ( ) ) go func ( ) { err Handler ( gs . Serve ( grpcl ) ) } ( ) var gwmux * gw . Serve Mux if s . Cfg . Enable GRPCGateway { gwmux , err = sctx . register Gateway ( [ ] grpc . Dial Option { grpc . With Insecure ( ) } ) if err ! = nil { return err } } httpmux : = sctx . create Mux ( gwmux , handler ) srvhttp : = & http . Server { Handler : create Access Controller ( sctx . lg , s , httpmux ) , Error Log : logger , httpl : = m . Match ( cmux . HTTP 1 ( ) ) go func ( ) { err Handler ( srvhttp . Serve ( httpl ) ) } ( ) sctx . servers C < - & servers { grpc : gs , http : srvhttp } if sctx . lg ! = nil { sctx . lg . Info ( " " , zap . String ( " " , sctx . l . Addr ( ) . String ( ) ) , ) } else { plog . Noticef ( " " , sctx . l . Addr ( ) . String ( ) ) } } if sctx . secure { tlscfg , tls Err : = tlsinfo . Server Config ( ) if tls Err ! = nil { return tls Err } gs = v 3rpc . Server ( s , tlscfg , gopts . . . ) v 3electionpb . Register Election Server ( gs , serv Election ) v 3lockpb . Register Lock Server ( gs , serv Lock ) if sctx . service Register ! = nil { sctx . service Register ( gs ) } handler = grpc Handler Func ( gs , handler ) var gwmux * gw . Serve Mux if s . Cfg . Enable GRPCGateway { dtls : = tlscfg . Clone ( ) creds : = credentials . New TLS ( dtls ) opts : = [ ] grpc . Dial Option { grpc . With Transport Credentials ( creds ) } gwmux , err = sctx . register Gateway ( opts ) if err ! = nil { return err } } var tlsl net . Listener tlsl , err = transport . New TLSListener ( m . Match ( cmux . Any ( ) ) , tlsinfo ) if err ! = nil { return err } srv : = & http . Server { Handler : create Access Controller ( sctx . lg , s , httpmux ) , TLSConfig : tlscfg , Error Log : logger , go func ( ) { err Handler ( srv . Serve ( tlsl ) ) } ( ) sctx . servers C < - & servers { secure : true , grpc : gs , http : srv } if sctx . lg ! = nil { sctx . lg . Info ( " " , zap . String ( " " , sctx . l . Addr ( ) . String ( ) ) , ) } else { plog . Infof ( " " , sctx . l . Addr ( ) . String ( ) ) } } close ( sctx . servers C ) return m . Serve ( ) } 
func grpc Handler Func ( grpc Server * grpc . Server , other Handler http . Handler ) http . Handler { if other Handler = = nil { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { grpc Server . Serve HTTP ( w , r ) } ) } return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if r . Proto Major = = 2 & & strings . Contains ( r . Header . Get ( " " ) , " " ) { grpc Server . Serve HTTP ( w , r ) } else { other Handler . Serve HTTP ( w , r ) } } ) } 
func create Access Controller ( lg * zap . Logger , s * etcdserver . Etcd Server , mux * http . Serve Mux ) http . Handler { return & access Controller { lg : lg , s : s , mux : mux } } 
func add CORSHeader ( w http . Response Writer , origin string ) { w . Header ( ) . Add ( " " , " " ) w . Header ( ) . Add ( " " , origin ) w . Header ( ) . Add ( " " , " " ) } 
func Wrap CORS ( cors map [ string ] struct { } , h http . Handler ) http . Handler { return & cors Handler { ac : & etcdserver . Access Controller { CORS : cors } , h : h , } } 
func ( txn * txn Leasing ) fallback ( ops [ ] v 3 . Op ) ( fb Ops [ ] v 3 . Op ) { for _ , op : = range ops { if op . Is Get ( ) { continue } lkey , lend : = txn . lkv . pfx + string ( op . Key Bytes ( ) ) , " " if len ( op . Range Bytes ( ) ) > 0 { lend = txn . lkv . pfx + string ( op . Range Bytes ( ) ) } fb Ops = append ( fb Ops , v 3 . Op Get ( lkey , v 3 . With Range ( lend ) ) ) } return fb Ops } 
func IDFrom String ( s string ) ( ID , error ) { i , err : = strconv . Parse Uint ( s , 1 6 , 6 4 ) return ID ( i ) , err } 
func acquire Directory Lock ( dir Path string , pid File Name string , read Only bool ) ( * directory Lock Guard , error ) { if err ! = nil { return nil , errors . Wrap ( err , " " ) } f , err : = os . Open ( dir Path ) if err ! = nil { return nil , errors . Wrapf ( err , " " , dir Path ) } opts : = unix . LOCK _EX | unix . LOCK _NB if read Only { opts = unix . LOCK _SH | unix . LOCK _NB } err = unix . Flock ( int ( f . Fd ( ) ) , opts ) if err ! = nil { f . Close ( ) return nil , errors . Wrapf ( err , " " , dir Path ) } if ! read Only { if err ! = nil { f . Close ( ) return nil , errors . Wrapf ( err , " " , abs Pid File Path ) } } return & directory Lock Guard { f , abs Pid File Path , read Only } , nil } 
func ( guard * directory Lock Guard ) release ( ) error { var err error if ! guard . read Only { } if close Err : = guard . f . Close ( ) ; err = = nil { err = close Err } guard . path = " " guard . f = nil return err } 
func ( v * Value Struct ) Encoded Size ( ) uint 1 6 { sz : = len ( v . Value ) + 2 if v . Expires At = = 0 { return uint 1 6 ( sz + 1 ) } enc : = size Varint ( v . Expires At ) return uint 1 6 ( sz + enc ) } 
func ( v * Value Struct ) Decode ( b [ ] byte ) { v . Meta = b [ 0 ] v . User Meta = b [ 1 ] var sz int v . Expires At , sz = binary . Uvarint ( b [ 2 : ] ) v . Value = b [ 2 + sz : ] } 
func ( v * Value Struct ) Encode ( b [ ] byte ) { b [ 0 ] = v . Meta b [ 1 ] = v . User Meta sz : = binary . Put Uvarint ( b [ 2 : ] , v . Expires At ) copy ( b [ 2 + sz : ] , v . Value ) } 
func ( v * Value Struct ) Encode To ( buf * bytes . Buffer ) { buf . Write Byte ( v . Meta ) buf . Write Byte ( v . User Meta ) var enc [ binary . Max Varint Len 6 4 ] byte sz : = binary . Put Uvarint ( enc [ : ] , v . Expires At ) buf . Write ( enc [ : sz ] ) buf . Write ( v . Value ) } 
func New Merge Iterator ( iters [ ] Iterator , reversed bool ) * Merge Iterator { m : = & Merge Iterator { all : iters , reversed : reversed } m . h = make ( elem Heap , 0 , len ( iters ) ) m . init Heap ( ) return m } 
func ( s * Merge Iterator ) init Heap ( ) { s . h = s . h [ : 0 ] for idx , itr : = range s . all { if ! itr . Valid ( ) { continue } e : = & elem { itr : itr , nice : idx , reversed : s . reversed } s . h = append ( s . h , e ) } heap . Init ( & s . h ) for len ( s . h ) > 0 { it : = s . h [ 0 ] . itr if it = = nil | | ! it . Valid ( ) { heap . Pop ( & s . h ) continue } s . store Key ( s . h [ 0 ] . itr ) break } } 
func ( s * Merge Iterator ) Valid ( ) bool { if s = = nil { return false } if len ( s . h ) = = 0 { return false } return s . h [ 0 ] . itr . Valid ( ) } 
func ( s * Merge Iterator ) Key ( ) [ ] byte { if len ( s . h ) = = 0 { return nil } return s . h [ 0 ] . itr . Key ( ) } 
func ( s * Merge Iterator ) Value ( ) Value Struct { if len ( s . h ) = = 0 { return Value Struct { } } return s . h [ 0 ] . itr . Value ( ) } 
func ( s * Merge Iterator ) Next ( ) { if len ( s . h ) = = 0 { return } smallest : = s . h [ 0 ] . itr smallest . Next ( ) for len ( s . h ) > 0 { smallest = s . h [ 0 ] . itr if ! smallest . Valid ( ) { heap . Pop ( & s . h ) continue } heap . Fix ( & s . h , 0 ) smallest = s . h [ 0 ] . itr if smallest . Valid ( ) { if ! bytes . Equal ( smallest . Key ( ) , s . cur Key ) { break } smallest . Next ( ) } } if ! smallest . Valid ( ) { return } s . store Key ( smallest ) } 
func ( s * Merge Iterator ) Rewind ( ) { for _ , itr : = range s . all { itr . Rewind ( ) } s . init Heap ( ) } 
func ( s * Merge Iterator ) Seek ( key [ ] byte ) { for _ , itr : = range s . all { itr . Seek ( key ) } s . init Heap ( ) } 
func ( s * Merge Iterator ) Close ( ) error { for _ , itr : = range s . all { if err : = itr . Close ( ) ; err ! = nil { return errors . Wrap ( err , " " ) } } return nil } 
func ( p value Pointer ) Encode ( b [ ] byte ) [ ] byte { binary . Big Endian . Put Uint 3 2 ( b [ : 4 ] , p . Fid ) binary . Big Endian . Put Uint 3 2 ( b [ 4 : 8 ] , p . Len ) binary . Big Endian . Put Uint 3 2 ( b [ 8 : 1 2 ] , p . Offset ) return b [ : vptr Size ] } 
func ( h * header ) Decode ( buf [ ] byte ) { h . klen = binary . Big Endian . Uint 3 2 ( buf [ 0 : 4 ] ) h . vlen = binary . Big Endian . Uint 3 2 ( buf [ 4 : 8 ] ) h . expires At = binary . Big Endian . Uint 6 4 ( buf [ 8 : 1 6 ] ) h . meta = buf [ 1 6 ] h . user Meta = buf [ 1 7 ] } 
func encode Entry ( e * Entry , buf * bytes . Buffer ) ( int , error ) { h : = header { klen : uint 3 2 ( len ( e . Key ) ) , vlen : uint 3 2 ( len ( e . Value ) ) , expires At : e . Expires At , meta : e . meta , user Meta : e . User Meta , } var header Enc [ header Buf Size ] byte h . Encode ( header Enc [ : ] ) hash : = crc 3 2 . New ( y . Castagnoli Crc Table ) buf . Write ( header Enc [ : ] ) hash . Write ( header Enc [ : ] ) buf . Write ( e . Key ) hash . Write ( e . Key ) buf . Write ( e . Value ) hash . Write ( e . Value ) var crc Buf [ crc 3 2 . Size ] byte binary . Big Endian . Put Uint 3 2 ( crc Buf [ : ] , hash . Sum 3 2 ( ) ) buf . Write ( crc Buf [ : ] ) return len ( header Enc ) + len ( e . Key ) + len ( e . Value ) + len ( crc Buf ) , nil } 
func ( db * DB ) New Write Batch ( ) * Write Batch { txn : = db . new Transaction ( true , true ) return & Write Batch { db : db , txn : txn } } 
func ( wb * Write Batch ) Set Entry ( e * Entry ) error { wb . Lock ( ) defer wb . Unlock ( ) if err : = wb . txn . Set Entry ( e ) ; err ! = Err Txn Too Big { return err } } return err } return nil } 
func ( wb * Write Batch ) Set ( k , v [ ] byte , meta byte ) error { e : = & Entry { Key : k , Value : v , User Meta : meta } return wb . Set Entry ( e ) } 
func ( wb * Write Batch ) Set With TTL ( key , val [ ] byte , dur time . Duration ) error { expire : = time . Now ( ) . Add ( dur ) . Unix ( ) e : = & Entry { Key : key , Value : val , Expires At : uint 6 4 ( expire ) } return wb . Set Entry ( e ) } 
func ( wb * Write Batch ) Delete ( k [ ] byte ) error { wb . Lock ( ) defer wb . Unlock ( ) if err : = wb . txn . Delete ( k ) ; err ! = Err Txn Too Big { return err } if err : = wb . commit ( ) ; err ! = nil { return err } if err : = wb . txn . Delete ( k ) ; err ! = nil { wb . err = err return err } return nil } 
func ( wb * Write Batch ) commit ( ) error { if wb . err ! = nil { return wb . err } wb . txn . Commit With ( wb . callback ) wb . txn = wb . db . new Transaction ( true , true ) return wb . err } 
func ( wb * Write Batch ) Flush ( ) error { wb . Lock ( ) _ = wb . commit ( ) wb . txn . Discard ( ) wb . Unlock ( ) wb . wg . Wait ( ) } 
func ( wb * Write Batch ) Error ( ) error { wb . Lock ( ) defer wb . Unlock ( ) return wb . err } 
func Open ( opt Options ) ( db * DB , err error ) { opt . max Batch Size = ( 1 5 * opt . Max Table Size ) / 1 0 0 opt . max Batch Count = opt . max Batch Size / int 6 4 ( skl . Max Node Size ) if opt . Value Threshold > math . Max Uint 1 6 - 1 6 { return nil , Err Value Threshold } if opt . Read Only { } for _ , path : = range [ ] string { opt . Dir , opt . Value Dir } { dir Exists , err : = exists ( path ) if err ! = nil { return nil , y . Wrapf ( err , " " , path ) } if ! dir Exists { if opt . Read Only { return nil , y . Wrapf ( err , " " , path ) } if err ! = nil { return nil , y . Wrapf ( err , " " , path ) } } } abs Dir , err : = filepath . Abs ( opt . Dir ) if err ! = nil { return nil , err } abs Value Dir , err : = filepath . Abs ( opt . Value Dir ) if err ! = nil { return nil , err } var dir Lock Guard , value Dir Lock Guard * directory Lock Guard dir Lock Guard , err = acquire Directory Lock ( opt . Dir , lock File , opt . Read Only ) if err ! = nil { return nil , err } defer func ( ) { if dir Lock Guard ! = nil { _ = dir Lock Guard . release ( ) } } ( ) if abs Value Dir ! = abs Dir { value Dir Lock Guard , err = acquire Directory Lock ( opt . Value Dir , lock File , opt . Read Only ) if err ! = nil { return nil , err } defer func ( ) { if value Dir Lock Guard ! = nil { _ = value Dir Lock Guard . release ( ) } } ( ) } if ! ( opt . Value Log File Size < = 2 < < 3 0 & & opt . Value Log File Size > = 1 < < 2 0 ) { return nil , Err Value Log Size } if ! ( opt . Value Log Loading Mode = = options . File IO | | opt . Value Log Loading Mode = = options . Memory Map ) { return nil , Err Invalid Loading Mode } manifest File , manifest , err : = open Or Create Manifest File ( opt . Dir , opt . Read Only ) if err ! = nil { return nil , err } defer func ( ) { if manifest File ! = nil { _ = manifest File . close ( ) } } ( ) db = & DB { imm : make ( [ ] * skl . Skiplist , 0 , opt . Num Memtables ) , flush Chan : make ( chan flush Task , opt . Num Memtables ) , write Ch : make ( chan * request , kv Write Ch Capacity ) , opt : opt , manifest : manifest File , elog : trace . New Event Log ( " " , " " ) , dir Lock Guard : dir Lock Guard , value Dir Guard : value Dir Lock Guard , orc : new Oracle ( opt ) , } db . closers . update Size = y . New Closer ( 1 ) go db . update Size ( db . closers . update Size ) db . mt = skl . New Skiplist ( arena Size ( opt ) ) } if ! opt . Read Only { db . closers . compactors = y . New Closer ( 1 ) db . lc . start Compact ( db . closers . compactors ) db . closers . memtable = y . New Closer ( 1 ) go db . flush Memtable ( db . closers . memtable ) } head Key : = y . Key With Ts ( head , math . Max Uint 6 4 ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } db . orc . next Txn Ts = vs . Version var vptr value Pointer if len ( vs . Value ) > 0 { vptr . Decode ( vs . Value ) } replay Closer : = y . New Closer ( 1 ) go db . do Writes ( replay Closer ) if err = db . vlog . open ( db , vptr , db . replay Function ( ) ) ; err ! = nil { return db , err } replay Closer . Signal And Wait ( ) db . orc . next Txn Ts + + db . write Ch = make ( chan * request , kv Write Ch Capacity ) db . closers . writes = y . New Closer ( 1 ) go db . do Writes ( db . closers . writes ) db . closers . value GC = y . New Closer ( 1 ) go db . vlog . wait On GC ( db . closers . value GC ) value Dir Lock Guard = nil dir Lock Guard = nil manifest File = nil return db , nil } 
func ( db * DB ) Close ( ) ( err error ) { db . elog . Printf ( " " ) atomic . Store Int 3 2 ( & db . block Writes , 1 ) } for { pushed Flush Task : = func ( ) bool { db . Lock ( ) defer db . Unlock ( ) y . Assert True ( db . mt ! = nil ) select { case db . flush Chan < - flush Task { mt : db . mt , vptr : db . vhead } : db . imm = append ( db . imm , db . mt ) db . mt = nil db . elog . Printf ( " \n " ) return true default : return false } ( ) if pushed Flush Task { break } time . Sleep ( 1 0 * time . Millisecond ) } } db . stop Compactions ( ) switch err { case err Fill Tables : default : db . opt . Warningf ( " " , err ) } } if lc Err : = db . lc . close ( ) ; err = = nil { err = errors . Wrap ( lc Err , " " ) } db . elog . Printf ( " " ) db . closers . update Size . Signal And Wait ( ) db . orc . Stop ( ) db . elog . Finish ( ) if db . dir Lock Guard ! = nil { if guard Err : = db . dir Lock Guard . release ( ) ; err = = nil { err = errors . Wrap ( guard Err , " " ) } } if db . value Dir Guard ! = nil { if guard Err : = db . value Dir Guard . release ( ) ; err = = nil { err = errors . Wrap ( guard Err , " " ) } } if manifest Err : = db . manifest . close ( ) ; err = = nil { err = errors . Wrap ( manifest Err , " " ) } } if sync Err : = sync Dir ( db . opt . Value Dir ) ; err = = nil { err = errors . Wrap ( sync Err , " " ) } return err } 
func sync Dir ( dir string ) error { f , err : = open Dir ( dir ) if err ! = nil { return errors . Wrapf ( err , " " , dir ) } err = f . Sync ( ) close Err : = f . Close ( ) if err ! = nil { return errors . Wrapf ( err , " " , dir ) } return errors . Wrapf ( close Err , " " , dir ) } 
func ( db * DB ) get Mem Tables ( ) ( [ ] * skl . Skiplist , func ( ) ) { db . RLock ( ) defer db . RUnlock ( ) tables : = make ( [ ] * skl . Skiplist , len ( db . imm ) + 1 ) tables [ 0 ] . Incr Ref ( ) for i : = range db . imm { tables [ i + 1 ] = db . imm [ last - i ] tables [ i + 1 ] . Incr Ref ( ) } return tables , func ( ) { for _ , tbl : = range tables { tbl . Decr Ref ( ) } } } 
func ( db * DB ) get ( key [ ] byte ) ( y . Value Struct , error ) { tables , decr : = db . get Mem Tables ( ) defer decr ( ) var max Vs * y . Value Struct var version uint 6 4 if bytes . Has Prefix ( key , badger Move ) { version = y . Parse Ts ( key ) } y . Num Gets . Add ( 1 ) for i : = 0 ; i < len ( tables ) ; i + + { vs : = tables [ i ] . Get ( key ) y . Num Memtable Gets . Add ( 1 ) if vs . Meta = = 0 & & vs . Value = = nil { continue } } if max Vs . Version < vs . Version { * max Vs = vs } } return db . lc . get ( key , max Vs ) } 
func ( db * DB ) write Requests ( reqs [ ] * request ) error { if len ( reqs ) = = 0 { return nil } done : = func ( err error ) { for _ , r : = range reqs { r . Err = err r . Wg . Done ( ) } } db . elog . Printf ( " " ) err : = db . vlog . write ( reqs ) if err ! = nil { done ( err ) return err } db . elog . Printf ( " " ) var count int for _ , b : = range reqs { if len ( b . Entries ) = = 0 { continue } count + = len ( b . Entries ) var i uint 6 4 for err = db . ensure Room For Write ( ) ; err = = err No Room ; err = db . ensure Room For Write ( ) { i + + if i % 1 0 0 = = 0 { db . elog . Printf ( " " ) } } if err ! = nil { done ( err ) return errors . Wrap ( err , " " ) } if err : = db . write To LSM ( b ) ; err ! = nil { done ( err ) return errors . Wrap ( err , " " ) } db . update Head ( b . Ptrs ) } done ( nil ) db . elog . Printf ( " " , count ) return nil } 
func ( db * DB ) batch Set ( entries [ ] * Entry ) error { req , err : = db . send To Write Ch ( entries ) if err ! = nil { return err } return req . Wait ( ) } 
func ( db * DB ) batch Set Async ( entries [ ] * Entry , f func ( error ) ) error { req , err : = db . send To Write Ch ( entries ) if err ! = nil { return err } go func ( ) { err : = req . Wait ( ) } ( ) return nil } 
func ( db * DB ) ensure Room For Write ( ) error { var err error db . Lock ( ) defer db . Unlock ( ) if db . mt . Mem Size ( ) < db . opt . Max Table Size { return nil } y . Assert True ( db . mt ! = nil ) select { case db . flush Chan < - flush Task { mt : db . mt , vptr : db . vhead } : db . elog . Printf ( " " ) if err ! = nil { return err } db . elog . Printf ( " \n " , db . mt . Mem Size ( ) , len ( db . flush Chan ) ) db . mt = skl . New Skiplist ( arena Size ( db . opt ) ) default : } } 
func write Level 0Table ( ft flush Task , f io . Writer ) error { iter : = ft . mt . New Iterator ( ) defer iter . Close ( ) b : = table . New Table Builder ( ) defer b . Close ( ) for iter . Seek To First ( ) ; iter . Valid ( ) ; iter . Next ( ) { if len ( ft . drop Prefix ) > 0 & & bytes . Has Prefix ( iter . Key ( ) , ft . drop Prefix ) { continue } if err : = b . Add ( iter . Key ( ) , iter . Value ( ) ) ; err ! = nil { return err } } _ , err : = f . Write ( b . Finish ( ) ) return err } 
func ( db * DB ) handle Flush Task ( ft flush Task ) error { if ! ft . mt . Empty ( ) { db . elog . Printf ( " \n " , ft . vptr ) offset : = make ( [ ] byte , vptr Size ) ft . vptr . Encode ( offset ) ft . mt . Put ( head Ts , y . Value Struct { Value : offset } ) ft . mt . Put ( discard Stats Key , y . Value Struct { Value : db . vlog . encoded Discard Stats ( ) } ) } file ID : = db . lc . reserve File ID ( ) fd , err : = y . Create Synced File ( table . New Filename ( file ID , db . opt . Dir ) , true ) if err ! = nil { return y . Wrap ( err ) } go func ( ) { dir Sync Ch < - sync Dir ( db . opt . Dir ) } ( ) err = write Level 0Table ( ft , fd ) dir Sync Err : = < - dir Sync Ch if err ! = nil { db . elog . Errorf ( " " , err ) return err } if dir Sync Err ! = nil { } tbl , err : = table . Open Table ( fd , db . opt . Table Loading Mode , nil ) if err ! = nil { db . elog . Printf ( " " , err ) return err } tbl . Decr Ref ( ) return err } 
func ( db * DB ) flush Memtable ( lc * y . Closer ) error { defer lc . Done ( ) for ft : = range db . flush Chan { if ft . mt = = nil { } for { err : = db . handle Flush Task ( ft ) if err = = nil { db . imm = db . imm [ 1 : ] ft . mt . Decr Ref ( ) db . Unlock ( ) break } time . Sleep ( time . Second ) } } return nil } 
func ( db * DB ) calculate Size ( ) { new Int : = func ( val int 6 4 ) * expvar . Int { v : = new ( expvar . Int ) v . Add ( val ) return v } total Size : = func ( dir string ) ( int 6 4 , int 6 4 ) { var lsm Size , vlog Size int 6 4 err : = filepath . Walk ( dir , func ( path string , info os . File Info , err error ) error { if err ! = nil { return err } ext : = filepath . Ext ( path ) if ext = = " " { lsm Size + = info . Size ( ) } else if ext = = " " { vlog Size + = info . Size ( ) } return nil } ) if err ! = nil { db . elog . Printf ( " " , dir ) } return lsm Size , vlog Size } lsm Size , vlog Size : = total Size ( db . opt . Dir ) y . LSMSize . Set ( db . opt . Dir , new Int ( lsm Size ) ) } y . Vlog Size . Set ( db . opt . Dir , new Int ( vlog Size ) ) } 
func ( db * DB ) Run Value Log GC ( discard Ratio float 6 4 ) error { if discard Ratio > = 1 . 0 | | discard Ratio < = 0 . 0 { return Err Invalid Request } if err ! = nil { return errors . Wrap ( err , " " ) } var head value Pointer if len ( val . Value ) > 0 { head . Decode ( val . Value ) } } 
func ( db * DB ) Size ( ) ( lsm , vlog int 6 4 ) { if y . LSMSize . Get ( db . opt . Dir ) = = nil { lsm , vlog = 0 , 0 return } lsm = y . LSMSize . Get ( db . opt . Dir ) . ( * expvar . Int ) . Value ( ) vlog = y . Vlog Size . Get ( db . opt . Dir ) . ( * expvar . Int ) . Value ( ) return } 
func ( seq * Sequence ) Next ( ) ( uint 6 4 , error ) { seq . Lock ( ) defer seq . Unlock ( ) if seq . next > = seq . leased { if err : = seq . update Lease ( ) ; err ! = nil { return 0 , err } } val : = seq . next seq . next + + return val , nil } 
func ( seq * Sequence ) Release ( ) error { seq . Lock ( ) defer seq . Unlock ( ) err : = seq . db . Update ( func ( txn * Txn ) error { var buf [ 8 ] byte binary . Big Endian . Put Uint 6 4 ( buf [ : ] , seq . next ) return txn . Set ( seq . key , buf [ : ] ) } ) if err ! = nil { return err } seq . leased = seq . next return nil } 
func ( db * DB ) Get Sequence ( key [ ] byte , bandwidth uint 6 4 ) ( * Sequence , error ) { if db . opt . managed Txns { panic ( " " ) } switch { case len ( key ) = = 0 : return nil , Err Empty Key case bandwidth = = 0 : return nil , Err Zero Bandwidth } seq : = & Sequence { db : db , key : key , next : 0 , leased : 0 , bandwidth : bandwidth , } err : = seq . update Lease ( ) return seq , err } 
func ( db * DB ) Key Splits ( prefix [ ] byte ) [ ] string { var splits [ ] string for _ , ti : = range db . Tables ( ) { } } sort . Strings ( splits ) return splits } 
func ( db * DB ) Flatten ( workers int ) error { db . stop Compactions ( ) defer db . start Compactions ( ) compact Away : = func ( cp compaction Priority ) error { db . opt . Infof ( " \n " , cp ) err Ch : = make ( chan error , 1 ) for i : = 0 ; i < workers ; i + + { go func ( ) { err Ch < - db . lc . do Compact ( cp ) } ( ) } var success int var rerr error for i : = 0 ; i < workers ; i + + { err : = < - err Ch if err ! = nil { rerr = err db . opt . Warningf ( " \n " , cp , err ) } else { success + + } } if success = = 0 { return rerr } return nil } hbytes : = func ( sz int 6 4 ) string { return humanize . Bytes ( uint 6 4 ( sz ) ) } for { db . opt . Infof ( " \n " ) var levels [ ] int for i , l : = range db . lc . levels { sz : = l . get Total Size ( ) db . opt . Infof ( " \n " , i , hbytes ( l . get Total Size ( ) ) , hbytes ( l . max Total Size ) ) if sz > 0 { levels = append ( levels , i ) } } if len ( levels ) < = 1 { prios : = db . lc . pick Compact Levels ( ) if len ( prios ) = = 0 | | prios [ 0 ] . score < = 1 . 0 { db . opt . Infof ( " \n " ) return nil } if err : = compact Away ( prios [ 0 ] ) ; err ! = nil { return err } continue } if err : = compact Away ( cp ) ; err ! = nil { return err } } } 
func ( db * DB ) Drop All ( ) error { db . opt . Infof ( " " ) f : = db . prepare To Drop ( ) defer f ( ) defer db . Unlock ( ) for _ , mt : = range db . imm { mt . Decr Ref ( ) } db . imm = db . imm [ : 0 ] db . mt = skl . New Skiplist ( arena Size ( db . opt ) ) num , err : = db . lc . drop Tree ( ) if err ! = nil { return err } db . opt . Infof ( " \n " , num ) num , err = db . vlog . drop All ( ) if err ! = nil { return err } db . vhead = value Pointer { } db . opt . Infof ( " \n " , num ) return nil } 
func ( db * DB ) Drop Prefix ( prefix [ ] byte ) error { db . opt . Infof ( " " , hex . Dump ( prefix ) ) f : = db . prepare To Drop ( ) defer f ( ) defer db . Unlock ( ) db . imm = append ( db . imm , db . mt ) for _ , memtable : = range db . imm { if memtable . Empty ( ) { memtable . Decr Ref ( ) continue } task : = flush Task { mt : memtable , db . opt . Debugf ( " " ) if err : = db . handle Flush Task ( task ) ; err ! = nil { db . opt . Errorf ( " " , err ) return err } memtable . Decr Ref ( ) } db . imm = db . imm [ : 0 ] db . mt = skl . New Skiplist ( arena Size ( db . opt ) ) } db . opt . Infof ( " " ) return nil } 
func Mmap ( fd * os . File , writable bool , size int 6 4 ) ( [ ] byte , error ) { mtype : = unix . PROT _READ if writable { mtype | = unix . PROT _WRITE } return unix . Mmap ( int ( fd . Fd ( ) ) , 0 , int ( size ) , mtype , unix . MAP _SHARED ) } 
func Madvise ( b [ ] byte , readahead bool ) error { flags : = unix . MADV _NORMAL if ! readahead { flags = unix . MADV _RANDOM } return madvise ( b , flags ) } 
func ( o * oracle ) set Discard Ts ( ts uint 6 4 ) { o . Lock ( ) defer o . Unlock ( ) o . discard Ts = ts } 
func ( o * oracle ) has Conflict ( txn * Txn ) bool { if len ( txn . reads ) = = 0 { return false } for _ , ro : = range txn . reads { } } return false } 
func ( txn * Txn ) Set ( key , val [ ] byte ) error { e : = & Entry { Key : key , Value : val , } return txn . Set Entry ( e ) } 
func ( txn * Txn ) Set With Meta ( key , val [ ] byte , meta byte ) error { e : = & Entry { Key : key , Value : val , User Meta : meta } return txn . Set Entry ( e ) } 
func ( txn * Txn ) Delete ( key [ ] byte ) error { e : = & Entry { Key : key , meta : bit Delete , } return txn . modify ( e ) } 
func ( txn * Txn ) Get ( key [ ] byte ) ( item * Item , rerr error ) { if len ( key ) = = 0 { return nil , Err Empty Key } else if txn . discarded { return nil , Err Discarded Txn } item = new ( Item ) if txn . update { if e , has : = txn . pending Writes [ string ( key ) ] ; has & & bytes . Equal ( key , e . Key ) { if is Deleted Or Expired ( e . meta , e . Expires At ) { return nil , Err Key Not Found } item . val = e . Value item . user Meta = e . User Meta item . key = key item . status = prefetched item . version = txn . read Ts item . expires At = e . Expires At } } seek : = y . Key With Ts ( key , txn . read Ts ) vs , err : = txn . db . get ( seek ) if err ! = nil { return nil , errors . Wrapf ( err , " " , key ) } if vs . Value = = nil & & vs . Meta = = 0 { return nil , Err Key Not Found } if is Deleted Or Expired ( vs . Meta , vs . Expires At ) { return nil , Err Key Not Found } item . key = key item . version = vs . Version item . meta = vs . Meta item . user Meta = vs . User Meta item . db = txn . db item . vptr = vs . Value item . txn = txn item . expires At = vs . Expires At return item , nil } 
func ( txn * Txn ) Discard ( ) { if txn . discarded { } if atomic . Load Int 3 2 ( & txn . num Iterators ) > 0 { panic ( " " ) } txn . discarded = true if ! txn . db . orc . is Managed { txn . db . orc . read Mark . Done ( txn . read Ts ) } if txn . update { txn . db . orc . decr Ref ( ) } } 
func ( txn * Txn ) Commit ( ) error { txn . commit Precheck ( ) defer txn . Discard ( ) if len ( txn . writes ) = = 0 { return nil } txn Cb , err : = txn . commit And Send ( ) if err ! = nil { return err } } 
func ( txn * Txn ) Commit With ( cb func ( error ) ) { txn . commit Precheck ( ) defer txn . Discard ( ) if cb = = nil { panic ( " " ) } if len ( txn . writes ) = = 0 { return } commit Cb , err : = txn . commit And Send ( ) if err ! = nil { go run Txn Callback ( & txn Cb { user : cb , err : err } ) return } go run Txn Callback ( & txn Cb { user : cb , commit : commit Cb } ) } 
func ( db * DB ) New Transaction ( update bool ) * Txn { return db . new Transaction ( update , false ) } 
func ( db * DB ) View ( fn func ( txn * Txn ) error ) error { var txn * Txn if db . opt . managed Txns { txn = db . New Transaction At ( math . Max Uint 6 4 , false ) } else { txn = db . New Transaction ( false ) } defer txn . Discard ( ) return fn ( txn ) } 
func ( db * DB ) Update ( fn func ( txn * Txn ) error ) error { if db . opt . managed Txns { panic ( " " ) } txn : = db . New Transaction ( true ) defer txn . Discard ( ) if err : = fn ( txn ) ; err ! = nil { return err } return txn . Commit ( ) } 
func ( itr * block Iterator ) Seek ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . Reset ( ) case current : } var done bool for itr . Init ( ) ; itr . Valid ( ) ; itr . Next ( ) { k : = itr . Key ( ) if y . Compare Keys ( k , key ) > = 0 { break } } if ! done { itr . err = io . EOF } } 
func ( itr * block Iterator ) Seek To Last ( ) { itr . err = nil for itr . Init ( ) ; itr . Valid ( ) ; itr . Next ( ) { } itr . Prev ( ) } 
func ( itr * block Iterator ) parse KV ( h header ) { if cap ( itr . key ) < int ( h . plen + h . klen ) { sz : = int ( h . plen ) + int ( h . klen ) itr . key = make ( [ ] byte , 2 * sz ) } itr . key = itr . key [ : h . plen + h . klen ] copy ( itr . key , itr . base Key [ : h . plen ] ) copy ( itr . key [ h . plen : ] , itr . data [ itr . pos : itr . pos + uint 3 2 ( h . klen ) ] ) itr . pos + = uint 3 2 ( h . klen ) if itr . pos + uint 3 2 ( h . vlen ) > uint 3 2 ( len ( itr . data ) ) { itr . err = errors . Errorf ( " " , itr . pos , h . klen , h . vlen , len ( itr . data ) , h ) return } itr . val = y . Safe Copy ( itr . val , itr . data [ itr . pos : itr . pos + uint 3 2 ( h . vlen ) ] ) itr . pos + = uint 3 2 ( h . vlen ) } 
func ( t * Table ) New Iterator ( reversed bool ) * Iterator { t . Incr Ref ( ) ti : = & Iterator { t : t , reversed : reversed } ti . next ( ) return ti } 
func ( itr * Iterator ) seek From ( key [ ] byte , whence int ) { itr . err = nil switch whence { case origin : itr . reset ( ) case current : } idx : = sort . Search ( len ( itr . t . block Index ) , func ( idx int ) bool { ko : = itr . t . block Index [ idx ] return y . Compare Keys ( ko . key , key ) > 0 } ) if idx = = 0 { return } if itr . err = = io . EOF { } } 
func ( itr * Iterator ) seek For Prev ( key [ ] byte ) { if ! bytes . Equal ( itr . Key ( ) , key ) { itr . prev ( ) } } 
func ( itr * Iterator ) Value ( ) ( ret y . Value Struct ) { ret . Decode ( itr . bi . Value ( ) ) return } 
func ( itr * Iterator ) Seek ( key [ ] byte ) { if ! itr . reversed { itr . seek ( key ) } else { itr . seek For Prev ( key ) } } 
func New Concat Iterator ( tbls [ ] * Table , reversed bool ) * Concat Iterator { iters : = make ( [ ] * Iterator , len ( tbls ) ) for i : = 0 ; i < len ( tbls ) ; i + + { iters [ i ] = tbls [ i ] . New Iterator ( reversed ) } return & Concat Iterator { reversed : reversed , iters : iters , tables : tbls , idx : - 1 , } 
func ( s * Concat Iterator ) Rewind ( ) { if len ( s . iters ) = = 0 { return } if ! s . reversed { s . set Idx ( 0 ) } else { s . set Idx ( len ( s . iters ) - 1 ) } s . cur . Rewind ( ) } 
func ( s * Concat Iterator ) Valid ( ) bool { return s . cur ! = nil & & s . cur . Valid ( ) } 
func ( s * Concat Iterator ) Seek ( key [ ] byte ) { var idx int if ! s . reversed { idx = sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . Compare Keys ( s . tables [ i ] . Biggest ( ) , key ) > = 0 } ) } else { n : = len ( s . tables ) idx = n - 1 - sort . Search ( n , func ( i int ) bool { return y . Compare Keys ( s . tables [ n - 1 - i ] . Smallest ( ) , key ) < = 0 } ) } if idx > = len ( s . tables ) | | idx < 0 { s . set Idx ( - 1 ) return } s . cur . Seek ( key ) } 
func ( s * Concat Iterator ) Next ( ) { s . cur . Next ( ) if s . cur . Valid ( ) { } for { } else { s . set Idx ( s . idx - 1 ) } if s . cur = = nil { } s . cur . Rewind ( ) if s . cur . Valid ( ) { break } } } 
func ( s * Concat Iterator ) Close ( ) error { for _ , it : = range s . iters { if err : = it . Close ( ) ; err ! = nil { return errors . Wrap ( err , " " ) } } return nil } 
func Open Existing File ( filename string , flags uint 3 2 ) ( * os . File , error ) { open Flags : = os . O _RDWR if flags & Read Only ! = 0 { open Flags = os . O _RDONLY } if flags & Sync ! = 0 { open Flags | = datasync File Flag } return os . Open File ( filename , open Flags , 0 ) } 
func Create Synced File ( filename string , sync bool ) ( * os . File , error ) { flags : = os . O _RDWR | os . O _CREATE | os . O _EXCL if sync { flags | = datasync File Flag } return os . Open File ( filename , flags , 0 6 6 6 ) } 
func Copy ( a [ ] byte ) [ ] byte { b : = make ( [ ] byte , len ( a ) ) copy ( b , a ) return b } 
func Key With Ts ( key [ ] byte , ts uint 6 4 ) [ ] byte { out : = make ( [ ] byte , len ( key ) + 8 ) copy ( out , key ) binary . Big Endian . Put Uint 6 4 ( out [ len ( key ) : ] , math . Max Uint 6 4 - ts ) return out } 
func Parse Ts ( key [ ] byte ) uint 6 4 { if len ( key ) < = 8 { return 0 } return math . Max Uint 6 4 - binary . Big Endian . Uint 6 4 ( key [ len ( key ) - 8 : ] ) } 
func Compare Keys ( key 1 , key 2 [ ] byte ) int { Assert True ( len ( key 1 ) > 8 & & len ( key 2 ) > 8 ) if cmp : = bytes . Compare ( key 1 [ : len ( key 1 ) - 8 ] , key 2 [ : len ( key 2 ) - 8 ] ) ; cmp ! = 0 { return cmp } return bytes . Compare ( key 1 [ len ( key 1 ) - 8 : ] , key 2 [ len ( key 2 ) - 8 : ] ) } 
func Parse Key ( key [ ] byte ) [ ] byte { if key = = nil { return nil } Assert True ( len ( key ) > 8 ) return key [ : len ( key ) - 8 ] } 
func Same Key ( src , dst [ ] byte ) bool { if len ( src ) ! = len ( dst ) { return false } return bytes . Equal ( Parse Key ( src ) , Parse Key ( dst ) ) } 
func ( s * Slice ) Resize ( sz int ) [ ] byte { if cap ( s . buf ) < sz { s . buf = make ( [ ] byte , sz ) } return s . buf [ 0 : sz ] } 
func Fixed Duration ( d time . Duration ) string { str : = fmt . Sprintf ( " " , int ( d . Seconds ( ) ) % 6 0 ) if d > = time . Minute { str = fmt . Sprintf ( " " , int ( d . Minutes ( ) ) % 6 0 ) + str } if d > = time . Hour { str = fmt . Sprintf ( " " , int ( d . Hours ( ) ) ) + str } return str } 
func New Closer ( initial int ) * Closer { ret : = & Closer { closed : make ( chan struct { } ) } ret . waiting . Add ( initial ) return ret } 
func New Throttle ( max int ) * Throttle { return & Throttle { ch : make ( chan struct { } , max ) , err Ch : make ( chan error , max ) , } } 
func ( t * Throttle ) Do ( ) error { for { select { case t . ch < - struct { } { } : t . wg . Add ( 1 ) return nil case err : = < - t . err Ch : if err ! = nil { return err } } } } 
func ( t * Throttle ) Done ( err error ) { if err ! = nil { t . err Ch < - err } select { case < - t . ch : default : panic ( " " ) } t . wg . Done ( ) } 
func ( t * Throttle ) Finish ( ) error { t . wg . Wait ( ) close ( t . ch ) close ( t . err Ch ) for err : = range t . err Ch { if err ! = nil { return err } } return nil } 
func Open Managed ( opts Options ) ( * DB , error ) { opts . managed Txns = true return Open ( opts ) } 
func ( db * DB ) New Transaction At ( read Ts uint 6 4 , update bool ) * Txn { if ! db . opt . managed Txns { panic ( " " ) } txn : = db . new Transaction ( update , true ) txn . read Ts = read Ts return txn } 
func ( txn * Txn ) Commit At ( commit Ts uint 6 4 , callback func ( error ) ) error { if ! txn . db . opt . managed Txns { panic ( " " ) } txn . commit Ts = commit Ts if callback = = nil { return txn . Commit ( ) } txn . Commit With ( callback ) return nil } 
func ( db * DB ) Set Discard Ts ( ts uint 6 4 ) { if ! db . opt . managed Txns { panic ( " " ) } db . orc . set Discard Ts ( ts ) } 
func ( lf * log File ) open Read Only ( ) error { var err error lf . fd , err = os . Open File ( lf . path , os . O _RDONLY , 0 6 6 6 ) if err ! = nil { return errors . Wrapf ( err , " " , lf . path ) } fi , err : = lf . fd . Stat ( ) if err ! = nil { return errors . Wrapf ( err , " " , lf . path ) } y . Assert True ( fi . Size ( ) < = math . Max Uint 3 2 ) lf . size = uint 3 2 ( fi . Size ( ) ) if err = lf . mmap ( fi . Size ( ) ) ; err ! = nil { _ = lf . fd . Close ( ) return y . Wrapf ( err , " " ) } return nil } 
func ( lf * log File ) read ( p value Pointer , s * y . Slice ) ( buf [ ] byte , err error ) { var nbr int 6 4 offset : = p . Offset if lf . loading Mode = = options . File IO { buf = s . Resize ( int ( p . Len ) ) var n int n , err = lf . fd . Read At ( buf , int 6 4 ( offset ) ) nbr = int 6 4 ( n ) } else { valsz : = p . Len if int 6 4 ( offset ) > = size | | int 6 4 ( offset + valsz ) > size { err = y . Err EOF } else { buf = lf . fmap [ offset : offset + valsz ] nbr = int 6 4 ( valsz ) } } y . Num Reads . Add ( 1 ) y . Num Bytes Read . Add ( nbr ) return buf , err } 
func ( vlog * value Log ) iterate ( lf * log File , offset uint 3 2 , fn log Entry ) ( uint 3 2 , error ) { fi , err : = lf . fd . Stat ( ) if err ! = nil { return 0 , err } if int 6 4 ( offset ) = = fi . Size ( ) { } if vlog . opt . Read Only { } } reader : = bufio . New Reader ( lf . fd ) read : = & safe Read { k : make ( [ ] byte , 1 0 ) , v : make ( [ ] byte , 1 0 ) , record Offset : offset , } var last Commit uint 6 4 var valid End Offset uint 3 2 for { e , err : = read . Entry ( reader ) if err = = io . EOF { break } else if err = = io . Err Unexpected EOF | | err = = err Truncate { break } else if err ! = nil { return 0 , err } else if e = = nil { continue } var vp value Pointer vp . Len = uint 3 2 ( header Buf Size + len ( e . Key ) + len ( e . Value ) + crc 3 2 . Size ) read . record Offset + = vp . Len vp . Offset = e . offset vp . Fid = lf . fid if e . meta & bit Txn > 0 { txn Ts : = y . Parse Ts ( e . Key ) if last Commit = = 0 { last Commit = txn Ts } if last Commit ! = txn Ts { break } } else if e . meta & bit Fin Txn > 0 { txn Ts , err : = strconv . Parse Uint ( string ( e . Value ) , 1 0 , 6 4 ) if err ! = nil | | last Commit ! = txn Ts { break } valid End Offset = read . record Offset } else { if last Commit ! = 0 { } valid End Offset = read . record Offset } if err : = fn ( * e , vp ) ; err ! = nil { if err = = err Stop { break } return 0 , err File ( err , lf . path , " " ) } } return valid End Offset , nil } 
func ( vlog * value Log ) sorted Fids ( ) [ ] uint 3 2 { to Be Deleted : = make ( map [ uint 3 2 ] struct { } ) for _ , fid : = range vlog . files To Be Deleted { to Be Deleted [ fid ] = struct { } { } } ret : = make ( [ ] uint 3 2 , 0 , len ( vlog . files Map ) ) for fid : = range vlog . files Map { if _ , ok : = to Be Deleted [ fid ] ; ! ok { ret = append ( ret , fid ) } } sort . Slice ( ret , func ( i , j int ) bool { return ret [ i ] < ret [ j ] } ) return ret } 
func ( vlog * value Log ) sync ( fid uint 3 2 ) error { if vlog . opt . Sync Writes { return nil } vlog . files Lock . RLock ( ) max Fid : = atomic . Load Uint 3 2 ( & vlog . max Fid ) return nil } curlf : = vlog . files Map [ max Fid ] return nil } curlf . lock . RLock ( ) vlog . files Lock . RUnlock ( ) err : = curlf . sync ( ) curlf . lock . RUnlock ( ) return err } 
func ( vlog * value Log ) write ( reqs [ ] * request ) error { vlog . files Lock . RLock ( ) max Fid : = atomic . Load Uint 3 2 ( & vlog . max Fid ) curlf : = vlog . files Map [ max Fid ] vlog . files Lock . RUnlock ( ) var buf bytes . Buffer to Disk : = func ( ) error { if buf . Len ( ) = = 0 { return nil } vlog . elog . Printf ( " " , len ( reqs ) , buf . Len ( ) ) n , err : = curlf . fd . Write ( buf . Bytes ( ) ) if err ! = nil { return errors . Wrapf ( err , " " , curlf . path ) } buf . Reset ( ) y . Num Writes . Add ( 1 ) y . Num Bytes Written . Add ( int 6 4 ( n ) ) vlog . elog . Printf ( " " ) atomic . Add Uint 3 2 ( & vlog . writable Log Offset , uint 3 2 ( n ) ) if vlog . woffset ( ) > uint 3 2 ( vlog . opt . Value Log File Size ) | | vlog . num Entries Written > vlog . opt . Value Log Max Entries { var err error if err = curlf . done Writing ( vlog . woffset ( ) ) ; err ! = nil { return err } newid : = atomic . Add Uint 3 2 ( & vlog . max Fid , 1 ) y . Assert Truef ( newid > 0 , " " , newid ) newlf , err : = vlog . create Vlog File ( newid ) if err ! = nil { return err } curlf = newlf } return nil } for i : = range reqs { b : = reqs [ i ] b . Ptrs = b . Ptrs [ : 0 ] for j : = range b . Entries { e : = b . Entries [ j ] var p value Pointer p . Fid = curlf . fid plen , err : = encode Entry ( e , & buf ) if err ! = nil { return err } p . Len = uint 3 2 ( plen ) b . Ptrs = append ( b . Ptrs , p ) } vlog . num Entries Written + = uint 3 2 ( len ( b . Entries ) ) if write Now { if err : = to Disk ( ) ; err ! = nil { return err } } } return to Disk ( ) } 
func ( vlog * value Log ) get File RLocked ( fid uint 3 2 ) ( * log File , error ) { vlog . files Lock . RLock ( ) defer vlog . files Lock . RUnlock ( ) ret , ok : = vlog . files Map [ fid ] if ! ok { } ret . lock . RLock ( ) return ret , nil } 
func ( vlog * value Log ) Read ( vp value Pointer , s * y . Slice ) ( [ ] byte , func ( ) , error ) { if vp . Fid = = max Fid & & vp . Offset > = vlog . woffset ( ) { return nil , nil , errors . Errorf ( " " , vp . Offset , vlog . woffset ( ) ) } buf , cb , err : = vlog . read Value Bytes ( vp , s ) if err ! = nil { return nil , cb , err } var h header h . Decode ( buf ) n : = uint 3 2 ( header Buf Size ) + h . klen return buf [ n : n + h . vlen ] , cb , nil } 
func value Bytes To Entry ( buf [ ] byte ) ( e Entry ) { var h header h . Decode ( buf ) n : = uint 3 2 ( header Buf Size ) e . Key = buf [ n : n + h . klen ] n + = h . klen e . meta = h . meta e . User Meta = h . user Meta e . Value = buf [ n : n + h . vlen ] return } 
func ( vlog * value Log ) encoded Discard Stats ( ) [ ] byte { vlog . lf Discard Stats . Lock ( ) defer vlog . lf Discard Stats . Unlock ( ) encoded Stats , _ : = json . Marshal ( vlog . lf Discard Stats . m ) return encoded Stats } 
func ( vlog * value Log ) populate Discard Stats ( ) error { discard Stats Key : = y . Key With Ts ( lf Discard Stats Key , math . Max Uint 6 4 ) vs , err : = vlog . db . get ( discard Stats Key ) if err ! = nil { return err } return nil } var stats Map map [ uint 3 2 ] int 6 4 if err : = json . Unmarshal ( vs . Value , & stats Map ) ; err ! = nil { return err } vlog . opt . Debugf ( " " , stats Map ) vlog . lf Discard Stats = & lf Discard Stats { m : stats Map } return nil } 
func ( db * DB ) Backup ( w io . Writer , since uint 6 4 ) ( uint 6 4 , error ) { stream : = db . New Stream ( ) stream . Log Prefix = " " return stream . Backup ( w , since ) } 
func ( stream * Stream ) Backup ( w io . Writer , since uint 6 4 ) ( uint 6 4 , error ) { stream . Key To List = func ( key [ ] byte , itr * Iterator ) ( * pb . KVList , error ) { list : = & pb . KVList { } for ; itr . Valid ( ) ; itr . Next ( ) { item : = itr . Item ( ) if ! bytes . Equal ( item . Key ( ) , key ) { return list , nil } if item . Version ( ) < since { } var val Copy [ ] byte if ! item . Is Deleted Or Expired ( ) { val Copy , err = item . Value Copy ( nil ) if err ! = nil { stream . db . opt . Errorf ( " \n " , item . Key ( ) , item . Version ( ) , err ) return nil , err } } kv : = & pb . KV { Key : item . Key Copy ( nil ) , Value : val Copy , User Meta : [ ] byte { item . User Meta ( ) } , Version : item . Version ( ) , Expires At : item . Expires At ( ) , Meta : [ ] byte { meta } , } list . Kv = append ( list . Kv , kv ) switch { case item . Discard Earlier Versions ( ) : return list , nil case item . Is Deleted Or Expired ( ) : return list , nil } } return list , nil } var max Version uint 6 4 stream . Send = func ( list * pb . KVList ) error { for _ , kv : = range list . Kv { if max Version < kv . Version { max Version = kv . Version } if err : = write To ( kv , w ) ; err ! = nil { return err } } return nil } if err : = stream . Orchestrate ( context . Background ( ) ) ; err ! = nil { return 0 , err } return max Version , nil } 
func ( db * DB ) Load ( r io . Reader ) error { br : = bufio . New Reader Size ( r , 1 6 < < 1 0 ) unmarshal Buf : = make ( [ ] byte , 1 < < 1 0 ) var entries [ ] * Entry var wg sync . Wait Group err Chan : = make ( chan error , 1 ) default : wg . Add ( 1 ) return db . batch Set Async ( entries , func ( err error ) { defer wg . Done ( ) if err ! = nil { select { case err Chan < - err : default : } } } ) } } for { var sz uint 6 4 err : = binary . Read ( br , binary . Little Endian , & sz ) if err = = io . EOF { break } else if err ! = nil { return err } if cap ( unmarshal Buf ) < int ( sz ) { unmarshal Buf = make ( [ ] byte , sz ) } e : = & pb . KV { } if _ , err = io . Read Full ( br , unmarshal Buf [ : sz ] ) ; err ! = nil { return err } if err = e . Unmarshal ( unmarshal Buf [ : sz ] ) ; err ! = nil { return err } var user Meta byte if len ( e . User Meta ) > 0 { user Meta = e . User Meta [ 0 ] } entries = append ( entries , & Entry { Key : y . Key With Ts ( e . Key , e . Version ) , Value : e . Value , User Meta : user Meta , Expires At : e . Expires At , meta : e . Meta [ 0 ] , } ) } if len ( entries ) = = 1 0 0 0 { if err : = batch Set Async If No Err ( entries ) ; err ! = nil { return err } entries = make ( [ ] * Entry , 0 , 1 0 0 0 ) } } if len ( entries ) > 0 { if err : = batch Set Async If No Err ( entries ) ; err ! = nil { return err } } wg . Wait ( ) select { case err : = < - err Chan : return err default : return nil } } 
func ( st * Stream ) To List ( key [ ] byte , itr * Iterator ) ( * pb . KVList , error ) { list : = & pb . KVList { } for ; itr . Valid ( ) ; itr . Next ( ) { item : = itr . Item ( ) if item . Is Deleted Or Expired ( ) { break } if ! bytes . Equal ( key , item . Key ( ) ) { } val Copy , err : = item . Value Copy ( nil ) if err ! = nil { return nil , err } kv : = & pb . KV { Key : item . Key Copy ( nil ) , Value : val Copy , User Meta : [ ] byte { item . User Meta ( ) } , Version : item . Version ( ) , Expires At : item . Expires At ( ) , } list . Kv = append ( list . Kv , kv ) if st . db . opt . Num Versions To Keep = = 1 { break } if item . Discard Earlier Versions ( ) { break } } return list , nil } 
func ( st * Stream ) produce Ranges ( ctx context . Context ) { splits : = st . db . Key Splits ( st . Prefix ) start : = y . Safe Copy ( nil , st . Prefix ) for _ , key : = range splits { st . range Ch < - key Range { left : start , right : y . Safe Copy ( nil , [ ] byte ( key ) ) } start = y . Safe Copy ( nil , [ ] byte ( key ) ) } close ( st . range Ch ) } 
func ( st * Stream ) produce KVs ( ctx context . Context ) error { var size int var txn * Txn if st . read Ts > 0 { txn = st . db . New Transaction At ( st . read Ts , false ) } else { txn = st . db . New Transaction ( false ) } defer txn . Discard ( ) iterate : = func ( kr key Range ) error { iter Opts : = Default Iterator Options iter Opts . All Versions = true iter Opts . Prefix = st . Prefix iter Opts . Prefetch Values = false itr : = txn . New Iterator ( iter Opts ) defer itr . Close ( ) out List : = new ( pb . KVList ) var prev Key [ ] byte for itr . Seek ( kr . left ) ; itr . Valid ( ) ; { if bytes . Equal ( item . Key ( ) , prev Key ) { itr . Next ( ) continue } prev Key = append ( prev Key [ : 0 ] , item . Key ( ) . . . ) } } if err ! = nil { return err } if list = = nil | | len ( list . Kv ) = = 0 { continue } out List . Kv = append ( out List . Kv , list . Kv . . . ) size + = list . Size ( ) if size > = page Size { st . kv Chan < - out List out List = new ( pb . KVList ) size = 0 } } if len ( out List . Kv ) > 0 { st . kv Chan < - out List } return nil } for { select { case kr , ok : = < - st . range Ch : if ! ok { } if err : = iterate ( kr ) ; err ! = nil { return err } case < - ctx . Done ( ) : return ctx . Err ( ) } } } 
func ( st * Stream ) Orchestrate ( ctx context . Context ) error { st . range Ch = make ( chan key Range , 3 ) if st . Key To List = = nil { st . Key To List = st . To List } err Ch : = make ( chan error , 1 ) var wg sync . Wait Group for i : = 0 ; i < st . Num Go ; i + + { wg . Add ( 1 ) go func ( ) { defer wg . Done ( ) } } ( ) } go func ( ) { } ( ) wg . Wait ( ) close ( st . kv Chan ) select { case err : = < - err Ch : default : } return err } 
func ( db * DB ) New Stream ( ) * Stream { if db . opt . managed Txns { panic ( " " ) } return db . new Stream ( ) } 
func ( db * DB ) New Stream At ( read Ts uint 6 4 ) * Stream { if ! db . opt . managed Txns { panic ( " " ) } stream : = db . new Stream ( ) stream . read Ts = read Ts return stream } 
func ( t * Table ) Decr Ref ( ) error { new Ref : = atomic . Add Int 3 2 ( & t . ref , - 1 ) if new Ref = = 0 { } if err : = t . fd . Truncate ( 0 ) ; err ! = nil { } filename : = t . fd . Name ( ) if err : = t . fd . Close ( ) ; err ! = nil { return err } if err : = os . Remove ( filename ) ; err ! = nil { return err } } return nil } 
func Open Table ( fd * os . File , mode options . File Loading Mode , cksum [ ] byte ) ( * Table , error ) { file Info , err : = fd . Stat ( ) if err ! = nil { return nil , y . Wrap ( err ) } filename : = file Info . Name ( ) id , ok : = Parse File ID ( filename ) if ! ok { _ = fd . Close ( ) return nil , errors . Errorf ( " " , filename ) } t : = & Table { fd : fd , ref : 1 , t . table Size = int ( file Info . Size ( ) ) } } if err : = t . read Index ( ) ; err ! = nil { return nil , y . Wrap ( err ) } it : = t . New Iterator ( false ) defer it . Close ( ) it . Rewind ( ) if it . Valid ( ) { t . smallest = it . Key ( ) } it 2 : = t . New Iterator ( true ) defer it 2 . Close ( ) it 2 . Rewind ( ) if it 2 . Valid ( ) { t . biggest = it 2 . Key ( ) } switch mode { case options . Load To RAM : if err ! = nil { _ = fd . Close ( ) return nil , y . Wrapf ( err , " " ) } case options . File IO : t . mmap = nil default : panic ( fmt . Sprintf ( " " , mode ) ) } return t , nil } 
func ( t * Table ) Close ( ) error { if t . loading Mode = = options . Memory Map { y . Munmap ( t . mmap ) } return t . fd . Close ( ) } 
func Parse File ID ( name string ) ( uint 6 4 , bool ) { name = path . Base ( name ) if ! strings . Has Suffix ( name , file Suffix ) { return 0 , false } id , err : = strconv . Atoi ( name ) if err ! = nil { return 0 , false } y . Assert True ( id > = 0 ) return uint 6 4 ( id ) , true } 
func New Filename ( id uint 6 4 , dir string ) string { return filepath . Join ( dir , IDTo Filename ( id ) ) } 
func ( db * DB ) Print Histogram ( key Prefix [ ] byte ) { if db = = nil { fmt . Println ( " \n " ) return } histogram : = db . build Histogram ( key Prefix ) fmt . Printf ( " \n " ) histogram . key Size Histogram . print Histogram ( ) fmt . Printf ( " \n " ) histogram . value Size Histogram . print Histogram ( ) } 
func new Size Histogram ( ) * size Histogram { value Bins : = create Histogram Bins ( 1 , 3 0 ) return & size Histogram { key Size Histogram : histogram Data { bins : key Bins , count Per Bin : make ( [ ] int 6 4 , len ( key Bins ) + 1 ) , max : math . Min Int 6 4 , min : math . Max Int 6 4 , sum : 0 , } , value Size Histogram : histogram Data { bins : value Bins , count Per Bin : make ( [ ] int 6 4 , len ( value Bins ) + 1 ) , max : math . Min Int 6 4 , min : math . Max Int 6 4 , sum : 0 , } , } } 
func create Histogram Bins ( min Exponent , max Exponent uint 3 2 ) [ ] int 6 4 { var bins [ ] int 6 4 for i : = min Exponent ; i < = max Exponent ; i + + { bins = append ( bins , int 6 4 ( 1 ) < < i ) } return bins } 
func ( histogram * histogram Data ) Update ( value int 6 4 ) { if value > histogram . max { histogram . max = value } if value < histogram . min { histogram . min = value } histogram . sum + = value histogram . total Count + + for index : = 0 ; index < = len ( histogram . bins ) ; index + + { break } break } } } 
func ( db * DB ) build Histogram ( key Prefix [ ] byte ) * size Histogram { txn : = db . New Transaction ( false ) defer txn . Discard ( ) itr : = txn . New Iterator ( Default Iterator Options ) defer itr . Close ( ) badger Histogram : = new Size Histogram ( ) badger Histogram . key Size Histogram . Update ( item . Key Size ( ) ) badger Histogram . value Size Histogram . Update ( item . Value Size ( ) ) } return badger Histogram } 
func ( histogram histogram Data ) print Histogram ( ) { fmt . Printf ( " \n " , histogram . total Count ) fmt . Printf ( " \n " , histogram . min ) fmt . Printf ( " \n " , histogram . max ) fmt . Printf ( " \n " , float 6 4 ( histogram . sum ) / float 6 4 ( histogram . total Count ) ) fmt . Printf ( " \n " , " " , " " ) num Bins : = len ( histogram . bins ) for index , count : = range histogram . count Per Bin { if count = = 0 { continue } fmt . Printf ( " \n " , lower Bound , " " , count ) continue } upper Bound : = int ( histogram . bins [ index ] ) lower Bound : = 0 if index > 0 { lower Bound = int ( histogram . bins [ index - 1 ] ) } fmt . Printf ( " \n " , lower Bound , upper Bound , count ) } fmt . Println ( ) } 
func ( w * Water Mark ) Init ( closer * Closer ) { w . mark Ch = make ( chan mark , 1 0 0 ) w . elog = trace . New Event Log ( " " , w . Name ) go w . process ( closer ) } 
func ( w * Water Mark ) Begin ( index uint 6 4 ) { atomic . Store Uint 6 4 ( & w . last Index , index ) w . mark Ch < - mark { index : index , done : false } } 
func ( w * Water Mark ) Begin Many ( indices [ ] uint 6 4 ) { atomic . Store Uint 6 4 ( & w . last Index , indices [ len ( indices ) - 1 ] ) w . mark Ch < - mark { index : 0 , indices : indices , done : false } } 
func ( w * Water Mark ) Done ( index uint 6 4 ) { w . mark Ch < - mark { index : index , done : true } } 
func ( w * Water Mark ) Done Many ( indices [ ] uint 6 4 ) { w . mark Ch < - mark { index : 0 , indices : indices , done : true } } 
func ( w * Water Mark ) Set Done Until ( val uint 6 4 ) { atomic . Store Uint 6 4 ( & w . done Until , val ) } 
func ( w * Water Mark ) Wait For Mark ( ctx context . Context , index uint 6 4 ) error { if w . Done Until ( ) > = index { return nil } wait Ch : = make ( chan struct { } ) w . mark Ch < - mark { index : index , waiter : wait Ch } select { case < - ctx . Done ( ) : return ctx . Err ( ) case < - wait Ch : return nil } } 
func ( w * Water Mark ) process ( closer * Closer ) { defer closer . Done ( ) var indices uint 6 4Heap waiters : = make ( map [ uint 6 4 ] [ ] chan struct { } ) heap . Init ( & indices ) var loop uint 6 4 process One : = func ( index uint 6 4 , done bool ) { if ! present { heap . Push ( & indices , index ) } delta : = 1 if done { delta = - 1 } pending [ index ] = prev + delta loop + + if len ( indices ) > 0 & & loop % 1 0 0 0 0 = = 0 { min : = indices [ 0 ] w . elog . Printf ( " \n " , w . Name , index , len ( indices ) , w . Done Until ( ) , min , pending [ min ] ) } if done Until > index { Assert Truef ( false , " " , w . Name , done Until , index ) } until : = done Until loops : = 0 for len ( indices ) > 0 { min : = indices [ 0 ] if done : = pending [ min ] ; done > 0 { break } delete ( pending , min ) until = min loops + + } for i : = done Until + 1 ; i < = until ; i + + { to Notify : = waiters [ i ] for _ , ch : = range to Notify { close ( ch ) } delete ( waiters , i ) } if until ! = done Until { Assert True ( atomic . Compare And Swap Uint 6 4 ( & w . done Until , done Until , until ) ) w . elog . Printf ( " \n " , w . Name , until , loops ) } } for { select { case < - closer . Has Been Closed ( ) : return case mark : = < - w . mark Ch : if mark . waiter ! = nil { done Until : = atomic . Load Uint 6 4 ( & w . done Until ) if done Until > = mark . index { close ( mark . waiter ) } else { ws , ok : = waiters [ mark . index ] if ! ok { waiters [ mark . index ] = [ ] chan struct { } { mark . waiter } } else { waiters [ mark . index ] = append ( ws , mark . waiter ) } } } else { if mark . index > 0 { process One ( mark . index , mark . done ) } for _ , index : = range mark . indices { process One ( index , mark . done ) } } } } } 
func ( h header ) Encode ( b [ ] byte ) { binary . Big Endian . Put Uint 1 6 ( b [ 0 : 2 ] , h . plen ) binary . Big Endian . Put Uint 1 6 ( b [ 2 : 4 ] , h . klen ) binary . Big Endian . Put Uint 1 6 ( b [ 4 : 6 ] , h . vlen ) binary . Big Endian . Put Uint 3 2 ( b [ 6 : 1 0 ] , h . prev ) } 
func ( h * header ) Decode ( buf [ ] byte ) int { h . plen = binary . Big Endian . Uint 1 6 ( buf [ 0 : 2 ] ) h . klen = binary . Big Endian . Uint 1 6 ( buf [ 2 : 4 ] ) h . vlen = binary . Big Endian . Uint 1 6 ( buf [ 4 : 6 ] ) h . prev = binary . Big Endian . Uint 3 2 ( buf [ 6 : 1 0 ] ) return h . Size ( ) } 
func New Table Builder ( ) * Builder { return & Builder { key Buf : new Buffer ( 1 < < 2 0 ) , buf : new Buffer ( 1 < < 2 0 ) , prev Offset : math . Max Uint 3 2 , } 
func ( b Builder ) key Diff ( new Key [ ] byte ) [ ] byte { var i int for i = 0 ; i < len ( new Key ) & & i < len ( b . base Key ) ; i + + { if new Key [ i ] ! = b . base Key [ i ] { break } } return new Key [ i : ] } 
func ( b * Builder ) Add ( key [ ] byte , value y . Value Struct ) error { if b . counter > = restart Interval { b . finish Block ( ) b . counter = 0 b . base Key = [ ] byte { } b . base Offset = uint 3 2 ( b . buf . Len ( ) ) b . prev Offset = math . Max Uint 3 2 } b . add Helper ( key , value ) return nil } 
func ( b * Builder ) Reached Capacity ( cap int 6 4 ) bool { estimate Sz : = b . buf . Len ( ) + 8 + 4 * len ( b . restarts ) + 8 return int 6 4 ( estimate Sz ) > cap } 
func ( b * Builder ) block Index ( ) [ ] byte { out : = make ( [ ] byte , sz ) buf : = out for _ , r : = range b . restarts { binary . Big Endian . Put Uint 3 2 ( buf [ : 4 ] , r ) buf = buf [ 4 : ] } binary . Big Endian . Put Uint 3 2 ( buf [ : 4 ] , uint 3 2 ( len ( b . restarts ) ) ) return out } 
func ( b * Builder ) Finish ( ) [ ] byte { bf : = bbloom . New ( float 6 4 ( b . key Count ) , 0 . 0 1 ) var klen [ 2 ] byte key : = make ( [ ] byte , 1 0 2 4 ) for { if _ , err : = b . key Buf . Read ( klen [ : ] ) ; err = = io . EOF { break } else if err ! = nil { y . Check ( err ) } kl : = int ( binary . Big Endian . Uint 1 6 ( klen [ : ] ) ) if cap ( key ) < kl { key = make ( [ ] byte , 2 * int ( kl ) ) } key = key [ : kl ] y . Check 2 ( b . key Buf . Read ( key ) ) bf . Add ( key ) } b . finish Block ( ) index : = b . block Index ( ) b . buf . Write ( index ) n , err : = b . buf . Write ( bdata ) y . Check ( err ) var buf [ 4 ] byte binary . Big Endian . Put Uint 3 2 ( buf [ : ] , uint 3 2 ( n ) ) b . buf . Write ( buf [ : ] ) return b . buf . Bytes ( ) } 
func ( opt * Options ) Errorf ( format string , v . . . interface { } ) { if opt . Logger = = nil { return } opt . Logger . Errorf ( format , v . . . ) } 
func ( opt * Options ) Infof ( format string , v . . . interface { } ) { if opt . Logger = = nil { return } opt . Logger . Infof ( format , v . . . ) } 
func ( opt * Options ) Warningf ( format string , v . . . interface { } ) { if opt . Logger = = nil { return } opt . Logger . Warningf ( format , v . . . ) } 
func ( opt * Options ) Debugf ( format string , v . . . interface { } ) { if opt . Logger = = nil { return } opt . Logger . Debugf ( format , v . . . ) } 
func ( s * Skiplist ) Decr Ref ( ) { new Ref : = atomic . Add Int 3 2 ( & s . ref , - 1 ) if new Ref > 0 { return } s . arena . reset ( ) } 
func New Skiplist ( arena Size int 6 4 ) * Skiplist { arena : = new Arena ( arena Size ) head : = new Node ( arena , nil , y . Value Struct { } , max Height ) return & Skiplist { height : 1 , head : head , arena : arena , ref : 1 , } } 
func random Height ( ) int { h : = 1 for h < max Height & & rand . Uint 3 2 ( ) < = height Increase { h + + } return h } 
func ( s * Skiplist ) find Near ( key [ ] byte , less bool , allow Equal bool ) ( * node , bool ) { x : = s . head level : = int ( s . get Height ( ) - 1 ) for { if next = = nil { continue } } } return x , false } next Key : = next . key ( s . arena ) cmp : = y . Compare Keys ( key , next Key ) if cmp > 0 { continue } if cmp = = 0 { } if ! less { } continue } } return x , false } continue } } } return x , false } } 
func ( s * Skiplist ) find Splice For Level ( key [ ] byte , before * node , level int ) ( * node , * node ) { for { if next = = nil { return before , next } next Key : = next . key ( s . arena ) cmp : = y . Compare Keys ( key , next Key ) if cmp = = 0 { } if cmp < 0 { } before = next } } 
func ( s * Skiplist ) Put ( key [ ] byte , v y . Value Struct ) { var prev [ max Height + 1 ] * node var next [ max Height + 1 ] * node prev [ list Height ] = s . head next [ list Height ] = nil for i : = int ( list Height ) - 1 ; i > = 0 ; i - - { if prev [ i ] = = next [ i ] { prev [ i ] . set Value ( s . arena , v ) return } } x : = new Node ( s . arena , key , v , height ) for height > int ( list Height ) { if atomic . Compare And Swap Int 3 2 ( & s . height , list Height , int 3 2 ( height ) ) { } list Height = s . get Height ( ) } } next Offset : = s . arena . get Node Offset ( next [ i ] ) x . tower [ i ] = next Offset if prev [ i ] . cas Next Offset ( i , next Offset , s . arena . get Node Offset ( x ) ) { } if prev [ i ] = = next [ i ] { y . Assert Truef ( i = = 0 , " " , i ) prev [ i ] . set Value ( s . arena , v ) return } } } } 
func ( s * Skiplist ) find Last ( ) * node { n : = s . head level : = int ( s . get Height ( ) ) - 1 for { next : = s . get Next ( n , level ) if next ! = nil { n = next continue } if level = = 0 { if n = = s . head { return nil } return n } level - - } } 
func ( s * Skiplist ) Get ( key [ ] byte ) y . Value Struct { n , _ : = s . find Near ( key , false , true ) if n = = nil { return y . Value Struct { } } next Key : = s . arena . get Key ( n . key Offset , n . key Size ) if ! y . Same Key ( key , next Key ) { return y . Value Struct { } } val Offset , val Size : = n . get Value Offset ( ) vs : = s . arena . get Val ( val Offset , val Size ) vs . Version = y . Parse Ts ( next Key ) return vs } 
func ( s * Iterator ) Key ( ) [ ] byte { return s . list . arena . get Key ( s . n . key Offset , s . n . key Size ) } 
func ( s * Iterator ) Value ( ) y . Value Struct { val Offset , val Size : = s . n . get Value Offset ( ) return s . list . arena . get Val ( val Offset , val Size ) } 
func ( s * Iterator ) Next ( ) { y . Assert True ( s . Valid ( ) ) s . n = s . list . get Next ( s . n , 0 ) } 
func ( s * Iterator ) Prev ( ) { y . Assert True ( s . Valid ( ) ) s . n , _ = s . list . find Near ( s . Key ( ) , true , false ) } 
func ( s * Iterator ) Seek ( target [ ] byte ) { s . n , _ = s . list . find Near ( target , false , true ) } 
func ( s * Iterator ) Seek For Prev ( target [ ] byte ) { s . n , _ = s . list . find Near ( target , true , true ) } 
func ( s * Iterator ) Seek To First ( ) { s . n = s . list . get Next ( s . list . head , 0 ) } 
func ( s * Skiplist ) New Uni Iterator ( reversed bool ) * Uni Iterator { return & Uni Iterator { iter : s . New Iterator ( ) , reversed : reversed , } } 
func ( s * Uni Iterator ) Next ( ) { if ! s . reversed { s . iter . Next ( ) } else { s . iter . Prev ( ) } } 
func ( s * Uni Iterator ) Rewind ( ) { if ! s . reversed { s . iter . Seek To First ( ) } else { s . iter . Seek To Last ( ) } } 
func ( s * Uni Iterator ) Seek ( key [ ] byte ) { if ! s . reversed { s . iter . Seek ( key ) } else { s . iter . Seek For Prev ( key ) } } 
func ( m * Manifest ) as Changes ( ) [ ] * pb . Manifest Change { changes : = make ( [ ] * pb . Manifest Change , 0 , len ( m . Tables ) ) for id , tm : = range m . Tables { changes = append ( changes , new Create Change ( id , int ( tm . Level ) , tm . Checksum ) ) } return changes } 
func open Or Create Manifest File ( dir string , read Only bool ) ( ret * manifest File , result Manifest , err error ) { return help Open Or Create Manifest File ( dir , read Only , manifest Deletions Rewrite Threshold ) } 
func ( mf * manifest File ) add Changes ( changes Param [ ] * pb . Manifest Change ) error { changes : = pb . Manifest Change Set { Changes : changes Param } buf , err : = changes . Marshal ( ) if err ! = nil { return err } if err : = apply Change Set ( & mf . manifest , & changes ) ; err ! = nil { mf . append Lock . Unlock ( ) return err } return err } } else { var len Crc Buf [ 8 ] byte binary . Big Endian . Put Uint 3 2 ( len Crc Buf [ 0 : 4 ] , uint 3 2 ( len ( buf ) ) ) binary . Big Endian . Put Uint 3 2 ( len Crc Buf [ 4 : 8 ] , crc 3 2 . Checksum ( buf , y . Castagnoli Crc Table ) ) buf = append ( len Crc Buf [ : ] , buf . . . ) if _ , err : = mf . fp . Write ( buf ) ; err ! = nil { mf . append Lock . Unlock ( ) return err } } mf . append Lock . Unlock ( ) return mf . fp . Sync ( ) } 
func ( mf * manifest File ) rewrite ( ) error { } fp , net Creations , err : = help Rewrite ( mf . directory , & mf . manifest ) if err ! = nil { return err } mf . fp = fp mf . manifest . Creations = net Creations mf . manifest . Deletions = 0 return nil } 
func Replay Manifest File ( fp * os . File ) ( ret Manifest , trunc Offset int 6 4 , err error ) { r : = counting Reader { wrapped : bufio . New Reader ( fp ) } var magic Buf [ 8 ] byte if _ , err : = io . Read Full ( & r , magic Buf [ : ] ) ; err ! = nil { return Manifest { } , 0 , err Bad Magic } if ! bytes . Equal ( magic Buf [ 0 : 4 ] , magic Text [ : ] ) { return Manifest { } , 0 , err Bad Magic } version : = binary . Big Endian . Uint 3 2 ( magic Buf [ 4 : 8 ] ) if version ! = magic Version { return Manifest { } , 0 , fmt . Errorf ( " " , version , magic Version ) } build : = create Manifest ( ) var offset int 6 4 for { offset = r . count var len Crc Buf [ 8 ] byte _ , err : = io . Read Full ( & r , len Crc Buf [ : ] ) if err ! = nil { if err = = io . EOF | | err = = io . Err Unexpected EOF { break } return Manifest { } , 0 , err } length : = binary . Big Endian . Uint 3 2 ( len Crc Buf [ 0 : 4 ] ) var buf = make ( [ ] byte , length ) if _ , err : = io . Read Full ( & r , buf ) ; err ! = nil { if err = = io . EOF | | err = = io . Err Unexpected EOF { break } return Manifest { } , 0 , err } if crc 3 2 . Checksum ( buf , y . Castagnoli Crc Table ) ! = binary . Big Endian . Uint 3 2 ( len Crc Buf [ 4 : 8 ] ) { break } var change Set pb . Manifest Change Set if err : = change Set . Unmarshal ( buf ) ; err ! = nil { return Manifest { } , 0 , err } if err : = apply Change Set ( & build , & change Set ) ; err ! = nil { return Manifest { } , 0 , err } } return build , offset , err } 
func apply Change Set ( build * Manifest , change Set * pb . Manifest Change Set ) error { for _ , change : = range change Set . Changes { if err : = apply Manifest Change ( build , change ) ; err ! = nil { return err } } return nil } 
func ( s * level Handler ) validate ( ) error { if s . level = = 0 { return nil } s . RLock ( ) defer s . RUnlock ( ) num Tables : = len ( s . tables ) for j : = 1 ; j < num Tables ; j + + { if j > = len ( s . tables ) { return errors . Errorf ( " " , s . level , j , num Tables ) } if y . Compare Keys ( s . tables [ j - 1 ] . Biggest ( ) , s . tables [ j ] . Smallest ( ) ) > = 0 { return errors . Errorf ( " \n \n \n \n " , hex . Dump ( s . tables [ j - 1 ] . Biggest ( ) ) , hex . Dump ( s . tables [ j ] . Smallest ( ) ) , s . level , j , num Tables ) } if y . Compare Keys ( s . tables [ j ] . Smallest ( ) , s . tables [ j ] . Biggest ( ) ) > 0 { return errors . Errorf ( " " , s . tables [ j ] . Smallest ( ) , s . tables [ j ] . Biggest ( ) , s . level , j , num Tables ) } } return nil } 
func ( s * levels Controller ) reserve File ID ( ) uint 6 4 { id : = atomic . Add Uint 6 4 ( & s . next File ID , 1 ) return id - 1 } 
func acquire Directory Lock ( dir Path string , pid File Name string , read Only bool ) ( * directory Lock Guard , error ) { if read Only { return nil , Err Windows Not Supported } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrapf ( err , " " , abs Lock File Path ) } return & directory Lock Guard { h : h , path : abs Lock File Path } , nil } 
func ( g * directory Lock Guard ) release ( ) error { g . path = " " return syscall . Close Handle ( g . h ) } 
func Assert Truef ( b bool , format string , args . . . interface { } ) { if ! b { log . Fatalf ( " " , errors . Errorf ( format , args . . . ) ) } } 
func Wrapf ( err error , format string , args . . . interface { } ) error { if ! debug Mode { if err = = nil { return nil } return fmt . Errorf ( format + " " , append ( args , err ) . . . ) } return errors . Wrapf ( err , format , args . . . ) } 
func ( s * level Handler ) init Tables ( tables [ ] * table . Table ) { s . Lock ( ) defer s . Unlock ( ) s . tables = tables s . total Size = 0 for _ , t : = range tables { s . total Size + = t . Size ( ) } if s . level = = 0 { } ) } else { } ) } } 
func ( s * level Handler ) delete Tables ( to Del [ ] * table . Table ) error { s . Lock ( ) to Del Map : = make ( map [ uint 6 4 ] struct { } ) for _ , t : = range to Del { to Del Map [ t . ID ( ) ] = struct { } { } } for _ , t : = range s . tables { _ , found : = to Del Map [ t . ID ( ) ] if ! found { new Tables = append ( new Tables , t ) continue } s . total Size - = t . Size ( ) } s . tables = new Tables s . Unlock ( ) return decr Refs ( to Del ) } 
func ( s * level Handler ) replace Tables ( to Del , to Add [ ] * table . Table ) error { to Del Map : = make ( map [ uint 6 4 ] struct { } ) for _ , t : = range to Del { to Del Map [ t . ID ( ) ] = struct { } { } } var new Tables [ ] * table . Table for _ , t : = range s . tables { _ , found : = to Del Map [ t . ID ( ) ] if ! found { new Tables = append ( new Tables , t ) continue } s . total Size - = t . Size ( ) } t . Incr Ref ( ) new Tables = append ( new Tables , t ) } sort . Slice ( s . tables , func ( i , j int ) bool { return y . Compare Keys ( s . tables [ i ] . Smallest ( ) , s . tables [ j ] . Smallest ( ) ) < 0 } ) s . Unlock ( ) return decr Refs ( to Del ) } 
func ( s * level Handler ) try Add Level 0Table ( t * table . Table ) bool { y . Assert True ( s . level = = 0 ) defer s . Unlock ( ) if len ( s . tables ) > = s . db . opt . Num Level Zero Tables Stall { return false } s . tables = append ( s . tables , t ) t . Incr Ref ( ) s . total Size + = t . Size ( ) return true } 
func ( s * level Handler ) get Table For Key ( key [ ] byte ) ( [ ] * table . Table , func ( ) error ) { s . RLock ( ) defer s . RUnlock ( ) if s . level = = 0 { for i : = len ( s . tables ) - 1 ; i > = 0 ; i - - { out = append ( out , s . tables [ i ] ) s . tables [ i ] . Incr Ref ( ) } return out , func ( ) error { for _ , t : = range out { if err : = t . Decr Ref ( ) ; err ! = nil { return err } } return nil } } } ) if idx > = len ( s . tables ) { } tbl : = s . tables [ idx ] tbl . Incr Ref ( ) return [ ] * table . Table { tbl } , tbl . Decr Ref } 
func ( s * level Handler ) get ( key [ ] byte ) ( y . Value Struct , error ) { tables , decr : = s . get Table For Key ( key ) key No Ts : = y . Parse Key ( key ) var max Vs y . Value Struct for _ , th : = range tables { if th . Does Not Have ( key No Ts ) { y . Num LSMBloom Hits . Add ( s . str Level , 1 ) continue } it : = th . New Iterator ( false ) defer it . Close ( ) y . Num LSMGets . Add ( s . str Level , 1 ) it . Seek ( key ) if ! it . Valid ( ) { continue } if y . Same Key ( key , it . Key ( ) ) { if version : = y . Parse Ts ( it . Key ( ) ) ; max Vs . Version < version { max Vs = it . Value ( ) max Vs . Version = version } } } return max Vs , decr ( ) } 
func ( s * level Handler ) append Iterators ( iters [ ] y . Iterator , opt * Iterator Options ) [ ] y . Iterator { s . RLock ( ) defer s . RUnlock ( ) tables : = make ( [ ] * table . Table , 0 , len ( s . tables ) ) for _ , t : = range s . tables { if opt . pick Table ( t ) { tables = append ( tables , t ) } } if len ( tables ) = = 0 { return iters } if s . level = = 0 { } return append ( iters , table . New Concat Iterator ( tables , opt . Reverse ) ) } 
func ( s * level Handler ) overlapping Tables ( _ level Handler RLocked , kr key Range ) ( int , int ) { if len ( kr . left ) = = 0 | | len ( kr . right ) = = 0 { return 0 , 0 } left : = sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . Compare Keys ( kr . left , s . tables [ i ] . Biggest ( ) ) < = 0 } ) right : = sort . Search ( len ( s . tables ) , func ( i int ) bool { return y . Compare Keys ( kr . right , s . tables [ i ] . Smallest ( ) ) < 0 } ) return left , right } 
func ( item * Item ) String ( ) string { return fmt . Sprintf ( " " , item . Key ( ) , item . Version ( ) , item . meta ) } 
func ( item * Item ) Key Copy ( dst [ ] byte ) [ ] byte { return y . Safe Copy ( dst , item . key ) } 
func ( item * Item ) Value ( fn func ( val [ ] byte ) error ) error { item . wg . Wait ( ) if item . status = = prefetched { if item . err = = nil & & fn ! = nil { if err : = fn ( item . val ) ; err ! = nil { return err } } return item . err } buf , cb , err : = item . yield Item Value ( ) defer run Callback ( cb ) if err ! = nil { return err } if fn ! = nil { return fn ( buf ) } return nil } 
func ( item * Item ) Value Copy ( dst [ ] byte ) ( [ ] byte , error ) { item . wg . Wait ( ) if item . status = = prefetched { return y . Safe Copy ( dst , item . val ) , item . err } buf , cb , err : = item . yield Item Value ( ) defer run Callback ( cb ) return y . Safe Copy ( dst , buf ) , err } 
func ( item * Item ) Estimated Size ( ) int 6 4 { if ! item . has Value ( ) { return 0 } if ( item . meta & bit Value Pointer ) = = 0 { return int 6 4 ( len ( item . key ) + len ( item . vptr ) ) } var vp value Pointer vp . Decode ( item . vptr ) return int 6 4 ( vp . Len ) } 
func ( item * Item ) Value Size ( ) int 6 4 { if ! item . has Value ( ) { return 0 } if ( item . meta & bit Value Pointer ) = = 0 { return int 6 4 ( len ( item . vptr ) ) } var vp value Pointer vp . Decode ( item . vptr ) klen : = int 6 4 ( len ( item . key ) + 8 ) return int 6 4 ( vp . Len ) - klen - header Buf Size - crc 3 2 . Size } 
func ( txn * Txn ) New Iterator ( opt Iterator Options ) * Iterator { if txn . discarded { panic ( " " ) } panic ( " " ) } defer decr ( ) txn . db . vlog . incr Iterator Count ( ) var iters [ ] y . Iterator if itr : = txn . new Pending Writes Iterator ( opt . Reverse ) ; itr ! = nil { iters = append ( iters , itr ) } for i : = 0 ; i < len ( tables ) ; i + + { iters = append ( iters , tables [ i ] . New Uni Iterator ( opt . Reverse ) ) } iters = txn . db . lc . append Iterators ( iters , & opt ) res : = & Iterator { txn : txn , iitr : y . New Merge Iterator ( iters , opt . Reverse ) , opt : opt , read Ts : txn . read Ts , } return res } 
func ( txn * Txn ) New Key Iterator ( key [ ] byte , opt Iterator Options ) * Iterator { if len ( opt . Prefix ) > 0 { panic ( " " ) } opt . Prefix = key opt . prefix Is Key = true return txn . New Iterator ( opt ) } 
func ( it * Iterator ) Item ( ) * Item { tx : = it . txn tx . add Read Key ( it . item . Key ( ) ) return it . item } 
func ( it * Iterator ) Valid ( ) bool { if it . item = = nil { return false } return bytes . Has Prefix ( it . item . key , it . opt . Prefix ) } 
func ( it * Iterator ) Valid For Prefix ( prefix [ ] byte ) bool { return it . Valid ( ) & & bytes . Has Prefix ( it . item . key , prefix ) } 
func ( it * Iterator ) Close ( ) { if it . closed { return } it . closed = true it . iitr . Close ( ) for item ! = nil { item . wg . Wait ( ) item = l . pop ( ) } } wait For ( it . waste ) wait For ( it . data ) atomic . Add Int 3 2 ( & it . txn . num Iterators , - 1 ) } 
func ( it * Iterator ) Next ( ) { it . waste . push ( it . item ) for it . iitr . Valid ( ) { if it . parse Item ( ) { } } } 
func ( it * Iterator ) parse Item ( ) bool { mi : = it . iitr key : = mi . Key ( ) set Item : = func ( item * Item ) { if it . item = = nil { it . item = item } else { it . data . push ( item ) } } return false } if version > it . read Ts { mi . Next ( ) return false } if it . opt . All Versions { it . fill ( item ) set Item ( item ) mi . Next ( ) return true } return false } } FILL : if is Deleted Or Expired ( vs . Meta , vs . Expires At ) { mi . Next ( ) return false } item : = it . new Item ( ) it . fill ( item ) if ! it . opt . Reverse | | ! mi . Valid ( ) { return true } mik : = y . Parse Key ( mi . Key ( ) ) if next Ts < = it . read Ts & & bytes . Equal ( mik , item . key ) { } return true } 
func ( it * Iterator ) Seek ( key [ ] byte ) { for i : = it . data . pop ( ) ; i ! = nil ; i = it . data . pop ( ) { i . wg . Wait ( ) it . waste . push ( i ) } it . last Key = it . last Key [ : 0 ] if len ( key ) = = 0 { key = it . opt . Prefix } if len ( key ) = = 0 { it . iitr . Rewind ( ) it . prefetch ( ) return } if ! it . opt . Reverse { key = y . Key With Ts ( key , it . txn . read Ts ) } else { key = y . Key With Ts ( key , 0 ) } it . iitr . Seek ( key ) it . prefetch ( ) } 
func ( db * DB ) Get Merge Operator ( key [ ] byte , f Merge Func , dur time . Duration ) * Merge Operator { op : = & Merge Operator { f : f , db : db , key : key , closer : y . New Closer ( 1 ) , } go op . run Compactions ( dur ) return op } 
func ( op * Merge Operator ) Add ( val [ ] byte ) error { return op . db . Update ( func ( txn * Txn ) error { return txn . Set ( op . key , val ) } ) } 
func ( op * Merge Operator ) Get ( ) ( [ ] byte , error ) { op . RLock ( ) defer op . RUnlock ( ) var existing [ ] byte err : = op . db . View ( func ( txn * Txn ) ( err error ) { existing , err = op . iterate And Merge ( txn ) return err } ) if err = = err No Merge { return existing , nil } return existing , err } 
func ( cs * compact Status ) compare And Add ( _ this And Next Level RLocked , cd compact Def ) bool { cs . Lock ( ) defer cs . Unlock ( ) level : = cd . this Level . level y . Assert Truef ( level < len ( cs . levels ) - 1 , " " , level , len ( cs . levels ) ) this Level : = cs . levels [ level ] next Level : = cs . levels [ level + 1 ] if this Level . overlaps With ( cd . this Range ) { return false } if next Level . overlaps With ( cd . next Range ) { return false } next Level . ranges = append ( next Level . ranges , cd . next Range ) this Level . del Size + = cd . this Size return true } 
func new Arena ( n int 6 4 ) * Arena { return out } 
func ( s * Arena ) put Node ( height int ) uint 3 2 { n : = atomic . Add Uint 3 2 ( & s . n , l ) y . Assert Truef ( int ( n ) < = len ( s . buf ) , " " , l , n , len ( s . buf ) ) return m } 
func ( s * Arena ) put Val ( v y . Value Struct ) uint 3 2 { l : = uint 3 2 ( v . Encoded Size ( ) ) n : = atomic . Add Uint 3 2 ( & s . n , l ) y . Assert Truef ( int ( n ) < = len ( s . buf ) , " " , l , n , len ( s . buf ) ) m : = n - l v . Encode ( s . buf [ m : ] ) return m } 
func ( s * Arena ) get Node ( offset uint 3 2 ) * node { if offset = = 0 { return nil } return ( * node ) ( unsafe . Pointer ( & s . buf [ offset ] ) ) } 
func ( s * Arena ) get Key ( offset uint 3 2 , size uint 1 6 ) [ ] byte { return s . buf [ offset : offset + uint 3 2 ( size ) ] } 
func ( s * Arena ) get Val ( offset uint 3 2 , size uint 1 6 ) ( ret y . Value Struct ) { ret . Decode ( s . buf [ offset : offset + uint 3 2 ( size ) ] ) return } 
func ( s * Arena ) get Node Offset ( nd * node ) uint 3 2 { if nd = = nil { return 0 } return uint 3 2 ( uintptr ( unsafe . Pointer ( nd ) ) - uintptr ( unsafe . Pointer ( & s . buf [ 0 ] ) ) ) } 
func init ( ) { Num Reads = expvar . New Int ( " " ) Num Writes = expvar . New Int ( " " ) Num Bytes Read = expvar . New Int ( " " ) Num Bytes Written = expvar . New Int ( " " ) Num LSMGets = expvar . New Map ( " " ) Num LSMBloom Hits = expvar . New Map ( " " ) Num Gets = expvar . New Int ( " " ) Num Puts = expvar . New Int ( " " ) Num Blocked Puts = expvar . New Int ( " " ) Num Memtable Gets = expvar . New Int ( " " ) LSMSize = expvar . New Map ( " " ) Vlog Size = expvar . New Map ( " " ) Pending Writes = expvar . New Map ( " " ) } 
func revert To Manifest ( kv * DB , mf * Manifest , id Map map [ uint 6 4 ] struct { } ) error { } } filename : = table . New Filename ( id , kv . opt . Dir ) if err : = os . Remove ( filename ) ; err ! = nil { return y . Wrapf ( err , " " , id ) } } } return nil } 
func close All Tables ( tables [ ] [ ] * table . Table ) { for _ , table Slice : = range tables { for _ , table : = range table Slice { _ = table . Close ( ) } } } 
func ( s * levels Controller ) drop Tree ( ) ( int , error ) { for _ , l : = range s . levels { l . RLock ( ) all = append ( all , l . tables . . . ) l . RUnlock ( ) } if len ( all ) = = 0 { return 0 , nil } for _ , table : = range all { changes = append ( changes , new Delete Change ( table . ID ( ) ) ) } change Set : = pb . Manifest Change Set { Changes : changes } if err : = s . kv . manifest . add Changes ( change Set . Changes ) ; err ! = nil { return 0 , err } l . total Size = 0 l . tables = l . tables [ : 0 ] l . Unlock ( ) } for _ , table : = range all { if err : = table . Decr Ref ( ) ; err ! = nil { return 0 , err } } return len ( all ) , nil } 
func ( s * levels Controller ) drop Prefix ( prefix [ ] byte ) error { opt : = s . kv . opt for _ , l : = range s . levels { l . RLock ( ) if l . level = = 0 { size : = len ( l . tables ) l . RUnlock ( ) if size > 0 { cp : = compaction Priority { level : 0 , score : 1 . 7 4 , if err : = s . do Compact ( cp ) ; err ! = nil { opt . Warningf ( " " , err ) return nil } } continue } var tables [ ] * table . Table for _ , table : = range l . tables { var absent bool switch { case bytes . Has Prefix ( table . Smallest ( ) , prefix ) : case bytes . Has Prefix ( table . Biggest ( ) , prefix ) : case bytes . Compare ( prefix , table . Smallest ( ) ) > 0 & & bytes . Compare ( prefix , table . Biggest ( ) ) < 0 : default : absent = true } if ! absent { tables = append ( tables , table ) } } l . RUnlock ( ) if len ( tables ) = = 0 { continue } cd : = compact Def { elog : trace . New ( fmt . Sprintf ( " " , l . level ) , " " ) , this Level : l , next Level : l , top : [ ] * table . Table { } , bot : tables , drop Prefix : prefix , } if err : = s . run Compact Def ( l . level , cd ) ; err ! = nil { opt . Warningf ( " " , cd , err ) return err } } return nil } 
func ( s * levels Controller ) is Level 0Compactable ( ) bool { return s . levels [ 0 ] . num Tables ( ) > = s . kv . opt . Num Level Zero Tables } 
func ( l * level Handler ) is Compactable ( del Size int 6 4 ) bool { return l . get Total Size ( ) - del Size > = l . max Total Size } 
func ( s * levels Controller ) pick Compact Levels ( ) ( prios [ ] compaction Priority ) { prios = append ( prios , pri ) } for i , l : = range s . levels [ 1 : ] { if l . is Compactable ( del Size ) { pri : = compaction Priority { level : i + 1 , score : float 6 4 ( l . get Total Size ( ) - del Size ) / float 6 4 ( l . max Total Size ) , } prios = append ( prios , pri ) } } sort . Slice ( prios , func ( i , j int ) bool { return prios [ i ] . score > prios [ j ] . score } ) return prios } 
func ( s * levels Controller ) compact Build Tables ( lev int , cd compact Def ) ( [ ] * table . Table , func ( ) error , error ) { top Tables : = cd . top bot Tables : = cd . bot var has Overlap bool { kr : = get Key Range ( cd . top ) for i , lh : = range s . levels { if i < = lev { } lh . RLock ( ) left , right : = lh . overlapping Tables ( level Handler RLocked { } , kr ) lh . RUnlock ( ) if right - left > 0 { has Overlap = true break } } } update Stats : = func ( vs y . Value Struct ) { if vs . Meta & bit Value Pointer > 0 { var vp value Pointer vp . Decode ( vs . Value ) discard Stats [ vp . Fid ] + = int 6 4 ( vp . Len ) } } if lev = = 0 { iters = append Iterators Reversed ( iters , top Tables , false ) } else if len ( top Tables ) > 0 { y . Assert True ( len ( top Tables ) = = 1 ) iters = [ ] y . Iterator { top Tables [ 0 ] . New Iterator ( false ) } } for _ , table : = range bot Tables { if len ( cd . drop Prefix ) > 0 & & bytes . Has Prefix ( table . Smallest ( ) , cd . drop Prefix ) & & bytes . Has Prefix ( table . Biggest ( ) , cd . drop Prefix ) { } valid = append ( valid , table ) } iters = append ( iters , table . New Concat Iterator ( valid , false ) ) it : = y . New Merge Iterator ( iters , false ) defer it . Close ( ) it . Rewind ( ) err error } result Ch : = make ( chan new Table Result ) var num Builds , num Versions int var last Key , skip Key [ ] byte for it . Valid ( ) { time Start : = time . Now ( ) builder : = table . New Table Builder ( ) var num Keys , num Skips uint 6 4 for ; it . Valid ( ) ; it . Next ( ) { update Stats ( it . Value ( ) ) continue } update Stats ( it . Value ( ) ) continue } else { skip Key = skip Key [ : 0 ] } } if ! y . Same Key ( it . Key ( ) , last Key ) { if builder . Reached Capacity ( s . kv . opt . Max Table Size ) { } last Key = y . Safe Copy ( last Key , it . Key ( ) ) num Versions = 0 } vs : = it . Value ( ) version : = y . Parse Ts ( it . Key ( ) ) if version < = discard Ts { last Valid Version : = vs . Meta & bit Discard Earlier Versions > 0 if is Deleted Or Expired ( vs . Meta , vs . Expires At ) | | num Versions > s . kv . opt . Num Versions To Keep | | last Valid Version { if last Valid Version { update Stats ( vs ) continue } } } num Keys + + y . Check ( builder . Add ( it . Key ( ) , it . Value ( ) ) ) } if ! builder . Empty ( ) { num Builds + + file ID : = s . reserve File ID ( ) go func ( builder * table . Builder ) { defer builder . Close ( ) fd , err : = y . Create Synced File ( table . New Filename ( file ID , s . kv . opt . Dir ) , true ) if err ! = nil { result Ch < - new Table Result { nil , errors . Wrapf ( err , " " , file ID ) } return } if _ , err : = fd . Write ( builder . Finish ( ) ) ; err ! = nil { result Ch < - new Table Result { nil , errors . Wrapf ( err , " " , file ID ) } return } tbl , err : = table . Open Table ( fd , s . kv . opt . Table Loading Mode , nil ) } ( builder ) } } new Tables : = make ( [ ] * table . Table , 0 , 2 0 ) for x : = 0 ; x < num Builds ; x + + { res : = < - result Ch new Tables = append ( new Tables , res . table ) if first Err = = nil { first Err = res . err } } if first Err = = nil { } if first Err ! = nil { } } error Return : = errors . Wrapf ( first Err , " " , cd ) return nil , nil , error Return } sort . Slice ( new Tables , func ( i , j int ) bool { return y . Compare Keys ( new Tables [ i ] . Biggest ( ) , new Tables [ j ] . Biggest ( ) ) < 0 } ) s . kv . vlog . update Discard Stats ( discard Stats ) s . kv . opt . Debugf ( " " , discard Stats ) return new Tables , func ( ) error { return decr Refs ( new Tables ) } , nil } 
func ( s * levels Controller ) do Compact ( p compaction Priority ) error { l : = p . level y . Assert True ( l + 1 < s . kv . opt . Max Levels ) cd : = compact Def { elog : trace . New ( fmt . Sprintf ( " " , l ) , " " ) , this Level : s . levels [ l ] , next Level : s . levels [ l + 1 ] , drop Prefix : p . drop Prefix , } cd . elog . Set Max Events ( 1 0 0 ) defer cd . elog . Finish ( ) s . kv . opt . Infof ( " " , p ) } } else { if ! s . fill Tables ( & cd ) { return err Fill Tables } } defer s . cstatus . delete ( cd ) s . kv . opt . Infof ( " \n " , cd . this Level . level ) s . cstatus . to Log ( cd . elog ) if err : = s . run Compact Def ( l , cd ) ; err ! = nil { return err } s . cstatus . to Log ( cd . elog ) s . kv . opt . Infof ( " " , cd . this Level . level ) return nil } 
func ( s * levels Controller ) get ( key [ ] byte , max Vs * y . Value Struct ) ( y . Value Struct , error ) { for _ , h : = range s . levels { vs , err : = h . get ( key ) if err ! = nil { return y . Value Struct { } , errors . Wrapf ( err , " " , key ) } if vs . Value = = nil & & vs . Meta = = 0 { continue } if max Vs = = nil | | vs . Version = = version { return vs , nil } if max Vs . Version < vs . Version { * max Vs = vs } } if max Vs ! = nil { return * max Vs , nil } return y . Value Struct { } , nil } 
func ( s * levels Controller ) append Iterators ( iters [ ] y . Iterator , opt * Iterator Options ) [ ] y . Iterator { } return iters } 
func seek Total ( txn * badger . Txn ) ( [ ] account , error ) { expected : = uint 6 4 ( num Accounts ) * uint 6 4 ( initial Bal ) var accounts [ ] account var total uint 6 4 for i : = 0 ; i < num Accounts ; i + + { item , err : = txn . Get ( key ( i ) ) if err ! = nil { log . Printf ( " \n " , i , err , key ( i ) ) return accounts , err } val , err : = item . Value Copy ( nil ) if err ! = nil { return accounts , err } acc : = account { Id : i , Bal : to Uint 6 4 ( val ) , } accounts = append ( accounts , acc ) total + = acc . Bal } if total ! = expected { log . Printf ( " " , expected , total ) atomic . Add Int 3 2 ( & stop All , 1 ) return accounts , err Failure } return accounts , nil } 
func find First Invalid Txn ( db * badger . DB , low Ts , high Ts uint 6 4 ) uint 6 4 { check At : = func ( ts uint 6 4 ) error { txn : = db . New Transaction At ( ts , false ) _ , err : = seek Total ( txn ) txn . Discard ( ) return err } if high Ts - low Ts < 1 { log . Printf ( " \n " , low Ts ) err : = check At ( low Ts ) if err = = err Failure { fmt . Printf ( " \n " , low Ts ) return low Ts } else if err ! = nil { log . Printf ( " \n " , low Ts , err ) return 0 } fmt . Printf ( " \n " , low Ts ) return 0 } mid Ts : = ( low Ts + high Ts ) / 2 log . Println ( ) log . Printf ( " \n " , low Ts , high Ts , mid Ts ) err : = check At ( mid Ts ) if err = = badger . Err Key Not Found | | err = = nil { } } 
func ( m * Inmem Snapshot Store ) Create ( version Snapshot Version , index , term uint 6 4 , configuration Configuration , configuration Index uint 6 4 , trans Transport ) ( Snapshot Sink , error ) { } name : = snapshot Name ( term , index ) m . Lock ( ) defer m . Unlock ( ) sink : = & Inmem Snapshot Sink { meta : Snapshot Meta { Version : version , ID : name , Index : index , Term : term , Peers : encode Peers ( configuration , trans ) , Configuration : configuration , Configuration Index : configuration Index , } , contents : & bytes . Buffer { } , } m . has Snapshot = true m . latest = sink return sink , nil } 
func ( m * Inmem Snapshot Store ) List ( ) ( [ ] * Snapshot Meta , error ) { m . RLock ( ) defer m . RUnlock ( ) if ! m . has Snapshot { return [ ] * Snapshot Meta { } , nil } return [ ] * Snapshot Meta { & m . latest . meta } , nil } 
func ( m * Inmem Snapshot Store ) Open ( id string ) ( * Snapshot Meta , io . Read Closer , error ) { m . RLock ( ) defer m . RUnlock ( ) if m . latest . meta . ID ! = id { return nil , nil , fmt . Errorf ( " " , id ) } return & m . latest . meta , ioutil . Nop Closer ( m . latest . contents ) , nil } 
func ( s * Inmem Snapshot Sink ) Write ( p [ ] byte ) ( n int , err error ) { written , err : = io . Copy ( s . contents , bytes . New Reader ( p ) ) s . meta . Size + = written return int ( written ) , err } 
func New File Snapshot Store With Logger ( base string , retain int , logger * log . Logger ) ( * File Snapshot Store , error ) { if retain < 1 { return nil , fmt . Errorf ( " " ) } if logger = = nil { logger = log . New ( os . Stderr , " " , log . Lstd Flags ) } if err : = os . Mkdir All ( path , 0 7 5 5 ) ; err ! = nil & & ! os . Is Exist ( err ) { return nil , fmt . Errorf ( " " , err ) } } return store , nil } 
func New File Snapshot Store ( base string , retain int , log Output io . Writer ) ( * File Snapshot Store , error ) { if log Output = = nil { log Output = os . Stderr } return New File Snapshot Store With Logger ( base , retain , log . New ( log Output , " " , log . Lstd Flags ) ) } 
func snapshot Name ( term , index uint 6 4 ) string { now : = time . Now ( ) msec : = now . Unix Nano ( ) / int 6 4 ( time . Millisecond ) return fmt . Sprintf ( " " , term , index , msec ) } 
func ( f * File Snapshot Store ) Create ( version Snapshot Version , index , term uint 6 4 , configuration Configuration , configuration Index uint 6 4 , trans Transport ) ( Snapshot Sink , error ) { } path : = filepath . Join ( f . path , name + tmp Suffix ) f . logger . Printf ( " " , path ) return nil , err } return nil , err } fh , err : = os . Create ( state Path ) if err ! = nil { f . logger . Printf ( " " , err ) return nil , err } sink . state File = fh sink . buffered = bufio . New Writer ( multi ) } 
func ( f * File Snapshot Store ) List ( ) ( [ ] * Snapshot Meta , error ) { if err ! = nil { f . logger . Printf ( " " , err ) return nil , err } var snap Meta [ ] * Snapshot Meta for _ , meta : = range snapshots { snap Meta = append ( snap Meta , & meta . Snapshot Meta ) if len ( snap Meta ) = = f . retain { break } } return snap Meta , nil } 
func ( f * File Snapshot Store ) get Snapshots ( ) ( [ ] * file Snapshot Meta , error ) { if err ! = nil { f . logger . Printf ( " " , err ) return nil , err } for _ , snap : = range snapshots { } if strings . Has Suffix ( dir Name , tmp Suffix ) { f . logger . Printf ( " " , dir Name ) continue } if err ! = nil { f . logger . Printf ( " " , dir Name , err ) continue } continue } } return snap Meta , nil } 
func ( f * File Snapshot Store ) read Meta ( name string ) ( * file Snapshot Meta , error ) { fh , err : = os . Open ( meta Path ) if err ! = nil { return nil , err } defer fh . Close ( ) dec : = json . New Decoder ( buffered ) if err : = dec . Decode ( meta ) ; err ! = nil { return nil , err } return meta , nil } 
func ( f * File Snapshot Store ) Open ( id string ) ( * Snapshot Meta , io . Read Closer , error ) { if err ! = nil { f . logger . Printf ( " " , err ) return nil , nil , err } fh , err : = os . Open ( state Path ) if err ! = nil { f . logger . Printf ( " " , err ) return nil , nil , err } if err ! = nil { f . logger . Printf ( " " , err ) fh . Close ( ) return nil , nil , err } if bytes . Compare ( meta . CRC , computed ) ! = 0 { f . logger . Printf ( " " , meta . CRC , computed ) fh . Close ( ) return nil , nil , fmt . Errorf ( " " ) } fh . Close ( ) return nil , nil , err } return & meta . Snapshot Meta , buffered , nil } 
func ( f * File Snapshot Store ) Reap Snapshots ( ) error { snapshots , err : = f . get Snapshots ( ) if err ! = nil { f . logger . Printf ( " " , err ) return err } for i : = f . retain ; i < len ( snapshots ) ; i + + { path : = filepath . Join ( f . path , snapshots [ i ] . ID ) f . logger . Printf ( " " , path ) if err : = os . Remove All ( path ) ; err ! = nil { f . logger . Printf ( " " , path , err ) return err } } return nil } 
func ( s * File Snapshot Sink ) Write ( b [ ] byte ) ( int , error ) { return s . buffered . Write ( b ) } 
func ( s * File Snapshot Sink ) Close ( ) error { } s . closed = true if del Err : = os . Remove All ( s . dir ) ; del Err ! = nil { s . logger . Printf ( " " , s . dir , del Err ) return del Err } return err } return err } if err : = os . Rename ( s . dir , new Path ) ; err ! = nil { s . logger . Printf ( " " , err ) return err } if runtime . GOOS ! = " " { defer parent FH . Close ( ) if err ! = nil { s . logger . Printf ( " " , s . parent Dir , err ) return err } if err = parent FH . Sync ( ) ; err ! = nil { s . logger . Printf ( " " , s . parent Dir , err ) return err } } } return nil } 
func ( s * File Snapshot Sink ) Cancel ( ) error { } s . closed = true return err } } 
func ( s * File Snapshot Sink ) finalize ( ) error { } } } } s . meta . Size = stat . Size ( ) return nil } 
func ( s * File Snapshot Sink ) write Meta ( ) error { fh , err : = os . Create ( meta Path ) if err ! = nil { return err } defer fh . Close ( ) if err : = enc . Encode ( & s . meta ) ; err ! = nil { return err } if err = buffered . Flush ( ) ; err ! = nil { return err } if err = fh . Sync ( ) ; err ! = nil { return err } return nil } 
func New Network Transport With Config ( config * Network Transport Config , ) * Network Transport { if config . Logger = = nil { config . Logger = log . New ( os . Stderr , " " , log . Lstd Flags ) } trans : = & Network Transport { conn Pool : make ( map [ Server Address ] [ ] * net Conn ) , consume Ch : make ( chan RPC ) , logger : config . Logger , max Pool : config . Max Pool , shutdown Ch : make ( chan struct { } ) , stream : config . Stream , timeout : config . Timeout , Timeout Scale : Default Timeout Scale , server Address Provider : config . Server Address Provider , } go trans . listen ( ) return trans } 
func New Network Transport ( stream Stream Layer , max Pool int , timeout time . Duration , log Output io . Writer , ) * Network Transport { if log Output = = nil { log Output = os . Stderr } logger : = log . New ( log Output , " " , log . Lstd Flags ) config : = & Network Transport Config { Stream : stream , Max Pool : max Pool , Timeout : timeout , Logger : logger } return New Network Transport With Config ( config ) } 
func New Network Transport With Logger ( stream Stream Layer , max Pool int , timeout time . Duration , logger * log . Logger , ) * Network Transport { config : = & Network Transport Config { Stream : stream , Max Pool : max Pool , Timeout : timeout , Logger : logger } return New Network Transport With Config ( config ) } 
func ( n * Network Transport ) setup Stream Context ( ) { ctx , cancel : = context . With Cancel ( context . Background ( ) ) n . stream Ctx = ctx n . stream Cancel = cancel } 
func ( n * Network Transport ) get Stream Context ( ) context . Context { n . stream Ctx Lock . RLock ( ) defer n . stream Ctx Lock . RUnlock ( ) return n . stream Ctx } 
func ( n * Network Transport ) Set Heartbeat Handler ( cb func ( rpc RPC ) ) { n . heartbeat Fn Lock . Lock ( ) defer n . heartbeat Fn Lock . Unlock ( ) n . heartbeat Fn = cb } 
func ( n * Network Transport ) Close Streams ( ) { n . conn Pool Lock . Lock ( ) defer n . conn Pool Lock . Unlock ( ) } delete ( n . conn Pool , k ) } n . stream Cancel ( ) n . setup Stream Context ( ) n . stream Ctx Lock . Unlock ( ) } 
func ( n * Network Transport ) Close ( ) error { n . shutdown Lock . Lock ( ) defer n . shutdown Lock . Unlock ( ) if ! n . shutdown { close ( n . shutdown Ch ) n . stream . Close ( ) n . shutdown = true } return nil } 
func ( n * Network Transport ) get Pooled Conn ( target Server Address ) * net Conn { n . conn Pool Lock . Lock ( ) defer n . conn Pool Lock . Unlock ( ) conns , ok : = n . conn Pool [ target ] if ! ok | | len ( conns ) = = 0 { return nil } var conn * net Conn num : = len ( conns ) conn , conns [ num - 1 ] = conns [ num - 1 ] , nil n . conn Pool [ target ] = conns [ : num - 1 ] return conn } 
func ( n * Network Transport ) get Conn From Address Provider ( id Server ID , target Server Address ) ( * net Conn , error ) { address : = n . get Provider Address Or Fallback ( id , target ) return n . get Conn ( address ) } 
func ( n * Network Transport ) get Conn ( target Server Address ) ( * net Conn , error ) { } if err ! = nil { return nil , err } net Conn . enc = codec . New Encoder ( net Conn . w , & codec . Msgpack Handle { } ) } 
func ( n * Network Transport ) return Conn ( conn * net Conn ) { n . conn Pool Lock . Lock ( ) defer n . conn Pool Lock . Unlock ( ) key : = conn . target conns , _ : = n . conn Pool [ key ] if ! n . Is Shutdown ( ) & & len ( conns ) < n . max Pool { n . conn Pool [ key ] = append ( conns , conn ) } else { conn . Release ( ) } } 
func ( n * Network Transport ) Append Entries Pipeline ( id Server ID , target Server Address ) ( Append Pipeline , error ) { if err ! = nil { return nil , err } } 
func ( n * Network Transport ) Append Entries ( id Server ID , target Server Address , args * Append Entries Request , resp * Append Entries Response ) error { return n . generic RPC ( id , target , rpc Append Entries , args , resp ) } 
func ( n * Network Transport ) Request Vote ( id Server ID , target Server Address , args * Request Vote Request , resp * Request Vote Response ) error { return n . generic RPC ( id , target , rpc Request Vote , args , resp ) } 
func ( n * Network Transport ) generic RPC ( id Server ID , target Server Address , rpc Type uint 8 , args interface { } , resp interface { } ) error { if err ! = nil { return err } } } if can Return { n . return Conn ( conn ) } return err } 
func ( n * Network Transport ) Install Snapshot ( id Server ID , target Server Address , args * Install Snapshot Request , resp * Install Snapshot Response , data io . Reader ) error { if err ! = nil { return err } defer conn . Release ( ) if timeout < n . timeout { timeout = n . timeout } conn . conn . Set Deadline ( time . Now ( ) . Add ( timeout ) ) } } } } return err } 
func ( n * Network Transport ) Encode Peer ( id Server ID , p Server Address ) [ ] byte { address : = n . get Provider Address Or Fallback ( id , p ) return [ ] byte ( address ) } 
func ( n * Network Transport ) listen ( ) { const base Delay = 5 * time . Millisecond const max Delay = 1 * time . Second var loop Delay time . Duration for { if err ! = nil { if loop Delay = = 0 { loop Delay = base Delay } else { loop Delay * = 2 } if loop Delay > max Delay { loop Delay = max Delay } if ! n . Is Shutdown ( ) { n . logger . Printf ( " " , err ) } select { case < - n . shutdown Ch : return case < - time . After ( loop Delay ) : continue } } n . logger . Printf ( " " , n . Local Addr ( ) , conn . Remote Addr ( ) ) } } 
func ( n * Network Transport ) handle Conn ( conn Ctx context . Context , conn net . Conn ) { defer conn . Close ( ) r : = bufio . New Reader ( conn ) w : = bufio . New Writer ( conn ) dec : = codec . New Decoder ( r , & codec . Msgpack Handle { } ) enc : = codec . New Encoder ( w , & codec . Msgpack Handle { } ) for { select { case < - conn Ctx . Done ( ) : n . logger . Println ( " " ) return default : } if err : = n . handle Command ( r , dec , enc ) ; err ! = nil { if err ! = io . EOF { n . logger . Printf ( " " , err ) } return } if err : = w . Flush ( ) ; err ! = nil { n . logger . Printf ( " " , err ) return } } } 
func ( n * Network Transport ) handle Command ( r * bufio . Reader , dec * codec . Decoder , enc * codec . Encoder ) error { if err ! = nil { return err } rpc : = RPC { Resp Chan : resp Ch , } switch rpc Type { case rpc Append Entries : var req Append Entries Request if err : = dec . Decode ( & req ) ; err ! = nil { return err } rpc . Command = & req } case rpc Request Vote : var req Request Vote Request if err : = dec . Decode ( & req ) ; err ! = nil { return err } rpc . Command = & req case rpc Install Snapshot : var req Install Snapshot Request if err : = dec . Decode ( & req ) ; err ! = nil { return err } rpc . Command = & req rpc . Reader = io . Limit Reader ( r , req . Size ) default : return fmt . Errorf ( " " , rpc Type ) } fn : = n . heartbeat Fn n . heartbeat Fn Lock . Unlock ( ) if fn ! = nil { fn ( rpc ) goto RESP } } } if resp . Error ! = nil { resp Err = resp . Error . Error ( ) } if err : = enc . Encode ( resp Err ) ; err ! = nil { return err } } case < - n . shutdown Ch : return Err Transport Shutdown } return nil } 
func decode Response ( conn * net Conn , resp interface { } ) ( bool , error ) { if err : = conn . dec . Decode ( & rpc Error ) ; err ! = nil { conn . Release ( ) return false , err } return false , err } } return true , nil } 
func send RPC ( conn * net Conn , rpc Type uint 8 , args interface { } ) error { return err } return err } return err } return nil } 
func new Net Pipeline ( trans * Network Transport , conn * net Conn ) * net Pipeline { n : = & net Pipeline { conn : conn , trans : trans , done Ch : make ( chan Append Future , rpc Max Pipeline ) , inprogress Ch : make ( chan * append Future , rpc Max Pipeline ) , shutdown Ch : make ( chan struct { } ) , } go n . decode Responses ( ) return n } 
func ( n * net Pipeline ) decode Responses ( ) { timeout : = n . trans . timeout for { select { case future : = < - n . inprogress Ch : if timeout > 0 { n . conn . conn . Set Read Deadline ( time . Now ( ) . Add ( timeout ) ) } _ , err : = decode Response ( n . conn , future . resp ) future . respond ( err ) select { case n . done Ch < - future : case < - n . shutdown Ch : return } case < - n . shutdown Ch : return } } } 
func ( n * net Pipeline ) Append Entries ( args * Append Entries Request , resp * Append Entries Response ) ( Append Future , error ) { future . init ( ) } } case < - n . shutdown Ch : return nil , Err Pipeline Shutdown } } 
func ( n * net Pipeline ) Close ( ) error { n . shutdown Lock . Lock ( ) defer n . shutdown Lock . Unlock ( ) if n . shutdown { return nil } n . shutdown = true close ( n . shutdown Ch ) return nil } 
func New Observer ( channel chan Observation , blocking bool , filter Filter Fn ) * Observer { return & Observer { channel : channel , blocking : blocking , filter : filter , id : atomic . Add Uint 6 4 ( & next Observer ID , 1 ) , } } 
func ( r * Raft ) Register Observer ( or * Observer ) { r . observers Lock . Lock ( ) defer r . observers Lock . Unlock ( ) r . observers [ or . id ] = or } 
func ( r * Raft ) Deregister Observer ( or * Observer ) { r . observers Lock . Lock ( ) defer r . observers Lock . Unlock ( ) delete ( r . observers , or . id ) } 
func ( r * Raft ) observe ( o interface { } ) { defer r . observers Lock . RUnlock ( ) for _ , or : = range r . observers { if or . filter ! = nil & & ! or . filter ( & ob ) { continue } if or . channel = = nil { continue } if or . blocking { or . channel < - ob atomic . Add Uint 6 4 ( & or . num Observed , 1 ) } else { select { case or . channel < - ob : atomic . Add Uint 6 4 ( & or . num Observed , 1 ) default : atomic . Add Uint 6 4 ( & or . num Dropped , 1 ) } } } } 
func New Inmem Store ( ) * Inmem Store { i : = & Inmem Store { logs : make ( map [ uint 6 4 ] * Log ) , kv : make ( map [ string ] [ ] byte ) , kv Int : make ( map [ string ] uint 6 4 ) , } return i } 
func ( i * Inmem Store ) First Index ( ) ( uint 6 4 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . low Index , nil } 
func ( i * Inmem Store ) Last Index ( ) ( uint 6 4 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . high Index , nil } 
func ( i * Inmem Store ) Get Log ( index uint 6 4 , log * Log ) error { i . l . RLock ( ) defer i . l . RUnlock ( ) l , ok : = i . logs [ index ] if ! ok { return Err Log Not Found } * log = * l return nil } 
func ( i * Inmem Store ) Store Log ( log * Log ) error { return i . Store Logs ( [ ] * Log { log } ) } 
func ( i * Inmem Store ) Store Logs ( logs [ ] * Log ) error { i . l . Lock ( ) defer i . l . Unlock ( ) for _ , l : = range logs { i . logs [ l . Index ] = l if i . low Index = = 0 { i . low Index = l . Index } if l . Index > i . high Index { i . high Index = l . Index } } return nil } 
func ( i * Inmem Store ) Delete Range ( min , max uint 6 4 ) error { i . l . Lock ( ) defer i . l . Unlock ( ) for j : = min ; j < = max ; j + + { delete ( i . logs , j ) } if min < = i . low Index { i . low Index = max + 1 } if max > = i . high Index { i . high Index = min - 1 } if i . low Index > i . high Index { i . low Index = 0 i . high Index = 0 } return nil } 
func ( i * Inmem Store ) Set ( key [ ] byte , val [ ] byte ) error { i . l . Lock ( ) defer i . l . Unlock ( ) i . kv [ string ( key ) ] = val return nil } 
func ( i * Inmem Store ) Get ( key [ ] byte ) ( [ ] byte , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) val : = i . kv [ string ( key ) ] if val = = nil { return nil , errors . New ( " " ) } return val , nil } 
func ( i * Inmem Store ) Set Uint 6 4 ( key [ ] byte , val uint 6 4 ) error { i . l . Lock ( ) defer i . l . Unlock ( ) i . kv Int [ string ( key ) ] = val return nil } 
func ( i * Inmem Store ) Get Uint 6 4 ( key [ ] byte ) ( uint 6 4 , error ) { i . l . RLock ( ) defer i . l . RUnlock ( ) return i . kv Int [ string ( key ) ] , nil } 
func New Log Cache ( capacity int , store Log Store ) ( * Log Cache , error ) { if capacity < = 0 { return nil , fmt . Errorf ( " " ) } c : = & Log Cache { store : store , cache : make ( [ ] * Log , capacity ) , } return c , nil } 
func New Inmem Transport With Timeout ( addr Server Address , timeout time . Duration ) ( Server Address , * Inmem Transport ) { if string ( addr ) = = " " { addr = New Inmem Addr ( ) } trans : = & Inmem Transport { consumer Ch : make ( chan RPC , 1 6 ) , local Addr : addr , peers : make ( map [ Server Address ] * Inmem Transport ) , timeout : timeout , } return addr , trans } 
func ( i * Inmem Transport ) Append Entries Pipeline ( id Server ID , target Server Address ) ( Append Pipeline , error ) { i . Lock ( ) defer i . Unlock ( ) peer , ok : = i . peers [ target ] if ! ok { return nil , fmt . Errorf ( " " , target ) } pipeline : = new Inmem Pipeline ( i , peer , target ) i . pipelines = append ( i . pipelines , pipeline ) return pipeline , nil } 
func ( i * Inmem Transport ) Append Entries ( id Server ID , target Server Address , args * Append Entries Request , resp * Append Entries Response ) error { rpc Resp , err : = i . make RPC ( target , args , nil , i . timeout ) if err ! = nil { return err } * resp = * out return nil } 
func ( i * Inmem Transport ) Request Vote ( id Server ID , target Server Address , args * Request Vote Request , resp * Request Vote Response ) error { rpc Resp , err : = i . make RPC ( target , args , nil , i . timeout ) if err ! = nil { return err } * resp = * out return nil } 
func ( i * Inmem Transport ) Install Snapshot ( id Server ID , target Server Address , args * Install Snapshot Request , resp * Install Snapshot Response , data io . Reader ) error { rpc Resp , err : = i . make RPC ( target , args , data , 1 0 * i . timeout ) if err ! = nil { return err } * resp = * out return nil } 
func ( i * Inmem Transport ) Encode Peer ( id Server ID , p Server Address ) [ ] byte { return [ ] byte ( p ) } 
func ( i * Inmem Transport ) Connect ( peer Server Address , t Transport ) { trans : = t . ( * Inmem Transport ) i . Lock ( ) defer i . Unlock ( ) i . peers [ peer ] = trans } 
func ( i * Inmem Transport ) Disconnect ( peer Server Address ) { i . Lock ( ) defer i . Unlock ( ) delete ( i . peers , peer ) for idx : = 0 ; idx < n ; idx + + { if i . pipelines [ idx ] . peer Addr = = peer { i . pipelines [ idx ] . Close ( ) i . pipelines [ idx ] , i . pipelines [ n - 1 ] = i . pipelines [ n - 1 ] , nil idx - - n - - } } i . pipelines = i . pipelines [ : n ] } 
func ( i * Inmem Transport ) Disconnect All ( ) { i . Lock ( ) defer i . Unlock ( ) i . peers = make ( map [ Server Address ] * Inmem Transport ) } i . pipelines = nil } 
func ( r * RPC ) Respond ( resp interface { } , err error ) { r . Resp Chan < - RPCResponse { resp , err } } 
func ( u * user Snapshot Future ) Open ( ) ( * Snapshot Meta , io . Read Closer , error ) { if u . opener = = nil { return nil , nil , fmt . Errorf ( " " ) } else { } ( ) return u . opener ( ) } } 
func ( v * verify Future ) vote ( leader bool ) { v . vote Lock . Lock ( ) defer v . vote Lock . Unlock ( ) } if leader { v . votes + + if v . votes > = v . quorum Size { v . notify Ch < - v v . notify Ch = nil } } else { v . notify Ch < - v v . notify Ch = nil } } 
func ( s * follower Replication ) notify All ( leader bool ) { n : = s . notify s . notify = make ( map [ * verify Future ] struct { } ) s . notify Lock . Unlock ( ) } } 
func ( s * follower Replication ) clean Notify ( v * verify Future ) { s . notify Lock . Lock ( ) delete ( s . notify , v ) s . notify Lock . Unlock ( ) } 
func ( s * follower Replication ) Last Contact ( ) time . Time { s . last Contact Lock . RLock ( ) last : = s . last Contact s . last Contact Lock . RUnlock ( ) return last } 
func ( s * follower Replication ) set Last Contact ( ) { s . last Contact Lock . Lock ( ) s . last Contact = time . Now ( ) s . last Contact Lock . Unlock ( ) } 
func ( r * Raft ) replicate ( s * follower Replication ) { defer close ( stop Heartbeat ) r . go Func ( func ( ) { r . heartbeat ( s , stop Heartbeat ) } ) RPC : should Stop : = false for ! should Stop { select { case max Index : = < - s . stop Ch : } return case < - s . trigger Ch : last Log Idx , _ : = r . get Last Log ( ) should Stop = r . replicate To ( s , last Log Idx ) should Stop = r . replicate To ( s , last Log Idx ) } } } return PIPELINE : } } goto RPC } 
func ( r * Raft ) replicate To ( s * follower Replication , last Index uint 6 4 ) ( should Stop bool ) { var resp Append Entries Response var start time . Time START : } } else if err ! = nil { return } if err : = r . trans . Append Entries ( s . peer . ID , s . peer . Address , & req , & resp ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , s . peer , err ) ) s . failures + + return } append Stats ( string ( s . peer . ID ) , start , float 3 2 ( len ( req . Entries ) ) ) return true } s . allow Pipeline = true } else { s . next Index = max ( min ( s . next Index - 1 , resp . Last Log + 1 ) , 1 ) if resp . No Retry Backoff { s . failures = 0 } else { s . failures + + } r . logger . Warn ( fmt . Sprintf ( " " , s . peer , s . next Index ) ) } CHECK _MORE : default : } } return } else if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , s . peer , err ) ) return } } 
func ( r * Raft ) heartbeat ( s * follower Replication , stop Ch chan struct { } ) { var failures uint 6 4 req : = Append Entries Request { RPCHeader : r . get RPCHeader ( ) , Term : s . current Term , Leader : r . trans . Encode Peer ( r . local ID , r . local Addr ) , } var resp Append Entries Response for { } start : = time . Now ( ) if err : = r . trans . Append Entries ( s . peer . ID , s . peer . Address , & req , & resp ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , s . peer . Address , err ) ) failures + + select { case < - time . After ( backoff ( failure Wait , failures , max Failure Scale ) ) : case < - stop Ch : } } else { s . set Last Contact ( ) failures = 0 metrics . Measure Since ( [ ] string { " " , " " , " " , string ( s . peer . ID ) } , start ) s . notify All ( resp . Success ) } } } 
func ( r * Raft ) pipeline Replicate ( s * follower Replication ) error { if err ! = nil { return err } defer pipeline . Close ( ) defer r . logger . Info ( fmt . Sprintf ( " " , s . peer ) ) finish Ch : = make ( chan struct { } ) should Stop : = false SEND : for ! should Stop { select { case < - finish Ch : break SEND case max Index : = < - s . stop Ch : } break SEND case < - s . trigger Ch : last Log Idx , _ : = r . get Last Log ( ) should Stop = r . pipeline Send ( s , pipeline , & next Index , last Log Idx ) case < - random Timeout ( r . conf . Commit Timeout ) : last Log Idx , _ : = r . get Last Log ( ) should Stop = r . pipeline Send ( s , pipeline , & next Index , last Log Idx ) } } select { case < - finish Ch : case < - r . shutdown Ch : } return nil } 
func ( r * Raft ) pipeline Send ( s * follower Replication , p Append Pipeline , next Idx * uint 6 4 , last Index uint 6 4 ) ( should Stop bool ) { if err : = r . setup Append Entries ( s , req , * next Idx , last Index ) ; err ! = nil { return true } return true } * next Idx = last . Index + 1 } return false } 
func ( r * Raft ) pipeline Decode ( s * follower Replication , p Append Pipeline , stop Ch , finish Ch chan struct { } ) { defer close ( finish Ch ) resp Ch : = p . Consumer ( ) for { select { case ready : = < - resp Ch : req , resp : = ready . Request ( ) , ready . Response ( ) append Stats ( string ( s . peer . ID ) , ready . Start ( ) , float 3 2 ( len ( req . Entries ) ) ) return } } case < - stop Ch : return } } } 
func ( r * Raft ) setup Append Entries ( s * follower Replication , req * Append Entries Request , next Index , last Index uint 6 4 ) error { req . RPCHeader = r . get RPCHeader ( ) req . Term = s . current Term req . Leader = r . trans . Encode Peer ( r . local ID , r . local Addr ) req . Leader Commit Index = r . get Commit Index ( ) if err : = r . set Previous Log ( req , next Index ) ; err ! = nil { return err } if err : = r . set New Logs ( req , next Index , last Index ) ; err ! = nil { return err } return nil } 
func ( r * Raft ) set Previous Log ( req * Append Entries Request , next Index uint 6 4 ) error { if next Index = = 1 { req . Prev Log Entry = 0 req . Prev Log Term = 0 } else if ( next Index - 1 ) = = last Snap Idx { req . Prev Log Entry = last Snap Idx req . Prev Log Term = last Snap Term } else { var l Log if err : = r . logs . Get Log ( next Index - 1 , & l ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , next Index - 1 , err ) ) return err } req . Prev Log Term = l . Term } return nil } 
func ( r * Raft ) set New Logs ( req * Append Entries Request , next Index , last Index uint 6 4 ) error { max Index : = min ( next Index + uint 6 4 ( r . conf . Max Append Entries ) - 1 , last Index ) for i : = next Index ; i < = max Index ; i + + { old Log : = new ( Log ) if err : = r . logs . Get Log ( i , old Log ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , i , err ) ) return err } req . Entries = append ( req . Entries , old Log ) } return nil } 
func append Stats ( peer string , start time . Time , logs float 3 2 ) { metrics . Measure Since ( [ ] string { " " , " " , " " , " " , peer } , start ) metrics . Incr Counter ( [ ] string { " " , " " , " " , " " , peer } , logs ) } 
func ( r * Raft ) handle Stale Term ( s * follower Replication ) { r . logger . Error ( fmt . Sprintf ( " " , s . peer ) ) s . notify All ( false ) async Notify Ch ( s . step Down ) } 
func update Last Appended ( s * follower Replication , req * Append Entries Request ) { s . next Index = last . Index + 1 s . commitment . match ( s . peer . ID , last . Index ) } } 
func ( t * transport ) Append Entries ( id raft . Server ID , target raft . Server Address , args * raft . Append Entries Request , resp * raft . Append Entries Response ) error { ae : = append Entries { source : t . node , target : target , first Index : first Index ( args ) , last Index : last Index ( args ) , commit Index : args . Leader Commit Index , } if len ( t . ae ) < cap ( t . ae ) { t . ae = append ( t . ae , ae ) } return t . send RPC ( string ( target ) , args , resp ) } 
func ( t * transport ) Request Vote ( id raft . Server ID , target raft . Server Address , args * raft . Request Vote Request , resp * raft . Request Vote Response ) error { return t . send RPC ( string ( target ) , args , resp ) } 
func ( t * transport ) Install Snapshot ( id raft . Server ID , target raft . Server Address , args * raft . Install Snapshot Request , resp * raft . Install Snapshot Response , data io . Reader ) error { t . log . Printf ( " " ) return errors . New ( " " ) } 
func ( t * transport ) Encode Peer ( id raft . Server ID , p raft . Server Address ) [ ] byte { return [ ] byte ( p ) } 
func ( t * transport ) Decode Peer ( p [ ] byte ) raft . Server Address { return raft . Server Address ( p ) } 
func ( t * transport ) Append Entries Pipeline ( id raft . Server ID , target raft . Server Address ) ( raft . Append Pipeline , error ) { p : = & pipeline { t : t , id : id , target : target , work : make ( chan * append Entry , 1 0 0 ) , consumer : make ( chan raft . Append Future , 1 0 0 ) , } go p . run ( ) return p , nil } 
func ( p * pipeline ) Append Entries ( args * raft . Append Entries Request , resp * raft . Append Entries Response ) ( raft . Append Future , error ) { e : = & append Entry { req : args , res : resp , start : time . Now ( ) , ready : make ( chan error ) , consumer : p . consumer , } p . work < - e return e , nil } 
func Read Peers JSON ( path string ) ( Configuration , error ) { if err ! = nil { return Configuration { } , err } dec : = json . New Decoder ( bytes . New Reader ( buf ) ) if err : = dec . Decode ( & peers ) ; err ! = nil { return Configuration { } , err } for _ , peer : = range peers { server : = Server { Suffrage : Voter , ID : Server ID ( peer ) , Address : Server Address ( peer ) , } configuration . Servers = append ( configuration . Servers , server ) } } return configuration , nil } 
func Read Config JSON ( path string ) ( Configuration , error ) { if err ! = nil { return Configuration { } , err } dec : = json . New Decoder ( bytes . New Reader ( buf ) ) if err : = dec . Decode ( & peers ) ; err ! = nil { return Configuration { } , err } for _ , peer : = range peers { suffrage : = Voter if peer . Non Voter { suffrage = Nonvoter } server : = Server { Suffrage : suffrage , ID : peer . ID , Address : peer . Address , } configuration . Servers = append ( configuration . Servers , server ) } } return configuration , nil } 
func New TCPTransport ( bind Addr string , advertise net . Addr , max Pool int , timeout time . Duration , log Output io . Writer , ) ( * Network Transport , error ) { return new TCPTransport ( bind Addr , advertise , func ( stream Stream Layer ) * Network Transport { return New Network Transport ( stream , max Pool , timeout , log Output ) } ) } 
func New TCPTransport With Logger ( bind Addr string , advertise net . Addr , max Pool int , timeout time . Duration , logger * log . Logger , ) ( * Network Transport , error ) { return new TCPTransport ( bind Addr , advertise , func ( stream Stream Layer ) * Network Transport { return New Network Transport With Logger ( stream , max Pool , timeout , logger ) } ) } 
func New TCPTransport With Config ( bind Addr string , advertise net . Addr , config * Network Transport Config , ) ( * Network Transport , error ) { return new TCPTransport ( bind Addr , advertise , func ( stream Stream Layer ) * Network Transport { config . Stream = stream return New Network Transport With Config ( config ) } ) } 
func ( t * TCPStream Layer ) Dial ( address Server Address , timeout time . Duration ) ( net . Conn , error ) { return net . Dial Timeout ( " " , string ( address ) , timeout ) } 
func ( t * TCPStream Layer ) Accept ( ) ( c net . Conn , err error ) { return t . listener . Accept ( ) } 
func ( t * TCPStream Layer ) Addr ( ) net . Addr { } return t . listener . Addr ( ) } 
func Bootstrap Cluster ( conf * Config , logs Log Store , stable Stable Store , snaps Snapshot Store , trans Transport , configuration Configuration ) error { } } if err ! = nil { return fmt . Errorf ( " " , err ) } if has State { return Err Cant Bootstrap } } if conf . Protocol Version < 3 { entry . Type = Log Remove Peer Deprecated entry . Data = encode Peers ( configuration , trans ) } else { entry . Type = Log Configuration entry . Data = encode Configuration ( configuration ) } if err : = logs . Store Log ( entry ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Recover Cluster ( conf * Config , fsm FSM , logs Log Store , stable Stable Store , snaps Snapshot Store , trans Transport , configuration Configuration ) error { } } if err ! = nil { return fmt . Errorf ( " " , err ) } if ! has State { return fmt . Errorf ( " " ) } var snapshot Term uint 6 4 snapshots , err : = snaps . List ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } for _ , snapshot : = range snapshots { _ , source , err : = snaps . Open ( snapshot . ID ) if err ! = nil { } defer source . Close ( ) if err : = fsm . Restore ( source ) ; err ! = nil { } snapshot Index = snapshot . Index snapshot Term = snapshot . Term break } if len ( snapshots ) > 0 & & ( snapshot Index = = 0 | | snapshot Term = = 0 ) { return fmt . Errorf ( " " ) } last Term : = snapshot Term if err ! = nil { return fmt . Errorf ( " " , err ) } for index : = snapshot Index + 1 ; index < = last Log Index ; index + + { var entry Log if err : = logs . Get Log ( index , & entry ) ; err ! = nil { return fmt . Errorf ( " " , index , err ) } if entry . Type = = Log Command { _ = fsm . Apply ( & entry ) } last Index = entry . Index last Term = entry . Term } if err ! = nil { return fmt . Errorf ( " " , err ) } version : = get Snapshot Version ( conf . Protocol Version ) sink , err : = snaps . Create ( version , last Index , last Term , configuration , 1 , trans ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = snapshot . Persist ( sink ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = sink . Close ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = logs . Delete Range ( first Log Index , last Log Index ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Has Existing State ( logs Log Store , stable Stable Store , snaps Snapshot Store ) ( bool , error ) { if err = = nil { if current Term > 0 { return true , nil } } else { if err . Error ( ) ! = " " { return false , fmt . Errorf ( " " , err ) } } if err ! = nil { return false , fmt . Errorf ( " " , err ) } if last Index > 0 { return true , nil } if err ! = nil { return false , fmt . Errorf ( " " , err ) } if len ( snapshots ) > 0 { return true , nil } return false , nil } 
func New Raft ( conf * Config , fsm FSM , logs Log Store , stable Stable Store , snaps Snapshot Store , trans Transport ) ( * Raft , error ) { } if conf . Logger ! = nil { logger = conf . Logger } else { if conf . Log Output = = nil { conf . Log Output = os . Stderr } logger = hclog . New ( & hclog . Logger Options { Name : " " , Level : hclog . Level From String ( conf . Log Level ) , Output : conf . Log Output , } ) } if err ! = nil & & err . Error ( ) ! = " " { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if last Index > 0 { if err = logs . Get Log ( last Index , & last Log ) ; err ! = nil { return nil , fmt . Errorf ( " " , last Index , err ) } } local Addr : = Server Address ( trans . Local Addr ( ) ) local ID : = conf . Local ID } r . set Leader ( r . local Addr ) } r . set Last Log ( last Log . Index , last Log . Term ) } for index : = snapshot Index + 1 ; index < = last Log . Index ; index + + { var entry Log if err : = r . logs . Get Log ( index , & entry ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , index , err ) ) panic ( err ) } r . process Configuration Log Entry ( & entry ) } r . logger . Info ( fmt . Sprintf ( " " , r . configurations . latest Index , r . configurations . latest . Servers ) ) r . go Func ( r . run FSM ) r . go Func ( r . run Snapshots ) return r , nil } 
func ( r * Raft ) restore Snapshot ( ) error { snapshots , err : = r . snapshots . List ( ) if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , err ) ) return err } if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , snapshot . ID , err ) ) continue } defer source . Close ( ) if err : = r . fsm . Restore ( source ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , snapshot . ID , err ) ) continue } r . configurations . committed Index = snapshot . Configuration Index r . configurations . latest = snapshot . Configuration r . configurations . latest Index = snapshot . Configuration Index } else { configuration : = decode Peers ( snapshot . Peers , r . trans ) r . configurations . committed = configuration r . configurations . committed Index = snapshot . Index r . configurations . latest = configuration r . configurations . latest Index = snapshot . Index } } } return nil } 
func ( r * Raft ) Bootstrap Cluster ( configuration Configuration ) Future { bootstrap Req : = & bootstrap Future { } bootstrap Req . init ( ) bootstrap Req . configuration = configuration select { case < - r . shutdown Ch : return error Future { Err Raft Shutdown } case r . bootstrap Ch < - bootstrap Req : return bootstrap Req } } 
func ( r * Raft ) Leader ( ) Server Address { r . leader Lock . RLock ( ) leader : = r . leader r . leader Lock . RUnlock ( ) return leader } 
func ( r * Raft ) Apply ( cmd [ ] byte , timeout time . Duration ) Apply Future { metrics . Incr Counter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . Time if timeout > 0 { timer = time . After ( timeout ) } log Future . init ( ) select { case < - timer : return error Future { Err Enqueue Timeout } case < - r . shutdown Ch : return error Future { Err Raft Shutdown } case r . apply Ch < - log Future : return log Future } } 
func ( r * Raft ) Barrier ( timeout time . Duration ) Future { metrics . Incr Counter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . Time if timeout > 0 { timer = time . After ( timeout ) } log Future . init ( ) select { case < - timer : return error Future { Err Enqueue Timeout } case < - r . shutdown Ch : return error Future { Err Raft Shutdown } case r . apply Ch < - log Future : return log Future } } 
func ( r * Raft ) Verify Leader ( ) Future { metrics . Incr Counter ( [ ] string { " " , " " } , 1 ) verify Future : = & verify Future { } verify Future . init ( ) select { case < - r . shutdown Ch : return error Future { Err Raft Shutdown } case r . verify Ch < - verify Future : return verify Future } } 
func ( r * Raft ) Get Configuration ( ) Configuration Future { config Req : = & configurations Future { } config Req . init ( ) select { case < - r . shutdown Ch : config Req . respond ( Err Raft Shutdown ) return config Req case r . configurations Ch < - config Req : return config Req } } 
func ( r * Raft ) Add Peer ( peer Server Address ) Future { if r . protocol Version > 2 { return error Future { Err Unsupported Protocol } } return r . request Config Change ( configuration Change Request { command : Add Staging , server ID : Server ID ( peer ) , server Address : peer , prev Index : 0 , } , 0 ) } 
func ( r * Raft ) Remove Peer ( peer Server Address ) Future { if r . protocol Version > 2 { return error Future { Err Unsupported Protocol } } return r . request Config Change ( configuration Change Request { command : Remove Server , server ID : Server ID ( peer ) , prev Index : 0 , } , 0 ) } 
func ( r * Raft ) Add Voter ( id Server ID , address Server Address , prev Index uint 6 4 , timeout time . Duration ) Index Future { if r . protocol Version < 2 { return error Future { Err Unsupported Protocol } } return r . request Config Change ( configuration Change Request { command : Add Staging , server ID : id , server Address : address , prev Index : prev Index , } , timeout ) } 
func ( r * Raft ) Remove Server ( id Server ID , prev Index uint 6 4 , timeout time . Duration ) Index Future { if r . protocol Version < 2 { return error Future { Err Unsupported Protocol } } return r . request Config Change ( configuration Change Request { command : Remove Server , server ID : id , prev Index : prev Index , } , timeout ) } 
func ( r * Raft ) Shutdown ( ) Future { r . shutdown Lock . Lock ( ) defer r . shutdown Lock . Unlock ( ) if ! r . shutdown { close ( r . shutdown Ch ) r . shutdown = true r . set State ( Shutdown ) return & shutdown Future { r } } } 
func ( r * Raft ) Snapshot ( ) Snapshot Future { future : = & user Snapshot Future { } future . init ( ) select { case r . user Snapshot Ch < - future : return future case < - r . shutdown Ch : future . respond ( Err Raft Shutdown ) return future } } 
func ( r * Raft ) Restore ( meta * Snapshot Meta , reader io . Reader , timeout time . Duration ) error { metrics . Incr Counter ( [ ] string { " " , " " } , 1 ) var timer < - chan time . Time if timeout > 0 { timer = time . After ( timeout ) } restore . init ( ) select { case < - timer : return Err Enqueue Timeout case < - r . shutdown Ch : return Err Raft Shutdown case r . user Restore Ch < - restore : } } noop . init ( ) select { case < - timer : return Err Enqueue Timeout case < - r . shutdown Ch : return Err Raft Shutdown case r . apply Ch < - noop : return noop . Error ( ) } } 
func ( r * Raft ) String ( ) string { return fmt . Sprintf ( " " , r . local Addr , r . get State ( ) ) } 
func ( r * Raft ) Last Contact ( ) time . Time { r . last Contact Lock . RLock ( ) last : = r . last Contact r . last Contact Lock . RUnlock ( ) return last } 
func ( r * Raft ) Stats ( ) map [ string ] string { to String : = func ( v uint 6 4 ) string { return strconv . Format Uint ( v , 1 0 ) } last Log Index , last Log Term : = r . get Last Log ( ) last Snap Index , last Snap Term : = r . get Last Snapshot ( ) s : = map [ string ] string { " " : r . get State ( ) . String ( ) , " " : to String ( r . get Current Term ( ) ) , " " : to String ( last Log Index ) , " " : to String ( last Log Term ) , " " : to String ( r . get Commit Index ( ) ) , " " : to String ( r . get Last Applied ( ) ) , " " : to String ( uint 6 4 ( len ( r . fsm Mutate Ch ) ) ) , " " : to String ( last Snap Index ) , " " : to String ( last Snap Term ) , " " : to String ( uint 6 4 ( r . protocol Version ) ) , " " : to String ( uint 6 4 ( Protocol Version Min ) ) , " " : to String ( uint 6 4 ( Protocol Version Max ) ) , " " : to String ( uint 6 4 ( Snapshot Version Min ) ) , " " : to String ( uint 6 4 ( Snapshot Version Max ) ) , } future : = r . Get Configuration ( ) if err : = future . Error ( ) ; err ! = nil { r . logger . Warn ( fmt . Sprintf ( " " , err ) ) } else { configuration : = future . Configuration ( ) s [ " " ] = to String ( future . Index ( ) ) s [ " " ] = fmt . Sprintf ( " " , configuration . Servers ) num Peers : = 0 for _ , server : = range configuration . Servers { if server . Suffrage = = Voter { if server . ID = = r . local ID { has Us = true } else { num Peers + + } } } if ! has Us { num Peers = 0 } s [ " " ] = to String ( uint 6 4 ( num Peers ) ) } last : = r . Last Contact ( ) if r . get State ( ) = = Leader { s [ " " ] = " " } else if last . Is Zero ( ) { s [ " " ] = " " } else { s [ " " ] = fmt . Sprintf ( " " , time . Now ( ) . Sub ( last ) ) } return s } 
func ( a * Logger Adapter ) Logf ( s string , v . . . interface { } ) { a . log . Printf ( s , v . . . ) } 
func ( c * cluster ) Leader ( timeout time . Duration ) * raft Node { start : = time . Now ( ) for true { for _ , n : = range c . nodes { if n . raft . State ( ) = = raft . Leader { return n } } if time . Now ( ) . Sub ( start ) > timeout { return nil } time . Sleep ( time . Millisecond ) } return nil } 
func contains Node ( nodes [ ] * raft Node , n * raft Node ) bool { for _ , rn : = range nodes { if rn = = n { return true } } return false } 
func ( c * cluster ) Leader Plus ( n int ) [ ] * raft Node { r : = make ( [ ] * raft Node , 0 , n + 1 ) ldr : = c . Leader ( time . Second ) if ldr ! = nil { r = append ( r , ldr ) } if len ( r ) > = n { return r } for _ , node : = range c . nodes { if ! contains Node ( r , node ) { r = append ( r , node ) if len ( r ) > = n { return r } } } return r } 
func ( c * cluster ) Wait Til Upto Date ( t * testing . T , max Wait time . Duration ) { idx : = c . last Apply Success . Index ( ) start : = time . Now ( ) for true { all At Idx : = true for i : = 0 ; i < len ( c . nodes ) ; i + + { node Applied Idx : = c . nodes [ i ] . raft . Applied Index ( ) if node Applied Idx < idx { all At Idx = false break } else if node Applied Idx > idx { all At Idx = false idx = node Applied Idx break } } if all At Idx { t . Logf ( " " , idx ) return } if time . Now ( ) . Sub ( start ) > max Wait { t . Fatalf ( " " , idx , c . applied Indexes ( ) ) } time . Sleep ( time . Millisecond * 1 0 ) } } 
func assert Log Entry Equal ( t * testing . T , node string , exp * raft . Log , act * raft . Log ) bool { res : = true if exp . Term ! = act . Term { t . Errorf ( " " , exp . Index , node , exp . Term , act . Term ) res = false } if exp . Index ! = act . Index { t . Errorf ( " " , node , exp . Index , act . Index ) res = false } if exp . Type ! = act . Type { t . Errorf ( " " , node , exp . Index , exp . Type , act . Type ) res = false } if ! bytes . Equal ( exp . Data , act . Data ) { t . Errorf ( " " , node , exp . Index , exp . Data , act . Data ) res = false } return res } 
func ( r * Raft ) run FSM ( ) { var last Index , last Term uint 6 4 commit : = func ( req * commit Tuple ) { if req . log . Type = = Log Command { start : = time . Now ( ) resp = r . fsm . Apply ( req . log ) metrics . Measure Since ( [ ] string { " " , " " , " " } , start ) } last Term = req . log . Term req . future . respond ( nil ) } } restore : = func ( req * restore Future ) { if err ! = nil { req . respond ( fmt . Errorf ( " " , req . ID , err ) ) return } if err : = r . fsm . Restore ( source ) ; err ! = nil { req . respond ( fmt . Errorf ( " " , req . ID , err ) ) source . Close ( ) return } source . Close ( ) metrics . Measure Since ( [ ] string { " " , " " , " " } , start ) last Term = meta . Term req . respond ( nil ) } snapshot : = func ( req * req Snapshot Future ) { return } snap , err : = r . fsm . Snapshot ( ) metrics . Measure Since ( [ ] string { " " , " " , " " } , start ) req . term = last Term req . snapshot = snap req . respond ( err ) } for { select { case ptr : = < - r . fsm Mutate Ch : switch req : = ptr . ( type ) { case * commit Tuple : commit ( req ) case * restore Future : restore ( req ) default : panic ( fmt . Errorf ( " " , ptr ) ) } case req : = < - r . fsm Snapshot Ch : snapshot ( req ) case < - r . shutdown Ch : return } } } 
func ( c * Configuration ) Clone ( ) ( copy Configuration ) { copy . Servers = append ( copy . Servers , c . Servers . . . ) return } 
func ( c * configurations ) Clone ( ) ( copy configurations ) { copy . committed = c . committed . Clone ( ) copy . committed Index = c . committed Index copy . latest = c . latest . Clone ( ) copy . latest Index = c . latest Index return } 
func has Vote ( configuration Configuration , id Server ID ) bool { for _ , server : = range configuration . Servers { if server . ID = = id { return server . Suffrage = = Voter } } return false } 
func check Configuration ( configuration Configuration ) error { id Set : = make ( map [ Server ID ] bool ) address Set : = make ( map [ Server Address ] bool ) var voters int for _ , server : = range configuration . Servers { if server . ID = = " " { return fmt . Errorf ( " " , configuration ) } if server . Address = = " " { return fmt . Errorf ( " " , server ) } if id Set [ server . ID ] { return fmt . Errorf ( " " , server . ID ) } id Set [ server . ID ] = true if address Set [ server . Address ] { return fmt . Errorf ( " " , server . Address ) } address Set [ server . Address ] = true if server . Suffrage = = Voter { voters + + } } if voters = = 0 { return fmt . Errorf ( " " , configuration ) } return nil } 
func next Configuration ( current Configuration , current Index uint 6 4 , change configuration Change Request ) ( Configuration , error ) { if change . prev Index > 0 & & change . prev Index ! = current Index { return Configuration { } , fmt . Errorf ( " " , change . prev Index , current Index ) } configuration : = current . Clone ( ) switch change . command { case Add Staging : found : = false for i , server : = range configuration . Servers { if server . ID = = change . server ID { if server . Suffrage = = Voter { configuration . Servers [ i ] . Address = change . server Address } else { configuration . Servers [ i ] = new Server } found = true break } } if ! found { configuration . Servers = append ( configuration . Servers , new Server ) } case Add Nonvoter : new Server : = Server { Suffrage : Nonvoter , ID : change . server ID , Address : change . server Address , } found : = false for i , server : = range configuration . Servers { if server . ID = = change . server ID { if server . Suffrage ! = Nonvoter { configuration . Servers [ i ] . Address = change . server Address } else { configuration . Servers [ i ] = new Server } found = true break } } if ! found { configuration . Servers = append ( configuration . Servers , new Server ) } case Demote Voter : for i , server : = range configuration . Servers { if server . ID = = change . server ID { configuration . Servers [ i ] . Suffrage = Nonvoter break } } case Remove Server : for i , server : = range configuration . Servers { if server . ID = = change . server ID { configuration . Servers = append ( configuration . Servers [ : i ] , configuration . Servers [ i + 1 : ] . . . ) break } } case Promote : for i , server : = range configuration . Servers { if server . ID = = change . server ID & & server . Suffrage = = Staging { configuration . Servers [ i ] . Suffrage = Voter break } } } } return configuration , nil } 
func encode Peers ( configuration Configuration , trans Transport ) [ ] byte { for _ , server : = range configuration . Servers { if server . Suffrage = = Voter { enc Peers = append ( enc Peers , trans . Encode Peer ( server . ID , server . Address ) ) } } if err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } return buf . Bytes ( ) } 
func decode Peers ( buf [ ] byte , trans Transport ) Configuration { if err : = decode Msg Pack ( buf , & enc Peers ) ; err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } for _ , enc : = range enc Peers { p : = trans . Decode Peer ( enc ) servers = append ( servers , Server { Suffrage : Voter , ID : Server ID ( p ) , Address : Server Address ( p ) , } ) } return Configuration { Servers : servers , } } 
func encode Configuration ( configuration Configuration ) [ ] byte { buf , err : = encode Msg Pack ( configuration ) if err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } return buf . Bytes ( ) } 
func decode Configuration ( buf [ ] byte ) Configuration { var configuration Configuration if err : = decode Msg Pack ( buf , & configuration ) ; err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } return configuration } 
func ( r * raft State ) go Func ( f func ( ) ) { r . routines Group . Add ( 1 ) go func ( ) { defer r . routines Group . Done ( ) f ( ) } ( ) } 
func ( r * raft State ) get Last Index ( ) uint 6 4 { r . last Lock . Lock ( ) defer r . last Lock . Unlock ( ) return max ( r . last Log Index , r . last Snapshot Index ) } 
func ( r * raft State ) get Last Entry ( ) ( uint 6 4 , uint 6 4 ) { r . last Lock . Lock ( ) defer r . last Lock . Unlock ( ) if r . last Log Index > = r . last Snapshot Index { return r . last Log Index , r . last Log Term } return r . last Snapshot Index , r . last Snapshot Term } 
func resolve Directory ( dir string , create bool ) ( string , error ) { var resolved string if filepath . Is Abs ( dir ) { resolved = dir } else { execdir , err : = filepath . Abs ( filepath . Dir ( os . Args [ 0 ] ) ) if err ! = nil { return " " , err } resolved = filepath . Join ( execdir , dir ) } if create { if _ , err : = os . Stat ( resolved ) ; os . Is Not Exist ( err ) { if err : = os . Mkdir All ( resolved , 0 7 4 4 ) ; err ! = nil { return " " , err } } } return resolved , nil } 
func ( r * Raft ) check RPCHeader ( rpc RPC ) error { if ! ok { return fmt . Errorf ( " " ) } header : = wh . Get RPCHeader ( ) } } return nil } 
func ( r * Raft ) set Leader ( leader Server Address ) { r . leader Lock . Lock ( ) old Leader : = r . leader r . leader = leader r . leader Lock . Unlock ( ) if old Leader ! = leader { r . observe ( Leader Observation { leader : leader } ) } } 
func ( r * Raft ) request Config Change ( req configuration Change Request , timeout time . Duration ) Index Future { var timer < - chan time . Time if timeout > 0 { timer = time . After ( timeout ) } future : = & configuration Change Future { req : req , } future . init ( ) select { case < - timer : return error Future { Err Enqueue Timeout } case r . configuration Change Ch < - future : return future case < - r . shutdown Ch : return error Future { Err Raft Shutdown } } } 
func ( r * Raft ) run ( ) { for { return default : } case Candidate : r . run Candidate ( ) case Leader : r . run Leader ( ) } } } 
func ( r * Raft ) run Follower ( ) { did Warn : = false r . logger . Info ( fmt . Sprintf ( " " , r , r . Leader ( ) ) ) metrics . Incr Counter ( [ ] string { " " , " " , " " } , 1 ) heartbeat Timer : = random Timeout ( r . conf . Heartbeat Timeout ) for { select { case rpc : = < - r . rpc Ch : r . process RPC ( rpc ) case c : = < - r . configuration Change Ch : case a : = < - r . apply Ch : case v : = < - r . verify Ch : case r : = < - r . user Restore Ch : case c : = < - r . configurations Ch : c . configurations = r . configurations . Clone ( ) c . respond ( nil ) case b : = < - r . bootstrap Ch : b . respond ( r . live Bootstrap ( b . configuration ) ) case < - heartbeat Timer : if time . Now ( ) . Sub ( last Contact ) < r . conf . Heartbeat Timeout { continue } r . set Leader ( " " ) if r . configurations . latest Index = = 0 { if ! did Warn { r . logger . Warn ( " " ) did Warn = true } } else if r . configurations . latest Index = = r . configurations . committed Index & & ! has Vote ( r . configurations . latest , r . local ID ) { if ! did Warn { r . logger . Warn ( " " ) did Warn = true } } else { r . logger . Warn ( fmt . Sprintf ( " " , last Leader ) ) metrics . Incr Counter ( [ ] string { " " , " " , " " } , 1 ) r . set State ( Candidate ) return } case < - r . shutdown Ch : return } } } 
func ( r * Raft ) live Bootstrap ( configuration Configuration ) error { if err ! = nil { return err } if err : = r . logs . Get Log ( 1 , & entry ) ; err ! = nil { panic ( err ) } r . set Current Term ( 1 ) r . set Last Log ( entry . Index , entry . Term ) r . process Configuration Log Entry ( & entry ) return nil } 
func ( r * Raft ) run Candidate ( ) { r . logger . Info ( fmt . Sprintf ( " " , r , r . get Current Term ( ) + 1 ) ) metrics . Incr Counter ( [ ] string { " " , " " , " " } , 1 ) election Timer : = random Timeout ( r . conf . Election Timeout ) votes Needed : = r . quorum Size ( ) r . logger . Debug ( fmt . Sprintf ( " " , votes Needed ) ) for r . get State ( ) = = Candidate { select { case rpc : = < - r . rpc Ch : r . process RPC ( rpc ) case vote : = < - vote Ch : r . set State ( Follower ) r . set Current Term ( vote . Term ) return } r . logger . Debug ( fmt . Sprintf ( " " , vote . voter ID , vote . Term , granted Votes ) ) } r . set State ( Leader ) r . set Leader ( r . local Addr ) return } case c : = < - r . configuration Change Ch : case a : = < - r . apply Ch : case v : = < - r . verify Ch : case r : = < - r . user Restore Ch : case c : = < - r . configurations Ch : c . configurations = r . configurations . Clone ( ) c . respond ( nil ) case b : = < - r . bootstrap Ch : b . respond ( Err Cant Bootstrap ) case < - election Timer : return case < - r . shutdown Ch : return } } } 
func ( r * Raft ) run Leader ( ) { r . logger . Info ( fmt . Sprintf ( " " , r ) ) metrics . Incr Counter ( [ ] string { " " , " " , " " } , 1 ) } r . leader State . commitment = new Commitment ( r . leader State . commit Ch , r . configurations . latest , r . get Last Index ( ) + 1 ) r . leader State . inflight = list . New ( ) r . leader State . repl State = make ( map [ Server ID ] * follower Replication ) r . leader State . notify = make ( map [ * verify Future ] struct { } ) r . leader State . step Down = make ( chan struct { } , 1 ) } } } r . leader State . commitment = nil r . leader State . inflight = nil r . leader State . repl State = nil r . leader State . notify = nil r . leader State . step Down = nil if r . leader = = r . local Addr { r . leader = " " } r . leader Lock . Unlock ( ) } } } ( ) r . dispatch Logs ( [ ] * log Future { noop } ) } 
func ( r * Raft ) start Stop Replication ( ) { in Config : = make ( map [ Server ID ] bool , len ( r . configurations . latest . Servers ) ) last Idx : = r . get Last Index ( ) } in Config [ server . ID ] = true if _ , ok : = r . leader State . repl State [ server . ID ] ; ! ok { r . logger . Info ( fmt . Sprintf ( " " , server . ID ) ) s : = & follower Replication { peer : server , commitment : r . leader State . commitment , stop Ch : make ( chan uint 6 4 , 1 ) , trigger Ch : make ( chan struct { } , 1 ) , current Term : r . get Current Term ( ) , next Index : last Idx + 1 , last Contact : time . Now ( ) , notify : make ( map [ * verify Future ] struct { } ) , notify Ch : make ( chan struct { } , 1 ) , step Down : r . leader State . step Down , } r . leader State . repl State [ server . ID ] = s r . go Func ( func ( ) { r . replicate ( s ) } ) async Notify Ch ( s . trigger Ch ) } } } repl . stop Ch < - last Idx close ( repl . stop Ch ) delete ( r . leader State . repl State , server ID ) } } 
func ( r * Raft ) configuration Change Ch If Stable ( ) chan * configuration Change Future { } return nil } 
func ( r * Raft ) leader Loop ( ) { lease : = time . After ( r . conf . Leader Lease Timeout ) for r . get State ( ) = = Leader { select { case rpc : = < - r . rpc Ch : r . process RPC ( rpc ) case < - r . leader State . step Down : r . set State ( Follower ) case < - r . leader State . commit Ch : commit Index : = r . leader State . commitment . get Commit Index ( ) r . set Commit Index ( commit Index ) if r . configurations . latest Index > old Commit Index & & r . configurations . latest Index < = commit Index { r . configurations . committed = r . configurations . latest r . configurations . committed Index = r . configurations . latest Index if ! has Vote ( r . configurations . committed , r . local ID ) { step Down = true } } var num Processed int start : = time . Now ( ) for { e : = r . leader State . inflight . Front ( ) if e = = nil { break } commit Log : = e . Value . ( * log Future ) idx : = commit Log . log . Index if idx > commit Index { break } r . process Logs ( idx , commit Log ) r . leader State . inflight . Remove ( e ) num Processed + + } if step Down { if r . conf . Shutdown On Remove { r . logger . Info ( " " ) r . Shutdown ( ) } else { r . logger . Info ( " " ) r . set State ( Follower ) } } case v : = < - r . verify Ch : if v . quorum Size = = 0 { } else if v . votes < v . quorum Size { r . set State ( Follower ) delete ( r . leader State . notify , v ) for _ , repl : = range r . leader State . repl State { repl . clean Notify ( v ) } v . respond ( Err Not Leader ) } else { for _ , repl : = range r . leader State . repl State { repl . clean Notify ( v ) } v . respond ( nil ) } case future : = < - r . user Restore Ch : err : = r . restore User Snapshot ( future . meta , future . reader ) future . respond ( err ) case c : = < - r . configurations Ch : c . configurations = r . configurations . Clone ( ) c . respond ( nil ) case future : = < - r . configuration Change Ch If Stable ( ) : r . append Configuration Entry ( future ) case b : = < - r . bootstrap Ch : b . respond ( Err Cant Bootstrap ) case new Log : = < - r . apply Ch : for i : = 0 ; i < r . conf . Max Append Entries ; i + + { select { case new Log : = < - r . apply Ch : ready = append ( ready , new Log ) default : break } } } } else { r . dispatch Logs ( ready ) } case < - lease : if check Interval < min Check Interval { check Interval = min Check Interval } case < - r . shutdown Ch : return } } } 
func ( r * Raft ) verify Leader ( v * verify Future ) { if v . quorum Size = = 1 { v . respond ( nil ) return } r . leader State . notify [ v ] = struct { } { } repl . notify [ v ] = struct { } { } repl . notify Lock . Unlock ( ) async Notify Ch ( repl . notify Ch ) } } 
func ( r * Raft ) check Leader Lease ( ) time . Duration { now : = time . Now ( ) for peer , f : = range r . leader State . repl State { diff : = now . Sub ( f . Last Contact ( ) ) if diff < = r . conf . Leader Lease Timeout { contacted + + if diff > max Diff { max Diff = diff } } else { } else { r . logger . Debug ( fmt . Sprintf ( " " , peer , diff ) ) } } metrics . Add Sample ( [ ] string { " " , " " , " " } , float 3 2 ( diff / time . Millisecond ) ) } if contacted < quorum { r . logger . Warn ( " " ) r . set State ( Follower ) metrics . Incr Counter ( [ ] string { " " , " " , " " } , 1 ) } return max Diff } 
func ( r * Raft ) quorum Size ( ) int { voters : = 0 for _ , server : = range r . configurations . latest . Servers { if server . Suffrage = = Voter { voters + + } } return voters / 2 + 1 } 
func ( r * Raft ) restore User Snapshot ( meta * Snapshot Meta , reader io . Reader ) error { defer metrics . Measure Since ( [ ] string { " " , " " } , time . Now ( ) ) if version < Snapshot Version Min | | version > Snapshot Version Max { return fmt . Errorf ( " " , version ) } latest Index : = r . configurations . latest Index if committed Index ! = latest Index { return fmt . Errorf ( " " , latest Index , committed Index ) } if e = = nil { break } e . Value . ( * log Future ) . respond ( Err Aborted By Restore ) r . leader State . inflight . Remove ( e ) } last Index : = r . get Last Index ( ) if meta . Index > last Index { last Index = meta . Index } last Index + + if err ! = nil { return fmt . Errorf ( " " , err ) } n , err : = io . Copy ( sink , reader ) if err ! = nil { sink . Cancel ( ) return fmt . Errorf ( " " , err ) } if n ! = meta . Size { sink . Cancel ( ) return fmt . Errorf ( " " , n , meta . Size ) } if err : = sink . Close ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } r . logger . Info ( fmt . Sprintf ( " " , n ) ) fsm . init ( ) select { case r . fsm Mutate Ch < - fsm : case < - r . shutdown Ch : return Err Raft Shutdown } if err : = fsm . Error ( ) ; err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } r . set Last Applied ( last Index ) r . set Last Snapshot ( last Index , term ) r . logger . Info ( fmt . Sprintf ( " " , last Index ) ) return nil } 
func ( r * Raft ) append Configuration Entry ( future * configuration Change Future ) { configuration , err : = next Configuration ( r . configurations . latest , r . configurations . latest Index , future . req ) if err ! = nil { future . respond ( err ) return } r . logger . Info ( fmt . Sprintf ( " " , future . req . command , future . req . server ID , future . req . server Address , configuration . Servers ) ) } else { future . log = Log { Type : Log Configuration , Data : encode Configuration ( configuration ) , } } r . dispatch Logs ( [ ] * log Future { & future . log Future } ) index : = future . Index ( ) r . configurations . latest = configuration r . configurations . latest Index = index r . leader State . commitment . set Configuration ( configuration ) r . start Stop Replication ( ) } 
func ( r * Raft ) dispatch Logs ( apply Logs [ ] * log Future ) { now : = time . Now ( ) defer metrics . Measure Since ( [ ] string { " " , " " , " " } , now ) term : = r . get Current Term ( ) last Index : = r . get Last Index ( ) n : = len ( apply Logs ) logs : = make ( [ ] * Log , n ) metrics . Set Gauge ( [ ] string { " " , " " , " " } , float 3 2 ( n ) ) for idx , apply Log : = range apply Logs { apply Log . dispatch = now last Index + + apply Log . log . Index = last Index apply Log . log . Term = term logs [ idx ] = & apply Log . log r . leader State . inflight . Push Back ( apply Log ) } for _ , apply Log : = range apply Logs { apply Log . respond ( err ) } r . set State ( Follower ) return } r . leader State . commitment . match ( r . local ID , last Index ) } } 
func ( r * Raft ) process Logs ( index uint 6 4 , future * log Future ) { if index < = last Applied { r . logger . Warn ( fmt . Sprintf ( " " , index ) ) return } } else { l : = new ( Log ) if err : = r . logs . Get Log ( idx , l ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , idx , err ) ) panic ( err ) } r . process Log ( l , nil ) } } } 
func ( r * Raft ) process Log ( l * Log , future * log Future ) { switch l . Type { case Log Barrier : case Log Command : } } case Log Configuration : case Log Add Peer Deprecated : case Log Remove Peer Deprecated : case Log Noop : } } } 
func ( r * Raft ) process RPC ( rpc RPC ) { if err : = r . check RPCHeader ( rpc ) ; err ! = nil { rpc . Respond ( nil , err ) return } switch cmd : = rpc . Command . ( type ) { case * Append Entries Request : r . append Entries ( rpc , cmd ) case * Request Vote Request : r . request Vote ( rpc , cmd ) case * Install Snapshot Request : r . install Snapshot ( rpc , cmd ) default : r . logger . Error ( fmt . Sprintf ( " " , rpc . Command ) ) rpc . Respond ( nil , fmt . Errorf ( " " ) ) } } 
func ( r * Raft ) process Heartbeat ( rpc RPC ) { defer metrics . Measure Since ( [ ] string { " " , " " , " " } , time . Now ( ) ) default : } default : r . logger . Error ( fmt . Sprintf ( " " , rpc . Command ) ) rpc . Respond ( nil , fmt . Errorf ( " " ) ) } } 
func ( r * Raft ) append Entries ( rpc RPC , a * Append Entries Request ) { defer metrics . Measure Since ( [ ] string { " " , " " , " " } , time . Now ( ) ) var rpc Err error defer func ( ) { rpc . Respond ( resp , rpc Err ) } ( ) } r . set Current Term ( a . Term ) resp . Term = a . Term } var prev Log Term uint 6 4 if a . Prev Log Entry = = last Idx { prev Log Term = last Term } else { var prev Log Log if err : = r . logs . Get Log ( a . Prev Log Entry , & prev Log ) ; err ! = nil { r . logger . Warn ( fmt . Sprintf ( " " , a . Prev Log Entry , err , last Idx ) ) resp . No Retry Backoff = true return } prev Log Term = prev Log . Term } if a . Prev Log Term ! = prev Log Term { r . logger . Warn ( fmt . Sprintf ( " " , prev Log Term , a . Prev Log Term ) ) resp . No Retry Backoff = true return } } var new Entries [ ] * Log for i , entry : = range a . Entries { if entry . Index > last Log Idx { new Entries = a . Entries [ i : ] break } var store Entry Log if err : = r . logs . Get Log ( entry . Index , & store Entry ) ; err ! = nil { r . logger . Warn ( fmt . Sprintf ( " " , entry . Index , err ) ) return } if entry . Term ! = store Entry . Term { r . logger . Warn ( fmt . Sprintf ( " " , entry . Index , last Log Idx ) ) if err : = r . logs . Delete Range ( entry . Index , last Log Idx ) ; err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , err ) ) return } if entry . Index < = r . configurations . latest Index { r . configurations . latest = r . configurations . committed r . configurations . latest Index = r . configurations . committed Index } new Entries = a . Entries [ i : ] break } } if n : = len ( new Entries ) ; n > 0 { } } r . set Last Log ( last . Index , last . Term ) } metrics . Measure Since ( [ ] string { " " , " " , " " , " " } , start ) } idx : = min ( a . Leader Commit Index , r . get Last Index ( ) ) r . set Commit Index ( idx ) if r . configurations . latest Index < = idx { r . configurations . committed = r . configurations . latest r . configurations . committed Index = r . configurations . latest Index } r . process Logs ( idx , nil ) metrics . Measure Since ( [ ] string { " " , " " , " " , " " } , start ) } r . set Last Contact ( ) return } 
func ( r * Raft ) process Configuration Log Entry ( entry * Log ) { if entry . Type = = Log Configuration { r . configurations . committed = r . configurations . latest r . configurations . committed Index = r . configurations . latest Index r . configurations . latest = decode Configuration ( entry . Data ) r . configurations . latest Index = entry . Index } else if entry . Type = = Log Add Peer Deprecated | | entry . Type = = Log Remove Peer Deprecated { r . configurations . committed = r . configurations . latest r . configurations . committed Index = r . configurations . latest Index r . configurations . latest = decode Peers ( entry . Data , r . trans ) r . configurations . latest Index = entry . Index } } 
func ( r * Raft ) request Vote ( rpc RPC , req * Request Vote Request ) { defer metrics . Measure Since ( [ ] string { " " , " " , " " } , time . Now ( ) ) r . observe ( * req ) var rpc Err error defer func ( ) { rpc . Respond ( resp , rpc Err ) } ( ) } if leader : = r . Leader ( ) ; leader ! = " " & & leader ! = candidate { r . logger . Warn ( fmt . Sprintf ( " " , candidate , leader ) ) return } } r . set Current Term ( req . Term ) resp . Term = req . Term } if err ! = nil & & err . Error ( ) ! = " " { r . logger . Error ( fmt . Sprintf ( " " , err ) ) return } last Vote Cand Bytes , err : = r . stable . Get ( key Last Vote Cand ) if err ! = nil & & err . Error ( ) ! = " " { r . logger . Error ( fmt . Sprintf ( " " , err ) ) return } if bytes . Compare ( last Vote Cand Bytes , req . Candidate ) = = 0 { r . logger . Warn ( fmt . Sprintf ( " " , req . Candidate ) ) resp . Granted = true } return } if last Term > req . Last Log Term { r . logger . Warn ( fmt . Sprintf ( " " , candidate , last Term , req . Last Log Term ) ) return } if last Term = = req . Last Log Term & & last Idx > req . Last Log Index { r . logger . Warn ( fmt . Sprintf ( " " , candidate , last Idx , req . Last Log Index ) ) return } return } resp . Granted = true r . set Last Contact ( ) return } 
func ( r * Raft ) install Snapshot ( rpc RPC , req * Install Snapshot Request ) { defer metrics . Measure Since ( [ ] string { " " , " " , " " } , time . Now ( ) ) var rpc Err error defer func ( ) { io . Copy ( ioutil . Discard , rpc . Reader ) rpc . Respond ( resp , rpc Err ) } ( ) return } return } r . set Current Term ( req . Term ) resp . Term = req . Term } var req Configuration Index uint 6 4 if req . Snapshot Version > 0 { req Configuration = decode Configuration ( req . Configuration ) req Configuration Index = req . Configuration Index } else { req Configuration = decode Peers ( req . Peers , r . trans ) req Configuration Index = req . Last Log Index } version : = get Snapshot Version ( r . protocol Version ) sink , err : = r . snapshots . Create ( version , req . Last Log Index , req . Last Log Term , req Configuration , req Configuration Index , r . trans ) if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , err ) ) rpc Err = fmt . Errorf ( " " , err ) return } if err ! = nil { sink . Cancel ( ) r . logger . Error ( fmt . Sprintf ( " " , err ) ) rpc Err = err return } r . logger . Error ( fmt . Sprintf ( " " , n , req . Size ) ) rpc Err = fmt . Errorf ( " " ) return } rpc Err = err return } r . logger . Info ( fmt . Sprintf ( " " , n ) ) future . init ( ) select { case r . fsm Mutate Ch < - future : case < - r . shutdown Ch : future . respond ( Err Raft Shutdown ) return } rpc Err = err return } r . configurations . latest Index = req Configuration Index r . configurations . committed = req Configuration r . configurations . committed Index = req Configuration Index } r . logger . Info ( " " ) resp . Success = true r . set Last Contact ( ) return } 
func ( r * Raft ) set Last Contact ( ) { r . last Contact Lock . Lock ( ) r . last Contact = time . Now ( ) r . last Contact Lock . Unlock ( ) } 
func ( r * Raft ) elect Self ( ) < - chan * vote Result { req : = & Request Vote Request { RPCHeader : r . get RPCHeader ( ) , Term : r . get Current Term ( ) , Candidate : r . trans . Encode Peer ( r . local ID , r . local Addr ) , Last Log Index : last Idx , Last Log Term : last Term , } resp : = & vote Result { voter ID : peer . ID } err : = r . trans . Request Vote ( peer . ID , peer . Address , req , & resp . Request Vote Response ) if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , peer , err ) ) resp . Term = req . Term resp . Granted = false } resp Ch < - resp } ) } return nil } } else { ask Peer ( server ) } } } return resp Ch } 
func ( r * Raft ) persist Vote ( term uint 6 4 , candidate [ ] byte ) error { if err : = r . stable . Set Uint 6 4 ( key Last Vote Term , term ) ; err ! = nil { return err } if err : = r . stable . Set ( key Last Vote Cand , candidate ) ; err ! = nil { return err } return nil } 
func ( r * Raft ) set Current Term ( t uint 6 4 ) { } r . raft State . set Current Term ( t ) } 
func ( r * Raft ) set State ( state Raft State ) { r . set Leader ( " " ) old State : = r . raft State . get State ( ) r . raft State . set State ( state ) if old State ! = state { r . observe ( state ) } } 
func new Commitment ( commit Ch chan struct { } , configuration Configuration , start Index uint 6 4 ) * commitment { match Indexes : = make ( map [ Server ID ] uint 6 4 ) for _ , server : = range configuration . Servers { if server . Suffrage = = Voter { match Indexes [ server . ID ] = 0 } } return & commitment { commit Ch : commit Ch , match Indexes : match Indexes , commit Index : 0 , start Index : start Index , } } 
func ( c * commitment ) set Configuration ( configuration Configuration ) { c . Lock ( ) defer c . Unlock ( ) old Match Indexes : = c . match Indexes c . match Indexes = make ( map [ Server ID ] uint 6 4 ) for _ , server : = range configuration . Servers { if server . Suffrage = = Voter { c . match Indexes [ server . ID ] = old Match Indexes [ server . ID ] } } c . recalculate ( ) } 
func ( c * commitment ) get Commit Index ( ) uint 6 4 { c . Lock ( ) defer c . Unlock ( ) return c . commit Index } 
func ( c * commitment ) match ( server Server ID , match Index uint 6 4 ) { c . Lock ( ) defer c . Unlock ( ) if prev , has Vote : = c . match Indexes [ server ] ; has Vote & & match Index > prev { c . match Indexes [ server ] = match Index c . recalculate ( ) } } 
func ( c * commitment ) recalculate ( ) { if len ( c . match Indexes ) = = 0 { return } matched : = make ( [ ] uint 6 4 , 0 , len ( c . match Indexes ) ) for _ , idx : = range c . match Indexes { matched = append ( matched , idx ) } sort . Sort ( uint 6 4Slice ( matched ) ) quorum Match Index : = matched [ ( len ( matched ) - 1 ) / 2 ] if quorum Match Index > c . commit Index & & quorum Match Index > = c . start Index { c . commit Index = quorum Match Index async Notify Ch ( c . commit Ch ) } } 
func new Seed ( ) int 6 4 { r , err : = crand . Int ( crand . Reader , big . New Int ( math . Max Int 6 4 ) ) if err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } return r . Int 6 4 ( ) } 
func random Timeout ( min Val time . Duration ) < - chan time . Time { if min Val = = 0 { return nil } extra : = ( time . Duration ( rand . Int 6 3 ( ) ) % min Val ) return time . After ( min Val + extra ) } 
func generate UUID ( ) string { buf : = make ( [ ] byte , 1 6 ) if _ , err : = crand . Read ( buf ) ; err ! = nil { panic ( fmt . Errorf ( " " , err ) ) } return fmt . Sprintf ( " " , buf [ 0 : 4 ] , buf [ 4 : 6 ] , buf [ 6 : 8 ] , buf [ 8 : 1 0 ] , buf [ 1 0 : 1 6 ] ) } 
func decode Msg Pack ( buf [ ] byte , out interface { } ) error { r : = bytes . New Buffer ( buf ) hd : = codec . Msgpack Handle { } dec : = codec . New Decoder ( r , & hd ) return dec . Decode ( out ) } 
func encode Msg Pack ( in interface { } ) ( * bytes . Buffer , error ) { buf : = bytes . New Buffer ( nil ) hd : = codec . Msgpack Handle { } enc : = codec . New Encoder ( buf , & hd ) err : = enc . Encode ( in ) return buf , err } 
func backoff ( base time . Duration , round , limit uint 6 4 ) time . Duration { power : = min ( round , limit ) for power > 2 { base * = 2 power - - } return base } 
func new Apply Source ( seed string ) * apply Source { h : = fnv . New 3 2 ( ) h . Write ( [ ] byte ( seed ) ) s : = & apply Source { seed : int 6 4 ( h . Sum 3 2 ( ) ) } s . reset ( ) return s } 
func ( a * apply Source ) reset ( ) { a . rnd = rand . New ( rand . New Source ( a . seed ) ) } 
func ( a * apply Source ) apply ( t * testing . T , c * cluster , n uint ) * cluster Applier { ap : = & cluster Applier { stop Ch : make ( chan bool ) , src : a } go ap . apply ( t , c , n ) return ap } 
func Default Config ( ) * Config { return & Config { Protocol Version : Protocol Version Max , Heartbeat Timeout : 1 0 0 0 * time . Millisecond , Election Timeout : 1 0 0 0 * time . Millisecond , Commit Timeout : 5 0 * time . Millisecond , Max Append Entries : 6 4 , Shutdown On Remove : true , Trailing Logs : 1 0 2 4 0 , Snapshot Interval : 1 2 0 * time . Second , Snapshot Threshold : 8 1 9 2 , Leader Lease Timeout : 5 0 0 * time . Millisecond , Log Level : " " , } } 
func Validate Config ( config * Config ) error { if protocol Min = = 0 { protocol Min = 1 } if config . Protocol Version < protocol Min | | config . Protocol Version > Protocol Version Max { return fmt . Errorf ( " " , config . Protocol Version , protocol Min , Protocol Version Max ) } if len ( config . Local ID ) = = 0 { return fmt . Errorf ( " " ) } if config . Heartbeat Timeout < 5 * time . Millisecond { return fmt . Errorf ( " " ) } if config . Election Timeout < 5 * time . Millisecond { return fmt . Errorf ( " " ) } if config . Commit Timeout < time . Millisecond { return fmt . Errorf ( " " ) } if config . Max Append Entries < = 0 { return fmt . Errorf ( " " ) } if config . Max Append Entries > 1 0 2 4 { return fmt . Errorf ( " " ) } if config . Snapshot Interval < 5 * time . Millisecond { return fmt . Errorf ( " " ) } if config . Leader Lease Timeout < 5 * time . Millisecond { return fmt . Errorf ( " " ) } if config . Leader Lease Timeout > config . Heartbeat Timeout { return fmt . Errorf ( " " ) } if config . Election Timeout < config . Heartbeat Timeout { return fmt . Errorf ( " " ) } return nil } 
func ( r * Raft ) run Snapshots ( ) { for { select { case < - random Timeout ( r . conf . Snapshot Interval ) : } } case future : = < - r . user Snapshot Ch : if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , err ) ) } else { future . opener = func ( ) ( * Snapshot Meta , io . Read Closer , error ) { return r . snapshots . Open ( id ) } } future . respond ( err ) case < - r . shutdown Ch : return } } } 
func ( r * Raft ) should Snapshot ( ) bool { if err ! = nil { r . logger . Error ( fmt . Sprintf ( " " , err ) ) return false } return delta > = r . conf . Snapshot Threshold } 
func ( r * Raft ) take Snapshot ( ) ( string , error ) { defer metrics . Measure Since ( [ ] string { " " , " " , " " } , time . Now ( ) ) snap Req . init ( ) } } return " " , err } defer snap Req . snapshot . Release ( ) config Req . init ( ) select { case r . configurations Ch < - config Req : case < - r . shutdown Ch : return " " , Err Raft Shutdown } if err : = config Req . Error ( ) ; err ! = nil { return " " , err } committed : = config Req . configurations . committed committed Index : = config Req . configurations . committed Index } start : = time . Now ( ) version : = get Snapshot Version ( r . protocol Version ) sink , err : = r . snapshots . Create ( version , snap Req . index , snap Req . term , committed , committed Index , r . trans ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } metrics . Measure Since ( [ ] string { " " , " " , " " } , start ) if err : = snap Req . snapshot . Persist ( sink ) ; err ! = nil { sink . Cancel ( ) return " " , fmt . Errorf ( " " , err ) } metrics . Measure Since ( [ ] string { " " , " " , " " } , start ) } } r . logger . Info ( fmt . Sprintf ( " " , snap Req . index ) ) return sink . ID ( ) , nil } 
func ( r * Raft ) compact Logs ( snap Idx uint 6 4 ) error { defer metrics . Measure Since ( [ ] string { " " , " " } , time . Now ( ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } if last Log Idx < = r . conf . Trailing Logs { return nil } } return nil } 
func Webpack Check ( r * Runner ) error { fmt . Println ( " " ) if ! r . App . With Webpack { return nil } box : = webpack . Templates f , err : = box . Find String ( " " ) if err ! = nil { return err } tmpl , err : = template . New ( " " ) . Parse ( f ) if err ! = nil { return err } bb : = & bytes . Buffer { } err = tmpl . Execute ( bb , map [ string ] interface { } { " " : & webpack . Options { App : r . App , } , } ) if err ! = nil { return err } b , err : = ioutil . Read File ( " " ) if err ! = nil { return err } if string ( b ) = = bb . String ( ) { return nil } if ! ask ( " \n " ) { fmt . Println ( " \t " ) return nil } wf , err : = os . Create ( " " ) if err ! = nil { return err } _ , err = wf . Write ( bb . Bytes ( ) ) if err ! = nil { return err } return wf . Close ( ) } 
func Auto ( ctx context . Context , i interface { } ) Renderer { e : = New ( Options { } ) return e . Auto ( ctx , i ) } 
func ( e * Engine ) Auto ( ctx context . Context , i interface { } ) Renderer { ct , _ : = ctx . Value ( " " ) . ( string ) if ct = = " " { ct = e . Default Content Type } ct = strings . Trim Space ( strings . To Lower ( ct ) ) if strings . Contains ( ct , " " ) { return e . JSON ( i ) } if strings . Contains ( ct , " " ) { return e . XML ( i ) } return html Auto Renderer { Engine : e , model : i , } } 
func ( opts * Options ) Validate ( ) error { if opts . Options = = nil { opts . Options = & core . Options { } } if err : = opts . Options . Validate ( ) ; err ! = nil { return err } if opts . Docker ! = nil { if opts . Docker . App . Is Zero ( ) { opts . Docker . App = opts . App } if err : = opts . Docker . Validate ( ) ; err ! = nil { return err } } if opts . Webpack ! = nil { if opts . Webpack . App . Is Zero ( ) { opts . Webpack . App = opts . App } if err : = opts . Webpack . Validate ( ) ; err ! = nil { return err } } if opts . Standard ! = nil & & opts . Webpack ! = nil { return errors . New ( " " ) } return nil } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } if opts . Provider = = " " { return g , nil } box : = packr . New ( " " , " " ) s , err : = box . Find String ( " " ) if err ! = nil { return g , err } p : = opts . Provider n : = fmt . Sprintf ( " " , p ) g . File ( genny . New File S ( n , s ) ) g . Command ( exec . Command ( p , " " ) ) args : = [ ] string { " " , " " } if p = = " " { } g . Command ( exec . Command ( p , args . . . ) ) g . Command ( exec . Command ( p , " " , " " , " " , " " ) ) return g , nil } 
func ( s * Listener ) Set Addr ( addr string ) { if s . Server . Addr = = " " { s . Server . Addr = addr } } 
func ( s * Listener ) Start ( c context . Context , h http . Handler ) error { s . Handler = h return s . Serve ( s . Listener ) } 
func Unix Socket ( addr string ) ( * Listener , error ) { listener , err : = net . Listen ( " " , addr ) if err ! = nil { return nil , err } return & Listener { Server : & http . Server { } , Listener : listener , } , nil } 
func ( e Error Handlers ) Get ( status int ) Error Handler { if eh , ok : = e [ status ] ; ok { return eh } if eh , ok : = e [ 0 ] ; ok { return eh } return default Error Handler } 
func ( a * App ) Panic Handler ( next Handler ) Handler { return func ( c Context ) error { defer func ( ) { var err error if r ! = nil { case string : err = errors . New ( t ) default : err = errors . New ( fmt . Sprint ( t ) ) } err = err events . Emit Error ( events . Err Panic , err , map [ string ] interface { } { " " : c , " " : a , } , ) eh : = a . Error Handlers . Get ( 5 0 0 ) eh ( 5 0 0 , err , c ) } } ( ) return next ( c ) } } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if len ( opts . Version ) = = 0 { opts . Version = runtime . Version } if len ( opts . Provider ) = = 0 { return errors . New ( " " ) } opts . Provider = strings . To Lower ( opts . Provider ) var found bool for _ , a : = range Available { if opts . Provider = = a { found = true break } if opts . Provider = = a + " " { opts . Provider = a found = true break } } if ! found { return fmt . Errorf ( " " , opts . Provider , strings . Join ( Available , " " ) ) } found = false for _ , d : = range pop . Available Dialects { if d = = opts . DBType { found = true break } } if ! found { return fmt . Errorf ( " " , opts . DBType , strings . Join ( pop . Available Dialects , " " ) ) } return nil } 
func Wrap TLS ( s * http . Server , cert File string , key File string ) Server { return & TLS { Server : s , Cert File : cert File , Key File : key File , } } 
func Wrap Listener ( s * http . Server , l net . Listener ) Server { return & Listener { Server : s , Listener : l , } } 
func ( s template Renderer ) partial Feeder ( name string ) ( string , error ) { ct : = strings . To Lower ( s . content Type ) d , f : = filepath . Split ( name ) name = filepath . Join ( d , " " + f ) name = fix Extension ( name , ct ) return s . Templates Box . Find String ( name ) } 
func Template ( c string , names . . . string ) Renderer { e : = New ( Options { } ) return e . Template ( c , names . . . ) } 
func ( e * Engine ) Template ( c string , names . . . string ) Renderer { return & template Renderer { Engine : e , content Type : c , names : names , } } 
func New ( opts Options ) * Engine { if opts . Helpers = = nil { opts . Helpers = map [ string ] interface { } { } } if opts . Template Engines = = nil { opts . Template Engines = map [ string ] Template Engine { } } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = plush . Buffalo Renderer } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = plush . Buffalo Renderer } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = plush . Buffalo Renderer } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = plush . Buffalo Renderer } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = MDTemplate Engine } if _ , ok : = opts . Template Engines [ " " ] ; ! ok { opts . Template Engines [ " " ] = Go Template Engine } if opts . Default Content Type = = " " { opts . Default Content Type = " " } e : = & Engine { Options : opts , } return e } 
func ( s * Simple ) Set Addr ( addr string ) { if s . Server . Addr = = " " { s . Server . Addr = addr } } 
func ( s * Simple ) Start ( c context . Context , h http . Handler ) error { s . Handler = h return s . Listen And Serve ( ) } 
func ( m * Message ) Write To ( w io . Writer ) ( int 6 4 , error ) { mw : = & message Writer { w : w } mw . write Message ( m ) return mw . n , mw . err } 
func App ( ) * buffalo . App { if app = = nil { app = buffalo . New ( buffalo . Options { Env : ENV , Session Name : " " , } ) app . GET ( " " , Home Handler ) app . Serve Files ( " " , assets Box ) } return app } 
func translations ( ) buffalo . Middleware Func { var err error if T , err = i 1 8n . New ( packr . New ( " " , " " ) , " " ) ; err ! = nil { app . Stop ( err ) } return T . Middleware ( ) } 
func force SSL ( ) buffalo . Middleware Func { return forcessl . Middleware ( secure . Options { SSLRedirect : ENV = = " " , SSLProxy Headers : map [ string ] string { " " : " " } , } ) } 
func ( sm SMTPSender ) Send ( message Message ) error { gm : = gomail . New Message ( ) gm . Set Header ( " " , message . From ) gm . Set Header ( " " , message . To . . . ) gm . Set Header ( " " , message . Subject ) gm . Set Header ( " " , message . CC . . . ) gm . Set Header ( " " , message . Bcc . . . ) sm . add Bodies ( message , gm ) sm . add Attachments ( message , gm ) for field , value : = range message . Headers { gm . Set Header ( field , value ) } err : = sm . Dialer . Dial And Send ( gm ) if err ! = nil { return err } return nil } 
func New SMTPSender ( host string , port string , user string , password string ) ( SMTPSender , error ) { iport , err : = strconv . Atoi ( port ) if err ! = nil { return SMTPSender { } , errors . New ( " " ) } dialer : = & gomail . Dialer { Host : host , Port : iport , } if user ! = " " { dialer . Username = user dialer . Password = password } return SMTPSender { Dialer : dialer , } , nil } 
func ( d * Default Context ) Param ( key string ) string { return d . Params ( ) . Get ( key ) } 
func ( d * Default Context ) Set ( key string , value interface { } ) { d . moot . Lock ( ) d . data [ key ] = value d . moot . Unlock ( ) } 
func ( d * Default Context ) Value ( key interface { } ) interface { } { if k , ok : = key . ( string ) ; ok { d . moot . RLock ( ) defer d . moot . RUnlock ( ) if v , ok : = d . data [ k ] ; ok { return v } } return d . Context . Value ( key ) } 
func ( d * Default Context ) Render ( status int , rr render . Renderer ) error { start : = time . Now ( ) defer func ( ) { d . Log Field ( " " , time . Since ( start ) ) } ( ) if rr ! = nil { data : = d . Data ( ) pp : = map [ string ] string { } for k , v : = range d . params { pp [ k ] = v [ 0 ] } data [ " " ] = pp data [ " " ] = d . Flash ( ) . data data [ " " ] = d . Session ( ) data [ " " ] = d . Request ( ) data [ " " ] = status bb : = & bytes . Buffer { } err : = rr . Render ( bb , data ) if err ! = nil { if er , ok : = errors . Cause ( err ) . ( render . Err Redirect ) ; ok { return d . Redirect ( er . Status , er . URL ) } return HTTPError { Status : 5 0 0 , Cause : err } } if d . Session ( ) ! = nil { d . Flash ( ) . Clear ( ) d . Flash ( ) . persist ( d . Session ( ) ) } d . Response ( ) . Header ( ) . Set ( " " , rr . Content Type ( ) ) if p , ok : = data [ " " ] . ( paginable ) ; ok { d . Response ( ) . Header ( ) . Set ( " " , p . Paginate ( ) ) } d . Response ( ) . Write Header ( status ) _ , err = io . Copy ( d . Response ( ) , bb ) if err ! = nil { return HTTPError { Status : 5 0 0 , Cause : err } } return nil } d . Response ( ) . Write Header ( status ) return nil } 
func ( d * Default Context ) Bind ( value interface { } ) error { return binding . Exec ( d . Request ( ) , value ) } 
func ( d * Default Context ) Log Field ( key string , value interface { } ) { d . logger = d . logger . With Field ( key , value ) } 
func ( d * Default Context ) Log Fields ( values map [ string ] interface { } ) { d . logger = d . logger . With Fields ( values ) } 
func ( d * Default Context ) Redirect ( status int , url string , args . . . interface { } ) error { d . Flash ( ) . persist ( d . Session ( ) ) if strings . Has Suffix ( url , " " ) { if len ( args ) > 1 { return fmt . Errorf ( " " , args ) } var m map [ string ] interface { } if len ( args ) = = 1 { rv : = reflect . Indirect ( reflect . Value Of ( args [ 0 ] ) ) if ! rv . Type ( ) . Convertible To ( map Type ) { return fmt . Errorf ( " " , args ) } m = rv . Convert ( map Type ) . Interface ( ) . ( map [ string ] interface { } ) } h , ok : = d . Value ( strings . Trim Suffix ( url , " " ) ) . ( Route Helper Func ) if ! ok { return fmt . Errorf ( " " , url ) } url , err : = h ( m ) if err ! = nil { return err } http . Redirect ( d . Response ( ) , d . Request ( ) , string ( url ) , status ) return nil } if len ( args ) > 0 { url = fmt . Sprintf ( url , args . . . ) } http . Redirect ( d . Response ( ) , d . Request ( ) , url , status ) return nil } 
func ( d * Default Context ) Data ( ) map [ string ] interface { } { d . moot . Lock ( ) m : = map [ string ] interface { } { } for k , v : = range d . data { m [ k ] = v } d . moot . Unlock ( ) return m } 
func ( d * Default Context ) File ( name string ) ( binding . File , error ) { req : = d . Request ( ) if err : = req . Parse Multipart Form ( 5 * 1 0 2 4 * 1 0 2 4 ) ; err ! = nil { return binding . File { } , err } f , h , err : = req . Form File ( name ) bf : = binding . File { File : f , File Header : h , } if err ! = nil { return bf , err } return bf , nil } 
func ( d * Default Context ) Marshal JSON ( ) ( [ ] byte , error ) { m : = map [ string ] interface { } { } data : = d . Data ( ) for k , v : = range data { } if _ , err : = json . Marshal ( v ) ; err = = nil { } } return json . Marshal ( m ) } 
func New ( opts * Options ) ( * genny . Group , error ) { gg : = & genny . Group { } if err ! = nil { return gg , err } gg . Add ( g ) app : = opts . App if app . With Modules { g , err : = gomods . Init ( app . Package Pkg , app . Root ) if err ! = nil { return gg , err } g . Command ( gogen . Get ( " " + runtime . Version ) ) g . Command ( gogen . Get ( " " ) ) gg . Add ( g ) } plugs , err : = plugdeps . List ( app ) if err ! = nil & & ( errors . Cause ( err ) ! = plugdeps . Err Missing Config ) { return nil , err } if opts . Docker ! = nil { if err ! = nil { return gg , err } gg . Add ( g ) } if opts . Pop ! = nil { if err ! = nil { return gg , err } gg . Merge ( gg 2 ) } if opts . CI ! = nil { if err ! = nil { return gg , err } gg . Add ( g ) } if opts . Refresh ! = nil { g , err = refresh . New ( opts . Refresh ) if err ! = nil { return gg , err } gg . Add ( g ) } if app . With SQLite { iopts . Tags = meta . Build Tags { " " } } ig , err : = install . New ( iopts ) if err ! = nil { return gg , err } gg . Merge ( ig ) if err ! = nil { return gg , err } gg . Add ( di ) } if ! app . With Dep & & ! app . With Modules { g : = genny . New ( ) g . Command ( gogen . Get ( " " , " " ) ) gg . Add ( g ) } if app . With Modules { g , err : = gomods . Tidy ( app . Root , false ) if err ! = nil { return gg , err } gg . Add ( g ) } return gg , nil } 
func New ( opts * Options ) ( * genny . Group , error ) { if err : = opts . Validate ( ) ; err ! = nil { return nil , err } gg , err : = core . New ( opts . Options ) if err ! = nil { return gg , err } g : = genny . New ( ) data : = map [ string ] interface { } { " " : opts , } helpers : = template . Func Map { } t : = gogen . Template Transformer ( data , helpers ) g . Transformer ( t ) g . Box ( packr . New ( " " , " " ) ) gg . Add ( g ) return gg , nil } 
func New ( opts Options ) * App { Load Plugins ( ) envy . Load ( ) opts = options With Defaults ( opts ) a : = & App { Options : opts , Error Handlers : Error Handlers { 4 0 4 : default Error Handler , 5 0 0 : default Error Handler , } , router : mux . New Router ( ) , moot : & sync . RWMutex { } , routes : Route List { } , children : [ ] * App { } , } dem : = a . default Error Middleware a . Middleware = new Middleware Stack ( dem ) not Found Handler : = func ( errorf string , code int ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { c : = a . new Context ( Route Info { } , res , req ) err : = fmt . Errorf ( errorf , req . Method , req . URL . Path ) a . Error Handlers . Get ( code ) ( code , err , c ) } } a . router . Not Found Handler = not Found Handler ( " " , 4 0 4 ) a . router . Method Not Allowed Handler = not Found Handler ( " " , 4 0 5 ) if a . Method Override = = nil { a . Method Override = Method Override } a . Use ( a . Panic Handler ) a . Use ( Request Logger ) a . Use ( session Saver ) return a } 
func Deprecrations Check ( r * Runner ) error { fmt . Println ( " " ) b , err : = ioutil . Read File ( " " ) if err ! = nil { return err } if bytes . Contains ( b , [ ] byte ( " " ) ) { r . Warnings = append ( r . Warnings , " " ) } return filepath . Walk ( filepath . Join ( r . App . Root , " " ) , func ( path string , info os . File Info , _ error ) error { if info . Is Dir ( ) { return nil } if filepath . Ext ( path ) ! = " " { return nil } b , err : = ioutil . Read File ( path ) if err ! = nil { return err } if bytes . Contains ( b , [ ] byte ( " " ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( " " , path ) ) } if bytes . Contains ( b , [ ] byte ( " " ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( " " , path ) ) } if bytes . Contains ( b , [ ] byte ( " " ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( " " , path ) ) } } if bytes . Contains ( b , [ ] byte ( " " ) ) { b = bytes . Replace ( b , [ ] byte ( " " ) , [ ] byte ( " \ " \ " " ) , - 1 ) } if bytes . Contains ( b , [ ] byte ( " " ) ) | | bytes . Contains ( b , [ ] byte ( " " ) ) { r . Warnings = append ( r . Warnings , fmt . Sprintf ( " " , path ) ) } ioutil . Write File ( path , b , 0 6 6 4 ) return nil } ) } 
func ( v Base Resource ) List ( c Context ) error { return c . Error ( 4 0 4 , errors . New ( " " ) ) } 
func ( s func Renderer ) Render ( w io . Writer , data Data ) error { return s . render Func ( w , data ) } 
func Func ( s string , fn Renderer Func ) Renderer { return func Renderer { content Type : s , render Func : fn , } } 
func ( e * Engine ) Func ( s string , fn Renderer Func ) Renderer { return Func ( s , fn ) } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if opts . Out . Writer = = nil { opts . Out = rx . New Writer ( os . Stdout ) } return nil } 
func build Actions ( pres * presenter ) genny . Run Fn { return func ( r * genny . Runner ) error { fn : = fmt . Sprintf ( " " , pres . Name . File ( ) ) xf , err : = r . Find File ( fn ) if err ! = nil { return build New Actions ( fn , pres ) ( r ) } if err : = append Actions ( xf , pres ) ( r ) ; err ! = nil { return err } return nil } } 
func build New Actions ( fn string , pres * presenter ) genny . Run Fn { return func ( r * genny . Runner ) error { for _ , a : = range pres . Options . Actions { pres . Actions = append ( pres . Actions , name . New ( a ) ) } h , err : = box . Find String ( " " ) if err ! = nil { return err } a , err : = box . Find String ( " " ) if err ! = nil { return err } f : = genny . New File S ( fn + " " , h + a ) f , err = transform ( pres , f ) if err ! = nil { return err } return r . File ( f ) } } 
func append Actions ( f genny . File , pres * presenter ) genny . Run Fn { return func ( r * genny . Runner ) error { body : = f . String ( ) for _ , ac : = range pres . Options . Actions { a : = name . New ( ac ) x : = fmt . Sprintf ( " " , pres . Name . Pascalize ( ) , a . Pascalize ( ) ) if strings . Contains ( body , x ) { continue } pres . Actions = append ( pres . Actions , a ) } a , err : = box . Find String ( " " ) if err ! = nil { return err } f = genny . New File S ( f . Name ( ) + " " , f . String ( ) + a ) f , err = transform ( pres , f ) if err ! = nil { return err } return r . File ( f ) } } 
func ( s * Session ) Save ( ) error { return s . Session . Save ( s . req , s . res ) } 
func ( s * Session ) Get Once ( name interface { } ) interface { } { if x , ok : = s . Session . Values [ name ] ; ok { s . Delete ( name ) return x } return nil } 
func ( s * Session ) Set ( name , value interface { } ) { s . Session . Values [ name ] = value } 
func ( s * Session ) Clear ( ) { for k : = range s . Session . Values { s . Delete ( k ) } } 
func ( a * App ) get Session ( r * http . Request , w http . Response Writer ) * Session { if a . root ! = nil { return a . root . get Session ( r , w ) } session , _ : = a . Session Store . Get ( r , a . Session Name ) return & Session { Session : session , req : r , res : w , } } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } data : = map [ string ] interface { } { " " : opts , } t : = gogen . Template Transformer ( data , template . Func Map { } ) g . Transformer ( t ) g . Run Fn ( func ( r * genny . Runner ) error { return gen File ( r , opts ) } ) return g , nil } 
func String ( s string , args . . . interface { } ) Renderer { e : = New ( Options { } ) return e . String ( s , args . . . ) } 
func ( e * Engine ) String ( s string , args . . . interface { } ) Renderer { if len ( args ) > 0 { s = fmt . Sprintf ( s , args . . . ) } return string Renderer { Engine : e , body : s , } } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } g . Run Fn ( func ( r * genny . Runner ) error { if _ , err : = r . Look Path ( " " ) ; err ! = nil { return errors . New ( " " ) } return nil } ) g . Box ( Templates ) data : = map [ string ] interface { } { " " : opts , } t : = gogen . Template Transformer ( data , gogen . Template Helpers ) g . Transformer ( t ) g . Transformer ( genny . Dot ( ) ) g . Run Fn ( func ( r * genny . Runner ) error { return install Pkgs ( r , opts ) } ) return g , nil } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } g . Box ( packr . New ( " " , " " ) ) ctx : = plush . New Context ( ) ctx . Set ( " " , opts . App ) g . Transformer ( plushgen . Transformer ( ctx ) ) g . Transformer ( genny . Dot ( ) ) return g , nil } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } g . Error Fn = func ( err error ) { events . Emit Error ( Evt Build Stop Err , err , events . Payload { " " : opts } ) } g . Run Fn ( func ( r * genny . Runner ) error { events . Emit Payload ( Evt Build Start , events . Payload { " " : opts } ) return nil } ) g . Transformer ( genny . Dot ( ) ) if err : = g . Box ( box ) ; err ! = nil { return g , err } ctx . Set ( " " , opts ) ctx . Set ( " " , opts . Build Time . Format ( time . RFC 3 3 3 9 ) ) ctx . Set ( " " , opts . Build Version ) ctx . Set ( " " , runtime . Version ) g . Transformer ( plushgen . Transformer ( ctx ) ) if err ! = nil { return g , err } g . Merge ( ag ) if opts . With Assets { if err ! = nil { return g , err } g . Merge ( ag ) } if err ! = nil { return g , err } g . Merge ( dg ) g . Run Fn ( func ( r * genny . Runner ) error { return jam . Pack ( jam . Pack Options { } ) } ) if err ! = nil { return g , err } g . Command ( c ) g . Run Fn ( Cleanup ( opts ) ) g . Run Fn ( func ( r * genny . Runner ) error { events . Emit Payload ( Evt Build Stop , events . Payload { " " : opts } ) return nil } ) return g , nil } 
func Execute ( ) { if err : = Root Cmd . Execute ( ) ; err ! = nil { if strings . Contains ( err . Error ( ) , db Not Found ) | | strings . Contains ( err . Error ( ) , pop Not Found ) { logrus . Errorf ( pop Install Instructions ) os . Exit ( - 1 ) } logrus . Errorf ( " " , err ) if strings . Contains ( err . Error ( ) , db Not Found ) | | strings . Contains ( err . Error ( ) , pop Not Found ) { fmt . Println ( pop Install Instructions ) os . Exit ( - 1 ) } os . Exit ( - 1 ) } } 
func ( opts * Options ) Validate ( ) error { pwd , _ : = os . Getwd ( ) if opts . App . Is Zero ( ) { opts . App = meta . New ( pwd ) } if len ( opts . Environment ) = = 0 { opts . Environment = " " } if opts . Build Time . Is Zero ( ) { opts . Build Time = time . Now ( ) } if len ( opts . Build Version ) = = 0 { opts . Build Version = opts . Build Time . Format ( time . RFC 3 3 3 9 ) } if opts . rollback = = nil { opts . rollback = & sync . Map { } } if len ( opts . Go Command ) = = 0 { opts . Go Command = " " } return nil } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if len ( opts . Name ) = = 0 { return errors . New ( " " ) } if len ( opts . Model ) = = 0 { opts . Model = opts . Name } if strings . Contains ( opts . Model , " " ) { parts : = strings . Split ( opts . Model , " " ) opts . Model = parts [ len ( parts ) - 1 ] } if opts . App . As API { opts . Skip Templates = true } return nil } 
func New Message ( settings . . . Message Setting ) * Message { m : = & Message { header : make ( header ) , charset : " " , encoding : Quoted Printable , } m . apply Settings ( settings ) if m . encoding = = Base 6 4 { m . h Encoder = b Encoding } else { m . h Encoder = q Encoding } return m } 
func ( m * Message ) Reset ( ) { for k : = range m . header { delete ( m . header , k ) } m . parts = nil m . attachments = nil m . embedded = nil } 
func ( m * Message ) Set Header ( field string , value . . . string ) { m . encode Header ( value ) m . header [ field ] = value } 
func ( m * Message ) Set Headers ( h map [ string ] [ ] string ) { for k , v : = range h { m . Set Header ( k , v . . . ) } } 
func ( m * Message ) Set Address Header ( field , address , name string ) { m . header [ field ] = [ ] string { m . Format Address ( address , name ) } } 
func ( m * Message ) Format Address ( address , name string ) string { if name = = " " { return address } enc : = m . encode String ( name ) if enc = = name { m . buf . Write Byte ( ' " ' ) for i : = 0 ; i < len ( name ) ; i + + { b : = name [ i ] if b = = ' \ \ ' | | b = = ' " ' { m . buf . Write Byte ( ' \ \ ' ) } m . buf . Write Byte ( b ) } m . buf . Write Byte ( ' " ' ) } else if has Specials ( name ) { m . buf . Write String ( b Encoding . Encode ( m . charset , name ) ) } else { m . buf . Write String ( enc ) } m . buf . Write String ( " " ) m . buf . Write String ( address ) m . buf . Write Byte ( ' > ' ) addr : = m . buf . String ( ) m . buf . Reset ( ) return addr } 
func ( m * Message ) Set Date Header ( field string , date time . Time ) { m . header [ field ] = [ ] string { m . Format Date ( date ) } } 
func ( m * Message ) Format Date ( date time . Time ) string { return date . Format ( time . RFC 1 1 2 3Z ) } 
func ( m * Message ) Set Body ( content Type , body string , settings . . . Part Setting ) { m . Set Body Writer ( content Type , new Copier ( body ) , settings . . . ) } 
func ( m * Message ) Set Body Writer ( content Type string , f func ( io . Writer ) error , settings . . . Part Setting ) { m . parts = [ ] * part { m . new Part ( content Type , f , settings ) } } 
func ( m * Message ) Add Alternative ( content Type , body string , settings . . . Part Setting ) { m . Add Alternative Writer ( content Type , new Copier ( body ) , settings . . . ) } 
func ( m * Message ) Add Alternative Writer ( content Type string , f func ( io . Writer ) error , settings . . . Part Setting ) { m . parts = append ( m . parts , m . new Part ( content Type , f , settings ) ) } 
func Set Part Encoding ( e Encoding ) Part Setting { return Part Setting ( func ( p * part ) { p . encoding = e } ) } 
func Set Header ( h map [ string ] [ ] string ) File Setting { return func ( f * file ) { for k , v : = range h { f . Header [ k ] = v } } } 
func Set Copy Func ( f func ( io . Writer ) error ) File Setting { return func ( fi * file ) { fi . Copy Func = f } } 
func ( m * Message ) Attach Reader ( name string , r io . Reader , settings . . . File Setting ) { m . attachments = m . append File ( m . attachments , file From Reader ( name , r ) , settings ) } 
func ( m * Message ) Attach ( filename string , settings . . . File Setting ) { m . attachments = m . append File ( m . attachments , file From Filename ( filename ) , settings ) } 
func ( m * Message ) Embed Reader ( name string , r io . Reader , settings . . . File Setting ) { m . embedded = m . append File ( m . embedded , file From Reader ( name , r ) , settings ) } 
func ( m * Message ) Embed ( filename string , settings . . . File Setting ) { m . embedded = m . append File ( m . embedded , file From Filename ( filename ) , settings ) } 
func Validate Templates ( walk packd . Walker , tvs [ ] Template Validator ) genny . Run Fn { if len ( tvs ) = = 0 { return func ( r * genny . Runner ) error { return nil } } return func ( r * genny . Runner ) error { var errs [ ] string err : = packd . Skip Walker ( walk , packd . Common Skip Prefixes , func ( path string , file packd . File ) error { info , err : = file . File Info ( ) if err ! = nil { return err } if info . Is Dir ( ) { return nil } f : = genny . New File ( path , file ) for _ , tv : = range tvs { err : = safe . Run ( func ( ) { if err : = tv ( f ) ; err ! = nil { errs = append ( errs , fmt . Sprintf ( " " , path , err . Error ( ) ) ) } } ) if err ! = nil { return err } } return nil } ) if err ! = nil { return err } if len ( errs ) = = 0 { return nil } return errors . New ( strings . Join ( errs , " \n " ) ) } } 
func Plush Validator ( f genny . File ) error { if ! genny . Has Ext ( f , " " , " " , " " ) { return nil } _ , err : = plush . Parse ( f . String ( ) ) return err } 
func Go Template Validator ( f genny . File ) error { if ! genny . Has Ext ( f , " " ) { return nil } t : = template . New ( f . Name ( ) ) _ , err : = t . Parse ( f . String ( ) ) return err } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } var found bool for _ , a : = range Available { if opts . Provider = = a { found = true break } } if ! found { return fmt . Errorf ( " " , opts . Provider , strings . Join ( Available , " " ) ) } return nil } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if len ( opts . Version ) = = 0 { opts . Version = runtime . Version } if opts . Pop ! = nil { if opts . Pop . App . Is Zero ( ) { opts . Pop . App = opts . App } if err : = opts . Pop . Validate ( ) ; err ! = nil { return err } } if opts . CI ! = nil { if opts . CI . App . Is Zero ( ) { opts . CI . App = opts . App } if err : = opts . CI . Validate ( ) ; err ! = nil { return err } } if opts . Refresh ! = nil { if opts . Refresh . App . Is Zero ( ) { opts . Refresh . App = opts . App } if err : = opts . Refresh . Validate ( ) ; err ! = nil { return err } } if opts . VCS ! = nil { if opts . VCS . App . Is Zero ( ) { opts . VCS . App = opts . App } if err : = opts . VCS . Validate ( ) ; err ! = nil { return err } } if opts . App . With Modules & & opts . App . With Dep { return Err Go Modules With Dep } name : = strings . To Lower ( opts . App . Name . String ( ) ) fb : = append ( opts . Forbidden Names , " " , " " , " " ) for _ , n : = range fb { rx , err : = regexp . Compile ( n ) if err ! = nil { return err } if rx . Match String ( name ) { return fmt . Errorf ( " " , opts . App . Name ) } } if ! name RX . Match String ( name ) { return fmt . Errorf ( " " , opts . App . Name ) } return nil } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if len ( opts . Name . String ( ) ) = = 0 { return errors . New ( " " ) } return nil } 
func Load Plugins ( ) error { var err error oncer . Do ( " " , func ( ) { } plugs , err : = plugins . Available ( ) if err ! = nil { err = err return } for _ , cmds : = range plugs { for _ , c : = range cmds { if c . Buffalo Command ! = " " { continue } err : = func ( c plugins . Command ) error { return safe . Run E ( func ( ) error { n : = fmt . Sprintf ( " " , c . Binary , c . Name ) fn : = func ( e events . Event ) { b , err : = json . Marshal ( e ) if err ! = nil { fmt . Println ( " " , e , err ) return } cmd : = exec . Command ( c . Binary , c . Use Command , string ( b ) ) cmd . Stderr = os . Stderr cmd . Stdout = os . Stdout cmd . Stdin = os . Stdin if err : = cmd . Run ( ) ; err ! = nil { fmt . Println ( " " , strings . Join ( cmd . Args , " " ) , err ) } } _ , err : = events . Named Listen ( n , events . Filter ( c . Listen For , fn ) ) if err ! = nil { return err } return nil } ) } ( c ) if err ! = nil { err = err return } } } } ) return err } 
func ( w * Response ) Write Header ( i int ) { w . Status = i w . Response Writer . Write Header ( i ) } 
func ( w * Response ) Write ( b [ ] byte ) ( int , error ) { w . Size = binary . Size ( b ) return w . Response Writer . Write ( b ) } 
func ( w * Response ) Flush ( ) { if f , ok : = w . Response Writer . ( http . Flusher ) ; ok { f . Flush ( ) } } 
func ( w * Response ) Close Notify ( ) < - chan bool { if cn , ok : = w . Response Writer . ( close Notifier ) ; ok { return cn . Close Notify ( ) } return nil } 
func Run ( ) error { fmt . Printf ( " \n " , runtime . Version ) if ! ask ( " " ) { fmt . Println ( " " ) return nil } r : = & Runner { App : meta . New ( " " ) , Warnings : [ ] string { } , } defer func ( ) { if len ( r . Warnings ) = = 0 { return } fmt . Println ( " \n \n " ) fmt . Printf ( " \n \n " , len ( r . Warnings ) ) for _ , w : = range r . Warnings { fmt . Printf ( " \n " , w ) } } ( ) for _ , c : = range checks { if err : = c ( r ) ; err ! = nil { return err } } return nil } 
func only Relevant Files ( p string , fi os . File Info , err error , fn func ( p string ) error ) error { if err ! = nil { return err } if fi . Is Dir ( ) { base : = filepath . Base ( p ) if strings . Has Prefix ( base , " " ) { return filepath . Skip Dir } for _ , n : = range [ ] string { " " , " " , " " } { if base = = n { return filepath . Skip Dir } } return nil } ext : = filepath . Ext ( p ) if ext ! = " " { return nil } return fn ( p ) } 
func Go Template Engine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { t : = template . New ( input ) if helpers ! = nil { t = t . Funcs ( helpers ) } t , err : = t . Parse ( input ) if err ! = nil { return " " , err } bb : = & bytes . Buffer { } err = t . Execute ( bb , data ) return bb . String ( ) , err } 
func ( a * App ) GET ( p string , h Handler ) * Route Info { return a . add Route ( " " , p , h ) } 
func ( a * App ) Redirect ( status int , from , to string ) * Route Info { return a . GET ( from , func ( c Context ) error { return c . Redirect ( status , to ) } ) } 
func ( a * App ) Mount ( p string , h http . Handler ) { prefix : = path . Join ( a . Prefix , p ) path : = path . Join ( p , " " ) a . ANY ( path , Wrap Handler ( http . Strip Prefix ( prefix , h ) ) ) } 
func ( a * App ) Serve Files ( p string , root http . File System ) { path : = path . Join ( a . Prefix , p ) a . filepaths = append ( a . filepaths , path ) h : = strip Asset ( path , a . file Server ( root ) , a ) a . router . Path Prefix ( path ) . Handler ( h ) } 
func ( a * App ) Resource ( p string , r Resource ) * App { g : = a . Group ( p ) p = " " rv : = reflect . Value Of ( r ) if rv . Kind ( ) = = reflect . Ptr { rv = rv . Elem ( ) } rt : = rv . Type ( ) rname : = fmt . Sprintf ( " " , rt . Pkg Path ( ) , rt . Name ( ) ) + " " n : = strings . Trim Suffix ( rt . Name ( ) , " " ) param Name : = name . New ( n ) . Param ID ( ) . String ( ) type param Keyable interface { Param Key ( ) string } if pk , ok : = r . ( param Keyable ) ; ok { param Name = pk . Param Key ( ) } spath : = path . Join ( p , " " + param Name + " " ) set Func Key ( r . List , fmt . Sprintf ( rname , " " ) ) g . GET ( p , r . List ) if n , ok : = r . ( newable ) ; ok { set Func Key ( n . New , fmt . Sprintf ( rname , " " ) ) g . GET ( path . Join ( p , " " ) , n . New ) } set Func Key ( r . Show , fmt . Sprintf ( rname , " " ) ) g . GET ( path . Join ( spath ) , r . Show ) if n , ok : = r . ( editable ) ; ok { set Func Key ( n . Edit , fmt . Sprintf ( rname , " " ) ) g . GET ( path . Join ( spath , " " ) , n . Edit ) } set Func Key ( r . Create , fmt . Sprintf ( rname , " " ) ) g . POST ( p , r . Create ) set Func Key ( r . Update , fmt . Sprintf ( rname , " " ) ) g . PUT ( path . Join ( spath ) , r . Update ) set Func Key ( r . Destroy , fmt . Sprintf ( rname , " " ) ) g . DELETE ( path . Join ( spath ) , r . Destroy ) g . Prefix = path . Join ( g . Prefix , spath ) return g } 
func ( a * App ) ANY ( p string , h Handler ) { a . GET ( p , h ) a . POST ( p , h ) a . PUT ( p , h ) a . PATCH ( p , h ) a . HEAD ( p , h ) a . OPTIONS ( p , h ) a . DELETE ( p , h ) } 
func ( a * App ) Group ( group Path string ) * App { g : = New ( a . Options ) g . Prefix = path . Join ( a . Prefix , group Path ) g . Name = g . Prefix g . router = a . router g . Middleware = a . Middleware . clone ( ) g . Error Handlers = a . Error Handlers g . root = a if a . root ! = nil { g . root = a . root } a . children = append ( a . children , g ) return g } 
func ( a * App ) Route Helpers ( ) map [ string ] Route Helper Func { rh : = map [ string ] Route Helper Func { } for _ , route : = range a . Routes ( ) { c Route : = route rh [ c Route . Path Name ] = c Route . Build Path Helper ( ) } return rh } 
func ( a * App ) build Route Name ( p string ) string { if p = = " " | | p = = " " { return " " } result Parts : = [ ] string { } parts : = strings . Split ( p , " " ) for index , part : = range parts { if strings . Contains ( part , " " ) | | part = = " " { continue } should Singularize : = ( len ( parts ) > index + 1 ) & & strings . Contains ( parts [ index + 1 ] , " " ) if should Singularize { part = flect . Singularize ( part ) } if parts [ index ] = = " " | | parts [ index ] = = " " { result Parts = append ( [ ] string { part } , result Parts . . . ) continue } if index > 0 & & strings . Contains ( parts [ index - 1 ] , " " ) { result Parts = append ( result Parts , part ) continue } result Parts = append ( result Parts , part ) } if len ( result Parts ) = = 0 { return " " } underscore : = strings . Trim Space ( strings . Join ( result Parts , " " ) ) return name . Var Case ( underscore ) } 
func New ( opts * Options ) ( * genny . Group , error ) { gg : = & genny . Group { } if err : = opts . Validate ( ) ; err ! = nil { return gg , err } if ! opts . Skip Init { g , err : = init Generator ( opts ) if err ! = nil { return gg , err } gg . Add ( g ) } g : = genny . New ( ) h : = template . Func Map { } data : = map [ string ] interface { } { " " : opts , } t : = gogen . Template Transformer ( data , h ) g . Transformer ( t ) fn : = opts . Name . File ( ) . String ( ) g . File ( genny . New File S ( " " + fn + " " , mailer Tmpl ) ) g . File ( genny . New File S ( " " + fn + " " , mail Tmpl ) ) gg . Add ( g ) return gg , nil } 
func New Dialer ( host string , port int , username , password string ) * Dialer { return & Dialer { Host : host , Port : port , Username : username , Password : password , SSL : port = = 4 6 5 , Timeout : 1 0 * time . Second , Retry Failure : true , } } 
func ( d * Dialer ) Dial ( ) ( Send Closer , error ) { conn , err : = Net Dial Timeout ( " " , addr ( d . Host , d . Port ) , d . Timeout ) if err ! = nil { return nil , err } if d . SSL { conn = tls Client ( conn , d . tls Config ( ) ) } c , err : = smtp New Client ( conn , d . Host ) if err ! = nil { return nil , err } if d . Timeout > 0 { conn . Set Deadline ( time . Now ( ) . Add ( d . Timeout ) ) } if d . Local Name ! = " " { if err : = c . Hello ( d . Local Name ) ; err ! = nil { return nil , err } } if ! d . SSL & & d . Start TLSPolicy ! = No Start TLS { ok , _ : = c . Extension ( " " ) if ! ok & & d . Start TLSPolicy = = Mandatory Start TLS { err : = Start TLSUnsupported Error { Policy : d . Start TLSPolicy } return nil , err } if ok { if err : = c . Start TLS ( d . tls Config ( ) ) ; err ! = nil { c . Close ( ) return nil , err } } } if d . Auth = = nil & & d . Username ! = " " { if ok , auths : = c . Extension ( " " ) ; ok { if strings . Contains ( auths , " " ) { d . Auth = smtp . CRAMMD 5Auth ( d . Username , d . Password ) } else if strings . Contains ( auths , " " ) & & ! strings . Contains ( auths , " " ) { d . Auth = & login Auth { username : d . Username , password : d . Password , host : d . Host , } } else { d . Auth = smtp . Plain Auth ( " " , d . Username , d . Password , d . Host ) } } } if d . Auth ! = nil { if err = c . Auth ( d . Auth ) ; err ! = nil { c . Close ( ) return nil , err } } return & smtp Sender { c , conn , d } , nil } 
func ( d * Dialer ) Dial And Send ( m . . . * Message ) error { s , err : = d . Dial ( ) if err ! = nil { return err } defer s . Close ( ) return Send ( s , m . . . ) } 
func Request Logger Func ( h Handler ) Handler { return func ( c Context ) error { var irid interface { } if irid = c . Session ( ) . Get ( " " ) ; irid = = nil { irid = randx . String ( 1 0 ) c . Session ( ) . Set ( " " , irid ) c . Session ( ) . Save ( ) } rid : = irid . ( string ) + " " + randx . String ( 1 0 ) c . Set ( " " , rid ) c . Log Field ( " " , rid ) start : = time . Now ( ) defer func ( ) { ws , ok : = c . Response ( ) . ( * Response ) if ! ok { ws = & Response { Response Writer : c . Response ( ) } ws . Status = 2 0 0 } req : = c . Request ( ) ct : = httpx . Content Type ( req ) if ct ! = " " { c . Log Field ( " " , ct ) } c . Log Fields ( map [ string ] interface { } { " " : req . Method , " " : req . URL . String ( ) , " " : time . Since ( start ) , " " : ws . Size , " " : humanize . Bytes ( uint 6 4 ( ws . Size ) ) , " " : ws . Status , } ) c . Logger ( ) . Info ( req . URL . String ( ) ) } ( ) return h ( c ) } } 
func ( f Flash ) Set ( key string , values [ ] string ) { f . data [ key ] = values } 
func ( f Flash ) Add ( key , value string ) { if len ( f . data [ key ] ) = = 0 { f . data [ key ] = [ ] string { value } return } f . data [ key ] = append ( f . data [ key ] , value ) } 
func ( f Flash ) persist ( session * Session ) { b , _ : = json . Marshal ( f . data ) session . Set ( flash Key , b ) session . Save ( ) } 
func new Flash ( session * Session ) * Flash { result : = & Flash { data : map [ string ] [ ] string { } , } if session . Session ! = nil { if f : = session . Get ( flash Key ) ; f ! = nil { json . Unmarshal ( f . ( [ ] byte ) , & result . data ) } } return result } 
func ( c * Cookies ) Get ( name string ) ( string , error ) { ck , err : = c . req . Cookie ( name ) if err ! = nil { return " " , err } return ck . Value , nil } 
func ( c * Cookies ) Set ( name , value string , max Age time . Duration ) { ck : = http . Cookie { Name : name , Value : value , Max Age : int ( max Age . Seconds ( ) ) , } http . Set Cookie ( c . res , & ck ) } 
func ( c * Cookies ) Set With Expiration Time ( name , value string , expires time . Time ) { ck : = http . Cookie { Name : name , Value : value , Expires : expires , } http . Set Cookie ( c . res , & ck ) } 
func ( c * Cookies ) Set With Path ( name , value , path string ) { ck : = http . Cookie { Name : name , Value : value , Path : path , } http . Set Cookie ( c . res , & ck ) } 
func ( c * Cookies ) Delete ( name string ) { ck : = http . Cookie { Name : name , Value : " " , http . Set Cookie ( c . res , & ck ) } 
func New Message ( ) Message { return Message { Context : context . Background ( ) , Headers : map [ string ] string { } , Data : render . Data { } , moot : & sync . RWMutex { } , } } 
func New From Data ( data render . Data ) Message { d : = render . Data { } for k , v : = range data { d [ k ] = v } m : = New Message ( ) m . Data = d return m } 
func New ( c buffalo . Context ) Message { m : = New From Data ( c . Data ( ) ) m . Context = c return m } 
func ( es * Event Source ) Close Notify ( ) < - chan bool { if cn , ok : = es . w . ( close Notifier ) ; ok { return cn . Close Notify ( ) } return nil } 
func New Event Source ( w http . Response Writer ) ( * Event Source , error ) { es : = & Event Source { w : w } var ok bool es . fl , ok = w . ( http . Flusher ) if ! ok { return es , errors . New ( " " ) } es . w . Header ( ) . Set ( " " , " " ) es . w . Header ( ) . Set ( " " , " " ) es . w . Header ( ) . Set ( " " , " " ) es . w . Header ( ) . Set ( " " , " " ) return es , nil } 
func New Simple With Context ( ctx context . Context ) * Simple { ctx , cancel : = context . With Cancel ( ctx ) l : = logrus . New ( ) l . Level = logrus . Info Level l . Formatter = & logrus . Text Formatter { } return & Simple { Logger : l , ctx : ctx , cancel : cancel , handlers : map [ string ] Handler { } , moot : & sync . Mutex { } , } } 
func ( w * Simple ) Register ( name string , h Handler ) error { w . moot . Lock ( ) defer w . moot . Unlock ( ) if _ , ok : = w . handlers [ name ] ; ok { return fmt . Errorf ( " " , name ) } w . handlers [ name ] = h return nil } 
func ( w * Simple ) Start ( ctx context . Context ) error { w . Logger . Info ( " " ) w . ctx , w . cancel = context . With Cancel ( ctx ) return nil } 
func ( w Simple ) Stop ( ) error { w . Logger . Info ( " " ) w . cancel ( ) return nil } 
func ( w Simple ) Perform ( job Job ) error { w . Logger . Debugf ( " " , job ) if job . Handler = = " " { err : = fmt . Errorf ( " " , job ) w . Logger . Error ( err ) return err } w . moot . Lock ( ) defer w . moot . Unlock ( ) if h , ok : = w . handlers [ job . Handler ] ; ok { go func ( ) { err : = safe . Run E ( func ( ) error { return h ( job . Args ) } ) if err ! = nil { w . Logger . Error ( err ) } w . Logger . Debugf ( " " , job ) } ( ) return nil } err : = fmt . Errorf ( " " , job . Handler ) w . Logger . Error ( err ) return err } 
func ( w Simple ) Perform At ( job Job , t time . Time ) error { return w . Perform In ( job , time . Until ( t ) ) } 
func ( w Simple ) Perform In ( job Job , d time . Duration ) error { go func ( ) { select { case < - time . After ( d ) : w . Perform ( job ) case < - w . ctx . Done ( ) : w . cancel ( ) } } ( ) return nil } 
func ( opts * Options ) Validate ( ) error { if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } return nil } 
func ( ri Route Info ) String ( ) string { b , _ : = json . Marshal Indent ( ri , " " , " " ) return string ( b ) } 
func ( ri * Route Info ) Alias ( aliases . . . string ) * Route Info { ri . Aliases = append ( ri . Aliases , aliases . . . ) for _ , a : = range aliases { ri . App . router . Handle ( a , ri ) . Methods ( ri . Method ) } return ri } 
func ( ri * Route Info ) Name ( name string ) * Route Info { route Index : = - 1 for index , route : = range ri . App . Routes ( ) { if route . Path = = ri . Path & & route . Method = = ri . Method { route Index = index break } } name = flect . Camelize ( name ) if ! strings . Has Suffix ( name , " " ) { name = name + " " } ri . Path Name = name if route Index ! = - 1 { ri . App . Routes ( ) [ route Index ] = reflect . Value Of ( ri ) . Interface ( ) . ( * Route Info ) } return ri } 
func ( ri * Route Info ) Build Path Helper ( ) Route Helper Func { c Route : = ri return func ( opts map [ string ] interface { } ) ( template . HTML , error ) { pairs : = [ ] string { } for k , v : = range opts { pairs = append ( pairs , k ) pairs = append ( pairs , fmt . Sprintf ( " " , v ) ) } url , err : = c Route . Mux Route . URL ( pairs . . . ) if err ! = nil { return " " , errors . Wrapf ( err , " " , c Route . Path ) } result : = url . Path result = add Extra Params To ( result , opts ) return template . HTML ( result ) , nil } } 
func ( s * TLS ) Set Addr ( addr string ) { if s . Server . Addr = = " " { s . Server . Addr = addr } } 
func ( s * TLS ) Start ( c context . Context , h http . Handler ) error { s . Handler = h return s . Listen And Serve TLS ( s . Cert File , s . Key File ) } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } g . Transformer ( genny . Replace ( " " , " " ) ) g . Transformer ( genny . Dot ( ) ) box : = packr . New ( " " , " " ) var fname string switch opts . Provider { case " " , " " : fname = " " case " " , " " : if opts . App . With Pop { fname = " " } else { fname = " " } default : return g , fmt . Errorf ( " " , opts . Provider ) } f , err : = box . Find String ( fname ) if err ! = nil { return g , err } g . File ( genny . New File S ( fname , f ) ) data : = map [ string ] interface { } { " " : opts , } if opts . DBType = = " " { data [ " " ] = " " + opts . App . Name . File ( ) . String ( ) + " " } else if opts . DBType = = " " { data [ " " ] = " " + opts . App . Name . File ( ) . String ( ) + " " } else { data [ " " ] = " " } helpers : = template . Func Map { } t : = gogen . Template Transformer ( data , helpers ) g . Transformer ( t ) return g , nil } 
func Download ( ctx context . Context , name string , r io . Reader ) Renderer { return download Renderer { ctx : ctx , name : name , reader : r , } } 
func ( e * Engine ) Download ( ctx context . Context , name string , r io . Reader ) Renderer { return Download ( ctx , name , r ) } 
func Java Script ( names . . . string ) Renderer { e : = New ( Options { } ) return e . Java Script ( names . . . ) } 
func ( e * Engine ) Java Script ( names . . . string ) Renderer { if e . Java Script Layout ! = " " & & len ( names ) = = 1 { names = append ( names , e . Java Script Layout ) } hr : = & template Renderer { Engine : e , content Type : " " , names : names , } return hr } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } g . Run Fn ( construct ( opts ) ) return g , nil } 
func Register Custom Decoder ( fn Custom Type Decoder , types [ ] interface { } , fields [ ] interface { } ) { raw Func : = ( func ( [ ] string ) ( interface { } , error ) ) ( fn ) decoder . Register Custom Type ( raw Func , types , fields ) } 
func Register ( content Type string , fn Binder ) { lock . Lock ( ) defer lock . Unlock ( ) binders [ strings . To Lower ( content Type ) ] = fn } 
func Exec ( req * http . Request , value interface { } ) error { if ba , ok : = value . ( Bindable ) ; ok { return ba . Bind ( req ) } ct : = httpx . Content Type ( req ) if ct = = " " { return errors . New ( " " ) } if b , ok : = binders [ ct ] ; ok { return b ( req , value ) } return fmt . Errorf ( " " , ct ) } 
func Method Override ( res http . Response Writer , req * http . Request ) { if req . Method = = " " { req . Method = defaults . String ( req . Form Value ( " " ) , " " ) req . Form . Del ( " " ) req . Post Form . Del ( " " ) } } 
func ( ms * Middleware Stack ) Clear ( ) { ms . stack = [ ] Middleware Func { } ms . skips = map [ string ] bool { } } 
func ( ms * Middleware Stack ) Use ( mw . . . Middleware Func ) { ms . stack = append ( ms . stack , mw . . . ) } 
func ( ms * Middleware Stack ) Skip ( mw Middleware Func , handlers . . . Handler ) { for _ , h : = range handlers { key : = func Key ( mw , h ) ms . skips [ key ] = true } } 
func ( ms * Middleware Stack ) Replace ( mw 1 Middleware Func , mw 2 Middleware Func ) { m 1k : = func Key ( mw 1 ) stack : = [ ] Middleware Func { } for _ , mw : = range ms . stack { if func Key ( mw ) = = m 1k { stack = append ( stack , mw 2 ) } else { stack = append ( stack , mw ) } } ms . stack = stack } 
func ( a * App ) Routes ( ) Route List { if a . root ! = nil { return a . root . routes } return a . routes } 
func ( a Route List ) Lookup ( name string ) ( * Route Info , error ) { for _ , ri : = range a { if ri . Path Name = = name { return ri , nil } } return nil , errors . New ( " " ) } 
func Wrap Buffalo Handler ( h Handler ) http . Handler { a : = New ( Options { } ) return ri } 
func Package JSONCheck ( r * Runner ) error { fmt . Println ( " " ) if ! r . App . With Webpack { return nil } box : = webpack . Templates f , err : = box . Find String ( " " ) if err ! = nil { return err } tmpl , err : = template . New ( " " ) . Parse ( f ) if err ! = nil { return err } bb : = & bytes . Buffer { } err = tmpl . Execute ( bb , map [ string ] interface { } { " " : & webpack . Options { App : r . App , } , } ) if err ! = nil { return err } b , err : = ioutil . Read File ( " " ) if err ! = nil { return err } if string ( b ) = = bb . String ( ) { return nil } if ! ask ( " \n " ) { fmt . Println ( " \t " ) return nil } pf , err : = os . Create ( " " ) if err ! = nil { return err } _ , err = pf . Write ( bb . Bytes ( ) ) if err ! = nil { return err } err = pf . Close ( ) if err ! = nil { return err } os . Remove All ( filepath . Join ( r . App . Root , " " ) ) var cmd * exec . Cmd if r . App . With Yarn { cmd = exec . Command ( " " , " " ) } else { cmd = exec . Command ( " " , " " ) } cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr return cmd . Run ( ) } 
func ( c Import Converter ) match ( importpath string ) ( string , bool ) { for key , value : = range c . Data { if ! strings . Has Prefix ( importpath , key ) { continue } result : = strings . Replace ( importpath , key , value , 1 ) return result , true } return importpath , false } 
func ( opts * Options ) Validate ( ) error { if len ( opts . Name ) = = 0 { return errors . New ( " " ) } if len ( opts . Actions ) = = 0 { return errors . New ( " " ) } if opts . App . Is Zero ( ) { opts . App = meta . New ( " " ) } if len ( opts . Method ) = = 0 { opts . Method = " " } return nil } 
func ( f Send Func ) Send ( from string , to [ ] string , msg io . Writer To ) error { return f ( from , to , msg ) } 
func Send ( s Sender , msg . . . * Message ) error { for i , m : = range msg { if err : = send ( s , m ) ; err ! = nil { return & Send Error { Cause : err , Index : uint ( i ) } } } return nil } 
func ( opts Options ) Last ( n name . Ident ) bool { return opts . Parts [ len ( opts . Parts ) - 1 ] . String ( ) = = n . String ( ) } 
func ( opts * Options ) Validate ( ) error { if len ( opts . Args ) = = 0 { return errors . New ( " " ) } opts . Namespaced = strings . Contains ( opts . Args [ 0 ] , " " ) for _ , n : = range strings . Split ( opts . Args [ 0 ] , " " ) { opts . Parts = append ( opts . Parts , name . New ( n ) ) } opts . Name = opts . Parts [ len ( opts . Parts ) - 1 ] return nil } 
func ( a * App ) Serve ( srvs . . . servers . Server ) error { a . Logger . Infof ( " " , a . Options . Addr ) payload : = events . Payload { " " : a , } if err : = events . Emit Payload ( Evt App Start , payload ) ; err ! = nil { return err } if len ( srvs ) = = 0 { if strings . Has Prefix ( a . Options . Addr , " " ) { tcp , err : = servers . Unix Socket ( a . Options . Addr [ 5 : ] ) if err ! = nil { return err } srvs = append ( srvs , tcp ) } else { srvs = append ( srvs , servers . New ( ) ) } } ctx , cancel : = sigtx . With Cancel ( a . Context , syscall . SIGTERM , os . Interrupt ) defer cancel ( ) go func ( ) { a . Logger . Info ( " " ) events . Emit Error ( Evt App Stop , ctx . Err ( ) , payload ) if err : = a . Stop ( ctx . Err ( ) ) ; err ! = nil { events . Emit Error ( Evt App Stop Err , err , payload ) a . Logger . Error ( err ) } if ! a . Worker Off { events . Emit Payload ( Evt Worker Stop , payload ) if err : = a . Worker . Stop ( ) ; err ! = nil { events . Emit Error ( Evt Worker Stop Err , err , payload ) a . Logger . Error ( err ) } } for _ , s : = range srvs { if err : = s . Shutdown ( ctx ) ; err ! = nil { a . Logger . Error ( err ) } } } ( ) if err : = a . Worker . Start ( ctx ) ; err ! = nil { a . Stop ( err ) } } ( ) } for _ , s : = range srvs { s . Set Addr ( a . Addr ) go func ( s servers . Server ) { if err : = s . Start ( ctx , a ) ; err ! = nil { a . Stop ( err ) } } ( s ) } < - ctx . Done ( ) return a . Context . Err ( ) } 
func ( a * App ) Stop ( err error ) error { a . cancel ( ) if err ! = nil & & errors . Cause ( err ) ! = context . Canceled { a . Logger . Error ( err ) return err } return nil } 
func Dep Ensure ( r * Runner ) error { if r . App . With Pop { upkg = append ( upkg , " " , " " ) } if ! r . App . With Dep { fmt . Println ( " " ) return mod Get Update ( r ) } fmt . Println ( " " ) return run Dep Ensure ( r ) } 
func Plain ( names . . . string ) Renderer { e : = New ( Options { } ) return e . Plain ( names . . . ) } 
func ( e * Engine ) Plain ( names . . . string ) Renderer { hr : = & template Renderer { Engine : e , content Type : " " , names : names , } return hr } 
func ( b Build Info ) String ( ) string { return fmt . Sprintf ( " " , b . Version , b . Time ) } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , err } if ! opts . Skip Templates { core : = packr . New ( " " , " " ) if err : = g . Box ( core ) ; err ! = nil { return g , err } } var abox packd . Box if opts . Skip Model { abox = packr . New ( " " , " " ) } else { abox = packr . New ( " " , " " ) } if err : = g . Box ( abox ) ; err ! = nil { return g , err } pres : = presenter { App : opts . App , Name : name . New ( opts . Name ) , Model : name . New ( opts . Model ) , Attrs : opts . Attrs , } x : = pres . Name . Resource ( ) . File ( ) . String ( ) folder : = pres . Name . Folder ( ) . Pluralize ( ) . String ( ) g . Transformer ( genny . Replace ( " " , x ) ) g . Transformer ( genny . Replace ( " " , x ) ) g . Transformer ( genny . Replace ( " " , folder ) ) data : = map [ string ] interface { } { " " : pres , " " : actions ( opts ) , " " : folder , } helpers : = template . Func Map { " " : func ( s string ) string { return flect . Camelize ( s ) } , } g . Transformer ( gogen . Template Transformer ( data , helpers ) ) g . Run Fn ( install Pop ( opts ) ) g . Run Fn ( add Resource ( pres ) ) return g , nil } 
func ( m * Message ) Add Body ( r render . Renderer , data render . Data ) error { buf : = bytes . New Buffer ( [ ] byte { } ) err : = r . Render ( buf , m . merge ( data ) ) if err ! = nil { return err } m . Bodies = append ( m . Bodies , Body { Content : buf . String ( ) , Content Type : r . Content Type ( ) , } ) return nil } 
func ( m * Message ) Add Bodies ( data render . Data , renderers . . . render . Renderer ) error { for _ , r : = range renderers { err : = m . Add Body ( r , data ) if err ! = nil { return err } } return nil } 
func ( m * Message ) Add Attachment ( name , content Type string , r io . Reader ) error { m . Attachments = append ( m . Attachments , Attachment { Name : name , Content Type : content Type , Reader : r , Embedded : false , } ) return nil } 
func ( m * Message ) Add Embedded ( name string , r io . Reader ) error { m . Attachments = append ( m . Attachments , Attachment { Name : name , Reader : r , Embedded : true , } ) return nil } 
func ( m * Message ) Set Header ( field , value string ) { m . Headers [ field ] = value } 
func New ( opts * Options ) ( * genny . Group , error ) { if err : = opts . Validate ( ) ; err ! = nil { return nil , err } gg , err : = core . New ( opts . Options ) if err ! = nil { return gg , err } g : = genny . New ( ) g . Transformer ( genny . Dot ( ) ) data : = map [ string ] interface { } { " " : opts , } helpers : = template . Func Map { } t : = gogen . Template Transformer ( data , helpers ) g . Transformer ( t ) g . Box ( packr . New ( " " , " " ) ) gg . Add ( g ) if opts . Webpack ! = nil { if err ! = nil { return gg , err } gg . Add ( g ) } if opts . Standard ! = nil { if err ! = nil { return gg , err } gg . Add ( g ) } return gg , nil } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) g . Box ( packr . New ( " " , " " ) ) data : = map [ string ] interface { } { } h : = template . Func Map { } t : = gogen . Template Transformer ( data , h ) g . Transformer ( t ) g . Run Fn ( func ( r * genny . Runner ) error { f , err : = r . Find File ( " " ) if err ! = nil { return err } s : = strings . Replace ( f . String ( ) , " " , " \n " + bs 4 , 1 ) return r . File ( genny . New File S ( f . Name ( ) , s ) ) } ) return g , nil } 
func New ( opts * Options ) ( * genny . Generator , error ) { g : = genny . New ( ) if err : = opts . Validate ( ) ; err ! = nil { return g , errors . With Stack ( err ) } g . Run Fn ( app Details ( opts ) ) c Box : = packr . Folder ( filepath . Join ( opts . App . Root , " " ) ) g . Run Fn ( configs ( opts , c Box ) ) a Box : = packr . Folder ( opts . App . Root ) g . Run Fn ( pkg Checks ( opts , a Box ) ) return g , nil } 
func Cleanup ( opts * Options ) genny . Run Fn { return func ( r * genny . Runner ) error { defer os . Remove All ( filepath . Join ( opts . Root , " " ) ) if err : = jam . Clean ( ) ; err ! = nil { return err } var err error opts . rollback . Range ( func ( k , v interface { } ) bool { f : = genny . New File S ( k . ( string ) , v . ( string ) ) r . Logger . Debugf ( " " , f . Name ( ) ) if err = r . File ( f ) ; err ! = nil { return false } r . Disk . Remove ( f . Name ( ) ) return true } ) if err ! = nil { return err } for _ , f : = range r . Disk . Files ( ) { if err : = r . Disk . Delete ( f . Name ( ) ) ; err ! = nil { return err } } if envy . Mods ( ) { if err : = r . Exec ( exec . Command ( genny . Go Bin ( ) , " " , " " ) ) ; err ! = nil { return err } } return nil } } 
func ( opts * Options ) Validate ( ) error { if opts . Options = = nil { opts . Options = & core . Options { } } return opts . Options . Validate ( ) } 
func HTML ( names . . . string ) Renderer { e : = New ( Options { } ) return e . HTML ( names . . . ) } 
func ( e * Engine ) HTML ( names . . . string ) Renderer { if e . HTMLLayout ! = " " & & len ( names ) = = 1 { names = append ( names , e . HTMLLayout ) } hr : = & template Renderer { Engine : e , content Type : " " , names : names , } return hr } 
func MDTemplate Engine ( input string , data map [ string ] interface { } , helpers map [ string ] interface { } ) ( string , error ) { if ct , ok : = data [ " " ] . ( string ) ; ok & & ct = = " " { return plush . Buffalo Renderer ( input , data , helpers ) } source : = github _flavored _markdown . Markdown ( [ ] byte ( input ) ) source = [ ] byte ( html . Unescape String ( string ( source ) ) ) return plush . Buffalo Renderer ( string ( source ) , data , helpers ) } 
func Update ( fg File Getter , kc corev 1 . Config Map Interface , name , namespace string , updates [ ] Config Map Update , logger * logrus . Entry ) error { cm , get Err : = kc . Get ( name , metav 1 . Get Options { } ) is Not Found : = errors . Is Not Found ( get Err ) if get Err ! = nil & & ! is Not Found { return fmt . Errorf ( " " , get Err ) } if cm = = nil | | is Not Found { cm = & coreapi . Config Map { Object Meta : metav 1 . Object Meta { Name : name , Namespace : namespace , } , } } if cm . Data = = nil { cm . Data = map [ string ] string { } } if cm . Binary Data = = nil { cm . Binary Data = map [ string ] [ ] byte { } } for _ , upd : = range updates { if upd . Filename = = " " { logger . With Field ( " " , upd . Key ) . Debug ( " " ) delete ( cm . Data , upd . Key ) delete ( cm . Binary Data , upd . Key ) continue } content , err : = fg . Get File ( upd . Filename ) if err ! = nil { return fmt . Errorf ( " " , err ) } logger . With Fields ( logrus . Fields { " " : upd . Key , " " : upd . Filename } ) . Debug ( " " ) value : = content if upd . GZIP { buff : = bytes . New Buffer ( [ ] byte { } ) if _ , err : = z . Write ( content ) ; err ! = nil { logger . With Error ( err ) . Error ( " " ) } else { if err : = z . Close ( ) ; err ! = nil { logger . With Error ( err ) . Error ( " " ) } else { value = buff . Bytes ( ) } } } if utf 8 . Valid String ( string ( value ) ) { delete ( cm . Binary Data , upd . Key ) cm . Data [ upd . Key ] = string ( value ) } else { delete ( cm . Data , upd . Key ) cm . Binary Data [ upd . Key ] = value } } var update Err error var verb string if get Err ! = nil & & is Not Found { verb = " " _ , update Err = kc . Create ( cm ) } else { verb = " " _ , update Err = kc . Update ( cm ) } if update Err ! = nil { return fmt . Errorf ( " " , verb , update Err ) } return nil } 
func Filter Changes ( cfg plugins . Config Updater , changes [ ] github . Pull Request Change , log * logrus . Entry ) map [ Config Map ID ] [ ] Config Map Update { to Update : = map [ Config Map ID ] [ ] Config Map Update { } for _ , change : = range changes { var cm plugins . Config Map Spec found : = false for key , config Map : = range cfg . Maps { var match Err error found , match Err = zglob . Match ( key , change . Filename ) if match Err ! = nil { continue } if found { cm = config Map break } } if ! found { continue } key : = cm . Key if key = = " " { key = path . Base ( change . Filename ) } } if change . Status = = github . Pull Request File Removed { to Update [ id ] = append ( to Update [ id ] , Config Map Update { Key : key } ) } else { gzip : = cfg . GZIP if cm . GZIP ! = nil { gzip = * cm . GZIP } to Update [ id ] = append ( to Update [ id ] , Config Map Update { Key : key , Filename : change . Filename , GZIP : gzip } ) } } } return to Update } 
func get Labels From REMatches ( matches [ ] [ ] string ) ( labels [ ] string ) { for _ , match : = range matches { for _ , label : = range strings . Split ( match [ 0 ] , " " ) [ 1 : ] { label = strings . To Lower ( match [ 1 ] + " " + strings . Trim Space ( label ) ) labels = append ( labels , label ) } } return } 
func get Labels From Generic Matches ( matches [ ] [ ] string , additional Labels [ ] string ) [ ] string { if len ( additional Labels ) = = 0 { return nil } var labels [ ] string for _ , match : = range matches { parts : = strings . Split ( match [ 0 ] , " " ) if ( ( parts [ 0 ] ! = " " ) & & ( parts [ 0 ] ! = " " ) ) | | len ( parts ) ! = 2 { continue } for _ , l : = range additional Labels { if l = = parts [ 1 ] { labels = append ( labels , parts [ 1 ] ) } } } return labels } 
func ( ca * Agent ) Start ( prow Config , job Config string ) error { c , err : = Load ( prow Config , job Config ) if err ! = nil { return err } ca . Set ( c ) go func ( ) { var last Mod Time time . Time for range time . Tick ( 1 * time . Second ) { if skips < 6 0 0 { if err ! = nil { logrus . With Field ( " " , prow Config ) . With Error ( err ) . Error ( " " ) continue } recent Mod Time : = prow Stat . Mod Time ( ) if err ! = nil { logrus . With Field ( " " , job Config ) . With Error ( err ) . Error ( " " ) continue } if job Config Stat . Mod Time ( ) . After ( recent Mod Time ) { recent Mod Time = job Config Stat . Mod Time ( ) } } if ! recent Mod Time . After ( last Mod Time ) { skips + + continue } last Mod Time = recent Mod Time } if c , err : = Load ( prow Config , job Config ) ; err ! = nil { logrus . With Field ( " " , prow Config ) . With Field ( " " , job Config ) . With Error ( err ) . Error ( " " ) } else { skips = 0 ca . Set ( c ) } } } ( ) return nil } 
func ( ca * Agent ) Subscribe ( subscription Delta Chan ) { ca . mut . Lock ( ) defer ca . mut . Unlock ( ) ca . subscriptions = append ( ca . subscriptions , subscription ) } 
func ( ca * Agent ) Config ( ) * Config { ca . mut . RLock ( ) defer ca . mut . RUnlock ( ) return ca . c } 
func ( ca * Agent ) Set ( c * Config ) { ca . mut . Lock ( ) defer ca . mut . Unlock ( ) var old Config Config if ca . c ! = nil { old Config = * ca . c } delta : = Delta { old Config , * c } ca . c = c for _ , subscription : = range ca . subscriptions { go func ( sub Delta Chan ) { select { case sub < - delta : case < - end . C : } if ! end . Stop ( ) { } } ( subscription ) } } 
func ( f * Fake Client ) Is Member ( org , user string ) ( bool , error ) { for _ , m : = range f . Org Members [ org ] { if m = = user { return true , nil } } return false , nil } 
func ( f * Fake Client ) List Issue Comments ( owner , repo string , number int ) ( [ ] github . Issue Comment , error ) { return append ( [ ] github . Issue Comment { } , f . Issue Comments [ number ] . . . ) , nil } 
func ( f * Fake Client ) List Pull Request Comments ( owner , repo string , number int ) ( [ ] github . Review Comment , error ) { return append ( [ ] github . Review Comment { } , f . Pull Request Comments [ number ] . . . ) , nil } 
func ( f * Fake Client ) List Reviews ( owner , repo string , number int ) ( [ ] github . Review , error ) { return append ( [ ] github . Review { } , f . Reviews [ number ] . . . ) , nil } 
func ( f * Fake Client ) List Issue Events ( owner , repo string , number int ) ( [ ] github . Listed Issue Event , error ) { return append ( [ ] github . Listed Issue Event { } , f . Issue Events [ number ] . . . ) , nil } 
func ( f * Fake Client ) Create Comment ( owner , repo string , number int , comment string ) error { f . Issue Comments Added = append ( f . Issue Comments Added , fmt . Sprintf ( " " , owner , repo , number , comment ) ) f . Issue Comments [ number ] = append ( f . Issue Comments [ number ] , github . Issue Comment { ID : f . Issue Comment ID , Body : comment , User : github . User { Login : bot Name } , } ) f . Issue Comment ID + + return nil } 
func ( f * Fake Client ) Create Review ( org , repo string , number int , r github . Draft Review ) error { f . Reviews [ number ] = append ( f . Reviews [ number ] , github . Review { ID : f . Review ID , User : github . User { Login : bot Name } , Body : r . Body , } ) f . Review ID + + return nil } 
func ( f * Fake Client ) Create Comment Reaction ( org , repo string , ID int , reaction string ) error { f . Comment Reactions Added = append ( f . Comment Reactions Added , fmt . Sprintf ( " " , org , repo , ID , reaction ) ) return nil } 
func ( f * Fake Client ) Create Issue Reaction ( org , repo string , ID int , reaction string ) error { f . Issue Reactions Added = append ( f . Issue Reactions Added , fmt . Sprintf ( " " , org , repo , ID , reaction ) ) return nil } 
func ( f * Fake Client ) Delete Comment ( owner , repo string , ID int ) error { f . Issue Comments Deleted = append ( f . Issue Comments Deleted , fmt . Sprintf ( " " , owner , repo , ID ) ) for num , ics : = range f . Issue Comments { for i , ic : = range ics { if ic . ID = = ID { f . Issue Comments [ num ] = append ( ics [ : i ] , ics [ i + 1 : ] . . . ) return nil } } } return fmt . Errorf ( " " , ID ) } 
func ( f * Fake Client ) Delete Stale Comments ( org , repo string , number int , comments [ ] github . Issue Comment , is Stale func ( github . Issue Comment ) bool ) error { if comments = = nil { comments , _ = f . List Issue Comments ( org , repo , number ) } for _ , comment : = range comments { if is Stale ( comment ) { if err : = f . Delete Comment ( org , repo , comment . ID ) ; err ! = nil { return fmt . Errorf ( " " , comment . ID ) } } } return nil } 
func ( f * Fake Client ) Get Pull Request ( owner , repo string , number int ) ( * github . Pull Request , error ) { val , exists : = f . Pull Requests [ number ] if ! exists { return nil , fmt . Errorf ( " " , number ) } return val , nil } 
func ( f * Fake Client ) Get Pull Request Changes ( org , repo string , number int ) ( [ ] github . Pull Request Change , error ) { return f . Pull Request Changes [ number ] , nil } 
func ( f * Fake Client ) Get Ref ( owner , repo , ref string ) ( string , error ) { return Test Ref , nil } 
func ( f * Fake Client ) Delete Ref ( owner , repo , ref string ) error { f . Refs Deleted = append ( f . Refs Deleted , struct { Org , Repo , Ref string } { Org : owner , Repo : repo , Ref : ref } ) return nil } 
func ( f * Fake Client ) Get Single Commit ( org , repo , SHA string ) ( github . Single Commit , error ) { return f . Commits [ SHA ] , nil } 
func ( f * Fake Client ) Create Status ( owner , repo , SHA string , s github . Status ) error { if f . Created Statuses = = nil { f . Created Statuses = make ( map [ string ] [ ] github . Status ) } statuses : = f . Created Statuses [ SHA ] var updated bool for i : = range statuses { if statuses [ i ] . Context = = s . Context { statuses [ i ] = s updated = true } } if ! updated { statuses = append ( statuses , s ) } f . Created Statuses [ SHA ] = statuses return nil } 
func ( f * Fake Client ) List Statuses ( org , repo , ref string ) ( [ ] github . Status , error ) { return f . Created Statuses [ ref ] , nil } 
func ( f * Fake Client ) Get Combined Status ( owner , repo , ref string ) ( * github . Combined Status , error ) { return f . Combined Statuses [ ref ] , nil } 
func ( f * Fake Client ) Get Repo Labels ( owner , repo string ) ( [ ] github . Label , error ) { la : = [ ] github . Label { } for _ , l : = range f . Repo Labels Existing { la = append ( la , github . Label { Name : l } ) } return la , nil } 
func ( f * Fake Client ) Get Issue Labels ( owner , repo string , number int ) ( [ ] github . Label , error ) { re : = regexp . Must Compile ( fmt . Sprintf ( ` ^ %s / %s # %d : ( . * ) $ ` , owner , repo , number ) ) la : = [ ] github . Label { } all Labels : = sets . New String ( f . Issue Labels Existing . . . ) all Labels . Insert ( f . Issue Labels Added . . . ) all Labels . Delete ( f . Issue Labels Removed . . . ) for _ , l : = range all Labels . List ( ) { groups : = re . Find String Submatch ( l ) if groups ! = nil { la = append ( la , github . Label { Name : groups [ 1 ] } ) } } return la , nil } 
func ( f * Fake Client ) Add Label ( owner , repo string , number int , label string ) error { label String : = fmt . Sprintf ( " " , owner , repo , number , label ) if sets . New String ( f . Issue Labels Added . . . ) . Has ( label String ) { return fmt . Errorf ( " " , label , owner , repo , number ) } if f . Repo Labels Existing = = nil { f . Issue Labels Added = append ( f . Issue Labels Added , label String ) return nil } for _ , l : = range f . Repo Labels Existing { if label = = l { f . Issue Labels Added = append ( f . Issue Labels Added , label String ) return nil } } return fmt . Errorf ( " " , label , owner , repo , number ) } 
func ( f * Fake Client ) Remove Label ( owner , repo string , number int , label string ) error { label String : = fmt . Sprintf ( " " , owner , repo , number , label ) if ! sets . New String ( f . Issue Labels Removed . . . ) . Has ( label String ) { f . Issue Labels Removed = append ( f . Issue Labels Removed , label String ) return nil } return fmt . Errorf ( " " , label , owner , repo , number ) } 
func ( f * Fake Client ) Find Issues ( query , sort string , asc bool ) ( [ ] github . Issue , error ) { return f . Issues , nil } 
func ( f * Fake Client ) Assign Issue ( owner , repo string , number int , assignees [ ] string ) error { var m github . Missing Users for _ , a : = range assignees { if a = = " " { m . Users = append ( m . Users , a ) continue } f . Assignees Added = append ( f . Assignees Added , fmt . Sprintf ( " " , owner , repo , number , a ) ) } if m . Users = = nil { return nil } return m } 
func ( f * Fake Client ) Get File ( org , repo , file , commit string ) ( [ ] byte , error ) { contents , ok : = f . Remote Files [ file ] if ! ok { return nil , fmt . Errorf ( " " , file ) } if commit = = " " { if master , ok : = contents [ " " ] ; ok { return [ ] byte ( master ) , nil } return nil , fmt . Errorf ( " " , file ) } if content , ok : = contents [ commit ] ; ok { return [ ] byte ( content ) , nil } return nil , fmt . Errorf ( " " , file , commit ) } 
func ( f * Fake Client ) List Teams ( org string ) ( [ ] github . Team , error ) { return [ ] github . Team { { ID : 0 , Name : " " , } , { ID : 4 2 , Name : " " , } , } , nil } 
func ( f * Fake Client ) List Team Members ( team ID int , role string ) ( [ ] github . Team Member , error ) { if role ! = github . Role All { return nil , fmt . Errorf ( " " , role ) } teams : = map [ int ] [ ] github . Team Member { 0 : { { Login : " " } } , 4 2 : { { Login : " " } } , } members , ok : = teams [ team ID ] if ! ok { return [ ] github . Team Member { } , nil } return members , nil } 
func ( f * Fake Client ) Is Collaborator ( org , repo , login string ) ( bool , error ) { normed : = github . Norm Login ( login ) for _ , collab : = range f . Collaborators { if github . Norm Login ( collab ) = = normed { return true , nil } } return false , nil } 
func ( f * Fake Client ) List Collaborators ( org , repo string ) ( [ ] github . User , error ) { result : = make ( [ ] github . User , 0 , len ( f . Collaborators ) ) for _ , login : = range f . Collaborators { result = append ( result , github . User { Login : login } ) } return result , nil } 
func ( f * Fake Client ) Clear Milestone ( org , repo string , issue Num int ) error { f . Milestone = 0 return nil } 
func ( f * Fake Client ) Set Milestone ( org , repo string , issue Num , milestone Num int ) error { if milestone Num < 0 { return fmt . Errorf ( " " ) } f . Milestone = milestone Num return nil } 
func ( f * Fake Client ) List Milestones ( org , repo string ) ( [ ] github . Milestone , error ) { milestones : = [ ] github . Milestone { } for k , v : = range f . Milestone Map { milestones = append ( milestones , github . Milestone { Title : k , Number : v } ) } return milestones , nil } 
func ( f * Fake Client ) List PRCommits ( org , repo string , pr Number int ) ( [ ] github . Repository Commit , error ) { k : = fmt . Sprintf ( " " , org , repo , pr Number ) return f . Commit Map [ k ] , nil } 
func ( f * Fake Client ) Get Repo Projects ( owner , repo string ) ( [ ] github . Project , error ) { return f . Repo Projects [ fmt . Sprintf ( " " , owner , repo ) ] , nil } 
func ( f * Fake Client ) Get Org Projects ( org string ) ( [ ] github . Project , error ) { return f . Repo Projects [ fmt . Sprintf ( " " , org ) ] , nil } 
func ( f * Fake Client ) Get Project Columns ( project ID int ) ( [ ] github . Project Column , error ) { } } } return nil , fmt . Errorf ( " " ) } 
func ( f * Fake Client ) Create Project Card ( column ID int , project Card github . Project Card ) ( * github . Project Card , error ) { if f . Column Cards Map = = nil { f . Column Cards Map = make ( map [ int ] [ ] github . Project Card ) } for project , column IDMap : = range f . Column IDMap { column Name , exists : = column IDMap [ column ID ] if exists { f . Column Cards Map [ column ID ] = append ( f . Column Cards Map [ column ID ] , project Card , ) f . Column = column Name f . Project = project return & project Card , nil } } return nil , fmt . Errorf ( " " , column ID , f . Column IDMap ) } 
func ( f * Fake Client ) Delete Project Card ( project Card ID int ) error { if f . Column Cards Map = = nil { return fmt . Errorf ( " " ) } f . Project = " " f . Column = " " new Cards : = [ ] github . Project Card { } old Column ID : = - 1 for column , cards : = range f . Column Cards Map { removal Index : = - 1 for i , existing Card : = range cards { if existing Card . Content ID = = project Card ID { old Column ID = column removal Index = i break } } if removal Index ! = - 1 { new Cards = cards new Cards [ removal Index ] = new Cards [ len ( new Cards ) - 1 ] new Cards = new Cards [ : len ( new Cards ) - 1 ] break } } } return nil } 
func ( f * Fake Client ) Move Project Card ( project Card ID int , new Column ID int ) error { old Column ID : = - 1 project Card : = github . Project Card { } for column , cards : = range f . Column Cards Map { removal Index : = - 1 for i , existing Card : = range cards { if existing Card . Content ID = = project Card ID { old Column ID = column removal Index = i project Card = existing Card break } } if removal Index ! = - 1 { new Cards = cards new Cards [ removal Index ] = new Cards [ len ( new Cards ) - 1 ] new Cards = new Cards [ : len ( new Cards ) - 1 ] } } if old Column ID ! = - 1 { } for project , column IDMap : = range f . Column IDMap { if column Name , exists : = column IDMap [ new Column ID ] ; exists { f . Column = column Name f . Project = project break } } return nil } 
func ( f * Fake Client ) Team Has Member ( team ID int , member Login string ) ( bool , error ) { team Members , _ : = f . List Team Members ( team ID , github . Role All ) for _ , member : = range team Members { if member . Login = = member Login { return true , nil } } return false , nil } 
func ( config * Influx Config ) Add Flags ( cmd * cobra . Command ) { cmd . Persistent Flags ( ) . String Var ( & config . User , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & config . Password , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & config . Host , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & config . DB , " " , " " , " " ) } 
func ( config * Influx Config ) Create Database Client ( ) ( * Influx DB , error ) { client , err : = influxdb . New HTTPClient ( influxdb . HTTPConfig { Addr : config . Host , Username : config . User , Password : config . Password , } ) if err ! = nil { return nil , err } return & Influx DB { client : client , database : config . DB , } , nil } 
func ( i * Influx DB ) Push ( measurement string , tags map [ string ] string , fields map [ string ] interface { } , date time . Time ) error { batch , err : = influxdb . New Batch Points ( influxdb . Batch Points Config { Database : i . database , Precision : " " , } ) if err ! = nil { return err } pt , err : = influxdb . New Point ( measurement , tags , fields , date ) if err ! = nil { return err } batch . Add Point ( pt ) err = i . client . Write ( batch ) if err ! = nil { return err } glog . Infof ( " " , measurement , tags , fields , date ) return nil } 
func New Prow Job With Annotation ( spec prowapi . Prow Job Spec , labels , annotations map [ string ] string ) prowapi . Prow Job { return new Prow Job ( spec , labels , annotations ) } 
func New Prow Job ( spec prowapi . Prow Job Spec , labels map [ string ] string ) prowapi . Prow Job { return new Prow Job ( spec , labels , nil ) } 
func New Presubmit ( pr github . Pull Request , base SHA string , job config . Presubmit , event GUID string ) prowapi . Prow Job { refs : = create Refs ( pr , base SHA ) labels : = make ( map [ string ] string ) for k , v : = range job . Labels { labels [ k ] = v } labels [ github . Event GUID ] = event GUID return New Prow Job ( Presubmit Spec ( job , refs ) , labels ) } 
func Presubmit Spec ( p config . Presubmit , refs prowapi . Refs ) prowapi . Prow Job Spec { pjs : = spec From Job Base ( p . Job Base ) pjs . Type = prowapi . Presubmit Job pjs . Context = p . Context pjs . Report = ! p . Skip Report pjs . Rerun Command = p . Rerun Command if p . Jenkins Spec ! = nil { pjs . Jenkins Spec = & prowapi . Jenkins Spec { Git Hub Branch Source Job : p . Jenkins Spec . Git Hub Branch Source Job , } } pjs . Refs = complete Primary Refs ( refs , p . Job Base ) return pjs } 
func Postsubmit Spec ( p config . Postsubmit , refs prowapi . Refs ) prowapi . Prow Job Spec { pjs : = spec From Job Base ( p . Job Base ) pjs . Type = prowapi . Postsubmit Job pjs . Context = p . Context pjs . Report = ! p . Skip Report pjs . Refs = complete Primary Refs ( refs , p . Job Base ) if p . Jenkins Spec ! = nil { pjs . Jenkins Spec = & prowapi . Jenkins Spec { Git Hub Branch Source Job : p . Jenkins Spec . Git Hub Branch Source Job , } } return pjs } 
func Periodic Spec ( p config . Periodic ) prowapi . Prow Job Spec { pjs : = spec From Job Base ( p . Job Base ) pjs . Type = prowapi . Periodic Job return pjs } 
func Batch Spec ( p config . Presubmit , refs prowapi . Refs ) prowapi . Prow Job Spec { pjs : = spec From Job Base ( p . Job Base ) pjs . Type = prowapi . Batch Job pjs . Context = p . Context pjs . Refs = complete Primary Refs ( refs , p . Job Base ) return pjs } 
func Partition Active ( pjs [ ] prowapi . Prow Job ) ( pending , triggered chan prowapi . Prow Job ) { for _ , pj : = range pjs { switch pj . Status . State { case prowapi . Pending State : pending Count + + case prowapi . Triggered State : triggered Count + + } } pending = make ( chan prowapi . Prow Job , pending Count ) triggered = make ( chan prowapi . Prow Job , triggered Count ) case prowapi . Triggered State : triggered < - pj } } close ( pending ) close ( triggered ) return pending , triggered } 
func Prow Job Fields ( pj * prowapi . Prow Job ) logrus . Fields { fields : = make ( logrus . Fields ) fields [ " " ] = pj . Object Meta . Name fields [ " " ] = pj . Spec . Job fields [ " " ] = pj . Spec . Type if len ( pj . Object Meta . Labels [ github . Event GUID ] ) > 0 { fields [ github . Event GUID ] = pj . Object Meta . Labels [ github . Event GUID ] } if pj . Spec . Refs ! = nil & & len ( pj . Spec . Refs . Pulls ) = = 1 { fields [ github . Pr Log Field ] = pj . Spec . Refs . Pulls [ 0 ] . Number fields [ github . Repo Log Field ] = pj . Spec . Refs . Repo fields [ github . Org Log Field ] = pj . Spec . Refs . Org } if pj . Spec . Jenkins Spec ! = nil { fields [ " " ] = pj . Spec . Jenkins Spec . Git Hub Branch Source Job } return fields } 
func Job URL ( plank config . Plank , pj prowapi . Prow Job , log * logrus . Entry ) string { if pj . Spec . Decoration Config ! = nil & & plank . Get Job URLPrefix ( pj . Spec . Refs ) ! = " " { spec : = downwardapi . New Job Spec ( pj . Spec , pj . Status . Build ID , pj . Name ) gcs Config : = pj . Spec . Decoration Config . GCSConfiguration _ , gcs Path , _ : = gcsupload . Paths For Job ( gcs Config , & spec , " " ) prefix , _ : = url . Parse ( plank . Get Job URLPrefix ( pj . Spec . Refs ) ) prefix . Path = path . Join ( prefix . Path , gcs Config . Bucket , gcs Path ) return prefix . String ( ) } var b bytes . Buffer if err : = plank . Job URLTemplate . Execute ( & b , & pj ) ; err ! = nil { log . With Fields ( Prow Job Fields ( & pj ) ) . Errorf ( " " , err ) } else { return b . String ( ) } return " " } 
func Cluster To Ctx ( cluster string ) string { if cluster = = kube . In Cluster Context { return kube . Default Cluster Alias } return cluster } 
func ( plugin Help * Plugin Help ) Add Command ( command Command ) { plugin Help . Commands = append ( plugin Help . Commands , command ) } 
func ( c * Fake Prow Jobs ) Get ( name string , options v 1 . Get Options ) ( result * prowjobsv 1 . Prow Job , err error ) { obj , err : = c . Fake . Invokes ( testing . New Get Action ( prowjobs Resource , c . ns , name ) , & prowjobsv 1 . Prow Job { } ) if obj = = nil { return nil , err } return obj . ( * prowjobsv 1 . Prow Job ) , err } 
func ( c * Fake Prow Jobs ) List ( opts v 1 . List Options ) ( result * prowjobsv 1 . Prow Job List , err error ) { obj , err : = c . Fake . Invokes ( testing . New List Action ( prowjobs Resource , prowjobs Kind , c . ns , opts ) , & prowjobsv 1 . Prow Job List { } ) if obj = = nil { return nil , err } label , _ , _ : = testing . Extract From List Options ( opts ) if label = = nil { label = labels . Everything ( ) } list : = & prowjobsv 1 . Prow Job List { List Meta : obj . ( * prowjobsv 1 . Prow Job List ) . List Meta } for _ , item : = range obj . ( * prowjobsv 1 . Prow Job List ) . Items { if label . Matches ( labels . Set ( item . Labels ) ) { list . Items = append ( list . Items , item ) } } return list , err } 
func ( c * Fake Prow Jobs ) Watch ( opts v 1 . List Options ) ( watch . Interface , error ) { return c . Fake . Invokes Watch ( testing . New Watch Action ( prowjobs Resource , c . ns , opts ) ) } 
func ( c * Fake Prow Jobs ) Create ( prow Job * prowjobsv 1 . Prow Job ) ( result * prowjobsv 1 . Prow Job , err error ) { obj , err : = c . Fake . Invokes ( testing . New Create Action ( prowjobs Resource , c . ns , prow Job ) , & prowjobsv 1 . Prow Job { } ) if obj = = nil { return nil , err } return obj . ( * prowjobsv 1 . Prow Job ) , err } 
func ( c * Fake Prow Jobs ) Update ( prow Job * prowjobsv 1 . Prow Job ) ( result * prowjobsv 1 . Prow Job , err error ) { obj , err : = c . Fake . Invokes ( testing . New Update Action ( prowjobs Resource , c . ns , prow Job ) , & prowjobsv 1 . Prow Job { } ) if obj = = nil { return nil , err } return obj . ( * prowjobsv 1 . Prow Job ) , err } 
func ( c * Fake Prow Jobs ) Update Status ( prow Job * prowjobsv 1 . Prow Job ) ( * prowjobsv 1 . Prow Job , error ) { obj , err : = c . Fake . Invokes ( testing . New Update Subresource Action ( prowjobs Resource , " " , c . ns , prow Job ) , & prowjobsv 1 . Prow Job { } ) if obj = = nil { return nil , err } return obj . ( * prowjobsv 1 . Prow Job ) , err } 
func ( c * Fake Prow Jobs ) Delete ( name string , options * v 1 . Delete Options ) error { _ , err : = c . Fake . Invokes ( testing . New Delete Action ( prowjobs Resource , c . ns , name ) , & prowjobsv 1 . Prow Job { } ) return err } 
func ( c * Fake Prow Jobs ) Delete Collection ( options * v 1 . Delete Options , list Options v 1 . List Options ) error { action : = testing . New Delete Collection Action ( prowjobs Resource , c . ns , list Options ) _ , err : = c . Fake . Invokes ( action , & prowjobsv 1 . Prow Job List { } ) return err } 
func ( c * Fake Prow Jobs ) Patch ( name string , pt types . Patch Type , data [ ] byte , subresources . . . string ) ( result * prowjobsv 1 . Prow Job , err error ) { obj , err : = c . Fake . Invokes ( testing . New Patch Subresource Action ( prowjobs Resource , c . ns , name , data , subresources . . . ) , & prowjobsv 1 . Prow Job { } ) if obj = = nil { return nil , err } return obj . ( * prowjobsv 1 . Prow Job ) , err } 
func ( t * Tide ) Merge Method ( org , repo string ) github . Pull Request Merge Type { name : = org + " " + repo v , ok : = t . Merge Type [ name ] if ! ok { if ov , found : = t . Merge Type [ org ] ; found { return ov } return github . Merge Merge } return v } 
func ( t * Tide ) Merge Commit Template ( org , repo string ) Tide Merge Commit Template { name : = org + " " + repo v , ok : = t . Merge Template [ name ] if ! ok { return t . Merge Template [ org ] } return v } 
func ( tq * Tide Query ) Query ( ) string { toks : = [ ] string { " " , " " } for _ , o : = range tq . Orgs { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , o ) ) } for _ , r : = range tq . Repos { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , r ) ) } for _ , r : = range tq . Excluded Repos { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , r ) ) } for _ , b : = range tq . Excluded Branches { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , b ) ) } for _ , b : = range tq . Included Branches { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , b ) ) } for _ , l : = range tq . Labels { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , l ) ) } for _ , l : = range tq . Missing Labels { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , l ) ) } if tq . Milestone ! = " " { toks = append ( toks , fmt . Sprintf ( " \ " \ " " , tq . Milestone ) ) } if tq . Review Approved Required { toks = append ( toks , " " ) } return strings . Join ( toks , " " ) } 
func ( tq Tide Query ) For Repo ( org , repo string ) bool { full Name : = fmt . Sprintf ( " " , org , repo ) for _ , query Org : = range tq . Orgs { if query Org ! = org { continue } } } return true } for _ , query Repo : = range tq . Repos { if query Repo = = full Name { return true } } return false } 
func ( tqs Tide Queries ) Org Exceptions And Repos ( ) ( map [ string ] sets . String , sets . String ) { orgs : = make ( map [ string ] sets . String ) for i : = range tqs { for _ , org : = range tqs [ i ] . Orgs { applicable Repos : = sets . New String ( repos In Org ( org , tqs [ i ] . Excluded Repos ) . . . ) if excepts , ok : = orgs [ org ] ; ! ok { } else { } } } repos : = sets . New String ( ) for i : = range tqs { repos . Insert ( tqs [ i ] . Repos . . . ) } for _ , excepts : = range orgs { excepts . Delete ( repos List . . . ) } return orgs , repos } 
func ( tqs Tide Queries ) Query Map ( ) * Query Map { return & Query Map { queries : tqs , cache : make ( map [ string ] Tide Queries ) , } } 
func ( qm * Query Map ) For Repo ( org , repo string ) Tide Queries { res : = Tide Queries ( nil ) full Name : = fmt . Sprintf ( " " , org , repo ) qm . Lock ( ) defer qm . Unlock ( ) if qs , ok : = qm . cache [ full Name ] ; ok { return append ( res , qs . . . ) } } } qm . cache [ full Name ] = res return res } 
func ( tq * Tide Query ) Validate ( ) error { duplicates : = func ( field string , list [ ] string ) error { dups : = sets . New String ( ) seen : = sets . New String ( ) for _ , elem : = range list { if seen . Has ( elem ) { dups . Insert ( elem ) } else { seen . Insert ( elem ) } } dup Count : = len ( list ) - seen . Len ( ) if dup Count = = 0 { return nil } return fmt . Errorf ( " " , field , dup Count , strings . Join ( dups . List ( ) , " " ) ) } orgs : = sets . New String ( ) for o : = range tq . Orgs { if strings . Contains ( tq . Orgs [ o ] , " " ) { return fmt . Errorf ( " " , o , tq . Orgs [ o ] ) } if len ( tq . Orgs [ o ] ) = = 0 { return fmt . Errorf ( " " , o ) } orgs . Insert ( tq . Orgs [ o ] ) } if err : = duplicates ( " " , tq . Orgs ) ; err ! = nil { return err } for r : = range tq . Repos { parts : = strings . Split ( tq . Repos [ r ] , " " ) if len ( parts ) ! = 2 | | len ( parts [ 0 ] ) = = 0 | | len ( parts [ 1 ] ) = = 0 { return fmt . Errorf ( " \ " \ " " , r , tq . Repos [ r ] ) } if orgs . Has ( parts [ 0 ] ) { return fmt . Errorf ( " " , r , tq . Repos [ r ] , parts [ 0 ] ) } } if err : = duplicates ( " " , tq . Repos ) ; err ! = nil { return err } if len ( tq . Orgs ) = = 0 & & len ( tq . Repos ) = = 0 { return errors . New ( " " ) } for er : = range tq . Excluded Repos { parts : = strings . Split ( tq . Excluded Repos [ er ] , " " ) if len ( parts ) ! = 2 | | len ( parts [ 0 ] ) = = 0 | | len ( parts [ 1 ] ) = = 0 { return fmt . Errorf ( " \ " \ " " , er , tq . Excluded Repos [ er ] ) } if ! orgs . Has ( parts [ 0 ] ) { return fmt . Errorf ( " " , er , tq . Excluded Repos [ er ] , parts [ 0 ] ) } if err : = duplicates ( " " , tq . Excluded Repos ) ; err ! = nil { return err } if invalids : = sets . New String ( tq . Labels . . . ) . Intersection ( sets . New String ( tq . Missing Labels . . . ) ) ; len ( invalids ) > 0 { return fmt . Errorf ( " " , invalids . List ( ) ) } if err : = duplicates ( " " , tq . Labels ) ; err ! = nil { return err } if err : = duplicates ( " " , tq . Missing Labels ) ; err ! = nil { return err } if len ( tq . Excluded Branches ) > 0 & & len ( tq . Included Branches ) > 0 { return errors . New ( " " ) } if err : = duplicates ( " " , tq . Included Branches ) ; err ! = nil { return err } if err : = duplicates ( " " , tq . Excluded Branches ) ; err ! = nil { return err } return nil } 
func ( cp * Tide Context Policy ) Validate ( ) error { if inter : = sets . New String ( cp . Required Contexts . . . ) . Intersection ( sets . New String ( cp . Optional Contexts . . . ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( " " , strings . Join ( inter . List ( ) , " " ) ) } if inter : = sets . New String ( cp . Required Contexts . . . ) . Intersection ( sets . New String ( cp . Required If Present Contexts . . . ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( " " , strings . Join ( inter . List ( ) , " " ) ) } if inter : = sets . New String ( cp . Optional Contexts . . . ) . Intersection ( sets . New String ( cp . Required If Present Contexts . . . ) ) ; inter . Len ( ) > 0 { return fmt . Errorf ( " " , strings . Join ( inter . List ( ) , " " ) ) } return nil } 
func ( c Config ) Get Tide Context Policy ( org , repo , branch string ) ( * Tide Context Policy , error ) { options : = parse Tide Context Policy Options ( org , repo , branch , c . Tide . Context Options ) required If Present : = sets . New String ( options . Required If Present Contexts . . . ) optional : = sets . New String ( options . Optional Contexts . . . ) required . Insert ( prow Required . . . ) required If Present . Insert ( prow Required If Present . . . ) optional . Insert ( prow Optional . . . ) if err ! = nil { logrus . With Error ( err ) . Warningf ( " " , org , repo , branch ) } else if bp ! = nil & & bp . Protect ! = nil & & * bp . Protect & & bp . Required Status Checks ! = nil { required . Insert ( bp . Required Status Checks . Contexts . . . ) } } t : = & Tide Context Policy { Required Contexts : required . List ( ) , Required If Present Contexts : required If Present . List ( ) , Optional Contexts : optional . List ( ) , Skip Unknown Contexts : options . Skip Unknown Contexts , } if err : = t . Validate ( ) ; err ! = nil { return t , err } return t , nil } 
func ( cp * Tide Context Policy ) Is Optional ( c string ) bool { if sets . New String ( cp . Optional Contexts . . . ) . Has ( c ) { return true } if sets . New String ( cp . Required Contexts . . . ) . Has ( c ) { return false } } if cp . Skip Unknown Contexts ! = nil & & * cp . Skip Unknown Contexts { return true } return false } 
func ( cp * Tide Context Policy ) Missing Required Contexts ( contexts [ ] string ) [ ] string { if len ( cp . Required Contexts ) = = 0 { return nil } existing Contexts : = sets . New String ( ) for _ , c : = range contexts { existing Contexts . Insert ( c ) } var missing Contexts [ ] string for c : = range sets . New String ( cp . Required Contexts . . . ) . Difference ( existing Contexts ) { missing Contexts = append ( missing Contexts , c ) } return missing Contexts } 
func Validate Webhook ( w http . Response Writer , r * http . Request , hmac Secret [ ] byte ) ( string , string , [ ] byte , bool , int ) { defer r . Body . Close ( ) } return " " , " " , nil , false , http . Status Method Not Allowed } event Type : = r . Header . Get ( " " ) if event Type = = " " { response HTTPError ( w , http . Status Bad Request , " " ) return " " , " " , nil , false , http . Status Bad Request } event GUID : = r . Header . Get ( " " ) if event GUID = = " " { response HTTPError ( w , http . Status Bad Request , " " ) return " " , " " , nil , false , http . Status Bad Request } sig : = r . Header . Get ( " " ) if sig = = " " { response HTTPError ( w , http . Status Forbidden , " " ) return " " , " " , nil , false , http . Status Forbidden } content Type : = r . Header . Get ( " " ) if content Type ! = " " { response HTTPError ( w , http . Status Bad Request , " " ) return " " , " " , nil , false , http . Status Bad Request } payload , err : = ioutil . Read All ( r . Body ) if err ! = nil { response HTTPError ( w , http . Status Internal Server Error , " " ) return " " , " " , nil , false , http . Status Internal Server Error } return " " , " " , nil , false , http . Status Forbidden } return event Type , event GUID , payload , true , http . Status OK } 
func New For Config Or Die ( c * rest . Config ) * Clientset { var cs Clientset cs . prow V 1 = prowv 1 . New For Config Or Die ( c ) cs . Discovery Client = discovery . New Discovery Client For Config Or Die ( c ) return & cs } 
func New ( c rest . Interface ) * Clientset { var cs Clientset cs . prow V 1 = prowv 1 . New ( c ) cs . Discovery Client = discovery . New Discovery Client ( c ) return & cs } 
func matches ( repo string , repos [ ] string ) bool { org : = strings . Split ( repo , " " ) [ 0 ] for _ , r : = range repos { if r = = repo | | r = = org { return true } } return false } 
func Help Provider ( enabled Repos [ ] string ) ( * pluginhelp . Plugin Help , error ) { return & pluginhelp . Plugin Help { Description : `The needs -rebase plugin manages the ' ` + labels . Needs Rebase + ` ' label by removing it from Pull Requests that are mergeable and adding it to those which are not . The plugin reacts to commit changes on PRs in addition to periodically scanning all open PRs for any changes to mergeability that could have resulted from changes in other PRs . ` , } , nil } 
func Handle Event ( log * logrus . Entry , ghc github Client , pre * github . Pull Request Event ) error { if pre . Action ! = github . Pull Request Action Opened & & pre . Action ! = github . Pull Request Action Synchronize & & pre . Action ! = github . Pull Request Action Reopened { return nil } org : = pre . Repo . Owner . Login repo : = pre . Repo . Name number : = pre . Number sha : = pre . Pull Request . Head . SHA mergeable , err : = ghc . Is Mergeable ( org , repo , number , sha ) if err ! = nil { return err } issue Labels , err : = ghc . Get Issue Labels ( org , repo , number ) if err ! = nil { return err } has Label : = github . Has Label ( labels . Needs Rebase , issue Labels ) return take Action ( log , ghc , org , repo , number , pre . Pull Request . User . Login , has Label , mergeable ) } 
func Handle All ( log * logrus . Entry , ghc github Client , config * plugins . Configuration ) error { log . Info ( " " ) orgs , repos : = config . Enabled Repos For External Plugin ( Plugin Name ) if len ( orgs ) = = 0 & & len ( repos ) = = 0 { log . Warnf ( " " , Plugin Name ) return nil } var buf bytes . Buffer fmt . Fprint ( & buf , " " ) for _ , org : = range orgs { fmt . Fprintf ( & buf , " \ " \ " " , org ) } for _ , repo : = range repos { fmt . Fprintf ( & buf , " \ " \ " " , repo ) } prs , err : = search ( context . Background ( ) , log , ghc , buf . String ( ) ) if err ! = nil { return err } log . Infof ( " " , len ( prs ) ) for _ , pr : = range prs { } org : = string ( pr . Repository . Owner . Login ) repo : = string ( pr . Repository . Name ) num : = int ( pr . Number ) l : = log . With Fields ( logrus . Fields { " " : org , " " : repo , " " : num , } ) has Label : = false for _ , label : = range pr . Labels . Nodes { if label . Name = = labels . Needs Rebase { has Label = true break } } err : = take Action ( l , ghc , org , repo , num , string ( pr . Author . Login ) , has Label , pr . Mergeable = = githubql . Mergeable State Mergeable , ) if err ! = nil { l . With Error ( err ) . Error ( " " ) } } return nil } 
func take Action ( log * logrus . Entry , ghc github Client , org , repo string , num int , author string , has Label , mergeable bool ) error { if ! mergeable & & ! has Label { if err : = ghc . Add Label ( org , repo , num , labels . Needs Rebase ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , labels . Needs Rebase ) } msg : = plugins . Format Simple Response ( author , needs Rebase Message ) return ghc . Create Comment ( org , repo , num , msg ) } else if mergeable & & has Label { } bot Name , err : = ghc . Bot Name ( ) if err ! = nil { return err } return ghc . Delete Stale Comments ( org , repo , num , nil , should Prune ( bot Name ) ) } return nil } 
func New Dry Run Prow Job Client ( deck URL string ) prowv 1 . Prow Job Interface { return & dry Run Prow Job Client { deck URL : deck URL , client : & http . Client { } , } } 
func ( c * dry Run Prow Job Client ) Create ( * prowapi . Prow Job ) ( * prowapi . Prow Job , error ) { return nil , nil } 
func ( c * dry Run Prow Job Client ) Update ( * prowapi . Prow Job ) ( * prowapi . Prow Job , error ) { return nil , nil } 
func ( c * dry Run Prow Job Client ) Update Status ( * prowapi . Prow Job ) ( * prowapi . Prow Job , error ) { return nil , nil } 
func ( c * dry Run Prow Job Client ) Delete ( name string , options * metav 1 . Delete Options ) error { return nil } 
func ( c * dry Run Prow Job Client ) Delete Collection ( options * metav 1 . Delete Options , list Options metav 1 . List Options ) error { return nil } 
func ( c * dry Run Prow Job Client ) Get ( name string , options metav 1 . Get Options ) ( * prowapi . Prow Job , error ) { return nil , nil } 
func ( c * dry Run Prow Job Client ) List ( opts metav 1 . List Options ) ( * prowapi . Prow Job List , error ) { var jl prowapi . Prow Job List err : = c . request ( " " , map [ string ] string { " " : opts . Label Selector } , & jl ) return & jl , err } 
func ( c * dry Run Prow Job Client ) request Retry ( path string , query map [ string ] string ) ( [ ] byte , error ) { resp , err : = c . retry ( path , query ) if err ! = nil { return nil , err } defer resp . Body . Close ( ) rb , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return nil , err } if resp . Status Code = = 4 0 4 { return nil , & kapierrors . Status Error { Err Status : metav 1 . Status { Status : metav 1 . Status Failure , Code : http . Status Not Found , Reason : metav 1 . Status Reason Not Found , } } } else if resp . Status Code = = 4 0 9 { return nil , & kapierrors . Status Error { Err Status : metav 1 . Status { Status : metav 1 . Status Failure , Code : http . Status Conflict , Reason : metav 1 . Status Reason Already Exists , } } } else if resp . Status Code = = 4 2 2 { return nil , & kapierrors . Status Error { Err Status : metav 1 . Status { Status : metav 1 . Status Failure , Code : http . Status Unprocessable Entity , Reason : metav 1 . Status Reason Invalid , } } } else if resp . Status Code < 2 0 0 | | resp . Status Code > 2 9 9 { return nil , fmt . Errorf ( " \ " \ " \ " \ " " , resp . Status , string ( rb ) ) } return rb , nil } 
func ( c * dry Run Prow Job Client ) Watch ( opts metav 1 . List Options ) ( watch . Interface , error ) { return nil , nil } 
func ( c * dry Run Prow Job Client ) Patch ( name string , pt types . Patch Type , data [ ] byte , subresources . . . string ) ( result * prowapi . Prow Job , err error ) { return nil , nil } 
func ( c * controller ) has Synced ( ) bool { if ! c . pj Informer . Has Synced ( ) { if c . wait ! = " " { c . wait = " " ns : = c . pj Namespace ( ) if ns = = " " { ns = " " } logrus . Infof ( " " , ns ) } return false } if ! c . prow Jobs Done { c . prow Jobs Done = true logrus . Info ( " " ) } if c . pipelines Done = = nil { c . pipelines Done = map [ string ] bool { } } for n , cfg : = range c . pipelines { if ! cfg . informer . Informer ( ) . Has Synced ( ) { if c . wait ! = n { c . wait = n logrus . Infof ( " " , n ) } return false } else if ! c . pipelines Done [ n ] { c . pipelines Done [ n ] = true logrus . Infof ( " " , n ) } } return true } 
func ( c * controller ) Run ( threads int , stop < - chan struct { } ) error { defer runtime . Handle Crash ( ) defer c . workqueue . Shut Down ( ) logrus . Info ( " " ) logrus . Info ( " " ) if ok : = cache . Wait For Cache Sync ( stop , c . has Synced ) ; ! ok { return fmt . Errorf ( " " ) } logrus . Info ( " " ) for i : = 0 ; i < threads ; i + + { go wait . Until ( c . run Worker , time . Second , stop ) } logrus . Info ( " " ) < - stop logrus . Info ( " " ) return nil } 
func ( c * controller ) run Worker ( ) { for { key , shutdown : = c . workqueue . Get ( ) if shutdown { return } func ( ) { defer c . workqueue . Done ( key ) if err : = reconcile ( c , key . ( string ) ) ; err ! = nil { runtime . Handle Error ( fmt . Errorf ( " " , key , err ) ) return } c . workqueue . Forget ( key ) } ( ) } } 
func to Key ( ctx , namespace , name string ) string { return strings . Join ( [ ] string { ctx , namespace , name } , " " ) } 
func from Key ( key string ) ( string , string , string , error ) { parts : = strings . Split ( key , " " ) if len ( parts ) ! = 3 { return " " , " " , " " , fmt . Errorf ( " " , key ) } return parts [ 0 ] , parts [ 1 ] , parts [ 2 ] , nil } 
func ( c * controller ) enqueue Key ( ctx string , obj interface { } ) { switch o : = obj . ( type ) { case * prowjobv 1 . Prow Job : ns : = o . Spec . Namespace if ns = = " " { ns = o . Namespace } c . workqueue . Add Rate Limited ( to Key ( ctx , ns , o . Name ) ) case * pipelinev 1alpha 1 . Pipeline Run : c . workqueue . Add Rate Limited ( to Key ( ctx , o . Namespace , o . Name ) ) default : logrus . Warnf ( " " , o , obj ) return } } 
func reconcile ( c reconciler , key string ) error { logrus . Debugf ( " \n " , key ) ctx , namespace , name , err : = from Key ( key ) if err ! = nil { runtime . Handle Error ( err ) return nil } var want Pipeline Run bool pj , err : = c . get Prow Job ( name ) switch { case apierrors . Is Not Found ( err ) : case pj . Spec . Agent ! = prowjobv 1 . Tekton Agent : case pj . Deletion Timestamp = = nil : want Pipeline Run = true } var have Pipeline Run bool p , err : = c . get Pipeline Run ( ctx , namespace , name ) switch { case apierrors . Is Not Found ( err ) : case p . Deletion Timestamp = = nil : have Pipeline Run = true } var new Pipeline Run bool switch { case ! want Pipeline Run : if ! have Pipeline Run { if pj ! = nil & & pj . Spec . Agent = = prowjobv 1 . Tekton Agent { logrus . Infof ( " " , key ) } return nil } } logrus . Infof ( " " , key ) if err = c . delete Pipeline Run ( ctx , namespace , name ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil case final State ( pj . Status . State ) : logrus . Infof ( " " , key ) return nil case want Pipeline Run & & pj . Spec . Pipeline Run Spec = = nil : return fmt . Errorf ( " " , key ) case want Pipeline Run & & ! have Pipeline Run : id , url , err : = c . pipeline ID ( * pj ) if err ! = nil { return fmt . Errorf ( " " , err ) } pj . Status . Build ID = id pj . Status . URL = url new Pipeline Run = true pr : = make Pipeline Git Resource ( * pj ) logrus . Infof ( " " , key ) if pr , err = c . create Pipeline Resource ( ctx , namespace , pr ) ; err ! = nil { return fmt . Errorf ( " " , key , err ) } newp , err : = make Pipeline Run ( * pj , pr ) if err ! = nil { return fmt . Errorf ( " " , key , err ) } logrus . Infof ( " " , key ) p , err = c . create Pipeline Run ( ctx , namespace , newp ) if err ! = nil { jerr : = fmt . Errorf ( " " , err ) } } if p = = nil { return fmt . Errorf ( " " , key , want Pipeline Run ) } want State , want Msg : = prow Job Status ( p . Status ) return update Prow Job State ( c , key , new Pipeline Run , pj , want State , want Msg ) } 
func final State ( status prowjobv 1 . Prow Job State ) bool { switch status { case " " , prowjobv 1 . Pending State , prowjobv 1 . Triggered State : return false } return true } 
func description ( cond duckv 1alpha 1 . Condition , fallback string ) string { switch { case cond . Message ! = " " : return cond . Message case cond . Reason ! = " " : return cond . Reason } return fallback } 
func prow Job Status ( ps pipelinev 1alpha 1 . Pipeline Run Status ) ( prowjobv 1 . Prow Job State , string ) { started : = ps . Start Time finished : = ps . Completion Time pcond : = ps . Get Condition ( duckv 1alpha 1 . Condition Succeeded ) if pcond = = nil { if ! finished . Is Zero ( ) { return prowjobv 1 . Error State , desc Missing Condition } return prowjobv 1 . Triggered State , desc Scheduling } cond : = * pcond switch { case cond . Status = = untypedcorev 1 . Condition True : return prowjobv 1 . Success State , description ( cond , desc Succeeded ) case cond . Status = = untypedcorev 1 . Condition False : return prowjobv 1 . Failure State , description ( cond , desc Failed ) case started . Is Zero ( ) : return prowjobv 1 . Triggered State , description ( cond , desc Initializing ) case cond . Status = = untypedcorev 1 . Condition Unknown , finished . Is Zero ( ) : return prowjobv 1 . Pending State , description ( cond , desc Running ) } logrus . Warnf ( " " , cond ) return prowjobv 1 . Error State , description ( cond , desc Unknown ) } 
func pipeline Meta ( pj prowjobv 1 . Prow Job ) metav 1 . Object Meta { labels , annotations : = decorate . Labels And Annotations For Job ( pj ) return metav 1 . Object Meta { Annotations : annotations , Name : pj . Name , Namespace : pj . Spec . Namespace , Labels : labels , } } 
func source URL ( pj prowjobv 1 . Prow Job ) string { if pj . Spec . Refs = = nil { return " " } source URL : = pj . Spec . Refs . Clone URI if source URL = = " " { source URL = fmt . Sprintf ( " " , pj . Spec . Refs . Repo Link ) } return source URL } 
func make Pipeline Git Resource ( pj prowjobv 1 . Prow Job ) * pipelinev 1alpha 1 . Pipeline Resource { var revision string if pj . Spec . Refs ! = nil { if len ( pj . Spec . Refs . Pulls ) > 0 { revision = pj . Spec . Refs . Pulls [ 0 ] . SHA } else { revision = pj . Spec . Refs . Base SHA } } pr : = pipelinev 1alpha 1 . Pipeline Resource { Object Meta : pipeline Meta ( pj ) , Spec : pipelinev 1alpha 1 . Pipeline Resource Spec { Type : pipelinev 1alpha 1 . Pipeline Resource Type Git , Params : [ ] pipelinev 1alpha 1 . Param { { Name : " " , Value : source URL ( pj ) , } , { Name : " " , Value : revision , } , } , } , } return & pr } 
func make Pipeline Run ( pj prowjobv 1 . Prow Job , pr * pipelinev 1alpha 1 . Pipeline Resource ) ( * pipelinev 1alpha 1 . Pipeline Run , error ) { if pj . Spec . Pipeline Run Spec = = nil { return nil , errors . New ( " " ) } p : = pipelinev 1alpha 1 . Pipeline Run { Object Meta : pipeline Meta ( pj ) , Spec : * pj . Spec . Pipeline Run Spec . Deep Copy ( ) , } build ID : = pj . Status . Build ID if build ID = = " " { return nil , errors . New ( " " ) } p . Spec . Params = append ( p . Spec . Params , pipelinev 1alpha 1 . Param { Name : " " , Value : build ID , } ) rb : = pipelinev 1alpha 1 . Pipeline Resource Binding { Name : pr . Name , Resource Ref : pipelinev 1alpha 1 . Pipeline Resource Ref { Name : pr . Name , APIVersion : pr . APIVersion , } , } p . Spec . Resources = append ( p . Spec . Resources , rb ) return & p , nil } 
func disk Monitor ( interval time . Duration , disk Root string ) { logger : = logrus . With Field ( " " , " " ) ticker : = time . New Ticker ( interval ) for ; true ; < - ticker . C { logger . Info ( " " ) _ , bytes Free , bytes Used , err : = diskutil . Get Disk Usage ( disk Root ) if err ! = nil { logger . With Error ( err ) . Error ( " " ) } else { disk Free . Set ( float 6 4 ( bytes Free ) / 1e 9 ) disk Used . Set ( float 6 4 ( bytes Used ) / 1e 9 ) disk Total . Set ( float 6 4 ( bytes Free + bytes Used ) / 1e 9 ) } } } 
func ( m * Multiplexer Plugin Wrapper ) Receive Issue ( issue sql . Issue ) [ ] Point { points : = [ ] Point { } for _ , plugin : = range m . plugins { points = append ( points , plugin . Receive Issue ( issue ) . . . ) } return points } 
func ( m * Multiplexer Plugin Wrapper ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { points : = [ ] Point { } for _ , plugin : = range m . plugins { points = append ( points , plugin . Receive Issue Event ( event ) . . . ) } return points } 
func ( m * Multiplexer Plugin Wrapper ) Receive Comment ( comment sql . Comment ) [ ] Point { points : = [ ] Point { } for _ , plugin : = range m . plugins { points = append ( points , plugin . Receive Comment ( comment ) . . . ) } return points } 
func matching Configs ( org , repo , branch , label string , all Configs [ ] plugins . Require Matching Label ) [ ] plugins . Require Matching Label { var filtered [ ] plugins . Require Matching Label for _ , cfg : = range all Configs { } } } filtered = append ( filtered , cfg ) } return filtered } 
func Suggest Code Change ( p lint . Problem ) string { var suggestion = " " for regex , handler : = range lint Handlers Map { matches : = regex . Find String Submatch ( p . Text ) suggestion = handler ( p , matches ) if suggestion ! = " " & & suggestion ! = p . Line Text { return format Suggestion ( suggestion ) } } return " " } 
func Serve External Plugin Help ( mux * http . Serve Mux , log * logrus . Entry , provider External Plugin Help Provider ) { mux . Handle Func ( " " , func ( w http . Response Writer , r * http . Request ) { w . Header ( ) . Set ( " " , " " ) server Error : = func ( action string , err error ) { log . With Error ( err ) . Errorf ( " " , action ) msg : = fmt . Sprintf ( " " , action , err ) http . Error ( w , msg , http . Status Internal Server Error ) } if r . Method ! = http . Method Post { log . Errorf ( " " , r . Method ) http . Error ( w , " " , http . Status Method Not Allowed ) return } b , err : = ioutil . Read All ( r . Body ) if err ! = nil { server Error ( " " , err ) return } var enabled Repos [ ] string if err : = json . Unmarshal ( b , & enabled Repos ) ; err ! = nil { server Error ( " " , err ) return } if provider = = nil { server Error ( " " , errors . New ( " " ) ) return } help , err : = provider ( enabled Repos ) if err ! = nil { server Error ( " " , err ) return } b , err = json . Marshal ( help ) if err ! = nil { server Error ( " " , err ) return } fmt . Fprint ( w , string ( b ) ) } , ) } 
func ( p * protector ) protect ( ) { bp : = p . cfg . Branch Protection if err : = p . Update Org ( org Name , * org ) ; err ! = nil { p . errors . add ( fmt . Errorf ( " " , org Name , err ) ) } } } } parts : = strings . Split ( repo , " " ) if len ( parts ) ! = 2 { continue } org Name : = parts [ 0 ] repo Name : = parts [ 1 ] repo : = bp . Get Org ( org Name ) . Get Repo ( repo Name ) if err : = p . Update Repo ( org Name , repo Name , * repo ) ; err ! = nil { p . errors . add ( fmt . Errorf ( " " , org Name , repo Name , err ) ) } } } 
func ( p * protector ) Update Org ( org Name string , org config . Org ) error { var repos [ ] string if org . Protect ! = nil { if err ! = nil { return fmt . Errorf ( " " , err ) } for _ , r : = range rs { if ! r . Archived { repos = append ( repos , r . Name ) } } } else { } } for _ , repo Name : = range repos { repo : = org . Get Repo ( repo Name ) if err : = p . Update Repo ( org Name , repo Name , * repo ) ; err ! = nil { return fmt . Errorf ( " " , repo Name , err ) } } return nil } 
func ( p * protector ) Update Repo ( org Name string , repo Name string , repo config . Repo ) error { p . completed Repos [ org Name + " " + repo Name ] = true github Repo , err : = p . client . Get Repo ( org Name , repo Name ) if err ! = nil { return fmt . Errorf ( " " , err ) } if github Repo . Archived { } branches : = map [ string ] github . Branch { } for _ , only Protected : = range [ ] bool { false , true } { if err ! = nil { return fmt . Errorf ( " " , err ) } for _ , b : = range bs { branches [ b . Name ] = b } } for bn , github Branch : = range branches { if branch , err : = repo . Get Branch ( bn ) ; err ! = nil { return fmt . Errorf ( " " , bn , err ) } else if err = p . Update Branch ( org Name , repo Name , bn , * branch , github Branch . Protected ) ; err ! = nil { return fmt . Errorf ( " " , bn , github Branch . Protected , err ) } } return nil } 
func ( p * protector ) Update Branch ( org Name , repo string , branch Name string , branch config . Branch , protected bool ) error { bp , err : = p . cfg . Get Policy ( org Name , repo , branch Name , branch ) if err ! = nil { return fmt . Errorf ( " " , err ) } if bp = = nil | | bp . Protect = = nil { return nil } if ! protected & & ! * bp . Protect { logrus . Infof ( " " , org Name , repo , branch Name ) return nil } var req * github . Branch Protection Request if * bp . Protect { r : = make Request ( * bp ) req = & r } p . updates < - requirements { Org : org Name , Repo : repo , Branch : branch Name , Request : req , } return nil } 
func ( o * Options ) Validate ( ) error { if o . Num Workers = = 0 { return errors . New ( " " ) } if o . Prow Job Namespace = = " " { return errors . New ( " " ) } return o . Options . Validate ( ) } 
func ( o * Options ) Load Config ( config string ) error { return json . Unmarshal ( [ ] byte ( config ) , o ) } 
func ( o * Options ) Add Flags ( flags * flag . Flag Set ) { flags . Int Var ( & o . Num Workers , " " , 2 5 , " " ) flags . String Var ( & o . Prow Job Namespace , " " , " " , " " ) o . Options . Add Flags ( flags ) } 
func load Cluster Config ( ) ( * rest . Config , error ) { cluster Config , err : = rest . In Cluster Config ( ) if err = = nil { return cluster Config , nil } credentials , err : = clientcmd . New Default Client Config Loading Rules ( ) . Load ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } cluster Config , err = clientcmd . New Default Client Config ( * credentials , & clientcmd . Config Overrides { } ) . Client Config ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return cluster Config , nil } 
func ( o * Options ) Run ( ) error { cluster Config , err : = load Cluster Config ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } client , err : = kubernetes . New For Config ( cluster Config ) if err ! = nil { return err } prow Job Client , err : = kube . New Client In Cluster ( o . Prow Job Namespace ) if err ! = nil { return err } controller : = artifact _uploader . New Controller ( client . Core V 1 ( ) , prow Job Client , o . Options ) stop : = make ( chan struct { } ) defer close ( stop ) go controller . Run ( o . Num Workers , stop ) } 
func ( a * Agent ) Start ( paths [ ] string ) error { secrets Map , err : = Load Secrets ( paths ) if err ! = nil { return err } a . secrets Map = secrets Map } return nil } 
func ( a * Agent ) reload Secret ( secret Path string ) { var last Mod Time time . Time logger : = logrus . New Entry ( logrus . Standard Logger ( ) ) skips : = 0 for range time . Tick ( 1 * time . Second ) { if skips < 6 0 0 { if err ! = nil { logger . With Field ( " " , secret Path ) . With Error ( err ) . Error ( " " ) continue } recent Mod Time : = secret Stat . Mod Time ( ) if ! recent Mod Time . After ( last Mod Time ) { skips + + continue } last Mod Time = recent Mod Time } if secret Value , err : = Load Single Secret ( secret Path ) ; err ! = nil { logger . With Field ( " " , secret Path ) . With Error ( err ) . Error ( " " ) } else { a . set Secret ( secret Path , secret Value ) skips = 0 } } } 
func ( a * Agent ) Get Secret ( secret Path string ) [ ] byte { a . RLock ( ) defer a . RUnlock ( ) return a . secrets Map [ secret Path ] } 
func ( a * Agent ) set Secret ( secret Path string , secret Value [ ] byte ) { a . Lock ( ) defer a . Unlock ( ) a . secrets Map [ secret Path ] = secret Value } 
func ( a * Agent ) Get Token Generator ( secret Path string ) func ( ) [ ] byte { return func ( ) [ ] byte { return a . Get Secret ( secret Path ) } } 
func New ( max Records Per Key int , opener io . Opener , path string ) ( * History , error ) { hist : = & History { logs : map [ string ] * record Log { } , log Size Limit : max Records Per Key , opener : opener , path : path , } if path ! = " " { start : = time . Now ( ) hist . logs , err = read History ( max Records Per Key , hist . opener , hist . path ) if err ! = nil { return nil , err } logrus . With Fields ( logrus . Fields { " " : time . Since ( start ) . String ( ) , " " : hist . path , } ) . Debugf ( " " , len ( hist . logs ) ) } return hist , nil } 
func ( h * History ) Record ( pool Key , action , base SHA , err string , targets [ ] prowapi . Pull ) { t : = now ( ) sort . Sort ( By Num ( targets ) ) h . add Record ( pool Key , & Record { Time : t , Action : action , Base SHA : base SHA , Target : targets , Err : err , } , ) } 
func ( h * History ) Serve HTTP ( w http . Response Writer , r * http . Request ) { b , err : = json . Marshal ( h . All Records ( ) ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) b = [ ] byte ( " " ) } if _ , err = w . Write ( b ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } 
func ( h * History ) Flush ( ) { if h . path = = " " { return } records : = h . All Records ( ) start : = time . Now ( ) err : = write History ( h . opener , h . path , records ) log : = logrus . With Fields ( logrus . Fields { " " : time . Since ( start ) . String ( ) , " " : h . path , } ) if err ! = nil { log . With Error ( err ) . Error ( " " ) } else { log . Debugf ( " " , len ( h . logs ) ) } } 
func ( h * History ) All Records ( ) map [ string ] [ ] * Record { h . Lock ( ) defer h . Unlock ( ) res : = make ( map [ string ] [ ] * Record , len ( h . logs ) ) for key , log : = range h . logs { res [ key ] = log . to Slice ( ) } return res } 
func Make Command ( ) * cobra . Command { flags : = & flags { } cmd : = & cobra . Command { Use : " " , Short : " " , Long : `Finds and downloads the coverage profile file from the latest healthy build stored in given gcs directory . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . String Var P ( & flags . output File , " " , " " , " " , " " ) cmd . Flags ( ) . String Var P ( & flags . artifacts Dir Name , " " , " " , " " , " " ) cmd . Flags ( ) . String Var P ( & flags . profile Name , " " , " " , " " , " " ) return cmd } 
func ( c * Comment Counter Plugin ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . String Slice Var ( & c . pattern , " " , [ ] string { } , " " ) } 
func ( c * Comment Counter Plugin ) Check Flags ( ) error { for _ , pattern : = range c . pattern { matcher , err : = regexp . Compile ( pattern ) if err ! = nil { return err } c . matcher = append ( c . matcher , matcher ) } return nil } 
func ( c * Comment Counter Plugin ) Receive Comment ( comment sql . Comment ) [ ] Point { points : = [ ] Point { } for _ , matcher : = range c . matcher { if matcher . Match String ( comment . Body ) { points = append ( points , Point { Values : map [ string ] interface { } { " " : 1 , } , Date : comment . Comment Created At , } ) } } return points } 
func New Controller ( pjclientset clientset . Interface , queue workqueue . Rate Limiting Interface , informer pjinformers . Prow Job Informer , reporter report Client , num Workers int , wg * sync . Wait Group ) * Controller { return & Controller { pjclientset : pjclientset , queue : queue , informer : informer , reporter : reporter , num Workers : num Workers , wg : wg , } } 
func ( c * Controller ) Run ( stop Ch < - chan struct { } ) { logrus . Info ( " " ) c . informer . Informer ( ) . Add Event Handler ( cache . Resource Event Handler Funcs { Add Func : func ( obj interface { } ) { key , err : = cache . Meta Namespace Key Func ( obj ) logrus . With Field ( " " , key ) . Infof ( " " ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return } c . queue . Add Rate Limited ( key ) } , Update Func : func ( old Obj , new Obj interface { } ) { key , err : = cache . Meta Namespace Key Func ( new Obj ) logrus . With Field ( " " , key ) . Infof ( " " ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return } c . queue . Add Rate Limited ( key ) } , } ) return } logrus . Info ( " " ) } logrus . Infof ( " " , c . num Workers ) < - stop Ch logrus . Info ( " " ) } 
func ( c * Controller ) run Worker ( ) { c . wg . Add ( 1 ) for c . process Next Item ( ) { } c . wg . Done ( ) } 
func ( c * Controller ) process Next Item ( ) bool { key , quit : = c . queue . Get ( ) if quit { return false } defer c . queue . Done ( key ) namespace , name , err : = cache . Split Meta Namespace Key ( key Raw ) if err ! = nil { logrus . With Error ( err ) . With Field ( " " , key Raw ) . Error ( " " ) c . queue . Forget ( key ) return true } if err ! = nil { if errors . Is Not Found ( err ) { logrus . With Field ( " " , key Raw ) . Info ( " " ) c . queue . Forget ( key ) return true } return c . retry ( key , err ) } return true } } c . queue . Forget ( key ) return true } logrus . With Field ( " " , key Raw ) . Infof ( " " , pj . Status . State ) pjs , err : = c . reporter . Report ( pj ) if err ! = nil { fields : = logrus . Fields { " " : key Raw , " " : pj . Name , " " : pj . Status , } logrus . With Error ( err ) . With Fields ( fields ) . Error ( " " ) return c . retry ( key , err ) } logrus . With Field ( " " , key Raw ) . Info ( " " ) for _ , pjob : = range pjs { if err : = c . update Report State ( pjob ) ; err ! = nil { logrus . With Error ( err ) . With Field ( " " , key Raw ) . Error ( " " ) if err ! = nil { logrus . With Error ( err ) . With Field ( " " , key Raw ) . Error ( " " ) c . queue . Forget ( key ) return true } if err : = c . update Report State ( updated PJ ) ; err ! = nil { c . queue . Forget ( key ) return true } } logrus . With Field ( " " , key Raw ) . Infof ( " " , pjob . Spec . Job , pjob . Status . State ) } c . queue . Forget ( key ) return true } 
func New Aggregate ( errlist . . . error ) Aggregate { if len ( errlist ) = = 0 { return nil } for _ , e : = range errlist { if e ! = nil { errs = append ( errs , e ) } } if len ( errs ) = = 0 { return nil } return aggregate ( errs ) } 
func ( agg aggregate ) Error ( ) string { if len ( agg ) = = 0 { } return fmt . Sprintf ( " " , strings . Join ( agg . Strings ( ) , " " ) ) } 
func ( agg aggregate ) Strings ( ) [ ] string { strs : = make ( [ ] string , 0 , len ( agg ) ) for _ , e : = range agg { if sub Agg , ok : = e . ( aggregate ) ; ok { strs = append ( strs , sub Agg . Strings ( ) . . . ) } else { strs = append ( strs , e . Error ( ) ) } } return strs } 
func New ( ) ( * Local Git , * git . Client , error ) { g , err : = exec . Look Path ( " " ) if err ! = nil { return nil , nil , err } t , err : = ioutil . Temp Dir ( " " , " " ) if err ! = nil { return nil , nil , err } c , err : = git . New Client ( ) if err ! = nil { os . Remove All ( t ) return nil , nil , err } get Secret : = func ( ) [ ] byte { return [ ] byte ( " " ) } c . Set Credentials ( " " , get Secret ) c . Set Remote ( t ) return & Local Git { Dir : t , Git : g , } , c , nil } 
func ( lg * Local Git ) Make Fake Repo ( org , repo string ) error { rdir : = filepath . Join ( lg . Dir , org , repo ) if err : = os . Mkdir All ( rdir , os . Mode Perm ) ; err ! = nil { return err } if err : = run Cmd ( lg . Git , rdir , " " ) ; err ! = nil { return err } if err : = run Cmd ( lg . Git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = run Cmd ( lg . Git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = run Cmd ( lg . Git , rdir , " " , " " , " " ) ; err ! = nil { return err } if err : = lg . Add Commit ( org , repo , map [ string ] [ ] byte { " " : { } } ) ; err ! = nil { return err } return nil } 
func ( lg * Local Git ) Add Commit ( org , repo string , files map [ string ] [ ] byte ) error { rdir : = filepath . Join ( lg . Dir , org , repo ) for f , b : = range files { path : = filepath . Join ( rdir , f ) if err : = os . Mkdir All ( filepath . Dir ( path ) , os . Mode Perm ) ; err ! = nil { return err } if err : = ioutil . Write File ( path , b , os . Mode Perm ) ; err ! = nil { return err } if err : = run Cmd ( lg . Git , rdir , " " , f ) ; err ! = nil { return err } } return run Cmd ( lg . Git , rdir , " " , " " , " " ) } 
func ( lg * Local Git ) Checkout New Branch ( org , repo , branch string ) error { rdir : = filepath . Join ( lg . Dir , org , repo ) return run Cmd ( lg . Git , rdir , " " , " " , branch ) } 
func ( lg * Local Git ) Checkout ( org , repo , commitlike string ) error { rdir : = filepath . Join ( lg . Dir , org , repo ) return run Cmd ( lg . Git , rdir , " " , commitlike ) } 
func ( lg * Local Git ) Rev Parse ( org , repo , commitlike string ) ( string , error ) { rdir : = filepath . Join ( lg . Dir , org , repo ) return run Cmd Output ( lg . Git , rdir , " " , commitlike ) } 
func Clean All ( sess * session . Session , region string ) error { acct , err : = account . Get Account ( sess , regions . Default ) if err ! = nil { return errors . Wrap ( err , " " ) } klog . V ( 1 ) . Infof ( " " , acct ) var region List [ ] string if region = = " " { region List , err = regions . Get All ( sess ) if err ! = nil { return errors . Wrap ( err , " " ) } } else { region List = [ ] string { region } } klog . Infof ( " " , region List ) for _ , r : = range region List { for _ , typ : = range Regional Type List { set , err : = typ . List All ( sess , acct , r ) if err ! = nil { return errors . Wrapf ( err , " " , typ ) } if err : = typ . Mark And Sweep ( sess , acct , r , set ) ; err ! = nil { return errors . Wrapf ( err , " " , typ ) } } } for _ , typ : = range Global Type List { set , err : = typ . List All ( sess , acct , regions . Default ) if err ! = nil { return errors . Wrapf ( err , " " , typ ) } if err : = typ . Mark And Sweep ( sess , acct , regions . Default , set ) ; err ! = nil { return errors . Wrapf ( err , " " , typ ) } } return nil } 
func options For Repo ( config * plugins . Configuration , org , repo string ) * plugins . Lgtm { full Name : = fmt . Sprintf ( " " , org , repo ) for i : = range config . Lgtm { if ! str In Slice ( org , config . Lgtm [ i ] . Repos ) & & ! str In Slice ( full Name , config . Lgtm [ i ] . Repos ) { continue } return & config . Lgtm [ i ] } return & plugins . Lgtm { } } 
func get Changed Files ( gc github Client , org , repo string , number int ) ( [ ] string , error ) { changes , err : = gc . Get Pull Request Changes ( org , repo , number ) if err ! = nil { return nil , fmt . Errorf ( " " , org , repo , number ) } var filenames [ ] string for _ , change : = range changes { filenames = append ( filenames , change . Filename ) } return filenames , nil } 
func load Reviewers ( ro repoowners . Repo Owner , filenames [ ] string ) sets . String { reviewers : = sets . String { } for _ , filename : = range filenames { reviewers = reviewers . Union ( ro . Approvers ( filename ) ) . Union ( ro . Reviewers ( filename ) ) } return reviewers } 
func New Controller ( last Sync Fallback , cookiefile Path string , projects map [ string ] [ ] string , kc * kube . Client , cfg config . Getter ) ( * Controller , error ) { if last Sync Fallback = = " " { return nil , errors . New ( " " ) } var last Update time . Time if buf , err : = ioutil . Read File ( last Sync Fallback ) ; err = = nil { unix , err : = strconv . Parse Int ( string ( buf ) , 1 0 , 6 4 ) if err ! = nil { return nil , err } last Update = time . Unix ( unix , 0 ) } else if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , fmt . Errorf ( " " , err ) } else { logrus . Warnf ( " " , last Sync Fallback ) last Update = time . Now ( ) } c , err : = client . New Client ( projects ) if err ! = nil { return nil , err } c . Start ( cookiefile Path ) return & Controller { kc : kc , config : cfg , gc : c , last Update : last Update , last Sync Fallback : last Sync Fallback , } , nil } 
func ( c * Controller ) Save Last Sync ( last Sync time . Time ) error { if c . last Sync Fallback = = " " { return nil } last Sync Unix : = strconv . Format Int ( last Sync . Unix ( ) , 1 0 ) logrus . Infof ( " " , last Sync Unix ) temp File , err : = ioutil . Temp File ( filepath . Dir ( c . last Sync Fallback ) , " " ) if err ! = nil { return err } defer os . Remove ( temp File . Name ( ) ) err = ioutil . Write File ( temp File . Name ( ) , [ ] byte ( last Sync Unix ) , 0 6 4 4 ) if err ! = nil { return err } err = os . Rename ( temp File . Name ( ) , c . last Sync Fallback ) if err ! = nil { logrus . With Error ( err ) . Info ( " " ) return copy File ( temp File . Name ( ) , c . last Sync Fallback ) } return nil } 
func ( c * Controller ) Sync ( ) error { sync Time : = c . last Update for instance , changes : = range c . gc . Query Changes ( c . last Update , c . config ( ) . Gerrit . Rate Limit ) { for _ , change : = range changes { if err : = c . Process Change ( instance , change ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , change . Current Revision ) } if sync Time . Before ( change . Updated . Time ) { sync Time = change . Updated . Time } } logrus . Infof ( " " , len ( changes ) , instance ) } c . last Update = sync Time if err : = c . Save Last Sync ( sync Time ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , sync Time , c . last Sync Fallback ) } return nil } 
func list Changed Files ( change Info client . Change Info ) config . Changed Files Provider { return func ( ) ( [ ] string , error ) { var changed [ ] string revision : = change Info . Revisions [ change Info . Current Revision ] for file : = range revision . Files { changed = append ( changed , file ) } return changed , nil } } 
func ( c * Controller ) Process Change ( instance string , change client . Change Info ) error { logger : = logrus . With Field ( " " , change . Number ) clone URI , err : = make Clone URI ( instance , change . Project ) if err ! = nil { return fmt . Errorf ( " " , err ) } base SHA , err : = c . gc . Get Branch Revision ( instance , change . Project , change . Branch ) if err ! = nil { return fmt . Errorf ( " " , err ) } triggered Jobs : = [ ] string { } refs , err : = create Refs ( instance , change , clone URI , base SHA ) if err ! = nil { return fmt . Errorf ( " " , err ) } type job Spec struct { spec prowapi . Prow Job Spec labels map [ string ] string } var job Specs [ ] job Spec changed Files : = list Changed Files ( change ) switch change . Status { case client . Merged : postsubmits : = c . config ( ) . Postsubmits [ clone URI . String ( ) ] postsubmits = append ( postsubmits , c . config ( ) . Postsubmits [ clone URI . Host + " " + clone URI . Path ] . . . ) for _ , postsubmit : = range postsubmits { if should Run , err : = postsubmit . Should Run ( change . Branch , changed Files ) ; err ! = nil { return fmt . Errorf ( " " , postsubmit . Name , err ) } else if should Run { job Specs = append ( job Specs , job Spec { spec : pjutil . Postsubmit Spec ( postsubmit , refs ) , labels : postsubmit . Labels , } ) } } case client . New : presubmits : = c . config ( ) . Presubmits [ clone URI . String ( ) ] presubmits = append ( presubmits , c . config ( ) . Presubmits [ clone URI . Host + " " + clone URI . Path ] . . . ) var filters [ ] pjutil . Filter filter , err : = message Filter ( c . last Update , change , presubmits ) if err ! = nil { logger . With Error ( err ) . Warn ( " " ) } else { filters = append ( filters , filter ) } if change . Revisions [ change . Current Revision ] . Created . Time . After ( c . last Update ) { filters = append ( filters , pjutil . Test All Filter ( ) ) } to Trigger , _ , err : = pjutil . Filter Presubmits ( pjutil . Aggregate Filter ( filters ) , list Changed Files ( change ) , change . Branch , presubmits , logger ) if err ! = nil { return fmt . Errorf ( " " , err ) } for _ , presubmit : = range to Trigger { job Specs = append ( job Specs , job Spec { spec : pjutil . Presubmit Spec ( presubmit , refs ) , labels : presubmit . Labels , } ) } } annotations : = map [ string ] string { client . Gerrit ID : change . ID , client . Gerrit Instance : instance , } for _ , j Spec : = range job Specs { labels : = make ( map [ string ] string ) for k , v : = range j Spec . labels { labels [ k ] = v } labels [ client . Gerrit Revision ] = change . Current Revision if gerrit Label , ok : = labels [ client . Gerrit Report Label ] ; ! ok | | gerrit Label = = " " { labels [ client . Gerrit Report Label ] = client . Code Review } pj : = pjutil . New Prow Job With Annotation ( j Spec . spec , labels , annotations ) if _ , err : = c . kc . Create Prow Job ( pj ) ; err ! = nil { logger . With Error ( err ) . Errorf ( " " , pj ) } else { logger . Infof ( " " , j Spec . spec . Job ) triggered Jobs = append ( triggered Jobs , j Spec . spec . Job ) } } if len ( triggered Jobs ) > 0 { for _ , job : = range triggered Jobs { message + = fmt . Sprintf ( " \n " , job ) } if err : = c . gc . Set Review ( instance , change . ID , change . Current Revision , message , nil ) ; err ! = nil { return err } } return nil } 
func ( e * Event Counter Plugin ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . String Var ( & e . desc , " " , " " , " " ) } 
func ( e * Event Counter Plugin ) Check Flags ( ) error { e . matcher = New Event Matcher ( e . desc ) return nil } 
func ( e * Event Counter Plugin ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { var label string if event . Label ! = nil { label = * event . Label } if ! e . matcher . Match ( event . Event , label ) { return nil } return [ ] Point { { Values : map [ string ] interface { } { " " : 1 } , Date : event . Event Created At , } , } } 
func Upload ( bucket * storage . Bucket Handle , upload Targets map [ string ] Upload Func ) error { err Ch : = make ( chan error , len ( upload Targets ) ) group : = & sync . Wait Group { } group . Add ( len ( upload Targets ) ) for dest , upload : = range upload Targets { obj : = bucket . Object ( dest ) logrus . With Field ( " " , dest ) . Info ( " " ) go func ( f Upload Func , obj * storage . Object Handle , name string ) { defer group . Done ( ) if err : = f ( obj ) ; err ! = nil { err Ch < - err } logrus . With Field ( " " , name ) . Info ( " " ) } ( upload , obj , dest ) } group . Wait ( ) close ( err Ch ) if len ( err Ch ) ! = 0 { var upload Errors [ ] error for err : = range err Ch { upload Errors = append ( upload Errors , err ) } return fmt . Errorf ( " " , upload Errors ) } return nil } 
func File Upload With Metadata ( file string , metadata map [ string ] string ) Upload Func { return func ( obj * storage . Object Handle ) error { reader , err : = os . Open ( file ) if err ! = nil { return err } upload Err : = Data Upload With Metadata ( reader , metadata ) ( obj ) close Err : = reader . Close ( ) return errorutil . New Aggregate ( upload Err , close Err ) } } 
func Data Upload With Metadata ( src io . Reader , metadata map [ string ] string ) Upload Func { return func ( obj * storage . Object Handle ) error { writer : = obj . New Writer ( context . Background ( ) ) writer . Metadata = metadata _ , copy Err : = io . Copy ( writer , src ) close Err : = writer . Close ( ) return errorutil . New Aggregate ( copy Err , close Err ) } } 
func Has Label ( label string , issue Labels [ ] Label ) bool { for _ , l : = range issue Labels { if strings . To Lower ( l . Name ) = = strings . To Lower ( label ) { return true } } return false } 
func Image Too Big ( url string ) ( bool , error ) { if err ! = nil { return true , fmt . Errorf ( " " , err ) } if sc : = resp . Status Code ; sc ! = http . Status OK { return true , fmt . Errorf ( " " , sc ) } size , _ : = strconv . Atoi ( resp . Header . Get ( " " ) ) if size > limit { return true , nil } return false , nil } 
func Level From Permissions ( permissions Repo Permissions ) Repo Permission Level { if permissions . Admin { return Admin } else if permissions . Push { return Write } else if permissions . Pull { return Read } else { return None } } 
func Permissions From Level ( permission Repo Permission Level ) Repo Permissions { switch permission { case None : return Repo Permissions { } case Read : return Repo Permissions { Pull : true } case Write : return Repo Permissions { Pull : true , Push : true } case Admin : return Repo Permissions { Pull : true , Push : true , Admin : true } default : return Repo Permissions { } } } 
func new Prow Jobs ( c * Prow V 1Client , namespace string ) * prow Jobs { return & prow Jobs { client : c . RESTClient ( ) , ns : namespace , } } 
func ( c * prow Jobs ) List ( opts metav 1 . List Options ) ( result * v 1 . Prow Job List , err error ) { result = & v 1 . Prow Job List { } err = c . client . Get ( ) . Namespace ( c . ns ) . Resource ( " " ) . Versioned Params ( & opts , scheme . Parameter Codec ) . Do ( ) . Into ( result ) return } 
func ( c * prow Jobs ) Create ( prow Job * v 1 . Prow Job ) ( result * v 1 . Prow Job , err error ) { result = & v 1 . Prow Job { } err = c . client . Post ( ) . Namespace ( c . ns ) . Resource ( " " ) . Body ( prow Job ) . Do ( ) . Into ( result ) return } 
func ( c * prow Jobs ) Update ( prow Job * v 1 . Prow Job ) ( result * v 1 . Prow Job , err error ) { result = & v 1 . Prow Job { } err = c . client . Put ( ) . Namespace ( c . ns ) . Resource ( " " ) . Name ( prow Job . Name ) . Body ( prow Job ) . Do ( ) . Into ( result ) return } 
func ( b Blockers ) Get Applicable ( org , repo , branch string ) [ ] Blocker { var res [ ] Blocker res = append ( res , b . Repo [ org Repo { org : org , repo : repo } ] . . . ) res = append ( res , b . Branch [ org Repo Branch { org : org , repo : repo , branch : branch } ] . . . ) sort . Slice ( res , func ( i , j int ) bool { return res [ i ] . Number < res [ j ] . Number } ) return res } 
func Find All ( ghc github Client , log * logrus . Entry , label , org Repo Tokens string ) ( Blockers , error ) { issues , err : = search ( context . Background ( ) , ghc , log , blocker Query ( label , org Repo Tokens ) , ) if err ! = nil { return Blockers { } , fmt . Errorf ( " " , err ) } return from Issues ( issues ) , nil } 
func serve ( jc * jenkins . Client ) { http . Handle ( " " , gziphandler . Gzip Handler ( handle Log ( jc ) ) ) http . Handle ( " " , promhttp . Handler ( ) ) logrus . With Error ( http . Listen And Serve ( " " , nil ) ) . Fatal ( " " ) } 
func New Count Plugin ( runner func ( Plugin ) error ) * cobra . Command { state Counter : = & State Plugin { } event Counter : = & Event Counter Plugin { } comments As Events : = New Fake Comment Plugin Wrapper ( event Counter ) comment Counter : = & Comment Counter Plugin { } author Loggable : = New Multiplexer Plugin Wrapper ( comments As Events , comment Counter , ) author Logged : = New Author Logger Plugin Wrapper ( author Loggable ) full Multiplex : = New Multiplexer Plugin Wrapper ( author Logged , state Counter ) fake Open : = New Fake Open Plugin Wrapper ( full Multiplex ) type Filter : = New Type Filter Wrapper Plugin ( fake Open ) author Filter : = New Author Filter Plugin Wrapper ( type Filter ) cmd : = & cobra . Command { Use : " " , Short : " " , Run E : func ( cmd * cobra . Command , args [ ] string ) error { if err : = event Counter . Check Flags ( ) ; err ! = nil { return err } if err : = state Counter . Check Flags ( ) ; err ! = nil { return err } if err : = type Filter . Check Flags ( ) ; err ! = nil { return err } if err : = comment Counter . Check Flags ( ) ; err ! = nil { return err } return runner ( author Filter ) } , } event Counter . Add Flags ( cmd ) state Counter . Add Flags ( cmd ) comment Counter . Add Flags ( cmd ) type Filter . Add Flags ( cmd ) author Filter . Add Flags ( cmd ) author Logged . Add Flags ( cmd ) return cmd } 
func ( o * Fake Comment Plugin Wrapper ) Receive Issue ( issue sql . Issue ) [ ] Point { } 
func ( o * Fake Comment Plugin Wrapper ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { } 
func ( o * Fake Comment Plugin Wrapper ) Receive Comment ( comment sql . Comment ) [ ] Point { return append ( o . plugin . Receive Comment ( comment ) , o . plugin . Receive Issue Event ( fake Event ) . . . , ) } 
func update Metrics ( interval time . Duration , disk Root string ) { logger : = logrus . With Field ( " " , " " ) ticker : = time . New Ticker ( interval ) for ; true ; < - ticker . C { logger . Info ( " " ) _ , bytes Free , bytes Used , err : = diskutil . Get Disk Usage ( disk Root ) if err ! = nil { logger . With Error ( err ) . Error ( " " ) } else { prom Metrics . Disk Free . Set ( float 6 4 ( bytes Free ) / 1e 9 ) prom Metrics . Disk Used . Set ( float 6 4 ( bytes Used ) / 1e 9 ) prom Metrics . Disk Total . Set ( float 6 4 ( bytes Free + bytes Used ) / 1e 9 ) } } } 
func New Ranch ( config string , s * Storage ) ( * Ranch , error ) { new Ranch : = & Ranch { Storage : s , Update Time : update Time , } if config ! = " " { if err : = new Ranch . Sync Config ( config ) ; err ! = nil { return nil , err } } new Ranch . Log Status ( ) return new Ranch , nil } 
func ( r * Ranch ) Acquire ( r Type , state , dest , owner string ) ( * common . Resource , error ) { r . resources Lock . Lock ( ) defer r . resources Lock . Unlock ( ) resources , err : = r . Storage . Get Resources ( ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) return nil , & Resource Not Found { r Type } } found Type : = false for idx : = range resources { res : = resources [ idx ] if r Type = = res . Type { found Type = true if state = = res . State & & res . Owner = = " " { res . Last Update = r . Update Time ( ) res . Owner = owner res . State = dest if err : = r . Storage . Update Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name ) return nil , err } return & res , nil } } } if found Type { return nil , & Resource Not Found { r Type } } return nil , & Resource Type Not Found { r Type } } 
func ( r * Ranch ) Acquire By State ( state , dest , owner string , names [ ] string ) ( [ ] common . Resource , error ) { r . resources Lock . Lock ( ) defer r . resources Lock . Unlock ( ) if names = = nil { return nil , fmt . Errorf ( " " ) } r Names : = map [ string ] bool { } for _ , t : = range names { r Names [ t ] = true } all Resources , err : = r . Storage . Get Resources ( ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) return nil , & Resource Not Found { state } } var resources [ ] common . Resource for idx : = range all Resources { res : = all Resources [ idx ] if state = = res . State { if res . Owner ! = " " { continue } if r Names [ res . Name ] { res . Last Update = r . Update Time ( ) res . Owner = owner res . State = dest if err : = r . Storage . Update Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name ) return nil , err } resources = append ( resources , res ) delete ( r Names , res . Name ) } } } if len ( r Names ) ! = 0 { var missing Resources [ ] string for n : = range r Names { missing Resources = append ( missing Resources , n ) } err : = & Resource Not Found { state } logrus . With Error ( err ) . Errorf ( " " , strings . Join ( missing Resources , " " ) ) return resources , err } return resources , nil } 
func ( r * Ranch ) Release ( name , dest , owner string ) error { r . resources Lock . Lock ( ) defer r . resources Lock . Unlock ( ) res , err : = r . Storage . Get Resource ( name ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , name ) return & Resource Not Found { name } } if owner ! = res . Owner { return & Owner Not Match { owner : owner , request : res . Owner } } res . Last Update = r . Update Time ( ) res . Owner = " " res . State = dest if err : = r . Storage . Update Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name ) return err } return nil } 
func ( r * Ranch ) Update ( name , owner , state string , ud * common . User Data ) error { r . resources Lock . Lock ( ) defer r . resources Lock . Unlock ( ) res , err : = r . Storage . Get Resource ( name ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , name ) return & Resource Not Found { name } } if owner ! = res . Owner { return & Owner Not Match { owner : owner , request : res . Owner } } if state ! = res . State { return & State Not Match { res . State , state } } if res . User Data = = nil { res . User Data = & common . User Data { } } res . User Data . Update ( ud ) res . Last Update = r . Update Time ( ) if err : = r . Storage . Update Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name ) return err } return nil } 
func ( r * Ranch ) Reset ( rtype , state string , expire time . Duration , dest string ) ( map [ string ] string , error ) { r . resources Lock . Lock ( ) defer r . resources Lock . Unlock ( ) ret : = make ( map [ string ] string ) resources , err : = r . Storage . Get Resources ( ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) return nil , err } for idx : = range resources { res : = resources [ idx ] if rtype = = res . Type & & state = = res . State & & res . Owner ! = " " { if time . Since ( res . Last Update ) > expire { res . Last Update = r . Update Time ( ) ret [ res . Name ] = res . Owner res . Owner = " " res . State = dest if err : = r . Storage . Update Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name ) return ret , err } } } } return ret , nil } 
func ( r * Ranch ) Log Status ( ) { resources , err : = r . Storage . Get Resources ( ) if err ! = nil { return } res JSON , err : = json . Marshal ( resources ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , resources ) } logrus . Infof ( " " , string ( res JSON ) ) } 
func ( r * Ranch ) Sync Config ( config string ) error { resources , err : = Parse Config ( config ) if err ! = nil { return err } if err : = r . Storage . Sync Resources ( resources ) ; err ! = nil { return err } return nil } 
func ( r * Ranch ) Metric ( rtype string ) ( common . Metric , error ) { metric : = common . Metric { Type : rtype , Current : map [ string ] int { } , Owners : map [ string ] int { } , } resources , err : = r . Storage . Get Resources ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return metric , & Resource Not Found { rtype } } for _ , res : = range resources { if res . Type ! = rtype { continue } if _ , ok : = metric . Current [ res . State ] ; ! ok { metric . Current [ res . State ] = 0 } if _ , ok : = metric . Owners [ res . Owner ] ; ! ok { metric . Owners [ res . Owner ] = 0 } metric . Current [ res . State ] + + metric . Owners [ res . Owner ] + + } if len ( metric . Current ) = = 0 & & len ( metric . Owners ) = = 0 { return metric , & Resource Not Found { rtype } } return metric , nil } 
func Format URL ( dog URL string ) ( string , error ) { if dog URL = = " " { return " " , errors . New ( " " ) } src , err : = url . Parse Request URI ( dog URL ) if err ! = nil { return " " , fmt . Errorf ( " " , dog URL , err ) } return fmt . Sprintf ( " " , src , src ) , nil } 
func Trusted User ( ghc trusted User Client , trigger plugins . Trigger , user , org , repo string ) ( bool , error ) { } else if ok { return true , nil } } } else if member { return true , nil } } if err ! = nil { return false , fmt . Errorf ( " " , trigger . Trusted Org , err ) } return member , nil } 
func run And Skip Jobs ( c Client , pr * github . Pull Request , requested Jobs [ ] config . Presubmit , skipped Jobs [ ] config . Presubmit , event GUID string , elide Skipped Contexts bool ) error { if err : = validate Context Overlap ( requested Jobs , skipped Jobs ) ; err ! = nil { c . Logger . With Error ( err ) . Warn ( " " ) return err } run Err : = Run Requested ( c , pr , requested Jobs , event GUID ) var skip Err error if ! elide Skipped Contexts { skip Err = skip Requested ( c , pr , skipped Jobs ) } return errorutil . New Aggregate ( run Err , skip Err ) } 
func validate Context Overlap ( to Run , to Skip [ ] config . Presubmit ) error { requested Contexts : = sets . New String ( ) for _ , job : = range to Run { requested Contexts . Insert ( job . Context ) } skipped Contexts : = sets . New String ( ) for _ , job : = range to Skip { skipped Contexts . Insert ( job . Context ) } if overlap : = requested Contexts . Intersection ( skipped Contexts ) . List ( ) ; len ( overlap ) > 0 { return fmt . Errorf ( " " , strings . Join ( overlap , " " ) ) } return nil } 
func Run Requested ( c Client , pr * github . Pull Request , requested Jobs [ ] config . Presubmit , event GUID string ) error { base SHA , err : = c . Git Hub Client . Get Ref ( pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , " " + pr . Base . Ref ) if err ! = nil { return err } var errors [ ] error for _ , job : = range requested Jobs { c . Logger . Infof ( " " , job . Name ) pj : = pjutil . New Presubmit ( * pr , base SHA , job , event GUID ) c . Logger . With Fields ( pjutil . Prow Job Fields ( & pj ) ) . Info ( " " ) if _ , err : = c . Prow Job Client . Create ( & pj ) ; err ! = nil { c . Logger . With Error ( err ) . Error ( " " ) errors = append ( errors , err ) } } return errorutil . New Aggregate ( errors . . . ) } 
func skip Requested ( c Client , pr * github . Pull Request , skipped Jobs [ ] config . Presubmit ) error { var errors [ ] error for _ , job : = range skipped Jobs { if job . Skip Report { continue } c . Logger . Infof ( " " , job . Name ) if err : = c . Git Hub Client . Create Status ( pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , pr . Head . SHA , skipped Status For ( job . Context ) ) ; err ! = nil { errors = append ( errors , err ) } } return errorutil . New Aggregate ( errors . . . ) } 
func ( l Label Event ) Match ( event Name , label string ) bool { return event Name = = " " & & label = = l . Label } 
func ( u Unlabel Event ) Match ( event Name , label string ) bool { return event Name = = " " & & label = = u . Label } 
func New Event Matcher ( event Description string ) Event Matcher { split : = strings . Split N ( event Description , " " , 2 ) switch split [ 0 ] { case " " : return False Event { } case " " : return Comment Event { } case " " : return Open Event { } case " " : return Reopen Event { } case " " : return Merge Event { } case " " : return Close Event { } case " " : if len ( split ) ! = 2 { panic ( fmt . Errorf ( " " ) ) } return Label Event { split [ 1 ] } case " " : if len ( split ) ! = 2 { panic ( fmt . Errorf ( " " ) ) } return Unlabel Event { split [ 1 ] } default : panic ( fmt . Errorf ( " " , split [ 0 ] ) ) } } 
func ( o * Git Hub Options ) Add Flags ( fs * flag . Flag Set ) { o . add Flags ( true , fs ) } 
func ( o * Git Hub Options ) Add Flags Without Default Git Hub Token Path ( fs * flag . Flag Set ) { o . add Flags ( false , fs ) } 
func ( o * Git Hub Options ) Validate ( dry Run bool ) error { for _ , uri : = range o . endpoint . Strings ( ) { if uri = = " " { uri = github . Default APIEndpoint } else if _ , err : = url . Parse Request URI ( uri ) ; err ! = nil { return fmt . Errorf ( " " , uri ) } } if o . graphql Endpoint = = " " { o . graphql Endpoint = github . Default Graph QLEndpoint } else if _ , err : = url . Parse ( o . graphql Endpoint ) ; err ! = nil { return fmt . Errorf ( " " , o . graphql Endpoint ) } if o . deprecated Token File ! = " " { o . Token Path = o . deprecated Token File logrus . Error ( " " ) } if o . Token Path = = " " { logrus . Warn ( " " ) } return nil } 
func ( o * Git Hub Options ) Git Hub Client With Log Fields ( secret Agent * secret . Agent , dry Run bool , fields logrus . Fields ) ( client * github . Client , err error ) { var generator * func ( ) [ ] byte if o . Token Path = = " " { generator Func : = func ( ) [ ] byte { return [ ] byte { } } generator = & generator Func } else { if secret Agent = = nil { return nil , fmt . Errorf ( " " , o . Token Path ) } generator Func : = secret Agent . Get Token Generator ( o . Token Path ) generator = & generator Func } if dry Run { return github . New Dry Run Client With Fields ( fields , * generator , o . graphql Endpoint , o . endpoint . Strings ( ) . . . ) , nil } return github . New Client With Fields ( fields , * generator , o . graphql Endpoint , o . endpoint . Strings ( ) . . . ) , nil } 
func ( o * Git Hub Options ) Git Hub Client ( secret Agent * secret . Agent , dry Run bool ) ( client * github . Client , err error ) { return o . Git Hub Client With Log Fields ( secret Agent , dry Run , logrus . Fields { } ) } 
func ( o * Git Hub Options ) Git Client ( secret Agent * secret . Agent , dry Run bool ) ( client * git . Client , err error ) { client , err = git . New Client ( ) if err ! = nil { return nil , err } } } ( client ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } bot Name , err : = github Client . Bot Name ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } client . Set Credentials ( bot Name , secret Agent . Get Token Generator ( o . Token Path ) ) return client , nil } 
func to Map ( g * calculation . Coverage List ) map [ string ] calculation . Coverage { m : = make ( map [ string ] calculation . Coverage ) for _ , cov : = range g . Group { m [ cov . Name ] = cov } return m } 
func find Changes ( base List * calculation . Coverage List , new List * calculation . Coverage List ) [ ] * coverage Change { var changes [ ] * coverage Change base Files Map : = to Map ( base List ) for _ , new Cov : = range new List . Group { base Cov , ok : = base Files Map [ new Cov . Name ] var base Ratio float 3 2 if ! ok { base Ratio = - 1 } else { base Ratio = base Cov . Ratio ( ) } new Ratio : = new Cov . Ratio ( ) if is Change Significant ( base Ratio , new Ratio ) { changes = append ( changes , & coverage Change { name : new Cov . Name , base Ratio : base Ratio , new Ratio : new Ratio , } ) } } return changes } 
func ( config * My SQLConfig ) Create Database ( ) ( * gorm . DB , error ) { db , err : = gorm . Open ( " " , config . get DSN ( " " ) ) if err ! = nil { return nil , err } db . Exec ( fmt . Sprintf ( " " , config . Db ) ) db . Close ( ) db , err = gorm . Open ( " " , config . get DSN ( config . Db ) ) err = db . Auto Migrate ( & Assignee { } , & Issue { } , & Issue Event { } , & Label { } , & Comment { } ) . Error if err ! = nil { return nil , err } return db , nil } 
func ( config * My SQLConfig ) Add Flags ( cmd * cobra . Command ) { cmd . Persistent Flags ( ) . String Var ( & config . User , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & config . Password , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & config . Host , " " , " " , " " ) cmd . Persistent Flags ( ) . Int Var ( & config . Port , " " , 3 3 0 6 , " " ) cmd . Persistent Flags ( ) . String Var ( & config . Db , " " , " " , " " ) } 
func New Reporter ( gc report . Git Hub Client , cfg config . Getter , report Agent v 1 . Prow Job Agent ) * Client { return & Client { gc : gc , config : cfg , report Agent : report Agent , } } 
func ( c * Client ) Should Report ( pj * v 1 . Prow Job ) bool { if ! pj . Spec . Report { } if pj . Spec . Type ! = v 1 . Presubmit Job & & pj . Spec . Type ! = v 1 . Postsubmit Job { } if c . report Agent ! = " " & & pj . Spec . Agent ! = c . report Agent { } return true } 
func ( c * Client ) Report ( pj * v 1 . Prow Job ) ( [ ] * v 1 . Prow Job , error ) { } 
func Parse Refs ( value string ) ( * prowapi . Refs , error ) { git Ref : = & prowapi . Refs { } values : = strings . Split N ( value , " " , 2 ) if len ( values ) ! = 2 { return git Ref , fmt . Errorf ( " " , value ) } info : = values [ 0 ] all Refs : = values [ 1 ] info Values : = strings . Split N ( info , " " , 2 ) if len ( info Values ) ! = 2 { return git Ref , fmt . Errorf ( " " , value ) } git Ref . Org = info Values [ 0 ] git Ref . Repo = info Values [ 1 ] ref Values : = strings . Split ( all Refs , " " ) if len ( ref Values ) = = 1 & & ref Values [ 0 ] = = " " { return git Ref , fmt . Errorf ( " " , value ) } base Ref Parts : = strings . Split ( ref Values [ 0 ] , " " ) if len ( base Ref Parts ) ! = 1 & & len ( base Ref Parts ) ! = 2 { return git Ref , fmt . Errorf ( " " , ref Values [ 0 ] ) } git Ref . Base Ref = base Ref Parts [ 0 ] if len ( base Ref Parts ) = = 2 { git Ref . Base SHA = base Ref Parts [ 1 ] } for _ , ref Value : = range ref Values [ 1 : ] { ref Parts : = strings . Split ( ref Value , " " ) if len ( ref Parts ) = = 0 | | len ( ref Parts ) > 3 { return git Ref , fmt . Errorf ( " " , ref Value ) } pull Number , err : = strconv . Atoi ( ref Parts [ 0 ] ) if err ! = nil { return git Ref , fmt . Errorf ( " " , ref Value , err ) } pull Ref : = prowapi . Pull { Number : pull Number , } if len ( ref Parts ) > 1 { pull Ref . SHA = ref Parts [ 1 ] } if len ( ref Parts ) > 2 { pull Ref . Ref = ref Parts [ 2 ] } git Ref . Pulls = append ( git Ref . Pulls , pull Ref ) } return git Ref , nil } 
func date Token ( start , end time . Time ) string { if start . Year ( ) > = 1 9 7 0 { start String = start . Format ( github . Search Time Format ) } if end . Year ( ) > = 1 9 7 0 { end String = end . Format ( github . Search Time Format ) } return fmt . Sprintf ( " " , start String , end String ) } 
func ( s * Set ) Mark ( r Interface ) bool { key : = r . Resource Key ( ) now : = time . Now ( ) s . marked [ key ] = true if t , ok : = s . first Seen [ key ] ; ok { since : = now . Sub ( t ) if since > s . ttl { s . swept = append ( s . swept , key ) return true } klog . V ( 1 ) . Infof ( " " , key , since ) return false } s . first Seen [ key ] = now klog . V ( 1 ) . Infof ( " " , key ) if s . ttl = = 0 { return true } return false } 
func ( s * Set ) Mark Complete ( ) int { var gone [ ] string for key : = range s . first Seen { if ! s . marked [ key ] { gone = append ( gone , key ) } } for _ , key : = range gone { klog . V ( 1 ) . Infof ( " " , key ) delete ( s . first Seen , key ) } if len ( s . swept ) > 0 { klog . Errorf ( " " , len ( s . swept ) , s . swept ) } return len ( s . swept ) } 
func New Job Agent ( kc service Cluster Client , pl Clients map [ string ] Pod Log Client , cfg config . Getter ) * Job Agent { return & Job Agent { kc : kc , pkcs : pl Clients , config : cfg , } } 
func ( ja * Job Agent ) Start ( ) { ja . try Update ( ) go func ( ) { t : = time . Tick ( period ) for range t { ja . try Update ( ) } } ( ) } 
func ( ja * Job Agent ) Jobs ( ) [ ] Job { ja . mut . Lock ( ) defer ja . mut . Unlock ( ) res : = make ( [ ] Job , len ( ja . jobs ) ) copy ( res , ja . jobs ) return res } 
func ( ja * Job Agent ) Prow Jobs ( ) [ ] prowapi . Prow Job { ja . mut . Lock ( ) defer ja . mut . Unlock ( ) res : = make ( [ ] prowapi . Prow Job , len ( ja . prow Jobs ) ) copy ( res , ja . prow Jobs ) return res } 
func ( ja * Job Agent ) Get Prow Job ( job , id string ) ( prowapi . Prow Job , error ) { if ja = = nil { return prowapi . Prow Job { } , fmt . Errorf ( " " ) } var j prowapi . Prow Job ja . mut . Lock ( ) id Map , ok : = ja . jobs IDMap [ job ] if ok { j , ok = id Map [ id ] } ja . mut . Unlock ( ) if ! ok { return prowapi . Prow Job { } , err Prowjob Not Found } return j , nil } 
func ( ja * Job Agent ) Get Job Log ( job , id string ) ( [ ] byte , error ) { j , err : = ja . Get Prow Job ( job , id ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if j . Spec . Agent = = prowapi . Kubernetes Agent { client , ok : = ja . pkcs [ j . Cluster Alias ( ) ] if ! ok { return nil , fmt . Errorf ( " " , j . Object Meta . Name , j . Spec . Agent , j . Cluster Alias ( ) ) } return client . Get Logs ( j . Status . Pod Name , & coreapi . Pod Log Options { Container : kube . Test Container Name } ) } for _ , agent To Tmpl : = range ja . config ( ) . Deck . External Agent Logs { if agent To Tmpl . Agent ! = string ( j . Spec . Agent ) { continue } if ! agent To Tmpl . Selector . Matches ( labels . Set ( j . Object Meta . Labels ) ) { continue } var b bytes . Buffer if err : = agent To Tmpl . URLTemplate . Execute ( & b , & j ) ; err ! = nil { return nil , fmt . Errorf ( " " , j . Object Meta . Name , j . Spec . Agent , err ) } resp , err : = http . Get ( b . String ( ) ) if err ! = nil { return nil , err } defer resp . Body . Close ( ) return ioutil . Read All ( resp . Body ) } return nil , fmt . Errorf ( " " , j . Object Meta . Name , j . Spec . Agent ) } 
func union Strings ( parent , child [ ] string ) [ ] string { if child = = nil { return parent } if parent = = nil { return child } s : = sets . New String ( parent . . . ) s . Insert ( child . . . ) return s . List ( ) } 
func ( p Policy ) Apply ( child Policy ) Policy { return Policy { Protect : select Bool ( p . Protect , child . Protect ) , Required Status Checks : merge Context Policy ( p . Required Status Checks , child . Required Status Checks ) , Admins : select Bool ( p . Admins , child . Admins ) , Restrictions : merge Restrictions ( p . Restrictions , child . Restrictions ) , Required Pull Request Reviews : merge Review Policy ( p . Required Pull Request Reviews , child . Required Pull Request Reviews ) , } } 
func ( bp Branch Protection ) Get Org ( name string ) * Org { o , ok : = bp . Orgs [ name ] if ok { o . Policy = bp . Apply ( o . Policy ) } else { o . Policy = bp . Policy } return & o } 
func ( o Org ) Get Repo ( name string ) * Repo { r , ok : = o . Repos [ name ] if ok { r . Policy = o . Apply ( r . Policy ) } else { r . Policy = o . Policy } return & r } 
func ( r Repo ) Get Branch ( name string ) ( * Branch , error ) { b , ok : = r . Branches [ name ] if ok { b . Policy = r . Apply ( b . Policy ) if b . Protect = = nil { return nil , errors . New ( " " ) } } else { b . Policy = r . Policy } return & b , nil } 
func ( c * Config ) Get Branch Protection ( org , repo , branch string ) ( * Policy , error ) { if _ , present : = c . Branch Protection . Orgs [ org ] ; ! present { return nil , nil } b , err : = c . Branch Protection . Get Org ( org ) . Get Repo ( repo ) . Get Branch ( branch ) if err ! = nil { return nil , err } return c . Get Policy ( org , repo , branch , * b ) } 
func ( c * Config ) Get Policy ( org , repo , branch string , b Branch ) ( * Policy , error ) { policy : = b . Policy } ps : = Policy { Required Status Checks : & Context Policy { Contexts : prow Contexts , } , } ps . Protect = & yes } policy = policy . Apply ( ps ) } if policy . Protect ! = nil & & ! * policy . Protect { old , policy . Protect = policy . Protect , old switch { case policy . defined ( ) & & c . Branch Protection . Allow Disabled Policies : logrus . Warnf ( " " , org , repo , branch ) policy = Policy { Protect : policy . Protect , } case policy . defined ( ) : return nil , fmt . Errorf ( " " , org , repo , branch ) } policy . Protect = old } if ! policy . defined ( ) { return nil , nil } return & policy , nil } 
func Branch Requirements ( org , repo , branch string , presubmits map [ string ] [ ] Presubmit ) ( [ ] string , [ ] string , [ ] string ) { jobs , ok : = presubmits [ org + " " + repo ] if ! ok { return nil , nil , nil } var required , required If Present , optional [ ] string for _ , j : = range jobs { if ! j . Could Run ( branch ) { continue } if j . Context Required ( ) { if j . Triggers Conditionally ( ) { } else { } } else { optional = append ( optional , j . Context ) } } return required , required If Present , optional } 
func Update Issue Events ( issue ID int , db * gorm . DB , client Client Interface ) { latest , err : = find Latest Event ( issue ID , db , client . Repository Name ( ) ) if err ! = nil { glog . Error ( " " , err ) return } c : = make ( chan * github . Issue Event , 5 0 0 ) go client . Fetch Issue Events ( issue ID , latest , c ) for event : = range c { event Orm , err : = New Issue Event ( event , issue ID , client . Repository Name ( ) ) if err ! = nil { glog . Error ( " " , err ) } db . Create ( event Orm ) } } 
func ( c * controller ) enqueue Key ( ctx string , obj interface { } ) { switch o : = obj . ( type ) { case * prowjobv 1 . Prow Job : c . workqueue . Add Rate Limited ( to Key ( ctx , o . Spec . Namespace , o . Name ) ) case * buildv 1alpha 1 . Build : c . workqueue . Add Rate Limited ( to Key ( ctx , o . Namespace , o . Name ) ) default : logrus . Warnf ( " " , o , obj ) return } } 
func reconcile ( c reconciler , key string ) error { ctx , namespace , name , err : = from Key ( key ) if err ! = nil { runtime . Handle Error ( err ) return nil } if err : = c . terminate Dup Prow Jobs ( ctx , namespace ) ; err ! = nil { logrus . With Error ( err ) . Warn ( " " ) } var want Build bool pj , err : = c . get Prow Job ( name ) switch { case apierrors . Is Not Found ( err ) : case pj . Spec . Agent ! = prowjobv 1 . Knative Build Agent : case pj . Deletion Timestamp = = nil : want Build = true } var have Build bool b , err : = c . get Build ( ctx , namespace , name ) switch { case apierrors . Is Not Found ( err ) : case b . Deletion Timestamp = = nil : have Build = true } var new Build ID bool } return nil } switch v , ok : = b . Labels [ kube . Created By Prow ] ; { case ! ok , v ! = " " : } logrus . Infof ( " " , key ) if err = c . delete Build ( ctx , namespace , name ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil case final State ( pj . Status . State ) : logrus . Infof ( " " , key ) return nil case want Build & & pj . Spec . Build Spec = = nil : return errors . New ( " " ) case want Build & & ! have Build : id , url , err : = c . build ID ( * pj ) if err ! = nil { return fmt . Errorf ( " " , err ) } pj . Status . Build ID = id pj . Status . URL = url new Build ID = true if b , err = make Build ( * pj , c . default Build Timeout ( ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } logrus . Infof ( " " , key ) if b , err = c . create Build ( ctx , namespace , b ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } have Msg : = pj . Status . Description want State , want Msg : = prow Job Status ( b . Status ) if new Build ID | | have State ! = want State | | have Msg ! = want Msg { npj : = pj . Deep Copy ( ) if npj . Status . Start Time . Is Zero ( ) { npj . Status . Start Time = c . now ( ) } if npj . Status . Completion Time . Is Zero ( ) & & final State ( want State ) { now : = c . now ( ) npj . Status . Completion Time = & now } npj . Status . State = want State npj . Status . Description = want Msg logrus . Infof ( " " , key ) if _ , err = c . update Prow Job ( npj ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } return nil } 
func prow Job Status ( bs buildv 1alpha 1 . Build Status ) ( prowjobv 1 . Prow Job State , string ) { started : = bs . Start Time finished : = bs . Completion Time pcond : = bs . Get Condition ( buildv 1alpha 1 . Build Succeeded ) if pcond = = nil { if ! finished . Is Zero ( ) { return prowjobv 1 . Error State , desc Missing Condition } return prowjobv 1 . Triggered State , desc Scheduling } cond : = * pcond switch { case cond . Status = = coreapi . Condition True : return prowjobv 1 . Success State , description ( cond , desc Succeeded ) case cond . Status = = coreapi . Condition False : return prowjobv 1 . Failure State , description ( cond , desc Failed ) case started . Is Zero ( ) : return prowjobv 1 . Triggered State , description ( cond , desc Initializing ) case cond . Status = = coreapi . Condition Unknown , finished . Is Zero ( ) : return prowjobv 1 . Pending State , description ( cond , desc Running ) } logrus . Warnf ( " " , cond ) return prowjobv 1 . Error State , description ( cond , desc Unknown ) } 
func build Env ( pj prowjobv 1 . Prow Job , build ID string ) ( map [ string ] string , error ) { return downwardapi . Env For Spec ( downwardapi . New Job Spec ( pj . Spec , build ID , pj . Name ) ) } 
func default Arguments ( t * buildv 1alpha 1 . Template Instantiation Spec , raw Env map [ string ] string ) { keys : = sets . String { } for _ , arg : = range t . Arguments { keys . Insert ( arg . Name ) } for _ , k : = range sets . String Key Set ( raw Env ) . List ( ) { } t . Arguments = append ( t . Arguments , buildv 1alpha 1 . Argument Spec { Name : k , Value : raw Env [ k ] } ) } } 
func default Env ( c * coreapi . Container , raw Env map [ string ] string ) { keys : = sets . String { } for _ , arg : = range c . Env { keys . Insert ( arg . Name ) } for _ , k : = range sets . String Key Set ( raw Env ) . List ( ) { } c . Env = append ( c . Env , coreapi . Env Var { Name : k , Value : raw Env [ k ] } ) } } 
func inject Environment ( b * buildv 1alpha 1 . Build , raw Env map [ string ] string ) { for i : = range b . Spec . Steps { } if b . Spec . Template ! = nil { } } 
func inject Source ( b * buildv 1alpha 1 . Build , pj prowjobv 1 . Prow Job ) ( bool , error ) { if b . Spec . Source ! = nil { return false , nil } src Container , refs , clone Volumes , err : = decorate . Clone Refs ( pj , code Mount , log Mount ) if err ! = nil { return false , fmt . Errorf ( " " , err ) } if src Container = = nil { return false , nil } else { src Container . Name = " " } b . Spec . Source = & buildv 1alpha 1 . Source Spec { Custom : src Container , } b . Spec . Volumes = append ( b . Spec . Volumes , clone Volumes . . . ) wd : = work Dir ( refs [ 0 ] ) } b . Spec . Steps [ i ] . Working Dir = wd . Value } if b . Spec . Template ! = nil { } return true , nil } 
func injected Steps ( encoded Job Spec string , dc prowjobv 1 . Decoration Config , injected Source bool , tools Mount coreapi . Volume Mount , entries [ ] wrapper . Options ) ( [ ] coreapi . Container , * coreapi . Container , * coreapi . Volume , error ) { gcs Vol , gcs Mount , gcs Options : = decorate . GCSOptions ( dc ) sidecar , err : = decorate . Sidecar ( dc . Utility Images . Sidecar , gcs Options , gcs Mount , log Mount , encoded Job Spec , decorate . Require Passing Entries , entries . . . ) if err ! = nil { return nil , nil , nil , fmt . Errorf ( " " , err ) } var clone Log Mount * coreapi . Volume Mount if injected Source { clone Log Mount = & log Mount } init Upload , err : = decorate . Init Upload ( dc . Utility Images . Init Upload , gcs Options , gcs Mount , clone Log Mount , encoded Job Spec ) if err ! = nil { return nil , nil , nil , fmt . Errorf ( " " , err ) } placer : = decorate . Place Entrypoint ( dc . Utility Images . Entrypoint , tools Mount ) return [ ] coreapi . Container { placer , * init Upload } , sidecar , & gcs Vol , nil } 
func determine Timeout ( spec * buildv 1alpha 1 . Build Spec , dc * prowjobv 1 . Decoration Config , default Timeout time . Duration ) time . Duration { switch { case spec . Timeout ! = nil : return spec . Timeout . Duration case dc ! = nil & & dc . Timeout . Duration > 0 : return dc . Timeout . Duration default : return default Timeout } } 
func make Build ( pj prowjobv 1 . Prow Job , default Timeout time . Duration ) ( * buildv 1alpha 1 . Build , error ) { if pj . Spec . Build Spec = = nil { return nil , errors . New ( " " ) } build ID : = pj . Status . Build ID if build ID = = " " { return nil , errors . New ( " " ) } b : = buildv 1alpha 1 . Build { Object Meta : build Meta ( pj ) , Spec : * pj . Spec . Build Spec . Deep Copy ( ) , } raw Env , err : = build Env ( pj , build ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } inject Environment ( & b , raw Env ) injected Source , err : = inject Source ( & b , pj ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } inject Timeout ( & b . Spec , pj . Spec . Decoration Config , default Timeout ) if pj . Spec . Decoration Config ! = nil { encoded Job Spec : = raw Env [ downwardapi . Job Spec Env ] err = decorate Build ( & b . Spec , encoded Job Spec , * pj . Spec . Decoration Config , injected Source ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } return & b , nil } 
func New Issue ( g Issue * github . Issue , repository string ) ( * sql . Issue , error ) { if g Issue . Number = = nil | | g Issue . Title = = nil | | g Issue . User = = nil | | g Issue . User . Login = = nil | | g Issue . State = = nil | | g Issue . Comments = = nil | | g Issue . Created At = = nil | | g Issue . Updated At = = nil { return nil , fmt . Errorf ( " " , g Issue ) } var closed At * time . Time if g Issue . Closed At ! = nil { closed At = g Issue . Closed At } assignees , err : = new Assignees ( * g Issue . Number , g Issue . Assignees , repository ) if err ! = nil { return nil , err } var body string if g Issue . Body ! = nil { body = * g Issue . Body } is PR : = ( g Issue . Pull Request Links ! = nil & & g Issue . Pull Request Links . URL ! = nil ) labels , err : = new Labels ( * g Issue . Number , g Issue . Labels , repository ) if err ! = nil { return nil , err } return & sql . Issue { ID : strconv . Itoa ( * g Issue . Number ) , Labels : labels , Title : * g Issue . Title , Body : body , User : * g Issue . User . Login , Assignees : assignees , State : * g Issue . State , Comments : * g Issue . Comments , Is PR : is PR , Issue Closed At : closed At , Issue Created At : * g Issue . Created At , Issue Updated At : * g Issue . Updated At , Repository : strings . To Lower ( repository ) , } , nil } 
func New Issue Event ( g Issue Event * github . Issue Event , issue ID int , repository string ) ( * sql . Issue Event , error ) { if g Issue Event . ID = = nil | | g Issue Event . Event = = nil | | g Issue Event . Created At = = nil { return nil , fmt . Errorf ( " " , g Issue Event ) } var label * string if g Issue Event . Label ! = nil { label = g Issue Event . Label . Name } var assignee * string if g Issue Event . Assignee ! = nil { assignee = g Issue Event . Assignee . Login } var actor * string if g Issue Event . Actor ! = nil { actor = g Issue Event . Actor . Login } return & sql . Issue Event { ID : itoa ( * g Issue Event . ID ) , Label : label , Event : * g Issue Event . Event , Event Created At : * g Issue Event . Created At , Issue ID : strconv . Itoa ( issue ID ) , Assignee : assignee , Actor : actor , Repository : strings . To Lower ( repository ) , } , nil } 
func new Labels ( issue ID int , g Labels [ ] github . Label , repository string ) ( [ ] sql . Label , error ) { labels : = [ ] sql . Label { } repository = strings . To Lower ( repository ) for _ , label : = range g Labels { if label . Name = = nil { return nil , fmt . Errorf ( " " ) } labels = append ( labels , sql . Label { Issue ID : strconv . Itoa ( issue ID ) , Name : * label . Name , Repository : repository , } ) } return labels , nil } 
func new Assignees ( issue ID int , g Assignees [ ] * github . User , repository string ) ( [ ] sql . Assignee , error ) { assignees : = [ ] sql . Assignee { } repository = strings . To Lower ( repository ) for _ , assignee : = range g Assignees { if assignee ! = nil & & assignee . Login = = nil { return nil , fmt . Errorf ( " " ) } assignees = append ( assignees , sql . Assignee { Issue ID : strconv . Itoa ( issue ID ) , Name : * assignee . Login , Repository : repository , } ) } return assignees , nil } 
func New Issue Comment ( issue ID int , g Comment * github . Issue Comment , repository string ) ( * sql . Comment , error ) { if g Comment . ID = = nil | | g Comment . Body = = nil | | g Comment . Created At = = nil | | g Comment . Updated At = = nil { return nil , fmt . Errorf ( " " , g Comment ) } var login string if g Comment . User ! = nil & & g Comment . User . Login ! = nil { login = * g Comment . User . Login } return & sql . Comment { ID : itoa ( * g Comment . ID ) , Issue ID : strconv . Itoa ( issue ID ) , Body : * g Comment . Body , User : login , Comment Created At : * g Comment . Created At , Comment Updated At : * g Comment . Updated At , Pull Request : false , Repository : strings . To Lower ( repository ) , } , nil } 
func message Filter ( last Update time . Time , change client . Change Info , presubmits [ ] config . Presubmit ) ( pjutil . Filter , error ) { var filters [ ] pjutil . Filter current Revision : = change . Revisions [ change . Current Revision ] . Number for _ , message : = range change . Messages { message Time : = message . Date . Time if message . Revision Number ! = current Revision | | ! message Time . After ( last Update ) { continue } if ! pjutil . Test All Re . Match String ( message . Message ) { for _ , presubmit : = range presubmits { if presubmit . Trigger Matches ( message . Message ) { logrus . Infof ( " " , change . Number , message . Message , presubmit . Name ) filters = append ( filters , pjutil . Command Filter ( message . Message ) ) } } } else { filters = append ( filters , pjutil . Test All Filter ( ) ) } } return pjutil . Aggregate Filter ( filters ) , nil } 
func ( jb * Build ) Is Success ( ) bool { return jb . Result ! = nil & & * jb . Result = = success } 
func ( jb * Build ) Is Failure ( ) bool { return jb . Result ! = nil & & ( * jb . Result = = failure | | * jb . Result = = unstable ) } 
func ( jb * Build ) Is Aborted ( ) bool { return jb . Result ! = nil & & * jb . Result = = aborted } 
func ( jb * Build ) Prow Job ID ( ) string { for _ , action : = range jb . Actions { for _ , p : = range action . Parameters { if p . Name = = prow Job ID { value , ok : = p . Value . ( string ) if ! ok { logrus . Errorf ( " " , p . Name , jb ) continue } return value } } } return " " } 
func ( jb * Build ) Build ID ( ) string { var build ID string has Prow Job ID : = false for _ , action : = range jb . Actions { for _ , p : = range action . Parameters { has Prow Job ID = has Prow Job ID | | p . Name = = prow Job ID if p . Name = = status Build ID { value , ok : = p . Value . ( string ) if ! ok { logrus . Errorf ( " " , p . Name , jb ) continue } build ID = value } } } if ! has Prow Job ID { return " " } return build ID } 
func New Client ( url string , dry Run bool , tls Config * tls . Config , auth Config * Auth Config , logger * logrus . Entry , metrics * Client Metrics , ) ( * Client , error ) { if logger = = nil { logger = logrus . New Entry ( logrus . Standard Logger ( ) ) } c : = & Client { logger : logger . With Field ( " " , " " ) , dry Run : dry Run , base URL : url , auth Config : auth Config , client : & http . Client { Timeout : 3 0 * time . Second , } , metrics : metrics , } if tls Config ! = nil { c . client . Transport = & http . Transport { TLSClient Config : tls Config } } if c . auth Config . CSRFProtect { if err : = c . Crumb Request ( ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } return c , nil } 
func ( c * Client ) Crumb Request ( ) error { if c . auth Config . csrf Token ! = " " & & c . auth Config . csrf Request Field ! = " " { return nil } c . logger . Debug ( " " ) data , err : = c . Get Skip Metrics ( " " ) if err ! = nil { return err } crumb Resp : = struct { Crumb string `json : "crumb " ` Crumb Request Field string `json : "crumb Request Field " ` } { } if err : = json . Unmarshal ( data , & crumb Resp ) ; err ! = nil { return fmt . Errorf ( " " , err ) } c . auth Config . csrf Token = crumb Resp . Crumb c . auth Config . csrf Request Field = crumb Resp . Crumb Request Field return nil } 
func ( c * Client ) measure ( method , path string , code int , start time . Time ) { if c . metrics = = nil { return } c . metrics . Request Latency . With Label Values ( method , path ) . Observe ( time . Since ( start ) . Seconds ( ) ) c . metrics . Requests . With Label Values ( method , path , fmt . Sprintf ( " " , code ) ) . Inc ( ) } 
func ( c * Client ) Get Skip Metrics ( path string ) ( [ ] byte , error ) { resp , err : = c . request ( http . Method Get , path , nil , false ) if err ! = nil { return nil , err } return read Resp ( resp ) } 
func ( c * Client ) Get ( path string ) ( [ ] byte , error ) { resp , err : = c . request ( http . Method Get , path , nil , true ) if err ! = nil { return nil , err } return read Resp ( resp ) } 
func ( c * Client ) request ( method , path string , params url . Values , measure bool ) ( * http . Response , error ) { var resp * http . Response var err error backoff : = retry Delay url Path : = fmt . Sprintf ( " " , c . base URL , path ) if params ! = nil { url Path = fmt . Sprintf ( " " , url Path , params . Encode ( ) ) } start : = time . Now ( ) for retries : = 0 ; retries < max Retries ; retries + + { resp , err = c . do Request ( method , url Path ) if err = = nil & & resp . Status Code < 5 0 0 { break } else if err = = nil & & retries + 1 < max Retries { resp . Body . Close ( ) } } time . Sleep ( backoff ) backoff * = 2 } if measure & & resp ! = nil { c . measure ( method , path , resp . Status Code , start ) } return resp , err } 
func ( c * Client ) do Request ( method , path string ) ( * http . Response , error ) { req , err : = http . New Request ( method , path , nil ) if err ! = nil { return nil , err } if c . auth Config ! = nil { if c . auth Config . Basic ! = nil { req . Set Basic Auth ( c . auth Config . Basic . User , string ( c . auth Config . Basic . Get Token ( ) ) ) } if c . auth Config . Bearer Token ! = nil { req . Header . Set ( " " , fmt . Sprintf ( " " , c . auth Config . Bearer Token . Get Token ( ) ) ) } if c . auth Config . CSRFProtect & & c . auth Config . csrf Request Field ! = " " & & c . auth Config . csrf Token ! = " " { req . Header . Set ( c . auth Config . csrf Request Field , c . auth Config . csrf Token ) } } return c . client . Do ( req ) } 
func get Job Name ( spec * prowapi . Prow Job Spec ) string { if spec . Jenkins Spec ! = nil & & spec . Jenkins Spec . Git Hub Branch Source Job & & spec . Refs ! = nil { if len ( spec . Refs . Pulls ) > 0 { return fmt . Sprintf ( " " , spec . Job , spec . Refs . Pulls [ 0 ] . Number ) } return fmt . Sprintf ( " " , spec . Job , spec . Refs . Base Ref ) } return spec . Job } 
func get Build Path ( spec * prowapi . Prow Job Spec ) string { jenkins Job Name : = get Job Name ( spec ) jenkins Path : = fmt . Sprintf ( " " , jenkins Job Name ) return jenkins Path } 
func ( c * Client ) Get Job Info ( spec * prowapi . Prow Job Spec ) ( * Job Info , error ) { path : = get Job Info Path ( spec ) c . logger . Debugf ( " " , path ) data , err : = c . Get ( path ) if err ! = nil { c . logger . Errorf ( " " , err ) return nil , err } var job Info Job Info if err : = json . Unmarshal ( data , & job Info ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } c . logger . Tracef ( " " , job Info ) return & job Info , nil } 
func ( c * Client ) Job Parameterized ( job Info * Job Info ) bool { for _ , prop : = range job Info . Property { if prop . Parameter Definitions ! = nil & & len ( prop . Parameter Definitions ) > 0 { return true } } return false } 
func ( c * Client ) Ensure Buildable Job ( spec * prowapi . Prow Job Spec ) error { var job Info * Job Info get Job Err : = wait . Exponential Backoff ( get Job Info Backoff , func ( ) ( bool , error ) { var job Err error job Info , job Err = c . Get Job Info ( spec ) if job Err ! = nil & & ! strings . Contains ( strings . To Lower ( job Err . Error ( ) ) , " " ) { return false , job Err } return job Info ! = nil , nil } ) if get Job Err ! = nil { return fmt . Errorf ( " " , spec . Job ) } is Parameterized : = c . Job Parameterized ( job Info ) c . logger . Tracef ( " " , is Parameterized ) if is Parameterized | | len ( job Info . Builds ) > 0 { return nil } build Err : = c . Launch Build ( spec , nil ) if build Err ! = nil { return build Err } backoff : = wait . Backoff { Duration : time . Duration ( 5 ) * time . Second , Factor : 1 , Jitter : 1 , Steps : 1 0 , } return wait . Exponential Backoff ( backoff , func ( ) ( bool , error ) { c . logger . Debugf ( " " , spec . Job ) job Info , _ : = c . Get Job Info ( spec ) is Parameterized : = false if job Info ! = nil { is Parameterized = c . Job Parameterized ( job Info ) if is Parameterized & & job Info . Last Build ! = nil { c . logger . Debugf ( " " , spec . Job ) err : = c . Abort ( get Job Name ( spec ) , job Info . Last Build ) if err ! = nil { c . logger . Infof ( " " , job Info . Last Build . Number , spec . Job , err ) } } } } ) } 
func ( c * Client ) Launch Build ( spec * prowapi . Prow Job Spec , params url . Values ) error { var path string if params ! = nil { path = get Build With Parameters Path ( spec ) } else { path = get Build Path ( spec ) } c . logger . Debugf ( " " , path ) resp , err : = c . request ( http . Method Post , path , params , true ) if err ! = nil { return err } defer resp . Body . Close ( ) if resp . Status Code ! = 2 0 1 { return fmt . Errorf ( " " , resp . Status ) } return nil } 
func ( c * Client ) Build ( pj * prowapi . Prow Job , build ID string ) error { c . logger . With Fields ( pjutil . Prow Job Fields ( pj ) ) . Info ( " " ) return c . Build From Spec ( & pj . Spec , build ID , pj . Object Meta . Name ) } 
func ( c * Client ) Build From Spec ( spec * prowapi . Prow Job Spec , build ID , prow Job ID string ) error { if c . dry Run { return nil } env , err : = downwardapi . Env For Spec ( downwardapi . New Job Spec ( * spec , build ID , prow Job ID ) ) if err ! = nil { return err } params : = url . Values { } for key , value : = range env { params . Set ( key , value ) } if err : = c . Ensure Buildable Job ( spec ) ; err ! = nil { return fmt . Errorf ( " " , spec . Job , err ) } return c . Launch Build ( spec , params ) } 
func ( c * Client ) List Builds ( jobs [ ] Build Query Params ) ( map [ string ] Build , error ) { if err ! = nil { return nil , err } build Chan : = make ( chan map [ string ] Build , len ( jobs ) ) err Chan : = make ( chan error , len ( jobs ) ) wg : = & sync . Wait Group { } wg . Add ( len ( jobs ) ) builds , err : = c . Get Builds ( job ) if err ! = nil { err Chan < - err } else { build Chan < - builds } } ( job . Job Name ) } wg . Wait ( ) close ( build Chan ) close ( err Chan ) for err : = range err Chan { if err ! = nil { return nil , err } } for builds : = range build Chan { for id , build : = range builds { jenkins Builds [ id ] = build } } return jenkins Builds , nil } 
func ( c * Client ) Get Enqueued Builds ( jobs [ ] Build Query Params ) ( map [ string ] Build , error ) { c . logger . Debug ( " " ) data , err : = c . Get ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } page : = struct { Queued Builds [ ] Build `json : "items " ` } { } if err : = json . Unmarshal ( data , & page ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } jenkins Builds : = make ( map [ string ] Build ) for _ , jb : = range page . Queued Builds { prow Job ID : = jb . Prow Job ID ( ) } for _ , job : = range jobs { if prow Job ID = = job . Prow Job ID { exists = true break } } if ! exists { continue } jb . enqueued = true jenkins Builds [ prow Job ID ] = jb } return jenkins Builds , nil } 
func ( c * Client ) Get Builds ( job string ) ( map [ string ] Build , error ) { c . logger . Debugf ( " " , job ) data , err : = c . Get ( fmt . Sprintf ( " " , job ) ) if err ! = nil { return nil , nil } return nil , fmt . Errorf ( " " , job , err ) } page : = struct { Builds [ ] Build `json : "builds " ` } { } if err : = json . Unmarshal ( data , & page ) ; err ! = nil { return nil , fmt . Errorf ( " " , job , err ) } jenkins Builds : = make ( map [ string ] Build ) for _ , jb : = range page . Builds { prow Job ID : = jb . Prow Job ID ( ) } jenkins Builds [ prow Job ID ] = jb } return jenkins Builds , nil } 
func ( c * Client ) Abort ( job string , build * Build ) error { c . logger . Debugf ( " " , job , build . Number ) if c . dry Run { return nil } resp , err : = c . request ( http . Method Post , fmt . Sprintf ( " " , job , build . Number ) , nil , false ) if err ! = nil { return err } defer resp . Body . Close ( ) if resp . Status Code < 2 0 0 | | resp . Status Code > = 3 0 0 { return fmt . Errorf ( " " , resp . Status ) } return nil } 
func Presubmit To Job Spec ( pre config . Presubmit ) * downwardapi . Job Spec { return & downwardapi . Job Spec { Type : prowapi . Presubmit Job , Job : pre . Name , } } 
func Postsubmit To Job Spec ( post config . Postsubmit ) * downwardapi . Job Spec { return & downwardapi . Job Spec { Type : prowapi . Postsubmit Job , Job : post . Name , } } 
func Periodic To Job Spec ( periodic config . Periodic ) * downwardapi . Job Spec { return & downwardapi . Job Spec { Type : prowapi . Periodic Job , Job : periodic . Name , } } 
func Get Build ID ( name , tot URL string ) ( string , error ) { if tot URL = = " " { return node . Generate ( ) . String ( ) , nil } var err error url , err : = url . Parse ( tot URL ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } url . Path = path . Join ( url . Path , " " , name ) sleep Duration : = 1 0 0 * time . Millisecond for retries : = 0 ; retries < 1 0 ; retries + + { if retries > 0 { sleep ( sleep Duration ) sleep Duration = sleep Duration * 2 } var resp * http . Response resp , err = http . Get ( url . String ( ) ) if err ! = nil { continue } defer resp . Body . Close ( ) if resp . Status Code ! = 2 0 0 { err = fmt . Errorf ( " " , resp . Status ) continue } var buf [ ] byte buf , err = ioutil . Read All ( resp . Body ) if err = = nil { return string ( buf ) , nil } return " " , err } return " " , err } 
func list Gcs Objects ( ctx context . Context , client * storage . Client , bucket Name , prefix , delim string ) ( [ ] string , error ) { var objects [ ] string it : = client . Bucket ( bucket Name ) . Objects ( ctx , & storage . Query { Prefix : prefix , Delimiter : delim , } ) for { attrs , err : = it . Next ( ) if err = = iterator . Done { break } if err ! = nil { return objects , fmt . Errorf ( " " , err ) } if attrs . Prefix ! = " " { objects = append ( objects , path . Base ( attrs . Prefix ) ) } } logrus . Info ( " " ) return objects , nil } 
func Find Base Profile ( ctx context . Context , client * storage . Client , bucket , prow Job Name , artifacts Dir Name , cov Profile Name string ) ( [ ] byte , error ) { dir Of Job : = path . Join ( " " , prow Job Name ) str Builds , err : = list Gcs Objects ( ctx , client , bucket , dir Of Job + " " , " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } builds : = sort Builds ( str Builds ) profile Path : = " " for _ , build : = range builds { build Dir Path : = path . Join ( dir Of Job , strconv . Itoa ( build ) ) dir Of Status JSON : = path . Join ( build Dir Path , status JSON ) status Text , err : = read Gcs Object ( ctx , client , bucket , dir Of Status JSON ) if err ! = nil { logrus . Infof ( " " , dir Of Status JSON , bucket ) } else if is Build Succeeded ( status Text ) { artifacts Dir Path : = path . Join ( build Dir Path , artifacts Dir Name ) profile Path = path . Join ( artifacts Dir Path , cov Profile Name ) break } } if profile Path = = " " { return nil , fmt . Errorf ( " " , dir Of Job , bucket , len ( builds ) ) } return read Gcs Object ( ctx , client , bucket , profile Path ) } 
func sort Builds ( str Builds [ ] string ) [ ] int { var res [ ] int for _ , build Str : = range str Builds { num , err : = strconv . Atoi ( build Str ) if err ! = nil { logrus . Infof ( " " , build Str ) } else { res = append ( res , num ) } } sort . Sort ( sort . Reverse ( sort . Int Slice ( res ) ) ) return res } 
func Get All ( sess * session . Session ) ( [ ] string , error ) { var regions [ ] string svc : = ec 2 . New ( sess , & aws . Config { Region : aws . String ( Default ) } ) resp , err : = svc . Describe Regions ( nil ) if err ! = nil { return nil , err } for _ , region : = range resp . Regions { regions = append ( regions , * region . Region Name ) } return regions , nil } 
func New Event Client ( ghc github Client , log * logrus . Entry , org , repo string , number int ) * Event Client { return & Event Client { org : org , repo : repo , number : number , ghc : ghc , log : log , } } 
func ( c * Event Client ) Prune Comments ( should Prune func ( github . Issue Comment ) bool ) { c . once . Do ( func ( ) { bot Name , err : = c . ghc . Bot Name ( ) if err ! = nil { c . log . With Error ( err ) . Error ( " " ) } comments , err : = c . ghc . List Issue Comments ( c . org , c . repo , c . number ) if err ! = nil { c . log . With Error ( err ) . Errorf ( " " , c . org , c . repo , c . number ) } if bot Name ! = " " { for _ , comment : = range comments { if comment . User . Login = = bot Name { c . comments = append ( c . comments , comment ) } } } } ) c . lock . Lock ( ) defer c . lock . Unlock ( ) var remaining [ ] github . Issue Comment for _ , comment : = range c . comments { removed : = false if should Prune ( comment ) { if err : = c . ghc . Delete Comment ( c . org , c . repo , comment . ID ) ; err ! = nil { c . log . With Error ( err ) . Errorf ( " " , comment . ID ) } else { removed = true } } if ! removed { remaining = append ( remaining , comment ) } } c . comments = remaining } 
func make Shield ( subject , status , color string ) [ ] byte { Xpos Left , Xpos Right float 6 4 Subject , Status string Color string } { Subject : subject , Status : status , Right Start : 1 3 + 6 * len ( subject ) , Right Width : 1 3 + 6 * len ( status ) , } p . Width = p . Right Start + p . Right Width p . Xpos Left = float 6 4 ( p . Right Start ) * 0 . 5 p . Xpos Right = float 6 4 ( p . Right Start ) + float 6 4 ( p . Right Width - 2 ) * 0 . 5 switch color { case " " : p . Color = " " case " " : p . Color = " " default : p . Color = color } var buf bytes . Buffer svg Template . Execute ( & buf , p ) return buf . Bytes ( ) } 
func Format Response ( to , message , reason string ) string { format : = ` @ %s : %s <details > %s %s < /details > ` return fmt . Sprintf ( format , to , message , reason , About This Bot Without Commands ) } 
func Format Simple Response ( to , message string ) string { format : = ` @ %s : %s <details > %s < /details > ` return fmt . Sprintf ( format , to , message , About This Bot Without Commands ) } 
func Format ICResponse ( ic github . Issue Comment , s string ) string { return Format Response Raw ( ic . Body , ic . HTMLURL , ic . User . Login , s ) } 
func Format Response Raw ( body , body URL , login , reply string ) string { format : = `In response to [this ] ( %s ) : %s ` for _ , l : = range strings . Split ( body , " \n " ) { quoted = append ( quoted , " " + l ) } return Format Response ( login , reply , fmt . Sprintf ( format , body URL , strings . Join ( quoted , " \n " ) ) ) } 
func ( o * Options ) Validate ( ) error { if o . gcs Path . String ( ) ! = " " { o . Bucket = o . gcs Path . Bucket ( ) o . Path Prefix = o . gcs Path . Object ( ) } if ! o . Dry Run { if o . Bucket = = " " { return errors . New ( " " ) } if o . Gcs Credentials File = = " " { return errors . New ( " " ) } } return o . GCSConfiguration . Validate ( ) } 
func ( o * Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . Sub Dir , " " , " " , " " ) fs . String Var ( & o . Path Strategy , " " , prowapi . Path Strategy Explicit , " " ) fs . String Var ( & o . Default Org , " " , " " , " " ) fs . String Var ( & o . Default Repo , " " , " " , " " ) fs . Var ( & o . gcs Path , " " , " " ) fs . String Var ( & o . Gcs Credentials File , " " , " " , " " ) fs . Bool Var ( & o . Dry Run , " " , true , " " ) } 
func Encode ( options Options ) ( string , error ) { encoded , err : = json . Marshal ( options ) return string ( encoded ) , err } 
func Register Issue Handler ( name string , fn Issue Handler , help Help Provider ) { plugin Help [ name ] = help issue Handlers [ name ] = fn } 
func Register Issue Comment Handler ( name string , fn Issue Comment Handler , help Help Provider ) { plugin Help [ name ] = help issue Comment Handlers [ name ] = fn } 
func Register Pull Request Handler ( name string , fn Pull Request Handler , help Help Provider ) { plugin Help [ name ] = help pull Request Handlers [ name ] = fn } 
func Register Status Event Handler ( name string , fn Status Event Handler , help Help Provider ) { plugin Help [ name ] = help status Event Handlers [ name ] = fn } 
func Register Push Event Handler ( name string , fn Push Event Handler , help Help Provider ) { plugin Help [ name ] = help push Event Handlers [ name ] = fn } 
func Register Review Event Handler ( name string , fn Review Event Handler , help Help Provider ) { plugin Help [ name ] = help review Event Handlers [ name ] = fn } 
func Register Review Comment Event Handler ( name string , fn Review Comment Event Handler , help Help Provider ) { plugin Help [ name ] = help review Comment Event Handlers [ name ] = fn } 
func Register Generic Comment Handler ( name string , fn Generic Comment Handler , help Help Provider ) { plugin Help [ name ] = help generic Comment Handlers [ name ] = fn } 
func New Agent ( config Agent * config . Agent , plugin Config Agent * Config Agent , client Agent * Client Agent , logger * logrus . Entry ) Agent { prow Config : = config Agent . Config ( ) plugin Config : = plugin Config Agent . Config ( ) return Agent { Git Hub Client : client Agent . Git Hub Client , Kubernetes Client : client Agent . Kubernetes Client , Prow Job Client : client Agent . Prow Job Client , Git Client : client Agent . Git Client , Slack Client : client Agent . Slack Client , Owners Client : client Agent . Owners Client , Config : prow Config , Plugin Config : plugin Config , Logger : logger , } } 
func ( a * Agent ) Initialize Comment Pruner ( org , repo string , pr int ) { a . comment Pruner = commentpruner . New Event Client ( a . Git Hub Client , a . Logger . With Field ( " " , " " ) , org , repo , pr , ) } 
func ( a * Agent ) Comment Pruner ( ) ( * commentpruner . Event Client , error ) { if a . comment Pruner = = nil { return nil , errors . New ( " " ) } return a . comment Pruner , nil } 
func ( pa * Config Agent ) Load ( path string ) error { b , err : = ioutil . Read File ( path ) if err ! = nil { return err } np : = & Configuration { } if err : = yaml . Unmarshal ( b , np ) ; err ! = nil { return err } if err : = np . Validate ( ) ; err ! = nil { return err } pa . Set ( np ) return nil } 
func ( pa * Config Agent ) Config ( ) * Configuration { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) return pa . configuration } 
func ( pa * Config Agent ) Set ( pc * Configuration ) { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) pa . configuration = pc } 
func ( pa * Config Agent ) Start ( path string ) error { if err : = pa . Load ( path ) ; err ! = nil { return err } ticker : = time . Tick ( 1 * time . Minute ) go func ( ) { for range ticker { if err : = pa . Load ( path ) ; err ! = nil { logrus . With Field ( " " , path ) . With Error ( err ) . Error ( " " ) } } } ( ) return nil } 
func ( pa * Config Agent ) Generic Comment Handlers ( owner , repo string ) map [ string ] Generic Comment Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Generic Comment Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = generic Comment Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Issue Handlers ( owner , repo string ) map [ string ] Issue Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Issue Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = issue Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Issue Comment Handlers ( owner , repo string ) map [ string ] Issue Comment Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Issue Comment Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = issue Comment Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Pull Request Handlers ( owner , repo string ) map [ string ] Pull Request Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Pull Request Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = pull Request Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Review Event Handlers ( owner , repo string ) map [ string ] Review Event Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Review Event Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = review Event Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Review Comment Event Handlers ( owner , repo string ) map [ string ] Review Comment Event Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Review Comment Event Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = review Comment Event Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Status Event Handlers ( owner , repo string ) map [ string ] Status Event Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Status Event Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = status Event Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) Push Event Handlers ( owner , repo string ) map [ string ] Push Event Handler { pa . mut . Lock ( ) defer pa . mut . Unlock ( ) hs : = map [ string ] Push Event Handler { } for _ , p : = range pa . get Plugins ( owner , repo ) { if h , ok : = push Event Handlers [ p ] ; ok { hs [ p ] = h } } return hs } 
func ( pa * Config Agent ) get Plugins ( owner , repo string ) [ ] string { var plugins [ ] string full Name : = fmt . Sprintf ( " " , owner , repo ) plugins = append ( plugins , pa . configuration . Plugins [ owner ] . . . ) plugins = append ( plugins , pa . configuration . Plugins [ full Name ] . . . ) return plugins } 
func Events For Plugin ( name string ) [ ] string { var events [ ] string if _ , ok : = issue Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = issue Comment Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = pull Request Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = push Event Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = review Event Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = review Comment Event Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = status Event Handlers [ name ] ; ok { events = append ( events , " " ) } if _ , ok : = generic Comment Handlers [ name ] ; ok { events = append ( events , " " ) } return events } 
func strip Tags ( str string ) ( string , [ ] string ) { tags : = re . Find All String ( str , - 1 ) for i , w : = range tags { w = strings . Trim Space ( w ) tags [ i ] = w [ 1 : len ( w ) - 1 ] } var reals [ ] string for _ , p : = range re . Split ( str , - 1 ) { if p = = " " { continue } reals = append ( reals , p ) } return strings . Join ( reals , " " ) , tags } 
func insert Link ( started * gcs . Started , view URL string ) ( bool , error ) { if started . Metadata = = nil { started . Metadata = metadata . Metadata { } } meta : = started . Metadata var changed bool top , present : = meta . String ( resultstore Key ) if ! present | | top = = nil | | * top ! = view URL { changed = true meta [ resultstore Key ] = view URL } links , present : = meta . Meta ( links Key ) if present & & links = = nil { return false , fmt . Errorf ( " " , meta [ links Key ] ) } if links = = nil { links = & metadata . Metadata { } changed = true } resultstore Meta , present : = links . Meta ( resultstore Key ) if present & & resultstore Meta = = nil { return false , fmt . Errorf ( " " , ( * links ) [ resultstore Key ] ) } if resultstore Meta = = nil { resultstore Meta = & metadata . Metadata { } changed = true } val , present : = resultstore Meta . String ( url Key ) if present & & val = = nil { return false , fmt . Errorf ( " " , ( * resultstore Meta ) [ url Key ] ) } if ! changed & & val ! = nil & & * val = = view URL { return false , nil } ( * resultstore Meta ) [ url Key ] = view URL ( * links ) [ resultstore Key ] = * resultstore Meta meta [ links Key ] = * links return true , nil } 
func Parse Config ( config Path string ) ( [ ] common . Resources Config , error ) { if _ , err : = os . Stat ( config Path ) ; os . Is Not Exist ( err ) { return nil , err } file , err : = ioutil . Read File ( config Path ) if err ! = nil { return nil , err } var data common . Mason Config err = yaml . Unmarshal ( file , & data ) if err ! = nil { return nil , err } return data . Configs , nil } 
func Validate Config ( configs [ ] common . Resources Config , resources [ ] common . Resource ) error { resources Needs : = map [ string ] int { } actual Resources : = map [ string ] int { } config Names : = map [ string ] map [ string ] int { } for _ , c : = range configs { _ , already Exists : = config Names [ c . Name ] if already Exists { return fmt . Errorf ( " " , c . Name ) } config Names [ c . Name ] = c . Needs } for _ , res : = range resources { _ , use Config : = config Names [ res . Type ] if use Config { c , ok : = config Names [ res . Type ] if ! ok { err : = fmt . Errorf ( " " , res . Type ) logrus . With Error ( err ) . Error ( " " ) return err } } } actual Resources [ res . Type ] + + } for r Type , needs : = range resources Needs { actual , ok : = actual Resources [ r Type ] if ! ok { err : = fmt . Errorf ( " " , r Type ) logrus . With Error ( err ) . Errorf ( " " ) return err } if needs > actual { err : = fmt . Errorf ( " " , r Type ) logrus . With Error ( err ) . Errorf ( " " ) return err } } return nil } 
func New Mason ( cleaner Count int , client boskos Client , wait Period , sync Period time . Duration ) * Mason { return & Mason { client : client , cleaner Count : cleaner Count , storage : * new Storage ( storage . New Memory Storage ( ) ) , pending : make ( chan requirements ) , cleaned : make ( chan requirements , cleaner Count + 1 ) , fulfilled : make ( chan requirements , cleaner Count + 1 ) , boskos Wait Period : wait Period , boskos Sync Period : sync Period , config Converters : map [ string ] Config Converter { } , } } 
func ( m * Mason ) Register Config Converter ( name string , fn Config Converter ) error { _ , ok : = m . config Converters [ name ] if ok { return fmt . Errorf ( " " , name ) } m . config Converters [ name ] = fn return nil } 
func ( m * Mason ) Update Configs ( storage Path string ) error { configs , err : = Parse Config ( storage Path ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return err } return m . storage . Sync Configs ( configs ) } 
func ( m * Mason ) Start ( ) { ctx , cancel : = context . With Cancel ( context . Background ( ) ) m . cancel = cancel m . start ( ctx , m . sync All ) m . start ( ctx , m . recycle All ) m . start ( ctx , m . fulfill All ) for i : = 0 ; i < m . cleaner Count ; i + + { m . start ( ctx , m . clean All ) } m . start ( ctx , m . free All ) logrus . Info ( " " ) } 
func ( m * Mason ) Stop ( ) { logrus . Info ( " " ) m . cancel ( ) m . wg . Wait ( ) close ( m . pending ) close ( m . cleaned ) close ( m . fulfilled ) m . client . Release All ( common . Dirty ) logrus . Info ( " " ) } 
func Help Provider ( enabled Repos [ ] string ) ( * pluginhelp . Plugin Help , error ) { plugin Help : = & pluginhelp . Plugin Help { Description : `The cherrypick plugin is used for cherrypicking PRs across branches . For every successful cherrypick invocation a new PR is opened against the target branch and assigned to the requester . If the parent PR contains a release note , it is copied to the cherrypick PR . ` , } plugin Help . Add Command ( pluginhelp . Command { Usage : " " , Description : " " , Featured : true , return plugin Help , nil } 
func ( s * Server ) ensure Fork Exists ( org , repo string ) error { s . repo Lock . Lock ( ) defer s . repo Lock . Unlock ( ) if ! repo Exists ( fork , s . repos ) { if err : = s . ghc . Create Fork ( org , repo ) ; err ! = nil { return fmt . Errorf ( " " , org , repo , err ) } if err : = wait For Repo ( s . bot Name , repo , s . ghc ) ; err ! = nil { return fmt . Errorf ( " " , org , repo , err ) } s . repos = append ( s . repos , github . Repo { Full Name : fork , Fork : true } ) } return nil } 
func ( s * Server ) get Patch ( org , repo , target Branch string , num int ) ( string , error ) { patch , err : = s . ghc . Get Pull Request Patch ( org , repo , num ) if err ! = nil { return " " , err } local Path : = fmt . Sprintf ( " " , org , repo , num , normalize ( target Branch ) ) out , err : = os . Create ( local Path ) if err ! = nil { return " " , err } defer out . Close ( ) if _ , err : = io . Copy ( out , bytes . New Buffer ( patch ) ) ; err ! = nil { return " " , err } return local Path , nil } 
func release Note From Parent PR ( body string ) string { potential Match : = release Note Re . Find String Submatch ( body ) if potential Match = = nil { return " " } return fmt . Sprintf ( " \n \n " , strings . Trim Space ( potential Match [ 1 ] ) ) } 
func Validate Payload ( payload [ ] byte , sig string , key [ ] byte ) bool { if ! strings . Has Prefix ( sig , " " ) { return false } sig = sig [ 5 : ] sb , err : = hex . Decode String ( sig ) if err ! = nil { return false } mac : = hmac . New ( sha 1 . New , key ) mac . Write ( payload ) expected : = mac . Sum ( nil ) return hmac . Equal ( sb , expected ) } 
func Payload Signature ( payload [ ] byte , key [ ] byte ) string { mac : = hmac . New ( sha 1 . New , key ) mac . Write ( payload ) sum : = mac . Sum ( nil ) return " " + hex . Encode To String ( sum ) } 
func find Team ( teams map [ string ] github . Team , name string , previous Names . . . string ) * github . Team { if t , ok : = teams [ name ] ; ok { return & t } for _ , p : = range previous Names { if t , ok : = teams [ p ] ; ok { return & t } } return nil } 
func validate Team Names ( org Config org . Config ) error { dups : = sets . String { } for name , org Team : = range org Config . Teams { if used . Has ( name ) { dups . Insert ( name ) } else { used . Insert ( name ) } for _ , n : = range org Team . Previously { if used . Has ( n ) { dups . Insert ( n ) } else { used . Insert ( n ) } } } if n : = len ( dups ) ; n > 0 { return fmt . Errorf ( " " , n , strings . Join ( dups . List ( ) , " " ) ) } return nil } 
func configure Teams ( client team Client , org Name string , org Config org . Config , max Delta float 6 4 , ignore Secret Teams bool ) ( map [ string ] github . Team , error ) { if err : = validate Team Names ( org Config ) ; err ! = nil { return nil , err } ints : = sets . Int { } team List , err : = client . List Teams ( org Name ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } logrus . Debugf ( " " , len ( team List ) ) for _ , t : = range team List { if ignore Secret Teams & & org . Privacy ( t . Privacy ) = = org . Secret { continue } ids [ t . ID ] = t ints . Insert ( t . ID ) } if ignore Secret Teams { logrus . Debugf ( " " , len ( team List ) ) } names : = map [ string ] github . Team { } for _ , t : = range ids { logger : = logrus . With Fields ( logrus . Fields { " " : t . ID , " " : t . Name } ) n : = t . Name switch val , ok : = names [ n ] ; { case ! ok : names [ n ] = t case ok & & t . ID < val . ID : names [ n ] = t older [ n ] = append ( older [ n ] , val ) default : older [ n ] = append ( older [ n ] , val ) } } missing : = map [ string ] org . Team { } used : = sets . Int { } var match func ( teams map [ string ] org . Team ) match = func ( teams map [ string ] org . Team ) { for name , org Team : = range teams { logger : = logrus . With Field ( " " , name ) match ( org Team . Children ) t : = find Team ( names , name , org Team . Previously . . . ) if t = = nil { missing [ name ] = org Team logger . Debug ( " " ) continue } matches [ name ] = * t logger . With Field ( " " , t . ID ) . Debug ( " " ) used . Insert ( t . ID ) } } match ( org Config . Teams ) if delta : = float 6 4 ( len ( unused ) ) / float 6 4 ( len ( ints ) ) ; delta > max Delta { return nil , fmt . Errorf ( " " , len ( unused ) , delta , org Name , max Delta ) } for name , org Team : = range missing { t : = & github . Team { Name : name } if org Team . Description ! = nil { t . Description = * org Team . Description } if org Team . Privacy ! = nil { t . Privacy = string ( * org Team . Privacy ) } t , err : = client . Create Team ( org Name , * t ) if err ! = nil { logrus . With Error ( err ) . Warnf ( " " , name , org Name ) failures = append ( failures , name ) continue } matches [ name ] = * t } if n : = len ( failures ) ; n > 0 { return nil , fmt . Errorf ( " " , n , strings . Join ( failures , " " ) ) } unused = unused . Difference ( reused ) } logrus . With Error ( err ) . Warnf ( " " , str , org Name ) failures = append ( failures , str ) } } if n : = len ( failures ) ; n > 0 { return nil , fmt . Errorf ( " " , n , strings . Join ( failures , " " ) ) } } 
func update String ( have , want * string ) bool { switch { case have = = nil : panic ( " " ) case want = = nil : return false case * have = = * want : return false } * have = * want return true } 
func update Bool ( have , want * bool ) bool { switch { case have = = nil : panic ( " " ) case want = = nil : return false case * have = = * want : return false } * have = * want return true } 
func configure Org Meta ( client org Metadata Client , org Name string , want org . Metadata ) error { cur , err : = client . Get Org ( org Name ) if err ! = nil { return fmt . Errorf ( " " , org Name , err ) } change : = false change = update String ( & cur . Billing Email , want . Billing Email ) | | change change = update String ( & cur . Company , want . Company ) | | change change = update String ( & cur . Email , want . Email ) | | change change = update String ( & cur . Name , want . Name ) | | change change = update String ( & cur . Description , want . Description ) | | change change = update String ( & cur . Location , want . Location ) | | change if want . Default Repository Permission ! = nil { w : = string ( * want . Default Repository Permission ) change = update String ( & cur . Default Repository Permission , & w ) } change = update Bool ( & cur . Has Organization Projects , want . Has Organization Projects ) | | change change = update Bool ( & cur . Has Repository Projects , want . Has Repository Projects ) | | change change = update Bool ( & cur . Members Can Create Repositories , want . Members Can Create Repositories ) | | change if change { if _ , err : = client . Edit Org ( org Name , * cur ) ; err ! = nil { return fmt . Errorf ( " " , org Name , err ) } } return nil } 
func configure Team ( client edit Team Client , org Name , team Name string , team org . Team , gt github . Team , parent * int ) error { if gt . Name ! = team Name { patch = true } gt . Name = team Name if team . Description ! = nil & & gt . Description ! = * team . Description { patch = true gt . Description = * team . Description } else { gt . Description = " " } gt . Parent Team ID = parent } if gt . Parent ! = nil { gt . Parent = nil gt . Parent Team ID = parent } else if gt . Parent . ID ! = * parent { gt . Parent = nil gt . Parent Team ID = parent } } if team . Privacy ! = nil & & gt . Privacy ! = string ( * team . Privacy ) { patch = true gt . Privacy = string ( * team . Privacy ) } else if team . Privacy = = nil & & ( parent ! = nil | | len ( team . Children ) > 0 ) & & gt . Privacy ! = " " { patch = true gt . Privacy = github . Privacy Closed } if patch { } } return nil } 
func configure Team Repos ( client team Repo Client , github Teams map [ string ] github . Team , name , org Name string , team org . Team ) error { gt , ok : = github Teams [ name ] if ! ok { } want : = team . Repos have : = map [ string ] github . Repo Permission Level { } repos , err : = client . List Team Repos ( gt . ID ) if err ! = nil { return fmt . Errorf ( " " , gt . ID , name , err ) } for _ , repo : = range repos { have [ repo . Name ] = github . Level From Permissions ( repo . Permissions ) } actions : = map [ string ] github . Repo Permission Level { } for want Repo , want Permission : = range want { if have Permission , have Repo : = have [ want Repo ] ; have Repo & & have Permission = = want Permission { } } for have Repo : = range have { if _ , want Repo : = want [ have Repo ] ; ! want Repo { } } var update Errors [ ] error for repo , permission : = range actions { var err error if permission = = github . None { err = client . Remove Team Repo ( gt . ID , org Name , repo ) } else { err = client . Update Team Repo ( gt . ID , org Name , repo , permission ) } if err ! = nil { update Errors = append ( update Errors , fmt . Errorf ( " " , gt . ID , name , repo , permission , err ) ) } } return errorutil . New Aggregate ( update Errors . . . ) } 
func configure Team Members ( client team Members Client , gt github . Team , team org . Team ) error { want Members : = sets . New String ( team . Members . . . ) have Members : = sets . String { } members , err : = client . List Team Members ( gt . ID , github . Role Member ) if err ! = nil { return fmt . Errorf ( " " , gt . ID , gt . Name , err ) } for _ , m : = range members { have Members . Insert ( m . Login ) } maintainers , err : = client . List Team Members ( gt . ID , github . Role Maintainer ) if err ! = nil { return fmt . Errorf ( " " , gt . ID , gt . Name , err ) } for _ , m : = range maintainers { have Maintainers . Insert ( m . Login ) } invitees , err : = team Invitations ( client , gt . ID ) if err ! = nil { return fmt . Errorf ( " " , gt . ID , gt . Name , err ) } adder : = func ( user string , super bool ) error { if invitees . Has ( user ) { logrus . Infof ( " " , user , gt . ID , gt . Name ) return nil } role : = github . Role Member if super { role = github . Role Maintainer } tm , err : = client . Update Team Membership ( gt . ID , user , super ) if err ! = nil { logrus . With Error ( err ) . Warnf ( " " , gt . ID , gt . Name , user , super ) } else if tm . State = = github . State Pending { logrus . Infof ( " " , user , gt . ID , gt . Name , role ) } else { logrus . Infof ( " " , user , role , gt . ID , gt . Name ) } return err } remover : = func ( user string ) error { err : = client . Remove Team Membership ( gt . ID , user ) if err ! = nil { logrus . With Error ( err ) . Warnf ( " " , gt . ID , gt . Name , user ) } else { logrus . Infof ( " " , user , gt . ID , gt . Name ) } return err } want : = memberships { members : want Members , super : want Maintainers } have : = memberships { members : have Members , super : have Maintainers } return configure Members ( have , want , invitees , adder , remover ) } 
func ( c * Client ) Should Report ( pj * prowapi . Prow Job ) bool { pub Sub Map : = find Labels ( pj , Pub Sub Project Label , Pub Sub Topic Label ) return pub Sub Map [ Pub Sub Project Label ] ! = " " & & pub Sub Map [ Pub Sub Topic Label ] ! = " " } 
func ( c * Client ) Report ( pj * prowapi . Prow Job ) ( [ ] * prowapi . Prow Job , error ) { message : = c . generate Message From PJ ( pj ) ctx : = context . Background ( ) client , err : = pubsub . New Client ( ctx , message . Project ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } topic : = client . Topic ( message . Topic ) d , err : = json . Marshal ( message ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } res : = topic . Publish ( ctx , & pubsub . Message { Data : d , } ) _ , err = res . Get ( ctx ) if err ! = nil { return nil , fmt . Errorf ( " \ " \ " " , message . Run ID , message . Project , message . Topic , err ) } return [ ] * prowapi . Prow Job { pj } , nil } 
func ( o Options ) Run ( spec * downwardapi . Job Spec , extra map [ string ] gcs . Upload Func ) error { upload Targets : = o . assemble Targets ( spec , extra ) if ! o . Dry Run { ctx : = context . Background ( ) gcs Client , err : = storage . New Client ( ctx , option . With Credentials File ( o . Gcs Credentials File ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = gcs . Upload ( gcs Client . Bucket ( o . Bucket ) , upload Targets ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } else { for destination : = range upload Targets { logrus . With Field ( " " , destination ) . Info ( " " ) } } logrus . Info ( " " ) return nil } 
func Paths For Job ( options * prowapi . GCSConfiguration , spec * downwardapi . Job Spec , subdir string ) ( string , string , gcs . Repo Path Builder ) { builder : = builder For Strategy ( options . Path Strategy , options . Default Org , options . Default Repo ) job Base Path : = gcs . Path For Spec ( spec , builder ) if options . Path Prefix ! = " " { job Base Path = path . Join ( options . Path Prefix , job Base Path ) } var gcs Path string if subdir = = " " { gcs Path = job Base Path } else { gcs Path = path . Join ( job Base Path , subdir ) } return job Base Path , gcs Path , builder } 
func New Default Fields Formatter ( wrapped Formatter logrus . Formatter , default Fields logrus . Fields , ) * Default Fields Formatter { res : = & Default Fields Formatter { Wrapped Formatter : wrapped Formatter , Default Fields : default Fields , } if res . Wrapped Formatter = = nil { res . Wrapped Formatter = & logrus . JSONFormatter { } } return res } 
func ( d * Default Fields Formatter ) Format ( entry * logrus . Entry ) ( [ ] byte , error ) { data : = make ( logrus . Fields , len ( entry . Data ) + len ( d . Default Fields ) ) for k , v : = range d . Default Fields { data [ k ] = v } for k , v : = range entry . Data { data [ k ] = v } return d . Wrapped Formatter . Format ( & logrus . Entry { Logger : entry . Logger , Data : data , Time : entry . Time , Level : entry . Level , Message : entry . Message , } ) } 
func ( issue * Issue ) Find Labels ( regex * regexp . Regexp ) [ ] Label { labels : = [ ] Label { } for _ , label : = range issue . Labels { if regex . Match String ( label . Name ) { labels = append ( labels , label ) } } return labels } 
func ( o * Options ) Add Flags ( flags * flag . Flag Set ) { flags . String Var ( & o . Log , " " , " " , " " ) o . Options . Add Flags ( flags ) } 
func New Agent ( config * config . Git Hub OAuth Config , logger * logrus . Entry ) * Agent { return & Agent { gc : config , logger : logger , } } 
func ( ga * Agent ) Handle Login ( client OAuth Client ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { state Token : = xsrftoken . Generate ( ga . gc . Client Secret , " " , " " ) state : = hex . Encode To String ( [ ] byte ( state Token ) ) oauth Session , err : = ga . gc . Cookie Store . New ( r , oauth Session Cookie ) oauth Session . Options . Secure = true oauth Session . Options . Http Only = true if err ! = nil { ga . server Error ( w , " " , err ) return } oauth Session . Options . Max Age = 1 0 * 6 0 oauth Session . Values [ state Key ] = state if err : = oauth Session . Save ( r , w ) ; err ! = nil { ga . server Error ( w , " " , err ) return } redirect URL : = client . Auth Code URL ( state , oauth 2 . Approval Force , oauth 2 . Access Type Online ) http . Redirect ( w , r , redirect URL , http . Status Found ) } } 
func ( ga * Agent ) Handle Logout ( client OAuth Client ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { access Token Session , err : = ga . gc . Cookie Store . Get ( r , token Session ) if err ! = nil { ga . server Error ( w , " " , err ) return } if err : = access Token Session . Save ( r , w ) ; err ! = nil { ga . server Error ( w , " " , err ) return } login Cookie , err : = r . Cookie ( login Session ) if err = = nil { login Cookie . Max Age = - 1 login Cookie . Expires = time . Now ( ) . Add ( - time . Hour * 2 4 ) http . Set Cookie ( w , login Cookie ) } http . Redirect ( w , r , ga . gc . Final Redirect URL , http . Status Found ) } } 
func ( ga * Agent ) Handle Redirect ( client OAuth Client , getter Git Hub Client Getter ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { state : = r . Form Value ( " " ) state Token Raw , err : = hex . Decode String ( state ) if err ! = nil { ga . server Error ( w , " " , fmt . Errorf ( " " ) ) } state Token : = string ( state Token Raw ) return } oauth Session , err : = ga . gc . Cookie Store . Get ( r , oauth Session Cookie ) if err ! = nil { ga . server Error ( w , " " , err ) return } secret State , ok : = oauth Session . Values [ state Key ] . ( string ) if ! ok { ga . server Error ( w , " " , fmt . Errorf ( " " ) ) return } return } token , err : = client . Exchange ( context . Background ( ) , code ) if err ! = nil { if gherror : = r . Form Value ( " " ) ; len ( gherror ) > 0 { gherror Description : = r . Form Value ( " " ) gherror URI : = r . Form Value ( " " ) fields : = logrus . Fields { " " : gherror , " " : gherror Description , " " : gherror URI , } ga . logger . With Fields ( fields ) . Error ( " " ) ga . server Error ( w , " " , fmt . Errorf ( gherror ) ) } else { ga . server Error ( w , " " , err ) } return } session . Options . Secure = true session . Options . Http Only = true if err ! = nil { ga . server Error ( w , " " , err ) return } session . Values [ token Key ] = token if err : = session . Save ( r , w ) ; err ! = nil { ga . server Error ( w , " " , err ) return } ghc : = getter . Get Git Hub Client ( token . Access Token , false ) user , err : = ghc . Get User ( " " ) if err ! = nil { ga . server Error ( w , " " , err ) return } http . Set Cookie ( w , & http . Cookie { Name : login Session , Value : * user . Login , Path : " " , Expires : time . Now ( ) . Add ( time . Hour * 2 4 * 3 0 ) , Secure : true , } ) http . Redirect ( w , r , ga . gc . Final Redirect URL , http . Status Found ) } } 
func ( ga * Agent ) server Error ( w http . Response Writer , action string , err error ) { ga . logger . With Error ( err ) . Errorf ( " " , action ) msg : = fmt . Sprintf ( " " , action , err ) http . Error ( w , msg , http . Status Internal Server Error ) } 
func ( in * Resources Config Object ) Deep Copy Object ( ) runtime . Object { if c : = in . deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * Resources Config Object ) From Item ( i common . Item ) { c , err : = common . Item To Resources Config ( i ) if err = = nil { in . from Config ( c ) } } 
func ( in * Resources Config Collection ) Get Items ( ) [ ] Object { var items [ ] Object for _ , i : = range in . Items { items = append ( items , i ) } return items } 
func ( in * Resources Config Collection ) Set Items ( objects [ ] Object ) { var items [ ] * Resources Config Object for _ , b : = range objects { items = append ( items , b . ( * Resources Config Object ) ) } in . Items = items } 
func ( in * Resources Config Collection ) Deep Copy Object ( ) runtime . Object { if c : = in . deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( s * Server ) Serve HTTP ( w http . Response Writer , r * http . Request ) { if ! ok { return } fmt . Fprint ( w , " " ) if err : = s . handle Event ( event Type , event GUID , payload ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } 
func ( l * Repo Permission Level ) Unmarshal Text ( text [ ] byte ) error { v : = Repo Permission Level ( text ) if _ , ok : = repo Permission Levels [ v ] ; ! ok { return fmt . Errorf ( " " , v , repo Permission Levels ) } * l = v return nil } 
func ( i Issue ) Is Assignee ( login string ) bool { for _ , assignee : = range i . Assignees { if Norm Login ( login ) = = Norm Login ( assignee . Login ) { return true } } return false } 
func ( i Issue ) Is Author ( login string ) bool { return Norm Login ( i . User . Login ) = = Norm Login ( login ) } 
func ( i Issue ) Has Label ( label To Find string ) bool { for _ , label : = range i . Labels { if strings . To Lower ( label . Name ) = = strings . To Lower ( label To Find ) { return true } } return false } 
func ( pe Push Event ) Branch ( ) string { ref : = strings . Trim Prefix ( pe . Ref , " " ) ref = strings . Trim Prefix ( ref , " " ) return ref } 
func prowjob State To Git Hub Status ( pj State prowapi . Prow Job State ) ( string , error ) { switch pj State { case prowapi . Triggered State : return github . Status Pending , nil case prowapi . Pending State : return github . Status Pending , nil case prowapi . Success State : return github . Status Success , nil case prowapi . Error State : return github . Status Error , nil case prowapi . Failure State : return github . Status Failure , nil case prowapi . Aborted State : return github . Status Failure , nil } return " " , fmt . Errorf ( " " , pj State ) } 
func truncate ( in string ) string { const ( half = ( max Len - len ( elide ) ) / 2 ) if len ( in ) < = max Len { return in } return in [ : half ] + elide + in [ len ( in ) - half : ] } 
func report Status ( ghc Git Hub Client , pj prowapi . Prow Job ) error { refs : = pj . Spec . Refs if pj . Spec . Report { context State , err : = prowjob State To Git Hub Status ( pj . Status . State ) if err ! = nil { return err } sha : = refs . Base SHA if len ( refs . Pulls ) > 0 { sha = refs . Pulls [ 0 ] . SHA } if err : = ghc . Create Status ( refs . Org , refs . Repo , sha , github . Status { State : context State , Description : truncate ( pj . Status . Description ) , Context : pj . Spec . Context , } } return nil } 
func Should Report ( pj prowapi . Prow Job , valid Types [ ] prowapi . Prow Job Type ) bool { valid : = false for _ , t : = range valid Types { if pj . Spec . Type = = t { valid = true } } if ! valid { return false } if ! pj . Spec . Report { return false } return true } 
func Report ( ghc Git Hub Client , report Template * template . Template , pj prowapi . Prow Job , valid Types [ ] prowapi . Prow Job Type ) error { if ghc = = nil { return fmt . Errorf ( " " , pj . Object Meta . Name ) } if ! Should Report ( pj , valid Types ) { return nil } refs : = pj . Spec . Refs } if err : = report Status ( ghc , pj ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } if len ( refs . Pulls ) = = 0 { return nil } ics , err : = ghc . List Issue Comments ( refs . Org , refs . Repo , refs . Pulls [ 0 ] . Number ) if err ! = nil { return fmt . Errorf ( " " , err ) } bot Name , err : = ghc . Bot Name ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } deletes , entries , update ID : = parse Issue Comments ( pj , bot Name , ics ) for _ , delete : = range deletes { if err : = ghc . Delete Comment ( refs . Org , refs . Repo , delete ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } if len ( entries ) > 0 { comment , err : = create Comment ( report Template , pj , entries ) if err ! = nil { return fmt . Errorf ( " " , err ) } if update ID = = 0 { if err : = ghc . Create Comment ( refs . Org , refs . Repo , refs . Pulls [ 0 ] . Number , comment ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } else { if err : = ghc . Edit Comment ( refs . Org , refs . Repo , update ID , comment ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } } return nil } 
func parse Issue Comments ( pj prowapi . Prow Job , bot Name string , ics [ ] github . Issue Comment ) ( [ ] int , [ ] string , int ) { var delete [ ] int var previous Comments [ ] int var latest Comment int var entries [ ] string } } if ! strings . Contains ( ic . Body , comment Tag ) { continue } if latest Comment ! = 0 { previous Comments = append ( previous Comments , latest Comment ) } latest Comment = ic . ID var tracking bool for _ , line : = range strings . Split ( ic . Body , " \n " ) { line = strings . Trim Space ( line ) if strings . Has Prefix ( line , " " ) { tracking = true } else if len ( line ) = = 0 { tracking = false } else if tracking { entries = append ( entries , line ) } } } var new Entries [ ] string f 1 : = strings . Split ( entries [ i ] , " " ) for j : = range entries { if i = = j { continue } f 2 : = strings . Split ( entries [ j ] , " " ) } } } if keep { new Entries = append ( new Entries , entries [ i ] ) } } var create New Comment bool if string ( pj . Status . State ) = = github . Status Failure { new Entries = append ( new Entries , create Entry ( pj ) ) create New Comment = true } delete = append ( delete , previous Comments . . . ) if ( create New Comment | | len ( new Entries ) = = 0 ) & & latest Comment ! = 0 { delete = append ( delete , latest Comment ) latest Comment = 0 } return delete , new Entries , latest Comment } 
func create Comment ( report Template * template . Template , pj prowapi . Prow Job , entries [ ] string ) ( string , error ) { plural : = " " if len ( entries ) > 1 { plural = " " } var b bytes . Buffer if report Template ! = nil { if err : = report Template . Execute ( & b , & pj ) ; err ! = nil { return " " , err } } lines : = [ ] string { fmt . Sprintf ( " " , pj . Spec . Refs . Pulls [ 0 ] . Author , plural ) , " " , " " , " " , } lines = append ( lines , entries . . . ) if report Template ! = nil { lines = append ( lines , " " , b . String ( ) ) } lines = append ( lines , [ ] string { " " , " " , " " , plugins . About This Bot , " " , comment Tag , } . . . ) return strings . Join ( lines , " \n " ) , nil } 
func default Looking DHCPOptions ( dhcp * ec 2 . Dhcp Options , region string ) bool { if len ( dhcp . Tags ) ! = 0 { return false } for _ , conf : = range dhcp . Dhcp Configurations { switch * conf . Key { case " " : var domain string } else { domain = region + " " } } case " " : } default : return false } } return true } 
func generic Comment Action ( action string ) github . Generic Comment Event Action { switch action { case " " , " " , " " : return github . Generic Comment Action Created case " " : return github . Generic Comment Action Edited case " " , " " : return github . Generic Comment Action Deleted } } 
func ( lens Lens ) Config ( ) lenses . Lens Config { return lenses . Lens Config { Name : name , Title : title , Priority : priority , } } 
func ( lens Lens ) Header ( artifacts [ ] lenses . Artifact , resource Dir string ) string { t , err : = template . Parse Files ( filepath . Join ( resource Dir , " " ) ) if err ! = nil { return fmt . Sprintf ( " " , err ) } var buf bytes . Buffer if err : = t . Execute Template ( & buf , " " , nil ) ; err ! = nil { return fmt . Sprintf ( " " , err ) } return buf . String ( ) } 
func ( lens Lens ) Callback ( artifacts [ ] lenses . Artifact , resource Dir string , data string ) string { return " " } 
func ( lens Lens ) Body ( artifacts [ ] lenses . Artifact , resource Dir string , data string ) string { type test Results struct { junit [ ] junit . Result link string path string err error } result Chan : = make ( chan test Results ) for _ , artifact : = range artifacts { go func ( artifact lenses . Artifact ) { result : = test Results { link : artifact . Canonical Link ( ) , path : artifact . Job Path ( ) , } var contents [ ] byte contents , result . err = artifact . Read All ( ) if result . err ! = nil { logrus . With Error ( result . err ) . With Field ( " " , artifact . Canonical Link ( ) ) . Warn ( " " ) result Chan < - result return } var suites junit . Suites suites , result . err = junit . Parse ( contents ) if result . err ! = nil { logrus . With Error ( result . err ) . With Field ( " " , artifact . Canonical Link ( ) ) . Info ( " " ) result Chan < - result return } for _ , suite : = range suites . Suites { for _ , test : = range suite . Results { result . junit = append ( result . junit , test ) } } result Chan < - result } ( artifact ) } results : = make ( [ ] test Results , 0 , len ( artifacts ) ) for range artifacts { results = append ( results , < - result Chan ) } sort . Slice ( results , func ( i , j int ) bool { return results [ i ] . path < results [ j ] . path } ) jvd : = struct { Num Tests int Passed [ ] Test Result Failed [ ] Test Result Skipped [ ] Test Result } { } for _ , result : = range results { if result . err ! = nil { continue } for _ , test : = range result . junit { if test . Failure ! = nil { jvd . Failed = append ( jvd . Failed , Test Result { Junit : Junit Result { test } , Link : result . link , } ) } else if test . Skipped ! = nil { jvd . Skipped = append ( jvd . Skipped , Test Result { Junit : Junit Result { test } , Link : result . link , } ) } else { jvd . Passed = append ( jvd . Passed , Test Result { Junit : Junit Result { test } , Link : result . link , } ) } } } jvd . Num Tests = len ( jvd . Passed ) + len ( jvd . Failed ) + len ( jvd . Skipped ) junit Template , err : = template . Parse Files ( filepath . Join ( resource Dir , " " ) ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return fmt . Sprintf ( " " , err ) } var buf bytes . Buffer if err : = junit Template . Execute Template ( & buf , " " , jvd ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } return buf . String ( ) } 
func Format Record ( record Record ) string { output : = bytes . Buffer { } if record . Failed { fmt . Fprintln ( & output , " " ) } fmt . Fprintf ( & output , " " , record . Refs . Org , record . Refs . Repo , record . Refs . Base Ref ) if record . Refs . Base SHA ! = " " { fmt . Fprintf ( & output , " " , record . Refs . Base SHA ) } output . Write String ( " \n " ) if len ( record . Refs . Pulls ) > 0 { output . Write String ( " \n " ) for _ , pull : = range record . Refs . Pulls { fmt . Fprintf ( & output , " \t " , pull . Number ) if pull . SHA ! = " " { fmt . Fprintf ( & output , " " , pull . SHA ) } fmt . Fprint ( & output , " \n " ) } } for _ , command : = range record . Commands { fmt . Fprintf ( & output , " \n " , command . Command ) fmt . Fprint ( & output , command . Output ) if command . Error ! = " " { fmt . Fprintf ( & output , " \n " , command . Error ) } } return output . String ( ) } 
func ( c * Client ) Namespace ( ns string ) * Client { nc : = * c nc . namespace = ns return & nc } 
func ( c * Client ) request Retry Stream ( r * request ) ( io . Read Closer , error ) { if c . fake & & r . deck Path = = " " { return nil , nil } resp , err : = c . retry ( r ) if err ! = nil { return nil , err } if resp . Status Code = = 4 0 9 { return nil , New Conflict Error ( fmt . Errorf ( " " ) ) } else if resp . Status Code < 2 0 0 | | resp . Status Code > 2 9 9 { return nil , fmt . Errorf ( " \ " \ " " , resp . Status ) } return resp . Body , nil } 
func ( c * Client ) request Retry ( r * request ) ( [ ] byte , error ) { if c . fake & & r . deck Path = = " " { return [ ] byte ( " " ) , nil } resp , err : = c . retry ( r ) if err ! = nil { return nil , err } defer resp . Body . Close ( ) rb , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return nil , err } if resp . Status Code = = 4 0 4 { return nil , New Not Found Error ( fmt . Errorf ( " " , string ( rb ) ) ) } else if resp . Status Code = = 4 0 9 { return nil , New Conflict Error ( fmt . Errorf ( " " , string ( rb ) ) ) } else if resp . Status Code = = 4 2 2 { return nil , New Unprocessable Entity Error ( fmt . Errorf ( " " , string ( rb ) ) ) } else if resp . Status Code = = 4 0 4 { return nil , New Not Found Error ( fmt . Errorf ( " " , string ( rb ) ) ) } else if resp . Status Code < 2 0 0 | | resp . Status Code > 2 9 9 { return nil , fmt . Errorf ( " \ " \ " \ " \ " " , resp . Status , string ( rb ) ) } return rb , nil } 
func New Fake Client ( deck URL string ) * Client { return & Client { namespace : " " , deck URL : deck URL , client : & http . Client { } , fake : true , } } 
func New Client In Cluster ( namespace string ) ( * Client , error ) { token File : = " " token , err : = ioutil . Read File ( token File ) if err ! = nil { return nil , err } root CAFile : = " " cert Data , err : = ioutil . Read File ( root CAFile ) if err ! = nil { return nil , err } cp : = x 5 0 9 . New Cert Pool ( ) cp . Append Certs From PEM ( cert Data ) tr : = & http . Transport { TLSClient Config : & tls . Config { Min Version : tls . Version TLS 1 2 , Root CAs : cp , } , } return & Client { logger : logrus . With Field ( " " , " " ) , base URL : in Cluster Base URL , client : & http . Client { Transport : tr , Timeout : request Timeout } , token : string ( token ) , namespace : namespace , } , nil } 
func New Client From File ( cluster Path , namespace string ) ( * Client , error ) { data , err : = ioutil . Read File ( cluster Path ) if err ! = nil { return nil , err } var c Cluster if err : = yaml . Unmarshal ( data , & c ) ; err ! = nil { return nil , err } return New Client ( & c , namespace ) } 
func Unmarshal Cluster Map ( data [ ] byte ) ( map [ string ] Cluster , error ) { var raw map [ string ] Cluster if err : = yaml . Unmarshal ( data , & raw ) ; err ! = nil { if err : = yaml . Unmarshal ( data , & single Config ) ; err ! = nil { return nil , err } raw = map [ string ] Cluster { Default Cluster Alias : single Config } } return raw , nil } 
func Client Map From File ( clusters Path , namespace string ) ( map [ string ] * Client , error ) { data , err : = ioutil . Read File ( clusters Path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } raw , err : = Unmarshal Cluster Map ( data ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } found Default : = false result : = map [ string ] * Client { } for alias , config : = range raw { client , err : = new Client ( & config , namespace ) if err ! = nil { return nil , fmt . Errorf ( " " , alias , clusters Path , err ) } result [ alias ] = client if alias = = Default Cluster Alias { found Default = true } } if ! found Default { return nil , fmt . Errorf ( " " , Default Cluster Alias , clusters Path ) } return result , nil } 
func New Client ( c * Cluster , namespace string ) ( * Client , error ) { ck : = c . Client Key ca : = c . Cluster CACertificate cert , err : = tls . X 5 0 9Key Pair ( cc , ck ) if err ! = nil { return nil , err } cp : = x 5 0 9 . New Cert Pool ( ) cp . Append Certs From PEM ( ca ) tr : = & http . Transport { TLSClient Config : & tls . Config { Min Version : tls . Version TLS 1 2 , Certificates : [ ] tls . Certificate { cert } , Root CAs : cp , } , } return & Client { logger : logrus . With Field ( " " , " " ) , base URL : c . Endpoint , client : & http . Client { Transport : tr , Timeout : request Timeout } , namespace : namespace , } , nil } 
func ( c * Client ) Get Pod ( name string ) ( Pod , error ) { c . log ( " " , name ) var ret Pod Pod err : = c . request ( & request { path : fmt . Sprintf ( " " , c . namespace , name ) , } , & ret Pod ) return ret Pod , err } 
func ( c * Client ) List Pods ( selector string ) ( [ ] Pod , error ) { c . log ( " " , selector ) var pl struct { Items [ ] Pod `json : "items " ` } err : = c . request ( & request { path : fmt . Sprintf ( " " , c . namespace ) , query : map [ string ] string { " " : selector } , } , & pl ) return pl . Items , err } 
func ( c * Client ) Create Prow Job ( j prowapi . Prow Job ) ( prowapi . Prow Job , error ) { var representation string if out , err : = json . Marshal ( j ) ; err = = nil { representation = string ( out [ : ] ) } else { representation = fmt . Sprintf ( " " , j ) } c . log ( " " , representation ) var ret Job prowapi . Prow Job err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , c . namespace ) , request Body : & j , } , & ret Job ) return ret Job , err } 
func ( c * Client ) Get Prow Job ( name string ) ( prowapi . Prow Job , error ) { c . log ( " " , name ) var pj prowapi . Prow Job err : = c . request ( & request { path : fmt . Sprintf ( " " , c . namespace , name ) , } , & pj ) return pj , err } 
func ( c * Client ) List Prow Jobs ( selector string ) ( [ ] prowapi . Prow Job , error ) { c . log ( " " , selector ) var jl struct { Items [ ] prowapi . Prow Job `json : "items " ` } err : = c . request ( & request { path : fmt . Sprintf ( " " , c . namespace ) , deck Path : " " , query : map [ string ] string { " " : selector } , } , & jl ) if err = = nil { var pjs [ ] prowapi . Prow Job for _ , pj : = range jl . Items { pjs = append ( pjs , pj ) } jl . Items = pjs } return jl . Items , err } 
func ( c * Client ) Delete Prow Job ( name string ) error { c . log ( " " , name ) return c . request ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , c . namespace , name ) , } , nil ) } 
func ( c * Client ) Replace Prow Job ( name string , job prowapi . Prow Job ) ( prowapi . Prow Job , error ) { c . log ( " " , name , job ) var ret Job prowapi . Prow Job err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , c . namespace , name ) , request Body : & job , } , & ret Job ) return ret Job , err } 
func ( c * Client ) Create Pod ( p v 1 . Pod ) ( Pod , error ) { c . log ( " " , p ) var ret Pod Pod err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , c . namespace ) , request Body : & p , } , & ret Pod ) return ret Pod , err } 
func ( c * Client ) Get Log ( pod string ) ( [ ] byte , error ) { c . log ( " " , pod ) return c . request Retry ( & request { path : fmt . Sprintf ( " " , c . namespace , pod ) , } ) } 
func ( c * Client ) Get Log Tail ( pod , container string , n int 6 4 ) ( [ ] byte , error ) { c . log ( " " , pod , n ) return c . request Retry ( & request { path : fmt . Sprintf ( " " , c . namespace , pod ) , query : map [ string ] string { } 
func ( c * Client ) Get Container Log ( pod , container string ) ( [ ] byte , error ) { c . log ( " " , pod ) return c . request Retry ( & request { path : fmt . Sprintf ( " " , c . namespace , pod ) , query : map [ string ] string { " " : container } , } ) } 
func ( c * Client ) Create Config Map ( content Config Map ) ( Config Map , error ) { c . log ( " " ) var ret Config Map Config Map err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , c . namespace ) , request Body : & content , } , & ret Config Map ) return ret Config Map , err } 
func ( c * Client ) Get Config Map ( name , namespace string ) ( Config Map , error ) { c . log ( " " , name ) if namespace = = " " { namespace = c . namespace } var ret Config Map Config Map err : = c . request ( & request { path : fmt . Sprintf ( " " , namespace , name ) , } , & ret Config Map ) return ret Config Map , err } 
func ( c * Client ) Replace Config Map ( name string , config Config Map ) ( Config Map , error ) { c . log ( " " , name ) namespace : = c . namespace if config . Namespace ! = " " { namespace = config . Namespace } var ret Config Map Config Map err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , namespace , name ) , request Body : & config , } , & ret Config Map ) return ret Config Map , err } 
func Get Disk Usage ( path string ) ( percent Blocks Free float 6 4 , bytes Free , bytes Used uint 6 4 , err error ) { var stat syscall . Statfs _t err = syscall . Statfs ( path , & stat ) if err ! = nil { return 0 , 0 , 0 , err } percent Blocks Free = float 6 4 ( stat . Bfree ) / float 6 4 ( stat . Blocks ) * 1 0 0 bytes Free = stat . Bfree * uint 6 4 ( stat . Bsize ) bytes Used = ( stat . Blocks - stat . Bfree ) * uint 6 4 ( stat . Bsize ) return percent Blocks Free , bytes Free , bytes Used , nil } 
func Get ATime ( path string , default Time time . Time ) time . Time { at , err : = atime . Stat ( path ) if err ! = nil { log . With Error ( err ) . Errorf ( " " , path ) return default Time } return at } 
func Register Lens ( lens Lens ) error { config : = lens . Config ( ) _ , ok : = lens Reg [ config . Name ] if ok { return fmt . Errorf ( " " , config . Name ) } if config . Title = = " " { return errors . New ( " " ) } if config . Priority < 0 { return errors . New ( " " ) } lens Reg [ config . Name ] = lens logrus . Infof ( " " , config . Name , config . Title ) return nil } 
func Get Lens ( name string ) ( Lens , error ) { lens , ok : = lens Reg [ name ] if ! ok { return nil , Err Invalid Lens Name } return lens , nil } 
func Last NLines ( a Artifact , n int 6 4 ) ( [ ] string , error ) { } 
func Last NLines Chunked ( a Artifact , n , chunk Size int 6 4 ) ( [ ] string , error ) { to Read : = chunk Size + 1 chunks : = int 6 4 ( 1 ) var contents [ ] byte var lines In Contents int 6 4 artifact Size , err : = a . Size ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } offset : = artifact Size - chunks * chunk Size last Offset : = offset var last Read int 6 4 for lines In Contents < n & & offset ! = 0 { offset = last Offset - last Read if offset < 0 { to Read = offset + chunk Size + 1 offset = 0 } bytes Read : = make ( [ ] byte , to Read ) num Bytes Read , err : = a . Read At ( bytes Read , offset ) if err ! = nil & & err ! = io . EOF { return nil , fmt . Errorf ( " " , err ) } last Read = int 6 4 ( num Bytes Read ) last Offset = offset bytes Read = bytes . Trim ( bytes Read , " \x 0 0 " ) lines In Contents + = int 6 4 ( bytes . Count ( bytes Read , [ ] byte ( " \n " ) ) ) contents = append ( bytes Read , contents . . . ) chunks + + } var lines [ ] string scanner : = bufio . New Scanner ( bytes . New Reader ( contents ) ) scanner . Split ( bufio . Scan Lines ) for scanner . Scan ( ) { line : = scanner . Text ( ) lines = append ( lines , line ) } l : = int 6 4 ( len ( lines ) ) if l < n { return lines , nil } return lines [ l - n : ] , nil } 
func New Client ( token Generator func ( ) [ ] byte ) * Client { return & Client { logger : logrus . With Field ( " " , " " ) , token Generator : token Generator , } } 
func ( sl * Client ) Write Message ( text , channel string ) error { sl . log ( " " , text , channel ) if sl . fake { return nil } var uv = sl . url Values ( ) uv . Add ( " " , channel ) uv . Add ( " " , text ) _ , err : = sl . post Message ( chat Post Message , uv ) return err } 
func ( NATGateway ) Mark And Sweep ( sess * session . Session , acct string , region string , set * Set ) error { svc : = ec 2 . New ( sess , & aws . Config { Region : aws . String ( region ) } ) inp : = & ec 2 . Describe Nat Gateways Input { } if err : = svc . Describe Nat Gateways Pages ( inp , func ( page * ec 2 . Describe Nat Gateways Output , _ bool ) bool { for _ , gw : = range page . Nat Gateways { g : = & nat Gateway { Account : acct , Region : region , ID : * gw . Nat Gateway Id , } if set . Mark ( g ) { inp : = & ec 2 . Delete Nat Gateway Input { Nat Gateway Id : gw . Nat Gateway Id } if _ , err : = svc . Delete Nat Gateway ( inp ) ; err ! = nil { klog . Warningf ( " " , g . ARN ( ) , err ) } } } return true } ) ; err ! = nil { return err } return nil } 
func ( NATGateway ) List All ( sess * session . Session , acct , region string ) ( * Set , error ) { svc : = ec 2 . New ( sess , & aws . Config { Region : aws . String ( region ) } ) set : = New Set ( 0 ) inp : = & ec 2 . Describe Nat Gateways Input { } err : = svc . Describe Nat Gateways Pages ( inp , func ( page * ec 2 . Describe Nat Gateways Output , _ bool ) bool { for _ , gw : = range page . Nat Gateways { now : = time . Now ( ) arn : = nat Gateway { Account : acct , Region : region , ID : * gw . Nat Gateway Id , } . ARN ( ) set . first Seen [ arn ] = now } return true } ) return set , errors . Wrapf ( err , " " , acct , region ) } 
func ( c * Prow V 1Client ) RESTClient ( ) rest . Interface { if c = = nil { return nil } return c . rest Client } 
func New Client ( owner string , url string ) * Client { client : = & Client { url : url , owner : owner , storage : storage . New Memory Storage ( ) , } client . Dialer . Retry Sleep = time . Second * 1 0 client . Dialer . Keep Alive = 3 0 * time . Second client . Dialer . Dual Stack = true client . http . Transport = & http . Transport { Proxy : http . Proxy From Environment , Dial : client . Dialer . Dial , Dial Context : client . Dialer . Dial Context , Max Idle Conns : 1 0 0 , Idle Conn Timeout : 9 0 * time . Second , TLSHandshake Timeout : 1 0 * time . Second , Expect Continue Timeout : 1 * time . Second , } return client } 
func ( c * Client ) Acquire ( rtype , state , dest string ) ( * common . Resource , error ) { r , err : = c . acquire ( rtype , state , dest ) if err ! = nil { return nil , err } c . lock . Lock ( ) defer c . lock . Unlock ( ) if r ! = nil { c . storage . Add ( * r ) } return r , nil } 
func ( c * Client ) Acquire Wait ( ctx context . Context , rtype , state , dest string ) ( * common . Resource , error ) { if ctx = = nil { return nil , Err Context Required } if err ! = nil { if err = = Err Already In Use | | err = = Err Not Found { select { case < - ctx . Done ( ) : return nil , err case < - time . After ( 3 * time . Second ) : continue } } return nil , err } return r , nil } } 
func ( c * Client ) Acquire By State ( state , dest string , names [ ] string ) ( [ ] common . Resource , error ) { resources , err : = c . acquire By State ( state , dest , names ) if err ! = nil { return nil , err } c . lock . Lock ( ) defer c . lock . Unlock ( ) for _ , r : = range resources { c . storage . Add ( r ) } return resources , nil } 
func ( c * Client ) Acquire By State Wait ( ctx context . Context , state , dest string , names [ ] string ) ( [ ] common . Resource , error ) { if ctx = = nil { return nil , Err Context Required } if err ! = nil { if err = = Err Already In Use | | err = = Err Not Found { select { case < - ctx . Done ( ) : return nil , err case < - time . After ( 3 * time . Second ) : continue } } return nil , err } return r , nil } } 
func ( c * Client ) Release All ( dest string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err : = c . storage . List ( ) if err ! = nil { return err } if len ( resources ) = = 0 { return fmt . Errorf ( " " ) } var all Errors error for _ , r : = range resources { c . storage . Delete ( r . Get Name ( ) ) err : = c . release ( r . Get Name ( ) , dest ) if err ! = nil { all Errors = multierror . Append ( all Errors , err ) } } return all Errors } 
func ( c * Client ) Release One ( name , dest string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) if _ , err : = c . storage . Get ( name ) ; err ! = nil { return fmt . Errorf ( " " , name ) } c . storage . Delete ( name ) if err : = c . release ( name , dest ) ; err ! = nil { return err } return nil } 
func ( c * Client ) Update All ( state string ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err : = c . storage . List ( ) if err ! = nil { return err } if len ( resources ) = = 0 { return fmt . Errorf ( " " ) } var all Errors error for _ , r : = range resources { if err : = c . update ( r . Get Name ( ) , state , nil ) ; err ! = nil { all Errors = multierror . Append ( all Errors , err ) continue } if err : = c . update Local Resource ( r , state , nil ) ; err ! = nil { all Errors = multierror . Append ( all Errors , err ) } } return all Errors } 
func ( c * Client ) Sync All ( ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) resources , err : = c . storage . List ( ) if err ! = nil { return err } if len ( resources ) = = 0 { logrus . Info ( " " ) return nil } var all Errors error for _ , i : = range resources { r , err : = common . Item To Resource ( i ) if err ! = nil { all Errors = multierror . Append ( all Errors , err ) continue } if err : = c . update ( r . Name , r . State , nil ) ; err ! = nil { all Errors = multierror . Append ( all Errors , err ) continue } if err : = c . storage . Update ( r ) ; err ! = nil { all Errors = multierror . Append ( all Errors , err ) } } return all Errors } 
func ( c * Client ) Update One ( name , state string , user Data * common . User Data ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) r , err : = c . storage . Get ( name ) if err ! = nil { return fmt . Errorf ( " " , name ) } if err : = c . update ( r . Get Name ( ) , state , user Data ) ; err ! = nil { return err } return c . update Local Resource ( r , state , user Data ) } 
func ( c * Client ) Reset ( rtype , state string , expire time . Duration , dest string ) ( map [ string ] string , error ) { return c . reset ( rtype , state , expire , dest ) } 
func ( c * Client ) Metric ( rtype string ) ( common . Metric , error ) { return c . metric ( rtype ) } 
func ( c * Client ) Has Resource ( ) bool { resources , _ : = c . storage . List ( ) return len ( resources ) > 0 } 
func ( c * Client ) update Local Resource ( i common . Item , state string , data * common . User Data ) error { res , err : = common . Item To Resource ( i ) if err ! = nil { return err } res . State = state if res . User Data = = nil { res . User Data = data } else { res . User Data . Update ( data ) } return c . storage . Update ( res ) } 
func ( d * Dialer With Retry ) Dial Context ( ctx context . Context , network , address string ) ( net . Conn , error ) { sleep : = d . Retry Sleep i : = uint ( 0 ) for { conn , err : = d . Dialer . Dial Context ( ctx , network , address ) if err ! = nil { if is Dial Error Retriable ( err ) { if i < count - 1 { select { case < - time . After ( sleep ) : i + + continue case < - ctx . Done ( ) : return nil , err } } } return nil , err } return conn , nil } } 
func is Dial Error Retriable ( err error ) bool { op Err , is Op Err : = err . ( * net . Op Error ) if ! is Op Err { return false } if op Err . Timeout ( ) | | op Err . Temporary ( ) { return true } sys Err , is Sys Err : = op Err . Err . ( * os . Syscall Error ) if ! is Sys Err { return false } switch sys Err . Err { case syscall . ECONNREFUSED , syscall . ECONNRESET : return true } return false } 
func New Dashboard Agent ( repos [ ] string , config * config . Git Hub OAuth Config , log * logrus . Entry ) * Dashboard Agent { return & Dashboard Agent { repos : repos , goac : config , log : log , } } 
func ( da * Dashboard Agent ) Handle Pr Status ( query Handler Pull Request Query Handler ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { server Error : = func ( action string , err error ) { da . log . With Error ( err ) . Errorf ( " " , action ) msg : = fmt . Sprintf ( " " , action , err ) http . Error ( w , msg , http . Status Internal Server Error ) } data : = User Data { Login : false , } if err ! = nil { da . log . With Error ( err ) . Info ( " " ) if err : = invalidate Git Hub Session ( w , r , session ) ; err ! = nil { server Error ( " " , err ) return } } var user * github . User var bot Name string if ok & & token . Valid ( ) { github Client : = github . New Client ( func ( ) [ ] byte { return [ ] byte ( token . Access Token ) } , github . Default Graph QLEndpoint , github . Default APIEndpoint ) var err error bot Name , err = github Client . Bot Name ( ) user = & github . User { Login : bot Name } if err ! = nil { if strings . Contains ( err . Error ( ) , " " ) { da . log . Info ( " " ) if err : = invalidate Git Hub Session ( w , r , session ) ; err ! = nil { server Error ( " " , err ) return } } else { server Error ( " " , err ) return } } } if user ! = nil { login : = user . Login data . Login = true session . Values [ login Key ] = login if err : = session . Save ( r , w ) ; err ! = nil { server Error ( " " , err ) return } query : = da . Construct Search Query ( login ) if err : = r . Parse Form ( ) ; err = = nil { if q : = r . Form . Get ( " " ) ; q ! = " " { query = q } } } } pull Requests , err : = query Handler . Query Pull Requests ( context . Background ( ) , ghc , query ) if err ! = nil { server Error ( " " , err ) return } var pull Request With Contexts [ ] Pull Request With Contexts for _ , pr : = range pull Requests { prcontexts , err : = query Handler . Get Head Contexts ( ghc , pr ) if err ! = nil { server Error ( " " , err ) continue } pull Request With Contexts = append ( pull Request With Contexts , Pull Request With Contexts { Contexts : prcontexts , Pull Request : pr , } ) } data . Pull Requests With Contexts = pull Request With Contexts } marshaled Data , err : = json . Marshal ( data ) if err ! = nil { da . log . With Error ( err ) . Error ( " " ) } if v : = r . URL . Query ( ) . Get ( " " ) ; v ! = " " { fmt . Fprintf ( w , " " , v ) w . Write ( marshaled Data ) io . Write String ( w , " " ) } else { w . Write ( marshaled Data ) } } } 
func ( da * Dashboard Agent ) Query Pull Requests ( ctx context . Context , ghc github Client , query string ) ( [ ] Pull Request , error ) { var prs [ ] Pull Request vars : = map [ string ] interface { } { " " : ( githubql . String ) ( query ) , " " : ( * githubql . String ) ( nil ) , } var total Cost int var remaining int for { sq : = search Query { } if err : = ghc . Query ( ctx , & sq , vars ) ; err ! = nil { return nil , err } total Cost + = int ( sq . Rate Limit . Cost ) remaining = int ( sq . Rate Limit . Remaining ) for _ , n : = range sq . Search . Nodes { prs = append ( prs , n . Pull Request ) } if ! sq . Search . Page Info . Has Next Page { break } vars [ " " ] = githubql . New String ( sq . Search . Page Info . End Cursor ) } da . log . Infof ( " \ " \ " " , query , total Cost , remaining ) return prs , nil } 
func ( da * Dashboard Agent ) Get Head Contexts ( ghc github Client , pr Pull Request ) ( [ ] Context , error ) { org : = string ( pr . Repository . Owner . Login ) repo : = string ( pr . Repository . Name ) combined , err : = ghc . Get Combined Status ( org , repo , string ( pr . Head Ref OID ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } contexts : = make ( [ ] Context , 0 , len ( combined . Statuses ) ) for _ , status : = range combined . Statuses { contexts = append ( contexts , Context { Context : status . Context , Description : status . Description , State : strings . To Upper ( status . State ) , } , ) } return contexts , nil } 
func ( da * Dashboard Agent ) Construct Search Query ( login string ) string { tokens : = [ ] string { " " , " " , " " + login } for i : = range da . repos { tokens = append ( tokens , fmt . Sprintf ( " \ " \ " " , da . repos [ i ] ) ) } return strings . Join ( tokens , " " ) } 
func Load Cluster Configs ( kubeconfig , build Cluster string ) ( map [ string ] rest . Config , error ) { logrus . Infof ( " " ) if err ! = nil { logrus . With Error ( err ) . Warn ( " " ) } kube Cfgs , current Context , err : = kube Configs ( kubeconfig ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return merge Configs ( local Cfg , kube Cfgs , current Context , build Cfgs ) } 
func parse Links ( h string ) map [ string ] string { links : = map [ string ] string { } for _ , m : = range lre . Find All String Submatch ( h , 1 0 ) { if len ( m ) ! = 3 { continue } links [ m [ 2 ] ] = m [ 1 ] } return links } 
func New Bundled States ( description string ) Bundled States { return Bundled States { description : description , states : map [ string ] State { } , } } 
func ( b Bundled States ) Receive Event ( ID string , event Name , label string , t time . Time ) bool { state , ok : = b . states [ ID ] if ! ok { state = New State ( b . description ) } state , changed : = state . Receive Event ( event Name , label , t ) b . states [ ID ] = state return changed } 
func ( b Bundled States ) ages ( t time . Time ) map [ string ] time . Duration { ages : = map [ string ] time . Duration { } for id , state : = range b . states { if ! state . Active ( ) { continue } ages [ id ] = state . Age ( t ) } return ages } 
func ( b Bundled States ) Total ( t time . Time ) ( count int , sum int 6 4 ) { for _ , age : = range b . ages ( t ) { count + + sum + = int 6 4 ( age / time . Minute ) } return } 
func ( b Bundled States ) Percentile ( t time . Time , percentile int ) time . Duration { if percentile > 1 0 0 | | percentile < = 0 { panic ( fmt . Errorf ( " " , percentile ) ) } ages : = [ ] time . Duration { } for _ , age : = range b . ages ( t ) { ages = append ( ages , age ) } if len ( ages ) = = 0 { return 0 } sort . Sort ( By Duration ( ages ) ) index : = int ( math . Ceil ( float 6 4 ( percentile ) * float 6 4 ( len ( ages ) ) / 1 0 0 ) - 1 ) if index > = len ( ages ) { panic ( fmt . Errorf ( " " , index , len ( ages ) ) ) } return ages [ index ] } 
func New Metrics ( ) * Metrics { return & Metrics { Client Metrics : & Client Metrics { Requests : requests , Request Retries : request Retries , Request Latency : request Latency , } , Resync Period : resync Period , } } 
func New Group ( git Attributes Content func ( ) ( [ ] byte , error ) ) ( * Group , error ) { g : = & Group { Linguist Generated Patterns : [ ] Pattern { } , } bs , err : = git Attributes Content ( ) if err ! = nil { switch err . ( type ) { case * github . File Not Found : return g , nil default : return nil , fmt . Errorf ( " " , err ) } } if err : = g . load ( bytes . New Buffer ( bs ) ) ; err ! = nil { return nil , err } return g , nil } 
func ( g * Group ) load ( r io . Reader ) error { s : = bufio . New Scanner ( r ) for s . Scan ( ) { } fs : = strings . Fields ( l ) if len ( fs ) < 2 { continue } if attributes . Has ( " " ) { p , err : = parse Pattern ( fs [ 0 ] ) if err ! = nil { return fmt . Errorf ( " " , err ) } g . Linguist Generated Patterns = append ( g . Linguist Generated Patterns , p ) } } if err : = s . Err ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( g * Group ) Is Linguist Generated ( path string ) bool { for _ , p : = range g . Linguist Generated Patterns { if p . Match ( path ) { return true } } return false } 
func handle ( log * logrus . Entry , ghc github Client , cp comment Pruner , ie * github . Issue Event , mention Re * regexp . Regexp ) error { } org : = ie . Repo . Owner . Login repo : = ie . Repo . Name number : = ie . Issue . Number has Sig Label : = has Sig Label ( ie . Issue . Labels ) has Needs Sig Label : = github . Has Label ( labels . Needs Sig , ie . Issue . Labels ) if has Sig Label & & has Needs Sig Label { if err : = ghc . Remove Label ( org , repo , number , labels . Needs Sig ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , labels . Needs Sig ) } bot Name , err : = ghc . Bot Name ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } cp . Prune Comments ( should Prune ( log , bot Name ) ) } else if ! has Sig Label & & ! has Needs Sig Label { if err : = ghc . Add Label ( org , repo , number , labels . Needs Sig ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , labels . Needs Sig ) } msg : = plugins . Format Response ( ie . Issue . User . Login , needs SIGMessage , needs SIGDetails ) if err : = ghc . Create Comment ( org , repo , number , msg ) ; err ! = nil { log . With Error ( err ) . Error ( " " ) } } return nil } 
func should Prune ( log * logrus . Entry , bot Name string ) func ( github . Issue Comment ) bool { return func ( comment github . Issue Comment ) bool { if comment . User . Login ! = bot Name { return false } return strings . Contains ( comment . Body , needs SIGMessage ) } } 
func New Disk Cache ( delegate http . Round Tripper , cache Dir string , cache Size GB , max Concurrency int ) http . Round Tripper { return New From Cache ( delegate , diskcache . New With Diskv ( diskv . New ( diskv . Options { Base Path : path . Join ( cache Dir , " " ) , Temp Dir : path . Join ( cache Dir , " " ) , Cache Size Max : uint 6 4 ( cache Size GB ) * uint 6 4 ( 1 0 0 0 0 0 0 0 0 0 ) , } 
func New Mem Cache ( delegate http . Round Tripper , max Concurrency int ) http . Round Tripper { return New From Cache ( delegate , httpcache . New Memory Cache ( ) , max Concurrency ) } 
func New From Cache ( delegate http . Round Tripper , cache httpcache . Cache , max Concurrency int ) http . Round Tripper { cache Transport : = httpcache . New Transport ( cache ) cache Transport . Transport = new Throttling Transport ( max Concurrency , upstream Transport { delegate : delegate } ) return & request Coalescer { keys : make ( map [ string ] * response Waiter ) , delegate : cache Transport , } } 
func ( c * Clientset ) Prow V 1 ( ) prowv 1 . Prow V 1Interface { return & fakeprowv 1 . Fake Prow V 1 { Fake : & c . Fake } } 
func ( c * Clientset ) Prow ( ) prowv 1 . Prow V 1Interface { return & fakeprowv 1 . Fake Prow V 1 { Fake : & c . Fake } } 
func New Owners ( log * logrus . Entry , filenames [ ] string , r Repo , s int 6 4 ) Owners { return Owners { filenames : filenames , repo : r , seed : s , log : log } } 
func ( o Owners ) Get Approvers ( ) map [ string ] sets . String { owners To Approvers : = map [ string ] sets . String { } for fn : = range o . Get Owners Set ( ) { owners To Approvers [ fn ] = o . repo . Approvers ( fn ) } return owners To Approvers } 
func ( o Owners ) Get Leaf Approvers ( ) map [ string ] sets . String { owners To Approvers : = map [ string ] sets . String { } for fn : = range o . Get Owners Set ( ) { owners To Approvers [ fn ] = o . repo . Leaf Approvers ( fn ) } return owners To Approvers } 
func ( o Owners ) Get All Potential Approvers ( ) [ ] string { approvers Only : = [ ] string { } for _ , approver List : = range o . Get Leaf Approvers ( ) { for approver : = range approver List { approvers Only = append ( approvers Only , approver ) } } sort . Strings ( approvers Only ) if len ( approvers Only ) = = 0 { o . log . Debug ( " " ) } return approvers Only } 
func ( o Owners ) Get Reverse Map ( approvers map [ string ] sets . String ) map [ string ] sets . String { approver Ownersfiles : = map [ string ] sets . String { } for owners File , approvers : = range approvers { for approver : = range approvers { if _ , ok : = approver Ownersfiles [ approver ] ; ok { approver Ownersfiles [ approver ] . Insert ( owners File ) } else { approver Ownersfiles [ approver ] = sets . New String ( owners File ) } } } return approver Ownersfiles } 
func ( o Owners ) temporary Unapproved Files ( approvers sets . String ) sets . String { ap : = New Approvers ( o ) for approver : = range approvers { ap . Add Approver ( approver , " " , false ) } return ap . Unapproved Files ( ) } 
func ( o Owners ) Keep Covering Approvers ( reverse Map map [ string ] sets . String , known Approvers sets . String , potential Approvers [ ] string ) sets . String { if len ( potential Approvers ) = = 0 { o . log . Debug ( " " ) } kept Approvers : = sets . New String ( ) unapproved : = o . temporary Unapproved Files ( known Approvers ) for _ , suggested Approver : = range o . Get Suggested Approvers ( reverse Map , potential Approvers ) . List ( ) { if reverse Map [ suggested Approver ] . Intersection ( unapproved ) . Len ( ) ! = 0 { kept Approvers . Insert ( suggested Approver ) } } return kept Approvers } 
func ( o Owners ) Get Suggested Approvers ( reverse Map map [ string ] sets . String , potential Approvers [ ] string ) sets . String { ap : = New Approvers ( o ) for ! ap . Requirements Met ( ) { new Approver : = find Most Covering Approver ( potential Approvers , reverse Map , ap . Unapproved Files ( ) ) if new Approver = = " " { o . log . Warnf ( " " , ap . Unapproved Files ( ) . List ( ) ) return ap . Get Current Approvers Set ( ) } ap . Add Approver ( new Approver , " " , false ) } return ap . Get Current Approvers Set ( ) } 
func ( o Owners ) Get Owners Set ( ) sets . String { owners : = sets . New String ( ) for _ , fn : = range o . filenames { owners . Insert ( o . repo . Find Approver Owners For File ( fn ) ) } o . remove Subdirs ( owners ) return owners } 
func ( o Owners ) Get Shuffled Approvers ( ) [ ] string { approvers List : = o . Get All Potential Approvers ( ) order : = rand . New ( rand . New Source ( o . seed ) ) . Perm ( len ( approvers List ) ) people : = make ( [ ] string , 0 , len ( approvers List ) ) for _ , i : = range order { people = append ( people , approvers List [ i ] ) } return people } 
func ( o Owners ) remove Subdirs ( dirs sets . String ) { canonicalize : = func ( p string ) string { if p = = " " { return " " } return p } for _ , dir : = range dirs . List ( ) { path : = dir for { if o . repo . Is No Parent Owners ( path ) | | canonicalize ( path ) = = " " { break } path = filepath . Dir ( path ) if dirs . Has ( canonicalize ( path ) ) { dirs . Delete ( dir ) break } } } } 
func ( a Approval ) String ( ) string { return fmt . Sprintf ( ` * <a href = " %s " title = " %s " > %s < /a > * ` , a . Reference , a . How , a . Login , ) } 
func Intersect Sets Case ( one , other sets . String ) sets . String { lower : = sets . New String ( ) for item : = range other { lower . Insert ( strings . To Lower ( item ) ) } intersection : = sets . New String ( ) for item : = range one { if lower . Has ( strings . To Lower ( item ) ) { intersection . Insert ( item ) } } return intersection } 
func New Approvers ( owners Owners ) Approvers { return Approvers { owners : owners , approvers : map [ string ] Approval { } , assignees : sets . New String ( ) , Manually Approved : func ( ) bool { return false } , } } 
func ( ap * Approvers ) should Not Override Approval ( login string , no Issue bool ) bool { login = strings . To Lower ( login ) approval , already Approved : = ap . approvers [ login ] return already Approved & & approval . No Issue & & ! no Issue } 
func ( ap * Approvers ) Add LGTMer ( login , reference string , no Issue bool ) { if ap . should Not Override Approval ( login , no Issue ) { return } ap . approvers [ strings . To Lower ( login ) ] = Approval { Login : login , How : " " , Reference : reference , No Issue : no Issue , } } 
func ( ap * Approvers ) Remove Approver ( login string ) { delete ( ap . approvers , strings . To Lower ( login ) ) } 
func ( ap * Approvers ) Add Assignees ( logins . . . string ) { for _ , login : = range logins { ap . assignees . Insert ( strings . To Lower ( login ) ) } } 
func ( ap Approvers ) Get Current Approvers Set ( ) sets . String { current Approvers : = sets . New String ( ) for approver : = range ap . approvers { current Approvers . Insert ( approver ) } return current Approvers } 
func ( ap Approvers ) Get Current Approvers Set Cased ( ) sets . String { current Approvers : = sets . New String ( ) for _ , approval : = range ap . approvers { current Approvers . Insert ( approval . Login ) } return current Approvers } 
func ( ap Approvers ) Get No Issue Approvers Set ( ) sets . String { approvers : = sets . New String ( ) for approver : = range ap . No Issue Approvers ( ) { approvers . Insert ( approver ) } return approvers } 
func ( ap Approvers ) Get Files Approvers ( ) map [ string ] sets . String { files Approvers : = map [ string ] sets . String { } current Approvers : = ap . Get Current Approvers Set Cased ( ) for fn , potential Approvers : = range ap . owners . Get Approvers ( ) { } return files Approvers } 
func ( ap Approvers ) No Issue Approvers ( ) map [ string ] Approval { nia : = map [ string ] Approval { } reverse Map : = ap . owners . Get Reverse Map ( ap . owners . Get Approvers ( ) ) for login , approver : = range ap . approvers { if ! approver . No Issue { continue } if len ( reverse Map [ login ] ) = = 0 { continue } nia [ login ] = approver } return nia } 
func ( ap Approvers ) Unapproved Files ( ) sets . String { unapproved : = sets . New String ( ) for fn , approvers : = range ap . Get Files Approvers ( ) { if len ( approvers ) = = 0 { unapproved . Insert ( fn ) } } return unapproved } 
func ( ap Approvers ) Get Files ( base URL * url . URL , branch string ) [ ] File { all Owners Files : = [ ] File { } files Approvers : = ap . Get Files Approvers ( ) for _ , file : = range ap . owners . Get Owners Set ( ) . List ( ) { if len ( files Approvers [ file ] ) = = 0 { all Owners Files = append ( all Owners Files , Unapproved File { base URL : base URL , filepath : file , branch : branch , } ) } else { all Owners Files = append ( all Owners Files , Approved File { base URL : base URL , filepath : file , approvers : files Approvers [ file ] , branch : branch , } ) } } return all Owners Files } 
func ( ap Approvers ) Get CCs ( ) [ ] string { randomized Approvers : = ap . owners . Get Shuffled Approvers ( ) current Approvers : = ap . Get Current Approvers Set ( ) approvers And Assignees : = current Approvers . Union ( ap . assignees ) leaf Reverse Map : = ap . owners . Get Reverse Map ( ap . owners . Get Leaf Approvers ( ) ) suggested : = ap . owners . Keep Covering Approvers ( leaf Reverse Map , approvers And Assignees , randomized Approvers ) approvers And Suggested : = current Approvers . Union ( suggested ) everyone : = approvers And Suggested . Union ( ap . assignees ) full Reverse Map : = ap . owners . Get Reverse Map ( ap . owners . Get Approvers ( ) ) keep Assignees : = ap . owners . Keep Covering Approvers ( full Reverse Map , approvers And Suggested , everyone . List ( ) ) return suggested . Union ( keep Assignees ) . List ( ) } 
func ( ap Approvers ) Requirements Met ( ) bool { return ap . Are Files Approved ( ) & & ( ! ap . Require Issue | | ap . Associated Issue ! = 0 | | len ( ap . No Issue Approvers ( ) ) ! = 0 ) } 
func ( ap Approvers ) Is Approved ( ) bool { reqs Met : = ap . Requirements Met ( ) if ! reqs Met & & ap . Manually Approved ( ) { return true } return reqs Met } 
func ( ap Approvers ) List Approvals ( ) [ ] Approval { approvals : = [ ] Approval { } for _ , approver : = range ap . Get Current Approvers Set ( ) . List ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals } 
func ( ap Approvers ) List No Issue Approvals ( ) [ ] Approval { approvals : = [ ] Approval { } for _ , approver : = range ap . Get No Issue Approvers Set ( ) . List ( ) { approvals = append ( approvals , ap . approvers [ approver ] ) } return approvals } 
func Generate Template ( templ , name string , data interface { } ) ( string , error ) { buf : = bytes . New Buffer String ( " " ) if message Templ , err : = template . New ( name ) . Parse ( templ ) ; err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } else if err : = message Templ . Execute ( buf , data ) ; err ! = nil { return " " , fmt . Errorf ( " " , name , err ) } return buf . String ( ) , nil } 
func Get Message ( ap Approvers , link URL * url . URL , org , repo , branch string ) * string { link URL . Path = org + " " + repo message , err : = Generate Template ( ` { {if (and (not .ap .Requirements Met ) (call .ap .Manually Approved ) ) } } Approval requirements bypassed by manually added approval . { {end - } } This pull -request has been approved by : { {range $index , $approval : = .ap .List Approvals } } { {if $index } } , { {else } } { {end } } { { $approval } } { {end } } { { - if (and (not .ap .Are Files Approved ) (not (call .ap .Manually Approved ) ) ) } } To fully approve this pull request , please assign additional approvers . We suggest the following additional approver { {if ne 1 (len .ap .Get CCs ) } }s { {end } } : { {range $index , $cc : = .ap .Get CCs } } { {if $index } } , { {end } } * * { { $cc } } * * { {end } } If they are not already assigned , you can assign the PR to them by writing ` + " " + ` in a comment when ready . { { - end } } { {if not .ap .Require Issue - } } { {else if .ap .Associated Issue - } } Associated issue : * # { { .ap .Associated Issue } } * { { else if len .ap .No Issue Approvers - } } Associated issue requirement bypassed by : { {range $index , $approval : = .ap .List No Issue Approvals } } { {if $index } } , { {else } } { {end } } { { $approval } } { {end } } { { else if call .ap .Manually Approved - } } *No associated issue * . Requirement bypassed by manually added approval . { { else - } } *No associated issue * . Update pull -request body to add a reference to an issue , or get approval with ` + " " + ` { { end - } } The full list of commands accepted by this bot can be found [here ] (https : The pull request process is described [here ] (https : <details { {if (and (not .ap .Are Files Approved ) (not (call .ap .Manually Approved ) ) ) } }open { {end } } > Needs approval from an approver in each of these files : { {range .ap .Get Files .base URL .branch } } { { . } } { {end } } Approvers can indicate their approval by writing ` + " " + ` in a comment Approvers can cancel approval by writing ` + " " + ` in a comment < /details > ` , " " , map [ string ] interface { } { " " : ap , " " : link URL , " " : org , " " : repo , " " : branch } ) if err ! = nil { ap . owners . log . With Error ( err ) . Errorf ( " " ) return nil } message + = get Gubernator Metadata ( ap . Get CCs ( ) ) title , err : = Generate Template ( " " , " " , ap ) if err ! = nil { ap . owners . log . With Error ( err ) . Errorf ( " " ) return nil } return notification ( Approval Notification Name , title , message ) } 
func get Gubernator Metadata ( to Be Assigned [ ] string ) string { bytes , err : = json . Marshal ( map [ string ] [ ] string { " " : to Be Assigned } ) if err = = nil { return fmt . Sprintf ( " \n " , bytes ) } return " " } 
func write Template ( template Path string , output Path string , data interface { } ) error { } , } t , err : = template . New ( filepath . Base ( template Path ) ) . Funcs ( func Map ) . Parse Files ( template Path ) if err ! = nil { return err } if err ! = nil { return err } } if err ! = nil { return err } defer f . Close ( ) f . Truncate ( 0 ) if err ! = nil { return err } return nil } 
func validate ( labels [ ] Label , parent string , seen map [ string ] string ) ( map [ string ] string , error ) { new Seen : = copy String Map ( seen ) for _ , l : = range labels { name : = strings . To Lower ( l . Name ) path : = parent + " " + name if other , present : = new Seen [ name ] ; present { return new Seen , fmt . Errorf ( " " , name , path , other ) } new Seen [ name ] = path if new Seen , err : = validate ( l . Previously , path , new Seen ) ; err ! = nil { return new Seen , err } if len ( l . Description ) > 1 0 0 { } } return new Seen , nil } 
func ( c Configuration ) Labels ( ) [ ] Label { var labelarrays [ ] [ ] Label labelarrays = append ( labelarrays , c . Default . Labels ) for _ , repo : = range c . Repos { labelarrays = append ( labelarrays , repo . Labels ) } labelmap : = make ( map [ string ] Label ) for _ , labels : = range labelarrays { for _ , l : = range labels { name : = strings . To Lower ( l . Name ) if _ , ok : = labelmap [ name ] ; ! ok { labelmap [ name ] = l } } } var labels [ ] Label for _ , label : = range labelmap { labels = append ( labels , label ) } sort . Slice ( labels , func ( i , j int ) bool { return labels [ i ] . Name < labels [ j ] . Name } ) return labels } 
func ( c Configuration ) validate ( orgs string ) error { if err ! = nil { return fmt . Errorf ( " " , err ) } sort . Strings ( sorted Orgs ) } if len ( data ) = = 2 { if ! string In Sorted Slice ( data [ 0 ] , sorted Orgs ) { logrus . With Field ( " " , orgs ) . With Field ( " " , data [ 0 ] ) . With Field ( " " , repo ) . Warn ( " " ) } } } } return nil } 
func Labels For Target ( labels [ ] Label , target Label Target ) ( filtered Labels [ ] Label ) { for _ , label : = range labels { if target = = label . Target { filtered Labels = append ( filtered Labels , label ) } } return } 
func Load Config ( path string , orgs string ) ( * Configuration , error ) { if path = = " " { return nil , errors . New ( " " ) } var c Configuration data , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } if err = yaml . Unmarshal ( data , & c ) ; err ! = nil { return nil , err } if err = c . validate ( orgs ) ; err ! = nil { } return & c , nil } 
func Get Org ( org string ) ( string , bool ) { data : = strings . Split ( org , " " ) if len ( data ) = = 2 & & data [ 0 ] = = " " { return data [ 1 ] , true } return org , false } 
func load Repos ( org string , gc client ) ( [ ] string , error ) { org , is User : = Get Org ( org ) repos , err : = gc . Get Repos ( org , is User ) if err ! = nil { return nil , err } var rl [ ] string for _ , r : = range repos { if r . Archived { continue } rl = append ( rl , r . Name ) } return rl , nil } 
func load Labels ( gc client , org string , repos [ ] string ) ( * Repo Labels , error ) { repo Chan : = make ( chan string , len ( repos ) ) for _ , repo : = range repos { repo Chan < - repo } close ( repo Chan ) wg : = sync . Wait Group { } wg . Add ( max Concurrent Workers ) labels : = make ( chan Repo Labels , len ( repos ) ) err Chan : = make ( chan error , len ( repos ) ) for i : = 0 ; i < max Concurrent Workers ; i + + { go func ( repositories < - chan string ) { defer wg . Done ( ) for repository : = range repositories { logrus . With Field ( " " , org ) . With Field ( " " , repository ) . Info ( " " ) repo Labels , err : = gc . Get Repo Labels ( org , repository ) if err ! = nil { logrus . With Field ( " " , org ) . With Field ( " " , repository ) . Error ( " " ) err Chan < - err } labels < - Repo Labels { repository : repo Labels } } } ( repo Chan ) } wg . Wait ( ) close ( labels ) close ( err Chan ) rl : = Repo Labels { } for data : = range labels { for repo , repo Labels : = range data { rl [ repo ] = repo Labels } } var overall Err error if len ( err Chan ) > 0 { var list Errs [ ] error for list Err : = range err Chan { list Errs = append ( list Errs , list Err ) } overall Err = fmt . Errorf ( " " , list Errs ) } return & rl , overall Err } 
func kill ( repo string , label Label ) Update { logrus . With Field ( " " , repo ) . With Field ( " " , label . Name ) . Info ( " " ) return Update { Why : " " , Current : & label , repo : repo } } 
func create ( repo string , label Label ) Update { logrus . With Field ( " " , repo ) . With Field ( " " , label . Name ) . Info ( " " ) return Update { Why : " " , Wanted : & label , repo : repo } } 
func rename ( repo string , previous , wanted Label ) Update { logrus . With Field ( " " , repo ) . With Field ( " " , previous . Name ) . With Field ( " " , wanted . Name ) . Info ( " " ) return Update { Why : " " , Current : & previous , Wanted : & wanted , repo : repo } } 
func change ( repo string , label Label ) Update { logrus . With Field ( " " , repo ) . With Field ( " " , label . Name ) . With Field ( " " , label . Color ) . Info ( " " ) return Update { Why : " " , Current : & label , Wanted : & label , repo : repo } } 
func classify Labels ( labels [ ] Label , required , archaic , dead map [ string ] Label , now time . Time , parent * Label ) ( map [ string ] Label , map [ string ] Label , map [ string ] Label ) { new Required : = copy Label Map ( required ) new Archaic : = copy Label Map ( archaic ) new Dead : = copy Label Map ( dead ) for i , l : = range labels { first : = parent if first = = nil { first = & labels [ i ] } lower : = strings . To Lower ( l . Name ) switch { case parent = = nil & & l . Delete After = = nil : case l . Delete After ! = nil & & now . After ( * l . Delete After ) : new Dead [ lower ] = l case parent ! = nil : l . parent = parent new Archaic [ lower ] = l } new Required , new Archaic , new Dead = classify Labels ( l . Previously , new Required , new Archaic , new Dead , now , first ) } return new Required , new Archaic , new Dead } 
func ( ru Repo Updates ) Do Updates ( org string , gc client ) error { var num Updates int for _ , updates : = range ru { num Updates + = len ( updates ) } update Chan : = make ( chan repo Update , num Updates ) for repo , updates : = range ru { logrus . With Field ( " " , org ) . With Field ( " " , repo ) . Infof ( " " , len ( updates ) ) for _ , item : = range updates { update Chan < - repo Update { repo : repo , update : item } } } close ( update Chan ) wg : = sync . Wait Group { } wg . Add ( max Concurrent Workers ) err Chan : = make ( chan error , num Updates ) for i : = 0 ; i < max Concurrent Workers ; i + + { go func ( updates < - chan repo Update ) { defer wg . Done ( ) for item : = range updates { repo : = item . repo update : = item . update logrus . With Field ( " " , org ) . With Field ( " " , repo ) . With Field ( " " , update . Why ) . Debug ( " " ) switch update . Why { case " " : err : = gc . Add Repo Label ( org , repo , update . Wanted . Name , update . Wanted . Description , update . Wanted . Color ) if err ! = nil { err Chan < - err } case " " , " " : err : = gc . Update Repo Label ( org , repo , update . Current . Name , update . Wanted . Name , update . Wanted . Description , update . Wanted . Color ) if err ! = nil { err Chan < - err } case " " : err : = gc . Delete Repo Label ( org , repo , update . Current . Name ) if err ! = nil { err Chan < - err } case " " : issues , err : = gc . Find Issues ( fmt . Sprintf ( " \ " \ " \ " \ " " , org , repo , update . Current . Name , update . Wanted . Name ) , " " , false ) if err ! = nil { err Chan < - err } if len ( issues ) = = 0 { if err = gc . Delete Repo Label ( org , repo , update . Current . Name ) ; err ! = nil { err Chan < - err } } for _ , i : = range issues { if err = gc . Add Label ( org , repo , i . Number , update . Wanted . Name ) ; err ! = nil { err Chan < - err continue } if err = gc . Remove Label ( org , repo , i . Number , update . Current . Name ) ; err ! = nil { err Chan < - err } } default : err Chan < - errors . New ( " " + update . Why ) } } } ( update Chan ) } wg . Wait ( ) close ( err Chan ) var overall Err error if len ( err Chan ) > 0 { var update Errs [ ] error for update Err : = range err Chan { update Errs = append ( update Errs , update Err ) } overall Err = fmt . Errorf ( " " , update Errs ) } return overall Err } 
func main ( ) { logrus . Set Formatter ( logrusutil . New Default Fields Formatter ( nil , logrus . Fields { " " : " " } ) , ) flag . Parse ( ) if * debug { logrus . Set Level ( logrus . Debug Level ) } config , err : = Load Config ( * labels Path , * orgs ) if err ! = nil { logrus . With Error ( err ) . Fatalf ( " " , * labels Path ) } if * only Repos ! = " " & & * skip Repos ! = " " { logrus . Fatalf ( " " ) } if * only Repos ! = " " & & * orgs ! = " " { logrus . Fatalf ( " " ) } switch { case * action = = " " : if err : = write Docs ( * docs Template , * docs Output , * config ) ; err ! = nil { logrus . With Error ( err ) . Fatalf ( " " , * docs Template , * docs Output ) } case * action = = " " : if err : = write CSS ( * css Template , * css Output , * config ) ; err ! = nil { logrus . With Error ( err ) . Fatalf ( " " , * css Template , * css Output ) } case * action = = " " : github Client , err : = new Client ( * token , * tokens , * token Burst , ! * confirm , * graphql Endpoint , endpoint . Strings ( ) . . . ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } if parse Error ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } for org : = range repos To Sync { if err = sync Org ( org , github Client , * config , repos To Sync [ org ] ) ; err ! = nil { logrus . With Error ( err ) . Fatalf ( " " , org ) } } return } skipped Repos : = map [ string ] [ ] string { } if * skip Repos ! = " " { repos To Skip , parse Error : = parse Comma Delimited List ( * skip Repos ) if parse Error ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } skipped Repos = repos To Skip } for _ , org : = range strings . Split ( * orgs , " " ) { org = strings . Trim Space ( org ) logger : = logrus . With Field ( " " , org ) logger . Info ( " " ) repos , err : = load Repos ( org , github Client ) if err ! = nil { logger . With Error ( err ) . Fatalf ( " " ) } if skipped , exist : = skipped Repos [ org ] ; exist { repos = sets . New String ( repos . . . ) . Difference ( sets . New String ( skipped . . . ) ) . Unsorted List ( ) } if err = sync Org ( org , github Client , * config , repos ) ; err ! = nil { logrus . With Error ( err ) . Fatalf ( " " , org ) } } default : logrus . Fatalf ( " " , * action ) } } 
func parse Comma Delimited List ( list string ) ( map [ string ] [ ] string , error ) { mapping : = map [ string ] [ ] string { } for _ , r : = range strings . Split ( list , " " ) { value : = strings . Trim Space ( r ) if strings . Count ( value , " " ) ! = 1 { return nil , fmt . Errorf ( " " , value ) } parts : = strings . Split N ( value , " " , 2 ) if others , exist : = mapping [ parts [ 0 ] ] ; ! exist { mapping [ parts [ 0 ] ] = [ ] string { parts [ 1 ] } } else { mapping [ parts [ 0 ] ] = append ( others , parts [ 1 ] ) } } return mapping , nil } 
func linkify ( text string ) string { link = discard . Replace All String ( link , " " ) } 
func css Escape ( s string ) ( escaped string ) { var Is Alpha = regexp . Must Compile ( ` ^ [a -z A -Z ] + $ ` ) . Match String for i , c : = range s { if ( i = = 0 & & unicode . Is Digit ( c ) ) | | ! ( unicode . Is Digit ( c ) | | Is Alpha ( string ( c ) ) ) { escaped + = fmt . Sprintf ( " " , c ) continue } escaped + = string ( c ) } return } 
func get Text Color ( background Color string ) ( string , error ) { d , err : = hex . Decode String ( background Color ) if err ! = nil | | len ( d ) ! = 3 { return " " , errors . New ( " " ) } for i , v : = range d { color [ i ] = float 6 4 ( v ) / 2 5 5 . 0 if color [ i ] < = 0 . 0 3 9 2 8 { color [ i ] = color [ i ] / 1 2 . 9 2 } else { color [ i ] = math . Pow ( ( color [ i ] + 0 . 0 5 5 ) / 1 . 0 5 5 , 2 . 4 ) } } L : = 0 . 2 1 2 6 * color [ 0 ] + 0 . 7 1 5 2 * color [ 1 ] + 0 . 0 7 2 2 * color [ 2 ] if ( L + 0 . 0 5 ) / ( 0 . 0 + 0 . 0 5 ) > ( 1 . 0 + 0 . 0 5 ) / ( L + 0 . 0 5 ) { return " " , nil } else { return " " , nil } } 
func New Cache ( disk Root string ) * Cache { return & Cache { disk Root : strings . Trim Suffix ( disk Root , string ( os . Path List Separator ) ) , } } 
func ( c * Cache ) Key To Path ( key string ) string { return filepath . Join ( c . disk Root , key ) } 
func ( c * Cache ) Path To Key ( key string ) string { return strings . Trim Prefix ( key , c . disk Root + string ( os . Path Separator ) ) } 
func ensure Dir ( dir string ) error { if exists ( dir ) { return nil } return os . Mkdir All ( dir , os . File Mode ( 0 7 4 4 ) ) } 
func ( c * Cache ) Put ( key string , content io . Reader , content SHA 2 5 6 string ) error { dir : = filepath . Dir ( path ) err : = ensure Dir ( dir ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , dir ) } if err ! = nil { return fmt . Errorf ( " " , err ) } if err ! = nil { remove Temp ( temp . Name ( ) ) return fmt . Errorf ( " " , err ) } } else { hasher : = sha 2 5 6 . New ( ) _ , err = io . Copy ( io . Multi Writer ( temp , hasher ) , content ) if err ! = nil { remove Temp ( temp . Name ( ) ) return fmt . Errorf ( " " , err ) } actual Content SHA 2 5 6 : = hex . Encode To String ( hasher . Sum ( nil ) ) if actual Content SHA 2 5 6 ! = content SHA 2 5 6 { remove Temp ( temp . Name ( ) ) return fmt . Errorf ( " " , key , content SHA 2 5 6 , actual Content SHA 2 5 6 ) } } if err ! = nil { remove Temp ( temp . Name ( ) ) return fmt . Errorf ( " " , err ) } temp . Close ( ) err = os . Rename ( temp . Name ( ) , path ) if err ! = nil { remove Temp ( temp . Name ( ) ) return fmt . Errorf ( " " , err ) } return nil } 
func ( c * Cache ) Get ( key string , read Handler Read Handler ) error { path : = c . Key To Path ( key ) f , err : = os . Open ( path ) if err ! = nil { if os . Is Not Exist ( err ) { return read Handler ( false , nil ) } return fmt . Errorf ( " " , err ) } return read Handler ( true , f ) } 
func ( c * Cache ) Get Entries ( ) [ ] Entry Info { entries : = [ ] Entry Info { } return nil } if ! f . Is Dir ( ) { atime : = diskutil . Get ATime ( path , time . Now ( ) ) entries = append ( entries , Entry Info { Path : path , Last Access : atime , } ) } return nil } ) return entries } 
func ( c * Cache ) Delete ( key string ) error { return os . Remove ( c . Key To Path ( key ) ) } 
func New GCSArtifact ( ctx context . Context , handle artifact Handle , link string , path string , size Limit int 6 4 ) * GCSArtifact { return & GCSArtifact { handle : handle , link : link , path : path , size Limit : size Limit , ctx : ctx , } } 
func ( a * GCSArtifact ) Size ( ) ( int 6 4 , error ) { attrs , err : = a . handle . Attrs ( a . ctx ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } return attrs . Size , nil } 
func ( a * GCSArtifact ) Read At ( p [ ] byte , off int 6 4 ) ( n int , err error ) { gzipped , err : = a . gzipped ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } if gzipped { return 0 , lenses . Err Gzip Offset Read } artifact Size , err : = a . Size ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } if off > = artifact Size { return 0 , fmt . Errorf ( " " ) } var got EOF bool to Read : = int 6 4 ( len ( p ) ) if to Read + off > artifact Size { return 0 , fmt . Errorf ( " " ) } else if to Read + off = = artifact Size { got EOF = true } reader , err : = a . handle . New Range Reader ( a . ctx , off , to Read ) defer reader . Close ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } for offset < len ( p ) { n , err = reader . Read ( p [ offset : ] ) offset + = n if err ! = nil { if err = = io . EOF & & got EOF { break } return 0 , fmt . Errorf ( " " , err ) } } if got EOF { return offset , io . EOF } return offset , nil } 
func ( a * GCSArtifact ) Read At Most ( n int 6 4 ) ( [ ] byte , error ) { var reader io . Read Closer var p [ ] byte gzipped , err : = a . gzipped ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if gzipped { reader , err = a . handle . New Reader ( a . ctx ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } defer reader . Close ( ) p , err = ioutil . Read All ( reader ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } artifact Size : = int 6 4 ( len ( p ) ) read Range : = n if n > artifact Size { read Range = artifact Size return p [ : read Range ] , io . EOF } return p [ : read Range ] , nil } artifact Size , err : = a . Size ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } read Range : = n var got EOF bool if n > artifact Size { got EOF = true read Range = artifact Size } reader , err = a . handle . New Range Reader ( a . ctx , 0 , read Range ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } defer reader . Close ( ) p , err = ioutil . Read All ( reader ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if got EOF { return p , io . EOF } return p , nil } 
func ( a * GCSArtifact ) Read All ( ) ( [ ] byte , error ) { size , err : = a . Size ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if size > a . size Limit { return nil , lenses . Err File Too Large } reader , err : = a . handle . New Reader ( a . ctx ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } defer reader . Close ( ) p , err : = ioutil . Read All ( reader ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return p , nil } 
func ( a * GCSArtifact ) Read Tail ( n int 6 4 ) ( [ ] byte , error ) { gzipped , err : = a . gzipped ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if gzipped { return nil , lenses . Err Gzip Offset Read } size , err : = a . Size ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } var offset int 6 4 if n > = size { offset = 0 } else { offset = size - n } reader , err : = a . handle . New Range Reader ( a . ctx , offset , - 1 ) defer reader . Close ( ) if err ! = nil & & err ! = io . EOF { return nil , fmt . Errorf ( " " , err ) } read , err : = ioutil . Read All ( reader ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return read , nil } 
func ( a * GCSArtifact ) gzipped ( ) ( bool , error ) { attrs , err : = a . handle . Attrs ( a . ctx ) if err ! = nil { return false , fmt . Errorf ( " " , err ) } return attrs . Content Encoding = = " " , nil } 
func options For Repo ( config * plugins . Configuration , org , repo string ) * plugins . Welcome { full Name : = fmt . Sprintf ( " " , org , repo ) } return & c } } return & c } } 
func ( s * prow Job Lister ) List ( selector labels . Selector ) ( ret [ ] * v 1 . Prow Job , err error ) { err = cache . List All ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v 1 . Prow Job ) ) } ) return ret , err } 
func ( s * prow Job Lister ) Prow Jobs ( namespace string ) Prow Job Namespace Lister { return prow Job Namespace Lister { indexer : s . indexer , namespace : namespace } } 
func ( s prow Job Namespace Lister ) List ( selector labels . Selector ) ( ret [ ] * v 1 . Prow Job , err error ) { err = cache . List All By Namespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v 1 . Prow Job ) ) } ) return ret , err } 
func Metadata From File Name ( filename string ) ( string , map [ string ] string ) { metadata : = make ( map [ string ] string ) segments : = strings . Split ( filename , " " ) index : = len ( segments ) - 1 segment : = segments [ index ] } if _ , ok : = metadata [ " " ] ; ok { if index = = 0 { segment = " " } else { filename = filename [ : len ( filename ) - len ( segment ) - 1 ] index - = 1 segment = segments [ index ] } } if segment ! = " " { media Type : = mime . Type By Extension ( " " + segment ) if media Type ! = " " { metadata [ " " ] = media Type } } if _ , ok : = metadata [ " " ] ; ! ok { if _ , ok : = metadata [ " " ] ; ok { metadata [ " " ] = " " delete ( metadata , " " ) } } return filename , metadata } 
func ( br Brancher ) Runs Against All Branch ( ) bool { return len ( br . Skip Branches ) = = 0 & & len ( br . Branches ) = = 0 } 
func ( br Brancher ) Should Run ( branch string ) bool { if br . Runs Against All Branch ( ) { return true } } if len ( br . Branches ) = = 0 | | br . re . Match String ( branch ) { return true } return false } 
func ( br Brancher ) Intersects ( other Brancher ) bool { if br . Runs Against All Branch ( ) | | other . Runs Against All Branch ( ) { return true } if len ( br . Branches ) > 0 { base Branches : = sets . New String ( br . Branches . . . ) if len ( other . Branches ) > 0 { other Branches : = sets . New String ( other . Branches . . . ) if base Branches . Intersection ( other Branches ) . Len ( ) > 0 { return true } return false } } } return false } if len ( other . Branches ) = = 0 { } return other . Intersects ( br ) } 
func ( cm Regexp Change Matcher ) Should Run ( changes Changed Files Provider ) ( determined bool , should Run bool , err error ) { if cm . Could Run ( ) { change List , err : = changes ( ) if err ! = nil { return true , false , err } return true , cm . Runs Against Changes ( change List ) , nil } return false , false , nil } 
func ( cm Regexp Change Matcher ) Runs Against Changes ( changes [ ] string ) bool { for _ , change : = range changes { if cm . re Changes . Match String ( change ) { return true } } return false } 
func ( ps Postsubmit ) Could Run ( base Ref string ) bool { return ps . Brancher . Should Run ( base Ref ) } 
func ( ps Postsubmit ) Should Run ( base Ref string , changes Changed Files Provider ) ( bool , error ) { if ! ps . Could Run ( base Ref ) { return false , nil } if determined , should Run , err : = ps . Regexp Change Matcher . Should Run ( changes ) ; err ! = nil { return false , err } else if determined { return should Run , nil } } 
func ( ps Presubmit ) Could Run ( base Ref string ) bool { return ps . Brancher . Should Run ( base Ref ) } 
func ( ps Presubmit ) Should Run ( base Ref string , changes Changed Files Provider , forced , defaults bool ) ( bool , error ) { if ! ps . Could Run ( base Ref ) { return false , nil } if ps . Always Run { return true , nil } if forced { return true , nil } if determined , should Run , err : = ps . Regexp Change Matcher . Should Run ( changes ) ; err ! = nil { return false , err } else if determined { return should Run , nil } return defaults , nil } 
func ( ps Presubmit ) Trigger Matches ( body string ) bool { return ps . Trigger ! = " " & & ps . re . Match String ( body ) } 
func New Git Hub Deferred Changed Files Provider ( client github Client , org , repo string , num int ) Changed Files Provider { var changed Files [ ] string return func ( ) ( [ ] string , error ) { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , change : = range changes { changed Files = append ( changed Files , change . Filename ) } } return changed Files , nil } } 
func ( c * Job Config ) Get Presubmit ( repo , job Name string ) * Presubmit { presubmits : = c . All Presubmits ( [ ] string { repo } ) for i : = range presubmits { ps : = presubmits [ i ] if ps . Name = = job Name { return & ps } } return nil } 
func ( c * Job Config ) Set Presubmits ( jobs map [ string ] [ ] Presubmit ) error { nj : = map [ string ] [ ] Presubmit { } for k , v : = range jobs { nj [ k ] = make ( [ ] Presubmit , len ( v ) ) copy ( nj [ k ] , v ) if err : = Set Presubmit Regexes ( nj [ k ] ) ; err ! = nil { return err } } c . Presubmits = nj return nil } 
func ( c * Job Config ) Set Postsubmits ( jobs map [ string ] [ ] Postsubmit ) error { nj : = map [ string ] [ ] Postsubmit { } for k , v : = range jobs { nj [ k ] = make ( [ ] Postsubmit , len ( v ) ) copy ( nj [ k ] , v ) if err : = Set Postsubmit Regexes ( nj [ k ] ) ; err ! = nil { return err } } c . Postsubmits = nj return nil } 
func ( c * Job Config ) All Presubmits ( repos [ ] string ) [ ] Presubmit { var res [ ] Presubmit for repo , v : = range c . Presubmits { if len ( repos ) = = 0 { res = append ( res , v . . . ) } else { for _ , r : = range repos { if r = = repo { res = append ( res , v . . . ) break } } } } return res } 
func ( c * Job Config ) All Postsubmits ( repos [ ] string ) [ ] Postsubmit { var res [ ] Postsubmit for repo , v : = range c . Postsubmits { if len ( repos ) = = 0 { res = append ( res , v . . . ) } else { for _ , r : = range repos { if r = = repo { res = append ( res , v . . . ) break } } } } return res } 
func ( c * Job Config ) All Periodics ( ) [ ] Periodic { var list Periodic func ( ps [ ] Periodic ) [ ] Periodic list Periodic = func ( ps [ ] Periodic ) [ ] Periodic { var res [ ] Periodic for _ , p : = range ps { res = append ( res , p ) } return res } return list Periodic ( c . Periodics ) } 
func Clear Compiled Regexes ( presubmits [ ] Presubmit ) { for i : = range presubmits { presubmits [ i ] . re = nil presubmits [ i ] . Brancher . re = nil presubmits [ i ] . Brancher . re Skip = nil presubmits [ i ] . Regexp Change Matcher . re Changes = nil } } 
func ( s * Simple Config ) Empty ( ) bool { return len ( s . Approvers ) = = 0 & & len ( s . Reviewers ) = = 0 & & len ( s . Required Reviewers ) = = 0 & & len ( s . Labels ) = = 0 } 
func New Client ( gc * git . Client , ghc * github . Client , md YAMLEnabled func ( org , repo string ) bool , skip Collaborators func ( org , repo string ) bool , owners Dir Blacklist func ( ) prow Conf . Owners Dir Blacklist , ) * Client { return & Client { git : gc , ghc : ghc , logger : logrus . With Field ( " " , " " ) , cache : make ( map [ string ] cache Entry ) , md YAMLEnabled : md YAMLEnabled , skip Collaborators : skip Collaborators , owners Dir Blacklist : owners Dir Blacklist , } } 
func ( c * Client ) Load Repo Aliases ( org , repo , base string ) ( Repo Aliases , error ) { log : = c . logger . With Fields ( logrus . Fields { " " : org , " " : repo , " " : base } ) clone Ref : = fmt . Sprintf ( " " , org , repo ) full Name : = fmt . Sprintf ( " " , clone Ref , base ) sha , err : = c . ghc . Get Ref ( org , repo , fmt . Sprintf ( " " , base ) ) if err ! = nil { return nil , fmt . Errorf ( " " , full Name , err ) } c . lock . Lock ( ) defer c . lock . Unlock ( ) entry , ok : = c . cache [ full Name ] if ! ok | | entry . sha ! = sha { if err ! = nil { return nil , fmt . Errorf ( " " , clone Ref , err ) } defer git Repo . Clean ( ) if err : = git Repo . Checkout ( base ) ; err ! = nil { return nil , err } entry . aliases = load Aliases From ( git Repo . Dir , log ) entry . sha = sha c . cache [ full Name ] = entry } return entry . aliases , nil } 
func ( c * Client ) Load Repo Owners ( org , repo , base string ) ( Repo Owner , error ) { log : = c . logger . With Fields ( logrus . Fields { " " : org , " " : repo , " " : base } ) clone Ref : = fmt . Sprintf ( " " , org , repo ) full Name : = fmt . Sprintf ( " " , clone Ref , base ) md Yaml : = c . md YAMLEnabled ( org , repo ) sha , err : = c . ghc . Get Ref ( org , repo , fmt . Sprintf ( " " , base ) ) if err ! = nil { return nil , fmt . Errorf ( " " , full Name , err ) } c . lock . Lock ( ) defer c . lock . Unlock ( ) entry , ok : = c . cache [ full Name ] if ! ok | | entry . sha ! = sha | | entry . owners = = nil | | ! entry . matches MDYAML ( md Yaml ) { git Repo , err : = c . git . Clone ( clone Ref ) if err ! = nil { return nil , fmt . Errorf ( " " , clone Ref , err ) } defer git Repo . Clean ( ) reusable : = entry . fully Loaded ( ) & & entry . matches MDYAML ( md Yaml ) if err ! = nil { return nil , fmt . Errorf ( " " , sha , entry . sha ) } for _ , change : = range changes { if md Yaml & & strings . Has Suffix ( change , " " ) | | strings . Has Suffix ( change , aliases File Name ) | | strings . Has Suffix ( change , owners File Name ) { reusable = false break } } } if reusable { entry . sha = sha } else { if err : = git Repo . Checkout ( base ) ; err ! = nil { return nil , err } if entry . aliases = = nil | | entry . sha ! = sha { } dir Blacklist Patterns : = append ( c . owners Dir Blacklist ( ) . Dir Blacklist ( org , repo ) , common Dir Blacklist . . . ) var dir Blacklist [ ] * regexp . Regexp for _ , pattern : = range dir Blacklist Patterns { re , err : = regexp . Compile ( pattern ) if err ! = nil { log . With Error ( err ) . Errorf ( " " , pattern ) continue } dir Blacklist = append ( dir Blacklist , re ) } entry . owners , err = load Owners From ( git Repo . Dir , md Yaml , entry . aliases , dir Blacklist , log ) if err ! = nil { return nil , fmt . Errorf ( " " , full Name , err ) } entry . sha = sha c . cache [ full Name ] = entry } } if c . skip Collaborators ( org , repo ) { log . Debugf ( " " , org , repo ) return entry . owners , nil } var owners * Repo Owners if err ! = nil { log . With Error ( err ) . Errorf ( " " ) owners = entry . owners } else { owners = entry . owners . filter Collaborators ( collaborators ) } return owners , nil } 
func ( a Repo Aliases ) Expand Alias ( alias string ) sets . String { if a = = nil { return nil } return a [ github . Norm Login ( alias ) ] } 
func ( a Repo Aliases ) Expand Aliases ( logins sets . String ) sets . String { if a = = nil { return logins } for _ , login : = range logins . List ( ) { if expanded : = a . Expand Alias ( login ) ; len ( expanded ) > 0 { logins . Delete ( login ) logins = logins . Union ( expanded ) } } return logins } 
func Parse Full Config ( b [ ] byte ) ( Full Config , error ) { full : = new ( Full Config ) err : = yaml . Unmarshal ( b , full ) return * full , err } 
func Parse Simple Config ( b [ ] byte ) ( Simple Config , error ) { simple : = new ( Simple Config ) err : = yaml . Unmarshal ( b , simple ) return * simple , err } 
func decode Owners Md Config ( path string , config * Simple Config ) error { file Bytes , err : = ioutil . Read File ( path ) if err ! = nil { return err } } 
func find Owners For File ( log * logrus . Entry , path string , owner Map map [ string ] map [ * regexp . Regexp ] sets . String ) string { d : = path for ; d ! = base Dir Convention ; d = canonicalize ( filepath . Dir ( d ) ) { relative , err : = filepath . Rel ( d , path ) if err ! = nil { log . With Error ( err ) . With Field ( " " , path ) . Errorf ( " " , d ) return " " } for re , n : = range owner Map [ d ] { if re ! = nil & & ! re . Match String ( relative ) { continue } if len ( n ) ! = 0 { return d } } } return " " } 
func ( o * Repo Owners ) Find Approver Owners For File ( path string ) string { return find Owners For File ( o . log , path , o . approvers ) } 
func ( o * Repo Owners ) Find Reviewers Owners For File ( path string ) string { return find Owners For File ( o . log , path , o . reviewers ) } 
func ( o * Repo Owners ) Find Labels For File ( path string ) sets . String { return o . entries For File ( path , o . labels , false ) } 
func ( o * Repo Owners ) Is No Parent Owners ( path string ) bool { return o . options [ path ] . No Parent Owners } 
func ( o * Repo Owners ) entries For File ( path string , people map [ string ] map [ * regexp . Regexp ] sets . String , leaf Only bool ) sets . String { d : = path if ! o . enable MDYAML | | ! strings . Has Suffix ( path , " " ) { d = canonicalize ( path ) } out : = sets . New String ( ) for { relative , err : = filepath . Rel ( d , path ) if err ! = nil { o . log . With Error ( err ) . With Field ( " " , path ) . Errorf ( " " , d ) return nil } for re , s : = range people [ d ] { if re = = nil | | re . Match String ( relative ) { out . Insert ( s . List ( ) . . . ) } } if leaf Only & & out . Len ( ) > 0 { break } if d = = base Dir Convention { break } if o . options [ d ] . No Parent Owners { break } d = filepath . Dir ( d ) d = canonicalize ( d ) } return out } 
func ( o * Repo Owners ) Leaf Approvers ( path string ) sets . String { return o . entries For File ( path , o . approvers , true ) } 
func ( o * Repo Owners ) Approvers ( path string ) sets . String { return o . entries For File ( path , o . approvers , false ) } 
func ( o * Repo Owners ) Leaf Reviewers ( path string ) sets . String { return o . entries For File ( path , o . reviewers , true ) } 
func ( o * Repo Owners ) Reviewers ( path string ) sets . String { return o . entries For File ( path , o . reviewers , false ) } 
func ( o * Repo Owners ) Required Reviewers ( path string ) sets . String { return o . entries For File ( path , o . required Reviewers , false ) } 
func ( c * Coverage ) Ratio ( ) float 3 2 { if c . Num All Stmts = = 0 { return 1 } return float 3 2 ( c . Num Covered Stmts ) / float 3 2 ( c . Num All Stmts ) } 
func ( pe * Periodic Prow Job Event ) From Payload ( data [ ] byte ) error { if err : = json . Unmarshal ( data , pe ) ; err ! = nil { return err } return nil } 
func ( pe * Periodic Prow Job Event ) To Message ( ) ( * pubsub . Message , error ) { data , err : = json . Marshal ( pe ) if err ! = nil { return nil , err } message : = pubsub . Message { Data : data , Attributes : map [ string ] string { prow Event Type : periodic Prow Job Event , } , } return & message , nil } 
func ( p * Privacy ) Unmarshal Text ( text [ ] byte ) error { v : = Privacy ( text ) if _ , ok : = privacy Settings [ v ] ; ! ok { return fmt . Errorf ( " " , v ) } * p = v return nil } 
func compile Applicable Blockades ( org , repo string , log * logrus . Entry , blockades [ ] plugins . Blockade ) [ ] blockade { if len ( blockades ) = = 0 { return nil } org Repo : = fmt . Sprintf ( " " , org , repo ) var compiled [ ] blockade for _ , raw : = range blockades { } b : = blockade { } for _ , str : = range raw . Block Regexps { if reg , err : = regexp . Compile ( str ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , str ) } else { b . block Regexps = append ( b . block Regexps , reg ) } } if len ( b . block Regexps ) = = 0 { continue } if raw . Explanation = = " " { b . explanation = " " } else { b . explanation = raw . Explanation } for _ , str : = range raw . Exception Regexps { if reg , err : = regexp . Compile ( str ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , str ) } else { b . exception Regexps = append ( b . exception Regexps , reg ) } } compiled = append ( compiled , b ) } return compiled } 
func calculate Blocks ( changes [ ] github . Pull Request Change , blockades [ ] blockade ) summary { sum : = make ( summary ) for _ , change : = range changes { for _ , b : = range blockades { if b . is Blocked ( change . Filename ) { sum [ b . explanation ] = append ( sum [ b . explanation ] , change ) } } } return sum } 
func Merge Profiles ( a [ ] * cover . Profile , b [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { var result [ ] * cover . Profile files : = make ( map [ string ] * cover . Profile , len ( a ) ) for _ , profile : = range a { np : = deep Copy Profile ( * profile ) result = append ( result , & np ) files [ np . File Name ] = & np } needs Sort : = false if ok { if err : = ensure Profiles Match ( profile , dest ) ; err ! = nil { return nil , fmt . Errorf ( " " , profile . File Name , err ) } for i , block : = range profile . Blocks { db : = & dest . Blocks [ i ] db . Count + = block . Count } } else { files [ np . File Name ] = & np result = append ( result , & np ) needs Sort = true } } if needs Sort { sort . Slice ( result , func ( i , j int ) bool { return result [ i ] . File Name < result [ j ] . File Name } ) } return result , nil } 
func Merge Multiple Profiles ( profiles [ ] [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { if len ( profiles ) < 1 { return nil , errors . New ( " " ) } result : = profiles [ 0 ] for _ , profile : = range profiles [ 1 : ] { var err error if result , err = Merge Profiles ( result , profile ) ; err ! = nil { return nil , err } } return result , nil } 
func ( a * Author Logger Plugin Wrapper ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . Bool Var ( & a . enabled , " " , false , " " ) } 
func ( a * Author Logger Plugin Wrapper ) Receive Issue ( issue sql . Issue ) [ ] Point { points : = a . plugin . Receive Issue ( issue ) if a . enabled { for i : = range points { if points [ i ] . Values = = nil { points [ i ] . Values = map [ string ] interface { } { } } points [ i ] . Values [ " " ] = issue . User } } return points } 
func ( a * Author Logger Plugin Wrapper ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { points : = a . plugin . Receive Issue Event ( event ) if a . enabled { for i : = range points { if points [ i ] . Values = = nil { points [ i ] . Values = map [ string ] interface { } { } } if event . Actor ! = nil { points [ i ] . Values [ " " ] = * event . Actor } } } return points } 
func ( a * Author Logger Plugin Wrapper ) Receive Comment ( comment sql . Comment ) [ ] Point { points : = a . plugin . Receive Comment ( comment ) if a . enabled { for i : = range points { if points [ i ] . Values = = nil { points [ i ] . Values = map [ string ] interface { } { } } points [ i ] . Values [ " " ] = comment . User } } return points } 
func ( o * Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . Process Log , " " , " " , " " ) fs . String Var ( & o . Marker File , " " , " " , " " ) fs . String Var ( & o . Metadata File , " " , " " , " " ) } 
func ( o * Options ) Validate ( ) error { if o . Process Log = = " " { return errors . New ( " " ) } if o . Marker File = = " " { return errors . New ( " " ) } return nil } 
func ( c * Controller ) process Next Item ( ) bool { key , quit : = c . queue . Get ( ) if quit { return false } defer c . queue . Done ( key ) work Item : = key . ( item ) prow Job , err : = c . prow Job Client . Get Prow Job ( work Item . prow Job Id ) if err ! = nil { c . handle Err ( err , work Item ) return true } spec : = downwardapi . New Job Spec ( prow Job . Spec , prow Job . Status . Build ID , prow Job . Name ) result : = c . client . Pods ( work Item . namespace ) . Get Logs ( work Item . pod Name , & api . Pod Log Options { Container : work Item . container Name } ) . Do ( ) if err : = result . Error ( ) ; err ! = nil { c . handle Err ( err , work Item ) return true } var target string if work Item . pod Name = = work Item . prow Job Id { target = path . Join ( Container Log Dir , fmt . Sprintf ( " " , work Item . container Name ) ) } else { target = path . Join ( Container Log Dir , work Item . pod Name , fmt . Sprintf ( " " , work Item . container Name ) ) } data : = gcs . Data Upload ( bytes . New Reader ( log ) ) if err : = c . gcs Config . Run ( & spec , map [ string ] gcs . Upload Func { target : data } ) ; err ! = nil { c . handle Err ( err , work Item ) return true } c . queue . Forget ( key ) return true } 
func ( c * Controller ) handle Err ( err error , key item ) { if c . queue . Num Requeues ( key ) < 5 { glog . Infof ( " " , key . container Name , key . pod Name , err ) c . queue . Add Rate Limited ( key ) return } c . queue . Forget ( key ) glog . Infof ( " " , key . container Name , key . pod Name , err ) } 
func Command Filter ( body string ) Filter { return func ( p config . Presubmit ) ( bool , bool , bool ) { return p . Trigger Matches ( body ) , p . Trigger Matches ( body ) , true } } 
func Aggregate Filter ( filters [ ] Filter ) Filter { return func ( presubmit config . Presubmit ) ( bool , bool , bool ) { for _ , filter : = range filters { if should Run , forced , defaults : = filter ( presubmit ) ; should Run { return should Run , forced , defaults } } return false , false , false } } 
func Filter Presubmits ( filter Filter , changes config . Changed Files Provider , branch string , presubmits [ ] config . Presubmit , logger * logrus . Entry ) ( [ ] config . Presubmit , [ ] config . Presubmit , error ) { var to Trigger [ ] config . Presubmit var to Skip [ ] config . Presubmit for _ , presubmit : = range presubmits { matches , forced , defaults : = filter ( presubmit ) if ! matches { continue } should Run , err : = presubmit . Should Run ( branch , changes , forced , defaults ) if err ! = nil { return nil , nil , err } if should Run { to Trigger = append ( to Trigger , presubmit ) } else { to Skip = append ( to Skip , presubmit ) } } logger . With Fields ( logrus . Fields { " " : to Trigger , " " : to Skip } ) . Debugf ( " " , len ( presubmits ) , len ( to Trigger ) , len ( to Skip ) ) return to Trigger , to Skip , nil } 
func Make Command ( ) * cobra . Command { flags : = & flags { } cmd : = & cobra . Command { Use : " " , Short : " " , Long : `Filters a Go coverage file , removing entries that do not match the given flags . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . String Var P ( & flags . Output File , " " , " " , " " , " " ) cmd . Flags ( ) . String Slice Var ( & flags . Include Paths , " " , nil , " " ) cmd . Flags ( ) . String Slice Var ( & flags . Exclude Paths , " " , nil , " " ) return cmd } 
func ( t * Event Time Heap ) Push ( x interface { } ) { * t = append ( * t , x . ( sql . Issue Event ) ) } 
func ( t * Event Time Heap ) Pop ( ) interface { } { old : = * t n : = len ( old ) x : = old [ n - 1 ] * t = old [ 0 : n - 1 ] return x } 
func New Fake Open Plugin Wrapper ( plugin Plugin ) * Fake Open Plugin Wrapper { return & Fake Open Plugin Wrapper { plugin : plugin , already Open : map [ string ] bool { } , } } 
func ( o * Fake Open Plugin Wrapper ) Receive Issue ( issue sql . Issue ) [ ] Point { if _ , ok : = o . already Open [ issue . ID ] ; ! ok { o . already Open [ issue . ID ] = true } return o . plugin . Receive Issue ( issue ) } 
func ( o * Fake Open Plugin Wrapper ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { points : = [ ] Point { } } return append ( points , o . plugin . Receive Issue Event ( event ) . . . ) } 
func ( o * Fake Open Plugin Wrapper ) Receive Comment ( comment sql . Comment ) [ ] Point { return o . plugin . Receive Comment ( comment ) } 
func ( o * Options ) Validate ( ) error { if o . Src Root = = " " { return errors . New ( " " ) } if o . Log = = " " { return errors . New ( " " ) } if len ( o . Git Refs ) = = 0 { return errors . New ( " " ) } seen : = map [ string ] sets . String { } for _ , ref : = range o . Git Refs { if _ , seen Org : = seen [ ref . Org ] ; seen Org { if seen [ ref . Org ] . Has ( ref . Repo ) { return errors . New ( " " ) } seen [ ref . Org ] . Insert ( ref . Repo ) } else { seen [ ref . Org ] = sets . New String ( ref . Repo ) } } return nil } 
func ( o * Options ) Complete ( args [ ] string ) { o . Git Refs = o . refs . git Refs o . Key Files = o . keys . data for _ , ref : = range o . Git Refs { alias , err : = o . clone Path . Execute ( Org Repo { Org : ref . Org , Repo : ref . Repo } ) if err ! = nil { panic ( err ) } ref . Path Alias = alias alias , err = o . clone URI . Execute ( Org Repo { Org : ref . Org , Repo : ref . Repo } ) if err ! = nil { panic ( err ) } ref . Clone URI = alias } } 
func ( o * Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . Src Root , " " , " " , " " ) fs . String Var ( & o . Log , " " , " " , " " ) fs . String Var ( & o . Git User Name , " " , Default Git User Name , " " ) fs . String Var ( & o . Git User Email , " " , Default Git User Email , " " ) fs . Var ( & o . refs , " " , " " ) fs . Var ( & o . keys , " " , " " ) fs . Var ( & o . clone Path , " " , " " ) fs . Var ( & o . clone URI , " " , " " ) fs . Int Var ( & o . Max Parallel Workers , " " , 0 , " " ) fs . String Var ( & o . Cookie Path , " " , " " , " " ) } 
func ( r * git Refs ) Set ( value string ) error { git Ref , err : = Parse Refs ( value ) if err ! = nil { return err } r . git Refs = append ( r . git Refs , * git Ref ) return nil } 
func ( r * string Slice ) Set ( value string ) error { r . data = append ( r . data , value ) return nil } 
func ( a * org Repo Format ) Set ( value string ) error { templ , err : = template . New ( " " ) . Parse ( value ) if err ! = nil { return err } a . raw = value a . format = templ return nil } 
func ensure ( binary , install string ) error { if _ , err : = exec . Look Path ( binary ) ; err ! = nil { return fmt . Errorf ( " " , binary , install ) } return nil } 
func output ( args . . . string ) ( string , error ) { cmd : = exec . Command ( args [ 0 ] , args [ 1 : ] . . . ) cmd . Stderr = os . Stderr cmd . Stdin = os . Stdin b , err : = cmd . Output ( ) return strings . Trim Space ( string ( b ) ) , err } 
func projects ( max int ) ( [ ] string , error ) { out , err : = output ( " " , " " , " " , fmt . Sprintf ( " " , max ) , " " ) if err ! = nil { return nil , err } return strings . Split ( out , " \n " ) , nil } 
func select Project ( choice string ) ( string , error ) { fmt . Print ( " " ) who , err : = current Account ( ) if err ! = nil { logrus . Warn ( " " ) return " " , err } fmt . Println ( who ) var projs [ ] string if choice = = " " { fmt . Printf ( " " , who ) fmt . Println ( ) const max = 2 0 projs , err = projects ( max ) for _ , proj : = range projs { fmt . Println ( " " , proj ) } if err ! = nil { return " " , fmt . Errorf ( " " , err ) } if len ( projs ) = = 0 { fmt . Println ( " " ) return " " , errors . New ( " " ) } if len ( projs ) = = max { fmt . Println ( " " ) fmt . Println ( " " ) } def , err : = current Project ( ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } fmt . Printf ( " " , def ) fmt . Scanln ( & choice ) } } } } fmt . Printf ( " " , who , choice ) fmt . Println ( ) } return choice , nil } 
func current Clusters ( proj string ) ( map [ string ] cluster , error ) { clusters , err : = output ( " " , " " , " " , " " , " " + proj , " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } options : = map [ string ] cluster { } for _ , line : = range strings . Split ( clusters , " \n " ) { if len ( line ) = = 0 { continue } parts : = strings . Split ( line , " \t " ) if len ( parts ) ! = 2 { return nil , fmt . Errorf ( " " , line ) } c : = cluster { name : parts [ 0 ] , zone : parts [ 1 ] , project : proj } options [ c . name ] = c } return options , nil } 
func create Cluster ( proj , choice string ) ( * cluster , error ) { const def = " " if choice = = " " { fmt . Printf ( " " , def ) fmt . Scanln ( & choice ) if choice = = " " { choice = def } } cmd : = exec . Command ( " " , " " , " " , " " , choice ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr if err : = cmd . Run ( ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } out , err : = output ( " " , " " , " " , " " , choice , " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } parts : = strings . Split ( out , " \t " ) if len ( parts ) ! = 2 { return nil , fmt . Errorf ( " " , out ) } return & cluster { name : parts [ 0 ] , zone : parts [ 1 ] , project : proj } , nil } 
func create Context ( co context Options ) ( string , error ) { proj , err : = select Project ( co . project ) if err ! = nil { logrus . Info ( " " ) return " " , fmt . Errorf ( " " , err ) } fmt . Printf ( " " , proj ) fmt . Println ( ) clusters , err : = current Clusters ( proj ) if err ! = nil { return " " , fmt . Errorf ( " " , proj , err ) } for name : = range clusters { fmt . Println ( " " , name ) } if len ( clusters ) = = 0 { fmt . Println ( " " ) } var choice string create : = co . create reuse : = co . reuse switch { case create ! = " " & & reuse ! = " " : return " " , errors . New ( " " ) case create ! = " " : fmt . Println ( " " + create + " " ) choice = " " case reuse ! = " " : fmt . Println ( " " + reuse + " " ) choice = reuse default : fmt . Print ( " " ) fmt . Scanln ( & choice ) } if choice = = " " | | choice = = " " { cluster , err : = create Cluster ( proj , create ) if err ! = nil { return " " , fmt . Errorf ( " " , proj , err ) } return cluster . context ( ) , nil } cluster , ok : = clusters [ choice ] if ! ok { return " " , fmt . Errorf ( " " , choice ) } cmd : = exec . Command ( " " , " " , " " , " " , cluster . name , " " + cluster . project , " " + cluster . zone ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr if err : = cmd . Run ( ) ; err ! = nil { return " " , fmt . Errorf ( " " , err ) } return cluster . context ( ) , nil } 
func context Config ( ) ( clientcmd . Client Config Loader , * clientcmdapi . Config , error ) { if err : = ensure Kubectl ( ) ; err ! = nil { fmt . Println ( " " ) fmt . Println ( " " , err ) if gerr : = ensure Gcloud ( ) ; gerr ! = nil { fmt . Println ( " " , gerr ) } return nil , nil , errors . New ( " " ) } l : = clientcmd . New Default Client Config Loading Rules ( ) c , err : = l . Load ( ) return l , c , err } 
func select Context ( co context Options ) ( string , error ) { fmt . Println ( " " ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } var ctxs [ ] string for ctx : = range cfg . Contexts { ctxs = append ( ctxs , ctx ) } sort . Strings ( ctxs ) for idx , ctx : = range ctxs { options [ idx ] = ctx if ctx = = cfg . Current Context { fmt . Printf ( " " , idx , ctx ) } else { fmt . Printf ( " " , idx , ctx ) } fmt . Println ( ) } fmt . Println ( ) choice : = co . context switch { case choice ! = " " : fmt . Println ( " " + choice + " " ) case co . create ! = " " | | co . reuse ! = " " : choice = " " fmt . Println ( " " ) default : fmt . Print ( " " ) fmt . Scanln ( & choice ) } if choice = = " " | | choice = = " " | | choice = = " " | | choice = = " " { ctx , err : = create Context ( co ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return ctx , nil } if _ , ok : = cfg . Contexts [ choice ] ; ok { return choice , nil } idx , err : = strconv . Atoi ( choice ) if err ! = nil { return " " , fmt . Errorf ( " " , choice ) } if ctx , ok : = options [ idx ] ; ok { return ctx , nil } return " " , fmt . Errorf ( " " , idx ) } 
func apply Create ( ctx string , args . . . string ) error { create : = exec . Command ( " " , append ( [ ] string { " " , " " , " " } , args . . . ) . . . ) create . Stderr = os . Stderr obj , err : = create . Stdout Pipe ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = create . Start ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = apply ( ctx , obj ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = create . Wait ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Filter Presubmits ( honor Ok To Test bool , git Hub Client Git Hub Client , body string , pr * github . Pull Request , presubmits [ ] config . Presubmit , logger * logrus . Entry ) ( [ ] config . Presubmit , [ ] config . Presubmit , error ) { org , repo , sha : = pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , pr . Head . SHA filter , err : = presubmit Filter ( honor Ok To Test , git Hub Client , body , org , repo , sha , logger ) if err ! = nil { return nil , nil , err } number , branch : = pr . Number , pr . Base . Ref changes : = config . New Git Hub Deferred Changed Files Provider ( git Hub Client , org , repo , number ) to Trigger , to Skip Superset , err : = pjutil . Filter Presubmits ( filter , changes , branch , presubmits , logger ) if err ! = nil { return nil , nil , err } to Skip : = determine Skipped Presubmits ( to Trigger , to Skip Superset , logger ) return to Trigger , to Skip , err } 
func determine Skipped Presubmits ( to Trigger , to Skip Superset [ ] config . Presubmit , logger * logrus . Entry ) [ ] config . Presubmit { triggered Contexts : = sets . New String ( ) for _ , presubmit : = range to Trigger { triggered Contexts . Insert ( presubmit . Context ) } var to Skip [ ] config . Presubmit for _ , presubmit : = range to Skip Superset { if triggered Contexts . Has ( presubmit . Context ) { logger . With Fields ( logrus . Fields { " " : presubmit . Context , " " : presubmit . Name } ) . Debug ( " " ) continue } to Skip = append ( to Skip , presubmit ) } return to Skip } 
func Diff Profiles ( before [ ] * cover . Profile , after [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { var diff [ ] * cover . Profile if len ( before ) ! = len ( after ) { return nil , fmt . Errorf ( " " , len ( before ) , len ( after ) ) } for i , before Profile : = range before { after Profile : = after [ i ] if err : = ensure Profiles Match ( before Profile , after Profile ) ; err ! = nil { return nil , fmt . Errorf ( " " , i , err ) } diff Profile : = cover . Profile { File Name : before Profile . File Name , Mode : before Profile . Mode } for j , before Block : = range before Profile . Blocks { after Block : = after Profile . Blocks [ j ] diff Block : = cover . Profile Block { Start Line : before Block . Start Line , Start Col : before Block . Start Col , End Line : before Block . End Line , End Col : before Block . End Col , Num Stmt : before Block . Num Stmt , Count : after Block . Count - before Block . Count , } diff Profile . Blocks = append ( diff Profile . Blocks , diff Block ) } diff = append ( diff , & diff Profile ) } return diff , nil } 
func Dispatch ( plugin plugins . Plugin , DB * Influx DB , issues chan sql . Issue , events Comments Channel chan interface { } ) { for { var points [ ] plugins . Point select { case issue , ok : = < - issues : if ! ok { return } points = plugin . Receive Issue ( issue ) case event , ok : = < - events Comments Channel : if ! ok { return } switch event : = event . ( type ) { case sql . Issue Event : points = plugin . Receive Issue Event ( event ) case sql . Comment : points = plugin . Receive Comment ( event ) default : glog . Fatal ( " " , event ) } } for _ , point : = range points { if err : = DB . Push ( point . Tags , point . Values , point . Date ) ; err ! = nil { glog . Fatal ( " " , err ) } } } } 
func ( config * transform Config ) run ( plugin plugins . Plugin ) error { if err : = config . Check Root Flags ( ) ; err ! = nil { return err } mysqldb , err : = config . My SQLConfig . Create Database ( ) if err ! = nil { return err } influxdb , err : = config . Influx Config . Create Database ( map [ string ] string { " " : config . repository } , config . metric Name ) if err ! = nil { return err } fetcher : = New Fetcher ( config . repository ) ticker : = time . Tick ( time . Hour / time . Duration ( config . frequency ) ) for { } if err : = influxdb . Push Batch Points ( ) ; err ! = nil { return err } if config . once { break } < - ticker } return nil } 
func ( a * Author Filter Plugin Wrapper ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . String Slice Var ( & a . ignored Authors , " " , [ ] string { } , " " ) } 
func ( a * Author Filter Plugin Wrapper ) Receive Issue ( issue sql . Issue ) [ ] Point { if a . match ( issue . User ) { return nil } return a . plugin . Receive Issue ( issue ) } 
func ( a * Author Filter Plugin Wrapper ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { if event . Actor ! = nil & & a . match ( * event . Actor ) { return nil } return a . plugin . Receive Issue Event ( event ) } 
func ( a * Author Filter Plugin Wrapper ) Receive Comment ( comment sql . Comment ) [ ] Point { if a . match ( comment . User ) { return nil } return a . plugin . Receive Comment ( comment ) } 
func ( c * Client ) Create Issue ( org , repo , title , body string , labels , assignees [ ] string ) ( * github . Issue , error ) { glog . Infof ( " \n " , c . dry Run , title , labels , assignees ) if c . dry Run { return nil , nil } issue : = & github . Issue Request { Title : & title , Body : & body , } if len ( labels ) > 0 { issue . Labels = & labels } if len ( assignees ) > 0 { issue . Assignees = & assignees } var result * github . Issue _ , err : = c . retry ( fmt . Sprintf ( " " , title ) , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . issue Service . Create ( context . Background ( ) , org , repo , issue ) return resp , err } , ) return result , err } 
func ( c * Client ) Create Status ( owner , repo , ref string , status * github . Repo Status ) ( * github . Repo Status , error ) { glog . Infof ( " " , c . dry Run , ref , * status . Context , * status . State ) if c . dry Run { return nil , nil } var result * github . Repo Status msg : = fmt . Sprintf ( " " , ref ) _ , err : = c . retry ( msg , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . repo Service . Create Status ( context . Background ( ) , owner , repo , ref , status ) return resp , err } ) return result , err } 
func ( c * Client ) For Each PR ( owner , repo string , opts * github . Pull Request List Options , continue On Error bool , munge PR PRMunge Func ) error { var last Page int if err = = nil { for _ , pr : = range list { if pr = = nil { glog . Errorln ( " " ) } if munge Err : = munge PR ( pr ) ; munge Err ! = nil { if pr . Number = = nil { munge Err = fmt . Errorf ( " " , munge Err ) } else { munge Err = fmt . Errorf ( " " , * pr . Number , munge Err ) } if ! continue On Error { return nil , resp , & retry Abort { munge Err } } glog . Errorf ( " \n " , munge Err ) } } if resp . Last Page > 0 { last Page = resp . Last Page } glog . Infof ( " \n " , opts . List Options . Page , last Page ) } return nil , resp , err } , ) return err } 
func ( c * Client ) Get Collaborators ( org , repo string ) ( [ ] * github . User , error ) { opts : = & github . List Collaborators Options { } collaborators , err : = c . depaginate ( fmt . Sprintf ( " " , org , repo ) , & opts . List Options , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err : = c . repo Service . List Collaborators ( context . Background ( ) , org , repo , opts ) var interface List [ ] interface { } if err = = nil { interface List = make ( [ ] interface { } , 0 , len ( page ) ) for _ , user : = range page { interface List = append ( interface List , user ) } } return interface List , resp , err } , ) result : = make ( [ ] * github . User , 0 , len ( collaborators ) ) for _ , user : = range collaborators { result = append ( result , user . ( * github . User ) ) } return result , err } 
func ( c * Client ) Get Combined Status ( owner , repo , ref string ) ( * github . Combined Status , error ) { var result * github . Combined Status list Opts : = & github . List Options { } statuses , err : = c . depaginate ( fmt . Sprintf ( " " , ref ) , list Opts , func ( ) ( [ ] interface { } , * github . Response , error ) { combined , resp , err : = c . repo Service . Get Combined Status ( context . Background ( ) , owner , repo , ref , list Opts , ) if result = = nil { result = combined } var interface List [ ] interface { } if err = = nil { interface List = make ( [ ] interface { } , 0 , len ( combined . Statuses ) ) for _ , status : = range combined . Statuses { interface List = append ( interface List , status ) } } return interface List , resp , err } , ) if result ! = nil { result . Statuses = make ( [ ] github . Repo Status , 0 , len ( statuses ) ) for _ , status : = range statuses { result . Statuses = append ( result . Statuses , status . ( github . Repo Status ) ) } } return result , err } 
func ( c * Client ) Get Issues ( org , repo string , opts * github . Issue List By Repo Options ) ( [ ] * github . Issue , error ) { issues , err : = c . depaginate ( fmt . Sprintf ( " " , org , repo ) , & opts . List Options , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err : = c . issue Service . List By Repo ( context . Background ( ) , org , repo , opts ) var interface List [ ] interface { } if err = = nil { interface List = make ( [ ] interface { } , 0 , len ( page ) ) for _ , issue : = range page { interface List = append ( interface List , issue ) } } return interface List , resp , err } , ) result : = make ( [ ] * github . Issue , 0 , len ( issues ) ) for _ , issue : = range issues { result = append ( result , issue . ( * github . Issue ) ) } return result , err } 
func ( c * Client ) Get Repo Labels ( org , repo string ) ( [ ] * github . Label , error ) { opts : = & github . List Options { } labels , err : = c . depaginate ( fmt . Sprintf ( " " , org , repo ) , opts , func ( ) ( [ ] interface { } , * github . Response , error ) { page , resp , err : = c . issue Service . List Labels ( context . Background ( ) , org , repo , opts ) var interface List [ ] interface { } if err = = nil { interface List = make ( [ ] interface { } , 0 , len ( page ) ) for _ , label : = range page { interface List = append ( interface List , label ) } } return interface List , resp , err } , ) result : = make ( [ ] * github . Label , 0 , len ( labels ) ) for _ , label : = range labels { result = append ( result , label . ( * github . Label ) ) } return result , err } 
func ( c * Client ) Get User ( login string ) ( * github . User , error ) { var result * github . User _ , err : = c . retry ( fmt . Sprintf ( " " , login ) , func ( ) ( * github . Response , error ) { var resp * github . Response var err error result , resp , err = c . user Service . Get ( context . Background ( ) , login ) return resp , err } , ) return result , err } 
func check Config Validity ( ) error { glog . Info ( " " ) if * node Name = = " " { return fmt . Errorf ( " " ) } if * gcs Path = = " " { return fmt . Errorf ( " " ) } if _ , err : = os . Stat ( * gcloud Auth File Path ) ; err ! = nil { return fmt . Errorf ( " " , err ) } else { glog . Infof ( " \n " , * gcloud Auth File Path ) cmd : = exec . Command ( " " , " " , " " , " " + * gcloud Auth File Path ) var stderr , stdout bytes . Buffer cmd . Stderr , cmd . Stdout = & stderr , & stdout err = cmd . Run ( ) glog . Infof ( " \n \n " , stdout . String ( ) ) glog . Infof ( " \n \n " , stderr . String ( ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } } return nil } 
func create Systemd Logfile ( service string , output Mode string , output Dir string ) error { if service = = " " { journal Cmd Args = append ( journal Cmd Args , " " ) } else { journal Cmd Args = append ( journal Cmd Args , " " , fmt . Sprintf ( " " , service ) ) } cmd : = exec . Command ( " " , journal Cmd Args . . . ) if err ! = nil { return fmt . Errorf ( " " , service , err ) } logfile : = filepath . Join ( output Dir , service + " " ) if err : = ioutil . Write File ( logfile , output , 0 4 4 4 ) ; err ! = nil { return fmt . Errorf ( " " , service , err ) } return nil } 
func create Full Systemd Logfile ( output Dir string ) error { cmd : = exec . Command ( " " , " " , " " , * journal Path ) if err ! = nil { return fmt . Errorf ( " " , err ) } logfile : = filepath . Join ( output Dir , " " ) if err : = ioutil . Write File ( logfile , output , 0 4 4 4 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func create Systemd Logfiles ( output Dir string ) { services : = append ( systemd Services , node Systemd Services . . . ) for _ , service : = range services { if err : = create Systemd Logfile ( service , " " , output Dir ) ; err ! = nil { glog . Warningf ( " " , err ) } } } } if * dump Systemd Journal { if err : = create Full Systemd Logfile ( output Dir ) ; err ! = nil { glog . Warningf ( " " , err ) } } } 
func prepare Logfiles ( log Dir string ) { glog . Info ( " " ) logfiles : = node Logs [ : ] switch * cloud Provider { case " " , " " : logfiles = append ( logfiles , gce Logs . . . ) case " " : logfiles = append ( logfiles , aws Logs . . . ) default : glog . Errorf ( " " , * cloud Provider ) } } create Systemd Logfiles ( log Dir ) } else { glog . Infof ( " " , err ) logfiles = append ( logfiles , kernel Log ) logfiles = append ( logfiles , initd Logs . . . ) logfiles = append ( logfiles , supervisord Logs . . . ) } cmd : = exec . Command ( " " , " " , fmt . Sprintf ( " " , logfile Full Path , log Dir ) ) if err : = cmd . Run ( ) ; err ! = nil { glog . Warningf ( " " , logfile Full Path , err ) } } } 
func write Success Marker File ( ) error { marker File Path : = * gcs Path + " " + * node Name + " " cmd : = exec . Command ( " " , " " , " " , " " , " " , " " , marker File Path ) stdin , err : = cmd . Stdin Pipe ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } io . Write String ( stdin , " " ) stdin . Close ( ) if err = cmd . Run ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Make Command ( ) * cobra . Command { flags : = & flags { } cmd : = & cobra . Command { Use : " " , Short : " " , Long : `Summarize coverage profile and produce the result in junit xml format . Summary done at per -file and per -package level . Any coverage below coverage -threshold will be marked with a <failure > tag in the xml produced . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . String Var P ( & flags . output File , " " , " " , " " , " " ) cmd . Flags ( ) . Float 3 2Var P ( & flags . threshold , " " , " " , . 8 , " " ) return cmd } 
func ( c * Configuration ) MDYAMLEnabled ( org , repo string ) bool { full : = fmt . Sprintf ( " " , org , repo ) for _ , elem : = range c . Owners . MDYAMLRepos { if elem = = org | | elem = = full { return true } } return false } 
func ( r Require Matching Label ) validate ( ) error { if r . Org = = " " { return errors . New ( " " ) } if strings . Contains ( r . Repo , " " ) { return errors . New ( " " ) } if r . Regexp = = " " { return errors . New ( " " ) } if r . Missing Label = = " " { return errors . New ( " " ) } if r . Grace Period = = " " { return errors . New ( " " ) } if ! r . PRs & & ! r . Issues { return errors . New ( " " ) } if ! r . PRs & & r . Branch ! = " " { return errors . New ( " " ) } if r . Re . Match String ( r . Missing Label ) { return errors . New ( " " ) } return nil } 
func warn Deprecated ( last * time . Time , freq time . Duration , msg string ) { fresh : = time . Now ( ) . Sub ( * last ) < = freq warn Lock . RUnlock ( ) if fresh { } defer warn Lock . Unlock ( ) now : = time . Now ( ) if now . Sub ( * last ) < = freq { } * last = now logrus . Warn ( msg ) } 
func ( r Require Matching Label ) Describe ( ) string { str : = & strings . Builder { } fmt . Fprintf ( str , " " , r . Missing Label ) if r . Missing Comment = = " " { fmt . Fprint ( str , " " ) } else { fmt . Fprint ( str , " " ) } if r . Issues { fmt . Fprint ( str , " " ) if r . PRs { fmt . Fprint ( str , " " ) } } if r . PRs { if r . Branch ! = " " { fmt . Fprintf ( str , " " , r . Branch ) } fmt . Fprint ( str , " " ) } if r . Repo = = " " { fmt . Fprintf ( str , " " , r . Org ) } else { fmt . Fprintf ( str , " " , r . Org , r . Repo ) } fmt . Fprintf ( str , " " , r . Regexp ) return str . String ( ) } 
func ( c * Configuration ) Trigger For ( org , repo string ) Trigger { for _ , tr : = range c . Triggers { for _ , r : = range tr . Repos { if r = = org | | r = = fmt . Sprintf ( " " , org , repo ) { return tr } } } return Trigger { } } 
func ( c * Configuration ) Enabled Repos For Plugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins : = range c . Plugins { found : = false for _ , candidate : = range plugins { if candidate = = plugin { found = true break } } if found { if strings . Contains ( repo , " " ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return } 
func ( c * Configuration ) Enabled Repos For External Plugin ( plugin string ) ( orgs , repos [ ] string ) { for repo , plugins : = range c . External Plugins { found : = false for _ , candidate : = range plugins { if candidate . Name = = plugin { found = true break } } if found { if strings . Contains ( repo , " " ) { repos = append ( repos , repo ) } else { orgs = append ( orgs , repo ) } } } return } 
func ( c * Config Updater ) Set Defaults ( ) { if len ( c . Maps ) = = 0 { cf : = c . Config File if cf = = " " { cf = " " } else { logrus . Warnf ( `config _file is deprecated , please switch to "maps " : { " %s " : "config " } before July 2 0 1 8 ` , cf ) } pf : = c . Plugin File if pf = = " " { pf = " " } else { logrus . Warnf ( `plugin _file is deprecated , please switch to "maps " : { " %s " : "plugins " } before July 2 0 1 8 ` , pf ) } c . Maps = map [ string ] Config Map Spec { cf : { Name : " " , } , pf : { Name : " " , } , } } for name , spec : = range c . Maps { spec . Namespaces = append ( [ ] string { spec . Namespace } , spec . Additional Namespaces . . . ) c . Maps [ name ] = spec } } 
func validate Plugins ( plugins map [ string ] [ ] string ) error { var errors [ ] string for _ , configuration : = range plugins { for _ , plugin : = range configuration { if _ , ok : = plugin Help [ plugin ] ; ! ok { errors = append ( errors , fmt . Sprintf ( " " , plugin ) ) } } } for repo , repo Config : = range plugins { if strings . Contains ( repo , " " ) { org : = strings . Split ( repo , " " ) [ 0 ] if dupes : = find Duplicated Plugin Config ( repo Config , plugins [ org ] ) ; len ( dupes ) > 0 { errors = append ( errors , fmt . Sprintf ( " " , dupes , repo , org ) ) } } } if len ( errors ) > 0 { return fmt . Errorf ( " \n \t " , strings . Join ( errors , " \n \t " ) ) } return nil } 
func New Reporter ( cookiefile Path string , projects map [ string ] [ ] string , lister pjlister . Prow Job Lister ) ( * Client , error ) { gc , err : = client . New Client ( projects ) if err ! = nil { return nil , err } gc . Start ( cookiefile Path ) return & Client { gc : gc , lister : lister , } , nil } 
func ( c * Client ) Should Report ( pj * v 1 . Prow Job ) bool { if pj . Status . State = = v 1 . Triggered State | | pj . Status . State = = v 1 . Pending State { return false } if pj . Status . State = = v 1 . Aborted State { return false } return false } if pj . Object Meta . Labels [ client . Gerrit Report Label ] = = " " { } else { selector [ client . Gerrit Report Label ] = pj . Object Meta . Labels [ client . Gerrit Report Label ] } pjs , err : = c . lister . List ( selector . As Selector ( ) ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , selector ) return false } for _ , pjob : = range pjs { if pjob . Status . State = = v 1 . Triggered State | | pjob . Status . State = = v 1 . Pending State { return false } } return true } 
func ( c * Client ) Report ( pj * v 1 . Prow Job ) ( [ ] * v 1 . Prow Job , error ) { logger : = logrus . With Field ( " " , pj ) client Gerrit Revision : = client . Gerrit Revision client Gerrit ID : = client . Gerrit ID client Gerrit Instance : = client . Gerrit Instance pj Type Label : = kube . Prow Job Type Label gerrit Report Label : = client . Gerrit Report Label selector : = labels . Set { client Gerrit Revision : pj . Object Meta . Labels [ client Gerrit Revision ] , pj Type Label : pj . Object Meta . Labels [ pj Type Label ] , } if pj . Object Meta . Labels [ gerrit Report Label ] = = " " { } else { selector [ gerrit Report Label ] = pj . Object Meta . Labels [ gerrit Report Label ] } if err ! = nil { logger . With Error ( err ) . Errorf ( " " , selector ) return nil , err } message : = " " var to Report Jobs [ ] * v 1 . Prow Job most Recent Job : = map [ string ] * v 1 . Prow Job { } for _ , pj On Revision With Same Label : = range pjs On Revision With Same Label { job , ok : = most Recent Job [ pj On Revision With Same Label . Spec . Job ] if ! ok | | job . Creation Timestamp . Time . Before ( pj On Revision With Same Label . Creation Timestamp . Time ) { most Recent Job [ pj On Revision With Same Label . Spec . Job ] = pj On Revision With Same Label } } for _ , pj On Revision With Same Label : = range most Recent Job { if pj On Revision With Same Label . Status . State = = v 1 . Aborted State { continue } to Report Jobs = append ( to Report Jobs , pj On Revision With Same Label ) check Or X : = " if pj On Revision With Same Label . Status . State = = v 1 . Success State { check Or X = " success + + } message + = fmt . Sprintf ( " \n \n " , check Or X , pj On Revision With Same Label . Spec . Job , strings . To Upper ( string ( pj On Revision With Same Label . Status . State ) ) , pj On Revision With Same Label . Status . URL ) } total : = len ( to Report Jobs ) if total < = 0 { return nil , nil } message = fmt . Sprintf ( " " , success , total , message ) gerrit Instance : = pj . Object Meta . Annotations [ client Gerrit Instance ] gerrit Revision : = pj . Object Meta . Labels [ client Gerrit Revision ] report Label : = client . Code Review if val , ok : = pj . Object Meta . Labels [ client . Gerrit Report Label ] ; ok { report Label = val } vote : = client . LBTM if success = = total { vote = client . LGTM } review Labels : = map [ string ] string { report Label : vote } logger . Infof ( " " , gerrit Instance , gerrit ID , message ) if err : = c . gc . Set Review ( gerrit Instance , gerrit ID , gerrit Revision , message , review Labels ) ; err ! = nil { logger . With Error ( err ) . Errorf ( " " , report Label , gerrit ID ) if err : = c . gc . Set Review ( gerrit Instance , gerrit ID , gerrit Revision , message , nil ) ; err ! = nil { logger . With Error ( err ) . Errorf ( " " , gerrit ID ) return nil , err } } logger . Infof ( " " , to Report Jobs ) return to Report Jobs , nil } 
func Run ( refs prowapi . Refs , dir , git User Name , git User Email , cookie Path string , env [ ] string ) Record { logrus . With Fields ( logrus . Fields { " " : refs } ) . Info ( " " ) record : = Record { Refs : refs } logrus . With Fields ( logrus . Fields { " " : formatted Command , " " : output , " " : err } ) . Info ( " " ) message : = " " if err ! = nil { message = err . Error ( ) record . Failed = true } record . Commands = append ( record . Commands , Command { Command : formatted Command , Output : output , Error : message } ) if err ! = nil { return err } } return nil } g : = git Ctx For Refs ( refs , dir , env ) if err : = run Commands ( g . commands For Base Ref ( refs , git User Name , git User Email , cookie Path ) ) ; err ! = nil { return record } timestamp , err : = g . git Head Timestamp ( ) if err ! = nil { timestamp = int ( time . Now ( ) . Unix ( ) ) } if err : = run Commands ( g . commands For Pull Refs ( refs , timestamp ) ) ; err ! = nil { return record } final SHA , err : = g . git Rev Parse ( ) if err ! = nil { logrus . With Error ( err ) . Warnf ( " " , refs ) } else { record . Final SHA = final SHA } return record } 
func Path For Refs ( base Dir string , refs prowapi . Refs ) string { var clone Path string if refs . Path Alias ! = " " { clone Path = refs . Path Alias } else { clone Path = fmt . Sprintf ( " " , refs . Org , refs . Repo ) } return fmt . Sprintf ( " " , base Dir , clone Path ) } 
func git Ctx For Refs ( refs prowapi . Refs , base Dir string , env [ ] string ) git Ctx { g : = git Ctx { clone Dir : Path For Refs ( base Dir , refs ) , env : env , repository URI : fmt . Sprintf ( " " , refs . Org , refs . Repo ) , } if refs . Clone URI ! = " " { g . repository URI = refs . Clone URI } return g } 
func ( g * git Ctx ) commands For Base Ref ( refs prowapi . Refs , git User Name , git User Email , cookie Path string ) [ ] clone Command { commands : = [ ] clone Command { { dir : " " , env : g . env , command : " " , args : [ ] string { " " , g . clone Dir } } } commands = append ( commands , g . git Command ( " " ) ) if git User Name ! = " " { commands = append ( commands , g . git Command ( " " , " " , git User Name ) ) } if git User Email ! = " " { commands = append ( commands , g . git Command ( " " , " " , git User Email ) ) } if cookie Path ! = " " { commands = append ( commands , g . git Command ( " " , " " , cookie Path ) ) } commands = append ( commands , g . git Command ( " " , g . repository URI , " " , " " ) ) commands = append ( commands , g . git Command ( " " , g . repository URI , refs . Base Ref ) ) var target string if refs . Base SHA ! = " " { target = refs . Base SHA } else { target = " " } commands = append ( commands , g . git Command ( " " , " " , refs . Base Ref , target ) ) commands = append ( commands , g . git Command ( " " , refs . Base Ref ) ) return commands } 
func ( g * git Ctx ) git Head Timestamp ( ) ( int , error ) { git Show Command : = g . git Command ( " " , " " , " " , " " ) _ , git Output , err : = git Show Command . run ( ) if err ! = nil { logrus . With Error ( err ) . Debug ( " " ) return 0 , err } timestamp , conv Err : = strconv . Atoi ( string ( git Output ) ) if conv Err ! = nil { logrus . With Error ( conv Err ) . Errorf ( " " , git Output ) return 0 , conv Err } return timestamp , nil } 
func git Timestamp Envs ( timestamp int ) [ ] string { return [ ] string { fmt . Sprintf ( " " , timestamp ) , fmt . Sprintf ( " " , timestamp ) , } } 
func ( g * git Ctx ) git Rev Parse ( ) ( string , error ) { git Rev Parse Command : = g . git Command ( " " , " " ) _ , commit , err : = git Rev Parse Command . run ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return " " , err } return strings . Trim Space ( commit ) , nil } 
func ( g * git Ctx ) commands For Pull Refs ( refs prowapi . Refs , fake Timestamp int ) [ ] clone Command { var commands [ ] clone Command for _ , pr Ref : = range refs . Pulls { ref : = fmt . Sprintf ( " " , pr Ref . Number ) if pr Ref . Ref ! = " " { ref = pr Ref . Ref } commands = append ( commands , g . git Command ( " " , g . repository URI , ref ) ) var pr Checkout string if pr Ref . SHA ! = " " { pr Checkout = pr Ref . SHA } else { pr Checkout = " " } fake Timestamp + + git Merge Command : = g . git Command ( " " , " " , pr Checkout ) git Merge Command . env = append ( git Merge Command . env , git Timestamp Envs ( fake Timestamp ) . . . ) commands = append ( commands , git Merge Command ) } } return commands } 
func Produce Cov List ( profiles [ ] * cover . Profile ) * Coverage List { cov List : = new Coverage List ( " " ) for _ , prof : = range profiles { cov List . Group = append ( cov List . Group , summarize Blocks ( prof ) ) } return cov List } 
func pop Random ( set sets . String ) string { list : = set . List ( ) sort . Strings ( list ) sel : = list [ rand . Intn ( len ( list ) ) ] set . Delete ( sel ) return sel } 
func ( o * Experimental Kubernetes Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . build Cluster , " " , " " , " " ) fs . String Var ( & o . kubeconfig , " " , " " , " " ) fs . String Var ( & o . Deck URI , " " , " " , " " ) } 
func ( o * Experimental Kubernetes Options ) Validate ( dry Run bool ) error { if dry Run & & o . Deck URI = = " " { return errors . New ( " " ) } if o . Deck URI ! = " " { if _ , err : = url . Parse Request URI ( o . Deck URI ) ; err ! = nil { return fmt . Errorf ( " " , o . Deck URI ) } } if o . kubeconfig ! = " " { if _ , err : = os . Stat ( o . kubeconfig ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } if o . kubeconfig ! = " " & & o . build Cluster ! = " " { return errors . New ( " " ) } return nil } 
func ( o * Experimental Kubernetes Options ) resolve ( dry Run bool ) ( err error ) { if o . resolved { return nil } o . dry Run = dry Run if dry Run { return nil } cluster Configs , err : = kube . Load Cluster Configs ( o . kubeconfig , o . build Cluster ) if err ! = nil { return fmt . Errorf ( " " , o . kubeconfig , o . build Cluster , err ) } clients : = map [ string ] kubernetes . Interface { } for context , config : = range cluster Configs { client , err : = kubernetes . New For Config ( & config ) if err ! = nil { return fmt . Errorf ( " " , context , err ) } clients [ context ] = client } local Cfg : = cluster Configs [ kube . In Cluster Context ] pj Client , err : = prow . New For Config ( & local Cfg ) if err ! = nil { return err } o . prow Job Clientset = pj Client o . kubernetes Clients By Context = clients o . resolved = true return nil } 
func ( o * Experimental Kubernetes Options ) Prow Job Clientset ( namespace string , dry Run bool ) ( prow Job Clientset prow . Interface , err error ) { if err : = o . resolve ( dry Run ) ; err ! = nil { return nil , err } if o . dry Run { return nil , errors . New ( " " ) } return o . prow Job Clientset , nil } 
func ( o * Experimental Kubernetes Options ) Prow Job Client ( namespace string , dry Run bool ) ( prow Job Client prowv 1 . Prow Job Interface , err error ) { if err : = o . resolve ( dry Run ) ; err ! = nil { return nil , err } if o . dry Run { return kube . New Dry Run Prow Job Client ( o . Deck URI ) , nil } return o . prow Job Clientset . Prow V 1 ( ) . Prow Jobs ( namespace ) , nil } 
func ( o * Experimental Kubernetes Options ) Infrastructure Cluster Client ( dry Run bool ) ( kubernetes Client kubernetes . Interface , err error ) { if err : = o . resolve ( dry Run ) ; err ! = nil { return nil , err } if o . dry Run { return nil , errors . New ( " " ) } return o . kubernetes Clients By Context [ kube . In Cluster Context ] , nil } 
func ( o * Experimental Kubernetes Options ) Build Cluster Clients ( namespace string , dry Run bool ) ( build Cluster Clients map [ string ] corev 1 . Pod Interface , err error ) { if err : = o . resolve ( dry Run ) ; err ! = nil { return nil , err } if o . dry Run { return nil , errors . New ( " " ) } build Clients : = map [ string ] corev 1 . Pod Interface { } for context , client : = range o . kubernetes Clients By Context { build Clients [ context ] = client . Core V 1 ( ) . Pods ( namespace ) } return build Clients , nil } 
func ( a * Active State ) Age ( t time . Time ) time . Duration { return t . Sub ( a . start Time ) } 
func ( a * Active State ) Receive Event ( event Name , label string , t time . Time ) ( State , bool ) { if a . exit . Match ( event Name , label ) { return & Inactive State { entry : a . exit . Opposite ( ) , } , true } return a , false } 
func ( i * Inactive State ) Receive Event ( event Name , label string , t time . Time ) ( State , bool ) { if i . entry . Match ( event Name , label ) { return & Active State { start Time : t , exit : i . entry . Opposite ( ) , } , true } return i , false } 
func ( m * Multi State ) Active ( ) bool { for _ , state : = range m . states { if ! state . Active ( ) { return false } } return true } 
func ( m * Multi State ) Age ( t time . Time ) time . Duration { min Age : = time . Duration ( 1 < < 6 3 - 1 ) for _ , state : = range m . states { state Age : = state . Age ( t ) if state Age < min Age { min Age = state Age } } return min Age } 
func ( m * Multi State ) Receive Event ( event Name , label string , t time . Time ) ( State , bool ) { one Changed : = false for i : = range m . states { state , changed : = m . states [ i ] . Receive Event ( event Name , label , t ) if changed { one Changed = true } m . states [ i ] = state } return m , one Changed } 
func New State ( states Description string ) State { states : = [ ] State { } if states Description = = " " { } split Description : = strings . Split ( states Description , " " ) for _ , description : = range split Description { description = strings . Trim Space ( description ) if strings . Has Prefix ( description , " " ) { states = append ( states , & Active State { start Time : time . Time { } , exit : New Event Matcher ( description [ 1 : ] ) , } ) } else { states = append ( states , & Inactive State { entry : New Event Matcher ( description ) , } ) } } return & Multi State { states : states } } 
func ( f * shared Informer Factory ) For Resource ( resource schema . Group Version Resource ) ( Generic Informer , error ) { switch resource { } return nil , fmt . Errorf ( " " , resource ) } 
func ( v * version ) Prow Jobs ( ) Prow Job Informer { return & prow Job Informer { factory : v . factory , namespace : v . namespace , tweak List Options : v . tweak List Options } } 
func Item To Resources Config ( i Item ) ( Resources Config , error ) { conf , ok : = i . ( Resources Config ) if ! ok { return Resources Config { } , fmt . Errorf ( " " , i ) } return conf , nil } 
func ( t Type To Resources ) Copy ( ) Type To Resources { n : = Type To Resources { } for k , v : = range t { n [ k ] = v } return n } 
func Make Command ( ) * cobra . Command { flags : = & flags { } cmd : = & cobra . Command { Use : " " , Short : " " , Long : `Given multiple Go coverage files from identical binaries recorded in "count " or "atomic " mode , produces a new Go coverage file in the same mode that counts how many of those coverage profiles hit a block at least once . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { run ( flags , cmd , args ) } , } cmd . Flags ( ) . String Var P ( & flags . Output File , " " , " " , " " , " " ) return cmd } 
func New Controller ( kc * kube . Client , pkcs map [ string ] * kube . Client , ghc Git Hub Client , logger * logrus . Entry , cfg config . Getter , tot URL , selector string , skip Report bool ) ( * Controller , error ) { if logger = = nil { logger = logrus . New Entry ( logrus . Standard Logger ( ) ) } build Clusters : = map [ string ] kube Client { } for alias , client : = range pkcs { build Clusters [ alias ] = kube Client ( client ) } return & Controller { kc : kc , pkcs : build Clusters , ghc : ghc , log : logger , config : cfg , pending Jobs : make ( map [ string ] int ) , tot URL : tot URL , selector : selector , skip Report : skip Report , } , nil } 
func ( c * Controller ) increment Num Pending Jobs ( job string ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . pending Jobs [ job ] + + } 
func ( c * Controller ) set Previous Report State ( pj prowapi . Prow Job ) error { if err ! = nil { return err } if latest PJ . Status . Prev Report States = = nil { latest PJ . Status . Prev Report States = map [ string ] prowapi . Prow Job State { } } latest PJ . Status . Prev Report States [ reporter . Git Hub Reporter Name ] = latest PJ . Status . State _ , err = c . kc . Replace Prow Job ( latest PJ . Object Meta . Name , latest PJ ) return err } 
func ( c * Controller ) Sync ( ) error { pjs , err : = c . kc . List Prow Jobs ( c . selector ) if err ! = nil { return fmt . Errorf ( " " , err ) } selector : = fmt . Sprintf ( " " , kube . Created By Prow ) if len ( c . selector ) > 0 { selector = strings . Join ( [ ] string { c . selector , selector } , " " ) } pm : = map [ string ] kube . Pod { } for alias , client : = range c . pkcs { pods , err : = client . List Pods ( selector ) if err ! = nil { return fmt . Errorf ( " " , alias , err ) } for _ , pod : = range pods { pm [ pod . Object Meta . Name ] = pod } } for _ , pj : = range pjs { if pj . Spec . Agent = = prowapi . Kubernetes Agent { k 8s Jobs = append ( k 8s Jobs , pj ) } } pjs = k 8s Jobs var sync Errs [ ] error if err : = c . terminate Dupes ( pjs , pm ) ; err ! = nil { sync Errs = append ( sync Errs , err ) } c . pjs = pjs c . pj Lock . Unlock ( ) pending Ch , triggered Ch : = pjutil . Partition Active ( pjs ) err Ch : = make ( chan error , len ( pjs ) ) report Ch : = make ( chan prowapi . Prow Job , len ( pjs ) ) c . log . Debugf ( " " , len ( pending Ch ) ) sync Prow Jobs ( c . log , c . sync Pending Job , max Sync Routines , pending Ch , report Ch , err Ch , pm ) c . log . Debugf ( " " , len ( triggered Ch ) ) sync Prow Jobs ( c . log , c . sync Triggered Job , max Sync Routines , triggered Ch , report Ch , err Ch , pm ) close ( err Ch ) close ( report Ch ) for err : = range err Ch { sync Errs = append ( sync Errs , err ) } var report Errs [ ] error if ! c . skip Report { report Template : = c . config ( ) . Plank . Report Template report Types : = c . config ( ) . Git Hub Reporter . Job Types To Report for report : = range report Ch { if err : = reportlib . Report ( c . ghc , report Template , report , report Types ) ; err ! = nil { report Errs = append ( report Errs , err ) c . log . With Fields ( pjutil . Prow Job Fields ( & report ) ) . With Error ( err ) . Warn ( " " ) } } } } if len ( sync Errs ) = = 0 & & len ( report Errs ) = = 0 { return nil } return fmt . Errorf ( " " , sync Errs , report Errs ) } 
func ( c * Controller ) Sync Metrics ( ) { c . pj Lock . RLock ( ) defer c . pj Lock . RUnlock ( ) kube . Gather Prow Job Metrics ( c . pjs ) } 
func ( c * Controller ) terminate Dupes ( pjs [ ] prowapi . Prow Job , pm map [ string ] coreapi . Pod ) error { log : = c . log . With Field ( " " , " " ) return pjutil . Terminate Older Presubmit Jobs ( c . kc , log , pjs , func ( to Cancel prowapi . Prow Job ) error { } else if err : = client . Delete Pod ( pod . Object Meta . Name ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } } return nil } ) } 
func sync Prow Jobs ( l * logrus . Entry , sync Fn sync Fn , max Sync Routines int , jobs < - chan prowapi . Prow Job , reports chan < - prowapi . Prow Job , sync Errors chan < - error , pm map [ string ] coreapi . Pod , ) { goroutines : = max Sync Routines if goroutines > len ( jobs ) { goroutines = len ( jobs ) } wg : = & sync . Wait Group { } wg . Add ( goroutines ) l . Debugf ( " " , goroutines ) for i : = 0 ; i < goroutines ; i + + { go func ( ) { defer wg . Done ( ) for pj : = range jobs { if err : = sync Fn ( pj , pm , reports ) ; err ! = nil { sync Errors < - err } } } ( ) } wg . Wait ( ) } 
func ( c * Controller ) start Pod ( pj prowapi . Prow Job ) ( string , string , error ) { build ID , err : = c . get Build ID ( pj . Spec . Job ) if err ! = nil { return " " , " " , fmt . Errorf ( " " , err ) } pod , err : = decorate . Prow Job To Pod ( pj , build ID ) if err ! = nil { return " " , " " , err } client , ok : = c . pkcs [ pj . Cluster Alias ( ) ] if ! ok { return " " , " " , fmt . Errorf ( " " , pj . Cluster Alias ( ) ) } actual , err : = client . Create Pod ( * pod ) if err ! = nil { return " " , " " , err } return build ID , actual . Object Meta . Name , nil } 
func Dump Profile ( profiles [ ] * cover . Profile , writer io . Writer ) error { if len ( profiles ) = = 0 { return errors . New ( " " ) } if _ , err : = io . Write String ( writer , " " + profiles [ 0 ] . Mode + " \n " ) ; err ! = nil { return err } for _ , profile : = range profiles { for _ , block : = range profile . Blocks { if _ , err : = fmt . Fprintf ( writer , " \n " , profile . File Name , block . Start Line , block . Start Col , block . End Line , block . End Col , block . Num Stmt , block . Count ) ; err ! = nil { return err } } } return nil } 
func blocks Equal ( a cover . Profile Block , b cover . Profile Block ) bool { return a . Start Col = = b . Start Col & & a . Start Line = = b . Start Line & & a . End Col = = b . End Col & & a . End Line = = b . End Line & & a . Num Stmt = = b . Num Stmt } 
func New Prow Job Informer ( client versioned . Interface , namespace string , resync Period time . Duration , indexers cache . Indexers ) cache . Shared Index Informer { return New Filtered Prow Job Informer ( client , namespace , resync Period , indexers , nil ) } 
func New Filtered Prow Job Informer ( client versioned . Interface , namespace string , resync Period time . Duration , indexers cache . Indexers , tweak List Options internalinterfaces . Tweak List Options Func ) cache . Shared Index Informer { return cache . New Shared Index Informer ( & cache . List Watch { List Func : func ( options metav 1 . List Options ) ( runtime . Object , error ) { if tweak List Options ! = nil { tweak List Options ( & options ) } return client . Prow V 1 ( ) . Prow Jobs ( namespace ) . List ( options ) } , Watch Func : func ( options metav 1 . List Options ) ( watch . Interface , error ) { if tweak List Options ! = nil { tweak List Options ( & options ) } return client . Prow V 1 ( ) . Prow Jobs ( namespace ) . Watch ( options ) } , } , & prowjobsv 1 . Prow Job { } , resync Period , indexers , ) } 
func New ( ja * jobs . Job Agent , cfg config . Getter , c * storage . Client , ctx context . Context ) * Spyglass { return & Spyglass { Job Agent : ja , config : cfg , Pod Log Artifact Fetcher : New Pod Log Artifact Fetcher ( ja ) , GCSArtifact Fetcher : New GCSArtifact Fetcher ( c ) , testgrid : & Test Grid { conf : cfg , client : c , ctx : ctx , } , } } 
func ( s * Spyglass ) Lenses ( match Cache map [ string ] [ ] string ) [ ] lenses . Lens { ls : = [ ] lenses . Lens { } for lens Name , matches : = range match Cache { if len ( matches ) = = 0 { continue } lens , err : = lenses . Get Lens ( lens Name ) if err ! = nil { logrus . With Field ( " " , lens ) . With Error ( err ) . Error ( " " ) } else { ls = append ( ls , lens ) } } jconf : = ls [ j ] . Config ( ) iname : = iconf . Name jname : = jconf . Name pi : = iconf . Priority pj : = jconf . Priority if pi = = pj { return iname < jname } return pi < pj } ) return ls } 
func ( s * Spyglass ) Job Path ( src string ) ( string , error ) { src = strings . Trim Suffix ( src , " " ) key Type , key , err : = split Src ( src ) if err ! = nil { return " " , fmt . Errorf ( " " , src ) } split : = strings . Split ( key , " " ) switch key Type { case gcs Key Type : if len ( split ) < 4 { return " " , fmt . Errorf ( " " , key ) } log Type : = split [ 1 ] job Name : = split [ len ( split ) - 2 ] if log Type = = gcs . Non PRLogs { return path . Dir ( key ) , nil } else if log Type = = gcs . PRLogs { return path . Join ( bkt Name , gcs . PRLogs , " " , job Name ) , nil } return " " , fmt . Errorf ( " " , key ) case prow Key Type : if len ( split ) < 2 { return " " , fmt . Errorf ( " " , key ) } job Name : = split [ 0 ] build ID : = split [ 1 ] job , err : = s . job Agent . Get Prow Job ( job Name , build ID ) if err ! = nil { return " " , fmt . Errorf ( " " , key , err ) } if job . Spec . Decoration Config = = nil { return " " , fmt . Errorf ( " " , job Name ) } if job . Spec . Decoration Config . GCSConfiguration = = nil { return " " , fmt . Errorf ( " " , job Name ) } bkt Name : = job . Spec . Decoration Config . GCSConfiguration . Bucket if job . Spec . Type = = prowapi . Presubmit Job { return path . Join ( bkt Name , gcs . PRLogs , " " , job Name ) , nil } return path . Join ( bkt Name , gcs . Non PRLogs , job Name ) , nil default : return " " , fmt . Errorf ( " " , src ) } } 
func ( s * Spyglass ) Run Path ( src string ) ( string , error ) { src = strings . Trim Suffix ( src , " " ) key Type , key , err : = split Src ( src ) if err ! = nil { return " " , fmt . Errorf ( " " , src ) } switch key Type { case gcs Key Type : return key , nil case prow Key Type : return s . prow To GCS ( key ) default : return " " , fmt . Errorf ( " " , src ) } } 
func ( s * Spyglass ) Run To PR ( src string ) ( string , string , int , error ) { src = strings . Trim Suffix ( src , " " ) key Type , key , err : = split Src ( src ) if err ! = nil { return " " , " " , 0 , fmt . Errorf ( " " , src ) } split : = strings . Split ( key , " " ) if len ( split ) < 2 { return " " , " " , 0 , fmt . Errorf ( " " , src ) } switch key Type { case gcs Key Type : if log Type = = gcs . Non PRLogs { return " " , " " , 0 , fmt . Errorf ( " " , key ) } else if log Type = = gcs . PRLogs { if len ( split ) < 3 { return " " , " " , 0 , fmt . Errorf ( " " , gcs . PRLogs , key ) } pr Num Str : = split [ len ( split ) - 3 ] pr Num , err : = strconv . Atoi ( pr Num Str ) if err ! = nil { return " " , " " , 0 , fmt . Errorf ( " " , pr Num Str , key , err ) } } c : = s . config ( ) . Plank . Default Decoration Config . GCSConfiguration if len ( parts ) = = 1 { return c . Default Org , parts [ 0 ] , pr Num , nil } return parts [ 0 ] , parts [ 1 ] , pr Num , nil case 6 : return c . Default Org , c . Default Repo , pr Num , nil default : return " " , " " , 0 , fmt . Errorf ( " " , key ) } } else { return " " , " " , 0 , fmt . Errorf ( " " , log Type ) } case prow Key Type : if len ( split ) < 2 { return " " , " " , 0 , fmt . Errorf ( " " , key ) } job Name : = split [ 0 ] build ID : = split [ 1 ] job , err : = s . job Agent . Get Prow Job ( job Name , build ID ) if err ! = nil { return " " , " " , 0 , fmt . Errorf ( " " , key , err ) } if job . Spec . Refs = = nil | | len ( job . Spec . Refs . Pulls ) = = 0 { return " " , " " , 0 , fmt . Errorf ( " " , job . Name ) } return job . Spec . Refs . Org , job . Spec . Refs . Repo , job . Spec . Refs . Pulls [ 0 ] . Number , nil default : return " " , " " , 0 , fmt . Errorf ( " " , src ) } } 
func ( sg * Spyglass ) Extra Links ( src string ) ( [ ] Extra Link , error ) { artifacts , err : = sg . Fetch Artifacts ( src , " " , 1 0 0 0 0 0 0 , [ ] string { " " } ) return nil , nil } if err ! = nil { return nil , err } if err : = json . Unmarshal ( content , & started ) ; err ! = nil { return nil , err } if ! ok { return nil , nil } extra Links : = make ( [ ] Extra Link , 0 , len ( * links ) ) for _ , name : = range links . Keys ( ) { m , ok : = links . Meta ( name ) if ! ok { continue } s : = m . Strings ( ) link : = Extra Link { Name : name , URL : s [ " " ] , Description : s [ " " ] , } if link . URL = = " " | | link . Name = = " " { continue } extra Links = append ( extra Links , link ) } return extra Links , nil } 
func ( s * Server ) Serve HTTP ( w http . Response Writer , r * http . Request ) { event Type , event GUID , payload , ok , resp : = github . Validate Webhook ( w , r , s . Token Generator ( ) ) if counter , err : = s . Metrics . Webhook Counter . Get Metric With Label Values ( strconv . Itoa ( resp ) ) ; err ! = nil { logrus . With Fields ( logrus . Fields { " " : resp , } ) . With Error ( err ) . Error ( " " ) } else { counter . Inc ( ) } if ! ok { return } fmt . Fprint ( w , " " ) if err : = s . demux Event ( event Type , event GUID , payload , r . Header ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } 
func ( s * Server ) need Demux ( event Type , src Repo string ) [ ] plugins . External Plugin { var matching [ ] plugins . External Plugin src Org : = strings . Split ( src Repo , " " ) [ 0 ] for repo , plugins : = range s . Plugins . Config ( ) . External Plugins { } } else { for _ , et : = range p . Events { if et ! = event Type { continue } matching = append ( matching , p ) break } } } } return matching } 
func ( s * Server ) demux External ( l * logrus . Entry , external Plugins [ ] plugins . External Plugin , payload [ ] byte , h http . Header ) { h . Set ( " " , " " ) for _ , p : = range external Plugins { s . wg . Add ( 1 ) go func ( p plugins . External Plugin ) { defer s . wg . Done ( ) if err : = s . dispatch ( p . Endpoint , payload , h ) ; err ! = nil { l . With Error ( err ) . With Field ( " " , p . Name ) . Error ( " " ) } else { l . With Field ( " " , p . Name ) . Info ( " " ) } } ( p ) } } 
func ( s * Server ) dispatch ( endpoint string , payload [ ] byte , h http . Header ) error { req , err : = http . New Request ( http . Method Post , endpoint , bytes . New Buffer ( payload ) ) if err ! = nil { return err } req . Header = h resp , err : = s . do ( req ) if err ! = nil { return err } defer resp . Body . Close ( ) rb , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return err } if resp . Status Code < 2 0 0 | | resp . Status Code > 2 9 9 { return fmt . Errorf ( " " , resp . Status , string ( rb ) ) } return nil } 
func ( s * State Plugin ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . String Var ( & s . desc , " " , " " , " " ) cmd . Flags ( ) . Int Slice Var ( & s . percentiles , " " , [ ] int { } , " " ) } 
func ( s * State Plugin ) Check Flags ( ) error { s . states = New Bundled States ( s . desc ) return nil } 
func ( s * State Plugin ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { label : = " " if event . Label ! = nil { label = * event . Label } if ! s . states . Receive Event ( event . Issue ID , event . Event , label , event . Event Created At ) { return nil } total , sum : = s . states . Total ( event . Event Created At ) values : = map [ string ] interface { } { " " : total , " " : int ( sum ) , } for _ , percentile : = range s . percentiles { values [ fmt . Sprintf ( " " , percentile ) ] = int ( s . states . Percentile ( event . Event Created At , percentile ) ) } return [ ] Point { { Values : values , Date : event . Event Created At , } , } } 
func ( owners Dir Blacklist Owners Dir Blacklist ) Dir Blacklist ( org , repo string ) ( blacklist [ ] string ) { blacklist = append ( blacklist , owners Dir Blacklist . Default . . . ) if bl , ok : = owners Dir Blacklist . Repos [ org ] ; ok { blacklist = append ( blacklist , bl . . . ) } if bl , ok : = owners Dir Blacklist . Repos [ org + " " + repo ] ; ok { blacklist = append ( blacklist , bl . . . ) } return } 
func Load ( prow Config , job Config string ) ( c * Config , err error ) { } } ( ) c , err = load Config ( prow Config , job Config ) if err ! = nil { return nil , err } if err : = c . finalize Job Config ( ) ; err ! = nil { return nil , err } if err : = c . validate Component Config ( ) ; err ! = nil { return nil , err } if err : = c . validate Job Config ( ) ; err ! = nil { return nil , err } return c , nil } 
func load Config ( prow Config , job Config string ) ( * Config , error ) { stat , err : = os . Stat ( prow Config ) if err ! = nil { return nil , err } if stat . Is Dir ( ) { return nil , fmt . Errorf ( " " , prow Config ) } var nc Config if err : = yaml To Config ( prow Config , & nc ) ; err ! = nil { return nil , err } if err : = parse Prow Config ( & nc ) ; err ! = nil { return nil , err } } stat , err = os . Stat ( job Config ) if err ! = nil { return nil , err } if ! stat . Is Dir ( ) { if err : = yaml To Config ( job Config , & jc ) ; err ! = nil { return nil , err } if err : = nc . merge Job Config ( jc ) ; err ! = nil { return nil , err } return & nc , nil } err = filepath . Walk ( job Config , func ( path string , info os . File Info , err error ) error { if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , path ) } if strings . Has Prefix ( info . Name ( ) , " " ) { } return nil } if filepath . Ext ( path ) ! = " " & & filepath . Ext ( path ) ! = " " { return nil } if info . Is Dir ( ) { return nil } base : = filepath . Base ( path ) if unique Basenames . Has ( base ) { return fmt . Errorf ( " " , base ) } unique Basenames . Insert ( base ) var sub Config Job Config if err : = yaml To Config ( path , & sub Config ) ; err ! = nil { return err } return nc . merge Job Config ( sub Config ) } ) if err ! = nil { return nil , err } return & nc , nil } 
func yaml To Config ( path string , nc interface { } ) error { b , err : = Read File Maybe GZIP ( path ) if err ! = nil { return fmt . Errorf ( " " , path , err ) } if err : = yaml . Unmarshal ( b , nc ) ; err ! = nil { return fmt . Errorf ( " " , path , err ) } var jc * Job Config switch v : = nc . ( type ) { case * Job Config : jc = v case * Config : jc = & v . Job Config } for rep : = range jc . Presubmits { var fix func ( * Presubmit ) fix = func ( job * Presubmit ) { job . Source Path = path } for i : = range jc . Presubmits [ rep ] { fix ( & jc . Presubmits [ rep ] [ i ] ) } } for rep : = range jc . Postsubmits { var fix func ( * Postsubmit ) fix = func ( job * Postsubmit ) { job . Source Path = path } for i : = range jc . Postsubmits [ rep ] { fix ( & jc . Postsubmits [ rep ] [ i ] ) } } var fix func ( * Periodic ) fix = func ( job * Periodic ) { job . Source Path = path } for i : = range jc . Periodics { fix ( & jc . Periodics [ i ] ) } return nil } 
func Read File Maybe GZIP ( path string ) ( [ ] byte , error ) { b , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } return ioutil . Read All ( gzip Reader ) } 
func ( c * Config ) merge Job Config ( jc Job Config ) error { for _ , preset : = range c . Presets { for label , val : = range preset . Labels { pair : = label + " " + val if _ , ok : = valid Labels [ pair ] ; ok { return fmt . Errorf ( " " , pair ) } valid Labels [ pair ] = true } } } for repo , jobs : = range jc . Presubmits { c . Presubmits [ repo ] = append ( c . Presubmits [ repo ] , jobs . . . ) } } for repo , jobs : = range jc . Postsubmits { c . Postsubmits [ repo ] = append ( c . Postsubmits [ repo ] , jobs . . . ) } return nil } 
func ( c * Config ) finalize Job Config ( ) error { if c . decoration Requested ( ) { if c . Plank . Default Decoration Config = = nil { return errors . New ( " " ) } if c . Plank . Default Decoration Config . Utility Images = = nil { return errors . New ( " " ) } if c . Plank . Default Decoration Config . GCSConfiguration = = nil { return errors . New ( " " ) } if c . Plank . Default Decoration Config . GCSCredentials Secret = = " " { return errors . New ( " " ) } for _ , vs : = range c . Presubmits { for i : = range vs { set Presubmit Decoration Defaults ( c , & vs [ i ] ) } } for _ , js : = range c . Postsubmits { for i : = range js { set Postsubmit Decoration Defaults ( c , & js [ i ] ) } } for i : = range c . Periodics { set Periodic Decoration Defaults ( c , & c . Periodics [ i ] ) } } if err : = Set Presubmit Regexes ( vs ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } for _ , js : = range c . Postsubmits { c . default Postsubmit Fields ( js ) if err : = Set Postsubmit Regexes ( js ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } c . default Periodic Fields ( c . Periodics ) for _ , v : = range c . All Presubmits ( nil ) { if err : = resolve Presets ( v . Name , v . Labels , v . Spec , v . Build Spec , c . Presets ) ; err ! = nil { return err } } for _ , v : = range c . All Postsubmits ( nil ) { if err : = resolve Presets ( v . Name , v . Labels , v . Spec , v . Build Spec , c . Presets ) ; err ! = nil { return err } } for _ , v : = range c . All Periodics ( ) { if err : = resolve Presets ( v . Name , v . Labels , v . Spec , v . Build Spec , c . Presets ) ; err ! = nil { return err } } return nil } 
func ( c * Config ) validate Component Config ( ) error { if c . Plank . Job URLPrefix ! = " " & & c . Plank . Job URLPrefix Config [ " " ] ! = " " { return errors . New ( `Planks job _url _prefix must be unset when job _url _prefix _config [ " * " ] is set . The former is deprecated , use the latter ` ) } for k , v : = range c . Plank . Job URLPrefix Config { if _ , err : = url . Parse ( v ) ; err ! = nil { return fmt . Errorf ( `Invalid value for Planks job _url _prefix _config [ " %s " ] : %v ` , k , err ) } } if c . Slack Reporter ! = nil { if err : = c . Slack Reporter . Default And Validate ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } return nil } 
func ( c * Config ) validate Job Config ( ) error { type org Repo Job Name struct { org Repo , job Name string } for repo , jobs : = range c . Presubmits { for _ , job : = range jobs { repo Job Name : = org Repo Job Name { repo , job . Name } for _ , existing Job : = range valid Presubmits [ repo Job Name ] { if existing Job . Brancher . Intersects ( job . Brancher ) { return fmt . Errorf ( " " , job . Name ) } } valid Presubmits [ repo Job Name ] = append ( valid Presubmits [ repo Job Name ] , job ) } } for _ , v : = range c . All Presubmits ( nil ) { if err : = validate Job Base ( v . Job Base , prowapi . Presubmit Job , c . Pod Namespace ) ; err ! = nil { return fmt . Errorf ( " " , v . Name , err ) } if err : = validate Triggering ( v ) ; err ! = nil { return err } } for repo , jobs : = range c . Postsubmits { for _ , job : = range jobs { repo Job Name : = org Repo Job Name { repo , job . Name } for _ , existing Job : = range valid Postsubmits [ repo Job Name ] { if existing Job . Brancher . Intersects ( job . Brancher ) { return fmt . Errorf ( " " , job . Name ) } } valid Postsubmits [ repo Job Name ] = append ( valid Postsubmits [ repo Job Name ] , job ) } } for _ , j : = range c . All Postsubmits ( nil ) { if err : = validate Job Base ( j . Job Base , prowapi . Postsubmit Job , c . Pod Namespace ) ; err ! = nil { return fmt . Errorf ( " " , j . Name , err ) } } } valid Periodics . Insert ( p . Name ) if err : = validate Job Base ( p . Job Base , prowapi . Periodic Job , c . Pod Namespace ) ; err ! = nil { return fmt . Errorf ( " " , p . Name , err ) } } } else if p . Cron = = " " & & p . Interval = = " " { return fmt . Errorf ( " " , p . Name ) } else if p . Cron ! = " " { if _ , err : = cron . Parse ( p . Cron ) ; err ! = nil { return fmt . Errorf ( " " , p . Cron , p . Name , err ) } } else { d , err : = time . Parse Duration ( c . Periodics [ j ] . Interval ) if err ! = nil { return fmt . Errorf ( " " , c . Periodics [ j ] . Name , err ) } c . Periodics [ j ] . interval = d } } return nil } 
func Config Path ( value string ) string { if value ! = " " { return value } logrus . Warningf ( " " , Default Config Path ) return Default Config Path } 
func Validate Controller ( c * Controller ) error { url Tmpl , err : = template . New ( " " ) . Parse ( c . Job URLTemplate String ) if err ! = nil { return fmt . Errorf ( " " , err ) } c . Job URLTemplate = url Tmpl report Tmpl , err : = template . New ( " " ) . Parse ( c . Report Template String ) if err ! = nil { return fmt . Errorf ( " " , err ) } c . Report Template = report Tmpl if c . Max Concurrency < 0 { return fmt . Errorf ( " " , c . Max Concurrency ) } if c . Max Goroutines = = 0 { c . Max Goroutines = 2 0 } if c . Max Goroutines < = 0 { return fmt . Errorf ( " " , c . Max Goroutines ) } return nil } 
func ( c * Prow Config ) default Job Base ( base * Job Base ) { if base . Agent = = " " { } if base . Namespace = = nil | | * base . Namespace = = " " { s : = c . Pod Namespace base . Namespace = & s } if base . Cluster = = " " { base . Cluster = kube . Default Cluster Alias } } 
func Set Presubmit Regexes ( js [ ] Presubmit ) error { for i , j : = range js { if re , err : = regexp . Compile ( j . Trigger ) ; err = = nil { js [ i ] . re = re } else { return fmt . Errorf ( " " , j . Name , err ) } if ! js [ i ] . re . Match String ( j . Rerun Command ) { return fmt . Errorf ( " \ " \ " \ " \ " " , j . Name , j . Rerun Command , j . Trigger ) } b , err : = set Brancher Regexes ( j . Brancher ) if err ! = nil { return fmt . Errorf ( " " , j . Name , err ) } js [ i ] . Brancher = b c , err : = set Change Regexes ( j . Regexp Change Matcher ) if err ! = nil { return fmt . Errorf ( " " , j . Name , err ) } js [ i ] . Regexp Change Matcher = c } return nil } 
func set Brancher Regexes ( br Brancher ) ( Brancher , error ) { if len ( br . Branches ) > 0 { if re , err : = regexp . Compile ( strings . Join ( br . Branches , ` | ` ) ) ; err = = nil { br . re = re } else { return br , fmt . Errorf ( " " , err ) } } if len ( br . Skip Branches ) > 0 { if re , err : = regexp . Compile ( strings . Join ( br . Skip Branches , ` | ` ) ) ; err = = nil { br . re Skip = re } else { return br , fmt . Errorf ( " " , err ) } } return br , nil } 
func Set Postsubmit Regexes ( ps [ ] Postsubmit ) error { for i , j : = range ps { b , err : = set Brancher Regexes ( j . Brancher ) if err ! = nil { return fmt . Errorf ( " " , j . Name , err ) } ps [ i ] . Brancher = b c , err : = set Change Regexes ( j . Regexp Change Matcher ) if err ! = nil { return fmt . Errorf ( " " , j . Name , err ) } ps [ i ] . Regexp Change Matcher = c } return nil } 
func ( lens Lens ) Body ( artifacts [ ] lenses . Artifact , resource Dir string , data string ) string { var buf bytes . Buffer type Metadata View Data struct { Status string Start Time time . Time Finished Time time . Time Elapsed time . Duration Metadata map [ string ] string } metadata View Data : = Metadata View Data { Status : " " } started : = gcs . Started { } finished : = gcs . Finished { } for _ , a : = range artifacts { read , err : = a . Read All ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) } if a . Job Path ( ) = = " " { if err = json . Unmarshal ( read , & started ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } metadata View Data . Start Time = time . Unix ( started . Timestamp , 0 ) } else if a . Job Path ( ) = = " " { if err = json . Unmarshal ( read , & finished ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } if finished . Timestamp ! = nil { metadata View Data . Finished Time = time . Unix ( * finished . Timestamp , 0 ) } metadata View Data . Status = finished . Result } } if ! metadata View Data . Start Time . Is Zero ( ) { if metadata View Data . Finished Time . Is Zero ( ) { metadata View Data . Elapsed = time . Now ( ) . Sub ( metadata View Data . Start Time ) } else { metadata View Data . Elapsed = metadata View Data . Finished Time . Sub ( metadata View Data . Start Time ) } metadata View Data . Elapsed = metadata View Data . Elapsed . Round ( time . Second ) } metadata View Data . Metadata = map [ string ] string { " " : started . Node } metadatas : = [ ] metadata . Metadata { started . Metadata , finished . Metadata } for _ , m : = range metadatas { for k , v : = range m { if s , ok : = v . ( string ) ; ok & & v ! = " " { metadata View Data . Metadata [ k ] = s } } } metadata Template , err : = template . Parse Files ( filepath . Join ( resource Dir , " " ) ) if err ! = nil { return fmt . Sprintf ( " " , err ) } if err : = metadata Template . Execute Template ( & buf , " " , metadata View Data ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } return buf . String ( ) } 
func New Boskos Handler ( r * ranch . Ranch ) * http . Serve Mux { mux : = http . New Serve Mux ( ) mux . Handle ( " " , handle Default ( r ) ) mux . Handle ( " " , handle Acquire ( r ) ) mux . Handle ( " " , handle Acquire By State ( r ) ) mux . Handle ( " " , handle Release ( r ) ) mux . Handle ( " " , handle Reset ( r ) ) mux . Handle ( " " , handle Update ( r ) ) mux . Handle ( " " , handle Metric ( r ) ) return mux } 
func Error To Status ( err error ) int { switch err . ( type ) { default : return http . Status Internal Server Error case * ranch . Owner Not Match : return http . Status Unauthorized case * ranch . Resource Not Found : return http . Status Not Found case * ranch . Resource Type Not Found : return http . Status Not Found case * ranch . State Not Match : return http . Status Conflict } } 
func handle Default ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) } } 
func handle Acquire ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Post { msg : = fmt . Sprintf ( " " , req . Method ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Method Not Allowed ) return } state : = req . URL . Query ( ) . Get ( " " ) dest : = req . URL . Query ( ) . Get ( " " ) owner : = req . URL . Query ( ) . Get ( " " ) if rtype = = " " | | state = = " " | | dest = = " " | | owner = = " " { msg : = fmt . Sprintf ( " " , rtype , state , dest , owner ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } logrus . Infof ( " " , state , rtype , owner , dest ) resource , err : = r . Acquire ( rtype , state , dest , owner ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } res JSON , err : = json . Marshal ( resource ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , resource ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) if err ! = nil { logrus . With Error ( err ) . Warningf ( " " , resource . Name ) } return } logrus . Infof ( " " , string ( res JSON ) ) fmt . Fprint ( res , string ( res JSON ) ) } } 
func handle Acquire By State ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Post { msg : = fmt . Sprintf ( " " , req . Method ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Method Not Allowed ) return } dest : = req . URL . Query ( ) . Get ( " " ) owner : = req . URL . Query ( ) . Get ( " " ) names : = req . URL . Query ( ) . Get ( " " ) if state = = " " | | dest = = " " | | owner = = " " | | names = = " " { msg : = fmt . Sprintf ( " " , state , dest , owner , names ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } r Names : = strings . Split ( names , " " ) logrus . Infof ( " " , strings . Join ( r Names , " " ) , state , owner , dest ) resources , err : = r . Acquire By State ( state , dest , owner , r Names ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } res Bytes : = new ( bytes . Buffer ) if err : = json . New Encoder ( res Bytes ) . Encode ( resources ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , resources ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) for _ , resource : = range resources { err : = r . Release ( resource . Name , state , owner ) if err ! = nil { logrus . With Error ( err ) . Warningf ( " " , resource . Name ) } } return } logrus . Infof ( " " , res Bytes . String ( ) ) fmt . Fprint ( res , res Bytes . String ( ) ) } } 
func handle Release ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Post { msg : = fmt . Sprintf ( " " , req . Method ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Method Not Allowed ) return } name : = req . URL . Query ( ) . Get ( " " ) dest : = req . URL . Query ( ) . Get ( " " ) owner : = req . URL . Query ( ) . Get ( " " ) if name = = " " | | dest = = " " | | owner = = " " { msg : = fmt . Sprintf ( " " , name , dest , owner ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } if err : = r . Release ( name , dest , owner ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , name , dest , owner ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } logrus . Infof ( " " , name , dest ) } } 
func handle Reset ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Post { msg : = fmt . Sprintf ( " " , req . Method ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Method Not Allowed ) return } rtype : = req . URL . Query ( ) . Get ( " " ) state : = req . URL . Query ( ) . Get ( " " ) expire Str : = req . URL . Query ( ) . Get ( " " ) dest : = req . URL . Query ( ) . Get ( " " ) logrus . Infof ( " " , rtype , state , expire Str , dest ) if rtype = = " " | | state = = " " | | expire Str = = " " | | dest = = " " { msg : = fmt . Sprintf ( " " , rtype , state , expire Str , dest ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } expire , err : = time . Parse Duration ( expire Str ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , expire Str ) http . Error ( res , err . Error ( ) , http . Status Bad Request ) return } rmap , err : = r . Reset ( rtype , state , expire , dest ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) http . Error ( res , err . Error ( ) , http . Status Bad Request ) return } res JSON , err : = json . Marshal ( rmap ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , rmap ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } logrus . Infof ( " " , rtype , len ( rmap ) , dest ) fmt . Fprint ( res , string ( res JSON ) ) } } 
func handle Update ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Post { msg : = fmt . Sprintf ( " " , req . Method ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Method Not Allowed ) return } name : = req . URL . Query ( ) . Get ( " " ) owner : = req . URL . Query ( ) . Get ( " " ) state : = req . URL . Query ( ) . Get ( " " ) if name = = " " | | owner = = " " | | state = = " " { msg : = fmt . Sprintf ( " " , name , owner , state ) logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } var user Data common . User Data if req . Body ! = nil { err : = json . New Decoder ( req . Body ) . Decode ( & user Data ) switch { case err = = io . EOF : http . Error ( res , err . Error ( ) , http . Status Bad Request ) return } } if err : = r . Update ( name , owner , state , & user Data ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , name , state , owner ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } logrus . Infof ( " " , name ) } } 
func handle Metric ( r * ranch . Ranch ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { logrus . With Field ( " " , " " ) . Infof ( " " , req . Remote Addr ) if req . Method ! = http . Method Get { logrus . Warningf ( " " , req . Method ) http . Error ( res , " " , http . Status Method Not Allowed ) return } rtype : = req . URL . Query ( ) . Get ( " " ) if rtype = = " " { msg : = " " logrus . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } metric , err : = r . Metric ( rtype ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , rtype ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } js , err : = json . Marshal ( metric ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) http . Error ( res , err . Error ( ) , Error To Status ( err ) ) return } res . Header ( ) . Set ( " " , " " ) res . Write ( js ) } } 
func Dump Profile ( destination string , profile [ ] * cover . Profile ) error { var output io . Writer if destination = = " " { output = os . Stdout } else { f , err : = os . Create ( destination ) if err ! = nil { return fmt . Errorf ( " " , destination , err ) } defer f . Close ( ) output = f } err : = cov . Dump Profile ( profile , output ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Load Profile ( origin string ) ( [ ] * cover . Profile , error ) { filename : = origin if origin = = " " { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } defer tf . Close ( ) defer os . Remove ( tf . Name ( ) ) if _ , err : = io . Copy ( tf , os . Stdin ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } filename = tf . Name ( ) } return cover . Parse Profiles ( filename ) } 
func New Client ( ) ( * Client , error ) { g , err : = exec . Look Path ( " " ) if err ! = nil { return nil , err } t , err : = ioutil . Temp Dir ( " " , " " ) if err ! = nil { return nil , err } return & Client { logger : logrus . With Field ( " " , " " ) , dir : t , git : g , base : fmt . Sprintf ( " " , github ) , repo Locks : make ( map [ string ] * sync . Mutex ) , } , nil } 
func ( c * Client ) Set Credentials ( user string , token Generator func ( ) [ ] byte ) { c . cred Lock . Lock ( ) defer c . cred Lock . Unlock ( ) c . user = user c . token Generator = token Generator } 
func ( c * Client ) Clone ( repo string ) ( * Repo , error ) { c . lock Repo ( repo ) defer c . unlock Repo ( repo ) base : = c . base user , pass : = c . get Credentials ( ) if user ! = " " & & pass ! = " " { base = fmt . Sprintf ( " " , user , pass , github ) } cache : = filepath . Join ( c . dir , repo ) + " " if _ , err : = os . Stat ( cache ) ; os . Is Not Exist ( err ) { if err : = os . Mkdir All ( filepath . Dir ( cache ) , os . Mode Perm ) ; err ! = nil & & ! os . Is Exist ( err ) { return nil , err } remote : = fmt . Sprintf ( " " , base , repo ) if b , err : = retry Cmd ( c . logger , " " , c . git , " " , " " , remote , cache ) ; err ! = nil { return nil , fmt . Errorf ( " " , err , string ( b ) ) } } else if err ! = nil { return nil , err } else { if b , err : = retry Cmd ( c . logger , cache , c . git , " " ) ; err ! = nil { return nil , fmt . Errorf ( " " , err , string ( b ) ) } } t , err : = ioutil . Temp Dir ( " " , " " ) if err ! = nil { return nil , err } if b , err : = exec . Command ( c . git , " " , cache , t ) . Combined Output ( ) ; err ! = nil { return nil , fmt . Errorf ( " " , err , string ( b ) ) } return & Repo { Dir : t , logger : c . logger , git : c . git , base : base , repo : repo , user : user , pass : pass , } , nil } 
func ( r * Repo ) Checkout ( commitlike string ) error { r . logger . Infof ( " " , commitlike ) co : = r . git Command ( " " , commitlike ) if b , err : = co . Combined Output ( ) ; err ! = nil { return fmt . Errorf ( " " , commitlike , err , string ( b ) ) } return nil } 
func ( r * Repo ) Checkout New Branch ( branch string ) error { r . logger . Infof ( " " , branch ) co : = r . git Command ( " " , " " , branch ) if b , err : = co . Combined Output ( ) ; err ! = nil { return fmt . Errorf ( " " , branch , err , string ( b ) ) } return nil } 
func ( r * Repo ) Merge ( commitlike string ) ( bool , error ) { r . logger . Infof ( " " , commitlike ) co : = r . git Command ( " " , " " , " " , " " , commitlike ) b , err : = co . Combined Output ( ) if err = = nil { return true , nil } r . logger . With Error ( err ) . Infof ( " " , string ( b ) ) if b , err : = r . git Command ( " " , " " ) . Combined Output ( ) ; err ! = nil { return false , fmt . Errorf ( " " , commitlike , err , string ( b ) ) } return false , nil } 
func ( r * Repo ) Am ( path string ) error { r . logger . Infof ( " " , path ) co : = r . git Command ( " " , " " , path ) b , err : = co . Combined Output ( ) if err = = nil { return nil } output : = string ( b ) r . logger . With Error ( err ) . Infof ( " " , output ) if b , abort Err : = r . git Command ( " " , " " ) . Combined Output ( ) ; err ! = nil { r . logger . With Error ( abort Err ) . Warningf ( " " , string ( b ) ) } apply Msg : = " " if strings . Contains ( output , apply Msg ) { i : = strings . Index ( output , apply Msg ) err = fmt . Errorf ( " " , output [ : i ] ) } return err } 
func ( r * Repo ) Push ( repo , branch string ) error { if r . user = = " " | | r . pass = = " " { return errors . New ( " " ) } r . logger . Infof ( " " , r . user , repo , branch ) remote : = fmt . Sprintf ( " " , r . user , r . pass , github , r . user , repo ) co : = r . git Command ( " " , remote , branch ) _ , err : = co . Combined Output ( ) return err } 
func ( r * Repo ) Checkout Pull Request ( number int ) error { r . logger . Infof ( " " , r . repo , number ) if b , err : = retry Cmd ( r . logger , r . Dir , r . git , " " , r . base + " " + r . repo , fmt . Sprintf ( " " , number , number ) ) ; err ! = nil { return fmt . Errorf ( " " , number , err , string ( b ) ) } co : = r . git Command ( " " , fmt . Sprintf ( " " , number ) ) if b , err : = co . Combined Output ( ) ; err ! = nil { return fmt . Errorf ( " " , number , err , string ( b ) ) } return nil } 
func ( r * Repo ) Config ( key , value string ) error { r . logger . Infof ( " " , key , value ) if b , err : = r . git Command ( " " , key , value ) . Combined Output ( ) ; err ! = nil { return fmt . Errorf ( " " , key , value , err , string ( b ) ) } return nil } 
func retry Cmd ( l * logrus . Entry , dir , cmd string , arg . . . string ) ( [ ] byte , error ) { var b [ ] byte var err error sleepy Time : = time . Second for i : = 0 ; i < 3 ; i + + { c : = exec . Command ( cmd , arg . . . ) c . Dir = dir b , err = c . Combined Output ( ) if err ! = nil { l . Warningf ( " " , cmd , arg , err , string ( b ) ) time . Sleep ( sleepy Time ) sleepy Time * = 2 continue } break } return b , err } 
func ( r * Repo ) Merge Commits Exist Between ( target , head string ) ( bool , error ) { r . logger . Infof ( " " , target , head ) b , err : = r . git Command ( " " , fmt . Sprintf ( " " , target , head ) , " " , " " ) . Combined Output ( ) if err ! = nil { return false , fmt . Errorf ( " " , target , head , err , string ( b ) ) } return len ( b ) ! = 0 , nil } 
func Labels And Annotations For Spec ( spec prowapi . Prow Job Spec , extra Labels , extra Annotations map [ string ] string ) ( map [ string ] string , map [ string ] string ) { job Name For Label : = spec . Job if len ( job Name For Label ) > validation . Label Value Max Length { logrus . With Fields ( logrus . Fields { " " : spec . Job , " " : kube . Prow Job Annotation , " " : spec . Job , " " : job Name For Label , } ) . Info ( " " ) } labels : = map [ string ] string { kube . Created By Prow : " " , kube . Prow Job Type Label : string ( spec . Type ) , kube . Prow Job Annotation : job Name For Label , } if spec . Type ! = prowapi . Periodic Job & & spec . Refs ! = nil { labels [ kube . Org Label ] = spec . Refs . Org labels [ kube . Repo Label ] = spec . Refs . Repo if len ( spec . Refs . Pulls ) > 0 { labels [ kube . Pull Label ] = strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) } } for k , v : = range extra Labels { labels [ k ] = v } if errs : = validation . Is Valid Label Value ( base ) ; len ( errs ) = = 0 { labels [ key ] = base continue } logrus . With Fields ( logrus . Fields { " " : key , " " : value , " " : errs , } ) . Warn ( " " ) delete ( labels , key ) } } annotations : = map [ string ] string { kube . Prow Job Annotation : spec . Job , } for k , v : = range extra Annotations { annotations [ k ] = v } return labels , annotations } 
func Labels And Annotations For Job ( pj prowapi . Prow Job ) ( map [ string ] string , map [ string ] string ) { var extra Labels map [ string ] string if extra Labels = pj . Object Meta . Labels ; extra Labels = = nil { extra Labels = map [ string ] string { } } extra Labels [ kube . Prow Job IDLabel ] = pj . Object Meta . Name return Labels And Annotations For Spec ( pj . Spec , extra Labels , nil ) } 
func Prow Job To Pod ( pj prowapi . Prow Job , build ID string ) ( * coreapi . Pod , error ) { if pj . Spec . Pod Spec = = nil { return nil , fmt . Errorf ( " " , pj . Name ) } raw Env , err : = downwardapi . Env For Spec ( downwardapi . New Job Spec ( pj . Spec , build ID , pj . Name ) ) if err ! = nil { return nil , err } spec : = pj . Spec . Pod Spec . Deep Copy ( ) spec . Restart Policy = " " spec . Containers [ 0 ] . Name = kube . Test Container Name spec . Automount Service Account Token = & my False } if pj . Spec . Decoration Config = = nil { spec . Containers [ 0 ] . Env = append ( spec . Containers [ 0 ] . Env , kube Env ( raw Env ) . . . ) } else { if err : = decorate ( spec , & pj , raw Env ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } pod Labels , annotations : = Labels And Annotations For Job ( pj ) return & coreapi . Pod { Object Meta : metav 1 . Object Meta { Name : pj . Object Meta . Name , Labels : pod Labels , Annotations : annotations , } , Spec : * spec , } , nil } 
func Clone Log Path ( log Mount coreapi . Volume Mount ) string { return filepath . Join ( log Mount . Mount Path , clone Log Path ) } 
func clone Env ( opt clonerefs . Options ) ( [ ] coreapi . Env Var , error ) { if err ! = nil { return nil , err } return kube Env ( map [ string ] string { clonerefs . JSONConfig Env Var : clone Config Env } ) , nil } 
func ssh Volume ( secret string ) ( coreapi . Volume , coreapi . Volume Mount ) { var ssh Key Mode int 3 2 = 0 4 0 0 name : = strings . Join ( [ ] string { " " , secret } , " " ) mount Path : = path . Join ( " " , secret ) v : = coreapi . Volume { Name : name , Volume Source : coreapi . Volume Source { Secret : & coreapi . Secret Volume Source { Secret Name : secret , Default Mode : & ssh Key Mode , } , } , } vm : = coreapi . Volume Mount { Name : name , Mount Path : mount Path , Read Only : true , } return v , vm } 
func cookiefile Volume ( secret string ) ( coreapi . Volume , coreapi . Volume Mount , string ) { cookie Secret : = parts [ 0 ] var base string if len ( parts ) = = 1 { base = parts [ 0 ] } else { base = parts [ 1 ] } var cookiefile Mode int 3 2 = 0 4 0 0 vol : = coreapi . Volume { Name : " " , Volume Source : coreapi . Volume Source { Secret : & coreapi . Secret Volume Source { Secret Name : cookie Secret , Default Mode : & cookiefile Mode , } , } , } mount : = coreapi . Volume Mount { Name : vol . Name , Mount Path : " " , return vol , mount , path . Join ( mount . Mount Path , base ) } 
func Clone Refs ( pj prowapi . Prow Job , code Mount , log Mount coreapi . Volume Mount ) ( * coreapi . Container , [ ] prowapi . Refs , [ ] coreapi . Volume , error ) { if pj . Spec . Decoration Config = = nil { return nil , nil , nil , nil } if skip : = pj . Spec . Decoration Config . Skip Cloning ; skip ! = nil & & * skip { return nil , nil , nil , nil } var clone Volumes [ ] coreapi . Volume var refs [ ] prowapi . Refs if pj . Spec . Refs ! = nil { refs = append ( refs , * pj . Spec . Refs ) } for _ , r : = range pj . Spec . Extra Refs { refs = append ( refs , r ) } if len ( refs ) = = 0 { } if code Mount . Name = = " " | | code Mount . Mount Path = = " " { return nil , nil , nil , fmt . Errorf ( " " ) } if log Mount . Name = = " " | | log Mount . Mount Path = = " " { return nil , nil , nil , fmt . Errorf ( " " ) } var clone Mounts [ ] coreapi . Volume Mount var ssh Key Paths [ ] string for _ , secret : = range pj . Spec . Decoration Config . SSHKey Secrets { volume , mount : = ssh Volume ( secret ) clone Mounts = append ( clone Mounts , mount ) ssh Key Paths = append ( ssh Key Paths , mount . Mount Path ) clone Volumes = append ( clone Volumes , volume ) } var clone Args [ ] string var cookiefile Path string if cp : = pj . Spec . Decoration Config . Cookiefile Secret ; cp ! = " " { v , vm , vp : = cookiefile Volume ( cp ) clone Mounts = append ( clone Mounts , vm ) clone Volumes = append ( clone Volumes , v ) cookiefile Path = vp clone Args = append ( clone Args , " " + cookiefile Path ) } env , err : = clone Env ( clonerefs . Options { Cookie Path : cookiefile Path , Git Refs : refs , Git User Email : clonerefs . Default Git User Email , Git User Name : clonerefs . Default Git User Name , Host Fingerprints : pj . Spec . Decoration Config . SSHHost Fingerprints , Key Files : ssh Key Paths , Log : Clone Log Path ( log Mount ) , Src Root : code Mount . Mount Path , } ) if err ! = nil { return nil , nil , nil , fmt . Errorf ( " " , err ) } container : = coreapi . Container { Name : clone Refs Name , Image : pj . Spec . Decoration Config . Utility Images . Clone Refs , Command : [ ] string { clone Refs Command } , Args : clone Args , Env : env , Volume Mounts : append ( [ ] coreapi . Volume Mount { log Mount , code Mount } , clone Mounts . . . ) , } return & container , refs , clone Volumes , nil } 
func Inject Entrypoint ( c * coreapi . Container , timeout , grace Period time . Duration , prefix , previous Marker string , exit Zero bool , log , tools coreapi . Volume Mount ) ( * wrapper . Options , error ) { wrapper Options : = & wrapper . Options { Args : append ( c . Command , c . Args . . . ) , Process Log : process Log ( log , prefix ) , Marker File : marker File ( log , prefix ) , Metadata File : metadata File ( log , prefix ) , } if err ! = nil { return nil , err } c . Command = [ ] string { entrypoint Location ( tools ) } c . Args = nil c . Env = append ( c . Env , kube Env ( map [ string ] string { entrypoint . JSONConfig Env Var : entrypoint Config Env } ) . . . ) c . Volume Mounts = append ( c . Volume Mounts , log , tools ) return wrapper Options , nil } 
func Place Entrypoint ( image string , tools Mount coreapi . Volume Mount ) coreapi . Container { return coreapi . Container { Name : " " , Image : image , Command : [ ] string { " " } , Args : [ ] string { " " , entrypoint Location ( tools Mount ) } , Volume Mounts : [ ] coreapi . Volume Mount { tools Mount } , } } 
func kube Env ( environment map [ string ] string ) [ ] coreapi . Env Var { var keys [ ] string for key : = range environment { keys = append ( keys , key ) } sort . Strings ( keys ) var kube Environment [ ] coreapi . Env Var for _ , key : = range keys { kube Environment = append ( kube Environment , coreapi . Env Var { Name : key , Value : environment [ key ] , } ) } return kube Environment } 
func ( o * Kubernetes Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . cluster , " " , " " , " " ) fs . String Var ( & o . kubeconfig , " " , " " , " " ) fs . String Var ( & o . Deck URI , " " , " " , " " ) } 
func ( o * Kubernetes Options ) Validate ( dry Run bool ) error { if dry Run & & o . Deck URI = = " " { return errors . New ( " " ) } if o . Deck URI ! = " " { if _ , err : = url . Parse Request URI ( o . Deck URI ) ; err ! = nil { return fmt . Errorf ( " " , o . Deck URI ) } } return nil } 
func ( o * Kubernetes Options ) Client ( namespace string , dry Run bool ) ( * kube . Client , error ) { if dry Run { return kube . New Fake Client ( o . Deck URI ) , nil } if o . cluster = = " " { return kube . New Client In Cluster ( namespace ) } return kube . New Client From File ( o . cluster , namespace ) } 
func handle ( gc github Client , le * logrus . Entry , e * event ) error { needs Label : = e . draft | | title Regex . Match String ( e . title ) if needs Label & & ! e . has Label { if err : = gc . Add Label ( e . org , e . repo , e . number , labels . Work In Progress ) ; err ! = nil { le . Warnf ( " " , labels . Work In Progress , err ) return err } } else if ! needs Label & & e . has Label { if err : = gc . Remove Label ( e . org , e . repo , e . number , labels . Work In Progress ) ; err ! = nil { le . Warnf ( " " , labels . Work In Progress , err ) return err } } return nil } 
func Send Hook ( address , event Type string , payload , hmac [ ] byte ) error { req , err : = http . New Request ( http . Method Post , address , bytes . New Buffer ( payload ) ) if err ! = nil { return err } req . Header . Set ( " " , event Type ) req . Header . Set ( " " , " " ) req . Header . Set ( " " , github . Payload Signature ( payload , hmac ) ) req . Header . Set ( " " , " " ) c : = & http . Client { } resp , err : = c . Do ( req ) if err ! = nil { return err } defer resp . Body . Close ( ) rb , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return err } if resp . Status Code ! = 2 0 0 { return fmt . Errorf ( " " , resp . Status Code , string ( bytes . Trim Space ( rb ) ) ) } return nil } 
func format ( rtype string ) string { splits : = strings . Split ( rtype , " " ) return splits [ len ( splits ) - 1 ] } 
func janitor Clean ( resource * common . Resource , flags [ ] string ) error { args : = append ( [ ] string { fmt . Sprintf ( " " , format ( resource . Type ) , resource . Name ) } , flags . . . ) logrus . Infof ( " " , * janitor Path , strings . Join ( args , " " ) ) cmd : = exec . Command ( * janitor Path , args . . . ) b , err : = cmd . Combined Output ( ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , resource . Name , string ( b ) ) } else { logrus . Tracef ( " " , string ( b ) ) logrus . Infof ( " " , resource . Name ) } return err } 
func janitor ( c boskos Client , buffer < - chan * common . Resource , fn clean , flags [ ] string ) { for { resource : = < - buffer dest : = common . Free if err : = fn ( resource , flags ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , * janitor Path ) dest = common . Dirty } if err : = c . Release One ( resource . Name , dest ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } } 
func ( s * Push Server ) Serve HTTP ( w http . Response Writer , r * http . Request ) { HTTPCode : = http . Status OK subscription : = " " var final Error error defer func ( ) { s . Subscriber . Metrics . Response Counter . With ( prometheus . Labels { subscription Label : subscription , response Code Label : string ( HTTPCode ) , } ) . Inc ( ) if final Error ! = nil { http . Error ( w , final Error . Error ( ) , HTTPCode ) } } ( ) if s . Token Generator ! = nil { token : = r . URL . Query ( ) . Get ( token Label ) if token ! = string ( s . Token Generator ( ) ) { final Error = fmt . Errorf ( " " ) HTTPCode = http . Status Forbidden return } } if err : = json . New Decoder ( r . Body ) . Decode ( pr ) ; err ! = nil { final Error = err HTTPCode = http . Status Bad Request return } msg : = pubsub . Message { Data : pr . Message . Data , ID : pr . Message . ID , Attributes : pr . Message . Attributes , } if err : = s . Subscriber . handle Message ( & pub Sub Message { Message : msg } , pr . Subscription ) ; err ! = nil { final Error = err HTTPCode = http . Status Not Modified return } } 
func ( c * pub Sub Client ) new ( ctx context . Context , project string ) ( pubsub Client Interface , error ) { client , err : = pubsub . New Client ( ctx , project ) if err ! = nil { return nil , err } c . client = client return c , nil } 
func ( c * pub Sub Client ) subscription ( id string ) subscription Interface { return & pub Sub Subscription { sub : c . client . Subscription ( id ) , } } 
func ( s * Pull Server ) handle Pulls ( ctx context . Context , project Subscriptions config . Pubsub Subscriptions ) ( * errgroup . Group , context . Context , error ) { for project , subscriptions : = range project Subscriptions { client , err : = s . Client . new ( ctx , project ) if err ! = nil { return err Group , derived Ctx , err } for _ , sub Name : = range subscriptions { sub : = client . subscription ( sub Name ) err Group . Go ( func ( ) error { logrus . Infof ( " " , sub . string ( ) , project ) defer logrus . Warnf ( " " , sub . string ( ) , project ) err : = sub . receive ( derived Ctx , func ( ctx context . Context , msg message Interface ) { if err = s . Subscriber . handle Message ( msg , sub . string ( ) ) ; err ! = nil { s . Subscriber . Metrics . ACKMessage Counter . With ( prometheus . Labels { subscription Label : sub . string ( ) } ) . Inc ( ) } else { s . Subscriber . Metrics . NACKMessage Counter . With ( prometheus . Labels { subscription Label : sub . string ( ) } ) . Inc ( ) } msg . ack ( ) } ) if err ! = nil { logrus . With Error ( err ) . Errorf ( " " , sub . string ( ) , project ) return err } return nil } ) } } return err Group , derived Ctx , nil } 
func ( s * Pull Server ) Run ( ctx context . Context ) error { config Event : = make ( chan config . Delta , 2 ) s . Subscriber . Config Agent . Subscribe ( config Event ) var err error defer func ( ) { if err ! = nil { logrus . With Error ( ctx . Err ( ) ) . Error ( " " ) } logrus . Warn ( " " ) } ( ) current Config : = s . Subscriber . Config Agent . Config ( ) . Pub Sub Subscriptions err Group , derived Ctx , err : = s . handle Pulls ( ctx , current Config ) if err ! = nil { return err } for { select { return err logrus . Info ( " " ) if ! reflect . Deep Equal ( current Config , new Config ) { logrus . Warn ( " " ) if err ! = nil { return err } current Config = new Config } } } } 
func spec To Started ( spec * downwardapi . Job Spec , main Ref SHA string ) gcs . Started { started : = gcs . Started { Timestamp : time . Now ( ) . Unix ( ) , Repo Version : downwardapi . Get Revision From Spec ( spec ) , } if main Ref SHA ! = " " { started . Repo Version = main Ref SHA } } started . Repos = map [ string ] string { } if spec . Refs ! = nil { started . Repos [ spec . Refs . Org + " " + spec . Refs . Repo ] = spec . Refs . String ( ) } for _ , ref : = range spec . Extra Refs { started . Repos [ ref . Org + " " + ref . Repo ] = ref . String ( ) } return started } 
func ( o Options ) Run ( ) error { spec , err : = downwardapi . Resolve Spec From Env ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } upload Targets : = map [ string ] gcs . Upload Func { } var failed bool var main Ref SHA string if o . Log ! = " " { if failed , main Ref SHA , err = process Clone Log ( o . Log , upload Targets ) ; err ! = nil { return err } } started : = spec To Started ( spec , main Ref SHA ) started Data , err : = json . Marshal ( & started ) if err ! = nil { return fmt . Errorf ( " " , err ) } upload Targets [ " " ] = gcs . Data Upload ( bytes . New Reader ( started Data ) ) if err : = o . Options . Run ( spec , upload Targets ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if failed { return errors . New ( " " ) } return nil } 
func process Clone Log ( logfile string , upload Targets map [ string ] gcs . Upload Func ) ( bool , string , error ) { var clone Records [ ] clone . Record data , err : = ioutil . Read File ( logfile ) if err ! = nil { return true , " " , fmt . Errorf ( " " , err ) } if err = json . Unmarshal ( data , & clone Records ) ; err ! = nil { return true , " " , fmt . Errorf ( " " , err ) } var failed bool var main Ref SHA string for idx , record : = range clone Records { clone Log . Write String ( clone . Format Record ( record ) ) failed = failed | | record . Failed } } upload Targets [ " " ] = gcs . Data Upload ( bytes . New Reader ( clone Log . Bytes ( ) ) ) upload Targets [ " " ] = gcs . File Upload ( logfile ) if failed { upload Targets [ " " ] = gcs . Data Upload ( bytes . New Reader ( clone Log . Bytes ( ) ) ) passed : = ! failed now : = time . Now ( ) . Unix ( ) finished : = gcs . Finished { Timestamp : & now , Passed : & passed , Result : " " , } finished Data , err : = json . Marshal ( & finished ) if err ! = nil { return true , main Ref SHA , fmt . Errorf ( " " , err ) } upload Targets [ " " ] = gcs . Data Upload ( bytes . New Reader ( finished Data ) ) } return failed , main Ref SHA , nil } 
func has PRChanged ( pr github . Pull Request Event ) bool { switch pr . Action { case github . Pull Request Action Opened : return true case github . Pull Request Action Reopened : return true case github . Pull Request Action Synchronize : return true default : return false } } 
func Update Issues ( db * gorm . DB , client Client Interface ) { latest , err : = find Latest Issue Update ( db , client . Repository Name ( ) ) if err ! = nil { glog . Error ( " " , err ) return } c : = make ( chan * github . Issue , 2 0 0 ) go client . Fetch Issues ( latest , c ) for issue : = range c { issue Orm , err : = New Issue ( issue , client . Repository Name ( ) ) if err ! = nil { glog . Error ( " " , err ) continue } if db . Create ( issue Orm ) . Error ! = nil { db . Delete ( sql . Assignee { } , " " , issue Orm . ID , client . Repository Name ( ) ) if err : = db . Save ( issue Orm ) . Error ; err ! = nil { glog . Error ( " " , err ) } } } } 
func handle Review Event ( pc plugins . Agent , re github . Review Event ) error { return handle Review ( pc . Logger , pc . Git Hub Client , pc . Owners Client , pc . Config . Git Hub Options , pc . Plugin Config , & re , ) } 
func find Associated Issue ( body , org string ) ( int , error ) { associated Issue Regex , err : = regexp . Compile ( fmt . Sprintf ( associated Issue Regex Format , org ) ) if err ! = nil { return 0 , err } match : = associated Issue Regex . Find String Submatch ( body ) if len ( match ) = = 0 { return 0 , nil } v , err : = strconv . Atoi ( match [ 1 ] ) if err ! = nil { return 0 , err } return v , nil } 
func handle ( log * logrus . Entry , ghc github Client , repo approvers . Repo , github Config config . Git Hub Options , opts * plugins . Approve , pr * state ) error { fetch Err : = func ( context string , err error ) error { return fmt . Errorf ( " " , context , pr . org , pr . repo , pr . number , err ) } changes , err : = ghc . Get Pull Request Changes ( pr . org , pr . repo , pr . number ) if err ! = nil { return fetch Err ( " " , err ) } var filenames [ ] string for _ , change : = range changes { filenames = append ( filenames , change . Filename ) } issue Labels , err : = ghc . Get Issue Labels ( pr . org , pr . repo , pr . number ) if err ! = nil { return fetch Err ( " " , err ) } has Approved Label : = false for _ , label : = range issue Labels { if label . Name = = labels . Approved { has Approved Label = true break } } bot Name , err : = ghc . Bot Name ( ) if err ! = nil { return fetch Err ( " " , err ) } issue Comments , err : = ghc . List Issue Comments ( pr . org , pr . repo , pr . number ) if err ! = nil { return fetch Err ( " " , err ) } review Comments , err : = ghc . List Pull Request Comments ( pr . org , pr . repo , pr . number ) if err ! = nil { return fetch Err ( " " , err ) } reviews , err : = ghc . List Reviews ( pr . org , pr . repo , pr . number ) if err ! = nil { return fetch Err ( " " , err ) } approvers Handler : = approvers . New Approvers ( approvers . New Owners ( log , filenames , repo , int 6 4 ( pr . number ) , ) , ) approvers Handler . Associated Issue , err = find Associated Issue ( pr . body , pr . org ) if err ! = nil { log . With Error ( err ) . Errorf ( " " , err ) } approvers Handler . Require Issue = opts . Issue Required approvers Handler . Manually Approved = human Added Approved ( ghc , log , pr . org , pr . repo , pr . number , bot Name , has Approved Label ) } else { } comments From Issue Comments : = comments From Issue Comments ( issue Comments ) comments : = append ( comments From Review Comments ( review Comments ) , comments From Issue Comments . . . ) comments = append ( comments , comments From Reviews ( reviews ) . . . ) sort . Slice Stable ( comments , func ( i , j int ) bool { return comments [ i ] . Created At . Before ( comments [ j ] . Created At ) } ) approve Comments : = filter Comments ( comments , approval Matcher ( bot Name , opts . Lgtm Acts As Approve , opts . Consider Review State ( ) ) ) add Approvers ( & approvers Handler , approve Comments , pr . author , opts . Consider Review State ( ) ) for _ , user : = range pr . assignees { approvers Handler . Add Assignees ( user . Login ) } notifications : = filter Comments ( comments From Issue Comments , notification Matcher ( bot Name ) ) latest Notification : = get Last ( notifications ) new Message : = update Notification ( github Config . Link URL , pr . org , pr . repo , pr . branch , latest Notification , approvers Handler ) if new Message ! = nil { for _ , notif : = range notifications { if err : = ghc . Delete Comment ( pr . org , pr . repo , notif . ID ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , pr . org , pr . repo , pr . number , notif . ID ) } } if err : = ghc . Create Comment ( pr . org , pr . repo , pr . number , * new Message ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , pr . org , pr . repo , pr . number , * new Message ) } } if ! approvers Handler . Is Approved ( ) { if has Approved Label { if err : = ghc . Remove Label ( pr . org , pr . repo , pr . number , labels . Approved ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , labels . Approved , pr . org , pr . repo , pr . number ) } } } else if ! has Approved Label { if err : = ghc . Add Label ( pr . org , pr . repo , pr . number , labels . Approved ) ; err ! = nil { log . With Error ( err ) . Errorf ( " " , labels . Approved , pr . org , pr . repo , pr . number ) } } return nil } 
func add Approvers ( approvers Handler * approvers . Approvers , approve Comments [ ] * comment , author string , review Acts As Approve bool ) { for _ , c : = range approve Comments { if c . Author = = " " { continue } if review Acts As Approve & & c . Review State = = github . Review State Approved { approvers Handler . Add Approver ( c . Author , c . HTMLURL , false , ) } if review Acts As Approve & & c . Review State = = github . Review State Changes Requested { approvers Handler . Remove Approver ( c . Author ) } for _ , match : = range command Regex . Find All String Submatch ( c . Body , - 1 ) { name : = strings . To Upper ( match [ 1 ] ) if name ! = approve Command & & name ! = lgtm Command { continue } args : = strings . To Lower ( strings . Trim Space ( match [ 2 ] ) ) if strings . Contains ( args , cancel Argument ) { approvers Handler . Remove Approver ( c . Author ) continue } if c . Author = = author { approvers Handler . Add Author Self Approver ( c . Author , c . HTMLURL , args = = no Issue Argument , ) } if name = = approve Command { approvers Handler . Add Approver ( c . Author , c . HTMLURL , args = = no Issue Argument , ) } else { approvers Handler . Add LGTMer ( c . Author , c . HTMLURL , args = = no Issue Argument , ) } } } } 
func options For Repo ( config * plugins . Configuration , org , repo string ) * plugins . Approve { full Name : = fmt . Sprintf ( " " , org , repo ) a : = func ( ) * plugins . Approve { } return & c } } return & c } } ( ) if a . Deprecated Implicit Self Approve = = nil & & a . Require Self Approval = = nil & & config . Use Deprecated Self Approve { no : = false a . Deprecated Implicit Self Approve = & no } if a . Deprecated Review Acts As Approve = = nil & & a . Ignore Review State = = nil & & config . Use Deprecated Review Approve { no : = false a . Deprecated Review Acts As Approve = & no } return a } 
func local Only Main ( cfg config . Getter , o options , mux * http . Serve Mux ) * http . Serve Mux { mux . Handle ( " " , gziphandler . Gzip Handler ( handle Simple Template ( o , cfg , " " , nil ) ) ) if o . spyglass { init Spyglass ( cfg , o , mux , nil ) } return mux } 
func prod Only Main ( cfg config . Getter , o options , mux * http . Serve Mux ) * http . Serve Mux { prow Job Client , err : = o . kubernetes . Prow Job Client ( cfg ( ) . Prow Job Namespace , false ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } build Cluster Clients , err : = o . kubernetes . Build Cluster Clients ( cfg ( ) . Pod Namespace , false ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } pod Log Clients : = map [ string ] jobs . Pod Log Client { } for cluster Context , client : = range build Cluster Clients { pod Log Clients [ cluster Context ] = & pod Log Client { client : client } } ja : = jobs . New Job Agent ( & filtering Prow Job Lister { client : prow Job Client , hidden Repos : sets . New String ( cfg ( ) . Deck . Hidden Repos . . . ) , hidden Only : o . hidden Only , show Hidden : o . show Hidden , } , pod Log Clients , cfg ) ja . Start ( ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Prow Jobs ( ja ) ) ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Badge ( ja ) ) ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Log ( ja ) ) ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Rerun ( prow Job Client ) ) ) if o . spyglass { init Spyglass ( cfg , o , mux , ja ) } if o . hook URL ! = " " { mux . Handle ( " " , gziphandler . Gzip Handler ( handle Plugin Help ( new Help Agent ( o . hook URL ) ) ) ) } if o . tide URL ! = " " { ta : = & tide Agent { log : logrus . With Field ( " " , " " ) , path : o . tide URL , update Period : func ( ) time . Duration { return cfg ( ) . Deck . Tide Update Period } , hidden Repos : cfg ( ) . Deck . Hidden Repos , hidden Only : o . hidden Only , show Hidden : o . show Hidden , } ta . start ( ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Tide Pools ( cfg , ta ) ) ) mux . Handle ( " " , gziphandler . Gzip Handler ( handle Tide History ( ta ) ) ) } if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } cookie Secret Raw , err : = load Token ( o . cookie Secret File ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } var github OAuth Config config . Git Hub OAuth Config if err : = yaml . Unmarshal ( github OAuth Config Raw , & github OAuth Config ) ; err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } if ! is Validated Git OAuth Config ( & github OAuth Config ) { logrus . Fatal ( " " ) } decoded Secret , err : = base 6 4 . Std Encoding . Decode String ( string ( cookie Secret Raw ) ) if err ! = nil { logrus . With Error ( err ) . Fatal ( " " ) } if len ( decoded Secret ) = = 0 { logrus . Fatal ( " " ) } cookie : = sessions . New Cookie Store ( decoded Secret ) github OAuth Config . Init Git Hub OAuth Config ( cookie ) goa : = githuboauth . New Agent ( & github OAuth Config , logrus . With Field ( " " , " " ) ) oauth Client : = & oauth 2 . Config { Client ID : github OAuth Config . Client ID , Client Secret : github OAuth Config . Client Secret , Redirect URL : github OAuth Config . Redirect URL , Scopes : github OAuth Config . Scopes , Endpoint : github . Endpoint , } repo Set : = make ( map [ string ] bool ) for r : = range cfg ( ) . Presubmits { repo Set [ r ] = true } for _ , q : = range cfg ( ) . Tide . Queries { for _ , v : = range q . Repos { repo Set [ v ] = true } } var repos [ ] string for k , v : = range repo Set { if v { repos = append ( repos , k ) } } pr Status Agent : = prstatus . New Dashboard Agent ( repos , & github OAuth Config , logrus . With Field ( " " , " " ) ) mux . Handle ( " " , handle Not Cached ( pr Status Agent . Handle Pr Status ( pr Status Agent ) ) ) } redirect Mux . Handle ( " " , func ( old Mux * http . Serve Mux , host string ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { if r . Header . Get ( " " ) = = " " { redirect URL , err : = url . Parse ( r . URL . String ( ) ) if err ! = nil { logrus . Errorf ( " " , r . URL . String ( ) ) http . Error ( w , " " , http . Status Internal Server Error ) return } redirect URL . Scheme = " " redirect URL . Host = host http . Redirect ( w , r , redirect URL . String ( ) , http . Status Moved Permanently ) } else { old Mux . Serve HTTP ( w , r ) } } } ( mux , o . redirect HTTPTo ) ) mux = redirect Mux } return mux } 
func dupe Request ( original * http . Request ) * http . Request { r 2 : = new ( http . Request ) * r 2 = * original r 2 . URL = new ( url . URL ) * r 2 . URL = * original . URL return r 2 } 
func handle Badge ( ja * jobs . Job Agent ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { set Headers No Caching ( w ) want Jobs : = r . URL . Query ( ) . Get ( " " ) if want Jobs = = " " { http . Error ( w , " " , http . Status Bad Request ) return } w . Header ( ) . Set ( " " , " " ) all Jobs : = ja . Prow Jobs ( ) _ , _ , svg : = render Badge ( pick Latest Jobs ( all Jobs , want Jobs ) ) w . Write ( svg ) } } 
func handle Job History ( o options , cfg config . Getter , gcs Client * storage . Client ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { set Headers No Caching ( w ) tmpl , err : = get Job History ( r . URL , cfg ( ) , gcs Client ) if err ! = nil { msg : = fmt . Sprintf ( " " , err ) logrus . With Field ( " " , r . URL ) . Error ( msg ) http . Error ( w , msg , http . Status Internal Server Error ) return } handle Simple Template ( o , cfg , " " , tmpl ) ( w , r ) } } 
func handle Request Job Views ( sg * spyglass . Spyglass , cfg config . Getter , o options ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { start : = time . Now ( ) set Headers No Caching ( w ) src : = strings . Trim Prefix ( r . URL . Path , " " ) page , err : = render Spyglass ( sg , cfg , src , o ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) message : = fmt . Sprintf ( " " , err ) http . Error ( w , message , http . Status Internal Server Error ) return } fmt . Fprint ( w , page ) elapsed : = time . Since ( start ) logrus . With Fields ( logrus . Fields { " " : elapsed . String ( ) , " " : r . URL . Path , " " : src , } ) . Info ( " " ) } } 
func render Spyglass ( sg * spyglass . Spyglass , cfg config . Getter , src string , o options ) ( string , error ) { render Start : = time . Now ( ) src = strings . Trim Suffix ( src , " " ) real Path , err : = sg . Resolve Symlink ( src ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } src = real Path artifact Names , err : = sg . List Artifacts ( src ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } if len ( artifact Names ) = = 0 { return " " , fmt . Errorf ( " " , src ) } viewer Cache : = map [ string ] [ ] string { } viewers Registry : = cfg ( ) . Deck . Spyglass . Viewers regex Cache : = cfg ( ) . Deck . Spyglass . Regex Cache for re , viewer Names : = range viewers Registry { matches : = [ ] string { } for _ , a : = range artifact Names { if regex Cache [ re ] . Match String ( a ) { matches = append ( matches , a ) } } if len ( matches ) > 0 { for _ , v Name : = range viewer Names { viewer Cache [ v Name ] = matches } } } ls : = sg . Lenses ( viewer Cache ) lens Names : = [ ] string { } for _ , l : = range ls { lens Names = append ( lens Names , l . Config ( ) . Name ) } job Hist Link : = " " job Path , err : = sg . Job Path ( src ) if err = = nil { job Hist Link = path . Join ( " " , job Path ) } artifacts Link : = " " gcsweb Prefix : = cfg ( ) . Deck . Spyglass . GCSBrowser Prefix if gcsweb Prefix ! = " " { run Path , err : = sg . Run Path ( src ) if err = = nil { artifacts Link = gcsweb Prefix + run Path } } } pr Hist Link : = " " org , repo , number , err : = sg . Run To PR ( src ) if err = = nil { pr Hist Link = " " + org + " " + repo + " " + strconv . Itoa ( number ) } job Name , build ID , err : = sg . Key To Job ( src ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } announcement : = " " if cfg ( ) . Deck . Spyglass . Announcement ! = " " { announcement Tmpl , err : = template . New ( " " ) . Parse ( cfg ( ) . Deck . Spyglass . Announcement ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } run Path , err : = sg . Run Path ( src ) if err ! = nil { run Path = " " } var announcement Buf bytes . Buffer err = announcement Tmpl . Execute ( & announcement Buf , struct { Artifact Path string } { Artifact Path : run Path , } ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } announcement = announcement Buf . String ( ) } tg Link , err : = sg . Test Grid Link ( src ) if err ! = nil { tg Link = " " } extra Links , err : = sg . Extra Links ( src ) if err ! = nil { logrus . With Error ( err ) . With Field ( " " , src ) . Warn ( " " ) extra Links = nil } var view Buf bytes . Buffer type lenses Template struct { Lenses [ ] lenses . Lens Lens Names [ ] string Source string Lens Artifacts map [ string ] [ ] string Job Hist Link string Artifacts Link string PRHist Link string Announcement template . HTML Testgrid Link string Job Name string Build ID string Extra Links [ ] spyglass . Extra Link } l Tmpl : = lenses Template { Lenses : ls , Lens Names : lens Names , Source : src , Lens Artifacts : viewer Cache , Job Hist Link : job Hist Link , Artifacts Link : artifacts Link , PRHist Link : pr Hist Link , Announcement : template . HTML ( announcement ) , Testgrid Link : tg Link , Job Name : job Name , Build ID : build ID , Extra Links : extra Links , } t : = template . New ( " " ) if _ , err : = prepare Base Template ( o , cfg , t ) ; err ! = nil { return " " , fmt . Errorf ( " " , err ) } t , err = t . Parse Files ( path . Join ( o . template Files Location , " " ) ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } if err = t . Execute ( & view Buf , l Tmpl ) ; err ! = nil { return " " , fmt . Errorf ( " " , err ) } render Elapsed : = time . Since ( render Start ) logrus . With Fields ( logrus . Fields { " " : render Elapsed . String ( ) , " " : src , } ) . Info ( " " ) return view Buf . String ( ) , nil } 
func handle Artifact View ( o options , sg * spyglass . Spyglass , cfg config . Getter ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { set Headers No Caching ( w ) path Segments : = strings . Split ( r . URL . Path , " " ) if len ( path Segments ) ! = 2 { http . Not Found ( w , r ) return } lens Name : = path Segments [ 0 ] resource : = path Segments [ 1 ] lens , err : = lenses . Get Lens ( lens Name ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , lens Name , err ) , http . Status Not Found ) return } lens Config : = lens . Config ( ) lens Resources Dir : = lenses . Resource Dir For Lens ( o . spyglass Files Location , lens Config . Name ) req String : = r . URL . Query ( ) . Get ( " " ) var request spyglass . Lens Request err = json . Unmarshal ( [ ] byte ( req String ) , & request ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Bad Request ) return } artifacts , err : = sg . Fetch Artifacts ( request . Source , " " , cfg ( ) . Deck . Spyglass . Size Limit , request . Artifacts ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Internal Server Error ) return } switch resource { case " " : t , err : = template . Parse Files ( path . Join ( o . template Files Location , " " ) ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Internal Server Error ) return } w . Header ( ) . Set ( " " , " " ) t . Execute ( w , struct { Title string Base URL string Head template . HTML Body template . HTML } { lens Config . Title , " " + lens Name + " " , template . HTML ( lens . Header ( artifacts , lens Resources Dir ) ) , template . HTML ( lens . Body ( artifacts , lens Resources Dir , " " ) ) , } ) case " " : data , err : = ioutil . Read All ( r . Body ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Internal Server Error ) return } w . Header ( ) . Set ( " " , " " ) w . Write ( [ ] byte ( lens . Body ( artifacts , lens Resources Dir , string ( data ) ) ) ) case " " : data , err : = ioutil . Read All ( r . Body ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Internal Server Error ) return } w . Write ( [ ] byte ( lens . Callback ( artifacts , lens Resources Dir , string ( data ) ) ) ) default : http . Not Found ( w , r ) } } } 
func handle Log ( lc log Client ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { set Headers No Caching ( w ) w . Header ( ) . Set ( " " , " " ) job : = r . URL . Query ( ) . Get ( " " ) id : = r . URL . Query ( ) . Get ( " " ) logger : = logrus . With Fields ( logrus . Fields { " " : job , " " : id } ) if err : = validate Log Request ( r ) ; err ! = nil { http . Error ( w , err . Error ( ) , http . Status Bad Request ) return } log , err : = lc . Get Job Log ( job , id ) if err ! = nil { http . Error ( w , fmt . Sprintf ( " " , err ) , http . Status Not Found ) logger : = logger . With Error ( err ) msg : = " " if strings . Contains ( err . Error ( ) , " " ) { } else { logger . Warning ( msg ) } return } if _ , err = w . Write ( log ) ; err ! = nil { logger . With Error ( err ) . Warning ( " " ) } } } 
func new Coverage List ( name string ) * Coverage List { return & Coverage List { Coverage : & Coverage { Name : name } , Group : [ ] Coverage { } , } } 
func ( cov List * Coverage List ) summarize ( ) { cov List . Num Covered Stmts = 0 cov List . Num All Stmts = 0 for _ , item : = range cov List . Group { cov List . Num Covered Stmts + = item . Num Covered Stmts cov List . Num All Stmts + = item . Num All Stmts } } 
func ( cov List * Coverage List ) Subset ( prefix string ) * Coverage List { s : = new Coverage List ( " " ) for _ , c : = range cov List . Group { if strings . Has Prefix ( c . Name , prefix ) { cov List . Group = append ( cov List . Group , c ) } } return s } 
func ( cov List Coverage List ) List Directories ( ) [ ] string { dir Set : = map [ string ] bool { } for _ , cov : = range cov List . Group { dir Set [ path . Dir ( cov . Name ) ] = true } var result [ ] string for key : = range dir Set { result = append ( result , key ) } return result } 
func read Request ( r io . Reader , content Type string ) ( * admissionapi . Admission Request , error ) { if content Type ! = content Type JSON { return nil , fmt . Errorf ( " " , content Type , content Type JSON ) } } body , err : = ioutil . Read All ( r ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } deserializer : = codecs . Universal Deserializer ( ) if _ , _ , err : = deserializer . Decode ( body , nil , & ar ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return ar . Request , nil } 
func handle ( w http . Response Writer , r * http . Request ) { req , err : = read Request ( r . Body , r . Header . Get ( " " ) ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) } if err : = write Response ( * req , w , only Update Status ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } 
func write Response ( ar admissionapi . Admission Request , w io . Writer , decide decider ) error { response , err : = decide ( ar ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) response = & admissionapi . Admission Response { Result : & meta . Status { Message : err . Error ( ) , } , } } var result admissionapi . Admission Review result . Response = response result . Response . UID = ar . UID out , err : = json . Marshal ( result ) if err ! = nil { return fmt . Errorf ( " " , err ) } if _ , err : = w . Write ( out ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func only Update Status ( req admissionapi . Admission Request ) ( * admissionapi . Admission Response , error ) { logger : = logrus . With Fields ( logrus . Fields { " " : req . Resource , " " : req . Sub Resource , " " : req . Name , " " : req . Namespace , " " : req . Operation , } ) return & allow , nil } if _ , _ , err : = codecs . Universal Deserializer ( ) . Decode ( req . Object . Raw , nil , & new ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } var old prowjobv 1 . Prow Job if _ , _ , err : = codecs . Universal Deserializer ( ) . Decode ( req . Old Object . Raw , nil , & old ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if equality . Semantic . Deep Equal ( old . Spec , new . Spec ) { logrus . Info ( " " ) return & allow , nil } logger . Info ( " " ) return & reject , nil } 
func convert Suite Meta ( suite Meta gcs . Suites Meta ) resultstore . Suite { out : = resultstore . Suite { Name : path . Base ( suite Meta . Path ) , Files : [ ] resultstore . File { { Content Type : " " , ID : resultstore . UUID ( ) , URL : suite Meta . Path , for _ , suite : = range suite Meta . Suites . Suites { child : = resultstore . Suite { Name : suite . Name , Duration : dur ( suite . Time ) , } switch { case suite . Failures > 0 & & suite . Tests > = suite . Failures : child . Failures = append ( child . Failures , resultstore . Failure { Message : fmt . Sprintf ( " " , suite . Failures , suite . Tests , float 6 4 ( suite . Tests - suite . Failures ) * 1 0 0 . 0 / float 6 4 ( suite . Tests ) ) , } ) case suite . Failures > 0 : child . Failures = append ( child . Failures , resultstore . Failure { Message : fmt . Sprintf ( " " , suite . Failures ) , } ) } for _ , result : = range suite . Results { name , tags : = strip Tags ( result . Name ) class : = result . Class Name if class = = " " { class = strings . Join ( tags , " " ) } else { class + = " " + strings . Join ( tags , " " ) } c : = resultstore . Case { Name : name , Class : class , Duration : dur ( result . Time ) , Result : resultstore . Completed , } const max = 5 0 0 0 msg : = result . Message ( max ) switch { case result . Failure ! = nil : } c . Failures = append ( c . Failures , resultstore . Failure { Message : msg , } ) case result . Skipped ! = nil : c . Result = resultstore . Skipped if msg ! = " " { } } child . Cases = append ( child . Cases , c ) if c . Duration > child . Duration { child . Duration = c . Duration } } if child . Duration > out . Duration { } out . Suites = append ( out . Suites , child ) } return out } 
func convert ( project , details string , url gcs . Path , result download Result ) ( resultstore . Invocation , resultstore . Target , resultstore . Test ) { started : = result . started finished : = result . finished artifacts : = result . artifact URLs base Path : = trailing Slash ( url . String ( ) ) artifacts Path : = base Path + " " build Log : = base Path + " " bucket : = url . Bucket ( ) inv : = resultstore . Invocation { Project : project , Details : details , Files : [ ] resultstore . File { { ID : resultstore . Invocation Log , Content Type : " " , URL : build Log , for i , a : = range artifacts { artifacts [ i ] = " " + bucket + " " + a } for _ , a : = range artifacts { } if a = = build Log { continue } inv . Files = append ( inv . Files , resultstore . File { ID : uniq Path ( a ) , Content Type : " " , URL : a , } ) } if started . Timestamp > 0 { inv . Start = time . Unix ( started . Timestamp , 0 ) if finished . Timestamp ! = nil { inv . Duration = time . Duration ( * finished . Timestamp - started . Timestamp ) * time . Second } } const day = 2 4 * 6 0 * 6 0 switch { case finished . Timestamp = = nil & & started . Timestamp < time . Now ( ) . Unix ( ) + day : inv . Status = resultstore . Running inv . Description = " " case finished . Passed ! = nil & & * finished . Passed : inv . Status = resultstore . Passed inv . Description = " " case finished . Timestamp = = nil : inv . Status = resultstore . Failed inv . Description = " " default : inv . Status = resultstore . Failed inv . Description = " " } test : = resultstore . Test { Action : resultstore . Action { Node : started . Node , } , Suite : resultstore . Suite { Name : " " , Files : [ ] resultstore . File { { ID : resultstore . Target Log , Content Type : " " , URL : build Log , for _ , suite Meta : = range result . suite Metas { child : = convert Suite Meta ( suite Meta ) test . Suite . Suites = append ( test . Suite . Suites , child ) test . Suite . Files = append ( test . Suite . Files , child . Files . . . ) } for _ , a : = range artifacts { if ! strings . Has Prefix ( a , artifacts Path ) { continue } if a = = build Log { continue } for _ , sm : = range result . suite Metas { if sm . Path = = a { found = true break } } if found { continue } test . Suite . Files = append ( test . Suite . Files , resultstore . File { ID : uniq Path ( a ) , Content Type : " " , URL : a , } ) } test . Suite . Start = inv . Start test . Action . Start = inv . Start test . Suite . Duration = inv . Duration test . Action . Duration = inv . Duration test . Status = inv . Status test . Description = inv . Description target : = resultstore . Target { Start : inv . Start , Duration : inv . Duration , Status : inv . Status , Description : inv . Description , } return inv , target , test } 
func New Health ( ) * Health { health Mux : = http . New Serve Mux ( ) health Mux . Handle Func ( " " , func ( w http . Response Writer , r * http . Request ) { fmt . Fprint ( w , " " ) } ) go func ( ) { logrus . With Error ( http . Listen And Serve ( " " + strconv . Itoa ( health Port ) , health Mux ) ) . Fatal ( " " ) } ( ) return & Health { health Mux : health Mux , } } 
func ( h * Health ) Serve Ready ( ) { h . health Mux . Handle Func ( " " , func ( w http . Response Writer , r * http . Request ) { fmt . Fprint ( w , " " ) } ) } 
func New Controller ( ghc Sync , ghc Status * github . Client , prow Job Client prowv 1 . Prow Job Interface , cfg config . Getter , gc * git . Client , max Records Per Pool int , opener io . Opener , history URI , status URI string , logger * logrus . Entry ) ( * Controller , error ) { if logger = = nil { logger = logrus . New Entry ( logrus . Standard Logger ( ) ) } hist , err : = history . New ( max Records Per Pool , opener , history URI ) if err ! = nil { return nil , fmt . Errorf ( " " , history URI , err ) } sc : = & status Controller { logger : logger . With Field ( " " , " " ) , ghc : ghc Status , config : cfg , new Pool Pending : make ( chan bool , 1 ) , shut Down : make ( chan bool ) , opener : opener , path : status URI , } go sc . run ( ) return & Controller { logger : logger . With Field ( " " , " " ) , ghc : ghc Sync , prow Job Client : prow Job Client , config : cfg , gc : gc , sc : sc , changed Files : & changed Files Agent { ghc : ghc Sync , next Change Cache : make ( map [ change Cache Key ] [ ] string ) , } , History : hist , } , nil } 
func by Repo And Number ( prs [ ] Pull Request ) map [ string ] Pull Request { m : = make ( map [ string ] Pull Request ) for _ , pr : = range prs { key : = pr Key ( & pr ) m [ key ] = pr } return m } 
func new Expected Context ( c string ) Context { return Context { Context : githubql . String ( c ) , State : githubql . Status State Expected , Description : githubql . String ( " " ) , } } 
func contexts To Strings ( contexts [ ] Context ) [ ] string { var names [ ] string for _ , c : = range contexts { names = append ( names , string ( c . Context ) ) } return names } 
func ( c * Controller ) Sync ( ) error { start : = time . Now ( ) defer func ( ) { duration : = time . Since ( start ) c . logger . With Field ( " " , duration . String ( ) ) . Info ( " " ) tide Metrics . sync Duration . Set ( duration . Seconds ( ) ) } ( ) defer c . changed Files . prune ( ) c . logger . Debug ( " " ) prs : = make ( map [ string ] Pull Request ) for _ , query : = range c . config ( ) . Tide . Queries { q : = query . Query ( ) results , err : = search ( c . ghc . Query , c . logger , q , time . Time { } , time . Now ( ) ) if err ! = nil & & len ( results ) = = 0 { return fmt . Errorf ( " " , q , err ) } if err ! = nil { c . logger . With Error ( err ) . With Field ( " " , q ) . Warning ( " " ) } for _ , pr : = range results { prs [ pr Key ( & pr ) ] = pr } } c . logger . With Field ( " " , time . Since ( start ) . String ( ) , ) . Debugf ( " " , len ( prs ) ) var pjs [ ] prowapi . Prow Job var blocks blockers . Blockers var err error if len ( prs ) > 0 { start : = time . Now ( ) pj List , err : = c . prow Job Client . List ( metav 1 . List Options { Label Selector : labels . Everything ( ) . String ( ) } ) if err ! = nil { c . logger . With Field ( " " , time . Since ( start ) . String ( ) ) . Debug ( " " ) return err } c . logger . With Field ( " " , time . Since ( start ) . String ( ) ) . Debug ( " " ) pjs = pj List . Items if label : = c . config ( ) . Tide . Blocker Label ; label ! = " " { c . logger . Debugf ( " " , label ) org Excepts , repos : = c . config ( ) . Tide . Queries . Org Exceptions And Repos ( ) orgs : = make ( [ ] string , 0 , len ( org Excepts ) ) for org : = range org Excepts { orgs = append ( orgs , org ) } org Repo Query : = org Repo Query String ( orgs , repos . Unsorted List ( ) , org Excepts ) blocks , err = blockers . Find All ( c . ghc , c . logger , label , org Repo Query ) if err ! = nil { return err } } } if err ! = nil { return err } filtered Pools : = c . filter Subpools ( c . config ( ) . Tide . Max Goroutines , raw Pools ) c . sc . pool PRs = pool PRMap ( filtered Pools ) select { case c . sc . new Pool Pending < - true : default : } c . sc . Unlock ( ) subpools In Parallel ( c . config ( ) . Tide . Max Goroutines , filtered Pools , func ( sp * subpool ) { pool , err : = c . sync Subpool ( * sp , blocks . Get Applicable ( sp . org , sp . repo , sp . branch ) ) if err ! = nil { sp . log . With Error ( err ) . Errorf ( " " ) } pool Chan < - pool } , ) close ( pool Chan ) pools : = make ( [ ] Pool , 0 , len ( pool Chan ) ) for pool : = range pool Chan { pools = append ( pools , pool ) } sort Pools ( pools ) c . m . Lock ( ) c . pools = pools c . m . Unlock ( ) c . History . Flush ( ) return nil } 
func ( c * Controller ) filter Subpools ( goroutines int , raw map [ string ] * subpool ) map [ string ] * subpool { filtered : = make ( map [ string ] * subpool ) var lock sync . Mutex subpools In Parallel ( goroutines , raw , func ( sp * subpool ) { if err : = c . init Subpool Data ( sp ) ; err ! = nil { sp . log . With Error ( err ) . Error ( " " ) return } key : = pool Key ( sp . org , sp . repo , sp . branch ) if sp Filtered : = filter Subpool ( c . ghc , sp ) ; sp Filtered ! = nil { sp . log . With Field ( " " , key ) . With Field ( " " , sp Filtered ) . Debug ( " " ) lock . Lock ( ) filtered [ key ] = sp Filtered lock . Unlock ( ) } else { sp . log . With Field ( " " , key ) . With Field ( " " , sp Filtered ) . Debug ( " " ) } } , ) return filtered } 
func filter Subpool ( ghc github Client , sp * subpool ) * subpool { var to Keep [ ] Pull Request for _ , pr : = range sp . prs { if ! filter PR ( ghc , sp , & pr ) { to Keep = append ( to Keep , pr ) } } if len ( to Keep ) = = 0 { return nil } sp . prs = to Keep return sp } 
func filter PR ( ghc github Client , sp * subpool , pr * Pull Request ) bool { log : = sp . log . With Fields ( pr . log Fields ( ) ) return true } if err ! = nil { log . With Error ( err ) . Error ( " " ) return true } presubmits Have Context : = func ( context string ) bool { for _ , job : = range sp . presubmits [ int ( pr . Number ) ] { if job . Context = = context { return true } } return false } for _ , ctx : = range unsuccessful Contexts ( contexts , sp . cc , log ) { if ctx . State ! = githubql . Status State Pending { log . With Field ( " " , ctx . Context ) . Debug ( " " ) return true } if ! presubmits Have Context ( string ( ctx . Context ) ) { log . With Field ( " " , ctx . Context ) . Debug ( " " ) return true } } return false } 
func pool PRMap ( subpool Map map [ string ] * subpool ) map [ string ] Pull Request { prs : = make ( map [ string ] Pull Request ) for _ , sp : = range subpool Map { for _ , pr : = range sp . prs { prs [ pr Key ( & pr ) ] = pr } } return prs } 
func unsuccessful Contexts ( contexts [ ] Context , cc context Checker , log * logrus . Entry ) [ ] Context { var failed [ ] Context for _ , ctx : = range contexts { if string ( ctx . Context ) = = status Context { continue } if cc . Is Optional ( string ( ctx . Context ) ) { continue } if ctx . State ! = githubql . Status State Success { failed = append ( failed , ctx ) } } for _ , c : = range cc . Missing Required Contexts ( contexts To Strings ( contexts ) ) { failed = append ( failed , new Expected Context ( c ) ) } log . Debugf ( " " , len ( contexts ) , contexts To Strings ( contexts ) , len ( failed ) , contexts To Strings ( failed ) ) return failed } 
func accumulate Batch ( presubmits map [ int ] [ ] config . Presubmit , prs [ ] Pull Request , pjs [ ] prowapi . Prow Job , log * logrus . Entry ) ( [ ] Pull Request , [ ] Pull Request ) { log . Debug ( " " ) if len ( presubmits ) = = 0 { log . Debug ( " " ) return nil , nil } pr Nums : = make ( map [ int ] Pull Request ) for _ , pr : = range prs { pr Nums [ int ( pr . Number ) ] = pr } type acc State struct { prs [ ] Pull Request job States map [ string ] simple State } states : = make ( map [ string ] * acc State ) for _ , pj : = range pjs { if pj . Spec . Type ! = prowapi . Batch Job { continue } if _ , ok : = states [ ref ] ; ! ok { state : = & acc State { job States : make ( map [ string ] simple State ) , valid Pulls : true , } for _ , pull : = range pj . Spec . Refs . Pulls { if pr , ok : = pr Nums [ pull . Number ] ; ok & & string ( pr . Head Ref OID ) = = pull . SHA { state . prs = append ( state . prs , pr ) } else if ! ok { state . valid Pulls = false log . With Field ( " " , ref ) . With Fields ( pr . log Fields ( ) ) . Debug ( " " ) break } else { state . valid Pulls = false log . With Field ( " " , ref ) . With Fields ( pr . log Fields ( ) ) . Debug ( " " ) break } } states [ ref ] = state } if ! states [ ref ] . valid Pulls { } job State : = to Simple State ( pj . Status . State ) } } var pending Batch , success Batch [ ] Pull Request for ref , state : = range states { if ! state . valid Pulls { continue } required Presubmits : = sets . New String ( ) for _ , pr : = range state . prs { for _ , job : = range presubmits [ int ( pr . Number ) ] { required Presubmits . Insert ( job . Context ) } } overall State : = success State for _ , p : = range required Presubmits . List ( ) { if s , ok : = state . job States [ p ] ; ! ok | | s = = failure State { overall State = failure State log . With Field ( " " , ref ) . Debugf ( " " , p ) break } else if s = = pending State & & overall State = = success State { overall State = pending State } } switch overall State { case success State : success Batch = state . prs } } return success Batch , pending Batch } 
func accumulate ( presubmits map [ int ] [ ] config . Presubmit , prs [ ] Pull Request , pjs [ ] prowapi . Prow Job , log * logrus . Entry ) ( successes , pendings , nones [ ] Pull Request ) { for _ , pr : = range prs { for _ , pj : = range pjs { if pj . Spec . Type ! = prowapi . Presubmit Job { continue } if pj . Spec . Refs . Pulls [ 0 ] . Number ! = int ( pr . Number ) { continue } if pj . Spec . Refs . Pulls [ 0 ] . SHA ! = string ( pr . Head Ref OID ) { continue } name : = pj . Spec . Context old State : = ps States [ name ] new State : = to Simple State ( pj . Status . State ) if old State = = failure State | | old State = = " " { ps States [ name ] = new State } else if old State = = pending State & & new State = = success State { ps States [ name ] = success State } } for _ , ps : = range presubmits [ int ( pr . Number ) ] { if s , ok : = ps States [ ps . Context ] ; ! ok { overall State = failure State log . With Fields ( pr . log Fields ( ) ) . Debugf ( " " , ps . Context ) break } else if s = = failure State { overall State = failure State log . With Fields ( pr . log Fields ( ) ) . Debugf ( " " , ps . Context ) break } else if s = = pending State { log . With Fields ( pr . log Fields ( ) ) . Debugf ( " " , ps . Context ) overall State = pending State } } if overall State = = success State { successes = append ( successes , pr ) } else if overall State = = pending State { pendings = append ( pendings , pr ) } else { nones = append ( nones , pr ) } } return } 
func try Merge ( merge Func func ( ) error ) ( bool , error ) { var err error const max Retries = 3 backoff : = time . Second * 4 for retry : = 0 ; retry < max Retries ; retry + + { if err = merge Func ( ) ; err = = nil { } } else if _ , ok = err . ( github . Unmergable PRBase Changed Error ) ; ok { if retry + 1 < max Retries { sleep ( backoff ) backoff * = 2 } } else if _ , ok = err . ( github . Unauthorized To Push Error ) ; ok { } else if _ , ok = err . ( github . Merge Commits Forbidden Error ) ; ok { } else if _ , ok = err . ( github . Unmergable PRError ) ; ok { return true , fmt . Errorf ( " " , err ) } else { return true , err } } } 
func ( c * changed Files Agent ) pr Changes ( pr * Pull Request ) config . Changed Files Provider { return func ( ) ( [ ] string , error ) { cache Key : = change Cache Key { org : string ( pr . Repository . Owner . Login ) , repo : string ( pr . Repository . Name ) , number : int ( pr . Number ) , sha : string ( pr . Head Ref OID ) , } c . RLock ( ) changed Files , ok : = c . change Cache [ cache Key ] if ok { c . RUnlock ( ) c . Lock ( ) c . next Change Cache [ cache Key ] = changed Files c . Unlock ( ) return changed Files , nil } if changed Files , ok = c . next Change Cache [ cache Key ] ; ok { c . RUnlock ( ) return changed Files , nil } c . RUnlock ( ) if err ! = nil { return nil , fmt . Errorf ( " " , int ( pr . Number ) , err ) } changed Files = make ( [ ] string , 0 , len ( changes ) ) for _ , change : = range changes { changed Files = append ( changed Files , change . Filename ) } c . Lock ( ) c . next Change Cache [ cache Key ] = changed Files c . Unlock ( ) return changed Files , nil } } 
func ( c * changed Files Agent ) prune ( ) { c . Lock ( ) defer c . Unlock ( ) c . change Cache = c . next Change Cache c . next Change Cache = make ( map [ change Cache Key ] [ ] string ) } 
func ( c * Controller ) divide Pool ( pool map [ string ] Pull Request , pjs [ ] prowapi . Prow Job ) ( map [ string ] * subpool , error ) { sps : = make ( map [ string ] * subpool ) for _ , pr : = range pool { org : = string ( pr . Repository . Owner . Login ) repo : = string ( pr . Repository . Name ) branch : = string ( pr . Base Ref . Name ) branch Ref : = string ( pr . Base Ref . Prefix ) + string ( pr . Base Ref . Name ) fn : = pool Key ( org , repo , branch ) if sps [ fn ] = = nil { sha , err : = c . ghc . Get Ref ( org , repo , strings . Trim Prefix ( branch Ref , " " ) ) if err ! = nil { return nil , err } sps [ fn ] = & subpool { log : c . logger . With Fields ( logrus . Fields { " " : org , " " : repo , " " : branch , " " : sha , } ) , org : org , repo : repo , branch : branch , sha : sha , } } sps [ fn ] . prs = append ( sps [ fn ] . prs , pr ) } for _ , pj : = range pjs { if pj . Spec . Type ! = prowapi . Presubmit Job & & pj . Spec . Type ! = prowapi . Batch Job { continue } fn : = pool Key ( pj . Spec . Refs . Org , pj . Spec . Refs . Repo , pj . Spec . Refs . Base Ref ) if sps [ fn ] = = nil | | pj . Spec . Refs . Base SHA ! = sps [ fn ] . sha { continue } sps [ fn ] . pjs = append ( sps [ fn ] . pjs , pj ) } return sps , nil } 
func head Contexts ( log * logrus . Entry , ghc github Client , pr * Pull Request ) ( [ ] Context , error ) { for _ , node : = range pr . Commits . Nodes { if node . Commit . OID = = pr . Head Ref OID { return node . Commit . Status . Contexts , nil } } repo : = string ( pr . Repository . Name ) combined , err : = ghc . Get Combined Status ( org , repo , string ( pr . Head Ref OID ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } contexts : = make ( [ ] Context , 0 , len ( combined . Statuses ) ) for _ , status : = range combined . Statuses { contexts = append ( contexts , Context { Context : githubql . String ( status . Context ) , Description : githubql . String ( status . Description ) , State : githubql . Status State ( strings . To Upper ( status . State ) ) , } , ) } return contexts , nil } 
func Aggregate Profiles ( profiles [ ] [ ] * cover . Profile ) ( [ ] * cover . Profile , error ) { set Profiles : = make ( [ ] [ ] * cover . Profile , 0 , len ( profiles ) ) for _ , p : = range profiles { c : = count To Boolean ( p ) set Profiles = append ( set Profiles , c ) } aggregate Profiles , err : = Merge Multiple Profiles ( set Profiles ) if err ! = nil { return nil , err } return aggregate Profiles , nil } 
func count To Boolean ( profile [ ] * cover . Profile ) [ ] * cover . Profile { set Profile : = make ( [ ] * cover . Profile , 0 , len ( profile ) ) for _ , p : = range profile { pc : = deep Copy Profile ( * p ) for i : = range pc . Blocks { if pc . Blocks [ i ] . Count > 0 { pc . Blocks [ i ] . Count = 1 } } set Profile = append ( set Profile , & pc ) } return set Profile } 
func New Storage ( r storage . Persistence Layer , storage string ) ( * Storage , error ) { s : = & Storage { resources : r , } if storage ! = " " { var data struct { Resources [ ] common . Resource } buf , err : = ioutil . Read File ( storage ) if err = = nil { logrus . Infof ( " " , string ( buf ) ) err = json . Unmarshal ( buf , & data ) if err ! = nil { return nil , err } } else if ! os . Is Not Exist ( err ) { return nil , err } logrus . Info ( " " ) for _ , res : = range data . Resources { if err : = s . Add Resource ( res ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , res . Name , res . State ) } logrus . Infof ( " " , res . Name , res . State ) } } return s , nil } 
func ( s * Storage ) Add Resource ( resource common . Resource ) error { return s . resources . Add ( resource ) } 
func ( s * Storage ) Delete Resource ( name string ) error { return s . resources . Delete ( name ) } 
func ( s * Storage ) Update Resource ( resource common . Resource ) error { return s . resources . Update ( resource ) } 
func ( s * Storage ) Get Resource ( name string ) ( common . Resource , error ) { i , err : = s . resources . Get ( name ) if err ! = nil { return common . Resource { } , err } var res common . Resource res , err = common . Item To Resource ( i ) if err ! = nil { return common . Resource { } , err } return res , nil } 
func ( s * Storage ) Get Resources ( ) ( [ ] common . Resource , error ) { var resources [ ] common . Resource items , err : = s . resources . List ( ) if err ! = nil { return resources , err } for _ , i : = range items { var res common . Resource res , err = common . Item To Resource ( i ) if err ! = nil { return nil , err } resources = append ( resources , res ) } sort . Stable ( common . Resource By Update Time ( resources ) ) return resources , nil } 
func ( s * Storage ) Sync Resources ( data [ ] common . Resource ) error { s . resources Lock . Lock ( ) defer s . resources Lock . Unlock ( ) resources , err : = s . Get Resources ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return err } var final Error error for _ , res : = range resources { valid + + continue } to Delete : = true for _ , new Res : = range data { if res . Name = = new Res . Name { resources [ valid ] = res valid + + to Delete = false break } } if to Delete { logrus . Infof ( " " , res . Name ) if err : = s . Delete Resource ( res . Name ) ; err ! = nil { final Error = multierror . Append ( final Error , err ) logrus . With Error ( err ) . Errorf ( " " , res . Name ) } } } resources = resources [ : valid ] for idx : = range resources { exist : = resources [ idx ] if p . Name = = exist . Name { found = true logrus . Infof ( " " , p . Name ) break } } if ! found { if p . State = = " " { p . State = common . Free } logrus . Infof ( " " , p . Name ) resources = append ( resources , p ) if err : = s . Add Resource ( p ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , p . Name ) final Error = multierror . Append ( final Error , err ) } } } return final Error } 
func Parse Config ( config Path string ) ( [ ] common . Resource , error ) { file , err : = ioutil . Read File ( config Path ) if err ! = nil { return nil , err } var data common . Boskos Config err = yaml . Unmarshal ( file , & data ) if err ! = nil { return nil , err } var resources [ ] common . Resource for _ , entry : = range data . Resources { resources = append ( resources , common . New Resources From Config ( entry ) . . . ) } return resources , nil } 
func problems In Files ( r * git . Repo , files map [ string ] string ) ( map [ string ] [ ] string , error ) { problems : = make ( map [ string ] [ ] string ) for f : = range files { src , err : = ioutil . Read File ( filepath . Join ( r . Dir , f ) ) if err ! = nil { return nil , err } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } before Rewrite : = build . Format ( content ) var info build . Rewrite Info build . Rewrite ( content , & info ) ndata : = build . Format ( content ) if ! bytes . Equal ( src , ndata ) & & ! bytes . Equal ( src , before Rewrite ) { } } return problems , nil } 
func New Pod Log Artifact ( job Name string , build ID string , size Limit int 6 4 , ja job Agent ) ( * Pod Log Artifact , error ) { if job Name = = " " { return nil , err Insufficient Job Info } if build ID = = " " { return nil , err Insufficient Job Info } if size Limit < 0 { return nil , err Invalid Size Limit } return & Pod Log Artifact { name : job Name , build ID : build ID , size Limit : size Limit , job Agent : ja , } , nil } 
func ( a * Pod Log Artifact ) Canonical Link ( ) string { q : = url . Values { " " : [ ] string { a . name } , " " : [ ] string { a . build ID } , } u : = url . URL { Path : " " , Raw Query : q . Encode ( ) , } return u . String ( ) } 
func ( a * Pod Log Artifact ) Read At ( p [ ] byte , off int 6 4 ) ( n int , err error ) { logs , err : = a . job Agent . Get Job Log ( a . name , a . build ID ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } r : = bytes . New Reader ( logs ) read Bytes , err : = r . Read At ( p , off ) if err = = io . EOF { return read Bytes , io . EOF } if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } return read Bytes , nil } 
func ( a * Pod Log Artifact ) Read All ( ) ( [ ] byte , error ) { size , err : = a . Size ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if size > a . size Limit { return nil , lenses . Err File Too Large } logs , err : = a . job Agent . Get Job Log ( a . name , a . build ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return logs , nil } 
func ( a * Pod Log Artifact ) Read At Most ( n int 6 4 ) ( [ ] byte , error ) { logs , err : = a . job Agent . Get Job Log ( a . name , a . build ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } reader : = bytes . New Reader ( logs ) var byte Count int 6 4 var p [ ] byte for byte Count < n { b , err : = reader . Read Byte ( ) if err = = io . EOF { return p , io . EOF } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } p = append ( p , b ) byte Count + + } return p , nil } 
func ( a * Pod Log Artifact ) Read Tail ( n int 6 4 ) ( [ ] byte , error ) { logs , err : = a . job Agent . Get Job Log ( a . name , a . build ID ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } size : = int 6 4 ( len ( logs ) ) var off int 6 4 if n > size { off = 0 } else { off = size - n } p : = make ( [ ] byte , n ) read Bytes , err : = bytes . New Reader ( logs ) . Read At ( p , off ) if err ! = nil & & err ! = io . EOF { return nil , fmt . Errorf ( " " , err ) } return p [ : read Bytes ] , nil } 
func ( a * Pod Log Artifact ) Size ( ) ( int 6 4 , error ) { logs , err : = a . job Agent . Get Job Log ( a . name , a . build ID ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } return int 6 4 ( len ( logs ) ) , nil } 
func modified Go Files ( ghc github Client , org , repo string , number int , sha string ) ( map [ string ] string , error ) { changes , err : = ghc . Get Pull Request Changes ( org , repo , number ) if err ! = nil { return nil , err } gfg , err : = genfiles . New Group ( ghc , org , repo , sha ) if err ! = nil { return nil , err } modified Files : = make ( map [ string ] string ) for _ , change : = range changes { switch { case strings . Has Prefix ( change . Filename , " " ) : continue case filepath . Ext ( change . Filename ) ! = " " : continue case gfg . Match ( change . Filename ) : continue case change . Status = = github . Pull Request File Removed | | change . Status = = github . Pull Request File Renamed : continue } modified Files [ change . Filename ] = change . Patch } return modified Files , nil } 
func new Problems ( cs [ ] github . Review Comment , ps map [ string ] map [ int ] lint . Problem ) map [ string ] map [ int ] lint . Problem { for f , ls : = range ps { res [ f ] = make ( map [ int ] lint . Problem ) for l , p : = range ls { res [ f ] [ l ] = p } } for _ , c : = range cs { if c . Position = = nil { continue } if ! strings . Contains ( c . Body , comment Tag ) { continue } delete ( res [ c . Path ] , * c . Position ) } return res } 
func problems In Files ( r * git . Repo , files map [ string ] string ) ( map [ string ] map [ int ] lint . Problem , [ ] github . Draft Review Comment ) { problems : = make ( map [ string ] map [ int ] lint . Problem ) var lint Error Comments [ ] github . Draft Review Comment l : = new ( lint . Linter ) for f , patch : = range files { problems [ f ] = make ( map [ int ] lint . Problem ) src , err : = ioutil . Read File ( filepath . Join ( r . Dir , f ) ) if err ! = nil { lint Error Comments = append ( lint Error Comments , github . Draft Review Comment { Path : f , Body : fmt . Sprintf ( " " , err ) , } ) } ps , err : = l . Lint ( f , src ) if err ! = nil { re Number : = regexp . Must Compile ( ` : ( [ 0 - 9 ] + ) : ` ) matches : = re Number . Find String Submatch ( err . Error ( ) [ err Line Index Start : ] ) new Comment : = github . Draft Review Comment { Path : f , Body : err . Error ( ) , } if len ( matches ) > 1 { err Line String : = matches [ 1 ] err Line , err Atoi : = strconv . Atoi ( err Line String ) if err Atoi = = nil { new Comment . Position = err Line } matches = re Trim Error . Find String Submatch ( err . Error ( ) ) if len ( matches ) > 0 { new Comment . Body = err . Error ( ) [ len ( matches [ 0 ] ) + err Line Index Start : ] } } lint Error Comments = append ( lint Error Comments , new Comment ) } al , err : = Added Lines ( patch ) if err ! = nil { lint Error Comments = append ( lint Error Comments , github . Draft Review Comment { Path : f , Body : fmt . Sprintf ( " " , f , err ) , } ) } for _ , p : = range ps { if pl , ok : = al [ p . Position . Line ] ; ok { problems [ f ] [ pl ] = p } } } return problems , lint Error Comments } 
func Added Lines ( patch string ) ( map [ int ] int , error ) { result : = make ( map [ int ] int ) if patch = = " " { return result , nil } lines : = strings . Split ( patch , " \n " ) for i : = 0 ; i < len ( lines ) ; i + + { } _ , old Len , new Line , new Len , err : = parse Hunk Line ( lines [ i ] ) if err ! = nil { return nil , fmt . Errorf ( " " , i , patch , err ) } old Add : = 0 new Add : = 0 for old Add < old Len | | new Add < new Len { i + + if i > = len ( lines ) { return nil , fmt . Errorf ( " " , patch ) } switch lines [ i ] [ 0 ] { case ' ' : old Add + + new Add + + case ' - ' : old Add + + case ' + ' : result [ new Line + new Add ] = i new Add + + default : return nil , fmt . Errorf ( " " , i , patch ) } } } return result , nil } 
func undo Preset ( preset * config . Preset , labels map [ string ] string , pod * coreapi . Pod Spec ) { } } for _ , e 1 : = range preset . Env { remove Env Names . Insert ( e 1 . Name ) } remove Volume Names : = sets . New String ( ) for _ , volume : = range preset . Volumes { remove Volume Names . Insert ( volume . Name ) } remove Volume Mount Names : = sets . New String ( ) for _ , volume Mount : = range preset . Volume Mounts { remove Volume Mount Names . Insert ( volume Mount . Name ) } for _ , volume : = range pod . Volumes { if ! remove Volume Names . Has ( volume . Name ) { filtered Volumes = append ( filtered Volumes , volume ) } } pod . Volumes = filtered Volumes for _ , env : = range pod . Containers [ i ] . Env { if ! remove Env Names . Has ( env . Name ) { filtered Env = append ( filtered Env , env ) } } pod . Containers [ i ] . Env = filtered Env filtered Volume Mounts : = [ ] coreapi . Volume Mount { } for _ , mount : = range pod . Containers [ i ] . Volume Mounts { if ! remove Volume Mount Names . Has ( mount . Name ) { filtered Volume Mounts = append ( filtered Volume Mounts , mount ) } } pod . Containers [ i ] . Volume Mounts = filtered Volume Mounts } } 
func undo Presubmit Presets ( presets [ ] config . Preset , presubmit * config . Presubmit ) { if presubmit . Spec = = nil { return } for _ , preset : = range presets { undo Preset ( & preset , presubmit . Labels , presubmit . Spec ) } } 
func convert Job To Security Job ( j * config . Presubmit , drop Labels sets . String , default Decoration * prowapi . Decoration Config , pod Namespace string ) * config . Presubmit { } for k , v : = range j . Labels { if ! drop Labels . Has ( fmt . Sprintf ( " " , k , v ) ) { filtered Labels [ k ] = v } } j . Labels = filtered Labels } original Name : = j . Name j . Rerun Command = strings . Replace ( j . Rerun Command , " " , " " , - 1 ) j . Trigger = strings . Replace ( j . Trigger , " " , " " , - 1 ) j . Context = strings . Replace ( j . Context , " " , " " , - 1 ) if j . Namespace ! = nil & & * j . Namespace = = pod Namespace { j . Namespace = nil } if j . Decoration Config ! = nil { if reflect . Deep Equal ( j . Decoration Config , default Decoration ) { j . Decoration Config = nil } else if reflect . Deep Equal ( j . Decoration Config . Utility Images , default Decoration . Utility Images ) { j . Decoration Config . Utility Images = nil } } container : = & j . Spec . Containers [ 0 ] need GCSFlag : = false need GCSShared Flag : = false need Staging Flag : = false is GCPe 2e : = false for i , arg : = range container . Args { if arg = = " " { ends With Scenario Args = true need GCSShared Flag = true } else if strings . Has Prefix ( arg , " " ) { need Staging Flag = true } else if strings . Has Prefix ( arg , " " ) { need GCSShared Flag = true } } for _ , arg : = range container . Args { if strings . Has Prefix ( arg , " " ) { scenario = strings . Trim Prefix ( arg , " " ) } } need GCSShared Flag = true break } } } if scenario = = " " { for _ , arg : = range container . Args { if strings . Contains ( arg , " " ) { is GCPe 2e = true } if strings . Has Prefix ( arg , " " ) { need Staging Flag = true } else if strings . Has Prefix ( arg , " " ) { need GCSShared Flag = true } } } } if need GCSFlag { container . Args = append ( container . Args , " " + j . Name ) } if need GCSShared Flag { container . Args = append ( container . Args , " " ) } if need Staging Flag { container . Args = append ( container . Args , " " + j . Name ) } } default Mode : = int 3 2 ( 0 4 0 0 ) j . Spec . Volumes = append ( j . Spec . Volumes , coreapi . Volume { Name : " " , Volume Source : coreapi . Volume Source { Secret : & coreapi . Secret Volume Source { Secret Name : " " , Default Mode : & default Mode , } , } , } , ) } return j } 
func yaml Bytes Strip Nulls ( yaml Bytes [ ] byte ) [ ] byte { null RE : = regexp . Must Compile ( " \n \n " ) return null RE . Replace All ( yaml Bytes , [ ] byte { } ) } 
func Serve PProf ( ) { pprof Mux : = http . New Serve Mux ( ) pprof Mux . Handle Func ( " " , pprof . Index ) pprof Mux . Handle Func ( " " , pprof . Cmdline ) pprof Mux . Handle Func ( " " , pprof . Profile ) pprof Mux . Handle Func ( " " , pprof . Symbol ) pprof Mux . Handle Func ( " " , pprof . Trace ) go func ( ) { logrus . With Error ( http . Listen And Serve ( " " , pprof Mux ) ) . Fatal ( " " ) } ( ) } 
func monitor Disk And Evict ( c * diskcache . Cache , interval time . Duration , min Percent Blocks Free , evict Until Percent Blocks Free float 6 4 , ) { disk Root : = c . Disk Root ( ) for ; true ; < - ticker . C { blocks Free , _ , _ , err : = diskutil . Get Disk Usage ( disk Root ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) continue } logger : = logrus . With Fields ( logrus . Fields { " " : " " , " " : blocks Free , } ) logger . Info ( " " ) sort . Slice ( files , func ( i , j int ) bool { return files [ i ] . Last Access . Before ( files [ j ] . Last Access ) } ) } entry , files = files [ 0 ] , files [ 1 : ] err = c . Delete ( c . Path To Key ( entry . Path ) ) if err ! = nil { logger . With Error ( err ) . Errorf ( " " , entry . Path ) } else { prom Metrics . Files Evicted . Inc ( ) prom Metrics . Last Evicted Access Age . Set ( time . Now ( ) . Sub ( entry . Last Access ) . Hours ( ) ) } logger = logrus . With Fields ( logrus . Fields { " " : " " , " " : blocks Free , } ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) continue } } logger . Info ( " " ) } } } 
func ( c * org Repo Config ) difference ( c 2 * org Repo Config ) * org Repo Config { res : = & org Repo Config { org Exceptions : make ( map [ string ] sets . String ) , repos : sets . New String ( ) . Union ( c . repos ) , } for org , excepts 1 : = range c . org Exceptions { if excepts 2 , ok : = c 2 . org Exceptions [ org ] ; ok { res . repos . Insert ( excepts 2 . Difference ( excepts 1 ) . Unsorted List ( ) . . . ) } else { excepts : = sets . New String ( ) . Union ( excepts 1 ) } } res . org Exceptions [ org ] = excepts } } res . repos = res . repos . Difference ( c 2 . repos ) for _ , repo : = range res . repos . Unsorted List ( ) { if parts : = strings . Split N ( repo , " " , 2 ) ; len ( parts ) = = 2 { if excepts 2 , ok : = c 2 . org Exceptions [ parts [ 0 ] ] ; ok & & ! excepts 2 . Has ( repo ) { res . repos . Delete ( repo ) } } } return res } 
func ( c * org Repo Config ) union ( c 2 * org Repo Config ) * org Repo Config { res : = & org Repo Config { org Exceptions : make ( map [ string ] sets . String ) , repos : sets . New String ( ) , } for org , excepts 1 : = range c . org Exceptions { if excepts 2 , ok : = c 2 . org Exceptions [ org ] ; ok { res . org Exceptions [ org ] = pruned . Intersection ( excepts 2 . Difference ( c . repos ) ) } else { res . org Exceptions [ org ] = pruned } } for org , excepts 2 : = range c 2 . org Exceptions { } } if len ( parts ) ! = 2 { logrus . Warnf ( " " , repo ) continue } if _ , exists : = res . org Exceptions [ parts [ 0 ] ] ; ! exists { res . repos . Insert ( repo ) } } return res } 
func ensure Valid Configuration ( plugin , label , verb string , tide Sub Set , tide Super Set , plugins Sub Set * org Repo Config ) error { not Enabled : = tide Sub Set . difference ( plugins Sub Set ) . items ( ) not Required : = plugins Sub Set . intersection ( tide Super Set ) . difference ( tide Sub Set ) . items ( ) var config Errors [ ] error if len ( not Enabled ) > 0 { config Errors = append ( config Errors , fmt . Errorf ( " " , verb , label , plugin , not Enabled ) ) } if len ( not Required ) > 0 { config Errors = append ( config Errors , fmt . Errorf ( " " , plugin , verb , label , not Required ) ) } return errorutil . New Aggregate ( config Errors . . . ) } 
func ( s * Strings ) Set ( value string ) error { if ! s . been Set { s . been Set = true } s . vals = append ( s . vals , value ) return nil } 
func clear Stale Comments ( gc github Client , log * logrus . Entry , pr * github . Pull Request Event , pr Labels sets . String , comments [ ] github . Issue Comment ) error { } bot Name , err : = gc . Bot Name ( ) if err ! = nil { return err } return gc . Delete Stale Comments ( pr . Repo . Owner . Login , pr . Repo . Name , pr . Number , comments , func ( c github . Issue Comment ) bool { } , ) } 
func determine Release Note Label ( body string ) string { composed Release Note : = strings . To Lower ( strings . Trim Space ( get Release Note ( body ) ) ) if composed Release Note = = " " { return Release Note Label Needed } if none Re . Match String ( composed Release Note ) { return release Note None } if strings . Contains ( composed Release Note , action Required Note ) { return release Note Action Required } return release Note } 
func get Release Note ( body string ) string { potential Match : = note Matcher RE . Find String Submatch ( body ) if potential Match = = nil { return " " } return strings . Trim Space ( potential Match [ 1 ] ) } 
func New Client ( boskos Client boskos Client ) * Client { return & Client { basic : boskos Client , resources : map [ string ] common . Resource { } , } } 
func ( c * Client ) Acquire ( rtype , state , dest string ) ( * common . Resource , error ) { var resources To Release [ ] common . Resource release On Failure : = func ( ) { for _ , r : = range resources To Release { if err : = c . basic . Release One ( r . Name , common . Dirty ) ; err ! = nil { logrus . With Error ( err ) . Warningf ( " " , r . Name ) } } } res , err : = c . basic . Acquire ( rtype , state , dest ) if err ! = nil { return nil , err } var leased Resources common . Leased Resources if err = res . User Data . Extract ( Leased Resources , & leased Resources ) ; err ! = nil { if _ , ok : = err . ( * common . User Data Not Found ) ; ! ok { logrus . With Error ( err ) . Errorf ( " " , Leased Resources ) return nil , err } } resources To Release = append ( resources To Release , * res ) resources , err : = c . basic . Acquire By State ( res . Name , dest , leased Resources ) if err ! = nil { release On Failure ( ) return nil , err } resources To Release = append ( resources To Release , resources . . . ) c . update Resource ( * res ) return res , nil } 
func ( c * Client ) Release One ( name , dest string ) ( all Errors error ) { res , err : = c . get Resource ( name ) if err ! = nil { all Errors = err return } resource Names : = [ ] string { name } var leased Resources common . Leased Resources if err : = res . User Data . Extract ( Leased Resources , & leased Resources ) ; err ! = nil { if _ , ok : = err . ( * common . User Data Not Found ) ; ! ok { logrus . With Error ( err ) . Errorf ( " " , Leased Resources ) all Errors = multierror . Append ( all Errors , err ) if err : = c . basic . Release One ( name , dest ) ; err ! = nil { logrus . With Error ( err ) . Warningf ( " " , name ) all Errors = multierror . Append ( all Errors , err ) } return } } resource Names = append ( resource Names , leased Resources . . . ) for _ , n : = range resource Names { if err : = c . basic . Release One ( n , dest ) ; err ! = nil { logrus . With Error ( err ) . Warningf ( " " , n ) all Errors = multierror . Append ( all Errors , err ) } } c . delete Resource ( name ) return } 
func ( c * Client ) Update All ( state string ) error { return c . basic . Update All ( state ) } 
func Get Git Hub Client ( token string ) * github . Client { return github . New Client ( oauth 2 . New Client ( oauth 2 . No Context , oauth 2 . Static Token Source ( & oauth 2 . Token { Access Token : token } ) , ) , ) } 
func Get Username ( client * github . Client ) ( string , error ) { user , _ , err : = client . Users . Get ( context . Background ( ) , " " ) if err ! = nil { return " " , err } if user . Login = = nil { return " " , errors . New ( " \ " \ " " ) } return * user . Login , nil } 
func Create Token Handler ( token Stream io . Reader , influxdb * Influx DB ) ( * Token Handler , error ) { token , err : = ioutil . Read All ( token Stream ) if err ! = nil { return nil , err } client : = Get Git Hub Client ( strings . Trim Space ( string ( token ) ) ) login , err : = Get Username ( client ) if err ! = nil { return nil , err } return & Token Handler { g Client : client , login : login , influxdb : influxdb , } , nil } 
func Create Token Handlers ( token Files [ ] string , influxdb * Influx DB ) ( [ ] Token Handler , error ) { tokens : = [ ] Token Handler { } for _ , token File : = range token Files { f , err : = os . Open ( token File ) if err ! = nil { return nil , fmt . Errorf ( " " , token File , err ) } token , err : = Create Token Handler ( f , influxdb ) if err ! = nil { return nil , fmt . Errorf ( " " , token File , err ) } tokens = append ( tokens , * token ) } return tokens , nil } 
func ( t Token Handler ) Process ( ) { last Rate , err : = t . get Core Rate ( ) if err ! = nil { glog . Fatalf ( " " , t . login , err ) } for { half Period : = last Rate . Reset . Time . Sub ( time . Now ( ) ) / 2 time . Sleep ( half Period ) new Rate , err : = t . get Core Rate ( ) if err ! = nil { glog . Error ( " " , err ) continue } } for { new Rate , err = t . get Core Rate ( ) if err = = nil { break } glog . Error ( " " , err ) time . Sleep ( time . Minute ) } } last Rate = new Rate } } 
func ( i * job Indentifier ) String ( ) string { return fmt . Sprintf ( " " , i . job , i . organization , i . repository , i . pull Request ) } 
func Terminate Older Presubmit Jobs ( pjc prow Client , log * logrus . Entry , pjs [ ] prowapi . Prow Job , cleanup Prow Job Resources Cleanup ) error { dupes : = map [ job Indentifier ] int { } for i , pj : = range pjs { if pj . Complete ( ) | | pj . Spec . Type ! = prowapi . Presubmit Job { continue } ji : = job Indentifier { job : pj . Spec . Job , organization : pj . Spec . Refs . Org , repository : pj . Spec . Refs . Repo , pull Request : pj . Spec . Refs . Pulls [ 0 ] . Number , } prev , ok : = dupes [ ji ] if ! ok { dupes [ ji ] = i continue } cancel Index : = i if ( & pjs [ prev ] . Status . Start Time ) . Before ( & pj . Status . Start Time ) { cancel Index = prev dupes [ ji ] = i } to Cancel : = pjs [ cancel Index ] } to Cancel . Set Complete ( ) prev State : = to Cancel . Status . State to Cancel . Status . State = prowapi . Aborted State log . With Fields ( Prow Job Fields ( & to Cancel ) ) . With Field ( " " , prev State ) . With Field ( " " , to Cancel . Status . State ) . Info ( " " ) npj , err : = pjc . Replace Prow Job ( to Cancel . Object Meta . Name , to Cancel ) if err ! = nil { return err } pjs [ cancel Index ] = npj } return nil } 
func Push Metrics ( component , endpoint string , interval time . Duration ) { sig : = make ( chan os . Signal , 1 ) signal . Notify ( sig , os . Interrupt , syscall . SIGTERM ) for { select { case < - time . Tick ( interval ) : if err : = push . From Gatherer ( component , push . Hostname Grouping Key ( ) , endpoint , prometheus . Default Gatherer ) ; err ! = nil { logrus . With Field ( " " , component ) . With Error ( err ) . Error ( " " ) } case < - sig : logrus . With Field ( " " , component ) . Infof ( " " ) return } } } 
func handle ( gc git Hub Client , log * logrus . Entry , se github . Status Event ) error { if se . State = = " " | | se . Context = = " " { return fmt . Errorf ( " " ) } if se . Context ! = cla Context Name { } if se . State = = github . Status Pending { } org : = se . Repo . Owner . Login repo : = se . Repo . Name log . Info ( " " ) var issues [ ] github . Issue var err error for i : = 0 ; i < max Retries ; i + + { issues , err = gc . Find Issues ( fmt . Sprintf ( " " , se . SHA , org , repo ) , " " , false ) if err ! = nil { return fmt . Errorf ( " " , err ) } if len ( issues ) > 0 { break } time . Sleep ( 1 0 * time . Second ) } log . Infof ( " " , len ( issues ) ) for _ , issue : = range issues { l : = log . With Field ( " " , issue . Number ) has Cncf Yes : = issue . Has Label ( labels . Cla Yes ) has Cncf No : = issue . Has Label ( labels . Cla No ) if has Cncf Yes & & se . State = = github . Status Success { continue } if has Cncf No & & ( se . State = = github . Status Failure | | se . State = = github . Status Error ) { continue } l . Info ( " " ) pr , err : = gc . Get Pull Request ( org , repo , issue . Number ) if err ! = nil { l . With Error ( err ) . Warningf ( " " , issue . Number , org , repo ) continue } continue } number : = pr . Number if se . State = = github . Status Success { if has Cncf No { if err : = gc . Remove Label ( org , repo , number , labels . Cla No ) ; err ! = nil { l . With Error ( err ) . Warningf ( " " , labels . Cla No ) } } if err : = gc . Add Label ( org , repo , number , labels . Cla Yes ) ; err ! = nil { l . With Error ( err ) . Warningf ( " " , labels . Cla Yes ) } continue } } } if err : = gc . Create Comment ( org , repo , number , fmt . Sprintf ( cncfcla Not Found Message , plugins . About This Bot ) ) ; err ! = nil { l . With Error ( err ) . Warning ( " " ) } if err : = gc . Add Label ( org , repo , number , labels . Cla No ) ; err ! = nil { l . With Error ( err ) . Warningf ( " " , labels . Cla No ) } } return nil } 
func Rate Limiter ( controller Name string ) workqueue . Rate Limiting Interface { rl : = workqueue . New Max Of Rate Limiter ( workqueue . New Item Exponential Failure Rate Limiter ( 5 * time . Millisecond , 1 2 0 * time . Second ) , & workqueue . Bucket Rate Limiter { Limiter : rate . New Limiter ( rate . Limit ( 1 0 0 0 ) , 5 0 0 0 0 ) } , ) return workqueue . New Named Rate Limiting Queue ( rl , controller Name ) } 
func find Repo ( wd , path string ) ( string , error ) { opwd , err : = real Path ( wd ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } if strings . Has Prefix ( path , " " ) { path = strings . Replace ( path , " " , " " , 1 ) } var old string pwd : = opwd for old ! = pwd { old = pwd if strings . Has Suffix ( pwd , " " + path ) { return pwd , nil } pwd = filepath . Dir ( pwd ) } pwd = opwd for old ! = pwd { old = pwd check : = filepath . Join ( pwd , path ) if info , err : = os . Stat ( check ) ; err = = nil & & info . Is Dir ( ) { return check , nil } pwd = filepath . Dir ( pwd ) } base : = filepath . Base ( path ) pwd = opwd for old ! = pwd { old = pwd check : = filepath . Join ( pwd , base ) if info , err : = os . Stat ( check ) ; err = = nil & & info . Is Dir ( ) { return check , nil } pwd = filepath . Dir ( pwd ) } return " " , errors . New ( " " ) } 
func check Commit Messages ( gc git Hub Client , l * logrus . Entry , org , repo string , number int ) ( [ ] github . Git Commit , error ) { all Commits , err : = gc . List PRCommits ( org , repo , number ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } l . Debugf ( " " , len ( all Commits ) ) var commits Missing DCO [ ] github . Git Commit for _ , commit : = range all Commits { if ! test Re . Match String ( commit . Commit . Message ) { c : = commit . Commit c . SHA = commit . SHA commits Missing DCO = append ( commits Missing DCO , c ) } } l . Debugf ( " " , len ( commits Missing DCO ) = = 0 ) return commits Missing DCO , nil } 
func check Existing Status ( gc git Hub Client , l * logrus . Entry , org , repo , sha string ) ( string , error ) { statuses , err : = gc . List Statuses ( org , repo , sha ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } existing Status : = " " for _ , status : = range statuses { if status . Context ! = dco Context Name { continue } existing Status = status . State break } l . Debugf ( " " , existing Status ) return existing Status , nil } 
func check Existing Labels ( gc git Hub Client , l * logrus . Entry , org , repo string , number int ) ( has Yes Label , has No Label bool , err error ) { labels , err : = gc . Get Issue Labels ( org , repo , number ) if err ! = nil { return false , false , fmt . Errorf ( " " , err ) } for _ , l : = range labels { if l . Name = = dco Yes Label { has Yes Label = true } if l . Name = = dco No Label { has No Label = true } } return has Yes Label , has No Label , nil } 
func take Action ( gc git Hub Client , cp comment Pruner , l * logrus . Entry , org , repo string , pr github . Pull Request , commits Missing DCO [ ] github . Git Commit , existing Status string , has Yes Label , has No Label , add Comment bool ) error { target URL : = fmt . Sprintf ( " " , org , repo ) signed Off : = len ( commits Missing DCO ) = = 0 } } if ! has Yes Label { l . Debugf ( " " , dco Yes Label ) } } if existing Status ! = github . Status Success { l . Debugf ( " " ) if err : = gc . Create Status ( org , repo , pr . Head . SHA , github . Status { Context : dco Context Name , State : github . Status Success , Target URL : target URL , Description : dco Context Message Success , } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } cp . Prune Comments ( should Prune ( l ) ) return nil } } } if has Yes Label { l . Debugf ( " " , dco Yes Label ) } } if existing Status ! = github . Status Failure { l . Debugf ( " " ) if err : = gc . Create Status ( org , repo , pr . Head . SHA , github . Status { Context : dco Context Name , State : github . Status Failure , Target URL : target URL , Description : dco Context Message Failed , } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } if add Comment { l . Debugf ( " " ) if err : = gc . Create Comment ( org , repo , pr . Number , fmt . Sprintf ( dco Not Found Message , target URL , Markdown SHAList ( org , repo , commits Missing DCO ) , plugins . About This Bot ) ) ; err ! = nil { l . With Error ( err ) . Warning ( " " ) } } return nil } 
func handle ( gc git Hub Client , cp comment Pruner , log * logrus . Entry , org , repo string , pr github . Pull Request , add Comment bool ) error { l : = log . With Field ( " " , pr . Number ) commits Missing DCO , err : = check Commit Messages ( gc , l , org , repo , pr . Number ) if err ! = nil { l . With Error ( err ) . Infof ( " " ) return err } existing Status , err : = check Existing Status ( gc , l , org , repo , pr . Head . SHA ) if err ! = nil { l . With Error ( err ) . Infof ( " " ) return err } has Yes Label , has No Label , err : = check Existing Labels ( gc , l , org , repo , pr . Number ) if err ! = nil { l . With Error ( err ) . Infof ( " " ) return err } return take Action ( gc , cp , l , org , repo , pr , commits Missing DCO , existing Status , has Yes Label , has No Label , add Comment ) } 
func Markdown SHAList ( org , repo string , list [ ] github . Git Commit ) string { lines : = make ( [ ] string , len ( list ) ) line Fmt : = " " for i , commit : = range list { if commit . SHA = = " " { continue } if len ( short SHA ) > 7 { short SHA = short SHA [ : 7 ] } lines [ i ] = fmt . Sprintf ( line Fmt , short SHA , org , repo , commit . SHA , message ) } return strings . Join ( lines , " \n " ) } 
func should Prune ( log * logrus . Entry ) func ( github . Issue Comment ) bool { return func ( comment github . Issue Comment ) bool { return strings . Contains ( comment . Body , dco Msg Prune Match ) } } 
func Path For Spec ( spec * downwardapi . Job Spec , path Segment Repo Path Builder ) string { switch spec . Type { case prowapi . Periodic Job , prowapi . Postsubmit Job : return path . Join ( Non PRLogs , spec . Job , spec . Build ID ) case prowapi . Presubmit Job : return path . Join ( PRLogs , " " , path Segment ( spec . Refs . Org , spec . Refs . Repo ) , strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) , spec . Job , spec . Build ID ) case prowapi . Batch Job : return path . Join ( PRLogs , " " , " " , spec . Job , spec . Build ID ) default : logrus . Fatalf ( " " , spec . Type ) } return " " } 
func Alias For Spec ( spec * downwardapi . Job Spec ) string { switch spec . Type { case prowapi . Periodic Job , prowapi . Postsubmit Job , prowapi . Batch Job : return " " case prowapi . Presubmit Job : return path . Join ( PRLogs , " " , spec . Job , fmt . Sprintf ( " " , spec . Build ID ) ) default : logrus . Fatalf ( " " , spec . Type ) } return " " } 
func Root For Spec ( spec * downwardapi . Job Spec ) string { switch spec . Type { case prowapi . Periodic Job , prowapi . Postsubmit Job : return path . Join ( Non PRLogs , spec . Job ) case prowapi . Presubmit Job , prowapi . Batch Job : return path . Join ( PRLogs , " " , spec . Job ) default : logrus . Errorf ( " " , spec . Type ) } return " " } 
func New Single Default Repo Path Builder ( default Org , default Repo string ) Repo Path Builder { return func ( org , repo string ) string { if org = = default Org & & repo = = default Repo { return " " } return fmt . Sprintf ( " " , org , repo ) } } 
func New Explicit Repo Path Builder ( ) Repo Path Builder { return func ( org , repo string ) string { return fmt . Sprintf ( " " , org , repo ) } } 
func Register Source Or Die ( name string , src Issue Source ) { if _ , ok : = sources [ name ] ; ok { glog . Fatalf ( " " , name ) } sources [ name ] = src glog . Infof ( " " , name ) } 
func ( c * Issue Creator ) Create And Sync ( ) { var err error if err = c . initialize ( ) ; err ! = nil { glog . Fatalf ( " " , err ) } glog . Info ( " " ) for src Name , src : = range sources { glog . Infof ( " " , src Name ) var issues [ ] Issue if issues , err = src . Issues ( c ) ; err ! = nil { glog . Errorf ( " " , src Name , err ) continue } created : = 0 for _ , issue : = range issues { if c . sync ( issue ) { created + + } } glog . Infof ( " " , created , len ( issues ) , src Name , ) } } 
func ( c * Issue Creator ) load Cache ( ) error { user , err : = c . client . Get User ( " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } if user = = nil { return fmt . Errorf ( " " ) } if user . Login = = nil { return fmt . Errorf ( " " ) } c . author Name = * user . Login glog . Errorf ( " \n " , c . org , c . project , err ) } else { c . valid Labels = make ( [ ] string , 0 , len ( valid Labels ) ) for _ , label : = range valid Labels { if label . Name ! = nil & & * label . Name ! = " " { c . valid Labels = append ( c . valid Labels , * label . Name ) } } } glog . Errorf ( " \n " , c . org , c . project , err ) } else { c . Collaborators = make ( [ ] string , 0 , len ( collaborators ) ) for _ , user : = range collaborators { if user . Login ! = nil & & * user . Login ! = " " { c . Collaborators = append ( c . Collaborators , strings . To Lower ( * user . Login ) ) } } } if err ! = nil { return fmt . Errorf ( " " , c . author Name , c . org , c . project , err ) } if len ( issues ) = = 0 { glog . Warningf ( " \n " , c . org , c . project , c . author Name ) } c . all Issues = make ( map [ int ] * github . Issue ) for _ , i : = range issues { c . all Issues [ * i . Number ] = i } return nil } 
func ( c * Issue Creator ) Register Flags ( ) { flag . String Var ( & c . owner Path , " " , " " , " " ) flag . Int Var ( & c . Max SIGCount , " " , 3 , " " ) flag . Int Var ( & c . Max Assignees , " " , 3 , " " ) flag . String Var ( & c . token File , " " , " " , " " ) flag . String Var ( & c . project , " " , " " , " " ) flag . String Var ( & c . org , " " , " " , " " ) flag . Bool Var ( & c . dry Run , " " , true , " " ) for _ , src : = range sources { src . Register Flags ( ) } } 
func set Intersect ( a , b [ ] string ) ( filtered , removed [ ] string ) { for _ , elem A : = range a { found : = false for _ , elem B : = range b { if elem A = = elem B { found = true break } } if found { filtered = append ( filtered , elem A ) } else { removed = append ( removed , elem A ) } } return } 
func ( c * Issue Creator ) sync ( issue Issue ) bool { var closed Issues [ ] * github . Issue for _ , i : = range c . all Issues { if strings . Contains ( * i . Body , id ) { switch * i . State { case " " : case " " : closed Issues = append ( closed Issues , i ) default : glog . Errorf ( " \n " , * i . State , * i . Number ) } } } if body = = " " { return false } if ! strings . Contains ( body , id ) { glog . Fatalf ( " \n \n " , id , body ) } title : = issue . Title ( ) owners : = issue . Owners ( ) if c . Collaborators ! = nil { var removed Owners [ ] string owners , removed Owners = set Intersect ( owners , c . Collaborators ) if len ( removed Owners ) > 0 { glog . Errorf ( " " , title , removed Owners ) } } labels : = issue . Labels ( ) if prio , ok : = issue . Priority ( ) ; ok { labels = append ( labels , " " + prio ) } if c . valid Labels ! = nil { var removed Labels [ ] string labels , removed Labels = set Intersect ( labels , c . valid Labels ) if len ( removed Labels ) > 0 { glog . Errorf ( " " , title , removed Labels ) } } glog . Infof ( " \n " , title , owners ) if c . dry Run { return true } created , err : = c . client . Create Issue ( c . org , c . project , title , body , labels , owners ) if err ! = nil { glog . Errorf ( " \n " , id ) return false } c . all Issues [ * created . Number ] = created return true } 
func Get AWSCreds ( r * common . Resource ) ( credentials . Value , error ) { val : = credentials . Value { } if r . Type ! = Resource Type { return val , fmt . Errorf ( " " , Resource Type , r . Type ) } access Key , ok : = r . User Data . Map . Load ( User Data Access IDKey ) if ! ok { return val , errors . New ( " " ) } secret Key , ok : = r . User Data . Map . Load ( User Data Secret Access Key ) if ! ok { return val , errors . New ( " " ) } val . Access Key ID = access Key . ( string ) val . Secret Access Key = secret Key . ( string ) return val , nil } 
func stopper ( ) chan struct { } { stop : = make ( chan struct { } ) c : = make ( chan os . Signal , 2 ) signal . Notify ( c , os . Interrupt , syscall . SIGTERM ) go func ( ) { < - c logrus . Warn ( " " ) close ( stop ) < - c logrus . Error ( " " ) os . Exit ( 1 ) } ( ) return stop } 
func new Pipeline Config ( cfg rest . Config , stop chan struct { } ) ( * pipeline Config , error ) { bc , err : = pipelineset . New For Config ( & cfg ) if err ! = nil { return nil , err } } bif . Tekton ( ) . V 1alpha 1 ( ) . Pipeline Runs ( ) . Lister ( ) go bif . Start ( stop ) return & pipeline Config { client : bc , informer : bif . Tekton ( ) . V 1alpha 1 ( ) . Pipeline Runs ( ) , } , nil } 
func ( o * Kubernetes Client Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . master URL , " " , " " , " " ) fs . String Var ( & o . kube Config , " " , " " , " " ) } 
func ( o * Kubernetes Client Options ) Validate ( dry Run bool ) error { if dry Run & & o . master URL = = " " { return errors . New ( " " ) } if o . master URL ! = " " { if _ , err : = url . Parse Request URI ( o . master URL ) ; err ! = nil { return fmt . Errorf ( " " , o . master URL ) } } if o . kube Config ! = " " { if _ , err : = os . Stat ( o . kube Config ) ; err ! = nil { return err } } return nil } 
func ( o * Kubernetes Client Options ) Kube Client ( ) ( kubernetes . Interface , error ) { return kube . Get Kubernetes Client ( o . master URL , o . kube Config ) } 
func ( o * Kubernetes Client Options ) Prow Job Client ( ) ( versioned . Interface , error ) { return kube . Get Prow Job Client ( o . master URL , o . kube Config ) } 
func ( bucket gcs Bucket ) resolve Sym Link ( sym Link string ) ( string , error ) { data , err : = bucket . read Object ( sym Link ) if err ! = nil { return " " , fmt . Errorf ( " " , sym Link , err ) } return prefix Re . Replace All String ( u , " " ) , nil } 
func read JSON ( bucket storage Bucket , key string , data interface { } ) error { raw Data , err : = bucket . read Object ( key ) if err ! = nil { return fmt . Errorf ( " " , key , err ) } err = json . Unmarshal ( raw Data , & data ) if err ! = nil { return fmt . Errorf ( " " , key , err ) } return nil } 
func ( bucket gcs Bucket ) list Sub Dirs ( prefix string ) ( [ ] string , error ) { if ! strings . Has Suffix ( prefix , " " ) { prefix + = " " } dirs : = [ ] string { } it : = bucket . Objects ( context . Background ( ) , & storage . Query { Prefix : prefix , Delimiter : " " , } ) for { attrs , err : = it . Next ( ) if err = = iterator . Done { break } if err ! = nil { return dirs , err } if attrs . Prefix ! = " " { dirs = append ( dirs , attrs . Prefix ) } } return dirs , nil } 
func ( bucket gcs Bucket ) list All ( prefix string ) ( [ ] string , error ) { keys : = [ ] string { } it : = bucket . Objects ( context . Background ( ) , & storage . Query { Prefix : prefix , } ) for { attrs , err : = it . Next ( ) if err = = iterator . Done { break } if err ! = nil { return keys , err } keys = append ( keys , attrs . Name ) } return keys , nil } 
func ( bucket gcs Bucket ) list Build IDs ( root string ) ( [ ] int 6 4 , error ) { ids : = [ ] int 6 4 { } if strings . Has Prefix ( root , logs Prefix ) { dirs , err : = bucket . list Sub Dirs ( root ) if err ! = nil { return ids , fmt . Errorf ( " " , err ) } for _ , dir : = range dirs { i , err : = strconv . Parse Int ( path . Base ( dir ) , 1 0 , 6 4 ) if err = = nil { ids = append ( ids , i ) } else { logrus . Warningf ( " " , dir ) } } } else { keys , err : = bucket . list All ( root ) if err ! = nil { return ids , fmt . Errorf ( " " , err ) } for _ , key : = range keys { matches : = link Re . Find String Submatch ( key ) if len ( matches ) = = 2 { i , err : = strconv . Parse Int ( matches [ 1 ] , 1 0 , 6 4 ) if err = = nil { ids = append ( ids , i ) } else { logrus . Warningf ( " " , key ) } } } } return ids , nil } 
func crop Results ( a [ ] int 6 4 , max int 6 4 ) ( [ ] int 6 4 , int , int ) { res : = [ ] int 6 4 { } first Index : = - 1 last Index : = 0 for i , v : = range a { if v < = max { res = append ( res , v ) if first Index = = - 1 { first Index = i } last Index = i if len ( res ) > = results Per Page { break } } } return res , first Index , last Index } 
func get Job History ( url * url . URL , config * config . Config , gcs Client * storage . Client ) ( job History Template , error ) { start : = time . Now ( ) tmpl : = job History Template { } bucket Name , root , top , err : = parse Job Hist URL ( url ) if err ! = nil { return tmpl , fmt . Errorf ( " " , url . String ( ) , err ) } tmpl . Name = root bucket : = gcs Bucket { bucket Name , gcs Client . Bucket ( bucket Name ) } latest , err : = read Latest Build ( bucket , root ) if err ! = nil { return tmpl , fmt . Errorf ( " " , err ) } if top = = empty ID | | top > latest { top = latest } if top ! = latest { tmpl . Latest Link = link ID ( url , empty ID ) } build IDs , err : = bucket . list Build IDs ( root ) if err ! = nil { return tmpl , fmt . Errorf ( " " , err ) } sort . Sort ( sort . Reverse ( int 6 4slice ( build IDs ) ) ) if next Index > = 0 { next = build IDs [ next Index ] } tmpl . Newer Link = link ID ( url , next ) } if last Index < len ( build IDs ) - 1 { tmpl . Older Link = link ID ( url , build IDs [ last Index + 1 ] ) } tmpl . Builds = make ( [ ] build Data , len ( shown IDs ) ) tmpl . Results Shown = len ( shown IDs ) tmpl . Results Total = len ( build IDs ) for i , build ID : = range shown IDs { go func ( i int , build ID int 6 4 ) { id : = strconv . Format Int ( build ID , 1 0 ) dir , err : = bucket . get Path ( root , id , " " ) if err ! = nil { logrus . Errorf ( " " , err ) bch < - build Data { } return } b , err : = get Build Data ( bucket , dir ) if err ! = nil { logrus . Warningf ( " " , build ID , err ) } b . index = i b . ID = id b . Spyglass Link , err = bucket . spyglass Link ( root , id ) if err ! = nil { logrus . Errorf ( " " , err ) } bch < - b } ( i , build ID ) } for i : = 0 ; i < len ( shown IDs ) ; i + + { b : = < - bch tmpl . Builds [ b . index ] = b } elapsed : = time . Now ( ) . Sub ( start ) logrus . Infof ( " " , url . Path , elapsed ) return tmpl , nil } 
func Filter Profile Paths ( profile [ ] * cover . Profile , paths [ ] string , include bool ) ( [ ] * cover . Profile , error ) { paren Paths : = make ( [ ] string , len ( paths ) ) for i , path : = range paths { paren Paths [ i ] = " " + path + " " } joined : = strings . Join ( paren Paths , " " ) re , err : = regexp . Compile ( joined ) if err ! = nil { return nil , err } result : = make ( [ ] * cover . Profile , 0 , len ( profile ) ) for _ , p : = range profile { if re . Match String ( p . File Name ) = = include { result = append ( result , p ) } } return result , nil } 
func handle ( gc github Client , log * logrus . Entry , e * github . Generic Comment Event , f has Label Func ) error { if e . Action ! = github . Generic Comment Action Created { return nil } needs Label : = false if label Re . Match String ( e . Body ) { needs Label = true } else if label Cancel Re . Match String ( e . Body ) { needs Label = false } else { return nil } org : = e . Repo . Owner . Login repo : = e . Repo . Name issue Labels , err : = gc . Get Issue Labels ( org , repo , e . Number ) if err ! = nil { return fmt . Errorf ( " " , org , repo , e . Number , err ) } has Label : = f ( labels . Hold , issue Labels ) if has Label & & ! needs Label { log . Infof ( " " , labels . Hold , org , repo , e . Number ) return gc . Remove Label ( org , repo , e . Number , labels . Hold ) } else if ! has Label & & needs Label { log . Infof ( " " , labels . Hold , org , repo , e . Number ) return gc . Add Label ( org , repo , e . Number , labels . Hold ) } return nil } 
func handle ( h * handler ) error { e : = h . event org : = e . Repo . Owner . Login repo : = e . Repo . Name matches : = h . regexp . Find All String Submatch ( e . Body , - 1 ) if matches = = nil { return nil } users : = make ( map [ string ] bool ) for _ , re : = range matches { add : = re [ 1 ] ! = " " if re [ 2 ] = = " " { users [ e . User . Login ] = add } else { for _ , login : = range parse Logins ( re [ 2 ] ) { users [ login ] = add } } } var to Add , to Remove [ ] string for login , add : = range users { if add { to Add = append ( to Add , login ) } else { to Remove = append ( to Remove , login ) } } if len ( to Remove ) > 0 { h . log . Printf ( " " , h . user Type , org , repo , e . Number , to Remove ) if err : = h . remove ( org , repo , e . Number , to Remove ) ; err ! = nil { return err } } if len ( to Add ) > 0 { h . log . Printf ( " " , h . user Type , org , repo , e . Number , to Add ) if err : = h . add ( org , repo , e . Number , to Add ) ; err ! = nil { if mu , ok : = err . ( github . Missing Users ) ; ok { msg : = h . add Failure Response ( mu ) if len ( msg ) = = 0 { return nil } if err : = h . gc . Create Comment ( org , repo , e . Number , plugins . Format Response Raw ( e . Body , e . HTMLURL , e . User . Login , msg ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } return err } } return nil } 
func Load Secrets ( paths [ ] string ) ( map [ string ] [ ] byte , error ) { secrets Map : = make ( map [ string ] [ ] byte , len ( paths ) ) for _ , path : = range paths { secret Value , err : = Load Single Secret ( path ) if err ! = nil { return nil , err } secrets Map [ path ] = secret Value } return secrets Map , nil } 
func Load Single Secret ( path string ) ( [ ] byte , error ) { b , err : = ioutil . Read File ( path ) if err ! = nil { return nil , fmt . Errorf ( " " , path , err ) } return bytes . Trim Space ( b ) , nil } 
func ( b * Bool ) Set ( s string ) error { v , err : = strconv . Parse Bool ( s ) if err ! = nil { return err } b . Explicit = true b . Value = v return nil } 
func New Opener ( ctx context . Context , creds string ) ( Opener , error ) { var options [ ] option . Client Option if creds ! = " " { options = append ( options , option . With Credentials File ( creds ) ) } client , err : = storage . New Client ( ctx , options . . . ) if err ! = nil { if creds ! = " " { return nil , err } logrus . With Error ( err ) . Debug ( " " ) client = nil } return opener { gcs : client } , nil } 
func Is Not Exist ( err error ) bool { return os . Is Not Exist ( err ) | | err = = storage . Err Object Not Exist } 
func Log Close ( c io . Closer ) { if err : = c . Close ( ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } 
func ( o opener ) Reader ( ctx context . Context , path string ) ( io . Read Closer , error ) { g , err : = o . open GCS ( path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if g = = nil { return os . Open ( path ) } return g . New Reader ( ctx ) } 
func ( o opener ) Writer ( ctx context . Context , path string ) ( io . Write Closer , error ) { g , err : = o . open GCS ( path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if g = = nil { return os . Create ( path ) } return g . New Writer ( ctx ) , nil } 
func ( gac * Git Hub OAuth Config ) Init Git Hub OAuth Config ( cookie * sessions . Cookie Store ) { gob . Register ( & oauth 2 . Token { } ) gac . Cookie Store = cookie } 
func delta Displayed ( change * coverage Change ) string { if change . base Ratio < 0 { return " " } return fmt . Sprintf ( " " , ( change . new Ratio - change . base Ratio ) * 1 0 0 ) } 
func make Table ( base Cov List , new Cov List * calculation . Coverage List , coverage Threshold float 3 2 ) ( string , bool ) { var rows [ ] string is Coverage Low : = false for _ , change : = range find Changes ( base Cov List , new Cov List ) { file Path : = change . name rows = append ( rows , fmt . Sprintf ( " " , file Path , format Percentage ( change . base Ratio ) , format Percentage ( change . new Ratio ) , delta Displayed ( change ) ) ) if change . new Ratio < coverage Threshold { is Coverage Low = true } } return strings . Join ( rows , " \n " ) , is Coverage Low } 
func Content For Git Hub Post ( base Profiles , new Profiles [ ] * cover . Profile , job Name string , coverage Threshold float 3 2 ) ( string , bool ) { rows : = [ ] string { " " , fmt . Sprintf ( " " , job Name ) , " " , " " , " " , } table , is Coverage Low : = make Table ( calculation . Produce Cov List ( base Profiles ) , calculation . Produce Cov List ( new Profiles ) , coverage Threshold ) if table = = " " { return " " , false } rows = append ( rows , table ) rows = append ( rows , " " ) return strings . Join ( rows , " \n " ) , is Coverage Low } 
func ( client * Client ) Add Flags ( cmd * cobra . Command ) { cmd . Persistent Flags ( ) . String Var ( & client . Token , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & client . Token File , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & client . Org , " " , " " , " " ) cmd . Persistent Flags ( ) . String Var ( & client . Project , " " , " " , " " ) } 
func ( client * Client ) Check Flags ( ) error { if client . Org = = " " { return fmt . Errorf ( " " ) } client . Org = strings . To Lower ( client . Org ) if client . Project = = " " { return fmt . Errorf ( " " ) } client . Project = strings . To Lower ( client . Project ) return nil } 
func ( client * Client ) get Git Hub Client ( ) ( * github . Client , error ) { if client . github Client ! = nil { return client . github Client , nil } token : = client . Token if len ( token ) = = 0 & & len ( client . Token File ) ! = 0 { data , err : = ioutil . Read File ( client . Token File ) if err ! = nil { return nil , err } token = strings . Trim Space ( string ( data ) ) } if len ( token ) > 0 { ts : = oauth 2 . Static Token Source ( & oauth 2 . Token { Access Token : token } ) tc : = oauth 2 . New Client ( oauth 2 . No Context , ts ) client . github Client = github . New Client ( tc ) } else { client . github Client = github . New Client ( nil ) } return client . github Client , nil } 
func ( client * Client ) limits Check And Wait ( ) { var sleep time . Duration github Client , err : = client . get Git Hub Client ( ) if err ! = nil { glog . Error ( " " , err ) sleep = time . Minute } else { limits , _ , err : = github Client . Rate Limits ( context . Background ( ) ) if err ! = nil { glog . Error ( " " , err ) sleep = time . Minute } if limits ! = nil & & limits . Core ! = nil & & limits . Core . Remaining < token Limit { sleep = limits . Core . Reset . Sub ( time . Now ( ) ) glog . Warning ( " " , sleep ) } } time . Sleep ( sleep ) } 
func ( client * Client ) Repository Name ( ) string { return fmt . Sprintf ( " " , client . Org , client . Project ) } 
func ( client * Client ) Fetch Issues ( latest time . Time , c chan * github . Issue ) { opt : = & github . Issue List By Repo Options { Since : latest , Sort : " " , State : " " , Direction : " " } github Client , err : = client . get Git Hub Client ( ) if err ! = nil { close ( c ) glog . Error ( err ) return } count : = 0 for { client . limits Check And Wait ( ) issues , resp , err : = github Client . Issues . List By Repo ( context . Background ( ) , client . Org , client . Project , opt , ) if err ! = nil { close ( c ) glog . Error ( err ) return } for _ , issue : = range issues { c < - issue count + + } if resp . Next Page = = 0 { break } opt . List Options . Page = resp . Next Page } glog . Infof ( " " , count , latest ) close ( c ) } 
func has ID ( events [ ] * github . Issue Event , id int ) bool { for _ , event : = range events { if * event . ID = = int 6 4 ( id ) { return true } } return false } 
func ( client * Client ) Fetch Issue Events ( issue ID int , latest * int , c chan * github . Issue Event ) { opt : = & github . List Options { Per Page : 1 0 0 } github Client , err : = client . get Git Hub Client ( ) if err ! = nil { close ( c ) glog . Error ( err ) return } count : = 0 for { client . limits Check And Wait ( ) events , resp , err : = github Client . Issues . List Issue Events ( context . Background ( ) , client . Org , client . Project , issue ID , opt , ) if err ! = nil { glog . Errorf ( " " , err ) time . Sleep ( time . Second ) continue } for _ , event : = range events { c < - event count + + } if resp . Next Page = = 0 | | ( latest ! = nil & & has ID ( events , * latest ) ) { break } opt . Page = resp . Next Page } glog . Infof ( " " , count ) close ( c ) } 
func ( client * Client ) Fetch Issue Comments ( issue ID int , latest time . Time , c chan * github . Issue Comment ) { opt : = & github . Issue List Comments Options { Since : latest , Sort : " " , Direction : " " } github Client , err : = client . get Git Hub Client ( ) if err ! = nil { close ( c ) glog . Error ( err ) return } count : = 0 for { client . limits Check And Wait ( ) comments , resp , err : = github Client . Issues . List Comments ( context . Background ( ) , client . Org , client . Project , issue ID , opt , ) if err ! = nil { close ( c ) glog . Error ( err ) return } for _ , comment : = range comments { c < - comment count + + } if resp . Next Page = = 0 { break } opt . List Options . Page = resp . Next Page } glog . Infof ( " " , count , latest , issue ID ) close ( c ) } 
func is PRChanged ( pe github . Pull Request Event ) bool { switch pe . Action { case github . Pull Request Action Opened : return true case github . Pull Request Action Reopened : return true case github . Pull Request Action Synchronize : return true case github . Pull Request Action Edited : return true default : return false } } 
func New Fetcher ( repository string ) * Fetcher { return & Fetcher { Issues Channel : make ( chan sql . Issue , 1 0 0 ) , Events Comments Channel : make ( chan interface { } , 1 0 0 ) , repository : repository , } } 
func ( f * Fetcher ) fetch Recent Issues ( db * gorm . DB ) error { glog . Infof ( " " , f . last Issue ) var issues [ ] sql . Issue query : = db . Where ( " " , f . last Issue ) . Where ( " " , f . repository ) . Order ( " " ) . Preload ( " " ) . Find ( & issues ) if query . Error ! = nil { return query . Error } count : = len ( issues ) for _ , issue : = range issues { f . Issues Channel < - issue f . last Issue = issue . Issue Updated At } glog . Infof ( " " , count ) return nil } 
func ( f * Fetcher ) fetch Recent Events And Comments ( db * gorm . DB ) error { glog . Infof ( " " , f . last Event ) glog . Infof ( " " , f . last Comment ) event Rows , err : = db . Model ( sql . Issue Event { } ) . Where ( " " , f . repository ) . Where ( " " , f . last Event ) . Order ( " " ) . Rows ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } comment Rows , err : = db . Model ( sql . Comment { } ) . Where ( " " , f . repository ) . Where ( " " , f . last Comment ) . Order ( " " ) . Rows ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } count : = 0 comment : = & sql . Comment { } if comment Rows . Next ( ) { db . Scan Rows ( comment Rows , comment ) } else { comment = nil } event : = & sql . Issue Event { } if event Rows . Next ( ) { db . Scan Rows ( event Rows , event ) } else { event = nil } for event ! = nil | | comment ! = nil { if event = = nil | | ( comment ! = nil & & comment . Comment Created At . Before ( event . Event Created At ) ) { f . Events Comments Channel < - * comment f . last Comment = comment . Comment Created At if comment Rows . Next ( ) { db . Scan Rows ( comment Rows , comment ) } else { comment = nil } } else { f . Events Comments Channel < - * event f . last Event = event . Event Created At if event Rows . Next ( ) { db . Scan Rows ( event Rows , event ) } else { event = nil } } count + + } glog . Infof ( " " , count ) return nil } 
func ( f * Fetcher ) Fetch ( db * gorm . DB ) error { if err : = f . fetch Recent Issues ( db ) ; err ! = nil { return err } if err : = f . fetch Recent Events And Comments ( db ) ; err ! = nil { return err } return nil } 
func zone Is Managed ( z * route 5 3 . Hosted Zone ) bool { if " " = = name { return true } klog . Infof ( " " , name ) return false } 
func resource Record Set Is Managed ( rrs * route 5 3 . Resource Record Set ) bool { if " " ! = aws . String Value ( rrs . Type ) { return false } name : = aws . String Value ( rrs . Name ) for _ , managed Name Regex : = range managed Name Regexes { if managed Name Regex . Match String ( name ) { return true } } klog . Infof ( " " , name ) return false } 
func ( fjr * Flaky Job Reporter ) Register Flags ( ) { flag . String Var ( & fjr . flaky Job Data URL , " " , " " , " " ) flag . Int Var ( & fjr . sync Count , " " , 3 , " " ) } 
func ( fjr * Flaky Job Reporter ) Issues ( c * creator . Issue Creator ) ( [ ] creator . Issue , error ) { fjr . creator = c json , err : = Read HTTP ( fjr . flaky Job Data URL ) if err ! = nil { return nil , err } flaky Jobs , err : = fjr . parse Flaky Jobs ( json ) if err ! = nil { return nil , err } count : = fjr . sync Count if len ( flaky Jobs ) < count { count = len ( flaky Jobs ) } issues : = make ( [ ] creator . Issue , 0 , count ) for _ , fj : = range flaky Jobs [ 0 : count ] { issues = append ( issues , fj ) } return issues , nil } 
func ( fjr * Flaky Job Reporter ) parse Flaky Jobs ( json In [ ] byte ) ( [ ] * Flaky Job , error ) { var flake Map map [ string ] * Flaky Job err : = json . Unmarshal ( json In , & flake Map ) if err ! = nil | | flake Map = = nil { return nil , fmt . Errorf ( " " , err ) } flaky Jobs : = make ( [ ] * Flaky Job , 0 , len ( flake Map ) ) for job , fj : = range flake Map { if job = = " " { glog . Errorf ( " \n " ) continue } if fj = = nil { glog . Errorf ( " \n " , job ) continue } if fj . Consistency = = nil { glog . Errorf ( " \n " , job ) continue } if fj . Flake Count = = nil { glog . Errorf ( " \n " , job ) continue } if fj . Flaky Tests = = nil { glog . Errorf ( " \n " , job ) continue } fj . Name = job fj . reporter = fjr flaky Jobs = append ( flaky Jobs , fj ) } sort . Slice Stable ( flaky Jobs , func ( i , j int ) bool { if * flaky Jobs [ i ] . Flake Count = = * flaky Jobs [ j ] . Flake Count { return * flaky Jobs [ i ] . Consistency < * flaky Jobs [ j ] . Consistency } return * flaky Jobs [ i ] . Flake Count > * flaky Jobs [ j ] . Flake Count } ) return flaky Jobs , nil } 
func ( fj * Flaky Job ) Title ( ) string { return fmt . Sprintf ( " " , fj . Name , * fj . Flake Count ) } 
func ( fj * Flaky Job ) Body ( closed Issues [ ] * githubapi . Issue ) string { for _ , closed : = range closed Issues { if closed . Closed At . After ( cutoff Time ) { return " " } } fmt . Fprintf ( & buf , " \n \n \n " , fj . ID ( ) , * fj . Flake Count , * fj . Consistency * 1 0 0 ) if len ( fj . Flaky Tests ) > 0 { fmt . Fprint ( & buf , " \n \n \n \n " ) for _ , test Name : = range fj . Tests Sorted ( ) { fmt . Fprintf ( & buf , " \n " , test Name , fj . Flaky Tests [ test Name ] ) } } for _ , closed : = range closed Issues { fmt . Fprintf ( & buf , " " , * closed . Number ) } fmt . Fprint ( & buf , " \n " ) } owners Map : = fj . reporter . creator . Tests Owners ( tests Sorted ) if len ( owners Map ) > 0 { fmt . Fprint ( & buf , " \n " ) for user : = range owners Map { fmt . Fprintf ( & buf , " " , user ) } fmt . Fprint ( & buf , " \n " ) } fmt . Fprintf ( & buf , " \n \n " , fj . reporter . flaky Job Data URL ) fmt . Fprintf ( & buf , " \n \n " ) return buf . String ( ) } 
func ( fj * Flaky Job ) Labels ( ) [ ] string { labels : = [ ] string { " " } } return labels } 
func Read HTTP ( url string ) ( [ ] byte , error ) { var err error retry Delay : = time . Duration ( 2 ) * time . Second for retry Count : = 0 ; retry Count < 5 ; retry Count + + { if retry Count > 0 { time . Sleep ( retry Delay ) retry Delay * = time . Duration ( 2 ) } resp , err : = http . Get ( url ) if resp ! = nil & & resp . Status Code > = 5 0 0 { } if err ! = nil { return nil , err } defer resp . Body . Close ( ) body , err : = ioutil . Read All ( resp . Body ) if err ! = nil { continue } return body , nil } return nil , fmt . Errorf ( " " , url , err ) } 
func ( l lines By Timestamp ) String ( ) string { sort . Sort ( l ) var log string for i , line : = range l { switch i { case len ( l ) - 1 : log + = string ( line . actual ) default : } } return fmt . Sprintf ( " " , log ) } 
func handle Metric ( boskos * client . Client ) http . Handler Func { return func ( res http . Response Writer , req * http . Request ) { log : = logrus . With Field ( " " , " " ) log . Infof ( " " , req . Remote Addr ) if req . Method ! = " " { log . Warningf ( " " , req . Method ) http . Error ( res , " " , http . Status Method Not Allowed ) return } rtype : = req . URL . Query ( ) . Get ( " " ) if rtype = = " " { msg : = " " log . Warning ( msg ) http . Error ( res , msg , http . Status Bad Request ) return } log . Infof ( " " , rtype ) metric , err : = boskos . Metric ( rtype ) if err ! = nil { log . With Error ( err ) . Errorf ( " " , rtype ) http . Error ( res , err . Error ( ) , http . Status Not Found ) return } metric JSON , err : = json . Marshal ( metric ) if err ! = nil { log . With Error ( err ) . Errorf ( " " , metric JSON ) http . Error ( res , err . Error ( ) , http . Status Internal Server Error ) return } log . Infof ( " " , rtype , string ( metric JSON ) ) fmt . Fprint ( res , string ( metric JSON ) ) } } 
func load Cluster Config ( master URL , kube Config string ) ( * rest . Config , error ) { cluster Config , err : = clientcmd . Build Config From Flags ( master URL , kube Config ) if err = = nil { return cluster Config , nil } credentials , err : = clientcmd . New Default Client Config Loading Rules ( ) . Load ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } cluster Config , err = clientcmd . New Default Client Config ( * credentials , & clientcmd . Config Overrides { } ) . Client Config ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return cluster Config , nil } 
func Get Kubernetes Client ( master URL , kube Config string ) ( kubernetes . Interface , error ) { config , err : = load Cluster Config ( master URL , kube Config ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } logrus . Info ( " " ) return client , nil } 
func Get Prow Job Client ( master URL , kube Config string ) ( prowjobclientset . Interface , error ) { config , err : = load Cluster Config ( master URL , kube Config ) if err ! = nil { return nil , err } prowjob Client , err : = prowjobclientset . New For Config ( config ) if err ! = nil { return nil , err } logrus . Info ( " " ) return prowjob Client , nil } 
func parse Pattern ( p string ) ( Pattern , error ) { res : = pattern { } } } } if strings . Contains ( p , pattern Dir Sep ) { res . is Path = true } res . pattern = strings . Split ( p , pattern Dir Sep ) return & res , nil } 
func ( o * Options ) Validate ( ) error { ents : = o . entries ( ) if len ( ents ) = = 0 { return errors . New ( " " ) } for i , e : = range ents { if err : = e . Validate ( ) ; err ! = nil { return fmt . Errorf ( " " , i , err ) } } return o . Gcs Options . Validate ( ) } 
func ( o * Options ) Add Flags ( flags * flag . Flag Set ) { o . Gcs Options . Add Flags ( flags ) 
func New Job Spec ( spec prowapi . Prow Job Spec , build ID , prow Job ID string ) Job Spec { return Job Spec { Type : spec . Type , Job : spec . Job , Build ID : build ID , Prow Job ID : prow Job ID , Refs : spec . Refs , Extra Refs : spec . Extra Refs , agent : spec . Agent , } } 
func Resolve Spec From Env ( ) ( * Job Spec , error ) { spec Env , ok : = os . Lookup Env ( Job Spec Env ) if ! ok { return nil , fmt . Errorf ( " " , Job Spec Env ) } spec : = & Job Spec { } if err : = json . Unmarshal ( [ ] byte ( spec Env ) , spec ) ; err ! = nil { return nil , fmt . Errorf ( " " , Job Spec Env , err ) } return spec , nil } 
func Env For Spec ( spec Job Spec ) ( map [ string ] string , error ) { env : = map [ string ] string { job Name Env : spec . Job , build IDEnv : spec . Build ID , prow Job IDEnv : spec . Prow Job ID , job Type Env : string ( spec . Type ) , } } raw , err : = json . Marshal ( spec ) if err ! = nil { return env , fmt . Errorf ( " " , err ) } env [ Job Spec Env ] = string ( raw ) if spec . Type = = prowapi . Periodic Job { return env , nil } env [ repo Owner Env ] = spec . Refs . Org env [ repo Name Env ] = spec . Refs . Repo env [ pull Base Ref Env ] = spec . Refs . Base Ref env [ pull Base Sha Env ] = spec . Refs . Base SHA env [ pull Refs Env ] = spec . Refs . String ( ) if spec . Type = = prowapi . Postsubmit Job | | spec . Type = = prowapi . Batch Job { return env , nil } env [ pull Number Env ] = strconv . Itoa ( spec . Refs . Pulls [ 0 ] . Number ) env [ pull Pull Sha Env ] = spec . Refs . Pulls [ 0 ] . SHA return env , nil } 
func Env For Type ( job Type prowapi . Prow Job Type ) [ ] string { base Env : = [ ] string { job Name Env , Job Spec Env , job Type Env , prow Job IDEnv , build IDEnv , prow Build IDEnv } refs Env : = [ ] string { repo Owner Env , repo Name Env , pull Base Ref Env , pull Base Sha Env , pull Refs Env } pull Env : = [ ] string { pull Number Env , pull Pull Sha Env } switch job Type { case prowapi . Periodic Job : return base Env case prowapi . Postsubmit Job , prowapi . Batch Job : return append ( base Env , refs Env . . . ) case prowapi . Presubmit Job : return append ( append ( base Env , refs Env . . . ) , pull Env . . . ) default : return [ ] string { } } } 
func get Revision From Ref ( refs * prowapi . Refs ) string { if len ( refs . Pulls ) > 0 { return refs . Pulls [ 0 ] . SHA } if refs . Base SHA ! = " " { return refs . Base SHA } return refs . Base Ref } 
func Get Revision From Spec ( spec * Job Spec ) string { if spec . Refs ! = nil { return get Revision From Ref ( spec . Refs ) } else if len ( spec . Extra Refs ) > 0 { return get Revision From Ref ( & spec . Extra Refs [ 0 ] ) } return " " } 
func help Provider ( config * plugins . Configuration , enabled Repos [ ] string ) ( * pluginhelp . Plugin Help , error ) { } 
func New Group ( gc gh File Client , owner , repo , sha string ) ( * Group , error ) { g : = & Group { Paths : make ( map [ string ] bool ) , File Names : make ( map [ string ] bool ) , Path Prefixes : make ( map [ string ] bool ) , File Prefixes : make ( map [ string ] bool ) , } bs , err : = gc . Get File ( owner , repo , gen Config File , sha ) if err ! = nil { switch err . ( type ) { case * github . File Not Found : return g , nil default : return nil , fmt . Errorf ( " " , err ) } } repo Files , err : = g . load ( bytes . New Buffer ( bs ) ) if err ! = nil { return nil , err } for _ , f : = range repo Files { bs , err = gc . Get File ( owner , repo , f , sha ) if err ! = nil { return nil , err } if err = g . load Paths ( bytes . New Buffer ( bs ) ) ; err ! = nil { return nil , err } } return g , nil } 
func ( g * Group ) load ( r io . Reader ) ( [ ] string , error ) { var repo Paths [ ] string s : = bufio . New Scanner ( r ) for s . Scan ( ) { l : = strings . Trim Space ( s . Text ( ) ) if l = = " " | | l [ 0 ] = = ' # ' { } fs : = strings . Fields ( l ) if len ( fs ) ! = 2 { return repo Paths , & Parse Error { line : l } } switch fs [ 0 ] { case " " , " " : g . Path Prefixes [ fs [ 1 ] ] = true case " " : g . File Prefixes [ fs [ 1 ] ] = true case " " : g . File Names [ fs [ 1 ] ] = true case " " : g . File Names [ fs [ 1 ] ] = true case " " : default : return repo Paths , & Parse Error { line : l } } } if err : = s . Err ( ) ; err ! = nil { return repo Paths , err } return repo Paths , nil } 
func ( g * Group ) load Paths ( r io . Reader ) error { s : = bufio . New Scanner ( r ) for s . Scan ( ) { l : = strings . Trim Space ( s . Text ( ) ) if l = = " " | | l [ 0 ] = = ' # ' { } g . Paths [ l ] = true } if err : = s . Err ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( g * Group ) Match ( path string ) bool { if g . Paths [ path ] { return true } for prefix : = range g . Path Prefixes { if strings . Has Prefix ( path , prefix ) { return true } } base : = filepath . Base ( path ) if g . File Names [ base ] { return true } for prefix : = range g . File Prefixes { if strings . Has Prefix ( base , prefix ) { return true } } return false } 
func ( config * Influx Config ) Create Database ( tags map [ string ] string , measurement string ) ( * Influx DB , error ) { client , err : = influxdb . New HTTPClient ( influxdb . HTTPConfig { Addr : config . Host , Username : config . User , Password : config . Password , } ) if err ! = nil { return nil , err } err = drop Series ( client , measurement , config . DB , tags ) if err ! = nil { return nil , err } bp , err : = influxdb . New Batch Points ( influxdb . Batch Points Config { Database : config . DB , Precision : " " , } ) if err ! = nil { return nil , err } return & Influx DB { client : client , database : config . DB , batch : bp , tags : tags , measurement : measurement , } , err } 
func merge Tags ( default Tags , extra Tags map [ string ] string ) map [ string ] string { new Tags : = map [ string ] string { } for k , v : = range default Tags { new Tags [ k ] = v } for k , v : = range extra Tags { new Tags [ k ] = v } return new Tags } 
func tags To Where ( tags map [ string ] string ) string { if len ( tags ) = = 0 { return " " } sorted Keys : = [ ] string { } for k : = range tags { sorted Keys = append ( sorted Keys , k ) } sort . Strings ( sorted Keys ) conditions : = [ ] string { } for _ , key : = range sorted Keys { conditions = append ( conditions , fmt . Sprintf ( ` " %s " = ' %v ' ` , key , tags [ key ] ) ) } return " " + strings . Join ( conditions , " " ) } 
func ( i * Influx DB ) Push ( tags map [ string ] string , fields map [ string ] interface { } , date time . Time ) error { pt , err : = influxdb . New Point ( i . measurement , merge Tags ( i . tags , tags ) , fields , date ) if err ! = nil { return err } i . batch . Add Point ( pt ) i . batch Size + + return nil } 
func ( i * Influx DB ) Push Batch Points ( ) error { if err ! = nil { return err } glog . Infof ( " " , i . batch Size ) i . batch Size = 0 if err ! = nil { return err } return nil } 
func ( af * Pod Log Artifact Fetcher ) artifact ( job Name , build ID string , size Limit int 6 4 ) ( lenses . Artifact , error ) { pod Log , err : = New Pod Log Artifact ( job Name , build ID , size Limit , af . job Agent ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return pod Log , nil } 
func role Is Managed ( role * iam . Role ) bool { name : = aws . String Value ( role . Role Name ) path : = aws . String Value ( role . Path ) } } klog . Infof ( " " , name , path ) return false } 
func serve ( ) { http . Handle ( " " , promhttp . Handler ( ) ) logrus . With Error ( http . Listen And Serve ( " " , nil ) ) . Fatal ( " " ) } 
func gather ( c * plank . Controller ) { tick : = time . Tick ( 3 0 * time . Second ) sig : = make ( chan os . Signal , 1 ) signal . Notify ( sig , os . Interrupt , syscall . SIGTERM ) for { select { case < - tick : start : = time . Now ( ) c . Sync Metrics ( ) logrus . With Field ( " " , fmt . Sprintf ( " " , time . Since ( start ) ) ) . Debug ( " " ) case < - sig : logrus . Debug ( " " ) return } } } 
func make Request ( policy branchprotection . Policy ) github . Branch Protection Request { return github . Branch Protection Request { Enforce Admins : make Admins ( policy . Admins ) , Required Pull Request Reviews : make Reviews ( policy . Required Pull Request Reviews ) , Required Status Checks : make Checks ( policy . Required Status Checks ) , Restrictions : make Restrictions ( policy . Restrictions ) , } } 
func make Admins ( val * bool ) * bool { if v : = make Bool ( val ) ; v { return & v } return nil } 
func make Checks ( cp * branchprotection . Context Policy ) * github . Required Status Checks { if cp = = nil { return nil } return & github . Required Status Checks { Contexts : append ( [ ] string { } , sets . New String ( cp . Contexts . . . ) . List ( ) . . . ) , Strict : make Bool ( cp . Strict ) , } } 
func make Restrictions ( rp * branchprotection . Restrictions ) * github . Restrictions { if rp = = nil { return nil } teams : = append ( [ ] string { } , sets . New String ( rp . Teams . . . ) . List ( ) . . . ) users : = append ( [ ] string { } , sets . New String ( rp . Users . . . ) . List ( ) . . . ) return & github . Restrictions { Teams : & teams , Users : & users , } } 
func make Reviews ( rp * branchprotection . Review Policy ) * github . Required Pull Request Reviews { switch { case rp = = nil : return nil case rp . Approvals = = nil : logrus . Warn ( " " ) return nil case * rp . Approvals = = 0 : return nil } rprr : = github . Required Pull Request Reviews { Dismiss Stale Reviews : make Bool ( rp . Dismiss Stale ) , Require Code Owner Reviews : make Bool ( rp . Require Owners ) , Required Approving Review Count : * rp . Approvals , } if rp . Dismissal Restrictions ! = nil { rprr . Dismissal Restrictions = * make Restrictions ( rp . Dismissal Restrictions ) } return & rprr } 
func ( lens Lens ) Header ( artifacts [ ] lenses . Artifact , resource Dir string ) string { return execute Template ( resource Dir , " " , Build Logs View { } ) } 
func ( lens Lens ) Body ( artifacts [ ] lenses . Artifact , resource Dir string , data string ) string { build Logs View : = Build Logs View { Log Views : [ ] Log Artifact View { } , Raw Get All Requests : make ( map [ string ] string ) , Raw Get More Requests : make ( map [ string ] string ) , } lines , err : = log Lines All ( a ) if err ! = nil { logrus . With Error ( err ) . Info ( " " ) continue } av . Line Groups = group Lines ( highlight Lines ( lines , 0 ) ) av . View All = true build Logs View . Log Views = append ( build Logs View . Log Views , av ) } return execute Template ( resource Dir , " " , build Logs View ) } 
func ( lens Lens ) Callback ( artifacts [ ] lenses . Artifact , resource Dir string , data string ) string { var request Line Request err : = json . Unmarshal ( [ ] byte ( data ) , & request ) if err ! = nil { return " " } artifact , ok : = artifact By Name ( artifacts , request . Artifact ) if ! ok { return " " + request . Artifact } var lines [ ] string if request . Offset = = 0 & & request . Length = = - 1 { lines , err = log Lines All ( artifact ) } else { lines , err = log Lines ( artifact , request . Offset , request . Length ) } if err ! = nil { return fmt . Sprintf ( " " , err ) } log Lines : = highlight Lines ( lines , request . Start Line ) return execute Template ( resource Dir , " " , log Lines ) } 
func log Lines All ( artifact lenses . Artifact ) ( [ ] string , error ) { read , err : = artifact . Read All ( ) if err ! = nil { return nil , fmt . Errorf ( " " , artifact . Job Path ( ) , err ) } log Lines : = strings . Split ( string ( read ) , " \n " ) return log Lines , nil } 
func group Lines ( log Lines [ ] Log Line ) [ ] Line Group { } if i + d > = len ( log Lines ) { break } log Lines [ i + d ] . Skip = false } } } previous Offset : = 0 var line Groups [ ] Line Group cur Group : = Line Group { } for i , line : = range log Lines { if line . Skip = = cur Group . Skip { cur Group . Log Lines = append ( cur Group . Log Lines , line ) current Offset + = line . Length } else { cur Group . End = i cur Group . Byte Length = current Offset - previous Offset - 1 previous Offset = current Offset if cur Group . Skip { if cur Group . Lines Skipped ( ) < min Lines Skipped { cur Group . Skip = false } } if len ( cur Group . Log Lines ) > 0 { line Groups = append ( line Groups , cur Group ) } cur Group = Line Group { Skip : line . Skip , Start : i , Log Lines : [ ] Log Line { line } , Byte Offset : current Offset , } current Offset + = line . Length } } cur Group . End = len ( log Lines ) cur Group . Byte Length = current Offset - previous Offset - 1 if cur Group . Skip { if cur Group . Lines Skipped ( ) < min Lines Skipped { cur Group . Skip = false } } if len ( cur Group . Log Lines ) > 0 { line Groups = append ( line Groups , cur Group ) } return line Groups } 
func execute Template ( resource Dir , template Name string , data interface { } ) string { t : = template . New ( " " ) _ , err : = t . Parse Files ( filepath . Join ( resource Dir , " " ) ) if err ! = nil { return fmt . Sprintf ( " " , err ) } var buf bytes . Buffer if err : = t . Execute Template ( & buf , template Name , data ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } return buf . String ( ) } 
func ( in * Resource Object ) Deep Copy Object ( ) runtime . Object { if c : = in . deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * Resource Object ) From Item ( i common . Item ) { r , err : = common . Item To Resource ( i ) if err = = nil { in . from Resource ( r ) } } 
func ( in * Resource Collection ) Set Items ( objects [ ] Object ) { var items [ ] * Resource Object for _ , b : = range objects { items = append ( items , b . ( * Resource Object ) ) } in . Items = items } 
func ( in * Resource Collection ) Deep Copy Object ( ) runtime . Object { if c : = in . deep Copy ( ) ; c ! = nil { return c } return nil } 
func use Context ( o options , ctx string ) error { _ , cmd : = command ( " " , " " , " " , ctx ) return cmd . Run ( ) } 
func current Context ( o options ) ( string , error ) { _ , cmd : = command ( " " , " " , " " ) b , err : = cmd . Output ( ) return strings . Trim Space ( string ( b ) ) , err } 
func get Credentials ( o options ) error { if ! o . change Context { cur , err : = current Context ( o ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer use Context ( o , cur ) } if set { defer os . Setenv ( use Client Cert Env , old ) } if err : = os . Setenv ( " " , " " ) ; err ! = nil { return fmt . Errorf ( " " , use Client Cert Env , err ) } args , cmd : = command ( " " , " " , " " , " " , o . cluster , " " , o . project , " " , o . zone , ) if err : = cmd . Run ( ) ; err ! = nil { return fmt . Errorf ( " " , strings . Join ( args , " " ) , err ) } return nil } 
func command ( bin string , args . . . string ) ( [ ] string , * exec . Cmd ) { cmd : = exec . Command ( bin , args . . . ) cmd . Stderr = os . Stderr return append ( [ ] string { bin } , args . . . ) , cmd } 
func get Account ( ) ( string , error ) { args , cmd : = command ( " " , " " , " " , " " ) b , err : = cmd . Output ( ) if err ! = nil { return " " , fmt . Errorf ( " " , strings . Join ( args , " " ) , err ) } return strings . Trim Space ( string ( b ) ) , nil } 
func set Account ( account string ) error { _ , cmd : = command ( " " , " " , " " , " " , account ) return cmd . Run ( ) } 
func describe Cluster ( o options ) ( * describe , error ) { if o . account ! = " " { act , err : = get Account ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } defer set Account ( act ) if err = set Account ( o . account ) ; err ! = nil { return nil , fmt . Errorf ( " " , o . account , err ) } } args , cmd : = command ( " " , " " , " " , " " , o . cluster , " " , o . project , " " , o . zone , " " , ) data , err : = cmd . Output ( ) if err ! = nil { return nil , fmt . Errorf ( " " , strings . Join ( args , " " ) , err ) } var d describe if yaml . Unmarshal ( data , & d ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if d . Endpoint = = " " { return nil , errors . New ( " " ) } if len ( d . Auth . Cluster CACertificate ) = = 0 { return nil , errors . New ( " " ) } if len ( d . Auth . Client Key ) = = 0 { return nil , errors . New ( " " ) } if len ( d . Auth . Client Certificate ) = = 0 { return nil , errors . New ( " " ) } return & d , nil } 
func do ( o options ) error { } } if err ! = nil { return fmt . Errorf ( " " , err ) } new Cluster : = kube . Cluster { Endpoint : " " + d . Endpoint , Cluster CACertificate : d . Auth . Cluster CACertificate , Client Key : d . Auth . Client Key , Client Certificate : d . Auth . Client Certificate , } if err ! = nil { return fmt . Errorf ( " " , err ) } if _ , err = c . List Pods ( " " ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " ) return fmt . Errorf ( " " , err ) } } if err ! = nil { return fmt . Errorf ( " " , o . alias , err ) } fmt . Println ( string ( data ) ) return nil } if err ! = nil { return fmt . Errorf ( " " , err ) } var s coreapi . Secret if err : = yaml . Unmarshal ( b , & s ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err ! = nil { return fmt . Errorf ( " " , err ) } var existing [ ] string for a : = range clusters { existing = append ( existing , a ) } logrus . Infof ( " " , strings . Join ( existing , " " ) ) if ok & & ! o . overwrite { return fmt . Errorf ( " " , o . alias ) } clusters [ o . alias ] = new Cluster logrus . Infof ( " " , o . alias ) if err ! = nil { return fmt . Errorf ( " " , err ) } if o . print Data { return nil } buf , err : = yaml . Marshal ( s ) if err ! = nil { return fmt . Errorf ( " " , err ) } fmt . Println ( string ( buf ) ) return nil } 
func ( ss * strslice ) Set ( value string ) error { * ss = append ( * ss , value ) return nil } 
func split Bucket Object ( path string ) ( string , string ) { path = strings . Trim ( path , " " ) parts : = strings . Split N ( path , " " , 2 ) if len ( parts ) = = 0 { return " " , " " } if len ( parts ) = = 1 { return parts [ 0 ] , " " } return parts [ 0 ] , parts [ 1 ] } 
func dirname ( path string ) string { leading : = " " if strings . Has Prefix ( path , " " ) { leading = " " } parts : = strings . Split ( strings . Trim ( path , " " ) , " " ) if len ( parts ) > 1 { return leading + strings . Join ( parts [ 0 : len ( parts ) - 1 ] , " " ) + " " } return leading } 
func parse XML ( body [ ] byte , object string ) ( * gcs Dir , error ) { dir : = new ( gcs Dir ) if err : = xml . Unmarshal ( body , & dir ) ; err ! = nil { return nil , err } self Index : = - 1 for i : = range dir . Contents { rec : = & dir . Contents [ i ] name : = strings . Trim Prefix ( rec . Name , object ) if name = = " " { self Index = i continue } rec . Name = name if strings . Has Suffix ( name , " " ) { rec . is Dir = true } } for i : = range dir . Common Prefixes { cp : = & dir . Common Prefixes [ i ] cp . Prefix = strings . Trim Prefix ( cp . Prefix , object ) } if ! is Dir { return nil , nil } if self Index > = 0 { } return dir , nil } 
func ( dir * gcs Dir ) Render ( out http . Response Writer , in Path string ) { html Page Header ( out , dir . Name ) if ! strings . Has Suffix ( in Path , " " ) { in Path + = " " } html Content Header ( out , dir . Name , in Path ) if dir . Next Marker ! = " " { html Next Button ( out , gcs Path + in Path , dir . Next Marker ) } html Grid Header ( out ) if parent : = dirname ( in Path ) ; parent ! = " " { url : = gcs Path + parent html Grid Item ( out , icon Back , url , " " , " " , " " ) } for i : = range dir . Common Prefixes { dir . Common Prefixes [ i ] . Render ( out , in Path ) } for i : = range dir . Contents { dir . Contents [ i ] . Render ( out , in Path ) } if dir . Next Marker ! = " " { html Next Button ( out , gcs Path + in Path , dir . Next Marker ) } html Content Footer ( out ) html Page Footer ( out ) } 
func ( rec * Record ) Render ( out http . Response Writer , in Path string ) { mtime : = " " ts , err : = time . Parse ( time . RFC 3 3 3 9 , rec . MTime ) if err = = nil { mtime = ts . Format ( " " ) } var url , size string if rec . is Dir { url = gcs Path + in Path + rec . Name size = " " } else { url = gcs Base URL + in Path + rec . Name size = fmt . Sprintf ( " " , rec . Size ) } html Grid Item ( out , icon File , url , rec . Name , size , mtime ) } 
func ( pfx * Prefix ) Render ( out http . Response Writer , in Path string ) { url : = gcs Path + in Path + pfx . Prefix html Grid Item ( out , icon Dir , url , pfx . Prefix , " " , " " ) } 
func ( tl txn Logger ) Printf ( fmt string , args . . . interface { } ) { args = append ( [ ] interface { } { tl . nonce } , args . . . ) log . Printf ( " " + fmt , args . . . ) } 
func process Regex Matches ( matches [ ] string ) ( string , string , bool , string ) { var should Clear = false proposed Project : = matches [ 1 ] proposed Column Name : = " " if len ( matches ) > 1 & & proposed Project ! = clear Keyword { proposed Column Name = matches [ 2 ] } should Clear = true } else { msg : = invalid Num Args return " " , " " , false , msg } } return proposed Project , proposed Column Name , should Clear , " " } 
func ( p Projects Flag ) Set ( value string ) error { parts : = strings . Split N ( value , " " , 2 ) if len ( parts ) ! = 2 { return fmt . Errorf ( " " , value ) } host : = parts [ 0 ] if _ , ok : = p [ host ] ; ok { return fmt . Errorf ( " " , host ) } repos : = strings . Split ( parts [ 1 ] , " " ) p [ host ] = repos return nil } 
func New Client ( instances map [ string ] [ ] string ) ( * Client , error ) { c : = & Client { handlers : map [ string ] * gerrit Instance Handler { } , } for instance : = range instances { gc , err : = gerrit . New Client ( instance , nil ) if err ! = nil { return nil , err } c . handlers [ instance ] = & gerrit Instance Handler { instance : instance , projects : instances [ instance ] , auth Service : gc . Authentication , account Service : gc . Accounts , change Service : gc . Changes , project Service : gc . Projects , } } return c , nil } 
func ( c * Client ) Query Changes ( last Update time . Time , rate Limit int ) map [ string ] [ ] Change Info { result : = map [ string ] [ ] Change Info { } for _ , h : = range c . handlers { changes : = h . query All Changes ( last Update , rate Limit ) if len ( changes ) > 0 { result [ h . instance ] = [ ] Change Info { } for _ , change : = range changes { result [ h . instance ] = append ( result [ h . instance ] , change ) } } } return result } 
func ( c * Client ) Set Review ( instance , id , revision , message string , labels map [ string ] string ) error { h , ok : = c . handlers [ instance ] if ! ok { return fmt . Errorf ( " " , instance ) } if _ , _ , err : = h . change Service . Set Review ( id , revision , & gerrit . Review Input { Message : message , Labels : labels , } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( c * Client ) Get Branch Revision ( instance , project , branch string ) ( string , error ) { h , ok : = c . handlers [ instance ] if ! ok { return " " , fmt . Errorf ( " " , instance ) } res , _ , err : = h . project Service . Get Branch ( project , branch ) if err ! = nil { return " " , err } return res . Revision , nil } 
func ( h * gerrit Instance Handler ) query All Changes ( last Update time . Time , rate Limit int ) [ ] gerrit . Change Info { result : = [ ] gerrit . Change Info { } for _ , project : = range h . projects { changes , err : = h . query Changes For Project ( project , last Update , rate Limit ) if err ! = nil { continue } result = append ( result , changes . . . ) } return result } 
func New Type Filter Wrapper Plugin ( plugin Plugin ) * Type Filter Wrapper Plugin { return & Type Filter Wrapper Plugin { plugin : plugin , pass : map [ string ] bool { } , } } 
func ( t * Type Filter Wrapper Plugin ) Add Flags ( cmd * cobra . Command ) { cmd . Flags ( ) . Bool Var ( & t . pull Requests , " " , false , " " ) cmd . Flags ( ) . Bool Var ( & t . issues , " " , false , " " ) } 
func ( t * Type Filter Wrapper Plugin ) Check Flags ( ) error { if t . pull Requests & & t . issues { return fmt . Errorf ( " " ) } return nil } 
func ( t * Type Filter Wrapper Plugin ) Receive Issue ( issue sql . Issue ) [ ] Point { if issue . Is PR & & t . pull Requests { return nil } else if ! issue . Is PR & & t . issues { return nil } else { t . pass [ issue . ID ] = true return t . plugin . Receive Issue ( issue ) } } 
func ( t * Type Filter Wrapper Plugin ) Receive Issue Event ( event sql . Issue Event ) [ ] Point { if ! t . pass [ event . Issue ID ] { return nil } return t . plugin . Receive Issue Event ( event ) } 
func ( t * Type Filter Wrapper Plugin ) Receive Comment ( comment sql . Comment ) [ ] Point { if ! t . pass [ comment . Issue ID ] { return nil } return t . plugin . Receive Comment ( comment ) } 
func ( o * Kubernetes Client Options ) Add Flags ( fs * flag . Flag Set ) { fs . String Var ( & o . namespace , " " , v 1 . Namespace Default , " " ) fs . String Var ( & o . kube Config , " " , " " , " " ) fs . Bool Var ( & o . in Memory , " " , false , " " ) } 
func ( o * Kubernetes Client Options ) Validate ( ) error { if o . kube Config ! = " " { if _ , err : = os . Stat ( o . kube Config ) ; err ! = nil { return err } } return nil } 
func ( o * Kubernetes Client Options ) Client ( t Type ) ( Client Interface , error ) { if o . in Memory { return new Dummy Client ( t ) , nil } return o . new CRDClient ( t ) } 
func ( o * Kubernetes Client Options ) new CRDClient ( t Type ) ( * Client , error ) { config , scheme , err : = create RESTConfig ( o . kube Config , t ) if err ! = nil { return nil , err } if err = register Resource ( config , t ) ; err ! = nil { return nil , err } rest Client , err = rest . RESTClient For ( config ) if err ! = nil { return nil , err } rc : = Client { cl : rest Client , ns : o . namespace , t : t , codec : runtime . New Parameter Codec ( scheme ) } return & rc , nil } 
func create RESTConfig ( kubeconfig string , t Type ) ( config * rest . Config , types * runtime . Scheme , err error ) { if kubeconfig = = " " { config , err = rest . In Cluster Config ( ) } else { config , err = clientcmd . Build Config From Flags ( " " , kubeconfig ) } if err ! = nil { return } version : = schema . Group Version { Group : group , Version : version , } config . Group Version = & version config . APIPath = " " config . Content Type = runtime . Content Type JSON types = runtime . New Scheme ( ) scheme Builder : = runtime . New Scheme Builder ( func ( scheme * runtime . Scheme ) error { scheme . Add Known Types ( version , t . Object , t . Collection ) v 1 . Add To Group Version ( scheme , version ) return nil } ) err = scheme Builder . Add To Scheme ( types ) config . Negotiated Serializer = serializer . Direct Codec Factory { Codec Factory : serializer . New Codec Factory ( types ) } return } 
func register Resource ( config * rest . Config , t Type ) error { c , err : = apiextensionsclient . New For Config ( config ) if err ! = nil { return err } crd : = & apiextensionsv 1beta 1 . Custom Resource Definition { Object Meta : v 1 . Object Meta { Name : fmt . Sprintf ( " " , t . Plural , group ) , } , Spec : apiextensionsv 1beta 1 . Custom Resource Definition Spec { Group : group , Version : version , Scope : apiextensionsv 1beta 1 . Namespace Scoped , Names : apiextensionsv 1beta 1 . Custom Resource Definition Names { Singular : t . Singular , Plural : t . Plural , Kind : t . Kind , List Kind : t . List Kind , } , } , } if _ , err : = c . Apiextensions V 1beta 1 ( ) . Custom Resource Definitions ( ) . Create ( crd ) ; err ! = nil & & ! apierrors . Is Already Exists ( err ) { return err } return nil } 
func new Dummy Client ( t Type ) * dummy Client { c : = & dummy Client { t : t , objects : make ( map [ string ] Object ) , } return c } 
func ( c * dummy Client ) Create ( obj Object ) ( Object , error ) { c . objects [ obj . Get Name ( ) ] = obj return obj , nil } 
func ( c * dummy Client ) Update ( obj Object ) ( Object , error ) { _ , ok : = c . objects [ obj . Get Name ( ) ] if ! ok { return nil , fmt . Errorf ( " " , obj . Get Name ( ) ) } c . objects [ obj . Get Name ( ) ] = obj return obj , nil } 
func ( c * dummy Client ) Delete ( name string , options * v 1 . Delete Options ) error { _ , ok : = c . objects [ name ] if ok { delete ( c . objects , name ) return nil } return fmt . Errorf ( " " , name ) } 
func ( c * dummy Client ) Get ( name string ) ( Object , error ) { obj , ok : = c . objects [ name ] if ok { return obj , nil } return nil , fmt . Errorf ( " " , name ) } 
func ( c * dummy Client ) List ( opts v 1 . List Options ) ( Collection , error ) { var items [ ] Object for _ , i : = range c . objects { items = append ( items , i ) } r : = c . New Collection ( ) r . Set Items ( items ) return r , nil } 
func ( c * Client ) Create ( obj Object ) ( Object , error ) { result : = c . New Object ( ) err : = c . cl . Post ( ) . Namespace ( c . ns ) . Resource ( c . t . Plural ) . Name ( obj . Get Name ( ) ) . Body ( obj ) . Do ( ) . Into ( result ) return result , err } 
func ( c * Client ) Delete ( name string , options * v 1 . Delete Options ) error { return c . cl . Delete ( ) . Namespace ( c . ns ) . Resource ( c . t . Plural ) . Name ( name ) . Body ( options ) . Do ( ) . Error ( ) } 
func ( c * Client ) Get ( name string ) ( Object , error ) { result : = c . New Object ( ) err : = c . cl . Get ( ) . Namespace ( c . ns ) . Resource ( c . t . Plural ) . Name ( name ) . Do ( ) . Into ( result ) return result , err } 
func ( c * Client ) List ( opts v 1 . List Options ) ( Collection , error ) { result : = c . New Collection ( ) err : = c . cl . Get ( ) . Namespace ( c . ns ) . Resource ( c . t . Plural ) . Versioned Params ( & opts , c . codec ) . Do ( ) . Into ( result ) return result , err } 
func Trusted Pull Request ( ghc github Client , trigger plugins . Trigger , author , org , repo string , num int , l [ ] github . Label ) ( [ ] github . Label , bool , error ) { } else if org Member { return l , true , nil } l , err = ghc . Get Issue Labels ( org , repo , num ) if err ! = nil { return l , false , err } } return l , github . Has Label ( labels . Ok To Test , l ) , nil } 
func build All ( c Client , pr * github . Pull Request , event GUID string , elide Skipped Contexts bool ) error { org , repo , number , branch : = pr . Base . Repo . Owner . Login , pr . Base . Repo . Name , pr . Number , pr . Base . Ref changes : = config . New Git Hub Deferred Changed Files Provider ( c . Git Hub Client , org , repo , number ) to Test , to Skip Superset , err : = pjutil . Filter Presubmits ( pjutil . Test All Filter ( ) , changes , branch , c . Config . Presubmits [ pr . Base . Repo . Full Name ] , c . Logger ) if err ! = nil { return err } to Skip : = determine Skipped Presubmits ( to Test , to Skip Superset , c . Logger ) return run And Skip Jobs ( c , pr , to Test , to Skip , event GUID , elide Skipped Contexts ) } 
func ( o Options ) Run ( ctx context . Context ) ( int , error ) { spec , err : = downwardapi . Resolve Spec From Env ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } ctx , cancel : = context . With Cancel ( ctx ) signal . Notify ( interrupt , os . Interrupt , syscall . SIGTERM ) go func ( ) { select { case s : = < - interrupt : logrus . Errorf ( " " , s ) cancel ( ) case < - ctx . Done ( ) : } } ( ) if o . Deprecated Wrapper Options ! = nil { } entries : = o . entries ( ) passed , aborted , failures : = wait ( ctx , entries ) cancel ( ) build Log : = log Reader ( entries ) metadata : = combine Metadata ( entries ) return failures , o . do Upload ( spec , passed , aborted , metadata , build Log ) } 
func ( s * Storage ) Add Config ( conf common . Resources Config ) error { return s . configs . Add ( conf ) } 
func ( s * Storage ) Delete Config ( name string ) error { return s . configs . Delete ( name ) } 
func ( s * Storage ) Update Config ( conf common . Resources Config ) error { return s . configs . Update ( conf ) } 
func ( s * Storage ) Get Config ( name string ) ( common . Resources Config , error ) { i , err : = s . configs . Get ( name ) if err ! = nil { return common . Resources Config { } , err } var conf common . Resources Config conf , err = common . Item To Resources Config ( i ) if err ! = nil { return common . Resources Config { } , err } return conf , nil } 
func ( s * Storage ) Get Configs ( ) ( [ ] common . Resources Config , error ) { var configs [ ] common . Resources Config items , err : = s . configs . List ( ) if err ! = nil { return configs , err } for _ , i : = range items { var conf common . Resources Config conf , err = common . Item To Resources Config ( i ) if err ! = nil { return nil , err } configs = append ( configs , conf ) } return configs , nil } 
func ( s * Storage ) Sync Configs ( new Configs [ ] common . Resources Config ) error { s . configs Lock . Lock ( ) defer s . configs Lock . Unlock ( ) current Configs , err : = s . Get Configs ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) return err } current Set : = mapset . New Set ( ) new Set : = mapset . New Set ( ) to Update : = mapset . New Set ( ) configs : = map [ string ] common . Resources Config { } for _ , c : = range current Configs { current Set . Add ( c . Name ) configs [ c . Name ] = c } for _ , c : = range new Configs { new Set . Add ( c . Name ) if old , exists : = configs [ c . Name ] ; exists { if ! reflect . Deep Equal ( old , c ) { to Update . Add ( c . Name ) configs [ c . Name ] = c } } else { configs [ c . Name ] = c } } var final Error error to Delete : = current Set . Difference ( new Set ) to Add : = new Set . Difference ( current Set ) for _ , n : = range to Delete . To Slice ( ) { logrus . Infof ( " " , n . ( string ) ) if err : = s . Delete Config ( n . ( string ) ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , n ) final Error = multierror . Append ( final Error , err ) } } for _ , n : = range to Add . To Slice ( ) { rc : = configs [ n . ( string ) ] logrus . Infof ( " " , n . ( string ) ) if err : = s . Add Config ( rc ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , n ) final Error = multierror . Append ( final Error , err ) } } for _ , n : = range to Update . To Slice ( ) { rc : = configs [ n . ( string ) ] logrus . Infof ( " " , n . ( string ) ) if err : = s . Update Config ( rc ) ; err ! = nil { logrus . With Error ( err ) . Errorf ( " " , n ) final Error = multierror . Append ( final Error , err ) } } return final Error } 
func add Known Types ( scheme * runtime . Scheme ) error { scheme . Add Known Types ( Scheme Group Version , & Prow Job { } , & Prow Job List { } , ) metav 1 . Add To Group Version ( scheme , Scheme Group Version ) return nil } 
func New Controller ( continue On Error bool , added Presubmit Blacklist sets . String , prow Job Client prowv 1 . Prow Job Interface , github Client * github . Client , config Agent * config . Agent , plugin Agent * plugins . Config Agent ) * Controller { return & Controller { continue On Error : continue On Error , added Presubmit Blacklist : added Presubmit Blacklist , prow Job Triggerer : & kube Prow Job Triggerer { prow Job Client : prow Job Client , github Client : github Client , config Agent : config Agent , } , github Client : github Client , status Migrator : & git Hub Migrator { github Client : github Client , continue On Error : continue On Error , } , trusted Checker : & github Trusted Checker { github Client : github Client , plugin Agent : plugin Agent , } , } } 
func ( c * Controller ) Run ( stop < - chan os . Signal , changes < - chan config . Delta ) { for { select { case change : = < - changes : start : = time . Now ( ) if err : = c . reconcile ( change ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } logrus . With Field ( " " , fmt . Sprintf ( " " , time . Since ( start ) ) ) . Info ( " " ) case < - stop : logrus . Info ( " " ) return } } } 
func added Blocking Presubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] config . Presubmit { added : = map [ string ] [ ] config . Presubmit { } for repo , old Presubmits : = range old { added [ repo ] = [ ] config . Presubmit { } for _ , new Presubmit : = range new [ repo ] { if ! new Presubmit . Context Required ( ) | | new Presubmit . Needs Explicit Trigger ( ) { continue } var found bool for _ , old Presubmit : = range old Presubmits { if old Presubmit . Name = = new Presubmit . Name { if old Presubmit . Skip Report & & ! new Presubmit . Skip Report { added [ repo ] = append ( added [ repo ] , new Presubmit ) logrus . With Fields ( logrus . Fields { " " : repo , " " : old Presubmit . Name , } ) . Debug ( " " ) } if old Presubmit . Run If Changed ! = new Presubmit . Run If Changed { added [ repo ] = append ( added [ repo ] , new Presubmit ) logrus . With Fields ( logrus . Fields { " " : repo , " " : old Presubmit . Name , } ) . Debug ( " " ) } found = true break } } if ! found { added [ repo ] = append ( added [ repo ] , new Presubmit ) logrus . With Fields ( logrus . Fields { " " : repo , " " : new Presubmit . Name , } ) . Debug ( " " ) } } } var num Added int for _ , presubmits : = range added { num Added + = len ( presubmits ) } logrus . Infof ( " " , num Added ) return added } 
func removed Blocking Presubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] config . Presubmit { removed : = map [ string ] [ ] config . Presubmit { } for repo , old Presubmits : = range old { removed [ repo ] = [ ] config . Presubmit { } for _ , old Presubmit : = range old Presubmits { if ! old Presubmit . Context Required ( ) { continue } var found bool for _ , new Presubmit : = range new [ repo ] { if old Presubmit . Name = = new Presubmit . Name { found = true break } } if ! found { removed [ repo ] = append ( removed [ repo ] , old Presubmit ) logrus . With Fields ( logrus . Fields { " " : repo , " " : old Presubmit . Name , } ) . Debug ( " " ) } } } var num Removed int for _ , presubmits : = range removed { num Removed + = len ( presubmits ) } logrus . Infof ( " " , num Removed ) return removed } 
func migrated Blocking Presubmits ( old , new map [ string ] [ ] config . Presubmit ) map [ string ] [ ] presubmit Migration { migrated : = map [ string ] [ ] presubmit Migration { } for repo , old Presubmits : = range old { migrated [ repo ] = [ ] presubmit Migration { } for _ , new Presubmit : = range new [ repo ] { if ! new Presubmit . Context Required ( ) { continue } for _ , old Presubmit : = range old Presubmits { if old Presubmit . Context ! = new Presubmit . Context & & old Presubmit . Name = = new Presubmit . Name { migrated [ repo ] = append ( migrated [ repo ] , presubmit Migration { from : old Presubmit , to : new Presubmit } ) logrus . With Fields ( logrus . Fields { " " : repo , " " : old Presubmit . Name , " " : old Presubmit . Context , " " : new Presubmit . Context , } ) . Debug ( " " ) } } } } var num Migrated int for _ , presubmits : = range migrated { num Migrated + = len ( presubmits ) } logrus . Infof ( " " , num Migrated ) return migrated } 
func Load ( loader Option Loader ) error { if json Config , provided : = os . Lookup Env ( loader . Config Var ( ) ) ; provided { if err : = loader . Load Config ( json Config ) ; err ! = nil { return fmt . Errorf ( " " , loader . Config Var ( ) , err ) } return nil } fs : = flag . New Flag Set ( os . Args [ 0 ] , flag . Exit On Error ) loader . Add Flags ( fs ) fs . Parse ( os . Args [ 1 : ] ) loader . Complete ( fs . Args ( ) ) return nil } 
func New Controller ( prow Job Client prowv 1 . Prow Job Interface , jc * Client , ghc * github . Client , logger * logrus . Entry , cfg config . Getter , tot URL , selector string ) ( * Controller , error ) { n , err : = snowflake . New Node ( 1 ) if err ! = nil { return nil , err } if logger = = nil { logger = logrus . New Entry ( logrus . Standard Logger ( ) ) } return & Controller { prow Job Client : prow Job Client , jc : jc , ghc : ghc , log : logger , cfg : cfg , selector : selector , node : n , tot URL : tot URL , pending Jobs : make ( map [ string ] int ) , } , nil } 
func ( c * Controller ) can Execute Concurrently ( pj * prowapi . Prow Job ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) if max : = c . config ( ) . Max Concurrency ; max > 0 { var running int for _ , num : = range c . pending Jobs { running + = num } if running > = max { c . log . With Fields ( pjutil . Prow Job Fields ( pj ) ) . Debugf ( " " , running ) return false } } if pj . Spec . Max Concurrency = = 0 { c . pending Jobs [ pj . Spec . Job ] + + return true } num Pending : = c . pending Jobs [ pj . Spec . Job ] if num Pending > = pj . Spec . Max Concurrency { c . log . With Fields ( pjutil . Prow Job Fields ( pj ) ) . Debugf ( " " , pj . Spec . Job , num Pending ) return false } c . pending Jobs [ pj . Spec . Job ] + + return true } 
func ( c * Controller ) Sync ( ) error { pjs , err : = c . prow Job Client . List ( metav 1 . List Options { Label Selector : c . selector } ) if err ! = nil { return fmt . Errorf ( " " , err ) } c . pjs = pjs . Items c . pj Lock . Unlock ( ) for _ , pj : = range pjs . Items { if pj . Spec . Agent = = prowapi . Jenkins Agent { jenkins Jobs = append ( jenkins Jobs , pj ) } } jbs , err : = c . jc . List Builds ( get Jenkins Jobs ( jenkins Jobs ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } var sync Errs [ ] error if err : = c . terminate Dupes ( jenkins Jobs , jbs ) ; err ! = nil { sync Errs = append ( sync Errs , err ) } pending Ch , triggered Ch : = pjutil . Partition Active ( jenkins Jobs ) err Ch : = make ( chan error , len ( jenkins Jobs ) ) report Ch : = make ( chan prowapi . Prow Job , len ( jenkins Jobs ) ) c . log . Debugf ( " " , len ( pending Ch ) ) sync Prow Jobs ( c . log , c . sync Pending Job , max Sync Routines , pending Ch , report Ch , err Ch , jbs ) c . log . Debugf ( " " , len ( triggered Ch ) ) sync Prow Jobs ( c . log , c . sync Triggered Job , max Sync Routines , triggered Ch , report Ch , err Ch , jbs ) close ( err Ch ) close ( report Ch ) for err : = range err Ch { sync Errs = append ( sync Errs , err ) } var report Errs [ ] error report Template : = c . config ( ) . Report Template report Types : = c . cfg ( ) . Git Hub Reporter . Job Types To Report for report : = range report Ch { if err : = reportlib . Report ( c . ghc , report Template , report , report Types ) ; err ! = nil { report Errs = append ( report Errs , err ) c . log . With Fields ( pjutil . Prow Job Fields ( & report ) ) . With Error ( err ) . Warn ( " " ) } } if len ( sync Errs ) = = 0 & & len ( report Errs ) = = 0 { return nil } return fmt . Errorf ( " " , sync Errs , report Errs ) } 
func get Jenkins Jobs ( pjs [ ] prowapi . Prow Job ) [ ] Build Query Params { jenkins Jobs : = [ ] Build Query Params { } for _ , pj : = range pjs { if pj . Complete ( ) { continue } jenkins Jobs = append ( jenkins Jobs , Build Query Params { Job Name : get Job Name ( & pj . Spec ) , Prow Job ID : pj . Name , } ) } return jenkins Jobs } 
func ( c * Controller ) terminate Dupes ( pjs [ ] prowapi . Prow Job , jbs map [ string ] Build ) error { for i , pj : = range pjs { if pj . Complete ( ) | | pj . Spec . Type ! = prowapi . Presubmit Job { continue } n : = fmt . Sprintf ( " " , pj . Spec . Job , pj . Spec . Refs . Org , pj . Spec . Refs . Repo , pj . Spec . Refs . Pulls [ 0 ] . Number ) prev , ok : = dupes [ n ] if ! ok { dupes [ n ] = i continue } cancel Index : = i if ( & pjs [ prev ] . Status . Start Time ) . Before ( & pj . Status . Start Time ) { cancel Index = prev dupes [ n ] = i } to Cancel : = pjs [ cancel Index ] } } } } to Cancel . Set Complete ( ) prev State : = to Cancel . Status . State to Cancel . Status . State = prowapi . Aborted State c . log . With Fields ( pjutil . Prow Job Fields ( & to Cancel ) ) . With Field ( " " , prev State ) . With Field ( " " , to Cancel . Status . State ) . Info ( " " ) npj , err : = c . prow Job Client . Update ( & to Cancel ) if err ! = nil { return err } pjs [ cancel Index ] = * npj } return nil } 
func ( c * Client ) Throttle ( hourly Tokens , burst int ) { c . log ( " " , hourly Tokens , burst ) c . throttle . lock . Lock ( ) defer c . throttle . lock . Unlock ( ) previously Throttled : = c . throttle . ticker ! = nil if hourly Tokens < = 0 | | burst < = 0 { c . gqlc = c . throttle . graph c . throttle . ticker . Stop ( ) c . throttle . ticker = nil } return } rate : = time . Hour / time . Duration ( hourly Tokens ) ticker : = time . New Ticker ( rate ) throttle : = make ( chan time . Time , burst ) for i : = 0 ; i < burst ; i + + { } go func ( ) { } } ( ) if ! previously Throttled { c . throttle . graph = c . gqlc c . client = & c . throttle c . gqlc = & c . throttle } c . throttle . ticker = ticker c . throttle . throttle = throttle } 
func New Client With Fields ( fields logrus . Fields , get Token func ( ) [ ] byte , graphql Endpoint string , bases . . . string ) * Client { return & Client { logger : logrus . With Fields ( fields ) . With Field ( " " , " " ) , time : & standard Time { } , gqlc : githubql . New Enterprise Client ( graphql Endpoint , & http . Client { Timeout : max Request Time , Transport : & oauth 2 . Transport { Source : new Reloading Token Source ( get Token ) } , } ) , client : & http . Client { Timeout : max Request Time } , bases : bases , get Token : get Token , dry : false , } } 
func New Client ( get Token func ( ) [ ] byte , graphql Endpoint string , bases . . . string ) * Client { return New Client With Fields ( logrus . Fields { } , get Token , graphql Endpoint , bases . . . ) } 
func New Dry Run Client ( get Token func ( ) [ ] byte , graphql Endpoint string , bases . . . string ) * Client { return New Dry Run Client With Fields ( logrus . Fields { } , get Token , graphql Endpoint , bases . . . ) } 
func New Fake Client ( ) * Client { return & Client { logger : logrus . With Field ( " " , " " ) , time : & standard Time { } , fake : true , dry : true , } } 
func ( c * Client ) request ( r * request , ret interface { } ) ( int , error ) { status Code , b , err : = c . request Raw ( r ) if err ! = nil { return status Code , err } if ret ! = nil { if err : = json . Unmarshal ( b , ret ) ; err ! = nil { return status Code , err } } return status Code , nil } 
func ( c * Client ) request Raw ( r * request ) ( int , [ ] byte , error ) { if c . fake | | ( c . dry & & r . method ! = http . Method Get ) { return r . exit Codes [ 0 ] , nil , nil } resp , err : = c . request Retry ( r . method , r . path , r . accept , r . request Body ) if err ! = nil { return 0 , nil , err } defer resp . Body . Close ( ) b , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return 0 , nil , err } var ok Code bool for _ , code : = range r . exit Codes { if code = = resp . Status Code { ok Code = true break } } if ! ok Code { client Error : = unmarshal Client Error ( b ) err = request Error { Client Error : client Error , Error String : fmt . Sprintf ( " " , resp . Status Code , r . exit Codes , string ( b ) ) , } } return resp . Status Code , b , err } 
func ( c * Client ) request Retry ( method , path , accept string , body interface { } ) ( * http . Response , error ) { var host Index int var resp * http . Response var err error backoff : = initial Delay for retries : = 0 ; retries < max Retries ; retries + + { if retries > 0 & & resp ! = nil { resp . Body . Close ( ) } resp , err = c . do Request ( method , c . bases [ host Index ] + path , accept , body ) if err = = nil { if resp . Status Code = = 4 0 4 & & retries < max 4 0 4Retries { backoff * = 2 } else if resp . Status Code = = 4 0 3 { if resp . Header . Get ( " " ) = = " " { if t , err = strconv . Atoi ( resp . Header . Get ( " " ) ) ; err = = nil { if sleep Time < max Sleep Time { c . time . Sleep ( sleep Time ) } else { err = fmt . Errorf ( " " , sleep Time , max Sleep Time ) resp . Body . Close ( ) break } } else { err = fmt . Errorf ( " " , resp . Header . Get ( " " ) , err ) resp . Body . Close ( ) break } } else if raw Time : = resp . Header . Get ( " " ) ; raw Time ! = " " & & raw Time ! = " " { if t , err = strconv . Atoi ( raw Time ) ; err = = nil { if sleep Time < max Sleep Time { c . time . Sleep ( sleep Time ) } else { err = fmt . Errorf ( " " , sleep Time , max Sleep Time ) resp . Body . Close ( ) break } } else { err = fmt . Errorf ( " " , raw Time , err ) resp . Body . Close ( ) break } } else if oauth Scopes : = resp . Header . Get ( " " ) ; len ( oauth Scopes ) > 0 { authorized Scopes : = resp . Header . Get ( " " ) if authorized Scopes = = " " { authorized Scopes = " " } err = fmt . Errorf ( " " , authorized Scopes , oauth Scopes ) resp . Body . Close ( ) break } } else if resp . Status Code < 5 0 0 { } else { backoff * = 2 } } else { c . time . Sleep ( backoff ) backoff * = 2 } } return resp , err } 
func ( c * Client ) get User Data ( ) error { c . log ( " " ) var u User _ , err : = c . request ( & request { method : http . Method Get , path : " " , exit Codes : [ ] int { 2 0 0 } , } , & u ) if err ! = nil { return err } c . bot Name = u . Login return nil } 
func ( c * Client ) Bot Name ( ) ( string , error ) { c . mut . Lock ( ) defer c . mut . Unlock ( ) if c . bot Name = = " " { if err : = c . get User Data ( ) ; err ! = nil { return " " , fmt . Errorf ( " " , err ) } } return c . bot Name , nil } 
func ( c * Client ) Email ( ) ( string , error ) { c . mut . Lock ( ) defer c . mut . Unlock ( ) if c . email = = " " { if err : = c . get User Data ( ) ; err ! = nil { return " " , fmt . Errorf ( " " , err ) } } return c . email , nil } 
func ( c * Client ) Is Member ( org , user string ) ( bool , error ) { c . log ( " " , org , user ) if org = = user { } code , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , org , user ) , exit Codes : [ ] int { 2 0 4 , 4 0 4 , 3 0 2 } , } , nil ) if err ! = nil { return false , err } if code = = 2 0 4 { return true , nil } else if code = = 4 0 4 { return false , nil } else if code = = 3 0 2 { return false , fmt . Errorf ( " " , org ) } } 
func ( c * Client ) List Org Hooks ( org string ) ( [ ] Hook , error ) { c . log ( " " , org ) return c . list Hooks ( org , nil ) } 
func ( c * Client ) List Repo Hooks ( org , repo string ) ( [ ] Hook , error ) { c . log ( " " , org , repo ) return c . list Hooks ( org , & repo ) } 
func ( c * Client ) Edit Repo Hook ( org , repo string , id int , req Hook Request ) error { c . log ( " " , org , repo , id ) return c . edit Hook ( org , & repo , id , req ) } 
func ( c * Client ) Edit Org Hook ( org string , id int , req Hook Request ) error { c . log ( " " , org , id ) return c . edit Hook ( org , nil , id , req ) } 
func ( c * Client ) Create Org Hook ( org string , req Hook Request ) ( int , error ) { c . log ( " " , org ) return c . create Hook ( org , nil , req ) } 
func ( c * Client ) Create Repo Hook ( org , repo string , req Hook Request ) ( int , error ) { c . log ( " " , org , repo ) return c . create Hook ( org , & repo , req ) } 
func ( c * Client ) Get Org ( name string ) ( * Organization , error ) { c . log ( " " , name ) var ret Org Organization _ , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , name ) , exit Codes : [ ] int { 2 0 0 } , } , & ret Org ) if err ! = nil { return nil , err } return & ret Org , nil } 
func ( c * Client ) Edit Org ( name string , config Organization ) ( * Organization , error ) { c . log ( " " , name , config ) if c . dry { return & config , nil } var ret Org Organization _ , err : = c . request ( & request { method : http . Method Patch , path : fmt . Sprintf ( " " , name ) , exit Codes : [ ] int { 2 0 0 } , request Body : & config , } , & ret Org ) if err ! = nil { return nil , err } return & ret Org , nil } 
func ( c * Client ) List Org Invitations ( org string ) ( [ ] Org Invitation , error ) { c . log ( " " , org ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org ) var ret [ ] Org Invitation err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Org Invitation { } } , func ( obj interface { } ) { ret = append ( ret , * ( obj . ( * [ ] Org Invitation ) ) . . . ) } , ) if err ! = nil { return nil , err } return ret , nil } 
func ( c * Client ) List Org Members ( org , role string ) ( [ ] Team Member , error ) { c . log ( " " , org , role ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org ) var team Members [ ] Team Member err : = c . read Paginated Results With Values ( path , url . Values { " " : [ ] string { " " } , " " : [ ] string { role } , } , accept None , func ( ) interface { } { return & [ ] Team Member { } } , func ( obj interface { } ) { team Members = append ( team Members , * ( obj . ( * [ ] Team Member ) ) . . . ) } , ) if err ! = nil { return nil , err } return team Members , nil } 
func ( c * Client ) Has Permission ( org , repo , user string , roles . . . string ) ( bool , error ) { perm , err : = c . Get User Permission ( org , repo , user ) if err ! = nil { return false , err } for _ , r : = range roles { if r = = perm { return true , nil } } return false , nil } 
func ( c * Client ) Get User Permission ( org , repo , user string ) ( string , error ) { c . log ( " " , org , repo , user ) var perm struct { Perm string `json : "permission " ` } _ , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , org , repo , user ) , exit Codes : [ ] int { 2 0 0 } , } , & perm ) if err ! = nil { return " " , err } return perm . Perm , nil } 
func ( c * Client ) Update Org Membership ( org , user string , admin bool ) ( * Org Membership , error ) { c . log ( " " , org , user , admin ) om : = Org Membership { } if admin { om . Role = Role Admin } else { om . Role = Role Member } if c . dry { return & om , nil } _ , err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , org , user ) , request Body : & om , exit Codes : [ ] int { 2 0 0 } , } , & om ) return & om , err } 
func ( c * Client ) Remove Org Membership ( org , user string ) error { c . log ( " " , org , user ) _ , err : = c . request ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , org , user ) , exit Codes : [ ] int { 2 0 4 } , } , nil ) return err } 
func ( c * Client ) Create Comment ( org , repo string , number int , comment string ) error { c . log ( " " , org , repo , number , comment ) ic : = Issue Comment { Body : comment , } _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , org , repo , number ) , request Body : & ic , exit Codes : [ ] int { 2 0 1 } , } , nil ) return err } 
func ( c * Client ) Edit Comment ( org , repo string , id int , comment string ) error { c . log ( " " , org , repo , id , comment ) ic : = Issue Comment { Body : comment , } _ , err : = c . request ( & request { method : http . Method Patch , path : fmt . Sprintf ( " " , org , repo , id ) , request Body : & ic , exit Codes : [ ] int { 2 0 0 } , } , nil ) return err } 
func ( c * Client ) Create Comment Reaction ( org , repo string , id int , reaction string ) error { c . log ( " " , org , repo , id , reaction ) r : = Reaction { Content : reaction } _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , org , repo , id ) , accept : " " , exit Codes : [ ] int { 2 0 1 } , request Body : & r , } , nil ) return err } 
func ( c * Client ) Delete Stale Comments ( org , repo string , number int , comments [ ] Issue Comment , is Stale func ( Issue Comment ) bool ) error { var err error if comments = = nil { comments , err = c . List Issue Comments ( org , repo , number ) if err ! = nil { return fmt . Errorf ( " " , err ) } } for _ , comment : = range comments { if is Stale ( comment ) { if err : = c . Delete Comment ( org , repo , comment . ID ) ; err ! = nil { return fmt . Errorf ( " " , comment . ID ) } } } return nil } 
func ( c * Client ) read Paginated Results ( path , accept string , new Obj func ( ) interface { } , accumulate func ( interface { } ) ) error { values : = url . Values { " " : [ ] string { " " } , } return c . read Paginated Results With Values ( path , values , accept , new Obj , accumulate ) } 
func ( c * Client ) read Paginated Results With Values ( path string , values url . Values , accept string , new Obj func ( ) interface { } , accumulate func ( interface { } ) ) error { paged Path : = path if len ( values ) > 0 { paged Path + = " " + values . Encode ( ) } for { resp , err : = c . request Retry ( http . Method Get , paged Path , accept , nil ) if err ! = nil { return err } defer resp . Body . Close ( ) if resp . Status Code < 2 0 0 | | resp . Status Code > 2 9 9 { return fmt . Errorf ( " " , resp . Status ) } b , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return err } obj : = new Obj ( ) if err : = json . Unmarshal ( b , obj ) ; err ! = nil { return err } accumulate ( obj ) link : = parse Links ( resp . Header . Get ( " " ) ) [ " " ] if link = = " " { break } u , err : = url . Parse ( link ) if err ! = nil { return fmt . Errorf ( " " , err ) } paged Path = u . Request URI ( ) } return nil } 
func ( c * Client ) Get Pull Requests ( org , repo string ) ( [ ] Pull Request , error ) { c . log ( " " , org , repo ) var prs [ ] Pull Request if c . fake { return prs , nil } path : = fmt . Sprintf ( " " , org , repo ) err : = c . read Paginated Results ( path , } , func ( obj interface { } ) { prs = append ( prs , * ( obj . ( * [ ] Pull Request ) ) . . . ) } , ) if err ! = nil { return nil , err } return prs , err } 
func ( c * Client ) Get Pull Request ( org , repo string , number int ) ( * Pull Request , error ) { c . log ( " " , org , repo , number ) var pr Pull Request _ , err : = c . request ( & request { return & pr , err } 
func ( c * Client ) Get Pull Request Patch ( org , repo string , number int ) ( [ ] byte , error ) { c . log ( " " , org , repo , number ) _ , patch , err : = c . request Raw ( & request { accept : " " , method : http . Method Get , path : fmt . Sprintf ( " " , org , repo , number ) , exit Codes : [ ] int { 2 0 0 } , } ) return patch , err } 
func ( c * Client ) Create Pull Request ( org , repo , title , body , head , base string , can Modify bool ) ( int , error ) { c . log ( " " , org , repo , title ) data : = struct { Title string `json : "title " ` Body string `json : "body " ` Head string `json : "head " ` Base string `json : "base " ` } { Title : title , Body : body , Head : head , Base : base , Maintainer Can Modify : can Modify , } var resp struct { Num int `json : "number " ` } _ , err : = c . request ( & request { if err ! = nil { return 0 , err } return resp . Num , nil } 
func ( c * Client ) Update Pull Request ( org , repo string , number int , title , body * string , open * bool , branch * string , can Modify * bool ) error { c . log ( " " , org , repo , title ) data : = struct { State * string `json : "state ,omitempty " ` Title * string `json : "title ,omitempty " ` Body * string `json : "body ,omitempty " ` Base * string `json : "base ,omitempty " ` } { Title : title , Body : body , Base : branch , Maintainer Can Modify : can Modify , } if open ! = nil & & * open { op : = " " data . State = & op } else if open ! = nil { cl : = " " data . State = & cl } _ , err : = c . request ( & request { return err } 
func ( c * Client ) Get Pull Request Changes ( org , repo string , number int ) ( [ ] Pull Request Change , error ) { c . log ( " " , org , repo , number ) if c . fake { return [ ] Pull Request Change { } , nil } path : = fmt . Sprintf ( " " , org , repo , number ) var changes [ ] Pull Request Change err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Pull Request Change { } } , func ( obj interface { } ) { changes = append ( changes , * ( obj . ( * [ ] Pull Request Change ) ) . . . ) } , ) if err ! = nil { return nil , err } return changes , nil } 
func ( c * Client ) List Pull Request Comments ( org , repo string , number int ) ( [ ] Review Comment , error ) { c . log ( " " , org , repo , number ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org , repo , number ) var comments [ ] Review Comment err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Review Comment { } } , func ( obj interface { } ) { comments = append ( comments , * ( obj . ( * [ ] Review Comment ) ) . . . ) } , ) if err ! = nil { return nil , err } return comments , nil } 
func ( c * Client ) List Reviews ( org , repo string , number int ) ( [ ] Review , error ) { c . log ( " " , org , repo , number ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org , repo , number ) var reviews [ ] Review err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Review { } } , func ( obj interface { } ) { reviews = append ( reviews , * ( obj . ( * [ ] Review ) ) . . . ) } , ) if err ! = nil { return nil , err } return reviews , nil } 
func ( c * Client ) Create Status ( org , repo , SHA string , s Status ) error { c . log ( " " , org , repo , SHA , s ) _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , org , repo , SHA ) , request Body : & s , exit Codes : [ ] int { 2 0 1 } , } , nil ) return err } 
func ( c * Client ) List Statuses ( org , repo , ref string ) ( [ ] Status , error ) { c . log ( " " , org , repo , ref ) path : = fmt . Sprintf ( " " , org , repo , ref ) var statuses [ ] Status err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Status { } } , func ( obj interface { } ) { statuses = append ( statuses , * ( obj . ( * [ ] Status ) ) . . . ) } , ) return statuses , err } 
func ( c * Client ) Get Repo ( owner , name string ) ( Repo , error ) { c . log ( " " , owner , name ) var repo Repo _ , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , owner , name ) , exit Codes : [ ] int { 2 0 0 } , } , & repo ) return repo , err } 
func ( c * Client ) Get Repos ( org string , is User bool ) ( [ ] Repo , error ) { c . log ( " " , org , is User ) var ( repos [ ] Repo next URL string ) if c . fake { return repos , nil } if is User { next URL = fmt . Sprintf ( " " , org ) } else { next URL = fmt . Sprintf ( " " , org ) } err : = c . read Paginated Results ( next URL , } , func ( obj interface { } ) { } , ) if err ! = nil { return nil , err } return repos , nil } 
func ( c * Client ) Get Single Commit ( org , repo , SHA string ) ( Single Commit , error ) { c . log ( " " , org , repo , SHA ) var commit Single Commit _ , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , org , repo , SHA ) , exit Codes : [ ] int { 2 0 0 } , } , & commit ) return commit , err } 
func ( c * Client ) Get Branches ( org , repo string , only Protected bool ) ( [ ] Branch , error ) { c . log ( " " , org , repo ) var branches [ ] Branch err : = c . read Paginated Results With Values ( fmt . Sprintf ( " " , org , repo ) , url . Values { " " : [ ] string { strconv . Format Bool ( only Protected ) } , " " : [ ] string { " " } , } , accept None , func ( ) interface { } { } , func ( obj interface { } ) { branches = append ( branches , * ( obj . ( * [ ] Branch ) ) . . . ) } , ) if err ! = nil { return nil , err } return branches , nil } 
func ( c * Client ) Update Branch Protection ( org , repo , branch string , config Branch Protection Request ) error { c . log ( " " , org , repo , branch , config ) _ , err : = c . request ( & request { accept : " " , return err } 
func ( c * Client ) Update Repo Label ( org , repo , label , new Name , description , color string ) error { c . log ( " " , org , repo , label , new Name , color ) _ , err : = c . request ( & request { method : http . Method Patch , path : fmt . Sprintf ( " " , org , repo , label ) , accept : " " , return err } 
func ( c * Client ) Delete Repo Label ( org , repo , label string ) error { c . log ( " " , org , repo , label ) _ , err : = c . request ( & request { method : http . Method Delete , accept : " " , return err } 
func ( c * Client ) Get Combined Status ( org , repo , ref string ) ( * Combined Status , error ) { c . log ( " " , org , repo , ref ) var combined Status Combined Status err : = c . read Paginated Results ( fmt . Sprintf ( " " , org , repo , ref ) , " " , func ( ) interface { } { return & Combined Status { } } , func ( obj interface { } ) { cs : = * ( obj . ( * Combined Status ) ) cs . Statuses = append ( combined Status . Statuses , cs . Statuses . . . ) combined Status = cs } , ) return & combined Status , err } 
func ( c * Client ) get Labels ( path string ) ( [ ] Label , error ) { var labels [ ] Label if c . fake { return labels , nil } err : = c . read Paginated Results ( path , " " , } , func ( obj interface { } ) { labels = append ( labels , * ( obj . ( * [ ] Label ) ) . . . ) } , ) if err ! = nil { return nil , err } return labels , nil } 
func ( c * Client ) Get Repo Labels ( org , repo string ) ( [ ] Label , error ) { c . log ( " " , org , repo ) return c . get Labels ( fmt . Sprintf ( " " , org , repo ) ) } 
func ( c * Client ) Get Issue Labels ( org , repo string , number int ) ( [ ] Label , error ) { c . log ( " " , org , repo , number ) return c . get Labels ( fmt . Sprintf ( " " , org , repo , number ) ) } 
func ( c * Client ) Remove Label ( org , repo string , number int , label string ) error { c . log ( " " , org , repo , number , label ) code , body , err : = c . request Raw ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , org , repo , number , label ) , switch { case code = = 2 0 0 | | code = = 2 0 4 : case code = = 4 0 4 : default : return fmt . Errorf ( " " , code ) } ge : = & github Error { } if err : = json . Unmarshal ( body , ge ) ; err ! = nil { return err } } } 
func ( c * Client ) Assign Issue ( org , repo string , number int , logins [ ] string ) error { c . log ( " " , org , repo , number , logins ) assigned : = make ( map [ string ] bool ) var i Issue _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , org , repo , number ) , request Body : map [ string ] [ ] string { " " : logins } , exit Codes : [ ] int { 2 0 1 } , } , & i ) if err ! = nil { return err } for _ , assignee : = range i . Assignees { assigned [ Norm Login ( assignee . Login ) ] = true } missing : = Missing Users { action : " " } for _ , login : = range logins { if ! assigned [ Norm Login ( login ) ] { missing . Users = append ( missing . Users , login ) } } if len ( missing . Users ) > 0 { return missing } return nil } 
func ( c * Client ) Create Review ( org , repo string , number int , r Draft Review ) error { c . log ( " " , org , repo , number , r ) _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , org , repo , number ) , accept : " " , request Body : r , exit Codes : [ ] int { 2 0 0 } , } , nil ) return err } 
func prepare Reviewers Body ( logins [ ] string , org string ) ( map [ string ] [ ] string , error ) { body : = map [ string ] [ ] string { } var errors [ ] error for _ , login : = range logins { mat : = team Re . Find String Submatch ( login ) if mat = = nil { if _ , exists : = body [ " " ] ; ! exists { body [ " " ] = [ ] string { } } body [ " " ] = append ( body [ " " ] , login ) } else if mat [ 1 ] = = org { if _ , exists : = body [ " " ] ; ! exists { body [ " " ] = [ ] string { } } body [ " " ] = append ( body [ " " ] , mat [ 2 ] ) } else { errors = append ( errors , fmt . Errorf ( " " , login , org ) ) } } return body , errorutil . New Aggregate ( errors . . . ) } 
func ( c * Client ) Request Review ( org , repo string , number int , logins [ ] string ) error { status Code , err : = c . try Request Review ( org , repo , number , logins ) if err ! = nil & & status Code = = http . Status Unprocessable Entity { for _ , user : = range logins { status Code , err = c . try Request Review ( org , repo , number , [ ] string { user } ) if err ! = nil & & status Code = = http . Status Unprocessable Entity { } else if err ! = nil { return fmt . Errorf ( " " , status Code , err ) } } if len ( missing . Users ) > 0 { return missing } return nil } return err } 
func ( c * Client ) Unrequest Review ( org , repo string , number int , logins [ ] string ) error { c . log ( " " , org , repo , number , logins ) var pr Pull Request body , err : = prepare Reviewers Body ( logins , org ) if len ( body ) = = 0 { } _ , err = c . request ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , org , repo , number ) , accept : " " , request Body : body , exit Codes : [ ] int { http . Status OK } , } , & pr ) if err ! = nil { return err } extras : = Extra Users { action : " " } for _ , user : = range pr . Requested Reviewers { found : = false for _ , to Delete : = range logins { if Norm Login ( user . Login ) = = Norm Login ( to Delete ) { found = true break } } if found { extras . Users = append ( extras . Users , user . Login ) } } if len ( extras . Users ) > 0 { return extras } return nil } 
func ( c * Client ) Close Issue ( org , repo string , number int ) error { c . log ( " " , org , repo , number ) _ , err : = c . request ( & request { method : http . Method Patch , path : fmt . Sprintf ( " " , org , repo , number ) , request Body : map [ string ] string { " " : " " } , exit Codes : [ ] int { 2 0 0 } , } , nil ) return err } 
func state Cannot Be Changed Or Original Error ( err error ) error { request Err , ok : = err . ( request Error ) if ok { for _ , error Msg : = range request Err . Error Messages ( ) { if strings . Contains ( error Msg , state Cannot Be Changed Message Prefix ) { return State Cannot Be Changed { Message : error Msg , } } } } return err } 
func ( c * Client ) Get Ref ( org , repo , ref string ) ( string , error ) { c . log ( " " , org , repo , ref ) var res struct { Object map [ string ] string `json : "object " ` } _ , err : = c . request ( & request { method : http . Method Get , path : fmt . Sprintf ( " " , org , repo , ref ) , exit Codes : [ ] int { 2 0 0 } , } , & res ) return res . Object [ " " ] , err } 
func ( c * Client ) Delete Ref ( org , repo , ref string ) error { c . log ( " " , org , repo , ref ) _ , err : = c . request ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , org , repo , ref ) , exit Codes : [ ] int { 2 0 4 } , } , nil ) return err } 
func ( c * Client ) Find Issues ( query , sort string , asc bool ) ( [ ] Issue , error ) { c . log ( " " , query ) path : = fmt . Sprintf ( " " , url . Query Escape ( query ) ) if sort ! = " " { path + = " " + url . Query Escape ( sort ) if asc { path + = " " } } var iss Search Result Issues Search Result _ , err : = c . request ( & request { method : http . Method Get , path : path , exit Codes : [ ] int { 2 0 0 } , } , & iss Search Result ) return iss Search Result . Issues , err } 
func ( c * Client ) Get File ( org , repo , filepath , commit string ) ( [ ] byte , error ) { c . log ( " " , org , repo , filepath , commit ) url : = fmt . Sprintf ( " " , org , repo , filepath ) if commit ! = " " { url = fmt . Sprintf ( " " , url , commit ) } var res Content code , err : = c . request ( & request { method : http . Method Get , path : url , exit Codes : [ ] int { 2 0 0 , 4 0 4 } , } , & res ) if err ! = nil { return nil , err } if code = = 4 0 4 { return nil , & File Not Found { org : org , repo : repo , path : filepath , commit : commit , } } decoded , err : = base 6 4 . Std Encoding . Decode String ( res . Content ) if err ! = nil { return nil , fmt . Errorf ( " " , res . Content , err ) } return decoded , nil } 
func ( c * Client ) Query ( ctx context . Context , q interface { } , vars map [ string ] interface { } ) error { } 
func ( c * Client ) Create Team ( org string , team Team ) ( * Team , error ) { c . log ( " " , org , team ) if team . Name = = " " { return nil , errors . New ( " " ) } if c . fake { return nil , nil } else if c . dry { return & team , nil } path : = fmt . Sprintf ( " " , org ) var ret Team Team _ , err : = c . request ( & request { method : http . Method Post , path : path , return & ret Team , err } 
func ( c * Client ) Edit Team ( t Team ) ( * Team , error ) { c . log ( " " , t ) if t . ID = = 0 { return nil , errors . New ( " " ) } if c . dry { return & t , nil } id : = t . ID t . ID = 0 Parent Team ID * int `json : "parent _team _id " ` } { Team : t , Parent Team ID : t . Parent Team ID , } var ret Team Team path : = fmt . Sprintf ( " " , id ) _ , err : = c . request ( & request { method : http . Method Patch , path : path , return & ret Team , err } 
func ( c * Client ) Delete Team ( id int ) error { c . log ( " " , id ) path : = fmt . Sprintf ( " " , id ) _ , err : = c . request ( & request { method : http . Method Delete , path : path , exit Codes : [ ] int { 2 0 4 } , } , nil ) return err } 
func ( c * Client ) List Teams ( org string ) ( [ ] Team , error ) { c . log ( " " , org ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org ) var teams [ ] Team err : = c . read Paginated Results ( path , } , func ( obj interface { } ) { teams = append ( teams , * ( obj . ( * [ ] Team ) ) . . . ) } , ) if err ! = nil { return nil , err } return teams , nil } 
func ( c * Client ) Update Team Membership ( id int , user string , maintainer bool ) ( * Team Membership , error ) { c . log ( " " , id , user , maintainer ) if c . fake { return nil , nil } tm : = Team Membership { } if maintainer { tm . Role = Role Maintainer } else { tm . Role = Role Member } if c . dry { return & tm , nil } _ , err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , id , user ) , request Body : & tm , exit Codes : [ ] int { 2 0 0 } , } , & tm ) return & tm , err } 
func ( c * Client ) Remove Team Membership ( id int , user string ) error { c . log ( " " , id , user ) if c . fake { return nil } _ , err : = c . request ( & request { method : http . Method Delete , path : fmt . Sprintf ( " " , id , user ) , exit Codes : [ ] int { 2 0 4 } , } , nil ) return err } 
func ( c * Client ) List Team Members ( id int , role string ) ( [ ] Team Member , error ) { c . log ( " " , id , role ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , id ) var team Members [ ] Team Member err : = c . read Paginated Results With Values ( path , url . Values { " " : [ ] string { " " } , " " : [ ] string { role } , } , } , func ( obj interface { } ) { team Members = append ( team Members , * ( obj . ( * [ ] Team Member ) ) . . . ) } , ) if err ! = nil { return nil , err } return team Members , nil } 
func ( c * Client ) List Team Repos ( id int ) ( [ ] Repo , error ) { c . log ( " " , id ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , id ) var repos [ ] Repo err : = c . read Paginated Results With Values ( path , url . Values { " " : [ ] string { " " } , } , } , func ( obj interface { } ) { repos = append ( repos , * ( obj . ( * [ ] Repo ) ) . . . ) } , ) if err ! = nil { return nil , err } return repos , nil } 
func ( c * Client ) Update Team Repo ( id int , org , repo string , permission Repo Permission Level ) error { c . log ( " " , id , org , repo , permission ) if c . fake | | c . dry { return nil } data : = struct { Permission string `json : "permission " ` } { Permission : string ( permission ) , } _ , err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , id , org , repo ) , request Body : & data , exit Codes : [ ] int { 2 0 4 } , } , nil ) return err } 
func ( c * Client ) List Team Invitations ( id int ) ( [ ] Org Invitation , error ) { c . log ( " " , id ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , id ) var ret [ ] Org Invitation err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Org Invitation { } } , func ( obj interface { } ) { ret = append ( ret , * ( obj . ( * [ ] Org Invitation ) ) . . . ) } , ) if err ! = nil { return nil , err } return ret , nil } 
func ( c * Client ) Merge ( org , repo string , pr int , details Merge Details ) error { c . log ( " " , org , repo , pr , details ) ge : = github Error { } ec , err : = c . request ( & request { method : http . Method Put , path : fmt . Sprintf ( " " , org , repo , pr ) , request Body : & details , exit Codes : [ ] int { 2 0 0 , 4 0 5 , 4 0 9 } , } , & ge ) if err ! = nil { return err } if ec = = 4 0 5 { if strings . Contains ( ge . Message , " " ) { return Unmergable PRBase Changed Error ( ge . Message ) } if strings . Contains ( ge . Message , " " ) { return Unauthorized To Push Error ( ge . Message ) } if strings . Contains ( ge . Message , " " ) { return Merge Commits Forbidden Error ( ge . Message ) } return Unmergable PRError ( ge . Message ) } else if ec = = 4 0 9 { return Modified Head Error ( ge . Message ) } return nil } 
func ( c * Client ) List Collaborators ( org , repo string ) ( [ ] User , error ) { c . log ( " " , org , repo ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org , repo ) var users [ ] User err : = c . read Paginated Results ( path , } , func ( obj interface { } ) { users = append ( users , * ( obj . ( * [ ] User ) ) . . . ) } , ) if err ! = nil { return nil , err } return users , nil } 
func ( c * Client ) Create Fork ( owner , repo string ) error { c . log ( " " , owner , repo ) _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , owner , repo ) , exit Codes : [ ] int { 2 0 2 } , } , nil ) return err } 
func ( c * Client ) List Issue Events ( org , repo string , num int ) ( [ ] Listed Issue Event , error ) { c . log ( " " , org , repo , num ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org , repo , num ) var events [ ] Listed Issue Event err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Listed Issue Event { } } , func ( obj interface { } ) { events = append ( events , * ( obj . ( * [ ] Listed Issue Event ) ) . . . ) } , ) if err ! = nil { return nil , err } return events , nil } 
func ( c * Client ) Is Mergeable ( org , repo string , number int , SHA string ) ( bool , error ) { backoff : = time . Second * 3 max Tries : = 3 for try : = 0 ; try < max Tries ; try + + { pr , err : = c . Get Pull Request ( org , repo , number ) if err ! = nil { return false , err } if pr . Head . SHA ! = SHA { return false , fmt . Errorf ( " " , SHA , pr . Head . SHA ) } if pr . Merged { return false , errors . New ( " " ) } if pr . Mergable ! = nil { return * pr . Mergable , nil } if try + 1 < max Tries { c . time . Sleep ( backoff ) backoff * = 2 } } return false , fmt . Errorf ( " " , max Tries ) } 
func ( c * Client ) Clear Milestone ( org , repo string , num int ) error { c . log ( " " , org , repo , num ) issue : = & struct { } { } _ , err : = c . request ( & request { method : http . Method Patch , path : fmt . Sprintf ( " " , org , repo , num ) , request Body : & issue , exit Codes : [ ] int { 2 0 0 } , } , nil ) return err } 
func ( c * Client ) List Milestones ( org , repo string ) ( [ ] Milestone , error ) { c . log ( " " , org ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , org , repo ) var milestones [ ] Milestone err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Milestone { } } , func ( obj interface { } ) { milestones = append ( milestones , * ( obj . ( * [ ] Milestone ) ) . . . ) } , ) if err ! = nil { return nil , err } return milestones , nil } 
func ( c * Client ) List PRCommits ( org , repo string , number int ) ( [ ] Repository Commit , error ) { c . log ( " " , org , repo , number ) if c . fake { return nil , nil } var commits [ ] Repository Commit err : = c . read Paginated Results ( fmt . Sprintf ( " " , org , repo , number ) , accept None , func ( ) interface { } { } , func ( obj interface { } ) { } , ) if err ! = nil { return nil , err } return commits , nil } 
func ( s * reloading Token Source ) Token ( ) ( * oauth 2 . Token , error ) { return & oauth 2 . Token { Access Token : string ( s . get Token ( ) ) , } , nil } 
func ( c * Client ) Get Repo Projects ( owner , repo string ) ( [ ] Project , error ) { c . log ( " " , owner , repo ) path : = ( fmt . Sprintf ( " " , owner , repo ) ) var projects [ ] Project err : = c . read Paginated Results ( path , " " , func ( ) interface { } { return & [ ] Project { } } , func ( obj interface { } ) { projects = append ( projects , * ( obj . ( * [ ] Project ) ) . . . ) } , ) if err ! = nil { return nil , err } return projects , nil } 
func ( c * Client ) Get Org Projects ( org string ) ( [ ] Project , error ) { c . log ( " " , org ) path : = ( fmt . Sprintf ( " " , org ) ) var projects [ ] Project err : = c . read Paginated Results ( path , " " , func ( ) interface { } { return & [ ] Project { } } , func ( obj interface { } ) { projects = append ( projects , * ( obj . ( * [ ] Project ) ) . . . ) } , ) if err ! = nil { return nil , err } return projects , nil } 
func ( c * Client ) Get Project Columns ( project ID int ) ( [ ] Project Column , error ) { c . log ( " " , project ID ) path : = ( fmt . Sprintf ( " " , project ID ) ) var project Columns [ ] Project Column err : = c . read Paginated Results ( path , " " , func ( ) interface { } { return & [ ] Project Column { } } , func ( obj interface { } ) { project Columns = append ( project Columns , * ( obj . ( * [ ] Project Column ) ) . . . ) } , ) if err ! = nil { return nil , err } return project Columns , nil } 
func ( c * Client ) Create Project Card ( column ID int , project Card Project Card ) ( * Project Card , error ) { c . log ( " " , column ID , project Card ) if ( project Card . Content Type ! = " " ) & & ( project Card . Content Type ! = " " ) { return nil , errors . New ( " " ) } if c . dry { return & project Card , nil } path : = fmt . Sprintf ( " " , column ID ) var ret Project Card Project Card _ , err : = c . request ( & request { method : http . Method Post , path : path , accept : " " , request Body : & project Card , exit Codes : [ ] int { 2 0 0 } , } , & ret Project Card ) return & ret Project Card , err } 
func ( c * Client ) Get Column Project Card ( column ID int , card Number int ) ( * Project Card , error ) { c . log ( " " , column ID , card Number ) if c . fake { return nil , nil } path : = fmt . Sprintf ( " " , column ID ) var cards [ ] Project Card err : = c . read Paginated Results ( path , accept None , func ( ) interface { } { return & [ ] Project Card { } } , func ( obj interface { } ) { cards = append ( cards , * ( obj . ( * [ ] Project Card ) ) . . . ) } , ) if err ! = nil { return nil , err } for _ , card : = range cards { if card . Content ID = = card Number { return & card , nil } } return nil , nil } 
func ( c * Client ) Move Project Card ( project Card ID int , new Column ID int ) error { c . log ( " " , project Card ID , new Column ID ) _ , err : = c . request ( & request { method : http . Method Post , path : fmt . Sprintf ( " " , project Card ID ) , accept : " " , return err } 
func ( c * Client ) Delete Project Card ( project Card ID int ) error { c . log ( " " , project Card ID ) _ , err : = c . request ( & request { method : http . Method Delete , accept : " " , return err } 
func ( c * Client ) Team Has Member ( team ID int , member Login string ) ( bool , error ) { c . log ( " " , team ID , member Login ) project Maintainers , err : = c . List Team Members ( team ID , Role All ) if err ! = nil { return false , err } for _ , person : = range project Maintainers { if Norm Login ( person . Login ) = = Norm Login ( member Login ) { return true , nil } } return false , nil } 
func ( s * Spyglass ) List Artifacts ( src string ) ( [ ] string , error ) { key Type , key , err : = split Src ( src ) if err ! = nil { return [ ] string { } , fmt . Errorf ( " " , err ) } gcs Key : = " " switch key Type { case gcs Key Type : gcs Key = key case prow Key Type : if gcs Key , err = s . prow To GCS ( key ) ; err ! = nil { logrus . Warningf ( " " , err ) } default : return nil , fmt . Errorf ( " " , src ) } artifact Names , err : = s . GCSArtifact Fetcher . artifacts ( gcs Key ) log Found : = false for _ , name : = range artifact Names { if name = = " " { log Found = true break } } if err ! = nil | | ! log Found { artifact Names = append ( artifact Names , " " ) } return artifact Names , nil } 
func ( * Spyglass ) Key To Job ( src string ) ( job Name string , build ID string , err error ) { src = strings . Trim ( src , " " ) parsed : = strings . Split ( src , " " ) if len ( parsed ) < 2 { return " " , " " , fmt . Errorf ( " " , src ) } job Name = parsed [ len ( parsed ) - 2 ] build ID = parsed [ len ( parsed ) - 1 ] return job Name , build ID , nil } 
func ( s * Spyglass ) prow To GCS ( prow Key string ) ( string , error ) { job Name , build ID , err : = s . Key To Job ( prow Key ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } job , err : = s . job Agent . Get Prow Job ( job Name , build ID ) if err ! = nil { return " " , fmt . Errorf ( " " , prow Key , err ) } url : = job . Status . URL prefix : = s . config ( ) . Plank . Get Job URLPrefix ( job . Spec . Refs ) if ! strings . Has Prefix ( url , prefix ) { return " " , fmt . Errorf ( " " , url , prefix ) } return url [ len ( prefix ) : ] , nil } 
func ( s * Spyglass ) Fetch Artifacts ( src string , pod Name string , size Limit int 6 4 , artifact Names [ ] string ) ( [ ] lenses . Artifact , error ) { art Start : = time . Now ( ) arts : = [ ] lenses . Artifact { } key Type , key , err : = split Src ( src ) if err ! = nil { return arts , fmt . Errorf ( " " , err ) } job Name , build ID , err : = s . Key To Job ( src ) if err ! = nil { return arts , fmt . Errorf ( " " , err ) } gcs Key : = " " switch key Type { case gcs Key Type : gcs Key = strings . Trim Suffix ( key , " " ) case prow Key Type : if gcs Key , err = s . prow To GCS ( key ) ; err ! = nil { logrus . Warningln ( err ) } default : return nil , fmt . Errorf ( " " , src ) } pod Log Needed : = false for _ , name : = range artifact Names { art , err : = s . GCSArtifact Fetcher . artifact ( gcs Key , name , size Limit ) if err = = nil { } if err ! = nil { if name = = " " { pod Log Needed = true } continue } arts = append ( arts , art ) } if pod Log Needed { art , err : = s . Pod Log Artifact Fetcher . artifact ( job Name , build ID , size Limit ) if err ! = nil { logrus . Errorf ( " " , err ) } else { arts = append ( arts , art ) } } logrus . With Field ( " " , time . Since ( art Start ) ) . Infof ( " " , src ) return arts , nil } 
func ( in * Decoration Config ) Deep Copy Into ( out * Decoration Config ) { * out = * in out . Timeout = in . Timeout out . Grace Period = in . Grace Period if in . Utility Images ! = nil { in , out : = & in . Utility Images , & out . Utility Images * out = new ( Utility Images ) * * out = * * in } if in . GCSConfiguration ! = nil { in , out : = & in . GCSConfiguration , & out . GCSConfiguration * out = new ( GCSConfiguration ) * * out = * * in } if in . SSHKey Secrets ! = nil { in , out : = & in . SSHKey Secrets , & out . SSHKey Secrets * out = make ( [ ] string , len ( * in ) ) copy ( * out , * in ) } if in . SSHHost Fingerprints ! = nil { in , out : = & in . SSHHost Fingerprints , & out . SSHHost Fingerprints * out = make ( [ ] string , len ( * in ) ) copy ( * out , * in ) } if in . Skip Cloning ! = nil { in , out : = & in . Skip Cloning , & out . Skip Cloning * out = new ( bool ) * * out = * * in } return } 
func ( in * Decoration Config ) Deep Copy ( ) * Decoration Config { if in = = nil { return nil } out : = new ( Decoration Config ) in . Deep Copy Into ( out ) return out } 
func ( in * GCSConfiguration ) Deep Copy ( ) * GCSConfiguration { if in = = nil { return nil } out : = new ( GCSConfiguration ) in . Deep Copy Into ( out ) return out } 
func ( in * Jenkins Spec ) Deep Copy ( ) * Jenkins Spec { if in = = nil { return nil } out : = new ( Jenkins Spec ) in . Deep Copy Into ( out ) return out } 
func ( in * Prow Job ) Deep Copy Into ( out * Prow Job ) { * out = * in out . Type Meta = in . Type Meta in . Object Meta . Deep Copy Into ( & out . Object Meta ) in . Spec . Deep Copy Into ( & out . Spec ) in . Status . Deep Copy Into ( & out . Status ) return } 
func ( in * Prow Job ) Deep Copy ( ) * Prow Job { if in = = nil { return nil } out : = new ( Prow Job ) in . Deep Copy Into ( out ) return out } 
func ( in * Prow Job ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * Prow Job List ) Deep Copy Into ( out * Prow Job List ) { * out = * in out . Type Meta = in . Type Meta out . List Meta = in . List Meta if in . Items ! = nil { in , out : = & in . Items , & out . Items * out = make ( [ ] Prow Job , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . Deep Copy Into ( & ( * out ) [ i ] ) } } return } 
func ( in * Prow Job List ) Deep Copy ( ) * Prow Job List { if in = = nil { return nil } out : = new ( Prow Job List ) in . Deep Copy Into ( out ) return out } 
func ( in * Prow Job List ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * Prow Job Spec ) Deep Copy Into ( out * Prow Job Spec ) { * out = * in if in . Refs ! = nil { in , out : = & in . Refs , & out . Refs * out = new ( Refs ) ( * in ) . Deep Copy Into ( * out ) } if in . Extra Refs ! = nil { in , out : = & in . Extra Refs , & out . Extra Refs * out = make ( [ ] Refs , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . Deep Copy Into ( & ( * out ) [ i ] ) } } if in . Pod Spec ! = nil { in , out : = & in . Pod Spec , & out . Pod Spec * out = new ( corev 1 . Pod Spec ) ( * in ) . Deep Copy Into ( * out ) } if in . Build Spec ! = nil { in , out : = & in . Build Spec , & out . Build Spec * out = new ( v 1alpha 1 . Build Spec ) ( * in ) . Deep Copy Into ( * out ) } if in . Jenkins Spec ! = nil { in , out : = & in . Jenkins Spec , & out . Jenkins Spec * out = new ( Jenkins Spec ) * * out = * * in } if in . Pipeline Run Spec ! = nil { in , out : = & in . Pipeline Run Spec , & out . Pipeline Run Spec * out = new ( pipelinev 1alpha 1 . Pipeline Run Spec ) ( * in ) . Deep Copy Into ( * out ) } if in . Decoration Config ! = nil { in , out : = & in . Decoration Config , & out . Decoration Config * out = new ( Decoration Config ) ( * in ) . Deep Copy Into ( * out ) } return } 
func ( in * Prow Job Spec ) Deep Copy ( ) * Prow Job Spec { if in = = nil { return nil } out : = new ( Prow Job Spec ) in . Deep Copy Into ( out ) return out } 
func ( in * Prow Job Status ) Deep Copy Into ( out * Prow Job Status ) { * out = * in in . Start Time . Deep Copy Into ( & out . Start Time ) if in . Completion Time ! = nil { in , out : = & in . Completion Time , & out . Completion Time * out = ( * in ) . Deep Copy ( ) } if in . Prev Report States ! = nil { in , out : = & in . Prev Report States , & out . Prev Report States * out = make ( map [ string ] Prow Job State , len ( * in ) ) for key , val : = range * in { ( * out ) [ key ] = val } } return } 
func ( in * Prow Job Status ) Deep Copy ( ) * Prow Job Status { if in = = nil { return nil } out : = new ( Prow Job Status ) in . Deep Copy Into ( out ) return out } 
func ( in * Pull ) Deep Copy ( ) * Pull { if in = = nil { return nil } out : = new ( Pull ) in . Deep Copy Into ( out ) return out } 
func ( in * Refs ) Deep Copy Into ( out * Refs ) { * out = * in if in . Pulls ! = nil { in , out : = & in . Pulls , & out . Pulls * out = make ( [ ] Pull , len ( * in ) ) copy ( * out , * in ) } return } 
func ( in * Refs ) Deep Copy ( ) * Refs { if in = = nil { return nil } out : = new ( Refs ) in . Deep Copy Into ( out ) return out } 
func ( in * Utility Images ) Deep Copy ( ) * Utility Images { if in = = nil { return nil } out : = new ( Utility Images ) in . Deep Copy Into ( out ) return out } 
func upload ( rs Client * resultstore . Client , inv resultstore . Invocation , target resultstore . Target , test resultstore . Test ) ( string , error ) { target ID : = test . Name const config ID = resultstore . Default inv Name , err : = rs Client . Invocations ( ) . Create ( inv ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } target Name , err : = rs Client . Targets ( inv Name ) . Create ( target ID , target ) if err ! = nil { return resultstore . URL ( inv Name ) , fmt . Errorf ( " " , err ) } url : = resultstore . URL ( target Name ) _ , err = rs Client . Configurations ( inv Name ) . Create ( config ID ) if err ! = nil { return url , fmt . Errorf ( " " , err ) } ct Name , err : = rs Client . Configured Targets ( target Name , config ID ) . Create ( test . Action ) if err ! = nil { return url , fmt . Errorf ( " " , err ) } _ , err = rs Client . Actions ( ct Name ) . Create ( " " , test ) if err ! = nil { return url , fmt . Errorf ( " " , err ) } return url , nil } 
func ( d * Decoration Config ) Apply Default ( def * Decoration Config ) * Decoration Config { if d = = nil & & def = = nil { return nil } var merged Decoration Config if d ! = nil { merged = * d } else { merged = * def } if d = = nil | | def = = nil { return & merged } merged . Utility Images = merged . Utility Images . Apply Default ( def . Utility Images ) merged . GCSConfiguration = merged . GCSConfiguration . Apply Default ( def . GCSConfiguration ) if merged . Timeout . Duration = = 0 { merged . Timeout = def . Timeout } if merged . Grace Period . Duration = = 0 { merged . Grace Period = def . Grace Period } if merged . GCSCredentials Secret = = " " { merged . GCSCredentials Secret = def . GCSCredentials Secret } if len ( merged . SSHKey Secrets ) = = 0 { merged . SSHKey Secrets = def . SSHKey Secrets } if len ( merged . SSHHost Fingerprints ) = = 0 { merged . SSHHost Fingerprints = def . SSHHost Fingerprints } if merged . Skip Cloning = = nil { merged . Skip Cloning = def . Skip Cloning } if merged . Cookiefile Secret = = " " { merged . Cookiefile Secret = def . Cookiefile Secret } return & merged } 
func ( d * Decoration Config ) Validate ( ) error { if d . Utility Images = = nil { return errors . New ( " " ) } var missing [ ] string if d . Utility Images . Clone Refs = = " " { missing = append ( missing , " " ) } if d . Utility Images . Init Upload = = " " { missing = append ( missing , " " ) } if d . Utility Images . Entrypoint = = " " { missing = append ( missing , " " ) } if d . Utility Images . Sidecar = = " " { missing = append ( missing , " " ) } if len ( missing ) > 0 { return fmt . Errorf ( " " , missing ) } if d . GCSConfiguration = = nil { return errors . New ( " " ) } if d . GCSCredentials Secret = = " " { return errors . New ( " " ) } if err : = d . GCSConfiguration . Validate ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( u * Utility Images ) Apply Default ( def * Utility Images ) * Utility Images { if u = = nil { return def } else if def = = nil { return u } merged : = * u if merged . Clone Refs = = " " { merged . Clone Refs = def . Clone Refs } if merged . Init Upload = = " " { merged . Init Upload = def . Init Upload } if merged . Entrypoint = = " " { merged . Entrypoint = def . Entrypoint } if merged . Sidecar = = " " { merged . Sidecar = def . Sidecar } return & merged } 
func ( g * GCSConfiguration ) Apply Default ( def * GCSConfiguration ) * GCSConfiguration { if g = = nil & & def = = nil { return nil } var merged GCSConfiguration if g ! = nil { merged = * g } else { merged = * def } if g = = nil | | def = = nil { return & merged } if merged . Bucket = = " " { merged . Bucket = def . Bucket } if merged . Path Prefix = = " " { merged . Path Prefix = def . Path Prefix } if merged . Path Strategy = = " " { merged . Path Strategy = def . Path Strategy } if merged . Default Org = = " " { merged . Default Org = def . Default Org } if merged . Default Repo = = " " { merged . Default Repo = def . Default Repo } return & merged } 
func ( g * GCSConfiguration ) Validate ( ) error { if g . Path Strategy ! = Path Strategy Legacy & & g . Path Strategy ! = Path Strategy Explicit & & g . Path Strategy ! = Path Strategy Single { return fmt . Errorf ( " " , Path Strategy Legacy , Path Strategy Explicit , Path Strategy Single ) } if g . Path Strategy ! = Path Strategy Explicit & & ( g . Default Org = = " " | | g . Default Repo = = " " ) { return fmt . Errorf ( " " , g . Path Strategy ) } return nil } 
func ( j * Prow Job ) Set Complete ( ) { j . Status . Completion Time = new ( metav 1 . Time ) * j . Status . Completion Time = metav 1 . Now ( ) } 
func ( j * Prow Job ) Cluster Alias ( ) string { if j . Spec . Cluster = = " " { return Default Cluster Alias } return j . Spec . Cluster } 
func New Resource ( name , rtype , state , owner string , t time . Time ) Resource { return Resource { Name : name , Type : rtype , State : state , Owner : owner , Last Update : t , User Data : & User Data { } , } } 
func New Resources From Config ( e Resource Entry ) [ ] Resource { var resources [ ] Resource for _ , name : = range e . Names { resources = append ( resources , New Resource ( name , e . Type , e . State , " " , time . Time { } ) ) } return resources } 
func User Data From Map ( m User Data Map ) * User Data { ud : = & User Data { } for k , v : = range m { ud . Store ( k , v ) } return ud } 
func ( r * Comma Separated Strings ) Set ( value string ) error { if len ( * r ) > 0 { return errors . New ( " " ) } for _ , rtype : = range strings . Split ( value , " " ) { * r = append ( * r , rtype ) } return nil } 
func ( ud * User Data ) Unmarshal JSON ( data [ ] byte ) error { tmp Map : = User Data Map { } if err : = json . Unmarshal ( data , & tmp Map ) ; err ! = nil { return err } ud . From Map ( tmp Map ) return nil } 
func ( ud * User Data ) Extract ( id string , out interface { } ) error { content , ok : = ud . Load ( id ) if ! ok { return & User Data Not Found { id } } return yaml . Unmarshal ( [ ] byte ( content . ( string ) ) , out ) } 
func ( ud * User Data ) Set ( id string , in interface { } ) error { b , err : = yaml . Marshal ( in ) if err ! = nil { return err } ud . Store ( id , string ( b ) ) return nil } 
func ( ud * User Data ) Update ( new * User Data ) { if new = = nil { return } new . Range ( func ( key , value interface { } ) bool { if value . ( string ) ! = " " { ud . Store ( key , value ) } else { ud . Delete ( key ) } return true } ) } 
func ( ud * User Data ) To Map ( ) User Data Map { m : = User Data Map { } ud . Range ( func ( key , value interface { } ) bool { m [ key . ( string ) ] = value . ( string ) return true } ) return m } 
func ( ud * User Data ) From Map ( m User Data Map ) { for key , value : = range m { ud . Store ( key , value ) } } 
func Item To Resource ( i Item ) ( Resource , error ) { res , ok : = i . ( Resource ) if ! ok { return Resource { } , fmt . Errorf ( " " , i ) } return res , nil } 
func ( o Options ) Run ( ) error { var env [ ] string if len ( o . Key Files ) > 0 { var err error env , err = add SSHKeys ( o . Key Files ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) } if len ( o . Host Fingerprints ) > 0 { if err : = add Host Fingerprints ( o . Host Fingerprints ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) } } var num Workers int if o . Max Parallel Workers ! = 0 { num Workers = o . Max Parallel Workers } else { num Workers = len ( o . Git Refs ) } wg : = & sync . Wait Group { } wg . Add ( num Workers ) input : = make ( chan prowapi . Refs ) output : = make ( chan clone . Record , len ( o . Git Refs ) ) for i : = 0 ; i < num Workers ; i + + { go func ( ) { defer wg . Done ( ) for ref : = range input { output < - clone Func ( ref , o . Src Root , o . Git User Name , o . Git User Email , o . Cookie Path , env ) } } ( ) } for _ , ref : = range o . Git Refs { input < - ref } close ( input ) wg . Wait ( ) close ( output ) var results [ ] clone . Record for record : = range output { results = append ( results , record ) } log Data , err : = json . Marshal ( results ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = ioutil . Write File ( o . Log , log Data , 0 7 5 5 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func add SSHKeys ( paths [ ] string ) ( [ ] string , error ) { vars , err : = exec . Command ( " " ) . Combined Output ( ) if err ! = nil { return [ ] string { } , fmt . Errorf ( " " , err ) } logrus . Info ( " " ) env : = [ ] string { strings . Trim Space ( parts [ 0 ] ) , strings . Trim Space ( parts [ 2 ] ) } for _ , key Path : = range paths { } return nil } if info . Is Dir ( ) { return nil } cmd : = exec . Command ( " " , path ) cmd . Env = append ( cmd . Env , env . . . ) if output , err : = cmd . Combined Output ( ) ; err ! = nil { return fmt . Errorf ( " " , path , err , output ) } logrus . Infof ( " " , path ) return nil } ) ; err ! = nil { return env , fmt . Errorf ( " " , key Path , err ) } } return env , nil } 
func ( f * Triage Filer ) Issues ( c * creator . Issue Creator ) ( [ ] creator . Issue , error ) { f . creator = c rawjson , err : = Read HTTP ( cluster Data URL ) if err ! = nil { return nil , err } clusters , err : = f . load Clusters ( rawjson ) if err ! = nil { return nil , err } topclusters : = top Clusters ( clusters , f . top Clusters Count ) issues : = make ( [ ] creator . Issue , 0 , len ( topclusters ) ) for _ , clust : = range topclusters { issues = append ( issues , clust ) } return issues , nil } 
func ( f * Triage Filer ) Register Flags ( ) { flag . Int Var ( & f . top Clusters Count , " " , 3 , " " ) flag . Int Var ( & f . window Days , " " , 1 , " " ) } 
func ( f * Triage Filer ) filter And Validate ( window Days int ) error { f . latest Start = int 6 4 ( 0 ) for _ , start : = range f . data . Builds . Cols . Started { if start > f . latest Start { f . latest Start = start } } cutoff Time : = time . Unix ( f . latest Start , 0 ) . Add Date ( 0 , 0 , - window Days ) . Unix ( ) valid Clusts : = [ ] * Cluster { } for clust Index , clust : = range f . data . Clustered { if len ( clust . Identifier ) = = 0 { return fmt . Errorf ( " " , clust Index ) } if clust . Tests = = nil { return fmt . Errorf ( " " , clust . Identifier ) } valid Tests : = [ ] * Test { } for _ , test : = range clust . Tests { if len ( test . Name ) = = 0 { return fmt . Errorf ( " " , clust . Identifier ) } if test . Jobs = = nil { return fmt . Errorf ( " " , clust . Identifier ) } valid Jobs : = [ ] * Job { } for _ , job : = range test . Jobs { if len ( job . Name ) = = 0 { return fmt . Errorf ( " " , clust . Identifier , test . Name ) } } if len ( job . Builds ) = = 0 { return fmt . Errorf ( " " , clust . Identifier , job . Name , test . Name ) } valid Builds : = [ ] int { } row Map , ok : = f . data . Builds . Jobs [ job . Name ] if ! ok { return fmt . Errorf ( " " , job . Name ) } for _ , buildnum : = range job . Builds { row , err : = row Map . row For Build ( buildnum ) if err ! = nil { return err } if f . data . Builds . Cols . Started [ row ] > cutoff Time { valid Builds = append ( valid Builds , buildnum ) } } if len ( valid Builds ) > 0 { job . Builds = valid Builds valid Jobs = append ( valid Jobs , job ) } } if len ( valid Jobs ) > 0 { test . Jobs = valid Jobs valid Tests = append ( valid Tests , test ) } } if len ( valid Tests ) > 0 { clust . Tests = valid Tests valid Clusts = append ( valid Clusts , clust ) } } f . data . Clustered = valid Clusts return nil } 
func ( f * Triage Filer ) load Clusters ( json In [ ] byte ) ( [ ] * Cluster , error ) { var err error f . data , err = parse Triage Data ( json In ) if err ! = nil { return nil , err } if err = f . filter And Validate ( f . window Days ) ; err ! = nil { return nil , err } clust . jobs = make ( map [ string ] [ ] int ) for _ , test : = range clust . Tests { for _ , job : = range test . Jobs { for _ , buildnum : = range job . Builds { found : = false for _ , old Build : = range clust . jobs [ job . Name ] { if old Build = = buildnum { found = true break } } if ! found { clust . jobs [ job . Name ] = append ( clust . jobs [ job . Name ] , buildnum ) } } } } clust . total Jobs = len ( clust . jobs ) clust . total Tests = len ( clust . Tests ) clust . total Builds = 0 for _ , builds : = range clust . jobs { clust . total Builds + = len ( builds ) } } return f . data . Clustered , nil } 
func parse Triage Data ( json In [ ] byte ) ( * triage Data , error ) { var data triage Data if err : = json . Unmarshal ( json In , & data ) ; err ! = nil { return nil , err } if data . Builds . Cols . Started = = nil { return nil , fmt . Errorf ( " " ) } if data . Builds . Jobs Raw = = nil { return nil , fmt . Errorf ( " " ) } if data . Builds . Job Paths = = nil { return nil , fmt . Errorf ( " " ) } if data . Clustered = = nil { return nil , fmt . Errorf ( " " ) } for job ID , mapper : = range data . Builds . Jobs Raw { switch mapper : = mapper . ( type ) { case [ ] interface { } : case map [ string ] interface { } : default : return nil , fmt . Errorf ( " " , job ID , reflect . Type Of ( mapper ) ) } } return & data , nil } 
func top Clusters ( clusters [ ] * Cluster , count int ) [ ] * Cluster { less : = func ( i , j int ) bool { return clusters [ i ] . total Builds > clusters [ j ] . total Builds } sort . Slice Stable ( clusters , less ) if len ( clusters ) < count { count = len ( clusters ) } return clusters [ 0 : count ] } 
func ( c * Cluster ) top Jobs Failed ( count int ) [ ] * Job { slice : = make ( [ ] * Job , len ( c . jobs ) ) i : = 0 for job Name , builds : = range c . jobs { slice [ i ] = & Job { Name : job Name , Builds : builds } i + + } less : = func ( i , j int ) bool { return len ( slice [ i ] . Builds ) > len ( slice [ j ] . Builds ) } sort . Slice Stable ( slice , less ) if len ( slice ) < count { count = len ( slice ) } return slice [ 0 : count ] } 
func ( c * Cluster ) Title ( ) string { return fmt . Sprintf ( " " , c . Identifier [ 0 : 6 ] , c . total Builds , c . total Jobs , c . total Tests , c . filer . window Days , ) } 
func ( c * Cluster ) Body ( closed Issues [ ] * githubapi . Issue ) string { for _ , closed : = range closed Issues { if closed . Closed At . After ( cutoff Time ) { return " " } } var buf bytes . Buffer fmt . Fprintf ( & buf , " \n " , c . ID ( ) , triage URL , c . Identifier ) fmt . Fprintf ( & buf , " \n \n \n \n " , c . Text ) fmt . Fprintf ( & buf , " \n " , c . total Tests , c . total Jobs , c . total Builds ) fmt . Fprintf ( & buf , " \n \n " , c . filer . window Days , cutoff Time . Format ( time Format ) , time . Unix ( c . filer . latest Start , 0 ) . Format ( time Format ) ) for _ , test : = range c . top Tests Failed ( top Tests Count ) { fmt . Fprintf ( & buf , " \n " , test . Name , len ( test . Jobs ) ) } fmt . Fprint ( & buf , " \n \n \n " ) for _ , job : = range c . top Jobs Failed ( top Jobs Count ) { latest : = 0 latest Time : = int 6 4 ( 0 ) row Map : = c . filer . data . Builds . Jobs [ job . Name ] for _ , build : = range job . Builds { row , _ : = row Map . row For Build ( build ) build Time : = c . filer . data . Builds . Cols . Started [ row ] if build Time > latest Time { latest Time = build Time latest = build } } path : = strings . Trim Prefix ( c . filer . data . Builds . Job Paths [ job . Name ] , " " ) fmt . Fprintf ( & buf , " \n " , job . Name , len ( job . Builds ) , time . Unix ( latest Time , 0 ) . Format ( time Format ) , path , latest ) } for _ , closed : = range closed Issues { fmt . Fprintf ( & buf , " " , * closed . Number ) } fmt . Fprint ( & buf , " \n " ) } for _ , test : = range c . top Tests Failed ( len ( c . Tests ) ) { test Names = append ( test Names , test . Name ) } owners Map : = c . filer . creator . Tests Owners ( test Names ) if len ( owners Map ) > 0 { fmt . Fprint ( & buf , " \n " ) for user : = range owners Map { fmt . Fprintf ( & buf , " " , user ) } fmt . Fprint ( & buf , " \n " ) } fmt . Fprintf ( & buf , " \n " , triage URL , c . Identifier ) return buf . String ( ) } 
func ( c * Cluster ) Labels ( ) [ ] string { labels : = [ ] string { " " } top Tests : = make ( [ ] string , len ( c . Tests ) ) for i , test : = range c . top Tests Failed ( len ( c . Tests ) ) { top Tests [ i ] = test . Name } for sig : = range c . filer . creator . Tests SIGs ( top Tests ) { labels = append ( labels , " " + sig ) } return labels } 
func New ( ) * Cron { return & Cron { cron Agent : cron . New ( ) , jobs : map [ string ] * job Status { } , logger : logrus . With Field ( " " , " " ) , } } 
func ( c * Cron ) Queued Jobs ( ) [ ] string { c . lock . Lock ( ) defer c . lock . Unlock ( ) res : = [ ] string { } for k , v : = range c . jobs { if v . triggered { res = append ( res , k ) } c . jobs [ k ] . triggered = false } return res } 
func ( c * Cron ) Sync Config ( cfg * config . Config ) error { c . lock . Lock ( ) defer c . lock . Unlock ( ) for _ , p : = range cfg . Periodics { if err : = c . add Periodic ( p ) ; err ! = nil { return err } } periodic Names : = sets . New String ( ) for _ , p : = range cfg . All Periodics ( ) { periodic Names . Insert ( p . Name ) } existing : = sets . New String ( ) for k : = range c . jobs { existing . Insert ( k ) } var removal Errors [ ] error for _ , job : = range existing . Difference ( periodic Names ) . List ( ) { if err : = c . remove Job ( job ) ; err ! = nil { removal Errors = append ( removal Errors , err ) } } return errorutil . New Aggregate ( removal Errors . . . ) } 
func ( c * Cron ) Has Job ( name string ) bool { c . lock . Lock ( ) defer c . lock . Unlock ( ) _ , ok : = c . jobs [ name ] return ok } 
func ( c * Cron ) add Job ( name , cron string ) error { id , err : = c . cron Agent . Add Func ( " " + cron , func ( ) { c . lock . Lock ( ) defer c . lock . Unlock ( ) c . jobs [ name ] . triggered = true c . logger . Infof ( " " , name ) } ) if err ! = nil { return fmt . Errorf ( " " , name , cron , err ) } c . jobs [ name ] = & job Status { entry ID : id , cron Str : cron , c . logger . Infof ( " " , name , cron ) return nil } 
func ( c * Cron ) remove Job ( name string ) error { job , ok : = c . jobs [ name ] if ! ok { return fmt . Errorf ( " " , name ) } c . cron Agent . Remove ( job . entry ID ) delete ( c . jobs , name ) c . logger . Infof ( " " , name ) return nil } 
func Update Comments ( issue ID int , pull Request bool , db * gorm . DB , client Client Interface ) { latest : = find Latest Comment Update ( issue ID , db , client . Repository Name ( ) ) update Issue Comments ( issue ID , latest , db , client ) if pull Request { update Pull Comments ( issue ID , latest , db , client ) } } 
func Gather Prow Job Metrics ( pjs [ ] prowapi . Prow Job ) { for _ , pj : = range pjs { if metric Map [ pj . Spec . Job ] = = nil { metric Map [ pj . Spec . Job ] = make ( map [ string ] map [ string ] float 6 4 ) } if metric Map [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] = = nil { metric Map [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] = make ( map [ string ] float 6 4 ) } metric Map [ pj . Spec . Job ] [ string ( pj . Spec . Type ) ] [ string ( pj . Status . State ) ] + + } for job , job Map : = range metric Map { for job Type , type Map : = range job Map { for state , count : = range type Map { prow Jobs . With Label Values ( job , job Type , state ) . Set ( count ) } } } } 
func ( o Options ) Run ( ) int { code , err : = o . Execute Process ( ) if err ! = nil { logrus . With Error ( err ) . Error ( " " ) } if err : = o . mark ( code ) ; err ! = nil { logrus . With Error ( err ) . Error ( " " ) return Internal Error Code } if o . Always Zero { return 0 } return code } 
func ( o Options ) Execute Process ( ) ( int , error ) { if o . Artifact Dir ! = " " { if err : = os . Mkdir All ( o . Artifact Dir , os . Mode Perm ) ; err ! = nil { return Internal Error Code , fmt . Errorf ( " " , o . Artifact Dir , err ) } } process Log File , err : = os . Create ( o . Process Log ) if err ! = nil { return Internal Error Code , fmt . Errorf ( " " , o . Process Log , err ) } defer process Log File . Close ( ) output : = io . Multi Writer ( os . Stdout , process Log File ) logrus . Set Output ( output ) defer logrus . Set Output ( os . Stdout ) signal . Notify ( interrupt , os . Interrupt , syscall . SIGTERM ) if o . Previous Marker ! = " " { ctx , cancel : = context . With Cancel ( context . Background ( ) ) go func ( ) { select { case s : = < - interrupt : logrus . Errorf ( " " , s ) cancel ( ) case < - ctx . Done ( ) : } } ( ) code , err : = wrapper . Wait For Marker ( ctx , o . Previous Marker ) cancel ( ) if err ! = nil { return Internal Error Code , fmt . Errorf ( " " , o . Previous Marker , err ) } if code ! = 0 { logrus . Infof ( " " , code ) return Previous Error Code , nil } } executable : = o . Args [ 0 ] var arguments [ ] string if len ( o . Args ) > 1 { arguments = o . Args [ 1 : ] } command : = exec . Command ( executable , arguments . . . ) command . Stderr = output command . Stdout = output if err : = command . Start ( ) ; err ! = nil { return Internal Error Code , fmt . Errorf ( " " , err ) } timeout : = option Or Default ( o . Timeout , Default Timeout ) grace Period : = option Or Default ( o . Grace Period , Default Grace Period ) var command Err error cancelled , aborted : = false , false done : = make ( chan error ) go func ( ) { done < - command . Wait ( ) } ( ) select { case err : = < - done : command Err = err case < - time . After ( timeout ) : logrus . Errorf ( " " , timeout ) cancelled = true gracefully Terminate ( command , done , grace Period ) case s : = < - interrupt : logrus . Errorf ( " " , s ) cancelled = true aborted = true gracefully Terminate ( command , done , grace Period ) } var return Code int if cancelled { if aborted { command Err = err Aborted return Code = Aborted Error Code } else { command Err = err Timed Out return Code = Internal Error Code } } else { if status , ok : = command . Process State . Sys ( ) . ( syscall . Wait Status ) ; ok { return Code = status . Exit Status ( ) } else if command Err = = nil { return Code = 0 } else { return Code = 1 } if return Code ! = 0 { command Err = fmt . Errorf ( " " , command Err ) } } return return Code , command Err } 
func option Or Default ( option , default Value time . Duration ) time . Duration { if option = = 0 { return default Value } return option } 
func new GCSJob Source ( src string ) ( * gcs Job Source , error ) { gcs URL , err : = url . Parse ( fmt . Sprintf ( " " , src ) ) if err ! = nil { return & gcs Job Source { } , Err Cannot Parse Source } gcs Path : = & gcs . Path { } err = gcs Path . Set URL ( gcs URL ) if err ! = nil { return & gcs Job Source { } , Err Cannot Parse Source } tokens : = strings . Fields Func ( gcs Path . Object ( ) , func ( c rune ) bool { return c = = ' / ' } ) if len ( tokens ) < 2 { return & gcs Job Source { } , Err Cannot Parse Source } build ID : = tokens [ len ( tokens ) - 1 ] name : = tokens [ len ( tokens ) - 2 ] return & gcs Job Source { source : src , link Prefix : " " , bucket : gcs Path . Bucket ( ) , job Prefix : path . Clean ( gcs Path . Object ( ) ) + " " , job Name : name , build ID : build ID , } , nil } 
func ( af * GCSArtifact Fetcher ) artifacts ( key string ) ( [ ] string , error ) { src , err : = new GCSJob Source ( key ) if err ! = nil { return nil , fmt . Errorf ( " " , key , err ) } list Start : = time . Now ( ) bucket Name , prefix : = extract Bucket Prefix Pair ( src . job Path ( ) ) artifacts : = [ ] string { } bkt : = af . client . Bucket ( bucket Name ) q : = storage . Query { Prefix : prefix , Versions : false , } obj Iter : = bkt . Objects ( context . Background ( ) , & q ) wait : = [ ] time . Duration { 1 6 , 3 2 , 6 4 , 1 2 8 , 2 5 6 , 2 5 6 , 5 1 2 , 5 1 2 } for i : = 0 ; ; { o Attrs , err : = obj Iter . Next ( ) if err = = iterator . Done { break } if err ! = nil { logrus . With Fields ( fields For Job ( src ) ) . With Error ( err ) . Error ( " " ) if i > = len ( wait ) { return artifacts , fmt . Errorf ( " " , err ) } time . Sleep ( ( wait [ i ] + time . Duration ( rand . Intn ( 1 0 ) ) ) * time . Millisecond ) i + + continue } artifacts = append ( artifacts , strings . Trim Prefix ( o Attrs . Name , prefix ) ) i = 0 } list Elapsed : = time . Since ( list Start ) logrus . With Field ( " " , list Elapsed ) . Infof ( " " , len ( artifacts ) ) return artifacts , nil } 
func ( af * GCSArtifact Fetcher ) artifact ( key string , artifact Name string , size Limit int 6 4 ) ( lenses . Artifact , error ) { src , err : = new GCSJob Source ( key ) if err ! = nil { return nil , fmt . Errorf ( " " , key , err ) } bucket Name , prefix : = extract Bucket Prefix Pair ( src . job Path ( ) ) bkt : = af . client . Bucket ( bucket Name ) obj : = & gcs Artifact Handle { bkt . Object ( path . Join ( prefix , artifact Name ) ) } artifact Link : = & url . URL { Scheme : https Scheme , Host : " " , Path : path . Join ( src . job Path ( ) , artifact Name ) , } return New GCSArtifact ( context . Background ( ) , obj , artifact Link . String ( ) , artifact Name , size Limit ) , nil } 
func ( src * gcs Job Source ) canonical Link ( ) string { return path . Join ( src . link Prefix , src . bucket , src . job Prefix ) } 
func ( src * gcs Job Source ) job Path ( ) string { return fmt . Sprintf ( " " , src . bucket , src . job Prefix ) } 
func requirement Diff ( pr * Pull Request , q * config . Tide Query , cc context Checker ) ( string , int ) { const max Label Chars = 5 0 var desc string var diff int chars : = len ( labels [ 0 ] ) for ; i < len ( labels ) ; i + + { if chars + len ( labels [ i ] ) > max Label Chars { break } chars + = len ( labels [ i ] ) + 2 } return labels [ : i ] } for _ , excluded Branch : = range q . Excluded Branches { if string ( pr . Base Ref . Name ) = = excluded Branch { target Branch Blacklisted = true break } } for _ , included Branch : = range q . Included Branches { if string ( pr . Base Ref . Name ) = = included Branch { target Branch Whitelisted = true break } } if target Branch Blacklisted | | ! target Branch Whitelisted { diff + = 1 0 0 0 if desc = = " " { desc = fmt . Sprintf ( " " , pr . Base Ref . Name ) } } if desc = = " " { desc = fmt . Sprintf ( " " , q . Milestone ) } } for _ , l 1 : = range q . Labels { var found bool for _ , l 2 : = range pr . Labels . Nodes { if string ( l 2 . Name ) = = l 1 { found = true break } } if ! found { missing Labels = append ( missing Labels , l 1 ) } } diff + = len ( missing Labels ) if desc = = " " & & len ( missing Labels ) > 0 { sort . Strings ( missing Labels ) trunced : = truncate ( missing Labels ) if len ( trunced ) = = 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] ) } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) ) } } var present Labels [ ] string for _ , l 1 : = range q . Missing Labels { for _ , l 2 : = range pr . Labels . Nodes { if string ( l 2 . Name ) = = l 1 { present Labels = append ( present Labels , l 1 ) break } } } diff + = len ( present Labels ) if desc = = " " & & len ( present Labels ) > 0 { sort . Strings ( present Labels ) trunced : = truncate ( present Labels ) if len ( trunced ) = = 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] ) } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) ) } } for _ , commit : = range pr . Commits . Nodes { if commit . Commit . OID = = pr . Head Ref OID { for _ , ctx : = range unsuccessful Contexts ( commit . Commit . Status . Contexts , cc , logrus . New ( ) . With Fields ( pr . log Fields ( ) ) ) { contexts = append ( contexts , string ( ctx . Context ) ) } } } diff + = len ( contexts ) if desc = = " " & & len ( contexts ) > 0 { sort . Strings ( contexts ) trunced : = truncate ( contexts ) if len ( trunced ) = = 1 { desc = fmt . Sprintf ( " " , trunced [ 0 ] ) } else { desc = fmt . Sprintf ( " " , strings . Join ( trunced , " " ) ) } } } 
func expected Status ( query Map * config . Query Map , pr * Pull Request , pool map [ string ] Pull Request , cc context Checker ) ( string , string ) { if _ , ok : = pool [ pr Key ( pr ) ] ; ! ok { min Diff Count : = - 1 var min Diff string for _ , q : = range query Map . For Repo ( string ( pr . Repository . Owner . Login ) , string ( pr . Repository . Name ) ) { diff , diff Count : = requirement Diff ( pr , & q , cc ) if min Diff Count = = - 1 | | diff Count < min Diff Count { min Diff Count = diff Count min Diff = diff } } return github . Status Pending , fmt . Sprintf ( status Not In Pool , min Diff ) } return github . Status Success , status In Pool } 
func target URL ( c config . Getter , pr * Pull Request , log * logrus . Entry ) string { var link string if tide URL : = c ( ) . Tide . Target URL ; tide URL ! = " " { link = tide URL } else if base URL : = c ( ) . Tide . PRStatus Base URL ; base URL ! = " " { parse URL , err : = url . Parse ( base URL ) if err ! = nil { log . With Error ( err ) . Error ( " " ) } else { pr Query : = fmt . Sprintf ( " " , pr . Repository . Name With Owner , pr . Author . Login , pr . Head Ref Name ) values : = parse URL . Query ( ) values . Set ( " " , pr Query ) parse URL . Raw Query = values . Encode ( ) link = parse URL . String ( ) } } return link } 
func ( sc * status Controller ) wait Sync ( ) { for { select { case < - wait : sc . Lock ( ) pool : = sc . pool PRs sc . Unlock ( ) sc . sync ( pool ) return case more : = < - sc . new Pool Pending : if ! more { return } } } } 
func new Build Config ( cfg rest . Config , stop chan struct { } ) ( * build Config , error ) { bc , err : = buildset . New For Config ( & cfg ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } bif . Build ( ) . V 1alpha 1 ( ) . Builds ( ) . Lister ( ) go bif . Start ( stop ) return & build Config { client : bc , informer : bif . Build ( ) . V 1alpha 1 ( ) . Builds ( ) , } , nil } 
func New Client ( token string , dry Run bool ) * Client { http Client : = & http . Client { Transport : & oauth 2 . Transport { Base : http . Default Transport , Source : oauth 2 . Reuse Token Source ( nil , oauth 2 . Static Token Source ( & oauth 2 . Token { Access Token : token } ) ) , } , } client : = github . New Client ( http Client ) return & Client { issue Service : client . Issues , pr Service : client . Pull Requests , repo Service : client . Repositories , user Service : client . Users , retries : 5 , retry Initial Backoff : time . Second , token Reserve : 5 0 , dry Run : dry Run , } } 
func ( c * Client ) retry ( action string , call func ( ) ( * github . Response , error ) ) ( * github . Response , error ) { var err error var resp * github . Response for retry Count : = 0 ; retry Count < = c . retries ; retry Count + + { if resp , err = call ( ) ; err = = nil { c . limit Rate ( & resp . Rate ) return resp , nil } switch err : = err . ( type ) { case * github . Rate Limit Error : c . limit Rate ( & err . Rate ) case * github . Two Factor Auth Error : return resp , err case * retry Abort : return resp , err } if retry Count = = c . retries { return resp , err } glog . Errorf ( " \n " , action , err ) c . sleep For Attempt ( retry Count ) } return resp , err } 
func ( c * Client ) depaginate ( action string , opts * github . List Options , call func ( ) ( [ ] interface { } , * github . Response , error ) ) ( [ ] interface { } , error ) { var all Items [ ] interface { } wrapper : = func ( ) ( * github . Response , error ) { items , resp , err : = call ( ) if err = = nil { all Items = append ( all Items , items . . . ) } return resp , err } opts . Page = 1 opts . Per Page = 1 0 0 last Page : = 1 for ; opts . Page < = last Page ; opts . Page + + { resp , err : = c . retry ( action , wrapper ) if err ! = nil { return all Items , fmt . Errorf ( " " , opts . Page , last Page , err ) } if resp . Last Page > 0 { last Page = resp . Last Page } } return all Items , nil } 
func New Help Agent ( pa plugin Agent , ghc github Client ) * Help Agent { l : = logrus . With Field ( " " , " " ) return & Help Agent { log : l , pa : pa , oa : new Org Agent ( l , ghc , new Repo Detection Limit ) , } } 
func ( ha * Help Agent ) Generate Plugin Help ( ) * pluginhelp . Help { config : = ha . pa . Config ( ) org To Repos : = ha . oa . org To Repos Map ( config ) normal Rev Map , external Rev Map : = reverse Plugin Maps ( config , org To Repos ) all Plugins , plugin Help : = ha . generate Normal Plugin Help ( config , normal Rev Map ) all External Plugins , external Plugin Help : = ha . generate External Plugin Help ( config , external Rev Map ) for repo , plugins : = range config . Plugins { repo Plugins [ repo ] = plugins } repo External Plugins : = map [ string ] [ ] string { " " : all External Plugins , } for repo , exts : = range config . External Plugins { for _ , ext : = range exts { repo External Plugins [ repo ] = append ( repo External Plugins [ repo ] , ext . Name ) } } return & pluginhelp . Help { All Repos : all Repos ( config , org To Repos ) , Repo Plugins : repo Plugins , Repo External Plugins : repo External Plugins , Plugin Help : plugin Help , External Plugin Help : external Plugin Help , } } 
func reverse Plugin Maps ( config * plugins . Configuration , org To Repos map [ string ] sets . String ) ( normal , external map [ string ] [ ] string ) { normal = map [ string ] [ ] string { } for repo , enabled Plugins : = range config . Plugins { var repos [ ] string if ! strings . Contains ( repo , " " ) { if flattened , ok : = org To Repos [ repo ] ; ok { repos = flattened . List ( ) } } else { repos = [ ] string { repo } } for _ , plugin : = range enabled Plugins { normal [ plugin ] = append ( normal [ plugin ] , repos . . . ) } } external = map [ string ] [ ] string { } for repo , ext Plugins : = range config . External Plugins { var repos [ ] string if flattened , ok : = org To Repos [ repo ] ; ok { repos = flattened . List ( ) } else { repos = [ ] string { repo } } for _ , plugin : = range ext Plugins { external [ plugin . Name ] = append ( external [ plugin . Name ] , repos . . . ) } } return } 
func orgs In Config ( config * plugins . Configuration ) sets . String { orgs : = sets . New String ( ) for repo : = range config . Plugins { if ! strings . Contains ( repo , " " ) { orgs . Insert ( repo ) } } for repo : = range config . External Plugins { if ! strings . Contains ( repo , " " ) { orgs . Insert ( repo ) } } return orgs } 
func ( r * request Coalescer ) Round Trip ( req * http . Request ) ( * http . Response , error ) { } var cache Mode = Mode Error resp , err : = func ( ) ( * http . Response , error ) { key : = req . URL . String ( ) r . Lock ( ) waiter , ok : = r . keys [ key ] if ok { } waiter . L . Lock ( ) r . Unlock ( ) waiter . waiting = true waiter . L . Unlock ( ) } resp , err : = http . Read Response ( bufio . New Reader ( bytes . New Buffer ( waiter . resp ) ) , nil ) if err ! = nil { logrus . With Field ( " " , key ) . With Error ( err ) . Error ( " " ) return nil , err } cache Mode = Mode Coalesced return resp , nil } r . keys [ key ] = waiter r . Unlock ( ) resp , err : = r . delegate . Round Trip ( req ) delete ( r . keys , key ) r . Unlock ( ) waiter . L . Lock ( ) if waiter . waiting { if err ! = nil { waiter . resp , waiter . err = nil , err } else { } waiter . Broadcast ( ) } waiter . L . Unlock ( ) if err ! = nil { logrus . With Field ( " " , key ) . With Error ( err ) . Error ( " " ) return nil , err } cache Mode = cache Response Mode ( resp . Header ) return resp , nil } ( ) cache Counter . With Label Values ( string ( cache Mode ) ) . Inc ( ) if resp ! = nil { resp . Header . Set ( Cache Mode Header , string ( cache Mode ) ) } return resp , err } 
func ( o * Options ) Validate ( ) error { if len ( o . Args ) = = 0 { return errors . New ( " " ) } return o . Options . Validate ( ) } 
func ( o * Options ) Add Flags ( flags * flag . Flag Set ) { flags . Duration Var ( & o . Timeout , " " , Default Timeout , " " ) flags . Duration Var ( & o . Grace Period , " " , Default Grace Period , " " ) flags . String Var ( & o . Artifact Dir , " " , " " , " " ) o . Options . Add Flags ( flags ) } 
func get Pull Commit Hash ( pull string ) ( string , error ) { match : = pull Commit Re . Find String Submatch ( pull ) if len ( match ) ! = 2 { expected : = " " return " " , fmt . Errorf ( " " , pull , expected ) } return match [ 1 ] , nil } 
func list Job Builds ( bucket storage Bucket , job Prefixes [ ] string ) [ ] job Builds { jobch : = make ( chan job Builds ) defer close ( jobch ) for i , job Prefix : = range job Prefixes { go func ( i int , job Prefix string ) { build Prefixes , err : = bucket . list Sub Dirs ( job Prefix ) if err ! = nil { logrus . With Error ( err ) . Warningf ( " " , job Prefix ) } jobch < - job Builds { name : path . Base ( job Prefix ) , build Prefixes : build Prefixes , } } ( i , job Prefix ) } jobs : = [ ] job Builds { } for range job Prefixes { job : = < - jobch jobs = append ( jobs , job ) } return jobs } 
func get PRBuild Data ( bucket storage Bucket , jobs [ ] job Builds ) [ ] build Data { buildch : = make ( chan build Data ) defer close ( buildch ) expected : = 0 for _ , job : = range jobs { for j , build Prefix : = range job . build Prefixes { go func ( j int , job Name , build Prefix string ) { build , err : = get Build Data ( bucket , build Prefix ) if err ! = nil { logrus . With Error ( err ) . Warningf ( " " , build Prefix ) } split : = strings . Split ( strings . Trim Suffix ( build Prefix , " " ) , " " ) build . Spyglass Link = path . Join ( spyglass Prefix , bucket . get Name ( ) , build Prefix ) build . ID = split [ len ( split ) - 1 ] build . job Name = job Name build . prefix = build Prefix build . index = j buildch < - build } ( j , job . name , build Prefix ) expected + + } } builds : = [ ] build Data { } for k : = 0 ; k < expected ; k + + { build : = < - buildch builds = append ( builds , build ) } return builds } 
func parse Pull URL ( u * url . URL ) ( org , repo string , pr int , err error ) { var pr Str string vals : = u . Query ( ) if org = vals . Get ( " " ) ; org = = " " { return " " , " " , 0 , fmt . Errorf ( " " ) } if repo = vals . Get ( " " ) ; repo = = " " { return " " , " " , 0 , fmt . Errorf ( " " ) } pr Str = vals . Get ( " " ) pr , err = strconv . Atoi ( pr Str ) if err ! = nil { return " " , " " , 0 , fmt . Errorf ( " " , pr Str , err ) } return org , repo , pr , nil } 
func get GCSDirs For PR ( config * config . Config , org , repo string , pr int ) ( map [ string ] sets . String , error ) { to Search : = make ( map [ string ] sets . String ) full Repo : = org + " " + repo presubmits , ok : = config . Presubmits [ full Repo ] if ! ok { return to Search , fmt . Errorf ( " " , full Repo ) } for _ , presubmit : = range presubmits { var gcs Config * v 1 . GCSConfiguration if presubmit . Decoration Config ! = nil & & presubmit . Decoration Config . GCSConfiguration ! = nil { gcs Config = presubmit . Decoration Config . GCSConfiguration } else { } gcs Path , _ , _ : = gcsupload . Paths For Job ( gcs Config , & downwardapi . Job Spec { Type : v 1 . Presubmit Job , Job : presubmit . Name , Refs : & v 1 . Refs { Repo : repo , Org : org , Pulls : [ ] v 1 . Pull { { Number : pr } , } , } , } , " " ) gcs Path , _ = path . Split ( path . Clean ( gcs Path ) ) if _ , ok : = to Search [ gcs Config . Bucket ] ; ! ok { to Search [ gcs Config . Bucket ] = sets . String { } } to Search [ gcs Config . Bucket ] . Insert ( gcs Path ) } return to Search , nil } 
func img Post Cont Info ( d * Daemon , r * http . Request , req api . Images Post , op * operation , builddir string ) ( * api . Image , error ) { info : = api . Image { } info . Properties = map [ string ] string { } project : = project Param ( r ) name : = req . Source . Name ctype : = req . Source . Type if ctype = = " " | | name = = " " { return nil , fmt . Errorf ( " " ) } switch ctype { case " " : if ! shared . Is Snapshot ( name ) { return nil , fmt . Errorf ( " " ) } case " " : if shared . Is Snapshot ( name ) { return nil , fmt . Errorf ( " " ) } default : return nil , fmt . Errorf ( " " ) } info . Filename = req . Filename switch req . Public { case true : info . Public = true case false : info . Public = false } c , err : = container Load By Project And Name ( d . State ( ) , project , name ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } defer os . Remove ( image File . Name ( ) ) sum Size : = func ( path string , fi os . File Info , err error ) error { if err = = nil { total Size + = fi . Size ( ) } return nil } err = filepath . Walk ( c . Rootfs Path ( ) , sum Size ) if err ! = nil { return nil , err } image Progress Writer : = & ioprogress . Progress Writer { Tracker : & ioprogress . Progress Tracker { Handler : func ( value , speed int 6 4 ) { percent : = int 6 4 ( 0 ) processed : = int 6 4 ( 0 ) if total Size > 0 { percent = value processed = total Size * ( percent / 1 0 0 . 0 ) } else { processed = value } shared . Set Progress Metadata ( metadata , " " , " " , percent , processed , speed ) op . Update Metadata ( metadata ) } , Length : total Size , } , } sha 2 5 6 : = sha 2 5 6 . New ( ) var compress string var writer io . Writer if req . Compression Algorithm ! = " " { compress = req . Compression Algorithm } else { compress , err = cluster . Config Get String ( d . cluster , " " ) if err ! = nil { return nil , err } } var compress Err error if compress ! = " " { wg . Add ( 1 ) tar Reader , tar Writer : = io . Pipe ( ) image Progress Writer . Write Closer = tar Writer writer = image Progress Writer compress Writer : = io . Multi Writer ( image File , sha 2 5 6 ) go func ( ) { defer wg . Done ( ) compress Err = compress File ( compress , tar Reader , compress Writer ) } ( ) } else { image Progress Writer . Write Closer = image File writer = io . Multi Writer ( image Progress Writer , sha 2 5 6 ) } err = c . Export ( writer , req . Properties ) wg . Wait ( ) if err ! = nil { return nil , err } if compress Err ! = nil { return nil , err } image File . Close ( ) fi , err : = os . Stat ( image File . Name ( ) ) if err ! = nil { return nil , err } info . Size = fi . Size ( ) info . Fingerprint = fmt . Sprintf ( " " , sha 2 5 6 . Sum ( nil ) ) _ , _ , err = d . cluster . Image Get ( project , info . Fingerprint , false , true ) if err ! = db . Err No Such Object { if err ! = nil { return nil , err } return & info , fmt . Errorf ( " " , info . Fingerprint ) } final Name : = shared . Var Path ( " " , info . Fingerprint ) err = shared . File Move ( image File . Name ( ) , final Name ) if err ! = nil { return nil , err } info . Architecture , _ = osarch . Architecture Name ( c . Architecture ( ) ) info . Properties = req . Properties if err ! = nil { return nil , err } return & info , nil } 
func image Create In Pool ( d * Daemon , info * api . Image , storage Pool string ) error { if storage Pool = = " " { return fmt . Errorf ( " " ) } if err ! = nil { return err } if err ! = nil { return err } return nil } 
func auto Update Image ( d * Daemon , op * operation , id int , info * api . Image , project string ) error { fingerprint : = info . Fingerprint _ , source , err : = d . cluster . Image Source Get ( id ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : fingerprint } ) return err } if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : fingerprint } ) return err } if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : fingerprint } ) return err } } logger . Debug ( " " , log . Ctx { " " : fingerprint , " " : source . Server , " " : source . Protocol , " " : source . Alias } ) } metadata : = map [ string ] interface { } { " " : result } op . Update Metadata ( metadata ) } for _ , pool Name : = range pool Names { new Info , err : = d . Image Download ( op , source . Server , source . Protocol , source . Certificate , " " , source . Alias , false , true , pool Name , false , project ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : fingerprint } ) continue } hash = new Info . Fingerprint if hash = = fingerprint { logger . Debug ( " " , log . Ctx { " " : fingerprint } ) continue } new Id , _ , err : = d . cluster . Image Get ( " " , hash , false , true ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : hash } ) continue } if info . Cached { err = d . cluster . Image Last Access Init ( hash ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : hash } ) continue } } err = d . cluster . Image Last Access Update ( hash , info . Last Used At ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : hash } ) continue } err = d . cluster . Image Aliases Move ( id , new Id ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : hash } ) continue } if err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : fingerprint } ) } } } return nil } if shared . Path Exists ( fname ) { err = os . Remove ( fname ) if err ! = nil { logger . Debugf ( " " , fname , err ) } } if shared . Path Exists ( fname ) { err = os . Remove ( fname ) if err ! = nil { logger . Debugf ( " " , fname , err ) } } } set Refresh Result ( true ) return nil } 
func image Delete From Disk ( fingerprint string ) { if shared . Path Exists ( fname ) { err : = os . Remove ( fname ) if err ! = nil & & ! os . Is Not Exist ( err ) { logger . Errorf ( " " , fname , err ) } } if shared . Path Exists ( fname ) { err : = os . Remove ( fname ) if err ! = nil & & ! os . Is Not Exist ( err ) { logger . Errorf ( " " , fname , err ) } } } 
func networks Get ( d * Daemon , r * http . Request ) Response { recursion : = util . Is Recursion Request ( r ) ifs , err : = network Get Interfaces ( d . cluster ) if err ! = nil { return Internal Error ( err ) } result String : = [ ] string { } result Map : = [ ] api . Network { } for _ , iface : = range ifs { if ! recursion { result String = append ( result String , fmt . Sprintf ( " " , version . APIVersion , iface ) ) } else { net , err : = do Network Get ( d , iface ) if err ! = nil { continue } result Map = append ( result Map , net ) } } if ! recursion { return Sync Response ( true , result String ) } return Sync Response ( true , result Map ) } 
func do Networks Create ( d * Daemon , req api . Networks Post , with Database bool ) error { if err ! = nil { return err } err = n . Start ( ) if err ! = nil { n . Delete ( with Database ) return err } return nil } 
func network Load By Name ( s * state . State , name string ) ( * network , error ) { id , db Info , err : = s . Cluster . Network Get ( name ) if err ! = nil { return nil , err } n : = network { state : s , id : id , name : name , description : db Info . Description , config : db Info . Config } return & n , nil } 
func Open Node ( dir string , fresh func ( * Node ) error , legacy Patches map [ int ] * Legacy Patch ) ( * Node , * Dump , error ) { db , err : = node . Open ( dir ) if err ! = nil { return nil , nil , err } legacy Hook : = legacy Patch Hook ( db , legacy Patches ) hook : = func ( version int , tx * sql . Tx ) error { if version = = node . Update From Pre Clustering { logger . Debug ( " " ) var err error dump , err = Load Pre Clustering Data ( tx ) if err ! = nil { return err } } return legacy Hook ( version , tx ) } initial , err : = node . Ensure Schema ( db , dir , hook ) if err ! = nil { return nil , nil , err } node : = & Node { db : db , dir : dir , } if initial = = 0 { if fresh ! = nil { err : = fresh ( node ) if err ! = nil { return nil , nil , err } } } db . Set Max Open Conns ( 1 ) db . Set Max Idle Conns ( 1 ) return node , dump , nil } 
func ( n * Node ) Transaction ( f func ( * Node Tx ) error ) error { node Tx : = & Node Tx { } return query . Transaction ( n . db , func ( tx * sql . Tx ) error { node Tx . tx = tx return f ( node Tx ) } ) } 
func Open Cluster ( name string , store dqlite . Server Store , address , dir string , timeout time . Duration , options . . . dqlite . Driver Option ) ( * Cluster , error ) { db , err : = cluster . Open ( name , store , options . . . ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = 0 ; ; i + + { if i > 5 { log Priority = 2 if i > 1 5 & & ! ( ( i % 5 ) = = 0 ) { log Priority = 0 } } err = db . Ping ( ) if err = = nil { break } cause : = errors . Cause ( err ) if cause ! = dqlite . Err No Available Leader { return nil , err } switch log Priority { case 1 : logger . Debugf ( " " , i , err ) case 2 : logger . Warnf ( " " , i , err ) } time . Sleep ( 2 * time . Second ) select { case < - timer : return nil , fmt . Errorf ( " " ) default : } } nodes Versions Match , err : = cluster . Ensure Schema ( db , address , dir ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } db . Set Max Open Conns ( 1 ) db . Set Max Idle Conns ( 1 ) if ! nodes Versions Match { cluster : = & Cluster { db : db , stmts : map [ int ] * sql . Stmt { } , } return cluster , Err Some Nodes Are Behind } stmts , err : = cluster . Prepare Stmts ( db ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } cluster : = & Cluster { db : db , stmts : stmts , } if err ! = nil { return errors . Wrap ( err , " " ) } if len ( nodes ) = = 1 & & nodes [ 0 ] . Address = = " " { return nil } for _ , node : = range nodes { if node . Address = = address { cluster . node ID = node . ID return nil } } return fmt . Errorf ( " " , address ) } ) if err ! = nil { return nil , err } return cluster , err } 
func For Local Inspection With Prepared Stmts ( db * sql . DB ) ( * Cluster , error ) { c : = For Local Inspection ( db ) stmts , err : = cluster . Prepare Stmts ( c . db ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } c . stmts = stmts return c , nil } 
func ( c * Cluster ) Set Default Timeout ( timeout time . Duration ) { driver : = c . db . Driver ( ) . ( * dqlite . Driver ) driver . Set Context Timeout ( timeout ) } 
func ( c * Cluster ) Transaction ( f func ( * Cluster Tx ) error ) error { c . mu . RLock ( ) defer c . mu . RUnlock ( ) return c . transaction ( f ) } 
func ( c * Cluster ) Enter Exclusive ( ) error { logger . Debug ( " " ) ch : = make ( chan struct { } ) go func ( ) { c . mu . Lock ( ) ch < - struct { } { } } ( ) timeout : = 2 0 * time . Second select { case < - ch : return nil case < - time . After ( timeout ) : return fmt . Errorf ( " " , timeout ) } } 
func ( c * Cluster ) Exit Exclusive ( f func ( * Cluster Tx ) error ) error { logger . Debug ( " " ) defer c . mu . Unlock ( ) return c . transaction ( f ) } 
func ( c * Cluster ) Close ( ) error { for _ , stmt : = range c . stmts { stmt . Close ( ) } return c . db . Close ( ) } 
func Tx Commit ( tx * sql . Tx ) error { err : = tx . Commit ( ) if err = = nil | | err = = sql . Err Tx Done { } return err } 
func query Scan ( db * sql . DB , q string , inargs [ ] interface { } , outfmt [ ] interface { } ) ( [ ] [ ] interface { } , error ) { return do Db Query Scan ( db , q , inargs , outfmt ) } 
func ( c * Config ) Parse Remote ( raw string ) ( string , string , error ) { result : = strings . Split N ( raw , " " , 2 ) if len ( result ) = = 1 { return c . Default Remote , raw , nil } _ , ok : = c . Remotes [ result [ 0 ] ] if ! ok { } return " " , " " , fmt . Errorf ( " \ " \ " " , result [ 0 ] ) } return result [ 0 ] , result [ 1 ] , nil } 
func ( c * Config ) Get Container Server ( name string ) ( lxd . Container Server , error ) { if ! ok { return nil , fmt . Errorf ( " \ " \ " " , name ) } } if err ! = nil { return nil , err } if err ! = nil { return nil , err } if remote . Project ! = " " & & remote . Project ! = " " { d = d . Use Project ( remote . Project ) } if c . Project Override ! = " " { d = d . Use Project ( c . Project Override ) } return d , nil } } d , err : = lxd . Connect LXD ( remote . Addr , args ) if err ! = nil { return nil , err } if remote . Project ! = " " & & remote . Project ! = " " { d = d . Use Project ( remote . Project ) } if c . Project Override ! = " " { d = d . Use Project ( c . Project Override ) } return d , nil } 
func ( c * Config ) Get Image Server ( name string ) ( lxd . Image Server , error ) { if ! ok { return nil , fmt . Errorf ( " \ " \ " " , name ) } if err ! = nil { return nil , err } if err ! = nil { return nil , err } if remote . Project ! = " " & & remote . Project ! = " " { d = d . Use Project ( remote . Project ) } if c . Project Override ! = " " { d = d . Use Project ( c . Project Override ) } return d , nil } if err ! = nil { return nil , err } return d , nil } if err ! = nil { return nil , err } return d , nil } if err ! = nil { return nil , err } if remote . Project ! = " " & & remote . Project ! = " " { d = d . Use Project ( remote . Project ) } if c . Project Override ! = " " { d = d . Use Project ( c . Project Override ) } return d , nil } 
func ( s * OS ) init App Armor ( ) { _ , err : = exec . Look Path ( " " ) if os . Getenv ( " " ) = = " " { logger . Warnf ( " " ) } else if ! shared . Is Dir ( " " ) { logger . Warnf ( " " ) } else if err ! = nil { logger . Warnf ( " " ) } else { s . App Armor Available = true } s . App Armor Stacking = app Armor Can Stack ( ) if shared . Path Exists ( " " ) { content Bytes , err : = ioutil . Read File ( " " ) if err = = nil & & string ( content Bytes ) = = " \n " { s . App Armor Stacked = true } } if ! have Mac Admin ( ) { if s . App Armor Available { logger . Warnf ( " " ) } } else if s . Running In User NS & & ! s . App Armor Stacked { if s . App Armor Available { logger . Warnf ( " " ) } } else { s . App Armor Admin = true } profile : = util . App Armor Profile ( ) if profile ! = " " & & profile ! = " " { if s . App Armor Available { logger . Warnf ( " " ) } s . App Armor Confined = true } } 
func app Armor Can Stack ( ) bool { content Bytes , err : = ioutil . Read File ( " " ) if err ! = nil { return false } if string ( content Bytes ) ! = " \n " { return false } content Bytes , err = ioutil . Read File ( " " ) if err ! = nil { return false } content : = string ( content Bytes ) parts : = strings . Split ( strings . Trim Space ( content ) , " " ) if len ( parts ) = = 0 { logger . Warn ( " " , log . Ctx { " " : content } ) return false } major , err : = strconv . Atoi ( parts [ 0 ] ) if err ! = nil { logger . Warn ( " " , log . Ctx { " " : content } ) return false } minor : = 0 if len ( parts ) = = 2 { minor , err = strconv . Atoi ( parts [ 1 ] ) if err ! = nil { logger . Warn ( " " , log . Ctx { " " : content } ) return false } } return major > = 1 & & minor > = 2 } 
func container Device Add ( client lxd . Container Server , name string , dev Name string , dev map [ string ] string ) error { if err ! = nil { return err } if ok { return fmt . Errorf ( i 1 8n . G ( " " ) , dev Name ) } container . Devices [ dev Name ] = dev op , err : = client . Update Container ( name , container . Writable ( ) , etag ) if err ! = nil { return err } return op . Wait ( ) } 
func profile Device Add ( client lxd . Container Server , name string , dev Name string , dev map [ string ] string ) error { if err ! = nil { return err } if ok { return fmt . Errorf ( i 1 8n . G ( " " ) , dev Name ) } err = client . Update Profile ( name , profile . Writable ( ) , profile Etag ) if err ! = nil { return err } return nil } 
func ensure Image Aliases ( client lxd . Container Server , aliases [ ] api . Image Alias , fingerprint string ) error { if len ( aliases ) = = 0 { return nil } names : = make ( [ ] string , len ( aliases ) ) for i , alias : = range aliases { names [ i ] = alias . Name } sort . Strings ( names ) resp , err : = client . Get Image Aliases ( ) if err ! = nil { return err } if err ! = nil { fmt . Println ( fmt . Sprintf ( i 1 8n . G ( " " ) , alias . Name ) ) } } alias Post . Name = alias . Name alias Post . Target = fingerprint err : = client . Create Image Alias ( alias Post ) if err ! = nil { fmt . Println ( fmt . Sprintf ( i 1 8n . G ( " " ) , alias . Name ) ) } } return nil } 
func Get Existing Aliases ( aliases [ ] string , all Aliases [ ] api . Image Aliases Entry ) [ ] api . Image Aliases Entry { existing : = [ ] api . Image Aliases Entry { } for _ , alias : = range all Aliases { name : = alias . Name pos : = sort . Search Strings ( aliases , name ) if pos < len ( aliases ) & & aliases [ pos ] = = name { existing = append ( existing , alias ) } } return existing } 
func ( o Status Code ) String ( ) string { return map [ Status Code ] string { Operation Created : " " , Started : " " , Stopped : " " , Running : " " , Cancelling : " " , Pending : " " , Success : " " , Failure : " " , Cancelled : " " , Starting : " " , Stopping : " " , Aborting : " " , Freezing : " " , Frozen : " " , Thawed : " " , Error : " " , } [ o ] } 
func ( c * Cluster ) Images Get ( project string , public bool ) ( [ ] string , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = ` SELECT fingerprint FROM images JOIN projects ON projects .id = images .project _id WHERE projects .name = ? ` if public = = true { q + = " " } var fp string inargs : = [ ] interface { } { project } outfmt : = [ ] interface { } { fp } db Results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } results : = [ ] string { } for _ , r : = range db Results { results = append ( results , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * Cluster ) Images Get Expired ( expiry int 6 4 ) ( [ ] string , error ) { q : = `SELECT fingerprint , last _use _date , upload _date FROM images WHERE cached = 1 ` var fp Str string var use Str string var upload Str string inargs : = [ ] interface { } { } outfmt : = [ ] interface { } { fp Str , use Str , upload Str } db Results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } results : = [ ] string { } for _ , r : = range db Results { if r [ 1 ] ! = " " { timestamp = r [ 1 ] } var image Expiry time . Time err = image Expiry . Unmarshal Text ( [ ] byte ( timestamp . ( string ) ) ) if err ! = nil { return [ ] string { } , err } image Expiry = image Expiry . Add ( time . Duration ( expiry * 2 4 ) * time . Hour ) } results = append ( results , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * Cluster ) Image Source Insert ( id int , server string , protocol string , certificate string , alias string ) error { stmt : = `INSERT INTO images _source (image _id , server , protocol , certificate , alias ) values ( ? , ? , ? , ? , ? ) ` protocol Int : = - 1 for proto Int , proto String : = range Image Source Protocol { if proto String = = protocol { protocol Int = proto Int } } if protocol Int = = - 1 { return fmt . Errorf ( " " , protocol ) } err : = exec ( c . db , stmt , id , server , protocol Int , certificate , alias ) return err } 
func ( c * Cluster ) Image Source Get ( image ID int ) ( int , api . Image Source , error ) { q : = `SELECT id , server , protocol , certificate , alias FROM images _source WHERE image _id = ? ` id : = 0 protocol Int : = - 1 result : = api . Image Source { } arg 1 : = [ ] interface { } { image ID } arg 2 : = [ ] interface { } { & id , & result . Server , & protocol Int , & result . Certificate , & result . Alias } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , api . Image Source { } , Err No Such Object } return - 1 , api . Image Source { } , err } protocol , found : = Image Source Protocol [ protocol Int ] if ! found { return - 1 , api . Image Source { } , fmt . Errorf ( " " , protocol Int ) } result . Protocol = protocol return id , result , nil } 
func ( c * Cluster ) Image Source Get Cached Fingerprint ( server string , protocol string , alias string ) ( string , error ) { protocol Int : = - 1 for proto Int , proto String : = range Image Source Protocol { if proto String = = protocol { protocol Int = proto Int } } if protocol Int = = - 1 { return " " , fmt . Errorf ( " " , protocol ) } q : = `SELECT images .fingerprint FROM images _source INNER JOIN images ON images _source .image _id =images .id WHERE server = ? AND protocol = ? AND alias = ? AND auto _update = 1 ORDER BY creation _date DESC ` fingerprint : = " " arg 1 : = [ ] interface { } { server , protocol Int , alias } arg 2 : = [ ] interface { } { & fingerprint } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { if err = = sql . Err No Rows { return " " , Err No Such Object } return " " , err } return fingerprint , nil } 
func ( c * Cluster ) Image Exists ( project string , fingerprint string ) ( bool , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return false , err } var exists bool query : = ` SELECT COUNT ( * ) > 0 FROM images JOIN projects ON projects .id = images .project _id WHERE projects .name = ? AND fingerprint = ? ` inargs : = [ ] interface { } { project , fingerprint } outargs : = [ ] interface { } { & exists } err = db Query Row Scan ( c . db , query , inargs , outargs ) if err = = sql . Err No Rows { return exists , Err No Such Object } return exists , err } 
func ( c * Cluster ) Image Get ( project , fingerprint string , public bool , strict Matching bool ) ( int , * api . Image , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return - 1 , nil , err } var create , expire , used , upload * time . Time id : = - 1 arch : = - 1 inargs : = [ ] interface { } { project } query : = ` SELECT images .id , fingerprint , filename , size , cached , public , auto _update , architecture , creation _date , expiry _date , last _use _date , upload _date FROM images JOIN projects ON projects .id = images .project _id WHERE projects .name = ? ` if strict Matching { inargs = append ( inargs , fingerprint ) query + = " " } else { inargs = append ( inargs , fingerprint + " " ) query + = " " } if public { query + = " " } err = db Query Row Scan ( c . db , query , inargs , outfmt ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , nil , Err No Such Object } return - 1 , nil , err } SELECT COUNT (images .id ) FROM images JOIN projects ON projects .id = images .project _id WHERE projects .name = ? AND fingerprint LIKE ? ` count : = 0 outfmt : = [ ] interface { } { & count } err = db Query Row Scan ( c . db , query , inargs , outfmt ) if err ! = nil { return - 1 , nil , err } if count > 1 { return - 1 , nil , fmt . Errorf ( " " ) } } err = c . image Fill ( id , & image , create , expire , used , upload , arch ) if err ! = nil { return - 1 , nil , errors . Wrapf ( err , " " ) } return id , & image , nil } 
func ( c * Cluster ) Image Get From Any Project ( fingerprint string ) ( int , * api . Image , error ) { var create , expire , used , upload * time . Time id : = - 1 arch : = - 1 inargs : = [ ] interface { } { fingerprint } query : = ` SELECT images .id , fingerprint , filename , size , cached , public , auto _update , architecture , creation _date , expiry _date , last _use _date , upload _date FROM images WHERE fingerprint = ? LIMIT 1 ` err : = db Query Row Scan ( c . db , query , inargs , outfmt ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , nil , Err No Such Object } return - 1 , nil , err } err = c . image Fill ( id , & image , create , expire , used , upload , arch ) if err ! = nil { return - 1 , nil , errors . Wrapf ( err , " " ) } return id , & image , nil } 
func ( c * Cluster ) image Fill ( id int , image * api . Image , create , expire , used , upload * time . Time , arch int ) error { } else { image . Created At = time . Time { } } if expire ! = nil { image . Expires At = * expire } else { image . Expires At = time . Time { } } if used ! = nil { image . Last Used At = * used } else { image . Last Used At = time . Time { } } image . Architecture , _ = osarch . Architecture Name ( arch ) var key , value , name , desc string inargs : = [ ] interface { } { id } outfmt : = [ ] interface { } { key , value } results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return err } properties : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) properties [ key ] = value } image . Properties = properties inargs = [ ] interface { } { id } outfmt = [ ] interface { } { name , desc } results , err = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return err } aliases : = [ ] api . Image Alias { } for _ , r : = range results { name = r [ 0 ] . ( string ) desc = r [ 1 ] . ( string ) a : = api . Image Alias { Name : name , Description : desc } aliases = append ( aliases , a ) } image . Aliases = aliases _ , source , err : = c . Image Source Get ( id ) if err = = nil { image . Update Source = & source } return nil } 
func ( c * Cluster ) Image Locate ( fingerprint string ) ( string , error ) { stmt : = ` SELECT nodes .address FROM nodes LEFT JOIN images _nodes ON images _nodes .node _id = nodes .id LEFT JOIN images ON images _nodes .image _id = images .id WHERE images .fingerprint = ? ` var local Address string var addresses [ ] string err : = c . Transaction ( func ( tx * Cluster Tx ) error { offline Threshold , err : = tx . Node Offline Threshold ( ) if err ! = nil { return err } local Address , err = tx . Node Address ( ) if err ! = nil { return err } all Addresses , err : = query . Select Strings ( tx . tx , stmt , fingerprint ) if err ! = nil { return err } for _ , address : = range all Addresses { node , err : = tx . Node By Address ( address ) if err ! = nil { return err } if address ! = local Address & & node . Is Offline ( offline Threshold ) { continue } addresses = append ( addresses , address ) } return err } ) if err ! = nil { return " " , err } if len ( addresses ) = = 0 { return " " , fmt . Errorf ( " " ) } for _ , address : = range addresses { if address = = local Address { return " " , nil } } return addresses [ 0 ] , nil } 
func ( c * Cluster ) Image Associate Node ( project , fingerprint string ) error { image ID , _ , err : = c . Image Get ( project , fingerprint , false , true ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { _ , err : = tx . tx . Exec ( " " , image ID , c . node ID ) return err } ) return err } 
func ( c * Cluster ) Image Delete ( id int ) error { err : = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Image Aliases Get ( project string ) ( [ ] string , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = ` SELECT images _aliases .name FROM images _aliases JOIN projects ON projects .id =images _aliases .project _id WHERE projects .name = ? ` var name string inargs : = [ ] interface { } { project } outfmt : = [ ] interface { } { name } results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } names : = [ ] string { } for _ , res : = range results { names = append ( names , res [ 0 ] . ( string ) ) } return names , nil } 
func ( c * Cluster ) Image Alias Get ( project , name string , is Trusted Client bool ) ( int , api . Image Aliases Entry , error ) { id : = - 1 entry : = api . Image Aliases Entry { } err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return id , entry , err } q : = `SELECT images _aliases .id , images .fingerprint , images _aliases .description FROM images _aliases INNER JOIN images ON images _aliases .image _id =images .id INNER JOIN projects ON images _aliases .project _id =projects .id WHERE projects .name = ? AND images _aliases .name = ? ` if ! is Trusted Client { q = q + ` AND images .public = 1 ` } var fingerprint , description string arg 1 : = [ ] interface { } { project , name } arg 2 : = [ ] interface { } { & id , & fingerprint , & description } err = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , entry , Err No Such Object } return - 1 , entry , err } entry . Name = name entry . Target = fingerprint entry . Description = description return id , entry , nil } 
func ( c * Cluster ) Image Alias Rename ( id int , name string ) error { err : = exec ( c . db , " " , name , id ) return err } 
func ( c * Cluster ) Image Alias Delete ( project , name string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return err } err = exec ( c . db , ` DELETE FROM images _aliases WHERE project _id = (SELECT id FROM projects WHERE name = ? ) AND name = ? ` , project , name ) return err } 
func ( c * Cluster ) Image Aliases Move ( source int , destination int ) error { err : = exec ( c . db , " " , destination , source ) return err } 
func ( c * Cluster ) Image Alias Add ( project , name string , image ID int , desc string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return err } stmt : = ` INSERT INTO images _aliases (name , image _id , description , project _id ) VALUES ( ? , ? , ? , (SELECT id FROM projects WHERE name = ? ) ) ` err = exec ( c . db , stmt , name , image ID , desc , project ) return err } 
func ( c * Cluster ) Image Alias Update ( id int , image ID int , desc string ) error { stmt : = `UPDATE images _aliases SET image _id = ? , description = ? WHERE id = ? ` err : = exec ( c . db , stmt , image ID , desc , id ) return err } 
func ( c * Cluster ) Image Last Access Update ( fingerprint string , date time . Time ) error { stmt : = `UPDATE images SET last _use _date = ? WHERE fingerprint = ? ` err : = exec ( c . db , stmt , date , fingerprint ) return err } 
func ( c * Cluster ) Image Last Access Init ( fingerprint string ) error { stmt : = `UPDATE images SET cached = 1 , last _use _date =strftime ( " %s " ) WHERE fingerprint = ? ` err : = exec ( c . db , stmt , fingerprint ) return err } 
func ( c * Cluster ) Image Update ( id int , fname string , sz int 6 4 , public bool , auto Update bool , architecture string , created At time . Time , expires At time . Time , properties map [ string ] string ) error { arch , err : = osarch . Architecture Id ( architecture ) if err ! = nil { arch = 0 } err = c . Transaction ( func ( tx * Cluster Tx ) error { public Int : = 0 if public { public Int = 1 } auto Update Int : = 0 if auto Update { auto Update Int = 1 } stmt , err : = tx . tx . Prepare ( `UPDATE images SET filename = ? , size = ? , public = ? , auto _update = ? , architecture = ? , creation _date = ? , expiry _date = ? WHERE id = ? ` ) if err ! = nil { return err } defer stmt . Close ( ) _ , err = stmt . Exec ( fname , sz , public Int , auto Update Int , arch , created At , expires At , id ) if err ! = nil { return err } _ , err = tx . tx . Exec ( `DELETE FROM images _properties WHERE image _id = ? ` , id ) if err ! = nil { return err } stmt 2 , err : = tx . tx . Prepare ( `INSERT INTO images _properties (image _id , type , key , value ) VALUES ( ? , ? , ? , ? ) ` ) if err ! = nil { return err } defer stmt 2 . Close ( ) for key , value : = range properties { _ , err = stmt 2 . Exec ( id , 0 , key , value ) if err ! = nil { return err } } return nil } ) return err } 
func ( c * Cluster ) Image Insert ( project , fp string , fname string , sz int 6 4 , public bool , auto Update bool , architecture string , created At time . Time , expires At time . Time , properties map [ string ] string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Images ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return err } arch , err : = osarch . Architecture Id ( architecture ) if err ! = nil { arch = 0 } err = c . Transaction ( func ( tx * Cluster Tx ) error { public Int : = 0 if public { public Int = 1 } auto Update Int : = 0 if auto Update { auto Update Int = 1 } stmt , err : = tx . tx . Prepare ( `INSERT INTO images (project _id , fingerprint , filename , size , public , auto _update , architecture , creation _date , expiry _date , upload _date ) VALUES ( (SELECT id FROM projects WHERE name = ? ) , ? , ? , ? , ? , ? , ? , ? , ? , ? ) ` ) if err ! = nil { return err } defer stmt . Close ( ) result , err : = stmt . Exec ( project , fp , fname , sz , public Int , auto Update Int , arch , created At , expires At , time . Now ( ) . UTC ( ) ) if err ! = nil { return err } id 6 4 , err : = result . Last Insert Id ( ) if err ! = nil { return err } id : = int ( id 6 4 ) if len ( properties ) > 0 { pstmt , err : = tx . tx . Prepare ( `INSERT INTO images _properties (image _id , type , key , value ) VALUES ( ? , 0 , ? , ? ) ` ) if err ! = nil { return err } defer pstmt . Close ( ) for k , v : = range properties { if err ! = nil { return err } } } _ , err = tx . tx . Exec ( " " , id , c . node ID ) if err ! = nil { return err } return nil } ) return err } 
func ( c * Cluster ) Image Get Pools ( image Fingerprint string ) ( [ ] int 6 4 , error ) { pool ID : = int 6 4 ( - 1 ) query : = " " inargs : = [ ] interface { } { c . node ID , image Fingerprint , Storage Pool Volume Type Image } outargs : = [ ] interface { } { pool ID } result , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] int 6 4 { } , err } pool IDs : = [ ] int 6 4 { } for _ , r : = range result { pool IDs = append ( pool IDs , r [ 0 ] . ( int 6 4 ) ) } return pool IDs , nil } 
func ( c * Cluster ) Image Get Pool Names From IDs ( pool IDs [ ] int 6 4 ) ( [ ] string , error ) { var pool Name string query : = " " pool Names : = [ ] string { } for _ , pool ID : = range pool IDs { inargs : = [ ] interface { } { pool ID } outargs : = [ ] interface { } { pool Name } result , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } for _ , r : = range result { pool Names = append ( pool Names , r [ 0 ] . ( string ) ) } } return pool Names , nil } 
func ( c * Cluster ) Image Uploaded At ( id int , uploaded At time . Time ) error { err : = exec ( c . db , " " , uploaded At , id ) return err } 
func ( c * Cluster ) Images Get On Current Node ( ) ( map [ string ] [ ] string , error ) { return c . Images Get By Node ID ( c . node ID ) } 
func ( c * Cluster ) Images Get By Node ID ( id int 6 4 ) ( map [ string ] [ ] string , error ) { images : = make ( map [ string ] [ ] string ) err : = c . Transaction ( func ( tx * Cluster Tx ) error { stmt : = ` SELECT images .fingerprint , projects .name FROM images LEFT JOIN images _nodes ON images .id = images _nodes .image _id LEFT JOIN nodes ON images _nodes .node _id = nodes .id LEFT JOIN projects ON images .project _id = projects .id WHERE nodes .id = ? ` rows , err : = tx . tx . Query ( stmt , id ) if err ! = nil { return err } var fingerprint string var project Name string for rows . Next ( ) { err : = rows . Scan ( & fingerprint , & project Name ) if err ! = nil { return err } images [ fingerprint ] = append ( images [ fingerprint ] , project Name ) } return rows . Err ( ) } ) return images , err } 
func ( c * Cluster ) Image Get Nodes With Image ( fingerprint string ) ( [ ] string , error ) { q : = ` SELECT DISTINCT nodes .address FROM nodes LEFT JOIN images _nodes ON images _nodes .node _id = nodes .id LEFT JOIN images ON images _nodes .image _id = images .id WHERE images .fingerprint = ? ` return c . get Nodes By Image Fingerprint ( q , fingerprint ) } 
func ( c * Cluster ) Image Get Nodes Without Image ( fingerprint string ) ( [ ] string , error ) { q : = ` SELECT DISTINCT nodes .address FROM nodes WHERE nodes .address NOT IN ( SELECT DISTINCT nodes .address FROM nodes LEFT JOIN images _nodes ON images _nodes .node _id = nodes .id LEFT JOIN images ON images _nodes .image _id = images .id WHERE images .fingerprint = ? ) ` return c . get Nodes By Image Fingerprint ( q , fingerprint ) } 
func ( g * Group ) Add ( f Func , schedule Schedule ) * Task { i : = len ( g . tasks ) g . tasks = append ( g . tasks , Task { f : f , schedule : schedule , reset : make ( chan struct { } , 1 6 ) , return & g . tasks [ i ] } 
func ( g * Group ) Start ( ) { ctx : = context . Background ( ) ctx , g . cancel = context . With Cancel ( ctx ) g . wg . Add ( len ( g . tasks ) ) g . mu . Lock ( ) if g . running = = nil { g . running = make ( map [ int ] bool ) } g . mu . Unlock ( ) for i : = range g . tasks { g . mu . Lock ( ) if g . running [ i ] { g . mu . Unlock ( ) continue } g . running [ i ] = true task : = g . tasks [ i ] g . mu . Unlock ( ) go func ( i int ) { task . loop ( ctx ) g . wg . Done ( ) g . mu . Lock ( ) g . running [ i ] = false g . mu . Unlock ( ) } ( i ) } } 
func ( g * Group ) Stop ( timeout time . Duration ) error { if g . cancel = = nil { } g . cancel ( ) graceful : = make ( chan struct { } , 1 ) go func ( ) { g . wg . Wait ( ) close ( graceful ) } ( ) defer cancel ( ) select { case < - ctx . Done ( ) : running : = [ ] string { } for i , value : = range g . running { if value { running = append ( running , strconv . Itoa ( i ) ) } } return fmt . Errorf ( " " , strings . Join ( running , " " ) ) case < - graceful : return nil } } 
func zfs Is Enabled ( ) bool { out , err : = exec . Look Path ( " " ) if err ! = nil | | len ( out ) = = 0 { return false } return true } 
func zfs Tool Version Get ( ) ( string , error ) { if err ! = nil { return " " , err } return strings . Trim Space ( string ( out ) ) , nil } 
func zfs Module Version Get ( ) ( string , error ) { var zfs Version string if shared . Path Exists ( " " ) { out , err : = ioutil . Read File ( " " ) if err ! = nil { return " " , fmt . Errorf ( " " ) } zfs Version = string ( out ) } else { out , err : = shared . Run Command ( " " , " " , " " , " " ) if err ! = nil { return " " , fmt . Errorf ( " " ) } zfs Version = out } return strings . Trim Space ( zfs Version ) , nil } 
func zfs Pool Volume Create ( dataset string , properties . . . string ) ( string , error ) { cmd : = [ ] string { " " , " " } for _ , prop : = range properties { cmd = append ( cmd , [ ] string { " " , prop } . . . ) } cmd = append ( cmd , [ ] string { " " , dataset } . . . ) return shared . Run Command ( cmd [ 0 ] , cmd [ 1 : ] . . . ) } 
func zfs Pool Volume Exists ( dataset string ) ( bool , error ) { output , err : = shared . Run Command ( " " , " " , " " , " " ) if err ! = nil { return false , err } for _ , name : = range strings . Split ( output , " \n " ) { if name = = dataset { return true , nil } } return false , nil } 
func ( c * Cluster Tx ) Network IDs Not Pending ( ) ( map [ string ] int 6 4 , error ) { networks : = [ ] struct { id int 6 4 name string } { } dest : = func ( i int ) [ ] interface { } { networks = append ( networks , struct { id int 6 4 name string } { } ) return [ ] interface { } { & networks [ i ] . id , & networks [ i ] . name } } stmt , err : = c . tx . Prepare ( " " ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , network Pending ) if err ! = nil { return nil , err } ids : = map [ string ] int 6 4 { } for _ , network : = range networks { ids [ network . name ] = network . id } return ids , nil } 
func ( c * Cluster Tx ) Network Config Add ( network ID , node ID int 6 4 , config map [ string ] string ) error { return network Config Add ( c . tx , network ID , node ID , config ) } 
func ( c * Cluster Tx ) Network Node Join ( network ID , node ID int 6 4 ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { network ID , node ID } _ , err : = query . Upsert Object ( c . tx , " " , columns , values ) return err } 
func ( c * Cluster Tx ) Network Create Pending ( node , name string , conf map [ string ] string ) error { state int } { } var err Consistency error dest : = func ( i int ) [ ] interface { } { } return [ ] interface { } { & network . id , & network . state } } stmt , err : = c . tx . Prepare ( " " ) if err ! = nil { return err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , name ) if err ! = nil { return err } if err Consistency ! = nil { return err Consistency } var network ID = network . id if network ID = = 0 { values : = [ ] interface { } { name } network ID , err = query . Upsert Object ( c . tx , " " , columns , values ) if err ! = nil { return err } } else { } } if err ! = nil { return err } if err ! = nil { return err } if count ! = 0 { return Err Already Defined } values : = [ ] interface { } { network ID , node Info . ID } _ , err = query . Upsert Object ( c . tx , " " , columns , values ) if err ! = nil { return err } err = c . Network Config Add ( network ID , node Info . ID , conf ) if err ! = nil { return err } return nil } 
func ( c * Cluster Tx ) Network Created ( name string ) error { return c . network State ( name , network Created ) } 
func ( c * Cluster Tx ) Network Errored ( name string ) error { return c . network State ( name , network Errored ) } 
func ( c * Cluster ) networks ( where string , args . . . interface { } ) ( [ ] string , error ) { q : = " " inargs : = [ ] interface { } { } if where ! = " " { q + = fmt . Sprintf ( " " , where ) for _ , arg : = range args { inargs = append ( inargs , arg ) } } var name string outfmt : = [ ] interface { } { name } result , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for _ , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * Cluster ) Network Get ( name string ) ( int 6 4 , * api . Network , error ) { description : = sql . Null String { } id : = int 6 4 ( - 1 ) state : = 0 q : = " " arg 1 : = [ ] interface { } { name } arg 2 : = [ ] interface { } { & id , & description , & state } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , nil , Err No Such Object } return - 1 , nil , err } config , err : = c . Network Config Get ( id ) if err ! = nil { return - 1 , nil , err } network : = api . Network { Name : name , Managed : true , Type : " " , } network . Description = description . String network . Config = config switch state { case network Pending : network . Status = " " case network Created : network . Status = " " default : network . Status = " " } nodes , err : = c . network Nodes ( id ) if err ! = nil { return - 1 , nil , err } network . Locations = nodes return id , & network , nil } 
func ( c * Cluster ) network Nodes ( network ID int 6 4 ) ( [ ] string , error ) { stmt : = ` SELECT nodes .name FROM nodes JOIN networks _nodes ON networks _nodes .node _id = nodes .id WHERE networks _nodes .network _id = ? ` var nodes [ ] string err : = c . Transaction ( func ( tx * Cluster Tx ) error { var err error nodes , err = query . Select Strings ( tx . tx , stmt , network ID ) return err } ) if err ! = nil { return nil , err } return nodes , nil } 
func ( c * Cluster ) Network Get Interface ( dev Name string ) ( int 6 4 , * api . Network , error ) { id : = int 6 4 ( - 1 ) name : = " " value : = " " q : = " \ " \ " " arg 1 : = [ ] interface { } { c . node ID } arg 2 : = [ ] interface { } { id , name , value } result , err : = query Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { return - 1 , nil , err } for _ , r : = range result { for _ , entry : = range strings . Split ( r [ 2 ] . ( string ) , " " ) { entry = strings . Trim Space ( entry ) if entry = = dev Name { id = r [ 0 ] . ( int 6 4 ) name = r [ 1 ] . ( string ) } } } if id = = - 1 { return - 1 , nil , fmt . Errorf ( " " , dev Name ) } config , err : = c . Network Config Get ( id ) if err ! = nil { return - 1 , nil , err } network : = api . Network { Name : name , Managed : true , Type : " " , } network . Config = config return id , & network , nil } 
func ( c * Cluster ) Network Config Get ( id int 6 4 ) ( map [ string ] string , error ) { var key , value string query : = ` SELECT key , value FROM networks _config WHERE network _id = ? AND (node _id = ? OR node _id IS NULL ) ` inargs : = [ ] interface { } { id , c . node ID } outfmt : = [ ] interface { } { key , value } results , err : = query Scan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , fmt . Errorf ( " " , id ) } if len ( results ) = = 0 { query : = " " var r int results , err : = query Scan ( c . db , query , [ ] interface { } { id } , [ ] interface { } { r } ) if err ! = nil { return nil , err } if len ( results ) = = 0 { return nil , Err No Such Object } } config : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * Cluster ) Network Create ( name , description string , config map [ string ] string ) ( int 6 4 , error ) { var id int 6 4 err : = c . Transaction ( func ( tx * Cluster Tx ) error { result , err : = tx . tx . Exec ( " " , name , description , network Created ) if err ! = nil { return err } id , err : = result . Last Insert Id ( ) if err ! = nil { return err } values : = [ ] interface { } { id , c . node ID } _ , err = query . Upsert Object ( tx . tx , " " , columns , values ) if err ! = nil { return err } err = network Config Add ( tx . tx , id , c . node ID , config ) if err ! = nil { return err } return nil } ) if err ! = nil { id = - 1 } return id , err } 
func ( c * Cluster ) Network Update ( name , description string , config map [ string ] string ) error { id , _ , err : = c . Network Get ( name ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { err = Network Update Description ( tx . tx , id , description ) if err ! = nil { return err } err = Network Config Clear ( tx . tx , id , c . node ID ) if err ! = nil { return err } err = network Config Add ( tx . tx , id , c . node ID , config ) if err ! = nil { return err } return nil } ) return err } 
func Network Update Description ( tx * sql . Tx , id int 6 4 , description string ) error { _ , err : = tx . Exec ( " " , description , id ) return err } 
func Network Config Clear ( tx * sql . Tx , network ID , node ID int 6 4 ) error { _ , err : = tx . Exec ( " " , network ID , node ID ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Network Delete ( name string ) error { id , _ , err : = c . Network Get ( name ) if err ! = nil { return err } err = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Network Rename ( old Name string , new Name string ) error { id , _ , err : = c . Network Get ( old Name ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { _ , err = tx . tx . Exec ( " " , new Name , id ) return err } ) return err } 
func ( r * Protocol LXD ) Get Containers ( ) ( [ ] api . Container , error ) { containers : = [ ] api . Container { } if err ! = nil { return nil , err } return containers , nil } 
func ( r * Protocol LXD ) Get Containers Full ( ) ( [ ] api . Container Full , error ) { containers : = [ ] api . Container Full { } if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return containers , nil } 
func ( r * Protocol LXD ) Get Container ( name string ) ( * api . Container , string , error ) { container : = api . Container { } if err ! = nil { return nil , " " , err } return & container , etag , nil } 
func ( r * Protocol LXD ) Create Container From Backup ( args Container Backup Args ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if args . Pool Name = = " " { if err ! = nil { return nil , err } return op , nil } if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } req , err : = http . New Request ( " " , req URL , args . Backup File ) if err ! = nil { return nil , err } req . Header . Set ( " " , " " ) req . Header . Set ( " " , args . Pool Name ) } if err ! = nil { return nil , err } defer resp . Body . Close ( ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } return & op , nil } 
func ( r * Protocol LXD ) Create Container ( container api . Containers Post ) ( Operation , error ) { if container . Source . Container Only { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Create Container From Image ( source Image Server , image api . Image , req api . Containers Post ) ( Remote Operation , error ) { req . Source . Alias = " " op , err : = r . Create Container ( req ) if err ! = nil { return nil , err } rop : = remote Operation { target Op : op , ch Done : make ( chan bool ) , } close ( rop . ch Done ) } ( ) return & rop , nil } } else { req . Source . Fingerprint = image . Fingerprint req . Source . Alias = " " } if err ! = nil { return nil , err } req . Source . Protocol = info . Protocol req . Source . Certificate = info . Certificate if err ! = nil { return nil , err } req . Source . Secret = secret } return r . try Create Container ( req , info . Addresses ) } 
func ( r * Protocol LXD ) Copy Container ( source Container Server , container api . Container , args * Container Copy Args ) ( Remote Operation , error ) { req . Source . Base Image = container . Config [ " " ] } if ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if shared . String In Slice ( args . Mode , [ ] string { " " , " " } ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if args . Mode = = " " & & ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if args . Refresh { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } } req . Source . Live = args . Live req . Source . Container Only = args . Container Only req . Source . Refresh = args . Refresh } if req . Source . Live { req . Source . Live = container . Status Code = = api . Running } source Info , err : = source . Get Connection Info ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } dest Info , err : = r . Get Connection Info ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } req . Source . Project = source Info . Project } req . Source . Source = container . Name if err ! = nil { return nil , err } rop : = remote Operation { target Op : op , ch Done : make ( chan bool ) , } close ( rop . ch Done ) } ( ) return & rop , nil } if err ! = nil { return nil , err } req . Source . Mode = " " req . Source . Refresh = args . Refresh op , err : = r . Create Container ( req ) if err ! = nil { return nil , err } op API : = op . Get ( ) target Secrets : = map [ string ] string { } for k , v : = range op API . Metadata { target Secrets [ k ] = v . ( string ) } target . Operation = op API . ID target . Websockets = target Secrets target . Certificate = info . Certificate source Req . Target = & target return r . try Migrate Container ( source , container . Name , source Req , info . Addresses ) } if err ! = nil { return nil , err } op , err : = source . Migrate Container ( container . Name , source Req ) if err ! = nil { return nil , err } op API : = op . Get ( ) source Secrets : = map [ string ] string { } for k , v : = range op API . Metadata { source Secrets [ k ] = v . ( string ) } req . Source . Mode = " " if err ! = nil { return nil , err } target Op API : = target Op . Get ( ) for k , v : = range target Op API . Metadata { target Secrets [ k ] = v . ( string ) } if err ! = nil { return nil , err } close ( rop . ch Done ) } ( ) return & rop , nil } req . Source . Mode = " " req . Source . Operation = op API . ID req . Source . Websockets = source Secrets req . Source . Certificate = info . Certificate return r . try Create Container ( req , info . Addresses ) } 
func ( r * Protocol LXD ) Update Container ( name string , container api . Container Put , ETag string ) ( Operation , error ) { if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Rename Container ( name string , container api . Container Post ) ( Operation , error ) { } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Exec Container ( container Name string , exec api . Container Exec Post , args * Container Exec Args ) ( Operation , error ) { if exec . Record Output { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if err ! = nil { return nil , err } op API : = op . Get ( ) value , ok : = op API . Metadata [ " " ] if ok { values : = value . ( map [ string ] interface { } ) for k , v : = range values { fds [ k ] = v . ( string ) } } if err ! = nil { return nil , err } go args . Control ( conn ) } if exec . Interactive { if err ! = nil { return nil , err } < - shared . Websocket Recv Stream ( args . Stdout , conn ) conn . Close ( ) if args . Data Done ! = nil { close ( args . Data Done ) } } ( ) } else { if args . Data Done ! = nil { close ( args . Data Done ) } } } else { conns : = [ ] * websocket . Conn { } if err ! = nil { return nil , err } conns = append ( conns , conn ) dones [ 0 ] = shared . Websocket Send Stream ( conn , args . Stdin , - 1 ) } if err ! = nil { return nil , err } conns = append ( conns , conn ) dones [ 1 ] = shared . Websocket Recv Stream ( args . Stdout , conn ) } if err ! = nil { return nil , err } conns = append ( conns , conn ) dones [ 2 ] = shared . Websocket Recv Stream ( args . Stderr , conn ) } } < - ch Done } if fds [ " " ] ! = " " { if args . Stdin ! = nil { args . Stdin . Close ( ) } } ( ) } for _ , conn : = range conns { conn . Close ( ) } if args . Data Done ! = nil { close ( args . Data Done ) } } ( ) } } return op , nil } 
func ( r * Protocol LXD ) Get Container File ( container Name string , path string ) ( io . Read Closer , * Container File Response , error ) { if err ! = nil { return nil , nil , err } request URL , err = r . set Query Attributes ( request URL ) if err ! = nil { return nil , nil , err } req , err : = http . New Request ( " " , request URL , nil ) if err ! = nil { return nil , nil , err } } if err ! = nil { return nil , nil , err } if err ! = nil { return nil , nil , err } } file Resp : = Container File Response { UID : uid , GID : gid , Mode : mode , Type : file Type , } if file Resp . Type = = " " { decoder : = json . New Decoder ( resp . Body ) err = decoder . Decode ( & response ) if err ! = nil { return nil , nil , err } err = response . Metadata As Struct ( & entries ) if err ! = nil { return nil , nil , err } file Resp . Entries = entries return nil , & file Resp , err } return resp . Body , & file Resp , err } 
func ( r * Protocol LXD ) Create Container File ( container Name string , path string , args Container File Args ) error { if args . Type = = " " { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } } if args . Type = = " " { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } } if args . Write Mode = = " " { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } } request URL , err : = r . set Query Attributes ( request URL ) if err ! = nil { return err } req , err : = http . New Request ( " " , request URL , args . Content ) if err ! = nil { return err } } } if args . GID > - 1 { req . Header . Set ( " " , fmt . Sprintf ( " " , args . GID ) ) } if args . Mode > - 1 { req . Header . Set ( " " , fmt . Sprintf ( " " , args . Mode ) ) } if args . Type ! = " " { req . Header . Set ( " " , args . Type ) } if args . Write Mode ! = " " { req . Header . Set ( " " , args . Write Mode ) } if err ! = nil { return err } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Container File ( container Name string , path string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Get Container Snapshot Names ( container Name string ) ( [ ] string , error ) { urls : = [ ] string { } if err ! = nil { return nil , err } for _ , uri : = range urls { fields : = strings . Split ( uri , fmt . Sprintf ( " " , url . Query Escape ( container Name ) ) ) names = append ( names , fields [ len ( fields ) - 1 ] ) } return names , nil } 
func ( r * Protocol LXD ) Get Container Snapshots ( container Name string ) ( [ ] api . Container Snapshot , error ) { snapshots : = [ ] api . Container Snapshot { } if err ! = nil { return nil , err } return snapshots , nil } 
func ( r * Protocol LXD ) Get Container Snapshot ( container Name string , name string ) ( * api . Container Snapshot , string , error ) { snapshot : = api . Container Snapshot { } if err ! = nil { return nil , " " , err } return & snapshot , etag , nil } 
func ( r * Protocol LXD ) Create Container Snapshot ( container Name string , snapshot api . Container Snapshots Post ) ( Operation , error ) { } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Copy Container Snapshot ( source Container Server , container Name string , snapshot api . Container Snapshot , args * Container Snapshot Copy Args ) ( Remote Operation , error ) { c Name : = container Name s Name : = fields [ len ( fields ) - 1 ] if snapshot . Stateful & & args . Live { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } req . Container Put . Stateful = snapshot . Stateful req . Source . Live = args . Live } req . Source . Base Image = snapshot . Config [ " " ] } if ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if args . Mode = = " " & & ! source . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } } source Info , err : = source . Get Connection Info ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } dest Info , err : = r . Get Connection Info ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } container , _ , err : = source . Get Container ( c Name ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } req . Source . Project = source Info . Project } req . Source . Source = fmt . Sprintf ( " " , c Name , s Name ) if err ! = nil { return nil , err } rop : = remote Operation { target Op : op , ch Done : make ( chan bool ) , } close ( rop . ch Done ) } ( ) return & rop , nil } if snapshot . Stateful & & args . Live { source Req . Live = args . Live } if err ! = nil { return nil , err } req . Source . Mode = " " op , err : = r . Create Container ( req ) if err ! = nil { return nil , err } op API : = op . Get ( ) target Secrets : = map [ string ] string { } for k , v : = range op API . Metadata { target Secrets [ k ] = v . ( string ) } target . Operation = op API . ID target . Websockets = target Secrets target . Certificate = info . Certificate source Req . Target = & target return r . try Migrate Container Snapshot ( source , c Name , s Name , source Req , info . Addresses ) } if err ! = nil { return nil , err } op , err : = source . Migrate Container Snapshot ( c Name , s Name , source Req ) if err ! = nil { return nil , err } op API : = op . Get ( ) source Secrets : = map [ string ] string { } for k , v : = range op API . Metadata { source Secrets [ k ] = v . ( string ) } req . Source . Mode = " " if err ! = nil { return nil , err } target Op API : = target Op . Get ( ) for k , v : = range target Op API . Metadata { target Secrets [ k ] = v . ( string ) } if err ! = nil { return nil , err } close ( rop . ch Done ) } ( ) return & rop , nil } req . Source . Mode = " " req . Source . Operation = op API . ID req . Source . Websockets = source Secrets req . Source . Certificate = info . Certificate return r . try Create Container ( req , info . Addresses ) } 
func ( r * Protocol LXD ) Migrate Container Snapshot ( container Name string , name string , container api . Container Snapshot Post ) ( Operation , error ) { } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Update Container Snapshot ( container Name string , name string , container api . Container Snapshot Put , ETag string ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Get Container State ( name string ) ( * api . Container State , string , error ) { state : = api . Container State { } if err ! = nil { return nil , " " , err } return & state , etag , nil } 
func ( r * Protocol LXD ) Update Container State ( name string , state api . Container State Put , ETag string ) ( Operation , error ) { if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Get Container Logfiles ( name string ) ( [ ] string , error ) { urls : = [ ] string { } if err ! = nil { return nil , err } for _ , uri : = range logfiles { fields : = strings . Split ( uri , fmt . Sprintf ( " " , url . Query Escape ( name ) ) ) logfiles = append ( logfiles , fields [ len ( fields ) - 1 ] ) } return logfiles , nil } 
func ( r * Protocol LXD ) Get Container Logfile ( name string , filename string ) ( io . Read Closer , error ) { url , err : = r . set Query Attributes ( url ) if err ! = nil { return nil , err } req , err : = http . New Request ( " " , url , nil ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } if err ! = nil { return nil , err } } return resp . Body , err } 
func ( r * Protocol LXD ) Get Container Metadata ( name string ) ( * api . Image Metadata , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } metadata : = api . Image Metadata { } url : = fmt . Sprintf ( " " , url . Query Escape ( name ) ) etag , err : = r . query Struct ( " " , url , nil , " " , & metadata ) if err ! = nil { return nil , " " , err } return & metadata , etag , err } 
func ( r * Protocol LXD ) Set Container Metadata ( name string , metadata api . Image Metadata , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } url : = fmt . Sprintf ( " " , url . Query Escape ( name ) ) _ , _ , err : = r . query ( " " , url , metadata , ETag ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Get Container Template Files ( container Name string ) ( [ ] string , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } templates : = [ ] string { } url : = fmt . Sprintf ( " " , url . Query Escape ( container Name ) ) _ , err : = r . query Struct ( " " , url , nil , " " , & templates ) if err ! = nil { return nil , err } return templates , nil } 
func ( r * Protocol LXD ) Create Container Template File ( container Name string , template Name string , content io . Read Seeker ) error { return r . set Container Template File ( container Name , template Name , content , " " ) } 
func ( r * Protocol LXD ) Delete Container Template File ( name string , template Name string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query ( " " , fmt . Sprintf ( " " , url . Query Escape ( name ) , url . Query Escape ( template Name ) ) , nil , " " ) return err } 
func ( r * Protocol LXD ) Console Container ( container Name string , console api . Container Console Post , args * Container Console Args ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } op API : = op . Get ( ) if args = = nil | | args . Terminal = = nil { return nil , fmt . Errorf ( " " ) } if args . Control = = nil { return nil , fmt . Errorf ( " " ) } value , ok : = op API . Metadata [ " " ] if ok { values : = value . ( map [ string ] interface { } ) for k , v : = range values { fds [ k ] = v . ( string ) } } var control Conn * websocket . Conn } control Conn , err = r . Get Operation Websocket ( op API . ID , fds [ " " ] ) if err ! = nil { return nil , err } go args . Control ( control Conn ) if err ! = nil { return nil , err } msg : = websocket . Format Close Message ( websocket . Close Normal Closure , " " ) control Conn . Close ( ) } ( args . Console Disconnect ) < - shared . Websocket Recv Stream ( args . Terminal , conn ) conn . Close ( ) } ( ) return op , nil } 
func ( r * Protocol LXD ) Get Container Console Log ( container Name string , args * Container Console Log Args ) ( io . Read Closer , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } url , err : = r . set Query Attributes ( url ) if err ! = nil { return nil , err } req , err : = http . New Request ( " " , url , nil ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } if err ! = nil { return nil , err } } return resp . Body , err } 
func ( r * Protocol LXD ) Delete Container Console Log ( container Name string , args * Container Console Log Args ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Get Container Backups ( container Name string ) ( [ ] api . Container Backup , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } _ , err : = r . query Struct ( " " , fmt . Sprintf ( " " , url . Query Escape ( container Name ) ) , nil , " " , & backups ) if err ! = nil { return nil , err } return backups , nil } 
func ( r * Protocol LXD ) Get Container Backup ( container Name string , name string ) ( * api . Container Backup , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } etag , err : = r . query Struct ( " " , fmt . Sprintf ( " " , url . Query Escape ( container Name ) , url . Query Escape ( name ) ) , nil , " " , & backup ) if err ! = nil { return nil , " " , err } return & backup , etag , nil } 
func ( r * Protocol LXD ) Create Container Backup ( container Name string , backup api . Container Backups Post ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Rename Container Backup ( container Name string , name string , backup api . Container Backup Post ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Delete Container Backup ( container Name string , name string ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Get Container Backup File ( container Name string , name string , req * Backup File Request ) ( * Backup File Response , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if r . project ! = " " { uri + = fmt . Sprintf ( " " , url . Query Escape ( r . project ) ) } if err ! = nil { return nil , err } if r . http User Agent ! = " " { request . Header . Set ( " " , r . http User Agent ) } if err ! = nil { return nil , err } defer response . Body . Close ( ) defer close ( done Ch ) if response . Status Code ! = http . Status OK { _ , _ , err : = lxd Parse Response ( response ) if err ! = nil { return nil , err } } if req . Progress Handler ! = nil { body = & ioprogress . Progress Reader { Read Closer : response . Body , Tracker : & ioprogress . Progress Tracker { Length : response . Content Length , Handler : func ( percent int 6 4 , speed int 6 4 ) { req . Progress Handler ( ioprogress . Progress Data { Text : fmt . Sprintf ( " " , percent , shared . Get Byte Size String ( speed , 2 ) ) } ) } , } , } } size , err : = io . Copy ( req . Backup File , body ) if err ! = nil { return nil , err } resp : = Backup File Response { } resp . Size = size return & resp , nil } 
func Camel ( s string ) string { words : = strings . Split ( s , " " ) for i : = range words { words [ i ] = Capital ( words [ i ] ) } return strings . Join ( words , " " ) } 
func Snake ( name string ) string { var ret bytes . Buffer multiple Upper : = false var last Upper rune var before Upper rune for _ , c : = range name { if last Upper ! = 0 { last In Row : = ! is Upper if ret . Len ( ) > 0 & & ( first In Row | | last In Row ) & & before Upper ! = ' _ ' { ret . Write Byte ( ' _ ' ) } ret . Write Rune ( unicode . To Lower ( last Upper ) ) } last Upper = c continue } ret . Write Rune ( c ) last Upper = 0 before Upper = c multiple Upper = false } if last Upper ! = 0 { ret . Write Rune ( unicode . To Lower ( last Upper ) ) } return string ( ret . Bytes ( ) ) } 
func rsync Local Copy ( source string , dest string , bwlimit string ) ( string , error ) { err : = os . Mkdir All ( dest , 0 7 5 5 ) if err ! = nil { return " " , err } rsync Verbosity : = " " if debug { rsync Verbosity = " " } if bwlimit = = " " { bwlimit = " " } msg , err : = shared . Run Command ( " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , bwlimit , rsync Verbosity , shared . Add Slash ( source ) , dest ) if err ! = nil { run Error , ok : = err . ( shared . Run Error ) if ok { exit Error , ok : = run Error . Err . ( * exec . Exit Error ) if ok { wait Status : = exit Error . Sys ( ) . ( syscall . Wait Status ) if wait Status . Exit Status ( ) = = 2 4 { return msg , nil } } } return msg , err } return msg , nil } 
func Rsync Send ( name string , path string , conn * websocket . Conn , read Wrapper func ( io . Read Closer ) io . Read Closer , features [ ] string , bwlimit string , exec Path string ) error { cmd , data Socket , stderr , err : = rsync Send Setup ( name , path , bwlimit , exec Path , features ) if err ! = nil { return err } if data Socket ! = nil { defer data Socket . Close ( ) } read Pipe : = io . Read Closer ( data Socket ) if read Wrapper ! = nil { read Pipe = read Wrapper ( data Socket ) } read Done , write Done : = shared . Websocket Mirror ( conn , data Socket , read Pipe , nil , nil ) ch Error : = make ( chan error , 1 ) go func ( ) { err = cmd . Wait ( ) if err ! = nil { data Socket . Close ( ) read Pipe . Close ( ) } ch Error < - err } ( ) output , err : = ioutil . Read All ( stderr ) if err ! = nil { cmd . Process . Kill ( ) } err = < - ch Error if err ! = nil { logger . Errorf ( " " , path , err , string ( output ) ) } < - read Done < - write Done return err } 
func Rsync Recv ( path string , conn * websocket . Conn , write Wrapper func ( io . Write Closer ) io . Write Closer , features [ ] string ) error { args : = [ ] string { " " , " " , " " , " " , " " , " " , } if features ! = nil & & len ( features ) > 0 { args = append ( args , rsync Feature Args ( features ) . . . ) } args = append ( args , [ ] string { " " , path } . . . ) cmd : = exec . Command ( " " , args . . . ) stdin , err : = cmd . Stdin Pipe ( ) if err ! = nil { return err } stdout , err : = cmd . Stdout Pipe ( ) if err ! = nil { return err } stderr , err : = cmd . Stderr Pipe ( ) if err ! = nil { return err } if err : = cmd . Start ( ) ; err ! = nil { return err } write Pipe : = io . Write Closer ( stdin ) if write Wrapper ! = nil { write Pipe = write Wrapper ( stdin ) } read Done , write Done : = shared . Websocket Mirror ( conn , write Pipe , stdout , nil , nil ) output , err : = ioutil . Read All ( stderr ) if err ! = nil { cmd . Process . Kill ( ) cmd . Wait ( ) return err } err = cmd . Wait ( ) if err ! = nil { logger . Errorf ( " " , path , err , string ( output ) ) } < - read Done < - write Done return err } 
func patches Get Names ( ) [ ] string { names : = make ( [ ] string , len ( patches ) ) for i , patch : = range patches { names [ i ] = patch . name } return names } 
func patch Rename Custom Volume LVs ( name string , d * Daemon ) error { for _ , pool Name : = range pools { pool ID , pool , err : = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { return err } s Type , err : = storage String To Type ( pool . Driver ) if err ! = nil { return err } if s Type ! = storage Type Lvm { continue } volumes , err : = d . cluster . Storage Pool Node Volumes Get Type ( storage Pool Volume Type Custom , pool ID ) if err ! = nil { return err } vg Name : = pool Name if pool . Config [ " " ] ! = " " { vg Name = pool . Config [ " " ] } for _ , volume : = range volumes { old Name : = fmt . Sprintf ( " " , vg Name , volume ) new Name : = fmt . Sprintf ( " " , vg Name , container Name To LVName ( volume ) ) exists , err : = storage LVExists ( new Name ) if err ! = nil { return err } if exists | | old Name = = new Name { continue } err = lvm LVRename ( vg Name , old Name , new Name ) if err ! = nil { return err } logger . Info ( " " , log . Ctx { " " : old Name , " " : new Name } ) } } return nil } 
func patch Shrink Logs DBFile ( name string , d * Daemon ) error { dir : = filepath . Join ( d . os . Var Dir , " " , " " ) info , err : = os . Stat ( filepath . Join ( dir , " " ) ) if err ! = nil { if os . Is Not Exist ( err ) { } return errors . Wrap ( err , " " ) } if info . Size ( ) < 1 0 2 4 * 1 0 2 4 * 1 0 0 { } snaps , err : = raft . New File Snapshot Store With Logger ( dir , 2 , stdlog . New ( ioutil . Discard , " " , 0 ) ) if err ! = nil { return errors . Wrap ( err , " " ) } metas , err : = snaps . List ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if len ( metas ) = = 0 { return nil } meta : = metas [ 0 ] if err ! = nil { return errors . Wrap ( err , " " ) } defer logs Cur . Close ( ) path New : = filepath . Join ( dir , " " ) logs New , err : = raftboltdb . New ( raftboltdb . Options { Path : path New , Bolt Options : & bolt . Options { Timeout : 1 0 * time . Second } , } ) if err ! = nil { return errors . Wrap ( err , " " ) } defer logs New . Close ( ) last Index , err : = logs Cur . Last Index ( ) if err ! = nil { return errors . Wrap ( err , " " ) } for index : = meta . Index ; index < = last Index ; index + + { log : = & raft . Log { } err : = logs Cur . Get Log ( index , log ) if err ! = nil { return errors . Wrapf ( err , " " , index ) } err = logs New . Store Log ( log ) if err ! = nil { return errors . Wrapf ( err , " " , index ) } } term , err : = logs Cur . Get Uint 6 4 ( [ ] byte ( " " ) ) if err ! = nil { return errors . Wrap ( err , " " ) } err = logs New . Set Uint 6 4 ( [ ] byte ( " " ) , term ) if err ! = nil { return errors . Wrap ( err , " " ) } logs Cur . Close ( ) logs New . Close ( ) err = os . Remove ( path Cur ) if err ! = nil { return errors . Wrap ( err , " " ) } err = os . Rename ( path New , path Cur ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func patch Lvm Node Specific Config Keys ( name string , d * Daemon ) error { tx , err : = d . cluster . Begin ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } for _ , pool ID : = range pool IDs { if err ! = nil { return errors . Wrap ( err , " " ) } for _ , key : = range [ ] string { " " , " " } { value , ok : = config [ key ] if ! ok { continue } DELETE FROM storage _pools _config WHERE key = ? AND storage _pool _id = ? AND node _id IS NULL ` , key , pool ID ) if err ! = nil { return errors . Wrapf ( err , " " , key ) } INSERT INTO storage _pools _config (storage _pool _id , node _id , key , value ) VALUES ( ? , ? , ? , ? ) ` , pool ID , node ID , key , value ) if err ! = nil { return errors . Wrapf ( err , " " , key ) } } } } err = tx . Commit ( ) if err ! = nil { return errors . Wrap ( err , " " ) } return err } 
func patch Storage Api Update Storage Configs ( name string , d * Daemon ) error { pools , err : = d . cluster . Storage Pools ( ) if err ! = nil { if err = = db . Err No Such Object { return nil } logger . Errorf ( " " , err ) return err } for _ , pool Name : = range pools { pool ID , pool , err : = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { logger . Errorf ( " " , err ) return err } } if err ! = nil { return err } } } case " " : } case " " : } } if pool . Config [ " " ] = = " " { pool . Config [ " " ] = " " } case " " : } if ! shared . Is True ( pool . Config [ " " ] ) { pool . Config [ " " ] = " " } } } if err ! = nil { return err } if err ! = nil { if err = = db . Err No Such Object { continue } return err } for _ , volume : = range volumes { } if err ! = nil { return err } } case " " : } case " " : } case " " : } if ! shared . Is True ( volume . Config [ " " ] ) { volume . Config [ " " ] = " " } } } if err ! = nil { return err } } } return nil } 
func ( r * Protocol LXD ) Get Connection Info ( ) ( * Connection Info , error ) { info : = Connection Info { } info . Certificate = r . http Certificate info . Protocol = " " info . URL = r . http Host info . Socket Path = r . http Unix Path info . Project = r . project if info . Project = = " " { info . Project = " " } urls : = [ ] string { } if r . http Protocol = = " " { urls = append ( urls , r . http Host ) } if r . server ! = nil & & len ( r . server . Environment . Addresses ) > 0 { for _ , addr : = range r . server . Environment . Addresses { url : = fmt . Sprintf ( " " , addr ) if ! shared . String In Slice ( url , urls ) { urls = append ( urls , url ) } } } info . Addresses = urls return & info , nil } 
func ( r * Protocol LXD ) Get HTTPClient ( ) ( * http . Client , error ) { if r . http = = nil { return nil , fmt . Errorf ( " " ) } return r . http , nil } 
func ( r * Protocol LXD ) do ( req * http . Request ) ( * http . Response , error ) { if r . bakery Client ! = nil { r . add Macaroon Headers ( req ) return r . bakery Client . Do ( req ) } return r . http . Do ( req ) } 
func ( r * Protocol LXD ) Raw Query ( method string , path string , data interface { } , ETag string ) ( * api . Response , string , error ) { return r . raw Query ( method , url , data , ETag ) } 
func ( r * Protocol LXD ) Raw Websocket ( path string ) ( * websocket . Conn , error ) { return r . websocket ( path ) } 
func ( r * Protocol LXD ) Raw Operation ( method string , path string , data interface { } , ETag string ) ( Operation , string , error ) { return r . query Operation ( method , path , data , ETag ) } 
func lxd Parse Response ( resp * http . Response ) ( * api . Response , string , error ) { response : = api . Response { } err : = decoder . Decode ( & response ) if err ! = nil { } return nil , " " , err } } return & response , etag , nil } 
func Profile To API ( profile * Profile ) * api . Profile { p : = & api . Profile { Name : profile . Name , Used By : profile . Used By , } p . Description = profile . Description p . Config = profile . Config p . Devices = profile . Devices return p } 
func ( c * Cluster ) Profiles ( project string ) ( [ ] string , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = fmt . Sprintf ( ` SELECT profiles .name FROM profiles JOIN projects ON projects .id = profiles .project _id WHERE projects .name = ? ` ) inargs : = [ ] interface { } { project } var name string outfmt : = [ ] interface { } { name } result , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for _ , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * Cluster ) Profile Get ( project , name string ) ( int 6 4 , * api . Profile , error ) { var result * api . Profile var id int 6 4 err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } profile , err : = tx . Profile Get ( project , name ) if err ! = nil { return err } result = Profile To API ( profile ) id = int 6 4 ( profile . ID ) return nil } ) if err ! = nil { return - 1 , nil , err } return id , result , nil } 
func ( c * Cluster ) Profiles Get ( project string , names [ ] string ) ( [ ] api . Profile , error ) { profiles : = make ( [ ] api . Profile , len ( names ) ) err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } for i , name : = range names { profile , err : = tx . Profile Get ( project , name ) if err ! = nil { return errors . Wrapf ( err , " " , name ) } profiles [ i ] = * Profile To API ( profile ) } return nil } ) if err ! = nil { return nil , err } return profiles , nil } 
func ( c * Cluster ) Profile Config ( project , name string ) ( map [ string ] string , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } var key , value string query : = ` SELECT key , value FROM profiles _config JOIN profiles ON profiles _config .profile _id =profiles .id JOIN projects ON projects .id = profiles .project _id WHERE projects .name = ? AND profiles .name = ? ` inargs : = [ ] interface { } { project , name } outfmt : = [ ] interface { } { key , value } results , err : = query Scan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , errors . Wrapf ( err , " " , name ) } if len ( results ) = = 0 { query : = " " var id int results , err : = query Scan ( c . db , query , [ ] interface { } { name } , [ ] interface { } { id } ) if err ! = nil { return nil , err } if len ( results ) = = 0 { return nil , Err No Such Object } } config : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func Profile Config Clear ( tx * sql . Tx , id int 6 4 ) error { _ , err : = tx . Exec ( " " , id ) if err ! = nil { return err } _ , err = tx . Exec ( `DELETE FROM profiles _devices _config WHERE id IN (SELECT profiles _devices _config .id FROM profiles _devices _config JOIN profiles _devices ON profiles _devices _config .profile _device _id =profiles _devices .id WHERE profiles _devices .profile _id = ? ) ` , id ) if err ! = nil { return err } _ , err = tx . Exec ( " " , id ) if err ! = nil { return err } return nil } 
func Profile Config Add ( tx * sql . Tx , id int 6 4 , config map [ string ] string ) error { str : = fmt . Sprintf ( " " ) stmt , err : = tx . Prepare ( str ) defer stmt . Close ( ) if err ! = nil { return err } for k , v : = range config { if v = = " " { continue } _ , err = stmt . Exec ( id , k , v ) if err ! = nil { return err } } return nil } 
func ( c * Cluster ) Profile Containers Get ( project , profile string ) ( map [ string ] [ ] string , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } q : = `SELECT containers .name , projects .name FROM containers JOIN containers _profiles ON containers .id = = containers _profiles .container _id JOIN projects ON projects .id = = containers .project _id WHERE containers _profiles .profile _id = = (SELECT profiles .id FROM profiles JOIN projects ON projects .id = = profiles .project _id WHERE profiles .name = ? AND projects .name = ? ) AND containers .type = = 0 ` results : = map [ string ] [ ] string { } inargs : = [ ] interface { } { profile , project } var name string outfmt : = [ ] interface { } { name , name } output , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } for _ , r : = range output { if results [ r [ 1 ] . ( string ) ] = = nil { results [ r [ 1 ] . ( string ) ] = [ ] string { } } results [ r [ 1 ] . ( string ) ] = append ( results [ r [ 1 ] . ( string ) ] , r [ 0 ] . ( string ) ) } return results , nil } 
func ( c * Cluster ) Profile Cleanup Leftover ( ) error { stmt : = ` DELETE FROM profiles _config WHERE profile _id NOT IN (SELECT id FROM profiles ) ; DELETE FROM profiles _devices WHERE profile _id NOT IN (SELECT id FROM profiles ) ; DELETE FROM profiles _devices _config WHERE profile _device _id NOT IN (SELECT id FROM profiles _devices ) ; ` err : = exec ( c . db , stmt ) if err ! = nil { return err } return nil } 
func Profiles Expand Config ( config map [ string ] string , profiles [ ] api . Profile ) map [ string ] string { expanded Config : = map [ string ] string { } for i , profile : = range profiles { profile Configs [ i ] = profile . Config } for i : = range profile Configs { for k , v : = range profile Configs [ i ] { expanded Config [ k ] = v } } } return expanded Config } 
func Profiles Expand Devices ( devices types . Devices , profiles [ ] api . Profile ) types . Devices { expanded Devices : = types . Devices { } for i , profile : = range profiles { profile Devices [ i ] = profile . Devices } for i : = range profile Devices { for k , v : = range profile Devices [ i ] { expanded Devices [ k ] = v } } } return expanded Devices } 
func ( r * Protocol LXD ) Get Server ( ) ( * api . Server , string , error ) { server : = api . Server { } if err ! = nil { return nil , " " , err } server . Environment . Certificate Fingerprint , err = shared . Cert Fingerprint Str ( server . Environment . Certificate ) if err ! = nil { return nil , " " , err } } if ! server . Public & & len ( server . Auth Methods ) = = 0 { } return & server , etag , nil } 
func ( r * Protocol LXD ) Update Server ( server api . Server Put , ETag string ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Has Extension ( extension string ) bool { } for _ , entry : = range r . server . APIExtensions { if entry = = extension { return true } } return false } 
func ( r * Protocol LXD ) Get Server Resources ( ) ( * api . Resources , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } resources : = api . Resources { } if err ! = nil { return nil , err } return & resources , nil } 
func ( r * Protocol LXD ) Use Project ( name string ) Container Server { return & Protocol LXD { server : r . server , http : r . http , http Certificate : r . http Certificate , http Host : r . http Host , http Protocol : r . http Protocol , http User Agent : r . http User Agent , bakery Client : r . bakery Client , bakery Interactor : r . bakery Interactor , require Authenticated : r . require Authenticated , cluster Target : r . cluster Target , project : name , } } 
func sqlite Open ( path string ) ( * sql . DB , error ) { timeout : = 5 } 
func Bootstrap ( state * state . State , gateway * Gateway , name string ) error { } err : = membership Check No Leftover Cluster Cert ( state . OS . Var Dir ) if err ! = nil { return err } var address string err = state . Node . Transaction ( func ( tx * db . Node Tx ) error { if err ! = nil { return errors . Wrap ( err , " " ) } address = config . Cluster Address ( ) if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return err } if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } err = gateway . Shutdown ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } err = gateway . wait Leadership ( ) if err ! = nil { return err } } err : = os . Symlink ( " " + ext , filepath . Join ( state . OS . Var Dir , " " + ext ) ) if err ! = nil { return errors . Wrap ( err , " " ) } } return err } ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func Accept ( state * state . State , gateway * Gateway , name , address string , schema , api int ) ( [ ] db . Raft Node , error ) { } if address = = " " { return nil , fmt . Errorf ( " " ) } if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return nil , err } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if len ( nodes ) < membership Max Raft Nodes { err = state . Node . Transaction ( func ( tx * db . Node Tx ) error { id , err : = tx . Raft Node Add ( address ) if err ! = nil { return err } nodes = append ( nodes , db . Raft Node { ID : id , Address : address } ) return nil } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } } return nodes , nil } 
func Join ( state * state . State , gateway * Gateway , cert * shared . Cert Info , name string , nodes [ ] db . Raft Node ) error { } var address string err : = state . Node . Transaction ( func ( tx * db . Node Tx ) error { if err ! = nil { return errors . Wrap ( err , " " ) } address = config . Cluster Address ( ) if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return err } var networks map [ string ] map [ string ] string var operations [ ] db . Operation err = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { pools , err = tx . Storage Pools Node Config ( ) if err ! = nil { return err } networks , err = tx . Networks Node Config ( ) if err ! = nil { return err } operations , err = tx . Operations ( ) if err ! = nil { return err } return nil } ) if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } err = os . Remove All ( state . OS . Global Database Dir ( ) ) if err ! = nil { return errors . Wrap ( err , " " ) } err = gateway . init ( ) if err ! = nil { return errors . Wrap ( err , " " ) } target : = " " for _ , node : = range nodes { if node . Address = = address { id = strconv . Itoa ( int ( node . ID ) ) } else { target = node . Address } } if id ! = " " { logger . Info ( " " , log 1 5 . Ctx { " " : id , " " : address , " " : target } ) changer : = gateway . raft . Membership Changer ( ) err : = changer . Join ( raft . Server ID ( id ) , raft . Server Address ( target ) , 5 * time . Second ) if err ! = nil { return err } } else { logger . Info ( " " ) } err = state . Cluster . Exit Exclusive ( func ( tx * db . Cluster Tx ) error { node , err : = tx . Node Pending By Address ( address ) if err ! = nil { return errors . Wrap ( err , " " ) } state . Cluster . Node ID ( node . ID ) tx . Node ID ( node . ID ) if err ! = nil { return errors . Wrap ( err , " " ) } for name , id : = range ids { err : = tx . Storage Pool Node Join ( id , node . ID ) if err ! = nil { return errors . Wrap ( err , " " ) } driver , err : = tx . Storage Pool Driver ( id ) if err ! = nil { return errors . Wrap ( err , " " ) } if driver = = " " { if err ! = nil { return errors . Wrap ( err , " " ) } } else { if ! ok { return fmt . Errorf ( " " , name ) } err = tx . Storage Pool Config Add ( id , node . ID , config ) if err ! = nil { return errors . Wrap ( err , " " ) } } } if err ! = nil { return errors . Wrap ( err , " " ) } for name , id : = range ids { config , ok : = networks [ name ] if ! ok { return fmt . Errorf ( " " , name ) } err : = tx . Network Node Join ( id , node . ID ) if err ! = nil { return errors . Wrap ( err , " " ) } err = tx . Network Config Add ( id , node . ID , config ) if err ! = nil { return errors . Wrap ( err , " " ) } } if err ! = nil { return errors . Wrapf ( err , " " , operation . UUID ) } } if err ! = nil { return errors . Wrapf ( err , " " ) } return nil } ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func Rebalance ( state * state . State , gateway * Gateway ) ( string , [ ] db . Raft Node , error ) { if err ! = nil { return " " , nil , errors . Wrap ( err , " " ) } if len ( current Raft Nodes ) > = membership Max Raft Nodes { } current Raft Addresses : = make ( [ ] string , len ( current Raft Nodes ) ) for i , node : = range current Raft Nodes { current Raft Addresses [ i ] = node . Address } err = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { config , err : = Config Load ( tx ) if err ! = nil { return errors . Wrap ( err , " " ) } nodes , err : = tx . Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } } if node . Is Offline ( config . Offline Threshold ( ) ) { continue } logger . Debugf ( " " , node . Name , node . Address ) address = node . Address break } return nil } ) if err ! = nil { return " " , nil , err } if address = = " " { } err = gateway . db . Transaction ( func ( tx * db . Node Tx ) error { id , err : = tx . Raft Node Add ( address ) if err ! = nil { return errors . Wrap ( err , " " ) } updated Raft Nodes = append ( updated Raft Nodes , db . Raft Node { ID : id , Address : address } ) err = tx . Raft Nodes Replace ( updated Raft Nodes ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return " " , nil , err } return address , updated Raft Nodes , nil } 
func Promote ( state * state . State , gateway * Gateway , nodes [ ] db . Raft Node ) error { logger . Info ( " " ) } err : = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error address , err = tx . Node Address ( ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return err } } target : = " " for _ , node : = range nodes { if node . Address = = address { id = strconv . Itoa ( int ( node . ID ) ) } else { target = node . Address } } } if err ! = nil { return errors . Wrap ( err , " " ) } return nil } ) if err ! = nil { return err } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } logger . Info ( " " , log 1 5 . Ctx { " " : id , " " : address , " " : target } ) changer : = gateway . raft . Membership Changer ( ) err = changer . Join ( raft . Server ID ( id ) , raft . Server Address ( target ) , 5 * time . Second ) if err ! = nil { return err } return err } ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func Leave ( state * state . State , gateway * Gateway , name string , force bool ) ( string , error ) { logger . Debugf ( " " , name ) err : = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { if err ! = nil { return err } if err ! = nil { return err } } address = node . Address return nil } ) if err ! = nil { return " " , err } raft Node Remove Index : = - 1 err = state . Node . Transaction ( func ( tx * db . Node Tx ) error { var err error raft Nodes , err = tx . Raft Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } for i , node : = range raft Nodes { if node . Address = = address { raft Node Remove Index = i break } } return nil } ) if err ! = nil { return " " , err } if raft Node Remove Index = = - 1 { } id : = strconv . Itoa ( int ( raft Nodes [ raft Node Remove Index ] . ID ) ) logger . Info ( " " , log 1 5 . Ctx { " " : id , " " : address , " " : target } ) dial , err : = raft Dial ( gateway . cert ) if err ! = nil { return " " , err } err = rafthttp . Change Membership ( raftmembership . Leave Request , raft Endpoint , dial , raft . Server ID ( id ) , address , target , 5 * time . Second ) if err ! = nil { return " " , err } return address , nil } 
func Purge ( cluster * db . Cluster , name string ) error { logger . Debugf ( " " , name ) return cluster . Transaction ( func ( tx * db . Cluster Tx ) error { if err ! = nil { return errors . Wrapf ( err , " " , name ) } err = tx . Node Clear ( node . ID ) if err ! = nil { return errors . Wrapf ( err , " " , name ) } err = tx . Node Remove ( node . ID ) if err ! = nil { return errors . Wrapf ( err , " " , name ) } return nil } ) } 
func List ( state * state . State ) ( [ ] api . Cluster Member , error ) { addresses : = [ ] string { } err : = state . Node . Transaction ( func ( tx * db . Node Tx ) error { nodes , err : = tx . Raft Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } for _ , node : = range nodes { addresses = append ( addresses , node . Address ) } return nil } ) if err ! = nil { return nil , err } var nodes [ ] db . Node Info var offline Threshold time . Duration err = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { nodes , err = tx . Nodes ( ) if err ! = nil { return err } offline Threshold , err = tx . Node Offline Threshold ( ) if err ! = nil { return err } return nil } ) if err ! = nil { return nil , err } result : = make ( [ ] api . Cluster Member , len ( nodes ) ) now : = time . Now ( ) version : = nodes [ 0 ] . Version ( ) for i , node : = range nodes { result [ i ] . Server Name = node . Name result [ i ] . URL = fmt . Sprintf ( " " , node . Address ) result [ i ] . Database = shared . String In Slice ( node . Address , addresses ) if node . Is Offline ( offline Threshold ) { result [ i ] . Status = " " result [ i ] . Message = fmt . Sprintf ( " " , now . Sub ( node . Heartbeat ) ) } else { result [ i ] . Status = " " result [ i ] . Message = " " } n , err : = util . Compare Versions ( version , node . Version ( ) ) if err ! = nil { result [ i ] . Status = " " result [ i ] . Message = " " continue } if n = = 1 { } } } n , err : = util . Compare Versions ( version , node . Version ( ) ) if err ! = nil { continue } if n = = 2 { result [ i ] . Status = " " result [ i ] . Message = " " } } return result , nil } 
func Count ( state * state . State ) ( int , error ) { var count int err : = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error count , err = tx . Nodes Count ( ) return err } ) return count , err } 
func Enabled ( node * db . Node ) ( bool , error ) { enabled : = false err : = node . Transaction ( func ( tx * db . Node Tx ) error { addresses , err : = tx . Raft Node Addresses ( ) if err ! = nil { return err } enabled = len ( addresses ) > 0 return nil } ) return enabled , err } 
func membership Check Node State For Bootstrap Or Join ( tx * db . Node Tx , address string ) error { nodes , err : = tx . Raft Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } has Cluster Address : = address ! = " " has Raft Nodes : = len ( nodes ) > 0 } if ! has Cluster Address { return fmt . Errorf ( " " ) } if has Raft Nodes { return fmt . Errorf ( " " ) } return nil } 
func membership Check Cluster State For Bootstrap Or Join ( tx * db . Cluster Tx ) error { nodes , err : = tx . Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if len ( nodes ) ! = 1 { return fmt . Errorf ( " " ) } return nil } 
func membership Check Cluster State For Accept ( tx * db . Cluster Tx , name string , address string , schema int , api int ) error { nodes , err : = tx . Nodes ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if len ( nodes ) = = 1 & & nodes [ 0 ] . Address = = " " { return fmt . Errorf ( " " ) } for _ , node : = range nodes { if node . Name = = name { return fmt . Errorf ( " " , name ) } if node . Address = = address { return fmt . Errorf ( " " , address ) } if node . Schema ! = schema { return fmt . Errorf ( " " , node . Schema ) } if node . APIExtensions ! = api { return fmt . Errorf ( " " , node . APIExtensions ) } } return nil } 
func membership Check Cluster State For Leave ( tx * db . Cluster Tx , node ID int 6 4 ) error { if err ! = nil { return err } if message ! = " " { return fmt . Errorf ( message ) } if err ! = nil { return err } if len ( nodes ) = = 1 { return fmt . Errorf ( " " ) } return nil } 
func membership Check No Leftover Cluster Cert ( dir string ) error { } } return nil } 
func Config Load ( tx * db . Node Tx ) ( * Config , error ) { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } m , err : = config . Safe Load ( Config Schema , values ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & Config { tx : tx , m : m } , nil } 
func ( c * Config ) Replace ( values map [ string ] interface { } ) ( map [ string ] string , error ) { return c . update ( values ) } 
func ( c * Config ) Patch ( patch map [ string ] interface { } ) ( map [ string ] string , error ) { values : = c . Dump ( ) for name , value : = range patch { values [ name ] = value } return c . update ( values ) } 
func HTTPSAddress ( node * db . Node ) ( string , error ) { var config * Config err : = node . Transaction ( func ( tx * db . Node Tx ) error { var err error config , err = Config Load ( tx ) return err } ) if err ! = nil { return " " , err } return config . HTTPSAddress ( ) , nil } 
func ( c * Cluster ) Certificates Get ( ) ( certs [ ] * Cert Info , err error ) { err = c . Transaction ( func ( tx * Cluster Tx ) error { rows , err : = tx . tx . Query ( " " , ) if err ! = nil { return err } defer rows . Close ( ) for rows . Next ( ) { cert : = new ( Cert Info ) rows . Scan ( & cert . ID , & cert . Fingerprint , & cert . Type , & cert . Name , & cert . Certificate , ) certs = append ( certs , cert ) } return rows . Err ( ) } ) if err ! = nil { return certs , err } return certs , nil } 
func ( c * Cluster ) Certificate Get ( fingerprint string ) ( cert * Cert Info , err error ) { cert = new ( Cert Info ) inargs : = [ ] interface { } { fingerprint + " " } outfmt : = [ ] interface { } { & cert . ID , & cert . Fingerprint , & cert . Type , & cert . Name , & cert . Certificate , } query : = ` SELECT id , fingerprint , type , name , certificate FROM certificates WHERE fingerprint LIKE ? ` if err = db Query Row Scan ( c . db , query , inargs , outfmt ) ; err ! = nil { if err = = sql . Err No Rows { return nil , Err No Such Object } return nil , err } return cert , err } 
func ( c * Cluster ) Cert Save ( cert * Cert Info ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { stmt , err : = tx . tx . Prepare ( ` INSERT INTO certificates ( fingerprint , type , name , certificate ) VALUES ( ? , ? , ? , ? ) ` , ) if err ! = nil { return err } defer stmt . Close ( ) _ , err = stmt . Exec ( cert . Fingerprint , cert . Type , cert . Name , cert . Certificate , ) if err ! = nil { return err } return nil } ) return err } 
func ( c * Cluster ) Cert Delete ( fingerprint string ) error { err : = exec ( c . db , " " , fingerprint ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Cert Update ( fingerprint string , cert Name string , cert Type int ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { _ , err : = tx . tx . Exec ( " " , cert Name , cert Type , fingerprint ) return err } ) return err } 
func create Dev Lxdl Listener ( dir string ) ( net . Listener , error ) { path : = filepath . Join ( dir , " " , " " ) if err ! = nil { return nil , err } listener , err : = socket Unix Listen ( path ) if err ! = nil { return nil , err } err = socket Unix Set Permissions ( path , 0 6 6 6 ) if err ! = nil { listener . Close ( ) return nil , err } return listener , nil } 
func new Raft ( database * db . Node , cert * shared . Cert Info , latency float 6 4 ) ( * raft Instance , error ) { if latency < = 0 { return nil , fmt . Errorf ( " " ) } err : = database . Transaction ( func ( tx * db . Node Tx ) error { var err error info , err = node . Determine Raft Node ( tx ) return err } ) if err ! = nil { return nil , err } } logger . Debug ( " " , log 1 5 . Ctx { " " : info . ID , " " : info . Address } ) if err ! = nil { return nil , err } return instance , nil } 
func raft Instance Init ( db * db . Node , node * db . Raft Node , cert * shared . Cert Info , latency float 6 4 ) ( * raft Instance , error ) { raft Logger : = raft Logger ( ) config . Logger = raft Logger config . Local ID = raft . Server ID ( strconv . Itoa ( int ( node . ID ) ) ) var membership Changer func ( * raft . Raft ) var layer * rafthttp . Layer var transport raft . Transport addr : = node . Address if addr = = " " { transport = raft Memory Transport ( ) } else { dial , err : = raft Dial ( cert ) if err ! = nil { return nil , err } transport , handler , layer , err = raft Network Transport ( db , addr , log . New ( & raft Log Writer { } , " " , 0 ) , timeout , dial ) if err ! = nil { return nil , err } membership Changer = func ( raft * raft . Raft ) { raftmembership . Handle Change Requests ( raft , handler . Requests ( ) ) } } err : = raft . Validate Config ( config ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } legacy Dir : = filepath . Join ( db . Dir ( ) , " " , " " ) if shared . Path Exists ( legacy Dir ) { if shared . Path Exists ( dir ) { return nil , fmt . Errorf ( " " ) } logger . Info ( " " ) err : = os . Rename ( legacy Dir , dir ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } } if err ! = nil { return nil , err } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } } serial + + fsm : = dqlite . New FSM ( registry ) if err ! = nil { logs . Close ( ) return nil , errors . Wrap ( err , " " ) } if membership Changer ! = nil { } instance : = & raft Instance { layer : layer , handler : raft Handler ( cert , handler ) , membership Changer : membership Changer , logs : logs , registry : registry , fsm : fsm , raft : raft , } return instance , nil } 
func ( i * raft Instance ) Servers ( ) ( [ ] raft . Server , error ) { if i . raft . State ( ) ! = raft . Leader { return nil , raft . Err Not Leader } future : = i . raft . Get Configuration ( ) err : = future . Error ( ) if err ! = nil { return nil , err } configuration : = future . Configuration ( ) return configuration . Servers , nil } 
func ( i * raft Instance ) Handler Func ( ) http . Handler Func { if i . handler = = nil { return nil } return i . handler . Serve HTTP } 
func ( i * raft Instance ) Shutdown ( ) error { logger . Debug ( " " ) err Ch : = make ( chan error ) timer : = time . After ( timeout ) go func ( ) { err Ch < - i . raft . Shutdown ( ) . Error ( ) } ( ) select { case err : = < - err Ch : if err ! = nil { return errors . Wrap ( err , " " ) } case < - timer : logger . Debug ( " " ) return fmt . Errorf ( " " , timeout ) } err : = i . logs . Close ( ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func raft Dial ( cert * shared . Cert Info ) ( rafthttp . Dial , error ) { config , err : = tls Client Config ( cert ) if err ! = nil { return nil , err } dial : = rafthttp . New Dial TLS ( config ) return dial , nil } 
func raft Network Transport ( db * db . Node , address string , logger * log . Logger , timeout time . Duration , dial rafthttp . Dial ) ( raft . Transport , * rafthttp . Handler , * rafthttp . Layer , error ) { handler : = rafthttp . New Handler With Logger ( logger ) addr , err : = net . Resolve TCPAddr ( " " , address ) if err ! = nil { return nil , nil , nil , errors . Wrap ( err , " " ) } layer : = rafthttp . New Layer ( raft Endpoint , addr , handler , dial ) config : = & raft . Network Transport Config { Logger : logger , Stream : layer , Max Pool : 2 , Timeout : timeout , Server Address Provider : & raft Address Provider { db : db } , } transport : = raft . New Network Transport With Config ( config ) return transport , handler , layer , nil } 
func raft Config ( latency float 6 4 ) * raft . Config { config : = raft . Default Config ( ) scale : = func ( duration * time . Duration ) { * duration = time . Duration ( ( math . Ceil ( float 6 4 ( * duration ) * latency ) ) ) } durations : = [ ] * time . Duration { & config . Heartbeat Timeout , & config . Election Timeout , & config . Commit Timeout , & config . Leader Lease Timeout , } for _ , duration : = range durations { scale ( duration ) } config . Snapshot Threshold = 1 0 2 4 config . Trailing Logs = 5 1 2 return config } 
func raft Maybe Bootstrap ( conf * raft . Config , logs * raftboltdb . Bolt Store , snaps raft . Snapshot Store , trans raft . Transport ) error { if err ! = nil { return errors . Wrap ( err , " " ) } if has Existing State { return nil } server : = raft . Server { ID : conf . Local ID , Address : trans . Local Addr ( ) , } configuration : = raft . Configuration { Servers : [ ] raft . Server { server } , } return raft . Bootstrap Cluster ( conf , logs , logs , snaps , trans , configuration ) } 
func CPUResource ( ) ( * api . Resources CPU , error ) { c : = api . Resources CPU { } threads , err : = get Threads ( ) if err ! = nil { return nil , err } var cur * api . Resources CPUSocket c . Total = uint 6 4 ( len ( threads ) ) for _ , v : = range threads { if uint 6 4 ( len ( c . Sockets ) ) < = v . socket ID { c . Sockets = append ( c . Sockets , api . Resources CPUSocket { } ) cur = & c . Sockets [ v . socket ID ] for _ , thread : = range threads { if thread . socket ID ! = v . socket ID { continue } socket Cores [ thread . core ID ] = true } cur . Cores = uint 6 4 ( len ( socket Cores ) ) } else { cur = & c . Sockets [ v . socket ID ] } cur . Socket = v . socket ID cur . NUMANode = v . numa Node cur . Threads + + cur . Name = v . name cur . Vendor = v . vendor cur . Frequency = v . frequency cur . Frequency Turbo = v . frequency Turbo } return & c , nil } 
func Memory Resource ( ) ( * api . Resources Memory , error ) { var buffers uint 6 4 var cached uint 6 4 var free uint 6 4 var total uint 6 4 f , err : = os . Open ( " " ) if err ! = nil { return nil , err } defer f . Close ( ) clean Line : = func ( l string ) ( string , error ) { l = strings . Trim Space ( l ) idx : = strings . Last Index ( l , " " ) if idx < 0 { return " " , fmt . Errorf ( `Failed to detect "k B " suffix ` ) } return strings . Trim Space ( l [ : idx ] ) , nil } mem : = api . Resources Memory { } scanner : = bufio . New Scanner ( f ) found : = 0 for scanner . Scan ( ) { var err error line : = scanner . Text ( ) if strings . Has Prefix ( line , " " ) { line , err = clean Line ( line [ len ( " " ) : ] ) if err ! = nil { return nil , err } total , err = strconv . Parse Uint ( line , 1 0 , 6 4 ) if err ! = nil { return nil , err } found + + } else if strings . Has Prefix ( line , " " ) { line , err = clean Line ( line [ len ( " " ) : ] ) if err ! = nil { return nil , err } free , err = strconv . Parse Uint ( line , 1 0 , 6 4 ) if err ! = nil { return nil , err } found + + } else if strings . Has Prefix ( line , " " ) { line , err = clean Line ( line [ len ( " " ) : ] ) if err ! = nil { return nil , err } cached , err = strconv . Parse Uint ( line , 1 0 , 6 4 ) if err ! = nil { return nil , err } found + + } else if strings . Has Prefix ( line , " " ) { line , err = clean Line ( line [ len ( " " ) : ] ) if err ! = nil { return nil , err } buffers , err = strconv . Parse Uint ( line , 1 0 , 6 4 ) if err ! = nil { return nil , err } found + + } if found = = 4 { break } } mem . Total = total * 1 0 2 4 mem . Used = ( total - free - cached - buffers ) * 1 0 2 4 return & mem , err } 
func ( r * Protocol LXD ) Get Operation UUIDs ( ) ( [ ] string , error ) { urls : = [ ] string { } if err ! = nil { return nil , err } for _ , url : = range urls { fields : = strings . Split ( url , " " ) uuids = append ( uuids , fields [ len ( fields ) - 1 ] ) } return uuids , nil } 
func ( r * Protocol LXD ) Get Operations ( ) ( [ ] api . Operation , error ) { api Operations : = map [ string ] [ ] api . Operation { } if err ! = nil { return nil , err } for _ , v : = range api Operations { for _ , operation : = range v { operations = append ( operations , operation ) } } return operations , nil } 
func ( r * Protocol LXD ) Get Operation ( uuid string ) ( * api . Operation , string , error ) { op : = api . Operation { } if err ! = nil { return nil , " " , err } return & op , etag , nil } 
func ( r * Protocol LXD ) Get Operation Websocket ( uuid string , secret string ) ( * websocket . Conn , error ) { path : = fmt . Sprintf ( " " , url . Query Escape ( uuid ) ) if secret ! = " " { path = fmt . Sprintf ( " " , path , url . Query Escape ( secret ) ) } return r . websocket ( path ) } 
func ( r * Protocol LXD ) Delete Operation ( uuid string ) error { if err ! = nil { return err } return nil } 
func try Mount ( src string , dst string , fs string , flags uintptr , options string ) error { var err error for i : = 0 ; i < 2 0 ; i + + { err = syscall . Mount ( src , dst , fs , flags , options ) if err = = nil { break } time . Sleep ( 5 0 0 * time . Millisecond ) } if err ! = nil { return err } return nil } 
func lxd Uses Pool ( db Obj * db . Cluster , on Disk Pool Name string , driver string , on Disk Property string ) ( bool , string , error ) { pools , err : = db Obj . Storage Pools ( ) if err ! = nil & & err ! = db . Err No Such Object { return false , " " , err } for _ , pool : = range pools { _ , pl , err : = db Obj . Storage Pool Get ( pool ) if err ! = nil { continue } if pl . Driver ! = driver { continue } if pl . Config [ on Disk Property ] = = on Disk Pool Name { return true , pl . Name , nil } } return false , " " , nil } 
func storage Pool Volumes Get ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) pool Name : = mux . Vars ( r ) [ " " ] recursion : = util . Is Recursion Request ( r ) if err ! = nil { return Smart Error ( err ) } if err ! = nil & & err ! = db . Err No Such Object { return Smart Error ( err ) } image Volumes , err : = d . cluster . Storage Pool Volumes Get ( " " , pool ID , [ ] int { storage Pool Volume Type Image } ) if err ! = nil & & err ! = db . Err No Such Object { return Smart Error ( err ) } project Images , err : = d . cluster . Images Get ( project , false ) if err ! = nil { return Smart Error ( err ) } for _ , volume : = range image Volumes { if shared . String In Slice ( volume . Name , project Images ) { volumes = append ( volumes , volume ) } } result String : = [ ] string { } for _ , volume : = range volumes { api Endpoint , err : = storage Pool Volume Type Name To APIEndpoint ( volume . Type ) if err ! = nil { return Internal Error ( err ) } if api Endpoint = = storage Pool Volume APIEndpoint Containers { api Endpoint = " " } else if api Endpoint = = storage Pool Volume APIEndpoint Images { api Endpoint = " " } if ! recursion { vol Name , snap Name , ok : = container Get Parent And Snapshot Name ( volume . Name ) if ok { result String = append ( result String , fmt . Sprintf ( " " , version . APIVersion , pool Name , api Endpoint , vol Name , snap Name ) ) } else { result String = append ( result String , fmt . Sprintf ( " " , version . APIVersion , pool Name , api Endpoint , volume . Name ) ) } } else { volume Used By , err : = storage Pool Volume Used By Get ( d . State ( ) , project , volume . Name , volume . Type ) if err ! = nil { return Internal Error ( err ) } volume . Used By = volume Used By } } if ! recursion { return Sync Response ( true , result String ) } return Sync Response ( true , volumes ) } 
func storage Pool Volumes Type Get ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) recursion : = util . Is Recursion Request ( r ) if err ! = nil { return Bad Request ( err ) } } if err ! = nil { return Smart Error ( err ) } if err ! = nil { return Smart Error ( err ) } result String : = [ ] string { } result Map : = [ ] * api . Storage Volume { } for _ , volume : = range volumes { if ! recursion { api Endpoint , err : = storage Pool Volume Type To APIEndpoint ( volume Type ) if err ! = nil { return Internal Error ( err ) } if api Endpoint = = storage Pool Volume APIEndpoint Containers { api Endpoint = " " } else if api Endpoint = = storage Pool Volume APIEndpoint Images { api Endpoint = " " } result String = append ( result String , fmt . Sprintf ( " " , version . APIVersion , pool Name , api Endpoint , volume ) ) } else { _ , vol , err : = d . cluster . Storage Pool Node Volume Get Type ( volume , volume Type , pool ID ) if err ! = nil { continue } volume Used By , err : = storage Pool Volume Used By Get ( d . State ( ) , project , vol . Name , vol . Type ) if err ! = nil { return Smart Error ( err ) } vol . Used By = volume Used By result Map = append ( result Map , vol ) } } if ! recursion { return Sync Response ( true , result String ) } return Sync Response ( true , result Map ) } 
func storage Pool Volumes Type Post ( d * Daemon , r * http . Request ) Response { response : = Forwarded Response If Target Is Remote ( d , r ) if response ! = nil { return response } req : = api . Storage Volumes Post { } if err ! = nil { return Bad Request ( err ) } } if strings . Contains ( req . Name , " " ) { return Bad Request ( fmt . Errorf ( " " ) ) } req . Type = mux . Vars ( r ) [ " " ] } pool Name : = mux . Vars ( r ) [ " " ] switch req . Source . Type { case " " : return do Volume Create Or Copy ( d , pool Name , & req ) case " " : return do Volume Create Or Copy ( d , pool Name , & req ) case " " : return do Volume Migration ( d , pool Name , & req ) default : return Bad Request ( fmt . Errorf ( " " , req . Source . Type ) ) } } 
func storage Pool Volume Type Post ( d * Daemon , r * http . Request , volume Type Name string ) Response { fields : = strings . Split ( mux . Vars ( r ) [ " " ] , " " ) if len ( fields ) = = 3 & & fields [ 1 ] = = " " { } else if len ( fields ) > 1 { volume Name = fmt . Sprintf ( " " , fields [ 0 ] , shared . Snapshot Delimiter , fields [ 1 ] ) } else if len ( fields ) > 0 { } else { return Bad Request ( fmt . Errorf ( " " , mux . Vars ( r ) [ " " ] ) ) } req : = api . Storage Volume Post { } if err ! = nil { return Bad Request ( err ) } } if strings . Contains ( req . Name , " " ) { return Bad Request ( fmt . Errorf ( " " ) ) } } if req . Pool ! = " " { pool ID , err = d . cluster . Storage Pool Get ID ( req . Pool ) } else { pool ID , err = d . cluster . Storage Pool Get ID ( pool Name ) } if err ! = nil { return Smart Error ( err ) } err = json . New Encoder ( & buf ) . Encode ( req ) if err ! = nil { return Smart Error ( err ) } r . Body = shared . Bytes Read Closer { Buf : & buf } response : = Forwarded Response If Target Is Remote ( d , r ) if response ! = nil { return response } if err ! = nil { return Bad Request ( err ) } response = Forwarded Response If Volume Is Remote ( d , r , pool ID , volume Name , volume Type ) if response ! = nil { return response } s , err : = storage Pool Volume Init ( d . State ( ) , " " , pool Name , volume Name , storage Pool Volume Type Custom ) if err ! = nil { return Internal Error ( err ) } if err ! = nil { return Internal Error ( err ) } resources : = map [ string ] [ ] string { } resources [ " " ] = [ ] string { fmt . Sprintf ( " " , pool Name , volume Name ) } if req . Target ! = nil { if err ! = nil { return Internal Error ( err ) } op , err : = operation Create ( d . cluster , " " , operation Class Task , db . Operation Volume Migrate , resources , nil , ws . Do Storage , nil , nil ) if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } if err ! = db . Err No Such Object { if err ! = nil { return Internal Error ( err ) } return Conflict ( fmt . Errorf ( " " , req . Name ) ) } do Work : = func ( ) error { cts Using Volume , err : = storage Pool Volume Used By Running Containers With Profiles Get ( d . State ( ) , pool Name , volume Name , storage Pool Volume Type Name Custom , true ) if err ! = nil { return err } if len ( cts Using Volume ) > 0 { return fmt . Errorf ( " " ) } err = storage Pool Volume Update Users ( d , pool Name , volume Name , req . Pool , req . Name ) if err ! = nil { return err } if req . Pool = = " " | | req . Pool = = pool Name { err : = s . Storage Pool Volume Rename ( req . Name ) if err ! = nil { storage Pool Volume Update Users ( d , req . Pool , req . Name , pool Name , volume Name ) return err } } else { move Req : = api . Storage Volumes Post { } move Req . Name = req . Name move Req . Type = " " move Req . Source . Name = volume Name move Req . Source . Pool = pool Name err : = storage Pool Volume Create Internal ( d . State ( ) , req . Pool , & move Req ) if err ! = nil { storage Pool Volume Update Users ( d , req . Pool , req . Name , pool Name , volume Name ) return err } err = s . Storage Pool Volume Delete ( ) if err ! = nil { return err } } return nil } if req . Pool = = " " { err = do Work ( ) if err ! = nil { return Smart Error ( err ) } return Sync Response Location ( true , nil , fmt . Sprintf ( " " , version . APIVersion , pool Name , storage Pool Volume APIEndpoint Custom ) ) } run : = func ( op * operation ) error { return do Work ( ) } op , err : = operation Create ( d . cluster , " " , operation Class Task , db . Operation Volume Move , nil , nil , run , nil , nil ) if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } 
func storage Pool Volume Type Get ( d * Daemon , r * http . Request , volume Type Name string ) Response { project : = project Param ( r ) fields : = strings . Split ( mux . Vars ( r ) [ " " ] , " " ) if len ( fields ) = = 3 & & fields [ 1 ] = = " " { } else if len ( fields ) > 1 { volume Name = fmt . Sprintf ( " " , fields [ 0 ] , shared . Snapshot Delimiter , fields [ 1 ] ) } else if len ( fields ) > 0 { } else { return Bad Request ( fmt . Errorf ( " " , mux . Vars ( r ) [ " " ] ) ) } if err ! = nil { return Bad Request ( err ) } } if err ! = nil { return Smart Error ( err ) } response : = Forwarded Response If Target Is Remote ( d , r ) if response ! = nil { return response } response = Forwarded Response If Volume Is Remote ( d , r , pool ID , volume Name , volume Type ) if response ! = nil { return response } if err ! = nil { return Smart Error ( err ) } volume Used By , err : = storage Pool Volume Used By Get ( d . State ( ) , project , volume . Name , volume . Type ) if err ! = nil { return Smart Error ( err ) } volume . Used By = volume Used By etag : = [ ] interface { } { volume Name , volume . Type , volume . Config } return Sync Response ETag ( true , volume , etag ) } 
func storage Pool Volume Type Put ( d * Daemon , r * http . Request , volume Type Name string ) Response { fields : = strings . Split ( mux . Vars ( r ) [ " " ] , " " ) if len ( fields ) = = 3 & & fields [ 1 ] = = " " { } else if len ( fields ) > 1 { volume Name = fmt . Sprintf ( " " , fields [ 0 ] , shared . Snapshot Delimiter , fields [ 1 ] ) } else if len ( fields ) > 0 { } else { return Bad Request ( fmt . Errorf ( " " , mux . Vars ( r ) [ " " ] ) ) } if err ! = nil { return Bad Request ( err ) } } pool ID , pool , err : = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { return Smart Error ( err ) } response : = Forwarded Response If Target Is Remote ( d , r ) if response ! = nil { return response } response = Forwarded Response If Volume Is Remote ( d , r , pool ID , volume Name , volume Type ) if response ! = nil { return response } if err ! = nil { return Smart Error ( err ) } err = util . Etag Check ( r , etag ) if err ! = nil { return Precondition Failed ( err ) } req : = api . Storage Volume Put { } if err : = json . New Decoder ( r . Body ) . Decode ( & req ) ; err ! = nil { return Bad Request ( err ) } if req . Restore ! = " " { cts Using Volume , err : = storage Pool Volume Used By Running Containers With Profiles Get ( d . State ( ) , pool Name , volume . Name , storage Pool Volume Type Name Custom , true ) if err ! = nil { return Internal Error ( err ) } if len ( cts Using Volume ) ! = 0 { return Bad Request ( fmt . Errorf ( " " ) ) } err = storage Pool Volume Restore ( d . State ( ) , pool Name , volume Name , volume Type , req . Restore ) if err ! = nil { return Smart Error ( err ) } } else { if err ! = nil { return Bad Request ( err ) } err = storage Pool Volume Update ( d . State ( ) , pool Name , volume Name , volume Type , req . Description , req . Config ) if err ! = nil { return Smart Error ( err ) } } return Empty Sync Response } 
func storage Pool Volume Type Delete ( d * Daemon , r * http . Request , volume Type Name string ) Response { project : = project Param ( r ) fields : = strings . Split ( mux . Vars ( r ) [ " " ] , " " ) if len ( fields ) = = 3 & & fields [ 1 ] = = " " { } else if len ( fields ) > 0 { } else { return Bad Request ( fmt . Errorf ( " " , mux . Vars ( r ) [ " " ] ) ) } if err ! = nil { return Bad Request ( err ) } } response : = Forwarded Response If Target Is Remote ( d , r ) if response ! = nil { return response } pool ID , _ , err : = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { return Smart Error ( err ) } response = Forwarded Response If Volume Is Remote ( d , r , pool ID , volume Name , volume Type ) if response ! = nil { return response } switch volume Type { case storage Pool Volume Type Custom : } volume Used By , err : = storage Pool Volume Used By Get ( d . State ( ) , project , volume Name , volume Type Name ) if err ! = nil { return Smart Error ( err ) } if len ( volume Used By ) > 0 { if len ( volume Used By ) ! = 1 | | volume Type ! = storage Pool Volume Type Image | | volume Used By [ 0 ] ! = fmt . Sprintf ( " " , version . APIVersion , volume Name ) { return Bad Request ( fmt . Errorf ( `The storage volume is ` + `still in use by containers or profiles ` ) ) } } s , err : = storage Pool Volume Init ( d . State ( ) , " " , pool Name , volume Name , volume Type ) if err ! = nil { return Not Found ( err ) } switch volume Type { case storage Pool Volume Type Custom : var snapshots [ ] string if err ! = nil { return Smart Error ( err ) } for _ , snapshot : = range snapshots { s , err : = storage Pool Volume Init ( d . State ( ) , project , pool Name , snapshot , volume Type ) if err ! = nil { return Not Found ( err ) } err = s . Storage Pool Volume Snapshot Delete ( ) if err ! = nil { return Smart Error ( err ) } } err = s . Storage Pool Volume Delete ( ) case storage Pool Volume Type Image : err = s . Image Delete ( volume Name ) default : return Bad Request ( fmt . Errorf ( `Storage volumes of type " %s " ` + `cannot be deleted with the storage api ` , volume Type Name ) ) } if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func ( c * Cluster Tx ) Project URIs ( filter Project Filter ) ( [ ] string , error ) { if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil { stmt = c . stmt ( project Names By Name ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( project Names ) args = [ ] interface { } { } } code : = cluster . Entity Types [ " " ] formatter : = cluster . Entity Format URIs [ code ] return query . Select URIs ( stmt , formatter , args . . . ) } 
func ( c * Cluster Tx ) Project List ( filter Project Filter ) ( [ ] api . Project , error ) { if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil { stmt = c . stmt ( project Objects By Name ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( project Objects ) args = [ ] interface { } { } } return [ ] interface { } { & objects [ i ] . Description , & objects [ i ] . Name , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { value : = config Objects [ objects [ i ] . Name ] if value = = nil { value = map [ string ] string { } } objects [ i ] . Config = value } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { value : = used By Objects [ objects [ i ] . Name ] if value = = nil { value = [ ] string { } } objects [ i ] . Used By = value } return objects , nil } 
func ( c * Cluster Tx ) Project Get ( name string ) ( * api . Project , error ) { filter : = Project Filter { } filter . Name = name objects , err : = c . Project List ( filter ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , Err No Such Object case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Project Exists ( name string ) ( bool , error ) { _ , err : = c . Project ID ( name ) if err ! = nil { if err = = Err No Such Object { return false , nil } return false , err } return true , nil } 
func ( c * Cluster Tx ) Project Create ( object api . Projects Post ) ( int 6 4 , error ) { if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } if exists { return - 1 , fmt . Errorf ( " " ) } args : = make ( [ ] interface { } , 2 ) args [ 1 ] = object . Name if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } id , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } for key , value : = range object . Config { _ , err : = stmt . Exec ( id , key , value ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } return id , nil } 
func ( c * Cluster Tx ) Project Used By Ref ( filter Project Filter ) ( map [ string ] [ ] string , error ) { Value string } , 0 ) if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil { stmt = c . stmt ( project Used By Ref By Name ) args = [ ] interface { } { filter . Name , } } else { stmt = c . stmt ( project Used By Ref ) args = [ ] interface { } { } } Value string } { } ) return [ ] interface { } { & objects [ i ] . Name , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { item , ok : = index [ object . Name ] if ! ok { item = [ ] string { } } index [ object . Name ] = append ( item , object . Value ) } return index , nil } 
func ( c * Cluster Tx ) Project Rename ( name string , to string ) error { stmt : = c . stmt ( project Rename ) result , err : = stmt . Exec ( to , name ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Project Delete ( name string ) error { stmt : = c . stmt ( project Delete ) result , err : = stmt . Exec ( name ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func Password Check ( secret string , password string ) error { } if err ! = nil { return err } salt : = buff [ 0 : 3 2 ] hash , err : = scrypt . Key ( [ ] byte ( password ) , salt , 1 < < 1 4 , 8 , 1 , 6 4 ) if err ! = nil { return err } if ! bytes . Equal ( hash , buff [ 3 2 : ] ) { return fmt . Errorf ( " " ) } return nil } 
func Load Cert ( dir string ) ( * shared . Cert Info , error ) { prefix : = " " if shared . Path Exists ( filepath . Join ( dir , " " ) ) { prefix = " " } cert , err : = shared . Key Pair And CA ( dir , prefix , shared . Cert Server ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return cert , nil } 
func Write Cert ( dir , prefix string , cert , key , ca [ ] byte ) error { err : = ioutil . Write File ( filepath . Join ( dir , prefix + " " ) , cert , 0 6 4 4 ) if err ! = nil { return err } err = ioutil . Write File ( filepath . Join ( dir , prefix + " " ) , key , 0 6 0 0 ) if err ! = nil { return err } if ca ! = nil { err = ioutil . Write File ( filepath . Join ( dir , prefix + " " ) , ca , 0 6 4 4 ) if err ! = nil { return err } } return nil } 
func New Daemon ( config * Daemon Config , os * sys . OS ) * Daemon { return & Daemon { config : config , os : os , setup Chan : make ( chan struct { } ) , ready Chan : make ( chan struct { } ) , shutdown Chan : make ( chan struct { } ) , } } 
func Default Daemon ( ) * Daemon { config : = Default Daemon Config ( ) os : = sys . Default OS ( ) return New Daemon ( config , os ) } 
func Allow Project Permission ( feature string , permission string ) func ( d * Daemon , r * http . Request ) Response { return func ( d * Daemon , r * http . Request ) Response { } } return Empty Sync Response } } 
func ( d * Daemon ) check Trusted Client ( r * http . Request ) error { trusted , _ , _ , err : = d . Authenticate ( r ) if ! trusted | | err ! = nil { if err ! = nil { return err } return fmt . Errorf ( " " ) } return nil } 
func ( d * Daemon ) Authenticate ( r * http . Request ) ( bool , string , string , error ) { cluster Certs : = map [ string ] x 5 0 9 . Certificate { " " : * cert } for i : = range r . TLS . Peer Certificates { trusted , _ : = util . Check Trust State ( * r . TLS . Peer Certificates [ i ] , cluster Certs ) if trusted { return true , " " , " " , nil } } } } } } } if d . external Auth ! = nil & & r . Header . Get ( httpbakery . Bakery Protocol Header ) ! = " " { auth Checker : = d . external Auth . bakery . Checker . Auth ( httpbakery . Request Macaroons ( r ) . . . ) ops : = [ ] bakery . Op { { Entity : r . URL . Path , Action : r . Method , } } info , err : = auth Checker . Allow ( ctx , ops . . . ) if err ! = nil { } if info ! = nil & & info . Identity ! = nil { } } if trusted { return true , username , " " , nil } } } 
func ( d * Daemon ) State ( ) * state . State { return state . New State ( d . db , d . cluster , d . maas , d . os , d . endpoints ) } 
func ( d * Daemon ) Unix Socket ( ) string { path : = os . Getenv ( " " ) if path ! = " " { return path } return filepath . Join ( d . os . Var Dir , " " ) } 
func ( d * Daemon ) Stop ( ) error { logger . Info ( " " ) errs : = [ ] error { } track Error : = func ( err error ) { if err ! = nil { errs = append ( errs , err ) } } if d . endpoints ! = nil { track Error ( d . endpoints . Down ( ) ) } track Error ( d . tasks . Stop ( 3 * time . Second ) ) track Error ( d . cluster Tasks . Stop ( 3 * time . Second ) ) should Unmount : = false if d . cluster ! = nil { go func ( ) { n , err : = d . num Running Containers ( ) ch < - err ! = nil | | n = = 0 } ( ) select { case should Unmount = < - ch : case < - time . After ( 2 * time . Second ) : should Unmount = true } logger . Infof ( " " ) err : = d . cluster . Close ( ) } else { track Error ( err ) } } if d . db ! = nil { track Error ( d . db . Close ( ) ) } if d . gateway ! = nil { track Error ( d . gateway . Shutdown ( ) ) } if d . endpoints ! = nil { track Error ( d . endpoints . Down ( ) ) } if d . endpoints ! = nil { track Error ( d . endpoints . Down ( ) ) } if should Unmount { logger . Infof ( " " ) syscall . Unmount ( shared . Var Path ( " " ) , syscall . MNT _DETACH ) syscall . Unmount ( shared . Var Path ( " " ) , syscall . MNT _DETACH ) logger . Infof ( " " ) } else { logger . Debugf ( " " ) } var err error if n : = len ( errs ) ; n > 0 { format : = " " if n > 1 { format + = fmt . Sprintf ( " " , n ) } err = fmt . Errorf ( format , errs [ 0 ] ) } if err ! = nil { logger . Errorf ( " " , err ) } return err } 
func ( d * Daemon ) setup External Authentication ( auth Endpoint string , auth Pubkey string , expiry int 6 4 , domains string ) error { for _ , domain : = range strings . Split ( domains , " " ) { if domain = = " " { continue } auth Domains = append ( auth Domains , strings . Trim Space ( domain ) ) } return nil } if err ! = nil { return err } idm Client Wrapper : = & Identity Client Wrapper { client : idm Client , Valid Domains : auth Domains , } if err ! = nil { return err } pk Cache : = bakery . New Third Party Store ( ) pk Locator : = httpbakery . New Third Party Locator ( nil , pk Cache ) if auth Pubkey ! = " " { err : = pk Key . Unmarshal Text ( [ ] byte ( auth Pubkey ) ) if err ! = nil { return err } } } } , } , } ) return nil } 
func ( d * Daemon ) setup RBACServer ( rbac URL string , rbac Key string , rbac Expiry int 6 4 , rbac Agent URL string , rbac Agent Username string , rbac Agent Private Key string , rbac Agent Public Key string ) error { if d . rbac ! = nil | | rbac URL = = " " | | rbac Agent URL = = " " | | rbac Agent Username = = " " | | rbac Agent Private Key = = " " | | rbac Agent Public Key = = " " { return nil } if err ! = nil { return err } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error result , err = tx . Project Map ( ) return err } ) return result , err } if err ! = nil { return err } server . Start Status Check ( ) d . rbac = server if err ! = nil { return err } return nil } 
func ( d * Daemon ) setup MAASController ( server string , key string , machine string ) error { var err error d . maas = nil if err ! = nil { return err } } } if err ! = nil { d . maas = nil return err } d . maas = controller return nil } 
func initialize Db Object ( d * Daemon ) ( * db . Dump , error ) { logger . Info ( " " ) } logger . Info ( " " ) err : = os . Rename ( d . os . Legacy Local Database Path ( ) , d . os . Local Database Path ( ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } } for i , patch : = range legacy Patches { legacy [ i ] = & db . Legacy Patch { Hook : func ( node * sql . DB ) error { defer func ( ) { d . cluster = cluster } ( ) d . db = db . For Legacy Patches ( node ) d . cluster = db . For Local Inspection ( node ) return patch ( d ) } , } } for _ , i : = range legacy Patches Needing DB { legacy [ i ] . Needs DB = true } if err ! = nil { return err } } return nil } var err error var dump * db . Dump d . db , dump , err = db . Open Node ( filepath . Join ( d . os . Var Dir , " " ) , fresh Hook , legacy ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return dump , nil } 
func ( s * rbd Migration Source Driver ) rbd Send ( conn * websocket . Conn , volume Name string , volume Parent Name string , read Wrapper func ( io . Read Closer ) io . Read Closer ) error { args : = [ ] string { " " , " " , s . ceph . Cluster Name , volume Name , } if volume Parent Name ! = " " { args = append ( args , " " , volume Parent Name ) } cmd : = exec . Command ( " " , args . . . ) stdout , err : = cmd . Stdout Pipe ( ) if err ! = nil { return err } read Pipe : = io . Read Closer ( stdout ) if read Wrapper ! = nil { read Pipe = read Wrapper ( stdout ) } stderr , err : = cmd . Stderr Pipe ( ) if err ! = nil { return err } err = cmd . Start ( ) if err ! = nil { return err } < - shared . Websocket Send Stream ( conn , read Pipe , 4 * 1 0 2 4 * 1 0 2 4 ) output , err : = ioutil . Read All ( stderr ) if err ! = nil { logger . Debugf ( `Failed to read stderr output from "rbd export -diff " : %s ` , err ) } err = cmd . Wait ( ) if err ! = nil { logger . Errorf ( `Failed to perform "rbd export -diff " : %s ` , string ( output ) ) } return err } 
func Write JSON ( w http . Response Writer , body interface { } , debug bool ) error { var output io . Writer var captured * bytes . Buffer output = w if debug { captured = & bytes . Buffer { } output = io . Multi Writer ( w , captured ) } err : = json . New Encoder ( output ) . Encode ( body ) if captured ! = nil { shared . Debug Json ( captured ) } return err } 
func Etag Hash ( data interface { } ) ( string , error ) { etag : = sha 2 5 6 . New ( ) err : = json . New Encoder ( etag ) . Encode ( data ) if err ! = nil { return " " , err } return fmt . Sprintf ( " " , etag . Sum ( nil ) ) , nil } 
func Etag Check ( r * http . Request , data interface { } ) error { match : = r . Header . Get ( " " ) if match = = " " { return nil } hash , err : = Etag Hash ( data ) if err ! = nil { return err } if hash ! = match { return fmt . Errorf ( " " , hash , match ) } return nil } 
func HTTPClient ( certificate string , proxy proxy Func ) ( * http . Client , error ) { var err error var cert * x 5 0 9 . Certificate if certificate ! = " " { cert Block , _ : = pem . Decode ( [ ] byte ( certificate ) ) if cert Block = = nil { return nil , fmt . Errorf ( " " ) } cert , err = x 5 0 9 . Parse Certificate ( cert Block . Bytes ) if err ! = nil { return nil , err } } tls Config , err : = shared . Get TLSConfig ( " " , " " , " " , cert ) if err ! = nil { return nil , err } tr : = & http . Transport { TLSClient Config : tls Config , Dial : shared . RFC 3 4 9 3Dialer , Proxy : proxy , Disable Keep Alives : true , } myhttp : = http . Client { Transport : tr , } return nil } return & myhttp , nil } 
func Check Trust State ( cert x 5 0 9 . Certificate , trusted Certs map [ string ] x 5 0 9 . Certificate ) ( bool , string ) { } for k , v : = range trusted Certs { if bytes . Compare ( cert . Raw , v . Raw ) = = 0 { logger . Debug ( " " , log . Ctx { " " : k } ) return true , k } } return false , " " } 
func Is Recursion Request ( r * http . Request ) bool { recursion Str : = r . Form Value ( " " ) recursion , err : = strconv . Atoi ( recursion Str ) if err ! = nil { return false } return recursion ! = 0 } 
func Listen Addresses ( value string ) ( [ ] string , error ) { addresses : = make ( [ ] string , 0 ) if value = = " " { return addresses , nil } local Host , local Port , err : = net . Split Host Port ( value ) if err ! = nil { local Host = value local Port = shared . Default Port } if local Host = = " " | | local Host = = " " | | local Host = = " " { ifaces , err : = net . Interfaces ( ) if err ! = nil { return addresses , err } for _ , i : = range ifaces { addrs , err : = i . Addrs ( ) if err ! = nil { continue } for _ , addr : = range addrs { var ip net . IP switch v : = addr . ( type ) { case * net . IPNet : ip = v . IP case * net . IPAddr : ip = v . IP } if ! ip . Is Global Unicast ( ) { continue } if ip . To 4 ( ) = = nil { if local Host = = " " { continue } addresses = append ( addresses , fmt . Sprintf ( " " , ip , local Port ) ) } else { addresses = append ( addresses , fmt . Sprintf ( " " , ip , local Port ) ) } } } } else { if strings . Contains ( local Host , " " ) { addresses = append ( addresses , fmt . Sprintf ( " " , local Host , local Port ) ) } else { addresses = append ( addresses , fmt . Sprintf ( " " , local Host , local Port ) ) } } return addresses , nil } 
func Get Listeners ( start int ) [ ] net . Listener { defer func ( ) { os . Unsetenv ( " " ) os . Unsetenv ( " " ) } ( ) pid , err : = strconv . Atoi ( os . Getenv ( " " ) ) if err ! = nil { return nil } if pid ! = os . Getpid ( ) { return nil } fds , err : = strconv . Atoi ( os . Getenv ( " " ) ) if err ! = nil { return nil } listeners : = [ ] net . Listener { } for i : = start ; i < start + fds ; i + + { syscall . Close On Exec ( i ) file : = os . New File ( uintptr ( i ) , fmt . Sprintf ( " " , i ) ) listener , err : = net . File Listener ( file ) if err ! = nil { continue } listeners = append ( listeners , listener ) } return listeners } 
func internal SQLGet ( d * Daemon , r * http . Request ) Response { database : = r . Form Value ( " " ) if ! shared . String In Slice ( database , [ ] string { " " , " " } ) { return Bad Request ( fmt . Errorf ( " " ) ) } schema Form Value : = r . Form Value ( " " ) schema Only , err : = strconv . Atoi ( schema Form Value ) if err ! = nil { schema Only = 0 } var schema string var db * sql . DB if database = = " " { db = d . cluster . DB ( ) schema = cluster . Fresh Schema ( ) } else { db = d . db . DB ( ) schema = node . Fresh Schema ( ) } tx , err : = db . Begin ( ) if err ! = nil { return Smart Error ( errors . Wrap ( err , " " ) ) } defer tx . Rollback ( ) dump , err : = query . Dump ( tx , schema , schema Only = = 1 ) if err ! = nil { return Smart Error ( errors . Wrapf ( err , " " , database ) ) } return Sync Response ( true , internal SQLDump { Text : dump } ) } 
func internal SQLPost ( d * Daemon , r * http . Request ) Response { req : = & internal SQLQuery { } if err ! = nil { return Bad Request ( err ) } if ! shared . String In Slice ( req . Database , [ ] string { " " , " " } ) { return Bad Request ( fmt . Errorf ( " " ) ) } if req . Query = = " " { return Bad Request ( fmt . Errorf ( " " ) ) } var db * sql . DB if req . Database = = " " { db = d . cluster . DB ( ) } else { db = d . db . DB ( ) } batch : = internal SQLBatch { } if req . Query = = " " { d . gateway . Sync ( ) return Sync Response ( true , batch ) } for _ , query : = range strings . Split ( req . Query , " " ) { query = strings . Trim Left ( query , " " ) if query = = " " { continue } result : = internal SQLResult { } tx , err : = db . Begin ( ) if err ! = nil { return Smart Error ( err ) } if strings . Has Prefix ( strings . To Upper ( query ) , " " ) { err = internal SQLSelect ( tx , query , & result ) tx . Rollback ( ) } else { err = internal SQLExec ( tx , query , & result ) if err ! = nil { tx . Rollback ( ) } else { err = tx . Commit ( ) } } if err ! = nil { return Smart Error ( err ) } batch . Results = append ( batch . Results , result ) } return Sync Response ( true , batch ) } 
func Key Pair And CA ( dir , prefix string , kind Cert Kind ) ( * Cert Info , error ) { cert Filename : = filepath . Join ( dir , prefix + " " ) key Filename : = filepath . Join ( dir , prefix + " " ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } var ca * x 5 0 9 . Certificate if Path Exists ( ca Filename ) { ca , err = Read Cert ( ca Filename ) if err ! = nil { return nil , err } } info : = & Cert Info { keypair : keypair , ca : ca , } return info , nil } 
func ( c * Cert Info ) Public Key ( ) [ ] byte { data : = c . Key Pair ( ) . Certificate [ 0 ] return pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : data } ) } 
func ( c * Cert Info ) Private Key ( ) [ ] byte { ec Key , ok : = c . Key Pair ( ) . Private Key . ( * ecdsa . Private Key ) if ok { data , err : = x 5 0 9 . Marshal ECPrivate Key ( ec Key ) if err ! = nil { return nil } return pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : data } ) } rsa Key , ok : = c . Key Pair ( ) . Private Key . ( * rsa . Private Key ) if ok { data : = x 5 0 9 . Marshal PKCS 1Private Key ( rsa Key ) return pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : data } ) } return nil } 
func ( c * Cert Info ) Fingerprint ( ) string { fingerprint , err : = Cert Fingerprint Str ( string ( c . Public Key ( ) ) ) } return fingerprint } 
func mynames ( ) ( [ ] string , error ) { h , err : = os . Hostname ( ) if err ! = nil { return nil , err } ret : = [ ] string { h } ifs , err : = net . Interfaces ( ) if err ! = nil { return nil , err } for _ , iface : = range ifs { if Is Loopback ( & iface ) { continue } addrs , err : = iface . Addrs ( ) if err ! = nil { return nil , err } for _ , addr : = range addrs { ret = append ( ret , addr . String ( ) ) } } return ret , nil } 
func Gen Cert ( certf string , keyf string , certtype bool ) error { dir : = path . Dir ( certf ) err : = os . Mkdir All ( dir , 0 7 5 0 ) if err ! = nil { return err } dir = path . Dir ( keyf ) err = os . Mkdir All ( dir , 0 7 5 0 ) if err ! = nil { return err } cert Bytes , key Bytes , err : = Generate Mem Cert ( certtype ) if err ! = nil { return err } cert Out , err : = os . Create ( certf ) if err ! = nil { return fmt . Errorf ( " " , certf , err ) } cert Out . Write ( cert Bytes ) cert Out . Close ( ) key Out , err : = os . Open File ( keyf , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 0 0 ) if err ! = nil { return fmt . Errorf ( " " , keyf , err ) } key Out . Write ( key Bytes ) key Out . Close ( ) return nil } 
func Generate Mem Cert ( client bool ) ( [ ] byte , [ ] byte , error ) { privk , err : = ecdsa . Generate Key ( elliptic . P 3 8 4 ( ) , rand . Reader ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } hosts , err : = mynames ( ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } valid From : = time . Now ( ) valid To : = valid From . Add ( 1 0 * 3 6 5 * 2 4 * time . Hour ) serial Number Limit : = new ( big . Int ) . Lsh ( big . New Int ( 1 ) , 1 2 8 ) serial Number , err : = rand . Int ( rand . Reader , serial Number Limit ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } user Entry , err : = user . Current ( ) var username string if err = = nil { username = user Entry . Username if username = = " " { username = " " } } else { username = " " } hostname , err : = os . Hostname ( ) if err ! = nil { hostname = " " } template : = x 5 0 9 . Certificate { Serial Number : serial Number , Subject : pkix . Name { Organization : [ ] string { " " } , Common Name : fmt . Sprintf ( " " , username , hostname ) , } , Not Before : valid From , Not After : valid To , Key Usage : x 5 0 9 . Key Usage Key Encipherment | x 5 0 9 . Key Usage Digital Signature , Basic Constraints Valid : true , } if client { template . Ext Key Usage = [ ] x 5 0 9 . Ext Key Usage { x 5 0 9 . Ext Key Usage Client Auth } } else { template . Ext Key Usage = [ ] x 5 0 9 . Ext Key Usage { x 5 0 9 . Ext Key Usage Server Auth } } for _ , h : = range hosts { if ip , _ , err : = net . Parse CIDR ( h ) ; err = = nil { if ! ip . Is Link Local Unicast ( ) & & ! ip . Is Link Local Multicast ( ) { template . IPAddresses = append ( template . IPAddresses , ip ) } } else { template . DNSNames = append ( template . DNSNames , h ) } } der Bytes , err : = x 5 0 9 . Create Certificate ( rand . Reader , & template , & template , & privk . Public Key , privk ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } data , err : = x 5 0 9 . Marshal ECPrivate Key ( privk ) if err ! = nil { return nil , nil , err } cert : = pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : der Bytes } ) key : = pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : data } ) return cert , key , nil } 
func Print Server Info ( c lxd . Container Server ) error { server , _ , err : = c . Get Server ( ) if err ! = nil { return err } env : = server . Environment fmt . Printf ( " \n " ) fmt . Printf ( " \n " , env . Server ) fmt . Printf ( " \n " , env . Server Version ) fmt . Printf ( " \n " , env . Kernel ) fmt . Printf ( " \n " , env . Kernel Architecture ) fmt . Printf ( " \n " , env . Kernel Version ) fmt . Printf ( " \n " , env . Storage ) fmt . Printf ( " \n " , env . Storage Version ) fmt . Printf ( " \n " , env . Driver ) fmt . Printf ( " \n " , env . Driver Version ) fmt . Printf ( " \n " ) return nil } 
func Launch Containers ( c lxd . Container Server , count int , parallel int , image string , privileged bool , start bool , freeze bool ) ( time . Duration , error ) { var duration time . Duration batch Size , err : = get Batch Size ( parallel ) if err ! = nil { return duration , err } print Test Config ( count , batch Size , image , privileged , freeze ) fingerprint , err : = ensure Image ( c , image ) if err ! = nil { return duration , err } batch Start : = func ( index int , wg * sync . Wait Group ) { defer wg . Done ( ) name : = get Container Name ( count , index ) err : = create Container ( c , fingerprint , name , privileged ) if err ! = nil { logf ( " " , name , err ) return } if start { err : = start Container ( c , name ) if err ! = nil { logf ( " " , name , err ) return } if freeze { err : = freeze Container ( c , name ) if err ! = nil { logf ( " " , name , err ) return } } } } duration = process Batch ( count , batch Size , batch Start ) return duration , nil } 
func Create Containers ( c lxd . Container Server , count int , parallel int , fingerprint string , privileged bool ) ( time . Duration , error ) { var duration time . Duration batch Size , err : = get Batch Size ( parallel ) if err ! = nil { return duration , err } batch Create : = func ( index int , wg * sync . Wait Group ) { defer wg . Done ( ) name : = get Container Name ( count , index ) err : = create Container ( c , fingerprint , name , privileged ) if err ! = nil { logf ( " " , name , err ) return } } duration = process Batch ( count , batch Size , batch Create ) return duration , nil } 
func Get Containers ( c lxd . Container Server ) ( [ ] api . Container , error ) { containers : = [ ] api . Container { } all Containers , err : = c . Get Containers ( ) if err ! = nil { return containers , err } for _ , container : = range all Containers { if container . Config [ user Config Key ] = = " " { containers = append ( containers , container ) } } return containers , nil } 
func Start Containers ( c lxd . Container Server , containers [ ] api . Container , parallel int ) ( time . Duration , error ) { var duration time . Duration batch Size , err : = get Batch Size ( parallel ) if err ! = nil { return duration , err } count : = len ( containers ) logf ( " " , count ) batch Start : = func ( index int , wg * sync . Wait Group ) { defer wg . Done ( ) container : = containers [ index ] if ! container . Is Active ( ) { err : = start Container ( c , container . Name ) if err ! = nil { logf ( " " , container . Name , err ) return } } } duration = process Batch ( count , batch Size , batch Start ) return duration , nil } 
func Params ( n int ) string { tokens : = make ( [ ] string , n ) for i : = 0 ; i < n ; i + + { tokens [ i ] = " " } return fmt . Sprintf ( " " , strings . Join ( tokens , " " ) ) } 
func set Query Param ( uri , param , value string ) ( string , error ) { fields , err : = url . Parse ( uri ) if err ! = nil { return " " , err } values : = fields . Query ( ) values . Set ( param , url . Query Escape ( value ) ) fields . Raw Query = values . Encode ( ) return fields . String ( ) , nil } 
func ( r * Protocol LXD ) Get Images ( ) ( [ ] api . Image , error ) { images : = [ ] api . Image { } _ , err : = r . query Struct ( " " , " " , nil , " " , & images ) if err ! = nil { return nil , err } return images , nil } 
func ( r * Protocol LXD ) Get Image Fingerprints ( ) ( [ ] string , error ) { urls : = [ ] string { } if err ! = nil { return nil , err } for _ , url : = range urls { fields : = strings . Split ( url , " " ) fingerprints = append ( fingerprints , fields [ len ( fields ) - 1 ] ) } return fingerprints , nil } 
func ( r * Protocol LXD ) Get Image ( fingerprint string ) ( * api . Image , string , error ) { return r . Get Private Image ( fingerprint , " " ) } 
func ( r * Protocol LXD ) Get Image File ( fingerprint string , req Image File Request ) ( * Image File Response , error ) { return r . Get Private Image File ( fingerprint , " " , req ) } 
func ( r * Protocol LXD ) Get Image Secret ( fingerprint string ) ( string , error ) { op , err : = r . Create Image Secret ( fingerprint ) if err ! = nil { return " " , err } op API : = op . Get ( ) return op API . Metadata [ " " ] . ( string ) , nil } 
func ( r * Protocol LXD ) Get Private Image ( fingerprint string , secret string ) ( * api . Image , string , error ) { image : = api . Image { } var err error path , err = r . set Query Attributes ( path ) if err ! = nil { return nil , " " , err } if secret ! = " " { path , err = set Query Param ( path , " " , secret ) if err ! = nil { return nil , " " , err } } if err ! = nil { return nil , " " , err } return & image , etag , nil } 
func ( r * Protocol LXD ) Get Private Image File ( fingerprint string , secret string , req Image File Request ) ( * Image File Response , error ) { } uri : = fmt . Sprintf ( " " , url . Query Escape ( fingerprint ) ) var err error uri , err = r . set Query Attributes ( uri ) if err ! = nil { return nil , err } if err = = nil { resp , err : = lxd Download Image ( fingerprint , unix URI , r . http User Agent , devlxd HTTP , req ) if err = = nil { return resp , nil } } } if secret ! = " " { uri , err = set Query Param ( uri , " " , secret ) if err ! = nil { return nil , err } } return lxd Download Image ( fingerprint , uri , r . http User Agent , r . http , req ) } 
func ( r * Protocol LXD ) Get Image Aliases ( ) ( [ ] api . Image Aliases Entry , error ) { aliases : = [ ] api . Image Aliases Entry { } if err ! = nil { return nil , err } return aliases , nil } 
func ( r * Protocol LXD ) Get Image Alias ( name string ) ( * api . Image Aliases Entry , string , error ) { alias : = api . Image Aliases Entry { } if err ! = nil { return nil , " " , err } return & alias , etag , nil } 
func ( r * Protocol LXD ) Create Image ( image api . Images Post , args * Image Create Args ) ( Operation , error ) { if image . Compression Algorithm ! = " " { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } if err ! = nil { return nil , err } return op , nil } } var content Type string if args . Rootfs File = = nil { content Type = " " } else { if err ! = nil { return nil , err } defer os . Remove ( tmpfile . Name ( ) ) if err ! = nil { return nil , err } _ , err = io . Copy ( fw , args . Meta File ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } _ , err = io . Copy ( fw , args . Rootfs File ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } _ , err = tmpfile . Seek ( 0 , 0 ) if err ! = nil { return nil , err } } , } , } } else { body = tmpfile } content Type = w . Form Data Content Type ( ) } if err ! = nil { return nil , err } req , err : = http . New Request ( " " , req URL , body ) if err ! = nil { return nil , err } if image . Public { req . Header . Set ( " " , " " ) } if image . Filename ! = " " { req . Header . Set ( " " , image . Filename ) } if len ( image . Properties ) > 0 { img Props : = url . Values { } for k , v : = range image . Properties { img Props . Set ( k , v ) } req . Header . Set ( " " , img Props . Encode ( ) ) } } if err ! = nil { return nil , err } defer resp . Body . Close ( ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } return & op , nil } 
func ( r * Protocol LXD ) try Copy Image ( req api . Images Post , urls [ ] string ) ( Remote Operation , error ) { if len ( urls ) = = 0 { return nil , fmt . Errorf ( " " ) } rop : = remote Operation { ch Done : make ( chan bool ) , } go func ( ) { defer close ( rop . ch Post ) if rop . err ! = nil { return } if err ! = nil { return } alias . Name = entry . Name alias . Target = fingerprint r . Create Image Alias ( alias ) } } ( ) } errors : = map [ string ] error { } for _ , server URL : = range urls { req . Source . Server = server URL op , err : = r . Create Image ( req , nil ) if err ! = nil { errors [ server URL ] = err continue } rop . target Op = op for _ , handler : = range rop . handlers { rop . target Op . Add Handler ( handler ) } err = rop . target Op . Wait ( ) if err ! = nil { errors [ server URL ] = err continue } success = true break } if ! success { rop . err = remote Operation Error ( " " , errors ) } close ( rop . ch Done ) } ( ) return & rop , nil } 
func ( r * Protocol LXD ) Copy Image ( source Image Server , image api . Image , args * Image Copy Args ) ( Remote Operation , error ) { } if err ! = nil { return nil , err } if err ! = nil { return nil , err } req . Source . Secret = secret } req . Auto Update = args . Auto Update req . Public = args . Public if args . Copy Aliases { req . Aliases = image . Aliases if args . Aliases ! = nil { req . Aliases = append ( req . Aliases , args . Aliases . . . ) } } } return r . try Copy Image ( req , info . Addresses ) } 
func ( r * Protocol LXD ) Update Image ( fingerprint string , image api . Image Put , ETag string ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Image ( fingerprint string ) ( Operation , error ) { if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Refresh Image ( fingerprint string ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Create Image Alias ( alias api . Image Aliases Post ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Image Alias ( name string , alias api . Image Aliases Entry Put , ETag string ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Rename Image Alias ( name string , alias api . Image Aliases Entry Post ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Image Alias ( name string ) error { if err ! = nil { return err } return nil } 
func Open ( dir string ) ( * sql . DB , error ) { path : = filepath . Join ( dir , " " ) db , err : = sqlite Open ( path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return db , nil } 
func Ensure Schema ( db * sql . DB , dir string , hook schema . Hook ) ( int , error ) { backup Done : = false schema : = Schema ( ) schema . File ( filepath . Join ( dir , " " ) ) schema . Hook ( func ( version int , tx * sql . Tx ) error { if ! backup Done { logger . Infof ( " \ " \ " " ) path : = filepath . Join ( dir , " " ) err : = shared . File Copy ( path , path + " " ) if err ! = nil { return err } backup Done = true } if version = = - 1 { logger . Debugf ( " " ) } else { logger . Debugf ( " " , version , version + 1 ) } if err ! = nil { } } return nil } ) return schema . Ensure ( db ) } 
func Filesystem Detect ( path string ) ( string , error ) { fs : = syscall . Statfs _t { } err : = syscall . Statfs ( path , & fs ) if err ! = nil { return " " , err } switch fs . Type { case Filesystem Super Magic Btrfs : return " " , nil case Filesystem Super Magic Zfs : return " " , nil case Filesystem Super Magic Tmpfs : return " " , nil case Filesystem Super Magic Ext 4 : return " " , nil case Filesystem Super Magic Xfs : return " " , nil case Filesystem Super Magic Nfs : return " " , nil default : logger . Debugf ( " " , fs . Type ) return string ( fs . Type ) , nil } } 
func Schema ( ) * schema . Schema { schema : = schema . New From Map ( updates ) schema . Fresh ( fresh Schema ) return schema } 
func update From V 3 7 ( tx * sql . Tx ) error { count , err : = query . Count ( tx , " " , " " ) if err ! = nil { return errors . Wrap ( err , " " ) } if count = = 0 { } INSERT INTO config (key , value ) SELECT 'cluster .https _address ' , value FROM config WHERE key = 'core .https _address ' ` ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func Architecture Get Local ( ) ( string , error ) { uname , err : = shared . Uname ( ) if err ! = nil { return Architecture Default , err } return uname . Machine , nil } 
func New Controller ( url string , key string , machine string ) ( * Controller , error ) { base URL : = fmt . Sprintf ( " " , url ) if err ! = nil { } return nil , fmt . Errorf ( " " , base URL , strings . Split ( strings . Split ( err . Error ( ) , " " ) [ 1 ] , " " ) [ 0 ] ) } srv Raw , err : = gomaasapi . New Authenticated Client ( base URL , key ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } if len ( machines ) ! = 1 { return nil , fmt . Errorf ( " " , machine ) } c . srv = srv c . srv Raw = * srv Raw c . machine = machines [ 0 ] c . url = base URL return & c , err } 
func ( c * Controller ) Create Container ( name string , interfaces [ ] Container Interface ) error { if err ! = nil { return err } if err ! = nil { return err } if err ! = nil { return err } defer func ( ) { if success = = true { return } c . Delete Container ( name ) } ( ) if err ! = nil { return err } } if err ! = nil { return err } if ! ok { return fmt . Errorf ( " " , entry . MACAddress ( ) ) } if err ! = nil { return err } } } success = true return nil } 
func ( c * Controller ) Defined Container ( name string ) ( bool , error ) { devs , err : = c . machine . Devices ( gomaasapi . Devices Args { Hostname : [ ] string { name } } ) if err ! = nil { return false , err } if len ( devs ) = = 1 { return true , nil } return false , nil } 
func ( c * Controller ) Update Container ( name string , interfaces [ ] Container Interface ) error { if err ! = nil { return err } if err ! = nil { return err } device , err : = c . get Device ( name ) if err ! = nil { return err } for _ , entry : = range device . Interface Set ( ) { if ! ok { if err ! = nil { return err } continue } for _ , link : = range entry . Links ( ) { for _ , subnet : = range iface . Subnets { if subnet . Name = = link . Subnet ( ) . Name ( ) { if subnet . Address = = " " | | subnet . Address = = link . IPAddress ( ) { found = true } break } } if err ! = nil { return err } continue } } if ok { continue } if err ! = nil { return err } } } if ok { } if err ! = nil { return err } if err ! = nil { return err } } } return nil } 
func ( c * Controller ) Rename Container ( name string , new Name string ) error { device , err : = c . get Device ( name ) if err ! = nil { return err } if err ! = nil { return err } values : = url . Values { } values . Set ( " " , new Name ) _ , err = c . srv Raw . Put ( uri , values ) if err ! = nil { return err } return nil } 
func ( c * Controller ) Delete Container ( name string ) error { device , err : = c . get Device ( name ) if err ! = nil { return err } err = device . Delete ( ) if err ! = nil { return err } return nil } 
func New From Map ( versions To Updates map [ int ] Update ) * Schema { for version : = range versions To Updates { versions = append ( versions , version ) } for i , version : = range versions { } updates = append ( updates , versions To Updates [ version ] ) } return & Schema { updates : updates , } } 
func ( s * Schema ) Add ( update Update ) { s . updates = append ( s . updates , update ) } 
func ( s * Schema ) Ensure ( db * sql . DB ) ( int , error ) { var current int aborted : = false err : = query . Transaction ( db , func ( tx * sql . Tx ) error { err : = exec From File ( tx , s . path , s . hook ) if err ! = nil { return errors . Wrapf ( err , " " , s . path ) } err = ensure Schema Table Exists ( tx ) if err ! = nil { return err } current , err = query Current Version ( tx ) if err ! = nil { return err } if s . check ! = nil { err : = s . check ( current , tx ) if err = = Err Graceful Abort { return nil } if err ! = nil { return err } } if err ! = nil { return fmt . Errorf ( " " , err ) } } else { err = ensure Updates Are Applied ( tx , current , s . updates , s . hook ) if err ! = nil { return err } } return nil } ) if err ! = nil { return - 1 , err } if aborted { return current , Err Graceful Abort } return current , nil } 
func ( s * Schema ) Dump ( db * sql . DB ) ( string , error ) { var statements [ ] string err : = query . Transaction ( db , func ( tx * sql . Tx ) error { err : = check All Updates Are Applied ( tx , s . updates ) if err ! = nil { return err } statements , err = select Tables SQL ( tx ) return err } ) if err ! = nil { return " " , err } for i , statement : = range statements { statements [ i ] = format SQL ( statement ) } INSERT INTO schema (version , updated _at ) VALUES ( %d , strftime ( " % %s " ) ) ` , len ( s . updates ) ) ) return strings . Join ( statements , " \n " ) , nil } 
func ( s * Schema ) Trim ( version int ) [ ] Update { trimmed : = s . updates [ version : ] s . updates = s . updates [ : version ] s . fresh = " " return trimmed } 
func ( s * Schema ) Exercise Update ( version int , hook func ( * sql . DB ) ) ( * sql . DB , error ) { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } _ , err = s . Ensure ( db ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } _ , err = s . Ensure ( db ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return db , nil } 
func ensure Schema Table Exists ( tx * sql . Tx ) error { exists , err : = Does Schema Table Exist ( tx ) if err ! = nil { return fmt . Errorf ( " " , err ) } if ! exists { err : = create Schema Table ( tx ) if err ! = nil { return fmt . Errorf ( " " , err ) } } return nil } 
func query Current Version ( tx * sql . Tx ) ( int , error ) { versions , err : = select Schema Versions ( tx ) if err ! = nil { return - 1 , fmt . Errorf ( " " , err ) } if has Version ( 3 0 ) & & has Version ( 3 2 ) & & ! has Version ( 3 1 ) { err = insert Schema Version ( tx , 3 1 ) if err ! = nil { return - 1 , fmt . Errorf ( " " ) } versions , err = select Schema Versions ( tx ) if err ! = nil { return - 1 , fmt . Errorf ( " " , err ) } } if err ! = nil { return - 1 , fmt . Errorf ( " " , err ) } if count = = 1 { if err ! = nil { return - 1 , fmt . Errorf ( " " ) } versions = append ( versions , 3 8 ) } } current : = 0 if len ( versions ) > 0 { err = check Schema Versions Have No Holes ( versions ) if err ! = nil { return - 1 , err } current = versions [ len ( versions ) - 1 ] } return current , nil } 
func ensure Updates Are Applied ( tx * sql . Tx , current int , updates [ ] Update , hook Hook ) error { if current > len ( updates ) { return fmt . Errorf ( " " , current , len ( updates ) ) } } if err ! = nil { return fmt . Errorf ( " " , current , err ) } } err : = update ( tx ) if err ! = nil { return fmt . Errorf ( " " , current , err ) } current + + err = insert Schema Version ( tx , current ) if err ! = nil { return fmt . Errorf ( " " , current ) } } return nil } 
func check Schema Versions Have No Holes ( versions [ ] int ) error { } } return nil } 
func check All Updates Are Applied ( tx * sql . Tx , updates [ ] Update ) error { versions , err : = select Schema Versions ( tx ) if err ! = nil { return fmt . Errorf ( " " , err ) } if len ( versions ) = = 0 { return fmt . Errorf ( " " ) } err = check Schema Versions Have No Holes ( versions ) if err ! = nil { return err } current : = versions [ len ( versions ) - 1 ] if current ! = len ( updates ) { return fmt . Errorf ( " " , current , len ( updates ) ) } return nil } 
func format SQL ( statement string ) string { lines : = strings . Split ( statement , " \n " ) for i , line : = range lines { if strings . Contains ( line , " " ) { } lines [ i ] = strings . Replace ( line , " " , " \n " , - 1 ) } return strings . Join ( lines , " \n " ) } 
func Get Path Mode ( path string ) ( os . File Mode , error ) { s , err : = os . Open ( path ) if err ! = nil { return os . File Mode ( 0 0 0 0 ) , err } defer s . Close ( ) fi , err : = s . Stat ( ) if err ! = nil { return os . File Mode ( 0 0 0 0 ) , err } mode , _ , _ : = Get Owner Mode ( fi ) return mode , nil } 
func llistxattr ( path string , list [ ] byte ) ( sz int , err error ) { var _p 0 * byte _p 0 , err = syscall . Byte Ptr From String ( path ) if err ! = nil { return } var _p 1 unsafe . Pointer if len ( list ) > 0 { _p 1 = unsafe . Pointer ( & list [ 0 ] ) } else { _p 1 = unsafe . Pointer ( nil ) } r 0 , _ , e 1 : = syscall . Syscall ( syscall . SYS _LLISTXATTR , uintptr ( unsafe . Pointer ( _p 0 ) ) , uintptr ( _p 1 ) , uintptr ( len ( list ) ) ) sz = int ( r 0 ) if e 1 ! = 0 { err = e 1 } return } 
func Get All Xattr ( path string ) ( xattrs map [ string ] string , err error ) { e 1 : = fmt . Errorf ( " " ) if err ! = nil | | pre < 0 { return nil , err } if pre = = 0 { return nil , nil } dest : = make ( [ ] byte , pre ) post , err : = llistxattr ( path , dest ) if err ! = nil | | post < 0 { return nil , err } if post ! = pre { return nil , e 1 } split : = strings . Split ( string ( dest ) , " \x 0 0 " ) if split = = nil { return nil , fmt . Errorf ( " " ) } } xattrs = make ( map [ string ] string , len ( split ) ) for _ , x : = range split { xattr : = string ( x ) if err ! = nil | | pre < 0 { return nil , err } dest = make ( [ ] byte , pre ) post : = 0 if pre > 0 { post , err = syscall . Getxattr ( path , xattr , dest ) if err ! = nil | | post < 0 { return nil , err } } if post ! = pre { return nil , e 1 } xattrs [ xattr ] = string ( dest ) } return xattrs , nil } 
func Get Errno ( err error ) ( errno error , iserrno bool ) { sys Err , ok : = err . ( * os . Syscall Error ) if ok { return sys Err . Err , true } path Err , ok : = err . ( * os . Path Error ) if ok { return path Err . Err , true } tmp Errno , ok : = err . ( syscall . Errno ) if ok { return tmp Errno , true } return nil , false } 
func Uname ( ) ( * Utsname , error ) { uname : = syscall . Utsname { } err : = syscall . Uname ( & uname ) if err ! = nil { return nil , err } return & Utsname { Sysname : int Array To String ( uname . Sysname ) , Nodename : int Array To String ( uname . Nodename ) , Release : int Array To String ( uname . Release ) , Version : int Array To String ( uname . Version ) , Machine : int Array To String ( uname . Machine ) , Domainname : int Array To String ( uname . Domainname ) , } , nil } 
func ( s * storage Ceph ) do Cross Pool Container Copy ( target container , source container , container Only bool , refresh bool , refresh Snapshots [ ] container ) error { source Pool , err : = source . Storage Pool ( ) if err ! = nil { return err } if err ! = nil { return err } our Mount , err : = src Storage . Storage Pool Mount ( ) if err ! = nil { return err } if our Mount { defer src Storage . Storage Pool Umount ( ) } target Pool , err : = target . Storage Pool ( ) if err ! = nil { return err } var snapshots [ ] container if refresh { snapshots = refresh Snapshots } else { snapshots , err = source . Snapshots ( ) if err ! = nil { return err } if err ! = nil { return err } } if err ! = nil { return err } dest Container Mnt Point : = get Container Mount Point ( target . Project ( ) , target Pool , target . Name ( ) ) bwlimit : = s . pool . Config [ " " ] _ , err = rsync Local Copy ( src Snapshot Mnt Point , dest Container Mnt Point , bwlimit ) if err ! = nil { return err } msg , fs Freeze Err : = shared . Try Run Command ( " " , " " , dest Container Mnt Point ) logger . Debugf ( " " , msg , fs Freeze Err ) err = s . do Container Snapshot Create ( target . Project ( ) , fmt . Sprintf ( " " , target . Name ( ) , snap Only Name ) , target . Name ( ) ) if fs Freeze Err = = nil { msg , fs Freeze Err : = shared . Try Run Command ( " " , " " , dest Container Mnt Point ) logger . Debugf ( " " , msg , fs Freeze Err ) } if err ! = nil { return err } } } src Container Mnt Point : = get Container Mount Point ( source . Project ( ) , source Pool , source . Name ( ) ) _ , err = rsync Local Copy ( src Container Mnt Point , dest Container Mnt Point , bwlimit ) if err ! = nil { if ! refresh { s . Storage Pool Volume Delete ( ) } logger . Errorf ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name , err ) return err } return nil } 
func ( s * storage Ceph ) Container Backup Load ( info backup Info , data io . Read Seeker , tar Args [ ] string ) error { if err ! = nil { return err } if err ! = nil { return err } container Mnt Point : = get Container Mount Point ( info . Project , s . pool . Name , info . Name ) err = shared . Run Command With Fds ( data , nil , " " , args . . . ) if err ! = nil { logger . Errorf ( " \ " \ " \ " \ " " , cur , container Mnt Point , err ) return err } msg , fs Freeze Err : = shared . Try Run Command ( " " , " " , container Mnt Point ) logger . Debugf ( " " , msg , fs Freeze Err ) if fs Freeze Err = = nil { msg , fs Freeze Err : = shared . Try Run Command ( " " , " " , container Mnt Point ) logger . Debugf ( " " , msg , fs Freeze Err ) } if err ! = nil { return err } } err = shared . Run Command With Fds ( data , nil , " " , args . . . ) if err ! = nil { logger . Errorf ( " \ " \ " \ " \ " " , container Mnt Point , err ) return err } return nil } 
func Register Stmt ( sql string ) int { code : = len ( stmts ) stmts [ code ] = sql return code } 
func Prepare Stmts ( db * sql . DB ) ( map [ int ] * sql . Stmt , error ) { index : = map [ int ] * sql . Stmt { } for code , sql : = range stmts { stmt , err : = db . Prepare ( sql ) if err ! = nil { return nil , errors . Wrapf ( err , " " , sql ) } index [ code ] = stmt } return index , nil } 
func New Gateway ( db * db . Node , cert * shared . Cert Info , options . . . Option ) ( * Gateway , error ) { ctx , cancel : = context . With Cancel ( context . Background ( ) ) o : = new Options ( ) for _ , option : = range options { option ( o ) } gateway : = & Gateway { db : db , cert : cert , options : o , ctx : ctx , cancel : cancel , upgrade Ch : make ( chan struct { } , 1 6 ) , accept Ch : make ( chan net . Conn ) , store : & dqlite Server Store { } , } err : = gateway . init ( ) if err ! = nil { return nil , err } return gateway , nil } 
func ( g * Gateway ) Handler Funcs ( ) map [ string ] http . Handler Func { database : = func ( w http . Response Writer , r * http . Request ) { if ! tls Check Cert ( r , g . cert ) { http . Error ( w , " " , http . Status Forbidden ) return } err : = shared . Read To JSON ( r . Body , & nodes ) if err ! = nil { http . Error ( w , " " , http . Status Bad Request ) return } logger . Debugf ( " " , nodes ) err = g . db . Transaction ( func ( tx * db . Node Tx ) error { return tx . Raft Nodes Replace ( nodes ) } ) if err ! = nil { http . Error ( w , " " , http . Status Internal Server Error ) return } return } return } return } return } return } if err ! = nil { http . Error ( w , " " , http . Status Internal Server Error ) return } util . Write JSON ( w , map [ string ] string { " " : leader } , false ) return } if r . Header . Get ( " " ) ! = " " { http . Error ( w , " " , http . Status Bad Request ) return } hijacker , ok : = w . ( http . Hijacker ) if ! ok { http . Error ( w , " " , http . Status Internal Server Error ) return } conn , _ , err : = hijacker . Hijack ( ) if err ! = nil { message : = errors . Wrap ( err , " " ) . Error ( ) http . Error ( w , message , http . Status Internal Server Error ) return } if n , err : = conn . Write ( data ) ; err ! = nil | | n ! = len ( data ) { conn . Close ( ) return } g . accept Ch < - conn } raft : = func ( w http . Response Writer , r * http . Request ) { err : = g . db . Transaction ( func ( tx * db . Node Tx ) error { nodes , err : = tx . Raft Nodes ( ) if err ! = nil { return err } address = nodes [ 0 ] . Address return nil } ) if err ! = nil { http . Error ( w , " " , http . Status Internal Server Error ) return } url : = & url . URL { Scheme : " " , Path : r . URL . Path , Raw Query : r . URL . Raw Query , Host : address , } http . Redirect ( w , r , url . String ( ) , http . Status Permanent Redirect ) return } return } g . raft . Handler Func ( ) ( w , r ) } return map [ string ] http . Handler Func { database Endpoint : database , raft Endpoint : raft , } } 
func ( g * Gateway ) Dial Func ( ) dqlite . Dial Func { return func ( ctx context . Context , address string ) ( net . Conn , error ) { } return dqlite Network Dial ( ctx , address , g . cert ) } } 
func ( g * Gateway ) Shutdown ( ) error { logger . Debugf ( " " ) if g . raft ! = nil { err : = g . raft . Shutdown ( ) if err ! = nil { return errors . Wrap ( err , " " ) } } if g . server ! = nil { g . Sync ( ) g . server . Close ( ) } return nil } 
func ( g * Gateway ) Sync ( ) { if g . server = = nil { return } dir : = filepath . Join ( g . db . Dir ( ) , " " ) err : = g . server . Dump ( " " , dir ) if err ! = nil { } } 
func ( g * Gateway ) Reset ( cert * shared . Cert Info ) error { err : = g . Shutdown ( ) if err ! = nil { return err } err = os . Remove All ( filepath . Join ( g . db . Dir ( ) , " " ) ) if err ! = nil { return err } err = g . db . Transaction ( func ( tx * db . Node Tx ) error { return tx . Raft Nodes Replace ( nil ) } ) if err ! = nil { return err } g . cert = cert return g . init ( ) } 
func ( g * Gateway ) Leader Address ( ) ( string , error ) { } ctx , cancel : = context . With Timeout ( g . ctx , 5 * time . Second ) defer cancel ( ) if address ! = " " { return address , nil } time . Sleep ( time . Second ) } return " " , ctx . Err ( ) } if err ! = nil { return " " , err } addresses : = [ ] string { } err = g . db . Transaction ( func ( tx * db . Node Tx ) error { nodes , err : = tx . Raft Nodes ( ) if err ! = nil { return err } for _ , node : = range nodes { addresses = append ( addresses , node . Address ) } return nil } ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } if len ( addresses ) = = 0 { } for _ , address : = range addresses { url : = fmt . Sprintf ( " " , address , database Endpoint ) request , err : = http . New Request ( " " , url , nil ) if err ! = nil { return " " , err } request = request . With Context ( ctx ) client : = & http . Client { Transport : & http . Transport { TLSClient Config : config } } response , err : = client . Do ( request ) if err ! = nil { logger . Debugf ( " " , address ) continue } if response . Status Code ! = http . Status OK { logger . Debugf ( " " , address ) continue } info : = map [ string ] string { } err = shared . Read To JSON ( response . Body , & info ) if err ! = nil { logger . Debugf ( " " , address ) continue } leader : = info [ " " ] if leader = = " " { logger . Debugf ( " " , address ) continue } return leader , nil } return " " , fmt . Errorf ( " " ) } 
func ( g * Gateway ) init ( ) error { logger . Debugf ( " " ) raft , err : = new Raft ( g . db , g . cert , g . options . latency ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } if raft . Handler Func ( ) = = nil { g . memory Dial = dqlite Memory Dial ( listener ) g . store . in Memory = dqlite . New Inmem Server Store ( ) g . store . Set ( context . Background ( ) , [ ] dqlite . Server Info { { Address : " " } } ) } else { go run Dqlite Proxy ( listener , g . accept Ch ) g . store . in Memory = nil } provider : = & raft Address Provider { db : g . db } server , err : = dqlite . New Server ( raft . Raft ( ) , raft . Registry ( ) , listener , dqlite . With Server Address Provider ( provider ) , dqlite . With Server Log Func ( Dqlite Log ) , ) if err ! = nil { return errors . Wrap ( err , " " ) } g . server = server g . raft = raft } else { g . server = nil g . raft = nil g . store . in Memory = nil } g . store . on Disk = dqlite . New Server Store ( g . db . DB ( ) , " " , " " , " " ) return nil } 
func ( g * Gateway ) wait Leadership ( ) error { n : = 8 0 sleep : = 2 5 0 * time . Millisecond for i : = 0 ; i < n ; i + + { if g . raft . raft . State ( ) = = raft . Leader { return nil } time . Sleep ( sleep ) } return fmt . Errorf ( " " , time . Duration ( n ) * sleep ) } 
func ( g * Gateway ) current Raft Nodes ( ) ( [ ] db . Raft Node , error ) { if g . raft = = nil { return nil , raft . Err Not Leader } servers , err : = g . raft . Servers ( ) if err ! = nil { return nil , err } provider : = raft Address Provider { db : g . db } nodes : = make ( [ ] db . Raft Node , len ( servers ) ) for i , server : = range servers { address , err : = provider . Server Addr ( server . ID ) if err ! = nil { if err ! = db . Err No Such Object { return nil , errors . Wrap ( err , " " ) } } id , err : = strconv . Atoi ( string ( server . ID ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } nodes [ i ] . ID = int 6 4 ( id ) nodes [ i ] . Address = string ( address ) } return nodes , nil } 
func ( g * Gateway ) cached Raft Nodes ( ) ( [ ] string , error ) { var addresses [ ] string err : = g . db . Transaction ( func ( tx * db . Node Tx ) error { var err error addresses , err = tx . Raft Node Addresses ( ) return err } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return addresses , nil } 
func dqlite Memory Dial ( listener net . Listener ) dqlite . Dial Func { return func ( ctx context . Context , address string ) ( net . Conn , error ) { return net . Dial ( " " , listener . Addr ( ) . String ( ) ) } } 
func Dqlite Log ( l dqlite . Log Level , format string , a . . . interface { } ) { format = fmt . Sprintf ( " " , format ) switch l { case dqlite . Log Debug : logger . Debugf ( format , a . . . ) case dqlite . Log Info : logger . Debugf ( format , a . . . ) case dqlite . Log Warn : logger . Warnf ( format , a . . . ) case dqlite . Log Error : logger . Errorf ( format , a . . . ) } } 
func ( r * Response ) Metadata As Map ( ) ( map [ string ] interface { } , error ) { ret : = map [ string ] interface { } { } err : = r . Metadata As Struct ( & ret ) if err ! = nil { return nil , err } return ret , nil } 
func ( r * Response ) Metadata As Operation ( ) ( * Operation , error ) { op : = Operation { } err : = r . Metadata As Struct ( & op ) if err ! = nil { return nil , err } return & op , nil } 
func ( r * Response ) Metadata As String Slice ( ) ( [ ] string , error ) { sl : = [ ] string { } err : = r . Metadata As Struct ( & sl ) if err ! = nil { return nil , err } return sl , nil } 
func ( r * Response ) Metadata As Struct ( target interface { } ) error { return json . Unmarshal ( r . Metadata , & target ) } 
func ( r * CSVReport ) Load ( ) error { file , err : = os . Open ( r . Filename ) if err ! = nil { return err } defer file . Close ( ) reader : = csv . New Reader ( file ) for line : = 1 ; err ! = io . EOF ; line + + { record , err : = reader . Read ( ) if err = = io . EOF { break } else if err ! = nil { return err } err = r . add Record ( record ) if err ! = nil { return err } } logf ( " " , r . Filename ) return nil } 
func ( r * CSVReport ) Write ( ) error { file , err : = os . Open File ( r . Filename , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 4 0 ) if err ! = nil { return err } defer file . Close ( ) writer : = csv . New Writer ( file ) err = writer . Write All ( r . records ) if err ! = nil { return err } logf ( " " , r . Filename ) return nil } 
func ( r * CSVReport ) Add Record ( label string , elapsed time . Duration ) error { if len ( r . records ) = = 0 { r . add Record ( csv Fields ) } record : = [ ] string { fmt . Sprintf ( " " , time . Now ( ) . Unix Nano ( ) / int 6 4 ( time . Millisecond ) ) , return r . add Record ( record ) } 
func Load Config ( path string ) ( * Config , error ) { if err ! = nil { return nil , fmt . Errorf ( " " , err ) } err = yaml . Unmarshal ( content , & c ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for k , r : = range c . Remotes { if ! r . Public & & r . Auth Type = = " " { r . Auth Type = " " c . Remotes [ k ] = r } } } } c . Remotes [ k ] = v } if ok & & images . Protocol ! = Images Remote . Protocol & & images . Addr = = Images Remote . Addr { c . Remotes [ " " ] = Images Remote c . Save Config ( path ) } return c , nil } 
func ( c * Config ) Save Config ( path string ) error { err : = shared . Deep Copy ( c , & conf ) if err ! = nil { return fmt . Errorf ( " " , err ) } } delete ( conf . Remotes , k ) } if err ! = nil { return fmt . Errorf ( " " , err ) } defer f . Close ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } _ , err = f . Write ( data ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( l Chroot Loader ) Abs ( base string , name string ) string { return filepath . Clean ( fmt . Sprintf ( " " , l . Path , name ) ) } 
func ( l Chroot Loader ) Get ( path string ) ( io . Reader , error ) { if err ! = nil { return nil , err } base Path , err : = filepath . Eval Symlinks ( l . Path ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } return bytes . New Reader ( buf ) , nil } 
func ( c * Config ) Config Path ( paths . . . string ) string { path : = [ ] string { c . Config Dir } path = append ( path , paths . . . ) return filepath . Join ( path . . . ) } 
func ( c * Config ) Server Cert Path ( remote string ) string { return c . Config Path ( " " , fmt . Sprintf ( " " , remote ) ) } 
func New Config ( config Dir string , defaults bool ) * Config { config : = & Config { Config Dir : config Dir } if defaults { config . Remotes = Default Remotes config . Default Remote = " " } return config } 
func Determine Raft Node ( tx * db . Node Tx ) ( * db . Raft Node , error ) { config , err : = Config Load ( tx ) if err ! = nil { return nil , err } address : = config . Cluster Address ( ) } nodes , err : = tx . Raft Nodes ( ) if err ! = nil { return nil , err } } } } return nil , nil } 
func ( s * migration Source Ws ) check For Pre Dump Support ( ) ( bool , int ) { err : = s . container . Migrate ( & criu Migration Args ) if err ! = nil { } if tmp ! = " " { use _pre _dumps = shared . Is True ( tmp ) } var max _iterations int if tmp ! = " " { max _iterations , _ = strconv . Atoi ( tmp ) } else { } if max _iterations > 9 9 9 { } logger . Debugf ( " " , max _iterations ) return use _pre _dumps , max _iterations } 
func read Criu Stats Dump ( path string ) ( uint 6 4 , uint 6 4 , error ) { stats Dump : = shared . Add Slash ( path ) + " " in , err : = ioutil . Read File ( stats Dump ) if err ! = nil { logger . Errorf ( " " , err . Error ( ) ) return 0 , 0 , err } logger . Errorf ( msg ) return 0 , 0 , fmt . Errorf ( msg ) } logger . Errorf ( msg ) return 0 , 0 , fmt . Errorf ( msg ) } stats Entry : = & migration . Stats Entry { } if err = proto . Unmarshal ( in [ 1 2 : 1 2 + size ] , stats Entry ) ; err ! = nil { logger . Errorf ( " " , err . Error ( ) ) return 0 , 0 , err } written : = stats Entry . Get Dump ( ) . Get Pages Written ( ) skipped : = stats Entry . Get Dump ( ) . Get Pages Skipped Parent ( ) return written , skipped , nil } 
func ( s * migration Source Ws ) pre Dump Loop ( args * pre Dump Loop Args ) ( bool , error ) { logger . Debugf ( " " , args . pre Dump Dir ) final : = args . final err : = s . container . Migrate ( & criu Migration Args ) if err ! = nil { return final , err } state : = s . container . Daemon State ( ) err = Rsync Send ( ct Name , shared . Add Slash ( args . checkpoint Dir ) , s . criu Conn , nil , args . rsync Features , args . bwlimit , state . OS . Exec Path ) if err ! = nil { return final , err } dump Path + = shared . Add Slash ( args . dump Dir ) written , skipped _parent , err : = read Criu Stats Dump ( dump Path ) if err ! = nil { return final , err } logger . Debugf ( " " , written ) logger . Debugf ( " " , skipped _parent ) total _pages : = written + skipped _parent percentage _skipped : = int ( 1 0 0 - ( ( 1 0 0 * written ) / total _pages ) ) logger . Debugf ( " " , percentage _skipped ) tmp : = s . container . Expanded Config ( ) [ " " ] if tmp ! = " " { threshold , _ = strconv . Atoi ( tmp ) } else { } if percentage _skipped > threshold { logger . Debugf ( " " , percentage _skipped , threshold ) logger . Debugf ( " " ) final = true } sync : = migration . Migration Sync { Final Pre Dump : proto . Bool ( final ) , } data , err : = proto . Marshal ( & sync ) if err ! = nil { return final , err } err = s . criu Conn . Write Message ( websocket . Binary Message , data ) if err ! = nil { s . send Control ( err ) return final , err } logger . Debugf ( " " ) return final , nil } 
func ( r * Protocol Simple Streams ) Get Connection Info ( ) ( * Connection Info , error ) { info : = Connection Info { } info . Addresses = [ ] string { r . http Host } info . Certificate = r . http Certificate info . Protocol = " " info . URL = r . http Host return & info , nil } 
func new Root ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Long : `This is the entry point for all "go :generate " directives used in LXD 's source code . ` , Run E : func ( cmd * cobra . Command , args [ ] string ) error { return fmt . Errorf ( " " ) } , } cmd . Add Command ( new Db ( ) ) return cmd } 
func APIExtensions Count ( ) int { count : = len ( APIExtensions ) if artificial Bump ! = " " { n , err : = strconv . Atoi ( artificial Bump ) if err = = nil { count + = n } } return count } 
func Dot Go ( updates map [ int ] Update , name string ) error { if err ! = nil { return fmt . Errorf ( " " , err ) } schema : = New From Map ( updates ) _ , err = schema . Ensure ( db ) if err ! = nil { return err } dump , err : = schema . Dump ( db ) if err ! = nil { return err } file , err : = os . Create ( path . Join ( path . Dir ( filename ) , name + " " ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } pkg : = path . Base ( path . Dir ( filename ) ) _ , err = file . Write ( [ ] byte ( fmt . Sprintf ( dot Go Template , pkg , dump ) ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func Select URIs ( stmt * sql . Stmt , f func ( a . . . interface { } ) string , args . . . interface { } ) ( [ ] string , error ) { rows , err : = stmt . Query ( args . . . ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } defer rows . Close ( ) columns , err : = rows . Columns ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } params : = make ( [ ] interface { } , len ( columns ) ) dest : = make ( [ ] interface { } , len ( params ) ) for i : = range params { params [ i ] = " " dest [ i ] = & params [ i ] } uris : = [ ] string { } for rows . Next ( ) { err : = rows . Scan ( dest . . . ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } uri : = f ( params . . . ) uris = append ( uris , uri ) } err = rows . Err ( ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } return uris , nil } 
func Select Strings ( tx * sql . Tx , query string , args . . . interface { } ) ( [ ] string , error ) { values : = [ ] string { } scan : = func ( rows * sql . Rows ) error { var value string err : = rows . Scan ( & value ) if err ! = nil { return err } values = append ( values , value ) return nil } err : = scan Single Column ( tx , query , args , " " , scan ) if err ! = nil { return nil , err } return values , nil } 
func Insert Strings ( tx * sql . Tx , stmt string , values [ ] string ) error { n : = len ( values ) if n = = 0 { return nil } params : = make ( [ ] string , n ) args : = make ( [ ] interface { } , n ) for i , value : = range values { params [ i ] = " " args [ i ] = value } stmt = fmt . Sprintf ( stmt , strings . Join ( params , " " ) ) _ , err : = tx . Exec ( stmt , args . . . ) return err } 
func scan Single Column ( tx * sql . Tx , query string , args [ ] interface { } , type Name string , scan scan Func ) error { rows , err : = tx . Query ( query , args . . . ) if err ! = nil { return err } defer rows . Close ( ) for rows . Next ( ) { err : = scan ( rows ) if err ! = nil { return err } } err = rows . Err ( ) if err ! = nil { return err } return nil } 
func Caller Stack Handler ( format string , h Handler ) Handler { return Func Handler ( func ( r * Record ) error { s : = stack . Callers ( ) . Trim Below ( stack . Call ( r . Call PC [ 0 ] ) ) . Trim Runtime ( ) if len ( s ) > 0 { buf : = & bytes . Buffer { } buf . Write Byte ( ' [ ' ) for i , pc : = range s { if i > 0 { buf . Write Byte ( ' ' ) } fmt . Fprintf ( buf , format , pc ) } buf . Write Byte ( ' ] ' ) r . Ctx = append ( r . Ctx , " " , buf . String ( ) ) } return h . Log ( r ) } ) } 
func Lazy Handler ( h Handler ) Handler { return Func Handler ( func ( r * Record ) error { for i : = 1 ; i < len ( r . Ctx ) ; i + = 2 { lz , ok : = r . Ctx [ i ] . ( Lazy ) if ok { v , err : = evaluate Lazy ( lz ) if err ! = nil { had Err = true r . Ctx [ i ] = err } else { if cs , ok : = v . ( stack . Trace ) ; ok { v = cs . Trim Below ( stack . Call ( r . Call PC [ 0 ] ) ) . Trim Runtime ( ) } r . Ctx [ i ] = v } } } if had Err { r . Ctx = append ( r . Ctx , error Key , " " ) } return h . Log ( r ) } ) } 
func ( pc Call ) Format ( s fmt . State , c rune ) { fn : = runtime . Func For PC ( pc Fix ) if fn = = nil { fmt . Fprintf ( s , " " , c ) return } switch c { case 's ' , 'v ' : file , line : = fn . File Line ( pc Fix ) switch { case s . Flag ( ' # ' ) : imp Cnt : = strings . Count ( fn . Name ( ) , sep ) + 1 path Cnt : = strings . Count ( file , sep ) for path Cnt > imp Cnt { i : = strings . Index ( file , sep ) if i = = - 1 { break } file = file [ i + len ( sep ) : ] path Cnt - - } default : const sep = " " if i : = strings . Last Index ( file , sep ) ; i ! = - 1 { file = file [ i + len ( sep ) : ] } } fmt . Fprint ( s , file ) if c = = 'v ' { fmt . Fprint ( s , " " , line ) } case 'd ' : _ , line : = fn . File Line ( pc Fix ) fmt . Fprint ( s , line ) case 'n ' : name : = fn . Name ( ) if ! s . Flag ( ' + ' ) { const path Sep = " " if i : = strings . Last Index ( name , path Sep ) ; i ! = - 1 { name = name [ i + len ( path Sep ) : ] } const pkg Sep = " " if i : = strings . Index ( name , pkg Sep ) ; i ! = - 1 { name = name [ i + len ( pkg Sep ) : ] } } fmt . Fprint ( s , name ) } } 
func Callers ( ) Trace { pcs : = pool Buf ( ) pcs = pcs [ : cap ( pcs ) ] n : = runtime . Callers ( 2 , pcs ) cs : = make ( [ ] Call , n ) for i , pc : = range pcs [ : n ] { cs [ i ] = Call ( pc ) } put Pool Buf ( pcs ) return cs } 
func ( pc Call ) name ( ) string { pc Fix : = uintptr ( pc ) - 1 fn : = runtime . Func For PC ( pc Fix ) if fn = = nil { return " " } return fn . Name ( ) } 
func ( pcs Trace ) Format ( s fmt . State , c rune ) { s . Write ( [ ] byte ( " " ) ) for i , pc : = range pcs { if i > 0 { s . Write ( [ ] byte ( " " ) ) } pc . Format ( s , c ) } s . Write ( [ ] byte ( " " ) ) } 
func ( pcs Trace ) Trim Below ( pc Call ) Trace { for len ( pcs ) > 0 & & pcs [ 0 ] ! = pc { pcs = pcs [ 1 : ] } return pcs } 
func ( pcs Trace ) Trim Above ( pc Call ) Trace { for len ( pcs ) > 0 & & pcs [ len ( pcs ) - 1 ] ! = pc { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func ( pcs Trace ) Trim Below Name ( name string ) Trace { for len ( pcs ) > 0 & & pcs [ 0 ] . name ( ) ! = name { pcs = pcs [ 1 : ] } return pcs } 
func ( pcs Trace ) Trim Above Name ( name string ) Trace { for len ( pcs ) > 0 & & pcs [ len ( pcs ) - 1 ] . name ( ) ! = name { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func ( pcs Trace ) Trim Runtime ( ) Trace { for len ( pcs ) > 0 & & in Goroot ( pcs [ len ( pcs ) - 1 ] . file ( ) ) { pcs = pcs [ : len ( pcs ) - 1 ] } return pcs } 
func Shift Owner ( basepath string , path string , uid int , gid int ) error { cbasepath : = C . CString ( basepath ) defer C . free ( unsafe . Pointer ( cbasepath ) ) cpath : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cpath ) ) r : = C . shiftowner ( cbasepath , cpath , C . int ( uid ) , C . int ( gid ) ) if r ! = 0 { return fmt . Errorf ( " " , path ) } return nil } 
func Get Caps ( path string ) ( [ ] byte , error ) { xattrs , err : = shared . Get All Xattr ( path ) if err ! = nil { return nil , err } value Str , ok : = xattrs [ " " ] if ! ok { return nil , nil } return [ ] byte ( value Str ) , nil } 
func Set Caps ( path string , caps [ ] byte , uid int 6 4 ) error { cpath : = C . CString ( path ) defer C . free ( unsafe . Pointer ( cpath ) ) ccaps : = C . CString ( string ( caps ) ) defer C . free ( unsafe . Pointer ( ccaps ) ) r : = C . set _vfs _ns _caps ( cpath , ccaps , C . ssize _t ( len ( caps ) ) , C . uint 3 2 _t ( uid ) ) if r ! = 0 { return fmt . Errorf ( " " , path ) } return nil } 
func Shift ACL ( path string , shift Ids func ( uid int 6 4 , gid int 6 4 ) ( int 6 4 , int 6 4 ) ) error { err : = shift Acl Type ( path , C . ACL _TYPE _ACCESS , shift Ids ) if err ! = nil { return err } err = shift Acl Type ( path , C . ACL _TYPE _DEFAULT , shift Ids ) if err ! = nil { return err } return nil } 
func ( pt * Progress Reader ) Read ( p [ ] byte ) ( int , error ) { pt . Tracker . update ( n ) } return n , err } 
func Supported ( path string ) ( bool , error ) { if err ! = nil { return false , err } defer C . free ( unsafe . Pointer ( c Dev Path ) ) return C . quota _supported ( c Dev Path ) = = 0 , nil } 
func Get Project ( path string ) ( uint 3 2 , error ) { defer C . free ( unsafe . Pointer ( c Path ) ) id : = C . quota _get _path ( c Path ) if id < 0 { return 0 , fmt . Errorf ( " " , path ) } return uint 3 2 ( id ) , nil } 
func Set Project ( path string , id uint 3 2 ) error { defer C . free ( unsafe . Pointer ( c Path ) ) if C . quota _set _path ( c Path , C . uint 3 2 _t ( id ) ) ! = 0 { return fmt . Errorf ( " " , id , path ) } return nil } 
func Delete Project ( path string , id uint 3 2 ) error { if err ! = nil { return err } if err ! = nil { return err } return nil } 
func Get Project Usage ( path string , id uint 3 2 ) ( int 6 4 , error ) { if err ! = nil { return - 1 , err } defer C . free ( unsafe . Pointer ( c Dev Path ) ) size : = C . quota _get _usage ( c Dev Path , C . uint 3 2 _t ( id ) ) if size < 0 { return - 1 , fmt . Errorf ( " " , id , path ) } return int 6 4 ( size ) , nil } 
func Set Project Quota ( path string , id uint 3 2 , bytes int 6 4 ) error { if err ! = nil { return err } defer C . free ( unsafe . Pointer ( c Dev Path ) ) if C . quota _set ( c Dev Path , C . uint 3 2 _t ( id ) , C . int ( bytes / 1 0 2 4 ) ) ! = 0 { return fmt . Errorf ( " " , id , path ) } return nil } 
func backup Load By Name ( s * state . State , project , name string ) ( * backup , error ) { if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } } 
func backup Create ( s * state . State , args db . Container Backup Args , source Container container ) error { if err ! = nil { if err = = db . Err Already Defined { return fmt . Errorf ( " " , args . Name ) } return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { s . Cluster . Container Backup Remove ( args . Name ) return errors . Wrap ( err , " " ) } return nil } 
func ( b * backup ) Rename ( new Name string ) error { old Backup Path : = shared . Var Path ( " " , b . name ) new Backup Path : = shared . Var Path ( " " , new Name ) if ! shared . Path Exists ( backups Path ) { err : = os . Mkdir All ( backups Path , 0 7 0 0 ) if err ! = nil { return err } } if err ! = nil { return err } if empty { err : = os . Remove ( backups Path ) if err ! = nil { return err } } if err ! = nil { return err } return nil } 
func ( b * backup ) Delete ( ) error { return do Backup Delete ( b . state , b . name , b . container . Name ( ) ) } 
func backup Fix Storage Pool ( c * db . Cluster , b backup Info , use Default Pool bool ) error { var pool Name string if use Default Pool { if err ! = nil { return err } _ , v , err : = shared . Get Root Disk Device ( profile . Devices ) if err ! = nil { return err } pool Name = v [ " " ] } else { pool Name = b . Pool } if err ! = nil { return err } f : = func ( path string ) error { if err ! = nil { return err } root Disk Device Found : = false if backup . Container . Devices ! = nil { dev Name , _ , err : = shared . Get Root Disk Device ( backup . Container . Devices ) if err = = nil { backup . Container . Devices [ dev Name ] [ " " ] = pool Name root Disk Device Found = true } } if backup . Container . Expanded Devices ! = nil { dev Name , _ , err : = shared . Get Root Disk Device ( backup . Container . Expanded Devices ) if err = = nil { backup . Container . Expanded Devices [ dev Name ] [ " " ] = pool Name root Disk Device Found = true } } if ! root Disk Device Found { return fmt . Errorf ( " " ) } file , err : = os . Create ( path ) if err ! = nil { return err } defer file . Close ( ) data , err : = yaml . Marshal ( & backup ) if err ! = nil { return err } _ , err = file . Write ( data ) if err ! = nil { return err } return nil } err = f ( shared . Var Path ( " " , pool . Name , " " , b . Name , " " ) ) if err ! = nil { return err } for _ , snap : = range b . Snapshots { err = f ( shared . Var Path ( " " , pool . Name , " " , b . Name , snap , " " ) ) if err ! = nil { return err } } return nil } 
func Count ( tx * sql . Tx , table string , where string , args . . . interface { } ) ( int , error ) { stmt : = fmt . Sprintf ( " " , table ) if where ! = " " { stmt + = fmt . Sprintf ( " " , where ) } rows , err : = tx . Query ( stmt , args . . . ) if err ! = nil { return - 1 , err } defer rows . Close ( ) } var count int err = rows . Scan ( & count ) if err ! = nil { return - 1 , fmt . Errorf ( " " ) } if rows . Next ( ) { return - 1 , fmt . Errorf ( " " ) } err = rows . Err ( ) if err ! = nil { return - 1 , err } return count , nil } 
func Count All ( tx * sql . Tx ) ( map [ string ] int , error ) { tables , err : = Select Strings ( tx , " " ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } counts : = map [ string ] int { } for _ , table : = range tables { count , err : = Count ( tx , table , " " ) if err ! = nil { return nil , errors . Wrapf ( err , " " , table ) } counts [ table ] = count } return counts , nil } 
func Init TLSConfig ( ) * tls . Config { return & tls . Config { Min Version : tls . Version TLS 1 2 , Cipher Suites : [ ] uint 1 6 { tls . TLS _ECDHE _ECDSA _WITH _AES _ 2 5 6 _GCM _SHA 3 8 4 , tls . TLS _ECDHE _ECDSA _WITH _AES _ 2 5 6 _CBC _SHA , tls . TLS _ECDHE _ECDSA _WITH _AES _ 1 2 8 _GCM _SHA 2 5 6 , tls . TLS _ECDHE _ECDSA _WITH _AES _ 1 2 8 _CBC _SHA , tls . TLS _ECDHE _RSA _WITH _AES _ 2 5 6 _GCM _SHA 3 8 4 , tls . TLS _ECDHE _RSA _WITH _AES _ 2 5 6 _CBC _SHA , tls . TLS _ECDHE _RSA _WITH _AES _ 1 2 8 _GCM _SHA 2 5 6 , tls . TLS _ECDHE _RSA _WITH _AES _ 1 2 8 _CBC _SHA , } , Prefer Server Cipher Suites : true , } } 
func ( s * storage Lvm ) copy Container Thinpool ( target container , source container , readonly bool ) error { err : = s . create Snapshot Container ( target , source , readonly ) if err ! = nil { logger . Errorf ( " " , err ) return err } pool Name : = s . get On Disk Pool Name ( ) container Name : = target . Name ( ) container Lvm Name : = container Name To LVName ( container Name ) container Lv Dev Path : = get Lvm Dev Path ( target . Project ( ) , pool Name , storage Pool Volume APIEndpoint Containers , container Lvm Name ) if err ! = nil { return err } if our Umount { defer s . Container Mount ( source ) } } msg , err : = fs Generate New UUID ( LVFilesystem , container Lv Dev Path ) if err ! = nil { logger . Errorf ( " \ " \ " \ " \ " \ " \ " " , LVFilesystem , container Name , s . pool . Name , msg ) return err } return nil } 
func ( s * storage Lvm ) copy Container Lv ( target container , source container , readonly bool , refresh bool ) error { exists , err : = storage LVExists ( get Lvm Dev Path ( target . Project ( ) , s . get On Disk Pool Name ( ) , storage Pool Volume APIEndpoint Containers , container Name To LVName ( target . Name ( ) ) ) ) if err ! = nil { return err } if err ! = nil { return err } } target Name : = target . Name ( ) target Start , err : = target . Storage Start ( ) if err ! = nil { return err } if target Start { defer target . Storage Stop ( ) } source Name : = source . Name ( ) source Start , err : = source . Storage Start ( ) if err ! = nil { return err } if source Start { defer source . Storage Stop ( ) } source Pool , err : = source . Storage Pool ( ) if err ! = nil { return err } source Container Mnt Point : = get Container Mount Point ( source . Project ( ) , source Pool , source Name ) if source . Is Snapshot ( ) { source Container Mnt Point = get Snapshot Mount Point ( source . Project ( ) , source Pool , source Name ) } target Container Mnt Point : = get Container Mount Point ( target . Project ( ) , s . pool . Name , target Name ) if target . Is Snapshot ( ) { target Container Mnt Point = get Snapshot Mount Point ( source . Project ( ) , s . pool . Name , target Name ) } if source . Is Running ( ) { err = source . Freeze ( ) if err ! = nil { return err } defer source . Unfreeze ( ) } bwlimit : = s . pool . Config [ " " ] output , err : = rsync Local Copy ( source Container Mnt Point , target Container Mnt Point , bwlimit ) if err ! = nil { return fmt . Errorf ( " " , string ( output ) , err ) } if readonly { target Lvm Name : = container Name To LVName ( target Name ) pool Name : = s . get On Disk Pool Name ( ) output , err : = shared . Try Run Command ( " " , " " , fmt . Sprintf ( " " , pool Name , storage Pool Volume APIEndpoint Containers , target Lvm Name ) ) if err ! = nil { logger . Errorf ( " \ " \ " " , target Name , output ) return err } } return nil } 
func ( s * storage Lvm ) copy Container ( target container , source container , refresh bool ) error { target Pool , err : = target . Storage Pool ( ) if err ! = nil { return err } target Container Mnt Point : = get Container Mount Point ( target . Project ( ) , target Pool , target . Name ( ) ) err = create Container Mountpoint ( target Container Mnt Point , target . Path ( ) , target . Is Privileged ( ) ) if err ! = nil { return err } source Pool , err : = source . Storage Pool ( ) if err ! = nil { return err } if s . use Thinpool & & target Pool = = source Pool & & ! refresh { } else { } if err ! = nil { return err } err = target . Template Apply ( " " ) if err ! = nil { return err } return nil } 
func ( s * storage Lvm ) copy Volume ( source Pool string , source string ) error { target Mnt Point : = get Storage Pool Volume Mount Point ( s . pool . Name , s . volume . Name ) err : = os . Mkdir All ( target Mnt Point , 0 7 1 1 ) if err ! = nil { return err } if s . use Thinpool & & source Pool = = s . pool . Name { err = s . copy Volume Thinpool ( source , s . volume . Name , false ) } else { err = s . copy Volume Lv ( source Pool , source , s . volume . Name , false ) } if err ! = nil { return err } return nil } 
func ( r * Protocol Simple Streams ) Get Image Fingerprints ( ) ( [ ] string , error ) { if err ! = nil { return nil , err } for _ , img : = range images { fingerprints = append ( fingerprints , img . Fingerprint ) } return fingerprints , nil } 
func ( r * Protocol Simple Streams ) Get Image ( fingerprint string ) ( * api . Image , string , error ) { image , err : = r . ss Client . Get Image ( fingerprint ) if err ! = nil { return nil , " " , err } return image , " " , err } 
func ( r * Protocol Simple Streams ) Get Image File ( fingerprint string , req Image File Request ) ( * Image File Response , error ) { } if err = = nil { resp , err : = lxd Download Image ( fingerprint , unix URI , r . http User Agent , devlxd HTTP , req ) if err = = nil { return resp , nil } } } if err ! = nil { return nil , err } size , err : = shared . Download File Hash ( r . http , r . http User Agent , req . Progress Handler , req . Canceler , filename , url , hash , sha 2 5 6 . New ( ) , target ) if err ! = nil { } size , err = shared . Download File Hash ( r . http , r . http User Agent , req . Progress Handler , req . Canceler , filename , url , hash , sha 2 5 6 . New ( ) , target ) if err ! = nil { return - 1 , err } } return size , nil } if ok & & req . Meta File ! = nil { size , err : = download ( meta . Path , " " , meta . Sha 2 5 6 , req . Meta File ) if err ! = nil { return nil , err } parts : = strings . Split ( meta . Path , " " ) resp . Meta Name = parts [ len ( parts ) - 1 ] resp . Meta Size = size } if ok & & req . Rootfs File ! = nil { _ , err : = exec . Look Path ( " " ) if err = = nil & & req . Delta Source Retriever ! = nil { for filename , file : = range files { if ! strings . Has Prefix ( filename , " " ) { continue } src Path : = req . Delta Source Retriever ( src Fingerprint , " " ) if src Path = = " " { continue } if err ! = nil { return nil , err } defer delta File . Close ( ) defer os . Remove ( delta File . Name ( ) ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } defer patched File . Close ( ) defer os . Remove ( patched File . Name ( ) ) if err ! = nil { return nil , err } if err ! = nil { return nil , err } parts : = strings . Split ( rootfs . Path , " " ) resp . Rootfs Name = parts [ len ( parts ) - 1 ] resp . Rootfs Size = size downloaded = true } } if err ! = nil { return nil , err } parts : = strings . Split ( rootfs . Path , " " ) resp . Rootfs Name = parts [ len ( parts ) - 1 ] resp . Rootfs Size = size } } return & resp , nil } 
func ( r * Protocol Simple Streams ) Get Private Image ( fingerprint string , secret string ) ( * api . Image , string , error ) { return nil , " " , fmt . Errorf ( " " ) } 
func ( r * Protocol Simple Streams ) Get Private Image File ( fingerprint string , secret string , req Image File Request ) ( * Image File Response , error ) { return nil , fmt . Errorf ( " " ) } 
func ( r * Protocol Simple Streams ) Get Image Alias Names ( ) ( [ ] string , error ) { if err ! = nil { return nil , err } for _ , alias : = range aliases { names = append ( names , alias . Name ) } return names , nil } 
func ( r * Protocol Simple Streams ) Get Image Alias ( name string ) ( * api . Image Aliases Entry , string , error ) { alias , err : = r . ss Client . Get Alias ( name ) if err ! = nil { return nil , " " , err } return alias , " " , err } 
func Proto Recv ( ws * websocket . Conn , msg proto . Message ) error { mt , r , err : = ws . Next Reader ( ) if err ! = nil { return err } if mt ! = websocket . Binary Message { return fmt . Errorf ( " " ) } buf , err : = ioutil . Read All ( r ) if err ! = nil { return err } err = proto . Unmarshal ( buf , msg ) if err ! = nil { return err } return nil } 
func Proto Send ( ws * websocket . Conn , msg proto . Message ) error { w , err : = ws . Next Writer ( websocket . Binary Message ) if err ! = nil { return err } defer w . Close ( ) data , err : = proto . Marshal ( msg ) if err ! = nil { return err } err = shared . Write All ( w , data ) if err ! = nil { return err } return nil } 
func Proto Send Control ( ws * websocket . Conn , err error ) { message : = " " if err ! = nil { message = err . Error ( ) } msg : = Migration Control { Success : proto . Bool ( err = = nil ) , Message : proto . String ( message ) , } Proto Send ( ws , & msg ) } 
func Load Pre Clustering Data ( tx * sql . Tx ) ( * Dump , error ) { DELETE FROM containers _config WHERE container _id NOT IN (SELECT id FROM containers ) ; DELETE FROM containers _devices WHERE container _id NOT IN (SELECT id FROM containers ) ; DELETE FROM containers _devices _config WHERE container _device _id NOT IN (SELECT id FROM containers _devices ) ; DELETE FROM containers _profiles WHERE container _id NOT IN (SELECT id FROM containers ) ; DELETE FROM containers _profiles WHERE profile _id NOT IN (SELECT id FROM profiles ) ; DELETE FROM images _aliases WHERE image _id NOT IN (SELECT id FROM images ) ; DELETE FROM images _properties WHERE image _id NOT IN (SELECT id FROM images ) ; DELETE FROM images _source WHERE image _id NOT IN (SELECT id FROM images ) ; DELETE FROM networks _config WHERE network _id NOT IN (SELECT id FROM networks ) ; DELETE FROM profiles _config WHERE profile _id NOT IN (SELECT id FROM profiles ) ; DELETE FROM profiles _devices WHERE profile _id NOT IN (SELECT id FROM profiles ) ; DELETE FROM profiles _devices _config WHERE profile _device _id NOT IN (SELECT id FROM profiles _devices ) ; DELETE FROM storage _pools _config WHERE storage _pool _id NOT IN (SELECT id FROM storage _pools ) ; DELETE FROM storage _volumes WHERE storage _pool _id NOT IN (SELECT id FROM storage _pools ) ; DELETE FROM storage _volumes _config WHERE storage _volume _id NOT IN (SELECT id FROM storage _volumes ) ; ` ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , table : = range pre Clustering Tables { logger . Debugf ( " " , table ) data : = [ ] [ ] interface { } { } stmt : = fmt . Sprintf ( " " , table ) rows , err : = tx . Query ( stmt ) if err ! = nil { return nil , errors . Wrapf ( err , " " , table ) } columns , err : = rows . Columns ( ) if err ! = nil { rows . Close ( ) return nil , errors . Wrapf ( err , " " , table ) } dump . Schema [ table ] = columns for rows . Next ( ) { values : = make ( [ ] interface { } , len ( columns ) ) row : = make ( [ ] interface { } , len ( columns ) ) for i : = range values { row [ i ] = & values [ i ] } err : = rows . Scan ( row . . . ) if err ! = nil { rows . Close ( ) return nil , errors . Wrapf ( err , " " , table ) } data = append ( data , values ) } err = rows . Err ( ) if err ! = nil { rows . Close ( ) return nil , errors . Wrapf ( err , " " , table ) } rows . Close ( ) dump . Data [ table ] = data } return dump , nil } 
func ( c * Cluster ) Import Pre Clustering Data ( dump * Dump ) error { tx , err : = c . db . Begin ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { tx . Rollback ( ) return errors . Wrap ( err , " " ) } for _ , table : = range pre Clustering Tables { logger . Debugf ( " " , table ) for i , row : = range dump . Data [ table ] { for i , element : = range row { if ok { row [ i ] = string ( bytes ) } } columns : = dump . Schema [ table ] null Node ID : = false append Node ID : = func ( ) { columns = append ( columns , " " ) if null Node ID { row = append ( row , nil ) } else { row = append ( row , int 6 4 ( 1 ) ) } } switch table { case " " : skip : = false for i , column : = range columns { value , ok : = row [ i ] . ( string ) if ! ok { continue } if column = = " " & & shared . String In Slice ( value , keys ) { skip = true } } if skip { continue } case " " : append Node ID ( ) case " " : for i , column : = range columns { if column = = " " { index = i break } } key : = row [ index ] . ( string ) if ! shared . String In Slice ( key , Network Node Config Keys ) { null Node ID = true break } append Node ID ( ) case " " : for i , column : = range columns { if column = = " " { index = i break } } key : = row [ index ] . ( string ) if ! shared . String In Slice ( key , Storage Pool Node Config Keys ) { null Node ID = true break } append Node ID ( ) case " " : fallthrough case " " : columns = append ( columns , " " ) row = append ( row , storage Pool Created ) case " " : append Node ID ( ) } if shared . String In Slice ( table , pre Clustering Tables Requiring Project ID ) { row = append ( row , 1 ) } stmt : = fmt . Sprintf ( " " , table , strings . Join ( columns , " " ) ) stmt + = fmt . Sprintf ( " " , query . Params ( len ( columns ) ) ) result , err : = tx . Exec ( stmt , row . . . ) if err ! = nil { tx . Rollback ( ) return errors . Wrapf ( err , " " , i , table ) } n , err : = result . Rows Affected ( ) if err ! = nil { tx . Rollback ( ) return errors . Wrapf ( err , " " , i , table ) } if n ! = 1 { tx . Rollback ( ) return fmt . Errorf ( " " , i , table ) } import Node Association ( entity , columns , row , tx ) } } } return tx . Commit ( ) } 
func import Node Association ( entity string , columns [ ] string , row [ ] interface { } , tx * sql . Tx ) error { stmt : = fmt . Sprintf ( " " , entity , entity ) var id int 6 4 for i , column : = range columns { if column = = " " { id = row [ i ] . ( int 6 4 ) break } } if id = = 0 { return fmt . Errorf ( " " , entity ) } _ , err : = tx . Exec ( stmt , id ) if err ! = nil { return errors . Wrapf ( err , " " , entity ) } return nil } 
func ( er stdin Mirror ) Read ( p [ ] byte ) ( int , error ) { n , err : = er . r . Read ( p ) v : = rune ( p [ 0 ] ) if v = = ' \u 0 0 0 1 ' & & ! * er . found Escape { * er . found Escape = true return 0 , err } if v = = 'q ' & & * er . found Escape { select { case er . console Disconnect < - true : return 0 , err default : return 0 , err } } * er . found Escape = false return n , err } 
func do Containers Get From Node ( project , node string , cert * shared . Cert Info ) ( [ ] api . Container , error ) { f : = func ( ) ( [ ] api . Container , error ) { client , err : = cluster . Connect ( node , cert , true ) if err ! = nil { return nil , errors . Wrapf ( err , " " , node ) } client = client . Use Project ( project ) containers , err : = client . Get Containers ( ) if err ! = nil { return nil , errors . Wrapf ( err , " " , node ) } return containers , nil } timeout : = time . After ( 3 0 * time . Second ) done : = make ( chan struct { } ) var containers [ ] api . Container var err error go func ( ) { containers , err = f ( ) done < - struct { } { } } ( ) select { case < - timeout : err = fmt . Errorf ( " " , node ) case < - done : } return containers , err } 
func Dev Lxd Server ( d * Daemon ) * http . Server { return & http . Server { Handler : dev Lxd API ( d ) , Conn State : pid Mapper . Conn State Handler , } } 
func extract Underlying Fd ( unix Conn Ptr * net . Unix Conn ) ( int , error ) { conn : = reflect . Indirect ( reflect . Value Of ( unix Conn Ptr ) ) net Fd Ptr : = conn . Field By Name ( " " ) if ! net Fd Ptr . Is Valid ( ) { return - 1 , fmt . Errorf ( " " ) } net Fd : = reflect . Indirect ( net Fd Ptr ) fd : = net Fd . Field By Name ( " " ) if ! fd . Is Valid ( ) { if ! pfd Ptr . Is Valid ( ) { return - 1 , fmt . Errorf ( " " ) } pfd : = reflect . Indirect ( pfd Ptr ) fd = pfd . Field By Name ( " " ) if ! fd . Is Valid ( ) { return - 1 , fmt . Errorf ( " " ) } } return int ( fd . Int ( ) ) , nil } 
func extract Underlying Conn ( w http . Response Writer ) * net . Unix Conn { v : = reflect . Indirect ( reflect . Value Of ( w ) ) conn Ptr : = v . Field By Name ( " " ) conn : = reflect . Indirect ( conn Ptr ) rwc : = conn . Field By Name ( " " ) net Conn Ptr : = ( * net . Conn ) ( unsafe . Pointer ( rwc . Unsafe Addr ( ) ) ) unix Conn Ptr : = ( * net Conn Ptr ) . ( * net . Unix Conn ) return unix Conn Ptr } 
func Retry ( f func ( ) error ) error { for i : = 0 ; i < 5 ; i + + { err = f ( ) if err ! = nil { logger . Debugf ( " " , err ) if Is Retriable Error ( err ) { logger . Debugf ( " " , err ) time . Sleep ( 2 5 0 * time . Millisecond ) continue } } break } return err } 
func Is Retriable Error ( err error ) bool { err = errors . Cause ( err ) if err = = nil { return false } if err = = sqlite 3 . Err Locked | | err = = sqlite 3 . Err Busy { return true } if strings . Contains ( err . Error ( ) , " " ) { return true } if strings . Contains ( err . Error ( ) , " " ) { return true } } return false } 
func storage Pool Volume Used By Get ( s * state . State , project , volume Name string , volume Type Name string ) ( [ ] string , error ) { if snap { return [ ] string { fmt . Sprintf ( " " , version . APIVersion , c Name , s Name ) } , nil } return [ ] string { fmt . Sprintf ( " " , version . APIVersion , c Name ) } , nil } } if err ! = nil { return [ ] string { } , err } volume Used By : = [ ] string { } for _ , ct : = range cts Using Volume { volume Used By = append ( volume Used By , fmt . Sprintf ( " " , version . APIVersion , ct ) ) } profiles , err : = profiles Using Pool Volume Get Names ( s . Cluster , volume Name , volume Type Name ) if err ! = nil { return [ ] string { } , err } if len ( volume Used By ) = = 0 & & len ( profiles ) = = 0 { return [ ] string { } , nil } for _ , p Name : = range profiles { volume Used By = append ( volume Used By , fmt . Sprintf ( " " , version . APIVersion , p Name ) ) } return volume Used By , nil } 
func storage Pool Volume Snapshots Get ( s * state . State , pool string , volume string , vol Type int ) ( [ ] string , error ) { pool ID , err : = s . Cluster . Storage Pool Get ID ( pool ) if err ! = nil { return nil , err } snapshots , err : = s . Cluster . Storage Pool Volume Snapshots Get Type ( volume , vol Type , pool ID ) if err ! = nil { return nil , err } return snapshots , nil } 
func App Armor Profile ( ) string { contents , err : = ioutil . Read File ( " " ) if err = = nil { return strings . Trim Space ( string ( contents ) ) } return " " } 
func get Snapshot Subvolume Path ( project , pool Name string , container Name string ) string { return shared . Var Path ( " " , pool Name , " " , project Prefix ( project , container Name ) ) } 
func ( s * storage Btrfs ) Storage Pool Volume Create ( ) error { logger . Infof ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) _ , err : = s . Storage Pool Mount ( ) if err ! = nil { return err } is Snapshot : = shared . Is Snapshot ( s . volume . Name ) if is Snapshot { custom Subvolume Path = s . get Custom Snapshot Subvolume Path ( s . pool . Name ) } else { custom Subvolume Path = s . get Custom Subvolume Path ( s . pool . Name ) } if ! shared . Path Exists ( custom Subvolume Path ) { err : = os . Mkdir All ( custom Subvolume Path , 0 7 0 0 ) if err ! = nil { return err } } if is Snapshot { custom Subvolume Name = get Storage Pool Volume Snapshot Mount Point ( s . pool . Name , s . volume . Name ) } else { custom Subvolume Name = get Storage Pool Volume Mount Point ( s . pool . Name , s . volume . Name ) } err = btrfs Sub Volume Create ( custom Subvolume Name ) if err ! = nil { return err } if err ! = nil { return err } err = s . Storage Entity Set Quota ( storage Pool Volume Type Custom , size , nil ) if err ! = nil { return err } } logger . Infof ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) return nil } 
func ( s * storage Btrfs ) Container Storage Ready ( container container ) bool { container Mnt Point : = get Container Mount Point ( container . Project ( ) , s . pool . Name , container . Name ( ) ) return is Btrfs Sub Volume ( container Mnt Point ) } 
func ( s * storage Btrfs ) Container Create From Image ( container container , fingerprint string , tracker * ioprogress . Progress Tracker ) error { logger . Debugf ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) source : = s . pool . Config [ " " ] if source = = " " { return fmt . Errorf ( " \ " \ " " ) } _ , err : = s . Storage Pool Mount ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! shared . Path Exists ( container Subvolume Path ) { err : = os . Mkdir All ( container Subvolume Path , containers Dir Mode ) if err ! = nil { return errors . Wrap ( err , " " ) } } image Storage Pool Lock ID : = get Image Create Lock ID ( s . pool . Name , fingerprint ) lxd Storage Map Lock . Lock ( ) if wait Channel , ok : = lxd Storage Ongoing Operation Map [ image Storage Pool Lock ID ] ; ok { lxd Storage Map Lock . Unlock ( ) if _ , ok : = < - wait Channel ; ok { logger . Warnf ( " " ) } } else { lxd Storage Ongoing Operation Map [ image Storage Pool Lock ID ] = make ( chan bool ) lxd Storage Map Lock . Unlock ( ) var imgerr error if ! shared . Path Exists ( image Mnt Point ) | | ! is Btrfs Sub Volume ( image Mnt Point ) { imgerr = s . Image Create ( fingerprint , tracker ) } lxd Storage Map Lock . Lock ( ) if wait Channel , ok : = lxd Storage Ongoing Operation Map [ image Storage Pool Lock ID ] ; ok { close ( wait Channel ) delete ( lxd Storage Ongoing Operation Map , image Storage Pool Lock ID ) } lxd Storage Map Lock . Unlock ( ) if imgerr ! = nil { return errors . Wrap ( imgerr , " " ) } } err = s . btrfs Pool Volumes Snapshot ( image Mnt Point , container Subvolume Name , false , false ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } logger . Debugf ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) err = container . Template Apply ( " " ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func ( s * storage Btrfs ) Container Snapshot Rename ( snapshot Container container , new Name string ) error { logger . Debugf ( " \ " \ " " , s . volume . Name , s . volume . Name , new Name ) if err ! = nil { return err } new Snapshot Subvolume Name : = get Snapshot Mount Point ( snapshot Container . Project ( ) , s . pool . Name , new Name ) err = os . Rename ( old Snapshot Subvolume Name , new Snapshot Subvolume Name ) if err ! = nil { return err } logger . Debugf ( " \ " \ " " , s . volume . Name , s . volume . Name , new Name ) return nil } 
func ( s * storage Btrfs ) Container Snapshot Create Empty ( snapshot Container container ) error { logger . Debugf ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) if err ! = nil { return err } snapshot Subvolume Path : = get Snapshot Subvolume Path ( snapshot Container . Project ( ) , s . pool . Name , source Name ) snapshot Subvolume Name : = get Snapshot Mount Point ( snapshot Container . Project ( ) , s . pool . Name , snapshot Container . Name ( ) ) if ! shared . Path Exists ( snapshot Subvolume Path ) { err : = os . Mkdir All ( snapshot Subvolume Path , containers Dir Mode ) if err ! = nil { return err } } err = btrfs Sub Volume Create ( snapshot Subvolume Name ) if err ! = nil { return err } snapshot Mnt Point Symlink Target : = shared . Var Path ( " " , s . pool . Name , " " , project Prefix ( snapshot Container . Project ( ) , source Name ) ) snapshot Mnt Point Symlink : = shared . Var Path ( " " , project Prefix ( snapshot Container . Project ( ) , source Name ) ) if ! shared . Path Exists ( snapshot Mnt Point Symlink ) { err : = create Container Mountpoint ( snapshot Mnt Point Symlink Target , snapshot Mnt Point Symlink , snapshot Container . Is Privileged ( ) ) if err ! = nil { return err } } logger . Debugf ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) return nil } 
func btrfs Sub Volumes Delete ( subvol string ) error { if err ! = nil { return err } sort . Sort ( sort . Reverse ( sort . String Slice ( subsubvols ) ) ) for _ , subsubvol : = range subsubvols { err : = btrfs Sub Volume Delete ( path . Join ( subvol , subsubvol ) ) if err ! = nil { return err } } if err ! = nil { return err } return nil } 
func btrfs Snapshot ( source string , dest string , readonly bool ) error { var output string var err error if readonly { output , err = shared . Run Command ( " " , " " , " " , " " , source , dest ) } else { output , err = shared . Run Command ( " " , " " , " " , source , dest ) } if err ! = nil { return fmt . Errorf ( " " , source , dest , output , ) } return err } 
func is Btrfs Sub Volume ( subvol Path string ) bool { fs : = syscall . Stat _t { } err : = syscall . Lstat ( subvol Path , & fs ) if err ! = nil { return false } } return true } 
func Safe Load ( schema Schema , values map [ string ] string ) ( Map , error ) { m , err : = Load ( schema , values ) if err ! = nil { errors , ok : = err . ( Error List ) if ! ok { return m , err } for _ , error : = range errors { message : = fmt . Sprintf ( " " , error . Reason ) logger . Error ( message , log . Ctx { " " : error . Name } ) } } return m , nil } 
func Select Config ( tx * sql . Tx , table string , where string , args . . . interface { } ) ( map [ string ] string , error ) { query : = fmt . Sprintf ( " " , table ) if where ! = " " { query + = fmt . Sprintf ( " " , where ) } rows , err : = tx . Query ( query , args . . . ) if err ! = nil { return nil , err } defer rows . Close ( ) values : = map [ string ] string { } for rows . Next ( ) { var key string var value string err : = rows . Scan ( & key , & value ) if err ! = nil { return nil , err } values [ key ] = value } err = rows . Err ( ) if err ! = nil { return nil , err } return values , nil } 
func Update Config ( tx * sql . Tx , table string , values map [ string ] string ) error { changes : = map [ string ] string { } deletes : = [ ] string { } for key , value : = range values { if value = = " " { deletes = append ( deletes , key ) continue } changes [ key ] = value } err : = upsert Config ( tx , table , changes ) if err ! = nil { return errors . Wrap ( err , " " ) } err = delete Config ( tx , table , deletes ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func upsert Config ( tx * sql . Tx , table string , values map [ string ] string ) error { if len ( values ) = = 0 { return nil } query : = fmt . Sprintf ( " " , table ) exprs : = [ ] string { } params : = [ ] interface { } { } for key , value : = range values { exprs = append ( exprs , " " ) params = append ( params , key ) params = append ( params , value ) } query + = strings . Join ( exprs , " " ) _ , err : = tx . Exec ( query , params . . . ) return err } 
func delete Config ( tx * sql . Tx , table string , keys [ ] string ) error { n : = len ( keys ) if n = = 0 { return nil } query : = fmt . Sprintf ( " " , table , Params ( n ) ) values : = make ( [ ] interface { } , n ) for i , key : = range keys { values [ i ] = key } _ , err : = tx . Exec ( query , values . . . ) return err } 
func Format Section ( header string , content string ) string { out : = " " } } out + = line + " \n " } if header ! = " " { } else { } return out } 
func ( r * Protocol LXD ) Get Projects ( ) ( [ ] api . Project , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } projects : = [ ] api . Project { } if err ! = nil { return nil , err } return projects , nil } 
func ( r * Protocol LXD ) Get Project ( name string ) ( * api . Project , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } project : = api . Project { } if err ! = nil { return nil , " " , err } return & project , etag , nil } 
func ( r * Protocol LXD ) Create Project ( project api . Projects Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Project ( name string , project api . Project Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Rename Project ( name string , project api . Project Post ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return nil , err } return op , nil } 
func ( er Reader ) Read ( p [ ] byte ) ( int , error ) { again : n , err : = er . Reader . Read ( p ) if err = = nil { return n , nil } if ok & & ( errno = = syscall . EAGAIN | | errno = = syscall . EINTR ) { goto again } return n , err } 
func ( ew Writer ) Write ( p [ ] byte ) ( int , error ) { again : n , err : = ew . Writer . Write ( p ) if err = = nil { return n , nil } if ok & & ( errno = = syscall . EAGAIN | | errno = = syscall . EINTR ) { goto again } return n , err } 
func New Canceler ( ) * Canceler { c : = Canceler { } c . lock . Lock ( ) c . req Ch Cancel = make ( map [ * http . Request ] chan struct { } ) c . lock . Unlock ( ) return & c } 
func ( c * Canceler ) Cancelable ( ) bool { c . lock . Lock ( ) length : = len ( c . req Ch Cancel ) c . lock . Unlock ( ) return length > 0 } 
func ( c * Canceler ) Cancel ( ) error { if ! c . Cancelable ( ) { return fmt . Errorf ( " " ) } c . lock . Lock ( ) for req , ch : = range c . req Ch Cancel { close ( ch ) delete ( c . req Ch Cancel , req ) } c . lock . Unlock ( ) return nil } 
func Cancelable Download ( c * Canceler , client * http . Client , req * http . Request ) ( * http . Response , chan bool , error ) { ch Done : = make ( chan bool ) ch Cancel : = make ( chan struct { } ) if c ! = nil { c . lock . Lock ( ) c . req Ch Cancel [ req ] = ch Cancel c . lock . Unlock ( ) } req . Cancel = ch Cancel go func ( ) { < - ch Done if c ! = nil { c . lock . Lock ( ) delete ( c . req Ch Cancel , req ) c . lock . Unlock ( ) } } ( ) resp , err : = client . Do ( req ) return resp , ch Done , err } 
func cluster Get ( d * Daemon , r * http . Request ) Response { name : = " " err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error name , err = tx . Node Name ( ) return err } ) if err ! = nil { return Smart Error ( err ) } } member Config , err : = cluster Get Member Config ( d . cluster ) if err ! = nil { return Smart Error ( err ) } cluster : = api . Cluster { Server Name : name , Enabled : name ! = " " , Member Config : member Config , } return Sync Response ETag ( true , cluster , cluster ) } 
func cluster Get Member Config ( cluster * db . Cluster ) ( [ ] api . Cluster Member Config Key , error ) { var pools map [ string ] map [ string ] string var networks map [ string ] map [ string ] string keys : = [ ] api . Cluster Member Config Key { } err : = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error pools , err = tx . Storage Pools Node Config ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } networks , err = tx . Networks Node Config ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } return nil } ) if err ! = nil { return nil , err } for pool , config : = range pools { for key : = range config { if strings . Has Prefix ( key , " " ) { continue } key : = api . Cluster Member Config Key { Entity : " " , Name : pool , Key : key , Description : fmt . Sprintf ( " \ " \ " \ " \ " " , key , pool ) , } keys = append ( keys , key ) } } for network , config : = range networks { for key : = range config { if strings . Has Prefix ( key , " " ) { continue } key : = api . Cluster Member Config Key { Entity : " " , Name : network , Key : key , Description : fmt . Sprintf ( " \ " \ " \ " \ " " , key , network ) , } keys = append ( keys , key ) } } return keys , nil } 
func cluster Put ( d * Daemon , r * http . Request ) Response { req : = api . Cluster Put { } if err ! = nil { return Bad Request ( err ) } } if req . Server Name ! = " " & & ! req . Enabled { return Bad Request ( fmt . Errorf ( " " ) ) } } } return cluster Put Join ( d , req ) } 
func cluster Put Disable ( d * Daemon ) Response { if err ! = nil { return Smart Error ( err ) } if ! shared . Path Exists ( path ) { continue } err : = os . Remove ( path ) if err ! = nil { return Internal Error ( err ) } } cert , err : = util . Load Cert ( d . os . Var Dir ) if err ! = nil { return Internal Error ( errors . Wrap ( err , " " ) ) } err = d . gateway . Reset ( cert ) if err ! = nil { return Smart Error ( err ) } if err ! = nil { return Smart Error ( err ) } store : = d . gateway . Server Store ( ) d . cluster , err = db . Open Cluster ( " " , store , address , " " , d . config . Dqlite Setup Timeout , dqlite . With Dial Func ( d . gateway . Dial Func ( ) ) , dqlite . With Context ( d . gateway . Context ( ) ) , ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func cluster Init Member ( d , client lxd . Container Server , member Config [ ] api . Cluster Member Config Key ) error { data : = init Data Node { } if err ! = nil { return errors . Wrap ( err , " " ) } } } logger . Debugf ( " " , pool . Name ) post : = api . Storage Pools Post { Storage Pool Put : pool . Storage Pool Put , Driver : pool . Driver , Name : pool . Name , } delete ( post . Config , " " ) } if config . Name ! = pool . Name { continue } if ! shared . String In Slice ( config . Key , db . Storage Pool Node Config Keys ) { logger . Warnf ( " " , config . Key , config . Name ) continue } post . Config [ config . Key ] = config . Value } data . Storage Pools = append ( data . Storage Pools , post ) } if err ! = nil { return errors . Wrap ( err , " " ) } } post : = api . Networks Post { Network Put : network . Network Put , Managed : true , Name : network . Name , Type : network . Type , } } if config . Name ! = network . Name { continue } if ! shared . String In Slice ( config . Key , db . Network Node Config Keys ) { logger . Warnf ( " " , config . Key , config . Name ) continue } post . Config [ config . Key ] = config . Value } data . Networks = append ( data . Networks , post ) } revert , err : = init Data Node Apply ( d , data ) if err ! = nil { revert ( ) return errors . Wrap ( err , " " ) } return nil } 
func cluster Accept Member ( client lxd . Container Server , name , address string , schema , api Ext int , pools [ ] api . Storage Pool , networks [ ] api . Network ) ( * internal Cluster Post Accept Response , error ) { req : = internal Cluster Post Accept Request { Name : name , Address : address , Schema : schema , API : api Ext , Storage Pools : pools , Networks : networks , } info : = & internal Cluster Post Accept Response { } resp , _ , err : = client . Raw Query ( " " , " " , req , " " ) if err ! = nil { return nil , err } err = resp . Metadata As Struct ( & info ) if err ! = nil { return nil , err } return info , nil } 
func try Cluster Rebalance ( d * Daemon ) error { leader , err : = d . gateway . Leader Address ( ) if err ! = nil { } cert : = d . endpoints . Network Cert ( ) client , err : = cluster . Connect ( leader , cert , true ) if err ! = nil { return errors . Wrap ( err , " " ) } _ , _ , err = client . Raw Query ( " " , " " , nil , " " ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func internal Cluster Post Rebalance ( d * Daemon , r * http . Request ) Response { if err ! = nil { return Smart Error ( err ) } leader , err : = d . gateway . Leader Address ( ) if err ! = nil { return Internal Error ( err ) } if local Address ! = leader { logger . Debugf ( " " , leader ) url : = & url . URL { Scheme : " " , Path : " " , Host : leader , } return Sync Response Redirect ( url . String ( ) ) } logger . Debugf ( " " ) if err ! = nil { return Smart Error ( err ) } if address = = " " { return Sync Response ( true , nil ) } for _ , node : = range nodes { post . Raft Nodes = append ( post . Raft Nodes , internal Raft Node { ID : node . ID , Address : node . Address , } ) } cert : = d . endpoints . Network Cert ( ) client , err : = cluster . Connect ( address , cert , false ) if err ! = nil { return Smart Error ( err ) } _ , _ , err = client . Raw Query ( " " , " " , post , " " ) if err ! = nil { return Smart Error ( err ) } return Sync Response ( true , nil ) } 
func internal Cluster Post Promote ( d * Daemon , r * http . Request ) Response { req : = internal Cluster Post Promote Request { } if err ! = nil { return Bad Request ( err ) } } nodes : = make ( [ ] db . Raft Node , len ( req . Raft Nodes ) ) for i , node : = range req . Raft Nodes { nodes [ i ] . ID = node . ID nodes [ i ] . Address = node . Address } err = cluster . Promote ( d . State ( ) , d . gateway , nodes ) if err ! = nil { return Smart Error ( err ) } return Sync Response ( true , nil ) } 
func Packages ( ) ( map [ string ] * ast . Package , error ) { packages : = map [ string ] * ast . Package { } for _ , name : = range default Packages { pkg , err : = lex . Parse ( name ) if err ! = nil { return nil , errors . Wrapf ( err , " " , name ) } parts : = strings . Split ( name , " " ) packages [ parts [ len ( parts ) - 1 ] ] = pkg } return packages , nil } 
func Filters ( pkg * ast . Package , entity string ) [ ] [ ] string { objects : = pkg . Scope . Objects filters : = [ ] [ ] string { } prefix : = fmt . Sprintf ( " " , entity ) for name : = range objects { if ! strings . Has Prefix ( name , prefix ) { continue } rest : = name [ len ( prefix ) : ] filters = append ( filters , strings . Split ( rest , " " ) ) } sort . Slice Stable ( filters , func ( i , j int ) bool { return len ( filters [ i ] ) > len ( filters [ j ] ) } ) return filters } 
func Parse ( pkg * ast . Package , name string ) ( * Mapping , error ) { str : = find Struct ( pkg . Scope , name ) if str = = nil { return nil , fmt . Errorf ( " " , name ) } fields , err : = parse Struct ( str ) if err ! = nil { return nil , errors . Wrapf ( err , " " , name ) } m : = & Mapping { Package : pkg . Name , Name : name , Fields : fields , } return m , nil } 
func find Struct ( scope * ast . Scope , name string ) * ast . Struct Type { obj : = scope . Lookup ( name ) if obj = = nil { return nil } typ , ok : = obj . Decl . ( * ast . Type Spec ) if ! ok { return nil } str , ok : = typ . Type . ( * ast . Struct Type ) if ! ok { return nil } return str } 
func parse Struct ( str * ast . Struct Type ) ( [ ] * Field , error ) { fields : = make ( [ ] * Field , 0 ) for _ , f : = range str . Fields . List { if len ( f . Names ) = = 0 { if ! ok { continue } typ , ok : = ident . Obj . Decl . ( * ast . Type Spec ) if ! ok { continue } parent Str , ok : = typ . Type . ( * ast . Struct Type ) if ! ok { continue } parent Fields , err : = parse Struct ( parent Str ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } fields = append ( fields , parent Fields . . . ) continue } if len ( f . Names ) ! = 1 { return nil , fmt . Errorf ( " " , f . Names ) } field , err : = parse Field ( f ) if err ! = nil { return nil , err } fields = append ( fields , field ) } return fields , nil } 
func ( r * Protocol LXD ) Get Profile Names ( ) ( [ ] string , error ) { urls : = [ ] string { } if err ! = nil { return nil , err } for _ , url : = range urls { fields : = strings . Split ( url , " " ) names = append ( names , strings . Split ( fields [ len ( fields ) - 1 ] , " " ) [ 0 ] ) } return names , nil } 
func ( r * Protocol LXD ) Get Profiles ( ) ( [ ] api . Profile , error ) { profiles : = [ ] api . Profile { } if err ! = nil { return nil , err } return profiles , nil } 
func ( r * Protocol LXD ) Get Profile ( name string ) ( * api . Profile , string , error ) { profile : = api . Profile { } if err ! = nil { return nil , " " , err } return & profile , etag , nil } 
func ( r * Protocol LXD ) Create Profile ( profile api . Profiles Post ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Profile ( name string , profile api . Profile Put , ETag string ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Rename Profile ( name string , profile api . Profile Post ) error { if err ! = nil { return err } return nil } 
func Load ( schema Schema , values map [ string ] string ) ( Map , error ) { m : = Map { schema : schema , } return m , err } 
func ( m * Map ) Change ( changes map [ string ] interface { } ) ( map [ string ] string , error ) { values : = make ( map [ string ] string , len ( m . schema ) ) errors : = Error List { } for name , change : = range changes { key , ok : = m . schema [ name ] } } if s . Kind ( ) ! = reflect . String { errors . add ( name , nil , fmt . Sprintf ( " " , s . Kind ( ) ) ) continue } values [ name ] = change . ( string ) } if errors . Len ( ) > 0 { return nil , errors } if ! ok { values [ name ] = key . Default } } names , err : = m . update ( values ) changed : = map [ string ] string { } for _ , name : = range names { changed [ name ] = m . Get Raw ( name ) } return changed , err } 
func ( m * Map ) Dump ( ) map [ string ] interface { } { values : = map [ string ] interface { } { } for name , key : = range m . schema { value : = m . Get Raw ( name ) if value ! = key . Default { if key . Hidden { values [ name ] = true } else { values [ name ] = value } } } return values } 
func ( m * Map ) Get Raw ( name string ) string { key : = m . schema . must Get Key ( name ) value , ok : = m . values [ name ] if ! ok { value = key . Default } return value } 
func ( m * Map ) Get String ( name string ) string { m . schema . assert Key Type ( name , String ) return m . Get Raw ( name ) } 
func ( m * Map ) Get Bool ( name string ) bool { m . schema . assert Key Type ( name , Bool ) return shared . Is True ( m . Get Raw ( name ) ) } 
func ( m * Map ) Get Int 6 4 ( name string ) int 6 4 { m . schema . assert Key Type ( name , Int 6 4 ) n , err : = strconv . Parse Int ( m . Get Raw ( name ) , 1 0 , 6 4 ) if err ! = nil { panic ( fmt . Sprintf ( " " , err ) ) } return n } 
func ( m * Map ) update ( values map [ string ] string ) ( [ ] string , error ) { if initial { m . values = make ( map [ string ] string , len ( values ) ) } names : = [ ] string { } for name , value : = range values { changed , err : = m . set ( name , value , initial ) if err ! = nil { errors . add ( name , value , err . Error ( ) ) continue } if changed { names = append ( names , name ) } } sort . Strings ( names ) var err error if errors . Len ( ) > 0 { errors . sort ( ) err = errors } return names , err } 
func ( m * Map ) set ( name string , value string , initial bool ) ( bool , error ) { key , ok : = m . schema [ name ] if ! ok { return false , fmt . Errorf ( " " ) } err : = key . validate ( value ) if err ! = nil { return false , err } if key . Type = = Bool { value = normalize Bool ( value ) current = normalize Bool ( current ) } } if err ! = nil { return false , err } } if value = = " " { delete ( m . values , name ) } else { m . values [ name ] = value } return true , nil } 
func Does Schema Table Exist ( tx * sql . Tx ) ( bool , error ) { statement : = ` SELECT COUNT (name ) FROM sqlite _master WHERE type = 'table ' AND name = 'schema ' ` rows , err : = tx . Query ( statement ) if err ! = nil { return false , err } defer rows . Close ( ) if ! rows . Next ( ) { return false , fmt . Errorf ( " " ) } var count int err = rows . Scan ( & count ) if err ! = nil { return false , err } return count = = 1 , nil } 
func select Schema Versions ( tx * sql . Tx ) ( [ ] int , error ) { statement : = ` SELECT version FROM schema ORDER BY version ` return query . Select Integers ( tx , statement ) } 
func select Tables SQL ( tx * sql . Tx ) ( [ ] string , error ) { statement : = ` SELECT sql FROM sqlite _master WHERE type IN ( 'table ' , 'index ' , 'view ' ) AND name ! = 'schema ' AND name NOT LIKE 'sqlite _ % ' ORDER BY name ` return query . Select Strings ( tx , statement ) } 
func create Schema Table ( tx * sql . Tx ) error { statement : = ` CREATE TABLE schema ( id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL , version INTEGER NOT NULL , updated _at DATETIME NOT NULL , UNIQUE (version ) ) ` _ , err : = tx . Exec ( statement ) return err } 
func insert Schema Version ( tx * sql . Tx , new int ) error { statement : = ` INSERT INTO schema (version , updated _at ) VALUES ( ? , strftime ( " %s " ) ) ` _ , err : = tx . Exec ( statement , new ) return err } 
func exec From File ( tx * sql . Tx , path string , hook Hook ) error { if ! shared . Path Exists ( path ) { return nil } bytes , err : = ioutil . Read File ( path ) if err ! = nil { return errors . Wrap ( err , " " ) } if hook ! = nil { err : = hook ( - 1 , tx ) if err ! = nil { return errors . Wrap ( err , " " ) } } _ , err = tx . Exec ( string ( bytes ) ) if err ! = nil { return err } err = os . Remove ( path ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func New State ( node * db . Node , cluster * db . Cluster , maas * maas . Controller , os * sys . OS , endpoints * endpoints . Endpoints ) * State { return & State { Node : node , Cluster : cluster , MAAS : maas , OS : os , Endpoints : endpoints , } } 
func lxc Set Config Item ( c * lxc . Container , key string , value string ) error { if c = = nil { return fmt . Errorf ( " " ) } if ! util . Runtime Liblxc Version At Least ( 2 , 1 , 0 ) { switch key { case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " case " " : key = " " } } if strings . Has Prefix ( key , " " ) { if ! util . Runtime Liblxc Version At Least ( 2 , 1 , 0 ) { return fmt . Errorf ( `Process limits require liblxc > = 2 . 1 ` ) } } err : = c . Set Config Item ( key , value ) if err ! = nil { return fmt . Errorf ( " " , key , value ) } return nil } 
func container LXCCreate ( s * state . State , args db . Container Args ) ( container , error ) { } if c . creation Date . Is Zero ( ) { c . creation Date = time . Time { } } if c . last Used Date . Is Zero ( ) { c . last Used Date = time . Time { } } ctx Map : = log . Ctx { " " : args . Project , " " : c . name , " " : c . ephemeral , } logger . Info ( " " , ctx Map ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } err = container Valid Devices ( s . Cluster , c . expanded Devices , false , true ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , errors . Wrap ( err , " " ) } if err ! = nil { c . Delete ( ) return nil , err } if root Disk Device [ " " ] = = " " { c . Delete ( ) return nil , fmt . Errorf ( " " ) } storage Pool : = root Disk Device [ " " ] if err ! = nil { c . Delete ( ) return nil , err } err = storage Volume Fill Default ( storage Pool , volume Config , pool ) if err ! = nil { c . Delete ( ) return nil , err } if err ! = nil { c . Delete ( ) return nil , err } if err ! = nil { c . Delete ( ) s . Cluster . Storage Pool Volume Delete ( args . Project , args . Name , storage Pool Volume Type Container , pool ID ) logger . Error ( " " , ctx Map ) return nil , err } c . storage = c Storage base : = int 6 4 ( 0 ) if ! c . Is Privileged ( ) { idmap , base , err = find Idmap ( s , args . Name , c . expanded Config [ " " ] , c . expanded Config [ " " ] , c . expanded Config [ " " ] , c . expanded Config [ " " ] , ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } } var json Idmap string if idmap ! = nil { idmap Bytes , err : = json . Marshal ( idmap . Idmap ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } json Idmap = string ( idmap Bytes ) } else { json Idmap = " " } err = c . Config Key Set ( " " , json Idmap ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } err = c . Config Key Set ( " " , fmt . Sprintf ( " " , base ) ) if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } } if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } if err ! = nil { c . Delete ( ) logger . Error ( " " , ctx Map ) return nil , err } } logger . Info ( " " , ctx Map ) event Send Lifecycle ( c . project , " " , fmt . Sprintf ( " " , c . name ) , nil ) return c , nil } 
func container LXCUnload ( c * container LXC ) { runtime . Set Finalizer ( c , nil ) if c . c ! = nil { c . c . Release ( ) c . c = nil } } 
func container LXCInstantiate ( s * state . State , args db . Container Args ) * container LXC { return & container LXC { state : s , id : args . ID , project : args . Project , name : args . Name , description : args . Description , ephemeral : args . Ephemeral , architecture : args . Architecture , c Type : args . Ctype , creation Date : args . Creation Date , last Used Date : args . Last Used Date , profiles : args . Profiles , local Config : args . Config , local Devices : args . Devices , stateful : args . Stateful , node : args . Node , expiry Date : args . Expiry Date , } } 
func ( c * container LXC ) init Storage ( ) error { if c . storage ! = nil { return nil } s , err : = storage Pool Volume Container Load Init ( c . state , c . Project ( ) , c . Name ( ) ) if err ! = nil { return err } c . storage = s return nil } 
func ( c * container LXC ) expand Config ( profiles [ ] api . Profile ) error { if profiles = = nil & & len ( c . profiles ) > 0 { var err error profiles , err = c . state . Cluster . Profiles Get ( c . project , c . profiles ) if err ! = nil { return err } } c . expanded Config = db . Profiles Expand Config ( c . local Config , profiles ) return nil } 
func ( c * container LXC ) setup Unix Device ( prefix string , dev types . Device , major int , minor int , path string , create Must Succeed bool , default Mode bool ) error { if c . is Currently Privileged ( ) & & ! c . state . OS . Running In User NS & & c . state . OS . CGroup Devices Controller { err : = lxc Set Config Item ( c . c , " " , fmt . Sprintf ( " " , major , minor ) ) if err ! = nil { return err } } temp : = types . Device { } err : = shared . Deep Copy ( & dev , & temp ) if err ! = nil { return err } temp [ " " ] = fmt . Sprintf ( " " , major ) temp [ " " ] = fmt . Sprintf ( " " , minor ) temp [ " " ] = path paths , err : = c . create Unix Device ( prefix , temp , default Mode ) if err ! = nil { logger . Debug ( " " , log . Ctx { " " : err , " " : prefix } ) if create Must Succeed { return err } return nil } dev Path : = shared . Escape Path Fstab ( paths [ 0 ] ) tgt Path : = shared . Escape Path Fstab ( paths [ 1 ] ) val : = fmt . Sprintf ( " " , dev Path , tgt Path ) return lxc Set Config Item ( c . c , " " , val ) } 
func ( c * container LXC ) start Common ( ) ( string , error ) { if err ! = nil { return " " , errors . Wrap ( err , " " ) } } } case " " : if m [ " " ] ! = " " & & ! shared . Path Exists ( fmt . Sprintf ( " " , m [ " " ] ) ) { return " " , fmt . Errorf ( " " , m [ " " ] , name ) } case " " , " " : src Path , exist : = m [ " " ] if ! exist { src Path = m [ " " ] } if src Path ! = " " & & m [ " " ] ! = " " & & ! shared . Is True ( m [ " " ] ) { err = device Inotify Add Closest Living Ancestor ( c . state , filepath . Dir ( src Path ) ) if err ! = nil { logger . Errorf ( " \ " \ " " , src Path ) return " " , fmt . Errorf ( " " , src Path , err ) } } else if src Path ! = " " & & m [ " " ] = = " " & & m [ " " ] = = " " & & ! shared . Path Exists ( src Path ) { return " " , fmt . Errorf ( " " , src Path , name ) } } } if kernel Modules ! = " " { for _ , module : = range strings . Split ( kernel Modules , " " ) { module = strings . Trim Prefix ( module , " " ) err : = util . Load Module ( module ) if err ! = nil { return " " , fmt . Errorf ( " " , module , err ) } } } var our Start bool new Size , ok : = c . Local Config ( ) [ " " ] if ok { err : = c . init Storage ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } size , err : = shared . Parse Byte Size String ( new Size ) if err ! = nil { return " " , err } err = c . storage . Storage Entity Set Quota ( storage Pool Volume Type Container , size , c ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } if err ! = nil { return " " , errors . Wrap ( err , " " ) } delete ( c . expanded Config , " " ) } next Idmap , err : = c . Next Idmap ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } disk Idmap , err : = c . Disk Idmap ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } if ! next Idmap . Equals ( disk Idmap ) & & ! ( disk Idmap = = nil & & c . state . OS . Shiftfs ) { if shared . Is True ( c . expanded Config [ " " ] ) { return " " , fmt . Errorf ( " " ) } logger . Debugf ( " " ) c . update Progress ( " " ) our Start , err = c . Storage Start ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } if disk Idmap ! = nil { if c . Storage ( ) . Get Storage Type ( ) = = storage Type Zfs { err = disk Idmap . Unshift Rootfs ( c . Rootfs Path ( ) , zfs Idmap Set Skipper ) } else { err = disk Idmap . Unshift Rootfs ( c . Rootfs Path ( ) , nil ) } if err ! = nil { if our Start { c . Storage Stop ( ) } return " " , err } } if next Idmap ! = nil & & ! c . state . OS . Shiftfs { if c . Storage ( ) . Get Storage Type ( ) = = storage Type Zfs { err = next Idmap . Shift Rootfs ( c . Rootfs Path ( ) , zfs Idmap Set Skipper ) } else { err = next Idmap . Shift Rootfs ( c . Rootfs Path ( ) , nil ) } if err ! = nil { if our Start { c . Storage Stop ( ) } return " " , err } } json Disk Idmap : = " " if next Idmap ! = nil & & ! c . state . OS . Shiftfs { idmap Bytes , err : = json . Marshal ( next Idmap . Idmap ) if err ! = nil { return " " , err } json Disk Idmap = string ( idmap Bytes ) } err = c . Config Key Set ( " " , json Disk Idmap ) if err ! = nil { return " " , errors . Wrapf ( err , " " , c . name , c . id ) } c . update Progress ( " " ) } var idmap Bytes [ ] byte if next Idmap = = nil { idmap Bytes = [ ] byte ( " " ) } else { idmap Bytes , err = json . Marshal ( next Idmap . Idmap ) if err ! = nil { return " " , err } } if c . local Config [ " " ] ! = string ( idmap Bytes ) { err = c . Config Key Set ( " " , string ( idmap Bytes ) ) if err ! = nil { return " " , errors . Wrapf ( err , " " , c . name , c . id ) } } } c . remove Disk Devices ( ) c . remove Network Filters ( ) c . remove Proxy Devices ( ) var usbs [ ] usb Device var sriov [ ] string disk Devices : = map [ string ] types . Device { } if shared . String In Slice ( m [ " " ] , [ ] string { " " , " " } ) { if err ! = nil { } src Path : = m [ " " ] if src Path = = " " { src Path = m [ " " ] } src Path = shared . Host Path ( src Path ) err = device Inotify Add Closest Living Ancestor ( c . state , src Path ) if err ! = nil { logger . Errorf ( " \ " \ " " , src Path ) return " " , err } continue } dev Path : = paths [ 0 ] if c . is Currently Privileged ( ) & & ! c . state . OS . Running In User NS & & c . state . OS . CGroup Devices Controller { if err ! = nil { if m [ " " ] = = " " | | shared . Is True ( m [ " " ] ) { return " " , err } } else { err = lxc Set Config Item ( c . c , " " , fmt . Sprintf ( " " , d Type , d Major , d Minor ) ) if err ! = nil { return " " , fmt . Errorf ( " " ) } } } } else if m [ " " ] = = " " { if usbs = = nil { usbs , err = device Load Usb ( ) if err ! = nil { return " " , err } } for _ , usb : = range usbs { if ( m [ " " ] ! = " " & & usb . vendor ! = m [ " " ] ) | | ( m [ " " ] ! = " " & & usb . product ! = m [ " " ] ) { continue } err : = c . setup Unix Device ( fmt . Sprintf ( " " , k ) , m , usb . major , usb . minor , usb . path , shared . Is True ( m [ " " ] ) , false ) if err ! = nil { return " " , err } } } else if m [ " " ] = = " " { all Gpus : = device Wants All GPUs ( m ) gpus , nvidia Devices , err : = device Load Gpu ( all Gpus ) if err ! = nil { return " " , err } saw Nvidia : = false found : = false for _ , gpu : = range gpus { if ( m [ " " ] ! = " " & & gpu . vendor ID ! = m [ " " ] ) | | ( m [ " " ] ! = " " & & gpu . pci ! = m [ " " ] ) | | ( m [ " " ] ! = " " & & gpu . product ID ! = m [ " " ] ) | | ( m [ " " ] ! = " " & & gpu . id ! = m [ " " ] ) { continue } found = true err : = c . setup Unix Device ( fmt . Sprintf ( " " , k ) , m , gpu . major , gpu . minor , gpu . path , true , false ) if err ! = nil { return " " , err } if ! gpu . is Nvidia { continue } if gpu . nvidia . path ! = " " { err = c . setup Unix Device ( fmt . Sprintf ( " " , k ) , m , gpu . nvidia . major , gpu . nvidia . minor , gpu . nvidia . path , true , false ) if err ! = nil { return " " , err } } else if ! all Gpus { err Msg : = fmt . Errorf ( " \ " \ " " ) logger . Errorf ( " " , err Msg ) return " " , err Msg } saw Nvidia = true } if saw Nvidia { for _ , gpu : = range nvidia Devices { if shared . Is True ( c . expanded Config [ " " ] ) { if ! gpu . is Card { continue } } err : = c . setup Unix Device ( fmt . Sprintf ( " " , k ) , m , gpu . major , gpu . minor , gpu . path , true , false ) if err ! = nil { return " " , err } } } if ! found { msg : = " " logger . Error ( msg ) return " " , fmt . Errorf ( msg ) } } else if m [ " " ] = = " " { if m [ " " ] ! = " " { disk Devices [ k ] = m } } else if m [ " " ] = = " " | | m [ " " ] = = " " { var err error var infiniband map [ string ] IBF if m [ " " ] = = " " { infiniband , err = device Load Infiniband ( ) if err ! = nil { return " " , err } } network Key Prefix : = " " if ! util . Runtime Liblxc Version At Least ( 2 , 1 , 0 ) { network Key Prefix = " " } m , err = c . fill Network Device ( k , m ) if err ! = nil { return " " , err } networkidx : = - 1 reserved : = [ ] string { } if m [ " " ] ! = " " & & m [ " " ] ! = " " { continue } if m [ " " ] ! = " " { continue } reserved = append ( reserved , m [ " " ] ) } for _ , d Name : = range c . expanded Devices . Device Names ( ) { m : = c . expanded Devices [ d Name ] if m [ " " ] ! = " " & & m [ " " ] ! = " " { continue } networkidx + + if shared . String In Slice ( d Name , sriov ) { continue } else { sriov = append ( sriov , d Name ) } if m [ " " ] ! = " " { continue } m , err = c . fill Sriov Network Device ( d Name , m , reserved ) if err ! = nil { return " " , err } val : = c . c . Config Item ( fmt . Sprintf ( " " , network Key Prefix , networkidx ) ) if len ( val ) = = 0 | | val [ 0 ] ! = " " { return " " , fmt . Errorf ( " " ) } if err ! = nil { return " " , err } if m [ " " ] = = " " { key : = m [ " " ] if Dev , ok : = infiniband [ key ] if ! ok { return " " , fmt . Errorf ( " \ " \ " " , key ) } err : = c . add Infiniband Devices ( d Name , & if Dev , false ) if err ! = nil { return " " , err } } } if m [ " " ] = = " " & & m [ " " ] = = " " { key : = m [ " " ] if Dev , ok : = infiniband [ key ] if ! ok { return " " , fmt . Errorf ( " \ " \ " " , key ) } err : = c . add Infiniband Devices ( k , & if Dev , false ) if err ! = nil { return " " , err } } if m [ " " ] = = " " & & shared . Is True ( m [ " " ] ) { for i : = 0 ; i < len ( c . c . Config Item ( network Key Prefix ) ) ; i + + { val : = c . c . Config Item ( fmt . Sprintf ( " " , network Key Prefix , i ) ) if len ( val ) = = 0 | | val [ 0 ] ! = m [ " " ] { continue } val = c . c . Config Item ( fmt . Sprintf ( " " , network Key Prefix , i ) ) if len ( val ) = = 0 | | val [ 0 ] ! = m [ " " ] { continue } val = c . c . Config Item ( fmt . Sprintf ( " " , network Key Prefix , i ) ) if len ( val ) = = 0 { continue } veth Name = val [ 0 ] break } if veth Name = = " " { return " " , fmt . Errorf ( " " ) } err = c . create Network Filter ( veth Name , m [ " " ] , m [ " " ] ) if err ! = nil { return " " , err } } if ! shared . Path Exists ( fmt . Sprintf ( " " , device ) ) { _ , err : = shared . Run Command ( " " , " " , " " , " " , m [ " " ] , " " , device , " " , " " , " " , " " , m [ " " ] ) if err ! = nil { return " " , err } } } } } err = c . add Disk Devices ( disk Devices , func ( name string , d types . Device ) error { _ , err : = c . create Disk Device ( name , d ) return err } ) if err ! = nil { return " " , err } if err ! = nil { return " " , err } err = os . Mkdir All ( c . Devices Path ( ) , 0 7 1 1 ) if err ! = nil { return " " , err } err = os . Mkdir All ( c . Shmounts Path ( ) , 0 7 1 1 ) if err ! = nil { return " " , err } if shared . Path Exists ( logfile ) { os . Remove ( logfile + " " ) err : = os . Rename ( logfile , logfile + " " ) if err ! = nil { return " " , err } } if err ! = nil { return " " , err } err = c . c . Save Config File ( config Path ) if err ! = nil { os . Remove ( config Path ) return " " , err } if err ! = nil { if our Start { c . Storage Stop ( ) } return " " , err } if c . is Currently Privileged ( ) { mode = 0 7 0 0 } else { mode = 0 7 1 1 } err = os . Chmod ( c . Path ( ) , mode ) if err ! = nil { if our Start { c . Storage Stop ( ) } return " " , err } if err ! = nil { if our Start { c . Storage Stop ( ) } return " " , err } if ! c . Is Stateful ( ) & & shared . Path Exists ( c . State Path ( ) ) { os . Remove All ( c . State Path ( ) ) } _ , err = c . Storage Stop ( ) if err ! = nil { return " " , err } if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return config Path , nil } 
func ( c * container LXC ) Stop ( stateful bool ) error { var ctx Map log . Ctx } if err ! = nil { return err } ctx Map = log . Ctx { " " : c . project , " " : c . name , " " : op . action , " " : c . creation Date , " " : c . ephemeral , " " : c . last Used Date , " " : stateful } logger . Info ( " " , ctx Map ) os . Remove All ( state Dir ) err : = os . Mkdir All ( state Dir , 0 7 0 0 ) if err ! = nil { op . Done ( err ) logger . Error ( " " , ctx Map ) return err } criu Migration Args : = Criu Migration Args { cmd : lxc . MIGRATE _DUMP , state Dir : state Dir , function : " " , stop : true , action Script : false , dump Dir : " " , pre Dump Dir : " " , } if err ! = nil { op . Done ( err ) logger . Error ( " " , ctx Map ) return err } err = op . Wait ( ) if err ! = nil & & c . Is Running ( ) { logger . Error ( " " , ctx Map ) return err } c . stateful = true err = c . state . Cluster . Container Set Stateful ( c . id , true ) if err ! = nil { op . Done ( err ) logger . Error ( " " , ctx Map ) return err } op . Done ( nil ) logger . Info ( " " , ctx Map ) event Send Lifecycle ( c . project , " " , fmt . Sprintf ( " " , c . name ) , nil ) return nil } else if shared . Path Exists ( c . State Path ( ) ) { os . Remove All ( c . State Path ( ) ) } if err ! = nil { op . Done ( err ) logger . Error ( " " , ctx Map ) return err } } else if c . state . OS . CGroup Freezer Controller { go func ( ) { c . Freeze ( ) freezer < - true } ( ) select { case < - freezer : case < - time . After ( time . Second * 5 ) : c . Unfreeze ( ) } } if err : = c . c . Stop ( ) ; err ! = nil { op . Done ( err ) logger . Error ( " " , ctx Map ) return err } err = op . Wait ( ) if err ! = nil & & c . Is Running ( ) { logger . Error ( " " , ctx Map ) return err } logger . Info ( " " , ctx Map ) event Send Lifecycle ( c . project , " " , fmt . Sprintf ( " " , c . name ) , nil ) return nil } 
func ( c * container LXC ) On Network Up ( device Name string , host Name string ) error { device : = c . expanded Devices [ device Name ] device [ " " ] = host Name return c . setup Host Veth Device ( device ) } 
func ( c * container LXC ) setup Host Veth Device ( device types . Device ) error { } } if err ! = nil { return err } if err ! = nil { return err } return nil } 
func ( c * container LXC ) Freeze ( ) error { ctx Map : = log . Ctx { " " : c . project , " " : c . name , " " : c . creation Date , " " : c . ephemeral , " " : c . last Used Date } } return nil } } logger . Info ( " " , ctx Map ) if err ! = nil { ctx Map [ " " ] = err logger . Error ( " " , ctx Map ) return err } err = c . c . Freeze ( ) if err ! = nil { ctx Map [ " " ] = err logger . Error ( " " , ctx Map ) return err } logger . Info ( " " , ctx Map ) event Send Lifecycle ( c . project , " " , fmt . Sprintf ( " " , c . name ) , nil ) return err } 
func ( c * container LXC ) get Lxc State ( ) ( lxc . State , error ) { if c . Is Snapshot ( ) { return lxc . State Map [ " " ] , nil } if err ! = nil { return lxc . State Map [ " " ] , err } monitor : = make ( chan lxc . State , 1 ) go func ( c * lxc . Container ) { monitor < - c . State ( ) } ( c . c ) select { case state : = < - monitor : return state , nil case < - time . After ( 5 * time . Second ) : return lxc . State Map [ " " ] , Lxc Monitor State Error } } 
func ( c * container LXC ) Storage ( ) storage { if c . storage = = nil { c . init Storage ( ) } return c . storage } 
func ( c * container LXC ) Storage Start Sensitive ( ) ( bool , error ) { if err ! = nil { return false , err } var is Our Operation bool if c . Is Snapshot ( ) { is Our Operation , err = c . storage . Container Snapshot Start ( c ) } else { is Our Operation , err = c . storage . Container Mount ( c ) } return is Our Operation , err } 
func ( c * container LXC ) insert Mount ( source , target , fstype string , flags int ) error { var err error if pid = = - 1 { } if lxc . Has Api Extension ( " " ) { cname : = project Prefix ( c . Project ( ) , c . Name ( ) ) config Path : = filepath . Join ( c . Log Path ( ) , " " ) if fstype = = " " { fstype = " " } if ! strings . Has Prefix ( target , " " ) { target = " " + target } _ , err : = shared . Run Command ( c . state . OS . Exec Path , " " , " " , cname , c . state . OS . Lxc Path , config Path , source , target , fstype , fmt . Sprintf ( " " , flags ) ) if err ! = nil { return err } } else { if shared . Is Dir ( source ) { tmp Mount , err = ioutil . Temp Dir ( c . Shmounts Path ( ) , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } } else { f , err : = ioutil . Temp File ( c . Shmounts Path ( ) , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } tmp Mount = f . Name ( ) f . Close ( ) } defer os . Remove ( tmp Mount ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer syscall . Unmount ( tmp Mount , syscall . MNT _DETACH ) pid Str : = fmt . Sprintf ( " " , pid ) out , err : = shared . Run Command ( c . state . OS . Exec Path , " " , " " , pid Str , mntsrc , target ) if out ! = " " { for _ , line : = range strings . Split ( strings . Trim Right ( out , " \n " ) , " \n " ) { logger . Debugf ( " " , line ) } } if err ! = nil { return err } } return nil } 
func ( c * container LXC ) device Exists In Devices Folder ( prefix string , path string ) bool { relative Dest Path : = strings . Trim Prefix ( path , " " ) dev Name : = fmt . Sprintf ( " " , strings . Replace ( prefix , " " , " " , - 1 ) , strings . Replace ( relative Dest Path , " " , " " , - 1 ) ) dev Path : = filepath . Join ( c . Devices Path ( ) , dev Name ) return shared . Path Exists ( dev Path ) } 
func ( c * container LXC ) create Unix Device ( prefix string , m types . Device , default Mode bool ) ( [ ] string , error ) { var err error var major , minor int } } } src Path : = m [ " " ] if src Path = = " " { src Path = m [ " " ] } src Path = shared . Host Path ( src Path ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , err ) } } else if m [ " " ] = = " " | | m [ " " ] = = " " { return nil , fmt . Errorf ( " " , m [ " " ] ) } else { major , err = strconv . Atoi ( m [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , m [ " " ] ) } minor , err = strconv . Atoi ( m [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , m [ " " ] ) } } if m [ " " ] ! = " " { tmp , err : = device Mode Oct ( m [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , m [ " " ] ) } mode = os . File Mode ( tmp ) } else if ! default Mode { mode , err = shared . Get Path Mode ( src Path ) if err ! = nil { errno , is Errno : = shared . Get Errno ( err ) if ! is Errno | | errno ! = syscall . ENOENT { return nil , fmt . Errorf ( " " , m [ " " ] , err ) } mode = os . File Mode ( 0 6 6 0 ) } } if m [ " " ] = = " " { mode | = syscall . S _IFBLK } else { mode | = syscall . S _IFCHR } gid : = 0 if m [ " " ] ! = " " { uid , err = strconv . Atoi ( m [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , m [ " " ] ) } } if m [ " " ] ! = " " { gid , err = strconv . Atoi ( m [ " " ] ) if err ! = nil { return nil , fmt . Errorf ( " " , m [ " " ] , m [ " " ] ) } } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } dest Path : = m [ " " ] if dest Path = = " " { dest Path = m [ " " ] } relative Dest Path : = strings . Trim Prefix ( dest Path , " " ) dev Name : = fmt . Sprintf ( " " , strings . Replace ( prefix , " " , " " , - 1 ) , strings . Replace ( relative Dest Path , " " , " " , - 1 ) ) dev Path : = filepath . Join ( c . Devices Path ( ) , dev Name ) if err : = syscall . Mknod ( dev Path , uint 3 2 ( mode ) , encoded _device _number ) ; err ! = nil { return nil , fmt . Errorf ( " " , dev Path , m [ " " ] , err ) } if err : = os . Chown ( dev Path , uid , gid ) ; err ! = nil { return nil , fmt . Errorf ( " " , dev Path , err ) } } idmapset , err : = c . Current Idmap ( ) if err ! = nil { return nil , err } if idmapset ! = nil { if err : = idmapset . Shift File ( dev Path ) ; err ! = nil { } } } else { f , err : = os . Create ( dev Path ) if err ! = nil { return nil , err } f . Close ( ) err = device Mount Disk ( src Path , dev Path , false , false , " " ) if err ! = nil { return nil , err } } return [ ] string { dev Path , relative Dest Path } , nil } 
func ( c * container LXC ) create Network Device ( name string , m types . Device ) ( string , error ) { var dev , n 1 string if shared . String In Slice ( m [ " " ] , [ ] string { " " , " " , " " } ) { } else { n 1 = device Next Veth ( ) } } if m [ " " ] = = " " { dev = m [ " " ] } _ , err : = shared . Run Command ( " " , " " , " " , " " , n 1 , " " , " " , " " , " " , n 2 ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } _ , err = shared . Run Command ( " " , " " , " " , " " , n 1 , " " ) if err ! = nil { return " " , fmt . Errorf ( " " , n 1 , err ) } if m [ " " ] = = " " { err = network Attach Interface ( m [ " " ] , n 1 ) if err ! = nil { device Remove Interface ( n 2 ) return " " , fmt . Errorf ( " " , err ) } } dev = n 2 } if m [ " " ] ! = " " { device = network Get Host Device ( m [ " " ] , m [ " " ] ) if ! shared . Path Exists ( fmt . Sprintf ( " " , device ) ) { _ , err : = shared . Run Command ( " " , " " , " " , " " , m [ " " ] , " " , device , " " , " " , " " , " " , m [ " " ] ) if err ! = nil { return " " , err } } } } if err ! = nil { return " " , fmt . Errorf ( " " , err ) } dev = n 1 } } if err ! = nil { device Remove Interface ( dev ) return " " , fmt . Errorf ( " " , err ) } } if err ! = nil { device Remove Interface ( dev ) return " " , fmt . Errorf ( " " , err ) } if err ! = nil { return " " , err } } return dev , nil } 
func ( c * container LXC ) create Disk Device ( name string , m types . Device ) ( string , error ) { dev Name : = fmt . Sprintf ( " " , strings . Replace ( name , " " , " " , - 1 ) , strings . Replace ( relative Dest Path , " " , " " , - 1 ) ) dev Path : = filepath . Join ( c . Devices Path ( ) , dev Name ) src Path : = shared . Host Path ( m [ " " ] ) is Read Only : = shared . Is True ( m [ " " ] ) is Recursive : = shared . Is True ( m [ " " ] ) is File : = false if m [ " " ] = = " " { is File = ! shared . Is Dir ( src Path ) & & ! device Is Blockdev ( src Path ) } else { } volume Type Name : = " " volume Name : = filepath . Clean ( m [ " " ] ) slash : = strings . Index ( volume Name , " " ) if ( slash > 0 ) & & ( len ( volume Name ) > slash ) { } switch volume Type Name { case storage Pool Volume Type Name Container : return " " , fmt . Errorf ( " " ) case " " : fallthrough case storage Pool Volume Type Name Custom : src Path = shared . Var Path ( " " , m [ " " ] , volume Type Name , volume Name ) case storage Pool Volume Type Name Image : return " " , fmt . Errorf ( " " ) default : return " " , fmt . Errorf ( " \ " \ " " , volume Type Name ) } s , err : = storage Pool Volume Attach Init ( c . state , m [ " " ] , volume Name , volume Type , c ) if err ! = nil & & ! is Optional { return " " , fmt . Errorf ( " \ " \ " \ " \ " \ " \ " " , volume Name , volume Type Name , m [ " " ] , err ) } else if err = = nil { _ , err = s . Storage Pool Volume Mount ( ) if err ! = nil { msg : = fmt . Sprintf ( " \ " \ " \ " \ " \ " \ " " , volume Name , volume Type Name , m [ " " ] , err ) if ! is Optional { logger . Errorf ( msg ) return " " , err } logger . Warnf ( msg ) } } } } return " " , fmt . Errorf ( " " , src Path , name ) } if err ! = nil { return " " , err } } if err ! = nil { return " " , err } } if err ! = nil { return " " , err } f . Close ( ) } else { err : = os . Mkdir ( dev Path , 0 7 0 0 ) if err ! = nil { return " " , err } } if err ! = nil { return " " , err } return dev Path , nil } 
func ( c * container LXC ) get Disk Limits ( ) ( map [ string ] device Block Limit , error ) { result : = map [ string ] device Block Limit { } dents , err : = ioutil . Read Dir ( " " ) if err ! = nil { return nil , err } for _ , f : = range dents { f Path : = filepath . Join ( " " , f . Name ( ) ) if shared . Path Exists ( fmt . Sprintf ( " " , f Path ) ) { continue } if ! shared . Path Exists ( fmt . Sprintf ( " " , f Path ) ) { continue } block , err : = ioutil . Read File ( fmt . Sprintf ( " " , f Path ) ) if err ! = nil { return nil , err } valid Blocks = append ( valid Blocks , strings . Trim Suffix ( string ( block ) , " \n " ) ) } for _ , k : = range c . expanded Devices . Device Names ( ) { m : = c . expanded Devices [ k ] if m [ " " ] ! = " " { continue } m [ " " ] = m [ " " ] } if err ! = nil { return nil , err } if source = = " " { source = c . Rootfs Path ( ) } } if err ! = nil { if read Bps = = 0 & & read Iops = = 0 & & write Bps = = 0 & & write Iops = = 0 { } else { return nil , err } } device : = device Block Limit { read Bps : read Bps , read Iops : read Iops , write Bps : write Bps , write Iops : write Iops } for _ , block : = range blocks { block Str : = " " if shared . String In Slice ( block , valid Blocks ) { } else { fields [ 1 ] = " " if shared . String In Slice ( fmt . Sprintf ( " " , fields [ 0 ] , fields [ 1 ] ) , valid Blocks ) { block Str = fmt . Sprintf ( " " , fields [ 0 ] , fields [ 1 ] ) } } if block Str = = " " { return nil , fmt . Errorf ( " " , block ) } if block Limits [ block Str ] = = nil { block Limits [ block Str ] = [ ] device Block Limit { } } block Limits [ block Str ] = append ( block Limits [ block Str ] , device ) } } for _ , limit : = range limits { if limit . read Bps > 0 { read Bps Count + = 1 read Bps Total + = limit . read Bps } if limit . read Iops > 0 { read Iops Count + = 1 read Iops Total + = limit . read Iops } if limit . write Bps > 0 { write Bps Count + = 1 write Bps Total + = limit . write Bps } if limit . write Iops > 0 { write Iops Count + = 1 write Iops Total + = limit . write Iops } } device : = device Block Limit { } if read Bps Count > 0 { device . read Bps = read Bps Total / read Bps Count } if read Iops Count > 0 { device . read Iops = read Iops Total / read Iops Count } if write Bps Count > 0 { device . write Bps = write Bps Total / write Bps Count } if write Iops Count > 0 { device . write Iops = write Iops Total / write Iops Count } result [ block ] = device } return result , nil } 
func ( c * container LXC ) set Network Priority ( ) error { } } if network Priority = = " " { network Priority = " " } network Int , err : = strconv . Atoi ( network Priority ) if err ! = nil { return err } if err ! = nil { return err } var last _error error for _ , netif : = range netifs { err = c . CGroup Set ( " " , fmt . Sprintf ( " " , netif . Name , network Int ) ) if err = = nil { success = true } else { last _error = err } } if ! success { return fmt . Errorf ( " " , last _error ) } return nil } 
func ( c * container LXC ) set Network Routes ( m types . Device ) error { if ! shared . Path Exists ( fmt . Sprintf ( " " , m [ " " ] ) ) { return fmt . Errorf ( " " , m [ " " ] ) } if err ! = nil { return err } if err ! = nil { return err } _ , err : = shared . Run Command ( " " , " " , " " , " " , " " , m [ " " ] , route , " " , " " ) if err ! = nil { return err } } } _ , err : = shared . Run Command ( " " , " " , " " , " " , " " , m [ " " ] , route , " " , " " ) if err ! = nil { return err } } } return nil } 
func ( c * container LXC ) Path ( ) string { name : = project Prefix ( c . Project ( ) , c . Name ( ) ) return container Path ( name , c . Is Snapshot ( ) ) } 
func ( c * container LXC ) maas Interfaces ( ) ( [ ] maas . Container Interface , error ) { interfaces : = [ ] maas . Container Interface { } for k , m : = range c . expanded Devices { if m [ " " ] ! = " " { continue } if m [ " " ] = = " " & & m [ " " ] = = " " { continue } m , err : = c . fill Network Device ( k , m ) if err ! = nil { return nil , err } subnets : = [ ] maas . Container Interface Subnet { } subnets = append ( subnets , subnet ) } subnets = append ( subnets , subnet ) } iface : = maas . Container Interface { Name : m [ " " ] , MACAddress : m [ " " ] , Subnets : subnets , } interfaces = append ( interfaces , iface ) } return interfaces , nil } 
func get System Handler ( syslog string , debug bool , format log . Format ) log . Handler { } return log . Must . Syslog Handler ( syslog , format ) } return nil } 
func find Nvidia Minor Old ( ) ( string , error ) { var minor string if err ! = nil { return " " , err } rp : = regexp . Must Compile ( " " ) for _ , ent : = range ents { matches : = rp . Find String Submatch ( ent . Name ( ) ) if matches = = nil { continue } if minor ! = " " { return " " , fmt . Errorf ( " " ) } minor = matches [ 1 ] } if minor = = " " { return " " , fmt . Errorf ( " " ) } return minor , nil } 
func find Nvidia Minor ( pci string ) ( string , error ) { nvidia Path : = fmt . Sprintf ( " " , pci ) buf , err : = ioutil . Read File ( nvidia Path ) if err ! = nil { return " " , err } str Buf : = strings . Trim Space ( string ( buf ) ) idx : = strings . Index ( str Buf , " " ) if idx ! = - 1 { idx + = len ( " " ) str Buf = str Buf [ idx : ] str Buf = strings . Trim Space ( str Buf ) parts : = strings . Split N ( str Buf , " \n " , 2 ) _ , err = strconv . Atoi ( parts [ 0 ] ) if err = = nil { return parts [ 0 ] , nil } } minor , err : = find Nvidia Minor Old ( ) if err = = nil { return minor , nil } return " " , err } 
func Get Logger ( syslog string , logfile string , verbose bool , debug bool , custom Handler log . Handler ) ( logger . Logger , error ) { Log : = log . New ( ) var handlers [ ] log . Handler var syshandler log . Handler if syshandler ! = nil { handlers = append ( handlers , syshandler ) } } if ! debug { handlers = append ( handlers , log . Lvl Filter Handler ( log . Lvl Info , log . Must . File Handler ( logfile , Logfmt Format ( ) ) , ) , ) } else { handlers = append ( handlers , log . Must . File Handler ( logfile , Logfmt Format ( ) ) ) } } if term . Is Tty ( os . Stderr . Fd ( ) ) { format = Terminal Format ( ) } if verbose | | debug { if ! debug { handlers = append ( handlers , log . Lvl Filter Handler ( log . Lvl Info , log . Stream Handler ( os . Stderr , format ) , ) , ) } else { handlers = append ( handlers , log . Stream Handler ( os . Stderr , format ) ) } } else { handlers = append ( handlers , log . Lvl Filter Handler ( log . Lvl Warn , log . Stream Handler ( os . Stderr , format ) , ) , ) } if custom Handler ! = nil { handlers = append ( handlers , custom Handler ) } Log . Set Handler ( log . Multi Handler ( handlers . . . ) ) return Log , nil } 
func Set Logger ( new Logger logger . Logger ) func ( ) { orig Log : = logger . Log logger . Log = new Logger return func ( ) { logger . Log = orig Log } } 
func Wait Record ( ch chan * log . Record , timeout time . Duration ) * log . Record { select { case record : = < - ch : return record case < - time . After ( timeout ) : return nil } } 
func Add Context ( logger logger . Logger , ctx log . Ctx ) logger . Logger { log 1 5logger , ok : = logger . ( log . Logger ) if ! ok { logger . Error ( " " , log . Ctx { " " : log 1 5logger , " " : ctx } ) return logger } return log 1 5logger . New ( ctx ) } 
func New Dotted Version ( version String string ) ( * Dotted Version , error ) { format Error : = fmt . Errorf ( " " , version String ) split : = strings . Split ( version String , " " ) if len ( split ) < 2 { return nil , format Error } maj , err : = strconv . Atoi ( split [ 0 ] ) if err ! = nil { return nil , format Error } min , err : = strconv . Atoi ( split [ 1 ] ) if err ! = nil { return nil , format Error } patch : = - 1 if len ( split ) = = 3 { patch , err = strconv . Atoi ( split [ 2 ] ) if err ! = nil { return nil , format Error } } return & Dotted Version { Major : maj , Minor : min , Patch : patch , } , nil } 
func Parse ( s string ) ( * Dotted Version , error ) { r , _ : = regexp . Compile ( ` ^ ( [ 0 - 9 ] + . [ 0 - 9 ] + ( . [ 0 - 9 ] + ) ) ? . * ` ) matches : = r . Find All String Submatch ( s , - 1 ) if len ( matches [ 0 ] ) < 2 { return nil , fmt . Errorf ( " " ) } return New Dotted Version ( matches [ 0 ] [ 1 ] ) } 
func ( v * Dotted Version ) String ( ) string { version : = fmt . Sprintf ( " " , v . Major , v . Minor ) if v . Patch ! = - 1 { version + = fmt . Sprintf ( " " , v . Patch ) } return version } 
func ( v * Dotted Version ) Compare ( other * Dotted Version ) int { result : = compare Ints ( v . Major , other . Major ) if result ! = 0 { return result } result = compare Ints ( v . Minor , other . Minor ) if result ! = 0 { return result } return compare Ints ( v . Patch , other . Patch ) } 
func prepare Loop Dev ( source string , flags int ) ( * os . File , error ) { c Loop Dev : = C . malloc ( C . size _t ( C . LO _NAME _SIZE ) ) if c Loop Dev = = nil { return nil , fmt . Errorf ( " " ) } defer C . free ( c Loop Dev ) c Source : = C . CString ( source ) defer C . free ( unsafe . Pointer ( c Source ) ) loop Fd , _ : = C . find _associated _loop _device ( c Source , ( * C . char ) ( c Loop Dev ) ) if loop Fd > = 0 { return os . New File ( uintptr ( loop Fd ) , C . Go String ( ( * C . char ) ( c Loop Dev ) ) ) , nil } loop Fd , err : = C . prepare _loop _dev _retry ( c Source , ( * C . char ) ( c Loop Dev ) , C . int ( flags ) ) if loop Fd < 0 { if err ! = nil { return nil , errors . Wrapf ( err , " " , source ) } return nil , fmt . Errorf ( " " , source ) } return os . New File ( uintptr ( loop Fd ) , C . Go String ( ( * C . char ) ( c Loop Dev ) ) ) , nil } 
func project Create Default Profile ( tx * db . Cluster Tx , project string ) error { profile . Project = project profile . Name = " " profile . Description = fmt . Sprintf ( " " , project ) profile . Config = map [ string ] string { } profile . Devices = types . Devices { } _ , err : = tx . Profile Create ( profile ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func project Change ( d * Daemon , project * api . Project , req api . Project Put ) Response { } if ! project Is Empty ( project ) & & features Changed { return Bad Request ( fmt . Errorf ( " " ) ) } if err ! = nil { return Bad Request ( err ) } if err ! = nil { return errors . Wrap ( err , " " ) } if req . Config [ " " ] ! = project . Config [ " " ] { if req . Config [ " " ] = = " " { err = project Create Default Profile ( tx , project . Name ) if err ! = nil { return err } } else { if err ! = nil { return errors . Wrap ( err , " " ) } } } return nil } ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func project Is Empty ( project * api . Project ) bool { if len ( project . Used By ) > 0 { } return false } return true } 
func project Prefix ( project string , s string ) string { if project ! = " " { s = fmt . Sprintf ( " " , project , s ) } return s } 
func ( r * Protocol LXD ) Get Certificate Fingerprints ( ) ( [ ] string , error ) { certificates : = [ ] string { } if err ! = nil { return nil , err } for _ , fingerprint : = range certificates { fields : = strings . Split ( fingerprint , " " ) fingerprints = append ( fingerprints , fields [ len ( fields ) - 1 ] ) } return fingerprints , nil } 
func ( r * Protocol LXD ) Get Certificates ( ) ( [ ] api . Certificate , error ) { certificates : = [ ] api . Certificate { } if err ! = nil { return nil , err } return certificates , nil } 
func ( r * Protocol LXD ) Get Certificate ( fingerprint string ) ( * api . Certificate , string , error ) { certificate : = api . Certificate { } if err ! = nil { return nil , " " , err } return & certificate , etag , nil } 
func ( r * Protocol LXD ) Create Certificate ( certificate api . Certificates Post ) error { if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Certificate ( fingerprint string , certificate api . Certificate Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Certificate ( fingerprint string ) error { if err ! = nil { return err } return nil } 
func container Metadata Templates Get ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) name : = mux . Vars ( r ) [ " " ] if err ! = nil { return Smart Error ( err ) } if response ! = nil { return response } if err ! = nil { return Smart Error ( err ) } if err ! = nil { return Smart Error ( err ) } if our Start { defer c . Storage Stop ( ) } if template Name = = " " { files Info , err : = ioutil . Read Dir ( templates Path ) if err ! = nil { return Internal Error ( err ) } templates : = [ ] string { } for _ , info : = range files Info { if ! info . Is Dir ( ) { templates = append ( templates , info . Name ( ) ) } } return Sync Response ( true , templates ) } if err ! = nil { return Smart Error ( err ) } if ! shared . Path Exists ( template Path ) { return Not Found ( fmt . Errorf ( " " , template Path ) ) } if err ! = nil { return Smart Error ( err ) } defer template . Close ( ) tempfile , err : = ioutil . Temp File ( " " , " " ) if err ! = nil { return Smart Error ( err ) } defer tempfile . Close ( ) _ , err = io . Copy ( tempfile , template ) if err ! = nil { return Internal Error ( err ) } files : = make ( [ ] file Response Entry , 1 ) files [ 0 ] . identifier = template Name files [ 0 ] . path = tempfile . Name ( ) files [ 0 ] . filename = template Name return File Response ( r , files , nil , true ) } 
func container Metadata Templates Post Put ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) name : = mux . Vars ( r ) [ " " ] if err ! = nil { return Smart Error ( err ) } if response ! = nil { return response } if err ! = nil { return Smart Error ( err ) } if err ! = nil { return Smart Error ( err ) } if our Start { defer c . Storage Stop ( ) } if template Name = = " " { return Bad Request ( fmt . Errorf ( " " ) ) } if err ! = nil { return Smart Error ( err ) } if r . Method = = " " & & shared . Path Exists ( template Path ) { return Bad Request ( fmt . Errorf ( " " ) ) } if err ! = nil { return Smart Error ( err ) } defer template . Close ( ) _ , err = io . Copy ( template , r . Body ) if err ! = nil { return Internal Error ( err ) } return Empty Sync Response } 
func container Metadata Templates Delete ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) name : = mux . Vars ( r ) [ " " ] if err ! = nil { return Smart Error ( err ) } if response ! = nil { return response } if err ! = nil { return Smart Error ( err ) } if err ! = nil { return Smart Error ( err ) } if our Start { defer c . Storage Stop ( ) } if template Name = = " " { return Bad Request ( fmt . Errorf ( " " ) ) } template Path , err : = get Container Template Path ( c , template Name ) if err ! = nil { return Smart Error ( err ) } if ! shared . Path Exists ( template Path ) { return Not Found ( fmt . Errorf ( " " , template Path ) ) } if err ! = nil { return Internal Error ( err ) } return Empty Sync Response } 
func get Container Template Path ( c container , filename string ) ( string , error ) { if strings . Contains ( filename , " " ) { return " " , fmt . Errorf ( " " ) } return filepath . Join ( c . Path ( ) , " " , filename ) , nil } 
func ( e Error ) Error ( ) string { message : = fmt . Sprintf ( " " , e . Name ) if e . Value ! = nil { message + = fmt . Sprintf ( " " , e . Value ) } return message + fmt . Sprintf ( " " , e . Reason ) } 
func ( l Error List ) Error ( ) string { switch len ( l ) { case 0 : return " " case 1 : return l [ 0 ] . Error ( ) } return fmt . Sprintf ( " " , l [ 0 ] , len ( l ) - 1 ) } 
func ( l * Error List ) add ( name string , value interface { } , reason string ) { * l = append ( * l , & Error { name , value , reason } ) } 
func Update Schema ( ) error { err : = cluster . Schema Dot Go ( ) if err ! = nil { return errors . Wrap ( err , " " ) } err = node . Schema Dot Go ( ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func do Profile Update Cluster ( d * Daemon , project , name string , old api . Profile Put ) error { node Name : = " " err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error node Name , err = tx . Node Name ( ) return err } ) if err ! = nil { return errors . Wrap ( err , " " ) } containers , err : = get Profile Containers Info ( d . cluster , project , name ) if err ! = nil { return errors . Wrapf ( err , " " , name ) } failures : = map [ string ] error { } for _ , args : = range containers { err : = do Profile Update Container ( d , name , old , node Name , args ) if err ! = nil { failures [ args . Name ] = err } } if len ( failures ) ! = 0 { msg : = " \n " for cname , err : = range failures { msg + = fmt . Sprintf ( " \n " , cname , err ) } return fmt . Errorf ( " " , msg ) } return nil } 
func do Profile Update Container ( d * Daemon , name string , old api . Profile Put , node Name string , args db . Container Args ) error { if args . Node ! = " " & & args . Node ! = node Name { } profiles , err : = d . cluster . Profiles Get ( args . Project , args . Profiles ) if err ! = nil { return err } for i , profile Name : = range args . Profiles { if profile Name = = name { profiles [ i ] . Devices = old . Devices break } } c : = container LXCInstantiate ( d . State ( ) , args ) c . expand Config ( profiles ) c . expand Devices ( profiles ) return c . Update ( db . Container Args { Architecture : c . Architecture ( ) , Config : c . Local Config ( ) , Description : c . Description ( ) , Devices : c . Local Devices ( ) , Ephemeral : c . Is Ephemeral ( ) , Profiles : c . Profiles ( ) , Project : c . Project ( ) , } , true ) } 
func get Profile Containers Info ( cluster * db . Cluster , project , profile string ) ( [ ] db . Container Args , error ) { if err ! = nil { return nil , errors . Wrapf ( err , " " , profile ) } containers : = [ ] db . Container Args { } err = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { for ct Project , ct Names : = range names { for _ , ct Name : = range ct Names { container , err : = tx . Container Get ( ct Project , ct Name ) if err ! = nil { return err } containers = append ( containers , db . Container To Args ( container ) ) } } return nil } ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } return containers , nil } 
func Cancelable Wait ( raw Op interface { } , progress * Progress Renderer ) error { var op lxd . Operation var rop lxd . Remote Operation case lxd . Remote Operation : rop = v default : return fmt . Errorf ( " " ) } signal . Notify ( ch Signal , os . Interrupt ) go func ( ) { if op ! = nil { ch Operation < - op . Wait ( ) } else { ch Operation < - rop . Wait ( ) } close ( ch Operation ) } ( ) count : = 0 for { var err error select { case err : = < - ch Operation : return err case < - ch Signal : if op ! = nil { err = op . Cancel ( ) } else { err = rop . Cancel Target ( ) } if err = = nil { return fmt . Errorf ( i 1 8n . G ( " " ) ) } count + + if count = = 3 { return fmt . Errorf ( i 1 8n . G ( " " ) ) } if progress ! = nil { progress . Warn ( fmt . Sprintf ( i 1 8n . G ( " " ) , err ) , time . Second * 5 ) } } } } 
func ( r * Protocol LXD ) Get Network Names ( ) ( [ ] string , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } urls : = [ ] string { } if err ! = nil { return nil , err } for _ , url : = range urls { fields : = strings . Split ( url , " " ) names = append ( names , fields [ len ( fields ) - 1 ] ) } return names , nil } 
func ( r * Protocol LXD ) Get Networks ( ) ( [ ] api . Network , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } networks : = [ ] api . Network { } if err ! = nil { return nil , err } return networks , nil } 
func ( r * Protocol LXD ) Get Network ( name string ) ( * api . Network , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } network : = api . Network { } if err ! = nil { return nil , " " , err } return & network , etag , nil } 
func ( r * Protocol LXD ) Get Network Leases ( name string ) ( [ ] api . Network Lease , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } leases : = [ ] api . Network Lease { } if err ! = nil { return nil , err } return leases , nil } 
func ( r * Protocol LXD ) Get Network State ( name string ) ( * api . Network State , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } state : = api . Network State { } if err ! = nil { return nil , err } return & state , nil } 
func ( r * Protocol LXD ) Create Network ( network api . Networks Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Network ( name string , network api . Network Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Rename Network ( name string , network api . Network Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func Open ( name string , store dqlite . Server Store , options . . . dqlite . Driver Option ) ( * sql . DB , error ) { driver , err : = dqlite . New Driver ( store , options . . . ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } driver Name : = dqlite Driver Name ( ) sql . Register ( driver Name , driver ) } db , err : = sql . Open ( driver Name , name ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return db , nil } 
func Ensure Schema ( db * sql . DB , address string , dir string ) ( bool , error ) { some Nodes Are Behind : = false api Extensions : = version . APIExtensions Count ( ) backup Done : = false hook : = ( func ( version int , tx * sql . Tx ) error { if err ! = nil { return errors . Wrap ( err , " " ) } if ! is Update { return nil } n , err : = select Unclustered Nodes Count ( tx ) if err ! = nil { return errors . Wrap ( err , " " ) } if n > 1 { } else if n = = 1 { clustered = false } err : = shared . Dir Copy ( filepath . Join ( dir , " " ) , filepath . Join ( dir , " " ) , ) if err ! = nil { return errors . Wrap ( err , " " ) } backup Done = true } if version = = - 1 { logger . Debugf ( " " ) } else { logger . Debugf ( " " , version , version + 1 ) } return nil } ) check : = func ( current int , tx * sql . Tx ) error { } if err ! = nil { return errors . Wrap ( err , " " ) } if n > 1 { } else if n = = 1 { address = " " } if err ! = nil { return errors . Wrap ( err , " " ) } err = check Cluster Is Upgradable ( tx , [ 2 ] int { len ( updates ) , api Extensions } ) if err = = err Some Nodes Are Behind { some Nodes Are Behind = true return schema . Err Graceful Abort } return err } schema : = Schema ( ) schema . File ( filepath . Join ( dir , " " ) ) schema . Check ( check ) schema . Hook ( hook ) var initial int err : = query . Retry ( func ( ) error { var err error initial , err = schema . Ensure ( db ) return err } ) if some Nodes Are Behind { return false , nil } if err ! = nil { return false , err } if err ! = nil { return false , err } stmt : = ` INSERT INTO nodes (id , name , address , schema , api _extensions ) VALUES ( 1 , 'none ' , ' 0 . 0 . 0 . 0 ' , ? , ? ) ` _ , err = tx . Exec ( stmt , Schema Version , api Extensions ) if err ! = nil { tx . Rollback ( ) return false , err } INSERT INTO projects (name , description ) VALUES ( 'default ' , 'Default LXD project ' ) ; INSERT INTO projects _config (project _id , key , value ) VALUES ( 1 , 'features .images ' , 'true ' ) ; INSERT INTO projects _config (project _id , key , value ) VALUES ( 1 , 'features .profiles ' , 'true ' ) ; ` _ , err = tx . Exec ( stmt ) if err ! = nil { tx . Rollback ( ) return false , err } INSERT INTO profiles (name , description , project _id ) VALUES ( 'default ' , 'Default LXD profile ' , 1 ) ` _ , err = tx . Exec ( stmt ) if err ! = nil { tx . Rollback ( ) return false , err } err = tx . Commit ( ) if err ! = nil { return false , err } } return true , err } 
func URLEncode ( path string , query map [ string ] string ) ( string , error ) { u , err : = url . Parse ( path ) if err ! = nil { return " " , err } params : = url . Values { } for key , value : = range query { params . Add ( key , value ) } u . Raw Query = params . Encode ( ) return u . String ( ) , nil } 
func Is Unix Socket ( path string ) bool { stat , err : = os . Stat ( path ) if err ! = nil { return false } return ( stat . Mode ( ) & os . Mode Socket ) = = os . Mode Socket } 
func Host Path ( path string ) string { } } snap Name : = os . Getenv ( " " ) if snap = = " " | | snap Name ! = " " { return path } if ppid < 1 { return path } pwd , err : = os . Readlink ( fmt . Sprintf ( " " , ppid ) ) if err ! = nil { return path } path = filepath . Clean ( strings . Join ( [ ] string { pwd , path } , string ( os . Path Separator ) ) ) } } } return fmt . Sprintf ( " " , path ) } 
func Var Path ( path . . . string ) string { var Dir : = os . Getenv ( " " ) if var Dir = = " " { var Dir = " " } items : = [ ] string { var Dir } items = append ( items , path . . . ) return filepath . Join ( items . . . ) } 
func Cache Path ( path . . . string ) string { var Dir : = os . Getenv ( " " ) log Dir : = " " if var Dir ! = " " { log Dir = filepath . Join ( var Dir , " " ) } items : = [ ] string { log Dir } items = append ( items , path . . . ) return filepath . Join ( items . . . ) } 
func Random Crypto String ( ) ( string , error ) { buf : = make ( [ ] byte , 3 2 ) n , err : = rand . Read ( buf ) if err ! = nil { return " " , err } if n ! = len ( buf ) { return " " , fmt . Errorf ( " " ) } return hex . Encode To String ( buf ) , nil } 
func File Move ( old Path string , new Path string ) error { err : = os . Rename ( old Path , new Path ) if err = = nil { return nil } err = File Copy ( old Path , new Path ) if err ! = nil { return err } os . Remove ( old Path ) return nil } 
func File Copy ( source string , dest string ) error { s , err : = os . Open ( source ) if err ! = nil { return err } defer s . Close ( ) fi , err : = s . Stat ( ) if err ! = nil { return err } d , err : = os . Create ( dest ) if err ! = nil { if os . Is Exist ( err ) { d , err = os . Open File ( dest , os . O _WRONLY , fi . Mode ( ) ) if err ! = nil { return err } } else { return err } } defer d . Close ( ) _ , err = io . Copy ( d , s ) if err ! = nil { return err } if runtime . GOOS ! = " " { _ , uid , gid : = Get Owner Mode ( fi ) return d . Chown ( uid , gid ) } return nil } 
func Dir Copy ( source string , dest string ) error { if err ! = nil { return errors . Wrapf ( err , " " ) } if ! info . Is Dir ( ) { return fmt . Errorf ( " " ) } if err ! = nil { return errors . Wrapf ( err , " " , dest ) } } if err ! = nil { return errors . Wrapf ( err , " " , dest ) } if err ! = nil { return errors . Wrapf ( err , " " , source ) } for _ , entry : = range entries { source Path : = filepath . Join ( source , entry . Name ( ) ) dest Path : = filepath . Join ( dest , entry . Name ( ) ) if entry . Is Dir ( ) { err : = Dir Copy ( source Path , dest Path ) if err ! = nil { return errors . Wrapf ( err , " " , source Path , dest Path ) } } else { err : = File Copy ( source Path , dest Path ) if err ! = nil { return errors . Wrapf ( err , " " , source Path , dest Path ) } } } return nil } 
func String Map Has String Key ( m map [ string ] string , keys . . . string ) bool { for _ , k : = range keys { if _ , ok : = m [ k ] ; ok { return true } } return false } 
func Deep Copy ( src , dest interface { } ) error { buff : = new ( bytes . Buffer ) enc : = gob . New Encoder ( buff ) dec : = gob . New Decoder ( buff ) if err : = enc . Encode ( src ) ; err ! = nil { return err } if err : = dec . Decode ( dest ) ; err ! = nil { return err } return nil } 
func Text Editor ( in Path string , in Content [ ] byte ) ( [ ] byte , error ) { var f * os . File var err error var path string if editor = = " " { editor = os . Getenv ( " " ) if editor = = " " { for _ , p : = range [ ] string { " " , " " , " " , " " } { _ , err : = exec . Look Path ( p ) if err = = nil { editor = p break } } if editor = = " " { return [ ] byte { } , fmt . Errorf ( " " ) } } } if in Path = = " " { if err ! = nil { return [ ] byte { } , err } err = os . Chmod ( f . Name ( ) , 0 6 0 0 ) if err ! = nil { f . Close ( ) os . Remove ( f . Name ( ) ) return [ ] byte { } , err } f . Write ( in Content ) f . Close ( ) path = fmt . Sprintf ( " " , f . Name ( ) ) os . Rename ( f . Name ( ) , path ) defer os . Remove ( path ) } else { path = in Path } cmd Parts : = strings . Fields ( editor ) cmd : = exec . Command ( cmd Parts [ 0 ] , append ( cmd Parts [ 1 : ] , path ) . . . ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr err = cmd . Run ( ) if err ! = nil { return [ ] byte { } , err } content , err : = ioutil . Read File ( path ) if err ! = nil { return [ ] byte { } , err } return content , nil } 
func Parse Byte Size String ( input string ) ( int 6 4 , error ) { } for i , chr : = range [ ] byte ( input ) { _ , err : = strconv . Atoi ( string ( [ ] byte { chr } ) ) if err ! = nil { suffix Len = len ( input ) - i break } } if suffix Len = = len ( input ) { return - 1 , fmt . Errorf ( " " , input ) } value Int , err : = strconv . Parse Int ( value , 1 0 , 6 4 ) if err ! = nil { return - 1 , fmt . Errorf ( " " , input ) } switch suffix { case " " , " " , " " : multiplicator = 1 case " " : multiplicator = 1 0 0 0 case " " : multiplicator = 1 0 0 0 * 1 0 0 0 case " " : multiplicator = 1 0 0 0 * 1 0 0 0 * 1 0 0 0 case " " : multiplicator = 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 case " " : multiplicator = 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 case " " : multiplicator = 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 * 1 0 0 0 case " " : multiplicator = 1 0 2 4 case " " : multiplicator = 1 0 2 4 * 1 0 2 4 case " " : multiplicator = 1 0 2 4 * 1 0 2 4 * 1 0 2 4 case " " : multiplicator = 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 case " " : multiplicator = 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 case " " : multiplicator = 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 * 1 0 2 4 default : return - 1 , fmt . Errorf ( " " , input ) } return value Int * multiplicator , nil } 
func Remove Duplicates From String ( s string , sep string ) string { dup : = sep + sep for s = strings . Replace ( s , dup , sep , - 1 ) ; strings . Contains ( s , dup ) ; s = strings . Replace ( s , dup , sep , - 1 ) { } return s } 
func Write Temp File ( dir string , prefix string , content string ) ( string , error ) { f , err : = ioutil . Temp File ( dir , prefix ) if err ! = nil { return " " , err } defer f . Close ( ) _ , err = f . Write String ( content ) return f . Name ( ) , err } 
func Escape Path Fstab ( path string ) string { r : = strings . New Replacer ( " " , " \ \ " , " \t " , " \ \ " , " \n " , " \ \ " , " \ \ " , " \ \ \ \ " ) return r . Replace ( path ) } 
func Render Template ( template string , ctx pongo 2 . Context ) ( string , error ) { if err ! = nil { return " " , err } if err ! = nil { return ret , err } } return ret , err } 
func Every ( interval time . Duration , options . . . Every Option ) Schedule { every : = & every { } for _ , option : = range options { option ( every ) } first : = true return func ( ) ( time . Duration , error ) { var err error if first & & every . skip First { err = Err Skip } first = false return interval , err } } 
func ( s * storage Lvm ) Storage Core Init ( ) error { s . s Type = storage Type Lvm type Name , err : = storage Type To String ( s . s Type ) if err ! = nil { return err } s . s Type Name = type Name if lvm Version ! = " " { s . s Type Version = lvm Version return nil } output , err : = shared . Run Command ( " " , " " ) if err ! = nil { return fmt . Errorf ( " \n " , err , output ) } lines : = strings . Split ( output , " \n " ) s . s Type Version = " " for idx , line : = range lines { fields : = strings . Split After N ( line , " " , 2 ) if len ( fields ) < 2 { continue } if idx > 0 { s . s Type Version + = " " } s . s Type Version + = strings . Trim Space ( fields [ 1 ] ) } lvm Version = s . s Type Version return nil } 
func ( s * storage Lvm ) Storage Pool Mount ( ) ( bool , error ) { source : = s . pool . Config [ " " ] if source = = " " { return false , fmt . Errorf ( " \ " \ " " ) } if ! filepath . Is Abs ( source ) { return true , nil } pool Mount Lock ID : = get Pool Mount Lock ID ( s . pool . Name ) lxd Storage Map Lock . Lock ( ) if wait Channel , ok : = lxd Storage Ongoing Operation Map [ pool Mount Lock ID ] ; ok { lxd Storage Map Lock . Unlock ( ) if _ , ok : = < - wait Channel ; ok { logger . Warnf ( " " ) } } lxd Storage Ongoing Operation Map [ pool Mount Lock ID ] = make ( chan bool ) lxd Storage Map Lock . Unlock ( ) remove Lock From Map : = func ( ) { lxd Storage Map Lock . Lock ( ) if wait Channel , ok : = lxd Storage Ongoing Operation Map [ pool Mount Lock ID ] ; ok { close ( wait Channel ) delete ( lxd Storage Ongoing Operation Map , pool Mount Lock ID ) } lxd Storage Map Lock . Unlock ( ) } defer remove Lock From Map ( ) if filepath . Is Abs ( source ) & & ! shared . Is Blockdev Path ( source ) { if loop Err ! = nil { return false , loop Err } if loop Err ! = nil { return false , loop Err } s . loop Info = loop F } return true , nil } 
func Dump ( tx * sql . Tx , schema string , schema Only bool ) ( string , error ) { schemas : = dump Parse Schema ( schema ) BEGIN TRANSACTION ; ` if err ! = nil { return " " , errors . Wrapf ( err , " " ) } dump + = table Dump for table : = range schemas { tables = append ( tables , table ) } sort . Strings ( tables ) for _ , table : = range tables { if schema Only { continue } table Dump , err : = dump Table ( tx , table , schemas [ table ] ) if err ! = nil { return " " , errors . Wrapf ( err , " " , table ) } dump + = table Dump } if err ! = nil { return " " , errors . Wrapf ( err , " " ) } dump + = table Dump } return dump , nil } 
func dump Parse Schema ( schema string ) map [ string ] string { tables : = map [ string ] string { } for _ , statement : = range strings . Split ( schema , " " ) { statement = strings . Trim ( statement , " \n " ) + " " if ! strings . Has Prefix ( statement , " " ) { continue } table : = strings . Split ( statement , " " ) [ 2 ] tables [ table ] = statement } return tables } 
func dump Table ( tx * sql . Tx , table , schema string ) ( string , error ) { statements : = [ ] string { schema } if err ! = nil { return " " , errors . Wrap ( err , " " ) } defer rows . Close ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } row : = make ( [ ] interface { } , len ( columns ) ) for i : = range raw { row [ i ] = & raw [ i ] } err : = rows . Scan ( row . . . ) if err ! = nil { return " " , errors . Wrapf ( err , " " , i ) } values : = make ( [ ] string , len ( columns ) ) for j , v : = range raw { switch v : = v . ( type ) { case int 6 4 : values [ j ] = strconv . Format Int ( v , 1 0 ) case string : values [ j ] = fmt . Sprintf ( " " , v ) case [ ] byte : values [ j ] = fmt . Sprintf ( " " , string ( v ) ) case time . Time : values [ j ] = strconv . Format Int ( v . Unix ( ) , 1 0 ) default : if v ! = nil { return " " , fmt . Errorf ( " " , columns [ j ] , i ) } values [ j ] = " " } } statement : = fmt . Sprintf ( " " , table , strings . Join ( values , " " ) ) statements = append ( statements , statement ) } return strings . Join ( statements , " \n " ) + " \n " , nil } 
func ( c * Cluster Tx ) Project Has Profiles ( name string ) ( bool , error ) { return project Has Profiles ( c . tx , name ) } 
func ( c * Cluster Tx ) Project Names ( ) ( [ ] string , error ) { stmt : = " " names , err : = query . Select Strings ( c . tx , stmt ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return names , nil } 
func ( c * Cluster Tx ) Project Map ( ) ( map [ int 6 4 ] string , error ) { stmt : = " " rows , err : = c . tx . Query ( stmt ) if err ! = nil { return nil , err } defer rows . Close ( ) result : = map [ int 6 4 ] string { } for i : = 0 ; rows . Next ( ) ; i + + { var id int 6 4 var name string err : = rows . Scan ( & id , & name ) if err ! = nil { return nil , err } result [ id ] = name } err = rows . Err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * Cluster Tx ) Project Has Images ( name string ) ( bool , error ) { project , err : = c . Project Get ( name ) if err ! = nil { return false , errors . Wrap ( err , " " ) } enabled : = project . Config [ " " ] = = " " return enabled , nil } 
func ( c * Cluster Tx ) Project Update ( name string , object api . Project Put ) error { stmt : = c . stmt ( project Update ) result , err : = stmt . Exec ( object . Description , name ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } id , err : = c . Project ID ( name ) if err ! = nil { return errors . Wrap ( err , " " ) } DELETE FROM projects _config WHERE projects _config .project _id = ? ` , id ) if err ! = nil { return errors . Wrap ( err , " " ) } for key , value : = range object . Config { _ , err : = stmt . Exec ( id , key , value ) if err ! = nil { return errors . Wrap ( err , " " ) } } return nil } 
func ( r * Protocol LXD ) Get Cluster ( ) ( * api . Cluster , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } cluster : = & api . Cluster { } etag , err : = r . query Struct ( " " , " " , nil , " " , & cluster ) if err ! = nil { return nil , " " , err } return cluster , etag , nil } 
func ( r * Protocol LXD ) Update Cluster ( cluster api . Cluster Put , ETag string ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if cluster . Server Address ! = " " | | cluster . Cluster Password ! = " " | | len ( cluster . Member Config ) > 0 { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } op , _ , err : = r . query Operation ( " " , " " , cluster , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Delete Cluster Member ( name string , force bool ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } params : = " " if force { params + = " " } _ , err : = r . query Struct ( " " , fmt . Sprintf ( " " , name , params ) , nil , " " , nil ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Get Cluster Member Names ( ) ( [ ] string , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } urls : = [ ] string { } _ , err : = r . query Struct ( " " , " " , nil , " " , & urls ) if err ! = nil { return nil , err } return urls , nil } 
func ( r * Protocol LXD ) Get Cluster Members ( ) ( [ ] api . Cluster Member , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } members : = [ ] api . Cluster Member { } _ , err : = r . query Struct ( " " , " " , nil , " " , & members ) if err ! = nil { return nil , err } return members , nil } 
func ( r * Protocol LXD ) Get Cluster Member ( name string ) ( * api . Cluster Member , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } member : = api . Cluster Member { } etag , err : = r . query Struct ( " " , fmt . Sprintf ( " " , name ) , nil , " " , & member ) if err ! = nil { return nil , " " , err } return & member , etag , nil } 
func ( r * Protocol LXD ) Rename Cluster Member ( name string , member api . Cluster Member Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query ( " " , fmt . Sprintf ( " " , name ) , member , " " ) if err ! = nil { return err } return nil } 
func Get State ( fd int ) ( * State , error ) { state , err : = terminal . Get State ( fd ) if err ! = nil { return nil , err } current State : = State ( * state ) return & current State , nil } 
func Make Raw ( fd int ) ( * State , error ) { state , err : = terminal . Make Raw ( fd ) if err ! = nil { return nil , err } old State : = State ( * state ) return & old State , nil } 
func Restore ( fd int , state * State ) error { new State : = terminal . State ( * state ) return terminal . Restore ( fd , & new State ) } 
func ( e * Event Listener ) Add Handler ( types [ ] string , function func ( api . Event ) ) ( * Event Target , error ) { if function = = nil { return nil , fmt . Errorf ( " " ) } defer e . targets Lock . Unlock ( ) return & target , nil } 
func ( e * Event Listener ) Remove Handler ( target * Event Target ) error { if target = = nil { return fmt . Errorf ( " " ) } defer e . targets Lock . Unlock ( ) e . targets [ len ( e . targets ) - 1 ] = nil e . targets = e . targets [ : len ( e . targets ) - 1 ] return nil } } return fmt . Errorf ( " " ) } 
func ( e * Event Listener ) Disconnect ( ) { if e . disconnected { return } defer e . r . event Listeners Lock . Unlock ( ) e . r . event Listeners [ len ( e . r . event Listeners ) - 1 ] = nil e . r . event Listeners = e . r . event Listeners [ : len ( e . r . event Listeners ) - 1 ] break } } e . disconnected = true close ( e . ch Active ) } 
func Compare Versions ( version 1 , version 2 [ 2 ] int ) ( int , error ) { schema 1 , extensions 1 : = version 1 [ 0 ] , version 1 [ 1 ] schema 2 , extensions 2 : = version 2 [ 0 ] , version 2 [ 1 ] if schema 1 = = schema 2 & & extensions 1 = = extensions 2 { return 0 , nil } if schema 1 > = schema 2 & & extensions 1 > = extensions 2 { return 1 , nil } if schema 1 < = schema 2 & & extensions 1 < = extensions 2 { return 2 , nil } return - 1 , fmt . Errorf ( " " ) } 
func ( c * Config ) Has Client Certificate ( ) bool { certf : = c . Config Path ( " " ) keyf : = c . Config Path ( " " ) if ! shared . Path Exists ( certf ) | | ! shared . Path Exists ( keyf ) { return false } return true } 
func ( c * Config ) Generate Client Certificate ( ) error { if c . Has Client Certificate ( ) { return nil } certf : = c . Config Path ( " " ) keyf : = c . Config Path ( " " ) return shared . Find Or Gen Cert ( certf , keyf , true ) } 
func Load Module ( module string ) error { if shared . Path Exists ( fmt . Sprintf ( " " , module ) ) { return nil } _ , err : = shared . Run Command ( " " , module ) return err } 
func Parse ( name string ) ( * ast . Package , error ) { base : = os . Getenv ( " " ) if base = = " " { base = " " } dir : = filepath . Join ( base , " " , name ) fset : = token . New File Set ( ) paths , err : = filepath . Glob ( filepath . Join ( dir , " " ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } files : = map [ string ] * ast . File { } for _ , path : = range paths { } file , err : = parser . Parse File ( fset , path , nil , parser . Parse Comments ) if err ! = nil { return nil , fmt . Errorf ( " " , path ) } files [ path ] = file } return pkg , nil } 
func ( e * Endpoints ) Pprof Address ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener : = e . listeners [ pprof ] if listener = = nil { return " " } return listener . Addr ( ) . String ( ) } 
func ( e * Endpoints ) Pprof Update Address ( address string ) error { if address ! = " " { address = util . Canonical Network Address ( address ) } old Address : = e . Network Address ( ) if address = = old Address { return nil } logger . Infof ( " " ) e . mu . Lock ( ) defer e . mu . Unlock ( ) } var listener net . Listener for i : = 0 ; i < 1 0 ; i + + { if err = = nil { break } time . Sleep ( 1 0 0 * time . Millisecond ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & listener , nil } if err ! = nil { if err 1 = = nil { e . listeners [ pprof ] = * listener e . serve HTTP ( pprof ) } return err } e . listeners [ pprof ] = * listener e . serve HTTP ( pprof ) } return nil } 
func New Method ( database , pkg , entity , kind string , config map [ string ] string ) ( * Method , error ) { packages , err : = Packages ( ) if err ! = nil { return nil , err } method : = & Method { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return method , nil } 
func ( m * Method ) Generate ( buf * file . Buffer ) error { if strings . Has Suffix ( m . kind , " " ) { return m . ref ( buf ) } switch m . kind { case " " : return m . uris ( buf ) case " " : return m . list ( buf ) case " " : return m . get ( buf ) case " " : return m . id ( buf ) case " " : return m . exists ( buf ) case " " : return m . create ( buf ) case " " : return m . rename ( buf ) case " " : return m . update ( buf ) case " " : return m . delete ( buf ) default : return fmt . Errorf ( " " , m . kind ) } } 
func ( m * Method ) fill Slice Reference Field ( buf * file . Buffer , nk [ ] * Field , field * Field ) error { objects Var : = fmt . Sprintf ( " " , lex . Minuscule ( field . Name ) ) method Name : = fmt . Sprintf ( " " , lex . Capital ( m . entity ) , field . Name ) buf . L ( " " , field . Name ) buf . L ( " " , objects Var , method Name ) buf . L ( " " ) buf . L ( " \ " \ " " , field . Name ) buf . L ( " " ) buf . N ( ) buf . L ( " " ) needle : = " " for i , key : = range nk [ : len ( nk ) - 1 ] { needle + = fmt . Sprintf ( " " , key . Name ) sub Index Typ : = index Type ( nk [ i + 1 : ] , field . Type . Name ) buf . L ( " " , objects Var , needle ) buf . L ( " " ) buf . L ( " " , sub Index Typ ) buf . L ( " " , objects Var , needle ) buf . L ( " " ) buf . N ( ) } needle + = fmt . Sprintf ( " " , nk [ len ( nk ) - 1 ] . Name ) buf . L ( " " , objects Var , needle ) buf . L ( " " ) buf . L ( " " , field . Type . Name ) buf . L ( " " ) buf . L ( " " , field . Name ) buf . L ( " " ) buf . N ( ) return nil } 
func ( c * Cluster Tx ) Storage Pools Node Config ( ) ( map [ string ] map [ string ] string , error ) { names , err : = query . Select Strings ( c . tx , " " ) if err ! = nil { return nil , err } pools : = make ( map [ string ] map [ string ] string , len ( names ) ) for _ , name : = range names { table : = ` storage _pools _config JOIN storage _pools ON storage _pools .id =storage _pools _config .storage _pool _id ` config , err : = query . Select Config ( c . tx , table , " " , name , c . node ID ) if err ! = nil { return nil , err } pools [ name ] = config } return pools , nil } 
func ( c * Cluster Tx ) Storage Pool ID ( name string ) ( int 6 4 , error ) { stmt : = " " ids , err : = query . Select Integers ( c . tx , stmt , name ) if err ! = nil { return - 1 , err } switch len ( ids ) { case 0 : return - 1 , Err No Such Object case 1 : return int 6 4 ( ids [ 0 ] ) , nil default : return - 1 , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Storage Pool Driver ( id int 6 4 ) ( string , error ) { stmt : = " " drivers , err : = query . Select Strings ( c . tx , stmt , id ) if err ! = nil { return " " , err } switch len ( drivers ) { case 0 : return " " , Err No Such Object case 1 : return drivers [ 0 ] , nil default : return " " , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Storage Pool IDs Not Pending ( ) ( map [ string ] int 6 4 , error ) { pools : = [ ] struct { id int 6 4 name string } { } dest : = func ( i int ) [ ] interface { } { pools = append ( pools , struct { id int 6 4 name string } { } ) return [ ] interface { } { & pools [ i ] . id , & pools [ i ] . name } } stmt , err : = c . tx . Prepare ( " " ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , storage Pool Pending ) if err ! = nil { return nil , err } ids : = map [ string ] int 6 4 { } for _ , pool : = range pools { ids [ pool . name ] = pool . id } return ids , nil } 
func ( c * Cluster Tx ) Storage Pool Node Join ( pool ID , node ID int 6 4 ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { pool ID , node ID } _ , err : = query . Upsert Object ( c . tx , " " , columns , values ) if err ! = nil { return errors . Wrap ( err , " " ) } return nil } 
func ( c * Cluster Tx ) Storage Pool Node Join Ceph ( pool ID , node ID int 6 4 ) error { node IDs , err : = query . Select Integers ( c . tx , stmt , pool ID ) if err ! = nil { return errors . Wrap ( err , " " ) } if len ( node IDs ) = = 0 { return fmt . Errorf ( " " ) } other Node ID : = node IDs [ 0 ] INSERT INTO storage _volumes (name , storage _pool _id , node _id , type , description , project _id ) SELECT name , storage _pool _id , ? , type , description , 1 FROM storage _volumes WHERE storage _pool _id = ? AND node _id = ? ` , node ID , pool ID , other Node ID ) if err ! = nil { return errors . Wrap ( err , " " ) } SELECT id FROM storage _volumes WHERE storage _pool _id = ? AND node _id = ? ORDER BY name , type ` volume IDs , err : = query . Select Integers ( c . tx , stmt , pool ID , node ID ) if err ! = nil { return errors . Wrap ( err , " " ) } other Volume IDs , err : = query . Select Integers ( c . tx , stmt , pool ID , other Node ID ) if err ! = nil { return errors . Wrap ( err , " " ) } if len ( volume IDs ) ! = len ( other Volume IDs ) { } for i , other Volume ID : = range other Volume IDs { config , err : = query . Select Config ( c . tx , " " , " " , other Volume ID ) if err ! = nil { return errors . Wrap ( err , " " ) } for key , value : = range config { _ , err : = c . tx . Exec ( ` INSERT INTO storage _volumes _config (storage _volume _id , key , value ) VALUES ( ? , ? , ? ) ` , volume IDs [ i ] , key , value ) if err ! = nil { return errors . Wrap ( err , " " ) } } } return nil } 
func ( c * Cluster Tx ) Storage Pool Config Add ( pool ID , node ID int 6 4 , config map [ string ] string ) error { return storage Pool Config Add ( c . tx , pool ID , node ID , config ) } 
func ( c * Cluster Tx ) Storage Pool Create Pending ( node , name , driver string , conf map [ string ] string ) error { driver string state int } { } var err Consistency error dest : = func ( i int ) [ ] interface { } { } return [ ] interface { } { & pool . id , & pool . driver , & pool . state } } stmt , err : = c . tx . Prepare ( " " ) if err ! = nil { return err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , name ) if err ! = nil { return err } if err Consistency ! = nil { return err Consistency } var pool ID = pool . id if pool ID = = 0 { values : = [ ] interface { } { name , driver } pool ID , err = query . Upsert Object ( c . tx , " " , columns , values ) if err ! = nil { return err } } else { } if pool . state ! = storage Pool Pending { return fmt . Errorf ( " " ) } } if err ! = nil { return err } if err ! = nil { return err } if count ! = 0 { return Err Already Defined } values : = [ ] interface { } { pool ID , node Info . ID } _ , err = query . Upsert Object ( c . tx , " " , columns , values ) if err ! = nil { return err } err = c . Storage Pool Config Add ( pool ID , node Info . ID , conf ) if err ! = nil { return err } return nil } 
func ( c * Cluster Tx ) Storage Pool Created ( name string ) error { return c . storage Pool State ( name , storage Pool Created ) } 
func ( c * Cluster Tx ) Storage Pool Errored ( name string ) error { return c . storage Pool State ( name , storage Pool Errored ) } 
func ( c * Cluster Tx ) Storage Pool Node Configs ( pool ID int 6 4 ) ( map [ string ] map [ string ] string , error ) { if err ! = nil { return nil , err } SELECT nodes .name FROM nodes LEFT JOIN storage _pools _nodes ON storage _pools _nodes .node _id = nodes .id LEFT JOIN storage _pools ON storage _pools _nodes .storage _pool _id = storage _pools .id WHERE storage _pools .id = ? AND storage _pools .state = ? ` defined , err : = query . Select Strings ( c . tx , stmt , pool ID , storage Pool Pending ) if err ! = nil { return nil , err } for _ , node : = range nodes { if ! shared . String In Slice ( node . Name , defined ) { missing = append ( missing , node . Name ) } } if len ( missing ) > 0 { return nil , fmt . Errorf ( " " , strings . Join ( missing , " " ) ) } configs : = map [ string ] map [ string ] string { } for _ , node : = range nodes { config , err : = query . Select Config ( c . tx , " " , " " , pool ID , node . ID ) if err ! = nil { return nil , err } configs [ node . Name ] = config } return configs , nil } 
func ( c * Cluster ) storage Pools ( where string , args . . . interface { } ) ( [ ] string , error ) { var name string stmt : = " " inargs : = [ ] interface { } { } outargs : = [ ] interface { } { name } if where ! = " " { stmt + = fmt . Sprintf ( " " , where ) for _ , arg : = range args { inargs = append ( inargs , arg ) } } result , err : = query Scan ( c . db , stmt , inargs , outargs ) if err ! = nil { return [ ] string { } , err } if len ( result ) = = 0 { return [ ] string { } , Err No Such Object } pools : = [ ] string { } for _ , r : = range result { pools = append ( pools , r [ 0 ] . ( string ) ) } return pools , nil } 
func ( c * Cluster ) Storage Pools Get Drivers ( ) ( [ ] string , error ) { var pool Driver string query : = " " inargs : = [ ] interface { } { } outargs : = [ ] interface { } { pool Driver } result , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } if len ( result ) = = 0 { return [ ] string { } , Err No Such Object } drivers : = [ ] string { } for _ , driver : = range result { drivers = append ( drivers , driver [ 0 ] . ( string ) ) } return drivers , nil } 
func ( c * Cluster ) Storage Pool Get ID ( pool Name string ) ( int 6 4 , error ) { pool ID : = int 6 4 ( - 1 ) query : = " " inargs : = [ ] interface { } { pool Name } outargs : = [ ] interface { } { & pool ID } err : = db Query Row Scan ( c . db , query , inargs , outargs ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , Err No Such Object } } return pool ID , nil } 
func ( c * Cluster ) Storage Pool Get ( pool Name string ) ( int 6 4 , * api . Storage Pool , error ) { var pool Driver string pool ID : = int 6 4 ( - 1 ) description : = sql . Null String { } var state int query : = " " inargs : = [ ] interface { } { pool Name } outargs : = [ ] interface { } { & pool ID , & pool Driver , & description , & state } err : = db Query Row Scan ( c . db , query , inargs , outargs ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , nil , Err No Such Object } return - 1 , nil , err } config , err : = c . Storage Pool Config Get ( pool ID ) if err ! = nil { return - 1 , nil , err } storage Pool : = api . Storage Pool { Name : pool Name , Driver : pool Driver , } storage Pool . Description = description . String storage Pool . Config = config switch state { case storage Pool Pending : storage Pool . Status = " " case storage Pool Created : storage Pool . Status = " " default : storage Pool . Status = " " } nodes , err : = c . storage Pool Nodes ( pool ID ) if err ! = nil { return - 1 , nil , err } storage Pool . Locations = nodes return pool ID , & storage Pool , nil } 
func ( c * Cluster ) storage Pool Nodes ( pool ID int 6 4 ) ( [ ] string , error ) { stmt : = ` SELECT nodes .name FROM nodes JOIN storage _pools _nodes ON storage _pools _nodes .node _id = nodes .id WHERE storage _pools _nodes .storage _pool _id = ? ` var nodes [ ] string err : = c . Transaction ( func ( tx * Cluster Tx ) error { var err error nodes , err = query . Select Strings ( tx . tx , stmt , pool ID ) return err } ) if err ! = nil { return nil , err } return nodes , nil } 
func ( c * Cluster ) Storage Pool Config Get ( pool ID int 6 4 ) ( map [ string ] string , error ) { var key , value string query : = " " inargs : = [ ] interface { } { pool ID , c . node ID } outargs : = [ ] interface { } { key , value } results , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return nil , err } config : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * Cluster ) Storage Pool Create ( pool Name string , pool Description string , pool Driver string , pool Config map [ string ] string ) ( int 6 4 , error ) { var id int 6 4 err : = c . Transaction ( func ( tx * Cluster Tx ) error { result , err : = tx . tx . Exec ( " " , pool Name , pool Description , pool Driver , storage Pool Created ) if err ! = nil { return err } id , err = result . Last Insert Id ( ) if err ! = nil { return err } values : = [ ] interface { } { id , c . node ID } _ , err = query . Upsert Object ( tx . tx , " " , columns , values ) if err ! = nil { return err } err = storage Pool Config Add ( tx . tx , id , c . node ID , pool Config ) if err ! = nil { return err } return nil } ) if err ! = nil { id = - 1 } return id , nil } 
func storage Pool Config Add ( tx * sql . Tx , pool ID , node ID int 6 4 , pool Config map [ string ] string ) error { str : = " " stmt , err : = tx . Prepare ( str ) defer stmt . Close ( ) if err ! = nil { return err } for k , v : = range pool Config { if v = = " " { continue } var node IDValue interface { } if ! shared . String In Slice ( k , Storage Pool Node Config Keys ) { node IDValue = nil } else { node IDValue = node ID } _ , err = stmt . Exec ( pool ID , node IDValue , k , v ) if err ! = nil { return err } } return nil } 
func storage Pool Driver Get ( tx * sql . Tx , id int 6 4 ) ( string , error ) { stmt : = " " drivers , err : = query . Select Strings ( tx , stmt , id ) if err ! = nil { return " " , err } switch len ( drivers ) { case 0 : return " " , Err No Such Object case 1 : return drivers [ 0 ] , nil default : return " " , fmt . Errorf ( " " ) } } 
func ( c * Cluster ) Storage Pool Update ( pool Name , description string , pool Config map [ string ] string ) error { pool ID , _ , err : = c . Storage Pool Get ( pool Name ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { err = Storage Pool Update Description ( tx . tx , pool ID , description ) if err ! = nil { return err } err = Storage Pool Config Clear ( tx . tx , pool ID , c . node ID ) if err ! = nil { return err } err = storage Pool Config Add ( tx . tx , pool ID , c . node ID , pool Config ) if err ! = nil { return err } return nil } ) return err } 
func Storage Pool Config Clear ( tx * sql . Tx , pool ID , node ID int 6 4 ) error { _ , err : = tx . Exec ( " " , pool ID , node ID ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Storage Pool Delete ( pool Name string ) ( * api . Storage Pool , error ) { pool ID , pool , err : = c . Storage Pool Get ( pool Name ) if err ! = nil { return nil , err } err = exec ( c . db , " " , pool ID ) if err ! = nil { return nil , err } return pool , nil } 
func ( c * Cluster ) Storage Pool Volumes Get Names ( pool ID int 6 4 ) ( [ ] string , error ) { var volume Name string query : = " " inargs : = [ ] interface { } { pool ID , c . node ID } outargs : = [ ] interface { } { volume Name } result , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } var out [ ] string for _ , r : = range result { out = append ( out , r [ 0 ] . ( string ) ) } return out , nil } 
func ( c * Cluster ) Storage Pool Volumes Get ( project string , pool ID int 6 4 , volume Types [ ] int ) ( [ ] * api . Storage Volume , error ) { var node IDs [ ] int err : = c . Transaction ( func ( tx * Cluster Tx ) error { var err error node IDs , err = query . Select Integers ( tx . tx , ` SELECT DISTINCT node _id FROM storage _volumes JOIN projects ON projects .id = storage _volumes .project _id WHERE (projects .name = ? OR storage _volumes .type = ? ) AND storage _pool _id = ? ` , project , Storage Pool Volume Type Custom , pool ID ) return err } ) if err ! = nil { return nil , err } volumes : = [ ] * api . Storage Volume { } for _ , node ID : = range node IDs { node Volumes , err : = c . storage Pool Volumes Get ( project , pool ID , int 6 4 ( node ID ) , volume Types ) if err ! = nil { return nil , err } volumes = append ( volumes , node Volumes . . . ) } return volumes , nil } 
func ( c * Cluster ) Storage Pool Node Volumes Get ( pool ID int 6 4 , volume Types [ ] int ) ( [ ] * api . Storage Volume , error ) { return c . storage Pool Volumes Get ( " " , pool ID , c . node ID , volume Types ) } 
func ( c * Cluster ) storage Pool Volumes Get ( project string , pool ID , node ID int 6 4 , volume Types [ ] int ) ( [ ] * api . Storage Volume , error ) { for _ , volume Type : = range volume Types { volume Names , err : = c . Storage Pool Volumes Get Type ( project , volume Type , pool ID , node ID ) if err ! = nil & & err ! = sql . Err No Rows { return nil , errors . Wrap ( err , " " ) } for _ , volume Name : = range volume Names { _ , volume , err : = c . Storage Pool Volume Get Type ( project , volume Name , volume Type , pool ID , node ID ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } result = append ( result , volume ) } } if len ( result ) = = 0 { return result , Err No Such Object } return result , nil } 
func ( c * Cluster ) Storage Pool Volumes Get Type ( project string , volume Type int , pool ID , node ID int 6 4 ) ( [ ] string , error ) { var pool Name string query : = ` SELECT storage _volumes .name FROM storage _volumes JOIN projects ON projects .id =storage _volumes .project _id WHERE (projects .name = ? OR storage _volumes .type = ? ) AND storage _pool _id = ? AND node _id = ? AND type = ? ` inargs : = [ ] interface { } { project , Storage Pool Volume Type Custom , pool ID , node ID , volume Type } outargs : = [ ] interface { } { pool Name } result , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for _ , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( c * Cluster ) Storage Pool Volume Snapshots Get Type ( volume Name string , volume Type int , pool ID int 6 4 ) ( [ ] string , error ) { result : = [ ] string { } regexp : = volume Name + shared . Snapshot Delimiter length : = len ( regexp ) query : = " " inargs : = [ ] interface { } { pool ID , c . node ID , volume Type , true , length , regexp } outfmt : = [ ] interface { } { volume Name } db Results , err : = query Scan ( c . db , query , inargs , outfmt ) if err ! = nil { return result , err } for _ , r : = range db Results { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * Cluster ) Storage Pool Node Volumes Get Type ( volume Type int , pool ID int 6 4 ) ( [ ] string , error ) { return c . Storage Pool Volumes Get Type ( " " , volume Type , pool ID , c . node ID ) } 
func ( c * Cluster ) Storage Pool Volume Get Type ( project string , volume Name string , volume Type int , pool ID , node ID int 6 4 ) ( int 6 4 , * api . Storage Volume , error ) { } volume ID , err : = c . Storage Pool Volume Get Type ID ( project , volume Name , volume Type , pool ID , node ID ) if err ! = nil { return - 1 , nil , err } volume Node , err : = c . Storage Volume Node Get ( volume ID ) if err ! = nil { return - 1 , nil , err } volume Config , err : = c . Storage Volume Config Get ( volume ID ) if err ! = nil { return - 1 , nil , err } volume Description , err : = c . Storage Volume Description Get ( volume ID ) if err ! = nil { return - 1 , nil , err } volume Type Name , err : = Storage Pool Volume Type To Name ( volume Type ) if err ! = nil { return - 1 , nil , err } storage Volume : = api . Storage Volume { Type : volume Type Name , } storage Volume . Name = volume Name storage Volume . Description = volume Description storage Volume . Config = volume Config storage Volume . Location = volume Node return volume ID , & storage Volume , nil } 
func ( c * Cluster ) Storage Pool Node Volume Get Type ( volume Name string , volume Type int , pool ID int 6 4 ) ( int 6 4 , * api . Storage Volume , error ) { return c . Storage Pool Node Volume Get Type By Project ( " " , volume Name , volume Type , pool ID ) } 
func ( c * Cluster ) Storage Pool Node Volume Get Type By Project ( project , volume Name string , volume Type int , pool ID int 6 4 ) ( int 6 4 , * api . Storage Volume , error ) { return c . Storage Pool Volume Get Type ( project , volume Name , volume Type , pool ID , c . node ID ) } 
func ( c * Cluster ) Storage Pool Volume Update ( volume Name string , volume Type int , pool ID int 6 4 , volume Description string , volume Config map [ string ] string ) error { volume ID , _ , err : = c . Storage Pool Node Volume Get Type ( volume Name , volume Type , pool ID ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { err = storage Pool Volume Replicate If Ceph ( tx . tx , volume ID , " " , volume Name , volume Type , pool ID , func ( volume ID int 6 4 ) error { err = Storage Volume Config Clear ( tx . tx , volume ID ) if err ! = nil { return err } err = Storage Volume Config Add ( tx . tx , volume ID , volume Config ) if err ! = nil { return err } return Storage Volume Description Update ( tx . tx , volume ID , volume Description ) } ) if err ! = nil { return err } return nil } ) return err } 
func ( c * Cluster ) Storage Pool Volume Delete ( project , volume Name string , volume Type int , pool ID int 6 4 ) error { volume ID , _ , err : = c . Storage Pool Node Volume Get Type By Project ( project , volume Name , volume Type , pool ID ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { err : = storage Pool Volume Replicate If Ceph ( tx . tx , volume ID , project , volume Name , volume Type , pool ID , func ( volume ID int 6 4 ) error { _ , err : = tx . tx . Exec ( " " , volume ID ) return err } ) return err } ) return err } 
func ( c * Cluster ) Storage Pool Volume Rename ( project , old Volume Name string , new Volume Name string , volume Type int , pool ID int 6 4 ) error { volume ID , _ , err : = c . Storage Pool Node Volume Get Type By Project ( project , old Volume Name , volume Type , pool ID ) if err ! = nil { return err } err = c . Transaction ( func ( tx * Cluster Tx ) error { err : = storage Pool Volume Replicate If Ceph ( tx . tx , volume ID , project , old Volume Name , volume Type , pool ID , func ( volume ID int 6 4 ) error { _ , err : = tx . tx . Exec ( " " , new Volume Name , volume ID , volume Type ) return err } ) return err } ) return err } 
func storage Pool Volume Replicate If Ceph ( tx * sql . Tx , volume ID int 6 4 , project , volume Name string , volume Type int , pool ID int 6 4 , f func ( int 6 4 ) error ) error { driver , err : = storage Pool Driver Get ( tx , pool ID ) if err ! = nil { return err } volume IDs : = [ ] int 6 4 { volume ID } if err ! = nil { return err } } for _ , volume ID : = range volume IDs { err : = f ( volume ID ) if err ! = nil { return err } } return nil } 
func ( c * Cluster ) Storage Pool Volume Create ( project , volume Name , volume Description string , volume Type int , snapshot bool , pool ID int 6 4 , volume Config map [ string ] string ) ( int 6 4 , error ) { var this Volume ID int 6 4 err : = c . Transaction ( func ( tx * Cluster Tx ) error { node IDs : = [ ] int { int ( c . node ID ) } driver , err : = storage Pool Driver Get ( tx . tx , pool ID ) if err ! = nil { return err } if err ! = nil { return err } } for _ , node ID : = range node IDs { result , err : = tx . tx . Exec ( ` INSERT INTO storage _volumes (storage _pool _id , node _id , type , snapshot , name , description , project _id ) VALUES ( ? , ? , ? , ? , ? , ? , (SELECT id FROM projects WHERE name = ? ) ) ` , pool ID , node ID , volume Type , snapshot , volume Name , volume Description , project ) if err ! = nil { return err } volume ID , err : = result . Last Insert Id ( ) if err ! = nil { return err } if int 6 4 ( node ID ) = = c . node ID { } err = Storage Volume Config Add ( tx . tx , volume ID , volume Config ) if err ! = nil { tx . tx . Rollback ( ) return err } } return nil } ) if err ! = nil { this Volume ID = - 1 } return this Volume ID , err } 
func ( c * Cluster ) Storage Pool Volume Get Type ID ( project string , volume Name string , volume Type int , pool ID , node ID int 6 4 ) ( int 6 4 , error ) { volume ID : = int 6 4 ( - 1 ) query : = `SELECT storage _volumes .id FROM storage _volumes JOIN storage _pools ON storage _volumes .storage _pool _id = storage _pools .id JOIN projects ON storage _volumes .project _id = projects .id WHERE projects .name = ? AND storage _volumes .storage _pool _id = ? AND storage _volumes .node _id = ? AND storage _volumes .name = ? AND storage _volumes .type = ? ` inargs : = [ ] interface { } { project , pool ID , node ID , volume Name , volume Type } outargs : = [ ] interface { } { & volume ID } err : = db Query Row Scan ( c . db , query , inargs , outargs ) if err ! = nil { if err = = sql . Err No Rows { return - 1 , Err No Such Object } return - 1 , err } return volume ID , nil } 
func ( c * Cluster ) Storage Pool Node Volume Get Type ID ( volume Name string , volume Type int , pool ID int 6 4 ) ( int 6 4 , error ) { return c . Storage Pool Volume Get Type ID ( " " , volume Name , volume Type , pool ID , c . node ID ) } 
func Storage Pool Volume Type To Name ( volume Type int ) ( string , error ) { switch volume Type { case Storage Pool Volume Type Container : return Storage Pool Volume Type Name Container , nil case Storage Pool Volume Type Image : return Storage Pool Volume Type Name Image , nil case Storage Pool Volume Type Custom : return Storage Pool Volume Type Name Custom , nil } return " " , fmt . Errorf ( " " ) } 
func Devices Add ( tx * sql . Tx , w string , c ID int 6 4 , devices types . Devices ) error { stmt 1 , err : = tx . Prepare ( str 1 ) if err ! = nil { return err } defer stmt 1 . Close ( ) stmt 2 , err : = tx . Prepare ( str 2 ) if err ! = nil { return err } defer stmt 2 . Close ( ) if err ! = nil { return err } result , err : = stmt 1 . Exec ( c ID , k , t ) if err ! = nil { return err } id 6 4 , err : = result . Last Insert Id ( ) if err ! = nil { return fmt . Errorf ( " " , k ) } id : = int ( id 6 4 ) for ck , cv : = range v { } _ , err = stmt 2 . Exec ( id , ck , cv ) if err ! = nil { return err } } } return nil } 
func ( c * Cluster ) Devices ( project , q Name string , isprofile bool ) ( types . Devices , error ) { err : = c . Transaction ( func ( tx * Cluster Tx ) error { enabled , err : = tx . Project Has Profiles ( project ) if err ! = nil { return err } if ! enabled { project = " " } return nil } ) if err ! = nil { return nil , err } var q string if isprofile { q = `SELECT profiles _devices .id , profiles _devices .name , profiles _devices .type FROM profiles _devices JOIN profiles ON profiles _devices .profile _id = profiles .id JOIN projects ON projects .id =profiles .project _id WHERE projects .name = ? AND profiles .name = ? ` } else { q = `SELECT containers _devices .id , containers _devices .name , containers _devices .type FROM containers _devices JOIN containers ON containers _devices .container _id = containers .id JOIN projects ON projects .id =containers .project _id WHERE projects .name = ? AND containers .name = ? ` } var id , dtype int var name , stype string inargs : = [ ] interface { } { project , q Name } outfmt : = [ ] interface { } { id , name , dtype } results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } devices : = types . Devices { } for _ , r : = range results { id = r [ 0 ] . ( int ) name = r [ 1 ] . ( string ) stype , err = db Device Type To String ( r [ 2 ] . ( int ) ) if err ! = nil { return nil , err } newdev , err : = db Device Config ( c . db , id , isprofile ) if err ! = nil { return nil , err } newdev [ " " ] = stype devices [ name ] = newdev } return devices , nil } 
func ( n * Node ) Patches ( ) ( [ ] string , error ) { inargs : = [ ] interface { } { } outfmt : = [ ] interface { } { " " } query : = fmt . Sprintf ( " " ) result , err : = query Scan ( n . db , query , inargs , outfmt ) if err ! = nil { return [ ] string { } , err } response : = [ ] string { } for _ , r : = range result { response = append ( response , r [ 0 ] . ( string ) ) } return response , nil } 
func ( n * Node ) Patches Mark Applied ( patch string ) error { stmt : = `INSERT INTO patches (name , applied _at ) VALUES ( ? , strftime ( " %s " ) ) ; ` _ , err : = n . db . Exec ( stmt , patch ) return err } 
func entity Type ( pkg string , entity string ) string { typ : = lex . Capital ( entity ) if pkg ! = " " { typ = pkg + " " + typ } return typ } 
func entity Post ( entity string ) string { return fmt . Sprintf ( " " , lex . Capital ( lex . Plural ( entity ) ) ) } 
func stmt Code Var ( entity string , kind string , filters . . . string ) string { name : = fmt . Sprintf ( " " , entity , lex . Camel ( kind ) ) if len ( filters ) > 0 { name + = " " name + = strings . Join ( filters , " " ) } return name } 
func active Criteria ( filter [ ] string ) string { expr : = " " for i , name : = range filter { if i > 0 { expr + = " " } expr + = fmt . Sprintf ( " " , name ) } return expr } 
func dest Func ( slice string , typ string , fields [ ] * Field ) string { f : = fmt . Sprintf ( `func (i int ) [ ]interface { } { %s = append ( %s , %s { } ) return [ ]interface { } { ` , slice , slice , typ ) for _ , field : = range fields { f + = fmt . Sprintf ( " \n " , slice , field . Name ) } f + = " \n " f + = " " return f } 
func index Type ( fields [ ] * Field , typ string ) string { index : = " " for range fields { index + = " " } index + = typ return index } 
func Compare Configs ( config 1 , config 2 map [ string ] string , exclude [ ] string ) error { if exclude = = nil { exclude = [ ] string { } } delta : = [ ] string { } for key , value : = range config 1 { if shared . String In Slice ( key , exclude ) { continue } if config 2 [ key ] ! = value { delta = append ( delta , key ) } } for key , value : = range config 2 { if shared . String In Slice ( key , exclude ) { continue } if config 1 [ key ] ! = value { present : = false for i : = range delta { if delta [ i ] = = key { present = true } break } if ! present { delta = append ( delta , key ) } } } sort . Strings ( delta ) if len ( delta ) > 0 { return fmt . Errorf ( " " , strings . Join ( delta , " " ) ) } return nil } 
func Copy Config ( config map [ string ] string ) map [ string ] string { copy : = map [ string ] string { } for key , value : = range config { copy [ key ] = value } return copy } 
func New Notifier ( state * state . State , cert * shared . Cert Info , policy Notifier Policy ) ( Notifier , error ) { address , err : = node . Cluster Address ( state . Node ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return null Notifier , nil } peers : = [ ] string { } err = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { offline Threshold , err : = tx . Node Offline Threshold ( ) if err ! = nil { return err } nodes , err : = tx . Nodes ( ) if err ! = nil { return err } for _ , node : = range nodes { if node . Address = = address | | node . Address = = " " { continue } if node . Is Offline ( offline Threshold ) { switch policy { case Notify All : return fmt . Errorf ( " " , node . Address ) case Notify Alive : continue } } peers = append ( peers , node . Address ) } return nil } ) if err ! = nil { return nil , err } notifier : = func ( hook func ( lxd . Container Server ) error ) error { errs : = make ( [ ] error , len ( peers ) ) wg : = sync . Wait Group { } wg . Add ( len ( peers ) ) for i , address : = range peers { logger . Debugf ( " " , address ) go func ( i int , address string ) { defer wg . Done ( ) client , err : = Connect ( address , cert , true ) if err ! = nil { errs [ i ] = errors . Wrapf ( err , " " , address ) return } err = hook ( client ) if err ! = nil { errs [ i ] = errors . Wrapf ( err , " " , address ) } } ( i , address ) } wg . Wait ( ) continue } return err } } return nil } return notifier , nil } 
func Events ( endpoints * endpoints . Endpoints , cluster * db . Cluster , f func ( int 6 4 , api . Event ) ) ( task . Func , task . Schedule ) { listeners : = map [ int 6 4 ] * lxd . Event Listener { } go func ( ) { events Update Listeners ( endpoints , cluster , listeners , f ) ch < - struct { } { } } ( ) select { case < - ch : case < - ctx . Done ( ) : } } schedule : = task . Every ( time . Second ) return update , schedule } 
func events Connect ( address string , cert * shared . Cert Info ) ( * lxd . Event Listener , error ) { client , err : = Connect ( address , cert , true ) if err ! = nil { return nil , err } return client . Get Events ( ) } 
func ( e * Idmap Entry ) shift _into _ns ( id int 6 4 ) ( int 6 4 , error ) { if id < e . Nsid | | id > = e . Nsid + e . Maprange { } return id - e . Nsid + e . Hostid , nil } 
func Extend ( slice [ ] Idmap Entry , element Idmap Entry ) [ ] Idmap Entry { n : = len ( slice ) if n = = cap ( slice ) { copy ( new Slice , slice ) slice = new Slice } slice = slice [ 0 : n + 1 ] slice [ n ] = element return slice } 
func ( m * Idmap Set ) Add Safe ( i Idmap Entry ) error { result : = [ ] Idmap Entry { } added : = false for _ , e : = range m . Idmap { if ! e . Intersects ( i ) { result = append ( result , e ) continue } if e . Hostids Intersect ( i ) { return Err Host Id Is Sub Id } added = true lower : = Idmap Entry { Isuid : e . Isuid , Isgid : e . Isgid , Hostid : e . Hostid , Nsid : e . Nsid , Maprange : i . Nsid - e . Nsid , } upper : = Idmap Entry { Isuid : e . Isuid , Isgid : e . Isgid , Hostid : e . Hostid + lower . Maprange + i . Maprange , Nsid : i . Nsid + i . Maprange , Maprange : e . Maprange - i . Maprange - lower . Maprange , } if lower . Maprange > 0 { result = append ( result , lower ) } result = append ( result , i ) if upper . Maprange > 0 { result = append ( result , upper ) } } if ! added { result = append ( result , i ) } m . Idmap = result return nil } 
func get From Shadow ( fname string , username string ) ( [ ] [ ] int 6 4 , error ) { entries : = [ ] [ ] int 6 4 { } f , err : = os . Open ( fname ) if err ! = nil { return nil , err } defer f . Close ( ) scanner : = bufio . New Scanner ( f ) for scanner . Scan ( ) { if len ( s [ 0 ] ) = = 0 { continue } if len ( s ) < 3 { return nil , fmt . Errorf ( " " , fname , s ) } if strings . Equal Fold ( s [ 0 ] , username ) { if err ! = nil { continue } if err ! = nil { continue } entries = append ( entries , [ ] int 6 4 { int 6 4 ( entry Start ) , int 6 4 ( entry Size ) } ) } } if len ( entries ) = = 0 { return nil , fmt . Errorf ( " " , username , path . Base ( fname ) ) } return entries , nil } 
func get From Proc ( fname string ) ( [ ] [ ] int 6 4 , error ) { entries : = [ ] [ ] int 6 4 { } f , err : = os . Open ( fname ) if err ! = nil { return nil , err } defer f . Close ( ) scanner : = bufio . New Scanner ( f ) for scanner . Scan ( ) { if len ( s [ 0 ] ) = = 0 { continue } if len ( s ) < 3 { return nil , fmt . Errorf ( " " , fname , s ) } if err ! = nil { continue } if err ! = nil { continue } if err ! = nil { continue } entries = append ( entries , [ ] int 6 4 { int 6 4 ( entry Start ) , int 6 4 ( entry Host ) , int 6 4 ( entry Size ) } ) } if len ( entries ) = = 0 { return nil , fmt . Errorf ( " " ) } return entries , nil } 
func Default Idmap Set ( rootfs string , username string ) ( * Idmap Set , error ) { idmapset : = new ( Idmap Set ) if username = = " " { current User , err : = user . Current ( ) if err ! = nil { return nil , err } username = current User . Username } subgid Path : = path . Join ( rootfs , " " ) if shared . Path Exists ( subuid Path ) & & shared . Path Exists ( subgid Path ) { if err ! = nil { return nil , err } for _ , entry : = range entries { } e : = Idmap Entry { Isuid : true , Nsid : 0 , Hostid : entry [ 0 ] , Maprange : entry [ 1 ] } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } if err ! = nil { return nil , err } for _ , entry : = range entries { } e : = Idmap Entry { Isgid : true , Nsid : 0 , Hostid : entry [ 0 ] , Maprange : entry [ 1 ] } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } return idmapset , nil } if err ! = nil { idmapset . Idmap = Extend ( idmapset . Idmap , e ) e = Idmap Entry { Isuid : false , Isgid : true , Nsid : 0 , Hostid : 1 0 0 0 0 0 0 , Maprange : 1 0 0 0 0 0 0 0 0 0 } idmapset . Idmap = Extend ( idmapset . Idmap , e ) return idmapset , nil } if err ! = nil { return nil , err } if reflect . Deep Equal ( kernel Ranges , full Kernel Ranges ) { idmapset . Idmap = Extend ( idmapset . Idmap , e ) e = Idmap Entry { Isuid : false , Isgid : true , Nsid : 0 , Hostid : 1 0 0 0 0 0 0 , Maprange : 1 0 0 0 0 0 0 0 0 0 } idmapset . Idmap = Extend ( idmapset . Idmap , e ) return idmapset , nil } } } } } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } } } } } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } return idmapset , nil } 
func Current Idmap Set ( ) ( * Idmap Set , error ) { idmapset : = new ( Idmap Set ) if shared . Path Exists ( " " ) { if err ! = nil { return nil , err } for _ , entry : = range entries { e : = Idmap Entry { Isuid : true , Nsid : entry [ 0 ] , Hostid : entry [ 1 ] , Maprange : entry [ 2 ] } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } } else { idmapset . Idmap = Extend ( idmapset . Idmap , e ) } if shared . Path Exists ( " " ) { if err ! = nil { return nil , err } for _ , entry : = range entries { e : = Idmap Entry { Isgid : true , Nsid : entry [ 0 ] , Hostid : entry [ 1 ] , Maprange : entry [ 2 ] } idmapset . Idmap = Extend ( idmapset . Idmap , e ) } } else { idmapset . Idmap = Extend ( idmapset . Idmap , e ) } return idmapset , nil } 
func ( s * storage Dir ) Storage Core Init ( ) error { s . s Type = storage Type Dir type Name , err : = storage Type To String ( s . s Type ) if err ! = nil { return err } s . s Type Name = type Name s . s Type Version = " " return nil } 
func ( s * storage Dir ) Storage Pool Init ( ) error { err : = s . Storage Core Init ( ) if err ! = nil { return err } return nil } 
func ( s * storage Dir ) Storage Pool Volume Create ( ) error { logger . Infof ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) _ , err : = s . Storage Pool Mount ( ) if err ! = nil { return err } source : = s . pool . Config [ " " ] if source = = " " { return fmt . Errorf ( " \ " \ " " ) } is Snapshot : = shared . Is Snapshot ( s . volume . Name ) var storage Volume Path string if is Snapshot { storage Volume Path = get Storage Pool Volume Snapshot Mount Point ( s . pool . Name , s . volume . Name ) } else { storage Volume Path = get Storage Pool Volume Mount Point ( s . pool . Name , s . volume . Name ) } err = os . Mkdir All ( storage Volume Path , 0 7 1 1 ) if err ! = nil { return err } err = s . init Quota ( storage Volume Path , s . volume ID ) if err ! = nil { return err } logger . Infof ( " \ " \ " \ " \ " " , s . volume . Name , s . pool . Name ) return nil } 
func User Id ( name string ) ( int , error ) { var pw C . struct _passwd var result * C . struct _passwd buf Size : = C . sysconf ( C . _SC _GETPW _R _SIZE _MAX ) if buf Size < 0 { buf Size = 4 0 9 6 } buf : = C . malloc ( C . size _t ( buf Size ) ) if buf = = nil { return - 1 , fmt . Errorf ( " " ) } defer C . free ( buf ) cname : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) again : rv , errno : = C . getpwnam _r ( cname , & pw , ( * C . char ) ( buf ) , C . size _t ( buf Size ) , & result ) if rv < 0 { tmp : = C . realloc ( buf , C . size _t ( buf Size ) ) if tmp = = nil { return - 1 , fmt . Errorf ( " " ) } buf = tmp goto again } return - 1 , fmt . Errorf ( " " , syscall . Errno ( rv ) ) } if result = = nil { return - 1 , fmt . Errorf ( " " , name ) } return int ( C . int ( result . pw _uid ) ) , nil } 
func Group Id ( name string ) ( int , error ) { var grp C . struct _group var result * C . struct _group buf Size : = C . sysconf ( C . _SC _GETGR _R _SIZE _MAX ) if buf Size < 0 { buf Size = 4 0 9 6 } buf : = C . malloc ( C . size _t ( buf Size ) ) if buf = = nil { return - 1 , fmt . Errorf ( " " ) } cname : = C . CString ( name ) defer C . free ( unsafe . Pointer ( cname ) ) again : rv , errno : = C . getgrnam _r ( cname , & grp , ( * C . char ) ( buf ) , C . size _t ( buf Size ) , & result ) if rv ! = 0 { tmp : = C . realloc ( buf , C . size _t ( buf Size ) ) if tmp = = nil { return - 1 , fmt . Errorf ( " " ) } buf = tmp goto again } C . free ( buf ) return - 1 , fmt . Errorf ( " " , syscall . Errno ( rv ) ) } C . free ( buf ) if result = = nil { return - 1 , fmt . Errorf ( " " , name ) } return int ( C . int ( result . gr _gid ) ) , nil } 
func Exec Reader To Channel ( r io . Reader , buffer Size int , exited < - chan bool , fd int ) < - chan [ ] byte { if buffer Size < = ( 1 2 8 * 1 0 2 4 ) { buffer Size = ( 1 2 8 * 1 0 2 4 ) } ch : = make ( chan ( [ ] byte ) ) close Channel : = func ( ) { close ( ch ) } go func ( ) { < - exited atomic . Store Int 3 2 ( & attached Child Is Dead , 1 ) ret , revents , err : = Get Poll Revents ( fd , 0 , ( POLLIN | POLLPRI | POLLERR | POLLHUP | POLLRDHUP | POLLNVAL ) ) if ret < 0 { logger . Errorf ( " " , err ) } else if ret > 0 { if ( revents & POLLERR ) > 0 { logger . Warnf ( " " ) } else if ( revents & POLLNVAL ) > 0 { logger . Warnf ( " " ) } } else if ret = = 0 { logger . Debugf ( " " ) once . Do ( close Channel ) return } } ( ) go func ( ) { read Size : = ( 1 2 8 * 1 0 2 4 ) offset : = 0 buf : = make ( [ ] byte , buffer Size ) avoid Atomic Load : = false defer once . Do ( close Channel ) for { nr : = 0 var err error ret , revents , err : = Get Poll Revents ( fd , - 1 , ( POLLIN | POLLPRI | POLLERR | POLLHUP | POLLRDHUP | POLLNVAL ) ) if ret < 0 { return } if both { logger . Debugf ( " " ) read : = buf [ offset : offset + read Size ] nr , err = r . Read ( read ) } if ( revents & POLLERR ) > 0 { logger . Warnf ( " " ) return } else if ( revents & POLLNVAL ) > 0 { logger . Warnf ( " " ) return } if ( ( revents & ( POLLIN | POLLPRI ) ) > 0 ) & & ! both { if ret < 0 { logger . Errorf ( " " , err ) return } else if ( revents & ( POLLHUP | POLLRDHUP | POLLERR | POLLNVAL ) ) = = 0 { logger . Debugf ( " " ) return } } read : = buf [ offset : offset + read Size ] nr , err = r . Read ( read ) } return } offset + = nr if offset > 0 & & ( offset + read Size > = buffer Size | | err ! = nil ) { ch < - buf [ 0 : offset ] offset = 0 buf = make ( [ ] byte , buffer Size ) } } } ( ) return ch } 
func get AAProfile Content ( c container ) string { profile : = strings . Trim Left ( AA _PROFILE _BASE , " \n " ) # # # Feature : unix # Allow receive via unix sockets from anywhere unix (receive ) , # Allow all unix in the container unix peer = (label = @ {profile _name } ) , ` } profile + = " \n " profile + = " \n " } state : = c . Daemon State ( ) if state . OS . App Armor Stacking & & ! state . OS . App Armor Stacked { profile + = " \n \n " profile + = ` # # # Configuration : apparmor profile loading (in namespace ) deny /sys /k [ ^e ] * { , / * * } wklx , deny /sys /ke [ ^r ] * { , / * * } wklx , deny /sys /ker [ ^n ] * { , / * * } wklx , deny /sys /kern [ ^e ] * { , / * * } wklx , deny /sys /kerne [ ^l ] * { , / * * } wklx , deny /sys /kernel / [ ^s ] * { , / * * } wklx , deny /sys /kernel /s [ ^e ] * { , / * * } wklx , deny /sys /kernel /se [ ^c ] * { , / * * } wklx , deny /sys /kernel /sec [ ^u ] * { , / * * } wklx , deny /sys /kernel /secu [ ^r ] * { , / * * } wklx , deny /sys /kernel /secur [ ^i ] * { , / * * } wklx , deny /sys /kernel /securi [ ^t ] * { , / * * } wklx , deny /sys /kernel /securit [ ^y ] * { , / * * } wklx , deny /sys /kernel /security / [ ^a ] * { , / * * } wklx , deny /sys /kernel /security /a [ ^p ] * { , / * * } wklx , deny /sys /kernel /security /ap [ ^p ] * { , / * * } wklx , deny /sys /kernel /security /app [ ^a ] * { , / * * } wklx , deny /sys /kernel /security /appa [ ^r ] * { , / * * } wklx , deny /sys /kernel /security /appar [ ^m ] * { , / * * } wklx , deny /sys /kernel /security /apparm [ ^o ] * { , / * * } wklx , deny /sys /kernel /security /apparmo [ ^r ] * { , / * * } wklx , deny /sys /kernel /security /apparmor ? * { , / * * } wklx , deny /sys /kernel /security ? * { , / * * } wklx , deny /sys /kernel ? * { , / * * } wklx , ` profile + = fmt . Sprintf ( " \ " \ " \n " , AANamespace ( c ) ) profile + = fmt . Sprintf ( " \ " \ " \n " , AANamespace ( c ) ) } else { profile + = " \n \n " profile + = " \n " } if c . Is Nesting ( ) { profile + = strings . Trim Left ( AA _PROFILE _NESTING , " \n " ) if ! state . OS . App Armor Stacking | | state . OS . App Armor Stacked { profile + = fmt . Sprintf ( " \ " \ " \n " , AAProfile Full ( c ) ) } } if ! c . Is Privileged ( ) | | state . OS . Running In User NS { profile + = strings . Trim Left ( AA _PROFILE _UNPRIVILEGED , " \n " ) } if ok { profile + = " \n \n " for _ , line : = range strings . Split ( strings . Trim ( raw Apparmor , " \n " ) , " \n " ) { profile + = fmt . Sprintf ( " \n " , line ) } } return fmt . Sprintf ( ` #include <tunables /global > profile " %s " flags = (attach _disconnected ,mediate _deleted ) { %s } ` , AAProfile Full ( c ) , strings . Trim ( profile , " \n " ) ) } 
func AALoad Profile ( c container ) error { state : = c . Daemon State ( ) if ! state . OS . App Armor Admin { return nil } if err : = mk Apparmor Namespace ( c , AANamespace ( c ) ) ; err ! = nil { return err } profile : = path . Join ( aa Path , " " , AAProfile Short ( c ) ) content , err : = ioutil . Read File ( profile ) if err ! = nil & & ! os . Is Not Exist ( err ) { return err } updated : = get AAProfile Content ( c ) if string ( content ) ! = string ( updated ) { if err : = os . Mkdir All ( path . Join ( aa Path , " " ) , 0 7 0 0 ) ; err ! = nil { return err } if err : = os . Mkdir All ( path . Join ( aa Path , " " ) , 0 7 0 0 ) ; err ! = nil { return err } if err : = ioutil . Write File ( profile , [ ] byte ( updated ) , 0 6 0 0 ) ; err ! = nil { return err } } return run Apparmor ( APPARMOR _CMD _LOAD , c ) } 
func AADestroy ( c container ) error { state : = c . Daemon State ( ) if ! state . OS . App Armor Admin { return nil } if state . OS . App Armor Stacking & & ! state . OS . App Armor Stacked { p : = path . Join ( " " , AANamespace ( c ) ) if err : = os . Remove ( p ) ; err ! = nil { logger . Error ( " " , log . Ctx { " " : err , " " : p } ) } } return run Apparmor ( APPARMOR _CMD _UNLOAD , c ) } 
func AAParse Profile ( c container ) error { state : = c . Daemon State ( ) if ! state . OS . App Armor Available { return nil } return run Apparmor ( APPARMOR _CMD _PARSE , c ) } 
func AADelete Profile ( c container ) { state : = c . Daemon State ( ) if ! state . OS . App Armor Admin { return } os . Remove ( path . Join ( get AACache Dir ( ) , AAProfile Short ( c ) ) ) os . Remove ( path . Join ( aa Path , " " , AAProfile Short ( c ) ) ) } 
func get System Handler ( syslog string , debug bool , format log . Format ) log . Handler { return nil } 
func Notify Upgrade Completed ( state * state . State , cert * shared . Cert Info ) error { notifier , err : = New Notifier ( state , cert , Notify All ) if err ! = nil { return err } return notifier ( func ( client lxd . Container Server ) error { info , err : = client . Get Connection Info ( ) if err ! = nil { return errors . Wrap ( err , " " ) } url : = fmt . Sprintf ( " " , info . Addresses [ 0 ] , database Endpoint ) request , err : = http . New Request ( " " , url , nil ) if err ! = nil { return errors . Wrap ( err , " " ) } http Client , err : = client . Get HTTPClient ( ) if err ! = nil { return errors . Wrap ( err , " " ) } response , err : = http Client . Do ( request ) if err ! = nil { return errors . Wrap ( err , " " ) } if response . Status Code ! = http . Status OK { return fmt . Errorf ( " " , response . Status ) } return nil } ) } 
func Keep Updated ( state * state . State ) ( task . Func , task . Schedule ) { f : = func ( ctx context . Context ) { ch : = make ( chan struct { } ) go func ( ) { maybe Update ( state ) close ( ch ) } ( ) select { case < - ctx . Done ( ) : case < - ch : } } schedule : = task . Every ( 5 * time . Minute ) return f , schedule } 
func maybe Update ( state * state . State ) { should Update : = false enabled , err : = Enabled ( state . Node ) if err ! = nil { logger . Errorf ( " " , err ) return } if ! enabled { return } err = state . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { outdated , err : = tx . Node Is Outdated ( ) if err ! = nil { return err } should Update = outdated return nil } ) if err ! = nil { return } if ! should Update { logger . Debugf ( " " ) return } logger . Infof ( " " ) update Executable : = os . Getenv ( " " ) if update Executable = = " " { logger . Debug ( " " ) return } logger . Infof ( " " , update Executable ) _ , err = shared . Run Command ( update Executable ) if err ! = nil { logger . Errorf ( " " , err . Error ( ) ) return } } 
func New Server ( api URL string , api Key string , agent Auth URL string , agent Username string , agent Private Key string , agent Public Key string ) ( * Server , error ) { r : = Server { api URL : api URL , api Key : api Key , last Sync ID : " " , last Change : time . Time { } , resources : make ( map [ string ] string ) , permissions : make ( map [ string ] map [ string ] [ ] string ) , permissions Lock : & sync . Mutex { } , } key Pair . Private . Unmarshal Text ( [ ] byte ( agent Private Key ) ) key Pair . Public . Unmarshal Text ( [ ] byte ( agent Public Key ) ) r . client = httpbakery . New Client ( ) auth Info : = agent . Auth Info { Key : & key Pair , Agents : [ ] agent . Agent { { URL : agent Auth URL , Username : agent Username , } , } , } err : = agent . Set Up Auth ( r . client , & auth Info ) if err ! = nil { return nil , err } r . client . Client . Jar , err = cookiejar . New ( nil ) if err ! = nil { return nil , err } return & r , nil } 
func ( r * Server ) Start Status Check ( ) { r . status Done = make ( chan int ) go func ( ) { for { select { case < - r . status Done : return case < - time . After ( time . Minute ) : if r . has Status Changed ( ) { r . flush Cache ( ) } } } } ( ) } 
func ( r * Server ) Sync Projects ( ) error { if r . Projects Func = = nil { return fmt . Errorf ( " " ) } resources : = [ ] rbac Resource { } resources Map : = map [ string ] string { } if err ! = nil { return err } resources Map [ name ] = strconv . Format Int ( id , 1 0 ) } if err ! = nil { return err } r . resources = resources Map r . resources Lock . Unlock ( ) return nil } 
func ( r * Server ) Add Project ( id int 6 4 , name string ) error { resource : = rbac Resource { Name : name , Identifier : strconv . Format Int ( id , 1 0 ) , } if err ! = nil { return err } r . resources [ name ] = strconv . Format Int ( id , 1 0 ) r . resources Lock . Unlock ( ) return nil } 
func ( r * Server ) Delete Project ( id int 6 4 ) error { if err ! = nil { return err } for k , v : = range r . resources { if v = = strconv . Format Int ( id , 1 0 ) { delete ( r . resources , k ) break } } r . resources Lock . Unlock ( ) return nil } 
func ( r * Server ) Rename Project ( id int 6 4 , name string ) error { return r . Add Project ( id , name ) } 
func ( r * Server ) Is Admin ( username string ) bool { r . permissions Lock . Lock ( ) defer r . permissions Lock . Unlock ( ) if ! cached { r . sync Permissions ( username ) } return shared . String In Slice ( " " , r . permissions [ username ] [ " " ] ) } 
func ( r * Server ) Has Permission ( username , project , permission string ) bool { r . permissions Lock . Lock ( ) defer r . permissions Lock . Unlock ( ) if ! cached { r . sync Permissions ( username ) } r . resources Lock . Lock ( ) permissions : = r . permissions [ username ] [ r . resources [ project ] ] r . resources Lock . Unlock ( ) return shared . String In Slice ( permission , permissions ) } 
func container Put ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) if err ! = nil { return Smart Error ( err ) } if response ! = nil { return response } c , err : = container Load By Project And Name ( d . State ( ) , project , name ) if err ! = nil { return Not Found ( err ) } err = util . Etag Check ( r , etag ) if err ! = nil { return Precondition Failed ( err ) } config Raw : = api . Container Put { } if err : = json . New Decoder ( r . Body ) . Decode ( & config Raw ) ; err ! = nil { return Bad Request ( err ) } architecture , err : = osarch . Architecture Id ( config Raw . Architecture ) if err ! = nil { architecture = 0 } var do func ( * operation ) error var op Type db . Operation Type if config Raw . Restore = = " " { if err ! = nil { return err } return nil } op Type = db . Operation Snapshot Update } else { } op Type = db . Operation Snapshot Restore } resources : = map [ string ] [ ] string { } resources [ " " ] = [ ] string { name } op , err : = operation Create ( d . cluster , project , operation Class Task , op Type , resources , nil , do , nil , nil ) if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } 
func rsync Send ( conn * websocket . Conn , path string , rsync Args string ) error { cmd , data Socket , stderr , err : = rsync Send Setup ( path , rsync Args ) if err ! = nil { return err } if data Socket ! = nil { defer data Socket . Close ( ) } read Done , write Done : = shared . Websocket Mirror ( conn , data Socket , io . Read Closer ( data Socket ) , nil , nil ) output , err : = ioutil . Read All ( stderr ) if err ! = nil { cmd . Process . Kill ( ) cmd . Wait ( ) return fmt . Errorf ( " \n " , err , output ) } err = cmd . Wait ( ) < - read Done < - write Done if err ! = nil { return fmt . Errorf ( " \n " , err , output ) } return nil } 
func rsync Send Setup ( path string , rsync Args string ) ( * exec . Cmd , net . Conn , io . Read Closer , error ) { auds : = fmt . Sprintf ( " " , uuid . New Random ( ) . String ( ) ) if len ( auds ) > shared . ABSTRACT _UNIX _SOCK _LEN - 1 { auds = auds [ : shared . ABSTRACT _UNIX _SOCK _LEN - 1 ] } l , err : = net . Listen ( " " , auds ) if err ! = nil { return nil , nil , nil , err } exec Path , err : = os . Readlink ( " " ) if err ! = nil { return nil , nil , nil , err } if ! shared . Path Exists ( exec Path ) { exec Path = os . Args [ 0 ] } rsync Cmd : = fmt . Sprintf ( " \ " \ " " , exec Path , auds ) args : = [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " , } if err ! = nil { return false } fields : = strings . Split ( out , " " ) cur Ver , err : = version . Parse ( fields [ 3 ] ) if err ! = nil { return false } min Ver , err : = version . Parse ( min ) if err ! = nil { return false } return cur Ver . Compare ( min Ver ) > = 0 } if rsync Check Version ( " " ) { args = append ( args , " " ) } if rsync Args ! = " " { args = append ( args , strings . Split ( rsync Args , " " ) . . . ) } args = append ( args , [ ] string { path , " " } . . . ) args = append ( args , [ ] string { " " , rsync Cmd } . . . ) cmd : = exec . Command ( " " , args . . . ) cmd . Stdout = os . Stderr stderr , err : = cmd . Stderr Pipe ( ) if err ! = nil { return nil , nil , nil , err } if err : = cmd . Start ( ) ; err ! = nil { return nil , nil , nil , err } conn , err : = l . Accept ( ) if err ! = nil { cmd . Process . Kill ( ) cmd . Wait ( ) return nil , nil , nil , err } l . Close ( ) return cmd , conn , stderr , nil } 
func tls Client Config ( info * shared . Cert Info ) ( * tls . Config , error ) { keypair : = info . Key Pair ( ) ca : = info . CA ( ) config : = shared . Init TLSConfig ( ) config . Certificates = [ ] tls . Certificate { keypair } config . Root CAs = x 5 0 9 . New Cert Pool ( ) if ca ! = nil { config . Root CAs . Add Cert ( ca ) } if err ! = nil { return nil , err } cert . Is CA = true cert . Key Usage = x 5 0 9 . Key Usage Cert Sign config . Root CAs . Add Cert ( cert ) if cert . DNSNames ! = nil { config . Server Name = cert . DNSNames [ 0 ] } return config , nil } 
func tls Check Cert ( r * http . Request , info * shared . Cert Info ) bool { cert , err : = x 5 0 9 . Parse Certificate ( info . Key Pair ( ) . Certificate [ 0 ] ) if err ! = nil { } trusted Certs : = map [ string ] x 5 0 9 . Certificate { " " : * cert } trusted , _ : = util . Check Trust State ( * r . TLS . Peer Certificates [ 0 ] , trusted Certs ) return r . TLS ! = nil & & trusted } 
func container Post Clustering Migrate ( d * Daemon , c container , old Name , new Name , new Node string ) Response { cert : = d . endpoints . Network Cert ( ) var source Address string var target Address string err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error source Address , err = tx . Node Address ( ) if err ! = nil { return errors . Wrap ( err , " " ) } node , err : = tx . Node By Name ( new Node ) if err ! = nil { return errors . Wrap ( err , " " ) } target Address = node . Address return nil } ) if err ! = nil { return Smart Error ( err ) } run : = func ( * operation ) error { if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } dest = dest . Use Target ( new Node ) dest Name : = new Name is Same Name : = false dest Name = fmt . Sprintf ( " " , uuid . New Random ( ) . String ( ) ) } if err ! = nil { return errors . Wrap ( err , " " ) } args : = lxd . Container Copy Args { Name : dest Name , Mode : " " , } copy Op , err : = dest . Copy Container ( source , * entry , & args ) if err ! = nil { return errors . Wrap ( err , " " ) } err = copy Op . Wait ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } err = delete Op . Wait ( ) if err ! = nil { return errors . Wrap ( err , " " ) } op , err : = dest . Rename Container ( dest Name , container Post ) if err ! = nil { return errors . Wrap ( err , " " ) } err = op . Wait ( ) if err ! = nil { return errors . Wrap ( err , " " ) } dest Name = old Name } if err ! = nil { return errors . Wrap ( err , " " ) } err = d . cluster . Container Config Remove ( id , " " ) if err ! = nil { return errors . Wrap ( err , " " ) } if orig Volatile Apply Template ! = " " { config : = map [ string ] string { " " : orig Volatile Apply Template , } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { return tx . Container Config Insert ( id , config ) } ) if err ! = nil { return errors . Wrap ( err , " " ) } } return nil } resources : = map [ string ] [ ] string { } resources [ " " ] = [ ] string { old Name } op , err : = operation Create ( d . cluster , c . Project ( ) , operation Class Task , db . Operation Container Migrate , resources , nil , run , nil , nil ) if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } 
func container Post Clustering Migrate With Ceph ( d * Daemon , c container , project , old Name , new Name , new Node string ) Response { run : = func ( * operation ) error { pool Name , err : = c . Storage Pool ( ) if err ! = nil { return errors . Wrap ( err , " " ) } _ , pool , err : = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { return errors . Wrap ( err , " " ) } if pool . Driver ! = " " { return fmt . Errorf ( " " ) } si , err : = storage Pool Volume Container Load Init ( d . State ( ) , c . Project ( ) , c . Name ( ) ) if err ! = nil { return errors . Wrap ( err , " " ) } s , ok : = si . ( * storage Ceph ) if ! ok { return fmt . Errorf ( " " ) } err = ceph RBDVolume Unmap ( s . Cluster Name , s . OSDPool Name , c . Name ( ) , storage Pool Volume Type Name Container , s . User Name , true ) if err ! = nil { return errors . Wrap ( err , " " ) } } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { err : = tx . Container Node Move ( old Name , new Name , new Node ) if err ! = nil { return err } pool Name , err = tx . Container Pool ( project , new Name ) if err ! = nil { return err } return nil } ) if err ! = nil { return errors . Wrap ( err , " " ) } _ , s . pool , err = d . cluster . Storage Pool Get ( pool Name ) if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } err = s . Storage Pool Init ( ) if err ! = nil { return errors . Wrap ( err , " " ) } err = ceph RBDVolume Rename ( s . Cluster Name , s . OSDPool Name , storage Pool Volume Type Name Container , old Name , new Name , s . User Name ) if err ! = nil { return errors . Wrap ( err , " " ) } } client , err : = cluster . Connect If Container Is Remote ( d . cluster , project , new Name , cert ) if err ! = nil { return errors . Wrap ( err , " " ) } if client = = nil { err : = container Post Create Container Mount Point ( d , project , new Name ) if err ! = nil { return errors . Wrap ( err , " " ) } } else { path : = fmt . Sprintf ( " " , new Name ) resp , _ , err : = client . Raw Query ( " " , path , nil , " " ) if err ! = nil { return errors . Wrap ( err , " " ) } if resp . Status Code ! = 2 0 0 { return fmt . Errorf ( " " , resp . Error ) } } return nil } resources : = map [ string ] [ ] string { } resources [ " " ] = [ ] string { old Name } op , err : = operation Create ( d . cluster , project , operation Class Task , db . Operation Container Migrate , resources , nil , run , nil , nil ) if err ! = nil { return Internal Error ( err ) } return Operation Response ( op ) } 
func internal Cluster Container Moved Post ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) container Name : = mux . Vars ( r ) [ " " ] err : = container Post Create Container Mount Point ( d , project , container Name ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func container Post Create Container Mount Point ( d * Daemon , project , container Name string ) error { c , err : = container Load By Project And Name ( d . State ( ) , project , container Name ) if err ! = nil { return errors . Wrap ( err , " " ) } pool Name , err : = c . Storage Pool ( ) if err ! = nil { return errors . Wrap ( err , " " ) } snapshot Names , err : = d . cluster . Container Get Snapshots ( project , container Name ) if err ! = nil { return errors . Wrap ( err , " " ) } container Mnt Point : = get Container Mount Point ( c . Project ( ) , pool Name , container Name ) err = create Container Mountpoint ( container Mnt Point , c . Path ( ) , c . Is Privileged ( ) ) if err ! = nil { return errors . Wrap ( err , " " ) } for _ , snapshot Name : = range snapshot Names { mnt Point : = get Snapshot Mount Point ( project , pool Name , snapshot Name ) snapshots Symlink Target : = shared . Var Path ( " " , pool Name , " " , container Name ) snapshot Mnt Point Symlink : = shared . Var Path ( " " , container Name ) err : = create Snapshot Mountpoint ( mnt Point , snapshots Symlink Target , snapshot Mnt Point Symlink ) if err ! = nil { return errors . Wrap ( err , " " ) } } return nil } 
func ( list Devices ) Contains ( k string , d Device ) bool { } old : = list [ k ] return device Equals ( old , d ) } 
func ( list Devices ) Update ( newlist Devices ) ( map [ string ] Device , map [ string ] Device , map [ string ] Device , [ ] string ) { rmlist : = map [ string ] Device { } addlist : = map [ string ] Device { } updatelist : = map [ string ] Device { } for key , d : = range list { if ! newlist . Contains ( key , d ) { rmlist [ key ] = d } } for key , d : = range newlist { if ! list . Contains ( key , d ) { addlist [ key ] = d } } update Diff : = [ ] string { } for key , d : = range addlist { src Old Device : = rmlist [ key ] var old Device Device err : = shared . Deep Copy ( & src Old Device , & old Device ) if err ! = nil { continue } src New Device : = newlist [ key ] var new Device Device err = shared . Deep Copy ( & src New Device , & new Device ) if err ! = nil { continue } update Diff = device Equals Diff Keys ( old Device , new Device ) for _ , k : = range [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , " " } { delete ( old Device , k ) delete ( new Device , k ) } if device Equals ( old Device , new Device ) { delete ( rmlist , key ) delete ( addlist , key ) updatelist [ key ] = d } } return rmlist , addlist , updatelist , update Diff } 
func ( list Devices ) Device Names ( ) [ ] string { sortable : = sortable Devices { } for k , d : = range list { sortable = append ( sortable , named Device { k , d } ) } sort . Sort ( sortable ) return sortable . Names ( ) } 
func Debug ( msg string , ctx . . . interface { } ) { if Log ! = nil { Log . Debug ( msg , ctx . . . ) } } 
func Info ( msg string , ctx . . . interface { } ) { if Log ! = nil { Log . Info ( msg , ctx . . . ) } } 
func Warn ( msg string , ctx . . . interface { } ) { if Log ! = nil { Log . Warn ( msg , ctx . . . ) } } 
func Error ( msg string , ctx . . . interface { } ) { if Log ! = nil { Log . Error ( msg , ctx . . . ) } } 
func Crit ( msg string , ctx . . . interface { } ) { if Log ! = nil { Log . Crit ( msg , ctx . . . ) } } 
func Infof ( format string , args . . . interface { } ) { if Log ! = nil { Log . Info ( fmt . Sprintf ( format , args . . . ) ) } } 
func Debugf ( format string , args . . . interface { } ) { if Log ! = nil { Log . Debug ( fmt . Sprintf ( format , args . . . ) ) } } 
func Warnf ( format string , args . . . interface { } ) { if Log ! = nil { Log . Warn ( fmt . Sprintf ( format , args . . . ) ) } } 
func Errorf ( format string , args . . . interface { } ) { if Log ! = nil { Log . Error ( fmt . Sprintf ( format , args . . . ) ) } } 
func Critf ( format string , args . . . interface { } ) { if Log ! = nil { Log . Crit ( fmt . Sprintf ( format , args . . . ) ) } } 
func event Forward ( id int 6 4 , event api . Event ) { if event . Type = = " " { err : = json . Unmarshal ( event . Metadata , & log Entry ) if err ! = nil { return } if ! debug & & log Entry . Level = = " " { return } if ! debug & & ! verbose & & log Entry . Level = = " " { return } } err : = event Broadcast ( " " , event , true ) if err ! = nil { logger . Warnf ( " " , id , err ) } } 
func get Container Mount Point ( project string , pool Name string , container Name string ) string { return shared . Var Path ( " " , pool Name , " " , project Prefix ( project , container Name ) ) } 
func get Snapshot Mount Point ( project , pool Name string , snapshot Name string ) string { return shared . Var Path ( " " , pool Name , " " , project Prefix ( project , snapshot Name ) ) } 
func get Image Mount Point ( pool Name string , fingerprint string ) string { return shared . Var Path ( " " , pool Name , " " , fingerprint ) } 
func get Storage Pool Volume Mount Point ( pool Name string , volume Name string ) string { return shared . Var Path ( " " , pool Name , " " , volume Name ) } 
func get Storage Pool Volume Snapshot Mount Point ( pool Name string , snapshot Name string ) string { return shared . Var Path ( " " , pool Name , " " , snapshot Name ) } 
func Storage Progress Reader ( op * operation , key string , description string ) func ( io . Read Closer ) io . Read Closer { return func ( reader io . Read Closer ) io . Read Closer { if op = = nil { return reader } progress : = func ( progress Int int 6 4 , speed Int int 6 4 ) { progress Wrapper Render ( op , key , description , progress Int , speed Int ) } read Pipe : = & ioprogress . Progress Reader { Read Closer : reader , Tracker : & ioprogress . Progress Tracker { Handler : progress , } , } return read Pipe } } 
func Storage Progress Writer ( op * operation , key string , description string ) func ( io . Write Closer ) io . Write Closer { return func ( writer io . Write Closer ) io . Write Closer { if op = = nil { return writer } progress : = func ( progress Int int 6 4 , speed Int int 6 4 ) { progress Wrapper Render ( op , key , description , progress Int , speed Int ) } write Pipe : = & ioprogress . Progress Writer { Write Closer : writer , Tracker : & ioprogress . Progress Tracker { Handler : progress , } , } return write Pipe } } 
func Get LSBRelease ( ) ( map [ string ] string , error ) { os Release , err : = get LSBRelease ( " " ) if os . Is Not Exist ( err ) { return get LSBRelease ( " " ) } return os Release , err } 
func Reset ( path string , imports [ ] string ) error { content : = fmt . Sprintf ( `package %s import ( ` , os . Getenv ( " " ) , os . Args [ 0 ] ) for _ , uri : = range imports { content + = fmt . Sprintf ( " \t \n " , uri ) } content + = " \n \n " bytes : = [ ] byte ( content ) var err error if path = = " " { _ , err = os . Stdout . Write ( bytes ) } else { err = ioutil . Write File ( path , [ ] byte ( content ) , 0 6 4 4 ) } if err ! = nil { errors . Wrapf ( err , " " , path ) } return nil } 
func Append ( path string , snippet Snippet ) error { buffer : = new Buffer ( ) buffer . N ( ) err : = snippet . Generate ( buffer ) if err ! = nil { return errors . Wrap ( err , " " ) } var file * os . File if path = = " " { file = os . Stdout } else { file , err = os . Open File ( path , os . O _APPEND | os . O _WRONLY , 0 6 4 4 ) if err ! = nil { return errors . Wrapf ( err , " " , path ) } defer file . Close ( ) } bytes , err : = buffer . code ( ) if err ! = nil { return err } _ , err = file . Write ( bytes ) if err ! = nil { return errors . Wrapf ( err , " " , path ) } return nil } 
func Container To Args ( container * Container ) Container Args { args : = Container Args { ID : container . ID , Project : container . Project , Name : container . Name , Node : container . Node , Ctype : Container Type ( container . Type ) , Architecture : container . Architecture , Ephemeral : container . Ephemeral , Creation Date : container . Creation Date , Stateful : container . Stateful , Last Used Date : container . Last Use Date , Description : container . Description , Config : container . Config , Devices : container . Devices , Profiles : container . Profiles , Expiry Date : container . Expiry Date , } if args . Devices = = nil { args . Devices = types . Devices { } } return args } 
func ( c * Cluster Tx ) Container Names ( project string ) ( [ ] string , error ) { stmt : = ` SELECT containers .name FROM containers JOIN projects ON projects .id = containers .project _id WHERE projects .name = ? AND containers .type = ? ` return query . Select Strings ( c . tx , stmt , project , CType Regular ) } 
func ( c * Cluster Tx ) Container Node Address ( project string , name string ) ( string , error ) { stmt : = ` SELECT nodes .id , nodes .address FROM nodes JOIN containers ON containers .node _id = nodes .id JOIN projects ON projects .id = containers .project _id WHERE projects .name = ? AND containers .name = ? ` var address string var id int 6 4 rows , err : = c . tx . Query ( stmt , project , name ) if err ! = nil { return " " , err } defer rows . Close ( ) if ! rows . Next ( ) { return " " , Err No Such Object } err = rows . Scan ( & id , & address ) if err ! = nil { return " " , err } if rows . Next ( ) { return " " , fmt . Errorf ( " " ) } err = rows . Err ( ) if err ! = nil { return " " , err } if id = = c . node ID { return " " , nil } return address , nil } 
func ( c * Cluster Tx ) Containers List By Node Address ( project string ) ( map [ string ] [ ] string , error ) { offline Threshold , err : = c . Node Offline Threshold ( ) if err ! = nil { return nil , err } stmt : = ` SELECT containers .name , nodes .id , nodes .address , nodes .heartbeat FROM containers JOIN nodes ON nodes .id = containers .node _id JOIN projects ON projects .id = containers .project _id WHERE containers .type = ? AND projects .name = ? ORDER BY containers .id ` rows , err : = c . tx . Query ( stmt , CType Regular , project ) if err ! = nil { return nil , err } defer rows . Close ( ) result : = map [ string ] [ ] string { } for i : = 0 ; rows . Next ( ) ; i + + { var name string var node Address string var node ID int 6 4 var node Heartbeat time . Time err : = rows . Scan ( & name , & node ID , & node Address , & node Heartbeat ) if err ! = nil { return nil , err } if node ID = = c . node ID { node Address = " " } else if node Is Offline ( offline Threshold , node Heartbeat ) { node Address = " " } result [ node Address ] = append ( result [ node Address ] , name ) } err = rows . Err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * Cluster Tx ) Container List Expanded ( ) ( [ ] Container , error ) { containers , err : = c . Container List ( Container Filter { } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } profiles , err : = c . Profile List ( Profile Filter { } ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , profile : = range profiles { profiles By Name , ok : = profiles By Project And Name [ profile . Project ] if ! ok { profiles By Name = map [ string ] Profile { } profiles By Project And Name [ profile . Project ] = profiles By Name } profiles By Name [ profile . Name ] = profile } for i , container : = range containers { profiles : = make ( [ ] api . Profile , len ( container . Profiles ) ) for j , name : = range container . Profiles { profile : = profiles By Project And Name [ container . Project ] [ name ] profiles [ j ] = * Profile To API ( & profile ) } containers [ i ] . Config = Profiles Expand Config ( container . Config , profiles ) containers [ i ] . Devices = Profiles Expand Devices ( container . Devices , profiles ) } return containers , nil } 
func ( c * Cluster Tx ) Containers By Node Name ( project string ) ( map [ string ] string , error ) { stmt : = ` SELECT containers .name , nodes .name FROM containers JOIN nodes ON nodes .id = containers .node _id JOIN projects ON projects .id = containers .project _id WHERE containers .type = ? AND projects .name = ? ` rows , err : = c . tx . Query ( stmt , CType Regular , project ) if err ! = nil { return nil , err } defer rows . Close ( ) result : = map [ string ] string { } for i : = 0 ; rows . Next ( ) ; i + + { var name string var node Name string err : = rows . Scan ( & name , & node Name ) if err ! = nil { return nil , err } result [ name ] = node Name } err = rows . Err ( ) if err ! = nil { return nil , err } return result , nil } 
func ( c * Cluster Tx ) Snapshot IDs And Names ( name string ) ( map [ int ] string , error ) { prefix : = name + shared . Snapshot Delimiter length : = len ( prefix ) objects : = make ( [ ] struct { ID int Name string } , 0 ) dest : = func ( i int ) [ ] interface { } { objects = append ( objects , struct { ID int Name string } { } ) return [ ] interface { } { & objects [ i ] . ID , & objects [ i ] . Name } } stmt , err : = c . tx . Prepare ( " " ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , length , prefix , CType Snapshot ) if err ! = nil { return nil , err } result : = make ( map [ int ] string ) for i : = range objects { result [ objects [ i ] . ID ] = strings . Split ( objects [ i ] . Name , shared . Snapshot Delimiter ) [ 1 ] } return result , nil } 
func ( c * Cluster Tx ) Container Node Move ( old Name , new Name , new Node string ) error { if err ! = nil { return errors . Wrap ( err , " " ) } pool ID , err : = c . Storage Pool ID ( pool Name ) if err ! = nil { return errors . Wrap ( err , " " ) } pool Driver , err : = c . Storage Pool Driver ( pool ID ) if err ! = nil { return errors . Wrap ( err , " " ) } if pool Driver ! = " " { return fmt . Errorf ( " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } snapshots , err : = c . Snapshot IDs And Names ( old Name ) if err ! = nil { return errors . Wrap ( err , " " ) } node , err : = c . Node By Name ( new Node ) if err ! = nil { return errors . Wrap ( err , " " ) } stmt : = " " result , err : = c . tx . Exec ( stmt , node . ID , new Name , container ID ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } for snapshot ID , snapshot Name : = range snapshots { new Snapshot Name : = new Name + shared . Snapshot Delimiter + snapshot Name stmt : = " " result , err : = c . tx . Exec ( stmt , node . ID , new Snapshot Name , snapshot ID ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } } } if err ! = nil { return errors . Wrap ( err , " " ) } stmt = " " result , err = c . tx . Exec ( stmt , new Name , old Name , pool ID , Storage Pool Volume Type Container ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = int 6 4 ( count ) { return fmt . Errorf ( " " , n ) } for _ , snapshot Name : = range snapshots { old Snapshot Name : = old Name + shared . Snapshot Delimiter + snapshot Name new Snapshot Name : = new Name + shared . Snapshot Delimiter + snapshot Name stmt : = " " result , err : = c . tx . Exec ( stmt , new Snapshot Name , old Snapshot Name , pool ID , Storage Pool Volume Type Container ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = int 6 4 ( count ) { return fmt . Errorf ( " " , n ) } } return nil } 
func ( c * Cluster Tx ) Container Node List ( ) ( [ ] Container , error ) { node , err : = c . Node Name ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } filter : = Container Filter { Node : node , Type : int ( CType Regular ) , } return c . Container List ( filter ) } 
func ( c * Cluster Tx ) Container Node Project List ( project string ) ( [ ] Container , error ) { node , err : = c . Node Name ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } filter : = Container Filter { Project : project , Node : node , Type : int ( CType Regular ) , } return c . Container List ( filter ) } 
func ( c * Cluster Tx ) Container Config Insert ( id int , config map [ string ] string ) error { return Container Config Insert ( c . tx , id , config ) } 
func ( c * Cluster ) Container Remove ( project , name string ) error { return c . Transaction ( func ( tx * Cluster Tx ) error { return tx . Container Delete ( project , name ) } ) } 
func ( c * Cluster ) Container Project And Name ( id int ) ( string , string , error ) { q : = ` SELECT projects .name , containers .name FROM containers JOIN projects ON projects .id = containers .project _id WHERE containers .id = ? ` project : = " " name : = " " arg 1 : = [ ] interface { } { id } arg 2 : = [ ] interface { } { & project , & name } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err = = sql . Err No Rows { return " " , " " , Err No Such Object } return project , name , err } 
func Container Config Clear ( tx * sql . Tx , id int ) error { _ , err : = tx . Exec ( " " , id ) if err ! = nil { return err } _ , err = tx . Exec ( " " , id ) if err ! = nil { return err } _ , err = tx . Exec ( `DELETE FROM containers _devices _config WHERE id IN (SELECT containers _devices _config .id FROM containers _devices _config JOIN containers _devices ON containers _devices _config .container _device _id =containers _devices .id WHERE containers _devices .container _id = ? ) ` , id ) if err ! = nil { return err } _ , err = tx . Exec ( " " , id ) return err } 
func Container Config Insert ( tx * sql . Tx , id int , config map [ string ] string ) error { str : = " " stmt , err : = tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) for k , v : = range config { if v = = " " { continue } _ , err : = stmt . Exec ( id , k , v ) if err ! = nil { logger . Debugf ( " " , k , v , id ) return err } } return nil } 
func ( c * Cluster ) Container Config Get ( id int , key string ) ( string , error ) { q : = " " value : = " " arg 1 : = [ ] interface { } { id , key } arg 2 : = [ ] interface { } { & value } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err = = sql . Err No Rows { return " " , Err No Such Object } return value , err } 
func ( c * Cluster ) Container Config Remove ( id int , key string ) error { err : = exec ( c . db , " " , key , id ) return err } 
func ( c * Cluster ) Container Set Stateful ( id int , stateful bool ) error { stateful Int : = 0 if stateful { stateful Int = 1 } err : = exec ( c . db , " " , stateful Int , id ) return err } 
func Container Profiles Insert ( tx * sql . Tx , id int , project string , profiles [ ] string ) error { enabled , err : = project Has Profiles ( tx , project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! enabled { project = " " } apply Order : = 1 str : = ` INSERT INTO containers _profiles (container _id , profile _id , apply _order ) VALUES ( ? , (SELECT profiles .id FROM profiles JOIN projects ON projects .id =profiles .project _id WHERE projects .name = ? AND profiles .name = ? ) , ? ) ` stmt , err : = tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) for _ , profile : = range profiles { _ , err = stmt . Exec ( id , project , profile , apply Order ) if err ! = nil { logger . Debugf ( " " , profile , err ) return err } apply Order = apply Order + 1 } return nil } 
func ( c * Cluster ) Container Profiles ( id int ) ( [ ] string , error ) { var name string var profiles [ ] string query : = ` SELECT name FROM containers _profiles JOIN profiles ON containers _profiles .profile _id =profiles .id WHERE container _id = ? ORDER BY containers _profiles .apply _order ` inargs : = [ ] interface { } { id } outfmt : = [ ] interface { } { name } results , err : = query Scan ( c . db , query , inargs , outfmt ) if err ! = nil { return nil , err } for _ , r : = range results { name = r [ 0 ] . ( string ) profiles = append ( profiles , name ) } return profiles , nil } 
func ( c * Cluster ) Container Config ( id int ) ( map [ string ] string , error ) { var key , value string q : = `SELECT key , value FROM containers _config WHERE container _id = ? ` inargs : = [ ] interface { } { id } outfmt : = [ ] interface { } { key , value } if err ! = nil { return nil , err } config : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * Cluster ) Legacy Containers List ( c Type Container Type ) ( [ ] string , error ) { q : = fmt . Sprintf ( " " ) inargs : = [ ] interface { } { c Type } var container string outfmt : = [ ] interface { } { container } result , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } var ret [ ] string for _ , container : = range result { ret = append ( ret , container [ 0 ] . ( string ) ) } return ret , nil } 
func ( c * Cluster ) Container Set State ( id int , state string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { stmt , err : = tx . tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) if _ , err = stmt . Exec ( id , state ) ; err ! = nil { return err } return nil } ) return err } 
func Container Update ( tx * sql . Tx , id int , description string , architecture int , ephemeral bool , expiry Date time . Time ) error { str : = fmt . Sprintf ( " " ) stmt , err : = tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) ephemeral Int : = 0 if ephemeral { ephemeral Int = 1 } if expiry Date . Is Zero ( ) { _ , err = stmt . Exec ( description , architecture , ephemeral Int , " " , id ) } else { _ , err = stmt . Exec ( description , architecture , ephemeral Int , expiry Date , id ) } if err ! = nil { return err } return nil } 
func ( c * Cluster ) Container Last Used Update ( id int , date time . Time ) error { stmt : = `UPDATE containers SET last _use _date = ? WHERE id = ? ` err : = exec ( c . db , stmt , date , id ) return err } 
func ( c * Cluster ) Container Get Snapshots ( project , name string ) ( [ ] string , error ) { result : = [ ] string { } regexp : = name + shared . Snapshot Delimiter length : = len ( regexp ) q : = ` SELECT containers .name FROM containers JOIN projects ON projects .id = containers .project _id WHERE projects .name = ? AND containers .type = ? AND SUBSTR (containers .name , 1 , ? ) = ? ` inargs : = [ ] interface { } { project , CType Snapshot , length , regexp } outfmt : = [ ] interface { } { name } db Results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return result , err } for _ , r : = range db Results { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * Cluster Tx ) Container Get Snapshots Full ( project string , name string ) ( [ ] Container , error ) { filter : = Container Filter { Parent : name , Project : project , Type : int ( CType Snapshot ) , } return c . Container List ( filter ) } 
func ( c * Cluster ) Container Next Snapshot ( project string , name string , pattern string ) int { base : = name + shared . Snapshot Delimiter length : = len ( base ) q : = ` SELECT containers .name FROM containers JOIN projects ON projects .id = containers .project _id WHERE projects .name = ? AND containers .type = ? AND SUBSTR (containers .name , 1 , ? ) = ? ` var numstr string inargs : = [ ] interface { } { project , CType Snapshot , length , base } outfmt : = [ ] interface { } { numstr } results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return 0 } max : = 0 for _ , r : = range results { snap Only Name : = strings . Split N ( r [ 0 ] . ( string ) , shared . Snapshot Delimiter , 2 ) [ 1 ] fields : = strings . Split N ( pattern , " " , 2 ) var num int count , err : = fmt . Sscanf ( snap Only Name , fmt . Sprintf ( " " , fields [ 0 ] , fields [ 1 ] ) , & num ) if err ! = nil | | count ! = 1 { continue } if num > = max { max = num + 1 } } return max } 
func ( c * Cluster ) Container Pool ( project , container Name string ) ( string , error ) { var pool Name string err : = c . Transaction ( func ( tx * Cluster Tx ) error { var err error pool Name , err = tx . Container Pool ( project , container Name ) return err } ) return pool Name , err } 
func ( c * Cluster Tx ) Container Pool ( project , container Name string ) ( string , error ) { query : = ` SELECT storage _pools .name FROM storage _pools JOIN storage _volumes ON storage _pools .id =storage _volumes .storage _pool _id JOIN containers ON containers .name =storage _volumes .name JOIN projects ON projects .id =containers .project _id WHERE projects .name = ? AND storage _volumes .node _id = ? AND storage _volumes .name = ? AND storage _volumes .type = ? ` inargs : = [ ] interface { } { project , c . node ID , container Name , Storage Pool Volume Type Container } outargs : = [ ] interface { } { & pool Name } err : = c . tx . Query Row ( query , inargs . . . ) . Scan ( outargs . . . ) if err ! = nil { if err = = sql . Err No Rows { return " " , Err No Such Object } return " " , err } return pool Name , nil } 
func ( c * Cluster ) Container Get Backup ( project , name string ) ( Container Backup Args , error ) { args : = Container Backup Args { } args . Name = name container Only Int : = - 1 optimized Storage Int : = - 1 q : = ` SELECT containers _backups .id , containers _backups .container _id , containers _backups .creation _date , containers _backups .expiry _date , containers _backups .container _only , containers _backups .optimized _storage FROM containers _backups JOIN containers ON containers .id =containers _backups .container _id JOIN projects ON projects .id =containers .project _id WHERE projects .name = ? AND containers _backups .name = ? ` arg 1 : = [ ] interface { } { project , name } arg 2 : = [ ] interface { } { & args . ID , & args . Container ID , & args . Creation Date , & args . Expiry Date , & container Only Int , & optimized Storage Int } err : = db Query Row Scan ( c . db , q , arg 1 , arg 2 ) if err ! = nil { if err = = sql . Err No Rows { return args , Err No Such Object } return args , err } if container Only Int = = 1 { args . Container Only = true } if optimized Storage Int = = 1 { args . Optimized Storage = true } return args , nil } 
func ( c * Cluster ) Container Get Backups ( project , name string ) ( [ ] string , error ) { var result [ ] string q : = `SELECT containers _backups .name FROM containers _backups JOIN containers ON containers _backups .container _id =containers .id JOIN projects ON projects .id =containers .project _id WHERE projects .name = ? AND containers .name = ? ` inargs : = [ ] interface { } { project , name } outfmt : = [ ] interface { } { name } db Results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return nil , err } for _ , r : = range db Results { result = append ( result , r [ 0 ] . ( string ) ) } return result , nil } 
func ( c * Cluster ) Container Backup Create ( args Container Backup Args ) error { _ , err : = c . Container Backup ID ( args . Name ) if err = = nil { return Err Already Defined } err = c . Transaction ( func ( tx * Cluster Tx ) error { container Only Int : = 0 if args . Container Only { container Only Int = 1 } optimized Storage Int : = 0 if args . Optimized Storage { optimized Storage Int = 1 } str : = fmt . Sprintf ( " " ) stmt , err : = tx . tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) result , err : = stmt . Exec ( args . Container ID , args . Name , args . Creation Date . Unix ( ) , args . Expiry Date . Unix ( ) , container Only Int , optimized Storage Int ) if err ! = nil { return err } _ , err = result . Last Insert Id ( ) if err ! = nil { return fmt . Errorf ( " " , args . Name ) } return nil } ) return err } 
func ( c * Cluster ) Container Backup Remove ( name string ) error { id , err : = c . Container Backup ID ( name ) if err ! = nil { return err } err = exec ( c . db , " " , id ) if err ! = nil { return err } return nil } 
func ( c * Cluster ) Container Backup Rename ( old Name , new Name string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { str : = fmt . Sprintf ( " " ) stmt , err : = tx . tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) logger . Debug ( " " , log . Ctx { " " : " " , " " : old Name , " " : new Name } ) if _ , err : = stmt . Exec ( new Name , old Name ) ; err ! = nil { return err } return nil } ) return err } 
func ( c * Cluster ) Container Backups Get Expired ( ) ( [ ] string , error ) { var result [ ] string var name string var expiry Date string q : = `SELECT containers _backups .name , containers _backups .expiry _date FROM containers _backups ` outfmt : = [ ] interface { } { name , expiry Date } db Results , err : = query Scan ( c . db , q , nil , outfmt ) if err ! = nil { return nil , err } for _ , r : = range db Results { timestamp : = r [ 1 ] var backup Expiry time . Time err = backup Expiry . Unmarshal Text ( [ ] byte ( timestamp . ( string ) ) ) if err ! = nil { return [ ] string { } , err } if backup Expiry . Is Zero ( ) { } } } return result , nil } 
func Default OS ( ) * OS { new OS : = & OS { Var Dir : shared . Var Path ( ) , Cache Dir : shared . Cache Path ( ) , Log Dir : shared . Log Path ( ) , } new OS . Inotify Watch . Fd = - 1 new OS . Inotify Watch . Targets = make ( map [ string ] * Inotify Target Info ) return new OS } 
func ( s * OS ) Init ( ) error { err : = s . init Dirs ( ) if err ! = nil { return err } s . Architectures , err = util . Get Architectures ( ) if err ! = nil { return err } s . Lxc Path = filepath . Join ( s . Var Dir , " " ) s . Backing FS , err = util . Filesystem Detect ( s . Lxc Path ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err } ) } s . Idmap Set = util . Get Idmap Set ( ) s . Exec Path = util . Get Exec Path ( ) s . Running In User NS = shared . Running In User NS ( ) s . init App Armor ( ) s . init CGroup ( ) return nil } 
func ( op * operation ) Add Handler ( function func ( api . Operation ) ) ( * Event Target , error ) { if err ! = nil { return nil , err } defer op . handler Lock . Unlock ( ) } err : = json . Unmarshal ( event . Metadata , & new Op ) if err ! = nil | | new Op . ID ! = op . ID { return } function ( new Op ) } return op . listener . Add Handler ( [ ] string { " " } , wrapped ) } 
func ( op * operation ) Get Websocket ( secret string ) ( * websocket . Conn , error ) { return op . r . Get Operation Websocket ( op . ID , secret ) } 
func ( op * operation ) Remove Handler ( target * Event Target ) error { defer op . handler Lock . Unlock ( ) } return op . listener . Remove Handler ( target ) } 
func ( op * operation ) Refresh ( ) error { if err ! = nil { return err } return nil } 
func ( op * operation ) Wait ( ) error { } return nil } if err ! = nil { return err } < - op . ch Active } return nil } 
func ( op * remote Operation ) Add Handler ( function func ( api . Operation ) ) ( * Event Target , error ) { var err error var target * Event Target if err ! = nil { return nil , err } } else { } return target , nil } 
func ( op * remote Operation ) Cancel Target ( ) error { if op . target Op = = nil { return fmt . Errorf ( " " ) } return op . target Op . Cancel ( ) } 
func ( op * remote Operation ) Get Target ( ) ( * api . Operation , error ) { if op . target Op = = nil { return nil , fmt . Errorf ( " " ) } op API : = op . target Op . Get ( ) return & op API , nil } 
func ( op * remote Operation ) Wait ( ) error { < - op . ch Done if op . ch Post ! = nil { < - op . ch Post } return op . err } 
func Up ( config * Config ) ( * Endpoints , error ) { if config . Dir = = " " { return nil , fmt . Errorf ( " " ) } if config . Unix Socket = = " " { return nil , fmt . Errorf ( " " ) } if config . Rest Server = = nil { return nil , fmt . Errorf ( " " ) } if config . Dev Lxd Server = = nil { return nil , fmt . Errorf ( " " ) } if config . Cert = = nil { return nil , fmt . Errorf ( " " ) } endpoints : = & Endpoints { systemd Listen FDs Start : util . Systemd Listen FDs Start , } err : = endpoints . up ( config ) if err ! = nil { endpoints . Down ( ) return nil , err } return endpoints , nil } 
func ( e * Endpoints ) up ( config * Config ) error { e . mu . Lock ( ) defer e . mu . Unlock ( ) e . servers = map [ kind ] * http . Server { devlxd : config . Dev Lxd Server , local : config . Rest Server , network : config . Rest Server , cluster : config . Rest Server , pprof : pprof Create Server ( ) , } e . cert = config . Cert e . inherited = map [ kind ] bool { } var err error if len ( systemd Listeners ) > 0 { e . listeners = activated Listeners ( systemd Listeners , e . cert ) for kind : = range e . listeners { e . inherited [ kind ] = true } } else { e . listeners = map [ kind ] net . Listener { } e . listeners [ local ] , err = local Create Listener ( config . Unix Socket , config . Local Unix Socket Group ) if err ! = nil { return fmt . Errorf ( " " , err ) } } if err ! = nil { return err } if config . Network Address ! = " " { listener , ok : = e . listeners [ network ] if ok { logger . Infof ( " " ) listener . Close ( ) e . inherited [ network ] = false } is Covered : = util . Is Address Covered ( config . Cluster Address , config . Network Address ) if config . Cluster Address ! = " " & & ! is Covered { e . listeners [ cluster ] , err = cluster Create Listener ( config . Cluster Address , e . cert ) if err ! = nil { return err } logger . Infof ( " " ) e . serve HTTP ( cluster ) } } if config . Debug Address ! = " " { e . listeners [ pprof ] , err = pprof Create Listener ( config . Debug Address ) if err ! = nil { return err } logger . Infof ( " " ) e . serve HTTP ( pprof ) } logger . Infof ( " " ) e . serve HTTP ( devlxd ) logger . Infof ( " " ) e . serve HTTP ( local ) e . serve HTTP ( network ) return nil } 
func ( e * Endpoints ) Down ( ) error { e . mu . Lock ( ) defer e . mu . Unlock ( ) if e . listeners [ network ] ! = nil | | e . listeners [ local ] ! = nil { logger . Infof ( " " ) err : = e . close Listener ( network ) if err ! = nil { return err } err = e . close Listener ( local ) if err ! = nil { return err } } if e . listeners [ cluster ] ! = nil { logger . Infof ( " " ) err : = e . close Listener ( cluster ) if err ! = nil { return err } } if e . listeners [ devlxd ] ! = nil { logger . Infof ( " " ) err : = e . close Listener ( devlxd ) if err ! = nil { return err } } if e . listeners [ pprof ] ! = nil { logger . Infof ( " " ) err : = e . close Listener ( pprof ) if err ! = nil { return err } } if e . tomb ! = nil { e . tomb . Kill ( nil ) e . tomb . Wait ( ) } return nil } 
func ( e * Endpoints ) serve HTTP ( kind kind ) { listener : = e . listeners [ kind ] if listener = = nil { return } ctx : = log . Ctx { " " : listener . Addr ( ) } if e . inherited [ kind ] { ctx [ " " ] = true } message : = fmt . Sprintf ( " " , descriptions [ kind ] ) logger . Info ( message , ctx ) server : = e . servers [ kind ] } e . tomb . Go ( func ( ) error { server . Serve ( listener ) return nil } ) } 
func ( e * Endpoints ) close Listener ( kind kind ) error { listener : = e . listeners [ kind ] if listener = = nil { return nil } delete ( e . listeners , kind ) logger . Info ( " " , log . Ctx { " " : listener . Addr ( ) } ) return listener . Close ( ) } 
func activated Listeners ( systemd Listeners [ ] net . Listener , cert * shared . Cert Info ) map [ kind ] net . Listener { listeners : = map [ kind ] net . Listener { } for _ , listener : = range systemd Listeners { var kind kind switch listener . ( type ) { case * net . Unix Listener : kind = local case * net . TCPListener : kind = network listener = network TLSListener ( listener , cert ) default : continue } listeners [ kind ] = listener } return listeners } 
func ( c * Config ) Candid Server ( ) ( string , string , int 6 4 , string ) { return c . m . Get String ( " " ) , c . m . Get String ( " " ) , c . m . Get Int 6 4 ( " " ) , c . m . Get String ( " " ) } 
func ( c * Config ) RBACServer ( ) ( string , string , int 6 4 , string , string , string , string ) { return c . m . Get String ( " " ) , c . m . Get String ( " " ) , c . m . Get Int 6 4 ( " " ) , c . m . Get String ( " " ) , c . m . Get String ( " " ) , c . m . Get String ( " " ) , c . m . Get String ( " " ) } 
func ( c * Config ) Auto Update Interval ( ) time . Duration { n : = c . m . Get Int 6 4 ( " " ) return time . Duration ( n ) * time . Hour } 
func ( c * Config ) MAASController ( ) ( string , string ) { url : = c . m . Get String ( " " ) key : = c . m . Get String ( " " ) return url , key } 
func ( c * Config ) Offline Threshold ( ) time . Duration { n : = c . m . Get Int 6 4 ( " " ) return time . Duration ( n ) * time . Second } 
func Config Get String ( cluster * db . Cluster , key string ) ( string , error ) { config , err : = config Get ( cluster ) if err ! = nil { return " " , err } return config . m . Get String ( key ) , nil } 
func Config Get Bool ( cluster * db . Cluster , key string ) ( bool , error ) { config , err : = config Get ( cluster ) if err ! = nil { return false , err } return config . m . Get Bool ( key ) , nil } 
func Config Get Int 6 4 ( cluster * db . Cluster , key string ) ( int 6 4 , error ) { config , err : = config Get ( cluster ) if err ! = nil { return 0 , err } return config . m . Get Int 6 4 ( key ) , nil } 
func ( e * Endpoints ) Cluster Address ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener : = e . listeners [ cluster ] if listener = = nil { return " " } return listener . Addr ( ) . String ( ) } 
func Debug ( msg string , ctx . . . interface { } ) { if Log ! = nil { pc , fn , line , _ : = runtime . Caller ( 1 ) msg : = fmt . Sprintf ( " " , fn , line , runtime . Func For PC ( pc ) . Name ( ) , msg ) Log . Debug ( msg , ctx . . . ) } } 
func Infof ( format string , args . . . interface { } ) { if Log ! = nil { msg : = fmt . Sprintf ( format , args . . . ) pc , fn , line , _ : = runtime . Caller ( 1 ) msg = fmt . Sprintf ( " " , fn , line , runtime . Func For PC ( pc ) . Name ( ) , msg ) Log . Info ( msg ) } } 
func Rest Server ( d * Daemon ) * http . Server { mux : = mux . New Router ( ) mux . Strict Slash ( false ) mux . Handle Func ( " " , func ( w http . Response Writer , r * http . Request ) { w . Header ( ) . Set ( " " , " " ) Sync Response ( true , [ ] string { " " } ) . Render ( w ) } ) for endpoint , f : = range d . gateway . Handler Funcs ( ) { mux . Handle Func ( endpoint , f ) } for _ , c : = range api 1 0 { d . create Cmd ( mux , " " , c ) } for _ , c : = range api Internal { d . create Cmd ( mux , " " , c ) } mux . Not Found Handler = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { logger . Info ( " " , log . Ctx { " " : r . URL } ) w . Header ( ) . Set ( " " , " " ) Not Found ( nil ) . Render ( w ) } ) return & http . Server { Handler : & lxd Http Server { r : mux , d : d } } } 
func project Param ( request * http . Request ) string { project : = query Param ( request , " " ) if project = = " " { project = " " } return project } 
func query Param ( request * http . Request , key string ) string { var values url . Values var err error if request . URL ! = nil { values , err = url . Parse Query ( request . URL . Raw Query ) if err ! = nil { logger . Warnf ( " " , request . URL . Raw Query , err ) return " " } } if values = = nil { values = make ( url . Values ) } return values . Get ( key ) } 
func new Db ( ) * cobra . Command { cmd : = & cobra . Command { Use : " " , Short : " " , Run E : func ( cmd * cobra . Command , args [ ] string ) error { return fmt . Errorf ( " " ) } , } cmd . Add Command ( new Db Schema ( ) ) cmd . Add Command ( new Db Mapper ( ) ) return cmd } 
func ( t Operation Type ) Description ( ) string { switch t { case Operation Cluster Bootstrap : return " " case Operation Cluster Join : return " " case Operation Backup Create : return " " case Operation Backup Rename : return " " case Operation Backup Restore : return " " case Operation Backup Remove : return " " case Operation Console Show : return " " case Operation Container Create : return " " case Operation Container Update : return " " case Operation Container Rename : return " " case Operation Container Migrate : return " " case Operation Container Live Migrate : return " " case Operation Container Freeze : return " " case Operation Container Unfreeze : return " " case Operation Container Delete : return " " case Operation Container Start : return " " case Operation Container Stop : return " " case Operation Container Restart : return " " case Operation Command Exec : return " " case Operation Snapshot Create : return " " case Operation Snapshot Rename : return " " case Operation Snapshot Restore : return " " case Operation Snapshot Transfer : return " " case Operation Snapshot Update : return " " case Operation Snapshot Delete : return " " case Operation Image Download : return " " case Operation Image Delete : return " " case Operation Image Token : return " " case Operation Image Refresh : return " " case Operation Volume Copy : return " " case Operation Volume Create : return " " case Operation Volume Migrate : return " " case Operation Volume Move : return " " case Operation Volume Snapshot Create : return " " case Operation Volume Snapshot Delete : return " " case Operation Volume Snapshot Update : return " " case Operation Project Rename : return " " case Operation Images Expire : return " " case Operation Images Prune Leftover : return " " case Operation Images Update : return " " case Operation Images Synchronize : return " " case Operation Logs Expire : return " " case Operation Instance Types Update : return " " case Operation Backups Expire : return " " case Operation Snapshots Expire : return " " default : return " " } } 
func ( t Operation Type ) Permission ( ) string { switch t { case Operation Backup Create : return " " case Operation Backup Rename : return " " case Operation Backup Restore : return " " case Operation Backup Remove : return " " case Operation Console Show : return " " case Operation Container Freeze : return " " case Operation Container Unfreeze : return " " case Operation Container Start : return " " case Operation Container Stop : return " " case Operation Container Restart : return " " case Operation Command Exec : return " " case Operation Snapshot Create : return " " case Operation Snapshot Rename : return " " case Operation Snapshot Transfer : return " " case Operation Snapshot Update : return " " case Operation Snapshot Delete : return " " case Operation Container Create : return " " case Operation Container Update : return " " case Operation Container Rename : return " " case Operation Container Migrate : return " " case Operation Container Live Migrate : return " " case Operation Container Delete : return " " case Operation Snapshot Restore : return " " case Operation Image Download : return " " case Operation Image Delete : return " " case Operation Image Token : return " " case Operation Image Refresh : return " " case Operation Images Update : return " " case Operation Images Synchronize : return " " } return " " } 
func ( c * Cluster Tx ) Operations UUIDs ( ) ( [ ] string , error ) { stmt : = " " return query . Select Strings ( c . tx , stmt , c . node ID ) } 
func ( c * Cluster Tx ) Operation Nodes ( project string ) ( [ ] string , error ) { stmt : = ` SELECT DISTINCT nodes .address FROM operations LEFT OUTER JOIN projects ON projects .id = operations .project _id JOIN nodes ON nodes .id = operations .node _id WHERE projects .name = ? OR operations .project _id IS NULL ` return query . Select Strings ( c . tx , stmt , project ) } 
func ( c * Cluster Tx ) Operation By UUID ( uuid string ) ( Operation , error ) { null : = Operation { } operations , err : = c . operations ( " " , uuid ) if err ! = nil { return null , err } switch len ( operations ) { case 0 : return null , Err No Such Object case 1 : return operations [ 0 ] , nil default : return null , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Operation Add ( project , uuid string , typ Operation Type ) ( int 6 4 , error ) { var project ID interface { } if project ! = " " { var err error project ID , err = c . Project ID ( project ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } else { project ID = nil } columns : = [ ] string { " " , " " , " " , " " } values : = [ ] interface { } { uuid , c . node ID , typ , project ID } return query . Upsert Object ( c . tx , " " , columns , values ) } 
func ( c * Cluster Tx ) Operation Remove ( uuid string ) error { result , err : = c . tx . Exec ( " " , uuid ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) operations ( where string , args . . . interface { } ) ( [ ] Operation , error ) { operations : = [ ] Operation { } dest : = func ( i int ) [ ] interface { } { operations = append ( operations , Operation { } ) return [ ] interface { } { & operations [ i ] . ID , & operations [ i ] . UUID , & operations [ i ] . Node Address , & operations [ i ] . Type , } } sql : = ` SELECT operations .id , uuid , nodes .address , type FROM operations JOIN nodes ON nodes .id = node _id ` if where ! = " " { sql + = fmt . Sprintf ( " " , where ) } sql + = " " stmt , err : = c . tx . Prepare ( sql ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , args . . . ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return operations , nil } 
func expire Logs Task ( state * state . State ) ( task . Func , task . Schedule ) { f : = func ( ctx context . Context ) { op Run : = func ( op * operation ) error { return expire Logs ( ctx , state ) } op , err : = operation Create ( state . Cluster , " " , operation Class Task , db . Operation Logs Expire , nil , nil , op Run , nil , nil ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err } ) return } logger . Infof ( " " ) _ , err = op . Run ( ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err } ) } logger . Infof ( " " ) } return f , task . Daily ( ) } 
func abs Path ( path string ) string { elems : = strings . Split ( filename , string ( filepath . Separator ) ) for i : = len ( elems ) - 1 ; i > = 0 ; i - - { if elems [ i ] = = " " { elems = append ( [ ] string { string ( filepath . Separator ) } , elems [ : i ] . . . ) elems = append ( elems , path ) return filepath . Join ( elems . . . ) } } log . Fatalf ( " " ) return " " } 
func ( s Schema ) Keys ( ) [ ] string { keys : = make ( [ ] string , len ( s ) ) i : = 0 for key : = range s { keys [ i ] = key i + + } sort . Strings ( keys ) return keys } 
func ( s Schema ) Defaults ( ) map [ string ] interface { } { values : = make ( map [ string ] interface { } , len ( s ) ) for name , key : = range s { values [ name ] = key . Default } return values } 
func ( s Schema ) must Get Key ( name string ) Key { key , ok : = s [ name ] if ! ok { panic ( fmt . Sprintf ( " " , name ) ) } return key } 
func ( s Schema ) assert Key Type ( name string , code Type ) { key : = s . must Get Key ( name ) if key . Type ! = code { panic ( fmt . Sprintf ( " " , name , key . Type , code ) ) } } 
func ( v * Key ) validate ( value string ) error { validator : = v . Validator if validator = = nil { } } switch v . Type { case String : case Bool : if ! shared . String In Slice ( strings . To Lower ( value ) , booleans ) { return fmt . Errorf ( " " ) } case Int 6 4 : _ , err : = strconv . Parse Int ( value , 1 0 , 6 4 ) if err ! = nil { return fmt . Errorf ( " " ) } default : panic ( fmt . Sprintf ( " " , v . Type ) ) } if v . Deprecated ! = " " & & value ! = v . Default { return fmt . Errorf ( " " , v . Deprecated ) } } 
func ( r * Protocol LXD ) Get Storage Pool Volumes ( pool string ) ( [ ] api . Storage Volume , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } volumes : = [ ] api . Storage Volume { } if err ! = nil { return nil , err } return volumes , nil } 
func ( r * Protocol LXD ) Get Storage Pool Volume ( pool string , vol Type string , name string ) ( * api . Storage Volume , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } volume : = api . Storage Volume { } etag , err : = r . query Struct ( " " , path , nil , " " , & volume ) if err ! = nil { return nil , " " , err } return & volume , etag , nil } 
func ( r * Protocol LXD ) Create Storage Pool Volume ( pool string , volume api . Storage Volumes Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query ( " " , path , volume , " " ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Create Storage Pool Volume Snapshot ( pool string , volume Type string , volume Name string , snapshot api . Storage Volume Snapshots Post ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } op , _ , err : = r . query Operation ( " " , path , snapshot , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Get Storage Pool Volume Snapshots ( pool string , volume Type string , volume Name string ) ( [ ] api . Storage Volume Snapshot , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } snapshots : = [ ] api . Storage Volume Snapshot { } path : = fmt . Sprintf ( " " , url . Query Escape ( pool ) , url . Query Escape ( volume Type ) , url . Query Escape ( volume Name ) ) _ , err : = r . query Struct ( " " , path , nil , " " , & snapshots ) if err ! = nil { return nil , err } return snapshots , nil } 
func ( r * Protocol LXD ) Get Storage Pool Volume Snapshot ( pool string , volume Type string , volume Name string , snapshot Name string ) ( * api . Storage Volume Snapshot , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } snapshot : = api . Storage Volume Snapshot { } path : = fmt . Sprintf ( " " , url . Query Escape ( pool ) , url . Query Escape ( volume Type ) , url . Query Escape ( volume Name ) , url . Query Escape ( snapshot Name ) ) etag , err : = r . query Struct ( " " , path , nil , " " , & snapshot ) if err ! = nil { return nil , " " , err } return & snapshot , etag , nil } 
func ( r * Protocol LXD ) Update Storage Pool Volume Snapshot ( pool string , volume Type string , volume Name string , snapshot Name string , volume api . Storage Volume Snapshot Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query Operation ( " " , path , volume , ETag ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Migrate Storage Pool Volume ( pool string , volume api . Storage Volume Post ) ( Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } } op , _ , err : = r . query Operation ( " " , path , volume , " " ) if err ! = nil { return nil , err } return op , nil } 
func ( r * Protocol LXD ) Copy Storage Pool Volume ( pool string , source Container Server , source Pool string , volume api . Storage Volume , args * Storage Pool Volume Copy Args ) ( Remote Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if args ! = nil & & args . Volume Only & & ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } req : = api . Storage Volumes Post { Name : args . Name , Type : volume . Type , Source : api . Storage Volume Source { Name : volume . Name , Type : " " , Pool : source Pool , Volume Only : args . Volume Only , } , } req . Config = volume . Config req . Description = volume . Description if r = = source { if err ! = nil { return nil , err } rop : = remote Operation { target Op : op , ch Done : make ( chan bool ) , } close ( rop . ch Done ) } ( ) return & rop , nil } if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } source Req : = api . Storage Volume Post { Migration : true , Name : volume . Name , Pool : source Pool , Volume Only : args . Volume Only , } if err ! = nil { return nil , err } req . Source . Mode = " " if err ! = nil { return nil , err } op API : = op . Get ( ) target Secrets : = map [ string ] string { } for k , v : = range op API . Metadata { target Secrets [ k ] = v . ( string ) } target . Operation = op API . ID target . Websockets = target Secrets target . Certificate = info . Certificate source Req . Target = & target return r . try Migrate Storage Pool Volume ( source , source Pool , source Req , info . Addresses ) } if err ! = nil { return nil , err } if err ! = nil { return nil , err } op API : = op . Get ( ) for k , v : = range op API . Metadata { source Secrets [ k ] = v . ( string ) } req . Source . Mode = " " if err ! = nil { return nil , err } target Op API : = target Op . Get ( ) for k , v : = range target Op API . Metadata { target Secrets [ k ] = v . ( string ) } if err ! = nil { return nil , err } close ( rop . ch Done ) } ( ) return & rop , nil } req . Source . Mode = " " req . Source . Operation = op API . ID req . Source . Websockets = source Secrets req . Source . Certificate = info . Certificate return r . try Create Storage Pool Volume ( pool , req , info . Addresses ) } 
func ( r * Protocol LXD ) Move Storage Pool Volume ( pool string , source Container Server , source Pool string , volume api . Storage Volume , args * Storage Pool Volume Move Args ) ( Remote Operation , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } if r ! = source { return nil , fmt . Errorf ( " " ) } req : = api . Storage Volume Post { Name : args . Name , Pool : pool , } if err ! = nil { return nil , err } rop : = remote Operation { target Op : op , ch Done : make ( chan bool ) , } close ( rop . ch Done ) } ( ) return & rop , nil } 
func ( r * Protocol LXD ) Update Storage Pool Volume ( pool string , vol Type string , name string , volume api . Storage Volume Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if volume . Restore ! = " " & & ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query ( " " , path , volume , ETag ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Storage Pool Volume ( pool string , vol Type string , name string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } _ , _ , err : = r . query ( " " , path , nil , " " ) if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Rename Storage Pool Volume ( pool string , vol Type string , name string , volume api . Storage Volume Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } path : = fmt . Sprintf ( " " , url . Query Escape ( pool ) , url . Query Escape ( vol Type ) , url . Query Escape ( name ) ) if err ! = nil { return err } return nil } 
func storage Pool Used By Get ( state * state . State , pool ID int 6 4 , pool Name string ) ( [ ] string , error ) { if err ! = nil & & err ! = db . Err No Such Object { return [ ] string { } , err } if err ! = nil { return [ ] string { } , err } slicelen : = len ( volumes ) + len ( profiles ) if slicelen = = 0 { return [ ] string { } , nil } for i : = 0 ; i < len ( volumes ) ; i + + { api Endpoint , _ : = storage Pool Volume Type Name To APIEndpoint ( volumes [ i ] . Type ) switch api Endpoint { case storage Pool Volume APIEndpoint Containers : if strings . Index ( volumes [ i ] . Name , shared . Snapshot Delimiter ) > 0 { parent Name , snap Only Name , _ : = container Get Parent And Snapshot Name ( volumes [ i ] . Name ) pool Used By [ i ] = fmt . Sprintf ( " " , version . APIVersion , parent Name , snap Only Name ) } else { pool Used By [ i ] = fmt . Sprintf ( " " , version . APIVersion , volumes [ i ] . Name ) } case storage Pool Volume APIEndpoint Images : pool Used By [ i ] = fmt . Sprintf ( " " , version . APIVersion , volumes [ i ] . Name ) case storage Pool Volume APIEndpoint Custom : pool Used By [ i ] = fmt . Sprintf ( " " , version . APIVersion , pool Name , volumes [ i ] . Type , volumes [ i ] . Name ) default : } } for i : = 0 ; i < len ( profiles ) ; i + + { pool Used By [ i + len ( volumes ) ] = fmt . Sprintf ( " " , version . APIVersion , profiles [ i ] ) } return pool Used By , err } 
func do Storage Pool Create Internal ( state * state . State , pool Name , pool Description string , driver string , config map [ string ] string , is Notification bool ) error { try Undo : = true s , err : = storage Pool Init ( state , pool Name ) if err ! = nil { return err } return os . Mkdir All ( volume Mnt Point , 0 7 1 1 ) } err = s . Storage Pool Create ( ) if err ! = nil { return err } defer func ( ) { if ! try Undo { return } s . Storage Pool Delete ( ) } ( ) config Diff , _ : = storage Config Diff ( config , post Create Config ) if len ( config Diff ) > 0 { if err ! = nil { return fmt . Errorf ( " " , pool Name , err ) } } return nil } 
func db Storage Pool Create And Update Cache ( db * db . Cluster , pool Name string , pool Description string , pool Driver string , pool Config map [ string ] string ) ( int 6 4 , error ) { id , err : = db . Storage Pool Create ( pool Name , pool Description , pool Driver , pool Config ) if err ! = nil { return id , err } return id , nil } 
func db Storage Pool Delete And Update Cache ( db * db . Cluster , pool Name string ) error { _ , err : = db . Storage Pool Delete ( pool Name ) if err ! = nil { return err } return err } 
func operation Get ( d * Daemon , r * http . Request ) Response { id : = mux . Vars ( r ) [ " " ] var body * api . Operation if err = = nil { _ , body , err = op . Render ( ) if err ! = nil { return Smart Error ( err ) } return Sync Response ( true , body ) } err = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { operation , err : = tx . Operation By UUID ( id ) if err ! = nil { return err } address = operation . Node Address return nil } ) if err ! = nil { return Smart Error ( err ) } cert : = d . endpoints . Network Cert ( ) client , err : = cluster . Connect ( address , cert , false ) if err ! = nil { return Smart Error ( err ) } body , _ , err = client . Get Operation ( id ) if err ! = nil { return Smart Error ( err ) } return Sync Response ( true , body ) } 
func container Get Parent And Snapshot Name ( name string ) ( string , string , bool ) { fields : = strings . Split N ( name , shared . Snapshot Delimiter , 2 ) if len ( fields ) = = 1 { return name , " " , false } return fields [ 0 ] , fields [ 1 ] , true } 
func container Create As Empty ( d * Daemon , args db . Container Args ) ( container , error ) { if err ! = nil { return nil , err } if err ! = nil { c . Delete ( ) return nil , err } if err ! = nil { c . Delete ( ) return nil , err } return c , nil } 
func container Load From All Projects ( s * state . State ) ( [ ] container , error ) { var projects [ ] string err : = s . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error projects , err = tx . Project Names ( ) return err } ) if err ! = nil { return nil , err } containers : = [ ] container { } for _ , project : = range projects { project Containers , err : = container Load By Project ( s , project ) if err ! = nil { return nil , errors . Wrapf ( nil , " " , project ) } containers = append ( containers , project Containers . . . ) } return containers , nil } 
func container Load Node All ( s * state . State ) ( [ ] container , error ) { err : = s . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error cts , err = tx . Container Node List ( ) if err ! = nil { return err } return nil } ) if err ! = nil { return nil , err } return container Load All Internal ( cts , s ) } 
func container Load Node Project All ( s * state . State , project string ) ( [ ] container , error ) { err : = s . Cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error cts , err = tx . Container Node Project List ( project ) if err ! = nil { return err } return nil } ) if err ! = nil { return nil , err } return container Load All Internal ( cts , s ) } 
func Heartbeat ( gateway * Gateway , cluster * db . Cluster ) ( task . Func , task . Schedule ) { heartbeat : = func ( ctx context . Context ) { if gateway . server = = nil | | gateway . memory Dial ! = nil { } raft Nodes , err : = gateway . current Raft Nodes ( ) if err = = raft . Err Not Leader { return } logger . Debugf ( " " ) if err ! = nil { logger . Warnf ( " " , err ) return } err = gateway . db . Transaction ( func ( tx * db . Node Tx ) error { return tx . Raft Nodes Replace ( raft Nodes ) } ) if err ! = nil { logger . Warnf ( " " , err ) return } var nodes [ ] db . Node Info var node Address string err = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error nodes , err = tx . Nodes ( ) if err ! = nil { return err } node Address , err = tx . Node Address ( ) if err ! = nil { return err } return nil } ) if err ! = nil { logger . Warnf ( " " , err ) return } heartbeats : = make ( [ ] time . Time , len ( nodes ) ) heartbeats Lock : = sync . Mutex { } heartbeats Wg : = sync . Wait Group { } for i , node : = range nodes { heartbeats [ i ] = time . Now ( ) heartbeats Lock . Unlock ( ) continue } go func ( i int , address string ) { defer heartbeats Wg . Done ( ) logger . Debugf ( " " , address ) err : = heartbeat Node ( ctx , address , gateway . cert , raft Nodes ) if err = = nil { heartbeats Lock . Lock ( ) heartbeats [ i ] = time . Now ( ) heartbeats Lock . Unlock ( ) logger . Debugf ( " " , address ) } else { logger . Debugf ( " " , address , err ) } } ( i , node . Address ) } heartbeats Wg . Wait ( ) return } err = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { for i , node : = range nodes { if heartbeats [ i ] . Equal ( time . Time { } ) { continue } err : = tx . Node Heartbeat ( node . Address , heartbeats [ i ] ) if err ! = nil { return err } } return nil } ) if err ! = nil { logger . Warnf ( " " , err ) } logger . Debugf ( " " ) } go func ( ) { heartbeat ( ctx ) ch < - struct { } { } } ( ) select { case < - ch : case < - ctx . Done ( ) : } } schedule : = task . Every ( time . Duration ( heartbeat Interval ) * time . Second ) return heartbeat Wrapper , schedule } 
func heartbeat Node ( task Ctx context . Context , address string , cert * shared . Cert Info , raft Nodes [ ] db . Raft Node ) error { logger . Debugf ( " " , address ) config , err : = tls Client Config ( cert ) if err ! = nil { return err } url : = fmt . Sprintf ( " " , address , database Endpoint ) client : = & http . Client { Transport : & http . Transport { TLSClient Config : config } } buffer : = bytes . Buffer { } err = json . New Encoder ( & buffer ) . Encode ( raft Nodes ) if err ! = nil { return err } request , err : = http . New Request ( " " , url , bytes . New Reader ( buffer . Bytes ( ) ) ) if err ! = nil { return err } ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Second ) defer cancel ( ) request = request . With Context ( ctx ) request . Close = true go func ( ) { response , err : = client . Do ( request ) if err ! = nil { err Ch < - errors . Wrap ( err , " " ) return } defer response . Body . Close ( ) if response . Status Code ! = http . Status OK { err Ch < - fmt . Errorf ( " " , response . Status ) return } err Ch < - nil } ( ) select { case err : = < - err Ch : return err case < - task Ctx . Done ( ) : return task Ctx . Err ( ) } } 
func ( c * cmd List ) dot Prefix Match ( short string , full string ) bool { full Membs : = strings . Split ( full , " " ) short Membs : = strings . Split ( short , " " ) if len ( full Membs ) ! = len ( short Membs ) { return false } for i : = range full Membs { if ! strings . Has Prefix ( full Membs [ i ] , short Membs [ i ] ) { return false } } return true } 
func ( s * storage Zfs ) Storage Core Init ( ) error { s . s Type = storage Type Zfs type Name , err : = storage Type To String ( s . s Type ) if err ! = nil { return err } s . s Type Name = type Name if zfs Version ! = " " { s . s Type Version = zfs Version return nil } util . Load Module ( " " ) if ! zfs Is Enabled ( ) { return fmt . Errorf ( " \ " \ " " ) } s . s Type Version , err = zfs Tool Version Get ( ) if err ! = nil { s . s Type Version , err = zfs Module Version Get ( ) if err ! = nil { return err } } zfs Version = s . s Type Version return nil } 
func ( s * storage Zfs ) Storage Pool Init ( ) error { err : = s . Storage Core Init ( ) if err ! = nil { return err } } return nil } 
func ( s * storage Zfs ) Container Mount ( c container ) ( bool , error ) { return s . do Container Mount ( c . Project ( ) , c . Name ( ) , c . Is Privileged ( ) ) } 
func ( s * storage Zfs ) Container Storage Ready ( container container ) bool { volume Name : = project Prefix ( container . Project ( ) , container . Name ( ) ) fs : = fmt . Sprintf ( " " , volume Name ) return zfs Filesystem Entity Exists ( s . get On Disk Pool Name ( ) , fs ) } 
func ( s * storage Zfs ) Image Create ( fingerprint string , tracker * ioprogress . Progress Tracker ) error { logger . Debugf ( " \ " \ " \ " \ " " , fingerprint , s . pool . Name ) pool Name : = s . get On Disk Pool Name ( ) image Mnt Point : = get Image Mount Point ( s . pool . Name , fingerprint ) fs : = fmt . Sprintf ( " " , fingerprint ) revert : = true subrevert : = true err : = s . create Image Db Pool Volume ( fingerprint ) if err ! = nil { return err } defer func ( ) { if ! subrevert { return } s . delete Image Db Pool Volume ( fingerprint ) } ( ) if zfs Filesystem Entity Exists ( pool Name , fmt . Sprintf ( " " , fs ) ) { if err : = zfs Pool Volume Rename ( pool Name , fmt . Sprintf ( " " , fs ) , fs , true ) ; err ! = nil { return err } defer func ( ) { if ! revert { return } s . Image Delete ( fingerprint ) } ( ) if err ! = nil { return err } revert = false subrevert = false return nil } if ! shared . Path Exists ( image Mnt Point ) { err : = os . Mkdir All ( image Mnt Point , 0 7 0 0 ) if err ! = nil { return err } defer func ( ) { if ! subrevert { return } os . Remove All ( image Mnt Point ) } ( ) } tmp Image Dir , err : = ioutil . Temp Dir ( tmp , " " ) if err ! = nil { return err } defer os . Remove All ( tmp Image Dir ) image Path : = shared . Var Path ( " " , fingerprint ) msg , err : = zfs Pool Volume Create ( dataset , " " ) if err ! = nil { logger . Errorf ( " \ " \ " \ " \ " " , dataset , s . pool . Name , msg ) return err } subrevert = false defer func ( ) { if ! revert { return } s . Image Delete ( fingerprint ) } ( ) if err ! = nil { return err } } if err ! = nil { return err } } } } if err ! = nil { return err } revert = false logger . Debugf ( " \ " \ " \ " \ " " , fingerprint , s . pool . Name ) return nil } 
func Ask Bool ( question string , default Answer string ) bool { for { answer : = ask Question ( question , default Answer ) if shared . String In Slice ( strings . To Lower ( answer ) , [ ] string { " " , " " } ) { return true } else if shared . String In Slice ( strings . To Lower ( answer ) , [ ] string { " " , " " } ) { return false } invalid Input ( ) } } 
func Ask Choice ( question string , choices [ ] string , default Answer string ) string { for { answer : = ask Question ( question , default Answer ) if shared . String In Slice ( answer , choices ) { return answer } invalid Input ( ) } } 
func Ask Int ( question string , min int 6 4 , max int 6 4 , default Answer string ) int 6 4 { for { answer : = ask Question ( question , default Answer ) result , err : = strconv . Parse Int ( answer , 1 0 , 6 4 ) if err = = nil & & ( min = = - 1 | | result > = min ) & & ( max = = - 1 | | result < = max ) { return result } invalid Input ( ) } } 
func Ask String ( question string , default Answer string , validate func ( string ) error ) string { for { answer : = ask Question ( question , default Answer ) if validate ! = nil { error : = validate ( answer ) if error ! = nil { fmt . Fprintf ( os . Stderr , " \n \n " , error ) continue } return answer } if len ( answer ) ! = 0 { return answer } invalid Input ( ) } } 
func Ask Password ( question string ) string { for { fmt . Printf ( question ) pwd , _ : = terminal . Read Password ( 0 ) fmt . Println ( " " ) in First : = string ( pwd ) in First = strings . Trim Suffix ( in First , " \n " ) fmt . Printf ( " " ) pwd , _ = terminal . Read Password ( 0 ) fmt . Println ( " " ) in Second : = string ( pwd ) in Second = strings . Trim Suffix ( in Second , " \n " ) if in First = = in Second { return in First } invalid Input ( ) } } 
func Ask Password Once ( question string ) string { fmt . Printf ( question ) pwd , _ : = terminal . Read Password ( 0 ) fmt . Println ( " " ) return string ( pwd ) } 
func ask Question ( question , default Answer string ) string { fmt . Printf ( question ) return read Answer ( default Answer ) } 
func read Answer ( default Answer string ) string { answer , _ : = stdin . Read String ( ' \n ' ) answer = strings . Trim Suffix ( answer , " \n " ) answer = strings . Trim Space ( answer ) if answer = = " " { answer = default Answer } return answer } 
func profiles Get ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) recursion : = util . Is Recursion Request ( r ) var result interface { } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { has Profiles , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! has Profiles { project = " " } filter : = db . Profile Filter { Project : project , } if recursion { profiles , err : = tx . Profile List ( filter ) if err ! = nil { return err } api Profiles : = make ( [ ] * api . Profile , len ( profiles ) ) for i , profile : = range profiles { api Profiles [ i ] = db . Profile To API ( & profile ) } result = api Profiles } else { result , err = tx . Profile URIs ( filter ) } return err } ) if err ! = nil { return Smart Error ( err ) } return Sync Response ( true , result ) } 
func profile Post ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) name : = mux . Vars ( r ) [ " " ] if name = = " " { return Forbidden ( errors . New ( " " ) ) } req : = api . Profile Post { } if err : = json . New Decoder ( r . Body ) . Decode ( & req ) ; err ! = nil { return Bad Request ( err ) } } if strings . Contains ( req . Name , " " ) { return Bad Request ( fmt . Errorf ( " " ) ) } if shared . String In Slice ( req . Name , [ ] string { " " , " " } ) { return Bad Request ( fmt . Errorf ( " " , req . Name ) ) } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { has Profiles , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! has Profiles { project = " " } if err = = nil { return fmt . Errorf ( " " , req . Name ) } return tx . Profile Rename ( project , name , req . Name ) } ) if err ! = nil { return Smart Error ( err ) } return Sync Response Location ( true , nil , fmt . Sprintf ( " " , version . APIVersion , req . Name ) ) } 
func profile Delete ( d * Daemon , r * http . Request ) Response { project : = project Param ( r ) name : = mux . Vars ( r ) [ " " ] if name = = " " { return Forbidden ( errors . New ( " " ) ) } err : = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { has Profiles , err : = tx . Project Has Profiles ( project ) if err ! = nil { return errors . Wrap ( err , " " ) } if ! has Profiles { project = " " } profile , err : = tx . Profile Get ( project , name ) if err ! = nil { return err } if len ( profile . Used By ) > 0 { return fmt . Errorf ( " " ) } return tx . Profile Delete ( project , name ) } ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func Is Root Disk Device ( device map [ string ] string ) bool { if device [ " " ] = = " " & & device [ " " ] = = " " & & device [ " " ] = = " " { return true } return false } 
func Get Root Disk Device ( devices map [ string ] map [ string ] string ) ( string , map [ string ] string , error ) { var dev Name string var dev map [ string ] string for n , d : = range devices { if Is Root Disk Device ( d ) { if dev Name ! = " " { return " " , nil , fmt . Errorf ( " " ) } dev Name = n dev = d } } if dev Name ! = " " { return dev Name , dev , nil } return " " , nil , fmt . Errorf ( " " ) } 
func Config Key Checker ( key string ) ( func ( value string ) error , error ) { if f , ok : = Known Container Config Keys [ key ] ; ok { return f , nil } if strings . Has Prefix ( key , " " ) { if strings . Has Suffix ( key , " " ) { return Is Any , nil } if strings . Has Suffix ( key , " " ) { return Is Any , nil } if strings . Has Suffix ( key , " " ) { return Is Any , nil } } if strings . Has Prefix ( key , " " ) { return Is Any , nil } if strings . Has Prefix ( key , " " ) { return Is Any , nil } if strings . Has Prefix ( key , " " ) { return Is Any , nil } if strings . Has Prefix ( key , " " ) & & ( len ( key ) > len ( " " ) ) { return Is Any , nil } return nil , fmt . Errorf ( " " , key ) } 
func Forwarded Response ( client lxd . Container Server , request * http . Request ) Response { return & forwarded Response { client : client , request : request , } } 
func Forwarded Response If Target Is Remote ( d * Daemon , request * http . Request ) Response { target Node : = query Param ( request , " " ) if target Node = = " " { return nil } if err ! = nil { return Smart Error ( err ) } if address ! = " " { client , err : = cluster . Connect ( address , cert , false ) if err ! = nil { return Smart Error ( err ) } return Forwarded Response ( client , request ) } return nil } 
func Forwarded Response If Container Is Remote ( d * Daemon , r * http . Request , project , name string ) ( Response , error ) { cert : = d . endpoints . Network Cert ( ) client , err : = cluster . Connect If Container Is Remote ( d . cluster , project , name , cert ) if err ! = nil { return nil , err } if client = = nil { return nil , nil } return Forwarded Response ( client , r ) , nil } 
func Forwarded Response If Volume Is Remote ( d * Daemon , r * http . Request , pool ID int 6 4 , volume Name string , volume Type int ) Response { if query Param ( r , " " ) ! = " " { return nil } cert : = d . endpoints . Network Cert ( ) client , err : = cluster . Connect If Volume Is Remote ( d . cluster , pool ID , volume Name , volume Type , cert ) if err ! = nil & & err ! = db . Err No Such Object { return Smart Error ( err ) } if client = = nil { return nil } return Forwarded Response ( client , r ) } 
func Forwarded Operation Response ( project string , op * api . Operation ) Response { return & forwarded Operation Response { op : op , project : project , } } 
func Smart Error ( err error ) Response { switch errors . Cause ( err ) { case nil : return Empty Sync Response case os . Err Not Exist , sql . Err No Rows , db . Err No Such Object : return Not Found ( nil ) case os . Err Permission : return Forbidden ( nil ) case db . Err Already Defined , sqlite 3 . Err Constraint Unique : return Conflict ( nil ) case dqlite . Err No Available Leader : return Unavailable ( err ) default : return Internal Error ( err ) } } 
func Key Value ( s string ) ( string , string , error ) { parts : = strings . Split ( s , " " ) if len ( parts ) ! = 2 { return " " , " " , fmt . Errorf ( " " , s ) } return parts [ 0 ] , parts [ 1 ] , nil } 
func ( p * Progress Renderer ) Done ( msg string ) { defer p . lock . Unlock ( ) } } } } if len ( msg ) > p . max Length { p . max Length = len ( msg ) } else { fmt . Printf ( " \r " , strings . Repeat ( " " , p . max Length ) ) } fmt . Print ( " \r " ) fmt . Print ( msg ) } 
func ( p * Progress Renderer ) Update ( status string ) { if timeout . Seconds ( ) > 0 { time . Sleep ( timeout ) } defer p . lock . Unlock ( ) } } } p . terminal = 1 } if p . terminal ! = 1 { return } if p . Format ! = " " { msg = p . Format } msg = fmt . Sprintf ( msg , status ) } if len ( msg ) > p . max Length { p . max Length = len ( msg ) } else { fmt . Printf ( " \r " , strings . Repeat ( " " , p . max Length ) ) } fmt . Print ( msg ) } 
func ( p * Progress Renderer ) Warn ( status string , timeout time . Duration ) { defer p . lock . Unlock ( ) } msg : = fmt . Sprintf ( " " , status ) } if len ( msg ) > p . max Length { p . max Length = len ( msg ) } else { fmt . Printf ( " \r " , strings . Repeat ( " " , p . max Length ) ) } fmt . Print ( msg ) } 
func ( p * Progress Renderer ) Update Progress ( progress ioprogress . Progress Data ) { p . Update ( progress . Text ) } 
func ( p * Progress Renderer ) Update Op ( op api . Operation ) { if op . Metadata = = nil { return } for key , value : = range op . Metadata { if ! strings . Has Suffix ( key , " " ) { continue } p . Update ( value . ( string ) ) break } } 
func ( d * Daemon ) Image Download ( op * operation , server string , protocol string , certificate string , secret string , alias string , for Container bool , auto Update bool , storage Pool string , prefer Cached bool , project string ) ( * api . Image , error ) { var err error var ctx Map log . Ctx var remote lxd . Image Server var info * api . Image } image Stream Cache , err : = image Get Stream Cache ( d ) if err ! = nil { image Stream Cache Lock . Unlock ( ) return nil , err } entry , _ : = image Stream Cache [ server ] if entry = = nil | | entry . Expiry . Before ( time . Now ( ) ) { if err ! = nil { return nil , err } if err ! = nil { return nil , err } if err ! = nil { return nil , err } fingerprints : = [ ] string { } for _ , image : = range images { fingerprints = append ( fingerprints , image . Fingerprint ) } image Stream Cache [ server ] = entry image Save Stream Cache ( d . os , image Stream Cache ) return entry , nil } new Entry , err : = refresh ( ) if err = = nil { } else if entry ! = nil { entry . Expiry = time . Now ( ) . Add ( time . Hour ) } else { return nil , err } } else { remote , err = lxd . Connect Simple Streams ( server , & lxd . Connection Args { TLSServer Cert : entry . Certificate , User Agent : version . User Agent , Proxy : d . proxy , } ) if err ! = nil { image Stream Cache Lock . Unlock ( ) return nil , err } } image Stream Cache Lock . Unlock ( ) } fp = entry . Target break } for _ , entry : = range entry . Fingerprints { if strings . Has Prefix ( entry , fp ) { matches = append ( matches , entry ) } } if len ( matches ) = = 1 { fp = matches [ 0 ] } else if len ( matches ) > 1 { return nil , fmt . Errorf ( " " ) } else { return nil , fmt . Errorf ( " " ) } } else if protocol = = " " { if err ! = nil { return nil , err } if err = = nil { fp = entry . Target } if err ! = nil { return nil , err } fp = info . Fingerprint } } if err ! = nil { return nil , err } if prefer Cached & & interval > 0 & & alias ! = fp { cached Fingerprint , err : = d . cluster . Image Source Get Cached Fingerprint ( server , protocol , alias ) if err = = nil & & cached Fingerprint ! = fp { fp = cached Fingerprint } } if err = = db . Err No Such Object { if err = = nil { if err ! = nil { return nil , err } var id int id , img Info , err = d . cluster . Image Get ( project , fp , false , true ) if err ! = nil { return nil , err } err = d . cluster . Image Source Insert ( id , server , protocol , certificate , alias ) if err ! = nil { return nil , err } } } if err = = nil { logger . Debug ( " " , log . Ctx { " " : fp } ) info = img Info } if err ! = nil { return nil , err } if err ! = nil { return nil , err } if shared . Int 6 4In Slice ( pool ID , pool IDs ) { logger . Debugf ( " \ " \ " " , storage Pool ) return info , nil } err = image Create In Pool ( d , info , storage Pool ) if err ! = nil { logger . Debugf ( " \ " \ " " , storage Pool , err ) return nil , err } logger . Debugf ( " \ " \ " " , storage Pool ) return info , nil } if wait Channel , ok : = images Downloading [ fp ] ; ok { logger . Debug ( " " , log . Ctx { " " : fp } ) if err ! = nil { } else { } } else { images Downloading Lock . Unlock ( ) } images Downloading [ fp ] = make ( chan bool ) images Downloading Lock . Unlock ( ) if wait Channel , ok : = images Downloading [ fp ] ; ok { close ( wait Channel ) delete ( images Downloading , fp ) } images Downloading Lock . Unlock ( ) } ( ) } else { ctx Map = log . Ctx { " " : op . url , " " : fp , " " : op . id , " " : alias , " " : server } } logger . Info ( " " , ctx Map ) dest Name : = filepath . Join ( dest Dir , fp ) failure : = true cleanup : = func ( ) { if failure { os . Remove ( dest Name ) os . Remove ( dest Name + " " ) } } defer cleanup ( ) } meta : = op . metadata if meta = = nil { meta = make ( map [ string ] interface { } ) } if meta [ " " ] ! = progress . Text { meta [ " " ] = progress . Text op . Update Metadata ( meta ) } } var canceler * cancel . Canceler if op ! = nil { canceler = cancel . New Canceler ( ) op . canceler = canceler } if protocol = = " " | | protocol = = " " { if err ! = nil { return nil , err } defer dest . Close ( ) dest Rootfs , err : = os . Create ( dest Name + " " ) if err ! = nil { return nil , err } defer dest Rootfs . Close ( ) if err ! = nil { return nil , err } alias = info . Fingerprint } else { info , _ , err = remote . Get Image ( fp ) if err ! = nil { return nil , err } } } request : = lxd . Image File Request { Meta File : io . Write Seeker ( dest ) , Rootfs File : io . Write Seeker ( dest Rootfs ) , Progress Handler : progress , Canceler : canceler , Delta Source Retriever : func ( fingerprint string , file string ) string { path : = shared . Var Path ( " " , fmt . Sprintf ( " " , fingerprint , file ) ) if shared . Path Exists ( path ) { return path } return " " } , } if secret ! = " " { resp , err = remote . Get Private Image File ( fp , secret , request ) } else { resp , err = remote . Get Image File ( fp , request ) } if err ! = nil { return nil , err } if err ! = nil { return nil , err } } } else if protocol = = " " { if err ! = nil { return nil , err } req , err : = http . New Request ( " " , server , nil ) if err ! = nil { return nil , err } req . Header . Set ( " " , version . User Agent ) defer close ( done Ch ) if err ! = nil { return nil , err } if raw . Status Code ! = http . Status OK { return nil , fmt . Errorf ( " " , server , raw . Status ) } } , } , } if err ! = nil { return nil , err } defer f . Close ( ) if err ! = nil { return nil , err } if result ! = fp { return nil , fmt . Errorf ( " " , server , result , fp ) } if err ! = nil { return nil , err } info = & api . Image { } info . Fingerprint = fp info . Size = size info . Architecture = image Meta . Architecture info . Created At = time . Unix ( image Meta . Creation Date , 0 ) info . Expires At = time . Unix ( image Meta . Expiry Date , 0 ) info . Properties = image Meta . Properties } } if err ! = nil { return nil , err } if new Dest Name ! = dest Name { err = shared . File Move ( dest Name , new Dest Name ) if err ! = nil { return nil , err } if shared . Path Exists ( dest Name + " " ) { err = shared . File Move ( dest Name + " " , new Dest Name + " " ) if err ! = nil { return nil , err } } } if err ! = nil { return nil , err } err = d . cluster . Image Source Insert ( id , server , protocol , certificate , alias ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } } if err ! = nil { return nil , err } } logger . Info ( " " , ctx Map ) return info , nil } 
func update From V 6 ( tx * sql . Tx ) error { if err ! = nil { return errors . Wrap ( err , " " ) } SELECT id FROM storage _pools WHERE driver = 'zfs ' ` ) if err ! = nil { return errors . Wrap ( err , " " ) } for _ , pool ID : = range pool IDs { if err ! = nil { return errors . Wrap ( err , " " ) } pool Name , ok : = config [ " " ] if ! ok { continue } DELETE FROM storage _pools _config WHERE key = 'zfs .pool _name ' AND storage _pool _id = ? AND node _id IS NULL ` , pool ID ) if err ! = nil { return errors . Wrap ( err , " " ) } INSERT INTO storage _pools _config (storage _pool _id , node _id , key , value ) VALUES ( ? , ? , 'zfs .pool _name ' , ? ) ` , pool ID , node ID , pool Name ) if err ! = nil { return errors . Wrap ( err , " " ) } } } return nil } 
func update From V 5 ( tx * sql . Tx ) error { if err ! = nil { return errors . Wrap ( err , " " ) } SELECT storage _volumes .id FROM storage _volumes JOIN storage _pools ON storage _volumes .storage _pool _id =storage _pools .id WHERE storage _pools .driver = 'ceph ' ` ) if err ! = nil { return errors . Wrap ( err , " " ) } Name string Storage Pool ID int Node ID int Type int Description string } , len ( volume IDs ) ) sql : = ` SELECT storage _volumes .id , storage _volumes .name , storage _volumes .storage _pool _id , storage _volumes .node _id , storage _volumes .type , storage _volumes .description FROM storage _volumes JOIN storage _pools ON storage _volumes .storage _pool _id =storage _pools .id WHERE storage _pools .driver = 'ceph ' ` stmt , err : = tx . Prepare ( sql ) if err ! = nil { return err } defer stmt . Close ( ) err = query . Select Objects ( stmt , func ( i int ) [ ] interface { } { return [ ] interface { } { & volumes [ i ] . ID , & volumes [ i ] . Name , & volumes [ i ] . Storage Pool ID , & volumes [ i ] . Node ID , & volumes [ i ] . Type , & volumes [ i ] . Description , } } ) if err ! = nil { return errors . Wrap ( err , " " ) } columns : = [ ] string { " " , " " , " " , " " , " " } for _ , volume : = range volumes { for _ , node ID : = range node IDs { if volume . Node ID = = node ID { } values : = [ ] interface { } { volume . Name , volume . Storage Pool ID , node ID , volume . Type , volume . Description , } id , err : = query . Upsert Object ( tx , " " , columns , values ) if err ! = nil { return errors . Wrap ( err , " " ) } _ , ok : = created [ volume . ID ] if ! ok { created [ volume . ID ] = make ( [ ] int 6 4 , 0 ) } created [ volume . ID ] = append ( created [ volume . ID ] , id ) } } if err ! = nil { errors . Wrap ( err , " " ) } for _ , new ID : = range new IDs { for key , value : = range config { _ , err : = tx . Exec ( ` INSERT INTO storage _volumes _config (storage _volume _id , key , value ) VALUES ( ? , ? , ? ) ` , new ID , key , value ) if err ! = nil { return errors . Wrap ( err , " " ) } } } } return nil } 
func local Create Listener ( path string , group string ) ( net . Listener , error ) { err : = Check Already Running ( path ) if err ! = nil { return nil , err } err = socket Unix Remove Stale ( path ) if err ! = nil { return nil , err } listener , err : = socket Unix Listen ( path ) if err ! = nil { return nil , err } err = local Set Access ( path , group ) if err ! = nil { listener . Close ( ) return nil , err } return listener , nil } 
func local Set Access ( path string , group string ) error { err : = socket Unix Set Permissions ( path , 0 6 6 0 ) if err ! = nil { return err } err = socket Unix Set Ownership ( path , group ) if err ! = nil { return err } return nil } 
func New Stmt ( database , pkg , entity , kind string , config map [ string ] string ) ( * Stmt , error ) { packages , err : = Packages ( ) if err ! = nil { return nil , err } stmt : = & Stmt { db : database , pkg : pkg , entity : entity , kind : kind , config : config , packages : packages , } return stmt , nil } 
func ( s * Stmt ) Generate ( buf * file . Buffer ) error { if strings . Has Prefix ( s . kind , " " ) { return s . objects ( buf ) } if strings . Has Prefix ( s . kind , " " ) & & strings . Has Suffix ( s . kind , " " ) { return s . create Ref ( buf ) } if strings . Has Suffix ( s . kind , " " ) | | strings . Contains ( s . kind , " " ) { return s . ref ( buf ) } if strings . Has Prefix ( s . kind , " " ) { return s . names ( buf ) } switch s . kind { case " " : return s . create ( buf ) case " " : return s . id ( buf ) case " " : return s . rename ( buf ) case " " : return s . update ( buf ) case " " : return s . delete ( buf ) default : return fmt . Errorf ( " " , s . kind ) } } 
func ( s * Stmt ) register ( buf * file . Buffer , sql string , filters . . . string ) { kind : = strings . Replace ( s . kind , " " , " " , - 1 ) if kind = = " " { kind = " " } buf . L ( " \n \n " , stmt Code Var ( s . entity , kind , filters . . . ) , s . db , sql ) } 
func Connect LXD ( url string , args * Connection Args ) ( Container Server , error ) { logger . Debugf ( " " ) return https LXD ( url , args ) } 
func Connect LXDUnix ( path string , args * Connection Args ) ( Container Server , error ) { logger . Debugf ( " " ) } if path = = " " { lxd Dir : = os . Getenv ( " " ) if lxd Dir = = " " { lxd Dir = " " } path = filepath . Join ( lxd Dir , " " ) } } if err ! = nil { return nil , err } server . http = http Client if err ! = nil { return nil , err } } return & server , nil } 
func Connect Public LXD ( url string , args * Connection Args ) ( Image Server , error ) { logger . Debugf ( " " ) return https LXD ( url , args ) } 
func Connect Simple Streams ( url string , args * Connection Args ) ( Image Server , error ) { logger . Debugf ( " " ) } if err ! = nil { return nil , err } server . http = http Client server . ss Client = ss Client return & server , nil } 
func https LXD ( url string , args * Connection Args ) ( Container Server , error ) { } if args . Auth Type = = " " { server . Require Authenticated ( true ) } if err ! = nil { return nil , err } if args . Cookie Jar ! = nil { http Client . Jar = args . Cookie Jar } server . http = http Client if args . Auth Type = = " " { server . setup Bakery Client ( ) } if err ! = nil { return nil , err } } return & server , nil } 
func move Cluster Container ( conf * config . Config , source Resource , dest Resource , target string ) error { if err ! = nil { return err } if err ! = nil { return err } } } if err ! = nil { return errors . Wrap ( err , i 1 8n . G ( " " ) ) } } req : = api . Container Post { Name : dest Name , Migration : true } op , err : = source . Migrate Container ( source Name , req ) if err ! = nil { return errors . Wrap ( err , i 1 8n . G ( " " ) ) } err = op . Wait ( ) if err ! = nil { return errors . Wrap ( err , i 1 8n . G ( " " ) ) } return nil } 
func ( c Container ) Is Active ( ) bool { switch c . Status Code { case Stopped : return false case Error : return false default : return true } } 
func ( n * Node Tx ) Raft Nodes ( ) ( [ ] Raft Node , error ) { nodes : = [ ] Raft Node { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , Raft Node { } ) return [ ] interface { } { & nodes [ i ] . ID , & nodes [ i ] . Address } } stmt , err : = n . tx . Prepare ( " " ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return nodes , nil } 
func ( n * Node Tx ) Raft Node Address ( id int 6 4 ) ( string , error ) { stmt : = " " addresses , err : = query . Select Strings ( n . tx , stmt , id ) if err ! = nil { return " " , err } switch len ( addresses ) { case 0 : return " " , Err No Such Object case 1 : return addresses [ 0 ] , nil default : } } 
func ( n * Node Tx ) Raft Node First ( address string ) error { columns : = [ ] string { " " , " " } values : = [ ] interface { } { int 6 4 ( 1 ) , address } id , err : = query . Upsert Object ( n . tx , " " , columns , values ) if err ! = nil { return err } if id ! = 1 { return fmt . Errorf ( " " ) } return nil } 
func ( n * Node Tx ) Raft Node Add ( address string ) ( int 6 4 , error ) { columns : = [ ] string { " " } values : = [ ] interface { } { address } return query . Upsert Object ( n . tx , " " , columns , values ) } 
func ( n * Node Tx ) Raft Node Delete ( id int 6 4 ) error { deleted , err : = query . Delete Object ( n . tx , " " , id ) if err ! = nil { return err } if ! deleted { return Err No Such Object } return nil } 
func ( n * Node Tx ) Raft Nodes Replace ( nodes [ ] Raft Node ) error { _ , err : = n . tx . Exec ( " " ) if err ! = nil { return err } columns : = [ ] string { " " , " " } for _ , node : = range nodes { values : = [ ] interface { } { node . ID , node . Address } _ , err : = query . Upsert Object ( n . tx , " " , columns , values ) if err ! = nil { return err } } return nil } 
func ( s * OS ) init CGroup ( ) { flags : = [ ] * bool { & s . CGroup Blkio Controller , & s . CGroup CPUController , & s . CGroup CPUacct Controller , & s . CGroup CPUset Controller , & s . CGroup Devices Controller , & s . CGroup Freezer Controller , & s . CGroup Memory Controller , & s . CGroup Net Prio Controller , & s . CGroup Pids Controller , & s . CGroup Swap Accounting , } for i , flag : = range flags { * flag = shared . Path Exists ( " " + c Groups [ i ] . path ) if ! * flag { logger . Warnf ( c Groups [ i ] . warn ) } } } 
func sqlite Direct Access ( conn * sqlite 3 . SQLite Conn ) error { if err ! = nil { return err } if err ! = nil { return err } if err ! = nil { return err } return nil } 
func ( c * Cluster Tx ) Container List ( filter Container Filter ) ( [ ] Container , error ) { if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } if filter . Node ! = " " { criteria [ " " ] = filter . Node } if filter . Parent ! = " " { criteria [ " " ] = filter . Parent } if filter . Type ! = - 1 { criteria [ " " ] = filter . Type } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Project And Name And Type ) args = [ ] interface { } { filter . Project , filter . Name , filter . Type , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Project And Type And Parent ) args = [ ] interface { } { filter . Project , filter . Type , len ( filter . Parent ) + 1 , filter . Parent + " " , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Project And Node And Type ) args = [ ] interface { } { filter . Project , filter . Node , filter . Type , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Node And Type ) args = [ ] interface { } { filter . Node , filter . Type , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Project And Type ) args = [ ] interface { } { filter . Project , filter . Type , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Objects By Type ) args = [ ] interface { } { filter . Type , } } else { stmt = c . stmt ( container Objects ) args = [ ] interface { } { } } return [ ] interface { } { & objects [ i ] . ID , & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Node , & objects [ i ] . Type , & objects [ i ] . Architecture , & objects [ i ] . Ephemeral , & objects [ i ] . Creation Date , & objects [ i ] . Stateful , & objects [ i ] . Last Use Date , & objects [ i ] . Description , & objects [ i ] . Expiry Date , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = config Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] map [ string ] string { } config Objects [ objects [ i ] . Project ] = sub Index } value : = config Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = map [ string ] string { } } objects [ i ] . Config = value } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = devices Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] map [ string ] map [ string ] string { } devices Objects [ objects [ i ] . Project ] = sub Index } value : = devices Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = map [ string ] map [ string ] string { } } objects [ i ] . Devices = value } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = profiles Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] [ ] string { } profiles Objects [ objects [ i ] . Project ] = sub Index } value : = profiles Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = [ ] string { } } objects [ i ] . Profiles = value } return objects , nil } 
func ( c * Cluster Tx ) Container Get ( project string , name string ) ( * Container , error ) { filter : = Container Filter { } filter . Project = project filter . Name = name filter . Type = - 1 objects , err : = c . Container List ( filter ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , Err No Such Object case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Container ID ( project string , name string ) ( int 6 4 , error ) { stmt : = c . stmt ( container ID ) rows , err : = stmt . Query ( project , name ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } defer rows . Close ( ) } var id int 6 4 err = rows . Scan ( & id ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } if rows . Next ( ) { return - 1 , fmt . Errorf ( " " ) } err = rows . Err ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } return id , nil } 
func ( c * Cluster Tx ) Container Exists ( project string , name string ) ( bool , error ) { _ , err : = c . Container ID ( project , name ) if err ! = nil { if err = = Err No Such Object { return false , nil } return false , err } return true , nil } 
func ( c * Cluster Tx ) Container Create ( object Container ) ( int 6 4 , error ) { if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } if exists { return - 1 , fmt . Errorf ( " " ) } args : = make ( [ ] interface { } , 1 1 ) args [ 1 ] = object . Name args [ 2 ] = object . Node args [ 3 ] = object . Type args [ 4 ] = object . Architecture args [ 5 ] = object . Ephemeral args [ 6 ] = object . Creation Date args [ 7 ] = object . Stateful args [ 8 ] = object . Last Use Date args [ 9 ] = object . Description args [ 1 0 ] = object . Expiry Date if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } id , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } for key , value : = range object . Config { _ , err : = stmt . Exec ( id , key , value ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } if ! ok { return - 1 , fmt . Errorf ( " " , name ) } typ Code , err : = db Device Type To Int ( typ ) if err ! = nil { return - 1 , errors . Wrapf ( err , " " , typ ) } stmt = c . stmt ( container Create Devices Ref ) result , err : = stmt . Exec ( id , name , typ Code ) if err ! = nil { return - 1 , errors . Wrapf ( err , " " , name ) } device ID , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } stmt = c . stmt ( container Create Devices Config Ref ) for key , value : = range config { _ , err : = stmt . Exec ( device ID , key , value ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } } if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } return id , nil } 
func ( c * Cluster Tx ) Container Profiles Ref ( filter Container Filter ) ( map [ string ] map [ string ] [ ] string , error ) { Name string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } if filter . Parent ! = " " { criteria [ " " ] = filter . Parent } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Profiles Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Profiles Ref By Project And Node ) args = [ ] interface { } { filter . Project , filter . Node , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Profiles Ref By Project ) args = [ ] interface { } { filter . Project , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Profiles Ref By Node ) args = [ ] interface { } { filter . Node , } } else { stmt = c . stmt ( container Profiles Ref ) args = [ ] interface { } { } } Name string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] [ ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = [ ] string { } } index [ object . Project ] [ object . Name ] = append ( item , object . Value ) } return index , nil } 
func ( c * Cluster Tx ) Container Config Ref ( filter Container Filter ) ( map [ string ] map [ string ] map [ string ] string , error ) { Name string Key string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } if filter . Parent ! = " " { criteria [ " " ] = filter . Parent } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Config Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Config Ref By Project And Node ) args = [ ] interface { } { filter . Project , filter . Node , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Config Ref By Node ) args = [ ] interface { } { filter . Node , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Config Ref By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( container Config Ref ) args = [ ] interface { } { } } Name string Key string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Key , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] map [ string ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = map [ string ] string { } } index [ object . Project ] [ object . Name ] = item item [ object . Key ] = object . Value } return index , nil } 
func ( c * Cluster Tx ) Container Devices Ref ( filter Container Filter ) ( map [ string ] map [ string ] map [ string ] map [ string ] string , error ) { Name string Device string Type int Key string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } if filter . Parent ! = " " { criteria [ " " ] = filter . Parent } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Devices Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( container Devices Ref By Project And Node ) args = [ ] interface { } { filter . Project , filter . Node , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Devices Ref By Node ) args = [ ] interface { } { filter . Node , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( container Devices Ref By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( container Devices Ref ) args = [ ] interface { } { } } Name string Device string Type int Key string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Device , & objects [ i ] . Type , & objects [ i ] . Key , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] map [ string ] map [ string ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = map [ string ] map [ string ] string { } } index [ object . Project ] [ object . Name ] = item config , ok : = item [ object . Device ] if ! ok { if err ! = nil { return nil , errors . Wrapf ( err , " " , object . Type ) } config = map [ string ] string { } config [ " " ] = device Type item [ object . Device ] = config } if object . Key ! = " " { config [ object . Key ] = object . Value } } return index , nil } 
func ( m * Mapping ) Natural Key ( ) [ ] * Field { key : = [ ] * Field { } for _ , field : = range m . Fields { if field . Config . Get ( " " ) ! = " " { key = append ( key , field ) } } if len ( key ) = = 0 { } return key } 
func ( m * Mapping ) Contains Fields ( fields [ ] * Field ) bool { matches : = map [ * Field ] bool { } for _ , field : = range m . Fields { for _ , other : = range fields { if field . Name = = other . Name & & field . Type . Name = = other . Type . Name { matches [ field ] = true } } } return len ( matches ) = = len ( fields ) } 
func ( m * Mapping ) Field By Name ( name string ) * Field { for _ , field : = range m . Fields { if field . Name = = name { return field } } return nil } 
func ( m * Mapping ) Field Column Name ( name string ) string { field : = m . Field By Name ( name ) return fmt . Sprintf ( " " , entity Table ( m . Name ) , field . Column ( ) ) } 
func ( m * Mapping ) Filter Field By Name ( name string ) ( * Field , error ) { field : = m . Field By Name ( name ) if field = = nil { return nil , fmt . Errorf ( " " , name ) } if field . Type . Code ! = Type Column { return nil , fmt . Errorf ( " " , name ) } return field , nil } 
func ( m * Mapping ) Column Fields ( exclude . . . string ) [ ] * Field { fields : = [ ] * Field { } for _ , field : = range m . Fields { if shared . String In Slice ( field . Name , exclude ) { continue } if field . Type . Code = = Type Column { fields = append ( fields , field ) } } return fields } 
func ( m * Mapping ) Scalar Fields ( ) [ ] * Field { fields : = [ ] * Field { } for _ , field : = range m . Fields { if field . Config . Get ( " " ) ! = " " { fields = append ( fields , field ) } } return fields } 
func ( m * Mapping ) Ref Fields ( ) [ ] * Field { fields : = [ ] * Field { } for _ , field : = range m . Fields { if field . Type . Code = = Type Slice | | field . Type . Code = = Type Map { fields = append ( fields , field ) } } return fields } 
func ( f * Field ) Column ( ) string { if f . Type . Code ! = Type Column { panic ( " " ) } column : = lex . Snake ( f . Name ) join : = f . Config . Get ( " " ) if join ! = " " { column = fmt . Sprintf ( " " , join , column ) } return column } 
func ( f * Field ) Zero Value ( ) string { if f . Type . Code ! = Type Column { panic ( " " ) } switch f . Type . Name { case " " : return ` " " ` case " " : default : panic ( " " ) } } 
func Field Columns ( fields [ ] * Field ) string { columns : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { columns [ i ] = field . Column ( ) } return strings . Join ( columns , " " ) } 
func Field Args ( fields [ ] * Field ) string { args : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { args [ i ] = fmt . Sprintf ( " " , lex . Minuscule ( field . Name ) , field . Type . Name ) } return strings . Join ( args , " " ) } 
func Field Params ( fields [ ] * Field ) string { args : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { args [ i ] = lex . Minuscule ( field . Name ) } return strings . Join ( args , " " ) } 
func Field Criteria ( fields [ ] * Field ) string { criteria : = make ( [ ] string , len ( fields ) ) for i , field : = range fields { criteria [ i ] = fmt . Sprintf ( " " , field . Column ( ) ) } return strings . Join ( criteria , " " ) } 
func api 1 0Resources Get ( d * Daemon , r * http . Request ) Response { if response ! = nil { return response } cpu , err : = util . CPUResource ( ) if err ! = nil { return Smart Error ( err ) } cards , _ , err : = device Load Gpu ( false ) if err ! = nil { return Smart Error ( err ) } gpus : = api . Resources GPU { } gpus . Cards = [ ] api . Resources GPUCard { } processed Cards : = map [ uint 6 4 ] bool { } for _ , card : = range cards { id , err : = strconv . Parse Uint ( card . id , 1 0 , 6 4 ) if err ! = nil { continue } if processed Cards [ id ] { continue } gpu : = api . Resources GPUCard { } gpu . ID = id gpu . Driver = card . driver gpu . Driver Version = card . driver Version gpu . PCIAddress = card . pci gpu . Vendor = card . vendor Name gpu . Vendor ID = card . vendor ID gpu . Product = card . product Name gpu . Product ID = card . product ID gpu . NUMANode = card . numa Node if card . is Nvidia { gpu . Nvidia = & api . Resources GPUCard Nvidia { CUDAVersion : card . nvidia . cuda Version , NVRMVersion : card . nvidia . nvrm Version , Brand : card . nvidia . brand , Model : card . nvidia . model , UUID : card . nvidia . uuid , Architecture : card . nvidia . architecture , } } gpus . Cards = append ( gpus . Cards , gpu ) gpus . Total + = 1 processed Cards [ id ] = true } mem , err : = util . Memory Resource ( ) if err ! = nil { return Smart Error ( err ) } res . CPU = * cpu res . GPU = gpus res . Memory = * mem return Sync Response ( true , res ) } 
func storage Pool Resources Get ( d * Daemon , r * http . Request ) Response { if response ! = nil { return response } s , err : = storage Pool Init ( d . State ( ) , pool Name ) if err ! = nil { return Internal Error ( err ) } err = s . Storage Pool Check ( ) if err ! = nil { return Internal Error ( err ) } res , err : = s . Storage Pool Resources ( ) if err ! = nil { return Internal Error ( err ) } return Sync Response ( true , & res ) } 
func init Data Node Apply ( d lxd . Container Server , config init Data Node ) ( func ( ) , error ) { revert : = func ( ) { } } if err ! = nil { return revert , errors . Wrap ( err , " " ) } } ) err = shared . Deep Copy ( current Server . Writable ( ) , & new Server ) if err ! = nil { return revert , errors . Wrap ( err , " " ) } for k , v : = range config . Config { new Server . Config [ k ] = fmt . Sprintf ( " " , v ) } if err ! = nil { return revert , errors . Wrap ( err , " " ) } } if err ! = nil { return revert , errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrapf ( err , " " , network . Name ) } } ) return nil } if err ! = nil { return errors . Wrapf ( err , " " , network . Name ) } } ) err = shared . Deep Copy ( current Network . Writable ( ) , & new Network ) if err ! = nil { return errors . Wrapf ( err , " " , network . Name ) } } } if err ! = nil { return errors . Wrapf ( err , " " , network . Name ) } return nil } for _ , network : = range config . Networks { if err ! = nil { return revert , err } continue } if err ! = nil { return revert , err } } } if err ! = nil { return revert , errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrapf ( err , " " , storage Pool . Name ) } } ) return nil } if err ! = nil { return errors . Wrapf ( err , " " , storage Pool . Name ) } } } ) err = shared . Deep Copy ( current Storage Pool . Writable ( ) , & new Storage Pool ) if err ! = nil { return errors . Wrapf ( err , " " , storage Pool . Name ) } } } if err ! = nil { return errors . Wrapf ( err , " " , storage Pool . Name ) } return nil } for _ , storage Pool : = range config . Storage Pools { if err ! = nil { return revert , err } continue } if err ! = nil { return revert , err } } } if err ! = nil { return revert , errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrapf ( err , " " , profile . Name ) } } ) return nil } if err ! = nil { return errors . Wrapf ( err , " " , profile . Name ) } } ) err = shared . Deep Copy ( current Profile . Writable ( ) , & new Profile ) if err ! = nil { return errors . Wrapf ( err , " " , profile . Name ) } } } if ! ok { new Profile . Devices [ k ] = v continue } } } if err ! = nil { return errors . Wrapf ( err , " " , profile . Name ) } return nil } for _ , profile : = range config . Profiles { if err ! = nil { return revert , err } continue } if err ! = nil { return revert , err } } } return nil , nil } 
func init Data Cluster Apply ( d lxd . Container Server , config * init Data Cluster ) error { if config = = nil | | ! config . Enabled { return nil } if err ! = nil { return errors . Wrap ( err , " " ) } if err ! = nil { return errors . Wrap ( err , " " ) } err = op . Wait ( ) if err ! = nil { return errors . Wrap ( err , " " ) } } return nil } 
func Terminal Format ( ) Format { return Format Func ( func ( r * Record ) [ ] byte { var color = 0 switch r . Lvl { case Lvl Crit : color = 3 5 case Lvl Error : color = 3 1 case Lvl Warn : color = 3 3 case Lvl Info : color = 3 2 case Lvl Debug : color = 3 6 } b : = & bytes . Buffer { } lvl : = strings . To Upper ( r . Lvl . String ( ) ) if color > 0 { fmt . Fprintf ( b , " \x 1b \x 1b " , color , lvl , r . Time . Format ( term Time Format ) , r . Msg ) } else { fmt . Fprintf ( b , " " , lvl , r . Time . Format ( term Time Format ) , r . Msg ) } } return b . Bytes ( ) } ) } 
func Json Format Ex ( pretty , line Separated bool ) Format { json Marshal : = json . Marshal if pretty { json Marshal = func ( v interface { } ) ( [ ] byte , error ) { return json . Marshal Indent ( v , " " , " " ) } } return Format Func ( func ( r * Record ) [ ] byte { props : = make ( map [ string ] interface { } ) props [ r . Key Names . Time ] = r . Time props [ r . Key Names . Lvl ] = r . Lvl props [ r . Key Names . Msg ] = r . Msg for i : = 0 ; i < len ( r . Ctx ) ; i + = 2 { k , ok : = r . Ctx [ i ] . ( string ) if ! ok { props [ error Key ] = fmt . Sprintf ( " " , r . Ctx [ i ] ) } props [ k ] = format Json Value ( r . Ctx [ i + 1 ] ) } b , err : = json Marshal ( props ) if err ! = nil { b , _ = json Marshal ( map [ string ] string { error Key : err . Error ( ) , } ) return b } if line Separated { b = append ( b , ' \n ' ) } return b } ) } 
func format Logfmt Value ( value interface { } ) string { if value = = nil { return " " } value = format Shared ( value ) switch v : = value . ( type ) { case bool : return strconv . Format Bool ( v ) case float 3 2 : return strconv . Format Float ( float 6 4 ( v ) , float Format , 3 , 6 4 ) case float 6 4 : return strconv . Format Float ( v , float Format , 3 , 6 4 ) case int , int 8 , int 1 6 , int 3 2 , int 6 4 , uint , uint 8 , uint 1 6 , uint 3 2 , uint 6 4 : return fmt . Sprintf ( " " , value ) case string : return escape String ( v ) default : return escape String ( fmt . Sprintf ( " " , value ) ) } } 
func Resolve Target ( cluster * db . Cluster , target string ) ( string , error ) { address : = " " err : = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { name , err : = tx . Node Name ( ) if err ! = nil { return err } if target = = name { return nil } node , err : = tx . Node By Name ( target ) if err ! = nil { if err = = db . Err No Such Object { return fmt . Errorf ( " " , target ) } return err } if node . Name ! = name { address = node . Address } return nil } ) return address , err } 
func ( pt * Progress Writer ) Write ( p [ ] byte ) ( int , error ) { pt . Tracker . update ( n ) } return n , err } 
func update Node Version ( tx * sql . Tx , address string , api Extensions int ) error { stmt : = " " result , err : = tx . Exec ( stmt , len ( updates ) , api Extensions , address ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func select Nodes Versions ( tx * sql . Tx ) ( [ ] [ 2 ] int , error ) { versions : = [ ] [ 2 ] int { } dest : = func ( i int ) [ ] interface { } { versions = append ( versions , [ 2 ] int { } ) return [ ] interface { } { & versions [ i ] [ 0 ] , & versions [ i ] [ 1 ] } } stmt , err : = tx . Prepare ( " " ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest ) if err ! = nil { return nil , err } return versions , nil } 
func Get Architectures ( ) ( [ ] int , error ) { architectures : = [ ] int { } architecture Name , err : = osarch . Architecture Get Local ( ) if err ! = nil { return nil , err } architecture , err : = osarch . Architecture Id ( architecture Name ) if err ! = nil { return nil , err } architectures = append ( architectures , architecture ) personalities , err : = osarch . Architecture Personalities ( architecture ) if err ! = nil { return nil , err } for _ , personality : = range personalities { architectures = append ( architectures , personality ) } return architectures , nil } 
func Get Idmap Set ( ) * idmap . Idmap Set { idmap Set , err : = idmap . Default Idmap Set ( " " , " " ) if err ! = nil { logger . Warn ( " " , log . Ctx { " " : err . Error ( ) } ) logger . Warnf ( " " ) idmap Set = nil } else { kernel Idmap Set , err : = idmap . Current Idmap Set ( ) if err = = nil { logger . Infof ( " " ) for _ , lxcmap : = range kernel Idmap Set . To Lxc String ( ) { logger . Infof ( fmt . Sprintf ( " " , lxcmap ) ) } } if len ( idmap Set . Idmap ) = = 0 { logger . Warnf ( " " ) logger . Warnf ( " " ) idmap Set = nil } else { logger . Infof ( " " ) for _ , lxcmap : = range idmap Set . Idmap { suffix : = " " if lxcmap . Usable ( ) ! = nil { suffix = " " } for _ , lxc Entry : = range lxcmap . To Lxc String ( ) { logger . Infof ( " " , lxc Entry , suffix ) } } err = idmap Set . Usable ( ) if err ! = nil { logger . Warnf ( " " ) logger . Warnf ( " " ) idmap Set = nil } } } return idmap Set } 
func Runtime Liblxc Version At Least ( major int , minor int , micro int ) bool { version : = golxc . Version ( ) version = strings . Replace ( version , " " , " " , 1 ) parts : = strings . Split ( version , " " ) parts Len : = len ( parts ) if parts Len = = 0 { return false } devel Parts : = strings . Split ( parts [ parts Len - 1 ] , " " ) if len ( devel Parts ) = = 2 & & devel Parts [ 1 ] = = " " { return true } maj : = - 1 min : = - 1 mic : = - 1 for i , v : = range parts { if i > 2 { break } num , err : = strconv . Atoi ( v ) if err ! = nil { return false } switch i { case 0 : maj = num case 1 : min = num case 2 : mic = num } } if maj > major { return true } if maj < major { return false } if min > minor { return true } if min < minor { return false } if mic > micro { return true } if mic < micro { return false } return true } 
func Get Exec Path ( ) string { exec Path : = os . Getenv ( " " ) if exec Path ! = " " { return exec Path } exec Path , err : = os . Readlink ( " " ) if err ! = nil { exec Path = " " } return exec Path } 
func Connect ( address string , cert * shared . Cert Info , notify bool ) ( lxd . Container Server , error ) { args : = & lxd . Connection Args { TLSServer Cert : string ( cert . Public Key ( ) ) , TLSClient Cert : string ( cert . Public Key ( ) ) , TLSClient Key : string ( cert . Private Key ( ) ) , Skip Get Server : true , } if notify { args . User Agent = " " } url : = fmt . Sprintf ( " " , address ) return lxd . Connect LXD ( url , args ) } 
func Connect If Container Is Remote ( cluster * db . Cluster , project , name string , cert * shared . Cert Info ) ( lxd . Container Server , error ) { var address string err : = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error address , err = tx . Container Node Address ( project , name ) return err } ) if err ! = nil { return nil , err } if address = = " " { } return Connect ( address , cert , false ) } 
func Connect If Volume Is Remote ( cluster * db . Cluster , pool ID int 6 4 , volume Name string , volume Type int , cert * shared . Cert Info ) ( lxd . Container Server , error ) { var addresses [ ] string err : = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error addresses , err = tx . Storage Volume Node Addresses ( pool ID , " " , volume Name , volume Type ) return err } ) if err ! = nil { return nil , err } if len ( addresses ) > 1 { var driver string err : = cluster . Transaction ( func ( tx * db . Cluster Tx ) error { var err error driver , err = tx . Storage Pool Driver ( pool ID ) return err } ) if err ! = nil { return nil , err } if driver = = " " { return nil , nil } return nil , fmt . Errorf ( " " , volume Name ) } address : = addresses [ 0 ] if address = = " " { return nil , nil } return Connect ( address , cert , false ) } 
func Setup Trust ( cert , target Address , target Cert , target Password string ) error { target , err : = lxd . Connect LXD ( fmt . Sprintf ( " " , target Address ) , args ) if err ! = nil { return errors . Wrap ( err , " " ) } block , _ : = pem . Decode ( [ ] byte ( cert ) ) if block = = nil { return errors . Wrap ( err , " " ) } certificate : = base 6 4 . Std Encoding . Encode To String ( block . Bytes ) post : = api . Certificates Post { Password : target Password , Certificate : certificate , } fingerprint , err : = shared . Cert Fingerprint Str ( cert ) if err ! = nil { return errors . Wrap ( err , " " ) } post . Name = fmt . Sprintf ( " " , fingerprint ) post . Type = " " err = target . Create Certificate ( post ) if err ! = nil & & err . Error ( ) ! = " " { return errors . Wrap ( err , " " ) } return nil } 
func ( r * Protocol LXD ) Get Storage Pools ( ) ( [ ] api . Storage Pool , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } pools : = [ ] api . Storage Pool { } if err ! = nil { return nil , err } return pools , nil } 
func ( r * Protocol LXD ) Get Storage Pool ( name string ) ( * api . Storage Pool , string , error ) { if ! r . Has Extension ( " " ) { return nil , " " , fmt . Errorf ( " \ " \ " " ) } pool : = api . Storage Pool { } if err ! = nil { return nil , " " , err } return & pool , etag , nil } 
func ( r * Protocol LXD ) Create Storage Pool ( pool api . Storage Pools Post ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if pool . Driver = = " " & & ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Update Storage Pool ( name string , pool api . Storage Pool Put , ETag string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Delete Storage Pool ( name string ) error { if ! r . Has Extension ( " " ) { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return err } return nil } 
func ( r * Protocol LXD ) Get Storage Pool Resources ( name string ) ( * api . Resources Storage Pool , error ) { if ! r . Has Extension ( " " ) { return nil , fmt . Errorf ( " \ " \ " " ) } res : = api . Resources Storage Pool { } if err ! = nil { return nil , err } return & res , nil } 
func ( s * OS ) init Dirs ( ) error { dirs : = [ ] struct { path string mode os . File Mode } { { s . Var Dir , 0 7 1 1 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { s . Cache Dir , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 1 1 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 1 1 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 5 5 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { s . Log Dir , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 1 1 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 1 1 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 0 0 } , { filepath . Join ( s . Var Dir , " " ) , 0 7 1 1 } , } for _ , dir : = range dirs { err : = os . Mkdir ( dir . path , dir . mode ) if err ! = nil & & ! os . Is Exist ( err ) { return errors . Wrapf ( err , " " , dir . path ) } } return nil } 
func ( n * Node Tx ) Config ( ) ( map [ string ] string , error ) { return query . Select Config ( n . tx , " " , " " ) } 
func ( n * Node Tx ) Update Config ( values map [ string ] string ) error { return query . Update Config ( n . tx , " " , values ) } 
func ( c * Cluster Tx ) Config ( ) ( map [ string ] string , error ) { return query . Select Config ( c . tx , " " , " " ) } 
func ( c * Cluster Tx ) Update Config ( values map [ string ] string ) error { return query . Update Config ( c . tx , " " , values ) } 
func Config Value Set ( c * Cluster , key string , value string ) error { err : = c . Transaction ( func ( tx * Cluster Tx ) error { _ , err : = tx . tx . Exec ( " " , key ) if err ! = nil { return err } if value ! = " " { str : = `INSERT INTO config (key , value ) VALUES ( ? , ? ) ; ` stmt , err : = tx . tx . Prepare ( str ) if err ! = nil { return err } defer stmt . Close ( ) _ , err = stmt . Exec ( key , value ) if err ! = nil { return err } } return nil } ) return err } 
func storage Pools Get ( d * Daemon , r * http . Request ) Response { recursion : = util . Is Recursion Request ( r ) pools , err : = d . cluster . Storage Pools ( ) if err ! = nil & & err ! = db . Err No Such Object { return Smart Error ( err ) } result String : = [ ] string { } result Map : = [ ] api . Storage Pool { } for _ , pool : = range pools { if ! recursion { result String = append ( result String , fmt . Sprintf ( " " , version . APIVersion , pool ) ) } else { pl ID , pl , err : = d . cluster . Storage Pool Get ( pool ) if err ! = nil { continue } if err ! = nil { return Smart Error ( err ) } pl . Used By = pool Used By result Map = append ( result Map , * pl ) } } if ! recursion { return Sync Response ( true , result String ) } return Sync Response ( true , result Map ) } 
func storage Pools Post ( d * Daemon , r * http . Request ) Response { storage Pool Create Lock . Lock ( ) defer storage Pool Create Lock . Unlock ( ) req : = api . Storage Pools Post { } if err ! = nil { return Bad Request ( err ) } } if strings . Contains ( req . Name , " " ) { return Bad Request ( fmt . Errorf ( " " ) ) } if req . Driver = = " " { return Bad Request ( fmt . Errorf ( " " ) ) } url : = fmt . Sprintf ( " " , version . APIVersion , req . Name ) response : = Sync Response Location ( true , nil , url ) if is Cluster Notification ( r ) { if err ! = nil { return Bad Request ( err ) } err = do Storage Pool Create Internal ( d . State ( ) , req . Name , req . Description , req . Driver , req . Config , true ) if err ! = nil { return Smart Error ( err ) } return response } target Node : = query Param ( r , " " ) if target Node = = " " { count , err : = cluster . Count ( d . State ( ) ) if err ! = nil { return Smart Error ( err ) } if count = = 1 { } else { } if err ! = nil { return Internal Error ( err ) } return response } } } err = storage Pool Validate ( req . Name , req . Driver , req . Config ) if err ! = nil { return Bad Request ( err ) } err = d . cluster . Transaction ( func ( tx * db . Cluster Tx ) error { return tx . Storage Pool Create Pending ( target Node , req . Name , req . Driver , req . Config ) } ) if err ! = nil { if err = = db . Err Already Defined { return Bad Request ( fmt . Errorf ( " " , target Node ) ) } return Smart Error ( err ) } return response } 
func storage Pool Get ( d * Daemon , r * http . Request ) Response { if response ! = nil { return response } pool Name : = mux . Vars ( r ) [ " " ] if err ! = nil { return Smart Error ( err ) } if err ! = nil & & err ! = db . Err No Such Object { return Smart Error ( err ) } pool . Used By = pool Used By target Node : = query Param ( r , " " ) clustered , err : = cluster . Enabled ( d . db ) if err ! = nil { return Smart Error ( err ) } } } etag : = [ ] interface { } { pool . Name , pool . Driver , pool . Config } return Sync Response ETag ( true , & pool , etag ) } 
func storage Pool Put ( d * Daemon , r * http . Request ) Response { pool Name : = mux . Vars ( r ) [ " " ] if err ! = nil { return Smart Error ( err ) } req : = api . Storage Pool Put { } if err : = json . New Decoder ( r . Body ) . Decode ( & req ) ; err ! = nil { return Bad Request ( err ) } clustered , err : = cluster . Enabled ( d . db ) if err ! = nil { return Smart Error ( err ) } config : = db Info . Config if clustered { err : = storage Pool Validate Cluster Config ( req . Config ) if err ! = nil { return Bad Request ( err ) } config = storage Pool Cluster Config For Etag ( config ) } err = util . Etag Check ( r , etag ) if err ! = nil { return Precondition Failed ( err ) } if err ! = nil { return Bad Request ( err ) } config = req . Config if clustered { } notifier , err : = cluster . New Notifier ( d . State ( ) , cert , cluster . Notify All ) if err ! = nil { return Smart Error ( err ) } err = notifier ( func ( client lxd . Container Server ) error { return client . Update Storage Pool ( pool Name , req , r . Header . Get ( " " ) ) } ) if err ! = nil { return Smart Error ( err ) } } with DB : = ! is Cluster Notification ( r ) err = storage Pool Update ( d . State ( ) , pool Name , req . Description , config , with DB ) if err ! = nil { return Internal Error ( err ) } return Empty Sync Response } 
func storage Pool Validate Cluster Config ( req Config map [ string ] string ) error { for key : = range req Config { if shared . String In Slice ( key , db . Storage Pool Node Config Keys ) { return fmt . Errorf ( " " , key ) } } return nil } 
func storage Pool Cluster Config For Etag ( db Config map [ string ] string ) map [ string ] string { config : = util . Copy Config ( db Config ) for _ , key : = range db . Storage Pool Node Config Keys { delete ( config , key ) } return config } 
func storage Pool Cluster Fill With Node Config ( db Config , req Config map [ string ] string ) map [ string ] string { config : = util . Copy Config ( req Config ) for _ , key : = range db . Storage Pool Node Config Keys { config [ key ] = db Config [ key ] } return config } 
func storage Pool Delete ( d * Daemon , r * http . Request ) Response { pool Name : = mux . Vars ( r ) [ " " ] pool ID , err : = d . cluster . Storage Pool Get ID ( pool Name ) if err ! = nil { return Not Found ( err ) } if response ! = nil { return response } } if err ! = nil { return Smart Error ( err ) } if pool . Status = = " " { _ , err : = d . cluster . Storage Pool Delete ( pool Name ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } s , err : = storage Pool Init ( d . State ( ) , pool Name ) if err ! = nil { return Internal Error ( err ) } if shared . Path Exists ( pool Mnt Point ) { err : = os . Remove All ( pool Mnt Point ) if err ! = nil { return Smart Error ( err ) } } return Empty Sync Response } volume Names , err : = d . cluster . Storage Pool Volumes Get Names ( pool ID ) if err ! = nil { return Internal Error ( err ) } for _ , volume : = range volume Names { _ , img Info , err : = d . cluster . Image Get ( " " , volume , false , false ) if err ! = nil { return Internal Error ( err ) } err = do Delete Image From Pool ( d . State ( ) , img Info . Fingerprint , pool Name ) if err ! = nil { return Internal Error ( err ) } } err = s . Storage Pool Delete ( ) if err ! = nil { return Internal Error ( err ) } } if err ! = nil { return Smart Error ( err ) } if clustered { notifier , err : = cluster . New Notifier ( d . State ( ) , d . endpoints . Network Cert ( ) , cluster . Notify All ) if err ! = nil { return Smart Error ( err ) } err = notifier ( func ( client lxd . Container Server ) error { _ , _ , err : = client . Get Server ( ) if err ! = nil { return err } return client . Delete Storage Pool ( pool Name ) } ) if err ! = nil { return Smart Error ( err ) } } err = db Storage Pool Delete And Update Cache ( d . cluster , pool Name ) if err ! = nil { return Smart Error ( err ) } return Empty Sync Response } 
func ( r * Protocol LXD ) Get Events ( ) ( * Event Listener , error ) { defer r . event Listeners Lock . Unlock ( ) if r . event Listeners ! = nil { return & listener , nil } if err ! = nil { return nil , err } conn , err : = r . websocket ( url ) if err ! = nil { return nil , err } go func ( ) { for { select { case < - time . After ( time . Minute ) : case < - stop Ch : break } r . event Listeners Lock . Lock ( ) if len ( r . event Listeners ) = = 0 { r . event Listeners = nil r . event Listeners Lock . Unlock ( ) break } r . event Listeners Lock . Unlock ( ) } } ( ) if err ! = nil { defer r . event Listeners Lock . Unlock ( ) listener . disconnected = true close ( listener . ch Active ) } conn . Close ( ) close ( stop Ch ) return } err = json . Unmarshal ( data , & event ) if err ! = nil { continue } } for _ , listener : = range r . event Listeners { listener . targets Lock . Lock ( ) for _ , target : = range listener . targets { if target . types ! = nil & & ! shared . String In Slice ( event . Type , target . types ) { continue } go target . function ( event ) } listener . targets Lock . Unlock ( ) } r . event Listeners Lock . Unlock ( ) } } ( ) return & listener , nil } 
func Logfmt Format ( ) log . Format { return log . Format Func ( func ( r * log . Record ) [ ] byte { common : = [ ] interface { } { r . Key Names . Time , r . Time , r . Key Names . Lvl , r . Lvl , r . Key Names . Msg , r . Msg } buf : = & bytes . Buffer { } logfmt ( buf , common , 0 , false ) buf . Truncate ( buf . Len ( ) - 1 ) buf . Write Byte ( ' ' ) logfmt ( buf , r . Ctx , 0 , true ) return buf . Bytes ( ) } ) } 
func ( c * Cluster Tx ) Storage Volume Node Addresses ( pool ID int 6 4 , project , name string , typ int ) ( [ ] string , error ) { nodes : = [ ] struct { id int 6 4 address string } { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , struct { id int 6 4 address string } { } ) return [ ] interface { } { & nodes [ i ] . id , & nodes [ i ] . address } } sql : = ` SELECT nodes .id , nodes .address FROM nodes JOIN storage _volumes ON storage _volumes .node _id =nodes .id JOIN projects ON projects .id = storage _volumes .project _id WHERE storage _volumes .storage _pool _id = ? AND projects .name = ? AND storage _volumes .name = ? AND storage _volumes .type = ? ` stmt , err : = c . tx . Prepare ( sql ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , pool ID , project , name , typ ) if err ! = nil { return nil , err } addresses : = [ ] string { } for _ , node : = range nodes { address : = node . address if node . id = = c . node ID { address = " " } addresses = append ( addresses , address ) } sort . Strings ( addresses ) if len ( addresses ) = = 0 { return nil , Err No Such Object } return addresses , nil } 
func ( c * Cluster ) Storage Volume Node Get ( volume ID int 6 4 ) ( string , error ) { name : = " " query : = ` SELECT nodes .name FROM storage _volumes JOIN nodes ON nodes .id =storage _volumes .node _id WHERE storage _volumes .id = ? ` inargs : = [ ] interface { } { volume ID } outargs : = [ ] interface { } { & name } err : = db Query Row Scan ( c . db , query , inargs , outargs ) if err ! = nil { if err = = sql . Err No Rows { return " " , Err No Such Object } return " " , err } return name , nil } 
func ( c * Cluster ) Storage Volume Config Get ( volume ID int 6 4 ) ( map [ string ] string , error ) { var key , value string query : = " " inargs : = [ ] interface { } { volume ID } outargs : = [ ] interface { } { key , value } results , err : = query Scan ( c . db , query , inargs , outargs ) if err ! = nil { return nil , err } config : = map [ string ] string { } for _ , r : = range results { key = r [ 0 ] . ( string ) value = r [ 1 ] . ( string ) config [ key ] = value } return config , nil } 
func ( c * Cluster ) Storage Volume Description Get ( volume ID int 6 4 ) ( string , error ) { description : = sql . Null String { } query : = " " inargs : = [ ] interface { } { volume ID } outargs : = [ ] interface { } { & description } err : = db Query Row Scan ( c . db , query , inargs , outargs ) if err ! = nil { if err = = sql . Err No Rows { return " " , Err No Such Object } return " " , err } return description . String , nil } 
func ( c * Cluster ) Storage Volume Next Snapshot ( name string , typ int ) int { base : = name + shared . Snapshot Delimiter + " " length : = len ( base ) q : = fmt . Sprintf ( " " ) var numstr string inargs : = [ ] interface { } { typ , true , length , base } outfmt : = [ ] interface { } { numstr } results , err : = query Scan ( c . db , q , inargs , outfmt ) if err ! = nil { return 0 } max : = 0 for _ , r : = range results { numstr = r [ 0 ] . ( string ) if len ( numstr ) < = length { continue } substr : = numstr [ length : ] var num int count , err : = fmt . Sscanf ( substr , " " , & num ) if err ! = nil | | count ! = 1 { continue } if num > = max { max = num + 1 } } return max } 
func ( c * Cluster ) Storage Volume Is Available ( pool , volume string ) ( bool , error ) { is Available : = false err : = c . Transaction ( func ( tx * Cluster Tx ) error { id , err : = tx . Storage Pool ID ( pool ) if err ! = nil { return errors . Wrapf ( err , " " , pool ) } driver , err : = tx . Storage Pool Driver ( id ) if err ! = nil { return errors . Wrapf ( err , " " , pool ) } if driver ! = " " { is Available = true return nil } node , err : = tx . Node Name ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } containers , err : = tx . Container List Expanded ( ) if err ! = nil { return errors . Wrapf ( err , " " ) } for _ , container : = range containers { for _ , device : = range container . Devices { if device [ " " ] ! = " " { continue } if device [ " " ] ! = pool { continue } if device [ " " ] ! = volume { continue } if container . Node ! = node { } } } is Available = true return nil } ) if err ! = nil { return false , err } return is Available , nil } 
func Storage Volume Description Update ( tx * sql . Tx , volume ID int 6 4 , description string ) error { _ , err : = tx . Exec ( " " , description , volume ID ) return err } 
func Storage Volume Config Add ( tx * sql . Tx , volume ID int 6 4 , volume Config map [ string ] string ) error { str : = " " stmt , err : = tx . Prepare ( str ) defer stmt . Close ( ) if err ! = nil { return err } for k , v : = range volume Config { if v = = " " { continue } _ , err = stmt . Exec ( volume ID , k , v ) if err ! = nil { return err } } return nil } 
func Storage Volume Config Clear ( tx * sql . Tx , volume ID int 6 4 ) error { _ , err : = tx . Exec ( " " , volume ID ) if err ! = nil { return err } return nil } 
func storage Volume IDs Get ( tx * sql . Tx , project , volume Name string , volume Type int , pool ID int 6 4 ) ( [ ] int 6 4 , error ) { ids , err : = query . Select Integers ( tx , ` SELECT storage _volumes .id FROM storage _volumes JOIN projects ON projects .id = storage _volumes .project _id WHERE projects .name = ? AND storage _volumes .name = ? AND storage _volumes .type = ? AND storage _pool _id = ? ` , project , volume Name , volume Type , pool ID ) if err ! = nil { return nil , err } ids 6 4 : = make ( [ ] int 6 4 , len ( ids ) ) for i , id : = range ids { ids 6 4 [ i ] = int 6 4 ( id ) } return ids 6 4 , nil } 
func ( c * Cluster ) Storage Volume Cleanup Images ( fingerprints [ ] string ) error { stmt : = fmt . Sprintf ( " " , query . Params ( len ( fingerprints ) ) ) args : = [ ] interface { } { Storage Pool Volume Type Image } for _ , fingerprint : = range fingerprints { args = append ( args , fingerprint ) } err : = exec ( c . db , stmt , args . . . ) return err } 
func ( c * Cluster ) Storage Volume Move To LVMThin Pool Name Key ( ) error { err : = exec ( c . db , " " ) if err ! = nil { return err } err = exec ( c . db , " " ) if err ! = nil { return err } return nil } 
func ( b * Buffer ) L ( format string , a . . . interface { } ) { fmt . Fprintf ( b . buf , format , a . . . ) b . N ( ) } 
func ( b * Buffer ) code ( ) ( [ ] byte , error ) { code , err : = format . Source ( b . buf . Bytes ( ) ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return code , nil } 
func Pretty ( input interface { } ) string { pretty , err : = json . Marshal Indent ( input , " \t " , " \t " ) if err ! = nil { return fmt . Sprintf ( " " , input ) } return fmt . Sprintf ( " \n \t " , pretty ) } 
func ( e * Endpoints ) Network Public Key ( ) [ ] byte { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert . Public Key ( ) } 
func ( e * Endpoints ) Network Private Key ( ) [ ] byte { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert . Private Key ( ) } 
func ( e * Endpoints ) Network Cert ( ) * shared . Cert Info { e . mu . RLock ( ) defer e . mu . RUnlock ( ) return e . cert } 
func ( e * Endpoints ) Network Address ( ) string { e . mu . RLock ( ) defer e . mu . RUnlock ( ) listener : = e . listeners [ network ] if listener = = nil { return " " } return listener . Addr ( ) . String ( ) } 
func ( e * Endpoints ) Network Update Address ( address string ) error { if address ! = " " { address = util . Canonical Network Address ( address ) } old Address : = e . Network Address ( ) if address = = old Address { return nil } cluster Address : = e . Cluster Address ( ) logger . Infof ( " " ) e . mu . Lock ( ) defer e . mu . Unlock ( ) } } var listener net . Listener for i : = 0 ; i < 1 0 ; i + + { if err = = nil { break } time . Sleep ( 1 0 0 * time . Millisecond ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & listener , nil } if err ! = nil { if err 1 = = nil { e . listeners [ network ] = network TLSListener ( * listener , e . cert ) e . serve HTTP ( network ) } return err } e . listeners [ network ] = network TLSListener ( * listener , e . cert ) e . serve HTTP ( network ) } return nil } 
func ( e * Endpoints ) Network Update Cert ( cert * shared . Cert Info ) { e . mu . Lock ( ) defer e . mu . Unlock ( ) e . cert = cert listener , ok : = e . listeners [ network ] if ! ok { return } listener . ( * network Listener ) . Config ( cert ) if ! ok { return } listener . ( * network Listener ) . Config ( cert ) } 
func network Create Listener ( address string , cert * shared . Cert Info ) net . Listener { listener , err : = net . Listen ( " " , util . Canonical Network Address ( address ) ) if err ! = nil { logger . Error ( " " , log . Ctx { " " : err } ) return nil } return network TLSListener ( listener , cert ) } 
func ( l * network Listener ) Accept ( ) ( net . Conn , error ) { c , err : = l . Listener . Accept ( ) if err ! = nil { return nil , err } l . mu . RLock ( ) defer l . mu . RUnlock ( ) config : = l . config return tls . Server ( c , config ) , nil } 
func ( l * network Listener ) Config ( cert * shared . Cert Info ) { config : = util . Server TLSConfig ( cert ) l . mu . Lock ( ) defer l . mu . Unlock ( ) l . config = config } 
func Start ( f Func , schedule Schedule ) ( func ( time . Duration ) error , func ( ) ) { group : = Group { } task : = group . Add ( f , schedule ) group . Start ( ) stop : = group . Stop reset : = task . Reset return stop , reset } 
func ( n Node Info ) Is Offline ( threshold time . Duration ) bool { return node Is Offline ( threshold , n . Heartbeat ) } 
func ( c * Cluster Tx ) Node By Address ( address string ) ( Node Info , error ) { null : = Node Info { } nodes , err : = c . nodes ( false , " " , address ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , Err No Such Object case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Node Pending By Address ( address string ) ( Node Info , error ) { null : = Node Info { } nodes , err : = c . nodes ( true , " " , address ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , Err No Such Object case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Node By Name ( name string ) ( Node Info , error ) { null : = Node Info { } nodes , err : = c . nodes ( false , " " , name ) if err ! = nil { return null , err } switch len ( nodes ) { case 0 : return null , Err No Such Object case 1 : return nodes [ 0 ] , nil default : return null , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Node Name ( ) ( string , error ) { stmt : = " " names , err : = query . Select Strings ( c . tx , stmt , c . node ID ) if err ! = nil { return " " , err } switch len ( names ) { case 0 : return " " , nil case 1 : return names [ 0 ] , nil default : return " " , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Node Address ( ) ( string , error ) { stmt : = " " addresses , err : = query . Select Strings ( c . tx , stmt , c . node ID ) if err ! = nil { return " " , err } switch len ( addresses ) { case 0 : return " " , nil case 1 : return addresses [ 0 ] , nil default : return " " , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Node Is Outdated ( ) ( bool , error ) { nodes , err : = c . nodes ( false , " " ) if err ! = nil { return false , errors . Wrap ( err , " " ) } for _ , node : = range nodes { if node . ID = = c . node ID { version = node . Version ( ) } } if version [ 0 ] = = 0 | | version [ 1 ] = = 0 { return false , fmt . Errorf ( " " ) } } n , err : = util . Compare Versions ( node . Version ( ) , version ) if err ! = nil { errors . Wrapf ( err , " " , node . Name ) } if n = = 1 { } } return false , nil } 
func ( c * Cluster Tx ) Nodes Count ( ) ( int , error ) { count , err : = query . Count ( c . tx , " " , " " ) if err ! = nil { return 0 , errors . Wrap ( err , " " ) } return count , nil } 
func ( c * Cluster Tx ) Node Rename ( old , new string ) error { count , err : = query . Count ( c . tx , " " , " " , new ) if err ! = nil { return errors . Wrap ( err , " " ) } if count ! = 0 { return Err Already Defined } stmt : = `UPDATE nodes SET name = ? WHERE name = ? ` result , err : = c . tx . Exec ( stmt , new , old ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) nodes ( pending bool , where string , args . . . interface { } ) ( [ ] Node Info , error ) { nodes : = [ ] Node Info { } dest : = func ( i int ) [ ] interface { } { nodes = append ( nodes , Node Info { } ) return [ ] interface { } { & nodes [ i ] . ID , & nodes [ i ] . Name , & nodes [ i ] . Address , & nodes [ i ] . Description , & nodes [ i ] . Schema , & nodes [ i ] . APIExtensions , & nodes [ i ] . Heartbeat , } } if pending { args = append ( [ ] interface { } { 1 } , args . . . ) } else { args = append ( [ ] interface { } { 0 } , args . . . ) } sql : = ` SELECT id , name , address , description , schema , api _extensions , heartbeat FROM nodes WHERE pending = ? ` if where ! = " " { sql + = fmt . Sprintf ( " " , where ) } sql + = " " stmt , err : = c . tx . Prepare ( sql ) if err ! = nil { return nil , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest , args . . . ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return nodes , nil } 
func ( c * Cluster Tx ) Node Add ( name string , address string ) ( int 6 4 , error ) { columns : = [ ] string { " " , " " , " " , " " } values : = [ ] interface { } { name , address , cluster . Schema Version , version . APIExtensions Count ( ) } return query . Upsert Object ( c . tx , " " , columns , values ) } 
func ( c * Cluster Tx ) Node Pending ( id int 6 4 , pending bool ) error { value : = 0 if pending { value = 1 } result , err : = c . tx . Exec ( " " , value , id ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Node Update ( id int 6 4 , name string , address string ) error { result , err : = c . tx . Exec ( " " , name , address , id ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Node Remove ( id int 6 4 ) error { result , err : = c . tx . Exec ( " " , id ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Node Heartbeat ( address string , heartbeat time . Time ) error { stmt : = " " result , err : = c . tx . Exec ( stmt , heartbeat , address ) if err ! = nil { return err } n , err : = result . Rows Affected ( ) if err ! = nil { return err } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Node Is Empty ( id int 6 4 ) ( string , error ) { if err ! = nil { return " " , errors . Wrapf ( err , " " , id ) } if len ( containers ) > 0 { message : = fmt . Sprintf ( " " , strings . Join ( containers , " " ) ) return message , nil } node ID int 6 4 } { } dest : = func ( i int ) [ ] interface { } { images = append ( images , struct { fingerprint string node ID int 6 4 } { } ) return [ ] interface { } { & images [ i ] . fingerprint , & images [ i ] . node ID } } stmt , err : = c . tx . Prepare ( ` SELECT fingerprint , node _id FROM images JOIN images _nodes ON images .id =images _nodes .image _id ` ) if err ! = nil { return " " , err } defer stmt . Close ( ) err = query . Select Objects ( stmt , dest ) if err ! = nil { return " " , errors . Wrapf ( err , " " , id ) } index : = map [ string ] [ ] int 6 4 { } for _ , image : = range images { index [ image . fingerprint ] = append ( index [ image . fingerprint ] , image . node ID ) } fingerprints : = [ ] string { } for fingerprint , ids : = range index { if len ( ids ) > 1 { continue } if ids [ 0 ] = = id { fingerprints = append ( fingerprints , fingerprint ) } } if len ( fingerprints ) > 0 { message : = fmt . Sprintf ( " " , strings . Join ( fingerprints , " " ) ) return message , nil } if err ! = nil { return " " , errors . Wrapf ( err , " " , id ) } if len ( volumes ) > 0 { message : = fmt . Sprintf ( " " , strings . Join ( volumes , " " ) ) return message , nil } return " " , nil } 
func ( c * Cluster Tx ) Node Clear ( id int 6 4 ) error { _ , err : = c . tx . Exec ( " " , id ) if err ! = nil { return err } if err ! = nil { return err } if err ! = nil { return err } if err ! = nil { return err } if count > 0 { continue } _ , err = c . tx . Exec ( " " , id ) if err ! = nil { return err } } return nil } 
func ( c * Cluster Tx ) Node Offline Threshold ( ) ( time . Duration , error ) { threshold : = time . Duration ( Default Offline Threshold ) * time . Second values , err : = query . Select Strings ( c . tx , " " ) if err ! = nil { return - 1 , err } if len ( values ) > 0 { seconds , err : = strconv . Atoi ( values [ 0 ] ) if err ! = nil { return - 1 , err } threshold = time . Duration ( seconds ) * time . Second } return threshold , nil } 
func ( c * Cluster Tx ) Node With Least Containers ( ) ( string , error ) { threshold , err : = c . Node Offline Threshold ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } nodes , err : = c . Nodes ( ) if err ! = nil { return " " , errors . Wrap ( err , " " ) } name : = " " containers : = - 1 for _ , node : = range nodes { if node . Is Offline ( threshold ) { continue } if err ! = nil { return " " , errors . Wrap ( err , " " ) } if err ! = nil { return " " , errors . Wrap ( err , " " ) } count : = created + pending if containers = = - 1 | | count < containers { containers = count name = node . Name } } return name , nil } 
func ( c * Cluster Tx ) Node Update Version ( id int 6 4 , version [ 2 ] int ) error { stmt : = " " result , err : = c . tx . Exec ( stmt , version [ 0 ] , version [ 1 ] , id ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " ) } return nil } 
func Transaction ( db * sql . DB , f func ( * sql . Tx ) error ) error { tx , err : = db . Begin ( ) if err ! = nil { return errors . Wrap ( err , " " ) } err = f ( tx ) if err ! = nil { return rollback ( tx , err ) } err = tx . Commit ( ) if err = = sql . Err Tx Done { err = nil } return err } 
func rollback ( tx * sql . Tx , reason error ) error { err : = tx . Rollback ( ) if err ! = nil { logger . Warnf ( " " , reason , err ) } return reason } 
func ( c * Cluster Tx ) Profile URIs ( filter Profile Filter ) ( [ ] string , error ) { if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( profile Names By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profile Names By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profile Names ) args = [ ] interface { } { } } code : = cluster . Entity Types [ " " ] formatter : = cluster . Entity Format URIs [ code ] return query . Select URIs ( stmt , formatter , args . . . ) } 
func ( c * Cluster Tx ) Profile List ( filter Profile Filter ) ( [ ] Profile , error ) { if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( profile Objects By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profile Objects By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profile Objects ) args = [ ] interface { } { } } return [ ] interface { } { & objects [ i ] . ID , & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Description , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = config Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] map [ string ] string { } config Objects [ objects [ i ] . Project ] = sub Index } value : = config Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = map [ string ] string { } } objects [ i ] . Config = value } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = devices Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] map [ string ] map [ string ] string { } devices Objects [ objects [ i ] . Project ] = sub Index } value : = devices Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = map [ string ] map [ string ] string { } } objects [ i ] . Devices = value } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for i : = range objects { _ , ok : = used By Objects [ objects [ i ] . Project ] if ! ok { sub Index : = map [ string ] [ ] string { } used By Objects [ objects [ i ] . Project ] = sub Index } value : = used By Objects [ objects [ i ] . Project ] [ objects [ i ] . Name ] if value = = nil { value = [ ] string { } } objects [ i ] . Used By = value } return objects , nil } 
func ( c * Cluster Tx ) Profile Get ( project string , name string ) ( * Profile , error ) { filter : = Profile Filter { } filter . Project = project filter . Name = name objects , err : = c . Profile List ( filter ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } switch len ( objects ) { case 0 : return nil , Err No Such Object case 1 : return & objects [ 0 ] , nil default : return nil , fmt . Errorf ( " " ) } } 
func ( c * Cluster Tx ) Profile Exists ( project string , name string ) ( bool , error ) { _ , err : = c . Profile ID ( project , name ) if err ! = nil { if err = = Err No Such Object { return false , nil } return false , err } return true , nil } 
func ( c * Cluster Tx ) Profile Config Ref ( filter Profile Filter ) ( map [ string ] map [ string ] map [ string ] string , error ) { Name string Key string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( profile Config Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profile Config Ref By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profile Config Ref ) args = [ ] interface { } { } } Name string Key string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Key , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] map [ string ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = map [ string ] string { } } index [ object . Project ] [ object . Name ] = item item [ object . Key ] = object . Value } return index , nil } 
func ( c * Cluster Tx ) Profile Devices Ref ( filter Profile Filter ) ( map [ string ] map [ string ] map [ string ] map [ string ] string , error ) { Name string Device string Type int Key string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( profile Devices Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profile Devices Ref By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profile Devices Ref ) args = [ ] interface { } { } } Name string Device string Type int Key string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Device , & objects [ i ] . Type , & objects [ i ] . Key , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] map [ string ] map [ string ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = map [ string ] map [ string ] string { } } index [ object . Project ] [ object . Name ] = item config , ok : = item [ object . Device ] if ! ok { if err ! = nil { return nil , errors . Wrapf ( err , " " , object . Type ) } config = map [ string ] string { } config [ " " ] = device Type item [ object . Device ] = config } if object . Key ! = " " { config [ object . Key ] = object . Value } } return index , nil } 
func ( c * Cluster Tx ) Profile Used By Ref ( filter Profile Filter ) ( map [ string ] map [ string ] [ ] string , error ) { Name string Value string } , 0 ) if filter . Project ! = " " { criteria [ " " ] = filter . Project } if filter . Name ! = " " { criteria [ " " ] = filter . Name } var args [ ] interface { } if criteria [ " " ] ! = nil & & criteria [ " " ] ! = nil { stmt = c . stmt ( profile Used By Ref By Project And Name ) args = [ ] interface { } { filter . Project , filter . Name , } } else if criteria [ " " ] ! = nil { stmt = c . stmt ( profile Used By Ref By Project ) args = [ ] interface { } { filter . Project , } } else { stmt = c . stmt ( profile Used By Ref ) args = [ ] interface { } { } } Name string Value string } { } ) return [ ] interface { } { & objects [ i ] . Project , & objects [ i ] . Name , & objects [ i ] . Value , } } if err ! = nil { return nil , errors . Wrap ( err , " " ) } for _ , object : = range objects { _ , ok : = index [ object . Project ] if ! ok { sub Index : = map [ string ] [ ] string { } index [ object . Project ] = sub Index } item , ok : = index [ object . Project ] [ object . Name ] if ! ok { item = [ ] string { } } index [ object . Project ] [ object . Name ] = append ( item , object . Value ) } return index , nil } 
func ( c * Cluster Tx ) Profile Create ( object Profile ) ( int 6 4 , error ) { if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } if exists { return - 1 , fmt . Errorf ( " " ) } args : = make ( [ ] interface { } , 3 ) args [ 1 ] = object . Name args [ 2 ] = object . Description if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } id , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } for key , value : = range object . Config { _ , err : = stmt . Exec ( id , key , value ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } if ! ok { return - 1 , fmt . Errorf ( " " , name ) } typ Code , err : = db Device Type To Int ( typ ) if err ! = nil { return - 1 , errors . Wrapf ( err , " " , typ ) } stmt = c . stmt ( profile Create Devices Ref ) result , err : = stmt . Exec ( id , name , typ Code ) if err ! = nil { return - 1 , errors . Wrapf ( err , " " , name ) } device ID , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } stmt = c . stmt ( profile Create Devices Config Ref ) for key , value : = range config { _ , err : = stmt . Exec ( device ID , key , value ) if err ! = nil { return - 1 , errors . Wrap ( err , " " ) } } } return id , nil } 
func ( c * Cluster Tx ) Profile Rename ( project string , name string , to string ) error { stmt : = c . stmt ( profile Rename ) result , err : = stmt . Exec ( to , project , name ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func ( c * Cluster Tx ) Profile Delete ( project string , name string ) error { stmt : = c . stmt ( profile Delete ) result , err : = stmt . Exec ( project , name ) if err ! = nil { return errors . Wrap ( err , " " ) } n , err : = result . Rows Affected ( ) if err ! = nil { return errors . Wrap ( err , " " ) } if n ! = 1 { return fmt . Errorf ( " " , n ) } return nil } 
func In Memory Network ( ) ( net . Listener , func ( ) net . Conn ) { listener : = & in Memory Listener { conns : make ( chan net . Conn , 1 6 ) , closed : make ( chan struct { } ) , } dialer : = func ( ) net . Conn { server , client : = net . Pipe ( ) listener . conns < - server return client } return listener , dialer } 
func ( l * in Memory Listener ) Accept ( ) ( net . Conn , error ) { select { case conn : = < - l . conns : return conn , nil case < - l . closed : return nil , fmt . Errorf ( " " ) } } 
func Canonical Network Address ( address string ) string { _ , _ , err : = net . Split Host Port ( address ) if err ! = nil { ip : = net . Parse IP ( address ) if ip ! = nil & & ip . To 4 ( ) = = nil { address = fmt . Sprintf ( " " , address , shared . Default Port ) } else { address = fmt . Sprintf ( " " , address , shared . Default Port ) } } return address } 
func Server TLSConfig ( cert * shared . Cert Info ) * tls . Config { config : = shared . Init TLSConfig ( ) config . Client Auth = tls . Request Client Cert config . Certificates = [ ] tls . Certificate { cert . Key Pair ( ) } config . Next Protos = [ ] string { " " } if cert . CA ( ) ! = nil { pool : = x 5 0 9 . New Cert Pool ( ) pool . Add Cert ( cert . CA ( ) ) config . Root CAs = pool config . Client CAs = pool logger . Infof ( " " ) } config . Build Name To Certificate ( ) return config } 
func Network Interface Address ( ) string { ifaces , err : = net . Interfaces ( ) if err ! = nil { return " " } for _ , iface : = range ifaces { if shared . Is Loopback ( & iface ) { continue } addrs , err : = iface . Addrs ( ) if err ! = nil { continue } if len ( addrs ) = = 0 { continue } addr , ok : = addrs [ 0 ] . ( * net . IPNet ) if ! ok { continue } return addr . IP . String ( ) } return " " } 
func Is Address Covered ( address 1 , address 2 string ) bool { if address 1 = = address 2 { return true } host 1 , port 1 , err : = net . Split Host Port ( address 1 ) if err ! = nil { return false } host 2 , port 2 , err : = net . Split Host Port ( address 2 ) if err ! = nil { return false } } if ip ! = nil & & ip . To 4 ( ) ! = nil { return true } return false } } return false } 
func Select Objects ( stmt * sql . Stmt , dest Dest , args . . . interface { } ) error { rows , err : = stmt . Query ( args . . . ) if err ! = nil { return err } defer rows . Close ( ) for i : = 0 ; rows . Next ( ) ; i + + { err : = rows . Scan ( dest ( i ) . . . ) if err ! = nil { return err } } err = rows . Err ( ) if err ! = nil { return err } return nil } 
func Upsert Object ( tx * sql . Tx , table string , columns [ ] string , values [ ] interface { } ) ( int 6 4 , error ) { n : = len ( columns ) if n = = 0 { return - 1 , fmt . Errorf ( " " ) } if n ! = len ( values ) { return - 1 , fmt . Errorf ( " " ) } stmt : = fmt . Sprintf ( " " , table , strings . Join ( columns , " " ) , Params ( n ) ) result , err : = tx . Exec ( stmt , values . . . ) if err ! = nil { return - 1 , err } id , err : = result . Last Insert Id ( ) if err ! = nil { return - 1 , err } return id , nil } 
func Delete Object ( tx * sql . Tx , table string , id int 6 4 ) ( bool , error ) { stmt : = fmt . Sprintf ( " " , table ) result , err : = tx . Exec ( stmt , id ) if err ! = nil { return false , err } n , err : = result . Rows Affected ( ) if err ! = nil { return false , err } if n > 1 { return true , fmt . Errorf ( " " ) } return n = = 1 , nil } 
func ( t * Task ) loop ( ctx context . Context ) { for { var timer < - chan time . Time schedule , err : = t . schedule ( ) switch err { case Err Skip : fallthrough case nil : } else { timer = make ( chan time . Time ) } default : } timer = time . After ( schedule ) } select { case < - timer : if err = = nil { delay = schedule } else { } case < - ctx . Done ( ) : return case < - t . reset : delay = immediately } } } 
func Is Terminal ( fd int ) bool { _ , err : = Get State ( fd ) return err = = nil } 
func Get State ( fd int ) ( * State , error ) { termios : = syscall . Termios { } ret , err : = C . tcgetattr ( C . int ( fd ) , ( * C . struct _termios ) ( unsafe . Pointer ( & termios ) ) ) if ret ! = 0 { return nil , err . ( syscall . Errno ) } state : = State { } state . Termios = termios return & state , nil } 
func Make Raw ( fd int ) ( * State , error ) { var err error var old State , new State * State old State , err = Get State ( fd ) if err ! = nil { return nil , err } err = shared . Deep Copy ( & old State , & new State ) if err ! = nil { return nil , err } C . cfmakeraw ( ( * C . struct _termios ) ( unsafe . Pointer ( & new State . Termios ) ) ) err = Restore ( fd , new State ) if err ! = nil { return nil , err } return old State , nil } 
func Restore ( fd int , state * State ) error { ret , err : = C . tcsetattr ( C . int ( fd ) , C . TCSANOW , ( * C . struct _termios ) ( unsafe . Pointer ( & state . Termios ) ) ) if ret ! = 0 { return err . ( syscall . Errno ) } return nil } 
func socket Unix Listen ( path string ) ( net . Listener , error ) { addr , err : = net . Resolve Unix Addr ( " " , path ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } listener , err : = net . Listen Unix ( " " , addr ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return listener , err } 
func Check Already Running ( path string ) error { if err = = nil { if pid = = os . Getpid ( ) { return nil } } } _ , err = lxd . Connect LXDUnix ( path , nil ) } return nil } 
func socket Unix Remove Stale ( path string ) error { } logger . Debugf ( " " ) err : = os . Remove ( path ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func socket Unix Set Permissions ( path string , mode os . File Mode ) error { err : = os . Chmod ( path , mode ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func socket Unix Set Ownership ( path string , group string ) error { var gid int var err error if group ! = " " { gid , err = shared . Group Id ( group ) if err ! = nil { return fmt . Errorf ( " " , group , err ) } } else { gid = os . Getgid ( ) } err = os . Chown ( path , os . Getuid ( ) , gid ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ceph OSDPool Exists ( Cluster Name string , pool Name string , user Name string ) bool { _ , err : = shared . Run Command ( " " , " " , fmt . Sprintf ( " " , user Name ) , " " , Cluster Name , " " , " " , " " , pool Name , " " ) if err ! = nil { return false } return true } 
func ceph OSDPool Destroy ( cluster Name string , pool Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , fmt . Sprintf ( " " , user Name ) , " " , cluster Name , " " , " " , " " , pool Name , pool Name , " " ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Create ( cluster Name string , pool Name string , volume Name string , volume Type string , size string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , " " , " " , cluster Name , " " , pool Name , " " , size , " " , fmt . Sprintf ( " " , volume Type , volume Name ) ) return err } 
func ceph RBDVolume Exists ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string ) bool { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , " " , fmt . Sprintf ( " " , volume Type , volume Name ) ) if err ! = nil { return false } return true } 
func ceph RBDVolume Map ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string ) ( string , error ) { dev Path , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , fmt . Sprintf ( " " , volume Type , volume Name ) ) if err ! = nil { return " " , err } idx : = strings . Index ( dev Path , " " ) if idx < 0 { return " " , fmt . Errorf ( " " ) } dev Path = dev Path [ idx : ] return strings . Trim Space ( dev Path ) , nil } 
func ceph RBDSnapshot Protect ( cluster Name string , pool Name string , volume Name string , volume Type string , snapshot Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , " " , " " , snapshot Name , fmt . Sprintf ( " " , volume Type , volume Name ) ) if err ! = nil { run Error , ok : = err . ( shared . Run Error ) if ok { exit Error , ok : = run Error . Err . ( * exec . Exit Error ) if ok { wait Status : = exit Error . Sys ( ) . ( syscall . Wait Status ) if wait Status . Exit Status ( ) = = 1 6 { } } } return err } return nil } 
func ceph RBDClone Create ( source Cluster Name string , source Pool Name string , source Volume Name string , source Volume Type string , source Snapshot Name string , target Pool Name string , target Volume Name string , target Volume Type string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , source Cluster Name , " " , " " , " " , fmt . Sprintf ( " " , source Pool Name , source Volume Type , source Volume Name , source Snapshot Name ) , fmt . Sprintf ( " " , target Pool Name , target Volume Type , target Volume Name ) ) if err ! = nil { return err } return nil } 
func ceph RBDSnapshot List Clones ( cluster Name string , pool Name string , volume Name string , volume Type string , snapshot Name string , user Name string ) ( [ ] string , error ) { msg , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , " " , fmt . Sprintf ( " " , volume Type , volume Name ) , " " , snapshot Name ) if err ! = nil { return nil , err } msg = strings . Trim Space ( msg ) clones : = strings . Fields ( msg ) if len ( clones ) = = 0 { return nil , db . Err No Such Object } return clones , nil } 
func ceph RBDVolume Mark Deleted ( cluster Name string , pool Name string , volume Type string , old Volume Name string , new Volume Name string , user Name string , suffix string ) error { deleted Name : = fmt . Sprintf ( " " , pool Name , volume Type , new Volume Name ) if suffix ! = " " { deleted Name = fmt . Sprintf ( " " , deleted Name , suffix ) } _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , fmt . Sprintf ( " " , pool Name , volume Type , old Volume Name ) , deleted Name ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Unmark Deleted ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string , old Suffix string , new Suffix string ) error { old Name : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name ) if old Suffix ! = " " { old Name = fmt . Sprintf ( " " , old Name , old Suffix ) } new Name : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name ) if new Suffix ! = " " { new Name = fmt . Sprintf ( " " , new Name , new Suffix ) } _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , old Name , new Name ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Rename ( cluster Name string , pool Name string , volume Type string , old Volume Name string , new Volume Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , fmt . Sprintf ( " " , pool Name , volume Type , old Volume Name ) , fmt . Sprintf ( " " , pool Name , volume Type , new Volume Name ) ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Snapshot Rename ( cluster Name string , pool Name string , volume Name string , volume Type string , old Snapshot Name string , new Snapshot Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , " " , fmt . Sprintf ( " " , pool Name , volume Type , volume Name , old Snapshot Name ) , fmt . Sprintf ( " " , pool Name , volume Type , volume Name , new Snapshot Name ) ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Get Parent ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string ) ( string , error ) { msg , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , fmt . Sprintf ( " " , volume Type , volume Name ) ) if err ! = nil { return " " , err } idx : = strings . Index ( msg , " " ) if idx = = - 1 { return " " , db . Err No Such Object } msg = msg [ ( idx + len ( " " ) ) : ] msg = strings . Trim Space ( msg ) idx = strings . Index ( msg , " \n " ) if idx = = - 1 { return " " , fmt . Errorf ( " " ) } msg = msg [ : idx ] msg = strings . Trim Space ( msg ) return msg , nil } 
func ceph RBDSnapshot Delete ( cluster Name string , pool Name string , volume Name string , volume Type string , snapshot Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , pool Name , " " , " " , fmt . Sprintf ( " " , volume Type , volume Name , snapshot Name ) ) if err ! = nil { return err } return nil } 
func ceph RBDVolume Copy ( cluster Name string , old Volume Name string , new Volume Name string , user Name string ) error { _ , err : = shared . Run Command ( " " , " " , user Name , " " , cluster Name , " " , old Volume Name , new Volume Name ) if err ! = nil { return err } return nil } 
func ceph RBDVolume List Snapshots ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string ) ( [ ] string , error ) { msg , err : = shared . Run Command ( " " , " " , user Name , " " , " " , " " , cluster Name , " " , pool Name , " " , " " , fmt . Sprintf ( " " , volume Type , volume Name ) ) if err ! = nil { return [ ] string { } , err } var data [ ] map [ string ] interface { } err = json . Unmarshal ( [ ] byte ( msg ) , & data ) if err ! = nil { return [ ] string { } , err } snapshots : = [ ] string { } for _ , v : = range data { _ , ok : = v [ " " ] if ! ok { return [ ] string { } , fmt . Errorf ( " \ " \ " " ) } name , ok : = v [ " " ] . ( string ) if ! ok { return [ ] string { } , fmt . Errorf ( " \ " \ " " ) } name = strings . Trim Space ( name ) snapshots = append ( snapshots , name ) } if len ( snapshots ) = = 0 { return [ ] string { } , db . Err No Such Object } return snapshots , nil } 
func ( s * storage Ceph ) get RBDSize ( ) ( string , error ) { sz , err : = shared . Parse Byte Size String ( s . volume . Config [ " " ] ) if err ! = nil { return " " , err } } return fmt . Sprintf ( " " , sz ) , nil } 
func ( s * storage Ceph ) get RBDFilesystem ( ) string { if s . volume . Config [ " " ] ! = " " { return s . volume . Config [ " " ] } if s . pool . Config [ " " ] ! = " " { return s . pool . Config [ " " ] } return " " } 
func ( s * storage Ceph ) copy Without Snapshots Full ( target container , source container ) error { logger . Debugf ( `Creating non -sparse copy of RBD storage volume for container " %s " to " %s " without snapshots ` , source . Name ( ) , target . Name ( ) ) source Is Snapshot : = source . Is Snapshot ( ) source Container Name : = project Prefix ( source . Project ( ) , source . Name ( ) ) target Container Name : = project Prefix ( target . Project ( ) , target . Name ( ) ) old Volume Name : = fmt . Sprintf ( " " , s . OSDPool Name , source Container Name ) new Volume Name : = fmt . Sprintf ( " " , s . OSDPool Name , target Container Name ) if source Is Snapshot { source Container Only Name , source Snapshot Only Name , _ : = container Get Parent And Snapshot Name ( source Container Name ) old Volume Name = fmt . Sprintf ( " " , s . OSDPool Name , source Container Only Name , source Snapshot Only Name ) } err : = ceph RBDVolume Copy ( s . Cluster Name , old Volume Name , new Volume Name , s . User Name ) if err ! = nil { logger . Debugf ( `Failed to create full RBD copy " %s " to " %s " : %s ` , source . Name ( ) , target . Name ( ) , err ) return err } _ , err = ceph RBDVolume Map ( s . Cluster Name , s . OSDPool Name , target Container Name , storage Pool Volume Type Name Container , s . User Name ) if err ! = nil { logger . Errorf ( `Failed to map RBD storage volume for image " %s " on storage pool " %s " : %s ` , target Container Name , s . pool . Name , err ) return err } target Container Mount Point : = get Container Mount Point ( target . Project ( ) , s . pool . Name , target . Name ( ) ) err = create Container Mountpoint ( target Container Mount Point , target . Path ( ) , target . Is Privileged ( ) ) if err ! = nil { return err } our Mount , err : = target . Storage Start ( ) if err ! = nil { return err } if our Mount { defer target . Storage Stop ( ) } err = target . Template Apply ( " " ) if err ! = nil { logger . Errorf ( `Failed to apply copy template for container " %s " : %s ` , target . Name ( ) , err ) return err } logger . Debugf ( `Applied copy template for container " %s " ` , target . Name ( ) ) logger . Debugf ( `Created non -sparse copy of RBD storage volume for container " %s " to " %s " without snapshots ` , source . Name ( ) , target . Name ( ) ) return nil } 
func ( s * storage Ceph ) copy Without Snapshots Sparse ( target container , source container ) error { logger . Debugf ( `Creating sparse copy of RBD storage volume for container " %s " to " %s " without snapshots ` , source . Name ( ) , target . Name ( ) ) source Is Snapshot : = source . Is Snapshot ( ) source Container Name : = project Prefix ( source . Project ( ) , source . Name ( ) ) target Container Name : = project Prefix ( target . Project ( ) , target . Name ( ) ) source Container Only Name : = source Container Name source Snapshot Only Name : = " " snapshot Name : = fmt . Sprintf ( " " , uuid . New Random ( ) . String ( ) ) if source Is Snapshot { source Container Only Name , source Snapshot Only Name , _ = container Get Parent And Snapshot Name ( source Container Name ) snapshot Name = fmt . Sprintf ( " " , source Snapshot Only Name ) } else { if err ! = nil { logger . Errorf ( `Failed to create snapshot for RBD storage volume for image " %s " on storage pool " %s " : %s ` , target Container Name , s . pool . Name , err ) return err } } if err ! = nil { logger . Errorf ( `Failed to protect snapshot for RBD storage volume for image " %s " on storage pool " %s " : %s ` , snapshot Name , s . pool . Name , err ) return err } err = ceph RBDClone Create ( s . Cluster Name , s . OSDPool Name , source Container Only Name , storage Pool Volume Type Name Container , snapshot Name , s . OSDPool Name , target Container Name , storage Pool Volume Type Name Container , s . User Name ) if err ! = nil { logger . Errorf ( `Failed to clone new RBD storage volume for container " %s " : %s ` , target Container Name , err ) return err } if err ! = nil { return err } err = create Container Mountpoint ( target Container Mount Point , target . Path ( ) , target . Is Privileged ( ) ) if err ! = nil { return err } our Mount , err : = target . Storage Start ( ) if err ! = nil { return err } if our Mount { defer target . Storage Stop ( ) } err = target . Template Apply ( " " ) if err ! = nil { logger . Errorf ( `Failed to apply copy template for container " %s " : %s ` , target . Name ( ) , err ) return err } logger . Debugf ( `Applied copy template for container " %s " ` , target . Name ( ) ) logger . Debugf ( `Created sparse copy of RBD storage volume for container " %s " to " %s " without snapshots ` , source . Name ( ) , target . Name ( ) ) return nil } 
func ( s * storage Ceph ) copy With Snapshots ( source Volume Name string , target Volume Name string , source Parent Snapshot string ) error { logger . Debugf ( `Creating non -sparse copy of RBD storage volume " %s to " %s " ` , source Volume Name , target Volume Name ) args : = [ ] string { " " , " " , s . User Name , " " , s . Cluster Name , source Volume Name , } if source Parent Snapshot ! = " " { args = append ( args , " " , source Parent Snapshot ) } / / redirect output to stdout args = append ( args , " " ) rbd Send Cmd : = exec . Command ( " " , args . . . ) rbd Recv Cmd : = exec . Command ( " " , " " , s . User Name , " " , " " , s . Cluster Name , " " , target Volume Name ) rbd Recv Cmd . Stdin , _ = rbd Send Cmd . Stdout Pipe ( ) rbd Recv Cmd . Stdout = os . Stdout rbd Recv Cmd . Stderr = os . Stderr err : = rbd Recv Cmd . Start ( ) if err ! = nil { return err } err = rbd Send Cmd . Run ( ) if err ! = nil { return err } err = rbd Recv Cmd . Wait ( ) if err ! = nil { return err } logger . Debugf ( `Created non -sparse copy of RBD storage volume " %s " to " %s " ` , source Volume Name , target Volume Name ) return nil } 
func ceph Container Delete ( cluster Name string , pool Name string , volume Name string , volume Type string , user Name string ) int { log Entry : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name ) snaps , err : = ceph RBDVolume List Snapshots ( cluster Name , pool Name , volume Name , volume Type , user Name ) if err = = nil { var zombies int for _ , snap : = range snaps { log Entry : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name , snap ) ret : = ceph Container Snapshot Delete ( cluster Name , pool Name , volume Name , volume Type , snap , user Name ) if ret < 0 { logger . Errorf ( `Failed to delete RBD storage volume " %s " ` , log Entry ) return - 1 } else if ret = = 1 { logger . Debugf ( `Marked RBD storage volume " %s " as zombie ` , log Entry ) zombies + + } else { logger . Debugf ( `Deleted RBD storage volume " %s " ` , log Entry ) } } if zombies > 0 { if err ! = nil { logger . Errorf ( `Failed to unmap RBD storage volume " %s " : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Unmapped RBD storage volume " %s " ` , log Entry ) if strings . Has Prefix ( volume Type , " " ) { logger . Debugf ( `RBD storage volume " %s " already marked as zombie ` , log Entry ) return 1 } new Volume Name : = fmt . Sprintf ( " " , volume Name , uuid . New Random ( ) . String ( ) ) err : = ceph RBDVolume Mark Deleted ( cluster Name , pool Name , volume Type , volume Name , new Volume Name , user Name , " " ) if err ! = nil { logger . Errorf ( `Failed to mark RBD storage volume " %s " as zombie : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Marked RBD storage volume " %s " as zombie ` , log Entry ) return 1 } } else { if err ! = db . Err No Such Object { logger . Errorf ( `Failed to retrieve snapshots of RBD storage volume : %s ` , err ) return - 1 } parent , err : = ceph RBDVolume Get Parent ( cluster Name , pool Name , volume Name , volume Type , user Name ) if err = = nil { logger . Debugf ( `Detected " %s " as parent of RBD storage volume " %s " ` , parent , log Entry ) _ , parent Volume Type , parent Volume Name , parent Snapshot Name , err : = parse Parent ( parent ) if err ! = nil { logger . Errorf ( `Failed to parse parent " %s " of RBD storage volume " %s " ` , parent , log Entry ) return - 1 } logger . Debugf ( `Split parent " %s " of RBD storage volume " %s " into volume type " %s " , volume name " %s " , and snapshot name " %s " ` , parent , log Entry , parent Volume Type , parent Volume Name , parent Snapshot Name ) if err ! = nil { logger . Errorf ( `Failed to unmap RBD storage volume " %s " : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Unmapped RBD storage volume " %s " ` , log Entry ) if err ! = nil { logger . Errorf ( `Failed to delete RBD storage volume " %s " : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Deleted RBD storage volume " %s " ` , log Entry ) if ret < 0 { logger . Errorf ( `Failed to delete snapshot " %s " of RBD storage volume " %s " ` , parent Snapshot Name , log Entry ) return - 1 } logger . Debugf ( `Deleteed snapshot " %s " of RBD storage volume " %s " ` , parent Snapshot Name , log Entry ) } return 0 } else { if err ! = db . Err No Such Object { logger . Errorf ( `Failed to retrieve parent of RBD storage volume " %s " ` , log Entry ) return - 1 } logger . Debugf ( `RBD storage volume " %s " does not have parent ` , log Entry ) if err ! = nil { logger . Errorf ( `Failed to unmap RBD storage volume " %s " : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Unmapped RBD storage volume " %s " ` , log Entry ) if err ! = nil { logger . Errorf ( `Failed to delete RBD storage volume " %s " : %s ` , log Entry , err ) return - 1 } logger . Debugf ( `Deleted RBD storage volume " %s " ` , log Entry ) } } return 0 } 
func ceph Container Snapshot Delete ( cluster Name string , pool Name string , volume Name string , volume Type string , snapshot Name string , user Name string ) int { log Image Entry : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name ) log Snapshot Entry : = fmt . Sprintf ( " " , pool Name , volume Type , volume Name , snapshot Name ) clones , err : = ceph RBDSnapshot List Clones ( cluster Name , pool Name , volume Name , volume Type , snapshot Name , user Name ) if err ! = nil { if err ! = db . Err No Such Object { logger . Errorf ( `Failed to list clones of RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `RBD snapshot " %s " of RBD storage volume " %s " does not have any clones ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to unprotect RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Unprotected RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to unmap RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Unmapped RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to delete RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Deleted RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if ret < 0 { logger . Errorf ( `Failed to delete RBD storage volume " %s " ` , log Image Entry ) return - 1 } logger . Debugf ( `Deleted RBD storage volume " %s " ` , log Image Entry ) } return 0 } else { logger . Debugf ( `Detected " %v " as clones of RBD snapshot " %s " of RBD storage volume " %s " ` , clones , log Snapshot Entry , log Image Entry ) can Delete : = true for _ , clone : = range clones { clone Pool , clone Type , clone Name , err : = parse Clone ( clone ) if err ! = nil { logger . Errorf ( `Failed to parse clone " %s " of RBD snapshot " %s " of RBD storage volume " %s " ` , clone , log Snapshot Entry , log Image Entry ) return - 1 } logger . Debugf ( `Split clone " %s " of RBD snapshot " %s " of RBD storage volume " %s " into pool name " %s " , volume type " %s " , and volume name " %s " ` , clone , log Snapshot Entry , log Image Entry , clone Pool , clone Type , clone Name ) if ! strings . Has Prefix ( clone Type , " " ) { can Delete = false continue } ret : = ceph Container Delete ( cluster Name , clone Pool , clone Name , clone Type , user Name ) if ret < 0 { logger . Errorf ( `Failed to delete clone " %s " of RBD snapshot " %s " of RBD storage volume " %s " ` , clone , log Snapshot Entry , log Image Entry ) return - 1 } else if ret = = 1 { } } if can Delete { logger . Debugf ( `Deleted all clones of RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to unprotect RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Unprotected RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to unmap RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Unmapped RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if err ! = nil { logger . Errorf ( `Failed to delete RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debugf ( `Deleted RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if ret < 0 { logger . Errorf ( `Failed to delete RBD storage volume " %s " ` , log Image Entry ) return - 1 } logger . Debugf ( `Deleted RBD storage volume " %s " ` , log Image Entry ) } } else { logger . Debugf ( `Could not delete all clones of RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) if strings . Has Prefix ( snapshot Name , " " ) { return 1 } err : = ceph RBDVolume Snapshot Unmap ( cluster Name , pool Name , volume Name , volume Type , snapshot Name , user Name , true ) if err ! = nil { logger . Errorf ( `Failed to unmap RBD snapshot " %s " of RBD storage volume " %s " : %s ` , log Snapshot Entry , log Image Entry , err ) return - 1 } logger . Debug ( `Unmapped RBD snapshot " %s " of RBD storage volume " %s " ` , log Snapshot Entry , log Image Entry ) new Snapshot Name : = fmt . Sprintf ( " " , snapshot Name ) log Snapshot New Entry : = fmt . Sprintf ( " " , pool Name , volume Name , volume Type , new Snapshot Name ) err = ceph RBDVolume Snapshot Rename ( cluster Name , pool Name , volume Name , volume Type , snapshot Name , new Snapshot Name , user Name ) if err ! = nil { logger . Errorf ( `Failed to rename RBD snapshot " %s " of RBD storage volume " %s " to %s ` , log Snapshot Entry , log Image Entry , log Snapshot New Entry ) return - 1 } logger . Debugf ( `Renamed RBD snapshot " %s " of RBD storage volume " %s " to %s ` , log Snapshot Entry , log Image Entry , log Snapshot New Entry ) } } return 1 } 
func parse Parent ( parent string ) ( string , string , string , string , error ) { idx : = strings . Index ( parent , " " ) if idx = = - 1 { return " " , " " , " " , " " , fmt . Errorf ( " " ) } slider : = parent [ ( idx + 1 ) : ] pool Name : = parent [ : idx ] volume Type : = slider idx = strings . Index ( slider , " " ) if idx = = 0 { idx + = len ( " " ) volume Type = slider slider = slider [ idx : ] } idx Type : = strings . Index ( slider , " " ) if idx Type = = - 1 { return " " , " " , " " , " " , fmt . Errorf ( " " ) } if idx = = len ( " " ) { idx Type + = idx } volume Type = volume Type [ : idx Type ] idx = strings . Index ( slider , " " ) if idx = = - 1 { return " " , " " , " " , " " , fmt . Errorf ( " " ) } volume Name : = slider idx = strings . Index ( volume Name , " " ) if idx = = - 1 { return " " , " " , " " , " " , fmt . Errorf ( " " ) } volume Name = volume Name [ ( idx + 1 ) : ] idx = strings . Index ( volume Name , " " ) if idx = = - 1 { return " " , " " , " " , " " , fmt . Errorf ( " " ) } snapshot Name : = volume Name [ ( idx + 1 ) : ] volume Name = volume Name [ : idx ] return pool Name , volume Type , volume Name , snapshot Name , nil } 
func parse Clone ( clone string ) ( string , string , string , error ) { idx : = strings . Index ( clone , " " ) if idx = = - 1 { return " " , " " , " " , fmt . Errorf ( " " ) } slider : = clone [ ( idx + 1 ) : ] pool Name : = clone [ : idx ] volume Type : = slider idx = strings . Index ( slider , " " ) if idx = = 0 { idx + = len ( " " ) volume Type = slider slider = slider [ idx : ] } idx Type : = strings . Index ( slider , " " ) if idx Type = = - 1 { return " " , " " , " " , fmt . Errorf ( " " ) } if idx = = len ( " " ) { idx Type + = idx } volume Type = volume Type [ : idx Type ] idx = strings . Index ( slider , " " ) if idx = = - 1 { return " " , " " , " " , fmt . Errorf ( " " ) } volume Name : = slider idx = strings . Index ( volume Name , " " ) if idx = = - 1 { return " " , " " , " " , fmt . Errorf ( " " ) } volume Name = volume Name [ ( idx + 1 ) : ] return pool Name , volume Type , volume Name , nil } 
func get RBDMapped Dev Path ( cluster Name string , pool Name string , volume Type string , volume Name string , do Map bool , user Name string ) ( string , int ) { files , err : = ioutil . Read Dir ( " " ) if err ! = nil { if os . Is Not Exist ( err ) { if do Map { goto map Image } return " " , 0 } return " " , - 1 } for _ , f : = range files { if ! f . Is Dir ( ) { continue } f Name : = f . Name ( ) idx , err : = strconv . Parse Uint ( f Name , 1 0 , 6 4 ) if err ! = nil { continue } tmp : = fmt . Sprintf ( " " , f Name ) contents , err : = ioutil . Read File ( tmp ) if err ! = nil { if os . Is Not Exist ( err ) { continue } return " " , - 1 } detected Pool Name : = strings . Trim Space ( string ( contents ) ) if detected Pool Name ! = pool Name { continue } tmp = fmt . Sprintf ( " " , f Name ) contents , err = ioutil . Read File ( tmp ) if err ! = nil { if os . Is Not Exist ( err ) { continue } return " " , - 1 } typed Volume Name : = fmt . Sprintf ( " " , volume Type , volume Name ) detected Volume Name : = strings . Trim Space ( string ( contents ) ) if detected Volume Name ! = typed Volume Name { continue } tmp = fmt . Sprintf ( " " , f Name ) contents , err = ioutil . Read File ( tmp ) if err ! = nil { if os . Is Not Exist ( err ) { return fmt . Sprintf ( " " , idx ) , 1 } return " " , - 1 } detected Snap Name : = strings . Trim Space ( string ( contents ) ) if detected Snap Name ! = " " { continue } return fmt . Sprintf ( " " , idx ) , 1 } if ! do Map { return " " , 0 } map Image : dev Path , err : = ceph RBDVolume Map ( cluster Name , pool Name , volume Name , volume Type , user Name ) if err ! = nil { return " " , - 1 } return strings . Trim Space ( dev Path ) , 2 } 
func ( s * storage Ceph ) ceph RBDVolume Dump To File ( source Volume Name string , file string ) error { logger . Debugf ( `Dumping RBD storage volume " %s " to " %s " ` , source Volume Name , file ) args : = [ ] string { " " , " " , s . User Name , " " , s . Cluster Name , source Volume Name , file , } rbd Send Cmd : = exec . Command ( " " , args . . . ) err : = rbd Send Cmd . Run ( ) if err ! = nil { return err } logger . Debugf ( `Dumped RBD storage volume " %s " to " %s " ` , source Volume Name , file ) return nil } 
func ( s * storage Ceph ) ceph RBDVolume Backup Create ( tmp Path string , backup backup , source container ) error { source Is Snapshot : = source . Is Snapshot ( ) source Container Name : = source . Name ( ) source Container Only Name : = project Prefix ( source . Project ( ) , source Container Name ) source Snapshot Only Name : = " " if err ! = nil { return fmt . Errorf ( " " , string ( output ) , err ) } return nil } bwlimit : = s . pool . Config [ " " ] if source Is Snapshot { source Container Only Name , source Snapshot Only Name , _ = container Get Parent And Snapshot Name ( source Container Name ) source Container Only Name = project Prefix ( source . Project ( ) , source Container Only Name ) snapshot Name = fmt . Sprintf ( " " , project Prefix ( source . Project ( ) , source Snapshot Only Name ) ) } else { if err ! = nil { return err } defer ceph RBDSnapshot Delete ( s . Cluster Name , s . OSDPool Name , source Container Only Name , storage Pool Volume Type Name Container , snapshot Name , s . User Name ) } if err ! = nil { return err } defer ceph RBDSnapshot Unprotect ( s . Cluster Name , s . OSDPool Name , source Container Only Name , storage Pool Volume Type Name Container , snapshot Name , s . User Name ) err = ceph RBDClone Create ( s . Cluster Name , s . OSDPool Name , source Container Only Name , storage Pool Volume Type Name Container , snapshot Name , s . OSDPool Name , clone Name , " " , s . User Name ) if err ! = nil { return err } defer ceph RBDVolume Delete ( s . Cluster Name , s . OSDPool Name , clone Name , " " , s . User Name ) if err ! = nil { return err } defer ceph RBDVolume Unmap ( s . Cluster Name , s . OSDPool Name , clone Name , " " , s . User Name , true ) msg , err : = fs Generate New UUID ( RBDFilesystem , RBDDev Path ) if err ! = nil { logger . Errorf ( " \ " \ " " , RBDFilesystem , msg , err ) return err } if err ! = nil { return err } defer os . Remove All ( tmp Container Mnt Point ) err = os . Chmod ( tmp Container Mnt Point , 0 7 0 0 ) if err ! = nil { return err } err = try Mount ( RBDDev Path , tmp Container Mnt Point , RBDFilesystem , mount Flags , mount Options ) if err ! = nil { logger . Errorf ( " " , RBDDev Path , tmp Container Mnt Point , err ) return err } logger . Debugf ( " " , RBDDev Path , tmp Container Mnt Point ) defer try Unmount ( tmp Container Mnt Point , syscall . MNT _DETACH ) if source Is Snapshot { _ , target Name , _ = container Get Parent And Snapshot Name ( source Container Name ) } if source Is Snapshot { target Backup Mnt Point = fmt . Sprintf ( " " , tmp Path , target Name ) } err = os . Mkdir All ( target Backup Mnt Point , 0 7 1 1 ) if err ! = nil { return err } err = rsync ( tmp Container Mnt Point , target Backup Mnt Point , bwlimit ) if err ! = nil { return err } return nil } 
func ( s * storage Ceph ) ceph RBDGenerate UUID ( volume Name string , volume Type string ) error { if err ! = nil { return err } defer ceph RBDVolume Unmap ( s . Cluster Name , s . OSDPool Name , volume Name , volume Type , s . User Name , true ) if err ! = nil { return fmt . Errorf ( " " , volume Name , err , msg ) } return nil } 
func Get Config Cmd ( no Port Forwarding * bool ) * cobra . Command { var format string get Config : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( true , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) resp , err : = c . Get Configuration ( c . Ctx ( ) , & auth . Get Configuration Request { } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if resp . Configuration = = nil { fmt . Println ( " " ) return nil } output , err : = json . Marshal Indent ( resp . Configuration , " " , " " ) if err ! = nil { return fmt . Errorf ( " \n \n " , resp . Configuration , err ) } switch format { case " " : if err ! = nil { return fmt . Errorf ( " " , err ) } default : return fmt . Errorf ( " " , format ) } fmt . Println ( string ( output ) ) return nil } ) , } get Config . Flags ( ) . String Var P ( & format , " " , " " , " " , " " + " \ " \ " \ " \ " " ) return cmdutil . Create Alias ( get Config , " " ) } 
func Set Config Cmd ( no Port Forwarding * bool ) * cobra . Command { var file string set Config : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( true , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) var config Bytes [ ] byte if file = = " " { var err error config Bytes , err = ioutil . Read All ( os . Stdin ) if err ! = nil { return fmt . Errorf ( " " , err ) } } else if file ! = " " { var err error config Bytes , err = ioutil . Read File ( file ) if err ! = nil { return fmt . Errorf ( " " , file , err ) } } else { return errors . New ( " \ " \ " " ) } if err : = yaml . Unmarshal ( config Bytes , & config ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return grpcutil . Scrub GRPC ( err ) } ) , } set Config . Flags ( ) . String Var P ( & file , " " , " " , " " , " " + " " ) return cmdutil . Create Alias ( set Config , " " ) } 
func New Sharder ( discovery Client discovery . Client , num Shards uint 6 4 , namespace string ) Sharder { return new Sharder ( discovery Client , num Shards , namespace ) } 
func New Router ( sharder Sharder , dialer grpcutil . Dialer , local Address string , ) Router { return new Router ( sharder , dialer , local Address , ) } 
func Pachctl Cmd ( ) * cobra . Command { var verbose bool var no Metrics bool var no Port Forwarding bool raw : = false raw Flags : = pflag . New Flag Set ( " " , pflag . Continue On Error ) raw Flags . Bool Var ( & raw , " " , false , " " ) marshaller : = & jsonpb . Marshaler { Indent : " " } root Cmd : = & cobra . Command { Use : os . Args [ 0 ] , Long : `Access the Pachyderm API . Environment variables : PACHD _ADDRESS = <host > : <port > , the pachd server to connect to (e .g . 1 2 7 . 0 . 0 . 1 : 3 0 6 5 0 ) . PACH _CONFIG = <path > , the path where pachctl will attempt to load your pach config . JAEGER _ENDPOINT = <host > : <port > , the Jaeger server to connect to , if PACH _ENABLE _TRACING is set PACH _ENABLE _TRACING = {true ,false } , If true , and JAEGER _ENDPOINT is set , attach a Jaeger trace to all outgoing RPCs ` , Persistent Pre Run : func ( cmd * cobra . Command , args [ ] string ) { log . Set Formatter ( new ( prefixed . Text Formatter ) ) if ! verbose { log . Set Level ( log . Error Level ) } else { log . Set Level ( log . Debug Level ) etcd . Set Logger ( grpclog . New Logger V 2 ( logutil . New GRPCLog Writer ( logger , " " ) , ioutil . Discard , ioutil . Discard , ) ) } } , Bash Completion Function : bash Completion Func , } root Cmd . Persistent Flags ( ) . Bool Var P ( & verbose , " " , " " , false , " " ) root Cmd . Persistent Flags ( ) . Bool Var P ( & no Metrics , " " , " " , false , " " ) root Cmd . Persistent Flags ( ) . Bool Var P ( & no Port Forwarding , " " , " " , false , " " ) var subcommands [ ] * cobra . Command var client Only bool var timeout Flag string version Cmd : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { if client Only { if raw { if err : = marshaller . Marshal ( os . Stdout , version . Version ) ; err ! = nil { return err } } else { fmt . Println ( version . Pretty Print Version ( version . Version ) ) } return nil } if ! no Metrics { start : = time . Now ( ) start Metrics Wait : = metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } if raw { if err : = marshaller . Marshal ( os . Stdout , version . Version ) ; err ! = nil { return err } } else { print Version Header ( writer ) print Version ( writer , " " , version . Version ) if err : = writer . Flush ( ) ; err ! = nil { return err } } var err error if timeout Flag ! = " " { var timeout time . Duration timeout , err = time . Parse Duration ( timeout Flag ) if err ! = nil { return fmt . Errorf ( " " , timeout , err ) } pach Client , err = client . New On User Machine ( false , ! no Port Forwarding , " " , client . With Dial Timeout ( timeout ) ) } else { pach Client , err = client . New On User Machine ( false , ! no Port Forwarding , " " ) } if err ! = nil { return err } defer pach Client . Close ( ) ctx , cancel : = context . With Timeout ( context . Background ( ) , time . Second ) defer cancel ( ) version , err : = pach Client . Get Version ( ctx , & types . Empty { } ) if err ! = nil { buf : = bytes . New Buffer String ( " " ) err Writer : = ansiterm . New Tab Writer ( buf , 2 0 , 1 , 3 , ' ' , 0 ) fmt . Fprintf ( err Writer , " \t \n \n \n " , pach Client . Get Address ( ) , grpc . Error Desc ( err ) ) err Writer . Flush ( ) return errors . New ( buf . String ( ) ) } } } else { print Version ( writer , " " , version ) if err : = writer . Flush ( ) ; err ! = nil { return err } } return nil } ) , } version Cmd . Flags ( ) . Bool Var ( & client Only , " " , false , " " + " " + " " ) version Cmd . Flags ( ) . String Var ( & timeout Flag , " " , " " , " " + " " + " " + " " + " " ) version Cmd . Flags ( ) . Add Flag Set ( raw Flags ) subcommands = append ( subcommands , cmdutil . Create Alias ( version Cmd , " " ) ) delete All : = & cobra . Command { Short : " " , Long : `Delete all repos , commits , files , pipelines and jobs . This resets the cluster to its initial state . ` , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! no Metrics , ! no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) red : = color . New ( color . Fg Red ) . Sprint Func ( ) var repos , pipelines [ ] string repo Infos , err : = client . List Repo ( ) if err ! = nil { return err } for _ , ri : = range repo Infos { repos = append ( repos , red ( ri . Repo . Name ) ) } pipeline Infos , err : = client . List Pipeline ( ) if err ! = nil { return err } for _ , pi : = range pipeline Infos { pipelines = append ( pipelines , red ( pi . Pipeline . Name ) ) } fmt . Println ( " " ) if len ( repos ) > 0 { fmt . Printf ( " \n " , strings . Join ( repos , " " ) ) } if len ( pipelines ) > 0 { fmt . Printf ( " \n " , strings . Join ( pipelines , " " ) ) } fmt . Println ( " " ) r : = bufio . New Reader ( os . Stdin ) bytes , err : = r . Read Bytes ( ' \n ' ) if err ! = nil { return err } if bytes [ 0 ] = = 'y ' | | bytes [ 0 ] = = 'Y ' { return client . Delete All ( ) } return nil } ) , } subcommands = append ( subcommands , cmdutil . Create Alias ( delete All , " " ) ) var port uint 1 6 var remote Port uint 1 6 var saml Port uint 1 6 var ui Port uint 1 6 var ui Websocket Port uint 1 6 var pfs Port uint 1 6 var s 3gateway Port uint 1 6 var namespace string port Forward : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { fw , err : = client . New Port Forwarder ( namespace ) if err ! = nil { return err } if err = fw . Lock ( ) ; err ! = nil { return err } defer fw . Close ( ) fail Count : = 0 fmt . Println ( " " ) if err = fw . Run For Daemon ( port , remote Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } fmt . Println ( " " ) if err = fw . Run For SAMLACS ( saml Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } fmt . Printf ( " \n " , ui Port ) if err = fw . Run For Dash UI ( ui Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } fmt . Println ( " " ) if err = fw . Run For Dash Web Socket ( ui Websocket Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } fmt . Println ( " " ) if err = fw . Run For PFS ( pfs Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } fmt . Println ( " " ) if err = fw . Run For S 3Gateway ( s 3gateway Port ) ; err ! = nil { fmt . Printf ( " \n " , err ) fail Count + + } if fail Count < 6 { fmt . Println ( " " ) ch : = make ( chan os . Signal , 1 ) signal . Notify ( ch , os . Interrupt ) < - ch } return nil } ) , } port Forward . Flags ( ) . Uint 1 6Var P ( & port , " " , " " , 3 0 6 5 0 , " " ) port Forward . Flags ( ) . Uint 1 6Var ( & remote Port , " " , 6 5 0 , " " ) port Forward . Flags ( ) . Uint 1 6Var ( & saml Port , " " , 3 0 6 5 4 , " " ) port Forward . Flags ( ) . Uint 1 6Var P ( & ui Port , " " , " " , 3 0 0 8 0 , " " ) port Forward . Flags ( ) . Uint 1 6Var P ( & ui Websocket Port , " " , " " , 3 0 0 8 1 , " " ) port Forward . Flags ( ) . Uint 1 6Var P ( & pfs Port , " " , " " , 3 0 6 5 2 , " " ) port Forward . Flags ( ) . Uint 1 6Var P ( & s 3gateway Port , " " , " " , 3 0 6 0 0 , " " ) port Forward . Flags ( ) . String Var ( & namespace , " " , " " , " " ) subcommands = append ( subcommands , cmdutil . Create Alias ( port Forward , " " ) ) var install bool var path string completion : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { var dest io . Writer if install { f , err : = os . Create ( path ) if err ! = nil { if os . Is Permission ( err ) { fmt . Fprintf ( os . Stderr , " \n " ) } return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } fmt . Printf ( " \n " , path ) } ( ) dest = f } else { dest = os . Stdout } unhide = func ( cmd * cobra . Command ) { cmd . Hidden = false for _ , subcmd : = range cmd . Commands ( ) { unhide ( subcmd ) } } unhide ( root Cmd ) return root Cmd . Gen Bash Completion ( dest ) } ) , } completion . Flags ( ) . Bool Var ( & install , " " , false , " " ) completion . Flags ( ) . String Var ( & path , " " , " " , " " ) subcommands = append ( subcommands , cmdutil . Create Alias ( completion , " " ) ) subcommands = append ( subcommands , cmdutil . Create Alias ( delete Docs , " " ) ) create Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( create Docs , " " ) ) update Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( update Docs , " " ) ) inspect Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( inspect Docs , " " ) ) list Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( list Docs , " " ) ) start Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( start Docs , " " ) ) finish Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( finish Docs , " " ) ) flush Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( flush Docs , " " ) ) subscribe Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( subscribe Docs , " " ) ) put Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( put Docs , " " ) ) copy Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( copy Docs , " " ) ) get Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( get Docs , " " ) ) glob Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( glob Docs , " " ) ) diff Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( diff Docs , " " ) ) stop Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( stop Docs , " " ) ) restart Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( restart Docs , " " ) ) edit Docs : = & cobra . Command { Short : " " , Long : " " , } subcommands = append ( subcommands , cmdutil . Create Alias ( edit Docs , " " ) ) subcommands = append ( subcommands , pfscmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , ppscmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , deploycmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , authcmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , enterprisecmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , admincmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) subcommands = append ( subcommands , debugcmds . Cmds ( & no Metrics , & no Port Forwarding ) . . . ) cmdutil . Merge Commands ( root Cmd , subcommands ) apply Root Usage Func ( root Cmd ) apply Command Compat 1 _ 8 ( root Cmd , & no Metrics , & no Port Forwarding ) return root Cmd } 
func ( b * backend ) Renew ( ctx context . Context , req * logical . Request , d * framework . Field Data ) ( resp * logical . Response , ret Err error ) { defer func ( ) { b . Logger ( ) . Debug ( fmt . Sprintf ( " " , req . Operation , req . Path , ret Err = = nil & & ! resp . Is Error ( ) ) ) } ( ) if ! ok { return nil , fmt . Errorf ( " " ) } user Token , ok : = token Iface . ( string ) if ! ok { return nil , fmt . Errorf ( " " , token Iface ) } if err ! = nil { return nil , err } if len ( config . Admin Token ) = = 0 { return nil , errors . New ( " " ) } if len ( config . Pachd Address ) = = 0 { return nil , errors . New ( " " ) } if ttl = = 0 { ttl , max TTL , err = b . Sanitize TTLStr ( config . TTL , max TTL . String ( ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } if err ! = nil { return nil , err } } 
func renew User Credentials ( ctx context . Context , pachd Address string , admin Token string , user Token string , ttl time . Duration ) error { if err ! = nil { return err } defer client . Close ( ) client = client . With Ctx ( ctx ) client . Set Auth Token ( admin Token ) _ , err = client . Auth APIClient . Extend Auth Token ( client . Ctx ( ) , & auth . Extend Auth Token Request { Token : user Token , TTL : int 6 4 ( ttl . Seconds ( ) ) , } ) if err ! = nil { return err } return nil } 
func New Local Client ( root string ) ( Client , error ) { if err : = os . Mkdir All ( root , 0 7 5 5 ) ; err ! = nil { return nil , err } return & local Client { root } , nil } 
func Add Span To Any Existing ( ctx context . Context , operation string , kvs . . . interface { } ) ( opentracing . Span , context . Context ) { if parent Span : = opentracing . Span From Context ( ctx ) ; parent Span ! = nil { span : = opentracing . Start Span ( operation , opentracing . Child Of ( parent Span . Context ( ) ) ) tag Span ( span , kvs ) return span , opentracing . Context With Span ( ctx , span ) } return nil , ctx } 
func Install Jaeger Tracer From Env ( ) { jaeger Once . Do ( func ( ) { jaeger Endpoint , on User Machine : = os . Lookup Env ( jaeger Endpoint Env Var ) if ! on User Machine { if host , ok : = os . Lookup Env ( " " ) ; ok { port : = os . Getenv ( " " ) jaeger Endpoint = fmt . Sprintf ( " " , host , port ) } } if jaeger Endpoint = = " " { return } jaeger Endpoint = strings . Trim Suffix ( jaeger Endpoint , " " ) jaeger Endpoint = fmt . Sprintf ( " " , jaeger Endpoint ) cfg : = jaegercfg . Configuration { if ! on User Machine { logger = jaeger . Std Logger } if err ! = nil { panic ( fmt . Sprintf ( " " , err ) ) } opentracing . Set Global Tracer ( tracer ) } ) } 
func Unary Client Interceptor ( ) grpc . Unary Client Interceptor { return otgrpc . Open Tracing Client Interceptor ( opentracing . Global Tracer ( ) , otgrpc . Including Spans ( add Trace If Tracing Enabled ) ) } 
func Stream Client Interceptor ( ) grpc . Stream Client Interceptor { return otgrpc . Open Tracing Stream Client Interceptor ( opentracing . Global Tracer ( ) , otgrpc . Including Spans ( add Trace If Tracing Enabled ) ) } 
func Unary Server Interceptor ( ) grpc . Unary Server Interceptor { return otgrpc . Open Tracing Server Interceptor ( opentracing . Global Tracer ( ) , otgrpc . Including Spans ( add Trace If Tracing Enabled ) ) } 
func Stream Server Interceptor ( ) grpc . Stream Server Interceptor { return otgrpc . Open Tracing Stream Server Interceptor ( opentracing . Global Tracer ( ) , otgrpc . Including Spans ( add Trace If Tracing Enabled ) ) } 
func Close And Report Traces ( ) { if c , ok : = opentracing . Global Tracer ( ) . ( io . Closer ) ; ok { c . Close ( ) } } 
func new Writer ( ctx context . Context , obj C obj . Client , prefix string ) * Writer { hash . Write ( make ( [ ] byte , Window Size ) ) return & Writer { ctx : ctx , obj C : obj C , prefix : prefix , cbs : [ ] func ( [ ] * Data Ref ) error { } , buf : & bytes . Buffer { } , hash : hash , split Mask : ( 1 < < uint 6 4 ( Average Bits ) ) - 1 , } } 
func ( w * Writer ) Range Start ( cb func ( [ ] * Data Ref ) error ) { } w . data Refs = [ ] * Data Ref { & Data Ref { Offset Bytes : int 6 4 ( w . buf . Len ( ) ) } } w . range Size = 0 w . range Count + + } 
func ( w * Writer ) Write ( data [ ] byte ) ( int , error ) { offset : = 0 size : = w . buf . Len ( ) for i , b : = range data { size + + w . hash . Roll ( b ) if w . hash . Sum 6 4 ( ) & w . split Mask = = 0 { w . buf . Write ( data [ offset : i + 1 ] ) if err : = w . put ( ) ; err ! = nil { return 0 , err } w . buf . Reset ( ) offset = i + 1 size = 0 } } w . buf . Write ( data [ offset : ] ) w . range Size + = int 6 4 ( len ( data ) ) return len ( data ) , nil } 
func identify User ( client * analytics . Client , user ID string ) { err : = client . Identify ( & analytics . Identify { User Id : user ID , } ) if err ! = nil { log . Errorf ( " " , err . Error ( ) ) } } 
func ( b * Constant Back Off ) Get Elapsed Time ( ) time . Duration { return time . Now ( ) . Sub ( b . start Time ) } 
func ( b * Constant Back Off ) Next Back Off ( ) time . Duration { if b . Max Elapsed Time ! = 0 & & b . Get Elapsed Time ( ) > b . Max Elapsed Time { return Stop } return b . Interval } 
func ( b * Constant Back Off ) For ( max Elapsed time . Duration ) * Constant Back Off { b . Max Elapsed Time = max Elapsed return b } 
func ( l * logger ) Log ( request interface { } , response interface { } , err error , duration time . Duration ) { if err ! = nil { l . Log At Level From Depth ( request , response , err , duration , logrus . Error Level , 4 ) } else { l . Log At Level From Depth ( request , response , err , duration , logrus . Info Level , 4 ) } } 
func ( f Formatter Func ) Format ( entry * logrus . Entry ) ( [ ] byte , error ) { return f ( entry ) } 
func Pretty ( entry * logrus . Entry ) ( [ ] byte , error ) { serialized : = [ ] byte ( fmt . Sprintf ( " " , entry . Time . Format ( logrus . Default Timestamp Format ) , strings . To Upper ( entry . Level . String ( ) ) , ) , ) if entry . Data [ " " ] ! = nil { serialized = append ( serialized , [ ] byte ( fmt . Sprintf ( " " , entry . Data [ " " ] , entry . Data [ " " ] ) ) . . . ) } if len ( entry . Data ) > 2 { delete ( entry . Data , " " ) delete ( entry . Data , " " ) if entry . Data [ " " ] ! = nil { entry . Data [ " " ] = entry . Data [ " " ] . ( time . Duration ) . Seconds ( ) } data , err : = json . Marshal ( entry . Data ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } serialized = append ( serialized , [ ] byte ( string ( data ) ) . . . ) serialized = append ( serialized , ' ' ) } serialized = append ( serialized , [ ] byte ( entry . Message ) . . . ) serialized = append ( serialized , ' \n ' ) return serialized , nil } 
func New GRPCLog Writer ( logger * logrus . Logger , source string ) * GRPCLog Writer { return & GRPCLog Writer { logger : logger , source : source , } } 
func ( l * GRPCLog Writer ) Write ( p [ ] byte ) ( int , error ) { parts : = strings . Split N ( string ( p ) , " " , 4 ) entry : = l . logger . With Field ( " " , l . source ) if len ( parts ) = = 4 { message : = strings . Trim Space ( parts [ 3 ] ) if level = = " " { entry . Info ( message ) } else if level = = " " { entry . Error ( message ) } else if level = = " " { entry . Warning ( message ) } else if level = = " " { } else { entry . Error ( message ) entry . Error ( " " , level ) } } else { entry . Error ( p ) entry . Error ( " " ) } return len ( p ) , nil } 
func Read ( ) ( * Config , error ) { var c * Config if raw , err : = ioutil . Read File ( p ) ; err = = nil { err = json . Unmarshal ( raw , & c ) if err ! = nil { return nil , err } } else if os . Is Not Exist ( err ) { c = & Config { } } else { return nil , fmt . Errorf ( " " , p , err ) } if c . User ID = = " " { fmt . Printf ( " " + " \n " , p ) uuid , err : = uuid . New V 4 ( ) if err ! = nil { return nil , err } c . User ID = uuid . String ( ) if err : = c . Write ( ) ; err ! = nil { return nil , err } } return c , nil } 
func ( c * Config ) Write ( ) error { raw Config , err : = json . Marshal Indent ( c , " " , " " ) if err ! = nil { return err } if _ , ok : = os . Lookup Env ( config Env Var ) ; ok { if _ , err : = os . Stat ( d ) ; err ! = nil { return fmt . Errorf ( " " , p , err ) } } else { if err ! = nil { return err } } return ioutil . Write File ( p , raw Config , 0 6 4 4 ) } 
func ( r * read Writer ) Read ( val proto . Message ) error { buf , err : = r . Read Bytes ( ) if err ! = nil { return err } return proto . Unmarshal ( buf , val ) } 
func ( r * read Writer ) Write ( val proto . Message ) ( int 6 4 , error ) { bytes , err : = proto . Marshal ( val ) if err ! = nil { return 0 , err } return r . Write Bytes ( bytes ) } 
func New Read Writer ( rw io . Read Writer ) Read Writer { return & read Writer { r : rw , w : rw } } 
func Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command var no Objects bool var url string extract : = & cobra . Command { Short : " " , Long : " " , Example : ` # Extract into a local file : $ { {alias } } > backup # Extract to s 3 : $ { {alias } } -u s 3 : if err ! = nil { return err } defer c . Close ( ) if url ! = " " { return c . Extract URL ( url ) } w : = snappy . New Buffered Writer ( os . Stdout ) defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return c . Extract Writer ( ! no Objects , w ) } ) , } extract . Flags ( ) . Bool Var ( & no Objects , " " , false , " " ) extract . Flags ( ) . String Var P ( & url , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( extract , " " ) ) restore : = & cobra . Command { Short : " " , Long : " " , Example : ` # Restore from a local file : $ { {alias } } < backup # Restore from s 3 : $ { {alias } } -u s 3 : if err ! = nil { return err } defer c . Close ( ) if url ! = " " { err = c . Restore URL ( url ) } else { err = c . Restore Reader ( snappy . New Reader ( os . Stdin ) ) } if err ! = nil { return fmt . Errorf ( " \n " + " " , err ) } return nil } ) , } restore . Flags ( ) . String Var P ( & url , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( restore , " " ) ) inspect Cluster : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) ci , err : = c . Inspect Cluster ( ) if err ! = nil { return err } fmt . Println ( ci . ID ) return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( inspect Cluster , " " ) ) return commands } 
func Run Git Hook Server ( address string , etcd Address string , etcd Prefix string ) error { c , err : = client . New From Address ( address ) if err ! = nil { return err } etcd Client , err : = etcd . New ( etcd . Config { Endpoints : [ ] string { etcd Address } , Dial Options : client . Default Dial Options ( ) , } ) if err ! = nil { return err } hook , err : = github . New ( ) if err ! = nil { return err } s : = & git Hook Server { hook , c , etcd Client , ppsdb . Pipelines ( etcd Client , etcd Prefix ) , } return http . Listen And Serve ( fmt . Sprintf ( " " , Git Hook Port ) , s ) } 
func new Logging Pipe ( ) * logging Pipe { p : = & logging Pipe { } p . client Reader , p . client Writer = io . Pipe ( ) p . client Reader = io . Tee Reader ( p . client Reader , & p . Server To Client Buf ) p . server Reader , p . server Writer = io . Pipe ( ) p . server Reader = io . Tee Reader ( p . server Reader , & p . Client To Server Buf ) return p } 
func ( p * logging Pipe ) Close ( ) error { p . client Writer . Close ( ) p . server Writer . Close ( ) return nil } 
func ( p * logging Pipe ) client Conn ( ) * logging Conn { return & logging Conn { pipe : p , r : p . client Reader , w : p . server Writer , } } 
func ( p * logging Pipe ) server Conn ( ) * logging Conn { return & logging Conn { pipe : p , r : p . server Reader , w : p . client Writer , } } 
func ( l * logging Conn ) Read ( b [ ] byte ) ( n int , err error ) { return l . r . Read ( b ) } 
func ( l * logging Conn ) Write ( b [ ] byte ) ( n int , err error ) { return l . w . Write ( b ) } 
func ( l * Test Listener ) Dial ( context . Context , string , string ) ( net . Conn , error ) { l . conn Mu . Lock ( ) defer l . conn Mu . Unlock ( ) if l . conn ! = nil { return nil , errors . New ( " " ) } l . conn = p . server Conn ( ) close ( l . conn Ch ) return p . client Conn ( ) , nil } 
func ( l * Test Listener ) Accept ( ) ( net . Conn , error ) { conn : = < - l . conn Ch if conn = = nil { return nil , errors . New ( " " ) } return conn , nil } 
func ( l * Test Listener ) Close ( ) error { l . conn Mu . Lock ( ) defer l . conn Mu . Unlock ( ) c : = < - l . conn Ch if c ! = nil { close ( l . conn Ch ) } return nil } 
func Server ( pc * client . APIClient , port uint 1 6 ) * http . Server { router : = mux . New Router ( ) router . Handle ( ` / ` , new Root Handler ( pc ) ) . Methods ( " " , " " ) trailing Slash Bucket Router : = router . Path ( ` / {branch : [a -z A -Z 0 - 9 \ - _ ] { 1 , 2 5 5 } } . {repo : [a -z A -Z 0 - 9 \ - _ ] { 1 , 2 5 5 } } / ` ) . Subrouter ( ) attach Bucket Routes ( trailing Slash Bucket Router , bucket Handler ) bucket Router : = router . Path ( ` / {branch : [a -z A -Z 0 - 9 \ - _ ] { 1 , 2 5 5 } } . {repo : [a -z A -Z 0 - 9 \ - _ ] { 1 , 2 5 5 } } ` ) . Subrouter ( ) attach Bucket Routes ( bucket Router , bucket Handler ) object Router . Methods ( " " , " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " , " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " , " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " , " " , " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Headers ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " , " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Router . Methods ( " " ) . Queries ( " " , " " ) . Handler Func ( not Implemented Error ) object Handler : = new Object Handler ( pc ) object Router . Methods ( " " , " " ) . Handler Func ( object Handler . get ) object Router . Methods ( " " ) . Handler Func ( object Handler . put ) object Router . Methods ( " " ) . Handler Func ( object Handler . del ) router . Method Not Allowed Handler = http . Handler Func ( method Not Allowed Error ) router . Not Found Handler = http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { request Logger ( r ) . Infof ( " " , r . URL . Path ) if bucket Name Validator . Match String ( r . URL . Path ) { no Such Key Error ( w , r ) } else { invalid Bucket Name Error ( w , r ) } } ) var last Enterprise Check time . Time is Enterprise : = false return & http . Server { Addr : fmt . Sprintf ( " " , port ) , Handler : http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if request ID = = " " { request ID = uuid . New Without Dashes ( ) r . Header . Set ( " " , request ID ) } w . Header ( ) . Set ( " " , request ID ) if ! is Enterprise | | now . Sub ( last Enterprise Check ) > enterprise Timeout { resp , err : = pc . Enterprise . Get State ( context . Background ( ) , & enterpriseclient . Get State Request { } ) if err ! = nil { err = fmt . Errorf ( " " , grpcutil . Scrub GRPC ( err ) ) internal Error ( w , r , err ) return } is Enterprise = resp . State = = enterpriseclient . State _ACTIVE } if ! is Enterprise { enterprise Disabled Error ( w , r ) return } router . Serve HTTP ( w , r ) } ) , Error Log : stdlog . New ( server Error Log , " " , 0 ) , } } 
func Code ( err error ) Err Code { if err = = nil { return OK } hte , ok : = err . ( * hash Tree Error ) if ! ok { return Unknown } return hte . code } 
func errorf ( c Err Code , fmt Str string , args . . . interface { } ) error { return & hash Tree Error { code : c , s : fmt . Sprintf ( fmt Str , args . . . ) , } } 
func Init Pach Only Env ( config * Configuration ) * Service Env { env : = & Service Env { Configuration : config } env . pach Address = net . Join Host Port ( " " , fmt . Sprintf ( " " , env . Peer Port ) ) env . pach Eg . Go ( env . init Pach Client ) return env } 
func Init Service Env ( config * Configuration ) * Service Env { env : = Init Pach Only Env ( config ) env . etcd Address = fmt . Sprintf ( " " , net . Join Host Port ( env . Etcd Host , env . Etcd Port ) ) env . etcd Eg . Go ( env . init Etcd Client ) return env } 
func Init With Kube ( config * Configuration ) * Service Env { env : = Init Service Env ( config ) env . kube Eg . Go ( env . init Kube Client ) return env } 
func ( env * Service Env ) Get Pach Client ( ctx context . Context ) * client . APIClient { if err : = env . pach Eg . Wait ( ) ; err ! = nil { panic ( err ) } return env . pach Client . With Ctx ( ctx ) } 
func ( env * Service Env ) Get Etcd Client ( ) * etcd . Client { if err : = env . etcd Eg . Wait ( ) ; err ! = nil { panic ( err ) } if env . etcd Client = = nil { panic ( " " ) } return env . etcd Client } 
func ( env * Service Env ) Get Kube Client ( ) * kube . Clientset { if err : = env . kube Eg . Wait ( ) ; err ! = nil { panic ( err ) } if env . kube Client = = nil { panic ( " " ) } return env . kube Client } 
func New Hasher ( job Modulus uint 6 4 , pipeline Modulus uint 6 4 ) * Hasher { return & Hasher { Job Modulus : job Modulus , Pipeline Modulus : pipeline Modulus , } } 
func ( s * Hasher ) Hash Job ( job ID string ) uint 6 4 { return uint 6 4 ( adler 3 2 . Checksum ( [ ] byte ( job ID ) ) ) % s . Job Modulus } 
func ( s * Hasher ) Hash Pipeline ( pipeline Name string ) uint 6 4 { return uint 6 4 ( adler 3 2 . Checksum ( [ ] byte ( pipeline Name ) ) ) % s . Pipeline Modulus } 
func Status ( ctx context . Context , pipeline Rc Name string , etcd Client * etcd . Client , etcd Prefix string , worker Grpc Port uint 1 6 ) ( [ ] * pps . Worker Status , error ) { worker Clients , err : = Clients ( ctx , pipeline Rc Name , etcd Client , etcd Prefix , worker Grpc Port ) if err ! = nil { return nil , err } var result [ ] * pps . Worker Status for _ , worker Client : = range worker Clients { status , err : = worker Client . Status ( ctx , & types . Empty { } ) if err ! = nil { return nil , err } result = append ( result , status ) } return result , nil } 
func Cancel ( ctx context . Context , pipeline Rc Name string , etcd Client * etcd . Client , etcd Prefix string , worker Grpc Port uint 1 6 , job ID string , data Filter [ ] string ) error { worker Clients , err : = Clients ( ctx , pipeline Rc Name , etcd Client , etcd Prefix , worker Grpc Port ) if err ! = nil { return err } success : = false for _ , worker Client : = range worker Clients { resp , err : = worker Client . Cancel ( ctx , & Cancel Request { Job ID : job ID , Data Filters : data Filter , } ) if err ! = nil { return err } if resp . Success { success = true } } if ! success { return fmt . Errorf ( " " , data Filter , job ID ) } return nil } 
func Conns ( ctx context . Context , pipeline Rc Name string , etcd Client * etcd . Client , etcd Prefix string , worker Grpc Port uint 1 6 ) ( [ ] * grpc . Client Conn , error ) { resp , err : = etcd Client . Get ( ctx , path . Join ( etcd Prefix , Worker Etcd Prefix , pipeline Rc Name ) , etcd . With Prefix ( ) ) if err ! = nil { return nil , err } var result [ ] * grpc . Client Conn for _ , kv : = range resp . Kvs { conn , err : = grpc . Dial ( fmt . Sprintf ( " " , path . Base ( string ( kv . Key ) ) , worker Grpc Port ) , append ( client . Default Dial Options ( ) , grpc . With Insecure ( ) ) . . . ) if err ! = nil { return nil , err } result = append ( result , conn ) } return result , nil } 
func Clients ( ctx context . Context , pipeline Rc Name string , etcd Client * etcd . Client , etcd Prefix string , worker Grpc Port uint 1 6 ) ( [ ] Client , error ) { conns , err : = Conns ( ctx , pipeline Rc Name , etcd Client , etcd Prefix , worker Grpc Port ) if err ! = nil { return nil , err } var result [ ] Client for _ , conn : = range conns { result = append ( result , new Client ( conn ) ) } return result , nil } 
func New Client ( address string ) ( Client , error ) { port , err : = strconv . Atoi ( os . Getenv ( client . PPSWorker Port Env ) ) if err ! = nil { return Client { } , err } conn , err : = grpc . Dial ( fmt . Sprintf ( " " , address , port ) , append ( client . Default Dial Options ( ) , grpc . With Insecure ( ) ) . . . ) if err ! = nil { return Client { } , err } return new Client ( conn ) , nil } 
func Scrub GRPC ( err error ) error { if err = = nil { return nil } if s , ok : = status . From Error ( err ) ; ok { return errors . New ( s . Message ( ) ) } return err } 
func Run Fixed Args ( num Args int , run func ( [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) ! = num Args { fmt . Printf ( " \n \n " , num Args , len ( args ) ) cmd . Usage ( ) } else { if err : = run ( args ) ; err ! = nil { Error And Exit ( " " , err ) } } } } 
func Run Bounded Args ( min int , max int , run func ( [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) < min | | len ( args ) > max { fmt . Printf ( " \n \n " , min , max , len ( args ) ) cmd . Usage ( ) } else { if err : = run ( args ) ; err ! = nil { Error And Exit ( " " , err ) } } } } 
func Run ( run func ( args [ ] string ) error ) func ( * cobra . Command , [ ] string ) { return func ( _ * cobra . Command , args [ ] string ) { if err : = run ( args ) ; err ! = nil { Error And Exit ( err . Error ( ) ) } } } 
func Error And Exit ( format string , args . . . interface { } ) { if err String : = strings . Trim Space ( fmt . Sprintf ( format , args . . . ) ) ; err String ! = " " { fmt . Fprintf ( os . Stderr , " \n " , err String ) } os . Exit ( 1 ) } 
func Parse Commit ( arg string ) ( * pfs . Commit , error ) { parts : = strings . Split N ( arg , " " , 2 ) if parts [ 0 ] = = " " { return nil , fmt . Errorf ( " \ " \ " " , arg ) } commit : = & pfs . Commit { Repo : & pfs . Repo { Name : parts [ 0 ] , } , ID : " " , } if len ( parts ) = = 2 { commit . ID = parts [ 1 ] } return commit , nil } 
func Parse Commits ( args [ ] string ) ( [ ] * pfs . Commit , error ) { var results [ ] * pfs . Commit for _ , arg : = range args { commit , err : = Parse Commit ( arg ) if err ! = nil { return nil , err } results = append ( results , commit ) } return results , nil } 
func Parse Branch ( arg string ) ( * pfs . Branch , error ) { commit , err : = Parse Commit ( arg ) if err ! = nil { return nil , err } return & pfs . Branch { Repo : commit . Repo , Name : commit . ID } , nil } 
func Parse Branches ( args [ ] string ) ( [ ] * pfs . Branch , error ) { var results [ ] * pfs . Branch for _ , arg : = range args { branch , err : = Parse Branch ( arg ) if err ! = nil { return nil , err } results = append ( results , branch ) } return results , nil } 
func Parse File ( arg string ) ( * pfs . File , error ) { repo And Rest : = strings . Split N ( arg , " " , 2 ) if repo And Rest [ 0 ] = = " " { return nil , fmt . Errorf ( " \ " \ " " , arg ) } file : = & pfs . File { Commit : & pfs . Commit { Repo : & pfs . Repo { Name : repo And Rest [ 0 ] , } , ID : " " , } , Path : " " , } if len ( repo And Rest ) > 1 { commit And Path : = strings . Split N ( repo And Rest [ 1 ] , " " , 2 ) if commit And Path [ 0 ] = = " " { return nil , fmt . Errorf ( " \ " \ " " , arg ) } file . Commit . ID = commit And Path [ 0 ] if len ( commit And Path ) > 1 { file . Path = commit And Path [ 1 ] } } return file , nil } 
func Parse Files ( args [ ] string ) ( [ ] * pfs . File , error ) { var results [ ] * pfs . File for _ , arg : = range args { commit , err : = Parse File ( arg ) if err ! = nil { return nil , err } results = append ( results , commit ) } return results , nil } 
func ( r * Repeated String Arg ) Set ( s string ) error { * r = append ( * r , s ) return nil } 
func Create Alias ( cmd * cobra . Command , invocation string ) * cobra . Command { args : = strings . Split ( invocation , " " ) for i , arg : = range args { cur : = & cobra . Command { } if cmd . Use = = " " { cur . Use = arg } else { cur . Use = strings . Replace ( cmd . Use , " " , arg , - 1 ) } cur . Example = strings . Replace ( cmd . Example , " " , fmt . Sprintf ( " " , os . Args [ 0 ] , invocation ) , - 1 ) } else { cur . Use = arg } if root = = nil { root = cur } else if prev ! = nil { prev . Add Command ( cur ) } prev = cur } return root } 
func Merge Commands ( root * cobra . Command , children [ ] * cobra . Command ) { } } return nil } depth = func ( cmd * cobra . Command ) int { max Depth : = 0 for _ , subcmd : = range cmd . Commands ( ) { subcmd Depth : = depth ( subcmd ) if subcmd Depth > max Depth { max Depth = subcmd Depth } } return max Depth + 1 } sort . Slice ( children , func ( i , j int ) bool { return depth ( children [ i ] ) < depth ( children [ j ] ) } ) if parent = = nil { root . Add Command ( cmd ) } else { Merge Commands ( parent , cmd . Commands ( ) ) } } } 
func Set Docs Usage ( command * cobra . Command ) { command . Set Help Template ( ` { {or .Long .Short } } { { .Usage String } } ` ) command . Set Usage Func ( func ( cmd * cobra . Command ) error { root Cmd : = cmd . Root ( ) var walk func ( * cobra . Command ) walk = func ( cursor * cobra . Command ) { if cursor . Name ( ) = = cmd . Name ( ) & & cursor . Command Path ( ) ! = cmd . Command Path ( ) { associated = append ( associated , cursor ) } for _ , subcmd : = range cursor . Commands ( ) { walk ( subcmd ) } } walk ( root Cmd ) var max Command Path int for _ , x : = range associated { command Path Len : = len ( x . Command Path ( ) ) if command Path Len > max Command Path { max Command Path = command Path Len } } template Funcs : = template . Func Map { " " : func ( s string ) string { format : = fmt . Sprintf ( " " , max Command Path + 1 ) return fmt . Sprintf ( format , s ) } , " " : func ( ) [ ] * cobra . Command { return associated } , } text : = `Associated Commands : { {range associated } } { {if .Is Available Command } } { {pad .Command Path } } { { .Short } } { {end } } { {end } } ` t : = template . New ( " " ) t . Funcs ( template Funcs ) template . Must ( t . Parse ( text ) ) return t . Execute ( cmd . Out ( ) , cmd ) } ) } 
func ( a * api Server ) master ( ) { master Lock : = dlock . New DLock ( a . env . Get Etcd Client ( ) , path . Join ( a . etcd Prefix , master Lock Path ) ) backoff . Retry Notify ( func ( ) error { ctx , cancel : = context . With Cancel ( context . Background ( ) ) defer cancel ( ) ctx , err : = master Lock . Lock ( ctx ) if err ! = nil { return err } defer master Lock . Unlock ( ctx ) kube Client : = a . env . Get Kube Client ( ) log . Infof ( " " ) pipeline Watcher , err : = a . pipelines . Read Only ( ctx ) . Watch ( watch . With Prev KV ( ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer pipeline Watcher . Close ( ) kube Pipeline Watch , err : = kube Client . Core V 1 ( ) . Pods ( a . namespace ) . Watch ( metav 1 . List Options { Label Selector : metav 1 . Format Label Selector ( metav 1 . Set As Label Selector ( map [ string ] string { " " : " " , } ) ) , Watch : true , } ) if err ! = nil { log . Errorf ( " " , err ) } else { watch Chan = kube Pipeline Watch . Result Chan ( ) defer kube Pipeline Watch . Stop ( ) } for { select { case event : = < - pipeline Watcher . Watch ( ) : if event . Err ! = nil { return fmt . Errorf ( " " , event . Err ) } switch event . Type { case watch . Event Put : var pipeline Name string var pipeline Ptr pps . Etcd Pipeline Info if err : = event . Unmarshal ( & pipeline Name , & pipeline Ptr ) ; err ! = nil { return err } var pipeline Info , prev Pipeline Info * pps . Pipeline Info if err : = a . sudo ( pach Client , func ( super User Client * client . APIClient ) error { var err error pipeline Info , err = ppsutil . Get Pipeline Info ( super User Client , & pipeline Ptr , true ) if err ! = nil { return err } if event . Prev Key ! = nil { if err : = event . Unmarshal Prev ( & pipeline Name , & prev Pipeline Ptr ) ; err ! = nil { return err } prev Pipeline Info , err = ppsutil . Get Pipeline Info ( super User Client , & prev Pipeline Ptr , true ) if err ! = nil { return err } } return nil } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = a . delete Workers For Pipeline ( pipeline Name ) ; err ! = nil { return err } if err : = a . set Pipeline State ( pach Client , pipeline Info , pps . Pipeline State _PIPELINE _PAUSED , " " ) ; err ! = nil { return err } } var has Git Input bool pps . Visit Input ( pipeline Info . Input , func ( input * pps . Input ) { if input . Git ! = nil { has Git Input = true } } ) if prev Pipeline Ptr . Spec Commit ! = nil { prev Spec Commit = prev Pipeline Ptr . Spec Commit . ID } return pipeline Ptr . Spec Commit . ID ! = prev Spec Commit & & ! pipeline Info . Stopped } ( ) if pipeline Restarted | | auth Activation Changed | | pipeline Upserted { if ( pipeline Upserted | | auth Activation Changed ) & & event . Prev Key ! = nil { if err : = a . delete Workers For Pipeline ( prev Pipeline Info . Pipeline . Name ) ; err ! = nil { return err } } if ( pipeline Upserted | | pipeline Restarted ) & & has Git Input { if err : = a . check Or Deploy Githook Service ( ) ; err ! = nil { return err } } log . Infof ( " " , pipeline Name ) if err : = a . upsert Workers For Pipeline ( pipeline Info ) ; err ! = nil { if err : = a . set Pipeline State ( pach Client , pipeline Info , pps . Pipeline State _PIPELINE _STARTING , fmt . Sprintf ( " " , err . Error ( ) ) ) ; err ! = nil { return err } } } if pipeline Info . State = = pps . Pipeline State _PIPELINE _RUNNING { if err : = a . scale Up Workers For Pipeline ( pipeline Info ) ; err ! = nil { return err } } if pipeline Info . State = = pps . Pipeline State _PIPELINE _STANDBY { if err : = a . scale Down Workers For Pipeline ( pipeline Info ) ; err ! = nil { return err } } } case event : = < - watch Chan : } kube Pipeline Watch , err = kube Client . Core V 1 ( ) . Pods ( a . namespace ) . Watch ( metav 1 . List Options { Label Selector : metav 1 . Format Label Selector ( metav 1 . Set As Label Selector ( map [ string ] string { " " : " " , } ) ) , Watch : true , } ) if err ! = nil { log . Errorf ( " " , err ) watch Chan = nil } else { watch Chan = kube Pipeline Watch . Result Chan ( ) defer kube Pipeline Watch . Stop ( ) } } pod , ok : = event . Object . ( * v 1 . Pod ) if ! ok { continue } if pod . Status . Phase = = v 1 . Pod Failed { log . Errorf ( " " , pod . Status . Message ) } for _ , status : = range pod . Status . Container Statuses { if status . Name = = " " & & status . State . Waiting ! = nil & & failures [ status . State . Waiting . Reason ] { if err : = a . set Pipeline Failure ( ctx , pod . Object Meta . Annotations [ " " ] , status . State . Waiting . Message ) ; err ! = nil { return err } } } } } } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { for _ , c : = range a . monitor Cancels { c ( ) } a . monitor Cancels = make ( map [ string ] func ( ) ) log . Errorf ( " " , err , d ) return nil } ) } 
func ( a * api Server ) make Cron Commits ( pach Client * client . APIClient , in * pps . Input ) error { schedule , err : = cron . Parse Standard ( in . Cron . Spec ) if err ! = nil { return err } if err ! = nil & & ! is Nil Branch Err ( err ) { return err } else if commit Info ! = nil & & commit Info . Finished = = nil { } } var latest Time time . Time files , err : = pach Client . List File ( in . Cron . Repo , " " , " " ) if err ! = nil & & ! is Nil Branch Err ( err ) { return err } else if err ! = nil | | len ( files ) = = 0 { if err ! = nil { return err } } else { if err ! = nil { return err } } for { if err ! = nil { return err } if err ! = nil { return err } if in . Cron . Overwrite { if err ! = nil & & ! is Not Found Err ( err ) & & ! is Nil Branch Err ( err ) { return fmt . Errorf ( " " , err ) } } if err ! = nil { return fmt . Errorf ( " " , err ) } err = pach Client . Finish Commit ( in . Cron . Repo , " " ) if err ! = nil { return err } } } 
func ( o * tracing Obj Client ) Writer ( ctx context . Context , name string ) ( io . Write Closer , error ) { span , ctx : = tracing . Add Span To Any Existing ( ctx , o . provider + " " , " " , name ) if span ! = nil { defer span . Finish ( ) } return o . Client . Writer ( ctx , name ) } 
func ( o * tracing Obj Client ) Reader ( ctx context . Context , name string , offset uint 6 4 , size uint 6 4 ) ( io . Read Closer , error ) { span , ctx : = tracing . Add Span To Any Existing ( ctx , o . provider + " " , " " , name , " " , fmt . Sprintf ( " " , offset ) , " " , fmt . Sprintf ( " " , size ) ) defer tracing . Finish Any Span ( span ) return o . Client . Reader ( ctx , name , offset , size ) } 
func ( o * tracing Obj Client ) Delete ( ctx context . Context , name string ) error { span , ctx : = tracing . Add Span To Any Existing ( ctx , o . provider + " " , " " , name ) defer tracing . Finish Any Span ( span ) return o . Client . Delete ( ctx , name ) } 
func ( o * tracing Obj Client ) Walk ( ctx context . Context , prefix string , fn func ( name string ) error ) error { span , ctx : = tracing . Add Span To Any Existing ( ctx , o . provider + " " , " " , prefix ) defer tracing . Finish Any Span ( span ) return o . Client . Walk ( ctx , prefix , fn ) } 
func ( o * tracing Obj Client ) Exists ( ctx context . Context , name string ) bool { span , ctx : = tracing . Add Span To Any Existing ( ctx , o . provider + " " , " " , name ) defer tracing . Finish Any Span ( span ) return o . Client . Exists ( ctx , name ) } 
func ( c * Commit ) Full ID ( ) string { return fmt . Sprintf ( " " , c . Repo . Name , c . ID ) } 
func Get Block ( hash hash . Hash ) * Block { return & Block { Hash : base 6 4 . URLEncoding . Encode To String ( hash . Sum ( nil ) ) , } } 
func ( h * health Server ) Health ( context . Context , * types . Empty ) ( * types . Empty , error ) { if ! h . ready { return nil , fmt . Errorf ( " " ) } return & types . Empty { } , nil } 
func clean ( p string ) string { if ! strings . Has Prefix ( p , " " ) { p = " " + p } return internal Default ( path . Clean ( p ) ) } 
func split ( p string ) ( string , string ) { return clean ( path . Dir ( p ) ) , base ( p ) } 
func Validate Path ( path string ) error { path = clean ( path ) match , _ : = regexp . Match String ( " " , path ) if ! match { return fmt . Errorf ( " " , path ) } if Is Glob ( path ) { return fmt . Errorf ( " " , path , glob Regex . Find String ( path ) ) } return nil } 
func Match Datum ( filter [ ] string , data [ ] * pps . Input File ) bool { data Filters : for _ , data Filter : = range filter { for _ , datum : = range data { if data Filter = = datum . Path | | data Filter = = base 6 4 . Std Encoding . Encode To String ( datum . Hash ) | | data Filter = = hex . Encode To String ( datum . Hash ) { continue data Filters } } matches Data = false break } return matches Data } 
func New Cache Server ( router shard . Router , shards uint 6 4 ) Cache Server { server : = & group Cache Server { Logger : log . New Logger ( " " ) , router : router , local Shards : make ( map [ uint 6 4 ] bool ) , shards : shards , } groupcache . Register Peer Picker ( func ( ) groupcache . Peer Picker { return server } ) return server } 
func ( a * api Server ) authorize Pipeline Op ( pach Client * client . APIClient , operation pipeline Operation , input * pps . Input , output string ) error { ctx : = pach Client . Ctx ( ) me , err : = pach Client . Who Am I ( ctx , & auth . Who Am IRequest { } ) if auth . Is Err Not Activated ( err ) { return nil } else if err ! = nil { return err } if input ! = nil { done : = make ( map [ string ] struct { } ) pps . Visit Input ( input , func ( in * pps . Input ) { var repo string if in . Pfs ! = nil { repo = in . Pfs . Repo } else { return } if _ , ok : = done [ repo ] ; ok { return } done [ repo ] = struct { } { } eg . Go ( func ( ) error { resp , err : = pach Client . Authorize ( ctx , & auth . Authorize Request { Repo : repo , Scope : auth . Scope _READER , } ) if err ! = nil { return err } if ! resp . Authorized { return & auth . Err Not Authorized { Subject : me . Username , Repo : repo , Required : auth . Scope _READER , } } return nil } ) } ) if err : = eg . Wait ( ) ; err ! = nil { return err } } switch operation { case pipeline Op Create : if _ , err : = pach Client . Inspect Repo ( output ) ; err = = nil { return fmt . Errorf ( " \ " \ " " , output ) } else if ! is Not Found Err ( err ) { return err } case pipeline Op List Datum , pipeline Op Get Logs : required = auth . Scope _READER case pipeline Op Update : required = auth . Scope _WRITER case pipeline Op Delete : required = auth . Scope _OWNER default : return fmt . Errorf ( " " , operation ) } if required ! = auth . Scope _NONE { resp , err : = pach Client . Authorize ( ctx , & auth . Authorize Request { Repo : output , Scope : required , } ) if err ! = nil { return err } if ! resp . Authorized { return & auth . Err Not Authorized { Subject : me . Username , Repo : output , Required : required , } } } return nil } 
func ( a * api Server ) list Job ( pach Client * client . APIClient , pipeline * pps . Pipeline , output Commit * pfs . Commit , input Commits [ ] * pfs . Commit , f func ( * pps . Job Info ) error ) error { auth Is Active : = true me , err : = pach Client . Who Am I ( pach Client . Ctx ( ) , & auth . Who Am IRequest { } ) if auth . Is Err Not Activated ( err ) { auth Is Active = false } else if err ! = nil { return err } if auth Is Active & & pipeline ! = nil { if err ! = nil { return err } if ! resp . Authorized { return & auth . Err Not Authorized { Subject : me . Username , Repo : pipeline . Name , Required : auth . Scope _READER , } } } if output Commit ! = nil { output Commit , err = a . resolve Commit ( pach Client , output Commit ) if err ! = nil { return err } } for i , input Commit : = range input Commits { input Commits [ i ] , err = a . resolve Commit ( pach Client , input Commit ) if err ! = nil { return err } } jobs : = a . jobs . Read Only ( pach Client . Ctx ( ) ) job Ptr : = & pps . Etcd Job Info { } _f : = func ( key string ) error { job Info , err : = a . job Info From Ptr ( pach Client , job Ptr , len ( input Commits ) > 0 ) if err ! = nil { if is Not Found Err ( err ) { } else if auth . Is Err Not Authorized ( err ) { return nil } return err } if len ( input Commits ) > 0 { found : = make ( [ ] bool , len ( input Commits ) ) pps . Visit Input ( job Info . Input , func ( in * pps . Input ) { if in . Pfs ! = nil { for i , input Commit : = range input Commits { if in . Pfs . Commit = = input Commit . ID { found [ i ] = true } } } } ) for _ , found : = range found { if ! found { return nil } } } return f ( job Info ) } if pipeline ! = nil { return jobs . Get By Index ( ppsdb . Jobs Pipeline Index , pipeline , job Ptr , col . Default Options , _f ) } else if output Commit ! = nil { return jobs . Get By Index ( ppsdb . Jobs Output Index , output Commit , job Ptr , col . Default Options , _f ) } else { return jobs . List ( job Ptr , col . Default Options , _f ) } } 
func ( a * api Server ) list Datum ( pach Client * client . APIClient , job * pps . Job , page , page Size int 6 4 ) ( response * pps . List Datum Response , ret Err error ) { if err : = check Logged In ( pach Client ) ; err ! = nil { return nil , err } response = & pps . List Datum Response { } ctx : = pach Client . Ctx ( ) pfs Client : = pach Client . Pfs APIClient if err ! = nil { return nil , err } } } get Page Bounds : = func ( total Size int ) ( int , int , error ) { start : = int ( page * page Size ) end : = int ( ( page + 1 ) * page Size ) switch { case total Size < = start : return 0 , 0 , io . EOF case total Size < = end : return start , total Size , nil case end < total Size : return start , end , nil } return 0 , 0 , goerr . New ( " " ) } df , err : = workerpkg . New Datum Factory ( pach Client , job Info . Input ) if err ! = nil { return nil , err } end : = df . Len ( ) if page Size > 0 { var err error start , end , err = get Page Bounds ( df . Len ( ) ) if err ! = nil { return nil , err } response . Page = page response . Total Pages = get Total Pages ( df . Len ( ) ) } var datum Infos [ ] * pps . Datum Info for i : = start ; i < end ; i + + { datum : = df . Datum ( i ) id : = workerpkg . Hash Datum ( job Info . Pipeline . Name , job Info . Salt , datum ) datum Info : = & pps . Datum Info { Datum : & pps . Datum { ID : id , Job : job Info . Job , } , State : pps . Datum State _STARTING , } for _ , input : = range datum { datum Info . Data = append ( datum Info . Data , input . File Info ) } datum Infos = append ( datum Infos , datum Info ) } response . Datum Infos = datum Infos return response , nil } var datum File Infos [ ] * pfs . File Info fs , err : = pfs Client . List File Stream ( ctx , & pfs . List File Request { File : file , Full : true } ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } path To Datum Hash : = func ( path string ) ( string , error ) { _ , datum Hash : = filepath . Split ( path ) if _ , ok : = blacklist [ datum Hash ] ; ok { return " " , fmt . Errorf ( " " , datum Hash ) } return datum Hash , nil } for { f , err : = fs . Recv ( ) if err = = io . EOF { break } else if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } if _ , err : = path To Datum Hash ( f . File . Path ) ; err ! = nil { } datum File Infos = append ( datum File Infos , f ) } var eg Get Datums errgroup . Group limiter : = limit . New ( 2 0 0 ) datum Infos : = make ( [ ] * pps . Datum Info , len ( datum File Infos ) ) for index , file Info : = range datum File Infos { file Info : = file Info index : = index eg Get Datums . Go ( func ( ) error { limiter . Acquire ( ) defer limiter . Release ( ) datum Hash , err : = path To Datum Hash ( file Info . File . Path ) if err ! = nil { } datum , err : = a . get Datum ( pach Client , job Info . Stats Commit . Repo . Name , job Info . Stats Commit , job . ID , datum Hash , df ) if err ! = nil { return err } datum Infos [ index ] = datum return nil } ) } if err = eg Get Datums . Wait ( ) ; err ! = nil { return nil , err } } ) if page Size > 0 { response . Page = page response . Total Pages = get Total Pages ( len ( datum Infos ) ) start , end , err : = get Page Bounds ( len ( datum Infos ) ) if err ! = nil { return nil , err } datum Infos = datum Infos [ start : end ] } response . Datum Infos = datum Infos return response , nil } 
func ( a * api Server ) hard Stop Pipeline ( pach Client * client . APIClient , pipeline Info * pps . Pipeline Info ) error { } if err ! = nil { return fmt . Errorf ( " " , pipeline Info . Output Branch , err ) } if err = = io . EOF { break } else if err ! = nil { return err } if ci . Finished = = nil { } } return nil } 
func ( a * api Server ) sudo ( pach Client * client . APIClient , f func ( * client . APIClient ) error ) error { b . Max Elapsed Time = 6 0 * time . Second b . Max Interval = 5 * time . Second if err : = backoff . Retry ( func ( ) error { super User Token Col : = col . New Collection ( a . env . Get Etcd Client ( ) , ppsconsts . PPSToken Key , nil , & types . String Value { } , nil , nil ) . Read Only ( pach Client . Ctx ( ) ) var result types . String Value if err : = super User Token Col . Get ( " " , & result ) ; err ! = nil { return err } super User Token = result . Value return nil } , b ) ; err ! = nil { panic ( fmt . Sprintf ( " " , err ) ) } } ) super User Client . Set Auth Token ( super User Token ) return f ( super User Client ) } 
func ( a * api Server ) make Pipeline Info Commit ( pach Client * client . APIClient , pipeline Info * pps . Pipeline Info ) ( result * pfs . Commit , ret Err error ) { pipeline Name : = pipeline Info . Pipeline . Name var commit * pfs . Commit if err : = a . sudo ( pach Client , func ( super User Client * client . APIClient ) error { data , err : = pipeline Info . Marshal ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if _ , err = super User Client . Put File Overwrite ( ppsconsts . Spec Repo , pipeline Name , ppsconsts . Spec File , bytes . New Reader ( data ) , 0 ) ; err ! = nil { return err } branch Info , err : = super User Client . Inspect Branch ( ppsconsts . Spec Repo , pipeline Name ) if err ! = nil { return err } commit = branch Info . Head return nil } ) ; err ! = nil { return nil , err } return commit , nil } 
func set Pipeline Defaults ( pipeline Info * pps . Pipeline Info ) { now : = time . Now ( ) if pipeline Info . Transform . Image = = " " { pipeline Info . Transform . Image = Default User Image } pps . Visit Input ( pipeline Info . Input , func ( input * pps . Input ) { if input . Pfs ! = nil { if input . Pfs . Branch = = " " { input . Pfs . Branch = " " } if input . Pfs . Name = = " " { input . Pfs . Name = input . Pfs . Repo } } if input . Cron ! = nil { if input . Cron . Start = = nil { start , _ : = types . Timestamp Proto ( now ) input . Cron . Start = start } if input . Cron . Repo = = " " { input . Cron . Repo = fmt . Sprintf ( " " , pipeline Info . Pipeline . Name , input . Cron . Name ) } } if input . Git ! = nil { if input . Git . Branch = = " " { input . Git . Branch = " " } if input . Git . Name = = " " { input . Git . Name = tokens [ 0 ] } } } ) if pipeline Info . Output Branch = = " " { } if pipeline Info . Cache Size = = " " { pipeline Info . Cache Size = " " } if pipeline Info . Resource Requests = = nil & & pipeline Info . Cache Size ! = " " { pipeline Info . Resource Requests = & pps . Resource Spec { Memory : pipeline Info . Cache Size , } } if pipeline Info . Max Queue Size < 1 { pipeline Info . Max Queue Size = 1 } if pipeline Info . Datum Tries = = 0 { pipeline Info . Datum Tries = Default Datum Tries } } 
func ( a * api Server ) inspect Pipeline ( pach Client * client . APIClient , name string ) ( * pps . Pipeline Info , error ) { if err : = check Logged In ( pach Client ) ; err ! = nil { return nil , err } kube Client : = a . env . Get Kube Client ( ) name , ancestors : = ancestry . Parse ( name ) pipeline Ptr : = pps . Etcd Pipeline Info { } if err : = a . pipelines . Read Only ( pach Client . Ctx ( ) ) . Get ( name , & pipeline Ptr ) ; err ! = nil { if col . Is Err Not Found ( err ) { return nil , fmt . Errorf ( " \ " \ " " , name ) } return nil , err } pipeline Ptr . Spec Commit . ID = ancestry . Add ( pipeline Ptr . Spec Commit . ID , ancestors ) pipeline Info , err : = ppsutil . Get Pipeline Info ( pach Client , & pipeline Ptr , true ) if err ! = nil { return nil , err } if pipeline Info . Service ! = nil { rc Name : = ppsutil . Pipeline Rc Name ( pipeline Info . Pipeline . Name , pipeline Info . Version ) if err ! = nil { return nil , err } service , err : = kube Client . Core V 1 ( ) . Services ( a . namespace ) . Get ( fmt . Sprintf ( " " , rc Name ) , metav 1 . Get Options { } ) if err ! = nil { if ! is Not Found Err ( err ) { return nil , err } } else { pipeline Info . Service . IP = service . Spec . Cluster IP } } var has Git Input bool pps . Visit Input ( pipeline Info . Input , func ( input * pps . Input ) { if input . Git ! = nil { has Git Input = true } } ) if has Git Input { pipeline Info . Githook URL = " " svc , err : = get Githook Service ( kube Client , a . namespace ) if err ! = nil { return pipeline Info , nil } num IPs : = len ( svc . Status . Load Balancer . Ingress ) if num IPs = = 0 { } if num IPs ! = 1 { return nil , fmt . Errorf ( " " ) } ingress : = svc . Status . Load Balancer . Ingress [ 0 ] if ingress . IP ! = " " { } else if ingress . Hostname ! = " " { } } return pipeline Info , nil } 
func Collect Active Objects And Tags ( ctx context . Context , pach Client * client . APIClient , repo Infos [ ] * pfs . Repo Info , pipeline Infos [ ] * pps . Pipeline Info , memory Allowance int , storage Root string ) ( * Active Stat , error ) { if memory Allowance = = 0 { memory Allowance = default GCMemory } result : = & Active Stat { var active Objects Mu sync . Mutex defer active Objects Mu . Unlock ( ) for _ , object : = range objects { if object ! = nil { result . NObjects + + result . Objects . Add String ( object . Hash ) } } } } add Active Objects ( object ) tree , err : = hashtree . Get Hash Tree Object ( pach Client , storage Root , object ) if err ! = nil { return err } return tree . Walk ( " " , func ( path string , node * hashtree . Node Proto ) error { if node . File Node ! = nil { add Active Objects ( node . File Node . Objects . . . ) } return nil } ) } var eg errgroup . Group for _ , repo : = range repo Infos { repo : = repo client , err : = pach Client . List Commit Stream ( ctx , & pfs . List Commit Request { Repo : repo . Repo , } ) if err ! = nil { return nil , err } for { ci , err : = client . Recv ( ) if err = = io . EOF { break } else if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } limiter . Acquire ( ) eg . Go ( func ( ) error { defer limiter . Release ( ) add Active Objects ( ci . Datums ) return add Active Tree ( ci . Tree ) } ) } } if err : = eg . Wait ( ) ; err ! = nil { return nil , err } eg = errgroup . Group { } for _ , pipeline Info : = range pipeline Infos { tags , err : = pach Client . Object APIClient . List Tags ( pach Client . Ctx ( ) , & pfs . List Tags Request { Prefix : client . Datum Tag Prefix ( pipeline Info . Salt ) , Include Object : true , } ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for resp , err : = tags . Recv ( ) ; err ! = io . EOF ; resp , err = tags . Recv ( ) { resp : = resp if err ! = nil { return nil , err } result . Tags . Add String ( resp . Tag . Name ) result . NTags + + limiter . Acquire ( ) eg . Go ( func ( ) error { defer limiter . Release ( ) return nil } ) } } if err : = eg . Wait ( ) ; err ! = nil { return nil , err } return result , nil } 
func ( a * api Server ) increment GCGeneration ( ctx context . Context ) error { resp , err : = a . env . Get Etcd Client ( ) . Get ( ctx , client . GCGeneration Key ) if err ! = nil { return err } if resp . Count = = 0 { } } else { old Gen , err : = strconv . Atoi ( string ( resp . Kvs [ 0 ] . Value ) ) if err ! = nil { return err } new Gen : = old Gen + 1 if _ , err : = a . env . Get Etcd Client ( ) . Put ( ctx , client . GCGeneration Key , strconv . Itoa ( new Gen ) ) ; err ! = nil { return err } } return nil } 
func New Debug Server ( name string , etcd Client * etcd . Client , etcd Prefix string , worker Grpc Port uint 1 6 ) debug . Debug Server { return & debug Server { name : name , etcd Client : etcd Client , etcd Prefix : etcd Prefix , worker Grpc Port : worker Grpc Port , } } 
func ( c APIClient ) Health ( ) error { _ , err : = c . health Client . Health ( c . Ctx ( ) , & types . Empty { } ) return grpcutil . Scrub GRPC ( err ) } 
func new Obj Block APIServer ( dir string , cache Bytes int 6 4 , etcd Address string , obj Client obj . Client , test bool ) ( * obj Block APIServer , error ) { } one Cache Share : = cache Bytes / ( object Cache Shares + tag Cache Shares + object Info Cache Shares + block Cache Shares ) s : = & obj Block APIServer { Logger : log . New Logger ( " " ) , dir : dir , obj Client : obj Client , object Indexes : make ( map [ string ] * pfsclient . Object Index ) , object Cache Bytes : one Cache Share * object Cache Shares , } object Group Name : = " " tag Group Name : = " " object Info Group Name : = " " block Group Name : = " " if test { uuid : = uuid . New ( ) object Group Name + = uuid tag Group Name + = uuid object Info Group Name + = uuid block Group Name + = uuid } s . object Cache = groupcache . New Group ( object Group Name , one Cache Share * object Cache Shares , groupcache . Getter Func ( s . object Getter ) ) s . tag Cache = groupcache . New Group ( tag Group Name , one Cache Share * tag Cache Shares , groupcache . Getter Func ( s . tag Getter ) ) s . object Info Cache = groupcache . New Group ( object Info Group Name , one Cache Share * object Info Cache Shares , groupcache . Getter Func ( s . object Info Getter ) ) s . block Cache = groupcache . New Group ( block Group Name , one Cache Share * block Cache Shares , groupcache . Getter Func ( s . block Getter ) ) if ! test { Register Cache Stats ( " " , & s . tag Cache . Stats ) Register Cache Stats ( " " , & s . object Cache . Stats ) Register Cache Stats ( " " , & s . object Info Cache . Stats ) } go s . watch GC ( etcd Address ) return s , nil } 
func ( s * obj Block APIServer ) watch GC ( etcd Address string ) { b : = backoff . New Infinite Back Off ( ) backoff . Retry Notify ( func ( ) error { etcd Client , err : = etcd . New ( etcd . Config { Endpoints : [ ] string { etcd Address } , Dial Options : client . Default Dial Options ( ) , } ) if err ! = nil { return fmt . Errorf ( " " , err ) } watcher , err : = watch . New Watcher ( context . Background ( ) , etcd Client , " " , client . GCGeneration Key , nil ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer watcher . Close ( ) for { ev , ok : = < - watcher . Watch ( ) if ev . Err ! = nil { return fmt . Errorf ( " " , ev . Err ) } if ! ok { return fmt . Errorf ( " " ) } new Gen , err : = strconv . Atoi ( string ( ev . Value ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } s . set Generation ( new Gen ) } } , b , func ( err error , d time . Duration ) error { logrus . Errorf ( " " , err , d ) return nil } ) } 
func ( s * obj Block APIServer ) write Internal ( ctx context . Context , path string , data [ ] byte ) ( ret Err error ) { defer func ( ) { if ret Err ! = nil { return } ret Err = func ( ) ( ret Err error ) { if ! s . obj Client . Exists ( ctx , path ) { logrus . Errorf ( " " , path ) return fmt . Errorf ( " " , path ) } return nil } ( ) } ( ) w , err : = s . obj Client . Writer ( ctx , path ) if err ! = nil { return err } defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) _ , err = w . Write ( data ) return err } 
func ( s * obj Block APIServer ) split Key ( key string ) string { gen : = s . get Generation ( ) if len ( key ) < prefix Length { return fmt . Sprintf ( " " , key , gen ) } return fmt . Sprintf ( " " , key [ : prefix Length ] , key [ prefix Length : ] , gen ) } 
func New Writer ( w io . Writer , header string ) * Writer { if header [ len ( header ) - 1 ] ! = ' \n ' { panic ( " " ) } tabwriter : = ansiterm . New Tab Writer ( w , 0 , 1 , 1 , ' ' , 0 ) tabwriter . Write ( [ ] byte ( header ) ) return & Writer { w : tabwriter , lines : 1 , } 
func ( w * Writer ) Write ( buf [ ] byte ) ( int , error ) { if w . lines > = term Height { if err : = w . Flush ( ) ; err ! = nil { return 0 , err } if _ , err : = w . w . Write ( w . header ) ; err ! = nil { return 0 , err } w . lines + + } w . lines + = bytes . Count ( buf , [ ] byte { ' \n ' } ) return w . w . Write ( buf ) } 
func Print Repo Header ( w io . Writer , print Auth bool ) { if print Auth { fmt . Fprint ( w , Repo Auth Header ) return } fmt . Fprint ( w , Repo Header ) } 
func Print Repo Info ( w io . Writer , repo Info * pfs . Repo Info , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , repo Info . Repo . Name ) if full Timestamps { fmt . Fprintf ( w , " \t " , repo Info . Created . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( repo Info . Created ) ) } fmt . Fprintf ( w , " \t " , units . Bytes Size ( float 6 4 ( repo Info . Size Bytes ) ) ) if repo Info . Auth Info ! = nil { fmt . Fprintf ( w , " \t " , repo Info . Auth Info . Access Level . String ( ) ) } fmt . Fprintln ( w ) } 
func Print Detailed Repo Info ( repo Info * Printable Repo Info ) error { template , err : = template . New ( " " ) . Funcs ( func Map ) . Parse ( `Name : { { .Repo .Name } } { {if .Description } } Description : { { .Description } } { {end } } { {if .Full Timestamps } } Created : { { .Created } } { {else } } Created : { {pretty Ago .Created } } { {end } } Size of HEAD on master : { {pretty Size .Size Bytes } } { {if .Auth Info } } Access level : { { .Auth Info .Access Level .String } } { {end } } ` ) if err ! = nil { return err } err = template . Execute ( os . Stdout , repo Info ) if err ! = nil { return err } return nil } 
func Print Branch ( w io . Writer , branch Info * pfs . Branch Info ) { fmt . Fprintf ( w , " \t " , branch Info . Branch . Name ) if branch Info . Head ! = nil { fmt . Fprintf ( w , " \t \n " , branch Info . Head . ID ) } else { fmt . Fprintf ( w , " \t \n " ) } } 
func Print Commit Info ( w io . Writer , commit Info * pfs . Commit Info , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , commit Info . Commit . Repo . Name ) fmt . Fprintf ( w , " \t " , commit Info . Branch . Name ) fmt . Fprintf ( w , " \t " , commit Info . Commit . ID ) if commit Info . Parent Commit ! = nil { fmt . Fprintf ( w , " \t " , commit Info . Parent Commit . ID ) } else { fmt . Fprint ( w , " \t " ) } if full Timestamps { fmt . Fprintf ( w , " \t " , commit Info . Started . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( commit Info . Started ) ) } if commit Info . Finished ! = nil { fmt . Fprintf ( w , fmt . Sprintf ( " \t " , pretty . Time Difference ( commit Info . Started , commit Info . Finished ) ) ) fmt . Fprintf ( w , " \t \n " , units . Bytes Size ( float 6 4 ( commit Info . Size Bytes ) ) ) } else { fmt . Fprintf ( w , " \t " ) } } 
func Print Detailed Commit Info ( commit Info * Printable Commit Info ) error { template , err : = template . New ( " " ) . Funcs ( func Map ) . Parse ( `Commit : { { .Commit .Repo .Name } } @ { { .Commit .ID } } { {if .Branch } } Original Branch : { { .Branch .Name } } { {end } } { {if .Description } } Description : { { .Description } } { {end } } { {if .Parent Commit } } Parent : { { .Parent Commit .ID } } { {end } } { {if .Full Timestamps } } Started : { { .Started } } { {else } } Started : { {pretty Ago .Started } } { {end } } { {if .Finished } } { {if .Full Timestamps } } Finished : { { .Finished } } { {else } } Finished : { {pretty Ago .Finished } } { {end } } { {end } } Size : { {pretty Size .Size Bytes } } { {if .Provenance } } Provenance : { {range .Provenance } } { { .Commit .Repo .Name } } @ { { .Commit .ID } } ( { { .Branch .Name } } ) { {end } } { {end } } ` ) if err ! = nil { return err } err = template . Execute ( os . Stdout , commit Info ) if err ! = nil { return err } return nil } 
func Print File Info ( w io . Writer , file Info * pfs . File Info , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , file Info . File . Commit . ID ) fmt . Fprintf ( w , " \t " , file Info . File . Path ) if file Info . File Type = = pfs . File Type _FILE { fmt . Fprint ( w , " \t " ) } else { fmt . Fprint ( w , " \t " ) } if file Info . Committed = = nil { fmt . Fprintf ( w , " \t " ) } else if full Timestamps { fmt . Fprintf ( w , " \t " , file Info . Committed . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( file Info . Committed ) ) } fmt . Fprintf ( w , " \t \n " , units . Bytes Size ( float 6 4 ( file Info . Size Bytes ) ) ) } 
func Print Detailed File Info ( file Info * pfs . File Info ) error { template , err : = template . New ( " " ) . Funcs ( func Map ) . Parse ( `Path : { { .File .Path } } Type : { {file Type .File Type } } Size : { {pretty Size .Size Bytes } } Children : { {range .Children } } { { . } } { {end } } ` ) if err ! = nil { return err } return template . Execute ( os . Stdout , file Info ) } 
func Compact Print Branch ( b * pfs . Branch ) string { return fmt . Sprintf ( " " , b . Repo . Name , b . Name ) } 
func Compact Print Commit ( c * pfs . Commit ) string { return fmt . Sprintf ( " " , c . Repo . Name , c . ID ) } 
func Compact Print File ( f * pfs . File ) string { return fmt . Sprintf ( " " , f . Commit . Repo . Name , f . Commit . ID , f . Path ) } 
func Parse ( s string ) ( string , int ) { sep Index : = strings . Index Any ( s , " " ) if sep Index = = - 1 { return s , 0 } str After Sep : = s [ sep Index + 1 : ] } } } } 
func Add ( s string , ancestors int ) string { return fmt . Sprintf ( " " , s , ancestors ) } 
func Retry Notify ( operation Operation , b Back Off , notify Notify ) error { var err error var next time . Duration b . Reset ( ) for { if err = operation ( ) ; err = = nil { return nil } if next = b . Next Back Off ( ) ; next = = Stop { return err } if notify ! = nil { if err : = notify ( err , next ) ; err ! = nil { return err } } time . Sleep ( next ) } } 
func New Cache ( size int ) ( * Cache , error ) { c , err : = lru . New With Evict ( size , func ( key interface { } , value interface { } ) { go func ( ) { tree , ok : = value . ( * db Hash Tree ) if ! ok { logrus . Infof ( " " , reflect . Type Of ( value ) ) return } if err : = tree . Destroy ( ) ; err ! = nil { logrus . Infof ( " " , err ) } } ( ) } ) if err ! = nil { return nil , err } return & Cache { c } , nil } 
func ( c * Merge Cache ) Put ( id int 6 4 , tree io . Reader ) ( ret Err error ) { return c . Cache . Put ( fmt . Sprint ( id ) , tree ) } 
func ( c * Merge Cache ) Get ( id int 6 4 , w io . Writer , filter Filter ) ( ret Err error ) { r , err : = c . Cache . Get ( fmt . Sprint ( id ) ) if err ! = nil { return err } defer func ( ) { if err : = r . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return New Writer ( w ) . Copy ( New Reader ( r , filter ) ) } 
func ( c * Merge Cache ) Delete ( id int 6 4 ) error { return c . Cache . Delete ( fmt . Sprint ( id ) ) } 
func ( c * Merge Cache ) Merge ( w * Writer , base io . Reader , filter Filter ) ( ret Err error ) { var trees [ ] * Reader if base ! = nil { trees = append ( trees , New Reader ( base , filter ) ) } for _ , key : = range c . Keys ( ) { r , err : = c . Cache . Get ( key ) if err ! = nil { return err } defer func ( ) { if err : = r . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) trees = append ( trees , New Reader ( r , filter ) ) } return Merge ( w , trees ) } 
func Print Job Info ( w io . Writer , job Info * ppsclient . Job Info , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , job Info . Job . ID ) fmt . Fprintf ( w , " \t " , job Info . Pipeline . Name ) if full Timestamps { fmt . Fprintf ( w , " \t " , job Info . Started . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( job Info . Started ) ) } if job Info . Finished ! = nil { fmt . Fprintf ( w , " \t " , pretty . Time Difference ( job Info . Started , job Info . Finished ) ) } else { fmt . Fprintf ( w , " \t " ) } fmt . Fprintf ( w , " \t " , job Info . Restart ) if job Info . Data Recovered ! = 0 { fmt . Fprintf ( w , " \t " , job Info . Data Processed , job Info . Data Skipped , job Info . Data Recovered , job Info . Data Total ) } else { fmt . Fprintf ( w , " \t " , job Info . Data Processed , job Info . Data Skipped , job Info . Data Total ) } fmt . Fprintf ( w , " \t " , pretty . Size ( job Info . Stats . Download Bytes ) ) fmt . Fprintf ( w , " \t " , pretty . Size ( job Info . Stats . Upload Bytes ) ) if job Info . State = = ppsclient . Job State _JOB _FAILURE { fmt . Fprintf ( w , " \t \n " , job State ( job Info . State ) , safe Trim ( job Info . Reason , job Reason Len ) ) } else { fmt . Fprintf ( w , " \t \n " , job State ( job Info . State ) ) } } 
func Print Pipeline Info ( w io . Writer , pipeline Info * ppsclient . Pipeline Info , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , pipeline Info . Pipeline . Name ) fmt . Fprintf ( w , " \t " , Shorthand Input ( pipeline Info . Input ) ) if full Timestamps { fmt . Fprintf ( w , " \t " , pipeline Info . Created At . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( pipeline Info . Created At ) ) } fmt . Fprintf ( w , " \t \n " , pipeline State ( pipeline Info . State ) , job State ( pipeline Info . Last Job State ) ) } 
func Print Worker Status ( w io . Writer , worker Status * ppsclient . Worker Status , full Timestamps bool ) { fmt . Fprintf ( w , " \t " , worker Status . Worker ID ) fmt . Fprintf ( w , " \t " , worker Status . Job ID ) for _ , datum : = range worker Status . Data { fmt . Fprintf ( w , datum . Path ) } fmt . Fprintf ( w , " \t " ) if full Timestamps { fmt . Fprintf ( w , " \t " , worker Status . Started . String ( ) ) } else { fmt . Fprintf ( w , " \t " , pretty . Ago ( worker Status . Started ) ) } fmt . Fprintf ( w , " \t \n " , worker Status . Queue Size ) } 
func Print Detailed Job Info ( job Info * Printable Job Info ) error { template , err : = template . New ( " " ) . Funcs ( func Map ) . Parse ( `ID : { { .Job .ID } } { {if .Pipeline } } Pipeline : { { .Pipeline .Name } } { {end } } { {if .Parent Job } } Parent : { { .Parent Job .ID } } { {end } } { {if .Full Timestamps } } Started : { { .Started } } { {else } } Started : { {pretty Ago .Started } } { {end } } { {if .Finished } } Duration : { {pretty Time Difference .Started .Finished } } { {end } } State : { {job State .State } } Reason : { { .Reason } } Processed : { { .Data Processed } } Failed : { { .Data Failed } } Skipped : { { .Data Skipped } } Recovered : { { .Data Recovered } } Total : { { .Data Total } } Data Downloaded : { {pretty Size .Stats .Download Bytes } } Data Uploaded : { {pretty Size .Stats .Upload Bytes } } Download Time : { {pretty Duration .Stats .Download Time } } Process Time : { {pretty Duration .Stats .Process Time } } Upload Time : { {pretty Duration .Stats .Upload Time } } Datum Timeout : { { .Datum Timeout } } Job Timeout : { { .Job Timeout } } Worker Status : { {worker Status . } }Restarts : { { .Restart } } Parallelism Spec : { { .Parallelism Spec } } { { if .Resource Requests } }Resource Requests : CPU : { { .Resource Requests .Cpu } } Memory : { { .Resource Requests .Memory } } { {end } } { { if .Resource Limits } }Resource Limits : CPU : { { .Resource Limits .Cpu } } Memory : { { .Resource Limits .Memory } } { { if .Resource Limits .Gpu } }GPU : Type : { { .Resource Limits .Gpu .Type } } Number : { { .Resource Limits .Gpu .Number } } { {end } } { {end } } { { if .Service } }Service : { { if .Service .Internal Port } }Internal Port : { { .Service .Internal Port } } { {end } } { { if .Service .External Port } }External Port : { { .Service .External Port } } { {end } } { {end } }Input : { {job Input . } } Transform : { {pretty Transform .Transform } } { {if .Output Commit } } Output Commit : { { .Output Commit .ID } } { {end } } { { if .Stats Commit } } Stats Commit : { { .Stats Commit .ID } } { {end } } { { if .Egress } } Egress : { { .Egress .URL } } { {end } } ` ) if err ! = nil { return err } err = template . Execute ( os . Stdout , job Info ) if err ! = nil { return err } return nil } 
func Print Detailed Pipeline Info ( pipeline Info * Printable Pipeline Info ) error { template , err : = template . New ( " " ) . Funcs ( func Map ) . Parse ( `Name : { { .Pipeline .Name } } { {if .Description } } Description : { { .Description } } { {end } } { {if .Full Timestamps } } Created : { { .Created At } } { { else } } Created : { {pretty Ago .Created At } } { {end } } State : { {pipeline State .State } } Stopped : { { .Stopped } } Reason : { { .Reason } } Parallelism Spec : { { .Parallelism Spec } } { { if .Resource Requests } }Resource Requests : CPU : { { .Resource Requests .Cpu } } Memory : { { .Resource Requests .Memory } } { {end } } { { if .Resource Limits } }Resource Limits : CPU : { { .Resource Limits .Cpu } } Memory : { { .Resource Limits .Memory } } { { if .Resource Limits .Gpu } }GPU : Type : { { .Resource Limits .Gpu .Type } } Number : { { .Resource Limits .Gpu .Number } } { {end } } { {end } } Datum Timeout : { { .Datum Timeout } } Job Timeout : { { .Job Timeout } } Input : { {pipeline Input .Pipeline Info } } { { if .Githook URL } }Githook URL : { { .Githook URL } } { {end } } Output Branch : { { .Output Branch } } Transform : { {pretty Transform .Transform } } { { if .Egress } }Egress : { { .Egress .URL } } { {end } } { {if .Recent Error } } Recent Error : { { .Recent Error } } { {end } } Job Counts : { {job Counts .Job Counts } } ` ) if err ! = nil { return err } err = template . Execute ( os . Stdout , pipeline Info ) if err ! = nil { return err } return nil } 
func Print Datum Info ( w io . Writer , datum Info * ppsclient . Datum Info ) { total Time : = " " if datum Info . Stats ! = nil { total Time = units . Human Duration ( client . Get Datum Total Time ( datum Info . Stats ) ) } fmt . Fprintf ( w , " \t \t \n " , datum Info . Datum . ID , datum State ( datum Info . State ) , total Time ) } 
func Print Detailed Datum Info ( w io . Writer , datum Info * ppsclient . Datum Info ) { fmt . Fprintf ( w , " \t \n " , datum Info . Datum . ID ) fmt . Fprintf ( w , " \t \n " , datum Info . Datum . Job . ID ) fmt . Fprintf ( w , " \t \n " , datum Info . State ) fmt . Fprintf ( w , " \t \n " , pretty . Size ( datum Info . Stats . Download Bytes ) ) fmt . Fprintf ( w , " \t \n " , pretty . Size ( datum Info . Stats . Upload Bytes ) ) total Time : = client . Get Datum Total Time ( datum Info . Stats ) . String ( ) fmt . Fprintf ( w , " \t \n " , total Time ) var download Time string dl , err : = types . Duration From Proto ( datum Info . Stats . Download Time ) if err ! = nil { download Time = err . Error ( ) } download Time = dl . String ( ) fmt . Fprintf ( w , " \t \n " , download Time ) var proc Time string proc , err : = types . Duration From Proto ( datum Info . Stats . Process Time ) if err ! = nil { proc Time = err . Error ( ) } proc Time = proc . String ( ) fmt . Fprintf ( w , " \t \n " , proc Time ) var upload Time string ul , err : = types . Duration From Proto ( datum Info . Stats . Upload Time ) if err ! = nil { upload Time = err . Error ( ) } upload Time = ul . String ( ) fmt . Fprintf ( w , " \t \n " , upload Time ) fmt . Fprintf ( w , " \n " ) tw : = ansiterm . New Tab Writer ( w , 1 0 , 1 , 3 , ' ' , 0 ) Print File Header ( tw ) Print File ( tw , datum Info . Pfs State ) tw . Flush ( ) fmt . Fprintf ( w , " \n " ) tw = ansiterm . New Tab Writer ( w , 1 0 , 1 , 3 , ' ' , 0 ) Print File Header ( tw ) for _ , d : = range datum Info . Data { Print File ( tw , d . File ) } tw . Flush ( ) } 
func Print File ( w io . Writer , file * pfsclient . File ) { fmt . Fprintf ( w , " \t \t \t \n " , file . Commit . Repo . Name , file . Commit . ID , file . Path ) } 
func Shorthand Input ( input * ppsclient . Input ) string { switch { case input = = nil : return " " case input . Pfs ! = nil : return fmt . Sprintf ( " " , input . Pfs . Repo , input . Pfs . Glob ) case input . Cross ! = nil : var sub Input [ ] string for _ , input : = range input . Cross { sub Input = append ( sub Input , Shorthand Input ( input ) ) } return " " + strings . Join ( sub Input , " + " " case input . Union ! = nil : var sub Input [ ] string for _ , input : = range input . Union { sub Input = append ( sub Input , Shorthand Input ( input ) ) } return " " + strings . Join ( sub Input , " + " " case input . Cron ! = nil : return fmt . Sprintf ( " " , input . Cron . Name , input . Cron . Spec ) } return " " } 
func ( v * vault Credentials Provider ) update Lease ( secret * vault . Secret ) { v . lease Mu . Lock ( ) defer v . lease Mu . Unlock ( ) v . lease ID = secret . Lease ID v . lease Last Renew = time . Now ( ) v . lease Duration = time . Duration ( secret . Lease Duration ) * time . Second } 
func ( v * vault Credentials Provider ) Retrieve ( ) ( credentials . Value , error ) { var empty Creds , result credentials . Value if err ! = nil { return empty Creds , fmt . Errorf ( " " , err ) } access Key Iface , access Key Ok : = vault Secret . Data [ " " ] aws Secret Iface , aws Secret Ok : = vault Secret . Data [ " " ] if ! access Key Ok | | ! aws Secret Ok { return empty Creds , fmt . Errorf ( " " ) } result . Secret Access Key , aws Secret Ok = aws Secret Iface . ( string ) if ! access Key Ok | | ! aws Secret Ok { return empty Creds , fmt . Errorf ( " " , access Key Iface , aws Secret Iface ) } go func ( ) { for { if renew Interval . Seconds ( ) < one Day In Seconds { renew Interval = one Day In Seconds * time . Second } backoff . Retry Notify ( func ( ) error { if err ! = nil { return err } v . update Lease ( vault Secret ) return nil } , backoff . New Exponential Back Off ( ) , func ( err error , _ time . Duration ) error { log . Errorf ( " " , err ) return nil } ) } } ( ) return result , nil } 
func ( v * vault Credentials Provider ) Is Expired ( ) bool { v . lease Mu . Lock ( ) defer v . lease Mu . Unlock ( ) return time . Now ( ) . After ( v . lease Last Renew . Add ( v . lease Duration ) ) } 
func ( a * sharder ) unsafe Assign Roles ( cancel chan bool ) ( ret Err error ) { var version int 6 4 old Servers : = make ( map [ string ] bool ) old Roles : = make ( map [ string ] * Server Role ) old Shards : = make ( map [ uint 6 4 ] string ) var old Min Version int 6 4 if err ! = nil { return err } for _ , encoded Server Role : = range server Roles { server Role , err : = decode Server Role ( encoded Server Role ) if err ! = nil { return err } if old Server Role , ok : = old Roles [ server Role . Address ] ; ! ok | | old Server Role . Version < server Role . Version { old Roles [ server Role . Address ] = server Role old Servers [ server Role . Address ] = true } if version < server Role . Version + 1 { version = server Role . Version + 1 } } for _ , old Server Role : = range old Roles { for shard : = range old Server Role . Shards { old Shards [ shard ] = old Server Role . Address } } err = a . discovery Client . Watch All ( a . server State Dir ( ) , cancel , func ( encoded Server States map [ string ] string ) error { if len ( encoded Server States ) = = 0 { return nil } new Server States : = make ( map [ string ] * Server State ) new Roles : = make ( map [ string ] * Server Role ) new Shards : = make ( map [ uint 6 4 ] string ) shards Per Server : = a . num Shards / uint 6 4 ( len ( encoded Server States ) ) shards Remainder : = a . num Shards % uint 6 4 ( len ( encoded Server States ) ) for _ , encoded Server State : = range encoded Server States { server State , err : = decode Server State ( encoded Server State ) if err ! = nil { return err } new Server States [ server State . Address ] = server State new Roles [ server State . Address ] = & Server Role { Address : server State . Address , Version : version , Shards : make ( map [ uint 6 4 ] bool ) , } } for _ , server State : = range new Server States { if server State . Version < min Version { min Version = server State . Version } } if err : = a . discovery Client . Watch All ( a . frontend State Dir ( ) , cancel , func ( encoded Frontend States map [ string ] string ) error { for _ , encoded Frontend State : = range encoded Frontend States { frontend State , err : = decode Frontend State ( encoded Frontend State ) if err ! = nil { return err } if frontend State . Version < min Version { return nil } } return err Complete } ) ; err ! = nil & & err ! = err Complete { return err } server Roles , err : = a . discovery Client . Get All ( a . server Role Dir ( ) ) if err ! = nil { return err } for key , encoded Server Role : = range server Roles { server Role , err : = decode Server Role ( encoded Server Role ) if err ! = nil { return err } if server Role . Version < min Version { if err : = a . discovery Client . Delete ( key ) ; err ! = nil { return err } } } } } Shard : for shard : = uint 6 4 ( 0 ) ; shard < a . num Shards ; shard + + { if address , ok : = old Shards [ shard ] ; ok { if assign Shard ( new Roles , new Shards , address , shard , shards Per Server , & shards Remainder ) { continue Shard } } for address : = range new Server States { if assign Shard ( new Roles , new Shards , address , shard , shards Per Server , & shards Remainder ) { continue Shard } } log . Error ( & Failed To Assign Roles { Server States : new Server States , Num Shards : a . num Shards , } ) return nil } addresses : = Addresses { Version : version , Addresses : make ( map [ uint 6 4 ] string ) , } for address , server Role : = range new Roles { encoded Server Role , err : = marshaler . Marshal To String ( server Role ) if err ! = nil { return err } if err : = a . discovery Client . Set ( a . server Role Key Version ( address , version ) , encoded Server Role , 0 ) ; err ! = nil { return err } address : = new Server States [ address ] . Address for shard : = range server Role . Shards { addresses . Addresses [ shard ] = address } } encoded Addresses , err : = marshaler . Marshal To String ( & addresses ) if err ! = nil { return err } if err : = a . discovery Client . Set ( a . addresses Key ( version ) , encoded Addresses , 0 ) ; err ! = nil { return err } version + + old Servers = make ( map [ string ] bool ) for address : = range new Server States { old Servers [ address ] = true } old Roles = new Roles old Shards = new Shards return nil } ) if err = = discovery . Err Cancelled { return Err Cancelled } return err } 
func New Branch ( repo Name string , branch Name string ) * pfs . Branch { return & pfs . Branch { Repo : New Repo ( repo Name ) , Name : branch Name , } } 
func New Commit ( repo Name string , commit ID string ) * pfs . Commit { return & pfs . Commit { Repo : New Repo ( repo Name ) , ID : commit ID , } } 
func New Commit Provenance ( repo Name string , branch Name string , commit ID string ) * pfs . Commit Provenance { return & pfs . Commit Provenance { Commit : New Commit ( repo Name , commit ID ) , Branch : New Branch ( repo Name , branch Name ) , } } 
func New File ( repo Name string , commit ID string , path string ) * pfs . File { return & pfs . File { Commit : New Commit ( repo Name , commit ID ) , Path : path , } } 
func ( c APIClient ) Create Repo ( repo Name string ) error { _ , err : = c . Pfs APIClient . Create Repo ( c . Ctx ( ) , & pfs . Create Repo Request { Repo : New Repo ( repo Name ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Repo ( repo Name string ) ( * pfs . Repo Info , error ) { resp , err : = c . Pfs APIClient . Inspect Repo ( c . Ctx ( ) , & pfs . Inspect Repo Request { Repo : New Repo ( repo Name ) , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return resp , nil } 
func ( c APIClient ) List Repo ( ) ( [ ] * pfs . Repo Info , error ) { request : = & pfs . List Repo Request { } repo Infos , err : = c . Pfs APIClient . List Repo ( c . Ctx ( ) , request , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return repo Infos . Repo Info , nil } 
func ( c APIClient ) Delete Repo ( repo Name string , force bool ) error { _ , err : = c . Pfs APIClient . Delete Repo ( c . Ctx ( ) , & pfs . Delete Repo Request { Repo : New Repo ( repo Name ) , Force : force , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Build Commit ( repo Name string , branch string , parent string , tree Object string ) ( * pfs . Commit , error ) { commit , err : = c . Pfs APIClient . Build Commit ( c . Ctx ( ) , & pfs . Build Commit Request { Parent : New Commit ( repo Name , parent ) , Branch : branch , Tree : & pfs . Object { Hash : tree Object } , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return commit , nil } 
func ( c APIClient ) Start Commit Parent ( repo Name string , branch string , parent Commit string ) ( * pfs . Commit , error ) { commit , err : = c . Pfs APIClient . Start Commit ( c . Ctx ( ) , & pfs . Start Commit Request { Parent : & pfs . Commit { Repo : & pfs . Repo { Name : repo Name , } , ID : parent Commit , } , Branch : branch , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return commit , nil } 
func ( c APIClient ) Finish Commit ( repo Name string , commit ID string ) error { _ , err : = c . Pfs APIClient . Finish Commit ( c . Ctx ( ) , & pfs . Finish Commit Request { Commit : New Commit ( repo Name , commit ID ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Commit ( repo Name string , commit ID string ) ( * pfs . Commit Info , error ) { return c . inspect Commit ( repo Name , commit ID , pfs . Commit State _STARTED ) } 
func ( c APIClient ) Block Commit ( repo Name string , commit ID string ) ( * pfs . Commit Info , error ) { return c . inspect Commit ( repo Name , commit ID , pfs . Commit State _FINISHED ) } 
func ( c APIClient ) List Commit ( repo Name string , to string , from string , number uint 6 4 ) ( [ ] * pfs . Commit Info , error ) { var result [ ] * pfs . Commit Info if err : = c . List Commit F ( repo Name , to , from , number , func ( ci * pfs . Commit Info ) error { result = append ( result , ci ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) List Commit F ( repo Name string , to string , from string , number uint 6 4 , f func ( * pfs . Commit Info ) error ) error { req : = & pfs . List Commit Request { Repo : New Repo ( repo Name ) , Number : number , } if from ! = " " { req . From = New Commit ( repo Name , from ) } if to ! = " " { req . To = New Commit ( repo Name , to ) } stream , err : = c . Pfs APIClient . List Commit Stream ( c . Ctx ( ) , req ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { ci , err : = stream . Recv ( ) if err = = io . EOF { break } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( ci ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } return nil } 
func ( c APIClient ) List Commit By Repo ( repo Name string ) ( [ ] * pfs . Commit Info , error ) { return c . List Commit ( repo Name , " " , " " , 0 ) } 
func ( c APIClient ) Create Branch ( repo Name string , branch string , commit string , provenance [ ] * pfs . Branch ) error { var head * pfs . Commit if commit ! = " " { head = New Commit ( repo Name , commit ) } _ , err : = c . Pfs APIClient . Create Branch ( c . Ctx ( ) , & pfs . Create Branch Request { Branch : New Branch ( repo Name , branch ) , Head : head , Provenance : provenance , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Branch ( repo Name string , branch string ) ( * pfs . Branch Info , error ) { branch Info , err : = c . Pfs APIClient . Inspect Branch ( c . Ctx ( ) , & pfs . Inspect Branch Request { Branch : New Branch ( repo Name , branch ) , } , ) return branch Info , grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) List Branch ( repo Name string ) ( [ ] * pfs . Branch Info , error ) { branch Infos , err : = c . Pfs APIClient . List Branch ( c . Ctx ( ) , & pfs . List Branch Request { Repo : New Repo ( repo Name ) , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return branch Infos . Branch Info , nil } 
func ( c APIClient ) Set Branch ( repo Name string , commit string , branch string ) error { return c . Create Branch ( repo Name , branch , commit , nil ) } 
func ( c APIClient ) Delete Branch ( repo Name string , branch string , force bool ) error { _ , err : = c . Pfs APIClient . Delete Branch ( c . Ctx ( ) , & pfs . Delete Branch Request { Branch : New Branch ( repo Name , branch ) , Force : force , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Delete Commit ( repo Name string , commit ID string ) error { _ , err : = c . Pfs APIClient . Delete Commit ( c . Ctx ( ) , & pfs . Delete Commit Request { Commit : New Commit ( repo Name , commit ID ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Flush Commit ( commits [ ] * pfs . Commit , to Repos [ ] * pfs . Repo ) ( Commit Info Iterator , error ) { ctx , cancel : = context . With Cancel ( c . Ctx ( ) ) stream , err : = c . Pfs APIClient . Flush Commit ( ctx , & pfs . Flush Commit Request { Commits : commits , To Repos : to Repos , } , ) if err ! = nil { cancel ( ) return nil , grpcutil . Scrub GRPC ( err ) } return & commit Info Iterator { stream , cancel } , nil } 
func ( c APIClient ) Flush Commit F ( commits [ ] * pfs . Commit , to Repos [ ] * pfs . Repo , f func ( * pfs . Commit Info ) error ) error { stream , err : = c . Pfs APIClient . Flush Commit ( c . Ctx ( ) , & pfs . Flush Commit Request { Commits : commits , To Repos : to Repos , } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { ci , err : = stream . Recv ( ) if err ! = nil { if err = = io . EOF { return nil } return grpcutil . Scrub GRPC ( err ) } if err : = f ( ci ) ; err ! = nil { return err } } } 
func ( c APIClient ) Flush Commit All ( commits [ ] * pfs . Commit , to Repos [ ] * pfs . Repo ) ( [ ] * pfs . Commit Info , error ) { var result [ ] * pfs . Commit Info if err : = c . Flush Commit F ( commits , to Repos , func ( ci * pfs . Commit Info ) error { result = append ( result , ci ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) Subscribe Commit ( repo string , branch string , from string , state pfs . Commit State ) ( Commit Info Iterator , error ) { ctx , cancel : = context . With Cancel ( c . Ctx ( ) ) req : = & pfs . Subscribe Commit Request { Repo : New Repo ( repo ) , Branch : branch , State : state , } if from ! = " " { req . From = New Commit ( repo , from ) } stream , err : = c . Pfs APIClient . Subscribe Commit ( ctx , req ) if err ! = nil { cancel ( ) return nil , grpcutil . Scrub GRPC ( err ) } return & commit Info Iterator { stream , cancel } , nil } 
func ( c APIClient ) Subscribe Commit F ( repo , branch , from string , state pfs . Commit State , f func ( * pfs . Commit Info ) error ) error { req : = & pfs . Subscribe Commit Request { Repo : New Repo ( repo ) , Branch : branch , State : state , } if from ! = " " { req . From = New Commit ( repo , from ) } stream , err : = c . Pfs APIClient . Subscribe Commit ( c . Ctx ( ) , req ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { ci , err : = stream . Recv ( ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( ci ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } } } 
func ( c APIClient ) Put Object Async ( tags [ ] * pfs . Tag ) ( * Put Object Write Closer Async , error ) { w , err : = c . new Put Object Write Closer Async ( tags ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return w , nil } 
func ( c APIClient ) Put Object ( _r io . Reader , tags . . . string ) ( object * pfs . Object , _ int 6 4 , ret Err error ) { r : = grpcutil . Reader Wrapper { _r } w , err : = c . new Put Object Write Closer ( tags . . . ) if err ! = nil { return nil , 0 , grpcutil . Scrub GRPC ( err ) } defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } if ret Err = = nil { object = w . object } } ( ) buf : = grpcutil . Get Buffer ( ) defer grpcutil . Put Buffer ( buf ) written , err : = io . Copy Buffer ( w , r , buf ) if err ! = nil { return nil , 0 , grpcutil . Scrub GRPC ( err ) } } 
func ( c APIClient ) Put Object Split ( _r io . Reader ) ( objects [ ] * pfs . Object , _ int 6 4 , ret Err error ) { r : = grpcutil . Reader Wrapper { _r } w , err : = c . new Put Object Split Write Closer ( ) if err ! = nil { return nil , 0 , grpcutil . Scrub GRPC ( err ) } defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } if ret Err = = nil { objects = w . objects } } ( ) buf : = grpcutil . Get Buffer ( ) defer grpcutil . Put Buffer ( buf ) written , err : = io . Copy Buffer ( w , r , buf ) if err ! = nil { return nil , 0 , grpcutil . Scrub GRPC ( err ) } } 
func ( c APIClient ) Get Object ( hash string , writer io . Writer ) error { get Object Client , err : = c . Object APIClient . Get Object ( c . Ctx ( ) , & pfs . Object { Hash : hash } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = grpcutil . Write From Streaming Bytes Client ( get Object Client , writer ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Get Object Reader ( hash string ) ( io . Read Closer , error ) { ctx , cancel : = context . With Cancel ( c . Ctx ( ) ) get Object Client , err : = c . Object APIClient . Get Object ( ctx , & pfs . Object { Hash : hash } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return grpcutil . New Streaming Bytes Reader ( get Object Client , cancel ) , nil } 
func ( c APIClient ) Read Object ( hash string ) ( [ ] byte , error ) { var buffer bytes . Buffer if err : = c . Get Object ( hash , & buffer ) ; err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return buffer . Bytes ( ) , nil } 
func ( c APIClient ) Get Objects ( hashes [ ] string , offset uint 6 4 , size uint 6 4 , total Size uint 6 4 , writer io . Writer ) error { var objects [ ] * pfs . Object for _ , hash : = range hashes { objects = append ( objects , & pfs . Object { Hash : hash } ) } get Objects Client , err : = c . Object APIClient . Get Objects ( c . Ctx ( ) , & pfs . Get Objects Request { Objects : objects , Offset Bytes : offset , Size Bytes : size , Total Size : total Size , } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = grpcutil . Write From Streaming Bytes Client ( get Objects Client , writer ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Read Objects ( hashes [ ] string , offset uint 6 4 , size uint 6 4 ) ( [ ] byte , error ) { var buffer bytes . Buffer if err : = c . Get Objects ( hashes , offset , size , 0 , & buffer ) ; err ! = nil { return nil , err } return buffer . Bytes ( ) , nil } 
func ( c APIClient ) Tag Object ( hash string , tags . . . string ) error { var _tags [ ] * pfs . Tag for _ , tag : = range tags { _tags = append ( _tags , & pfs . Tag { Name : tag } ) } if _ , err : = c . Object APIClient . Tag Object ( c . Ctx ( ) , & pfs . Tag Object Request { Object : & pfs . Object { Hash : hash } , Tags : _tags , } , ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) List Object ( f func ( * pfs . Object ) error ) error { list Object Client , err : = c . Object APIClient . List Objects ( c . Ctx ( ) , & pfs . List Objects Request { } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { object , err : = list Object Client . Recv ( ) if err ! = nil { if err = = io . EOF { return nil } return grpcutil . Scrub GRPC ( err ) } if err : = f ( object ) ; err ! = nil { return err } } } 
func ( c APIClient ) Inspect Object ( hash string ) ( * pfs . Object Info , error ) { value , err : = c . Object APIClient . Inspect Object ( c . Ctx ( ) , & pfs . Object { Hash : hash } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return value , nil } 
func ( c APIClient ) Get Tag ( tag string , writer io . Writer ) error { get Tag Client , err : = c . Object APIClient . Get Tag ( c . Ctx ( ) , & pfs . Tag { Name : tag } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = grpcutil . Write From Streaming Bytes Client ( get Tag Client , writer ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Get Tag Reader ( tag string ) ( io . Read Closer , error ) { ctx , cancel : = context . With Cancel ( c . Ctx ( ) ) get Tag Client , err : = c . Object APIClient . Get Tag ( ctx , & pfs . Tag { Name : tag } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return grpcutil . New Streaming Bytes Reader ( get Tag Client , cancel ) , nil } 
func ( c APIClient ) Read Tag ( tag string ) ( [ ] byte , error ) { var buffer bytes . Buffer if err : = c . Get Tag ( tag , & buffer ) ; err ! = nil { return nil , err } return buffer . Bytes ( ) , nil } 
func ( c APIClient ) List Tag ( f func ( * pfs . List Tags Response ) error ) error { list Tag Client , err : = c . Object APIClient . List Tags ( c . Ctx ( ) , & pfs . List Tags Request { Include Object : true } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { list Tag Response , err : = list Tag Client . Recv ( ) if err ! = nil { if err = = io . EOF { return nil } return grpcutil . Scrub GRPC ( err ) } if err : = f ( list Tag Response ) ; err ! = nil { return err } } } 
func ( c APIClient ) Compact ( ) error { _ , err : = c . Object APIClient . Compact ( c . Ctx ( ) , & types . Empty { } , ) return err } 
func ( c APIClient ) New Put File Client ( ) ( Put File Client , error ) { pfc , err : = c . Pfs APIClient . Put File ( c . Ctx ( ) ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return & put File Client { c : pfc } , nil } 
func ( c * put File Client ) Put File Writer ( repo Name , commit ID , path string ) ( io . Write Closer , error ) { return c . new Put File Write Closer ( repo Name , commit ID , path , pfs . Delimiter _NONE , 0 , 0 , 0 , nil ) } 
func ( c * put File Client ) Put File Split Writer ( repo Name string , commit ID string , path string , delimiter pfs . Delimiter , target File Datums int 6 4 , target File Bytes int 6 4 , header Records int 6 4 , overwrite bool ) ( io . Write Closer , error ) { if overwrite { overwrite Index = & pfs . Overwrite Index { } } return c . new Put File Write Closer ( repo Name , commit ID , path , delimiter , target File Datums , target File Bytes , header Records , overwrite Index ) } 
func ( c * put File Client ) Put File ( repo Name string , commit ID string , path string , reader io . Reader ) ( _ int , ret Err error ) { return c . Put File Split ( repo Name , commit ID , path , pfs . Delimiter _NONE , 0 , 0 , 0 , false , reader ) } 
func ( c * put File Client ) Put File Overwrite ( repo Name string , commit ID string , path string , reader io . Reader , overwrite Index int 6 4 ) ( _ int , ret Err error ) { writer , err : = c . new Put File Write Closer ( repo Name , commit ID , path , pfs . Delimiter _NONE , 0 , 0 , 0 , & pfs . Overwrite Index { Index : overwrite Index } ) if err ! = nil { return 0 , grpcutil . Scrub GRPC ( err ) } defer func ( ) { if err : = writer . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) written , err : = io . Copy ( writer , reader ) return int ( written ) , grpcutil . Scrub GRPC ( err ) } 
func ( c * put File Client ) Put File Split ( repo Name string , commit ID string , path string , delimiter pfs . Delimiter , target File Datums int 6 4 , target File Bytes int 6 4 , header Records int 6 4 , overwrite bool , reader io . Reader ) ( _ int , ret Err error ) { writer , err : = c . Put File Split Writer ( repo Name , commit ID , path , delimiter , target File Datums , target File Bytes , header Records , overwrite ) if err ! = nil { return 0 , grpcutil . Scrub GRPC ( err ) } defer func ( ) { if err : = writer . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) buf : = grpcutil . Get Buffer ( ) defer grpcutil . Put Buffer ( buf ) written , err : = io . Copy Buffer ( writer , reader , buf ) return int ( written ) , grpcutil . Scrub GRPC ( err ) } 
func ( c * put File Client ) Put File URL ( repo Name string , commit ID string , path string , url string , recursive bool , overwrite bool ) ( ret Err error ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) var overwrite Index * pfs . Overwrite Index if overwrite { overwrite Index = & pfs . Overwrite Index { } } if c . oneoff { defer func ( ) { if err : = grpcutil . Scrub GRPC ( c . Close ( ) ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) } if err : = c . c . Send ( & pfs . Put File Request { File : New File ( repo Name , commit ID , path ) , Url : url , Recursive : recursive , Overwrite Index : overwrite Index , } ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c * put File Client ) Close ( ) error { _ , err : = c . c . Close And Recv ( ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Put File Writer ( repo Name string , commit ID string , path string ) ( io . Write Closer , error ) { pfc , err : = c . new Oneoff Put File Client ( ) if err ! = nil { return nil , err } return pfc . Put File Writer ( repo Name , commit ID , path ) } 
func ( c APIClient ) Put File Split Writer ( repo Name string , commit ID string , path string , delimiter pfs . Delimiter , target File Datums int 6 4 , target File Bytes int 6 4 , header Records int 6 4 , overwrite bool ) ( io . Write Closer , error ) { pfc , err : = c . new Oneoff Put File Client ( ) if err ! = nil { return nil , err } return pfc . Put File Split Writer ( repo Name , commit ID , path , delimiter , target File Datums , target File Bytes , header Records , overwrite ) } 
func ( c APIClient ) Put File ( repo Name string , commit ID string , path string , reader io . Reader ) ( _ int , ret Err error ) { pfc , err : = c . new Oneoff Put File Client ( ) if err ! = nil { return 0 , err } return pfc . Put File ( repo Name , commit ID , path , reader ) } 
func ( c APIClient ) Put File Split ( repo Name string , commit ID string , path string , delimiter pfs . Delimiter , target File Datums int 6 4 , target File Bytes int 6 4 , header Records int 6 4 , overwrite bool , reader io . Reader ) ( _ int , ret Err error ) { if err ! = nil { return 0 , err } return pfc . Put File Split ( repo Name , commit ID , path , delimiter , target File Datums , target File Bytes , header Records , overwrite , reader ) } 
func ( c APIClient ) Put File URL ( repo Name string , commit ID string , path string , url string , recursive bool , overwrite bool ) ( ret Err error ) { pfc , err : = c . new Oneoff Put File Client ( ) if err ! = nil { return err } return pfc . Put File URL ( repo Name , commit ID , path , url , recursive , overwrite ) } 
func ( c APIClient ) Copy File ( src Repo , src Commit , src Path , dst Repo , dst Commit , dst Path string , overwrite bool ) error { if _ , err : = c . Pfs APIClient . Copy File ( c . Ctx ( ) , & pfs . Copy File Request { Src : New File ( src Repo , src Commit , src Path ) , Dst : New File ( dst Repo , dst Commit , dst Path ) , Overwrite : overwrite , } ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Get File ( repo Name string , commit ID string , path string , offset int 6 4 , size int 6 4 , writer io . Writer ) error { if c . limiter ! = nil { c . limiter . Acquire ( ) defer c . limiter . Release ( ) } api Get File Client , err : = c . get File ( repo Name , commit ID , path , offset , size ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = grpcutil . Write From Streaming Bytes Client ( api Get File Client , writer ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Get File Reader ( repo Name string , commit ID string , path string , offset int 6 4 , size int 6 4 ) ( io . Reader , error ) { api Get File Client , err : = c . get File ( repo Name , commit ID , path , offset , size ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return grpcutil . New Streaming Bytes Reader ( api Get File Client , nil ) , nil } 
func ( c APIClient ) Get File Read Seeker ( repo Name string , commit ID string , path string ) ( io . Read Seeker , error ) { file Info , err : = c . Inspect File ( repo Name , commit ID , path ) if err ! = nil { return nil , err } reader , err : = c . Get File Reader ( repo Name , commit ID , path , 0 , 0 ) if err ! = nil { return nil , err } return & get File Read Seeker { Reader : reader , file : New File ( repo Name , commit ID , path ) , offset : 0 , size : int 6 4 ( file Info . Size Bytes ) , c : c , } , nil } 
func ( c APIClient ) Inspect File ( repo Name string , commit ID string , path string ) ( * pfs . File Info , error ) { return c . inspect File ( repo Name , commit ID , path ) } 
func ( c APIClient ) List File ( repo Name string , commit ID string , path string ) ( [ ] * pfs . File Info , error ) { var result [ ] * pfs . File Info if err : = c . List File F ( repo Name , commit ID , path , 0 , func ( fi * pfs . File Info ) error { result = append ( result , fi ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) List File History ( repo Name string , commit ID string , path string , history int 6 4 ) ( [ ] * pfs . File Info , error ) { var result [ ] * pfs . File Info if err : = c . List File F ( repo Name , commit ID , path , history , func ( fi * pfs . File Info ) error { result = append ( result , fi ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) List File F ( repo Name string , commit ID string , path string , history int 6 4 , f func ( fi * pfs . File Info ) error ) error { fs , err : = c . Pfs APIClient . List File Stream ( c . Ctx ( ) , & pfs . List File Request { File : New File ( repo Name , commit ID , path ) , History : history , } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { fi , err : = fs . Recv ( ) if err = = io . EOF { return nil } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( fi ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } } 
func ( c APIClient ) Glob File ( repo Name string , commit ID string , pattern string ) ( [ ] * pfs . File Info , error ) { fs , err : = c . Pfs APIClient . Glob File Stream ( c . Ctx ( ) , & pfs . Glob File Request { Commit : New Commit ( repo Name , commit ID ) , Pattern : pattern , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } var result [ ] * pfs . File Info for { f , err : = fs . Recv ( ) if err = = io . EOF { break } else if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } result = append ( result , f ) } return result , nil } 
func ( c APIClient ) Glob File F ( repo Name string , commit ID string , pattern string , f func ( fi * pfs . File Info ) error ) error { fs , err : = c . Pfs APIClient . Glob File Stream ( c . Ctx ( ) , & pfs . Glob File Request { Commit : New Commit ( repo Name , commit ID ) , Pattern : pattern , } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { fi , err : = fs . Recv ( ) if err = = io . EOF { return nil } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( fi ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } } 
func ( c APIClient ) Diff File ( new Repo Name , new Commit ID , new Path , old Repo Name , old Commit ID , old Path string , shallow bool ) ( [ ] * pfs . File Info , [ ] * pfs . File Info , error ) { var old File * pfs . File if old Repo Name ! = " " { old File = New File ( old Repo Name , old Commit ID , old Path ) } resp , err : = c . Pfs APIClient . Diff File ( c . Ctx ( ) , & pfs . Diff File Request { New File : New File ( new Repo Name , new Commit ID , new Path ) , Old File : old File , Shallow : shallow , } , ) if err ! = nil { return nil , nil , grpcutil . Scrub GRPC ( err ) } return resp . New Files , resp . Old Files , nil } 
func ( c APIClient ) Walk ( repo Name string , commit ID string , path string , f Walk Fn ) error { fs , err : = c . Pfs APIClient . Walk File ( c . Ctx ( ) , & pfs . Walk File Request { File : New File ( repo Name , commit ID , path ) } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { fi , err : = fs . Recv ( ) if err = = io . EOF { return nil } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( fi ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } } 
func ( c APIClient ) Delete File ( repo Name string , commit ID string , path string ) error { _ , err : = c . Pfs APIClient . Delete File ( c . Ctx ( ) , & pfs . Delete File Request { File : New File ( repo Name , commit ID , path ) , } , ) return err } 
func ( w * Put Object Write Closer Async ) Write ( p [ ] byte ) ( int , error ) { select { case err : = < - w . err Chan : if err ! = nil { return 0 , grpcutil . Scrub GRPC ( err ) } default : for len ( w . buf ) + len ( p ) > cap ( w . buf ) { w . buf = append ( w . buf , p [ : i ] . . . ) p = p [ i : ] w . write Chan < - w . buf w . buf = grpcutil . Get Buffer ( ) [ : 0 ] } w . buf = append ( w . buf , p . . . ) } return len ( p ) , nil } 
func ( w * Put Object Write Closer Async ) Close ( ) error { w . write Chan < - w . buf close ( w . write Chan ) err : = < - w . err Chan if err ! = nil { return grpcutil . Scrub GRPC ( err ) } w . object , err = w . client . Close And Recv ( ) return grpcutil . Scrub GRPC ( err ) } 
func ( w * Put Object Write Closer Async ) Object ( ) ( * pfs . Object , error ) { select { case err : = < - w . err Chan : if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return w . object , nil default : return nil , fmt . Errorf ( " " ) } } 
func Pretty Print Version ( version * pb . Version ) string { result : = Pretty Print Version No Additional ( version ) if version . Additional ! = " " { result + = fmt . Sprintf ( " " , version . Additional ) } return result } 
func Pretty Print Version No Additional ( version * pb . Version ) string { return fmt . Sprintf ( " " , version . Major , version . Minor , version . Micro ) } 
func recursive Block Quote Examples ( parent * cobra . Command ) { if parent . Example ! = " " { parent . Example = fmt . Sprintf ( " \n \n " , parent . Example ) } for _ , cmd : = range parent . Commands ( ) { recursive Block Quote Examples ( cmd ) } } 
func err Missing Field ( field string ) * logical . Response { return logical . Error Response ( fmt . Sprintf ( " " , field ) ) } 
func validate Fields ( req * logical . Request , data * framework . Field Data ) error { var unknown Fields [ ] string for k : = range req . Data { if _ , ok : = data . Schema [ k ] ; ! ok { unknown Fields = append ( unknown Fields , k ) } } if len ( unknown Fields ) > 0 { return fmt . Errorf ( " " , unknown Fields ) } return nil } 
func put Config ( ctx context . Context , s logical . Storage , cfg * config ) error { entry , err : = logical . Storage Entry JSON ( " " , cfg ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = s . Put ( ctx , entry ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func get Config ( ctx context . Context , s logical . Storage ) ( * config , error ) { entry , err : = s . Get ( ctx , " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if entry = = nil | | len ( entry . Value ) = = 0 { return nil , errors . New ( " " ) } var result config if err : = entry . Decode JSON ( & result ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & result , nil } 
func get String Field ( data * framework . Field Data , key string ) ( string , * logical . Response ) { value Iface , ok , err : = data . Get Ok Err ( key ) if err ! = nil { return " " , logical . Error Response ( fmt . Sprintf ( " " , err , key ) ) } } value , ok : = value Iface . ( string ) if ! ok { return " " , logical . Error Response ( fmt . Sprintf ( " " , key , value Iface ) ) } return value , nil } 
func Serve ( servers . . . Server Options , ) ( ret Err error ) { for _ , server : = range servers { if server . Register Func = = nil { return Err Must Specify Register Func } if server . Port = = 0 { return Err Must Specify Port } opts : = [ ] grpc . Server Option { grpc . Max Concurrent Streams ( math . Max Uint 3 2 ) , grpc . Max Recv Msg Size ( server . Max Msg Size ) , grpc . Max Send Msg Size ( server . Max Msg Size ) , grpc . Keepalive Enforcement Policy ( keepalive . Enforcement Policy { Min Time : 5 * time . Second , Permit Without Stream : true , } ) , grpc . Unary Interceptor ( tracing . Unary Server Interceptor ( ) ) , grpc . Stream Interceptor ( tracing . Stream Server Interceptor ( ) ) , } if server . Public Port TLSAllowed { key Path : = path . Join ( TLSVolume Path , TLSKey File ) _ , cert Path Stat Err : = os . Stat ( cert Path ) _ , key Path Stat Err : = os . Stat ( key Path ) if cert Path Stat Err ! = nil { log . Warnf ( " " , cert Path , cert Path Stat Err ) } if key Path Stat Err ! = nil { log . Warnf ( " " , key Path , key Path Stat Err ) } if cert Path Stat Err = = nil & & key Path Stat Err = = nil { if err ! = nil { return fmt . Errorf ( " " , err ) } opts = append ( opts , grpc . Creds ( transport Creds ) ) } } grpc Server : = grpc . New Server ( opts . . . ) if err : = server . Register Func ( grpc Server ) ; err ! = nil { return err } listener , err : = net . Listen ( " " , fmt . Sprintf ( " " , server . Port ) ) if err ! = nil { return err } if server . Cancel ! = nil { go func ( ) { < - server . Cancel if err : = listener . Close ( ) ; err ! = nil { fmt . Printf ( " \n " , err ) } } ( ) } if err : = grpc Server . Serve ( listener ) ; err ! = nil { return err } } return nil } 
func New Puller ( ) * Puller { return & Puller { err Ch : make ( chan error , 1 ) , pipes : make ( map [ string ] bool ) , } } 
func ( p * Puller ) Pull ( client * pachclient . APIClient , root string , repo , commit , file string , pipes bool , empty Files bool , concurrency int , stats Tree * hashtree . Ordered , stats Root string ) error { limiter : = limit . New ( concurrency ) var eg errgroup . Group if err : = client . Walk ( repo , commit , file , func ( file Info * pfs . File Info ) error { basepath , err : = filepath . Rel ( file , file Info . File . Path ) if err ! = nil { return err } if stats Tree ! = nil { stats Path : = filepath . Join ( stats Root , basepath ) if file Info . File Type = = pfs . File Type _DIR { stats Tree . Put Dir ( stats Path ) } else { var block Refs [ ] * pfs . Block Ref for _ , object : = range file Info . Objects { object Info , err : = client . Inspect Object ( object . Hash ) if err ! = nil { return err } block Refs = append ( block Refs , object Info . Block Ref ) } block Refs = append ( block Refs , file Info . Block Refs . . . ) stats Tree . Put File ( stats Path , file Info . Hash , int 6 4 ( file Info . Size Bytes ) , & hashtree . File Node Proto { Block Refs : block Refs } ) } } path : = filepath . Join ( root , basepath ) if file Info . File Type = = pfs . File Type _DIR { return os . Mkdir All ( path , 0 7 0 0 ) } if pipes { return p . make Pipe ( path , func ( w io . Writer ) error { return client . Get File ( repo , commit , file Info . File . Path , 0 , 0 , w ) } ) } if empty Files { return p . make File ( path , func ( w io . Writer ) error { return nil } ) } eg . Go ( func ( ) ( ret Err error ) { limiter . Acquire ( ) defer limiter . Release ( ) return p . make File ( path , func ( w io . Writer ) error { return client . Get File ( repo , commit , file Info . File . Path , 0 , 0 , w ) } ) } ) return nil } ) ; err ! = nil { return err } return eg . Wait ( ) } 
func ( p * Puller ) Pull Diff ( client * pachclient . APIClient , root string , new Repo , new Commit , new Path , old Repo , old Commit , old Path string , new Only bool , pipes bool , empty Files bool , concurrency int , tree hashtree . Hash Tree , tree Root string ) error { limiter : = limit . New ( concurrency ) var eg errgroup . Group new Files , old Files , err : = client . Diff File ( new Repo , new Commit , new Path , old Repo , old Commit , old Path , false ) if err ! = nil { return err } for _ , new File : = range new Files { basepath , err : = filepath . Rel ( new Path , new File . File . Path ) if err ! = nil { return err } if tree ! = nil { tree Path : = path . Join ( tree Root , " " , basepath ) if new Only { tree Path = path . Join ( tree Root , basepath ) } if err : = tree . Put File ( tree Path , new File . Objects , int 6 4 ( new File . Size Bytes ) ) ; err ! = nil { return err } } path : = filepath . Join ( root , " " , basepath ) if new Only { path = filepath . Join ( root , basepath ) } if pipes { if err : = p . make Pipe ( path , func ( w io . Writer ) error { return client . Get File ( new File . File . Commit . Repo . Name , new File . File . Commit . ID , new File . File . Path , 0 , 0 , w ) } ) ; err ! = nil { return err } } else if empty Files { if err : = p . make File ( path , func ( w io . Writer ) error { return nil } ) ; err ! = nil { return err } } else { new File : = new File limiter . Acquire ( ) eg . Go ( func ( ) error { defer limiter . Release ( ) return p . make File ( path , func ( w io . Writer ) error { return client . Get File ( new File . File . Commit . Repo . Name , new File . File . Commit . ID , new File . File . Path , 0 , 0 , w ) } ) } ) } } if ! new Only { for _ , old File : = range old Files { basepath , err : = filepath . Rel ( old Path , old File . File . Path ) if err ! = nil { return err } if tree ! = nil { tree Path : = path . Join ( tree Root , " " , basepath ) if err : = tree . Put File ( tree Path , old File . Objects , int 6 4 ( old File . Size Bytes ) ) ; err ! = nil { return err } } path : = filepath . Join ( root , " " , basepath ) if pipes { if err : = p . make Pipe ( path , func ( w io . Writer ) error { return client . Get File ( old File . File . Commit . Repo . Name , old File . File . Commit . ID , old File . File . Path , 0 , 0 , w ) } ) ; err ! = nil { return err } } else { old File : = old File limiter . Acquire ( ) eg . Go ( func ( ) error { defer limiter . Release ( ) return p . make File ( path , func ( w io . Writer ) error { return client . Get File ( old File . File . Commit . Repo . Name , old File . File . Commit . ID , old File . File . Path , 0 , 0 , w ) } ) } ) } } } return eg . Wait ( ) } 
func ( p * Puller ) Pull Tree ( client * pachclient . APIClient , root string , tree hashtree . Hash Tree , pipes bool , concurrency int ) error { limiter : = limit . New ( concurrency ) var eg errgroup . Group if err : = tree . Walk ( " " , func ( path string , node * hashtree . Node Proto ) error { if node . File Node ! = nil { path : = filepath . Join ( root , path ) var hashes [ ] string for _ , object : = range node . File Node . Objects { hashes = append ( hashes , object . Hash ) } if pipes { return p . make Pipe ( path , func ( w io . Writer ) error { return client . Get Objects ( hashes , 0 , 0 , uint 6 4 ( node . Subtree Size ) , w ) } ) } limiter . Acquire ( ) eg . Go ( func ( ) ( ret Err error ) { defer limiter . Release ( ) return p . make File ( path , func ( w io . Writer ) error { return client . Get Objects ( hashes , 0 , 0 , uint 6 4 ( node . Subtree Size ) , w ) } ) } ) } return nil } ) ; err ! = nil { return err } return eg . Wait ( ) } 
func ( p * Puller ) Clean Up ( ) ( int 6 4 , error ) { var result error select { case result = < - p . err Ch : default : } func ( ) { p . Lock ( ) defer p . Unlock ( ) p . cleaned = true for path : = range p . pipes { f , err : = os . Open File ( path , syscall . O _NONBLOCK + os . O _RDONLY , os . Mode Named Pipe ) if err ! = nil & & result = = nil { result = err } pipes = append ( pipes , f ) } p . pipes = make ( map [ string ] bool ) } ( ) } } size : = p . size p . size = 0 return size , result } 
func Push ( client * pachclient . APIClient , root string , commit * pfs . Commit , overwrite bool ) error { var g errgroup . Group if err : = filepath . Walk ( root , func ( path string , info os . File Info , err error ) error { g . Go ( func ( ) ( ret Err error ) { if path = = root | | info . Is Dir ( ) { return nil } f , err : = os . Open ( path ) if err ! = nil { return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) rel Path , err : = filepath . Rel ( root , path ) if err ! = nil { return err } if overwrite { if err : = client . Delete File ( commit . Repo . Name , commit . ID , rel Path ) ; err ! = nil { return err } } _ , err = client . Put File ( commit . Repo . Name , commit . ID , rel Path , f ) return err } ) return nil } ) ; err ! = nil { return err } return g . Wait ( ) } 
func Push Obj ( pach Client * pachclient . APIClient , commit * pfs . Commit , obj Client obj . Client , root string ) error { var eg errgroup . Group sem : = make ( chan struct { } , 2 0 0 ) if err : = pach Client . Walk ( commit . Repo . Name , commit . ID , " " , func ( file Info * pfs . File Info ) error { if file Info . File Type ! = pfs . File Type _FILE { return nil } eg . Go ( func ( ) ( ret Err error ) { sem < - struct { } { } defer func ( ) { < - sem } ( ) w , err : = obj Client . Writer ( pach Client . Ctx ( ) , filepath . Join ( root , file Info . File . Path ) ) if err ! = nil { return err } defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return pach Client . Get File ( commit . Repo . Name , commit . ID , file Info . File . Path , 0 , 0 , w ) } ) return nil } ) ; err ! = nil { return err } return eg . Wait ( ) } 
func Push File ( c * pachclient . APIClient , pfc pachclient . Put File Client , pfs File * pfs . File , os File io . Read Seeker ) error { file Info , err : = c . Inspect File ( pfs File . Commit . Repo . Name , pfs File . Commit . ID , pfs File . Path ) if err ! = nil & & ! is Not Exist ( err ) { return err } var i int var object * pfs . Object if file Info ! = nil { for i , object = range file Info . Objects { hash : = pfs . New Hash ( ) if _ , err : = io . Copy N ( hash , os File , pfs . Chunk Size ) ; err ! = nil { if err = = io . EOF { break } return err } if object . Hash ! = pfs . Encode Hash ( hash . Sum ( nil ) ) { break } } } if _ , err : = os File . Seek ( int 6 4 ( i ) * pfs . Chunk Size , 0 ) ; err ! = nil { return err } _ , err = pfc . Put File Overwrite ( pfs File . Commit . Repo . Name , pfs File . Commit . ID , pfs File . Path , os File , int 6 4 ( i ) ) return err } 
func ( c APIClient ) Dump ( w io . Writer ) error { goro Client , err : = c . Debug Client . Dump ( c . Ctx ( ) , & debug . Dump Request { } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } return grpcutil . Scrub GRPC ( grpcutil . Write From Streaming Bytes Client ( goro Client , w ) ) } 
func ( c APIClient ) Profile ( profile string , duration time . Duration , w io . Writer ) error { var d * types . Duration if duration ! = 0 { d = types . Duration Proto ( duration ) } profile Client , err : = c . Debug Client . Profile ( c . Ctx ( ) , & debug . Profile Request { Profile : profile , Duration : d , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } return grpcutil . Scrub GRPC ( grpcutil . Write From Streaming Bytes Client ( profile Client , w ) ) } 
func ( c APIClient ) Binary ( w io . Writer ) error { binary Client , err : = c . Debug Client . Binary ( c . Ctx ( ) , & debug . Binary Request { } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } return grpcutil . Scrub GRPC ( grpcutil . Write From Streaming Bytes Client ( binary Client , w ) ) } 
func Register Cache Stats ( cache Name string , group Cache Stats * groupcache . Stats ) { c : = & cache Stats { cache Name : cache Name , descriptions : make ( map [ string ] * prometheus . Desc ) , stats : group Cache Stats , } if err : = prometheus . Register ( c ) ; err ! = nil { } } } 
func ( c * counter ) wait ( n int 6 4 ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) for c . n < n { c . cond . Wait ( ) } } 
func ( c * counter ) cancel ( ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) c . n = math . Max Int 6 4 } 
func Run Workload ( client * client . APIClient , rand * rand . Rand , size int , ) error { worker : = new Worker ( rand ) for i : = 0 ; i < size ; i + + { if err : = worker . work ( client ) ; err ! = nil { return err } } for _ , job : = range worker . started Jobs { job Info , err : = client . Inspect Job ( job . ID , true ) if err ! = nil { return err } if job Info . State ! = pps . Job State _JOB _SUCCESS { return fmt . Errorf ( " " , job . ID ) } } return nil } 
func ( w * worker ) create Repo ( c * client . APIClient ) error { repo Name : = w . rand String ( 1 0 ) if err : = c . Create Repo ( repo Name ) ; err ! = nil { return err } w . repos = append ( w . repos , & pfs . Repo { Name : repo Name } ) if err ! = nil { return err } w . started = append ( w . started , commit ) return nil } 
func ( w * worker ) advance Commit ( c * client . APIClient ) error { if len ( w . started ) > = max Started Commits | | len ( w . finished ) = = 0 { } i : = w . rand . Intn ( len ( w . started ) ) commit : = w . started [ i ] } if err : = c . Finish Commit ( commit . Repo . Name , commit . ID ) ; err ! = nil { return err } w . finished = append ( w . finished , commit ) } else { commit , err : = c . Start Commit Parent ( commit . Repo . Name , " " , commit . ID ) if err ! = nil { return err } w . started = append ( w . started , commit ) } return nil } 
func ( w * worker ) put File ( c * client . APIClient ) error { if len ( w . started ) = = 0 { return nil } commit : = w . started [ w . rand . Intn ( len ( w . started ) ) ] if _ , err : = c . Put File ( commit . Repo . Name , commit . ID , w . rand String ( 1 0 ) , w . reader ( ) ) ; err ! = nil { return err } return nil } 
func Rand String ( r * rand . Rand , n int ) string { b : = make ( [ ] byte , n ) for i : = range b { b [ i ] = letters [ r . Intn ( len ( letters ) ) ] } return string ( b ) } 
func New Reader ( rand * rand . Rand , bytes int 6 4 ) io . Reader { return & reader { rand : rand , bytes : bytes , } } 
func New DBHash Tree ( storage Root string ) ( Hash Tree , error ) { file : = db File ( storage Root ) if err : = os . Mkdir All ( pathlib . Dir ( file ) , 0 7 7 7 ) ; err ! = nil { return nil , err } result , err : = new DBHash Tree ( file ) if err ! = nil { return nil , err } if err : = result . Put Dir ( " " ) ; err ! = nil { return nil , err } return result , err } 
func Deserialize DBHash Tree ( storage Root string , r io . Reader ) ( _ Hash Tree , ret Err error ) { result , err : = New DBHash Tree ( storage Root ) if err ! = nil { return nil , err } if err : = result . Deserialize ( r ) ; err ! = nil { return nil , err } return result , nil } 
func ( h * db Hash Tree ) Get ( path string ) ( * Node Proto , error ) { path = clean ( path ) var node * Node Proto if err : = h . View ( func ( tx * bolt . Tx ) error { var err error node , err = get ( tx , path ) return err } ) ; err ! = nil { return nil , err } return node , nil } 
func Get ( rs [ ] io . Read Closer , file Path string ) ( * Node Proto , error ) { file Path = clean ( file Path ) var file Node * Node Proto if err : = nodes ( rs , func ( path string , node * Node Proto ) error { if path = = file Path { file Node = node } return nil } ) ; err ! = nil { return nil , err } if file Node = = nil { return nil , errorf ( Path Not Found , " \ " \ " " , file Path ) } return file Node , nil } 
func iter Dir ( tx * bolt . Tx , path string , f func ( k , v [ ] byte , c * bolt . Cursor ) error ) error { node , err : = get ( tx , path ) if err ! = nil { return err } if node . Dir Node = = nil { return errorf ( Path Conflict , " \ " \ " " , path ) } c : = New Child Cursor ( tx , path ) for k , v : = c . K ( ) , c . V ( ) ; k ! = nil ; k , v = c . Next ( ) { if err : = f ( k , v , c . c ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } return nil } 
func ( h * db Hash Tree ) List ( path string , f func ( * Node Proto ) error ) error { path = clean ( path ) return h . View ( func ( tx * bolt . Tx ) error { return list ( tx , path , f ) } ) } 
func ( h * db Hash Tree ) List All ( path string ) ( [ ] * Node Proto , error ) { var result [ ] * Node Proto if err : = h . List ( path , func ( node * Node Proto ) error { result = append ( result , node ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func List ( rs [ ] io . Read Closer , pattern string , f func ( string , * Node Proto ) error ) ( ret Err error ) { pattern = clean ( pattern ) if pattern = = " " { pattern = " " } g , err : = globlib . Compile ( pattern , ' / ' ) if err ! = nil { return errorf ( Malformed Glob , err . Error ( ) ) } return nodes ( rs , func ( path string , node * Node Proto ) error { if ( g . Match ( path ) & & node . Dir Node = = nil ) | | ( g . Match ( pathlib . Dir ( path ) ) ) { return f ( path , node ) } return nil } ) } 
func ( h * db Hash Tree ) Glob ( pattern string , f func ( string , * Node Proto ) error ) error { pattern = clean ( pattern ) return h . View ( func ( tx * bolt . Tx ) error { return glob ( tx , pattern , f ) } ) } 
func Glob ( rs [ ] io . Read Closer , pattern string , f func ( string , * Node Proto ) error ) ( ret Err error ) { pattern = clean ( pattern ) g , err : = globlib . Compile ( pattern , ' / ' ) if err ! = nil { return errorf ( Malformed Glob , err . Error ( ) ) } return nodes ( rs , func ( path string , node * Node Proto ) error { if g . Match ( path ) { return f ( external Default ( path ) , node ) } return nil } ) } 
func ( h * db Hash Tree ) FSSize ( ) int 6 4 { root Node , err : = h . Get ( " " ) if err ! = nil { return 0 } return root Node . Subtree Size } 
func ( h * db Hash Tree ) Walk ( path string , f func ( path string , node * Node Proto ) error ) error { path = clean ( path ) return h . View ( func ( tx * bolt . Tx ) error { c : = fs ( tx ) . Cursor ( ) for k , v : = c . Seek ( b ( path ) ) ; k ! = nil & & strings . Has Prefix ( s ( k ) , path ) ; k , v = c . Next ( ) { node : = & Node Proto { } if err : = node . Unmarshal ( v ) ; err ! = nil { return err } node Path : = s ( k ) if node Path = = " " { node Path = " " } if node Path ! = path & & ! strings . Has Prefix ( node Path , path + " " ) { } if err : = f ( node Path , node ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } return nil } ) } 
func Walk ( rs [ ] io . Read Closer , walk Path string , f func ( path string , node * Node Proto ) error ) error { walk Path = clean ( walk Path ) return nodes ( rs , func ( path string , node * Node Proto ) error { if path = = " " { path = " " } if path ! = walk Path & & ! strings . Has Prefix ( path , walk Path + " " ) { return nil } if err : = f ( path , node ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } return nil } ) } 
func ( h * db Hash Tree ) Diff ( old Hash Tree Hash Tree , new Path string , old Path string , recursive Depth int 6 4 , f func ( path string , node * Node Proto , new bool ) error ) ( ret Err error ) { if old = = nil { return fmt . Errorf ( " " ) } rollback : = func ( tx * bolt . Tx ) { if err : = tx . Rollback ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } var new Tx * bolt . Tx var old Tx * bolt . Tx if h = = old Hash Tree { tx , err : = h . Begin ( false ) if err ! = nil { return err } new Tx = tx old Tx = tx defer rollback ( tx ) } else { var err error new Tx , err = h . Begin ( false ) if err ! = nil { return err } defer rollback ( new Tx ) old Tx , err = old . Begin ( false ) if err ! = nil { return err } defer rollback ( old Tx ) } return diff ( new Tx , old Tx , new Path , old Path , recursive Depth , f ) } 
func ( h * db Hash Tree ) Serialize ( _w io . Writer ) error { w : = pbutil . New Writer ( _w ) return h . View ( func ( tx * bolt . Tx ) error { for _ , bucket : = range buckets { b : = tx . Bucket ( b ( bucket ) ) if _ , err : = w . Write ( & Bucket Header { Bucket : bucket , } ) ; err ! = nil { return err } if err : = b . For Each ( func ( k , v [ ] byte ) error { if _ , err : = w . Write Bytes ( k ) ; err ! = nil { return err } _ , err : = w . Write Bytes ( v ) return err } ) ; err ! = nil { return err } if _ , err : = w . Write Bytes ( Sentinel Byte ) ; err ! = nil { return err } } return nil } ) } 
func ( h * db Hash Tree ) Deserialize ( _r io . Reader ) error { r : = pbutil . New Reader ( _r ) hdr : = & Bucket Header { } batch Size : = 1 0 0 0 0 kvs : = make ( chan * key Value , batch Size / 1 0 ) eg . Go ( func ( ) error { var bucket [ ] byte for { count : = 0 if err : = h . Update ( func ( tx * bolt . Tx ) error { if bucket ! = nil { tx . Bucket ( bucket ) . Fill Percent = 1 } for kv : = range kvs { if kv . k = = nil { bucket = kv . v continue } if err : = tx . Bucket ( bucket ) . Put ( kv . k , kv . v ) ; err ! = nil { return err } count + + if count > = batch Size { return nil } } return nil } ) ; err ! = nil | | copy Ctx . Err ( ) ! = nil { return err } if count < = 0 { return nil } } } ) eg . Go ( func ( ) error { defer close ( kvs ) for { hdr . Reset ( ) } return err } bucket : = b ( hdr . Bucket ) select { case kvs < - & key Value { nil , bucket } : case < - copy Ctx . Done ( ) : return nil } for { _k , err : = r . Read Bytes ( ) if err ! = nil { return err } if bytes . Equal ( _k , Sentinel Byte ) { break } copy ( k , _k ) _v , err : = r . Read Bytes ( ) if err ! = nil { return err } v : = make ( [ ] byte , len ( _v ) ) copy ( v , _v ) select { case kvs < - & key Value { k , v } : case < - copy Ctx . Done ( ) : return nil } } } return nil } ) return eg . Wait ( ) } 
func ( h * db Hash Tree ) Copy ( ) ( Hash Tree , error ) { if err : = h . Hash ( ) ; err ! = nil { return nil , err } r , w : = io . Pipe ( ) var eg errgroup . Group eg . Go ( func ( ) ( ret Err error ) { defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return h . Serialize ( w ) } ) var result Hash Tree eg . Go ( func ( ) error { var err error result , err = Deserialize DBHash Tree ( pathlib . Dir ( h . Path ( ) ) , r ) return err } ) if err : = eg . Wait ( ) ; err ! = nil { return nil , err } return result , nil } 
func ( h * db Hash Tree ) Destroy ( ) error { path : = h . Path ( ) if err : = h . Close ( ) ; err ! = nil { return err } return os . Remove ( path ) } 
func visit ( tx * bolt . Tx , path string , update update Fn ) error { for path ! = " " { parent , child : = split ( path ) pnode , err : = get ( tx , parent ) if err ! = nil & & Code ( err ) ! = Path Not Found { return err } if pnode ! = nil & & pnode . nodetype ( ) ! = directory { return errorf ( Path Conflict , " \ " \ " " + " " , path ) } if pnode = = nil { pnode = & Node Proto { } } if err : = update ( pnode , parent , child ) ; err ! = nil { return err } if err : = put ( tx , parent , pnode ) ; err ! = nil { return err } path = parent } return nil } 
func ( h * db Hash Tree ) Put File ( path string , objects [ ] * pfs . Object , size int 6 4 ) error { return h . put File ( path , objects , nil , size , false ) } 
func ( h * db Hash Tree ) Put File Overwrite ( path string , objects [ ] * pfs . Object , overwrite Index * pfs . Overwrite Index , size Delta int 6 4 ) error { return h . put File ( path , objects , overwrite Index , size Delta , false ) } 
func ( h * db Hash Tree ) Put Dir Header Footer ( path string , header , footer * pfs . Object , header Size , footer Size int 6 4 ) error { path = clean ( path ) return h . Batch ( func ( tx * bolt . Tx ) error { if err ! = nil & & Code ( err ) ! = Path Not Found { return errorf ( Internal , " " , path , err ) } if node ! = nil & & node . nodetype ( ) ! = directory { return errorf ( Path Conflict , " " + " " , path , node . nodetype ( ) ) } if node = = nil { new Node = true node = & Node Proto { Name : base ( path ) , Dir Node : & Directory Node Proto { Shared : & Shared { } , } , } footer Same : = ( node . Dir Node . Shared . Footer = = nil & & footer = = nil ) | | ( node . Dir Node . Shared . Footer ! = nil & & node . Dir Node . Shared . Footer . Hash = = footer . Hash ) if new Node | | ! header Same | | ! footer Same { node . Dir Node . Shared = & Shared { Header : header , Footer : footer , Header Size : header Size , Footer Size : footer Size , } return put ( tx , path , node ) } return nil } ) } 
func ( h * db Hash Tree ) Put File Header Footer ( path string , objects [ ] * pfs . Object , size int 6 4 ) error { return h . put File ( path , objects , nil , size , true ) } 
func ( h * db Hash Tree ) Put Dir ( path string ) error { path = clean ( path ) return h . Batch ( func ( tx * bolt . Tx ) error { node , err : = get ( tx , path ) if err ! = nil & & Code ( err ) ! = Path Not Found { return err } if node ! = nil { if node . nodetype ( ) = = directory { return nil } else if node . nodetype ( ) ! = none { return errorf ( Path Conflict , " \ " \ " " + " " , path , node . nodetype ( ) ) } } node = & Node Proto { Name : base ( path ) , Dir Node : & Directory Node Proto { } , } if err : = put ( tx , path , node ) ; err ! = nil { return err } return visit ( tx , path , func ( node * Node Proto , parent , child string ) error { if node . Dir Node = = nil { node . Dir Node = & Directory Node Proto { } } return nil } ) } ) } 
func delete Dir ( tx * bolt . Tx , path string ) error { c : = fs ( tx ) . Cursor ( ) prefix : = append ( b ( path ) , null Byte [ 0 ] ) for k , _ : = c . Seek ( prefix ) ; bytes . Has Prefix ( k , prefix ) ; k , _ = c . Next ( ) { if err : = c . Delete ( ) ; err ! = nil { return err } } return fs ( tx ) . Delete ( b ( path ) ) } 
func ( h * db Hash Tree ) Delete File ( path string ) error { path = clean ( path ) } return h . Batch ( func ( tx * bolt . Tx ) error { if err : = glob ( tx , path , func ( path string , node * Node Proto ) error { } } size : = node . Subtree Size pnode , err : = get ( tx , parent ) if err ! = nil { if Code ( err ) = = Path Not Found { return errorf ( Internal , " \ " \ " " , path ) } return err } if pnode . Dir Node = = nil { return errorf ( Internal , " \ " \ " \ " \ " " + " " , path , pnode . Dir Node ) } put ( tx , parent , pnode ) } node . Subtree Size - = size return nil } ) ; err ! = nil { return err } return nil } ) ; err ! = nil & & Code ( err ) ! = Path Not Found { } return nil } ) } 
func New Reader ( r io . Reader , filter Filter ) * Reader { return & Reader { pbr : pbutil . New Reader ( r ) , filter : filter , } } 
func ( r * Reader ) Read ( ) ( * Merge Node , error ) { _k , err : = r . pbr . Read Bytes ( ) if err ! = nil { return nil , err } if r . filter ! = nil { for { if r . filter ( _k ) { break } _ , err = r . pbr . Read Bytes ( ) if err ! = nil { return nil , err } _k , err = r . pbr . Read Bytes ( ) if err ! = nil { return nil , err } } } k : = make ( [ ] byte , len ( _k ) ) copy ( k , _k ) _v , err : = r . pbr . Read Bytes ( ) if err ! = nil { return nil , err } v : = make ( [ ] byte , len ( _v ) ) copy ( v , _v ) return & Merge Node { k : k , v : v , } , nil } 
func New Writer ( w io . Writer ) * Writer { return & Writer { pbw : pbutil . New Writer ( w ) , } } 
func ( w * Writer ) Write ( n * Merge Node ) error { n . v , err = n . node Proto . Marshal ( ) if err ! = nil { return err } } if err : = n . node Proto . Unmarshal ( n . v ) ; err ! = nil { return err } } w . size = uint 6 4 ( n . node Proto . Subtree Size ) } } b , err : = w . pbw . Write Bytes ( n . k ) if err ! = nil { return err } w . offset + = uint 6 4 ( b ) b , err = w . pbw . Write Bytes ( n . v ) if err ! = nil { return err } w . offset + = uint 6 4 ( b ) return nil } 
func ( w * Writer ) Copy ( r * Reader ) error { for { n , err : = r . Read ( ) if err ! = nil { if err = = io . EOF { return nil } return err } if err : = w . Write ( n ) ; err ! = nil { return err } } } 
func ( w * Writer ) Index ( ) ( [ ] byte , error ) { buf : = & bytes . Buffer { } pbw : = pbutil . New Writer ( buf ) for _ , idx : = range w . idxs { if _ , err : = pbw . Write ( idx ) ; err ! = nil { return nil , err } } return buf . Bytes ( ) , nil } 
func Get Range From Index ( r io . Reader , prefix string ) ( uint 6 4 , uint 6 4 , error ) { prefix = clean ( prefix ) pbr : = pbutil . New Reader ( r ) idx : = & Index { } k : = b ( prefix ) var lower , upper uint 6 4 iter : = func ( f func ( int ) bool ) error { for { if err : = pbr . Read ( idx ) ; err ! = nil { if err = = io . EOF { break } return err } var cmp int if len ( k ) < len ( idx . K ) { cmp = bytes . Compare ( k , idx . K [ : len ( k ) ] ) } else { cmp = bytes . Compare ( k [ : len ( idx . K ) ] , idx . K ) } if f ( cmp ) { break } } return nil } low : = func ( cmp int ) bool { if cmp > 0 { lower = idx . Offset return false } else if cmp < 0 { } return true } up : = func ( cmp int ) bool { if cmp < 0 { upper = idx . Offset return true } return false } } } } 
func New Filter ( num Trees int 6 4 , tree int 6 4 ) Filter { return func ( k [ ] byte ) bool { if path To Tree ( k , num Trees ) = = uint 6 4 ( tree ) { return true } return false } } 
func Path To Tree ( path string , num Trees int 6 4 ) uint 6 4 { path = clean ( path ) return path To Tree ( b ( path ) , num Trees ) } 
func Merge ( w * Writer , rs [ ] * Reader ) error { if len ( rs ) = = 0 { return nil } mq : = & merge PQ { q : make ( [ ] * node Stream , len ( rs ) + 1 ) } } } for mq . q [ 1 ] ! = nil { if err ! = nil { return err } if err ! = nil { return err } } } return nil } 
func Hash File Node ( n * File Node Proto ) [ ] byte { hash : = sha 2 5 6 . New ( ) } return hash . Sum ( nil ) } 
func ( h * db Hash Tree ) Hash ( ) error { return h . Batch ( func ( tx * bolt . Tx ) error { return canonicalize ( tx , " " ) } ) } 
func Is Glob ( pattern string ) bool { pattern = clean ( pattern ) return glob Regex . Match ( [ ] byte ( pattern ) ) } 
func Glob Literal Prefix ( pattern string ) string { pattern = clean ( pattern ) idx : = glob Regex . Find String Index ( pattern ) if idx = = nil { return pattern } return pattern [ : idx [ 0 ] ] } 
func Get Hash Tree Object ( pach Client * client . APIClient , storage Root string , tree Ref * pfs . Object ) ( Hash Tree , error ) { return get Hash Tree ( storage Root , func ( w io . Writer ) error { return pach Client . Get Object ( tree Ref . Hash , w ) } ) } 
func Get Hash Tree Tag ( pach Client * client . APIClient , storage Root string , tree Ref * pfs . Tag ) ( Hash Tree , error ) { return get Hash Tree ( storage Root , func ( w io . Writer ) error { return pach Client . Get Tag ( tree Ref . Name , w ) } ) } 
func Put Hash Tree ( pach Client * client . APIClient , tree Hash Tree , tags . . . string ) ( * pfs . Object , error ) { r , w : = io . Pipe ( ) var eg errgroup . Group eg . Go ( func ( ) ( ret Err error ) { defer func ( ) { if err : = w . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return tree . Serialize ( w ) } ) var tree Ref * pfs . Object eg . Go ( func ( ) error { var err error tree Ref , _ , err = pach Client . Put Object ( r , tags . . . ) return err } ) if err : = eg . Wait ( ) ; err ! = nil { return nil , err } return tree Ref , nil } 
func New Child Cursor ( tx * bolt . Tx , path string ) * Child Cursor { path = clean ( path ) c : = fs ( tx ) . Cursor ( ) dir : = b ( path ) k , v : = c . Seek ( append ( dir , null Byte [ 0 ] ) ) if ! bytes . Equal ( dir , null Byte ) { dir = append ( dir , null Byte [ 0 ] ) } if ! bytes . Has Prefix ( k , dir ) { k , v = nil , nil } return & Child Cursor { c : c , dir : dir , k : k , v : v , } } 
func ( d * Child Cursor ) Next ( ) ( [ ] byte , [ ] byte ) { if d . k = = nil { return nil , nil } k , v : = d . c . Seek ( append ( d . k , 1 ) ) if ! bytes . Has Prefix ( k , d . dir ) { k , v = nil , nil } d . k , d . v = k , v return k , v } 
func New Ordered ( root string ) * Ordered { root = clean ( root ) o : = & Ordered { } n : = & node { path : " " , node Proto : & Node Proto { Name : " " , Dir Node : & Directory Node Proto { } , } , hash : sha 2 5 6 . New ( ) , } o . fs = append ( o . fs , n ) o . dir Stack = append ( o . dir Stack , n ) o . Mkdir All ( root ) o . root = root return o } 
func ( o * Ordered ) Mkdir All ( path string ) { var paths [ ] string for path ! = " " { paths = append ( paths , path ) path , _ = split ( path ) } for i : = len ( paths ) - 1 ; i > = 0 ; i - - { o . Put Dir ( paths [ i ] ) } } 
func ( o * Ordered ) Put Dir ( path string ) { path = clean ( path ) if path = = " " { return } node Proto : = & Node Proto { Name : base ( path ) , Dir Node : & Directory Node Proto { } , } o . put Dir ( path , node Proto ) } 
func ( o * Ordered ) Put File ( path string , hash [ ] byte , size int 6 4 , file Node Proto * File Node Proto ) { path = clean ( path ) node Proto : = & Node Proto { Name : base ( path ) , Hash : hash , Subtree Size : size , File Node : file Node Proto , } o . put File ( path , node Proto ) } 
func ( o * Ordered ) Serialize ( _w io . Writer ) error { w : = New Writer ( _w ) child . node Proto . Hash = child . hash . Sum ( nil ) o . dir Stack = o . dir Stack [ : len ( o . dir Stack ) - 1 ] parent : = o . dir Stack [ len ( o . dir Stack ) - 1 ] parent . hash . Write ( [ ] byte ( fmt . Sprintf ( " " , child . node Proto . Name , child . node Proto . Hash ) ) ) parent . node Proto . Subtree Size + = child . node Proto . Subtree Size } o . fs [ 0 ] . node Proto . Hash = o . fs [ 0 ] . hash . Sum ( nil ) for _ , n : = range o . fs { if err : = w . Write ( & Merge Node { k : b ( n . path ) , node Proto : n . node Proto , } ) ; err ! = nil { return err } } return nil } 
func New Unordered ( root string ) * Unordered { return & Unordered { fs : make ( map [ string ] * Node Proto ) , root : clean ( root ) , } } 
func ( u * Unordered ) Put File ( path string , hash [ ] byte , size int 6 4 , block Refs . . . * pfs . Block Ref ) { path = join ( u . root , path ) node Proto : = & Node Proto { Name : base ( path ) , Hash : hash , Subtree Size : size , File Node : & File Node Proto { Block Refs : block Refs , } , } u . fs [ path ] = node Proto u . create Parents ( path ) } 
func ( u * Unordered ) Ordered ( ) * Ordered { paths : = make ( [ ] string , len ( u . fs ) ) i : = 0 for path : = range u . fs { paths [ i ] = path i + + } sort . Strings ( paths ) o : = New Ordered ( " " ) for i : = 1 ; i < len ( paths ) ; i + + { path : = paths [ i ] n : = u . fs [ path ] if n . Dir Node ! = nil { o . put Dir ( path , n ) } else { o . put File ( path , n ) } } return o } 
func ( b * backend ) Revoke ( ctx context . Context , req * logical . Request , data * framework . Field Data ) ( resp * logical . Response , ret Err error ) { b . Logger ( ) . Debug ( fmt . Sprintf ( " " , req . ID , req . Operation , req . Path ) ) defer func ( ) { b . Logger ( ) . Debug ( fmt . Sprintf ( " " , req . ID , req . Operation , req . Path , ret Err = = nil & & ! resp . Is Error ( ) ) ) } ( ) if ! ok { return nil , fmt . Errorf ( " " ) } user Token , ok : = token Iface . ( string ) if ! ok { return nil , fmt . Errorf ( " " , token Iface ) } if err ! = nil { return nil , err } if len ( config . Admin Token ) = = 0 { return nil , errors . New ( " " ) } if len ( config . Pachd Address ) = = 0 { return nil , errors . New ( " " ) } if err ! = nil { return nil , err } return & logical . Response { } , nil } 
func revoke User Credentials ( ctx context . Context , pachd Address string , user Token string , admin Token string ) error { if err ! = nil { return err } defer client . Close ( ) client = client . With Ctx ( ctx ) client . Set Auth Token ( admin Token ) _ , err = client . Auth APIClient . Revoke Auth Token ( client . Ctx ( ) , & auth . Revoke Auth Token Request { Token : user Token , } ) return err } 
func New APIServer ( version * pb . Version , options APIServer Options ) pb . APIServer { return new APIServer ( version , options ) } 
func Get Server Version ( client Conn * grpc . Client Conn ) ( * pb . Version , error ) { return pb . New APIClient ( client Conn ) . Get Version ( context . Background ( ) , & types . Empty { } , ) } 
func String ( v * pb . Version ) string { return fmt . Sprintf ( " " , v . Major , v . Minor , v . Micro , v . Additional ) } 
func get Pipeline Info ( pach Client * client . APIClient , env * serviceenv . Service Env ) ( * pps . Pipeline Info , error ) { ctx , cancel : = context . With Timeout ( context . Background ( ) , 3 0 * time . Second ) defer cancel ( ) resp , err : = env . Get Etcd Client ( ) . Get ( ctx , path . Join ( env . PPSEtcd Prefix , " " , env . PPSPipeline Name ) ) if err ! = nil { return nil , err } if len ( resp . Kvs ) ! = 1 { return nil , fmt . Errorf ( " " , env . PPSPipeline Name , len ( resp . Kvs ) , resp ) } var pipeline Ptr pps . Etcd Pipeline Info if err : = pipeline Ptr . Unmarshal ( resp . Kvs [ 0 ] . Value ) ; err ! = nil { return nil , err } pach Client . Set Auth Token ( pipeline Ptr . Auth Token ) return ppsutil . Get Pipeline Info ( pach Client , & pipeline Ptr , true ) } 
func insert Str ( ss * [ ] string , new S string ) bool { sz : = cap ( * ss ) idx : = sort . Search Strings ( * ss , new S ) if idx > = len ( * ss ) | | ( * ss ) [ idx ] ! = new S { copy ( ( * ss ) [ idx + 1 : ] , ( * ss ) [ idx : ] ) ( * ss ) [ idx ] = new S } else { new Ss : = make ( [ ] string , len ( * ss ) + 1 , max ( cap 1 , cap 2 ) ) copy ( new Ss , ( * ss ) [ : idx ] ) copy ( new Ss [ idx + 1 : ] , ( * ss ) [ idx : ] ) new Ss [ idx ] = new S * ss = new Ss } return true } return false } 
func remove Str ( ss * [ ] string , s string ) bool { idx : = sort . Search Strings ( * ss , s ) if idx = = len ( * ss ) { return false } copy ( ( * ss ) [ idx : ] , ( * ss ) [ idx + 1 : ] ) * ss = ( * ss ) [ : len ( * ss ) - 1 ] return true } 
func Public Cert To PEM ( cert * tls . Certificate ) [ ] byte { return pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : cert . Certificate [ 0 ] , } ) } 
func Key To PEM ( cert * tls . Certificate ) [ ] byte { switch k : = cert . Private Key . ( type ) { case * rsa . Private Key : return pem . Encode To Memory ( & pem . Block { Type : " " , Bytes : x 5 0 9 . Marshal PKCS 1Private Key ( k ) , } ) default : return nil } } 
func Generate Self Signed Cert ( address string , name * pkix . Name , ip Addresses . . . string ) ( * tls . Certificate , error ) { } switch { case address = = " " & & name . Common Name = = " " : return nil , errors . New ( " \ " \ " \ " \ " " ) case address ! = " " & & name . Common Name = = " " : name . Common Name = address case address ! = " " & & name . Common Name ! = " " & & name . Common Name ! = address : return nil , fmt . Errorf ( " \ " \ " \ " \ " " , address , name . Common Name ) default : for _ , str IP : = range ip Addresses { next Parsed IP : = net . Parse IP ( str IP ) if next Parsed IP = = nil { return nil , fmt . Errorf ( " " , str IP ) } parsed IPs = append ( parsed IPs , next Parsed IP ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } signed Cert , err : = x 5 0 9 . Parse Certificate ( signed Cert DER ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & tls . Certificate { Certificate : [ ] [ ] byte { signed Cert DER } , Leaf : signed Cert , Private Key : key , } , nil } 
func Activate Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { var initial Admin string activate : = & cobra . Command { Short : " " , Long : ` Activate Pachyderm 's auth system , and restrict access to existing data to the user running the command (or the argument to - -initial -admin ) , who will be the first cluster admin ` [ 1 : ] , Run : cmdutil . Run ( func ( args [ ] string ) error { var token string var err error if ! strings . Has Prefix ( initial Admin , auth . Robot Prefix ) { token , err = github Login ( ) if err ! = nil { return err } } fmt . Println ( " " ) / / Exchange Git Hub token for Pachyderm token c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) resp , err : = c . Activate ( c . Ctx ( ) , & auth . Activate Request { Git Hub Token : token , Subject : initial Admin , } ) if err ! = nil { return fmt . Errorf ( " " , grpcutil . Scrub GRPC ( err ) ) } if err : = write Pach Token To Cfg ( resp . Pach Token ) ; err ! = nil { return err } if strings . Has Prefix ( initial Admin , auth . Robot Prefix ) { fmt . Println ( " " + " \n " + " " ) fmt . Printf ( " \ " \ " \n \n " , initial Admin , resp . Pach Token ) } return nil } ) , } activate . Persistent Flags ( ) . String Var ( & initial Admin , " " , " " , ` The subject (robot user or github user ) who will be the first cluster admin ; the user running 'activate ' will identify as this user once auth is active . If you set 'initial -admin ' to a robot user , pachctl will print that robot user 's Pachyderm token ; this token is effectively a root token , and if it 's lost you will be locked out of your cluster ` [ 1 : ] ) return cmdutil . Create Alias ( activate , " " ) } 
func Deactivate Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { deactivate : = & cobra . Command { Short : " " , Long : " " + " " + " " , Run : cmdutil . Run ( func ( args [ ] string ) error { fmt . Println ( " " + " " ) confirm , err : = bufio . New Reader ( os . Stdin ) . Read String ( ' \n ' ) if ! strings . Contains ( " " , confirm [ : 1 ] ) { return fmt . Errorf ( " " ) } c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) _ , err = c . Deactivate ( c . Ctx ( ) , & auth . Deactivate Request { } ) return grpcutil . Scrub GRPC ( err ) } ) , } return cmdutil . Create Alias ( deactivate , " " ) } 
func Login Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { var use OTP bool login : = & cobra . Command { Short : " " , Long : " " + " " + " " , Run : cmdutil . Run ( func ( [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) var auth Err error if use OTP { code , err : = bufio . New Reader ( os . Stdin ) . Read String ( ' \n ' ) if err ! = nil { return fmt . Errorf ( " " , err ) } code = strings . Trim Space ( code ) resp , auth Err = c . Authenticate ( c . Ctx ( ) , & auth . Authenticate Request { One Time Password : code } ) } else { if err ! = nil { return err } fmt . Println ( " " ) resp , auth Err = c . Authenticate ( c . Ctx ( ) , & auth . Authenticate Request { Git Hub Token : token } ) } } return fmt . Errorf ( " " , grpcutil . Scrub GRPC ( auth Err ) ) } return write Pach Token To Cfg ( resp . Pach Token ) } ) , } login . Persistent Flags ( ) . Bool Var P ( & use OTP , " " , " " , false , " " + " " ) return cmdutil . Create Alias ( login , " " ) } 
func Logout Cmd ( ) * cobra . Command { logout : = & cobra . Command { Short : " " , Long : " " + " " + " " + " " , Run : cmdutil . Run ( func ( [ ] string ) error { cfg , err : = config . Read ( ) if err ! = nil { return fmt . Errorf ( " " + " " , err ) } if cfg . V 1 = = nil { return nil } cfg . V 1 . Session Token = " " return cfg . Write ( ) } ) , } return cmdutil . Create Alias ( logout , " " ) } 
func Whoami Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { whoami : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run ( func ( [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) resp , err : = c . Who Am I ( c . Ctx ( ) , & auth . Who Am IRequest { } ) if err ! = nil { return fmt . Errorf ( " " , grpcutil . Scrub GRPC ( err ) ) } fmt . Printf ( " \ " \ " \n " , resp . Username ) if resp . TTL > 0 { fmt . Printf ( " \n " , time . Now ( ) . Add ( time . Duration ( resp . TTL ) * time . Second ) . Format ( time . RFC 8 2 2 ) ) } if resp . Is Admin { fmt . Println ( " " ) } return nil } ) , } return cmdutil . Create Alias ( whoami , " " ) } 
func Check Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { check : = & cobra . Command { Use : " " , Short : " " , Long : " " + " \ " \ " " + " \ " \ " " + " \ " \ " " + " " + " " , Run : cmdutil . Run Fixed Args ( 2 , func ( args [ ] string ) error { scope , err : = auth . Parse Scope ( args [ 0 ] ) if err ! = nil { return err } repo : = args [ 1 ] c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) resp , err : = c . Authorize ( c . Ctx ( ) , & auth . Authorize Request { Repo : repo , Scope : scope , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } fmt . Printf ( " \n " , resp . Authorized ) return nil } ) , } return cmdutil . Create Alias ( check , " " ) } 
func Get Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { get : = & cobra . Command { Use : " " , Short : " " , Long : " " + " " + " \ " \ " \ " \ " \ " \ " \ " \ " " + " \ " \ " \ " \ " " + " " + " " , Run : cmdutil . Run Bounded Args ( 1 , 2 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) if len ( args ) = = 1 { resp , err : = c . Get ACL ( c . Ctx ( ) , & auth . Get ACLRequest { Repo : repo , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } t : = template . Must ( template . New ( " " ) . Parse ( " \n " ) ) return t . Execute ( os . Stdout , resp . Entries ) } resp , err : = c . Get Scope ( c . Ctx ( ) , & auth . Get Scope Request { Repos : [ ] string { repo } , Username : username , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } fmt . Println ( resp . Scopes [ 0 ] . String ( ) ) return nil } ) , } return cmdutil . Create Alias ( get , " " ) } 
func Set Scope Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { set Scope : = & cobra . Command { Use : " " , Short : " " , Long : " " + " " + " \ " \ " \ " \ " " + " " + " \ " \ " \ " \ " " + " " + " " + " " , Run : cmdutil . Run Fixed Args ( 3 , func ( args [ ] string ) error { scope , err : = auth . Parse Scope ( args [ 1 ] ) if err ! = nil { return err } username , repo : = args [ 0 ] , args [ 2 ] c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) _ , err = c . Set Scope ( c . Ctx ( ) , & auth . Set Scope Request { Repo : repo , Scope : scope , Username : username , } ) return grpcutil . Scrub GRPC ( err ) } ) , } return cmdutil . Create Alias ( set Scope , " " ) } 
func List Admins Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { list Admins : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run ( func ( [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) resp , err : = c . Get Admins ( c . Ctx ( ) , & auth . Get Admins Request { } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for _ , user : = range resp . Admins { fmt . Println ( user ) } return nil } ) , } return cmdutil . Create Alias ( list Admins , " " ) } 
func Modify Admins Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { var add [ ] string var remove [ ] string modify Admins : = & cobra . Command { Short : " " , Long : " " + " " + " " , Run : cmdutil . Run ( func ( [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) _ , err = c . Modify Admins ( c . Ctx ( ) , & auth . Modify Admins Request { Add : add , Remove : remove , } ) if auth . Is Err Partially Activated ( err ) { return fmt . Errorf ( " " + " " + " " , err ) } return grpcutil . Scrub GRPC ( err ) } ) , } modify Admins . Persistent Flags ( ) . String Slice Var ( & add , " " , [ ] string { } , " " ) modify Admins . Persistent Flags ( ) . String Slice Var ( & remove , " " , [ ] string { } , " " ) return cmdutil . Create Alias ( modify Admins , " " ) } 
func Get Auth Token Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { var quiet bool get Auth Token : = & cobra . Command { Use : " " , Short : " \ " \ " " , Long : " \ " \ " " + " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { subject : = args [ 0 ] c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) resp , err : = c . Get Auth Token ( c . Ctx ( ) , & auth . Get Auth Token Request { Subject : subject , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if quiet { fmt . Println ( resp . Token ) } else { fmt . Printf ( " \n \n \n " , resp . Subject , resp . Token ) } return nil } ) , } get Auth Token . Persistent Flags ( ) . Bool Var P ( & quiet , " " , " " , false , " " + " " + " " ) return cmdutil . Create Alias ( get Auth Token , " " ) } 
func Use Auth Token Cmd ( ) * cobra . Command { use Auth Token : = & cobra . Command { Short : " " + " " , Long : " " + " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { fmt . Println ( " " ) token , err : = bufio . New Reader ( os . Stdin ) . Read String ( ' \n ' ) if err ! = nil { return fmt . Errorf ( " " , err ) } write Pach Token To Cfg ( strings . Trim Space ( token ) ) return nil } ) , } return cmdutil . Create Alias ( use Auth Token , " " ) } 
func Cmds ( no Metrics , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command auth : = & cobra . Command { Short : " " , Long : " " , } commands = append ( commands , cmdutil . Create Alias ( auth , " " ) ) commands = append ( commands , Activate Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Deactivate Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Login Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Logout Cmd ( ) ) commands = append ( commands , Whoami Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Check Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Set Scope Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Get Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , List Admins Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Modify Admins Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Get Auth Token Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Use Auth Token Cmd ( ) ) commands = append ( commands , Get Config Cmd ( no Port Forwarding ) ) commands = append ( commands , Set Config Cmd ( no Port Forwarding ) ) return commands } 
func Parse Scope ( s string ) ( Scope , error ) { for name , value : = range Scope _value { if strings . Equal Fold ( s , name ) { return Scope ( value ) , nil } } return Scope _NONE , fmt . Errorf ( " " , s ) } 
func Is Err Not Activated ( err error ) bool { if err = = nil { return false } } 
func Is Err Partially Activated ( err error ) bool { if err = = nil { return false } } 
func Is Err Not Signed In ( err error ) bool { if err = = nil { return false } } 
func Is Err No Metadata ( err error ) bool { if err = = nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( Err No Metadata ) . Message ( ) ) } 
func Is Err Bad Token ( err error ) bool { if err = = nil { return false } return strings . Contains ( err . Error ( ) , status . Convert ( Err Bad Token ) . Message ( ) ) } 
func Is Err Not Authorized ( err error ) bool { if err = = nil { return false } } 
func Is Err Invalid Principal ( err error ) bool { if err = = nil { return false } return strings . Contains ( err . Error ( ) , " \ " " ) & & strings . Contains ( err . Error ( ) , " \ " \ " \ " \ " \ " \ " \ " \ " \ " " ) } 
func Is Err Too Short TTL ( err error ) bool { if err = = nil { return false } err Msg : = err . Error ( ) return strings . Contains ( err Msg , " " ) & & strings . Contains ( err Msg , " " ) & & strings . Contains ( err Msg , " " ) } 
func New Datum Factory ( pach Client * client . APIClient , input * pps . Input ) ( Datum Factory , error ) { switch { case input . Pfs ! = nil : return new PFSDatum Factory ( pach Client , input . Pfs ) case input . Union ! = nil : return new Union Datum Factory ( pach Client , input . Union ) case input . Cross ! = nil : return new Cross Datum Factory ( pach Client , input . Cross ) case input . Cron ! = nil : return new Cron Datum Factory ( pach Client , input . Cron ) case input . Git ! = nil : return new Git Datum Factory ( pach Client , input . Git ) } return nil , fmt . Errorf ( " " ) } 
func New Collection ( etcd Client * etcd . Client , prefix string , indexes [ ] * Index , template proto . Message , key Check func ( string ) error , val Check func ( proto . Message ) error ) Collection { } return & collection { prefix : prefix , etcd Client : etcd Client , indexes : indexes , limit : default Limit , template : template , key Check : key Check , val Check : val Check , } } 
func ( c * collection ) Path ( key string ) string { return path . Join ( c . prefix , key ) } 
func ( c * collection ) index Dir ( index * Index , index Val interface { } ) string { var index Val Str string if marshaller , ok : = index Val . ( proto . Marshaler ) ; ok { if index Val Bytes , err : = marshaller . Marshal ( ) ; err = = nil { } else { index Val Str = fmt . Sprintf ( " " , index Val ) } } else { index Val Str = fmt . Sprintf ( " " , index Val ) } return path . Join ( c . index Root ( index ) , index Val Str ) } 
func ( c * collection ) index Path ( index * Index , index Val interface { } , key string ) string { return path . Join ( c . index Dir ( index , index Val ) , key ) } 
func ( c * read Write Collection ) get Index Path ( val interface { } , index * Index , key string ) string { refl Val : = reflect . Value Of ( val ) field : = reflect . Indirect ( refl Val ) . Field By Name ( index . Field ) . Interface ( ) return c . index Path ( index , field , key ) } 
func ( c * read Write Collection ) get Multi Index Paths ( val interface { } , index * Index , key string ) [ ] string { var index Paths [ ] string field : = reflect . Indirect ( reflect . Value Of ( val ) ) . Field By Name ( index . Field ) for i : = 0 ; i < field . Len ( ) ; i + + { index Paths = append ( index Paths , c . index Path ( index , field . Index ( i ) . Interface ( ) , key ) ) } return index Paths } 
func ( c * read Write Collection ) Upsert ( key string , val proto . Message , f func ( ) error ) error { if err : = watch . Check Type ( c . template , val ) ; err ! = nil { return err } if err : = c . Get ( key , val ) ; err ! = nil & & ! Is Err Not Found ( err ) { return err } if err : = f ( ) ; err ! = nil { return err } return c . Put ( key , val ) } 
func ( c * readonly Collection ) get ( key string , opts . . . etcd . Op Option ) ( * etcd . Get Response , error ) { span , ctx : = tracing . Add Span To Any Existing ( c . ctx , " " ) defer tracing . Finish Any Span ( span ) resp , err : = c . etcd Client . Get ( ctx , key , opts . . . ) return resp , err } 
func ( c * readonly Collection ) List Prefix ( prefix string , val proto . Message , opts * Options , f func ( string ) error ) error { query Prefix : = c . prefix if prefix ! = " " { } return c . list ( query Prefix , & c . limit , opts , func ( kv * mvccpb . Key Value ) error { if err : = proto . Unmarshal ( kv . Value , val ) ; err ! = nil { return err } return f ( strings . Trim Prefix ( string ( kv . Key ) , query Prefix ) ) } ) } 
func ( c * readonly Collection ) List ( val proto . Message , opts * Options , f func ( string ) error ) error { if err : = watch . Check Type ( c . template , val ) ; err ! = nil { return err } return c . list ( c . prefix , & c . limit , opts , func ( kv * mvccpb . Key Value ) error { if err : = proto . Unmarshal ( kv . Value , val ) ; err ! = nil { return err } return f ( strings . Trim Prefix ( string ( kv . Key ) , c . prefix ) ) } ) } 
func ( c * readonly Collection ) Watch ( opts . . . watch . Op Option ) ( watch . Watcher , error ) { return watch . New Watcher ( c . ctx , c . etcd Client , c . prefix , c . prefix , c . template , opts . . . ) } 
func ( c * readonly Collection ) Watch By Index ( index * Index , val interface { } ) ( watch . Watcher , error ) { event Ch : = make ( chan * watch . Event ) done : = make ( chan struct { } ) watcher , err : = watch . New Watcher ( c . ctx , c . etcd Client , c . prefix , c . index Dir ( index , val ) , c . template ) if err ! = nil { return nil , err } go func ( ) ( ret Err error ) { defer func ( ) { if ret Err ! = nil { event Ch < - & watch . Event { Type : watch . Event Error , Err : ret Err , } watcher . Close ( ) } close ( event Ch ) } ( ) for { var ev * watch . Event var ok bool select { case ev , ok = < - watcher . Watch ( ) : case < - done : watcher . Close ( ) return nil } if ! ok { watcher . Close ( ) return nil } var direct Ev * watch . Event switch ev . Type { case watch . Event Error : case watch . Event Put : resp , err : = c . get ( c . Path ( path . Base ( string ( ev . Key ) ) ) ) if err ! = nil { return err } if len ( resp . Kvs ) = = 0 { } direct Ev = & watch . Event { Key : [ ] byte ( path . Base ( string ( ev . Key ) ) ) , Value : resp . Kvs [ 0 ] . Value , Type : ev . Type , Template : c . template , } case watch . Event Delete : direct Ev = & watch . Event { Key : [ ] byte ( path . Base ( string ( ev . Key ) ) ) , Type : ev . Type , Template : c . template , } } event Ch < - direct Ev } } ( ) return watch . Make Watcher ( event Ch , done ) , nil } 
func ( c * readonly Collection ) Watch One ( key string ) ( watch . Watcher , error ) { return watch . New Watcher ( c . ctx , c . etcd Client , c . prefix , c . Path ( key ) , c . template ) } 
func ( c * readonly Collection ) Watch One F ( key string , f func ( e * watch . Event ) error ) error { watcher , err : = watch . New Watcher ( c . ctx , c . etcd Client , c . prefix , c . Path ( key ) , c . template ) if err ! = nil { return err } defer watcher . Close ( ) for { select { case e : = < - watcher . Watch ( ) : if err : = f ( e ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } case < - c . ctx . Done ( ) : return c . ctx . Err ( ) } } } 
func generate User Credentials ( ctx context . Context , pachd Address string , admin Token string , username string , ttl time . Duration ) ( string , error ) { if err ! = nil { return " " , err } defer client . Close ( ) client = client . With Ctx ( ctx ) client . Set Auth Token ( admin Token ) resp , err : = client . Auth APIClient . Get Auth Token ( client . Ctx ( ) , & auth . Get Auth Token Request { Subject : username , TTL : int 6 4 ( ttl . Seconds ( ) ) , } ) if err ! = nil { return " " , err } return resp . Token , nil } 
func New Cache ( root string ) * Cache { return & Cache { root : root , keys : make ( map [ string ] bool ) , } } 
func ( c * Cache ) Put ( key string , value io . Reader ) ( ret Err error ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) f , err : = os . Create ( filepath . Join ( c . root , key ) ) if err ! = nil { return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) buf : = grpcutil . Get Buffer ( ) defer grpcutil . Put Buffer ( buf ) if _ , err : = io . Copy Buffer ( f , value , buf ) ; err ! = nil { return err } c . keys [ key ] = true return nil } 
func ( c * Cache ) Get ( key string ) ( io . Read Closer , error ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if ! c . keys [ key ] { return nil , fmt . Errorf ( " " , key ) } f , err : = os . Open ( filepath . Join ( c . root , key ) ) if err ! = nil { return nil , err } return f , nil } 
func ( c * Cache ) Keys ( ) [ ] string { c . mu . Lock ( ) defer c . mu . Unlock ( ) var keys [ ] string for key : = range c . keys { keys = append ( keys , key ) } sort . Strings ( keys ) return keys } 
func ( c * Cache ) Delete ( key string ) error { c . mu . Lock ( ) defer c . mu . Unlock ( ) if ! c . keys [ key ] { return nil } delete ( c . keys , key ) return os . Remove ( filepath . Join ( c . root , key ) ) } 
func ( c * Cache ) Clear ( ) error { c . mu . Lock ( ) defer c . mu . Unlock ( ) defer func ( ) { c . keys = make ( map [ string ] bool ) } ( ) for key : = range c . keys { if err : = os . Remove ( filepath . Join ( c . root , key ) ) ; err ! = nil { return err } } return nil } 
func New HTTPServer ( address string ) ( http . Handler , error ) { router : = httprouter . New ( ) s : = & server { router : router , address : address , http Client : & http . Client { } , } router . GET ( get File Path , s . get File Handler ) router . GET ( service Path , s . service Handler ) router . POST ( login Path , s . auth Login Handler ) router . POST ( logout Path , s . auth Logout Handler ) router . POST ( service Path , s . service Handler ) router . Not Found = http . Handler Func ( not Found ) return s , nil } 
func New Deploy Server ( kube Client * kube . Clientset , kube Namespace string ) deploy . APIServer { return & api Server { kube Client : kube Client , kube Namespace : kube Namespace , } } 
func invalid Delimiter Error ( w http . Response Writer , r * http . Request ) { write Error ( w , r , http . Status Bad Request , " " , " " ) } 
func invalid File Path Error ( w http . Response Writer , r * http . Request ) { write Error ( w , r , http . Status Bad Request , " " , " " ) } 
func Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command dump : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Dump ( os . Stdout ) } ) , } commands = append ( commands , cmdutil . Create Alias ( dump , " " ) ) var duration time . Duration profile : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Profile ( args [ 0 ] , duration , os . Stdout ) } ) , } profile . Flags ( ) . Duration Var P ( & duration , " " , " " , time . Minute , " " ) commands = append ( commands , cmdutil . Create Alias ( profile , " " ) ) binary : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Binary ( os . Stdout ) } ) , } commands = append ( commands , cmdutil . Create Alias ( binary , " " ) ) var profile File string var binary File string pprof : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) var eg errgroup . Group } f , err : = os . Create ( profile File ) if err ! = nil { return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return client . Profile ( args [ 0 ] , duration , f ) } ) if err ! = nil { return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return client . Binary ( f ) } ) if err : = eg . Wait ( ) ; err ! = nil { return err } cmd : = exec . Command ( " " , " " , " " , binary File , profile File ) cmd . Stdin = os . Stdin cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr return cmd . Run ( ) } ) , } pprof . Flags ( ) . String Var ( & profile File , " " , " " , " " ) pprof . Flags ( ) . String Var ( & binary File , " " , " " , " " ) pprof . Flags ( ) . Duration Var P ( & duration , " " , " " , time . Minute , " " ) commands = append ( commands , cmdutil . Create Alias ( pprof , " " ) ) debug : = & cobra . Command { Short : " " , Long : " " , } commands = append ( commands , cmdutil . Create Alias ( debug , " " ) ) return commands } 
func Export ( opts * assets . Asset Opts , out io . Writer ) error { client , err : = docker . New Client From Env ( ) if err ! = nil { return err } auth Configs , err : = docker . New Auth Configurations From Docker Cfg ( ) if err ! = nil { return fmt . Errorf ( " " , err . Error ( ) ) } if len ( auth Configs . Configs ) = = 0 { return fmt . Errorf ( " " ) } images : = assets . Images ( opts ) for _ , image : = range images { repository , tag : = docker . Parse Repository Tag ( image ) pulled : = false var loop Err [ ] error for registry , auth Config : = range auth Configs . Configs { if err : = client . Pull Image ( docker . Pull Image Options { Repository : repository , Tag : tag , Inactivity Timeout : 5 * time . Second , } , auth Config , ) ; err ! = nil { loop Err = append ( loop Err , fmt . Errorf ( " " , registry , err ) ) continue } pulled = true break } if ! pulled { err Str : = " " for _ , err : = range loop Err { err Str + = err . Error ( ) + " \n " } return fmt . Errorf ( " \n " , repository , tag , err Str ) } } return client . Export Images ( docker . Export Images Options { Names : images , Output Stream : out , } ) } 
func Import ( opts * assets . Asset Opts , in io . Reader ) error { client , err : = docker . New Client From Env ( ) if err ! = nil { return err } auth Configs , err : = docker . New Auth Configurations From Docker Cfg ( ) if err ! = nil { return fmt . Errorf ( " " , err . Error ( ) ) } if len ( auth Configs . Configs ) = = 0 { return fmt . Errorf ( " " ) } if err : = client . Load Image ( docker . Load Image Options { Input Stream : in , } ) ; err ! = nil { return err } registry : = opts . Registry opts . Registry = " " images : = assets . Images ( opts ) opts . Registry = registry for _ , image : = range images { repository , tag : = docker . Parse Repository Tag ( image ) registry Repo : = assets . Add Registry ( opts . Registry , repository ) if err : = client . Tag Image ( image , docker . Tag Image Options { Repo : registry Repo , Tag : tag , } , ) ; err ! = nil { return fmt . Errorf ( " " , err ) } pushed : = false var loop Err [ ] error for registry , auth Config : = range auth Configs . Configs { if err : = client . Push Image ( docker . Push Image Options { Name : registry Repo , Tag : tag , Registry : opts . Registry , Inactivity Timeout : 5 * time . Second , } , auth Config , ) ; err ! = nil { loop Err = append ( loop Err , fmt . Errorf ( " " , registry , err ) ) continue } pushed = true break } if ! pushed { err Str : = " " for _ , err : = range loop Err { err Str + = err . Error ( ) + " \n " } return fmt . Errorf ( " \n " , registry Repo , tag , err Str ) } } return nil } 
func Datum Tag Prefix ( salt string ) string { h . Write ( [ ] byte ( salt ) ) return hex . Encode To String ( h . Sum ( nil ) ) [ : 4 ] } 
func New PFSInput ( repo string , glob string ) * pps . Input { return & pps . Input { Pfs : & pps . PFSInput { Repo : repo , Glob : glob , } , } } 
func New PFSInput Opts ( name string , repo string , branch string , glob string , lazy bool ) * pps . Input { return & pps . Input { Pfs : & pps . PFSInput { Name : name , Repo : repo , Branch : branch , Glob : glob , Lazy : lazy , } , } } 
func New Cross Input ( input . . . * pps . Input ) * pps . Input { return & pps . Input { Cross : input , } } 
func New Union Input ( input . . . * pps . Input ) * pps . Input { return & pps . Input { Union : input , } } 
func New Cron Input ( name string , spec string ) * pps . Input { return & pps . Input { Cron : & pps . Cron Input { Name : name , Spec : spec , } , } } 
func New Job Input ( repo Name string , commit ID string , glob string ) * pps . Job Input { return & pps . Job Input { Commit : New Commit ( repo Name , commit ID ) , Glob : glob , } } 
func New Pipeline Input ( repo Name string , glob string ) * pps . Pipeline Input { return & pps . Pipeline Input { Repo : New Repo ( repo Name ) , Glob : glob , } } 
func ( c APIClient ) Create Job ( pipeline string , output Commit * pfs . Commit ) ( * pps . Job , error ) { job , err : = c . Pps APIClient . Create Job ( c . Ctx ( ) , & pps . Create Job Request { Pipeline : New Pipeline ( pipeline ) , Output Commit : output Commit , } , ) return job , grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Job ( job ID string , block State bool ) ( * pps . Job Info , error ) { job Info , err : = c . Pps APIClient . Inspect Job ( c . Ctx ( ) , & pps . Inspect Job Request { Job : New Job ( job ID ) , Block State : block State , } ) return job Info , grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Job Output Commit ( repo Name , commit ID string , block State bool ) ( * pps . Job Info , error ) { job Info , err : = c . Pps APIClient . Inspect Job ( c . Ctx ( ) , & pps . Inspect Job Request { Output Commit : New Commit ( repo Name , commit ID ) , Block State : block State , } ) return job Info , grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) List Job ( pipeline Name string , input Commit [ ] * pfs . Commit , output Commit * pfs . Commit ) ( [ ] * pps . Job Info , error ) { var result [ ] * pps . Job Info if err : = c . List Job F ( pipeline Name , input Commit , output Commit , func ( ji * pps . Job Info ) error { result = append ( result , ji ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) List Job F ( pipeline Name string , input Commit [ ] * pfs . Commit , output Commit * pfs . Commit , f func ( * pps . Job Info ) error ) error { var pipeline * pps . Pipeline if pipeline Name ! = " " { pipeline = New Pipeline ( pipeline Name ) } client , err : = c . Pps APIClient . List Job Stream ( c . Ctx ( ) , & pps . List Job Request { Pipeline : pipeline , Input Commit : input Commit , Output Commit : output Commit , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { ji , err : = client . Recv ( ) if err = = io . EOF { return nil } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( ji ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } } 
func ( c APIClient ) Flush Job ( commits [ ] * pfs . Commit , to Pipelines [ ] string , f func ( * pps . Job Info ) error ) error { req : = & pps . Flush Job Request { Commits : commits , } for _ , pipeline : = range to Pipelines { req . To Pipelines = append ( req . To Pipelines , New Pipeline ( pipeline ) ) } client , err : = c . Pps APIClient . Flush Job ( c . Ctx ( ) , req ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { job Info , err : = client . Recv ( ) if err ! = nil { if err = = io . EOF { return nil } return grpcutil . Scrub GRPC ( err ) } if err : = f ( job Info ) ; err ! = nil { return err } } } 
func ( c APIClient ) Flush Job All ( commits [ ] * pfs . Commit , to Pipelines [ ] string ) ( [ ] * pps . Job Info , error ) { var result [ ] * pps . Job Info if err : = c . Flush Job ( commits , to Pipelines , func ( ji * pps . Job Info ) error { result = append ( result , ji ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) Delete Job ( job ID string ) error { _ , err : = c . Pps APIClient . Delete Job ( c . Ctx ( ) , & pps . Delete Job Request { Job : New Job ( job ID ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Stop Job ( job ID string ) error { _ , err : = c . Pps APIClient . Stop Job ( c . Ctx ( ) , & pps . Stop Job Request { Job : New Job ( job ID ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Restart Datum ( job ID string , datum Filter [ ] string ) error { _ , err : = c . Pps APIClient . Restart Datum ( c . Ctx ( ) , & pps . Restart Datum Request { Job : New Job ( job ID ) , Data Filters : datum Filter , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) List Datum ( job ID string , page Size int 6 4 , page int 6 4 ) ( * pps . List Datum Response , error ) { client , err : = c . Pps APIClient . List Datum Stream ( c . Ctx ( ) , & pps . List Datum Request { Job : New Job ( job ID ) , Page Size : page Size , Page : page , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } resp : = & pps . List Datum Response { } first : = true for { r , err : = client . Recv ( ) if err = = io . EOF { break } else if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } if first { resp . Total Pages = r . Total Pages resp . Page = r . Page first = false } resp . Datum Infos = append ( resp . Datum Infos , r . Datum Info ) } return resp , nil } 
func ( c APIClient ) List Datum F ( job ID string , page Size int 6 4 , page int 6 4 , f func ( di * pps . Datum Info ) error ) error { client , err : = c . Pps APIClient . List Datum Stream ( c . Ctx ( ) , & pps . List Datum Request { Job : New Job ( job ID ) , Page Size : page Size , Page : page , } , ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { resp , err : = client . Recv ( ) if err = = io . EOF { return nil } else if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( resp . Datum Info ) ; err ! = nil { if err = = errutil . Err Break { return nil } return err } } } 
func ( c APIClient ) Inspect Datum ( job ID string , datum ID string ) ( * pps . Datum Info , error ) { datum Info , err : = c . Pps APIClient . Inspect Datum ( c . Ctx ( ) , & pps . Inspect Datum Request { Datum : & pps . Datum { ID : datum ID , Job : New Job ( job ID ) , } , } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return datum Info , nil } 
func ( l * Logs Iter ) Next ( ) bool { if l . err ! = nil { l . msg = nil return false } l . msg , l . err = l . logs Client . Recv ( ) if l . err ! = nil { return false } return true } 
func ( l * Logs Iter ) Err ( ) error { if l . err = = io . EOF { return nil } return grpcutil . Scrub GRPC ( l . err ) } 
func ( c APIClient ) Get Logs ( pipeline Name string , job ID string , data [ ] string , datum ID string , master bool , follow bool , tail int 6 4 , ) * Logs Iter { request : = pps . Get Logs Request { Master : master , Follow : follow , Tail : tail , } resp : = & Logs Iter { } if pipeline Name ! = " " { request . Pipeline = New Pipeline ( pipeline Name ) } if job ID ! = " " { request . Job = New Job ( job ID ) } request . Data Filters = data if datum ID ! = " " { request . Datum = & pps . Datum { Job : New Job ( job ID ) , ID : datum ID , } } resp . logs Client , resp . err = c . Pps APIClient . Get Logs ( c . Ctx ( ) , & request ) resp . err = grpcutil . Scrub GRPC ( resp . err ) return resp } 
func ( c APIClient ) Create Pipeline ( name string , image string , cmd [ ] string , stdin [ ] string , parallelism Spec * pps . Parallelism Spec , input * pps . Input , output Branch string , update bool , ) error { _ , err : = c . Pps APIClient . Create Pipeline ( c . Ctx ( ) , & pps . Create Pipeline Request { Pipeline : New Pipeline ( name ) , Transform : & pps . Transform { Image : image , Cmd : cmd , Stdin : stdin , } , Parallelism Spec : parallelism Spec , Input : input , Output Branch : output Branch , Update : update , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Inspect Pipeline ( pipeline Name string ) ( * pps . Pipeline Info , error ) { pipeline Info , err : = c . Pps APIClient . Inspect Pipeline ( c . Ctx ( ) , & pps . Inspect Pipeline Request { Pipeline : New Pipeline ( pipeline Name ) , } , ) return pipeline Info , grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) List Pipeline ( ) ( [ ] * pps . Pipeline Info , error ) { pipeline Infos , err : = c . Pps APIClient . List Pipeline ( c . Ctx ( ) , & pps . List Pipeline Request { } , ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return pipeline Infos . Pipeline Info , nil } 
func ( c APIClient ) Delete Pipeline ( name string , force bool ) error { _ , err : = c . Pps APIClient . Delete Pipeline ( c . Ctx ( ) , & pps . Delete Pipeline Request { Pipeline : New Pipeline ( name ) , Force : force , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Start Pipeline ( name string ) error { _ , err : = c . Pps APIClient . Start Pipeline ( c . Ctx ( ) , & pps . Start Pipeline Request { Pipeline : New Pipeline ( name ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Stop Pipeline ( name string ) error { _ , err : = c . Pps APIClient . Stop Pipeline ( c . Ctx ( ) , & pps . Stop Pipeline Request { Pipeline : New Pipeline ( name ) , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Rerun Pipeline ( name string , include [ ] * pfs . Commit , exclude [ ] * pfs . Commit ) error { _ , err : = c . Pps APIClient . Rerun Pipeline ( c . Ctx ( ) , & pps . Rerun Pipeline Request { Pipeline : New Pipeline ( name ) , Include : include , Exclude : exclude , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Create Pipeline Service ( name string , image string , cmd [ ] string , stdin [ ] string , parallelism Spec * pps . Parallelism Spec , input * pps . Input , update bool , internal Port int 3 2 , external Port int 3 2 , ) error { _ , err : = c . Pps APIClient . Create Pipeline ( c . Ctx ( ) , & pps . Create Pipeline Request { Pipeline : New Pipeline ( name ) , Transform : & pps . Transform { Image : image , Cmd : cmd , Stdin : stdin , } , Parallelism Spec : parallelism Spec , Input : input , Update : update , Service : & pps . Service { Internal Port : internal Port , External Port : external Port , } , } , ) return grpcutil . Scrub GRPC ( err ) } 
func ( c APIClient ) Garbage Collect ( memory Bytes int 6 4 ) error { _ , err : = c . Pps APIClient . Garbage Collect ( c . Ctx ( ) , & pps . Garbage Collect Request { Memory Bytes : memory Bytes } , ) return grpcutil . Scrub GRPC ( err ) } 
func Get Datum Total Time ( s * pps . Process Stats ) time . Duration { total Duration : = time . Duration ( 0 ) duration , _ : = types . Duration From Proto ( s . Download Time ) total Duration + = duration duration , _ = types . Duration From Proto ( s . Process Time ) total Duration + = duration duration , _ = types . Duration From Proto ( s . Upload Time ) total Duration + = duration return total Duration } 
func Mount ( c * client . APIClient , mount Point string , opts * Options ) error { nfs : = pathfs . New Path Node Fs ( new File System ( c , opts . get Commits ( ) ) , nil ) server , _ , err : = nodefs . Mount Root ( mount Point , nfs . Root ( ) , opts . get Fuse ( ) ) if err ! = nil { return fmt . Errorf ( " " , err ) } sig Chan : = make ( chan os . Signal , 1 ) signal . Notify ( sig Chan , os . Interrupt ) go func ( ) { select { case < - sig Chan : case < - opts . get Unmount ( ) : } server . Unmount ( ) } ( ) server . Serve ( ) return nil } 
func New Buf Pool ( size int ) * Buf Pool { return & Buf Pool { sync . Pool { New : func ( ) interface { } { return make ( [ ] byte , size ) } , } } } 
func Storage Root From Env ( ) ( string , error ) { storage Root , ok : = os . Lookup Env ( Pach Root Env Var ) if ! ok { return " " , fmt . Errorf ( " " , Pach Root Env Var ) } storage Backend , ok : = os . Lookup Env ( Storage Backend Env Var ) if ! ok { return " " , fmt . Errorf ( " " , Storage Backend Env Var ) } case Minio : if len ( storage Root ) > 0 & & storage Root [ 0 ] = = ' / ' { storage Root = storage Root [ 1 : ] } } return storage Root , nil } 
func Block Path From Env ( block * pfs . Block ) ( string , error ) { storage Root , err : = Storage Root From Env ( ) if err ! = nil { return " " , err } return filepath . Join ( storage Root , " " , block . Hash ) , nil } 
func New Google Client ( bucket string , opts [ ] option . Client Option ) ( Client , error ) { return new Google Client ( bucket , opts ) } 
func New Google Client From Secret ( bucket string ) ( Client , error ) { var err error if bucket = = " " { bucket , err = read Secret File ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " ) } } cred , err : = read Secret File ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " ) } var opts [ ] option . Client Option if cred ! = " " { opts = append ( opts , option . With Credentials File ( secret File ( " " ) ) ) } else { opts = append ( opts , option . With Token Source ( google . Compute Token Source ( " " ) ) ) } return New Google Client ( bucket , opts ) } 
func New Google Client From Env ( ) ( Client , error ) { bucket , ok : = os . Lookup Env ( Google Bucket Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Google Bucket Env Var ) } creds , ok : = os . Lookup Env ( Google Cred Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Google Cred Env Var ) } opts : = [ ] option . Client Option { option . With Credentials JSON ( [ ] byte ( creds ) ) } return New Google Client ( bucket , opts ) } 
func New Microsoft Client ( container string , account Name string , account Key string ) ( Client , error ) { return new Microsoft Client ( container , account Name , account Key ) } 
func New Microsoft Client From Secret ( container string ) ( Client , error ) { var err error if container = = " " { container , err = read Secret File ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " ) } } id , err : = read Secret File ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " ) } secret , err : = read Secret File ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " ) } return New Microsoft Client ( container , id , secret ) } 
func New Microsoft Client From Env ( ) ( Client , error ) { container , ok : = os . Lookup Env ( Microsoft Container Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Microsoft Container Env Var ) } id , ok : = os . Lookup Env ( Microsoft IDEnv Var ) if ! ok { return nil , fmt . Errorf ( " " , Microsoft IDEnv Var ) } secret , ok : = os . Lookup Env ( Microsoft Secret Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Microsoft Secret Env Var ) } return New Microsoft Client ( container , id , secret ) } 
func New Minio Client ( endpoint , bucket , id , secret string , secure , is S 3V 2 bool ) ( Client , error ) { if is S 3V 2 { return new Minio Client V 2 ( endpoint , bucket , id , secret , secure ) } return new Minio Client ( endpoint , bucket , id , secret , secure ) } 
func New Amazon Client ( region , bucket string , creds * Amazon Creds , distribution string , reversed . . . bool ) ( Client , error ) { return new Amazon Client ( region , bucket , creds , distribution , reversed . . . ) } 
func New Minio Client From Secret ( bucket string ) ( Client , error ) { var err error if bucket = = " " { bucket , err = read Secret File ( " " ) if err ! = nil { return nil , err } } endpoint , err : = read Secret File ( " " ) if err ! = nil { return nil , err } id , err : = read Secret File ( " " ) if err ! = nil { return nil , err } secret , err : = read Secret File ( " " ) if err ! = nil { return nil , err } secure , err : = read Secret File ( " " ) if err ! = nil { return nil , err } is S 3V 2 , err : = read Secret File ( " " ) if err ! = nil { return nil , err } return New Minio Client ( endpoint , bucket , id , secret , secure = = " " , is S 3V 2 = = " " ) } 
func New Minio Client From Env ( ) ( Client , error ) { bucket , ok : = os . Lookup Env ( Minio Bucket Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio Bucket Env Var ) } endpoint , ok : = os . Lookup Env ( Minio Endpoint Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio Endpoint Env Var ) } id , ok : = os . Lookup Env ( Minio IDEnv Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio IDEnv Var ) } secret , ok : = os . Lookup Env ( Minio Secret Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio Secret Env Var ) } secure , ok : = os . Lookup Env ( Minio Secure Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio Secure Env Var ) } is S 3V 2 , ok : = os . Lookup Env ( Minio Signature Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Minio Signature Env Var ) } return New Minio Client ( endpoint , bucket , id , secret , secure = = " " , is S 3V 2 = = " " ) } 
func New Amazon Client From Secret ( bucket string , reversed . . . bool ) ( Client , error ) { if err ! = nil { return nil , fmt . Errorf ( " " ) } if err ! = nil { return nil , err } } creds . ID , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } creds . Secret , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } creds . Token , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } creds . Vault Address , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } creds . Vault Role , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } creds . Vault Token , err = read Secret File ( " " ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } return New Amazon Client ( region , bucket , & creds , distribution , reversed . . . ) } 
func New Amazon Client From Env ( ) ( Client , error ) { region , ok : = os . Lookup Env ( Amazon Region Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Amazon Region Env Var ) } bucket , ok : = os . Lookup Env ( Amazon Bucket Env Var ) if ! ok { return nil , fmt . Errorf ( " " , Amazon Bucket Env Var ) } var creds Amazon Creds creds . ID , _ = os . Lookup Env ( Amazon IDEnv Var ) creds . Secret , _ = os . Lookup Env ( Amazon Secret Env Var ) creds . Token , _ = os . Lookup Env ( Amazon Token Env Var ) creds . Vault Address , _ = os . Lookup Env ( Amazon Vault Addr Env Var ) creds . Vault Role , _ = os . Lookup Env ( Amazon Vault Role Env Var ) creds . Vault Token , _ = os . Lookup Env ( Amazon Vault Token Env Var ) distribution , _ : = os . Lookup Env ( Amazon Distribution Env Var ) return New Amazon Client ( region , bucket , & creds , distribution ) } 
func New Client From URLAnd Secret ( url * Object Store URL , reversed . . . bool ) ( c Client , err error ) { switch url . Store { case " " : c , err = New Amazon Client From Secret ( url . Bucket , reversed . . . ) case " " : fallthrough case " " : c , err = New Google Client From Secret ( url . Bucket ) case " " : fallthrough case " " : case " " : c , err = New Local Client ( " " + url . Bucket ) } switch { case err ! = nil : return nil , err case c ! = nil : return Tracing Obj Client ( url . Store , c ) , nil default : return nil , fmt . Errorf ( " " , url . Bucket ) } } 
func Parse URL ( url Str string ) ( * Object Store URL , error ) { url , err : = url . Parse ( url Str ) if err ! = nil { return nil , fmt . Errorf ( " " , url Str , err ) } switch url . Scheme { case " " , " " , " " , " " : return & Object Store URL { Store : url . Scheme , Bucket : url . Host , Object : strings . Trim ( url . Path , " " ) , } , nil case " " , " " : if len ( parts ) < 1 { return nil , fmt . Errorf ( " " , url Str ) } return & Object Store URL { Store : url . Scheme , Bucket : parts [ 0 ] , Object : strings . Trim ( path . Join ( parts [ 1 : ] . . . ) , " " ) , } , nil } return nil , fmt . Errorf ( " " , url . Scheme ) } 
func New Client From Env ( storage Root string ) ( c Client , err error ) { storage Backend , ok : = os . Lookup Env ( Storage Backend Env Var ) if ! ok { return nil , fmt . Errorf ( " " ) } switch storage Backend { case Amazon : c , err = New Amazon Client From Env ( ) case Google : c , err = New Google Client From Env ( ) case Microsoft : c , err = New Microsoft Client From Env ( ) case Minio : c , err = New Minio Client From Env ( ) case Local : c , err = New Local Client ( storage Root ) } switch { case err ! = nil : return nil , err case c ! = nil : return Tracing Obj Client ( storage Backend , c ) , nil default : return nil , fmt . Errorf ( " " , storage Backend ) } } 
func New Exponential Back Off Config ( ) * backoff . Exponential Back Off { config : = backoff . New Exponential Back Off ( ) config . Multiplier = 2 config . Max Interval = 1 5 * time . Minute return config } 
func ( b * Backoff Read Closer ) Close ( ) error { span , _ : = tracing . Add Span To Any Existing ( b . ctx , " " ) defer tracing . Finish Any Span ( span ) return b . reader . Close ( ) } 
func ( b * Backoff Write Closer ) Close ( ) error { span , _ : = tracing . Add Span To Any Existing ( b . ctx , " " ) defer tracing . Finish Any Span ( span ) err : = b . writer . Close ( ) if b . client . Is Ignorable ( err ) { return nil } return err } 
func Is Retryable ( client Client , err error ) bool { return is Net Retryable ( err ) | | client . Is Retryable ( err ) } 
func Run Stdin ( stdin io . Reader , args . . . string ) error { return Run IO ( IO { Stdin : stdin } , args . . . ) } 
func Run IODir Path ( io Obj IO , dir Path string , args . . . string ) error { var debug Stderr io . Read Writer = bytes . New Buffer ( nil ) var stderr io . Writer = debug Stderr if io Obj . Stderr ! = nil { stderr = io . Multi Writer ( debug Stderr , io Obj . Stderr ) } cmd : = exec . Command ( args [ 0 ] , args [ 1 : ] . . . ) cmd . Stdin = io Obj . Stdin cmd . Stdout = io Obj . Stdout cmd . Stderr = stderr cmd . Dir = dir Path if err : = cmd . Run ( ) ; err ! = nil { data , _ : = ioutil . Read All ( debug Stderr ) if data ! = nil & & len ( data ) > 0 { return fmt . Errorf ( " \n " , strings . Join ( args , " " ) , err . Error ( ) , string ( data ) ) } return fmt . Errorf ( " " , strings . Join ( args , " " ) , err . Error ( ) ) } return nil } 
func ( a * api Server ) Log Req ( request interface { } ) { a . pach Logger . Log ( request , nil , nil , 0 ) } 
func ( a * api Server ) Log Resp ( request interface { } , response interface { } , err error , duration time . Duration ) { if err = = nil { a . pach Logger . Log At Level From Depth ( request , response , err , duration , logrus . Info Level , 4 ) } else if authclient . Is Err Not Activated ( err ) { a . pach Logger . Log At Level From Depth ( request , response , err , duration , logrus . Debug Level , 4 ) } else { a . pach Logger . Log At Level From Depth ( request , response , err , duration , logrus . Error Level , 4 ) } } 
func New Auth Server ( env * serviceenv . Service Env , etcd Prefix string , public bool ) ( authclient . APIServer , error ) { s : = & api Server { env : env , pach Logger : log . New Logger ( " " ) , admin Cache : make ( map [ string ] struct { } ) , tokens : col . New Collection ( env . Get Etcd Client ( ) , path . Join ( etcd Prefix , tokens Prefix ) , nil , & authclient . Token Info { } , nil , nil , ) , authentication Codes : col . New Collection ( env . Get Etcd Client ( ) , path . Join ( etcd Prefix , authentication Codes Prefix ) , nil , & authclient . OTPInfo { } , nil , nil , ) , acls : col . New Collection ( env . Get Etcd Client ( ) , path . Join ( etcd Prefix , acls Prefix ) , nil , & authclient . ACL { } , nil , nil , ) , admins : col . New Collection ( env . Get Etcd Client ( ) , path . Join ( etcd Prefix , admins Prefix ) , nil , & types . Bool Value { } , go s . retrieve Or Generate PPSToken ( ) go s . watch Admins ( path . Join ( etcd Prefix , admins Prefix ) ) if public { } return s , nil } 
func ( a * api Server ) activation State ( ) activation State { a . admin Mu . Lock ( ) defer a . admin Mu . Unlock ( ) if len ( a . admin Cache ) = = 0 { return none } if _ , magic User Is Admin : = a . admin Cache [ magic User ] ; magic User Is Admin { return partial } return full } 
func ( a * api Server ) retrieve Or Generate PPSToken ( ) { var token Proto types . String Value ctx , cancel : = context . With Timeout ( context . Background ( ) , 2 * time . Minute ) defer cancel ( ) b : = backoff . New Exponential Back Off ( ) b . Max Elapsed Time = 6 0 * time . Second b . Max Interval = 5 * time . Second if err : = backoff . Retry ( func ( ) error { if _ , err : = col . New STM ( ctx , a . env . Get Etcd Client ( ) , func ( stm col . STM ) error { super User Token Col : = col . New Collection ( a . env . Get Etcd Client ( ) , ppsconsts . PPSToken Key , nil , & types . String Value { } , nil , nil ) . Read Write ( stm ) if err = = nil { return nil } if col . Is Err Not Found ( err ) { token Proto . Value = token if err : = super User Token Col . Create ( " " , & token Proto ) ; err ! = nil { return err } } return nil } ) ; err ! = nil { return err } a . pps Token = token Proto . Value return nil } , b ) ; err ! = nil { panic ( fmt . Sprintf ( " " , err ) ) } } 
func Git Hub Token To Username ( ctx context . Context , oauth Token string ) ( string , error ) { if ! github Token Regex . Match String ( oauth Token ) & & os . Getenv ( Disable Authentication Env Var ) = = " " { logrus . Warnf ( " " + " " + " \ " \ " " , oauth Token ) return authclient . Git Hub Prefix + oauth Token , nil } tc : = oauth 2 . New Client ( ctx , ts ) gclient : = github . New Client ( tc ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } verified Username : = user . Get Login ( ) return authclient . Git Hub Prefix + verified Username , nil } 
func ( a * api Server ) expired Cluster Admin Check ( ctx context . Context , username string ) error { state , err : = a . get Enterprise Token State ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } is Admin , err : = a . is Admin ( ctx , username ) if err ! = nil { return err } if state ! = enterpriseclient . State _ACTIVE & & ! is Admin { return errors . New ( " " + " " + " " ) } return nil } 
func ( a * api Server ) get One Time Password ( ctx context . Context , username string , expiration time . Time ) ( code string , err error ) { if ! expiration . Is Zero ( ) { expiration Proto , err : = types . Timestamp Proto ( expiration ) if err ! = nil { return " " , fmt . Errorf ( " " , expiration . String ( ) , err ) } otp Info . Session Expiration = expiration Proto } if _ , err = col . New STM ( ctx , a . env . Get Etcd Client ( ) , func ( stm col . STM ) error { return a . authentication Codes . Read Write ( stm ) . Put TTL ( hash Token ( code ) , otp Info , default Auth Code TTLSecs ) } ) ; err ! = nil { return " " , err } return code , nil } 
func ( a * api Server ) get Scope ( ctx context . Context , subject string , acl * authclient . ACL ) ( authclient . Scope , error ) { if err ! = nil { return authclient . Scope _NONE , fmt . Errorf ( " " + " " , err ) } for _ , g : = range groups { group Scope : = acl . Entries [ g ] if scope < group Scope { scope = group Scope } } return scope , nil } 
func ( a * api Server ) set Groups For User Internal ( ctx context . Context , subject string , groups [ ] string ) error { _ , err : = col . New STM ( ctx , a . env . Get Etcd Client ( ) , func ( stm col . STM ) error { members : = a . members . Read Write ( stm ) add Groups : = add To Set ( nil , groups . . . ) if err : = members . Get ( subject , & remove Groups ) ; err = = nil { for _ , group : = range groups { if remove Groups . Groups [ group ] { remove Groups . Groups = remove From Set ( remove Groups . Groups , group ) add Groups = remove From Set ( add Groups , group ) } } } } var members Proto authclient . Users for group : = range remove Groups . Groups { if err : = groups . Upsert ( group , & members Proto , func ( ) error { members Proto . Usernames = remove From Set ( members Proto . Usernames , subject ) return nil } ) ; err ! = nil { return err } } return nil } ) ; err ! = nil { return err } } return nil } ) return err } 
func ( a * api Server ) get Groups ( ctx context . Context , subject string ) ( [ ] string , error ) { members : = a . members . Read Only ( ctx ) var groups Proto authclient . Groups if err : = members . Get ( subject , & groups Proto ) ; err ! = nil { if col . Is Err Not Found ( err ) { return [ ] string { } , nil } return nil , err } return set To List ( groups Proto . Groups ) , nil } 
func hash Token ( token string ) string { sum : = sha 2 5 6 . Sum 2 5 6 ( [ ] byte ( token ) ) return fmt . Sprintf ( " " , sum ) } 
func get Auth Token ( ctx context . Context ) ( string , error ) { md , ok : = metadata . From Incoming Context ( ctx ) if ! ok { return " " , authclient . Err No Metadata } if len ( md [ authclient . Context Token Key ] ) > 1 { return " " , fmt . Errorf ( " " ) } else if len ( md [ authclient . Context Token Key ] ) = = 0 { return " " , authclient . Err Not Signed In } return md [ authclient . Context Token Key ] [ 0 ] , nil } 
func ( a * api Server ) canonicalize Subjects ( ctx context . Context , subjects [ ] string ) ( [ ] string , error ) { if subjects = = nil { return [ ] string { } , nil } eg : = & errgroup . Group { } canonicalized Subjects : = make ( [ ] string , len ( subjects ) ) for i , subject : = range subjects { i , subject : = i , subject eg . Go ( func ( ) error { subject , err : = a . canonicalize Subject ( ctx , subject ) if err ! = nil { return err } canonicalized Subjects [ i ] = subject return nil } ) } if err : = eg . Wait ( ) ; err ! = nil { return nil , err } return canonicalized Subjects , nil } 
func ( a * api Server ) canonicalize Subject ( ctx context . Context , subject string ) ( string , error ) { colon Idx : = strings . Index ( subject , " " ) if colon Idx < 0 { subject = authclient . Git Hub Prefix + subject colon Idx = len ( authclient . Git Hub Prefix ) - 1 } prefix : = subject [ : colon Idx ] a . config Mu . Lock ( ) defer a . config Mu . Unlock ( ) } if prefix = = path . Join ( " " , a . config Cache . IDP . Name ) { return subject , nil } } switch prefix { case authclient . Git Hub Prefix : var err error subject , err = canonicalize Git Hub Username ( ctx , subject [ len ( authclient . Git Hub Prefix ) : ] ) if err ! = nil { return " " , err } case authclient . Pipeline Prefix , authclient . Robot Prefix : break default : return " " , fmt . Errorf ( " " , subject [ : colon Idx + 1 ] ) } return subject , nil } 
func canonicalize Git Hub Username ( ctx context . Context , user string ) ( string , error ) { if strings . Index ( user , " " ) > = 0 { return " " , fmt . Errorf ( " " , authclient . Git Hub Prefix , user ) } if os . Getenv ( Disable Authentication Env Var ) = = " " { } gclient : = github . New Client ( http . Default Client ) u , _ , err : = gclient . Users . Get ( ctx , strings . To Lower ( user ) ) if err ! = nil { return " " , fmt . Errorf ( " \ " \ " " , user , err ) } return authclient . Git Hub Prefix + u . Get Login ( ) , nil } 
func Matches ( tb testing . TB , expected Match string , actual string , msg And Args . . . interface { } ) { tb . Helper ( ) r , err : = regexp . Compile ( expected Match ) if err ! = nil { fatal ( tb , msg And Args , " " , expected Match ) } if ! r . Match String ( actual ) { fatal ( tb , msg And Args , " " , actual , expected Match ) } } 
func One Of Matches ( tb testing . TB , expected Match string , actuals [ ] string , msg And Args . . . interface { } ) { tb . Helper ( ) r , err : = regexp . Compile ( expected Match ) if err ! = nil { fatal ( tb , msg And Args , " " , expected Match ) } for _ , actual : = range actuals { if r . Match String ( actual ) { return } } fatal ( tb , msg And Args , " " , actuals , expected Match ) } 
func Equal ( tb testing . TB , expected interface { } , actual interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) e V , a V : = reflect . Value Of ( expected ) , reflect . Value Of ( actual ) if e V . Type ( ) ! = a V . Type ( ) { fatal ( tb , msg And Args , " \n " + " " , expected , expected , actual , actual ) } if ! reflect . Deep Equal ( expected , actual ) { fatal ( tb , msg And Args , " \n " + " " , expected , actual ) } } 
func Not Equal ( tb testing . TB , expected interface { } , actual interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) if reflect . Deep Equal ( expected , actual ) { fatal ( tb , msg And Args , " \n " + " " , expected , actual ) } } 
func Elements Equal Or Err ( expecteds interface { } , actuals interface { } ) error { es : = reflect . Value Of ( expecteds ) as : = reflect . Value Of ( actuals ) as Is Empty : = actuals = = nil | | as . Is Nil ( ) | | ( as . Kind ( ) = = reflect . Slice & & as . Len ( ) = = 0 ) if es Is Empty & & as Is Empty { return nil } else if es Is Empty { return fmt . Errorf ( " " , as . Len ( ) , actuals ) } else if as Is Empty { return fmt . Errorf ( " \n " , es . Len ( ) , expecteds ) } } if as . Kind ( ) ! = reflect . Slice { return fmt . Errorf ( " \ " \ " " , as . Type ( ) . String ( ) ) } as Are Ptrs : = as . Type ( ) . Elem ( ) . Kind ( ) = = reflect . Ptr es Elem Type , as Elem Type : = es . Type ( ) . Elem ( ) , as . Type ( ) . Elem ( ) if es Are Ptrs { es Elem Type = es . Type ( ) . Elem ( ) . Elem ( ) } if as Are Ptrs { as Elem Type = as . Type ( ) . Elem ( ) . Elem ( ) } if es Elem Type ! = as Elem Type { return fmt . Errorf ( " " , es . Type ( ) . Elem ( ) , as . Type ( ) . Elem ( ) ) } expected Ct : = reflect . Make Map ( reflect . Map Of ( es Elem Type , int Type ) ) for i : = 0 ; i < es . Len ( ) ; i + + { v : = es . Index ( i ) if es Are Ptrs { v = v . Elem ( ) } if ! expected Ct . Map Index ( v ) . Is Valid ( ) { expected Ct . Set Map Index ( v , reflect . Value Of ( int 6 4 ( 1 ) ) ) } else { new Ct : = expected Ct . Map Index ( v ) . Int ( ) + 1 expected Ct . Set Map Index ( v , reflect . Value Of ( new Ct ) ) } } for i : = 0 ; i < as . Len ( ) ; i + + { v : = as . Index ( i ) if as Are Ptrs { v = v . Elem ( ) } if ! actual Ct . Map Index ( v ) . Is Valid ( ) { actual Ct . Set Map Index ( v , reflect . Value Of ( int 6 4 ( 1 ) ) ) } else { new Ct : = actual Ct . Map Index ( v ) . Int ( ) + 1 actual Ct . Set Map Index ( v , reflect . Value Of ( new Ct ) ) } } if expected Ct . Len ( ) ! = actual Ct . Len ( ) { } for _ , key : = range expected Ct . Map Keys ( ) { ec : = expected Ct . Map Index ( key ) ac : = actual Ct . Map Index ( key ) if ! ec . Is Valid ( ) | | ! ac . Is Valid ( ) | | ec . Int ( ) ! = ac . Int ( ) { ec Int , ac Int : = int 6 4 ( 0 ) , int 6 4 ( 0 ) if ec . Is Valid ( ) { ec Int = ec . Int ( ) } if ac . Is Valid ( ) { ac Int = ac . Int ( ) } } } return nil } 
func Elements Equal Under Fn ( tb testing . TB , expecteds interface { } , actuals interface { } , f func ( interface { } ) interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) as : = reflect . Value Of ( actuals ) es : = reflect . Value Of ( expecteds ) } else if actuals = = nil | | as . Is Nil ( ) | | as . Len ( ) = = 0 { } return } } else if expecteds = = nil | | es . Is Nil ( ) | | es . Len ( ) = = 0 { fatal ( tb , msg And Args , fmt . Sprintf ( " \n " , as . Len ( ) , actuals ) ) } for i : = 0 ; i < as . Len ( ) ; i + + { new Actuals . Index ( i ) . Set ( reflect . Value Of ( f ( as . Index ( i ) . Interface ( ) ) ) ) } if err : = Elements Equal Or Err ( expecteds , new Actuals . Interface ( ) ) ; err ! = nil { fatal ( tb , msg And Args , err . Error ( ) ) } } 
func Elements Equal ( tb testing . TB , expecteds interface { } , actuals interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) if err : = Elements Equal Or Err ( expecteds , actuals ) ; err ! = nil { fatal ( tb , msg And Args , err . Error ( ) ) } } 
func one Of Equals ( slice Name string , slice interface { } , elem interface { } ) ( bool , error ) { e : = reflect . Value Of ( elem ) sl : = reflect . Value Of ( slice ) if slice = = nil | | sl . Is Nil ( ) { sl = reflect . Make Slice ( reflect . Slice Of ( e . Type ( ) ) , 0 , 0 ) } if sl . Kind ( ) ! = reflect . Slice { return false , fmt . Errorf ( " \ " \ " " , slice Name , sl . Type ( ) . String ( ) ) } if e . Type ( ) ! = sl . Type ( ) . Elem ( ) { return false , nil } are Ptrs : = e . Kind ( ) = = reflect . Ptr for i : = 0 ; i < sl . Len ( ) ; i + + { if ! are Ptrs & & reflect . Deep Equal ( e . Interface ( ) , sl . Index ( i ) . Interface ( ) ) { return true , nil } else if are Ptrs & & reflect . Deep Equal ( e . Elem ( ) . Interface ( ) , sl . Index ( i ) . Elem ( ) . Interface ( ) ) { return true , nil } } return false , nil } 
func Equal One Of ( tb testing . TB , expecteds interface { } , actual interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) equal , err : = one Of Equals ( " " , expecteds , actual ) if err ! = nil { fatal ( tb , msg And Args , err . Error ( ) ) } if ! equal { fatal ( tb , msg And Args , " \n " + " " , expecteds , actual ) } } 
func None Equals ( tb testing . TB , expected interface { } , actuals interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) equal , err : = one Of Equals ( " " , actuals , expected ) if err ! = nil { fatal ( tb , msg And Args , err . Error ( ) ) } if equal { fatal ( tb , msg And Args , " \n " , expected , actuals ) } } 
func No Error ( tb testing . TB , err error , msg And Args . . . interface { } ) { tb . Helper ( ) if err ! = nil { fatal ( tb , msg And Args , " " , err . Error ( ) ) } } 
func No Error Within T ( tb testing . TB , t time . Duration , f func ( ) error , msg And Args . . . interface { } ) { tb . Helper ( ) err Ch : = make ( chan error ) go func ( ) { } ( ) select { case err : = < - err Ch : if err ! = nil { fatal ( tb , msg And Args , " " , err . Error ( ) ) } case < - time . After ( t ) : fatal ( tb , msg And Args , " " , t . String ( ) ) } } 
func No Error Within TRetry ( tb testing . TB , t time . Duration , f func ( ) error , msg And Args . . . interface { } ) { tb . Helper ( ) done Ch : = make ( chan struct { } ) timeout : = false var err error go func ( ) { for ! timeout { if err = f ( ) ; err = = nil { close ( done Ch ) break } } } ( ) select { case < - done Ch : case < - time . After ( t ) : timeout = true fatal ( tb , msg And Args , " " , t . String ( ) , err ) } } 
func Yes Error ( tb testing . TB , err error , msg And Args . . . interface { } ) { tb . Helper ( ) if err = = nil { fatal ( tb , msg And Args , " " , err ) } } 
func Not Nil ( tb testing . TB , object interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) success : = true if object = = nil { success = false } else { value : = reflect . Value Of ( object ) kind : = value . Kind ( ) if kind > = reflect . Chan & & kind < = reflect . Slice & & value . Is Nil ( ) { success = false } } if ! success { fatal ( tb , msg And Args , " " ) } } 
func Nil ( tb testing . TB , object interface { } , msg And Args . . . interface { } ) { tb . Helper ( ) if object = = nil { return } value : = reflect . Value Of ( object ) kind : = value . Kind ( ) if kind > = reflect . Chan & & kind < = reflect . Slice & & value . Is Nil ( ) { return } fatal ( tb , msg And Args , " " , object ) } 
func False ( tb testing . TB , value bool , msg And Args . . . interface { } ) { tb . Helper ( ) if value { fatal ( tb , msg And Args , " " ) } } 
func New STM ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { return new STMSerializable ( ctx , c , apply , false ) } 
func New Dryrun STM ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) error { _ , err : = new STMSerializable ( ctx , c , apply , true ) return err } 
func new STMRepeatable ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { s : = & stm { client : c , ctx : ctx , get Opts : [ ] v 3 . Op Option { v 3 . With Serializable ( ) } } return run STM ( s , apply , false ) } 
func new STMSerializable ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error , dryrun bool ) ( * v 3 . Txn Response , error ) { s : = & stm Serializable { stm : stm { client : c , ctx : ctx } , prefetch : make ( map [ string ] * v 3 . Get Response ) , } return run STM ( s , apply , dryrun ) } 
func new STMRead Committed ( ctx context . Context , c * v 3 . Client , apply func ( STM ) error ) ( * v 3 . Txn Response , error ) { s : = & stm Read Committed { stm { client : c , ctx : ctx , get Opts : [ ] v 3 . Op Option { v 3 . With Serializable ( ) } } } return run STM ( s , apply , true ) } 
func ( s * stm ) cmps ( ) [ ] v 3 . Cmp { cmps : = make ( [ ] v 3 . Cmp , 0 , len ( s . rset ) ) for k , rk : = range s . rset { cmps = append ( cmps , is Key Current ( k , rk ) ) } return cmps } 
func ( s * stm ) puts ( ) [ ] v 3 . Op { puts : = make ( [ ] v 3 . Op , 0 , len ( s . wset ) ) for _ , v : = range s . wset { puts = append ( puts , v . op ) } return puts } 
func ( s * stm Read Committed ) commit ( ) * v 3 . Txn Response { s . rset = nil return s . stm . commit ( ) } 
func ( s * stm ) fetch TTL ( iface STM , key string ) ( int 6 4 , error ) { } } if len ( get Resp . Kvs ) = = 0 { return 0 , Err Not Found { Key : key } } lease ID : = v 3 . Lease ID ( get Resp . Kvs [ 0 ] . Lease ) if lease ID = = 0 { s . ttlset [ key ] = 0 return 0 , nil } span , ctx : = tracing . Add Span To Any Existing ( s . ctx , " " ) defer tracing . Finish Any Span ( span ) lease Resp , err : = s . client . Time To Live ( ctx , lease ID ) if err ! = nil { panic ( stm Error { err } ) } s . ttlset [ key ] = lease Resp . TTL for _ , key : = range lease Resp . Keys { s . ttlset [ string ( key ) ] = lease Resp . TTL } return lease Resp . TTL , nil } 
func Pipelines ( etcd Client * etcd . Client , etcd Prefix string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , pipelines Prefix ) , nil , & pps . Etcd Pipeline Info { } , nil , nil , ) } 
func Jobs ( etcd Client * etcd . Client , etcd Prefix string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , jobs Prefix ) , [ ] * col . Index { Jobs Pipeline Index , Jobs Output Index } , & pps . Etcd Job Info { } , nil , nil , ) } 
func New Ticker ( b Back Off ) * Ticker { c : = make ( chan time . Time ) t : = & Ticker { C : c , c : c , b : b , stop : make ( chan struct { } ) , } go t . run ( ) runtime . Set Finalizer ( t , ( * Ticker ) . Stop ) return t } 
func custom Check Retry ( cluster * etcd . Cluster , num Reqs int , last Resp http . Response , err error ) error { if 6 0 0 > max Retries { max Retries = 6 0 0 } if num Reqs > max Retries { err Str : = fmt . Sprintf ( " " , cluster . Machines , err ) return & etcd . Etcd Error { Error Code : etcd . Err Code Etcd Not Reachable , Message : " " , Cause : err Str , Index : 0 , } } if last Resp . Status Code = = 0 { } if last Resp . Status Code ! = http . Status Internal Server Error { if last Resp . Body ! = nil { if b , err : = ioutil . Read All ( last Resp . Body ) ; err = = nil { body = b } } err Str : = fmt . Sprintf ( " " , http . Status Text ( last Resp . Status Code ) , body ) return & etcd . Etcd Error { Error Code : etcd . Err Code Unhandled HTTPStatus , Message : " " , Cause : err Str , Index : 0 , } } fmt . Println ( " " , last Resp . Status Code ) return nil } 
func node To Map ( node * etcd . Node , out map [ string ] string ) bool { key : = strings . Trim Prefix ( node . Key , " " ) if ! node . Dir { if node . Value = = " " { if _ , ok : = out [ key ] ; ok { delete ( out , key ) return true } return false } if value , ok : = out [ key ] ; ! ok | | value ! = node . Value { out [ key ] = node . Value return true } return false } changed : = false for _ , node : = range node . Nodes { changed = node To Map ( node , out ) | | changed } return changed } 
func fill Default Resource Requests ( opts * Asset Opts , persistent Disk Backend backend ) { if persistent Disk Backend = = local Backend { } if opts . Pachd Non Cache Mem Request = = " " { opts . Pachd Non Cache Mem Request = " " } if opts . Pachd CPURequest = = " " { opts . Pachd CPURequest = " " } if opts . Etcd Mem Request = = " " { opts . Etcd Mem Request = " " } if opts . Etcd CPURequest = = " " { opts . Etcd CPURequest = " " } } else { } if opts . Pachd Non Cache Mem Request = = " " { opts . Pachd Non Cache Mem Request = " " } if opts . Pachd CPURequest = = " " { opts . Pachd CPURequest = " " } if opts . Etcd Mem Request = = " " { opts . Etcd Mem Request = " " } if opts . Etcd CPURequest = = " " { opts . Etcd CPURequest = " " } } } 
func Service Account ( opts * Asset Opts ) * v 1 . Service Account { return & v 1 . Service Account { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( Service Account Name , labels ( " " ) , nil , opts . Namespace ) , } } 
func Cluster Role ( opts * Asset Opts ) * rbacv 1 . Cluster Role { return & rbacv 1 . Cluster Role { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( role Name , labels ( " " ) , nil , opts . Namespace ) , Rules : role Policy Rules , } } 
func Role Binding ( opts * Asset Opts ) * rbacv 1 . Role Binding { return & rbacv 1 . Role Binding { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( role Binding Name , labels ( " " ) , nil , opts . Namespace ) , Subjects : [ ] rbacv 1 . Subject { { Kind : " " , Name : Service Account Name , Namespace : opts . Namespace , } } , Role Ref : rbacv 1 . Role Ref { Kind : " " , Name : role Name , } , } } 
func Get Backend Secret Volume And Mount ( backend string ) ( v 1 . Volume , v 1 . Volume Mount ) { return v 1 . Volume { Name : client . Storage Secret Name , Volume Source : v 1 . Volume Source { Secret : & v 1 . Secret Volume Source { Secret Name : client . Storage Secret Name , } , } , } , v 1 . Volume Mount { Name : client . Storage Secret Name , Mount Path : " " + client . Storage Secret Name , } } 
func Get Secret Env Vars ( storage Backend string ) [ ] v 1 . Env Var { var env Vars [ ] v 1 . Env Var if storage Backend ! = " " { env Vars = append ( env Vars , v 1 . Env Var { Name : obj . Storage Backend Env Var , Value : storage Backend , } ) } true Val : = true for env Var , secret Key : = range obj . Env Var To Secret Key { env Vars = append ( env Vars , v 1 . Env Var { Name : env Var , Value From : & v 1 . Env Var Source { Secret Key Ref : & v 1 . Secret Key Selector { Local Object Reference : v 1 . Local Object Reference { Name : client . Storage Secret Name , } , Key : secret Key , Optional : & true Val , } , } , } ) } return env Vars } 
func Pachd Deployment ( opts * Asset Opts , object Store Backend backend , host Path string ) * apps . Deployment { } if opts . Trace Port = = 0 { opts . Trace Port = 6 5 1 } if opts . HTTPPort = = 0 { opts . HTTPPort = 6 5 2 } if opts . Peer Port = = 0 { opts . Peer Port = 6 5 3 } mem : = resource . Must Parse ( opts . Block Cache Size ) mem . Add ( resource . Must Parse ( opts . Pachd Non Cache Mem Request ) ) cpu : = resource . Must Parse ( opts . Pachd CPURequest ) image : = Add Registry ( opts . Registry , versioned Pachd Image ( opts ) ) volumes : = [ ] v 1 . Volume { { Name : " " , } , } volume Mounts : = [ ] v 1 . Volume Mount { { Name : " " , Mount Path : " " , } , } var storage Host Path string switch object Store Backend { case local Backend : storage Host Path = filepath . Join ( host Path , " " ) volumes [ 0 ] . Host Path = & v 1 . Host Path Volume Source { Path : storage Host Path , } backend Env Var = pfs . Local Backend Env Var case minio Backend : backend Env Var = pfs . Minio Backend Env Var case amazon Backend : backend Env Var = pfs . Amazon Backend Env Var case google Backend : backend Env Var = pfs . Google Backend Env Var case microsoft Backend : backend Env Var = pfs . Microsoft Backend Env Var } volume , mount : = Get Backend Secret Volume And Mount ( backend Env Var ) volumes = append ( volumes , volume ) volume Mounts = append ( volume Mounts , mount ) if opts . TLS ! = nil { volumes = append ( volumes , v 1 . Volume { Name : tls Volume Name , Volume Source : v 1 . Volume Source { Secret : & v 1 . Secret Volume Source { Secret Name : tls Secret Name , } , } , } ) volume Mounts = append ( volume Mounts , v 1 . Volume Mount { Name : tls Volume Name , Mount Path : grpcutil . TLSVolume Path , } ) } resource Requirements : = v 1 . Resource Requirements { Requests : v 1 . Resource List { v 1 . Resource CPU : cpu , v 1 . Resource Memory : mem , } , } if ! opts . No Guaranteed { resource Requirements . Limits = v 1 . Resource List { v 1 . Resource CPU : cpu , v 1 . Resource Memory : mem , } } return & apps . Deployment { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( pachd Name , labels ( pachd Name ) , nil , opts . Namespace ) , Spec : apps . Deployment Spec { Replicas : replicas ( 1 ) , Selector : & metav 1 . Label Selector { Match Labels : labels ( pachd Name ) , } , Template : v 1 . Pod Template Spec { Object Meta : object Meta ( pachd Name , labels ( pachd Name ) , map [ string ] string { IAMAnnotation : opts . IAMRole } , opts . Namespace ) , Spec : v 1 . Pod Spec { Containers : [ ] v 1 . Container { { Name : pachd Name , Image : image , Env : append ( [ ] v 1 . Env Var { { Name : " " , Value : " " } , { Name : " " , Value : opts . Etcd Prefix } , { Name : " " , Value : fmt . Sprintf ( " " , opts . Pachd Shards ) } , { Name : " " , Value : backend Env Var } , { Name : " " , Value : storage Host Path } , { Name : " " , Value : Add Registry ( opts . Registry , versioned Worker Image ( opts ) ) } , { Name : " " , Value : opts . Image Pull Secret } , { Name : " " , Value : image } , { Name : " " , Value : " " } , { Name : " " , Value : opts . Version } , { Name : " " , Value : strconv . Format Bool ( opts . Metrics ) } , { Name : " " , Value : opts . Log Level } , { Name : " " , Value : opts . Block Cache Size } , { Name : " " , Value : opts . IAMRole } , { Name : " " , Value : strconv . Format Bool ( opts . No Expose Docker Socket ) } , { Name : auth . Disable Authentication Env Var , Value : strconv . Format Bool ( opts . Disable Authentication ) } , { Name : " " , Value From : & v 1 . Env Var Source { Field Ref : & v 1 . Object Field Selector { APIVersion : " " , Field Path : " " , } , } , } , { Name : " " , Value From : & v 1 . Env Var Source { Resource Field Ref : & v 1 . Resource Field Selector { Container Name : " " , Resource : " " , } , } , } , { Name : " " , Value : strconv . Format Bool ( opts . Expose Object API ) } , } , Get Secret Env Vars ( " " ) . . . ) , Ports : [ ] v 1 . Container Port { { Container Port : opts . Pachd Port , } 
func Pachd Service ( opts * Asset Opts ) * v 1 . Service { prometheus Annotations : = map [ string ] string { " " : " " , " " : strconv . Itoa ( Prometheus Port ) , } return & v 1 . Service { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( pachd Name , labels ( pachd Name ) , prometheus Annotations , opts . Namespace ) , Spec : v 1 . Service Spec { Type : v 1 . Service Type Node Port , Selector : map [ string ] string { " " : pachd Name , } , Ports : [ ] v 1 . Service Port { { Port : 6 0 0 , } 
func Githook Service ( namespace string ) * v 1 . Service { name : = " " return & v 1 . Service { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( name , labels ( name ) , nil , namespace ) , Spec : v 1 . Service Spec { Type : v 1 . Service Type Load Balancer , Selector : map [ string ] string { " " : pachd Name , } , Ports : [ ] v 1 . Service Port { { Target Port : intstr . From Int ( githook . Git Hook Port ) , Name : " " , Port : githook . External Port ( ) , } , } , } , } } 
func Etcd Deployment ( opts * Asset Opts , host Path string ) * apps . Deployment { cpu : = resource . Must Parse ( opts . Etcd CPURequest ) mem : = resource . Must Parse ( opts . Etcd Mem Request ) var volumes [ ] v 1 . Volume if host Path = = " " { volumes = [ ] v 1 . Volume { { Name : " " , Volume Source : v 1 . Volume Source { Persistent Volume Claim : & v 1 . Persistent Volume Claim Volume Source { Claim Name : etcd Volume Claim Name , } , } , } , } } else { volumes = [ ] v 1 . Volume { { Name : " " , Volume Source : v 1 . Volume Source { Host Path : & v 1 . Host Path Volume Source { Path : filepath . Join ( host Path , " " ) , } , } , } , } } resource Requirements : = v 1 . Resource Requirements { Requests : v 1 . Resource List { v 1 . Resource CPU : cpu , v 1 . Resource Memory : mem , } , } if ! opts . No Guaranteed { resource Requirements . Limits = v 1 . Resource List { v 1 . Resource CPU : cpu , v 1 . Resource Memory : mem , } } if opts . Registry ! = " " { image = Add Registry ( opts . Registry , etcd Image ) } return & apps . Deployment { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( etcd Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : apps . Deployment Spec { Replicas : replicas ( 1 ) , Selector : & metav 1 . Label Selector { Match Labels : labels ( etcd Name ) , } , Template : v 1 . Pod Template Spec { Object Meta : object Meta ( etcd Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : v 1 . Pod Spec { Containers : [ ] v 1 . Container { { Name : etcd Name , Image : image , } 
func Etcd Storage Class ( opts * Asset Opts , backend backend ) ( interface { } , error ) { sc : = map [ string ] interface { } { " " : " " , " " : " " , " " : map [ string ] interface { } { " " : default Etcd Storage Class Name , " " : labels ( etcd Name ) , " " : opts . Namespace , } , } switch backend { case google Backend : sc [ " " ] = " " sc [ " " ] = map [ string ] string { " " : " " , } case amazon Backend : sc [ " " ] = " " sc [ " " ] = map [ string ] string { " " : " " , } default : return nil , nil } return sc , nil } 
func Etcd Volume ( persistent Disk Backend backend , opts * Asset Opts , host Path string , name string , size int ) ( * v 1 . Persistent Volume , error ) { spec : = & v 1 . Persistent Volume { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( etcd Volume Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : v 1 . Persistent Volume Spec { Capacity : map [ v 1 . Resource Name ] resource . Quantity { " " : resource . Must Parse ( fmt . Sprintf ( " " , size ) ) , } , Access Modes : [ ] v 1 . Persistent Volume Access Mode { v 1 . Read Write Once } , Persistent Volume Reclaim Policy : v 1 . Persistent Volume Reclaim Retain , } , } switch persistent Disk Backend { case amazon Backend : spec . Spec . Persistent Volume Source = v 1 . Persistent Volume Source { AWSElastic Block Store : & v 1 . AWSElastic Block Store Volume Source { FSType : " " , Volume ID : name , } , } case google Backend : spec . Spec . Persistent Volume Source = v 1 . Persistent Volume Source { GCEPersistent Disk : & v 1 . GCEPersistent Disk Volume Source { FSType : " " , PDName : name , } , } case microsoft Backend : data Disk URI : = name split : = strings . Split ( name , " " ) disk Name : = split [ len ( split ) - 1 ] spec . Spec . Persistent Volume Source = v 1 . Persistent Volume Source { Azure Disk : & v 1 . Azure Disk Volume Source { Disk Name : disk Name , Data Disk URI : data Disk URI , } , } case minio Backend : fallthrough case local Backend : spec . Spec . Persistent Volume Source = v 1 . Persistent Volume Source { Host Path : & v 1 . Host Path Volume Source { Path : filepath . Join ( host Path , " " ) , } , } default : return nil , fmt . Errorf ( " \ " \ " " , persistent Disk Backend ) } return spec , nil } 
func Etcd Volume Claim ( size int , opts * Asset Opts ) * v 1 . Persistent Volume Claim { return & v 1 . Persistent Volume Claim { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( etcd Volume Claim Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : v 1 . Persistent Volume Claim Spec { Resources : v 1 . Resource Requirements { Requests : map [ v 1 . Resource Name ] resource . Quantity { " " : resource . Must Parse ( fmt . Sprintf ( " " , size ) ) , } , } , Access Modes : [ ] v 1 . Persistent Volume Access Mode { v 1 . Read Write Once } , Volume Name : etcd Volume Name , } , } } 
func Etcd Node Port Service ( local bool , opts * Asset Opts ) * v 1 . Service { var client Node Port int 3 2 if local { client Node Port = 3 2 3 7 9 } return & v 1 . Service { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( etcd Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : v 1 . Service Spec { Type : v 1 . Service Type Node Port , Selector : map [ string ] string { " " : etcd Name , } , Ports : [ ] v 1 . Service Port { { Port : 2 3 7 9 , Name : " " , Node Port : client Node Port , } , } , } , } } 
func Etcd Headless Service ( opts * Asset Opts ) * v 1 . Service { return & v 1 . Service { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( etcd Headless Service Name , labels ( etcd Name ) , nil , opts . Namespace ) , Spec : v 1 . Service Spec { Selector : map [ string ] string { " " : etcd Name , } , Cluster IP : " " , Ports : [ ] v 1 . Service Port { { Name : " " , Port : 2 3 8 0 , } , } , } , } } 
func Etcd Stateful Set ( opts * Asset Opts , backend backend , disk Space int ) interface { } { mem : = resource . Must Parse ( opts . Etcd Mem Request ) cpu : = resource . Must Parse ( opts . Etcd CPURequest ) initial Cluster : = make ( [ ] string , 0 , opts . Etcd Nodes ) for i : = 0 ; i < opts . Etcd Nodes ; i + + { url : = fmt . Sprintf ( " " , i ) initial Cluster = append ( initial Cluster , fmt . Sprintf ( " " , i , url ) ) } for i , str : = range etcd Cmd { etcd Cmd [ i ] = fmt . Sprintf ( " \ " \ " " , str ) } var pvc Templates [ ] interface { } switch backend { case google Backend , amazon Backend : storage Class Name : = opts . Etcd Storage Class Name if storage Class Name = = " " { storage Class Name = default Etcd Storage Class Name } pvc Templates = [ ] interface { } { map [ string ] interface { } { " " : map [ string ] interface { } { " " : etcd Volume Claim Name , " " : labels ( etcd Name ) , " " : map [ string ] string { " " : storage Class Name , } , " " : opts . Namespace , } , " " : map [ string ] interface { } { " " : map [ string ] interface { } { " " : map [ string ] interface { } { " " : resource . Must Parse ( fmt . Sprintf ( " " , disk Space ) ) , } , } , " " : [ ] string { " " } , } , } , } default : pvc Templates = [ ] interface { } { map [ string ] interface { } { " " : map [ string ] interface { } { " " : etcd Volume Claim Name , " " : labels ( etcd Name ) , " " : opts . Namespace , } , " " : map [ string ] interface { } { " " : map [ string ] interface { } { " " : map [ string ] interface { } { " " : resource . Must Parse ( fmt . Sprintf ( " " , disk Space ) ) , } , } , " " : [ ] string { " " } , } , } , } } var image Pull Secrets [ ] map [ string ] string if opts . Image Pull Secret ! = " " { image Pull Secrets = append ( image Pull Secrets , map [ string ] string { " " : opts . Image Pull Secret } ) } if opts . Registry ! = " " { image = Add Registry ( opts . Registry , etcd Image ) } return map [ string ] interface { } { " " : " " , " " : " " , " " : map [ string ] interface { } { " " : etcd Name , " " : labels ( etcd Name ) , " " : opts . Namespace , } , " " : map [ string ] interface { } { } 
func Dash Deployment ( opts * Asset Opts ) * apps . Deployment { return & apps . Deployment { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( dash Name , labels ( dash Name ) , nil , opts . Namespace ) , Spec : apps . Deployment Spec { Selector : & metav 1 . Label Selector { Match Labels : labels ( dash Name ) , } , Template : v 1 . Pod Template Spec { Object Meta : object Meta ( dash Name , labels ( dash Name ) , nil , opts . Namespace ) , Spec : v 1 . Pod Spec { Containers : [ ] v 1 . Container { { Name : dash Name , Image : Add Registry ( opts . Registry , opts . Dash Image ) , Ports : [ ] v 1 . Container Port { { Container Port : 8 0 8 0 , Name : " " , } , } , Image Pull Policy : " " , } , { Name : grpc Proxy Name , Image : Add Registry ( opts . Registry , grpc Proxy Image ) , Ports : [ ] v 1 . Container Port { { Container Port : 8 0 8 1 , Name : " " , } , } , Image Pull Policy : " " , } , } , Image Pull Secrets : image Pull Secrets ( opts ) , } , } , } , } } 
func Dash Service ( opts * Asset Opts ) * v 1 . Service { return & v 1 . Service { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( dash Name , labels ( dash Name ) , nil , opts . Namespace ) , Spec : v 1 . Service Spec { Type : v 1 . Service Type Node Port , Selector : labels ( dash Name ) , Ports : [ ] v 1 . Service Port { { Port : 8 0 8 0 , Name : " " , Node Port : 3 0 0 8 0 , } , { Port : 8 0 8 1 , Name : " " , Node Port : 3 0 0 8 1 , } , } , } , } } 
func Minio Secret ( bucket string , id string , secret string , endpoint string , secure , is S 3V 2 bool ) map [ string ] [ ] byte { secure V : = " " if secure { secure V = " " } s 3V 2 : = " " if is S 3V 2 { s 3V 2 = " " } return map [ string ] [ ] byte { " " : [ ] byte ( bucket ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , " " : [ ] byte ( endpoint ) , " " : [ ] byte ( secure V ) , " " : [ ] byte ( s 3V 2 ) , } } 
func Write Secret ( encoder Encoder , data map [ string ] [ ] byte , opts * Asset Opts ) error { if opts . Dash Only { return nil } secret : = & v 1 . Secret { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( client . Storage Secret Name , labels ( client . Storage Secret Name ) , nil , opts . Namespace ) , Data : data , } return encoder . Encode ( secret ) } 
func Amazon Secret ( region , bucket , id , secret , token , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , " " : [ ] byte ( token ) , " " : [ ] byte ( distribution ) , } } 
func Amazon Vault Secret ( region , bucket , vault Address , vault Role , vault Token , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( vault Address ) , " " : [ ] byte ( vault Role ) , " " : [ ] byte ( vault Token ) , " " : [ ] byte ( distribution ) , } } 
func Amazon IAMRole Secret ( region , bucket , distribution string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( region ) , " " : [ ] byte ( bucket ) , " " : [ ] byte ( distribution ) , } } 
func Google Secret ( bucket string , cred string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( bucket ) , " " : [ ] byte ( cred ) , } } 
func Microsoft Secret ( container string , id string , secret string ) map [ string ] [ ] byte { return map [ string ] [ ] byte { " " : [ ] byte ( container ) , " " : [ ] byte ( id ) , " " : [ ] byte ( secret ) , } } 
func Write Dashboard Assets ( encoder Encoder , opts * Asset Opts ) error { if err : = encoder . Encode ( Dash Service ( opts ) ) ; err ! = nil { return err } return encoder . Encode ( Dash Deployment ( opts ) ) } 
func Write Assets ( encoder Encoder , opts * Asset Opts , object Store Backend backend , persistent Disk Backend backend , volume Size int , host Path string ) error { } fill Default Resource Requests ( opts , persistent Disk Backend ) if opts . Dash Only { if dash Err : = Write Dashboard Assets ( encoder , opts ) ; dash Err ! = nil { return dash Err } return nil } if err : = encoder . Encode ( Service Account ( opts ) ) ; err ! = nil { return err } if ! opts . No RBAC { if opts . Local Roles { if err : = encoder . Encode ( Role ( opts ) ) ; err ! = nil { return err } if err : = encoder . Encode ( Role Binding ( opts ) ) ; err ! = nil { return err } } else { if err : = encoder . Encode ( Cluster Role ( opts ) ) ; err ! = nil { return err } if err : = encoder . Encode ( Cluster Role Binding ( opts ) ) ; err ! = nil { return err } } } if opts . Etcd Nodes > 0 & & opts . Etcd Volume ! = " " { return fmt . Errorf ( " " ) } } } else if opts . Etcd Nodes > 0 { if err ! = nil { return err } if sc ! = nil { if err = encoder . Encode ( sc ) ; err ! = nil { return err } } } if err : = encoder . Encode ( Etcd Headless Service ( opts ) ) ; err ! = nil { return err } if err : = encoder . Encode ( Etcd Stateful Set ( opts , persistent Disk Backend , volume Size ) ) ; err ! = nil { return err } } else if opts . Etcd Volume ! = " " | | persistent Disk Backend = = local Backend { volume , err : = Etcd Volume ( persistent Disk Backend , opts , host Path , opts . Etcd Volume , volume Size ) if err ! = nil { return err } if err = encoder . Encode ( volume ) ; err ! = nil { return err } if err = encoder . Encode ( Etcd Volume Claim ( volume Size , opts ) ) ; err ! = nil { return err } if err = encoder . Encode ( Etcd Deployment ( opts , " " ) ) ; err ! = nil { return err } } else { return fmt . Errorf ( " " ) } if err : = encoder . Encode ( Etcd Node Port Service ( object Store Backend = = local Backend , opts ) ) ; err ! = nil { return err } if err : = encoder . Encode ( Pachd Service ( opts ) ) ; err ! = nil { return err } if err : = encoder . Encode ( Pachd Deployment ( opts , object Store Backend , host Path ) ) ; err ! = nil { return err } if ! opts . No Dash { if err : = Write Dashboard Assets ( encoder , opts ) ; err ! = nil { return err } } if opts . TLS ! = nil { if err : = Write TLSSecret ( encoder , opts ) ; err ! = nil { return err } } return nil } 
func Write TLSSecret ( encoder Encoder , opts * Asset Opts ) error { } if opts . TLS = = nil { return fmt . Errorf ( " " ) } if opts . TLS . Server Key = = " " { return fmt . Errorf ( " \ " \ " " ) } if opts . TLS . Server Cert = = " " { return fmt . Errorf ( " \ " \ " " ) } if err ! = nil { return fmt . Errorf ( " \ " \ " " , opts . TLS . Server Cert , err ) } key Bytes , err : = ioutil . Read File ( opts . TLS . Server Key ) if err ! = nil { return fmt . Errorf ( " \ " \ " " , opts . TLS . Server Key , err ) } secret : = & v 1 . Secret { Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , Object Meta : object Meta ( tls Secret Name , labels ( tls Secret Name ) , nil , opts . Namespace ) , Data : map [ string ] [ ] byte { grpcutil . TLSCert File : cert Bytes , grpcutil . TLSKey File : key Bytes , } , } return encoder . Encode ( secret ) } 
func Write Local Assets ( encoder Encoder , opts * Asset Opts , host Path string ) error { if err : = Write Assets ( encoder , opts , local Backend , local Backend , 1 , host Path ) ; err ! = nil { return err } if secret Err : = Write Secret ( encoder , Local Secret ( ) , opts ) ; secret Err ! = nil { return secret Err } return nil } 
func Write Custom Assets ( encoder Encoder , opts * Asset Opts , args [ ] string , object Store Backend string , persistent Disk Backend string , secure , is S 3V 2 bool ) error { switch object Store Backend { case " " : if len ( args ) ! = s 3Custom Args { return fmt . Errorf ( " " , s 3Custom Args ) } volume Size , err : = strconv . Atoi ( args [ 1 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 1 ] ) } switch persistent Disk Backend { case " " : if err : = Write Assets ( encoder , opts , minio Backend , amazon Backend , volume Size , " " ) ; err ! = nil { return err } case " " : if err : = Write Assets ( encoder , opts , minio Backend , google Backend , volume Size , " " ) ; err ! = nil { return err } case " " : if err : = Write Assets ( encoder , opts , minio Backend , microsoft Backend , volume Size , " " ) ; err ! = nil { return err } default : return fmt . Errorf ( " " ) } return Write Secret ( encoder , Minio Secret ( args [ 2 ] , args [ 3 ] , args [ 4 ] , args [ 5 ] , secure , is S 3V 2 ) , opts ) default : return fmt . Errorf ( " " ) } } 
func Write Amazon Assets ( encoder Encoder , opts * Asset Opts , region string , bucket string , volume Size int , creds * Amazon Creds , cloudfront Distro string ) error { if err : = Write Assets ( encoder , opts , amazon Backend , amazon Backend , volume Size , " " ) ; err ! = nil { return err } var secret map [ string ] [ ] byte if creds = = nil { secret = Amazon IAMRole Secret ( region , bucket , cloudfront Distro ) } else if creds . ID ! = " " { secret = Amazon Secret ( region , bucket , creds . ID , creds . Secret , creds . Token , cloudfront Distro ) } else if creds . Vault Address ! = " " { secret = Amazon Vault Secret ( region , bucket , creds . Vault Address , creds . Vault Role , creds . Vault Token , cloudfront Distro ) } return Write Secret ( encoder , secret , opts ) } 
func Write Google Assets ( encoder Encoder , opts * Asset Opts , bucket string , cred string , volume Size int ) error { if err : = Write Assets ( encoder , opts , google Backend , google Backend , volume Size , " " ) ; err ! = nil { return err } return Write Secret ( encoder , Google Secret ( bucket , cred ) , opts ) } 
func Write Microsoft Assets ( encoder Encoder , opts * Asset Opts , container string , id string , secret string , volume Size int ) error { if err : = Write Assets ( encoder , opts , microsoft Backend , microsoft Backend , volume Size , " " ) ; err ! = nil { return err } return Write Secret ( encoder , Microsoft Secret ( container , id , secret ) , opts ) } 
func Images ( opts * Asset Opts ) [ ] string { return [ ] string { versioned Worker Image ( opts ) , etcd Image , grpc Proxy Image , pause Image , versioned Pachd Image ( opts ) , opts . Dash Image , } } 
func Add Registry ( registry string , image Name string ) string { if registry = = " " { return image Name } parts : = strings . Split ( image Name , " " ) if len ( parts ) = = 3 { parts = parts [ 1 : ] } return path . Join ( registry , parts [ 0 ] , parts [ 1 ] ) } 
func ( b * Exponential Back Off ) with Canonical Randomization Factor ( ) * Exponential Back Off { if b . Randomization Factor < 0 { b . Randomization Factor = 0 } else if b . Randomization Factor > 1 { b . Randomization Factor = 1 } return b } 
func New 1 0s Back Off ( ) * Exponential Back Off { b : = & Exponential Back Off { Initial Interval : 1 0 0 * time . Millisecond , Randomization Factor : Default Randomization Factor , Multiplier : Default Multiplier , Max Interval : 2 * time . Second , Max Elapsed Time : 1 0 * time . Second , Clock : System Clock , } return b . with Canonical Randomization Factor ( ) . with Reset ( ) } 
func ( b * Exponential Back Off ) Reset ( ) { b . current Interval = b . Initial Interval b . start Time = b . Clock . Now ( ) } 
func ( b * Exponential Back Off ) Next Back Off ( ) time . Duration { } defer b . increment Current Interval ( ) return get Random Value From Interval ( b . Randomization Factor , rand . Float 6 4 ( ) , b . current Interval ) } 
func ( b * Exponential Back Off ) Get Elapsed Time ( ) time . Duration { return b . Clock . Now ( ) . Sub ( b . start Time ) } 
func ( b * Exponential Back Off ) increment Current Interval ( ) { } else { b . current Interval = time . Duration ( float 6 4 ( b . current Interval ) * b . Multiplier ) } } 
func get Random Value From Interval ( randomization Factor , random float 6 4 , current Interval time . Duration ) time . Duration { var delta = randomization Factor * float 6 4 ( current Interval ) var min Interval = float 6 4 ( current Interval ) - delta var max Interval = float 6 4 ( current Interval ) + delta } 
func Factory ( ctx context . Context , c * logical . Backend Config ) ( logical . Backend , error ) { result : = & backend { } result . Backend = & framework . Backend { Backend Type : logical . Type Logical , Paths Special : & logical . Paths { Unauthenticated : [ ] string { " " } , } , Paths : [ ] * framework . Path { result . config Path ( ) , result . login Path ( ) , result . version Path ( ) , } , Secrets : [ ] * framework . Secret { { Type : " " , Fields : map [ string ] * framework . Field Schema { " " : & framework . Field Schema { Type : framework . Type String , Description : " " , } , } , Renew : result . Renew , Revoke : result . Revoke , } } , } if err : = result . Setup ( ctx , c ) ; err ! = nil { return nil , err } return result , nil } 
func New APIServer ( env * serviceenv . Service Env , etcd Prefix string , tree Cache * hashtree . Cache , storage Root string , memory Request int 6 4 ) ( APIServer , error ) { return new APIServer ( env , etcd Prefix , tree Cache , storage Root , memory Request ) } 
func New Block APIServer ( dir string , cache Bytes int 6 4 , backend string , etcd Address string ) ( Block APIServer , error ) { switch backend { case Minio Backend Env Var : } block APIServer , err : = new Minio Block APIServer ( dir , cache Bytes , etcd Address ) if err ! = nil { return nil , err } return block APIServer , nil case Amazon Backend Env Var : } block APIServer , err : = new Amazon Block APIServer ( dir , cache Bytes , etcd Address ) if err ! = nil { return nil , err } return block APIServer , nil case Google Backend Env Var : if err ! = nil { return nil , err } return block APIServer , nil case Microsoft Backend Env Var : block APIServer , err : = new Microsoft Block APIServer ( dir , cache Bytes , etcd Address ) if err ! = nil { return nil , err } return block APIServer , nil case Local Backend Env Var : fallthrough default : block APIServer , err : = new Local Block APIServer ( dir , cache Bytes , etcd Address ) if err ! = nil { return nil , err } return block APIServer , nil } } 
func Local Storage ( tb testing . TB ) ( obj . Client , * Storage ) { wd , err : = os . Getwd ( ) require . No Error ( tb , err ) obj C , err : = obj . New Local Client ( wd ) require . No Error ( tb , err ) return obj C , New Storage ( obj C , Prefix ) } 
func ( a * APIServer ) wait Job ( pach Client * client . APIClient , job Info * pps . Job Info , logger * tagged Logger ) ( ret Err error ) { logger . Logf ( " " , job Info . Job . ID ) ctx , cancel : = context . With Cancel ( pach Client . Ctx ( ) ) pach Client = pach Client . With Ctx ( ctx ) if err ! = nil { if pfsserver . Is Commit Not Found Err ( err ) | | pfsserver . Is Commit Deleted Err ( err ) { defer cancel ( ) if err : = a . jobs . Read Write ( stm ) . Get ( job Info . Job . ID , job Ptr ) ; err ! = nil { return err } return a . delete Job ( stm , job Ptr ) } ) ; err ! = nil & & ! col . Is Err Not Found ( err ) { return err } return nil } return err } if commit Info . Trees = = nil { defer cancel ( ) if _ , err : = col . New STM ( ctx , a . etcd Client , func ( stm col . STM ) error { if err : = a . jobs . Read Write ( stm ) . Get ( job Info . Job . ID , job Ptr ) ; err ! = nil { return err } if ! ppsutil . Is Terminal ( job Ptr . State ) { return ppsutil . Update Job State ( a . pipelines . Read Write ( stm ) , a . jobs . Read Write ( stm ) , job Ptr , pps . Job State _JOB _KILLED , " " ) } return nil } ) ; err ! = nil { return err } } return nil } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { if is Done ( ctx ) { return err } return nil } ) } ( ) if job Info . Job Timeout ! = nil { start Time , err : = types . Timestamp From Proto ( job Info . Started ) if err ! = nil { return err } timeout , err : = types . Duration From Proto ( job Info . Job Timeout ) if err ! = nil { return err } after Time : = start Time . Add ( timeout ) . Sub ( time . Now ( ) ) logger . Logf ( " " , after Time ) timer : = time . After Func ( after Time , func ( ) { if _ , err : = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : job Info . Output Commit , Empty : true , } ) ; err ! = nil { logger . Logf ( " " , err ) } } ) defer timer . Stop ( ) } backoff . Retry Notify ( func ( ) ( ret Err error ) { if err ! = nil { return err } if len ( failed Inputs ) > 0 { reason : = fmt . Sprintf ( " " , strings . Join ( failed Inputs , " " ) ) if err : = a . update Job State ( ctx , job Info , nil , pps . Job State _JOB _FAILURE , reason ) ; err ! = nil { return err } _ , err : = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : job Info . Output Commit , Empty : true , } ) return err } if err ! = nil { return err } parallelism , err : = ppsutil . Get Expected Num Workers ( a . kube Client , a . pipeline Info . Parallelism Spec ) if err ! = nil { return fmt . Errorf ( " " , err ) } num Hashtrees , err : = ppsutil . Get Expected Num Hashtrees ( a . pipeline Info . Hashtree Spec ) if err ! = nil { return fmt . Errorf ( " " , err ) } plan : = & Plan { } var stats Trees [ ] * pfs . Object var stats Size uint 6 4 if job Info . Enable Stats { ci , err : = pach Client . Inspect Commit ( job Info . Output Commit . Repo . Name , job Info . Output Commit . ID ) if err ! = nil { return err } for _ , commit Range : = range ci . Subvenance { if commit Range . Lower . Repo . Name = = job Info . Output Repo . Name & & commit Range . Upper . Repo . Name = = job Info . Output Repo . Name { stats Commit = commit Range . Lower } } } if _ , err : = col . New STM ( ctx , a . etcd Client , func ( stm col . STM ) error { jobs : = a . jobs . Read Write ( stm ) job Ptr : = & pps . Etcd Job Info { } if err : = jobs . Get ( job ID , job Ptr ) ; err ! = nil { return err } if job Ptr . State = = pps . Job State _JOB _KILLED { return nil } job Ptr . Data Total = int 6 4 ( df . Len ( ) ) job Ptr . Stats Commit = stats Commit if err : = ppsutil . Update Job State ( a . pipelines . Read Write ( stm ) , a . jobs . Read Write ( stm ) , job Ptr , pps . Job State _JOB _RUNNING , " " ) ; err ! = nil { return err } plans Col : = a . plans . Read Write ( stm ) if err : = plans Col . Get ( job ID , plan ) ; err = = nil { return nil } plan = new Plan ( df , job Info . Chunk Spec , parallelism , num Hashtrees ) return plans Col . Put ( job ID , plan ) } ) ; err ! = nil { return err } defer func ( ) { if ret Err = = nil { if _ , err : = col . New STM ( ctx , a . etcd Client , func ( stm col . STM ) error { chunks Col : = a . chunks ( job ID ) . Read Write ( stm ) chunks Col . Delete All ( ) plans Col : = a . plans . Read Write ( stm ) return plans Col . Delete ( job ID ) } ) ; err ! = nil { ret Err = err } } } ( ) } if job Info . Enable Stats { if _ , err = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : stats Commit , Trees : stats Trees , Size Bytes : stats Size , } ) ; err ! = nil { return err } } _ , err : = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : job Info . Output Commit , Empty : true , } ) return err } var failed Datum ID string for _ , high : = range plan . Chunks { chunk State : = & Chunk State { } if err : = chunks . Watch One F ( fmt . Sprint ( high ) , func ( e * watch . Event ) error { var key string if err : = e . Unmarshal ( & key , chunk State ) ; err ! = nil { return err } if key ! = fmt . Sprint ( high ) { return nil } if chunk State . State ! = State _RUNNING { if chunk State . State = = State _FAILED { failed Datum ID = chunk State . Datum ID } return errutil . Err Break } return nil } ) ; err ! = nil { return err } } if err : = a . update Job State ( ctx , job Info , nil , pps . Job State _JOB _MERGING , " " ) ; err ! = nil { return err } var trees [ ] * pfs . Object var size uint 6 4 if failed Datum ID = = " " | | job Info . Enable Stats { for merge : = int 6 4 ( 0 ) ; merge < plan . Merges ; merge + + { merge State : = & Merge State { } if err : = merges . Watch One F ( fmt . Sprint ( merge ) , func ( e * watch . Event ) error { var key string if err : = e . Unmarshal ( & key , merge State ) ; err ! = nil { return err } if key ! = fmt . Sprint ( merge ) { return nil } if merge State . State ! = State _RUNNING { trees = append ( trees , merge State . Tree ) size + = merge State . Size Bytes stats Trees = append ( stats Trees , merge State . Stats Tree ) stats Size + = merge State . Stats Size Bytes return errutil . Err Break } return nil } ) ; err ! = nil { return err } } } if job Info . Enable Stats { if _ , err = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : stats Commit , Trees : stats Trees , Size Bytes : stats Size , } ) ; err ! = nil { return err } } if err : = a . update Job State ( ctx , job Info , stats Commit , pps . Job State _JOB _FAILURE , reason ) ; err ! = nil { return err } _ , err = pach Client . Pfs APIClient . Finish Commit ( ctx , & pfs . Finish Commit Request { Commit : job Info . Output Commit , Empty : true , } ) return err } pbw : = pbutil . New Writer ( buf ) for i : = 0 ; i < df . Len ( ) ; i + + { files : = df . Datum ( i ) datum Hash : = Hash Datum ( a . pipeline Info . Pipeline . Name , a . pipeline Info . Salt , files ) if _ , err : = pbw . Write Bytes ( [ ] byte ( datum Hash ) ) ; err ! = nil { return err } } datums , _ , err : = pach Client . Put Object ( buf ) if err ! = nil { return err } if err ! = nil & & ! pfsserver . Is Commit Finished Err ( err ) { if pfsserver . Is Commit Not Found Err ( err ) | | pfsserver . Is Commit Deleted Err ( err ) { return nil } return err } return a . update Job State ( ctx , job Info , stats Commit , pps . Job State _JOB _FAILURE , reason ) } return a . update Job State ( ctx , job Info , stats Commit , pps . Job State _JOB _SUCCESS , " " ) } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { logger . Logf ( " " , err , d ) select { case < - ctx . Done ( ) : if err : = ctx . Err ( ) ; err ! = nil { if err = = context . Deadline Exceeded { reason : = fmt . Sprintf ( " " , job Info . Job Timeout ) job ID : = job Info . Job . ID job Ptr : = & pps . Etcd Job Info { } if err : = jobs . Get ( job ID , job Ptr ) ; err ! = nil { return err } err = ppsutil . Update Job State ( a . pipelines . Read Write ( stm ) , a . jobs . Read Write ( stm ) , job Ptr , pps . Job State _JOB _FAILURE , reason ) if err ! = nil { return nil } return nil } ) if err ! = nil { return err } } return err } return err default : } job ID : = job Info . Job . ID job Ptr : = & pps . Etcd Job Info { } if err : = jobs . Get ( job ID , job Ptr ) ; err ! = nil { return err } job Ptr . Restart + + return jobs . Put ( job ID , job Ptr ) } ) if err ! = nil { logger . Logf ( " " , job Info . Job . ID ) } return nil } ) return nil } 
func ( a * APIServer ) delete Job ( stm col . STM , job Ptr * pps . Etcd Job Info ) error { pipeline Ptr : = & pps . Etcd Pipeline Info { } if err : = a . pipelines . Read Write ( stm ) . Update ( job Ptr . Pipeline . Name , pipeline Ptr , func ( ) error { if pipeline Ptr . Job Counts = = nil { pipeline Ptr . Job Counts = make ( map [ int 3 2 ] int 3 2 ) } if pipeline Ptr . Job Counts [ int 3 2 ( job Ptr . State ) ] ! = 0 { pipeline Ptr . Job Counts [ int 3 2 ( job Ptr . State ) ] - - } return nil } ) ; err ! = nil { return err } return a . jobs . Read Write ( stm ) . Delete ( job Ptr . Job . ID ) } 
func write XML ( w http . Response Writer , r * http . Request , code int , v interface { } ) { w . Header ( ) . Set ( " " , " " ) w . Write Header ( code ) encoder : = xml . New Encoder ( w ) if err : = encoder . Encode ( v ) ; err ! = nil { } } 
func clean 1 _ 7Hashtree Path ( p string ) string { if ! strings . Has Prefix ( p , " " ) { p = " " + p } return default 1 _ 7Hashtree Root ( pathlib . Clean ( p ) ) } 
func New From Address ( addr string , options . . . Option ) ( * APIClient , error ) { for _ , option : = range options { if err : = option ( & settings ) ; err ! = nil { return nil , err } } c : = & APIClient { addr : addr , ca Certs : settings . ca Certs , limiter : limit . New ( settings . max Concurrent Streams ) , } if err : = c . connect ( settings . dial Timeout ) ; err ! = nil { return nil , err } return c , nil } 
func With Max Concurrent Streams ( streams int ) Option { return func ( settings * client Settings ) error { settings . max Concurrent Streams = streams return nil } } 
func With Root CAs ( path string ) Option { return func ( settings * client Settings ) error { settings . ca Certs = x 5 0 9 . New Cert Pool ( ) return add Cert From File ( settings . ca Certs , path ) } } 
func With Additional Root CAs ( pem Bytes [ ] byte ) Option { return func ( settings * client Settings ) error { } if ok : = settings . ca Certs . Append Certs From PEM ( pem Bytes ) ; ! ok { return fmt . Errorf ( " " ) } return nil } } 
func With Dial Timeout ( t time . Duration ) Option { return func ( settings * client Settings ) error { settings . dial Timeout = t return nil } } 
func With Additional Pachd Cert ( ) Option { return func ( settings * client Settings ) error { if _ , err : = os . Stat ( grpcutil . TLSVolume Path ) ; err = = nil { if settings . ca Certs = = nil { settings . ca Certs = x 5 0 9 . New Cert Pool ( ) } return add Cert From File ( settings . ca Certs , path . Join ( grpcutil . TLSVolume Path , grpcutil . TLSCert File ) ) } return nil } } 
func get User Machine Addr And Opts ( cfg * config . Config ) ( string , [ ] Option , error ) { } options , err : = get Cert Options From Env ( ) if err ! = nil { return " " , nil , err } return env Addr , options , nil } if err ! = nil { return " " , nil , fmt . Errorf ( " " , err ) } return cfg . V 1 . Pachd Address , [ ] Option { With Additional Root CAs ( pem Bytes ) } , nil } return cfg . V 1 . Pachd Address , nil , nil } if err ! = nil { return " " , nil , err } return " " , options , nil } 
func New On User Machine ( report Metrics bool , port Forward bool , prefix string , options . . . Option ) ( * APIClient , error ) { cfg , err : = config . Read ( ) if err ! = nil { } addr , cfg Options , err : = get User Machine Addr And Opts ( cfg ) if err ! = nil { return nil , err } if addr = = " " { addr = fmt . Sprintf ( " " , Default Pachd Node Port ) if port Forward { fw = port Forwarder ( ) } } client , err : = New From Address ( addr , append ( options , cfg Options . . . ) . . . ) if err ! = nil { if strings . Contains ( err . Error ( ) , " " ) { if colon Idx : = strings . Last Index Byte ( addr , ' : ' ) ; colon Idx > = 0 { port = addr [ colon Idx + 1 : ] } } if strings . Has Prefix ( addr , " " ) | | strings . Has Prefix ( addr , " " ) | | strings . Has Prefix ( addr , " " ) | | strings . Has Prefix ( addr , " " ) { return nil , fmt . Errorf ( " " + " " , addr , err ) } if port = = " " { return nil , fmt . Errorf ( " " + " " , addr , err ) } } return nil , fmt . Errorf ( " " , addr , err ) } if cfg ! = nil & & cfg . User ID ! = " " & & report Metrics { client . metrics User ID = cfg . User ID } if cfg ! = nil & & cfg . V 1 ! = nil & & cfg . V 1 . Session Token ! = " " { client . authentication Token = cfg . V 1 . Session Token } return client , nil } 
func New In Cluster ( options . . . Option ) ( * APIClient , error ) { host , ok : = os . Lookup Env ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } port , ok : = os . Lookup Env ( " " ) if ! ok { return nil , fmt . Errorf ( " " ) } } 
func ( c * APIClient ) Close ( ) error { if err : = c . client Conn . Close ( ) ; err ! = nil { return err } if c . port Forwarder ! = nil { c . port Forwarder . Close ( ) } return nil } 
func ( c APIClient ) Delete All ( ) error { if _ , err : = c . Auth APIClient . Deactivate ( c . Ctx ( ) , & auth . Deactivate Request { } , ) ; err ! = nil & & ! auth . Is Err Not Activated ( err ) { return grpcutil . Scrub GRPC ( err ) } if _ , err : = c . Pps APIClient . Delete All ( c . Ctx ( ) , & types . Empty { } , ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } if _ , err : = c . Pfs APIClient . Delete All ( c . Ctx ( ) , & types . Empty { } , ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } 
func ( c APIClient ) Set Max Concurrent Streams ( n int ) { c . limiter = limit . New ( n ) } 
func Default Dial Options ( ) [ ] grpc . Dial Option { return [ ] grpc . Dial Option { } 
func ( c * APIClient ) Add Metadata ( ctx context . Context ) context . Context { if c . authentication Token ! = " " { client Data [ auth . Context Token Key ] = c . authentication Token } client Data [ " " ] = c . metrics Prefix } outgoing MD , _ : = metadata . From Outgoing Context ( ctx ) client MD : = metadata . New ( client Data ) final MD : = make ( metadata . MD ) for _ , md : = range [ ] metadata . MD { incoming MD , outgoing MD , client MD } { for k , v : = range md { final MD [ k ] = v } } return metadata . New Outgoing Context ( ctx , final MD ) } 
func ( c * APIClient ) Ctx ( ) context . Context { if c . ctx = = nil { return c . Add Metadata ( context . Background ( ) ) } return c . Add Metadata ( c . ctx ) } 
func ( c * APIClient ) With Ctx ( ctx context . Context ) * APIClient { result : = * c result . ctx = ctx return & result } 
func New DLock ( client * etcd . Client , prefix string ) DLock { return & etcd Impl { client : client , prefix : prefix , } } 
func ( a * APIServer ) Datum ID ( data [ ] * Input ) string { hash : = sha 2 5 6 . New ( ) for _ , d : = range data { hash . Write ( [ ] byte ( d . File Info . File . Path ) ) hash . Write ( d . File Info . Hash ) } } 
func ( logger * tagged Logger ) Logf ( format String string , args . . . interface { } ) { logger . template . Message = fmt . Sprintf ( format String , args . . . ) if ts , err : = types . Timestamp Proto ( time . Now ( ) ) ; err = = nil { logger . template . Ts = ts } else { logger . stderr Log . Printf ( " \n " , err ) return } msg , err : = logger . marshaler . Marshal To String ( & logger . template ) if err ! = nil { logger . stderr Log . Printf ( " \n " , & logger . template , err ) return } fmt . Println ( msg ) if logger . put Obj Client ! = nil { logger . msg Ch < - msg + " \n " } } 
func New APIServer ( pach Client * client . APIClient , etcd Client * etcd . Client , etcd Prefix string , pipeline Info * pps . Pipeline Info , worker Name string , namespace string , hashtree Storage string ) ( * APIServer , error ) { init Prometheus ( ) cfg , err : = rest . In Cluster Config ( ) if err ! = nil { return nil , err } kube Client , err : = kube . New For Config ( cfg ) if err ! = nil { return nil , err } server : = & APIServer { pach Client : pach Client , kube Client : kube Client , etcd Client : etcd Client , etcd Prefix : etcd Prefix , pipeline Info : pipeline Info , log Msg Template : pps . Log Message { Pipeline Name : pipeline Info . Pipeline . Name , Worker ID : os . Getenv ( client . PPSPod Name Env ) , } , worker Name : worker Name , namespace : namespace , jobs : ppsdb . Jobs ( etcd Client , etcd Prefix ) , pipelines : ppsdb . Pipelines ( etcd Client , etcd Prefix ) , plans : col . New Collection ( etcd Client , path . Join ( etcd Prefix , plan Prefix ) , nil , & Plan { } , nil , nil ) , shards : col . New Collection ( etcd Client , path . Join ( etcd Prefix , shard Prefix , pipeline Info . Pipeline . Name ) , nil , & Shard Info { } , nil , nil ) , hashtree Storage : hashtree Storage , claimed Shard : make ( chan context . Context , 1 ) , shard : no Shard , clients : make ( map [ string ] Client ) , } logger , err : = server . get Tagged Logger ( pach Client , " " , nil , false ) if err ! = nil { return nil , err } resp , err : = pach Client . Enterprise . Get State ( context . Background ( ) , & enterprise . Get State Request { } ) if err ! = nil { logger . Logf ( " \n " , err ) } else { server . export Stats = resp . State = = enterprise . State _ACTIVE } num Workers , err : = ppsutil . Get Expected Num Workers ( kube Client , pipeline Info . Parallelism Spec ) if err ! = nil { logger . Logf ( " " , err ) num Workers = 1 } server . num Workers = num Workers num Shards , err : = ppsutil . Get Expected Num Hashtrees ( pipeline Info . Hashtree Spec ) if err ! = nil { logger . Logf ( " " , err ) num Shards = 1 } server . num Shards = num Shards root : = filepath . Join ( hashtree Storage , uuid . New Without Dashes ( ) ) if err : = os . Mkdir All ( filepath . Join ( root , " " , " " ) , 0 7 7 7 ) ; err ! = nil { return nil , err } if err : = os . Mkdir All ( filepath . Join ( root , " " , " " ) , 0 7 7 7 ) ; err ! = nil { return nil , err } server . chunk Cache = hashtree . New Merge Cache ( filepath . Join ( root , " " ) ) server . chunk Stats Cache = hashtree . New Merge Cache ( filepath . Join ( root , " " , " " ) ) server . datum Cache = hashtree . New Merge Cache ( filepath . Join ( root , " " ) ) server . datum Stats Cache = hashtree . New Merge Cache ( filepath . Join ( root , " " , " " ) ) var no Docker bool if _ , err : = os . Stat ( " " ) ; err ! = nil { no Docker = true } if pipeline Info . Transform . Image ! = " " & & ! no Docker { docker , err : = docker . New Client From Env ( ) if err ! = nil { return nil , err } image , err : = docker . Inspect Image ( pipeline Info . Transform . Image ) if err ! = nil { return nil , fmt . Errorf ( " " , pipeline Info . Transform . Image , err ) } if pipeline Info . Transform . User = = " " { pipeline Info . Transform . User = image . Config . User } if pipeline Info . Transform . Working Dir = = " " { pipeline Info . Transform . Working Dir = image . Config . Working Dir } if server . pipeline Info . Transform . Cmd = = nil { server . pipeline Info . Transform . Cmd = image . Config . Entrypoint } } if pipeline Info . Transform . User ! = " " { user , err : = lookup Docker User ( pipeline Info . Transform . User ) if err ! = nil & & ! os . Is Not Exist ( err ) { return nil , err } if err ! = nil { return nil , err } uid 3 2 : = uint 3 2 ( uid ) server . uid = & uid 3 2 gid , err : = strconv . Parse Uint ( user . Gid , 1 0 , 3 2 ) if err ! = nil { return nil , err } gid 3 2 : = uint 3 2 ( gid ) server . gid = & gid 3 2 } } switch { case pipeline Info . Service ! = nil : go server . master ( " " , server . service Spawner ) case pipeline Info . Spout ! = nil : go server . master ( " " , server . spout Spawner ) default : go server . master ( " " , server . job Spawner ) } go server . worker ( ) return server , nil } 
func ( a * APIServer ) run User Error Handling Code ( ctx context . Context , logger * tagged Logger , environ [ ] string , stats * pps . Process Stats , raw Datum Timeout * types . Duration ) ( ret Err error ) { logger . Logf ( " " ) defer func ( start time . Time ) { if ret Err ! = nil { logger . Logf ( " " , time . Since ( start ) , ret Err ) } else { logger . Logf ( " " , time . Since ( start ) ) } } ( time . Now ( ) ) cmd : = exec . Command Context ( ctx , a . pipeline Info . Transform . Err Cmd [ 0 ] , a . pipeline Info . Transform . Err Cmd [ 1 : ] . . . ) if a . pipeline Info . Transform . Err Stdin ! = nil { cmd . Stdin = strings . New Reader ( strings . Join ( a . pipeline Info . Transform . Err Stdin , " \n " ) + " \n " ) } cmd . Stdout = logger . user Logger ( ) cmd . Stderr = logger . user Logger ( ) cmd . Env = environ if a . uid ! = nil & & a . gid ! = nil { cmd . Sys Proc Attr = & syscall . Sys Proc Attr { Credential : & syscall . Credential { Uid : * a . uid , Gid : * a . gid , } , } } cmd . Dir = a . pipeline Info . Transform . Working Dir err : = cmd . Start ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err ! = nil { return fmt . Errorf ( " " , err ) } if is Done ( ctx ) { if err = ctx . Err ( ) ; err ! = nil { return err } } } } } } return fmt . Errorf ( " " , err ) } return nil } 
func Hash Datum ( pipeline Name string , pipeline Salt string , data [ ] * Input ) string { hash : = sha 2 5 6 . New ( ) for _ , datum : = range data { hash . Write ( [ ] byte ( datum . Name ) ) hash . Write ( [ ] byte ( datum . File Info . File . Path ) ) hash . Write ( datum . File Info . Hash ) } hash . Write ( [ ] byte ( pipeline Name ) ) hash . Write ( [ ] byte ( pipeline Salt ) ) return client . Datum Tag Prefix ( pipeline Salt ) + hex . Encode To String ( hash . Sum ( nil ) ) } 
func Hash Datum 1 5 ( pipeline Info * pps . Pipeline Info , data [ ] * Input ) ( string , error ) { hash : = sha 2 5 6 . New ( ) for _ , datum : = range data { hash . Write ( [ ] byte ( datum . Name ) ) hash . Write ( [ ] byte ( datum . File Info . File . Path ) ) hash . Write ( datum . File Info . Hash ) } pipeline Info . Transform . Env = nil defer func ( ) { pipeline Info . Transform . Env = env } ( ) bytes , err : = pipeline Info . Transform . Marshal ( ) if err ! = nil { return " " , err } hash . Write ( bytes ) hash . Write ( [ ] byte ( pipeline Info . Pipeline . Name ) ) hash . Write ( [ ] byte ( pipeline Info . ID ) ) hash . Write ( [ ] byte ( strconv . Itoa ( int ( pipeline Info . Version ) ) ) ) } 
func ( a * APIServer ) Status ( ctx context . Context , _ * types . Empty ) ( * pps . Worker Status , error ) { a . status Mu . Lock ( ) defer a . status Mu . Unlock ( ) started , err : = types . Timestamp Proto ( a . started ) if err ! = nil { return nil , err } result : = & pps . Worker Status { Job ID : a . job ID , Worker ID : a . worker Name , Started : started , Data : a . datum ( ) , Queue Size : atomic . Load Int 6 4 ( & a . queue Size ) , } return result , nil } 
func ( a * APIServer ) Cancel ( ctx context . Context , request * Cancel Request ) ( * Cancel Response , error ) { a . status Mu . Lock ( ) defer a . status Mu . Unlock ( ) if request . Job ID ! = a . job ID { return & Cancel Response { Success : false } , nil } if ! Match Datum ( request . Data Filters , a . datum ( ) ) { return & Cancel Response { Success : false } , nil } a . cancel ( ) a . data = nil a . started = time . Time { } a . cancel = nil return & Cancel Response { Success : true } , nil } 
func ( a * APIServer ) Get Chunk ( request * Get Chunk Request , server Worker _Get Chunk Server ) error { filter : = hashtree . New Filter ( a . num Shards , request . Shard ) if request . Stats { return a . chunk Stats Cache . Get ( request . Id , grpcutil . New Streaming Bytes Writer ( server ) , filter ) } return a . chunk Cache . Get ( request . Id , grpcutil . New Streaming Bytes Writer ( server ) , filter ) } 
func ( a * APIServer ) cancel Ctx If Job Fails ( job Ctx context . Context , job Cancel func ( ) , job ID string ) { logger : = a . get Worker Logger ( ) backoff . Retry Notify ( func ( ) error { } if err ! = nil { if col . Is Err Not Found ( err ) { job Cancel ( ) return nil } return fmt . Errorf ( " " , job ID , err ) } job Ptr : = & pps . Etcd Job Info { } if err : = e . Unmarshal ( & job ID , job Ptr ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if ppsutil . Is Terminal ( job Ptr . State ) { job Cancel ( ) } case watch . Event Delete : job Cancel ( ) case watch . Event Error : return fmt . Errorf ( " " , e . Err ) } case < - job Ctx . Done ( ) : break } } } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { if job Ctx . Err ( ) = = context . Canceled { return err } logger . Logf ( " " , job ID , err , d ) return nil } ) } 
func ( a * APIServer ) worker ( ) { logger : = a . get Worker Logger ( ) defer retry Cancel ( ) watcher , err : = a . jobs . Read Only ( retry Ctx ) . Watch By Index ( ppsdb . Jobs Pipeline Index , a . pipeline Info . Pipeline ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer watcher . Close ( ) Next Job : for e : = range watcher . Watch ( ) { } if err : = a . chunk Stats Cache . Clear ( ) ; err ! = nil { logger . Logf ( " " , err ) } if e . Type = = watch . Event Error { return fmt . Errorf ( " " , e . Err ) } else if e . Type = = watch . Event Delete { } job Ptr : = & pps . Etcd Job Info { } if err : = e . Unmarshal ( & job ID , job Ptr ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if ppsutil . Is Terminal ( job Ptr . State ) { continue Next Job } defer job Cancel ( ) pach Client : = a . pach Client . With Ctx ( job Ctx ) if err ! = nil { if col . Is Err Not Found ( err ) { continue Next Job } return fmt . Errorf ( " " , job ID , err ) } if job Info . Pipeline Version < a . pipeline Info . Version { continue } if job Info . Pipeline Version > a . pipeline Info . Version { return fmt . Errorf ( " " + " " + " " , job ID , job Info . Pipeline Version , a . pipeline Info . Version ) } if err : = a . plans . Read Only ( job Ctx ) . Get Block ( job Info . Job . ID , plan ) ; err ! = nil { return err } df , err : = New Datum Factory ( pach Client , job Info . Input ) if err ! = nil { return fmt . Errorf ( " " , err ) } var use Parent Hash Tree bool parent Commit Info , err : = a . get Parent Commit Info ( job Ctx , pach Client , job Info . Output Commit ) if err ! = nil { return err } if parent Commit Info ! = nil { var err error skip , err = a . get Commit Datums ( job Ctx , pach Client , parent Commit Info ) if err ! = nil { return err } var count int for i : = 0 ; i < df . Len ( ) ; i + + { files : = df . Datum ( i ) datum Hash : = Hash Datum ( a . pipeline Info . Pipeline . Name , a . pipeline Info . Salt , files ) if _ , ok : = skip [ datum Hash ] ; ok { count + + } } if len ( skip ) = = count { use Parent Hash Tree = true } } if err ! = nil { return err } eg , ctx : = errgroup . With Context ( job Ctx ) if err ! = nil { return nil , err } return process Result , nil } , ) } ) eg . Go ( func ( ) error { return a . merge Datums ( ctx , pach Client , job Info , job ID , plan , logger , df , skip , use Parent Hash Tree ) } ) if err : = eg . Wait ( ) ; err ! = nil { if job Ctx . Err ( ) = = context . Canceled { continue Next Job } return fmt . Errorf ( " " , job ID , err ) } } return fmt . Errorf ( " " , a . pipeline Info . Pipeline . Name ) } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { logger . Logf ( " " , err , d ) return nil } ) } 
func ( a * APIServer ) process Datums ( pach Client * client . APIClient , logger * tagged Logger , job Info * pps . Job Info , df Datum Factory , low , high int 6 4 , skip map [ string ] struct { } , use Parent Hash Tree bool ) ( result * process Result , ret Err error ) { defer func ( ) { if err : = a . datum Cache . Clear ( ) ; err ! = nil & & ret Err = = nil { logger . Logf ( " " , err ) } if err : = a . datum Stats Cache . Clear ( ) ; err ! = nil & & ret Err = = nil { logger . Logf ( " " , err ) } } ( ) ctx : = pach Client . Ctx ( ) obj Client , err : = obj . New Client From Env ( a . hashtree Storage ) if err ! = nil { return nil , err } stats : = & pps . Process Stats { } var stats Mu sync . Mutex result = & process Result { } var eg errgroup . Group limiter : = limit . New ( int ( a . pipeline Info . Max Queue Size ) ) for i : = low ; i < high ; i + + { datum Idx : = i limiter . Acquire ( ) atomic . Add Int 6 4 ( & a . queue Size , 1 ) eg . Go ( func ( ) ( ret Err error ) { defer limiter . Release ( ) defer atomic . Add Int 6 4 ( & a . queue Size , - 1 ) data : = df . Datum ( int ( datum Idx ) ) logger , err : = a . get Tagged Logger ( pach Client , job Info . Job . ID , data , a . pipeline Info . Enable Stats ) if err ! = nil { return err } if _ , ok : = skip [ tag ] ; ok { if ! use Parent Hash Tree { if err : = a . cache Hashtree ( pach Client , tag , datum Idx ) ; err ! = nil { return err } } atomic . Add Int 6 4 ( & result . datums Skipped , 1 ) logger . Logf ( " " ) return nil } if _ , err : = pach Client . Inspect Tag ( ctx , client . New Tag ( tag ) ) ; err = = nil { if err : = a . cache Hashtree ( pach Client , tag , datum Idx ) ; err ! = nil { return err } atomic . Add Int 6 4 ( & result . datums Skipped , 1 ) logger . Logf ( " " ) return nil } sub Stats : = & pps . Process Stats { } var input Tree , output Tree * hashtree . Ordered var stats Tree * hashtree . Unordered if a . pipeline Info . Enable Stats { stats Root : = path . Join ( " " , logger . template . Datum ID ) input Tree = hashtree . New Ordered ( path . Join ( stats Root , " " ) ) output Tree = hashtree . New Ordered ( path . Join ( stats Root , " " , " " ) ) stats Tree = hashtree . New Unordered ( stats Root ) if err ! = nil { return err } object Info , err : = pach Client . Inspect Object ( object . Hash ) if err ! = nil { return err } h , err : = pfs . Decode Hash ( object . Hash ) if err ! = nil { return err } stats Tree . Put File ( " " , h , size , object Info . Block Ref ) defer func ( ) { if err : = a . write Stats ( pach Client , obj Client , tag , sub Stats , logger , input Tree , output Tree , stats Tree , datum Idx ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) } env : = a . user Code Env ( job Info . Job . ID , job Info . Output Commit . ID , data ) var dir string var failures int 6 4 if err : = backoff . Retry Notify ( func ( ) error { if is Done ( ctx ) { return ctx . Err ( ) } dir , err = a . download Data ( pach Client , logger , data , puller , sub Stats , input Tree ) } } ( ) } } ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } a . run Mu . Lock ( ) defer a . run Mu . Unlock ( ) pach Client : = pach Client . With Ctx ( ctx ) func ( ) { a . status Mu . Lock ( ) defer a . status Mu . Unlock ( ) a . job ID = job Info . Job . ID a . data = data a . started = time . Now ( ) a . cancel = cancel a . stats = stats } ( ) if err : = os . Mkdir All ( client . PPSInput Prefix , 0 7 7 7 ) ; err ! = nil { return err } if err : = a . link Data ( data , dir ) ; err ! = nil { return fmt . Errorf ( " " , err ) } defer func ( ) { if err : = a . unlink Data ( data ) ; err ! = nil & & ret Err = = nil { ret Err = fmt . Errorf ( " " , err ) } } ( ) } return err } ) } if err : = a . run User Code ( ctx , logger , env , sub Stats , job Info . Datum Timeout ) ; err ! = nil { if a . pipeline Info . Transform . Err Cmd ! = nil & & failures = = job Info . Datum Tries - 1 { if err = a . run User Error Handling Code ( ctx , logger , env , sub Stats , job Info . Datum Timeout ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return err Datum Recovered } return fmt . Errorf ( " " , err ) } if err ! = nil { logger . Logf ( " " , err ) return err } atomic . Add Uint 6 4 ( & sub Stats . Download Bytes , uint 6 4 ( down Size ) ) a . report Download Size Stats ( float 6 4 ( down Size ) , logger ) return a . upload Output ( pach Client , dir , tag , logger , data , sub Stats , output Tree , datum Idx ) } , & backoff . Zero Back Off { } , func ( err error , d time . Duration ) error { if is Done ( ctx ) { return ctx . Err ( ) } failures + + if failures > = job Info . Datum Tries { logger . Logf ( " " , err ) if stats Tree ! = nil { object , size , err : = pach Client . Put Object ( strings . New Reader ( err . Error ( ) ) ) if err ! = nil { logger . stderr Log . Printf ( " \n " , err ) } else { object Info , err : = pach Client . Inspect Object ( object . Hash ) if err ! = nil { return err } h , err : = pfs . Decode Hash ( object . Hash ) if err ! = nil { return err } stats Tree . Put File ( " " , h , size , object Info . Block Ref ) } } return err } logger . Logf ( " " , err , d ) return nil } ) ; err = = err Datum Recovered { atomic . Add Int 6 4 ( & result . datums Recovered , 1 ) return nil } else if err ! = nil { result . failed Datum ID = a . Datum ID ( data ) atomic . Add Int 6 4 ( & result . datums Failed , 1 ) return nil } stats Mu . Lock ( ) defer stats Mu . Unlock ( ) if err : = merge Stats ( stats , sub Stats ) ; err ! = nil { logger . Logf ( " " , err ) } return nil } ) } if err : = eg . Wait ( ) ; err ! = nil { return nil , err } if _ , err : = col . New STM ( ctx , a . etcd Client , func ( stm col . STM ) error { jobs : = a . jobs . Read Write ( stm ) job ID : = job Info . Job . ID job Ptr : = & pps . Etcd Job Info { } if err : = jobs . Get ( job ID , job Ptr ) ; err ! = nil { return err } if job Ptr . Stats = = nil { job Ptr . Stats = & pps . Process Stats { } } if err : = merge Stats ( job Ptr . Stats , stats ) ; err ! = nil { logger . Logf ( " " , err ) } return jobs . Put ( job ID , job Ptr ) } ) ; err ! = nil { return nil , err } result . datums Processed = high - low - result . datums Skipped - result . datums Failed - result . datums Recovered } return result , nil } 
func merge Stats ( x , y * pps . Process Stats ) error { var err error if x . Download Time , err = plus Duration ( x . Download Time , y . Download Time ) ; err ! = nil { return err } if x . Process Time , err = plus Duration ( x . Process Time , y . Process Time ) ; err ! = nil { return err } if x . Upload Time , err = plus Duration ( x . Upload Time , y . Upload Time ) ; err ! = nil { return err } x . Download Bytes + = y . Download Bytes x . Upload Bytes + = y . Upload Bytes return nil } 
func ( a * APIServer ) merge Chunk ( logger * tagged Logger , high int 6 4 , result * process Result ) ( ret Err error ) { logger . Logf ( " " ) defer func ( start time . Time ) { if ret Err ! = nil { logger . Logf ( " " , time . Since ( start ) , ret Err ) } else { logger . Logf ( " " , time . Since ( start ) ) } } ( time . Now ( ) ) buf : = & bytes . Buffer { } if result . datums Failed < = 0 { if err : = a . datum Cache . Merge ( hashtree . New Writer ( buf ) , nil , nil ) ; err ! = nil { return err } } if err : = a . chunk Cache . Put ( high , buf ) ; err ! = nil { return err } if a . pipeline Info . Enable Stats { buf . Reset ( ) if err : = a . datum Stats Cache . Merge ( hashtree . New Writer ( buf ) , nil , nil ) ; err ! = nil { return err } return a . chunk Stats Cache . Put ( high , buf ) } return nil } 
func lookup Docker User ( user Arg string ) ( _ * user . User , ret Err error ) { user Parts : = strings . Split ( user Arg , " " ) user Or UID : = user Parts [ 0 ] group Or GID : = " " if len ( user Parts ) > 1 { group Or GID = user Parts [ 1 ] } passwd , err : = os . Open ( " " ) if err ! = nil { return nil , err } defer func ( ) { if err : = passwd . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) scanner : = bufio . New Scanner ( passwd ) for scanner . Scan ( ) { parts : = strings . Split ( scanner . Text ( ) , " " ) if parts [ 0 ] = = user Or UID | | parts [ 2 ] = = user Or UID { result : = & user . User { Username : parts [ 0 ] , Uid : parts [ 2 ] , Gid : parts [ 3 ] , Name : parts [ 4 ] , Home Dir : parts [ 5 ] , } if group Or GID ! = " " { if parts [ 0 ] = = user Or UID { if err ! = nil { return nil , err } result . Gid = group . Gid } else { } } return result , nil } } if err : = scanner . Err ( ) ; err ! = nil { log . Fatal ( err ) } return nil , fmt . Errorf ( " " , user Arg ) } 
func Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command raw : = false raw Flags : = pflag . New Flag Set ( " " , pflag . Continue On Error ) raw Flags . Bool Var ( & raw , " " , false , " " ) full Timestamps : = false full Timestamps Flags : = pflag . New Flag Set ( " " , pflag . Continue On Error ) full Timestamps Flags . Bool Var ( & full Timestamps , " " , false , " " ) marshaller : = & jsonpb . Marshaler { Indent : " " } repo Docs : = & cobra . Command { Short : " " , Long : `Repos , short for repository , are the top level data objects in Pachyderm . Repos contain version -controlled directories and files . Files can be of any size or type (e .g . csv , binary , images , etc ) . ` , } cmdutil . Set Docs Usage ( repo Docs ) commands = append ( commands , cmdutil . Create Alias ( repo Docs , " " ) ) var description string create Repo : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) _ , err = c . Pfs APIClient . Create Repo ( c . Ctx ( ) , & pfsclient . Create Repo Request { Repo : client . New Repo ( args [ 0 ] ) , Description : description , } , ) return grpcutil . Scrub GRPC ( err ) } ) , } create Repo . Flags ( ) . String Var P ( & description , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( create Repo , " " ) ) update Repo : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) _ , err = c . Pfs APIClient . Create Repo ( c . Ctx ( ) , & pfsclient . Create Repo Request { Repo : client . New Repo ( args [ 0 ] ) , Description : description , Update : true , } , ) return grpcutil . Scrub GRPC ( err ) } ) , } update Repo . Flags ( ) . String Var P ( & description , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( update Repo , " " ) ) inspect Repo : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) repo Info , err : = c . Inspect Repo ( args [ 0 ] ) if err ! = nil { return err } if repo Info = = nil { return fmt . Errorf ( " " , args [ 0 ] ) } if raw { return marshaller . Marshal ( os . Stdout , repo Info ) } ri : = & pretty . Printable Repo Info { Repo Info : repo Info , Full Timestamps : full Timestamps , } return pretty . Print Detailed Repo Info ( ri ) } ) , } inspect Repo . Flags ( ) . Add Flag Set ( raw Flags ) inspect Repo . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect Repo , " " ) ) list Repo : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) repo Infos , err : = c . List Repo ( ) if err ! = nil { return err } if raw { for _ , repo Info : = range repo Infos { if err : = marshaller . Marshal ( os . Stdout , repo Info ) ; err ! = nil { return err } } return nil } header : = pretty . Repo Header if ( len ( repo Infos ) > 0 ) & & ( repo Infos [ 0 ] . Auth Info ! = nil ) { header = pretty . Repo Auth Header } writer : = tabwriter . New Writer ( os . Stdout , header ) for _ , repo Info : = range repo Infos { pretty . Print Repo Info ( writer , repo Info , full Timestamps ) } return writer . Flush ( ) } ) , } list Repo . Flags ( ) . Add Flag Set ( raw Flags ) list Repo . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( list Repo , " " ) ) var force bool var all bool delete Repo : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Bounded Args ( 0 , 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if len ( args ) > 0 & & all { return fmt . Errorf ( " " ) } if len ( args ) = = 0 & & ! all { return fmt . Errorf ( " " ) } if all { _ , err = client . Pfs APIClient . Delete Repo ( client . Ctx ( ) , & pfsclient . Delete Repo Request { Force : force , All : all , } ) } else { err = client . Delete Repo ( args [ 0 ] , force ) } if err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } ) , } delete Repo . Flags ( ) . Bool Var P ( & force , " " , " " , false , " " ) delete Repo . Flags ( ) . Bool Var ( & all , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( delete Repo , " " ) ) commit Docs : = & cobra . Command { Short : " " , Long : `Commits are atomic transactions on the content of a repo . Creating a commit is a multistep process : - start a new commit with 'start commit ' - write files to the commit via 'put file ' - finish the new commit with 'finish commit ' Commits that have been started but not finished are NOT durable storage . Commits become reliable (and immutable ) when they are finished . Commits can be created with another commit as a parent . ` , } cmdutil . Set Docs Usage ( commit Docs ) commands = append ( commands , cmdutil . Create Alias ( commit Docs , " " ) ) var parent string start Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Start a new commit in repo "test " that 's not on any branch $ { {alias } } test # Start a commit in repo "test " on branch "master " $ { {alias } } test @master # Start a commit with "master " as the parent in repo "test " , on a new branch "patch " ; essentially a fork . $ { {alias } } test @patch -p master # Start a commit with XXX as the parent in repo "test " , not on any branch $ { {alias } } test -p XXX ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { branch , err : = cmdutil . Parse Branch ( args [ 0 ] ) if err ! = nil { return err } cli , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer cli . Close ( ) commit , err : = cli . Pfs APIClient . Start Commit ( cli . Ctx ( ) , & pfsclient . Start Commit Request { Branch : branch . Name , Parent : client . New Commit ( branch . Repo . Name , parent ) , Description : description , } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } fmt . Println ( commit . ID ) return nil } ) , } start Commit . Flags ( ) . String Var P ( & parent , " " , " " , " " , " " ) start Commit . Mark Flag Custom ( " " , " " ) start Commit . Flags ( ) . String Var P ( & description , " " , " " , " " , " " ) start Commit . Flags ( ) . String Var ( & description , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( start Commit , " " ) ) finish Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { commit , err : = cmdutil . Parse Commit ( args [ 0 ] ) if err ! = nil { return err } cli , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer cli . Close ( ) if description ! = " " { _ , err : = cli . Pfs APIClient . Finish Commit ( cli . Ctx ( ) , & pfsclient . Finish Commit Request { Commit : commit , Description : description , } ) return grpcutil . Scrub GRPC ( err ) } return cli . Finish Commit ( commit . Repo . Name , commit . ID ) } ) , } finish Commit . Flags ( ) . String Var P ( & description , " " , " " , " " , " " ) finish Commit . Flags ( ) . String Var ( & description , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( finish Commit , " " ) ) inspect Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { commit , err : = cmdutil . Parse Commit ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) commit Info , err : = client . Inspect Commit ( commit . Repo . Name , commit . ID ) if err ! = nil { return err } if commit Info = = nil { return fmt . Errorf ( " " , commit . ID ) } if raw { return marshaller . Marshal ( os . Stdout , commit Info ) } ci : = & pretty . Printable Commit Info { Commit Info : commit Info , Full Timestamps : full Timestamps , } return pretty . Print Detailed Commit Info ( ci ) } ) , } inspect Commit . Flags ( ) . Add Flag Set ( raw Flags ) inspect Commit . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect Commit , " " ) ) var from string var number int list Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # return commits in repo "foo " $ { {alias } } foo # return commits in repo "foo " on branch "master " $ { {alias } } foo @master # return the last 2 0 commits in repo "foo " on branch "master " $ { {alias } } foo @master -n 2 0 # return commits in repo "foo " since commit XXX $ { {alias } } foo @master - -from XXX ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) ( ret Err error ) { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) branch , err : = cmdutil . Parse Branch ( args [ 0 ] ) if err ! = nil { return err } if raw { return c . List Commit F ( branch . Repo . Name , branch . Name , from , uint 6 4 ( number ) , func ( ci * pfsclient . Commit Info ) error { return marshaller . Marshal ( os . Stdout , ci ) } ) } writer : = tabwriter . New Writer ( os . Stdout , pretty . Commit Header ) if err : = c . List Commit F ( branch . Repo . Name , branch . Name , from , uint 6 4 ( number ) , func ( ci * pfsclient . Commit Info ) error { pretty . Print Commit Info ( writer , ci , full Timestamps ) return nil } ) ; err ! = nil { return err } return writer . Flush ( ) } ) , } list Commit . Flags ( ) . String Var P ( & from , " " , " " , " " , " " ) list Commit . Flags ( ) . Int Var P ( & number , " " , " " , 0 , " " ) list Commit . Mark Flag Custom ( " " , " " ) list Commit . Flags ( ) . Add Flag Set ( raw Flags ) list Commit . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( list Commit , " " ) ) print Commit Iter : = func ( commit Iter client . Commit Info Iterator ) error { if raw { for { commit Info , err : = commit Iter . Next ( ) if err = = io . EOF { return nil } if err ! = nil { return err } if err : = marshaller . Marshal ( os . Stdout , commit Info ) ; err ! = nil { return err } } } writer : = tabwriter . New Writer ( os . Stdout , pretty . Commit Header ) for { commit Info , err : = commit Iter . Next ( ) if err = = io . EOF { break } if err ! = nil { return err } pretty . Print Commit Info ( writer , commit Info , full Timestamps ) } return writer . Flush ( ) } var repos cmdutil . Repeated String Arg flush Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # return commits caused by foo @XXX and bar @YYY $ { {alias } } foo @XXX bar @YYY # return commits caused by foo @XXX leading to repos bar and baz $ { {alias } } foo @XXX -r bar -r baz ` , Run : cmdutil . Run ( func ( args [ ] string ) error { commits , err : = cmdutil . Parse Commits ( args ) if err ! = nil { return err } c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) var to Repos [ ] * pfsclient . Repo for _ , repo Name : = range repos { to Repos = append ( to Repos , client . New Repo ( repo Name ) ) } commit Iter , err : = c . Flush Commit ( commits , to Repos ) if err ! = nil { return err } return print Commit Iter ( commit Iter ) } ) , } flush Commit . Flags ( ) . Var P ( & repos , " " , " " , " " ) flush Commit . Mark Flag Custom ( " " , " " ) flush Commit . Flags ( ) . Add Flag Set ( raw Flags ) flush Commit . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( flush Commit , " " ) ) var new Commits bool subscribe Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # subscribe to commits in repo "test " on branch "master " $ { {alias } } test @master # subscribe to commits in repo "test " on branch "master " , but only since commit XXX . $ { {alias } } test @master - -from XXX # subscribe to commits in repo "test " on branch "master " , but only for new commits created from now on . $ { {alias } } test @master - -new ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { branch , err : = cmdutil . Parse Branch ( args [ 0 ] ) if err ! = nil { return err } c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) if new Commits & & from ! = " " { return fmt . Errorf ( " " ) } if new Commits { from = branch . Name } commit Iter , err : = c . Subscribe Commit ( branch . Repo . Name , branch . Name , from , pfsclient . Commit State _STARTED ) if err ! = nil { return err } return print Commit Iter ( commit Iter ) } ) , } subscribe Commit . Flags ( ) . String Var ( & from , " " , " " , " " ) subscribe Commit . Mark Flag Custom ( " " , " " ) subscribe Commit . Flags ( ) . Bool Var ( & new Commits , " " , false , " " ) subscribe Commit . Flags ( ) . Add Flag Set ( raw Flags ) subscribe Commit . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( subscribe Commit , " " ) ) delete Commit : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { commit , err : = cmdutil . Parse Commit ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Delete Commit ( commit . Repo . Name , commit . ID ) } ) , } commands = append ( commands , cmdutil . Create Alias ( delete Commit , " " ) ) branch Docs : = & cobra . Command { Short : " " , Long : `A branch in Pachyderm is an alias for a Commit ID . The branch reference will "float " to always refer to the latest commit on the branch , known as the HEAD commit . Not all commits must be on a branch and multiple branches can refer to the same commit . Any pachctl command that can take a Commit ID , can take a branch name instead . ` , } cmdutil . Set Docs Usage ( branch Docs ) commands = append ( commands , cmdutil . Create Alias ( branch Docs , " " ) ) var branch Provenance cmdutil . Repeated String Arg var head string create Branch : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { branch , err : = cmdutil . Parse Branch ( args [ 0 ] ) if err ! = nil { return err } provenance , err : = cmdutil . Parse Branches ( branch Provenance ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Create Branch ( branch . Repo . Name , branch . Name , head , provenance ) } ) , } create Branch . Flags ( ) . Var P ( & branch Provenance , " " , " " , " " ) create Branch . Mark Flag Custom ( " " , " " ) create Branch . Flags ( ) . String Var P ( & head , " " , " " , " " , " " ) create Branch . Mark Flag Custom ( " " , " " ) commands = append ( commands , cmdutil . Create Alias ( create Branch , " " ) ) list Branch : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) branches , err : = client . List Branch ( args [ 0 ] ) if err ! = nil { return err } if raw { for _ , branch : = range branches { if err : = marshaller . Marshal ( os . Stdout , branch ) ; err ! = nil { return err } } return nil } writer : = tabwriter . New Writer ( os . Stdout , pretty . Branch Header ) for _ , branch : = range branches { pretty . Print Branch ( writer , branch ) } return writer . Flush ( ) } ) , } list Branch . Flags ( ) . Add Flag Set ( raw Flags ) commands = append ( commands , cmdutil . Create Alias ( list Branch , " " ) ) delete Branch : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { branch , err : = cmdutil . Parse Branch ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Delete Branch ( branch . Repo . Name , branch . Name , force ) } ) , } delete Branch . Flags ( ) . Bool Var P ( & force , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( delete Branch , " " ) ) file Docs : = & cobra . Command { Short : " " , Long : `Files are the lowest level data objects in Pachyderm . Files can be of any type (e .g . csv , binary , images , etc ) or size and can be written to started (but not finished ) commits with 'put file ' . Files can be read from commits with 'get file ' . ` , } cmdutil . Set Docs Usage ( file Docs ) commands = append ( commands , cmdutil . Create Alias ( file Docs , " " ) ) var file Paths [ ] string var recursive bool var input File string var parallelism int var split string var target File Datums uint var target File Bytes uint var header Records uint var put File Commit bool var overwrite bool put File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Put data from stdin as repo /branch /path : $ echo "data " | { {alias } } repo branch path # Put data from stdin as repo /branch /path and start / finish a new commit on the branch . $ echo "data " | { {alias } } -c repo branch path # Put a file from the local filesystem as repo /branch /path : $ { {alias } } repo branch path -f file # Put a file from the local filesystem as repo /branch /file : $ { {alias } } repo branch -f file # Put the contents of a directory as repo /branch /path /dir /file : $ { {alias } } -r repo branch path -f dir # Put the contents of a directory as repo /branch /dir /file : $ { {alias } } -r repo branch -f dir # Put the contents of a directory as repo /branch /file , i .e . put files at the top level : $ { {alias } } -r repo branch / -f dir # Put the data from a URL as repo /branch /path : $ { {alias } } repo branch path -f http : / /host /path # Put the data from a URL as repo /branch /path : $ { {alias } } repo branch -f http : / /host /path # Put the data from an S 3 bucket as repo /branch /s 3 _object : $ { {alias } } repo branch -r -f s 3 : / /my _bucket # Put several files or URLs that are listed in file . # Files and URLs should be newline delimited . $ { {alias } } repo branch -i file # Put several files or URLs that are listed at URL . # NOTE this URL can reference local files , so it could cause you to put sensitive # files into your Pachyderm cluster . $ { {alias } } repo branch -i http : / /host /path ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) ( ret Err error ) { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " , client . With Max Concurrent Streams ( parallelism ) ) if err ! = nil { return err } defer c . Close ( ) pfc , err : = c . New Put File Client ( ) if err ! = nil { return err } defer func ( ) { if err : = pfc . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) if put File Commit { fmt . Fprintf ( os . Stderr , " \n " ) } limiter : = limit . New ( int ( parallelism ) ) var sources [ ] string if input File ! = " " { / / User has provided a file listing sources , one per line . Read sources var r io . Reader if input File = = " " { r = os . Stdin } else if url , err : = url . Parse ( input File ) ; err = = nil & & url . Scheme ! = " " { resp , err : = http . Get ( url . String ( ) ) if err ! = nil { return err } defer func ( ) { if err : = resp . Body . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) r = resp . Body } else { input File , err : = os . Open ( input File ) if err ! = nil { return err } defer func ( ) { if err : = input File . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) r = input File } / / scan line by line scanner : = bufio . New Scanner ( r ) for scanner . Scan ( ) { if file Path : = scanner . Text ( ) ; file Path ! = " " { sources = append ( sources , file Path ) } } } else { / / User has provided a single source sources = file Paths } / / Arguments parsed ; create put File Helper and begin copying data var eg errgroup . Group files Put : = & gosync . Map { } for _ , source : = range sources { source : = source if file . Path = = " " { / / The user has not specified a path so we use source as path . if source = = " " { return fmt . Errorf ( " " ) } eg . Go ( func ( ) error { return put File Helper ( c , pfc , file . Commit . Repo . Name , file . Commit . ID , join Paths ( " " , source ) , source , recursive , overwrite , limiter , split , target File Datums , target File Bytes , header Records , files Put ) } ) } else if len ( sources ) = = 1 { / / We have a single source and the user has specified a path , / / we use the path and ignore source (in terms of naming the file ) . eg . Go ( func ( ) error { return put File Helper ( c , pfc , file . Commit . Repo . Name , file . Commit . ID , file . Path , source , recursive , overwrite , limiter , split , target File Datums , target File Bytes , header Records , files Put ) } ) } else { / / We have multiple sources and the user has specified a path , / / we use that path as a prefix for the filepaths . eg . Go ( func ( ) error { return put File Helper ( c , pfc , file . Commit . Repo . Name , file . Commit . ID , join Paths ( file . Path , source ) , source , recursive , overwrite , limiter , split , target File Datums , target File Bytes , header Records , files Put ) } ) } } return eg . Wait ( ) } ) , } put File . Flags ( ) . String Slice Var P ( & file Paths , " " , " " , [ ] string { " " } , " " ) put File . Flags ( ) . String Var P ( & input File , " " , " " , " " , " " ) put File . Flags ( ) . Bool Var P ( & recursive , " " , " " , false , " " ) put File . Flags ( ) . Int Var P ( & parallelism , " " , " " , Default Parallelism , " " ) put File . Flags ( ) . String Var ( & split , " " , " " , " " ) put File . Flags ( ) . Uint Var ( & target File Datums , " " , 0 , " " ) put File . Flags ( ) . Uint Var ( & target File Bytes , " " , 0 , " " ) put File . Flags ( ) . Uint Var ( & header Records , " " , 0 , " " ) put File . Flags ( ) . Bool Var P ( & put File Commit , " " , " " , false , " " ) put File . Flags ( ) . Bool Var P ( & overwrite , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( put File , " " ) ) copy File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 2 , func ( args [ ] string ) ( ret Err error ) { src File , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } dest File , err : = cmdutil . Parse File ( args [ 1 ] ) if err ! = nil { return err } c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " , client . With Max Concurrent Streams ( parallelism ) ) if err ! = nil { return err } defer c . Close ( ) return c . Copy File ( src File . Commit . Repo . Name , src File . Commit . ID , src File . Path , dest File . Commit . Repo . Name , dest File . Commit . ID , dest File . Path , overwrite , ) } ) , } copy File . Flags ( ) . Bool Var P ( & overwrite , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( copy File , " " ) ) var output Path string get File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # get file "XXX " on branch "master " in repo "foo " $ { {alias } } foo @master :XXX # get file "XXX " in the parent of the current head of branch "master " # in repo "foo " $ { {alias } } foo @master ^ :XXX # get file "XXX " in the grandparent of the current head of branch "master " # in repo "foo " $ { {alias } } foo @master ^ 2 :XXX ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if recursive { if output Path = = " " { return fmt . Errorf ( " " ) } puller : = sync . New Puller ( ) return puller . Pull ( client , output Path , file . Commit . Repo . Name , file . Commit . ID , file . Path , false , false , parallelism , nil , " " ) } var w io . Writer / / If an output path is given , print the output to stdout if output Path = = " " { w = os . Stdout } else { f , err : = os . Create ( output Path ) if err ! = nil { return err } defer f . Close ( ) w = f } return client . Get File ( file . Commit . Repo . Name , file . Commit . ID , file . Path , 0 , 0 , w ) } ) , } get File . Flags ( ) . Bool Var P ( & recursive , " " , " " , false , " " ) get File . Flags ( ) . String Var P ( & output Path , " " , " " , " " , " " ) get File . Flags ( ) . Int Var P ( & parallelism , " " , " " , Default Parallelism , " " ) commands = append ( commands , cmdutil . Create Alias ( get File , " " ) ) inspect File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) file Info , err : = client . Inspect File ( file . Commit . Repo . Name , file . Commit . ID , file . Path ) if err ! = nil { return err } if file Info = = nil { return fmt . Errorf ( " " , file . Path ) } if raw { return marshaller . Marshal ( os . Stdout , file Info ) } return pretty . Print Detailed File Info ( file Info ) } ) , } inspect File . Flags ( ) . Add Flag Set ( raw Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect File , " " ) ) var history int 6 4 list File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # list top -level files on branch "master " in repo "foo " $ { {alias } } foo @master # list files under directory "dir " on branch "master " in repo "foo " $ { {alias } } foo @master :dir # list top -level files in the parent commit of the current head of "master " # in repo "foo " $ { {alias } } foo @master ^ # list top -level files in the grandparent of the current head of "master " # in repo "foo " $ { {alias } } foo @master ^ 2 # list the last n versions of top -level files on branch "master " in repo "foo " $ { {alias } } foo @master - -history n # list all versions of top -level files on branch "master " in repo "foo " $ { {alias } } foo @master - -history - 1 ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if raw { return client . List File F ( file . Commit . Repo . Name , file . Commit . ID , file . Path , history , func ( fi * pfsclient . File Info ) error { return marshaller . Marshal ( os . Stdout , fi ) } ) } writer : = tabwriter . New Writer ( os . Stdout , pretty . File Header ) if err : = client . List File F ( file . Commit . Repo . Name , file . Commit . ID , file . Path , history , func ( fi * pfsclient . File Info ) error { pretty . Print File Info ( writer , fi , full Timestamps ) return nil } ) ; err ! = nil { return err } return writer . Flush ( ) } ) , } list File . Flags ( ) . Add Flag Set ( raw Flags ) list File . Flags ( ) . Add Flag Set ( full Timestamps Flags ) list File . Flags ( ) . Int 6 4Var ( & history , " " , 0 , " " ) commands = append ( commands , cmdutil . Create Alias ( list File , " " ) ) glob File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Return files in repo "foo " on branch "master " that start # with the character "A " . Note how the double quotation marks around the # parameter are necessary because otherwise your shell might interpret the " * " . $ { {alias } } "foo @master :A * " # Return files in repo "foo " on branch "master " under directory "data " . $ { {alias } } "foo @master :data / * " ` , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) file Infos , err : = client . Glob File ( file . Commit . Repo . Name , file . Commit . ID , file . Path ) if err ! = nil { return err } if raw { for _ , file Info : = range file Infos { if err : = marshaller . Marshal ( os . Stdout , file Info ) ; err ! = nil { return err } } return nil } writer : = tabwriter . New Writer ( os . Stdout , pretty . File Header ) for _ , file Info : = range file Infos { pretty . Print File Info ( writer , file Info , full Timestamps ) } return writer . Flush ( ) } ) , } glob File . Flags ( ) . Add Flag Set ( raw Flags ) glob File . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( glob File , " " ) ) var shallow bool diff File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Return the diff of the file "path " of the repo "foo " between the head of the # "master " branch and its parent . $ { {alias } } foo @master :path # Return the diff between the master branches of repos foo and bar at paths # path 1 and path 2 , respectively . $ { {alias } } foo @master :path 1 bar @master :path 2 ` , Run : cmdutil . Run Bounded Args ( 1 , 2 , func ( args [ ] string ) error { new File , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } old File : = client . New File ( " " , " " , " " ) if len ( args ) = = 2 { old File , err = cmdutil . Parse File ( args [ 1 ] ) if err ! = nil { return err } } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) new Files , old Files , err : = client . Diff File ( new File . Commit . Repo . Name , new File . Commit . ID , new File . Path , old File . Commit . Repo . Name , old File . Commit . ID , old File . Path , shallow , ) if err ! = nil { return err } if len ( new Files ) > 0 { fmt . Println ( " " ) writer : = tabwriter . New Writer ( os . Stdout , pretty . File Header ) for _ , file Info : = range new Files { pretty . Print File Info ( writer , file Info , full Timestamps ) } if err : = writer . Flush ( ) ; err ! = nil { return err } } if len ( old Files ) > 0 { fmt . Println ( " " ) writer : = tabwriter . New Writer ( os . Stdout , pretty . File Header ) for _ , file Info : = range old Files { pretty . Print File Info ( writer , file Info , full Timestamps ) } if err : = writer . Flush ( ) ; err ! = nil { return err } } return nil } ) , } diff File . Flags ( ) . Bool Var P ( & shallow , " " , " " , false , " " ) diff File . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( diff File , " " ) ) delete File : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { file , err : = cmdutil . Parse File ( args [ 0 ] ) if err ! = nil { return err } client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Delete File ( file . Commit . Repo . Name , file . Commit . ID , file . Path ) } ) , } commands = append ( commands , cmdutil . Create Alias ( delete File , " " ) ) object Docs : = & cobra . Command { Short : " " , Long : `Objects are content -addressed blobs of data that are directly stored in the backend object store . Objects are a low -level resource and should not be accessed directly by most users . ` , } cmdutil . Set Docs Usage ( object Docs ) commands = append ( commands , cmdutil . Create Alias ( object Docs , " " ) ) get Object : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Get Object ( args [ 0 ] , os . Stdout ) } ) , } commands = append ( commands , cmdutil . Create Alias ( get Object , " " ) ) tag Docs : = & cobra . Command { Short : " " , Long : `Tags are aliases for objects . Many tags can refer to the same object . Tags are a low -level resource and should not be accessed directly by most users . ` , } cmdutil . Set Docs Usage ( tag Docs ) commands = append ( commands , cmdutil . Create Alias ( tag Docs , " " ) ) get Tag : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) return client . Get Tag ( args [ 0 ] , os . Stdout ) } ) , } commands = append ( commands , cmdutil . Create Alias ( get Tag , " " ) ) var debug bool var commits cmdutil . Repeated String Arg mount : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) mount Point : = args [ 0 ] commits , err : = parse Commits ( commits ) if err ! = nil { return err } opts : = & fuse . Options { Fuse : & nodefs . Options { Debug : debug , } , Commits : commits , } return fuse . Mount ( client , mount Point , opts ) } ) , } mount . Flags ( ) . Bool Var P ( & debug , " " , " " , false , " " ) mount . Flags ( ) . Var P ( & commits , " " , " " , " \ " \ " " ) mount . Mark Flag Custom ( " " , " " ) commands = append ( commands , cmdutil . Create Alias ( mount , " " ) ) unmount : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Bounded Args ( 0 , 1 , func ( args [ ] string ) error { if len ( args ) = = 1 { return syscall . Unmount ( args [ 0 ] , 0 ) } if all { stdin : = strings . New Reader ( ` mount | grep pfs : / / | cut -f 3 -d " " ` ) var stdout bytes . Buffer if err : = cmdutil . Run IO ( cmdutil . IO { Stdin : stdin , Stdout : & stdout , Stderr : os . Stderr , } , " " ) ; err ! = nil { return err } scanner : = bufio . New Scanner ( & stdout ) var mounts [ ] string for scanner . Scan ( ) { mounts = append ( mounts , scanner . Text ( ) ) } if len ( mounts ) = = 0 { fmt . Println ( " " ) return nil } fmt . Printf ( " \n " ) for _ , mount : = range mounts { fmt . Printf ( " \n " , mount ) } r : = bufio . New Reader ( os . Stdin ) bytes , err : = r . Read Bytes ( ' \n ' ) if err ! = nil { return err } if bytes [ 0 ] = = 'y ' | | bytes [ 0 ] = = 'Y ' { for _ , mount : = range mounts { if err : = syscall . Unmount ( mount , 0 ) ; err ! = nil { return err } } } } return nil } ) , } unmount . Flags ( ) . Bool Var P ( & all , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( unmount , " " ) ) return commands } 
func Is Commit Not Found Err ( err error ) bool { if err = = nil { return false } return commit Not Found Re . Match String ( grpcutil . Scrub GRPC ( err ) . Error ( ) ) } 
func Is Commit Deleted Err ( err error ) bool { if err = = nil { return false } return commit Deleted Re . Match String ( grpcutil . Scrub GRPC ( err ) . Error ( ) ) } 
func Is Commit Finished Err ( err error ) bool { if err = = nil { return false } return commit Finished Re . Match String ( grpcutil . Scrub GRPC ( err ) . Error ( ) ) } 
func Is Repo Not Found Err ( err error ) bool { if err = = nil { return false } return repo Not Found Re . Match String ( err . Error ( ) ) } 
func Is Branch Not Found Err ( err error ) bool { if err = = nil { return false } return branch Not Found Re . Match String ( err . Error ( ) ) } 
func Is File Not Found Err ( err error ) bool { if err = = nil { return false } return file Not Found Re . Match String ( err . Error ( ) ) } 
func ( c APIClient ) Version ( ) ( string , error ) { v , err : = c . Version APIClient . Get Version ( c . Ctx ( ) , & types . Empty { } ) if err ! = nil { return " " , grpcutil . Scrub GRPC ( err ) } return version . Pretty Print Version ( v ) , nil } 
func validate Repo Name ( name string ) error { match , _ : = regexp . Match String ( " " , name ) if ! match { return fmt . Errorf ( " " , name ) } return nil } 
func new Driver ( env * serviceenv . Service Env , etcd Prefix string , tree Cache * hashtree . Cache , storage Root string , memory Request int 6 4 ) ( * driver , error ) { } d : = & driver { etcd Client : etcd Client , prefix : etcd Prefix , repos : pfsdb . Repos ( etcd Client , etcd Prefix ) , put File Records : pfsdb . Put File Records ( etcd Client , etcd Prefix ) , commits : func ( repo string ) col . Collection { return pfsdb . Commits ( etcd Client , etcd Prefix , repo ) } , branches : func ( repo string ) col . Collection { return pfsdb . Branches ( etcd Client , etcd Prefix , repo ) } , open Commits : pfsdb . Open Commits ( etcd Client , etcd Prefix ) , tree Cache : tree Cache , storage Root : storage Root , repo Info : = & pfs . Repo Info { Repo : repo , Created : now ( ) , } if _ , err : = col . New STM ( context . Background ( ) , etcd Client , func ( stm col . STM ) error { repos : = d . repos . Read Write ( stm ) return repos . Create ( repo . Name , repo Info ) } ) ; err ! = nil & & ! col . Is Err Exists ( err ) { return nil , err } return d , nil } 
func ( d * driver ) check Is Authorized ( pach Client * client . APIClient , r * pfs . Repo , s auth . Scope ) error { ctx : = pach Client . Ctx ( ) me , err : = pach Client . Who Am I ( ctx , & auth . Who Am IRequest { } ) if auth . Is Err Not Activated ( err ) { return nil } resp , err : = pach Client . Auth APIClient . Authorize ( ctx , & auth . Authorize Request { Repo : r . Name , Scope : s , } ) if err ! = nil { return fmt . Errorf ( " \ " \ " " , r . Name , grpcutil . Scrub GRPC ( err ) ) } if ! resp . Authorized { return & auth . Err Not Authorized { Subject : me . Username , Repo : r . Name , Required : s } } return nil } 
func ( d * driver ) make Commit ( pach Client * client . APIClient , ID string , parent * pfs . Commit , branch string , provenance [ ] * pfs . Commit Provenance , tree Ref * pfs . Object , record Files [ ] string , records [ ] * pfs . Put File Records , description string ) ( * pfs . Commit , error ) { } } if new Commit . ID = = " " { new Commit . ID = uuid . New Without Dashes ( ) } new Commit Info : = & pfs . Commit Info { Commit : new Commit , Started : now ( ) , Description : description , } if tree Ref ! = nil { var err error tree , err = hashtree . Get Hash Tree Object ( pach Client , d . storage Root , tree Ref ) if err ! = nil { return nil , err } } repos : = d . repos . Read Write ( stm ) commits : = d . commits ( parent . Repo . Name ) . Read Write ( stm ) branches : = d . branches ( parent . Repo . Name ) . Read Write ( stm ) if err : = repos . Get ( parent . Repo . Name , repo Info ) ; err ! = nil { return err } if err : = branches . Upsert ( branch , branch Info , func ( ) error { } for _ , p : = range branch Info . Provenance { if p . Repo . Name = = ppsconsts . Spec Repo { provenance Count - - break } } if provenance Count > 0 & & tree Ref = = nil { return fmt . Errorf ( " " ) } branch Info . Head = new Commit branch Info . Branch = client . New Branch ( new Commit . Repo . Name , branch ) return nil } ) ; err ! = nil { return err } } if err ! = nil { return fmt . Errorf ( " " , err ) } } if err : = commits . Update ( parent . ID , parent Commit Info , func ( ) error { new Commit Info . Parent Commit = parent } parent Commit Info . Child Commits = append ( parent Commit Info . Child Commits , new Commit ) return nil } ) ; err ! = nil { } } if err ! = nil { return err } tree , err = parent Tree . Copy ( ) if err ! = nil { return err } for i , record : = range records { if err : = d . apply Write ( record Files [ i ] , record , tree ) ; err ! = nil { return err } } if err : = tree . Hash ( ) ; err ! = nil { return err } tree Ref , err = hashtree . Put Hash Tree ( pach Client , tree ) if err ! = nil { return err } } new Commit Info . Size Bytes = uint 6 4 ( tree . FSSize ( ) ) new Commit Info . Finished = now ( ) } } else { if err : = d . open Commits . Read Write ( stm ) . Put ( new Commit . ID , new Commit ) ; err ! = nil { return err } } } for _ , prov : = range provenance { new Commit Prov [ prov . Commit . ID ] = prov prov Commit Info : = & pfs . Commit Info { } if err : = d . commits ( prov . Commit . Repo . Name ) . Read Write ( stm ) . Get ( prov . Commit . ID , prov Commit Info ) ; err ! = nil { return err } for _ , c : = range prov Commit Info . Provenance { new Commit Prov [ c . Commit . ID ] = c } } prov Commit Info : = & pfs . Commit Info { } if err : = d . commits ( prov . Commit . Repo . Name ) . Read Write ( stm ) . Update ( prov . Commit . ID , prov Commit Info , func ( ) error { append Subvenance ( prov Commit Info , new Commit Info ) return nil } ) ; err ! = nil { return err } } } } return nil } ) ; err ! = nil { return nil , err } return new Commit , nil } 
func ( d * driver ) write Finished Commit ( ctx context . Context , commit * pfs . Commit , commit Info * pfs . Commit Info ) error { _ , err : = col . New STM ( ctx , d . etcd Client , func ( stm col . STM ) error { commits : = d . commits ( commit . Repo . Name ) . Read Write ( stm ) if err : = commits . Put ( commit . ID , commit Info ) ; err ! = nil { return err } if err : = d . open Commits . Read Write ( stm ) . Delete ( commit . ID ) ; err ! = nil { return fmt . Errorf ( " " , commit . ID , err ) } repo Info : = new ( pfs . Repo Info ) if err : = repos . Get ( commit . Repo . Name , repo Info ) ; err ! = nil { return err } for _ , branch : = range repo Info . Branches { if branch . Name = = " " { branch Info : = & pfs . Branch Info { } if err : = d . branches ( commit . Repo . Name ) . Read Write ( stm ) . Get ( branch . Name , branch Info ) ; err ! = nil { return err } if err : = repos . Put ( commit . Repo . Name , repo Info ) ; err ! = nil { return err } } } } return nil } ) return err } 
func ( d * driver ) propagate Commit ( stm col . STM , branch * pfs . Branch ) error { if branch = = nil { return fmt . Errorf ( " " ) } branch Info : = & pfs . Branch Info { } if err : = d . branches ( branch . Repo . Name ) . Read Write ( stm ) . Get ( branch . Name , branch Info ) ; err ! = nil { return err } subv Branch Infos = append ( subv Branch Infos , branch Info ) for _ , subv Branch : = range branch Info . Subvenance { subv Branch Info : = & pfs . Branch Info { } if err : = d . branches ( subv Branch . Repo . Name ) . Read Write ( stm ) . Get ( subv Branch . Name , subv Branch Info ) ; err ! = nil { return err } subv Branch Infos = append ( subv Branch Infos , subv Branch Info ) } var head * pfs . Commit Info if branch Info . Head ! = nil { head = & pfs . Commit Info { } if err : = d . commits ( branch . Repo . Name ) . Read Write ( stm ) . Get ( branch Info . Head . ID , head ) ; err ! = nil { return err } } repo : = branch . Repo commits : = d . commits ( repo . Name ) . Read Write ( stm ) branches : = d . branches ( repo . Name ) . Read Write ( stm ) commit Prov Map : = make ( map [ string ] * pfs . Commit Provenance ) for _ , prov Branch : = range branch Info . Provenance { prov Branch Info : = & pfs . Branch Info { } if err : = d . branches ( prov Branch . Repo . Name ) . Read Write ( stm ) . Get ( prov Branch . Name , prov Branch Info ) ; err ! = nil & & ! col . Is Err Not Found ( err ) { return fmt . Errorf ( " " , prov Branch . Repo . Name , prov Branch . Name , err ) } if prov Branch Info . Head = = nil { continue } if head ! = nil { for _ , commit Prov : = range head . Provenance { commit Prov Map [ key ( commit Prov . Commit . ID , commit Prov . Branch . Name ) ] = commit Prov } } if len ( commit Prov Map ) = = 0 { } if err : = commits . Get ( branch Info . Head . ID , branch Head Info ) ; err ! = nil { return pfsserver . Err Commit Not Found { branch Info . Head } } head Is Subset : = false for _ , v : = range commit Prov Map { matched : = false for _ , c : = range branch Head Info . Provenance { if c . Commit . ID = = v . Commit . ID { matched = true } } head Is Subset = matched if ! head Is Subset { break } } if len ( branch Head Info . Provenance ) > = len ( commit Prov Map ) & & head Is Subset { } } for _ , p : = range commit Prov Map { if p . Branch . Repo . Name ! = ppsconsts . Spec Repo { all Spec = false break } } if all Spec { } new Commit Info : = & pfs . Commit Info { Commit : new Commit , Started : now ( ) , } if branch Info . Head ! = nil { parent Commit Info : = & pfs . Commit Info { } if err : = commits . Update ( new Commit Info . Parent Commit . ID , parent Commit Info , func ( ) error { parent Commit Info . Child Commits = append ( parent Commit Info . Child Commits , new Commit ) return nil } ) ; err ! = nil { return err } } branch Info . Head = new Commit branch Info . Name = branch . Name branch Info . Branch = branch new Commit Info . Branch = branch if err : = branches . Put ( branch . Name , branch Info ) ; err ! = nil { return err } if err : = d . commits ( prov . Commit . Repo . Name ) . Read Write ( stm ) . Update ( prov . Commit . ID , prov Commit Info , func ( ) error { append Subvenance ( prov Commit Info , new Commit Info ) return nil } ) ; err ! = nil { return err } } } if err : = d . open Commits . Read Write ( stm ) . Put ( new Commit . ID , new Commit ) ; err ! = nil { return err } } return nil } 
func ( d * driver ) inspect Commit ( pach Client * client . APIClient , commit * pfs . Commit , block State pfs . Commit State ) ( * pfs . Commit Info , error ) { ctx : = pach Client . Ctx ( ) if commit = = nil { return nil , fmt . Errorf ( " " ) } if err : = d . check Is Authorized ( pach Client , commit . Repo , auth . Scope _READER ) ; err ! = nil { return nil , err } if _ , err : = col . New STM ( ctx , d . etcd Client , func ( stm col . STM ) error { var err error commit Info , err = d . resolve Commit ( stm , commit ) return err } ) ; err ! = nil { return nil , err } commits : = d . commits ( commit . Repo . Name ) . Read Only ( ctx ) if block State = = pfs . Commit State _READY { } } if block State = = pfs . Commit State _FINISHED { if err ! = nil { return err } defer commit Info Watcher . Close ( ) for { var commit ID string _commit Info : = new ( pfs . Commit Info ) event : = < - commit Info Watcher . Watch ( ) switch event . Type { case watch . Event Error : return event . Err case watch . Event Put : if err : = event . Unmarshal ( & commit ID , _commit Info ) ; err ! = nil { return fmt . Errorf ( " " , err ) } case watch . Event Delete : return pfsserver . Err Commit Deleted { commit } } if _commit Info . Finished ! = nil { commit Info = _commit Info break } } return nil } ( ) ; err ! = nil { return nil , err } } return commit Info , nil } 
func ( d * driver ) resolve Commit ( stm col . STM , user Commit * pfs . Commit ) ( * pfs . Commit Info , error ) { if user Commit = = nil { return nil , fmt . Errorf ( " " ) } if user Commit . ID = = " " { return nil , fmt . Errorf ( " " ) } commit : = proto . Clone ( user Commit ) . ( * pfs . Commit ) commit . ID , ancestry Length = ancestry . Parse ( commit . ID ) branch Info : = & pfs . Branch Info { } } if branch Info . Head = = nil { return nil , pfsserver . Err No Head { branch Info . Branch } } commit Branch = branch Info . Branch commit . ID = branch Info . Head . ID } commit Info : = & pfs . Commit Info { } for i : = 0 ; i < = ancestry Length ; i + + { if commit = = nil { return nil , pfsserver . Err Commit Not Found { user Commit } } child Commit : = commit if err : = commits . Get ( commit . ID , commit Info ) ; err ! = nil { if col . Is Err Not Found ( err ) { if i = = 0 { return nil , pfsserver . Err Commit Not Found { child Commit } } return nil , pfsserver . Err Parent Commit Not Found { child Commit } } return nil , err } commit = commit Info . Parent Commit } if commit Info . Branch = = nil { commit Info . Branch = commit Branch } user Commit . ID = commit Info . Commit . ID return commit Info , nil } 
func ( d * driver ) create Branch ( pach Client * client . APIClient , branch * pfs . Branch , commit * pfs . Commit , provenance [ ] * pfs . Branch ) error { ctx : = pach Client . Ctx ( ) if err : = d . check Is Authorized ( pach Client , branch . Repo , auth . Scope _WRITER ) ; err ! = nil { return err } if ! same Target & & provenance ! = nil { return fmt . Errorf ( " \ " \ " \ " \ " " , branch . Name , commit . Repo . Name , commit . ID ) } } _ , err : = col . New STM ( ctx , d . etcd Client , func ( stm col . STM ) error { if commit ! = nil { _ , err = d . resolve Commit ( stm , commit ) if err ! = nil { } commit = nil } } branch Info : = & pfs . Branch Info { } if err : = branches . Upsert ( branch . Name , branch Info , func ( ) error { branch Info . Name = branch . Name branch Info . Branch = branch branch Info . Head = commit branch Info . Direct Provenance = nil for _ , prov Branch : = range provenance { add ( & branch Info . Direct Provenance , prov Branch ) } return nil } ) ; err ! = nil { return err } repos : = d . repos . Read Write ( stm ) repo Info : = & pfs . Repo Info { } if err : = repos . Update ( branch . Repo . Name , repo Info , func ( ) error { add ( & repo Info . Branches , branch ) return nil } ) ; err ! = nil { return err } for _ , subv Branch : = range branch Info . Subvenance { subv Branch Info : = & pfs . Branch Info { } if err : = d . branches ( subv Branch . Repo . Name ) . Read Write ( stm ) . Get ( subv Branch . Name , subv Branch Info ) ; err ! = nil { return err } to Update = append ( to Update , subv Branch Info ) } for _ , branch Info : = range to Update { old Provenance : = branch Info . Provenance branch Info . Provenance = nil } prov Branch Info : = & pfs . Branch Info { } if err : = d . branches ( prov Branch . Repo . Name ) . Read Write ( stm ) . Get ( prov Branch . Name , prov Branch Info ) ; err ! = nil { return err } for _ , prov Branch : = range prov Branch Info . Provenance { if err : = d . add Branch Provenance ( branch Info , prov Branch , stm ) ; err ! = nil { return err } } } if err : = d . branches ( branch Info . Branch . Repo . Name ) . Read Write ( stm ) . Put ( branch Info . Branch . Name , branch Info ) ; err ! = nil { return err } if err : = d . branches ( old Prov Branch . Repo . Name ) . Read Write ( stm ) . Update ( old Prov Branch . Name , old Prov Branch Info , func ( ) error { del ( & old Prov Branch Info . Subvenance , branch Info . Branch ) return nil } ) ; err ! = nil { return err } } } } } ) return err } 
func ( d * driver ) scratch Commit Prefix ( commit * pfs . Commit ) string { } 
func ( d * driver ) scratch File Prefix ( file * pfs . File ) ( string , error ) { return path . Join ( d . scratch Commit Prefix ( file . Commit ) , file . Path ) , nil } 
func header Dir To Put File Records ( tree hashtree . Hash Tree , path string , node * hashtree . Node Proto ) ( * pfs . Put File Records , error ) { if node . Dir Node = = nil | | node . Dir Node . Shared = = nil { return nil , fmt . Errorf ( " " ) } s : = node . Dir Node . Shared pfr : = & pfs . Put File Records { Split : true , } if s . Header ! = nil { pfr . Header = & pfs . Put File Record { Size Bytes : s . Header Size , Object Hash : s . Header . Hash , } } if s . Footer ! = nil { pfr . Footer = & pfs . Put File Record { Size Bytes : s . Footer Size , Object Hash : s . Footer . Hash , } } if err : = tree . List ( path , func ( child * hashtree . Node Proto ) error { if child . File Node = = nil { return fmt . Errorf ( " " + " " ) } for i , o : = range child . File Node . Objects { if i = = 0 { size = child . Subtree Size } pfr . Records = append ( pfr . Records , & pfs . Put File Record { Size Bytes : size , Object Hash : o . Hash , } ) } return nil } ) ; err ! = nil { return nil , err } return pfr , nil } 
func ( d * driver ) get Tree For File ( pach Client * client . APIClient , file * pfs . File ) ( hashtree . Hash Tree , error ) { if file . Commit = = nil { t , err : = hashtree . New DBHash Tree ( d . storage Root ) if err ! = nil { return nil , err } return t , nil } commit Info , err : = d . inspect Commit ( pach Client , file . Commit , pfs . Commit State _STARTED ) if err ! = nil { return nil , err } if commit Info . Finished ! = nil { tree , err : = d . get Tree For Commit ( pach Client , file . Commit ) if err ! = nil { return nil , err } return tree , nil } parent Tree , err : = d . get Tree For Commit ( pach Client , commit Info . Parent Commit ) if err ! = nil { return nil , err } return d . get Tree For Open Commit ( pach Client , file , parent Tree ) } 
func provenant On Input ( provenance [ ] * pfs . Commit Provenance ) bool { provenance Count : = len ( provenance ) for _ , p : = range provenance { break } } return provenance Count > 0 } 
func node To File Info ( ci * pfs . Commit Info , path string , node * hashtree . Node Proto , full bool ) * pfs . File Info { file Info : = & pfs . File Info { File : & pfs . File { Commit : ci . Commit , Path : path , } , Size Bytes : uint 6 4 ( node . Subtree Size ) , Hash : node . Hash , Committed : ci . Finished , } if node . File Node ! = nil { file Info . File Type = pfs . File Type _FILE if full { file Info . Objects = node . File Node . Objects file Info . Block Refs = node . File Node . Block Refs } } else if node . Dir Node ! = nil { file Info . File Type = pfs . File Type _DIR if full { file Info . Children = node . Dir Node . Children } } return file Info } 
func node To File Info Header Footer ( ci * pfs . Commit Info , file Path string , node * hashtree . Node Proto , tree hashtree . Hash Tree , full bool ) ( * pfs . File Info , error ) { if node . File Node = = nil | | ! node . File Node . Has Header Footer { return node To File Info ( ci , file Path , node , full ) , nil } node = proto . Clone ( node ) . ( * hashtree . Node Proto ) } parent Node , err : = tree . Get ( parent Path ) if err ! = nil { return nil , fmt . Errorf ( " " + " " , file Path , parent Path , err ) } if parent Node . Dir Node = = nil { return nil , fmt . Errorf ( " " + " " , file Path ) } if parent Node . Dir Node . Shared = = nil { return nil , fmt . Errorf ( " " + " " , file Path ) } s : = parent Node . Dir Node . Shared var new Objects [ ] * pfs . Object if s . Header ! = nil { new Objects = make ( [ ] * pfs . Object , new L , new L + 1 ) new Objects [ 0 ] = s . Header copy ( new Objects [ 1 : ] , node . File Node . Objects ) } else { new Objects = node . File Node . Objects } if s . Footer ! = nil { new Objects = append ( new Objects , s . Footer ) } node . File Node . Objects = new Objects node . Subtree Size + = s . Header Size + s . Footer Size node . Hash = hashtree . Hash File Node ( node . File Node ) return node To File Info ( ci , file Path , node , full ) , nil } 
func ( d * driver ) file History ( pach Client * client . APIClient , file * pfs . File , history int 6 4 , f func ( * pfs . File Info ) error ) error { var fi * pfs . File Info for { _fi , err : = d . inspect File ( pach Client , file ) if err ! = nil { if _ , ok : = err . ( pfsserver . Err File Not Found ) ; ok { return f ( fi ) } return err } if fi ! = nil & & bytes . Compare ( fi . Hash , _fi . Hash ) ! = 0 { if err : = f ( fi ) ; err ! = nil { return err } if history > 0 { history - - if history = = 0 { return nil } } } fi = _fi ci , err : = d . inspect Commit ( pach Client , file . Commit , pfs . Commit State _STARTED ) if err ! = nil { return err } if ci . Parent Commit = = nil { return f ( fi ) } file . Commit = ci . Parent Commit } } 
func ( d * driver ) upsert Put File Records ( pach Client * client . APIClient , file * pfs . File , new Records * pfs . Put File Records ) error { prefix , err : = d . scratch File Prefix ( file ) if err ! = nil { return err } ctx : = pach Client . Ctx ( ) _ , err = col . New STM ( ctx , d . etcd Client , func ( stm col . STM ) error { commits Col : = d . open Commits . Read Only ( ctx ) var commit pfs . Commit err : = commits Col . Get ( file . Commit . ID , & commit ) if err ! = nil { return err } } records Col : = d . put File Records . Read Write ( stm ) var existing Records pfs . Put File Records return records Col . Upsert ( prefix , & existing Records , func ( ) error { if new Records . Tombstone { existing Records . Tombstone = true existing Records . Records = nil } existing Records . Split = new Records . Split existing Records . Records = append ( existing Records . Records , new Records . Records . . . ) existing Records . Header = new Records . Header existing Records . Footer = new Records . Footer return nil } ) } ) if err ! = nil { return err } return err } 
func ( r * PGDump Reader ) Read Row ( ) ( [ ] byte , error ) { if len ( r . Header ) = = 0 { err : = r . read Header ( ) if err ! = nil { return nil , err } } end Line : = " \ \ \n " row , err : = r . rd . Read Bytes ( ' \n ' ) if err ! = nil & & err ! = io . EOF { return nil , fmt . Errorf ( " " , err ) } row = row [ : len ( row ) - 1 ] } if string ( row ) = = end Line { r . Footer = append ( r . Footer , row . . . ) err = r . read Footer ( ) row = nil } if err = = io . EOF & & len ( r . Footer ) = = 0 { return nil , fmt . Errorf ( " " ) } return row , err } 
func New Reporter ( cluster ID string , kube Client * kube . Clientset ) * Reporter { reporter : = & Reporter { segment Client : new Persistent Client ( ) , cluster ID : cluster ID , kube Client : kube Client , } go reporter . report Cluster Metrics ( ) return reporter } 
func Report User Action ( ctx context . Context , r * Reporter , action string ) func ( time . Time , error ) { if r = = nil { } return func ( start time . Time , err error ) { if err = = nil { r . report User Action ( ctx , fmt . Sprintf ( " " , action ) , time . Since ( start ) . Seconds ( ) ) } else { r . report User Action ( ctx , fmt . Sprintf ( " " , action ) , err . Error ( ) ) } } } 
func report And Flush User Action ( action string , value interface { } ) func ( ) { metrics Done : = make ( chan struct { } ) go func ( ) { client : = new Segment Client ( ) defer client . Close ( ) cfg , err : = config . Read ( ) if err ! = nil | | cfg = = nil | | cfg . User ID = = " " { log . Errorf ( " " , err ) } report User Metrics To Segment ( client , cfg . User ID , " " , action , value , " " ) close ( metrics Done ) } ( ) return func ( ) { select { case < - metrics Done : return case < - time . After ( time . Second * 5 ) : return } } } 
func Finish Report And Flush User Action ( action string , err error , start time . Time ) func ( ) { var wait func ( ) if err ! = nil { wait = report And Flush User Action ( fmt . Sprintf ( " " , action ) , err ) } else { wait = report And Flush User Action ( fmt . Sprintf ( " " , action ) , time . Since ( start ) . Seconds ( ) ) } return wait } 
func ( r * Reader ) Read ( data [ ] byte ) ( int , error ) { var total Read int for len ( data ) > 0 { n , err : = r . r . Read ( data ) data = data [ n : ] total Read + = n if err ! = nil { } } } r . curr = r . data Refs [ 0 ] r . data Refs = r . data Refs [ 1 : ] r . r = bytes . New Reader ( r . buf . Bytes ( ) [ r . curr . Offset Bytes : r . curr . Offset Bytes + r . curr . Size Bytes ] ) } } return total Read , nil } 
func parse ISO 8 6 0 1 ( s string ) ( time . Time , error ) { t , err : = time . Parse ( time . RFC 3 3 3 9 , s ) if err = = nil { return t , nil } t , err = time . Parse ( " " , s ) if err = = nil { return t , nil } return time . Time { } , fmt . Errorf ( " \ " \ " " , s , [ ] string { time . RFC 3 3 3 9 , " " } ) } 
func Activate Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { var expires string activate : = & cobra . Command { Use : " " , Short : " " + " " , Long : " " + " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err . Error ( ) ) } defer c . Close ( ) req : = & enterprise . Activate Request { } req . Activation Code = args [ 0 ] if expires ! = " " { t , err : = parse ISO 8 6 0 1 ( expires ) if err ! = nil { return fmt . Errorf ( " \ " \ " " , expires , err . Error ( ) ) } req . Expires , err = types . Timestamp Proto ( t ) if err ! = nil { return fmt . Errorf ( " \ " \ " " , t . String ( ) , err . Error ( ) ) } } resp , err : = c . Enterprise . Activate ( c . Ctx ( ) , req ) if err ! = nil { return err } ts , err : = types . Timestamp From Proto ( resp . Info . Expires ) if err ! = nil { return fmt . Errorf ( " " + " " , err . Error ( ) ) } fmt . Printf ( " " + " \n " , ts . String ( ) ) return nil } ) , } activate . Persistent Flags ( ) . String Var ( & expires , " " , " " , " " + " " + " " + " " + " " ) return cmdutil . Create Alias ( activate , " " ) } 
func Get State Cmd ( no Metrics , no Port Forwarding * bool ) * cobra . Command { get State : = & cobra . Command { Short : " " + " " , Long : " " + " " , Run : cmdutil . Run ( func ( args [ ] string ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err . Error ( ) ) } defer c . Close ( ) resp , err : = c . Enterprise . Get State ( c . Ctx ( ) , & enterprise . Get State Request { } ) if err ! = nil { return err } if resp . State = = enterprise . State _NONE { fmt . Println ( " " ) return nil } ts , err : = types . Timestamp From Proto ( resp . Info . Expires ) if err ! = nil { return fmt . Errorf ( " " + " " , err . Error ( ) ) } fmt . Printf ( " \n \n " , resp . State . String ( ) , ts . String ( ) ) return nil } ) , } return cmdutil . Create Alias ( get State , " " ) } 
func Cmds ( no Metrics , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command enterprise : = & cobra . Command { Short : " " , Long : " " , } commands = append ( commands , cmdutil . Create Alias ( enterprise , " " ) ) commands = append ( commands , Activate Cmd ( no Metrics , no Port Forwarding ) ) commands = append ( commands , Get State Cmd ( no Metrics , no Port Forwarding ) ) return commands } 
func New Configuration ( config interface { } ) * Configuration { configuration : = & Configuration { } switch config . ( type ) { case * Global Configuration : configuration . Global Configuration = config . ( * Global Configuration ) return configuration case * Pachd Full Configuration : configuration . Global Configuration = & config . ( * Pachd Full Configuration ) . Global Configuration configuration . Pachd Specific Configuration = & config . ( * Pachd Full Configuration ) . Pachd Specific Configuration return configuration case * Worker Full Configuration : configuration . Global Configuration = & config . ( * Worker Full Configuration ) . Global Configuration configuration . Worker Specific Configuration = & config . ( * Worker Full Configuration ) . Worker Specific Configuration return configuration default : return nil } } 
func Repos ( etcd Client * etcd . Client , etcd Prefix string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , repos Prefix ) , nil , & pfs . Repo Info { } , nil , nil , ) } 
func Put File Records ( etcd Client * etcd . Client , etcd Prefix string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , put File Records Prefix ) , nil , & pfs . Put File Records { } , nil , nil , ) } 
func Commits ( etcd Client * etcd . Client , etcd Prefix string , repo string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , commits Prefix , repo ) , [ ] * col . Index { Provenance Index } , & pfs . Commit Info { } , nil , nil , ) } 
func Branches ( etcd Client * etcd . Client , etcd Prefix string , repo string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , branches Prefix , repo ) , nil , & pfs . Branch Info { } , func ( key string ) error { if uuid . Is UUIDWithout Dashes ( key ) { return fmt . Errorf ( " " ) } return nil } , nil , ) } 
func Open Commits ( etcd Client * etcd . Client , etcd Prefix string ) col . Collection { return col . New Collection ( etcd Client , path . Join ( etcd Prefix , open Commits Prefix ) , nil , & pfs . Commit { } , nil , nil , ) } 
func New DAG ( nodes map [ string ] [ ] string ) * DAG { result : = & DAG { parents : make ( map [ string ] [ ] string ) , children : make ( map [ string ] [ ] string ) , leaves : make ( map [ string ] bool ) , } for id , parents : = range nodes { result . New Node ( id , parents ) } return result } 
func ( d * DAG ) New Node ( id string , parents [ ] string ) { d . parents [ id ] = parents for _ , parent ID : = range parents { d . children [ parent ID ] = append ( d . children [ parent ID ] , id ) d . leaves [ parent ID ] = false } if _ , ok : = d . leaves [ id ] ; ! ok { d . leaves [ id ] = true } } 
func ( d * DAG ) Sorted ( ) [ ] string { seen : = make ( map [ string ] bool ) var result [ ] string for id : = range d . parents { result = append ( result , dfs ( id , d . parents , seen ) . . . ) } return result } 
func ( d * DAG ) Leaves ( ) [ ] string { var result [ ] string for id , is Leaf : = range d . leaves { } } return result } 
func ( d * DAG ) Ancestors ( id string , from [ ] string ) [ ] string { seen : = make ( map [ string ] bool ) for _ , from ID : = range from { seen [ from ID ] = true } return dfs ( id , d . parents , seen ) } 
func ( d * DAG ) Descendants ( id string , to [ ] string ) [ ] string { seen : = make ( map [ string ] bool ) for _ , to ID : = range to { seen [ to ID ] = true } return bfs ( id , d . children , seen ) } 
func ( d * DAG ) Ghosts ( ) [ ] string { var result [ ] string for id : = range d . children { if _ , ok : = d . parents [ id ] ; ! ok { result = append ( result , id ) } } return result } 
func New Port Forwarder ( namespace string ) ( * Port Forwarder , error ) { if namespace = = " " { namespace = " " } rules : = clientcmd . New Default Client Config Loading Rules ( ) overrides : = & clientcmd . Config Overrides { } kube Config : = clientcmd . New Non Interactive Deferred Loading Client Config ( rules , overrides ) config , err : = kube Config . Client Config ( ) if err ! = nil { return nil , err } client , err : = kubernetes . New For Config ( config ) if err ! = nil { return nil , err } core : = client . Core V 1 ( ) return & Port Forwarder { core : core , client : core . RESTClient ( ) , config : config , namespace : namespace , logger : log . Standard Logger ( ) . Writer ( ) , stop Chans Lock : & sync . Mutex { } , stop Chans : [ ] chan struct { } { } , shutdown : false , } , nil } 
func ( f * Port Forwarder ) Run ( app Name string , local Port , remote Port uint 1 6 ) error { pod Name Selector : = map [ string ] string { " " : " " , " " : app Name , } pod List , err : = f . core . Pods ( f . namespace ) . List ( metav 1 . List Options { Label Selector : metav 1 . Format Label Selector ( metav 1 . Set As Label Selector ( pod Name Selector ) ) , Type Meta : metav 1 . Type Meta { Kind : " " , APIVersion : " " , } , } ) if err ! = nil { return err } if len ( pod List . Items ) = = 0 { return fmt . Errorf ( " " , app Name ) } url : = f . client . Post ( ) . Resource ( " " ) . Namespace ( f . namespace ) . Name ( pod Name ) . Sub Resource ( " " ) . URL ( ) transport , upgrader , err : = spdy . Round Tripper For ( f . config ) if err ! = nil { return err } dialer : = spdy . New Dialer ( upgrader , & http . Client { Transport : transport } , " " , url ) ports : = [ ] string { fmt . Sprintf ( " " , local Port , remote Port ) } ready Chan : = make ( chan struct { } , 1 ) stop Chan : = make ( chan struct { } , 1 ) if f . shutdown { f . stop Chans Lock . Unlock ( ) return fmt . Errorf ( " " ) } f . stop Chans = append ( f . stop Chans , stop Chan ) f . stop Chans Lock . Unlock ( ) fw , err : = portforward . New ( dialer , ports , stop Chan , ready Chan , ioutil . Discard , f . logger ) if err ! = nil { return err } err Chan : = make ( chan error , 1 ) go func ( ) { err Chan < - fw . Forward Ports ( ) } ( ) select { case err = < - err Chan : return fmt . Errorf ( " " , err ) case < - fw . Ready : return nil } } 
func ( f * Port Forwarder ) Run For Daemon ( local Port , remote Port uint 1 6 ) error { if local Port = = 0 { local Port = pachd Local Port } if remote Port = = 0 { remote Port = pachd Remote Port } return f . Run ( " " , local Port , remote Port ) } 
func ( f * Port Forwarder ) Run For SAMLACS ( local Port uint 1 6 ) error { if local Port = = 0 { local Port = saml Acs Local Port } return f . Run ( " " , local Port , 6 5 4 ) } 
func ( f * Port Forwarder ) Run For Dash UI ( local Port uint 1 6 ) error { if local Port = = 0 { local Port = dash UILocal Port } return f . Run ( " " , local Port , 8 0 8 0 ) } 
func ( f * Port Forwarder ) Run For Dash Web Socket ( local Port uint 1 6 ) error { if local Port = = 0 { local Port = dash Web Socket Local Port } return f . Run ( " " , local Port , 8 0 8 1 ) } 
func ( f * Port Forwarder ) Run For PFS ( local Port uint 1 6 ) error { if local Port = = 0 { local Port = pfs Local Port } return f . Run ( " " , local Port , 3 0 6 5 2 ) } 
func ( f * Port Forwarder ) Run For S 3Gateway ( local Port uint 1 6 ) error { if local Port = = 0 { local Port = s 3gateway Local Port } return f . Run ( " " , local Port , 6 0 0 ) } 
func ( f * Port Forwarder ) Lock ( ) error { pidfile . Set Pidfile Path ( path . Join ( os . Getenv ( " " ) , " " ) ) return pidfile . Write ( ) } 
func ( f * Port Forwarder ) Close ( ) { defer f . logger . Close ( ) f . stop Chans Lock . Lock ( ) defer f . stop Chans Lock . Unlock ( ) if f . shutdown { panic ( " " ) } f . shutdown = true for _ , stop Chan : = range f . stop Chans { close ( stop Chan ) } } 
func ( e * Event ) Unmarshal ( key * string , val proto . Message ) error { if err : = Check Type ( e . Template , val ) ; err ! = nil { return err } * key = string ( e . Key ) return proto . Unmarshal ( e . Value , val ) } 
func ( e * Event ) Unmarshal Prev ( key * string , val proto . Message ) error { if err : = Check Type ( e . Template , val ) ; err ! = nil { return err } * key = string ( e . Prev Key ) return proto . Unmarshal ( e . Prev Value , val ) } 
func New Watcher ( ctx context . Context , client * etcd . Client , trim Prefix , prefix string , template proto . Message , opts . . . Op Option ) ( Watcher , error ) { event Ch : = make ( chan * Event ) done : = make ( chan struct { } ) if err ! = nil { return nil , err } next Revision : = resp . Header . Revision + 1 etcd Watcher : = etcd . New Watcher ( client ) for _ , opt : = range opts { options = append ( options , etcd . Op Option ( opt ) ) } rch : = etcd Watcher . Watch ( ctx , prefix , options . . . ) go func ( ) ( ret Err error ) { defer func ( ) { if ret Err ! = nil { select { case event Ch < - & Event { Err : ret Err , Type : Event Error , } : case < - done : } } close ( event Ch ) etcd Watcher . Close ( ) } ( ) for _ , etcd Kv : = range resp . Kvs { event Ch < - & Event { Key : bytes . Trim Prefix ( etcd Kv . Key , [ ] byte ( trim Prefix ) ) , Value : etcd Kv . Value , Type : Event Put , Rev : etcd Kv . Mod Revision , Template : template , } } for { var resp etcd . Watch Response var ok bool select { case resp , ok = < - rch : case < - done : return nil } if ! ok { if err : = etcd Watcher . Close ( ) ; err ! = nil { return err } etcd Watcher = etcd . New Watcher ( client ) rch = etcd Watcher . Watch ( ctx , prefix , etcd . With Prefix ( ) , etcd . With Rev ( next Revision ) ) continue } if err : = resp . Err ( ) ; err ! = nil { return err } for _ , etcd Ev : = range resp . Events { ev : = & Event { Key : bytes . Trim Prefix ( etcd Ev . Kv . Key , [ ] byte ( trim Prefix ) ) , Value : etcd Ev . Kv . Value , Rev : etcd Ev . Kv . Mod Revision , Template : template , } if etcd Ev . Prev Kv ! = nil { ev . Prev Key = bytes . Trim Prefix ( etcd Ev . Prev Kv . Key , [ ] byte ( trim Prefix ) ) ev . Prev Value = etcd Ev . Prev Kv . Value } if etcd Ev . Type = = etcd . Event Type Put { ev . Type = Event Put } else { ev . Type = Event Delete } select { case event Ch < - ev : case < - done : return nil } } next Revision = resp . Header . Revision + 1 } } ( ) return & watcher { event Ch : event Ch , done : done , } , nil } 
func Make Watcher ( event Ch chan * Event , done chan struct { } ) Watcher { return & watcher { event Ch : event Ch , done : done , } } 
func Check Type ( template proto . Message , val interface { } ) error { if template ! = nil { val Type , template Type : = reflect . Type Of ( val ) , reflect . Type Of ( template ) if val Type ! = template Type { return fmt . Errorf ( " " , val Type , template Type ) } } return nil } 
func New Pool ( kube Client * kube . Clientset , namespace string , service Name string , port int , queue Size int 6 4 , opts . . . grpc . Dial Option ) ( * Pool , error ) { endpoints Interface : = kube Client . Core V 1 ( ) . Endpoints ( namespace ) watch , err : = endpoints Interface . Watch ( metav 1 . List Options { Label Selector : metav 1 . Format Label Selector ( metav 1 . Set As Label Selector ( map [ string ] string { " " : service Name } , ) ) , Watch : true , } ) if err ! = nil { return nil , err } pool : = & Pool { port : port , endpoints Watch : watch , opts : opts , done : make ( chan struct { } ) , queue Size : queue Size , } pool . conns Cond = sync . New Cond ( & pool . conns Lock ) go pool . watch Endpoints ( ) return pool , nil } 
func ( p * Pool ) Do ( ctx context . Context , f func ( cc * grpc . Client Conn ) error ) error { var conn * conn Count if err : = func ( ) error { p . conns Lock . Lock ( ) defer p . conns Lock . Unlock ( ) for { for addr , map Conn : = range p . conns { if map Conn . cc = = nil { cc , err : = grpc . Dial Context ( ctx , addr , p . opts . . . ) if err ! = nil { return fmt . Errorf ( " " , addr , err ) } map Conn . cc = cc conn = map Conn } else { map Conn Count : = atomic . Load Int 6 4 ( & map Conn . count ) if map Conn Count < p . queue Size & & ( conn = = nil | | map Conn Count < atomic . Load Int 6 4 ( & conn . count ) ) { conn = map Conn } } } if conn = = nil { p . conns Cond . Wait ( ) } else { atomic . Add Int 6 4 ( & conn . count , 1 ) break } } return nil } ( ) ; err ! = nil { return err } defer p . conns Cond . Broadcast ( ) defer atomic . Add Int 6 4 ( & conn . count , - 1 ) return f ( conn . cc ) } 
func ( p * Pool ) Close ( ) error { close ( p . done ) var ret Err error for _ , conn : = range p . conns { if conn . cc ! = nil { if err : = conn . cc . Close ( ) ; err ! = nil { ret Err = err } } } return ret Err } 
func Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command raw : = false raw Flags : = pflag . New Flag Set ( " " , pflag . Continue On Error ) raw Flags . Bool Var ( & raw , " " , false , " " ) full Timestamps : = false full Timestamps Flags : = pflag . New Flag Set ( " " , pflag . Continue On Error ) full Timestamps Flags . Bool Var ( & full Timestamps , " " , false , " " ) marshaller : = & jsonpb . Marshaler { Indent : " " , Orig Name : true , } job Docs : = & cobra . Command { Short : " " , Long : `Jobs are the basic units of computation in Pachyderm . Jobs run a containerized workload over a set of finished input commits . Jobs are created by pipelines and will write output to a commit in the pipeline 's output repo . A job can have multiple datums , each processed independently and the results will be merged together at the end . If the job fails , the output commit will not be populated with data . ` , } cmdutil . Set Docs Usage ( job Docs ) commands = append ( commands , cmdutil . Create Alias ( job Docs , " " ) ) var block bool inspect Job : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) job Info , err : = client . Inspect Job ( args [ 0 ] , block ) if err ! = nil { cmdutil . Error And Exit ( " " , err . Error ( ) ) } if job Info = = nil { cmdutil . Error And Exit ( " " , args [ 0 ] ) } if raw { return marshaller . Marshal ( os . Stdout , job Info ) } ji : = & pretty . Printable Job Info { Job Info : job Info , Full Timestamps : full Timestamps , } return pretty . Print Detailed Job Info ( ji ) } ) , } inspect Job . Flags ( ) . Bool Var P ( & block , " " , " " , false , " " ) inspect Job . Flags ( ) . Add Flag Set ( raw Flags ) inspect Job . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect Job , " " ) ) var pipeline Name string var output Commit Str string var input Commit Strs [ ] string list Job : = & cobra . Command { Short : " " , Long : " " , Example : ` # Return all jobs $ { {alias } } # Return all jobs in pipeline foo $ { {alias } } -p foo # Return all jobs whose input commits include foo @XXX and bar @YYY $ { {alias } } -i foo @XXX -i bar @YYY # Return all jobs in pipeline foo and whose input commits include bar @YYY $ { {alias } } -p foo -i bar @YYY ` , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { commits , err : = cmdutil . Parse Commits ( input Commit Strs ) if err ! = nil { return err } var output Commit * pfs . Commit if output Commit Str ! = " " { output Commit , err = cmdutil . Parse Commit ( output Commit Str ) if err ! = nil { return err } } client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if raw { return client . List Job F ( pipeline Name , commits , output Commit , func ( ji * ppsclient . Job Info ) error { if err : = marshaller . Marshal ( os . Stdout , ji ) ; err ! = nil { return err } return nil } ) } writer : = tabwriter . New Writer ( os . Stdout , pretty . Job Header ) if err : = client . List Job F ( pipeline Name , commits , output Commit , func ( ji * ppsclient . Job Info ) error { pretty . Print Job Info ( writer , ji , full Timestamps ) return nil } ) ; err ! = nil { return err } return writer . Flush ( ) } ) , } list Job . Flags ( ) . String Var P ( & pipeline Name , " " , " " , " " , " " ) list Job . Mark Flag Custom ( " " , " " ) list Job . Flags ( ) . String Var P ( & output Commit Str , " " , " " , " " , " " ) list Job . Mark Flag Custom ( " " , " " ) list Job . Flags ( ) . String Slice Var P ( & input Commit Strs , " " , " " , [ ] string { } , " " ) list Job . Mark Flag Custom ( " " , " " ) list Job . Flags ( ) . Add Flag Set ( raw Flags ) list Job . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( list Job , " " ) ) var pipelines cmdutil . Repeated String Arg flush Job : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Return jobs caused by foo @XXX and bar @YYY . $ { {alias } } foo @XXX bar @YYY # Return jobs caused by foo @XXX leading to pipelines bar and baz . $ { {alias } } foo @XXX -p bar -p baz ` , Run : cmdutil . Run ( func ( args [ ] string ) error { commits , err : = cmdutil . Parse Commits ( args ) if err ! = nil { return err } c , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer c . Close ( ) job Infos , err : = c . Flush Job All ( commits , pipelines ) if err ! = nil { return err } if raw { for _ , job Info : = range job Infos { if err : = marshaller . Marshal ( os . Stdout , job Info ) ; err ! = nil { return err } } return nil } writer : = tabwriter . New Writer ( os . Stdout , pretty . Job Header ) for _ , job Info : = range job Infos { pretty . Print Job Info ( writer , job Info , full Timestamps ) } return writer . Flush ( ) } ) , } flush Job . Flags ( ) . Var P ( & pipelines , " " , " " , " " ) flush Job . Mark Flag Custom ( " " , " " ) flush Job . Flags ( ) . Add Flag Set ( raw Flags ) flush Job . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( flush Job , " " ) ) delete Job : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if err : = client . Delete Job ( args [ 0 ] ) ; err ! = nil { cmdutil . Error And Exit ( " " , err . Error ( ) ) } return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( delete Job , " " ) ) stop Job : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if err : = client . Stop Job ( args [ 0 ] ) ; err ! = nil { cmdutil . Error And Exit ( " " , err . Error ( ) ) } return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( stop Job , " " ) ) datum Docs : = & cobra . Command { Short : " " , Long : `Datums are the small independent units of processing for Pachyderm jobs . A datum is defined by applying a glob pattern (in the pipeline spec ) to the file paths in the input repo . A datum can include one or more files or directories . Datums within a job will be processed independently , sometimes distributed across separate workers . A separate execution of user code will be run for each datum . ` , } cmdutil . Set Docs Usage ( datum Docs ) commands = append ( commands , cmdutil . Create Alias ( datum Docs , " " ) ) restart Datum : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 2 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) datum Filter : = strings . Split ( args [ 1 ] , " " ) for i : = 0 ; i < len ( datum Filter ) ; { if len ( datum Filter [ i ] ) = = 0 { if i + 1 < len ( datum Filter ) { copy ( datum Filter [ i : ] , datum Filter [ i + 1 : ] ) } datum Filter = datum Filter [ : len ( datum Filter ) - 1 ] } else { i + + } } return client . Restart Datum ( args [ 0 ] , datum Filter ) } ) , } commands = append ( commands , cmdutil . Create Alias ( restart Datum , " " ) ) var page Size int 6 4 var page int 6 4 list Datum : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if page Size < 0 { return fmt . Errorf ( " " ) } if page < 0 { return fmt . Errorf ( " " ) } if raw { return client . List Datum F ( args [ 0 ] , page Size , page , func ( di * ppsclient . Datum Info ) error { return marshaller . Marshal ( os . Stdout , di ) } ) } writer : = tabwriter . New Writer ( os . Stdout , pretty . Datum Header ) if err : = client . List Datum F ( args [ 0 ] , page Size , page , func ( di * ppsclient . Datum Info ) error { pretty . Print Datum Info ( writer , di ) return nil } ) ; err ! = nil { return err } return writer . Flush ( ) } ) , } list Datum . Flags ( ) . Int 6 4Var ( & page Size , " " , 0 , " " ) list Datum . Flags ( ) . Int 6 4Var ( & page , " " , 0 , " " ) list Datum . Flags ( ) . Add Flag Set ( raw Flags ) commands = append ( commands , cmdutil . Create Alias ( list Datum , " " ) ) inspect Datum : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 2 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) datum Info , err : = client . Inspect Datum ( args [ 0 ] , args [ 1 ] ) if err ! = nil { return err } if raw { return marshaller . Marshal ( os . Stdout , datum Info ) } pretty . Print Detailed Datum Info ( os . Stdout , datum Info ) return nil } ) , } inspect Datum . Flags ( ) . Add Flag Set ( raw Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect Datum , " " ) ) var ( job ID string datum ID string comma Inputs string / / comma -separated list of input files of interest master bool follow bool tail int 6 4 ) get Logs : = & cobra . Command { Use : " " , Short : " " , Long : " " , Example : ` # Return logs emitted by recent jobs in the "filter " pipeline $ { {alias } } - -pipeline =filter # Return logs emitted by the job aedfa 1 2aedf $ { {alias } } - -job =aedfa 1 2aedf # Return logs emitted by the pipeline \ "filter \ " while processing /apple .txt and a file with the hash 1 2 3aef $ { {alias } } - -pipeline =filter - -inputs = /apple .txt , 1 2 3aef ` , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer client . Close ( ) / / Break up comma -separated input paths , and filter out empty entries data : = strings . Split ( comma Inputs , " " ) for i : = 0 ; i < len ( data ) ; { if len ( data [ i ] ) = = 0 { if i + 1 < len ( data ) { copy ( data [ i : ] , data [ i + 1 : ] ) } data = data [ : len ( data ) - 1 ] } else { i + + } } / / Issue RPC marshaler : = & jsonpb . Marshaler { } iter : = client . Get Logs ( pipeline Name , job ID , data , datum ID , master , follow , tail ) for iter . Next ( ) { var message Str string if raw { var err error message Str , err = marshaler . Marshal To String ( iter . Message ( ) ) if err ! = nil { fmt . Fprintf ( os . Stderr , " \ " \ " \n " , iter . Message ( ) , err ) } fmt . Println ( message Str ) } else if iter . Message ( ) . User { fmt . Println ( iter . Message ( ) . Message ) } else if iter . Message ( ) . Master & & master { fmt . Println ( iter . Message ( ) . Message ) } else if pipeline Name = = " " & & job ID = = " " { fmt . Println ( iter . Message ( ) . Message ) } } return iter . Err ( ) } ) , } get Logs . Flags ( ) . String Var P ( & pipeline Name , " " , " " , " " , " " + " " ) get Logs . Mark Flag Custom ( " " , " " ) get Logs . Flags ( ) . String Var ( & job ID , " " , " " , " " + " " ) get Logs . Mark Flag Custom ( " " , " " ) get Logs . Flags ( ) . String Var ( & datum ID , " " , " " , " " ) get Logs . Flags ( ) . String Var ( & comma Inputs , " " , " " , " " + " " ) get Logs . Flags ( ) . Bool Var ( & master , " " , false , " " ) get Logs . Flags ( ) . Bool Var ( & raw , " " , false , " " ) get Logs . Flags ( ) . Bool Var P ( & follow , " " , " " , false , " " ) get Logs . Flags ( ) . Int 6 4Var P ( & tail , " " , " " , 0 , " " ) commands = append ( commands , cmdutil . Create Alias ( get Logs , " " ) ) pipeline Docs : = & cobra . Command { Short : " " , Long : `Pipelines are a powerful abstraction for automating jobs . Pipelines take a set of repos and branches as inputs and will write to a single output repo of the same name . Pipelines then subscribe to commits on those repos and launch a job to process each incoming commit . All jobs created by a pipeline will create commits in the pipeline 's output repo . ` , } cmdutil . Set Docs Usage ( pipeline Docs ) commands = append ( commands , cmdutil . Create Alias ( pipeline Docs , " " ) ) var build bool var push Images bool var registry string var username string var pipeline Path string create Pipeline : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { return pipeline Helper ( ! * no Metrics , ! * no Port Forwarding , false , build , push Images , registry , username , pipeline Path , false ) } ) , } create Pipeline . Flags ( ) . String Var P ( & pipeline Path , " " , " " , " " , " " ) create Pipeline . Flags ( ) . Bool Var P ( & build , " " , " " , false , " " ) create Pipeline . Flags ( ) . Bool Var P ( & push Images , " " , " " , false , " " ) create Pipeline . Flags ( ) . String Var P ( & registry , " " , " " , " " , " " ) create Pipeline . Flags ( ) . String Var P ( & username , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( create Pipeline , " " ) ) var reprocess bool update Pipeline : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { return pipeline Helper ( ! * no Metrics , ! * no Port Forwarding , reprocess , build , push Images , registry , username , pipeline Path , true ) } ) , } update Pipeline . Flags ( ) . String Var P ( & pipeline Path , " " , " " , " " , " " ) update Pipeline . Flags ( ) . Bool Var P ( & build , " " , " " , false , " " ) update Pipeline . Flags ( ) . Bool Var P ( & push Images , " " , " " , false , " " ) update Pipeline . Flags ( ) . String Var P ( & registry , " " , " " , " " , " " ) update Pipeline . Flags ( ) . String Var P ( & username , " " , " " , " " , " " ) update Pipeline . Flags ( ) . Bool Var ( & reprocess , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( update Pipeline , " " ) ) inspect Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) pipeline Info , err : = client . Inspect Pipeline ( args [ 0 ] ) if err ! = nil { return err } if pipeline Info = = nil { return fmt . Errorf ( " " , args [ 0 ] ) } if raw { return marshaller . Marshal ( os . Stdout , pipeline Info ) } pi : = & pretty . Printable Pipeline Info { Pipeline Info : pipeline Info , Full Timestamps : full Timestamps , } return pretty . Print Detailed Pipeline Info ( pi ) } ) , } inspect Pipeline . Flags ( ) . Add Flag Set ( raw Flags ) inspect Pipeline . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( inspect Pipeline , " " ) ) extract Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) create Pipeline Request , err : = client . Extract Pipeline ( args [ 0 ] ) if err ! = nil { return err } return marshaller . Marshal ( os . Stdout , create Pipeline Request ) } ) , } commands = append ( commands , cmdutil . Create Alias ( extract Pipeline , " " ) ) var editor string edit Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) ( ret Err error ) { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) create Pipeline Request , err : = client . Extract Pipeline ( args [ 0 ] ) if err ! = nil { return err } f , err : = ioutil . Temp File ( " " , args [ 0 ] ) if err ! = nil { return err } if err : = marshaller . Marshal ( f , create Pipeline Request ) ; err ! = nil { return err } defer func ( ) { if err : = f . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) if editor = = " " { editor = os . Getenv ( " " ) } if editor = = " " { editor = " " } if err : = cmdutil . Run IO ( cmdutil . IO { Stdin : os . Stdin , Stdout : os . Stdout , Stderr : os . Stderr , } , editor , f . Name ( ) ) ; err ! = nil { return err } cfg Reader , err : = ppsutil . New Pipeline Manifest Reader ( f . Name ( ) ) if err ! = nil { return err } request , err : = cfg Reader . Next Create Pipeline Request ( ) if err ! = nil { return err } if proto . Equal ( create Pipeline Request , request ) { fmt . Println ( " " ) return nil } request . Update = true request . Reprocess = reprocess if _ , err : = client . Pps APIClient . Create Pipeline ( client . Ctx ( ) , request , ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } ) , } edit Pipeline . Flags ( ) . Bool Var ( & reprocess , " " , false , " " ) edit Pipeline . Flags ( ) . String Var ( & editor , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( edit Pipeline , " " ) ) var spec bool list Pipeline : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer client . Close ( ) pipeline Infos , err : = client . List Pipeline ( ) if err ! = nil { return err } if raw { for _ , pipeline Info : = range pipeline Infos { if err : = marshaller . Marshal ( os . Stdout , pipeline Info ) ; err ! = nil { return err } } return nil } if spec { for _ , pipeline Info : = range pipeline Infos { if err : = marshaller . Marshal ( os . Stdout , ppsutil . Pipeline Req From Info ( pipeline Info ) ) ; err ! = nil { return err } } return nil } writer : = tabwriter . New Writer ( os . Stdout , pretty . Pipeline Header ) for _ , pipeline Info : = range pipeline Infos { pretty . Print Pipeline Info ( writer , pipeline Info , full Timestamps ) } return writer . Flush ( ) } ) , } list Pipeline . Flags ( ) . Bool Var P ( & spec , " " , " " , false , " " ) list Pipeline . Flags ( ) . Add Flag Set ( raw Flags ) list Pipeline . Flags ( ) . Add Flag Set ( full Timestamps Flags ) commands = append ( commands , cmdutil . Create Alias ( list Pipeline , " " ) ) var all bool var force bool delete Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Bounded Args ( 0 , 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if len ( args ) > 0 & & all { return fmt . Errorf ( " " ) } if len ( args ) = = 0 & & ! all { return fmt . Errorf ( " " ) } if all { _ , err = client . Pps APIClient . Delete Pipeline ( client . Ctx ( ) , & ppsclient . Delete Pipeline Request { All : all , Force : force , } ) } else { err = client . Delete Pipeline ( args [ 0 ] , force ) } if err ! = nil { return grpcutil . Scrub GRPC ( err ) } return nil } ) , } delete Pipeline . Flags ( ) . Bool Var ( & all , " " , false , " " ) delete Pipeline . Flags ( ) . Bool Var P ( & force , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( delete Pipeline , " " ) ) start Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if err : = client . Start Pipeline ( args [ 0 ] ) ; err ! = nil { cmdutil . Error And Exit ( " " , err . Error ( ) ) } return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( start Pipeline , " " ) ) stop Pipeline : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) if err : = client . Stop Pipeline ( args [ 0 ] ) ; err ! = nil { cmdutil . Error And Exit ( " " , err . Error ( ) ) } return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( stop Pipeline , " " ) ) var memory string garbage Collect : = & cobra . Command { Short : " " , Long : `Garbage collect unused data . When a file /commit /repo is deleted , the data is not immediately removed from the underlying storage system (e .g . S 3 ) for performance and architectural reasons . This is similar to how when you delete a file on your computer , the file is not necessarily wiped from disk immediately . To actually remove the data , you will need to manually invoke garbage collection with "pachctl garbage -collect " . Currently "pachctl garbage -collect " can only be started when there are no pipelines running . You also need to ensure that there 's no ongoing "put file " . Garbage collection puts the cluster into a readonly mode where no new jobs can be created and no data can be added . Pachyderm 's garbage collection uses bloom filters to index live objects . This means that some dead objects may erronously not be deleted during garbage collection . The probability of this happening depends on how many objects you have ; at around 1 0M objects it starts to become likely with the default values . To lower Pachyderm 's error rate and make garbage -collection more comprehensive , you can increase the amount of memory used for the bloom filters with the - -memory flag . The default value is 1 0MB . ` , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { client , err : = pachdclient . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return err } defer client . Close ( ) memory Bytes , err : = units . RAMIn Bytes ( memory ) if err ! = nil { return err } return client . Garbage Collect ( memory Bytes ) } ) , } garbage Collect . Flags ( ) . String Var P ( & memory , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( garbage Collect , " " ) ) return commands } 
func build Image ( client * docker . Client , repo string , context Dir string , dockerfile string , dest Tag string ) error { dest Image : = fmt . Sprintf ( " " , repo , dest Tag ) fmt . Printf ( " \n " , dest Image ) err : = client . Build Image ( docker . Build Image Options { Name : dest Image , Context Dir : context Dir , Dockerfile : dockerfile , Output Stream : os . Stdout , } ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func push Image ( client * docker . Client , auth Config docker . Auth Configuration , repo string , source Tag string , dest Tag string ) ( string , error ) { source Image : = fmt . Sprintf ( " " , repo , source Tag ) dest Image : = fmt . Sprintf ( " " , repo , dest Tag ) fmt . Printf ( " \n " , dest Image ) if err : = client . Tag Image ( source Image , docker . Tag Image Options { Repo : repo , Tag : dest Tag , Context : context . Background ( ) , } ) ; err ! = nil { err = fmt . Errorf ( " " , err ) return " " , err } if err : = client . Push Image ( docker . Push Image Options { Name : repo , Tag : dest Tag , } , auth Config , ) ; err ! = nil { err = fmt . Errorf ( " " , err ) return " " , err } return dest Image , nil } 
func is Docker Using Keychain ( ) bool { user , err : = user . Current ( ) if err ! = nil { return false } contents , err : = ioutil . Read File ( path . Join ( user . Home Dir , " " ) ) if err ! = nil { return false } var j map [ string ] interface { } if err = json . Unmarshal ( contents , & j ) ; err ! = nil { return false } auths , ok : = j [ " " ] if ! ok { return false } auths Inner , ok : = auths . ( map [ string ] interface { } ) if ! ok { return false } index , ok : = auths Inner [ " " ] if ! ok { return false } index Inner , ok : = index . ( map [ string ] interface { } ) if ! ok | | len ( index Inner ) > 0 { return false } return j [ " " ] = = " " } 
func new Minio Client ( endpoint , bucket , id , secret string , secure bool ) ( * minio Client , error ) { mclient , err : = minio . New ( endpoint , id , secret , secure ) if err ! = nil { return nil , err } return & minio Client { bucket : bucket , Client : mclient , } , nil } 
func new Minio Client V 2 ( endpoint , bucket , id , secret string , secure bool ) ( * minio Client , error ) { mclient , err : = minio . New V 2 ( endpoint , id , secret , secure ) if err ! = nil { return nil , err } return & minio Client { bucket : bucket , Client : mclient , } , nil } 
func new Minio Writer ( ctx context . Context , client * minio Client , name string ) * minio Writer { reader , writer : = io . Pipe ( ) w : = & minio Writer { ctx : ctx , err Chan : make ( chan error ) , pipe : writer , } go func ( ) { _ , err : = client . Put Object ( client . bucket , name , reader , " " ) if err ! = nil { reader . Close With Error ( err ) } w . err Chan < - err } ( ) return w } 
func ( w * minio Writer ) Close ( ) error { span , _ : = tracing . Add Span To Any Existing ( w . ctx , " " ) defer tracing . Finish Any Span ( span ) if err : = w . pipe . Close ( ) ; err ! = nil { return err } return < - w . err Chan } 
func Pipeline Repo ( pipeline * ppsclient . Pipeline ) * pfs . Repo { return & pfs . Repo { Name : pipeline . Name } } 
func Pipeline Rc Name ( name string , version uint 6 4 ) string { return fmt . Sprintf ( " " , strings . To Lower ( name ) , version ) } 
func Get Requests Resource List From Pipeline ( pipeline Info * pps . Pipeline Info ) ( * v 1 . Resource List , error ) { return get Resource List From Spec ( pipeline Info . Resource Requests , pipeline Info . Cache Size ) } 
func Get Limits Resource List From Pipeline ( pipeline Info * pps . Pipeline Info ) ( * v 1 . Resource List , error ) { return get Resource List From Spec ( pipeline Info . Resource Limits , pipeline Info . Cache Size ) } 
func get Num Nodes ( kube Client * kube . Clientset ) ( int , error ) { node List , err : = kube Client . Core V 1 ( ) . Nodes ( ) . List ( metav 1 . List Options { } ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } if len ( node List . Items ) = = 0 { return 0 , fmt . Errorf ( " " ) } return len ( node List . Items ) , nil } 
func Get Expected Num Workers ( kube Client * kube . Clientset , spec * ppsclient . Parallelism Spec ) ( int , error ) { if spec = = nil | | ( spec . Constant = = 0 & & spec . Coefficient = = 0 ) { return 1 , nil } else if spec . Constant > 0 & & spec . Coefficient = = 0 { return int ( spec . Constant ) , nil } else if spec . Constant = = 0 & & spec . Coefficient > 0 { if err ! = nil { return 0 , err } result : = math . Floor ( spec . Coefficient * float 6 4 ( num Nodes ) ) return int ( math . Max ( result , 1 ) ) , nil } return 0 , fmt . Errorf ( " " , spec ) } 
func Get Expected Num Hashtrees ( spec * ppsclient . Hashtree Spec ) ( int 6 4 , error ) { if spec = = nil | | spec . Constant = = 0 { return 1 , nil } else if spec . Constant > 0 { return int 6 4 ( spec . Constant ) , nil } return 0 , fmt . Errorf ( " " , spec ) } 
func Get Pipeline Info ( pach Client * client . APIClient , ptr * pps . Etcd Pipeline Info , full bool ) ( * pps . Pipeline Info , error ) { result : = & pps . Pipeline Info { } if full { buf : = bytes . Buffer { } if err : = pach Client . Get File ( ppsconsts . Spec Repo , ptr . Spec Commit . ID , ppsconsts . Spec File , 0 , 0 , & buf ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if err : = result . Unmarshal ( buf . Bytes ( ) ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } } result . State = ptr . State result . Reason = ptr . Reason result . Job Counts = ptr . Job Counts result . Last Job State = ptr . Last Job State result . Spec Commit = ptr . Spec Commit return result , nil } 
func Fail Pipeline ( ctx context . Context , etcd Client * etcd . Client , pipelines Collection col . Collection , pipeline Name string , reason string ) error { _ , err : = col . New STM ( ctx , etcd Client , func ( stm col . STM ) error { pipelines : = pipelines Collection . Read Write ( stm ) pipeline Ptr : = new ( pps . Etcd Pipeline Info ) if err : = pipelines . Get ( pipeline Name , pipeline Ptr ) ; err ! = nil { return err } pipeline Ptr . State = pps . Pipeline State _PIPELINE _FAILURE pipeline Ptr . Reason = reason pipelines . Put ( pipeline Name , pipeline Ptr ) return nil } ) return err } 
func Job Input ( pipeline Info * pps . Pipeline Info , output Commit Info * pfs . Commit Info ) * pps . Input { key : = path . Join for _ , prov : = range output Commit Info . Provenance { branch To Commit [ key ( prov . Commit . Repo . Name , prov . Branch . Name ) ] = prov . Commit } job Input : = proto . Clone ( pipeline Info . Input ) . ( * pps . Input ) pps . Visit Input ( job Input , func ( input * pps . Input ) { if input . Pfs ! = nil { if commit , ok : = branch To Commit [ key ( input . Pfs . Repo , input . Pfs . Branch ) ] ; ok { input . Pfs . Commit = commit . ID } } if input . Cron ! = nil { if commit , ok : = branch To Commit [ key ( input . Cron . Repo , " " ) ] ; ok { input . Cron . Commit = commit . ID } } if input . Git ! = nil { if commit , ok : = branch To Commit [ key ( input . Git . Name , input . Git . Branch ) ] ; ok { input . Git . Commit = commit . ID } } } ) return job Input } 
func Pipeline Req From Info ( pipeline Info * ppsclient . Pipeline Info ) * ppsclient . Create Pipeline Request { return & ppsclient . Create Pipeline Request { Pipeline : pipeline Info . Pipeline , Transform : pipeline Info . Transform , Parallelism Spec : pipeline Info . Parallelism Spec , Hashtree Spec : pipeline Info . Hashtree Spec , Egress : pipeline Info . Egress , Output Branch : pipeline Info . Output Branch , Scale Down Threshold : pipeline Info . Scale Down Threshold , Resource Requests : pipeline Info . Resource Requests , Resource Limits : pipeline Info . Resource Limits , Input : pipeline Info . Input , Description : pipeline Info . Description , Cache Size : pipeline Info . Cache Size , Enable Stats : pipeline Info . Enable Stats , Batch : pipeline Info . Batch , Max Queue Size : pipeline Info . Max Queue Size , Service : pipeline Info . Service , Chunk Spec : pipeline Info . Chunk Spec , Datum Timeout : pipeline Info . Datum Timeout , Job Timeout : pipeline Info . Job Timeout , Salt : pipeline Info . Salt , } } 
func New Pipeline Manifest Reader ( path string ) ( result * Pipeline Manifest Reader , ret Err error ) { result = & Pipeline Manifest Reader { } var pipeline Reader io . Reader if path = = " " { pipeline Reader = io . Tee Reader ( os . Stdin , & result . buf ) fmt . Print ( " \n " ) } else if url , err : = url . Parse ( path ) ; err = = nil & & url . Scheme ! = " " { resp , err : = http . Get ( url . String ( ) ) if err ! = nil { return nil , err } defer func ( ) { if err : = resp . Body . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) raw Bytes , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return nil , err } pipeline Reader = io . Tee Reader ( strings . New Reader ( string ( raw Bytes ) ) , & result . buf ) } else { raw Bytes , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } pipeline Reader = io . Tee Reader ( strings . New Reader ( string ( raw Bytes ) ) , & result . buf ) } result . decoder = json . New Decoder ( pipeline Reader ) return result , nil } 
func ( r * Pipeline Manifest Reader ) Next Create Pipeline Request ( ) ( * ppsclient . Create Pipeline Request , error ) { var result ppsclient . Create Pipeline Request if err : = jsonpb . Unmarshal Next ( r . decoder , & result ) ; err ! = nil { if err = = io . EOF { return nil , err } return nil , fmt . Errorf ( " " , err ) } return & result , nil } 
func Describe Syntax Error ( original Err error , parsed Buffer bytes . Buffer ) error { s Err , ok : = original Err . ( * json . Syntax Error ) if ! ok { return original Err } buffer : = make ( [ ] byte , s Err . Offset ) parsed Buffer . Read ( buffer ) line Offset : = strings . Last Index ( string ( buffer [ : len ( buffer ) - 1 ] ) , " \n " ) if line Offset = = - 1 { line Offset = 0 } lines : = strings . Split ( string ( buffer [ : len ( buffer ) - 1 ] ) , " \n " ) line Number : = len ( lines ) descriptive Error String : = fmt . Sprintf ( " \n \n \n \n " , line Number , string ( buffer [ line Offset : ] ) , strings . Repeat ( " " , int ( s Err . Offset ) - 2 - line Offset ) , original Err , ) return errors . New ( descriptive Error String ) } 
func Is Terminal ( state pps . Job State ) bool { switch state { case pps . Job State _JOB _SUCCESS , pps . Job State _JOB _FAILURE , pps . Job State _JOB _KILLED : return true case pps . Job State _JOB _STARTING , pps . Job State _JOB _RUNNING , pps . Job State _JOB _MERGING : return false default : panic ( fmt . Sprintf ( " " , state ) ) } } 
func Update Job State ( pipelines col . Read Write Collection , jobs col . Read Write Collection , job Ptr * pps . Etcd Job Info , state pps . Job State , reason string ) error { if err : = pipelines . Get ( job Ptr . Pipeline . Name , pipeline Ptr ) ; err ! = nil { return err } if pipeline Ptr . Job Counts = = nil { pipeline Ptr . Job Counts = make ( map [ int 3 2 ] int 3 2 ) } if pipeline Ptr . Job Counts [ int 3 2 ( job Ptr . State ) ] ! = 0 { pipeline Ptr . Job Counts [ int 3 2 ( job Ptr . State ) ] - - } pipeline Ptr . Job Counts [ int 3 2 ( state ) ] + + pipeline Ptr . Last Job State = state if err : = pipelines . Put ( job Ptr . Pipeline . Name , pipeline Ptr ) ; err ! = nil { return err } if state = = pps . Job State _JOB _STARTING { job Ptr . Started , err = types . Timestamp Proto ( time . Now ( ) ) } else if Is Terminal ( state ) { job Ptr . Finished , err = types . Timestamp Proto ( time . Now ( ) ) } if err ! = nil { return err } job Ptr . State = state job Ptr . Reason = reason return jobs . Put ( job Ptr . Job . ID , job Ptr ) } 
func fetch Raw IDPMetadata ( name string , md URL * url . URL ) ( [ ] byte , error ) { c : = http . Default Client req , err : = http . New Request ( " " , md URL . String ( ) , nil ) if err ! = nil { return nil , fmt . Errorf ( " " , name , err ) } req . Header . Set ( " " , " " ) var raw Metadata [ ] byte b : = backoff . New Infinite Back Off ( ) b . Max Elapsed Time = 3 0 * time . Second b . Max Interval = 2 * time . Second if err : = backoff . Retry Notify ( func ( ) error { resp , err : = c . Do ( req ) if err ! = nil { return err } if resp . Status Code ! = http . Status OK { return fmt . Errorf ( " " , resp . Status Code , resp . Status ) } raw Metadata , err = ioutil . Read All ( resp . Body ) resp . Body . Close ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if len ( raw Metadata ) = = 0 { return fmt . Errorf ( " " ) } return nil } , b , func ( err error , d time . Duration ) error { logrus . Printf ( " " , err , d ) return nil } ) ; err ! = nil { return nil , err } } 
func ( a * api Server ) update Config ( config * auth . Auth Config ) error { if config = = nil { config = & auth . Auth Config { } } new Config , err : = validate Config ( config , internal ) if err ! = nil { return err } a . redirect Address = a . config Cache . SAMLSvc . Dash URL } else { a . config Cache = nil a . saml SP = nil a . redirect Address = nil } return nil } 
func ( a * api Server ) handle SAMLResponse Internal ( req * http . Request ) ( string , string , * errutil . HTTPError ) { a . config Mu . Lock ( ) defer a . config Mu . Unlock ( ) a . saml SPMu . Lock ( ) defer a . saml SPMu . Unlock ( ) if a . config Cache = = nil { return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " ) } if a . saml SP = = nil { return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " ) } sp : = a . saml SP if err : = req . Parse Form ( ) ; err ! = nil { return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " , err ) } if err ! = nil { err Msg : = fmt . Sprintf ( " " , err ) if invalid Resp Err , ok : = err . ( * saml . Invalid Response Error ) ; ok { err Msg + = " \n " + invalid Resp Err . Private Err . Error ( ) + " " } return " " , " " , errutil . New HTTPError ( http . Status Bad Request , err Msg ) } case assertion . Subject = = nil : return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " ) case assertion . Subject . Name ID = = nil : return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " ) case assertion . Subject . Name ID . Value = = " " : return " " , " " , errutil . New HTTPError ( http . Status Conflict , " " ) } if a . config Cache . SAMLSvc . Session Duration ! = 0 { expiration = time . Now ( ) . Add ( a . config Cache . SAMLSvc . Session Duration ) } auth Code , err : = a . get One Time Password ( req . Context ( ) , subject , expiration ) if err ! = nil { return " " , " " , errutil . New HTTPError ( http . Status Internal Server Error , err . Error ( ) ) } } for _ , v : = range attr . Values { groups = append ( groups , fmt . Sprintf ( " " , a . config Cache . IDP . Name , v . Value ) ) } if err : = a . set Groups For User Internal ( context . Background ( ) , subject , groups ) ; err ! = nil { return " " , " " , errutil . New HTTPError ( http . Status Internal Server Error , err . Error ( ) ) } } } } return subject , auth Code , nil } 
func ( a * api Server ) handle SAMLResponse ( w http . Response Writer , req * http . Request ) { var subject , auth Code string var err * errutil . HTTPError log Request : = " " a . Log Req ( log Request ) defer func ( start time . Time ) { if subject ! = " " { log Request = fmt . Sprintf ( " " , subject ) } a . Log Resp ( log Request , errutil . Pretty Print Code ( err ) , err , time . Since ( start ) ) } ( time . Now ( ) ) subject , auth Code , err = a . handle SAMLResponse Internal ( req ) if err ! = nil { http . Error ( w , err . Error ( ) , err . Code ( ) ) return } if a . redirect Address ! = nil { u = * a . redirect Address } u . Raw Query = url . Values { " " : [ ] string { auth Code } } . Encode ( ) w . Header ( ) . Set ( " " , u . String ( ) ) w . Write Header ( http . Status Found ) } 
func New ( ) string { var result string backoff . Retry Notify ( func ( ) error { uuid , err : = uuid . New V 4 ( ) if err ! = nil { return err } result = uuid . String ( ) return nil } , backoff . New Infinite Back Off ( ) , func ( err error , d time . Duration ) error { fmt . Printf ( " " , err ) return nil } ) return result } 
func ( h * HTTPError ) Code ( ) int { if h = = nil { return http . Status OK } return h . code } 
func Pretty Print Code ( h * HTTPError ) string { code Number : = h . Code ( ) code Text : = http . Status Text ( h . Code ( ) ) return fmt . Sprintf ( " " , code Number , code Text ) } 
func New HTTPError ( code int , format Str string , args . . . interface { } ) * HTTPError { return & HTTPError { code : code , err : fmt . Sprintf ( format Str , args . . . ) , } } 
func New Storage ( obj C obj . Client , prefix string ) * Storage { return & Storage { obj C : obj C , prefix : prefix , } } 
func ( s * Storage ) New Reader ( ctx context . Context , data Refs [ ] * Data Ref ) io . Read Closer { if len ( data Refs ) = = 0 { return ioutil . Nop Closer ( & bytes . Buffer { } ) } return new Reader ( ctx , s . obj C , s . prefix , data Refs ) } 
func ( s * Storage ) New Writer ( ctx context . Context ) * Writer { return new Writer ( ctx , s . obj C , s . prefix ) } 
func ( s * Storage ) Delete All ( ctx context . Context ) error { return s . obj C . Walk ( ctx , s . prefix , func ( hash string ) error { return s . obj C . Delete ( ctx , hash ) } ) } 
func Chunk ( data [ ] byte , chunk Size int ) [ ] [ ] byte { var result [ ] [ ] byte for i : = 0 ; i < len ( data ) ; i + = chunk Size { end : = i + chunk Size if end > len ( data ) { end = len ( data ) } result = append ( result , data [ i : end ] ) } return result } 
func Chunk Reader ( r io . Reader , f func ( [ ] byte ) error ) ( int , error ) { var total int buf : = Get Buffer ( ) defer Put Buffer ( buf ) for { n , err : = r . Read ( buf ) if n = = 0 & & err ! = nil { if err = = io . EOF { return total , nil } return total , err } if err : = f ( buf [ : n ] ) ; err ! = nil { return total , err } total + = n } } 
func New Streaming Bytes Reader ( streaming Bytes Client Streaming Bytes Client , cancel context . Cancel Func ) io . Read Closer { return & streaming Bytes Reader { streaming Bytes Client : streaming Bytes Client , cancel : cancel } } 
func Write To Streaming Bytes Server ( reader io . Reader , streaming Bytes Server Streaming Bytes Server ) error { buf : = Get Buffer ( ) defer Put Buffer ( buf ) _ , err : = io . Copy Buffer ( New Streaming Bytes Writer ( streaming Bytes Server ) , Reader Wrapper { reader } , buf ) return err } 
func Write From Streaming Bytes Client ( streaming Bytes Client Streaming Bytes Client , writer io . Writer ) error { for bytes Value , err : = streaming Bytes Client . Recv ( ) ; err ! = io . EOF ; bytes Value , err = streaming Bytes Client . Recv ( ) { if err ! = nil { return err } if _ , err = writer . Write ( bytes Value . Value ) ; err ! = nil { return err } } return nil } 
func New APIServer ( env * serviceenv . Service Env , etcd Prefix string , namespace string , worker Image string , worker Sidecar Image string , worker Image Pull Policy string , storage Root string , storage Backend string , storage Host Path string , iam Role string , image Pull Secret string , no Expose Docker Socket bool , reporter * metrics . Reporter , worker Uses Root bool , worker Grpc Port uint 1 6 , port uint 1 6 , pprof Port uint 1 6 , http Port uint 1 6 , peer Port uint 1 6 , ) ( ppsclient . APIServer , error ) { api Server : = & api Server { Logger : log . New Logger ( " " ) , env : env , etcd Prefix : etcd Prefix , namespace : namespace , worker Image : worker Image , worker Sidecar Image : worker Sidecar Image , worker Image Pull Policy : worker Image Pull Policy , storage Root : storage Root , storage Backend : storage Backend , storage Host Path : storage Host Path , iam Role : iam Role , image Pull Secret : image Pull Secret , no Expose Docker Socket : no Expose Docker Socket , reporter : reporter , worker Uses Root : worker Uses Root , pipelines : ppsdb . Pipelines ( env . Get Etcd Client ( ) , etcd Prefix ) , jobs : ppsdb . Jobs ( env . Get Etcd Client ( ) , etcd Prefix ) , monitor Cancels : make ( map [ string ] func ( ) ) , worker Grpc Port : worker Grpc Port , port : port , pprof Port : pprof Port , http Port : http Port , peer Port : peer Port , } api Server . validate Kube ( ) go api Server . master ( ) return api Server , nil } 
func New Sidecar APIServer ( env * serviceenv . Service Env , etcd Prefix string , iam Role string , reporter * metrics . Reporter , worker Grpc Port uint 1 6 , pprof Port uint 1 6 , http Port uint 1 6 , peer Port uint 1 6 , ) ( ppsclient . APIServer , error ) { api Server : = & api Server { Logger : log . New Logger ( " " ) , env : env , etcd Prefix : etcd Prefix , iam Role : iam Role , reporter : reporter , worker Uses Root : true , pipelines : ppsdb . Pipelines ( env . Get Etcd Client ( ) , etcd Prefix ) , jobs : ppsdb . Jobs ( env . Get Etcd Client ( ) , etcd Prefix ) , worker Grpc Port : worker Grpc Port , pprof Port : pprof Port , http Port : http Port , peer Port : peer Port , } return api Server , nil } 
func New Enterprise Server ( env * serviceenv . Service Env , etcd Prefix string ) ( ec . APIServer , error ) { s : = & api Server { pach Logger : log . New Logger ( " " ) , env : env , enterprise Token : col . New Collection ( env . Get Etcd Client ( ) , etcd Prefix , s . enterprise Expiration . Store ( time . Time { } ) go s . watch Enterprise Token ( etcd Prefix ) return s , nil } 
func validate Activation Code ( code string ) ( expiration time . Time , err error ) { if block = = nil { return time . Time { } , fmt . Errorf ( " " ) } pub , err : = x 5 0 9 . Parse PKIXPublic Key ( block . Bytes ) if err ! = nil { return time . Time { } , fmt . Errorf ( " " , err . Error ( ) ) } rsa Pub , ok : = pub . ( * rsa . Public Key ) if ! ok { return time . Time { } , fmt . Errorf ( " " ) } if err ! = nil { return time . Time { } , fmt . Errorf ( " " ) } activation Code : = & activation Code { } if err : = json . Unmarshal ( decoded Activation Code , & activation Code ) ; err ! = nil { return time . Time { } , fmt . Errorf ( " " ) } if err ! = nil { return time . Time { } , fmt . Errorf ( " " ) } } if err : = json . Unmarshal ( [ ] byte ( activation Code . Token ) , & token ) ; err ! = nil { return time . Time { } , fmt . Errorf ( " " ) } if err ! = nil { return time . Time { } , fmt . Errorf ( " " ) } } return expiration , nil } 
func ( a * api Server ) Activate ( ctx context . Context , req * ec . Activate Request ) ( resp * ec . Activate Response , ret Err error ) { a . Log Req ( req ) defer func ( start time . Time ) { a . pach Logger . Log ( req , resp , ret Err , time . Since ( start ) ) } ( time . Now ( ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err . Error ( ) ) } if err = = nil & & expiration . After ( custom Expiration ) { expiration = custom Expiration } } expiration Proto , err : = types . Timestamp Proto ( expiration ) if err ! = nil { return nil , fmt . Errorf ( " \ " \ " " , expiration . String ( ) , err . Error ( ) ) } if _ , err : = col . New STM ( ctx , a . env . Get Etcd Client ( ) , func ( stm col . STM ) error { e : = a . enterprise Token . Read Write ( stm ) } ) ; err ! = nil { return nil , err } } return nil } , backoff . Retry Every ( time . Second ) ) ; err ! = nil { return nil , err } time . Sleep ( time . Second ) return & ec . Activate Response { Info : & ec . Token Info { Expires : expiration Proto , } , } , nil } 
func ( a * api Server ) Get State ( ctx context . Context , req * ec . Get State Request ) ( resp * ec . Get State Response , ret Err error ) { a . Log Req ( req ) defer func ( start time . Time ) { a . pach Logger . Log ( req , resp , ret Err , time . Since ( start ) ) } ( time . Now ( ) ) expiration , ok : = a . enterprise Expiration . Load ( ) . ( time . Time ) if ! ok { return nil , fmt . Errorf ( " " ) } if expiration . Is Zero ( ) { return & ec . Get State Response { State : ec . State _NONE } , nil } expiration Proto , err : = types . Timestamp Proto ( expiration ) if err ! = nil { return nil , fmt . Errorf ( " \ " \ " " , expiration . String ( ) , err . Error ( ) ) } resp = & ec . Get State Response { Info : & ec . Token Info { Expires : expiration Proto , } , } if time . Now ( ) . After ( expiration ) { resp . State = ec . State _EXPIRED } else { resp . State = ec . State _ACTIVE } return resp , nil } 
func ( a * api Server ) Deactivate ( ctx context . Context , req * ec . Deactivate Request ) ( resp * ec . Deactivate Response , ret Err error ) { a . Log Req ( req ) defer func ( start time . Time ) { a . pach Logger . Log ( req , resp , ret Err , time . Since ( start ) ) } ( time . Now ( ) ) pach Client : = a . env . Get Pach Client ( ctx ) if err : = pach Client . Delete All ( ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } if _ , err : = col . New STM ( ctx , a . env . Get Etcd Client ( ) , func ( stm col . STM ) error { } ) ; err ! = nil { return nil , err } } return nil } , backoff . Retry Every ( time . Second ) ) ; err ! = nil { return nil , err } time . Sleep ( time . Second ) return & ec . Deactivate Response { } , nil } 
func Command ( name string , arg . . . string ) * Cmd { cmd : = & Cmd { Path : name , Args : append ( [ ] string { name } , arg . . . ) , } if filepath . Base ( name ) = = name { if lp , err : = exec . Look Path ( name ) ; err ! = nil { cmd . look Path Err = err } else { cmd . Path = lp } } return cmd } 
func Command Context ( ctx context . Context , name string , arg . . . string ) * Cmd { if ctx = = nil { panic ( " " ) } cmd : = Command ( name , arg . . . ) cmd . ctx = ctx return cmd } 
func ( c * Cmd ) Run ( ) error { if err : = c . Start ( ) ; err ! = nil { return err } return c . Wait ( ) } 
func look Extensions ( path , dir string ) ( string , error ) { if filepath . Base ( path ) = = path { path = filepath . Join ( " " , path ) } if dir = = " " { return exec . Look Path ( path ) } if filepath . Volume Name ( path ) ! = " " { return exec . Look Path ( path ) } if len ( path ) > 1 & & os . Is Path Separator ( path [ 0 ] ) { return exec . Look Path ( path ) } dirandpath : = filepath . Join ( dir , path ) if err ! = nil { return " " , err } ext : = strings . Trim Prefix ( lp , dirandpath ) return path + ext , nil } 
func ( c * Cmd ) Start ( ) error { if c . look Path Err ! = nil { c . close Descriptors ( c . close After Start ) c . close Descriptors ( c . close After Wait ) return c . look Path Err } if runtime . GOOS = = " " { lp , err : = look Extensions ( c . Path , c . Dir ) if err ! = nil { c . close Descriptors ( c . close After Start ) c . close Descriptors ( c . close After Wait ) return err } c . Path = lp } if c . Process ! = nil { return errors . New ( " " ) } if c . ctx ! = nil { select { case < - c . ctx . Done ( ) : c . close Descriptors ( c . close After Start ) c . close Descriptors ( c . close After Wait ) return c . ctx . Err ( ) default : } } type F func ( * Cmd ) ( * os . File , error ) for _ , setup Fd : = range [ ] F { ( * Cmd ) . stdin , ( * Cmd ) . stdout , ( * Cmd ) . stderr } { fd , err : = setup Fd ( c ) if err ! = nil { c . close Descriptors ( c . close After Start ) c . close Descriptors ( c . close After Wait ) return err } c . child Files = append ( c . child Files , fd ) } c . child Files = append ( c . child Files , c . Extra Files . . . ) var err error c . Process , err = os . Start Process ( c . Path , c . argv ( ) , & os . Proc Attr { Dir : c . Dir , Files : c . child Files , Env : dedup Env ( c . envv ( ) ) , Sys : c . Sys Proc Attr , } ) if err ! = nil { c . close Descriptors ( c . close After Start ) c . close Descriptors ( c . close After Wait ) return err } c . close Descriptors ( c . close After Start ) c . errch = make ( chan error , len ( c . goroutine ) ) for _ , fn : = range c . goroutine { go func ( fn func ( ) error ) { c . errch < - fn ( ) } ( fn ) } if c . ctx ! = nil { c . wait Done = make ( chan struct { } ) go func ( ) { select { case < - c . ctx . Done ( ) : c . Process . Kill ( ) case < - c . wait Done : } } ( ) } return nil } 
func ( c * Cmd ) Wait ( ) error { if c . Process = = nil { return errors . New ( " " ) } if c . finished { return errors . New ( " " ) } c . finished = true state , err : = c . Process . Wait ( ) return c . Wait IO ( state , err ) } 
func ( c * Cmd ) Wait IO ( state * os . Process State , err error ) ( ret Err error ) { if c . wait Done ! = nil { close ( c . wait Done ) } c . Process State = state if err ! = nil { return err } else if ! state . Success ( ) { return & Exit Error { Process State : state } } for range c . goroutine { if err : = < - c . errch ; err ! = nil & & ret Err = = nil { ret Err = err } } c . close Descriptors ( c . close After Wait ) return ret Err } 
func ( c * Cmd ) Output ( ) ( [ ] byte , error ) { if c . Stdout ! = nil { return nil , errors . New ( " " ) } var stdout bytes . Buffer c . Stdout = & stdout capture Err : = c . Stderr = = nil if capture Err { c . Stderr = & prefix Suffix Saver { N : 3 2 < < 1 0 } } err : = c . Run ( ) if err ! = nil & & capture Err { if ee , ok : = err . ( * Exit Error ) ; ok { ee . Stderr = c . Stderr . ( * prefix Suffix Saver ) . Bytes ( ) } } return stdout . Bytes ( ) , err } 
func ( c * Cmd ) Combined Output ( ) ( [ ] byte , error ) { if c . Stdout ! = nil { return nil , errors . New ( " " ) } if c . Stderr ! = nil { return nil , errors . New ( " " ) } var b bytes . Buffer c . Stdout = & b c . Stderr = & b err : = c . Run ( ) return b . Bytes ( ) , err } 
func ( c * Cmd ) Stdin Pipe ( ) ( io . Write Closer , error ) { if c . Stdin ! = nil { return nil , errors . New ( " " ) } if c . Process ! = nil { return nil , errors . New ( " " ) } pr , pw , err : = os . Pipe ( ) if err ! = nil { return nil , err } c . Stdin = pr c . close After Start = append ( c . close After Start , pr ) wc : = & close Once { File : pw } c . close After Wait = append ( c . close After Wait , closer Func ( wc . safe Close ) ) return wc , nil } 
func ( c * close Once ) safe Close ( ) error { c . writers . Lock ( ) err : = c . Close ( ) c . writers . Unlock ( ) return err } 
func ( c * Cmd ) Stdout Pipe ( ) ( io . Read Closer , error ) { if c . Stdout ! = nil { return nil , errors . New ( " " ) } if c . Process ! = nil { return nil , errors . New ( " " ) } pr , pw , err : = os . Pipe ( ) if err ! = nil { return nil , err } c . Stdout = pw c . close After Start = append ( c . close After Start , pw ) c . close After Wait = append ( c . close After Wait , pr ) return pr , nil } 
func dedup Env Case ( case Insensitive bool , env [ ] string ) [ ] string { out : = make ( [ ] string , 0 , len ( env ) ) saw : = map [ string ] int { } for _ , kv : = range env { eq : = strings . Index ( kv , " " ) if eq < 0 { out = append ( out , kv ) continue } k : = kv [ : eq ] if case Insensitive { k = strings . To Lower ( k ) } if dup Idx , is Dup : = saw [ k ] ; is Dup { out [ dup Idx ] = kv continue } saw [ k ] = len ( out ) out = append ( out , kv ) } return out } 
func Visit Input ( input * Input , f func ( * Input ) ) { switch { case input = = nil : return case input . Cross ! = nil : for _ , input : = range input . Cross { Visit Input ( input , f ) } case input . Union ! = nil : for _ , input : = range input . Union { Visit Input ( input , f ) } } f ( input ) } 
func Input Name ( input * Input ) string { switch { case input = = nil : return " " case input . Pfs ! = nil : return input . Pfs . Name case input . Cross ! = nil : if len ( input . Cross ) > 0 { return Input Name ( input . Cross [ 0 ] ) } case input . Union ! = nil : if len ( input . Union ) > 0 { return Input Name ( input . Union [ 0 ] ) } } return " " } 
func Sort Input ( input * Input ) { Visit Input ( input , func ( input * Input ) { Sort Inputs : = func ( inputs [ ] * Input ) { sort . Slice Stable ( inputs , func ( i , j int ) bool { return Input Name ( inputs [ i ] ) < Input Name ( inputs [ j ] ) } ) } switch { case input . Cross ! = nil : Sort Inputs ( input . Cross ) case input . Union ! = nil : Sort Inputs ( input . Union ) } } ) } 
func Input Branches ( input * Input ) [ ] * pfs . Branch { var result [ ] * pfs . Branch Visit Input ( input , func ( input * Input ) { if input . Pfs ! = nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Pfs . Repo } , Name : input . Pfs . Branch , } ) } if input . Cron ! = nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Cron . Repo } , Name : " " , } ) } if input . Git ! = nil { result = append ( result , & pfs . Branch { Repo : & pfs . Repo { Name : input . Git . Name } , Name : input . Git . Branch , } ) } } ) return result } 
func Validate Git Clone URL ( url string ) error { example URL : = " " if url = = " " { return fmt . Errorf ( " " , example URL ) } if err : = o . Validate ( ) ; err ! = nil { return err } if ! strings . Has Suffix ( url , " " ) { } if ! strings . Has Prefix ( url , " " ) { } return nil } 
func contains Empty ( vals [ ] string ) bool { for _ , val : = range vals { if val = = " " { return true } } return false } 
func deploy Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command var opts * assets . Asset Opts var dry Run bool var output Format string var dev bool var host Path string deploy Local : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) ( ret Err error ) { metrics : = ! * no Metrics if metrics & & ! dev { start : = time . Now ( ) start Metrics Wait : = _metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = _metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } manifest : = get Encoder ( output Format ) if dev { } if err : = assets . Write Local Assets ( manifest , opts , host Path ) ; err ! = nil { return err } return kubectl Create ( dry Run , manifest , opts , metrics ) } ) , } deploy Local . Flags ( ) . String Var ( & host Path , " " , " " , " " ) deploy Local . Flags ( ) . Bool Var P ( & dev , " " , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( deploy Local , " " ) ) deploy Google : = & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on Google Cloud Platform . <bucket -name > : A Google Cloud Storage bucket where Pachyderm will store PFS data . <disk -size > : Size of Google Compute Engine persistent disks in GB (assumed to all be the same ) . <credentials -file > : A file containing the private key for the account (downloaded from Google Compute Engine ) . ` , Run : cmdutil . Run Bounded Args ( 2 , 3 , func ( args [ ] string ) ( ret Err error ) { metrics : = ! * no Metrics if metrics { start : = time . Now ( ) start Metrics Wait : = _metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = _metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } volume Size , err : = strconv . Atoi ( args [ 1 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 1 ] ) } manifest : = get Encoder ( output Format ) opts . Block Cache Size = " " var cred string if len ( args ) = = 3 { cred Bytes , err : = ioutil . Read File ( args [ 2 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 2 ] , err ) } cred = string ( cred Bytes ) } bucket : = strings . Trim Prefix ( args [ 0 ] , " " ) if err = assets . Write Google Assets ( manifest , opts , bucket , cred , volume Size ) ; err ! = nil { return err } return kubectl Create ( dry Run , manifest , opts , metrics ) } ) , } commands = append ( commands , cmdutil . Create Alias ( deploy Google , " " ) ) var object Store Backend string var persistent Disk Backend string var secure bool var is S 3V 2 bool deploy Custom : = & cobra . Command { Use : " " , Short : " " , Long : `Deploy a custom Pachyderm cluster configuration . If <object store backend > is \ "s 3 \ " , then the arguments are : <volumes > <size of volumes (in GB ) > <bucket > <id > <secret > <endpoint > ` , Run : cmdutil . Run Bounded Args ( 4 , 7 , func ( args [ ] string ) ( ret Err error ) { metrics : = ! * no Metrics if metrics { start : = time . Now ( ) start Metrics Wait : = _metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = _metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } manifest : = get Encoder ( output Format ) err : = assets . Write Custom Assets ( manifest , opts , args , object Store Backend , persistent Disk Backend , secure , is S 3V 2 ) if err ! = nil { return err } return kubectl Create ( dry Run , manifest , opts , metrics ) } ) , } deploy Custom . Flags ( ) . Bool Var P ( & secure , " " , " " , false , " " ) deploy Custom . Flags ( ) . String Var ( & persistent Disk Backend , " " , " " , " " + " " ) deploy Custom . Flags ( ) . String Var ( & object Store Backend , " " , " " , " " + " " ) deploy Custom . Flags ( ) . Bool Var ( & is S 3V 2 , " " , false , " " ) commands = append ( commands , cmdutil . Create Alias ( deploy Custom , " " ) ) var cloudfront Distribution string var creds string var iam Role string var vault string deploy Amazon : = & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on AWS . <bucket -name > : An S 3 bucket where Pachyderm will store PFS data . <region > : The AWS region where Pachyderm is being deployed (e .g . us -west - 1 ) <disk -size > : Size of EBS volumes , in GB (assumed to all be the same ) . ` , Run : cmdutil . Run Fixed Args ( 3 , func ( args [ ] string ) ( ret Err error ) { metrics : = ! * no Metrics if metrics { start : = time . Now ( ) start Metrics Wait : = _metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = _metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } if creds = = " " & & vault = = " " & & iam Role = = " " { return fmt . Errorf ( " " ) } s : = bufio . New Scanner ( os . Stdin ) if creds ! = " " { parts : = strings . Split ( creds , " " ) if len ( parts ) < 2 | | len ( parts ) > 3 | | contains Empty ( parts [ : 2 ] ) { return fmt . Errorf ( " " ) } amazon Creds = & assets . Amazon Creds { ID : parts [ 0 ] , Secret : parts [ 1 ] } if len ( parts ) > 2 { amazon Creds . Token = parts [ 2 ] } if ! aws Access Key IDRE . Match String ( amazon Creds . ID ) { fmt . Printf ( " " + " \n " , aws Access Key IDRE ) if s . Scan ( ) ; s . Text ( ) [ 0 ] ! = 'y ' & & s . Text ( ) [ 0 ] ! = 'Y ' { os . Exit ( 1 ) } } if ! aws Secret RE . Match String ( amazon Creds . Secret ) { fmt . Printf ( " " + " \n " , aws Secret RE ) if s . Scan ( ) ; s . Text ( ) [ 0 ] ! = 'y ' & & s . Text ( ) [ 0 ] ! = 'Y ' { os . Exit ( 1 ) } } } if vault ! = " " { if amazon Creds ! = nil { return fmt . Errorf ( " " ) } parts : = strings . Split ( vault , " " ) if len ( parts ) ! = 3 | | contains Empty ( parts ) { return fmt . Errorf ( " " ) } amazon Creds = & assets . Amazon Creds { Vault Address : parts [ 0 ] , Vault Role : parts [ 1 ] , Vault Token : parts [ 2 ] } } if iam Role ! = " " { if amazon Creds ! = nil { return fmt . Errorf ( " " ) } opts . IAMRole = iam Role } volume Size , err : = strconv . Atoi ( args [ 2 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 2 ] ) } if strings . Trim Space ( cloudfront Distribution ) ! = " " { fmt . Printf ( " " + " \n " ) } bucket , region : = strings . Trim Prefix ( args [ 0 ] , " " ) , args [ 1 ] if ! aws Region RE . Match String ( region ) { fmt . Printf ( " " + " \n " , aws Region RE ) if s . Scan ( ) ; s . Text ( ) [ 0 ] ! = 'y ' & & s . Text ( ) [ 0 ] ! = 'Y ' { os . Exit ( 1 ) } } if err = assets . Write Amazon Assets ( manifest , opts , region , bucket , volume Size , amazon Creds , cloudfront Distribution ) ; err ! = nil { return err } return kubectl Create ( dry Run , manifest , opts , metrics ) } ) , } deploy Amazon . Flags ( ) . String Var ( & cloudfront Distribution , " " , " " , " " + " " + " " ) deploy Amazon . Flags ( ) . String Var ( & creds , " " , " " , " \ " \ " \ " \ " " ) deploy Amazon . Flags ( ) . String Var ( & vault , " " , " " , " \ " \ " " ) deploy Amazon . Flags ( ) . String Var ( & iam Role , " " , " " , fmt . Sprintf ( " " , assets . IAMAnnotation ) ) commands = append ( commands , cmdutil . Create Alias ( deploy Amazon , " " ) ) deploy Microsoft : = & cobra . Command { Use : " " , Short : " " , Long : `Deploy a Pachyderm cluster running on Microsoft Azure . <container > : An Azure container where Pachyderm will store PFS data . <disk -size > : Size of persistent volumes , in GB (assumed to all be the same ) . ` , Run : cmdutil . Run Fixed Args ( 4 , func ( args [ ] string ) ( ret Err error ) { metrics : = ! * no Metrics if metrics { start : = time . Now ( ) start Metrics Wait : = _metrics . Start Report And Flush User Action ( " " , start ) defer start Metrics Wait ( ) defer func ( ) { finish Metrics Wait : = _metrics . Finish Report And Flush User Action ( " " , ret Err , start ) finish Metrics Wait ( ) } ( ) } if _ , err : = base 6 4 . Std Encoding . Decode String ( args [ 2 ] ) ; err ! = nil { return fmt . Errorf ( " " , args [ 2 ] ) } if opts . Etcd Volume ! = " " { temp URI , err : = url . Parse Request URI ( opts . Etcd Volume ) if err ! = nil { return fmt . Errorf ( " " , opts . Etcd Volume ) } opts . Etcd Volume = temp URI . String ( ) } volume Size , err : = strconv . Atoi ( args [ 3 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 3 ] ) } manifest : = get Encoder ( output Format ) container : = strings . Trim Prefix ( args [ 0 ] , " " ) account Name , account Key : = args [ 1 ] , args [ 2 ] if err = assets . Write Microsoft Assets ( manifest , opts , container , account Name , account Key , volume Size ) ; err ! = nil { return err } return kubectl Create ( dry Run , manifest , opts , metrics ) } ) , } commands = append ( commands , cmdutil . Create Alias ( deploy Microsoft , " " ) ) deploy Storage Secrets : = func ( data map [ string ] [ ] byte ) error { c , err : = client . New On User Machine ( ! * no Metrics , ! * no Port Forwarding , " " ) if err ! = nil { return fmt . Errorf ( " " , err ) } defer c . Close ( ) _ , err = c . Deploy Storage Secret ( context . Background ( ) , & deployclient . Deploy Storage Secret Request { Secrets : data , } ) if err ! = nil { return fmt . Errorf ( " " , err ) } return nil } deploy Storage Amazon : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Bounded Args ( 3 , 4 , func ( args [ ] string ) error { var token string if len ( args ) = = 4 { token = args [ 3 ] } return deploy Storage Secrets ( assets . Amazon Secret ( args [ 0 ] , " " , args [ 1 ] , args [ 2 ] , token , " " ) ) } ) , } commands = append ( commands , cmdutil . Create Alias ( deploy Storage Amazon , " " ) ) deploy Storage Google : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) error { cred Bytes , err : = ioutil . Read File ( args [ 0 ] ) if err ! = nil { return fmt . Errorf ( " " , args [ 0 ] , err ) } return deploy Storage Secrets ( assets . Google Secret ( " " , string ( cred Bytes ) ) ) } ) , } commands = append ( commands , cmdutil . Create Alias ( deploy Storage Google , " " ) ) deploy Storage Azure : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 2 , func ( args [ ] string ) error { return deploy Storage Secrets ( assets . Microsoft Secret ( " " , args [ 0 ] , args [ 1 ] ) ) } ) , } commands = append ( commands , cmdutil . Create Alias ( deploy Storage Azure , " " ) ) deploy Storage : = & cobra . Command { Short : " " , Long : " " , } commands = append ( commands , cmdutil . Create Alias ( deploy Storage , " " ) ) list Images : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { for _ , image : = range assets . Images ( opts ) { fmt . Println ( image ) } return nil } ) , } commands = append ( commands , cmdutil . Create Alias ( list Images , " " ) ) export Images : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) ( ret Err error ) { file , err : = os . Create ( args [ 0 ] ) if err ! = nil { return err } defer func ( ) { if err : = file . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return images . Export ( opts , file ) } ) , } commands = append ( commands , cmdutil . Create Alias ( export Images , " " ) ) import Images : = & cobra . Command { Use : " " , Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 1 , func ( args [ ] string ) ( ret Err error ) { file , err : = os . Open ( args [ 0 ] ) if err ! = nil { return err } defer func ( ) { if err : = file . Close ( ) ; err ! = nil & & ret Err = = nil { ret Err = err } } ( ) return images . Import ( opts , file ) } ) , } commands = append ( commands , cmdutil . Create Alias ( import Images , " " ) ) var block Cache Size string var dash Image string var dash Only bool var etcd CPURequest string var etcd Mem Request string var etcd Nodes int var etcd Storage Class Name string var etcd Volume string var expose Object API bool var image Pull Secret string var local Roles bool var log Level string var namespace string var new Hash Tree bool var no Dash bool var no Expose Docker Socket bool var no Guaranteed bool var no RBAC bool var pachd CPURequest string var pachd Non Cache Mem Request string var pachd Shards int var registry string var tls Cert Key string deploy : = & cobra . Command { Short : " " , Long : " " , Persistent Pre Run : cmdutil . Run ( func ( [ ] string ) error { dash Image = get Default Or Latest Dash Image ( dash Image , dry Run ) opts = & assets . Asset Opts { Feature Flags : assets . Feature Flags { New Hash Tree : new Hash Tree , } , Pachd Shards : uint 6 4 ( pachd Shards ) , Version : version . Pretty Print Version ( version . Version ) , Log Level : log Level , Metrics : ! * no Metrics , Pachd CPURequest : pachd CPURequest , Pachd Non Cache Mem Request : pachd Non Cache Mem Request , Block Cache Size : block Cache Size , Etcd CPURequest : etcd CPURequest , Etcd Mem Request : etcd Mem Request , Etcd Nodes : etcd Nodes , Etcd Volume : etcd Volume , Etcd Storage Class Name : etcd Storage Class Name , Dash Only : dash Only , No Dash : no Dash , Dash Image : dash Image , Registry : registry , Image Pull Secret : image Pull Secret , No Guaranteed : no Guaranteed , No RBAC : no RBAC , Local Roles : local Roles , Namespace : namespace , No Expose Docker Socket : no Expose Docker Socket , Expose Object API : expose Object API , } if tls Cert Key ! = " " { if len ( cert Key ) ! = 2 { return fmt . Errorf ( " " , cert Key ) } opts . TLS = & assets . TLSOpts { Server Cert : cert Key [ 0 ] , Server Key : cert Key [ 1 ] , } } return nil } ) , } deploy . Persistent Flags ( ) . Int Var ( & pachd Shards , " " , 1 6 , " " ) deploy . Persistent Flags ( ) . Int Var ( & etcd Nodes , " " , 0 , " " ) deploy . Persistent Flags ( ) . String Var ( & etcd Volume , " " , " " , " " ) deploy . Persistent Flags ( ) . String Var ( & etcd Storage Class Name , " " , " " , " " ) deploy . Persistent Flags ( ) . Bool Var ( & dry Run , " " , false , " " ) deploy . Persistent Flags ( ) . String Var P ( & output Format , " " , " " , " " , " " ) deploy . Persistent Flags ( ) . String Var ( & log Level , " " , " " , " \ " \ " \ " \ " \ " \ " " ) deploy . Persistent Flags ( ) . Bool Var ( & dash Only , " " , false , " \ " \ " " ) deploy . Persistent Flags ( ) . Bool Var ( & no Dash , " " , false , " " ) deploy . Persistent Flags ( ) . String Var ( & registry , " " , " " , " " ) deploy . Persistent Flags ( ) . String Var ( & image Pull Secret , " " , " " , " " ) deploy . Persistent Flags ( ) . String Var ( & dash Image , " " , " " , " " ) deploy . Persistent Flags ( ) . Bool Var ( & no Guaranteed , " " , false , " " ) deploy . Persistent Flags ( ) . Bool Var ( & no RBAC , " " , false , " " ) deploy . Persistent Flags ( ) . Bool Var ( & local Roles , " " , false , " " ) deploy . Persistent Flags ( ) . String Var ( & namespace , " " , " " , " " ) deploy . Persistent Flags ( ) . Bool Var ( & no Expose Docker Socket , " " , false , " " ) deploy . Persistent Flags ( ) . Bool Var ( & expose Object API , " " , false , " " ) deploy . Persistent Flags ( ) . String Var ( & tls Cert Key , " " , " " , " \ " \ " " ) deploy . Persistent Flags ( ) . Bool Var ( & new Hash Tree , " " , false , " " ) deploy . Persistent Flags ( ) . String Var ( & block Cache Size , " " , " " , " " + " " ) deploy . Persistent Flags ( ) . String Var ( & pachd Non Cache Mem Request , " " , " " , " " + " " + " " ) deploy . Persistent Flags ( ) . String Var ( & etcd CPURequest , " " , " " , " " + " " + " " ) deploy . Persistent Flags ( ) . String Var ( & etcd Mem Request , " " , " " , " " + " " + " " ) commands = append ( commands , cmdutil . Create Alias ( deploy , " " ) ) return commands } 
func Cmds ( no Metrics * bool , no Port Forwarding * bool ) [ ] * cobra . Command { var commands [ ] * cobra . Command commands = append ( commands , deploy Cmds ( no Metrics , no Port Forwarding ) . . . ) var all bool var namespace string undeploy : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { if all { fmt . Printf ( ` By using the - -all flag , you are going to delete everything , including the persistent volumes where metadata is stored . If your persistent volumes were dynamically provisioned (i .e . if you used the " - -dynamic -etcd -nodes " flag ) , the underlying volumes will be removed , making metadata such repos , commits , pipelines , and jobs unrecoverable . If your persistent volume was manually provisioned (i .e . if you used the " - -static -etcd -volume " flag ) , the underlying volume will not be removed . ` ) } fmt . Println ( " " ) r : = bufio . New Reader ( os . Stdin ) bytes , err : = r . Read Bytes ( ' \n ' ) if err ! = nil { return err } if bytes [ 0 ] = = 'y ' | | bytes [ 0 ] = = 'Y ' { io : = cmdutil . IO { Stdout : os . Stdout , Stderr : os . Stderr , } assets : = [ ] string { " " , " " , " " , " " , " " , " " , " " , " " , } if all { assets = append ( assets , [ ] string { " " , " " , " " , } . . . ) } for _ , asset : = range assets { if err : = cmdutil . Run IO ( io , " " , " " , asset , " " , " " , " " , namespace ) ; err ! = nil { return err } } } return nil } ) , } undeploy . Flags ( ) . Bool Var P ( & all , " " , " " , false , ` Delete everything , including the persistent volumes where metadata is stored . If your persistent volumes were dynamically provisioned (i .e . if you used the " - -dynamic -etcd -nodes " flag ) , the underlying volumes will be removed , making metadata such repos , commits , pipelines , and jobs unrecoverable . If your persistent volume was manually provisioned (i .e . if you used the " - -static -etcd -volume " flag ) , the underlying volume will not be removed . ` ) undeploy . Flags ( ) . String Var ( & namespace , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( undeploy , " " ) ) var update Dash Dry Run bool var update Dash Output Format string update Dash : = & cobra . Command { Short : " " , Long : " " , Run : cmdutil . Run Fixed Args ( 0 , func ( args [ ] string ) error { if err : = cmdutil . Run IO ( io , " " , " " , " " , " " , " " ) ; err ! = nil { return err } if err : = cmdutil . Run IO ( io , " " , " " , " " , " " , " " ) ; err ! = nil { return err } } opts : = & assets . Asset Opts { Dash Only : true , Dash Image : get Default Or Latest Dash Image ( " " , update Dash Dry Run ) , } assets . Write Dashboard Assets ( manifest , opts ) return kubectl Create ( update Dash Dry Run , manifest , opts , false ) } ) , } update Dash . Flags ( ) . Bool Var ( & update Dash Dry Run , " " , false , " " ) update Dash . Flags ( ) . String Var P ( & update Dash Output Format , " " , " " , " " , " " ) commands = append ( commands , cmdutil . Create Alias ( update Dash , " " ) ) return commands } 
func Main ( do func ( interface { } ) error , app Env interface { } , decoders . . . Decoder ) { if err : = Populate ( app Env , decoders . . . ) ; err ! = nil { main Error ( err ) } if err : = do ( app Env ) ; err ! = nil { main Error ( err ) } os . Exit ( 0 ) } 
func New APIServer ( address string , storage Root string , cluster Info * admin . Cluster Info ) APIServer { return & api Server { Logger : log . New Logger ( " " ) , address : address , storage Root : storage Root , cluster Info : cluster Info , } } 
func Unescape HTML ( s string ) string { s = strings . Replace ( s , " \ \ " , " " , - 1 ) s = strings . Replace ( s , " \ \ " , " " , - 1 ) return s } 
func Ago ( timestamp * types . Timestamp ) string { t , _ : = types . Timestamp From Proto ( timestamp ) if t . Equal ( time . Time { } ) { return " " } return fmt . Sprintf ( " " , units . Human Duration ( time . Since ( t ) ) ) } 
func Time Difference ( from * types . Timestamp , to * types . Timestamp ) string { t From , _ : = types . Timestamp From Proto ( from ) t To , _ : = types . Timestamp From Proto ( to ) return units . Human Duration ( t To . Sub ( t From ) ) } 
func Duration ( d * types . Duration ) string { duration , _ : = types . Duration From Proto ( d ) return units . Human Duration ( duration ) } 
func ( c APIClient ) Inspect Cluster ( ) ( * admin . Cluster Info , error ) { cluster Info , err : = c . Admin APIClient . Inspect Cluster ( c . Ctx ( ) , & types . Empty { } ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } return cluster Info , nil } 
func ( c APIClient ) Extract ( objects bool , f func ( op * admin . Op ) error ) error { extract Client , err : = c . Admin APIClient . Extract ( c . Ctx ( ) , & admin . Extract Request { No Objects : ! objects } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } for { op , err : = extract Client . Recv ( ) if err = = io . EOF { break } if err ! = nil { return grpcutil . Scrub GRPC ( err ) } if err : = f ( op ) ; err ! = nil { return err } } return nil } 
func ( c APIClient ) Extract All ( objects bool ) ( [ ] * admin . Op , error ) { var result [ ] * admin . Op if err : = c . Extract ( objects , func ( op * admin . Op ) error { result = append ( result , op ) return nil } ) ; err ! = nil { return nil , err } return result , nil } 
func ( c APIClient ) Extract Writer ( objects bool , w io . Writer ) error { writer : = pbutil . New Writer ( w ) return c . Extract ( objects , func ( op * admin . Op ) error { _ , err : = writer . Write ( op ) return err } ) } 
func ( c APIClient ) Extract URL ( url string ) error { extract Client , err : = c . Admin APIClient . Extract ( c . Ctx ( ) , & admin . Extract Request { URL : url } ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } resp , err : = extract Client . Recv ( ) if err = = nil { return fmt . Errorf ( " " , resp ) } if err ! = io . EOF { return err } return nil } 
func ( c APIClient ) Extract Pipeline ( pipeline Name string ) ( * pps . Create Pipeline Request , error ) { op , err : = c . Admin APIClient . Extract Pipeline ( c . Ctx ( ) , & admin . Extract Pipeline Request { Pipeline : New Pipeline ( pipeline Name ) } ) if err ! = nil { return nil , grpcutil . Scrub GRPC ( err ) } if op . Op 1 _ 9 = = nil | | op . Op 1 _ 9 . Pipeline = = nil { return nil , fmt . Errorf ( " " ) } return op . Op 1 _ 9 . Pipeline , nil } 
func ( c APIClient ) Restore ( ops [ ] * admin . Op ) ( ret Err error ) { restore Client , err : = c . Admin APIClient . Restore ( c . Ctx ( ) ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } defer func ( ) { if _ , err : = restore Client . Close And Recv ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } } ( ) for _ , op : = range ops { if err : = restore Client . Send ( & admin . Restore Request { Op : op } ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } } return nil } 
func ( c APIClient ) Restore Reader ( r io . Reader ) ( ret Err error ) { restore Client , err : = c . Admin APIClient . Restore ( c . Ctx ( ) ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } defer func ( ) { if _ , err : = restore Client . Close And Recv ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } } ( ) reader : = pbutil . New Reader ( r ) op : = & admin . Op { } for { if err : = reader . Read ( op ) ; err ! = nil { if err = = io . EOF { break } return err } if err : = restore Client . Send ( & admin . Restore Request { Op : op } ) ; err ! = nil { return grpcutil . Scrub GRPC ( err ) } } return nil } 
func ( c APIClient ) Restore From ( objects bool , other C * APIClient ) ( ret Err error ) { restore Client , err : = c . Admin APIClient . Restore ( c . Ctx ( ) ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } defer func ( ) { if _ , err : = restore Client . Close And Recv ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } } ( ) return other C . Extract ( objects , func ( op * admin . Op ) error { return restore Client . Send ( & admin . Restore Request { Op : op } ) } ) } 
func ( c APIClient ) Restore URL ( url string ) ( ret Err error ) { restore Client , err : = c . Admin APIClient . Restore ( c . Ctx ( ) ) if err ! = nil { return grpcutil . Scrub GRPC ( err ) } defer func ( ) { if _ , err : = restore Client . Close And Recv ( ) ; err ! = nil & & ret Err = = nil { ret Err = grpcutil . Scrub GRPC ( err ) } } ( ) return grpcutil . Scrub GRPC ( restore Client . Send ( & admin . Restore Request { URL : url } ) ) } 
func New Evaluable Expression ( expression string ) ( * Evaluable Expression , error ) { functions : = make ( map [ string ] Expression Function ) return New Evaluable Expression With Functions ( expression , functions ) } 
func New Evaluable Expression From Tokens ( tokens [ ] Expression Token ) ( * Evaluable Expression , error ) { var ret * Evaluable Expression var err error ret = new ( Evaluable Expression ) ret . Query Date Format = iso Date Format err = check Balance ( tokens ) if err ! = nil { return nil , err } err = check Expression Syntax ( tokens ) if err ! = nil { return nil , err } ret . tokens , err = optimize Tokens ( tokens ) if err ! = nil { return nil , err } ret . evaluation Stages , err = plan Stages ( ret . tokens ) if err ! = nil { return nil , err } ret . Checks Types = true return ret , nil } 
func New Evaluable Expression With Functions ( expression string , functions map [ string ] Expression Function ) ( * Evaluable Expression , error ) { var ret * Evaluable Expression var err error ret = new ( Evaluable Expression ) ret . Query Date Format = iso Date Format ret . input Expression = expression ret . tokens , err = parse Tokens ( expression , functions ) if err ! = nil { return nil , err } err = check Balance ( ret . tokens ) if err ! = nil { return nil , err } err = check Expression Syntax ( ret . tokens ) if err ! = nil { return nil , err } ret . tokens , err = optimize Tokens ( ret . tokens ) if err ! = nil { return nil , err } ret . evaluation Stages , err = plan Stages ( ret . tokens ) if err ! = nil { return nil , err } ret . Checks Types = true return ret , nil } 
func ( this Evaluable Expression ) Evaluate ( parameters map [ string ] interface { } ) ( interface { } , error ) { if parameters = = nil { return this . Eval ( nil ) } return this . Eval ( Map Parameters ( parameters ) ) } 
func ( this Evaluable Expression ) Eval ( parameters Parameters ) ( interface { } , error ) { if this . evaluation Stages = = nil { return nil , nil } if parameters ! = nil { parameters = & sanitized Parameters { parameters } } else { parameters = DUMMY _PARAMETERS } return this . evaluate Stage ( this . evaluation Stages , parameters ) } 
func ( this Evaluable Expression ) Vars ( ) [ ] string { var varlist [ ] string for _ , val : = range this . Tokens ( ) { if val . Kind = = VARIABLE { varlist = append ( varlist , val . Value . ( string ) ) } } return varlist } 
func ( this Operator Symbol ) Is Modifier Type ( candidate [ ] Operator Symbol ) bool { for _ , symbol Type : = range candidate { if this = = symbol Type { return true } } return false } 
func ( this Operator Symbol ) String ( ) string { switch this { case NOOP : return " " case VALUE : return " " case EQ : return " " case NEQ : return " " case GT : return " " case LT : return " " case GTE : return " " case LTE : return " " case REQ : return " " case NREQ : return " " case AND : return " " case OR : return " " case IN : return " " case BITWISE _AND : return " " case BITWISE _OR : return " " case BITWISE _XOR : return " " case BITWISE _LSHIFT : return " " case BITWISE _RSHIFT : return " " case PLUS : return " " case MINUS : return " " case MULTIPLY : return " " case DIVIDE : return " " case MODULUS : return " " case EXPONENT : return " " case NEGATE : return " " case INVERT : return " " case BITWISE _NOT : return " " case TERNARY _TRUE : return " " case TERNARY _FALSE : return " " case COALESCE : return " " } return " " } 
func ( this Evaluable Expression ) To SQLQuery ( ) ( string , error ) { var stream * token Stream var transactions * expression Output Stream var transaction string var err error stream = new Token Stream ( this . tokens ) transactions = new ( expression Output Stream ) for stream . has Next ( ) { transaction , err = this . find Next SQLString ( stream , transactions ) if err ! = nil { return " " , err } transactions . add ( transaction ) } return transactions . create String ( " " ) , nil } 
func ( kind Token Kind ) String ( ) string { switch kind { case PREFIX : return " " case NUMERIC : return " " case BOOLEAN : return " " case STRING : return " " case PATTERN : return " " case TIME : return " " case VARIABLE : return " " case FUNCTION : return " " case SEPARATOR : return " " case COMPARATOR : return " " case LOGICALOP : return " " case MODIFIER : return " " case CLAUSE : return " " case CLAUSE _CLOSE : return " " case TERNARY : return " " case ACCESSOR : return " " } return " " } 
func read Until False ( stream * lexer Stream , include Whitespace bool , break Whitespace bool , allow Escaping bool , condition func ( rune ) bool ) ( string , bool ) { var token Buffer bytes . Buffer var character rune var conditioned bool conditioned = false for stream . can Read ( ) { character = stream . read Character ( ) token Buffer . Write String ( string ( character ) ) continue } if unicode . Is Space ( character ) { if break Whitespace & & token Buffer . Len ( ) > 0 { conditioned = true break } if ! include Whitespace { continue } } if condition ( character ) { token Buffer . Write String ( string ( character ) ) } else { conditioned = true stream . rewind ( 1 ) break } } return token Buffer . String ( ) , conditioned } 
func optimize Tokens ( tokens [ ] Expression Token ) ( [ ] Expression Token , error ) { var token Expression Token var symbol Operator Symbol var err error var index int for index , token = range tokens { } symbol = comparator Symbols [ token . Value . ( string ) ] if symbol ! = REQ & & symbol ! = NREQ { continue } index + + token = tokens [ index ] if token . Kind = = STRING { token . Kind = PATTERN token . Value , err = regexp . Compile ( token . Value . ( string ) ) if err ! = nil { return tokens , err } tokens [ index ] = token } } return tokens , nil } 
func check Balance ( tokens [ ] Expression Token ) error { var stream * token Stream var token Expression Token var parens int stream = new Token Stream ( tokens ) for stream . has Next ( ) { token = stream . next ( ) if token . Kind = = CLAUSE { parens + + continue } if token . Kind = = CLAUSE _CLOSE { parens - - continue } } if parens ! = 0 { return errors . New ( " " ) } return nil } 
func try Parse Time ( candidate string ) ( time . Time , bool ) { var ret time . Time var found bool time Formats : = [ . . . ] string { time . ANSIC , time . Unix Date , time . Ruby Date , time . Kitchen , time . RFC 3 3 3 9 , time . RFC 3 3 3 9Nano , " " , for _ , format : = range time Formats { ret , found = try Parse Exact Time ( candidate , format ) if found { return ret , true } } return time . Now ( ) , false } 
func make Precedent From Planner ( planner * precedence Planner ) precedent { var generated precedent var next Right precedent generated = func ( stream * token Stream ) ( * evaluation Stage , error ) { return plan Precedence Level ( stream , planner . type Error Format , planner . valid Symbols , planner . valid Kinds , next Right , planner . next , ) } if planner . next Right ! = nil { next Right = planner . next Right } else { next Right = generated } return generated } 
func plan Stages ( tokens [ ] Expression Token ) ( * evaluation Stage , error ) { stream : = new Token Stream ( tokens ) stage , err : = plan Tokens ( stream ) if err ! = nil { return nil , err } stage = elide Literals ( stage ) return stage , nil } 
func plan Precedence Level ( stream * token Stream , type Error Format string , valid Symbols map [ string ] Operator Symbol , valid Kinds [ ] Token Kind , right Precedent precedent , left Precedent precedent ) ( * evaluation Stage , error ) { var token Expression Token var symbol Operator Symbol var left Stage , right Stage * evaluation Stage var checks type Checks var err error var key Found bool if left Precedent ! = nil { left Stage , err = left Precedent ( stream ) if err ! = nil { return nil , err } } for stream . has Next ( ) { token = stream . next ( ) if len ( valid Kinds ) > 0 { key Found = false for _ , kind : = range valid Kinds { if kind = = token . Kind { key Found = true break } } if ! key Found { break } } if valid Symbols ! = nil { if ! is String ( token . Value ) { break } symbol , key Found = valid Symbols [ token . Value . ( string ) ] if ! key Found { break } } if right Precedent ! = nil { right Stage , err = right Precedent ( stream ) if err ! = nil { return nil , err } } checks = find Type Checks ( symbol ) return & evaluation Stage { symbol : symbol , left Stage : left Stage , right Stage : right Stage , operator : stage Symbol Map [ symbol ] , left Type Check : checks . left , right Type Check : checks . right , type Check : checks . combined , type Error Format : type Error Format , } , nil } stream . rewind ( ) return left Stage , nil } 
func plan Function ( stream * token Stream ) ( * evaluation Stage , error ) { var token Expression Token var right Stage * evaluation Stage var err error token = stream . next ( ) if token . Kind ! = FUNCTION { stream . rewind ( ) return plan Accessor ( stream ) } right Stage , err = plan Accessor ( stream ) if err ! = nil { return nil , err } return & evaluation Stage { symbol : FUNCTIONAL , right Stage : right Stage , operator : make Function Stage ( token . Value . ( Expression Function ) ) , type Error Format : " " , } , nil } 
func plan Value ( stream * token Stream ) ( * evaluation Stage , error ) { var token Expression Token var symbol Operator Symbol var ret * evaluation Stage var operator evaluation Operator var err error if ! stream . has Next ( ) { return nil , nil } token = stream . next ( ) switch token . Kind { case CLAUSE : ret , err = plan Tokens ( stream ) if err ! = nil { return nil , err } return ret , nil case CLAUSE _CLOSE : return nil , nil case VARIABLE : operator = make Parameter Stage ( token . Value . ( string ) ) case NUMERIC : fallthrough case STRING : fallthrough case PATTERN : fallthrough case BOOLEAN : symbol = LITERAL operator = make Literal Stage ( token . Value ) case TIME : symbol = LITERAL operator = make Literal Stage ( float 6 4 ( token . Value . ( time . Time ) . Unix ( ) ) ) case PREFIX : stream . rewind ( ) return plan Prefix ( stream ) } if operator = = nil { error Msg : = fmt . Sprintf ( " " , token . Kind . String ( ) , token . Value ) return nil , errors . New ( error Msg ) } return & evaluation Stage { symbol : symbol , operator : operator , } , nil } 
func find Type Checks ( symbol Operator Symbol ) type Checks { switch symbol { case GT : fallthrough case LT : fallthrough case GTE : fallthrough case LTE : return type Checks { combined : comparator Type Check , } case REQ : fallthrough case NREQ : return type Checks { left : is String , right : is Regex Or String , } case AND : fallthrough case OR : return type Checks { left : is Bool , right : is Bool , } case IN : return type Checks { right : is Array , } case BITWISE _LSHIFT : fallthrough case BITWISE _RSHIFT : fallthrough case BITWISE _OR : fallthrough case BITWISE _AND : fallthrough case BITWISE _XOR : return type Checks { left : is Float 6 4 , right : is Float 6 4 , } case PLUS : return type Checks { combined : addition Type Check , } case MINUS : fallthrough case MULTIPLY : fallthrough case DIVIDE : fallthrough case MODULUS : fallthrough case EXPONENT : return type Checks { left : is Float 6 4 , right : is Float 6 4 , } case NEGATE : return type Checks { right : is Float 6 4 , } case INVERT : return type Checks { right : is Bool , } case BITWISE _NOT : return type Checks { right : is Float 6 4 , } case TERNARY _TRUE : return type Checks { left : is Bool , } case NEQ : return type Checks { } case TERNARY _FALSE : fallthrough case COALESCE : fallthrough default : return type Checks { } } } 
func reorder Stages ( root Stage * evaluation Stage ) { var current Stage , next Stage * evaluation Stage var precedence , current Precedence operator Precedence next Stage = root Stage precedence = find Operator Precedence For Symbol ( root Stage . symbol ) for next Stage ! = nil { current Stage = next Stage next Stage = current Stage . right Stage } current Precedence = find Operator Precedence For Symbol ( current Stage . symbol ) if current Precedence = = precedence { identical Precedences = append ( identical Precedences , current Stage ) continue } } identical Precedences = [ ] * evaluation Stage { current Stage } precedence = current Precedence } if len ( identical Precedences ) > 1 { mirror Stage Subtree ( identical Precedences ) } } 
func mirror Stage Subtree ( stages [ ] * evaluation Stage ) { var root Stage , inverse Stage , carry Stage , front Stage * evaluation Stage stages Length : = len ( stages ) front Stage . right Stage = front Stage . left Stage front Stage . left Stage = carry Stage } front Stage = stages [ stages Length - 1 ] carry Stage = front Stage . left Stage front Stage . left Stage = root Stage . right Stage root Stage . right Stage = carry Stage inverse Stage = stages [ stages Length - i - 1 ] carry Stage = front Stage . right Stage front Stage . right Stage = inverse Stage . right Stage inverse Stage . right Stage = carry Stage } inverse Stage = stages [ stages Length - i - 1 ] front Stage . swap With ( inverse Stage ) } } 
func elide Literals ( root * evaluation Stage ) * evaluation Stage { if root . left Stage ! = nil { root . left Stage = elide Literals ( root . left Stage ) } if root . right Stage ! = nil { root . right Stage = elide Literals ( root . right Stage ) } return elide Stage ( root ) } 
func elide Stage ( root * evaluation Stage ) * evaluation Stage { var left Value , right Value , result interface { } var err error } case IN : return root } if err ! = nil { return root } right Value , err = root . right Stage . operator ( nil , nil , nil ) if err ! = nil { return root } if err ! = nil { return root } err = type Check ( root . right Type Check , right Value , root . symbol , root . type Error Format ) if err ! = nil { return root } if root . type Check ! = nil & & ! root . type Check ( left Value , right Value ) { return root } if err ! = nil { return root } return & evaluation Stage { symbol : LITERAL , operator : make Literal Stage ( result ) , } } 
func addition Type Check ( left interface { } , right interface { } ) bool { if is Float 6 4 ( left ) & & is Float 6 4 ( right ) { return true } if ! is String ( left ) & & ! is String ( right ) { return false } return true } 
func comparator Type Check ( left interface { } , right interface { } ) bool { if is Float 6 4 ( left ) & & is Float 6 4 ( right ) { return true } if is String ( left ) & & is String ( right ) { return true } return false } 
func Ignore Fields ( typ interface { } , names . . . string ) cmp . Option { sf : = new Struct Filter ( typ , names . . . ) return cmp . Filter Path ( sf . filter , cmp . Ignore ( ) ) } 
func Ignore Types ( typs . . . interface { } ) cmp . Option { tf : = new Type Filter ( typs . . . ) return cmp . Filter Path ( tf . filter , cmp . Ignore ( ) ) } 
func Ignore Interfaces ( ifaces interface { } ) cmp . Option { tf : = new Iface Filter ( ifaces ) return cmp . Filter Path ( tf . filter , cmp . Ignore ( ) ) } 
func Ignore Unexported ( typs . . . interface { } ) cmp . Option { ux : = new Unexported Filter ( typs . . . ) return cmp . Filter Path ( ux . filter , cmp . Ignore ( ) ) } 
func Ignore Slice Elements ( discard Func interface { } ) cmp . Option { vf : = reflect . Value Of ( discard Func ) if ! function . Is Type ( vf . Type ( ) , function . Value Predicate ) | | vf . Is Nil ( ) { panic ( fmt . Sprintf ( " " , discard Func ) ) } return cmp . Filter Path ( func ( p cmp . Path ) bool { si , ok : = p . Index ( - 1 ) . ( cmp . Slice Index ) if ! ok { return false } if ! si . Type ( ) . Assignable To ( vf . Type ( ) . In ( 0 ) ) { return false } vx , vy : = si . Values ( ) if vx . Is Valid ( ) & & vf . Call ( [ ] reflect . Value { vx } ) [ 0 ] . Bool ( ) { return true } if vy . Is Valid ( ) & & vf . Call ( [ ] reflect . Value { vy } ) [ 0 ] . Bool ( ) { return true } return false } , cmp . Ignore ( ) ) } 
func Ignore Map Entries ( discard Func interface { } ) cmp . Option { vf : = reflect . Value Of ( discard Func ) if ! function . Is Type ( vf . Type ( ) , function . Key Value Predicate ) | | vf . Is Nil ( ) { panic ( fmt . Sprintf ( " " , discard Func ) ) } return cmp . Filter Path ( func ( p cmp . Path ) bool { mi , ok : = p . Index ( - 1 ) . ( cmp . Map Index ) if ! ok { return false } if ! mi . Key ( ) . Type ( ) . Assignable To ( vf . Type ( ) . In ( 0 ) ) | | ! mi . Type ( ) . Assignable To ( vf . Type ( ) . In ( 1 ) ) { return false } k : = mi . Key ( ) vx , vy : = mi . Values ( ) if vx . Is Valid ( ) & & vf . Call ( [ ] reflect . Value { k , vx } ) [ 0 ] . Bool ( ) { return true } if vy . Is Valid ( ) & & vf . Call ( [ ] reflect . Value { k , vy } ) [ 0 ] . Bool ( ) { return true } return false } , cmp . Ignore ( ) ) } 
func ( s * text List ) Append Ellipsis ( ds diff Stats ) { has Stats : = ds ! = diff Stats { } if len ( * s ) = = 0 | | ! ( * s ) [ len ( * s ) - 1 ] . Value . Equal ( text Ellipsis ) { if has Stats { * s = append ( * s , text Record { Value : text Ellipsis , Comment : ds } ) } else { * s = append ( * s , text Record { Value : text Ellipsis } ) } return } if has Stats { ( * s ) [ len ( * s ) - 1 ] . Comment = ( * s ) [ len ( * s ) - 1 ] . Comment . ( diff Stats ) . Append ( ds ) } } 
func ( s diff Stats ) String ( ) string { var ss [ ] string var sum int labels : = [ . . . ] string { " " , " " , " " , " " , " " } counts : = [ . . . ] int { s . Num Ignored , s . Num Identical , s . Num Removed , s . Num Inserted , s . Num Modified } for i , n : = range counts { if n > 0 { ss = append ( ss , fmt . Sprintf ( " " , n , labels [ i ] ) ) } sum + = n } if sum > 1 { name = name + " " if strings . Has Suffix ( name , " " ) { name = name [ : len ( name ) - 2 ] + " " } } case 1 , 2 : return strings . Join ( ss , " " ) + " " + name default : return strings . Join ( ss [ : n - 1 ] , " " ) + " " + ss [ n - 1 ] + " " + name } } 
func Is Type ( t reflect . Type , ft func Type ) bool { if t = = nil | | t . Kind ( ) ! = reflect . Func | | t . Is Variadic ( ) { return false } ni , no : = t . Num In ( ) , t . Num Out ( ) switch ft { case tb Func : } case ttb Func : } case trb Func : } case tib Func : } case tr Func : } } return false } 
func Name Of ( v reflect . Value ) string { fnc : = runtime . Func For PC ( v . Pointer ( ) ) if fnc = = nil { return " " } full Name : = fnc . Name ( ) var name string for len ( full Name ) > 0 { in Paren : = strings . Has Suffix ( full Name , " " ) full Name = strings . Trim Suffix ( full Name , " " ) s : = last Ident Rx . Find String ( full Name ) if s = = " " { break } name = s + " " + name full Name = strings . Trim Suffix ( full Name , s ) if i : = strings . Last Index Byte ( full Name , ' ( ' ) ; in Paren & & i > = 0 { full Name = full Name [ : i ] } full Name = strings . Trim Suffix ( full Name , " " ) } return strings . Trim Suffix ( name , " " ) } 
func Pointer Of ( v reflect . Value ) Pointer { } 
func Sort Slices ( less Func interface { } ) cmp . Option { vf : = reflect . Value Of ( less Func ) if ! function . Is Type ( vf . Type ( ) , function . Less ) | | vf . Is Nil ( ) { panic ( fmt . Sprintf ( " " , less Func ) ) } ss : = slice Sorter { vf . Type ( ) . In ( 0 ) , vf } return cmp . Filter Values ( ss . filter , cmp . Transformer ( " " , ss . sort ) ) } 
func Sort Maps ( less Func interface { } ) cmp . Option { vf : = reflect . Value Of ( less Func ) if ! function . Is Type ( vf . Type ( ) , function . Less ) | | vf . Is Nil ( ) { panic ( fmt . Sprintf ( " " , less Func ) ) } ms : = map Sorter { vf . Type ( ) . In ( 0 ) , vf } return cmp . Filter Values ( ms . filter , cmp . Transformer ( " " , ms . sort ) ) } 
func ( es Edit Script ) String ( ) string { b : = make ( [ ] byte , len ( es ) ) for i , e : = range es { switch e { case Identity : b [ i ] = ' . ' case Unique X : b [ i ] = 'X ' case Unique Y : b [ i ] = 'Y ' case Modified : b [ i ] = 'M ' default : panic ( " " ) } } return string ( b ) } 
func ( es Edit Script ) stats ( ) ( s struct { NI , NX , NY , NM int } ) { for _ , e : = range es { switch e { case Identity : s . NI + + case Unique X : s . NX + + case Unique Y : s . NY + + case Modified : s . NM + + default : panic ( " " ) } } return } 
func Difference ( nx , ny int , f Equal Func ) ( es Edit Script ) { rev Path : = path { - 1 , point { nx , ny } , make ( Edit Script , 0 ) } fwd Frontier : = fwd Path . point rev Frontier : = rev Path . point for { } for stop 1 , stop 2 , i : = false , false , 0 ; ! ( stop 1 & & stop 2 ) & & search Budget > 0 ; i + + { p : = point { fwd Frontier . X + z , fwd Frontier . Y - z } switch { case p . X > = rev Path . X | | p . Y < fwd Path . Y : stop 1 = true case p . Y > = rev Path . Y | | p . X < fwd Path . X : stop 2 = true case f ( p . X , p . Y ) . Equal ( ) : fwd Path . append ( Identity ) } fwd Path . append ( Identity ) } fwd Frontier = fwd Path . point stop 1 , stop 2 = true , true default : search Budget - - } debug . Update ( ) } } else { fwd Frontier . Y + + } } for stop 1 , stop 2 , i : = false , false , 0 ; ! ( stop 1 & & stop 2 ) & & search Budget > 0 ; i + + { p : = point { rev Frontier . X - z , rev Frontier . Y + z } switch { case fwd Path . X > = p . X | | rev Path . Y < p . Y : stop 1 = true case fwd Path . Y > = p . Y | | rev Path . X < p . X : stop 2 = true case f ( p . X - 1 , p . Y - 1 ) . Equal ( ) : rev Path . append ( Identity ) } rev Path . append ( Identity ) } rev Frontier = rev Path . point stop 1 , stop 2 = true , true default : search Budget - - } debug . Update ( ) } } else { rev Frontier . Y - - } } for i : = len ( rev Path . es ) - 1 ; i > = 0 ; i - - { t : = rev Path . es [ i ] rev Path . es = rev Path . es [ : i ] fwd Path . append ( t ) } debug . Finish ( ) return fwd Path . es } 
func ( p * path ) connect ( dst point , f Equal Func ) { if p . dir > 0 { case r . Similar ( ) : p . append ( Modified ) case dst . X - p . X > = dst . Y - p . Y : p . append ( Unique X ) default : p . append ( Unique Y ) } } for dst . X > p . X { p . append ( Unique X ) } for dst . Y > p . Y { p . append ( Unique Y ) } } else { case r . Similar ( ) : p . append ( Modified ) case p . Y - dst . Y > = p . X - dst . X : p . append ( Unique Y ) default : p . append ( Unique X ) } } for p . X > dst . X { p . append ( Unique X ) } for p . Y > dst . Y { p . append ( Unique Y ) } } } 
func Equate Approx ( fraction , margin float 6 4 ) cmp . Option { if margin < 0 | | fraction < 0 | | math . Is Na N ( margin ) | | math . Is Na N ( fraction ) { panic ( " " ) } a : = approximator { fraction , margin } return cmp . Options { cmp . Filter Values ( are Real F 6 4s , cmp . Comparer ( a . compare F 6 4 ) ) , cmp . Filter Values ( are Real F 3 2s , cmp . Comparer ( a . compare F 3 2 ) ) , } } 
func Equate Na Ns ( ) cmp . Option { return cmp . Options { cmp . Filter Values ( are Na Ns F 6 4s , cmp . Comparer ( equate Always ) ) , cmp . Filter Values ( are Na Ns F 3 2s , cmp . Comparer ( equate Always ) ) , } } 
func ( pa Path ) Index ( i int ) Path Step { if i < 0 { i = len ( pa ) + i } if i < 0 | | i > = len ( pa ) { return path Step { } } return pa [ i ] } 
func ( pa Path ) String ( ) string { var ss [ ] string for _ , s : = range pa { if _ , ok : = s . ( Struct Field ) ; ok { ss = append ( ss , s . String ( ) ) } } return strings . Trim Prefix ( strings . Join ( ss , " " ) , " " ) } 
func ( pa Path ) Go String ( ) string { var ss Pre , ss Post [ ] string var num Indirect int for i , s : = range pa { var next Step Path Step if i + 1 < len ( pa ) { next Step = pa [ i + 1 ] } switch s : = s . ( type ) { case Indirect : num Indirect + + p Pre , p Post : = " " , " " switch next Step . ( type ) { case Indirect : continue case Struct Field : num Indirect - - case nil : p Pre , p Post = " " , " " } if num Indirect > 0 { ss Pre = append ( ss Pre , p Pre + strings . Repeat ( " " , num Indirect ) ) ss Post = append ( ss Post , p Post ) } num Indirect = 0 continue case Transform : ss Pre = append ( ss Pre , s . trans . name + " " ) ss Post = append ( ss Post , " " ) continue } ss Post = append ( ss Post , s . String ( ) ) } for i , j : = 0 , len ( ss Pre ) - 1 ; i < j ; i , j = i + 1 , j - 1 { ss Pre [ i ] , ss Pre [ j ] = ss Pre [ j ] , ss Pre [ i ] } return strings . Join ( ss Pre , " " ) + strings . Join ( ss Post , " " ) } 
func ( si Slice Index ) Key ( ) int { if si . xkey ! = si . ykey { return - 1 } return si . xkey } 
func ( r * default Reporter ) String ( ) string { assert ( r . root ! = nil & & r . curr = = nil ) if r . root . Num Diff = = 0 { return " " } return format Options { } . Format Diff ( r . root ) . String ( ) } 
func ( opts format Options ) Format Type ( t reflect . Type , s text Node ) text Node { } default : return s } case elide Type : return s } if t . Name ( ) = = " " { } type Name = strings . Replace ( type Name , " " , " " , - 1 ) type Name = strings . Replace ( type Name , " " , " " , - 1 ) } has Braces : = strings . Has Prefix ( s . Prefix , " " ) & & strings . Has Suffix ( s . Suffix , " " ) if has Parens | | has Braces { return text Wrap { type Name , s , " " } } } return text Wrap { type Name + " " , s , " " } } 
func ( opts format Options ) Format Value ( v reflect . Value , m visited Pointers ) ( out text Node ) { if ! v . Is Valid ( ) { return nil } t : = v . Type ( ) case fmt . Stringer : return text Line ( " " + format String ( v . String ( ) ) ) } } } defer func ( ) { if ! skip Type { out = opts . Format Type ( t , out ) } } ( ) var ptr string switch t . Kind ( ) { case reflect . Bool : return text Line ( fmt . Sprint ( v . Bool ( ) ) ) case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return text Line ( fmt . Sprint ( v . Int ( ) ) ) case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Uintptr : } return text Line ( fmt . Sprint ( v . Uint ( ) ) ) case reflect . Float 3 2 , reflect . Float 6 4 : return text Line ( fmt . Sprint ( v . Float ( ) ) ) case reflect . Complex 6 4 , reflect . Complex 1 2 8 : return text Line ( fmt . Sprint ( v . Complex ( ) ) ) case reflect . String : return text Line ( format String ( v . String ( ) ) ) case reflect . Unsafe Pointer , reflect . Chan , reflect . Func : return text Line ( format Pointer ( v ) ) case reflect . Struct : var list text List for i : = 0 ; i < v . Num Field ( ) ; i + + { vv : = v . Field ( i ) if value . Is Zero ( vv ) { continue } s : = opts . With Type Mode ( auto Type ) . Format Value ( vv , m ) list = append ( list , text Record { Key : t . Field ( i ) . Name , Value : s } ) } return text Wrap { " " , list , " " } case reflect . Slice : if v . Is Nil ( ) { return text Nil } if opts . Print Addresses { ptr = format Pointer ( v ) } fallthrough case reflect . Array : var list text List for i : = 0 ; i < v . Len ( ) ; i + + { vi : = v . Index ( i ) if vi . Can Addr ( ) { if m . Visit ( p ) { var out text Node out = text Line ( format Pointer ( p ) ) out = opts . With Type Mode ( emit Type ) . Format Type ( p . Type ( ) , out ) out = text Wrap { " " , out , " " } list = append ( list , text Record { Value : out } ) continue } } s : = opts . With Type Mode ( elide Type ) . Format Value ( vi , m ) list = append ( list , text Record { Value : s } ) } return text Wrap { ptr + " " , list , " " } case reflect . Map : if v . Is Nil ( ) { return text Nil } if m . Visit ( v ) { return text Line ( format Pointer ( v ) ) } var list text List for _ , k : = range value . Sort Keys ( v . Map Keys ( ) ) { sk : = format Map Key ( k ) sv : = opts . With Type Mode ( elide Type ) . Format Value ( v . Map Index ( k ) , m ) list = append ( list , text Record { Key : sk , Value : sv } ) } if opts . Print Addresses { ptr = format Pointer ( v ) } return text Wrap { ptr + " " , list , " " } case reflect . Ptr : if v . Is Nil ( ) { return text Nil } if m . Visit ( v ) | | opts . Shallow Pointers { return text Line ( format Pointer ( v ) ) } if opts . Print Addresses { ptr = format Pointer ( v ) } skip Type = true return text Wrap { " " + ptr , opts . Format Value ( v . Elem ( ) , m ) , " " } case reflect . Interface : if v . Is Nil ( ) { return text Nil } return opts . With Type Mode ( emit Type ) . Format Value ( v . Elem ( ) , m ) default : panic ( fmt . Sprintf ( " " , v . Kind ( ) ) ) } } 
func format Map Key ( v reflect . Value ) string { var opts format Options opts . Type Mode = elide Type opts . Avoid Stringer = true opts . Shallow Pointers = true s : = opts . Format Value ( v , visited Pointers { } ) . String ( ) return strings . Trim Space ( s ) } 
func format String ( s string ) string { if len ( qs ) = = 1 + len ( s ) + 1 { return qs } } if strings . Index Func ( s , raw Invalid ) < 0 { return " " + s + " " } return qs } 
func format Hex ( u uint 6 4 ) string { var f string switch { case u < = 0xff : f = " " case u < = 0xffff : f = " " case u < = 0xffffff : f = " " case u < = 0xffffffff : f = " " case u < = 0xffffffffff : f = " " case u < = 0xffffffffffff : f = " " case u < = 0xffffffffffffff : f = " " case u < = 0xffffffffffffffff : f = " " } return fmt . Sprintf ( f , u ) } 
func format Pointer ( v reflect . Value ) string { p : = v . Pointer ( ) if flags . Deterministic { p = 0xdeadf 0 0f } return fmt . Sprintf ( " ) } 
func ( m visited Pointers ) Visit ( v reflect . Value ) bool { p : = value . Pointer Of ( v ) _ , visited : = m [ p ] m [ p ] = struct { } { } return visited } 
func Acyclic Transformer ( name string , xform Func interface { } ) cmp . Option { xf : = xform Filter { cmp . Transformer ( name , xform Func ) } return cmp . Filter Path ( xf . filter , xf . xform ) } 
func retrieve Unexported Field ( v reflect . Value , f reflect . Struct Field ) reflect . Value { return reflect . New At ( f . Type , unsafe . Pointer ( v . Unsafe Addr ( ) + f . Offset ) ) . Elem ( ) } 
func filter Field ( typ interface { } , name string , opt cmp . Option ) cmp . Option { return cmp . Filter Path ( sf . filter , opt ) } 
func ( ft * field Tree ) insert ( cname [ ] string ) { if ft . sub = = nil { ft . sub = make ( map [ string ] field Tree ) } if len ( cname ) = = 0 { ft . ok = true return } sub : = ft . sub [ cname [ 0 ] ] sub . insert ( cname [ 1 : ] ) ft . sub [ cname [ 0 ] ] = sub } 
func ( ft field Tree ) match Prefix ( p cmp . Path ) bool { for _ , ps : = range p { switch ps : = ps . ( type ) { case cmp . Struct Field : ft = ft . sub [ ps . Name ( ) ] if ft . ok { return true } if len ( ft . sub ) = = 0 { return false } case cmp . Indirect : default : return false } } return false } 
func canonical Name ( t reflect . Type , sel string ) ( [ ] string , error ) { var name string sel = strings . Trim Prefix ( sel , " " ) if sel = = " " { return nil , fmt . Errorf ( " " ) } if i : = strings . Index Byte ( sel , ' . ' ) ; i < 0 { name , sel = sel , " " } else { name , sel = sel [ : i ] , sel [ i : ] } } if t . Kind ( ) ! = reflect . Struct { return nil , fmt . Errorf ( " " , t ) } } sf , ok : = t . Field By Name ( name ) if ! ok { return [ ] string { name } , fmt . Errorf ( " " ) } var ss [ ] string for i : = range sf . Index { ss = append ( ss , t . Field By Index ( sf . Index [ : i + 1 ] ) . Name ) } if sel = = " " { return ss , nil } ss Post , err : = canonical Name ( sf . Type , sel ) return append ( ss , ss Post . . . ) , err } 
func Filter Path ( f func ( Path ) bool , opt Option ) Option { if f = = nil { panic ( " " ) } if opt : = normalize Option ( opt ) ; opt ! = nil { return & path Filter { fnc : f , opt : opt } } return nil } 
func Filter Values ( f interface { } , opt Option ) Option { v : = reflect . Value Of ( f ) if ! function . Is Type ( v . Type ( ) , function . Value Filter ) | | v . Is Nil ( ) { panic ( fmt . Sprintf ( " " , f ) ) } if opt : = normalize Option ( opt ) ; opt ! = nil { vf : = & values Filter { fnc : v , opt : opt } if ti : = v . Type ( ) . In ( 0 ) ; ti . Kind ( ) ! = reflect . Interface | | ti . Num Method ( ) > 0 { vf . typ = ti } return vf } return nil } 
func Transformer ( name string , f interface { } ) Option { v : = reflect . Value Of ( f ) if ! function . Is Type ( v . Type ( ) , function . Transformer ) | | v . Is Nil ( ) { panic ( fmt . Sprintf ( " " , f ) ) } if name = = " " { name = function . Name Of ( v ) if ! idents Rx . Match String ( name ) { name = " / Lambda -symbol as placeholder name } } else if ! idents Rx . Match String ( name ) { panic ( fmt . Sprintf ( " " , name ) ) } tr : = & transformer { name : name , fnc : reflect . Value Of ( f ) } if ti : = v . Type ( ) . In ( 0 ) ; ti . Kind ( ) ! = reflect . Interface | | ti . Num Method ( ) > 0 { tr . typ = ti } return tr } 
func Comparer ( f interface { } ) Option { v : = reflect . Value Of ( f ) if ! function . Is Type ( v . Type ( ) , function . Equal ) | | v . Is Nil ( ) { panic ( fmt . Sprintf ( " " , f ) ) } cm : = & comparer { fnc : v } if ti : = v . Type ( ) . In ( 0 ) ; ti . Kind ( ) ! = reflect . Interface | | ti . Num Method ( ) > 0 { cm . typ = ti } return cm } 
func Allow Unexported ( types . . . interface { } ) Option { if ! support Allow Unexported { panic ( " " ) } m : = make ( map [ reflect . Type ] bool ) for _ , typ : = range types { t : = reflect . Type Of ( typ ) if t . Kind ( ) ! = reflect . Struct { panic ( fmt . Sprintf ( " " , typ ) ) } m [ t ] = true } return visible Structs ( m ) } 
func Reporter ( r interface { } ) Option { return reporter { r } } 
func normalize Option ( src Option ) Option { switch opts : = flatten Options ( nil , Options { src } ) ; len ( opts ) { case 0 : return nil case 1 : return opts [ 0 ] default : return opts } } 
func flatten Options ( dst , src Options ) Options { for _ , opt : = range src { switch opt : = opt . ( type ) { case nil : continue case Options : dst = flatten Options ( dst , opt ) case core Option : dst = append ( dst , opt ) default : panic ( fmt . Sprintf ( " " , opt ) ) } } return dst } 
func ( opts format Options ) Can Format Diff Slice ( v * value Node ) bool { switch { case opts . Diff Mode ! = diff Unknown : return false case v . Num Diff = = 0 : return false case v . Num Ignored + v . Num Compared + v . Num Transformed > 0 : case ! v . Value X . Is Valid ( ) | | ! v . Value Y . Is Valid ( ) : return false } switch t : = v . Type ; t . Kind ( ) { case reflect . String : case reflect . Array , reflect . Slice : } } default : return false } return v . Value X . Len ( ) > = min Length & & v . Value Y . Len ( ) > = min Length } 
func ( opts format Options ) Format Diff Slice ( v * value Node ) text Node { assert ( opts . Diff Mode = = diff Unknown ) t , vx , vy : = v . Type , v . Value X , v . Value Y var sx , sy string switch { case t . Kind ( ) = = reflect . String : sx , sy = vx . String ( ) , vy . String ( ) is Text = true case t . Kind ( ) = = reflect . Slice & & t . Elem ( ) = = reflect . Type Of ( byte ( 0 ) ) : sx , sy = string ( vx . Bytes ( ) ) , string ( vy . Bytes ( ) ) is Binary = true case t . Kind ( ) = = reflect . Array : vx 2 . Set ( vx ) vy 2 . Set ( vy ) vx , vy = vx 2 , vy 2 } if is Text | | is Binary { var num Lines , last Line Idx , max Line Len int is Binary = false for i , r : = range sx + sy { if ! ( unicode . Is Print ( r ) | | unicode . Is Space ( r ) ) | | r = = utf 8 . Rune Error { is Binary = true break } if r = = ' \n ' { if max Line Len < i - last Line Idx { last Line Idx = i - last Line Idx } last Line Idx = i + 1 num Lines + + } } is Text = ! is Binary is Lined Text = is Text & & num Lines > = 4 & & max Line Len < = 2 5 6 } var delim string switch { ssy : = strings . Split ( sy , " \n " ) list = opts . format Diff Slice ( reflect . Value Of ( ssx ) , reflect . Value Of ( ssy ) , 1 , " " , func ( v reflect . Value , d diff Mode ) text Record { s : = format String ( v . Index ( 0 ) . String ( ) ) return text Record { Diff : d , Value : text Line ( s ) } } , ) delim = " \n " return text Record { Diff : d , Value : text Line ( s ) } } , ) delim = " " for i : = 0 ; i < v . Len ( ) ; i + + { ss = append ( ss , format Hex ( v . Index ( i ) . Uint ( ) ) ) } s : = strings . Join ( ss , " " ) comment : = comment String ( fmt . Sprintf ( " " , d , format ASCII ( v . String ( ) ) ) ) return text Record { Diff : d , Value : text Line ( s ) , Comment : comment } } , ) if t . Elem ( ) . Kind ( ) = = reflect . Bool { chunk Size = 1 6 } else { switch t . Elem ( ) . Bits ( ) { case 8 : chunk Size = 1 6 case 1 6 : chunk Size = 1 2 case 3 2 : chunk Size = 8 default : chunk Size = 8 } } list = opts . format Diff Slice ( vx , vy , chunk Size , t . Elem ( ) . Kind ( ) . String ( ) , func ( v reflect . Value , d diff Mode ) text Record { var ss [ ] string for i : = 0 ; i < v . Len ( ) ; i + + { switch t . Elem ( ) . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : ss = append ( ss , fmt . Sprint ( v . Index ( i ) . Int ( ) ) ) case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Uintptr : ss = append ( ss , format Hex ( v . Index ( i ) . Uint ( ) ) ) case reflect . Bool , reflect . Float 3 2 , reflect . Float 6 4 , reflect . Complex 6 4 , reflect . Complex 1 2 8 : ss = append ( ss , fmt . Sprint ( v . Index ( i ) . Interface ( ) ) ) } } s : = strings . Join ( ss , " " ) return text Record { Diff : d , Value : text Line ( s ) } } , ) } if ! is Text { } return opts . Format Type ( t , out ) } switch t . Kind ( ) { case reflect . String : out = text Wrap { " " , out , fmt . Sprintf ( " " , delim ) } if t ! = reflect . Type Of ( string ( " " ) ) { out = opts . Format Type ( t , out ) } case reflect . Slice : out = text Wrap { " " , out , fmt . Sprintf ( " " , delim ) } if t ! = reflect . Type Of ( [ ] byte ( nil ) ) { out = opts . Format Type ( t , out ) } } return out } 
func format ASCII ( s string ) string { b : = bytes . Repeat ( [ ] byte { ' . ' } , len ( s ) ) for i : = 0 ; i < len ( s ) ; i + + { if ' ' < = s [ i ] & & s [ i ] < = ' ~ ' { b [ i ] = s [ i ] } } return string ( b ) } 
func coalesce Adjacent Edits ( name string , es diff . Edit Script ) ( groups [ ] diff Stats ) { var prev Case int last Stats : = func ( i int ) * diff Stats { if prev Case ! = i { groups = append ( groups , diff Stats { Name : name } ) prev Case = i } return & groups [ len ( groups ) - 1 ] } for _ , e : = range es { switch e { case diff . Identity : last Stats ( 1 ) . Num Identical + + case diff . Unique X : last Stats ( 2 ) . Num Removed + + case diff . Unique Y : last Stats ( 2 ) . Num Inserted + + case diff . Modified : last Stats ( 2 ) . Num Modified + + } } return groups } 
func coalesce Intervening Identical ( groups [ ] diff Stats , window Size int ) [ ] diff Stats { groups , groups Orig : = groups [ : 0 ] , groups for i , ds : = range groups Orig { if len ( groups ) > = 2 & & ds . Num Diff ( ) > 0 { prev : = & groups [ len ( groups ) - 2 ] curr : = & groups [ len ( groups ) - 1 ] next : = & groups Orig [ i ] had X , had Y : = prev . Num Removed > 0 , prev . Num Inserted > 0 has X , has Y : = next . Num Removed > 0 , next . Num Inserted > 0 if ( ( had X | | has X ) & & ( had Y | | has Y ) ) & & curr . Num Identical < = window Size { * prev = ( * prev ) . Append ( * curr ) . Append ( * next ) groups = groups [ : len ( groups ) - 1 ] continue } } groups = append ( groups , ds ) } return groups } 
func Sort Keys ( vs [ ] reflect . Value ) [ ] reflect . Value { if len ( vs ) = = 0 { return vs } for _ , v : = range vs [ 1 : ] { if is Less ( vs 2 [ len ( vs 2 ) - 1 ] , v ) { vs 2 = append ( vs 2 , v ) } } return vs 2 } 
func is Less ( x , y reflect . Value ) bool { switch x . Type ( ) . Kind ( ) { case reflect . Bool : return ! x . Bool ( ) & & y . Bool ( ) case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return x . Int ( ) < y . Int ( ) case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 , reflect . Uintptr : return x . Uint ( ) < y . Uint ( ) case reflect . Float 3 2 , reflect . Float 6 4 : fx , fy : = x . Float ( ) , y . Float ( ) return fx < fy | | math . Is Na N ( fx ) & & ! math . Is Na N ( fy ) case reflect . Complex 6 4 , reflect . Complex 1 2 8 : cx , cy : = x . Complex ( ) , y . Complex ( ) rx , ix , ry , iy : = real ( cx ) , imag ( cx ) , real ( cy ) , imag ( cy ) if rx = = ry | | ( math . Is Na N ( rx ) & & math . Is Na N ( ry ) ) { return ix < iy | | math . Is Na N ( ix ) & & ! math . Is Na N ( iy ) } return rx < ry | | math . Is Na N ( rx ) & & ! math . Is Na N ( ry ) case reflect . Ptr , reflect . Unsafe Pointer , reflect . Chan : return x . Pointer ( ) < y . Pointer ( ) case reflect . String : return x . String ( ) < y . String ( ) case reflect . Array : for i : = 0 ; i < x . Len ( ) ; i + + { if is Less ( x . Index ( i ) , y . Index ( i ) ) { return true } if is Less ( y . Index ( i ) , x . Index ( i ) ) { return false } } return false case reflect . Struct : for i : = 0 ; i < x . Num Field ( ) ; i + + { if is Less ( x . Field ( i ) , y . Field ( i ) ) { return true } if is Less ( y . Field ( i ) , x . Field ( i ) ) { return false } } return false case reflect . Interface : vx , vy : = x . Elem ( ) , y . Elem ( ) if ! vx . Is Valid ( ) | | ! vy . Is Valid ( ) { return ! vx . Is Valid ( ) & & vy . Is Valid ( ) } tx , ty : = vx . Type ( ) , vy . Type ( ) if tx = = ty { return is Less ( x . Elem ( ) , y . Elem ( ) ) } if tx . Kind ( ) ! = ty . Kind ( ) { return vx . Kind ( ) < vy . Kind ( ) } if tx . String ( ) ! = ty . String ( ) { return tx . String ( ) < ty . String ( ) } if tx . Pkg Path ( ) ! = ty . Pkg Path ( ) { return tx . Pkg Path ( ) < ty . Pkg Path ( ) } default : } } 
func ( opts format Options ) Format Diff ( v * value Node ) text Node { } outy : = opts . Format Value ( v . Value Y , visited Pointers { } ) if v . Num Ignored > 0 & & v . Num Same = = 0 { return text Ellipsis } else if outx . Len ( ) < outy . Len ( ) { return outx } else { return outy } } var list text List outx : = opts . With Type Mode ( elide Type ) . Format Value ( v . Value X , visited Pointers { } ) outy : = opts . With Type Mode ( elide Type ) . Format Value ( v . Value Y , visited Pointers { } ) if outx ! = nil { list = append ( list , text Record { Diff : ' - ' , Value : outx } ) } if outy ! = nil { list = append ( list , text Record { Diff : ' + ' , Value : outy } ) } return opts . With Type Mode ( emit Type ) . Format Type ( v . Type , list ) case diff Removed : return opts . Format Value ( v . Value X , visited Pointers { } ) case diff Inserted : return opts . Format Value ( v . Value Y , visited Pointers { } ) default : panic ( " " ) } } out = text Wrap { " " + v . Transformer Name + " " , out , " " } return opts . Format Type ( v . Type , out ) } else { switch k : = v . Type . Kind ( ) ; k { case reflect . Struct , reflect . Array , reflect . Slice , reflect . Map : return opts . Format Type ( v . Type , opts . format Diff List ( v . Records , k ) ) case reflect . Ptr : return text Wrap { " " , opts . Format Diff ( v . Value ) , " " } case reflect . Interface : return opts . With Type Mode ( emit Type ) . Format Diff ( v . Value ) default : panic ( fmt . Sprintf ( " " , k ) ) } } } 
func coalesce Adjacent Records ( name string , recs [ ] report Record ) ( groups [ ] diff Stats ) { var prev Case int last Stats : = func ( i int ) * diff Stats { if prev Case ! = i { groups = append ( groups , diff Stats { Name : name } ) prev Case = i } return & groups [ len ( groups ) - 1 ] } for _ , r : = range recs { switch rv : = r . Value ; { case rv . Num Ignored > 0 & & rv . Num Same + rv . Num Diff = = 0 : last Stats ( 1 ) . Num Ignored + + case rv . Num Diff = = 0 : last Stats ( 1 ) . Num Identical + + case rv . Num Diff > 0 & & ! rv . Value Y . Is Valid ( ) : last Stats ( 2 ) . Num Removed + + case rv . Num Diff > 0 & & ! rv . Value X . Is Valid ( ) : last Stats ( 2 ) . Num Inserted + + default : last Stats ( 2 ) . Num Modified + + } } return groups } 
func Equal ( x , y interface { } , opts . . . Option ) bool { vx : = reflect . Value Of ( x ) vy : = reflect . Value Of ( y ) if ! vx . Is Valid ( ) | | ! vy . Is Valid ( ) | | vx . Type ( ) ! = vy . Type ( ) { t = reflect . Type Of ( ( * interface { } ) ( nil ) ) . Elem ( ) if vx . Is Valid ( ) { vvx : = reflect . New ( t ) . Elem ( ) vvx . Set ( vx ) vx = vvx } if vy . Is Valid ( ) { vvy : = reflect . New ( t ) . Elem ( ) vvy . Set ( vy ) vy = vvy } } else { t = vx . Type ( ) } s : = new State ( opts ) s . compare Any ( & path Step { t , vx , vy } ) return s . result . Equal ( ) } 
func Diff ( x , y interface { } , opts . . . Option ) string { r : = new ( default Reporter ) eq : = Equal ( x , y , Options ( opts ) , Reporter ( r ) ) d : = r . String ( ) if ( d = = " " ) ! = eq { panic ( " " ) } return d } 
func ( s * state ) stateless Compare ( step Path Step ) diff . Result { s . result = diff . Result { } s . reporters = nil s . compare Any ( step ) res : = s . result s . result , s . reporters = old Result , old Reporters return res } 
func sanitize Value ( v reflect . Value , t reflect . Type ) reflect . Value { } } return v } 
func ( rc * rec Checker ) Check ( p Path ) { const min Len = 1 < < 1 6 if rc . next = = 0 { rc . next = min Len } if len ( p ) < rc . next { return } rc . next < < = 1 m : = map [ Option ] int { } for _ , ps : = range p { if t , ok : = ps . ( Transform ) ; ok { t : = t . Option ( ) if m [ t ] = = 1 { ss = append ( ss , fmt . Sprintf ( " " , t , tf . In ( 0 ) , tf . Out ( 0 ) ) ) } m [ t ] + + } } if len ( ss ) > 0 { const warning = " " const help = " " set : = strings . Join ( ss , " \n \t " ) panic ( fmt . Sprintf ( " \n \t \n " , warning , set , help ) ) } } 
func ( dc * dyn Checker ) Next ( ) bool { ok : = dc . curr = = dc . next if ok { dc . curr = 0 dc . next + + } dc . curr + + return ok } 
func make Addressable ( v reflect . Value ) reflect . Value { if v . Can Addr ( ) { return v } vc : = reflect . New ( v . Type ( ) ) . Elem ( ) vc . Set ( v ) return vc } 
func String ( key , val string ) Field { return Field { key : key , field Type : string Type , string Val : val , } } 
func Bool ( key string , val bool ) Field { var numeric Val int 6 4 if val { numeric Val = 1 } return Field { key : key , field Type : bool Type , numeric Val : numeric Val , } } 
func Int ( key string , val int ) Field { return Field { key : key , field Type : int Type , numeric Val : int 6 4 ( val ) , } } 
func Int 3 2 ( key string , val int 3 2 ) Field { return Field { key : key , field Type : int 3 2Type , numeric Val : int 6 4 ( val ) , } } 
func Int 6 4 ( key string , val int 6 4 ) Field { return Field { key : key , field Type : int 6 4Type , numeric Val : val , } } 
func Uint 3 2 ( key string , val uint 3 2 ) Field { return Field { key : key , field Type : uint 3 2Type , numeric Val : int 6 4 ( val ) , } } 
func Uint 6 4 ( key string , val uint 6 4 ) Field { return Field { key : key , field Type : uint 6 4Type , numeric Val : int 6 4 ( val ) , } } 
func Float 3 2 ( key string , val float 3 2 ) Field { return Field { key : key , field Type : float 3 2Type , numeric Val : int 6 4 ( math . Float 3 2bits ( val ) ) , } } 
func Float 6 4 ( key string , val float 6 4 ) Field { return Field { key : key , field Type : float 6 4Type , numeric Val : int 6 4 ( math . Float 6 4bits ( val ) ) , } } 
func Error ( err error ) Field { return Field { key : " " , field Type : error Type , interface Val : err , } } 
func Object ( key string , obj interface { } ) Field { return Field { key : key , field Type : object Type , interface Val : obj , } } 
func ( lf Field ) Marshal ( visitor Encoder ) { switch lf . field Type { case string Type : visitor . Emit String ( lf . key , lf . string Val ) case bool Type : visitor . Emit Bool ( lf . key , lf . numeric Val ! = 0 ) case int Type : visitor . Emit Int ( lf . key , int ( lf . numeric Val ) ) case int 3 2Type : visitor . Emit Int 3 2 ( lf . key , int 3 2 ( lf . numeric Val ) ) case int 6 4Type : visitor . Emit Int 6 4 ( lf . key , int 6 4 ( lf . numeric Val ) ) case uint 3 2Type : visitor . Emit Uint 3 2 ( lf . key , uint 3 2 ( lf . numeric Val ) ) case uint 6 4Type : visitor . Emit Uint 6 4 ( lf . key , uint 6 4 ( lf . numeric Val ) ) case float 3 2Type : visitor . Emit Float 3 2 ( lf . key , math . Float 3 2frombits ( uint 3 2 ( lf . numeric Val ) ) ) case float 6 4Type : visitor . Emit Float 6 4 ( lf . key , math . Float 6 4frombits ( uint 6 4 ( lf . numeric Val ) ) ) case error Type : if err , ok : = lf . interface Val . ( error ) ; ok { visitor . Emit String ( lf . key , err . Error ( ) ) } else { visitor . Emit String ( lf . key , " " ) } case object Type : visitor . Emit Object ( lf . key , lf . interface Val ) case lazy Logger Type : visitor . Emit Lazy Logger ( lf . interface Val . ( Lazy Logger ) ) case noop Type : } 
func ( lf Field ) Value ( ) interface { } { switch lf . field Type { case string Type : return lf . string Val case bool Type : return lf . numeric Val ! = 0 case int Type : return int ( lf . numeric Val ) case int 3 2Type : return int 3 2 ( lf . numeric Val ) case int 6 4Type : return int 6 4 ( lf . numeric Val ) case uint 3 2Type : return uint 3 2 ( lf . numeric Val ) case uint 6 4Type : return uint 6 4 ( lf . numeric Val ) case float 3 2Type : return math . Float 3 2frombits ( uint 3 2 ( lf . numeric Val ) ) case float 6 4Type : return math . Float 6 4frombits ( uint 6 4 ( lf . numeric Val ) ) case error Type , object Type , lazy Logger Type : return lf . interface Val case noop Type : return nil default : return nil } } 
func ( lf Field ) String ( ) string { return fmt . Sprint ( lf . key , " " , lf . Value ( ) ) } 
func ( r Span Reference ) Apply ( o * Start Span Options ) { if r . Referenced Context ! = nil { o . References = append ( o . References , r ) } } 
func ( t Start Time ) Apply ( o * Start Span Options ) { o . Start Time = time . Time ( t ) } 
func ( t Tags ) Apply ( o * Start Span Options ) { if o . Tags = = nil { o . Tags = make ( map [ string ] interface { } ) } for k , v : = range t { o . Tags [ k ] = v } } 
func ( t Tag ) Apply ( o * Start Span Options ) { if o . Tags = = nil { o . Tags = make ( map [ string ] interface { } ) } o . Tags [ t . Key ] = t . Value } 
func ( t Tag ) Set ( s Span ) { s . Set Tag ( t . Key , t . Value ) } 
func ( t * Text Map Propagator ) Inject ( span Context Mock Span Context , carrier interface { } ) error { writer , ok : = carrier . ( opentracing . Text Map Writer ) if ! ok { return opentracing . Err Invalid Carrier } writer . Set ( mock Text Map Ids Prefix + " " , strconv . Itoa ( span Context . Span ID ) ) writer . Set ( mock Text Map Ids Prefix + " " , fmt . Sprint ( span Context . Sampled ) ) if t . HTTPHeaders { safe Val = url . Query Escape ( baggage Val ) } writer . Set ( mock Text Map Baggage Prefix + baggage Key , safe Val ) } return nil } 
func ( t * Text Map Propagator ) Extract ( carrier interface { } ) ( Mock Span Context , error ) { reader , ok : = carrier . ( opentracing . Text Map Reader ) if ! ok { return empty Context , opentracing . Err Invalid Carrier } rval : = Mock Span Context { 0 , 0 , true , nil } err : = reader . Foreach Key ( func ( key , val string ) error { lower Key : = strings . To Lower ( key ) switch { case lower Key = = mock Text Map Ids Prefix + " " : if err ! = nil { return err } rval . Trace ID = i case lower Key = = mock Text Map Ids Prefix + " " : if err ! = nil { return err } rval . Span ID = i case lower Key = = mock Text Map Ids Prefix + " " : b , err : = strconv . Parse Bool ( val ) if err ! = nil { return err } rval . Sampled = b case strings . Has Prefix ( lower Key , mock Text Map Baggage Prefix ) : } safe Val : = val if t . HTTPHeaders { } } rval . Baggage [ lower Key [ len ( mock Text Map Baggage Prefix ) : ] ] = safe Val } return nil } ) if rval . Trace ID = = 0 | | rval . Span ID = = 0 { return empty Context , opentracing . Err Span Context Not Found } if err ! = nil { return empty Context , err } return rval , nil } 
func ( ld * Log Data ) To Log Record ( ) Log Record { var literal Timestamp time . Time if ld . Timestamp . Is Zero ( ) { literal Timestamp = time . Now ( ) } else { literal Timestamp = ld . Timestamp } rval : = Log Record { Timestamp : literal Timestamp , } if ld . Payload = = nil { rval . Fields = [ ] log . Field { log . String ( " " , ld . Event ) , } } else { rval . Fields = [ ] log . Field { log . String ( " " , ld . Event ) , log . Object ( " " , ld . Payload ) , } } return rval } 
func New ( ) * Mock Tracer { t : = & Mock Tracer { finished Spans : [ ] * Mock Span { } , injectors : make ( map [ interface { } ] Injector ) , extractors : make ( map [ interface { } ] Extractor ) , } t . Register Injector ( opentracing . Text Map , text Propagator ) t . Register Extractor ( opentracing . Text Map , text Propagator ) http Propagator : = & Text Map Propagator { HTTPHeaders : true } t . Register Injector ( opentracing . HTTPHeaders , http Propagator ) t . Register Extractor ( opentracing . HTTPHeaders , http Propagator ) return t } 
func ( t * Mock Tracer ) Finished Spans ( ) [ ] * Mock Span { t . RLock ( ) defer t . RUnlock ( ) spans : = make ( [ ] * Mock Span , len ( t . finished Spans ) ) copy ( spans , t . finished Spans ) return spans } 
func ( t * Mock Tracer ) Reset ( ) { t . Lock ( ) defer t . Unlock ( ) t . finished Spans = [ ] * Mock Span { } } 
func ( t * Mock Tracer ) Start Span ( operation Name string , opts . . . opentracing . Start Span Option ) opentracing . Span { sso : = opentracing . Start Span Options { } for _ , o : = range opts { o . Apply ( & sso ) } return new Mock Span ( t , operation Name , sso ) } 
func ( t * Mock Tracer ) Register Injector ( format interface { } , injector Injector ) { t . injectors [ format ] = injector } 
func ( t * Mock Tracer ) Register Extractor ( format interface { } , extractor Extractor ) { t . extractors [ format ] = extractor } 
func ( t * Mock Tracer ) Inject ( sm opentracing . Span Context , format interface { } , carrier interface { } ) error { span Context , ok : = sm . ( Mock Span Context ) if ! ok { return opentracing . Err Invalid Carrier } injector , ok : = t . injectors [ format ] if ! ok { return opentracing . Err Unsupported Format } return injector . Inject ( span Context , carrier ) } 
func ( t * Mock Tracer ) Extract ( format interface { } , carrier interface { } ) ( opentracing . Span Context , error ) { extractor , ok : = t . extractors [ format ] if ! ok { return nil , opentracing . Err Unsupported Format } return extractor . Extract ( carrier ) } 
func Context With Span ( ctx context . Context , span Span ) context . Context { return context . With Value ( ctx , active Span Key , span ) } 
func Span From Context ( ctx context . Context ) Span { val : = ctx . Value ( active Span Key ) if sp , ok : = val . ( Span ) ; ok { return sp } return nil } 
func Start Span From Context ( ctx context . Context , operation Name string , opts . . . Start Span Option ) ( Span , context . Context ) { return Start Span From Context With Tracer ( ctx , Global Tracer ( ) , operation Name , opts . . . ) } 
func ( tag span Kind Tag Name ) Set ( span opentracing . Span , value Span Kind Enum ) { span . Set Tag ( string ( tag ) , value ) } 
func ( tag string Tag Name ) Set ( span opentracing . Span , value string ) { span . Set Tag ( string ( tag ) , value ) } 
func ( tag uint 3 2Tag Name ) Set ( span opentracing . Span , value uint 3 2 ) { span . Set Tag ( string ( tag ) , value ) } 
func ( tag uint 1 6Tag Name ) Set ( span opentracing . Span , value uint 1 6 ) { span . Set Tag ( string ( tag ) , value ) } 
func ( tag bool Tag Name ) Set ( span opentracing . Span , value bool ) { span . Set Tag ( string ( tag ) , value ) } 
func ( tag ipv 4Tag ) Set String ( span opentracing . Span , value string ) { span . Set Tag ( string ( tag ) , value ) } 
func Start Span ( operation Name string , opts . . . Start Span Option ) Span { return global Tracer . tracer . Start Span ( operation Name , opts . . . ) } 
func Interleaved KVTo Fields ( key Values . . . interface { } ) ( [ ] Field , error ) { if len ( key Values ) % 2 ! = 0 { return nil , fmt . Errorf ( " " , len ( key Values ) ) } fields : = make ( [ ] Field , len ( key Values ) / 2 ) for i : = 0 ; i * 2 < len ( key Values ) ; i + + { key , ok : = key Values [ i * 2 ] . ( string ) if ! ok { return nil , fmt . Errorf ( " " , i , key Values [ i * 2 ] ) } switch typed Val : = key Values [ i * 2 + 1 ] . ( type ) { case bool : fields [ i ] = Bool ( key , typed Val ) case string : fields [ i ] = String ( key , typed Val ) case int : fields [ i ] = Int ( key , typed Val ) case int 8 : fields [ i ] = Int 3 2 ( key , int 3 2 ( typed Val ) ) case int 1 6 : fields [ i ] = Int 3 2 ( key , int 3 2 ( typed Val ) ) case int 3 2 : fields [ i ] = Int 3 2 ( key , typed Val ) case int 6 4 : fields [ i ] = Int 6 4 ( key , typed Val ) case uint : fields [ i ] = Uint 6 4 ( key , uint 6 4 ( typed Val ) ) case uint 6 4 : fields [ i ] = Uint 6 4 ( key , typed Val ) case uint 8 : fields [ i ] = Uint 3 2 ( key , uint 3 2 ( typed Val ) ) case uint 1 6 : fields [ i ] = Uint 3 2 ( key , uint 3 2 ( typed Val ) ) case uint 3 2 : fields [ i ] = Uint 3 2 ( key , typed Val ) case float 3 2 : fields [ i ] = Float 3 2 ( key , typed Val ) case float 6 4 : fields [ i ] = Float 6 4 ( key , typed Val ) default : } } return fields , nil } 
func ( c Text Map Carrier ) Foreach Key ( handler func ( key , val string ) error ) error { for k , v : = range c { if err : = handler ( k , v ) ; err ! = nil { return err } } return nil } 
func ( m * Mock Key Value ) Emit String ( key , value string ) { m . Key = key m . Value Kind = reflect . Type Of ( value ) . Kind ( ) m . Value String = fmt . Sprint ( value ) } 
func ( m * Mock Key Value ) Emit Lazy Logger ( value log . Lazy Logger ) { var meta Mock Key Value value ( & meta ) m . Key = meta . Key m . Value Kind = meta . Value Kind m . Value String = meta . Value String } 
func Run APIChecks ( t * testing . T , new Tracer func ( ) ( tracer opentracing . Tracer , closer func ( ) ) , opts . . . APICheck Option , ) { s : = & APICheck Suite { new Tracer : new Tracer } for _ , opt : = range opts { opt ( s ) } suite . Run ( t , s ) } 
func Check Baggage Values ( val bool ) APICheck Option { return func ( s * APICheck Suite ) { s . opts . Check Baggage Values = val } } 
func Check Extract ( val bool ) APICheck Option { return func ( s * APICheck Suite ) { s . opts . Check Extract = val } } 
func Check Inject ( val bool ) APICheck Option { return func ( s * APICheck Suite ) { s . opts . Check Inject = val } } 
func Check Everything ( ) APICheck Option { return func ( s * APICheck Suite ) { s . opts . Check Baggage Values = true s . opts . Check Extract = true s . opts . Check Inject = true } } 
func Use Probe ( probe APICheck Probe ) APICheck Option { return func ( s * APICheck Suite ) { s . opts . Probe = probe } } 
func ( c Mock Span Context ) With Baggage Item ( key , value string ) Mock Span Context { var new Baggage map [ string ] string if c . Baggage = = nil { new Baggage = map [ string ] string { key : value } } else { new Baggage = make ( map [ string ] string , len ( c . Baggage ) + 1 ) for k , v : = range c . Baggage { new Baggage [ k ] = v } new Baggage [ key ] = value } } 
func ( s * Mock Span ) Tags ( ) map [ string ] interface { } { s . RLock ( ) defer s . RUnlock ( ) tags : = make ( map [ string ] interface { } ) for k , v : = range s . tags { tags [ k ] = v } return tags } 
func ( s * Mock Span ) Tag ( k string ) interface { } { s . RLock ( ) defer s . RUnlock ( ) return s . tags [ k ] } 
func ( s * Mock Span ) Logs ( ) [ ] Mock Log Record { s . RLock ( ) defer s . RUnlock ( ) logs : = make ( [ ] Mock Log Record , len ( s . logs ) ) copy ( logs , s . logs ) return logs } 
func ( s * Mock Span ) Context ( ) opentracing . Span Context { s . Lock ( ) defer s . Unlock ( ) return s . Span Context } 
func ( s * Mock Span ) Set Tag ( key string , value interface { } ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) if key = = string ( ext . Sampling Priority ) { if v , ok : = value . ( uint 1 6 ) ; ok { s . Span Context . Sampled = v > 0 return s } if v , ok : = value . ( int ) ; ok { s . Span Context . Sampled = v > 0 return s } } s . tags [ key ] = value return s } 
func ( s * Mock Span ) Set Baggage Item ( key , val string ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) s . Span Context = s . Span Context . With Baggage Item ( key , val ) return s } 
func ( s * Mock Span ) Baggage Item ( key string ) string { s . RLock ( ) defer s . RUnlock ( ) return s . Span Context . Baggage [ key ] } 
func ( s * Mock Span ) Finish ( ) { s . Lock ( ) s . Finish Time = time . Now ( ) s . Unlock ( ) s . tracer . record Span ( s ) } 
func ( s * Mock Span ) Finish With Options ( opts opentracing . Finish Options ) { s . Lock ( ) s . Finish Time = opts . Finish Time s . Unlock ( ) } } else { s . log Fields With Timestamp ( ld . Timestamp , log . String ( " " , ld . Event ) ) } } s . tracer . record Span ( s ) } 
func ( s * Mock Span ) String ( ) string { return fmt . Sprintf ( " " , s . Span Context . Trace ID , s . Span Context . Span ID , s . Parent ID , s . Span Context . Sampled , s . Operation Name ) } 
func ( s * Mock Span ) Log Fields ( fields . . . log . Field ) { s . log Fields With Timestamp ( time . Now ( ) , fields . . . ) } 
func ( s * Mock Span ) log Fields With Timestamp ( ts time . Time , fields . . . log . Field ) { lr : = Mock Log Record { Timestamp : ts , Fields : make ( [ ] Mock Key Value , len ( fields ) ) , } for i , f : = range fields { out Field : = & ( lr . Fields [ i ] ) f . Marshal ( out Field ) } s . Lock ( ) defer s . Unlock ( ) s . logs = append ( s . logs , lr ) } 
func ( s * Mock Span ) Log KV ( key Values . . . interface { } ) { if len ( key Values ) % 2 ! = 0 { s . Log Fields ( log . Error ( fmt . Errorf ( " " , len ( key Values ) ) ) ) return } fields , err : = log . Interleaved KVTo Fields ( key Values . . . ) if err ! = nil { s . Log Fields ( log . Error ( err ) , log . String ( " " , " " ) ) return } s . Log Fields ( fields . . . ) } 
func ( s * Mock Span ) Log Event ( event string ) { s . Log Fields ( log . String ( " " , event ) ) } 
func ( s * Mock Span ) Log Event With Payload ( event string , payload interface { } ) { s . Log Fields ( log . String ( " " , event ) , log . Object ( " " , payload ) ) } 
func ( s * Mock Span ) Set Operation Name ( operation Name string ) opentracing . Span { s . Lock ( ) defer s . Unlock ( ) s . Operation Name = operation Name return s } 
func new Open Shift Client Config Loading Rules ( ) * client Config Loading Rules { chain : = [ ] string { } env Var File : = os . Getenv ( " " ) if len ( env Var File ) ! = 0 { chain = append ( chain , filepath . Split List ( env Var File ) . . . ) } else { chain = append ( chain , recommended Home File ) } return & client Config Loading Rules { Precedence : chain , } 
func ( config * deferred Loading Client Config ) Client Config ( ) ( * rest Config , error ) { merged Client Config , err : = config . create Client Config ( ) if err ! = nil { return nil , err } merged Config , err : = merged Client Config . Client Config ( ) if err ! = nil { return nil , err } } 
func ( config * direct Client Config ) Client Config ( ) ( * rest Config , error ) { if err : = config . Confirm Usable ( ) ; err ! = nil { return nil , err } config Auth Info : = config . get Auth Info ( ) config Cluster Info : = config . get Cluster ( ) client Config : = & rest Config { } client Config . Host = config Cluster Info . Server if u , err : = url . Parse Request URI ( client Config . Host ) ; err = = nil & & u . Opaque = = " " & & len ( u . Path ) > 1 { u . Raw Query = " " u . Fragment = " " client Config . Host = u . String ( ) } if err ! = nil { return nil , err } mergo . Merge ( client Config , user Auth Partial Config ) server Auth Partial Config , err : = get Server Identification Partial Config ( config Auth Info , config Cluster Info ) if err ! = nil { return nil , err } mergo . Merge ( client Config , server Auth Partial Config ) } return client Config , nil } 
func get Server Identification Partial Config ( config Auth Info clientcmd Auth Info , config Cluster Info clientcmd Cluster ) ( * rest Config , error ) { merged Config : = & rest Config { } config Client Config . CAFile = config Cluster Info . Certificate Authority config Client Config . CAData = config Cluster Info . Certificate Authority Data config Client Config . Insecure = config Cluster Info . Insecure Skip TLSVerify mergo . Merge ( merged Config , config Client Config ) return merged Config , nil } 
func get User Identification Partial Config ( config Auth Info clientcmd Auth Info ) ( * rest Config , error ) { merged Config : = & rest Config { } } if len ( config Auth Info . Client Certificate ) > 0 | | len ( config Auth Info . Client Certificate Data ) > 0 { merged Config . Cert File = config Auth Info . Client Certificate merged Config . Cert Data = config Auth Info . Client Certificate Data merged Config . Key File = config Auth Info . Client Key merged Config . Key Data = config Auth Info . Client Key Data } if len ( config Auth Info . Username ) > 0 | | len ( config Auth Info . Password ) > 0 { merged Config . Username = config Auth Info . Username merged Config . Password = config Auth Info . Password } } 
func can Identify User ( config rest Config ) bool { return len ( config . Username ) > 0 | | ( len ( config . Cert File ) > 0 | | len ( config . Cert Data ) > 0 ) | | len ( config . Bearer Token ) > 0 } 
func ( config * direct Client Config ) Confirm Usable ( ) error { var validation Errors [ ] error validation Errors = append ( validation Errors , validate Auth Info ( config . get Auth Info Name ( ) , config . get Auth Info ( ) ) . . . ) validation Errors = append ( validation Errors , validate Cluster Info ( config . get Cluster Name ( ) , config . get Cluster ( ) ) . . . ) } return new Err Configuration Invalid ( validation Errors ) } 
func ( config * direct Client Config ) get Context ( ) clientcmd Context { contexts : = config . config . Contexts context Name : = config . get Context Name ( ) var merged Context clientcmd Context if config Context , exists : = contexts [ context Name ] ; exists { mergo . Merge ( & merged Context , config Context ) } } 
func validate Cluster Info ( cluster Name string , cluster Info clientcmd Cluster ) [ ] error { var validation Errors [ ] error if reflect . Deep Equal ( clientcmd Cluster { } , cluster Info ) { return [ ] error { err Empty Cluster } } if len ( cluster Info . Server ) = = 0 { if len ( cluster Name ) = = 0 { validation Errors = append ( validation Errors , errors . Errorf ( " " ) ) } else { validation Errors = append ( validation Errors , errors . Errorf ( " " , cluster Name ) ) } } } if len ( cluster Info . Certificate Authority ) ! = 0 { client Cert CA , err : = os . Open ( cluster Info . Certificate Authority ) defer client Cert CA . Close ( ) if err ! = nil { validation Errors = append ( validation Errors , errors . Errorf ( " " , cluster Info . Certificate Authority , cluster Name , err ) ) } } return validation Errors } 
func validate Auth Info ( auth Info Name string , auth Info clientcmd Auth Info ) [ ] error { var validation Errors [ ] error using Auth Path : = false methods : = make ( [ ] string , 0 , 3 ) if len ( auth Info . Token ) ! = 0 { methods = append ( methods , " " ) } if len ( auth Info . Username ) ! = 0 | | len ( auth Info . Password ) ! = 0 { methods = append ( methods , " " ) } if len ( auth Info . Client Certificate ) ! = 0 | | len ( auth Info . Client Certificate Data ) ! = 0 { } } } if len ( auth Info . Client Certificate ) ! = 0 { client Cert File , err : = os . Open ( auth Info . Client Certificate ) defer client Cert File . Close ( ) if err ! = nil { validation Errors = append ( validation Errors , errors . Errorf ( " " , auth Info . Client Certificate , auth Info Name , err ) ) } } if len ( auth Info . Client Key ) ! = 0 { client Key File , err : = os . Open ( auth Info . Client Key ) defer client Key File . Close ( ) if err ! = nil { validation Errors = append ( validation Errors , errors . Errorf ( " " , auth Info . Client Key , auth Info Name , err ) ) } } } } return validation Errors } 
func ( config * direct Client Config ) get Auth Info ( ) clientcmd Auth Info { auth Infos : = config . config . Auth Infos auth Info Name : = config . get Auth Info Name ( ) var merged Auth Info clientcmd Auth Info if config Auth Info , exists : = auth Infos [ auth Info Name ] ; exists { mergo . Merge ( & merged Auth Info , config Auth Info ) } } 
func ( config * direct Client Config ) get Cluster ( ) clientcmd Cluster { cluster Infos : = config . config . Clusters cluster Info Name : = config . get Cluster Name ( ) var merged Cluster Info clientcmd Cluster mergo . Merge ( & merged Cluster Info , default Cluster ) mergo . Merge ( & merged Cluster Info , env Var Cluster ) if config Cluster Info , exists : = cluster Infos [ cluster Info Name ] ; exists { mergo . Merge ( & merged Cluster Info , config Cluster Info ) } } 
func new Aggregate ( errlist [ ] error ) error { if len ( errlist ) = = 0 { return nil } for _ , e : = range errlist { if e ! = nil { errs = append ( errs , e ) } } if len ( errs ) = = 0 { return nil } return aggregate Err ( errs ) } 
func ( rules * client Config Loading Rules ) Load ( ) ( * clientcmd Config , error ) { errlist : = [ ] error { } kube Config Files : = [ ] string { } kubeconfigs : = [ ] * clientcmd Config { } } config , err : = load From File ( filename ) if os . Is Not Exist ( err ) { } if err ! = nil { errlist = append ( errlist , errors . Wrapf ( err , " \ " \ " " , filename ) ) continue } kubeconfigs = append ( kubeconfigs , config ) } for _ , kubeconfig : = range kubeconfigs { mergo . Merge ( map Config , kubeconfig ) } for i : = len ( kubeconfigs ) - 1 ; i > = 0 ; i - - { kubeconfig : = kubeconfigs [ i ] mergo . Merge ( non Map Config , kubeconfig ) } mergo . Merge ( config , map Config ) mergo . Merge ( config , non Map Config ) } return config , new Aggregate ( errlist ) } 
func load From File ( filename string ) ( * clientcmd Config , error ) { kubeconfig Bytes , err : = ioutil . Read File ( filename ) if err ! = nil { return nil , err } config , err : = load ( kubeconfig Bytes ) if err ! = nil { return nil , err } config . Auth Infos [ key ] = obj } for key , obj : = range config . Clusters { obj . Location Of Origin = filename config . Clusters [ key ] = obj } for key , obj : = range config . Contexts { obj . Location Of Origin = filename config . Contexts [ key ] = obj } if config . Auth Infos = = nil { config . Auth Infos = map [ string ] * clientcmd Auth Info { } } if config . Clusters = = nil { config . Clusters = map [ string ] * clientcmd Cluster { } } if config . Contexts = = nil { config . Contexts = map [ string ] * clientcmd Context { } } return config , nil } 
func load ( data [ ] byte ) ( * clientcmd Config , error ) { config : = clientcmd New Config ( ) } if err ! = nil { return nil , err } if err : = json . Unmarshal ( data , config ) ; err ! = nil { return nil , err } return config , nil } 
func resolve Local Paths ( config * clientcmd Config ) error { for _ , cluster : = range config . Clusters { if len ( cluster . Location Of Origin ) = = 0 { continue } base , err : = filepath . Abs ( filepath . Dir ( cluster . Location Of Origin ) ) if err ! = nil { return errors . Wrapf ( err , " " , cluster . Location Of Origin ) } if err : = resolve Paths ( get Cluster File References ( cluster ) , base ) ; err ! = nil { return err } } for _ , auth Info : = range config . Auth Infos { if len ( auth Info . Location Of Origin ) = = 0 { continue } base , err : = filepath . Abs ( filepath . Dir ( auth Info . Location Of Origin ) ) if err ! = nil { return errors . Wrapf ( err , " " , auth Info . Location Of Origin ) } if err : = resolve Paths ( get Auth Info File References ( auth Info ) , base ) ; err ! = nil { return err } } return nil } 
func resolve Paths ( refs [ ] * string , base string ) error { for _ , ref : = range refs { } } } return nil } 
func rest Client For ( config * rest Config ) ( * url . URL , * http . Client , error ) { if err ! = nil { return nil , nil , err } transport , err : = transport For ( config ) if err ! = nil { return nil , nil , err } var http Client * http . Client if transport ! = http . Default Transport { http Client = & http . Client { Transport : transport } } } 
func default Server URL ( host string , default TLS bool ) ( * url . URL , error ) { if host = = " " { return nil , errors . Errorf ( " " ) } base : = host host URL , err : = url . Parse ( base ) if err ! = nil { return nil , err } if host URL . Scheme = = " " { scheme : = " " if default TLS { scheme = " " } host URL , err = url . Parse ( scheme + base ) if err ! = nil { return nil , err } if host URL . Path ! = " " & & host URL . Path ! = " " { return nil , errors . Errorf ( " " , base ) } } } 
func default Server URLFor ( config * rest Config ) ( * url . URL , error ) { has Cert : = len ( config . Cert File ) ! = 0 | | len ( config . Cert Data ) ! = 0 default TLS : = has CA | | has Cert | | config . Insecure host : = config . Host if host = = " " { host = " " } } 
func is Config Transport TLS ( config rest Config ) bool { base URL , err : = default Server URLFor ( & config ) if err ! = nil { return false } return base URL . Scheme = = " " } 
func transport New ( config * rest Config ) ( http . Round Tripper , error ) { err error ) rt , err = tls Cache Get ( config ) if err ! = nil { return nil , err } } return rt , nil } 
func new Proxier With No Proxy CIDR ( delegate func ( req * http . Request ) ( * url . URL , error ) ) func ( req * http . Request ) ( * url . URL , error ) { no Proxy Rules : = strings . Split ( no Proxy Env , " " ) cidrs : = [ ] * net . IPNet { } for _ , no Proxy Rule : = range no Proxy Rules { _ , cidr , _ : = net . Parse CIDR ( no Proxy Rule ) if cidr ! = nil { cidrs = append ( cidrs , cidr ) } } if len ( cidrs ) = = 0 { return delegate } return func ( req * http . Request ) ( * url . URL , error ) { host : = req . URL . Host host , _ , err = net . Split Host Port ( req . URL . Host ) if err ! = nil { return delegate ( req ) } } ip : = net . Parse IP ( host ) if ip = = nil { return delegate ( req ) } for _ , cidr : = range cidrs { if cidr . Contains ( ip ) { return nil , nil } } return delegate ( req ) } } 
func tls Cache Get ( config * rest Config ) ( http . Round Tripper , error ) { if err ! = nil { return nil , err } } } return t , nil } 
func load TLSFiles ( c * rest Config ) error { var err error c . CAData , err = data From Slice Or File ( c . CAData , c . CAFile ) if err ! = nil { return err } c . Cert Data , err = data From Slice Or File ( c . Cert Data , c . Cert File ) if err ! = nil { return err } c . Key Data , err = data From Slice Or File ( c . Key Data , c . Key File ) if err ! = nil { return err } return nil } 
func ( c * rest Config ) Has CA ( ) bool { return len ( c . CAData ) > 0 | | len ( c . CAFile ) > 0 } 
func ( c * rest Config ) Has Cert Auth ( ) bool { return len ( c . Cert Data ) ! = 0 | | len ( c . Cert File ) ! = 0 } 
func clientcmd New Config ( ) * clientcmd Config { return & clientcmd Config { Clusters : make ( map [ string ] * clientcmd Cluster ) , Auth Infos : make ( map [ string ] * clientcmd Auth Info ) , Contexts : make ( map [ string ] * clientcmd Context ) , } } 
func new Image Source ( ctx context . Context , sys * types . System Context , ref daemon Reference ) ( types . Image Source , error ) { c , err : = new Docker Client ( sys ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err ! = nil { return nil , errors . Wrap ( err , " " ) } defer input Stream . Close ( ) src , err : = tarfile . New Source From Stream ( input Stream ) if err ! = nil { return nil , err } return & daemon Image Source { ref : ref , Source : src , } , nil } 
func manifest Schema 2From Components ( config manifest . Schema 2Descriptor , src types . Image Source , config Blob [ ] byte , layers [ ] manifest . Schema 2Descriptor ) generic Manifest { return & manifest Schema 2 { src : src , config Blob : config Blob , m : manifest . Schema 2From Components ( config , layers ) , } } 
func ( m * manifest Schema 2 ) OCIConfig ( ctx context . Context ) ( * imgspecv 1 . Image , error ) { config Blob , err : = m . Config Blob ( ctx ) if err ! = nil { return nil , err } if err : = json . Unmarshal ( config Blob , config OCI ) ; err ! = nil { return nil , err } return config OCI , nil } 
func ( m * manifest Schema 2 ) Config Blob ( ctx context . Context ) ( [ ] byte , error ) { if m . config Blob = = nil { if m . src = = nil { return nil , errors . Errorf ( " " ) } stream , _ , err : = m . src . Get Blob ( ctx , manifest . Blob Info From Schema 2Descriptor ( m . m . Config Descriptor ) , none . No Cache ) if err ! = nil { return nil , err } defer stream . Close ( ) blob , err : = ioutil . Read All ( stream ) if err ! = nil { return nil , err } computed Digest : = digest . From Bytes ( blob ) if computed Digest ! = m . m . Config Descriptor . Digest { return nil , errors . Errorf ( " " , computed Digest , m . m . Config Descriptor . Digest ) } m . config Blob = blob } return m . config Blob , nil } 
func ( m * manifest Schema 2 ) Inspect ( ctx context . Context ) ( * types . Image Inspect Info , error ) { getter : = func ( info types . Blob Info ) ( [ ] byte , error ) { if info . Digest ! = m . Config Info ( ) . Digest { } config , err : = m . Config Blob ( ctx ) if err ! = nil { return nil , err } return config , nil } return m . m . Inspect ( getter ) } 
func ( m * manifest Schema 2 ) Updated Image ( ctx context . Context , options types . Manifest Update Options ) ( types . Image , error ) { copy : = manifest Schema 2 { if options . Layer Infos ! = nil { if err : = copy . m . Update Layer Infos ( options . Layer Infos ) ; err ! = nil { return nil , err } } case imgspecv 1 . Media Type Image Manifest : return copy . convert To Manifest OCI 1 ( ctx ) default : return nil , errors . Errorf ( " " , manifest . Docker V 2Schema 2Media Type , options . Manifest MIMEType ) } return memory Image From Manifest ( & copy ) , nil } 
func ( m * manifest Schema 2 ) convert To Manifest Schema 1 ( ctx context . Context , dest types . Image Destination ) ( types . Image , error ) { config Bytes , err : = m . Config Blob ( ctx ) if err ! = nil { return nil , err } image Config : = & manifest . Schema 2Image { } if err : = json . Unmarshal ( config Bytes , image Config ) ; err ! = nil { return nil , err } history : = make ( [ ] manifest . Schema 1History , len ( image Config . History ) ) nonempty Layer Index : = 0 var parent V 1ID string v 1ID : = " " have Gzipped Empty Layer : = false if len ( image Config . History ) = = 0 { } for v 2Index , history Entry : = range image Config . History { parent V 1ID = v 1ID v 1Index : = len ( image Config . History ) - 1 - v 2Index var blob Digest digest . Digest if history Entry . Empty Layer { if ! have Gzipped Empty Layer { logrus . Debugf ( " " ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if info . Digest ! = Gzipped Empty Layer Digest { return nil , errors . Errorf ( " " , info . Digest , Gzipped Empty Layer Digest ) } have Gzipped Empty Layer = true } blob Digest = Gzipped Empty Layer Digest } else { if nonempty Layer Index > = len ( m . m . Layers Descriptors ) { return nil , errors . Errorf ( " " , len ( m . m . Layers Descriptors ) ) } blob Digest = m . m . Layers Descriptors [ nonempty Layer Index ] . Digest nonempty Layer Index + + } if err ! = nil { return nil , err } v 1ID = v fake Image : = manifest . Schema 1V 1Compatibility { ID : v 1ID , Parent : parent V 1ID , Comment : history Entry . Comment , Created : history Entry . Created , Author : history Entry . Author , Throw Away : history Entry . Empty Layer , } fake Image . Container Config . Cmd = [ ] string { history Entry . Created By } v 1Compatibility Bytes , err : = json . Marshal ( & fake Image ) if err ! = nil { return nil , errors . Errorf ( " " , fake Image ) } fs Layers [ v 1Index ] = manifest . Schema 1FSLayers { Blob Sum : blob Digest } history [ v 1Index ] = manifest . Schema 1History { V 1Compatibility : string ( v 1Compatibility Bytes ) } if err ! = nil { return nil , err } v 1Config , err : = v 1Config From Config JSON ( config Bytes , v 1ID , parent V 1ID , image Config . History [ len ( image Config . History ) - 1 ] . Empty Layer ) if err ! = nil { return nil , err } history [ 0 ] . V 1Compatibility = string ( v 1Config ) m 1 , err : = manifest Schema 1From Components ( dest . Reference ( ) . Docker Reference ( ) , fs Layers , history , image Config . Architecture ) if err ! = nil { return nil , err } return memory Image From Manifest ( m 1 ) , nil } 
func configured Signature Storage Base ( sys * types . System Context , ref docker Reference , write bool ) ( signature Storage Base , error ) { logrus . Debugf ( `Using registries .d directory %s for sigstore configuration ` , dir Path ) config , err : = load And Merge Config ( dir Path ) if err ! = nil { return nil , err } top Level : = config . signature Top Level ( ref , write ) if top Level = = " " { return nil , nil } url , err : = url . Parse ( top Level ) if err ! = nil { return nil , errors . Wrapf ( err , " " , top Level ) } if path . Clean ( repo ) ! = repo { } url . Path = url . Path + " " + repo return url , nil } 
func registries Dir Path ( sys * types . System Context ) string { if sys ! = nil { if sys . Registries Dir Path ! = " " { return sys . Registries Dir Path } if sys . Root For Implicit Absolute Paths ! = " " { return filepath . Join ( sys . Root For Implicit Absolute Paths , system Registries Dir Path ) } } return system Registries Dir Path } 
func load And Merge Config ( dir Path string ) ( * registry Configuration , error ) { merged Config : = registry Configuration { Docker : map [ string ] registry Namespace { } } docker Default Merged From : = " " ns Merged From : = map [ string ] string { } dir , err : = os . Open ( dir Path ) if err ! = nil { if os . Is Not Exist ( err ) { return & merged Config , nil } return nil , err } config Names , err : = dir . Readdirnames ( 0 ) if err ! = nil { return nil , err } for _ , config Name : = range config Names { if ! strings . Has Suffix ( config Name , " " ) { continue } config Path : = filepath . Join ( dir Path , config Name ) config Bytes , err : = ioutil . Read File ( config Path ) if err ! = nil { return nil , err } var config registry Configuration err = yaml . Unmarshal ( config Bytes , & config ) if err ! = nil { return nil , errors . Wrapf ( err , " " , config Path ) } if config . Default Docker ! = nil { if merged Config . Default Docker ! = nil { return nil , errors . Errorf ( `Error parsing signature storage configuration : "default -docker " defined both in " %s " and " %s " ` , docker Default Merged From , config Path ) } merged Config . Default Docker = config . Default Docker docker Default Merged From = config Path } for ns Name , ns Config : = range config . Docker { } merged Config . Docker [ ns Name ] = ns Config ns Merged From [ ns Name ] = config Path } } return & merged Config , nil } 
func ( config * registry Configuration ) signature Top Level ( ref docker Reference , write bool ) string { if config . Docker ! = nil { if ns , ok : = config . Docker [ identity ] ; ok { logrus . Debugf ( ` Using "docker " namespace %s ` , identity ) if url : = ns . signature Top Level ( write ) ; url ! = " " { return url } } if url : = ns . signature Top Level ( write ) ; url ! = " " { return url } } } } if url : = config . Default Docker . signature Top Level ( write ) ; url ! = " " { return url } } logrus . Debugf ( " " , ref . Policy Configuration Identity ( ) ) return " " } 
func ( ns registry Namespace ) signature Top Level ( write bool ) string { if write & & ns . Sig Store Staging ! = " " { logrus . Debugf ( ` Using %s ` , ns . Sig Store Staging ) return ns . Sig Store Staging } if ns . Sig Store ! = " " { logrus . Debugf ( ` Using %s ` , ns . Sig Store ) return ns . Sig Store } return " " } 
func signature Storage URL ( base signature Storage Base , manifest Digest digest . Digest , index int ) * url . URL { if base = = nil { return nil } url : = * base url . Path = fmt . Sprintf ( " " , url . Path , manifest Digest . Algorithm ( ) , manifest Digest . Hex ( ) , index + 1 ) return & url } 
func ( t openshift Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func ( t openshift Transport ) Validate Policy Configuration Scope ( scope string ) error { if scope Regexp . Find String Index ( scope ) = = nil { return errors . Errorf ( " " , scope ) } return nil } 
func Parse Reference ( ref string ) ( types . Image Reference , error ) { r , err : = reference . Parse Normalized Named ( ref ) if err ! = nil { return nil , errors . Wrapf ( err , " " , ref ) } tagged , ok : = r . ( reference . Named Tagged ) if ! ok { return nil , errors . Errorf ( " " , ref ) } return New Reference ( tagged ) } 
func New Reference ( docker Ref reference . Named Tagged ) ( types . Image Reference , error ) { r : = strings . Split N ( reference . Path ( docker Ref ) , " " , 3 ) if len ( r ) ! = 2 { return nil , errors . Errorf ( " " , reference . Familiar String ( docker Ref ) ) } return openshift Reference { namespace : r [ 0 ] , stream : r [ 1 ] , docker Reference : docker Ref , } , nil } 
func ( ref openshift Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { src , err : = new Image Source ( sys , ref ) if err ! = nil { return nil , err } return generic Image . From Source ( ctx , sys , src ) } 
func server Default ( ) * tls . Config { return & tls . Config { } 
func docker Cert Dir ( sys * types . System Context , host Port string ) ( string , error ) { if sys ! = nil & & sys . Docker Cert Path ! = " " { return sys . Docker Cert Path , nil } if sys ! = nil & & sys . Docker Per Host Cert Dir Path ! = " " { return filepath . Join ( sys . Docker Per Host Cert Dir Path , host Port ) , nil } var ( host Cert Dir string full Cert Dir Path string ) for _ , system Per Host Cert Dir Path : = range system Per Host Cert Dir Paths { if sys ! = nil & & sys . Root For Implicit Absolute Paths ! = " " { host Cert Dir = filepath . Join ( sys . Root For Implicit Absolute Paths , system Per Host Cert Dir Path ) } else { host Cert Dir = system Per Host Cert Dir Path } full Cert Dir Path = filepath . Join ( host Cert Dir , host Port ) _ , err : = os . Stat ( full Cert Dir Path ) if err = = nil { break } if os . Is Not Exist ( err ) { continue } if os . Is Permission ( err ) { logrus . Debugf ( " " , err ) continue } if err ! = nil { return " " , err } } return full Cert Dir Path , nil } 
func new Docker Client From Ref ( sys * types . System Context , ref docker Reference , write bool , actions string ) ( * docker Client , error ) { registry : = reference . Domain ( ref . ref ) username , password , err : = config . Get Authentication ( sys , registry ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } sig Base , err : = configured Signature Storage Base ( sys , ref , write ) if err ! = nil { return nil , err } client , err : = new Docker Client ( sys , registry , ref . ref . Name ( ) ) if err ! = nil { return nil , err } client . username = username client . password = password client . signature Base = sig Base client . scope . actions = actions client . scope . remote Name = reference . Path ( ref . ref ) return client , nil } 
func new Docker Client ( sys * types . System Context , registry , reference string ) ( * docker Client , error ) { host Name : = registry if registry = = docker Hostname { registry = docker Registry } tls Client Config : = server Default ( ) if err ! = nil { return nil , err } if err : = tlsclientconfig . Setup Certificates ( cert Dir , tls Client Config ) ; err ! = nil { return nil , err } reg , err : = sysregistriesv 2 . Find Registry ( sys , reference ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } if reg ! = nil { skip Verify = reg . Insecure } tls Client Config . Insecure Skip Verify = skip Verify return & docker Client { sys : sys , registry : registry , tls Client Config : tls Client Config , } , nil } 
func Check Auth ( ctx context . Context , sys * types . System Context , username , password , registry string ) error { client , err : = new Docker Client ( sys , registry , registry ) if err ! = nil { return errors . Wrapf ( err , " " ) } client . username = username client . password = password resp , err : = client . make Request ( ctx , " " , " " , nil , nil , v 2Auth , nil ) if err ! = nil { return err } defer resp . Body . Close ( ) switch resp . Status Code { case http . Status OK : return nil case http . Status Unauthorized : return Err Unauthorized For Credentials default : return errors . Errorf ( " " , resp . Status Code , http . Status Text ( resp . Status Code ) ) } } 
func Search Registry ( ctx context . Context , sys * types . System Context , registry , image string , limit int ) ( [ ] Search Result , error ) { type V 2Results struct { } type V 1Results struct { } v 2Res : = & V 2Results { } v 1Res : = & V 1Results { } if err ! = nil { return nil , errors . Wrapf ( err , " " ) } if registry = = docker Hostname { hostname = docker V 1Hostname } client , err : = new Docker Client ( sys , hostname , registry ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } client . username = username client . password = password q : = u . Query ( ) q . Set ( " " , image ) q . Set ( " " , strconv . Itoa ( limit ) ) u . Raw Query = q . Encode ( ) logrus . Debugf ( " " ) resp , err : = client . make Request ( ctx , " " , u . String ( ) , nil , nil , no Auth , nil ) if err ! = nil { logrus . Debugf ( " " , registry , err ) } else { defer resp . Body . Close ( ) if resp . Status Code ! = http . Status OK { logrus . Debugf ( " " , registry , resp . Status Code , http . Status Text ( resp . Status Code ) ) } else { if err : = json . New Decoder ( resp . Body ) . Decode ( v 1Res ) ; err ! = nil { return nil , err } return v 1Res . Results , nil } } } logrus . Debugf ( " " ) resp , err : = client . make Request ( ctx , " " , " " , nil , nil , v 2Auth , nil ) if err ! = nil { logrus . Debugf ( " " , registry , err ) } else { defer resp . Body . Close ( ) if resp . Status Code ! = http . Status OK { logrus . Errorf ( " " , registry , resp . Status Code , http . Status Text ( resp . Status Code ) ) } else { if err : = json . New Decoder ( resp . Body ) . Decode ( v 2Res ) ; err ! = nil { return nil , err } search Res : = [ ] Search Result { } for _ , repo : = range v 2Res . Repositories { if strings . Contains ( repo , image ) { res : = Search Result { Name : repo , } search Res = append ( search Res , res ) } } return search Res , nil } } return nil , errors . Wrapf ( err , " " , registry ) } 
func ( c * docker Client ) make Request ( ctx context . Context , method , path string , headers map [ string ] [ ] string , stream io . Reader , auth send Auth , extra Scope * auth Scope ) ( * http . Response , error ) { if err : = c . detect Properties ( ctx ) ; err ! = nil { return nil , err } url : = fmt . Sprintf ( " " , c . scheme , c . registry , path ) return c . make Request To Resolved URL ( ctx , method , url , headers , stream , - 1 , auth , extra Scope ) } 
func ( c * docker Client ) make Request To Resolved URL ( ctx context . Context , method , url string , headers map [ string ] [ ] string , stream io . Reader , stream Len int 6 4 , auth send Auth , extra Scope * auth Scope ) ( * http . Response , error ) { req , err : = http . New Request ( method , url , stream ) if err ! = nil { return nil , err } req = req . With Context ( ctx ) if stream Len ! = - 1 { } req . Header . Set ( " " , " " ) for n , h : = range headers { for _ , hh : = range h { req . Header . Add ( n , hh ) } } if c . sys ! = nil & & c . sys . Docker Registry User Agent ! = " " { req . Header . Add ( " " , c . sys . Docker Registry User Agent ) } if auth = = v 2Auth { if err : = c . setup Request Auth ( req , extra Scope ) ; err ! = nil { return nil , err } } logrus . Debugf ( " " , method , url ) } 
func ( c * docker Client ) do HTTP ( req * http . Request ) ( * http . Response , error ) { tr : = tlsclientconfig . New Transport ( ) tr . TLSClient Config = c . tls Client Config http Client : = & http . Client { Transport : tr } return http Client . Do ( req ) } 
func ( c * docker Client ) setup Request Auth ( req * http . Request , extra Scope * auth Scope ) error { if len ( c . challenges ) = = 0 { return nil } scheme Names : = make ( [ ] string , 0 , len ( c . challenges ) ) for _ , challenge : = range c . challenges { scheme Names = append ( scheme Names , challenge . Scheme ) switch challenge . Scheme { case " " : req . Set Basic Auth ( c . username , c . password ) return nil case " " : cache Key : = " " scopes : = [ ] auth Scope { c . scope } if extra Scope ! = nil { scopes = append ( scopes , * extra Scope ) } var token bearer Token t , in Cache : = c . token Cache . Load ( cache Key ) if in Cache { token = t . ( bearer Token ) } if ! in Cache | | time . Now ( ) . After ( token . expiration Time ) { t , err : = c . get Bearer Token ( req . Context ( ) , challenge , scopes ) if err ! = nil { return err } token = * t c . token Cache . Store ( cache Key , token ) } req . Header . Set ( " " , fmt . Sprintf ( " " , token . Token ) ) return nil default : logrus . Debugf ( " " , challenge . Scheme ) } } logrus . Infof ( " " , strings . Join ( scheme Names , " " ) ) return nil } 
func ( c * docker Client ) detect Properties Helper ( ctx context . Context ) error { if c . scheme ! = " " { return nil } } ping : = func ( scheme string ) error { url : = fmt . Sprintf ( resolved Ping V 2URL , scheme , c . registry ) resp , err : = c . make Request To Resolved URL ( ctx , " " , url , nil , nil , - 1 , no Auth , nil ) if err ! = nil { logrus . Debugf ( " " , url , err . Error ( ) , err ) return err } defer resp . Body . Close ( ) logrus . Debugf ( " " , url , resp . Status Code ) if resp . Status Code ! = http . Status OK & & resp . Status Code ! = http . Status Unauthorized { return errors . Errorf ( " " , c . registry , resp . Status Code , http . Status Text ( resp . Status Code ) ) } c . challenges = parse Auth Header ( resp . Header ) c . scheme = scheme c . supports Signatures = resp . Header . Get ( " " ) = = " " return nil } err : = ping ( " " ) if err ! = nil & & c . tls Client Config . Insecure Skip Verify { err = ping ( " " ) } if err ! = nil { err = errors . Wrap ( err , " " ) if c . sys ! = nil & & c . sys . Docker Disable V 1Ping { return err } resp , err : = c . make Request To Resolved URL ( ctx , " " , url , nil , nil , - 1 , no Auth , nil ) if err ! = nil { logrus . Debugf ( " " , url , err . Error ( ) , err ) return false } defer resp . Body . Close ( ) logrus . Debugf ( " " , url , resp . Status Code ) if resp . Status Code ! = http . Status OK & & resp . Status Code ! = http . Status Unauthorized { return false } return true } is V 1 : = ping V 1 ( " " ) if ! is V 1 & & c . tls Client Config . Insecure Skip Verify { is V 1 = ping V 1 ( " " ) } if is V 1 { err = Err V 1Not Supported } } return err } 
func ( c * docker Client ) detect Properties ( ctx context . Context ) error { c . detect Properties Once . Do ( func ( ) { c . detect Properties Error = c . detect Properties Helper ( ctx ) } ) return c . detect Properties Error } 
func ( c * docker Client ) get Extensions Signatures ( ctx context . Context , ref docker Reference , manifest Digest digest . Digest ) ( * extension Signature List , error ) { path : = fmt . Sprintf ( extensions Signature Path , reference . Path ( ref . ref ) , manifest Digest ) res , err : = c . make Request ( ctx , " " , path , nil , nil , v 2Auth , nil ) if err ! = nil { return nil , err } defer res . Body . Close ( ) if res . Status Code ! = http . Status OK { return nil , errors . Wrapf ( client . Handle Error Response ( res ) , " " , manifest Digest , ref . ref . Name ( ) ) } body , err : = ioutil . Read All ( res . Body ) if err ! = nil { return nil , err } var parsed Body extension Signature List if err : = json . Unmarshal ( body , & parsed Body ) ; err ! = nil { return nil , errors . Wrapf ( err , " " ) } return & parsed Body , nil } 
func Setup Certificates ( dir string , tlsc * tls . Config ) error { logrus . Debugf ( " " , dir ) fs , err : = ioutil . Read Dir ( dir ) if err ! = nil { if os . Is Not Exist ( err ) { return nil } if os . Is Permission ( err ) { logrus . Debugf ( " " , dir , err ) return nil } return err } for _ , f : = range fs { full Path : = filepath . Join ( dir , f . Name ( ) ) if strings . Has Suffix ( f . Name ( ) , " " ) { logrus . Debugf ( " " , full Path ) data , err : = ioutil . Read File ( full Path ) if err ! = nil { if os . Is Not Exist ( err ) { continue } return err } if tlsc . Root CAs = = nil { system Pool , err : = tlsconfig . System Cert Pool ( ) if err ! = nil { return errors . Wrap ( err , " " ) } tlsc . Root CAs = system Pool } tlsc . Root CAs . Append Certs From PEM ( data ) } if strings . Has Suffix ( f . Name ( ) , " " ) { cert Name : = f . Name ( ) key Name : = cert Name [ : len ( cert Name ) - 5 ] + " " logrus . Debugf ( " " , full Path ) if ! has File ( fs , key Name ) { return errors . Errorf ( " " , key Name , cert Name ) } cert , err : = tls . Load X 5 0 9Key Pair ( filepath . Join ( dir , cert Name ) , filepath . Join ( dir , key Name ) ) if err ! = nil { return err } tlsc . Certificates = append ( tlsc . Certificates , cert ) } if strings . Has Suffix ( f . Name ( ) , " " ) { key Name : = f . Name ( ) cert Name : = key Name [ : len ( key Name ) - 4 ] + " " logrus . Debugf ( " " , full Path ) if ! has File ( fs , cert Name ) { return errors . Errorf ( " " , cert Name , key Name ) } } } return nil } 
func New Transport ( ) * http . Transport { direct : = & net . Dialer { Timeout : 3 0 * time . Second , Keep Alive : 3 0 * time . Second , Dual Stack : true , } tr : = & http . Transport { Proxy : http . Proxy From Environment , Dial : direct . Dial , TLSHandshake Timeout : 1 0 * time . Second , proxy Dialer , err : = sockets . Dialer From Environment ( direct ) if err = = nil { tr . Dial = proxy Dialer . Dial } return tr } 
func normalize Registries ( regs * registries ) { for i : = range regs . Registries { regs . Registries [ i ] = strings . Trim Right ( regs . Registries [ i ] , " " ) } } 
func read Registry Conf ( sys * types . System Context ) ( [ ] byte , error ) { return ioutil . Read File ( Registries Conf Path ( sys ) ) } 
func load Registry Conf ( sys * types . System Context ) ( * toml Config , error ) { config : = & toml Config { } config Bytes , err : = read Conf ( sys ) if err ! = nil { return nil , err } err = toml . Unmarshal ( config Bytes , & config ) normalize Registries ( & config . Registries . Search ) normalize Registries ( & config . Registries . Insecure ) normalize Registries ( & config . Registries . Block ) return config , err } 
func Get Registries ( sys * types . System Context ) ( [ ] string , error ) { config , err : = load Registry Conf ( sys ) if err ! = nil { return nil , err } return config . Registries . Search . Registries , nil } 
func Get Insecure Registries ( sys * types . System Context ) ( [ ] string , error ) { config , err : = load Registry Conf ( sys ) if err ! = nil { return nil , err } return config . Registries . Insecure . Registries , nil } 
func Registries Conf Path ( ctx * types . System Context ) string { path : = system Registries Conf Path if ctx ! = nil { if ctx . System Registries Conf Path ! = " " { path = ctx . System Registries Conf Path } else if ctx . Root For Implicit Absolute Paths ! = " " { path = filepath . Join ( ctx . Root For Implicit Absolute Paths , system Registries Conf Path ) } } return path } 
func New Optional Bool ( b bool ) Optional Bool { o : = Optional Bool False if b = = true { o = Optional Bool True } return o } 
func ( pc * Policy Context ) change State ( expected , new policy Context State ) error { if pc . state ! = expected { return errors . Errorf ( ` "Invalid Policy Context state , expected " %s " , found " %s " ` , expected , pc . state ) } pc . state = new return nil } 
func New Policy Context ( policy * Policy ) ( * Policy Context , error ) { pc : = & Policy Context { Policy : policy , state : pc Initializing } } return pc , nil } 
func ( pc * Policy Context ) Destroy ( ) error { if err : = pc . change State ( pc Ready , pc Destroying ) ; err ! = nil { return err } } 
func policy Identity Log Name ( ref types . Image Reference ) string { return ref . Transport ( ) . Name ( ) + " " + ref . Policy Configuration Identity ( ) } 
func ( pc * Policy Context ) requirements For Image Ref ( ref types . Image Reference ) Policy Requirements { if transport Scopes , ok : = pc . Policy . Transports [ transport Name ] ; ok { if req , ok : = transport Scopes [ identity ] ; ok { logrus . Debugf ( ` Using transport " %s " policy section %s ` , transport Name , identity ) return req } return req } } return req } } logrus . Debugf ( " " ) return pc . Policy . Default } 
func ( pc * Policy Context ) Get Signatures With Accepted Author ( ctx context . Context , image types . Unparsed Image ) ( sigs [ ] * Signature , final Err error ) { if err : = pc . change State ( pc Ready , pc In Use ) ; err ! = nil { return nil , err } defer func ( ) { if err : = pc . change State ( pc In Use , pc Ready ) ; err ! = nil { sigs = nil final Err = err } } ( ) logrus . Debugf ( " " , policy Identity Log Name ( image . Reference ( ) ) ) reqs : = pc . requirements For Image Ref ( image . Reference ( ) ) if err ! = nil { return nil , err } res : = make ( [ ] * Signature , 0 , len ( unverified Signatures ) ) for sig Number , sig : = range unverified Signatures { var accepted Sig * Signature rejected : = false interpreting Reqs : for req Number , req : = range reqs { rejected = true break interpreting Reqs } logrus . Debugf ( " " , req Number ) if accepted Sig = = nil { accepted Sig = as } else if * as ! = * accepted Sig { rejected = true accepted Sig = nil break interpreting Reqs } case sar Rejected : logrus . Debugf ( " " , req Number , err . Error ( ) ) rejected = true break interpreting Reqs case sar Unknown : if err ! = nil { rejected = true break interpreting Reqs } logrus . Debugf ( " " , req Number ) default : rejected = true break interpreting Reqs } } res = append ( res , accepted Sig ) } else { logrus . Debugf ( " " ) } } return res , nil } 
func ( pc * Policy Context ) Is Running Image Allowed ( ctx context . Context , image types . Unparsed Image ) ( res bool , final Err error ) { if err : = pc . change State ( pc Ready , pc In Use ) ; err ! = nil { return false , err } defer func ( ) { if err : = pc . change State ( pc In Use , pc Ready ) ; err ! = nil { res = false final Err = err } } ( ) logrus . Debugf ( " " , policy Identity Log Name ( image . Reference ( ) ) ) reqs : = pc . requirements For Image Ref ( image . Reference ( ) ) if len ( reqs ) = = 0 { return false , Policy Requirement Error ( " " ) } for req Number , req : = range reqs { if ! allowed { logrus . Debugf ( " " , req Number ) return false , err } logrus . Debugf ( " " , req Number ) } return true , nil } 
func Parse Image Name ( img Name string ) ( types . Image Reference , error ) { parts : = strings . Split N ( img Name , " " , 2 ) if len ( parts ) ! = 2 { return nil , errors . Errorf ( `Invalid image name " %s " , expected colon -separated transport :reference ` , img Name ) } transport : = transports . Get ( parts [ 0 ] ) if transport = = nil { return nil , errors . Errorf ( `Invalid image name " %s " , unknown transport " %s " ` , img Name , parts [ 0 ] ) } return transport . Parse Reference ( parts [ 1 ] ) } 
func Blob Info From OCI 1Descriptor ( desc imgspecv 1 . Descriptor ) types . Blob Info { return types . Blob Info { Digest : desc . Digest , Size : desc . Size , URLs : desc . URLs , Annotations : desc . Annotations , Media Type : desc . Media Type , } } 
func OCI 1From Manifest ( manifest [ ] byte ) ( * OCI 1 , error ) { oci 1 : = OCI 1 { } if err : = json . Unmarshal ( manifest , & oci 1 ) ; err ! = nil { return nil , err } return & oci 1 , nil } 
func OCI 1From Components ( config imgspecv 1 . Descriptor , layers [ ] imgspecv 1 . Descriptor ) * OCI 1 { return & OCI 1 { imgspecv 1 . Manifest { Versioned : specs . Versioned { Schema Version : 2 } , Config : config , Layers : layers , } , } } 
func ( m * OCI 1 ) Layer Infos ( ) [ ] Layer Info { blobs : = [ ] Layer Info { } for _ , layer : = range m . Layers { blobs = append ( blobs , Layer Info { Blob Info : Blob Info From OCI 1Descriptor ( layer ) , Empty Layer : false , } ) } return blobs } 
func ( m * OCI 1 ) Update Layer Infos ( layer Infos [ ] types . Blob Info ) error { if len ( m . Layers ) ! = len ( layer Infos ) { return errors . Errorf ( " " , len ( m . Layers ) , len ( layer Infos ) ) } original : = m . Layers m . Layers = make ( [ ] imgspecv 1 . Descriptor , len ( layer Infos ) ) for i , info : = range layer Infos { m . Layers [ i ] . Media Type = original [ i ] . Media Type m . Layers [ i ] . Digest = info . Digest m . Layers [ i ] . Size = info . Size m . Layers [ i ] . Annotations = info . Annotations m . Layers [ i ] . URLs = info . URLs } return nil } 
func ( m * OCI 1 ) Inspect ( config Getter func ( types . Blob Info ) ( [ ] byte , error ) ) ( * types . Image Inspect Info , error ) { config , err : = config Getter ( m . Config Info ( ) ) if err ! = nil { return nil , err } v 1 : = & imgspecv 1 . Image { } if err : = json . Unmarshal ( config , v 1 ) ; err ! = nil { return nil , err } d 1 : = & Schema 2V 1Image { } json . Unmarshal ( config , d 1 ) i : = & types . Image Inspect Info { Tag : " " , Created : v 1 . Created , Docker Version : d 1 . Docker Version , Labels : v 1 . Config . Labels , Architecture : v 1 . Architecture , Os : v 1 . OS , Layers : layer Infos To Strings ( m . Layer Infos ( ) ) , } return i , nil } 
func ( m * OCI 1 ) Image ID ( [ ] digest . Digest ) ( string , error ) { if err : = m . Config . Digest . Validate ( ) ; err ! = nil { return " " , err } return m . Config . Digest . Hex ( ) , nil } 
func ( t docker Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func Parse Reference ( ref String string ) ( types . Image Reference , error ) { if ! strings . Has Prefix ( ref String , " " ) { return nil , errors . Errorf ( " " , ref String ) } ref , err : = reference . Parse Normalized Named ( strings . Trim Prefix ( ref String , " " ) ) if err ! = nil { return nil , err } ref = reference . Tag Name Only ( ref ) return New Reference ( ref ) } 
func new Reference ( ref reference . Named ) ( docker Reference , error ) { if reference . Is Name Only ( ref ) { return docker Reference { } , errors . Errorf ( " " , reference . Familiar String ( ref ) ) } _ , is Digested : = ref . ( reference . Canonical ) if is Tagged & & is Digested { return docker Reference { } , errors . Errorf ( " " ) } return docker Reference { ref : ref , } , nil } 
func ( ref docker Reference ) Policy Configuration Identity ( ) string { res , err : = policyconfiguration . Docker Reference Identity ( ref . ref ) if res = = " " | | err ! = nil { } return res } 
func ( ref docker Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { return new Image ( ctx , sys , ref ) } 
func ( ref docker Reference ) Delete Image ( ctx context . Context , sys * types . System Context ) error { return delete Image ( ctx , sys , ref ) } 
func ( ref docker Reference ) tag Or Digest ( ) ( string , error ) { if ref , ok : = ref . ref . ( reference . Canonical ) ; ok { return ref . Digest ( ) . String ( ) , nil } if ref , ok : = ref . ref . ( reference . Named Tagged ) ; ok { return ref . Tag ( ) , nil } } 
func new Digesting Reader ( source io . Reader , expected Digest digest . Digest ) ( * digesting Reader , error ) { if err : = expected Digest . Validate ( ) ; err ! = nil { return nil , errors . Errorf ( " " , expected Digest ) } digest Algorithm : = expected Digest . Algorithm ( ) if ! digest Algorithm . Available ( ) { return nil , errors . Errorf ( " " , expected Digest , digest Algorithm ) } return & digesting Reader { source : source , digester : digest Algorithm . Digester ( ) , expected Digest : expected Digest , validation Failed : false , } , nil } 
func Image ( ctx context . Context , policy Context * signature . Policy Context , dest Ref , src Ref types . Image Reference , options * Options ) ( manifest [ ] byte , ret Err error ) { } report Writer : = ioutil . Discard if options . Report Writer ! = nil { report Writer = options . Report Writer } dest , err : = dest Ref . New Image Destination ( ctx , options . Destination Ctx ) if err ! = nil { return nil , errors . Wrapf ( err , " " , transports . Image Name ( dest Ref ) ) } defer func ( ) { if err : = dest . Close ( ) ; err ! = nil { ret Err = errors . Wrapf ( ret Err , " " , err ) } } ( ) raw Source , err : = src Ref . New Image Source ( ctx , options . Source Ctx ) if err ! = nil { return nil , errors . Wrapf ( err , " " , transports . Image Name ( src Ref ) ) } defer func ( ) { if err : = raw Source . Close ( ) ; err ! = nil { ret Err = errors . Wrapf ( ret Err , " " , err ) } } ( ) if ! is TTY ( report Writer ) { progress Output = ioutil . Discard } copy In Parallel : = dest . Has Thread Safe Put Blob ( ) & & raw Source . Has Thread Safe Get Blob ( ) c : = & copier { dest : dest , raw Source : raw Source , report Writer : report Writer , progress Output : progress Output , progress Interval : options . Progress Interval , progress : options . Progress , copy In Parallel : copy In Parallel , unparsed Toplevel : = image . Unparsed Instance ( raw Source , nil ) multi Image , err : = is Multi Image ( ctx , unparsed Toplevel ) if err ! = nil { return nil , errors . Wrapf ( err , " " , transports . Image Name ( src Ref ) ) } if ! multi Image { } } else { if err ! = nil { return nil , errors . Wrapf ( err , " " , transports . Image Name ( src Ref ) ) } logrus . Debugf ( " " , instance Digest ) unparsed Instance : = image . Unparsed Instance ( raw Source , & instance Digest ) if manifest , err = c . copy One Image ( ctx , policy Context , options , unparsed Instance ) ; err ! = nil { return nil , err } } if err : = c . dest . Commit ( ctx ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return manifest , nil } 
func ( c * copier ) copy One Image ( ctx context . Context , policy Context * signature . Policy Context , options * Options , unparsed Image * image . Unparsed Image ) ( manifest Bytes [ ] byte , ret Err error ) { if err ! = nil { } if multi Image { return nil , fmt . Errorf ( " " ) } } src , err : = image . From Unparsed Image ( ctx , options . Source Ctx , unparsed Image ) if err ! = nil { return nil , errors . Wrapf ( err , " " , transports . Image Name ( c . raw Source . Reference ( ) ) ) } if named : = c . dest . Reference ( ) . Docker Reference ( ) ; named ! = nil { if digested , ok : = named . ( reference . Digested ) ; ok { dest Is Digested Reference = true source Manifest , _ , err : = src . Manifest ( ctx ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } matches , err : = manifest . Matches Digest ( source Manifest , digested . Digest ( ) ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } if ! matches { return nil , errors . New ( " " ) } } } if err : = check Image Destination For Current Runtime OS ( ctx , options . Destination Ctx , src , c . dest ) ; err ! = nil { return nil , err } var sigs [ ] [ ] byte if options . Remove Signatures { sigs = [ ] [ ] byte { } } else { c . Printf ( " \n " ) s , err : = src . Signatures ( ctx ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } sigs = s } if len ( sigs ) ! = 0 { c . Printf ( " \n " ) if err : = c . dest . Supports Signatures ( ctx ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } ic : = image Copier { c : c , manifest Updates : & types . Manifest Update Options { Information Only : types . Manifest Update Information { Destination : c . dest } } , src : src , if err : = ic . update Embedded Docker Reference ( ) ; err ! = nil { return nil , err } if err ! = nil { return nil , err } if err : = ic . copy Layers ( ctx ) ; err ! = nil { return nil , err } if err ! = nil { logrus . Debugf ( " " , preferred Manifest MIMEType , err ) } } for _ , manifest MIMEType : = range other Manifest MIMEType Candidates { logrus . Debugf ( " m nifest MIMEType ) ic . manifest Updates . Manifest MIMEType = manifest MIMEType attempted Manifest , err : = ic . copy Updated Config And Manifest ( ctx ) if err ! = nil { logrus . Debugf ( " " , manifest MIMEType , err ) errs = append ( errs , fmt . Sprintf ( " " , manifest MIMEType , err ) ) continue } / / We have successfully uploaded a manifest . manifest Bytes = attempted Manifest errs = nil / / Mark this as a success so that we don 't abort below . break } if errs ! = nil { return nil , fmt . Errorf ( " " , strings . Join ( errs , " " ) ) } } if options . Sign By ! = " " { new Sig , err : = c . create Signature ( manifest Bytes , options . Sign By ) if err ! = nil { return nil , err } sigs = append ( sigs , new Sig ) } c . Printf ( " \n " ) if err : = c . dest . Put Signatures ( ctx , sigs ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return manifest Bytes , nil } 
func ( c * copier ) Printf ( format string , a . . . interface { } ) { fmt . Fprintf ( c . report Writer , format , a . . . ) } 
func ( ic * image Copier ) update Embedded Docker Reference ( ) error { if ic . c . dest . Ignores Embedded Docker Reference ( ) { return nil } dest Ref : = ic . c . dest . Reference ( ) . Docker Reference ( ) if dest Ref = = nil { return nil } if ! ic . src . Embedded Docker Reference Conflicts ( dest Ref ) { return nil } if ! ic . can Modify Manifest { return errors . Errorf ( " " , transports . Image Name ( ic . c . dest . Reference ( ) ) , dest Ref . String ( ) ) } ic . manifest Updates . Embedded Docker Reference = dest Ref return nil } 
func is TTY ( w io . Writer ) bool { if f , ok : = w . ( * os . File ) ; ok { return terminal . Is Terminal ( int ( f . Fd ( ) ) ) } return false } 
func ( ic * image Copier ) copy Layers ( ctx context . Context ) error { src Infos : = ic . src . Layer Infos ( ) num Layers : = len ( src Infos ) updated Src Infos , err : = ic . src . Layer Infos For Copy ( ctx ) if err ! = nil { return err } src Infos Updated : = false if updated Src Infos ! = nil & & ! reflect . Deep Equal ( src Infos , updated Src Infos ) { if ! ic . can Modify Manifest { return errors . Errorf ( " " ) } src Infos = updated Src Infos src Infos Updated = true } type copy Layer Data struct { dest Info types . Blob Info diff ID digest . Digest err error } copy Group . Add ( num Layers ) if ic . c . copy In Parallel { copy Semaphore = semaphore . New Weighted ( int 6 4 ( max Parallel Downloads ) ) } else { copy Semaphore = semaphore . New Weighted ( int 6 4 ( 1 ) ) } data : = make ( [ ] copy Layer Data , num Layers ) copy Layer Helper : = func ( index int , src Layer types . Blob Info , pool * mpb . Progress ) { defer copy Semaphore . Release ( 1 ) defer copy Group . Done ( ) cld : = copy Layer Data { } if ic . c . dest . Accepts Foreign Layer URLs ( ) & & len ( src Layer . URLs ) ! = 0 { } else { cld . dest Info = src Layer logrus . Debugf ( " " , cld . dest Info . Digest , ic . c . dest . Reference ( ) . Transport ( ) . Name ( ) ) } } else { cld . dest Info , cld . diff ID , cld . err = ic . copy Layer ( ctx , src Layer , pool ) } data [ index ] = cld } func ( ) { defer progress Cleanup ( ) for i , src Layer : = range src Infos { copy Semaphore . Acquire ( ctx , 1 ) go copy Layer Helper ( i , src Layer , progress Pool ) } } ( ) dest Infos : = make ( [ ] types . Blob Info , num Layers ) diff IDs : = make ( [ ] digest . Digest , num Layers ) for i , cld : = range data { if cld . err ! = nil { return cld . err } dest Infos [ i ] = cld . dest Info diff IDs [ i ] = cld . diff ID } ic . manifest Updates . Information Only . Layer Infos = dest Infos if ic . diff IDs Are Needed { ic . manifest Updates . Information Only . Layer Diff IDs = diff IDs } if src Infos Updated | | layer Digests Differ ( src Infos , dest Infos ) { ic . manifest Updates . Layer Infos = dest Infos } return nil } 
func layer Digests Differ ( a , b [ ] types . Blob Info ) bool { if len ( a ) ! = len ( b ) { return true } for i : = range a { if a [ i ] . Digest ! = b [ i ] . Digest { return true } } return false } 
func ( ic * image Copier ) copy Updated Config And Manifest ( ctx context . Context ) ( [ ] byte , error ) { pending Image : = ic . src if ! reflect . Deep Equal ( * ic . manifest Updates , types . Manifest Update Options { Information Only : ic . manifest Updates . Information Only } ) { if ! ic . can Modify Manifest { return nil , errors . Errorf ( " " ) } if ! ic . diff IDs Are Needed & & ic . src . Updated Image Needs Layer Diff IDs ( * ic . manifest Updates ) { } pi , err : = ic . src . Updated Image ( ctx , * ic . manifest Updates ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } pending Image = pi } manifest , _ , err : = pending Image . Manifest ( ctx ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } if err : = ic . c . copy Config ( ctx , pending Image ) ; err ! = nil { return nil , err } ic . c . Printf ( " \n " ) if err : = ic . c . dest . Put Manifest ( ctx , manifest ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return manifest , nil } 
func ( c * copier ) new Progress Pool ( ctx context . Context ) ( * mpb . Progress , func ( ) ) { ctx , cancel : = context . With Cancel ( ctx ) pool : = mpb . New ( mpb . With Width ( 4 0 ) , mpb . With Output ( c . progress Output ) , mpb . With Context ( ctx ) ) return pool , func ( ) { cancel ( ) pool . Wait ( ) } } 
func ( c * copier ) create Progress Bar ( pool * mpb . Progress , info types . Blob Info , kind string , on Complete string ) * mpb . Bar { prefix : = fmt . Sprintf ( " " , kind , info . Digest . Encoded ( ) ) if len ( prefix ) > max Prefix Len { prefix = prefix [ : max Prefix Len ] } bar : = pool . Add Bar ( info . Size , mpb . Bar Clear On Complete ( ) , mpb . Prepend Decorators ( decor . Name ( prefix ) , ) , mpb . Append Decorators ( decor . On Complete ( decor . Counters Kibi Byte ( " " ) , " " + on Complete ) , ) , ) if c . progress Output = = ioutil . Discard { c . Printf ( " \n " , kind , info . Digest ) } return bar } 
func ( c * copier ) copy Config ( ctx context . Context , src types . Image ) error { src Info : = src . Config Info ( ) if src Info . Digest ! = " " { config Blob , err : = src . Config Blob ( ctx ) if err ! = nil { return errors . Wrapf ( err , " " , src Info . Digest ) } dest Info , err : = func ( ) ( types . Blob Info , error ) { defer progress Cleanup ( ) bar : = c . create Progress Bar ( progress Pool , src Info , " " , " " ) dest Info , err : = c . copy Blob From Stream ( ctx , bytes . New Reader ( config Blob ) , src Info , nil , false , true , bar ) if err ! = nil { return types . Blob Info { } , err } bar . Set Total ( int 6 4 ( len ( config Blob ) ) , true ) return dest Info , nil } ( ) if err ! = nil { return nil } if dest Info . Digest ! = src Info . Digest { return errors . Errorf ( " " , src Info . Digest , dest Info . Digest ) } } return nil } 
func ( ic * image Copier ) copy Layer ( ctx context . Context , src Info types . Blob Info , pool * mpb . Progress ) ( types . Blob Info , digest . Digest , error ) { cached Diff ID : = ic . c . blob Info Cache . Uncompressed Digest ( src Info . Digest ) diff IDIs Needed : = ic . diff IDs Are Needed & & cached Diff ID = = " " if err ! = nil { return types . Blob Info { } , " " , errors . Wrapf ( err , " " , src Info . Digest ) } if reused { logrus . Debugf ( " " , src Info . Digest ) bar : = ic . c . create Progress Bar ( pool , src Info , " " , " " ) bar . Set Total ( 0 , true ) return blob Info , cached Diff ID , nil } } if err ! = nil { return types . Blob Info { } , " " , errors . Wrapf ( err , " " , src Info . Digest ) } defer src Stream . Close ( ) bar : = ic . c . create Progress Bar ( pool , src Info , " " , " " ) blob Info , diff IDChan , err : = ic . copy Layer From Stream ( ctx , src Stream , types . Blob Info { Digest : src Info . Digest , Size : src Blob Size } , diff IDIs Needed , bar ) if err ! = nil { return types . Blob Info { } , " " , err } diff ID : = cached Diff ID if diff IDIs Needed { select { case < - ctx . Done ( ) : return types . Blob Info { } , " " , ctx . Err ( ) case diff IDResult : = < - diff IDChan : if diff IDResult . err ! = nil { return types . Blob Info { } , " " , errors . Wrap ( diff IDResult . err , " " ) } logrus . Debugf ( " " , diff IDResult . digest , src Info . Digest ) diff ID = diff IDResult . digest } } bar . Set Total ( src Info . Size , true ) return blob Info , diff ID , nil } 
func ( ic * image Copier ) copy Layer From Stream ( ctx context . Context , src Stream io . Reader , src Info types . Blob Info , diff IDIs Needed bool , bar * mpb . Bar ) ( types . Blob Info , < - chan diff IDResult , error ) { var get Diff IDRecorder func ( compression . Decompressor Func ) io . Writer var diff IDChan chan diff IDResult err : = errors . New ( " " ) if diff IDIs Needed { diff IDChan = make ( chan diff IDResult , 1 ) pipe Reader , pipe Writer : = io . Pipe ( ) defer func ( ) { } ( ) get Diff IDRecorder = func ( decompressor compression . Decompressor Func ) io . Writer { return pipe Writer } } blob Info , err : = ic . c . copy Blob From Stream ( ctx , src Stream , src Info , get Diff IDRecorder , ic . can Modify Manifest , false , bar ) return blob Info , diff IDChan , err 
func diff IDComputation Goroutine ( dest chan < - diff IDResult , layer Stream io . Read Closer , decompressor compression . Decompressor Func ) { result : = diff IDResult { digest : " " , err : errors . New ( " " ) , } defer func ( ) { dest < - result } ( ) defer layer Stream . Close ( ) result . digest , result . err = compute Diff ID ( layer Stream , decompressor ) } 
func compute Diff ID ( stream io . Reader , decompressor compression . Decompressor Func ) ( digest . Digest , error ) { if decompressor ! = nil { s , err : = decompressor ( stream ) if err ! = nil { return " " , err } defer s . Close ( ) stream = s } return digest . Canonical . From Reader ( stream ) } 
func ( c * copier ) copy Blob From Stream ( ctx context . Context , src Stream io . Reader , src Info types . Blob Info , get Original Layer Copy Writer func ( decompressor compression . Decompressor Func ) io . Writer , can Modify Blob bool , is Config bool , bar * mpb . Bar ) ( types . Blob Info , error ) { if err ! = nil { return types . Blob Info { } , errors . Wrapf ( err , " " , src Info . Digest ) } var dest Stream io . Reader = digesting Reader if err ! = nil { return types . Blob Info { } , errors . Wrapf ( err , " " , src Info . Digest ) } is Compressed : = decompressor ! = nil dest Stream = bar . Proxy Reader ( dest Stream ) if get Original Layer Copy Writer ! = nil { dest Stream = io . Tee Reader ( dest Stream , get Original Layer Copy Writer ( decompressor ) ) original Layer Reader = dest Stream } var compression Operation types . Layer Compression if can Modify Blob & & c . dest . Desired Layer Compression ( ) = = types . Compress & & ! is Compressed { logrus . Debugf ( " " ) compression Operation = types . Compress pipe Reader , pipe Writer : = io . Pipe ( ) defer pipe Reader . Close ( ) dest Stream = pipe Reader input Info . Digest = " " input Info . Size = - 1 } else if can Modify Blob & & c . dest . Desired Layer Compression ( ) = = types . Decompress & & is Compressed { logrus . Debugf ( " " ) compression Operation = types . Decompress s , err : = decompressor ( dest Stream ) if err ! = nil { return types . Blob Info { } , err } defer s . Close ( ) dest Stream = s input Info . Digest = " " input Info . Size = - 1 } else { logrus . Debugf ( " " ) compression Operation = types . Preserve Original input Info = src Info } } if err ! = nil { return types . Blob Info { } , errors . Wrap ( err , " " ) } _ , err : = io . Copy ( ioutil . Discard , original Layer Reader ) if err ! = nil { return types . Blob Info { } , errors . Wrapf ( err , " " , src Info . Digest ) } } if digesting Reader . validation Failed { } if input Info . Digest ! = " " & & uploaded Info . Digest ! = input Info . Digest { return types . Blob Info { } , errors . Errorf ( " " , src Info . Digest , input Info . Digest , uploaded Info . Digest ) } if digesting Reader . validation Succeeded { case types . Compress : c . blob Info Cache . Record Digest Uncompressed Pair ( uploaded Info . Digest , src Info . Digest ) case types . Decompress : c . blob Info Cache . Record Digest Uncompressed Pair ( src Info . Digest , uploaded Info . Digest ) default : return types . Blob Info { } , errors . Errorf ( " " , compression Operation ) } } return uploaded Info , nil } 
func compress Goroutine ( dest * io . Pipe Writer , src io . Reader ) { err : = errors . New ( " " ) defer func ( ) { } ( ) zipper : = pgzip . New Writer ( dest ) defer zipper . Close ( ) _ , err = io . Copy ( zipper , src ) } 
func new Docker Client ( sys * types . System Context ) ( * dockerclient . Client , error ) { host : = dockerclient . Default Docker Host if sys ! = nil & & sys . Docker Daemon Host ! = " " { host = sys . Docker Daemon Host } if err ! = nil { return nil , err } var http Client * http . Client if url . Scheme ! = " " { if url . Scheme = = " " { http Client = http Config ( ) } else { hc , err : = tls Config ( sys ) if err ! = nil { return nil , err } http Client = hc } } return dockerclient . New Client ( host , default APIVersion , http Client , nil ) } 
func default Policy Path ( sys * types . System Context ) string { if sys ! = nil { if sys . Signature Policy Path ! = " " { return sys . Signature Policy Path } if sys . Root For Implicit Absolute Paths ! = " " { return filepath . Join ( sys . Root For Implicit Absolute Paths , system Default Policy Path ) } } return system Default Policy Path } 
func New Policy From File ( file Name string ) ( * Policy , error ) { contents , err : = ioutil . Read File ( file Name ) if err ! = nil { return nil , err } policy , err : = New Policy From Bytes ( contents ) if err ! = nil { return nil , errors . Wrapf ( err , " " , file Name ) } return policy , nil } 
func New Policy From Bytes ( data [ ] byte ) ( * Policy , error ) { p : = Policy { } if err : = json . Unmarshal ( data , & p ) ; err ! = nil { return nil , Invalid Policy Format Error ( err . Error ( ) ) } return & p , nil } 
func ( p * Policy ) Unmarshal JSON ( data [ ] byte ) error { * p = Policy { } transports : = policy Transports Map { } if err : = paranoid Unmarshal JSONObject ( data , func ( key string ) interface { } { switch key { case " " : return & p . Default case " " : return & transports default : return nil } } ) ; err ! = nil { return err } if p . Default = = nil { return Invalid Policy Format Error ( " " ) } p . Transports = map [ string ] Policy Transport Scopes ( transports ) return nil } 
func ( m * policy Transports Map ) Unmarshal JSON ( data [ ] byte ) error { if err : = paranoid Unmarshal JSONObject ( data , func ( key string ) interface { } { } pts With Transport : = policy Transport Scopes With Transport { transport : transport , dest : & Policy Transport Scopes { } , tmp Map [ key ] = pts With Transport . dest return & pts With Transport } ) ; err ! = nil { return err } for key , ptr : = range tmp Map { ( * m ) [ key ] = * ptr } return nil } 
func ( m * policy Transport Scopes With Transport ) Unmarshal JSON ( data [ ] byte ) error { if err : = paranoid Unmarshal JSONObject ( data , func ( key string ) interface { } { } if key ! = " " & & m . transport ! = nil { if err : = m . transport . Validate Policy Configuration Scope ( key ) ; err ! = nil { return nil } } ptr : = & Policy Requirements { } tmp Map [ key ] = ptr return ptr } ) ; err ! = nil { return err } for key , ptr : = range tmp Map { ( * m . dest ) [ key ] = * ptr } return nil } 
func ( m * Policy Requirements ) Unmarshal JSON ( data [ ] byte ) error { req JSONs : = [ ] json . Raw Message { } if err : = json . Unmarshal ( data , & req JSONs ) ; err ! = nil { return err } if len ( req JSONs ) = = 0 { return Invalid Policy Format Error ( " " ) } res : = make ( [ ] Policy Requirement , len ( req JSONs ) ) for i , req JSON : = range req JSONs { req , err : = new Policy Requirement From JSON ( req JSON ) if err ! = nil { return err } res [ i ] = req } * m = res return nil } 
func new Policy Requirement From JSON ( data [ ] byte ) ( Policy Requirement , error ) { var type Field pr Common if err : = json . Unmarshal ( data , & type Field ) ; err ! = nil { return nil , err } var res Policy Requirement switch type Field . Type { case pr Type Insecure Accept Anything : res = & pr Insecure Accept Anything { } case pr Type Reject : res = & pr Reject { } case pr Type Signed By : res = & pr Signed By { } case pr Type Signed Base Layer : res = & pr Signed Base Layer { } default : return nil , Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , type Field . Type ) ) } if err : = json . Unmarshal ( data , & res ) ; err ! = nil { return nil , err } return res , nil } 
func ( pr * pr Insecure Accept Anything ) Unmarshal JSON ( data [ ] byte ) error { * pr = pr Insecure Accept Anything { } var tmp pr Insecure Accept Anything if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , } ) ; err ! = nil { return err } if tmp . Type ! = pr Type Insecure Accept Anything { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } * pr = * new PRInsecure Accept Anything ( ) return nil } 
func ( pr * pr Reject ) Unmarshal JSON ( data [ ] byte ) error { * pr = pr Reject { } var tmp pr Reject if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , } ) ; err ! = nil { return err } if tmp . Type ! = pr Type Reject { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } * pr = * new PRReject ( ) return nil } 
func new PRSigned By ( key Type sb Key Type , key Path string , key Data [ ] byte , signed Identity Policy Reference Match ) ( * pr Signed By , error ) { if ! key Type . Is Valid ( ) { return nil , Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , key Type ) ) } if len ( key Path ) > 0 & & len ( key Data ) > 0 { return nil , Invalid Policy Format Error ( " " ) } if signed Identity = = nil { return nil , Invalid Policy Format Error ( " " ) } return & pr Signed By { pr Common : pr Common { Type : pr Type Signed By } , Key Type : key Type , Key Path : key Path , Key Data : key Data , Signed Identity : signed Identity , } , nil } 
func new PRSigned By Key Path ( key Type sb Key Type , key Path string , signed Identity Policy Reference Match ) ( * pr Signed By , error ) { return new PRSigned By ( key Type , key Path , nil , signed Identity ) } 
func New PRSigned By Key Path ( key Type sb Key Type , key Path string , signed Identity Policy Reference Match ) ( Policy Requirement , error ) { return new PRSigned By Key Path ( key Type , key Path , signed Identity ) } 
func new PRSigned By Key Data ( key Type sb Key Type , key Data [ ] byte , signed Identity Policy Reference Match ) ( * pr Signed By , error ) { return new PRSigned By ( key Type , " " , key Data , signed Identity ) } 
func New PRSigned By Key Data ( key Type sb Key Type , key Data [ ] byte , signed Identity Policy Reference Match ) ( Policy Requirement , error ) { return new PRSigned By Key Data ( key Type , key Data , signed Identity ) } 
func ( pr * pr Signed By ) Unmarshal JSON ( data [ ] byte ) error { * pr = pr Signed By { } var tmp pr Signed By var got Key Path , got Key Data = false , false var signed Identity json . Raw Message if err : = paranoid Unmarshal JSONObject ( data , func ( key string ) interface { } { switch key { case " " : return & tmp . Type case " " : return & tmp . Key Type case " " : got Key Path = true return & tmp . Key Path case " " : got Key Data = true return & tmp . Key Data case " " : return & signed Identity default : return nil } } ) ; err ! = nil { return err } if tmp . Type ! = pr Type Signed By { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } if signed Identity = = nil { tmp . Signed Identity = New PRMMatch Repo Digest Or Exact ( ) } else { si , err : = new Policy Reference Match From JSON ( signed Identity ) if err ! = nil { return err } tmp . Signed Identity = si } var res * pr Signed By var err error switch { case got Key Path & & got Key Data : return Invalid Policy Format Error ( " " ) case got Key Path & & ! got Key Data : res , err = new PRSigned By Key Path ( tmp . Key Type , tmp . Key Path , tmp . Signed Identity ) case ! got Key Path & & got Key Data : res , err = new PRSigned By Key Data ( tmp . Key Type , tmp . Key Data , tmp . Signed Identity ) case ! got Key Path & & ! got Key Data : return Invalid Policy Format Error ( " " ) default : } if err ! = nil { return err } * pr = * res return nil } 
func ( kt sb Key Type ) Is Valid ( ) bool { switch kt { case SBKey Type GPGKeys , SBKey Type Signed By GPGKeys , SBKey Type X 5 0 9Certificates , SBKey Type Signed By X 5 0 9CAs : return true default : return false } } 
func ( kt * sb Key Type ) Unmarshal JSON ( data [ ] byte ) error { * kt = sb Key Type ( " " ) var s string if err : = json . Unmarshal ( data , & s ) ; err ! = nil { return err } if ! sb Key Type ( s ) . Is Valid ( ) { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , s ) ) } * kt = sb Key Type ( s ) return nil } 
func new PRSigned Base Layer ( base Layer Identity Policy Reference Match ) ( * pr Signed Base Layer , error ) { if base Layer Identity = = nil { return nil , Invalid Policy Format Error ( " " ) } return & pr Signed Base Layer { pr Common : pr Common { Type : pr Type Signed Base Layer } , Base Layer Identity : base Layer Identity , } , nil } 
func ( pr * pr Signed Base Layer ) Unmarshal JSON ( data [ ] byte ) error { * pr = pr Signed Base Layer { } var tmp pr Signed Base Layer var base Layer Identity json . Raw Message if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , " " : & base Layer Identity , } ) ; err ! = nil { return err } if tmp . Type ! = pr Type Signed Base Layer { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } bli , err : = new Policy Reference Match From JSON ( base Layer Identity ) if err ! = nil { return err } res , err : = new PRSigned Base Layer ( bli ) if err ! = nil { } * pr = * res return nil } 
func new Policy Reference Match From JSON ( data [ ] byte ) ( Policy Reference Match , error ) { var type Field prm Common if err : = json . Unmarshal ( data , & type Field ) ; err ! = nil { return nil , err } var res Policy Reference Match switch type Field . Type { case prm Type Match Exact : res = & prm Match Exact { } case prm Type Match Repo Digest Or Exact : res = & prm Match Repo Digest Or Exact { } case prm Type Match Repository : res = & prm Match Repository { } case prm Type Exact Reference : res = & prm Exact Reference { } case prm Type Exact Repository : res = & prm Exact Repository { } default : return nil , Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , type Field . Type ) ) } if err : = json . Unmarshal ( data , & res ) ; err ! = nil { return nil , err } return res , nil } 
func ( prm * prm Match Exact ) Unmarshal JSON ( data [ ] byte ) error { * prm = prm Match Exact { } var tmp prm Match Exact if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , } ) ; err ! = nil { return err } if tmp . Type ! = prm Type Match Exact { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } * prm = * new PRMMatch Exact ( ) return nil } 
func ( prm * prm Match Repo Digest Or Exact ) Unmarshal JSON ( data [ ] byte ) error { * prm = prm Match Repo Digest Or Exact { } var tmp prm Match Repo Digest Or Exact if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , } ) ; err ! = nil { return err } if tmp . Type ! = prm Type Match Repo Digest Or Exact { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } * prm = * new PRMMatch Repo Digest Or Exact ( ) return nil } 
func ( prm * prm Match Repository ) Unmarshal JSON ( data [ ] byte ) error { * prm = prm Match Repository { } var tmp prm Match Repository if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , } ) ; err ! = nil { return err } if tmp . Type ! = prm Type Match Repository { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } * prm = * new PRMMatch Repository ( ) return nil } 
func new PRMExact Reference ( docker Reference string ) ( * prm Exact Reference , error ) { ref , err : = reference . Parse Normalized Named ( docker Reference ) if err ! = nil { return nil , Invalid Policy Format Error ( fmt . Sprintf ( " " , docker Reference , err . Error ( ) ) ) } if reference . Is Name Only ( ref ) { return nil , Invalid Policy Format Error ( fmt . Sprintf ( " " , docker Reference ) ) } return & prm Exact Reference { prm Common : prm Common { Type : prm Type Exact Reference } , Docker Reference : docker Reference , } , nil } 
func ( prm * prm Exact Reference ) Unmarshal JSON ( data [ ] byte ) error { * prm = prm Exact Reference { } var tmp prm Exact Reference if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , " " : & tmp . Docker Reference , } ) ; err ! = nil { return err } if tmp . Type ! = prm Type Exact Reference { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } res , err : = new PRMExact Reference ( tmp . Docker Reference ) if err ! = nil { return err } * prm = * res return nil } 
func new PRMExact Repository ( docker Repository string ) ( * prm Exact Repository , error ) { if _ , err : = reference . Parse Normalized Named ( docker Repository ) ; err ! = nil { return nil , Invalid Policy Format Error ( fmt . Sprintf ( " " , docker Repository , err . Error ( ) ) ) } return & prm Exact Repository { prm Common : prm Common { Type : prm Type Exact Repository } , Docker Repository : docker Repository , } , nil } 
func ( prm * prm Exact Repository ) Unmarshal JSON ( data [ ] byte ) error { * prm = prm Exact Repository { } var tmp prm Exact Repository if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & tmp . Type , " " : & tmp . Docker Repository , } ) ; err ! = nil { return err } if tmp . Type ! = prm Type Exact Repository { return Invalid Policy Format Error ( fmt . Sprintf ( " \ " \ " " , tmp . Type ) ) } res , err : = new PRMExact Repository ( tmp . Docker Repository ) if err ! = nil { return err } * prm = * res return nil } 
func new Image Source ( image Ref storage Reference ) ( * storage Image Source , error ) { if err ! = nil { return nil , err } if img . Metadata ! = " " { if err : = json . Unmarshal ( [ ] byte ( img . Metadata ) , image ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } } return image , nil } 
func ( s * storage Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( rc io . Read Closer , n int 6 4 , err error ) { if info . Digest = = image . Gzipped Empty Layer Digest { return ioutil . Nop Closer ( bytes . New Reader ( image . Gzipped Empty Layer ) ) , int 6 4 ( len ( image . Gzipped Empty Layer ) ) , nil } rc , n , _ , err = s . get Blob And Layer ID ( info ) return rc , n , err } 
func ( s * storage Image Source ) get Blob And Layer ID ( info types . Blob Info ) ( rc io . Read Closer , n int 6 4 , layer ID string , err error ) { var layer storage . Layer var diff Options * storage . Diff Options if err ! = nil { return nil , - 1 , " " , err } if err ! = nil { return nil , - 1 , " " , err } r : = bytes . New Reader ( b ) logrus . Debugf ( " " , info . Digest . String ( ) ) return ioutil . Nop Closer ( r ) , int 6 4 ( r . Len ( ) ) , " " , nil } i : = s . layer Position [ info . Digest ] s . layer Position [ info . Digest ] = i + 1 s . get Blob Mutex . Unlock ( ) if len ( layers ) > 0 { layer = layers [ i % len ( layers ) ] } diff Options = & storage . Diff Options { Compression : & no Compression , } if layer . Uncompressed Size < 0 { n = - 1 } else { n = layer . Uncompressed Size } logrus . Debugf ( " " , layer . ID , info . Digest ) rc , err = s . image Ref . transport . store . Diff ( " " , layer . ID , diff Options ) if err ! = nil { return nil , - 1 , " " , err } return rc , n , layer . ID , err } 
func ( s * storage Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( manifest Blob [ ] byte , MIMEType string , err error ) { if instance Digest ! = nil { return nil , " " , Err No Manifest Lists } if len ( s . cached Manifest ) = = 0 { blob , err : = s . image Ref . transport . store . Image Big Data ( s . image . ID , key ) if err ! = nil & & ! os . Is Not Exist ( err ) { } if err = = nil { s . cached Manifest = blob } } } if err ! = nil { return nil , " " , err } s . cached Manifest = cached Blob } } return s . cached Manifest , manifest . Guess MIMEType ( s . cached Manifest ) , err } 
func ( s * storage Image Source ) Layer Infos For Copy ( ctx context . Context ) ( [ ] types . Blob Info , error ) { manifest Blob , manifest Type , err : = s . Get Manifest ( ctx , nil ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s . image . ID ) } man , err : = manifest . From Blob ( manifest Blob , manifest Type ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s . image . ID ) } uncompressed Layer Type : = " " switch manifest Type { case imgspecv 1 . Media Type Image Manifest : uncompressed Layer Type = imgspecv 1 . Media Type Image Layer case manifest . Docker V 2Schema 1Media Type , manifest . Docker V 2Schema 1Signed Media Type , manifest . Docker V 2Schema 2Media Type : } physical Blob Infos : = [ ] types . Blob Info { } layer ID : = s . image . Top Layer for layer ID ! = " " { layer , err : = s . image Ref . transport . store . Layer ( layer ID ) if err ! = nil { return nil , errors . Wrapf ( err , " " , layer ID , s . image . ID ) } if layer . Uncompressed Digest = = " " { return nil , errors . Errorf ( " " , layer ID ) } if layer . Uncompressed Size < 0 { return nil , errors . Errorf ( " " , layer ID ) } blob Info : = types . Blob Info { Digest : layer . Uncompressed Digest , Size : layer . Uncompressed Size , Media Type : uncompressed Layer Type , } physical Blob Infos = append ( [ ] types . Blob Info { blob Info } , physical Blob Infos . . . ) layer ID = layer . Parent } res , err : = build Layer Infos For Copy ( man . Layer Infos ( ) , physical Blob Infos ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s . image . ID ) } return res , nil } 
func build Layer Infos For Copy ( manifest Infos [ ] manifest . Layer Info , physical Infos [ ] types . Blob Info ) ( [ ] types . Blob Info , error ) { next Physical : = 0 res : = make ( [ ] types . Blob Info , len ( manifest Infos ) ) for i , mi : = range manifest Infos { if mi . Empty Layer { res [ i ] = types . Blob Info { Digest : image . Gzipped Empty Layer Digest , Size : int 6 4 ( len ( image . Gzipped Empty Layer ) ) , Media Type : mi . Media Type , } } else { if next Physical > = len ( physical Infos ) { return nil , fmt . Errorf ( " " , len ( physical Infos ) ) } res [ i ] = physical Infos [ next Physical ] next Physical + + } } if next Physical ! = len ( physical Infos ) { return nil , fmt . Errorf ( " " , next Physical , len ( physical Infos ) ) } return res , nil } 
func ( s * storage Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( signatures [ ] [ ] byte , err error ) { if instance Digest ! = nil { return nil , Err No Manifest Lists } var offset int sigslice : = [ ] [ ] byte { } signature : = [ ] byte { } if len ( s . Signature Sizes ) > 0 { signature Blob , err : = s . image Ref . transport . store . Image Big Data ( s . image . ID , " " ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s . image . ID ) } signature = signature Blob } for _ , length : = range s . Signature Sizes { sigslice = append ( sigslice , signature [ offset : offset + length ] ) offset + = length } if offset ! = len ( signature ) { return nil , errors . Errorf ( " " , len ( signatures ) - offset ) } return sigslice , nil } 
func new Image Destination ( image Ref storage Reference ) ( * storage Image Destination , error ) { directory , err : = ioutil . Temp Dir ( tmpdir . Temporary Directory For Big Files ( ) , " " ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } image : = & storage Image Destination { image Ref : image Ref , directory : directory , blob Diff IDs : make ( map [ digest . Digest ] digest . Digest ) , file Sizes : make ( map [ digest . Digest ] int 6 4 ) , filenames : make ( map [ digest . Digest ] string ) , Signature Sizes : [ ] int { } , } return image , nil } 
func ( s * storage Image Destination ) Put Blob ( ctx context . Context , stream io . Reader , blobinfo types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { if blobinfo . Digest . Validate ( ) = = nil { if a : = blobinfo . Digest . Algorithm ( ) ; a . Available ( ) { hasher = a . Digester ( ) } } diff ID : = digest . Canonical . Digester ( ) filename : = s . compute Next Blob Cache File ( ) file , err : = os . Open File ( filename , os . O _CREATE | os . O _TRUNC | os . O _WRONLY | os . O _EXCL , 0 6 0 0 ) if err ! = nil { return error Blob Info , errors . Wrapf ( err , " " , filename ) } defer file . Close ( ) counter : = ioutils . New Write Counter ( hasher . Hash ( ) ) reader : = io . Tee Reader ( io . Tee Reader ( stream , counter ) , file ) decompressed , err : = archive . Decompress Stream ( reader ) if err ! = nil { return error Blob Info , errors . Wrap ( err , " " ) } decompressed . Close ( ) if err ! = nil { return error Blob Info , errors . Wrapf ( err , " " , filename ) } } if blobinfo . Size > = 0 & & blobinfo . Size ! = counter . Count { return error Blob Info , Err Blob Size Mismatch } s . blob Diff IDs [ hasher . Digest ( ) ] = diff ID . Digest ( ) s . file Sizes [ hasher . Digest ( ) ] = counter . Count s . filenames [ hasher . Digest ( ) ] = filename s . put Blob Mutex . Unlock ( ) blob Digest : = blobinfo . Digest if blob Digest . Validate ( ) ! = nil { blob Digest = hasher . Digest ( ) } blob Size : = blobinfo . Size if blob Size < 0 { blob Size = counter . Count } return types . Blob Info { Digest : blob Digest , Size : blob Size , Media Type : blobinfo . Media Type , } , nil } 
func ( s * storage Image Destination ) Try Reusing Blob ( ctx context . Context , blobinfo types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { defer s . put Blob Mutex . Unlock ( ) if blobinfo . Digest = = " " { return false , types . Blob Info { } , errors . Errorf ( `Can not check for a blob with unknown digest ` ) } if err : = blobinfo . Digest . Validate ( ) ; err ! = nil { return false , types . Blob Info { } , errors . Wrapf ( err , `Can not check for a blob with invalid digest ` ) } } if err ! = nil & & errors . Cause ( err ) ! = storage . Err Layer Unknown { return false , types . Blob Info { } , errors . Wrapf ( err , `Error looking for layers with digest %q ` , blobinfo . Digest ) } if len ( layers ) > 0 { return true , types . Blob Info { Digest : blobinfo . Digest , Size : layers [ 0 ] . Uncompressed Size , Media Type : blobinfo . Media Type , } , nil } if err ! = nil & & errors . Cause ( err ) ! = storage . Err Layer Unknown { return false , types . Blob Info { } , errors . Wrapf ( err , `Error looking for compressed layers with digest %q ` , blobinfo . Digest ) } if len ( layers ) > 0 { return true , types . Blob Info { Digest : blobinfo . Digest , Size : layers [ 0 ] . Compressed Size , Media Type : blobinfo . Media Type , } , nil } if err ! = nil & & errors . Cause ( err ) ! = storage . Err Layer Unknown { return false , types . Blob Info { } , errors . Wrapf ( err , `Error looking for layers with digest %q ` , uncompressed Digest ) } if len ( layers ) > 0 { s . blob Diff IDs [ uncompressed Digest ] = layers [ 0 ] . Uncompressed Digest return true , types . Blob Info { Digest : uncompressed Digest , Size : layers [ 0 ] . Uncompressed Size , Media Type : blobinfo . Media Type , } , nil } } } } 
func ( s * storage Image Destination ) compute ID ( m manifest . Manifest ) string { switch m : = m . ( type ) { case * manifest . Schema 1 : } blob Sum : = m . FSLayers [ i ] . Blob Sum diff ID , ok : = s . blob Diff IDs [ blob Sum ] if ! ok { logrus . Infof ( " " , blob Sum . String ( ) ) return " " } diff IDs = append ( [ ] digest . Digest { diff ID } , diff IDs . . . ) } case * manifest . Schema 2 , * manifest . OCI 1 : } id , err : = m . Image ID ( diff IDs ) if err ! = nil { return " " } return id } 
func ( s * storage Image Destination ) get Config Blob ( info types . Blob Info ) ( [ ] byte , error ) { if info . Digest = = " " { return nil , errors . Errorf ( `no digest supplied when reading blob ` ) } if err : = info . Digest . Validate ( ) ; err ! = nil { return nil , errors . Wrapf ( err , `invalid digest supplied when reading blob ` ) } if err 2 ! = nil { return nil , errors . Wrapf ( err 2 , `error reading blob from file %q ` , filename ) } return contents , nil } } 
func ( s * storage Image Destination ) Put Manifest ( ctx context . Context , manifest Blob [ ] byte ) error { if s . image Ref . named ! = nil { if digested , ok : = s . image Ref . named . ( reference . Digested ) ; ok { matches , err : = manifest . Matches Digest ( manifest Blob , digested . Digest ( ) ) if err ! = nil { return err } if ! matches { return fmt . Errorf ( " " , digested . Digest ( ) ) } } } s . manifest = make ( [ ] byte , len ( manifest Blob ) ) copy ( s . manifest , manifest Blob ) return nil } 
func ( s * storage Image Destination ) Put Signatures ( ctx context . Context , signatures [ ] [ ] byte ) error { sizes : = [ ] int { } sigblob : = [ ] byte { } for _ , sig : = range signatures { sizes = append ( sizes , len ( sig ) ) newblob : = make ( [ ] byte , len ( sigblob ) + len ( sig ) ) copy ( newblob , sigblob ) copy ( newblob [ len ( sigblob ) : ] , sig ) sigblob = newblob } s . signatures = sigblob s . Signature Sizes = sizes return nil } 
func ( s * storage Image Source ) get Size ( ) ( int 6 4 , error ) { var sum int 6 4 if err ! = nil { return - 1 , errors . Wrapf ( err , " " , s . image . ID ) } for _ , data Name : = range data Names { big Size , err : = s . image Ref . transport . store . Image Big Data Size ( s . image . ID , data Name ) if err ! = nil { return - 1 , errors . Wrapf ( err , " " , data Name , s . image . ID ) } sum + = big Size } } for layer ID ! = " " { layer , err : = s . image Ref . transport . store . Layer ( layer ID ) if err ! = nil { return - 1 , err } if layer . Uncompressed Digest = = " " | | layer . Uncompressed Size < 0 { return - 1 , errors . Errorf ( " " , layer ID ) } sum + = layer . Uncompressed Size if layer . Parent = = " " { break } layer ID = layer . Parent } return sum , nil } 
func new Image ( ctx context . Context , sys * types . System Context , s storage Reference ) ( types . Image Closer , error ) { src , err : = new Image Source ( s ) if err ! = nil { return nil , err } img , err : = image . From Source ( ctx , sys , src ) if err ! = nil { return nil , err } size , err : = src . get Size ( ) if err ! = nil { return nil , err } return & storage Image Closer { Image Closer : img , size : size } , nil } 
func new Image Source ( ctx context . Context , ref archive Reference ) ( types . Image Source , error ) { if ref . destination Ref ! = nil { logrus . Warnf ( " " ) } src , err : = tarfile . New Source From File ( ref . path ) if err ! = nil { return nil , err } return & archive Image Source { Source : src , ref : ref , } , nil } 
func ( no Cache ) Candidate Locations ( transport types . Image Transport , scope types . BICTransport Scope , digest digest . Digest , can Substitute bool ) [ ] types . BICReplacement Candidate { return nil } 
func new GPGSigning Mechanism In Directory ( optional Dir string ) ( Signing Mechanism , error ) { m : = & openpgp Signing Mechanism { keyring : openpgp . Entity List { } , } gpg Home : = optional Dir if gpg Home = = " " { gpg Home = os . Getenv ( " " ) if gpg Home = = " " { gpg Home = path . Join ( homedir . Get ( ) , " " ) } } pubring , err : = ioutil . Read File ( path . Join ( gpg Home , " " ) ) if err ! = nil { if ! os . Is Not Exist ( err ) { return nil , err } } else { _ , err : = m . import Keys From Bytes ( pubring ) if err ! = nil { return nil , err } } return m , nil } 
func new Ephemeral GPGSigning Mechanism ( blob [ ] byte ) ( Signing Mechanism , [ ] string , error ) { m : = & openpgp Signing Mechanism { keyring : openpgp . Entity List { } , } key Identities , err : = m . import Keys From Bytes ( blob ) if err ! = nil { return nil , nil , err } return m , key Identities , nil } 
func ( m * openpgp Signing Mechanism ) import Keys From Bytes ( blob [ ] byte ) ( [ ] string , error ) { keyring , err : = openpgp . Read Key Ring ( bytes . New Reader ( blob ) ) if err ! = nil { k , e 2 : = openpgp . Read Armored Key Ring ( bytes . New Reader ( blob ) ) if e 2 ! = nil { return nil , err } keyring = k } key Identities : = [ ] string { } for _ , entity : = range keyring { if entity . Primary Key = = nil { } m . keyring = append ( m . keyring , entity ) } return key Identities , nil } 
func ( m * openpgp Signing Mechanism ) Sign ( input [ ] byte , key Identity string ) ( [ ] byte , error ) { return nil , Signing Not Supported Error ( " " ) } 
func ( m * openpgp Signing Mechanism ) Verify ( unverified Signature [ ] byte ) ( contents [ ] byte , key Identity string , err error ) { md , err : = openpgp . Read Message ( bytes . New Reader ( unverified Signature ) , m . keyring , nil , nil ) if err ! = nil { return nil , " " , err } if ! md . Is Signed { return nil , " " , errors . New ( " " ) } content , err : = ioutil . Read All ( md . Unverified Body ) if err ! = nil { } if md . Signature Error ! = nil { return nil , " " , fmt . Errorf ( " " , md . Signature Error ) } if md . Signed By = = nil { return nil , " " , Invalid Signature Error { msg : fmt . Sprintf ( " " , md . Signature ) } } if md . Signature ! = nil { if md . Signature . Sig Lifetime Secs ! = nil { expiry : = md . Signature . Creation Time . Add ( time . Duration ( * md . Signature . Sig Lifetime Secs ) * time . Second ) if time . Now ( ) . After ( expiry ) { return nil , " " , Invalid Signature Error { msg : fmt . Sprintf ( " " , expiry ) } } } } else if md . Signature V 3 = = nil { } } 
func ( m openpgp Signing Mechanism ) Untrusted Signature Contents ( untrusted Signature [ ] byte ) ( untrusted Contents [ ] byte , short Key Identifier string , err error ) { return gpg Untrusted Signature Contents ( untrusted Signature ) } 
func new Image Source ( ctx context . Context , sys * types . System Context , ref oci Archive Reference ) ( types . Image Source , error ) { temp Dir Ref , err : = create Untar Temp Dir ( ref ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } unpacked Src , err : = temp Dir Ref . oci Ref Extracted . New Image Source ( ctx , sys ) if err ! = nil { if err : = temp Dir Ref . delete Temp Dir ( ) ; err ! = nil { return nil , errors . Wrapf ( err , " " , temp Dir Ref . temp Directory ) } return nil , err } return & oci Archive Image Source { ref : ref , unpacked Src : unpacked Src , temp Dir Ref : temp Dir Ref } , nil } 
func Load Manifest Descriptor ( img Ref types . Image Reference ) ( imgspecv 1 . Descriptor , error ) { oci Arch Ref , ok : = img Ref . ( oci Archive Reference ) if ! ok { return imgspecv 1 . Descriptor { } , errors . Errorf ( " " ) } temp Dir Ref , err : = create Untar Temp Dir ( oci Arch Ref ) if err ! = nil { return imgspecv 1 . Descriptor { } , errors . Wrap ( err , " " ) } defer temp Dir Ref . delete Temp Dir ( ) descriptor , err : = ocilayout . Load Manifest Descriptor ( temp Dir Ref . oci Ref Extracted ) if err ! = nil { return imgspecv 1 . Descriptor { } , errors . Wrap ( err , " " ) } return descriptor , nil } 
func ( s * oci Archive Image Source ) Close ( ) error { defer s . temp Dir Ref . delete Temp Dir ( ) return s . unpacked Src . Close ( ) } 
func ( s * oci Archive Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { return s . unpacked Src . Get Manifest ( ctx , instance Digest ) } 
func ( s * oci Archive Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { return s . unpacked Src . Get Blob ( ctx , info , cache ) } 
func ( s * oci Archive Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { return s . unpacked Src . Get Signatures ( ctx , instance Digest ) } 
func ( os * ordered Set ) append ( s string ) { if _ , ok : = os . included [ s ] ; ! ok { os . list = append ( os . list , s ) os . included [ s ] = struct { } { } } } 
func ( ic * image Copier ) determine Manifest Conversion ( ctx context . Context , dest Supported Manifest MIMETypes [ ] string , force Manifest MIMEType string ) ( string , [ ] string , error ) { _ , src Type , err : = ic . src . Manifest ( ctx ) if err ! = nil { } normalized Src Type : = manifest . Normalized MIMEType ( src Type ) if src Type ! = normalized Src Type { logrus . Debugf ( " " , src Type , normalized Src Type ) src Type = normalized Src Type } if force Manifest MIMEType ! = " " { dest Supported Manifest MIMETypes = [ ] string { force Manifest MIMEType } } if len ( dest Supported Manifest MIMETypes ) = = 0 { return src Type , [ ] string { } , nil } supported By Dest : = map [ string ] struct { } { } for _ , t : = range dest Supported Manifest MIMETypes { supported By Dest [ t ] = struct { } { } } } if ! ic . can Modify Manifest { return src Type , [ ] string { } , nil } } } } logrus . Debugf ( " " , src Type , strings . Join ( prioritized Types . list , " " ) ) if len ( prioritized Types . list ) = = 0 { } preferred Type : = prioritized Types . list [ 0 ] if preferred Type ! = src Type { ic . manifest Updates . Manifest MIMEType = preferred Type } else { logrus . Debugf ( " " ) } return preferred Type , prioritized Types . list [ 1 : ] , nil } 
func is Multi Image ( ctx context . Context , img types . Unparsed Image ) ( bool , error ) { _ , mt , err : = img . Manifest ( ctx ) if err ! = nil { return false , err } return manifest . MIMEType Is Multi Image ( mt ) , nil } 
func lock Path ( path string ) { pl : = func ( ) * path Lock { defer path Locks Mutex . Unlock ( ) pl , ok : = path Locks [ path ] if ok { pl . ref Count + + } else { pl = & path Lock { ref Count : 1 , mutex : sync . Mutex { } } path Locks [ path ] = pl } return pl } ( ) pl . mutex . Lock ( ) } 
func unlock Path ( path string ) { path Locks Mutex . Lock ( ) defer path Locks Mutex . Unlock ( ) pl , ok : = path Locks [ path ] if ! ok { } pl . mutex . Unlock ( ) pl . ref Count - - if pl . ref Count = = 0 { delete ( path Locks , path ) } } 
func ( bdc * cache ) view ( fn func ( tx * bolt . Tx ) error ) ( ret Err error ) { } lock Path ( bdc . path ) defer unlock Path ( bdc . path ) db , err : = bolt . Open ( bdc . path , 0 6 0 0 , & bolt . Options { Read Only : true } ) if err ! = nil { return err } defer func ( ) { if err : = db . Close ( ) ; ret Err = = nil & & err ! = nil { ret Err = err } } ( ) return db . View ( fn ) } 
func ( bdc * cache ) update ( fn func ( tx * bolt . Tx ) error ) ( ret Err error ) { lock Path ( bdc . path ) defer unlock Path ( bdc . path ) db , err : = bolt . Open ( bdc . path , 0 6 0 0 , nil ) if err ! = nil { return err } defer func ( ) { if err : = db . Close ( ) ; ret Err = = nil & & err ! = nil { ret Err = err } } ( ) return db . Update ( fn ) } 
func ( bdc * cache ) uncompressed Digest ( tx * bolt . Tx , any Digest digest . Digest ) digest . Digest { if b : = tx . Bucket ( uncompressed Digest Bucket ) ; b ! = nil { if uncompressed Bytes : = b . Get ( [ ] byte ( any Digest . String ( ) ) ) ; uncompressed Bytes ! = nil { d , err : = digest . Parse ( string ( uncompressed Bytes ) ) if err = = nil { return d } } if k , _ : = c . First ( ) ; k ! = nil { } } } return " " } 
func ( bdc * cache ) Uncompressed Digest ( any Digest digest . Digest ) digest . Digest { var res digest . Digest if err : = bdc . view ( func ( tx * bolt . Tx ) error { res = bdc . uncompressed Digest ( tx , any Digest ) return nil } ) ; err ! = nil { } return res } 
func ( bdc * cache ) Record Digest Uncompressed Pair ( any Digest digest . Digest , uncompressed digest . Digest ) { _ = bdc . update ( func ( tx * bolt . Tx ) error { b , err : = tx . Create Bucket If Not Exists ( uncompressed Digest Bucket ) if err ! = nil { return err } key : = [ ] byte ( any Digest . String ( ) ) if previous Bytes : = b . Get ( key ) ; previous Bytes ! = nil { previous , err : = digest . Parse ( string ( previous Bytes ) ) if err ! = nil { return err } if previous ! = uncompressed { logrus . Warnf ( " " , any Digest , previous , uncompressed ) } } if err : = b . Put ( key , [ ] byte ( uncompressed . String ( ) ) ) ; err ! = nil { return err } b , err = tx . Create Bucket If Not Exists ( digest By Uncompressed Bucket ) if err ! = nil { return err } b , err = b . Create Bucket If Not Exists ( [ ] byte ( uncompressed . String ( ) ) ) if err ! = nil { return err } if err : = b . Put ( [ ] byte ( any Digest . String ( ) ) , [ ] byte { } ) ; err ! = nil { } return nil } ) } 
func ( bdc * cache ) Record Known Location ( transport types . Image Transport , scope types . BICTransport Scope , blob Digest digest . Digest , location types . BICLocation Reference ) { _ = bdc . update ( func ( tx * bolt . Tx ) error { b , err : = tx . Create Bucket If Not Exists ( known Locations Bucket ) if err ! = nil { return err } b , err = b . Create Bucket If Not Exists ( [ ] byte ( transport . Name ( ) ) ) if err ! = nil { return err } b , err = b . Create Bucket If Not Exists ( [ ] byte ( scope . Opaque ) ) if err ! = nil { return err } b , err = b . Create Bucket If Not Exists ( [ ] byte ( blob Digest . String ( ) ) ) if err ! = nil { return err } value , err : = time . Now ( ) . Marshal Binary ( ) if err ! = nil { return err } if err : = b . Put ( [ ] byte ( location . Opaque ) , value ) ; err ! = nil { } return nil } ) } 
func ( bdc * cache ) append Replacement Candidates ( candidates [ ] prioritize . Candidate With Time , scope Bucket * bolt . Bucket , digest digest . Digest ) [ ] prioritize . Candidate With Time { b : = scope Bucket . Bucket ( [ ] byte ( digest . String ( ) ) ) if b = = nil { return candidates } _ = b . For Each ( func ( k , v [ ] byte ) error { t : = time . Time { } if err : = t . Unmarshal Binary ( v ) ; err ! = nil { return err } candidates = append ( candidates , prioritize . Candidate With Time { Candidate : types . BICReplacement Candidate { Digest : digest , Location : types . BICLocation Reference { Opaque : string ( k ) } , } , Last Seen : t , } ) return nil } ) return candidates } 
func ( bdc * cache ) Candidate Locations ( transport types . Image Transport , scope types . BICTransport Scope , primary Digest digest . Digest , can Substitute bool ) [ ] types . BICReplacement Candidate { res : = [ ] prioritize . Candidate With Time { } var uncompressed Digest Value digest . Digest if err : = bdc . view ( func ( tx * bolt . Tx ) error { scope Bucket : = tx . Bucket ( known Locations Bucket ) if scope Bucket = = nil { return nil } scope Bucket = scope Bucket . Bucket ( [ ] byte ( transport . Name ( ) ) ) if scope Bucket = = nil { return nil } scope Bucket = scope Bucket . Bucket ( [ ] byte ( scope . Opaque ) ) if scope Bucket = = nil { return nil } res = bdc . append Replacement Candidates ( res , scope Bucket , primary Digest ) if can Substitute { if uncompressed Digest Value = bdc . uncompressed Digest ( tx , primary Digest ) ; uncompressed Digest Value ! = " " { b : = tx . Bucket ( digest By Uncompressed Bucket ) if b ! = nil { b = b . Bucket ( [ ] byte ( uncompressed Digest Value . String ( ) ) ) if b ! = nil { if err : = b . For Each ( func ( k , _ [ ] byte ) error { d , err : = digest . Parse ( string ( k ) ) if err ! = nil { return err } if d ! = primary Digest & & d ! = uncompressed Digest Value { res = bdc . append Replacement Candidates ( res , scope Bucket , d ) } return nil } ) ; err ! = nil { return err } } } if uncompressed Digest Value ! = primary Digest { res = bdc . append Replacement Candidates ( res , scope Bucket , uncompressed Digest Value ) } } } return nil } ) ; err ! = nil { } return prioritize . Destructively Prioritize Replacement Candidates ( res , primary Digest , uncompressed Digest Value ) } 
func Temporary Directory For Big Files ( ) string { var temporary Directory For Big Files string if runtime . GOOS = = " " { temporary Directory For Big Files = os . Temp Dir ( ) } else { temporary Directory For Big Files = unix Temp Dir For Big Files } return temporary Directory For Big Files } 
func gpg Untrusted Signature Contents ( untrusted Signature [ ] byte ) ( untrusted Contents [ ] byte , short Key Identifier string , err error ) { if err ! = nil { return nil , " " , err } if ! md . Is Signed { return nil , " " , errors . New ( " " ) } content , err : = ioutil . Read All ( md . Unverified Body ) if err ! = nil { } } 
func new Image Destination ( sys * types . System Context , ref oci Reference ) ( types . Image Destination , error ) { var index * imgspecv 1 . Index if index Exists ( ref ) { var err error index , err = ref . get Index ( ) if err ! = nil { return nil , err } } else { index = & imgspecv 1 . Index { Versioned : imgspec . Versioned { Schema Version : 2 , } , } } d : = & oci Image Destination { ref : ref , index : * index } if sys ! = nil { d . shared Blob Dir = sys . OCIShared Blob Dir Path d . accept Uncompressed Layers = sys . OCIAccept Uncompressed Layers } if err : = ensure Directory Exists ( d . ref . dir ) ; err ! = nil { return nil , err } } return d , nil } 
func ( d * oci Image Destination ) Put Blob ( ctx context . Context , stream io . Reader , input Info types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { blob File , err : = ioutil . Temp File ( d . ref . dir , " " ) if err ! = nil { return types . Blob Info { } , err } succeeded : = false explicit Closed : = false defer func ( ) { if ! explicit Closed { blob File . Close ( ) } if ! succeeded { os . Remove ( blob File . Name ( ) ) } } ( ) digester : = digest . Canonical . Digester ( ) tee : = io . Tee Reader ( stream , digester . Hash ( ) ) if err ! = nil { return types . Blob Info { } , err } computed Digest : = digester . Digest ( ) if input Info . Size ! = - 1 & & size ! = input Info . Size { return types . Blob Info { } , errors . Errorf ( " " , computed Digest , input Info . Size , size ) } if err : = blob File . Sync ( ) ; err ! = nil { return types . Blob Info { } , err } } } blob Path , err : = d . ref . blob Path ( computed Digest , d . shared Blob Dir ) if err ! = nil { return types . Blob Info { } , err } if err : = ensure Parent Directory Exists ( blob Path ) ; err ! = nil { return types . Blob Info { } , err } explicit Closed = true if err : = os . Rename ( blob File . Name ( ) , blob Path ) ; err ! = nil { return types . Blob Info { } , err } succeeded = true return types . Blob Info { Digest : computed Digest , Size : size } , nil } 
func ( d * oci Image Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { if info . Digest = = " " { return false , types . Blob Info { } , errors . Errorf ( ` "Can not check for a blob with unknown digest ` ) } blob Path , err : = d . ref . blob Path ( info . Digest , d . shared Blob Dir ) if err ! = nil { return false , types . Blob Info { } , err } finfo , err : = os . Stat ( blob Path ) if err ! = nil & & os . Is Not Exist ( err ) { return false , types . Blob Info { } , nil } if err ! = nil { return false , types . Blob Info { } , err } return true , types . Blob Info { Digest : info . Digest , Size : finfo . Size ( ) } , nil } 
func ( d * oci Image Destination ) Put Manifest ( ctx context . Context , m [ ] byte ) error { digest , err : = manifest . Digest ( m ) if err ! = nil { return err } desc : = imgspecv 1 . Descriptor { } desc . Digest = digest desc . Size = int 6 4 ( len ( m ) ) blob Path , err : = d . ref . blob Path ( digest , d . shared Blob Dir ) if err ! = nil { return err } if err : = ensure Parent Directory Exists ( blob Path ) ; err ! = nil { return err } if err : = ioutil . Write File ( blob Path , m , 0 6 4 4 ) ; err ! = nil { return err } if d . ref . image ! = " " { annotations : = make ( map [ string ] string ) annotations [ " " ] = d . ref . image desc . Annotations = annotations } desc . Platform = & imgspecv 1 . Platform { Architecture : runtime . GOARCH , OS : runtime . GOOS , } d . add Manifest ( & desc ) return nil } 
func ( d * oci Image Destination ) Commit ( ctx context . Context ) error { if err : = ioutil . Write File ( d . ref . oci Layout Path ( ) , [ ] byte ( ` { "image Layout Version " : " 1 . 0 . 0 " } ` ) , 0 6 4 4 ) ; err ! = nil { return err } index JSON , err : = json . Marshal ( d . index ) if err ! = nil { return err } return ioutil . Write File ( d . ref . index Path ( ) , index JSON , 0 6 4 4 ) } 
func index Exists ( ref oci Reference ) bool { _ , err : = os . Stat ( ref . index Path ( ) ) if err = = nil { return true } if os . Is Not Exist ( err ) { return false } return true } 
func ( c * copier ) create Signature ( manifest [ ] byte , key Identity string ) ( [ ] byte , error ) { mech , err : = signature . New GPGSigning Mechanism ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } defer mech . Close ( ) if err : = mech . Supports Signing ( ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } docker Reference : = c . dest . Reference ( ) . Docker Reference ( ) if docker Reference = = nil { return nil , errors . Errorf ( " " , transports . Image Name ( c . dest . Reference ( ) ) ) } c . Printf ( " \n " ) new Sig , err : = signature . Sign Docker Manifest ( manifest , docker Reference . String ( ) , mech , key Identity ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } return new Sig , nil } 
func manifest Instance From Blob ( ctx context . Context , sys * types . System Context , src types . Image Source , manblob [ ] byte , mt string ) ( generic Manifest , error ) { switch manifest . Normalized MIMEType ( mt ) { case manifest . Docker V 2Schema 1Media Type , manifest . Docker V 2Schema 1Signed Media Type : return manifest Schema 1From Manifest ( manblob ) case imgspecv 1 . Media Type Image Manifest : return manifest OCI 1From Manifest ( src , manblob ) case manifest . Docker V 2Schema 2Media Type : return manifest Schema 2From Manifest ( src , manblob ) case manifest . Docker V 2List Media Type : return manifest Schema 2From Manifest List ( ctx , sys , src , manblob ) default : } } 
func manifest Layer Infos To Blob Infos ( layers [ ] manifest . Layer Info ) [ ] types . Blob Info { blobs : = make ( [ ] types . Blob Info , len ( layers ) ) for i , layer : = range layers { blobs [ i ] = layer . Blob Info } return blobs } 
func ( d * archive Image Destination ) Commit ( ctx context . Context ) error { return d . Destination . Commit ( ctx ) } 
func ( t oci Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func Parse Reference ( reference string ) ( types . Image Reference , error ) { dir , image : = internal . Split Path And Image ( reference ) return New Reference ( dir , image ) } 
func New Reference ( dir , image string ) ( types . Image Reference , error ) { resolved , err : = explicitfilepath . Resolve Path To Fully Explicit ( dir ) if err ! = nil { return nil , err } if err : = internal . Validate OCIPath ( dir ) ; err ! = nil { return nil , err } if err = internal . Validate Image Name ( image ) ; err ! = nil { return nil , err } return oci Reference { dir : dir , resolved Dir : resolved , image : image } , nil } 
func ( ref oci Reference ) String Within Transport ( ) string { return fmt . Sprintf ( " " , ref . dir , ref . image ) } 
func ( ref oci Reference ) Policy Configuration Namespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolved Dir for { last Slash : = strings . Last Index ( path , " " ) } res = append ( res , path ) path = path [ : last Slash ] } return res } 
func ( ref oci Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { src , err : = new Image Source ( sys , ref ) if err ! = nil { return nil , err } return image . From Source ( ctx , sys , src ) } 
func ( ref oci Reference ) get Index ( ) ( * imgspecv 1 . Index , error ) { index JSON , err : = os . Open ( ref . index Path ( ) ) if err ! = nil { return nil , err } defer index JSON . Close ( ) index : = & imgspecv 1 . Index { } if err : = json . New Decoder ( index JSON ) . Decode ( index ) ; err ! = nil { return nil , err } return index , nil } 
func Load Manifest Descriptor ( img Ref types . Image Reference ) ( imgspecv 1 . Descriptor , error ) { oci Ref , ok : = img Ref . ( oci Reference ) if ! ok { return imgspecv 1 . Descriptor { } , errors . Errorf ( " " ) } return oci Ref . get Manifest Descriptor ( ) } 
func ( ref oci Reference ) blob Path ( digest digest . Digest , shared Blob Dir string ) ( string , error ) { if err : = digest . Validate ( ) ; err ! = nil { return " " , errors . Wrapf ( err , " " , digest ) } blob Dir : = filepath . Join ( ref . dir , " " ) if shared Blob Dir ! = " " { blob Dir = shared Blob Dir } return filepath . Join ( blob Dir , digest . Algorithm ( ) . String ( ) , digest . Hex ( ) ) , nil } 
func Sign Docker Manifest ( m [ ] byte , docker Reference string , mech Signing Mechanism , key Identity string ) ( [ ] byte , error ) { manifest Digest , err : = manifest . Digest ( m ) if err ! = nil { return nil , err } sig : = new Untrusted Signature ( manifest Digest , docker Reference ) return sig . sign ( mech , key Identity ) } 
func Verify Docker Manifest Signature ( unverified Signature , unverified Manifest [ ] byte , expected Docker Reference string , mech Signing Mechanism , expected Key Identity string ) ( * Signature , error ) { expected Ref , err : = reference . Parse Normalized Named ( expected Docker Reference ) if err ! = nil { return nil , err } sig , err : = verify And Extract Signature ( mech , unverified Signature , signature Acceptance Rules { validate Key Identity : func ( key Identity string ) error { if key Identity ! = expected Key Identity { return Invalid Signature Error { msg : fmt . Sprintf ( " " , key Identity , expected Key Identity ) } } return nil } , validate Signed Docker Reference : func ( signed Docker Reference string ) error { signed Ref , err : = reference . Parse Normalized Named ( signed Docker Reference ) if err ! = nil { return Invalid Signature Error { msg : fmt . Sprintf ( " " , signed Docker Reference ) } } if signed Ref . String ( ) ! = expected Ref . String ( ) { return Invalid Signature Error { msg : fmt . Sprintf ( " " , signed Docker Reference , expected Docker Reference ) } } return nil } , validate Signed Docker Manifest Digest : func ( signed Docker Manifest Digest digest . Digest ) error { matches , err : = manifest . Matches Digest ( unverified Manifest , signed Docker Manifest Digest ) if err ! = nil { return err } if ! matches { return Invalid Signature Error { msg : fmt . Sprintf ( " " , signed Docker Manifest Digest ) } } return nil } , } ) if err ! = nil { return nil , err } return sig , nil } 
func new Openshift Client ( ref openshift Reference ) ( * openshift Client , error ) { logrus . Debugf ( " " , cmd Config ) rest Config , err : = cmd Config . Client Config ( ) if err ! = nil { return nil , err } base URL , http Client , err : = rest Client For ( rest Config ) if err ! = nil { return nil , err } logrus . Debugf ( " " , * base URL ) if http Client = = nil { http Client = http . Default Client } return & openshift Client { ref : ref , base URL : base URL , http Client : http Client , bearer Token : rest Config . Bearer Token , username : rest Config . Username , password : rest Config . Password , } , nil } 
func ( c * openshift Client ) do Request ( ctx context . Context , method , path string , request Body [ ] byte ) ( [ ] byte , error ) { url : = * c . base URL url . Path = path var request Body Reader io . Reader if request Body ! = nil { logrus . Debugf ( " " , request Body ) request Body Reader = bytes . New Reader ( request Body ) } req , err : = http . New Request ( method , url . String ( ) , request Body Reader ) if err ! = nil { return nil , err } req = req . With Context ( ctx ) if len ( c . bearer Token ) ! = 0 { req . Header . Set ( " " , " " + c . bearer Token ) } else if len ( c . username ) ! = 0 { req . Set Basic Auth ( c . username , c . password ) } req . Header . Set ( " " , " " ) req . Header . Set ( " " , fmt . Sprintf ( " " , version . Version ) ) if request Body ! = nil { req . Header . Set ( " " , " " ) } logrus . Debugf ( " " , method , url . String ( ) ) res , err : = c . http Client . Do ( req ) if err ! = nil { return nil , err } defer res . Body . Close ( ) body , err : = ioutil . Read All ( res . Body ) if err ! = nil { return nil , err } logrus . Debugf ( " " , body ) var status status status Valid : = false if err : = json . Unmarshal ( body , & status ) ; err = = nil & & len ( status . Status ) > 0 { status Valid = true } switch { case res . Status Code = = http . Status Switching Protocols : } case res . Status Code > = http . Status OK & & res . Status Code < = http . Status Partial Content : } return nil , errors . Errorf ( " " , res . Status Code , http . Status Text ( res . Status Code ) , string ( body ) ) } return body , nil } 
func ( c * openshift Client ) get Image ( ctx context . Context , image Stream Image Name string ) ( * image , error ) { body , err : = c . do Request ( ctx , " " , path , nil ) if err ! = nil { return nil , err } if err : = json . Unmarshal ( body , & isi ) ; err ! = nil { return nil , err } return & isi . Image , nil } 
func ( c * openshift Client ) convert Docker Image Reference ( ref string ) ( string , error ) { parts : = strings . Split N ( ref , " " , 2 ) if len ( parts ) ! = 2 { return " " , errors . Errorf ( " " , ref ) } return reference . Domain ( c . ref . docker Reference ) + " " + parts [ 1 ] , nil } 
func new Image Source ( sys * types . System Context , ref openshift Reference ) ( types . Image Source , error ) { client , err : = new Openshift Client ( ref ) if err ! = nil { return nil , err } return & openshift Image Source { client : client , sys : sys , } , nil } 
func ( s * openshift Image Source ) Close ( ) error { if s . docker ! = nil { err : = s . docker . Close ( ) s . docker = nil return err } return nil } 
func ( s * openshift Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if err : = s . ensure Image Is Resolved ( ctx ) ; err ! = nil { return nil , " " , err } return s . docker . Get Manifest ( ctx , instance Digest ) } 
func ( s * openshift Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { if err : = s . ensure Image Is Resolved ( ctx ) ; err ! = nil { return nil , 0 , err } return s . docker . Get Blob ( ctx , info , cache ) } 
func ( s * openshift Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { var image Name string if instance Digest = = nil { if err : = s . ensure Image Is Resolved ( ctx ) ; err ! = nil { return nil , err } image Name = s . image Stream Image Name } else { image Name = instance Digest . String ( ) } image , err : = s . client . get Image ( ctx , image Name ) if err ! = nil { return nil , err } var sigs [ ] [ ] byte for _ , sig : = range image . Signatures { if sig . Type = = image Signature Type Atomic { sigs = append ( sigs , sig . Content ) } } return sigs , nil } 
func ( s * openshift Image Source ) ensure Image Is Resolved ( ctx context . Context ) error { if s . docker ! = nil { return nil } body , err : = s . client . do Request ( ctx , " " , path , nil ) if err ! = nil { return err } if err : = json . Unmarshal ( body , & is ) ; err ! = nil { return err } var te * tag Event for _ , tag : = range is . Status . Tags { if tag . Tag ! = s . client . ref . docker Reference . Tag ( ) { continue } if len ( tag . Items ) > 0 { te = & tag . Items [ 0 ] break } } if te = = nil { return errors . Errorf ( " " ) } logrus . Debugf ( " " , te ) docker Ref String , err : = s . client . convert Docker Image Reference ( te . Docker Image Reference ) if err ! = nil { return err } logrus . Debugf ( " " , docker Ref String ) docker Ref , err : = docker . Parse Reference ( " " + docker Ref String ) if err ! = nil { return err } d , err : = docker Ref . New Image Source ( ctx , s . sys ) if err ! = nil { return err } s . docker = d s . image Stream Image Name = te . Image return nil } 
func new Image Destination ( ctx context . Context , sys * types . System Context , ref openshift Reference ) ( types . Image Destination , error ) { client , err : = new Openshift Client ( ref ) if err ! = nil { return nil , err } docker Ref , err : = docker . Parse Reference ( docker Ref String ) if err ! = nil { return nil , err } docker , err : = docker Ref . New Image Destination ( ctx , sys ) if err ! = nil { return nil , err } return & openshift Image Destination { client : client , docker : docker , } , nil } 
func ( d * openshift Image Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { return d . docker . Try Reusing Blob ( ctx , info , cache , can Substitute ) } 
func ( d * openshift Image Destination ) Put Manifest ( ctx context . Context , m [ ] byte ) error { manifest Digest , err : = manifest . Digest ( m ) if err ! = nil { return err } d . image Stream Image Name = manifest Digest . String ( ) return d . docker . Put Manifest ( ctx , m ) } 
func ( d * openshift Image Destination ) Commit ( ctx context . Context ) error { return d . docker . Commit ( ctx ) } 
func new Untrusted Signature ( docker Manifest Digest digest . Digest , docker Reference string ) untrusted Signature { timestamp : = time . Now ( ) . Unix ( ) return untrusted Signature { Untrusted Docker Manifest Digest : docker Manifest Digest , Untrusted Docker Reference : docker Reference , Untrusted Creator ID : & creator ID , Untrusted Timestamp : & timestamp , } } 
func ( s untrusted Signature ) Marshal JSON ( ) ( [ ] byte , error ) { if s . Untrusted Docker Manifest Digest = = " " | | s . Untrusted Docker Reference = = " " { return nil , errors . New ( " " ) } critical : = map [ string ] interface { } { " " : signature Type , " " : map [ string ] string { " " : s . Untrusted Docker Manifest Digest . String ( ) } , " " : map [ string ] string { " " : s . Untrusted Docker Reference } , } optional : = map [ string ] interface { } { } if s . Untrusted Creator ID ! = nil { optional [ " " ] = * s . Untrusted Creator ID } if s . Untrusted Timestamp ! = nil { optional [ " " ] = * s . Untrusted Timestamp } signature : = map [ string ] interface { } { " " : critical , " " : optional , } return json . Marshal ( signature ) } 
func ( s * untrusted Signature ) Unmarshal JSON ( data [ ] byte ) error { err : = s . strict Unmarshal JSON ( data ) if err ! = nil { if _ , ok : = err . ( json Format Error ) ; ok { err = Invalid Signature Error { msg : err . Error ( ) } } } return err } 
func ( s * untrusted Signature ) strict Unmarshal JSON ( data [ ] byte ) error { var critical , optional json . Raw Message if err : = paranoid Unmarshal JSONObject Exact Fields ( data , map [ string ] interface { } { " " : & critical , " " : & optional , } ) ; err ! = nil { return err } var creator ID string var timestamp float 6 4 var got Creator ID , got Timestamp = false , false if err : = paranoid Unmarshal JSONObject ( optional , func ( key string ) interface { } { switch key { case " " : got Creator ID = true return & creator ID case " " : got Timestamp = true return & timestamp default : var ignore interface { } return & ignore } } ) ; err ! = nil { return err } if got Creator ID { s . Untrusted Creator ID = & creator ID } if got Timestamp { int Timestamp : = int 6 4 ( timestamp ) if float 6 4 ( int Timestamp ) ! = timestamp { return Invalid Signature Error { msg : " " } } s . Untrusted Timestamp = & int Timestamp } var t string var image , identity json . Raw Message if err : = paranoid Unmarshal JSONObject Exact Fields ( critical , map [ string ] interface { } { " " : & t , " " : & image , " " : & identity , } ) ; err ! = nil { return err } if t ! = signature Type { return Invalid Signature Error { msg : fmt . Sprintf ( " " , t ) } } var digest String string if err : = paranoid Unmarshal JSONObject Exact Fields ( image , map [ string ] interface { } { " " : & digest String , } ) ; err ! = nil { return err } s . Untrusted Docker Manifest Digest = digest . Digest ( digest String ) return paranoid Unmarshal JSONObject Exact Fields ( identity , map [ string ] interface { } { " " : & s . Untrusted Docker Reference , } ) } 
func ( s untrusted Signature ) sign ( mech Signing Mechanism , key Identity string ) ( [ ] byte , error ) { json , err : = json . Marshal ( s ) if err ! = nil { return nil , err } return mech . Sign ( json , key Identity ) } 
func verify And Extract Signature ( mech Signing Mechanism , unverified Signature [ ] byte , rules signature Acceptance Rules ) ( * Signature , error ) { signed , key Identity , err : = mech . Verify ( unverified Signature ) if err ! = nil { return nil , err } if err : = rules . validate Key Identity ( key Identity ) ; err ! = nil { return nil , err } var unmatched Signature untrusted Signature if err : = json . Unmarshal ( signed , & unmatched Signature ) ; err ! = nil { return nil , Invalid Signature Error { msg : err . Error ( ) } } if err : = rules . validate Signed Docker Manifest Digest ( unmatched Signature . Untrusted Docker Manifest Digest ) ; err ! = nil { return nil , err } if err : = rules . validate Signed Docker Reference ( unmatched Signature . Untrusted Docker Reference ) ; err ! = nil { return nil , err } } 
func Get Untrusted Signature Information Without Verifying ( untrusted Signature Bytes [ ] byte ) ( * Untrusted Signature Information , error ) { if err ! = nil { return nil , err } defer mech . Close ( ) untrusted Contents , short Key Identifier , err : = mech . Untrusted Signature Contents ( untrusted Signature Bytes ) if err ! = nil { return nil , err } var untrusted Decoded Contents untrusted Signature if err : = json . Unmarshal ( untrusted Contents , & untrusted Decoded Contents ) ; err ! = nil { return nil , Invalid Signature Error { msg : err . Error ( ) } } var timestamp * time . Time if untrusted Decoded Contents . Untrusted Timestamp ! = nil { ts : = time . Unix ( * untrusted Decoded Contents . Untrusted Timestamp , 0 ) timestamp = & ts } return & Untrusted Signature Information { Untrusted Docker Manifest Digest : untrusted Decoded Contents . Untrusted Docker Manifest Digest , Untrusted Docker Reference : untrusted Decoded Contents . Untrusted Docker Reference , Untrusted Creator ID : untrusted Decoded Contents . Untrusted Creator ID , Untrusted Timestamp : timestamp , Untrusted Short Key Identifier : short Key Identifier , } , nil } 
func ( t daemon Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func ( t daemon Transport ) Validate Policy Configuration Scope ( scope string ) error { } } 
func Parse Reference ( ref String string ) ( types . Image Reference , error ) { } return New Reference ( dgst , nil ) } ref , err : = reference . Parse Normalized Named ( ref String ) if err ! = nil { return nil , err } if reference . Familiar Name ( ref ) = = digest . Canonical . String ( ) { return nil , errors . Errorf ( " " , ref String , digest . Canonical ) } return New Reference ( " " , ref ) } 
func New Reference ( id digest . Digest , ref reference . Named ) ( types . Image Reference , error ) { if id ! = " " & & ref ! = nil { return nil , errors . New ( " " ) } if ref ! = nil { if reference . Is Name Only ( ref ) { return nil , errors . Errorf ( " " , reference . Familiar String ( ref ) ) } _ , is Digested : = ref . ( reference . Canonical ) if is Tagged & & is Digested { return nil , errors . Errorf ( " " ) } } return daemon Reference { id : id , ref : ref , } , nil } 
func ( ref daemon Reference ) String Within Transport ( ) string { switch { case ref . id ! = " " : return ref . id . String ( ) case ref . ref ! = nil : return reference . Familiar String ( ref . ref ) default : } } 
func ( ref daemon Reference ) Policy Configuration Identity ( ) string { case ref . ref ! = nil : res , err : = policyconfiguration . Docker Reference Identity ( ref . ref ) if res = = " " | | err ! = nil { } return res default : } } 
func ( ref daemon Reference ) Policy Configuration Namespaces ( ) [ ] string { case ref . ref ! = nil : return policyconfiguration . Docker Reference Namespaces ( ref . ref ) default : } } 
func ( e * Endpoint ) Rewrite Reference ( ref reference . Named , prefix string ) ( reference . Named , error ) { if ref = = nil { return nil , fmt . Errorf ( " " ) } if prefix = = " " { return ref , nil } ref String : = ref . String ( ) if ref Matches Prefix ( ref String , prefix ) { new Named Ref : = strings . Replace ( ref String , prefix , e . Location , 1 ) new Parsed Ref , err : = reference . Parse Named ( new Named Ref ) if new Parsed Ref ! = nil { logrus . Debugf ( " " , ref String , new Parsed Ref . String ( ) ) } if err ! = nil { return nil , errors . Wrapf ( err , " " ) } return new Parsed Ref , nil } return nil , fmt . Errorf ( " " , prefix , ref String ) } 
func parse Location ( input string ) ( string , error ) { trimmed : = strings . Trim Right ( input , " " ) if trimmed = = " " { return " " , & Invalid Registries { s : " " } } if strings . Has Prefix ( trimmed , " " ) | | strings . Has Prefix ( trimmed , " " ) { msg : = fmt . Sprintf ( " " , input ) return " " , & Invalid Registries { s : msg } } return trimmed , nil } 
func get V 1Registries ( config * toml Config ) ( [ ] Registry , error ) { reg Map : = make ( map [ string ] * Registry ) get Registry : = func ( location string ) ( * Registry , error ) { location , err = parse Location ( location ) if err ! = nil { return nil , err } reg , exists : = reg Map [ location ] if ! exists { reg = & Registry { Endpoint : Endpoint { Location : location } , Mirrors : [ ] Endpoint { } , Prefix : location , } reg Map [ location ] = reg registry Order = append ( registry Order , location ) } return reg , nil } if err ! = nil { return nil , err } reg . Search = true } for _ , blocked : = range config . V 1TOMLConfig . Block . Registries { reg , err : = get Registry ( blocked ) if err ! = nil { return nil , err } reg . Blocked = true } for _ , insecure : = range config . V 1TOMLConfig . Insecure . Registries { reg , err : = get Registry ( insecure ) if err ! = nil { return nil , err } reg . Insecure = true } registries : = [ ] Registry { } for _ , location : = range registry Order { reg : = reg Map [ location ] registries = append ( registries , * reg ) } return registries , nil } 
func post Process Registries ( regs [ ] Registry ) ( [ ] Registry , error ) { var registries [ ] Registry reg Map : = make ( map [ string ] [ ] Registry ) for _ , reg : = range regs { var err error if err ! = nil { return nil , err } if reg . Prefix = = " " { reg . Prefix = reg . Location } else { reg . Prefix , err = parse Location ( reg . Prefix ) if err ! = nil { return nil , err } } if err ! = nil { return nil , err } } registries = append ( registries , reg ) reg Map [ reg . Location ] = append ( reg Map [ reg . Location ] , reg ) } for _ , other : = range others { if reg . Insecure ! = other . Insecure { msg : = fmt . Sprintf ( " " , reg . Location ) return nil , & Invalid Registries { s : msg } } if reg . Blocked ! = other . Blocked { msg : = fmt . Sprintf ( " " , reg . Location ) return nil , & Invalid Registries { s : msg } } } } return registries , nil } 
func get Config Path ( ctx * types . System Context ) string { conf Path : = system Registries Conf Path if ctx ! = nil { if ctx . System Registries Conf Path ! = " " { conf Path = ctx . System Registries Conf Path } else if ctx . Root For Implicit Absolute Paths ! = " " { conf Path = filepath . Join ( ctx . Root For Implicit Absolute Paths , system Registries Conf Path ) } } return conf Path } 
func Get Registries ( ctx * types . System Context ) ( [ ] Registry , error ) { config Path : = get Config Path ( ctx ) config Mutex . Lock ( ) defer config Mutex . Unlock ( ) } if err ! = nil { } return nil , err } registries : = config . Registries if err ! = nil { return nil , err } if len ( v 1Registries ) > 0 { if len ( registries ) > 0 { return nil , & Invalid Registries { s : " " } } registries = v 1Registries } registries , err = post Process Registries ( registries ) if err ! = nil { return nil , err } return registries , err } 
func Find Unqualified Search Registries ( ctx * types . System Context ) ( [ ] Registry , error ) { registries , err : = Get Registries ( ctx ) if err ! = nil { return nil , err } unqualified : = [ ] Registry { } for _ , reg : = range registries { if reg . Search { unqualified = append ( unqualified , reg ) } } return unqualified , nil } 
func ref Matches Prefix ( ref , prefix string ) bool { switch { case len ( ref ) < len ( prefix ) : return false case len ( ref ) = = len ( prefix ) : return ref = = prefix case len ( ref ) > len ( prefix ) : if ! strings . Has Prefix ( ref , prefix ) { return false } c : = ref [ len ( prefix ) ] default : panic ( " " ) } } 
func Find Registry ( ctx * types . System Context , ref string ) ( * Registry , error ) { registries , err : = Get Registries ( ctx ) if err ! = nil { return nil , err } reg : = Registry { } prefix Len : = 0 for _ , r : = range registries { if ref Matches Prefix ( ref , r . Prefix ) { length : = len ( r . Prefix ) if length > prefix Len { reg = r prefix Len = length } } } if prefix Len ! = 0 { return & reg , nil } return nil , nil } 
func read Registry Conf ( config Path string ) ( [ ] byte , error ) { config Bytes , err : = ioutil . Read File ( config Path ) return config Bytes , err } 
func load Registry Conf ( config Path string ) ( * toml Config , error ) { config : = & toml Config { } config Bytes , err : = read Conf ( config Path ) if err ! = nil { return nil , err } err = toml . Unmarshal ( config Bytes , & config ) return config , err } 
func ( s stub Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return nil , fmt . Errorf ( `The transport " %s : " is not supported in this build ` , string ( s ) ) } 
func From Source ( ctx context . Context , sys * types . System Context , src types . Image Source ) ( types . Image Closer , error ) { img , err : = From Unparsed Image ( ctx , sys , Unparsed Instance ( src , nil ) ) if err ! = nil { return nil , err } return & image Closer { Image : img , src : src , } , nil } 
func From Unparsed Image ( ctx context . Context , sys * types . System Context , unparsed * Unparsed Image ) ( types . Image , error ) { if err ! = nil { return nil , err } parsed Manifest , err : = manifest Instance From Blob ( ctx , sys , unparsed . src , manifest Blob , manifest MIMEType ) if err ! = nil { return nil , err } return & sourced Image { Unparsed Image : unparsed , manifest Blob : manifest Blob , manifest MIMEType : manifest MIMEType , generic Manifest : parsed Manifest , } , nil } 
func ( i * sourced Image ) Manifest ( ctx context . Context ) ( [ ] byte , string , error ) { return i . manifest Blob , i . manifest MIMEType , nil } 
func ( r * tarball Reference ) Config Update ( config imgspecv 1 . Image , annotations map [ string ] string ) error { r . config = config if r . annotations = = nil { r . annotations = make ( map [ string ] string ) } for k , v : = range annotations { r . annotations [ k ] = v } return nil } 
func ( r * tarball Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { src , err : = r . New Image Source ( ctx , sys ) if err ! = nil { return nil , err } img , err : = image . From Source ( ctx , sys , src ) if err ! = nil { src . Close ( ) return nil , err } return img , nil } 
func new Image Source ( sys * types . System Context , ref oci Reference ) ( types . Image Source , error ) { tr : = tlsclientconfig . New Transport ( ) tr . TLSClient Config = tlsconfig . Server Default ( ) if sys ! = nil & & sys . OCICert Path ! = " " { if err : = tlsclientconfig . Setup Certificates ( sys . OCICert Path , tr . TLSClient Config ) ; err ! = nil { return nil , err } tr . TLSClient Config . Insecure Skip Verify = sys . OCIInsecure Skip TLSVerify } client : = & http . Client { } client . Transport = tr descriptor , err : = ref . get Manifest Descriptor ( ) if err ! = nil { return nil , err } d : = & oci Image Source { ref : ref , descriptor : descriptor , client : client } if sys ! = nil { } return d , nil } 
func ( s * oci Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { var dig digest . Digest var mime Type string if instance Digest = = nil { dig = digest . Digest ( s . descriptor . Digest ) mime Type = s . descriptor . Media Type } else { dig = * instance Digest } manifest Path , err : = s . ref . blob Path ( dig , s . shared Blob Dir ) if err ! = nil { return nil , " " , err } m , err : = ioutil . Read File ( manifest Path ) if err ! = nil { return nil , " " , err } return m , mime Type , nil } 
func ( s * oci Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { if len ( info . URLs ) ! = 0 { return s . get External Blob ( ctx , info . URLs ) } path , err : = s . ref . blob Path ( info . Digest , s . shared Blob Dir ) if err ! = nil { return nil , 0 , err } r , err : = os . Open ( path ) if err ! = nil { return nil , 0 , err } fi , err : = r . Stat ( ) if err ! = nil { return nil , 0 , err } return r , fi . Size ( ) , nil } 
func ( s * oci Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { return [ ] [ ] byte { } , nil } 
func manifest OCI 1From Components ( config imgspecv 1 . Descriptor , src types . Image Source , config Blob [ ] byte , layers [ ] imgspecv 1 . Descriptor ) generic Manifest { return & manifest OCI 1 { src : src , config Blob : config Blob , m : manifest . OCI 1From Components ( config , layers ) , } } 
func ( m * manifest OCI 1 ) OCIConfig ( ctx context . Context ) ( * imgspecv 1 . Image , error ) { cb , err : = m . Config Blob ( ctx ) if err ! = nil { return nil , err } config OCI : = & imgspecv 1 . Image { } if err : = json . Unmarshal ( cb , config OCI ) ; err ! = nil { return nil , err } return config OCI , nil } 
func ( m * manifest OCI 1 ) Updated Image ( ctx context . Context , options types . Manifest Update Options ) ( types . Image , error ) { copy : = manifest OCI 1 { if options . Layer Infos ! = nil { if err : = copy . m . Update Layer Infos ( options . Layer Infos ) ; err ! = nil { return nil , err } } if err ! = nil { return nil , err } return m 2 . Updated Image ( ctx , types . Manifest Update Options { Manifest MIMEType : options . Manifest MIMEType , Information Only : options . Information Only , } ) case manifest . Docker V 2Schema 2Media Type : return copy . convert To Manifest Schema 2 ( ) default : return nil , errors . Errorf ( " " , imgspecv 1 . Media Type Image Manifest , options . Manifest MIMEType ) } return memory Image From Manifest ( & copy ) , nil } 
func parse Image And Docker Reference ( image types . Unparsed Image , s 2 string ) ( reference . Named , reference . Named , error ) { r 1 : = image . Reference ( ) . Docker Reference ( ) if r 1 = = nil { return nil , nil , Policy Requirement Error ( fmt . Sprintf ( " " , transports . Image Name ( image . Reference ( ) ) ) ) } r 2 , err : = reference . Parse Normalized Named ( s 2 ) if err ! = nil { return nil , nil , err } return r 1 , r 2 , nil } 
func parse Docker References ( s 1 , s 2 string ) ( reference . Named , reference . Named , error ) { r 1 , err : = reference . Parse Normalized Named ( s 1 ) if err ! = nil { return nil , nil , err } r 2 , err : = reference . Parse Normalized Named ( s 2 ) if err ! = nil { return nil , nil , err } return r 1 , r 2 , nil } 
func Image Name ( ref types . Image Reference ) string { return ref . Transport ( ) . Name ( ) + " " + ref . String Within Transport ( ) } 
func List Names ( ) [ ] string { kt . mu . Lock ( ) defer kt . mu . Unlock ( ) deprecated : = map [ string ] bool { " " : true , } var names [ ] string for _ , transport : = range kt . transports { if ! deprecated [ transport . Name ( ) ] { names = append ( names , transport . Name ( ) ) } } sort . Strings ( names ) return names } 
func ( t ostree Transport ) Validate Policy Configuration Scope ( scope string ) error { sep : = strings . Index ( scope , " " ) if sep < 0 { return errors . Errorf ( " " , scope ) } repo : = scope [ : sep ] if ! strings . Has Prefix ( repo , " " ) { return errors . Errorf ( " " , scope ) } cleaned : = filepath . Clean ( repo ) if cleaned ! = repo { return errors . Errorf ( `Invalid ostree : scope %s : Uses non -canonical path format , perhaps try with path %s ` , scope , cleaned ) } } 
func New Reference ( image string , repo string ) ( types . Image Reference , error ) { if err ! = nil { return nil , err } if reference . Is Name Only ( ostree Image ) { image = image + " " } resolved , err : = explicitfilepath . Resolve Path To Fully Explicit ( repo ) if err ! = nil { } else { return nil , err } } } return ostree Reference { image : image , branch Name : encode OStree Ref ( image ) , repo : resolved , } , nil } 
func ( ref ostree Reference ) String Within Transport ( ) string { return fmt . Sprintf ( " " , ref . image , ref . repo ) } 
func ( ref ostree Reference ) Policy Configuration Namespaces ( ) [ ] string { s : = strings . Split N ( ref . image , " " , 2 ) if len ( s ) ! = 2 { } name : = s [ 0 ] res : = [ ] string { } for { res = append ( res , fmt . Sprintf ( " " , ref . repo , name ) ) last Slash : = strings . Last Index ( name , " " ) if last Slash = = - 1 { break } name = name [ : last Slash ] } return res } 
func ( ref ostree Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { var tmp Dir string if sys = = nil | | sys . OSTree Tmp Dir Path = = " " { tmp Dir = os . Temp Dir ( ) } else { tmp Dir = sys . OSTree Tmp Dir Path } src , err : = new Image Source ( tmp Dir , ref ) if err ! = nil { return nil , err } return image . From Source ( ctx , sys , src ) } 
func ( ref ostree Reference ) New Image Source ( ctx context . Context , sys * types . System Context ) ( types . Image Source , error ) { var tmp Dir string if sys = = nil | | sys . OSTree Tmp Dir Path = = " " { tmp Dir = os . Temp Dir ( ) } else { tmp Dir = sys . OSTree Tmp Dir Path } return new Image Source ( tmp Dir , ref ) } 
func ( ref ostree Reference ) New Image Destination ( ctx context . Context , sys * types . System Context ) ( types . Image Destination , error ) { var tmp Dir string if sys = = nil | | sys . OSTree Tmp Dir Path = = " " { tmp Dir = os . Temp Dir ( ) } else { tmp Dir = sys . OSTree Tmp Dir Path } return new Image Destination ( ref , tmp Dir ) } 
func ( ref ostree Reference ) signature Path ( index int ) string { return filepath . Join ( " " , fmt . Sprintf ( " " , index + 1 ) ) } 
func paranoid Unmarshal JSONObject ( data [ ] byte , field Resolver func ( string ) interface { } ) error { seen Keys : = map [ string ] struct { } { } dec : = json . New Decoder ( bytes . New Reader ( data ) ) t , err : = dec . Token ( ) if err ! = nil { return json Format Error ( err . Error ( ) ) } if t ! = json . Delim ( ' { ' ) { return json Format Error ( fmt . Sprintf ( " \ " \ " " , t ) ) } for { t , err : = dec . Token ( ) if err ! = nil { return json Format Error ( err . Error ( ) ) } if t = = json . Delim ( ' } ' ) { break } key , ok : = t . ( string ) if ! ok { } if _ , ok : = seen Keys [ key ] ; ok { return json Format Error ( fmt . Sprintf ( " \ " \ " " , key ) ) } seen Keys [ key ] = struct { } { } value Ptr : = field Resolver ( key ) if value Ptr = = nil { return json Format Error ( fmt . Sprintf ( " \ " \ " " , key ) ) } } } if _ , err : = dec . Token ( ) ; err ! = io . EOF { return json Format Error ( " " ) } return nil } 
func paranoid Unmarshal JSONObject Exact Fields ( data [ ] byte , exact Fields map [ string ] interface { } ) error { seen Keys : = map [ string ] struct { } { } if err : = paranoid Unmarshal JSONObject ( data , func ( key string ) interface { } { if value Ptr , ok : = exact Fields [ key ] ; ok { seen Keys [ key ] = struct { } { } return value Ptr } return nil } ) ; err ! = nil { return err } for key : = range exact Fields { if _ , ok : = seen Keys [ key ] ; ! ok { return json Format Error ( fmt . Sprintf ( `Key " %s " missing in a JSON object ` , key ) ) } } return nil } 
func Validate Image Name ( image string ) error { if len ( image ) = = 0 { return nil } var err error if ! ref Regexp . Match String ( image ) { err = errors . Errorf ( " " , image ) } return err } 
func Split Path And Image ( reference string ) ( string , string ) { if runtime . GOOS = = " " { return split Path And Image Windows ( reference ) } return split Path And Image Non Windows ( reference ) } 
func Validate OCIPath ( path string ) error { if runtime . GOOS = = " " { } } else { if strings . Contains ( path , " " ) { return errors . Errorf ( " " , path ) } } return nil } 
func Validate Scope ( scope string ) error { var err error if runtime . GOOS = = " " { err = validate Scope Windows ( scope ) } else { err = validate Scope Non Windows ( scope ) } if err ! = nil { return err } cleaned : = filepath . Clean ( scope ) if cleaned ! = scope { return errors . Errorf ( `Invalid scope %s : Uses non -canonical path format , perhaps try with path %s ` , scope , cleaned ) } return nil } 
func Blob Info From Schema 2Descriptor ( desc Schema 2Descriptor ) types . Blob Info { return types . Blob Info { Digest : desc . Digest , Size : desc . Size , URLs : desc . URLs , Media Type : desc . Media Type , } } 
func Schema 2From Manifest ( manifest [ ] byte ) ( * Schema 2 , error ) { s 2 : = Schema 2 { } if err : = json . Unmarshal ( manifest , & s 2 ) ; err ! = nil { return nil , err } return & s 2 , nil } 
func Schema 2From Components ( config Schema 2Descriptor , layers [ ] Schema 2Descriptor ) * Schema 2 { return & Schema 2 { Schema Version : 2 , Media Type : Docker V 2Schema 2Media Type , Config Descriptor : config , Layers Descriptors : layers , } } 
func ( m * Schema 2 ) Layer Infos ( ) [ ] Layer Info { blobs : = [ ] Layer Info { } for _ , layer : = range m . Layers Descriptors { blobs = append ( blobs , Layer Info { Blob Info : Blob Info From Schema 2Descriptor ( layer ) , Empty Layer : false , } ) } return blobs } 
func ( m * Schema 2 ) Update Layer Infos ( layer Infos [ ] types . Blob Info ) error { if len ( m . Layers Descriptors ) ! = len ( layer Infos ) { return errors . Errorf ( " " , len ( m . Layers Descriptors ) , len ( layer Infos ) ) } original : = m . Layers Descriptors m . Layers Descriptors = make ( [ ] Schema 2Descriptor , len ( layer Infos ) ) for i , info : = range layer Infos { m . Layers Descriptors [ i ] . Media Type = original [ i ] . Media Type m . Layers Descriptors [ i ] . Digest = info . Digest m . Layers Descriptors [ i ] . Size = info . Size m . Layers Descriptors [ i ] . URLs = info . URLs } return nil } 
func ( m * Schema 2 ) Inspect ( config Getter func ( types . Blob Info ) ( [ ] byte , error ) ) ( * types . Image Inspect Info , error ) { config , err : = config Getter ( m . Config Info ( ) ) if err ! = nil { return nil , err } s 2 : = & Schema 2Image { } if err : = json . Unmarshal ( config , s 2 ) ; err ! = nil { return nil , err } i : = & types . Image Inspect Info { Tag : " " , Created : & s 2 . Created , Docker Version : s 2 . Docker Version , Architecture : s 2 . Architecture , Os : s 2 . OS , Layers : layer Infos To Strings ( m . Layer Infos ( ) ) , } if s 2 . Config ! = nil { i . Labels = s 2 . Config . Labels } return i , nil } 
func ( m * Schema 2 ) Image ID ( [ ] digest . Digest ) ( string , error ) { if err : = m . Config Descriptor . Digest . Validate ( ) ; err ! = nil { return " " , err } return m . Config Descriptor . Digest . Hex ( ) , nil } 
func Set Authentication ( sys * types . System Context , registry , username , password string ) error { return modify JSON ( sys , func ( auths * docker Config File ) ( bool , error ) { if ch , exists : = auths . Cred Helpers [ registry ] ; exists { return false , set Auth To Cred Helper ( ch , registry , username , password ) } creds : = base 6 4 . Std Encoding . Encode To String ( [ ] byte ( username + " " + password ) ) new Creds : = docker Auth Config { Auth : creds } auths . Auth Configs [ registry ] = new Creds return true , nil } ) } 
func Get Authentication ( sys * types . System Context , registry string ) ( string , string , error ) { if sys ! = nil & & sys . Docker Auth Config ! = nil { return sys . Docker Auth Config . Username , sys . Docker Auth Config . Password , nil } docker Legacy Path : = filepath . Join ( homedir . Get ( ) , docker Legacy Home Path ) var paths [ ] string path To Auth , err : = get Path To Auth ( sys ) if err = = nil { paths = append ( paths , path To Auth ) } else { } paths = append ( paths , filepath . Join ( homedir . Get ( ) , docker Home Path ) , docker Legacy Path ) for _ , path : = range paths { legacy Format : = path = = docker Legacy Path username , password , err : = find Authentication ( registry , path , legacy Format ) if err ! = nil { return " " , " " , err } if username ! = " " & & password ! = " " { return username , password , nil } } return " " , " " , nil } 
func Remove Authentication ( sys * types . System Context , registry string ) error { return modify JSON ( sys , func ( auths * docker Config File ) ( bool , error ) { } if _ , ok : = auths . Auth Configs [ registry ] ; ok { delete ( auths . Auth Configs , registry ) } else if _ , ok : = auths . Auth Configs [ normalize Registry ( registry ) ] ; ok { delete ( auths . Auth Configs , normalize Registry ( registry ) ) } else { return false , Err Not Logged In } return true , nil } ) } 
func Remove All Authentication ( sys * types . System Context ) error { return modify JSON ( sys , func ( auths * docker Config File ) ( bool , error ) { auths . Cred Helpers = make ( map [ string ] string ) auths . Auth Configs = make ( map [ string ] docker Auth Config ) return true , nil } ) } 
func get Path To Auth ( sys * types . System Context ) ( string , error ) { if sys ! = nil { if sys . Auth File Path ! = " " { return sys . Auth File Path , nil } if sys . Root For Implicit Absolute Paths ! = " " { return filepath . Join ( sys . Root For Implicit Absolute Paths , fmt . Sprintf ( default Per UIDPath Format , os . Getuid ( ) ) ) , nil } } runtime Dir : = os . Getenv ( " " ) if runtime Dir ! = " " { if os . Is Not Exist ( err ) { } return filepath . Join ( runtime Dir , xdg Runtime Dir Path ) , nil } return fmt . Sprintf ( default Per UIDPath Format , os . Getuid ( ) ) , nil } 
func read JSONFile ( path string , legacy Format bool ) ( docker Config File , error ) { var auths docker Config File raw , err : = ioutil . Read File ( path ) if err ! = nil { if os . Is Not Exist ( err ) { auths . Auth Configs = map [ string ] docker Auth Config { } return auths , nil } return docker Config File { } , err } if legacy Format { if err = json . Unmarshal ( raw , & auths . Auth Configs ) ; err ! = nil { return docker Config File { } , errors . Wrapf ( err , " " , path ) } return auths , nil } if err = json . Unmarshal ( raw , & auths ) ; err ! = nil { return docker Config File { } , errors . Wrapf ( err , " " , path ) } return auths , nil } 
func modify JSON ( sys * types . System Context , editor func ( auths * docker Config File ) ( bool , error ) ) error { path , err : = get Path To Auth ( sys ) if err ! = nil { return err } dir : = filepath . Dir ( path ) if _ , err : = os . Stat ( dir ) ; os . Is Not Exist ( err ) { if err = os . Mkdir All ( dir , 0 7 0 0 ) ; err ! = nil { return errors . Wrapf ( err , " " , dir ) } } auths , err : = read JSONFile ( path , false ) if err ! = nil { return errors . Wrapf ( err , " " , path ) } updated , err : = editor ( & auths ) if err ! = nil { return errors . Wrapf ( err , " " , path ) } if updated { new Data , err : = json . Marshal Indent ( auths , " " , " \t " ) if err ! = nil { return errors . Wrapf ( err , " " , path ) } if err = ioutil . Write File ( path , new Data , 0 7 5 5 ) ; err ! = nil { return errors . Wrapf ( err , " " , path ) } } return nil } 
func find Authentication ( registry , path string , legacy Format bool ) ( string , string , error ) { auths , err : = read JSONFile ( path , legacy Format ) if err ! = nil { return " " , " " , errors . Wrapf ( err , " " , path ) } } } normalized Auths : = map [ string ] docker Auth Config { } for k , v : = range auths . Auth Configs { normalized Auths [ normalize Registry ( k ) ] = v } if val , exists : = normalized Auths [ registry ] ; exists { return decode Docker Auth ( val . Auth ) } return " " , " " , nil } 
func convert To Hostname ( url string ) string { stripped : = url if strings . Has Prefix ( url , " " ) { stripped = strings . Trim Prefix ( url , " " ) } else if strings . Has Prefix ( url , " " ) { stripped = strings . Trim Prefix ( url , " " ) } name Parts : = strings . Split N ( stripped , " " , 2 ) return name Parts [ 0 ] } 
func ( is * tarball Image Source ) Get Blob ( ctx context . Context , blobinfo types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { } } reader , err : = os . Open ( is . filenames [ i ] ) if err ! = nil { return nil , - 1 , fmt . Errorf ( " " , is . filenames [ i ] , err ) } return reader , is . blob Sizes [ i ] , nil } } return nil , - 1 , fmt . Errorf ( " " , blobinfo . Digest . String ( ) ) } 
func ( is * tarball Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if instance Digest ! = nil { return nil , " " , fmt . Errorf ( " " , transport Name ) } return is . manifest , imgspecv 1 . Media Type Image Manifest , nil } 
func ( * tarball Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { if instance Digest ! = nil { return nil , fmt . Errorf ( " " , transport Name ) } return nil , nil } 
func ( * tarball Image Source ) Layer Infos For Copy ( ctx context . Context ) ( [ ] types . Blob Info , error ) { return nil , nil } 
func New Destination ( dest io . Writer , ref reference . Named Tagged ) * Destination { repo Tags : = [ ] reference . Named Tagged { } if ref ! = nil { repo Tags = append ( repo Tags , ref ) } return & Destination { writer : dest , tar : tar . New Writer ( dest ) , repo Tags : repo Tags , blobs : make ( map [ digest . Digest ] types . Blob Info ) , } } 
func ( d * Destination ) Add Repo Tags ( tags [ ] reference . Named Tagged ) { d . repo Tags = append ( d . repo Tags , tags . . . ) } 
func ( d * Destination ) Put Blob ( ctx context . Context , stream io . Reader , input Info types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { stream Copy , err : = ioutil . Temp File ( tmpdir . Temporary Directory For Big Files ( ) , " " ) if err ! = nil { return types . Blob Info { } , err } defer os . Remove ( stream Copy . Name ( ) ) defer stream Copy . Close ( ) digester : = digest . Canonical . Digester ( ) tee : = io . Tee Reader ( stream , digester . Hash ( ) ) if err ! = nil { return types . Blob Info { } , err } _ , err = stream Copy . Seek ( 0 , os . SEEK _SET ) if err ! = nil { return types . Blob Info { } , err } input Info . Size = size if input Info . Digest = = " " { input Info . Digest = digester . Digest ( ) } stream = stream Copy logrus . Debugf ( " " ) } if err ! = nil { return types . Blob Info { } , err } if ok { return reused Info , nil } if is Config { buf , err : = ioutil . Read All ( stream ) if err ! = nil { return types . Blob Info { } , errors . Wrap ( err , " " ) } d . config = buf if err : = d . send File ( input Info . Digest . Hex ( ) + " " , input Info . Size , bytes . New Reader ( buf ) ) ; err ! = nil { return types . Blob Info { } , errors . Wrap ( err , " " ) } } else { } } d . blobs [ input Info . Digest ] = types . Blob Info { Digest : input Info . Digest , Size : input Info . Size } return types . Blob Info { Digest : input Info . Digest , Size : input Info . Size } , nil } 
func ( d * Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { if info . Digest = = " " { return false , types . Blob Info { } , errors . Errorf ( " " ) } if blob , ok : = d . blobs [ info . Digest ] ; ok { return true , types . Blob Info { Digest : info . Digest , Size : blob . Size } , nil } return false , types . Blob Info { } , nil } 
func ( d * Destination ) Put Manifest ( ctx context . Context , m [ ] byte ) error { if err : = json . Unmarshal ( m , & man ) ; err ! = nil { return errors . Wrap ( err , " " ) } if man . Schema Version ! = 2 | | man . Media Type ! = manifest . Docker V 2Schema 2Media Type { return errors . Errorf ( " " ) } layer Paths , last Layer ID , err : = d . write Legacy Layer Metadata ( man . Layers Descriptors ) if err ! = nil { return err } if len ( man . Layers Descriptors ) > 0 { if err : = d . create Repositories File ( last Layer ID ) ; err ! = nil { return err } } repo Tags : = [ ] string { } for _ , tag : = range d . repo Tags { repo Tags = append ( repo Tags , ref String ) } items : = [ ] Manifest Item { { Config : man . Config Descriptor . Digest . Hex ( ) + " " , Repo Tags : repo Tags , Layers : layer Paths , Parent : " " , Layer Sources : nil , } } items Bytes , err : = json . Marshal ( & items ) if err ! = nil { return err } } 
func ( d * Destination ) write Legacy Layer Metadata ( layer Descriptors [ ] manifest . Schema 2Descriptor ) ( layer Paths [ ] string , last Layer ID string , err error ) { var chain ID digest . Digest last Layer ID = " " for i , l : = range layer Descriptors { } else { chain ID = digest . Canonical . From String ( chain ID . String ( ) + " " + l . Digest . String ( ) ) } physical Layer Path : = l . Digest . Hex ( ) + " " } b : = [ ] byte ( " " ) if err : = d . send Bytes ( filepath . Join ( layer ID , legacy Version File Name ) , b ) ; err ! = nil { return nil , " " , errors . Wrap ( err , " " ) } layer Config [ " " ] = layer ID } err : = json . Unmarshal ( d . config , & config ) if err ! = nil { return nil , " " , errors . Wrap ( err , " " ) } for _ , attr : = range [ 7 ] string { " " , " " , " " , " " , " " , " " , " " } { layer Config [ attr ] = config [ attr ] } } b , err : = json . Marshal ( layer Config ) if err ! = nil { return nil , " " , errors . Wrap ( err , " " ) } if err : = d . send Bytes ( filepath . Join ( layer ID , legacy Config File Name ) , b ) ; err ! = nil { return nil , " " , errors . Wrap ( err , " " ) } last Layer ID = layer ID } return layer Paths , last Layer ID , nil } 
func ( d * Destination ) send Symlink ( path string , target string ) error { hdr , err : = tar . File Info Header ( & tar FI { path : path , size : 0 , is Symlink : true } , target ) if err ! = nil { return nil } logrus . Debugf ( " " , path , target ) return d . tar . Write Header ( hdr ) } 
func ( d * Destination ) send Bytes ( path string , b [ ] byte ) error { return d . send File ( path , int 6 4 ( len ( b ) ) , bytes . New Reader ( b ) ) } 
func ( d * Destination ) send File ( path string , expected Size int 6 4 , stream io . Reader ) error { hdr , err : = tar . File Info Header ( & tar FI { path : path , size : expected Size } , " " ) if err ! = nil { return nil } logrus . Debugf ( " " , path ) if err : = d . tar . Write Header ( hdr ) ; err ! = nil { return err } if err ! = nil { return err } if size ! = expected Size { return errors . Errorf ( " " , path , expected Size , size ) } return nil } 
func ( d * Destination ) Put Signatures ( ctx context . Context , signatures [ ] [ ] byte ) error { if len ( signatures ) ! = 0 { return errors . Errorf ( " " ) } return nil } 
func ( d * Destination ) Commit ( ctx context . Context ) error { return d . tar . Close ( ) } 
func image Matches Repo ( image * storage . Image , ref reference . Named ) bool { repo : = ref . Name ( ) for _ , name : = range image . Names { if named , err : = reference . Parse Normalized Named ( name ) ; err = = nil { if named . Name ( ) = = repo { return true } } } return false } 
func ( s * storage Reference ) resolve Image ( ) ( * storage . Image , error ) { var loaded Image * storage . Image if s . id = = " " & & s . named ! = nil { if image ! = nil & & err = = nil { loaded Image = image s . id = image . ID } } if s . id = = " " & & s . named ! = nil { if digested , ok : = s . named . ( reference . Digested ) ; ok { if err = = nil & & len ( images ) > 0 { for _ , image : = range images { if image Matches Repo ( image , s . named ) { loaded Image = image s . id = image . ID break } } } } } if s . id = = " " { logrus . Debugf ( " " , s . String Within Transport ( ) ) return nil , errors . Wrapf ( Err No Such Image , " " , s . String Within Transport ( ) ) } if loaded Image = = nil { img , err : = s . transport . store . Image ( s . id ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s . id ) } loaded Image = img } if s . named ! = nil { if ! image Matches Repo ( loaded Image , s . named ) { logrus . Errorf ( " " , s . String Within Transport ( ) ) return nil , Err No Such Image } } } break } } } } return loaded Image , nil } 
func ( s storage Reference ) Transport ( ) types . Image Transport { return & storage Transport { store : s . transport . store , default UIDMap : s . transport . default UIDMap , default GIDMap : s . transport . default GIDMap , } } 
func ( s storage Reference ) String Within Transport ( ) string { options List : = " " options : = s . transport . store . Graph Options ( ) if len ( options ) > 0 { options List = " " + strings . Join ( options , " " ) } res : = " " + s . transport . store . Graph Driver Name ( ) + " " + s . transport . store . Graph Root ( ) + " " + s . transport . store . Run Root ( ) + options List + " " if s . named ! = nil { res = res + s . named . String ( ) } if s . id ! = " " { res = res + " " + s . id } return res } 
func ( s storage Reference ) Policy Configuration Namespaces ( ) [ ] string { store Spec : = " " + s . transport . store . Graph Driver Name ( ) + " " + s . transport . store . Graph Root ( ) + " " driverless Store Spec : = " " + s . transport . store . Graph Root ( ) + " " namespaces : = [ ] string { } if s . named ! = nil { if s . id ! = " " { } tagged , is Tagged : = s . named . ( reference . Tagged ) _ , is Digested : = s . named . ( reference . Digested ) if is Tagged & & is Digested { } components : = strings . Split ( s . named . Name ( ) , " " ) for len ( components ) > 0 { namespaces = append ( namespaces , store Spec + strings . Join ( components , " " ) ) components = components [ : len ( components ) - 1 ] } } namespaces = append ( namespaces , store Spec ) namespaces = append ( namespaces , driverless Store Spec ) return namespaces } 
func ( s storage Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { return new Image ( ctx , sys , s ) } 
func Docker Reference Identity ( ref reference . Named ) ( string , error ) { res : = ref . Name ( ) tagged , is Tagged : = ref . ( reference . Named Tagged ) digested , is Digested : = ref . ( reference . Canonical ) switch { case is Tagged & & is Digested : case ! is Tagged & & ! is Digested : case is Tagged : res = res + " " + tagged . Tag ( ) case is Digested : res = res + " " + digested . Digest ( ) . String ( ) default : } return res , nil } 
func Docker Reference Namespaces ( ref reference . Named ) [ ] string { name : = ref . Name ( ) for { res = append ( res , name ) last Slash : = strings . Last Index ( name , " " ) if last Slash = = - 1 { break } name = name [ : last Slash ] } return res } 
func Gzip Decompressor ( r io . Reader ) ( io . Read Closer , error ) { return pgzip . New Reader ( r ) } 
func Bzip 2Decompressor ( r io . Reader ) ( io . Read Closer , error ) { return ioutil . Nop Closer ( bzip 2 . New Reader ( r ) ) , nil } 
func Xz Decompressor ( r io . Reader ) ( io . Read Closer , error ) { r , err : = xz . New Reader ( r ) if err ! = nil { return nil , err } return ioutil . Nop Closer ( r ) , nil } 
func Detect Compression ( input io . Reader ) ( Decompressor Func , io . Reader , error ) { buffer : = [ 8 ] byte { } n , err : = io . Read At Least ( input , buffer [ : ] , len ( buffer ) ) if err ! = nil & & err ! = io . EOF & & err ! = io . Err Unexpected EOF { } var decompressor Decompressor Func for name , algo : = range compression Algos { if bytes . Has Prefix ( buffer [ : n ] , algo . prefix ) { logrus . Debugf ( " " , name ) decompressor = algo . decompressor break } } if decompressor = = nil { logrus . Debugf ( " " ) } return decompressor , io . Multi Reader ( bytes . New Reader ( buffer [ : n ] ) , input ) , nil } 
func Auto Decompress ( stream io . Reader ) ( io . Read Closer , bool , error ) { decompressor , stream , err : = Detect Compression ( stream ) if err ! = nil { return nil , false , errors . Wrapf ( err , " " ) } var res io . Read Closer if decompressor ! = nil { res , err = decompressor ( stream ) if err ! = nil { return nil , false , errors . Wrapf ( err , " " ) } } else { res = ioutil . Nop Closer ( stream ) } return res , decompressor ! = nil , nil } 
func new Image Destination ( sys * types . System Context , ref docker Reference ) ( types . Image Destination , error ) { c , err : = new Docker Client From Ref ( sys , ref , true , " " ) if err ! = nil { return nil , err } return & docker Image Destination { ref : ref , c : c , } , nil } 
func ( d * docker Image Destination ) Supports Signatures ( ctx context . Context ) error { if err : = d . c . detect Properties ( ctx ) ; err ! = nil { return err } switch { case d . c . signature Base ! = nil : return nil case d . c . supports Signatures : return nil default : return errors . Errorf ( " " ) } } 
func ( d * docker Image Destination ) Put Blob ( ctx context . Context , stream io . Reader , input Info types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { if input Info . Digest . String ( ) ! = " " { if err ! = nil { return types . Blob Info { } , err } if have Blob { return reused Info , nil } } logrus . Debugf ( " " , upload Path ) res , err : = d . c . make Request ( ctx , " " , upload Path , nil , nil , v 2Auth , nil ) if err ! = nil { return types . Blob Info { } , err } defer res . Body . Close ( ) if res . Status Code ! = http . Status Accepted { logrus . Debugf ( " " , * res ) return types . Blob Info { } , errors . Wrapf ( client . Handle Error Response ( res ) , " " , upload Path , d . c . registry ) } upload Location , err : = res . Location ( ) if err ! = nil { return types . Blob Info { } , errors . Wrap ( err , " " ) } digester : = digest . Canonical . Digester ( ) size Counter : = & size Counter { } tee : = io . Tee Reader ( stream , io . Multi Writer ( digester . Hash ( ) , size Counter ) ) res , err = d . c . make Request To Resolved URL ( ctx , " " , upload Location . String ( ) , map [ string ] [ ] string { " " : { " " } } , tee , input Info . Size , v 2Auth , nil ) if err ! = nil { logrus . Debugf ( " " , res ) return types . Blob Info { } , err } defer res . Body . Close ( ) computed Digest : = digester . Digest ( ) upload Location , err = res . Location ( ) if err ! = nil { return types . Blob Info { } , errors . Wrap ( err , " " ) } upload Location . Raw Query = location Query . Encode ( ) res , err = d . c . make Request To Resolved URL ( ctx , " " , upload Location . String ( ) , map [ string ] [ ] string { " " : { " " } } , nil , - 1 , v 2Auth , nil ) if err ! = nil { return types . Blob Info { } , err } defer res . Body . Close ( ) if res . Status Code ! = http . Status Created { logrus . Debugf ( " " , * res ) return types . Blob Info { } , errors . Wrapf ( client . Handle Error Response ( res ) , " " , upload Location ) } logrus . Debugf ( " " , computed Digest ) cache . Record Known Location ( d . ref . Transport ( ) , bic Transport Scope ( d . ref ) , computed Digest , new BICLocation Reference ( d . ref ) ) return types . Blob Info { Digest : computed Digest , Size : size Counter . size } , nil } 
func ( d * docker Image Destination ) blob Exists ( ctx context . Context , repo reference . Named , digest digest . Digest , extra Scope * auth Scope ) ( bool , int 6 4 , error ) { check Path : = fmt . Sprintf ( blobs Path , reference . Path ( repo ) , digest . String ( ) ) logrus . Debugf ( " " , check Path ) res , err : = d . c . make Request ( ctx , " " , check Path , nil , nil , v 2Auth , extra Scope ) if err ! = nil { return false , - 1 , err } defer res . Body . Close ( ) switch res . Status Code { case http . Status OK : logrus . Debugf ( " " ) return true , get Blob Size ( res ) , nil case http . Status Unauthorized : logrus . Debugf ( " " ) return false , - 1 , errors . Wrapf ( client . Handle Error Response ( res ) , " " , digest , repo . Name ( ) ) case http . Status Not Found : logrus . Debugf ( " " ) return false , - 1 , nil default : return false , - 1 , errors . Errorf ( " " , reference . Path ( d . ref . ref ) , res . Status Code , http . Status Text ( res . Status Code ) ) } } 
func ( d * docker Image Destination ) mount Blob ( ctx context . Context , src Repo reference . Named , src Digest digest . Digest , extra Scope * auth Scope ) error { u : = url . URL { Path : fmt . Sprintf ( blob Upload Path , reference . Path ( d . ref . ref ) ) , Raw Query : url . Values { " " : { src Digest . String ( ) } , " " : { reference . Path ( src Repo ) } , } . Encode ( ) , } mount Path : = u . String ( ) logrus . Debugf ( " " , mount Path ) res , err : = d . c . make Request ( ctx , " " , mount Path , nil , nil , v 2Auth , extra Scope ) if err ! = nil { return err } defer res . Body . Close ( ) switch res . Status Code { case http . Status Created : logrus . Debugf ( " " ) return nil case http . Status Accepted : if err ! = nil { return errors . Wrap ( err , " " ) } logrus . Debugf ( " " , upload Location . String ( ) ) res 2 , err : = d . c . make Request To Resolved URL ( ctx , " " , upload Location . String ( ) , nil , nil , - 1 , v 2Auth , extra Scope ) if err ! = nil { logrus . Debugf ( " " , err ) } else { defer res 2 . Body . Close ( ) if res 2 . Status Code ! = http . Status No Content { logrus . Debugf ( " " , http . Status Text ( res . Status Code ) ) } } default : logrus . Debugf ( " " , * res ) return errors . Wrapf ( client . Handle Error Response ( res ) , " " , src Digest , src Repo . Name ( ) , d . ref . ref . Name ( ) ) } } 
func ( d * docker Image Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { if info . Digest = = " " { return false , types . Blob Info { } , errors . Errorf ( ` "Can not check for a blob with unknown digest ` ) } / / First , check whether the blob happens to already exist at the destination . exists , size , err : = d . blob Exists ( ctx , d . ref . ref , info . Digest , nil ) if err ! = nil { return false , types . Blob Info { } , err } if exists { cache . Record Known Location ( d . ref . Transport ( ) , bic Transport Scope ( d . ref ) , info . Digest , new BICLocation Reference ( d . ref ) ) return true , types . Blob Info { Digest : info . Digest , Size : size } , nil } / / Then try reusing blobs from other locations . for _ , candidate : = range cache . Candidate Locations ( d . ref . Transport ( ) , bic Transport Scope ( d . ref ) , info . Digest , can Substitute ) { candidate Repo , err : = parse BICLocation Reference ( candidate . Location ) if err ! = nil { logrus . Debugf ( " " , err ) continue } logrus . Debugf ( " " , candidate . Digest . String ( ) , candidate Repo . Name ( ) ) / / Sanity checks : if reference . Domain ( candidate Repo ) ! = reference . Domain ( d . ref . ref ) { logrus . Debugf ( " " , reference . Domain ( candidate Repo ) , reference . Domain ( d . ref . ref ) ) continue } if candidate Repo . Name ( ) = = d . ref . ref . Name ( ) & & candidate . Digest = = info . Digest { logrus . Debug ( " " ) continue } / / Whatever happens here , don 't abort the entire operation . It 's likely we just don 't have permissions , and if it is a critical network error , we will find out soon enough anyway . / / Checking candidate Repo , and mounting from it , requires an / / expanded token scope . extra Scope : = & auth Scope { remote Name : reference . Path ( candidate Repo ) , actions : " " , } / / This existence check is not , strictly speaking , necessary : We only _really _ need it to get the blob size , and we could record that in the cache instead . / / But a "failed " d .mount Blob currently leaves around an unterminated server -side upload , which we would try to cancel . / / So , without this existence check , it would be 1 request on success , 2 requests on failure ; with it , it is 2 requests on success , 1 request on failure . / / On success we avoid the actual costly upload ; so , in a sense , the success case is "free " , but failures are always costly . / / Even worse , docker /distribution does not actually reasonably implement canceling uploads / / (it would require a "delete " action in the token , and Quay does not give that to anyone , so we can 't ask ) ; / / so , be a nice client and don 't create unnecesary upload sessions on the server . exists , size , err : = d . blob Exists ( ctx , candidate Repo , candidate . Digest , extra Scope ) if err ! = nil { logrus . Debugf ( " " , err ) continue } if ! exists { / / FIXME ? Should we drop the blob from cache here (and elsewhere ? ) ? continue / / logrus .Debug ( ) already happened in blob Exists } if candidate Repo . Name ( ) ! = d . ref . ref . Name ( ) { if err : = d . mount Blob ( ctx , candidate Repo , candidate . Digest , extra Scope ) ; err ! = nil { logrus . Debugf ( " " , err ) continue } } cache . Record Known Location ( d . ref . Transport ( ) , bic Transport Scope ( d . ref ) , candidate . Digest , new BICLocation Reference ( d . ref ) ) return true , types . Blob Info { Digest : candidate . Digest , Size : size } , nil } return false , types . Blob Info { } , nil } 
func ( d * docker Image Destination ) Put Manifest ( ctx context . Context , m [ ] byte ) error { digest , err : = manifest . Digest ( m ) if err ! = nil { return err } d . manifest Digest = digest ref Tail , err : = d . ref . tag Or Digest ( ) if err ! = nil { return err } path : = fmt . Sprintf ( manifest Path , reference . Path ( d . ref . ref ) , ref Tail ) headers : = map [ string ] [ ] string { } mime Type : = manifest . Guess MIMEType ( m ) if mime Type ! = " " { headers [ " " ] = [ ] string { mime Type } } res , err : = d . c . make Request ( ctx , " " , path , headers , bytes . New Reader ( m ) , v 2Auth , nil ) if err ! = nil { return err } defer res . Body . Close ( ) if ! success Status ( res . Status Code ) { err = errors . Wrapf ( client . Handle Error Response ( res ) , " " , ref Tail , d . ref . ref . Name ( ) ) if is Manifest Invalid Error ( errors . Cause ( err ) ) { err = types . Manifest Type Rejected Error { Err : err } } return err } return nil } 
func is Manifest Invalid Error ( err error ) bool { errors , ok : = err . ( errcode . Errors ) if ! ok | | len ( errors ) = = 0 { return false } err = errors [ 0 ] ec , ok : = err . ( errcode . Error Coder ) if ! ok { return false } switch ec . Error Code ( ) { default : return false } } 
func ( d * docker Image Destination ) put Signatures To Lookaside ( signatures [ ] [ ] byte ) error { } if d . manifest Digest . String ( ) = = " " { } if url = = nil { return errors . Errorf ( " " ) } err : = d . put One Signature ( url , signature ) if err ! = nil { return err } } if url = = nil { return errors . Errorf ( " " ) } missing , err : = d . c . delete One Signature ( url ) if err ! = nil { return err } if missing { break } } return nil } 
func ( d * docker Image Destination ) put One Signature ( url * url . URL , signature [ ] byte ) error { switch url . Scheme { case " " : logrus . Debugf ( " " , url . Path ) err : = os . Mkdir All ( filepath . Dir ( url . Path ) , 0 7 5 5 ) if err ! = nil { return err } err = ioutil . Write File ( url . Path , signature , 0 6 4 4 ) if err ! = nil { return err } return nil case " " , " " : return errors . Errorf ( " " , url . Scheme , url . String ( ) ) default : return errors . Errorf ( " " , url . String ( ) ) } } 
func ( c * docker Client ) delete One Signature ( url * url . URL ) ( missing bool , err error ) { switch url . Scheme { case " " : logrus . Debugf ( " " , url . Path ) err : = os . Remove ( url . Path ) if err ! = nil & & os . Is Not Exist ( err ) { return true , nil } return false , err case " " , " " : return false , errors . Errorf ( " " , url . Scheme , url . String ( ) ) default : return false , errors . Errorf ( " " , url . String ( ) ) } } 
func ( d * docker Image Destination ) put Signatures To APIExtension ( ctx context . Context , signatures [ ] [ ] byte ) error { } if d . manifest Digest . String ( ) = = " " { } if err ! = nil { return err } existing Sig Names : = map [ string ] struct { } { } for _ , sig : = range existing Signatures . Signatures { existing Sig Names [ sig . Name ] = struct { } { } } sig Exists : for _ , new Sig : = range signatures { for _ , existing Sig : = range existing Signatures . Signatures { if existing Sig . Version = = extension Signature Schema Version & & existing Sig . Type = = extension Signature Type Atomic & & bytes . Equal ( existing Sig . Content , new Sig ) { continue sig Exists } } for { rand Bytes : = make ( [ ] byte , 1 6 ) n , err : = rand . Read ( rand Bytes ) if err ! = nil | | n ! = 1 6 { return errors . Wrapf ( err , " " , n ) } signature Name = fmt . Sprintf ( " " , d . manifest Digest . String ( ) , rand Bytes ) if _ , ok : = existing Sig Names [ signature Name ] ; ! ok { break } } sig : = extension Signature { Version : extension Signature Schema Version , Name : signature Name , Type : extension Signature Type Atomic , Content : new Sig , } body , err : = json . Marshal ( sig ) if err ! = nil { return err } path : = fmt . Sprintf ( extensions Signature Path , reference . Path ( d . ref . ref ) , d . manifest Digest . String ( ) ) res , err : = d . c . make Request ( ctx , " " , path , nil , bytes . New Reader ( body ) , v 2Auth , nil ) if err ! = nil { return err } defer res . Body . Close ( ) if res . Status Code ! = http . Status Created { body , err : = ioutil . Read All ( res . Body ) if err = = nil { logrus . Debugf ( " " , string ( body ) ) } logrus . Debugf ( " " , res . Status Code , res ) return errors . Wrapf ( client . Handle Error Response ( res ) , " " , path , d . c . registry ) } } return nil } 
func bic Transport Scope ( ref docker Reference ) types . BICTransport Scope { } 
func new BICLocation Reference ( ref docker Reference ) types . BICLocation Reference { } 
func parse BICLocation Reference ( lr types . BICLocation Reference ) ( reference . Named , error ) { return reference . Parse Normalized Named ( lr . Opaque ) } 
func New Source From File ( path string ) ( * Source , error ) { file , err : = os . Open ( path ) if err ! = nil { return nil , errors . Wrapf ( err , " " , path ) } defer file . Close ( ) if err ! = nil { return nil , errors . Wrapf ( err , " " , path ) } defer stream . Close ( ) if ! is Compressed { return & Source { tar Path : path , } , nil } return New Source From Stream ( stream ) } 
func New Source From Stream ( input Stream io . Reader ) ( * Source , error ) { if err ! = nil { return nil , errors . Wrap ( err , " " ) } defer tar Copy File . Close ( ) succeeded : = false defer func ( ) { if ! succeeded { os . Remove ( tar Copy File . Name ( ) ) } } ( ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } defer uncompressed Stream . Close ( ) } succeeded = true return & Source { tar Path : tar Copy File . Name ( ) , remove Tar Path On Close : true , } , nil } 
func ( s * Source ) open Tar Component ( component Path string ) ( io . Read Closer , error ) { f , err : = os . Open ( s . tar Path ) if err ! = nil { return nil , err } succeeded : = false defer func ( ) { if ! succeeded { f . Close ( ) } } ( ) tar Reader , header , err : = find Tar Component ( f , component Path ) if err ! = nil { return nil , err } if header = = nil { return nil , os . Err Not Exist } if header . File Info ( ) . Mode ( ) & os . Mode Type = = os . Mode Symlink { } if err ! = nil { return nil , err } if header = = nil { return nil , os . Err Not Exist } } if ! header . File Info ( ) . Mode ( ) . Is Regular ( ) { return nil , errors . Errorf ( " " , header . Name ) } succeeded = true return & tar Read Closer { Reader : tar Reader , backing File : f } , nil } 
func find Tar Component ( input File io . Reader , path string ) ( * tar . Reader , * tar . Header , error ) { t : = tar . New Reader ( input File ) for { h , err : = t . Next ( ) if err = = io . EOF { break } if err ! = nil { return nil , nil , err } if h . Name = = path { return t , h , nil } } return nil , nil , nil } 
func ( s * Source ) read Tar Component ( path string ) ( [ ] byte , error ) { file , err : = s . open Tar Component ( path ) if err ! = nil { return nil , errors . Wrapf ( err , " " , path ) } defer file . Close ( ) bytes , err : = ioutil . Read All ( file ) if err ! = nil { return nil , err } return bytes , nil } 
func ( s * Source ) ensure Cached Data Is Present ( ) error { s . cache Data Lock . Do ( func ( ) { if err ! = nil { s . cache Data Result = err return } return } if err ! = nil { s . cache Data Result = err return } var parsed Config manifest . Schema 2Image if err : = json . Unmarshal ( config Bytes , & parsed Config ) ; err ! = nil { s . cache Data Result = errors . Wrapf ( err , " " , tar Manifest [ 0 ] . Config ) return } known Layers , err : = s . prepare Layer Data ( & tar Manifest [ 0 ] , & parsed Config ) if err ! = nil { s . cache Data Result = err return } s . config Bytes = config Bytes s . config Digest = digest . From Bytes ( config Bytes ) s . ordered Diff IDList = parsed Config . Root FS . Diff IDs s . known Layers = known Layers } ) return s . cache Data Result } 
func ( s * Source ) load Tar Manifest ( ) ( [ ] Manifest Item , error ) { if err ! = nil { return nil , err } var items [ ] Manifest Item if err : = json . Unmarshal ( bytes , & items ) ; err ! = nil { return nil , errors . Wrap ( err , " " ) } return items , nil } 
func ( s * Source ) Close ( ) error { if s . remove Tar Path On Close { return os . Remove ( s . tar Path ) } return nil } 
func ( s * Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if instance Digest ! = nil { } if s . generated Manifest = = nil { if err : = s . ensure Cached Data Is Present ( ) ; err ! = nil { return nil , " " , err } m : = manifest . Schema 2 { Schema Version : 2 , Media Type : manifest . Docker V 2Schema 2Media Type , Config Descriptor : manifest . Schema 2Descriptor { Media Type : manifest . Docker V 2Schema 2Config Media Type , Size : int 6 4 ( len ( s . config Bytes ) ) , Digest : s . config Digest , } , Layers Descriptors : [ ] manifest . Schema 2Descriptor { } , } for _ , diff ID : = range s . ordered Diff IDList { li , ok : = s . known Layers [ diff ID ] if ! ok { return nil , " " , errors . Errorf ( " " , diff ID ) } m . Layers Descriptors = append ( m . Layers Descriptors , manifest . Schema 2Descriptor { Digest : diff ID , } manifest Bytes , err : = json . Marshal ( & m ) if err ! = nil { return nil , " " , err } s . generated Manifest = manifest Bytes } return s . generated Manifest , manifest . Docker V 2Schema 2Media Type , nil } 
func ( s * Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { if err : = s . ensure Cached Data Is Present ( ) ; err ! = nil { return nil , 0 , err } if info . Digest = = s . config Digest { } if li , ok : = s . known Layers [ info . Digest ] ; ok { if err ! = nil { return nil , 0 , err } close Underlying Stream : = true defer func ( ) { if close Underlying Stream { underlying Stream . Close ( ) } } ( ) if err ! = nil { return nil , 0 , errors . Wrapf ( err , " " , info . Digest ) } new Stream : = uncompressed Read Closer { Reader : uncompressed Stream , underlying Closer : underlying Stream . Close , uncompressed Closer : uncompressed Stream . Close , } close Underlying Stream = false return new Stream , li . size , nil } return nil , 0 , errors . Errorf ( " " , info . Digest ) } 
func ( s * Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { if instance Digest ! = nil { } return [ ] [ ] byte { } , nil } 
func new Image Destination ( ctx context . Context , sys * types . System Context , ref daemon Reference ) ( types . Image Destination , error ) { if ref . ref = = nil { return nil , errors . Errorf ( " " , ref . String Within Transport ( ) ) } named Tagged Ref , ok : = ref . ref . ( reference . Named Tagged ) if ! ok { return nil , errors . Errorf ( " " , ref . String Within Transport ( ) ) } var must Match Runtime OS = true if sys ! = nil & & sys . Docker Daemon Host ! = client . Default Docker Host { must Match Runtime OS = false } c , err : = new Docker Client ( sys ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } reader , writer : = io . Pipe ( ) goroutine Context , goroutine Cancel : = context . With Cancel ( ctx ) go image Load Goroutine ( goroutine Context , c , reader , status Channel ) return & daemon Image Destination { ref : ref , must Match Runtime OS : must Match Runtime OS , Destination : tarfile . New Destination ( writer , named Tagged Ref ) , goroutine Cancel : goroutine Cancel , status Channel : status Channel , writer : writer , committed : false , } , nil } 
func image Load Goroutine ( ctx context . Context , c * client . Client , reader * io . Pipe Reader , status Channel chan < - error ) { err : = errors . New ( " " ) defer func ( ) { logrus . Debugf ( " " , err ) status Channel < - err } ( ) defer func ( ) { if err = = nil { reader . Close ( ) } else { reader . Close With Error ( err ) } } ( ) resp , err : = c . Image Load ( ctx , reader , true ) if err ! = nil { err = errors . Wrap ( err , " " ) return } defer resp . Body . Close ( ) } 
func ( d * daemon Image Destination ) Close ( ) error { if ! d . committed { logrus . Debugf ( " " ) } d . goroutine Cancel ( ) return nil } 
func ( d * daemon Image Destination ) Commit ( ctx context . Context ) error { logrus . Debugf ( " " ) if err : = d . Destination . Commit ( ctx ) ; err ! = nil { return err } if err : = d . writer . Close ( ) ; err ! = nil { return err } d . committed = true logrus . Debugf ( " " ) select { case < - ctx . Done ( ) : return ctx . Err ( ) case err : = < - d . status Channel : return err } } 
func ( t oci Archive Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func New Reference ( file , image string ) ( types . Image Reference , error ) { resolved , err : = explicitfilepath . Resolve Path To Fully Explicit ( file ) if err ! = nil { return nil , err } if err : = internal . Validate OCIPath ( file ) ; err ! = nil { return nil , err } if err : = internal . Validate Image Name ( image ) ; err ! = nil { return nil , err } return oci Archive Reference { file : file , resolved File : resolved , image : image } , nil } 
func ( ref oci Archive Reference ) String Within Transport ( ) string { return fmt . Sprintf ( " " , ref . file , ref . image ) } 
func ( ref oci Archive Reference ) Policy Configuration Namespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolved File for { last Slash : = strings . Last Index ( path , " " ) } res = append ( res , path ) path = path [ : last Slash ] } return res } 
func ( ref oci Archive Reference ) Delete Image ( ctx context . Context , sys * types . System Context ) error { return errors . Errorf ( " " ) } 
func create OCIRef ( image string ) ( temp Dir OCIRef , error ) { dir , err : = ioutil . Temp Dir ( tmpdir . Temporary Directory For Big Files ( ) , " " ) if err ! = nil { return temp Dir OCIRef { } , errors . Wrapf ( err , " " ) } oci Ref , err : = ocilayout . New Reference ( dir , image ) if err ! = nil { return temp Dir OCIRef { } , err } temp Dir Ref : = temp Dir OCIRef { temp Directory : dir , oci Ref Extracted : oci Ref } return temp Dir Ref , nil } 
func create Untar Temp Dir ( ref oci Archive Reference ) ( temp Dir OCIRef , error ) { temp Dir Ref , err : = create OCIRef ( ref . image ) if err ! = nil { return temp Dir OCIRef { } , errors . Wrap ( err , " " ) } src : = ref . resolved File dst : = temp Dir Ref . temp Directory } return temp Dir OCIRef { } , errors . Wrapf ( err , " " , temp Dir Ref . temp Directory ) } return temp Dir Ref , nil } 
func destructively Prioritize Replacement Candidates With Max ( cs [ ] Candidate With Time , primary Digest , uncompressed Digest digest . Digest , max Candidates int ) [ ] types . BICReplacement Candidate { res Length : = len ( cs ) if res Length > max Candidates { res Length = max Candidates } res : = make ( [ ] types . BICReplacement Candidate , res Length ) for i : = range res { res [ i ] = cs [ i ] . Candidate } return res } 
func Destructively Prioritize Replacement Candidates ( cs [ ] Candidate With Time , primary Digest , uncompressed Digest digest . Digest ) [ ] types . BICReplacement Candidate { return destructively Prioritize Replacement Candidates With Max ( cs , primary Digest , uncompressed Digest , replacement Attempts ) } 
func new Image Destination ( ref ostree Reference , tmp Dir Path string ) ( types . Image Destination , error ) { tmp Dir Path = filepath . Join ( tmp Dir Path , ref . branch Name ) if err : = ensure Directory Exists ( tmp Dir Path ) ; err ! = nil { return nil , err } return & ostree Image Destination { ref , " " , manifest Schema { } , tmp Dir Path , map [ string ] * blob To Import { } , " " , 0 , nil } , nil } 
func ( d * ostree Image Destination ) Close ( ) error { if d . repo ! = nil { C . g _object _unref ( C . gpointer ( d . repo ) ) } return os . Remove All ( d . tmp Dir Path ) } 
func ( d * ostree Image Destination ) Put Blob ( ctx context . Context , stream io . Reader , input Info types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { tmp Dir , err : = ioutil . Temp Dir ( d . tmp Dir Path , " " ) if err ! = nil { return types . Blob Info { } , err } blob Path : = filepath . Join ( tmp Dir , " " ) blob File , err : = os . Create ( blob Path ) if err ! = nil { return types . Blob Info { } , err } defer blob File . Close ( ) digester : = digest . Canonical . Digester ( ) tee : = io . Tee Reader ( stream , digester . Hash ( ) ) if err ! = nil { return types . Blob Info { } , err } computed Digest : = digester . Digest ( ) if input Info . Size ! = - 1 & & size ! = input Info . Size { return types . Blob Info { } , errors . Errorf ( " " , computed Digest , input Info . Size , size ) } if err : = blob File . Sync ( ) ; err ! = nil { return types . Blob Info { } , err } hash : = computed Digest . Hex ( ) d . blobs [ hash ] = & blob To Import { Size : size , Digest : computed Digest , Blob Path : blob Path } return types . Blob Info { Digest : computed Digest , Size : size } , nil } 
func ( d * ostree Image Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { if d . repo = = nil { repo , err : = open Repo ( d . ref . repo ) if err ! = nil { return false , types . Blob Info { } , err } d . repo = repo } branch : = fmt . Sprintf ( " " , info . Digest . Hex ( ) ) found , data , err : = read Metadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . Blob Info { } , err } found , data , err = read Metadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . Blob Info { } , err } found , data , err = read Metadata ( d . repo , branch , " " ) if err ! = nil | | ! found { return found , types . Blob Info { } , err } size , err : = strconv . Parse Int ( data , 1 0 , 6 4 ) if err ! = nil { return false , types . Blob Info { } , err } return true , types . Blob Info { Digest : info . Digest , Size : size } , nil } 
func ( d * ostree Image Destination ) Put Manifest ( ctx context . Context , manifest Blob [ ] byte ) error { d . manifest = string ( manifest Blob ) if err : = json . Unmarshal ( manifest Blob , & d . schema ) ; err ! = nil { return err } manifest Path : = filepath . Join ( d . tmp Dir Path , d . ref . manifest Path ( ) ) if err : = ensure Parent Directory Exists ( manifest Path ) ; err ! = nil { return err } digest , err : = manifest . Digest ( manifest Blob ) if err ! = nil { return err } d . digest = digest return ioutil . Write File ( manifest Path , manifest Blob , 0 6 4 4 ) } 
func Resolve Path To Fully Explicit ( path string ) ( string , error ) { switch _ , err : = os . Lstat ( path ) ; { case err = = nil : return resolve Existing Path To Fully Explicit ( path ) case os . Is Not Exist ( err ) : parent , file : = filepath . Split ( path ) resolved Parent , err : = resolve Existing Path To Fully Explicit ( parent ) if err ! = nil { return " " , err } if file = = " " | | file = = " " { } resolved Path : = filepath . Join ( resolved Parent , file ) if cleaned Resolved Path ! = resolved Path { } return resolved Path , nil default : } } 
func resolve Existing Path To Fully Explicit ( path string ) ( string , error ) { resolved , err : = filepath . Abs ( path ) if err ! = nil { return " " , err } resolved , err = filepath . Eval Symlinks ( resolved ) if err ! = nil { return " " , err } return filepath . Clean ( resolved ) , nil } 
func new Image Destination ( ref dir Reference , compress bool ) ( types . Image Destination , error ) { d : = & dir Image Destination { ref : ref , compress : compress } if err ! = nil { return nil , errors . Wrapf ( err , " " , d . ref . resolved Path ) } if dir Exists { is Empty , err : = is Dir Empty ( d . ref . resolved Path ) if err ! = nil { return nil , err } if ! is Empty { version Exists , err : = path Exists ( d . ref . version Path ( ) ) if err ! = nil { return nil , errors . Wrapf ( err , " " , d . ref . version Path ( ) ) } if version Exists { contents , err : = ioutil . Read File ( d . ref . version Path ( ) ) if err ! = nil { return nil , err } } } else { return nil , Err Not Container Image Dir } } logrus . Debugf ( " " , d . ref . resolved Path ) } } else { } } if err ! = nil { return nil , errors . Wrapf ( err , " " , d . ref . version Path ( ) ) } return d , nil } 
func ( d * dir Image Destination ) Put Manifest ( ctx context . Context , manifest [ ] byte ) error { return ioutil . Write File ( d . ref . manifest Path ( ) , manifest , 0 6 4 4 ) } 
func is Dir Empty ( path string ) ( bool , error ) { files , err : = ioutil . Read Dir ( path ) if err ! = nil { return false , err } return len ( files ) = = 0 , nil } 
func remove Dir Contents ( path string ) error { files , err : = ioutil . Read Dir ( path ) if err ! = nil { return err } for _ , file : = range files { if err : = os . Remove All ( filepath . Join ( path , file . Name ( ) ) ) ; err ! = nil { return err } } return nil } 
func new Image ( ctx context . Context , sys * types . System Context , ref docker Reference ) ( types . Image Closer , error ) { s , err : = new Image Source ( ctx , sys , ref ) if err ! = nil { return nil , err } img , err : = image . From Source ( ctx , sys , s ) if err ! = nil { return nil , err } return & Image { Image Closer : img , src : s } , nil } 
func ( i * Image ) Get Repository Tags ( ctx context . Context ) ( [ ] string , error ) { return Get Repository Tags ( ctx , i . src . c . sys , i . src . ref ) } 
func Get Repository Tags ( ctx context . Context , sys * types . System Context , ref types . Image Reference ) ( [ ] string , error ) { dr , ok : = ref . ( docker Reference ) if ! ok { return nil , errors . Errorf ( " " ) } path : = fmt . Sprintf ( tags Path , reference . Path ( dr . ref ) ) client , err : = new Docker Client From Ref ( sys , dr , false , " " ) if err ! = nil { return nil , errors . Wrap ( err , " " ) } tags : = make ( [ ] string , 0 ) for { res , err : = client . make Request ( ctx , " " , path , nil , nil , v 2Auth , nil ) if err ! = nil { return nil , err } defer res . Body . Close ( ) if res . Status Code ! = http . Status OK { } var tags Holder struct { Tags [ ] string } if err = json . New Decoder ( res . Body ) . Decode ( & tags Holder ) ; err ! = nil { return nil , err } tags = append ( tags , tags Holder . Tags . . . ) link : = res . Header . Get ( " " ) if link = = " " { break } link URLStr : = strings . Trim ( strings . Split ( link , " " ) [ 0 ] , " " ) link URL , err : = url . Parse ( link URLStr ) if err ! = nil { return tags , err } if link URL . Raw Query ! = " " { path + = " " path + = link URL . Raw Query } } return tags , nil } 
func blob Info Cache Dir ( sys * types . System Context , euid int ) ( string , error ) { if sys ! = nil & & sys . Blob Info Cache Dir ! = " " { return sys . Blob Info Cache Dir , nil } } return system Blob Info Cache Dir , nil } if data Dir = = " " { home : = os . Getenv ( " " ) if home = = " " { return " " , fmt . Errorf ( " " ) } data Dir = filepath . Join ( home , " " , " " ) } return filepath . Join ( data Dir , " " , " " ) , nil } 
func Default Cache ( sys * types . System Context ) types . Blob Info Cache { dir , err : = blob Info Cache Dir ( sys , get Rootless UID ( ) ) if err ! = nil { logrus . Debugf ( " " , blob Info Cache Filename ) return memory . New ( ) } path : = filepath . Join ( dir , blob Info Cache Filename ) if err : = os . Mkdir All ( dir , 0 7 0 0 ) ; err ! = nil { logrus . Debugf ( " " , blob Info Cache Filename , err ) return memory . New ( ) } logrus . Debugf ( " " , path ) return boltdb . New ( path ) } 
func ( t archive Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return Parse Reference ( reference ) } 
func Parse Reference ( ref String string ) ( types . Image Reference , error ) { if ref String = = " " { return nil , errors . Errorf ( " " , ref String ) } parts : = strings . Split N ( ref String , " " , 2 ) path : = parts [ 0 ] var destination Ref reference . Named Tagged if err ! = nil { return nil , errors . Wrapf ( err , " " ) } ref = reference . Tag Name Only ( ref ) if _ , is Digest : = ref . ( reference . Canonical ) ; is Digest { return nil , errors . Errorf ( " " , ref String ) } ref Tagged , is Tagged : = ref . ( reference . Named Tagged ) if ! is Tagged { } destination Ref = ref Tagged } return archive Reference { destination Ref : destination Ref , path : path , } , nil } 
func ( ref archive Reference ) String Within Transport ( ) string { if ref . destination Ref = = nil { return ref . path } return fmt . Sprintf ( " " , ref . path , ref . destination Ref . String ( ) ) } 
func ( ref archive Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { src , err : = new Image Source ( ctx , ref ) if err ! = nil { return nil , err } return ctr Image . From Source ( ctx , sys , src ) } 
func ( ref archive Reference ) New Image Source ( ctx context . Context , sys * types . System Context ) ( types . Image Source , error ) { return new Image Source ( ctx , ref ) } 
func ( ref archive Reference ) New Image Destination ( ctx context . Context , sys * types . System Context ) ( types . Image Destination , error ) { return new Image Destination ( sys , ref ) } 
func ( ref archive Reference ) Delete Image ( ctx context . Context , sys * types . System Context ) error { } 
func New ( ) types . Blob Info Cache { return & cache { uncompressed Digests : map [ digest . Digest ] digest . Digest { } , digests By Uncompressed : map [ digest . Digest ] map [ digest . Digest ] struct { } { } , known Locations : map [ location Key ] map [ types . BICLocation Reference ] time . Time { } , } } 
func ( mem * cache ) Uncompressed Digest ( any Digest digest . Digest ) digest . Digest { mem . mutex . Lock ( ) defer mem . mutex . Unlock ( ) return mem . uncompressed Digest Locked ( any Digest ) } 
func ( mem * cache ) uncompressed Digest Locked ( any Digest digest . Digest ) digest . Digest { if d , ok : = mem . uncompressed Digests [ any Digest ] ; ok { return d } } return " " } 
func ( mem * cache ) Record Digest Uncompressed Pair ( any Digest digest . Digest , uncompressed digest . Digest ) { mem . mutex . Lock ( ) defer mem . mutex . Unlock ( ) if previous , ok : = mem . uncompressed Digests [ any Digest ] ; ok & & previous ! = uncompressed { logrus . Warnf ( " " , any Digest , previous , uncompressed ) } mem . uncompressed Digests [ any Digest ] = uncompressed any Digest Set , ok : = mem . digests By Uncompressed [ uncompressed ] if ! ok { any Digest Set = map [ digest . Digest ] struct { } { } mem . digests By Uncompressed [ uncompressed ] = any Digest Set } any Digest Set [ any Digest ] = struct { } { } } 
func ( mem * cache ) Record Known Location ( transport types . Image Transport , scope types . BICTransport Scope , blob Digest digest . Digest , location types . BICLocation Reference ) { mem . mutex . Lock ( ) defer mem . mutex . Unlock ( ) key : = location Key { transport : transport . Name ( ) , scope : scope , blob Digest : blob Digest } location Scope , ok : = mem . known Locations [ key ] if ! ok { location Scope = map [ types . BICLocation Reference ] time . Time { } mem . known Locations [ key ] = location Scope } location Scope [ location ] = time . Now ( ) } 
func ( mem * cache ) append Replacement Candidates ( candidates [ ] prioritize . Candidate With Time , transport types . Image Transport , scope types . BICTransport Scope , digest digest . Digest ) [ ] prioritize . Candidate With Time { locations : = mem . known Locations [ location Key { transport : transport . Name ( ) , scope : scope , blob Digest : digest } ] for l , t : = range locations { candidates = append ( candidates , prioritize . Candidate With Time { Candidate : types . BICReplacement Candidate { Digest : digest , Location : l , } , Last Seen : t , } ) } return candidates } 
func ( mem * cache ) Candidate Locations ( transport types . Image Transport , scope types . BICTransport Scope , primary Digest digest . Digest , can Substitute bool ) [ ] types . BICReplacement Candidate { mem . mutex . Lock ( ) defer mem . mutex . Unlock ( ) res : = [ ] prioritize . Candidate With Time { } res = mem . append Replacement Candidates ( res , transport , scope , primary Digest ) var uncompressed Digest digest . Digest if can Substitute { if uncompressed Digest = mem . uncompressed Digest Locked ( primary Digest ) ; uncompressed Digest ! = " " { other Digests : = mem . digests By Uncompressed [ uncompressed Digest ] for d : = range other Digests { if d ! = primary Digest & & d ! = uncompressed Digest { res = mem . append Replacement Candidates ( res , transport , scope , d ) } } if uncompressed Digest ! = primary Digest { res = mem . append Replacement Candidates ( res , transport , scope , uncompressed Digest ) } } } return prioritize . Destructively Prioritize Replacement Candidates ( res , primary Digest , uncompressed Digest ) } 
func Unparsed Instance ( src types . Image Source , instance Digest * digest . Digest ) * Unparsed Image { return & Unparsed Image { src : src , instance Digest : instance Digest , } } 
func ( i * Unparsed Image ) Manifest ( ctx context . Context ) ( [ ] byte , string , error ) { if i . cached Manifest = = nil { m , mt , err : = i . src . Get Manifest ( ctx , i . instance Digest ) if err ! = nil { return nil , " " , err } if err ! = nil { return nil , " " , errors . Wrap ( err , " " ) } if ! matches { return nil , " " , errors . Errorf ( " " , digest ) } } i . cached Manifest = m i . cached Manifest MIMEType = mt } return i . cached Manifest , i . cached Manifest MIMEType , nil } 
func ( i * Unparsed Image ) expected Manifest Digest ( ) ( digest . Digest , bool ) { if i . instance Digest ! = nil { return * i . instance Digest , true } ref : = i . Reference ( ) . Docker Reference ( ) if ref ! = nil { if canonical , ok : = ref . ( reference . Canonical ) ; ok { return canonical . Digest ( ) , true } } return " " , false } 
func ( i * Unparsed Image ) Signatures ( ctx context . Context ) ( [ ] [ ] byte , error ) { if i . cached Signatures = = nil { sigs , err : = i . src . Get Signatures ( ctx , i . instance Digest ) if err ! = nil { return nil , err } i . cached Signatures = sigs } return i . cached Signatures , nil } 
func new GPGSigning Mechanism In Directory ( optional Dir string ) ( Signing Mechanism , error ) { ctx , err : = new GPGMEContext ( optional Dir ) if err ! = nil { return nil , err } return & gpgme Signing Mechanism { ctx : ctx , ephemeral Dir : " " , } , nil } 
func new Ephemeral GPGSigning Mechanism ( blob [ ] byte ) ( Signing Mechanism , [ ] string , error ) { dir , err : = ioutil . Temp Dir ( " " , " " ) if err ! = nil { return nil , nil , err } remove Dir : = true defer func ( ) { if remove Dir { os . Remove All ( dir ) } } ( ) ctx , err : = new GPGMEContext ( dir ) if err ! = nil { return nil , nil , err } mech : = & gpgme Signing Mechanism { ctx : ctx , ephemeral Dir : dir , } key Identities , err : = mech . import Keys From Bytes ( blob ) if err ! = nil { return nil , nil , err } remove Dir = false return mech , key Identities , nil } 
func new GPGMEContext ( optional Dir string ) ( * gpgme . Context , error ) { ctx , err : = gpgme . New ( ) if err ! = nil { return nil , err } if err = ctx . Set Protocol ( gpgme . Protocol Open PGP ) ; err ! = nil { return nil , err } if optional Dir ! = " " { err : = ctx . Set Engine Info ( gpgme . Protocol Open PGP , " " , optional Dir ) if err ! = nil { return nil , err } } ctx . Set Armor ( false ) ctx . Set Text Mode ( false ) return ctx , nil } 
func ( m * gpgme Signing Mechanism ) import Keys From Bytes ( blob [ ] byte ) ( [ ] string , error ) { input Data , err : = gpgme . New Data Bytes ( blob ) if err ! = nil { return nil , err } res , err : = m . ctx . Import ( input Data ) if err ! = nil { return nil , err } key Identities : = [ ] string { } for _ , i : = range res . Imports { if i . Result = = nil { key Identities = append ( key Identities , i . Fingerprint ) } } return key Identities , nil } 
func ( m * gpgme Signing Mechanism ) Sign ( input [ ] byte , key Identity string ) ( [ ] byte , error ) { key , err : = m . ctx . Get Key ( key Identity , true ) if err ! = nil { return nil , err } input Data , err : = gpgme . New Data Bytes ( input ) if err ! = nil { return nil , err } var sig Buffer bytes . Buffer sig Data , err : = gpgme . New Data Writer ( & sig Buffer ) if err ! = nil { return nil , err } if err = m . ctx . Sign ( [ ] * gpgme . Key { key } , input Data , sig Data , gpgme . Sig Mode Normal ) ; err ! = nil { return nil , err } return sig Buffer . Bytes ( ) , nil } 
func ( m gpgme Signing Mechanism ) Verify ( unverified Signature [ ] byte ) ( contents [ ] byte , key Identity string , err error ) { signed Buffer : = bytes . Buffer { } signed Data , err : = gpgme . New Data Writer ( & signed Buffer ) if err ! = nil { return nil , " " , err } unverified Signature Data , err : = gpgme . New Data Bytes ( unverified Signature ) if err ! = nil { return nil , " " , err } _ , sigs , err : = m . ctx . Verify ( unverified Signature Data , nil , signed Data ) if err ! = nil { return nil , " " , err } if len ( sigs ) ! = 1 { return nil , " " , Invalid Signature Error { msg : fmt . Sprintf ( " " , len ( sigs ) ) } } sig : = sigs [ 0 ] } return signed Buffer . Bytes ( ) , sig . Fingerprint , nil } 
func new Image Destination ( ctx context . Context , sys * types . System Context , ref oci Archive Reference ) ( types . Image Destination , error ) { temp Dir Ref , err : = create OCIRef ( ref . image ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } unpacked Dest , err : = temp Dir Ref . oci Ref Extracted . New Image Destination ( ctx , sys ) if err ! = nil { if err : = temp Dir Ref . delete Temp Dir ( ) ; err ! = nil { return nil , errors . Wrapf ( err , " " , temp Dir Ref . temp Directory ) } return nil , err } return & oci Archive Image Destination { ref : ref , unpacked Dest : unpacked Dest , temp Dir Ref : temp Dir Ref } , nil } 
func ( d * oci Archive Image Destination ) Close ( ) error { defer d . temp Dir Ref . delete Temp Dir ( ) return d . unpacked Dest . Close ( ) } 
func ( d * oci Archive Image Destination ) Supports Signatures ( ctx context . Context ) error { return d . unpacked Dest . Supports Signatures ( ctx ) } 
func ( d * oci Archive Image Destination ) Put Blob ( ctx context . Context , stream io . Reader , input Info types . Blob Info , cache types . Blob Info Cache , is Config bool ) ( types . Blob Info , error ) { return d . unpacked Dest . Put Blob ( ctx , stream , input Info , cache , is Config ) } 
func ( d * oci Archive Image Destination ) Try Reusing Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache , can Substitute bool ) ( bool , types . Blob Info , error ) { return d . unpacked Dest . Try Reusing Blob ( ctx , info , cache , can Substitute ) } 
func ( d * oci Archive Image Destination ) Put Manifest ( ctx context . Context , m [ ] byte ) error { return d . unpacked Dest . Put Manifest ( ctx , m ) } 
func ( d * oci Archive Image Destination ) Commit ( ctx context . Context ) error { if err : = d . unpacked Dest . Commit ( ctx ) ; err ! = nil { return errors . Wrapf ( err , " " , d . ref . image ) } return tar Directory ( src , dst ) } 
func tar Directory ( src , dst string ) error { if err ! = nil { return errors . Wrapf ( err , " " , src ) } if err ! = nil { return errors . Wrapf ( err , " " , dst ) } defer out File . Close ( ) return err } 
func ( s storage Transport ) Parse Store Reference ( store storage . Store , ref string ) ( * storage Reference , error ) { if ref = = " " { return nil , errors . Wrapf ( Err Invalid Reference , " " , ref ) } if ref [ 0 ] = = ' [ ' { if close Index < 1 { return nil , errors . Wrapf ( Err Invalid Reference , " " , ref ) } ref = ref [ close Index + 1 : ] } id : = " " if split ! = - 1 { possible ID : = ref [ split + 1 : ] if possible ID = = " " { return nil , errors . Wrapf ( Err Invalid Reference , " " , ref ) } } else if img , err : = store . Image ( possible ID ) ; err = = nil & & img ! = nil & & len ( possible ID ) > = minimum Truncated IDLength & & strings . Has Prefix ( img . ID , possible ID ) { } else { return nil , errors . Wrapf ( Err Invalid Reference , " " , possible ID ) } } } ref = " " } } var named reference . Named named , err = reference . Parse Normalized Named ( ref ) if err ! = nil { return nil , errors . Wrapf ( err , " " , ref ) } named = reference . Tag Name Only ( named ) } result , err : = new Reference ( storage Transport { store : store , default UIDMap : s . default UIDMap , default GIDMap : s . default GIDMap } , named , id ) if err ! = nil { return nil , err } logrus . Debugf ( " " , result . String Within Transport ( ) ) return result , nil } 
func ( s * storage Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { var store storage . Store if close Index < 1 { return nil , Err Invalid Reference } store Spec : = reference [ 1 : close Index ] reference = reference [ close Index + 1 : ] driver Split : = strings . Split N ( store Spec , " " , 2 ) if len ( driver Split ) ! = 2 { if store Spec = = " " { return nil , Err Invalid Reference } } else { driver Info = driver Split [ 0 ] if driver Info = = " " { return nil , Err Invalid Reference } store Spec = driver Split [ 1 ] if store Spec = = " " { return nil , Err Invalid Reference } } options Split : = strings . Split N ( store Spec , " " , 2 ) if len ( options Split ) = = 2 { options = strings . Split ( options Split [ 1 ] , " " ) store Spec = options Split [ 0 ] } run Root Split : = strings . Split N ( store Spec , " " , 2 ) if len ( run Root Split ) = = 2 { run Root Info = run Root Split [ 1 ] store Spec = run Root Split [ 0 ] } } if run Root Info ! = " " & & ! filepath . Is Abs ( run Root Info ) { return nil , Err Path Not Absolute } store 2 , err : = storage . Get Store ( storage . Store Options { Graph Driver Name : driver Info , Graph Root : root Info , Run Root : run Root Info , Graph Driver Options : options , UIDMap : s . default UIDMap , GIDMap : s . default GIDMap , } ) if err ! = nil { return nil , err } store = store 2 } else { if err ! = nil { return nil , err } store = store 2 } return s . Parse Store Reference ( store , reference ) } 
func choose Digest From Manifest List ( sys * types . System Context , blob [ ] byte ) ( digest . Digest , error ) { wanted Arch : = runtime . GOARCH if sys ! = nil & & sys . Architecture Choice ! = " " { wanted Arch = sys . Architecture Choice } wanted OS : = runtime . GOOS if sys ! = nil & & sys . OSChoice ! = " " { wanted OS = sys . OSChoice } list : = manifest List { } if err : = json . Unmarshal ( blob , & list ) ; err ! = nil { return " " , err } for _ , d : = range list . Manifests { if d . Platform . Architecture = = wanted Arch & & d . Platform . OS = = wanted OS { return d . Digest , nil } } return " " , fmt . Errorf ( " " , wanted Arch , wanted OS ) } 
func Choose Manifest Instance From Manifest List ( ctx context . Context , sys * types . System Context , src types . Unparsed Image ) ( digest . Digest , error ) { if err ! = nil { return " " , err } if mt ! = manifest . Docker V 2List Media Type { return " " , fmt . Errorf ( " " , mt ) } return choose Digest From Manifest List ( sys , blob ) } 
func ( s * dir Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if instance Digest ! = nil { return nil , " " , errors . Errorf ( `Getting target manifest not supported by "dir : " ` ) } m , err : = ioutil . Read File ( s . ref . manifest Path ( ) ) if err ! = nil { return nil , " " , err } return m , manifest . Guess MIMEType ( m ) , err } 
func ( s * dir Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { r , err : = os . Open ( s . ref . layer Path ( info . Digest ) ) if err ! = nil { return nil , - 1 , err } fi , err : = r . Stat ( ) if err ! = nil { return nil , - 1 , err } return r , fi . Size ( ) , nil } 
func ( s * dir Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { if instance Digest ! = nil { return nil , errors . Errorf ( `Manifests lists are not supported by "dir : " ` ) } signatures : = [ ] [ ] byte { } for i : = 0 ; ; i + + { signature , err : = ioutil . Read File ( s . ref . signature Path ( i ) ) if err ! = nil { if os . Is Not Exist ( err ) { break } return nil , err } signatures = append ( signatures , signature ) } return signatures , nil } 
func ( s * dir Image Source ) Layer Infos For Copy ( ctx context . Context ) ( [ ] types . Blob Info , error ) { return nil , nil } 
func manifest Schema 1From Components ( ref reference . Named , fs Layers [ ] manifest . Schema 1FSLayers , history [ ] manifest . Schema 1History , architecture string ) ( generic Manifest , error ) { m , err : = manifest . Schema 1From Components ( ref , fs Layers , history , architecture ) if err ! = nil { return nil , err } return & manifest Schema 1 { m : m } , nil } 
func ( m * manifest Schema 1 ) OCIConfig ( ctx context . Context ) ( * imgspecv 1 . Image , error ) { v 2s 2 , err : = m . convert To Manifest Schema 2 ( nil , nil ) if err ! = nil { return nil , err } return v 2s 2 . OCIConfig ( ctx ) } 
func ( m * manifest Schema 1 ) Embedded Docker Reference Conflicts ( ref reference . Named ) bool { var tag string if tagged , is Tagged : = ref . ( reference . Named Tagged ) ; is Tagged { tag = tagged . Tag ( ) } else { tag = " " } return m . m . Name ! = name | | m . m . Tag ! = tag } 
func ( m * manifest Schema 1 ) Inspect ( context . Context ) ( * types . Image Inspect Info , error ) { return m . m . Inspect ( nil ) } 
func ( m * manifest Schema 1 ) Updated Image Needs Layer Diff IDs ( options types . Manifest Update Options ) bool { return ( options . Manifest MIMEType = = manifest . Docker V 2Schema 2Media Type | | options . Manifest MIMEType = = imgspecv 1 . Media Type Image Manifest ) } 
func ( m * manifest Schema 1 ) Updated Image ( ctx context . Context , options types . Manifest Update Options ) ( types . Image , error ) { copy : = manifest Schema 1 { m : manifest . Schema 1Clone ( m . m ) } if options . Layer Infos ! = nil { if err : = copy . m . Update Layer Infos ( options . Layer Infos ) ; err ! = nil { return nil , err } } if options . Embedded Docker Reference ! = nil { copy . m . Name = reference . Path ( options . Embedded Docker Reference ) if tagged , is Tagged : = options . Embedded Docker Reference . ( reference . Named Tagged ) ; is Tagged { copy . m . Tag = tagged . Tag ( ) } else { copy . m . Tag = " " } } switch options . Manifest MIMEType { case " " : if err ! = nil { return nil , err } return memory Image From Manifest ( m 2 ) , nil case imgspecv 1 . Media Type Image Manifest : if err ! = nil { return nil , err } return m 2 . Updated Image ( ctx , types . Manifest Update Options { Manifest MIMEType : imgspecv 1 . Media Type Image Manifest , Information Only : options . Information Only , } ) default : return nil , errors . Errorf ( " " , manifest . Docker V 2Schema 1Signed Media Type , options . Manifest MIMEType ) } return memory Image From Manifest ( & copy ) , nil } 
func ( m * manifest Schema 1 ) convert To Manifest Schema 2 ( uploaded Layer Infos [ ] types . Blob Info , layer Diff IDs [ ] digest . Digest ) ( generic Manifest , error ) { if len ( m . m . Extracted V 1Compatibility ) = = 0 { } if len ( m . m . Extracted V 1Compatibility ) ! = len ( m . m . FSLayers ) { return nil , errors . Errorf ( " " , len ( m . m . Extracted V 1Compatibility ) , len ( m . m . FSLayers ) ) } if uploaded Layer Infos ! = nil & & len ( uploaded Layer Infos ) ! = len ( m . m . FSLayers ) { return nil , errors . Errorf ( " " , len ( uploaded Layer Infos ) , len ( m . m . FSLayers ) ) } if layer Diff IDs ! = nil & & len ( layer Diff IDs ) ! = len ( m . m . FSLayers ) { return nil , errors . Errorf ( " " , len ( layer Diff IDs ) , len ( m . m . FSLayers ) ) } var layers [ ] manifest . Schema 2Descriptor for v 1Index : = len ( m . m . Extracted V 1Compatibility ) - 1 ; v 1Index > = 0 ; v 1Index - - { v 2Index : = ( len ( m . m . Extracted V 1Compatibility ) - 1 ) - v 1Index if ! m . m . Extracted V 1Compatibility [ v 1Index ] . Throw Away { var size int 6 4 if uploaded Layer Infos ! = nil { size = uploaded Layer Infos [ v 2Index ] . Size } var d digest . Digest if layer Diff IDs ! = nil { d = layer Diff IDs [ v 2Index ] } layers = append ( layers , manifest . Schema 2Descriptor { Media Type : " " , Size : size , Digest : m . m . FSLayers [ v 1Index ] . Blob Sum , } ) diff IDs = append ( diff IDs , d ) } } config JSON , err : = m . m . To Schema 2Config ( diff IDs ) if err ! = nil { return nil , err } config Descriptor : = manifest . Schema 2Descriptor { Media Type : " " , Size : int 6 4 ( len ( config JSON ) ) , Digest : digest . From Bytes ( config JSON ) , } return manifest Schema 2From Components ( config Descriptor , nil , config JSON , layers ) , nil } 
func new Image Source ( ctx context . Context , sys * types . System Context , ref docker Reference ) ( * docker Image Source , error ) { registry , err : = sysregistriesv 2 . Find Registry ( sys , ref . ref . Name ( ) ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } if registry = = nil { } manifest Load Err error ) for _ , endpoint : = range append ( registry . Mirrors , registry . Endpoint ) { logrus . Debugf ( " " , ref . ref , endpoint . Location ) new Ref , err : = endpoint . Rewrite Reference ( ref . ref , registry . Prefix ) if err ! = nil { return nil , err } docker Ref , err : = new Reference ( new Ref ) if err ! = nil { return nil , err } client , err : = new Docker Client From Ref ( sys , docker Ref , false , " " ) if err ! = nil { return nil , err } client . tls Client Config . Insecure Skip Verify = endpoint . Insecure test Image Source : = & docker Image Source { ref : docker Ref , c : client , } manifest Load Err = test Image Source . ensure Manifest Is Loaded ( ctx ) if manifest Load Err = = nil { image Source = test Image Source break } } return image Source , manifest Load Err } 
func simplify Content Type ( content Type string ) string { if content Type = = " " { return content Type } mime Type , _ , err : = mime . Parse Media Type ( content Type ) if err ! = nil { return " " } return mime Type } 
func ( s * docker Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if instance Digest ! = nil { return s . fetch Manifest ( ctx , instance Digest . String ( ) ) } err : = s . ensure Manifest Is Loaded ( ctx ) if err ! = nil { return nil , " " , err } return s . cached Manifest , s . cached Manifest MIMEType , nil } 
func ( s * docker Image Source ) ensure Manifest Is Loaded ( ctx context . Context ) error { if s . cached Manifest ! = nil { return nil } reference , err : = s . ref . tag Or Digest ( ) if err ! = nil { return err } manblob , mt , err : = s . fetch Manifest ( ctx , reference ) if err ! = nil { return err } s . cached Manifest MIMEType = mt return nil } 
func ( s * docker Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { if len ( info . URLs ) ! = 0 { return s . get External Blob ( ctx , info . URLs ) } path : = fmt . Sprintf ( blobs Path , reference . Path ( s . ref . ref ) , info . Digest . String ( ) ) logrus . Debugf ( " " , path ) res , err : = s . c . make Request ( ctx , " " , path , nil , nil , v 2Auth , nil ) if err ! = nil { return nil , 0 , err } if res . Status Code ! = http . Status OK { } cache . Record Known Location ( s . ref . Transport ( ) , bic Transport Scope ( s . ref ) , info . Digest , new BICLocation Reference ( s . ref ) ) return res . Body , get Blob Size ( res ) , nil } 
func ( s * docker Image Source ) Get Signatures ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { if err : = s . c . detect Properties ( ctx ) ; err ! = nil { return nil , err } switch { case s . c . signature Base ! = nil : return s . get Signatures From Lookaside ( ctx , instance Digest ) case s . c . supports Signatures : return s . get Signatures From APIExtension ( ctx , instance Digest ) default : return [ ] [ ] byte { } , nil } } 
func ( s * docker Image Source ) manifest Digest ( ctx context . Context , instance Digest * digest . Digest ) ( digest . Digest , error ) { if instance Digest ! = nil { return * instance Digest , nil } if digested , ok : = s . ref . ref . ( reference . Digested ) ; ok { d : = digested . Digest ( ) if d . Algorithm ( ) = = digest . Canonical { return d , nil } } if err : = s . ensure Manifest Is Loaded ( ctx ) ; err ! = nil { return " " , err } return manifest . Digest ( s . cached Manifest ) } 
func ( s * docker Image Source ) get Signatures From Lookaside ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { manifest Digest , err : = s . manifest Digest ( ctx , instance Digest ) if err ! = nil { return nil , err } for i : = 0 ; ; i + + { url : = signature Storage URL ( s . c . signature Base , manifest Digest , i ) if url = = nil { return nil , errors . Errorf ( " " ) } signature , missing , err : = s . get One Signature ( ctx , url ) if err ! = nil { return nil , err } if missing { break } signatures = append ( signatures , signature ) } return signatures , nil } 
func ( s * docker Image Source ) get One Signature ( ctx context . Context , url * url . URL ) ( signature [ ] byte , missing bool , err error ) { switch url . Scheme { case " " : logrus . Debugf ( " " , url . Path ) sig , err : = ioutil . Read File ( url . Path ) if err ! = nil { if os . Is Not Exist ( err ) { return nil , true , nil } return nil , false , err } return sig , false , nil case " " , " " : logrus . Debugf ( " " , url ) req , err : = http . New Request ( " " , url . String ( ) , nil ) if err ! = nil { return nil , false , err } req = req . With Context ( ctx ) res , err : = s . c . do HTTP ( req ) if err ! = nil { return nil , false , err } defer res . Body . Close ( ) if res . Status Code = = http . Status Not Found { return nil , true , nil } else if res . Status Code ! = http . Status OK { return nil , false , errors . Errorf ( " " , url . String ( ) , res . Status Code , http . Status Text ( res . Status Code ) ) } sig , err : = ioutil . Read All ( res . Body ) if err ! = nil { return nil , false , err } return sig , false , nil default : return nil , false , errors . Errorf ( " " , url . String ( ) ) } } 
func ( s * docker Image Source ) get Signatures From APIExtension ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] [ ] byte , error ) { manifest Digest , err : = s . manifest Digest ( ctx , instance Digest ) if err ! = nil { return nil , err } parsed Body , err : = s . c . get Extensions Signatures ( ctx , s . ref , manifest Digest ) if err ! = nil { return nil , err } var sigs [ ] [ ] byte for _ , sig : = range parsed Body . Signatures { if sig . Version = = extension Signature Schema Version & & sig . Type = = extension Signature Type Atomic { sigs = append ( sigs , sig . Content ) } } return sigs , nil } 
func delete Image ( ctx context . Context , sys * types . System Context , ref docker Reference ) error { if err ! = nil { return err } headers [ " " ] = [ ] string { manifest . Docker V 2Schema 2Media Type } ref Tail , err : = ref . tag Or Digest ( ) if err ! = nil { return err } get Path : = fmt . Sprintf ( manifest Path , reference . Path ( ref . ref ) , ref Tail ) get , err : = c . make Request ( ctx , " " , get Path , headers , nil , v 2Auth , nil ) if err ! = nil { return err } defer get . Body . Close ( ) manifest Body , err : = ioutil . Read All ( get . Body ) if err ! = nil { return err } switch get . Status Code { case http . Status OK : case http . Status Not Found : return errors . Errorf ( " " , ref . ref ) default : return errors . Errorf ( " " , ref . ref , manifest Body , get . Status ) } digest : = get . Header . Get ( " " ) delete Path : = fmt . Sprintf ( manifest Path , reference . Path ( ref . ref ) , digest ) if err ! = nil { return err } defer delete . Body . Close ( ) body , err : = ioutil . Read All ( delete . Body ) if err ! = nil { return err } if delete . Status Code ! = http . Status Accepted { return errors . Errorf ( " " , delete Path , string ( body ) , delete . Status ) } if c . signature Base ! = nil { manifest Digest , err : = manifest . Digest ( manifest Body ) if err ! = nil { return err } for i : = 0 ; ; i + + { url : = signature Storage URL ( c . signature Base , manifest Digest , i ) if url = = nil { return errors . Errorf ( " " ) } missing , err : = c . delete One Signature ( url ) if err ! = nil { return err } if missing { break } } } return nil } 
func ( i * memory Image ) Manifest ( ctx context . Context ) ( [ ] byte , string , error ) { if i . serialized Manifest = = nil { m , err : = i . generic Manifest . serialize ( ) if err ! = nil { return nil , " " , err } i . serialized Manifest = m } return i . serialized Manifest , i . generic Manifest . manifest MIMEType ( ) , nil } 
func ( i * memory Image ) Signatures ( ctx context . Context ) ( [ ] [ ] byte , error ) { } 
func ( i * memory Image ) Layer Infos For Copy ( ctx context . Context ) ( [ ] types . Blob Info , error ) { return nil , nil } 
func Schema 1From Manifest ( manifest [ ] byte ) ( * Schema 1 , error ) { s 1 : = Schema 1 { } if err : = json . Unmarshal ( manifest , & s 1 ) ; err ! = nil { return nil , err } if s 1 . Schema Version ! = 1 { return nil , errors . Errorf ( " " , s 1 . Schema Version ) } if err : = s 1 . initialize ( ) ; err ! = nil { return nil , err } if err : = s 1 . fix Manifest Layers ( ) ; err ! = nil { return nil , err } return & s 1 , nil } 
func Schema 1From Components ( ref reference . Named , fs Layers [ ] Schema 1FSLayers , history [ ] Schema 1History , architecture string ) ( * Schema 1 , error ) { var name , tag string if ref ! = nil { if tagged , ok : = ref . ( reference . Named Tagged ) ; ok { tag = tagged . Tag ( ) } } s 1 : = Schema 1 { Name : name , Tag : tag , Architecture : architecture , FSLayers : fs Layers , History : history , Schema Version : 1 , } if err : = s 1 . initialize ( ) ; err ! = nil { return nil , err } return & s 1 , nil } 
func ( m * Schema 1 ) initialize ( ) error { if len ( m . FSLayers ) ! = len ( m . History ) { return errors . New ( " " ) } if len ( m . FSLayers ) = = 0 { return errors . New ( " " ) } m . Extracted V 1Compatibility = make ( [ ] Schema 1V 1Compatibility , len ( m . History ) ) for i , h : = range m . History { if err : = json . Unmarshal ( [ ] byte ( h . V 1Compatibility ) , & m . Extracted V 1Compatibility [ i ] ) ; err ! = nil { return errors . Wrapf ( err , " " , i ) } } return nil } 
func ( m * Schema 1 ) Layer Infos ( ) [ ] Layer Info { layers : = make ( [ ] Layer Info , len ( m . FSLayers ) ) for i , layer : = range m . FSLayers { } return layers } 
func ( m * Schema 1 ) Update Layer Infos ( layer Infos [ ] types . Blob Info ) error { } m . FSLayers = make ( [ ] Schema 1FSLayers , len ( layer Infos ) ) for i , info : = range layer Infos { } return nil } 
func ( m * Schema 1 ) Serialize ( ) ( [ ] byte , error ) { if err ! = nil { return nil , err } return Add Dummy V 2S 1Signature ( unsigned ) } 
func ( m * Schema 1 ) fix Manifest Layers ( ) error { } } if m . Extracted V 1Compatibility [ len ( m . Extracted V 1Compatibility ) - 1 ] . Parent ! = " " { return errors . New ( " " ) } var last ID string for _ , img : = range m . Extracted V 1Compatibility { } last ID = img . ID idmap [ last ID ] = struct { } { } } m . History = append ( m . History [ : i ] , m . History [ i + 1 : ] . . . ) m . Extracted V 1Compatibility = append ( m . Extracted V 1Compatibility [ : i ] , m . Extracted V 1Compatibility [ i + 1 : ] . . . ) } else if m . Extracted V 1Compatibility [ i ] . Parent ! = m . Extracted V 1Compatibility [ i + 1 ] . ID { return errors . Errorf ( " " , m . Extracted V 1Compatibility [ i + 1 ] . ID , m . Extracted V 1Compatibility [ i ] . Parent ) } } return nil } 
func ( m * Schema 1 ) Inspect ( _ func ( types . Blob Info ) ( [ ] byte , error ) ) ( * types . Image Inspect Info , error ) { s 1 : = & Schema 2V 1Image { } if err : = json . Unmarshal ( [ ] byte ( m . History [ 0 ] . V 1Compatibility ) , s 1 ) ; err ! = nil { return nil , err } i : = & types . Image Inspect Info { Tag : m . Tag , Created : & s 1 . Created , Docker Version : s 1 . Docker Version , Architecture : s 1 . Architecture , Os : s 1 . OS , Layers : layer Infos To Strings ( m . Layer Infos ( ) ) , } if s 1 . Config ! = nil { i . Labels = s 1 . Config . Labels } return i , nil } 
func ( m * Schema 1 ) To Schema 2Config ( diff IDs [ ] digest . Digest ) ( [ ] byte , error ) { } s 1 : = Schema 2V 1Image { } config : = [ ] byte ( m . History [ 0 ] . V 1Compatibility ) err : = json . Unmarshal ( config , & s 1 ) if err ! = nil { return nil , errors . Wrapf ( err , " " ) } if err ! = nil { return nil , errors . Wrapf ( err , " " , s 1 ) } } for _ , compat : = range m . Extracted V 1Compatibility { hitem : = Schema 2History { Created : compat . Created , Created By : strings . Join ( compat . Container Config . Cmd , " " ) , Author : compat . Author , Comment : compat . Comment , Empty Layer : compat . Throw Away , } converted History = append ( [ ] Schema 2History { hitem } , converted History . . . ) } err = json . Unmarshal ( config , & raw ) if err ! = nil { return nil , errors . Wrapf ( err , " " , s 1 ) } delete ( raw , " " ) delete ( raw , " " ) delete ( raw , " " ) delete ( raw , " " ) delete ( raw , " " ) if err ! = nil { return nil , errors . Errorf ( " " , root FS , err ) } raw Rootfs : = json . Raw Message ( rootfs ) raw [ " " ] = & raw Rootfs history , err : = json . Marshal ( converted History ) if err ! = nil { return nil , errors . Errorf ( " " , converted History , err ) } raw History : = json . Raw Message ( history ) raw [ " " ] = & raw History if err ! = nil { return nil , errors . Errorf ( " " , s 1 , err ) } return config , nil } 
func ( m * Schema 1 ) Image ID ( diff IDs [ ] digest . Digest ) ( string , error ) { image , err : = m . To Schema 2Config ( diff IDs ) if err ! = nil { return " " , err } return digest . From Bytes ( image ) . Hex ( ) , nil } 
func Guess MIMEType ( manifest [ ] byte ) string { Schema Version int `json : "schema Version " ` Signatures interface { } `json : "signatures " ` } { } if err : = json . Unmarshal ( manifest , & meta ) ; err ! = nil { return " " } switch meta . Media Type { case Docker V 2Schema 2Media Type , Docker V 2List Media Type : } } return Docker V 2Schema 1Media Type case 2 : } `json : "config " ` Layers [ ] imgspecv 1 . Descriptor `json : "layers " ` } { } if err : = json . Unmarshal ( manifest , & oci Man ) ; err ! = nil { return " " } if oci Man . Config . Media Type = = imgspecv 1 . Media Type Image Config & & len ( oci Man . Layers ) ! = 0 { return imgspecv 1 . Media Type Image Manifest } oci Index : = struct { Manifests [ ] imgspecv 1 . Descriptor `json : "manifests " ` } { } if err : = json . Unmarshal ( manifest , & oci Index ) ; err ! = nil { return " " } if len ( oci Index . Manifests ) ! = 0 & & oci Index . Manifests [ 0 ] . Media Type = = imgspecv 1 . Media Type Image Manifest { return imgspecv 1 . Media Type Image Index } return Docker V 2Schema 2Media Type } return " " } 
func Digest ( manifest [ ] byte ) ( digest . Digest , error ) { if Guess MIMEType ( manifest ) = = Docker V 2Schema 1Signed Media Type { sig , err : = libtrust . Parse Pretty Signature ( manifest , " " ) if err ! = nil { return " " , err } manifest , err = sig . Payload ( ) if err ! = nil { } } return digest . From Bytes ( manifest ) , nil } 
func Matches Digest ( manifest [ ] byte , expected Digest digest . Digest ) ( bool , error ) { if err ! = nil { return false , err } return expected Digest = = actual Digest , nil } 
func Add Dummy V 2S 1Signature ( manifest [ ] byte ) ( [ ] byte , error ) { key , err : = libtrust . Generate ECP 2 5 6Private Key ( ) if err ! = nil { return nil , err } js , err : = libtrust . New JSONSignature ( manifest ) if err ! = nil { return nil , err } if err : = js . Sign ( key ) ; err ! = nil { } return js . Pretty Signature ( " " ) } 
func Normalized MIMEType ( input string ) string { switch input { case Docker V 2Schema 1Media Type , Docker V 2Schema 1Signed Media Type , imgspecv 1 . Media Type Image Manifest , Docker V 2Schema 2Media Type , Docker V 2List Media Type : return input default : } } 
func From Blob ( manblob [ ] byte , mt string ) ( Manifest , error ) { switch Normalized MIMEType ( mt ) { case Docker V 2Schema 1Media Type , Docker V 2Schema 1Signed Media Type : return Schema 1From Manifest ( manblob ) case imgspecv 1 . Media Type Image Manifest : return OCI 1From Manifest ( manblob ) case Docker V 2Schema 2Media Type : return Schema 2From Manifest ( manblob ) case Docker V 2List Media Type : return nil , fmt . Errorf ( " " ) default : } } 
func layer Infos To Strings ( infos [ ] Layer Info ) [ ] string { layers : = make ( [ ] string , len ( infos ) ) for i , info : = range infos { layers [ i ] = info . Digest . String ( ) } return layers } 
func ( t dir Transport ) Parse Reference ( reference string ) ( types . Image Reference , error ) { return New Reference ( reference ) } 
func ( t dir Transport ) Validate Policy Configuration Scope ( scope string ) error { if ! strings . Has Prefix ( scope , " " ) { return errors . Errorf ( " " , scope ) } } cleaned : = filepath . Clean ( scope ) if cleaned ! = scope { return errors . Errorf ( `Invalid scope %s : Uses non -canonical format , perhaps try %s ` , scope , cleaned ) } return nil } 
func New Reference ( path string ) ( types . Image Reference , error ) { resolved , err : = explicitfilepath . Resolve Path To Fully Explicit ( path ) if err ! = nil { return nil , err } return dir Reference { path : path , resolved Path : resolved } , nil } 
func ( ref dir Reference ) Policy Configuration Namespaces ( ) [ ] string { res : = [ ] string { } path : = ref . resolved Path for { last Slash : = strings . Last Index ( path , " " ) if last Slash = = - 1 | | last Slash = = 0 { break } path = path [ : last Slash ] res = append ( res , path ) } } 
func ( ref dir Reference ) New Image ( ctx context . Context , sys * types . System Context ) ( types . Image Closer , error ) { src : = new Image Source ( ref ) return image . From Source ( ctx , sys , src ) } 
func ( ref dir Reference ) New Image Source ( ctx context . Context , sys * types . System Context ) ( types . Image Source , error ) { return new Image Source ( ref ) , nil } 
func ( ref dir Reference ) New Image Destination ( ctx context . Context , sys * types . System Context ) ( types . Image Destination , error ) { compress : = false if sys ! = nil { compress = sys . Dir Force Compress } return new Image Destination ( ref , compress ) } 
func ( ref dir Reference ) layer Path ( digest digest . Digest ) string { } 
func ( ref dir Reference ) signature Path ( index int ) string { return filepath . Join ( ref . path , fmt . Sprintf ( " " , index + 1 ) ) } 
func new Image Source ( tmp Dir string , ref ostree Reference ) ( types . Image Source , error ) { return & ostree Image Source { ref : ref , tmp Dir : tmp Dir , compressed : nil } , nil } 
func ( s * ostree Image Source ) Close ( ) error { if s . repo ! = nil { C . g _object _unref ( C . gpointer ( s . repo ) ) } return nil } 
func ( s * ostree Image Source ) Get Manifest ( ctx context . Context , instance Digest * digest . Digest ) ( [ ] byte , string , error ) { if instance Digest ! = nil { return nil , " " , errors . Errorf ( `Manifest lists are not supported by "ostree : " ` ) } if s . repo = = nil { repo , err : = open Repo ( s . ref . repo ) if err ! = nil { return nil , " " , err } s . repo = repo } b : = fmt . Sprintf ( " " , s . ref . branch Name ) found , out , err : = read Metadata ( s . repo , b , " " ) if err ! = nil { return nil , " " , err } if ! found { return nil , " " , errors . New ( " " ) } m : = [ ] byte ( out ) return m , manifest . Guess MIMEType ( m ) , nil } 
func ( s * ostree Image Source ) Get Blob ( ctx context . Context , info types . Blob Info , cache types . Blob Info Cache ) ( io . Read Closer , int 6 4 , error ) { blob : = info . Digest . Hex ( ) if err ! = nil { return nil , - 1 , err } } compressed Blob , found : = s . compressed [ info . Digest ] if found { blob = compressed Blob . Hex ( ) } branch : = fmt . Sprintf ( " " , blob ) if s . repo = = nil { repo , err : = open Repo ( s . ref . repo ) if err ! = nil { return nil , 0 , err } s . repo = repo } layer Size , err : = s . get Layer Size ( blob ) if err ! = nil { return nil , 0 , err } tarsplit , err : = s . get Tar Split Data ( blob ) if err ! = nil { return nil , 0 , err } if err ! = nil { return nil , 0 , err } return file , layer Size , nil } mf : = bytes . New Reader ( tarsplit ) mfz , err : = pgzip . New Reader ( mf ) if err ! = nil { return nil , 0 , err } meta Unpacker : = storage . New JSONUnpacker ( mfz ) getter , err : = new OSTree Path File Getter ( s . repo , branch ) if err ! = nil { mfz . Close ( ) return nil , 0 , err } ots : = asm . New Output Tar Stream ( getter , meta Unpacker ) rc : = ioutils . New Read Closer Wrapper ( ots , func ( ) error { getter . Close ( ) mfz . Close ( ) return ots . Close ( ) } ) return rc , layer Size , nil } 
func ( s * ostree Image Source ) Layer Infos For Copy ( ctx context . Context ) ( [ ] types . Blob Info , error ) { updated Blob Infos : = [ ] types . Blob Info { } manifest Blob , manifest Type , err : = s . Get Manifest ( ctx , nil ) if err ! = nil { return nil , err } man , err : = manifest . From Blob ( manifest Blob , manifest Type ) s . compressed = make ( map [ digest . Digest ] digest . Digest ) layer Blobs : = man . Layer Infos ( ) for _ , layer Blob : = range layer Blobs { branch : = fmt . Sprintf ( " " , layer Blob . Digest . Hex ( ) ) found , uncompressed Digest Str , err : = read Metadata ( s . repo , branch , " " ) if err ! = nil | | ! found { return nil , err } found , uncompressed Size Str , err : = read Metadata ( s . repo , branch , " " ) if err ! = nil | | ! found { return nil , err } uncompressed Size , err : = strconv . Parse Int ( uncompressed Size Str , 1 0 , 6 4 ) if err ! = nil { return nil , err } uncompressed Digest : = digest . Digest ( uncompressed Digest Str ) blob Info : = types . Blob Info { Digest : uncompressed Digest , Size : uncompressed Size , Media Type : layer Blob . Media Type , } s . compressed [ uncompressed Digest ] = layer Blob . Digest updated Blob Infos = append ( updated Blob Infos , blob Info ) } return updated Blob Infos , nil } 
func New ( n int , ctor func ( ) Worker ) * Pool { p : = & Pool { ctor : ctor , req Chan : make ( chan work Request ) , } p . Set Size ( n ) return p } 
func New Func ( n int , f func ( interface { } ) interface { } ) * Pool { return New ( n , func ( ) Worker { return & closure Worker { processor : f , } } ) } 
func ( p * Pool ) Process ( payload interface { } ) interface { } { atomic . Add Int 6 4 ( & p . queued Jobs , 1 ) request , open : = < - p . req Chan if ! open { panic ( Err Pool Not Running ) } request . job Chan < - payload payload , open = < - request . ret Chan if ! open { panic ( Err Worker Closed ) } atomic . Add Int 6 4 ( & p . queued Jobs , - 1 ) return payload } 
func ( p * Pool ) Process Timed ( payload interface { } , timeout time . Duration , ) ( interface { } , error ) { atomic . Add Int 6 4 ( & p . queued Jobs , 1 ) defer atomic . Add Int 6 4 ( & p . queued Jobs , - 1 ) tout : = time . New Timer ( timeout ) var request work Request var open bool select { case request , open = < - p . req Chan : if ! open { return nil , Err Pool Not Running } case < - tout . C : return nil , Err Job Timed Out } select { case request . job Chan < - payload : case < - tout . C : request . interrupt Func ( ) return nil , Err Job Timed Out } select { case payload , open = < - request . ret Chan : if ! open { return nil , Err Worker Closed } case < - tout . C : request . interrupt Func ( ) return nil , Err Job Timed Out } tout . Stop ( ) return payload , nil } 
func ( p * Pool ) Set Size ( n int ) { p . worker Mut . Lock ( ) defer p . worker Mut . Unlock ( ) l Workers : = len ( p . workers ) if l Workers = = n { return } } } } } 
func ( p * Pool ) Get Size ( ) int { p . worker Mut . Lock ( ) defer p . worker Mut . Unlock ( ) return len ( p . workers ) } 
func Get Perspective Transform ( rect , dst [ ] Cv Point 2D 3 2f ) * Mat { mat : = Create Mat ( 3 , 3 , CV _ 6 4F ) result : = C . cv Get Perspective Transform ( ( * C . Cv Point 2D 3 2f ) ( & rect [ 0 ] ) , ( * C . Cv Point 2D 3 2f ) ( & dst [ 0 ] ) , ( * C . struct _Cv Mat ) ( mat ) ) return ( * Mat ) ( result ) } 
func Warp Perspective ( src , dst * Ipl Image , map Matrix * Mat , flags int , fill Val Scalar ) { C . cv Warp Perspective ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ( * C . struct _Cv Mat ) ( map Matrix ) , C . int ( flags ) , ( C . Cv Scalar ) ( fill Val ) ) } 
func ( image * Ipl Image ) Find Contours ( mode , method int , offset Point ) * Seq { storage : = C . cv Create Mem Storage ( 0 ) header _size : = ( C . size _t ) ( unsafe . Sizeof ( C . Cv Contour { } ) ) var seq * C . Cv Seq C . cv Find Contours ( unsafe . Pointer ( image ) , storage , & seq , C . int ( header _size ) , C . int ( mode ) , C . int ( method ) , C . cv Point ( C . int ( offset . X ) , C . int ( offset . Y ) ) ) return ( * Seq ) ( seq ) } 
func Draw Contours ( image * Ipl Image , contours * Seq , external Color , hole Color Scalar , max Level , thickness , line Type int , offset Point ) { C . cv Draw Contours ( unsafe . Pointer ( image ) , ( * C . Cv Seq ) ( contours ) , ( C . Cv Scalar ) ( external Color ) , ( C . Cv Scalar ) ( hole Color ) , C . int ( max Level ) , C . int ( thickness ) , C . int ( line Type ) , C . cv Point ( C . int ( offset . X ) , C . int ( offset . Y ) ) ) } 
func Approx Poly ( src * Seq , header _size int , storage * Mem Storage , method int , eps float 6 4 , recursive int ) * Seq { seq : = C . cv Approx Poly ( unsafe . Pointer ( src ) , C . int ( header _size ) , ( * C . Cv Mem Storage ) ( storage ) , C . int ( method ) , C . double ( eps ) , C . int ( recursive ) ) return ( * Seq ) ( seq ) } 
func Arc Length ( curve * Seq , slice Slice , is _closed bool ) float 6 4 { is _closed _int : = 0 if is _closed { is _closed _int = 1 } return float 6 4 ( C . cv Arc Length ( unsafe . Pointer ( curve ) , ( C . Cv Slice ) ( slice ) , C . int ( is _closed _int ) ) ) } 
func Contour Area ( contour * Seq , slice Slice , oriented int ) float 6 4 { return float 6 4 ( C . cv Contour Area ( unsafe . Pointer ( contour ) , ( C . Cv Slice ) ( slice ) , C . int ( oriented ) ) ) } 
func Fit Ellipse 2 ( points unsafe . Pointer ) Box 2D { box : = C . cv Fit Ellipse 2 ( points ) center : = Point 2D 3 2f { float 3 2 ( box . center . x ) , float 3 2 ( box . center . y ) } size : = Size 2D 3 2f { float 3 2 ( box . size . width ) , float 3 2 ( box . size . height ) } angle : = float 3 2 ( box . angle ) return Box 2D { center , size , angle } } 
func Min Area Rect ( points unsafe . Pointer ) Box 2D { box : = C . cv Min Area Rect 2 ( points , nil ) center : = Point 2D 3 2f { float 3 2 ( box . center . x ) , float 3 2 ( box . center . y ) } size : = Size 2D 3 2f { float 3 2 ( box . size . width ) , float 3 2 ( box . size . height ) } angle : = float 3 2 ( box . angle ) return Box 2D { center , size , angle } } 
func Bounding Rect ( points unsafe . Pointer ) Rect { return ( Rect ) ( C . cv Bounding Rect ( points , C . int ( 0 ) ) ) } 
func KMeans ( data * Mat , k int , termcrit Term Criteria , attempts int , rng RNG , flags int ) ( labels , centers * Mat ) { var compactness C . double labels = Create Mat ( data . Rows ( ) , 1 , CV _ 3 2S ) centers = Create Mat ( k , 1 , data . Type ( ) ) C . cv KMeans 2 ( unsafe . Pointer ( data ) , C . int ( k ) , unsafe . Pointer ( labels ) , ( C . Cv Term Criteria ) ( termcrit ) , C . int ( attempts ) , ( * C . Cv RNG ) ( & rng ) , C . int ( flags ) , unsafe . Pointer ( centers ) , & compactness ) return labels , centers } 
func Decode Image Mem ( data [ ] byte ) * Ipl Image { buf : = Create Mat Header ( 1 , len ( data ) , CV _ 8U ) buf . Set Data ( unsafe . Pointer ( & data [ 0 ] ) , CV _AUTOSTEP ) defer buf . Release ( ) return Decode Image ( unsafe . Pointer ( buf ) , CV _LOAD _IMAGE _UNCHANGED ) } 
func From Image ( img image . Image ) * Ipl Image { b : = img . Bounds ( ) model : = color . RGBAModel dst : = Create Image ( b . Max . X - b . Min . X , b . Max . Y - b . Min . Y , IPL _DEPTH _ 8U , 4 ) for y : = b . Min . Y ; y < b . Max . Y ; y + + { for x : = b . Min . X ; x < b . Max . X ; x + + { px : = img . At ( x , y ) c : = model . Convert ( px ) . ( color . RGBA ) value : = New Scalar ( float 6 4 ( c . B ) , float 6 4 ( c . G ) , float 6 4 ( c . R ) , float 6 4 ( c . A ) ) dst . Set 2D ( x - b . Min . X , y - b . Min . Y , value ) } } return dst } 
func From Image Unsafe ( img * image . RGBA ) * Ipl Image { b : = img . Bounds ( ) buf : = Create Image Header ( b . Max . X - b . Min . X , b . Max . Y - b . Min . Y , IPL _DEPTH _ 8U , 4 ) dst : = Create Image ( b . Max . X - b . Min . X , b . Max . Y - b . Min . Y , IPL _DEPTH _ 8U , 4 ) buf . Set Data ( unsafe . Pointer ( & img . Pix [ 0 ] ) , CV _AUTOSTEP ) Cvt Color ( buf , dst , CV _RGBA 2BGRA ) buf . Release ( ) return dst } 
func ( img * Ipl Image ) To Image ( ) image . Image { var height , width , channels , step int = img . Height ( ) , img . Width ( ) , img . Channels ( ) , img . Width Step ( ) out : = image . New NRGBA ( image . Rect ( 0 , 0 , width , height ) ) if img . Depth ( ) ! = IPL _DEPTH _ 8U { return nil } var limg _ptr unsafe . Pointer = unsafe . Pointer ( limg ) var data [ ] C . char = ( * [ 1 < < 3 0 ] C . char ) ( limg _ptr ) [ : height * step : height * step ] c : = color . NRGBA { R : uint 8 ( 0 ) , G : uint 8 ( 0 ) , B : uint 8 ( 0 ) , A : uint 8 ( 2 5 5 ) } c . G = uint 8 ( data [ y * step + x + 1 ] ) c . R = uint 8 ( data [ y * step + x + 2 ] ) if channels = = 4 { c . A = uint 8 ( data [ y * step + x + 3 ] ) } out . Set NRGBA ( int ( x / channels ) , y , c ) } } return out } 
func Gcv Mat To Mat 6 4 ( mat Gcv Mat ) * mat 6 4 . Dense { col : = mat . Get Cols ( ) row : = mat . Get Rows ( ) data : = [ ] float 6 4 { } for i : = 0 ; i < row ; i + + { for j : = 0 ; j < col ; j + + { if flt Ptr , ok : = mat . Gcv Atf 6 4 ( i , j ) . ( * float 6 4 ) ; ok { data = append ( data , * flt Ptr ) } else { panic ( " " ) } } } return mat 6 4 . New Dense ( row , col , data ) } 
func Mat 6 4To Gcv Mat ( mat * mat 6 4 . Dense ) Gcv Mat { row , col : = mat . Dims ( ) raw Data : = New Gcv Float 6 4Vector ( int 6 4 ( row * col ) ) for i : = 0 ; i < row ; i + + { for j : = 0 ; j < col ; j + + { raw Data . Set ( i * col + j , mat . At ( i , j ) ) } } return Mat 6 4To Gcv Mat _ ( row , col , raw Data ) } 
func ( r * Rect ) TL ( ) Point { return Point { int ( r . x ) , int ( r . y ) } } 
func ( r * Rect ) BR ( ) Point { return Point { int ( r . x ) + int ( r . width ) , int ( r . y ) + int ( r . height ) } } 
func New Cv Point ( x , y int ) Cv Point { return Cv Point { C . int ( x ) , C . int ( y ) } } 
func ( p Cv Point ) To Point ( ) Point { return Point { int ( p . x ) , int ( p . y ) } } 
func New Cv Point 2D 3 2f ( x , y float 3 2 ) Cv Point 2D 3 2f { return Cv Point 2D 3 2f { C . float ( x ) , C . float ( y ) } } 
func ( p Cv Point 2D 3 2f ) To Point ( ) Point 2D 3 2f { return Point 2D 3 2f { float 3 2 ( p . x ) , float 3 2 ( p . y ) } } 
func ( box * Box 2D ) CVBox ( ) C . Cv Box 2D { var cv Box C . Cv Box 2D cv Box . angle = C . float ( box . angle ) cv Box . center . x = C . float ( box . center . X ) cv Box . center . y = C . float ( box . center . Y ) cv Box . size . width = C . float ( box . size . Width ) cv Box . size . height = C . float ( box . size . Height ) return cv Box } 
func ( box * Box 2D ) Points ( ) [ ] Point 2D 3 2f { var pts [ 4 ] C . Cv Point 2D 3 2f C . cv Box Points ( box . CVBox ( ) , ( * C . Cv Point 2D 3 2f ) ( unsafe . Pointer ( & pts [ 0 ] ) ) , ) out Pts : = make ( [ ] Point 2D 3 2f , 4 ) for i , p : = range pts { out Pts [ i ] . X = float 3 2 ( p . x ) out Pts [ i ] . Y = float 3 2 ( p . y ) } return out Pts } 
func Whole Seq ( ) Slice { slice : = C . cv Slice ( C . int ( 0 ) , C . CV _WHOLE _SEQ _END _INDEX ) return ( Slice ) ( slice ) } 
func ( s Scalar ) Val ( ) [ 4 ] float 6 4 { return [ 4 ] float 6 4 { float 6 4 ( s . val [ 0 ] ) , float 6 4 ( s . val [ 1 ] ) , float 6 4 ( s . val [ 2 ] ) , float 6 4 ( s . val [ 3 ] ) , } } 
func init System ( args [ ] string ) int { argc : = C . int ( len ( args ) ) argv : = make ( [ ] * C . char , len ( args ) ) for i : = 0 ; i < len ( args ) ; i + + { argv [ i ] = C . CString ( args [ i ] ) } rv : = C . cv Init System ( argc , ( * * C . char ) ( unsafe . Pointer ( & argv ) ) ) return int ( rv ) } 
func Wait Key ( delay int ) int { key : = C . cv Wait Key ( C . int ( delay ) ) return int ( key ) } 
func New Window ( name string , flags . . . int ) * Window { win _flags : = C . int ( CV _WINDOW _AUTOSIZE ) if len ( flags ) > 0 { win _flags = C . int ( flags [ 0 ] ) } win : = & Window { name : name , name _c : C . CString ( name ) , flags : win _flags , trackbar Handle : make ( map [ string ] Trackbar Func , 5 0 ) , trackbar Max : make ( map [ string ] int , 5 0 ) , trackbar Val : make ( map [ string ] int , 5 0 ) , trackbar Name : make ( map [ string ] ( * C . char ) , 5 0 ) , trackbar Param : make ( map [ string ] ( [ ] interface { } ) , 5 0 ) , } C . cv Named Window ( win . name _c , win . flags ) C . Go Open CV _Set Mouse Callback ( win . name _c ) all Windows [ win . name ] = win return win } 
func ( win * Window ) Set Property ( prop _id int , value float 6 4 ) { C . cv Set Window Property ( win . name _c , C . int ( prop _id ) , C . double ( value ) ) } 
func ( win * Window ) Show Image ( image * Ipl Image ) { win . image = image C . cv Show Image ( win . name _c , unsafe . Pointer ( image ) ) } 
func ( win * Window ) Resize ( width , height int ) { C . cv Resize Window ( win . name _c , C . int ( width ) , C . int ( height ) ) } 
func ( win * Window ) Get Handle ( ) unsafe . Pointer { p : = C . cv Get Window Handle ( win . name _c ) return unsafe . Pointer ( p ) } 
func ( win * Window ) Create Trackbar ( name string , value , count int , on _changed Trackbar Func , param . . . interface { } ) bool { bar _name : = C . CString ( name ) switch f : = on _changed . ( type ) { case Trackbar Func A : win . trackbar Handle [ name ] = Trackbar Func ( f ) case Trackbar Func B : win . trackbar Handle [ name ] = Trackbar Func ( f ) case func ( pos int ) : win . trackbar Handle [ name ] = Trackbar Func ( f ) case func ( pos int , param . . . interface { } ) : win . trackbar Handle [ name ] = Trackbar Func ( f ) default : panic ( " " ) } win . trackbar Val [ name ] = value win . trackbar Max [ name ] = count if len ( param ) > 0 { win . trackbar Param [ name ] = param } else { win . trackbar Param [ name ] = nil } rv : = C . Go Open CV _Create Trackbar ( bar _name , win . name _c , C . int ( value ) , C . int ( count ) ) return bool ( rv ! = 0 ) } 
func go Trackbar Callback ( bar Name _ , win Name _ * C . char , pos C . int ) { runtime . Lock OSThread ( ) defer runtime . Unlock OSThread ( ) win Name : = C . Go String ( win Name _ ) bar Name : = C . Go String ( bar Name _ ) win , ok : = all Windows [ win Name ] if ! ok { return } trackbar Handle , ok : = win . trackbar Handle [ bar Name ] if ! ok { return } if trackbar Handle = = nil { return } if fa , ok : = trackbar Handle . ( func ( pos int ) ) ; ok { fa ( int ( pos ) ) } else if fb , ok : = trackbar Handle . ( func ( pos int , param . . . interface { } ) ) ; ok { param : = win . trackbar Param [ bar Name ] if param ! = nil { fb ( int ( pos ) , param . . . ) } else { fb ( int ( pos ) ) } } } 
func ( win * Window ) Get Trackbar Pos ( name string ) ( value , max int ) { rv : = C . cv Get Trackbar Pos ( win . trackbar Name [ name ] , win . name _c ) return int ( rv ) , win . trackbar Max [ name ] } 
func ( win * Window ) Set Mouse Callback ( on _mouse Mouse Func , param . . . interface { } ) { switch f : = on _mouse . ( type ) { case Mouse Func A : win . mouse Handle = Mouse Func ( f ) case Mouse Func B : win . mouse Handle = Mouse Func ( f ) case func ( event , x , y , flags int ) : win . mouse Handle = Mouse Func ( f ) case func ( event , x , y , flags int , param . . . interface { } ) : win . mouse Handle = Mouse Func ( f ) default : panic ( " " ) } if len ( param ) > 0 { win . param = param } else { win . param = nil } } 
func go Mouse Callback ( name * C . char , event , x , y , flags C . int ) { runtime . Lock OSThread ( ) defer runtime . Unlock OSThread ( ) win Name : = C . Go String ( name ) win , ok : = all Windows [ win Name ] if ! ok { return } if win . mouse Handle = = nil { return } if fa , ok : = win . mouse Handle . ( func ( event , x , y , flags int ) ) ; ok { fa ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) ) return } if fb , ok : = win . mouse Handle . ( func ( event , x , y , flags int , param . . . interface { } ) ) ; ok { if win . param ! = nil { fb ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) , win . param . . . ) } else { fb ( int ( event ) , int ( x ) , int ( y ) , int ( flags ) ) } return } } 
func ( win * Window ) Destroy ( ) { C . cv Destroy Window ( win . name _c ) delete ( all Windows , win . name ) for _ , bar _name : = range win . trackbar Name { C . Go Open CV _Destroy Trackbar ( bar _name , win . name _c ) C . free ( unsafe . Pointer ( bar _name ) ) } C . free ( unsafe . Pointer ( win . name _c ) ) win . name _c = nil } 
func Load Image ( filename string , iscolor _ . . . int ) * Ipl Image { iscolor : = CV _LOAD _IMAGE _COLOR if len ( iscolor _ ) > 0 { iscolor = iscolor _ [ 0 ] } name _c : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( name _c ) ) rv : = C . cv Load Image ( name _c , C . int ( iscolor ) ) return ( * Ipl Image ) ( rv ) } 
func Save Image ( filename string , image * Ipl Image , params [ ] int ) int { name _c : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( name _c ) ) var first Param * C . int if len ( params ) > 0 { var params _c [ ] C . int for _ , param : = range params { params _c = append ( params _c , C . int ( param ) ) } first Param = & params _c [ 0 ] } rv : = C . cv Save Image ( name _c , unsafe . Pointer ( image ) , first Param ) return int ( rv ) } 
func Decode Image ( buf unsafe . Pointer , iscolor int ) * Ipl Image { rv : = C . cv Decode Image ( ( * C . Cv Mat ) ( buf ) , C . int ( iscolor ) ) return ( * Ipl Image ) ( rv ) } 
func Encode Image ( ext string , image unsafe . Pointer , params [ ] int ) * Mat { var first Param * C . int if len ( params ) > 0 { var params _c [ ] C . int for _ , param : = range params { params _c = append ( params _c , C . int ( param ) ) } first Param = & params _c [ 0 ] } ext _c : = C . CString ( ext ) defer C . free ( unsafe . Pointer ( ext _c ) ) rv : = C . cv Encode Image ( ext _c , ( image ) , first Param ) return ( * Mat ) ( rv ) } 
func Convert Image ( src , dst unsafe . Pointer , flags int ) { C . cv Convert Image ( src , dst , C . int ( flags ) ) } 
func New File Capture ( filename string ) * Capture { filename _c : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( filename _c ) ) cap : = C . cv Create File Capture ( filename _c ) return ( * Capture ) ( cap ) } 
func New Camera Capture ( index int ) * Capture { cap : = C . cv Create Camera Capture ( C . int ( index ) ) return ( * Capture ) ( cap ) } 
func ( capture * Capture ) Grab Frame ( ) bool { rv : = C . cv Grab Frame ( ( * C . Cv Capture ) ( capture ) ) return ( rv ! = C . int ( 0 ) ) } 
func ( capture * Capture ) Retrieve Frame ( stream Idx int ) * Ipl Image { rv : = C . cv Retrieve Frame ( ( * C . Cv Capture ) ( capture ) , C . int ( stream Idx ) ) return ( * Ipl Image ) ( rv ) } 
func ( capture * Capture ) Query Frame ( ) * Ipl Image { rv : = C . cv Query Frame ( ( * C . Cv Capture ) ( capture ) ) return ( * Ipl Image ) ( rv ) } 
func ( capture * Capture ) Release ( ) { cap _c : = ( * C . Cv Capture ) ( capture ) C . cv Release Capture ( & cap _c ) } 
func ( capture * Capture ) Get Property ( property _id int ) float 6 4 { rv : = C . cv Get Capture Property ( ( * C . Cv Capture ) ( capture ) , C . int ( property _id ) , ) return float 6 4 ( rv ) } 
func ( capture * Capture ) Get Domain ( ) int { rv : = C . cv Get Capture Domain ( ( * C . Cv Capture ) ( capture ) ) return int ( rv ) } 
func FOURCC ( c 1 , c 2 , c 3 , c 4 int 8 ) uint 3 2 { rv : = C . Go Open CV _FOURCC _ ( C . int ( c 1 ) , C . int ( c 2 ) , C . int ( c 3 ) , C . int ( c 4 ) ) return uint 3 2 ( rv ) } 
func New Video Writer ( filename string , fourcc int , fps float 3 2 , frame _width , frame _height , is _color int ) * Video Writer { size : = C . cv Size ( C . int ( frame _width ) , C . int ( frame _height ) ) filename _c : = C . CString ( filename ) defer C . free ( unsafe . Pointer ( filename _c ) ) rv : = C . cv Create Video Writer ( filename _c , C . int ( fourcc ) , C . double ( fps ) , size , C . int ( is _color ) , ) return ( * Video Writer ) ( rv ) } 
func ( writer * Video Writer ) Write Frame ( image * Ipl Image ) int { rv : = C . cv Write Frame ( ( * C . Cv Video Writer ) ( writer ) , ( * C . Ipl Image ) ( image ) ) return int ( rv ) } 
func ( writer * Video Writer ) Release ( ) { writer _c : = ( * C . Cv Video Writer ) ( writer ) C . cv Release Video Writer ( & writer _c ) } 
func Gcv Init Camera Matrix 2D ( obj Pts , img Pts * mat 6 4 . Dense , dims [ 2 ] int , aspect Ratio float 6 4 ) ( cam Mat * mat 6 4 . Dense ) { obj Dim , n Obj Pts : = obj Pts . Dims ( ) img Dim , n Img Pts : = img Pts . Dims ( ) if obj Dim ! = 3 | | img Dim ! = 2 | | n Obj Pts ! = n Img Pts { panic ( " " ) } obj Pts Vec : = New Gcv Point 3f 3 2Vector ( int 6 4 ( n Obj Pts ) ) img Pts Vec : = New Gcv Point 2f 3 2Vector ( int 6 4 ( n Obj Pts ) ) for j : = 0 ; j < n Obj Pts ; j + + { obj Pts Vec . Set ( j , New Gcv Point 3f 3 2 ( mat 6 4 . Col ( nil , j , obj Pts ) . . . ) ) } for j : = 0 ; j < n Obj Pts ; j + + { img Pts Vec . Set ( j , New Gcv Point 2f 3 2 ( mat 6 4 . Col ( nil , j , img Pts ) . . . ) ) } _img Size : = New Gcv Size 2i ( dims [ 0 ] , dims [ 1 ] ) cam Mat = Gcv Mat To Mat 6 4 ( Gcv Init Camera Matrix 2D _ ( obj Pts Vec , img Pts Vec , _img Size , aspect Ratio ) ) return cam Mat } 
func Gcv Rodrigues ( src * mat 6 4 . Dense ) ( dst * mat 6 4 . Dense ) { gcv Src : = Mat 6 4To Gcv Mat ( src ) gcv Dst : = New Gcv Mat ( ) Gcv Rodrigues _ ( gcv Src , gcv Dst ) dst = Gcv Mat To Mat 6 4 ( gcv Dst ) return dst } 
func Alloc ( size int ) unsafe . Pointer { return unsafe . Pointer ( C . cv Alloc ( C . size _t ( size ) ) ) } 
func Create Image Header ( w , h , depth , channels int ) * Ipl Image { hdr : = C . cv Create Image Header ( C . cv Size ( C . int ( w ) , C . int ( h ) ) , C . int ( depth ) , C . int ( channels ) , ) return ( * Ipl Image ) ( hdr ) } 
func ( img * Ipl Image ) Init Header ( w , h , depth , channels , origin , align int ) { C . cv Init Image Header ( ( * C . Ipl Image ) ( img ) , C . cv Size ( C . int ( w ) , C . int ( h ) ) , C . int ( depth ) , C . int ( channels ) , C . int ( origin ) , C . int ( align ) , ) } 
func Create Image ( w , h , depth , channels int ) * Ipl Image { size : = C . cv Size ( C . int ( w ) , C . int ( h ) ) img : = C . cv Create Image ( size , C . int ( depth ) , C . int ( channels ) ) return ( * Ipl Image ) ( img ) } 
func Merge ( img Blue , img Green , img Red , img Alpha , dst * Ipl Image ) { C . cv Merge ( unsafe . Pointer ( img Blue ) , unsafe . Pointer ( img Green ) , unsafe . Pointer ( img Red ) , unsafe . Pointer ( img Alpha ) , unsafe . Pointer ( dst ) , ) } 
func Split ( src , img Blue , img Green , img Red , img Alpha * Ipl Image ) { C . cv Split ( unsafe . Pointer ( src ) , unsafe . Pointer ( img Blue ) , unsafe . Pointer ( img Green ) , unsafe . Pointer ( img Red ) , unsafe . Pointer ( img Alpha ) , ) } 
func Add Weighted ( src 1 * Ipl Image , alpha float 6 4 , src 2 * Ipl Image , beta float 6 4 , gamma float 6 4 , dst * Ipl Image ) { C . cv Add Weighted ( unsafe . Pointer ( src 1 ) , C . double ( alpha ) , unsafe . Pointer ( src 2 ) , C . double ( beta ) , C . double ( gamma ) , unsafe . Pointer ( dst ) , ) } 
func ( img * Ipl Image ) Set Data ( data unsafe . Pointer , step int ) { C . cv Set Data ( unsafe . Pointer ( img ) , data , C . int ( step ) ) } 
func ( img * Ipl Image ) Release Header ( ) { img _c : = ( * C . Ipl Image ) ( img ) C . cv Release Image Header ( & img _c ) } 
func ( img * Ipl Image ) Release ( ) { img _c : = ( * C . Ipl Image ) ( img ) C . cv Release Image ( & img _c ) } 
func ( img * Ipl Image ) Clone ( ) * Ipl Image { p : = C . cv Clone Image ( ( * C . Ipl Image ) ( img ) ) return ( * Ipl Image ) ( p ) } 
func ( img * Ipl Image ) Set COI ( coi int ) { C . cv Set Image COI ( ( * C . Ipl Image ) ( img ) , C . int ( coi ) ) } 
func ( img * Ipl Image ) Get COI ( ) int { coi : = C . cv Get Image COI ( ( * C . Ipl Image ) ( img ) ) return int ( coi ) } 
func ( img * Ipl Image ) Set ROI ( rect Rect ) { C . cv Set Image ROI ( ( * C . Ipl Image ) ( img ) , C . Cv Rect ( rect ) ) } 
func ( img * Ipl Image ) Get ROI ( ) Rect { r : = C . cv Get Image ROI ( ( * C . Ipl Image ) ( img ) ) return Rect ( r ) } 
func ( img * Ipl Image ) Reshape ( channels , rows , _type int ) * Mat { total : = img . Width ( ) * img . Height ( ) header : = Create Mat ( rows , total / rows , _type ) n : = C . cv Reshape ( unsafe . Pointer ( img ) , ( * C . Cv Mat ) ( header ) , C . int ( channels ) , C . int ( rows ) ) return ( * Mat ) ( n ) } 
func ( img * Ipl Image ) Get 1D ( x int ) Scalar { ret : = C . cv Get 1D ( unsafe . Pointer ( img ) , C . int ( x ) ) return Scalar ( ret ) } 
func ( img * Ipl Image ) Get 2D ( x , y int ) Scalar { ret : = C . cv Get 2D ( unsafe . Pointer ( img ) , C . int ( y ) , C . int ( x ) ) return Scalar ( ret ) } 
func ( img * Ipl Image ) Get 3D ( x , y , z int ) Scalar { ret : = C . cv Get 3D ( unsafe . Pointer ( img ) , C . int ( z ) , C . int ( y ) , C . int ( x ) ) return Scalar ( ret ) } 
func ( img * Ipl Image ) Set ( value Scalar ) { C . cv Set ( unsafe . Pointer ( img ) , ( C . Cv Scalar ) ( value ) , nil ) } 
func ( img * Ipl Image ) Set 1D ( x int , value Scalar ) { C . cv Set 1D ( unsafe . Pointer ( img ) , C . int ( x ) , ( C . Cv Scalar ) ( value ) ) } 
func ( img * Ipl Image ) Set 2D ( x , y int , value Scalar ) { C . cv Set 2D ( unsafe . Pointer ( img ) , C . int ( y ) , C . int ( x ) , ( C . Cv Scalar ) ( value ) ) } 
func ( img * Ipl Image ) Set 3D ( x , y , z int , value Scalar ) { C . cv Set 3D ( unsafe . Pointer ( img ) , C . int ( z ) , C . int ( y ) , C . int ( x ) , ( C . Cv Scalar ) ( value ) ) } 
func ( img * Ipl Image ) Get Mat ( ) * Mat { var null C . int tmp : = Create Mat ( img . Height ( ) , img . Width ( ) , CV _ 3 2S ) m : = C . cv Get Mat ( unsafe . Pointer ( img ) , ( * C . Cv Mat ) ( tmp ) , & null , C . int ( 0 ) ) return ( * Mat ) ( m ) } 
func Create Mat Header ( rows , cols , type _ int ) * Mat { mat : = C . cv Create Mat Header ( C . int ( rows ) , C . int ( cols ) , C . int ( type _ ) , ) return ( * Mat ) ( mat ) } 
func Create Mat ( rows , cols , type _ int ) * Mat { mat : = C . cv Create Mat ( C . int ( rows ) , C . int ( cols ) , C . int ( type _ ) , ) return ( * Mat ) ( mat ) } 
func ( mat * Mat ) Init Header ( rows , cols , type _ int , data unsafe . Pointer , step int ) { C . cv Init Mat Header ( ( * C . Cv Mat ) ( mat ) , C . int ( rows ) , C . int ( cols ) , C . int ( type _ ) , data , C . int ( step ) , ) } 
func ( mat * Mat ) Set Data ( data unsafe . Pointer , step int ) { C . cv Set Data ( unsafe . Pointer ( mat ) , data , C . int ( step ) ) } 
func ( mat * Mat ) Release ( ) { mat _c : = ( * C . Cv Mat ) ( mat ) C . cv Release Mat ( & mat _c ) } 
func ( mat * Mat ) Clone ( ) * Mat { mat _new : = C . cv Clone Mat ( ( * C . Cv Mat ) ( mat ) ) return ( * Mat ) ( mat _new ) } 
func ( m * Mat ) Reshape ( channels , rows int ) * Mat { total : = m . Cols ( ) * m . Rows ( ) n : = Create Mat ( rows , total / rows , m . Type ( ) ) C . cv Reshape ( unsafe . Pointer ( m ) , ( * C . Cv Mat ) ( n ) , C . int ( channels ) , C . int ( rows ) ) return n } 
func Get Sub Rect ( arr Arr , submat * Mat , rect Rect ) * Mat { mat _new : = C . cv Get Sub Rect ( unsafe . Pointer ( arr ) , ( * C . Cv Mat ) ( submat ) , ( C . Cv Rect ) ( rect ) , ) return ( * Mat ) ( mat _new ) } 
func Get Rows ( arr Arr , submat * Mat , start _row , end _row , delta _row int ) * Mat { mat _new : = C . cv Get Rows ( unsafe . Pointer ( arr ) , ( * C . Cv Mat ) ( submat ) , C . int ( start _row ) , C . int ( end _row ) , C . int ( delta _row ) , ) return ( * Mat ) ( mat _new ) } 
func Get Cols ( arr Arr , submat * Mat , start _col , end _col int ) * Mat { mat _new : = C . cv Get Cols ( unsafe . Pointer ( arr ) , ( * C . Cv Mat ) ( submat ) , C . int ( start _col ) , C . int ( end _col ) , ) return ( * Mat ) ( mat _new ) } 
func Get Diag ( arr Arr , submat * Mat , diag int ) * Mat { mat _new : = C . cv Get Diag ( unsafe . Pointer ( arr ) , ( * C . Cv Mat ) ( submat ) , C . int ( diag ) , ) return ( * Mat ) ( mat _new ) } 
func ( m * Mat ) Get 1D ( x int ) Scalar { ret : = C . cv Get 1D ( unsafe . Pointer ( m ) , C . int ( x ) ) return Scalar ( ret ) } 
func ( m * Mat ) Get 2D ( x , y int ) Scalar { ret : = C . cv Get 2D ( unsafe . Pointer ( m ) , C . int ( x ) , C . int ( y ) ) return Scalar ( ret ) } 
func ( m * Mat ) Get 3D ( x , y , z int ) Scalar { ret : = C . cv Get 3D ( unsafe . Pointer ( m ) , C . int ( x ) , C . int ( y ) , C . int ( z ) ) return Scalar ( ret ) } 
func ( m * Mat ) Set 1D ( x int , value Scalar ) { C . cv Set 1D ( unsafe . Pointer ( m ) , C . int ( x ) , ( C . Cv Scalar ) ( value ) ) } 
func ( m * Mat ) Set 2D ( x , y int , value Scalar ) { C . cv Set 2D ( unsafe . Pointer ( m ) , C . int ( x ) , C . int ( y ) , ( C . Cv Scalar ) ( value ) ) } 
func ( m * Mat ) Set 3D ( x , y , z int , value Scalar ) { C . cv Set 3D ( unsafe . Pointer ( m ) , C . int ( x ) , C . int ( y ) , C . int ( z ) , ( C . Cv Scalar ) ( value ) ) } 
func ( m * Mat ) Get Image ( channels int ) * Ipl Image { tmp : = Create Image ( m . Cols ( ) , m . Rows ( ) , m . Type ( ) , channels ) img : = C . cv Get Image ( unsafe . Pointer ( m ) , ( * C . Ipl Image ) ( tmp ) ) return ( * Ipl Image ) ( img ) } 
func Scalar To Raw Data ( scalar * Scalar , data unsafe . Pointer , type _ , extend _to _ 1 2 int ) { C . cv Scalar To Raw Data ( ( * C . Cv Scalar ) ( scalar ) , data , C . int ( type _ ) , C . int ( extend _to _ 1 2 ) , ) } 
func Create Mat NDHeader ( sizes [ ] int , type _ int ) * Mat ND { dims : = C . int ( len ( sizes ) ) sizes _c : = make ( [ ] C . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i + + { sizes _c [ i ] = C . int ( sizes [ i ] ) } mat : = C . cv Create Mat NDHeader ( dims , ( * C . int ) ( & sizes _c [ 0 ] ) , C . int ( type _ ) , ) return ( * Mat ND ) ( mat ) } 
func Create Mat ND ( sizes [ ] int , type _ int ) * Mat ND { dims : = C . int ( len ( sizes ) ) sizes _c : = make ( [ ] C . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i + + { sizes _c [ i ] = C . int ( sizes [ i ] ) } mat : = C . cv Create Mat ND ( dims , ( * C . int ) ( & sizes _c [ 0 ] ) , C . int ( type _ ) , ) return ( * Mat ND ) ( mat ) } 
func ( mat * Mat ND ) Init Mat NDHeader ( sizes [ ] int , type _ int , data unsafe . Pointer ) { dims : = C . int ( len ( sizes ) ) sizes _c : = make ( [ ] C . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i + + { sizes _c [ i ] = C . int ( sizes [ i ] ) } C . cv Init Mat NDHeader ( ( * C . Cv Mat ND ) ( mat ) , dims , ( * C . int ) ( & sizes _c [ 0 ] ) , C . int ( type _ ) , data , ) } 
func ( mat * Mat ND ) Release ( ) { mat _c : = ( * C . Cv Mat ND ) ( mat ) C . cv Release Mat ND ( & mat _c ) } 
func ( mat * Mat ND ) Clone ( ) * Mat ND { mat _c : = ( * C . Cv Mat ND ) ( mat ) mat _ret : = C . cv Clone Mat ND ( mat _c ) return ( * Mat ND ) ( mat _ret ) } 
func Create Sparse Mat ( sizes [ ] int , type _ int ) * Sparse Mat { dims : = C . int ( len ( sizes ) ) sizes _c : = make ( [ ] C . int , len ( sizes ) ) for i : = 0 ; i < len ( sizes ) ; i + + { sizes _c [ i ] = C . int ( sizes [ i ] ) } mat : = C . cv Create Sparse Mat ( dims , ( * C . int ) ( & sizes _c [ 0 ] ) , C . int ( type _ ) , ) return ( * Sparse Mat ) ( mat ) } 
func ( mat * Sparse Mat ) Release ( ) { mat _c : = ( * C . Cv Sparse Mat ) ( mat ) C . cv Release Sparse Mat ( & mat _c ) } 
func ( mat * Sparse Mat ) Clone ( ) * Sparse Mat { mat _c : = ( * C . Cv Sparse Mat ) ( mat ) mat _ret : = C . cv Clone Sparse Mat ( mat _c ) return ( * Sparse Mat ) ( mat _ret ) } 
func ( mat * Sparse Mat ) Init Sparse Mat Iterator ( iter * Sparse Mat Iterator ) * Sparse Node { mat _c : = ( * C . Cv Sparse Mat ) ( mat ) node : = C . cv Init Sparse Mat Iterator ( mat _c , ( * C . Cv Sparse Mat Iterator ) ( iter ) ) return ( * Sparse Node ) ( node ) } 
func ( iter * Sparse Mat Iterator ) Next ( ) * Sparse Node { node : = C . cv Get Next Sparse Node ( ( * C . Cv Sparse Mat Iterator ) ( iter ) ) return ( * Sparse Node ) ( node ) } 
func Get Size Width ( img * Ipl Image ) int { size : = C . cv Get Size ( unsafe . Pointer ( img ) ) w : = int ( size . width ) return w } 
func Copy ( src , dst , mask * Ipl Image ) { C . cv Copy ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) ) } 
func Not ( src , dst * Ipl Image ) { C . cv Not ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ) } 
func And ( src 1 , src 2 , dst * Ipl Image ) { And With Mask ( src 1 , src 2 , dst , nil ) } 
func And With Mask ( src 1 , src 2 , dst , mask * Ipl Image ) { C . cv And ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func And Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { And Scalar With Mask ( src , value , dst , nil ) } 
func And Scalar With Mask ( src * Ipl Image , value Scalar , dst , mask * Ipl Image ) { C . cv And S ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Or ( src 1 , src 2 , dst * Ipl Image ) { Or With Mask ( src 1 , src 2 , dst , nil ) } 
func Or With Mask ( src 1 , src 2 , dst , mask * Ipl Image ) { C . cv Or ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Or Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { Or Scalar With Mask ( src , value , dst , nil ) } 
func Or Scalar With Mask ( src * Ipl Image , value Scalar , dst , mask * Ipl Image ) { C . cv Or S ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Xor ( src 1 , src 2 , dst * Ipl Image ) { Xor With Mask ( src 1 , src 2 , dst , nil ) } 
func Xor With Mask ( src 1 , src 2 , dst , mask * Ipl Image ) { C . cv Xor ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Xor Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { Xor Scalar With Mask ( src , value , dst , nil ) } 
func Xor Scalar With Mask ( src * Ipl Image , value Scalar , dst , mask * Ipl Image ) { C . cv Xor S ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Add ( src 1 , src 2 , dst * Ipl Image ) { Add With Mask ( src 1 , src 2 , dst , nil ) } 
func Add With Mask ( src 1 , src 2 , dst , mask * Ipl Image ) { C . cv Add ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Add Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { Add Scalar With Mask ( src , value , dst , nil ) } 
func Add Scalar With Mask ( src * Ipl Image , value Scalar , dst , mask * Ipl Image ) { C . cv Add S ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Subtract ( src 1 , src 2 , dst * Ipl Image ) { Subtract With Mask ( src 1 , src 2 , dst , nil ) } 
func Subtract With Mask ( src 1 , src 2 , dst , mask * Ipl Image ) { C . cv Sub ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Sub Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { Sub Scalar With Mask ( src , value , dst , nil ) } 
func Sub Scalar With Mask ( src * Ipl Image , value Scalar , dst , mask * Ipl Image ) { C . cv Sub S ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Sub Scalar Rev ( value Scalar , src , dst * Ipl Image ) { Sub Scalar With Mask Rev ( value , src , dst , nil ) } 
func Sub Scalar With Mask Rev ( value Scalar , src , dst , mask * Ipl Image ) { C . cv Sub RS ( unsafe . Pointer ( src ) , ( C . Cv Scalar ) ( value ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( mask ) , ) } 
func Abs Diff ( src 1 , src 2 , dst * Ipl Image ) { C . cv Abs Diff ( unsafe . Pointer ( src 1 ) , unsafe . Pointer ( src 2 ) , unsafe . Pointer ( dst ) , ) } 
func Abs Diff Scalar ( src * Ipl Image , value Scalar , dst * Ipl Image ) { C . cv Abs Diff S ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ( C . Cv Scalar ) ( value ) , ) } 
func ( src * Ipl Image ) Avg ( mask * Ipl Image ) Scalar { return ( Scalar ) ( C . cv Avg ( unsafe . Pointer ( src ) , unsafe . Pointer ( mask ) ) ) } 
func ( src * Ipl Image ) Equalize Hist ( dst * Ipl Image ) { C . cv Equalize Hist ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) ) } 
func Mean Std Dev With Mask ( src , mask * Ipl Image ) ( Scalar , Scalar ) { var mean , std Dev Scalar C . cv Avg Sdv ( unsafe . Pointer ( src ) , ( * C . Cv Scalar ) ( & mean ) , ( * C . Cv Scalar ) ( & std Dev ) , unsafe . Pointer ( mask ) , ) return mean , std Dev } 
func Create Seq ( seq _flags , elem _size int ) * Seq { return ( * Seq ) ( C . cv Create Seq ( C . int ( seq _flags ) , C . size _t ( unsafe . Sizeof ( Seq { } ) ) , C . size _t ( elem _size ) , C . cv Create Mem Storage ( C . int ( 0 ) ) , ) ) } 
func ( seq * Seq ) Push ( element unsafe . Pointer ) unsafe . Pointer { return unsafe . Pointer ( C . cv Seq Push ( ( * C . struct _Cv Seq ) ( seq ) , element ) ) } 
func ( seq * Seq ) Pop ( element unsafe . Pointer ) { C . cv Seq Pop ( ( * C . struct _Cv Seq ) ( seq ) , element ) } 
func ( seq * Seq ) Push Front ( element unsafe . Pointer ) unsafe . Pointer { return unsafe . Pointer ( ( C . cv Seq Push Front ( ( * C . struct _Cv Seq ) ( seq ) , element ) ) ) } 
func ( seq * Seq ) Pop Front ( element unsafe . Pointer ) { C . cv Seq Pop Front ( ( * C . struct _Cv Seq ) ( seq ) , element ) } 
func ( seq * Seq ) Get Elem At ( index int ) unsafe . Pointer { return ( unsafe . Pointer ) ( C . cv Get Seq Elem ( ( * C . struct _Cv Seq ) ( seq ) , C . int ( index ) , ) ) } 
func ( seq * Seq ) Remove At ( index int ) { C . cv Seq Remove ( ( * C . struct _Cv Seq ) ( seq ) , C . int ( index ) ) } 
func Line ( image * Ipl Image , pt 1 , pt 2 Point , color Scalar , thickness , line _type , shift int ) { C . cv Line ( unsafe . Pointer ( image ) , C . cv Point ( C . int ( pt 1 . X ) , C . int ( pt 1 . Y ) ) , C . cv Point ( C . int ( pt 2 . X ) , C . int ( pt 2 . Y ) ) , ( C . Cv Scalar ) ( color ) , C . int ( thickness ) , C . int ( line _type ) , C . int ( shift ) , ) } 
func Init Font ( font Face int , hscale , vscale , shear float 3 2 , thickness , line Type int ) * Font { font : = new ( Font ) C . cv Init Font ( & font . font , C . int ( font Face ) , C . double ( hscale ) , C . double ( vscale ) , C . double ( shear ) , C . int ( thickness ) , C . int ( line Type ) , ) return font } 
func ( this * Font ) Put Text ( image * Ipl Image , text string , pt 1 Point , color Scalar ) { C . cv Put Text ( unsafe . Pointer ( image ) , C . CString ( text ) , C . cv Point ( C . int ( pt 1 . X ) , C . int ( pt 1 . Y ) ) , & this . font , ( C . Cv Scalar ) ( color ) , ) } 
func Smooth ( src , dst * Ipl Image , smoothtype , param 1 , param 2 int , param 3 , param 4 float 6 4 ) { C . cv Smooth ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . int ( smoothtype ) , C . int ( param 1 ) , C . int ( param 2 ) , C . double ( param 3 ) , C . double ( param 4 ) , ) } 
func Laplace ( src , dst * Ipl Image , aperture _size int ) { C . cv Laplace ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . int ( aperture _size ) ) } 
func Convert Scale ( a , b * Ipl Image , scale , shift float 6 4 ) { C . cv Convert Scale ( unsafe . Pointer ( a ) , unsafe . Pointer ( b ) , C . double ( scale ) , C . double ( shift ) ) } 
func Cvt Color ( src , dst * Ipl Image , code int ) { C . cv Cvt Color ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . int ( code ) ) } 
func Canny ( image , edges * Ipl Image , threshold 1 , threshold 2 float 6 4 , aperture _size int ) { C . cv Canny ( unsafe . Pointer ( image ) , unsafe . Pointer ( edges ) , C . double ( threshold 1 ) , C . double ( threshold 2 ) , C . int ( aperture _size ) , ) } 
func Sobel ( src , dst * Ipl Image , xorder , yorder , aperture _size int ) { C . cv Sobel ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . int ( xorder ) , C . int ( yorder ) , C . int ( aperture _size ) , ) } 
func Inpaint ( src , inpaint _mask , dst * Ipl Image , inpaint Range float 6 4 , flags int ) { C . cv Inpaint ( unsafe . Pointer ( src ) , unsafe . Pointer ( inpaint _mask ) , unsafe . Pointer ( dst ) , C . double ( inpaint Range ) , C . int ( flags ) , ) } 
func Threshold ( src , dst * Ipl Image , threshold , max _value float 6 4 , threshold _type int ) { C . cv Threshold ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . double ( threshold ) , C . double ( max _value ) , C . int ( threshold _type ) , ) } 
func Adaptive Threshold ( src , dst * Ipl Image , max _value float 6 4 , adaptive _method , threshold _type , block _size int , thresh _C float 6 4 ) { C . cv Adaptive Threshold ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , C . double ( max _value ) , C . int ( adaptive _method ) , C . int ( threshold _type ) , C . int ( block _size ) , C . double ( thresh _C ) , ) } 
func Create Structuring Element ( cols , rows , anchor _x , anchor _y , shape int ) * Ipl Conv Kernel { return ( * Ipl Conv Kernel ) ( C . cv Create Structuring Element Ex ( C . int ( cols ) , C . int ( rows ) , C . int ( anchor _x ) , C . int ( anchor _y ) , C . int ( shape ) , nil , } 
func ( k * Ipl Conv Kernel ) Release Element ( ) { C . cv Release Structuring Element ( ( * * C . Ipl Conv Kernel ) ( unsafe . Pointer ( & k ) ) , ) } 
func Dilate ( src , dst * Ipl Image , element * Ipl Conv Kernel , iterations int ) { C . cv Dilate ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ( * C . Ipl Conv Kernel ) ( unsafe . Pointer ( element ) ) , C . int ( iterations ) , ) } 
func Erode ( src , dst * Ipl Image , element * Ipl Conv Kernel , iterations int ) { C . cv Erode ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , ( * C . Ipl Conv Kernel ) ( unsafe . Pointer ( element ) ) , C . int ( iterations ) , ) } 
func Morphology Ex ( src , dst , temp * Ipl Image , element * Ipl Conv Kernel , operation int , iterations int ) { C . cv Morphology Ex ( unsafe . Pointer ( src ) , unsafe . Pointer ( dst ) , unsafe . Pointer ( temp ) , ( * C . Ipl Conv Kernel ) ( unsafe . Pointer ( element ) ) , C . int ( operation ) , C . int ( iterations ) , ) } 
func Delay ( delay time . Duration ) Option { return func ( c * Config ) { c . delay = delay } } 
func Back Off Delay ( n uint , config * Config ) time . Duration { return config . delay * ( 1 < < ( n - 1 ) ) } 
func ( e Error ) Error ( ) string { log With Number : = make ( [ ] string , len Without Nil ( e ) ) for i , l : = range e { if l ! = nil { log With Number [ i ] = fmt . Sprintf ( " " , i + 1 , l . Error ( ) ) } } return fmt . Sprintf ( " \n " , strings . Join ( log With Number , " \n " ) ) } 
func ( r * Request Builder ) Arguments ( args . . . string ) * Request Builder { r . args = append ( r . args , args . . . ) return r } 
func ( r * Request Builder ) Body String ( body string ) * Request Builder { return r . Body ( strings . New Reader ( body ) ) } 
func ( r * Request Builder ) Body Bytes ( body [ ] byte ) * Request Builder { return r . Body ( bytes . New Reader ( body ) ) } 
func ( r * Request Builder ) Body ( body io . Reader ) * Request Builder { r . body = body return r } 
func ( r * Request Builder ) Option ( key string , value interface { } ) * Request Builder { var s string switch v : = value . ( type ) { case bool : s = strconv . Format Bool ( v ) case string : s = v case [ ] byte : s = string ( v ) default : } if r . opts = = nil { r . opts = make ( map [ string ] string , 1 ) } r . opts [ key ] = s return r } 
func ( r * Request Builder ) Header ( name , value string ) * Request Builder { if r . headers = = nil { r . headers = make ( map [ string ] string , 1 ) } r . headers [ name ] = value return r } 
func ( r * Request Builder ) Send ( ctx context . Context ) ( * Response , error ) { req : = New Request ( ctx , r . shell . url , r . command , r . args . . . ) req . Opts = r . opts req . Headers = r . headers req . Body = r . body return req . Send ( & r . shell . httpcli ) } 
func ( r * Request Builder ) Exec ( ctx context . Context , res interface { } ) error { http Res , err : = r . Send ( ctx ) if err ! = nil { return err } if res = = nil { late Err : = http Res . Close ( ) if http Res . Error ! = nil { return http Res . Error } return late Err } return http Res . Decode ( res ) } 
func ( s * Pub Sub Subscription ) Next ( ) ( * Message , error ) { if s . resp . Error ! = nil { return nil , s . resp . Error } d : = json . New Decoder ( s . resp . Output ) var r struct { From [ ] byte `json : "from ,omitempty " ` Data [ ] byte `json : "data ,omitempty " ` Seqno [ ] byte `json : "seqno ,omitempty " ` Topic IDs [ ] string `json : "topic IDs ,omitempty " ` } err : = d . Decode ( & r ) if err ! = nil { return nil , err } from , err : = peer . IDFrom Bytes ( r . From ) if err ! = nil { return nil , err } return & Message { From : from , Data : r . Data , Seqno : r . Seqno , Topic IDs : r . Topic IDs , } , nil } 
func ( s * Pub Sub Subscription ) Cancel ( ) error { if s . resp . Output = = nil { return nil } return s . resp . Output . Close ( ) } 
func ( s * Shell ) File List ( path string ) ( * Unix Ls Object , error ) { var out ls Output if err : = s . Request ( " " , path ) . Exec ( context . Background ( ) , & out ) ; err ! = nil { return nil , err } for _ , object : = range out . Objects { return object , nil } return nil , fmt . Errorf ( " " ) } 
func ( s * Shell ) ID ( peer . . . string ) ( * Id Output , error ) { if len ( peer ) > 1 { return nil , fmt . Errorf ( " " ) } var out Id Output if err : = s . Request ( " " , peer . . . ) . Exec ( context . Background ( ) , & out ) ; err ! = nil { return nil , err } return & out , nil } 
func ( s * Shell ) Cat ( path string ) ( io . Read Closer , error ) { resp , err : = s . Request ( " " , path ) . Send ( context . Background ( ) ) if err ! = nil { return nil , err } if resp . Error ! = nil { return nil , resp . Error } return resp . Output , nil } 
func ( s * Shell ) List ( path string ) ( [ ] * Ls Link , error ) { var out struct { Objects [ ] Ls Object } err : = s . Request ( " " , path ) . Exec ( context . Background ( ) , & out ) if err ! = nil { return nil , err } if len ( out . Objects ) ! = 1 { return nil , errors . New ( " " ) } return out . Objects [ 0 ] . Links , nil } 
func ( s * Shell ) Pin ( path string ) error { return s . Request ( " " , path ) . Option ( " " , true ) . Exec ( context . Background ( ) , nil ) } 
func ( s * Shell ) Pins ( ) ( map [ string ] Pin Info , error ) { var raw struct { Keys map [ string ] Pin Info } return raw . Keys , s . Request ( " " ) . Exec ( context . Background ( ) , & raw ) } 
func ( s * Shell ) Version ( ) ( string , string , error ) { ver : = struct { Version string Commit string } { } if err : = s . Request ( " " ) . Exec ( context . Background ( ) , & ver ) ; err ! = nil { return " " , " " , err } return ver . Version , ver . Commit , nil } 
func ( s * Shell ) Object Stat ( key string ) ( * Object Stats , error ) { var stat Object Stats err : = s . Request ( " " , key ) . Exec ( context . Background ( ) , & stat ) if err ! = nil { return nil , err } return & stat , nil } 
func ( s * Shell ) Stats BW ( ctx context . Context ) ( * p 2pmetrics . Stats , error ) { v : = & p 2pmetrics . Stats { } err : = s . Request ( " " ) . Exec ( ctx , & v ) return v , err } 
func ( s * Shell ) Swarm Peers ( ctx context . Context ) ( * Swarm Conn Infos , error ) { v : = & Swarm Conn Infos { } err : = s . Request ( " " ) . Exec ( ctx , & v ) return v , err } 
func ( s * Shell ) Swarm Connect ( ctx context . Context , addr . . . string ) error { var conn * swarm Connection err : = s . Request ( " " ) . Arguments ( addr . . . ) . Exec ( ctx , & conn ) return err } 
func Dag Put Options ( opts . . . Dag Put Option ) ( * Dag Put Settings , error ) { options : = & Dag Put Settings { Input Enc : " " , Kind : " " , Pin : " " , Hash : " " , } for _ , opt : = range opts { err : = opt ( options ) if err ! = nil { return nil , err } } return options , nil } 
func ( dag Opts ) Pin ( pin string ) Dag Put Option { return func ( opts * Dag Put Settings ) error { opts . Pin = pin return nil } } 
func ( dag Opts ) Input Enc ( enc string ) Dag Put Option { return func ( opts * Dag Put Settings ) error { opts . Input Enc = enc return nil } } 
func ( dag Opts ) Kind ( kind string ) Dag Put Option { return func ( opts * Dag Put Settings ) error { opts . Kind = kind return nil } } 
func ( dag Opts ) Hash ( hash string ) Dag Put Option { return func ( opts * Dag Put Settings ) error { opts . Hash = hash return nil } } 
func ( s * Shell ) Add No Pin ( r io . Reader ) ( string , error ) { return s . Add ( r , Pin ( false ) ) } 
func ( s * Shell ) Add With Opts ( r io . Reader , pin bool , raw Leaves bool ) ( string , error ) { return s . Add ( r , Pin ( pin ) , Raw Leaves ( raw Leaves ) ) } 
func ( s * Shell ) Add Dir ( dir string ) ( string , error ) { stat , err : = os . Lstat ( dir ) if err ! = nil { return " " , err } sf , err : = files . New Serial File ( dir , false , stat ) if err ! = nil { return " " , err } slf : = files . New Slice Directory ( [ ] files . Dir Entry { files . File Entry ( filepath . Base ( dir ) , sf ) } ) reader : = files . New Multi File Reader ( slf , true ) resp , err : = s . Request ( " " ) . Option ( " " , true ) . Body ( reader ) . Send ( context . Background ( ) ) if err ! = nil { return " " , nil } defer resp . Close ( ) if resp . Error ! = nil { return " " , resp . Error } dec : = json . New Decoder ( resp . Output ) var final string for { var out object err = dec . Decode ( & out ) if err ! = nil { if err = = io . EOF { break } return " " , err } final = out . Hash } if final = = " " { return " " , errors . New ( " " ) } return final , nil } 
func ( s * Shell ) Publish ( node string , value string ) error { var pub Resp Publish Response req : = s . Request ( " " ) if node ! = " " { req . Arguments ( node ) } req . Arguments ( value ) return req . Exec ( context . Background ( ) , & pub Resp ) } 
func ( s * Shell ) Publish With Details ( content Hash , key string , lifetime , ttl time . Duration , resolve bool ) ( * Publish Response , error ) { var pub Resp Publish Response req : = s . Request ( " " , content Hash ) . Option ( " " , resolve ) if key ! = " " { req . Option ( " " , key ) } if lifetime ! = 0 { req . Option ( " " , lifetime ) } if ttl . Seconds ( ) > 0 { req . Option ( " " , ttl ) } err : = req . Exec ( context . Background ( ) , & pub Resp ) if err ! = nil { return nil , err } return & pub Resp , nil } 
func ( s * Shell ) Resolve ( id string ) ( string , error ) { req : = s . Request ( " " ) if id ! = " " { req . Arguments ( id ) } var out struct { Path string } err : = req . Exec ( context . Background ( ) , & out ) return out . Path , err } 
func ( pv Plan Value ) Resolve Value ( bind Vars map [ string ] * querypb . Bind Variable ) ( Value , error ) { switch { case pv . Key ! = " " : bv , err : = pv . lookup Value ( bind Vars ) if err ! = nil { return NULL , err } return Make Trusted ( bv . Type , bv . Value ) , nil case ! pv . Value . Is Null ( ) : return pv . Value , nil case pv . List Key ! = " " | | pv . Values ! = nil : } return NULL , nil } 
func Resolve Rows ( pvs [ ] Plan Value , bind Vars map [ string ] * querypb . Bind Variable ) ( [ ] [ ] Value , error ) { count , err : = row Count ( pvs , bind Vars ) if err ! = nil { return nil , err } for i : = range rows { rows [ i ] = make ( [ ] Value , len ( pvs ) ) } if err ! = nil { return nil , err } for i : = range rows { rows [ i ] [ j ] = Make Trusted ( bv . Type , bv . Value ) } case ! pv . Value . Is Null ( ) : for i : = range rows { rows [ i ] [ j ] = pv . Value } case pv . List Key ! = " " : bv , err : = pv . lookup List ( bind Vars ) if err ! = nil { } for i : = range rows { rows [ i ] [ j ] = Make Trusted ( bv . Values [ i ] . Type , bv . Values [ i ] . Value ) } case pv . Values ! = nil : for i : = range rows { rows [ i ] [ j ] , err = pv . Values [ i ] . Resolve Value ( bind Vars ) if err ! = nil { return nil , err } } } return rows , nil } 
func ( pq * Parsed Query ) Generate Query ( bind Variables map [ string ] * querypb . Bind Variable , extras map [ string ] Encodable ) ( [ ] byte , error ) { if len ( pq . bind Locations ) = = 0 { return [ ] byte ( pq . Query ) , nil } buf : = bytes . New Buffer ( make ( [ ] byte , 0 , len ( pq . Query ) ) ) current : = 0 for _ , loc : = range pq . bind Locations { buf . Write String ( pq . Query [ current : loc . offset ] ) name : = pq . Query [ loc . offset : loc . offset + loc . length ] if encodable , ok : = extras [ name [ 1 : ] ] ; ok { encodable . Encode SQL ( buf ) } else { supplied , _ , err : = Fetch Bind Var ( name , bind Variables ) if err ! = nil { return nil , err } Encode Value ( buf , supplied ) } current = loc . offset + loc . length } buf . Write String ( pq . Query [ current : ] ) return buf . Bytes ( ) , nil } 
func Encode Value ( buf * bytes . Buffer , value * querypb . Bind Variable ) { if value . Type ! = querypb . Type _TUPLE { v . Encode SQL ( buf ) return } for i , bv : = range value . Values { if i ! = 0 { buf . Write String ( " " ) } sqltypes . Proto To Value ( bv ) . Encode SQL ( buf ) } buf . Write Byte ( ' ) ' ) } 
func ( tkn * Tokenizer ) Lex ( lval * yy Sym Type ) int { typ , val : = tkn . Scan ( ) for typ = = COMMENT { if tkn . Allow Comments { break } typ , val = tkn . Scan ( ) } lval . bytes = val tkn . last Token = val return typ } 
func ( tkn * Tokenizer ) skip Statement ( ) { ch : = tkn . last Char for ch ! = ' ; ' & & ch ! = eof Char { tkn . next ( ) ch = tkn . last Char } } 
func ( tkn * Tokenizer ) reset ( ) { tkn . Parse Tree = nil tkn . partial DDL = nil tkn . special Comment = nil tkn . pos Var Index = 0 tkn . nesting = 0 tkn . Force EOF = false } 
func Preview ( sql string ) int { trimmed : = Strip Leading Comments ( sql ) first Word : = trimmed if end : = strings . Index Func ( trimmed , unicode . Is Space ) ; end ! = - 1 { first Word = trimmed [ : end ] } first Word = strings . Trim Left Func ( first Word , func ( r rune ) bool { return ! unicode . Is Letter ( r ) } ) switch lowered First Word { case " " : return Stmt Select case " " : return Stmt Stream case " " : return Stmt Insert case " " : return Stmt Replace case " " : return Stmt Update case " " : return Stmt Delete } switch strings . To Lower ( trimmed No Comments ) { case " " , " " : return Stmt Begin case " " : return Stmt Commit case " " : return Stmt Rollback } switch lowered First Word { case " " , " " , " " , " " , " " : return Stmt DDL case " " : return Stmt Set case " " : return Stmt Show case " " : return Stmt Use case " " , " " , " " , " " , " " , " " : return Stmt Other } if strings . Index ( trimmed , " " ) = = 0 { return Stmt Comment } return Stmt Unknown } 
func New Plan Value ( node Expr ) ( sqltypes . Plan Value , error ) { switch node : = node . ( type ) { case * SQLVal : switch node . Type { case Val Arg : return sqltypes . Plan Value { Key : string ( node . Val [ 1 : ] ) } , nil case Int Val : n , err : = sqltypes . New Integral ( string ( node . Val ) ) if err ! = nil { return sqltypes . Plan Value { } , fmt . Errorf ( " " , err ) } return sqltypes . Plan Value { Value : n } , nil case Str Val : return sqltypes . Plan Value { Value : sqltypes . Make Trusted ( sqltypes . Var Binary , node . Val ) } , nil case Hex Val : v , err : = node . Hex Decode ( ) if err ! = nil { return sqltypes . Plan Value { } , fmt . Errorf ( " " , err ) } return sqltypes . Plan Value { Value : sqltypes . Make Trusted ( sqltypes . Var Binary , v ) } , nil } case List Arg : return sqltypes . Plan Value { List Key : string ( node [ 2 : ] ) } , nil case Val Tuple : pv : = sqltypes . Plan Value { Values : make ( [ ] sqltypes . Plan Value , 0 , len ( node ) ) , } for _ , val : = range node { innerpv , err : = New Plan Value ( val ) if err ! = nil { return sqltypes . Plan Value { } , err } if innerpv . List Key ! = " " | | innerpv . Values ! = nil { return sqltypes . Plan Value { } , errors . New ( " " ) } pv . Values = append ( pv . Values , innerpv ) } return pv , nil case * Null Val : return sqltypes . Plan Value { } , nil } return sqltypes . Plan Value { } , fmt . Errorf ( " " , String ( node ) ) } 
func String In ( str string , values . . . string ) bool { for _ , val : = range values { if str = = val { return true } } return false } 
func New Tracked Buffer ( node Formatter Node Formatter ) * Tracked Buffer { return & Tracked Buffer { Buffer : new ( bytes . Buffer ) , node Formatter : node Formatter , } } 
func New String Arena ( size int ) * String Arena { sa : = & String Arena { buf : make ( [ ] byte , 0 , size ) } pbytes : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & sa . buf ) ) pstring : = ( * reflect . String Header ) ( unsafe . Pointer ( & sa . str ) ) pstring . Data = pbytes . Data pstring . Len = pbytes . Cap return sa } 
func ( sa * String Arena ) New String ( b [ ] byte ) string { if len ( b ) = = 0 { return " " } if len ( sa . buf ) + len ( b ) > cap ( sa . buf ) { return string ( b ) } start : = len ( sa . buf ) sa . buf = append ( sa . buf , b . . . ) return sa . str [ start : start + len ( b ) ] } 
func ( sa * String Arena ) Space Left ( ) int { return cap ( sa . buf ) - len ( sa . buf ) } 
func String ( b [ ] byte ) ( s string ) { if len ( b ) = = 0 { return " " } pbytes : = ( * reflect . Slice Header ) ( unsafe . Pointer ( & b ) ) pstring : = ( * reflect . String Header ) ( unsafe . Pointer ( & s ) ) pstring . Data = pbytes . Data pstring . Len = pbytes . Len return } 
func Parse ( sql string ) ( Statement , error ) { tokenizer : = New String Tokenizer ( sql ) if yy Parse ( tokenizer ) ! = 0 { if tokenizer . partial DDL ! = nil { log . Printf ( " " , sql , tokenizer . Last Error ) tokenizer . Parse Tree = tokenizer . partial DDL return tokenizer . Parse Tree , nil } return nil , tokenizer . Last Error } return tokenizer . Parse Tree , nil } 
func Parse Strict DDL ( sql string ) ( Statement , error ) { tokenizer : = New String Tokenizer ( sql ) if yy Parse ( tokenizer ) ! = 0 { return nil , tokenizer . Last Error } return tokenizer . Parse Tree , nil } 
func Parse Next ( tokenizer * Tokenizer ) ( Statement , error ) { if tokenizer . last Char = = ' ; ' { tokenizer . next ( ) tokenizer . skip Blank ( ) } if tokenizer . last Char = = eof Char { return nil , io . EOF } tokenizer . reset ( ) tokenizer . multi = true if yy Parse ( tokenizer ) ! = 0 { if tokenizer . partial DDL ! = nil { tokenizer . Parse Tree = tokenizer . partial DDL return tokenizer . Parse Tree , nil } return nil , tokenizer . Last Error } return tokenizer . Parse Tree , nil } 
func Append ( buf * bytes . Buffer , node SQLNode ) { tbuf : = & Tracked Buffer { Buffer : buf , } node . Format ( tbuf ) } 
func ( node * Update ) Format ( buf * Tracked Buffer ) { buf . Myprintf ( " " , node . Comments , node . Table Exprs , node . Exprs , node . Where , node . Order By , node . Limit ) } 
func ( node * DDL ) Format ( buf * Tracked Buffer ) { switch node . Action { case Create Str : if node . Table Spec = = nil { buf . Myprintf ( " " , node . Action , node . New Name ) } else { buf . Myprintf ( " " , node . Action , node . New Name , node . Table Spec ) } case Drop Str : exists : = " " if node . If Exists { exists = " " } buf . Myprintf ( " " , node . Action , exists , node . Table ) case Rename Str : buf . Myprintf ( " " , node . Action , node . Table , node . New Name ) case Alter Str : if node . Partition Spec ! = nil { buf . Myprintf ( " " , node . Action , node . Table , node . Partition Spec ) } else { buf . Myprintf ( " " , node . Action , node . Table ) } case Create Vindex Str : buf . Myprintf ( " " , node . Action , node . Vindex Spec . Name , node . Vindex Spec ) case Add Col Vindex Str : buf . Myprintf ( " " , node . Table , node . Action , node . Vindex Spec . Name ) for i , col : = range node . Vindex Cols { if i ! = 0 { buf . Myprintf ( " " , col ) } else { buf . Myprintf ( " " , col ) } } buf . Myprintf ( " " ) if node . Vindex Spec . Type . String ( ) ! = " " { buf . Myprintf ( " " , node . Vindex Spec ) } case Drop Col Vindex Str : buf . Myprintf ( " " , node . Table , node . Action , node . Vindex Spec . Name ) default : buf . Myprintf ( " " , node . Action , node . Table ) } } 
func ( node * Show ) Format ( buf * Tracked Buffer ) { if node . Type = = " " & & node . Show Tables Opt ! = nil { opt : = node . Show Tables Opt if opt . Db Name ! = " " { if opt . Filter ! = nil { buf . Myprintf ( " " , opt . Extended , opt . Full , opt . Db Name , opt . Filter ) } else { buf . Myprintf ( " " , opt . Extended , opt . Full , opt . Db Name ) } } else { if opt . Filter ! = nil { buf . Myprintf ( " " , opt . Extended , opt . Full , opt . Filter ) } else { buf . Myprintf ( " " , opt . Extended , opt . Full ) } } return } if node . Scope = = " " { buf . Myprintf ( " " , node . Type ) } else { buf . Myprintf ( " " , node . Scope , node . Type ) } if node . Has On Table ( ) { buf . Myprintf ( " " , node . On Table ) } } 
func ( node * Show Filter ) Format ( buf * Tracked Buffer ) { if node . Like ! = " " { buf . Myprintf ( " " , node . Like ) } else { buf . Myprintf ( " " , node . Filter ) } } 
func Expr From Value ( value sqltypes . Value ) ( Expr , error ) { case value . Is Integral ( ) : return New Int Val ( value . To Bytes ( ) ) , nil case value . Is Float ( ) | | value . Type ( ) = = sqltypes . Decimal : return New Float Val ( value . To Bytes ( ) ) , nil case value . Is Quoted ( ) : return New Str Val ( value . To Bytes ( ) ) , nil default : } } 
func ( node * Substr Expr ) Format ( buf * Tracked Buffer ) { if node . To = = nil { buf . Myprintf ( " " , node . Name , node . From ) } else { buf . Myprintf ( " " , node . Name , node . From , node . To ) } } 
func ( node * Set Expr ) Format ( buf * Tracked Buffer ) { } else { buf . Myprintf ( " " , node . Name . String ( ) , node . Expr ) } } 
func Backtick ( in string ) string { var buf bytes . Buffer buf . Write Byte ( ' ` ' ) for _ , c : = range in { buf . Write Rune ( c ) if c = = ' ` ' { buf . Write Byte ( ' ` ' ) } } buf . Write Byte ( ' ` ' ) return buf . String ( ) } 
func New Value ( typ querypb . Type , val [ ] byte ) ( v Value , err error ) { switch { case Is Signed ( typ ) : if _ , err : = strconv . Parse Int ( string ( val ) , 0 , 6 4 ) ; err ! = nil { return NULL , err } return Make Trusted ( typ , val ) , nil case Is Unsigned ( typ ) : if _ , err : = strconv . Parse Uint ( string ( val ) , 0 , 6 4 ) ; err ! = nil { return NULL , err } return Make Trusted ( typ , val ) , nil case Is Float ( typ ) | | typ = = Decimal : if _ , err : = strconv . Parse Float ( string ( val ) , 6 4 ) ; err ! = nil { return NULL , err } return Make Trusted ( typ , val ) , nil case Is Quoted ( typ ) | | typ = = Null : return Make Trusted ( typ , val ) , nil } } 
func ( v Value ) String ( ) string { if v . typ = = Null { return " " } if v . Is Quoted ( ) { return fmt . Sprintf ( " " , v . typ , v . val ) } return fmt . Sprintf ( " " , v . typ , v . val ) } 
func ( v Value ) Encode SQL ( b Bin Writer ) { switch { case v . typ = = Null : b . Write ( nullstr ) case v . Is Quoted ( ) : encode Bytes SQL ( v . val , b ) default : b . Write ( v . val ) } } 
func ( iv Insert Values ) Encode SQL ( buf * bytes . Buffer ) { for i , rows : = range iv { if i ! = 0 { buf . Write String ( " " ) } buf . Write Byte ( ' ( ' ) for j , bv : = range rows { if j ! = 0 { buf . Write String ( " " ) } bv . Encode SQL ( buf ) } buf . Write Byte ( ' ) ' ) } } 
func ( tpl * Tuple Equality List ) Encode SQL ( buf * bytes . Buffer ) { if len ( tpl . Columns ) = = 1 { tpl . encode As In ( buf ) return } tpl . encode As Equality ( buf ) } 
func ( nz * normalizer ) Walk Statement ( node SQLNode ) ( bool , error ) { switch node : = node . ( type ) { case * Select : _ = Walk ( nz . Walk Select , node ) case * SQLVal : nz . convert SQLVal ( node ) case * Comparison Expr : nz . convert Comparison ( node ) } return true , nil } 
func ( nz * normalizer ) Walk Select ( node SQLNode ) ( bool , error ) { switch node : = node . ( type ) { case * SQLVal : nz . convert SQLVal Dedup ( node ) case * Comparison Expr : nz . convert Comparison ( node ) } return true , nil } 
func Get Bindvars ( stmt Statement ) map [ string ] struct { } { bindvars : = make ( map [ string ] struct { } ) _ = Walk ( func ( node SQLNode ) ( kontinue bool , err error ) { switch node : = node . ( type ) { case * SQLVal : if node . Type = = Val Arg { bindvars [ string ( node . Val [ 1 : ] ) ] = struct { } { } } case List Arg : bindvars [ string ( node [ 2 : ] ) ] = struct { } { } } return true , nil } , stmt ) return bindvars } 
func Bind Variables Equal ( x , y map [ string ] * querypb . Bind Variable ) bool { return reflect . Deep Equal ( & querypb . Bound Query { Bind Variables : x } , & querypb . Bound Query { Bind Variables : y } ) } 
func New ( options . . . Options ) * JWTMiddleware { var opts Options if len ( options ) = = 0 { opts = Options { } } else { opts = options [ 0 ] } if opts . User Property = = " " { opts . User Property = " " } if opts . Error Handler = = nil { opts . Error Handler = On Error } if opts . Extractor = = nil { opts . Extractor = From Auth Header } return & JWTMiddleware { Options : opts , } } 
func ( m * JWTMiddleware ) Handler With Next ( w http . Response Writer , r * http . Request , next http . Handler Func ) { err : = m . Check JWT ( w , r ) } } 
func From Auth Header ( r * http . Request ) ( string , error ) { auth Header : = r . Header . Get ( " " ) if auth Header = = " " { return " " , nil } if len ( auth Header Parts ) ! = 2 | | strings . To Lower ( auth Header Parts [ 0 ] ) ! = " " { return " " , errors . New ( " " ) } return auth Header Parts [ 1 ] , nil } 
func From Parameter ( param string ) Token Extractor { return func ( r * http . Request ) ( string , error ) { return r . URL . Query ( ) . Get ( param ) , nil } } 
func From First ( extractors . . . Token Extractor ) Token Extractor { return func ( r * http . Request ) ( string , error ) { for _ , ex : = range extractors { token , err : = ex ( r ) if err ! = nil { return " " , err } if token ! = " " { return token , nil } } return " " , nil } } 
func ( p * Pub Sub ) get Hello Packet ( ) * RPC { var rpc RPC for t : = range p . my Topics { as : = & pb . RPC _Sub Opts { Topicid : proto . String ( t ) , Subscribe : proto . Bool ( true ) , } rpc . Subscriptions = append ( rpc . Subscriptions , as ) } return & rpc } 
func New Floodsub With Protocols ( ctx context . Context , h host . Host , ps [ ] protocol . ID , opts . . . Option ) ( * Pub Sub , error ) { rt : = & Flood Sub Router { protocols : ps , } return New Pub Sub ( ctx , h , rt , opts . . . ) } 
func New Flood Sub ( ctx context . Context , h host . Host , opts . . . Option ) ( * Pub Sub , error ) { return New Floodsub With Protocols ( ctx , h , [ ] protocol . ID { Flood Sub ID } , opts . . . ) } 
func New LRUBlacklist ( cap int ) ( Blacklist , error ) { c , err : = lru . New ( cap ) if err ! = nil { return nil , err } b : = & LRUBlacklist { lru : c } return b , nil } 
func New Random Sub ( ctx context . Context , h host . Host , opts . . . Option ) ( * Pub Sub , error ) { rt : = & Random Sub Router { peers : make ( map [ peer . ID ] protocol . ID ) , } return New Pub Sub ( ctx , h , rt , opts . . . ) } 
func New Gossip Sub ( ctx context . Context , h host . Host , opts . . . Option ) ( * Pub Sub , error ) { rt : = & Gossip Sub Router { peers : make ( map [ peer . ID ] protocol . ID ) , mesh : make ( map [ string ] map [ peer . ID ] struct { } ) , fanout : make ( map [ string ] map [ peer . ID ] struct { } ) , lastpub : make ( map [ string ] int 6 4 ) , gossip : make ( map [ peer . ID ] [ ] * pb . Control IHave ) , control : make ( map [ peer . ID ] * pb . Control Message ) , mcache : New Message Cache ( Gossip Sub History Gossip , Gossip Sub History Length ) , } return New Pub Sub ( ctx , h , rt , opts . . . ) } 
func New Pub Sub ( ctx context . Context , h host . Host , rt Pub Sub Router , opts . . . Option ) ( * Pub Sub , error ) { ps : = & Pub Sub { host : h , ctx : ctx , rt : rt , sign ID : h . ID ( ) , sign Key : h . Peerstore ( ) . Priv Key ( h . ID ( ) ) , sign Strict : true , incoming : make ( chan * RPC , 3 2 ) , publish : make ( chan * Message ) , new Peers : make ( chan peer . ID ) , new Peer Stream : make ( chan inet . Stream ) , new Peer Error : make ( chan peer . ID ) , peer Dead : make ( chan peer . ID ) , cancel Ch : make ( chan * Subscription ) , get Peers : make ( chan * list Peer Req ) , add Sub : make ( chan * add Sub Req ) , get Topics : make ( chan * topic Req ) , send Msg : make ( chan * send Req , 3 2 ) , add Val : make ( chan * add Val Req ) , rm Val : make ( chan * rm Val Req ) , validate Throttle : make ( chan struct { } , default Validate Throttle ) , eval : make ( chan func ( ) ) , my Topics : make ( map [ string ] map [ * Subscription ] struct { } ) , topics : make ( map [ string ] map [ peer . ID ] struct { } ) , peers : make ( map [ peer . ID ] chan * RPC ) , topic Vals : make ( map [ string ] * topic Val ) , blacklist : New Map Blacklist ( ) , blacklist Peer : make ( chan peer . ID ) , seen Messages : timecache . New Time Cache ( Time Cache Duration ) , counter : uint 6 4 ( time . Now ( ) . Unix Nano ( ) ) , } for _ , opt : = range opts { err : = opt ( ps ) if err ! = nil { return nil , err } } if ps . sign Strict & & ps . sign Key = = nil { return nil , fmt . Errorf ( " " ) } rt . Attach ( ps ) for _ , id : = range rt . Protocols ( ) { h . Set Stream Handler ( id , ps . handle New Stream ) } h . Network ( ) . Notify ( ( * Pub Sub Notif ) ( ps ) ) go ps . process Loop ( ctx ) return ps , nil } 
func With Validate Throttle ( n int ) Option { return func ( ps * Pub Sub ) error { ps . validate Throttle = make ( chan struct { } , n ) return nil } } 
func With Message Signing ( enabled bool ) Option { return func ( p * Pub Sub ) error { if enabled { p . sign Key = p . host . Peerstore ( ) . Priv Key ( p . sign ID ) if p . sign Key = = nil { return fmt . Errorf ( " " , p . sign ID ) } } else { p . sign Key = nil p . sign Strict = false } return nil } } 
func With Message Author ( author peer . ID ) Option { return func ( p * Pub Sub ) error { if author = = " " { author = p . host . ID ( ) } if p . sign Key ! = nil { new Sign Key : = p . host . Peerstore ( ) . Priv Key ( author ) if new Sign Key = = nil { return fmt . Errorf ( " " , p . sign ID ) } p . sign Key = new Sign Key } p . sign ID = author return nil } } 
func With Strict Signature Verification ( required bool ) Option { return func ( p * Pub Sub ) error { p . sign Strict = required return nil } } 
func With Blacklist ( b Blacklist ) Option { return func ( p * Pub Sub ) error { p . blacklist = b return nil } } 
func ( p * Pub Sub ) process Loop ( ctx context . Context ) { defer func ( ) { } p . peers = nil p . topics = nil } ( ) for { select { case pid : = < - p . new Peers : if _ , ok : = p . peers [ pid ] ; ok { log . Warning ( " " , pid ) continue } if p . blacklist . Contains ( pid ) { log . Warning ( " " , pid ) continue } messages : = make ( chan * RPC , 3 2 ) messages < - p . get Hello Packet ( ) go p . handle New Peer ( ctx , pid , messages ) p . peers [ pid ] = messages case s : = < - p . new Peer Stream : pid : = s . Conn ( ) . Remote Peer ( ) ch , ok : = p . peers [ pid ] if ! ok { log . Warning ( " " , pid ) s . Reset ( ) continue } if p . blacklist . Contains ( pid ) { log . Warning ( " " , pid ) close ( ch ) s . Reset ( ) continue } p . rt . Add Peer ( pid , s . Protocol ( ) ) case pid : = < - p . new Peer Error : delete ( p . peers , pid ) case pid : = < - p . peer Dead : ch , ok : = p . peers [ pid ] if ! ok { continue } close ( ch ) if p . host . Network ( ) . Connectedness ( pid ) = = inet . Connected { messages : = make ( chan * RPC , 3 2 ) messages < - p . get Hello Packet ( ) go p . handle New Peer ( ctx , pid , messages ) p . peers [ pid ] = messages continue } delete ( p . peers , pid ) for _ , t : = range p . topics { delete ( t , pid ) } p . rt . Remove Peer ( pid ) case treq : = < - p . get Topics : var out [ ] string for t : = range p . my Topics { out = append ( out , t ) } treq . resp < - out case sub : = < - p . cancel Ch : p . handle Remove Subscription ( sub ) case sub : = < - p . add Sub : p . handle Add Subscription ( sub ) case preq : = < - p . get Peers : tmap , ok : = p . topics [ preq . topic ] if preq . topic ! = " " & & ! ok { preq . resp < - nil continue } var peers [ ] peer . ID for p : = range p . peers { if preq . topic ! = " " { _ , ok : = tmap [ p ] if ! ok { continue } } peers = append ( peers , p ) } preq . resp < - peers case rpc : = < - p . incoming : p . handle Incoming RPC ( rpc ) case msg : = < - p . publish : vals : = p . get Validators ( msg ) p . push Msg ( vals , p . host . ID ( ) , msg ) case req : = < - p . send Msg : p . publish Message ( req . from , req . msg . Message ) case req : = < - p . add Val : p . add Validator ( req ) case req : = < - p . rm Val : p . rm Validator ( req ) case thunk : = < - p . eval : thunk ( ) case pid : = < - p . blacklist Peer : log . Infof ( " " , pid ) p . blacklist . Add ( pid ) ch , ok : = p . peers [ pid ] if ok { close ( ch ) delete ( p . peers , pid ) for _ , t : = range p . topics { delete ( t , pid ) } p . rt . Remove Peer ( pid ) } case < - ctx . Done ( ) : log . Info ( " " ) return } } } 
func ( p * Pub Sub ) handle Remove Subscription ( sub * Subscription ) { subs : = p . my Topics [ sub . topic ] if subs = = nil { return } sub . err = fmt . Errorf ( " " ) close ( sub . ch ) delete ( subs , sub ) if len ( subs ) = = 0 { delete ( p . my Topics , sub . topic ) p . announce ( sub . topic , false ) p . rt . Leave ( sub . topic ) } } 
func ( p * Pub Sub ) handle Add Subscription ( req * add Sub Req ) { sub : = req . sub subs : = p . my Topics [ sub . topic ] p . rt . Join ( sub . topic ) } subs = p . my Topics [ sub . topic ] } sub . ch = make ( chan * Message , 3 2 ) sub . cancel Ch = p . cancel Ch p . my Topics [ sub . topic ] [ sub ] = struct { } { } req . resp < - sub } 
func ( p * Pub Sub ) announce ( topic string , sub bool ) { subopt : = & pb . RPC _Sub Opts { Topicid : & topic , Subscribe : & sub , } out : = rpc With Subs ( subopt ) for pid , peer : = range p . peers { select { case peer < - out : default : log . Infof ( " " , pid ) go p . announce Retry ( pid , topic , sub ) } } } 
func ( p * Pub Sub ) notify Subs ( msg * pb . Message ) { for _ , topic : = range msg . Get Topic IDs ( ) { subs : = p . my Topics [ topic ] for f : = range subs { select { case f . ch < - & Message { msg } : default : log . Infof ( " " , topic ) } } } } 
func ( p * Pub Sub ) seen Message ( id string ) bool { return p . seen Messages . Has ( id ) } 
func ( p * Pub Sub ) subscribed To Msg ( msg * pb . Message ) bool { if len ( p . my Topics ) = = 0 { return false } for _ , t : = range msg . Get Topic IDs ( ) { if _ , ok : = p . my Topics [ t ] ; ok { return true } } return false } 
func msg ID ( pmsg * pb . Message ) string { return string ( pmsg . Get From ( ) ) + string ( pmsg . Get Seqno ( ) ) } 
func ( p * Pub Sub ) push Msg ( vals [ ] * topic Val , src peer . ID , msg * Message ) { return } return } return } if p . seen Message ( id ) { return } if len ( vals ) > 0 | | msg . Signature ! = nil { < - p . validate Throttle } ( ) default : log . Warningf ( " " , src ) } return } p . publish Message ( src , msg . Message ) } 
func ( p * Pub Sub ) validate ( vals [ ] * topic Val , src peer . ID , msg * Message ) { if msg . Signature ! = nil { if ! p . validate Signature ( msg ) { log . Warningf ( " " , src ) return } } if len ( vals ) > 0 { if ! p . validate Topic ( vals , src , msg ) { log . Warningf ( " " , src ) return } } } 
func ( p * Pub Sub ) validate Single Topic ( val * topic Val , src peer . ID , msg * Message ) bool { select { case val . validate Throttle < - struct { } { } : ctx , cancel : = context . With Cancel ( p . ctx ) defer cancel ( ) res : = val . validate Msg ( ctx , src , msg ) < - val . validate Throttle return res default : log . Debugf ( " " , val . topic ) return false } } 
func ( p * Pub Sub ) get Validators ( msg * Message ) [ ] * topic Val { var vals [ ] * topic Val for _ , topic : = range msg . Get Topic IDs ( ) { val , ok : = p . topic Vals [ topic ] if ! ok { continue } vals = append ( vals , val ) } return vals } 
func ( p * Pub Sub ) Subscribe ( topic string , opts . . . Sub Opt ) ( * Subscription , error ) { td : = pb . Topic Descriptor { Name : & topic } return p . Subscribe By Topic Descriptor ( & td , opts . . . ) } 
func ( p * Pub Sub ) Subscribe By Topic Descriptor ( td * pb . Topic Descriptor , opts . . . Sub Opt ) ( * Subscription , error ) { if td . Get Auth ( ) . Get Mode ( ) ! = pb . Topic Descriptor _Auth Opts _NONE { return nil , fmt . Errorf ( " " ) } if td . Get Enc ( ) . Get Mode ( ) ! = pb . Topic Descriptor _Enc Opts _NONE { return nil , fmt . Errorf ( " " ) } sub : = & Subscription { topic : td . Get Name ( ) , } for _ , opt : = range opts { err : = opt ( sub ) if err ! = nil { return nil , err } } out : = make ( chan * Subscription , 1 ) p . add Sub < - & add Sub Req { sub : sub , resp : out , } return < - out , nil } 
func ( p * Pub Sub ) Get Topics ( ) [ ] string { out : = make ( chan [ ] string , 1 ) p . get Topics < - & topic Req { resp : out } return < - out } 
func ( p * Pub Sub ) Publish ( topic string , data [ ] byte ) error { seqno : = p . next Seqno ( ) m : = & pb . Message { Data : data , Topic IDs : [ ] string { topic } , From : [ ] byte ( p . host . ID ( ) ) , Seqno : seqno , } if p . sign Key ! = nil { m . From = [ ] byte ( p . sign ID ) err : = sign Message ( p . sign ID , p . sign Key , m ) if err ! = nil { return err } } p . publish < - & Message { m } return nil } 
func ( p * Pub Sub ) List Peers ( topic string ) [ ] peer . ID { out : = make ( chan [ ] peer . ID ) p . get Peers < - & list Peer Req { resp : out , topic : topic , } return < - out } 
func With Validator Timeout ( timeout time . Duration ) Validator Opt { return func ( add Val * add Val Req ) error { add Val . timeout = timeout return nil } } 
func With Validator Concurrency ( n int ) Validator Opt { return func ( add Val * add Val Req ) error { add Val . throttle = n return nil } } 
func ( p * Pub Sub ) Register Topic Validator ( topic string , val Validator , opts . . . Validator Opt ) error { add Val : = & add Val Req { topic : topic , validate : val , resp : make ( chan error , 1 ) , } for _ , opt : = range opts { err : = opt ( add Val ) if err ! = nil { return err } } p . add Val < - add Val return < - add Val . resp } 
func ( p * Pub Sub ) Unregister Topic Validator ( topic string ) error { rm Val : = & rm Val Req { topic : topic , resp : make ( chan error , 1 ) , } p . rm Val < - rm Val return < - rm Val . resp } 
func Default Metric Prefix ( name string , tags map [ string ] string ) string { return Metric With Prefix ( " " , name , tags ) } 
func Metric With Prefix ( prefix , name string , tags map [ string ] string ) string { buf : = buf Pool . Get ( ) . ( * bytes . Buffer ) buf . Reset ( ) if prefix ! = " " { buf . Write String ( prefix ) } buf . Write String ( name ) add Keys : = make ( [ ] string , 0 , 5 ) switch { case strings . Has Prefix ( name , " " ) : add Keys = append ( add Keys , " " , " " , " " ) if strings . Has Prefix ( name , " " ) { add Keys = append ( add Keys , " " ) } case strings . Has Prefix ( name , " " ) : add Keys = append ( add Keys , " " , " " , " " ) } for _ , k : = range add Keys { buf . Write Byte ( ' . ' ) v , ok : = tags [ k ] if ok { write Clean ( buf , v ) } else { buf . Write String ( " " ) buf . Write String ( k ) } } m : = buf . String ( ) buf Pool . Put ( buf ) return m } 
func write Clean ( buf * bytes . Buffer , v string ) { for i : = 0 ; i < len ( v ) ; i + + { c : = v [ i ] switch c { case ' { ' , ' } ' , ' / ' , ' \ \ ' , ' : ' , ' . ' , ' ' , ' \t ' , ' \r ' , ' \n ' : buf . Write Byte ( ' - ' ) default : buf . Write Byte ( c ) } } } 
func New Client ( ch * tchannel . Channel , target Service string , opts * Client Options ) * Client { client : = & Client { ch : ch , target Service : target Service , } if opts ! = nil & & opts . Host Port ! = " " { client . host Port = opts . Host Port } return client } 
func ( c * Client ) Call ( ctx Context , method string , arg , resp interface { } ) error { var ( headers = ctx . Headers ( ) resp Headers map [ string ] string resp Err Err Application err At string is OK bool ) err : = c . ch . Run With Retry ( ctx , func ( ctx context . Context , rs * tchannel . Request State ) error { resp Headers , resp Err , is OK = nil , nil , false err At = " " call , err : = c . start Call ( ctx , method , & tchannel . Call Options { Format : tchannel . JSON , Request State : rs , } ) if err ! = nil { return err } is OK , err At , err = make Call ( call , headers , arg , & resp Headers , resp , & resp Err ) return err } ) if err ! = nil { } if ! is OK { return resp Err } return nil } 
func wrap Call ( ctx Context , call * tchannel . Outbound Call , method string , arg , resp interface { } ) error { var resp Headers map [ string ] string var resp Err Err Application is OK , err At , err : = make Call ( call , ctx . Headers ( ) , arg , & resp Headers , resp , & resp Err ) if err ! = nil { return fmt . Errorf ( " " , err At , err ) } if ! is OK { return resp Err } ctx . Set Response Headers ( resp Headers ) return nil } 
func Call Peer ( ctx Context , peer * tchannel . Peer , service Name , method string , arg , resp interface { } ) error { call , err : = peer . Begin Call ( ctx , service Name , method , & tchannel . Call Options { Format : tchannel . JSON } ) if err ! = nil { return err } return wrap Call ( ctx , call , method , arg , resp ) } 
func Call SC ( ctx Context , sc * tchannel . Sub Channel , method string , arg , resp interface { } ) error { call , err : = sc . Begin Call ( ctx , method , & tchannel . Call Options { Format : tchannel . JSON } ) if err ! = nil { return err } return wrap Call ( ctx , call , method , arg , resp ) } 
func Read Response ( call tchannel . Arg Readable ) ( * http . Response , error ) { var arg 2 [ ] byte if err : = tchannel . New Arg Reader ( call . Arg 2Reader ( ) ) . Read ( & arg 2 ) ; err ! = nil { return nil , err } rb : = typed . New Read Buffer ( arg 2 ) status Code : = rb . Read Uint 1 6 ( ) message : = read Varint String ( rb ) response : = & http . Response { Status Code : int ( status Code ) , Status : fmt . Sprintf ( " " , status Code , message ) , Proto : " " , Proto Major : 1 , Proto Minor : 1 , Header : make ( http . Header ) , } read Headers ( rb , response . Header ) if err : = rb . Err ( ) ; err ! = nil { return nil , err } arg 3Reader , err : = call . Arg 3Reader ( ) if err ! = nil { return nil , err } response . Body = arg 3Reader return response , nil } 
func ( w * tchan Response Writer ) write Headers ( ) { wb . Write Uint 1 6 ( uint 1 6 ( w . status Code ) ) write Varint String ( wb , http . Status Text ( w . status Code ) ) write Headers ( wb , w . headers ) arg 2Writer , err : = w . response . Arg 2Writer ( ) if err ! = nil { w . err = err return } if _ , w . err = wb . Flush To ( arg 2Writer ) ; w . err ! = nil { return } if w . err = arg 2Writer . Close ( ) ; w . err ! = nil { return } w . arg 3Writer , w . err = w . response . Arg 3Writer ( ) } 
func Response Writer ( response tchannel . Arg Writable ) ( http . Response Writer , func ( ) error ) { response Writer : = new TChan Response Writer ( response ) return response Writer , response Writer . finish } 
func Write Headers ( w io . Writer , headers map [ string ] string ) error { for k , v : = range headers { size + = 4 size + = len ( k ) + len ( v ) } buf : = make ( [ ] byte , size ) write Buffer : = typed . New Write Buffer ( buf ) write Buffer . Write Uint 1 6 ( uint 1 6 ( len ( headers ) ) ) for k , v : = range headers { write Buffer . Write Len 1 6String ( k ) write Buffer . Write Len 1 6String ( v ) } if err : = write Buffer . Err ( ) ; err ! = nil { return err } } _ , err : = write Buffer . Flush To ( w ) return err } 
func Read Headers ( r io . Reader ) ( map [ string ] string , error ) { reader : = typed . New Reader ( r ) m , err : = read Headers ( reader ) reader . Release ( ) return m , err } 
func New TCPRaw Relay ( dests [ ] string ) ( Relay , error ) { return new TCPRelay ( dests , func ( _ bool , src , dst net . Conn ) { io . Copy ( src , dst ) } ) } 
func ( f * Fail Strategy ) Unmarshal Text ( text [ ] byte ) error { switch strategy : = string ( text ) ; strategy { case " " , " " : * f = Fail Strategy Fatal case " " : * f = Fail Strategy Ignore default : return fmt . Errorf ( " " , strategy ) } return nil } 
func New Client ( ch * tchannel . Channel , config Configuration , opts * Client Options ) ( * Client , error ) { client : = & Client { tchan : ch , quit : make ( chan struct { } ) } if opts ! = nil { client . opts = * opts } if client . opts . Timeout = = 0 { client . opts . Timeout = 3 * time . Second } if client . opts . Timeout Per Attempt = = 0 { client . opts . Timeout Per Attempt = time . Second } if client . opts . Handler = = nil { client . opts . Handler = null Handler { } } if client . opts . Time Sleep = = nil { client . opts . Time Sleep = time . Sleep } if err : = parse Config ( & config ) ; err ! = nil { return nil , err } } client . json Client = tjson . New Client ( ch , hyperbahn Service Name , nil ) thrift Client : = tthrift . New Client ( ch , hyperbahn Service Name , nil ) client . hyperbahn Client = htypes . New TChan Hyperbahn Client ( thrift Client ) return client , nil } 
func parse Config ( config * Configuration ) error { if config . Initial Nodes File ! = " " { f , err : = os . Open ( config . Initial Nodes File ) if err ! = nil { return err } defer f . Close ( ) decoder : = json . New Decoder ( f ) if err : = decoder . Decode ( & config . Initial Nodes ) ; err ! = nil { return err } } if len ( config . Initial Nodes ) = = 0 { return fmt . Errorf ( " " ) } for _ , node : = range config . Initial Nodes { if _ , _ , err : = net . Split Host Port ( node ) ; err ! = nil { return fmt . Errorf ( " " , node , err ) } } return nil } 
func add Peer ( ch * tchannel . Channel , host Port string ) { peers : = ch . Get Sub Channel ( hyperbahn Service Name ) . Peers ( ) peers . Add ( host Port ) } 
func ( c * Client ) Advertise ( other Services . . . tchannel . Registrar ) error { c . get Service Names ( other Services ) if err : = c . initial Advertise ( ) ; err ! = nil { return err } c . opts . Handler . On ( Advertised ) go c . advertise Loop ( ) return nil } 
func verify Handler ( t reflect . Type ) error { if t . Num In ( ) ! = 2 | | t . Num Out ( ) ! = 2 { return fmt . Errorf ( " " ) } is Struct Ptr : = func ( t reflect . Type ) bool { return t . Kind ( ) = = reflect . Ptr & & t . Elem ( ) . Kind ( ) = = reflect . Struct } is Map : = func ( t reflect . Type ) bool { return t . Kind ( ) = = reflect . Map & & t . Key ( ) . Kind ( ) = = reflect . String } validate Arg Res : = func ( t reflect . Type , name string ) error { if ! is Struct Ptr ( t ) & & ! is Map ( t ) { return fmt . Errorf ( " " , name ) } return nil } if t . In ( 0 ) ! = type Of Context { return fmt . Errorf ( " " ) } if err : = validate Arg Res ( t . In ( 1 ) , " " ) ; err ! = nil { return err } if err : = validate Arg Res ( t . Out ( 0 ) , " " ) ; err ! = nil { return err } if ! t . Out ( 1 ) . Assignable To ( type Of Error ) { return fmt . Errorf ( " " ) } return nil } 
func Register ( registrar tchannel . Registrar , funcs Handlers , on Error func ( context . Context , error ) ) error { handlers : = make ( map [ string ] * handler ) handler : = tchannel . Handler Func ( func ( ctx context . Context , call * tchannel . Inbound Call ) { h , ok : = handlers [ string ( call . Method ( ) ) ] if ! ok { on Error ( ctx , fmt . Errorf ( " " , call . Method ( ) ) ) return } if err : = h . Handle ( ctx , call ) ; err ! = nil { on Error ( ctx , err ) } } ) for m , f : = range funcs { h , err : = to Handler ( f ) if err ! = nil { return fmt . Errorf ( " " , m , err ) } h . tracer = func ( ) opentracing . Tracer { return tchannel . Tracer From Registrar ( registrar ) } handlers [ m ] = h registrar . Register ( handler , m ) } return nil } 
func ( h * handler ) Handle ( tctx context . Context , call * tchannel . Inbound Call ) error { var headers map [ string ] string if err : = tchannel . New Arg Reader ( call . Arg 2Reader ( ) ) . Read JSON ( & headers ) ; err ! = nil { return fmt . Errorf ( " " , err ) } tctx = tchannel . Extract Inbound Span ( tctx , call , headers , h . tracer ( ) ) ctx : = With Headers ( tctx , headers ) var arg 3 reflect . Value var call Arg reflect . Value if h . is Arg Map { arg 3 = reflect . New ( h . arg Type ) } else { arg 3 = reflect . New ( h . arg Type . Elem ( ) ) call Arg = arg 3 } if err : = tchannel . New Arg Reader ( call . Arg 3Reader ( ) ) . Read JSON ( arg 3 . Interface ( ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } args : = [ ] reflect . Value { reflect . Value Of ( ctx ) , call Arg } results : = h . handler . Call ( args ) res : = results [ 0 ] . Interface ( ) err : = results [ 1 ] . Interface ( ) } call . Response ( ) . Set Application Error ( ) Message string `json : "message " ` } { Type : " " , Message : err . ( error ) . Error ( ) , } } if err : = tchannel . New Arg Writer ( call . Response ( ) . Arg 2Writer ( ) ) . Write JSON ( ctx . Response Headers ( ) ) ; err ! = nil { return err } return tchannel . New Arg Writer ( call . Response ( ) . Arg 3Writer ( ) ) . Write JSON ( res ) } 
func ( s * Server ) Start ( ) error { if s . Host Port = = " " { s . Host Port = " " + common . Default Server Port } channel Opts : = & tchannel . Channel Options { Tracer : s . Tracer , } ch , err : = tchannel . New Channel ( common . Default Service Name , channel Opts ) if err ! = nil { return err } if err : = ch . Listen And Serve ( s . Host Port ) ; err ! = nil { return err } s . Host Port = ch . Peer Info ( ) . Host Port log . Printf ( " \n " , s . Host Port ) s . Ch = ch return nil } 
func ( s * Server ) Port ( ) string { host Port Split : = strings . Split ( s . Host Port , " " ) port : = host Port Split [ len ( host Port Split ) - 1 ] return port } 
func ( l * Peer List ) Set Strategy ( sc Score Calculator ) { l . Lock ( ) defer l . Unlock ( ) l . score Calculator = sc for _ , ps : = range l . peers By Host Port { new Score : = l . score Calculator . Get Score ( ps . Peer ) l . update Peer ( ps , new Score ) } } 
func ( l * Peer List ) Add ( host Port string ) * Peer { if ps , ok : = l . exists ( host Port ) ; ok { return ps . Peer } l . Lock ( ) defer l . Unlock ( ) if p , ok : = l . peers By Host Port [ host Port ] ; ok { return p . Peer } p : = l . parent . Add ( host Port ) p . add SC ( ) ps : = new Peer Score ( p , l . score Calculator . Get Score ( p ) ) l . peers By Host Port [ host Port ] = ps l . peer Heap . add Peer ( ps ) return p } 
func ( l * Peer List ) Get New ( prev Selected map [ string ] struct { } ) ( * Peer , error ) { l . Lock ( ) defer l . Unlock ( ) if l . peer Heap . Len ( ) = = 0 { return nil , Err No Peers } if peer = = nil { peer = l . choose Peer ( prev Selected , false ) } if peer = = nil { return nil , Err No New Peers } return peer , nil } 
func ( l * Peer List ) Get ( prev Selected map [ string ] struct { } ) ( * Peer , error ) { peer , err : = l . Get New ( prev Selected ) if err = = Err No New Peers { l . Lock ( ) peer = l . choose Peer ( nil , false ) l . Unlock ( ) } else if err ! = nil { return nil , err } if peer = = nil { return nil , Err No Peers } return peer , nil } 
func ( l * Peer List ) Remove ( host Port string ) error { l . Lock ( ) defer l . Unlock ( ) p , ok : = l . peers By Host Port [ host Port ] if ! ok { return Err Peer Not Found } p . del SC ( ) delete ( l . peers By Host Port , host Port ) l . peer Heap . remove Peer ( p ) return nil } 
func ( l * Peer List ) Get Or Add ( host Port string ) * Peer { if ps , ok : = l . exists ( host Port ) ; ok { return ps . Peer } return l . Add ( host Port ) } 
func ( l * Peer List ) Copy ( ) map [ string ] * Peer { l . RLock ( ) defer l . RUnlock ( ) list Copy : = make ( map [ string ] * Peer ) for k , v : = range l . peers By Host Port { list Copy [ k ] = v . Peer } return list Copy } 
func ( l * Peer List ) Len ( ) int { l . RLock ( ) defer l . RUnlock ( ) return l . peer Heap . Len ( ) } 
func ( l * Peer List ) exists ( host Port string ) ( * peer Score , bool ) { l . RLock ( ) ps , ok : = l . peers By Host Port [ host Port ] l . RUnlock ( ) return ps , ok } 
func ( l * Peer List ) get Peer Score ( host Port string ) ( * peer Score , uint 6 4 , bool ) { ps , ok : = l . peers By Host Port [ host Port ] if ! ok { return nil , 0 , false } return ps , ps . score , ok } 
func ( l * Peer List ) on Peer Change ( p * Peer ) { l . RLock ( ) ps , ps Score , ok : = l . get Peer Score ( p . host Port ) sc : = l . score Calculator l . RUnlock ( ) if ! ok { return } new Score : = sc . Get Score ( ps . Peer ) if new Score = = ps Score { return } l . Lock ( ) l . update Peer ( ps , new Score ) l . Unlock ( ) } 
func ( l * Peer List ) update Peer ( ps * peer Score , new Score uint 6 4 ) { if ps . score = = new Score { return } ps . score = new Score l . peer Heap . update Peer ( ps ) } 
func ( p * Peer ) get Conn ( i int ) * Connection { inbound Len : = len ( p . inbound Connections ) if i < inbound Len { return p . inbound Connections [ i ] } return p . outbound Connections [ i - inbound Len ] } 
func ( p * Peer ) get Active Conn ( ) ( * Connection , bool ) { p . RLock ( ) conn , ok : = p . get Active Conn Locked ( ) p . RUnlock ( ) return conn , ok } 
func ( p * Peer ) Get Connection ( ctx context . Context ) ( * Connection , error ) { if active Conn , ok : = p . get Active Conn ( ) ; ok { return active Conn , nil } defer p . new Conn Lock . Unlock ( ) } } 
func ( p * Peer ) get Connection Relay ( timeout time . Duration ) ( * Connection , error ) { if conn , ok : = p . get Active Conn ( ) ; ok { return conn , nil } defer p . new Conn Lock . Unlock ( ) } defer cancel ( ) return p . Connect ( ctx ) } 
func ( p * Peer ) can Remove ( ) bool { p . RLock ( ) count : = len ( p . inbound Connections ) + len ( p . outbound Connections ) + int ( p . sc Count ) p . RUnlock ( ) return count = = 0 } 
func ( p * Peer ) add Connection ( c * Connection , direction connection Direction ) error { conns : = p . connections For ( direction ) if c . read State ( ) ! = connection Active { return Err Invalid Connection State } p . Lock ( ) * conns = append ( * conns , c ) p . Unlock ( ) return nil } 
func ( p * Peer ) remove Connection ( conns Ptr * [ ] * Connection , changed * Connection ) bool { conns : = * conns Ptr for i , c : = range conns { if c = = changed { conns [ i ] , conns [ last ] = conns [ last ] , nil * conns Ptr = conns [ : last ] return true } } return false } 
func ( p * Peer ) connection Close State Change ( changed * Connection ) { if changed . Is Active ( ) { return } p . Lock ( ) found : = p . remove Connection ( & p . inbound Connections , changed ) if ! found { found = p . remove Connection ( & p . outbound Connections , changed ) } p . Unlock ( ) if found { p . on Closed Conn Removed ( p ) } } 
func ( p * Peer ) Connect ( ctx context . Context ) ( * Connection , error ) { return p . channel . Connect ( ctx , p . host Port ) } 
func ( p * Peer ) Begin Call ( ctx context . Context , service Name , method Name string , call Options * Call Options ) ( * Outbound Call , error ) { if call Options = = nil { call Options = default Call Options } call Options . Request State . Add Selected Peer ( p . Host Port ( ) ) if err : = validate Call ( ctx , service Name , method Name , call Options ) ; err ! = nil { return nil , err } conn , err : = p . Get Connection ( ctx ) if err ! = nil { return nil , err } call , err : = conn . begin Call ( ctx , service Name , method Name , call Options ) if err ! = nil { return nil , err } return call , err } 
func ( p * Peer ) Num Connections ( ) ( inbound int , outbound int ) { p . RLock ( ) inbound = len ( p . inbound Connections ) outbound = len ( p . outbound Connections ) p . RUnlock ( ) return inbound , outbound } 
func ( p * Peer ) Num Pending Outbound ( ) int { count : = 0 p . RLock ( ) for _ , c : = range p . outbound Connections { count + = c . outbound . count ( ) } for _ , c : = range p . inbound Connections { count + = c . outbound . count ( ) } p . RUnlock ( ) return count } 
func is Ephemeral Host Port ( host Port string ) bool { return host Port = = " " | | host Port = = ephemeral Host Port | | strings . Has Suffix ( host Port , " " ) } 
func ( h * kv Handler ) Get ( ctx thrift . Context , key string ) ( string , error ) { if err : = is Valid Key ( key ) ; err ! = nil { return " " , err } h . RLock ( ) defer h . RUnlock ( ) if val , ok : = h . vals [ key ] ; ok { return val , nil } return " " , & keyvalue . Key Not Found { Key : key } } 
func ( h * kv Handler ) Set ( ctx thrift . Context , key , value string ) error { if err : = is Valid Key ( key ) ; err ! = nil { return err } h . Lock ( ) defer h . Unlock ( ) h . vals [ key ] = value return nil } 
func ( h * kv Handler ) Clear All ( ctx thrift . Context ) error { if ! is Admin ( ctx ) { return & keyvalue . Not Authorized { } } h . Lock ( ) defer h . Unlock ( ) h . vals = make ( map [ string ] string ) return nil } 
func ( ccc channel Connection Common ) Tracer ( ) opentracing . Tracer { if ccc . tracer ! = nil { return ccc . tracer } return opentracing . Global Tracer ( ) } 
func New Channel ( service Name string , opts * Channel Options ) ( * Channel , error ) { if service Name = = " " { return nil , Err No Service Name } if opts = = nil { opts = & Channel Options { } } process Name : = opts . Process Name if process Name = = " " { process Name = fmt . Sprintf ( " " , filepath . Base ( os . Args [ 0 ] ) , os . Getpid ( ) ) } logger : = opts . Logger if logger = = nil { logger = Null Logger } stats Reporter : = opts . Stats Reporter if stats Reporter = = nil { stats Reporter = Null Stats Reporter } time Now : = opts . Time Now if time Now = = nil { time Now = time . Now } time Ticker : = opts . Time Ticker if time Ticker = = nil { time Ticker = time . New Ticker } ch ID : = _next Ch ID . Inc ( ) logger = logger . With Fields ( Log Field { " " , service Name } , Log Field { " " , process Name } , Log Field { " " , ch ID } , ) if err : = opts . validate Idle Check ( ) ; err ! = nil { return nil , err } ch : = & Channel { channel Connection Common : channel Connection Common { log : logger , relay Local : to String Set ( opts . Relay Local Handlers ) , stats Reporter : stats Reporter , sub Channels : & sub Channel Map { } , time Now : time Now , time Ticker : time Ticker , tracer : opts . Tracer , } , ch ID : ch ID , connection Options : opts . Default Connection Options . with Defaults ( ) , relay Host : opts . Relay Host , relay Max Timeout : validate Relay Max Timeout ( opts . Relay Max Timeout , logger ) , relay Timer Verify : opts . Relay Timer Verification , closed : make ( chan struct { } ) , } ch . peers = new Root Peer List ( ch , opts . On Peer Status Changed ) . new Child ( ) if opts . Handler ! = nil { ch . handler = opts . Handler } else { ch . handler = channel Handler { ch } } ch . mutable . peer Info = Local Peer Info { Peer Info : Peer Info { Process Name : process Name , Host Port : ephemeral Host Port , Is Ephemeral : true , Version : Peer Version { Language : " " , Language Version : strings . Trim Prefix ( runtime . Version ( ) , " " ) , TChannel Version : Version Info , } , } , Service Name : service Name , } ch . mutable . state = Channel Client ch . mutable . conns = make ( map [ uint 3 2 ] * Connection ) ch . create Common Stats ( ) } register New Channel ( ch ) if opts . Relay Host ! = nil { opts . Relay Host . Set Channel ( ch ) } return ch , nil } 
func ( ch * Channel ) Serve ( l net . Listener ) error { mutable : = & ch . mutable mutable . Lock ( ) defer mutable . Unlock ( ) if mutable . l ! = nil { return err Already Listening } mutable . l = tnet . Wrap ( l ) if mutable . state ! = Channel Client { return err Invalid State For Op } mutable . state = Channel Listening mutable . peer Info . Host Port = l . Addr ( ) . String ( ) mutable . peer Info . Is Ephemeral = false ch . log = ch . log . With Fields ( Log Field { " " , mutable . peer Info . Host Port } ) ch . log . Info ( " " ) go ch . serve ( ) return nil } 
func ( ch * Channel ) Listen And Serve ( host Port string ) error { mutable : = & ch . mutable mutable . RLock ( ) if mutable . l ! = nil { mutable . RUnlock ( ) return err Already Listening } l , err : = net . Listen ( " " , host Port ) if err ! = nil { mutable . RUnlock ( ) return err } mutable . RUnlock ( ) return ch . Serve ( l ) } 
func ( ch * Channel ) Register ( h Handler , method Name string ) { if _ , ok : = ch . handler . ( channel Handler ) ; ! ok { panic ( " " ) } ch . Get Sub Channel ( ch . Peer Info ( ) . Service Name ) . Register ( h , method Name ) } 
func ( ch * Channel ) Peer Info ( ) Local Peer Info { ch . mutable . RLock ( ) peer Info : = ch . mutable . peer Info ch . mutable . RUnlock ( ) return peer Info } 
func ( ch * Channel ) Get Sub Channel ( service Name string , opts . . . Sub Channel Option ) * Sub Channel { sub , added : = ch . sub Channels . get Or Add ( service Name , ch ) if added { for _ , opt : = range opts { opt ( sub ) } } return sub } 
func ( ch * Channel ) Begin Call ( ctx context . Context , host Port , service Name , method Name string , call Options * Call Options ) ( * Outbound Call , error ) { p : = ch . Root Peers ( ) . Get Or Add ( host Port ) return p . Begin Call ( ctx , service Name , method Name , call Options ) } 
func ( ch * Channel ) serve ( ) { accept Backoff : = 0 * time . Millisecond for { net Conn , err : = ch . mutable . l . Accept ( ) if err ! = nil { } else { accept Backoff * = 2 } if max : = 1 * time . Second ; accept Backoff > max { accept Backoff = max } ch . log . With Fields ( Err Field ( err ) , Log Field { " " , accept Backoff } , ) . Warn ( " " ) time . Sleep ( accept Backoff ) continue } else { } ch . log . With Fields ( Err Field ( err ) ) . Fatal ( " " ) return } } accept Backoff = 0 if _ , err : = ch . inbound Handshake ( context . Background ( ) , net Conn , events ) ; err ! = nil { net Conn . Close ( ) } } ( ) } } 
func ( ch * Channel ) Ping ( ctx context . Context , host Port string ) error { peer : = ch . Root Peers ( ) . Get Or Add ( host Port ) conn , err : = peer . Get Connection ( ctx ) if err ! = nil { return err } return conn . ping ( ctx ) } 
func ( ch * Channel ) Stats Tags ( ) map [ string ] string { m : = make ( map [ string ] string ) for k , v : = range ch . common Stats Tags { m [ k ] = v } return m } 
func ( ch * Channel ) Connect ( ctx context . Context , host Port string ) ( * Connection , error ) { switch state : = ch . State ( ) ; state { case Channel Client , Channel Listening : break default : ch . log . Debugf ( " " , state ) return nil , err Invalid State For Op } ctx , cancel = context . With Timeout ( ctx , params . connect Timeout ) defer cancel ( ) } events : = connection Events { On Active : ch . outbound Connection Active , On Close State Change : ch . connection Close State Change , On Exchange Updated : ch . exchange Updated , } if err : = ctx . Err ( ) ; err ! = nil { return nil , Get Context Error ( err ) } timeout : = get Timeout ( ctx ) tcp Conn , err : = dial Context ( ctx , host Port ) if err ! = nil { if ne , ok : = err . ( net . Error ) ; ok & & ne . Timeout ( ) { ch . log . With Fields ( Log Field { " " , host Port } , Log Field { " " , timeout } , ) . Info ( " " ) err = Err Timeout } else if ctx . Err ( ) = = context . Canceled { ch . log . With Fields ( Log Field { " " , host Port } , ) . Info ( " " ) err = Get Context Error ( Err Request Cancelled ) } else { ch . log . With Fields ( Err Field ( err ) , Log Field { " " , host Port } , ) . Info ( " " ) } return nil , err } conn , err : = ch . outbound Handshake ( ctx , tcp Conn , host Port , events ) if conn ! = nil { ch . add Connection To Peer ( host Port , conn , outbound ) } } return conn , err } 
func ( ch * Channel ) exchange Updated ( c * Connection ) { if c . remote Peer Info . Host Port = = " " { } p , ok : = ch . Root Peers ( ) . Get ( c . remote Peer Info . Host Port ) if ! ok { return } ch . update Peer ( p ) } 
func ( ch * Channel ) update Peer ( p * Peer ) { ch . peers . on Peer Change ( p ) ch . sub Channels . update Peer ( p ) p . call On Update Complete ( ) } 
func ( ch * Channel ) add Connection ( c * Connection , direction connection Direction ) bool { ch . mutable . Lock ( ) defer ch . mutable . Unlock ( ) if c . read State ( ) ! = connection Active { return false } switch state : = ch . mutable . state ; state { case Channel Client , Channel Listening : break default : return false } ch . mutable . conns [ c . conn ID ] = c return true } 
func ( ch * Channel ) remove Closed Conn ( c * Connection ) { if c . read State ( ) ! = connection Closed { return } ch . mutable . Lock ( ) delete ( ch . mutable . conns , c . conn ID ) ch . mutable . Unlock ( ) } 
func ( ch * Channel ) connection Close State Change ( c * Connection ) { ch . remove Closed Conn ( c ) if peer , ok : = ch . Root Peers ( ) . Get ( c . remote Peer Info . Host Port ) ; ok { peer . connection Close State Change ( c ) ch . update Peer ( peer ) } if c . outbound HP ! = " " & & c . outbound HP ! = c . remote Peer Info . Host Port { ch . update Peer ( peer ) } } ch State : = ch . State ( ) if ch State ! = Channel Start Close & & ch State ! = Channel Inbound Closed { return } ch . mutable . RLock ( ) min State : = ch . get Min Connection State ( ) ch . mutable . RUnlock ( ) var update To Channel State if min State > = connection Closed { update To = Channel Closed } else if min State > = connection Inbound Closed & & ch State = = Channel Start Close { update To = Channel Inbound Closed } var updated To State Channel State if update To > 0 { ch . mutable . Lock ( ) updated To State = update To } ch . mutable . Unlock ( ) ch State = update To } c . log . Debugf ( " " , ch State , min State ) if updated To State = = Channel Closed { ch . on Closed ( ) } } 
func ( ch * Channel ) State ( ) Channel State { ch . mutable . RLock ( ) state : = ch . mutable . state ch . mutable . RUnlock ( ) return state } 
func ( ch * Channel ) Close ( ) { ch . Logger ( ) . Info ( " " ) var connections [ ] * Connection var channel Closed bool func ( ) { ch . mutable . Lock ( ) defer ch . mutable . Unlock ( ) if ch . mutable . state = = Channel Closed { ch . Logger ( ) . Info ( " " ) return } if ch . mutable . l ! = nil { ch . mutable . l . Close ( ) } ch . mutable . state = Channel Start Close if len ( ch . mutable . conns ) = = 0 { ch . mutable . state = Channel Closed channel Closed = true } for _ , c : = range ch . mutable . conns { connections = append ( connections , c ) } } ( ) for _ , c : = range connections { c . close ( Log Field { " " , " " } ) } if channel Closed { ch . on Closed ( ) } } 
func New Reader ( reader io . Reader ) * Reader { r : = reader Pool . Get ( ) . ( * Reader ) r . reader = reader r . err = nil return r } 
func ( r * Reader ) Read Uint 1 6 ( ) uint 1 6 { if r . err ! = nil { return 0 } buf : = r . buf [ : 2 ] var read N int read N , r . err = io . Read Full ( r . reader , buf ) if read N < 2 { return 0 } return binary . Big Endian . Uint 1 6 ( buf ) } 
func ( r * Reader ) Read String ( n int ) string { if r . err ! = nil { return " " } var buf [ ] byte if n < = max Pool String Len { buf = r . buf [ : n ] } else { buf = make ( [ ] byte , n ) } var read N int read N , r . err = io . Read Full ( r . reader , buf ) if read N < n { return " " } s : = string ( buf ) return s } 
func ( r * Reader ) Read Len 1 6String ( ) string { len : = r . Read Uint 1 6 ( ) return r . Read String ( int ( len ) ) } 
func ( b * Behavior ) Register ( ch * tchannel . Channel ) { b . register Thrift ( ch ) b . register JSON ( ch ) } 
func ( b * Behavior ) Run ( t crossdock . T ) { log Params ( t ) sampled , err : = strconv . Parse Bool ( t . Param ( sampled Param ) ) if err ! = nil { t . Fatalf ( " " , sampled Param , err ) } baggage : = random Baggage ( ) level 1 : = & Request { Server Role : Role S 1 , } server 1 : = t . Param ( server 1Name Param ) level 2 : = & Downstream { Service Name : t . Param ( server 2Name Param ) , Server Role : Role S 2 , Host Port : fmt . Sprintf ( " " , b . service To Host ( t . Param ( server 2Name Param ) ) , b . Server Port , ) , Encoding : t . Param ( server 2Encoding Param ) , } level 1 . Downstream = level 2 level 3 : = & Downstream { Service Name : t . Param ( server 3Name Param ) , Server Role : Role S 3 , Host Port : fmt . Sprintf ( " " , b . service To Host ( t . Param ( server 3Name Param ) ) , b . Server Port , ) , Encoding : t . Param ( server 3Encoding Param ) , } level 2 . Downstream = level 3 resp , err : = b . start Trace ( t , level 1 , sampled , baggage ) if err ! = nil { t . Errorf ( " " , server 1 , err . Error ( ) ) return } log . Printf ( " " , resp . Span , resp . Downstream ) trace ID : = resp . Span . Trace ID require : = crossdock . Require ( t ) require . Not Empty ( trace ID , " " , server 1 ) if validate Trace ( t , level 1 . Downstream , resp , server 1 , 1 , trace ID , sampled , baggage ) { t . Successf ( " " ) log . Println ( " " ) } else { log . Println ( " " ) } } 
func ( tp * relay Timer Pool ) Get ( ) * relay Timer { timer , ok : = tp . pool . Get ( ) . ( * relay Timer ) if ok { timer . released = false return timer } rt : = & relay Timer { pool : tp , } if ! rt . timer . Stop ( ) { panic ( " " ) } return rt } 
func ( tp * relay Timer Pool ) Put ( rt * relay Timer ) { if tp . verify { } tp . pool . Put ( rt ) } 
func ( rt * relay Timer ) Start ( d time . Duration , items * relay Items , id uint 3 2 , is Originator bool ) { rt . verify Not Released ( ) if rt . active { panic ( " " ) } rt . active = true rt . items = items rt . id = id rt . is Originator = is Originator if was Active : = rt . timer . Reset ( d ) ; was Active { panic ( " " ) } } 
func ( rt * relay Timer ) Stop ( ) bool { rt . verify Not Released ( ) stopped : = rt . timer . Stop ( ) if stopped { rt . mark Timer Inactive ( ) } return stopped } 
func ( rt * relay Timer ) Release ( ) { rt . verify Not Released ( ) if rt . active { panic ( " " ) } rt . released = true rt . pool . Put ( rt ) } 
func New Logger ( writer io . Writer , fields . . . Log Field ) Logger { return & writer Logger { writer , fields } } 
func New TCPFrame Relay ( dests [ ] string , modifier func ( bool , * tchannel . Frame ) * tchannel . Frame ) ( Relay , error ) { var err error r : = & tcp Frame Relay { modifier : modifier } r . tcp Relay , err = new TCPRelay ( dests , r . handle Conn Frame Relay ) if err ! = nil { return nil , err } return r , nil } 
func New Tally Reporter ( scope tally . Scope ) tchannel . Stats Reporter { return & wrapper { scope : scope , by Tags : make ( map [ known Tags ] * tagged Scope ) , } } 
func ( kt known Tags ) tally Tags ( ) map [ string ] string { tally Tags : = make ( map [ string ] string , 5 ) if kt . dest ! = " " { tally Tags [ " " ] = kt . dest } if kt . source ! = " " { tally Tags [ " " ] = kt . source } if kt . procedure ! = " " { tally Tags [ " " ] = kt . procedure } if kt . retry Count ! = " " { tally Tags [ " " ] = kt . retry Count } return tally Tags } 
func Isolated ( s * Sub Channel ) { s . Lock ( ) s . peers = s . top Channel . peers . new Sibling ( ) s . peers . Set Strategy ( new Least Pending Calculator ( ) ) s . Unlock ( ) } 
func ( c * Sub Channel ) Begin Call ( ctx context . Context , method Name string , call Options * Call Options ) ( * Outbound Call , error ) { if call Options = = nil { call Options = default Call Options } peer , err : = c . peers . Get ( call Options . Request State . Prev Selected Peers ( ) ) if err ! = nil { return nil , err } return peer . Begin Call ( ctx , c . Service Name ( ) , method Name , call Options ) } 
func ( c * Sub Channel ) Isolated ( ) bool { c . RLock ( ) defer c . RUnlock ( ) return c . top Channel . Peers ( ) ! = c . peers } 
func ( c * Sub Channel ) Register ( h Handler , method Name string ) { handlers , ok : = c . handler . ( * handler Map ) if ! ok { panic ( fmt . Sprintf ( " " , c . Service Name ( ) , ) ) } handlers . register ( h , method Name ) } 
func ( c * Sub Channel ) Get Handlers ( ) map [ string ] Handler { handlers , ok : = c . handler . ( * handler Map ) if ! ok { panic ( fmt . Sprintf ( " " , c . Service Name ( ) , ) ) } handlers . RLock ( ) handlers Map : = make ( map [ string ] Handler , len ( handlers . handlers ) ) for k , v : = range handlers . handlers { handlers Map [ k ] = v } handlers . RUnlock ( ) return handlers Map } 
func ( c * Sub Channel ) Stats Tags ( ) map [ string ] string { tags : = c . top Channel . Stats Tags ( ) tags [ " " ] = c . service Name return tags } 
func ( sub Ch Map * sub Channel Map ) register New Sub Channel ( service Name string , ch * Channel ) ( _ * Sub Channel , added bool ) { sub Ch Map . Lock ( ) defer sub Ch Map . Unlock ( ) if sub Ch Map . subchannels = = nil { sub Ch Map . subchannels = make ( map [ string ] * Sub Channel ) } if sc , ok : = sub Ch Map . subchannels [ service Name ] ; ok { return sc , false } sc : = new Sub Channel ( service Name , ch ) sub Ch Map . subchannels [ service Name ] = sc return sc , true } 
func ( sub Ch Map * sub Channel Map ) get ( service Name string ) ( * Sub Channel , bool ) { sub Ch Map . RLock ( ) sc , ok : = sub Ch Map . subchannels [ service Name ] sub Ch Map . RUnlock ( ) return sc , ok } 
func ( sub Ch Map * sub Channel Map ) get Or Add ( service Name string , ch * Channel ) ( _ * Sub Channel , added bool ) { if sc , ok : = sub Ch Map . get ( service Name ) ; ok { return sc , false } return sub Ch Map . register New Sub Channel ( service Name , ch ) } 
func ( c * Client ) Discover ( service Name string ) ( [ ] string , error ) { ctx , cancel : = thrift . New Context ( time . Second ) defer cancel ( ) result , err : = c . hyperbahn Client . Discover ( ctx , & hyperbahn . Discovery Query { Service Name : service Name } ) if err ! = nil { return nil , err } var host Ports [ ] string for _ , peer : = range result . Get Peers ( ) { host Ports = append ( host Ports , service Peer To Host Port ( peer ) ) } return host Ports , nil } 
func ( c * Client ) Start ( ) error { if err : = c . listen ( ) ; err ! = nil { return err } go func ( ) { http . Serve ( c . listener , c . mux ) } ( ) return nil } 
func ( c * Client ) listen ( ) error { c . set Default Port ( & c . Client Host Port , " " + common . Default Client Port HTTP ) c . set Default Port ( & c . Server Port , common . Default Server Port ) c . mux = http . New Serve Mux ( ) c . mux . Handle ( " " , crossdock . Handler ( c . Behaviors , true ) ) listener , err : = net . Listen ( " " , c . Client Host Port ) if err ! = nil { return err } c . listener = listener c . Client Host Port = listener . Addr ( ) . String ( ) return nil } 
func Write Request ( call tchannel . Arg Writable , req * http . Request ) error { wb . Write Len 8String ( req . Method ) write Varint String ( wb , req . URL . String ( ) ) write Headers ( wb , req . Header ) arg 2Writer , err : = call . Arg 2Writer ( ) if err ! = nil { return err } if _ , err : = wb . Flush To ( arg 2Writer ) ; err ! = nil { return err } if err : = arg 2Writer . Close ( ) ; err ! = nil { return err } arg 3Writer , err : = call . Arg 3Writer ( ) if err ! = nil { return err } if req . Body ! = nil { if _ , err = io . Copy ( arg 3Writer , req . Body ) ; err ! = nil { return err } } return arg 3Writer . Close ( ) } 
func Read Request ( call tchannel . Arg Readable ) ( * http . Request , error ) { var arg 2 [ ] byte if err : = tchannel . New Arg Reader ( call . Arg 2Reader ( ) ) . Read ( & arg 2 ) ; err ! = nil { return nil , err } rb : = typed . New Read Buffer ( arg 2 ) method : = rb . Read Len 8String ( ) url : = read Varint String ( rb ) r , err : = http . New Request ( method , url , nil ) if err ! = nil { return nil , err } read Headers ( rb , r . Header ) if err : = rb . Err ( ) ; err ! = nil { return nil , err } r . Body , err = call . Arg 3Reader ( ) return r , err } 
func New Read Buffer With Size ( size int ) * Read Buffer { return & Read Buffer { buffer : make ( [ ] byte , size ) , remaining : nil } } 
func ( r * Read Buffer ) Read Byte ( ) ( byte , error ) { if r . err ! = nil { return 0 , r . err } if len ( r . remaining ) < 1 { r . err = Err EOF return 0 , r . err } b : = r . remaining [ 0 ] r . remaining = r . remaining [ 1 : ] return b , nil } 
func ( r * Read Buffer ) Read Bytes ( n int ) [ ] byte { if r . err ! = nil { return nil } if len ( r . remaining ) < n { r . err = Err EOF return nil } b : = r . remaining [ 0 : n ] r . remaining = r . remaining [ n : ] return b } 
func ( r * Read Buffer ) Read String ( n int ) string { if b : = r . Read Bytes ( n ) ; b ! = nil { } return " " } 
func ( r * Read Buffer ) Read Uint 1 6 ( ) uint 1 6 { if b : = r . Read Bytes ( 2 ) ; b ! = nil { return binary . Big Endian . Uint 1 6 ( b ) } return 0 } 
func ( r * Read Buffer ) Read Uint 3 2 ( ) uint 3 2 { if b : = r . Read Bytes ( 4 ) ; b ! = nil { return binary . Big Endian . Uint 3 2 ( b ) } return 0 } 
func ( r * Read Buffer ) Read Uint 6 4 ( ) uint 6 4 { if b : = r . Read Bytes ( 8 ) ; b ! = nil { return binary . Big Endian . Uint 6 4 ( b ) } return 0 } 
func ( r * Read Buffer ) Read Uvarint ( ) uint 6 4 { v , _ : = binary . Read Uvarint ( r ) return v } 
func ( r * Read Buffer ) Read Len 8String ( ) string { n : = r . Read Single Byte ( ) return r . Read String ( int ( n ) ) } 
func ( r * Read Buffer ) Read Len 1 6String ( ) string { n : = r . Read Uint 1 6 ( ) return r . Read String ( int ( n ) ) } 
func ( r * Read Buffer ) Fill From ( ior io . Reader , n int ) ( int , error ) { if len ( r . buffer ) < n { return 0 , Err EOF } r . err = nil r . remaining = r . buffer [ : n ] return io . Read Full ( ior , r . remaining ) } 
func ( r * Read Buffer ) Wrap ( b [ ] byte ) { r . buffer = b r . remaining = b r . err = nil } 
func ( w * Write Buffer ) Write Single Byte ( n byte ) { if w . err ! = nil { return } if len ( w . remaining ) = = 0 { w . set Err ( Err Buffer Full ) return } w . remaining [ 0 ] = n w . remaining = w . remaining [ 1 : ] } 
func ( w * Write Buffer ) Write Bytes ( in [ ] byte ) { if b : = w . reserve ( len ( in ) ) ; b ! = nil { copy ( b , in ) } } 
func ( w * Write Buffer ) Write Uint 1 6 ( n uint 1 6 ) { if b : = w . reserve ( 2 ) ; b ! = nil { binary . Big Endian . Put Uint 1 6 ( b , n ) } } 
func ( w * Write Buffer ) Write Uint 3 2 ( n uint 3 2 ) { if b : = w . reserve ( 4 ) ; b ! = nil { binary . Big Endian . Put Uint 3 2 ( b , n ) } } 
func ( w * Write Buffer ) Write Uint 6 4 ( n uint 6 4 ) { if b : = w . reserve ( 8 ) ; b ! = nil { binary . Big Endian . Put Uint 6 4 ( b , n ) } } 
func ( w * Write Buffer ) Write Uvarint ( n uint 6 4 ) { var Bytes : = binary . Put Uvarint ( buf , n ) if b : = w . reserve ( var Bytes ) ; b ! = nil { copy ( b , buf [ 0 : var Bytes ] ) } } 
func ( w * Write Buffer ) Write String ( s string ) { } } 
func ( w * Write Buffer ) Write Len 8String ( s string ) { if int ( byte ( len ( s ) ) ) ! = len ( s ) { w . set Err ( err String Too Long ) } w . Write Single Byte ( byte ( len ( s ) ) ) w . Write String ( s ) } 
func ( w * Write Buffer ) Write Len 1 6String ( s string ) { if int ( uint 1 6 ( len ( s ) ) ) ! = len ( s ) { w . set Err ( err String Too Long ) } w . Write Uint 1 6 ( uint 1 6 ( len ( s ) ) ) w . Write String ( s ) } 
func ( w * Write Buffer ) Defer Byte ( ) Byte Ref { if len ( w . remaining ) = = 0 { w . set Err ( Err Buffer Full ) return Byte Ref ( nil ) } buf Ref : = Byte Ref ( w . remaining [ 0 : ] ) w . remaining = w . remaining [ 1 : ] return buf Ref } 
func ( w * Write Buffer ) Defer Bytes ( n int ) Bytes Ref { return Bytes Ref ( w . deferred ( n ) ) } 
func ( w * Write Buffer ) Flush To ( iow io . Writer ) ( int , error ) { dirty : = w . buffer [ 0 : w . Bytes Written ( ) ] return iow . Write ( dirty ) } 
func ( w * Write Buffer ) Reset ( ) { w . remaining = w . buffer w . err = nil } 
func ( w * Write Buffer ) Wrap ( b [ ] byte ) { w . buffer = b w . remaining = b } 
func ( ref Uint 1 6Ref ) Update ( n uint 1 6 ) { if ref ! = nil { binary . Big Endian . Put Uint 1 6 ( ref , n ) } } 
func ( ref Uint 3 2Ref ) Update ( n uint 3 2 ) { if ref ! = nil { binary . Big Endian . Put Uint 3 2 ( ref , n ) } } 
func ( ref Uint 6 4Ref ) Update ( n uint 6 4 ) { if ref ! = nil { binary . Big Endian . Put Uint 6 4 ( ref , n ) } } 
func ( ref Bytes Ref ) Update ( b [ ] byte ) { if ref ! = nil { copy ( ref , b ) } } 
func ( ref Bytes Ref ) Update String ( s string ) { if ref ! = nil { copy ( ref , s ) } } 
func ( r * fragmenting Reader ) Arg Reader ( last bool ) ( Arg Reader , error ) { if err : = r . Begin Argument ( last ) ; err ! = nil { return nil , err } return r , nil } 
func ( f * writable Fragment ) finish ( has More Fragments bool ) { f . checksum Ref . Update ( f . checksum . Sum ( ) ) if has More Fragments { f . flags Ref . Update ( has More Fragments Flag ) } else { f . checksum . Release ( ) } } 
func new Writable Chunk ( checksum Checksum , contents * typed . Write Buffer ) * writable Chunk { return & writable Chunk { size : 0 , size Ref : contents . Defer Uint 1 6 ( ) , checksum : checksum , contents : contents , } } 
func ( c * writable Chunk ) write As Fits ( b [ ] byte ) int { if len ( b ) > c . contents . Bytes Remaining ( ) { b = b [ : c . contents . Bytes Remaining ( ) ] } c . checksum . Add ( b ) c . contents . Write Bytes ( b ) written : = len ( b ) c . size + = uint 1 6 ( written ) return written } 
func new Fragmenting Writer ( logger Logger , sender fragment Sender , checksum Checksum ) * fragmenting Writer { return & fragmenting Writer { logger : logger , sender : sender , checksum : checksum , state : fragmenting Write Start , } } 
func ( w * fragmenting Writer ) Arg Writer ( last bool ) ( Arg Writer , error ) { if err : = w . Begin Argument ( last ) ; err ! = nil { return nil , err } return w , nil } 
func ( w * fragmenting Writer ) Begin Argument ( last bool ) error { if w . err ! = nil { return w . err } switch { case w . state = = fragmenting Write Complete : w . err = err Complete return w . err case w . state . is Writing Argument ( ) : w . err = err Already Writing Argument return w . err } if w . cur Fragment , w . err = w . sender . new Fragment ( initial , w . checksum ) ; w . err ! = nil { return w . err } } } w . cur Chunk = new Writable Chunk ( w . checksum , w . cur Fragment . contents ) w . state = fragmenting Write In Argument if last { w . state = fragmenting Write In Last Argument } return nil } 
func ( w * fragmenting Writer ) Write ( b [ ] byte ) ( int , error ) { if w . err ! = nil { return 0 , w . err } if ! w . state . is Writing Argument ( ) { w . err = err Not Writing Argument return 0 , w . err } total Written : = 0 for { bytes Written : = w . cur Chunk . write As Fits ( b ) total Written + = bytes Written if bytes Written = = len ( b ) { } } b = b [ bytes Written : ] } } 
func ( w * fragmenting Writer ) Flush ( ) error { w . cur Chunk . finish ( ) w . cur Fragment . finish ( true ) if w . err = w . sender . flush Fragment ( w . cur Fragment ) ; w . err ! = nil { return w . err } if w . cur Fragment , w . err = w . sender . new Fragment ( false , w . checksum ) ; w . err ! = nil { return w . err } w . cur Chunk = new Writable Chunk ( w . checksum , w . cur Fragment . contents ) return nil } 
func ( w * fragmenting Writer ) Close ( ) error { last : = w . state = = fragmenting Write In Last Argument if w . err ! = nil { return w . err } if ! w . state . is Writing Argument ( ) { w . err = err Not Writing Argument return w . err } w . cur Chunk . finish ( ) w . cur Fragment . finish ( false ) w . err = w . sender . flush Fragment ( w . cur Fragment ) w . sender . done Sending ( ) return w . err } w . state = fragmenting Write Waiting For Argument if w . cur Fragment . contents . Bytes Remaining ( ) > chunk Header Size { } if w . err = w . sender . flush Fragment ( w . cur Fragment ) ; w . err ! = nil { return w . err } if w . cur Fragment , w . err = w . sender . new Fragment ( false , w . checksum ) ; w . err ! = nil { return w . err } return nil } 
func ( c * Connection ) begin Call ( ctx context . Context , service Name , method Name string , call Options * Call Options ) ( * Outbound Call , error ) { now : = c . time Now ( ) switch state : = c . read State ( ) ; state { case connection Active : break case connection Start Close , connection Inbound Closed , connection Closed : return nil , Err Connection Closed default : return nil , err Connection Unknown State { " " , state } } deadline , ok : = ctx . Deadline ( ) if ! ok { } if time To Live < time . Millisecond { return nil , Err Timeout } if err : = ctx . Err ( ) ; err ! = nil { return nil , Get Context Error ( err ) } request ID : = c . Next Message ID ( ) mex , err : = c . outbound . new Exchange ( ctx , c . opts . Frame Pool , message Type Call Req , request ID , mex Channel Buffer Size ) if err ! = nil { return nil , err } return nil , Err Connection Closed } call Options . set Headers ( headers ) if opts : = current Call Options ( ctx ) ; opts ! = nil { opts . override Headers ( headers ) } call : = new ( Outbound Call ) call . mex = mex call . conn = c call . call Req = call Req { id : request ID , Headers : headers , Service : service Name , Time To Live : time To Live , } call . stats Reporter = c . stats Reporter call . create Stats Tags ( c . common Stats Tags , call Options , method Name ) call . log = c . log . With Fields ( Log Field { " " , request ID } ) } return new ( call Req Continue ) } call . contents = new Fragmenting Writer ( call . log , call , c . opts . Checksum Type . New ( ) ) response : = new ( Outbound Call Response ) response . started At = now response . time Now = c . time Now response . request State = call Options . Request State response . mex = mex response . log = c . log . With Fields ( Log Field { " " , request ID } ) response . span = c . start Outbound Span ( ctx , service Name , method Name , call , now ) response . message For Fragment = func ( initial bool ) message { if initial { return & response . call Res } return new ( call Res Continue ) } response . contents = new Fragmenting Reader ( response . log , response ) response . stats Reporter = call . stats Reporter response . common Stats Tags = call . common Stats Tags call . response = response if err : = call . write Method ( [ ] byte ( method Name ) ) ; err ! = nil { return nil , err } return call , nil } 
func ( c * Connection ) handle Call Res ( frame * Frame ) bool { if err : = c . outbound . forward Peer Frame ( frame ) ; err ! = nil { return true } return false } 
func ( call * Outbound Call ) create Stats Tags ( connection Tags map [ string ] string , call Options * Call Options , method string ) { call . common Stats Tags = map [ string ] string { " " : call . call Req . Service , } for k , v : = range connection Tags { call . common Stats Tags [ k ] = v } if call Options . Format ! = HTTP { call . common Stats Tags [ " " ] = string ( method ) } } 
func ( call * Outbound Call ) write Method ( method [ ] byte ) error { call . stats Reporter . Inc Counter ( " " , call . common Stats Tags , 1 ) return New Arg Writer ( call . arg 1Writer ( ) ) . Write ( method ) } 
func ( response * Outbound Call Response ) Arg 2Reader ( ) ( Arg Reader , error ) { var method [ ] byte if err : = New Arg Reader ( response . arg 1Reader ( ) ) . Read ( & method ) ; err ! = nil { return nil , err } return response . arg 2Reader ( ) } 
func ( c * Connection ) handle Error ( frame * Frame ) bool { err Msg : = error Message { id : frame . Header . ID , } rbuf : = typed . New Read Buffer ( frame . Sized Payload ( ) ) if err : = err Msg . read ( rbuf ) ; err ! = nil { c . log . With Fields ( Log Field { " " , c . remote Peer Info } , Err Field ( err ) , ) . Warn ( " " ) c . connection Error ( " " , err ) return true } if err Msg . err Code = = Err Code Protocol { c . log . With Fields ( Log Field { " " , c . remote Peer Info } , Log Field { " " , err Msg . message } , ) . Warn ( " " ) c . connection Error ( " " , err Msg . As System Error ( ) ) return true } if err : = c . outbound . forward Peer Frame ( frame ) ; err ! = nil { c . log . With Fields ( Log Field { " " , frame . Header . String ( ) } , Log Field { " " , err Msg . id } , Log Field { " " , err Msg . message } , Log Field { " " , err Msg . err Code } , Err Field ( err ) , ) . Info ( " " ) return true } } 
func ( response * Outbound Call Response ) done Reading ( unexpected error ) { now : = response . time Now ( ) is Success : = unexpected = = nil & & ! response . Application Error ( ) last Attempt : = is Success | | ! response . request State . Has Retries ( unexpected ) } if ! is Success & & last Attempt { ext . Error . Set ( span , true ) } span . Finish With Options ( opentracing . Finish Options { Finish Time : now } ) } latency : = now . Sub ( response . started At ) response . stats Reporter . Record Timer ( " " , response . common Stats Tags , latency ) if last Attempt { request Latency : = response . request State . Since Start ( now , latency ) response . stats Reporter . Record Timer ( " " , response . common Stats Tags , request Latency ) } if retry Count : = response . request State . Retry Count ( ) ; retry Count > 0 { retry Tags : = clone Tags ( response . common Stats Tags ) retry Tags [ " " ] = fmt . Sprint ( retry Count ) response . stats Reporter . Inc Counter ( " " , retry Tags , 1 ) } if unexpected ! = nil { if last Attempt { response . stats Reporter . Inc Counter ( " " , response . common Stats Tags , 1 ) } } else { response . stats Reporter . Inc Counter ( " " , response . common Stats Tags , 1 ) } response . mex . shutdown ( ) } 
func ( w * req Res Writer ) arg Writer ( last bool , in State req Res Writer State , out State req Res Writer State ) ( Arg Writer , error ) { if w . err ! = nil { return nil , w . err } if w . state ! = in State { return nil , w . failed ( err Req Res Writer State Mismatch { state : w . state , expected State : in State } ) } arg Writer , err : = w . contents . Arg Writer ( last ) if err ! = nil { return nil , w . failed ( err ) } w . state = out State return arg Writer , nil } 
func ( w * req Res Writer ) new Fragment ( initial bool , checksum Checksum ) ( * writable Fragment , error ) { if err : = w . mex . check Error ( ) ; err ! = nil { return nil , w . failed ( err ) } message : = w . message For Fragment ( initial ) frame . Header . ID = w . mex . msg ID frame . Header . message Type = message . message Type ( ) fragment : = new ( writable Fragment ) fragment . frame = frame fragment . flags Ref = wbuf . Defer Byte ( ) if err : = message . write ( wbuf ) ; err ! = nil { return nil , err } wbuf . Write Single Byte ( byte ( checksum . Type Code ( ) ) ) fragment . checksum Ref = wbuf . Defer Bytes ( checksum . Size ( ) ) fragment . checksum = checksum fragment . contents = wbuf return fragment , wbuf . Err ( ) } 
func ( w * req Res Writer ) flush Fragment ( fragment * writable Fragment ) error { if w . err ! = nil { return w . err } frame : = fragment . frame . ( * Frame ) frame . Header . Set Payload Size ( uint 1 6 ( fragment . contents . Bytes Written ( ) ) ) if err : = w . mex . check Error ( ) ; err ! = nil { return w . failed ( err ) } select { case < - w . mex . ctx . Done ( ) : return w . failed ( Get Context Error ( w . mex . ctx . Err ( ) ) ) case < - w . mex . err Ch . c : return w . failed ( w . mex . err Ch . err ) case w . conn . send Ch < - frame : return nil } } 
func ( w * req Res Writer ) failed ( err error ) error { w . log . Debugf ( " " , err , w . err ) if w . err ! = nil { return w . err } w . mex . shutdown ( ) w . err = err return w . err } 
func ( r * req Res Reader ) arg 1Reader ( ) ( Arg Reader , error ) { return r . arg Reader ( false , req Res Reader Pre Arg 1 , req Res Reader Pre Arg 2 ) } 
func ( r * req Res Reader ) arg 2Reader ( ) ( Arg Reader , error ) { return r . arg Reader ( false , req Res Reader Pre Arg 2 , req Res Reader Pre Arg 3 ) } 
func ( r * req Res Reader ) arg 3Reader ( ) ( Arg Reader , error ) { return r . arg Reader ( true , req Res Reader Pre Arg 3 , req Res Reader Complete ) } 
func ( r * req Res Reader ) arg Reader ( last bool , in State req Res Reader State , out State req Res Reader State ) ( Arg Reader , error ) { if r . state ! = in State { return nil , r . failed ( err Req Res Reader State Mismatch { state : r . state , expected State : in State } ) } arg Reader , err : = r . contents . Arg Reader ( last ) if err ! = nil { return nil , r . failed ( err ) } r . state = out State return arg Reader , nil } 
func ( r * req Res Reader ) recv Next Fragment ( initial bool ) ( * readable Fragment , error ) { if r . initial Fragment ! = nil { fragment : = r . initial Fragment r . initial Fragment = nil r . previous Fragment = fragment return fragment , nil } frame , err : = r . mex . recv Peer Frame Of Type ( message . message Type ( ) ) if err ! = nil { if err , ok : = err . ( error Message ) ; ok { return nil , err } return nil , r . failed ( err ) } if err ! = nil { return nil , r . failed ( err ) } r . previous Fragment = fragment return fragment , nil } 
func ( r * req Res Reader ) release Previous Fragment ( ) { fragment : = r . previous Fragment r . previous Fragment = nil if fragment ! = nil { fragment . done ( ) } } 
func ( r * req Res Reader ) failed ( err error ) error { r . log . Debugf ( " " , err , r . err ) if r . err ! = nil { return r . err } r . mex . shutdown ( ) r . err = err return r . err } 
func parse Inbound Fragment ( frame Pool Frame Pool , frame * Frame , message message ) ( * readable Fragment , error ) { rbuf : = typed . New Read Buffer ( frame . Sized Payload ( ) ) fragment : = new ( readable Fragment ) fragment . flags = rbuf . Read Single Byte ( ) if err : = message . read ( rbuf ) ; err ! = nil { return nil , err } fragment . checksum Type = Checksum Type ( rbuf . Read Single Byte ( ) ) fragment . checksum = rbuf . Read Bytes ( fragment . checksum Type . Checksum Size ( ) ) fragment . contents = rbuf fragment . on Done = func ( ) { frame Pool . Release ( frame ) } return fragment , rbuf . Err ( ) } 
func New Context ( timeout time . Duration ) ( Context , context . Cancel Func ) { ctx , cancel : = tchannel . New Context ( timeout ) return Wrap ( ctx ) , cancel } 
func With Headers ( ctx context . Context , headers map [ string ] string ) Context { return tchannel . Wrap With Headers ( ctx , headers ) } 
func ( c * Connection ) health Check ( conn ID uint 3 2 ) { defer close ( c . health Check Done ) opts : = c . opts . Health Checks ticker : = c . time Ticker ( opts . Interval ) defer ticker . Stop ( ) consecutive Failures : = 0 for { select { case < - ticker . C : case < - c . health Check Ctx . Done ( ) : return } ctx , cancel : = context . With Timeout ( c . health Check Ctx , opts . Timeout ) err : = c . ping ( ctx ) cancel ( ) c . health Check History . add ( err = = nil ) if err = = nil { if c . log . Enabled ( Log Level Debug ) { c . log . Debug ( " " ) } consecutive Failures = 0 continue } return } consecutive Failures + + c . log . With Fields ( Log Fields { { " " , consecutive Failures } , Err Field ( err ) , { " " , opts . Failures To Close } , } . . . ) . Warn ( " " ) if consecutive Failures > = opts . Failures To Close { c . close ( Log Fields { { " " , " " } , Err Field ( err ) , } . . . ) return } } } 
func ( cb * Context Builder ) Set Timeout ( timeout time . Duration ) * Context Builder { cb . Timeout = timeout return cb } 
func ( cb * Context Builder ) Add Header ( key , value string ) * Context Builder { if cb . Headers = = nil { cb . Headers = map [ string ] string { key : value } } else { cb . Headers [ key ] = value } return cb } 
func ( cb * Context Builder ) Set Headers ( headers map [ string ] string ) * Context Builder { cb . Headers = headers cb . replace Parent Headers = true return cb } 
func ( cb * Context Builder ) Set Shard Key ( sk string ) * Context Builder { if cb . Call Options = = nil { cb . Call Options = new ( Call Options ) } cb . Call Options . Shard Key = sk return cb } 
func ( cb * Context Builder ) Set Format ( f Format ) * Context Builder { if cb . Call Options = = nil { cb . Call Options = new ( Call Options ) } cb . Call Options . Format = f return cb } 
func ( cb * Context Builder ) Set Routing Key ( rk string ) * Context Builder { if cb . Call Options = = nil { cb . Call Options = new ( Call Options ) } cb . Call Options . Routing Key = rk return cb } 
func ( cb * Context Builder ) Set Routing Delegate ( rd string ) * Context Builder { if cb . Call Options = = nil { cb . Call Options = new ( Call Options ) } cb . Call Options . Routing Delegate = rd return cb } 
func ( cb * Context Builder ) Set Connect Timeout ( d time . Duration ) * Context Builder { cb . Connect Timeout = d return cb } 
func ( cb * Context Builder ) Set Retry Options ( retry Options * Retry Options ) * Context Builder { cb . Retry Options = retry Options return cb } 
func ( cb * Context Builder ) Set Timeout Per Attempt ( timeout Per Attempt time . Duration ) * Context Builder { if cb . Retry Options = = nil { cb . Retry Options = & Retry Options { } } cb . Retry Options . Timeout Per Attempt = timeout Per Attempt return cb } 
func ( cb * Context Builder ) Set Parent Context ( ctx context . Context ) * Context Builder { cb . Parent Context = ctx return cb } 
func ( cb * Context Builder ) Build ( ) ( Context With Headers , context . Cancel Func ) { params : = & tchannel Ctx Params { options : cb . Call Options , call : cb . incoming Call , retry Options : cb . Retry Options , connect Timeout : cb . Connect Timeout , hide Listening On Outbound : cb . hide Listening On Outbound , tracing Disabled : cb . Tracing Disabled , } parent : = cb . Parent Context if parent = = nil { parent = context . Background ( ) } else if header Ctx , ok : = parent . ( header Ctx ) ; ok { } var ( ctx context . Context cancel context . Cancel Func ) if cb . Timeout = = 0 & & parent Has Deadline { ctx , cancel = context . With Cancel ( parent ) } else { ctx , cancel = context . With Timeout ( parent , cb . Timeout ) } ctx = context . With Value ( ctx , context Key TChannel , params ) return Wrap With Headers ( ctx , cb . get Headers ( ) ) , cancel } 
func ( c * Call Options ) override Headers ( headers transport Headers ) { if c . Format ! = " " { headers [ Arg Scheme ] = c . Format . String ( ) } if c . Shard Key ! = " " { headers [ Shard Key ] = c . Shard Key } if c . Routing Key ! = " " { headers [ Routing Key ] = c . Routing Key } if c . Routing Delegate ! = " " { headers [ Routing Delegate ] = c . Routing Delegate } if c . caller Name ! = " " { headers [ Caller Name ] = c . caller Name } } 
func ( r Arg Read Helper ) Read ( bs * [ ] byte ) error { return r . read ( func ( ) error { var err error * bs , err = ioutil . Read All ( r . reader ) return err } ) } 
func ( r Arg Read Helper ) Read JSON ( data interface { } ) error { return r . read ( func ( ) error { if _ , err : = reader . Peek ( 1 ) ; err = = io . EOF { } else if err ! = nil { return err } d : = json . New Decoder ( reader ) return d . Decode ( data ) } ) } 
func New Arg Writer ( writer io . Write Closer , err error ) Arg Write Helper { return Arg Write Helper { writer , err } } 
func ( w Arg Write Helper ) Write ( bs [ ] byte ) error { return w . write ( func ( ) error { _ , err : = w . writer . Write ( bs ) return err } ) } 
func ( w Arg Write Helper ) Write JSON ( data interface { } ) error { return w . write ( func ( ) error { e : = json . New Encoder ( w . writer ) return e . Encode ( data ) } ) } 
func Register ( registrar tchannel . Registrar ) { handler : = func ( ctx context . Context , call * tchannel . Inbound Call ) { req , err : = thttp . Read Request ( call ) if err ! = nil { registrar . Logger ( ) . With Fields ( tchannel . Log Field { Key : " " , Value : err . Error ( ) } , ) . Warn ( " " ) return } serve HTTP ( req , call . Response ( ) ) } registrar . Register ( tchannel . Handler Func ( handler ) , " " ) } 
func ( r * relay Items ) Count ( ) int { r . RLock ( ) n : = len ( r . items ) - int ( r . tombs ) r . RUnlock ( ) return n } 
func ( r * relay Items ) Get ( id uint 3 2 ) ( relay Item , bool ) { r . RLock ( ) item , ok : = r . items [ id ] r . RUnlock ( ) return item , ok } 
func ( r * relay Items ) Add ( id uint 3 2 , item relay Item ) { r . Lock ( ) r . items [ id ] = item r . Unlock ( ) } 
func ( r * relay Items ) Delete ( id uint 3 2 ) ( relay Item , bool ) { r . Lock ( ) item , ok : = r . items [ id ] if ! ok { r . Unlock ( ) r . logger . With Fields ( Log Field { " " , id } ) . Warn ( " " ) return item , false } delete ( r . items , id ) if item . tomb { r . tombs - - } r . Unlock ( ) item . timeout . Stop ( ) item . timeout . Release ( ) return item , ! item . tomb } 
func ( r * relay Items ) Entomb ( id uint 3 2 , delete After time . Duration ) ( relay Item , bool ) { r . Lock ( ) if r . tombs > _max Relay Tombs { r . Unlock ( ) r . logger . With Fields ( Log Field { " " , id } ) . Warn ( " " ) return r . Delete ( id ) } item , ok : = r . items [ id ] if ! ok { r . Unlock ( ) r . logger . With Fields ( Log Field { " " , id } ) . Warn ( " " ) return item , false } if item . tomb { r . Unlock ( ) r . logger . With Fields ( Log Field { " " , id } ) . Warn ( " " ) return item , false } r . tombs + + item . tomb = true r . items [ id ] = item r . Unlock ( ) return item , true } 
func New Relayer ( ch * Channel , conn * Connection ) * Relayer { r : = & Relayer { relay Host : ch . Relay Host ( ) , max Timeout : ch . relay Max Timeout , local Handler : ch . relay Local , outbound : new Relay Items ( conn . log . With Fields ( Log Field { " " , " " } ) ) , inbound : new Relay Items ( conn . log . With Fields ( Log Field { " " , " " } ) ) , peers : ch . Root Peers ( ) , conn : conn , relay Conn : & relay . Conn { Remote Addr : conn . conn . Remote Addr ( ) . String ( ) , Remote Process Name : conn . Remote Peer Info ( ) . Process Name , Is Outbound : conn . conn Direction = = outbound , } , logger : conn . log , } r . timeouts = new Relay Timer Pool ( r . timeout Relay Item , ch . relay Timer Verify ) return r } 
func ( r * Relayer ) Relay ( f * Frame ) error { if f . message Type ( ) ! = message Type Call Req { err : = r . handle Non Call Req ( f ) if err = = err Unknown ID { } } return err } return r . handle Call Req ( new Lazy Call Req ( f ) ) } 
func ( r * Relayer ) Receive ( f * Frame , f Type frame Type ) ( sent bool , failure Reason string ) { id : = f . Header . ID item , ok : = items . Get ( id ) if ! ok { r . logger . With Fields ( Log Field { " " , id } , ) . Warn ( " " ) return false , _relay Error Not Found } finished : = finishes Call ( f ) if item . tomb { } } else if len ( fail Msg ) > 0 { item . call . Failed ( fail Msg ) } } select { case r . conn . send Ch < - f : default : items : = r . receiver Items ( f Type ) err : = _relay Error Dest Conn Slow } r . fail Relay Item ( items , id , err ) return false , err } if finished { r . finish Relay Item ( items , id ) } return true , " " } 
func ( r * Relayer ) handle Non Call Req ( f * Frame ) error { frame Type : = frame Type For ( f ) finished : = finishes Call ( f ) if frame Type = = response Frame { items = r . inbound } item , ok : = items . Get ( f . Header . ID ) if ! ok { return err Unknown ID } if item . tomb { } original ID : = f . Header . ID f . Header . ID = item . remap ID sent , failure : = item . destination . Receive ( f , frame Type ) if ! sent { r . fail Relay Item ( items , original ID , failure ) return nil } if finished { r . finish Relay Item ( items , original ID ) } return nil } 
func ( r * Relayer ) add Relay Item ( is Originator bool , id , remap ID uint 3 2 , destination * Relayer , ttl time . Duration , span Span , call Relay Call ) relay Item { item : = relay Item { call : call , remap ID : remap ID , destination : destination , span : span , } items : = r . inbound if is Originator { items = r . outbound } item . timeout = r . timeouts . Get ( ) items . Add ( id , item ) item . timeout . Start ( ttl , items , id , is Originator ) return item } 
func ( r * Relayer ) fail Relay Item ( items * relay Items , id uint 3 2 , failure string ) { item , ok : = items . Get ( id ) if ! ok { items . logger . With Fields ( Log Field { " " , id } ) . Warn ( " " ) return } } if ! ok { return } if item . call ! = nil { } item . call . Failed ( failure ) item . call . End ( ) } r . decrement Pending ( ) } 
func Write Struct ( writer io . Writer , s thrift . TStruct ) error { wp : = get Protocol Writer ( writer ) err : = s . Write ( wp . protocol ) thrift Protocol Pool . Put ( wp ) return err } 
func Read Struct ( reader io . Reader , s thrift . TStruct ) error { wp : = get Protocol Reader ( reader ) err : = s . Read ( wp . protocol ) thrift Protocol Pool . Put ( wp ) return err } 
func Ensure Empty ( r io . Reader , stage string ) error { buf : = _buf Pool . Get ( ) . ( * [ ] byte ) defer _buf Pool . Put ( buf ) n , err : = r . Read ( * buf ) if n > 0 { return fmt . Errorf ( " " , stage , ( * buf ) [ : n ] ) } if err = = io . EOF { return nil } return err } 
func New Server ( opt Fns . . . Option ) Server { opts : = get Options ( opt Fns ) if opts . external { return new External Server ( opts ) } ch , err : = tchannel . New Channel ( opts . svc Name , & tchannel . Channel Options { Logger : tchannel . New Level Logger ( tchannel . New Logger ( os . Stderr ) , tchannel . Log Level Warn ) , } ) if err ! = nil { panic ( " " + err . Error ( ) ) } if err : = ch . Listen And Serve ( " " ) ; err ! = nil { panic ( " " + err . Error ( ) ) } s : = & internal Server { ch : ch , opts : opts , } t Server : = thrift . New Server ( ch ) t Server . Register ( gen . New TChan Second Service Server ( handler { calls : & s . thrift Calls } ) ) ch . Register ( raw . Wrap ( raw Handler { calls : & s . raw Calls } ) , " " ) if len ( opts . advertise Hosts ) > 0 { if err : = s . Advertise ( opts . advertise Hosts ) ; err ! = nil { panic ( " " + err . Error ( ) ) } } return s } 
func ( s * internal Server ) Advertise ( hyperbahn Hosts [ ] string ) error { config : = hyperbahn . Configuration { Initial Nodes : hyperbahn Hosts } hc , err : = hyperbahn . New Client ( s . ch , config , nil ) if err ! = nil { panic ( " " + err . Error ( ) ) } return hc . Advertise ( ) } 
func ( c * Connection ) handle Call Req ( frame * Frame ) bool { now : = c . time Now ( ) switch state : = c . read State ( ) ; state { case connection Active : break case connection Start Close , connection Inbound Closed , connection Closed : c . Send System Error ( frame . Header . ID , call Req Span ( frame ) , Err Channel Closed ) return true default : panic ( fmt . Errorf ( " " , state ) ) } call Req : = new ( call Req ) call Req . id = frame . Header . ID initial Fragment , err : = parse Inbound Fragment ( c . opts . Frame Pool , frame , call Req ) if err ! = nil { return true } call : = new ( Inbound Call ) call . conn = c ctx , cancel : = new Incoming Context ( call , call Req . Time To Live ) mex , err : = c . inbound . new Exchange ( ctx , c . opts . Frame Pool , call Req . message Type ( ) , frame . Header . ID , mex Channel Buffer Size ) if err ! = nil { if err = = err Duplicate Mex { err = err Inbound Request Already Active } c . log . With Fields ( Log Field { " " , frame . Header } ) . Error ( " " ) c . protocol Error ( frame . Header . ID , err Inbound Request Already Active ) return true } return true } response : = new ( Inbound Call Response ) response . call = call response . called At = now response . time Now = c . time Now response . span = c . extract Inbound Span ( call Req ) if response . span ! = nil { mex . ctx = opentracing . Context With Span ( mex . ctx , response . span ) } response . mex = mex response . conn = c response . cancel = cancel response . log = c . log . With Fields ( Log Field { " " , call Req . ID ( ) } ) response . contents = new Fragmenting Writer ( response . log , response , initial Fragment . checksum Type . New ( ) ) response . headers = transport Headers { } response . message For Fragment = func ( initial bool ) message { if initial { call Res : = new ( call Res ) call Res . Headers = response . headers call Res . Response Code = response OK if response . application Error { call Res . Response Code = response Application Error } return call Res } return new ( call Res Continue ) } call . mex = mex call . initial Fragment = initial Fragment call . service Name = string ( call Req . Service ) call . headers = call Req . Headers call . response = response call . log = c . log . With Fields ( Log Field { " " , call Req . ID ( ) } ) call . message For Fragment = func ( initial bool ) message { return new ( call Req Continue ) } call . contents = new Fragmenting Reader ( call . log , call ) call . stats Reporter = c . stats Reporter call . create Stats Tags ( c . common Stats Tags ) response . stats Reporter = c . stats Reporter response . common Stats Tags = call . common Stats Tags set Response Headers ( call . headers , response . headers ) go c . dispatch Inbound ( c . conn ID , call Req . ID ( ) , call , frame ) return false } 
func ( c * Connection ) handle Call Req Continue ( frame * Frame ) bool { if err : = c . inbound . forward Peer Frame ( frame ) ; err ! = nil { } return false } 
func ( call * Inbound Call ) create Stats Tags ( connection Tags map [ string ] string ) { call . common Stats Tags = map [ string ] string { " " : call . Caller Name ( ) , } for k , v : = range connection Tags { call . common Stats Tags [ k ] = v } } 
func ( c * Connection ) dispatch Inbound ( _ uint 3 2 , _ uint 3 2 , call * Inbound Call , frame * Frame ) { if call . log . Enabled ( Log Level Debug ) { call . log . Debugf ( " " , call . Service Name ( ) , c . remote Peer Info ) } if err : = call . read Method ( ) ; err ! = nil { call . log . With Fields ( Log Field { " " , c . remote Peer Info } , Err Field ( err ) , ) . Error ( " " ) c . opts . Frame Pool . Release ( frame ) return } call . common Stats Tags [ " " ] = call . method String call . stats Reporter . Inc Counter ( " " , call . common Stats Tags , 1 ) if span : = call . response . span ; span ! = nil { span . Set Operation Name ( call . method String ) } } case < - call . mex . err Ch . c : if c . log . Enabled ( Log Level Debug ) { call . log . Debugf ( " " , call . mex . err Ch . err ) } call . mex . inbound Expired ( ) } } ( ) c . handler . Handle ( call . mex . ctx , call ) } 
func ( call * Inbound Call ) Call Options ( ) * Call Options { return & Call Options { caller Name : call . Caller Name ( ) , Format : call . Format ( ) , Shard Key : call . Shard Key ( ) , Routing Delegate : call . Routing Delegate ( ) , Routing Key : call . Routing Key ( ) , } } 
func ( call * Inbound Call ) read Method ( ) error { var arg 1 [ ] byte if err : = New Arg Reader ( call . arg 1Reader ( ) ) . Read ( & arg 1 ) ; err ! = nil { return call . failed ( err ) } call . method = arg 1 call . method String = string ( arg 1 ) return nil } 
func ( call * Inbound Call ) Response ( ) * Inbound Call Response { if call . err ! = nil { } return call . response } 
func ( response * Inbound Call Response ) Send System Error ( err error ) error { if response . err ! = nil { return response . err } response . system Error = true response . done Sending ( ) response . call . release Previous Fragment ( ) span : = Current Span ( response . mex . ctx ) return response . conn . Send System Error ( response . mex . msg ID , * span , err ) } 
func ( response * Inbound Call Response ) Set Application Error ( ) error { if response . state > req Res Writer Pre Arg 2 { return response . failed ( err Req Res Writer State Mismatch { state : response . state , expected State : req Res Writer Pre Arg 2 , } ) } response . application Error = true return nil } 
func ( response * Inbound Call Response ) Arg 2Writer ( ) ( Arg Writer , error ) { if err : = New Arg Writer ( response . arg 1Writer ( ) ) . Write ( nil ) ; err ! = nil { return nil , err } return response . arg 2Writer ( ) } 
func ( response * Inbound Call Response ) done Sending ( ) { if span : = response . span ; span ! = nil { if response . application Error | | response . system Error { ext . Error . Set ( span , true ) } span . Finish With Options ( opentracing . Finish Options { Finish Time : now } ) } latency : = now . Sub ( response . called At ) response . stats Reporter . Record Timer ( " " , response . common Stats Tags , latency ) if response . system Error { } else { response . stats Reporter . Inc Counter ( " " , response . common Stats Tags , 1 ) } } } 
func new State ( v * parser . Thrift , all map [ string ] parse State ) * State { typedefs : = make ( map [ string ] * parser . Type ) for k , v : = range v . Typedefs { typedefs [ k ] = v . Type } for k : = range v . Enums { typedefs [ k ] = i 6 4Type } return & State { typedefs , nil , all } } 
func ( s * State ) root Type ( thrift Type * parser . Type ) * parser . Type { if state , new Type , include : = s . check Include ( thrift Type ) ; include ! = nil { return state . root Type ( new Type ) } if v , ok : = s . typedefs [ thrift Type . Name ] ; ok { return s . root Type ( v ) } return thrift Type } 
func ( s * State ) check Include ( thrift Type * parser . Type ) ( * State , * parser . Type , * Include ) { parts : = strings . Split N ( thrift Type . Name , " " , 2 ) if len ( parts ) < 2 { return nil , nil , nil } new Type : = * thrift Type new Type . Name = parts [ 1 ] include : = s . includes [ parts [ 0 ] ] state : = s . all [ include . file ] return state . global , & new Type , include } 
func ( s * State ) is Result Pointer ( thrift Type * parser . Type ) bool { _ , basic Go Type : = thrift To Go [ s . root Type ( thrift Type ) . Name ] return ! basic Go Type } 
func ( s * State ) go Type ( thrift Type * parser . Type ) string { return s . go Type Prefix ( " " , thrift Type ) } 
func ( s * State ) go Type Prefix ( prefix string , thrift Type * parser . Type ) string { switch thrift Type . Name { case " " : return " " case " " : return " " + s . go Type ( thrift Type . Value Type ) case " " : return " " + s . go Type ( thrift Type . Value Type ) + " " case " " : return " " + s . go Type ( thrift Type . Key Type ) + " " + s . go Type ( thrift Type . Value Type ) } } } go Thrift Name : = go Public Field Name ( thrift Type . Name ) go Thrift Name = prefix + go Thrift Name if _ , ok : = thrift To Go [ root Type . Name ] ; ok { return go Thrift Name } if root Type . Name = = " " | | root Type . Name = = " " | | root Type . Name = = " " { return go Thrift Name } } } 
func New Context ( timeout time . Duration ) ( context . Context , context . Cancel Func ) { return New Context Builder ( timeout ) . Build ( ) } 
func new Incoming Context ( call Incoming Call , timeout time . Duration ) ( context . Context , context . Cancel Func ) { return New Context Builder ( timeout ) . set Incoming Call ( call ) . Build ( ) } 
func Current Call ( ctx context . Context ) Incoming Call { if params : = get TChannel Params ( ctx ) ; params ! = nil { return params . call } return nil } 
func ( p * Key Value Client ) Get ( key string ) ( r string , err error ) { if err = p . send Get ( key ) ; err ! = nil { return } return p . recv Get ( ) } 
func ( p * Key Value Client ) Set ( key string , value string ) ( err error ) { if err = p . send Set ( key , value ) ; err ! = nil { return } return p . recv Set ( ) } 
func New ( seed int 6 4 ) * rand . Rand { return rand . New ( & locked Source { src : rand . New Source ( seed ) } ) } 
func ( h * meta Handler ) Health ( ctx Context , req * meta . Health Request ) ( * meta . Health Status , error ) { ok , message : = h . health Fn ( ctx , meta Req To Req ( req ) ) if message = = " " { return & meta . Health Status { Ok : ok } , nil } return & meta . Health Status { Ok : ok , Message : & message } , nil } 
func ( p * Meta Client ) Health ( hr * Health Request ) ( r * Health Status , err error ) { if err = p . send Health ( hr ) ; err ! = nil { return } return p . recv Health ( ) } 
func ( c header Ctx ) Headers ( ) map [ string ] string { if h : = c . headers ( ) ; h ! = nil { return h . req Headers } return nil } 
func ( c header Ctx ) Response Headers ( ) map [ string ] string { if h : = c . headers ( ) ; h ! = nil { return h . resp Headers } return nil } 
func ( c header Ctx ) Set Response Headers ( headers map [ string ] string ) { if h : = c . headers ( ) ; h ! = nil { h . resp Headers = headers return } panic ( " " ) } 
func ( c header Ctx ) Child ( ) Context With Headers { var headers Copy headers Container if h : = c . headers ( ) ; h ! = nil { headers Copy = * h } return Wrap ( context . With Value ( c . Context , context Key Headers , & headers Copy ) ) } 
func Wrap ( ctx context . Context ) Context With Headers { hctx : = header Ctx { Context : ctx } if h : = hctx . headers ( ) ; h ! = nil { return hctx } } 
func Wrap With Headers ( ctx context . Context , headers map [ string ] string ) Context With Headers { h : = & headers Container { req Headers : headers , } new Ctx : = context . With Value ( ctx , context Key Headers , h ) return header Ctx { Context : new Ctx } } 
func Without Headers ( ctx context . Context ) context . Context { return context . With Value ( context . With Value ( ctx , context Key TChannel , nil ) , context Key Headers , nil ) } 
func ( e * err Notifier ) Notify ( err error ) error { } } e . err = err close ( e . c ) return nil } 
func ( mex * message Exchange ) check Error ( ) error { if err : = mex . ctx . Err ( ) ; err ! = nil { return Get Context Error ( err ) } return mex . err Ch . check Err ( ) } 
func ( mex * message Exchange ) forward Peer Frame ( frame * Frame ) error { } select { case mex . recv Ch < - frame : return nil case < - mex . ctx . Done ( ) : case < - mex . err Ch . c : default : } return mex . err Ch . err } } 
func ( mex * message Exchange ) recv Peer Frame ( ) ( * Frame , error ) { } select { case frame : = < - mex . recv Ch : if err : = mex . check Frame ( frame ) ; err ! = nil { return nil , err } return frame , nil case < - mex . ctx . Done ( ) : return nil , Get Context Error ( mex . ctx . Err ( ) ) case < - mex . err Ch . c : } return frame , nil default : } return nil , mex . err Ch . err } } 
func ( mex * message Exchange ) recv Peer Frame Of Type ( msg Type message Type ) ( * Frame , error ) { frame , err : = mex . recv Peer Frame ( ) if err ! = nil { return nil , err } switch frame . Header . message Type { case msg Type : return frame , nil case message Type Error : err Msg : = error Message { id : frame . Header . ID , } var rbuf typed . Read Buffer rbuf . Wrap ( frame . Sized Payload ( ) ) if err : = err Msg . read ( & rbuf ) ; err ! = nil { return nil , err } return nil , err Msg default : return nil , err Unexpected Frame Type } } 
func ( mex * message Exchange ) shutdown ( ) { } if mex . err Ch Notified . CAS ( false , true ) { mex . err Ch . Notify ( err Mex Shutdown ) } mex . mexset . remove Exchange ( mex . msg ID ) } 
func new Message Exchange Set ( log Logger , name string ) * message Exchange Set { return & message Exchange Set { name : name , log : log . With Fields ( Log Field { " " , name } ) , exchanges : make ( map [ uint 3 2 ] * message Exchange ) , expired Exchanges : make ( map [ uint 3 2 ] struct { } ) , } } 
func ( mexset * message Exchange Set ) add Exchange ( mex * message Exchange ) error { if mexset . shutdown { return err Mex Set Shutdown } if _ , ok : = mexset . exchanges [ mex . msg ID ] ; ok { return err Duplicate Mex } mexset . exchanges [ mex . msg ID ] = mex return nil } 
func ( mexset * message Exchange Set ) new Exchange ( ctx context . Context , frame Pool Frame Pool , msg Type message Type , msg ID uint 3 2 , buffer Size int ) ( * message Exchange , error ) { if mexset . log . Enabled ( Log Level Debug ) { mexset . log . Debugf ( " " , mexset . name , msg Type , msg ID ) } mex : = & message Exchange { msg Type : msg Type , msg ID : msg ID , ctx : ctx , recv Ch : make ( chan * Frame , buffer Size ) , err Ch : new Err Notifier ( ) , mexset : mexset , frame Pool : frame Pool , } mexset . Lock ( ) add Err : = mexset . add Exchange ( mex ) mexset . Unlock ( ) if add Err ! = nil { logger : = mexset . log . With Fields ( Log Field { " " , mex . msg ID } , Log Field { " " , mex . msg Type } , Log Field { " " , mexset . name } , ) if add Err = = err Mex Set Shutdown { logger . Warn ( " " ) } else if add Err = = err Duplicate Mex { logger . Warn ( " " ) } return nil , add Err } mexset . on Added ( ) } 
func ( mexset * message Exchange Set ) delete Exchange ( msg ID uint 3 2 ) ( found , timed Out bool ) { if _ , found : = mexset . exchanges [ msg ID ] ; found { delete ( mexset . exchanges , msg ID ) return true , false } if _ , expired : = mexset . expired Exchanges [ msg ID ] ; expired { delete ( mexset . expired Exchanges , msg ID ) return false , true } return false , false } 
func ( mexset * message Exchange Set ) remove Exchange ( msg ID uint 3 2 ) { if mexset . log . Enabled ( Log Level Debug ) { mexset . log . Debugf ( " " , mexset . name , msg ID ) } mexset . Lock ( ) found , expired : = mexset . delete Exchange ( msg ID ) mexset . Unlock ( ) if ! found & & ! expired { mexset . log . With Fields ( Log Field { " " , msg ID } , ) . Error ( " " ) return } } 
func ( mexset * message Exchange Set ) expire Exchange ( msg ID uint 3 2 ) { mexset . log . Debugf ( " " , mexset . name , msg ID , ) mexset . Lock ( ) if found | | expired { } mexset . Unlock ( ) if expired { mexset . log . With Fields ( Log Field { " " , msg ID } ) . Info ( " " ) } mexset . on Removed ( ) } 
func ( mexset * message Exchange Set ) forward Peer Frame ( frame * Frame ) error { if mexset . log . Enabled ( Log Level Debug ) { mexset . log . Debugf ( " " , mexset . name , frame . Header ) } mexset . RLock ( ) mex : = mexset . exchanges [ frame . Header . ID ] mexset . RUnlock ( ) if mex = = nil { return nil } if err : = mex . forward Peer Frame ( frame ) ; err ! = nil { mexset . log . With Fields ( Log Field { " " , frame . Header . String ( ) } , Log Field { " " , frame . Header . Frame Size ( ) } , Log Field { " " , mexset . name } , Err Field ( err ) , ) . Info ( " " ) return err } return nil } 
func ( mexset * message Exchange Set ) copy Exchanges ( ) ( shutdown bool , exchanges map [ uint 3 2 ] * message Exchange ) { if mexset . shutdown { return true , nil } exchanges Copy : = make ( map [ uint 3 2 ] * message Exchange , len ( mexset . exchanges ) ) for k , mex : = range mexset . exchanges { exchanges Copy [ k ] = mex } return false , exchanges Copy } 
func ( mexset * message Exchange Set ) stop Exchanges ( err error ) { if mexset . log . Enabled ( Log Level Debug ) { mexset . log . Debugf ( " " , mexset . count ( ) , err ) } mexset . Lock ( ) shutdown , exchanges : = mexset . copy Exchanges ( ) mexset . shutdown = true mexset . Unlock ( ) if shutdown { mexset . log . Debugf ( " " ) return } for _ , mex : = range exchanges { } } } 
func ( fh Frame Header ) Marshal JSON ( ) ( [ ] byte , error ) { s : = struct { ID uint 3 2 `json : "id " ` Msg Type message Type `json : "msg Type " ` Size uint 1 6 `json : "size " ` } { fh . ID , fh . message Type , fh . size } return json . Marshal ( s ) } 
func New Frame ( payload Capacity int ) * Frame { f : = & Frame { } f . buffer = make ( [ ] byte , payload Capacity + Frame Header Size ) f . Payload = f . buffer [ Frame Header Size : ] f . header Buffer = f . buffer [ : Frame Header Size ] return f } 
func ( f * Frame ) Read Body ( header [ ] byte , r io . Reader ) error { } switch payload Size : = f . Header . Payload Size ( ) ; { case payload Size > Max Frame Payload Size : return fmt . Errorf ( " " , f . Header . size ) case payload Size > 0 : _ , err : = io . Read Full ( r , f . Sized Payload ( ) ) return err default : } } 
func ( f * Frame ) Read In ( r io . Reader ) error { header : = make ( [ ] byte , Frame Header Size ) if _ , err : = io . Read Full ( r , header ) ; err ! = nil { return err } return f . Read Body ( header , r ) } 
func ( f * Frame ) Write Out ( w io . Writer ) error { var wbuf typed . Write Buffer wbuf . Wrap ( f . header Buffer ) if err : = f . Header . write ( & wbuf ) ; err ! = nil { return err } full Frame : = f . buffer [ : f . Header . Frame Size ( ) ] if _ , err : = w . Write ( full Frame ) ; err ! = nil { return err } return nil } 
func ( r Retry On ) Can Retry ( err error ) bool { if r = = Retry Never { return false } if r = = Retry Default { r = Retry Connection Error } code : = get Err Code ( err ) if code = = Err Code Busy | | code = = Err Code Declined { return true } } switch r { case Retry Connection Error : return code = = Err Code Network case Retry Unexpected : return code = = Err Code Unexpected case Retry Idempotent : return true } return false } 
func ( rs * Request State ) Has Retries ( err error ) bool { if rs = = nil { return false } r Opts : = rs . retry Opts return rs . Attempt < r Opts . Max Attempts & & r Opts . Retry On . Can Retry ( err ) } 
func ( rs * Request State ) Since Start ( now time . Time , fallback time . Duration ) time . Duration { if rs = = nil { return fallback } return now . Sub ( rs . Start ) } 
func ( rs * Request State ) Add Selected Peer ( host Port string ) { if rs = = nil { return } host : = get Host ( host Port ) if rs . Selected Peers = = nil { rs . Selected Peers = map [ string ] struct { } { host Port : { } , host : { } , } } else { rs . Selected Peers [ host Port ] = struct { } { } rs . Selected Peers [ host ] = struct { } { } } } 
func ( ch * Channel ) Run With Retry ( run Ctx context . Context , f Retriable Func ) error { var err error opts : = get Retry Options ( run Ctx ) rs : = ch . get Request State ( opts ) defer request State Pool . Put ( rs ) for i : = 0 ; i < opts . Max Attempts ; i + + { rs . Attempt + + if opts . Timeout Per Attempt = = 0 { err = f ( run Ctx , rs ) } else { attempt Ctx , cancel : = context . With Timeout ( run Ctx , opts . Timeout Per Attempt ) err = f ( attempt Ctx , rs ) cancel ( ) } if err = = nil { return nil } if ! opts . Retry On . Can Retry ( err ) { if ch . log . Enabled ( Log Level Info ) { ch . log . With Fields ( Err Field ( err ) ) . Info ( " " ) } return err } ch . log . With Fields ( Err Field ( err ) , Log Field { " " , rs . Attempt } , Log Field { " " , opts . Max Attempts } , ) . Info ( " " ) } } 
func get Host ( host Port string ) string { for i : = 0 ; i < len ( host Port ) ; i + + { if host Port [ i ] = = ' : ' { return host Port [ : i ] } } return host Port } 
func ( t Checksum Type ) Checksum Size ( ) int { switch t { case Checksum Type None : return 0 case Checksum Type Crc 3 2 , Checksum Type Crc 3 2C : return crc 3 2 . Size case Checksum Type Farmhash : return 4 default : return 0 } } 
func ( t Checksum Type ) New ( ) Checksum { s : = t . pool ( ) . Get ( ) . ( Checksum ) s . Reset ( ) return s } 
func parse Templates ( skip TChannel bool , template Files [ ] string ) ( [ ] * Template , error ) { var templates [ ] * Template if ! skip TChannel { templates = append ( templates , & Template { name : " " , template : template . Must ( parse Template ( tchannel Tmpl ) ) , } ) } for _ , f : = range template Files { t , err : = parse Template File ( f ) if err ! = nil { return nil , err } templates = append ( templates , t ) } return templates , nil } 
func New String Slice Flag ( name string , usage string ) * [ ] string { var ss string Slice Flag flag . Var ( & ss , name , usage ) return ( * [ ] string ) ( & ss ) } 
func ( t * Template ) with State Funcs ( td Template Data ) * template . Template { return t . template . Funcs ( map [ string ] interface { } { " " : td . global . go Type , } ) } 
func ( ch * Channel ) Introspect State ( opts * Introspection Options ) * Runtime State { if opts = = nil { opts = & Introspection Options { } } ch . mutable . RLock ( ) state : = ch . mutable . state num Conns : = len ( ch . mutable . conns ) inactive Conns : = make ( [ ] * Connection , 0 , num Conns ) conn IDs : = make ( [ ] uint 3 2 , 0 , num Conns ) for id , conn : = range ch . mutable . conns { conn IDs = append ( conn IDs , id ) if ! conn . Is Active ( ) { inactive Conns = append ( inactive Conns , conn ) } } ch . mutable . RUnlock ( ) ch . State ( ) return & Runtime State { ID : ch . ch ID , Channel State : state . String ( ) , Created Stack : ch . created Stack , Local Peer : ch . Peer Info ( ) , Sub Channels : ch . sub Channels . Introspect State ( opts ) , Root Peers : ch . Root Peers ( ) . Introspect State ( opts ) , Peers : ch . Peers ( ) . Introspect List ( opts ) , Num Connections : num Conns , Connections : conn IDs , Inactive Connections : get Connection Runtime State ( inactive Conns , opts ) , Other Channels : ch . Introspect Others ( opts ) , Runtime Version : introspect Runtime Version ( ) , } } 
func ( ch * Channel ) Introspect Others ( opts * Introspection Options ) map [ string ] [ ] Channel Info { if ! opts . Include Other Channels { return nil } channel Map . Lock ( ) defer channel Map . Unlock ( ) states : = make ( map [ string ] [ ] Channel Info ) for svc , channels : = range channel Map . existing { channel Infos : = make ( [ ] Channel Info , 0 , len ( channels ) ) for _ , other Chan : = range channels { if ch = = other Chan { continue } channel Infos = append ( channel Infos , other Chan . Report Info ( opts ) ) } states [ svc ] = channel Infos } return states } 
func ( ch * Channel ) Report Info ( opts * Introspection Options ) Channel Info { return Channel Info { ID : ch . ch ID , Created Stack : ch . created Stack , Local Peer : ch . Peer Info ( ) , } } 
func ( l * Root Peer List ) Introspect State ( opts * Introspection Options ) map [ string ] Peer Runtime State { return from Peer List ( l , opts ) } 
func ( sub Ch Map * sub Channel Map ) Introspect State ( opts * Introspection Options ) map [ string ] Sub Channel Runtime State { m : = make ( map [ string ] Sub Channel Runtime State ) sub Ch Map . RLock ( ) for k , sc : = range sub Ch Map . subchannels { state : = Sub Channel Runtime State { Service : k , Isolated : sc . Isolated ( ) , } if state . Isolated { state . Isolated Peers = sc . Peers ( ) . Introspect List ( opts ) } if hmap , ok : = sc . handler . ( * handler Map ) ; ok { state . Handler . Type = method Handler methods : = make ( [ ] string , 0 , len ( hmap . handlers ) ) for k : = range hmap . handlers { methods = append ( methods , k ) } sort . Strings ( methods ) state . Handler . Methods = methods } else { state . Handler . Type = override Handler } m [ k ] = state } sub Ch Map . RUnlock ( ) return m } 
func ( p * Peer ) Introspect State ( opts * Introspection Options ) Peer Runtime State { p . RLock ( ) defer p . RUnlock ( ) return Peer Runtime State { Host Port : p . host Port , Inbound Connections : get Connection Runtime State ( p . inbound Connections , opts ) , Outbound Connections : get Connection Runtime State ( p . outbound Connections , opts ) , Chosen Count : p . chosen Count . Load ( ) , SCCount : p . sc Count , } } 
func ( c * Connection ) Introspect State ( opts * Introspection Options ) Connection Runtime State { c . state Mut . RLock ( ) defer c . state Mut . RUnlock ( ) if c . relay ! = nil { state . Relayer = c . relay . Introspect State ( opts ) } return state } 
func ( r * Relayer ) Introspect State ( opts * Introspection Options ) Relayer Runtime State { count : = r . inbound . Count ( ) + r . outbound . Count ( ) return Relayer Runtime State { Count : count , Inbound Items : r . inbound . Introspect State ( opts , " " ) , Outbound Items : r . outbound . Introspect State ( opts , " " ) , Max Timeout : r . max Timeout , } } 
func ( ri * relay Items ) Introspect State ( opts * Introspection Options , name string ) Relay Item Set State { ri . RLock ( ) defer ri . RUnlock ( ) set State : = Relay Item Set State { Name : name , Count : ri . Count ( ) , } if opts . Include Exchanges { set State . Items = make ( map [ string ] Relay Item State , len ( ri . items ) ) for k , v : = range ri . items { if ! opts . Include Tombstones & & v . tomb { continue } state : = Relay Item State { ID : k , Remap ID : v . remap ID , Destination Connection ID : v . destination . conn . conn ID , Tomb : v . tomb , } set State . Items [ strconv . Itoa ( int ( k ) ) ] = state } } return set State } 
func ( mexset * message Exchange Set ) Introspect State ( opts * Introspection Options ) Exchange Set Runtime State { mexset . RLock ( ) set State : = Exchange Set Runtime State { Name : mexset . name , Count : len ( mexset . exchanges ) , } if opts . Include Exchanges { set State . Exchanges = make ( map [ string ] Exchange Runtime State , len ( mexset . exchanges ) ) for k , v : = range mexset . exchanges { state : = Exchange Runtime State { ID : k , Message Type : v . msg Type , } set State . Exchanges [ strconv . Itoa ( int ( k ) ) ] = state } } mexset . RUnlock ( ) return set State } 
func ( l * Peer List ) Introspect List ( opts * Introspection Options ) [ ] Sub Peer Score { var peers [ ] Sub Peer Score l . RLock ( ) for _ , ps : = range l . peer Heap . peer Scores { peers = append ( peers , Sub Peer Score { Host Port : ps . Peer . host Port , Score : ps . score , } ) } l . RUnlock ( ) return peers } 
func ( ch * Channel ) Introspect Num Connections ( ) int { ch . mutable . RLock ( ) num Conns : = len ( ch . mutable . conns ) ch . mutable . RUnlock ( ) return num Conns } 
func ( ch * Channel ) register Internal ( ) { endpoints : = [ ] struct { name string handler func ( [ ] byte ) interface { } } { { " " , ch . handle Introspection } , { " " , handle Internal Runtime } , } tchan SC : = ch . Get Sub Channel ( " " ) for _ , ep : = range endpoints { handler : = func ( ctx context . Context , call * Inbound Call ) { var arg 2 , arg 3 [ ] byte if err : = New Arg Reader ( call . Arg 2Reader ( ) ) . Read ( & arg 2 ) ; err ! = nil { return } if err : = New Arg Reader ( call . Arg 3Reader ( ) ) . Read ( & arg 3 ) ; err ! = nil { return } if err : = New Arg Writer ( call . Response ( ) . Arg 2Writer ( ) ) . Write ( nil ) ; err ! = nil { return } New Arg Writer ( call . Response ( ) . Arg 3Writer ( ) ) . Write JSON ( ep . handler ( arg 3 ) ) } ch . Register ( Handler Func ( handler ) , ep . name ) tchan SC . Register ( Handler Func ( handler ) , ep . name ) } } 
func New Context ( timeout time . Duration ) ( Context , context . Cancel Func ) { ctx , cancel : = tchannel . New Context ( timeout ) return tchannel . Wrap With Headers ( ctx , nil ) , cancel } 
func Read Args ( call * tchannel . Inbound Call ) ( * Args , error ) { var args Args args . Caller = call . Caller Name ( ) args . Format = call . Format ( ) args . Method = string ( call . Method ( ) ) if err : = tchannel . New Arg Reader ( call . Arg 2Reader ( ) ) . Read ( & args . Arg 2 ) ; err ! = nil { return nil , err } if err : = tchannel . New Arg Reader ( call . Arg 3Reader ( ) ) . Read ( & args . Arg 3 ) ; err ! = nil { return nil , err } return & args , nil } 
func Write Response ( response * tchannel . Inbound Call Response , resp * Res ) error { if resp . System Err ! = nil { return response . Send System Error ( resp . System Err ) } if resp . Is Err { if err : = response . Set Application Error ( ) ; err ! = nil { return err } } if err : = tchannel . New Arg Writer ( response . Arg 2Writer ( ) ) . Write ( resp . Arg 2 ) ; err ! = nil { return err } return tchannel . New Arg Writer ( response . Arg 3Writer ( ) ) . Write ( resp . Arg 3 ) } 
func Wrap ( handler Handler ) tchannel . Handler { return tchannel . Handler Func ( func ( ctx context . Context , call * tchannel . Inbound Call ) { args , err : = Read Args ( call ) if err ! = nil { handler . On Error ( ctx , err ) return } resp , err : = handler . Handle ( ctx , args ) response : = call . Response ( ) if err ! = nil { resp = & Res { System Err : err , } } if err : = Write Response ( response , resp ) ; err ! = nil { handler . On Error ( ctx , err ) } } ) } 
func ( s * injectable Span ) init From Open Tracing ( span opentracing . Span ) error { return span . Tracer ( ) . Inject ( span . Context ( ) , zipkin Span Format , s ) } 
func Current Span ( ctx context . Context ) * Span { if sp : = opentracing . Span From Context ( ctx ) ; sp ! = nil { var injectable injectable Span if err : = injectable . init From Open Tracing ( sp ) ; err = = nil { span : = Span ( injectable ) return & span } return & empty Span } 
func ( c * Connection ) start Outbound Span ( ctx context . Context , service Name , method Name string , call * Outbound Call , start Time time . Time ) opentracing . Span { var parent opentracing . Span Context if s : = opentracing . Span From Context ( ctx ) ; s ! = nil { parent = s . Context ( ) } span : = c . Tracer ( ) . Start Span ( method Name , opentracing . Child Of ( parent ) , opentracing . Start Time ( start Time ) , ) if is Tracing Disabled ( ctx ) { ext . Sampling Priority . Set ( span , 0 ) } ext . Span Kind RPCClient . Set ( span ) ext . Peer Service . Set ( span , service Name ) c . set Peer Host Port ( span ) span . Set Tag ( " " , call . call Req . Headers [ Arg Scheme ] ) var injectable injectable Span if err : = injectable . init From Open Tracing ( span ) ; err = = nil { call . call Req . Tracing = Span ( injectable ) } else { call . call Req . Tracing . init Random ( ) } return span } 
func Inject Outbound Span ( response * Outbound Call Response , headers map [ string ] string ) map [ string ] string { span : = response . span if span = = nil { return headers } new Headers : = make ( map [ string ] string ) carrier : = tracing Headers Carrier ( new Headers ) if err : = span . Tracer ( ) . Inject ( span . Context ( ) , opentracing . Text Map , carrier ) ; err ! = nil { } if len ( new Headers ) = = 0 { return headers } for k , v : = range headers { } } return new Headers } 
func ( c * Connection ) extract Inbound Span ( call Req * call Req ) opentracing . Span { span Ctx , err : = c . Tracer ( ) . Extract ( zipkin Span Format , & call Req . Tracing ) if err ! = nil { if err ! = opentracing . Err Unsupported Format & & err ! = opentracing . Err Span Context Not Found { c . log . With Fields ( Err Field ( err ) ) . Error ( " " ) } return nil } if span Ctx = = nil { return nil } operation Name : = " " span : = c . Tracer ( ) . Start Span ( operation Name , ext . RPCServer Option ( span Ctx ) ) span . Set Tag ( " " , call Req . Headers [ Arg Scheme ] ) ext . Peer Service . Set ( span , call Req . Headers [ Caller Name ] ) c . set Peer Host Port ( span ) return span } 
func Extract Inbound Span ( ctx context . Context , call * Inbound Call , headers map [ string ] string , tracer opentracing . Tracer ) context . Context { var span = call . Response ( ) . span if span ! = nil { if headers ! = nil { if sc , err : = tracer . Extract ( opentracing . Text Map , carrier ) ; err = = nil { sc . Foreach Baggage Item ( func ( k , v string ) bool { span . Set Baggage Item ( k , v ) return true } ) } carrier . Remove Tracing Keys ( ) } } else { var parent opentracing . Span Context if headers ! = nil { carrier : = tracing Headers Carrier ( headers ) if p , err : = tracer . Extract ( opentracing . Text Map , carrier ) ; err = = nil { parent = p } carrier . Remove Tracing Keys ( ) } span = tracer . Start Span ( call . Method String ( ) , ext . RPCServer Option ( parent ) ) ext . Peer Service . Set ( span , call . Caller Name ( ) ) span . Set Tag ( " " , string ( call . Format ( ) ) ) call . conn . set Peer Host Port ( span ) call . Response ( ) . span = span } return opentracing . Context With Span ( ctx , span ) } 
func Tracer From Registrar ( registrar Registrar ) opentracing . Tracer { if tracer Provider , ok : = registrar . ( tracer Provider ) ; ok { return tracer Provider . Tracer ( ) } return opentracing . Global Tracer ( ) } 
func int To IP 4 ( ip uint 3 2 ) net . IP { return net . IP { byte ( ip > > 2 4 & 0xff ) , byte ( ip > > 1 6 & 0xff ) , byte ( ip > > 8 & 0xff ) , byte ( ip & 0xff ) , } } 
func service Peer To Host Port ( peer * hyperbahn . Service Peer ) string { host : = int To IP 4 ( uint 3 2 ( * peer . IP . Ipv 4 ) ) . String ( ) port : = strconv . Itoa ( int ( peer . Port ) ) return net . Join Host Port ( host , port ) } 
func New Statsd Reporter ( addr , prefix string ) ( tchannel . Stats Reporter , error ) { client , err : = statsd . New Buffered Client ( addr , prefix , time . Second , 0 ) if err ! = nil { return nil , err } return New Statsd Reporter Client ( client ) , nil } 
func ( r * To S ) Unmarshal Text ( data [ ] byte ) error { if v , ok : = _tos Name To Value [ string ( data ) ] ; ok { * r = v return nil } return fmt . Errorf ( " " , string ( data ) ) } 
func ( ph * peer Heap ) Push ( x interface { } ) { n : = len ( ph . peer Scores ) item : = x . ( * peer Score ) item . index = n ph . peer Scores = append ( ph . peer Scores , item ) } 
func ( ph * peer Heap ) Pop ( ) interface { } { old : = * ph n : = len ( old . peer Scores ) item : = old . peer Scores [ n - 1 ] item . index = - 1 ph . peer Scores = old . peer Scores [ : n - 1 ] return item } 
func ( ph * peer Heap ) update Peer ( peer Score * peer Score ) { heap . Fix ( ph , peer Score . index ) } 
func ( ph * peer Heap ) remove Peer ( peer Score * peer Score ) { heap . Remove ( ph , peer Score . index ) } 
func ( ph * peer Heap ) push Peer ( peer Score * peer Score ) { ph . order + + new Order : = ph . order peer Score . order = new Order + uint 6 4 ( ph . rng . Intn ( rand Range ) ) heap . Push ( ph , peer Score ) } 
func ( ph * peer Heap ) add Peer ( peer Score * peer Score ) { ph . push Peer ( peer Score ) ph . swap Order ( peer Score . index , r ) } 
func New Client ( ch * tchannel . Channel , service Name string , opts * Client Options ) TChan Client { client : = & client { ch : ch , sc : ch . Get Sub Channel ( service Name ) , service Name : service Name , } if opts ! = nil { client . opts = * opts } return client } 
func read Response ( response * tchannel . Outbound Call Response , resp thrift . TStruct ) ( map [ string ] string , bool , error ) { reader , err : = response . Arg 2Reader ( ) if err ! = nil { return nil , false , err } headers , err : = Read Headers ( reader ) if err ! = nil { return nil , false , err } if err : = argreader . Ensure Empty ( reader , " " ) ; err ! = nil { return nil , false , err } if err : = reader . Close ( ) ; err ! = nil { return nil , false , err } success : = ! response . Application Error ( ) reader , err = response . Arg 3Reader ( ) if err ! = nil { return headers , success , err } if err : = Read Struct ( reader , resp ) ; err ! = nil { return headers , success , err } if err : = argreader . Ensure Empty ( reader , " " ) ; err ! = nil { return nil , false , err } return headers , success , reader . Close ( ) } 
func ( l * Root Peer List ) Add ( host Port string ) * Peer { l . RLock ( ) if p , ok : = l . peers By Host Port [ host Port ] ; ok { l . RUnlock ( ) return p } l . RUnlock ( ) l . Lock ( ) defer l . Unlock ( ) if p , ok : = l . peers By Host Port [ host Port ] ; ok { return p } var p * Peer l . peers By Host Port [ host Port ] = p return p } 
func ( l * Root Peer List ) Get Or Add ( host Port string ) * Peer { peer , ok : = l . Get ( host Port ) if ok { return peer } return l . Add ( host Port ) } 
func ( l * Root Peer List ) Get ( host Port string ) ( * Peer , bool ) { l . RLock ( ) p , ok : = l . peers By Host Port [ host Port ] l . RUnlock ( ) return p , ok } 
func fnv 3 2a ( s string ) uint 3 2 { const ( initial = 2 1 6 6 1 3 6 2 6 1 prime = 1 6 7 7 7 6 1 9 ) hash : = uint 3 2 ( initial ) for i : = 0 ; i < len ( s ) ; i + + { hash ^ = uint 3 2 ( s [ i ] ) hash * = prime } return hash } 
func With Timeout ( timeout time . Duration ) Option { return func ( opts * options ) { opts . timeout = timeout } } 
func ( s * Service ) Extends Service Prefix ( ) string { if dot Index : = strings . Index ( s . Extends , " " ) ; dot Index > 0 { return s . Extends Prefix } return " " } 
func ( s * Service ) Methods ( ) [ ] * Method { if s . methods ! = nil { return s . methods } for _ , m : = range s . Service . Methods { s . methods = append ( s . methods , & Method { m , s , s . state } ) } sort . Sort ( by Method Name ( s . methods ) ) return s . methods } 
func ( s * Service ) Inherited Methods ( ) [ ] string { if s . inherited Methods ! = nil { return s . inherited Methods } for svc : = s . Extends Service ; svc ! = nil ; svc = svc . Extends Service { for m : = range svc . Service . Methods { s . inherited Methods = append ( s . inherited Methods , m ) } } sort . Strings ( s . inherited Methods ) return s . inherited Methods } 
func ( m * Method ) Arguments ( ) [ ] * Field { var args [ ] * Field for _ , f : = range m . Method . Arguments { args = append ( args , & Field { f , m . state } ) } return args } 
func ( m * Method ) Arg List ( ) string { args : = [ ] string { " " + context Type ( ) } for _ , arg : = range m . Arguments ( ) { args = append ( args , arg . Declaration ( ) ) } return strings . Join ( args , " " ) } 
func ( m * Method ) Call List ( req Struct string ) string { args : = [ ] string { " " } for _ , arg : = range m . Arguments ( ) { args = append ( args , req Struct + " " + arg . Arg Struct Name ( ) ) } return strings . Join ( args , " " ) } 
func ( m * Method ) Ret Type ( ) string { if ! m . Has Return ( ) { return " " } return fmt . Sprintf ( " " , m . state . go Type ( m . Method . Return Type ) , " " ) } 
func ( m * Method ) Wrap Result ( resp Var string ) string { if ! m . Has Return ( ) { panic ( " " ) } if m . state . is Result Pointer ( m . Return Type ) { return resp Var } return " " + resp Var } 
func ( m * Method ) Return With ( resp Name string , err Name string ) string { if ! m . Has Return ( ) { return err Name } return fmt . Sprintf ( " " , resp Name , err Name ) } 
func ( a * Field ) Declaration ( ) string { return fmt . Sprintf ( " " , a . Name ( ) , a . Arg Type ( ) ) } 
func camel Case ( name string , public Name bool ) string { parts : = strings . Split ( name , " " ) start At : = 1 if public Name { start At = 0 } for i : = start At ; i < len ( parts ) ; i + + { name : = parts [ i ] if name = = " " { continue } } else { name = strings . To Upper ( name [ 0 : 1 ] ) + name [ 1 : ] } if is Initialism : = common Initialisms [ strings . To Upper ( name ) ] ; is Initialism { name = strings . To Upper ( name ) } parts [ i ] = name } return strings . Join ( parts , " " ) } 
func start Idle Sweep ( ch * Channel , opts * Channel Options ) * idle Sweep { is : = & idle Sweep { ch : ch , max Idle Time : opts . Max Idle Time , idle Check Interval : opts . Idle Check Interval , } is . start ( ) return is } 
func ( is * idle Sweep ) start ( ) { if is . started | | is . idle Check Interval < = 0 { return } is . ch . log . With Fields ( Log Field { " " , is . idle Check Interval } , Log Field { " " , is . max Idle Time } , ) . Info ( " " ) is . started = true is . stop Ch = make ( chan struct { } ) go is . poller Loop ( ) } 
func ( is * idle Sweep ) Stop ( ) { if ! is . started { return } is . started = false is . ch . log . Info ( " " ) close ( is . stop Ch ) } 
func Resolve With Go Path ( filename string ) ( string , error ) { for _ , file : = range go Path Candidates ( filename ) { if _ , err : = os . Stat ( file ) ; ! os . Is Not Exist ( err ) { return file , nil } } return " " , fmt . Errorf ( " " , filename ) } 
func set Extends ( state map [ string ] parse State ) error { for _ , v : = range state { for _ , s : = range v . services { if s . Extends = = " " { continue } var search Services [ ] * Service var search For string parts : = strings . Split N ( s . Extends , " " , 2 ) search For = s . Extends } else { include : = v . global . includes [ parts [ 0 ] ] s . Extends Prefix = include . pkg + " " search Services = state [ include . file ] . services search For = parts [ 1 ] } found Service : = sort . Search ( len ( search Services ) , func ( i int ) bool { return search Services [ i ] . Name > = search For } ) if found Service = = len ( search Services ) { return fmt . Errorf ( " " , s . Extends , s . Name ) } s . Extends Service = search Services [ found Service ] } } return nil } 
func ( f Error Handler Func ) Handle ( ctx context . Context , call * Inbound Call ) { if err : = f ( ctx , call ) ; err ! = nil { if Get System Error Code ( err ) = = Err Code Unexpected { call . log . With Fields ( f . get Log Fields ( ) . . . ) . With Fields ( Err Field ( err ) ) . Error ( " " ) } call . Response ( ) . Send System Error ( err ) } } 
func ( hmap * handler Map ) register ( h Handler , method string ) { hmap . Lock ( ) defer hmap . Unlock ( ) if hmap . handlers = = nil { hmap . handlers = make ( map [ string ] Handler ) } hmap . handlers [ method ] = h } 
func ( hmap * handler Map ) find ( method [ ] byte ) Handler { hmap . RLock ( ) handler : = hmap . handlers [ string ( method ) ] hmap . RUnlock ( ) return handler } 
func ( c tracing Headers Carrier ) Set ( key , val string ) { prefixed Key : = tracing Key Encoding . map And Cache ( key ) c [ prefixed Key ] = val } 
func ( c tracing Headers Carrier ) Foreach Key ( handler func ( key , val string ) error ) error { for k , v : = range c { if ! strings . Has Prefix ( k , tracing Key Prefix ) { continue } no Prefix Key : = tracing Key Decoding . map And Cache ( k ) if err : = handler ( no Prefix Key , v ) ; err ! = nil { return err } } return nil } 
func New Client ( hosts [ ] string , opt Fns . . . Option ) Client { opts : = get Options ( opt Fns ) if opts . external { return new External Client ( hosts , opts ) } if opts . num Clients > 1 { return new Internal Multi Client ( hosts , opts ) } return new Client ( hosts , opts ) } 
func score Addr ( iface net . Interface , addr net . Addr ) ( int , net . IP ) { var ip net . IP if net Addr , ok : = addr . ( * net . IPNet ) ; ok { ip = net Addr . IP } else if net IP , ok : = addr . ( * net . IPAddr ) ; ok { ip = net IP . IP } else { return - 1 , nil } var score int if ip . To 4 ( ) ! = nil { score + = 3 0 0 } if iface . Flags & net . Flag Loopback = = 0 & & ! ip . Is Loopback ( ) { score + = 1 0 0 if iface . Flags & net . Flag Up ! = 0 { score + = 1 0 0 } } if is Local Mac Addr ( iface . Hardware Addr ) { score - = 5 0 } return score , ip } 
func Listen IP ( ) ( net . IP , error ) { interfaces , err : = net . Interfaces ( ) if err ! = nil { return nil , err } return listen IP ( interfaces ) } 
func ( p * First Client ) Echo ( msg string ) ( r string , err error ) { if err = p . send Echo ( msg ) ; err ! = nil { return } return p . recv Echo ( ) } 
func Wrap ( l net . Listener ) net . Listener { return & listener { Listener : l , cond : sync . New Cond ( & sync . Mutex { } ) } } 
func ( s * listener ) Accept ( ) ( net . Conn , error ) { s . inc Ref ( ) defer s . dec Ref ( ) return s . Listener . Accept ( ) } 
func ( s * listener ) Close ( ) error { if err : = s . Listener . Close ( ) ; err ! = nil { return err } s . cond . L . Lock ( ) for s . refs > 0 { s . cond . Wait ( ) } s . cond . L . Unlock ( ) return nil } 
func Read Args V 2 ( r tchannel . Arg Readable ) ( [ ] byte , [ ] byte , error ) { var arg 2 , arg 3 [ ] byte if err : = tchannel . New Arg Reader ( r . Arg 2Reader ( ) ) . Read ( & arg 2 ) ; err ! = nil { return nil , nil , err } if err : = tchannel . New Arg Reader ( r . Arg 3Reader ( ) ) . Read ( & arg 3 ) ; err ! = nil { return nil , nil , err } return arg 2 , arg 3 , nil } 
func Write Args ( call * tchannel . Outbound Call , arg 2 , arg 3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . Outbound Call Response , error ) { if err : = tchannel . New Arg Writer ( call . Arg 2Writer ( ) ) . Write ( arg 2 ) ; err ! = nil { return nil , nil , nil , err } if err : = tchannel . New Arg Writer ( call . Arg 3Writer ( ) ) . Write ( arg 3 ) ; err ! = nil { return nil , nil , nil , err } resp : = call . Response ( ) var resp Arg 2 [ ] byte if err : = tchannel . New Arg Reader ( resp . Arg 2Reader ( ) ) . Read ( & resp Arg 2 ) ; err ! = nil { return nil , nil , nil , err } var resp Arg 3 [ ] byte if err : = tchannel . New Arg Reader ( resp . Arg 3Reader ( ) ) . Read ( & resp Arg 3 ) ; err ! = nil { return nil , nil , nil , err } return resp Arg 2 , resp Arg 3 , resp , nil } 
func Call ( ctx context . Context , ch * tchannel . Channel , host Port string , service Name , method string , arg 2 , arg 3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . Outbound Call Response , error ) { call , err : = ch . Begin Call ( ctx , host Port , service Name , method , nil ) if err ! = nil { return nil , nil , nil , err } return Write Args ( call , arg 2 , arg 3 ) } 
func Call SC ( ctx context . Context , sc * tchannel . Sub Channel , method string , arg 2 , arg 3 [ ] byte ) ( [ ] byte , [ ] byte , * tchannel . Outbound Call Response , error ) { call , err : = sc . Begin Call ( ctx , method , nil ) if err ! = nil { return nil , nil , nil , err } return Write Args ( call , arg 2 , arg 3 ) } 
func Call V 2 ( ctx context . Context , sc * tchannel . Sub Channel , c Args CArgs ) ( * CRes , error ) { call , err : = sc . Begin Call ( ctx , c Args . Method , c Args . Call Options ) if err ! = nil { return nil , err } arg 2 , arg 3 , res , err : = Write Args ( call , c Args . Arg 2 , c Args . Arg 3 ) if err ! = nil { return nil , err } return & CRes { Arg 2 : arg 2 , Arg 3 : arg 3 , App Error : res . Application Error ( ) , } , nil } 
func New Real Relay ( services map [ string ] [ ] string ) ( Relay , error ) { hosts : = & fixed Hosts { hosts : services } ch , err : = tchannel . New Channel ( " " , & tchannel . Channel Options { Relay Host : relaytest . Host Func ( hosts . Get ) , Logger : tchannel . New Level Logger ( tchannel . New Logger ( os . Stderr ) , tchannel . Log Level Warn ) , } ) if err ! = nil { return nil , err } if err : = ch . Listen And Serve ( " " ) ; err ! = nil { return nil , err } return & real Relay { ch : ch , hosts : hosts , } , nil } 
func New Server ( registrar tchannel . Registrar ) * Server { meta Handler : = new Meta Handler ( ) server : = & Server { ch : registrar , log : registrar . Logger ( ) , handlers : make ( map [ string ] handler ) , meta Handler : meta Handler , ctx Fn : default Context Fn , } server . Register ( new TChan Meta Server ( meta Handler ) ) if ch , ok : = registrar . ( * tchannel . Channel ) ; ok { } return server } 
func ( s * Server ) Register ( svr TChan Server , opts . . . Register Option ) { service : = svr . Service ( ) handler : = & handler { server : svr } for _ , opt : = range opts { opt . Apply ( handler ) } s . Lock ( ) s . handlers [ service ] = * handler s . Unlock ( ) for _ , m : = range svr . Methods ( ) { s . ch . Register ( s , service + " " + m ) } } 
func ( s * Server ) Register Health Handler ( f Health Func ) { wrapped : = func ( ctx Context , r Health Request ) ( bool , string ) { return f ( ctx ) } s . meta Handler . set Handler ( wrapped ) } 
func ( s * Server ) Set Context Fn ( f func ( ctx context . Context , method string , headers map [ string ] string ) Context ) { s . ctx Fn = f } 
func ( s * Server ) Handle ( ctx context . Context , call * tchannel . Inbound Call ) { op : = call . Method String ( ) service , method , ok : = get Service Method ( op ) if ! ok { log . Fatalf ( " " , op ) } s . RLock ( ) handler , ok : = s . handlers [ service ] s . RUnlock ( ) if ! ok { log . Fatalf ( " " , service ) } if err : = s . handle ( ctx , handler , method , call ) ; err ! = nil { s . on Error ( call , err ) } } 
func ( c System Err Code ) Metrics Key ( ) string { switch c { case Err Code Invalid : case Err Code Timeout : return " " case Err Code Cancelled : return " " case Err Code Busy : return " " case Err Code Declined : return " " case Err Code Unexpected : return " " case Err Code Bad Request : return " " case Err Code Network : return " " case Err Code Protocol : return " " default : return c . String ( ) } } 
func New System Error ( code System Err Code , msg string , args . . . interface { } ) error { return System Error { code : code , msg : fmt . Sprintf ( msg , args . . . ) } } 
func New Wrapped System Error ( code System Err Code , wrapped error ) error { if se , ok : = wrapped . ( System Error ) ; ok { return se } return System Error { code : code , msg : fmt . Sprint ( wrapped ) , wrapped : wrapped } } 
func ( se System Error ) Error ( ) string { return fmt . Sprintf ( " " , se . Code ( ) , se . msg ) } 
func Get Context Error ( err error ) error { if err = = context . Deadline Exceeded { return Err Timeout } if err = = context . Canceled { return Err Request Cancelled } return err } 
func Get System Error Code ( err error ) System Err Code { if err = = nil { return Err Code Invalid } if se , ok : = err . ( System Error ) ; ok { return se . Code ( ) } return Err Code Unexpected } 
func Get System Error Message ( err error ) string { if se , ok : = err . ( System Error ) ; ok { return se . Message ( ) } return err . Error ( ) } 
func get Timeout ( ctx context . Context ) time . Duration { deadline , ok : = ctx . Deadline ( ) if ! ok { return Default Connect Timeout } return deadline . Sub ( time . Now ( ) ) } 
func ( c * Connection ) ping ( ctx context . Context ) error { req : = & ping Req { id : c . Next Message ID ( ) } mex , err : = c . outbound . new Exchange ( ctx , c . opts . Frame Pool , req . message Type ( ) , req . ID ( ) , 1 ) if err ! = nil { return c . connection Error ( " " , err ) } defer c . outbound . remove Exchange ( req . ID ( ) ) if err : = c . send Message ( req ) ; err ! = nil { return c . connection Error ( " " , err ) } return c . recv Message ( ctx , & ping Res { } , mex ) } 
func ( c * Connection ) handle Ping Res ( frame * Frame ) bool { if err : = c . outbound . forward Peer Frame ( frame ) ; err ! = nil { c . log . With Fields ( Log Field { " " , frame . Header } ) . Warn ( " " ) return true } } 
func ( c * Connection ) handle Ping Req ( frame * Frame ) { if state : = c . read State ( ) ; state ! = connection Active { c . protocol Error ( frame . Header . ID , err Conn Not Active { " " , state } ) return } ping Res : = & ping Res { id : frame . Header . ID } if err : = c . send Message ( ping Res ) ; err ! = nil { c . connection Error ( " " , err ) } } 
func ( c * Connection ) send Message ( msg message ) error { frame : = c . opts . Frame Pool . Get ( ) if err : = frame . write ( msg ) ; err ! = nil { c . opts . Frame Pool . Release ( frame ) return err } select { case c . send Ch < - frame : return nil default : return Err Send Buffer Full } } 
func ( c * Connection ) recv Message ( ctx context . Context , msg message , mex * message Exchange ) error { frame , err : = mex . recv Peer Frame Of Type ( msg . message Type ( ) ) if err ! = nil { if err , ok : = err . ( error Message ) ; ok { return err . As System Error ( ) } return err } err = frame . read ( msg ) c . opts . Frame Pool . Release ( frame ) return err } 
func ( c * Connection ) Send System Error ( id uint 3 2 , span Span , err error ) error { frame : = c . opts . Frame Pool . Get ( ) if err : = frame . write ( & error Message { id : id , err Code : Get System Error Code ( err ) , tracing : span , message : Get System Error Message ( err ) , } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return fmt . Errorf ( " " , c . state ) } select { case c . send Ch < - frame : default : c . log . With Fields ( Log Field { " " , c . remote Peer Info } , Log Field { " " , id } , Err Field ( err ) , ) . Warn ( " " ) return fmt . Errorf ( " " ) } ) } 
func ( c * Connection ) connection Error ( site string , err error ) error { var close Log Fields Log Fields if err = = io . EOF { close Log Fields = Log Fields { { " " , " " } } } else { close Log Fields = Log Fields { { " " , " " } , Err Field ( err ) , } } c . stop Health Check ( ) err = c . log Connection Error ( site , err ) c . close ( close Log Fields . . . ) c . inbound . stop Exchanges ( err ) } return err } 
func ( c * Connection ) with State Lock ( f func ( ) error ) error { c . state Mut . Lock ( ) err : = f ( ) c . state Mut . Unlock ( ) return err } 
func ( c * Connection ) with State RLock ( f func ( ) error ) error { c . state Mut . RLock ( ) err : = f ( ) c . state Mut . RUnlock ( ) return err } 
func ( c * Connection ) read Frames ( _ uint 3 2 ) { header Buf : = make ( [ ] byte , Frame Header Size ) handle Err : = func ( err error ) { if ! c . close Network Called . Load ( ) { c . connection Error ( " " , err ) } else { c . log . Debugf ( " " , err ) } } for { return } frame : = c . opts . Frame Pool . Get ( ) if err : = frame . Read Body ( header Buf , c . conn ) ; err ! = nil { handle Err ( err ) c . opts . Frame Pool . Release ( frame ) return } c . update Last Activity ( frame ) var release Frame bool if c . relay = = nil { release Frame = c . handle Frame No Relay ( frame ) } else { release Frame = c . handle Frame Relay ( frame ) } if release Frame { c . opts . Frame Pool . Release ( frame ) } } } 
func ( c * Connection ) write Frames ( _ uint 3 2 ) { for { select { case f : = < - c . send Ch : if c . log . Enabled ( Log Level Debug ) { c . log . Debugf ( " " , f . Header ) } c . update Last Activity ( f ) err : = f . Write Out ( c . conn ) c . opts . Frame Pool . Release ( f ) if err ! = nil { c . connection Error ( " " , err ) return } case < - c . stop Ch : } return } } } 
func ( c * Connection ) update Last Activity ( frame * Frame ) { } } 
func ( c * Connection ) has Pending Calls ( ) bool { if c . inbound . count ( ) > 0 | | c . outbound . count ( ) > 0 { return true } if ! c . relay . can Close ( ) { return true } return false } 
func ( c * Connection ) check Exchanges ( ) { c . call On Exchange Change ( ) move State : = func ( from State , to State connection State ) bool { err : = c . with State Lock ( func ( ) error { if c . state ! = from State { return errors . New ( " " ) } c . state = to State return nil } ) return err = = nil } cur State : = c . read State ( ) orig State : = cur State if cur State ! = connection Closed & & c . stopped Exchanges . Load ( ) { if move State ( cur State , connection Closed ) { cur State = connection Closed } } if cur State = = connection Start Close { if ! c . relay . can Close ( ) { return } if c . inbound . count ( ) = = 0 & & move State ( connection Start Close , connection Inbound Closed ) { cur State = connection Inbound Closed } } if cur State = = connection Inbound Closed { return } if c . outbound . count ( ) = = 0 & & move State ( connection Inbound Closed , connection Closed ) { cur State = connection Closed } } if cur State ! = orig State { } c . log . With Fields ( Log Field { " " , cur State } , ) . Debug ( " " ) c . call On Close State Change ( ) } } 
func ( c * Connection ) close Network ( ) { c . stop Health Check ( ) c . close Network Called . Store ( true ) if err : = c . conn . Close ( ) ; err ! = nil { c . log . With Fields ( Log Field { " " , c . remote Peer Info } , Err Field ( err ) , ) . Warn ( " " ) } } 
func ( c * Connection ) get Last Activity Time ( ) time . Time { return time . Unix ( 0 , c . last Activity . Load ( ) ) } 
func Validate ( svc * parser . Service ) error { for _ , m : = range svc . Methods { if err : = validate Method ( svc , m ) ; err ! = nil { return err } } return nil } 
func fuzz Interval ( interval time . Duration ) time . Duration { return time . Duration ( rand . Int 6 3n ( int 6 4 ( interval ) ) ) } 
func ( c * Client ) log Failed Registration Retry ( err Logger tchannel . Logger , consecutive Failures uint ) { log Fn : = err Logger . Info if consecutive Failures > max Advertise Failures { log Fn = err Logger . Warn } log Fn ( " " ) } 
func ( c * Client ) advertise Loop ( ) { sleep For : = c . fuzzed Advertise Interval ( ) consecutive Failures : = uint ( 0 ) for { c . sleep ( sleep For ) if c . Is Closed ( ) { c . tchan . Logger ( ) . Infof ( " " ) return } if err : = c . send Advertise ( ) ; err ! = nil { consecutive Failures + + err Logger : = c . tchan . Logger ( ) . With Fields ( tchannel . Err Field ( err ) ) if consecutive Failures > = max Advertise Failures & & c . opts . Fail Strategy = = Fail Strategy Fatal { c . opts . Handler . On Error ( Err Advertise Failed { Cause : err , Will Retry : false } ) err Logger . Fatal ( " " ) } c . log Failed Registration Retry ( err Logger , consecutive Failures ) c . opts . Handler . On Error ( Err Advertise Failed { Cause : err , Will Retry : true } ) } } else { c . opts . Handler . On ( Readvertised ) sleep For = c . fuzzed Advertise Interval ( ) consecutive Failures = 0 } } } 
func ( c * Client ) initial Advertise ( ) error { var err error for attempt : = uint ( 0 ) ; attempt < max Advertise Failures ; attempt + + { err = c . send Advertise ( ) if err = = nil | | err = = err Ephemeral Peer { break } c . tchan . Logger ( ) . With Fields ( tchannel . Err Field ( err ) ) . Info ( " " ) c . sleep ( sleep For ) } return err } 
func ( p * Hyperbahn Client ) Discover ( query * Discovery Query ) ( r * Discovery Result _ , err error ) { if err = p . send Discover ( query ) ; err ! = nil { return } return p . recv Discover ( ) } 
func new Lazy Call Req ( f * Frame ) lazy Call Req { if msg Type : = f . Header . message Type ; msg Type ! = message Type Call Req { panic ( fmt . Errorf ( " " , msg Type ) ) } cr : = lazy Call Req { Frame : f } service Len : = f . Payload [ _service Len Index ] num Headers : = int ( f . Payload [ header Start ] ) cur : = int ( header Start ) + 1 for i : = 0 ; i < num Headers ; i + + { key Len : = int ( f . Payload [ cur ] ) cur + + key : = f . Payload [ cur : cur + key Len ] cur + = key Len val Len : = int ( f . Payload [ cur ] ) cur + + val : = f . Payload [ cur : cur + val Len ] cur + = val Len if bytes . Equal ( key , _caller Name Key Bytes ) { cr . caller = val } else if bytes . Equal ( key , _routing Delegate Key Bytes ) { cr . delegate = val } else if bytes . Equal ( key , _routing Key Key Bytes ) { cr . key = val } } cur + = 1 + check Sum Type . Checksum Size ( ) cur + = 2 cr . method = f . Payload [ cur : cur + arg 1Len ] return cr } 
func ( f lazy Call Req ) Service ( ) [ ] byte { l : = f . Payload [ _service Len Index ] return f . Payload [ _service Name Index : _service Name Index + l ] } 
func ( f lazy Call Req ) TTL ( ) time . Duration { ttl : = binary . Big Endian . Uint 3 2 ( f . Payload [ _ttl Index : _ttl Index + _ttl Len ] ) return time . Duration ( ttl ) * time . Millisecond } 
func ( f lazy Call Req ) Set TTL ( d time . Duration ) { ttl : = uint 3 2 ( d / time . Millisecond ) binary . Big Endian . Put Uint 3 2 ( f . Payload [ _ttl Index : _ttl Index + _ttl Len ] , ttl ) } 
func finishes Call ( f * Frame ) bool { switch f . message Type ( ) { case message Type Error : return true case message Type Call Res , message Type Call Res Continue : flags : = f . Payload [ _flags Index ] return flags & has More Fragments Flag = = 0 default : return false } } 
func ( ps * Platform Strings ) Flat ( ) [ ] string { unique : = make ( map [ string ] struct { } ) for _ , s : = range ps . Generic { unique [ s ] = struct { } { } } for _ , ss : = range ps . OS { for _ , s : = range ss { unique [ s ] = struct { } { } } } for _ , ss : = range ps . Arch { for _ , s : = range ss { unique [ s ] = struct { } { } } } for _ , ss : = range ps . Platform { for _ , s : = range ss { unique [ s ] = struct { } { } } } flat : = make ( [ ] string , 0 , len ( unique ) ) for s : = range unique { flat = append ( flat , s ) } sort . Strings ( flat ) return flat } 
func ( ps * Platform Strings ) Map ( f func ( s string ) ( string , error ) ) ( Platform Strings , [ ] error ) { var errors [ ] error map Slice : = func ( ss [ ] string ) ( [ ] string , error ) { rs : = make ( [ ] string , 0 , len ( ss ) ) for _ , s : = range ss { if r , err : = f ( s ) ; err ! = nil { errors = append ( errors , err ) } else if r ! = " " { rs = append ( rs , r ) } } return rs , nil } result , _ : = ps . Map Slice ( map Slice ) return result , errors } 
func ( ps * Platform Strings ) Map Slice ( f func ( [ ] string ) ( [ ] string , error ) ) ( Platform Strings , [ ] error ) { var errors [ ] error map Slice : = func ( ss [ ] string ) [ ] string { rs , err : = f ( ss ) if err ! = nil { errors = append ( errors , err ) return nil } return rs } map String Map : = func ( m map [ string ] [ ] string ) map [ string ] [ ] string { if m = = nil { return nil } rm : = make ( map [ string ] [ ] string ) for k , ss : = range m { ss = map Slice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) = = 0 { return nil } return rm } map Platform Map : = func ( m map [ Platform ] [ ] string ) map [ Platform ] [ ] string { if m = = nil { return nil } rm : = make ( map [ Platform ] [ ] string ) for k , ss : = range m { ss = map Slice ( ss ) if len ( ss ) > 0 { rm [ k ] = ss } } if len ( rm ) = = 0 { return nil } return rm } result : = Platform Strings { Generic : map Slice ( ps . Generic ) , OS : map String Map ( ps . OS ) , Arch : map String Map ( ps . Arch ) , Platform : map Platform Map ( ps . Platform ) , } return result , errors } 
func Expr From Value ( val interface { } ) bzl . Expr { if e , ok : = val . ( bzl . Expr ) ; ok { return e } rv : = reflect . Value Of ( val ) switch rv . Kind ( ) { case reflect . Bool : tok : = " " if rv . Bool ( ) { tok = " " } return & bzl . Literal Expr { Token : tok } case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 , reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return & bzl . Literal Expr { Token : fmt . Sprintf ( " " , val ) } case reflect . Float 3 2 , reflect . Float 6 4 : return & bzl . Literal Expr { Token : fmt . Sprintf ( " " , val ) } case reflect . String : return & bzl . String Expr { Value : val . ( string ) } case reflect . Slice , reflect . Array : var list [ ] bzl . Expr for i : = 0 ; i < rv . Len ( ) ; i + + { elem : = Expr From Value ( rv . Index ( i ) . Interface ( ) ) list = append ( list , elem ) } return & bzl . List Expr { List : list } case reflect . Map : rkeys : = rv . Map Keys ( ) sort . Sort ( by String ( rkeys ) ) args : = make ( [ ] bzl . Expr , len ( rkeys ) ) for i , rk : = range rkeys { label : = fmt . Sprintf ( " " , map Key String ( rk ) ) k : = & bzl . String Expr { Value : label } v : = Expr From Value ( rv . Map Index ( rk ) . Interface ( ) ) if l , ok : = v . ( * bzl . List Expr ) ; ok { l . Force Multi Line = true } args [ i ] = & bzl . Key Value Expr { Key : k , Value : v } } args = append ( args , & bzl . Key Value Expr { Key : & bzl . String Expr { Value : " " } , Value : & bzl . List Expr { } , } ) sel : = & bzl . Call Expr { X : & bzl . Ident { Name : " " } , List : [ ] bzl . Expr { & bzl . Dict Expr { List : args , Force Multi Line : true } } , } return sel case reflect . Struct : switch val : = val . ( type ) { case Glob Value : patterns Value : = Expr From Value ( val . Patterns ) glob Args : = [ ] bzl . Expr { patterns Value } if len ( val . Excludes ) > 0 { excludes Value : = Expr From Value ( val . Excludes ) glob Args = append ( glob Args , & bzl . Key Value Expr { Key : & bzl . String Expr { Value : " " } , Value : excludes Value , } ) } return & bzl . Call Expr { X : & bzl . Literal Expr { Token : " " } , List : glob Args , } case Platform Strings : var pieces [ ] bzl . Expr if len ( val . Generic ) > 0 { pieces = append ( pieces , Expr From Value ( val . Generic ) ) } if len ( val . OS ) > 0 { pieces = append ( pieces , Expr From Value ( val . OS ) ) } if len ( val . Arch ) > 0 { pieces = append ( pieces , Expr From Value ( val . Arch ) ) } if len ( val . Platform ) > 0 { pieces = append ( pieces , Expr From Value ( val . Platform ) ) } if len ( pieces ) = = 0 { return & bzl . List Expr { } } else if len ( pieces ) = = 1 { return pieces [ 0 ] } else { e : = pieces [ 0 ] if list , ok : = e . ( * bzl . List Expr ) ; ok { list . Force Multi Line = true } for _ , piece : = range pieces [ 1 : ] { e = & bzl . Binary Expr { X : e , Y : piece , Op : " " } } return e } } } log . Panicf ( " " , val ) return nil } 
func Get Proto Config ( c * config . Config ) * Proto Config { pc : = c . Exts [ proto Name ] if pc = = nil { return nil } return pc . ( * Proto Config ) } 
func infer Proto Mode ( c * config . Config , rel string , f * rule . File ) { pc : = Get Proto Config ( c ) if pc . Mode ! = Default Mode | | pc . Mode Explicit { return } if pc . Go Prefix = = well Known Types Go Prefix { pc . Mode = Legacy Mode return } if path . Base ( rel ) = = " " { pc . Mode = Disable Mode return } if f = = nil { return } mode : = Default Mode outer : for _ , l : = range f . Loads { name : = l . Name ( ) if name = = " " { break } if name = = " " { mode = Legacy Mode break } for _ , sym : = range l . Symbols ( ) { if sym = = " " { mode = Disable Mode break outer } } } if mode = = Default Mode | | pc . Mode = = mode | | c . Should Fix & & mode = = Legacy Mode { return } pc . Mode = mode } 
func Map Expr Strings ( e bzl . Expr , f func ( string ) string ) bzl . Expr { if e = = nil { return nil } switch expr : = e . ( type ) { case * bzl . String Expr : s : = f ( expr . Value ) if s = = " " { return nil } ret : = * expr ret . Value = s return & ret case * bzl . List Expr : var list [ ] bzl . Expr for _ , elem : = range expr . List { elem = Map Expr Strings ( elem , f ) if elem ! = nil { list = append ( list , elem ) } } if len ( list ) = = 0 & & len ( expr . List ) > 0 { return nil } ret : = * expr ret . List = list return & ret case * bzl . Dict Expr : var cases [ ] bzl . Expr is Empty : = true for _ , kv : = range expr . List { keyval , ok : = kv . ( * bzl . Key Value Expr ) if ! ok { log . Panicf ( " " , kv ) } value : = Map Expr Strings ( keyval . Value , f ) if value ! = nil { cases = append ( cases , & bzl . Key Value Expr { Key : keyval . Key , Value : value } ) if key , ok : = keyval . Key . ( * bzl . String Expr ) ; ! ok | | key . Value ! = " " { is Empty = false } } } if is Empty { return nil } ret : = * expr ret . List = cases return & ret case * bzl . Call Expr : if x , ok : = expr . X . ( * bzl . Ident ) ; ! ok | | x . Name ! = " " | | len ( expr . List ) ! = 1 { log . Panicf ( " " , e ) } arg : = Map Expr Strings ( expr . List [ 0 ] , f ) if arg = = nil { return nil } call : = * expr call . List [ 0 ] = arg return & call case * bzl . Binary Expr : x : = Map Expr Strings ( expr . X , f ) y : = Map Expr Strings ( expr . Y , f ) if x = = nil { return y } if y = = nil { return x } binop : = * expr binop . X = x binop . Y = y return & binop default : return nil } } 
func Flatten Expr ( e bzl . Expr ) bzl . Expr { ps , err : = extract Platform Strings Exprs ( e ) if err ! = nil { return e } ls : = make List Squasher ( ) add Elem : = func ( e bzl . Expr ) bool { s , ok : = e . ( * bzl . String Expr ) if ! ok { return false } ls . add ( s ) return true } add List : = func ( e bzl . Expr ) bool { l , ok : = e . ( * bzl . List Expr ) if ! ok { return false } for _ , elem : = range l . List { if ! add Elem ( elem ) { return false } } return true } add Dict : = func ( d * bzl . Dict Expr ) bool { for _ , kv : = range d . List { if ! add List ( kv . ( * bzl . Key Value Expr ) . Value ) { return false } } return true } if ps . generic ! = nil { if ! add List ( ps . generic ) { return e } } for _ , d : = range [ ] * bzl . Dict Expr { ps . os , ps . arch , ps . platform } { if d = = nil { continue } if ! add Dict ( d ) { return e } } return ls . list ( ) } 
func extract Platform Strings Exprs ( expr bzl . Expr ) ( platform Strings Exprs , error ) { var ps platform Strings Exprs if expr = = nil { return ps , nil } for { binop , ok : = expr . ( * bzl . Binary Expr ) if ! ok { parts = append ( parts , expr ) break } parts = append ( parts , binop . Y ) expr = binop . X } } ps . generic = part case * bzl . Call Expr : x , ok : = part . X . ( * bzl . Ident ) if ! ok | | x . Name ! = " " | | len ( part . List ) ! = 1 { return platform Strings Exprs { } , fmt . Errorf ( " " ) } arg , ok : = part . List [ 0 ] . ( * bzl . Dict Expr ) if ! ok { return platform Strings Exprs { } , fmt . Errorf ( " " ) } var dict * * bzl . Dict Expr for _ , item : = range arg . List { kv : = item . ( * bzl . Key Value Expr ) k , ok : = kv . Key . ( * bzl . String Expr ) if ! ok { return platform Strings Exprs { } , fmt . Errorf ( " " ) } if k . Value = = " " { continue } key , err : = label . Parse ( k . Value ) if err ! = nil { return platform Strings Exprs { } , fmt . Errorf ( " " , k . Value ) } if Known OSSet [ key . Name ] { dict = & ps . os break } if Known Arch Set [ key . Name ] { dict = & ps . arch break } os Arch : = strings . Split ( key . Name , " " ) if len ( os Arch ) ! = 2 | | ! Known OSSet [ os Arch [ 0 ] ] | | ! Known Arch Set [ os Arch [ 1 ] ] { return platform Strings Exprs { } , fmt . Errorf ( " " , k . Value ) } dict = & ps . platform break } if dict = = nil { } if * dict ! = nil { return platform Strings Exprs { } , fmt . Errorf ( " " ) } * dict = arg } } return ps , nil } 
func make Platform Strings Expr ( ps platform Strings Exprs ) bzl . Expr { make Select : = func ( dict * bzl . Dict Expr ) bzl . Expr { return & bzl . Call Expr { X : & bzl . Ident { Name : " " } , List : [ ] bzl . Expr { dict } , } } force Multiline : = func ( e bzl . Expr ) { switch e : = e . ( type ) { case * bzl . List Expr : e . Force Multi Line = true case * bzl . Call Expr : e . List [ 0 ] . ( * bzl . Dict Expr ) . Force Multi Line = true } } var parts [ ] bzl . Expr if ps . generic ! = nil { parts = append ( parts , ps . generic ) } if ps . os ! = nil { parts = append ( parts , make Select ( ps . os ) ) } if ps . arch ! = nil { parts = append ( parts , make Select ( ps . arch ) ) } if ps . platform ! = nil { parts = append ( parts , make Select ( ps . platform ) ) } if len ( parts ) = = 0 { return nil } if len ( parts ) = = 1 { return parts [ 0 ] } expr : = parts [ 0 ] force Multiline ( expr ) for _ , part : = range parts [ 1 : ] { force Multiline ( part ) expr = & bzl . Binary Expr { Op : " " , X : expr , Y : part , } } return expr } 
func ( p Platform ) String ( ) string { switch { case p . OS ! = " " & & p . Arch ! = " " : return p . OS + " " + p . Arch case p . OS ! = " " : return p . OS case p . Arch ! = " " : return p . Arch default : return " " } } 
func Find ( dir string ) ( string , error ) { dir , err : = filepath . Abs ( dir ) if err ! = nil { return " " , err } for { _ , err = os . Stat ( filepath . Join ( dir , workspace File ) ) if err = = nil { return dir , nil } if ! os . Is Not Exist ( err ) { return " " , err } if strings . Has Suffix ( dir , string ( os . Path Separator ) ) { } dir = filepath . Dir ( dir ) } } 
func move Locations ( from , to , str string ) string { matches : = locations Regexp . Find All String Submatch Index ( str , - 1 ) buf : = new ( bytes . Buffer ) pos : = 0 for _ , match : = range matches { buf . Write String ( str [ pos : match [ 2 ] ] ) label : = str [ match [ 2 ] : match [ 3 ] ] moved : = move Label ( from , to , label ) buf . Write String ( moved ) buf . Write String ( str [ match [ 3 ] : match [ 1 ] ] ) pos = match [ 1 ] } buf . Write String ( str [ pos : ] ) return buf . String ( ) } 
func run Gazelle ( mode mode , dirs [ ] string ) error { if mode = = fast Mode & & len ( dirs ) = = 0 { return nil } args : = [ ] string { os . Getenv ( " " ) , " " , * gazelle Label , " " , " " } args = append ( args , " " ) if mode = = fast Mode { args = append ( args , " " ) args = append ( args , dirs . . . ) } cmd : = exec . Command ( args [ 0 ] , args [ 1 : ] . . . ) cmd . Stdout = os . Stdout cmd . Stderr = os . Stderr log . Printf ( " \n " , strings . Join ( cmd . Args , " " ) ) return cmd . Run ( ) } 
func restore Build Files In Repo ( ) { err : = filepath . Walk ( " " , func ( path string , info os . File Info , err error ) error { if err ! = nil { log . Print ( err ) return nil } restore Build Files In Dir ( path ) return nil } ) if err ! = nil { log . Print ( err ) } } 
func Fix Loads ( f * rule . File , known Loads [ ] rule . Load Info ) { known Files : = make ( map [ string ] bool ) known Kinds : = make ( map [ string ] string ) for _ , l : = range known Loads { known Files [ l . Name ] = true for _ , k : = range l . Symbols { known Kinds [ k ] = l . Name } } other Loaded Kinds : = make ( map [ string ] bool ) for _ , l : = range f . Loads { if known Files [ l . Name ( ) ] { loads = append ( loads , l ) continue } for _ , sym : = range l . Symbols ( ) { other Loaded Kinds [ sym ] = true } } for _ , r : = range f . Rules { kind : = r . Kind ( ) if file , ok : = known Kinds [ kind ] ; ok & & ! other Loaded Kinds [ kind ] { if used Kinds [ file ] = = nil { used Kinds [ file ] = make ( map [ string ] bool ) } used Kinds [ file ] [ kind ] = true } } first : = true for _ , l : = range loads { if l . Name ( ) ! = file { continue } if first { fix Load ( l , file , used Kinds [ file ] , known Kinds ) first = false } else { fix Load ( l , file , nil , known Kinds ) } if l . Is Empty ( ) { l . Delete ( ) } } if first { load : = fix Load ( nil , file , used Kinds [ file ] , known Kinds ) if load ! = nil { index : = new Load Index ( f , known . After ) load . Insert ( f , index ) } } } } 
func fix Load ( load * rule . Load , file string , kinds map [ string ] bool , known Kinds map [ string ] string ) * rule . Load { if load = = nil { if len ( kinds ) = = 0 { return nil } load = rule . New Load ( file ) } for k : = range kinds { load . Add ( k ) } for _ , k : = range load . Symbols ( ) { if known Kinds [ k ] ! = " " & & ! kinds [ k ] { load . Remove ( k ) } } return load } 
func new Load Index ( f * rule . File , after [ ] string ) int { if len ( after ) = = 0 { return 0 } index : = 0 for _ , r : = range f . Rules { for _ , a : = range after { if r . Kind ( ) = = a & & r . Index ( ) > = index { index = r . Index ( ) + 1 } } } return index } 
func Check Gazelle Loaded ( f * rule . File ) error { need Gazelle : = false for _ , l : = range f . Loads { if strings . Has Prefix ( l . Name ( ) , " " ) { need Gazelle = true } } if ! need Gazelle { return nil } for _ , r : = range f . Rules { if r . Name ( ) = = " " { return nil } } for _ , d : = range f . Directives { if d . Key ! = " " { continue } if fs : = strings . Fields ( d . Value ) ; len ( fs ) > 0 & & fs [ 0 ] = = " " { return nil } } return fmt . Errorf ( ` %s : error : bazel _gazelle is not declared in WORKSPACE . Without this repository , Gazelle cannot safely modify the WORKSPACE file . See the instructions at https : If the bazel _gazelle is declared inside a macro , you can suppress this error by adding a comment like this to WORKSPACE : # gazelle :repo bazel _gazelle ` , f . Path ) } 
func remove Legacy Go Repository ( f * rule . File ) { for _ , l : = range f . Loads { if l . Name ( ) = = " " { l . Remove ( " " ) if l . Is Empty ( ) { l . Delete ( ) } } } } 
func ( x Version ) Compare ( y Version ) int { n : = len ( x ) if len ( y ) < n { n = len ( y ) } for i : = 0 ; i < n ; i + + { cmp : = x [ i ] - y [ i ] if cmp ! = 0 { return cmp } } return len ( x ) - len ( y ) } 
func Parse Version ( vs string ) ( Version , error ) { i : = strings . Index Byte ( vs , ' - ' ) if i > = 0 { vs = vs [ : i ] } cstrs : = strings . Split ( vs , " " ) v : = make ( Version , len ( cstrs ) ) for i , cstr : = range cstrs { cn , err : = strconv . Atoi ( cstr ) if err ! = nil { return nil , fmt . Errorf ( " " , cstr ) } if cn < 0 { return nil , fmt . Errorf ( " " , cstr ) } v [ i ] = cn } return v , nil } 
func Empty File ( path , pkg string ) * File { return & File { File : & bzl . File { Path : path , Type : bzl . Type Build } , Path : path , Pkg : pkg , } } 
func Load File ( path , pkg string ) ( * File , error ) { data , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } return Load Data ( path , pkg , data ) } 
func Load Workspace File ( path , pkg string ) ( * File , error ) { data , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } return Load Workspace Data ( path , pkg , data ) } 
func Load Macro File ( path , pkg , def Name string ) ( * File , error ) { data , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } return Load Macro Data ( path , pkg , def Name , data ) } 
func Empty Macro File ( path , pkg , def Name string ) ( * File , error ) { _ , err : = os . Create ( path ) if err ! = nil { return nil , err } return Load Macro Data ( path , pkg , def Name , nil ) } 
func Load Data ( path , pkg string , data [ ] byte ) ( * File , error ) { ast , err : = bzl . Parse Build ( path , data ) if err ! = nil { return nil , err } return Scan AST ( pkg , ast ) , nil } 
func Load Workspace Data ( path , pkg string , data [ ] byte ) ( * File , error ) { ast , err : = bzl . Parse Workspace ( path , data ) if err ! = nil { return nil , err } return Scan AST ( pkg , ast ) , nil } 
func Load Macro Data ( path , pkg , def Name string , data [ ] byte ) ( * File , error ) { ast , err : = bzl . Parse Bzl ( path , data ) if err ! = nil { return nil , err } return Scan ASTBody ( pkg , def Name , ast ) , nil } 
func Scan AST ( pkg string , bzl File * bzl . File ) * File { return Scan ASTBody ( pkg , " " , bzl File ) } 
func Scan ASTBody ( pkg , def Name string , bzl File * bzl . File ) * File { f : = & File { File : bzl File , Pkg : pkg , Path : bzl File . Path , } var def Stmt * bzl . Def Stmt f . Rules , f . Loads , def Stmt = scan Exprs ( def Name , bzl File . Stmt ) if def Stmt ! = nil { f . Rules , _ , _ = scan Exprs ( " " , def Stmt . Body ) f . function = & function { stmt : def Stmt , inserted : true , } if len ( def Stmt . Body ) = = 1 { if v , ok : = def Stmt . Body [ 0 ] . ( * bzl . Branch Stmt ) ; ok & & v . Token = = " " { f . function . has Pass = true } } } else if def Name ! = " " { f . function = & function { stmt : & bzl . Def Stmt { Name : def Name } , inserted : false , } } f . Directives = Parse Directives ( bzl File ) return f } 
func Match Build File Name ( dir string , names [ ] string , files [ ] os . File Info ) string { for _ , name : = range names { for _ , fi : = range files { if fi . Name ( ) = = name & & ! fi . Is Dir ( ) { return filepath . Join ( dir , name ) } } } return " " } 
func ( f * File ) Sync Macro File ( from * File ) { from Func : = * from . function . stmt _ , _ , to Func : = scan Exprs ( from . function . stmt . Name , f . File . Stmt ) if to Func ! = nil { * to Func = from Func } else { f . File . Stmt = append ( f . File . Stmt , & from Func ) } } 
func ( f * File ) Macro Name ( ) string { if f . function ! = nil & & f . function . stmt ! = nil { return f . function . stmt . Name } return " " } 
func ( f * File ) Sync ( ) { var load Inserts , load Deletes , load Stmts [ ] * stmt var r , w int for r , w = 0 , 0 ; r < len ( f . Loads ) ; r + + { s : = f . Loads [ r ] s . sync ( ) if s . deleted { load Deletes = append ( load Deletes , & s . stmt ) continue } if s . inserted { load Inserts = append ( load Inserts , & s . stmt ) s . inserted = false } else { load Stmts = append ( load Stmts , & s . stmt ) } f . Loads [ w ] = s w + + } f . Loads = f . Loads [ : w ] var rule Inserts , rule Deletes , rule Stmts [ ] * stmt for r , w = 0 , 0 ; r < len ( f . Rules ) ; r + + { s : = f . Rules [ r ] s . sync ( ) if s . deleted { rule Deletes = append ( rule Deletes , & s . stmt ) continue } if s . inserted { rule Inserts = append ( rule Inserts , & s . stmt ) s . inserted = false } else { rule Stmts = append ( rule Stmts , & s . stmt ) } f . Rules [ w ] = s w + + } f . Rules = f . Rules [ : w ] if f . function = = nil { deletes : = append ( rule Deletes , load Deletes . . . ) inserts : = append ( rule Inserts , load Inserts . . . ) stmts : = append ( rule Stmts , load Stmts . . . ) update Stmt ( & f . File . Stmt , inserts , deletes , stmts ) } else { update Stmt ( & f . File . Stmt , load Inserts , load Deletes , load Stmts ) if f . function . has Pass & & len ( rule Inserts ) > 0 { f . function . stmt . Body = [ ] bzl . Expr { } f . function . has Pass = false } update Stmt ( & f . function . stmt . Body , rule Inserts , rule Deletes , rule Stmts ) if len ( f . function . stmt . Body ) = = 0 { f . function . stmt . Body = append ( f . function . stmt . Body , & bzl . Branch Stmt { Token : " " } ) f . function . has Pass = true } if ! f . function . inserted { f . File . Stmt = append ( f . File . Stmt , f . function . stmt ) f . function . inserted = true } } } 
func ( f * File ) Format ( ) [ ] byte { f . Sync ( ) return bzl . Format ( f . File ) } 
func ( f * File ) Save ( path string ) error { f . Sync ( ) data : = bzl . Format ( f . File ) return ioutil . Write File ( path , data , 0 6 6 6 ) } 
func ( f * File ) Has Default Visibility ( ) bool { for _ , r : = range f . Rules { if r . Kind ( ) = = " " & & r . Attr ( " " ) ! = nil { return true } } return false } 
func New Load ( name string ) * Load { return & Load { stmt : stmt { expr : & bzl . Load Stmt { Module : & bzl . String Expr { Value : name } , Force Compact : true , } , } , name : name , symbols : make ( map [ string ] ident Pair ) , } } 
func ( l * Load ) Symbols ( ) [ ] string { syms : = make ( [ ] string , 0 , len ( l . symbols ) ) for sym : = range l . symbols { syms = append ( syms , sym ) } sort . Strings ( syms ) return syms } 
func ( l * Load ) Has ( sym string ) bool { _ , ok : = l . symbols [ sym ] return ok } 
func ( l * Load ) Add ( sym string ) { if _ , ok : = l . symbols [ sym ] ; ! ok { i : = & bzl . Ident { Name : sym } l . symbols [ sym ] = ident Pair { to : i , from : i } l . updated = true } } 
func ( l * Load ) Remove ( sym string ) { if _ , ok : = l . symbols [ sym ] ; ok { delete ( l . symbols , sym ) l . updated = true } } 
func ( l * Load ) Insert ( f * File , index int ) { l . index = index l . inserted = true f . Loads = append ( f . Loads , l ) } 
func New Rule ( kind , name string ) * Rule { name Attr : = & bzl . Assign Expr { LHS : & bzl . Ident { Name : " " } , RHS : & bzl . String Expr { Value : name } , Op : " " , } r : = & Rule { stmt : stmt { expr : & bzl . Call Expr { X : & bzl . Ident { Name : kind } , List : [ ] bzl . Expr { name Attr } , } , } , kind : kind , attrs : map [ string ] * bzl . Assign Expr { " " : name Attr } , private : map [ string ] interface { } { } , } return r } 
func ( r * Rule ) Set Kind ( kind string ) { r . kind = kind r . updated = true } 
func ( r * Rule ) Attr Keys ( ) [ ] string { keys : = make ( [ ] string , 0 , len ( r . attrs ) ) for k : = range r . attrs { keys = append ( keys , k ) } sort . Slice Stable ( keys , func ( i , j int ) bool { if cmp : = bt . Name Priority [ keys [ i ] ] - bt . Name Priority [ keys [ j ] ] ; cmp ! = 0 { return cmp < 0 } return keys [ i ] < keys [ j ] } ) return keys } 
func ( r * Rule ) Attr ( key string ) bzl . Expr { attr , ok : = r . attrs [ key ] if ! ok { return nil } return attr . RHS } 
func ( r * Rule ) Attr String ( key string ) string { attr , ok : = r . attrs [ key ] if ! ok { return " " } str , ok : = attr . RHS . ( * bzl . String Expr ) if ! ok { return " " } return str . Value } 
func ( r * Rule ) Attr Strings ( key string ) [ ] string { attr , ok : = r . attrs [ key ] if ! ok { return nil } list , ok : = attr . RHS . ( * bzl . List Expr ) if ! ok { return nil } strs : = make ( [ ] string , 0 , len ( list . List ) ) for _ , e : = range list . List { if str , ok : = e . ( * bzl . String Expr ) ; ok { strs = append ( strs , str . Value ) } } return strs } 
func ( r * Rule ) Del Attr ( key string ) { delete ( r . attrs , key ) r . updated = true } 
func ( r * Rule ) Set Attr ( key string , value interface { } ) { rhs : = Expr From Value ( value ) if attr , ok : = r . attrs [ key ] ; ok { attr . RHS = rhs } else { r . attrs [ key ] = & bzl . Assign Expr { LHS : & bzl . Ident { Name : key } , RHS : rhs , Op : " " , } } r . updated = true } 
func ( r * Rule ) Private Attr Keys ( ) [ ] string { keys : = make ( [ ] string , 0 , len ( r . private ) ) for k : = range r . private { keys = append ( keys , k ) } sort . Strings ( keys ) return keys } 
func ( r * Rule ) Set Private Attr ( key string , value interface { } ) { r . private [ key ] = value } 
func ( r * Rule ) Insert ( f * File ) { if f . function = = nil { stmt = f . File . Stmt } else { stmt = f . function . stmt . Body } r . index = len ( stmt ) r . inserted = true f . Rules = append ( f . Rules , r ) } 
func ( r * Rule ) Is Empty ( info Kind Info ) bool { if info . Non Empty Attrs = = nil { return false } for k : = range info . Non Empty Attrs { if _ , ok : = r . attrs [ k ] ; ok { return false } } return true } 
func Should Keep ( e bzl . Expr ) bool { for _ , c : = range append ( e . Comment ( ) . Before , e . Comment ( ) . Suffix . . . ) { text : = strings . Trim Space ( strings . Trim Prefix ( c . Token , " " ) ) if text = = " " { return true } } return false } 
func Check Internal Visibility ( rel , visibility string ) string { if i : = strings . Last Index ( rel , " " ) ; i > = 0 { visibility = fmt . Sprintf ( " " , rel [ : i ] ) } else if strings . Has Prefix ( rel , " " ) { visibility = " " } return visibility } 
func New ( repo , pkg , name string ) Label { return Label { Repo : repo , Pkg : pkg , Name : name } } 
func Parse ( s string ) ( Label , error ) { orig Str : = s relative : = true var repo string if strings . Has Prefix ( s , " " ) { relative = false end Repo : = strings . Index ( s , " " ) if end Repo < 0 { return No Label , fmt . Errorf ( " " , orig Str ) } repo = s [ len ( " " ) : end Repo ] if ! label Repo Regexp . Match String ( repo ) { return No Label , fmt . Errorf ( " " , orig Str ) } s = s [ end Repo : ] } var pkg string if strings . Has Prefix ( s , " " ) { relative = false end Pkg : = strings . Index ( s , " " ) if end Pkg < 0 { pkg = s [ len ( " " ) : ] s = " " } else { pkg = s [ len ( " " ) : end Pkg ] s = s [ end Pkg : ] } if ! label Pkg Regexp . Match String ( pkg ) { return No Label , fmt . Errorf ( " " , orig Str ) } } if s = = " " { return No Label , fmt . Errorf ( " " , orig Str ) } name : = strings . Trim Prefix ( s , " " ) if ! label Name Regexp . Match String ( name ) { return No Label , fmt . Errorf ( " " , orig Str ) } if pkg = = " " & & name = = " " { return No Label , fmt . Errorf ( " " , orig Str ) } if name = = " " { name = path . Base ( pkg ) } return Label { Repo : repo , Pkg : pkg , Name : name , Relative : relative , } , nil } 
func ( l Label ) Abs ( repo , pkg string ) Label { if ! l . Relative { return l } return Label { Repo : repo , Pkg : pkg , Name : l . Name } } 
func ( l Label ) Rel ( repo , pkg string ) Label { if l . Relative | | l . Repo ! = repo { return l } if l . Pkg = = pkg { return Label { Name : l . Name , Relative : true } } return Label { Pkg : l . Pkg , Name : l . Name } } 
func ( l Label ) Equal ( other Label ) bool { return l . Repo = = other . Repo & & l . Pkg = = other . Pkg & & l . Name = = other . Name & & l . Relative = = other . Relative } 
func ( l Label ) Contains ( other Label ) bool { if l . Relative { log . Panicf ( " " , l ) } if other . Relative { log . Panicf ( " " , other ) } result : = l . Repo = = other . Repo & & pathtools . Has Prefix ( other . Pkg , l . Pkg ) return result } 
func Import Path To Bazel Repo Name ( importpath string ) string { importpath = strings . To Lower ( importpath ) components : = strings . Split ( importpath , " " ) labels : = strings . Split ( components [ 0 ] , " " ) var reversed [ ] string for i : = range labels { l : = labels [ len ( labels ) - i - 1 ] reversed = append ( reversed , l ) } repo : = strings . Join ( append ( reversed , components [ 1 : ] . . . ) , " " ) return strings . New Replacer ( " " , " " , " " , " " ) . Replace ( repo ) } 
func is Semver Prefix ( v string ) bool { dots : = 0 for i : = 0 ; i < len ( v ) ; i + + { switch v [ i ] { case ' - ' , ' + ' : return false case ' . ' : dots + + if dots > = 2 { return false } } } return true } 
func generate From Path ( w io . Writer , root Path string ) error { return filepath . Walk ( root Path , func ( path string , info os . File Info , err error ) error { if err ! = nil { return err } if ! strings . Has Suffix ( path , " " ) { return nil } rel Path , err : = filepath . Rel ( root Path , path ) if err ! = nil | | strings . Has Prefix ( rel Path , " " ) { log . Panicf ( " " , path , root Path ) } rel Path = filepath . To Slash ( rel Path ) if strings . Has Prefix ( rel Path , " " ) { proto Label , go Label : = proto Labels ( " " , " " ) fmt . Fprintf ( w , " \n " , rel Path , proto Label , package Path , go Label ) return nil } package Path , package Name , err : = load Go Package ( path ) if err ! = nil { log . Print ( err ) return nil } proto Label , go Label : = proto Labels ( rel Path , package Name ) fmt . Fprintf ( w , " \n " , rel Path , proto Label , package Path , go Label ) return nil } ) } 
func Walk ( c * config . Config , cexts [ ] config . Configurer , dirs [ ] string , mode Mode , wf Walk Func ) { known Directives : = make ( map [ string ] bool ) for _ , cext : = range cexts { for _ , d : = range cext . Known Directives ( ) { known Directives [ d ] = true } } symlinks : = symlink Resolver { visited : [ ] string { c . Repo Root } } update Rels : = build Update Rel Map ( c . Repo Root , dirs ) var visit func ( * config . Config , string , string , bool ) visit = func ( c * config . Config , dir , rel string , update Parent bool ) { have Error : = false if err ! = nil { log . Print ( err ) return } f , err : = load Build File ( c , rel , dir , files ) if err ! = nil { log . Print ( err ) have Error = true } c = configure ( cexts , known Directives , c , rel , f ) wc : = get Walk Config ( c ) if wc . is Excluded ( rel , " " ) { return } var subdirs , regular Files [ ] string for _ , fi : = range files { base : = fi . Name ( ) switch { case base = = " " | | wc . is Excluded ( rel , base ) : continue case fi . Is Dir ( ) | | fi . Mode ( ) & os . Mode Symlink ! = 0 & & symlinks . follow ( c , dir , rel , base ) : subdirs = append ( subdirs , base ) default : regular Files = append ( regular Files , base ) } } should Update : = should Update ( rel , mode , update Parent , update Rels ) for _ , sub : = range subdirs { if sub Rel : = path . Join ( rel , sub ) ; should Visit ( sub Rel , mode , update Rels ) { visit ( c , filepath . Join ( dir , sub ) , sub Rel , should Update ) } } update : = ! have Error & & ! wc . ignore & & should Update if should Call ( rel , mode , update Rels ) { gen Files : = find Gen Files ( wc , f ) wf ( dir , rel , c , update , f , subdirs , regular Files , gen Files ) } } visit ( c , c . Repo Root , " " , false ) } 
func build Update Rel Map ( root string , dirs [ ] string ) map [ string ] bool { rel Map : = make ( map [ string ] bool ) for _ , dir : = range dirs { rel , _ : = filepath . Rel ( root , dir ) rel = filepath . To Slash ( rel ) if rel = = " " { rel = " " } i : = 0 for { next : = strings . Index Byte ( rel [ i : ] , ' / ' ) + i if next - i < 0 { rel Map [ rel ] = true break } prefix : = rel [ : next ] rel Map [ prefix ] = rel Map [ prefix ] i = next + 1 } } return rel Map } 
func should Call ( rel string , mode Mode , update Rels map [ string ] bool ) bool { return mode ! = Update Dirs Mode | | update Rels [ rel ] } 
func should Update ( rel string , mode Mode , update Parent bool , update Rels map [ string ] bool ) bool { return mode = = Visit All Update Subdirs Mode & & update Parent | | update Rels [ rel ] } 
func should Visit ( rel string , mode Mode , update Rels map [ string ] bool ) bool { if mode ! = Update Dirs Mode { return true } _ , ok : = update Rels [ rel ] return ok } 
func ( r * symlink Resolver ) follow ( c * config . Config , dir , rel , base string ) bool { if dir = = c . Repo Root & & strings . Has Prefix ( base , " " ) { } link Rel : = path . Join ( rel , base ) for _ , follow : = range wc . follow { if link Rel = = follow { return true } } dest , err : = filepath . Eval Symlinks ( fullpath ) if err ! = nil { return false } if ! filepath . Is Abs ( dest ) { dest , err = filepath . Abs ( filepath . Join ( dir , dest ) ) if err ! = nil { return false } } for _ , p : = range r . visited { if pathtools . Has Prefix ( dest , p ) | | pathtools . Has Prefix ( p , dest ) { return false } } r . visited = append ( r . visited , dest ) stat , err : = os . Stat ( fullpath ) if err ! = nil { return false } return stat . Is Dir ( ) } 
func Merge Rules ( src , dst * Rule , mergeable map [ string ] bool , filename string ) { if dst . Should Keep ( ) { return } } dst Value : = dst Attr . RHS if merged Value , err : = merge Exprs ( nil , dst Value ) ; err ! = nil { start , end : = dst Value . Span ( ) log . Printf ( " " , filename , start . Line , start . Line Rune , end . Line , end . Line Rune ) } else if merged Value = = nil { dst . Del Attr ( key ) } else { dst . Set Attr ( key , merged Value ) } } if dst Attr , ok : = dst . attrs [ key ] ; ! ok { dst . Set Attr ( key , src Value ) } else if mergeable [ key ] & & ! Should Keep ( dst Attr ) { dst Value : = dst Attr . RHS if merged Value , err : = merge Exprs ( src Value , dst Value ) ; err ! = nil { start , end : = dst Value . Span ( ) log . Printf ( " " , filename , start . Line , start . Line Rune , end . Line , end . Line Rune ) } else { dst . Set Attr ( key , merged Value ) } } } } 
func merge Exprs ( src , dst bzl . Expr ) ( bzl . Expr , error ) { if Should Keep ( dst ) { return nil , nil } if src = = nil & & ( dst = = nil | | is Scalar ( dst ) ) { return nil , nil } if is Scalar ( src ) { return src , nil } src Exprs , err : = extract Platform Strings Exprs ( src ) if err ! = nil { return nil , err } dst Exprs , err : = extract Platform Strings Exprs ( dst ) if err ! = nil { return nil , err } merged Exprs , err : = merge Platform Strings Exprs ( src Exprs , dst Exprs ) if err ! = nil { return nil , err } return make Platform Strings Expr ( merged Exprs ) , nil } 
func Squash Rules ( src , dst * Rule , filename string ) error { if dst . Should Keep ( ) { return nil } for key , src Attr : = range src . attrs { src Value : = src Attr . RHS if dst Attr , ok : = dst . attrs [ key ] ; ! ok { dst . Set Attr ( key , src Value ) } else if ! Should Keep ( dst Attr ) { dst Value : = dst Attr . RHS if squashed Value , err : = squash Exprs ( src Value , dst Value ) ; err ! = nil { start , end : = dst Value . Span ( ) return fmt . Errorf ( " " , filename , start . Line , start . Line Rune , end . Line , end . Line Rune ) } else { dst . Set Attr ( key , squashed Value ) } } } dst . expr . Comment ( ) . Before = append ( dst . expr . Comment ( ) . Before , src . expr . Comment ( ) . Before . . . ) dst . expr . Comment ( ) . Suffix = append ( dst . expr . Comment ( ) . Suffix , src . expr . Comment ( ) . Suffix . . . ) dst . expr . Comment ( ) . After = append ( dst . expr . Comment ( ) . After , src . expr . Comment ( ) . After . . . ) return nil } 
func Merge File ( old File * rule . File , empty Rules , gen Rules [ ] * rule . Rule , phase Phase , kinds map [ string ] rule . Kind Info ) { get Merge Attrs : = func ( r * rule . Rule ) map [ string ] bool { if phase = = Pre Resolve { return kinds [ r . Kind ( ) ] . Mergeable Attrs } else { return kinds [ r . Kind ( ) ] . Resolve Attrs } } } rule . Merge Rules ( empty Rule , old Rule , get Merge Attrs ( empty Rule ) , old File . Path ) if old Rule . Is Empty ( kinds [ old Rule . Kind ( ) ] ) { old Rule . Delete ( ) } } } old File . Sync ( ) match Errors : = make ( [ ] error , len ( gen Rules ) ) substitutions : = make ( map [ string ] string ) for i , gen Rule : = range gen Rules { old Rule , err : = Match ( old File . Rules , gen Rule , kinds [ gen Rule . Kind ( ) ] ) if err ! = nil { continue } match Rules [ i ] = old Rule if old Rule ! = nil { if old Rule . Name ( ) ! = gen Rule . Name ( ) { substitutions [ gen Rule . Name ( ) ] = old Rule . Name ( ) } } } } } } if match Rules [ i ] = = nil { gen Rule . Insert ( old File ) } else { rule . Merge Rules ( gen Rule , match Rules [ i ] , get Merge Attrs ( gen Rule ) , old File . Path ) } } } 
func substitute Rule ( r * rule . Rule , substitutions map [ string ] string , info rule . Kind Info ) { for attr : = range info . Substitute Attrs { if expr : = r . Attr ( attr ) ; expr ! = nil { expr = rule . Map Expr Strings ( expr , func ( s string ) string { if rename , ok : = substitutions [ strings . Trim Prefix ( s , " " ) ] ; ok { return " " + rename } else { return s } } ) r . Set Attr ( attr , expr ) } } } 
func Match ( rules [ ] * rule . Rule , x * rule . Rule , info rule . Kind Info ) ( * rule . Rule , error ) { xname : = x . Name ( ) xkind : = x . Kind ( ) var name Matches [ ] * rule . Rule var kind Matches [ ] * rule . Rule for _ , y : = range rules { if xname = = y . Name ( ) { name Matches = append ( name Matches , y ) } if xkind = = y . Kind ( ) { kind Matches = append ( kind Matches , y ) } } if len ( name Matches ) = = 1 { y : = name Matches [ 0 ] if xkind ! = y . Kind ( ) { return nil , fmt . Errorf ( " " , xkind , xname , y . Kind ( ) ) } return y , nil } if len ( name Matches ) > 1 { return nil , fmt . Errorf ( " " , xkind , xname ) } for _ , key : = range info . Match Attrs { var attr Matches [ ] * rule . Rule xvalue : = x . Attr String ( key ) if xvalue = = " " { continue } for _ , y : = range kind Matches { if xvalue = = y . Attr String ( key ) { attr Matches = append ( attr Matches , y ) } } if len ( attr Matches ) = = 1 { return attr Matches [ 0 ] , nil } else if len ( attr Matches ) > 1 { return nil , fmt . Errorf ( " " , xkind , xname , key , xvalue ) } } if info . Match Any { if len ( kind Matches ) = = 1 { return kind Matches [ 0 ] , nil } else if len ( kind Matches ) > 1 { return nil , fmt . Errorf ( " " , xkind , xname ) } } return nil , nil } 
func run Client ( ) error { start Time : = time . Now ( ) conn , err : = net . Dial ( " " , * socket Path ) if err ! = nil { if err : = start Server ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } for retry : = 0 ; retry < 3 ; retry + + { conn , err = net . Dial ( " " , * socket Path ) if err = = nil { break } } if err ! = nil { return fmt . Errorf ( " " , err ) } } defer conn . Close ( ) if _ , err : = io . Copy ( os . Stderr , conn ) ; err ! = nil { log . Print ( err ) } elapsed Time : = time . Since ( start Time ) log . Printf ( " " , elapsed Time . Seconds ( ) ) return nil } 
func Parse Directives ( f * bzl . File ) [ ] Directive { var directives [ ] Directive parse Comment : = func ( com bzl . Comment ) { match : = directive Re . Find String Submatch ( com . Token ) if match = = nil { return } key , value : = match [ 1 ] , match [ 2 ] directives = append ( directives , Directive { key , value } ) } for _ , s : = range f . Stmt { coms : = s . Comment ( ) for _ , com : = range coms . Before { parse Comment ( com ) } for _ , com : = range coms . After { parse Comment ( com ) } } return directives } 
func Update Repo ( rc * Remote Cache , import Path string ) ( Repo , error ) { root , name , err : = rc . Root ( import Path ) if err ! = nil { return Repo { } , err } remote , vcs , err : = rc . Remote ( root ) if err ! = nil { return Repo { } , err } commit , tag , err : = rc . Head ( remote , vcs ) if err ! = nil { return Repo { } , err } repo : = Repo { Name : name , Go Prefix : root , Commit : commit , Tag : tag , Remote : remote , VCS : vcs , } return repo , nil } 
func New Remote Cache ( known Repos [ ] Repo ) ( r * Remote Cache , cleanup func ( ) error ) { r = & Remote Cache { Repo Root For Import Path : vcs . Repo Root For Import Path , Head Cmd : default Head Cmd , root : remote Cache Map { cache : make ( map [ string ] * remote Cache Entry ) } , remote : remote Cache Map { cache : make ( map [ string ] * remote Cache Entry ) } , head : remote Cache Map { cache : make ( map [ string ] * remote Cache Entry ) } , mod : remote Cache Map { cache : make ( map [ string ] * remote Cache Entry ) } , } r . Mod Info = func ( import Path string ) ( string , error ) { return default Mod Info ( r , import Path ) } for _ , repo : = range known Repos { r . root . cache [ repo . Go Prefix ] = & remote Cache Entry { value : root Value { root : repo . Go Prefix , name : repo . Name , } , } if repo . Remote ! = " " { r . remote . cache [ repo . Go Prefix ] = & remote Cache Entry { value : remote Value { remote : repo . Remote , vcs : repo . VCS , } , } } r . mod . cache [ repo . Go Prefix ] = & remote Cache Entry { value : mod Value { path : repo . Go Prefix , name : repo . Name , known : true , } , } } return r , r . cleanup } 
func ( r * Remote Cache ) Root ( import Path string ) ( root , name string , err error ) { for { v , ok , err : = r . root . get ( prefix ) if ok { if err ! = nil { return " " , " " , err } value : = v . ( root Value ) return value . root , value . name , nil } prefix = path . Dir ( prefix ) if prefix = = " " | | prefix = = " " { break } } var components [ ] string if rest ! = " " { components = strings . Split ( rest , " " ) } if len ( components ) < p . missing { return " " , " " , fmt . Errorf ( " " , import Path , p . prefix ) } root = p . prefix for _ , c : = range components [ : p . missing ] { root = path . Join ( root , c ) } name = label . Import Path To Bazel Repo Name ( root ) return root , name , nil } } name = label . Import Path To Bazel Repo Name ( root ) return root , name , nil } if err ! = nil { return nil , err } return root Value { res . Root , label . Import Path To Bazel Repo Name ( res . Root ) } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( root Value ) return value . root , value . name , nil } 
func ( r * Remote Cache ) Remote ( root string ) ( remote , vcs string , err error ) { v , err : = r . remote . ensure ( root , func ( ) ( interface { } , error ) { repo , err : = r . Repo Root For Import Path ( root , false ) if err ! = nil { return nil , err } return remote Value { remote : repo . Repo , vcs : repo . VCS . Cmd } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( remote Value ) return value . remote , value . vcs , nil } 
func ( r * Remote Cache ) Head ( remote , vcs string ) ( commit , tag string , err error ) { if vcs ! = " " { return " " , " " , fmt . Errorf ( " " , remote , vcs ) } v , err : = r . head . ensure ( remote , func ( ) ( interface { } , error ) { commit , err : = r . Head Cmd ( remote , vcs ) if err ! = nil { return nil , err } return head Value { commit : commit } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( head Value ) return value . commit , value . tag , nil } 
func ( r * Remote Cache ) Mod ( import Path string ) ( mod Path , name string , err error ) { for { v , ok , err : = r . mod . get ( prefix ) if ok { if err ! = nil { return " " , " " , err } value : = v . ( mod Value ) if value . known { return value . path , value . name , nil } else { break } } prefix = path . Dir ( prefix ) if prefix = = " " | | prefix = = " " { break } } if err ! = nil { return nil , err } return mod Value { path : mod Path , name : label . Import Path To Bazel Repo Name ( mod Path ) , } , nil } ) if err ! = nil { return " " , " " , err } value : = v . ( mod Value ) return value . path , value . name , nil } 
func ( m * remote Cache Map ) get ( key string ) ( value interface { } , ok bool , err error ) { m . mu . Lock ( ) e , ok : = m . cache [ key ] m . mu . Unlock ( ) if ! ok { return nil , ok , nil } if e . ready ! = nil { < - e . ready } return e . value , ok , e . err } 
func ( m * remote Cache Map ) ensure ( key string , load func ( ) ( interface { } , error ) ) ( interface { } , error ) { m . mu . Lock ( ) e , ok : = m . cache [ key ] if ! ok { e = & remote Cache Entry { ready : make ( chan struct { } ) } m . cache [ key ] = e m . mu . Unlock ( ) e . value , e . err = load ( ) close ( e . ready ) } else { m . mu . Unlock ( ) if e . ready ! = nil { < - e . ready } } return e . value , e . err } 
func Has Prefix ( p , prefix string ) bool { return prefix = = " " | | p = = prefix | | strings . Has Prefix ( p , prefix + " " ) } 
func Trim Prefix ( p , prefix string ) string { if prefix = = " " { return p } if prefix = = p { return " " } return strings . Trim Prefix ( p , prefix + " " ) } 
func Rel Base Name ( rel , prefix , root string ) string { base : = path . Base ( rel ) if base = = " " | | base = = " " { base = path . Base ( prefix ) } if base = = " " | | base = = " " { base = filepath . Base ( root ) } if base = = " " | | base = = " " { base = " " } return base } 
func ( c * Config ) Clone ( ) * Config { cc : = * c cc . Exts = make ( map [ string ] interface { } ) for k , v : = range c . Exts { cc . Exts [ k ] = v } cc . Kind Map = make ( map [ string ] Mapped Kind ) for k , v : = range c . Kind Map { cc . Kind Map [ k ] = v } return & cc } 
func ( c * Config ) Is Valid Build File Name ( name string ) bool { for _ , n : = range c . Valid Build File Names { if name = = n { return true } } return false } 
func ( l tag Line ) check ( c * config . Config , os , arch string ) bool { if len ( l ) = = 0 { return false } for _ , g : = range l { if g . check ( c , os , arch ) { return true } } return false } 
func ( g tag Group ) check ( c * config . Config , os , arch string ) bool { go Conf : = get Go Config ( c ) for _ , t : = range g { if strings . Has Prefix ( t , " " ) { } not : = strings . Has Prefix ( t , " " ) if not { t = t [ 1 : ] } if is Ignored Tag ( t ) { } var match bool if _ , ok : = rule . Known OSSet [ t ] ; ok { if os = = " " { return false } match = os = = t } else if _ , ok : = rule . Known Arch Set [ t ] ; ok { if arch = = " " { return false } match = arch = = t } else { match = go Conf . generic Tags [ t ] } if not { match = ! match } if ! match { return false } } return true } 
func file Name Info ( path _ string ) file Info { name : = filepath . Base ( path _ ) var ext ext switch path . Ext ( name ) { case " " : ext = go Ext case " " , " " , " " , " " , " " , " " : ext = c Ext case " " , " " , " " , " " : ext = h Ext case " " : ext = s Ext case " " : ext = cs Ext case " " : ext = proto Ext default : ext = unknown Ext } if strings . Has Prefix ( name , " " ) | | strings . Has Prefix ( name , " " ) { ext = unknown Ext } var goos , goarch string l : = strings . Split ( name [ : len ( name ) - len ( path . Ext ( name ) ) ] , " " ) if len ( l ) > = 2 & & l [ len ( l ) - 1 ] = = " " { is Test = ext = = go Ext l = l [ : len ( l ) - 1 ] } switch { case len ( l ) > = 3 & & rule . Known OSSet [ l [ len ( l ) - 2 ] ] & & rule . Known Arch Set [ l [ len ( l ) - 1 ] ] : goos = l [ len ( l ) - 2 ] goarch = l [ len ( l ) - 1 ] case len ( l ) > = 2 & & rule . Known OSSet [ l [ len ( l ) - 1 ] ] : goos = l [ len ( l ) - 1 ] case len ( l ) > = 2 & & rule . Known Arch Set [ l [ len ( l ) - 1 ] ] : goarch = l [ len ( l ) - 1 ] } return file Info { path : path _ , name : name , ext : ext , is Test : is Test , goos : goos , goarch : goarch , } } 
func other File Info ( path string ) file Info { info : = file Name Info ( path ) if info . ext = = unknown Ext { return info } tags , err : = read Tags ( info . path ) if err ! = nil { log . Printf ( " " , info . path , err ) return info } info . tags = tags return info } 
func go File Info ( path , rel string ) file Info { info : = file Name Info ( path ) fset : = token . New File Set ( ) pf , err : = parser . Parse File ( fset , info . path , nil , parser . Imports Only | parser . Parse Comments ) if err ! = nil { log . Printf ( " " , info . path , err ) return info } info . package Name = pf . Name . Name if info . is Test & & strings . Has Suffix ( info . package Name , " " ) { info . package Name = info . package Name [ : len ( info . package Name ) - len ( " " ) ] } for _ , decl : = range pf . Decls { d , ok : = decl . ( * ast . Gen Decl ) if ! ok { continue } for _ , dspec : = range d . Specs { spec , ok : = dspec . ( * ast . Import Spec ) if ! ok { continue } quoted : = spec . Path . Value path , err : = strconv . Unquote ( quoted ) if err ! = nil { log . Printf ( " " , info . path , err ) continue } if path = = " " { if info . is Test { log . Printf ( " " , info . path ) } info . is Cgo = true cg : = spec . Doc if cg = = nil & & len ( d . Specs ) = = 1 { cg = d . Doc } if cg ! = nil { if err : = save Cgo ( & info , rel , cg ) ; err ! = nil { log . Printf ( " " , info . path , err ) } } continue } info . imports = append ( info . imports , path ) } } tags , err : = read Tags ( info . path ) if err ! = nil { log . Printf ( " " , info . path , err ) return info } info . tags = tags return info } 
func save Cgo ( info * file Info , rel string , cg * ast . Comment Group ) error { text : = cg . Text ( ) for _ , line : = range strings . Split ( text , " \n " ) { orig : = line if len ( line ) < 5 | | line [ : 4 ] ! = " " | | ( line [ 4 ] ! = ' ' & & line [ 4 ] ! = ' \t ' ) { continue } i : = strings . Index ( line , " " ) if i < 0 { return fmt . Errorf ( " " , info . path , orig ) } line , optstr : = strings . Trim Space ( line [ : i ] ) , strings . Trim Space ( line [ i + 1 : ] ) if len ( f ) < 1 { return fmt . Errorf ( " " , info . path , orig ) } verb : = f [ len ( f ) - 1 ] tags : = parse Tags In Groups ( f [ : len ( f ) - 1 ] ) if err ! = nil { return fmt . Errorf ( " " , info . path , orig ) } var ok bool for i , opt : = range opts { if opt , ok = expand Src Dir ( opt , rel ) ; ! ok { return fmt . Errorf ( " " , info . path , orig ) } opts [ i ] = opt } joined Str : = strings . Join ( opts , opt Separator ) case " " : info . clinkopts = append ( info . clinkopts , tagged Opts { tags , joined Str } ) case " " : return fmt . Errorf ( " " , info . path , orig ) default : return fmt . Errorf ( " " , info . path , orig ) } } return nil } 
func split Quoted ( s string ) ( r [ ] string , err error ) { var args [ ] string arg : = make ( [ ] rune , len ( s ) ) escaped : = false quoted : = false quote : = ' \x 0 0 ' i : = 0 for _ , rune : = range s { switch { case escaped : escaped = false case rune = = ' \ \ ' : escaped = true continue case quote ! = ' \x 0 0 ' : if rune = = quote { quote = ' \x 0 0 ' continue } case rune = = ' " ' | | rune = = ' \ ' ' : quoted = true quote = rune continue case unicode . Is Space ( rune ) : if quoted | | i > 0 { quoted = false args = append ( args , string ( arg [ : i ] ) ) i = 0 } continue } arg [ i ] = rune i + + } if quoted | | i > 0 { args = append ( args , string ( arg [ : i ] ) ) } if quote ! = 0 { err = errors . New ( " " ) } else if escaped { err = errors . New ( " " ) } return args , err } 
func expand Src Dir ( str string , srcdir string ) ( string , bool ) { if srcdir = = " " { srcdir = " " } if len ( chunks ) < 2 { return str , safe Cgo Name ( str , false ) } ok : = true for _ , chunk : = range chunks { ok = ok & & ( chunk = = " " | | safe Cgo Name ( chunk , false ) ) } ok = ok & & ( srcdir = = " " | | safe Cgo Name ( srcdir , true ) ) res : = strings . Join ( chunks , srcdir ) return res , ok & & res ! = " " } 
func safe Cgo Name ( s string , spaces bool ) bool { if s = = " " { return false } safe : = safe Bytes if ! spaces { safe = safe [ len ( safe Spaces ) : ] } for i : = 0 ; i < len ( s ) ; i + + { if c : = s [ i ] ; c < utf 8 . Rune Self & & bytes . Index Byte ( safe , c ) < 0 { return false } } return true } 
func read Tags ( path string ) ( [ ] tag Line , error ) { f , err : = os . Open ( path ) if err ! = nil { return nil , err } defer f . Close ( ) scanner : = bufio . New Scanner ( f ) end : = 0 for scanner . Scan ( ) { line : = strings . Trim Space ( scanner . Text ( ) ) if line = = " " { end = len ( lines ) continue } if strings . Has Prefix ( line , " " ) { lines = append ( lines , line [ len ( " " ) : ] ) continue } break } if err : = scanner . Err ( ) ; err ! = nil { return nil , err } lines = lines [ : end ] for _ , line : = range lines { fields : = strings . Fields ( line ) if len ( fields ) > 0 & & fields [ 0 ] = = " " { tag Lines = append ( tag Lines , parse Tags In Groups ( fields [ 1 : ] ) ) } } return tag Lines , nil } 
func check Constraints ( c * config . Config , os , arch , os Suffix , arch Suffix string , file Tags [ ] tag Line , cgo Tags tag Line ) bool { if os Suffix ! = " " & & os Suffix ! = os | | arch Suffix ! = " " & & arch Suffix ! = arch { return false } for _ , l : = range file Tags { if ! l . check ( c , os , arch ) { return false } } if len ( cgo Tags ) > 0 & & ! cgo Tags . check ( c , os , arch ) { return false } return true } 
func is Ignored Tag ( tag string ) bool { if tag = = " " | | tag = = " " | | tag = = " " { return true } if len ( tag ) < 5 | | ! strings . Has Prefix ( tag , " " ) { return false } if tag [ 2 ] < ' 0 ' | | tag [ 2 ] > ' 9 ' | | tag [ 3 ] ! = ' . ' { return false } for _ , c : = range tag [ 4 : ] { if c < ' 0 ' | | c > ' 9 ' { return false } } return true } 
func proto File Info ( path _ string , proto Info proto . File Info ) file Info { info : = file Name Info ( path _ ) } if strings . Last Index Byte ( opt . Value , ' / ' ) = = - 1 { info . package Name = opt . Value } else { if i : = strings . Last Index Byte ( opt . Value , ' ; ' ) ; i ! = - 1 { info . import Path = opt . Value [ : i ] info . package Name = opt . Value [ i + 1 : ] } else { info . import Path = opt . Value info . package Name = path . Base ( opt . Value ) } } } } info . imports = proto Info . Imports info . has Services = proto Info . Has Services return info } 
func Find Rule With Override ( c * config . Config , imp Import Spec , lang string ) ( label . Label , bool ) { rc : = get Resolve Config ( c ) for i : = len ( rc . overrides ) - 1 ; i > = 0 ; i - - { o : = rc . overrides [ i ] if o . matches ( imp , lang ) { return o . dep , true } } return label . No Label , false } 
func New Rule Index ( mrslv func ( r * rule . Rule , pkg Rel string ) Resolver ) * Rule Index { return & Rule Index { label Map : make ( map [ label . Label ] * rule Record ) , mrslv : mrslv , } } 
func ( ix * Rule Index ) Add Rule ( c * config . Config , r * rule . Rule , f * rule . File ) { var imps [ ] Import Spec if rslv : = ix . mrslv ( r , f . Pkg ) ; rslv ! = nil { imps = rslv . Imports ( c , r , f ) } } record : = & rule Record { rule : r , label : label . New ( c . Repo Name , f . Pkg , r . Name ( ) ) , file : f , imported As : imps , } if _ , ok : = ix . label Map [ record . label ] ; ok { log . Printf ( " " , record . label ) return } ix . rules = append ( ix . rules , record ) ix . label Map [ record . label ] = record } 
func ( ix * Rule Index ) Finish ( ) { for _ , r : = range ix . rules { ix . collect Embeds ( r ) } ix . build Import Index ( ) } 
func ( ix * Rule Index ) build Import Index ( ) { ix . import Map = make ( map [ Import Spec ] [ ] * rule Record ) for _ , r : = range ix . rules { if r . embedded { continue } indexed : = make ( map [ Import Spec ] bool ) for _ , imp : = range r . imported As { if indexed [ imp ] { continue } indexed [ imp ] = true ix . import Map [ imp ] = append ( ix . import Map [ imp ] , r ) } } } 
func ( ix * Rule Index ) Find Rules By Import ( imp Import Spec , lang string ) [ ] Find Result { matches : = ix . import Map [ imp ] results : = make ( [ ] Find Result , 0 , len ( matches ) ) for _ , m : = range matches { if ix . mrslv ( m . rule , " " ) . Name ( ) ! = lang { continue } results = append ( results , Find Result { Label : m . label , Embeds : m . embeds , } ) } return results } 
func ( r Find Result ) Is Self Import ( from label . Label ) bool { if from . Equal ( r . Label ) { return true } for _ , e : = range r . Embeds { if from . Equal ( e ) { return true } } return false } 
func apply Kind Mappings ( mapped Kinds [ ] config . Mapped Kind , loads [ ] rule . Load Info ) [ ] rule . Load Info { if len ( mapped Kinds ) = = 0 { return loads } copy ( mapped Loads , loads ) for _ , mapped Kind : = range mapped Kinds { mapped Loads = append Or Merge Kind Mapping ( mapped Loads , mapped Kind ) } return mapped Loads } 
func append Or Merge Kind Mapping ( mapped Loads [ ] rule . Load Info , mapped Kind config . Mapped Kind ) [ ] rule . Load Info { return mapped Loads } } } 
func Rule Name ( names . . . string ) string { base : = " " for _ , name : = range names { not Ident : = func ( c rune ) bool { return ! ( 'A ' < = c & & c < = 'Z ' | | 'a ' < = c & & c < = 'z ' | | ' 0 ' < = c & & c < = ' 9 ' | | c = = ' _ ' ) } if i : = strings . Last Index Func ( name , not Ident ) ; i > = 0 { name = name [ i + 1 : ] } if name ! = " " { base = name break } } return base + " " } 
func build Packages ( pc * Proto Config , dir , rel string , proto Files , gen Files [ ] string ) [ ] * Package { package Map : = make ( map [ string ] * Package ) for _ , name : = range proto Files { info : = proto File Info ( dir , name ) key : = info . Package Name if pc . group Option ! = " " { for _ , opt : = range info . Options { if opt . Key = = pc . group Option { key = opt . Value break } } } if package Map [ key ] = = nil { package Map [ key ] = new Package ( info . Package Name ) } package Map [ key ] . add File ( info ) } switch pc . Mode { case Default Mode : pkg , err : = select Package ( dir , rel , package Map ) if err ! = nil { log . Print ( err ) } if pkg = = nil { return nil } for _ , name : = range gen Files { pkg . add Gen File ( dir , name ) } return [ ] * Package { pkg } case Package Mode : pkgs : = make ( [ ] * Package , 0 , len ( package Map ) ) for _ , pkg : = range package Map { pkgs = append ( pkgs , pkg ) } return pkgs default : return nil } } 
func select Package ( dir , rel string , package Map map [ string ] * Package ) ( * Package , error ) { if len ( package Map ) = = 0 { return nil , nil } if len ( package Map ) = = 1 { for _ , pkg : = range package Map { return pkg , nil } } default Package Name : = strings . Replace ( rel , " " , " " , - 1 ) for _ , pkg : = range package Map { if pkg Name : = go Package Name ( pkg ) ; pkg Name ! = " " & & pkg Name = = default Package Name { return pkg , nil } } return nil , fmt . Errorf ( " " , dir ) } 
func go Package Name ( pkg * Package ) string { if opt , ok : = pkg . Options [ " " ] ; ok { if i : = strings . Index Byte ( opt , ' ; ' ) ; i > = 0 { return opt [ i + 1 : ] } else if i : = strings . Last Index Byte ( opt , ' / ' ) ; i > = 0 { return opt [ i + 1 : ] } else { return opt } } if pkg . Name ! = " " { return strings . Replace ( pkg . Name , " " , " " , - 1 ) } if len ( pkg . Files ) = = 1 { for s : = range pkg . Files { return strings . Trim Suffix ( s , " " ) } } return " " } 
func generate Proto ( pc * Proto Config , rel string , pkg * Package , should Set Visibility bool ) * rule . Rule { var name string if pc . Mode = = Default Mode { name = Rule Name ( go Package Name ( pkg ) , pc . Go Prefix , rel ) } else { name = Rule Name ( pkg . Options [ pc . group Option ] , pkg . Name , rel ) } r : = rule . New Rule ( " " , name ) srcs : = make ( [ ] string , 0 , len ( pkg . Files ) ) for f : = range pkg . Files { srcs = append ( srcs , f ) } sort . Strings ( srcs ) if len ( srcs ) > 0 { r . Set Attr ( " " , srcs ) } r . Set Private Attr ( Package Key , * pkg ) imports : = make ( [ ] string , 0 , len ( pkg . Imports ) ) for i : = range pkg . Imports { imports = append ( imports , i ) } sort . Strings ( imports ) for k , v : = range pkg . Options { r . Set Private Attr ( k , v ) } if should Set Visibility { vis : = rule . Check Internal Visibility ( rel , " " ) r . Set Attr ( " " , [ ] string { vis } ) } if pc . strip Import Prefix ! = " " { r . Set Attr ( " " , pc . strip Import Prefix ) } if pc . import Prefix ! = " " { r . Set Attr ( " " , pc . import Prefix ) } return r } 
func generate Empty ( f * rule . File , regular Files , gen Files [ ] string ) [ ] * rule . Rule { if f = = nil { return nil } known Files : = make ( map [ string ] bool ) for _ , f : = range regular Files { known Files [ f ] = true } for _ , f : = range gen Files { known Files [ f ] = true } var empty [ ] * rule . Rule outer : for _ , r : = range f . Rules { if r . Kind ( ) ! = " " { continue } srcs : = r . Attr Strings ( " " ) if len ( srcs ) = = 0 & & r . Attr ( " " ) ! = nil { } for _ , src : = range r . Attr Strings ( " " ) { if known Files [ src ] { continue outer } } empty = append ( empty , rule . New Rule ( " " , r . Name ( ) ) ) } return empty } 
func build Proto Regexp ( ) * regexp . Regexp { hex Escape : = ` \ \ [x X ] [ 0 - 9a -f A -f ] { 2 } ` oct Escape : = ` \ \ [ 0 - 7 ] { 3 } ` char Escape : = ` \ \ [abfnrtv ' " \ \ ] ` char Value : = strings . Join ( [ ] string { hex Escape , oct Escape , char Escape , " \x 0 0 \ \ \ \ \ " \ \ \ \ " } , " " ) str Lit : = ` ' ( ? : ` + char Value + ` | " ) * ' | " ( ? : ` + char Value + ` | ' ) * " ` ident : = ` [A -Za -z ] [A -Za -z 0 - 9 _ ] * ` full Ident : = ident + ` ( ? : \ . ` + ident + ` ) * ` import Stmt : = ` \bimport \s * ( ? :public |weak ) ? \s * ( ?P <import > ` + str Lit + ` ) \s * ; ` package Stmt : = ` \bpackage \s * ( ?P <package > ` + full Ident + ` ) \s * ; ` option Stmt : = ` \boption \s * ( ?P <optkey > ` + full Ident + ` ) \s * = \s * ( ?P <optval > ` + str Lit + ` ) \s * ; ` service Stmt : = ` ( ?P <service >service ) ` comment : = ` / / [ ^ \n ] * ` proto Re Src : = strings . Join ( [ ] string { import Stmt , package Stmt , option Stmt , service Stmt , comment } , " " ) return regexp . Must Compile ( proto Re Src ) } 
func Import Repo Rules ( filename string , repo Cache * Remote Cache ) ( [ ] * rule . Rule , error ) { format : = get Lock File Format ( filename ) if format = = unknown Format { return nil , fmt . Errorf ( ` %s : unrecognized lock file format . Expected "Gopkg .lock " , "go .mod " , or "Godeps .json " ` , filename ) } parser : = lock File Parsers [ format ] repos , err : = parser ( filename , repo Cache ) if err ! = nil { return nil , fmt . Errorf ( " " , filename , err ) } sort . Stable ( by Name ( repos ) ) rules : = make ( [ ] * rule . Rule , 0 , len ( repos ) ) for _ , repo : = range repos { rules = append ( rules , Generate Rule ( repo ) ) } return rules , nil } 
func Merge Rules ( gen Rules [ ] * rule . Rule , existing Rules map [ * rule . File ] [ ] string , dest File * rule . File , kinds map [ string ] rule . Kind Info ) [ ] * rule . File { sort . Stable ( by Rule Name ( gen Rules ) ) repo Map : = make ( map [ string ] * rule . File ) for file , repo Names : = range existing Rules { if file . Path = = dest File . Path & & file . Macro Name ( ) ! = " " & & file . Macro Name ( ) = = dest File . Macro Name ( ) { file = dest File } for _ , name : = range repo Names { repo Map [ name ] = file } } rules By File : = make ( map [ * rule . File ] [ ] * rule . Rule ) for _ , rule : = range gen Rules { dest : = dest File if file , ok : = repo Map [ rule . Name ( ) ] ; ok { dest = file } rules By File [ dest ] = append ( rules By File [ dest ] , rule ) } updated Files : = make ( map [ string ] * rule . File ) for f , rules : = range rules By File { merger . Merge File ( f , nil , rules , merger . Pre Resolve , kinds ) f . Sync ( ) if uf , ok : = updated Files [ f . Path ] ; ok { uf . Sync Macro File ( f ) } else { updated Files [ f . Path ] = f } } files : = make ( [ ] * rule . File , 0 , len ( updated Files ) ) for _ , f : = range updated Files { files = append ( files , f ) } return files } 
func Generate Rule ( repo Repo ) * rule . Rule { r : = rule . New Rule ( " " , repo . Name ) if repo . Commit ! = " " { r . Set Attr ( " " , repo . Commit ) } if repo . Tag ! = " " { r . Set Attr ( " " , repo . Tag ) } r . Set Attr ( " " , repo . Go Prefix ) if repo . Remote ! = " " { r . Set Attr ( " " , repo . Remote ) } if repo . VCS ! = " " { r . Set Attr ( " " , repo . VCS ) } if repo . Version ! = " " { r . Set Attr ( " " , repo . Version ) } if repo . Sum ! = " " { r . Set Attr ( " " , repo . Sum ) } if repo . Replace ! = " " { r . Set Attr ( " " , repo . Replace ) } return r } 
func Find External Repo ( repo Root , name string ) ( string , error ) { clean Path , err : = filepath . Eval Symlinks ( external Path ) if err ! = nil { return " " , err } st , err : = os . Stat ( clean Path ) if err ! = nil { return " " , err } if ! st . Is Dir ( ) { return " " , fmt . Errorf ( " " , external Path ) } return clean Path , nil } 
func List Repositories ( workspace * rule . File ) ( repos [ ] Repo , repo Names By File map [ * rule . File ] [ ] string , err error ) { repo Names By File = make ( map [ * rule . File ] [ ] string ) repos , repo Names By File [ workspace ] = get Repos ( workspace . Rules ) for _ , d : = range workspace . Directives { switch d . Key { case " " : f , def Name , err : = parse Repository Macro Directive ( d . Value ) if err ! = nil { return nil , nil , err } f = filepath . Join ( filepath . Dir ( workspace . Path ) , filepath . Clean ( f ) ) macro File , err : = rule . Load Macro File ( f , " " , def Name ) if err ! = nil { return nil , nil , err } curr Repos , names : = get Repos ( macro File . Rules ) repo Names By File [ macro File ] = names repos = append ( repos , curr Repos . . . ) } } return repos , repo Names By File , nil } 
func migrate Library Embed ( c * config . Config , f * rule . File ) { for _ , r : = range f . Rules { if ! is Go Rule ( r . Kind ( ) ) { continue } lib Expr : = r . Attr ( " " ) if lib Expr = = nil | | rule . Should Keep ( lib Expr ) | | r . Attr ( " " ) ! = nil { continue } r . Del Attr ( " " ) r . Set Attr ( " " , & bzl . List Expr { List : [ ] bzl . Expr { lib Expr } } ) } } 
func migrate Grpc Compilers ( c * config . Config , f * rule . File ) { for _ , r : = range f . Rules { if r . Kind ( ) ! = " " | | r . Should Keep ( ) | | r . Attr ( " " ) ! = nil { continue } r . Set Kind ( " " ) r . Set Attr ( " " , [ ] string { grpc Compiler Label } ) } } 
func squash Cgo Library ( c * config . Config , f * rule . File ) { for _ , r : = range f . Rules { if r . Kind ( ) = = " " & & r . Name ( ) = = " " & & ! r . Should Keep ( ) { if cgo Library ! = nil { log . Printf ( " " , f . Path ) continue } cgo Library = r continue } if r . Kind ( ) = = " " & & r . Name ( ) = = default Lib Name { if go Library ! = nil { log . Printf ( " " , f . Path ) } go Library = r continue } } if cgo Library = = nil { return } if ! c . Should Fix { log . Printf ( " " , f . Path ) return } if go Library = = nil { cgo Library . Set Kind ( " " ) cgo Library . Set Name ( default Lib Name ) cgo Library . Set Attr ( " " , true ) return } if err : = rule . Squash Rules ( cgo Library , go Library , f . Path ) ; err ! = nil { log . Print ( err ) return } go Library . Del Attr ( " " ) go Library . Set Attr ( " " , true ) cgo Library . Delete ( ) } 
func flatten Srcs ( c * config . Config , f * rule . File ) { for _ , r : = range f . Rules { if ! is Go Rule ( r . Kind ( ) ) { continue } old Srcs : = r . Attr ( " " ) if old Srcs = = nil { continue } flat Srcs : = rule . Flatten Expr ( old Srcs ) if flat Srcs ! = old Srcs { r . Set Attr ( " " , flat Srcs ) } } } 
func remove Legacy Proto ( c * config . Config , f * rule . File ) { } for _ , l : = range f . Loads { if l . Name ( ) = = " " { proto Loads = append ( proto Loads , l ) } } var proto Filegroups , proto Rules [ ] * rule . Rule for _ , r : = range f . Rules { if r . Kind ( ) = = " " & & r . Name ( ) = = legacy Proto Filegroup Name { proto Filegroups = append ( proto Filegroups , r ) } if r . Kind ( ) = = " " { proto Rules = append ( proto Rules , r ) } } if len ( proto Loads ) + len ( proto Filegroups ) = = 0 { return } if ! c . Should Fix { log . Printf ( " " , f . Path ) return } } for _ , r : = range proto Filegroups { r . Delete ( ) } if len ( proto Loads ) > 0 { for _ , r : = range proto Rules { r . Delete ( ) } } } 
func remove Legacy Gazelle ( c * config . Config , f * rule . File ) { for _ , l : = range f . Loads { if l . Name ( ) = = " " & & l . Has ( " " ) { l . Remove ( " " ) if l . Is Empty ( ) { l . Delete ( ) } } } } 
func select Package ( c * config . Config , dir string , package Map map [ string ] * go Package ) ( * go Package , error ) { buildable Packages : = make ( map [ string ] * go Package ) for name , pkg : = range package Map { if pkg . is Buildable ( c ) { buildable Packages [ name ] = pkg } } if len ( buildable Packages ) = = 0 { return nil , & build . No Go Error { Dir : dir } } if len ( buildable Packages ) = = 1 { for _ , pkg : = range buildable Packages { return pkg , nil } } if pkg , ok : = buildable Packages [ default Package Name ( c , dir ) ] ; ok { return pkg , nil } err : = & build . Multiple Package Error { Dir : dir } for name , pkg : = range buildable Packages { err . Files = append ( err . Files , pkg . first Go File ( ) ) } return nil , err } 
func ( g * generator ) options ( opts rule . Platform Strings , pkg Rel string ) rule . Platform Strings { fix Path : = func ( opt string ) string { if strings . Has Prefix ( opt , " " ) { return opt } return path . Clean ( path . Join ( pkg Rel , opt ) ) } fix Groups : = func ( groups [ ] string ) ( [ ] string , error ) { fixed Groups : = make ( [ ] string , len ( groups ) ) for i , group : = range groups { opts : = strings . Split ( group , opt Separator ) fixed Opts : = make ( [ ] string , len ( opts ) ) is Path : = false for j , opt : = range opts { if is Path { opt = fix Path ( opt ) is Path = false goto next } for _ , short : = range short Opt Prefixes { if strings . Has Prefix ( opt , short ) & & len ( opt ) > len ( short ) { opt = short + fix Path ( opt [ len ( short ) : ] ) goto next } } for _ , long : = range long Opt Prefixes { if opt = = long { is Path = true goto next } } next : fixed Opts [ j ] = escape Option ( opt ) } fixed Groups [ i ] = strings . Join ( fixed Opts , " " ) } return fixed Groups , nil } opts , errs : = opts . Map Slice ( fix Groups ) if errs ! = nil { log . Panicf ( " " , pkg Rel , errs ) } return opts } 
func ( mr * meta Resolver ) Add Builtin ( kind Name string , resolver resolve . Resolver ) { mr . builtins [ kind Name ] = resolver } 
func ( mr * meta Resolver ) Mapped Kind ( pkg Rel string , kind config . Mapped Kind ) { mr . mapped Kinds [ pkg Rel ] = append ( mr . mapped Kinds [ pkg Rel ] , kind ) } 
func ( mr meta Resolver ) Resolver ( r * rule . Rule , pkg Rel string ) resolve . Resolver { for _ , mapped Kind : = range mr . mapped Kinds [ pkg Rel ] { if mapped Kind . Kind Name = = r . Kind ( ) { return mr . builtins [ mapped Kind . From Kind ] } } return mr . builtins [ r . Kind ( ) ] } 
func sort Expr Labels ( e bzl . Expr , _ [ ] bzl . Expr ) { list , ok : = e . ( * bzl . List Expr ) if ! ok | | len ( list . List ) = = 0 { return } keys : = make ( [ ] string Sort Key , len ( list . List ) ) for i , elem : = range list . List { s , ok : = elem . ( * bzl . String Expr ) if ! ok { return } keys [ i ] = make Sort Key ( i , s ) } before : = keys [ 0 ] . x . Comment ( ) . Before keys [ 0 ] . x . Comment ( ) . Before = nil sort . Sort ( by String Expr ( keys ) ) keys [ 0 ] . x . Comment ( ) . Before = append ( before , keys [ 0 ] . x . Comment ( ) . Before . . . ) for i , k : = range keys { list . List [ i ] = k . x } } 
func check Rules Go Version ( repo Root string ) { const message = `Gazelle may not be compatible with this version of rules _go . Update io _bazel _rules _go to a newer version in your WORKSPACE file . ` rules Go Path , err : = repo . Find External Repo ( repo Root , config . Rules Go Repo Name ) if err ! = nil { return } def Bzl Path : = filepath . Join ( rules Go Path , " " , " " ) def Bzl Content , err : = ioutil . Read File ( def Bzl Path ) if err ! = nil { return } version Re : = regexp . Must Compile ( ` ( ?m ) ^RULES _GO _VERSION = [ ' " ] ( [ 0 - 9 . ] * ) [ ' " ] ` ) match : = version Re . Find Submatch ( def Bzl Content ) if match = = nil { log . Printf ( " \n " , config . Rules Go Repo Name , message ) return } vstr : = string ( match [ 1 ] ) v , err : = version . Parse Version ( vstr ) if err ! = nil { log . Printf ( " \n " , vstr , config . Rules Go Repo Name , message ) } if v . Compare ( minimum Rules Go Version ) < 0 { log . Printf ( " \n " , v , minimum Rules Go Version , message ) } } 
func ( gc * go Config ) preprocess Tags ( ) { if gc . generic Tags = = nil { gc . generic Tags = make ( map [ string ] bool ) } gc . generic Tags [ " " ] = true } 
func ( gc * go Config ) set Build Tags ( tags string ) error { if tags = = " " { return nil } for _ , t : = range strings . Split ( tags , " " ) { if strings . Has Prefix ( t , " " ) { return fmt . Errorf ( " " , t ) } gc . generic Tags [ t ] = true } return nil } 
func check Prefix ( prefix string ) error { if strings . Has Prefix ( prefix , " " ) | | build . Is Local Import ( prefix ) { return fmt . Errorf ( " " , prefix ) } return nil } 
func split Value ( value string ) [ ] string { parts : = strings . Split ( value , " " ) values : = make ( [ ] string , 0 , len ( parts ) ) for _ , part : = range parts { values = append ( values , strings . Trim Space ( part ) ) } return values } 
func copy Go Mod To Temp ( filename string ) ( temp Dir string , err error ) { go Mod Orig , err : = os . Open ( filename ) if err ! = nil { return " " , err } defer go Mod Orig . Close ( ) temp Dir , err = ioutil . Temp Dir ( " " , " " ) if err ! = nil { return " " , err } go Mod Copy , err : = os . Create ( filepath . Join ( temp Dir , " " ) ) if err ! = nil { os . Remove ( temp Dir ) return " " , err } defer func ( ) { if cerr : = go Mod Copy . Close ( ) ; err = = nil & & cerr ! = nil { err = cerr } } ( ) _ , err = io . Copy ( go Mod Copy , go Mod Orig ) if err ! = nil { os . Remove All ( temp Dir ) return " " , err } return temp Dir , err } 
func find Go Tool ( ) string { path : = " " if goroot , ok : = os . Lookup Env ( " " ) ; ok { path = filepath . Join ( goroot , " " , " " ) } if runtime . GOOS = = " " { path + = " " } return path } 
func ( pkg * go Package ) add File ( c * config . Config , info file Info , cgo bool ) error { switch { case info . ext = = unknown Ext | | ! cgo & & ( info . ext = = c Ext | | info . ext = = cs Ext ) : return nil case info . ext = = proto Ext : if pc Mode : = get Proto Mode ( c ) ; pc Mode = = proto . Legacy Mode { } case info . is Test : if info . is Cgo { return fmt . Errorf ( " " , info . path ) } pkg . test . add File ( c , info ) default : pkg . library . add File ( c , info ) } return nil } 
func ( pkg * go Package ) is Buildable ( c * config . Config ) bool { return pkg . first Go File ( ) ! = " " | | ! pkg . proto . sources . is Empty ( ) } 
func ( pkg * go Package ) first Go File ( ) string { go Srcs : = [ ] platform Strings Builder { pkg . library . sources , pkg . binary . sources , pkg . test . sources , } for _ , sb : = range go Srcs { if sb . strs ! = nil { for s : = range sb . strs { if strings . Has Suffix ( s , " " ) { return s } } } } return " " } 
func get Platform Strings Add Function ( c * config . Config , info file Info , cgo Tags tag Line ) func ( sb * platform Strings Builder , ss . . . string ) { is OSSpecific , is Arch Specific : = is OSArch Specific ( info , cgo Tags ) switch { case ! is OSSpecific & & ! is Arch Specific : if check Constraints ( c , " " , " " , info . goos , info . goarch , info . tags , cgo Tags ) { return func ( sb * platform Strings Builder , ss . . . string ) { for _ , s : = range ss { sb . add Generic String ( s ) } } } case is OSSpecific & & ! is Arch Specific : var os Match [ ] string for _ , os : = range rule . Known OSs { if check Constraints ( c , os , " " , info . goos , info . goarch , info . tags , cgo Tags ) { os Match = append ( os Match , os ) } } if len ( os Match ) > 0 { return func ( sb * platform Strings Builder , ss . . . string ) { for _ , s : = range ss { sb . add OSString ( s , os Match ) } } } case ! is OSSpecific & & is Arch Specific : var arch Match [ ] string for _ , arch : = range rule . Known Archs { if check Constraints ( c , " " , arch , info . goos , info . goarch , info . tags , cgo Tags ) { arch Match = append ( arch Match , arch ) } } if len ( arch Match ) > 0 { return func ( sb * platform Strings Builder , ss . . . string ) { for _ , s : = range ss { sb . add Arch String ( s , arch Match ) } } } default : var platform Match [ ] rule . Platform for _ , platform : = range rule . Known Platforms { if check Constraints ( c , platform . OS , platform . Arch , info . goos , info . goarch , info . tags , cgo Tags ) { platform Match = append ( platform Match , platform ) } } if len ( platform Match ) > 0 { return func ( sb * platform Strings Builder , ss . . . string ) { for _ , s : = range ss { sb . add Platform String ( s , platform Match ) } } } } return func ( _ * platform Strings Builder , _ . . . string ) { } } 
func start Server ( ) error { exe , err : = os . Executable ( ) if err ! = nil { return err } args : = [ ] string { " " } args = append ( args , os . Args [ 1 : ] . . . ) cmd : = exec . Command ( exe , args . . . ) log . Printf ( " " , strings . Join ( cmd . Args , " " ) ) if err : = cmd . Start ( ) ; err ! = nil { return err } if err : = cmd . Process . Release ( ) ; err ! = nil { return err } return nil } 
func run Server ( ) error { if err ! = nil { return err } defer log File . Close ( ) log . Set Output ( log File ) ln , err : = net . Listen ( " " , * socket Path ) if err ! = nil { return err } uln : = ln . ( * net . Unix Listener ) uln . Set Unlink On Close ( true ) defer ln . Close ( ) if err : = uln . Set Deadline ( time . Now ( ) . Add ( * server Timeout ) ) ; err ! = nil { return err } log . Printf ( " " , os . Getpid ( ) ) is Watching : = err = = nil if err ! = nil { log . Print ( err ) } if is Watching { defer cancel Watch ( ) } for { c , err : = ln . Accept ( ) if err ! = nil { if operr , ok : = err . ( * net . Op Error ) ; ok { if operr . Timeout ( ) { return nil } if operr . Temporary ( ) { log . Printf ( " " , err ) continue } } return err } log . Set Output ( io . Multi Writer ( c , log File ) ) dirs : = get And Clear Written Dirs ( ) for _ , dir : = range dirs { restore Build Files In Dir ( dir ) } if err : = run Gazelle ( mode , dirs ) ; err ! = nil { log . Print ( err ) } log . Set Output ( log File ) c . Close ( ) if is Watching { mode = fast Mode } } } 
func watch Dir ( root string , record func ( string ) ) ( cancel func ( ) , err error ) { w , err : = fsnotify . New Watcher ( ) if err ! = nil { return nil , err } dirs , errs : = list Dirs ( root ) for _ , err : = range errs { log . Print ( err ) } git Dir : = filepath . Join ( root , " " ) for _ , dir : = range dirs { if dir = = git Dir { continue } if err : = w . Add ( dir ) ; err ! = nil { log . Print ( err ) } } done : = make ( chan struct { } ) go func ( ) { for { select { case ev : = < - w . Events : if should Ignore ( ev . Name ) { continue } if ev . Op = = fsnotify . Create { if st , err : = os . Lstat ( ev . Name ) ; err ! = nil { log . Print ( err ) } else if st . Is Dir ( ) { dirs , errs : = list Dirs ( ev . Name ) for _ , err : = range errs { log . Print ( err ) } for _ , dir : = range dirs { if err : = w . Add ( dir ) ; err ! = nil { log . Print ( err ) } record Write ( dir ) } } } else { record Write ( filepath . Dir ( ev . Name ) ) } case err : = < - w . Errors : log . Print ( err ) case < - done : if err : = w . Close ( ) ; err ! = nil { log . Print ( err ) } return } } } ( ) return func ( ) { close ( done ) } , nil } 
func list Dirs ( dir string ) ( [ ] string , [ ] error ) { var dirs [ ] string var errs [ ] error err : = filepath . Walk ( dir , func ( path string , info os . File Info , err error ) error { if err ! = nil { errs = append ( errs , err ) return nil } if info . Is Dir ( ) { dirs = append ( dirs , path ) } return nil } ) if err ! = nil { errs = append ( errs , err ) } return dirs , errs } 
func should Ignore ( p string ) bool { p = strings . Trim Prefix ( filepath . To Slash ( p ) , " " ) base : = path . Base ( p ) return strings . Has Prefix ( p , " " ) | | base = = " " | | base = = " " | | base = = " " } 
func record Write ( path string ) { dir Set Mutex . Lock ( ) defer dir Set Mutex . Unlock ( ) dir Set [ path ] = true } 
func get And Clear Written Dirs ( ) [ ] string { dir Set Mutex . Lock ( ) defer dir Set Mutex . Unlock ( ) dirs : = make ( [ ] string , 0 , len ( dir Set ) ) for d : = range dir Set { dirs = append ( dirs , d ) } dir Set = make ( map [ string ] bool ) return dirs } 
func Start ( command * exec . Cmd , out Writer io . Writer , err Writer io . Writer ) ( * Session , error ) { exited : = make ( chan struct { } ) session : = & Session { Command : command , Out : gbytes . New Buffer ( ) , Err : gbytes . New Buffer ( ) , Exited : exited , lock : & sync . Mutex { } , exit Code : - 1 , } var command Out , command Err io . Writer command Out , command Err = session . Out , session . Err if out Writer ! = nil { command Out = io . Multi Writer ( command Out , out Writer ) } if err Writer ! = nil { command Err = io . Multi Writer ( command Err , err Writer ) } command . Stdout = command Out command . Stderr = command Err err : = command . Start ( ) if err = = nil { go session . monitor For Exit ( exited ) tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) tracked Sessions = append ( tracked Sessions , session ) } return session , err } 
func ( s * Session ) Exit Code ( ) int { s . lock . Lock ( ) defer s . lock . Unlock ( ) return s . exit Code } 
func ( s * Session ) Wait ( timeout . . . interface { } ) * Session { Eventually With Offset ( 1 , s , timeout . . . ) . Should ( Exit ( ) ) return s } 
func ( s * Session ) Signal ( signal os . Signal ) * Session { if s . process Is Alive ( ) { s . Command . Process . Signal ( signal ) } return s } 
func Kill And Wait ( timeout . . . interface { } ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Kill ( ) . Wait ( timeout . . . ) } tracked Sessions = [ ] * Session { } } 
func Terminate And Wait ( timeout . . . interface { } ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Terminate ( ) . Wait ( timeout . . . ) } } 
func Kill ( ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Kill ( ) } } 
func Terminate ( ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Terminate ( ) } } 
func Signal ( signal os . Signal ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Signal ( signal ) } } 
func Interrupt ( ) { tracked Sessions Mutex . Lock ( ) defer tracked Sessions Mutex . Unlock ( ) for _ , session : = range tracked Sessions { session . Interrupt ( ) } } 
func Combine Handlers ( handlers . . . http . Handler Func ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { for _ , handler : = range handlers { handler ( w , req ) } } } 
func Verify Request ( method string , path interface { } , raw Query . . . string ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { Expect ( req . Method ) . Should ( Equal ( method ) , " " ) switch p : = path . ( type ) { case types . Gomega Matcher : Expect ( req . URL . Path ) . Should ( p , " " ) default : Expect ( req . URL . Path ) . Should ( Equal ( path ) , " " ) } if len ( raw Query ) > 0 { values , err : = url . Parse Query ( raw Query [ 0 ] ) Expect ( err ) . Should Not ( Have Occurred ( ) , " " ) Expect ( req . URL . Query ( ) ) . Should ( Equal ( values ) , " " ) } } } 
func Verify Content Type ( content Type string ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { Expect ( req . Header . Get ( " " ) ) . Should ( Equal ( content Type ) ) } } 
func Verify Mime Type ( mime Type string ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { Expect ( strings . Split ( req . Header . Get ( " " ) , " " ) [ 0 ] ) . Should ( Equal ( mime Type ) ) } } 
func Verify Basic Auth ( username string , password string ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { auth : = req . Header . Get ( " " ) Expect ( auth ) . Should Not ( Equal ( " " ) , " " ) decoded , err : = base 6 4 . Std Encoding . Decode String ( auth [ 6 : ] ) Expect ( err ) . Should Not ( Have Occurred ( ) ) Expect ( string ( decoded ) ) . Should ( Equal ( fmt . Sprintf ( " " , username , password ) ) , " " ) } } 
func Verify Header ( header http . Header ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { for key , values : = range header { key = http . Canonical Header Key ( key ) Expect ( req . Header [ key ] ) . Should ( Equal ( values ) , " " , key ) } } } 
func Verify Header KV ( key string , values . . . string ) http . Handler Func { return Verify Header ( http . Header { key : values } ) } 
func Verify Body ( expected Body [ ] byte ) http . Handler Func { return Combine Handlers ( func ( w http . Response Writer , req * http . Request ) { body , err : = ioutil . Read All ( req . Body ) req . Body . Close ( ) Expect ( err ) . Should Not ( Have Occurred ( ) ) Expect ( body ) . Should ( Equal ( expected Body ) , " " ) } , ) } 
func Verify JSON ( expected JSON string ) http . Handler Func { return Combine Handlers ( Verify Mime Type ( " " ) , func ( w http . Response Writer , req * http . Request ) { body , err : = ioutil . Read All ( req . Body ) req . Body . Close ( ) Expect ( err ) . Should Not ( Have Occurred ( ) ) Expect ( body ) . Should ( Match JSON ( expected JSON ) , " " ) } , ) } 
func Verify JSONRepresenting ( object interface { } ) http . Handler Func { data , err : = json . Marshal ( object ) Expect ( err ) . Should Not ( Have Occurred ( ) ) return Combine Handlers ( Verify Content Type ( " " ) , Verify JSON ( string ( data ) ) , ) } 
func Verify Form ( values url . Values ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { err : = r . Parse Form ( ) Expect ( err ) . Should Not ( Have Occurred ( ) ) for key , vals : = range values { Expect ( r . Form [ key ] ) . Should ( Equal ( vals ) , " " , key ) } } } 
func Verify Form KV ( key string , values . . . string ) http . Handler Func { return Verify Form ( url . Values { key : values } ) } 
func Verify Proto Representing ( expected proto . Message ) http . Handler Func { return Combine Handlers ( Verify Content Type ( " " ) , func ( w http . Response Writer , req * http . Request ) { body , err : = ioutil . Read All ( req . Body ) Expect ( err ) . Should Not ( Have Occurred ( ) ) req . Body . Close ( ) expected Type : = reflect . Type Of ( expected ) actual Value Ptr : = reflect . New ( expected Type . Elem ( ) ) actual , ok : = actual Value Ptr . Interface ( ) . ( proto . Message ) Expect ( ok ) . Should ( Be True ( ) , " " ) err = proto . Unmarshal ( body , actual ) Expect ( err ) . Should Not ( Have Occurred ( ) , " " ) Expect ( actual ) . Should ( Equal ( expected ) , " " ) } , ) } 
func Respond With ( status Code int , body interface { } , optional Header . . . http . Header ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { if len ( optional Header ) = = 1 { copy Header ( optional Header [ 0 ] , w . Header ( ) ) } w . Write Header ( status Code ) switch x : = body . ( type ) { case string : w . Write ( [ ] byte ( x ) ) case [ ] byte : w . Write ( x ) default : Expect ( body ) . Should ( Be Nil ( ) , " " ) } } } 
func Respond With JSONEncoded ( status Code int , object interface { } , optional Header . . . http . Header ) http . Handler Func { data , err : = json . Marshal ( object ) Expect ( err ) . Should Not ( Have Occurred ( ) ) var headers http . Header if len ( optional Header ) = = 1 { headers = optional Header [ 0 ] } else { headers = make ( http . Header ) } if _ , found : = headers [ " " ] ; ! found { headers [ " " ] = [ ] string { " " } } return Respond With ( status Code , string ( data ) , headers ) } 
func Respond With JSONEncoded Ptr ( status Code * int , object interface { } , optional Header . . . http . Header ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { data , err : = json . Marshal ( object ) Expect ( err ) . Should Not ( Have Occurred ( ) ) var headers http . Header if len ( optional Header ) = = 1 { headers = optional Header [ 0 ] } else { headers = make ( http . Header ) } if _ , found : = headers [ " " ] ; ! found { headers [ " " ] = [ ] string { " " } } copy Header ( headers , w . Header ( ) ) w . Write Header ( * status Code ) w . Write ( data ) } } 
func Respond With Proto ( status Code int , message proto . Message , optional Header . . . http . Header ) http . Handler Func { return func ( w http . Response Writer , req * http . Request ) { data , err : = proto . Marshal ( message ) Expect ( err ) . Should Not ( Have Occurred ( ) ) var headers http . Header if len ( optional Header ) = = 1 { headers = optional Header [ 0 ] } else { headers = make ( http . Header ) } if _ , found : = headers [ " " ] ; ! found { headers [ " " ] = [ ] string { " " } } copy Header ( headers , w . Header ( ) ) w . Write Header ( status Code ) w . Write ( data ) } } 
func Register Fail Handler With T ( t types . TWith Helper , handler types . Gomega Fail Handler ) { if handler = = nil { global Fail Wrapper = nil return } global Fail Wrapper = & types . Gomega Fail Wrapper { Fail : handler , TWith Helper : t , } } 
func Intercept Gomega Failures ( f func ( ) ) [ ] string { original Handler : = global Fail Wrapper . Fail failures : = [ ] string { } Register Fail Handler ( func ( message string , caller Skip . . . int ) { failures = append ( failures , message ) } ) f ( ) Register Fail Handler ( original Handler ) return failures } 
func Expect With Offset ( offset int , actual interface { } , extra . . . interface { } ) Assertion { if global Fail Wrapper = = nil { panic ( nil Fail Handler Panic ) } return assertion . New ( actual , global Fail Wrapper , offset , extra . . . ) } 
func Eventually With Offset ( offset int , actual interface { } , intervals . . . interface { } ) Async Assertion { if global Fail Wrapper = = nil { panic ( nil Fail Handler Panic ) } timeout Interval : = default Eventually Timeout polling Interval : = default Eventually Polling Interval if len ( intervals ) > 0 { timeout Interval = to Duration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { polling Interval = to Duration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . Async Assertion Type Eventually , actual , global Fail Wrapper , timeout Interval , polling Interval , offset ) } 
func Consistently With Offset ( offset int , actual interface { } , intervals . . . interface { } ) Async Assertion { if global Fail Wrapper = = nil { panic ( nil Fail Handler Panic ) } timeout Interval : = default Consistently Duration polling Interval : = default Consistently Polling Interval if len ( intervals ) > 0 { timeout Interval = to Duration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { polling Interval = to Duration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . Async Assertion Type Consistently , actual , global Fail Wrapper , timeout Interval , polling Interval , offset ) } 
func ( g * With T ) Expect ( actual interface { } , extra . . . interface { } ) Assertion { return assertion . New ( actual , testingtsupport . Build Testing TGomega Fail Wrapper ( g . t ) , 0 , extra . . . ) } 
func ( g * With T ) Eventually ( actual interface { } , intervals . . . interface { } ) Async Assertion { timeout Interval : = default Eventually Timeout polling Interval : = default Eventually Polling Interval if len ( intervals ) > 0 { timeout Interval = to Duration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { polling Interval = to Duration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . Async Assertion Type Eventually , actual , testingtsupport . Build Testing TGomega Fail Wrapper ( g . t ) , timeout Interval , polling Interval , 0 ) } 
func ( g * With T ) Consistently ( actual interface { } , intervals . . . interface { } ) Async Assertion { timeout Interval : = default Consistently Duration polling Interval : = default Consistently Polling Interval if len ( intervals ) > 0 { timeout Interval = to Duration ( intervals [ 0 ] ) } if len ( intervals ) > 1 { polling Interval = to Duration ( intervals [ 1 ] ) } return asyncassertion . New ( asyncassertion . Async Assertion Type Consistently , actual , testingtsupport . Build Testing TGomega Fail Wrapper ( g . t ) , timeout Interval , polling Interval , 0 ) } 
func Message ( actual interface { } , message string , expected . . . interface { } ) string { if len ( expected ) = = 0 { return fmt . Sprintf ( " \n \n " , Object ( actual , 1 ) , message ) } return fmt . Sprintf ( " \n \n \n " , Object ( actual , 1 ) , message , Object ( expected [ 0 ] , 1 ) ) } 
func Message With Diff ( actual , message , expected string ) string { if Truncated Diff & & len ( actual ) > = truncate Threshold & & len ( expected ) > = truncate Threshold { diff Point : = find First Mismatch ( actual , expected ) formatted Actual : = truncate And Format ( actual , diff Point ) formatted Expected : = truncate And Format ( expected , diff Point ) spaces Before Formatted Mismatch : = find First Mismatch ( formatted Actual , formatted Expected ) tab Length : = 4 space From Message To Actual : = tab Length + len ( " " ) - len ( message ) padding : = strings . Repeat ( " " , space From Message To Actual + spaces Before Formatted Mismatch ) + " " return Message ( formatted Actual , message + padding , formatted Expected ) } return Message ( actual , message , expected ) } 
func Object ( object interface { } , indentation uint ) string { indent : = strings . Repeat ( Indent , int ( indentation ) ) value : = reflect . Value Of ( object ) return fmt . Sprintf ( " " , indent , format Type ( object ) , format Value ( value , indentation ) ) } 
func Indent String ( s string , indentation uint ) string { components : = strings . Split ( s , " \n " ) result : = " " indent : = strings . Repeat ( Indent , int ( indentation ) ) for i , component : = range components { result + = indent + component if i < len ( components ) - 1 { result + = " \n " } } return result } 
func is Printable String ( str string ) bool { for _ , rune Value : = range str { if ! strconv . Is Print ( rune Value ) { return false } } return true } 
func Exit ( optional Exit Code . . . int ) * exit Matcher { exit Code : = - 1 if len ( optional Exit Code ) > 0 { exit Code = optional Exit Code [ 0 ] } return & exit Matcher { exit Code : exit Code , } } 
func Match Fields ( options Options , fields Fields ) types . Gomega Matcher { return & Fields Matcher { Fields : fields , Ignore Extras : options & Ignore Extras ! = 0 , Ignore Missing : options & Ignore Missing ! = 0 , } } 
func Say ( expected string , args . . . interface { } ) * say Matcher { if len ( args ) > 0 { expected = fmt . Sprintf ( expected , args . . . ) } return & say Matcher { re : regexp . Must Compile ( expected ) , } } 
func Receive ( args . . . interface { } ) types . Gomega Matcher { var arg interface { } if len ( args ) > 0 { arg = args [ 0 ] } return & matchers . Receive Matcher { Arg : arg , } } 
func Match Regexp ( regexp string , args . . . interface { } ) types . Gomega Matcher { return & matchers . Match Regexp Matcher { Regexp : regexp , Args : args , } } 
func Contain Substring ( substr string , args . . . interface { } ) types . Gomega Matcher { return & matchers . Contain Substring Matcher { Substr : substr , Args : args , } } 
func Have Prefix ( prefix string , args . . . interface { } ) types . Gomega Matcher { return & matchers . Have Prefix Matcher { Prefix : prefix , Args : args , } } 
func Have Suffix ( suffix string , args . . . interface { } ) types . Gomega Matcher { return & matchers . Have Suffix Matcher { Suffix : suffix , Args : args , } } 
func Have Key With Value ( key interface { } , value interface { } ) types . Gomega Matcher { return & matchers . Have Key With Value Matcher { Key : key , Value : value , } } 
func Be Numerically ( comparator string , compare To . . . interface { } ) types . Gomega Matcher { return & matchers . Be Numerically Matcher { Comparator : comparator , Compare To : compare To , } } 
func Be Temporally ( comparator string , compare To time . Time , threshold . . . time . Duration ) types . Gomega Matcher { return & matchers . Be Temporally Matcher { Comparator : comparator , Compare To : compare To , Threshold : threshold , } } 
func And ( ms . . . types . Gomega Matcher ) types . Gomega Matcher { return & matchers . And Matcher { Matchers : ms } } 
func Or ( ms . . . types . Gomega Matcher ) types . Gomega Matcher { return & matchers . Or Matcher { Matchers : ms } } 
func Not ( matcher types . Gomega Matcher ) types . Gomega Matcher { return & matchers . Not Matcher { Matcher : matcher } } 
func With Transform ( transform interface { } , matcher types . Gomega Matcher ) types . Gomega Matcher { return matchers . New With Transform Matcher ( transform , matcher ) } 
func Build ( package Path string , args . . . string ) ( compiled Path string , err error ) { return do Build ( build . Default . GOPATH , package Path , nil , args . . . ) } 
func Build With Environment ( package Path string , env [ ] string , args . . . string ) ( compiled Path string , err error ) { return do Build ( build . Default . GOPATH , package Path , env , args . . . ) } 
func Build In ( gopath string , package Path string , args . . . string ) ( compiled Path string , err error ) { return do Build ( gopath , package Path , nil , args . . . ) } 
func Cleanup Build Artifacts ( ) { mu . Lock ( ) defer mu . Unlock ( ) if tmp Dir ! = " " { os . Remove All ( tmp Dir ) tmp Dir = " " } } 
func Timeout Closer ( c io . Closer , timeout time . Duration ) io . Closer { return timeout Reader Writer Closer { c : c , d : timeout } } 
func Timeout Reader ( r io . Reader , timeout time . Duration ) io . Reader { return timeout Reader Writer Closer { r : r , d : timeout } } 
func Timeout Writer ( w io . Writer , timeout time . Duration ) io . Writer { return timeout Reader Writer Closer { w : w , d : timeout } } 
func Buffer With Bytes ( bytes [ ] byte ) * Buffer { return & Buffer { lock : & sync . Mutex { } , contents : bytes , } } 
func Buffer Reader ( reader io . Reader ) * Buffer { b : = & Buffer { lock : & sync . Mutex { } , } go func ( ) { io . Copy ( b , reader ) b . Close ( ) } ( ) return b } 
func ( b * Buffer ) Write ( p [ ] byte ) ( n int , err error ) { b . lock . Lock ( ) defer b . lock . Unlock ( ) if b . closed { return 0 , errors . New ( " " ) } b . contents = append ( b . contents , p . . . ) return len ( p ) , nil } 
func ( b * Buffer ) Read ( d [ ] byte ) ( int , error ) { b . lock . Lock ( ) defer b . lock . Unlock ( ) if b . closed { return 0 , errors . New ( " " ) } if uint 6 4 ( len ( b . contents ) ) < = b . read Cursor { return 0 , io . EOF } n : = copy ( d , b . contents [ b . read Cursor : ] ) b . read Cursor + = uint 6 4 ( n ) return n , nil } 
func ( b * Buffer ) Close ( ) error { b . lock . Lock ( ) defer b . lock . Unlock ( ) b . closed = true return nil } 
func ( b * Buffer ) Closed ( ) bool { b . lock . Lock ( ) defer b . lock . Unlock ( ) return b . closed } 
func ( b * Buffer ) Contents ( ) [ ] byte { b . lock . Lock ( ) defer b . lock . Unlock ( ) contents : = make ( [ ] byte , len ( b . contents ) ) copy ( contents , b . contents ) return contents } 
func ( b * Buffer ) Detect ( desired string , args . . . interface { } ) chan bool { formatted Regexp : = desired if len ( args ) > 0 { formatted Regexp = fmt . Sprintf ( desired , args . . . ) } re : = regexp . Must Compile ( formatted Regexp ) b . lock . Lock ( ) defer b . lock . Unlock ( ) if b . detect Closer = = nil { b . detect Closer = make ( chan interface { } ) } closer : = b . detect Closer response : = make ( chan bool ) go func ( ) { ticker : = time . New Ticker ( 1 0 * time . Millisecond ) defer ticker . Stop ( ) defer close ( response ) for { select { case < - ticker . C : b . lock . Lock ( ) data , cursor : = b . contents [ b . read Cursor : ] , b . read Cursor loc : = re . Find Index ( data ) b . lock . Unlock ( ) if loc ! = nil { response < - true b . lock . Lock ( ) new Cursor Position : = cursor + uint 6 4 ( loc [ 1 ] ) if new Cursor Position > = b . read Cursor { b . read Cursor = new Cursor Position } b . lock . Unlock ( ) return } case < - closer : return } } } ( ) return response } 
func ( b * Buffer ) Cancel Detects ( ) { b . lock . Lock ( ) defer b . lock . Unlock ( ) close ( b . detect Closer ) b . detect Closer = nil } 
func Nest ( path string , err error ) error { if ag , ok : = err . ( Aggregate Error ) ; ok { var errs Aggregate Error for _ , e : = range ag { errs = append ( errs , Nest ( path , e ) ) } return errs } if ne , ok : = err . ( * Nested Error ) ; ok { return & Nested Error { Path : path + ne . Path , Err : ne . Err , } } return & Nested Error { Path : path , Err : err , } } 
func ( err Aggregate Error ) Error ( ) string { if len ( err ) = = 0 { } if len ( err ) = = 1 { return err [ 0 ] . Error ( ) } result : = fmt . Sprintf ( " " , err [ 0 ] . Error ( ) ) for i : = 1 ; i < len ( err ) ; i + + { result + = fmt . Sprintf ( " " , err [ i ] . Error ( ) ) } result + = " " return result } 
func Match All Elements ( identifier Identifier , elements Elements ) types . Gomega Matcher { return & Elements Matcher { Identifier : identifier , Elements : elements , } } 
func Match Elements ( identifier Identifier , options Options , elements Elements ) types . Gomega Matcher { return & Elements Matcher { Identifier : identifier , Elements : elements , Ignore Extras : options & Ignore Extras ! = 0 , Ignore Missing : options & Ignore Missing ! = 0 , Allow Duplicates : options & Allow Duplicates ! = 0 , } } 
func Set Mock Service ( m * Mock Service ) { m . Cache = & cache . Mock App Cache Service { } m . Plan = & app . Mock Plan Service { } m . Platform = & app . Mock Platform Service { } m . Platform Image = & image . Mock Platform Image Service { } m . Team = & auth . Mock Team Service { } m . User Quota = & quota . Mock Quota Service { } m . App Quota = & quota . Mock Quota Service { } m . Cluster = & provision . Mock Cluster Service { } m . Service Broker = & service . Mock Service Broker Service { } m . Service Broker Catalog Cache = & service . Mock Service Broker Catalog Cache Service { } servicemanager . App Cache = m . Cache servicemanager . Plan = m . Plan servicemanager . Platform = m . Platform servicemanager . Platform Image = m . Platform Image servicemanager . Team = m . Team servicemanager . User Quota = m . User Quota servicemanager . App Quota = m . App Quota servicemanager . Cluster = m . Cluster servicemanager . Service Broker = m . Service Broker servicemanager . Service Broker Catalog Cache = m . Service Broker Catalog Cache } 
func Open ( addr , dbname string ) ( storage * Storage , err error ) { session Lock . RLock ( ) if sessions [ addr ] = = nil { session Lock . RUnlock ( ) session Lock . Lock ( ) if sessions [ addr ] = = nil { sessions [ addr ] , err = open ( addr ) } session Lock . Unlock ( ) if err ! = nil { return } } else { session Lock . RUnlock ( ) } cloned : = sessions [ addr ] . Clone ( ) runtime . Set Finalizer ( cloned , session Finalizer ) storage = & Storage { session : cloned , dbname : dbname , } return } 
func Find Machine By Id Or Address ( id string , address string ) ( Machine , error ) { coll , err : = collection ( ) if err ! = nil { return Machine { } , err } defer coll . Close ( ) var result Machine query : = bson . M { } if id ! = " " { query [ " " ] = id } else { query [ " " ] = address } err = coll . Find ( query ) . One ( & result ) if err = = mgo . Err Not Found { err = Err Machine Not Found } return result , err } 
func ( w * Flushing Writer ) Write ( data [ ] byte ) ( written int , err error ) { w . write Mutex . Lock ( ) defer w . write Mutex . Unlock ( ) w . wrote = true written , err = w . Response Writer . Write ( data ) if err ! = nil { return } if f , ok : = w . Response Writer . ( http . Flusher ) ; ok { defer func ( ) { if r : = recover ( ) ; r ! = nil { msg : = fmt . Sprintf ( " " , r ) log . Debugf ( msg ) err = errors . Errorf ( msg ) } } ( ) f . Flush ( ) } return } 
func ( w * Flushing Writer ) Hijack ( ) ( net . Conn , * bufio . Read Writer , error ) { if hijacker , ok : = w . Response Writer . ( http . Hijacker ) ; ok { return hijacker . Hijack ( ) } return nil , nil , errors . New ( " " ) } 
func List Deploys ( filter * Filter , skip , limit int ) ( [ ] Deploy Data , error ) { apps List , err : = List ( filter ) if err ! = nil { return nil , err } apps : = make ( [ ] string , len ( apps List ) ) for i , a : = range apps List { apps [ i ] = a . Get Name ( ) } evts , err : = event . List ( & event . Filter { Target : event . Target { Type : event . Target Type App } , Raw : bson . M { " " : bson . M { " " : apps } } , Kind Names : [ ] string { permission . Perm App Deploy . Full Name ( ) } , Kind Type : event . Kind Type Permission , Limit : limit , Skip : skip , } ) if err ! = nil { return nil , err } valid Images , err : = find Valid Images ( apps List . . . ) if err ! = nil { return nil , err } list : = make ( [ ] Deploy Data , len ( evts ) ) for i : = range evts { list [ i ] = * event To Deploy Data ( & evts [ i ] , valid Images , false ) } return list , nil } 
func Deploy ( opts Deploy Options ) ( string , error ) { if opts . Event = = nil { return " " , errors . Errorf ( " " ) } if opts . Rollback & & ! regexp . Must Compile ( " " ) . Match String ( opts . Image ) { image Name , err : = image . Get App Image By Suffix ( opts . App . Name , opts . Image ) if err ! = nil { return " " , err } opts . Image = image Name } log Writer : = Log Writer { App : opts . App } log Writer . Async ( ) defer log Writer . Close ( ) opts . Event . Set Log Writer ( io . Multi Writer ( & tsuru Io . No Error Writer { Writer : opts . Output Stream } , & log Writer ) ) image ID , err : = deploy To Provisioner ( & opts , opts . Event ) rebuild . Routes Rebuild Or Enqueue ( opts . App . Name ) quota Err : = opts . App . fix Quota ( ) if quota Err ! = nil { log . Errorf ( " " , quota Err ) } if err ! = nil { var log Lines [ ] Applog if provision . Is Startup Error ( err ) { log Lines , _ = opts . App . last Logs ( 1 0 , Applog { Source : " " , } , true ) } err = & error With Log { err : err , logs : log Lines } return " " , err } err = increment Deploy ( opts . App ) if err ! = nil { log . Errorf ( " " , opts ) } if opts . Kind = = Deploy Image | | opts . Kind = = Deploy Rollback { if ! opts . App . Update Platform { opts . App . Set Update Platform ( true ) } } else if opts . App . Update Platform { opts . App . Set Update Platform ( false ) } return image ID , nil } 
func event List ( w http . Response Writer , r * http . Request , t auth . Token ) error { var filter * event . Filter err : = Parse Input ( r , & filter ) if err ! = nil { return err } filter . Load Kind Names ( r . Form ) filter . Prune User Values ( ) filter . Permissions , err = t . Permissions ( ) if err ! = nil { return err } events , err : = event . List ( filter ) if err ! = nil { return err } if len ( events ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( events ) } 
func kind List ( w http . Response Writer , r * http . Request , t auth . Token ) error { kinds , err : = event . Get Kinds ( ) if err ! = nil { return err } if len ( kinds ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( kinds ) } 
func event Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { uuid : = r . URL . Query ( ) . Get ( " " ) if ! bson . Is Object Id Hex ( uuid ) { msg : = fmt . Sprintf ( " " , uuid ) return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } obj ID : = bson . Object Id Hex ( uuid ) e , err : = event . Get By ID ( obj ID ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } scheme , err : = permission . Safe Get ( e . Allowed . Scheme ) if err ! = nil { return err } allowed : = permission . Check ( t , scheme , e . Allowed . Contexts . . . ) if ! allowed { return permission . Err Unauthorized } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( e ) } 
func event Cancel ( w http . Response Writer , r * http . Request , t auth . Token ) error { uuid : = r . URL . Query ( ) . Get ( " " ) if ! bson . Is Object Id Hex ( uuid ) { msg : = fmt . Sprintf ( " " , uuid ) return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } obj ID : = bson . Object Id Hex ( uuid ) e , err : = event . Get By ID ( obj ID ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } reason : = Input Value ( r , " " ) if reason = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } scheme , err : = permission . Safe Get ( e . Allowed Cancel . Scheme ) if err ! = nil { return err } allowed : = permission . Check ( t , scheme , e . Allowed Cancel . Contexts . . . ) if ! allowed { return permission . Err Unauthorized } err = e . Try Cancel ( reason , t . Get User Name ( ) ) if err ! = nil { if err = = event . Err Not Cancelable { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } w . Write Header ( http . Status No Content ) return nil } 
func event Block List ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Event Block Read ) { return permission . Err Unauthorized } var active * bool if active Str : = Input Value ( r , " " ) ; active Str ! = " " { b , _ : = strconv . Parse Bool ( active Str ) active = & b } blocks , err : = event . List Blocks ( active ) if err ! = nil { return err } if len ( blocks ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( blocks ) } 
func event Block Add ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Event Block Add ) { return permission . Err Unauthorized } var block event . Block err = Parse Input ( r , & block ) if err ! = nil { return err } if block . Reason = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Event Block } , Kind : permission . Perm Event Block Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Event Block Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Target . Value = block . ID . Hex ( ) evt . Done ( err ) } ( ) return event . Add Block ( & block ) } 
func event Block Remove ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Event Block Remove ) { return permission . Err Unauthorized } uuid : = r . URL . Query ( ) . Get ( " " ) if ! bson . Is Object Id Hex ( uuid ) { msg : = fmt . Sprintf ( " " , uuid ) return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } obj ID : = bson . Object Id Hex ( uuid ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Event Block , Value : obj ID . Hex ( ) } , Kind : permission . Perm Event Block Remove , Owner : t , Custom Data : [ ] map [ string ] interface { } { { " " : " " , " " : obj ID . Hex ( ) } , } , Allowed : event . Allowed ( permission . Perm Event Block Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = event . Remove Block ( obj ID ) if _ , ok : = err . ( * event . Err Active Event Block Not Found ) ; ok { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func get User Quota ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed : = permission . Check ( t , permission . Perm User Update Quota ) if ! allowed { return permission . Err Unauthorized } email : = r . URL . Query ( ) . Get ( " " ) user , err : = auth . Get User By Email ( email ) if err = = auth Types . Err User Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( user . Quota ) } 
func change User Quota ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { email : = r . URL . Query ( ) . Get ( " " ) allowed : = permission . Check ( t , permission . Perm User Update Quota , permission . Context ( perm Types . Ctx User , email ) ) if ! allowed { return permission . Err Unauthorized } user , err : = auth . Get User By Email ( email ) if err = = auth Types . Err User Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } else if err ! = nil { return err } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type User , Value : email } , Kind : permission . Perm User Update Quota , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) limit , err : = strconv . Atoi ( Input Value ( r , " " ) ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } err = servicemanager . User Quota . Set Limit ( user . Email , limit ) if err = = quota . Err Limit Lower Than Allocated { return & errors . HTTP { Code : http . Status Forbidden , Message : err . Error ( ) , } } return err } 
func change App Quota ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Admin Quota , contexts For App ( & a ) . . . ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type App , Value : app Name } , Kind : permission . Perm App Admin Quota , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) limit , err : = strconv . Atoi ( Input Value ( r , " " ) ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } err = a . Set Quota Limit ( limit ) if err = = quota . Err Limit Lower Than Allocated { return & errors . HTTP { Code : http . Status Forbidden , Message : err . Error ( ) , } } return err } 
func ( r * Delayed Router ) Add All ( version , path string , h http . Handler ) * mux . Route { return r . add Route ( version , path , h , " " , " " , " " , " " ) } 
func saml Request Timeout ( scheme Data map [ string ] string ) int { p : = scheme Data [ " " ] timeout , _ : = strconv . Atoi ( p ) return timeout } 
func Register Handler ( path string , method string , h http . Handler ) { Register Handler Version ( " " , path , method , h ) } 
func Register Handler Version ( version , path , method string , h http . Handler ) { var th Tsuru Handler th . version = version th . path = path th . method = method th . h = h tsuru Handler List = append ( tsuru Handler List , th ) } 
func Run Server ( dry bool ) http . Handler { err : = log . Init ( ) if err ! = nil { std Log . Fatalf ( " " , err ) } err = Initialize DBServices ( ) if err ! = nil { fatal ( err ) } m : = api Router . New Router ( ) for _ , handler : = range tsuru Handler List { m . Add ( handler . version , handler . method , handler . path , handler . h ) } if disable Index , _ : = config . Get Bool ( " " ) ; ! disable Index { m . Add ( " " , " " , " " , Handler ( index ) ) } m . Add ( " " , " " , " " , Handler ( info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Instances ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( create Service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update Service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( bind Service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( unbind Service Instance ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Instance Status ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Instance Grant Team ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Instance Revoke Team ) ) proxy Instance Handler : = Authorization Required Handler ( service Instance Proxy ) proxy Service Handler : = Authorization Required Handler ( service Proxy ) m . Add All ( " " , " " , proxy Instance Handler ) m . Add All ( " " , " " , proxy Service Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( service List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Plans ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Doc ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Add Doc ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( grant Service Access ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( revoke Service Access ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( set CName ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( unset CName ) ) run Handler : = Authorization Required Handler ( run Command ) m . Add ( " " , " " , " " , run Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( restart ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( start ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( stop ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( sleep ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( get App Quota ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( change App Quota ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update App ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( get Env ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( set Env ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( unset Env ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( create App ) ) force Delete Lock Handler : = Authorization Required Handler ( force Delete Lock ) m . Add ( " " , " " , " " , force Delete Lock Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Units ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Units ) ) register Unit Handler : = Authorization Required Handler ( register Unit ) m . Add ( " " , " " , " " , register Unit Handler ) set Unit Status Handler : = Authorization Required Handler ( set Unit Status ) m . Add ( " " , " " , " " , set Unit Status Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( grant App Access ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( revoke App Access ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app Log ) ) log Post Handler : = Authorization Required Handler ( add Log ) m . Add ( " " , " " , " " , log Post Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploy Rollback ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploy Rollback Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploy Rebuild ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app Metric Envs ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( app Rebuild Routes ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Certificates ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( set Certificate ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( unset Certificate ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add App Router ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update App Router ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove App Router ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list App Routers ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( set Node Status ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploys List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploy Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event Block List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event Block Add ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event Block Remove ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( kind List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( event Cancel ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( webhook List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( webhook Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( webhook Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( webhook Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( webhook Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform Add ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform Remove ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( platform Rollback ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( deploy ) ) diff Deploy Handler : = Authorization Required Handler ( diff Deploy ) m . Add ( " " , " " , " " , diff Deploy Handler ) m . Add ( " " , " " , " " , Authorization Required Handler ( build ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Users ) ) m . Add ( " " , " " , " " , Handler ( create User ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( user Info ) ) m . Add ( " " , " " , " " , Handler ( auth Scheme ) ) m . Add ( " " , " " , " " , Handler ( login ) ) m . Add ( " " , " " , " " , Handler ( saml Callback Login ) ) m . Add ( " " , " " , " " , Handler ( saml Metadata ) ) m . Add ( " " , " " , " " , Handler ( reset Password ) ) m . Add ( " " , " " , " " , Handler ( login ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( get User Quota ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( change User Quota ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( logout ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( change Password ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove User ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Keys ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Key To User ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Key From User ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( show APIToken ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( regenerate APIToken ) ) m . Add ( " " , " " , " " , websocket . Handler ( add Logs ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( team List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( create Team ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Team ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update Team ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( team Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( swap ) ) m . Add ( " " , " " , " " , http . Handler Func ( healthcheck ) ) m . Add ( " " , " " , " " , http . Handler Func ( healthcheck ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( machines List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( machine Destroy ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( templates List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( template Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( template Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( template Destroy ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Plans ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Plan ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Plan ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( pool List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Pool Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Pool Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( pool Update Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Team To Pool Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Team To Pool Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( pool Constraint List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( pool Constraint Set ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Roles ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( role Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( role Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Permissions ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Permissions ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( assign Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( dissociate Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Default Roles ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Default Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Default Role ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Permissions ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( assign Role To Token ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( dissociate Role From Token ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( dump Goroutines ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( index Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( cmdline Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( profile Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( symbol Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( index Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( index Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( index Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( index Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( trace Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale History Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Get Config ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Run Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale List Rules ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Set Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Delete Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Delete Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Nodes Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Units By App ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Units By Node ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( rebalance Nodes Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( info Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Upgrade ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( install Host Add ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( install Host List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( install Host Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Read ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( healing History Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Routers ) ) m . Add ( " " , " " , " " , promhttp . Handler ( ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( provisioner List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( create Cluster ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update Cluster ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Clusters ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( delete Cluster ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volumes List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Bind ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Unbind ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( volume Plans List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( token List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( token Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( token Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( token Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( token Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Broker List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Broker Add ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Broker Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( service Broker Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Nodes Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Units By App ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Units By Node ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( add Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( update Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( remove Node Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( rebalance Nodes Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container List ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Create ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Info ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Container Upgrade ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Read ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Update ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( node Healing Delete ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( healing History Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale History Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Get Config ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Run Handler ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale List Rules ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Set Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Delete Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( auto Scale Delete Rule ) ) m . Add ( " " , " " , " " , Authorization Required Handler ( list Routers ) ) n : = negroni . New ( ) n . Use ( negroni . New Recovery ( ) ) n . Use ( negroni . Handler Func ( context Clearer Middleware ) ) if ! dry { n . Use ( new Logger Middleware ( ) ) } n . Use Handler ( m ) n . Use ( negroni . Handler Func ( flushing Writer Middleware ) ) n . Use ( negroni . Handler Func ( set Request IDHeader Middleware ) ) n . Use ( negroni . Handler Func ( error Handling Middleware ) ) n . Use ( negroni . Handler Func ( set Version Headers Middleware ) ) n . Use ( negroni . Handler Func ( auth Token Middleware ) ) n . Use ( & app Lock Middleware { excluded Handlers : [ ] http . Handler { log Post Handler , run Handler , force Delete Lock Handler , register Unit Handler , set Unit Status Handler , diff Deploy Handler , } } ) n . Use Handler ( http . Handler Func ( run Delayed Handler ) ) if ! dry { err : = start Server ( n ) if err ! = nil { fatal ( err ) } } return n } 
func validate TLSCertificate ( c * tls . Certificate , roots * x 5 0 9 . Cert Pool ) error { config Host , err : = config . Get String ( " " ) if err ! = nil { return err } url Host , err : = url . Parse ( config Host ) if err ! = nil { return err } hostname : = url Host . Hostname ( ) if c = = nil | | len ( c . Certificate ) = = 0 { return errors . New ( " " ) } var intermediate Cert Pool * x 5 0 9 . Cert Pool if len ( c . Certificate ) > 1 { intermediate Cert Pool = x 5 0 9 . New Cert Pool ( ) for i : = 1 ; i < len ( c . Certificate ) ; i + + { var intermerdiate Cert * x 5 0 9 . Certificate if intermerdiate Cert , err = x 5 0 9 . Parse Certificate ( c . Certificate [ i ] ) ; err ! = nil { return err } intermediate Cert Pool . Add Cert ( intermerdiate Cert ) } } leaf Cert , err : = x 5 0 9 . Parse Certificate ( c . Certificate [ 0 ] ) if err ! = nil { return err } _ , err = leaf Cert . Verify ( x 5 0 9 . Verify Options { DNSName : hostname , Roots : roots , Intermediates : intermediate Cert Pool , } ) return err } 
func Check ( names . . . string ) [ ] Result { results : = make ( [ ] Result , 0 , len ( checkers ) ) name Set : = set . From Slice ( names ) is All : = name Set . Includes ( " " ) for _ , checker : = range checkers { if ! is All & & ! name Set . Includes ( checker . name ) { continue } start Time : = time . Now ( ) if err : = checker . check ( ) ; err ! = nil & & err ! = Err Disabled Component { results = append ( results , Result { Name : checker . name , Status : " " + err . Error ( ) , Duration : time . Since ( start Time ) , } ) } else if err = = nil { results = append ( results , Result { Name : checker . name , Status : Health Check OK , Duration : time . Since ( start Time ) , } ) } } return results } 
func index Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } pprof . Index ( w , r ) return nil } 
func cmdline Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } pprof . Cmdline ( w , r ) return nil } 
func profile Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } pprof . Profile ( w , r ) return nil } 
func symbol Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } pprof . Symbol ( w , r ) return nil } 
func trace Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } pprof . Trace ( w , r ) return nil } 
func Discover Repository Path ( dir string ) ( string , error ) { _ , err : = os . Stat ( dir ) if os . Is Not Exist ( err ) { return " " , Err Repository Not Found } dir = filepath . Join ( dir , " " ) for dir ! = " " { fi , err : = os . Stat ( dir ) if err = = nil & & fi . Is Dir ( ) { return dir , nil } dir = filepath . Join ( dir , " " , " " , " " ) } return " " , Err Repository Not Found } 
func Open Repository ( p string ) ( * Repository , error ) { if ! strings . Has Suffix ( p , " " ) & & ! strings . Has Suffix ( p , " " ) { p = filepath . Join ( p , " " ) } p = strings . Trim Right ( p , " " ) fi , err : = os . Stat ( filepath . Join ( p , " " ) ) if err = = nil & & ! fi . Is Dir ( ) { return & Repository { path : p } , nil } return nil , Err Repository Not Found } 
func ( r * Repository ) Remote URL ( name string ) ( string , error ) { config , err : = os . Open ( filepath . Join ( r . path , " " ) ) if err ! = nil { return " " , err } defer config . Close ( ) line : = fmt . Sprintf ( " " , name ) scanner : = bufio . New Scanner ( config ) scanner . Split ( bufio . Scan Lines ) for scanner . Scan ( ) { if scanner . Text ( ) = = line { scanner . Scan ( ) return strings . Split ( scanner . Text ( ) , " " ) [ 1 ] , nil } } return " " , err Remote Not Found { name } } 
func token List ( w http . Response Writer , r * http . Request , t auth . Token ) error { tokens , err : = servicemanager . Team Token . Find By User Token ( t ) if err ! = nil { return err } if len ( tokens ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( tokens ) } 
func token Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { token ID : = r . URL . Query ( ) . Get ( " " ) if token ID = = " " { w . Write Header ( http . Status Bad Request ) return nil } team Token , err : = servicemanager . Team Token . Info ( token ID , t ) if err = = auth Types . Err Team Token Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Team Token Read , permission . Context ( perm Types . Ctx Team , team Token . Team ) , ) if ! allowed { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( team Token ) } 
func token Create ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var args auth Types . Team Token Create Args err = Parse Input ( r , & args ) if err ! = nil { return err } if args . Team = = " " { args . Team , err = auto Team Owner ( t , permission . Perm Team Token Create ) if err ! = nil { return err } } allowed : = permission . Check ( t , permission . Perm Team Token Create , permission . Context ( perm Types . Ctx Team , args . Team ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : team Target ( args . Team ) , Kind : permission . Perm Team Token Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , args . Team ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) token , err : = servicemanager . Team Token . Create ( args , t ) if err ! = nil { return err } if err ! = nil { if err = = auth Types . Err Team Token Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } return err } w . Write Header ( http . Status Created ) return json . New Encoder ( w ) . Encode ( token ) } 
func token Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var args auth Types . Team Token Update Args err = Parse Input ( r , & args ) if err ! = nil { return err } args . Token ID = r . URL . Query ( ) . Get ( " " ) team Token , err : = servicemanager . Team Token . Find By Token ID ( args . Token ID ) if err ! = nil { if err = = auth Types . Err Team Token Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } allowed : = permission . Check ( t , permission . Perm Team Token Update , permission . Context ( perm Types . Ctx Team , team Token . Team ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : team Target ( team Token . Team ) , Kind : permission . Perm Team Token Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , team Token . Team ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) team Token , err = servicemanager . Team Token . Update ( args , t ) if err = = auth Types . Err Team Token Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } if err ! = nil { return err } return json . New Encoder ( w ) . Encode ( team Token ) } 
func token Delete ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { token ID : = r . URL . Query ( ) . Get ( " " ) team Token , err : = servicemanager . Team Token . Find By Token ID ( token ID ) if err ! = nil { if err = = auth Types . Err Team Token Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } team Name : = team Token . Team allowed : = permission . Check ( t , permission . Perm Team Token Delete , permission . Context ( perm Types . Ctx Team , team Name ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : team Target ( team Name ) , Kind : permission . Perm Team Token Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , team Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Team Token . Delete ( token ID ) if err = = auth Types . Err Team Token Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } 
func add Role ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Create ) { return permission . Err Unauthorized } role Name : = Input Value ( r , " " ) if role Name = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : perm Types . Err Invalid Role Name . Error ( ) , } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) _ , err = permission . New Role ( role Name , Input Value ( r , " " ) , Input Value ( r , " " ) ) if err = = perm Types . Err Invalid Role Name { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } if err = = perm Types . Err Role Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } if err = = nil { w . Write Header ( http . Status Created ) } return err } 
func remove Role ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Delete ) { return permission . Err Unauthorized } role Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) users With Role , err : = auth . List Users With Role ( role Name ) if err ! = nil { return err } if len ( users With Role ) ! = 0 { return & errors . HTTP { Code : http . Status Precondition Failed , Message : perm Types . Err Remove Role With Users . Error ( ) } } err = permission . Destroy Role ( role Name ) if err = = perm Types . Err Role Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func list Roles ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! ( permission . Check ( t , permission . Perm Role Update ) | | permission . Check ( t , permission . Perm Role Update Assign ) | | permission . Check ( t , permission . Perm Role Update Dissociate ) | | permission . Check ( t , permission . Perm Role Create ) | | permission . Check ( t , permission . Perm Role Delete ) ) { return permission . Err Unauthorized } roles , err : = permission . List Roles ( ) if err ! = nil { return err } b , err : = json . Marshal ( roles ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) _ , err = w . Write ( b ) return err } 
func role Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! ( permission . Check ( t , permission . Perm Role Update ) | | permission . Check ( t , permission . Perm Role Update Assign ) | | permission . Check ( t , permission . Perm Role Update Dissociate ) | | permission . Check ( t , permission . Perm Role Create ) | | permission . Check ( t , permission . Perm Role Delete ) ) { return permission . Err Unauthorized } role Name : = r . URL . Query ( ) . Get ( " " ) role , err : = permission . Find Role ( role Name ) if err = = perm Types . Err Role Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } if err ! = nil { return err } b , err : = json . Marshal ( role ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) _ , err = w . Write ( b ) return err } 
func add Permissions ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Update Permission Add ) { return permission . Err Unauthorized } role Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Update Permission Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) role , err : = permission . Find Role ( role Name ) if err ! = nil { return err } users , err : = auth . List Users With Role ( role Name ) if err ! = nil { return err } err = run With Perm Sync ( users , func ( ) error { permissions , _ : = Input Values ( r , " " ) return role . Add Permissions ( permissions . . . ) } ) if err = = perm Types . Err Invalid Permission Name { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } if perr , ok : = err . ( * perm Types . Err Permission Not Found ) ; ok { return & errors . HTTP { Code : http . Status Bad Request , Message : perr . Error ( ) , } } if perr , ok : = err . ( * perm Types . Err Permission Not Allowed ) ; ok { return & errors . HTTP { Code : http . Status Conflict , Message : perr . Error ( ) , } } return err } 
func remove Permissions ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Update Permission Remove ) { return permission . Err Unauthorized } role Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Update Permission Remove , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) perm Name : = r . URL . Query ( ) . Get ( " " ) role , err : = permission . Find Role ( role Name ) if err ! = nil { if err = = perm Types . Err Role Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } users , err : = auth . List Users With Role ( role Name ) if err ! = nil { return err } err = run With Perm Sync ( users , func ( ) error { return role . Remove Permissions ( perm Name ) } ) return err } 
func assign Role ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Update Assign ) { return permission . Err Unauthorized } role Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Update Assign , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) email : = Input Value ( r , " " ) context Value : = Input Value ( r , " " ) user , err : = auth . Get User By Email ( email ) if err ! = nil { return err } err = can Use Role ( t , role Name , context Value ) if err ! = nil { return err } err = run With Perm Sync ( [ ] auth . User { * user } , func ( ) error { return user . Add Role ( role Name , context Value ) } ) return err } 
func list Permissions ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Role Update ) { return permission . Err Unauthorized } lst : = permission . Permission Registry . Permissions ( ) sort . Sort ( lst ) perm List : = make ( [ ] permission Scheme Data , len ( lst ) ) for i , perm : = range lst { contexts : = perm . Allowed Contexts ( ) context Names : = make ( [ ] string , len ( contexts ) ) for j , ctx : = range contexts { context Names [ j ] = string ( ctx ) } perm List [ i ] = permission Scheme Data { Name : perm . Full Name ( ) , Contexts : context Names , } } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( perm List ) } 
func add Default Role ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Role Default Create ) { return permission . Err Unauthorized } roles Map : = map [ string ] [ ] string { } for evt Name : = range perm Types . Role Event Map { roles , _ : = Input Values ( r , evt Name ) for _ , role Name : = range roles { roles Map [ role Name ] = append ( roles Map [ role Name ] , evt Name ) } } for role Name , evts : = range roles Map { evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Default Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) role , err : = permission . Find Role ( role Name ) if err ! = nil { if err = = perm Types . Err Role Not Found { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } return err } for _ , evt Name : = range evts { err = role . Add Event ( evt Name ) if err ! = nil { if _ , ok : = err . ( perm Types . Err Role Event Wrong Context ) ; ok { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } return err } } } return nil } 
func list Default Roles ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Role Default Create ) & & ! permission . Check ( t , permission . Perm Role Default Delete ) { return permission . Err Unauthorized } roles , err : = permission . List Roles With Events ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( roles ) } 
func role Update ( w http . Response Writer , r * http . Request , t auth . Token ) error { role Name : = Input Value ( r , " " ) new Name : = Input Value ( r , " " ) context Type : = Input Value ( r , " " ) description : = Input Value ( r , " " ) var wanted Perms [ ] * permission . Permission Scheme if new Name ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Role Update Name ) } if context Type ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Role Update Context Type ) } if description ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Role Update Description ) } if len ( wanted Perms ) = = 0 { msg : = " " return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } for _ , perm : = range wanted Perms { if ! permission . Check ( t , perm ) { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Update ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = auth . Update Role From All Users ( role Name , new Name , context Type , description ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } return nil } 
func assign Role To Token ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Role Update Assign ) { return permission . Err Unauthorized } token ID : = Input Value ( r , " " ) context Value : = Input Value ( r , " " ) role Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Role , Value : role Name } , Kind : permission . Perm Role Update Assign , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Role Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = can Use Role ( t , role Name , context Value ) if err ! = nil { return err } err = servicemanager . Team Token . Add Role ( token ID , role Name , context Value ) if err = = auth Types . Err Team Token Not Found { w . Write Header ( http . Status Not Found ) return nil } return err } 
func ( s * app Lister ) List ( selector labels . Selector ) ( ret [ ] * v 1 . App , err error ) { err = cache . List All ( s . indexer , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v 1 . App ) ) } ) return ret , err } 
func ( s * app Lister ) Apps ( namespace string ) App Namespace Lister { return app Namespace Lister { indexer : s . indexer , namespace : namespace } } 
func ( s app Namespace Lister ) List ( selector labels . Selector ) ( ret [ ] * v 1 . App , err error ) { err = cache . List All By Namespace ( s . indexer , s . namespace , selector , func ( m interface { } ) { ret = append ( ret , m . ( * v 1 . App ) ) } ) return ret , err } 
func ( d * Docker Machine ) Register Machine ( opts Register Machine Opts ) ( * Machine , error ) { if ! d . temp { return nil , errors . New ( " " ) } if opts . Base . Custom Data = = nil { return nil , errors . New ( " " ) } opts . Base . Custom Data [ " " ] = filepath . Join ( d . client . Get Machines Dir ( ) , opts . Base . Id , " " ) raw Driver , err : = json . Marshal ( opts . Base . Custom Data ) if err ! = nil { return nil , errors . With Message ( err , " " ) } h , err : = d . client . New Host ( opts . Driver Name , raw Driver ) if err ! = nil { return nil , errors . With Stack ( err ) } err = ioutil . Write File ( h . Driver . Get SSHKey Path ( ) , opts . SSHPrivate Key , 0 7 0 0 ) if err ! = nil { return nil , errors . With Stack ( err ) } err = ioutil . Write File ( h . Auth Options ( ) . Ca Cert Path , opts . Base . Ca Cert , 0 7 0 0 ) if err ! = nil { return nil , errors . With Stack ( err ) } err = ioutil . Write File ( h . Auth Options ( ) . Client Cert Path , opts . Base . Client Cert , 0 7 0 0 ) if err ! = nil { return nil , errors . With Stack ( err ) } err = ioutil . Write File ( h . Auth Options ( ) . Client Key Path , opts . Base . Client Key , 0 7 0 0 ) if err ! = nil { return nil , errors . With Stack ( err ) } err = d . client . Save ( h ) if err ! = nil { return nil , errors . With Stack ( err ) } saved Host , err : = d . client . Load ( h . Name ) if err ! = nil { return nil , errors . With Stack ( err ) } return & Machine { Base : opts . Base , Host : saved Host , } , nil } 
func Stream JSONResponse ( w io . Writer , response * http . Response ) error { if response = = nil { return errors . New ( " " ) } defer response . Body . Close ( ) var err error output : = tsuruio . New Stream Writer ( w , nil ) for n : = int 6 4 ( 1 ) ; n > 0 & & err = = nil ; n , err = io . Copy ( output , response . Body ) { } if err ! = nil { return err } unparsed : = output . Remaining ( ) if len ( unparsed ) > 0 { return errors . Errorf ( " " , string ( unparsed ) ) } return nil } 
func ( s * Storage ) Drop Database ( name string ) error { return s . session . DB ( name ) . Drop Database ( ) } 
func ( s * Storage ) Collection ( name string ) * Collection { return & Collection { Collection : s . session . DB ( s . dbname ) . C ( name ) } } 
func ( s * OAuth Scheme ) load Config ( ) ( oauth 2 . Config , error ) { if s . Base Config . Client ID ! = " " { return s . Base Config , nil } if s . Parser = = nil { s . Parser = s } var empty Config oauth 2 . Config client Id , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } client Secret , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } scope , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } auth URL , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } token URL , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } info URL , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } callback Port , err : = config . Get Int ( " " ) if err ! = nil { log . Debugf ( " " , err ) } s . Info URL = info URL s . Callback Port = callback Port s . Base Config = oauth 2 . Config { Client ID : client Id , Client Secret : client Secret , Scopes : [ ] string { scope } , Endpoint : oauth 2 . Endpoint { Auth URL : auth URL , Token URL : token URL , } , } return s . Base Config , nil } 
func ( t * Target ) Set Logger ( l Logger ) { t . mut . Lock ( ) defer t . mut . Unlock ( ) t . logger = l } 
func ( t * Target ) Error ( v error ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger ! = nil { t . logger . Errorf ( " " , v ) } } 
func ( t * Target ) Errorf ( format string , v . . . interface { } ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger ! = nil { t . logger . Errorf ( format , v . . . ) for _ , item : = range v { if _ , has Stack : = item . ( with Stack ) ; has Stack { t . logger . Errorf ( " " , item ) } } } } 
func ( t * Target ) Fatal ( v string ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger ! = nil { t . logger . Fatal ( v ) } } 
func ( t * Target ) Debugf ( format string , v . . . interface { } ) { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger ! = nil { t . logger . Debugf ( format , v . . . ) } } 
func ( t * Target ) Get Std Logger ( ) * log . Logger { t . mut . RLock ( ) defer t . mut . RUnlock ( ) if t . logger ! = nil { return t . logger . Get Std Logger ( ) } return nil } 
func ( c * Cluster Client ) Namespace ( ) string { if c . Custom Data ! = nil & & c . Custom Data [ namespace Cluster Key ] ! = " " { return c . Custom Data [ namespace Cluster Key ] } return " " } 
func recreate Containers ( p Docker Provisioner , w io . Writer , nodes . . . cluster . Node ) error { return ensure Containers Started ( p , w , true , nil , nodes . . . ) } 
func check Provisioner ( ) error { if value , _ : = config . Get ( " " ) ; value = = default Provisioner Name | | value = = " " { return check Docker ( ) } return nil } 
func check Docker ( ) error { if _ , err : = config . Get ( " " ) ; err ! = nil { return errors . New ( " " ) } err : = check Docker Basic Config ( ) if err ! = nil { return err } err = check Scheduler ( ) if err ! = nil { return err } err = check Router ( ) if err ! = nil { return err } return check Cluster ( ) } 
func check Scheduler ( ) error { if servers , err : = config . Get ( " " ) ; err = = nil & & servers ! = nil { return errors . Errorf ( `Using docker :servers is deprecated , please remove it your config and use "tsuru docker -node -add " do add docker nodes . ` ) } is Segregate , err : = config . Get Bool ( " " ) if err = = nil { if is Segregate { return config . New Warning ( `Setting "docker :segregate " is not necessary anymore , this is the default behavior from now on . ` ) } else { return errors . Errorf ( `You must remove "docker :segregate " from your config . ` ) } } return nil } 
func check Router ( ) error { default Router , _ : = config . Get String ( " " ) if default Router = = " " { return errors . Errorf ( `You must configure a default router in "docker :router " . ` ) } is Hipache Old : = false if default Router = = " " { hipache Old , _ : = config . Get ( " " ) is Hipache Old = hipache Old ! = nil } router Conf , _ : = config . Get ( " " + default Router ) if is Hipache Old { return config . New Warning ( `Setting "hipache : * " config entries is deprecated . You should configure your router with "routers : * " . See http : } if router Conf = = nil { return errors . Errorf ( `You must configure your default router %q in "routers : %s " . ` , default Router , default Router ) } router Type , _ : = config . Get ( " " + default Router + " " ) if router Type = = nil { return errors . Errorf ( `You must configure your default router type in "routers : %s :type " . ` , default Router ) } return nil } 
func add Plan ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { cpu Share , _ : = strconv . Atoi ( Input Value ( r , " " ) ) is Default , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) memory : = get Size ( Input Value ( r , " " ) ) swap : = get Size ( Input Value ( r , " " ) ) plan : = app Types . Plan { Name : Input Value ( r , " " ) , Memory : memory , Swap : swap , Cpu Share : cpu Share , Default : is Default , } allowed : = permission . Check ( t , permission . Perm Plan Create ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Plan , Value : plan . Name } , Kind : permission . Perm Plan Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Plan Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Plan . Create ( plan ) if err = = app Types . Err Plan Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } if err = = app Types . Err Limit Of Memory | | err = = app Types . Err Limit Of Cpu Share { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } if err = = nil { w . Write Header ( http . Status Created ) } return err } 
func list Plans ( w http . Response Writer , r * http . Request , t auth . Token ) error { plans , err : = servicemanager . Plan . List ( ) if err ! = nil { return err } if len ( plans ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( plans ) } 
func remove Plan ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Plan Delete ) if ! allowed { return permission . Err Unauthorized } plan Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Plan , Value : plan Name } , Kind : permission . Perm Plan Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Plan Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Plan . Remove ( plan Name ) if err = = app Types . Err Plan Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } 
func Get Build Image ( app provision . App ) ( string , error ) { if use Platform Image ( app ) { return get Platform Image ( app ) } app Image Name , err : = App Current Image Name ( app . Get Name ( ) ) if err ! = nil { return get Platform Image ( app ) } return app Image Name , nil } 
func pool List ( w http . Response Writer , r * http . Request , t auth . Token ) error { var teams , pool Names [ ] string is Global : = false contexts : = permission . Contexts For Permission ( t , permission . Perm App Create ) contexts = append ( contexts , permission . Contexts For Permission ( t , permission . Perm Pool Read ) . . . ) for _ , c : = range contexts { if c . Ctx Type = = perm Types . Ctx Global { is Global = true break } if c . Ctx Type = = perm Types . Ctx Team { teams = append ( teams , c . Value ) } if c . Ctx Type = = perm Types . Ctx Pool { pool Names = append ( pool Names , c . Value ) } } var pools [ ] pool . Pool var err error if is Global { pools , err = pool . List All Pools ( ) if err ! = nil { return err } } else { pools , err = pool . List Possible Pools ( teams ) if err ! = nil { return err } if len ( pool Names ) > 0 { named Pools , err : = pool . List Pools ( pool Names . . . ) if err ! = nil { return err } pools = append ( pools , named Pools . . . ) } } pools Map : = make ( map [ string ] struct { } ) var pool List [ ] pool . Pool for _ , p : = range pools { if _ , ok : = pools Map [ p . Name ] ; ok { continue } pool List = append ( pool List , p ) pools Map [ p . Name ] = struct { } { } } if len ( pool List ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( pool List ) } 
func add Pool Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Pool Create ) if ! allowed { return permission . Err Unauthorized } var add Opts pool . Add Pool Options err = Parse Input ( r , & add Opts ) if err ! = nil { return err } if add Opts . Name = = " " { return & terrors . HTTP { Code : http . Status Bad Request , Message : pool . Err Pool Name Is Required . Error ( ) , } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : add Opts . Name } , Kind : permission . Perm Pool Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , add Opts . Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = pool . Add Pool ( add Opts ) if err = = pool . Err Default Pool Already Exists | | err = = pool . Err Pool Already Exists { return & terrors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } if err = = pool . Err Pool Name Is Required { return & terrors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } if err = = nil { w . Write Header ( http . Status Created ) } return err } 
func remove Pool Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Pool Delete ) if ! allowed { return permission . Err Unauthorized } pool Name : = r . URL . Query ( ) . Get ( " " ) filter : = & app . Filter { } filter . Pool = pool Name apps , err : = app . List ( app Filter By Context ( [ ] perm Types . Permission Context { } , filter ) ) if err ! = nil { return err } if len ( apps ) > 0 { return & terrors . HTTP { Code : http . Status Forbidden , Message : " " } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Name } , Kind : permission . Perm Pool Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , pool Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = pool . Remove Pool ( pool Name ) if err = = pool . Err Pool Not Found { return & terrors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func add Team To Pool Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { pool Name : = r . URL . Query ( ) . Get ( " " ) allowed : = permission . Check ( t , permission . Perm Pool Update Team Add , permission . Context ( perm Types . Ctx Pool , pool Name ) ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Name } , Kind : permission . Perm Pool Update Team Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , pool Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if teams , ok : = Input Values ( r , " " ) ; ok { err : = pool . Add Teams To Pool ( pool Name , teams ) if err = = pool . Err Pool Not Found { return & terrors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } return & terrors . HTTP { Code : http . Status Bad Request , Message : " " } } 
func pool Update Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Pool Update ) if ! allowed { return permission . Err Unauthorized } pool Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Name } , Kind : permission . Perm Pool Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , pool Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) var update Opts pool . Update Pool Options err = Parse Input ( r , & update Opts ) if err ! = nil { return err } err = pool . Pool Update ( pool Name , update Opts ) if err = = pool . Err Pool Not Found { return & terrors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } if err = = pool . Err Default Pool Already Exists { return & terrors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } return err } 
func pool Constraint List ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Pool Read Constraints ) { return permission . Err Unauthorized } constraints , err : = pool . List Pools Constraints ( nil ) if err ! = nil { return err } if len ( constraints ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( constraints ) } 
func pool Constraint Set ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Pool Update Constraints Set ) { return permission . Err Unauthorized } var pool Constraint pool . Pool Constraint err = Parse Input ( r , & pool Constraint ) if err ! = nil { return err } if pool Constraint . Pool Expr = = " " { return & terrors . HTTP { Code : http . Status Bad Request , Message : " " , } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Constraint . Pool Expr } , Kind : permission . Perm Pool Update Constraints Set , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) append : = false if append Str : = Input Value ( r , " " ) ; append Str ! = " " { append , _ = strconv . Parse Bool ( append Str ) } if append { return pool . Append Pool Constraint ( & pool Constraint ) } return pool . Set Pool Constraint ( & pool Constraint ) } 
func ( u * Unit ) Available ( ) bool { return u . Status = = Status Started | | u . Status = = Status Starting | | u . Status = = Status Error } 
func Get ( name string ) ( Provisioner , error ) { p Func , ok : = provisioners [ name ] if ! ok { return nil , errors . Errorf ( " " , name ) } return p Func ( ) } 
func Registry ( ) ( [ ] Provisioner , error ) { registry : = make ( [ ] Provisioner , 0 , len ( provisioners ) ) for _ , p Func : = range provisioners { p , err : = p Func ( ) if err ! = nil { return nil , err } registry = append ( registry , p ) } return registry , nil } 
func ( e * Error ) Error ( ) string { var err string if e . Err ! = nil { err = e . Err . Error ( ) + " " + e . Reason } else { err = e . Reason } return err } 
func create User ( w http . Response Writer , r * http . Request ) error { registration Enabled , _ : = config . Get Bool ( " " ) if ! registration Enabled { token : = r . Header . Get ( " " ) t , err : = app . Auth Scheme . Auth ( token ) if err ! = nil { return create Disabled Err } if ! permission . Check ( t , permission . Perm User Create ) { return create Disabled Err } } email : = Input Value ( r , " " ) password : = Input Value ( r , " " ) evt , err : = event . New ( & event . Opts { Target : user Target ( email ) , Kind : permission . Perm User Create , Raw Owner : event . Owner { Type : event . Owner Type User , Name : email } , Custom Data : event . Form To Custom Data ( Input Fields ( r , " " ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u : = auth . User { Email : email , Password : password , } _ , err = app . Auth Scheme . Create ( & u ) if err ! = nil { return handle Auth Error ( err ) } w . Write Header ( http . Status Created ) return nil } 
func login ( w http . Response Writer , r * http . Request ) ( err error ) { params : = map [ string ] string { " " : r . URL . Query ( ) . Get ( " " ) , } fields : = Input Fields ( r ) for key , values : = range fields { params [ key ] = values [ 0 ] } token , err : = app . Auth Scheme . Login ( params ) if err ! = nil { return handle Auth Error ( err ) } return json . New Encoder ( w ) . Encode ( map [ string ] string { " " : token . Get Value ( ) } ) } 
func logout ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { return app . Auth Scheme . Logout ( t . Get Value ( ) ) } 
func change Password ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { managed , ok : = app . Auth Scheme . ( auth . Managed Scheme ) if ! ok { return & errors . HTTP { Code : http . Status Bad Request , Message : non Managed Scheme Msg } } evt , err : = event . New ( & event . Opts { Target : user Target ( t . Get User Name ( ) ) , Kind : permission . Perm User Update Password , Owner : t , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , t . Get User Name ( ) ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) old Password : = Input Value ( r , " " ) new Password : = Input Value ( r , " " ) confirm Password : = Input Value ( r , " " ) if old Password = = " " | | new Password = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } if new Password ! = confirm Password { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } err = managed . Change Password ( t , old Password , new Password ) if err ! = nil { return handle Auth Error ( err ) } return nil } 
func reset Password ( w http . Response Writer , r * http . Request ) ( err error ) { managed , ok : = app . Auth Scheme . ( auth . Managed Scheme ) if ! ok { return & errors . HTTP { Code : http . Status Bad Request , Message : non Managed Scheme Msg } } email : = r . URL . Query ( ) . Get ( " " ) token : = Input Value ( r , " " ) evt , err : = event . New ( & event . Opts { Target : user Target ( email ) , Kind : permission . Perm User Update Reset , Raw Owner : event . Owner { Type : event . Owner Type User , Name : email } , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u , err : = auth . Get User By Email ( email ) if err ! = nil { if err = = auth Types . Err User Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } if token = = " " { return managed . Start Password Reset ( u ) } return managed . Reset Password ( u , token ) } 
func update Team ( w http . Response Writer , r * http . Request , t auth . Token ) error { name : = r . URL . Query ( ) . Get ( " " ) type team Change struct { New Name string Tags [ ] string } change Request : = team Change { } if err : = Parse Input ( r , & change Request ) ; err ! = nil { return err } tags , _ : = Input Values ( r , " " ) change Request . Tags = append ( change Request . Tags , tags . . . ) allowed : = permission . Check ( t , permission . Perm Team Update , permission . Context ( perm Types . Ctx Team , name ) , ) if ! allowed { return permission . Err Unauthorized } _ , err : = servicemanager . Team . Find By Name ( name ) if err ! = nil { if err = = auth Types . Err Team Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } evt , err : = event . New ( & event . Opts { Target : team Target ( name ) , Kind : permission . Perm Team Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if change Request . New Name = = " " { return servicemanager . Team . Update ( name , change Request . Tags ) } u , err : = t . User ( ) if err ! = nil { return err } err = servicemanager . Team . Create ( change Request . New Name , change Request . Tags , u ) if err ! = nil { return err } var to Rollback [ ] func ( old Name , new Name string ) error defer func ( ) { if err = = nil { return } rollback Err : = servicemanager . Team . Remove ( change Request . New Name ) if rollback Err ! = nil { log . Errorf ( " " , name , change Request . New Name ) } for _ , rollback Fn : = range to Rollback { rollback Err : = rollback Fn ( change Request . New Name , name ) if rollback Err ! = nil { fn Name : = runtime . Func For PC ( reflect . Value Of ( rollback Fn ) . Pointer ( ) ) . Name ( ) log . Errorf ( " " , fn Name , name , change Request . New Name ) } } } ( ) for _ , fn : = range team Rename Fns { err = fn ( name , change Request . New Name ) if err ! = nil { return err } to Rollback = append ( to Rollback , fn ) } return servicemanager . Team . Remove ( name ) } 
func create Team ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed : = permission . Check ( t , permission . Perm Team Create ) if ! allowed { return permission . Err Unauthorized } var team auth Types . Team if err : = Parse Input ( r , & team ) ; err ! = nil { return err } tags , _ : = Input Values ( r , " " ) team . Tags = append ( team . Tags , tags . . . ) evt , err : = event . New ( & event . Opts { Target : team Target ( team . Name ) , Kind : permission . Perm Team Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , team . Name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u , err : = t . User ( ) if err ! = nil { return err } err = servicemanager . Team . Create ( team . Name , team . Tags , u ) switch err { case auth Types . Err Invalid Team Name : return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } case auth Types . Err Team Already Exists : return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } if err = = nil { w . Write Header ( http . Status Created ) } return err } 
func remove Team ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { name : = r . URL . Query ( ) . Get ( " " ) allowed : = permission . Check ( t , permission . Perm Team Delete , permission . Context ( perm Types . Ctx Team , name ) , ) if ! allowed { return & errors . HTTP { Code : http . Status Not Found , Message : fmt . Sprintf ( `Team " %s " not found . ` , name ) } } evt , err : = event . New ( & event . Opts { Target : team Target ( name ) , Kind : permission . Perm Team Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Team Read Events , permission . Context ( perm Types . Ctx Team , name ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Team . Remove ( name ) if err ! = nil { if _ , ok : = err . ( * auth Types . Err Team Still Used ) ; ok { msg : = fmt . Sprintf ( " \n " , err ) return & errors . HTTP { Code : http . Status Forbidden , Message : msg } } if err = = auth Types . Err Team Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : fmt . Sprintf ( `Team " %s " not found . ` , name ) } } return err } return nil } 
func team List ( w http . Response Writer , r * http . Request , t auth . Token ) error { perms For Team : = permission . Permission Registry . Permissions With Context Type ( perm Types . Ctx Team ) teams , err : = servicemanager . Team . List ( ) if err ! = nil { return err } teams Map : = map [ string ] auth Types . Team { } perms Map : = map [ string ] [ ] string { } perms , err : = t . Permissions ( ) if err ! = nil { return err } for _ , team : = range teams { teams Map [ team . Name ] = team team Ctx : = permission . Context ( perm Types . Ctx Team , team . Name ) var parent * permission . Permission Scheme for _ , p : = range perms For Team { if parent ! = nil & & parent . Is Parent ( p ) { continue } if permission . Check From Perm List ( perms , p , team Ctx ) { parent = p perms Map [ team . Name ] = append ( perms Map [ team . Name ] , p . Full Name ( ) ) } } } if len ( perms Map ) = = 0 { w . Write Header ( http . Status No Content ) return nil } var result [ ] map [ string ] interface { } for name , permissions : = range perms Map { result = append ( result , map [ string ] interface { } { " " : name , " " : teams Map [ name ] . Tags , " " : permissions , } ) } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( result ) } 
func team Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { team Name : = r . URL . Query ( ) . Get ( " " ) team , err : = servicemanager . Team . Find By Name ( team Name ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } can Read : = permission . Check ( t , permission . Perm Team Read ) if ! can Read { return permission . Err Unauthorized } apps , err : = app . List ( & app . Filter { Extra : map [ string ] [ ] string { " " : { team . Name } } , Team Owner : team . Name } ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } pools , err : = pool . List Pools For Team ( team . Name ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } users , err : = auth . List Users ( ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } cached Roles : = make ( map [ string ] permission . Role ) included Users : = make ( [ ] * api User , 0 ) for _ , user : = range users { for _ , role Instance : = range user . Roles { role , ok : = cached Roles [ role Instance . Name ] if ! ok { role Found , err : = permission . Find Role ( role Instance . Name ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } cached Roles [ role Instance . Name ] = role Found role = cached Roles [ role Instance . Name ] } if role . Context Type = = perm Types . Ctx Global | | ( role . Context Type = = perm Types . Ctx Team & & role Instance . Context Value = = team . Name ) { can Include : = permission . Check ( t , permission . Perm Team ) if can Include { role Map : = make ( map [ string ] * permission . Role ) perms , err : = t . Permissions ( ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } user Data , err : = create APIUser ( perms , & user , role Map , can Include ) if err ! = nil { return & errors . HTTP { Code : http . Status Internal Server Error , Message : err . Error ( ) } } included Users = append ( included Users , user Data ) break } } } } result : = map [ string ] interface { } { " " : team . Name , " " : team . Tags , " " : included Users , " " : pools , " " : apps , } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( result ) } 
func add Key To User ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { key : = repository . Key { Body : Input Value ( r , " " ) , Name : Input Value ( r , " " ) , } var force bool if Input Value ( r , " " ) = = " " { force = true } allowed : = permission . Check ( t , permission . Perm User Update Key Add , permission . Context ( perm Types . Ctx User , t . Get User Name ( ) ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : user Target ( t . Get User Name ( ) ) , Kind : permission . Perm User Update Key Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , t . Get User Name ( ) ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if key . Body = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } u , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } err = u . Add Key ( key , force ) if err = = auth Types . Err Key Disabled | | err = = repository . Err User Not Found { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } if err = = repository . Err Key Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } return err } 
func remove Key From User ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { key : = repository . Key { Name : r . URL . Query ( ) . Get ( " " ) , } if key . Name = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } allowed : = permission . Check ( t , permission . Perm User Update Key Remove , permission . Context ( perm Types . Ctx User , t . Get User Name ( ) ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : user Target ( t . Get User Name ( ) ) , Kind : permission . Perm User Update Key Remove , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , t . Get User Name ( ) ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } err = u . Remove Key ( key ) if err = = auth Types . Err Key Disabled { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } if err = = repository . Err Key Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } return err } 
func list Keys ( w http . Response Writer , r * http . Request , t auth . Token ) error { u , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } keys , err : = u . List Keys ( ) if err = = auth Types . Err Key Disabled { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } if err ! = nil { return err } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( keys ) } 
func remove User ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { email : = r . URL . Query ( ) . Get ( " " ) if email = = " " { email = t . Get User Name ( ) } allowed : = permission . Check ( t , permission . Perm User Delete , permission . Context ( perm Types . Ctx User , email ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : user Target ( email ) , Kind : permission . Perm User Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u , err : = auth . Get User By Email ( email ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } app Names , err : = deployable Apps ( u , make ( map [ string ] * permission . Role ) ) if err ! = nil { return err } manager : = repository . Manager ( ) for _ , name : = range app Names { manager . Revoke Access ( name , u . Email ) } if err : = manager . Remove User ( u . Email ) ; err ! = nil { log . Errorf ( " " , err ) } return app . Auth Scheme . Remove ( u ) } 
func auth Scheme ( w http . Response Writer , r * http . Request ) error { info , err : = app . Auth Scheme . Info ( ) if err ! = nil { return err } data : = scheme Data { Name : app . Auth Scheme . Name ( ) , Data : info } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( data ) } 
func regenerate APIToken ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { email : = r . URL . Query ( ) . Get ( " " ) if email = = " " { email = t . Get User Name ( ) } allowed : = permission . Check ( t , permission . Perm User Update Token , permission . Context ( perm Types . Ctx User , email ) , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : user Target ( email ) , Kind : permission . Perm User Update Token , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm User Read Events , permission . Context ( perm Types . Ctx User , email ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) u , err : = auth . Get User By Email ( email ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } api Key , err : = u . Regenerate APIKey ( ) if err ! = nil { return err } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( api Key ) } 
func show APIToken ( w http . Response Writer , r * http . Request , t auth . Token ) error { u , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } email : = r . URL . Query ( ) . Get ( " " ) if email ! = " " { if ! permission . Check ( t , permission . Perm User Update Token ) { return permission . Err Unauthorized } u , err = auth . Get User By Email ( email ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } } api Key , err : = u . Show APIKey ( ) if err ! = nil { return err } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( api Key ) } 
func list Users ( w http . Response Writer , r * http . Request , t auth . Token ) error { user Email : = r . URL . Query ( ) . Get ( " " ) role Name : = r . URL . Query ( ) . Get ( " " ) context Value : = r . URL . Query ( ) . Get ( " " ) users , err : = auth . List Users ( ) if err ! = nil { return err } api Users : = make ( [ ] api User , 0 , len ( users ) ) role Map : = make ( map [ string ] * permission . Role ) include All : = permission . Check ( t , permission . Perm User Update ) perms , err : = t . Permissions ( ) if err ! = nil { return err } for _ , user : = range users { usr Data , err : = create APIUser ( perms , & user , role Map , include All ) if err ! = nil { return err } if usr Data = = nil { continue } if user Email = = " " & & role Name = = " " { api Users = append ( api Users , * usr Data ) } if user Email ! = " " & & usr Data . Email = = user Email { api Users = append ( api Users , * usr Data ) } if role Name ! = " " { for _ , role : = range usr Data . Roles { if role . Name = = role Name { if context Value ! = " " & & role . Context Value = = context Value { api Users = append ( api Users , * usr Data ) break } if context Value = = " " { api Users = append ( api Users , * usr Data ) break } } } } } if len ( api Users ) = = 0 { if context Value ! = " " { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } user , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } perm , err : = user . Permissions ( ) if err ! = nil { return err } user Data , err : = create APIUser ( perm , user , nil , true ) if err ! = nil { return err } api Users = append ( api Users , * user Data ) } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( api Users ) } 
func user Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { user , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } perms , err : = t . Permissions ( ) if err ! = nil { return err } user Data , err : = create APIUser ( perms , user , nil , true ) if err ! = nil { return err } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( user Data ) } 
func platform Add ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { name : = Input Value ( r , " " ) file , _ , err : = r . Form File ( " " ) if err ! = nil { return & t Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } defer file . Close ( ) data , err : = ioutil . Read All ( file ) if err ! = nil { return err } if len ( data ) = = 0 { return & t Errors . HTTP { Code : http . Status Bad Request , Message : app Types . Err Missing File Content . Error ( ) } } args : = make ( map [ string ] string ) for key , values : = range r . Form { args [ key ] = values [ 0 ] } can Create Platform : = permission . Check ( t , permission . Perm Platform Create ) if ! can Create Platform { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Platform , Value : name } , Kind : permission . Perm Platform Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Platform Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) evt . Set Log Writer ( writer ) ctx , cancel : = evt . Cancelable Context ( context . Background ( ) ) err = servicemanager . Platform . Create ( app Types . Platform Options { Name : name , Args : args , Data : data , Output : evt , Ctx : ctx , } ) cancel ( ) if err ! = nil { return err } writer . Write ( [ ] byte ( " \n " ) ) return nil } 
func platform Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { name : = r . URL . Query ( ) . Get ( " " ) file , _ , _ : = r . Form File ( " " ) if file ! = nil { defer file . Close ( ) } args : = make ( map [ string ] string ) for key , values : = range r . Form { args [ key ] = values [ 0 ] } can Update Platform : = permission . Check ( t , permission . Perm Platform Update ) if ! can Update Platform { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Platform , Value : name } , Kind : permission . Perm Platform Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Platform Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) evt . Set Log Writer ( writer ) ctx , cancel : = evt . Cancelable Context ( context . Background ( ) ) err = servicemanager . Platform . Update ( app Types . Platform Options { Name : name , Args : args , Input : file , Output : evt , Ctx : ctx , } ) cancel ( ) if err = = app Types . Err Platform Not Found { return & t Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } if err ! = nil { return err } writer . Write ( [ ] byte ( " \n " ) ) return nil } 
func platform Remove ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { can Delete Platform : = permission . Check ( t , permission . Perm Platform Delete ) if ! can Delete Platform { return permission . Err Unauthorized } name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Platform , Value : name } , Kind : permission . Perm Platform Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Platform Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Platform . Remove ( name ) if err = = app Types . Err Platform Not Found { return & t Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func platform List ( w http . Response Writer , r * http . Request , t auth . Token ) error { can Use Plat : = permission . Check ( t , permission . Perm Platform Update ) | | permission . Check ( t , permission . Perm Platform Create ) platforms , err : = servicemanager . Platform . List ( ! can Use Plat ) if err ! = nil { return err } if len ( platforms ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( platforms ) } 
func platform Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { name : = r . URL . Query ( ) . Get ( " " ) can Use Plat : = permission . Check ( t , permission . Perm Platform Update ) | | permission . Check ( t , permission . Perm Platform Create ) if ! can Use Plat { return permission . Err Unauthorized } platform , err : = servicemanager . Platform . Find By Name ( name ) if err = = app Types . Err Platform Not Found { return & t Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } if err ! = nil { return err } images , err : = servicemanager . Platform Image . List Images Or Default ( name ) if err ! = nil { return err } msg : = map [ string ] interface { } { " " : platform , " " : images , } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( msg ) } 
func platform Rollback ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { name : = r . URL . Query ( ) . Get ( " " ) image : = Input Value ( r , " " ) if image = = " " { return & t Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } can Update Platform : = permission . Check ( t , permission . Perm Platform Update ) if ! can Update Platform { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Platform , Value : name } , Kind : permission . Perm Platform Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Platform Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) evt . Set Log Writer ( writer ) ctx , cancel : = evt . Cancelable Context ( context . Background ( ) ) err = servicemanager . Platform . Rollback ( app Types . Platform Options { Name : name , Image Name : image , Output : evt , Ctx : ctx , } ) cancel ( ) if err = = app Types . Err Platform Not Found { return & t Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } if err ! = nil { return err } writer . Write ( [ ] byte ( " \n " ) ) return nil } 
func move Container Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { params : = map [ string ] string { } err = api . Parse Input ( r , & params ) if err ! = nil { return err } cont Id : = r . URL . Query ( ) . Get ( " " ) to : = params [ " " ] if to = = " " { return & tsuru Errors . Validation Error { Message : fmt . Sprintf ( " " , cont Id , to ) } } cont , err : = main Docker Provisioner . Get Container ( cont Id ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } perm Contexts , err : = move Containers Permission Contexts ( cont . Host Addr , to ) if err ! = nil { return err } if ! permission . Check ( t , permission . Perm Node Update Move Container , perm Contexts . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Container , Value : cont Id } , Kind : permission . Perm Node Update Move Container , Owner : t , Custom Data : event . Form To Custom Data ( r . Form ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , perm Contexts . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) _ , err = main Docker Provisioner . move Container ( cont Id , to , evt ) if err ! = nil { return errors . Wrap ( err , " " ) } fmt . Fprintf ( writer , " \n " ) return nil } 
func move Containers Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { params : = map [ string ] string { } err = api . Parse Input ( r , & params ) if err ! = nil { return err } from : = params [ " " ] to : = params [ " " ] if from = = " " | | to = = " " { return & tsuru Errors . Validation Error { Message : fmt . Sprintf ( " " , from , to ) } } perm Contexts , err : = move Containers Permission Contexts ( from , to ) if err ! = nil { return err } if ! permission . Check ( t , permission . Perm Node Update Move Containers , perm Contexts . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node , Value : from } , Kind : permission . Perm Node Update Move Containers , Owner : t , Custom Data : event . Form To Custom Data ( r . Form ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , perm Contexts . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) err = main Docker Provisioner . Move Containers ( from , to , evt ) if err ! = nil { return errors . Wrap ( err , " " ) } fmt . Fprintf ( evt , " \n " ) return nil } 
func logs Config Get Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { pools , err : = permission . List Context Values ( t , permission . Perm Pool Update Logs , true ) if err ! = nil { return err } config Entries , err : = container . Log Load All ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) if len ( pools ) = = 0 { return json . New Encoder ( w ) . Encode ( config Entries ) } new Map : = map [ string ] container . Docker Log Config { } for _ , p : = range pools { if entry , ok : = config Entries [ p ] ; ok { new Map [ p ] = entry } } return json . New Encoder ( w ) . Encode ( new Map ) } 
func logs Config Set Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { pool : = api . Input Value ( r , " " ) restart , _ : = strconv . Parse Bool ( api . Input Value ( r , " " ) ) var conf container . Docker Log Config err = api . Parse Input ( r , & conf ) if err ! = nil { return err } var ctxs [ ] perm Types . Permission Context if pool ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , pool ) ) } has Permission : = permission . Check ( t , permission . Perm Pool Update Logs , ctxs . . . ) if ! has Permission { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool } , Kind : permission . Perm Pool Update Logs , Owner : t , Custom Data : event . Form To Custom Data ( r . Form ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = conf . Save ( pool ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) fmt . Fprintln ( evt , " " ) if restart { filter : = & app . Filter { } if pool ! = " " { filter . Pools = [ ] string { pool } } return try Restart Apps By Filter ( filter , evt ) } return nil } 
func validate Version ( supported , current string ) bool { if supported = = " " { return true } v Supported , err : = go Version . New Version ( supported ) if err ! = nil { return false } v Current , err : = go Version . New Version ( current ) if err ! = nil { return false } return v Current . Compare ( v Supported ) > = 0 } 
func Read Target ( ) ( string , error ) { if target : = os . Getenv ( " " ) ; target ! = " " { targets , err : = get Targets ( ) if err = = nil { if val , ok : = targets [ target ] ; ok { return val , nil } } return target , nil } target Path : = Join With User Dir ( " " , " " ) target , err : = read Target ( target Path ) if err = = err Undefined Target { copy Target Files ( ) target , err = read Target ( Join With User Dir ( " " ) ) } return target , err } 
func Write Target ( t string ) error { target Path : = Join With User Dir ( " " , " " ) target File , err : = filesystem ( ) . Open File ( target Path , syscall . O _WRONLY | syscall . O _CREAT | syscall . O _TRUNC , 0 6 0 0 ) if err ! = nil { return err } defer target File . Close ( ) n , err : = target File . Write String ( t ) if n ! = len ( t ) | | err ! = nil { return errors . New ( " " ) } return nil } 
func Write On Target List ( label , target string ) error { label = strings . Trim Space ( label ) target = strings . Trim Space ( target ) target Exist , err : = Check If Target Label Exists ( label ) if err ! = nil { return err } if target Exist { return errors . New ( " " ) } targets Path : = Join With User Dir ( " " , " " ) targets File , err : = filesystem ( ) . Open File ( targets Path , syscall . O _RDWR | syscall . O _CREAT | syscall . O _APPEND , 0 6 0 0 ) if err ! = nil { return err } defer targets File . Close ( ) content : = label + " \t " + target + " \n " n , err : = targets File . Write String ( content ) if n ! = len ( content ) | | err ! = nil { return errors . New ( " " ) } return nil } 
func ( s * SAMLAuth Scheme ) load Config ( ) ( Base Config , error ) { if s . Base Config . Entity ID ! = " " { return s . Base Config , nil } if s . Parser = = nil { s . Parser = s } var empty Config Base Config public Cert , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } private Key , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } idp URL , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } display Name , err : = config . Get String ( " " ) if err ! = nil { display Name = " " log . Debugf ( " " , err ) } description , err : = config . Get String ( " " ) if err ! = nil { description = " " log . Debugf ( " " , err ) } idp Public Cert , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } entity Id , err : = config . Get String ( " " ) if err ! = nil { return empty Config , err } sign Request , err : = config . Get Bool ( " " ) if err ! = nil { return empty Config , err } signed Response , err : = config . Get Bool ( " " ) if err ! = nil { return empty Config , err } deflat Encoded Response , err : = config . Get Bool ( " " ) if err ! = nil { deflat Encoded Response = false log . Debugf ( " " , err ) } s . Base Config = Base Config { Entity ID : entity Id , Display Name : display Name , Description : description , Public Cert : public Cert , Private Key : private Key , Idp URL : idp URL , Idp Public Cert : idp Public Cert , Sign Request : sign Request , Signed Response : signed Response , Deflat Encoded Response : deflat Encoded Response , } return s . Base Config , nil } 
func build ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { tag : = Input Value ( r , " " ) if tag = = " " { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } opts , err : = prepare To Build ( r ) if err ! = nil { return err } if opts . File ! = nil { defer opts . File . Close ( ) } w . Header ( ) . Set ( " " , " " ) app Name : = r . URL . Query ( ) . Get ( " " ) var user Name string if t . Is App Token ( ) { if t . Get App Name ( ) ! = app Name & & t . Get App Name ( ) ! = app . Internal App Name { return & tsuru Errors . HTTP { Code : http . Status Unauthorized , Message : " " } } user Name = Input Value ( r , " " ) } else { user Name = t . Get User Name ( ) } instance , err : = app . Get By Name ( app Name ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } opts . App = instance opts . Build Tag = tag opts . User = user Name opts . Get Kind ( ) if t . Get App Name ( ) ! = app . Internal App Name { can Build : = permission . Check ( t , permission . Perm App Build , contexts For App ( instance ) . . . ) if ! can Build { return & tsuru Errors . HTTP { Code : http . Status Forbidden , Message : " " } } } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Build , Raw Owner : event . Owner { Type : event . Owner Type User , Name : user Name } , Custom Data : opts , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( instance ) . . . ) , Allowed Cancel : event . Allowed ( permission . Perm App Update Events , contexts For App ( instance ) . . . ) , Cancelable : true , } ) if err ! = nil { return err } var image ID string defer func ( ) { evt . Done Custom Data ( err , map [ string ] string { " " : image ID } ) } ( ) opts . Event = evt writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer writer . Stop ( ) opts . Output Stream = writer image ID , err = app . Build ( opts ) if err = = nil { fmt . Fprintln ( w , image ID ) fmt . Fprintln ( w , " " ) } return err } 
func Build Health Check ( router Name string ) func ( ) error { return func ( ) error { router Config , err : = config . Get ( " " ) if err ! = nil { return hc . Err Disabled Component } routers , _ : = router Config . ( map [ interface { } ] interface { } ) check Count : = 0 for iface Name : = range routers { name : = iface Name . ( string ) if name ! = router Name { named Router : = routers [ name ] . ( map [ interface { } ] interface { } ) if tp , _ : = named Router [ " " ] . ( string ) ; tp ! = router Name { continue } } check Count + + err : = health Check ( name ) if err ! = nil { return err } } if check Count = = 0 { return hc . Err Disabled Component } return nil } } 
func Conn ( ) ( * Storage , error ) { var ( strg Storage err error ) url , dbname : = Db Config ( " " ) strg . Storage , err = storage . Open ( url , dbname ) return & strg , err } 
func ( s * Storage ) Apps ( ) * storage . Collection { name Index : = mgo . Index { Key : [ ] string { " " } , Unique : true } c : = s . Collection ( " " ) c . Ensure Index ( name Index ) return c } 
func ( s * Storage ) Pools Constraints ( ) * storage . Collection { pool Constraint Index : = mgo . Index { Key : [ ] string { " " , " " } , Unique : true } c : = s . Collection ( " " ) c . Ensure Index ( pool Constraint Index ) return c } 
func ( s * Storage ) Users ( ) * storage . Collection { email Index : = mgo . Index { Key : [ ] string { " " } , Unique : true } c : = s . Collection ( " " ) c . Ensure Index ( email Index ) return c } 
func ( s * Storage ) SAMLRequests ( ) * storage . Collection { id : = mgo . Index { Key : [ ] string { " " } } coll : = s . Collection ( " " ) coll . Ensure Index ( id ) return coll } 
func ( s * Log Storage ) App Log Collection ( app Name string ) * storage . Collection { if app Name = = " " { return nil } return s . Collection ( " " + app Name ) } 
func ( s * Log Storage ) Create App Log Collection ( app Name string ) ( * storage . Collection , error ) { c : = s . App Log Collection ( app Name ) err : = c . Create ( & log Capped Info ) return c , err } 
func ( s * Log Storage ) Logs Collections ( ) ( [ ] * storage . Collection , error ) { var names [ ] struct { Name string } conn , err : = Conn ( ) if err ! = nil { return nil , err } defer conn . Close ( ) err = conn . Apps ( ) . Find ( nil ) . All ( & names ) if err ! = nil { return nil , err } var colls [ ] * storage . Collection for _ , name : = range names { colls = append ( colls , s . Collection ( " " + name . Name ) ) } return colls , nil } 
func Archive Build Cmds ( app provision . App , archive URL string ) [ ] string { return build Cmds ( app , " " , " " , archive URL ) } 
func Archive Deploy Cmds ( app provision . App , archive URL string ) [ ] string { return build Cmds ( app , " " , " " , archive URL ) } 
func Deploy Cmds ( app provision . App ) [ ] string { ua Cmds : = unit Agent Cmds ( app ) ua Cmds = append ( ua Cmds , " " ) final Cmd : = strings . Join ( ua Cmds , " " ) return [ ] string { " " , " " , final Cmd } } 
func run With Agent Cmds ( app provision . App ) ( [ ] string , error ) { run Cmd , err : = config . Get String ( " " ) if err ! = nil { run Cmd = " " } host , _ : = config . Get String ( " " ) token : = app . Envs ( ) [ " " ] . Value return [ ] string { " " , host , token , app . Get Name ( ) , run Cmd } , nil } 
func new Apps ( c * Tsuru V 1Client , namespace string ) * apps { return & apps { client : c . RESTClient ( ) , ns : namespace , } } 
func ( c * apps ) Get ( name string , options meta _v 1 . Get Options ) ( result * v 1 . App , err error ) { result = & v 1 . App { } err = c . client . Get ( ) . Namespace ( c . ns ) . Resource ( " " ) . Name ( name ) . Versioned Params ( & options , scheme . Parameter Codec ) . Do ( ) . Into ( result ) return } 
func ( c * apps ) List ( opts meta _v 1 . List Options ) ( result * v 1 . App List , err error ) { result = & v 1 . App List { } err = c . client . Get ( ) . Namespace ( c . ns ) . Resource ( " " ) . Versioned Params ( & opts , scheme . Parameter Codec ) . Do ( ) . Into ( result ) return } 
func ( c * apps ) Create ( app * v 1 . App ) ( result * v 1 . App , err error ) { result = & v 1 . App { } err = c . client . Post ( ) . Namespace ( c . ns ) . Resource ( " " ) . Body ( app ) . Do ( ) . Into ( result ) return } 
func ( c * apps ) Update ( app * v 1 . App ) ( result * v 1 . App , err error ) { result = & v 1 . App { } err = c . client . Put ( ) . Namespace ( c . ns ) . Resource ( " " ) . Name ( app . Name ) . Body ( app ) . Do ( ) . Into ( result ) return } 
func ( c * apps ) Delete ( name string , options * meta _v 1 . Delete Options ) error { return c . client . Delete ( ) . Namespace ( c . ns ) . Resource ( " " ) . Name ( name ) . Body ( options ) . Do ( ) . Error ( ) } 
func ( c * Container ) Commit ( client provision . Builder Docker Client , limiter provision . Action Limiter , writer io . Writer , is Deploy bool ) ( string , error ) { log . Debugf ( " " , c . ID ) repository , tag : = image . Split Image Name ( c . Building Image ) opts : = docker . Commit Container Options { Container : c . ID , Repository : repository , Tag : tag } done : = limiter . Start ( c . Host Addr ) image , err : = client . Commit Container ( opts ) done ( ) if err ! = nil { return " " , log . Wrap Error ( errors . Wrapf ( err , " " , c . ID ) ) } tags : = [ ] string { tag } if is Deploy & & tag ! = " " { tags = append ( tags , " " ) err = client . Tag Image ( fmt . Sprintf ( " " , repository , tag ) , docker . Tag Image Options { Repo : repository , Tag : " " , Force : true , } ) if err ! = nil { return " " , log . Wrap Error ( errors . Wrapf ( err , " " , c . ID ) ) } } img History , err : = client . Image History ( c . Building Image ) img Size : = " " if err = = nil & & len ( img History ) > 0 { full Size : = img History [ 0 ] . Size if len ( img History ) > 1 & & strings . Contains ( img History [ 1 ] . Created By , " " ) { full Size + = img History [ 1 ] . Size } img Size = fmt . Sprintf ( " " , float 6 4 ( full Size ) / 1 0 2 4 / 1 0 2 4 ) } fmt . Fprintf ( writer , " \n " , img Size ) log . Debugf ( " " , image . ID , c . ID ) for _ , tag : = range tags { max Try , _ : = config . Get Int ( " " ) if max Try < = 0 { max Try = 3 } for i : = 0 ; i < max Try ; i + + { err = dockercommon . Push Image ( client , repository , tag , dockercommon . Registry Auth Config ( repository ) ) if err ! = nil { fmt . Fprintf ( writer , " \n " , err . Error ( ) ) log . Errorf ( " " , c . Building Image , err ) time . Sleep ( time . Second ) continue } break } if err ! = nil { return " " , log . Wrap Error ( errors . Wrapf ( err , " " , c . Building Image ) ) } } return c . Building Image , nil } 
func Parse Token ( header string ) ( string , error ) { s : = strings . Split ( header , " " ) var value string if len ( s ) < 3 { value = s [ len ( s ) - 1 ] } if value ! = " " { return value , nil } return value , Err Invalid Token } 
func process Tags ( tags [ ] string ) [ ] string { if tags = = nil { return nil } processed Tags : = [ ] string { } used Tags : = make ( map [ string ] bool ) for _ , tag : = range tags { tag = strings . Trim Space ( tag ) if len ( tag ) > 0 & & ! used Tags [ tag ] { processed Tags = append ( processed Tags , tag ) used Tags [ tag ] = true } } return processed Tags } 
func ( s * segregated Scheduler ) aggregate Containers By ( matcher bson . M ) ( map [ string ] int , error ) { coll : = s . provisioner . Collection ( ) defer coll . Close ( ) pipe : = coll . Pipe ( [ ] bson . M { matcher , { " " : bson . M { " " : " " , " " : bson . M { " " : 1 } } } , } ) var results [ ] node Aggregate err : = pipe . All ( & results ) if err ! = nil { return nil , err } count Map : = make ( map [ string ] int ) for _ , result : = range results { count Map [ result . Host Addr ] = result . Count } return count Map , nil } 
func ( s * segregated Scheduler ) choose Node To Add ( nodes [ ] cluster . Node , cont Name string , app Name , process string ) ( string , error ) { log . Debugf ( " " , cont Name , nodes ) s . host Mutex . Lock ( ) defer s . host Mutex . Unlock ( ) chosen Node , _ , err : = s . min Max Nodes ( nodes , app Name , process ) if err ! = nil { return " " , err } log . Debugf ( " " , cont Name , chosen Node ) if cont Name ! = " " { coll : = s . provisioner . Collection ( ) defer coll . Close ( ) err = coll . Update ( bson . M { " " : cont Name } , bson . M { " " : bson . M { " " : net . URLTo Host ( chosen Node ) } } ) } return chosen Node , err } 
func ( s * segregated Scheduler ) choose Container To Remove ( nodes [ ] cluster . Node , app Name , process string ) ( string , error ) { _ , chosen Node , err : = s . min Max Nodes ( nodes , app Name , process ) if err ! = nil { return " " , err } log . Debugf ( " " , chosen Node ) container ID , err : = s . get Container Preferably From Host ( chosen Node , app Name , process ) if err ! = nil { return " " , err } return container ID , err } 
func ( s * segregated Scheduler ) min Max Nodes ( nodes [ ] cluster . Node , app Name , process string ) ( string , string , error ) { nodes List : = make ( node . Node List , len ( nodes ) ) for i : = range nodes { nodes List [ i ] = & cluster Node Wrapper { Node : & nodes [ i ] , prov : s . provisioner } } meta Freq List , _ , err : = nodes List . Split Metadata ( ) if err ! = nil { log . Debugf ( " " , err ) } host Group Map : = map [ string ] int { } for i , m : = range meta Freq List { for _ , n : = range m . Nodes { host Group Map [ net . URLTo Host ( n . Address ( ) ) ] = i } } hosts , hosts Map : = s . nodes To Hosts ( nodes ) host Count Map , err : = s . aggregate Containers By Host ( hosts ) if err ! = nil { return " " , " " , err } app Count Map , err : = s . aggregate Containers By Host App Process ( hosts , app Name , process ) if err ! = nil { return " " , " " , err } priority Entries : = [ ] map [ string ] int { app Group Count ( host Group Map , app Count Map ) , app Count Map , host Count Map } var min Host , max Host string var min Score uint 6 4 = math . Max Uint 6 4 var max Score uint 6 4 = 0 for _ , host : = range hosts { var score uint 6 4 for i , e : = range priority Entries { score + = uint 6 4 ( e [ host ] ) < < uint ( ( len ( priority Entries ) - i - 1 ) * ( 6 4 / len ( priority Entries ) ) ) } if score < min Score { min Score = score min Host = host } if score > = max Score { max Score = score max Host = host } } return hosts Map [ min Host ] , hosts Map [ max Host ] , nil } 
func list Routers ( w http . Response Writer , r * http . Request , t auth . Token ) error { contexts : = permission . Contexts For Permission ( t , permission . Perm App Create ) var teams [ ] string var global bool contexts : for _ , c : = range contexts { switch c . Ctx Type { case perm Types . Ctx Global : global = true break contexts case perm Types . Ctx Team : teams = append ( teams , c . Value ) } } routers , err : = router . List With Info ( ) if err ! = nil { return err } filtered Routers : = routers if ! global { routers Allowed : = make ( map [ string ] struct { } ) filtered Routers = [ ] router . Plan Router { } pools , err : = pool . List Possible Pools ( teams ) if err ! = nil { return err } for _ , p : = range pools { rs , err : = p . Get Routers ( ) if err ! = nil { return err } for _ , r : = range rs { routers Allowed [ r ] = struct { } { } } } for _ , r : = range routers { if _ , ok : = routers Allowed [ r . Name ] ; ok { filtered Routers = append ( filtered Routers , r ) } } } if len ( filtered Routers ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( filtered Routers ) } 
func add App Router ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var app Router app Types . App Router err = Parse Input ( r , & app Router ) if err ! = nil { return err } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } _ , err = router . Get ( app Router . Name ) if err ! = nil { if _ , is Not Found : = err . ( * router . Err Router Not Found ) ; is Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } allowed : = permission . Check ( t , permission . Perm App Update Router Add , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } p , err : = pool . Get Pool By Name ( a . Pool ) if err ! = nil { return err } err = p . Validate Routers ( [ ] app Types . App Router { app Router } ) if err ! = nil { if err = = pool . Err Pool Has No Router { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Router Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return a . Add Router ( app Router ) } 
func remove App Router ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app Name : = r . URL . Query ( ) . Get ( " " ) router Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Router Remove , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Router Remove , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = a . Remove Router ( router Name ) if _ , is Not Found : = err . ( * router . Err Router Not Found ) ; is Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func list App Routers ( w http . Response Writer , r * http . Request , t auth . Token ) error { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } can Read : = permission . Check ( t , permission . Perm App Read Router , contexts For App ( & a ) . . . , ) if ! can Read { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) routers , err : = a . Get Routers With Addr ( ) if err ! = nil { return err } if len ( routers ) = = 0 { w . Write Header ( http . Status No Content ) return nil } return json . New Encoder ( w ) . Encode ( routers ) } 
func Get ( name string ) ( Router , error ) { router Type , prefix , err : = Type ( name ) if err ! = nil { return nil , & Err Router Not Found { Name : name } } factory , ok : = routers [ router Type ] if ! ok { return nil , errors . Errorf ( " " , router Type ) } r , err : = factory ( name , prefix ) if err ! = nil { return nil , err } return r , nil } 
func Default ( ) ( string , error ) { plans , err : = List ( ) if err ! = nil { return " " , err } if len ( plans ) = = 0 { return " " , Err Default Router Not Found } if len ( plans ) = = 1 { return plans [ 0 ] . Name , nil } for _ , p : = range plans { if p . Default { return p . Name , nil } } return " " , Err Default Router Not Found } 
func Store ( app Name , router Name , kind string ) error { coll , err : = collection ( ) if err ! = nil { return err } defer coll . Close ( ) data : = router App Entry { App : app Name , Router : router Name , Kind : kind , } _ , err = coll . Upsert ( bson . M { " " : app Name } , data ) return err } 
func service List ( w http . Response Writer , r * http . Request , t auth . Token ) error { contexts : = permission . Contexts For Permission ( t , permission . Perm Service Read ) services , err : = provision Readable Services ( t , contexts ) if err ! = nil { return err } s Instances , err : = service . Get Service Instances By Services ( services ) if err ! = nil { return err } results : = make ( [ ] service . Service Model , len ( services ) ) for i , s : = range services { results [ i ] . Service = s . Name for _ , si : = range s Instances { if si . Service Name = = s . Name { results [ i ] . Instances = append ( results [ i ] . Instances , si . Name ) results [ i ] . Service Instances = append ( results [ i ] . Service Instances , si ) } } } if len ( results ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( results ) } 
func service Create ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { s : = service . Service { Name : Input Value ( r , " " ) , Username : Input Value ( r , " " ) , Endpoint : map [ string ] string { " " : Input Value ( r , " " ) } , Password : Input Value ( r , " " ) , } team : = Input Value ( r , " " ) if team = = " " { team , err = permission . Team For Permission ( t , permission . Perm Service Create ) if err = = permission . Err Too Many Teams { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } if err ! = nil { return err } } s . Owner Teams = [ ] string { team } allowed : = permission . Check ( t , permission . Perm Service Create , permission . Context ( perm Types . Ctx Team , s . Owner Teams [ 0 ] ) , ) if ! allowed { return permission . Err Unauthorized } delete ( r . Form , " " ) evt , err : = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = service . Create ( s ) if err ! = nil { if err = = service . Err Service Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } return err } w . Write Header ( http . Status Created ) fmt . Fprint ( w , " " ) return nil } 
func service Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { d : = service . Service { Username : Input Value ( r , " " ) , Endpoint : map [ string ] string { " " : Input Value ( r , " " ) } , Password : Input Value ( r , " " ) , Name : r . URL . Query ( ) . Get ( " " ) , } team : = Input Value ( r , " " ) s , err : = get Service ( d . Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Update , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } delete ( r . Form , " " ) evt , err : = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) s . Endpoint = d . Endpoint s . Password = d . Password s . Username = d . Username if team ! = " " { s . Owner Teams = [ ] string { team } } return service . Update ( s ) } 
func service Delete ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { s , err : = get Service ( r . URL . Query ( ) . Get ( " " ) ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Delete , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) instances , err : = service . Get Service Instances By Services ( [ ] service . Service { s } ) if err ! = nil { return err } if len ( instances ) > 0 { msg : = " \n " msg + = " " return & errors . HTTP { Code : http . Status Forbidden , Message : msg } } return service . Delete ( s ) } 
func service Proxy ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) s , err : = get Service ( service Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Update Proxy , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } var evt * event . Event if r . Method ! = http . Method Get & & r . Method ! = http . Method Head { evt , err = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Update Proxy , Owner : t , Custom Data : append ( event . Form To Custom Data ( Input Fields ( r ) ) , map [ string ] interface { } { " " : " " , " " : r . Method , } ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) } path : = r . URL . Query ( ) . Get ( " " ) return service . Proxy ( & s , path , evt , request IDHeader ( r ) , w , r ) } 
func grant Service Access ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) s , err : = get Service ( service Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Update Grant Access , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } team Name : = r . URL . Query ( ) . Get ( " " ) team , err : = servicemanager . Team . Find By Name ( team Name ) if err ! = nil { if err = = auth Types . Err Team Not Found { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } return err } evt , err : = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Update Grant Access , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = s . Grant Access ( team ) if err ! = nil { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } return service . Update ( s ) } 
func service Add Doc ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) s , err : = get Service ( service Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Update Doc , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } s . Doc = Input Value ( r , " " ) evt , err : = event . New ( & event . Opts { Target : service Target ( s . Name ) , Kind : permission . Perm Service Update Doc , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Read Events , contexts For Service Provision ( & s ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return service . Update ( s ) } 
func New Simple Clientset ( objects . . . runtime . Object ) * Clientset { o : = testing . New Object Tracker ( scheme , codecs . Universal Decoder ( ) ) for _ , obj : = range objects { if err : = o . Add ( obj ) ; err ! = nil { panic ( err ) } } fake Ptr : = testing . Fake { } fake Ptr . Add Reactor ( " " , " " , testing . Object Reaction ( o ) ) fake Ptr . Add Watch Reactor ( " " , testing . Default Watch Reactor ( watch . New Fake ( ) , nil ) ) return & Clientset { fake Ptr , & fakediscovery . Fake Discovery { Fake : & fake Ptr } } } 
func ( c * Clientset ) Tsuru V 1 ( ) tsuruv 1 . Tsuru V 1Interface { return & faketsuruv 1 . Fake Tsuru V 1 { Fake : & c . Fake } } 
func ( c * Clientset ) Tsuru ( ) tsuruv 1 . Tsuru V 1Interface { return & faketsuruv 1 . Fake Tsuru V 1 { Fake : & c . Fake } } 
func healthcheck ( w http . Response Writer , r * http . Request ) { var checks [ ] string values : = r . URL . Query ( ) if values ! = nil { checks = values [ " " ] } full Healthcheck ( w , checks ) } 
func New App Informer ( client versioned . Interface , namespace string , resync Period time . Duration , indexers cache . Indexers ) cache . Shared Index Informer { return New Filtered App Informer ( client , namespace , resync Period , indexers , nil ) } 
func New Filtered App Informer ( client versioned . Interface , namespace string , resync Period time . Duration , indexers cache . Indexers , tweak List Options internalinterfaces . Tweak List Options Func ) cache . Shared Index Informer { return cache . New Shared Index Informer ( & cache . List Watch { List Func : func ( options meta _v 1 . List Options ) ( runtime . Object , error ) { if tweak List Options ! = nil { tweak List Options ( & options ) } return client . Tsuru V 1 ( ) . Apps ( namespace ) . List ( options ) } , Watch Func : func ( options meta _v 1 . List Options ) ( watch . Interface , error ) { if tweak List Options ! = nil { tweak List Options ( & options ) } return client . Tsuru V 1 ( ) . Apps ( namespace ) . Watch ( options ) } , } , & tsuru _v 1 . App { } , resync Period , indexers , ) } 
func ( c * Fake Apps ) Get ( name string , options v 1 . Get Options ) ( result * tsuru _v 1 . App , err error ) { obj , err : = c . Fake . Invokes ( testing . New Get Action ( apps Resource , c . ns , name ) , & tsuru _v 1 . App { } ) if obj = = nil { return nil , err } return obj . ( * tsuru _v 1 . App ) , err } 
func ( c * Fake Apps ) List ( opts v 1 . List Options ) ( result * tsuru _v 1 . App List , err error ) { obj , err : = c . Fake . Invokes ( testing . New List Action ( apps Resource , apps Kind , c . ns , opts ) , & tsuru _v 1 . App List { } ) if obj = = nil { return nil , err } label , _ , _ : = testing . Extract From List Options ( opts ) if label = = nil { label = labels . Everything ( ) } list : = & tsuru _v 1 . App List { } for _ , item : = range obj . ( * tsuru _v 1 . App List ) . Items { if label . Matches ( labels . Set ( item . Labels ) ) { list . Items = append ( list . Items , item ) } } return list , err } 
func ( c * Fake Apps ) Watch ( opts v 1 . List Options ) ( watch . Interface , error ) { return c . Fake . Invokes Watch ( testing . New Watch Action ( apps Resource , c . ns , opts ) ) } 
func ( c * Fake Apps ) Create ( app * tsuru _v 1 . App ) ( result * tsuru _v 1 . App , err error ) { obj , err : = c . Fake . Invokes ( testing . New Create Action ( apps Resource , c . ns , app ) , & tsuru _v 1 . App { } ) if obj = = nil { return nil , err } return obj . ( * tsuru _v 1 . App ) , err } 
func ( c * Fake Apps ) Update ( app * tsuru _v 1 . App ) ( result * tsuru _v 1 . App , err error ) { obj , err : = c . Fake . Invokes ( testing . New Update Action ( apps Resource , c . ns , app ) , & tsuru _v 1 . App { } ) if obj = = nil { return nil , err } return obj . ( * tsuru _v 1 . App ) , err } 
func ( c * Fake Apps ) Delete ( name string , options * v 1 . Delete Options ) error { _ , err : = c . Fake . Invokes ( testing . New Delete Action ( apps Resource , c . ns , name ) , & tsuru _v 1 . App { } ) return err } 
func ( c * Fake Apps ) Delete Collection ( options * v 1 . Delete Options , list Options v 1 . List Options ) error { action : = testing . New Delete Collection Action ( apps Resource , c . ns , list Options ) _ , err : = c . Fake . Invokes ( action , & tsuru _v 1 . App List { } ) return err } 
func ( c * Fake Apps ) Patch ( name string , pt types . Patch Type , data [ ] byte , subresources . . . string ) ( result * tsuru _v 1 . App , err error ) { obj , err : = c . Fake . Invokes ( testing . New Patch Subresource Action ( apps Resource , c . ns , name , data , subresources . . . ) , & tsuru _v 1 . App { } ) if obj = = nil { return nil , err } return obj . ( * tsuru _v 1 . App ) , err } 
func New Shared Informer Factory ( client versioned . Interface , default Resync time . Duration ) Shared Informer Factory { return New Filtered Shared Informer Factory ( client , default Resync , v 1 . Namespace All , nil ) } 
func New Filtered Shared Informer Factory ( client versioned . Interface , default Resync time . Duration , namespace string , tweak List Options internalinterfaces . Tweak List Options Func ) Shared Informer Factory { return & shared Informer Factory { client : client , namespace : namespace , tweak List Options : tweak List Options , default Resync : default Resync , informers : make ( map [ reflect . Type ] cache . Shared Index Informer ) , started Informers : make ( map [ reflect . Type ] bool ) , } } 
func webhook List ( w http . Response Writer , r * http . Request , t auth . Token ) error { ctxs : = permission . Contexts For Permission ( t , permission . Perm Webhook Read , perm Types . Ctx Team ) var teams [ ] string for _ , c : = range ctxs { if c . Ctx Type = = perm Types . Ctx Global { teams = nil break } teams = append ( teams , c . Value ) } webhooks , err : = servicemanager . Webhook . List ( teams ) if err ! = nil { return err } if len ( webhooks ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( webhooks ) } 
func webhook Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { webhook Name : = r . URL . Query ( ) . Get ( " " ) webhook , err : = servicemanager . Webhook . Find ( webhook Name ) if err ! = nil { if err = = event Types . Err Webhook Not Found { w . Write Header ( http . Status Not Found ) } return err } ctx : = permission . Context ( perm Types . Ctx Team , webhook . Team Owner ) if ! permission . Check ( t , permission . Perm Webhook Read , ctx ) { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( webhook ) } 
func webhook Create ( w http . Response Writer , r * http . Request , t auth . Token ) error { var webhook event Types . Webhook err : = Parse Input ( r , & webhook ) if err ! = nil { return err } if webhook . Team Owner = = " " { webhook . Team Owner , err = auto Team Owner ( t , permission . Perm Webhook Create ) if err ! = nil { return err } } ctx : = permission . Context ( perm Types . Ctx Team , webhook . Team Owner ) if ! permission . Check ( t , permission . Perm Webhook Create , ctx ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Webhook , Value : webhook . Name } , Kind : permission . Perm Webhook Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Webhook Read Events , ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Webhook . Create ( webhook ) if err = = event Types . Err Webhook Already Exists { w . Write Header ( http . Status Conflict ) } return err } 
func webhook Update ( w http . Response Writer , r * http . Request , t auth . Token ) error { var webhook event Types . Webhook err : = Parse Input ( r , & webhook ) if err ! = nil { return err } webhook . Name = r . URL . Query ( ) . Get ( " " ) ctx : = permission . Context ( perm Types . Ctx Team , webhook . Team Owner ) if ! permission . Check ( t , permission . Perm Webhook Update , ctx ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Webhook , Value : webhook . Name } , Kind : permission . Perm Webhook Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Webhook Read Events , ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = servicemanager . Webhook . Update ( webhook ) if err = = event Types . Err Webhook Not Found { w . Write Header ( http . Status Not Found ) } return err } 
func ( b * broker Client ) Proxy ( path string , evt * event . Event , request ID string , w http . Response Writer , r * http . Request ) error { return fmt . Errorf ( " " ) } 
func ( b * broker Client ) Unbind Unit ( instance * Service Instance , app bind . App , unit bind . Unit ) error { return nil } 
func ( s * plan Service ) Create ( plan app Types . Plan ) error { if plan . Name = = " " { return app Types . Plan Validation Error { Field : " " } } if plan . Cpu Share < 2 { return app Types . Err Limit Of Cpu Share } if plan . Memory > 0 & & plan . Memory < 4 1 9 4 3 0 4 { return app Types . Err Limit Of Memory } return s . storage . Insert ( plan ) } 
func ( s * plan Service ) Remove ( plan Name string ) error { return s . storage . Delete ( app Types . Plan { Name : plan Name } ) } 
func ( s * plan Service ) ensure Default ( ) error { plans , err : = s . storage . Find All ( ) if err ! = nil { return err } if len ( plans ) > 0 { return nil } config Memory , _ : = config . Get Int ( " " ) config Swap , _ : = config . Get Int ( " " ) dp : = app Types . Plan { Name : " " , Memory : int 6 4 ( config Memory ) * 1 0 2 4 * 1 0 2 4 , Swap : int 6 4 ( config Swap - config Memory ) * 1 0 2 4 * 1 0 2 4 , Cpu Share : 1 0 0 , Default : true , } return s . storage . Insert ( dp ) } 
func Delete Instance ( si * Service Instance , evt * event . Event , request ID string ) error { if len ( si . Apps ) > 0 { return Err Service Instance Bound } s , err : = Get ( si . Service Name ) if err ! = nil { return err } endpoint , err : = s . get Client ( " " ) if err = = nil { endpoint . Destroy ( si , evt , request ID ) } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) return conn . Service Instances ( ) . Remove ( bson . M { " " : si . Name , " " : si . Service Name } ) } 
func ( si * Service Instance ) To Info ( ) ( Service Instance With Info , error ) { info , err : = si . Info ( " " ) if err ! = nil { info = nil } return Service Instance With Info { Id : si . Id , Name : si . Name , Teams : si . Teams , Plan Name : si . Plan Name , Apps : si . Apps , Service Name : si . Service Name , Info : info , Team Owner : si . Team Owner , } , nil } 
func ( si * Service Instance ) Update ( service Service , update Data Service Instance , evt * event . Event , request ID string ) error { err : = validate Service Instance Team Owner ( update Data ) if err ! = nil { return err } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) tags : = process Tags ( update Data . Tags ) if tags = = nil { update Data . Tags = si . Tags } else { update Data . Tags = tags } actions : = [ ] * action . Action { & update Service Instance , & notify Update Service Instance } pipeline : = action . New Pipeline ( actions . . . ) return pipeline . Execute ( service , * si , update Data , evt , request ID ) } 
func ( si * Service Instance ) Bind App ( app bind . App , params Bind App Parameters , should Restart bool , writer io . Writer , evt * event . Event , request ID string ) error { args : = bind Pipeline Args { service Instance : si , app : app , writer : writer , should Restart : should Restart , params : params , event : evt , request ID : request ID , } actions : = [ ] * action . Action { bind App DBAction , bind App Endpoint Action , set Bound Envs Action , bind Units Action , } pipeline : = action . New Pipeline ( actions . . . ) return pipeline . Execute ( & args ) } 
func ( si * Service Instance ) Bind Unit ( app bind . App , unit bind . Unit ) error { s , err : = Get ( si . Service Name ) if err ! = nil { return err } endpoint , err : = s . get Client ( " " ) if err ! = nil { return err } conn , err : = db . Conn ( ) if err ! = nil { return err } update Op : = bson . M { " " : bson . M { " " : bson . D ( [ ] bson . Doc Elem { { Name : " " , Value : app . Get Name ( ) } , { Name : " " , Value : unit . Get ID ( ) } , { Name : " " , Value : unit . Get Ip ( ) } , } ) , } , } err = conn . Service Instances ( ) . Update ( bson . M { " " : si . Name , " " : si . Service Name , " " : bson . M { " " : unit . Get ID ( ) } } , update Op ) conn . Close ( ) if err ! = nil { if err = = mgo . Err Not Found { return nil } return err } err = endpoint . Bind Unit ( si , app , unit ) if err ! = nil { update Op = bson . M { " " : bson . M { " " : bson . D ( [ ] bson . Doc Elem { { Name : " " , Value : app . Get Name ( ) } , { Name : " " , Value : unit . Get ID ( ) } , { Name : " " , Value : unit . Get Ip ( ) } , } ) , } , } rollback Err : = si . update Data ( update Op ) if rollback Err ! = nil { log . Errorf ( " " , rollback Err ) } return err } return nil } 
func ( si * Service Instance ) Unbind App ( unbind Args Unbind App Args ) error { if si . Find App ( unbind Args . App . Get Name ( ) ) = = - 1 { return Err App Not Bound } args : = bind Pipeline Args { service Instance : si , app : unbind Args . App , writer : unbind Args . Event , should Restart : unbind Args . Restart , event : unbind Args . Event , request ID : unbind Args . Request ID , force Remove : unbind Args . Force Remove , } actions : = [ ] * action . Action { & unbind Units , & unbind App DB , & unbind App Endpoint , & remove Bound Envs , } pipeline : = action . New Pipeline ( actions . . . ) return pipeline . Execute ( & args ) } 
func ( si * Service Instance ) Status ( request ID string ) ( string , error ) { s , err : = Get ( si . Service Name ) if err ! = nil { return " " , err } endpoint , err : = s . get Client ( " " ) if err ! = nil { return " " , err } return endpoint . Status ( si , request ID ) } 
func Proxy Instance ( instance * Service Instance , path string , evt * event . Event , request ID string , w http . Response Writer , r * http . Request ) error { service , err : = Get ( instance . Service Name ) if err ! = nil { return err } endpoint , err : = service . get Client ( " " ) if err ! = nil { return err } prefix : = fmt . Sprintf ( " " , instance . Get Identifier ( ) ) path = strings . Trim ( strings . Trim Prefix ( path + " " , prefix ) , " " ) for _ , reserved : = range reserved Proxy Paths { if path = = reserved & & r . Method ! = " " { return & tsuru Errors . Validation Error { Message : fmt . Sprintf ( " " , r . Method , path ) , } } } return endpoint . Proxy ( fmt . Sprintf ( " " , prefix , path ) , evt , request ID , w , r ) } 
func ( s * Quota Service ) Inc ( app Name string , quantity int ) error { quota , err : = s . Storage . Get ( app Name ) if err ! = nil { return err } err = s . check Limit ( quota , quantity ) if err ! = nil { return err } return s . Storage . Inc ( app Name , quantity ) } 
func ( s * Quota Service ) Set Limit ( app Name string , limit int ) error { q , err : = s . Storage . Get ( app Name ) if err ! = nil { return err } if limit < 0 { limit = - 1 } else if limit < q . In Use { return quota . Err Limit Lower Than Allocated } return s . Storage . Set Limit ( app Name , limit ) } 
func ( s * Quota Service ) Set ( app Name string , in Use int ) error { q , err : = s . Storage . Get ( app Name ) if err ! = nil { return err } if in Use < 0 { return quota . Err Less Than Zero } if ! q . Is Unlimited ( ) & & in Use > q . Limit { return & quota . Quota Exceeded Error { Requested : uint ( in Use ) , Available : uint ( q . Limit ) , } } return s . Storage . Set ( app Name , in Use ) } 
func ( s * Quota Service ) Get ( app Name string ) ( * quota . Quota , error ) { return s . Storage . Get ( app Name ) } 
func install Host Add ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Install Manage ) if ! allowed { return permission . Err Unauthorized } var host * install . Host err = Parse Input ( r , & host ) if err ! = nil { return err } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Install Host , Value : host . Name } , Kind : permission . Perm Install Manage , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Install Manage ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) var raw Driver map [ string ] interface { } err = json . Unmarshal ( [ ] byte ( r . Form . Get ( " " ) ) , & raw Driver ) if err ! = nil { return err } host . Driver = raw Driver err = install . Add Host ( host ) if err ! = nil { return err } w . Write Header ( http . Status Created ) return nil } 
func install Host Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed : = permission . Check ( t , permission . Perm Install Manage ) if ! allowed { return permission . Err Unauthorized } host , err : = install . Get Host By Name ( r . URL . Query ( ) . Get ( " " ) ) if err Nf , ok : = err . ( * install . Err Host Not Found ) ; ok { return & errors . HTTP { Code : http . Status Not Found , Message : fmt . Sprintf ( " " , err Nf . Name ) } } if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( & host ) } 
func install Host List ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed : = permission . Check ( t , permission . Perm Install Manage ) if ! allowed { return permission . Err Unauthorized } hosts , err : = install . List Hosts ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( & hosts ) } 
func Migrate Unique Collection ( ) error { conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) coll : = conn . Collection ( " " ) app Coll : = conn . Apps ( ) var app Names [ ] string err = app Coll . Find ( nil ) . Distinct ( " " , & app Names ) if err ! = nil { return err } _ , err = coll . Remove All ( bson . M { " " : bson . M { " " : app Names } , " " : bson . M { " " : app Names } } ) if err ! = nil { return err } by App Map , err : = all Dup Entries ( coll ) if err ! = nil { return err } var to Remove [ ] bson . Object Id for app Name , app Entries : = range by App Map { to Remove Dups : = check All Dups ( app Entries ) to Remove = append ( to Remove , to Remove Dups . . . ) var to Remove Addrs [ ] bson . Object Id to Remove Addrs , err = check App Addr ( app Coll , app Name , app Entries ) if err ! = nil { return err } to Remove = append ( to Remove , to Remove Addrs . . . ) } _ , err = coll . Remove All ( bson . M { " " : bson . M { " " : to Remove } } ) if err ! = nil { return err } var router App Names [ ] string err = coll . Find ( nil ) . Distinct ( " " , & router App Names ) if err ! = nil { return err } var missing Apps [ ] string err = app Coll . Find ( bson . M { " " : bson . M { " " : router App Names } } ) . Distinct ( " " , & missing Apps ) if err ! = nil { return err } for _ , missing Entry : = range missing Apps { err = coll . Insert ( router App Entry { App : missing Entry , Router : missing Entry , } ) if err ! = nil { return err } } by App Map , err = all Dup Entries ( coll ) if err ! = nil { return err } if len ( by App Map ) = = 0 { _ , err = collection ( ) return err } err Buf : = bytes . New Buffer ( nil ) fmt . Fprintln ( err Buf , `ERROR : The following entries in 'db .routers ' collection have inconsistent duplicated entries that could not be fixed automatically . This could have happened after running app -swap due to a bug in previous tsuru versions . You 'll have to manually check if the apps are swapped or not and remove the duplicated entries accordingly : ` ) for app Name , entries : = range by App Map { fmt . Fprintf ( err Buf , " \n " , app Name ) for _ , e : = range entries { fmt . Fprintf ( err Buf , " \n " , e ) } } return errors . New ( err Buf . String ( ) ) } 
func Remove Image ( image Name string ) error { registry , image , tag : = parse Image ( image Name ) if registry = = " " { registry , _ = config . Get String ( " " ) } if registry = = " " { } if image = = " " { return errors . Errorf ( " " , image Name ) } r : = & docker Registry { server : registry } digest , err : = r . get Digest ( image , tag ) if err ! = nil { return errors . Wrapf ( err , " " , r . server , image , tag ) } err = r . remove Image ( image , digest ) if err ! = nil { return errors . Wrapf ( err , " " , r . server , image , tag , digest ) } return nil } 
func Remove App Images ( app Name string ) error { registry , _ : = config . Get String ( " " ) if registry = = " " { } r : = & docker Registry { server : registry } image : = fmt . Sprintf ( " " , app Name ) tags , err : = r . get Image Tags ( image ) if err ! = nil { return err } multi : = tsuru Errors . New Multi Error ( ) for _ , tag : = range tags { digest , err : = r . get Digest ( image , tag ) if err ! = nil { multi . Add ( errors . Wrapf ( err , " " , r . server , image , tag ) ) continue } err = r . remove Image ( image , digest ) if err ! = nil { multi . Add ( errors . Wrapf ( err , " " , r . server , image , tag , digest ) ) if errors . Cause ( err ) = = Err Delete Disabled { break } } } return multi . To Error ( ) } 
func ( s * platform Service ) Create ( opts app Types . Platform Options ) error { p : = app Types . Platform { Name : opts . Name } if err : = s . validate ( p ) ; err ! = nil { return err } err : = s . storage . Insert ( p ) if err ! = nil { return err } opts . Image Name , err = servicemanager . Platform Image . New Image ( opts . Name ) if err ! = nil { return err } err = builder . Platform Add ( opts ) if err ! = nil { if img Err : = servicemanager . Platform Image . Delete Images ( opts . Name ) ; img Err ! = nil { log . Errorf ( " " , img Err ) } db Err : = s . storage . Delete ( p ) if db Err ! = nil { return tsuru Errors . New Multi Error ( errors . Wrapf ( db Err , " " ) , errors . Wrapf ( err , " " ) , ) } return err } return servicemanager . Platform Image . Append Image ( opts . Name , opts . Image Name ) } 
func ( s * platform Service ) List ( enabled Only bool ) ( [ ] app Types . Platform , error ) { if enabled Only { return s . storage . Find Enabled ( ) } return s . storage . Find All ( ) } 
func ( s * platform Service ) Find By Name ( name string ) ( * app Types . Platform , error ) { p , err : = s . storage . Find By Name ( name ) if err ! = nil { return nil , app Types . Err Invalid Platform } return p , nil } 
func ( s * platform Service ) Update ( opts app Types . Platform Options ) error { if opts . Name = = " " { return app Types . Err Platform Name Missing } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) _ , err = s . Find By Name ( opts . Name ) if err ! = nil { return err } if opts . Input ! = nil { data , err : = ioutil . Read All ( opts . Input ) if err ! = nil { return err } if len ( data ) = = 0 { return app Types . Err Missing File Content } opts . Data = data opts . Image Name , err = servicemanager . Platform Image . New Image ( opts . Name ) if err ! = nil { return err } err = builder . Platform Update ( opts ) if err ! = nil { return err } err = servicemanager . Platform Image . Append Image ( opts . Name , opts . Image Name ) if err ! = nil { return err } var apps [ ] App err = conn . Apps ( ) . Find ( bson . M { " " : opts . Name } ) . All ( & apps ) if err ! = nil { return err } for _ , app : = range apps { app . Set Update Platform ( true ) } } if opts . Args [ " " ] ! = " " { disable Bool , err : = strconv . Parse Bool ( opts . Args [ " " ] ) if err ! = nil { return err } return s . storage . Update ( app Types . Platform { Name : opts . Name , Disabled : disable Bool } ) } return nil } 
func ( s * platform Service ) Remove ( name string ) error { if name = = " " { return app Types . Err Platform Name Missing } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) apps , _ : = conn . Apps ( ) . Find ( bson . M { " " : name } ) . Count ( ) if apps > 0 { return app Types . Err Delete Platform With Apps } err = builder . Platform Remove ( name ) if err ! = nil { log . Errorf ( " " , err ) } images , err : = servicemanager . Platform Image . List Images Or Default ( name ) if err = = nil { for _ , img : = range images { if reg Err : = registry . Remove Image ( img ) ; reg Err ! = nil { log . Errorf ( " " , reg Err ) } } } else { log . Errorf ( " " , err ) } err = servicemanager . Platform Image . Delete Images ( name ) if err ! = nil { log . Errorf ( " " , err ) } return s . storage . Delete ( app Types . Platform { Name : name } ) } 
func ( s * platform Service ) Rollback ( opts app Types . Platform Options ) error { if opts . Name = = " " { return app Types . Err Platform Name Missing } if opts . Image Name = = " " { return app Types . Err Platform Image Missing } _ , err : = s . Find By Name ( opts . Name ) if err ! = nil { return err } image , err : = servicemanager . Platform Image . Find Image ( opts . Name , opts . Image Name ) if err ! = nil { return err } if image = = " " { return fmt . Errorf ( " " , opts . Image Name , opts . Name ) } opts . Data = [ ] byte ( " " + image ) opts . Image Name , err = servicemanager . Platform Image . New Image ( opts . Name ) if err ! = nil { return err } err = builder . Platform Update ( opts ) if err ! = nil { return err } err = servicemanager . Platform Image . Append Image ( opts . Name , opts . Image Name ) if err ! = nil { return err } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) var apps [ ] App err = conn . Apps ( ) . Find ( bson . M { " " : opts . Name } ) . All ( & apps ) if err ! = nil { return err } for _ , app : = range apps { app . Set Update Platform ( true ) } return nil } 
func index ( w http . Response Writer , r * http . Request ) error { host , _ : = config . Get String ( " " ) user Create , _ : = config . Get Bool ( " " ) scheme , _ : = config . Get String ( " " ) repo Manager , _ : = config . Get String ( " " ) data : = map [ string ] interface { } { " " : host , " " : user Create , " " : scheme = = " " | | scheme = = " " , " " : repo Manager = = " " | | repo Manager = = " " , } template , err : = get Template ( ) if err ! = nil { return err } return template . Execute ( w , data ) } 
func Get Pool By Name ( name string ) ( * Pool , error ) { conn , err : = db . Conn ( ) if err ! = nil { return nil , err } defer conn . Close ( ) var p Pool err = conn . Pools ( ) . Find Id ( name ) . One ( & p ) if err ! = nil { if err = = mgo . Err Not Found { return nil , Err Pool Not Found } return nil , err } return & p , nil } 
func remote Shell Handler ( w http . Response Writer , r * http . Request ) { ws , err : = upgrader . Upgrade ( w , r , nil ) if err ! = nil { fmt . Fprintf ( w , " " , err ) return } var http Err * errors . HTTP defer func ( ) { if http Err ! = nil { var msg string switch http Err . Code { case http . Status Unauthorized : msg = " \n " default : msg = http Err . Message + " \n " } ws . Write Message ( websocket . Text Message , [ ] byte ( " " + msg ) ) } ws . Write Message ( websocket . Close Message , websocket . Format Close Message ( websocket . Close Normal Closure , " " ) ) ws . Close ( ) } ( ) token : = context . Get Auth Token ( r ) if token = = nil { http Err = & errors . HTTP { Code : http . Status Unauthorized , Message : " " , } return } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { if herr , ok : = err . ( * errors . HTTP ) ; ok { http Err = herr } else { http Err = & errors . HTTP { Code : http . Status Internal Server Error , Message : err . Error ( ) , } } return } allowed : = permission . Check ( token , permission . Perm App Run Shell , contexts For App ( & a ) . . . ) if ! allowed { http Err = permission . Err Unauthorized return } buf : = & optional Writer Closer { } var term * terminal . Terminal unit ID : = r . URL . Query ( ) . Get ( " " ) isolated , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) width , _ : = strconv . Atoi ( r . URL . Query ( ) . Get ( " " ) ) height , _ : = strconv . Atoi ( r . URL . Query ( ) . Get ( " " ) ) client Term : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Run Shell , Owner : token , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , Disable Lock : true , } ) if err ! = nil { http Err = & errors . HTTP { Code : http . Status Internal Server Error , Message : err . Error ( ) , } return } defer func ( ) { var final Err error if http Err ! = nil { final Err = http Err } for term ! = nil { buf . disable Write = true var line string line , err = term . Read Line ( ) if err ! = nil { break } fmt . Fprintf ( evt , " \n " , line ) } evt . Done ( final Err ) } ( ) term = terminal . New Terminal ( buf , " " ) ws . Set Read Deadline ( time . Now ( ) . Add ( pong Wait ) ) ws . Set Pong Handler ( func ( string ) error { ws . Set Read Deadline ( time . Now ( ) . Add ( pong Wait ) ) return nil } ) quit : = make ( chan struct { } ) defer close ( quit ) go func ( ) { for { select { case < - quit : return case < - time . After ( ping Interval ) : } ws . Write Control ( websocket . Ping Message , nil , time . Now ( ) . Add ( 2 * time . Second ) ) } } ( ) conn : = & cmd Logger { base : & ws Read Write Closer { ws } , term : term } opts : = provision . Exec Options { Stdout : conn , Stderr : conn , Stdin : conn , Width : width , Height : height , Units : units For Shell ( a , unit ID , isolated ) , Term : client Term , } err = a . Shell ( opts ) if err ! = nil { http Err = & errors . HTTP { Code : http . Status Internal Server Error , Message : err . Error ( ) , } } } 
func Manager ( ) Repository Manager { manager Name , err : = config . Get String ( " " ) if err ! = nil { manager Name = default Manager } if _ , ok : = managers [ manager Name ] ; ! ok { manager Name = " " } return managers [ manager Name ] } 
func Register ( name string , manager Repository Manager ) { if managers = = nil { managers = make ( map [ string ] Repository Manager ) } managers [ name ] = manager } 
func ( b * bind Syncer ) start ( ) error { if b . started { return errors . New ( " " ) } if b . app Lister = = nil { return errors . New ( " " ) } if b . interval = = 0 { b . interval = 5 * time . Minute } b . shutdown = make ( chan struct { } , 1 ) b . done = make ( chan struct { } ) b . started = true log . Debugf ( " \n " , b . interval ) go func ( d time . Duration ) { for { select { case < - time . After ( d ) : start : = time . Now ( ) log . Debug ( " " ) apps , err : = b . app Lister ( ) if err ! = nil { log . Errorf ( " " , err ) sync Duration . Set ( time . Since ( start ) . Seconds ( ) ) break } for _ , a : = range apps { err = b . sync ( a ) if err ! = nil { log . Errorf ( " " , a . Get Name ( ) , err ) } if len ( b . shutdown ) > 0 { break } } log . Debugf ( " " , len ( apps ) ) d = b . interval sync Duration . Set ( time . Since ( start ) . Seconds ( ) ) case < - b . shutdown : b . done < - struct { } { } return } } } ( time . Millisecond * 1 0 0 ) return nil } 
func ( b * bind Syncer ) Shutdown ( ctx context . Context ) error { if ! b . started { return nil } b . shutdown < - struct { } { } select { case < - b . done : case < - ctx . Done ( ) : } b . started = false return ctx . Err ( ) } 
func Get For Provisioner ( p provision . Provisioner ) ( Builder , error ) { builder , err : = get ( p . Get Name ( ) ) if err ! = nil { if _ , ok : = p . ( provision . Builder Deploy Docker Client ) ; ok { return get ( " " ) } else if _ , ok : = p . ( provision . Builder Deploy Kube Client ) ; ok { return get ( " " ) } } return builder , err } 
func get ( name string ) ( Builder , error ) { b , ok : = builders [ name ] if ! ok { return nil , errors . Errorf ( " " , name ) } return b , nil } 
func Registry ( ) ( [ ] Builder , error ) { registry : = make ( [ ] Builder , 0 , len ( builders ) ) for _ , b : = range builders { registry = append ( registry , b ) } return registry , nil } 
func Register Queue Task ( p Docker Provisioner ) error { q , err : = queue . Queue ( ) if err ! = nil { return err } return q . Register Task ( & run Bs { provisioner : p } ) } 
func healing History Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Healing Read ) { return permission . Err Unauthorized } filter : = r . URL . Query ( ) . Get ( " " ) if filter ! = " " & & filter ! = " " & & filter ! = " " { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } history , err : = healer . List Healing History ( filter ) if err ! = nil { return err } if len ( history ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( history ) } 
func ( v * version ) Apps ( ) App Informer { return & app Informer { factory : v . factory , namespace : v . namespace , tweak List Options : v . tweak List Options } } 
func is Terminating ( pod apiv 1 . Pod ) bool { return pod . Spec . Active Deadline Seconds ! = nil & & * pod . Spec . Active Deadline Seconds > = int 6 4 ( 0 ) | | pod . Deletion Timestamp ! = nil } 
func dump Goroutines ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Debug ) { return permission . Err Unauthorized } return pprof . Lookup ( " " ) . Write To ( w , 2 ) } 
func ( in * App ) Deep Copy Into ( out * App ) { * out = * in out . Type Meta = in . Type Meta in . Object Meta . Deep Copy Into ( & out . Object Meta ) in . Spec . Deep Copy Into ( & out . Spec ) return } 
func ( in * App ) Deep Copy ( ) * App { if in = = nil { return nil } out : = new ( App ) in . Deep Copy Into ( out ) return out } 
func ( in * App ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * App List ) Deep Copy Into ( out * App List ) { * out = * in out . Type Meta = in . Type Meta out . List Meta = in . List Meta if in . Items ! = nil { in , out : = & in . Items , & out . Items * out = make ( [ ] App , len ( * in ) ) for i : = range * in { ( * in ) [ i ] . Deep Copy Into ( & ( * out ) [ i ] ) } } return } 
func ( in * App List ) Deep Copy ( ) * App List { if in = = nil { return nil } out : = new ( App List ) in . Deep Copy Into ( out ) return out } 
func ( in * App List ) Deep Copy Object ( ) runtime . Object { if c : = in . Deep Copy ( ) ; c ! = nil { return c } return nil } 
func ( in * App Spec ) Deep Copy Into ( out * App Spec ) { * out = * in if in . Deployments ! = nil { in , out : = & in . Deployments , & out . Deployments * out = make ( map [ string ] [ ] string , len ( * in ) ) for key , val : = range * in { if val = = nil { ( * out ) [ key ] = nil } else { ( * out ) [ key ] = make ( [ ] string , len ( val ) ) copy ( ( * out ) [ key ] , val ) } } } if in . Services ! = nil { in , out : = & in . Services , & out . Services * out = make ( map [ string ] [ ] string , len ( * in ) ) for key , val : = range * in { if val = = nil { ( * out ) [ key ] = nil } else { ( * out ) [ key ] = make ( [ ] string , len ( val ) ) copy ( ( * out ) [ key ] , val ) } } } return } 
func ( in * App Spec ) Deep Copy ( ) * App Spec { if in = = nil { return nil } out : = new ( App Spec ) in . Deep Copy Into ( out ) return out } 
func service Broker List ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Service Broker Read ) { return permission . Err Unauthorized } brokers , err : = servicemanager . Service Broker . List ( ) if err ! = nil { return err } if len ( brokers ) = = 0 { w . Write Header ( http . Status No Content ) return nil } return json . New Encoder ( w ) . Encode ( map [ string ] interface { } { " " : brokers , } ) } 
func service Broker Add ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Service Broker Create ) { return permission . Err Unauthorized } broker , err : = decode Service Broker ( r ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Service Broker , Value : broker . Name } , Kind : permission . Perm Service Broker Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Broker Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if err = servicemanager . Service Broker . Create ( * broker ) ; err ! = nil { if err = = service . Err Service Broker Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : " " } } return err } w . Write Header ( http . Status Created ) return nil } 
func service Broker Update ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Service Broker Update ) { return permission . Err Unauthorized } broker Name : = r . URL . Query ( ) . Get ( " " ) if broker Name = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } broker , err : = decode Service Broker ( r ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Service Broker , Value : broker . Name } , Kind : permission . Perm Service Broker Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Broker Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if err = servicemanager . Service Broker . Update ( broker Name , * broker ) ; err = = service . Err Service Broker Not Found { w . Write Header ( http . Status Not Found ) } return err } 
func ( w * Log Writer ) Write ( data [ ] byte ) ( int , error ) { w . fin Lk . RLock ( ) defer w . fin Lk . RUnlock ( ) if w . closed { return len ( data ) , nil } if w . msg Ch = = nil { return len ( data ) , w . write ( data ) } copied : = make ( [ ] byte , len ( data ) ) copy ( copied , data ) w . msg Ch < - copied return len ( data ) , nil } 
func create Cluster ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Cluster Create ) if ! allowed { return permission . Err Unauthorized } var prov Cluster prov Types . Cluster err = Parse Input ( r , & prov Cluster ) if err ! = nil { return err } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Cluster , Value : prov Cluster . Name } , Kind : permission . Perm Cluster Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Cluster Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) _ , err = servicemanager . Cluster . Find By Name ( prov Cluster . Name ) if err = = nil { return & tsuru Errors . HTTP { Code : http . Status Conflict , Message : " " , } } for _ , pool Name : = range prov Cluster . Pools { _ , err = pool . Get Pool By Name ( pool Name ) if err ! = nil { if err = = pool . Err Pool Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } } stream Response : = strings . Has Prefix ( r . Header . Get ( " " ) , " " ) if stream Response { w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) } prov Cluster . Writer = evt err = servicemanager . Cluster . Create ( prov Cluster ) if err ! = nil { return errors . With Stack ( err ) } return nil } 
func list Clusters ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Cluster Read ) if ! allowed { return permission . Err Unauthorized } clusters , err : = servicemanager . Cluster . List ( ) if err ! = nil { if err = = prov Types . Err No Cluster { w . Write Header ( http . Status No Content ) return nil } return err } for i : = range clusters { clusters [ i ] . Client Key = nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( clusters ) } 
func delete Cluster ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Cluster Delete ) if ! allowed { return permission . Err Unauthorized } cluster Name : = r . URL . Query ( ) . Get ( " " ) evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Cluster , Value : cluster Name } , Kind : permission . Perm Cluster Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Cluster Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) stream Response : = strings . Has Prefix ( r . Header . Get ( " " ) , " " ) if stream Response { w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) } err = servicemanager . Cluster . Delete ( prov Types . Cluster { Name : cluster Name , Writer : evt } ) if err ! = nil { if errors . Cause ( err ) = = prov Types . Err Cluster Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } return nil } 
func provisioner List ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed : = permission . Check ( t , permission . Perm Cluster Read ) if ! allowed { return permission . Err Unauthorized } provs , err : = provision . Registry ( ) if err ! = nil { return err } info : = make ( [ ] provisioner Info , len ( provs ) ) for i , p : = range provs { info [ i ] . Name = p . Get Name ( ) if cluster Prov , ok : = p . ( cluster . Clustered Provisioner ) ; ok { info [ i ] . Cluster Help = cluster Prov . Cluster Help ( ) } } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( info ) } 
func add Node Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var params provision . Add Node Options err = Parse Input ( r , & params ) if err ! = nil { return err } if template Name , ok : = params . Metadata [ " " ] ; ok { params . Metadata , err = iaas . Expand Template ( template Name , params . Metadata ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } } params . Pool = params . Metadata [ provision . Pool Metadata Name ] params . Iaa SID = params . Metadata [ provision . Iaa SIDMetadata Name ] delete ( params . Metadata , provision . Iaa SIDMetadata Name ) if params . Pool = = " " { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " } } if ! permission . Check ( t , permission . Perm Node Create , permission . Context ( perm Types . Ctx Pool , params . Pool ) ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node } , Kind : permission . Perm Node Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , params . Pool ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) p , err : = pool . Get Pool By Name ( params . Pool ) if err ! = nil { return err } prov , err : = p . Get Provisioner ( ) if err ! = nil { return err } node Prov , ok : = prov . ( provision . Node Provisioner ) if ! ok { return provision . Provisioner Not Supported { Prov : prov , Action : " " } } w . Header ( ) . Set ( " " , " " ) w . Write Header ( http . Status Created ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) addr , response , err : = add Node For Params ( node Prov , params ) evt . Target . Value = addr if err ! = nil { if desc : = response [ " " ] ; desc ! = " " { return errors . Wrapf ( err , " \n " , desc ) } return err } return nil } 
func remove Node Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { address : = r . URL . Query ( ) . Get ( " " ) if address = = " " { return errors . Errorf ( " " ) } _ , n , err : = node . Find Node ( address ) if err ! = nil { if err = = provision . Err Node Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } pool : = n . Pool ( ) allowed Node Remove : = permission . Check ( t , permission . Perm Node Delete , permission . Context ( perm Types . Ctx Pool , pool ) , ) if ! allowed Node Remove { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node , Value : n . Address ( ) } , Kind : permission . Perm Node Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , pool ) ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) no Rebalance , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) remove Iaa S , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) return node . Remove Node ( node . Remove Node Args { Node : n , Rebalance : ! no Rebalance , Writer : w , Remove Iaa S : remove Iaa S , } ) } 
func list Nodes Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { pools , err : = permission . List Context Values ( t , permission . Perm Node Read , false ) if err ! = nil { return err } provs , err : = provision . Registry ( ) if err ! = nil { return err } prov Name Map : = map [ string ] string { } var all Nodes [ ] provision . Node Spec for _ , prov : = range provs { node Prov , ok : = prov . ( provision . Node Provisioner ) if ! ok { continue } var nodes [ ] provision . Node nodes , err = node Prov . List Nodes ( nil ) if err ! = nil { all Nodes = append ( all Nodes , provision . Node Spec { Address : fmt . Sprintf ( " " , prov . Get Name ( ) ) , Status : fmt . Sprintf ( " " , err ) , } ) continue } for _ , n : = range nodes { prov Name Map [ n . Address ( ) ] = prov . Get Name ( ) all Nodes = append ( all Nodes , provision . Node To Spec ( n ) ) } } if pools ! = nil { filtered Nodes : = make ( [ ] provision . Node Spec , 0 , len ( all Nodes ) ) for _ , node : = range all Nodes { for _ , pool : = range pools { if node . Pool = = pool { filtered Nodes = append ( filtered Nodes , node ) break } } } all Nodes = filtered Nodes } iaases , err : = permission . List Context Values ( t , permission . Perm Machine Read , false ) if err ! = nil { return err } machines , err : = iaas . List Machines ( ) if err ! = nil { return err } if iaases ! = nil { filtered Machines : = make ( [ ] iaas . Machine , 0 , len ( machines ) ) for _ , machine : = range machines { for _ , iaas : = range iaases { if machine . Iaas = = iaas { filtered Machines = append ( filtered Machines , machine ) break } } } machines = filtered Machines } if len ( all Nodes ) = = 0 & & len ( machines ) = = 0 { w . Write Header ( http . Status No Content ) return nil } result : = api Types . List Node Response { Nodes : all Nodes , Machines : machines , } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( result ) } 
func update Node Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var params provision . Update Node Options err = Parse Input ( r , & params ) if err ! = nil { return err } if params . Disable & & params . Enable { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } if params . Address = = " " { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " } } prov , node , err : = node . Find Node ( params . Address ) if err ! = nil { if err = = provision . Err Node Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } node Prov : = prov . ( provision . Node Provisioner ) old Pool : = node . Pool ( ) allowed Old Pool : = permission . Check ( t , permission . Perm Node Update , permission . Context ( perm Types . Ctx Pool , old Pool ) , ) if ! allowed Old Pool { return permission . Err Unauthorized } var ok bool params . Pool , ok = params . Metadata [ provision . Pool Metadata Name ] if ok { delete ( params . Metadata , provision . Pool Metadata Name ) allowed New Pool : = permission . Check ( t , permission . Perm Node Update , permission . Context ( perm Types . Ctx Pool , params . Pool ) , ) if ! allowed New Pool { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node , Value : node . Address ( ) } , Kind : permission . Perm Node Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , permission . Context ( perm Types . Ctx Pool , old Pool ) , permission . Context ( perm Types . Ctx Pool , params . Pool ) , ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return node Prov . Update Node ( params ) } 
func list Units By Node ( w http . Response Writer , r * http . Request , t auth . Token ) error { address : = r . URL . Query ( ) . Get ( " " ) _ , node , err : = node . Find Node ( address ) if err ! = nil { if err = = provision . Err Node Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } has Access : = permission . Check ( t , permission . Perm Node Read , permission . Context ( perm Types . Ctx Pool , node . Pool ( ) ) ) if ! has Access { return permission . Err Unauthorized } units , err : = node . Units ( ) if err ! = nil { return err } if len ( units ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( units ) } 
func list Units By App ( w http . Response Writer , r * http . Request , t auth . Token ) error { app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = app . Get By Name ( app Name ) if err ! = nil { if err = = app Types . Err App Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } can Read : = permission . Check ( t , permission . Perm App Read , contexts For App ( a ) . . . , ) if ! can Read { return permission . Err Unauthorized } units , err : = a . Units ( ) if err ! = nil { return err } if len ( units ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( units ) } 
func node Healing Read ( w http . Response Writer , r * http . Request , t auth . Token ) error { pools , err : = permission . List Context Values ( t , permission . Perm Healing Read , true ) if err ! = nil { return err } config Map , err : = healer . Get Config ( ) if err ! = nil { return err } if len ( pools ) > 0 { allowed Pool Set : = map [ string ] struct { } { } for _ , p : = range pools { allowed Pool Set [ p ] = struct { } { } } for k : = range config Map { if k = = " " { continue } if _ , ok : = allowed Pool Set [ k ] ; ! ok { delete ( config Map , k ) } } } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( config Map ) } 
func node Healing Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { pool Name : = Input Value ( r , " " ) var ctxs [ ] perm Types . Permission Context if pool Name ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , pool Name ) ) } if ! permission . Check ( t , permission . Perm Healing Update , ctxs . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Name } , Kind : permission . Perm Healing Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) var config healer . Node Healer Config err = Parse Input ( r , & config ) if err ! = nil { return err } return healer . Update Config ( pool Name , config ) } 
func node Healing Delete ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { pool Name : = r . URL . Query ( ) . Get ( " " ) var ctxs [ ] perm Types . Permission Context if pool Name ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , pool Name ) ) } if ! permission . Check ( t , permission . Perm Healing Delete , ctxs . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : pool Name } , Kind : permission . Perm Healing Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if len ( r . URL . Query ( ) [ " " ] ) = = 0 { return healer . Remove Config ( pool Name , " " ) } for _ , v : = range r . URL . Query ( ) [ " " ] { err : = healer . Remove Config ( pool Name , v ) if err ! = nil { return err } } return nil } 
func rebalance Nodes Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var params provision . Rebalance Nodes Options err = Parse Input ( r , & params ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } params . Force = true var perm Contexts [ ] perm Types . Permission Context var ok bool evt Target : = event . Target { Type : event . Target Type Global } params . Pool , ok = params . Metadata Filter [ provision . Pool Metadata Name ] if ok { delete ( params . Metadata Filter , provision . Pool Metadata Name ) perm Contexts = append ( perm Contexts , permission . Context ( perm Types . Ctx Pool , params . Pool ) ) evt Target = event . Target { Type : event . Target Type Pool , Value : params . Pool } } if ! permission . Check ( t , permission . Perm Node Update Rebalance , perm Contexts . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : evt Target , Kind : permission . Perm Node Update Rebalance , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events , perm Contexts . . . ) , Cancelable : true , Allowed Cancel : event . Allowed ( permission . Perm App Update Events , perm Contexts . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) params . Event = evt var provs [ ] provision . Provisioner if params . Pool ! = " " { var p * pool . Pool var prov provision . Provisioner p , err = pool . Get Pool By Name ( params . Pool ) if err ! = nil { return err } prov , err = p . Get Provisioner ( ) if err ! = nil { return err } if _ , ok : = prov . ( provision . Node Rebalance Provisioner ) ; ! ok { return provision . Provisioner Not Supported { Prov : prov , Action : " " } } provs = append ( provs , prov ) } else { provs , err = provision . Registry ( ) if err ! = nil { return err } } for _ , prov : = range provs { rebalance Prov , ok : = prov . ( provision . Node Rebalance Provisioner ) if ! ok { continue } _ , err = rebalance Prov . Rebalance Nodes ( params ) if err ! = nil { return errors . Wrap ( err , " " ) } } fmt . Fprintf ( writer , " \n " ) return nil } 
func info Node Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { address : = r . URL . Query ( ) . Get ( " " ) if address = = " " { return errors . Errorf ( " " ) } _ , node , err : = node . Find Node ( address ) if err ! = nil { if err = = provision . Err Node Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } has Access : = permission . Check ( t , permission . Perm Node Read , permission . Context ( perm Types . Ctx Pool , node . Pool ( ) ) ) if ! has Access { return permission . Err Unauthorized } spec : = provision . Node To Spec ( node ) if spec . Iaa SID = = " " { var machine iaas . Machine machine , err = iaas . Find Machine By Address ( address ) if err ! = nil { if err ! = iaas . Err Machine Not Found { return err } } else { spec . Iaa SID = machine . Iaas } } node Status , err : = healer . Healer Instance . Get Node Status Data ( node ) if err ! = nil & & err ! = provision . Err Node Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } units , err : = node . Units ( ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } response : = api Types . Info Node Response { Node : spec , Status : node Status , Units : units , } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( response ) } 
func ( s Native Scheme ) Reset Password ( user * auth . User , reset Token string ) error { if reset Token = = " " { return auth . Err Invalid Token } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) pass Token , err : = get Password Token ( reset Token ) if err ! = nil { return err } if pass Token . User Email ! = user . Email { return auth . Err Invalid Token } password : = generate Password ( 1 2 ) user . Password = password hash Password ( user ) go send New Password ( user , password ) pass Token . Used = true conn . Password Tokens ( ) . Update Id ( pass Token . Token , pass Token ) return user . Update ( ) } 
func deploy ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { opts , err : = prepare To Build ( r ) if err ! = nil { return err } if opts . File ! = nil { defer opts . File . Close ( ) } commit : = Input Value ( r , " " ) w . Header ( ) . Set ( " " , " " ) app Name : = r . URL . Query ( ) . Get ( " " ) origin : = Input Value ( r , " " ) if opts . Image ! = " " { origin = " " } if origin ! = " " { if ! app . Validate Origin ( origin ) { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } } var user Name string if t . Is App Token ( ) { if t . Get App Name ( ) ! = app Name & & t . Get App Name ( ) ! = app . Internal App Name { return & tsuru Errors . HTTP { Code : http . Status Unauthorized , Message : " " } } user Name = Input Value ( r , " " ) } else { commit = " " user Name = t . Get User Name ( ) } instance , err : = app . Get By Name ( app Name ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } message : = Input Value ( r , " " ) if commit ! = " " & & message = = " " { var messages [ ] string messages , err = repository . Manager ( ) . Commit Messages ( instance . Name , commit , 1 ) if err ! = nil { return err } if len ( messages ) > 0 { message = messages [ 0 ] } } if origin = = " " & & commit ! = " " { origin = " " } opts . App = instance opts . Commit = commit opts . User = user Name opts . Origin = origin opts . Message = message opts . Get Kind ( ) if t . Get App Name ( ) ! = app . Internal App Name { can Deploy : = permission . Check ( t , perm Scheme For Deploy ( opts ) , contexts For App ( instance ) . . . ) if ! can Deploy { return & tsuru Errors . HTTP { Code : http . Status Forbidden , Message : " " } } } var image ID string evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Deploy , Raw Owner : event . Owner { Type : event . Owner Type User , Name : user Name } , Custom Data : opts , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( instance ) . . . ) , Allowed Cancel : event . Allowed ( permission . Perm App Update Events , contexts For App ( instance ) . . . ) , Cancelable : true , } ) if err ! = nil { return err } defer func ( ) { evt . Done Custom Data ( err , map [ string ] string { " " : image ID } ) } ( ) w . Header ( ) . Set ( event IDHeader , evt . Unique ID . Hex ( ) ) opts . Event = evt writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer writer . Stop ( ) opts . Output Stream = writer image ID , err = app . Deploy ( opts ) if err = = nil { fmt . Fprintln ( w , " \n " ) } return err } 
func diff Deploy ( w http . Response Writer , r * http . Request , t auth . Token ) error { writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer writer . Stop ( ) fmt . Fprint ( w , " \n " ) app Name : = r . URL . Query ( ) . Get ( " " ) diff : = Input Value ( r , " " ) instance , err : = app . Get By Name ( app Name ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } if t . Get App Name ( ) ! = app . Internal App Name { can Diff Deploy : = permission . Check ( t , permission . Perm App Read Deploy , contexts For App ( instance ) . . . ) if ! can Diff Deploy { return & tsuru Errors . HTTP { Code : http . Status Forbidden , Message : permission . Err Unauthorized . Error ( ) } } } evt , err : = event . Get Running ( app Target ( app Name ) , permission . Perm App Deploy . Full Name ( ) ) if err ! = nil { return err } return evt . Set Other Custom Data ( map [ string ] string { " " : diff , } ) } 
func deploys List ( w http . Response Writer , r * http . Request , t auth . Token ) error { contexts : = permission . Contexts For Permission ( t , permission . Perm App Read Deploy ) if len ( contexts ) = = 0 { w . Write Header ( http . Status No Content ) return nil } filter : = app Filter By Context ( contexts , nil ) filter . Name = r . URL . Query ( ) . Get ( " " ) skip : = r . URL . Query ( ) . Get ( " " ) limit : = r . URL . Query ( ) . Get ( " " ) skip Int , _ : = strconv . Atoi ( skip ) limit Int , _ : = strconv . Atoi ( limit ) deploys , err : = app . List Deploys ( filter , skip Int , limit Int ) if err ! = nil { return err } if len ( deploys ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( deploys ) } 
func deploy Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { dep ID : = r . URL . Query ( ) . Get ( " " ) deploy , err : = app . Get Deploy ( dep ID ) if err ! = nil { if err = = event . Err Event Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : " " } } return err } db App , err : = app . Get By Name ( deploy . App ) if err ! = nil { return err } can Get : = permission . Check ( t , permission . Perm App Read Deploy , contexts For App ( db App ) . . . ) if ! can Get { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : " " } } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( deploy ) } 
func deploy Rebuild ( w http . Response Writer , r * http . Request , t auth . Token ) error { app Name : = r . URL . Query ( ) . Get ( " " ) instance , err : = app . Get By Name ( app Name ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : fmt . Sprintf ( " " , app Name ) } } origin : = Input Value ( r , " " ) if ! app . Validate Origin ( origin ) { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } opts : = app . Deploy Options { App : instance , Output Stream : writer , User : t . Get User Name ( ) , Origin : origin , Kind : app . Deploy Rebuild , } can Deploy : = permission . Check ( t , perm Scheme For Deploy ( opts ) , contexts For App ( instance ) . . . ) if ! can Deploy { return & tsuru Errors . HTTP { Code : http . Status Forbidden , Message : permission . Err Unauthorized . Error ( ) } } var image ID string evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Deploy , Owner : t , Custom Data : opts , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( instance ) . . . ) , Allowed Cancel : event . Allowed ( permission . Perm App Update Events , contexts For App ( instance ) . . . ) , Cancelable : true , } ) if err ! = nil { return err } defer func ( ) { evt . Done Custom Data ( err , map [ string ] string { " " : image ID } ) } ( ) opts . Event = evt image ID , err = app . Deploy ( opts ) if err ! = nil { writer . Encode ( tsuru Io . Simple Json Message { Error : err . Error ( ) } ) } return nil } 
func deploy Rollback Update ( w http . Response Writer , r * http . Request , t auth . Token ) error { app Name : = r . URL . Query ( ) . Get ( " " ) instance , err : = app . Get By Name ( app Name ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : fmt . Sprintf ( " " , app Name ) , } } can Update Rollback : = permission . Check ( t , permission . Perm App Update Deploy Rollback , contexts For App ( instance ) . . . ) if ! can Update Rollback { return & tsuru Errors . HTTP { Code : http . Status Forbidden , Message : " " , } } img : = Input Value ( r , " " ) if img = = " " { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } disable : = Input Value ( r , " " ) disable Rollback , err : = strconv . Parse Bool ( disable ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : fmt . Sprintf ( " " , disable ) , } } reason : = Input Value ( r , " " ) if ( reason = = " " ) & & ( disable Rollback ) { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Deploy Rollback , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( instance ) . . . ) , Allowed Cancel : event . Allowed ( permission . Perm App Update Events , contexts For App ( instance ) . . . ) , Cancelable : false , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = app . Rollback Update ( instance . Name , img , reason , disable Rollback ) if err ! = nil { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } return err } 
func Build Health Check ( provider Name string ) func ( ) error { return func ( ) error { iaas Config , err : = config . Get ( " " ) if err ! = nil { return hc . Err Disabled Component } iaases , _ : = iaas Config . ( map [ interface { } ] interface { } ) for iface Name : = range iaases { name : = iface Name . ( string ) if name = = " " { custom Iaases : = iaases [ name ] . ( map [ interface { } ] interface { } ) for iface Name : = range custom Iaases { iaas : = custom Iaases [ iface Name . ( string ) ] . ( map [ interface { } ] interface { } ) if iaas [ " " ] . ( string ) ! = provider Name { continue } name = iface Name . ( string ) } } else if name ! = provider Name { continue } err : = health Check ( name ) if err ! = nil { return err } } return nil } } 
func get Brokered Service ( name string ) ( Service , error ) { catalog Name , service Name , err : = split Broker Service ( name ) if err ! = nil { return Service { } , err } client , err : = new Brokered Service Client ( name ) if err ! = nil { return Service { } , err } s , _ , err : = client . get Service ( service Name , catalog Name ) return s , err } 
func machines List ( w http . Response Writer , r * http . Request , token auth . Token ) error { machines , err : = iaas . List Machines ( ) if err ! = nil { return err } contexts : = permission . Contexts For Permission ( token , permission . Perm Machine Read ) allowed Iaa S : = map [ string ] struct { } { } for _ , c : = range contexts { if c . Ctx Type = = perm Types . Ctx Global { allowed Iaa S = nil break } if c . Ctx Type = = perm Types . Ctx Iaa S { allowed Iaa S [ c . Value ] = struct { } { } } } for i : = 0 ; allowed Iaa S ! = nil & & i < len ( machines ) ; i + + { if _ , ok : = allowed Iaa S [ machines [ i ] . Iaas ] ; ! ok { machines = append ( machines [ : i ] , machines [ i + 1 : ] . . . ) i - - } } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( machines ) } 
func machine Destroy ( w http . Response Writer , r * http . Request , token auth . Token ) ( err error ) { machine ID : = r . URL . Query ( ) . Get ( " " ) if machine ID = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } m , err : = iaas . Find Machine By Id ( machine ID ) if err ! = nil { if err = = iaas . Err Machine Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } return err } iaas Ctx : = permission . Context ( perm Types . Ctx Iaa S , m . Iaas ) allowed : = permission . Check ( token , permission . Perm Machine Delete , iaas Ctx ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Iaas , Value : m . Iaas } , Kind : permission . Perm Machine Delete , Owner : token , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Machine Read Events , iaas Ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return m . Destroy ( ) } 
func templates List ( w http . Response Writer , r * http . Request , token auth . Token ) error { templates , err : = iaas . List Templates ( ) if err ! = nil { return err } contexts : = permission . Contexts For Permission ( token , permission . Perm Machine Template Read ) allowed Iaa S : = map [ string ] struct { } { } for _ , c : = range contexts { if c . Ctx Type = = perm Types . Ctx Global { allowed Iaa S = nil break } if c . Ctx Type = = perm Types . Ctx Iaa S { allowed Iaa S [ c . Value ] = struct { } { } } } for i : = 0 ; allowed Iaa S ! = nil & & i < len ( templates ) ; i + + { if _ , ok : = allowed Iaa S [ templates [ i ] . Iaa SName ] ; ! ok { templates = append ( templates [ : i ] , templates [ i + 1 : ] . . . ) i - - } } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( templates ) } 
func template Create ( w http . Response Writer , r * http . Request , token auth . Token ) ( err error ) { var param Template iaas . Template err = Parse Input ( r , & param Template ) if err ! = nil { return err } iaas Ctx : = permission . Context ( perm Types . Ctx Iaa S , param Template . Iaa SName ) allowed : = permission . Check ( token , permission . Perm Machine Template Create , iaas Ctx ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Iaas , Value : param Template . Iaa SName } , Kind : permission . Perm Machine Template Create , Owner : token , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Machine Read Events , iaas Ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) _ , err = iaas . Find Template ( param Template . Name ) if err ! = nil & & err ! = mgo . Err Not Found { return err } if err = = nil { return & errors . HTTP { Code : http . Status Conflict , Message : fmt . Sprintf ( " \ " \ " " , param Template . Name ) } } err = param Template . Save ( ) if err ! = nil { return err } w . Write Header ( http . Status Created ) return nil } 
func template Destroy ( w http . Response Writer , r * http . Request , token auth . Token ) ( err error ) { template Name : = r . URL . Query ( ) . Get ( " " ) t , err : = iaas . Find Template ( template Name ) if err ! = nil { if err = = mgo . Err Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } return err } iaas Ctx : = permission . Context ( perm Types . Ctx Iaa S , t . Iaa SName ) allowed : = permission . Check ( token , permission . Perm Machine Template Delete , iaas Ctx ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Iaas , Value : t . Iaa SName } , Kind : permission . Perm Machine Template Delete , Owner : token , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Machine Read Events , iaas Ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return iaas . Destroy Template ( template Name ) } 
func template Update ( w http . Response Writer , r * http . Request , token auth . Token ) ( err error ) { var param Template iaas . Template err = Parse Input ( r , & param Template ) if err ! = nil { return err } template Name : = r . URL . Query ( ) . Get ( " " ) db Tpl , err : = iaas . Find Template ( template Name ) if err ! = nil { if err = = mgo . Err Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } return err } iaas Value : = Input Value ( r , " " ) if iaas Value ! = " " { db Tpl . Iaa SName = iaas Value } iaas Ctx : = permission . Context ( perm Types . Ctx Iaa S , db Tpl . Iaa SName ) allowed : = permission . Check ( token , permission . Perm Machine Template Update , iaas Ctx ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Iaas , Value : db Tpl . Iaa SName } , Kind : permission . Perm Machine Template Update , Owner : token , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Machine Read Events , iaas Ctx ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return db Tpl . Update ( & param Template ) } 
func ( c * Tsuru V 1Client ) RESTClient ( ) rest . Interface { if c = = nil { return nil } return c . rest Client } 
func add Known Types ( scheme * runtime . Scheme ) error { scheme . Add Known Types ( Scheme Group Version , & App { } , & App List { } , ) scheme . Add Known Types ( Scheme Group Version , & metav 1 . Status { } , ) metav 1 . Add To Group Version ( scheme , Scheme Group Version ) return nil } 
func saml Metadata ( w http . Response Writer , r * http . Request ) error { if app . Auth Scheme . Name ( ) ! = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } page , err : = saml . Metadata ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) w . Write ( [ ] byte ( page ) ) return nil } 
func saml Callback Login ( w http . Response Writer , r * http . Request ) error { if app . Auth Scheme . Name ( ) ! = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } params : = map [ string ] string { } content : = r . Post Form Value ( " " ) if content = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } params [ " " ] = " " params [ " " ] = content _ , err : = scheme . Login ( params ) if err ! = nil { msg : = fmt . Sprintf ( cmd . Saml Callback Failure Message ( ) , err . Error ( ) ) fmt . Fprint ( w , msg ) } else { fmt . Fprint ( w , cmd . Saml Callback Success Message ( ) ) } return nil } 
func volumes List ( w http . Response Writer , r * http . Request , t auth . Token ) error { contexts : = permission . Contexts For Permission ( t , permission . Perm Volume Read ) if len ( contexts ) = = 0 { w . Write Header ( http . Status No Content ) return nil } volumes , err : = volume . List By Filter ( volume Filter By Context ( contexts ) ) if err ! = nil { return err } if len ( volumes ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( volumes ) } 
func volume Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { v , err : = volume . Load ( r . URL . Query ( ) . Get ( " " ) ) if err ! = nil { if err = = volume . Err Volume Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } can Read : = permission . Check ( t , permission . Perm Volume Read , contexts For Volume ( v ) . . . ) if ! can Read { return permission . Err Unauthorized } _ , err = v . Load Binds ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( & v ) } 
func volume Create ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var input Volume volume . Volume err = Parse Input ( r , & input Volume ) if err ! = nil { return err } input Volume . Plan . Opts = nil input Volume . Status = " " can Create : = permission . Check ( t , permission . Perm Volume Create , permission . Context ( perm Types . Ctx Team , input Volume . Team Owner ) , permission . Context ( perm Types . Ctx Pool , input Volume . Pool ) , ) if ! can Create { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Volume , Value : input Volume . Name } , Kind : permission . Perm Volume Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Volume Read Events , contexts For Volume ( & input Volume ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) _ , err = volume . Load ( input Volume . Name ) if err = = nil { return & errors . HTTP { Code : http . Status Conflict , Message : " " } } err = input Volume . Create ( ) if err ! = nil { return err } w . Write Header ( http . Status Created ) return nil } 
func volume Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var input Volume volume . Volume err = Parse Input ( r , & input Volume ) if err ! = nil { return err } input Volume . Plan . Opts = nil input Volume . Status = " " input Volume . Name = r . URL . Query ( ) . Get ( " " ) db Volume , err : = volume . Load ( input Volume . Name ) if err ! = nil { if err = = volume . Err Volume Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } can Update : = permission . Check ( t , permission . Perm Volume Update , contexts For Volume ( db Volume ) . . . ) if ! can Update { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Volume , Value : input Volume . Name } , Kind : permission . Perm Volume Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Volume Read Events , contexts For Volume ( db Volume ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return input Volume . Update ( ) } 
func volume Plans List ( w http . Response Writer , r * http . Request , t auth . Token ) error { contexts : = permission . Contexts For Permission ( t , permission . Perm Volume Create ) if len ( contexts ) = = 0 { return permission . Err Unauthorized } plans Provisioners , err : = volume . List Plans ( ) if err ! = nil { return err } if len ( plans Provisioners ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( plans Provisioners ) } 
func volume Delete ( w http . Response Writer , r * http . Request , t auth . Token ) error { volume Name : = r . URL . Query ( ) . Get ( " " ) db Volume , err : = volume . Load ( volume Name ) if err ! = nil { if err = = volume . Err Volume Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } can Delete : = permission . Check ( t , permission . Perm Volume Delete , contexts For Volume ( db Volume ) . . . ) if ! can Delete { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Volume , Value : volume Name } , Kind : permission . Perm Volume Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Volume Read Events , contexts For Volume ( db Volume ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return db Volume . Delete ( ) } 
func volume Bind ( w http . Response Writer , r * http . Request , t auth . Token ) error { var bind Info struct { App string Mount Point string Read Only bool No Restart bool } err : = Parse Input ( r , & bind Info ) if err ! = nil { return err } db Volume , err : = volume . Load ( r . URL . Query ( ) . Get ( " " ) ) if err ! = nil { if err = = volume . Err Volume Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } can Bind Volume : = permission . Check ( t , permission . Perm Volume Update Bind , contexts For Volume ( db Volume ) . . . ) if ! can Bind Volume { return permission . Err Unauthorized } a , err : = get App From Context ( bind Info . App , r ) if err ! = nil { return err } can Bind App : = permission . Check ( t , permission . Perm App Update Bind Volume , contexts For App ( & a ) . . . ) if ! can Bind App { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Volume , Value : db Volume . Name } , Kind : permission . Perm Volume Update Bind , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Volume Read Events , contexts For Volume ( db Volume ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = db Volume . Bind App ( bind Info . App , bind Info . Mount Point , bind Info . Read Only ) if err ! = nil | | bind Info . No Restart { if err = = volume . Err Volume Already Bound { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } return err } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) return a . Restart ( " " , evt ) } 
func auto Scale Get Config ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed Get Config : = permission . Check ( t , permission . Perm Node Autoscale Read ) if ! allowed Get Config { return permission . Err Unauthorized } config , err : = autoscale . Current Config ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( config ) } 
func auto Scale List Rules ( w http . Response Writer , r * http . Request , t auth . Token ) error { allowed List Rule : = permission . Check ( t , permission . Perm Node Autoscale Read ) if ! allowed List Rule { return permission . Err Unauthorized } rules , err : = autoscale . List Rules ( ) if err ! = nil { return err } if len ( rules ) = = 0 { w . Write Header ( http . Status No Content ) return nil } return json . New Encoder ( w ) . Encode ( & rules ) } 
func auto Scale Set Rule ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed Set Rule : = permission . Check ( t , permission . Perm Node Autoscale Update ) if ! allowed Set Rule { return permission . Err Unauthorized } var rule autoscale . Rule err = Parse Input ( r , & rule ) if err ! = nil { return err } var ctxs [ ] perm Types . Permission Context if rule . Metadata Filter ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , rule . Metadata Filter ) ) } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : rule . Metadata Filter } , Kind : permission . Perm Node Autoscale Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) return rule . Update ( ) } 
func auto Scale Delete Rule ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { allowed Delete Rule : = permission . Check ( t , permission . Perm Node Autoscale ) if ! allowed Delete Rule { return permission . Err Unauthorized } rule Pool : = r . URL . Query ( ) . Get ( " " ) var ctxs [ ] perm Types . Permission Context if rule Pool ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , rule Pool ) ) } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool , Value : rule Pool } , Kind : permission . Perm Node Autoscale Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = autoscale . Delete Rule ( rule Pool ) if err = = mgo . Err Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : " " } } return nil } 
func auto Scale History Handler ( w http . Response Writer , r * http . Request , t auth . Token ) error { if ! permission . Check ( t , permission . Perm Node Autoscale ) { return permission . Err Unauthorized } skip , _ : = strconv . Atoi ( r . URL . Query ( ) . Get ( " " ) ) limit , _ : = strconv . Atoi ( r . URL . Query ( ) . Get ( " " ) ) history , err : = autoscale . List Auto Scale Events ( skip , limit ) if err ! = nil { return err } if len ( history ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( & history ) } 
func auto Scale Run Handler ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { if ! permission . Check ( t , permission . Perm Node Autoscale Update Run ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Pool } , Kind : permission . Perm Node Autoscale Update Run , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Disable Lock : true , Allowed : event . Allowed ( permission . Perm Pool Read Events ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) w . Write Header ( http . Status OK ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) , } return autoscale . Run Once ( writer ) } 
func create Service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) srv , err : = get Service ( service Name ) if err ! = nil { return err } instance : = service . Service Instance { Service Name : service Name , err = Parse Input ( r , & instance ) if err ! = nil { return err } tags , _ : = Input Values ( r , " " ) instance . Tags = append ( instance . Tags , tags . . . ) var team Owner string if instance . Team Owner = = " " { team Owner , err = permission . Team For Permission ( t , permission . Perm Service Instance Create ) if err ! = nil { return err } instance . Team Owner = team Owner } allowed : = permission . Check ( t , permission . Perm Service Instance Create , permission . Context ( perm Types . Ctx Team , instance . Team Owner ) , ) if ! allowed { return permission . Err Unauthorized } if srv . Is Restricted { allowed : = permission . Check ( t , permission . Perm Service Read , contexts For Service ( & srv ) . . . , ) if ! allowed { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : service Instance Target ( service Name , instance . Name ) , Kind : permission . Perm Service Instance Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Instance Read Events , contexts For Service Instance ( & instance , srv . Name ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) request ID : = request IDHeader ( r ) err = service . Create Service Instance ( instance , & srv , evt , request ID ) if err = = service . Err Instance Name Already Exists { return & tsuru Errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) , } } if err = = service . Err Invalid Instance Name { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } if err = = nil { w . Write Header ( http . Status Created ) } return err } 
func update Service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) instance Name : = r . URL . Query ( ) . Get ( " " ) update Data : = struct { Description string Plan string Team Owner string Tags [ ] string } { } err = Parse Input ( r , & update Data ) if err ! = nil { return err } tags , _ : = Input Values ( r , " " ) update Data . Tags = append ( update Data . Tags , tags . . . ) srv , err : = get Service ( service Name ) if err ! = nil { return err } si , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } var wanted Perms [ ] * permission . Permission Scheme if update Data . Description ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Service Instance Update Description ) si . Description = update Data . Description } if update Data . Team Owner ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Service Instance Update Teamowner ) si . Team Owner = update Data . Team Owner } if update Data . Tags ! = nil { wanted Perms = append ( wanted Perms , permission . Perm Service Instance Update Tags ) si . Tags = update Data . Tags } if update Data . Plan ! = " " { wanted Perms = append ( wanted Perms , permission . Perm Service Instance Update Plan ) si . Plan Name = update Data . Plan } if len ( wanted Perms ) = = 0 { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : " " , } } for _ , perm : = range wanted Perms { allowed : = permission . Check ( t , perm , contexts For Service Instance ( si , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : service Instance Target ( service Name , instance Name ) , Kind : permission . Perm Service Instance Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Instance Read Events , contexts For Service Instance ( si , service Name ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) request ID : = request IDHeader ( r ) return si . Update ( srv , * si , evt , request ID ) } 
func remove Service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { unbind All : = r . URL . Query ( ) . Get ( " " ) service Name : = r . URL . Query ( ) . Get ( " " ) instance Name : = r . URL . Query ( ) . Get ( " " ) service Instance , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } w . Header ( ) . Set ( " " , " " ) allowed : = permission . Check ( t , permission . Perm Service Instance Delete , contexts For Service Instance ( service Instance , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : service Instance Target ( service Name , instance Name ) , Kind : permission . Perm Service Instance Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Instance Read Events , contexts For Service Instance ( service Instance , service Name ) . . . ) , } ) if err ! = nil { return err } evt . Set Log Writer ( writer ) defer func ( ) { evt . Done ( err ) } ( ) request ID : = request IDHeader ( r ) unbind All Bool , _ : = strconv . Parse Bool ( unbind All ) if unbind All Bool { if len ( service Instance . Apps ) > 0 { for _ , app Name : = range service Instance . Apps { _ , app , inst Err : = get Service Instance ( service Instance . Service Name , service Instance . Name , app Name ) if inst Err ! = nil { return inst Err } fmt . Fprintf ( evt , " \n " , app . Get Name ( ) ) inst Err = service Instance . Unbind App ( service . Unbind App Args { App : app , Restart : true , Force Remove : false , Event : evt , Request ID : request ID , } ) if inst Err ! = nil { return inst Err } fmt . Fprintf ( evt , " \n \n " , service Instance . Name , app . Get Name ( ) ) } service Instance , err = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } } } err = service . Delete Instance ( service Instance , evt , request ID ) if err ! = nil { if err = = service . Err Service Instance Bound { return & tsuru Errors . HTTP { Message : errors . Wrapf ( err , `Applications bound to the service " %s " : " %s " ` + " \n " , instance Name , strings . Join ( service Instance . Apps , " " ) ) . Error ( ) , Code : http . Status Bad Request , } } return err } evt . Write ( [ ] byte ( " \n " ) ) return nil } 
func service Instances ( w http . Response Writer , r * http . Request , t auth . Token ) error { app Name : = r . URL . Query ( ) . Get ( " " ) contexts : = permission . Contexts For Permission ( t , permission . Perm Service Instance Read ) instances , err : = readable Instances ( t , contexts , app Name , " " ) if err ! = nil { return err } contexts = permission . Contexts For Permission ( t , permission . Perm Service Read ) services , err : = readable Services ( t , contexts ) if err ! = nil { return err } services Map : = map [ string ] * service . Service Model { } for _ , s : = range services { if _ , in : = services Map [ s . Name ] ; ! in { services Map [ s . Name ] = & service . Service Model { Service : s . Name , Instances : [ ] string { } , } } } for _ , instance : = range instances { entry : = services Map [ instance . Service Name ] if entry = = nil { continue } entry . Instances = append ( entry . Instances , instance . Name ) entry . Plans = append ( entry . Plans , instance . Plan Name ) entry . Service Instances = append ( entry . Service Instances , instance ) } result : = [ ] service . Service Model { } for _ , name : = range sorted Service Names ( services Map ) { entry : = services Map [ name ] result = append ( result , * entry ) } if len ( result ) = = 0 { w . Write Header ( http . Status No Content ) return nil } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( result ) } 
func service Instance Status ( w http . Response Writer , r * http . Request , t auth . Token ) error { instance Name : = r . URL . Query ( ) . Get ( " " ) service Name : = r . URL . Query ( ) . Get ( " " ) service Instance , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Read Status , contexts For Service Instance ( service Instance , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } var b string request ID : = request IDHeader ( r ) if b , err = service Instance . Status ( request ID ) ; err ! = nil { return errors . Wrap ( err , " " ) } _ , err = fmt . Fprintf ( w , `Service instance " %s " is %s ` , instance Name , b ) return err } 
func service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) error { instance Name : = r . URL . Query ( ) . Get ( " " ) service Name : = r . URL . Query ( ) . Get ( " " ) svc , err : = get Service ( service Name ) if err ! = nil { return err } service Instance , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Read , contexts For Service Instance ( service Instance , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } request ID : = request IDHeader ( r ) info , err : = service Instance . Info ( request ID ) if err ! = nil { return err } plan , err : = service . Get Plan By Service And Plan Name ( svc , service Instance . Plan Name , request ID ) if err ! = nil { return err } s Info : = service Instance Info { Apps : service Instance . Apps , Teams : service Instance . Teams , Team Owner : service Instance . Team Owner , Description : service Instance . Description , Plan Name : plan . Name , Plan Description : plan . Description , Custom Info : info , Tags : service Instance . Tags , } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( s Info ) } 
func service Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { service Name : = r . URL . Query ( ) . Get ( " " ) _ , err : = get Service ( service Name ) if err ! = nil { return err } contexts : = permission . Contexts For Permission ( t , permission . Perm Service Instance Read ) instances , err : = readable Instances ( t , contexts , " " , service Name ) if err ! = nil { return err } var result [ ] service . Service Instance With Info for _ , instance : = range instances { info Data , err : = instance . To Info ( ) if err ! = nil { return err } result = append ( result , info Data ) } return json . New Encoder ( w ) . Encode ( result ) } 
func service Doc ( w http . Response Writer , r * http . Request , t auth . Token ) error { service Name : = r . URL . Query ( ) . Get ( " " ) s , err : = get Service ( service Name ) if err ! = nil { return err } if s . Is Restricted { allowed : = permission . Check ( t , permission . Perm Service Read Doc , contexts For Service ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } } w . Write ( [ ] byte ( s . Doc ) ) return nil } 
func service Plans ( w http . Response Writer , r * http . Request , t auth . Token ) error { service Name : = r . URL . Query ( ) . Get ( " " ) s , err : = get Service ( service Name ) if err ! = nil { return err } if s . Is Restricted { allowed : = permission . Check ( t , permission . Perm Service Read Plans , contexts For Service ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } } request ID : = request IDHeader ( r ) plans , err : = service . Get Plans By Service ( s , request ID ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( plans ) } 
func service Instance Proxy ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { service Name : = r . URL . Query ( ) . Get ( " " ) instance Name : = r . URL . Query ( ) . Get ( " " ) service Instance , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Update Proxy , contexts For Service Instance ( service Instance , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } path : = r . URL . Query ( ) . Get ( " " ) var evt * event . Event if r . Method ! = http . Method Get & & r . Method ! = http . Method Head { evt , err = event . New ( & event . Opts { Target : service Instance Target ( service Name , instance Name ) , Kind : permission . Perm Service Instance Update Proxy , Owner : t , Custom Data : append ( event . Form To Custom Data ( Input Fields ( r ) ) , map [ string ] interface { } { " " : " " , " " : r . Method , } ) , Allowed : event . Allowed ( permission . Perm Service Instance Read Events , contexts For Service Instance ( service Instance , service Name ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) } return service . Proxy Instance ( service Instance , path , evt , request IDHeader ( r ) , w , r ) } 
func service Instance Grant Team ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { instance Name : = r . URL . Query ( ) . Get ( " " ) service Name : = r . URL . Query ( ) . Get ( " " ) service Instance , err : = get Service Instance Or Error ( service Name , instance Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Update Grant , contexts For Service Instance ( service Instance , service Name ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : service Instance Target ( service Name , instance Name ) , Kind : permission . Perm Service Instance Update Grant , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Service Instance Read Events , contexts For Service Instance ( service Instance , service Name ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) team Name : = r . URL . Query ( ) . Get ( " " ) return service Instance . Grant ( team Name ) } 
func Register ( s Shutdownable ) { lock . Lock ( ) defer lock . Unlock ( ) registered = append ( registered , s ) } 
func Do ( ctx context . Context , w io . Writer ) error { lock . Lock ( ) defer lock . Unlock ( ) done : = make ( chan bool ) wg : = sync . Wait Group { } for _ , h : = range registered { wg . Add ( 1 ) go func ( h Shutdownable ) { defer wg . Done ( ) var name string if _ , ok : = h . ( fmt . Stringer ) ; ok { name = fmt . Sprintf ( " " , h ) } else { name = fmt . Sprintf ( " " , h ) } fmt . Fprintf ( w , " \n " , name ) err : = h . Shutdown ( ctx ) if err ! = nil { fmt . Fprintf ( w , " " , name , err ) return } fmt . Fprintf ( w , " \n " , name ) } ( h ) } go func ( ) { wg . Wait ( ) close ( done ) } ( ) select { case < - ctx . Done ( ) : return ctx . Err ( ) case < - done : } return nil } 
func ( s * platform Image Service ) List Images Or Default ( platform Name string ) ( [ ] string , error ) { imgs , err : = s . List Images ( platform Name ) if err ! = nil & & err = = image Types . Err Platform Image Not Found { return [ ] string { platform Basic Image Name ( platform Name ) } , nil } return imgs , err } 
func ( c * endpoint Client ) Info ( instance * Service Instance , request ID string ) ( [ ] map [ string ] string , error ) { log . Debugf ( " " , instance . Name , instance . Service Name ) url : = " " + instance . Get Identifier ( ) resp , err : = c . issue Request ( url , " " , nil , request ID ) if err ! = nil { return nil , err } defer resp . Body . Close ( ) if resp . Status Code ! = http . Status OK { return nil , nil } result : = [ ] map [ string ] string { } err = c . json From Response ( resp , & result ) if err ! = nil { return nil , err } return result , nil } 
func ( c * endpoint Client ) Plans ( request ID string ) ( [ ] Plan , error ) { url : = " " resp , err : = c . issue Request ( url , " " , nil , request ID ) if err ! = nil { return nil , err } defer resp . Body . Close ( ) if resp . Status Code ! = http . Status OK { return nil , nil } result : = [ ] Plan { } err = c . json From Response ( resp , & result ) if err ! = nil { return nil , err } return result , nil } 
func ( c * endpoint Client ) Proxy ( path string , evt * event . Event , request ID string , w http . Response Writer , r * http . Request ) error { rawurl : = strings . Trim Right ( c . endpoint , " " ) + " " + strings . Trim ( path , " " ) url , err : = url . Parse ( rawurl ) if err ! = nil { log . Errorf ( " " , rawurl , err ) return err } director : = func ( req * http . Request ) { if evt ! = nil { req . Header . Set ( " " , evt . Owner . Name ) req . Header . Set ( " " , evt . Unique ID . Hex ( ) ) } request IDHeader , err : = config . Get String ( " " ) if err = = nil & & request ID ! = " " & & request IDHeader ! = " " { req . Header . Set ( request IDHeader , request ID ) } req . Set Basic Auth ( c . username , c . password ) req . Host = url . Host req . URL = url } proxy : = & httputil . Reverse Proxy { Director : director } proxy . Serve HTTP ( w , r ) return nil } 
func Migrate Apps CRDs ( ) error { config . Set ( " " , false ) defer config . Unset ( " " ) prov : = kubernetes . Get Provisioner ( ) pools , err : = pool . List All Pools ( ) if err ! = nil { return errors . Wrap ( err , " " ) } var kube Pools [ ] string for _ , p : = range pools { if p . Provisioner = = prov . Get Name ( ) { kube Pools = append ( kube Pools , p . Name ) } } apps , err : = app . List ( & app . Filter { Pools : kube Pools } ) if err ! = nil { return errors . Wrap ( err , " " ) } multi Err : = tsuruerrors . New Multi Error ( ) for _ , a : = range apps { err Prov : = prov . Provision ( & a ) if err Prov ! = nil { multi Err . Add ( err Prov ) } } return multi Err . To Error ( ) } 
func Register ( name string , fn Migrate Func ) error { return register ( name , false , fn ) } 
func Register Optional ( name string , fn Migrate Func ) error { return register ( name , true , fn ) } 
func Run ( args Run Args ) error { if args . Name ! = " " { return run Optional ( args ) } if args . Force { return Err Cannot Force Mandatory } return run ( args ) } 
func ( app * App ) Units ( ) ( [ ] provision . Unit , error ) { prov , err : = app . get Provisioner ( ) if err ! = nil { return [ ] provision . Unit { } , err } units , err : = prov . Units ( app ) if units = = nil { } return units , err } 
func ( app * App ) Marshal JSON ( ) ( [ ] byte , error ) { repo , _ : = repository . Manager ( ) . Get Repository ( app . Name ) result : = make ( map [ string ] interface { } ) result [ " " ] = app . Name result [ " " ] = app . Platform if version : = app . Get Platform Version ( ) ; version ! = " " { result [ " " ] = fmt . Sprintf ( " " , app . Platform , version ) } result [ " " ] = app . Teams units , err : = app . Units ( ) result [ " " ] = units var err Msgs [ ] string if err ! = nil { err Msgs = append ( err Msgs , fmt . Sprintf ( " " , err ) ) } result [ " " ] = repo . Read Write URL plan : = map [ string ] interface { } { " " : app . Plan . Name , " " : app . Plan . Memory , " " : app . Plan . Swap , " " : app . Plan . Cpu Share , } routers , err : = app . Get Routers With Addr ( ) if err ! = nil { err Msgs = append ( err Msgs , fmt . Sprintf ( " " , err ) ) } if len ( routers ) > 0 { result [ " " ] = routers [ 0 ] . Address plan [ " " ] = routers [ 0 ] . Name result [ " " ] = routers [ 0 ] . Name result [ " " ] = routers [ 0 ] . Opts } result [ " " ] = app . CName result [ " " ] = app . Owner result [ " " ] = app . Pool result [ " " ] = app . Description result [ " " ] = app . Deploys result [ " " ] = app . Team Owner result [ " " ] = plan result [ " " ] = app . Lock result [ " " ] = app . Tags result [ " " ] = routers if len ( err Msgs ) > 0 { result [ " " ] = strings . Join ( err Msgs , " \n " ) } return json . Marshal ( & result ) } 
func Acquire Application Lock ( app Name string , owner string , reason string ) ( bool , error ) { return Acquire Application Lock Wait ( app Name , owner , reason , 0 ) } 
func Acquire Application Lock Wait ( app Name string , owner string , reason string , timeout time . Duration ) ( bool , error ) { timeout Chan : = time . After ( timeout ) for { app Lock : = app Types . App Lock { Locked : true , Reason : reason , Owner : owner , Acquire Date : time . Now ( ) . In ( time . UTC ) , } conn , err : = db . Conn ( ) if err ! = nil { return false , err } err = conn . Apps ( ) . Update ( bson . M { " " : app Name , " " : bson . M { " " : [ ] interface { } { false , nil } } } , bson . M { " " : bson . M { " " : app Lock } } ) conn . Close ( ) if err = = nil { return true , nil } if err ! = mgo . Err Not Found { return false , err } select { case < - timeout Chan : return false , nil case < - time . After ( 3 0 0 * time . Millisecond ) : } } } 
func Release Application Lock ( app Name string ) { var err error retries : = 3 for i : = 0 ; i < retries ; i + + { err = release Application Lock Once ( app Name ) if err = = nil { return } time . Sleep ( time . Second * time . Duration ( i + 1 ) ) } log . Error ( err ) } 
func Get By Name ( name string ) ( * App , error ) { var app App conn , err : = db . Conn ( ) if err ! = nil { return nil , err } defer conn . Close ( ) err = conn . Apps ( ) . Find ( bson . M { " " : name } ) . One ( & app ) if err = = mgo . Err Not Found { return nil , app Types . Err App Not Found } return & app , err } 
func Create App ( app * App , user * auth . User ) error { if _ , err : = Get By Name ( app . Get Name ( ) ) ; err ! = app Types . Err App Not Found { if err ! = nil { return errors . With Message ( err , " " ) } return & app Types . App Creation Error { Err : Err App Already Exists , App : app . Get Name ( ) } } var plan * app Types . Plan var err error if app . Plan . Name = = " " { plan , err = servicemanager . Plan . Default Plan ( ) } else { plan , err = servicemanager . Plan . Find By Name ( app . Plan . Name ) } if err ! = nil { return err } app . Plan = * plan err = app . Set Pool ( ) if err ! = nil { return err } err = app . configure Create Routers ( ) if err ! = nil { return err } app . Teams = [ ] string { app . Team Owner } app . Owner = user . Email app . Tags = process Tags ( app . Tags ) if app . Platform ! = " " { app . Platform , app . Platform Version , err = get Platform Name And Version ( app . Platform ) if err ! = nil { return err } } err = app . validate New ( ) if err ! = nil { return err } actions : = [ ] * action . Action { & reserve User App , & insert App , & create App Token , & export Environments Action , & create Repository , & provision App , & add Router Backend , } pipeline : = action . New Pipeline ( actions . . . ) err = pipeline . Execute ( app , user ) if err ! = nil { return & app Types . App Creation Error { App : app . Name , Err : err } } return nil } 
func ( app * App ) Update ( update Data App , w io . Writer ) ( err error ) { description : = update Data . Description plan Name : = update Data . Plan . Name pool Name : = update Data . Pool team Owner : = update Data . Team Owner platform : = update Data . Platform tags : = process Tags ( update Data . Tags ) old App : = * app if description ! = " " { app . Description = description } if pool Name ! = " " { app . Pool = pool Name app . provisioner = nil _ , err = app . get Pool For App ( app . Pool ) if err ! = nil { return err } } new Prov , err : = app . get Provisioner ( ) if err ! = nil { return err } old Prov , err : = old App . get Provisioner ( ) if err ! = nil { return err } if plan Name ! = " " { plan , err Find : = servicemanager . Plan . Find By Name ( plan Name ) if err Find ! = nil { return err Find } app . Plan = * plan } if team Owner ! = " " { team , err Team : = servicemanager . Team . Find By Name ( team Owner ) if err Team ! = nil { return err Team } app . Team Owner = team . Name defer func ( ) { if err = = nil { app . Grant ( team ) } } ( ) } if tags ! = nil { app . Tags = tags } if platform ! = " " { var p , v string p , v , err = get Platform Name And Version ( platform ) if err ! = nil { return err } if app . Platform ! = p | | app . Platform Version ! = v { app . Update Platform = true } app . Platform = p app . Platform Version = v } if update Data . Update Platform { app . Update Platform = true } err = app . validate ( ) if err ! = nil { return err } actions : = [ ] * action . Action { & save App , } if new Prov . Get Name ( ) = = old Prov . Get Name ( ) { actions = append ( actions , & update App Provisioner ) } if new Prov . Get Name ( ) ! = old Prov . Get Name ( ) { defer func ( ) { rebuild . Routes Rebuild Or Enqueue ( app . Name ) } ( ) err = validate Volumes ( app ) if err ! = nil { return err } actions = append ( actions , & provision App New Provisioner , & provision App Add Units , & destroy App Old Provisioner ) } else if app . Plan ! = old App . Plan { actions = append ( actions , & restart App ) } return action . New Pipeline ( actions . . . ) . Execute ( app , & old App , w ) } 
func ( app * App ) unbind ( evt * event . Event , request ID string ) error { instances , err : = service . Get Service Instances Bound To App ( app . Name ) if err ! = nil { return err } var msg string var add Msg = func ( instance Name string , reason error ) { if msg = = " " { msg = " \n " } msg + = fmt . Sprintf ( " " , instance Name , reason . Error ( ) ) } for _ , instance : = range instances { err = instance . Unbind App ( service . Unbind App Args { App : app , Restart : false , Force Remove : true , Event : evt , Request ID : request ID , } ) if err ! = nil { add Msg ( instance . Name , err ) } } if msg ! = " " { return errors . New ( msg ) } return nil } 
func Delete ( app * App , evt * event . Event , request ID string ) error { w : = evt is Swapped , swapped With , err : = router . Is Swapped ( app . Get Name ( ) ) if err ! = nil { return errors . Wrap ( err , " " ) } if is Swapped { return errors . Errorf ( " " , swapped With ) } app Name : = app . Name fmt . Fprintf ( w , " \n " , app Name ) var has Errors bool defer func ( ) { var problems string if has Errors { problems = " " } fmt . Fprintf ( w , " \n " , problems ) } ( ) log Err : = func ( msg string , err error ) { msg = fmt . Sprintf ( " " , msg , err ) fmt . Fprintf ( w , " \n " , msg ) log . Errorf ( " " , app Name , msg ) has Errors = true } prov , err : = app . get Provisioner ( ) if err ! = nil { return err } err = prov . Destroy ( app ) if err ! = nil { log Err ( " " , err ) } err = registry . Remove App Images ( app Name ) if err ! = nil { log . Errorf ( " " , app Name , err ) } if clean Prov , ok : = prov . ( provision . Clean Image Provisioner ) ; ok { var imgs [ ] string imgs , err = image . List App Images ( app Name ) if err ! = nil { log . Errorf ( " " , app Name , err ) } var imgs Build [ ] string imgs Build , err = image . List App Builder Images ( app Name ) if err ! = nil { log . Errorf ( " " , app Name , err ) } for _ , img : = range append ( imgs , imgs Build . . . ) { err = clean Prov . Clean Image ( app Name , img ) if err ! = nil { log . Errorf ( " " , app Name , err ) } } } err = image . Delete All App Image Names ( app Name ) if err ! = nil { log . Errorf ( " " , app Name , err ) } err = app . unbind ( evt , request ID ) if err ! = nil { log Err ( " " , err ) } routers : = app . Get Routers ( ) for _ , app Router : = range routers { var r router . Router r , err = router . Get ( app Router . Name ) if err = = nil { err = r . Remove Backend ( app . Name ) } if err ! = nil { log Err ( " " , err ) } } err = router . Remove ( app . Name ) if err ! = nil { log Err ( " " , err ) } err = app . unbind Volumes ( ) if err ! = nil { log Err ( " " , err ) } err = repository . Manager ( ) . Remove Repository ( app Name ) if err ! = nil { log Err ( " " , err ) } token : = app . Env [ " " ] . Value err = Auth Scheme . App Logout ( token ) if err ! = nil { log Err ( " " , err ) } owner , err : = auth . Get User By Email ( app . Owner ) if err = = nil { err = servicemanager . User Quota . Inc ( owner . Email , - 1 ) } if err ! = nil { log Err ( " " , err ) } log Conn , err : = db . Log Conn ( ) if err = = nil { defer log Conn . Close ( ) err = log Conn . App Log Collection ( app Name ) . Drop Collection ( ) } if err ! = nil { log Err ( " " , err ) } conn , err : = db . Conn ( ) if err = = nil { defer conn . Close ( ) err = conn . Apps ( ) . Remove ( bson . M { " " : app Name } ) } if err ! = nil { log Err ( " " , err ) } err = event . Mark As Removed ( event . Target { Type : event . Target Type App , Value : app Name } ) if err ! = nil { log Err ( " " , err ) } return nil } 
func ( app * App ) Add Units ( n uint , process string , w io . Writer ) error { if n = = 0 { return errors . New ( " " ) } units , err : = app . Units ( ) if err ! = nil { return err } for _ , u : = range units { if ( u . Status = = provision . Status Asleep ) | | ( u . Status = = provision . Status Stopped ) { return errors . New ( " " ) } } w = app . with Log Writer ( w ) err = action . New Pipeline ( & reserve Units To Add , & provision Add Units , ) . Execute ( app , n , w , process ) rebuild . Routes Rebuild Or Enqueue ( app . Name ) quota Err : = app . fix Quota ( ) if err ! = nil { return err } return quota Err } 
func ( app * App ) Remove Units ( n uint , process string , w io . Writer ) error { prov , err : = app . get Provisioner ( ) if err ! = nil { return err } w = app . with Log Writer ( w ) err = prov . Remove Units ( app , n , process , w ) rebuild . Routes Rebuild Or Enqueue ( app . Name ) quota Err : = app . fix Quota ( ) if err ! = nil { return err } return quota Err } 
func ( app * App ) Set Unit Status ( unit Name string , status provision . Status ) error { units , err : = app . Units ( ) if err ! = nil { return err } for _ , unit : = range units { if strings . Has Prefix ( unit . ID , unit Name ) { prov , err : = app . get Provisioner ( ) if err ! = nil { return err } unit Prov , ok : = prov . ( provision . Unit Status Provisioner ) if ! ok { return nil } return unit Prov . Set Unit Status ( unit , status ) } } return & provision . Unit Not Found Error { ID : unit Name } } 
func Update Node Status ( node Data provision . Node Status Data ) ( [ ] Update Units Result , error ) { node , find Node Err : = find Node For Node Data ( node Data ) var node Addresses [ ] string if find Node Err = = nil { node Addresses = [ ] string { node . Address ( ) } } else { node Addresses = node Data . Addrs } if healer . Healer Instance ! = nil { err : = healer . Healer Instance . Update Node Data ( node Addresses , node Data . Checks ) if err ! = nil { log . Errorf ( " " , err ) } } if find Node Err = = provision . Err Node Not Found { counter Nodes Not Found . Inc ( ) log . Errorf ( " " , node Data ) result : = make ( [ ] Update Units Result , len ( node Data . Units ) ) for i , unit Data : = range node Data . Units { result [ i ] = Update Units Result { ID : unit Data . ID , Found : false } } return result , nil } if find Node Err ! = nil { return nil , find Node Err } unit Prov , ok : = node . Provisioner ( ) . ( provision . Unit Status Provisioner ) if ! ok { return [ ] Update Units Result { } , nil } result : = make ( [ ] Update Units Result , len ( node Data . Units ) ) for i , unit Data : = range node Data . Units { unit : = provision . Unit { ID : unit Data . ID , Name : unit Data . Name } err : = unit Prov . Set Unit Status ( unit , unit Data . Status ) _ , is Not Found : = err . ( * provision . Unit Not Found Error ) if err ! = nil & & ! is Not Found { return nil , err } result [ i ] = Update Units Result { ID : unit Data . ID , Found : ! is Not Found } } return result , nil } 
func ( app * App ) available ( ) bool { units , err : = app . Units ( ) if err ! = nil { return false } for _ , unit : = range units { if unit . Available ( ) { return true } } return false } 
func ( app * App ) Grant ( team * auth Types . Team ) error { if _ , found : = app . find Team ( team ) ; found { return Err Already Have Access } app . Teams = append ( app . Teams , team . Name ) conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) if err ! = nil { return err } users , err : = auth . List Users With Permissions ( permission . Permission { Scheme : permission . Perm App Deploy , Context : permission . Context ( perm Types . Ctx Team , team . Name ) , } ) if err ! = nil { conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) return err } for _ , user : = range users { err = repository . Manager ( ) . Grant Access ( app . Name , user . Email ) if err ! = nil { conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) return err } } return nil } 
func ( app * App ) Revoke ( team * auth Types . Team ) error { if len ( app . Teams ) = = 1 { return Err Cannot Orphan App } index , found : = app . find Team ( team ) if ! found { return Err No Access } last : = len ( app . Teams ) - 1 app . Teams [ index ] = app . Teams [ last ] app . Teams = app . Teams [ : last ] conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) if err ! = nil { return err } users , err : = auth . List Users With Permissions ( permission . Permission { Scheme : permission . Perm App Deploy , Context : permission . Context ( perm Types . Ctx Team , team . Name ) , } ) if err ! = nil { conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) return err } for _ , user : = range users { perms , err : = user . Permissions ( ) if err ! = nil { conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) return err } can Deploy : = permission . Check From Perm List ( perms , permission . Perm App Deploy , append ( permission . Contexts ( perm Types . Ctx Team , app . Teams ) , permission . Context ( perm Types . Ctx App , app . Name ) , permission . Context ( perm Types . Ctx Pool , app . Pool ) , ) . . . , ) if can Deploy { continue } err = repository . Manager ( ) . Revoke Access ( app . Name , user . Email ) if err ! = nil { conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : team . Name } } ) return err } } return nil } 
func ( app * App ) Get Teams ( ) [ ] auth Types . Team { t , _ : = servicemanager . Team . Find By Names ( app . Teams ) return t } 
func ( app * App ) set Env ( env bind . Env Var ) { if app . Env = = nil { app . Env = make ( map [ string ] bind . Env Var ) } app . Env [ env . Name ] = env if env . Public { app . Log ( fmt . Sprintf ( " " , env . Name , env . Value ) , " " , " " ) } } 
func ( app * App ) get Env ( name string ) ( bind . Env Var , error ) { if env , ok : = app . Env [ name ] ; ok { return env , nil } return bind . Env Var { } , errors . New ( " " ) } 
func ( app * App ) validate New ( ) error { if app . Name = = Internal App Name | | ! validation . Validate Name ( app . Name ) { msg : = " " + " " + " " return & tsuru Errors . Validation Error { Message : msg } } return app . validate ( ) } 
func ( app * App ) validate ( ) error { err : = app . validate Pool ( ) if err ! = nil { return err } return app . validate Plan ( ) } 
func ( app * App ) Instance Envs ( service Name , instance Name string ) map [ string ] bind . Env Var { envs : = make ( map [ string ] bind . Env Var ) for _ , env : = range app . Service Envs { if env . Service Name = = service Name & & env . Instance Name = = instance Name { envs [ env . Name ] = env . Env Var } } return envs } 
func ( app * App ) Run ( cmd string , w io . Writer , args provision . Run Args ) error { if ! args . Isolated & & ! app . available ( ) { return errors . New ( " " ) } app . Log ( fmt . Sprintf ( " " , cmd ) , " " , " " ) log Writer : = Log Writer { App : app , Source : " " } log Writer . Async ( ) defer log Writer . Close ( ) return app . run ( cmd , io . Multi Writer ( w , & log Writer ) , args ) } 
func ( app * App ) Get Units ( ) ( [ ] bind . Unit , error ) { prov Units , err : = app . Units ( ) if err ! = nil { return nil , err } units : = make ( [ ] bind . Unit , len ( prov Units ) ) for i : = range prov Units { units [ i ] = & prov Units [ i ] } return units , nil } 
func ( app * App ) Get UUID ( ) ( string , error ) { if app . UUID ! = " " { return app . UUID , nil } uuid V 4 , err : = uuid . New V 4 ( ) if err ! = nil { return " " , errors . With Message ( err , " " ) } conn , err : = db . Conn ( ) if err ! = nil { return " " , err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : uuid V 4 . String ( ) } } ) if err ! = nil { return " " , err } app . UUID = uuid V 4 . String ( ) return app . UUID , nil } 
func ( app * App ) Envs ( ) map [ string ] bind . Env Var { merged Envs : = make ( map [ string ] bind . Env Var , len ( app . Env ) + len ( app . Service Envs ) + 1 ) for _ , e : = range app . Env { merged Envs [ e . Name ] = e } for _ , e : = range app . Service Envs { merged Envs [ e . Name ] = e . Env Var } merged Envs [ Tsuru Services Env Var ] = service Envs From Env Vars ( app . Service Envs ) return merged Envs } 
func ( app * App ) Set Envs ( set Envs bind . Set Env Args ) error { if len ( set Envs . Envs ) = = 0 { return nil } for _ , env : = range set Envs . Envs { err : = validate Env ( env . Name ) if err ! = nil { return err } } if set Envs . Writer ! = nil { fmt . Fprintf ( set Envs . Writer , " \n " , len ( set Envs . Envs ) ) } for _ , env : = range set Envs . Envs { app . set Env ( env ) } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : app . Env } } ) if err ! = nil { return err } if set Envs . Should Restart { return app . restart If Units ( set Envs . Writer ) } return nil } 
func ( app * App ) Unset Envs ( unset Envs bind . Unset Env Args ) error { if len ( unset Envs . Variable Names ) = = 0 { return nil } if unset Envs . Writer ! = nil { fmt . Fprintf ( unset Envs . Writer , " \n " , len ( unset Envs . Variable Names ) ) } for _ , name : = range unset Envs . Variable Names { delete ( app . Env , name ) } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) err = conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : app . Env } } ) if err ! = nil { return err } if unset Envs . Should Restart { return app . restart If Units ( unset Envs . Writer ) } return nil } 
func ( app * App ) Add CName ( cnames . . . string ) error { actions : = [ ] * action . Action { & validate New CNames , & set New CNames To Provisioner , & save CNames , & update App , } err : = action . New Pipeline ( actions . . . ) . Execute ( app , cnames ) rebuild . Routes Rebuild Or Enqueue ( app . Name ) return err } 
func ( app * App ) Log ( message , source , unit string ) error { messages : = strings . Split ( message , " \n " ) logs : = make ( [ ] interface { } , 0 , len ( messages ) ) for _ , msg : = range messages { if msg ! = " " { l : = Applog { Date : time . Now ( ) . In ( time . UTC ) , Message : msg , Source : source , App Name : app . Name , Unit : unit , } logs = append ( logs , l ) } } if len ( logs ) > 0 { conn , err : = db . Log Conn ( ) if err ! = nil { return err } defer conn . Close ( ) return conn . App Log Collection ( app . Name ) . Insert ( logs . . . ) } return nil } 
func ( app * App ) Last Logs ( lines int , filter Log Applog ) ( [ ] Applog , error ) { return app . last Logs ( lines , filter Log , false ) } 
func List ( filter * Filter ) ( [ ] App , error ) { apps : = [ ] App { } query : = filter . Query ( ) conn , err : = db . Conn ( ) if err ! = nil { return nil , err } err = conn . Apps ( ) . Find ( query ) . All ( & apps ) conn . Close ( ) if err ! = nil { return nil , err } if filter ! = nil & & len ( filter . Statuses ) > 0 { apps Provisioner Map : = make ( map [ string ] [ ] provision . App ) var prov provision . Provisioner for i : = range apps { a : = & apps [ i ] prov , err = a . get Provisioner ( ) if err ! = nil { return nil , err } apps Provisioner Map [ prov . Get Name ( ) ] = append ( apps Provisioner Map [ prov . Get Name ( ) ] , a ) } var provision Apps [ ] provision . App for prov Name , apps : = range apps Provisioner Map { prov , err = provision . Get ( prov Name ) if err ! = nil { return nil , err } if filter Prov , ok : = prov . ( provision . App Filter Provisioner ) ; ok { apps , err = filter Prov . Filter Apps By Unit Status ( apps , filter . Statuses ) if err ! = nil { return nil , err } } provision Apps = append ( provision Apps , apps . . . ) } for i : = range provision Apps { apps [ i ] = * ( provision Apps [ i ] . ( * App ) ) } apps = apps [ : len ( provision Apps ) ] } err = load Cached Addrs In Apps ( apps ) if err ! = nil { return nil , err } return apps , nil } 
func Swap ( app 1 , app 2 * App , cname Only bool ) error { a 1Routers : = app 1 . Get Routers ( ) a 2Routers : = app 2 . Get Routers ( ) if len ( a 1Routers ) ! = 1 | | len ( a 2Routers ) ! = 1 { return errors . New ( " " ) } r 1 , err : = router . Get ( a 1Routers [ 0 ] . Name ) if err ! = nil { return err } r 2 , err : = router . Get ( a 2Routers [ 0 ] . Name ) if err ! = nil { return err } defer func ( app 1 , app 2 * App ) { rebuild . Routes Rebuild Or Enqueue ( app 1 . Name ) rebuild . Routes Rebuild Or Enqueue ( app 2 . Name ) app 1 . Get Routers With Addr ( ) app 2 . Get Routers With Addr ( ) } ( app 1 , app 2 ) err = r 1 . Swap ( app 1 . Name , app 2 . Name , cname Only ) if err ! = nil { return err } conn , err : = db . Conn ( ) if err ! = nil { return err } defer conn . Close ( ) app 1 . CName , app 2 . CName = app 2 . CName , app 1 . CName update CName : = func ( app * App , r router . Router ) error { return conn . Apps ( ) . Update ( bson . M { " " : app . Name } , bson . M { " " : bson . M { " " : app . CName } } , ) } err = update CName ( app 1 , r 1 ) if err ! = nil { return err } return update CName ( app 2 , r 2 ) } 
func ( app * App ) Start ( w io . Writer , process string ) error { w = app . with Log Writer ( w ) msg : = fmt . Sprintf ( " \n " , process ) if process = = " " { msg = fmt . Sprintf ( " \n " , app . Name ) } fmt . Fprintf ( w , " \n " , msg ) prov , err : = app . get Provisioner ( ) if err ! = nil { return err } err = prov . Start ( app , process ) if err ! = nil { log . Errorf ( " " , app . Name , err ) return err } rebuild . Routes Rebuild Or Enqueue ( app . Name ) return err } 
func Get Db Driver ( name string ) ( * Db Driver , error ) { driver , ok : = db Drivers [ name ] if ! ok { return nil , errors . Errorf ( " " , name ) } return & driver , nil } 
func Get Current Db Driver ( ) ( * Db Driver , error ) { driver Lock . RLock ( ) if current Db Driver ! = nil { driver Lock . RUnlock ( ) return current Db Driver , nil } driver Lock . RUnlock ( ) driver Lock . Lock ( ) defer driver Lock . Unlock ( ) if current Db Driver ! = nil { return current Db Driver , nil } db Driver Name , err : = config . Get String ( " " ) if err ! = nil | | db Driver Name = = " " { db Driver Name = Default Db Driver Name } current Db Driver , err = Get Db Driver ( db Driver Name ) if err ! = nil { return nil , err } return current Db Driver , nil } 
func info ( w http . Response Writer , r * http . Request ) error { data : = map [ string ] string { } data [ " " ] = Version w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( data ) } 
func Proxy ( service * Service , path string , evt * event . Event , request ID string , w http . Response Writer , r * http . Request ) error { endpoint , err : = service . get Client ( " " ) if err ! = nil { return err } return endpoint . Proxy ( path , evt , request ID , w , r ) } 
func app Delete ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } can Delete : = permission . Check ( t , permission . Perm App Delete , contexts For App ( & a ) . . . , ) if ! can Delete { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( a . Name ) , Kind : permission . Perm App Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) w . Header ( ) . Set ( " " , " " ) return app . Delete ( & a , evt , request IDHeader ( r ) ) } 
func app List ( w http . Response Writer , r * http . Request , t auth . Token ) error { filter : = & app . Filter { } if name : = r . URL . Query ( ) . Get ( " " ) ; name ! = " " { filter . Name Matches = name } if platform : = r . URL . Query ( ) . Get ( " " ) ; platform ! = " " { filter . Platform = platform } if team Owner : = r . URL . Query ( ) . Get ( " " ) ; team Owner ! = " " { filter . Team Owner = team Owner } if owner : = r . URL . Query ( ) . Get ( " " ) ; owner ! = " " { filter . User Owner = owner } if pool : = r . URL . Query ( ) . Get ( " " ) ; pool ! = " " { filter . Pool = pool } locked , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) if locked { filter . Locked = true } if status , ok : = r . URL . Query ( ) [ " " ] ; ok { filter . Statuses = status } if tags , ok : = r . URL . Query ( ) [ " " ] ; ok { filter . Tags = tags } contexts : = permission . Contexts For Permission ( t , permission . Perm App Read ) if len ( contexts ) = = 0 { w . Write Header ( http . Status No Content ) return nil } apps , err : = app . List ( app Filter By Context ( contexts , filter ) ) if err ! = nil { return err } if len ( apps ) = = 0 { w . Write Header ( http . Status No Content ) return nil } simple , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) w . Header ( ) . Set ( " " , " " ) mini Apps : = make ( [ ] mini App , len ( apps ) ) if simple { for i , ap : = range apps { ur : = app . App Units Response { Units : nil , Err : nil } mini Apps [ i ] , err = minify App ( ap , ur ) if err ! = nil { return err } } return json . New Encoder ( w ) . Encode ( mini Apps ) } app Units , err : = app . Units ( apps ) if err ! = nil { return err } for i , app : = range apps { mini Apps [ i ] , err = minify App ( app , app Units [ app . Name ] ) if err ! = nil { return err } } return json . New Encoder ( w ) . Encode ( mini Apps ) } 
func app Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } can Read : = permission . Check ( t , permission . Perm App Read , contexts For App ( & a ) . . . , ) if ! can Read { return permission . Err Unauthorized } err = a . Fill Internal Addresses ( r . Context ( ) ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( & a ) } 
func create App ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var ia input App err = Parse Input ( r , & ia ) if err ! = nil { return err } a : = app . App { Team Owner : ia . Team Owner , Platform : ia . Platform , Plan : app Types . Plan { Name : ia . Plan } , Name : ia . Name , Description : ia . Description , Pool : ia . Pool , Router Opts : ia . Router Opts , Router : ia . Router , Tags : ia . Tags , Quota : quota . Unlimited Quota , } tags , _ : = Input Values ( r , " " ) a . Tags = append ( a . Tags , tags . . . ) if a . Team Owner = = " " { a . Team Owner , err = auto Team Owner ( t , permission . Perm App Create ) if err ! = nil { return err } } can Create : = permission . Check ( t , permission . Perm App Create , permission . Context ( perm Types . Ctx Team , a . Team Owner ) , ) if ! can Create { return permission . Err Unauthorized } u , err : = auth . Convert New User ( t . User ( ) ) if err ! = nil { return err } if a . Platform ! = " " { repo , _ : = image . Split Image Name ( a . Platform ) platform , err Plat : = servicemanager . Platform . Find By Name ( repo ) if err Plat ! = nil { return err Plat } if platform . Disabled { can Use Plat : = permission . Check ( t , permission . Perm Platform Update ) | | permission . Check ( t , permission . Perm Platform Create ) if ! can Use Plat { return & errors . HTTP { Code : http . Status Bad Request , Message : app Types . Err Invalid Platform . Error ( ) } } } } evt , err : = event . New ( & event . Opts { Target : app Target ( a . Name ) , Kind : permission . Perm App Create , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = app . Create App ( & a , u ) if err ! = nil { log . Errorf ( " " , err ) if _ , ok : = err . ( app Types . No Teams Error ) ; ok { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } if e , ok : = err . ( * app Types . App Creation Error ) ; ok { if e . Err = = app . Err App Already Exists { return & errors . HTTP { Code : http . Status Conflict , Message : e . Error ( ) } } if _ , ok : = e . Err . ( * quota . Quota Exceeded Error ) ; ok { return & errors . HTTP { Code : http . Status Forbidden , Message : " " , } } } if err = = app Types . Err Invalid Platform { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } repo , err : = repository . Manager ( ) . Get Repository ( a . Name ) if err ! = nil { return err } msg : = map [ string ] interface { } { " " : " " , " " : repo . Read Write URL , } addrs , err : = a . Get Addresses ( ) if err ! = nil { return err } if len ( addrs ) > 0 { msg [ " " ] = addrs [ 0 ] } json Msg , err : = json . Marshal ( msg ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) w . Write Header ( http . Status Created ) w . Write ( json Msg ) return nil } 
func update App ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var ia input App err = Parse Input ( r , & ia ) if err ! = nil { return err } image Reset , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) update Data : = app . App { Team Owner : ia . Team Owner , Plan : app Types . Plan { Name : ia . Plan } , Pool : ia . Pool , Description : ia . Description , Router : ia . Router , Tags : ia . Tags , Platform : Input Value ( r , " " ) , Update Platform : image Reset , Router Opts : ia . Router Opts , } tags , _ : = Input Values ( r , " " ) update Data . Tags = append ( update Data . Tags , tags . . . ) app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } var wanted Perms [ ] * permission . Permission Scheme if update Data . Router ! = " " | | len ( update Data . Router Opts ) > 0 { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } if update Data . Description ! = " " { wanted Perms = append ( wanted Perms , permission . Perm App Update Description ) } if len ( update Data . Tags ) > 0 { wanted Perms = append ( wanted Perms , permission . Perm App Update Tags ) } if update Data . Plan . Name ! = " " { wanted Perms = append ( wanted Perms , permission . Perm App Update Plan ) } if update Data . Pool ! = " " { wanted Perms = append ( wanted Perms , permission . Perm App Update Pool ) } if update Data . Team Owner ! = " " { wanted Perms = append ( wanted Perms , permission . Perm App Update Teamowner ) } if update Data . Platform ! = " " { repo , _ : = image . Split Image Name ( update Data . Platform ) platform , err Plat : = servicemanager . Platform . Find By Name ( repo ) if err Plat ! = nil { return err Plat } if platform . Disabled { can Use Plat : = permission . Check ( t , permission . Perm Platform Update ) | | permission . Check ( t , permission . Perm Platform Create ) if ! can Use Plat { return & errors . HTTP { Code : http . Status Bad Request , Message : app Types . Err Invalid Platform . Error ( ) } } } wanted Perms = append ( wanted Perms , permission . Perm App Update Platform ) update Data . Update Platform = true } if update Data . Update Platform { wanted Perms = append ( wanted Perms , permission . Perm App Update Image Reset ) } if len ( wanted Perms ) = = 0 { msg : = " " return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } for _ , perm : = range wanted Perms { allowed : = permission . Check ( t , perm , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) w . Header ( ) . Set ( " " , " " ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) err = a . Update ( update Data , evt ) if err = = app Types . Err Plan Not Found { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } if _ , ok : = err . ( * router . Err Router Not Found ) ; ok { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } 
func set Unit Status ( w http . Response Writer , r * http . Request , t auth . Token ) error { unit Name : = r . URL . Query ( ) . Get ( " " ) if unit Name = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " , } } post Status : = Input Value ( r , " " ) status , err : = provision . Parse Status ( post Status ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = app . Get By Name ( app Name ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } allowed : = permission . Check ( t , permission . Perm App Update Unit Status , contexts For App ( a ) . . . , ) if ! allowed { return permission . Err Unauthorized } err = a . Set Unit Status ( unit Name , status ) if _ , ok : = err . ( * provision . Unit Not Found Error ) ; ok { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } 
func set Node Status ( w http . Response Writer , r * http . Request , t auth . Token ) error { if t . Get App Name ( ) ! = app . Internal App Name { return & errors . HTTP { Code : http . Status Forbidden , Message : " " } } var host Input provision . Node Status Data err : = Parse Input ( r , & host Input ) if err ! = nil { return err } result , err : = app . Update Node Status ( host Input ) if err ! = nil { if err = = provision . Err Node Not Found { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } w . Header ( ) . Add ( " " , " " ) return json . New Encoder ( w ) . Encode ( result ) } 
func grant App Access ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app Name : = r . URL . Query ( ) . Get ( " " ) team Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Grant , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Grant , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) team , err : = servicemanager . Team . Find By Name ( team Name ) if err ! = nil { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } err = a . Grant ( team ) if err = = app . Err Already Have Access { return & errors . HTTP { Code : http . Status Conflict , Message : err . Error ( ) } } return err } 
func revoke App Access ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app Name : = r . URL . Query ( ) . Get ( " " ) team Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Revoke , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Revoke , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) team , err : = servicemanager . Team . Find By Name ( team Name ) if err ! = nil | | team = = nil { return & errors . HTTP { Code : http . Status Not Found , Message : " " } } if len ( a . Teams ) = = 1 { msg : = " " return & errors . HTTP { Code : http . Status Forbidden , Message : msg } } err = a . Revoke ( team ) switch err { case app . Err No Access : return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } case app . Err Cannot Orphan App : return & errors . HTTP { Code : http . Status Forbidden , Message : err . Error ( ) } default : return err } } 
func run Command ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { msg : = " " command : = Input Value ( r , " " ) if len ( command ) < 1 { return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } app Name : = r . URL . Query ( ) . Get ( " " ) once : = Input Value ( r , " " ) isolated : = Input Value ( r , " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Run , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Run , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) once Bool , _ : = strconv . Parse Bool ( once ) isolated Bool , _ : = strconv . Parse Bool ( isolated ) args : = provision . Run Args { Once : once Bool , Isolated : isolated Bool } return a . Run ( command , evt , args ) } 
func get Env ( w http . Response Writer , r * http . Request , t auth . Token ) error { var variables [ ] string if envs , ok : = r . URL . Query ( ) [ " " ] ; ok { variables = envs } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } if ! t . Is App Token ( ) { allowed : = permission . Check ( t , permission . Perm App Read Env , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } } return write Env Vars ( w , & a , variables . . . ) } 
func set Env ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var e api Types . Envs err = Parse Input ( r , & e ) if err ! = nil { return err } if len ( e . Envs ) = = 0 { msg : = " " return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Env Set , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } var to Exclude [ ] string if e . Private { for i : = 0 ; i < len ( e . Envs ) ; i + + { to Exclude = append ( to Exclude , fmt . Sprintf ( " " , i ) ) } } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Env Set , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r , to Exclude . . . ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) envs : = map [ string ] string { } variables : = [ ] bind . Env Var { } for _ , v : = range e . Envs { envs [ v . Name ] = v . Value variables = append ( variables , bind . Env Var { Name : v . Name , Value : v . Value , Public : ! e . Private } ) } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) err = a . Set Envs ( bind . Set Env Args { Envs : variables , Should Restart : ! e . No Restart , Writer : evt , } ) if v , ok : = err . ( * errors . Validation Error ) ; ok { return & errors . HTTP { Code : http . Status Bad Request , Message : v . Message } } return err } 
func unset Env ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { msg : = " " if Input Value ( r , " " ) = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } var variables [ ] string if envs , ok : = Input Values ( r , " " ) ; ok { variables = envs } else { return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Env Unset , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Env Unset , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) no Restart , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) return a . Unset Envs ( bind . Unset Env Args { Variable Names : variables , Should Restart : ! no Restart , Writer : evt , } ) } 
func set CName ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { c Name Msg : = " " cnames , _ : = Input Values ( r , " " ) if len ( cnames ) = = 0 { return & errors . HTTP { Code : http . Status Bad Request , Message : c Name Msg } } app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Cname Add , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Cname Add , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) if err = a . Add CName ( cnames . . . ) ; err = = nil { return nil } if err . Error ( ) = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } 
func app Log ( w http . Response Writer , r * http . Request , t auth . Token ) error { var err error var lines int if l : = r . URL . Query ( ) . Get ( " " ) ; l ! = " " { lines , err = strconv . Atoi ( l ) if err ! = nil { msg : = `Parameter "lines " must be an integer . ` return & errors . HTTP { Code : http . Status Bad Request , Message : msg } } } else { return & errors . HTTP { Code : http . Status Bad Request , Message : `Parameter "lines " is mandatory . ` } } w . Header ( ) . Set ( " " , " " ) source : = r . URL . Query ( ) . Get ( " " ) unit : = r . URL . Query ( ) . Get ( " " ) follow : = r . URL . Query ( ) . Get ( " " ) app Name : = r . URL . Query ( ) . Get ( " " ) filter Log : = app . Applog { Source : source , Unit : unit } a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Read Log , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } logs , err : = a . Last Logs ( lines , filter Log ) if err ! = nil { return err } encoder : = json . New Encoder ( w ) err = encoder . Encode ( logs ) if err ! = nil { return err } if follow ! = " " { return nil } close Chan : = r . Context ( ) . Done ( ) l , err : = app . New Log Listener ( & a , filter Log ) if err ! = nil { return err } log Tracker . add ( l ) defer func ( ) { log Tracker . remove ( l ) l . Close ( ) } ( ) log Chan : = l . Listen Chan ( ) for { var log Msg app . Applog var ch Open bool select { case < - close Chan : return nil case log Msg , ch Open = < - log Chan : } if ! ch Open { return nil } err : = encoder . Encode ( [ ] app . Applog { log Msg } ) if err ! = nil { break } } return nil } 
func bind Service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { instance Name : = r . URL . Query ( ) . Get ( " " ) app Name : = r . URL . Query ( ) . Get ( " " ) service Name : = r . URL . Query ( ) . Get ( " " ) req : = struct { No Restart bool Parameters service . Bind App Parameters } { } err = Parse Input ( r , & req ) if err ! = nil { return err } instance , a , err : = get Service Instance ( service Name , instance Name , app Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Update Bind , append ( permission . Contexts ( perm Types . Ctx Team , instance . Teams ) , permission . Context ( perm Types . Ctx Service Instance , instance . Name ) , ) . . . , ) if ! allowed { return permission . Err Unauthorized } allowed = permission . Check ( t , permission . Perm App Update Bind , contexts For App ( a ) . . . , ) if ! allowed { return permission . Err Unauthorized } err = a . Validate Service ( service Name ) if err ! = nil { if err = = pool . Err Pool Has No Service { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return err } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Bind , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) err = instance . Bind App ( a , req . Parameters , ! req . No Restart , evt , evt , request IDHeader ( r ) ) if err ! = nil { status , err Status : = instance . Status ( request IDHeader ( r ) ) if err Status ! = nil { return fmt . Errorf ( " " , err , err Status ) } return fmt . Errorf ( " " , err , instance Name , status ) } fmt . Fprintf ( writer , " \n \n " , instance Name , app Name ) envs : = a . Instance Envs ( service Name , instance Name ) if len ( envs ) > 0 { fmt . Fprintf ( writer , " \n \n " ) for k : = range envs { fmt . Fprintf ( writer , " \n " , k ) } fmt . Fprintf ( writer , " \n " , app . Tsuru Services Env Var ) } return nil } 
func unbind Service Instance ( w http . Response Writer , r * http . Request , t auth . Token ) error { instance Name , app Name , service Name : = r . URL . Query ( ) . Get ( " " ) , r . URL . Query ( ) . Get ( " " ) , r . URL . Query ( ) . Get ( " " ) no Restart , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) force , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) instance , a , err : = get Service Instance ( service Name , instance Name , app Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm Service Instance Update Unbind , append ( permission . Contexts ( perm Types . Ctx Team , instance . Teams ) , permission . Context ( perm Types . Ctx Service Instance , instance . Name ) , ) . . . , ) if ! allowed { return permission . Err Unauthorized } allowed = permission . Check ( t , permission . Perm App Update Unbind , contexts For App ( a ) . . . , ) if ! allowed { return permission . Err Unauthorized } if force { s , err Get : = service . Get ( instance . Service Name ) if err Get ! = nil { return err Get } allowed = permission . Check ( t , permission . Perm Service Update , contexts For Service Provision ( & s ) . . . , ) if ! allowed { return permission . Err Unauthorized } } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Unbind , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) err = instance . Unbind App ( service . Unbind App Args { App : a , Restart : ! no Restart , Force Remove : force , Event : evt , Request ID : request IDHeader ( r ) , } ) if err ! = nil { return err } fmt . Fprintf ( evt , " \n \n " , instance Name , app Name ) return nil } 
func restart ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { process : = Input Value ( r , " " ) app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Restart , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Restart , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) return a . Restart ( process , evt ) } 
func sleep ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { process : = Input Value ( r , " " ) app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } proxy : = Input Value ( r , " " ) if proxy = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } proxy URL , err : = url . Parse ( proxy ) if err ! = nil { log . Errorf ( " " , proxy ) return err } allowed : = permission . Check ( t , permission . Perm App Update Sleep , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Update Sleep , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 3 0 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) return a . Sleep ( evt , process , proxy URL ) } 
func add Log ( w http . Response Writer , r * http . Request , t auth . Token ) error { a , err : = app . Get By Name ( r . URL . Query ( ) . Get ( " " ) ) if err ! = nil { return err } if t . Get App Name ( ) ! = app . Internal App Name { allowed : = permission . Check ( t , permission . Perm App Update Log , contexts For App ( a ) . . . , ) if ! allowed { return permission . Err Unauthorized } } logs , _ : = Input Values ( r , " " ) source : = Input Value ( r , " " ) if source = = " " { source = " " } unit : = Input Value ( r , " " ) for _ , log : = range logs { err : = a . Log ( log , source , unit ) if err ! = nil { return err } } return nil } 
func swap ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app 1Name : = Input Value ( r , " " ) app 2Name : = Input Value ( r , " " ) force Swap : = Input Value ( r , " " ) cname Only , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) if force Swap = = " " { force Swap = " " } locked 1 , err : = app . Acquire Application Lock Wait ( app 1Name , t . Get User Name ( ) , " " , lock Wait Duration ) if err ! = nil { return err } defer app . Release Application Lock ( app 1Name ) locked 2 , err : = app . Acquire Application Lock Wait ( app 2Name , t . Get User Name ( ) , " " , lock Wait Duration ) if err ! = nil { return err } defer app . Release Application Lock ( app 2Name ) app 1 , err : = get App ( app 1Name ) if err ! = nil { return err } if ! locked 1 { return & errors . HTTP { Code : http . Status Conflict , Message : fmt . Sprintf ( " " , app 1 . Name , & app 1 . Lock ) } } app 2 , err : = get App ( app 2Name ) if err ! = nil { return err } if ! locked 2 { return & errors . HTTP { Code : http . Status Conflict , Message : fmt . Sprintf ( " " , app 2 . Name , & app 2 . Lock ) } } allowed 1 : = permission . Check ( t , permission . Perm App Update Swap , contexts For App ( app 1 ) . . . , ) allowed 2 : = permission . Check ( t , permission . Perm App Update Swap , contexts For App ( app 2 ) . . . , ) if ! allowed 1 | | ! allowed 2 { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app 1Name ) , Extra Targets : [ ] event . Extra Target { { Target : app Target ( app 2Name ) , Lock : true } , } , Kind : permission . Perm App Update Swap , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( app 1 ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) } app 1Units , err : = app 1 . Units ( ) if err ! = nil { return err } app 2Units , err : = app 2 . Units ( ) if err ! = nil { return err } if len ( app 1Units ) ! = len ( app 2Units ) { return & errors . HTTP { Code : http . Status Precondition Failed , Message : " " , } } } return app . Swap ( app 1 , app 2 , cname Only ) } 
func force Delete Lock ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = get App From Context ( app Name , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Admin Unlock , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : app Target ( app Name ) , Kind : permission . Perm App Admin Unlock , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) app . Release Application Lock ( a . Name ) return nil } 
func register Unit ( w http . Response Writer , r * http . Request , t auth . Token ) error { app Name : = r . URL . Query ( ) . Get ( " " ) a , err : = app . Get By Name ( app Name ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Unit Register , contexts For App ( a ) . . . , ) if ! allowed { return permission . Err Unauthorized } if is Deploy Agent UA ( r ) & & r . Header . Get ( " " ) = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : msg Error } } defer r . Body . Close ( ) data , err : = ioutil . Read All ( r . Body ) if err ! = nil { return err } val , err : = url . Parse Query ( string ( data ) ) if err ! = nil { return err } hostname : = val . Get ( " " ) var custom Data map [ string ] interface { } raw Custom Data : = val . Get ( " " ) if raw Custom Data ! = " " { err = json . Unmarshal ( [ ] byte ( raw Custom Data ) , & custom Data ) if err ! = nil { return err } } err = a . Register Unit ( hostname , custom Data ) if err ! = nil { if err , ok : = err . ( * provision . Unit Not Found Error ) ; ok { return & errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) } } return err } return write Env Vars ( w , a ) } 
func app Metric Envs ( w http . Response Writer , r * http . Request , t auth . Token ) error { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Read Metric , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) metric Map , err : = a . Metric Envs ( ) if err ! = nil { return err } return json . New Encoder ( w ) . Encode ( metric Map ) } 
func app Rebuild Routes ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Admin Routes , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } dry , _ : = strconv . Parse Bool ( Input Value ( r , " " ) ) evt , err : = event . New ( & event . Opts { Target : app Target ( a . Name ) , Kind : permission . Perm App Admin Routes , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } result : = map [ string ] rebuild . Rebuild Routes Result { } defer func ( ) { evt . Done Custom Data ( err , result ) } ( ) w . Header ( ) . Set ( " " , " " ) result , err = rebuild . Rebuild Routes ( & a , dry ) if err ! = nil { return err } return json . New Encoder ( w ) . Encode ( & result ) } 
func set Certificate ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Update Certificate Set , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } cname : = Input Value ( r , " " ) certificate : = Input Value ( r , " " ) key : = Input Value ( r , " " ) if cname = = " " { return & errors . HTTP { Code : http . Status Bad Request , Message : " " } } evt , err : = event . New ( & event . Opts { Target : app Target ( a . Name ) , Kind : permission . Perm App Update Certificate Set , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r , " " ) ) , Allowed : event . Allowed ( permission . Perm App Read Events , contexts For App ( & a ) . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = a . Set Certificate ( cname , certificate , key ) if err ! = nil { return & errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) } } return nil } 
func list Certificates ( w http . Response Writer , r * http . Request , t auth . Token ) error { a , err : = get App From Context ( r . URL . Query ( ) . Get ( " " ) , r ) if err ! = nil { return err } allowed : = permission . Check ( t , permission . Perm App Read Certificate , contexts For App ( & a ) . . . , ) if ! allowed { return permission . Err Unauthorized } w . Header ( ) . Set ( " " , " " ) result , err : = a . Get Certificates ( ) if err ! = nil { return err } return json . New Encoder ( w ) . Encode ( & result ) } 
func New For Config ( c * rest . Config ) ( * Clientset , error ) { config Shallow Copy : = * c if config Shallow Copy . Rate Limiter = = nil & & config Shallow Copy . QPS > 0 { config Shallow Copy . Rate Limiter = flowcontrol . New Token Bucket Rate Limiter ( config Shallow Copy . QPS , config Shallow Copy . Burst ) } var cs Clientset var err error cs . tsuru V 1 , err = tsuruv 1 . New For Config ( & config Shallow Copy ) if err ! = nil { return nil , err } cs . Discovery Client , err = discovery . New Discovery Client For Config ( & config Shallow Copy ) if err ! = nil { glog . Errorf ( " " , err ) return nil , err } return & cs , nil } 
func New For Config Or Die ( c * rest . Config ) * Clientset { var cs Clientset cs . tsuru V 1 = tsuruv 1 . New For Config Or Die ( c ) cs . Discovery Client = discovery . New Discovery Client For Config Or Die ( c ) return & cs } 
func New ( c rest . Interface ) * Clientset { var cs Clientset cs . tsuru V 1 = tsuruv 1 . New ( c ) cs . Discovery Client = discovery . New Discovery Client ( c ) return & cs } 
func node Container List ( w http . Response Writer , r * http . Request , t auth . Token ) error { pools , err : = permission . List Context Values ( t , permission . Perm Nodecontainer Read , true ) if err ! = nil { return err } lst , err : = nodecontainer . All Node Containers ( ) if err ! = nil { return err } if pools ! = nil { pool Map : = map [ string ] struct { } { } for _ , p : = range pools { pool Map [ p ] = struct { } { } } for i , entry : = range lst { for pool Name : = range entry . Config Pools { if pool Name = = " " { continue } if _ , ok : = pool Map [ pool Name ] ; ! ok { delete ( entry . Config Pools , pool Name ) } } lst [ i ] = entry } } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( lst ) } 
func node Container Info ( w http . Response Writer , r * http . Request , t auth . Token ) error { pools , err : = permission . List Context Values ( t , permission . Perm Nodecontainer Read , true ) if err ! = nil { return err } name : = r . URL . Query ( ) . Get ( " " ) config Map , err : = nodecontainer . Load Node Containers For Pools ( name ) if err ! = nil { if err = = nodecontainer . Err Node Container Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } return err } if pools ! = nil { pool Map : = map [ string ] struct { } { } for _ , p : = range pools { pool Map [ p ] = struct { } { } } for pool Name : = range config Map { if pool Name = = " " { continue } if _ , ok : = pool Map [ pool Name ] ; ! ok { delete ( config Map , pool Name ) } } } w . Header ( ) . Set ( " " , " " ) return json . New Encoder ( w ) . Encode ( config Map ) } 
func node Container Update ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { var config nodecontainer . Node Container Config err = Parse Input ( r , & config ) if err ! = nil { return err } pool Name : = Input Value ( r , " " ) var ctxs [ ] perm Types . Permission Context if pool Name ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , pool Name ) ) } if ! permission . Check ( t , permission . Perm Nodecontainer Update , ctxs . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node Container , Value : config . Name } , Kind : permission . Perm Nodecontainer Update , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) config . Name = r . URL . Query ( ) . Get ( " " ) err = nodecontainer . Update Container ( pool Name , & config ) if err ! = nil { if err = = nodecontainer . Err Node Container Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : err . Error ( ) , } } if _ , ok : = err . ( nodecontainer . Validation Err ) ; ok { return & tsuru Errors . HTTP { Code : http . Status Bad Request , Message : err . Error ( ) , } } return err } return nil } 
func node Container Delete ( w http . Response Writer , r * http . Request , t auth . Token ) ( err error ) { name : = r . URL . Query ( ) . Get ( " " ) pool Name : = r . URL . Query ( ) . Get ( " " ) kill , _ : = strconv . Parse Bool ( r . URL . Query ( ) . Get ( " " ) ) var ctxs [ ] perm Types . Permission Context if pool Name ! = " " { ctxs = append ( ctxs , permission . Context ( perm Types . Ctx Pool , pool Name ) ) } if ! permission . Check ( t , permission . Perm Nodecontainer Delete , ctxs . . . ) { return permission . Err Unauthorized } evt , err : = event . New ( & event . Opts { Target : event . Target { Type : event . Target Type Node Container , Value : name } , Kind : permission . Perm Nodecontainer Delete , Owner : t , Custom Data : event . Form To Custom Data ( Input Fields ( r ) ) , Allowed : event . Allowed ( permission . Perm Pool Read Events , ctxs . . . ) , } ) if err ! = nil { return err } defer func ( ) { evt . Done ( err ) } ( ) err = nodecontainer . Remove Container ( pool Name , name ) if err = = nodecontainer . Err Node Container Not Found { return & tsuru Errors . HTTP { Code : http . Status Not Found , Message : fmt . Sprintf ( " " , name , pool Name ) , } } if err ! = nil | | ! kill { return err } provs , err : = provision . Registry ( ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) keep Alive Writer : = tsuru Io . New Keep Alive Writer ( w , 1 5 * time . Second , " " ) defer keep Alive Writer . Stop ( ) writer : = & tsuru Io . Simple Json Message Encoder Writer { Encoder : json . New Encoder ( keep Alive Writer ) } evt . Set Log Writer ( writer ) var all Errors [ ] string for _ , prov : = range provs { nc Prov , ok : = prov . ( provision . Node Container Provisioner ) if ! ok { continue } err = nc Prov . Remove Node Container ( name , pool Name , evt ) if err ! = nil { all Errors = append ( all Errors , err . Error ( ) ) } } if len ( all Errors ) > 0 { return errors . Errorf ( " " , strings . Join ( all Errors , " " ) ) } return nil } 
func ( p * docker Provisioner ) Get App From Unit ID ( unit ID string ) ( provision . App , error ) { cnt , err : = p . Get Container ( unit ID ) if err ! = nil { return nil , err } a , err : = app . Get By Name ( cnt . App Name ) if err ! = nil { return nil , err } return a , nil } 
func Validate Length ( value string , min , max int ) bool { l : = len ( value ) if min > 0 & & l < min { return false } if max > 0 & & l > max { return false } return true } 
func New Pipeline ( actions . . . * Action ) * Pipeline { for i , action : = range actions { new Action : = & Action { Name : action . Name , Forward : action . Forward , Backward : action . Backward , Min Params : action . Min Params , On Error : action . On Error , } new Actions [ i ] = new Action } return & Pipeline { actions : new Actions } } 
func ( p * Pipeline ) Result ( ) Result { action : = p . actions [ len ( p . actions ) - 1 ] action . r Mutex . Lock ( ) defer action . r Mutex . Unlock ( ) return action . result } 
func ( p * Pipeline ) Execute ( params . . . interface { } ) ( err error ) { var r Result if len ( p . actions ) = = 0 { return Err Pipeline No Actions } fw Ctx : = FWContext { Params : params } var i int var a * Action defer func ( ) { if r : = recover ( ) ; r ! = nil { log . Errorf ( " " , a . Name , r ) err = fmt . Errorf ( " " , a . Name , r ) if a . On Error ! = nil { a . On Error ( fw Ctx , err ) } p . rollback ( i - 1 , params ) } } ( ) for i , a = range p . actions { log . Debugf ( " " , a . Name ) if a . Forward = = nil { err = Err Pipeline Forward Missing } else if len ( fw Ctx . Params ) < a . Min Params { err = Err Pipeline Few Parameters } else { r , err = a . Forward ( fw Ctx ) a . r Mutex . Lock ( ) a . result = r a . r Mutex . Unlock ( ) fw Ctx . Previous = r } if err ! = nil { log . Errorf ( " " , a . Name , err ) if a . On Error ! = nil { a . On Error ( fw Ctx , err ) } p . rollback ( i - 1 , params ) return err } } return nil } 
func deep Map ( dst , src reflect . Value , visited map [ uintptr ] * visit , depth int , config * Config ) ( err error ) { overwrite : = config . Overwrite if dst . Can Addr ( ) { addr : = dst . Unsafe Addr ( ) h : = 1 7 * addr seen : = visited [ h ] typ : = dst . Type ( ) for p : = seen ; p ! = nil ; p = p . next { if p . ptr = = addr & & p . typ = = typ { return nil } } } zero Value : = reflect . Value { } switch dst . Kind ( ) { case reflect . Map : dst Map : = dst . Interface ( ) . ( map [ string ] interface { } ) for i , n : = 0 , src . Num Field ( ) ; i < n ; i + + { src Type : = src . Type ( ) field : = src Type . Field ( i ) if ! is Exported ( field ) { continue } field Name : = field . Name field Name = change Initial Case ( field Name , unicode . To Lower ) if v , ok : = dst Map [ field Name ] ; ! ok | | ( is Empty Value ( reflect . Value Of ( v ) ) | | overwrite ) { dst Map [ field Name ] = src . Field ( i ) . Interface ( ) } } case reflect . Ptr : if dst . Is Nil ( ) { v : = reflect . New ( dst . Type ( ) . Elem ( ) ) dst . Set ( v ) } dst = dst . Elem ( ) fallthrough case reflect . Struct : src Map : = src . Interface ( ) . ( map [ string ] interface { } ) for key : = range src Map { config . overwrite With Empty Value = true src Value : = src Map [ key ] field Name : = change Initial Case ( key , unicode . To Upper ) dst Element : = dst . Field By Name ( field Name ) if dst Element = = zero Value { } src Element : = reflect . Value Of ( src Value ) dst Kind : = dst Element . Kind ( ) src Kind : = src Element . Kind ( ) if src Kind = = reflect . Ptr & & dst Kind ! = reflect . Ptr { src Element = src Element . Elem ( ) src Kind = reflect . Type Of ( src Element . Interface ( ) ) . Kind ( ) } else if dst Kind = = reflect . Ptr { src Element = reflect . Value Of ( src Ptr ) src Kind = reflect . Ptr } } if ! src Element . Is Valid ( ) { continue } if src Kind = = dst Kind { if err = deep Merge ( dst Element , src Element , visited , depth + 1 , config ) ; err ! = nil { return } } else if dst Kind = = reflect . Interface & & dst Element . Kind ( ) = = reflect . Interface { if err = deep Merge ( dst Element , src Element , visited , depth + 1 , config ) ; err ! = nil { return } } else if src Kind = = reflect . Map { if err = deep Map ( dst Element , src Element , visited , depth + 1 , config ) ; err ! = nil { return } } else { return fmt . Errorf ( " " , field Name , src Kind , dst Kind ) } } } return } 
func Map ( dst , src interface { } , opts . . . func ( * Config ) ) error { return _map ( dst , src , opts . . . ) } 
func Map With Overwrite ( dst , src interface { } , opts . . . func ( * Config ) ) error { return _map ( dst , src , append ( opts , With Override ) . . . ) } 
func deep Merge ( dst , src reflect . Value , visited map [ uintptr ] * visit , depth int , config * Config ) ( err error ) { overwrite : = config . Overwrite type Check : = config . Type Check overwrite With Empty Src : = config . overwrite With Empty Value config . overwrite With Empty Value = false if ! src . Is Valid ( ) { return } if dst . Can Addr ( ) { addr : = dst . Unsafe Addr ( ) h : = 1 7 * addr seen : = visited [ h ] typ : = dst . Type ( ) for p : = seen ; p ! = nil ; p = p . next { if p . ptr = = addr & & p . typ = = typ { return nil } } } if config . Transformers ! = nil & & ! is Empty Value ( dst ) { if fn : = config . Transformers . Transformer ( dst . Type ( ) ) ; fn ! = nil { err = fn ( dst , src ) return } } switch dst . Kind ( ) { case reflect . Struct : if has Exported Field ( dst ) { for i , n : = 0 , dst . Num Field ( ) ; i < n ; i + + { if err = deep Merge ( dst . Field ( i ) , src . Field ( i ) , visited , depth + 1 , config ) ; err ! = nil { return } } } else { if dst . Can Set ( ) & & ( ! is Empty Value ( src ) | | overwrite With Empty Src ) & & ( overwrite | | is Empty Value ( dst ) ) { dst . Set ( src ) } } case reflect . Map : if dst . Is Nil ( ) & & ! src . Is Nil ( ) { dst . Set ( reflect . Make Map ( dst . Type ( ) ) ) } for _ , key : = range src . Map Keys ( ) { src Element : = src . Map Index ( key ) if ! src Element . Is Valid ( ) { continue } dst Element : = dst . Map Index ( key ) switch src Element . Kind ( ) { case reflect . Chan , reflect . Func , reflect . Map , reflect . Interface , reflect . Slice : if src Element . Is Nil ( ) { continue } fallthrough default : if ! src Element . Can Interface ( ) { continue } switch reflect . Type Of ( src Element . Interface ( ) ) . Kind ( ) { case reflect . Struct : fallthrough case reflect . Ptr : fallthrough case reflect . Map : src Map Elm : = src Element dst Map Elm : = dst Element if src Map Elm . Can Interface ( ) { src Map Elm = reflect . Value Of ( src Map Elm . Interface ( ) ) if dst Map Elm . Is Valid ( ) { dst Map Elm = reflect . Value Of ( dst Map Elm . Interface ( ) ) } } if err = deep Merge ( dst Map Elm , src Map Elm , visited , depth + 1 , config ) ; err ! = nil { return } case reflect . Slice : src Slice : = reflect . Value Of ( src Element . Interface ( ) ) var dst Slice reflect . Value if ! dst Element . Is Valid ( ) | | dst Element . Is Nil ( ) { dst Slice = reflect . Make Slice ( src Slice . Type ( ) , 0 , src Slice . Len ( ) ) } else { dst Slice = reflect . Value Of ( dst Element . Interface ( ) ) } if ( ! is Empty Value ( src ) | | overwrite With Empty Src ) & & ( overwrite | | is Empty Value ( dst ) ) & & ! config . Append Slice { if type Check & & src Slice . Type ( ) ! = dst Slice . Type ( ) { return fmt . Errorf ( " " , src Slice . Type ( ) , dst Slice . Type ( ) ) } dst Slice = src Slice } else if config . Append Slice { if src Slice . Type ( ) ! = dst Slice . Type ( ) { return fmt . Errorf ( " " , src Slice . Type ( ) , dst Slice . Type ( ) ) } dst Slice = reflect . Append Slice ( dst Slice , src Slice ) } dst . Set Map Index ( key , dst Slice ) } } if dst Element . Is Valid ( ) & & ! is Empty Value ( dst Element ) & & ( reflect . Type Of ( src Element . Interface ( ) ) . Kind ( ) = = reflect . Map | | reflect . Type Of ( src Element . Interface ( ) ) . Kind ( ) = = reflect . Slice ) { continue } if src Element . Is Valid ( ) & & ( overwrite | | ( ! dst Element . Is Valid ( ) | | is Empty Value ( dst Element ) ) ) { if dst . Is Nil ( ) { dst . Set ( reflect . Make Map ( dst . Type ( ) ) ) } dst . Set Map Index ( key , src Element ) } } case reflect . Slice : if ! dst . Can Set ( ) { break } if ( ! is Empty Value ( src ) | | overwrite With Empty Src ) & & ( overwrite | | is Empty Value ( dst ) ) & & ! config . Append Slice { dst . Set ( src ) } else if config . Append Slice { if src . Type ( ) ! = dst . Type ( ) { return fmt . Errorf ( " " , src . Type ( ) , dst . Type ( ) ) } dst . Set ( reflect . Append Slice ( dst , src ) ) } case reflect . Ptr : fallthrough case reflect . Interface : if src . Is Nil ( ) { break } if dst . Kind ( ) ! = reflect . Ptr & & src . Type ( ) . Assignable To ( dst . Type ( ) ) { if dst . Is Nil ( ) | | overwrite { if dst . Can Set ( ) & & ( overwrite | | is Empty Value ( dst ) ) { dst . Set ( src ) } } break } if src . Kind ( ) ! = reflect . Interface { if dst . Is Nil ( ) | | overwrite { if dst . Can Set ( ) & & ( overwrite | | is Empty Value ( dst ) ) { dst . Set ( src ) } } else if src . Kind ( ) = = reflect . Ptr { if err = deep Merge ( dst . Elem ( ) , src . Elem ( ) , visited , depth + 1 , config ) ; err ! = nil { return } } else if dst . Elem ( ) . Type ( ) = = src . Type ( ) { if err = deep Merge ( dst . Elem ( ) , src , visited , depth + 1 , config ) ; err ! = nil { return } } else { return Err Different Arguments Types } break } if dst . Is Nil ( ) | | overwrite { if dst . Can Set ( ) & & ( overwrite | | is Empty Value ( dst ) ) { dst . Set ( src ) } } else if err = deep Merge ( dst . Elem ( ) , src . Elem ( ) , visited , depth + 1 , config ) ; err ! = nil { return } default : if dst . Can Set ( ) & & ( ! is Empty Value ( src ) | | overwrite With Empty Src ) & & ( overwrite | | is Empty Value ( dst ) ) { dst . Set ( src ) } } return } 
func Merge ( dst , src interface { } , opts . . . func ( * Config ) ) error { return merge ( dst , src , opts . . . ) } 
func Merge With Overwrite ( dst , src interface { } , opts . . . func ( * Config ) ) error { return merge ( dst , src , append ( opts , With Override ) . . . ) } 
func ( r * Request ) Decode Json Payload ( v interface { } ) error { content , err : = ioutil . Read All ( r . Body ) r . Body . Close ( ) if err ! = nil { return err } if len ( content ) = = 0 { return Err Json Payload Empty } err = json . Unmarshal ( content , v ) if err ! = nil { return err } return nil } 
func ( r * Request ) Base Url ( ) * url . URL { scheme : = r . URL . Scheme if scheme = = " " { scheme = " " } } host : = r . Host if len ( host ) > 0 & & host [ len ( host ) - 1 ] = = ' / ' { host = host [ : len ( host ) - 1 ] } return & url . URL { Scheme : scheme , Host : host , } } 
func ( r * Request ) Url For ( path string , query Params map [ string ] [ ] string ) * url . URL { base Url : = r . Base Url ( ) base Url . Path = path if query Params ! = nil { query : = url . Values { } for k , v : = range query Params { for _ , vv : = range v { query . Add ( k , vv ) } } base Url . Raw Query = query . Encode ( ) } return base Url } 
func ( r * Request ) Get Cors Info ( ) * Cors Info { origin : = r . Header . Get ( " " ) var origin Url * url . URL var is Cors bool if origin = = " " { is Cors = false } else if origin = = " " { is Cors = true } else { var err error origin Url , err = url . Parse Request URI ( origin ) is Cors = err = = nil & & r . Host ! = origin Url . Host } req Method : = r . Header . Get ( " " ) req Headers : = [ ] string { } raw Req Headers : = r . Header [ http . Canonical Header Key ( " " ) ] for _ , raw Req Header : = range raw Req Headers { if len ( raw Req Header ) = = 0 { continue } } } is Preflight : = is Cors & & r . Method = = " " & & req Method ! = " " return & Cors Info { Is Cors : is Cors , Is Preflight : is Preflight , Origin : origin , Origin Url : origin Url , Access Control Request Method : strings . To Upper ( req Method ) , Access Control Request Headers : req Headers , } } 
func ( mw * Cors Middleware ) Middleware Func ( handler Handler Func ) Handler Func { normed Methods : = [ ] string { } for _ , allowed Method : = range mw . Allowed Methods { normed : = strings . To Upper ( allowed Method ) mw . allowed Methods [ normed ] = true normed Methods = append ( normed Methods , normed ) } mw . allowed Methods Csv = strings . Join ( normed Methods , " " ) mw . allowed Headers = map [ string ] bool { } normed Headers : = [ ] string { } for _ , allowed Header : = range mw . Allowed Headers { normed : = http . Canonical Header Key ( allowed Header ) mw . allowed Headers [ normed ] = true normed Headers = append ( normed Headers , normed ) } mw . allowed Headers Csv = strings . Join ( normed Headers , " " ) return func ( writer Response Writer , request * Request ) { cors Info : = request . Get Cors Info ( ) return } return } return } if cors Info . Is Preflight { return } return } } writer . Header ( ) . Set ( " " , mw . allowed Methods Csv ) writer . Header ( ) . Set ( " " , mw . allowed Headers Csv ) writer . Header ( ) . Set ( " " , cors Info . Origin ) if mw . Access Control Allow Credentials = = true { writer . Header ( ) . Set ( " " , " " ) } writer . Header ( ) . Set ( " " , strconv . Itoa ( mw . Access Control Max Age ) ) writer . Write Header ( http . Status OK ) return } } writer . Header ( ) . Set ( " " , cors Info . Origin ) if mw . Access Control Allow Credentials = = true { writer . Header ( ) . Set ( " " , " " ) } return } } 
func ( mw * Recorder Middleware ) Middleware Func ( h Handler Func ) Handler Func { return func ( w Response Writer , r * Request ) { writer : = & recorder Response Writer { w , 0 , false , 0 } r . Env [ " " ] = writer . status Code r . Env [ " " ] = writer . bytes Written } } 
func ( w * recorder Response Writer ) Write Header ( code int ) { w . Response Writer . Write Header ( code ) if w . wrote Header { return } w . status Code = code w . wrote Header = true } 
func ( w * recorder Response Writer ) Write Json ( v interface { } ) error { b , err : = w . Encode Json ( v ) if err ! = nil { return err } _ , err = w . Write ( b ) if err ! = nil { return err } return nil } 
func ( w * recorder Response Writer ) Close Notify ( ) < - chan bool { notifier : = w . Response Writer . ( http . Close Notifier ) return notifier . Close Notify ( ) } 
func ( w * recorder Response Writer ) Write ( b [ ] byte ) ( int , error ) { if ! w . wrote Header { w . Write Header ( http . Status OK ) } writer : = w . Response Writer . ( http . Response Writer ) written , err : = writer . Write ( b ) w . bytes Written + = int 6 4 ( written ) return written , err } 
func Make Router ( routes . . . * Route ) ( App , error ) { r : = & router { Routes : routes , } err : = r . start ( ) if err ! = nil { return nil , err } return r , nil } 
func ( rt * router ) App Func ( ) Handler Func { return func ( writer Response Writer , request * Request ) { if route = = nil { if path Matched { return } return } handler ( writer , request ) } } 
func escaped Path ( url Obj * url . URL ) string { return parts [ 0 ] } 
func escaped Path Exp ( path Exp string ) ( string , error ) { } if path Exp [ 0 ] ! = ' / ' { return " " , errors . New ( " " ) } if strings . Contains ( path Exp , " " ) { return " " , errors . New ( " " ) } url Obj , err : = url . Parse ( path Exp ) if err ! = nil { return " " , err } path Exp = post Escape . Replace ( path Exp ) return path Exp , nil } 
func ( rt * router ) start ( ) error { rt . trie = trie . New ( ) rt . index = map [ * Route ] int { } for i , route : = range rt . Routes { if err ! = nil { return err } if err ! = nil { return err } } if rt . disable Trie Compression = = false { rt . trie . Compress ( ) } return nil } 
func ( rt * router ) of First Defined Route ( matches [ ] * trie . Match ) * trie . Match { min Index : = - 1 var best Match * trie . Match for _ , result : = range matches { route : = result . Route . ( * Route ) route Index : = rt . index [ route ] if min Index = = - 1 | | route Index < min Index { min Index = route Index best Match = result } } return best Match } 
func ( rt * router ) find Route From URL ( http Method string , url Obj * url . URL ) ( * Route , map [ string ] string , bool ) { } if len ( matches ) = = 1 { } return result . Route . ( * Route ) , result . Params , path Matched } 
func ( rt * router ) find Route ( http Method , url Str string ) ( * Route , map [ string ] string , bool , error ) { if err ! = nil { return nil , nil , false , err } route , params , path Matched : = rt . find Route From URL ( http Method , url Obj ) return route , params , path Matched , nil } 
func ( mw * Content Type Checker Middleware ) Middleware Func ( handler Handler Func ) Handler Func { return func ( w Response Writer , r * Request ) { mediatype , params , _ : = mime . Parse Media Type ( r . Header . Get ( " " ) ) charset , ok : = params [ " " ] if ! ok { charset = " " } return } } } 
func Error ( w Response Writer , error string , code int ) { w . Write Header ( code ) err : = w . Write Json ( map [ string ] string { Error Field Name : error } ) if err ! = nil { panic ( err ) } } 
func ( w * response Writer ) Close Notify ( ) < - chan bool { notifier : = w . Response Writer . ( http . Close Notifier ) return notifier . Close Notify ( ) } 
func ( mw * Access Log Apache Middleware ) Middleware Func ( h Handler Func ) Handler Func { } } mw . convert Format ( ) return func ( w Response Writer , r * Request ) { util : = & access Log Util { w , r } mw . Logger . Print ( mw . execute Text Template ( util ) ) } } 
func ( mw * Access Log Apache Middleware ) convert Format ( ) { tmpl Text : = apache Adapter . Replace ( string ( mw . Format ) ) func Map : = template . Func Map { " " : func ( value string ) string { if value = = " " { return " " } return value } , " " : func ( value int 6 4 ) string { if value = = 0 { return " " } return fmt . Sprintf ( " " , value ) } , " " : func ( dur * time . Duration ) string { if dur ! = nil { return fmt . Sprintf ( " " , dur . Nanoseconds ( ) / 1 0 0 0 ) } return " " } , " " : func ( status Code int ) string { if status Code > = 4 0 0 & & status Code < 5 0 0 { return " " } else if status Code > = 5 0 0 { return " " } return " " } , } var err error mw . text Template , err = template . New ( " " ) . Funcs ( func Map ) . Parse ( tmpl Text ) if err ! = nil { panic ( err ) } } 
func ( mw * Access Log Apache Middleware ) execute Text Template ( util * access Log Util ) string { buf : = bytes . New Buffer String ( " " ) err : = mw . text Template . Execute ( buf , util ) if err ! = nil { panic ( err ) } return buf . String ( ) } 
func ( u * access Log Util ) Remote User ( ) string { if u . R . Env [ " " ] ! = nil { return u . R . Env [ " " ] . ( string ) } return " " } 
func ( u * access Log Util ) Apache Query String ( ) string { if u . R . URL . Raw Query ! = " " { return " " + u . R . URL . Raw Query } return " " } 
func ( u * access Log Util ) Start Time ( ) * time . Time { if u . R . Env [ " " ] ! = nil { return u . R . Env [ " " ] . ( * time . Time ) } return nil } 
func ( u * access Log Util ) Apache Remote Addr ( ) string { remote Addr : = u . R . Remote Addr if remote Addr ! = " " { if ip , _ , err : = net . Split Host Port ( remote Addr ) ; err = = nil { return ip } } return " " } 
func ( u * access Log Util ) Status Code ( ) int { if u . R . Env [ " " ] ! = nil { return u . R . Env [ " " ] . ( int ) } return 0 } 
func ( u * access Log Util ) Response Time ( ) * time . Duration { if u . R . Env [ " " ] ! = nil { return u . R . Env [ " " ] . ( * time . Duration ) } return nil } 
func ( u * access Log Util ) Bytes Written ( ) int 6 4 { if u . R . Env [ " " ] ! = nil { return u . R . Env [ " " ] . ( int 6 4 ) } return 0 } 
func ( mw * Json Indent Middleware ) Middleware Func ( handler Handler Func ) Handler Func { if mw . Indent = = " " { mw . Indent = " " } return func ( w Response Writer , r * Request ) { writer : = & json Indent Response Writer { w , false , mw . Prefix , mw . Indent } } } 
func ( w * json Indent Response Writer ) Encode Json ( v interface { } ) ( [ ] byte , error ) { b , err : = json . Marshal Indent ( v , w . prefix , w . indent ) if err ! = nil { return nil , err } return b , nil } 
func ( w * json Indent Response Writer ) Write Header ( code int ) { w . Response Writer . Write Header ( code ) w . wrote Header = true } 
func ( w * json Indent Response Writer ) Close Notify ( ) < - chan bool { notifier : = w . Response Writer . ( http . Close Notifier ) return notifier . Close Notify ( ) } 
func ( w * json Indent Response Writer ) Write ( b [ ] byte ) ( int , error ) { if ! w . wrote Header { w . Write Header ( http . Status OK ) } writer : = w . Response Writer . ( http . Response Writer ) return writer . Write ( b ) } 
func ( route * Route ) Make Path ( path Params map [ string ] string ) string { path : = route . Path Exp for param Name , param Value : = range path Params { param Placeholder : = " " + param Name relaxed Placeholder : = " " + param Name splat Placeholder : = " " + param Name r : = strings . New Replacer ( param Placeholder , param Value , splat Placeholder , param Value , relaxed Placeholder , param Value ) path = r . Replace ( path ) } return path } 
func Head ( path Exp string , handler Func Handler Func ) * Route { return & Route { Http Method : " " , Path Exp : path Exp , Func : handler Func , } } 
func ( mw * Recover Middleware ) Middleware Func ( h Handler Func ) Handler Func { } return func ( w Response Writer , r * Request ) { mw . log Error ( message ) } else { Error ( w , " " , http . Status Internal Server Error ) } } } ( ) } } 
func Wrap Middlewares ( middlewares [ ] Middleware , handler Handler Func ) Handler Func { wrapped : = handler for i : = len ( middlewares ) - 1 ; i > = 0 ; i - - { wrapped = middlewares [ i ] . Middleware Func ( wrapped ) } return wrapped } 
func adapter Func ( handler Handler Func ) http . Handler Func { return func ( orig Writer http . Response Writer , orig Request * http . Request ) { writer : = & response Writer { orig Writer , false , } } } 
func ( mw * Timer Middleware ) Middleware Func ( h Handler Func ) Handler Func { return func ( w Response Writer , r * Request ) { start : = time . Now ( ) r . Env [ " " ] = & start end : = time . Now ( ) elapsed : = end . Sub ( start ) r . Env [ " " ] = & elapsed } } 
func ( mw * Gzip Middleware ) Middleware Func ( h Handler Func ) Handler Func { return func ( w Response Writer , r * Request ) { defer func ( ) { } } ( ) } } 
func ( w * gzip Response Writer ) Write Header ( code int ) { if w . can Gzip { w . Header ( ) . Set ( " " , " " ) } w . Response Writer . Write Header ( code ) w . wrote Header = true } 
func ( w * gzip Response Writer ) Close Notify ( ) < - chan bool { notifier : = w . Response Writer . ( http . Close Notifier ) return notifier . Close Notify ( ) } 
func ( w * gzip Response Writer ) Hijack ( ) ( net . Conn , * bufio . Read Writer , error ) { hijacker : = w . Response Writer . ( http . Hijacker ) return hijacker . Hijack ( ) } 
func ( w * gzip Response Writer ) Write ( b [ ] byte ) ( int , error ) { if ! w . wrote Header { w . Write Header ( http . Status OK ) } writer : = w . Response Writer . ( http . Response Writer ) if w . can Gzip { } count , err W : = w . gzip Writer . Write ( b ) err F : = w . gzip Writer . Flush ( ) if err W ! = nil { return count , err W } if err F ! = nil { return count , err F } return count , nil } return writer . Write ( b ) } 
func ( mw * Auth Basic Middleware ) Middleware Func ( handler Handler Func ) Handler Func { if mw . Realm = = " " { log . Fatal ( " " ) } if mw . Authenticator = = nil { log . Fatal ( " " ) } if mw . Authorizator = = nil { mw . Authorizator = func ( user Id string , request * Request ) bool { return true } } return func ( writer Response Writer , request * Request ) { auth Header : = request . Header . Get ( " " ) if auth Header = = " " { mw . unauthorized ( writer ) return } provided User Id , provided Password , err : = mw . decode Basic Auth Header ( auth Header ) if err ! = nil { Error ( writer , " " , http . Status Bad Request ) return } if ! mw . Authenticator ( provided User Id , provided Password ) { mw . unauthorized ( writer ) return } if ! mw . Authorizator ( provided User Id , request ) { mw . unauthorized ( writer ) return } request . Env [ " " ] = provided User Id handler ( writer , request ) } } 
func ( mw * If Middleware ) Middleware Func ( h Handler Func ) Handler Func { if mw . Condition = = nil { log . Fatal ( " " ) } var if True Handler Handler Func if mw . If True ! = nil { if True Handler = mw . If True . Middleware Func ( h ) } else { if True Handler = h } var if False Handler Handler Func if mw . If False ! = nil { if False Handler = mw . If False . Middleware Func ( h ) } else { if False Handler = h } return func ( w Response Writer , r * Request ) { if mw . Condition ( r ) { if True Handler ( w , r ) } else { if False Handler ( w , r ) } } } 
func ( n * node ) print Debug ( level int ) { level + + n . Splat Child . print Debug ( level ) } n . Param Child . print Debug ( level ) } n . Relaxed Child . print Debug ( level ) } node . print Debug ( level ) } } 
func ( t * Trie ) Add Route ( http Method , path Exp string , route interface { } ) error { return t . root . add Route ( http Method , path Exp , route , [ ] string { } ) } 
func ( t * Trie ) print Debug ( ) { fmt . Print ( " \n " ) t . root . print Debug ( 0 ) fmt . Print ( " \n " ) } 
func ( t * Trie ) Find Routes ( http Method , path string ) [ ] * Match { context : = new Find Context ( ) matches : = [ ] * Match { } context . match Func = func ( http Method , path string , node * node ) { if node . Http Method To Route [ http Method ] ! = nil { } } t . root . find ( http Method , path , context ) return matches } 
func ( t * Trie ) Find Routes And Path Matched ( http Method , path string ) ( [ ] * Match , bool ) { context : = new Find Context ( ) path Matched : = false matches : = [ ] * Match { } context . match Func = func ( http Method , path string , node * node ) { path Matched = true if node . Http Method To Route [ http Method ] ! = nil { } } t . root . find ( http Method , path , context ) return matches , path Matched } 
func ( t * Trie ) Find Routes For Path ( path string ) [ ] * Match { context : = new Find Context ( ) matches : = [ ] * Match { } context . match Func = func ( http Method , path string , node * node ) { params : = context . params As Map ( ) for _ , route : = range node . Http Method To Route { matches = append ( matches , & Match { Route : route , Params : params , } , ) } } t . root . find ( " " , path , context ) return matches } 
func ( api * Api ) Use ( middlewares . . . Middleware ) { api . stack = append ( api . stack , middlewares . . . ) } 
func ( api * Api ) Make Handler ( ) http . Handler { var app Func Handler Func if api . app ! = nil { app Func = api . app . App Func ( ) } else { app Func = func ( w Response Writer , r * Request ) { } } return http . Handler Func ( adapter Func ( Wrap Middlewares ( api . stack , app Func ) , ) , ) } 
func ( mw * Powered By Middleware ) Middleware Func ( h Handler Func ) Handler Func { powered By : = x Powered By Default if mw . XPowered By ! = " " { powered By = mw . XPowered By } return func ( w Response Writer , r * Request ) { w . Header ( ) . Add ( " " , powered By ) } } 
func ( mw * Status Middleware ) Middleware Func ( h Handler Func ) Handler Func { mw . start = time . Now ( ) mw . pid = os . Getpid ( ) mw . response Counts = map [ string ] int { } mw . total Response Time = time . Time { } return func ( w Response Writer , r * Request ) { if r . Env [ " " ] = = nil { log . Fatal ( " \ " \ " " + " " ) } status Code : = r . Env [ " " ] . ( int ) if r . Env [ " " ] = = nil { log . Fatal ( " \ " \ " " + " " ) } response Time : = r . Env [ " " ] . ( * time . Duration ) mw . lock . Lock ( ) mw . response Counts [ fmt . Sprintf ( " " , status Code ) ] + + mw . total Response Time = mw . total Response Time . Add ( * response Time ) mw . lock . Unlock ( ) } } 
func ( mw * Status Middleware ) Get Status ( ) * Status { mw . lock . RLock ( ) now : = time . Now ( ) uptime : = now . Sub ( mw . start ) total Count : = 0 for _ , count : = range mw . response Counts { total Count + = count } total Response Time : = mw . total Response Time . Sub ( time . Time { } ) average Response Time : = time . Duration ( 0 ) if total Count > 0 { avg Ns : = int 6 4 ( total Response Time ) / int 6 4 ( total Count ) average Response Time = time . Duration ( avg Ns ) } status : = & Status { Pid : mw . pid , Up Time : uptime . String ( ) , Up Time Sec : uptime . Seconds ( ) , Time : now . String ( ) , Time Unix : now . Unix ( ) , Status Code Count : mw . response Counts , Total Count : total Count , Total Response Time : total Response Time . String ( ) , Total Response Time Sec : total Response Time . Seconds ( ) , Average Response Time : average Response Time . String ( ) , Average Response Time Sec : average Response Time . Seconds ( ) , } mw . lock . RUnlock ( ) return status } 
func ( mw * Jsonp Middleware ) Middleware Func ( h Handler Func ) Handler Func { if mw . Callback Name Key = = " " { mw . Callback Name Key = " " } return func ( w Response Writer , r * Request ) { callback Name : = r . URL . Query ( ) . Get ( mw . Callback Name Key ) } else { } } } 
func ( w * jsonp Response Writer ) Write Header ( code int ) { w . Header ( ) . Set ( " " , " " ) w . Response Writer . Write Header ( code ) w . wrote Header = true } 
func ( w * jsonp Response Writer ) Write Json ( v interface { } ) error { b , err : = w . Encode Json ( v ) if err ! = nil { return err } w . Header ( ) . Set ( " " , " " ) w . Write ( [ ] byte ( " " + w . callback Name + " " ) ) w . Write ( b ) w . Write ( [ ] byte ( " " ) ) return nil } 
func ( w * jsonp Response Writer ) Flush ( ) { if ! w . wrote Header { w . Write Header ( http . Status OK ) } flusher : = w . Response Writer . ( http . Flusher ) flusher . Flush ( ) } 
func ( w * jsonp Response Writer ) Close Notify ( ) < - chan bool { notifier : = w . Response Writer . ( http . Close Notifier ) return notifier . Close Notify ( ) } 
func ( mw * Access Log Json Middleware ) Middleware Func ( h Handler Func ) Handler Func { } return func ( w Response Writer , r * Request ) { mw . Logger . Printf ( " " , make Access Log Json Record ( r ) . as Json ( ) ) } } 
func ( s * S 3 ) Init ( ) error { if s . Bucket = = " " { return errors . New ( " " ) } else if s . Key = = " " { return errors . New ( " " ) } if s . Region = = " " { s . Region = " " } creds : = credentials . Anonymous Credentials if s . Access ! = " " { creds = credentials . New Static Credentials ( s . Access , s . Secret , " " ) } else if os . Getenv ( " " ) ! = " " { creds = credentials . New Env Credentials ( ) } config : = & aws . Config { Credentials : creds , Region : & s . Region , } s . client = s 3 . New ( session . New ( config ) ) } return nil } 
func ( s * S 3 ) Fetch ( ) ( io . Reader , error ) { } s . delay = true if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if s . last ETag = = * head . ETag { return nil , nil } s . last ETag = * head . ETag if err ! = nil { return nil , fmt . Errorf ( " " , err ) } } } 
func Run ( c Config ) { err : = run Err ( & c ) if err ! = nil { if c . Required { log . Fatalf ( " " , err ) } else if c . Debug | | ! c . No Warn { log . Printf ( " " , err ) } c . Program ( Disabled State ) return } os . Exit ( 0 ) } 
func sanity Check ( ) bool { return true } return true } return false } 
func prog ( state overseer . State ) { fmt . Printf ( " \n " , Build ID , state . ID ) http . Handle ( " " , http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { d , _ : = time . Parse Duration ( r . URL . Query ( ) . Get ( " " ) ) time . Sleep ( d ) fmt . Fprintf ( w , " \n " , Build ID , state . ID ) } ) ) http . Serve ( state . Listener , nil ) fmt . Printf ( " \n " , Build ID , state . ID ) } 
func main ( ) { overseer . Run ( overseer . Config { Program : prog , Address : " " , Fetcher : & fetcher . File { Path : " " } , Debug : false , } 
func ( l * overseer Listener ) release ( timeout time . Duration ) { go func ( ) { l . wg . Wait ( ) waited < - true } ( ) go func ( ) { select { case < - time . After ( timeout ) : close ( l . close By Force ) case < - waited : } ( ) } 
func ( mp * master ) fetch Loop ( ) { min : = mp . Config . Min Fetch Interval time . Sleep ( min ) for { t 0 : = time . Now ( ) mp . fetch ( ) if diff < min { delay : = min - diff } } } 
func ( mp * master ) fork Loop ( ) error { } } } 
func ( h * Github ) Init ( ) error { } if h . Repo = = " " { return fmt . Errorf ( " " ) } if h . Asset = = nil { h . Asset = h . default Asset } h . release URL = " " + h . User + " " + h . Repo + " " if h . Interval = = 0 { h . Interval = 5 * time . Minute } else if h . Interval < 1 * time . Minute { log . Printf ( " " ) } return nil } 
func ( h * Github ) Fetch ( ) ( io . Reader , error ) { } h . delay = true if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if resp . Status Code ! = http . Status OK { resp . Body . Close ( ) return nil , fmt . Errorf ( " " , resp . Status Code ) } if err : = json . New Decoder ( resp . Body ) . Decode ( & h . latest Release ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } resp . Body . Close ( ) for _ , a : = range h . latest Release . Assets { if h . Asset ( a . Name ) { asset URL = a . URL break } } if asset URL = = " " { return nil , fmt . Errorf ( " " , h . latest Release . Tag Name ) } resp , err = http . Default Transport . Round Trip ( req ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } resp . Body . Close ( ) if resp . Status Code ! = http . Status Found { return nil , fmt . Errorf ( " " , resp . Status Code ) } s 3URL : = resp . Header . Get ( " " ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } req . Header . Set ( " " , " " ) resp , err = http . Default Transport . Round Trip ( req ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } resp . Body . Close ( ) if resp . Status Code ! = http . Status Partial Content { return nil , fmt . Errorf ( " " , resp . Status Code ) } etag : = resp . Header . Get ( " " ) if etag ! = " " & & h . last ETag = = etag { return nil , nil } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if resp . Status Code ! = http . Status OK { resp . Body . Close ( ) return nil , fmt . Errorf ( " " , resp . Status Code ) } h . last ETag = etag } return resp . Body , nil } 
func ( f * File ) Init ( ) error { if f . Path = = " " { return fmt . Errorf ( " " ) } if f . Interval < 1 * time . Second { f . Interval = 1 * time . Second } if err : = f . update Hash ( ) ; err ! = nil { return err } return nil } 
func ( f * File ) Fetch ( ) ( io . Reader , error ) { } f . delay = true last Hash : = f . hash if err : = f . update Hash ( ) ; err ! = nil { return nil , err } } if err ! = nil { return nil , err } const total = int ( 5 * time . Second / rate ) attempt : = 1 for { if attempt = = total { file . Close ( ) return nil , errors . New ( " " ) } attempt + + return nil , err } } last Hash = f . hash } return file , nil } 
func ( h * HTTP ) Init ( ) error { } h . lasts = map [ string ] string { } if h . Interval = = 0 { h . Interval = 5 * time . Minute } if h . Check Headers = = nil { h . Check Headers = default HTTPCheck Headers } return nil } 
func ( h * HTTP ) Fetch ( ) ( io . Reader , error ) { } h . delay = true if err ! = nil { return nil , fmt . Errorf ( " " , err ) } resp . Body . Close ( ) if resp . Status Code ! = http . Status OK { return nil , fmt . Errorf ( " " , resp . Status Code ) } for _ , header : = range h . Check Headers { if curr : = resp . Header . Get ( header ) ; curr ! = " " { if last , ok : = h . lasts [ header ] ; ok & & last = = curr { matches + + } h . lasts [ header ] = curr total + + } } if matches = = total { return nil , nil } if err ! = nil { return nil , fmt . Errorf ( " " , err ) } if resp . Status Code ! = http . Status OK { return nil , fmt . Errorf ( " " , resp . Status Code ) } } } 
func New Config ( ) * Config { c : = & Config { Config : * sarama . New Config ( ) , } c . Group . Partition Strategy = Strategy Range c . Group . Offsets . Retry . Max = 3 c . Group . Offsets . Synchronization . Dwell Time = c . Consumer . Max Processing Time c . Group . Session . Timeout = 3 0 * time . Second c . Group . Heartbeat . Interval = 3 * time . Second c . Config . Version = min Version return c } 
func ( c * Config ) Validate ( ) error { if c . Group . Heartbeat . Interval % time . Millisecond ! = 0 { sarama . Logger . Println ( " " ) } if c . Group . Session . Timeout % time . Millisecond ! = 0 { sarama . Logger . Println ( " " ) } if c . Group . Partition Strategy ! = Strategy Range & & c . Group . Partition Strategy ! = Strategy Round Robin { sarama . Logger . Println ( " " ) } if ! c . Version . Is At Least ( min Version ) { sarama . Logger . Println ( " " ) c . Version = min Version } if err : = c . Config . Validate ( ) ; err ! = nil { return err } case c . Group . Offsets . Synchronization . Dwell Time < = 0 : return sarama . Configuration Error ( " " ) case c . Group . Offsets . Synchronization . Dwell Time > 1 0 * time . Minute : return sarama . Configuration Error ( " " ) case c . Group . Heartbeat . Interval < = 0 : return sarama . Configuration Error ( " " ) case c . Group . Session . Timeout < = 0 : return sarama . Configuration Error ( " " ) case ! c . Metadata . Full & & c . Group . Topics . Whitelist ! = nil : return sarama . Configuration Error ( " " ) case ! c . Metadata . Full & & c . Group . Topics . Blacklist ! = nil : return sarama . Configuration Error ( " " ) } } return nil } 
func New Client ( addrs [ ] string , config * Config ) ( * Client , error ) { if config = = nil { config = New Config ( ) } if err : = config . Validate ( ) ; err ! = nil { return nil , err } client , err : = sarama . New Client ( addrs , & config . Config ) if err ! = nil { return nil , err } return & Client { Client : client , config : * config } , nil } 
func ( c * partition Consumer ) Async Close ( ) { c . close Once . Do ( func ( ) { c . close Err = c . Partition Consumer . Close ( ) close ( c . dying ) } ) } 
func ( c * partition Consumer ) Close ( ) error { c . Async Close ( ) < - c . dead return c . close Err } 
func ( c * partition Consumer ) Mark Offset ( offset int 6 4 , metadata string ) { c . mu . Lock ( ) if next : = offset + 1 ; next > c . state . Info . Offset { c . state . Info . Offset = next c . state . Info . Metadata = metadata c . state . Dirty = true } c . mu . Unlock ( ) } 
func New Consumer ( addrs [ ] string , group ID string , topics [ ] string , config * Config ) ( * Consumer , error ) { client , err : = New Client ( addrs , config ) if err ! = nil { return nil , err } consumer , err : = New Consumer From Client ( client , group ID , topics ) if err ! = nil { return nil , err } consumer . own Client = true return consumer , nil } 
func New Consumer From Client ( client * Client , group ID string , topics [ ] string ) ( * Consumer , error ) { if ! client . claim ( ) { return nil , err Client In Use } consumer , err : = sarama . New Consumer From Client ( client . Client ) if err ! = nil { client . release ( ) return nil , err } sort . Strings ( topics ) c : = & Consumer { client : client , consumer : consumer , subs : new Partition Map ( ) , group ID : group ID , core Topics : topics , dying : make ( chan none ) , dead : make ( chan none ) , messages : make ( chan * sarama . Consumer Message ) , errors : make ( chan error , client . config . Channel Buffer Size ) , partitions : make ( chan Partition Consumer , 1 ) , notifications : make ( chan * Notification ) , } if err : = c . client . Refresh Coordinator ( group ID ) ; err ! = nil { client . release ( ) return nil , err } go c . main Loop ( ) return c , nil } 
func ( c * Consumer ) Mark Partition Offset ( topic string , partition int 3 2 , offset int 6 4 , metadata string ) { if sub : = c . subs . Fetch ( topic , partition ) ; sub ! = nil { sub . Mark Offset ( offset , metadata ) } } 
func ( c * Consumer ) Mark Offsets ( s * Offset Stash ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for tp , info : = range s . offsets { if sub : = c . subs . Fetch ( tp . Topic , tp . Partition ) ; sub ! = nil { sub . Mark Offset ( info . Offset , info . Metadata ) } delete ( s . offsets , tp ) } } 
func ( c * Consumer ) Reset Offset ( msg * sarama . Consumer Message , metadata string ) { if sub : = c . subs . Fetch ( msg . Topic , msg . Partition ) ; sub ! = nil { sub . Reset Offset ( msg . Offset , metadata ) } } 
func ( c * Consumer ) Reset Partition Offset ( topic string , partition int 3 2 , offset int 6 4 , metadata string ) { sub : = c . subs . Fetch ( topic , partition ) if sub ! = nil { sub . Reset Offset ( offset , metadata ) } } 
func ( c * Consumer ) Commit Offsets ( ) error { c . commit Mu . Lock ( ) defer c . commit Mu . Unlock ( ) member ID , generation ID : = c . membership ( ) req : = & sarama . Offset Commit Request { Version : 2 , Consumer Group : c . group ID , Consumer Group Generation : generation ID , Consumer ID : member ID , Retention Time : - 1 , } if ns : = c . client . config . Consumer . Offsets . Retention ; ns ! = 0 { req . Retention Time = int 6 4 ( ns / time . Millisecond ) } snap : = c . subs . Snapshot ( ) dirty : = false for tp , state : = range snap { if state . Dirty { dirty = true req . Add Block ( tp . Topic , tp . Partition , state . Info . Offset , 0 , state . Info . Metadata ) } } if ! dirty { return nil } broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return err } resp , err : = broker . Commit Offset ( req ) if err ! = nil { c . close Coordinator ( broker , err ) return err } for topic , errs : = range resp . Errors { for partition , kerr : = range errs { if kerr ! = sarama . Err No Error { err = kerr } else if state , ok : = snap [ topic Partition { topic , partition } ] ; ok { if sub : = c . subs . Fetch ( topic , partition ) ; sub ! = nil { sub . mark Committed ( state . Info . Offset ) } } } } return err } 
func ( c * Consumer ) Close ( ) ( err error ) { c . close Once . Do ( func ( ) { close ( c . dying ) < - c . dead if e : = c . release ( ) ; e ! = nil { err = e } if e : = c . consumer . Close ( ) ; e ! = nil { err = e } close ( c . messages ) close ( c . errors ) if e : = c . leave Group ( ) ; e ! = nil { err = e } close ( c . partitions ) close ( c . notifications ) for range c . errors { } for p : = range c . partitions { _ = p . Close ( ) } for range c . notifications { } c . client . release ( ) if c . own Client { if e : = c . client . Close ( ) ; e ! = nil { err = e } } } ) return } 
func ( c * Consumer ) hb Loop ( stopped < - chan none ) { ticker : = time . New Ticker ( c . client . config . Group . Heartbeat . Interval ) defer ticker . Stop ( ) for { select { case < - ticker . C : switch err : = c . heartbeat ( ) ; err { case nil , sarama . Err No Error : case sarama . Err Not Coordinator For Consumer , sarama . Err Rebalance In Progress : return default : c . handle Error ( & Error { Ctx : " " , error : err } ) return } case < - stopped : return case < - c . dying : return } } } 
func ( c * Consumer ) tw Loop ( stopped < - chan none ) { ticker : = time . New Ticker ( c . client . config . Metadata . Refresh Frequency / 2 ) defer ticker . Stop ( ) for { select { case < - ticker . C : topics , err : = c . client . Topics ( ) if err ! = nil { c . handle Error ( & Error { Ctx : " " , error : err } ) return } for _ , topic : = range topics { if ! c . is Known Core Topic ( topic ) & & ! c . is Known Extra Topic ( topic ) & & c . is Potential Extra Topic ( topic ) { return } } case < - stopped : return case < - c . dying : return } } } 
func ( c * Consumer ) cm Loop ( stopped < - chan none ) { ticker : = time . New Ticker ( c . client . config . Consumer . Offsets . Commit Interval ) defer ticker . Stop ( ) for { select { case < - ticker . C : if err : = c . commit Offsets With Retry ( c . client . config . Group . Offsets . Retry . Max ) ; err ! = nil { c . handle Error ( & Error { Ctx : " " , error : err } ) return } case < - stopped : return case < - c . dying : return } } } 
func ( c * Consumer ) release ( ) ( err error ) { defer timeout . Stop ( ) select { case < - c . dying : case < - timeout . C : } } return } 
func ( c * Consumer ) heartbeat ( ) error { broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return err } member ID , generation ID : = c . membership ( ) resp , err : = broker . Heartbeat ( & sarama . Heartbeat Request { Group Id : c . group ID , Member Id : member ID , Generation Id : generation ID , } ) if err ! = nil { c . close Coordinator ( broker , err ) return err } return resp . Err } 
func ( c * Consumer ) rebalance ( ) ( map [ string ] [ ] int 3 2 , error ) { member ID , _ : = c . membership ( ) sarama . Logger . Printf ( " \n " , member ID ) all Topics , err : = c . client . Topics ( ) if err ! = nil { return nil , err } c . extra Topics = c . select Extra Topics ( all Topics ) sort . Strings ( c . extra Topics ) switch { case err = = sarama . Err Unknown Member Id : c . membership Mu . Lock ( ) c . member ID = " " c . membership Mu . Unlock ( ) return nil , err case err ! = nil : return nil , err } switch { case err = = sarama . Err Rebalance In Progress : return nil , err case err ! = nil : _ = c . leave Group ( ) return nil , err } return subs , nil } 
func ( c * Consumer ) subscribe ( tomb * loop Tomb , subs map [ string ] [ ] int 3 2 ) error { if err ! = nil { _ = c . leave Group ( ) return err } var wg sync . Wait Group for topic , partitions : = range subs { for _ , partition : = range partitions { wg . Add ( 1 ) info : = offsets [ topic ] [ partition ] go func ( topic string , partition int 3 2 ) { if e : = c . create Consumer ( tomb , topic , partition , info ) ; e ! = nil { mu . Lock ( ) err = e mu . Unlock ( ) } wg . Done ( ) } ( topic , partition ) } } wg . Wait ( ) if err ! = nil { _ = c . release ( ) _ = c . leave Group ( ) } return err } 
func ( c * Consumer ) join Group ( ) ( * balancer , error ) { member ID , _ : = c . membership ( ) req : = & sarama . Join Group Request { Group Id : c . group ID , Member Id : member ID , Session Timeout : int 3 2 ( c . client . config . Group . Session . Timeout / time . Millisecond ) , Protocol Type : " " , } meta : = & sarama . Consumer Group Member Metadata { Version : 1 , Topics : append ( c . core Topics , c . extra Topics . . . ) , User Data : c . client . config . Group . Member . User Data , } err : = req . Add Group Protocol Metadata ( string ( Strategy Range ) , meta ) if err ! = nil { return nil , err } err = req . Add Group Protocol Metadata ( string ( Strategy Round Robin ) , meta ) if err ! = nil { return nil , err } broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } resp , err : = broker . Join Group ( req ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } else if resp . Err ! = sarama . Err No Error { c . close Coordinator ( broker , resp . Err ) return nil , resp . Err } var strategy * balancer if resp . Leader Id = = resp . Member Id { members , err : = resp . Get Members ( ) if err ! = nil { return nil , err } strategy , err = new Balancer From Meta ( c . client , Strategy ( resp . Group Protocol ) , members ) if err ! = nil { return nil , err } } c . membership Mu . Lock ( ) c . member ID = resp . Member Id c . generation ID = resp . Generation Id c . membership Mu . Unlock ( ) return strategy , nil } 
func ( c * Consumer ) sync Group ( strategy * balancer ) ( map [ string ] [ ] int 3 2 , error ) { member ID , generation ID : = c . membership ( ) req : = & sarama . Sync Group Request { Group Id : c . group ID , Member Id : member ID , Generation Id : generation ID , } if strategy ! = nil { for member ID , topics : = range strategy . Perform ( ) { if err : = req . Add Group Assignment Member ( member ID , & sarama . Consumer Group Member Assignment { Topics : topics , } ) ; err ! = nil { return nil , err } } } broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } resp , err : = broker . Sync Group ( req ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } else if resp . Err ! = sarama . Err No Error { c . close Coordinator ( broker , resp . Err ) return nil , resp . Err } } if err ! = nil { return nil , err } } return members . Topics , nil } 
func ( c * Consumer ) fetch Offsets ( subs map [ string ] [ ] int 3 2 ) ( map [ string ] map [ int 3 2 ] offset Info , error ) { offsets : = make ( map [ string ] map [ int 3 2 ] offset Info , len ( subs ) ) req : = & sarama . Offset Fetch Request { Version : 1 , Consumer Group : c . group ID , } for topic , partitions : = range subs { offsets [ topic ] = make ( map [ int 3 2 ] offset Info , len ( partitions ) ) for _ , partition : = range partitions { offsets [ topic ] [ partition ] = offset Info { Offset : - 1 } req . Add Partition ( topic , partition ) } } broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } resp , err : = broker . Fetch Offset ( req ) if err ! = nil { c . close Coordinator ( broker , err ) return nil , err } for topic , partitions : = range subs { for _ , partition : = range partitions { block : = resp . Get Block ( topic , partition ) if block = = nil { return nil , sarama . Err Incomplete Response } if block . Err = = sarama . Err No Error { offsets [ topic ] [ partition ] = offset Info { Offset : block . Offset , Metadata : block . Metadata } } else { return nil , block . Err } } } return offsets , nil } 
func ( c * Consumer ) leave Group ( ) error { broker , err : = c . client . Coordinator ( c . group ID ) if err ! = nil { c . close Coordinator ( broker , err ) return err } member ID , _ : = c . membership ( ) if _ , err = broker . Leave Group ( & sarama . Leave Group Request { Group Id : c . group ID , Member Id : member ID , } ) ; err ! = nil { c . close Coordinator ( broker , err ) } return err } 
func ( c * Consumer ) create Consumer ( tomb * loop Tomb , topic string , partition int 3 2 , info offset Info ) error { member ID , _ : = c . membership ( ) sarama . Logger . Printf ( " \n " , member ID , topic , partition , info . Next Offset ( c . client . config . Consumer . Offsets . Initial ) ) if err ! = nil { return err } } else { pc . multiplex ( stopper , c . messages , c . errors ) } } ) if c . client . config . Group . Mode = = Consumer Mode Partitions { select { case c . partitions < - pc : case < - c . dying : pc . Close ( ) } } return nil } 
func ( s * Offset Stash ) Mark Offset ( msg * sarama . Consumer Message , metadata string ) { s . Mark Partition Offset ( msg . Topic , msg . Partition , msg . Offset , metadata ) } 
func ( s * Offset Stash ) Mark Partition Offset ( topic string , partition int 3 2 , offset int 6 4 , metadata string ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) key : = topic Partition { Topic : topic , Partition : partition } if info : = s . offsets [ key ] ; offset > = info . Offset { info . Offset = offset info . Metadata = metadata s . offsets [ key ] = info } } 
func ( s * Offset Stash ) Reset Offset ( msg * sarama . Consumer Message , metadata string ) { s . Reset Partition Offset ( msg . Topic , msg . Partition , msg . Offset , metadata ) } 
func ( s * Offset Stash ) Offsets ( ) map [ string ] int 6 4 { s . mu . Lock ( ) defer s . mu . Unlock ( ) res : = make ( map [ string ] int 6 4 , len ( s . offsets ) ) for tp , info : = range s . offsets { res [ tp . String ( ) ] = info . Offset } return res } 
func ( r * Instance Group ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) if r . Cached Actual ! = nil { logger . Debug ( " " ) return immutable , r . Cached Actual , nil } new Resource : = & Instance Group { Shared : Shared { Name : r . Name , Cloud ID : r . Server Pool . Identifier , } , } project , err : = Sdk . Service . Projects . Get ( immutable . Provider Config ( ) . Cloud Id ) . Do ( ) if err ! = nil & & project ! = nil { instances , err : = Sdk . Service . Instances . List ( immutable . Provider Config ( ) . Cloud Id , immutable . Provider Config ( ) . Location ) . Do ( ) if err ! = nil { return nil , nil , err } count : = len ( instances . Items ) if count > 0 { new Resource . Count = count instance : = instances . Items [ 0 ] new Resource . Name = instance . Name new Resource . Cloud ID = string ( instance . Id ) new Resource . Size = instance . Kind new Resource . Image = r . Image new Resource . Location = instance . Zone } } new Resource . Bootstrap Scripts = r . Server Pool . Bootstrap Scripts new Resource . SSHFingerprint = immutable . Provider Config ( ) . SSH . Public Key Fingerprint new Resource . Name = r . Name r . Cached Actual = new Resource return immutable , new Resource , nil } 
func ( r * Instance Group ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) if r . Cached Expected ! = nil { logger . Debug ( " " ) return immutable , r . Cached Expected , nil } expected : = & Instance Group { Shared : Shared { Name : r . Name , Cloud ID : r . Server Pool . Identifier , } , Size : r . Server Pool . Size , Location : immutable . Provider Config ( ) . Location , Image : r . Server Pool . Image , Count : r . Server Pool . Max Count , SSHFingerprint : immutable . Provider Config ( ) . SSH . Public Key Fingerprint , Bootstrap Scripts : r . Server Pool . Bootstrap Scripts , } r . Cached Expected = expected return immutable , expected , nil } 
func ( r * Instance Group ) Apply ( actual , expected cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) apply Resource : = expected . ( * Instance Group ) is Equal , err : = compare . Is Equal ( actual . ( * Instance Group ) , expected . ( * Instance Group ) ) if err ! = nil { return nil , nil , err } if is Equal { return immutable , apply Resource , nil } master IPPrivate : = " " master IPPublic : = " " if r . Server Pool . Type = = cluster . Server Pool Type Node { found : = false for i : = 0 ; i < Master IPAttempts ; i + + { master Tag : = " " machine Configs : = immutable . Machine Provider Configs ( ) for _ , machine Config : = range machine Configs { server Pool : = machine Config . Server Pool if server Pool . Type = = cluster . Server Pool Type Master { master Tag = server Pool . Name } } if master Tag = = " " { return nil , nil , fmt . Errorf ( " " ) } instance Group Manager , err : = Sdk . Service . Instance Group Managers . List Managed Instances ( immutable . Provider Config ( ) . Cloud Id , expected . ( * Instance Group ) . Location , strings . To Lower ( master Tag ) ) . Do ( ) if err ! = nil { return nil , nil , err } if err ! = nil | | len ( instance Group Manager . Managed Instances ) = = 0 { logger . Debug ( " " , err ) time . Sleep ( time . Duration ( Master IPSleep Seconds Per Attempt ) * time . Second ) continue } parts : = strings . Split ( instance Group Manager . Managed Instances [ 0 ] . Instance , " " ) instance , err : = Sdk . Service . Instances . Get ( immutable . Provider Config ( ) . Cloud Id , expected . ( * Instance Group ) . Location , parts [ len ( parts ) - 1 ] ) . Do ( ) if err ! = nil { logger . Debug ( " " , err ) time . Sleep ( time . Duration ( Master IPSleep Seconds Per Attempt ) * time . Second ) continue } for _ , network Interface : = range instance . Network Interfaces { if network Interface . Name = = " " { master IPPrivate = network Interface . Network IP for _ , access Configs : = range network Interface . Access Configs { master IPPublic = access Configs . Nat IP } } } if master IPPublic = = " " { logger . Debug ( " " ) time . Sleep ( time . Duration ( Master IPSleep Seconds Per Attempt ) * time . Second ) continue } found = true provider Config : = immutable . Provider Config ( ) provider Config . Values . Item Map [ " " ] = fmt . Sprintf ( " " , master IPPrivate , immutable . Provider Config ( ) . Kubernetes API . Port ) immutable . Set Provider Config ( provider Config ) break } if ! found { return nil , nil , fmt . Errorf ( " " ) } } provider Config : = immutable . Provider Config ( ) provider Config . Values . Item Map [ " " ] = immutable . Provider Config ( ) . Kubernetes API . Port immutable . Set Provider Config ( provider Config ) scripts , err : = script . Build Bootstrap Script ( r . Server Pool . Bootstrap Scripts , immutable ) if err ! = nil { return nil , nil , err } final Scripts : = string ( scripts ) if err ! = nil { return nil , nil , err } tags : = [ ] string { } if r . Server Pool . Type = = cluster . Server Pool Type Master { if immutable . Provider Config ( ) . Kubernetes API . Port = = " " { tags = append ( tags , " " ) } if immutable . Provider Config ( ) . Kubernetes API . Port = = " " { tags = append ( tags , " " ) } tags = append ( tags , " " ) } if r . Server Pool . Type = = cluster . Server Pool Type Node { tags = append ( tags , " " ) } prefix : = " " + immutable . Provider Config ( ) . Cloud Id image URL : = " " + expected . ( * Instance Group ) . Image template Instance , err : = Sdk . Service . Instance Templates . Get ( immutable . Provider Config ( ) . Cloud Id , strings . To Lower ( expected . ( * Instance Group ) . Name ) ) . Do ( ) if err ! = nil { ssh Public Key Value : = fmt . Sprintf ( " " , immutable . Provider Config ( ) . SSH . User , string ( immutable . Provider Config ( ) . SSH . Public Key Data ) ) template Instance = & compute . Instance Template { Name : strings . To Lower ( expected . ( * Instance Group ) . Name ) , Properties : & compute . Instance Properties { Machine Type : expected . ( * Instance Group ) . Size , Disks : [ ] * compute . Attached Disk { { Auto Delete : true , Boot : true , Type : " " , Initialize Params : & compute . Attached Disk Initialize Params { Source Image : image URL , } , } , } , Network Interfaces : [ ] * compute . Network Interface { { Access Configs : [ ] * compute . Access Config { { Type : " " , Name : " " , } , } , Network : prefix + " " , } , } , Service Accounts : [ ] * compute . Service Account { { Email : " " , Scopes : [ ] string { compute . Devstorage Full Control Scope , compute . Compute Scope , } , } , } , Metadata : & compute . Metadata { Kind : " " , Items : [ ] * compute . Metadata Items { { Key : " " , Value : & ssh Public Key Value , } , { Key : " " , Value : & final Scripts , } , } , } , Tags : & compute . Tags { Items : tags , } , } , } _ , err = Sdk . Service . Instance Templates . Insert ( immutable . Provider Config ( ) . Cloud Id , template Instance ) . Do ( ) if err ! = nil { return nil , nil , err } } _ , err = Sdk . Service . Instance Group Managers . Get ( immutable . Provider Config ( ) . Cloud Id , expected . ( * Instance Group ) . Location , strings . To Lower ( expected . ( * Instance Group ) . Name ) ) . Do ( ) if err ! = nil { instance Group Manager : = & compute . Instance Group Manager { Name : template Instance . Name , Base Instance Name : template Instance . Name , Instance Template : prefix + " " + template Instance . Name , Target Size : int 6 4 ( expected . ( * Instance Group ) . Count ) , } for i : = 0 ; i < Master IPAttempts ; i + + { logger . Debug ( " " ) _ , err = Sdk . Service . Instance Group Managers . Insert ( immutable . Provider Config ( ) . Cloud Id , expected . ( * Instance Group ) . Location , instance Group Manager ) . Do ( ) if err = = nil { break } logger . Debug ( " " ) time . Sleep ( time . Duration ( Master IPSleep Seconds Per Attempt ) * time . Second ) } logger . Success ( " " , template Instance . Name ) } new Resource : = & Instance Group { Shared : Shared { Name : r . Server Pool . Name , provider Config = immutable . Provider Config ( ) provider Config . Kubernetes API . Endpoint = master IPPublic immutable . Set Provider Config ( provider Config ) rendered Cluster , err : = r . immutable Render ( new Resource , immutable ) if err ! = nil { return nil , nil , err } return rendered Cluster , new Resource , nil } 
func ( r * Instance Group ) Delete ( actual cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) delete Resource : = actual . ( * Instance Group ) if delete Resource . Name = = " " { return nil , nil , fmt . Errorf ( " " , delete Resource . Name ) } logger . Success ( " " , r . Server Pool . Name ) _ , err : = Sdk . Service . Instance Group Managers . Get ( immutable . Provider Config ( ) . Cloud Id , immutable . Provider Config ( ) . Location , strings . To Lower ( r . Server Pool . Name ) ) . Do ( ) if err = = nil { _ , err : = Sdk . Service . Instance Group Managers . Delete ( immutable . Provider Config ( ) . Cloud Id , immutable . Provider Config ( ) . Location , strings . To Lower ( r . Server Pool . Name ) ) . Do ( ) if err ! = nil { return nil , nil , err } } _ , err = Sdk . Service . Instance Templates . Get ( immutable . Provider Config ( ) . Cloud Id , strings . To Lower ( r . Server Pool . Name ) ) . Do ( ) if err = = nil { err : = r . retry Delete Instance Template ( immutable ) if err ! = nil { return nil , nil , err } } provider Config . Kubernetes API . Endpoint = " " immutable . Set Provider Config ( provider Config ) rendered Cluster , err : = r . immutable Render ( actual , immutable ) if err ! = nil { return nil , nil , err } return rendered Cluster , actual , nil } 
func Get Reconciler ( known * cluster . Cluster , runtime Parameters * Runtime Parameters ) ( reconciler cloud . Reconciler , err error ) { switch known . Provider Config ( ) . Cloud { case cluster . Cloud Google : sdk , err : = google SDK . New Sdk ( ) if err ! = nil { return nil , err } gr . Sdk = sdk return cloud . New Atomic Reconciler ( known , compute . New Google Compute Model ( known ) ) , nil case cluster . Cloud Digital Ocean : sdk , err : = godo Sdk . New Sdk ( ) if err ! = nil { return nil , err } dr . Sdk = sdk return cloud . New Atomic Reconciler ( known , droplet . New Digital Ocean Droplet Model ( known ) ) , nil case cluster . Cloud Amazon : aws Profile : = " " if runtime Parameters ! = nil { aws Profile = runtime Parameters . Aws Profile } sdk , err : = aws Sdk Go . New Sdk ( known . Provider Config ( ) . Location , aws Profile ) if err ! = nil { return nil , err } ar . Sdk = sdk return cloud . New Atomic Reconciler ( known , awspub . New Amazon Public Model ( known ) ) , nil case cluster . Cloud Azure : sdk , err : = azure SDK . New Sdk ( ) if err ! = nil { return nil , err } azr . Sdk = sdk return cloud . New Atomic Reconciler ( known , azpub . New Azure Public Model ( known ) ) , nil case cluster . Cloud OVH : sdk , err : = openstack Sdk . New Sdk ( known . Provider Config ( ) . Location ) if err ! = nil { return nil , err } osr . Sdk = sdk return cloud . New Atomic Reconciler ( known , osovh . New Ovh Public Model ( known ) ) , nil case cluster . Cloud Packet : sdk , err : = packet SDK . New Sdk ( ) if err ! = nil { return nil , err } packetr . Sdk = sdk return cloud . New Atomic Reconciler ( known , packetpub . New Packet Public Model ( known ) ) , nil case cluster . Cloud ECS : sdk , err : = openstack Sdk . New Sdk ( known . Provider Config ( ) . Location ) if err ! = nil { return nil , err } osr . Sdk = sdk return cloud . New Atomic Reconciler ( known , osecs . New Ecs Public Model ( known ) ) , nil default : return nil , fmt . Errorf ( " " , known . Provider Config ( ) . Cloud ) } } 
func Get Version ( ) * Version { return & Version { Version : Kubicorn Version , Git Commit : Git Sha , Build Date : time . Now ( ) . UTC ( ) . String ( ) , Go Version : runtime . Version ( ) , GOOS : runtime . GOOS , GOArch : runtime . GOARCH , } } 
func Get Version JSON ( ) string { ver Bytes , err : = json . Marshal ( Get Version ( ) ) if err ! = nil { logger . Critical ( " " , err ) } return string ( ver Bytes ) } 
func ( r * Resource Group ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) new Resource : = & Resource Group { Shared : Shared { Name : r . Name , Tags : r . Tags , Identifier : immutable . Provider Config ( ) . Group Identifier , } , Location : r . Location , } if r . Identifier ! = " " { group , err : = Sdk . Resource Group . Get ( immutable . Name ) if err ! = nil { return nil , nil , err } new Resource . Location = * group . Location new Resource . Name = * group . Name new Resource . Identifier = * group . ID } new Cluster : = r . immutable Render ( new Resource , immutable ) return new Cluster , new Resource , nil } 
func ( r * Resource Group ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) new Resource : = & Resource Group { Shared : Shared { Name : immutable . Name , Tags : r . Tags , Identifier : immutable . Provider Config ( ) . Group Identifier , } , Location : immutable . Provider Config ( ) . Location , } new Cluster : = r . immutable Render ( new Resource , immutable ) return new Cluster , new Resource , nil } 
func Create Cmd ( ) * cobra . Command { var co = & cli . Create Options { } var create Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to create a Kubicorn API model in a defined state store . This command will create a cluster API model as a YAML manifest in a state store . Once the API model has been created , a user can optionally change the model to their liking . After a model is defined and configured properly , the user can then apply the model . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : co . Name = viper . Get String ( key Kubicorn Name ) if co . Name = = " " { co . Name = namer . Random Name ( ) } case 1 : co . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = Run Create ( co ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = create Cmd . Flags ( ) bind Common State Store Flags ( & co . State Store Options , fs ) bind Common Aws Flags ( & co . Aws Options , fs ) fs . String Var P ( & co . Profile , key Profile , " " , viper . Get String ( key Profile ) , desc Profile ) fs . String Var P ( & co . Cloud ID , key Cloud ID , " " , viper . Get String ( key Cloud ID ) , desc Cloud ID ) fs . String Var ( & co . Kube Config Local File , key Kube Config Local File , viper . Get String ( key Kube Config Local File ) , desc Kube Config Local File ) fs . String Array Var P ( & co . Set , key Set , " " , viper . Get String Slice ( key Set ) , desc Set ) fs . String Array Var P ( & co . Master Set , key Master Set , " " , viper . Get String Slice ( key Master Set ) , desc Master Set ) fs . String Array Var P ( & co . Node Set , key Node Set , " " , viper . Get String Slice ( key Node Set ) , desc Node Set ) fs . String Var P ( & co . Git Remote , key Git Config , " " , viper . Get String ( key Git Config ) , desc Git Config ) fs . String Array Var ( & co . Aws Options . Policy Attachments , key Policy Attachments , co . Aws Options . Policy Attachments , desc Policy Attachments ) flag Apply Annotations ( create Cmd , " " , " " ) flag Apply Annotations ( create Cmd , " " , " " ) create Cmd . Set Usage Template ( cli . Usage Template ) return create Cmd } 
func Run Create ( options * cli . Create Options ) error { var new Cluster * cluster . Cluster if _ , ok : = cli . Profile Map Indexed [ options . Profile ] ; ok { new Cluster = cli . Profile Map Indexed [ options . Profile ] . Profile Func ( name ) } else { return fmt . Errorf ( " " , options . Profile ) } if options . Kube Config Local File ! = " " { if new Cluster . Annotations = = nil { new Cluster . Annotations = make ( map [ string ] string ) } new Cluster . Annotations [ kubeconfig . Cluster Annotation Kubeconfig Local File ] = options . Kube Config Local File } if len ( options . Set ) > 0 { if len ( parts ) = = 1 { continue } provider Config : = new Cluster . Provider Config ( ) err : = cli . Swalker Write ( strings . Title ( parts [ 0 ] ) , provider Config , parts [ 1 ] ) if err ! = nil { } new Cluster . Set Provider Config ( provider Config ) } } if len ( options . Master Set ) > 0 { if len ( parts ) = = 1 { continue } for i , ms : = range new Cluster . Machine Sets { is Master : = false for _ , role : = range ms . Spec . Template . Spec . Roles { if role = = v 1alpha 1 . Master Role { is Master = true break } } if ! is Master { continue } pc Str : = ms . Spec . Template . Spec . Provider Config provider Config : = & cluster . Machine Provider Config { } json . Unmarshal ( [ ] byte ( pc Str ) , provider Config ) err : = cli . Swalker Write ( strings . Title ( parts [ 0 ] ) , provider Config , parts [ 1 ] ) if err ! = nil { } if err ! = nil { logger . Critical ( " " , err ) return err } str : = string ( bytes ) new Cluster . Machine Sets [ i ] . Spec . Template . Spec . Provider Config = str } } } if len ( options . Node Set ) > 0 { if len ( parts ) = = 1 { continue } for i , ms : = range new Cluster . Machine Sets { is Node : = false for _ , role : = range ms . Spec . Template . Spec . Roles { if role = = v 1alpha 1 . Node Role { is Node = true break } } if ! is Node { continue } pc Str : = ms . Spec . Template . Spec . Provider Config provider Config : = & cluster . Machine Provider Config { } json . Unmarshal ( [ ] byte ( pc Str ) , provider Config ) err : = cli . Swalker Write ( strings . Title ( parts [ 0 ] ) , provider Config , parts [ 1 ] ) if err ! = nil { } if err ! = nil { logger . Critical ( " " , err ) return err } str : = string ( bytes ) new Cluster . Machine Sets [ i ] . Spec . Template . Spec . Provider Config = str } } } if len ( options . Aws Options . Policy Attachments ) > 0 { for i , ms : = range new Cluster . Machine Sets { pc Str : = ms . Spec . Template . Spec . Provider Config provider Config : = & cluster . Machine Provider Config { } if err : = json . Unmarshal ( [ ] byte ( pc Str ) , provider Config ) ; err ! = nil { logger . Critical ( " " , err ) return err } if provider Config . Server Pool ! = nil & & provider Config . Server Pool . Instance Profile ! = nil & & provider Config . Server Pool . Instance Profile . Role ! = nil { provider Config . Server Pool . Instance Profile . Role . Policy Attachments = options . Aws Options . Policy Attachments } if err ! = nil { logger . Critical ( " " , err ) return err } str : = string ( bytes ) new Cluster . Machine Sets [ i ] . Spec . Template . Spec . Provider Config = str } } if new Cluster . Provider Config ( ) . Cloud = = cluster . Cloud Google & & options . Cloud ID = = " " { return fmt . Errorf ( " " ) } provider Config : = new Cluster . Provider Config ( ) provider Config . Cloud Id = options . Cloud ID new Cluster . Set Provider Config ( provider Config ) if err ! = nil { return err } else if state Store . Exists ( ) { return fmt . Errorf ( " " , name , options . State Store Path + " " + name ) } if err ! = nil { return fmt . Errorf ( " " , err ) } logger . Always ( " " , options . State Store Path , name , name ) return nil } 
func New Centos Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Amazon , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Network : & cluster . Network { Type : cluster . Network Type Public , CIDR : " " , Internet GW : & cluster . Internet GW { } , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Instance Profile : & cluster . IAMInstance Profile { Name : fmt . Sprintf ( " " , name ) , Role : & cluster . IAMRole { Name : fmt . Sprintf ( " " , name ) , Policies : [ ] * cluster . IAMPolicy { { Name : " " , Document : ` { "Version " : " 2 0 1 2 - 1 0 - 1 7 " , "Statement " : [ { "Effect " : "Allow " , "Action " : [ "ec 2 : * " , "elasticloadbalancing : * " , "ecr :Get Authorization Token " , "ecr :Batch Check Layer Availability " , "ecr :Get Download Url For Layer " , "ecr :Get Repository Policy " , "ecr :Describe Repositories " , "ecr :List Images " , "ecr :Batch Get Image " , "autoscaling :Describe Auto Scaling Groups " , "autoscaling :Update Auto Scaling Group " ] , "Resource " : " * " } ] } ` , } , } , } , } , Subnets : [ ] * cluster . Subnet { { Name : fmt . Sprintf ( " " , name ) , CIDR : " " , Zone : " " , } , } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name , uuid . Time Ordered UUID ( ) ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , } , } , } , } , } , { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Node , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Instance Profile : & cluster . IAMInstance Profile { Name : fmt . Sprintf ( " " , name ) , Role : & cluster . IAMRole { Name : fmt . Sprintf ( " " , name ) , Policies : [ ] * cluster . IAMPolicy { { Name : " " , Document : ` { "Version " : " 2 0 1 2 - 1 0 - 1 7 " , "Statement " : [ { "Effect " : "Allow " , "Action " : [ "ec 2 :Describe * " , "ec 2 :Attach Volume " , "ec 2 :Detach Volume " , "ecr :Get Authorization Token " , "ecr :Batch Check Layer Availability " , "ecr :Get Download Url For Layer " , "ecr :Get Repository Policy " , "ecr :Describe Repositories " , "ecr :List Images " , "ecr :Batch Get Image " , "autoscaling :Describe Auto Scaling Groups " , "autoscaling :Update Auto Scaling Group " ] , "Resource " : " * " } ] } ` , } , } , } , } , Subnets : [ ] * cluster . Subnet { { Name : fmt . Sprintf ( " " , name ) , CIDR : " " , Zone : " " , } , } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name , uuid . Time Ordered UUID ( ) ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , } , } , } , } , } , } c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) return c } 
func ( m * Model ) Resources ( ) map [ int ] cloud . Resource { if len ( m . cached Resources ) > 0 { return m . cached Resources } r : = make ( map [ int ] cloud . Resource ) i : = 0 i + + machine Configs : = m . known . Machine Provider Configs ( ) for _ , machine Config : = range machine Configs { server Pool : = machine Config . Server Pool i + + } for _ , machine Config : = range machine Configs { server Pool : = machine Config . Server Pool for _ , firewall : = range server Pool . Firewalls { for _ , rule : = range firewall . Ingress Rules { var src * resources . Sources if _ , _ , err : = net . Parse CIDR ( rule . Ingress Source ) ; err = = nil { src = & resources . Sources { Addresses : [ ] string { rule . Ingress Source } , } } else if ip : = net . Parse IP ( rule . Ingress Source ) ; ip ! = nil { src = & resources . Sources { Addresses : [ ] string { rule . Ingress Source } , } } else { src = & resources . Sources { Tags : [ ] string { rule . Ingress Source } , } } Inbound Rule : = resources . Inbound Rule { Protocol : rule . Ingress Protocol , Port Range : rule . Ingress To Port , Source : src , } f . Inbound Rules = append ( f . Inbound Rules , Inbound Rule ) } for _ , rule : = range firewall . Egress Rules { var dest * resources . Destinations if _ , _ , err : = net . Parse CIDR ( rule . Egress Destination ) ; err = = nil { dest = & resources . Destinations { Addresses : [ ] string { rule . Egress Destination } , } } else if ip : = net . Parse IP ( rule . Egress Destination ) ; ip ! = nil { dest = & resources . Destinations { Addresses : [ ] string { rule . Egress Destination } , } } else { dest = & resources . Destinations { Tags : [ ] string { rule . Egress Destination } , } } Outbound Rule : = resources . Outbound Rule { Protocol : rule . Egress Protocol , Port Range : rule . Egress To Port , Destinations : dest , } f . Outbound Rules = append ( f . Outbound Rules , Outbound Rule ) } r [ i ] = f i + + } } m . cached Resources = r return m . cached Resources } 
func New Controller Ubuntu Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Digital Ocean , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : fmt . Sprintf ( " " , name ) , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : fmt . Sprintf ( " " , name ) , Ingress Protocol : " " , } , } , Egress Rules : [ ] * cluster . Egress Rule { { Egress To Port : " " , deployment : = & appsv 1beta 2 . Deployment { Object Meta : metav 1 . Object Meta { Name : " " , } , Spec : appsv 1beta 2 . Deployment Spec { Replicas : ptrconvenient . Int 3 2Ptr ( 1 ) , Selector : & metav 1 . Label Selector { Match Labels : map [ string ] string { " " : " " , } , } , Template : apiv 1 . Pod Template Spec { Object Meta : metav 1 . Object Meta { Labels : map [ string ] string { " " : " " , } , } , Spec : apiv 1 . Pod Spec { Containers : [ ] apiv 1 . Container { { Name : " " , Image : " " , c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) cpms . Spec . Replicas = ptrconvenient . Int 3 2Ptr ( 3 ) c . Machine Sets [ 1 ] = cpms secret : = & apiv 1 . Secret { Object Meta : metav 1 . Object Meta { Name : " " , Namespace : " " , } , String Data : map [ string ] string { " " : string ( os . Getenv ( " " ) ) } , } c . APIToken Secret = secret return c } 
func Read From Resource ( r string ) ( string , error ) { env : = os . Getenv ( " " ) if dev Mode ! = " " { logger . Info ( " " , r ) return read From FS ( r ) } switch { logger . Info ( " " , git Hub Url ) url , err : = url . Parse Request URI ( git Hub Url ) if err ! = nil { return " " , err } return read From HTTP ( url ) logger . Info ( " " , url ) if err ! = nil { return " " , err } return read From HTTP ( url ) return read From FS ( r ) } } 
func Swalker Write ( exp string , obj interface { } , value string ) error { v , err : = swalker . Read ( exp , obj ) if err ! = nil { return err } rv : = reflect . Value Of ( v ) switch rv . Kind ( ) { case reflect . Int : i , err : = strconv . Parse Int ( value , 1 0 , 0 ) if err ! = nil { return err } return swalker . Write ( exp , obj , int ( i ) ) case reflect . Int 8 : i , err : = strconv . Parse Int ( value , 1 0 , 8 ) if err ! = nil { return err } return swalker . Write ( exp , obj , int 8 ( i ) ) case reflect . Int 1 6 : i , err : = strconv . Parse Int ( value , 1 0 , 1 6 ) if err ! = nil { return err } return swalker . Write ( exp , obj , int 1 6 ( i ) ) case reflect . Int 3 2 : i , err : = strconv . Parse Int ( value , 1 0 , 3 2 ) if err ! = nil { return err } return swalker . Write ( exp , obj , int 3 2 ( i ) ) case reflect . Int 6 4 : i , err : = strconv . Parse Int ( value , 1 0 , 6 4 ) if err ! = nil { return err } return swalker . Write ( exp , obj , i ) case reflect . Uint : i , err : = strconv . Parse Uint ( value , 1 0 , 0 ) if err ! = nil { return err } return swalker . Write ( exp , obj , uint ( i ) ) case reflect . Uint 8 : i , err : = strconv . Parse Uint ( value , 1 0 , 8 ) if err ! = nil { return err } return swalker . Write ( exp , obj , uint 8 ( i ) ) case reflect . Uint 1 6 : i , err : = strconv . Parse Uint ( value , 1 0 , 1 6 ) if err ! = nil { return err } return swalker . Write ( exp , obj , uint 1 6 ( i ) ) case reflect . Uint 3 2 : i , err : = strconv . Parse Uint ( value , 1 0 , 3 2 ) if err ! = nil { return err } return swalker . Write ( exp , obj , uint 3 2 ( i ) ) case reflect . Uint 6 4 : i , err : = strconv . Parse Uint ( value , 1 0 , 6 4 ) if err ! = nil { return err } return swalker . Write ( exp , obj , i ) case reflect . Bool : b , err : = strconv . Parse Bool ( value ) if err ! = nil { return err } return swalker . Write ( exp , obj , b ) } return swalker . Write ( exp , obj , value ) } 
func New Centos Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Digital Ocean , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : fmt . Sprintf ( " " , name ) , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : fmt . Sprintf ( " " , name ) , Ingress Protocol : " " , } , } , Egress Rules : [ ] * cluster . Egress Rule { { Egress To Port : " " , c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) secret : = & apiv 1 . Secret { Object Meta : metav 1 . Object Meta { Name : " " , Namespace : " " , } , String Data : map [ string ] string { " " : string ( os . Getenv ( " " ) ) } , } c . APIToken Secret = secret return c } 
func New Sdk ( ) ( * Sdk , error ) { sdk : = & Sdk { } api Token : = get Token ( ) if api Token = = " " { return nil , fmt . Errorf ( " " ) } sdk . Client = packngo . New Client ( " " , api Token , nil ) return sdk , nil } 
func New Ubuntu Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Azure , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , } , Egress Rules : [ ] * cluster . Egress Rule { { Egress To Port : " " , c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) return c } 
func ( c * Cluster ) Provider Config ( ) * Control Plane Provider Config { provider Config : = & Control Plane Provider Config { } err : = json . Unmarshal ( [ ] byte ( raw ) , provider Config ) if err ! = nil { logger . Critical ( " " , err ) } return provider Config } 
func ( c * Cluster ) Set Provider Config ( config * Control Plane Provider Config ) error { bytes , err : = json . Marshal ( config ) if err ! = nil { logger . Critical ( " " , err ) return err } str : = string ( bytes ) c . Cluster API . Spec . Provider Config = str return nil } 
func ( c * Cluster ) Machine Provider Configs ( ) [ ] * Machine Provider Config { var provider Configs [ ] * Machine Provider Config for _ , machine Set : = range c . Machine Sets { raw : = machine Set . Spec . Template . Spec . Provider Config provider Config : = & Machine Provider Config { } err : = json . Unmarshal ( [ ] byte ( raw ) , provider Config ) if err ! = nil { logger . Critical ( " " , err ) } provider Configs = append ( provider Configs , provider Config ) } return provider Configs } 
func ( c * Cluster ) Set Machine Provider Configs ( provider Configs [ ] * Machine Provider Config ) { for _ , provider Config : = range provider Configs { name : = provider Config . Server Pool . Name found : = false for _ , machine Set : = range c . Machine Sets { if machine Set . Name = = name { if err ! = nil { logger . Critical ( " " ) continue } str : = string ( bytes ) machine Set . Spec . Template . Spec . Provider Config = str found = true } } } } } 
func New Cluster ( name string ) * Cluster { return & Cluster { Name : name , Cluster API : & clusterv 1 . Cluster { Object Meta : metav 1 . Object Meta { Name : name , } , Spec : clusterv 1 . Cluster Spec { } , } , Control Plane : & clusterv 1 . Machine Set { } , } } 
func Deploy Controller Cmd ( ) * cobra . Command { var dco = & cli . Deploy Controller Options { } var deploy Controller Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to deploy a controller for a given cluster . As long as a controller is defined , this will create the deployment and the namespace . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : dco . Name = viper . Get String ( key Kubicorn Name ) case 1 : dco . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Deploy Controller ( dco ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = deploy Controller Cmd . Flags ( ) bind Common State Store Flags ( & dco . State Store Options , fs ) bind Common Aws Flags ( & dco . Aws Options , fs ) fs . String Var ( & dco . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) return deploy Controller Cmd } 
func New Retrier ( retries , sleep Seconds int , retryable Retryable ) * Retrier { return & Retrier { retries : retries , sleep Seconds : sleep Seconds , retryable : retryable , } } 
func ( r * Retrier ) Run Retry ( ) error { go sig Handler . Register ( ) finish : = make ( chan bool , 1 ) go func ( ) { select { case < - finish : return case < - time . After ( 1 0 * time . Second ) : return default : for { if sig Handler . Get State ( ) ! = 0 { logger . Critical ( " " ) os . Exit ( 1 ) } } } } ( ) for i : = 0 ; i < r . retries ; i + + { err : = r . retryable . Try ( ) if err ! = nil { logger . Info ( " " , err ) time . Sleep ( time . Duration ( r . sleep Seconds ) * time . Second ) continue } finish < - true return nil } finish < - true return fmt . Errorf ( " " , r . retries , r . sleep Seconds ) } 
func Must Generate Random Bytes ( length int ) [ ] byte { res , err : = Generate Random Bytes ( length ) if err ! = nil { panic ( " " ) } return res } 
func Generate Random Bytes ( length int ) ( [ ] byte , error ) { b : = make ( [ ] byte , length ) _ , err : = rand . Read ( b ) return b , err } 
func Generate Random Int ( min , max int ) int { return int ( Generate Random Int 6 4 ( int 6 4 ( min ) , int 6 4 ( max ) ) ) } 
func Generate Random Int 6 4 ( min , max int 6 4 ) int 6 4 { upper : = max - min n Big , err : = rand . Int ( rand . Reader , big . New Int ( upper ) ) if err ! = nil { panic ( err ) } return n Big . Int 6 4 ( ) + min } 
func Explain Cmd ( ) * cobra . Command { var exo = & cli . Explain Options { } var cmd = & cobra . Command { Use : " " , Short : " " , Long : `Output expected and actual state of the given cluster ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : exo . Name = viper . Get String ( key Kubicorn Name ) case 1 : exo . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Explain ( exo ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = cmd . Flags ( ) bind Common State Store Flags ( & exo . State Store Options , fs ) bind Common Aws Flags ( & exo . Aws Options , fs ) fs . String Var P ( & exo . Output , key Output , " " , viper . Get String ( key Output ) , desc Output ) fs . String Var ( & exo . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) return cmd } 
func Time Ordered UUID ( ) string { unix Time : = uint 3 2 ( time . Now ( ) . UTC ( ) . Unix ( ) ) return fmt . Sprintf ( " " , unix Time , rand . Must Generate Random Bytes ( 2 ) , rand . Must Generate Random Bytes ( 2 ) , rand . Must Generate Random Bytes ( 2 ) , rand . Must Generate Random Bytes ( 2 ) , rand . Must Generate Random Bytes ( 4 ) ) } 
func Get Config Cmd ( ) * cobra . Command { var cro = & cli . Get Config Options { } var get Config Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to pull a kubeconfig file from a cluster so you can use kubectl . This command will attempt to find a cluster , and append a local kubeconfig file with a kubeconfig ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : cro . Name = viper . Get String ( key Kubicorn Name ) case 1 : cro . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Get Config ( cro ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = get Config Cmd . Flags ( ) bind Common State Store Flags ( & cro . State Store Options , fs ) bind Common Aws Flags ( & cro . Aws Options , fs ) fs . String Var ( & cro . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) return get Config Cmd } 
func Prompt Cmd ( ) * cobra . Command { return & cobra . Command { Use : " " , Short : " " , Long : `Use this command to use the Kubicron API via a shell prompt . This command will open a prompt using go -prompt (with auto -completion ) to allow you to run commands interactively from the shell . Currently this doesn 't work on Windows systems . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { logger . Critical ( " " ) os . Exit ( 1 ) } , } } 
func Run Annotated ( task Task , description string , symbol string , options . . . interface { } ) error { done Ch : = make ( chan bool ) err Ch : = make ( chan error ) l : = logger . Log t : = Default Ticker for _ , o : = range options { if value , ok : = o . ( logger . Logger ) ; ok { l = value } else if value , ok : = o . ( * time . Ticker ) ; ok { t = value } } go func ( ) { err Ch < - task ( ) } ( ) l ( description ) log Activity ( symbol , l , t , done Ch ) err : = < - err Ch done Ch < - true return err } 
func log Activity ( symbol string , logger logger . Logger , ticker * time . Ticker , quit Ch < - chan bool ) { go func ( ) { for { select { case < - ticker . C : logger ( symbol ) case < - quit Ch : ticker . Stop ( ) return } } } ( ) } 
func List Cmd ( ) * cobra . Command { var lo = & cli . List Options { } var cmd = & cobra . Command { Use : " " , Short : " " , Long : `List the states available in the _state directory ` , Run : func ( cmd * cobra . Command , args [ ] string ) { if err : = run List ( lo ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = cmd . Flags ( ) bind Common State Store Flags ( & lo . State Store Options , fs ) bind Common Aws Flags ( & lo . Aws Options , fs ) fs . Bool Var P ( & no Headers , key No Headers , " " , viper . Get Bool ( key No Headers ) , des No Headers ) return cmd } 
func New Ubuntu Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Packet , Project : & cluster . Project { Name : fmt . Sprintf ( " " , name ) , } , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , } , } , { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Node , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , } , } , } c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) return c } 
func New Controller Ubuntu Cluster ( name string ) * cluster . Cluster { control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud Amazon , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Network : & cluster . Network { Type : cluster . Network Type Public , CIDR : " " , Internet GW : & cluster . Internet GW { } , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Instance Profile : & cluster . IAMInstance Profile { Name : fmt . Sprintf ( " " , name ) , Role : & cluster . IAMRole { Name : fmt . Sprintf ( " " , name ) , Policies : [ ] * cluster . IAMPolicy { { Name : " " , Document : ` { "Version " : " 2 0 1 2 - 1 0 - 1 7 " , "Statement " : [ { "Effect " : "Allow " , "Action " : [ "ec 2 : * " , "elasticloadbalancing : * " , "ecr :Get Authorization Token " , "ecr :Batch Check Layer Availability " , "ecr :Get Download Url For Layer " , "ecr :Get Repository Policy " , "ecr :Describe Repositories " , "ecr :List Images " , "ecr :Batch Get Image " , "autoscaling :Describe Auto Scaling Groups " , "autoscaling :Update Auto Scaling Group " ] , "Resource " : " * " } ] } ` , } , } , } , } , Subnets : [ ] * cluster . Subnet { { Name : fmt . Sprintf ( " " , name ) , CIDR : " " , Zone : " " , } , } , Aws Configuration : & cluster . Aws Configuration { } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name , uuid . Time Ordered UUID ( ) ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , } , } , } , } , } , { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Node , Name : fmt . Sprintf ( " " , name ) , Max Count : 1 , Min Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Instance Profile : & cluster . IAMInstance Profile { Name : fmt . Sprintf ( " " , name ) , Role : & cluster . IAMRole { Name : fmt . Sprintf ( " " , name ) , Policies : [ ] * cluster . IAMPolicy { { Name : " " , Document : ` { "Version " : " 2 0 1 2 - 1 0 - 1 7 " , "Statement " : [ { "Effect " : "Allow " , "Action " : [ "ec 2 :Describe * " , "ec 2 :Attach Volume " , "ec 2 :Detach Volume " , "ecr :Get Authorization Token " , "ecr :Batch Check Layer Availability " , "ecr :Get Download Url For Layer " , "ecr :Get Repository Policy " , "ecr :Describe Repositories " , "ecr :List Images " , "ecr :Batch Get Image " , "autoscaling :Describe Auto Scaling Groups " , "autoscaling :Update Auto Scaling Group " ] , "Resource " : " * " } ] } ` , } , } , } , } , Subnets : [ ] * cluster . Subnet { { Name : fmt . Sprintf ( " " , name ) , CIDR : " " , Zone : " " , } , } , Aws Configuration : & cluster . Aws Configuration { } , Firewalls : [ ] * cluster . Firewall { { Name : fmt . Sprintf ( " " , name , uuid . Time Ordered UUID ( ) ) , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , } , } , } , } , } , } deployment : = & appsv 1beta 2 . Deployment { Object Meta : metav 1 . Object Meta { Name : " " , } , Spec : appsv 1beta 2 . Deployment Spec { Replicas : ptrconvenient . Int 3 2Ptr ( 1 ) , Selector : & metav 1 . Label Selector { Match Labels : map [ string ] string { " " : " " , } , } , Template : apiv 1 . Pod Template Spec { Object Meta : metav 1 . Object Meta { Labels : map [ string ] string { " " : " " , } , } , Spec : apiv 1 . Pod Spec { Containers : [ ] apiv 1 . Container { { Name : " " , Image : " " , c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) cpms . Spec . Replicas = ptrconvenient . Int 3 2Ptr ( 3 ) c . Machine Sets [ 1 ] = cpms return c } 
func New Sdk ( region string ) ( * Sdk , error ) { sdk : = & Sdk { } auth Opts , err : = openstack . Auth Options From Env ( ) if err ! = nil { return nil , err } client , err : = openstack . Authenticated Client ( auth Opts ) if err ! = nil { return nil , err } } } } return sdk , nil } 
func Edit Cmd ( ) * cobra . Command { var eo = & cli . Edit Options { } var edit Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to edit a state . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : eo . Name = viper . Get String ( key Kubicorn Name ) case 1 : eo . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Edit ( eo ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = edit Cmd . Flags ( ) bind Common State Store Flags ( & eo . State Store Options , fs ) bind Common Aws Flags ( & eo . Aws Options , fs ) fs . String Var P ( & eo . Editor , key Editor , " " , viper . Get String ( key Editor ) , desc Editor ) fs . String Var ( & eo . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) return edit Cmd } 
func ( k * Keyring ) Remove Key ( key ssh . Public Key ) error { return k . Agent . Remove ( key ) } 
func ( k * Keyring ) Remove Key Using File ( pubkey string ) error { p , err : = ioutil . Read File ( pubkey ) if err ! = nil { return err } key , _ , _ , _ , _ : = ssh . Parse Authorized Key ( p ) if err ! = nil { return err } return k . Remove Key ( key ) } 
func ( r * Firewall ) Actual ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) new Resource : = default Firewall Struct ( ) if err ! = nil { return nil , nil , fmt . Errorf ( " " ) } for _ , firewall : = range firewalls { if firewall . Name = = r . Name { if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } if err : = json . Unmarshal ( firewall Bytes , new Resource ) ; err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } } } for i : = 0 ; i < len ( new Resource . Inbound Rules ) ; i + + { if new Resource . Inbound Rules [ i ] . Port Range = = " " { new Resource . Inbound Rules [ i ] . Port Range = " " } } } } new Cluster : = r . immutable Render ( new Resource , immutable ) return new Cluster , new Resource , nil } 
func ( r * Firewall ) Expected ( immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) new Resource : = & Firewall { Shared : Shared { Name : r . Name , Cloud ID : r . Server Pool . Identifier , } , Inbound Rules : r . Inbound Rules , Outbound Rules : r . Outbound Rules , Droplet IDs : r . Droplet IDs , Tags : r . Tags , Firewall ID : r . Firewall ID , Status : r . Status , Created : r . Created , } return new Cluster , new Resource , nil } 
func ( r * Firewall ) Apply ( actual , expected cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) expected Resource : = expected . ( * Firewall ) actual Resource : = actual . ( * Firewall ) is Equal , err : = compare . Is Equal ( actual Resource , expected Resource ) if err ! = nil { return nil , nil , err } if is Equal { return immutable , expected , nil } firewall Request : = godo . Firewall Request { Name : expected Resource . Name , Inbound Rules : convert In Rule Type ( expected Resource . Inbound Rules ) , Outbound Rules : convert Out Rule Type ( expected Resource . Outbound Rules ) , Droplet IDs : expected Resource . Droplet IDs , Tags : expected Resource . Tags , } for _ , machine Provider Config : = range machine Provider Configs { for i : = 0 ; i < = Tags Get Attempts ; i + + { active : = true droplets , _ , err : = Sdk . Client . Droplets . List By Tag ( context . TODO ( ) , machine Provider Config . Server Pool . Name , & godo . List Options { } ) if err ! = nil { logger . Debug ( " " , err ) time . Sleep ( time . Duration ( Tags Get Timeout ) * time . Second ) continue } if len ( droplets ) = = 0 { continue } for _ , d : = range droplets { if d . Status ! = " " { active = false break } } if ! active { logger . Debug ( " " ) time . Sleep ( time . Duration ( Tags Get Timeout ) * time . Second ) continue } break } } firewall , _ , err : = Sdk . Client . Firewalls . Create ( context . TODO ( ) , & firewall Request ) if err ! = nil { return nil , nil , fmt . Errorf ( " " , err ) } logger . Success ( " " , firewall . ID ) new Resource : = & Firewall { Shared : Shared { Cloud ID : firewall . ID , Name : r . Name , Tags : r . Tags , } , Droplet IDs : r . Droplet IDs , Firewall ID : firewall . ID , Inbound Rules : r . Inbound Rules , Outbound Rules : r . Outbound Rules , Created : r . Created , } new Cluster : = r . immutable Render ( new Resource , immutable ) return new Cluster , new Resource , nil } 
func ( r * Firewall ) Delete ( actual cloud . Resource , immutable * cluster . Cluster ) ( * cluster . Cluster , cloud . Resource , error ) { logger . Debug ( " " ) delete Resource , ok : = actual . ( * Firewall ) if ! ok { return nil , nil , fmt . Errorf ( " " ) } if delete Resource . Name = = " " { return immutable , nil , nil return nil , nil , fmt . Errorf ( " " , delete Resource . Name ) } if _ , err : = Sdk . Client . Firewalls . Delete ( context . TODO ( ) , delete Resource . Firewall ID ) ; err ! = nil { return nil , nil , fmt . Errorf ( " " , delete Resource . Name , err ) } logger . Success ( " " , delete Resource . Firewall ID ) new Resource : = & Firewall { Shared : Shared { Name : r . Name , Tags : r . Tags , } , Inbound Rules : r . Inbound Rules , Outbound Rules : r . Outbound Rules , Created : r . Created , } new Cluster : = r . immutable Render ( new Resource , immutable ) return new Cluster , new Resource , nil } 
func Delete Cmd ( ) * cobra . Command { var do = & cli . Delete Options { } var delete Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to delete cloud resources . This command will attempt to build the resource graph based on an API model . Once the graph is built , the delete will attempt to delete the resources from the cloud . After the delete is complete , the state store will be left in tact and could potentially be applied later . To delete the resource AND the API model in the state store , use - -purge . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : do . Name = viper . Get String ( key Kubicorn Name ) case 1 : do . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Delete ( do ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = delete Cmd . Flags ( ) bind Common State Store Flags ( & do . State Store Options , fs ) bind Common Aws Flags ( & do . Aws Options , fs ) fs . String Var ( & do . Aws Profile , key Aws Profile , viper . Get String ( key Aws Profile ) , desc Aws Profile ) fs . String Var ( & do . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) fs . Bool Var P ( & do . Purge , key Purge , " " , viper . Get Bool ( key Purge ) , desc Purge ) return delete Cmd } 
func ( options Options ) New State Store ( ) ( state . Cluster Storer , error ) { var state Store state . Cluster Storer switch options . State Store { case " " : logger . Info ( " " ) state Store = fs . New File System Store ( & fs . File System Store Options { Base Path : options . State Store Path , Cluster Name : options . Name , } ) case " " : logger . Info ( " " ) state Store = crd . New CRDStore ( & crd . CRDStore Options { Base Path : options . State Store Path , Cluster Name : options . Name , } ) case " " : logger . Info ( " " ) if options . Git Remote = = " " { return nil , errors . New ( " " ) } user , _ : = gg . Global ( " " ) email , _ : = gg . Email ( ) state Store = git . New JSONGit Store ( & git . JSONGit Store Options { Base Path : options . State Store Path , Cluster Name : options . Name , Commit Config : & git . JSONGit Commit Config { Name : user , Email : email , Remote : options . Git Remote , } , } ) case " " : logger . Info ( " " ) state Store = jsonfs . New JSONFile System Store ( & jsonfs . JSONFile System Store Options { Base Path : options . State Store Path , Cluster Name : options . Name , } ) case " " : logger . Info ( " " ) client , err : = minio . New ( options . Bucket Endpoint URL , options . S 3Access Key , options . S 3Secret Key , options . Bucket SSL ) if err ! = nil { return nil , err } state Store = s 3 . New JSONFS 3Store ( & s 3 . JSONS 3Store Options { Base Path : options . State Store Path , Cluster Name : options . Name , Client : client , Bucket Options : & s 3 . S 3Bucket Options { Endpoint URL : options . Bucket Endpoint URL , Bucket Name : options . Bucket Name , } , } ) default : return nil , fmt . Errorf ( " " , options . Name , options . State Store ) } return state Store , nil } 
func ( git * JSONGit Store ) Commit ( c * cluster . Cluster ) error { if c = = nil { return fmt . Errorf ( " " ) } bytes , err : = json . Marshal ( c ) if err ! = nil { return err } if err ! = nil { return err } _ , err = r . Commits ( ) if err ! = nil { return err } return nil } 
func Apply Cmd ( ) * cobra . Command { var ao = & cli . Apply Options { } var apply Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to apply an API model in a cloud . This command will attempt to find an API model in a defined state store , and then apply any changes needed directly to a cloud . The apply will run once , and ultimately time out if something goes wrong . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { switch len ( args ) { case 0 : ao . Name = viper . Get String ( key Kubicorn Name ) case 1 : ao . Name = args [ 0 ] default : logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Apply ( ao ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } fs : = apply Cmd . Flags ( ) bind Common State Store Flags ( & ao . State Store Options , fs ) bind Common Aws Flags ( & ao . Aws Options , fs ) fs . String Array Var P ( & ao . Set , key Kubicorn Set , " " , viper . Get String Slice ( key Kubicorn Set ) , desc Set ) fs . String Var ( & ao . Aws Profile , key Aws Profile , viper . Get String ( key Aws Profile ) , desc Aws Profile ) fs . String Var ( & ao . Git Remote , key Git Config , viper . Get String ( key Git Config ) , desc Git Config ) return apply Cmd } 
func get Git Hub Url ( bootstrap Script string ) string { } 
func Prompt Cmd ( ) * cobra . Command { var prompt Cmd = & cobra . Command { Use : " " , Short : " " , Long : `Use this command to use the Kubicron API via a shell prompt . This command will open a prompt using go -prompt (with auto -completion ) to allow you to run commands interactively from the shell . Currently this doesn 't work on Windows systems ` , Run : func ( cmd * cobra . Command , args [ ] string ) { if len ( args ) > 0 { logger . Critical ( " " ) os . Exit ( 1 ) } if err : = run Prompt ( ) ; err ! = nil { logger . Critical ( err . Error ( ) ) os . Exit ( 1 ) } } , } initialize Prompt ( ) return prompt Cmd } 
func Expand Path ( path string ) string { switch path { case " " : wd , err : = os . Getwd ( ) if err ! = nil { logger . Critical ( " " , err ) return " " } path = wd case " " : home Var : = os . Getenv ( " " ) if home Var = = " " { home User , err : = user . Current ( ) if err ! = nil { logger . Critical ( " " , err ) return " " } path = home User . Home Dir } } return path } 
func Completion Cmd ( ) * cobra . Command { return & cobra . Command { Use : " " , Short : " " , Long : `completion is used to output completion code for bash and zsh shells . Before using completion features , you have to source completion code from your .profile . This is done by adding following line to one of above files : source < (kubicorn completion SHELL ) Valid arguments for SHELL are : "bash " and "zsh " . Notes : 1 ) zsh completions requires zsh 5 . 2 or newer . 2 ) mac OS users have to install bash -completion framework to utilize completion features . This can be done using homebrew : brew install bash -completion Once installed , you must load bash _completion by adding following line to your .profile or .bashrc / .zshrc : source $ (brew - -prefix ) /etc /bash _completion ` , Run E : func ( cmd * cobra . Command , args [ ] string ) error { if logger . Fabulous { cmd . Set Output ( logger . Fabulous Writer ) } if viper . Get String ( key True Color ) ! = " " { cmd . Set Output ( logger . Fabulous Writer ) } switch len ( args ) { case 0 : return fmt . Errorf ( " " ) default : switch args [ 0 ] { case " " : return run Bash Generation ( ) case " " : return run Zsh Generation ( ) default : return fmt . Errorf ( " " ) } } } , } } 
func Adopt Cmd ( ) * cobra . Command { return & cobra . Command { Use : " " , Short : " " , Long : `Use this command to audit and adopt a Kubernetes cluster into a Kubicorn state store . This command will query cloud resources and attempt to build a representation of the cluster in the Kubicorn API model . Once the cluster has been adopted , a user can manage and scale their Kubernetes cluster with Kubicorn . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { fmt . Println ( " " ) } , } } 
func Str Env Def ( env string , def string ) string { val : = os . Getenv ( env ) if val = = " " { return def } return val } 
func Int Env Def ( env string , def int ) int { val : = os . Getenv ( env ) if val = = " " { return def } ival , err : = strconv . Atoi ( val ) if err ! = nil { return def } return ival } 
func Bool Env Def ( env string , def bool ) bool { val : = os . Getenv ( env ) if val = = " " { return def } b , err : = strconv . Parse Bool ( val ) if err ! = nil { return def } return b } 
func read From FS ( source Path string ) ( string , error ) { if home Dir = = " " { return " " , fmt . Errorf ( " " ) } source Path = filepath . Join ( home Dir , source Path [ 1 : ] ) } bytes , err : = ioutil . Read File ( source Path ) if err ! = nil { return " " , err } return string ( bytes ) , nil } 
func Version Cmd ( ) * cobra . Command { return & cobra . Command { Use : " " , Short : " " , Long : `Use this command to check the version of Kubicorn . This command will return the version of the Kubicorn binary . ` , Run : func ( cmd * cobra . Command , args [ ] string ) { fmt . Printf ( " \n " , version . Get Version JSON ( ) ) } , } } 
func New Signal Handler ( timeout Seconds int ) * Handler { signals : = make ( chan os . Signal ) signal . Notify ( signals , os . Interrupt , os . Kill ) return & Handler { timeout Seconds : timeout Seconds , signals : signals , signal Received : 0 , } } 
func ( h * Handler ) Register ( ) { go func ( ) { h . timer = time . New Timer ( time . Duration ( h . timeout Seconds ) * time . Second ) for { select { case s : = < - h . signals : switch { case s = = os . Interrupt : if h . signal Received = = 0 { h . signal Received = 1 logger . Debug ( " " ) continue } h . signal Received = signal Terminate debug . Print Stack ( ) os . Exit ( 1 3 0 ) break case s = = syscall . SIGQUIT : h . signal Received = signal Abort break case s = = syscall . SIGTERM : h . signal Received = signal Terminate os . Exit ( 3 ) break } case < - h . timer . C : os . Exit ( 4 ) break } } } ( ) } 
func New Sdk ( ) ( * Sdk , error ) { sdk : = & Sdk { } client , err : = google . Default Client ( context . TODO ( ) , compute . Compute Scope ) if err ! = nil { return nil , err } service , err : = compute . New ( client ) if err ! = nil { return nil , err } sdk . Service = service return sdk , nil } 
func New Ubuntu Cluster ( name string ) * cluster . Cluster { var ( master Name = fmt . Sprintf ( " " , name ) node Name = fmt . Sprintf ( " " , name ) ) control Plane Provider Config : = & cluster . Control Plane Provider Config { Cloud : cluster . Cloud ECS , Location : " " , SSH : & cluster . SSH { Public Key Path : " " , User : " " , } , Values : & cluster . Values { Item Map : map [ string ] string { " " : kubeadm . Get Random Token ( ) , } , } , Kubernetes API : & cluster . Kubernetes API { Port : " " , } , Network : & cluster . Network { Type : cluster . Network Type Public , Internet GW : & cluster . Internet GW { Name : " " , } , } , } machine Sets Provider Configs : = [ ] * cluster . Machine Provider Config { { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Master , Name : master Name , Max Count : 1 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Subnets : [ ] * cluster . Subnet { { Name : " " , CIDR : " " , } , } , Firewalls : [ ] * cluster . Firewall { { Name : master Name , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress Source : " " , } , } , } , } , } , } , { Server Pool : & cluster . Server Pool { Type : cluster . Server Pool Type Node , Name : node Name , Max Count : 2 , Image : " " , Size : " " , Bootstrap Scripts : [ ] string { " " , } , Firewalls : [ ] * cluster . Firewall { { Name : node Name , Ingress Rules : [ ] * cluster . Ingress Rule { { Ingress From Port : " " , Ingress To Port : " " , Ingress Source : " " , Ingress Protocol : " " , } , { Ingress Source : " " , } , } , } , } , } , } , } c : = cluster . New Cluster ( name ) c . Set Provider Config ( control Plane Provider Config ) c . New Machine Sets From Provider Configs ( machine Sets Provider Configs ) return c } 
func read From HTTP ( target URL * url . URL ) ( string , error ) { var client http . Client resp , err : = client . Get ( target URL . String ( ) ) if err ! = nil { return " " , err } defer resp . Body . Close ( ) if resp . Status Code = = http . Status OK { bytes , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return " " , err } return string ( bytes ) , nil } return " " , fmt . Errorf ( " " , target URL . String ( ) ) } 
func ( now * Now ) Beginning Of Hour ( ) time . Time { y , m , d : = now . Date ( ) return time . Date ( y , m , d , now . Time . Hour ( ) , 0 , 0 , 0 , now . Time . Location ( ) ) } 
func ( now * Now ) Beginning Of Day ( ) time . Time { y , m , d : = now . Date ( ) return time . Date ( y , m , d , 0 , 0 , 0 , 0 , now . Time . Location ( ) ) } 
func ( now * Now ) Beginning Of Week ( ) time . Time { t : = now . Beginning Of Day ( ) weekday : = int ( t . Weekday ( ) ) if Week Start Day ! = time . Sunday { week Start Day Int : = int ( Week Start Day ) if weekday < week Start Day Int { weekday = weekday + 7 - week Start Day Int } else { weekday = weekday - week Start Day Int } } return t . Add Date ( 0 , 0 , - weekday ) } 
func ( now * Now ) Beginning Of Month ( ) time . Time { y , m , _ : = now . Date ( ) return time . Date ( y , m , 1 , 0 , 0 , 0 , 0 , now . Location ( ) ) } 
func ( now * Now ) Beginning Of Quarter ( ) time . Time { month : = now . Beginning Of Month ( ) offset : = ( int ( month . Month ( ) ) - 1 ) % 3 return month . Add Date ( 0 , - offset , 0 ) } 
func ( now * Now ) Beginning Of Year ( ) time . Time { y , _ , _ : = now . Date ( ) return time . Date ( y , time . January , 1 , 0 , 0 , 0 , 0 , now . Location ( ) ) } 
func ( now * Now ) End Of Minute ( ) time . Time { return now . Beginning Of Minute ( ) . Add ( time . Minute - time . Nanosecond ) } 
func ( now * Now ) End Of Hour ( ) time . Time { return now . Beginning Of Hour ( ) . Add ( time . Hour - time . Nanosecond ) } 
func ( now * Now ) End Of Day ( ) time . Time { y , m , d : = now . Date ( ) return time . Date ( y , m , d , 2 3 , 5 9 , 5 9 , int ( time . Second - time . Nanosecond ) , now . Location ( ) ) } 
func ( now * Now ) End Of Week ( ) time . Time { return now . Beginning Of Week ( ) . Add Date ( 0 , 0 , 7 ) . Add ( - time . Nanosecond ) } 
func ( now * Now ) End Of Month ( ) time . Time { return now . Beginning Of Month ( ) . Add Date ( 0 , 1 , 0 ) . Add ( - time . Nanosecond ) } 
func ( now * Now ) End Of Quarter ( ) time . Time { return now . Beginning Of Quarter ( ) . Add Date ( 0 , 3 , 0 ) . Add ( - time . Nanosecond ) } 
func ( now * Now ) End Of Year ( ) time . Time { return now . Beginning Of Year ( ) . Add Date ( 1 , 0 , 0 ) . Add ( - time . Nanosecond ) } 
func ( now * Now ) Sunday ( ) time . Time { t : = now . Beginning Of Day ( ) weekday : = int ( t . Weekday ( ) ) if weekday = = 0 { return t } return t . Add Date ( 0 , 0 , ( 7 - weekday ) ) } 
func ( now * Now ) Parse ( strs . . . string ) ( t time . Time , err error ) { var ( set Current Time bool parse Time [ ] int current Time = [ ] int { now . Nanosecond ( ) , now . Second ( ) , now . Minute ( ) , now . Hour ( ) , now . Day ( ) , int ( now . Month ( ) ) , now . Year ( ) } current Location = now . Location ( ) only Time In Str = true ) for _ , str : = range strs { has Time In Str : = has Time Regexp . Match String ( str ) only Time In Str = has Time In Str & & only Time In Str & & only Time Regexp . Match String ( str ) if t , err = parse With Format ( str ) ; err = = nil { location : = t . Location ( ) if location . String ( ) = = " " { location = current Location } parse Time = [ ] int { t . Nanosecond ( ) , t . Second ( ) , t . Minute ( ) , t . Hour ( ) , t . Day ( ) , int ( t . Month ( ) ) , t . Year ( ) } for i , v : = range parse Time { } } } else { set Current Time = true } continue } } } t = time . Date ( parse Time [ 6 ] , time . Month ( parse Time [ 5 ] ) , parse Time [ 4 ] , parse Time [ 3 ] , parse Time [ 2 ] , parse Time [ 1 ] , parse Time [ 0 ] , location ) current Time = [ ] int { t . Nanosecond ( ) , t . Second ( ) , t . Minute ( ) , t . Hour ( ) , t . Day ( ) , int ( t . Month ( ) ) , t . Year ( ) } } } return } 
func ( now * Now ) Must Parse ( strs . . . string ) ( t time . Time ) { t , err : = now . Parse ( strs . . . ) if err ! = nil { panic ( err ) } return t } 
func ( now * Now ) Between ( begin , end string ) bool { begin Time : = now . Must Parse ( begin ) end Time : = now . Must Parse ( end ) return now . After ( begin Time ) & & now . Before ( end Time ) } 
func Parse ( strs . . . string ) ( time . Time , error ) { return New ( time . Now ( ) ) . Parse ( strs . . . ) } 
func Parse In Location ( loc * time . Location , strs . . . string ) ( time . Time , error ) { return New ( time . Now ( ) . In ( loc ) ) . Parse ( strs . . . ) } 
func Must Parse ( strs . . . string ) time . Time { return New ( time . Now ( ) ) . Must Parse ( strs . . . ) } 
func Must Parse In Location ( loc * time . Location , strs . . . string ) time . Time { return New ( time . Now ( ) . In ( loc ) ) . Must Parse ( strs . . . ) } 
func Between ( time 1 , time 2 string ) bool { return New ( time . Now ( ) ) . Between ( time 1 , time 2 ) } 
func ( b * Memory Backend ) Log ( level Level , calldepth int , rec * Record ) error { var size int 3 2 n : = & node { Record : rec } np : = unsafe . Pointer ( n ) swapped : = atomic . Compare And Swap Pointer ( & b . tail , tailp , np , ) if swapped = = true { if tailp = = nil { b . head = np } else { ( * node ) ( tailp ) . next = n } size = atomic . Add Int 3 2 ( & b . size , 1 ) break } } head : = ( * node ) ( b . head ) if head . next = = nil { break } swapped : = atomic . Compare And Swap Pointer ( & b . head , headp , unsafe . Pointer ( head . next ) , ) if swapped = = true { atomic . Add Int 3 2 ( & b . size , - 1 ) break } } } return nil } 
func New Channel Memory Backend ( size int ) * Channel Memory Backend { backend : = & Channel Memory Backend { max Size : size , incoming : make ( chan * Record , 1 0 2 4 ) , events : make ( chan event ) , } backend . Start ( ) return backend } 
func ( b * Channel Memory Backend ) Start ( ) { b . mu . Lock ( ) defer b . mu . Unlock ( ) b . stop Wg . Add ( 1 ) go b . process ( ) } } 
func ( b * Channel Memory Backend ) Flush ( ) { b . flush Wg . Add ( 1 ) b . events < - event Flush b . flush Wg . Wait ( ) } 
func ( b * Channel Memory Backend ) Stop ( ) { b . mu . Lock ( ) if b . running = = true { b . running = false b . events < - event Stop } b . mu . Unlock ( ) b . stop Wg . Wait ( ) } 
func ( b * Channel Memory Backend ) Log ( level Level , calldepth int , rec * Record ) error { b . incoming < - rec return nil } 
func ( r * Record ) Formatted ( calldepth int ) string { if r . formatted = = " " { var buf bytes . Buffer r . formatter . Format ( calldepth + 1 , r , & buf ) r . formatted = buf . String ( ) } return r . formatted } 
func ( r * Record ) Message ( ) string { if r . message = = nil { } } var buf bytes . Buffer if r . fmt ! = nil { fmt . Fprintf ( & buf , * r . fmt , r . Args . . . ) } else { buf . Truncate ( buf . Len ( ) - 1 ) } msg : = buf . String ( ) r . message = & msg } return * r . message } 
func ( l * Logger ) Set Backend ( backend Leveled Backend ) { l . backend = backend l . have Backend = true } 
func Must Get Logger ( module string ) * Logger { logger , err : = Get Logger ( module ) if err ! = nil { panic ( " " + module + " " + err . Error ( ) ) } return logger } 
func Reset ( ) { b : = Set Backend ( New Log Backend ( os . Stderr , " " , log . Lstd Flags ) ) b . Set Level ( DEBUG , " " ) Set Formatter ( Default Formatter ) time Now = time . Now } 
func ( l * Logger ) Is Enabled For ( level Level ) bool { return default Backend . Is Enabled For ( level , l . Module ) } 
func ( l * Logger ) Fatal ( args . . . interface { } ) { l . log ( CRITICAL , nil , args . . . ) os . Exit ( 1 ) } 
func ( l * Logger ) Fatalf ( format string , args . . . interface { } ) { l . log ( CRITICAL , & format , args . . . ) os . Exit ( 1 ) } 
func ( l * Logger ) Panic ( args . . . interface { } ) { l . log ( CRITICAL , nil , args . . . ) panic ( fmt . Sprint ( args . . . ) ) } 
func ( l * Logger ) Panicf ( format string , args . . . interface { } ) { l . log ( CRITICAL , & format , args . . . ) panic ( fmt . Sprintf ( format , args . . . ) ) } 
func ( l * Logger ) Criticalf ( format string , args . . . interface { } ) { l . log ( CRITICAL , & format , args . . . ) } 
func ( l * Logger ) Warningf ( format string , args . . . interface { } ) { l . log ( WARNING , & format , args . . . ) } 
func ( l * Logger ) Noticef ( format string , args . . . interface { } ) { l . log ( NOTICE , & format , args . . . ) } 
func ( l * Logger ) Infof ( format string , args . . . interface { } ) { l . log ( INFO , & format , args . . . ) } 
func New Log Backend ( out io . Writer , prefix string , flag int ) * Log Backend { b : = & Log Backend { Logger : log . New ( out , prefix , flag ) } } return b } 
func set Console Text Attribute ( f file , attribute uint 1 6 ) bool { ok , _ , _ : = set Console Text Attribute Proc . Call ( f . Fd ( ) , uintptr ( attribute ) , 0 ) return ok ! = 0 } 
func Set Formatter ( f Formatter ) { formatter . Lock ( ) defer formatter . Unlock ( ) formatter . def = f } 
func New String Formatter ( format string ) ( Formatter , error ) { var fmter = & string Formatter { } if matches = = nil { return nil , errors . New ( " " + format ) } for _ , m : = range matches { start , end : = m [ 0 ] , m [ 1 ] if start > prev { fmter . add ( fmt Verb Static , format [ prev : start ] ) } name : = format [ m [ 2 ] : m [ 3 ] ] verb : = get Fmt Verb By Name ( name ) if verb = = fmt Verb Unknown { return nil , errors . New ( " " + name ) } if m [ 4 ] ! = - 1 { layout = format [ m [ 4 ] : m [ 5 ] ] } if verb ! = fmt Verb Time & & verb ! = fmt Verb Level Color & & verb ! = fmt Verb Callpath { layout = " " + layout } fmter . add ( verb , layout ) prev = end } end : = format [ prev : ] if end ! = " " { fmter . add ( fmt Verb Static , end ) } if err ! = nil { panic ( err ) } test Fmt : = " " r : = & Record { ID : 1 2 3 4 5 , Time : t , Module : " " , Args : [ ] interface { } { " " } , fmt : & test Fmt , } if err : = fmter . Format ( 0 , r , & bytes . Buffer { } ) ; err ! = nil { return nil , err } return fmter , nil } 
func Must String Formatter ( format string ) Formatter { f , err : = New String Formatter ( format ) if err ! = nil { panic ( " " + err . Error ( ) ) } return f } 
func format Func Name ( v fmt Verb , f string ) string { i : = strings . Last Index ( f , " " ) j : = strings . Index ( f [ i + 1 : ] , " " ) if j < 1 { return " " } pkg , fun : = f [ : i + j + 1 ] , f [ i + j + 2 : ] switch v { case fmt Verb Longpkg : return pkg case fmt Verb Shortpkg : return path . Base ( pkg ) case fmt Verb Longfunc : return fun case fmt Verb Shortfunc : i = strings . Last Index ( fun , " " ) return fun [ i + 1 : ] } panic ( " " ) } 
func ( bf * backend Formatter ) Log ( level Level , calldepth int , r * Record ) error { r 2 . formatter = bf . f return bf . b . Log ( level , calldepth + 1 , & r 2 ) } 
func Log Level ( level string ) ( Level , error ) { for i , name : = range level Names { if strings . Equal Fold ( name , level ) { return Level ( i ) , nil } } return ERROR , Err Invalid Log Level } 
func Add Module Level ( backend Backend ) Leveled Backend { var leveled Leveled Backend var ok bool if leveled , ok = backend . ( Leveled Backend ) ; ! ok { leveled = & module Leveled { levels : make ( map [ string ] Level ) , backend : backend , } } return leveled } 
func ( l * module Leveled ) Get Level ( module string ) Level { level , exists : = l . levels [ module ] if exists = = false { level , exists = l . levels [ " " ] } } return level } 
func ( l * module Leveled ) Set Level ( level Level , module string ) { l . levels [ module ] = level } 
func ( l * module Leveled ) Is Enabled For ( level Level , module string ) bool { return level < = l . Get Level ( module ) } 
func Multi Logger ( backends . . . Backend ) Leveled Backend { var leveled Backends [ ] Leveled Backend for _ , backend : = range backends { leveled Backends = append ( leveled Backends , Add Module Level ( backend ) ) } return & multi Logger { leveled Backends } } 
func ( b * multi Logger ) Log ( level Level , calldepth int , rec * Record ) ( err error ) { for _ , backend : = range b . backends { if backend . Is Enabled For ( level , rec . Module ) { if e : = backend . Log ( level , calldepth + 1 , & r 2 ) ; e ! = nil { err = e } } } return } 
func ( b * multi Logger ) Get Level ( module string ) Level { var level Level for _ , backend : = range b . backends { if backend Level : = backend . Get Level ( module ) ; backend Level > level { level = backend Level } } return level } 
func ( b * multi Logger ) Set Level ( level Level , module string ) { for _ , backend : = range b . backends { backend . Set Level ( level , module ) } } 
func ( b * multi Logger ) Is Enabled For ( level Level , module string ) bool { for _ , backend : = range b . backends { if backend . Is Enabled For ( level , module ) { return true } } return false } 
func New Log Backend ( out io . Writer , prefix string , flag int ) * Log Backend { return & Log Backend { Logger : log . New ( out , prefix , flag ) } } 
func ( b * Log Backend ) Log ( level Level , calldepth int , rec * Record ) error { if b . Color { col : = colors [ level ] if len ( b . Color Config ) > int ( level ) & & b . Color Config [ level ] ! = " " { col = b . Color Config [ level ] } buf : = & bytes . Buffer { } buf . Write ( [ ] byte ( col ) ) buf . Write ( [ ] byte ( rec . Formatted ( calldepth + 1 ) ) ) buf . Write ( [ ] byte ( " \ 0 3 3 " ) ) } return b . Logger . Output ( calldepth + 2 , rec . Formatted ( calldepth + 1 ) ) } 
func Convert Colors ( colors [ ] int , bold bool ) [ ] string { converted : = [ ] string { } for _ , i : = range colors { if bold { converted = append ( converted , Color Seq Bold ( color ( i ) ) ) } else { converted = append ( converted , Color Seq ( color ( i ) ) ) } } return converted } 
func New Syslog Backend ( prefix string ) ( b * Syslog Backend , err error ) { var w * syslog . Writer w , err = syslog . New ( syslog . LOG _CRIT , prefix ) return & Syslog Backend { w } , err } 
func New Syslog Backend Priority ( prefix string , priority syslog . Priority ) ( b * Syslog Backend , err error ) { var w * syslog . Writer w , err = syslog . New ( priority , prefix ) return & Syslog Backend { w } , err } 
func ( b * Syslog Backend ) Log ( level Level , calldepth int , rec * Record ) error { line : = rec . Formatted ( calldepth + 1 ) switch level { case CRITICAL : return b . Writer . Crit ( line ) case ERROR : return b . Writer . Err ( line ) case WARNING : return b . Writer . Warning ( line ) case NOTICE : return b . Writer . Notice ( line ) case INFO : return b . Writer . Info ( line ) case DEBUG : return b . Writer . Debug ( line ) default : } panic ( " " ) } 
func Set Backend ( backends . . . Backend ) Leveled Backend { var backend Backend if len ( backends ) = = 1 { backend = backends [ 0 ] } else { backend = Multi Logger ( backends . . . ) } default Backend = Add Module Level ( backend ) return default Backend } 
func New Commander ( top Level Flags * flag . Flag Set , name string ) * Commander { cdr : = & Commander { top Flags : top Level Flags , name : name , Output : os . Stdout , Error : os . Stderr , } top Level Flags . Usage = func ( ) { cdr . explain ( cdr . Error ) } return cdr } 
func ( cdr * Commander ) Register ( cmd Command , group string ) { for _ , g : = range cdr . commands { if g . name = = group { g . commands = append ( g . commands , cmd ) return } } cdr . commands = append ( cdr . commands , & command Group { name : group , commands : [ ] Command { cmd } , } ) } 
func ( cdr * Commander ) Important Flag ( name string ) { cdr . important = append ( cdr . important , name ) } 
func ( cdr * Commander ) Execute ( ctx context . Context , args . . . interface { } ) Exit Status { if cdr . top Flags . NArg ( ) < 1 { cdr . top Flags . Usage ( ) return Exit Usage Error } name : = cdr . top Flags . Arg ( 0 ) for _ , group : = range cdr . commands { for _ , cmd : = range group . commands { if name ! = cmd . Name ( ) { continue } f : = flag . New Flag Set ( name , flag . Continue On Error ) f . Usage = func ( ) { explain ( cdr . Error , cmd ) } cmd . Set Flags ( f ) if f . Parse ( cdr . top Flags . Args ( ) [ 1 : ] ) ! = nil { return Exit Usage Error } return cmd . Execute ( ctx , f , args . . . ) } } return Exit Usage Error } 
func ( cdr * Commander ) explain ( w io . Writer ) { fmt . Fprintf ( w , " \n \n " , cdr . name ) sort . Sort ( by Group Name ( cdr . commands ) ) for _ , group : = range cdr . commands { explain Group ( w , group ) } if cdr . top Flags = = nil { fmt . Fprintln ( w , " \n " ) return } if len ( cdr . important ) = = 0 { fmt . Fprintf ( w , " \n \ " \ " \n " , cdr . name ) return } fmt . Fprintf ( w , " \n \ " \ " \n " , cdr . name ) for _ , name : = range cdr . important { f : = cdr . top Flags . Lookup ( name ) if f = = nil { panic ( fmt . Sprintf ( " " , name ) ) } fmt . Fprintf ( w , " \n " , f . Name , f . Def Value , f . Usage ) } } 
func explain Group ( w io . Writer , group * command Group ) { if len ( group . commands ) = = 0 { return } if group . name = = " " { fmt . Fprintf ( w , " \n " ) } else { fmt . Fprintf ( w , " \n " , group . name ) } sort . Sort ( group ) aliases : = make ( map [ string ] [ ] string ) for _ , cmd : = range group . commands { if alias , ok : = cmd . ( * aliaser ) ; ok { root : = dealias ( alias ) . Name ( ) if _ , ok : = aliases [ root ] ; ! ok { aliases [ root ] = [ ] string { } } aliases [ root ] = append ( aliases [ root ] , alias . Name ( ) ) } } for _ , cmd : = range group . commands { if _ , ok : = cmd . ( * aliaser ) ; ok { continue } name : = cmd . Name ( ) names : = [ ] string { name } if a , ok : = aliases [ name ] ; ok { names = append ( names , a . . . ) } fmt . Fprintf ( w , " \t \n " , strings . Join ( names , " " ) , cmd . Synopsis ( ) ) } fmt . Fprintln ( w ) } 
func explain ( w io . Writer , cmd Command ) { fmt . Fprintf ( w , " " , cmd . Usage ( ) ) subflags : = flag . New Flag Set ( cmd . Name ( ) , flag . Panic On Error ) subflags . Set Output ( w ) cmd . Set Flags ( subflags ) subflags . Print Defaults ( ) } 
func dealias ( cmd Command ) Command { if alias , ok : = cmd . ( * aliaser ) ; ok { return dealias ( alias . Command ) } return cmd } 
func Execute ( ctx context . Context , args . . . interface { } ) Exit Status { return Default Commander . Execute ( ctx , args . . . ) } 
func ( c * Config File ) read ( reader io . Reader ) ( err error ) { buf : = bufio . New Reader ( reader ) if err = = nil & & len ( mask ) > = 3 & & mask [ 0 ] = = 2 3 9 & & mask [ 1 ] = = 1 8 7 & & mask [ 2 ] = = 1 9 1 { buf . Read ( mask ) } count : = 1 var comments string line = strings . Trim Space ( line ) line Lengh : = len ( line ) if err ! = nil { if err ! = io . EOF { return err } } } case line [ 0 ] = = ' # ' | | line [ 0 ] = = ' ; ' : } else { comments + = Line Break + line } continue case line [ 0 ] = = ' [ ' & & line [ line Lengh - 1 ] = = ' ] ' : comments = " " } continue case section = = " " : default : key Quote string key string val Quote string value string ) } else { key Quote = ` " ` } } else if line [ 0 ] = = ' ` ' { key Quote = " " } if key Quote ! = " " { q Len : = len ( key Quote ) pos : = strings . Index ( line [ q Len : ] , key Quote ) if pos = = - 1 { return read Error { ERR _COULD _NOT _PARSE , line } } pos = pos + q Len i = strings . Index Any ( line [ pos : ] , " " ) if i < = 0 { return read Error { ERR _COULD _NOT _PARSE , line } } i = i + pos key = line [ q Len : pos ] / /            } else { i = strings . Index Any ( line , " " ) if i < = 0 { return read Error { ERR _COULD _NOT _PARSE , line } } key = strings . Trim Space ( line [ 0 : i ] ) } / / [SWH | + ] ; / / Check if it needs auto increment . if key = = " " { key = " " + fmt . Sprint ( count ) count + + } / / [SWH | + ] :            line Right : = strings . Trim Space ( line [ i + 1 : ] ) line Right Length : = len ( line Right ) first Char : = " " if line Right Length > = 2 { first Char = line Right [ 0 : 1 ] } if first Char = = " " { val Quote = " " } else if line Right Length > = 6 & & line Right [ 0 : 3 ] = = ` " " " ` { val Quote = ` " " " ` } if val Quote ! = " " { q Len : = len ( val Quote ) pos : = strings . Last Index ( line Right [ q Len : ] , val Quote ) if pos = = - 1 { return read Error { ERR _COULD _NOT _PARSE , line } } pos = pos + q Len value = line Right [ q Len : pos ] } else { value = strings . Trim Space ( line Right [ 0 : ] ) } / / [SWH | + ] ; c . Set Value ( section , key , value ) / / Set key comments and empty if it has comments . if len ( comments ) > 0 { c . Set Key Comments ( section , key , comments ) comments = " " } } } } return nil } 
func Load From Data ( data [ ] byte ) ( c * Config File , err error ) { if err = os . Mkdir All ( path . Dir ( tmp Name ) , os . Mode Perm ) ; err ! = nil { return nil , err } if err = ioutil . Write File ( tmp Name , data , 0 6 5 5 ) ; err ! = nil { return nil , err } c = new Config File ( [ ] string { tmp Name } ) err = c . read ( bytes . New Buffer ( data ) ) return c , err } 
func Load From Reader ( in io . Reader ) ( c * Config File , err error ) { c = new Config File ( [ ] string { " " } ) err = c . read ( in ) return c , err } 
func ( c * Config File ) Reload Data ( in io . Reader ) ( err error ) { var cfg * Config File if len ( c . file Names ) ! = 1 { return fmt . Errorf ( " " ) } cfg , err = Load From Reader ( in ) if err = = nil { * c = * cfg } return err } 
func ( c * Config File ) Append Files ( files . . . string ) error { if len ( c . file Names ) = = 1 & & c . file Names [ 0 ] = = " " { return fmt . Errorf ( " " ) } c . file Names = append ( c . file Names , files . . . ) return c . Reload ( ) } 
func ( c * Config File ) Get Key List ( section string ) [ ] string { } if c . Block Mode { c . lock . RLock ( ) defer c . lock . RUnlock ( ) } } for _ , key : = range c . key List [ section ] { if key ! = " " { list = append ( list , key ) } } return list } 
func Save Config Data ( c * Config File , out io . Writer ) ( err error ) { equal Sign : = " " if Pretty Format { equal Sign = " " } buf : = bytes . New Buffer ( nil ) for _ , section : = range c . section List { } } if section ! = DEFAULT _SECTION { } } for _ , key : = range c . key List [ section ] { if key ! = " " { } } key Name : = key } } else { key Name = ` " ` + key Name + ` " ` } } else { key Name = " " + key Name + " " } } value : = c . data [ section ] [ key ] } else { value = ` " ` + value + ` " ` } } } } } } } if _ , err : = buf . Write To ( out ) ; err ! = nil { return err } return nil } 
func Save Config File ( c * Config File , filename string ) ( err error ) { if f , err = os . Create ( filename ) ; err ! = nil { return err } if err : = Save Config Data ( c , f ) ; err ! = nil { return err } return f . Close ( ) } 
func ( s * selectable ) Find ( selector string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . CSS , selector ) . Single ( ) ) } 
func ( s * selectable ) Find By XPath ( selector string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . XPath , selector ) . Single ( ) ) } 
func ( s * selectable ) Find By Link ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Link , text ) . Single ( ) ) } 
func ( s * selectable ) Find By Label ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Label , text ) . Single ( ) ) } 
func ( s * selectable ) Find By Button ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Button , text ) . Single ( ) ) } 
func ( s * selectable ) Find By Name ( name string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Name , name ) . Single ( ) ) } 
func ( s * selectable ) Find By Class ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Class , text ) . Single ( ) ) } 
func ( s * selectable ) Find By ID ( id string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . ID , id ) . Single ( ) ) } 
func ( s * selectable ) First ( selector string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . CSS , selector ) . At ( 0 ) ) } 
func ( s * selectable ) First By XPath ( selector string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . XPath , selector ) . At ( 0 ) ) } 
func ( s * selectable ) First By Link ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Link , text ) . At ( 0 ) ) } 
func ( s * selectable ) First By Label ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Label , text ) . At ( 0 ) ) } 
func ( s * selectable ) First By Button ( text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Button , text ) . At ( 0 ) ) } 
func ( s * selectable ) First By Name ( name string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Name , name ) . At ( 0 ) ) } 
func ( s * selectable ) All ( selector string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . CSS , selector ) ) } 
func ( s * selectable ) All By XPath ( selector string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . XPath , selector ) ) } 
func ( s * selectable ) All By Link ( text string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . Link , text ) ) } 
func ( s * selectable ) All By Label ( text string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . Label , text ) ) } 
func ( s * selectable ) All By Button ( text string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . Button , text ) ) } 
func ( s * selectable ) All By Name ( name string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . Name , name ) ) } 
func ( s * selectable ) All By Class ( text string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . Class , text ) ) } 
func ( s * selectable ) All By ID ( text string ) * Multi Selection { return new Multi Selection ( s . session , s . selectors . Append ( target . ID , text ) ) } 
func ( s * selectable ) Find For Appium ( selector Type string , text string ) * Selection { return new Selection ( s . session , s . selectors . Append ( target . Class , text ) . At ( 0 ) ) } 
func Timeout ( seconds int ) Option { return func ( c * config ) { c . Timeout = time . Duration ( seconds ) * time . Second } } 
func Chrome Options ( opt string , value interface { } ) Option { return func ( c * config ) { if c . Chrome Options = = nil { c . Chrome Options = make ( map [ string ] interface { } ) } c . Chrome Options [ opt ] = value } } 
func HTTPClient ( client * http . Client ) Option { return func ( c * config ) { c . HTTPClient = client } } 
func New Page ( url string , options . . . Option ) ( * Page , error ) { page Options : = config { } . Merge ( options ) session , err : = api . Open With Client ( url , page Options . Capabilities ( ) , page Options . HTTPClient ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return new Page ( session ) , nil } 
func Join Page ( url string , options . . . Option ) * Page { page Options : = config { } . Merge ( options ) session : = api . New With Client ( url , page Options . HTTPClient ) return new Page ( session ) } 
func ( p * Page ) Destroy ( ) error { if err : = p . session . Delete ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Reset ( ) error { p . Confirm Popup ( ) url , err : = p . URL ( ) if err ! = nil { return err } if url = = " " { return nil } if err : = p . Clear Cookies ( ) ; err ! = nil { return err } if err : = p . session . Delete Local Storage ( ) ; err ! = nil { if err : = p . Run Script ( " " , nil , nil ) ; err ! = nil { return err } } if err : = p . session . Delete Session Storage ( ) ; err ! = nil { if err : = p . Run Script ( " " , nil , nil ) ; err ! = nil { return err } } return p . Navigate ( " " ) } 
func ( p * Page ) Navigate ( url string ) error { if err : = p . session . Set URL ( url ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Get Cookies ( ) ( [ ] * http . Cookie , error ) { api Cookies , err : = p . session . Get Cookies ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } cookies : = [ ] * http . Cookie { } for _ , api Cookie : = range api Cookies { exp Seconds : = int 6 4 ( api Cookie . Expiry ) exp Nano : = int 6 4 ( api Cookie . Expiry - float 6 4 ( exp Seconds ) ) * 1 0 0 0 0 0 0 0 0 0 cookie : = & http . Cookie { Name : api Cookie . Name , Value : api Cookie . Value , Path : api Cookie . Path , Domain : api Cookie . Domain , Secure : api Cookie . Secure , Http Only : api Cookie . HTTPOnly , Expires : time . Unix ( exp Seconds , exp Nano ) , } cookies = append ( cookies , cookie ) } return cookies , nil } 
func ( p * Page ) Set Cookie ( cookie * http . Cookie ) error { if cookie = = nil { return errors . New ( " " ) } var expiry int 6 4 if ! cookie . Expires . Is Zero ( ) { expiry = cookie . Expires . Unix ( ) } api Cookie : = & api . Cookie { Name : cookie . Name , Value : cookie . Value , Path : cookie . Path , Domain : cookie . Domain , Secure : cookie . Secure , HTTPOnly : cookie . Http Only , Expiry : float 6 4 ( expiry ) , } if err : = p . session . Set Cookie ( api Cookie ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Delete Cookie ( name string ) error { if err : = p . session . Delete Cookie ( name ) ; err ! = nil { return fmt . Errorf ( " " , name , err ) } return nil } 
func ( p * Page ) Clear Cookies ( ) error { if err : = p . session . Delete Cookies ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) URL ( ) ( string , error ) { url , err : = p . session . Get URL ( ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return url , nil } 
func ( p * Page ) Size ( width , height int ) error { window , err : = p . session . Get Window ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = window . Set Size ( width , height ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Screenshot ( filename string ) error { abs File Path , err : = filepath . Abs ( filename ) if err ! = nil { return fmt . Errorf ( " " , err ) } screenshot , err : = p . session . Get Screenshot ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } if err : = ioutil . Write File ( abs File Path , screenshot , 0 6 6 6 ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Title ( ) ( string , error ) { title , err : = p . session . Get Title ( ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return title , nil } 
func ( p * Page ) HTML ( ) ( string , error ) { html , err : = p . session . Get Source ( ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return html , nil } 
func ( p * Page ) Run Script ( body string , arguments map [ string ] interface { } , result interface { } ) error { var ( keys [ ] string values [ ] interface { } ) for key , value : = range arguments { keys = append ( keys , key ) values = append ( values , value ) } argument List : = strings . Join ( keys , " " ) clean Body : = fmt . Sprintf ( " " , argument List , body ) if err : = p . session . Execute ( clean Body , values , result ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Popup Text ( ) ( string , error ) { text , err : = p . session . Get Alert Text ( ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } return text , nil } 
func ( p * Page ) Enter Popup Text ( text string ) error { if err : = p . session . Set Alert Text ( text ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Confirm Popup ( ) error { if err : = p . session . Accept Alert ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Cancel Popup ( ) error { if err : = p . session . Dismiss Alert ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Switch To Parent Frame ( ) error { if err : = p . session . Frame Parent ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Switch To Root Frame ( ) error { if err : = p . session . Frame ( nil ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Switch To Window ( name string ) error { if err : = p . session . Set Window By Name ( name ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Next Window ( ) error { windows , err : = p . session . Get Windows ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } var window IDs [ ] string for _ , window : = range windows { window IDs = append ( window IDs , window . ID ) } active Window , err : = p . session . Get Window ( ) if err ! = nil { return fmt . Errorf ( " " , err ) } for position , window ID : = range window IDs { if window ID = = active Window . ID { active Window . ID = window IDs [ ( position + 1 ) % len ( window IDs ) ] break } } if err : = p . session . Set Window ( active Window ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Close Window ( ) error { if err : = p . session . Delete Window ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Window Count ( ) ( int , error ) { windows , err : = p . session . Get Windows ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , err ) } return len ( windows ) , nil } 
func ( p * Page ) Log Types ( ) ( [ ] string , error ) { types , err : = p . session . Get Log Types ( ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return types , nil } 
func ( p * Page ) Read New Logs ( log Type string ) ( [ ] Log , error ) { if p . logs = = nil { p . logs = map [ string ] [ ] Log { } } client Logs , err : = p . session . New Logs ( log Type ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } message Matcher : = regexp . Must Compile ( ` ^ ( ?s : ( . + ) ) \s \ ( ( [ ^ ) ] * : \w * ) \ ) $ ` ) var logs [ ] Log for _ , client Log : = range client Logs { matches : = message Matcher . Find String Submatch ( client Log . Message ) message , location : = client Log . Message , " " if len ( matches ) > 2 { message , location = matches [ 1 ] , matches [ 2 ] } log : = Log { message , location , client Log . Level , ms To Time ( client Log . Timestamp ) } logs = append ( logs , log ) } p . logs [ log Type ] = append ( p . logs [ log Type ] , logs . . . ) return logs , nil } 
func ( p * Page ) Read All Logs ( log Type string ) ( [ ] Log , error ) { if _ , err : = p . Read New Logs ( log Type ) ; err ! = nil { return nil , err } return append ( [ ] Log ( nil ) , p . logs [ log Type ] . . . ) , nil } 
func ( p * Page ) Move Mouse By ( x Offset , y Offset int ) error { if err : = p . session . Move To ( nil , api . XYOffset { X : x Offset , Y : y Offset } ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Double Click ( ) error { if err : = p . session . Double Click ( ) ; err ! = nil { return fmt . Errorf ( " " , err ) } return nil } 
func ( p * Page ) Click ( event Click , button Button ) error { var err error switch event { case Single Click : err = p . session . Click ( api . Button ( button ) ) case Hold Click : err = p . session . Button Down ( api . Button ( button ) ) case Release Click : err = p . session . Button Up ( api . Button ( button ) ) default : err = errors . New ( " " ) } if err ! = nil { return fmt . Errorf ( " " , event , button , err ) } return nil } 
func ( p * Page ) Set Implicit Wait ( timeout int ) error { return p . session . Set Implicit Wait ( timeout ) } 
func ( p * Page ) Set Page Load ( timeout int ) error { return p . session . Set Page Load ( timeout ) } 
func ( p * Page ) Set Script Timeout ( timeout int ) error { return p . session . Set Script Timeout ( timeout ) } 
func New Web Driver ( url string , command [ ] string , options . . . Option ) * Web Driver { api Web Driver : = api . New Web Driver ( url , command ) default Options : = config { Timeout : api Web Driver . Timeout } . Merge ( options ) api Web Driver . Timeout = default Options . Timeout api Web Driver . Debug = default Options . Debug api Web Driver . HTTPClient = default Options . HTTPClient return & Web Driver { api Web Driver , default Options } } 
func ( w * Web Driver ) New Page ( options . . . Option ) ( * Page , error ) { new Options : = w . default Options . Merge ( options ) session , err : = w . Open ( new Options . Capabilities ( ) ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return new Page ( session ) , nil } 
func ( s * Selection ) Click ( ) error { return s . for Each Element ( func ( selected Element element . Element ) error { if err : = selected Element . Click ( ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } ) } 
func ( s * Selection ) Double Click ( ) error { return s . for Each Element ( func ( selected Element element . Element ) error { if err : = s . session . Move To ( selected Element . ( * api . Element ) , nil ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = s . session . Double Click ( ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } ) } 
func ( s * Selection ) Fill ( text string ) error { return s . for Each Element ( func ( selected Element element . Element ) error { if err : = selected Element . Clear ( ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = selected Element . Value ( text ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } ) } 
func ( s * Selection ) Upload File ( filename string ) error { abs File Path , err : = filepath . Abs ( filename ) if err ! = nil { return fmt . Errorf ( " " , err ) } return s . for Each Element ( func ( selected Element element . Element ) error { tag Name , err : = selected Element . Get Name ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if tag Name ! = " " { return fmt . Errorf ( " " , s ) } input Type , err : = selected Element . Get Attribute ( " " ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if input Type ! = " " { return fmt . Errorf ( " " , s ) } if err : = selected Element . Value ( abs File Path ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } ) } 
func ( s * Selection ) Select ( text string ) error { return s . for Each Element ( func ( selected Element element . Element ) error { option XPath : = fmt . Sprintf ( ` . /option [normalize -space ( ) = " %s " ] ` , text ) option To Select : = target . Selector { Type : target . XPath , Value : option XPath } options , err : = selected Element . Get Elements ( option To Select . API ( ) ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if len ( options ) = = 0 { return fmt . Errorf ( `no options with text " %s " found for %s ` , text , s ) } for _ , option : = range options { if err : = option . Click ( ) ; err ! = nil { return fmt . Errorf ( `failed to click on option with text " %s " for %s : %s ` , text , s , err ) } } return nil } ) } 
func ( s * Selection ) Tap ( event Tap ) error { var touch Func func ( * api . Element ) error switch event { case Single Tap : touch Func = s . session . Touch Click case Double Tap : touch Func = s . session . Touch Double Click case Long Tap : touch Func = s . session . Touch Long Click default : return fmt . Errorf ( " " , event , s ) } return s . for Each Element ( func ( selected Element element . Element ) error { if err : = touch Func ( selected Element . ( * api . Element ) ) ; err ! = nil { return fmt . Errorf ( " " , event , s , err ) } return nil } ) } 
func ( s * Selection ) Touch ( event Touch ) error { var touch Func func ( x , y int ) error switch event { case Hold Finger : touch Func = s . session . Touch Down case Release Finger : touch Func = s . session . Touch Up case Move Finger : touch Func = s . session . Touch Move default : return fmt . Errorf ( " " , event , s ) } return s . for Each Element ( func ( selected Element element . Element ) error { x , y , err : = selected Element . Get Location ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = touch Func ( x , y ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } ) } 
func ( s * Selection ) Flick Finger ( x Offset , y Offset int , speed uint ) error { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = s . session . Touch Flick ( selected Element . ( * api . Element ) , api . XYOffset { X : x Offset , Y : y Offset } , api . Scalar Speed ( speed ) ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } 
func ( s * Selection ) Scroll Finger ( x Offset , y Offset int ) error { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = s . session . Touch Scroll ( selected Element . ( * api . Element ) , api . XYOffset { X : x Offset , Y : y Offset } ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } 
func ( s * Multi Selection ) At ( index int ) * Selection { return new Selection ( s . session , s . selectors . At ( index ) ) } 
func New Capabilities ( features . . . string ) Capabilities { c : = Capabilities { } for _ , feature : = range features { c . With ( feature ) } return c } 
func ( c Capabilities ) With ( feature string ) Capabilities { c [ feature ] = true return c } 
func ( c Capabilities ) Without ( feature string ) Capabilities { c [ feature ] = false return c } 
func ( c Capabilities ) JSON ( ) ( string , error ) { capabilities JSON , err : = json . Marshal ( c ) return string ( capabilities JSON ) , err } 
func Have Title ( title string ) types . Gomega Matcher { return & internal . Value Matcher { Method : " " , Property : " " , Expected : title } } 
func Have URL ( url string ) types . Gomega Matcher { return & internal . Value Matcher { Method : " " , Property : " " , Expected : url } } 
func Have Popup Text ( text string ) types . Gomega Matcher { return & internal . Value Matcher { Method : " " , Property : " " , Expected : text } } 
func Have Logged Error ( messages . . . string ) types . Gomega Matcher { return & internal . Log Matcher { Expected Messages : messages , Levels : [ ] string { " " , " " } , Name : " " , Type : " " , } } 
func ( s * Selection ) Text ( ) ( string , error ) { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return " " , fmt . Errorf ( " " , s , err ) } text , err : = selected Element . Get Text ( ) if err ! = nil { return " " , fmt . Errorf ( " " , s , err ) } return text , nil } 
func ( s * Selection ) Active ( ) ( bool , error ) { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return false , fmt . Errorf ( " " , s , err ) } active Element , err : = s . session . Get Active Element ( ) if err ! = nil { return false , fmt . Errorf ( " " , err ) } equal , err : = selected Element . Is Equal To ( active Element ) if err ! = nil { return false , fmt . Errorf ( " " , err ) } return equal , nil } 
func ( s * Selection ) Attribute ( attribute string ) ( string , error ) { return s . has Property ( element . Element . Get Attribute , attribute , " " ) } 
func ( s * Selection ) CSS ( property string ) ( string , error ) { return s . has Property ( element . Element . Get CSS , property , " " ) } 
func ( s * Selection ) Selected ( ) ( bool , error ) { return s . has State ( element . Element . Is Selected , " " ) } 
func ( s * Selection ) Visible ( ) ( bool , error ) { return s . has State ( element . Element . Is Displayed , " " ) } 
func ( s * Selection ) Enabled ( ) ( bool , error ) { return s . has State ( element . Element . Is Enabled , " " ) } 
func Have Count ( count int ) types . Gomega Matcher { return & internal . Value Matcher { Method : " " , Property : " " , Expected : count } } 
func Have Attribute ( attribute string , value string ) types . Gomega Matcher { return & internal . Have Attribute Matcher { Expected Attribute : attribute , Expected Value : value } } 
func Have CSS ( property string , value string ) types . Gomega Matcher { return & internal . Have CSSMatcher { Expected Property : property , Expected Value : value } } 
func Phantom JS ( options . . . Option ) * Web Driver { command : = [ ] string { " " , " " } default Options : = config { } . Merge ( options ) if ! default Options . Reject Invalid SSL { command = append ( command , " " ) } return New Web Driver ( " " , command , options . . . ) } 
func Edge Driver ( options . . . Option ) * Web Driver { var binary Name string if runtime . GOOS = = " " { binary Name = " " } else { return nil } command : = [ ] string { binary Name , " " } } 
func Selendroid ( jar File string , options . . . Option ) * Web Driver { abs JARPath , err : = filepath . Abs ( jar File ) if err ! = nil { return nil } command : = [ ] string { " " , " " , abs JARPath , " " , " " , } options = append ( [ ] Option { Timeout ( 9 0 ) , Browser ( " " ) } , options . . . ) return New Web Driver ( " " , command , options . . . ) } 
func Sauce Labs ( name , platform , browser , version , username , access Key string , options . . . Option ) ( * Page , error ) { url : = fmt . Sprintf ( " " , username , access Key ) capabilities : = New Capabilities ( ) . Browser ( browser ) . Platform ( platform ) . Version ( version ) capabilities [ " " ] = name return New Page ( url , append ( [ ] Option { Desired ( capabilities ) } , options . . . ) . . . ) } 
func Gecko Driver ( options . . . Option ) * Web Driver { var binary Name string if runtime . GOOS = = " " { binary Name = " " } else { binary Name = " " } command : = [ ] string { binary Name , " " } return New Web Driver ( " " , command , options . . . ) } 
func ( s * Selection ) Switch To Frame ( ) error { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = s . session . Frame ( selected Element . ( * api . Element ) ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } 
func ( s * Selection ) Elements ( ) ( [ ] * api . Element , error ) { elements , err : = s . elements . Get ( ) if err ! = nil { return nil , err } api Elements : = [ ] * api . Element { } for _ , selected Element : = range elements { api Elements = append ( api Elements , selected Element . ( * api . Element ) ) } return api Elements , nil } 
func ( s * Selection ) Count ( ) ( int , error ) { elements , err : = s . elements . Get ( ) if err ! = nil { return 0 , fmt . Errorf ( " " , s , err ) } return len ( elements ) , nil } 
func ( s * Selection ) Equals Element ( other interface { } ) ( bool , error ) { other Selection , ok : = other . ( * Selection ) if ! ok { multi Selection , ok : = other . ( * Multi Selection ) if ! ok { return false , fmt . Errorf ( " " ) } other Selection = & multi Selection . Selection } selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return false , fmt . Errorf ( " " , s , err ) } other Element , err : = other Selection . elements . Get Exactly One ( ) if err ! = nil { return false , fmt . Errorf ( " " , other , err ) } equal , err : = selected Element . Is Equal To ( other Element . ( * api . Element ) ) if err ! = nil { return false , fmt . Errorf ( " " , s , other , err ) } return equal , nil } 
func ( s * Selection ) Mouse To Element ( ) error { selected Element , err : = s . elements . Get Exactly One ( ) if err ! = nil { return fmt . Errorf ( " " , s , err ) } if err : = s . session . Move To ( selected Element . ( * api . Element ) , nil ) ; err ! = nil { return fmt . Errorf ( " " , s , err ) } return nil } 
func ( v * Verify Request ) Validate ( ) error { v . Args = [ ] string { } if len ( v . Pact URLs ) ! = 0 { v . Args = append ( v . Args , v . Pact URLs . . . ) } if len ( v . Pact URLs ) = = 0 & & v . Broker URL = = " " { return fmt . Errorf ( " " ) } if len ( v . Custom Provider Headers ) ! = 0 { for _ , header : = range v . Custom Provider Headers { v . Args = append ( v . Args , " " , header ) } } v . Args = append ( v . Args , " " , " " ) if v . Provider Base URL ! = " " { v . Args = append ( v . Args , " " , v . Provider Base URL ) } else { return fmt . Errorf ( " " ) } if v . Provider States Setup URL ! = " " { v . Args = append ( v . Args , " " , v . Provider States Setup URL ) } if v . Broker Username ! = " " { v . Args = append ( v . Args , " " , v . Broker Username ) } if v . Broker Password ! = " " { v . Args = append ( v . Args , " " , v . Broker Password ) } if v . Broker URL ! = " " & & ( ( v . Broker Username = = " " & & v . Broker Password ! = " " ) | | ( v . Broker Username ! = " " & & v . Broker Password = = " " ) ) { return errors . New ( " " ) } if v . Broker URL ! = " " { v . Args = append ( v . Args , " " , v . Broker URL ) } if v . Broker Token ! = " " { v . Args = append ( v . Args , " " , v . Broker Token ) } if v . Provider Version ! = " " { v . Args = append ( v . Args , " " , v . Provider Version ) } if v . Provider ! = " " { v . Args = append ( v . Args , " " , v . Provider ) } if v . Publish Verification Results { v . Args = append ( v . Args , " " , " " ) } if v . Verbose { log . Println ( " " ) } return nil } 
func logging Middleware ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { log . Printf ( " \n " , r . Remote Addr , r . Request URI ) next . Serve HTTP ( w , r ) } ) } 
func chain Handlers ( mw . . . Middleware ) Middleware { return func ( final http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { last : = final for i : = len ( mw ) - 1 ; i > = 0 ; i - - { last = mw [ i ] ( last ) } last . Serve HTTP ( w , r ) } ) } } 
func HTTPReverse Proxy ( options Options ) ( int , error ) { port : = options . Proxy Port var err error proxy : = httputil . New Single Host Reverse Proxy ( & url . URL { Scheme : options . Target Scheme , Host : options . Target Address , } ) if port = = 0 { port , err = utils . Get Free Port ( ) if err ! = nil { log . Println ( " " , err ) return 0 , err } } wrapper : = chain Handlers ( append ( options . Middleware , logging Middleware ) . . . ) log . Println ( " " , port ) go http . Listen And Serve ( fmt . Sprintf ( " " , port ) , wrapper ( proxy ) ) return port , nil } 
func ( i * Installer ) Check Installation ( ) error { for binary , version Range : = range version Map { log . Println ( " " , binary , " " , version Range ) version , err : = i . Get Version For Binary ( binary ) if err ! = nil { return err } if err = i . Check Version ( binary , version ) ; err ! = nil { return err } } return nil } 
func ( i * Installer ) Check Version ( binary , version string ) error { log . Println ( " " , binary , " " , version ) v , err : = goversion . New Version ( version ) if err ! = nil { log . Println ( " " , err ) return err } version Range , ok : = version Map [ binary ] if ! ok { return fmt . Errorf ( " " , binary ) } log . Println ( " " , v , " " , version Range ) constraints , err : = goversion . New Constraint ( version Range ) if constraints . Check ( v ) { log . Println ( " " , v , " " , v , constraints ) return nil } return fmt . Errorf ( " " , version , binary , version Range ) } 
func ( i * Installer ) Get Version For Binary ( binary string ) ( version string , err error ) { log . Println ( " " , binary ) content , err : = i . commander . Output ( binary , " " ) elements : = strings . Split ( strings . Trim Space ( string ( content ) ) , " \n " ) version = strings . Trim Space ( elements [ len ( elements ) - 1 ] ) return version , err } 
func ( c * Client ) get User ( id string ) ( * ex . User , error ) { u : = fmt . Sprintf ( " " , c . Host , id ) req , err : = http . New Request ( " " , u , nil ) req . Header . Set ( " " , c . token ) res , err : = http . Default Client . Do ( req ) if res . Status Code ! = 2 0 0 | | err ! = nil { return nil , fmt . Errorf ( " " ) } data , err : = ioutil . Read All ( res . Body ) if err ! = nil { return nil , err } var response ex . User err = json . Unmarshal ( data , & response ) if err ! = nil { return nil , err } return & response , err } 
func ( c * Client ) login ( username string , password string ) ( * ex . User , error ) { login Request : = fmt . Sprintf ( ` { "username " : " %s " , "password " : " %s " } ` , username , password ) res , err : = http . Post ( fmt . Sprintf ( " " , c . Host ) , " " , bytes . New Reader ( [ ] byte ( login Request ) ) ) if res . Status Code ! = 2 0 0 | | err ! = nil { return nil , fmt . Errorf ( " " ) } data , err : = ioutil . Read All ( res . Body ) if err ! = nil { return nil , err } var response login Response err = json . Unmarshal ( data , & response ) if err ! = nil { return nil , err } return & response . User , err } 
func ( c * Client ) login Handler ( w http . Response Writer , r * http . Request ) { username : = r . Form Value ( " " ) password : = r . Form Value ( " " ) user , err : = c . login ( username , password ) if err = = nil & & user ! = nil { c . user = user c . err = nil http . Redirect ( w , r , " " , http . Status Found ) return } c . err = fmt . Errorf ( " " ) http . Redirect ( w , r , " " , http . Status Found ) return } 
func ( c * Client ) logout Handler ( w http . Response Writer , r * http . Request ) { c . user = nil c . err = nil http . Redirect ( w , r , " " , http . Status Found ) return } 
func ( c * Client ) view Handler ( w http . Response Writer , r * http . Request ) { data : = template Data { User : c . user , Error : c . err , } render Template ( w , " " , data ) } 
func ( c * Client ) Run ( ) { http . Handle Func ( " " , c . login Handler ) http . Handle Func ( " " , c . logout Handler ) http . Handle Func ( " " , c . view Handler ) fmt . Println ( " " ) http . Listen And Serve ( " " , nil ) } 
func ( i * Interaction ) Given ( state string ) * Interaction { i . State = state return i } 
func ( i * Interaction ) Upon Receiving ( description string ) * Interaction { i . Description = description return i } 
func ( i * Interaction ) With Request ( request Request ) * Interaction { i . Request = request } return i } 
func ( i * Interaction ) Will Respond With ( response Response ) * Interaction { i . Response = response return i } 
func is JSONFormatted Object ( string Or Object interface { } ) bool { switch content : = string Or Object . ( type ) { case [ ] byte : case string : var obj interface { } err : = json . Unmarshal ( [ ] byte ( content ) , & obj ) if err ! = nil { return false } } } return false } 
func ( u * User Repository ) By Username ( username string ) ( * User , error ) { if user , ok : = u . Users [ username ] ; ok { return user , nil } return nil , Err Not Found } 
func ( u * User Repository ) By ID ( ID int ) ( * User , error ) { for _ , user : = range u . Users { if user . ID = = ID { return user , nil } } return nil , Err Not Found } 
func Is Authenticated ( h http . Handler Func ) http . Handler Func { return func ( w http . Response Writer , r * http . Request ) { if r . Header . Get ( " " ) = = fmt . Sprintf ( " " , get Auth Token ( ) ) { h . Serve HTTP ( w , r ) } else { w . Header ( ) . Set ( " " , " " ) w . Write Header ( http . Status Unauthorized ) } } } 
func User Login ( w http . Response Writer , r * http . Request ) { var login types . Login Request w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) body , err : = ioutil . Read All ( r . Body ) defer r . Body . Close ( ) if err ! = nil { w . Write Header ( http . Status Service Unavailable ) return } err = json . Unmarshal ( body , & login ) if err ! = nil { w . Write Header ( http . Status Service Unavailable ) return } user , err : = user Repository . By Username ( login . Username ) if err ! = nil { w . Write Header ( http . Status Not Found ) } else if user . Username ! = login . Username | | user . Password ! = login . Password { w . Write Header ( http . Status Unauthorized ) } else { w . Header ( ) . Set ( " " , get Auth Token ( ) ) w . Write Header ( http . Status OK ) res : = types . Login Response { User : user } res Body , _ : = json . Marshal ( res ) w . Write ( res Body ) } } 
func Get User ( w http . Response Writer , r * http . Request ) { w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) id , _ : = strconv . Atoi ( a [ len ( a ) - 1 ] ) user , err : = user Repository . By ID ( id ) if err ! = nil { w . Write Header ( http . Status Not Found ) } else { w . Write Header ( http . Status OK ) res Body , _ : = json . Marshal ( user ) w . Write ( res Body ) } } 
func new Client ( Mock Service Manager client . Service , verification Service Manager client . Service , message Service Manager client . Service , publish Service Manager client . Service ) * Pact Client { Mock Service Manager . Setup ( ) verification Service Manager . Setup ( ) message Service Manager . Setup ( ) publish Service Manager . Setup ( ) return & Pact Client { pact Mock Svc Manager : Mock Service Manager , verification Svc Manager : verification Service Manager , message Svc Manager : message Service Manager , publish Svc Manager : publish Service Manager , Timeout Duration : 1 0 * time . Second , } } 
func New Client ( ) * Pact Client { return new Client ( & client . Mock Service { } , & client . Verification Service { } , & client . Message Service { } , & client . Publish Service { } ) } 
func ( p * Pact Client ) Start Server ( args [ ] string , port int ) * types . Mock Server { log . Println ( " " , args , " " , port ) args = append ( args , [ ] string { " " , strconv . Itoa ( port ) } . . . ) svc : = p . pact Mock Svc Manager . New Service ( args ) cmd : = svc . Start ( ) wait For Port ( port , p . get Network Interface ( ) , p . Address , p . Timeout Duration , fmt . Sprintf ( `Timed out waiting for Mock Server to start on port %d - are you sure it 's running ? ` , port ) ) return & types . Mock Server { Pid : cmd . Process . Pid , Port : port , } } 
func ( p * Pact Client ) List Servers ( ) [ ] * types . Mock Server { log . Println ( " " ) var servers [ ] * types . Mock Server for port , s : = range p . pact Mock Svc Manager . List ( ) { servers = append ( servers , & types . Mock Server { Pid : s . Process . Pid , Port : port , } ) } return servers } 
func ( p * Pact Client ) Stop Server ( server * types . Mock Server ) ( * types . Mock Server , error ) { log . Println ( " " ) return server , server . Error } 
func ( p * Pact Client ) Remove All Servers ( server * types . Mock Server ) [ ] * types . Mock Server { log . Println ( " " ) for _ , s : = range p . verification Svc Manager . List ( ) { if s ! = nil { p . pact Mock Svc Manager . Stop ( s . Process . Pid ) } } return nil } 
func ( p * Pact Client ) Verify Provider ( request types . Verify Request ) ( types . Provider Verifier Response , error ) { log . Println ( " " ) var response types . Provider Verifier Response if err ! = nil { return response , err } address : = get Address ( request . Provider Base URL ) port : = get Port ( request . Provider Base URL ) wait For Port ( port , p . get Network Interface ( ) , address , p . Timeout Duration , fmt . Sprintf ( `Timed out waiting for Provider API to start on port %d - are you sure it 's running ? ` , port ) ) cmd : = svc . Command ( ) std Out Pipe , err : = cmd . Stdout Pipe ( ) if err ! = nil { return response , err } std Err Pipe , err : = cmd . Stderr Pipe ( ) if err ! = nil { return response , err } err = cmd . Start ( ) if err ! = nil { return response , err } std Out , err : = ioutil . Read All ( std Out Pipe ) if err ! = nil { return response , err } std Err , err : = ioutil . Read All ( std Err Pipe ) if err ! = nil { return response , err } err = cmd . Wait ( ) var verification types . Provider Verifier Response for _ , v : = range verifications { v = strings . Trim Space ( v ) response . Examples = append ( response . Examples , verification . Examples . . . ) if d Err ! = nil { err = d Err } } } if err = = nil { return response , err } return response , fmt . Errorf ( " \n \n \n \n \n \n " , err , std Err , std Out ) } 
func ( p * Pact Client ) Update Message Pact ( request types . Pact Message Request ) error { log . Println ( " " ) if err ! = nil { return err } svc : = p . message Svc Manager . New Service ( request . Args ) cmd : = svc . Command ( ) std Out Pipe , err : = cmd . Stdout Pipe ( ) if err ! = nil { return err } std Err Pipe , err : = cmd . Stderr Pipe ( ) if err ! = nil { return err } err = cmd . Start ( ) if err ! = nil { return err } std Out , err : = ioutil . Read All ( std Out Pipe ) if err ! = nil { return err } std Err , err : = ioutil . Read All ( std Err Pipe ) if err ! = nil { return err } err = cmd . Wait ( ) if err = = nil { return nil } return fmt . Errorf ( " \n \n \n \n \n \n " , err , std Err , std Out ) } 
func ( p * Pact Client ) Publish Pacts ( request types . Publish Request ) error { svc : = p . publish Svc Manager . New Service ( request . Args ) log . Println ( " " ) cmd : = svc . Start ( ) log . Println ( " " ) err : = cmd . Wait ( ) log . Println ( " " , err ) return err } 
func ( p * Pact Client ) Reify Message ( request * types . Pact Reification Request ) ( res * types . Reification Response , err error ) { log . Println ( " " ) var response Object interface { } res = & types . Reification Response { Response : response Object , } if err ! = nil { return } svc : = p . message Svc Manager . New Service ( request . Args ) cmd : = svc . Command ( ) std Out Pipe , err : = cmd . Stdout Pipe ( ) if err ! = nil { return } std Err Pipe , err : = cmd . Stderr Pipe ( ) if err ! = nil { return } err = cmd . Start ( ) if err ! = nil { return } std Out , err : = ioutil . Read All ( std Out Pipe ) if err ! = nil { return } std Err , err : = ioutil . Read All ( std Err Pipe ) if err ! = nil { return } err = cmd . Wait ( ) res . Response Raw = std Out decoder : = json . New Decoder ( bytes . New Reader ( std Out ) ) d Err : = decoder . Decode ( & res . Response ) if d Err = = nil { return } if err = = nil { err = d Err } if err = = nil { return } err = fmt . Errorf ( " \n \n \n \n \n \n " , err , std Err , std Out ) return } 
func get Port ( raw URL string ) int { parsed URL , err : = url . Parse ( raw URL ) if err = = nil { split Host : = strings . Split ( parsed URL . Host , " " ) if len ( split Host ) = = 2 { port , err : = strconv . Atoi ( split Host [ 1 ] ) if err = = nil { return port } } if parsed URL . Scheme = = " " { return 4 4 3 } return 8 0 } return - 1 } 
func get Address ( raw URL string ) string { parsed URL , err : = url . Parse ( raw URL ) if err ! = nil { return " " } split Host : = strings . Split ( parsed URL . Host , " " ) return split Host [ 0 ] } 
func sanitise Ruby Response ( response string ) string { log . Println ( " " , response ) r : = regexp . Must Compile ( " \ \ " ) s : = r . Replace All String ( response , " " ) r = regexp . Must Compile ( " " ) s = r . Replace All String ( s , " " ) r = regexp . Must Compile ( " \ \ " ) s = r . Replace All String ( s , " \n " ) return s } 
func ( s * Service Mock ) Stop ( pid int ) ( bool , error ) { s . Service Stop Count + + return s . Service Stop Result , s . Service Stop Error } 
func ( s * Service Mock ) Start ( ) * exec . Cmd { s . Service Start Count + + cmd : = s . Exec Func ( ) cmd . Start ( ) if s . processes = = nil { s . processes = make ( map [ int ] * exec . Cmd ) } s . processes [ cmd . Process . Pid ] = cmd return cmd } 
func ( v * Publish Service ) New Service ( args [ ] string ) Service { log . Printf ( " \n " , args ) v . Args = [ ] string { " " , } v . Args = append ( v . Args , args . . . ) v . Cmd = get Publisher Command Path ( ) return v } 
func ( v * Message Service ) New Service ( args [ ] string ) Service { v . Args = args log . Printf ( " \n " , v . Args ) v . Cmd = " " return v } 
func ( m * Pact Reification Request ) Validate ( ) error { m . Args = [ ] string { } body , err : = json . Marshal ( m . Message ) if err ! = nil { return err } m . Args = append ( m . Args , [ ] string { " " , string ( body ) , } . . . ) return nil } 
func ( p * Publisher ) Publish ( request types . Publish Request ) error { log . Println ( " " ) if p . pact Client = = nil { c : = New Client ( ) p . pact Client = c } err : = request . Validate ( ) if err ! = nil { return err } return p . pact Client . Publish Pacts ( request ) } 
func ( p * Publish Request ) Validate ( ) error { p . Args = [ ] string { } if len ( p . Pact URLs ) ! = 0 { p . Args = append ( p . Args , p . Pact URLs . . . ) } else { return fmt . Errorf ( " " ) } if p . Broker Username ! = " " { p . Args = append ( p . Args , " " , p . Broker Username ) } if p . Broker Password ! = " " { p . Args = append ( p . Args , " " , p . Broker Password ) } if p . Pact Broker ! = " " & & ( ( p . Broker Username = = " " & & p . Broker Password ! = " " ) | | ( p . Broker Username ! = " " & & p . Broker Password = = " " ) ) { return errors . New ( " " ) } if p . Pact Broker = = " " { return fmt . Errorf ( " " ) } p . Args = append ( p . Args , " " , p . Pact Broker ) if p . Broker Token ! = " " { p . Args = append ( p . Args , " " , p . Broker Token ) } if p . Consumer Version = = " " { return fmt . Errorf ( " " ) } p . Args = append ( p . Args , " " , p . Consumer Version ) if len ( p . Tags ) > 0 { for _ , t : = range p . Tags { p . Args = append ( p . Args , " " , t ) } } if p . Verbose { p . Args = append ( p . Args , " " ) } return nil } 
func ( v * Verify Message Request ) Validate ( ) error { v . Args = [ ] string { } if len ( v . Pact URLs ) ! = 0 { v . Args = append ( v . Args , v . Pact URLs . . . ) } else { return fmt . Errorf ( " " ) } v . Args = append ( v . Args , " " , " " ) if v . Broker Username ! = " " { v . Args = append ( v . Args , " " , v . Broker Username ) } if v . Broker Password ! = " " { v . Args = append ( v . Args , " " , v . Broker Password ) } if v . Provider Version ! = " " { v . Args = append ( v . Args , " " , v . Provider Version ) } if v . Publish Verification Results { v . Args = append ( v . Args , " " , " " ) } return nil } 
func Find Port In Range ( s string ) ( int , error ) { for _ , p : = range ports { i , err : = strconv . Atoi ( p ) if err ! = nil { return 0 , err } err = check Port ( i ) if err ! = nil { continue } return i , nil } return 0 , errors . New ( " " ) } if len ( ports ) ! = 2 { return 0 , errors . New ( " " ) } lower , err : = strconv . Atoi ( ports [ 0 ] ) if err ! = nil { return 0 , err } upper , err : = strconv . Atoi ( ports [ 1 ] ) if err ! = nil { return 0 , err } if upper < lower { return 0 , errors . New ( " " ) } for i : = lower ; i < = upper ; i + + { err = check Port ( i ) if err ! = nil { continue } return i , nil } return 0 , errors . New ( " " ) } 
func Each Like ( content interface { } , min Required int ) Matcher { return each Like { Contents : content , Min : min Required , } } 
func Term ( generate string , matcher string ) Matcher { return term { Data : term Data { Generate : generate , Matcher : term Matcher { Type : " " , O : 0 , Regex : matcher , } , } , } } 
func ( m * Map Matcher ) Unmarshal JSON ( bytes [ ] byte ) ( err error ) { sk : = make ( map [ string ] string ) err = json . Unmarshal ( bytes , & sk ) if err ! = nil { return } * m = make ( map [ string ] Matcher ) for k , v : = range sk { ( * m ) [ k ] = String ( v ) } return } 
func object To String ( obj interface { } ) string { switch content : = obj . ( type ) { case string : return content default : json String , err : = json . Marshal ( obj ) if err ! = nil { log . Println ( " " , err . Error ( ) ) return " " } return string ( json String ) } } 
func match ( src Type reflect . Type , params params ) Matcher { switch kind : = src Type . Kind ( ) ; kind { case reflect . Ptr : return match ( src Type . Elem ( ) , params ) case reflect . Slice , reflect . Array : return Each Like ( match ( src Type . Elem ( ) , get Defaults ( ) ) , params . slice . min ) case reflect . Struct : result : = Struct Matcher { } for i : = 0 ; i < src Type . Num Field ( ) ; i + + { field : = src Type . Field ( i ) result [ field . Tag . Get ( " " ) ] = match ( field . Type , pluck Params ( field . Type , field . Tag . Get ( " " ) ) ) } return result case reflect . String : if params . str . reg Ex ! = " " { return Term ( params . str . example , params . str . reg Ex ) } if params . str . example ! = " " { return Like ( params . str . example ) } return Like ( " " ) case reflect . Bool : return Like ( true ) case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 , reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return Like ( 1 ) case reflect . Float 3 2 , reflect . Float 6 4 : return Like ( 1 . 1 ) default : panic ( fmt . Sprintf ( " " , src Type ) ) } } 
func pluck Params ( src Type reflect . Type , pact Tag string ) params { params : = get Defaults ( ) if pact Tag = = " " { return params } switch kind : = src Type . Kind ( ) ; kind { case reflect . Slice : if _ , err : = fmt . Sscanf ( pact Tag , " " , & params . slice . min ) ; err ! = nil { trigger Invalid Pact Tag Panic ( pact Tag , err ) } case reflect . String : full Regex , _ : = regexp . Compile ( `regex = ( . * ) $ ` ) example Regex , _ : = regexp . Compile ( ` ^example = ( . * ) ` ) if full Regex . Match ( [ ] byte ( pact Tag ) ) { components : = strings . Split ( pact Tag , " " ) if len ( components [ 1 ] ) = = 0 { trigger Invalid Pact Tag Panic ( pact Tag , fmt . Errorf ( " " ) ) } if _ , err : = fmt . Sscanf ( components [ 0 ] , " " , & params . str . example ) ; err ! = nil { trigger Invalid Pact Tag Panic ( pact Tag , err ) } params . str . reg Ex = strings . Replace ( components [ 1 ] , ` \ ` , ` \ \ ` , - 1 ) } else if example Regex . Match ( [ ] byte ( pact Tag ) ) { components : = strings . Split ( pact Tag , " " ) if len ( components ) ! = 2 | | strings . Trim Space ( components [ 1 ] ) = = " " { trigger Invalid Pact Tag Panic ( pact Tag , fmt . Errorf ( " " ) ) } params . str . example = components [ 1 ] } } return params } 
func ( p * Pact ) Add Message ( ) * Message { log . Println ( " " ) m : = & Message { } p . Message Interactions = append ( p . Message Interactions , m ) return m } 
func ( p * Pact ) Add Interaction ( ) * Interaction { p . Setup ( true ) log . Println ( " " ) i : = & Interaction { } p . Interactions = append ( p . Interactions , i ) return i } 
func ( p * Pact ) Setup ( start Mock Server bool ) * Pact { p . setup Logging ( ) log . Println ( " " ) dir , _ : = os . Getwd ( ) if p . Network = = " " { p . Network = " " } if ! p . tool Validity Check & & ! ( p . Disable Tool Validity Check | | os . Getenv ( " " ) ! = " " ) { check Cli Compatibility ( ) p . tool Validity Check = true } if p . Host = = " " { p . Host = " " } if p . Log Dir = = " " { p . Log Dir = fmt . Sprintf ( filepath . Join ( dir , " " ) ) } if p . Pact Dir = = " " { p . Pact Dir = fmt . Sprintf ( filepath . Join ( dir , " " ) ) } if p . Specification Version = = 0 { p . Specification Version = 2 } if p . Client Timeout = = 0 { p . Client Timeout = 1 0 * time . Second } if p . pact Client = = nil { c : = New Client ( ) c . Timeout Duration = p . Client Timeout p . pact Client = c } if p . Pact File Write Mode = = " " { p . Pact File Write Mode = " " } var perr error if p . Allowed Mock Server Ports ! = " " { port , perr = utils . Find Port In Range ( p . Allowed Mock Server Ports ) } else { port , perr = utils . Get Free Port ( ) } if perr ! = nil { log . Println ( " " ) } if p . Server = = nil & & start Mock Server { log . Println ( " " , port ) args : = [ ] string { " " , fmt . Sprintf ( " " , p . Specification Version ) , " " , filepath . From Slash ( p . Pact Dir ) , " " , filepath . From Slash ( p . Log Dir + " " + " " ) , " " , p . Consumer , " " , p . Provider , " " , p . Pact File Write Mode , } p . Server = p . pact Client . Start Server ( args , port ) } return p } 
func ( p * Pact ) setup Logging ( ) { if p . log Filter = = nil { if p . Log Level = = " " { p . Log Level = " " } p . log Filter = & logutils . Level Filter { Levels : [ ] logutils . Log Level { " " , " " , " " , " " } , Min Level : logutils . Log Level ( p . Log Level ) , Writer : os . Stderr , } log . Set Output ( p . log Filter ) } log . Println ( " " ) } 
func ( p * Pact ) Teardown ( ) * Pact { log . Println ( " " ) if p . Server ! = nil { server , err : = p . pact Client . Stop Server ( p . Server ) if err ! = nil { log . Println ( " " , err ) } p . Server = server } return p } 
func ( p * Pact ) Verify ( integration Test func ( ) error ) error { p . Setup ( true ) log . Println ( " " ) } mock Server : = & Mock Service { Base URL : fmt . Sprintf ( " " , p . Host , p . Server . Port ) , Consumer : p . Consumer , Provider : p . Provider , } for _ , interaction : = range p . Interactions { err : = mock Server . Add Interaction ( interaction ) if err ! = nil { return err } } if err ! = nil { return err } if err ! = nil { return err } return mock Server . Delete Interactions ( ) } 
func ( p * Pact ) Write Pact ( ) error { p . Setup ( true ) log . Println ( " " ) mock Server : = Mock Service { Base URL : fmt . Sprintf ( " " , p . Host , p . Server . Port ) , Consumer : p . Consumer , Provider : p . Provider , Pact File Write Mode : p . Pact File Write Mode , } err : = mock Server . Write Pact ( ) if err ! = nil { return err } return nil } 
func ( p * Pact ) Verify Provider Raw ( request types . Verify Request ) ( types . Provider Verifier Response , error ) { p . Setup ( false ) var res types . Provider Verifier Response u , err : = url . Parse ( request . Provider Base URL ) if err ! = nil { return res , err } m : = [ ] proxy . Middleware { } if request . Before Each ! = nil { m = append ( m , Before Each Middleware ( request . Before Each ) ) } if request . After Each ! = nil { m = append ( m , After Each Middleware ( request . After Each ) ) } if len ( request . State Handlers ) > 0 { m = append ( m , state Handler Middleware ( request . State Handlers ) ) } if request . Request Filter ! = nil { m = append ( m , request . Request Filter ) } if request . Provider States Setup URL = = " " { setup URL = fmt . Sprintf ( " " , u . Scheme , port ) } if request . Provider = = " " { verification Request . Provider = p . Provider } port Err : = wait For Port ( port , " " , " " , p . Client Timeout , fmt . Sprintf ( `Timed out waiting for http verification proxy on port %d - check for errors ` , port ) ) if port Err ! = nil { log . Fatal ( " " , err ) return res , port Err } log . Println ( " " ) return p . pact Client . Verify Provider ( verification Request ) } 
func ( p * Pact ) Verify Provider ( t * testing . T , request types . Verify Request ) ( types . Provider Verifier Response , error ) { res , err : = p . Verify Provider Raw ( request ) for _ , example : = range res . Examples { t . Run ( example . Description , func ( st * testing . T ) { st . Log ( example . Full Description ) if example . Status ! = " " { t . Errorf ( " \n \n " , example . Full Description , example . Exception . Message ) } } ) } return res , err } 
func After Each Middleware ( After Each types . Hook ) proxy . Middleware { return func ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { next . Serve HTTP ( w , r ) if r . URL . Path ! = " " { log . Println ( " " ) err : = After Each ( ) if err ! = nil { log . Println ( " " , err ) w . Write Header ( http . Status Internal Server Error ) } } } ) } } 
func state Handler Middleware ( state Handlers types . State Handlers ) proxy . Middleware { return func ( next http . Handler ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { if r . URL . Path = = " " { var s * types . Provider State decoder : = json . New Decoder ( r . Body ) decoder . Decode ( & s ) if ! state Found { log . Printf ( " " , state ) } else { w . Write Header ( http . Status Internal Server Error ) return } } } w . Write Header ( http . Status OK ) return } log . Println ( " " , r . Request URI ) } ) } } 
func ( p * Pact ) Verify Message Provider ( t * testing . T , request Verify Message Request ) ( res types . Provider Verifier Response , err error ) { res , err = p . Verify Message Provider Raw ( request ) for _ , example : = range res . Examples { t . Run ( example . Description , func ( st * testing . T ) { st . Log ( example . Full Description ) if example . Status ! = " " { st . Errorf ( " \n " , example . Exception . Message ) st . Error ( " " ) } } ) } return } 
func ( p * Pact ) Verify Message Provider Raw ( request Verify Message Request ) ( types . Provider Verifier Response , error ) { p . Setup ( false ) response : = types . Provider Verifier Response { } port , err : = utils . Get Free Port ( ) if err ! = nil { return response , fmt . Errorf ( " " , err ) } mux . Handle Func ( " " , message Verification Handler ( request . Message Handlers , request . State Handlers ) ) ln , err : = net . Listen ( " " , fmt . Sprintf ( " " , port ) ) if err ! = nil { log . Fatal ( err ) } defer ln . Close ( ) log . Printf ( " " , port , ln . Addr ( ) ) go http . Serve ( ln , mux ) port Err : = wait For Port ( port , " " , " " , p . Client Timeout , fmt . Sprintf ( `Timed out waiting for pact proxy on port %d - check for errors ` , port ) ) if port Err ! = nil { log . Fatal ( " " , err ) return response , port Err } log . Println ( " " ) return p . pact Client . Verify Provider ( verification Request ) } 
func ( p * Pact ) Verify Message Consumer Raw ( message * Message , handler Message Consumer ) error { log . Printf ( " " ) p . Setup ( false ) if err ! = nil { return fmt . Errorf ( " " , err ) } t : = reflect . Type Of ( message . Type ) if t ! = nil & & t . Name ( ) ! = " " { log . Println ( " " , t . Name ( ) ) err = json . Unmarshal ( reified . Response Raw , & message . Type ) if err ! = nil { return fmt . Errorf ( " " , t . Name ( ) , err ) } } err = handler ( generated Message ) if err ! = nil { return err } } 
func ( p * Pact ) Verify Message Consumer ( t * testing . T , message * Message , handler Message Consumer ) error { err : = p . Verify Message Consumer Raw ( message , handler ) if err ! = nil { t . Errorf ( " " , err ) } return err } 
func ( p * mock Client ) Start Server ( args [ ] string , port int ) * types . Mock Server { return p . Mock Server } 
func ( p * mock Client ) Stop Server ( server * types . Mock Server ) ( * types . Mock Server , error ) { return p . Stop Server Response , p . Stop Server Error } 
func ( p * mock Client ) Remove All Servers ( server * types . Mock Server ) [ ] * types . Mock Server { return p . Remove All Servers Response } 
func ( p * mock Client ) Verify Provider ( request types . Verify Request ) ( types . Provider Verifier Response , error ) { return p . Verify Provider Response , p . Verify Provider Error } 
func ( p * mock Client ) Reify Message ( request * types . Pact Reification Request ) ( res * types . Reification Response , err error ) { return p . Reify Message Response , p . Reify Message Error } 
func ( m * Mock Service ) New Service ( args [ ] string ) Service { m . Args = [ ] string { " " , } m . Args = append ( m . Args , args . . . ) m . Cmd = get Mock Service Command Path ( ) return m } 
func ( s * Service Manager ) Setup ( ) { log . Println ( " " ) s . command Created Chan = make ( chan * exec . Cmd ) s . command Complete Chan = make ( chan * exec . Cmd ) s . process Map = process Map { processes : make ( map [ int ] * exec . Cmd ) } go s . remove Service Monitor ( ) } 
func ( s * Service Manager ) add Service Monitor ( ) { log . Println ( " " ) for { select { case p : = < - s . command Created Chan : if p ! = nil & & p . Process ! = nil { s . process Map . Set ( p . Process . Pid , p ) } } } } 
func ( s * Service Manager ) remove Service Monitor ( ) { log . Println ( " " ) var p * exec . Cmd for { select { case p = < - s . command Complete Chan : if p ! = nil & & p . Process ! = nil { p . Process . Signal ( os . Interrupt ) s . process Map . Delete ( p . Process . Pid ) } } } } 
func ( s * Service Manager ) Stop ( pid int ) ( bool , error ) { log . Println ( " " , pid ) cmd : = s . process Map . Get ( pid ) } ( ) done : = make ( chan error , 1 ) go func ( ) { done < - cmd . Wait ( ) } ( ) select { case < - time . After ( 3 * time . Second ) : if err = cmd . Process . Kill ( ) ; err ! = nil { log . Println ( " " , pid ) return false , err } case err = < - done : if err ! = nil { log . Println ( " " , err ) return false , err } } return true , nil } 
func ( s * Service Manager ) List ( ) map [ int ] * exec . Cmd { log . Println ( " " ) return s . process Map . processes } 
func ( s * Service Manager ) Command ( ) * exec . Cmd { cmd : = exec . Command ( s . Cmd , s . Args . . . ) env : = os . Environ ( ) env = append ( env , s . Env . . . ) cmd . Env = env return cmd } 
func ( s * Service Manager ) Start ( ) * exec . Cmd { log . Println ( " " ) cmd : = exec . Command ( s . Cmd , s . Args . . . ) env : = os . Environ ( ) env = append ( env , s . Env . . . ) cmd . Env = env cmd Reader , err : = cmd . Stdout Pipe ( ) if err ! = nil { log . Printf ( " \n " , err . Error ( ) ) } cmd Reader Err , err : = cmd . Stderr Pipe ( ) if err ! = nil { log . Printf ( " \n " , err . Error ( ) ) } scanner : = bufio . New Scanner ( cmd Reader ) go func ( ) { for scanner . Scan ( ) { log . Printf ( " \n " , scanner . Text ( ) ) } } ( ) scanner 2 : = bufio . New Scanner ( cmd Reader Err ) go func ( ) { for scanner 2 . Scan ( ) { log . Printf ( " \n " , scanner 2 . Text ( ) ) } } ( ) err = cmd . Start ( ) if err ! = nil { log . Println ( " " , err . Error ( ) ) } return cmd } 
func ( m * Mock Service ) call ( method string , url string , content interface { } ) error { body , err : = json . Marshal ( content ) if err ! = nil { fmt . Println ( err ) return err } client : = & http . Client { } var req * http . Request if method = = " " { req , err = http . New Request ( method , url , bytes . New Reader ( body ) ) } else { req , err = http . New Request ( method , url , nil ) } if err ! = nil { return err } req . Header . Set ( " " , " " ) req . Header . Set ( " " , " " ) res , err : = client . Do ( req ) if err ! = nil { return err } response Body , err : = ioutil . Read All ( res . Body ) res . Body . Close ( ) if res . Status Code < 2 0 0 | | res . Status Code > = 3 0 0 { return errors . New ( string ( response Body ) ) } return err } 
func ( m * Mock Service ) Delete Interactions ( ) error { log . Println ( " " ) url : = fmt . Sprintf ( " " , m . Base URL ) return m . call ( " " , url , nil ) } 
func ( m * Mock Service ) Add Interaction ( interaction * Interaction ) error { log . Println ( " " ) url : = fmt . Sprintf ( " " , m . Base URL ) return m . call ( " " , url , interaction ) } 
func ( m * Mock Service ) Write Pact ( ) error { log . Println ( " " ) if m . Consumer = = " " | | m . Provider = = " " { return errors . New ( " " ) } if m . Pact File Write Mode = = " " { m . Pact File Write Mode = " " } pact : = map [ string ] interface { } { " " : map [ string ] string { " " : m . Consumer , } , " " : map [ string ] string { " " : m . Provider , } , " " : m . Pact File Write Mode , } url : = fmt . Sprintf ( " " , m . Base URL ) return m . call ( " " , url , pact ) } 
func ( p * Message ) Given ( state string ) * Message { p . States = [ ] State { State { Name : state } } return p } 
func ( p * Message ) Expects To Receive ( description string ) * Message { p . Description = description return p } 
func ( p * Message ) With Metadata ( metadata Map Matcher ) * Message { p . Metadata = metadata return p } 
func ( p * Message ) As Type ( t interface { } ) * Message { fmt . Println ( " " , reflect . Type Of ( t ) ) p . Type = t return p } 
func Is Authenticated ( ) gin . Handler Func { return func ( c * gin . Context ) { fmt . Println ( c . Get Header ( " " ) ) if c . Get Header ( " " ) = = fmt . Sprintf ( " " , get Auth Token ( ) ) { c . Next ( ) } else { c . JSON ( http . Status Unauthorized , gin . H { " " : " " } ) } } } 
func User Login ( c * gin . Context ) { c . Header ( " " , " " ) var json Login if c . Bind JSON ( & json ) = = nil { user , err : = user Repository . By Username ( json . User ) if err ! = nil { c . JSON ( http . Status Not Found , gin . H { " " : " " } ) } else if user . Username ! = json . User | | user . Password ! = json . Password { c . JSON ( http . Status Unauthorized , gin . H { " " : " " } ) } else { c . Header ( " " , get Auth Token ( ) ) c . JSON ( http . Status OK , types . Login Response { User : user } ) } } } 
func Get User ( c * gin . Context ) { fmt . Println ( " " ) c . Header ( " " , " " ) id , _ : = strconv . Atoi ( c . Param ( " " ) ) user , err : = user Repository . By ID ( id ) if err ! = nil { c . JSON ( http . Status Not Found , gin . H { " " : " " } ) } else { c . JSON ( http . Status OK , user ) } } 
func ( m * Pact Message Request ) Validate ( ) error { m . Args = [ ] string { } body , err : = json . Marshal ( m . Message ) if err ! = nil { return err } m . Args = append ( m . Args , [ ] string { " " , string ( body ) , " " , m . Consumer , " " , m . Provider , " " , m . Pact Dir , " " , " " , } . . . ) return nil } 
func ( v * Verification Service ) New Service ( args [ ] string ) Service { log . Printf ( " \n " , args ) v . Args = args v . Cmd = get Verifier Command Path ( ) v . Env = append ( os . Environ ( ) , `PACT _INTERACTION _RERUN _COMMAND = "To re -run this specific test , set the following environment variables and run your test again : PACT _DESCRIPTION = \ " <PACT _DESCRIPTION > \ " PACT _PROVIDER _STATE = \ " <PACT _PROVIDER _STATE > \ " " ` ) return v } 
func ( s * S 3 ) Region ( ) string { region : = os . Getenv ( " " ) switch s . Domain { case " " , " " : return " " case " " : if region = = " " { panic ( " " ) } return region default : regions : = region Matcher . Find String Submatch ( s . Domain ) if len ( regions ) < 2 { if region = = " " { panic ( " " ) } return region } return regions [ 1 ] } } 
func New ( domain string , keys Keys ) * S 3 { if domain = = " " { domain = Default Domain } return & S 3 { domain , keys } } 
func ( s * S 3 ) Bucket ( name string ) * Bucket { return & Bucket { S 3 : s , Name : name , Config : Default Config , } } 
func ( b * Bucket ) Get Reader ( path string , c * Config ) ( r io . Read Closer , h http . Header , err error ) { if path = = " " { return nil , nil , errors . New ( " " ) } if c = = nil { c = b . conf ( ) } u , err : = b . url ( path , c ) if err ! = nil { return nil , nil , err } return new Getter ( * u , c , b ) } 
func ( b * Bucket ) Put Writer ( path string , h http . Header , c * Config ) ( w io . Write Closer , err error ) { if c = = nil { c = b . conf ( ) } u , err : = b . url ( path , c ) if err ! = nil { return nil , err } return new Putter ( * u , h , c , b ) } 
func ( b * Bucket ) url ( b Path string , c * Config ) ( * url . URL , error ) { if err ! = nil { return nil , err } var vals url . Values if v : = purl . Query ( ) . Get ( version Param ) ; v ! = " " { vals = make ( url . Values ) vals . Add ( version Param , v ) b Path = strings . Split ( b Path , " " ) [ 0 ] } } else { return & url . URL { Scheme : c . Scheme , Path : path . Clean ( fmt . Sprintf ( " " , b Path ) ) , Host : path . Clean ( fmt . Sprintf ( " " , b . Name , b . S 3 . Domain ) ) , Raw Query : vals . Encode ( ) , } , nil } } 
func ( b * Bucket ) Delete ( path string ) error { if err : = b . delete ( path ) ; err ! = nil { return err } } } logger . Printf ( " \n " , path , b . Name ) return nil } 
func Set Logger ( out io . Writer , prefix string , flag int , debug bool ) { logger = internal Logger { log . New ( out , prefix , flag ) , debug , } } 
func init ( ) { logger = internal Logger { log . New ( ioutil . Discard , " " , log . Lstd Flags ) , false , } } 
func Instance Keys ( ) ( keys Keys , err error ) { role Path : = " " var creds md Creds if err ! = nil { return } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 0 { err = new Resp Error ( resp ) return } role , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return } if err ! = nil { return } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 0 { err = new Resp Error ( resp ) return } metadata , err : = ioutil . Read All ( resp . Body ) if err ! = nil { return } if err = json . Unmarshal ( [ ] byte ( metadata ) , & creds ) ; err ! = nil { return } keys = Keys { Access Key : creds . Access Key ID , Secret Key : creds . Secret Access Key , Security Token : creds . Token , } return } 
func Env Keys ( ) ( keys Keys , err error ) { keys = Keys { Access Key : os . Getenv ( " " ) , Secret Key : os . Getenv ( " " ) , Security Token : os . Getenv ( " " ) , } if keys . Access Key = = " " | | keys . Secret Key = = " " { err = fmt . Errorf ( " " ) } return } 
func Client With Timeout ( timeout time . Duration ) * http . Client { transport : = & http . Transport { Proxy : http . Proxy From Environment , Dial : func ( netw , addr string ) ( net . Conn , error ) { c , err : = net . Dial Timeout ( netw , addr , timeout ) if err ! = nil { return nil , err } if tc , ok : = c . ( * net . TCPConn ) ; ok { tc . Set Keep Alive ( true ) tc . Set Keep Alive Period ( timeout ) } return & deadline Conn { timeout , c } , nil } , Response Header Timeout : timeout , Max Idle Conns Per Host : 1 0 , } return & http . Client { Transport : transport } } 
func ( b * Bucket ) Sign ( req * http . Request ) { if req . Header = = nil { req . Header = http . Header { } } if b . S 3 . Keys . Security Token ! = " " { req . Header . Set ( " " , b . S 3 . Keys . Security Token ) } req . Header . Set ( " " , " " ) s : = & signer { Time : time . Now ( ) , Request : req , Region : b . S 3 . Region ( ) , Keys : b . S 3 . Keys , } s . sign ( ) } 
func get AWSKeys ( ) ( keys s 3gof 3r . Keys , err error ) { keys , err = s 3gof 3r . Env Keys ( ) if err = = nil { return } keys , err = s 3gof 3r . Instance Keys ( ) if err = = nil { return } err = errors . New ( " " ) return } 
func home Dir ( ) ( string , error ) { if h : = os . Getenv ( " " ) ; h ! = " " { return h , nil } h , err : = exec . Command ( " " , " " , " " ) . Output ( ) if err = = nil & & len ( h ) > 0 { return strings . Trim Space ( string ( h ) ) , nil } return " " , fmt . Errorf ( " " ) } 
func ACL ( h http . Header , acl string ) http . Header { if acl ! = " " { h . Set ( " " , acl ) } return h } 
func new Putter ( url url . URL , h http . Header , c * Config , b * Bucket ) ( p * putter , err error ) { p = new ( putter ) p . url = url p . c , p . b = new ( Config ) , new ( Bucket ) * p . c , * p . b = * c , * b p . c . Concurrency = max ( c . Concurrency , 1 ) p . c . NTry = max ( c . NTry , 1 ) p . bufsz = max 6 4 ( min Part Size , c . Part Size ) resp , err : = p . retry Request ( " " , url . String ( ) + " " , nil , h ) if err ! = nil { return nil , err } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 0 { return nil , new Resp Error ( resp ) } err = xml . New Decoder ( resp . Body ) . Decode ( p ) if err ! = nil { return nil , err } p . ch = make ( chan * part ) for i : = 0 ; i < p . c . Concurrency ; i + + { go p . worker ( ) } p . md 5Of Parts = md 5 . New ( ) p . md 5 = md 5 . New ( ) p . sp = buffer Pool ( p . bufsz ) return p , nil } 
func ( p * putter ) retry Put Part ( part * part ) { defer p . wg . Done ( ) var err error for i : = 0 ; i < p . c . NTry ; i + + { err = p . put Part ( part ) if err = = nil { p . sp . give < - part . b part . b = nil return } logger . debug Printf ( " " , i , part . Part Number , err ) time . Sleep ( time . Duration ( math . Exp 2 ( float 6 4 ( i ) ) ) * 1 0 0 * time . Millisecond ) } p . err = err } 
func ( p * putter ) put Part ( part * part ) error { v : = url . Values { } v . Set ( " " , strconv . Itoa ( part . Part Number ) ) v . Set ( " " , p . Upload ID ) if _ , err : = part . r . Seek ( 0 , 0 ) ; err ! = nil { } req , err : = http . New Request ( " " , p . url . String ( ) + " " + v . Encode ( ) , part . r ) if err ! = nil { return err } req . Content Length = part . len req . Header . Set ( md 5Header , part . md 5 ) req . Header . Set ( sha 2 5 6Header , part . sha 2 5 6 ) p . b . Sign ( req ) resp , err : = p . c . Client . Do ( req ) if err ! = nil { return err } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 0 { return new Resp Error ( resp ) } s : = resp . Header . Get ( " " ) if len ( s ) < 2 { return fmt . Errorf ( " " , s ) } s = s [ 1 : len ( s ) - 1 ] if part . ETag ! = s { return fmt . Errorf ( " " , s , p . ETag ) } return nil } 
func ( p * putter ) abort ( ) { v : = url . Values { } v . Set ( " " , p . Upload ID ) s : = p . url . String ( ) + " " + v . Encode ( ) resp , err : = p . retry Request ( " " , s , nil , nil ) if err ! = nil { logger . Printf ( " \n " , err ) return } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 4 { logger . Printf ( " " , new Resp Error ( resp ) ) } return } 
func ( p * putter ) hash Content ( r io . Read Seeker ) ( string , string , string , error ) { m : = md 5 . New ( ) s : = sha 2 5 6 . New ( ) mw : = io . Multi Writer ( m , s , p . md 5 ) if _ , err : = io . Copy ( mw , r ) ; err ! = nil { return " " , " " , " " , err } md 5Sum : = m . Sum ( nil ) sha Sum : = hex . Encode To String ( s . Sum ( nil ) ) etag : = hex . Encode To String ( md 5Sum ) } return base 6 4 . Std Encoding . Encode To String ( md 5Sum ) , sha Sum , etag , nil } 
func ( p * putter ) put Md 5 ( ) ( err error ) { calc Md 5 : = fmt . Sprintf ( " " , p . md 5 . Sum ( nil ) ) md 5Reader : = strings . New Reader ( calc Md 5 ) md 5Path : = fmt . Sprint ( " " , p . url . Path , " " ) md 5Url , err : = p . b . url ( md 5Path , p . c ) if err ! = nil { return err } logger . debug Println ( " " , calc Md 5 ) logger . debug Println ( " " , md 5Path ) r , err : = http . New Request ( " " , md 5Url . String ( ) , md 5Reader ) if err ! = nil { return } p . b . Sign ( r ) resp , err : = p . c . Client . Do ( r ) if err ! = nil { return } defer check Close ( resp . Body , err ) if resp . Status Code ! = 2 0 0 { return new Resp Error ( resp ) } return } 
func grow Part Size ( part Index int , part Size , putsz int 6 4 ) bool { return ( max Obj Size - putsz ) / ( max NPart - int 6 4 ( part Index ) ) > part Size } 
func gather Info ( prefix string , spec interface { } ) ( [ ] var Info , error ) { s : = reflect . Value Of ( spec ) if s . Kind ( ) ! = reflect . Ptr { return nil , Err Invalid Specification } s = s . Elem ( ) if s . Kind ( ) ! = reflect . Struct { return nil , Err Invalid Specification } type Of Spec : = s . Type ( ) for i : = 0 ; i < s . Num Field ( ) ; i + + { f : = s . Field ( i ) ftype : = type Of Spec . Field ( i ) if ! f . Can Set ( ) | | is True ( ftype . Tag . Get ( " " ) ) { continue } for f . Kind ( ) = = reflect . Ptr { if f . Is Nil ( ) { if f . Type ( ) . Elem ( ) . Kind ( ) ! = reflect . Struct { } } f = f . Elem ( ) } if len ( words ) > 0 { var name [ ] string for _ , words : = range words { name = append ( name , words [ 0 ] ) } info . Key = strings . Join ( name , " " ) } } if info . Alt ! = " " { info . Key = info . Alt } if prefix ! = " " { info . Key = fmt . Sprintf ( " " , prefix , info . Key ) } info . Key = strings . To Upper ( info . Key ) infos = append ( infos , info ) if f . Kind ( ) = = reflect . Struct { if ! ftype . Anonymous { inner Prefix = info . Key } embedded Ptr : = f . Addr ( ) . Interface ( ) embedded Infos , err : = gather Info ( inner Prefix , embedded Ptr ) if err ! = nil { return nil , err } infos = append ( infos [ : len ( infos ) - 1 ] , embedded Infos . . . ) continue } } } return infos , nil } 
func Check Disallowed ( prefix string , spec interface { } ) error { infos , err : = gather Info ( prefix , spec ) if err ! = nil { return err } vars : = make ( map [ string ] struct { } ) for _ , info : = range infos { vars [ info . Key ] = struct { } { } } if prefix ! = " " { prefix = strings . To Upper ( prefix ) + " " } for _ , env : = range os . Environ ( ) { if ! strings . Has Prefix ( env , prefix ) { continue } v : = strings . Split N ( env , " " , 2 ) [ 0 ] if _ , found : = vars [ v ] ; ! found { return fmt . Errorf ( " " , v ) } } return nil } 
func Process ( prefix string , spec interface { } ) error { infos , err : = gather Info ( prefix , spec ) for _ , info : = range infos { if ! ok & & info . Alt ! = " " { value , ok = lookup Env ( info . Alt ) } def : = info . Tags . Get ( " " ) if def ! = " " & & ! ok { value = def } req : = info . Tags . Get ( " " ) if ! ok & & def = = " " { if is True ( req ) { return fmt . Errorf ( " " , info . Key ) } continue } err = process Field ( value , info . Field ) if err ! = nil { return & Parse Error { Key Name : info . Key , Field Name : info . Name , Type Name : info . Field . Type ( ) . String ( ) , Value : value , Err : err , } } } return err } 
func Must Process ( prefix string , spec interface { } ) { if err : = Process ( prefix , spec ) ; err ! = nil { panic ( err ) } } 
func to Type Description ( t reflect . Type ) string { switch t . Kind ( ) { case reflect . Array , reflect . Slice : return fmt . Sprintf ( " " , to Type Description ( t . Elem ( ) ) ) case reflect . Map : return fmt . Sprintf ( " " , to Type Description ( t . Key ( ) ) , to Type Description ( t . Elem ( ) ) , ) case reflect . Ptr : return to Type Description ( t . Elem ( ) ) case reflect . Struct : if implements Interface ( t ) & & t . Name ( ) ! = " " { return t . Name ( ) } return " " case reflect . String : name : = t . Name ( ) if name ! = " " & & name ! = " " { return name } return " " case reflect . Bool : name : = t . Name ( ) if name ! = " " & & name ! = " " { return name } return " " case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : name : = t . Name ( ) if name ! = " " & & ! strings . Has Prefix ( name , " " ) { return name } return " " case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : name : = t . Name ( ) if name ! = " " & & ! strings . Has Prefix ( name , " " ) { return name } return " " case reflect . Float 3 2 , reflect . Float 6 4 : name : = t . Name ( ) if name ! = " " & & ! strings . Has Prefix ( name , " " ) { return name } return " " } return fmt . Sprintf ( " " , t ) } 
func Usage ( prefix string , spec interface { } ) error { err : = Usagef ( prefix , spec , tabs , Default Table Format ) tabs . Flush ( ) return err } 
func Usagef ( prefix string , spec interface { } , out io . Writer , format string ) error { if req ! = " " { req B , err : = strconv . Parse Bool ( req ) if err ! = nil { return " " , err } if req B { req = " " } } return req , nil } , } tmpl , err : = template . New ( " " ) . Funcs ( functions ) . Parse ( format ) if err ! = nil { return err } return Usaget ( prefix , spec , out , tmpl ) } 
func Usaget ( prefix string , spec interface { } , out io . Writer , tmpl * template . Template ) error { if err ! = nil { return err } return tmpl . Execute ( out , infos ) } 
func ( t * Time ) Scan ( value interface { } ) error { var err error switch x : = value . ( type ) { case time . Time : t . Time = x case nil : t . Valid = false return nil default : err = fmt . Errorf ( " " , value , value ) } t . Valid = err = = nil return err } 
func ( t Time ) Value ( ) ( driver . Value , error ) { if ! t . Valid { return nil , nil } return t . Time , nil } 
func New Time ( t time . Time , valid bool ) Time { return Time { Time : t , Valid : valid , } } 
func Time From Ptr ( t * time . Time ) Time { if t = = nil { return New Time ( time . Time { } , false ) } return New Time ( * t , true ) } 
func ( t Time ) Value Or Zero ( ) time . Time { if ! t . Valid { return time . Time { } } return t . Time } 
func ( t Time ) Marshal JSON ( ) ( [ ] byte , error ) { if ! t . Valid { return [ ] byte ( " " ) , nil } return t . Time . Marshal JSON ( ) } 
func ( t * Time ) Unmarshal JSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case string : err = t . Time . Unmarshal JSON ( data ) case map [ string ] interface { } : ti , ti OK : = x [ " " ] . ( string ) valid , valid OK : = x [ " " ] . ( bool ) if ! ti OK | | ! valid OK { return fmt . Errorf ( `json : unmarshalling object into Go value of type null .Time requires key "Time " to be of type string and key "Valid " to be of type bool ; found %T and %T , respectively ` , x [ " " ] , x [ " " ] ) } err = t . Time . Unmarshal Text ( [ ] byte ( ti ) ) t . Valid = valid return err case nil : t . Valid = false return nil default : err = fmt . Errorf ( " " , reflect . Type Of ( v ) . Name ( ) ) } t . Valid = err = = nil return err } 
func ( t * Time ) Set Valid ( v time . Time ) { t . Time = v t . Valid = true } 
func ( t Time ) Ptr ( ) * time . Time { if ! t . Valid { return nil } return & t . Time } 
func New Bool ( b bool , valid bool ) Bool { return Bool { Null Bool : sql . Null Bool { Bool : b , Valid : valid , } , } } 
func Bool From Ptr ( b * bool ) Bool { if b = = nil { return New Bool ( false , false ) } return New Bool ( * b , true ) } 
func ( b * Bool ) Unmarshal JSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case bool : b . Bool = x case map [ string ] interface { } : err = json . Unmarshal ( data , & b . Null Bool ) case nil : b . Valid = false return nil default : err = fmt . Errorf ( " " , reflect . Type Of ( v ) . Name ( ) ) } b . Valid = err = = nil return err } 
func ( b * Bool ) Unmarshal Text ( text [ ] byte ) error { str : = string ( text ) switch str { case " " , " " : b . Valid = false return nil case " " : b . Bool = true case " " : b . Bool = false default : b . Valid = false return errors . New ( " " + str ) } b . Valid = true return nil } 
func ( b Bool ) Marshal JSON ( ) ( [ ] byte , error ) { if ! b . Valid { return [ ] byte ( " " ) , nil } if ! b . Bool { return [ ] byte ( " " ) , nil } return [ ] byte ( " " ) , nil } 
func ( b * Bool ) Set Valid ( v bool ) { b . Bool = v b . Valid = true } 
func New String ( s string , valid bool ) String { return String { Null String : sql . Null String { String : s , Valid : valid , } , } } 
func ( s * String ) Unmarshal JSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case string : s . String = x case map [ string ] interface { } : err = json . Unmarshal ( data , & s . Null String ) case nil : s . Valid = false return nil default : err = fmt . Errorf ( " " , reflect . Type Of ( v ) . Name ( ) ) } s . Valid = ( err = = nil ) & & ( s . String ! = " " ) return err } 
func ( s String ) Marshal Text ( ) ( [ ] byte , error ) { if ! s . Valid { return [ ] byte { } , nil } return [ ] byte ( s . String ) , nil } 
func ( s * String ) Unmarshal Text ( text [ ] byte ) error { s . String = string ( text ) s . Valid = s . String ! = " " return nil } 
func ( s * String ) Set Valid ( v string ) { s . String = v s . Valid = true } 
func String From Ptr ( s * string ) String { if s = = nil { return New String ( " " , false ) } return New String ( * s , true ) } 
func ( s String ) Marshal JSON ( ) ( [ ] byte , error ) { if ! s . Valid { return [ ] byte ( " " ) , nil } return json . Marshal ( s . String ) } 
func New Int ( i int 6 4 , valid bool ) Int { return Int { Null Int 6 4 : sql . Null Int 6 4 { Int 6 4 : i , Valid : valid , } , } } 
func Int From Ptr ( i * int 6 4 ) Int { if i = = nil { return New Int ( 0 , false ) } n : = New Int ( * i , true ) return n } 
func ( i * Int ) Unmarshal JSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case float 6 4 : case string : str : = string ( x ) if len ( str ) = = 0 { i . Valid = false return nil } i . Int 6 4 , err = strconv . Parse Int ( str , 1 0 , 6 4 ) case map [ string ] interface { } : err = json . Unmarshal ( data , & i . Null Int 6 4 ) case nil : i . Valid = false return nil default : err = fmt . Errorf ( " " , reflect . Type Of ( v ) . Name ( ) ) } i . Valid = ( err = = nil ) & & ( i . Int 6 4 ! = 0 ) return err } 
func ( i Int ) Marshal Text ( ) ( [ ] byte , error ) { n : = i . Int 6 4 if ! i . Valid { n = 0 } return [ ] byte ( strconv . Format Int ( n , 1 0 ) ) , nil } 
func ( i * Int ) Set Valid ( n int 6 4 ) { i . Int 6 4 = n i . Valid = true } 
func ( i * Int ) Unmarshal Text ( text [ ] byte ) error { str : = string ( text ) if str = = " " | | str = = " " { i . Valid = false return nil } var err error i . Int 6 4 , err = strconv . Parse Int ( string ( text ) , 1 0 , 6 4 ) i . Valid = err = = nil return err } 
func ( b Bool ) Marshal Text ( ) ( [ ] byte , error ) { if ! b . Valid | | ! b . Bool { return [ ] byte ( " " ) , nil } return [ ] byte ( " " ) , nil } 
func ( f * Float ) Set Valid ( v float 6 4 ) { f . Float 6 4 = v f . Valid = true } 
func Time From Ptr ( t * time . Time ) Time { if t = = nil { return New Time ( time . Time { } , false ) } return Time From ( * t ) } 
func ( t Time ) Marshal JSON ( ) ( [ ] byte , error ) { if ! t . Valid { return ( time . Time { } ) . Marshal JSON ( ) } return t . Time . Marshal JSON ( ) } 
func ( f * Float ) Unmarshal JSON ( data [ ] byte ) error { var err error var v interface { } if err = json . Unmarshal ( data , & v ) ; err ! = nil { return err } switch x : = v . ( type ) { case float 6 4 : f . Float 6 4 = float 6 4 ( x ) case string : str : = string ( x ) if len ( str ) = = 0 { f . Valid = false return nil } f . Float 6 4 , err = strconv . Parse Float ( str , 6 4 ) case map [ string ] interface { } : err = json . Unmarshal ( data , & f . Null Float 6 4 ) case nil : f . Valid = false return nil default : err = fmt . Errorf ( " " , reflect . Type Of ( v ) . Name ( ) ) } f . Valid = err = = nil return err } 
func ( f * Float ) Unmarshal Text ( text [ ] byte ) error { str : = string ( text ) if str = = " " | | str = = " " { f . Valid = false return nil } var err error f . Float 6 4 , err = strconv . Parse Float ( string ( text ) , 6 4 ) f . Valid = err = = nil return err } 
func ( f Float ) Marshal JSON ( ) ( [ ] byte , error ) { if ! f . Valid { return [ ] byte ( " " ) , nil } if math . Is Inf ( f . Float 6 4 , 0 ) | | math . Is Na N ( f . Float 6 4 ) { return nil , & json . Unsupported Value Error { Value : reflect . Value Of ( f . Float 6 4 ) , Str : strconv . Format Float ( f . Float 6 4 , 'g ' , - 1 , 6 4 ) , } } return [ ] byte ( strconv . Format Float ( f . Float 6 4 , 'f ' , - 1 , 6 4 ) ) , nil } 
func new Gossip Channel ( channel Name string , ourself * local Peer , r * routes , g Gossiper , logger Logger ) * gossip Channel { return & gossip Channel { name : channel Name , ourself : ourself , routes : r , gossiper : g , logger : logger , } } 
func ( c * gossip Channel ) Gossip Unicast ( dst Peer Name Peer Name , msg [ ] byte ) error { return c . relay Unicast ( dst Peer Name , gob Encode ( c . name , c . ourself . Name , dst Peer Name , msg ) ) } 
func ( c * gossip Channel ) Gossip Broadcast ( update Gossip Data ) { c . relay Broadcast ( c . ourself . Name , update ) } 
func ( c * gossip Channel ) Send ( data Gossip Data ) { c . relay ( c . ourself . Name , data ) } 
func ( c * gossip Channel ) Send Down ( conn Connection , data Gossip Data ) { c . sender For ( conn ) . Send ( data ) } 
func gob Encode ( items . . . interface { } ) [ ] byte { buf : = new ( bytes . Buffer ) enc : = gob . New Encoder ( buf ) for _ , i : = range items { if err : = enc . Encode ( i ) ; err ! = nil { panic ( err ) } } return buf . Bytes ( ) } 
func new Token Bucket ( capacity int 6 4 , token Interval time . Duration ) * token Bucket { tb : = token Bucket { capacity : capacity , token Interval : token Interval , refill Duration : token Interval * time . Duration ( capacity ) } tb . earliest Unspent Token = tb . capacity Token ( ) return & tb } 
func ( tb * token Bucket ) wait ( ) { if tb . earliest Unspent Token . Before ( capacity Token ) { tb . earliest Unspent Token = capacity Token } } 
func ( tb * token Bucket ) capacity Token ( ) time . Time { return time . Now ( ) . Add ( - tb . refill Duration ) . Truncate ( tb . token Interval ) } 
func Prefix Range End ( prefix [ ] byte ) [ ] byte { copy ( end , prefix ) for i : = len ( end ) - 1 ; i > = 0 ; i - - { if end [ i ] < 0xff { end [ i ] = end [ i ] + 1 end = end [ : i + 1 ] return end } } } 
func new Local Peer ( name Peer Name , nick Name string , router * Router ) * local Peer { action Chan : = make ( chan local Peer Action , Channel Size ) peer : = & local Peer { Peer : new Peer ( name , nick Name , random Peer UID ( ) , 0 , random Peer Short ID ( ) ) , router : router , action Chan : action Chan , } go peer . actor Loop ( action Chan ) return peer } 
func ( peer * local Peer ) get Connections ( ) connection Set { connections : = make ( connection Set ) peer . RLock ( ) defer peer . RUnlock ( ) for _ , conn : = range peer . connections { connections [ conn ] = struct { } { } } return connections } 
func ( peer * local Peer ) Connection To ( name Peer Name ) ( Connection , bool ) { peer . RLock ( ) defer peer . RUnlock ( ) conn , found : = peer . connections [ name ] return conn , found } 
func ( peer * local Peer ) Connections To ( names [ ] Peer Name ) [ ] Connection { if len ( names ) = = 0 { return nil } conns : = make ( [ ] Connection , 0 , len ( names ) ) peer . RLock ( ) defer peer . RUnlock ( ) for _ , name : = range names { conn , found : = peer . connections [ name ] } } return conns } 
func ( peer * local Peer ) create Connection ( local Addr string , peer Addr string , accept New Peer bool , logger Logger ) error { if err : = peer . check Connection Limit ( ) ; err ! = nil { return err } local TCPAddr , err : = net . Resolve TCPAddr ( " " , local Addr ) if err ! = nil { return err } remote TCPAddr , err : = net . Resolve TCPAddr ( " " , peer Addr ) if err ! = nil { return err } tcp Conn , err : = net . Dial TCP ( " " , local TCPAddr , remote TCPAddr ) if err ! = nil { return err } conn Remote : = new Remote Connection ( peer . Peer , nil , peer Addr , true , false ) start Local Connection ( conn Remote , tcp Conn , peer . router , accept New Peer , logger ) return nil } 
func ( peer * local Peer ) do Add Connection ( conn our Connection , is Restarted Peer bool ) error { result Chan : = make ( chan error ) peer . action Chan < - func ( ) { result Chan < - peer . handle Add Connection ( conn , is Restarted Peer ) } return < - result Chan } 
func ( peer * local Peer ) do Connection Established ( conn our Connection ) { peer . action Chan < - func ( ) { peer . handle Connection Established ( conn ) } } 
func ( peer * local Peer ) do Delete Connection ( conn our Connection ) { result Chan : = make ( chan interface { } ) peer . action Chan < - func ( ) { peer . handle Delete Connection ( conn ) result Chan < - nil } < - result Chan } 
func ( peer * local Peer ) actor Loop ( action Chan < - chan local Peer Action ) { gossip Timer : = time . Tick ( gossip Interval ) for { select { case action : = < - action Chan : action ( ) case < - gossip Timer : peer . router . send All Gossip ( ) } } } 
func ( peer * local Peer ) broadcast Peer Update ( peers . . . * Peer ) { } } 
func start Local Connection ( conn Remote * remote Connection , tcp Conn * net . TCPConn , router * Router , accept New Peer bool , logger Logger ) { if conn Remote . local ! = router . Ourself . Peer { panic ( " " ) } error Chan : = make ( chan error , 1 ) finished : = make ( chan struct { } ) conn : = & Local Connection { remote Connection : * conn Remote , conn . senders = new Gossip Senders ( conn , finished ) go conn . run ( error Chan , finished , accept New Peer ) } 
func ( conn * Local Connection ) Send Protocol Msg ( m protocol Msg ) error { if err : = conn . send Protocol Msg ( m ) ; err ! = nil { conn . shutdown ( err ) return err } return nil } 
func ( conn * Local Connection ) shutdown ( err error ) { } select { case conn . error Chan < - err : default : } } 
func ( conn * Local Connection ) run ( error Chan < - chan error , finished chan < - struct { } , accept New Peer bool ) { var err error defer func ( ) { conn . teardown ( err ) } ( ) defer close ( finished ) if err = conn . tcp Conn . Set Linger ( 0 ) ; err ! = nil { return } intro , err : = protocol Intro Params { Min Version : conn . router . Protocol Min Version , Max Version : Protocol Max Version , Features : conn . make Features ( ) , Conn : conn . tcp Conn , Password : conn . router . Password , Outbound : conn . outbound , } . do Intro ( ) if err ! = nil { return } conn . session Key = intro . Session Key conn . tcp Sender = intro . Sender conn . version = intro . Version remote , err : = conn . parse Features ( intro . Features ) if err ! = nil { return } if err = conn . register Remote ( remote , accept New Peer ) ; err ! = nil { return } is Restarted Peer : = conn . Remote ( ) . UID ! = remote . UID conn . logf ( " " , conn . version ) if conn . untrusted ( ) { session Key = conn . session Key } params : = Overlay Connection Params { Remote Peer : conn . remote , Local Addr : conn . tcp Conn . Local Addr ( ) . ( * net . TCPAddr ) , Remote Addr : conn . tcp Conn . Remote Addr ( ) . ( * net . TCPAddr ) , Outbound : conn . outbound , Conn UID : conn . uid , Session Key : session Key , Send Control Message : conn . send Overlay Control Message , Features : intro . Features , } if conn . Overlay Conn , err = conn . router . Overlay . Prepare Connection ( params ) ; err ! = nil { return } } conn . router . Connection Maker . connection Created ( conn ) go conn . receive TCP ( intro . Receiver ) } 
func ( conn * Local Connection ) send Simple Protocol Msg ( tag protocol Tag ) error { return conn . send Protocol Msg ( protocol Msg { tag : tag } ) } 
func New Status ( router * Router ) * Status { return & Status { Protocol : Protocol , Protocol Min Version : int ( router . Protocol Min Version ) , Protocol Max Version : Protocol Max Version , Encryption : router . using Password ( ) , Peer Discovery : router . Peer Discovery , Name : router . Ourself . Name . String ( ) , Nick Name : router . Ourself . Nick Name , Port : router . Port , Peers : make Peer Status Slice ( router . Peers ) , Unicast Routes : make Unicast Route Status Slice ( router . Routes ) , Broadcast Routes : make Broadcast Route Status Slice ( router . Routes ) , Connections : make Local Connection Status Slice ( router . Connection Maker ) , Termination Count : router . Connection Maker . termination Count , Targets : router . Connection Maker . Targets ( false ) , Overlay Diagnostics : router . Overlay . Diagnostics ( ) , Trusted Subnets : make Trusted Subnets Slice ( router . Trusted Subnets ) , } } 
func make Peer Status Slice ( peers * Peers ) [ ] Peer Status { var slice [ ] Peer Status peers . for Each ( func ( peer * Peer ) { var connections [ ] connection Status if peer = = peers . ourself . Peer { for conn : = range peers . ourself . get Connections ( ) { connections = append ( connections , make Connection Status ( conn ) ) } } else { } } slice = append ( slice , Peer Status { peer . Name . String ( ) , peer . Nick Name , peer . UID , peer . Short ID , peer . Version , connections , } ) } ) return slice } 
func make Unicast Route Status Slice ( r * routes ) [ ] unicast Route Status { r . RLock ( ) defer r . RUnlock ( ) var slice [ ] unicast Route Status for dest , via : = range r . unicast { slice = append ( slice , unicast Route Status { dest . String ( ) , via . String ( ) } ) } return slice } 
func make Broadcast Route Status Slice ( r * routes ) [ ] broadcast Route Status { r . RLock ( ) defer r . RUnlock ( ) var slice [ ] broadcast Route Status for source , via : = range r . broadcast { var hops [ ] string for _ , hop : = range via { hops = append ( hops , hop . String ( ) ) } slice = append ( slice , broadcast Route Status { source . String ( ) , hops } ) } return slice } 
func make Local Connection Status Slice ( cm * connection Maker ) [ ] Local Connection Status { result Chan : = make ( chan [ ] Local Connection Status ) cm . action Chan < - func ( ) bool { var slice [ ] Local Connection Status for conn : = range cm . connections { state : = " " if conn . is Established ( ) { state = " " } lc , _ : = conn . ( * Local Connection ) attrs : = lc . Overlay Conn . Attrs ( ) name , ok : = attrs [ " " ] if ! ok { name = " " } info : = fmt . Sprintf ( " " , name , conn . Remote ( ) ) if lc . router . using Password ( ) { if lc . untrusted ( ) { info = fmt . Sprintf ( " " , " " , info ) if attrs ! = nil { attrs [ " " ] = true } } else { info = fmt . Sprintf ( " " , " " , info ) } } slice = append ( slice , Local Connection Status { conn . remote TCPAddress ( ) , conn . is Outbound ( ) , state , info , attrs } ) } for address , target : = range cm . targets { add : = func ( state , info string ) { slice = append ( slice , Local Connection Status { address , true , state , info , nil } ) } switch target . state { case target Waiting : until : = " " if ! target . try After . Is Zero ( ) { until = target . try After . String ( ) } if target . last Error = = nil { } else { add ( " " , target . last Error . Error ( ) + " " + until ) } case target Attempting : if target . last Error = = nil { add ( " " , " " ) } else { add ( " " , target . last Error . Error ( ) ) } case target Connected : case target Suspended : } } result Chan < - slice return false } return < - result Chan } 
func make Trusted Subnets Slice ( trusted Subnets [ ] * net . IPNet ) [ ] string { trusted Subnet Strs : = [ ] string { } for _ , trusted Subnet : = range trusted Subnets { trusted Subnet Strs = append ( trusted Subnet Strs , trusted Subnet . String ( ) ) } return trusted Subnet Strs } 
func ( s * etcd Store ) Range ( ctx context . Context , req * etcdserverpb . Range Request ) ( * etcdserverpb . Range Response , error ) { ireq : = etcdserverpb . Internal Raft Request { ID : < - s . idgen , Range : req } msgc , errc , err : = s . propose Internal Raft Request ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . Done ( ) : s . cancel Internal Raft Request ( ireq ) return nil , ctx . Err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . Range Response ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , err Stopped } } 
func ( s * etcd Store ) Put ( ctx context . Context , req * etcdserverpb . Put Request ) ( * etcdserverpb . Put Response , error ) { ireq : = etcdserverpb . Internal Raft Request { ID : < - s . idgen , Put : req } msgc , errc , err : = s . propose Internal Raft Request ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . Done ( ) : s . cancel Internal Raft Request ( ireq ) return nil , ctx . Err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . Put Response ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , err Stopped } } 
func ( s * etcd Store ) Delete Range ( ctx context . Context , req * etcdserverpb . Delete Range Request ) ( * etcdserverpb . Delete Range Response , error ) { ireq : = etcdserverpb . Internal Raft Request { ID : < - s . idgen , Delete Range : req } msgc , errc , err : = s . propose Internal Raft Request ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . Done ( ) : s . cancel Internal Raft Request ( ireq ) return nil , ctx . Err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . Delete Range Response ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , err Stopped } } 
func ( s * etcd Store ) Txn ( ctx context . Context , req * etcdserverpb . Txn Request ) ( * etcdserverpb . Txn Response , error ) { ireq : = etcdserverpb . Internal Raft Request { ID : < - s . idgen , Txn : req } msgc , errc , err : = s . propose Internal Raft Request ( ireq ) if err ! = nil { return nil , err } select { case < - ctx . Done ( ) : s . cancel Internal Raft Request ( ireq ) return nil , ctx . Err ( ) case msg : = < - msgc : return msg . ( * etcdserverpb . Txn Response ) , nil case err : = < - errc : return nil , err case < - s . quitc : return nil , err Stopped } } 
func ( s * etcd Store ) Compact ( ctx context . Context , req * etcdserverpb . Compaction Request ) ( * etcdserverpb . Compaction Response , error ) { } 
func ( s * etcd Store ) propose Internal Raft Request ( req etcdserverpb . Internal Raft Request ) ( < - chan proto . Message , < - chan error , error ) { data , err : = req . Marshal ( ) if err ! = nil { return nil , nil , err } if len ( data ) > max Request Bytes { return nil , nil , err Too Big } msgc , errc , err : = s . register Pending ( req . ID ) if err ! = nil { return nil , nil , err } s . proposalc < - data return msgc , errc , nil } 
func ( s * etcd Store ) apply Internal Raft Request ( req etcdserverpb . Internal Raft Request ) ( proto . Message , error ) { switch { case req . Range ! = nil : return apply Range ( no Txn , s . kv , req . Range ) case req . Put ! = nil : return apply Put ( no Txn , s . kv , s . lessor , req . Put ) case req . Delete Range ! = nil : return apply Delete Range ( no Txn , s . kv , req . Delete Range ) case req . Txn ! = nil : return apply Transaction ( s . kv , s . lessor , req . Txn ) case req . Compaction ! = nil : return apply Compaction ( s . kv , req . Compaction ) case req . Lease Grant ! = nil : return apply Lease Grant ( s . lessor , req . Lease Grant ) case req . Lease Revoke ! = nil : return apply Lease Revoke ( s . lessor , req . Lease Revoke ) default : return nil , fmt . Errorf ( " " ) } } 
func apply Compare ( kv mvcc . KV , c * etcdserverpb . Compare ) ( int 6 4 , bool ) { ckvs , rev , err : = kv . Range ( c . Key , nil , 1 , 0 ) if err ! = nil { if err = = mvcc . Err Txn IDMismatch { panic ( " " ) } return rev , false } var ckv mvccpb . Key Value if len ( ckvs ) ! = 0 { ckv = ckvs [ 0 ] } else { } } switch c . Target { case etcdserverpb . Compare _VALUE : tv , _ : = c . Target Union . ( * etcdserverpb . Compare _Value ) if tv ! = nil { result = bytes . Compare ( ckv . Value , tv . Value ) } case etcdserverpb . Compare _CREATE : tv , _ : = c . Target Union . ( * etcdserverpb . Compare _Create Revision ) if tv ! = nil { result = compare Int 6 4 ( ckv . Create Revision , tv . Create Revision ) } case etcdserverpb . Compare _MOD : tv , _ : = c . Target Union . ( * etcdserverpb . Compare _Mod Revision ) if tv ! = nil { result = compare Int 6 4 ( ckv . Mod Revision , tv . Mod Revision ) } case etcdserverpb . Compare _VERSION : tv , _ : = c . Target Union . ( * etcdserverpb . Compare _Version ) if tv ! = nil { result = compare Int 6 4 ( ckv . Version , tv . Version ) } } switch c . Result { case etcdserverpb . Compare _EQUAL : if result ! = 0 { return rev , false } case etcdserverpb . Compare _GREATER : if result ! = 1 { return rev , false } case etcdserverpb . Compare _LESS : if result ! = - 1 { return rev , false } } return rev , true } 
func ( peers * Peers ) Descriptions ( ) [ ] Peer Description { peers . RLock ( ) defer peers . RUnlock ( ) descriptions : = make ( [ ] Peer Description , 0 , len ( peers . by Name ) ) for _ , peer : = range peers . by Name { descriptions = append ( descriptions , Peer Description { Name : peer . Name , Nick Name : peer . peer Summary . Nick Name , UID : peer . UID , Self : peer . Name = = peers . ourself . Name , Num Connections : len ( peer . connections ) , } ) } return descriptions } 
func ( peers * Peers ) On GC ( callback func ( * Peer ) ) { peers . Lock ( ) defer peers . Unlock ( ) } 
func ( peers * Peers ) On Invalidate Short IDs ( callback func ( ) ) { peers . Lock ( ) defer peers . Unlock ( ) } 
func ( peers * Peers ) choose Short ID ( ) ( Peer Short ID , bool ) { rng : = rand . New ( rand . New Source ( int 6 4 ( rand Uint 6 4 ( ) ) ) ) if peers . by Short ID [ short ID ] . peer = = nil { return short ID , true } } for _ , entry : = range peers . by Short ID { if entry . peer ! = nil { available - - } } if available = = 0 { } n : = rng . Intn ( available ) var i Peer Short ID for { if peers . by Short ID [ i ] . peer = = nil { if n = = 0 { return i , true } n - - } i + + } } 
func ( peers * Peers ) fetch With Default ( peer * Peer ) * Peer { peers . Lock ( ) var pending peers Pending Notifications defer peers . unlock And Notify ( & pending ) if existing Peer , found : = peers . by Name [ peer . Name ] ; found { existing Peer . local Ref Count + + return existing Peer } peers . by Name [ peer . Name ] = peer peers . add By Short ID ( peer , & pending ) peer . local Ref Count + + return peer } 
func ( peers * Peers ) Fetch ( name Peer Name ) * Peer { peers . RLock ( ) defer peers . RUnlock ( ) return peers . by Name [ name ] } 
func ( peers * Peers ) fetch And Add Ref ( name Peer Name ) * Peer { peers . Lock ( ) defer peers . Unlock ( ) peer : = peers . by Name [ name ] if peer ! = nil { peer . local Ref Count + + } return peer } 
func ( peers * Peers ) Fetch By Short ID ( short ID Peer Short ID ) * Peer { peers . RLock ( ) defer peers . RUnlock ( ) return peers . by Short ID [ short ID ] . peer } 
func ( peers * Peers ) dereference ( peer * Peer ) { peers . Lock ( ) defer peers . Unlock ( ) peer . local Ref Count - - } 
func ( peers * Peers ) apply Update ( update [ ] byte ) ( peer Name Set , peer Name Set , error ) { peers . Lock ( ) var pending peers Pending Notifications defer peers . unlock And Notify ( & pending ) new Peers , decoded Update , decoded Conns , err : = peers . decode Update ( update ) if err ! = nil { return nil , nil , err } peers . add By Short ID ( new Peer , & pending ) } peers . garbage Collect ( & pending ) for _ , peer Removed : = range pending . removed { delete ( new Update , peer Removed . Name ) } update Names : = make ( peer Name Set ) for _ , peer : = range decoded Update { update Names [ peer . Name ] = struct { } { } } return update Names , new Update , nil } 
func ( peers * Peers ) Garbage Collect ( ) { peers . Lock ( ) var pending peers Pending Notifications defer peers . unlock And Notify ( & pending ) peers . garbage Collect ( & pending ) } 
func new Routes ( ourself * local Peer , peers * Peers ) * routes { recalculate : = make ( chan * struct { } , 1 ) wait : = make ( chan chan struct { } ) action : = make ( chan func ( ) ) r : = & routes { ourself : ourself , peers : peers , unicast : unicast Routes { ourself . Name : Unknown Peer Name } , unicast All : unicast Routes { ourself . Name : Unknown Peer Name } , broadcast : broadcast Routes { ourself . Name : [ ] Peer Name { } } , broadcast All : broadcast Routes { ourself . Name : [ ] Peer Name { } } , recalc : recalculate , wait : wait , action : action , } go r . run ( recalculate , wait , action ) return r } 
func ( r * routes ) On Change ( callback func ( ) ) { r . Lock ( ) defer r . Unlock ( ) r . on Change = append ( r . on Change , callback ) } 
func ( r * routes ) Unicast ( name Peer Name ) ( Peer Name , bool ) { r . RLock ( ) defer r . RUnlock ( ) hop , found : = r . unicast [ name ] return hop , found } 
func ( r * routes ) Unicast All ( name Peer Name ) ( Peer Name , bool ) { r . RLock ( ) defer r . RUnlock ( ) hop , found : = r . unicast All [ name ] return hop , found } 
func ( r * routes ) Broadcast ( name Peer Name ) [ ] Peer Name { return r . lookup Or Calculate ( name , & r . broadcast , true ) } 
func ( r * routes ) Broadcast All ( name Peer Name ) [ ] Peer Name { return r . lookup Or Calculate ( name , & r . broadcast All , false ) } 
func ( r * routes ) random Neighbours ( except Peer Name ) [ ] Peer Name { destinations : = make ( peer Name Set ) r . RLock ( ) defer r . RUnlock ( ) count : = int ( math . Log 2 ( float 6 4 ( len ( r . unicast All ) ) ) ) if len ( destinations ) > = count { break } } } res : = make ( [ ] Peer Name , 0 , len ( destinations ) ) for dst : = range destinations { res = append ( res , dst ) } return res } 
func ( r * routes ) calculate Unicast ( established And Symmetric bool ) unicast Routes { _ , unicast : = r . ourself . routes ( nil , established And Symmetric ) return unicast } 
func ( r * routes ) calculate Broadcast ( name Peer Name , established And Symmetric bool ) [ ] Peer Name { hops : = [ ] Peer Name { } peer , found : = r . peers . by Name [ name ] if ! found { return hops } if found , reached : = peer . routes ( r . ourself . Peer , established And Symmetric ) ; found { r . ourself . for Each Connected Peer ( established And Symmetric , reached , func ( remote Peer * Peer ) { hops = append ( hops , remote Peer . Name ) } ) } return hops } 
func New Peer ( name mesh . Peer Name , uid mesh . Peer UID , logger mesh . Logger ) * Peer { p : = & Peer { name : name , uid : uid , gossip : nil , go p . loop ( ) return p } 
func ( p * Peer ) Register ( gossip mesh . Gossip ) { p . actions < - func ( ) { p . gossip = gossip } } 
func ( p * Peer ) Read From ( b [ ] byte ) ( n int , remote net . Addr , err error ) { c : = make ( chan struct { } ) p . actions < - func ( ) { go func ( ) { select { case pkt : = < - p . recv : n = copy ( b , pkt . Buf ) remote = Mesh Addr { Peer Name : pkt . Src Name , Peer UID : pkt . Src UID } if n < len ( pkt . Buf ) { err = Err Short Read } case < - p . quit : err = Err Peer Closed } } ( ) } < - c return n , remote , err } 
func ( p * Peer ) Write To ( b [ ] byte , dst net . Addr ) ( n int , err error ) { c : = make ( chan struct { } ) p . actions < - func ( ) { defer close ( c ) if p . gossip = = nil { err = Err Gossip Not Registered return } mesh Addr , ok : = dst . ( Mesh Addr ) if ! ok { err = Err Not Mesh Addr return } pkt : = pkt { Src Name : p . name , Src UID : p . uid , Buf : b } if mesh Addr . Peer Name = = p . name { p . recv < - pkt return } n = len ( buf ) err = p . gossip . Gossip Unicast ( mesh Addr . Peer Name , buf ) } < - c return n , err } 
func ( p * Peer ) Local Addr ( ) net . Addr { return Mesh Addr { Peer Name : p . name , Peer UID : p . uid } } 
func ( p * Peer ) On Gossip ( buf [ ] byte ) ( delta mesh . Gossip Data , err error ) { return pkt Slice { make Pkt ( buf ) } , nil } 
func ( p * Peer ) On Gossip Broadcast ( _ mesh . Peer Name , buf [ ] byte ) ( received mesh . Gossip Data , err error ) { pkt : = make Pkt ( buf ) p . recv < - pkt return pkt Slice { pkt } , nil } 
func ( p * Peer ) On Gossip Unicast ( _ mesh . Peer Name , buf [ ] byte ) error { pkt : = make Pkt ( buf ) p . recv < - pkt return nil } 
func GRPCServer ( s Server , options . . . grpc . Server Option ) * grpc . Server { srv : = grpc . New Server ( options . . . ) } 
func New Server ( router * mesh . Router , peer * meshconn . Peer , min Peer Count int , terminatec < - chan struct { } , terminatedc chan < - error , logger mesh . Logger , ) Server { c : = make ( chan Server ) go server Manager ( router , peer , min Peer Count , terminatec , terminatedc , logger , c ) return < - c } 
func New Default Server ( min Peer Count int , terminatec < - chan struct { } , terminatedc chan < - error , logger mesh . Logger , ) Server { var ( peer Name = must Peer Name ( ) nick Name = must Hostname ( ) host = " " port = 6 3 7 9 password = " " channel = " " ) router : = mesh . New Router ( mesh . Config { Host : host , Port : port , Protocol Min Version : mesh . Protocol Min Version , Password : [ ] byte ( password ) , Conn Limit : 6 4 , Peer Discovery : true , Trusted Subnets : [ ] * net . IPNet { } , } , peer Name , nick Name , mesh . Null Overlay { } , logger ) gossip : = router . New Gossip ( channel , peer ) peer . Register ( gossip ) return New Server ( router , peer , min Peer Count , terminatec , terminatedc , logger ) } 
func Peer Name From User Input ( user Input string ) ( Peer Name , error ) { return Peer Name From Bin ( name Byte Ary [ : Name Size ] ) , nil } 
func Peer Name From String ( name Str string ) ( Peer Name , error ) { if _ , err : = hex . Decode String ( name Str ) ; err ! = nil { return Unknown Peer Name , err } return Peer Name ( name Str ) , nil } 
func ( name Peer Name ) bytes ( ) [ ] byte { res , err : = hex . Decode String ( string ( name ) ) if err ! = nil { panic ( " " + name ) } return res } 
func Peer Name From String ( name Str string ) ( Peer Name , error ) { var a , b , c , d , e , f uint 6 4 match : = func ( format string , args . . . interface { } ) bool { a , b , c , d , e , f = 0 , 0 , 0 , 0 , 0 , 0 n , err : = fmt . Sscanf ( name Str + " \ 0 0 0 " , format + " \ 0 0 0 " , args . . . ) return err = = nil & & n = = len ( args ) } switch { case match ( " " , & a , & b , & c , & d , & e , & f ) : case match ( " " , & c , & d , & e , & f ) : case match ( " " , & a , & d , & e , & f ) : case match ( " " , & a , & b , & e , & f ) : case match ( " " , & a , & b , & c , & f ) : case match ( " " , & a , & b , & c , & d ) : case match ( " " , & d , & e , & f ) : case match ( " " , & a , & e , & f ) : case match ( " " , & a , & b , & f ) : case match ( " " , & a , & b , & c ) : case match ( " " , & e , & f ) : case match ( " " , & a , & f ) : case match ( " " , & a , & b ) : case match ( " " , & f ) : case match ( " " , & a ) : default : return Unknown Peer Name , fmt . Errorf ( " " , name Str ) } return Peer Name ( a < < 4 0 | b < < 3 2 | c < < 2 4 | d < < 1 6 | e < < 8 | f ) , nil } 
func New Router ( config Config , name Peer Name , nick Name string , overlay Overlay , logger Logger ) ( * Router , error ) { router : = & Router { Config : config , gossip Channels : make ( gossip Channels ) } if overlay = = nil { overlay = Null Overlay { } } router . Overlay = overlay router . Ourself = new Local Peer ( name , nick Name , router ) router . Peers = new Peers ( router . Ourself ) router . Peers . On GC ( func ( peer * Peer ) { logger . Printf ( " " , peer ) } ) router . Routes = new Routes ( router . Ourself , router . Peers ) router . Connection Maker = new Connection Maker ( router . Ourself , router . Peers , net . Join Host Port ( router . Host , " " ) , router . Port , router . Peer Discovery , logger ) router . logger = logger gossip , err : = router . New Gossip ( " " , router ) if err ! = nil { return nil , err } router . topology Gossip = gossip router . accept Limiter = new Token Bucket ( accept Max Tokens , accept Token Delay ) return router , nil } 
func ( router * Router ) New Gossip ( channel Name string , g Gossiper ) ( Gossip , error ) { channel : = new Gossip Channel ( channel Name , router . Ourself , router . Routes , g , router . logger ) router . gossip Lock . Lock ( ) defer router . gossip Lock . Unlock ( ) if _ , found : = router . gossip Channels [ channel Name ] ; found { return nil , fmt . Errorf ( " " , channel Name ) } router . gossip Channels [ channel Name ] = channel return channel , nil } 
func ( router * Router ) send All Gossip ( ) { for channel : = range router . gossip Channel Set ( ) { if gossip : = channel . gossiper . Gossip ( ) ; gossip ! = nil { channel . Send ( gossip ) } } } 
func ( router * Router ) send All Gossip Down ( conn Connection ) { for channel : = range router . gossip Channel Set ( ) { if gossip : = channel . gossiper . Gossip ( ) ; gossip ! = nil { channel . Send Down ( conn , gossip ) } } } 
func ( router * Router ) send Pending Gossip ( ) bool { sent Something : = false for conn : = range router . Ourself . get Connections ( ) { sent Something = conn . ( gossip Connection ) . gossip Senders ( ) . Flush ( ) | | sent Something } return sent Something } 
func ( router * Router ) broadcast Topology Update ( update [ ] * Peer ) { names : = make ( peer Name Set ) for _ , p : = range update { names [ p . Name ] = struct { } { } } router . topology Gossip . Gossip Broadcast ( & topology Gossip Data { peers : router . Peers , update : names } ) } 
func ( router * Router ) On Gossip Unicast ( sender Peer Name , msg [ ] byte ) error { return fmt . Errorf ( " " , msg ) } 
func ( router * Router ) On Gossip Broadcast ( _ Peer Name , update [ ] byte ) ( Gossip Data , error ) { orig Update , _ , err : = router . apply Topology Update ( update ) if err ! = nil | | len ( orig Update ) = = 0 { return nil , err } return & topology Gossip Data { peers : router . Peers , update : orig Update } , nil } 
func ( router * Router ) Gossip ( ) Gossip Data { return & topology Gossip Data { peers : router . Peers , update : router . Peers . names ( ) } } 
func ( router * Router ) On Gossip ( update [ ] byte ) ( Gossip Data , error ) { _ , new Update , err : = router . apply Topology Update ( update ) if err ! = nil | | len ( new Update ) = = 0 { return nil , err } return & topology Gossip Data { peers : router . Peers , update : new Update } , nil } 
func ( d * topology Gossip Data ) Merge ( other Gossip Data ) Gossip Data { names : = make ( peer Name Set ) for name : = range d . update { names [ name ] = struct { } { } } for name : = range other . ( * topology Gossip Data ) . update { names [ name ] = struct { } { } } return & topology Gossip Data { peers : d . peers , update : names } } 
func ( d * topology Gossip Data ) Encode ( ) [ ] [ ] byte { return [ ] [ ] byte { d . peers . encode Peers ( d . update ) } } 
func new State ( self mesh . Peer Name ) * state { return & state { set : map [ mesh . Peer Name ] int { } , self : self , } } 
func ( st * state ) Encode ( ) [ ] [ ] byte { st . mtx . RLock ( ) defer st . mtx . RUnlock ( ) var buf bytes . Buffer if err : = gob . New Encoder ( & buf ) . Encode ( st . set ) ; err ! = nil { panic ( err ) } return [ ] [ ] byte { buf . Bytes ( ) } } 
func ( st * state ) Merge ( other mesh . Gossip Data ) ( complete mesh . Gossip Data ) { return st . merge Complete ( other . ( * state ) . copy ( ) . set ) } 
func ( st * state ) merge Received ( set map [ mesh . Peer Name ] int ) ( received mesh . Gossip Data ) { st . mtx . Lock ( ) defer st . mtx . Unlock ( ) for peer , v : = range set { if v < = st . set [ peer ] { delete ( set , peer ) continue } st . set [ peer ] = v } return & state { set : set , } 
func ( st * state ) merge Delta ( set map [ mesh . Peer Name ] int ) ( delta mesh . Gossip Data ) { st . mtx . Lock ( ) defer st . mtx . Unlock ( ) for peer , v : = range set { if v < = st . set [ peer ] { delete ( set , peer ) continue } st . set [ peer ] = v } if len ( set ) < = 0 { return nil } return & state { set : set , } 
func ( st * state ) merge Complete ( set map [ mesh . Peer Name ] int ) ( complete mesh . Gossip Data ) { st . mtx . Lock ( ) defer st . mtx . Unlock ( ) for peer , v : = range set { if v > st . set [ peer ] { st . set [ peer ] = v } } return & state { set : st . set , } 
func ( * surrogate Gossiper ) On Gossip Broadcast ( _ Peer Name , update [ ] byte ) ( Gossip Data , error ) { return new Surrogate Gossip Data ( update ) , nil } 
func ( s * surrogate Gossiper ) On Gossip ( update [ ] byte ) ( Gossip Data , error ) { hash : = fnv . New 6 4a ( ) _ , _ = hash . Write ( update ) update Hash : = hash . Sum 6 4 ( ) s . Lock ( ) defer s . Unlock ( ) for _ , p : = range s . prev Updates { if update Hash = = p . hash & & bytes . Equal ( update , p . update ) { return nil , nil } } delete Before : = update Time . Add ( - gossip Interval ) keep From : = len ( s . prev Updates ) for i , p : = range s . prev Updates { if p . t . After ( delete Before ) { keep From = i break } } s . prev Updates = append ( s . prev Updates [ keep From : ] , prev Update { update , update Hash , update Time } ) return new Surrogate Gossip Data ( update ) , nil } 
func ( d * surrogate Gossip Data ) Merge ( other Gossip Data ) Gossip Data { o : = other . ( * surrogate Gossip Data ) messages : = make ( [ ] [ ] byte , 0 , len ( d . messages ) + len ( o . messages ) ) messages = append ( messages , d . messages . . . ) messages = append ( messages , o . messages . . . ) return & surrogate Gossip Data { messages : messages } } 
func generate Key Pair ( ) ( public Key , private Key * [ 3 2 ] byte , err error ) { return box . Generate Key ( rand . Reader ) } 
func form Session Key ( remote Public Key , local Private Key * [ 3 2 ] byte , secret Key [ ] byte ) * [ 3 2 ] byte { var shared Key [ 3 2 ] byte box . Precompute ( & shared Key , remote Public Key , local Private Key ) shared Key Slice : = shared Key [ : ] shared Key Slice = append ( shared Key Slice , secret Key . . . ) session Key : = sha 2 5 6 . Sum 2 5 6 ( shared Key Slice ) return & session Key } 
func new TCPCrypto State ( session Key * [ 3 2 ] byte , outbound bool ) * tcp Crypto State { s : = & tcp Crypto State { session Key : session Key } if outbound { s . nonce [ 0 ] | = ( 1 < < 7 ) } s . nonce [ 0 ] | = ( 1 < < 6 ) return s } 
func ( sender * gob TCPSender ) Send ( msg [ ] byte ) error { return sender . encoder . Encode ( msg ) } 
func ( sender * length Prefix TCPSender ) Send ( msg [ ] byte ) error { l : = len ( msg ) if l > max TCPMsg Size { return fmt . Errorf ( " " , l , max TCPMsg Size ) } binary . Big Endian . Put Uint 3 2 ( prefixed Msg , uint 3 2 ( l ) ) copy ( prefixed Msg [ 4 : ] , msg ) _ , err : = sender . writer . Write ( prefixed Msg ) return err } 
func ( sender * encrypted TCPSender ) Send ( msg [ ] byte ) error { sender . Lock ( ) defer sender . Unlock ( ) encoded Msg : = secretbox . Seal ( nil , msg , & sender . state . nonce , sender . state . session Key ) sender . state . advance ( ) return sender . sender . Send ( encoded Msg ) } 
func ( receiver * gob TCPReceiver ) Receive ( ) ( [ ] byte , error ) { var msg [ ] byte err : = receiver . decoder . Decode ( & msg ) return msg , err } 
func ( receiver * length Prefix TCPReceiver ) Receive ( ) ( [ ] byte , error ) { len Prefix : = make ( [ ] byte , 4 ) if _ , err : = io . Read Full ( receiver . reader , len Prefix ) ; err ! = nil { return nil , err } l : = binary . Big Endian . Uint 3 2 ( len Prefix ) if l > max TCPMsg Size { return nil , fmt . Errorf ( " " , l , max TCPMsg Size ) } msg : = make ( [ ] byte , l ) _ , err : = io . Read Full ( receiver . reader , msg ) return msg , err } 
func ( receiver * encrypted TCPReceiver ) Receive ( ) ( [ ] byte , error ) { msg , err : = receiver . receiver . Receive ( ) if err ! = nil { return nil , err } decoded Msg , success : = secretbox . Open ( nil , msg , & receiver . state . nonce , receiver . state . session Key ) if ! success { return nil , fmt . Errorf ( " " ) } receiver . state . advance ( ) return decoded Msg , nil } 
func new Peer ( self mesh . Peer Name , logger * log . Logger ) * peer { actions : = make ( chan func ( ) ) p : = & peer { st : new State ( self ) , send : nil , go p . loop ( actions ) return p } 
func ( p * peer ) incr ( ) ( result int ) { c : = make ( chan struct { } ) p . actions < - func ( ) { defer close ( c ) st : = p . st . incr ( ) if p . send ! = nil { p . send . Gossip Broadcast ( st ) } else { p . logger . Printf ( " " ) } result = st . get ( ) } < - c return result } 
func ( p * peer ) Gossip ( ) ( complete mesh . Gossip Data ) { complete = p . st . copy ( ) p . logger . Printf ( " " , complete . ( * state ) . set ) return complete } 
func ( p * peer ) On Gossip ( buf [ ] byte ) ( delta mesh . Gossip Data , err error ) { var set map [ mesh . Peer Name ] int if err : = gob . New Decoder ( bytes . New Reader ( buf ) ) . Decode ( & set ) ; err ! = nil { return nil , err } delta = p . st . merge Delta ( set ) if delta = = nil { p . logger . Printf ( " " , set , delta ) } else { p . logger . Printf ( " " , set , delta . ( * state ) . set ) } return delta , nil } 
func ( p * peer ) On Gossip Broadcast ( src mesh . Peer Name , buf [ ] byte ) ( received mesh . Gossip Data , err error ) { var set map [ mesh . Peer Name ] int if err : = gob . New Decoder ( bytes . New Reader ( buf ) ) . Decode ( & set ) ; err ! = nil { return nil , err } received = p . st . merge Received ( set ) if received = = nil { p . logger . Printf ( " " , src , set , received ) } else { p . logger . Printf ( " " , src , set , received . ( * state ) . set ) } return received , nil } 
func ( p * peer ) On Gossip Unicast ( src mesh . Peer Name , buf [ ] byte ) error { var set map [ mesh . Peer Name ] int if err : = gob . New Decoder ( bytes . New Reader ( buf ) ) . Decode ( & set ) ; err ! = nil { return err } complete : = p . st . merge Complete ( set ) p . logger . Printf ( " " , src , set , complete ) return nil } 
func make Raft Peer ( addr net . Addr ) raft . Peer { return raft . Peer { ID : uint 6 4 ( addr . ( meshconn . Mesh Addr ) . Peer UID ) , Context : nil , } 
func ( peer * Peer ) String ( ) string { return fmt . Sprint ( peer . Name , " " , peer . Nick Name , " " ) } 
func ( peer * Peer ) routes ( stop At * Peer , established And Symmetric bool ) ( bool , map [ Peer Name ] Peer Name ) { routes : = make ( unicast Routes ) routes [ peer . Name ] = Unknown Peer Name next Worklist : = [ ] * Peer { peer } for len ( next Worklist ) > 0 { worklist : = next Worklist sort . Sort ( list Of Peers ( worklist ) ) next Worklist = [ ] * Peer { } for _ , cur Peer : = range worklist { if cur Peer = = stop At { return true , routes } cur Peer . for Each Connected Peer ( established And Symmetric , routes , func ( remote Peer * Peer ) { next Worklist = append ( next Worklist , remote Peer ) remote Name : = remote Peer . Name } else { routes [ remote Name ] = routes [ cur Peer . Name ] } } ) } } return false , routes } 
func ( peer * Peer ) for Each Connected Peer ( established And Symmetric bool , exclude map [ Peer Name ] Peer Name , f func ( * Peer ) ) { for remote Name , conn : = range peer . connections { if established And Symmetric & & ! conn . is Established ( ) { continue } if _ , found : = exclude [ remote Name ] ; found { continue } remote Peer : = conn . Remote ( ) if remote Conn , found : = remote Peer . connections [ peer . Name ] ; ! established And Symmetric | | ( found & & remote Conn . is Established ( ) ) { f ( remote Peer ) } } } 
func parse Peer UID ( s string ) ( Peer UID , error ) { uid , err : = strconv . Parse Uint ( s , 1 0 , 6 4 ) return Peer UID ( uid ) , err } 
func ( lop list Of Peers ) Swap ( i , j int ) { lop [ i ] , lop [ j ] = lop [ j ] , lop [ i ] } 
func ( lop list Of Peers ) Less ( i , j int ) bool { return lop [ i ] . Name < lop [ j ] . Name } 
func ( params protocol Intro Params ) do Intro ( ) ( res protocol Intro Results , err error ) { if err = params . Conn . Set Deadline ( time . Now ( ) . Add ( header Timeout ) ) ; err ! = nil { return } if res . Version , err = params . exchange Protocol Header ( ) ; err ! = nil { return } var pub Key , priv Key * [ 3 2 ] byte if params . Password ! = nil { if pub Key , priv Key , err = generate Key Pair ( ) ; err ! = nil { return } } if err = params . Conn . Set Write Deadline ( time . Time { } ) ; err ! = nil { return } if err = params . Conn . Set Read Deadline ( time . Now ( ) . Add ( tcp Heartbeat * 2 ) ) ; err ! = nil { return } switch res . Version { case 1 : err = res . do Intro V 1 ( params , pub Key , priv Key ) case 2 : err = res . do Intro V 2 ( params , pub Key , priv Key ) default : panic ( " " ) } return } 
func ( res * protocol Intro Results ) do Intro V 1 ( params protocol Intro Params , pub Key , priv Key * [ 3 2 ] byte ) error { features : = filter V 1Features ( params . Features ) if pub Key ! = nil { features [ " " ] = hex . Encode To String ( pub Key [ : ] ) } enc : = gob . New Encoder ( params . Conn ) dec : = gob . New Decoder ( params . Conn ) go func ( ) { encode Done < - enc . Encode ( features ) } ( ) if err : = dec . Decode ( & res . Features ) ; err ! = nil { return err } if err : = < - encode Done ; err ! = nil { return err } res . Sender = new Gob TCPSender ( enc ) res . Receiver = new Gob TCPReceiver ( dec ) if pub Key = = nil { if _ , present : = res . Features [ " " ] ; present { return err Expected No Crypto } } else { remote Pub Key Str , ok : = res . Features [ " " ] if ! ok { return err Expected Crypto } remote Pub Key , err : = hex . Decode String ( remote Pub Key Str ) if err ! = nil { return err } res . setup Crypto ( params , remote Pub Key , priv Key ) } res . Features = filter V 1Features ( res . Features ) return nil } 
func filter V 1Features ( intro map [ string ] string ) map [ string ] string { safe : = make ( map [ string ] string ) for _ , k : = range protocol V 1Features { if val , ok : = intro [ k ] ; ok { safe [ k ] = val } } return safe } 
func ( res * protocol Intro Results ) do Intro V 2 ( params protocol Intro Params , pub Key , priv Key * [ 3 2 ] byte ) error { if pub Key = = nil { wbuf = [ ] byte { 0 } } else { wbuf = make ( [ ] byte , 1 + len ( * pub Key ) ) wbuf [ 0 ] = 1 copy ( wbuf [ 1 : ] , ( * pub Key ) [ : ] ) } go func ( ) { _ , err : = params . Conn . Write ( wbuf ) write Done < - err } ( ) rbuf : = make ( [ ] byte , 1 ) if _ , err : = io . Read Full ( params . Conn , rbuf ) ; err ! = nil { return err } switch rbuf [ 0 ] { case 0 : if pub Key ! = nil { return err Expected Crypto } res . Sender = new Length Prefix TCPSender ( params . Conn ) res . Receiver = new Length Prefix TCPReceiver ( params . Conn ) case 1 : if pub Key = = nil { return err Expected No Crypto } rbuf = make ( [ ] byte , len ( pub Key ) ) if _ , err : = io . Read Full ( params . Conn , rbuf ) ; err ! = nil { return err } res . Sender = new Length Prefix TCPSender ( params . Conn ) res . Receiver = new Length Prefix TCPReceiver ( params . Conn ) res . setup Crypto ( params , rbuf , priv Key ) default : return fmt . Errorf ( " " , rbuf [ 0 ] ) } if err : = < - write Done ; err ! = nil { return err } if err : = gob . New Encoder ( buf ) . Encode ( & params . Features ) ; err ! = nil { write Done < - err return } write Done < - res . Sender . Send ( buf . Bytes ( ) ) } ( ) rbuf , err : = res . Receiver . Receive ( ) if err ! = nil { return err } if err : = gob . New Decoder ( bytes . New Reader ( rbuf ) ) . Decode ( & res . Features ) ; err ! = nil { return err } if err : = < - write Done ; err ! = nil { return err } return nil } 
func new Connection Maker ( ourself * local Peer , peers * Peers , local Addr string , port int , discovery bool , logger Logger ) * connection Maker { action Chan : = make ( chan connection Maker Action , Channel Size ) cm : = & connection Maker { ourself : ourself , peers : peers , local Addr : local Addr , port : port , discovery : discovery , direct Peers : peer Addrs { } , targets : make ( map [ string ] * target ) , connections : make ( map [ Connection ] struct { } ) , action Chan : action Chan , logger : logger , } go cm . query Loop ( action Chan ) return cm } 
func ( cm * connection Maker ) Initiate Connections ( peers [ ] string , replace bool ) [ ] error { errors : = [ ] error { } addrs : = peer Addrs { } for _ , peer : = range peers { host , port , err : = net . Split Host Port ( peer ) if err ! = nil { host = peer port = " " } if host = = " " | | ! is Alnum ( port ) { errors = append ( errors , fmt . Errorf ( " " , peer ) ) } else if addr , err : = net . Resolve TCPAddr ( " " , fmt . Sprintf ( " " , host , port ) ) ; err ! = nil { errors = append ( errors , err ) } else { addrs [ peer ] = addr } } cm . action Chan < - func ( ) bool { if replace { cm . direct Peers = peer Addrs { } } for peer , addr : = range addrs { cm . direct Peers [ peer ] = addr } } return true } return errors } 
func ( cm * connection Maker ) Forget Connections ( peers [ ] string ) { cm . action Chan < - func ( ) bool { for _ , peer : = range peers { delete ( cm . direct Peers , peer ) } return true } } 
func ( cm * connection Maker ) Targets ( active Only bool ) [ ] string { result Chan : = make ( chan [ ] string ) cm . action Chan < - func ( ) bool { var slice [ ] string for peer , addr : = range cm . direct Peers { if active Only { if target , ok : = cm . targets [ cm . complete Addr ( * addr ) ] ; ok & & target . try After . Is Zero ( ) { continue } } slice = append ( slice , peer ) } result Chan < - slice return false } return < - result Chan } 
func ( cm * connection Maker ) connection Aborted ( address string , err error ) { cm . action Chan < - func ( ) bool { target : = cm . targets [ address ] target . state = target Waiting target . last Error = err target . next Try Later ( ) return true } } 
func ( cm * connection Maker ) connection Created ( conn Connection ) { cm . action Chan < - func ( ) bool { cm . connections [ conn ] = struct { } { } if conn . is Outbound ( ) { target : = cm . targets [ conn . remote TCPAddress ( ) ] target . state = target Connected } return false } } 
func ( cm * connection Maker ) connection Terminated ( conn Connection , err error ) { cm . action Chan < - func ( ) bool { if err ! = err Connect To Self { cm . termination Count + + } delete ( cm . connections , conn ) if conn . is Outbound ( ) { target : = cm . targets [ conn . remote TCPAddress ( ) ] target . state = target Waiting target . last Error = err _ , peer Name Collision : = err . ( * peer Name Collision Error ) switch { case peer Name Collision | | err = = err Connect To Self : target . next Try Never ( ) case time . Now ( ) . After ( target . try After . Add ( reset After ) ) : target . next Try Now ( ) default : target . next Try Later ( ) } } return true } } 
func ( t * target ) next Try Later ( ) { t . try After = time . Now ( ) . Add ( t . try Interval / 2 + time . Duration ( rand . Int 6 3n ( int 6 4 ( t . try Interval ) ) ) ) t . try Interval = t . try Interval * 3 / 2 if t . try Interval > max Interval { t . try Interval = max Interval } } 
func new Gossip Sender ( make Msg func ( msg [ ] byte ) protocol Msg , make Broadcast Msg func ( src Name Peer Name , msg [ ] byte ) protocol Msg , sender protocol Sender , stop < - chan struct { } , ) * gossip Sender { more : = make ( chan struct { } , 1 ) flush : = make ( chan chan < - bool ) s : = & gossip Sender { make Msg : make Msg , make Broadcast Msg : make Broadcast Msg , sender : sender , broadcasts : make ( map [ Peer Name ] Gossip Data ) , more : more , flush : flush , } go s . run ( stop , more , flush ) return s } 
func ( s * gossip Sender ) Send ( data Gossip Data ) { s . Lock ( ) defer s . Unlock ( ) if s . empty ( ) { defer s . prod ( ) } if s . gossip = = nil { s . gossip = data } else { s . gossip = s . gossip . Merge ( data ) } } 
func ( s * gossip Sender ) Broadcast ( src Name Peer Name , data Gossip Data ) { s . Lock ( ) defer s . Unlock ( ) if s . empty ( ) { defer s . prod ( ) } d , found : = s . broadcasts [ src Name ] if ! found { s . broadcasts [ src Name ] = data } else { s . broadcasts [ src Name ] = d . Merge ( data ) } } 
func ( s * gossip Sender ) Flush ( ) bool { ch : = make ( chan bool ) s . flush < - ch return < - ch } 
func new Gossip Senders ( sender protocol Sender , stop < - chan struct { } ) * gossip Senders { return & gossip Senders { sender : sender , stop : stop , senders : make ( map [ string ] * gossip Sender ) , } } 
func ( gs * gossip Senders ) Sender ( channel Name string , make Gossip Sender func ( sender protocol Sender , stop < - chan struct { } ) * gossip Sender ) * gossip Sender { gs . Lock ( ) defer gs . Unlock ( ) s , found : = gs . senders [ channel Name ] if ! found { s = make Gossip Sender ( gs . sender , gs . stop ) gs . senders [ channel Name ] = s } return s } 
func ( gs * gossip Senders ) Flush ( ) bool { sent : = false gs . Lock ( ) defer gs . Unlock ( ) for _ , sender : = range gs . senders { sent = sender . Flush ( ) | | sent } return sent } 
func find Main Path ( ) string { pc : = make ( [ ] uintptr , 1 0 0 ) n : = runtime . Callers ( 2 , pc ) frames : = runtime . Callers Frames ( pc [ : n ] ) for { frame , more : = frames . Next ( ) } if ! more { break } } return " " } 
func Create ( c context . Context , client ID string ) ( token string , err error ) { req : = & pb . Create Channel Request { Application Key : & client ID , } resp : = & pb . Create Channel Response { } err = internal . Call ( c , service , " " , req , resp ) token = resp . Get Token ( ) return token , remap Error ( err ) } 
func Send ( c context . Context , client ID , message string ) error { req : = & pb . Send Message Request { Application Key : & client ID , Message : & message , } resp : = & basepb . Void Proto { } return remap Error ( internal . Call ( c , service , " " , req , resp ) ) } 
func Send JSON ( c context . Context , client ID string , value interface { } ) error { m , err : = json . Marshal ( value ) if err ! = nil { return err } return Send ( c , client ID , string ( m ) ) } 
func remap Error ( err error ) error { if e , ok : = err . ( * internal . APIError ) ; ok { if e . Service = = " " { e . Service = " " } } return err } 
func Fully Qualified App ID ( ctx netcontext . Context ) string { if id , ok : = ctx . Value ( & app IDOverride Key ) . ( string ) ; ok { return id } return fully Qualified App ID ( ctx ) } 
func Namespaced Context ( ctx netcontext . Context , namespace string ) netcontext . Context { return with Namespace ( ctx , namespace ) } 
func proto To Item ( p * pb . Memcache Get Response _Item ) * Item { return & Item { Key : string ( p . Key ) , Value : p . Value , Flags : p . Get Flags ( ) , cas ID : p . Get Cas Id ( ) , } } 
func single Error ( err error ) error { if me , ok : = err . ( appengine . Multi Error ) ; ok { return me [ 0 ] } return err } 
func Get ( c context . Context , key string ) ( * Item , error ) { m , err : = Get Multi ( c , [ ] string { key } ) if err ! = nil { return nil , err } if _ , ok : = m [ key ] ; ! ok { return nil , Err Cache Miss } return m [ key ] , nil } 
func Get Multi ( c context . Context , key [ ] string ) ( map [ string ] * Item , error ) { if len ( key ) = = 0 { return nil , nil } key As Bytes : = make ( [ ] [ ] byte , len ( key ) ) for i , k : = range key { key As Bytes [ i ] = [ ] byte ( k ) } req : = & pb . Memcache Get Request { Key : key As Bytes , For Cas : proto . Bool ( true ) , } res : = & pb . Memcache Get Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } m : = make ( map [ string ] * Item , len ( res . Item ) ) for _ , p : = range res . Item { t : = proto To Item ( p ) m [ t . Key ] = t } return m , nil } 
func Delete ( c context . Context , key string ) error { return single Error ( Delete Multi ( c , [ ] string { key } ) ) } 
func Delete Multi ( c context . Context , key [ ] string ) error { if len ( key ) = = 0 { return nil } req : = & pb . Memcache Delete Request { Item : make ( [ ] * pb . Memcache Delete Request _Item , len ( key ) ) , } for i , k : = range key { req . Item [ i ] = & pb . Memcache Delete Request _Item { Key : [ ] byte ( k ) } } res : = & pb . Memcache Delete Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . Delete Status ) ! = len ( key ) { return Err Server Error } me , any : = make ( appengine . Multi Error , len ( key ) ) , false for i , s : = range res . Delete Status { switch s { case pb . Memcache Delete Response _DELETED : any = true default : me [ i ] = Err Server Error any = true } } if any { return me } return nil } 
func Increment ( c context . Context , key string , delta int 6 4 , initial Value uint 6 4 ) ( new Value uint 6 4 , err error ) { return incr ( c , key , delta , & initial Value ) } 
func Increment Existing ( c context . Context , key string , delta int 6 4 ) ( new Value uint 6 4 , err error ) { return incr ( c , key , delta , nil ) } 
func set ( c context . Context , item [ ] * Item , value [ ] [ ] byte , policy pb . Memcache Set Request _Set Policy ) error { if len ( item ) = = 0 { return nil } req : = & pb . Memcache Set Request { Item : make ( [ ] * pb . Memcache Set Request _Item , len ( item ) ) , } for i , t : = range item { p : = & pb . Memcache Set Request _Item { Key : [ ] byte ( t . Key ) , } if value = = nil { p . Value = t . Value } else { p . Value = value [ i ] } if t . Flags ! = 0 { p . Flags = proto . Uint 3 2 ( t . Flags ) } if t . Expiration ! = 0 { } else if t . Expiration > = thirty Years { p . Expiration Time = proto . Uint 3 2 ( uint 3 2 ( time . Now ( ) . Unix ( ) ) + uint 3 2 ( t . Expiration / time . Second ) ) } else { p . Expiration Time = proto . Uint 3 2 ( uint 3 2 ( t . Expiration / time . Second ) ) } } if t . cas ID ! = 0 { p . Cas Id = proto . Uint 6 4 ( t . cas ID ) p . For Cas = proto . Bool ( true ) } p . Set Policy = policy . Enum ( ) req . Item [ i ] = p } res : = & pb . Memcache Set Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . Set Status ) ! = len ( item ) { return Err Server Error } me , any : = make ( appengine . Multi Error , len ( item ) ) , false for i , st : = range res . Set Status { var err error switch st { case pb . Memcache Set Response _STORED : case pb . Memcache Set Response _EXISTS : err = Err CASConflict default : err = Err Server Error } if err ! = nil { me [ i ] = err any = true } } if any { return me } return nil } 
func Set ( c context . Context , item * Item ) error { return single Error ( set ( c , [ ] * Item { item } , nil , pb . Memcache Set Request _SET ) ) } 
func Set Multi ( c context . Context , item [ ] * Item ) error { return set ( c , item , nil , pb . Memcache Set Request _SET ) } 
func Add ( c context . Context , item * Item ) error { return single Error ( set ( c , [ ] * Item { item } , nil , pb . Memcache Set Request _ADD ) ) } 
func Add Multi ( c context . Context , item [ ] * Item ) error { return set ( c , item , nil , pb . Memcache Set Request _ADD ) } 
func Compare And Swap ( c context . Context , item * Item ) error { return single Error ( set ( c , [ ] * Item { item } , nil , pb . Memcache Set Request _CAS ) ) } 
func Compare And Swap Multi ( c context . Context , item [ ] * Item ) error { return set ( c , item , nil , pb . Memcache Set Request _CAS ) } 
func ( cd Codec ) Get ( c context . Context , key string , v interface { } ) ( * Item , error ) { i , err : = Get ( c , key ) if err ! = nil { return nil , err } if err : = cd . Unmarshal ( i . Value , v ) ; err ! = nil { return nil , err } return i , nil } 
func ( cd Codec ) Set ( c context . Context , item * Item ) error { return single Error ( cd . set ( c , [ ] * Item { item } , pb . Memcache Set Request _SET ) ) } 
func ( cd Codec ) Set Multi ( c context . Context , items [ ] * Item ) error { return cd . set ( c , items , pb . Memcache Set Request _SET ) } 
func ( cd Codec ) Add ( c context . Context , item * Item ) error { return single Error ( cd . set ( c , [ ] * Item { item } , pb . Memcache Set Request _ADD ) ) } 
func ( cd Codec ) Add Multi ( c context . Context , items [ ] * Item ) error { return cd . set ( c , items , pb . Memcache Set Request _ADD ) } 
func ( cd Codec ) Compare And Swap ( c context . Context , item * Item ) error { return single Error ( cd . set ( c , [ ] * Item { item } , pb . Memcache Set Request _CAS ) ) } 
func ( cd Codec ) Compare And Swap Multi ( c context . Context , items [ ] * Item ) error { return cd . set ( c , items , pb . Memcache Set Request _CAS ) } 
func Stats ( c context . Context ) ( * Statistics , error ) { req : = & pb . Memcache Stats Request { } res : = & pb . Memcache Stats Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } if res . Stats = = nil { return nil , Err No Stats } return & Statistics { Hits : * res . Stats . Hits , Misses : * res . Stats . Misses , Byte Hits : * res . Stats . Byte Hits , Items : * res . Stats . Items , Bytes : * res . Stats . Bytes , Oldest : int 6 4 ( * res . Stats . Oldest Item Age ) , } , nil } 
func Flush ( c context . Context ) error { req : = & pb . Memcache Flush Request { } res : = & pb . Memcache Flush Response { } return internal . Call ( c , " " , " " , req , res ) } 
func init ( ) { http . Handle Func ( " " , handle Background ) sc : = make ( chan send ) rc : = make ( chan recv ) sendc , recvc = sc , rc go matchmaker ( sc , rc ) } 
func Run In Background ( c context . Context , f func ( c context . Context ) ) error { req : = & pb . Start Background Request Request { } res : = & pb . Start Background Request Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } sendc < - send { res . Get Request Id ( ) , f } return nil } 
func List ( c context . Context ) ( [ ] string , error ) { req : = & pb . Get Modules Request { } res : = & pb . Get Modules Response { } err : = internal . Call ( c , " " , " " , req , res ) return res . Module , err } 
func Num Instances ( c context . Context , module , version string ) ( int , error ) { req : = & pb . Get Num Instances Request { } if module ! = " " { req . Module = & module } if version ! = " " { req . Version = & version } res : = & pb . Get Num Instances Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , err } return int ( * res . Instances ) , nil } 
func Set Num Instances ( c context . Context , module , version string , instances int ) error { req : = & pb . Set Num Instances Request { } if module ! = " " { req . Module = & module } if version ! = " " { req . Version = & version } req . Instances = proto . Int 6 4 ( int 6 4 ( instances ) ) res : = & pb . Set Num Instances Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Versions ( c context . Context , module string ) ( [ ] string , error ) { req : = & pb . Get Versions Request { } if module ! = " " { req . Module = & module } res : = & pb . Get Versions Response { } err : = internal . Call ( c , " " , " " , req , res ) return res . Get Version ( ) , err } 
func Default Version ( c context . Context , module string ) ( string , error ) { req : = & pb . Get Default Version Request { } if module ! = " " { req . Module = & module } res : = & pb . Get Default Version Response { } err : = internal . Call ( c , " " , " " , req , res ) return res . Get Version ( ) , err } 
func Start ( c context . Context , module , version string ) error { req : = & pb . Start Module Request { } if module ! = " " { req . Module = & module } if version ! = " " { req . Version = & version } res : = & pb . Start Module Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Stop ( c context . Context , module , version string ) error { req : = & pb . Stop Module Request { } if module ! = " " { req . Module = & module } if version ! = " " { req . Version = & version } res : = & pb . Stop Module Response { } return internal . Call ( c , " " , " " , req , res ) } 
func ( q * Query ) Ancestor ( ancestor * Key ) * Query { q = q . clone ( ) if ancestor = = nil { q . err = errors . New ( " " ) return q } q . ancestor = ancestor return q } 
func ( q * Query ) Eventual Consistency ( ) * Query { q = q . clone ( ) q . eventual = true return q } 
func ( q * Query ) Filter ( filter Str string , value interface { } ) * Query { q = q . clone ( ) filter Str = strings . Trim Space ( filter Str ) if len ( filter Str ) < 1 { q . err = errors . New ( " " + filter Str ) return q } f : = filter { Field Name : strings . Trim Right ( filter Str , " " ) , Value : value , } switch op : = strings . Trim Space ( filter Str [ len ( f . Field Name ) : ] ) ; op { case " " : f . Op = less Eq case " " : f . Op = greater Eq case " " : f . Op = less Than case " " : f . Op = greater Than case " " : f . Op = equal default : q . err = fmt . Errorf ( " " , op , filter Str ) return q } q . filter = append ( q . filter , f ) return q } 
func ( q * Query ) Order ( field Name string ) * Query { q = q . clone ( ) field Name = strings . Trim Space ( field Name ) o : = order { Direction : ascending , Field Name : field Name , } if strings . Has Prefix ( field Name , " " ) { o . Direction = descending o . Field Name = strings . Trim Space ( field Name [ 1 : ] ) } else if strings . Has Prefix ( field Name , " " ) { q . err = fmt . Errorf ( " " , field Name ) return q } if len ( o . Field Name ) = = 0 { q . err = errors . New ( " " ) return q } q . order = append ( q . order , o ) return q } 
func ( q * Query ) Project ( field Names . . . string ) * Query { q = q . clone ( ) q . projection = append ( [ ] string ( nil ) , field Names . . . ) return q } 
func ( q * Query ) Distinct ( ) * Query { q = q . clone ( ) q . distinct = true return q } 
func ( q * Query ) Distinct On ( field Names . . . string ) * Query { q = q . clone ( ) q . distinct On = field Names return q } 
func ( q * Query ) Keys Only ( ) * Query { q = q . clone ( ) q . keys Only = true return q } 
func ( q * Query ) Limit ( limit int ) * Query { q = q . clone ( ) if limit < math . Min Int 3 2 | | limit > math . Max Int 3 2 { q . err = errors . New ( " " ) return q } q . limit = int 3 2 ( limit ) return q } 
func ( q * Query ) Offset ( offset int ) * Query { q = q . clone ( ) if offset < 0 { q . err = errors . New ( " " ) return q } if offset > math . Max Int 3 2 { q . err = errors . New ( " " ) return q } q . offset = int 3 2 ( offset ) return q } 
func ( q * Query ) Batch Size ( size int ) * Query { q = q . clone ( ) if size < = 0 | | size > math . Max Int 3 2 { q . err = errors . New ( " " ) return q } q . count = int 3 2 ( size ) return q } 
func ( q * Query ) Start ( c Cursor ) * Query { q = q . clone ( ) if c . cc = = nil { q . err = errors . New ( " " ) return q } q . start = c . cc return q } 
func ( q * Query ) End ( c Cursor ) * Query { q = q . clone ( ) if c . cc = = nil { q . err = errors . New ( " " ) return q } q . end = c . cc return q } 
func ( q * Query ) to Proto ( dst * pb . Query , app ID string ) error { if len ( q . projection ) ! = 0 & & q . keys Only { return errors . New ( " " ) } if len ( q . distinct On ) ! = 0 & & q . distinct { return errors . New ( " " ) } dst . Reset ( ) dst . App = proto . String ( app ID ) if q . kind ! = " " { dst . Kind = proto . String ( q . kind ) } if q . ancestor ! = nil { dst . Ancestor = key To Proto ( app ID , q . ancestor ) if q . eventual { dst . Strong = proto . Bool ( false ) } } if q . projection ! = nil { dst . Property Name = q . projection if len ( q . distinct On ) ! = 0 { dst . Group By Property Name = q . distinct On } if q . distinct { dst . Group By Property Name = q . projection } } if q . keys Only { dst . Keys Only = proto . Bool ( true ) dst . Require Perfect Plan = proto . Bool ( true ) } for _ , qf : = range q . filter { if qf . Field Name = = " " { return errors . New ( " " ) } p , err Str : = value To Proto ( app ID , qf . Field Name , reflect . Value Of ( qf . Value ) , false ) if err Str ! = " " { return errors . New ( " " + err Str ) } xf : = & pb . Query _Filter { Op : operator To Proto [ qf . Op ] , Property : [ ] * pb . Property { p } , } if xf . Op = = nil { return errors . New ( " " ) } dst . Filter = append ( dst . Filter , xf ) } for _ , qo : = range q . order { if qo . Field Name = = " " { return errors . New ( " " ) } xo : = & pb . Query _Order { Property : proto . String ( qo . Field Name ) , Direction : sort Direction To Proto [ qo . Direction ] , } if xo . Direction = = nil { return errors . New ( " " ) } dst . Order = append ( dst . Order , xo ) } if q . limit > = 0 { dst . Limit = proto . Int 3 2 ( q . limit ) } if q . offset ! = 0 { dst . Offset = proto . Int 3 2 ( q . offset ) } if q . count ! = 0 { dst . Count = proto . Int 3 2 ( q . count ) } dst . Compiled Cursor = q . start dst . End Compiled Cursor = q . end dst . Compile = proto . Bool ( true ) return nil } 
func ( q * Query ) Count ( c context . Context ) ( int , error ) { } new Q . keys Only = len ( new Q . projection ) = = 0 new Q . limit = 0 if q . limit < 0 { } else { new Q . offset = q . offset + q . limit if new Q . offset < 0 { } } req : = & pb . Query { } if err : = new Q . to Proto ( req , internal . Fully Qualified App ID ( c ) ) ; err ! = nil { return 0 , err } res : = & pb . Query Result { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , err } for { } n + = res . Get Skipped Results ( ) if ! res . Get More Results ( ) { break } if err : = call Next ( c , res , new Q . offset - n , q . count ) ; err ! = nil { return 0 , err } } n - = q . offset if n < 0 { } return int ( n ) , nil } 
func call Next ( c context . Context , res * pb . Query Result , offset , count int 3 2 ) error { if res . Cursor = = nil { return errors . New ( " " ) } req : = & pb . Next Request { Cursor : res . Cursor , } if count > = 0 { req . Count = proto . Int 3 2 ( count ) } if offset ! = 0 { req . Offset = proto . Int 3 2 ( offset ) } if res . Compiled Cursor ! = nil { req . Compile = proto . Bool ( true ) } res . Reset ( ) return internal . Call ( c , " " , " " , req , res ) } 
func ( q * Query ) Get All ( c context . Context , dst interface { } ) ( [ ] * Key , error ) { var ( dv reflect . Value mat multi Arg Type elem Type reflect . Type err Field Mismatch error ) if ! q . keys Only { dv = reflect . Value Of ( dst ) if dv . Kind ( ) ! = reflect . Ptr | | dv . Is Nil ( ) { return nil , Err Invalid Entity Type } dv = dv . Elem ( ) mat , elem Type = check Multi Arg ( dv ) if mat = = multi Arg Type Invalid | | mat = = multi Arg Type Interface { return nil , Err Invalid Entity Type } } var keys [ ] * Key for t : = q . Run ( c ) ; ; { k , e , err : = t . next ( ) if err = = Done { break } if err ! = nil { return keys , err } if ! q . keys Only { ev : = reflect . New ( elem Type ) if elem Type . Kind ( ) = = reflect . Map { ev . Elem ( ) . Set ( x ) } if err = load Entity ( ev . Interface ( ) , e ) ; err ! = nil { if _ , ok : = err . ( * Err Field Mismatch ) ; ok { } else { return keys , err } } if mat ! = multi Arg Type Struct Ptr { ev = ev . Elem ( ) } dv . Set ( reflect . Append ( dv , ev ) ) } keys = append ( keys , k ) } return keys , err Field Mismatch } 
func ( q * Query ) Run ( c context . Context ) * Iterator { if q . err ! = nil { return & Iterator { err : q . err } } t : = & Iterator { c : c , limit : q . limit , count : q . count , q : q , prev CC : q . start , } var req pb . Query if err : = q . to Proto ( & req , internal . Fully Qualified App ID ( c ) ) ; err ! = nil { t . err = err return t } if err : = internal . Call ( c , " " , " " , & req , & t . res ) ; err ! = nil { t . err = err return t } offset : = q . offset - t . res . Get Skipped Results ( ) var count int 3 2 if t . count > 0 & & ( t . limit < 0 | | t . count < t . limit ) { count = t . count } else { count = t . limit } for offset > 0 & & t . res . Get More Results ( ) { t . prev CC = t . res . Compiled Cursor if err : = call Next ( t . c , & t . res , offset , count ) ; err ! = nil { t . err = err break } skip : = t . res . Get Skipped Results ( ) if skip < 0 { t . err = errors . New ( " " ) break } offset - = skip } if offset < 0 { t . err = errors . New ( " " ) } return t } 
func ( t * Iterator ) Next ( dst interface { } ) ( * Key , error ) { k , e , err : = t . next ( ) if err ! = nil { return nil , err } if dst ! = nil & & ! t . q . keys Only { err = load Entity ( dst , e ) } return k , err } 
func ( t * Iterator ) Cursor ( ) ( Cursor , error ) { if t . err ! = nil & & t . err ! = Done { return Cursor { } , t . err } if t . i = = 0 & & skipped = = 0 { if t . prev CC = = nil { } return Cursor { t . prev CC } , nil } if t . i = = len ( t . res . Result ) { return Cursor { t . res . Compiled Cursor } , nil } q . start = t . prev CC q . offset = skipped + int 3 2 ( t . i ) q . limit = 0 q . keys Only = len ( q . projection ) = = 0 t 1 : = q . Run ( t . c ) _ , _ , err : = t 1 . next ( ) if err ! = Done { if err = = nil { err = fmt . Errorf ( " " ) } return Cursor { } , err } return Cursor { t 1 . res . Compiled Cursor } , nil } 
func ( c Cursor ) String ( ) string { if c . cc = = nil { return " " } b , err : = proto . Marshal ( c . cc ) if err ! = nil { } return strings . Trim Right ( base 6 4 . URLEncoding . Encode To String ( b ) , " " ) } 
func Decode Cursor ( s string ) ( Cursor , error ) { if s = = " " { return Cursor { & zero CC } , nil } if n : = len ( s ) % 4 ; n ! = 0 { s + = strings . Repeat ( " " , 4 - n ) } b , err : = base 6 4 . URLEncoding . Decode String ( s ) if err ! = nil { return Cursor { } , err } cc : = & pb . Compiled Cursor { } if err : = proto . Unmarshal ( b , cc ) ; err ! = nil { return Cursor { } , err } return Cursor { cc } , nil } 
func value To Proto ( default App ID , name string , v reflect . Value , multiple bool ) ( p * pb . Property , err Str string ) { var ( pv pb . Property Value unsupported bool ) switch v . Kind ( ) { case reflect . Invalid : case reflect . Bool : pv . Boolean Value = proto . Bool ( v . Bool ( ) ) case reflect . String : pv . String Value = proto . String ( v . String ( ) ) case reflect . Float 3 2 , reflect . Float 6 4 : pv . Double Value = proto . Float 6 4 ( v . Float ( ) ) case reflect . Ptr : if k , ok : = v . Interface ( ) . ( * Key ) ; ok { if k ! = nil { pv . Referencevalue = key To Reference Value ( default App ID , k ) } } else { unsupported = true } case reflect . Struct : switch t : = v . Interface ( ) . ( type ) { case time . Time : if t . Before ( min Time ) | | t . After ( max Time ) { return nil , " " } pv . Int 6 4Value = proto . Int 6 4 ( to Unix Micro ( t ) ) case appengine . Geo Point : if ! t . Valid ( ) { return nil , " " } default : unsupported = true } case reflect . Slice : if b , ok : = v . Interface ( ) . ( [ ] byte ) ; ok { pv . String Value = proto . String ( string ( b ) ) } else { } default : unsupported = true } if unsupported { return nil , " " + v . Type ( ) . String ( ) } p = & pb . Property { Name : proto . String ( name ) , Value : & pv , Multiple : proto . Bool ( multiple ) , } if v . Is Valid ( ) { switch v . Interface ( ) . ( type ) { case [ ] byte : p . Meaning = pb . Property _BLOB . Enum ( ) case Byte String : p . Meaning = pb . Property _BYTESTRING . Enum ( ) case appengine . Blob Key : p . Meaning = pb . Property _BLOBKEY . Enum ( ) case time . Time : p . Meaning = pb . Property _GD _WHEN . Enum ( ) case appengine . Geo Point : p . Meaning = pb . Property _GEORSS _POINT . Enum ( ) } } return p , " " } 
func save Entity ( default App ID string , key * Key , src interface { } ) ( * pb . Entity Proto , error ) { var err error var props [ ] Property if e , ok : = src . ( Property Load Saver ) ; ok { props , err = e . Save ( ) } else { props , err = Save Struct ( src ) } if err ! = nil { return nil , err } return properties To Proto ( default App ID , key , props ) } 
func ( l * Field List ) Load ( f [ ] Field , _ * Document Metadata ) error { * l = append ( * l , f . . . ) return nil } 
func ( m * App Override ) Get Num Memcacheg Backends ( ) int 3 2 { if m ! = nil & & m . Num Memcacheg Backends ! = nil { return * m . Num Memcacheg Backends } return 0 } 
func ( m * App Override ) Get Ignore Shardlock ( ) bool { if m ! = nil & & m . Ignore Shardlock ! = nil { return * m . Ignore Shardlock } return false } 
func ( m * App Override ) Get Memcache Pool Hint ( ) string { if m ! = nil & & m . Memcache Pool Hint ! = nil { return * m . Memcache Pool Hint } return " " } 
func Namespace ( c context . Context , namespace string ) ( context . Context , error ) { if ! valid Namespace . Match String ( namespace ) { return nil , fmt . Errorf ( " " , namespace , valid Namespace ) } return internal . Namespaced Context ( c , namespace ) , nil } 
func ( cfg * Type Config ) typeof ( name string ) string { if cfg . Var ! = nil { if t : = cfg . Var [ name ] ; t ! = " " { return t } } if cfg . Func ! = nil { if t : = cfg . Func [ name ] ; t ! = " " { return " " + t } } return " " } 
func ( typ * Type ) dot ( cfg * Type Config , name string ) string { if typ . Field ! = nil { if t : = typ . Field [ name ] ; t ! = " " { return t } } if typ . Method ! = nil { if t : = typ . Method [ name ] ; t ! = " " { return t } } for _ , e : = range typ . Embed { etyp : = cfg . Type [ e ] if etyp ! = nil { if t : = etyp . dot ( cfg , name ) ; t ! = " " { return t } } } return " " } 
func typecheck ( cfg * Type Config , f * ast . File ) ( typeof map [ interface { } ] string , assign map [ string ] [ ] interface { } ) { typeof = make ( map [ interface { } ] string ) assign = make ( map [ string ] [ ] interface { } ) cfg 1 : = & Type Config { } * cfg 1 = * cfg copied : = false if ! ok { continue } typecheck 1 ( cfg , fn . Type , typeof , assign ) t : = typeof [ fn . Type ] if fn . Recv ! = nil { if ! is Type ( rcvr ) { if len ( fn . Recv . List ) ! = 1 { continue } rcvr = mk Type ( gofmt ( fn . Recv . List [ 0 ] . Type ) ) typeof [ fn . Recv . List [ 0 ] . Type ] = rcvr } rcvr = get Type ( rcvr ) if rcvr ! = " " & & rcvr [ 0 ] = = ' * ' { rcvr = rcvr [ 1 : ] } typeof [ rcvr + " " + fn . Name . Name ] = t } else { if is Type ( t ) { t = get Type ( t ) } else { t = gofmt ( fn . Type ) } typeof [ fn . Name ] = t } } if ok { for _ , s : = range d . Specs { switch s : = s . ( type ) { case * ast . Type Spec : if cfg 1 . Type [ s . Name . Name ] ! = nil { break } if ! copied { copied = true for k , v : = range cfg . Type { cfg 1 . Type [ k ] = v } } t : = & Type { Field : map [ string ] string { } } cfg 1 . Type [ s . Name . Name ] = t switch st : = s . Type . ( type ) { case * ast . Struct Type : for _ , f : = range st . Fields . List { for _ , n : = range f . Names { t . Field [ n . Name ] = gofmt ( f . Type ) } } case * ast . Array Type , * ast . Star Expr , * ast . Map Type : t . Def = gofmt ( st ) } } } } } typecheck 1 ( cfg 1 , f , typeof , assign ) return typeof , assign } 
func typecheck 1 ( cfg * Type Config , f interface { } , typeof map [ interface { } ] string , assign map [ string ] [ ] interface { } ) { } return } typeof [ n ] = typ } } } return } } if len ( lhs ) = = 1 & & len ( rhs ) = = 2 { } else if len ( lhs ) = = 2 & & len ( rhs ) = = 1 { } if typeof [ y ] ! = " " { set ( x , typeof [ y ] , is Decl ) } else { set ( y , typeof [ x ] , false ) } } } expand : = func ( s string ) string { typ : = cfg . Type [ s ] if typ ! = nil & & typ . Def ! = " " { return typ . Def } return s } before : = func ( n interface { } ) { case * ast . Func Lit : curfn = append ( curfn , n . Type ) } } } if false & & reflect . Type Of ( n ) . Kind ( ) = = reflect . Ptr { fmt . Fprintf ( os . Stderr , " \n " , pos , gofmt ( n ) , t ) } } ( ) } switch n : = n . ( type ) { case * ast . Func Decl , * ast . Func Lit : case * ast . Func Type : typeof [ n ] = mk Type ( join Func ( split ( typeof [ n . Params ] ) , split ( typeof [ n . Results ] ) ) ) case * ast . Field List : for _ , field : = range n . List { if t ! = " " { t + = " " } t + = typeof [ field ] } typeof [ n ] = t case * ast . Field : t : = typeof [ n . Type ] if ! is Type ( t ) { typeof [ n . Type ] = t } t = get Type ( t ) if len ( n . Names ) = = 0 { all = t } else { for _ , id : = range n . Names { if all ! = " " { all + = " " } all + = t typeof [ id . Obj ] = t typeof [ id ] = t } } typeof [ n ] = all case * ast . Value Spec : if ! is Type ( t ) { t = mk Type ( gofmt ( n . Type ) ) typeof [ n . Type ] = t } t = get Type ( t ) for _ , id : = range n . Names { set ( id , t , true ) } } case * ast . Assign Stmt : typecheck Assign ( n . Lhs , n . Rhs , n . Tok = = token . DEFINE ) case * ast . Ident : } case * ast . Selector Expr : if t : = typeof [ n . X ] ; t ! = " " { if strings . Has Prefix ( t , " " ) { t = t [ 1 : ] } if typ : = cfg . Type [ t ] ; typ ! = nil { if t : = typ . dot ( cfg , name ) ; t ! = " " { typeof [ n ] = t return } } tt : = typeof [ t + " " + name ] if is Type ( tt ) { typeof [ n ] = get Type ( tt ) return } } if cfg . Type [ str ] ! = nil { typeof [ n ] = mk Type ( str ) return } if t : = cfg . typeof ( x . Name + " " + name ) ; t ! = " " { typeof [ n ] = t return } } case * ast . Call Expr : return } return } in , out : = split Func ( t ) if in = = nil & & out = = nil { return } typeof [ n ] = join ( out ) for i , arg : = range n . Args { if i > = len ( in ) { break } if typeof [ arg ] = = " " { typeof [ arg ] = in [ i ] } } case * ast . Type Assert Expr : return } } else { typeof [ n ] = gofmt ( n . Type ) } case * ast . Slice Expr : case * ast . Index Expr : if strings . Has Prefix ( t , " " ) | | strings . Has Prefix ( t , " " ) { } } case * ast . Star Expr : if is Type ( t ) { typeof [ n ] = " " + get Type ( t ) } else if strings . Has Prefix ( t , " " ) { typeof [ n ] = t [ len ( " " ) : ] } case * ast . Unary Expr : if t ! = " " & & n . Op = = token . AND { typeof [ n ] = " " + t } case * ast . Composite Lit : case * ast . Paren Expr : case * ast . Range Stmt : t : = expand ( typeof [ n . X ] ) if t = = " " { return } var key , value string if t = = " " { key , value = " " , " " } else if strings . Has Prefix ( t , " " ) { key = " " if i : = strings . Index ( t , " " ) ; i > = 0 { value = t [ i + 1 : ] } } else if strings . Has Prefix ( t , " " ) { if i : = strings . Index ( t , " " ) ; i > = 0 { key , value = t [ 4 : i ] , t [ i + 1 : ] } } changed : = false if n . Key ! = nil & & key ! = " " { changed = true set ( n . Key , key , n . Tok = = token . DEFINE ) } if n . Value ! = nil & & value ! = " " { changed = true set ( n . Value , value , n . Tok = = token . DEFINE ) } } case * ast . Type Switch Stmt : if ! ok { return } varx , ok : = as . Lhs [ 0 ] . ( * ast . Ident ) if ! ok { return } t : = typeof [ varx ] for _ , cas : = range n . Body . List { cas : = cas . ( * ast . Case Clause ) if len ( cas . List ) = = 1 { typeof [ varx ] = tt typeof [ varx . Obj ] = tt typecheck 1 ( cfg , cas . Body , typeof , assign ) } } } typeof [ varx . Obj ] = t case * ast . Return Stmt : if len ( curfn ) = = 0 { } f : = curfn [ len ( curfn ) - 1 ] res : = n . Results if f . Results ! = nil { t : = split ( typeof [ f . Results ] ) for i : = 0 ; i < len ( res ) & & i < len ( t ) ; i + + { set ( res [ i ] , t [ i ] , false ) } } } } walk Before After ( f , before , after ) } 
func split Func ( s string ) ( in , out [ ] string ) { if ! strings . Has Prefix ( s , " " ) { return nil , nil } i : = len ( " " ) nparen : = 0 for j : = i ; j < len ( s ) ; j + + { switch s [ j ] { case ' ( ' : nparen + + case ' ) ' : nparen - - if nparen < 0 { if len ( out ) > = 2 & & out [ 0 ] = = ' ( ' & & out [ len ( out ) - 1 ] = = ' ) ' { out = out [ 1 : len ( out ) - 1 ] } return split ( s [ i : j ] ) , split ( out ) } } } return nil , nil } 
func join Func ( in , out [ ] string ) string { outs : = " " if len ( out ) = = 1 { outs = " " + out [ 0 ] } else if len ( out ) > 1 { outs = " " + join ( out ) + " " } return " " + join ( in ) + " " + outs } 
func split ( s string ) [ ] string { out : = [ ] string { } i : = 0 nparen : = 0 for j : = 0 ; j < len ( s ) ; j + + { switch s [ j ] { case ' ' : if i = = j { i + + } case ' ( ' : nparen + + case ' ) ' : nparen - - if nparen < 0 { } case ' , ' : if nparen = = 0 { if i < j { out = append ( out , s [ i : j ] ) } i = j + 1 } } } if nparen ! = 0 { } if i < len ( s ) { out = append ( out , s [ i : ] ) } return out } 
func Enabled ( ctx context . Context , api , capability string ) bool { req : = & pb . Is Enabled Request { Package : & api , Capability : [ ] string { capability } , } res : = & pb . Is Enabled Response { } if err : = internal . Call ( ctx , " " , " " , req , res ) ; err ! = nil { log . Warningf ( ctx , " " , err ) return false } switch * res . Summary Status { case pb . Is Enabled Response _ENABLED , pb . Is Enabled Response _SCHEDULED _FUTURE , pb . Is Enabled Response _SCHEDULED _NOW : return true case pb . Is Enabled Response _UNKNOWN : log . Errorf ( ctx , " " , api , capability ) return false default : return false } } 
func ( l * Property List ) Load ( p [ ] Property ) error { * l = append ( * l , p . . . ) return nil } 
func valid Property Name ( name string ) bool { if name = = " " { return false } for _ , s : = range strings . Split ( name , " " ) { if s = = " " { return false } first : = true for _ , c : = range s { if first { first = false if c ! = ' _ ' & & ! unicode . Is Letter ( c ) { return false } } else { if c ! = ' _ ' & & ! unicode . Is Letter ( c ) & & ! unicode . Is Digit ( c ) { return false } } } } return true } 
func get Struct Codec ( t reflect . Type ) ( * struct Codec , error ) { struct Codecs Mutex . Lock ( ) defer struct Codecs Mutex . Unlock ( ) return get Struct Codec Locked ( t ) } 
func get Struct Codec Locked ( t reflect . Type ) ( ret * struct Codec , ret Err error ) { c , ok : = struct Codecs [ t ] if ok { return c , nil } c = & struct Codec { fields : make ( map [ string ] field Codec ) , defer func ( ) { if ret Err ! = nil { delete ( struct Codecs , t ) } } ( ) for i : = 0 ; i < t . Num Field ( ) ; i + + { f : = t . Field ( i ) } tags : = strings . Split ( f . Tag . Get ( " " ) , " " ) name : = tags [ 0 ] opts : = make ( map [ string ] bool ) for _ , t : = range tags [ 1 : ] { opts [ t ] = true } switch { case name = = " " : if ! f . Anonymous { name = f . Name } case name = = " " : continue case name = = " " : if f . Type ! = type Of Key Ptr { return nil , fmt . Errorf ( " " , t ) } c . key Field = i case ! valid Property Name ( name ) : return nil , fmt . Errorf ( " " , name ) } substruct Type , f Is Slice : = reflect . Type ( nil ) , false switch f . Type . Kind ( ) { case reflect . Struct : substruct Type = f . Type case reflect . Slice : if f . Type . Elem ( ) . Kind ( ) = = reflect . Struct { substruct Type = f . Type . Elem ( ) } f Is Slice = f . Type ! = type Of Byte Slice c . has Slice = c . has Slice | | f Is Slice } var sub * struct Codec if substruct Type ! = nil & & substruct Type ! = type Of Time & & substruct Type ! = type Of Geo Point { var err error sub , err = get Struct Codec Locked ( substruct Type ) if err ! = nil { return nil , err } if ! sub . complete { return nil , fmt . Errorf ( " " , f . Name ) } if f Is Slice & & sub . has Slice { return nil , fmt . Errorf ( " " , f . Name ) } c . has Slice = c . has Slice | | sub . has Slice } if _ , ok : = c . fields [ subname ] ; ok { return nil , fmt . Errorf ( " " , subname ) } c . fields [ subname ] = field Codec { path : append ( [ ] int { i } , subfield . path . . . ) , no Index : subfield . no Index | | opts [ " " ] , omit Empty : subfield . omit Empty , struct Codec : subfield . struct Codec , } } continue } } if _ , ok : = c . fields [ name ] ; ok { return nil , fmt . Errorf ( " " , name ) } c . fields [ name ] = field Codec { path : [ ] int { i } , no Index : opts [ " " ] , omit Empty : opts [ " " ] , struct Codec : sub , } } c . complete = true return c , nil } 
func Load Struct ( dst interface { } , p [ ] Property ) error { x , err : = new Struct PLS ( dst ) if err ! = nil { return err } return x . Load ( p ) } 
func Save Struct ( src interface { } ) ( [ ] Property , error ) { x , err : = new Struct PLS ( src ) if err ! = nil { return nil , err } return x . Save ( ) } 
func Serving URL ( c context . Context , key appengine . Blob Key , opts * Serving URLOptions ) ( * url . URL , error ) { req : = & pb . Images Get Url Base Request { Blob Key : ( * string ) ( & key ) , } if opts ! = nil & & opts . Secure { req . Create Secure Url = & opts . Secure } res : = & pb . Images Get Url Base Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } if opts ! = nil & & opts . Size > 0 { u + = fmt . Sprintf ( " " , opts . Size ) if opts . Crop { u + = " " } } return url . Parse ( u ) } 
func Delete Serving URL ( c context . Context , key appengine . Blob Key ) error { req : = & pb . Images Delete Url Base Request { Blob Key : ( * string ) ( & key ) , } res : = & pb . Images Delete Url Base Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Current OAuth ( c context . Context , scopes . . . string ) ( * User , error ) { req : = & pb . Get OAuth User Request { } if len ( scopes ) ! = 1 | | scopes [ 0 ] ! = " " { } res : = & pb . Get OAuth User Response { } err : = internal . Call ( c , " " , " " , req , res ) if err ! = nil { return nil , err } return & User { Email : * res . Email , Auth Domain : * res . Auth Domain , Admin : res . Get Is Admin ( ) , ID : * res . User Id , Client ID : res . Get Client Id ( ) , } , nil } 
func OAuth Consumer Key ( c context . Context ) ( string , error ) { req : = & pb . Check OAuth Signature Request { } res : = & pb . Check OAuth Signature Response { } err : = internal . Call ( c , " " , " " , req , res ) if err ! = nil { return " " , err } return * res . Oauth Consumer Key , err } 
func app ID ( full App ID string ) string { _ , dom , dis : = parse Full App ID ( full App ID ) if dom ! = " " { return dom + " " + dis } return dis } 
func ( u * User ) String ( ) string { if u . Auth Domain ! = " " & & strings . Has Suffix ( u . Email , " " + u . Auth Domain ) { return u . Email [ : len ( u . Email ) - len ( " " + u . Auth Domain ) ] } if u . Federated Identity ! = " " { return u . Federated Identity } return u . Email } 
func Login URL ( c context . Context , dest string ) ( string , error ) { return Login URLFederated ( c , dest , " " ) } 
func Login URLFederated ( c context . Context , dest , identity string ) ( string , error ) { req : = & pb . Create Login URLRequest { Destination Url : proto . String ( dest ) , } if identity ! = " " { req . Federated Identity = proto . String ( identity ) } res : = & pb . Create Login URLResponse { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . Login Url , nil } 
func Logout URL ( c context . Context , dest string ) ( string , error ) { req : = & pb . Create Logout URLRequest { Destination Url : proto . String ( dest ) , } res : = & pb . Create Logout URLResponse { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . Logout Url , nil } 
func map Package ( s string ) string { if stutter Package { s + = " " + path . Base ( s ) } return new Package Base + s } 
func insert Context ( f * ast . File , call * ast . Call Expr , ctx * ast . Ident ) { if ctx = = nil { } else { } call . Args = append ( [ ] ast . Expr { ctx } , call . Args . . . ) } 
func New Client ( host string , client * http . Client ) ( * Client , error ) { * wrap Client = * client t : = client . Transport if t = = nil { t = http . Default Transport } wrap Client . Transport = & header Adding Round Tripper { t } url : = url . URL { Scheme : " " , Host : host , Path : " " , } if host = = " " | | strings . Has Prefix ( host , " " ) { url . Scheme = " " } u : = url . String ( ) app ID , err : = get App ID ( wrap Client , u ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & Client { hc : wrap Client , url : u , app ID : app ID , } , nil } 
func ( c * Client ) New Context ( parent context . Context ) context . Context { ctx : = internal . With Call Override ( parent , c . call ) ctx = internal . With Log Override ( ctx , c . logf ) ctx = internal . With App IDOverride ( ctx , c . app ID ) return ctx } 
func New Remote Context ( host string , client * http . Client ) ( context . Context , error ) { c , err : = New Client ( host , client ) if err ! = nil { return nil , err } return c . New Context ( context . Background ( ) ) , nil } 
func Debugf ( ctx context . Context , format string , args . . . interface { } ) { internal . Logf ( ctx , 0 , format , args . . . ) } 
func guestbook Key ( ctx context . Context ) * datastore . Key { } 
func ( opt * Retry Options ) to Retry Parameters ( ) * pb . Task Queue Retry Parameters { params : = & pb . Task Queue Retry Parameters { } if opt . Retry Limit > 0 { params . Retry Limit = proto . Int 3 2 ( opt . Retry Limit ) } if opt . Age Limit > 0 { params . Age Limit Sec = proto . Int 6 4 ( int 6 4 ( opt . Age Limit . Seconds ( ) ) ) } if opt . Min Backoff > 0 { params . Min Backoff Sec = proto . Float 6 4 ( opt . Min Backoff . Seconds ( ) ) } if opt . Max Backoff > 0 { params . Max Backoff Sec = proto . Float 6 4 ( opt . Max Backoff . Seconds ( ) ) } if opt . Max Doublings > 0 | | ( opt . Max Doublings = = 0 & & opt . Apply Zero Max Doublings ) { params . Max Doublings = proto . Int 3 2 ( opt . Max Doublings ) } return params } 
func New POSTTask ( path string , params url . Values ) * Task { h : = make ( http . Header ) h . Set ( " " , " " ) return & Task { Path : path , Payload : [ ] byte ( params . Encode ( ) ) , Header : h , Method : " " , } } 
func Parse Request Headers ( h http . Header ) * Request Headers { ret : = & Request Headers { Queue Name : h . Get ( " " ) , Task Name : h . Get ( " " ) , } ret . Task Retry Count , _ = strconv . Parse Int ( h . Get ( " " ) , 1 0 , 6 4 ) ret . Task Execution Count , _ = strconv . Parse Int ( h . Get ( " " ) , 1 0 , 6 4 ) eta Secs , _ : = strconv . Parse Int ( h . Get ( " " ) , 1 0 , 6 4 ) if eta Secs ! = 0 { ret . Task ETA = time . Unix ( eta Secs , 0 ) } ret . Task Previous Response , _ = strconv . Atoi ( h . Get ( " " ) ) ret . Task Retry Reason = h . Get ( " " ) if h . Get ( " " ) ! = " " { ret . Fail Fast = true } return ret } 
func Add ( c context . Context , task * Task , queue Name string ) ( * Task , error ) { req , err : = new Add Req ( c , task , queue Name ) if err ! = nil { return nil , err } res : = & pb . Task Queue Add Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { api Err , ok : = err . ( * internal . APIError ) if ok & & already Added Errors [ pb . Task Queue Service Error _Error Code ( api Err . Code ) ] { return nil , Err Task Already Added } return nil , err } result Task : = * task result Task . Method = task . method ( ) if task . Name = = " " { result Task . Name = string ( res . Chosen Task Name ) } return & result Task , nil } 
func Add Multi ( c context . Context , tasks [ ] * Task , queue Name string ) ( [ ] * Task , error ) { req : = & pb . Task Queue Bulk Add Request { Add Request : make ( [ ] * pb . Task Queue Add Request , len ( tasks ) ) , } me , any : = make ( appengine . Multi Error , len ( tasks ) ) , false for i , t : = range tasks { req . Add Request [ i ] , me [ i ] = new Add Req ( c , t , queue Name ) any = any | | me [ i ] ! = nil } if any { return nil , me } res : = & pb . Task Queue Bulk Add Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } if len ( res . Taskresult ) ! = len ( tasks ) { return nil , errors . New ( " " ) } tasks Out : = make ( [ ] * Task , len ( tasks ) ) for i , tr : = range res . Taskresult { tasks Out [ i ] = new ( Task ) * tasks Out [ i ] = * tasks [ i ] tasks Out [ i ] . Method = tasks Out [ i ] . method ( ) if tasks Out [ i ] . Name = = " " { tasks Out [ i ] . Name = string ( tr . Chosen Task Name ) } if * tr . Result ! = pb . Task Queue Service Error _OK { if already Added Errors [ * tr . Result ] { me [ i ] = Err Task Already Added } else { me [ i ] = & internal . APIError { Service : " " , Code : int 3 2 ( * tr . Result ) , } } any = true } } if any { return tasks Out , me } return tasks Out , nil } 
func Delete ( c context . Context , task * Task , queue Name string ) error { err : = Delete Multi ( c , [ ] * Task { task } , queue Name ) if me , ok : = err . ( appengine . Multi Error ) ; ok { return me [ 0 ] } return err } 
func Delete Multi ( c context . Context , tasks [ ] * Task , queue Name string ) error { task Names : = make ( [ ] [ ] byte , len ( tasks ) ) for i , t : = range tasks { task Names [ i ] = [ ] byte ( t . Name ) } if queue Name = = " " { queue Name = " " } req : = & pb . Task Queue Delete Request { Queue Name : [ ] byte ( queue Name ) , Task Name : task Names , } res : = & pb . Task Queue Delete Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if a , b : = len ( req . Task Name ) , len ( res . Result ) ; a ! = b { return fmt . Errorf ( " " , a , b ) } me , any : = make ( appengine . Multi Error , len ( res . Result ) ) , false for i , ec : = range res . Result { if ec ! = pb . Task Queue Service Error _OK { me [ i ] = & internal . APIError { Service : " " , Code : int 3 2 ( ec ) , } any = true } } if any { return me } return nil } 
func Lease ( c context . Context , max Tasks int , queue Name string , lease Time int ) ( [ ] * Task , error ) { return lease ( c , max Tasks , queue Name , lease Time , false , nil ) } 
func Lease By Tag ( c context . Context , max Tasks int , queue Name string , lease Time int , tag string ) ( [ ] * Task , error ) { return lease ( c , max Tasks , queue Name , lease Time , true , [ ] byte ( tag ) ) } 
func Purge ( c context . Context , queue Name string ) error { if queue Name = = " " { queue Name = " " } req : = & pb . Task Queue Purge Queue Request { Queue Name : [ ] byte ( queue Name ) , } res : = & pb . Task Queue Purge Queue Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Modify Lease ( c context . Context , task * Task , queue Name string , lease Time int ) error { if queue Name = = " " { queue Name = " " } req : = & pb . Task Queue Modify Task Lease Request { Queue Name : [ ] byte ( queue Name ) , Task Name : [ ] byte ( task . Name ) , Eta Usec : proto . Int 6 4 ( task . ETA . Unix Nano ( ) / 1e 3 ) , res : = & pb . Task Queue Modify Task Lease Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } task . ETA = time . Unix ( 0 , * res . Updated Eta Usec * 1e 3 ) return nil } 
func Queue Stats ( c context . Context , queue Names [ ] string ) ( [ ] Queue Statistics , error ) { req : = & pb . Task Queue Fetch Queue Stats Request { Queue Name : make ( [ ] [ ] byte , len ( queue Names ) ) , } for i , q : = range queue Names { if q = = " " { q = " " } req . Queue Name [ i ] = [ ] byte ( q ) } res : = & pb . Task Queue Fetch Queue Stats Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } qs : = make ( [ ] Queue Statistics , len ( res . Queuestats ) ) for i , qsg : = range res . Queuestats { qs [ i ] = Queue Statistics { Tasks : int ( * qsg . Num Tasks ) , } if eta : = * qsg . Oldest Eta Usec ; eta > - 1 { qs [ i ] . Oldest ETA = time . Unix ( 0 , eta * 1e 3 ) } if si : = qsg . Scanner Info ; si ! = nil { qs [ i ] . Executed 1Minute = int ( * si . Executed Last Minute ) qs [ i ] . In Flight = int ( si . Get Requests In Flight ( ) ) qs [ i ] . Enforced Rate = si . Get Enforced Rate ( ) } } return qs , nil } 
func Is Timeout Error ( err error ) bool { if err = = context . Deadline Exceeded { return true } if t , ok : = err . ( interface { Is Timeout ( ) bool } ) ; ok { return t . Is Timeout ( ) } return false } 
func file Key ( file string ) ( string , error ) { if ! internal . Is Second Gen ( ) | | internal . Main Path = = " " { return file , nil } } for _ , s : = range [ ] string { filepath . Join ( " " , " " ) + s , s + " " + s , filepath . Join ( build . Default . GOPATH , " " ) + s } { if idx : = strings . Index ( file , s ) ; idx > 0 { return file [ idx + len ( s ) : ] , nil } } if idx : = strings . Index ( file , m ) ; idx > 0 { file = file [ idx + len ( m ) : ] } else { return file , fmt . Errorf ( " " , file ) } return mod Version Pat . Replace All String ( file , " " ) , nil } 
func Func ( key string , i interface { } ) * Function { f : = & Function { fv : reflect . Value Of ( i ) } fk , err : = file Key ( file ) if err ! = nil { } f . key = fk + " " + key t : = f . fv . Type ( ) if t . Kind ( ) ! = reflect . Func { f . err = errors . New ( " " ) return f } if t . Num In ( ) = = 0 | | ! is Context ( t . In ( 0 ) ) { f . err = err First Arg return f } } gob . Register ( reflect . Zero ( t . In ( i ) ) . Interface ( ) ) } if old : = funcs [ f . key ] ; old ! = nil { old . err = fmt . Errorf ( " " , key , file ) } funcs [ f . key ] = f return f } 
func ( f * Function ) Task ( args . . . interface { } ) ( * taskqueue . Task , error ) { if f . err ! = nil { return nil , fmt . Errorf ( " " , f . err ) } n Args : = len ( args ) + 1 ft : = f . fv . Type ( ) min Args : = ft . Num In ( ) if ft . Is Variadic ( ) { min Args - - } if n Args < min Args { return nil , fmt . Errorf ( " " , n Args , min Args ) } if ! ft . Is Variadic ( ) & & n Args > min Args { return nil , fmt . Errorf ( " " , n Args , min Args ) } var dt reflect . Type if i < min Args { } else { } } return nil , fmt . Errorf ( " " , i , dt ) } switch at . Kind ( ) { case reflect . Chan , reflect . Func , reflect . Interface , reflect . Map , reflect . Ptr , reflect . Slice : av : = reflect . Value Of ( args [ i - 1 ] ) if av . Is Nil ( ) { } } if ! at . Assignable To ( dt ) { return nil , fmt . Errorf ( " " , i , at , dt ) } } inv : = invocation { Key : f . key , Args : args , } buf : = new ( bytes . Buffer ) if err : = gob . New Encoder ( buf ) . Encode ( inv ) ; err ! = nil { return nil , fmt . Errorf ( " " , err ) } return & taskqueue . Task { Path : path , Payload : buf . Bytes ( ) , } , nil } 
func Request Headers ( c context . Context ) ( * taskqueue . Request Headers , error ) { if ret , ok : = c . Value ( headers Context Key ) . ( * taskqueue . Request Headers ) ; ok { return ret , nil } return nil , err Outside Delay Func } 
func With Context ( parent context . Context , req * http . Request ) context . Context { return internal . With Context ( parent , req ) } 
func ( g Geo Point ) Valid ( ) bool { return - 9 0 < = g . Lat & & g . Lat < = 9 0 & & - 1 8 0 < = g . Lng & & g . Lng < = 1 8 0 } 
func With APICall Func ( ctx context . Context , f APICall Func ) context . Context { return internal . With Call Override ( ctx , internal . Call Override Func ( f ) ) } 
func APICall ( ctx context . Context , service , method string , in , out proto . Message ) error { return internal . Call ( ctx , service , method , in , out ) } 
func Module Hostname ( c context . Context , module , version , instance string ) ( string , error ) { req : = & modpb . Get Hostname Request { } if module ! = " " { req . Module = & module } if version ! = " " { req . Version = & version } if instance ! = " " { req . Instance = & instance } res : = & modpb . Get Hostname Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return * res . Hostname , nil } 
func Access Token ( c context . Context , scopes . . . string ) ( token string , expiry time . Time , err error ) { req : = & pb . Get Access Token Request { Scope : scopes } res : = & pb . Get Access Token Response { } err = internal . Call ( c , " " , " " , req , res ) if err ! = nil { return " " , time . Time { } , err } return res . Get Access Token ( ) , time . Unix ( res . Get Expiration Time ( ) , 0 ) , nil } 
func Public Certificates ( c context . Context ) ( [ ] Certificate , error ) { req : = & pb . Get Public Certificate For App Request { } res : = & pb . Get Public Certificate For App Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } var cs [ ] Certificate for _ , pc : = range res . Public Certificate List { cs = append ( cs , Certificate { Key Name : pc . Get Key Name ( ) , Data : [ ] byte ( pc . Get X 5 0 9Certificate Pem ( ) ) , } ) } return cs , nil } 
func Service Account ( c context . Context ) ( string , error ) { req : = & pb . Get Service Account Name Request { } res : = & pb . Get Service Account Name Response { } err : = internal . Call ( c , " " , " " , req , res ) if err ! = nil { return " " , err } return res . Get Service Account Name ( ) , err } 
func Sign Bytes ( c context . Context , bytes [ ] byte ) ( key Name string , signature [ ] byte , err error ) { req : = & pb . Sign For App Request { Bytes To Sign : bytes } res : = & pb . Sign For App Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , nil , err } return res . Get Key Name ( ) , res . Get Signature Bytes ( ) , nil } 
func ( r * reader ) fetch ( off int 6 4 ) error { req : = & blobpb . Fetch Data Request { Blob Key : proto . String ( string ( r . blob Key ) ) , Start Index : proto . Int 6 4 ( off ) , End Index : proto . Int 6 4 ( off + read Buffer Size - 1 ) , res : = & blobpb . Fetch Data Response { } if err : = internal . Call ( r . c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . Data ) = = 0 { return io . EOF } r . buf , r . r , r . off = res . Data , 0 , off return nil } 
func ( r * reader ) seek ( off int 6 4 ) ( int 6 4 , error ) { delta : = off - r . off if delta > = 0 & & delta < int 6 4 ( len ( r . buf ) ) { r . r = int ( delta ) return off , nil } r . buf , r . r , r . off = nil , 0 , off return off , nil } 
func key To Proto ( default App ID string , k * Key ) * pb . Reference { app ID : = k . app ID if app ID = = " " { app ID = default App ID } n : = 0 for i : = k ; i ! = nil ; i = i . parent { n + + } e : = make ( [ ] * pb . Path _Element , n ) for i : = k ; i ! = nil ; i = i . parent { n - - e [ n ] = & pb . Path _Element { Type : & i . kind , } } else if i . int ID ! = 0 { e [ n ] . Id = & i . int ID } } var namespace * string if k . namespace ! = " " { namespace = proto . String ( k . namespace ) } return & pb . Reference { App : proto . String ( app ID ) , Name Space : namespace , Path : & pb . Path { Element : e , } , } } 
func multi Key To Proto ( app ID string , key [ ] * Key ) [ ] * pb . Reference { ret : = make ( [ ] * pb . Reference , len ( key ) ) for i , k : = range key { ret [ i ] = key To Proto ( app ID , k ) } return ret } 
func multi Valid ( key [ ] * Key ) error { invalid : = false for _ , k : = range key { if ! k . valid ( ) { invalid = true break } } if ! invalid { return nil } err : = make ( appengine . Multi Error , len ( key ) ) for i , k : = range key { if ! k . valid ( ) { err [ i ] = Err Invalid Key } } return err } 
func reference Value To Key ( r * pb . Property Value _Reference Value ) ( k * Key , err error ) { app ID : = r . Get App ( ) namespace : = r . Get Name Space ( ) for _ , e : = range r . Pathelement { k = & Key { kind : e . Get Type ( ) , string ID : e . Get Name ( ) , int ID : e . Get Id ( ) , parent : k , app ID : app ID , namespace : namespace , } if ! k . valid ( ) { return nil , Err Invalid Key } } return } 
func key To Reference Value ( default App ID string , k * Key ) * pb . Property Value _Reference Value { ref : = key To Proto ( default App ID , k ) pe : = make ( [ ] * pb . Property Value _Reference Value _Path Element , len ( ref . Path . Element ) ) for i , e : = range ref . Path . Element { pe [ i ] = & pb . Property Value _Reference Value _Path Element { Type : e . Type , Id : e . Id , Name : e . Name , } } return & pb . Property Value _Reference Value { App : ref . App , Name Space : ref . Name Space , Pathelement : pe , } } 
func check Multi Arg ( v reflect . Value ) ( m multi Arg Type , elem Type reflect . Type ) { if v . Kind ( ) ! = reflect . Slice { return multi Arg Type Invalid , nil } if v . Type ( ) = = type Of Property List { return multi Arg Type Invalid , nil } elem Type = v . Type ( ) . Elem ( ) if reflect . Ptr To ( elem Type ) . Implements ( type Of Property Load Saver ) { return multi Arg Type Property Load Saver , elem Type } switch elem Type . Kind ( ) { case reflect . Struct : return multi Arg Type Struct , elem Type case reflect . Interface : return multi Arg Type Interface , elem Type case reflect . Ptr : elem Type = elem Type . Elem ( ) if elem Type . Kind ( ) = = reflect . Struct { return multi Arg Type Struct Ptr , elem Type } } return multi Arg Type Invalid , nil } 
func Get Multi ( c context . Context , key [ ] * Key , dst interface { } ) error { v : = reflect . Value Of ( dst ) multi Arg Type , _ : = check Multi Arg ( v ) if multi Arg Type = = multi Arg Type Invalid { return errors . New ( " " ) } if len ( key ) ! = v . Len ( ) { return errors . New ( " " ) } if len ( key ) = = 0 { return nil } if err : = multi Valid ( key ) ; err ! = nil { return err } req : = & pb . Get Request { Key : multi Key To Proto ( internal . Fully Qualified App ID ( c ) , key ) , } res : = & pb . Get Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( key ) ! = len ( res . Entity ) { return errors . New ( " " ) } multi Err , any : = make ( appengine . Multi Error , len ( key ) ) , false for i , e : = range res . Entity { if e . Entity = = nil { multi Err [ i ] = Err No Such Entity } else { elem : = v . Index ( i ) if multi Arg Type = = multi Arg Type Property Load Saver | | multi Arg Type = = multi Arg Type Struct { elem = elem . Addr ( ) } if multi Arg Type = = multi Arg Type Struct Ptr & & elem . Is Nil ( ) { elem . Set ( reflect . New ( elem . Type ( ) . Elem ( ) ) ) } multi Err [ i ] = load Entity ( elem . Interface ( ) , e . Entity ) } if multi Err [ i ] ! = nil { any = true } } if any { return multi Err } return nil } 
func Put ( c context . Context , key * Key , src interface { } ) ( * Key , error ) { k , err : = Put Multi ( c , [ ] * Key { key } , [ ] interface { } { src } ) if err ! = nil { if me , ok : = err . ( appengine . Multi Error ) ; ok { return nil , me [ 0 ] } return nil , err } return k [ 0 ] , nil } 
func Put Multi ( c context . Context , key [ ] * Key , src interface { } ) ( [ ] * Key , error ) { v : = reflect . Value Of ( src ) multi Arg Type , _ : = check Multi Arg ( v ) if multi Arg Type = = multi Arg Type Invalid { return nil , errors . New ( " " ) } if len ( key ) ! = v . Len ( ) { return nil , errors . New ( " " ) } if len ( key ) = = 0 { return nil , nil } app ID : = internal . Fully Qualified App ID ( c ) if err : = multi Valid ( key ) ; err ! = nil { return nil , err } req : = & pb . Put Request { } for i : = range key { elem : = v . Index ( i ) if multi Arg Type = = multi Arg Type Property Load Saver | | multi Arg Type = = multi Arg Type Struct { elem = elem . Addr ( ) } s Proto , err : = save Entity ( app ID , key [ i ] , elem . Interface ( ) ) if err ! = nil { return nil , err } req . Entity = append ( req . Entity , s Proto ) } res : = & pb . Put Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } if len ( key ) ! = len ( res . Key ) { return nil , errors . New ( " " ) } ret : = make ( [ ] * Key , len ( key ) ) for i : = range ret { var err error ret [ i ] , err = proto To Key ( res . Key [ i ] ) if err ! = nil | | ret [ i ] . Incomplete ( ) { return nil , errors . New ( " " ) } } return ret , nil } 
func Delete ( c context . Context , key * Key ) error { err : = Delete Multi ( c , [ ] * Key { key } ) if me , ok : = err . ( appengine . Multi Error ) ; ok { return me [ 0 ] } return err } 
func Delete Multi ( c context . Context , key [ ] * Key ) error { if len ( key ) = = 0 { return nil } if err : = multi Valid ( key ) ; err ! = nil { return err } req : = & pb . Delete Request { Key : multi Key To Proto ( internal . Fully Qualified App ID ( c ) , key ) , } res : = & pb . Delete Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Client ( ctx context . Context ) * http . Client { return & http . Client { Transport : & Transport { Context : ctx , } , } } 
func url String ( u * url . URL ) string { if u . Opaque = = " " | | strings . Has Prefix ( u . Opaque , " " ) { return u . String ( ) } aux : = * u aux . Opaque = " " + aux . Host + aux . Opaque return aux . String ( ) } 
func ( t * Transport ) Round Trip ( req * http . Request ) ( res * http . Response , err error ) { meth Num , ok : = pb . URLFetch Request _Request Method _value [ req . Method ] if ! ok { return nil , fmt . Errorf ( " " , req . Method ) } method : = pb . URLFetch Request _Request Method ( meth Num ) freq : = & pb . URLFetch Request { Method : & method , Url : proto . String ( url String ( req . URL ) ) , Follow Redirects : proto . Bool ( false ) , if deadline , ok : = t . Context . Deadline ( ) ; ok { freq . Deadline = proto . Float 6 4 ( deadline . Sub ( time . Now ( ) ) . Seconds ( ) ) } for k , vals : = range req . Header { for _ , val : = range vals { freq . Header = append ( freq . Header , & pb . URLFetch Request _Header { Key : proto . String ( k ) , Value : proto . String ( val ) , } ) } } if method Accepts Request Body [ req . Method ] & & req . Body ! = nil { } : freq . Payload = b . Bytes ( ) default : freq . Payload , err = ioutil . Read All ( req . Body ) if err ! = nil { return nil , err } } } fres : = & pb . URLFetch Response { } if err : = internal . Call ( t . Context , " " , " " , freq , fres ) ; err ! = nil { return nil , err } res = & http . Response { } res . Status Code = int ( * fres . Status Code ) res . Status = fmt . Sprintf ( " " , res . Status Code , status Code To Text ( res . Status Code ) ) res . Header = make ( http . Header ) res . Request = req res . Proto Minor = 1 res . Proto = " " res . Close = true for _ , h : = range fres . Header { hkey : = http . Canonical Header Key ( * h . Key ) hval : = * h . Value if hkey = = " " { } continue } res . Header . Add ( hkey , hval ) } if req . Method ! = " " { res . Content Length = int 6 4 ( len ( fres . Content ) ) } truncated : = fres . Get Content Was Truncated ( ) res . Body = & body Reader { content : fres . Content , truncated : truncated } return } 
func deploy ( ) error { vlogf ( " " , flag . Args ( ) ) cmd : = exec . Command ( flag . Arg ( 0 ) , flag . Args ( ) [ 1 : ] . . . ) cmd . Stdin , cmd . Stdout , cmd . Stderr = os . Stdin , os . Stdout , os . Stderr if err : = cmd . Run ( ) ; err ! = nil { return fmt . Errorf ( " " , strings . Join ( flag . Args ( ) , " " ) , err ) } return nil } 
func ( qr * Result ) Next ( ) ( * Record , error ) { if qr . err ! = nil { return nil , qr . err } if len ( qr . logs ) > 0 { lr : = qr . logs [ 0 ] qr . logs = qr . logs [ 1 : ] return lr , nil } if qr . request . Offset = = nil & & qr . results Seen { return nil , Done } if err : = qr . run ( ) ; err ! = nil { } return qr . Next ( ) } 
func proto To App Logs ( log Lines [ ] * pb . Log Line ) [ ] App Log { app Logs : = make ( [ ] App Log , len ( log Lines ) ) for i , line : = range log Lines { app Logs [ i ] = App Log { Time : time . Unix ( 0 , * line . Time * 1e 3 ) , Level : int ( * line . Level ) , Message : * line . Log Message , } } return app Logs } 
func proto To Record ( rl * pb . Request Log ) * Record { offset , err : = proto . Marshal ( rl . Offset ) if err ! = nil { offset = nil } return & Record { App ID : * rl . App Id , Module ID : rl . Get Module Id ( ) , Version ID : * rl . Version Id , Request ID : rl . Request Id , Offset : offset , IP : * rl . Ip , Nickname : rl . Get Nickname ( ) , App Engine Release : string ( rl . Get App Engine Release ( ) ) , Start Time : time . Unix ( 0 , * rl . Start Time * 1e 3 ) , End Time : time . Unix ( 0 , * rl . End Time * 1e 3 ) , Latency : time . Duration ( * rl . Latency ) * time . Microsecond , MCycles : * rl . Mcycles , Method : * rl . Method , Resource : * rl . Resource , HTTPVersion : * rl . Http Version , Status : * rl . Status , Response Size : * rl . Response Size , Referrer : rl . Get Referrer ( ) , User Agent : rl . Get User Agent ( ) , URLMap Entry : * rl . Url Map Entry , Combined : * rl . Combined , Host : rl . Get Host ( ) , Cost : rl . Get Cost ( ) , Task Queue Name : rl . Get Task Queue Name ( ) , Task Name : rl . Get Task Name ( ) , Was Loading Request : rl . Get Was Loading Request ( ) , Pending Time : time . Duration ( rl . Get Pending Time ( ) ) * time . Microsecond , Finished : rl . Get Finished ( ) , App Logs : proto To App Logs ( rl . Line ) , Instance ID : string ( rl . Get Clone Key ( ) ) , } } 
func ( params * Query ) Run ( c context . Context ) * Result { req , err : = make Request ( params , internal . Fully Qualified App ID ( c ) , appengine . Version ID ( c ) ) return & Result { context : c , request : req , err : err , } } 
func ( r * Result ) run ( ) error { res : = & pb . Log Read Response { } if err : = internal . Call ( r . context , " " , " " , r . request , res ) ; err ! = nil { return err } r . logs = make ( [ ] * Record , len ( res . Log ) ) r . request . Offset = res . Offset r . results Seen = true for i , log : = range res . Log { r . logs [ i ] = proto To Record ( log ) } return nil } 
func Current ( c context . Context ) * User { h : = internal . Incoming Headers ( c ) u : = & User { Email : h . Get ( " " ) , Auth Domain : h . Get ( " " ) , ID : h . Get ( " " ) , Admin : h . Get ( " " ) = = " " , Federated Identity : h . Get ( " " ) , Federated Provider : h . Get ( " " ) , } if u . Email = = " " & & u . Federated Identity = = " " { return nil } return u } 
func Is Admin ( c context . Context ) bool { h : = internal . Incoming Headers ( c ) return h . Get ( " " ) = = " " } 
func is Err Field Mismatch ( err error ) bool { _ , ok : = err . ( * datastore . Err Field Mismatch ) return ok } 
func Stat ( c context . Context , blob Key appengine . Blob Key ) ( * Blob Info , error ) { c , _ = appengine . Namespace ( c , " " ) dskey : = datastore . New Key ( c , blob Info Kind , string ( blob Key ) , 0 , nil ) bi : = & Blob Info { Blob Key : blob Key , } if err : = datastore . Get ( c , dskey , bi ) ; err ! = nil & & ! is Err Field Mismatch ( err ) { return nil , err } return bi , nil } 
func Send ( response http . Response Writer , blob Key appengine . Blob Key ) { hdr : = response . Header ( ) hdr . Set ( " " , string ( blob Key ) ) if hdr . Get ( " " ) = = " " { } } 
func Upload URL ( c context . Context , success Path string , opts * Upload URLOptions ) ( * url . URL , error ) { req : = & blobpb . Create Upload URLRequest { Success Path : proto . String ( success Path ) , } if opts ! = nil { if n : = opts . Max Upload Bytes ; n ! = 0 { req . Max Upload Size Bytes = & n } if n : = opts . Max Upload Bytes Per Blob ; n ! = 0 { req . Max Upload Size Per Blob Bytes = & n } if s : = opts . Storage Bucket ; s ! = " " { req . Gs Bucket Name = & s } } res : = & blobpb . Create Upload URLResponse { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } return url . Parse ( * res . Url ) } 
func Delete ( c context . Context , blob Key appengine . Blob Key ) error { return Delete Multi ( c , [ ] appengine . Blob Key { blob Key } ) } 
func Delete Multi ( c context . Context , blob Key [ ] appengine . Blob Key ) error { s : = make ( [ ] string , len ( blob Key ) ) for i , b : = range blob Key { s [ i ] = string ( b ) } req : = & blobpb . Delete Blob Request { Blob Key : s , } res : = & basepb . Void Proto { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } return nil } 
func Parse Upload ( req * http . Request ) ( blobs map [ string ] [ ] * Blob Info , other url . Values , err error ) { _ , params , err : = mime . Parse Media Type ( req . Header . Get ( " " ) ) if err ! = nil { return nil , nil , err } boundary : = params [ " " ] if boundary = = " " { return nil , nil , errorf ( " " ) } blobs = make ( map [ string ] [ ] * Blob Info ) other = make ( url . Values ) mreader : = multipart . New Reader ( io . Multi Reader ( req . Body , strings . New Reader ( " \r \n \r \n " ) ) , boundary ) for { part , perr : = mreader . Next Part ( ) if perr = = io . EOF { break } if perr ! = nil { return nil , nil , errorf ( " " , boundary , len ( boundary ) , perr ) } bi : = & Blob Info { } ctype , params , err : = mime . Parse Media Type ( part . Header . Get ( " " ) ) if err ! = nil { return nil , nil , err } bi . Filename = params [ " " ] form Key : = params [ " " ] ctype , params , err = mime . Parse Media Type ( part . Header . Get ( " " ) ) if err ! = nil { return nil , nil , err } bi . Blob Key = appengine . Blob Key ( params [ " " ] ) charset : = params [ " " ] if ctype ! = " " | | bi . Blob Key = = " " { if form Key ! = " " { slurp , serr : = ioutil . Read All ( part ) if serr ! = nil { return nil , nil , errorf ( " " , form Key ) } if err = = nil & & ctype = = " " { slurp , serr = ioutil . Read All ( base 6 4 . New Decoder ( base 6 4 . Std Encoding , bytes . New Reader ( slurp ) ) ) if serr ! = nil { return nil , nil , errorf ( " " , ctype , form Key ) } } if err ! = nil { return nil , nil , errorf ( " " , charset ) } slurp , err = encoding . New Decoder ( ) . Bytes ( slurp ) if err ! = nil { return nil , nil , errorf ( " " , charset ) } } other [ form Key ] = append ( other [ form Key ] , string ( slurp ) ) } continue } header , mimeerr : = tp . Read MIMEHeader ( ) if mimeerr ! = nil { return nil , nil , mimeerr } bi . Size , err = strconv . Parse Int ( header . Get ( " " ) , 1 0 , 6 4 ) if err ! = nil { return nil , nil , err } bi . Content Type = header . Get ( " " ) if create Date = = " " { return nil , nil , errorf ( " " ) } bi . Creation Time , err = time . Parse ( " " , create Date ) if err ! = nil { return nil , nil , errorf ( " " , err ) } if hdr : = header . Get ( " " ) ; hdr ! = " " { md 5 , err : = base 6 4 . URLEncoding . Decode String ( hdr ) if err ! = nil { return nil , nil , errorf ( " " , hdr , err ) } bi . MD 5 = string ( md 5 ) } blobs [ form Key ] = append ( blobs [ form Key ] , bi ) } return } 
func New Reader ( c context . Context , blob Key appengine . Blob Key ) Reader { return open Blob ( c , blob Key ) } 
func Blob Key For File ( c context . Context , filename string ) ( appengine . Blob Key , error ) { req : = & blobpb . Create Encoded Google Storage Key Request { Filename : & filename , } res : = & blobpb . Create Encoded Google Storage Key Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } return appengine . Blob Key ( * res . Blob Key ) , nil } 
func Handle ( f func ( c context . Context , m * Message ) ) { http . Handle Func ( " " , func ( _ http . Response Writer , r * http . Request ) { f ( appengine . New Context ( r ) , & Message { Sender : r . Form Value ( " " ) , To : [ ] string { r . Form Value ( " " ) } , Body : r . Form Value ( " " ) , } ) } ) } 
func ( m * Message ) Send ( c context . Context ) error { req : = & pb . Xmpp Message Request { Jid : m . To , Body : & m . Body , Raw Xml : & m . Raw XML , } if m . Type ! = " " & & m . Type ! = " " { req . Type = & m . Type } if m . Sender ! = " " { req . From Jid = & m . Sender } res : = & pb . Xmpp Message Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . Status ) ! = len ( req . Jid ) { return fmt . Errorf ( " " , len ( req . Jid ) , len ( res . Status ) ) } me , any : = make ( appengine . Multi Error , len ( req . Jid ) ) , false for i , st : = range res . Status { if st ! = pb . Xmpp Message Response _NO _ERROR { me [ i ] = errors . New ( st . String ( ) ) any = true } } if any { return me } return nil } 
func Invite ( c context . Context , to , from string ) error { req : = & pb . Xmpp Invite Request { Jid : & to , } if from ! = " " { req . From Jid = & from } res : = & pb . Xmpp Invite Response { } return internal . Call ( c , " " , " " , req , res ) } 
func ( p * Presence ) Send ( c context . Context ) error { req : = & pb . Xmpp Send Presence Request { Jid : & p . To , } if p . State ! = " " { req . Show = & p . State } if p . Type ! = " " { req . Type = & p . Type } if p . Sender ! = " " { req . From Jid = & p . Sender } if p . Status ! = " " { req . Status = & p . Status } res : = & pb . Xmpp Send Presence Response { } return internal . Call ( c , " " , " " , req , res ) } 
func Get Presence ( c context . Context , to string , from string ) ( string , error ) { req : = & pb . Presence Request { Jid : & to , } if from ! = " " { req . From Jid = & from } res : = & pb . Presence Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return " " , err } if ! * res . Is Available | | res . Presence = = nil { return " " , Err Presence Unavailable } presence , ok : = presence Map [ * res . Presence ] if ok { return presence , nil } return " " , fmt . Errorf ( " " , * res . Presence ) } 
func Get Presence Multi ( c context . Context , to [ ] string , from string ) ( [ ] string , error ) { req : = & pb . Bulk Presence Request { Jid : to , } if from ! = " " { req . From Jid = & from } res : = & pb . Bulk Presence Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } presences : = make ( [ ] string , 0 , len ( res . Presence Response ) ) errs : = appengine . Multi Error { } add Result : = func ( presence string , err error ) { presences = append ( presences , presence ) errs = append ( errs , err ) } any Err : = false for _ , subres : = range res . Presence Response { if ! subres . Get Valid ( ) { any Err = true add Result ( " " , Err Invalid JID ) continue } if ! * subres . Is Available | | subres . Presence = = nil { any Err = true add Result ( " " , Err Presence Unavailable ) continue } presence , ok : = presence Map [ * subres . Presence ] if ok { add Result ( presence , nil ) } else { any Err = true add Result ( " " , fmt . Errorf ( " " , * subres . Presence ) ) } } if any Err { return presences , errs } return presences , nil } 
func Dial ( ctx context . Context , protocol , addr string ) ( * Conn , error ) { conn , err : = net . Dial ( protocol , addr ) if err ! = nil { return nil , err } return & Conn { conn } , nil } 
func Dial Timeout ( ctx context . Context , protocol , addr string , timeout time . Duration ) ( * Conn , error ) { conn , err : = net . Dial Timeout ( protocol , addr , timeout ) if err ! = nil { return nil , err } return & Conn { conn } , nil } 
func Lookup IP ( ctx context . Context , host string ) ( addrs [ ] net . IP , err error ) { return net . Lookup IP ( host ) } 
func new Struct FLS ( p interface { } ) ( Field Load Saver , error ) { v : = reflect . Value Of ( p ) if v . Kind ( ) ! = reflect . Ptr | | v . Is Nil ( ) | | v . Elem ( ) . Kind ( ) ! = reflect . Struct { return nil , Err Invalid Document Type } codec , err : = load Codec ( v . Elem ( ) . Type ( ) ) if err ! = nil { return nil , err } return struct FLS { v . Elem ( ) , codec } , nil } 
func Save Struct ( src interface { } ) ( [ ] Field , error ) { f , _ , err : = save Struct With Meta ( src ) return f , err } 
func Namespaces ( ctx context . Context ) ( [ ] string , error ) { keys , err : = q . Get All ( ctx , nil ) if err ! = nil { return nil , err } } 
func Kinds ( ctx context . Context ) ( [ ] string , error ) { keys , err : = q . Get All ( ctx , nil ) if err ! = nil { return nil , err } return key Names ( keys ) , nil } 
func key Names ( keys [ ] * Key ) [ ] string { n : = make ( [ ] string , 0 , len ( keys ) ) for _ , k : = range keys { n = append ( n , k . String ID ( ) ) } return n } 
func Kind Properties ( ctx context . Context , kind string ) ( map [ string ] [ ] string , error ) { q : = New Query ( property Kind ) . Ancestor ( kind Key ) prop Map : = map [ string ] [ ] string { } props : = [ ] struct { Repr [ ] string `datastore : "property _representation " ` } { } keys , err : = q . Get All ( ctx , & props ) if err ! = nil { return nil , err } for i , p : = range props { prop Map [ keys [ i ] . String ID ( ) ] = p . Repr } return prop Map , nil } 
func must Get Metadata ( key string ) [ ] byte { b , err : = get Metadata ( key ) if err ! = nil { panic ( fmt . Sprintf ( " " , key , err ) ) } return b } 
func Run In Transaction ( c context . Context , f func ( tc context . Context ) error , opts * Transaction Options ) error { xg : = false if opts ! = nil { xg = opts . XG } read Only : = false if opts ! = nil { read Only = opts . Read Only } attempts : = 3 if opts ! = nil & & opts . Attempts > 0 { attempts = opts . Attempts } var t * pb . Transaction var err error for i : = 0 ; i < attempts ; i + + { if t , err = internal . Run Transaction Once ( c , f , xg , read Only , t ) ; err ! = internal . Err Concurrent Transaction { return err } } return Err Concurrent Transaction } 
func walk Before After ( x interface { } , before , after func ( interface { } ) ) { before ( x ) switch n : = x . ( type ) { default : panic ( fmt . Errorf ( " " , x ) ) case nil : case * ast . Expr : walk Before After ( * n , before , after ) case * ast . Spec : walk Before After ( * n , before , after ) case * ast . Stmt : walk Before After ( * n , before , after ) case * * ast . Call Expr : walk Before After ( * n , before , after ) case * * ast . Field List : walk Before After ( * n , before , after ) case * * ast . Func Type : walk Before After ( * n , before , after ) case * * ast . Ident : walk Before After ( * n , before , after ) case * * ast . Basic Lit : walk Before After ( * n , before , after ) case * [ ] ast . Expr : walk Before After ( * n , before , after ) case * [ ] * ast . File : walk Before After ( * n , before , after ) case * [ ] * ast . Ident : walk Before After ( * n , before , after ) case * [ ] ast . Spec : walk Before After ( * n , before , after ) case * [ ] ast . Stmt : walk Before After ( * n , before , after ) walk Before After ( & n . Type , before , after ) walk Before After ( & n . Tag , before , after ) case * ast . Field List : for _ , field : = range n . List { walk Before After ( field , before , after ) } case * ast . Bad Expr : case * ast . Ident : case * ast . Ellipsis : walk Before After ( & n . Elt , before , after ) case * ast . Basic Lit : case * ast . Func Lit : walk Before After ( & n . Type , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Composite Lit : walk Before After ( & n . Type , before , after ) walk Before After ( & n . Elts , before , after ) case * ast . Paren Expr : walk Before After ( & n . X , before , after ) case * ast . Selector Expr : walk Before After ( & n . X , before , after ) case * ast . Index Expr : walk Before After ( & n . X , before , after ) walk Before After ( & n . Index , before , after ) case * ast . Slice Expr : walk Before After ( & n . X , before , after ) if n . Low ! = nil { walk Before After ( & n . Low , before , after ) } if n . High ! = nil { walk Before After ( & n . High , before , after ) } case * ast . Type Assert Expr : walk Before After ( & n . X , before , after ) walk Before After ( & n . Type , before , after ) case * ast . Call Expr : walk Before After ( & n . Fun , before , after ) walk Before After ( & n . Args , before , after ) case * ast . Star Expr : walk Before After ( & n . X , before , after ) case * ast . Unary Expr : walk Before After ( & n . X , before , after ) case * ast . Binary Expr : walk Before After ( & n . X , before , after ) walk Before After ( & n . Y , before , after ) case * ast . Key Value Expr : walk Before After ( & n . Key , before , after ) walk Before After ( & n . Value , before , after ) case * ast . Array Type : walk Before After ( & n . Len , before , after ) walk Before After ( & n . Elt , before , after ) case * ast . Struct Type : walk Before After ( & n . Fields , before , after ) case * ast . Func Type : walk Before After ( & n . Params , before , after ) if n . Results ! = nil { walk Before After ( & n . Results , before , after ) } case * ast . Interface Type : walk Before After ( & n . Methods , before , after ) case * ast . Map Type : walk Before After ( & n . Key , before , after ) walk Before After ( & n . Value , before , after ) case * ast . Chan Type : walk Before After ( & n . Value , before , after ) case * ast . Bad Stmt : case * ast . Decl Stmt : walk Before After ( & n . Decl , before , after ) case * ast . Empty Stmt : case * ast . Labeled Stmt : walk Before After ( & n . Stmt , before , after ) case * ast . Expr Stmt : walk Before After ( & n . X , before , after ) case * ast . Send Stmt : walk Before After ( & n . Chan , before , after ) walk Before After ( & n . Value , before , after ) case * ast . Inc Dec Stmt : walk Before After ( & n . X , before , after ) case * ast . Assign Stmt : walk Before After ( & n . Lhs , before , after ) walk Before After ( & n . Rhs , before , after ) case * ast . Go Stmt : walk Before After ( & n . Call , before , after ) case * ast . Defer Stmt : walk Before After ( & n . Call , before , after ) case * ast . Return Stmt : walk Before After ( & n . Results , before , after ) case * ast . Branch Stmt : case * ast . Block Stmt : walk Before After ( & n . List , before , after ) case * ast . If Stmt : walk Before After ( & n . Init , before , after ) walk Before After ( & n . Cond , before , after ) walk Before After ( & n . Body , before , after ) walk Before After ( & n . Else , before , after ) case * ast . Case Clause : walk Before After ( & n . List , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Switch Stmt : walk Before After ( & n . Init , before , after ) walk Before After ( & n . Tag , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Type Switch Stmt : walk Before After ( & n . Init , before , after ) walk Before After ( & n . Assign , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Comm Clause : walk Before After ( & n . Comm , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Select Stmt : walk Before After ( & n . Body , before , after ) case * ast . For Stmt : walk Before After ( & n . Init , before , after ) walk Before After ( & n . Cond , before , after ) walk Before After ( & n . Post , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Range Stmt : walk Before After ( & n . Key , before , after ) walk Before After ( & n . Value , before , after ) walk Before After ( & n . X , before , after ) walk Before After ( & n . Body , before , after ) case * ast . Import Spec : case * ast . Value Spec : walk Before After ( & n . Type , before , after ) walk Before After ( & n . Values , before , after ) walk Before After ( & n . Names , before , after ) case * ast . Type Spec : walk Before After ( & n . Type , before , after ) case * ast . Bad Decl : case * ast . Gen Decl : walk Before After ( & n . Specs , before , after ) case * ast . Func Decl : if n . Recv ! = nil { walk Before After ( & n . Recv , before , after ) } walk Before After ( & n . Type , before , after ) if n . Body ! = nil { walk Before After ( & n . Body , before , after ) } case * ast . File : walk Before After ( & n . Decls , before , after ) case * ast . Package : walk Before After ( & n . Files , before , after ) case [ ] * ast . File : for i : = range n { walk Before After ( & n [ i ] , before , after ) } case [ ] ast . Decl : for i : = range n { walk Before After ( & n [ i ] , before , after ) } case [ ] ast . Expr : for i : = range n { walk Before After ( & n [ i ] , before , after ) } case [ ] * ast . Ident : for i : = range n { walk Before After ( & n [ i ] , before , after ) } case [ ] ast . Stmt : for i : = range n { walk Before After ( & n [ i ] , before , after ) } case [ ] ast . Spec : for i : = range n { walk Before After ( & n [ i ] , before , after ) } } after ( x ) } 
func imports ( f * ast . File , path string ) bool { return import Spec ( f , path ) ! = nil } 
func import Spec ( f * ast . File , path string ) * ast . Import Spec { for _ , s : = range f . Imports { if import Path ( s ) = = path { return s } } return nil } 
func decl Imports ( gen * ast . Gen Decl , path string ) bool { if gen . Tok ! = token . IMPORT { return false } for _ , spec : = range gen . Specs { impspec : = spec . ( * ast . Import Spec ) if import Path ( impspec ) = = path { return true } } return false } 
func is Pkg Dot ( t ast . Expr , pkg , name string ) bool { sel , ok : = t . ( * ast . Selector Expr ) return ok & & is Top Name ( sel . X , pkg ) & & sel . Sel . String ( ) = = name } 
func is Ptr Pkg Dot ( t ast . Expr , pkg , name string ) bool { ptr , ok : = t . ( * ast . Star Expr ) return ok & & is Pkg Dot ( ptr . X , pkg , name ) } 
func is Top Name ( n ast . Expr , name string ) bool { id , ok : = n . ( * ast . Ident ) return ok & & id . Name = = name & & id . Obj = = nil } 
func is Name ( n ast . Expr , name string ) bool { id , ok : = n . ( * ast . Ident ) return ok & & id . String ( ) = = name } 
func is Call ( t ast . Expr , pkg , name string ) bool { call , ok : = t . ( * ast . Call Expr ) return ok & & is Pkg Dot ( call . Fun , pkg , name ) } 
func is Ident ( n interface { } ) * ast . Ident { id , _ : = n . ( * ast . Ident ) return id } 
func refers To ( n ast . Node , x * ast . Ident ) bool { id , ok : = n . ( * ast . Ident ) } 
func is Empty String ( n ast . Expr ) bool { lit , ok : = n . ( * ast . Basic Lit ) return ok & & lit . Kind = = token . STRING & & len ( lit . Value ) = = 2 } 
func count Uses ( x * ast . Ident , scope [ ] ast . Stmt ) int { count : = 0 ff : = func ( n interface { } ) { if n , ok : = n . ( ast . Node ) ; ok & & refers To ( n , x ) { count + + } } for _ , n : = range scope { walk ( n , ff ) } return count } 
func rewrite Uses ( x * ast . Ident , f , fnot func ( token . Pos ) ast . Expr , scope [ ] ast . Stmt ) { var last F ast . Expr ff : = func ( n interface { } ) { ptr , ok : = n . ( * ast . Expr ) if ! ok { return } nn : = * ptr if ok & & not . Op = = token . NOT & & not . X = = last F { * ptr = fnot ( nn . Pos ( ) ) return } if refers To ( nn , x ) { last F = f ( nn . Pos ( ) ) * ptr = last F } } for _ , n : = range scope { walk ( n , ff ) } } 
func assigns To ( x * ast . Ident , scope [ ] ast . Stmt ) bool { assigned : = false ff : = func ( n interface { } ) { if assigned { return } switch n : = n . ( type ) { case * ast . Unary Expr : return } case * ast . Assign Stmt : for _ , l : = range n . Lhs { if refers To ( l , x ) { assigned = true return } } } } for _ , n : = range scope { if assigned { break } walk ( n , ff ) } return assigned } 
func new Pkg Dot ( pos token . Pos , pkg , name string ) ast . Expr { return & ast . Selector Expr { X : & ast . Ident { Name Pos : pos , Name : pkg , } , Sel : & ast . Ident { Name Pos : pos , Name : name , } , } } 
func rename Top ( f * ast . File , old , new string ) bool { var fixed bool fixed = true } } else { _ , this Name : = path . Split ( import Path ( s ) ) if this Name = = old { s . Name = ast . New Ident ( new ) fixed = true } } } d . Name . Obj . Name = new fixed = true } case * ast . Gen Decl : for _ , s : = range d . Specs { switch s : = s . ( type ) { case * ast . Type Spec : if s . Name . Name = = old { s . Name . Name = new s . Name . Obj . Name = new fixed = true } case * ast . Value Spec : for _ , n : = range s . Names { if n . Name = = old { n . Name = new n . Obj . Name = new fixed = true } } } } } } if ok & & is Top Name ( id , old ) { id . Name = new fixed = true } if ok & & id . Obj ! = nil & & id . Name = = old & & id . Obj . Name = = new { id . Name = id . Obj . Name fixed = true } } ) return fixed } 
func match Len ( x , y string ) int { i : = 0 for i < len ( x ) & & i < len ( y ) & & x [ i ] = = y [ i ] { i + + } return i } 
func delete Import ( f * ast . File , path string ) ( deleted bool ) { old Import : = import Spec ( f , path ) if ! ok | | gen . Tok ! = token . IMPORT { continue } for j , spec : = range gen . Specs { impspec : = spec . ( * ast . Import Spec ) if old Import ! = impspec { continue } copy ( gen . Specs [ j : ] , gen . Specs [ j + 1 : ] ) gen . Specs = gen . Specs [ : len ( gen . Specs ) - 1 ] f . Decls = f . Decls [ : len ( f . Decls ) - 1 ] } else if len ( gen . Specs ) = = 1 { gen . Lparen = token . No Pos } if j > 0 { } break } } f . Imports = f . Imports [ : len ( f . Imports ) - 1 ] break } } return } 
func rewrite Import ( f * ast . File , old Path , new Path string ) ( rewrote bool ) { for _ , imp : = range f . Imports { if import Path ( imp ) = = old Path { rewrote = true imp . Path . Value = strconv . Quote ( new Path ) } } return } 
func from Context ( ctx netcontext . Context ) * context { c , _ : = ctx . Value ( & context Key ) . ( * context ) return c } 
func Default Ticket ( ) string { default Ticket Once . Do ( func ( ) { if Is Dev App Server ( ) { default Ticket = " " + default Ticket Suffix return } app ID : = partitionless App ID ( ) esc App ID : = strings . Replace ( strings . Replace ( app ID , " " , " " , - 1 ) , " " , " " , - 1 ) maj Version : = Version ID ( nil ) if i : = strings . Index ( maj Version , " " ) ; i > 0 { maj Version = maj Version [ : i ] } default Ticket = fmt . Sprintf ( " " , esc App ID , Module Name ( nil ) , maj Version , Instance ID ( ) ) } ) return default Ticket } 
func ( c * context ) flush Log ( force bool ) ( flushed bool ) { c . pending Logs . Lock ( ) for ; n < len ( c . pending Logs . lines ) ; n + + { ll : = c . pending Logs . lines [ n ] if nb > rem { break } rem - = nb } lines : = c . pending Logs . lines [ : n ] c . pending Logs . lines = c . pending Logs . lines [ n : ] c . pending Logs . Unlock ( ) if len ( lines ) = = 0 & & ! force { } rescue Logs : = false defer func ( ) { if rescue Logs { c . pending Logs . Lock ( ) c . pending Logs . lines = append ( lines , c . pending Logs . lines . . . ) c . pending Logs . Unlock ( ) } } ( ) buf , err : = proto . Marshal ( & logpb . User App Log Group { Log Line : lines , } ) if err ! = nil { log . Printf ( " " , err ) rescue Logs = true return false } req : = & logpb . Flush Request { Logs : buf , } res : = & basepb . Void Proto { } c . pending Logs . Lock ( ) c . pending Logs . flushes + + c . pending Logs . Unlock ( ) if err : = Call ( to Context ( c ) , " " , " " , req , res ) ; err ! = nil { log . Printf ( " " , err ) rescue Logs = true return false } return true } 
func Dial ( ctx context . Context , protocol , addr string ) ( * Conn , error ) { return Dial Timeout ( ctx , protocol , addr , 0 ) } 
func Dial Timeout ( ctx context . Context , protocol , addr string , timeout time . Duration ) ( * Conn , error ) { dial Ctx : = ctx if timeout > 0 { var cancel context . Cancel Func dial Ctx , cancel = context . With Timeout ( ctx , timeout ) defer cancel ( ) } host , port Str , err : = net . Split Host Port ( addr ) if err ! = nil { return nil , err } port , err : = strconv . Atoi ( port Str ) if err ! = nil { return nil , fmt . Errorf ( " " , port Str , err ) } var prot pb . Create Socket Request _Socket Protocol switch protocol { case " " : prot = pb . Create Socket Request _TCP case " " : prot = pb . Create Socket Request _UDP default : return nil , fmt . Errorf ( " " , protocol ) } packed Addrs , resolved , err : = resolve ( dial Ctx , ip Families , host ) if err ! = nil { return nil , fmt . Errorf ( " " , host , err ) } if len ( packed Addrs ) = = 0 { return nil , fmt . Errorf ( " " , host ) } packed Addr : = packed Addrs [ 0 ] fam : = pb . Create Socket Request _IPv 4 if len ( packed Addr ) = = net . IPv 6len { fam = pb . Create Socket Request _IPv 6 } req : = & pb . Create Socket Request { Family : fam . Enum ( ) , Protocol : prot . Enum ( ) , Remote Ip : & pb . Address Port { Port : proto . Int 3 2 ( int 3 2 ( port ) ) , Packed Address : packed Addr , } , } if resolved { req . Remote Ip . Hostname Hint = & host } res : = & pb . Create Socket Reply { } if err : = internal . Call ( dial Ctx , " " , " " , req , res ) ; err ! = nil { return nil , err } return & Conn { ctx : ctx , desc : res . Get Socket Descriptor ( ) , prot : prot , local : res . Proxy External Ip , remote : req . Remote Ip , } , nil } 
func Lookup IP ( ctx context . Context , host string ) ( addrs [ ] net . IP , err error ) { packed Addrs , _ , err : = resolve ( ctx , ip Families , host ) if err ! = nil { return nil , fmt . Errorf ( " " , host , err ) } addrs = make ( [ ] net . IP , len ( packed Addrs ) ) for i , pa : = range packed Addrs { addrs [ i ] = net . IP ( pa ) } return addrs , nil } 
func with Deadline ( parent context . Context , deadline time . Time ) ( context . Context , context . Cancel Func ) { if deadline . Is Zero ( ) { return parent , func ( ) { } } return context . With Deadline ( parent , deadline ) } 
func ( cn * Conn ) Keep Alive ( ) error { req : = & pb . Get Socket Name Request { Socket Descriptor : & cn . desc , } res : = & pb . Get Socket Name Reply { } return internal . Call ( cn . ctx , " " , " " , req , res ) } 
func Register Transaction Setter ( f interface { } ) { v : = reflect . Value Of ( f ) transaction Setters [ v . Type ( ) . In ( 0 ) ] = v } 
func apply Transaction ( pb proto . Message , t * pb . Transaction ) { v : = reflect . Value Of ( pb ) if f , ok : = transaction Setters [ v . Type ( ) ] ; ok { f . Call ( [ ] reflect . Value { v , reflect . Value Of ( t ) } ) } } 
func analyze ( tags [ ] string ) ( * app , error ) { ctxt : = build Context ( tags ) has Main , app Files , err : = check Main ( ctxt ) if err ! = nil { return nil , err } gopath : = filepath . Split List ( ctxt . GOPATH ) im , err : = imports ( ctxt , * root Dir , gopath ) return & app { has Main : has Main , app Files : app Files , imports : im , } , err } 
func build Context ( tags [ ] string ) * build . Context { return & build . Context { GOARCH : build . Default . GOARCH , GOOS : build . Default . GOOS , GOROOT : build . Default . GOROOT , GOPATH : build . Default . GOPATH , Compiler : build . Default . Compiler , Build Tags : append ( build . Default . Build Tags , tags . . . ) , } } 
func ( s * app ) bundle ( tar File string ) ( err error ) { var out io . Writer if tar File = = " " { out = os . Stdout } else { f , err : = os . Create ( tar File ) if err ! = nil { return err } defer func ( ) { if cerr : = f . Close ( ) ; err = = nil { err = cerr } } ( ) out = f } tw : = tar . New Writer ( out ) for src Dir , import Name : = range s . imports { dst Dir : = " " + import Name if err = copy Tree ( tw , dst Dir , src Dir ) ; err ! = nil { return fmt . Errorf ( " " , src Dir , dst Dir , err ) } } if err : = copy Tree ( tw , " " , * root Dir ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if ! s . has Main { if err : = synthesize Main ( tw , s . app Files ) ; err ! = nil { return fmt . Errorf ( " " , err ) } } if err : = tw . Close ( ) ; err ! = nil { return fmt . Errorf ( " " , tar File , err ) } return nil } 
func synthesize Main ( tw * tar . Writer , app Files [ ] string ) error { app Map : = make ( map [ string ] bool ) for _ , f : = range app Files { app Map [ f ] = true } var f string for i : = 0 ; i < 1 0 0 ; i + + { f = fmt . Sprintf ( " " , i ) if ! app Map [ filepath . Join ( * root Dir , f ) ] { break } } if app Map [ filepath . Join ( * root Dir , f ) ] { return fmt . Errorf ( " " , f ) } hdr : = & tar . Header { Name : f , Mode : 0 6 4 4 , Size : int 6 4 ( len ( new Main ) ) , } if err : = tw . Write Header ( hdr ) ; err ! = nil { return fmt . Errorf ( " " , f , err ) } if _ , err : = tw . Write ( [ ] byte ( new Main ) ) ; err ! = nil { return fmt . Errorf ( " " , f , err ) } return nil } 
func imports ( ctxt * build . Context , src Dir string , gopath [ ] string ) ( map [ string ] string , error ) { pkg , err : = ctxt . Import Dir ( src Dir , 0 ) if err ! = nil { return nil , fmt . Errorf ( " " , err ) } for _ , v : = range pkg . Imports { if ! strings . Contains ( v , " " ) { continue } src , err : = find In Gopath ( v , gopath ) if err ! = nil { return nil , fmt . Errorf ( " " , v , gopath , err ) } result [ src ] = v im , err : = imports ( ctxt , src , gopath ) if err ! = nil { return nil , fmt . Errorf ( " " , src , err ) } for k , v : = range im { result [ k ] = v } } return result , nil } 
func find In Gopath ( dir string , gopath [ ] string ) ( string , error ) { for _ , v : = range gopath { dst : = filepath . Join ( v , " " , dir ) if _ , err : = os . Stat ( dst ) ; err = = nil { return dst , nil } } return " " , fmt . Errorf ( " " , dir , gopath ) } 
func copy Tree ( tw * tar . Writer , dst Dir , src Dir string ) error { entries , err : = ioutil . Read Dir ( src Dir ) if err ! = nil { return fmt . Errorf ( " " , src Dir , err ) } for _ , entry : = range entries { n : = entry . Name ( ) if skip Files [ n ] { continue } s : = filepath . Join ( src Dir , n ) d : = filepath . Join ( dst Dir , n ) if entry . Is Dir ( ) { if err : = copy Tree ( tw , d , s ) ; err ! = nil { return fmt . Errorf ( " " , s , d , err ) } continue } if err : = copy File ( tw , d , s ) ; err ! = nil { return fmt . Errorf ( " " , s , d , err ) } } return nil } 
func copy File ( tw * tar . Writer , dst , src string ) error { s , err : = os . Open ( src ) if err ! = nil { return fmt . Errorf ( " " , src , err ) } defer s . Close ( ) fi , err : = s . Stat ( ) if err ! = nil { return fmt . Errorf ( " " , src , err ) } hdr , err : = tar . File Info Header ( fi , dst ) if err ! = nil { return fmt . Errorf ( " " , dst , err ) } hdr . Name = dst if err : = tw . Write Header ( hdr ) ; err ! = nil { return fmt . Errorf ( " " , dst , err ) } _ , err = io . Copy ( tw , s ) if err ! = nil { return fmt . Errorf ( " " , src , dst , err ) } return nil } 
func check Main ( ctxt * build . Context ) ( bool , [ ] string , error ) { pkg , err : = ctxt . Import Dir ( * root Dir , 0 ) if err ! = nil { return false , nil , fmt . Errorf ( " " , err ) } if ! pkg . Is Command ( ) { errorf ( " \ " \ " \n " , pkg . Name ) } var app Files [ ] string for _ , f : = range pkg . Go Files { n : = filepath . Join ( * root Dir , f ) app Files = append ( app Files , n ) if has Main , err = read File ( n ) ; err ! = nil { return false , nil , fmt . Errorf ( " " , n , err ) } } return has Main , app Files , nil } 
func is Main ( f * ast . Func Decl ) bool { ft : = f . Type return f . Name . Name = = " " & & f . Recv = = nil & & ft . Params . Num Fields ( ) = = 0 & & ft . Results . Num Fields ( ) = = 0 } 
func read File ( filename string ) ( has Main bool , err error ) { var src [ ] byte src , err = ioutil . Read File ( filename ) if err ! = nil { return } fset : = token . New File Set ( ) file , err : = parser . Parse File ( fset , filename , src , 0 ) for _ , decl : = range file . Decls { func Decl , ok : = decl . ( * ast . Func Decl ) if ! ok { continue } if ! is Main ( func Decl ) { continue } has Main = true break } return } 
func set Val ( v reflect . Value , p Value interface { } ) string { switch v . Kind ( ) { case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : x , ok : = p Value . ( int 6 4 ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } if v . Overflow Int ( x ) { return fmt . Sprintf ( " " , x , v . Type ( ) ) } v . Set Int ( x ) case reflect . Bool : x , ok : = p Value . ( bool ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } v . Set Bool ( x ) case reflect . String : switch x : = p Value . ( type ) { case appengine . Blob Key : v . Set String ( string ( x ) ) case Byte String : v . Set String ( string ( x ) ) case string : v . Set String ( x ) default : if p Value ! = nil { return type Mismatch Reason ( p Value , v ) } } case reflect . Float 3 2 , reflect . Float 6 4 : x , ok : = p Value . ( float 6 4 ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } if v . Overflow Float ( x ) { return fmt . Sprintf ( " " , x , v . Type ( ) ) } v . Set Float ( x ) case reflect . Ptr : x , ok : = p Value . ( * Key ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } if _ , ok : = v . Interface ( ) . ( * Key ) ; ! ok { return type Mismatch Reason ( p Value , v ) } v . Set ( reflect . Value Of ( x ) ) case reflect . Struct : switch v . Type ( ) { case type Of Time : x , ok : = p Value . ( time . Time ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } v . Set ( reflect . Value Of ( x ) ) case type Of Geo Point : x , ok : = p Value . ( appengine . Geo Point ) if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } v . Set ( reflect . Value Of ( x ) ) default : ent , ok : = p Value . ( * Entity ) if ! ok { return type Mismatch Reason ( p Value , v ) } if err ! = nil { return err . Error ( ) } } err = pls . Load ( ent . Properties ) if err ! = nil { return err . Error ( ) } } case reflect . Slice : x , ok : = p Value . ( [ ] byte ) if ! ok { if y , yok : = p Value . ( Byte String ) ; yok { x , ok = [ ] byte ( y ) , true } } if ! ok & & p Value ! = nil { return type Mismatch Reason ( p Value , v ) } if v . Type ( ) . Elem ( ) . Kind ( ) ! = reflect . Uint 8 { return type Mismatch Reason ( p Value , v ) } v . Set Bytes ( x ) default : return type Mismatch Reason ( p Value , v ) } return " " } 
func init Field ( val reflect . Value , index [ ] int ) reflect . Value { for _ , i : = range index [ : len ( index ) - 1 ] { val = val . Field ( i ) if val . Kind ( ) = = reflect . Ptr { if val . Is Nil ( ) { val . Set ( reflect . New ( val . Type ( ) . Elem ( ) ) ) } val = val . Elem ( ) } } return val . Field ( index [ len ( index ) - 1 ] ) } 
func load Entity ( dst interface { } , src * pb . Entity Proto ) ( err error ) { ent , err : = proto To Entity ( src ) if err ! = nil { return err } if e , ok : = dst . ( Property Load Saver ) ; ok { return e . Load ( ent . Properties ) } return Load Struct ( dst , ent . Properties ) } 
func valid Index Name Or Doc ID ( s string ) bool { if strings . Has Prefix ( s , " " ) { return false } for _ , c : = range s { if c < 0x 2 1 | | 0x 7f < = c { return false } } return true } 
func Open ( name string ) ( * Index , error ) { if ! valid Index Name Or Doc ID ( name ) { return nil , fmt . Errorf ( " " , name ) } return & Index { spec : pb . Index Spec { Name : & name , } , } , nil } 
func ( x * Index ) Put ( c context . Context , id string , src interface { } ) ( string , error ) { ids , err : = x . Put Multi ( c , [ ] string { id } , [ ] interface { } { src } ) if err ! = nil { return " " , err } return ids [ 0 ] , nil } 
func ( x * Index ) Put Multi ( c context . Context , ids [ ] string , srcs [ ] interface { } ) ( [ ] string , error ) { if len ( ids ) ! = 0 & & len ( srcs ) ! = len ( ids ) { return nil , fmt . Errorf ( " " ) } if len ( srcs ) > max Documents Per Put Delete { return nil , Err Too Many Documents } docs : = make ( [ ] * pb . Document , len ( srcs ) ) for i , s : = range srcs { var err error docs [ i ] , err = save Doc ( s ) if err ! = nil { return nil , err } if len ( ids ) ! = 0 & & ids [ i ] ! = " " { if ! valid Index Name Or Doc ID ( ids [ i ] ) { return nil , fmt . Errorf ( " " , ids [ i ] ) } docs [ i ] . Id = proto . String ( ids [ i ] ) } } req : = & pb . Index Document Request { Params : & pb . Index Document Params { Document : docs , Index Spec : & spec , } , } res : = & pb . Index Document Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return nil , err } multi Err , has Err : = make ( appengine . Multi Error , len ( res . Status ) ) , false for i , s : = range res . Status { if s . Get Code ( ) ! = pb . Search Service Error _OK { multi Err [ i ] = fmt . Errorf ( " " , s . Get Code ( ) , s . Get Error Detail ( ) ) has Err = true } } if has Err { return res . Doc Id , multi Err } if len ( res . Status ) ! = len ( docs ) | | len ( res . Doc Id ) ! = len ( docs ) { return nil , fmt . Errorf ( " " , len ( res . Status ) , len ( res . Doc Id ) , len ( docs ) ) } return res . Doc Id , nil } 
func ( x * Index ) Get ( c context . Context , id string , dst interface { } ) error { if id = = " " | | ! valid Index Name Or Doc ID ( id ) { return fmt . Errorf ( " " , id ) } req : = & pb . List Documents Request { Params : & pb . List Documents Params { Index Spec : & x . spec , Start Doc Id : proto . String ( id ) , Limit : proto . Int 3 2 ( 1 ) , } , } res : = & pb . List Documents Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if res . Status = = nil | | res . Status . Get Code ( ) ! = pb . Search Service Error _OK { return fmt . Errorf ( " " , res . Status . Get Code ( ) , res . Status . Get Error Detail ( ) ) } if len ( res . Document ) ! = 1 | | res . Document [ 0 ] . Get Id ( ) ! = id { return Err No Such Document } return load Doc ( dst , res . Document [ 0 ] , nil ) } 
func ( x * Index ) Delete ( c context . Context , id string ) error { return x . Delete Multi ( c , [ ] string { id } ) } 
func ( x * Index ) Delete Multi ( c context . Context , ids [ ] string ) error { if len ( ids ) > max Documents Per Put Delete { return Err Too Many Documents } req : = & pb . Delete Document Request { Params : & pb . Delete Document Params { Doc Id : ids , Index Spec : & x . spec , } , } res : = & pb . Delete Document Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } if len ( res . Status ) ! = len ( ids ) { return fmt . Errorf ( " " , len ( res . Status ) , len ( ids ) ) } multi Err , has Err : = make ( appengine . Multi Error , len ( ids ) ) , false for i , s : = range res . Status { if s . Get Code ( ) ! = pb . Search Service Error _OK { multi Err [ i ] = fmt . Errorf ( " " , s . Get Code ( ) , s . Get Error Detail ( ) ) has Err = true } } if has Err { return multi Err } return nil } 
func ( x * Index ) Search ( c context . Context , query string , opts * Search Options ) * Iterator { t : = & Iterator { c : c , index : x , search Query : query , more : more Search , } if opts ! = nil { if opts . Cursor ! = " " { if opts . Offset ! = 0 { return err Iter ( " " ) } t . search Cursor = proto . String ( string ( opts . Cursor ) ) } t . limit = opts . Limit t . fields = opts . Fields t . ids Only = opts . IDs Only t . sort = opts . Sort t . exprs = opts . Expressions t . refinements = opts . Refinements t . facet Opts = opts . Facets t . search Offset = opts . Offset t . count Accuracy = opts . Count Accuracy } return t } 
func ( t * Iterator ) fetch More ( ) { if t . err = = nil & & len ( t . list Res ) + len ( t . search Res ) = = 0 & & t . more ! = nil { t . err = t . more ( t ) } } 
func ( t * Iterator ) Next ( dst interface { } ) ( string , error ) { t . fetch More ( ) if t . err ! = nil { return " " , t . err } var doc * pb . Document var exprs [ ] * pb . Field switch { case len ( t . list Res ) ! = 0 : doc = t . list Res [ 0 ] t . list Res = t . list Res [ 1 : ] case len ( t . search Res ) ! = 0 : doc = t . search Res [ 0 ] . Document exprs = t . search Res [ 0 ] . Expression t . search Cursor = t . search Res [ 0 ] . Cursor t . search Res = t . search Res [ 1 : ] default : return " " , Done } if doc = = nil { return " " , errors . New ( " " ) } if ! t . ids Only & & dst ! = nil { if err : = load Doc ( dst , doc , exprs ) ; err ! = nil { return " " , err } } return doc . Get Id ( ) , nil } 
func ( t * Iterator ) Cursor ( ) Cursor { if t . search Cursor = = nil { return " " } return Cursor ( * t . search Cursor ) } 
func ( t * Iterator ) Facets ( ) ( [ ] [ ] Facet Result , error ) { t . fetch More ( ) if t . err ! = nil & & t . err ! = Done { return nil , t . err } var facets [ ] [ ] Facet Result for _ , f : = range t . facet Res { fres : = make ( [ ] Facet Result , 0 , len ( f . Value ) ) for _ , v : = range f . Value { ref : = v . Refinement facet : = Facet Result { Facet : Facet { Name : ref . Get Name ( ) } , Count : int ( v . Get Count ( ) ) , } if ref . Value ! = nil { facet . Value = Atom ( * ref . Value ) } else { facet . Value = proto To Range ( ref . Range ) } fres = append ( fres , facet ) } facets = append ( facets , fres ) } return facets , nil } 
func save Doc ( src interface { } ) ( * pb . Document , error ) { var err error var fields [ ] Field var meta * Document Metadata switch x : = src . ( type ) { case Field Load Saver : fields , meta , err = x . Save ( ) default : fields , meta , err = save Struct With Meta ( src ) } if err ! = nil { return nil , err } fields Proto , err : = fields To Proto ( fields ) if err ! = nil { return nil , err } d : = & pb . Document { Field : fields Proto , Order Id : proto . Int 3 2 ( int 3 2 ( time . Since ( order IDEpoch ) . Seconds ( ) ) ) , Order Id Source : pb . Document _DEFAULTED . Enum ( ) , } if meta ! = nil { if meta . Rank ! = 0 { if ! valid Doc Rank ( meta . Rank ) { return nil , fmt . Errorf ( " " , meta . Rank ) } * d . Order Id = int 3 2 ( meta . Rank ) d . Order Id Source = pb . Document _SUPPLIED . Enum ( ) } if len ( meta . Facets ) > 0 { facets , err : = facets To Proto ( meta . Facets ) if err ! = nil { return nil , err } d . Facet = facets } } return d , nil } 
func load Doc ( dst interface { } , src * pb . Document , exprs [ ] * pb . Field ) ( err error ) { fields , err : = proto To Fields ( src . Field ) if err ! = nil { return err } facets , err : = proto To Facets ( src . Facet ) if err ! = nil { return err } if len ( exprs ) > 0 { expr Fields , err : = proto To Fields ( exprs ) if err ! = nil { return err } } fields = append ( fields , expr Fields . . . ) } meta : = & Document Metadata { Rank : int ( src . Get Order Id ( ) ) , Facets : facets , } switch x : = dst . ( type ) { case Field Load Saver : return x . Load ( fields , meta ) default : return load Struct With Meta ( dst , fields , meta ) } } 
func Default Bucket Name ( c context . Context ) ( string , error ) { req : = & aipb . Get Default Gcs Bucket Name Request { } res : = & aipb . Get Default Gcs Bucket Name Response { } err : = internal . Call ( c , " " , " " , req , res ) if err ! = nil { return " " , fmt . Errorf ( " " , res ) } return res . Get Default Gcs Bucket Name ( ) , nil } 
func ( k * Key ) valid ( ) bool { if k = = nil { return false } for ; k ! = nil ; k = k . parent { if k . kind = = " " | | k . app ID = = " " { return false } if k . string ID ! = " " & & k . int ID ! = 0 { return false } if k . parent ! = nil { if k . parent . Incomplete ( ) { return false } if k . parent . app ID ! = k . app ID | | k . parent . namespace ! = k . namespace { return false } } } return true } 
func ( k * Key ) Equal ( o * Key ) bool { for k ! = nil & & o ! = nil { if k . kind ! = o . kind | | k . string ID ! = o . string ID | | k . int ID ! = o . int ID | | k . app ID ! = o . app ID | | k . namespace ! = o . namespace { return false } k , o = k . parent , o . parent } return k = = o } 
func ( k * Key ) root ( ) * Key { for k . parent ! = nil { k = k . parent } return k } 
func ( k * Key ) marshal ( b * bytes . Buffer ) { if k . parent ! = nil { k . parent . marshal ( b ) } b . Write Byte ( ' / ' ) b . Write String ( k . kind ) b . Write Byte ( ' , ' ) if k . string ID ! = " " { b . Write String ( k . string ID ) } else { b . Write String ( strconv . Format Int ( k . int ID , 1 0 ) ) } } 
func ( k * Key ) String ( ) string { if k = = nil { return " " } b : = bytes . New Buffer ( make ( [ ] byte , 0 , 5 1 2 ) ) k . marshal ( b ) return b . String ( ) } 
func ( k * Key ) Encode ( ) string { ref : = key To Proto ( " " , k ) b , err : = proto . Marshal ( ref ) if err ! = nil { panic ( err ) } } 
func Decode Key ( encoded string ) ( * Key , error ) { } b , err : = base 6 4 . URLEncoding . Decode String ( encoded ) if err ! = nil { return nil , err } ref : = new ( pb . Reference ) if err : = proto . Unmarshal ( b , ref ) ; err ! = nil { return nil , err } return proto To Key ( ref ) } 
func New Incomplete Key ( c context . Context , kind string , parent * Key ) * Key { return New Key ( c , kind , " " , 0 , parent ) } 
func New Key ( c context . Context , kind , string ID string , int ID int 6 4 , parent * Key ) * Key { if parent ! = nil { namespace = parent . namespace } else { namespace = internal . Namespace From Context ( c ) } return & Key { kind : kind , string ID : string ID , int ID : int ID , parent : parent , app ID : internal . Fully Qualified App ID ( c ) , namespace : namespace , } } 
func Allocate IDs ( c context . Context , kind string , parent * Key , n int ) ( low , high int 6 4 , err error ) { if kind = = " " { return 0 , 0 , errors . New ( " " ) } if n < 0 { return 0 , 0 , fmt . Errorf ( " " , n ) } if n = = 0 { return 0 , 0 , nil } req : = & pb . Allocate Ids Request { Model Key : key To Proto ( " " , New Incomplete Key ( c , kind , parent ) ) , Size : proto . Int 6 4 ( int 6 4 ( n ) ) , } res : = & pb . Allocate Ids Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return 0 , 0 , err } high = res . Get End ( ) + 1 if low + int 6 4 ( n ) ! = high { return 0 , 0 , fmt . Errorf ( " " , n ) } return low , high , nil } 
func Allocate IDRange ( c context . Context , kind string , parent * Key , start , end int 6 4 ) ( err error ) { if kind = = " " { return errors . New ( " " ) } if start < 1 | | end < 1 { return errors . New ( " " ) } if start > end { return errors . New ( " " ) } req : = & pb . Allocate Ids Request { Model Key : key To Proto ( " " , New Incomplete Key ( c , kind , parent ) ) , Max : proto . Int 6 4 ( end ) , } res : = & pb . Allocate Ids Response { } if err : = internal . Call ( c , " " , " " , req , res ) ; err ! = nil { return err } keys , err : = q . Get All ( c , nil ) if err ! = nil { return err } if len ( keys ) ! = 0 { return & Key Range Collision Error { start : start , end : end } } } return nil } 
func ( m * Index Document Params ) Get Freshness ( ) Index Document Params _Freshness { if m ! = nil & & m . Freshness ! = nil { return * m . Freshness } return Default _Index Document Params _Freshness } 
func Is Over Quota ( err error ) bool { call Err , ok : = err . ( * internal . Call Error ) return ok & & call Err . Code = = 4 } 
func from Context ( ctx netcontext . Context ) appengine . Context { c , _ : = ctx . Value ( & context Key ) . ( appengine . Context ) return c } 
func Classic Context From Context ( ctx netcontext . Context ) ( appengine . Context , error ) { c : = from Context ( ctx ) if c = = nil { return nil , err Not App Engine Context } return c , nil } 
func Send ( c context . Context , msg * Message ) error { return send ( c , " " , msg ) } 
func Send To Admins ( c context . Context , msg * Message ) error { return send ( c , " " , msg ) } 
func Parse ( r io . Reader , pkg Name string ) ( * Report , error ) { reader : = bufio . New Reader ( r ) report : = & Report { make ( [ ] Package , 0 ) } if err ! = nil & & err = = io . EOF { break } else if err ! = nil { return nil , err } line : = string ( l ) if strings . Has Prefix ( line , " " ) { tests = append ( tests , & Test { Name : cur , Result : FAIL , Output : make ( [ ] string , 0 ) , } ) seen Summary = false } else if matches : = regex Benchmark . Find String Submatch ( line ) ; len ( matches ) = = 6 { bytes , _ : = strconv . Atoi ( matches [ 4 ] ) allocs , _ : = strconv . Atoi ( matches [ 5 ] ) benchmarks = append ( benchmarks , & Benchmark { Name : matches [ 1 ] , Duration : parse Nanoseconds ( matches [ 3 ] ) , Bytes : bytes , Allocs : allocs , } ) } else if strings . Has Prefix ( line , " " ) { continue } else if strings . Has Prefix ( line , " " ) { cur = strings . Trim Space ( line [ 8 : ] ) continue } else if matches : = regex Result . Find String Submatch ( line ) ; len ( matches ) = = 6 { if matches [ 5 ] ! = " " { coverage Pct = matches [ 5 ] } if strings . Has Suffix ( matches [ 4 ] , " " ) { } else if matches [ 1 ] = = " " & & len ( tests ) = = 0 & & len ( buffers [ cur ] ) > 0 { buffers [ cur ] = buffers [ cur ] [ 0 : 0 ] } buffers [ cur ] = buffers [ cur ] [ 0 : 0 ] tests = make ( [ ] * Test , 0 ) benchmarks = make ( [ ] * Benchmark , 0 ) coverage Pct = " " cur = " " tests Time = 0 } else if matches : = regex Status . Find String Submatch ( line ) ; len ( matches ) = = 4 { cur = matches [ 2 ] test : = find Test ( tests , cur ) if test = = nil { continue } } else if matches [ 1 ] = = " " { test . Result = SKIP } else { test . Result = FAIL } if matches : = regex Indent . Find String Submatch ( line ) ; len ( matches ) = = 2 { test . Subtest Indent = matches [ 1 ] } test . Output = buffers [ cur ] test . Name = matches [ 2 ] test . Duration = parse Seconds ( matches [ 3 ] ) tests Time + = test . Duration test . Time = int ( test . Duration / time . Millisecond ) } else if matches : = regex Coverage . Find String Submatch ( line ) ; len ( matches ) = = 2 { coverage Pct = matches [ 1 ] } else if matches : = regex Output . Find String Submatch ( line ) ; captured Package = = " " & & len ( matches ) = = 3 { if test = = nil { continue } test . Output = append ( test . Output , matches [ 2 ] ) } else if strings . Has Prefix ( line , " " ) { } else if captured Package ! = " " { } else if regex Summary . Match String ( line ) { } else if ! seen Summary { if test ! = nil { if strings . Has Prefix ( line , test . Subtest Indent + " " ) { test . Output = append ( test . Output , strings . Trim Prefix ( line , test . Subtest Indent + " " ) ) } } } } if len ( tests ) > 0 { } return report , nil } 
func ( r * Report ) Failures ( ) int { count : = 0 for _ , p : = range r . Packages { for _ , t : = range p . Tests { if t . Result = = FAIL { count + + } } } return count } 
func JUnit Report XML ( report * parser . Report , no XMLHeader bool , go Version string , w io . Writer ) error { suites : = JUnit Test Suites { } ts : = JUnit Test Suite { Tests : len ( pkg . Tests ) + len ( pkg . Benchmarks ) , Failures : 0 , Time : format Time ( pkg . Duration ) , Name : pkg . Name , Properties : [ ] JUnit Property { } , Test Cases : [ ] JUnit Test Case { } , } classname : = pkg . Name if idx : = strings . Last Index ( classname , " " ) ; idx > - 1 & & idx < len ( pkg . Name ) { classname = pkg . Name [ idx + 1 : ] } } ts . Properties = append ( ts . Properties , JUnit Property { " " , go Version } ) if pkg . Coverage Pct ! = " " { ts . Properties = append ( ts . Properties , JUnit Property { " " , pkg . Coverage Pct } ) } if test . Result = = parser . FAIL { ts . Failures + + test Case . Failure = & JUnit Failure { Message : " " , Type : " " , Contents : strings . Join ( test . Output , " \n " ) , } } if test . Result = = parser . SKIP { test Case . Skip Message = & JUnit Skip Message { strings . Join ( test . Output , " \n " ) } } ts . Test Cases = append ( ts . Test Cases , test Case ) } ts . Test Cases = append ( ts . Test Cases , benchmark Case ) } suites . Suites = append ( suites . Suites , ts ) } if err ! = nil { return err } writer : = bufio . New Writer ( w ) if ! no XMLHeader { writer . Write String ( xml . Header ) } writer . Write ( bytes ) writer . Write Byte ( ' \n ' ) writer . Flush ( ) return nil } 
func ( cdc * Codec ) decode Reflect Binary ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options , bare bool ) ( n int , err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if info . Type . Kind ( ) = = reflect . Interface & & rv . Kind ( ) = = reflect . Ptr { panic ( " " ) } if print Log { spew . Printf ( " \n " , bz , info , rv . Interface ( ) , rv . Type ( ) , fopts ) defer func ( ) { fmt . Printf ( " \n " , n , err ) } ( ) } var _n int rv . Set ( new Ptr ) } rv = rv . Elem ( ) } rinfo , err = cdc . get Type Info _wlock ( info . Amino Unmarshal Repr Type ) if err ! = nil { return } _n , err = cdc . decode Reflect Binary ( bz , rinfo , rrv , fopts , bare ) if slide ( & bz , & n , _n ) & & err ! = nil { return } uwouts : = uwrm . Call ( [ ] reflect . Value { rrv } ) erri : = uwouts [ 0 ] . Interface ( ) if erri ! = nil { err = erri . ( error ) } return } switch info . Type . Kind ( ) { n + = _n return case reflect . Array : ert : = info . Type . Elem ( ) if ert . Kind ( ) = = reflect . Uint 8 { _n , err = cdc . decode Reflect Binary Byte Array ( bz , info , rv , fopts ) n + = _n } else { _n , err = cdc . decode Reflect Binary Array ( bz , info , rv , fopts , bare ) n + = _n } return case reflect . Slice : ert : = info . Type . Elem ( ) if ert . Kind ( ) = = reflect . Uint 8 { _n , err = cdc . decode Reflect Binary Byte Slice ( bz , info , rv , fopts ) n + = _n } else { _n , err = cdc . decode Reflect Binary Slice ( bz , info , rv , fopts , bare ) n + = _n } return case reflect . Struct : _n , err = cdc . decode Reflect Binary Struct ( bz , info , rv , fopts , bare ) n + = _n return if fopts . Bin Fixed 6 4 { num , _n , err = Decode Int 6 4 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Int ( num ) } else { var u 6 4 uint 6 4 u 6 4 , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Int ( int 6 4 ( u 6 4 ) ) } return case reflect . Int 3 2 : if fopts . Bin Fixed 3 2 { var num int 3 2 num , _n , err = Decode Int 3 2 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Int ( int 6 4 ( num ) ) } else { var num uint 6 4 num , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } if int 6 4 ( num ) > math . Max Int 3 2 | | int 6 4 ( num ) < math . Min Int 3 2 { err = Err Overflow Int return } rv . Set Int ( int 6 4 ( num ) ) } return case reflect . Int 1 6 : var num int 1 6 num , _n , err = Decode Int 1 6 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Int ( int 6 4 ( num ) ) return case reflect . Int 8 : var num int 8 num , _n , err = Decode Int 8 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Int ( int 6 4 ( num ) ) return case reflect . Int : var num uint 6 4 num , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } if int 6 4 ( num ) > int 6 4 ( max Int ) | | int 6 4 ( num ) < int 6 4 ( min Int ) { err = Err Overflow Int return } rv . Set Int ( int 6 4 ( num ) ) return if fopts . Bin Fixed 6 4 { num , _n , err = Decode Uint 6 4 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( num ) } else { num , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( num ) } return case reflect . Uint 3 2 : if fopts . Bin Fixed 3 2 { var num uint 3 2 num , _n , err = Decode Uint 3 2 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( uint 6 4 ( num ) ) } else { var num uint 6 4 num , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( uint 6 4 ( num ) ) } return case reflect . Uint 1 6 : var num uint 1 6 num , _n , err = Decode Uint 1 6 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( uint 6 4 ( num ) ) return case reflect . Uint 8 : var num uint 8 num , _n , err = Decode Uint 8 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( uint 6 4 ( num ) ) return case reflect . Uint : var num uint 6 4 num , _n , err = Decode Uvarint ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Uint ( num ) return b , _n , err = Decode Bool ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Bool ( b ) return case reflect . Float 6 4 : var f float 6 4 if ! fopts . Unsafe { err = errors . New ( " \ " \ " " ) return } f , _n , err = Decode Float 6 4 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Float ( f ) return case reflect . Float 3 2 : var f float 3 2 if ! fopts . Unsafe { err = errors . New ( " \ " \ " " ) return } f , _n , err = Decode Float 3 2 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set Float ( float 6 4 ( f ) ) return case reflect . String : var str string str , _n , err = Decode String ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set String ( str ) return default : panic ( fmt . Sprintf ( " " , info . Type . Kind ( ) ) ) } } 
func ( cdc * Codec ) decode Reflect Binary Interface ( bz [ ] byte , iinfo * Type Info , rv reflect . Value , fopts Field Options , bare bool ) ( n int , err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } if ! rv . Is Nil ( ) { return } if ! bare { buf , _n , err = Decode Byte Slice ( bz ) if slide ( & bz , nil , _n ) & & err ! = nil { return } bz = buf } if slide ( & bz , & n , _n ) & & err ! = nil { return } if has Disamb { cinfo , err = cdc . get Type Info From Disfix _rlock ( to Disfix ( disamb , prefix ) ) } else if has Prefix { cinfo , err = cdc . get Type Info From Prefix _rlock ( iinfo , prefix ) } else { err = errors . New ( " " ) } if err ! = nil { return } if slide ( & bz , & n , _n ) & & err ! = nil { rv . Set ( irv Set ) return } return } return } 
func ( cdc * Codec ) decode Reflect Binary Byte Array ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( n int , err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } ert : = info . Type . Elem ( ) if ert . Kind ( ) ! = reflect . Uint 8 { panic ( " " ) } length : = info . Type . Len ( ) if len ( bz ) < length { return 0 , fmt . Errorf ( " " , length ) } byteslice , _n , err = Decode Byte Slice ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } if len ( byteslice ) ! = length { err = fmt . Errorf ( " " , length , len ( byteslice ) ) return } return } 
func ( cdc * Codec ) decode Reflect Binary Array ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options , bare bool ) ( n int , err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } ert : = info . Type . Elem ( ) if ert . Kind ( ) = = reflect . Uint 8 { panic ( " " ) } length : = info . Type . Len ( ) einfo , err : = cdc . get Type Info _wlock ( ert ) if err ! = nil { return } if ! bare { buf , _n , err = Decode Byte Slice ( bz ) if slide ( & bz , nil , _n ) & & err ! = nil { return } bz = buf } if typ 3 ! = Typ 3 _Byte Length { _n , err = cdc . decode Reflect Binary ( bz , einfo , erv , fopts , false ) if slide ( & bz , & n , _n ) & & err ! = nil { err = fmt . Errorf ( " " , err ) return } if is Default { erv . Set ( reflect . Zero ( erv . Type ( ) ) ) continue } } } return } } else { fnum , typ , _n , err = decode Field Number And Typ 3 ( bz ) return } if typ ! = Typ 3 _Byte Length { err = errors . New ( fmt . Sprintf ( " " , Typ 3 _Byte Length , typ ) ) return } if slide ( & bz , & n , _n ) & & err ! = nil { return } erv . Set ( default Value ( erv . Type ( ) ) ) continue } efopts . Bin Field Num = 1 _n , err = cdc . decode Reflect Binary ( bz , einfo , erv , efopts , false ) if slide ( & bz , & n , _n ) & & err ! = nil { err = fmt . Errorf ( " " , err ) return } } fnum , _ , _ , err = decode Field Number And Typ 3 ( bz ) if err ! = nil { return } if fnum < = fopts . Bin Field Num { err = fmt . Errorf ( " " , fnum , fopts . Bin Field Num ) return } } } return } 
func ( cdc * Codec ) decode Reflect Binary Struct ( bz [ ] byte , info * Type Info , rv reflect . Value , _ Field Options , bare bool ) ( n int , err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } _n : = 0 buf , _n , err = Decode Byte Slice ( bz ) if slide ( & bz , nil , _n ) & & err ! = nil { return } bz = buf } switch info . Type { case time Type : t , _n , err = Decode Time ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } rv . Set ( reflect . Value Of ( t ) ) default : var finfo * Type Info finfo , err = cdc . get Type Info _wlock ( field . Type ) if err ! = nil { return } continue } if field . Unpacked List { if slide ( & bz , & n , _n ) & & err ! = nil { return } } else { fnum , typ , _n , err = decode Field Number And Typ 3 ( bz ) if field . Bin Field Num < fnum { continue if fnum < = last Field Num { err = fmt . Errorf ( " \n " , fnum , last Field Num , bz ) return } last Field Num = fnum if slide ( & bz , & n , _n ) & & err ! = nil { return } return } typ Wanted : = type To Typ 3 ( finfo . Type , field . Field Options ) if typ ! = typ Wanted { err = errors . New ( fmt . Sprintf ( " " , typ Wanted , fnum , info . Type , typ ) ) return } if slide ( & bz , & n , _n ) & & err ! = nil { return } } } var typ 3 Typ 3 for len ( bz ) > 0 { fnum , typ 3 , _n , err = decode Field Number And Typ 3 ( bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } if fnum < = last Field Num { err = fmt . Errorf ( " \n " , fnum , last Field Num , bz ) return } last Field Num = fnum _n , err = consume Any ( typ 3 , bz ) if slide ( & bz , & n , _n ) & & err ! = nil { return } } } return } 
func consume Any ( typ 3 Typ 3 , bz [ ] byte ) ( n int , err error ) { var _n int switch typ 3 { case Typ 3 _Varint : _ , _n , err = Decode Varint ( bz ) case Typ 3 _ 8Byte : _ , _n , err = Decode Int 6 4 ( bz ) case Typ 3 _Byte Length : _ , _n , err = Decode Byte Slice ( bz ) case Typ 3 _ 4Byte : _ , _n , err = Decode Int 3 2 ( bz ) default : err = fmt . Errorf ( " " , typ 3 ) return } if err ! = nil { } slide ( & bz , & n , _n ) return } 
func Decode Disamb Prefix Bytes ( bz [ ] byte ) ( db Disamb Bytes , has Db bool , pb Prefix Bytes , has Pb bool , n int , err error ) { return } if bz [ 0 ] = = 0x 0 0 { return } copy ( db [ 0 : 3 ] , bz [ 1 : 4 ] ) copy ( pb [ 0 : 4 ] , bz [ 4 : 8 ] ) has Db = true has Pb = true n = 8 return } else { has Db = false has Pb = true n = 4 return } } 
func decode Field Number And Typ 3 ( bz [ ] byte ) ( num uint 3 2 , typ Typ 3 , n int , err error ) { value 6 4 , n , err = Decode Uvarint ( bz ) if err ! = nil { return } num 6 4 = value 6 4 > > 3 if num 6 4 > ( 1 < < 2 9 - 1 ) { err = fmt . Errorf ( " " , num 6 4 ) return } num = uint 3 2 ( num 6 4 ) return } 
func check Typ 3 ( rt reflect . Type , typ Typ 3 , fopts Field Options ) ( err error ) { typ Wanted : = type To Typ 3 ( rt , fopts ) if typ ! = typ Wanted { err = fmt . Errorf ( " " , typ Wanted , typ ) } return } 
func decode Typ 3 ( bz [ ] byte ) ( typ Typ 3 , n int , err error ) { if len ( bz ) = = 0 { err = fmt . Errorf ( " " ) return } if bz [ 0 ] & 0x F 8 ! = 0 { err = fmt . Errorf ( " " , Typ 3 ( bz [ 0 ] ) . String ( ) ) return } typ = Typ 3 ( bz [ 0 ] ) n = 1 return } 
func decode Num Nil Bytes ( bz [ ] byte ) ( num Nil int 6 4 , n int , err error ) { if len ( bz ) = = 0 { err = errors . New ( " " ) return } if bz [ 0 ] = = 0x 0 0 { num Nil , n = 0 , 1 return } if bz [ 0 ] = = 0x 0 1 { num Nil , n = 1 , 1 return } n , err = 0 , fmt . Errorf ( " " , bz [ 0 ] ) return } 
func New Prefix Bytes ( prefix Bytes [ ] byte ) Prefix Bytes { pb : = Prefix Bytes { } copy ( pb [ : ] , prefix Bytes ) return pb } 
func ( cdc * Codec ) Register Interface ( ptr interface { } , iopts * Interface Options ) { cdc . assert Not Sealed ( ) if rt . Kind ( ) ! = reflect . Interface { panic ( fmt . Sprintf ( " " , rt ) ) } defer cdc . mtx . Unlock ( ) cdc . collect Implementers _nolock ( info ) err : = cdc . check Conflicts In Prio _nolock ( info ) if err ! = nil { panic ( err ) } cdc . set Type Info _nolock ( info ) } ( ) } 
func ( cdc * Codec ) Register Concrete ( o interface { } , name string , copts * Concrete Options ) { cdc . assert Not Sealed ( ) var pointer Preferred bool if rt . Kind ( ) = = reflect . Interface { panic ( fmt . Sprintf ( " " , rt ) ) } if rt . Kind ( ) = = reflect . Ptr { rt = rt . Elem ( ) if rt . Kind ( ) = = reflect . Ptr { } if rt . Kind ( ) = = reflect . Interface { } pointer Preferred = true } defer cdc . mtx . Unlock ( ) cdc . add Check Conflicts With Concrete _nolock ( info ) cdc . set Type Info _nolock ( info ) } ( ) } 
func ( cdc * Codec ) Print Types ( out io . Writer ) error { cdc . mtx . RLock ( ) defer cdc . mtx . RUnlock ( ) } if _ , err : = io . Write String ( out , " \n " ) ; err ! = nil { return err } } if _ , err : = io . Write String ( out , " " ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , i . Name ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , " " ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , fmt . Sprintf ( " " , i . Prefix ) ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , " " ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , get Length Str ( i ) ) ; err ! = nil { return err } if _ , err : = io . Write String ( out , " " ) ; err ! = nil { return err } } } 
func get Length Str ( info * Type Info ) string { switch info . Type . Kind ( ) { case reflect . Array , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 , reflect . Float 3 2 , reflect . Float 6 4 , reflect . Complex 6 4 , reflect . Complex 1 2 8 : s : = info . Type . Size ( ) return fmt . Sprintf ( " " , s ) default : return " " } } 
func ( cdc * Codec ) assert Not Sealed ( ) { cdc . mtx . Lock ( ) defer cdc . mtx . Unlock ( ) if cdc . sealed { panic ( " " ) } } 
func ( cdc * Codec ) get Type Info From Prefix _rlock ( iinfo * Type Info , pb Prefix Bytes ) ( info * Type Info , err error ) { infos , ok : = iinfo . Implementers [ pb ] if ! ok { err = fmt . Errorf ( " " , pb ) cdc . mtx . RUnlock ( ) return } if len ( infos ) > 1 { err = fmt . Errorf ( " " , pb , infos [ 0 ] . Type , infos [ 1 ] . Type ) cdc . mtx . RUnlock ( ) return } info = infos [ 0 ] cdc . mtx . RUnlock ( ) return } 
func ( cdc * Codec ) new Type Info Unregistered ( rt reflect . Type ) * Type Info { if rt . Kind ( ) = = reflect . Ptr { panic ( " " ) } if rt . Kind ( ) = = reflect . Interface { panic ( " " ) } var info = new ( Type Info ) info . Type = rt info . Ptr To Type = reflect . Ptr To ( rt ) info . Zero Value = reflect . Zero ( rt ) info . Zero Proto = reflect . Zero ( rt ) . Interface ( ) if rt . Kind ( ) = = reflect . Struct { info . Struct Info = cdc . parse Struct Info ( rt ) } if rm , ok : = rt . Method By Name ( " " ) ; ok { info . Concrete Info . Is Amino Marshaler = true info . Concrete Info . Amino Marshal Repr Type = marshal Amino Repr Type ( rm ) } if rm , ok : = reflect . Ptr To ( rt ) . Method By Name ( " " ) ; ok { info . Concrete Info . Is Amino Unmarshaler = true info . Concrete Info . Amino Unmarshal Repr Type = unmarshal Amino Repr Type ( rm ) } return info } 
func ( cdc * Codec ) collect Implementers _nolock ( info * Type Info ) { for _ , cinfo : = range cdc . concrete Infos { if cinfo . Ptr To Type . Implements ( info . Type ) { info . Implementers [ cinfo . Prefix ] = append ( info . Implementers [ cinfo . Prefix ] , cinfo ) } } } 
func ( cdc * Codec ) check Conflicts In Prio _nolock ( iinfo * Type Info ) error { for _ , cinfos : = range iinfo . Implementers { if len ( cinfos ) < 2 { continue } for _ , cinfo : = range cinfos { var in Prio = false for _ , disfix : = range iinfo . Interface Info . Priority { if cinfo . Get Disfix ( ) = = disfix { in Prio = true } } if ! in Prio { return fmt . Errorf ( " " , cinfo . Type , len ( cinfos ) , iinfo . Type ) } } } return nil } 
func ( ti Type Info ) String ( ) string { buf : = new ( bytes . Buffer ) buf . Write ( [ ] byte ( " " ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Type ) ) ) if ti . Type . Kind ( ) = = reflect . Interface { buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Priority ) ) ) buf . Write ( [ ] byte ( " " ) ) for pb , cinfos : = range ti . Implementers { buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , pb ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " " , cinfos ) ) ) } buf . Write ( [ ] byte ( " " ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Interface Options . Priority ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Interface Options . Always Disambiguate ) ) ) } if ti . Type . Kind ( ) ! = reflect . Interface { if ti . Concrete Info . Registered { buf . Write ( [ ] byte ( " " ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Pointer Preferred ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , ti . Name ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , ti . Disamb ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , ti . Prefix ) ) ) } else { buf . Write ( [ ] byte ( " " ) ) } buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , ti . Amino Marshal Repr Type ) ) ) buf . Write ( [ ] byte ( fmt . Sprintf ( " \ " \ " " , ti . Amino Unmarshal Repr Type ) ) ) if ti . Type . Kind ( ) = = reflect . Struct { buf . Write ( [ ] byte ( fmt . Sprintf ( " " , ti . Fields ) ) ) } } buf . Write ( [ ] byte ( " " ) ) return buf . String ( ) } 
func is Exported ( field reflect . Struct Field ) bool { } for _ , c : = range field . Name { first = c break } } } 
func ( cdc * Codec ) encode Reflect Binary ( w io . Writer , info * Type Info , rv reflect . Value , fopts Field Options , bare bool ) ( err error ) { if rv . Kind ( ) = = reflect . Ptr { panic ( " " ) } if ! rv . Is Valid ( ) { panic ( " " ) } if print Log { spew . Printf ( " \n " , info , rv . Interface ( ) , rv . Type ( ) , fopts ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } rrv , err = to Repr Object ( rv ) if err ! = nil { return } rinfo , err = cdc . get Type Info _wlock ( info . Amino Marshal Repr Type ) if err ! = nil { return } return } switch info . Type . Kind ( ) { case reflect . Array : if info . Type . Elem ( ) . Kind ( ) = = reflect . Uint 8 { err = cdc . encode Reflect Binary Byte Array ( w , info , rv , fopts ) } else { err = cdc . encode Reflect Binary List ( w , info , rv , fopts , bare ) } case reflect . Slice : if info . Type . Elem ( ) . Kind ( ) = = reflect . Uint 8 { err = cdc . encode Reflect Binary Byte Slice ( w , info , rv , fopts ) } else { err = cdc . encode Reflect Binary List ( w , info , rv , fopts , bare ) } case reflect . Struct : err = cdc . encode Reflect Binary Struct ( w , info , rv , fopts , bare ) } else { err = Encode Uvarint ( w , uint 6 4 ( rv . Int ( ) ) ) } case reflect . Int 3 2 : if fopts . Bin Fixed 3 2 { err = Encode Int 3 2 ( w , int 3 2 ( rv . Int ( ) ) ) } else { err = Encode Uvarint ( w , uint 6 4 ( rv . Int ( ) ) ) } case reflect . Int 1 6 : err = Encode Int 1 6 ( w , int 1 6 ( rv . Int ( ) ) ) case reflect . Int 8 : err = Encode Int 8 ( w , int 8 ( rv . Int ( ) ) ) case reflect . Int : err = Encode Uvarint ( w , uint 6 4 ( rv . Int ( ) ) ) } else { err = Encode Uvarint ( w , rv . Uint ( ) ) } case reflect . Uint 3 2 : if fopts . Bin Fixed 3 2 { err = Encode Uint 3 2 ( w , uint 3 2 ( rv . Uint ( ) ) ) } else { err = Encode Uvarint ( w , rv . Uint ( ) ) } case reflect . Uint 1 6 : err = Encode Uint 1 6 ( w , uint 1 6 ( rv . Uint ( ) ) ) case reflect . Uint 8 : err = Encode Uint 8 ( w , uint 8 ( rv . Uint ( ) ) ) case reflect . Uint : err = Encode Uvarint ( w , rv . Uint ( ) ) case reflect . Float 6 4 : if ! fopts . Unsafe { err = errors . New ( " \ " \ " " ) return } err = Encode Float 6 4 ( w , rv . Float ( ) ) case reflect . Float 3 2 : if ! fopts . Unsafe { err = errors . New ( " \ " \ " " ) return } err = Encode Float 3 2 ( w , float 3 2 ( rv . Float ( ) ) ) case reflect . String : err = Encode String ( w , rv . String ( ) ) } return } 
func ( cdc * Codec ) encode Reflect Binary Byte Slice ( w io . Writer , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } ert : = info . Type . Elem ( ) if ert . Kind ( ) ! = reflect . Uint 8 { panic ( " " ) } err = Encode Byte Slice ( w , byteslice ) return } 
func encode Field Number And Typ 3 ( w io . Writer , num uint 3 2 , typ Typ 3 ) ( err error ) { if ( typ & 0x F 8 ) ! = 0 { panic ( fmt . Sprintf ( " " , typ ) ) } if num < 0 | | num > ( 1 < < 2 9 - 1 ) { panic ( fmt . Sprintf ( " " , num ) ) } n : = binary . Put Uvarint ( buf [ : ] , value 6 4 ) _ , err = w . Write ( buf [ 0 : n ] ) return } 
func ( cdc * Codec ) decode Reflect JSON ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if info . Type . Kind ( ) = = reflect . Interface & & rv . Kind ( ) = = reflect . Ptr { panic ( " " ) } if print Log { spew . Printf ( " \n " , bz , info , rv . Interface ( ) , rv . Type ( ) , fopts ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } return } rv . Set ( new Ptr ) } rv = rv . Elem ( ) } return } } else { err = fmt . Errorf ( " " , bz ) return } } return } rinfo , err = cdc . get Type Info _wlock ( info . Amino Unmarshal Repr Type ) if err ! = nil { return } err = cdc . decode Reflect JSON ( bz , rinfo , rrv , fopts ) if err ! = nil { return } uwouts : = uwrm . Call ( [ ] reflect . Value { rrv } ) erri : = uwouts [ 0 ] . Interface ( ) if erri ! = nil { err = erri . ( error ) } return } switch ikind : = info . Type . Kind ( ) ; ikind { case reflect . Array : err = cdc . decode Reflect JSONArray ( bz , info , rv , fopts ) case reflect . Slice : err = cdc . decode Reflect JSONSlice ( bz , info , rv , fopts ) case reflect . Struct : err = cdc . decode Reflect JSONStruct ( bz , info , rv , fopts ) case reflect . Map : err = cdc . decode Reflect JSONMap ( bz , info , rv , fopts ) case reflect . Uint 6 4 , reflect . Uint : if bz [ 0 ] ! = ' " ' | | bz [ len ( bz ) - 1 ] ! = ' " ' { err = fmt . Errorf ( " " , string ( bz ) ) if err ! = nil { return } } bz = bz [ 1 : len ( bz ) - 1 ] fallthrough case reflect . Int 3 2 , reflect . Int 1 6 , reflect . Int 8 , reflect . Uint 3 2 , reflect . Uint 1 6 , reflect . Uint 8 : err = invoke Stdlib JSONUnmarshal ( bz , rv , fopts ) } fallthrough case reflect . Bool , reflect . String : err = invoke Stdlib JSONUnmarshal ( bz , rv , fopts ) } return } 
func ( cdc * Codec ) decode Reflect JSONInterface ( bz [ ] byte , iinfo * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } if ! rv . Is Nil ( ) { } if err ! = nil { return } cinfo , err = cdc . get Type Info From Name _rlock ( name ) if err ! = nil { return } if err ! = nil { rv . Set ( irv Set ) return } return } 
func ( cdc * Codec ) decode Reflect JSONArray ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } ert : = info . Type . Elem ( ) length : = info . Type . Len ( ) switch ert . Kind ( ) { case reflect . Uint 8 : err = json . Unmarshal ( bz , & buf ) if err ! = nil { return } if len ( buf ) ! = length { err = fmt . Errorf ( " " , len ( buf ) , length ) } reflect . Copy ( rv , reflect . Value Of ( buf ) ) return default : einfo , err = cdc . get Type Info _wlock ( ert ) if err ! = nil { return } if err = json . Unmarshal ( bz , & raw Slice ) ; err ! = nil { return } if len ( raw Slice ) ! = length { err = fmt . Errorf ( " " , len ( raw Slice ) , length ) return } ebz : = raw Slice [ i ] err = cdc . decode Reflect JSON ( ebz , einfo , erv , fopts ) if err ! = nil { return } } return } } 
func ( cdc * Codec ) decode Reflect JSONSlice ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } var ert = info . Type . Elem ( ) switch ert . Kind ( ) { case reflect . Uint 8 : if err ! = nil { return } if rv . Len ( ) = = 0 { } else { return default : einfo , err = cdc . get Type Info _wlock ( ert ) if err ! = nil { return } if err = json . Unmarshal ( bz , & raw Slice ) ; err ! = nil { return } if length = = 0 { rv . Set ( info . Zero Value ) return } var srv = reflect . Make Slice ( esrt , length , length ) for i : = 0 ; i < length ; i + + { erv : = srv . Index ( i ) ebz : = raw Slice [ i ] err = cdc . decode Reflect JSON ( ebz , einfo , erv , fopts ) if err ! = nil { return } } return } } 
func ( cdc * Codec ) decode Reflect JSONStruct ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } err = json . Unmarshal ( bz , & raw Map ) if err ! = nil { return } for _ , field : = range info . Fields { var finfo * Type Info finfo , err = cdc . get Type Info _wlock ( field . Type ) if err ! = nil { return } if len ( value Bytes ) = = 0 { continue } if err ! = nil { return } } return nil } 
func ( cdc * Codec ) decode Reflect JSONMap ( bz [ ] byte , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Can Addr ( ) { panic ( " " ) } if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } err = json . Unmarshal ( bz , & raw Map ) if err ! = nil { return } var krt = rv . Type ( ) . Key ( ) if krt . Kind ( ) ! = reflect . String { err = fmt . Errorf ( " " ) return } var vinfo * Type Info vinfo , err = cdc . get Type Info _wlock ( rv . Type ( ) . Elem ( ) ) if err ! = nil { return } var mrv = reflect . Make Map With Size ( rv . Type ( ) , len ( raw Map ) ) for key , value Bytes : = range raw Map { if err ! = nil { return } krv . Set String ( key ) mrv . Set Map Index ( krv , vrv ) } rv . Set ( mrv ) return nil } 
func decode Interface JSON ( bz [ ] byte ) ( name string , data [ ] byte , err error ) { dfw : = new ( disfix Wrapper ) err = json . Unmarshal ( bz , dfw ) if err ! = nil { err = fmt . Errorf ( " " , err ) return } return } name = dfw . Name return } data = dfw . Data return } 
func get Type From Pointer ( ptr interface { } ) reflect . Type { rt : = reflect . Type Of ( ptr ) if rt . Kind ( ) ! = reflect . Ptr { panic ( fmt . Sprintf ( " " , rt ) ) } return rt . Elem ( ) } 
func slide ( bz * [ ] byte , n * int , _n int ) bool { if _n < 0 | | _n > len ( * bz ) { panic ( fmt . Sprintf ( " " , len ( * bz ) , _n ) ) } * bz = ( * bz ) [ _n : ] if n ! = nil { * n + = _n } return true } 
func deref Pointers ( rv reflect . Value ) ( drv reflect . Value , is Ptr bool , is Nil Ptr bool ) { for rv . Kind ( ) = = reflect . Ptr { is Ptr = true if rv . Is Nil ( ) { is Nil Ptr = true return } rv = rv . Elem ( ) } drv = rv return } 
func deref Pointers Zero ( rv reflect . Value ) ( drv reflect . Value , is Ptr bool , is Nil Ptr bool ) { for rv . Kind ( ) = = reflect . Ptr { is Ptr = true if rv . Is Nil ( ) { is Nil Ptr = true rt : = rv . Type ( ) . Elem ( ) for rt . Kind ( ) = = reflect . Ptr { rt = rt . Elem ( ) } drv = reflect . New ( rt ) . Elem ( ) return } rv = rv . Elem ( ) } drv = rv return } 
func is Default Value ( rv reflect . Value ) ( erv reflect . Value , is Default Value bool ) { rv , _ , is Nil Ptr : = deref Pointers ( rv ) if is Nil Ptr { return rv , true } else { switch rv . Kind ( ) { case reflect . Bool : return rv , rv . Bool ( ) = = false case reflect . Int , reflect . Int 8 , reflect . Int 1 6 , reflect . Int 3 2 , reflect . Int 6 4 : return rv , rv . Int ( ) = = 0 case reflect . Uint , reflect . Uint 8 , reflect . Uint 1 6 , reflect . Uint 3 2 , reflect . Uint 6 4 : return rv , rv . Uint ( ) = = 0 case reflect . String : return rv , rv . Len ( ) = = 0 case reflect . Chan , reflect . Map , reflect . Slice : return rv , rv . Is Nil ( ) | | rv . Len ( ) = = 0 case reflect . Func , reflect . Interface : return rv , rv . Is Nil ( ) default : return rv , false } } } 
func default Value ( rt reflect . Type ) ( rv reflect . Value ) { switch rt . Kind ( ) { case reflect . Ptr : for rt _ . Kind ( ) = = reflect . Ptr { rt _ = rt _ . Elem ( ) } switch rt _ { case time Type : rt _ , rv _ : = rt , rv for rt _ . Kind ( ) = = reflect . Ptr { new Ptr : = reflect . New ( rt _ . Elem ( ) ) rv _ . Set ( new Ptr ) rt _ = rt _ . Elem ( ) rv _ = rv _ . Elem ( ) } return rv } case reflect . Struct : switch rt { case time Type : rv . Set ( reflect . Value Of ( zero Time ) ) return rv } } } 
func construct Concrete Type ( cinfo * Type Info ) ( crv , irv Set reflect . Value ) { crv = c Ptr Rv . Elem ( ) irv Set = c Ptr Rv } else { crv = reflect . New ( cinfo . Type ) . Elem ( ) irv Set = crv } return } 
func type To Typ 3 ( rt reflect . Type , opts Field Options ) Typ 3 { switch rt . Kind ( ) { case reflect . Interface : return Typ 3 _Byte Length case reflect . Array , reflect . Slice : return Typ 3 _Byte Length case reflect . String : return Typ 3 _Byte Length case reflect . Struct , reflect . Map : return Typ 3 _Byte Length case reflect . Int 6 4 , reflect . Uint 6 4 : if opts . Bin Fixed 6 4 { return Typ 3 _ 8Byte } else { return Typ 3 _Varint } case reflect . Int 3 2 , reflect . Uint 3 2 : if opts . Bin Fixed 3 2 { return Typ 3 _ 4Byte } else { return Typ 3 _Varint } case reflect . Int 1 6 , reflect . Int 8 , reflect . Int , reflect . Uint 1 6 , reflect . Uint 8 , reflect . Uint , reflect . Bool : return Typ 3 _Varint case reflect . Float 6 4 : return Typ 3 _ 8Byte case reflect . Float 3 2 : return Typ 3 _ 4Byte default : panic ( fmt . Sprintf ( " " , rt ) ) } } 
func slide ( bz Ptr * [ ] byte , n * int , _n int ) bool { if len ( * bz Ptr ) < _n { panic ( " " ) } * bz Ptr = ( * bz Ptr ) [ _n : ] * n + = _n return true } 
func ( cdc * Codec ) encode Reflect JSON ( w io . Writer , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if ! rv . Is Valid ( ) { panic ( " " ) } if print Log { spew . Printf ( " \n " , info , rv . Interface ( ) , rv . Type ( ) , fopts ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } rv , _ , is Nil Ptr = deref Pointers ( rv ) return } rv = reflect . Value Of ( ct ) } return } } else if rv . Type ( ) . Implements ( json Marshaler Type ) { err = invoke Marshal JSON ( w , rv ) return } rrv , err = to Repr Object ( rv ) if err ! = nil { return } rinfo , err = cdc . get Type Info _wlock ( info . Amino Marshal Repr Type ) if err ! = nil { return } return } switch info . Type . Kind ( ) { case reflect . Array , reflect . Slice : return cdc . encode Reflect JSONList ( w , info , rv , fopts ) case reflect . Struct : return cdc . encode Reflect JSONStruct ( w , info , rv , fopts ) case reflect . Map : return cdc . encode Reflect JSONMap ( w , info , rv , fopts ) return case reflect . Uint 6 4 , reflect . Uint : _ , err = fmt . Fprintf ( w , ` " %d " ` , rv . Uint ( ) ) return case reflect . Int 3 2 , reflect . Int 1 6 , reflect . Int 8 , reflect . Uint 3 2 , reflect . Uint 1 6 , reflect . Uint 8 : return invoke Stdlib JSONMarshal ( w , rv . Interface ( ) ) } fallthrough case reflect . Bool , reflect . String : return invoke Stdlib JSONMarshal ( w , rv . Interface ( ) ) } } 
func ( cdc * Codec ) encode Reflect JSONMap ( w io . Writer , info * Type Info , rv reflect . Value , fopts Field Options ) ( err error ) { if print Log { fmt . Println ( " " ) defer func ( ) { fmt . Printf ( " \n " , err ) } ( ) } if err ! = nil { return } } } ( ) return } var write Comma = false for _ , krv : = range rv . Map Keys ( ) { if err ! = nil { return } write Comma = false } if err ! = nil { return } if err ! = nil { return } } else { var vinfo * Type Info vinfo , err = cdc . get Type Info _wlock ( vrv . Type ( ) ) if err ! = nil { return } err = cdc . encode Reflect JSON ( w , vinfo , vrv , fopts ) } if err ! = nil { return } write Comma = true } return } 
func invoke Marshal JSON ( w io . Writer , rv reflect . Value ) error { blob , err : = rv . Interface ( ) . ( json . Marshaler ) . Marshal JSON ( ) if err ! = nil { return err } _ , err = w . Write ( blob ) return err } 
func is Empty ( rv reflect . Value , zrv reflect . Value ) bool { if ! rv . Is Valid ( ) { return true } if reflect . Deep Equal ( rv . Interface ( ) , zrv . Interface ( ) ) { return true } switch rv . Kind ( ) { case reflect . Slice , reflect . Array , reflect . String : if rv . Len ( ) = = 0 { return true } } return false } 
func Encode Int 8 ( w io . Writer , i int 8 ) ( err error ) { return Encode Varint ( w , int 6 4 ( i ) ) } 
func Encode Byte ( w io . Writer , b byte ) ( err error ) { return Encode Uvarint ( w , uint 6 4 ( b ) ) } 
func Encode Uvarint ( w io . Writer , u uint 6 4 ) ( err error ) { var buf [ 1 0 ] byte n : = binary . Put Uvarint ( buf [ : ] , u ) _ , err = w . Write ( buf [ 0 : n ] ) return } 
func Encode Bool ( w io . Writer , b bool ) ( err error ) { if b { err = Encode Uint 8 ( w , 1 ) } else { err = Encode Uint 8 ( w , 0 ) } return } 
func Encode Float 3 2 ( w io . Writer , f float 3 2 ) ( err error ) { return Encode Uint 3 2 ( w , math . Float 3 2bits ( f ) ) } 
func Encode Float 6 4 ( w io . Writer , f float 6 4 ) ( err error ) { return Encode Uint 6 4 ( w , math . Float 6 4bits ( f ) ) } 
func Encode Time ( w io . Writer , t time . Time ) ( err error ) { s : = t . Unix ( ) } err = encode Field Number And Typ 3 ( w , 1 , Typ 3 _Varint ) if err ! = nil { return } err = Encode Uvarint ( w , uint 6 4 ( s ) ) if err ! = nil { return } } ns : = int 3 2 ( t . Nanosecond ( ) ) } err = encode Field Number And Typ 3 ( w , 2 , Typ 3 _Varint ) if err ! = nil { return } err = Encode Uvarint ( w , uint 6 4 ( ns ) ) if err ! = nil { return } } return } 
func Decode Int 8 ( bz [ ] byte ) ( i int 8 , n int , err error ) { var i 6 4 = int 6 4 ( 0 ) i 6 4 , n , err = Decode Varint ( bz ) if err ! = nil { return } if i 6 4 < int 6 4 ( math . Min Int 8 ) | | i 6 4 > int 6 4 ( math . Max Int 8 ) { err = errors . New ( " " ) return } i = int 8 ( i 6 4 ) return } 
func Decode Byte ( bz [ ] byte ) ( b byte , n int , err error ) { return Decode Uint 8 ( bz ) } 
func Decode Bool ( bz [ ] byte ) ( b bool , n int , err error ) { const size int = 1 if len ( bz ) < size { err = errors . New ( " " ) return } switch bz [ 0 ] { case 0 : b = false case 1 : b = true default : err = errors . New ( " " ) } n = size return } 
func Decode Float 3 2 ( bz [ ] byte ) ( f float 3 2 , n int , err error ) { const size int = 4 if len ( bz ) < size { err = errors . New ( " " ) return } i : = binary . Little Endian . Uint 3 2 ( bz [ : size ] ) f = math . Float 3 2frombits ( i ) n = size return } 
func Decode Float 6 4 ( bz [ ] byte ) ( f float 6 4 , n int , err error ) { const size int = 8 if len ( bz ) < size { err = errors . New ( " " ) return } i : = binary . Little Endian . Uint 6 4 ( bz [ : size ] ) f = math . Float 6 4frombits ( i ) n = size return } 
func Decode Time ( bz [ ] byte ) ( t time . Time , n int , err error ) { var nsec int 3 2 if len ( bz ) > 0 { sec , n , err = decode Seconds ( & bz ) if err ! = nil { return } } if len ( bz ) > 0 { nsec , err = decode Nanos ( & bz , & n ) if err ! = nil { return } } return } 
func Deep Copy ( o interface { } ) ( r interface { } ) { if o = = nil { return nil } src : = reflect . Value Of ( o ) dst : = reflect . New ( src . Type ( ) ) . Elem ( ) deep Copy ( src , dst ) return dst . Interface ( ) } 
func call Deep Copy ( src , dst reflect . Value ) bool { dc : = src . Method By Name ( " " ) if ! dc . Is Valid ( ) { return false } if dc . Type ( ) . Num In ( ) ! = 0 { return false } if dc . Type ( ) . Num Out ( ) ! = 1 { return false } otype : = dc . Type ( ) . Out ( 0 ) if dst . Kind ( ) = = reflect . Ptr & & dst . Type ( ) . Elem ( ) = = otype { cpy : = reflect . New ( dst . Type ( ) . Elem ( ) ) out : = dc . Call ( nil ) [ 0 ] cpy . Elem ( ) . Set ( out ) dst . Set ( cpy ) return true } if dst . Type ( ) = = otype { out : = dc . Call ( nil ) [ 0 ] dst . Set ( out ) return true } return false } 
func call Amino Copy ( src , dst reflect . Value ) bool { if src . Type ( ) ! = dst . Type ( ) { panic ( " " ) } if src . Kind ( ) = = reflect . Ptr { cpy : = reflect . New ( src . Type ( ) . Elem ( ) ) dst . Set ( cpy ) } else if src . Can Addr ( ) { if ! dst . Can Addr ( ) { panic ( " " ) } src = src . Addr ( ) dst = dst . Addr ( ) } else { return false } if ! can Amino Copy ( src ) { return false } cpy : = reflect . New ( src . Type ( ) . Elem ( ) ) dst . Set ( cpy ) ma : = src . Method By Name ( " " ) ua : = dst . Method By Name ( " " ) outs : = ma . Call ( nil ) repr , err : = outs [ 0 ] , outs [ 1 ] if ! err . Is Nil ( ) { panic ( err . Interface ( ) ) } outs = ua . Call ( [ ] reflect . Value { repr } ) err = outs [ 0 ] if ! err . Is Nil ( ) { panic ( err . Interface ( ) ) } return true } 
func ( cdc * Codec ) Marshal Binary Length Prefixed ( o interface { } ) ( [ ] byte , error ) { if err ! = nil { return nil , err } if err ! = nil { return nil , err } if err ! = nil { return nil , err } return buf . Bytes ( ) , nil } 
func ( cdc * Codec ) Marshal Binary Length Prefixed Writer ( w io . Writer , o interface { } ) ( n int 6 4 , err error ) { var bz , _n = [ ] byte ( nil ) , int ( 0 ) bz , err = cdc . Marshal Binary Length Prefixed ( o ) if err ! = nil { return 0 , err } _n , err = w . Write ( bz ) n = int 6 4 ( _n ) return } 
func ( cdc * Codec ) Must Marshal Binary Length Prefixed ( o interface { } ) [ ] byte { bz , err : = cdc . Marshal Binary Length Prefixed ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * Codec ) Marshal Binary Bare ( o interface { } ) ( [ ] byte , error ) { if is Nil Ptr { } buf : = new ( bytes . Buffer ) rt : = rv . Type ( ) info , err : = cdc . get Type Info _wlock ( rt ) if err ! = nil { return nil , err } err = cdc . encode Reflect Binary ( buf , info , rv , Field Options { Bin Field Num : 1 } , true ) if err ! = nil { return nil , err } bz = buf . Bytes ( ) bz = append ( pb , bz . . . ) } return bz , nil } 
func ( cdc * Codec ) Must Marshal Binary Bare ( o interface { } ) [ ] byte { bz , err : = cdc . Marshal Binary Bare ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * Codec ) Unmarshal Binary Length Prefixed ( bz [ ] byte , ptr interface { } ) error { if len ( bz ) = = 0 { return errors . New ( " " ) } if n < 0 { return fmt . Errorf ( " " , n ) } if u 6 4 > uint 6 4 ( len ( bz ) - n ) { return fmt . Errorf ( " " , u 6 4 , len ( bz ) - n ) } else if u 6 4 < uint 6 4 ( len ( bz ) - n ) { return fmt . Errorf ( " " , u 6 4 , len ( bz ) - n ) } bz = bz [ n : ] } 
func ( cdc * Codec ) Unmarshal Binary Length Prefixed Reader ( r io . Reader , ptr interface { } , max Size int 6 4 ) ( n int 6 4 , err error ) { if max Size < 0 { panic ( " " ) } var buf [ binary . Max Varint Len 6 4 ] byte for i : = 0 ; i < len ( buf ) ; i + + { _ , err = r . Read ( buf [ i : i + 1 ] ) if err ! = nil { return } n + = 1 if buf [ i ] & 0x 8 0 = = 0 { break } if n > = max Size { err = fmt . Errorf ( " " , max Size ) } } u 6 4 , _ : = binary . Uvarint ( buf [ : ] ) if err ! = nil { return } if max Size > 0 { if uint 6 4 ( max Size ) < u 6 4 { err = fmt . Errorf ( " " , max Size , u 6 4 ) return } if ( max Size - n ) < int 6 4 ( u 6 4 ) { err = fmt . Errorf ( " " , max Size , n , u 6 4 ) return } } l = int 6 4 ( u 6 4 ) if l < 0 { err = fmt . Errorf ( " " ) } _ , err = io . Read Full ( r , bz ) if err ! = nil { return } n + = l return } 
func ( cdc * Codec ) Must Unmarshal Binary Length Prefixed ( bz [ ] byte , ptr interface { } ) { err : = cdc . Unmarshal Binary Length Prefixed ( bz , ptr ) if err ! = nil { panic ( err ) } } 
func ( cdc * Codec ) Unmarshal Binary Bare ( bz [ ] byte , ptr interface { } ) error { rv : = reflect . Value Of ( ptr ) if rv . Kind ( ) ! = reflect . Ptr { panic ( " " ) } rv = rv . Elem ( ) rt : = rv . Type ( ) info , err : = cdc . get Type Info _wlock ( rt ) if err ! = nil { return err } if len ( bz ) < 4 { return fmt . Errorf ( " " , pb , bz ) } else if ! bytes . Equal ( bz [ : 4 ] , pb ) { return fmt . Errorf ( " " , pb , bz [ : 4 ] ) } bz = bz [ 4 : ] } if err ! = nil { return fmt . Errorf ( " " , info . Type , n , err , bz ) } if n ! = len ( bz ) { return fmt . Errorf ( " " , info . Type , len ( bz ) , n , bz ) } return nil } 
func ( cdc * Codec ) Must Unmarshal Binary Bare ( bz [ ] byte , ptr interface { } ) { err : = cdc . Unmarshal Binary Bare ( bz , ptr ) if err ! = nil { panic ( err ) } } 
func ( cdc * Codec ) Must Marshal JSON ( o interface { } ) [ ] byte { bz , err : = cdc . Marshal JSON ( o ) if err ! = nil { panic ( err ) } return bz } 
func ( cdc * Codec ) Must Unmarshal JSON ( bz [ ] byte , ptr interface { } ) { if err : = cdc . Unmarshal JSON ( bz , ptr ) ; err ! = nil { panic ( err ) } } 
func ( cdc * Codec ) Marshal JSONIndent ( o interface { } , prefix , indent string ) ( [ ] byte , error ) { bz , err : = cdc . Marshal JSON ( o ) if err ! = nil { return nil , err } var out bytes . Buffer err = json . Indent ( & out , bz , prefix , indent ) if err ! = nil { return nil , err } return out . Bytes ( ) , nil } 
func Dial To ( addr string ) ( * Conn , error ) { const network = " " if " " = = addr { addr = " " } conn , err : = net . Dial ( network , addr ) if nil ! = err { return nil , err } data Reader : = new Data Reader ( conn ) data Writer : = new Data Writer ( conn ) client Conn : = Conn { conn : conn , data Reader : data Reader , data Writer : data Writer , } return & client Conn , nil } 
func Dial To TLS ( addr string , tls Config * tls . Config ) ( * Conn , error ) { const network = " " if " " = = addr { addr = " " } conn , err : = tls . Dial ( network , addr , tls Config ) if nil ! = err { return nil , err } data Reader : = new Data Reader ( conn ) data Writer : = new Data Writer ( conn ) client Conn : = Conn { conn : conn , data Reader : data Reader , data Writer : data Writer , } return & client Conn , nil } 
func ( client Conn * Conn ) Read ( p [ ] byte ) ( n int , err error ) { return client Conn . data Reader . Read ( p ) } 
func ( client Conn * Conn ) Write ( p [ ] byte ) ( n int , err error ) { return client Conn . data Writer . Write ( p ) } 
func new Data Reader ( r io . Reader ) * internal Data Reader { buffered : = bufio . New Reader ( r ) reader : = internal Data Reader { wrapped : r , buffered : buffered , } return & reader } 
func ( r * internal Data Reader ) Read ( data [ ] byte ) ( n int , err error ) { const IAC = 2 5 5 const SB = 2 5 0 const SE = 2 4 0 const WILL = 2 5 1 const WONT = 2 5 2 const DO = 2 5 3 const DONT = 2 5 4 p : = data for len ( p ) > 0 { var b byte b , err = r . buffered . Read Byte ( ) if nil ! = err { return n , err } if IAC = = b { var peeked [ ] byte peeked , err = r . buffered . Peek ( 1 ) if nil ! = err { return n , err } switch peeked [ 0 ] { case WILL , WONT , DO , DONT : _ , err = r . buffered . Discard ( 2 ) if nil ! = err { return n , err } case IAC : p [ 0 ] = IAC n + + p = p [ 1 : ] _ , err = r . buffered . Discard ( 1 ) if nil ! = err { return n , err } case SB : for { var b 2 byte b 2 , err = r . buffered . Read Byte ( ) if nil ! = err { return n , err } if IAC = = b 2 { peeked , err = r . buffered . Peek ( 1 ) if nil ! = err { return n , err } if IAC = = peeked [ 0 ] { _ , err = r . buffered . Discard ( 1 ) if nil ! = err { return n , err } } if SE = = peeked [ 0 ] { _ , err = r . buffered . Discard ( 1 ) if nil ! = err { return n , err } break } } } case SE : _ , err = r . buffered . Discard ( 1 ) if nil ! = err { return n , err } default : return n , err } } else { p [ 0 ] = b n + + p = p [ 1 : ] } } return n , nil } 
func Listen And Serve TLS ( addr string , cert File string , key File string , handler Handler ) error { server : = & Server { Addr : addr , Handler : handler } return server . Listen And Serve TLS ( cert File , key File ) } 
func ( server * Server ) Listen And Serve TLS ( cert File string , key File string ) error { addr : = server . Addr if " " = = addr { addr = " " } listener , err : = net . Listen ( " " , addr ) if nil ! = err { return err } if nil = = server . TLSConfig { tls Config = & tls . Config { } } else { tls Config = & tls . Config { Rand : server . TLSConfig . Rand , Time : server . TLSConfig . Time , Certificates : server . TLSConfig . Certificates , Name To Certificate : server . TLSConfig . Name To Certificate , Get Certificate : server . TLSConfig . Get Certificate , Root CAs : server . TLSConfig . Root CAs , Next Protos : server . TLSConfig . Next Protos , Server Name : server . TLSConfig . Server Name , Client Auth : server . TLSConfig . Client Auth , Client CAs : server . TLSConfig . Client CAs , Insecure Skip Verify : server . TLSConfig . Insecure Skip Verify , Cipher Suites : server . TLSConfig . Cipher Suites , Prefer Server Cipher Suites : server . TLSConfig . Prefer Server Cipher Suites , Session Tickets Disabled : server . TLSConfig . Session Tickets Disabled , Session Ticket Key : server . TLSConfig . Session Ticket Key , Client Session Cache : server . TLSConfig . Client Session Cache , Min Version : server . TLSConfig . Min Version , Max Version : server . TLSConfig . Max Version , Curve Preferences : server . TLSConfig . Curve Preferences , } } tls Config Has Certificate : = len ( tls Config . Certificates ) > 0 | | nil ! = tls Config . Get Certificate if " " = = cert File | | " " = = key File | | ! tls Config Has Certificate { tls Config . Certificates = make ( [ ] tls . Certificate , 1 ) var err error tls Config . Certificates [ 0 ] , err = tls . Load X 5 0 9Key Pair ( cert File , key File ) if nil ! = err { return err } } tls Listener : = tls . New Listener ( listener , tls Config ) return server . Serve ( tls Listener ) } 
func new Data Writer ( w io . Writer ) * internal Data Writer { writer : = internal Data Writer { wrapped : w , } return & writer } 
func ( w * internal Data Writer ) Write ( data [ ] byte ) ( n int , err error ) { var n 6 4 int 6 4 n 6 4 , err = w . write 6 4 ( data ) n = int ( n 6 4 ) if int 6 4 ( n ) ! = n 6 4 { panic ( err Overflow ) } return n , err } 
func ( fn Producer Func ) Produce ( ctx telnet . Context , name string , args . . . string ) Handler { return fn ( ctx , name , args . . . ) } 
func Promote Handler Func ( fn Handler Func , args . . . string ) Handler { stdin , stdin Pipe : = io . Pipe ( ) stdout Pipe , stdout : = io . Pipe ( ) stderr Pipe , stderr : = io . Pipe ( ) args Copy : = make ( [ ] string , len ( args ) ) for i , datum : = range args { args Copy [ i ] = datum } handler : = internal Promoted Handler Func { err : nil , fn : fn , stdin : stdin , stdout : stdout , stderr : stderr , stdin Pipe : stdin Pipe , stdout Pipe : stdout Pipe , stderr Pipe : stderr Pipe , args : args Copy , } return & handler } 
func Serve ( listener net . Listener , handler Handler ) error { server : = & Server { Handler : handler } return server . Serve ( listener ) } 
func ( server * Server ) Listen And Serve ( ) error { addr : = server . Addr if " " = = addr { addr = " " } listener , err : = net . Listen ( " " , addr ) if nil ! = err { return err } return server . Serve ( listener ) } 
func ( server * Server ) Serve ( listener net . Listener ) error { defer listener . Close ( ) logger : = server . logger ( ) handler : = server . Handler if nil = = handler { handler = Echo Handler } for { conn , err : = listener . Accept ( ) if err ! = nil { } logger . Debugf ( " " , conn . Remote Addr ( ) ) logger . Debugf ( " " , conn . Remote Addr ( ) ) } } 
func ( p * Parser ) Fail ( msg string ) { p . Write Usage ( os . Stderr ) fmt . Fprintln ( os . Stderr , " " , msg ) os . Exit ( - 1 ) } 
func ( p * Parser ) Write Usage ( w io . Writer ) { var positionals , options [ ] * spec for _ , spec : = range p . specs { if spec . positional { positionals = append ( positionals , spec ) } else { options = append ( options , spec ) } } if p . version ! = " " { fmt . Fprintln ( w , p . version ) } fmt . Fprintf ( w , " " , p . config . Program ) if ! spec . required { fmt . Fprint ( w , " " ) } fmt . Fprint ( w , synopsis ( spec , " " + spec . long ) ) if ! spec . required { fmt . Fprint ( w , " " ) } } up : = strings . To Upper ( spec . long ) if spec . multiple { if ! spec . required { fmt . Fprint ( w , " " ) } fmt . Fprintf ( w , " " , up , up ) if ! spec . required { fmt . Fprint ( w , " " ) } } else { fmt . Fprint ( w , up ) } } fmt . Fprint ( w , " \n " ) } 
func ( p * Parser ) Write Help ( w io . Writer ) { var positionals , options [ ] * spec for _ , spec : = range p . specs { if spec . positional { positionals = append ( positionals , spec ) } else { options = append ( options , spec ) } } if p . description ! = " " { fmt . Fprintln ( w , p . description ) } p . Write Usage ( w ) for _ , spec : = range positionals { left : = " " + strings . To Upper ( spec . long ) fmt . Fprint ( w , left ) if spec . help ! = " " { if len ( left ) + 2 < col Width { fmt . Fprint ( w , strings . Repeat ( " " , col Width - len ( left ) ) ) } else { fmt . Fprint ( w , " \n " + strings . Repeat ( " " , col Width ) ) } fmt . Fprint ( w , spec . help ) } fmt . Fprint ( w , " \n " ) } } for _ , spec : = range options { print Option ( w , spec ) } if p . version ! = " " { print Option ( w , & spec { boolean : true , long : " " , help : " " } ) } } 
func Must Parse ( dest . . . interface { } ) * Parser { p , err : = New Parser ( Config { } , dest . . . ) if err ! = nil { fmt . Println ( err ) os . Exit ( - 1 ) } err = p . Parse ( flags ( ) ) if err = = Err Help { p . Write Help ( os . Stdout ) os . Exit ( 0 ) } if err = = Err Version { fmt . Println ( p . version ) os . Exit ( 0 ) } if err ! = nil { p . Fail ( err . Error ( ) ) } return p } 
func Parse ( dest . . . interface { } ) error { p , err : = New Parser ( Config { } , dest . . . ) if err ! = nil { return err } return p . Parse ( flags ( ) ) } 
func walk Fields ( v reflect . Value , visit func ( field reflect . Struct Field , val reflect . Value , owner reflect . Type ) bool ) { t : = v . Type ( ) for i : = 0 ; i < t . Num Field ( ) ; i + + { field : = t . Field ( i ) val : = v . Field ( i ) expand : = visit ( field , val , t ) if expand & & field . Type . Kind ( ) = = reflect . Struct { walk Fields ( val , visit ) } } } 
func New Parser ( config Config , dests . . . interface { } ) ( * Parser , error ) { p : = Parser { config : config , } for _ , dest : = range dests { if dest , ok : = dest . ( Versioned ) ; ok { p . version = dest . Version ( ) } if dest , ok : = dest . ( Described ) ; ok { p . description = dest . Description ( ) } v : = reflect . Value Of ( dest ) if v . Kind ( ) ! = reflect . Ptr { panic ( fmt . Sprintf ( " " , v . Type ( ) ) ) } v = v . Elem ( ) if v . Kind ( ) ! = reflect . Struct { panic ( fmt . Sprintf ( " " , dest ) ) } var errs [ ] string walk Fields ( v , func ( field reflect . Struct Field , val reflect . Value , t reflect . Type ) bool { if tag = = " " { return false } } spec : = spec { long : strings . To Lower ( field . Name ) , dest : val , } help , exists : = field . Tag . Lookup ( " " ) if exists { spec . help = help } parseable , spec . boolean , spec . multiple = can Parse ( field . Type ) if ! parseable { errs = append ( errs , fmt . Sprintf ( " " , t . Name ( ) , field . Name , field . Type . String ( ) ) ) return false } var value string if pos : = strings . Index ( key , " " ) ; pos ! = - 1 { value = key [ pos + 1 : ] key = key [ : pos ] } switch { case strings . Has Prefix ( key , " " ) : errs = append ( errs , fmt . Sprintf ( " " , t . Name ( ) , field . Name ) ) case strings . Has Prefix ( key , " " ) : spec . long = key [ 2 : ] case strings . Has Prefix ( key , " " ) : if len ( key ) ! = 2 { errs = append ( errs , fmt . Sprintf ( " " , t . Name ( ) , field . Name ) ) return false } spec . short = key [ 1 : ] case key = = " " : spec . required = true case key = = " " : spec . positional = true case key = = " " : spec . separate = true case key = = " " : case key = = " " : } else { spec . env = strings . To Upper ( field . Name ) } default : errs = append ( errs , fmt . Sprintf ( " " , key , tag ) ) return false } } } p . specs = append ( p . specs , & spec ) } ) if len ( errs ) > 0 { return nil , errors . New ( strings . Join ( errs , " \n " ) ) } } if p . config . Program = = " " { p . config . Program = " " if len ( os . Args ) > 0 { p . config . Program = filepath . Base ( os . Args [ 0 ] ) } } return & p , nil } 
func ( p * Parser ) Parse ( args [ ] string ) error { } if arg = = " " { return Err Version } if arg = = " " { break } } } 
func process ( specs [ ] * spec , args [ ] string ) error { for _ , spec : = range specs { if spec . positional { continue } if spec . long ! = " " { option Map [ spec . long ] = spec } if spec . short ! = " " { option Map [ spec . short ] = spec } } } value , found : = os . Lookup Env ( spec . env ) if ! found { continue } if spec . multiple { if err ! = nil { return fmt . Errorf ( " " , spec . env , err , ) } if err = set Slice ( spec . dest , values , ! spec . separate ) ; err ! = nil { return fmt . Errorf ( " " , spec . env , err , ) } } else { if err : = scalar . Parse Value ( spec . dest , value ) ; err ! = nil { return fmt . Errorf ( " " , spec . env , err ) } } was Present [ spec ] = true } var positionals [ ] string if arg = = " " { allpositional = true continue } if ! is Flag ( arg ) | | allpositional { positionals = append ( positionals , arg ) continue } opt : = strings . Trim Left ( arg , " " ) if pos : = strings . Index ( opt , " " ) ; pos ! = - 1 { value = opt [ pos + 1 : ] opt = opt [ : pos ] } if ! ok { return fmt . Errorf ( " " , arg ) } was Present [ spec ] = true if value = = " " { for i + 1 < len ( args ) & & ! is Flag ( args [ i + 1 ] ) { values = append ( values , args [ i + 1 ] ) i + + if spec . separate { break } } } else { values = append ( values , value ) } err : = set Slice ( spec . dest , values , ! spec . separate ) if err ! = nil { return fmt . Errorf ( " " , arg , err ) } continue } } } if ! next Is Numeric ( spec . dest . Type ( ) , args [ i + 1 ] ) & & is Flag ( args [ i + 1 ] ) { return fmt . Errorf ( " " , arg ) } value = args [ i + 1 ] i + + } err : = scalar . Parse Value ( spec . dest , value ) if err ! = nil { return fmt . Errorf ( " " , arg , err ) } } } if len ( positionals ) = = 0 { break } was Present [ spec ] = true if spec . multiple { err : = set Slice ( spec . dest , positionals , true ) if err ! = nil { return fmt . Errorf ( " " , spec . long , err ) } positionals = nil } else { err : = scalar . Parse Value ( spec . dest , positionals [ 0 ] ) if err ! = nil { return fmt . Errorf ( " " , spec . long , err ) } positionals = positionals [ 1 : ] } } if len ( positionals ) > 0 { return fmt . Errorf ( " " , positionals [ 0 ] ) } if ! spec . positional { name = " " + spec . long } return fmt . Errorf ( " " , name ) } } return nil } 
func is Flag ( s string ) bool { return strings . Has Prefix ( s , " " ) & & strings . Trim Left ( s , " " ) ! = " " } 
func set Slice ( dest reflect . Value , values [ ] string , trunc bool ) error { if ! dest . Can Set ( ) { return fmt . Errorf ( " " ) } var ptr bool elem : = dest . Type ( ) . Elem ( ) if elem . Kind ( ) = = reflect . Ptr & & ! elem . Implements ( text Unmarshaler Type ) { ptr = true elem = elem . Elem ( ) } } for _ , s : = range values { v : = reflect . New ( elem ) if err : = scalar . Parse Value ( v . Elem ( ) , s ) ; err ! = nil { return err } if ! ptr { v = v . Elem ( ) } dest . Set ( reflect . Append ( dest , v ) ) } return nil } 
func can Parse ( t reflect . Type ) ( parseable , boolean , multiple bool ) { parseable = scalar . Can Parse ( t ) boolean = is Boolean ( t ) if parseable { return } } t = t . Elem ( ) } parseable = scalar . Can Parse ( t ) boolean = is Boolean ( t ) if parseable { return } } parseable = scalar . Can Parse ( t ) boolean = is Boolean ( t ) if parseable { return } return false , false , false } 
func is Boolean ( t reflect . Type ) bool { switch { case t . Implements ( text Unmarshaler Type ) : return false case t . Kind ( ) = = reflect . Bool : return true case t . Kind ( ) = = reflect . Ptr & & t . Elem ( ) . Kind ( ) = = reflect . Bool : return true default : return false } } 
func New From Map ( m map [ string ] interface { } ) * Tree { t : = & Tree { root : & node { } } for k , v : = range m { t . Insert ( k , v ) } return t } 
func ( t * Tree ) Insert ( s string , v interface { } ) ( interface { } , bool ) { var parent * node n : = t . root search : = s for { n . leaf . val = v return old , true } n . leaf = & leaf Node { key : s , val : v , } t . size + + return nil , false } n = n . get Edge ( search [ 0 ] ) parent . add Edge ( e ) t . size + + return nil , false } if common Prefix = = len ( n . prefix ) { search = search [ common Prefix : ] continue } child : = & node { prefix : search [ : common Prefix ] , } parent . update Edge ( search [ 0 ] , child ) n . prefix = n . prefix [ common Prefix : ] if len ( search ) = = 0 { child . leaf = leaf return nil , false } return nil , false } } 
func ( t * Tree ) Delete ( s string ) ( interface { } , bool ) { var parent * node var label byte n : = t . root search : = s for { } goto DELETE } label = search [ 0 ] n = n . get Edge ( label ) if n = = nil { break } } else { break } } return nil , false DELETE : n . leaf = nil t . size - - } } } return leaf . val , true } 
func ( t * Tree ) Delete Prefix ( s string ) int { return t . delete Prefix ( nil , t . root , s ) } 
func ( t * Tree ) delete Prefix ( parent , n * node , prefix string ) int { return false } ) if n . is Leaf ( ) { n . leaf = nil } n . edges = nil } t . size - = sub Tree Size return sub Tree Size } child : = n . get Edge ( label ) if child = = nil | | ( ! strings . Has Prefix ( child . prefix , prefix ) & & ! strings . Has Prefix ( prefix , child . prefix ) ) { return 0 } } else { prefix = prefix [ len ( child . prefix ) : ] } return t . delete Prefix ( n , child , prefix ) } 
func ( t * Tree ) Get ( s string ) ( interface { } , bool ) { n : = t . root search : = s for { } break } if n = = nil { break } } else { break } } return nil , false } 
func ( t * Tree ) Longest Prefix ( s string ) ( string , interface { } , bool ) { var last * leaf Node n : = t . root search : = s for { } } if n = = nil { break } } else { break } } if last ! = nil { return last . key , last . val , true } return " " , nil , false } 
func ( t * Tree ) Minimum ( ) ( string , interface { } , bool ) { n : = t . root for { if n . is Leaf ( ) { return n . leaf . key , n . leaf . val , true } if len ( n . edges ) > 0 { n = n . edges [ 0 ] . node } else { break } } return " " , nil , false } 
func ( t * Tree ) Walk Prefix ( prefix string , fn Walk Fn ) { n : = t . root search : = prefix for { return } if n = = nil { break } } else if strings . Has Prefix ( n . prefix , search ) { return } else { break } } } 
func ( t * Tree ) Walk Path ( path string , fn Walk Fn ) { n : = t . root search : = path for { } } if n = = nil { return } } else { break } } } 
func recursive Walk ( n * node , fn Walk Fn ) bool { } } } return false } 
func ( t * Tree ) To Map ( ) map [ string ] interface { } { out : = make ( map [ string ] interface { } , t . size ) t . Walk ( func ( k string , v interface { } ) bool { out [ k ] = v return false } ) return out } 
func checkip ( ip string ) ( iptype uint 3 2 , ipnum * big . Int , ipindex uint 3 2 ) { iptype = 0 ipnum = big . New Int ( 0 ) ipnumtmp : = big . New Int ( 0 ) ipindex = 0 ipaddress : = net . Parse IP ( ip ) if ipaddress ! = nil { v 4 : = ipaddress . To 4 ( ) if v 4 ! = nil { iptype = 4 ipnum . Set Bytes ( v 4 ) } else { v 6 : = ipaddress . To 1 6 ( ) if v 6 ! = nil { iptype = 6 ipnum . Set Bytes ( v 6 ) } } } if iptype = = 4 { if meta . ipv 4indexbaseaddr > 0 { ipnumtmp . Rsh ( ipnum , 1 6 ) ipnumtmp . Lsh ( ipnumtmp , 3 ) ipindex = uint 3 2 ( ipnumtmp . Add ( ipnumtmp , big . New Int ( int 6 4 ( meta . ipv 4indexbaseaddr ) ) ) . Uint 6 4 ( ) ) } } else if iptype = = 6 { if meta . ipv 6indexbaseaddr > 0 { ipnumtmp . Rsh ( ipnum , 1 1 2 ) ipnumtmp . Lsh ( ipnumtmp , 3 ) ipindex = uint 3 2 ( ipnumtmp . Add ( ipnumtmp , big . New Int ( int 6 4 ( meta . ipv 6indexbaseaddr ) ) ) . Uint 6 4 ( ) ) } } return } 
func readuint 8 ( pos int 6 4 ) uint 8 { var retval uint 8 data : = make ( [ ] byte , 1 ) _ , err : = f . Read At ( data , pos - 1 ) if err ! = nil { fmt . Println ( " " , err ) } retval = data [ 0 ] return retval } 
func readuint 3 2 ( pos uint 3 2 ) uint 3 2 { pos 2 : = int 6 4 ( pos ) var retval uint 3 2 data : = make ( [ ] byte , 4 ) _ , err : = f . Read At ( data , pos 2 - 1 ) if err ! = nil { fmt . Println ( " " , err ) } buf : = bytes . New Reader ( data ) err = binary . Read ( buf , binary . Little Endian , & retval ) if err ! = nil { fmt . Println ( " " , err ) } return retval } 
func readuint 1 2 8 ( pos uint 3 2 ) * big . Int { pos 2 : = int 6 4 ( pos ) retval : = big . New Int ( 0 ) data : = make ( [ ] byte , 1 6 ) _ , err : = f . Read At ( data , pos 2 - 1 ) if err ! = nil { fmt . Println ( " " , err ) } } retval . Set Bytes ( data ) return retval } 
func readstr ( pos uint 3 2 ) string { pos 2 : = int 6 4 ( pos ) var retval string lenbyte : = make ( [ ] byte , 1 ) _ , err : = f . Read At ( lenbyte , pos 2 ) if err ! = nil { fmt . Println ( " " , err ) } strlen : = lenbyte [ 0 ] data : = make ( [ ] byte , strlen ) _ , err = f . Read At ( data , pos 2 + 1 ) if err ! = nil { fmt . Println ( " " , err ) } retval = string ( data [ : strlen ] ) return retval } 
func Open ( dbpath string ) { max _ipv 6 _range . Set String ( " " , 1 0 ) var err error f , err = os . Open ( dbpath ) if err ! = nil { return } meta . databasetype = readuint 8 ( 1 ) meta . databasecolumn = readuint 8 ( 2 ) meta . databaseyear = readuint 8 ( 3 ) meta . databasemonth = readuint 8 ( 4 ) meta . databaseday = readuint 8 ( 5 ) meta . ipv 4databasecount = readuint 3 2 ( 6 ) meta . ipv 4databaseaddr = readuint 3 2 ( 1 0 ) meta . ipv 6databasecount = readuint 3 2 ( 1 4 ) meta . ipv 6databaseaddr = readuint 3 2 ( 1 8 ) meta . ipv 4indexbaseaddr = readuint 3 2 ( 2 2 ) meta . ipv 6indexbaseaddr = readuint 3 2 ( 2 6 ) meta . ipv 4columnsize = uint 3 2 ( meta . databasecolumn < < 2 ) meta . ipv 6columnsize = uint 3 2 ( 1 6 + ( ( meta . databasecolumn - 1 ) < < 2 ) ) dbt : = meta . databasetype country _enabled = true } if region _position [ dbt ] ! = 0 { region _position _offset = uint 3 2 ( region _position [ dbt ] - 1 ) < < 2 region _enabled = true } if city _position [ dbt ] ! = 0 { city _position _offset = uint 3 2 ( city _position [ dbt ] - 1 ) < < 2 city _enabled = true } if isp _position [ dbt ] ! = 0 { isp _position _offset = uint 3 2 ( isp _position [ dbt ] - 1 ) < < 2 isp _enabled = true } if domain _position [ dbt ] ! = 0 { domain _position _offset = uint 3 2 ( domain _position [ dbt ] - 1 ) < < 2 domain _enabled = true } if zipcode _position [ dbt ] ! = 0 { zipcode _position _offset = uint 3 2 ( zipcode _position [ dbt ] - 1 ) < < 2 zipcode _enabled = true } if latitude _position [ dbt ] ! = 0 { latitude _position _offset = uint 3 2 ( latitude _position [ dbt ] - 1 ) < < 2 latitude _enabled = true } if longitude _position [ dbt ] ! = 0 { longitude _position _offset = uint 3 2 ( longitude _position [ dbt ] - 1 ) < < 2 longitude _enabled = true } if timezone _position [ dbt ] ! = 0 { timezone _position _offset = uint 3 2 ( timezone _position [ dbt ] - 1 ) < < 2 timezone _enabled = true } if netspeed _position [ dbt ] ! = 0 { netspeed _position _offset = uint 3 2 ( netspeed _position [ dbt ] - 1 ) < < 2 netspeed _enabled = true } if iddcode _position [ dbt ] ! = 0 { iddcode _position _offset = uint 3 2 ( iddcode _position [ dbt ] - 1 ) < < 2 iddcode _enabled = true } if areacode _position [ dbt ] ! = 0 { areacode _position _offset = uint 3 2 ( areacode _position [ dbt ] - 1 ) < < 2 areacode _enabled = true } if weatherstationcode _position [ dbt ] ! = 0 { weatherstationcode _position _offset = uint 3 2 ( weatherstationcode _position [ dbt ] - 1 ) < < 2 weatherstationcode _enabled = true } if weatherstationname _position [ dbt ] ! = 0 { weatherstationname _position _offset = uint 3 2 ( weatherstationname _position [ dbt ] - 1 ) < < 2 weatherstationname _enabled = true } if mcc _position [ dbt ] ! = 0 { mcc _position _offset = uint 3 2 ( mcc _position [ dbt ] - 1 ) < < 2 mcc _enabled = true } if mnc _position [ dbt ] ! = 0 { mnc _position _offset = uint 3 2 ( mnc _position [ dbt ] - 1 ) < < 2 mnc _enabled = true } if mobilebrand _position [ dbt ] ! = 0 { mobilebrand _position _offset = uint 3 2 ( mobilebrand _position [ dbt ] - 1 ) < < 2 mobilebrand _enabled = true } if elevation _position [ dbt ] ! = 0 { elevation _position _offset = uint 3 2 ( elevation _position [ dbt ] - 1 ) < < 2 elevation _enabled = true } if usagetype _position [ dbt ] ! = 0 { usagetype _position _offset = uint 3 2 ( usagetype _position [ dbt ] - 1 ) < < 2 usagetype _enabled = true } metaok = true } 
func loadmessage ( mesg string ) IP 2Locationrecord { var x IP 2Locationrecord x . Country _short = mesg x . Country _long = mesg x . Region = mesg x . City = mesg x . Isp = mesg x . Domain = mesg x . Zipcode = mesg x . Timezone = mesg x . Netspeed = mesg x . Iddcode = mesg x . Areacode = mesg x . Weatherstationcode = mesg x . Weatherstationname = mesg x . Mcc = mesg x . Mnc = mesg x . Mobilebrand = mesg x . Usagetype = mesg return x } 
func query ( ipaddress string , mode uint 3 2 ) IP 2Locationrecord { x : = loadmessage ( not _supported ) return x } if iptype = = 0 { x = loadmessage ( invalid _address ) return x } var colsize uint 3 2 var baseaddr uint 3 2 var low uint 3 2 var high uint 3 2 var mid uint 3 2 var rowoffset uint 3 2 var rowoffset 2 uint 3 2 ipfrom : = big . New Int ( 0 ) ipto : = big . New Int ( 0 ) maxip : = big . New Int ( 0 ) if iptype = = 4 { baseaddr = meta . ipv 4databaseaddr high = meta . ipv 4databasecount maxip = max _ipv 4 _range colsize = meta . ipv 4columnsize } else { baseaddr = meta . ipv 6databaseaddr high = meta . ipv 6databasecount maxip = max _ipv 6 _range colsize = meta . ipv 6columnsize } high = readuint 3 2 ( ipindex + 4 ) } if ipno . Cmp ( maxip ) > = 0 { ipno = ipno . Sub ( ipno , big . New Int ( 1 ) ) } for low < = high { mid = ( ( low + high ) > > 1 ) rowoffset = baseaddr + ( mid * colsize ) rowoffset 2 = rowoffset + colsize if iptype = = 4 { ipfrom = big . New Int ( int 6 4 ( readuint 3 2 ( rowoffset ) ) ) ipto = big . New Int ( int 6 4 ( readuint 3 2 ( rowoffset 2 ) ) ) } else { ipfrom = readuint 1 2 8 ( rowoffset ) ipto = readuint 1 2 8 ( rowoffset 2 ) } if ipno . Cmp ( ipfrom ) > = 0 & & ipno . Cmp ( ipto ) < 0 { if iptype = = 6 { rowoffset = rowoffset + 1 2 } if mode & countryshort = = 1 & & country _enabled { x . Country _short = readstr ( readuint 3 2 ( rowoffset + country _position _offset ) ) } if mode & countrylong ! = 0 & & country _enabled { x . Country _long = readstr ( readuint 3 2 ( rowoffset + country _position _offset ) + 3 ) } if mode & region ! = 0 & & region _enabled { x . Region = readstr ( readuint 3 2 ( rowoffset + region _position _offset ) ) } if mode & city ! = 0 & & city _enabled { x . City = readstr ( readuint 3 2 ( rowoffset + city _position _offset ) ) } if mode & isp ! = 0 & & isp _enabled { x . Isp = readstr ( readuint 3 2 ( rowoffset + isp _position _offset ) ) } if mode & latitude ! = 0 & & latitude _enabled { x . Latitude = readfloat ( rowoffset + latitude _position _offset ) } if mode & longitude ! = 0 & & longitude _enabled { x . Longitude = readfloat ( rowoffset + longitude _position _offset ) } if mode & domain ! = 0 & & domain _enabled { x . Domain = readstr ( readuint 3 2 ( rowoffset + domain _position _offset ) ) } if mode & zipcode ! = 0 & & zipcode _enabled { x . Zipcode = readstr ( readuint 3 2 ( rowoffset + zipcode _position _offset ) ) } if mode & timezone ! = 0 & & timezone _enabled { x . Timezone = readstr ( readuint 3 2 ( rowoffset + timezone _position _offset ) ) } if mode & netspeed ! = 0 & & netspeed _enabled { x . Netspeed = readstr ( readuint 3 2 ( rowoffset + netspeed _position _offset ) ) } if mode & iddcode ! = 0 & & iddcode _enabled { x . Iddcode = readstr ( readuint 3 2 ( rowoffset + iddcode _position _offset ) ) } if mode & areacode ! = 0 & & areacode _enabled { x . Areacode = readstr ( readuint 3 2 ( rowoffset + areacode _position _offset ) ) } if mode & weatherstationcode ! = 0 & & weatherstationcode _enabled { x . Weatherstationcode = readstr ( readuint 3 2 ( rowoffset + weatherstationcode _position _offset ) ) } if mode & weatherstationname ! = 0 & & weatherstationname _enabled { x . Weatherstationname = readstr ( readuint 3 2 ( rowoffset + weatherstationname _position _offset ) ) } if mode & mcc ! = 0 & & mcc _enabled { x . Mcc = readstr ( readuint 3 2 ( rowoffset + mcc _position _offset ) ) } if mode & mnc ! = 0 & & mnc _enabled { x . Mnc = readstr ( readuint 3 2 ( rowoffset + mnc _position _offset ) ) } if mode & mobilebrand ! = 0 & & mobilebrand _enabled { x . Mobilebrand = readstr ( readuint 3 2 ( rowoffset + mobilebrand _position _offset ) ) } if mode & elevation ! = 0 & & elevation _enabled { f , _ : = strconv . Parse Float ( readstr ( readuint 3 2 ( rowoffset + elevation _position _offset ) ) , 3 2 ) x . Elevation = float 3 2 ( f ) } if mode & usagetype ! = 0 & & usagetype _enabled { x . Usagetype = readstr ( readuint 3 2 ( rowoffset + usagetype _position _offset ) ) } return x } else { if ipno . Cmp ( ipfrom ) < 0 { high = mid - 1 } else { low = mid + 1 } } } return x } 
func Printrecord ( x IP 2Locationrecord ) { fmt . Printf ( " \n " , x . Country _short ) fmt . Printf ( " \n " , x . Country _long ) fmt . Printf ( " \n " , x . Region ) fmt . Printf ( " \n " , x . City ) fmt . Printf ( " \n " , x . Isp ) fmt . Printf ( " \n " , x . Latitude ) fmt . Printf ( " \n " , x . Longitude ) fmt . Printf ( " \n " , x . Domain ) fmt . Printf ( " \n " , x . Zipcode ) fmt . Printf ( " \n " , x . Timezone ) fmt . Printf ( " \n " , x . Netspeed ) fmt . Printf ( " \n " , x . Iddcode ) fmt . Printf ( " \n " , x . Areacode ) fmt . Printf ( " \n " , x . Weatherstationcode ) fmt . Printf ( " \n " , x . Weatherstationname ) fmt . Printf ( " \n " , x . Mcc ) fmt . Printf ( " \n " , x . Mnc ) fmt . Printf ( " \n " , x . Mobilebrand ) fmt . Printf ( " \n " , x . Elevation ) fmt . Printf ( " \n " , x . Usagetype ) } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { gc . Save ( ) gc . Scale ( 0 . 5 , 0 . 5 ) gc . Restore ( ) } 
func Draw ( gc draw 2d . Graphic Context ) { gc . Set Line Cap ( draw 2d . Round Cap ) gc . Set Stroke Color ( color . Black ) gc . Move To ( 1 0 . 6 3 4 , 3 0 0 . 4 9 3 ) r Cubic Curve To ( gc , 0 . 7 6 4 , 1 5 . 7 5 1 , 1 6 . 4 9 9 , 8 . 4 6 3 , 2 3 . 6 2 6 , 3 . 5 3 9 ) r Cubic Curve To ( gc , 6 . 7 6 5 , - 4 . 6 7 5 , 8 . 7 4 3 , - 0 . 7 8 9 , 9 . 3 3 7 , - 1 0 . 0 1 5 ) r Cubic Curve To ( gc , 0 . 3 8 9 , - 6 . 0 6 4 , 1 . 0 8 8 , - 1 2 . 1 2 8 , 0 . 7 4 4 , - 1 8 . 2 1 6 ) r Cubic Curve To ( gc , - 1 0 . 2 3 , - 0 . 9 2 7 , - 2 1 . 3 5 7 , 1 . 5 0 9 , - 2 9 . 7 4 4 , 7 . 6 0 2 ) gc . Cubic Curve To ( 1 0 . 2 7 7 , 2 8 6 . 5 4 2 , 2 . 1 7 7 , 2 9 6 . 5 6 1 , 1 0 . 6 3 4 , 3 0 0 . 4 9 3 ) gc . Fill Stroke ( ) r Cubic Curve To ( gc , 2 . 2 9 , - 0 . 8 5 2 , 4 . 7 1 7 , - 1 . 4 5 7 , 6 . 2 7 1 , - 3 . 5 2 8 ) gc . Stroke ( ) gc . Cubic Curve To ( - 1 3 . 3 , 9 5 . 8 9 7 , 3 1 . 5 3 6 , 1 9 . 1 8 9 , 7 9 . 9 5 6 , 5 0 . 7 4 ) gc . Line To ( 4 6 . 9 9 7 , 1 1 2 . 8 5 3 ) gc . Close ( ) gc . Stroke ( ) } 
func Rectangle ( path draw 2d . Path Builder , x 1 , y 1 , x 2 , y 2 float 6 4 ) { path . Move To ( x 1 , y 1 ) path . Line To ( x 2 , y 1 ) path . Line To ( x 2 , y 2 ) path . Line To ( x 1 , y 2 ) path . Close ( ) } 
func Rounded Rectangle ( path draw 2d . Path Builder , x 1 , y 1 , x 2 , y 2 , arc Width , arc Height float 6 4 ) { arc Width = arc Width / 2 arc Height = arc Height / 2 path . Move To ( x 1 , y 1 + arc Height ) path . Quad Curve To ( x 1 , y 1 , x 1 + arc Width , y 1 ) path . Line To ( x 2 - arc Width , y 1 ) path . Quad Curve To ( x 2 , y 1 , x 2 , y 1 + arc Height ) path . Line To ( x 2 , y 2 - arc Height ) path . Quad Curve To ( x 2 , y 2 , x 2 - arc Width , y 2 ) path . Line To ( x 1 + arc Width , y 2 ) path . Quad Curve To ( x 1 , y 2 , x 1 , y 2 - arc Height ) path . Close ( ) } 
func Ellipse ( path draw 2d . Path Builder , cx , cy , rx , ry float 6 4 ) { path . Arc To ( cx , cy , rx , ry , 0 , - math . Pi * 2 ) path . Close ( ) } 
func Circle ( path draw 2d . Path Builder , cx , cy , radius float 6 4 ) { path . Arc To ( cx , cy , radius , radius , 0 , - math . Pi * 2 ) path . Close ( ) } 
func Save To Pdf File ( file Path string , pdf * gofpdf . Fpdf ) error { return pdf . Output File And Close ( file Path ) } 
func ( p * Path ) Move To ( x , y float 6 4 ) { p . append To Path ( Move To Cmp , x , y ) p . x = x p . y = y } 
func ( p * Path ) Cubic Curve To ( cx 1 , cy 1 , cx 2 , cy 2 , x , y float 6 4 ) { if len ( p . Components ) = = 0 { } else { p . append To Path ( Cubic Curve To Cmp , cx 1 , cy 1 , cx 2 , cy 2 , x , y ) } p . x = x p . y = y } 
func ( p * Path ) Arc To ( cx , cy , rx , ry , start Angle , angle float 6 4 ) { end Angle : = start Angle + angle clock Wise : = true if angle < 0 { clock Wise = false } } } else { for start Angle < end Angle { start Angle + = math . Pi * 2 . 0 } } start X : = cx + math . Cos ( start Angle ) * rx start Y : = cy + math . Sin ( start Angle ) * ry if len ( p . Components ) > 0 { p . Line To ( start X , start Y ) } else { p . Move To ( start X , start Y ) } p . append To Path ( Arc To Cmp , cx , cy , rx , ry , start Angle , angle ) p . x = cx + math . Cos ( end Angle ) * rx p . y = cy + math . Sin ( end Angle ) * ry } 
func ( p * Path ) String ( ) string { s : = " " j : = 0 for _ , cmd : = range p . Components { switch cmd { case Move To Cmp : s + = fmt . Sprintf ( " \n " , p . Points [ j ] , p . Points [ j + 1 ] ) j = j + 2 case Line To Cmp : s + = fmt . Sprintf ( " \n " , p . Points [ j ] , p . Points [ j + 1 ] ) j = j + 2 case Quad Curve To Cmp : s + = fmt . Sprintf ( " \n " , p . Points [ j ] , p . Points [ j + 1 ] , p . Points [ j + 2 ] , p . Points [ j + 3 ] ) j = j + 4 case Cubic Curve To Cmp : s + = fmt . Sprintf ( " \n " , p . Points [ j ] , p . Points [ j + 1 ] , p . Points [ j + 2 ] , p . Points [ j + 3 ] , p . Points [ j + 4 ] , p . Points [ j + 5 ] ) j = j + 6 case Arc To Cmp : s + = fmt . Sprintf ( " \n " , p . Points [ j ] , p . Points [ j + 1 ] , p . Points [ j + 2 ] , p . Points [ j + 3 ] , p . Points [ j + 4 ] , p . Points [ j + 5 ] ) j = j + 6 case Close Cmp : s + = " \n " } } return s } 
func ( path * Path ) Vertical Flip ( ) * Path { p : = path . Copy ( ) j : = 0 for _ , cmd : = range p . Components { switch cmd { case Move To Cmp , Line To Cmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] j = j + 2 case Quad Curve To Cmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] j = j + 4 case Cubic Curve To Cmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] p . Points [ j + 5 ] = - p . Points [ j + 5 ] j = j + 6 case Arc To Cmp : p . Points [ j + 1 ] = - p . Points [ j + 1 ] p . Points [ j + 3 ] = - p . Points [ j + 3 ] p . Points [ j + 4 ] = - p . Points [ j + 4 ] p . Points [ j + 5 ] = - p . Points [ j + 5 ] j = j + 6 case Close Cmp : } } p . y = - p . y return p } 
func New Glyph Cache ( ) * Glyph Cache Imp { glyphs : = make ( map [ string ] map [ rune ] * Glyph ) return & Glyph Cache Imp { glyphs : glyphs , } } 
func ( glyph Cache * Glyph Cache Imp ) Fetch ( gc draw 2d . Graphic Context , font Name string , chr rune ) * Glyph { if glyph Cache . glyphs [ font Name ] = = nil { glyph Cache . glyphs [ font Name ] = make ( map [ rune ] * Glyph , 6 0 ) } if glyph Cache . glyphs [ font Name ] [ chr ] = = nil { glyph Cache . glyphs [ font Name ] [ chr ] = render Glyph ( gc , font Name , chr ) } return glyph Cache . glyphs [ font Name ] [ chr ] . Copy ( ) } 
func render Glyph ( gc draw 2d . Graphic Context , font Name string , chr rune ) * Glyph { gc . Save ( ) defer gc . Restore ( ) gc . Begin Path ( ) width : = gc . Create String Path ( string ( chr ) , 0 , 0 ) path : = gc . Get Path ( ) return & Glyph { Path : & path , Width : width , } } 
func ( g * Glyph ) Copy ( ) * Glyph { return & Glyph { Path : g . Path . Copy ( ) , Width : g . Width , } } 
func ( g * Glyph ) Fill ( gc draw 2d . Graphic Context , x , y float 6 4 ) float 6 4 { gc . Save ( ) gc . Begin Path ( ) gc . Translate ( x , y ) gc . Fill ( g . Path ) gc . Restore ( ) return g . Width } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { gc . Set Fill Rule ( draw 2d . Fill Rule Winding ) gc . Clear ( ) } gc . Clear Rect ( 1 0 0 , 7 5 , 1 9 7 , 1 3 5 ) draw 2dkit . Ellipse ( gc , 1 4 8 . 5 , 1 0 5 , 3 5 , 2 5 ) gc . Set Fill Color ( color . RGBA { 0xff , 0xff , 0x 4 4 , 0xff } ) gc . Fill Stroke ( ) } 
func Draw ( gc draw 2d . Graphic Context , x 0 , y 0 , x 1 , y 1 float 6 4 ) { gc . Line To ( x 1 , y 1 ) gc . Stroke ( ) } 
func opti Sprintf ( format string , a . . . interface { } ) string { chunks : = strings . Split ( format , " " ) new Chunks : = make ( [ ] string , len ( chunks ) ) for i , chunk : = range chunks { if i ! = 0 { verb : = chunk [ 0 ] if verb = = 'f ' | | verb = = 'F ' { num : = a [ i - 1 ] . ( float 6 4 ) p : = strconv . Itoa ( get Prec ( num , verb = = 'F ' ) ) chunk = strings . Replace ( chunk , string ( verb ) , " " + p + " " , 1 ) } } new Chunks [ i ] = chunk } format = strings . Join ( new Chunks , " " ) return fmt . Sprintf ( format , a . . . ) } 
func get Prec ( num float 6 4 , better bool ) int { max : = 3 eps : = 0 . 0 0 0 5 if better { max = 6 eps = 0 . 0 0 0 0 0 0 5 } prec : = 0 for math . Mod ( num , 1 ) > eps { num * = 1 0 eps * = 1 0 prec + + } if max < prec { return max } return prec } 
func ( p * Painter ) Paint ( ss [ ] raster . Span , done bool ) { clenrequired : = sslen * 8 vlenrequired : = sslen * 4 if clenrequired > = ( cap ( p . colors ) - len ( p . colors ) ) { p . Flush ( ) if clenrequired > = cap ( p . colors ) { p . vertices = make ( [ ] int 3 2 , 0 , vlenrequired + ( vlenrequired / 2 ) ) p . colors = make ( [ ] uint 8 , 0 , clenrequired + ( clenrequired / 2 ) ) } } vi : = len ( p . vertices ) ci : = len ( p . colors ) p . vertices = p . vertices [ 0 : vi + vlenrequired ] p . colors = p . colors [ 0 : ci + clenrequired ] var ( colors [ ] uint 8 vertices [ ] int 3 2 ) for _ , s : = range ss { a : = uint 8 ( ( s . Alpha * p . ca / M 1 6 ) > > 8 ) colors = p . colors [ ci : ] colors [ 0 ] = p . cr colors [ 1 ] = p . cg colors [ 2 ] = p . cb colors [ 3 ] = a colors [ 4 ] = p . cr colors [ 5 ] = p . cg colors [ 6 ] = p . cb colors [ 7 ] = a ci + = 8 vertices = p . vertices [ vi : ] vertices [ 0 ] = int 3 2 ( s . X 0 ) vertices [ 1 ] = int 3 2 ( s . Y ) vertices [ 2 ] = int 3 2 ( s . X 1 ) vertices [ 3 ] = int 3 2 ( s . Y ) vi + = 4 } } 
func ( p * Painter ) Set Color ( c color . Color ) { r , g , b , a : = c . RGBA ( ) if a = = 0 { p . cr = 0 p . cg = 0 p . cb = 0 p . ca = a } else { p . cr = uint 8 ( ( r * M 1 6 / a ) > > 8 ) p . cg = uint 8 ( ( g * M 1 6 / a ) > > 8 ) p . cb = uint 8 ( ( b * M 1 6 / a ) > > 8 ) p . ca = a } } 
func New Painter ( ) * Painter { p : = new ( Painter ) p . vertices = make ( [ ] int 3 2 , 0 , 1 0 2 4 ) p . colors = make ( [ ] uint 8 , 0 , 1 0 2 4 ) return p } 
func New Graphic Context ( width , height int ) * Graphic Context { gc : = & Graphic Context { draw 2dbase . New Stack Graphic Context ( ) , New Painter ( ) , raster . New Rasterizer ( width , height ) , raster . New Rasterizer ( width , height ) , draw 2d . Get Global Font Cache ( ) , draw 2dbase . New Glyph Cache ( ) , & truetype . Glyph Buf { } , 9 2 , } return gc } 
func ( gc * Graphic Context ) Fill String ( text string ) ( width float 6 4 ) { return gc . Fill String At ( text , 0 , 0 ) } 
func ( gc * Graphic Context ) Fill String At ( text string , x , y float 6 4 ) ( width float 6 4 ) { f , err : = gc . load Current Font ( ) if err ! = nil { log . Println ( err ) return 0 . 0 } startx : = x prev , has Prev : = truetype . Index ( 0 ) , false font Name : = gc . Get Font Name ( ) for _ , r : = range text { index : = f . Index ( r ) if has Prev { x + = f Units To Float 6 4 ( f . Kern ( fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , prev , index ) ) } glyph : = gc . glyph Cache . Fetch ( gc , font Name , r ) x + = glyph . Fill ( gc , x , y ) prev , has Prev = index , true } return x - startx } 
func ( gc * Graphic Context ) Get String Bounds ( s string ) ( left , top , right , bottom float 6 4 ) { f , err : = gc . load Current Font ( ) if err ! = nil { log . Println ( err ) return 0 , 0 , 0 , 0 } top , left , bottom , right = 1 0e 6 , 1 0e 6 , - 1 0e 6 , - 1 0e 6 cursor : = 0 . 0 prev , has Prev : = truetype . Index ( 0 ) , false for _ , rune : = range s { index : = f . Index ( rune ) if has Prev { cursor + = f Units To Float 6 4 ( f . Kern ( fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , prev , index ) ) } if err : = gc . glyph Buf . Load ( gc . Current . Font , fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , index , font . Hinting None ) ; err ! = nil { log . Println ( err ) return 0 , 0 , 0 , 0 } e 0 : = 0 for _ , e 1 : = range gc . glyph Buf . Ends { ps : = gc . glyph Buf . Points [ e 0 : e 1 ] for _ , p : = range ps { x , y : = point To F 6 4Point ( p ) top = math . Min ( top , y ) bottom = math . Max ( bottom , y ) left = math . Min ( left , x + cursor ) right = math . Max ( right , x + cursor ) } } cursor + = f Units To Float 6 4 ( f . HMetric ( fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , index ) . Advance Width ) prev , has Prev = index , true } return left , top , right , bottom } 
func ( gc * Graphic Context ) Stroke String ( text string ) ( width float 6 4 ) { return gc . Stroke String At ( text , 0 , 0 ) } 
func ( gc * Graphic Context ) recalc ( ) { gc . Current . Scale = gc . Current . Font Size * float 6 4 ( gc . DPI ) * ( 6 4 . 0 / 7 2 . 0 ) } 
func ( gc * Graphic Context ) Set Font ( font * truetype . Font ) { gc . Current . Font = font } 
func ( gc * Graphic Context ) Set Font Size ( font Size float 6 4 ) { gc . Current . Font Size = font Size gc . recalc ( ) } 
func ( gc * Graphic Context ) Stroke ( paths . . . * draw 2d . Path ) { gc . draw Paths ( stroked , paths . . . ) gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) Fill ( paths . . . * draw 2d . Path ) { gc . draw Paths ( filled , paths . . . ) gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) Fill Stroke ( paths . . . * draw 2d . Path ) { gc . draw Paths ( filled | stroked , paths . . . ) gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) Fill String ( text string ) ( cursor float 6 4 ) { return gc . Fill String At ( text , 0 , 0 ) } 
func ( gc * Graphic Context ) Fill String At ( text string , x , y float 6 4 ) ( cursor float 6 4 ) { return gc . draw String ( text , filled , x , y ) } 
func ( gc * Graphic Context ) Stroke String ( text string ) ( cursor float 6 4 ) { return gc . Stroke String At ( text , 0 , 0 ) } 
func ( gc * Graphic Context ) Stroke String At ( text string , x , y float 6 4 ) ( cursor float 6 4 ) { return gc . draw String ( text , stroked , x , y ) } 
func ( gc * Graphic Context ) Draw Image ( image image . Image ) { bounds : = image . Bounds ( ) svg Image : = & Image { Href : image To Svg Href ( image ) } svg Image . X = float 6 4 ( bounds . Min . X ) svg Image . Y = float 6 4 ( bounds . Min . Y ) svg Image . Width = to Svg Length ( float 6 4 ( bounds . Max . X - bounds . Min . X ) ) svg Image . Height = to Svg Length ( float 6 4 ( bounds . Max . Y - bounds . Min . Y ) ) gc . new Group ( 0 ) . Image = svg Image } 
func ( gc * Graphic Context ) Clear Rect ( x 1 , y 1 , x 2 , y 2 int ) { mask : = gc . new Mask ( x 1 , y 1 , x 2 - x 1 , y 2 - y 1 ) new Group : = & Group { Groups : gc . svg . Groups , Mask : " " + mask . Id + " " , } } 
func ( gc * Graphic Context ) Create String Path ( s string , x , y float 6 4 ) ( cursor float 6 4 ) { f , err : = gc . load Current Font ( ) if err ! = nil { log . Println ( err ) return 0 . 0 } startx : = x prev , has Prev : = truetype . Index ( 0 ) , false for _ , rune : = range s { index : = f . Index ( rune ) if has Prev { x + = f Units To Float 6 4 ( f . Kern ( fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , prev , index ) ) } err : = gc . draw Glyph ( index , x , y ) if err ! = nil { log . Println ( err ) return startx - x } x + = f Units To Float 6 4 ( f . HMetric ( fixed . Int 2 6 _ 6 ( gc . Current . Scale ) , index ) . Advance Width ) prev , has Prev = index , true } return x - startx } 
func ( gc * Graphic Context ) draw Paths ( draw Type draw Type , paths . . . * draw 2d . Path ) { group : = gc . new Group ( draw Type ) svg Paths Desc : = make ( [ ] string , len ( paths ) ) } svg Path . Desc = strings . Join ( svg Paths Desc , " " ) } 
func ( gc * Graphic Context ) draw String ( text string , draw Type draw Type , x , y float 6 4 ) float 6 4 { switch gc . svg . Font Mode { case Path Font Mode : w : = gc . Create String Path ( text , x , y ) gc . draw Paths ( draw Type ) gc . Current . Path . Clear ( ) return w case Svg Font Mode : gc . embed Svg Font ( text ) } group : = gc . new Group ( draw Type ) svg Text . Font Size = gc . Current . Font Size svg Text . X = x svg Text . Y = y svg Text . Font Family = gc . Current . Font Data . Name left , _ , right , _ : = gc . Get String Bounds ( text ) return right - left } 
func ( gc * Graphic Context ) new Group ( draw Type draw Type ) * Group { group : = Group { } group . Stroke Width = to Svg Length ( gc . Current . Line Width ) group . Stroke Linecap = gc . Current . Cap . String ( ) group . Stroke Linejoin = gc . Current . Join . String ( ) if len ( gc . Current . Dash ) > 0 { group . Stroke Dasharray = to Svg Array ( gc . Current . Dash ) group . Stroke Dashoffset = to Svg Length ( gc . Current . Dash Offset ) } } if draw Type & filled = = filled { group . Fill = to Svg RGBA ( gc . Current . Fill Color ) group . Fill Rule = to Svg Fill Rule ( gc . Current . Fill Rule ) } group . Transform = to Svg Transform ( gc . Current . Tr ) return & group } 
func ( gc * Graphic Context ) new Mask ( x , y , width , height int ) * Mask { mask : = & Mask { } mask . X = float 6 4 ( x ) mask . Y = float 6 4 ( y ) mask . Width = to Svg Length ( float 6 4 ( width ) ) mask . Height = to Svg Length ( float 6 4 ( height ) ) mask . Id = " " + strconv . Itoa ( len ( gc . svg . Masks ) ) return mask } 
func ( gc * Graphic Context ) embed Svg Font ( text string ) * Font { font Name : = gc . Current . Font Data . Name gc . load Current Font ( ) for _ , font : = range gc . svg . Fonts { if font . Name = = font Name { svg Font = font break } } if svg Font = = nil { } defer gc . Restore ( ) gc . Set Font Size ( 2 0 4 8 ) defer gc . Set DPI ( gc . Get DPI ( ) ) gc . Set DPI ( 9 2 ) filling : for _ , rune : = range text { for _ , g : = range svg Font . Glyphs { if g . Rune = = Rune ( rune ) { continue filling } } glyph : = gc . glyph Cache . Fetch ( gc , gc . Get Font Name ( ) , rune ) svg Font . Glyphs = append ( svg Font . Glyphs , & Glyph { Rune : Rune ( rune ) , Desc : to Svg Path Desc ( glyp Path ) , Horiz Adv X : glyph . Width , } ) } svg Font . Name = font Name return svg Font } 
func Trace Quad ( t Liner , quad [ ] float 6 4 , flattening Threshold float 6 4 ) error { if len ( quad ) < 6 { return errors . New ( " " ) } copy ( curves [ 0 : 6 ] , quad [ 0 : 6 ] ) i : = 0 var dx , dy , d float 6 4 for i > = 0 { c = curves [ i : ] dx = c [ 4 ] - c [ 0 ] dy = c [ 5 ] - c [ 1 ] d = math . Abs ( ( ( c [ 2 ] - c [ 4 ] ) * dy - ( c [ 3 ] - c [ 5 ] ) * dx ) ) i - = 6 } else { i + = 6 } } return nil } 
func ( cs * Context Stack ) Get Font Name ( ) string { font Data : = cs . Font Data return fmt . Sprintf ( " " , font Data . Name , font Data . Family , font Data . Style , cs . Font Size ) } 
func New Stack Graphic Context ( ) * Stack Graphic Context { gc : = & Stack Graphic Context { } gc . Current = new ( Context Stack ) gc . Current . Tr = draw 2d . New Identity Matrix ( ) gc . Current . Path = new ( draw 2d . Path ) gc . Current . Line Width = 1 . 0 gc . Current . Stroke Color = image . Black gc . Current . Fill Color = image . White gc . Current . Cap = draw 2d . Round Cap gc . Current . Fill Rule = draw 2d . Fill Rule Even Odd gc . Current . Join = draw 2d . Round Join gc . Current . Font Size = 1 0 gc . Current . Font Data = Default Font Data return gc } 
func New Folder Font Cache ( folder string ) * Folder Font Cache { return & Folder Font Cache { fonts : make ( map [ string ] * truetype . Font ) , folder : folder , namer : Font File Name , } } 
func ( cache * Folder Font Cache ) Load ( font Data Font Data ) ( font * truetype . Font , err error ) { if font = cache . fonts [ cache . namer ( font Data ) ] ; font ! = nil { return font , nil } var data [ ] byte var file = cache . namer ( font Data ) if data , err = ioutil . Read File ( filepath . Join ( cache . folder , file ) ) ; err ! = nil { return } if font , err = truetype . Parse ( data ) ; err ! = nil { return } cache . fonts [ file ] = font return } 
func ( cache * Folder Font Cache ) Store ( font Data Font Data , font * truetype . Font ) { cache . fonts [ cache . namer ( font Data ) ] = font } 
func New Sync Folder Font Cache ( folder string ) * Sync Folder Font Cache { return & Sync Folder Font Cache { fonts : make ( map [ string ] * truetype . Font ) , folder : folder , namer : Font File Name , } } 
func ( cache * Sync Folder Font Cache ) Load ( font Data Font Data ) ( font * truetype . Font , err error ) { cache . RLock ( ) font = cache . fonts [ cache . namer ( font Data ) ] cache . RUnlock ( ) if font ! = nil { return font , nil } var data [ ] byte var file = cache . namer ( font Data ) if data , err = ioutil . Read File ( filepath . Join ( cache . folder , file ) ) ; err ! = nil { return } if font , err = truetype . Parse ( data ) ; err ! = nil { return } cache . Lock ( ) cache . fonts [ file ] = font cache . Unlock ( ) return } 
func ( cache * Sync Folder Font Cache ) Store ( font Data Font Data , font * truetype . Font ) { cache . Lock ( ) cache . fonts [ cache . namer ( font Data ) ] = font cache . Unlock ( ) } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { gc . Set Stroke Color ( image . Black ) gc . Set Fill Color ( image . White ) gc . Save ( ) gc . Rotate ( - 3 0 * ( math . Pi / 1 8 0 . 0 ) ) Draw ( gc , 4 8 , 4 8 , 2 4 0 , 7 2 ) gc . Restore ( ) } 
func Draw ( gc draw 2d . Graphic Context , x , y , w , h float 6 4 ) { h 2 3 : = ( h * 2 ) / 3 blf : = color . RGBA { 0 , 0 , 0 , 0xff } wf : = color . RGBA { 0xff , 0xff , 0xff , 0xff } nf : = color . RGBA { 0x 8B , 0x 4 5 , 0x 1 3 , 0xff } brf : = color . RGBA { 0x 8B , 0x 4 5 , 0x 1 3 , 0x 9 9 } brb : = color . RGBA { 0x 8B , 0x 4 5 , 0x 1 3 , 0x BB } gc . Cubic Curve To ( x + w / 4 , y - h / 3 , x + 3 * w / 4 , y - h / 3 , x + w , y + h * 1 . 0 0 2 ) gc . Close ( ) gc . Set Fill Color ( brb ) gc . Fill ( ) gc . Fill ( ) gc . Set Fill Color ( brf ) gc . Fill ( ) gc . Set Fill Color ( nf ) gc . Fill ( ) gc . Set Fill Color ( brf ) gc . Fill ( ) gc . Set Fill Color ( nf ) gc . Fill ( ) gc . Set Fill Color ( wf ) gc . Fill ( ) gc . Set Fill Color ( blf ) gc . Fill ( ) gc . Set Fill Color ( wf ) gc . Fill ( ) gc . Fill ( ) gc . Set Fill Color ( blf ) gc . Fill ( ) gc . Set Fill Color ( wf ) gc . Fill ( ) draw 2dkit . Rounded Rectangle ( gc , x + w / 2 - w / 8 , y + h + h / 2 . 5 , x + w / 2 - w / 8 + w / 8 , y + h + h / 2 . 5 + w / 6 , w / 1 0 , w / 1 0 ) gc . Fill ( ) gc . Fill ( ) gc . Set Fill Color ( nf ) gc . Fill ( ) gc . Set Fill Color ( blf ) gc . Fill ( ) } 
func New Pdf ( orientation Str , unit Str , size Str string ) * gofpdf . Fpdf { pdf : = gofpdf . New ( orientation Str , unit Str , size Str , draw 2d . Get Font Folder ( ) ) pdf . Set Draw Color ( 0 , 0 , 0 ) pdf . Set Fill Color ( 2 5 5 , 2 5 5 , 2 5 5 ) pdf . Set Line Cap Style ( " " ) pdf . Set Line Join Style ( " " ) pdf . Set Line Width ( 1 ) pdf . Add Page ( ) return pdf } 
func rgb ( c color . Color ) ( int , int , int ) { r , g , b , _ : = c . RGBA ( ) return int ( float 6 4 ( r ) * c 2 5 5 ) , int ( float 6 4 ( g ) * c 2 5 5 ) , int ( float 6 4 ( b ) * c 2 5 5 ) } 
func clear Rect ( gc * Graphic Context , x 1 , y 1 , x 2 , y 2 float 6 4 ) { x , y : = gc . pdf . Get XY ( ) draw 2dkit . Rectangle ( gc , x 1 , y 1 , x 2 , y 2 ) gc . Fill ( ) gc . pdf . Move To ( x , y ) } 
func New Graphic Context ( pdf * gofpdf . Fpdf ) * Graphic Context { gc : = & Graphic Context { draw 2dbase . New Stack Graphic Context ( ) , pdf , DPI } gc . Set DPI ( DPI ) return gc } 
func ( gc * Graphic Context ) Draw Image ( image image . Image ) { name : = strconv . Itoa ( int ( image Count ) ) image Count + + tp : = " " b : = & bytes . Buffer { } png . Encode ( b , image ) gc . pdf . Register Image Reader ( name , tp , b ) bounds : = image . Bounds ( ) x 0 , y 0 : = float 6 4 ( bounds . Min . X ) , float 6 4 ( bounds . Min . Y ) w , h : = float 6 4 ( bounds . Dx ( ) ) , float 6 4 ( bounds . Dy ( ) ) gc . pdf . Image ( name , x 0 , y 0 , w , h , false , tp , 0 , " " ) } 
func ( gc * Graphic Context ) Clear ( ) { width , height : = gc . pdf . Get Page Size ( ) clear Rect ( gc , 0 , 0 , width , height ) } 
func ( gc * Graphic Context ) Clear Rect ( x 1 , y 1 , x 2 , y 2 int ) { clear Rect ( gc , float 6 4 ( x 1 ) , float 6 4 ( y 1 ) , float 6 4 ( x 2 ) , float 6 4 ( y 2 ) ) } 
func ( gc * Graphic Context ) Get String Bounds ( s string ) ( left , top , right , bottom float 6 4 ) { _ , h : = gc . pdf . Get Font Size ( ) d : = gc . pdf . Get Font Desc ( " " , " " ) if d . Ascent = = 0 { } else { top = - float 6 4 ( d . Ascent ) * h / float 6 4 ( d . Ascent - d . Descent ) } return 0 , top , gc . pdf . Get String Width ( s ) , top + h } 
func ( gc * Graphic Context ) Create String Path ( text string , x , y float 6 4 ) ( cursor float 6 4 ) { w : = right - left h : = bottom - top gc . pdf . Move To ( x - left - margin , y + top ) gc . pdf . Cell Format ( w , h , text , " " , 0 , " " , false , 0 , " " ) return w } 
func ( gc * Graphic Context ) Fill String At ( text string , x , y float 6 4 ) ( cursor float 6 4 ) { return gc . Create String Path ( text , x , y ) } 
func ( gc * Graphic Context ) Stroke ( paths . . . * draw 2d . Path ) { _ , _ , _ , alpha S : = gc . Current . Stroke Color . RGBA ( ) gc . draw ( " " , alpha S , paths . . . ) gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) Fill ( paths . . . * draw 2d . Path ) { style : = " " if gc . Current . Fill Rule ! = draw 2d . Fill Rule Winding { style + = " " } _ , _ , _ , alpha F : = gc . Current . Fill Color . RGBA ( ) gc . draw ( style , alpha F , paths . . . ) gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) Fill Stroke ( paths . . . * draw 2d . Path ) { var rule string if gc . Current . Fill Rule ! = draw 2d . Fill Rule Winding { rule = " " } _ , _ , _ , alpha S : = gc . Current . Stroke Color . RGBA ( ) _ , _ , _ , alpha F : = gc . Current . Fill Color . RGBA ( ) if alpha S = = alpha F { gc . draw ( " " + rule , alpha F , paths . . . ) } else { gc . draw ( " " + rule , alpha F , paths . . . ) gc . draw ( " " , alpha S , paths . . . ) } gc . Current . Path . Clear ( ) } 
func ( gc * Graphic Context ) draw ( style string , alpha uint 3 2 , paths . . . * draw 2d . Path ) { paths = append ( paths , gc . Current . Path ) for _ , p : = range paths { Convert Path ( p , gc . pdf ) } a : = float 6 4 ( alpha ) / alpha Max current , blend Mode : = gc . pdf . Get Alpha ( ) if a ! = current { gc . pdf . Set Alpha ( a , blend Mode ) } gc . pdf . Draw Path ( style ) } 
func ( gc * Graphic Context ) Set Stroke Color ( c color . Color ) { gc . Stack Graphic Context . Set Stroke Color ( c ) gc . pdf . Set Draw Color ( rgb ( c ) ) } 
func ( gc * Graphic Context ) Set Fill Color ( c color . Color ) { gc . Stack Graphic Context . Set Fill Color ( c ) gc . pdf . Set Fill Color ( rgb ( c ) ) gc . pdf . Set Text Color ( rgb ( c ) ) } 
func ( gc * Graphic Context ) Set Font Data ( font Data draw 2d . Font Data ) { var style string if font Data . Style & draw 2d . Font Style Bold ! = 0 { style + = " " } if font Data . Style & draw 2d . Font Style Italic ! = 0 { style + = " " } fn : = draw 2d . Font File Name ( font Data ) fn = fn [ : len ( fn ) - 4 ] size , _ : = gc . pdf . Get Font Size ( ) gc . pdf . Add Font ( font Data . Name , style , fn + " " ) gc . pdf . Set Font ( font Data . Name , style , size ) } 
func ( gc * Graphic Context ) Set Font Size ( font Size float 6 4 ) { gc . Stack Graphic Context . Set Font Size ( font Size ) gc . recalc ( ) gc . pdf . Set Font Size ( font Size * gc . Current . Scale ) } 
func ( gc * Graphic Context ) Set Line Dash ( Dash [ ] float 6 4 , Dash Offset float 6 4 ) { gc . Stack Graphic Context . Set Line Dash ( Dash , Dash Offset ) gc . pdf . Set Dash Pattern ( Dash , Dash Offset ) } 
func ( gc * Graphic Context ) Set Line Width ( Line Width float 6 4 ) { gc . Stack Graphic Context . Set Line Width ( Line Width ) gc . pdf . Set Line Width ( Line Width ) } 
func ( gc * Graphic Context ) Set Line Cap ( Cap draw 2d . Line Cap ) { gc . Stack Graphic Context . Set Line Cap ( Cap ) gc . pdf . Set Line Cap Style ( caps [ Cap ] ) } 
func ( gc * Graphic Context ) Set Line Join ( Join draw 2d . Line Join ) { gc . Stack Graphic Context . Set Line Join ( Join ) gc . pdf . Set Line Join Style ( joins [ Join ] ) } 
func ( gc * Graphic Context ) Scale ( sx , sy float 6 4 ) { gc . Stack Graphic Context . Scale ( sx , sy ) gc . pdf . Transform Scale ( sx * 1 0 0 , sy * 1 0 0 , 0 , 0 ) } 
func ( gc * Graphic Context ) Rotate ( angle float 6 4 ) { gc . Stack Graphic Context . Rotate ( angle ) gc . pdf . Transform Rotate ( - angle * 1 8 0 / math . Pi , 0 , 0 ) } 
func ( gc * Graphic Context ) Translate ( tx , ty float 6 4 ) { gc . Stack Graphic Context . Translate ( tx , ty ) gc . pdf . Transform Translate ( tx , ty ) } 
func ( gc * Graphic Context ) Restore ( ) { gc . pdf . Transform End ( ) gc . Stack Graphic Context . Restore ( ) c : = gc . Current gc . Set Font Size ( c . Font Size ) gc . Set Stroke Color ( c . Stroke Color ) gc . Set Fill Color ( c . Fill Color ) gc . Set Fill Rule ( c . Fill Rule ) gc . Set Line Join ( c . Join ) 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { } 
func Draw ( gc draw 2d . Graphic Context , text string ) { gc . Fill Stroke ( ) gc . Set Font Size ( 1 4 ) } 
func Save To Png File ( file Path string , m image . Image ) error { if err ! = nil { return err } defer f . Close ( ) if err ! = nil { return err } err = b . Flush ( ) if err ! = nil { return err } return nil } 
func Load From Png File ( file Path string ) ( image . Image , error ) { if err ! = nil { return nil , err } defer f . Close ( ) b : = bufio . New Reader ( f ) img , err : = png . Decode ( b ) if err ! = nil { return nil , err } return img , nil } 
func Resource ( folder , filename , ext string ) string { var root string if ext = = " " | | ext = = " " { root = " " } return fmt . Sprintf ( " " , root , folder , filename ) } 
func Output ( name , ext string ) string { var root string if ext = = " " | | ext = = " " { root = " " } return fmt . Sprintf ( " " , root , name , ext ) } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { gc . Save ( ) gc . Scale ( 0 . 3 5 , - 0 . 3 5 ) gc . Translate ( 7 0 , - 2 0 0 ) gc . Restore ( ) } 
func Draw ( gc draw 2d . Graphic Context , filename string ) { if err ! = nil { panic ( err ) } defer src . Close ( ) bytes , err : = ioutil . Read All ( src ) reader : = strings . New Reader ( string ( bytes ) ) interpreter . Execute ( reader ) } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { } 
func Bubble ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 1 0 0 , height / 1 0 0 gc . Move To ( x + sx * 5 0 , y ) gc . Quad Curve To ( x , y , x , y + sy * 3 7 . 5 ) gc . Quad Curve To ( x , y + sy * 7 5 , x + sx * 2 5 , y + sy * 7 5 ) gc . Quad Curve To ( x + sx * 2 5 , y + sy * 9 5 , x + sx * 5 , y + sy * 1 0 0 ) gc . Quad Curve To ( x + sx * 3 5 , y + sy * 9 5 , x + sx * 4 0 , y + sy * 7 5 ) gc . Quad Curve To ( x + sx * 1 0 0 , y + sy * 7 5 , x + sx * 1 0 0 , y + sy * 3 7 . 5 ) gc . Quad Curve To ( x + sx * 1 0 0 , y , x + sx * 5 0 , y ) gc . Stroke ( ) } 
func Curve Rectangle ( gc draw 2d . Graphic Context , x 0 , y 0 , rect Width , rect Height float 6 4 , stroke , fill color . Color ) { radius : = ( rect Width + rect Height ) / 4 x 1 : = x 0 + rect Width y 1 : = y 0 + rect Height if rect Width / 2 < radius { if rect Height / 2 < radius { gc . Move To ( x 0 , ( y 0 + y 1 ) / 2 ) gc . Cubic Curve To ( x 0 , y 0 , x 0 , y 0 , ( x 0 + x 1 ) / 2 , y 0 ) gc . Cubic Curve To ( x 1 , y 0 , x 1 , y 0 , x 1 , ( y 0 + y 1 ) / 2 ) gc . Cubic Curve To ( x 1 , y 1 , x 1 , y 1 , ( x 1 + x 0 ) / 2 , y 1 ) gc . Cubic Curve To ( x 0 , y 1 , x 0 , y 1 , x 0 , ( y 0 + y 1 ) / 2 ) } else { gc . Move To ( x 0 , y 0 + radius ) gc . Cubic Curve To ( x 0 , y 0 , x 0 , y 0 , ( x 0 + x 1 ) / 2 , y 0 ) gc . Cubic Curve To ( x 1 , y 0 , x 1 , y 0 , x 1 , y 0 + radius ) gc . Line To ( x 1 , y 1 - radius ) gc . Cubic Curve To ( x 1 , y 1 , x 1 , y 1 , ( x 1 + x 0 ) / 2 , y 1 ) gc . Cubic Curve To ( x 0 , y 1 , x 0 , y 1 , x 0 , y 1 - radius ) } } else { if rect Height / 2 < radius { gc . Move To ( x 0 , ( y 0 + y 1 ) / 2 ) gc . Cubic Curve To ( x 0 , y 0 , x 0 , y 0 , x 0 + radius , y 0 ) gc . Line To ( x 1 - radius , y 0 ) gc . Cubic Curve To ( x 1 , y 0 , x 1 , y 0 , x 1 , ( y 0 + y 1 ) / 2 ) gc . Cubic Curve To ( x 1 , y 1 , x 1 , y 1 , x 1 - radius , y 1 ) gc . Line To ( x 0 + radius , y 1 ) gc . Cubic Curve To ( x 0 , y 1 , x 0 , y 1 , x 0 , ( y 0 + y 1 ) / 2 ) } else { gc . Move To ( x 0 , y 0 + radius ) gc . Cubic Curve To ( x 0 , y 0 , x 0 , y 0 , x 0 + radius , y 0 ) gc . Line To ( x 1 - radius , y 0 ) gc . Cubic Curve To ( x 1 , y 0 , x 1 , y 0 , x 1 , y 0 + radius ) gc . Line To ( x 1 , y 1 - radius ) gc . Cubic Curve To ( x 1 , y 1 , x 1 , y 1 , x 1 - radius , y 1 ) gc . Line To ( x 0 + radius , y 1 ) gc . Cubic Curve To ( x 0 , y 1 , x 0 , y 1 , x 0 , y 1 - radius ) } } gc . Close ( ) gc . Set Stroke Color ( stroke ) gc . Set Fill Color ( fill ) gc . Set Line Width ( 1 0 . 0 ) gc . Fill Stroke ( ) } 
func Dash ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 1 6 2 , height / 2 0 5 gc . Set Stroke Color ( image . Black ) gc . Set Line Dash ( [ ] float 6 4 { height / 1 0 , height / 5 0 , height / 5 0 , height / 5 0 } , - 5 0 . 0 ) gc . Set Line Cap ( draw 2d . Butt Cap ) gc . Set Line Join ( draw 2d . Round Join ) gc . Set Line Width ( height / 5 0 ) gc . Move To ( x + sx * 6 0 . 0 , y ) gc . Line To ( x + sx * 6 0 . 0 , y ) gc . Line To ( x + sx * 1 6 2 , y + sy * 2 0 5 ) r Line To ( gc , sx * - 1 0 2 . 4 , 0 ) gc . Cubic Curve To ( x + sx * - 1 7 , y + sy * 2 0 5 , x + sx * - 1 7 , y + sy * 1 0 3 , x + sx * 6 0 . 0 , y + sy * 1 0 3 . 0 ) gc . Stroke ( ) gc . Set Line Dash ( nil , 0 . 0 ) } 
func Arc ( gc draw 2d . Graphic Context , xc , yc , width , height float 6 4 ) { yc + = height / 2 radius X , radius Y : = width / 2 , height / 2 start Angle : = 4 5 * ( math . Pi / 1 8 0 . 0 ) angle : = 1 3 5 * ( math . Pi / 1 8 0 . 0 ) gc . Set Line Width ( width / 1 0 ) gc . Set Line Cap ( draw 2d . Butt Cap ) gc . Set Stroke Color ( image . Black ) gc . Move To ( xc + math . Cos ( start Angle ) * radius X , yc + math . Sin ( start Angle ) * radius Y ) gc . Arc To ( xc , yc , radius X , radius Y , start Angle , angle ) gc . Stroke ( ) gc . Set Fill Color ( color . NRGBA { 2 5 5 , 0x 3 3 , 0x 3 3 , 0x 8 0 } ) gc . Set Line Width ( width / 2 0 ) gc . Move To ( xc + math . Cos ( start Angle ) * radius X , yc + math . Sin ( start Angle ) * radius Y ) gc . Line To ( xc , yc ) gc . Line To ( xc - radius X , yc ) gc . Stroke ( ) gc . Move To ( xc , yc ) gc . Arc To ( xc , yc , width / 1 0 . 0 , height / 1 0 . 0 , 0 , 2 * math . Pi ) gc . Fill ( ) } 
func Cubic Curve ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 1 6 2 , height / 2 0 5 x 0 , y 0 : = x , y + sy * 1 0 0 . 0 x 1 , y 1 : = x + sx * 7 5 , y + sy * 2 0 5 x 2 , y 2 : = x + sx * 1 2 5 , y x 3 , y 3 : = x + sx * 2 0 5 , y + sy * 1 0 0 gc . Set Stroke Color ( image . Black ) gc . Set Fill Color ( color . NRGBA { 0x AA , 0x AA , 0x AA , 0x FF } ) gc . Set Line Width ( width / 1 0 ) gc . Move To ( x 0 , y 0 ) gc . Cubic Curve To ( x 1 , y 1 , x 2 , y 2 , x 3 , y 3 ) gc . Stroke ( ) gc . Set Stroke Color ( color . NRGBA { 0x FF , 0x 3 3 , 0x 3 3 , 0x 8 8 } ) gc . Set Line Width ( width / 2 0 ) gc . Line To ( x 1 , y 1 ) gc . Line To ( x 2 , y 2 ) gc . Line To ( x 3 , y 3 ) gc . Stroke ( ) } 
func Fill String ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 1 0 0 , height / 1 0 0 gc . Save ( ) gc . Set Stroke Color ( image . Black ) gc . Set Line Width ( 1 ) draw 2dkit . Rounded Rectangle ( gc , x + sx * 5 , y + sy * 5 , x + sx * 9 5 , y + sy * 9 5 , sx * 1 0 , sy * 1 0 ) gc . Fill Stroke ( ) gc . Set Fill Color ( image . Black ) gc . Set Font Size ( height / 6 ) gc . Translate ( x + sx * 6 , y + sy * 5 2 ) gc . Set Font Data ( draw 2d . Font Data { Name : " " , Family : draw 2d . Font Family Mono , Style : draw 2d . Font Style Bold | draw 2d . Font Style Italic , } ) w : = gc . Fill String ( " " ) gc . Translate ( w + sx , 0 ) left , top , right , bottom : = gc . Get String Bounds ( " " ) gc . Set Stroke Color ( color . NRGBA { 2 5 5 , 0x 3 3 , 0x 3 3 , 0x 8 0 } ) draw 2dkit . Rectangle ( gc , left , top , right , bottom ) gc . Set Line Width ( height / 5 0 ) gc . Stroke ( ) gc . Set Fill Color ( color . NRGBA { 0x 3 3 , 0x 3 3 , 0xff , 0xff } ) gc . Set Stroke Color ( color . NRGBA { 0x 3 3 , 0x 3 3 , 0xff , 0xff } ) gc . Set Line Width ( height / 1 0 0 ) gc . Stroke String ( " " ) gc . Translate ( - ( w + sx ) , sy * 2 4 ) w = gc . Create String Path ( " " , 0 , 0 ) gc . Fill ( ) gc . Translate ( w + sx , 0 ) gc . Create String Path ( " " , 0 , 0 ) path : = gc . Get Path ( ) gc . Stroke ( ( & path ) . Vertical Flip ( ) ) gc . Restore ( ) } 
func Fill Stroke ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 2 1 0 , height / 2 1 5 gc . Move To ( x + sx * 1 1 3 . 0 , y ) gc . Line To ( x + sx * 2 1 5 . 0 , y + sy * 2 1 5 ) r Line To ( gc , sx * - 1 0 0 , 0 ) gc . Cubic Curve To ( x + sx * 3 5 , y + sy * 2 1 5 , x + sx * 3 5 , y + sy * 1 1 3 , x + sx * 1 1 3 . 0 , y + sy * 1 1 3 ) gc . Close ( ) gc . Move To ( x + sx * 5 0 . 0 , y ) r Line To ( gc , sx * 5 1 . 2 , sy * 5 1 . 2 ) r Line To ( gc , sx * - 5 1 . 2 , sy * 5 1 . 2 ) r Line To ( gc , sx * - 5 1 . 2 , sy * - 5 1 . 2 ) gc . Close ( ) gc . Set Line Width ( width / 2 0 . 0 ) gc . Set Fill Color ( color . NRGBA { 0 , 0 , 0x FF , 0x FF } ) gc . Set Stroke Color ( image . Black ) gc . Fill Stroke ( ) } 
func Fill Style ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { sx , sy : = width / 2 3 2 , height / 2 2 0 gc . Set Line Width ( width / 4 0 ) draw 2dkit . Rectangle ( gc , x + sx * 0 , y + sy * 1 2 , x + sx * 2 3 2 , y + sy * 7 0 ) var wheel 1 , wheel 2 draw 2d . Path wheel 1 . Arc To ( x + sx * 5 2 , y + sy * 7 0 , sx * 4 0 , sy * 4 0 , 0 , 2 * math . Pi ) wheel 2 . Arc To ( x + sx * 1 8 0 , y + sy * 7 0 , sx * 4 0 , sy * 4 0 , 0 , - 2 * math . Pi ) gc . Set Fill Rule ( draw 2d . Fill Rule Even Odd ) gc . Set Fill Color ( color . NRGBA { 0 , 0x B 2 , 0 , 0x FF } ) gc . Set Stroke Color ( image . Black ) gc . Fill Stroke ( & wheel 1 , & wheel 2 ) draw 2dkit . Rectangle ( gc , x , y + sy * 1 4 0 , x + sx * 2 3 2 , y + sy * 1 9 8 ) wheel 1 . Clear ( ) wheel 1 . Arc To ( x + sx * 5 2 , y + sy * 1 9 8 , sx * 4 0 , sy * 4 0 , 0 , 2 * math . Pi ) wheel 2 . Clear ( ) wheel 2 . Arc To ( x + sx * 1 8 0 , y + sy * 1 9 8 , sx * 4 0 , sy * 4 0 , 0 , - 2 * math . Pi ) gc . Set Fill Rule ( draw 2d . Fill Rule Winding ) gc . Set Fill Color ( color . NRGBA { 0 , 0 , 0x E 5 , 0x FF } ) gc . Fill Stroke ( & wheel 1 , & wheel 2 ) } 
func Path Transform ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { gc . Save ( ) gc . Set Line Width ( width / 1 0 ) gc . Translate ( x + width / 2 , y + height / 2 ) gc . Scale ( 1 , 4 ) gc . Arc To ( 0 , 0 , width / 8 , height / 8 , 0 , math . Pi * 2 ) gc . Close ( ) gc . Stroke ( ) gc . Restore ( ) } 
func Star ( gc draw 2d . Graphic Context , x , y , width , height float 6 4 ) { gc . Save ( ) gc . Translate ( x + width / 2 , y + height / 2 ) gc . Set Line Width ( width / 4 0 ) for i : = 0 . 0 ; i < 3 6 0 ; i = i + 1 0 { gc . Rotate ( i * ( math . Pi / 1 8 0 . 0 ) ) gc . Move To ( 0 , 0 ) gc . Line To ( width / 2 , 0 ) gc . Stroke ( ) gc . Restore ( ) } gc . Restore ( ) } 
func Draw ( gc draw 2d . Graphic Context , width , height float 6 4 ) { mx , my : = width * 0 . 0 2 5 , height * 0 . 0 2 5 dx , dy : = ( width - 2 * mx ) / 4 , ( height - 2 * my ) / 3 w , h : = dx - 2 * mx , dy - 2 * my x 0 , y : = 2 * mx , 2 * my x : = x 0 Bubble ( gc , x , y , w , h ) x + = dx Curve Rectangle ( gc , x , y , w , h , color . NRGBA { 0x 8 0 , 0 , 0 , 0x 8 0 } , color . NRGBA { 0x 8 0 , 0x 8 0 , 0x FF , 0x FF } ) x + = dx Dash ( gc , x , y , w , h ) x + = dx Arc ( gc , x , y , w , h ) x = x 0 y + = dy Arc Negative ( gc , x , y , w , h ) x + = dx Cubic Curve ( gc , x , y , w , h ) x + = dx Fill String ( gc , x , y , w , h ) x + = dx Fill Stroke ( gc , x , y , w , h ) x = x 0 y + = dy Fill Style ( gc , x , y , w , h ) x + = dx Path Transform ( gc , x , y , w , h ) x + = dx Star ( gc , x , y , w , h ) x + = dx gopher 2 . Draw ( gc , x , y , w , h / 2 ) } 
func Convert Path ( path * draw 2d . Path , pdf Vectorizer ) { var start X , start Y float 6 4 = 0 , 0 i : = 0 for _ , cmp : = range path . Components { switch cmp { case draw 2d . Move To Cmp : start X , start Y = path . Points [ i ] , path . Points [ i + 1 ] pdf . Move To ( start X , start Y ) i + = 2 case draw 2d . Line To Cmp : pdf . Line To ( path . Points [ i ] , path . Points [ i + 1 ] ) i + = 2 case draw 2d . Quad Curve To Cmp : pdf . Curve To ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] ) i + = 4 case draw 2d . Cubic Curve To Cmp : pdf . Curve Bezier Cubic To ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , path . Points [ i + 4 ] , path . Points [ i + 5 ] ) i + = 6 case draw 2d . Arc To Cmp : pdf . Arc To ( path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , 0 , i + = 6 case draw 2d . Close Cmp : pdf . Line To ( start X , start Y ) pdf . Close Path ( ) } } } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { x : = 3 5 . 0 caps : = [ ] draw 2d . Line Cap { draw 2d . Butt Cap , draw 2d . Square Cap , draw 2d . Round Cap } joins : = [ ] draw 2d . Line Join { draw 2d . Bevel Join , draw 2d . Miter Join , draw 2d . Round Join } for i : = range caps { Draw ( gc , caps [ i ] , joins [ i ] , x , 5 0 , x , 1 6 0 , offset ) x + = offset } } 
func Draw ( gc draw 2d . Graphic Context , cap draw 2d . Line Cap , join draw 2d . Line Join , x 0 , y 0 , x 1 , y 1 , offset float 6 4 ) { gc . Set Line Cap ( cap ) gc . Set Line Join ( join ) gc . Set Line Width ( 3 0 . 0 ) gc . Move To ( x 0 , y 0 ) gc . Line To ( ( x 0 + x 1 ) / 2 + offset , ( y 0 + y 1 ) / 2 ) gc . Line To ( x 1 , y 1 ) gc . Stroke ( ) gc . Set Line Width ( 2 . 5 6 ) gc . Move To ( x 0 , y 0 ) gc . Line To ( ( x 0 + x 1 ) / 2 + offset , ( y 0 + y 1 ) / 2 ) gc . Line To ( x 1 , y 1 ) gc . Stroke ( ) } 
func Draw Contour ( path draw 2d . Path Builder , ps [ ] truetype . Point , dx , dy float 6 4 ) { if len ( ps ) = = 0 { return } start X , start Y : = point To F 6 4Point ( ps [ 0 ] ) path . Move To ( start X + dx , start Y + dy ) q 0X , q 0Y , on 0 : = start X , start Y , true for _ , p : = range ps [ 1 : ] { q X , q Y : = point To F 6 4Point ( p ) on : = p . Flags & 0x 0 1 ! = 0 if on { if on 0 { path . Line To ( q X + dx , q Y + dy ) } else { path . Quad Curve To ( q 0X + dx , q 0Y + dy , q X + dx , q Y + dy ) } } else { if on 0 { mid Y : = ( q 0Y + q Y ) / 2 path . Quad Curve To ( q 0X + dx , q 0Y + dy , mid X + dx , mid Y + dy ) } } q 0X , q 0Y , on 0 = q X , q Y , on } } else { path . Quad Curve To ( q 0X + dx , q 0Y + dy , start X + dx , start Y + dy ) } } 
func Flatten ( path * draw 2d . Path , flattener Flattener , scale float 6 4 ) { i : = 0 for _ , cmp : = range path . Components { switch cmp { case draw 2d . Move To Cmp : x , y = path . Points [ i ] , path . Points [ i + 1 ] start X , start Y = x , y if i ! = 0 { flattener . End ( ) } flattener . Move To ( x , y ) i + = 2 case draw 2d . Line To Cmp : x , y = path . Points [ i ] , path . Points [ i + 1 ] flattener . Line To ( x , y ) flattener . Line Join ( ) i + = 2 case draw 2d . Quad Curve To Cmp : Trace Quad ( flattener , path . Points [ i - 2 : ] , 0 . 5 ) x , y = path . Points [ i + 2 ] , path . Points [ i + 3 ] flattener . Line To ( x , y ) i + = 4 case draw 2d . Cubic Curve To Cmp : Trace Cubic ( flattener , path . Points [ i - 2 : ] , 0 . 5 ) x , y = path . Points [ i + 4 ] , path . Points [ i + 5 ] flattener . Line To ( x , y ) i + = 6 case draw 2d . Arc To Cmp : x , y = Trace Arc ( flattener , path . Points [ i ] , path . Points [ i + 1 ] , path . Points [ i + 2 ] , path . Points [ i + 3 ] , path . Points [ i + 4 ] , path . Points [ i + 5 ] , scale ) flattener . Line To ( x , y ) i + = 6 case draw 2d . Close Cmp : flattener . Line To ( start X , start Y ) flattener . Close ( ) } } flattener . End ( ) } 
func ( tr 1 Matrix ) Equals ( tr 2 Matrix ) bool { for i : = 0 ; i < 6 ; i = i + 1 { if ! fequals ( tr 1 [ i ] , tr 2 [ i ] ) { return false } } return true } 
func New Graphic Context ( img draw . Image ) * Graphic Context { var painter Painter switch select Image : = img . ( type ) { case * image . RGBA : painter = raster . New RGBAPainter ( select Image ) default : panic ( " " ) } return New Graphic Context With Painter ( img , painter ) } 
func New Graphic Context With Painter ( img draw . Image , painter Painter ) * Graphic Context { width , height : = img . Bounds ( ) . Dx ( ) , img . Bounds ( ) . Dy ( ) dpi : = 9 2 gc : = & Graphic Context { draw 2dbase . New Stack Graphic Context ( ) , img , painter , raster . New Rasterizer ( width , height ) , raster . New Rasterizer ( width , height ) , draw 2d . Get Global Font Cache ( ) , draw 2dbase . New Glyph Cache ( ) , & truetype . Glyph Buf { } , dpi , } return gc } 
func ( gc * Graphic Context ) Clear ( ) { width , height : = gc . img . Bounds ( ) . Dx ( ) , gc . img . Bounds ( ) . Dy ( ) gc . Clear Rect ( 0 , 0 , width , height ) } 
func ( gc * Graphic Context ) Clear Rect ( x 1 , y 1 , x 2 , y 2 int ) { image Color : = image . New Uniform ( gc . Current . Fill Color ) draw . Draw ( gc . img , image . Rect ( x 1 , y 1 , x 2 , y 2 ) , image Color , image . ZP , draw . Over ) } 
func Draw Image ( src image . Image , dest draw . Image , tr draw 2d . Matrix , op draw . Op , filter Image Filter ) { var transformer draw . Transformer switch filter { case Linear Filter : transformer = draw . Nearest Neighbor case Bilinear Filter : transformer = draw . Bi Linear case Bicubic Filter : transformer = draw . Catmull Rom } transformer . Transform ( dest , f 6 4 . Aff 3 { tr [ 0 ] , tr [ 1 ] , tr [ 4 ] , tr [ 2 ] , tr [ 3 ] , tr [ 5 ] } , src , src . Bounds ( ) , op , nil ) } 
func ( gc * Graphic Context ) Draw Image ( img image . Image ) { Draw Image ( img , gc . img , gc . Current . Tr , draw . Over , Bilinear Filter ) } 
func ( gc * Graphic Context ) Stroke ( paths . . . * draw 2d . Path ) { paths = append ( paths , gc . Current . Path ) gc . stroke Rasterizer . Use Non Zero Winding = true stroker : = draw 2dbase . New Line Stroker ( gc . Current . Cap , gc . Current . Join , draw 2dbase . Transformer { Tr : gc . Current . Tr , Flattener : Ft Line Builder { Adder : gc . stroke Rasterizer } } ) stroker . Half Line Width = gc . Current . Line Width / 2 var liner draw 2dbase . Flattener if gc . Current . Dash ! = nil & & len ( gc . Current . Dash ) > 0 { liner = draw 2dbase . New Dash Converter ( gc . Current . Dash , gc . Current . Dash Offset , stroker ) } else { liner = stroker } for _ , p : = range paths { draw 2dbase . Flatten ( p , liner , gc . Current . Tr . Get Scale ( ) ) } gc . paint ( gc . stroke Rasterizer , gc . Current . Stroke Color ) } 
func ( gc * Graphic Context ) Fill ( paths . . . * draw 2d . Path ) { paths = append ( paths , gc . Current . Path ) gc . fill Rasterizer . Use Non Zero Winding = gc . Current . Fill Rule = = draw 2d . Fill Rule Winding flattener : = draw 2dbase . Transformer { Tr : gc . Current . Tr , Flattener : Ft Line Builder { Adder : gc . fill Rasterizer } } for _ , p : = range paths { draw 2dbase . Flatten ( p , flattener , gc . Current . Tr . Get Scale ( ) ) } gc . paint ( gc . fill Rasterizer , gc . Current . Fill Color ) } 
func ( gc * Graphic Context ) Fill Stroke ( paths . . . * draw 2d . Path ) { paths = append ( paths , gc . Current . Path ) gc . fill Rasterizer . Use Non Zero Winding = gc . Current . Fill Rule = = draw 2d . Fill Rule Winding gc . stroke Rasterizer . Use Non Zero Winding = true flattener : = draw 2dbase . Transformer { Tr : gc . Current . Tr , Flattener : Ft Line Builder { Adder : gc . fill Rasterizer } } stroker : = draw 2dbase . New Line Stroker ( gc . Current . Cap , gc . Current . Join , draw 2dbase . Transformer { Tr : gc . Current . Tr , Flattener : Ft Line Builder { Adder : gc . stroke Rasterizer } } ) stroker . Half Line Width = gc . Current . Line Width / 2 var liner draw 2dbase . Flattener if gc . Current . Dash ! = nil & & len ( gc . Current . Dash ) > 0 { liner = draw 2dbase . New Dash Converter ( gc . Current . Dash , gc . Current . Dash Offset , stroker ) } else { liner = stroker } demux : = draw 2dbase . Demux Flattener { Flatteners : [ ] draw 2dbase . Flattener { flattener , liner } } for _ , p : = range paths { draw 2dbase . Flatten ( p , demux , gc . Current . Tr . Get Scale ( ) ) } } 
func Main ( gc draw 2d . Graphic Context , ext string ) ( string , error ) { } 
func Draw ( gc draw 2d . Graphic Context , png string , dw , dh , margin , line Width float 6 4 ) error { gc . Set Line Width ( line Width ) gc . Fill Stroke ( ) if err ! = nil { return err } gc . Save ( ) gc . Translate ( ( dw - sw * scale ) / 2 , ( dh - sh * scale ) / 2 ) gc . Scale ( scale , scale ) gc . Rotate ( 0 . 2 ) gc . Draw Image ( source ) gc . Restore ( ) return nil } 
func Draw ( gc draw 2d . Graphic Context , x , y float 6 4 ) { gc . Set Stroke Color ( color . RGBA { 0x 4 4 , 0x 4 4 , 0x 4 4 , 0xff } ) gc . Set Line Width ( 5 ) gc . Arc To ( x + 8 0 , y + 7 0 , 5 0 , 5 0 , 1 8 0 * ( math . Pi / 1 8 0 ) , 1 8 0 * ( math . Pi / 1 8 0 ) ) gc . Close ( ) gc . Fill Stroke ( ) gc . Move To ( x + 6 0 , y + 2 5 ) gc . Line To ( x + 5 0 , y + 1 0 ) gc . Move To ( x + 1 0 0 , y + 2 5 ) gc . Line To ( x + 1 1 0 , y + 1 0 ) gc . Stroke ( ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) draw 2dkit . Rectangle ( gc , x + 3 0 , y + 7 5 , x + 3 0 + 1 0 0 , y + 7 5 + 8 0 ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) gc . Fill Stroke ( ) } 
func Checksum String 3 2S ( s string , seed uint 3 2 ) uint 3 2 { if len ( s ) = = 0 { return Checksum 3 2S ( nil , seed ) } ss : = ( * reflect . String Header ) ( unsafe . Pointer ( & s ) ) return Checksum 3 2S ( ( * [ max Int 3 2 ] byte ) ( unsafe . Pointer ( ss . Data ) ) [ : len ( s ) : len ( s ) ] , seed ) } 
func Checksum String 6 4S ( s string , seed uint 6 4 ) uint 6 4 { if len ( s ) = = 0 { return Checksum 6 4S ( nil , seed ) } ss : = ( * reflect . String Header ) ( unsafe . Pointer ( & s ) ) return Checksum 6 4S ( ( * [ max Int 3 2 ] byte ) ( unsafe . Pointer ( ss . Data ) ) [ : len ( s ) : len ( s ) ] , seed ) } 
func New S 3 2 ( seed uint 3 2 ) ( xx * XXHash 3 2 ) { xx = & XXHash 3 2 { seed : seed , } xx . Reset ( ) return } 
func ( xx * XXHash 3 2 ) Sum ( in [ ] byte ) [ ] byte { s : = xx . Sum 3 2 ( ) return append ( in , byte ( s > > 2 4 ) , byte ( s > > 1 6 ) , byte ( s > > 8 ) , byte ( s ) ) } 
func New S 6 4 ( seed uint 6 4 ) ( xx * XXHash 6 4 ) { xx = & XXHash 6 4 { seed : seed , } xx . Reset ( ) return } 
func ( xx * XXHash 6 4 ) Sum ( in [ ] byte ) [ ] byte { s : = xx . Sum 6 4 ( ) return append ( in , byte ( s > > 5 6 ) , byte ( s > > 4 8 ) , byte ( s > > 4 0 ) , byte ( s > > 3 2 ) , byte ( s > > 2 4 ) , byte ( s > > 1 6 ) , byte ( s > > 8 ) , byte ( s ) ) } 
func round 6 4 ( h , v uint 6 4 ) uint 6 4 { h + = v * prime 6 4x 2 h = rotl 6 4 _ 3 1 ( h ) h * = prime 6 4x 1 return h } 
func Checksum 3 2S ( in [ ] byte , seed uint 3 2 ) ( h uint 3 2 ) { var i int if len ( in ) > 1 5 { var ( v 1 = seed + prime 3 2x 1 + prime 3 2x 2 v 2 = seed + prime 3 2x 2 v 3 = seed + 0 v 4 = seed - prime 3 2x 1 ) for ; i < len ( in ) - 1 5 ; i + = 1 6 { in : = in [ i : i + 1 6 : len ( in ) ] v 1 + = u 3 2 ( in [ 0 : 4 : len ( in ) ] ) * prime 3 2x 2 v 1 = rotl 3 2 _ 1 3 ( v 1 ) * prime 3 2x 1 v 2 + = u 3 2 ( in [ 4 : 8 : len ( in ) ] ) * prime 3 2x 2 v 2 = rotl 3 2 _ 1 3 ( v 2 ) * prime 3 2x 1 v 3 + = u 3 2 ( in [ 8 : 1 2 : len ( in ) ] ) * prime 3 2x 2 v 3 = rotl 3 2 _ 1 3 ( v 3 ) * prime 3 2x 1 v 4 + = u 3 2 ( in [ 1 2 : 1 6 : len ( in ) ] ) * prime 3 2x 2 v 4 = rotl 3 2 _ 1 3 ( v 4 ) * prime 3 2x 1 } h = rotl 3 2 _ 1 ( v 1 ) + rotl 3 2 _ 7 ( v 2 ) + rotl 3 2 _ 1 2 ( v 3 ) + rotl 3 2 _ 1 8 ( v 4 ) } else { h = seed + prime 3 2x 5 } h + = uint 3 2 ( len ( in ) ) for ; i < = len ( in ) - 4 ; i + = 4 { in : = in [ i : i + 4 : len ( in ) ] h + = u 3 2 ( in [ 0 : 4 : len ( in ) ] ) * prime 3 2x 3 h = rotl 3 2 _ 1 7 ( h ) * prime 3 2x 4 } for ; i < len ( in ) ; i + + { h + = uint 3 2 ( in [ i ] ) * prime 3 2x 5 h = rotl 3 2 _ 1 1 ( h ) * prime 3 2x 1 } h ^ = h > > 1 5 h * = prime 3 2x 2 h ^ = h > > 1 3 h * = prime 3 2x 3 h ^ = h > > 1 6 return } 
func Checksum 6 4S ( in [ ] byte , seed uint 6 4 ) uint 6 4 { if len ( in ) = = 0 & & seed = = 0 { return 0xef 4 6db 3 7 5 1d 8e 9 9 9 } if len ( in ) > 3 1 { return checksum 6 4 ( in , seed ) } return checksum 6 4Short ( in , seed ) } 
func Get Executable Path ( ) ( string , error ) { buf : = make ( [ ] uint 1 6 , syscall . MAX _PATH + 1 ) res , _ , err : = get Module File Name . Call ( 0 , uintptr ( unsafe . Pointer ( & buf [ 0 ] ) ) , uintptr ( len ( buf ) ) ) if res = = 0 | | res > = syscall . MAX _PATH | | buf [ 0 ] = = 0 | | buf [ res - 1 ] = = 0 { return " " , fmt . Errorf ( " " , res , err ) } return string ( utf 1 6 . Decode ( buf [ : res ] ) ) , nil } 
func Get Executable Path ( ) ( string , error ) { exe Path , err : = Readlink ( " " ) if err ! = nil { err = fmt . Errorf ( " " , err ) } return filepath . Clean ( exe Path ) , err } 
func Get Executable Path ( ) ( string , error ) { PATH _MAX : = 1 0 2 4 exe Path : = make ( [ ] byte , PATH _MAX ) exe Len : = C . size _t ( len ( exe Path ) ) mib [ 1 ] = 1 4 mib [ 2 ] = 1 2 mib [ 3 ] = - 1 status , err : = C . sysctl ( ( * C . int ) ( unsafe . Pointer ( & mib [ 0 ] ) ) , 4 , unsafe . Pointer ( & exe Path [ 0 ] ) , & exe Len , nil , 0 ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } } exe Path String : = string ( exe Path [ : exe Path String Len ] ) return filepath . Clean ( exe Path String ) , nil } 
func Readlink ( name string ) ( string , error ) { for len : = 1 2 8 ; ; len * = 2 { b : = make ( [ ] byte , len ) n , e : = syscall . Readlink ( name , b ) if e ! = nil { return " " , & os . Path Error { " " , name , e } } if n < len { if z : = bytes . Index Byte ( b [ : n ] , 0 ) ; z > = 0 { n = z } return string ( b [ : n ] ) , nil } } } 
func Get Executable Path ( ) ( string , error ) { PATH _MAX : = 1 0 2 4 exe Path : = make ( [ ] byte , PATH _MAX ) exe Len : = C . uint 3 2 _t ( len ( exe Path ) ) status , err : = C . _NSGet Executable Path ( ( * C . char ) ( unsafe . Pointer ( & exe Path [ 0 ] ) ) , & exe Len ) if err ! = nil { return " " , fmt . Errorf ( " " , err ) } } exe Path String : = string ( exe Path [ : exe Path String Len ] ) return filepath . Clean ( exe Path String ) , nil } 
func Make Daemon ( attrs * Daemon Attr ) ( io . Reader , io . Reader , error ) { stage , advance Stage , reset Env : = get Stage ( ) } reset Env ( ) return nil , nil , err } file Count : = 3 + len ( attrs . Files ) files : = make ( [ ] * os . File , file Count , file Count + 2 ) if stage = = 0 { if err ! = nil { return fatal ( err ) } files [ 0 ] , files [ 1 ] , files [ 2 ] = null Dev , null Dev , null Dev fd : = 3 for _ , f Ptr : = range attrs . Files { files [ fd ] = * f Ptr save File Name ( fd , ( * f Ptr ) . Name ( ) ) fd + + } } else { files [ 0 ] , files [ 1 ] , files [ 2 ] = os . Stdin , os . Stdout , os . Stderr fd : = 3 for _ , f Ptr : = range attrs . Files { * f Ptr = os . New File ( uintptr ( fd ) , get File Name ( fd ) ) syscall . Close On Exec ( fd ) files [ fd ] = * f Ptr fd + + } } if stage < 2 { if err ! = nil { return fatal ( fmt . Errorf ( " " , err ) ) } } if stage = = 1 & & attrs . Capture Output { files = files [ : file Count + 2 ] } } } if err : = advance Stage ( ) ; err ! = nil { return fatal ( err ) } dir , _ : = os . Getwd ( ) os Attrs : = os . Proc Attr { Dir : dir , Env : os . Environ ( ) , Files : files } if stage = = 0 { sysattrs : = syscall . Sys Proc Attr { Setsid : true } os Attrs . Sys = & sysattrs } prog Name : = attrs . Program Name if len ( prog Name ) = = 0 { prog Name = os . Args [ 0 ] } args : = append ( [ ] string { prog Name } , os . Args [ 1 : ] . . . ) proc , err : = os . Start Process ( proc Name , args , & os Attrs ) if err ! = nil { return fatal ( fmt . Errorf ( " " , proc Name , err ) ) } proc . Release ( ) os . Exit ( 0 ) } os . Chdir ( " " ) syscall . Umask ( 0 ) reset Env ( ) for fd : = 3 ; fd < file Count ; fd + + { reset File Name ( fd ) } curr Stage = Daemon Stage ( stage ) var stdout , stderr * os . File if attrs . Capture Output { stdout = os . New File ( uintptr ( file Count ) , " " ) stderr = os . New File ( uintptr ( file Count + 1 ) , " " ) } return stdout , stderr , nil } 
func Stage ( ) Daemon Stage { if curr Stage = = stage Unknown { s , _ , _ : = get Stage ( ) curr Stage = Daemon Stage ( s ) } return curr Stage } 
func get Stage ( ) ( stage int , advance Stage func ( ) error , reset Env func ( ) error ) { var orig Value string stage = 0 daemon Stage : = os . Getenv ( stage Var ) stage Tag : = strings . Split N ( daemon Stage , " " , 2 ) stage Info : = strings . Split N ( stage Tag [ 0 ] , " " , 3 ) if len ( stage Info ) = = 3 { stage Str , tm , check : = stage Info [ 0 ] , stage Info [ 1 ] , stage Info [ 2 ] hash : = sha 1 . New ( ) hash . Write ( [ ] byte ( stage Str + " " + tm + " " ) ) if check ! = hex . Encode To String ( hash . Sum ( [ ] byte { } ) ) { } else { stage , _ = strconv . Atoi ( stage Str ) if len ( stage Tag ) = = 2 { orig Value = stage Tag [ 1 ] } } } else { orig Value = daemon Stage } advance Stage = func ( ) error { base : = fmt . Sprintf ( " " , stage + 1 , time . Now ( ) . Nanosecond ( ) ) hash : = sha 1 . New ( ) hash . Write ( [ ] byte ( base ) ) tag : = base + hex . Encode To String ( hash . Sum ( [ ] byte { } ) ) if err : = os . Setenv ( stage Var , tag + " " + orig Value ) ; err ! = nil { return fmt . Errorf ( " " , stage Var , err ) } return nil } reset Env = func ( ) error { return os . Setenv ( stage Var , orig Value ) } return stage , advance Stage , reset Env } 
func New ( ) * Glg { g : = & Glg { level Counter : new ( uint 3 2 ) , buffer : sync . Pool { New : func ( ) interface { } { return bytes . New Buffer ( make ( [ ] byte , 0 , buffer Size ) ) } , } , } atomic . Store Uint 3 2 ( g . level Counter , uint 3 2 ( FATAL ) ) for lev , log : = range map [ LEVEL ] * logger { log . update Mode ( ) g . logger . Store ( lev , log ) } return g } 
func Get ( ) * Glg { once . Do ( func ( ) { fastime . Set Format ( time Format ) glg = New ( ) } ) return glg } 
func ( g * Glg ) Set Mode ( mode MODE ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . mode = mode l . update Mode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g } 
func ( g * Glg ) Set Level Mode ( level LEVEL , mode MODE ) * Glg { lev , ok : = g . logger . Load ( level ) if ok { l : = lev . ( * logger ) l . mode = mode l . update Mode ( ) g . logger . Store ( level , l ) } return g } 
func ( g * Glg ) Set Prefix ( pref string ) * Glg { v , ok : = g . logger . Load ( PRINT ) if ok { value : = v . ( * logger ) value . tag = pref g . logger . Store ( PRINT , value ) } return g } 
func ( g * Glg ) Get Current Mode ( level LEVEL ) MODE { l , ok : = g . logger . Load ( level ) if ok { return l . ( * logger ) . mode } return NONE } 
func ( g * Glg ) Init Writer ( ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . writer = nil l . update Mode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g } 
func ( g * Glg ) Set Writer ( writer io . Writer ) * Glg { if writer = = nil { return g } g . logger . Range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . writer = writer l . update Mode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g } 
func ( g * Glg ) Set Level Color ( level LEVEL , color func ( string ) string ) * Glg { lev , ok : = g . logger . Load ( level ) if ok { l : = lev . ( * logger ) l . color = color g . logger . Store ( level , l ) } return g } 
func ( g * Glg ) Set Level Writer ( level LEVEL , writer io . Writer ) * Glg { if writer = = nil { return g } lev , ok : = g . logger . Load ( level ) if ok { l : = lev . ( * logger ) l . writer = writer l . update Mode ( ) g . logger . Store ( level , l ) } return g } 
func ( g * Glg ) Add Std Level ( tag string , mode MODE , is Color bool ) * Glg { atomic . Add Uint 3 2 ( g . level Counter , 1 ) lev : = LEVEL ( atomic . Load Uint 3 2 ( g . level Counter ) ) g . level Map . Store ( tag , lev ) l : = & logger { writer : nil , std : os . Stdout , color : Colorless , is Color : is Color , mode : mode , tag : tag , } l . update Mode ( ) g . logger . Store ( lev , l ) return g } 
func ( g * Glg ) Enable Color ( ) * Glg { g . logger . Range ( func ( key , val interface { } ) bool { l : = val . ( * logger ) l . is Color = true l . update Mode ( ) g . logger . Store ( key . ( LEVEL ) , l ) return true } ) return g } 
func ( g * Glg ) Enable Level Color ( lv LEVEL ) * Glg { ins , ok : = g . logger . Load ( lv ) if ok { l : = ins . ( * logger ) l . is Color = true l . update Mode ( ) g . logger . Store ( lv , l ) } return g } 
func ( g * Glg ) Disable Level Color ( lv LEVEL ) * Glg { ins , ok : = g . logger . Load ( lv ) if ok { l : = ins . ( * logger ) l . is Color = false l . update Mode ( ) g . logger . Store ( lv , l ) } return g } 
func ( g * Glg ) Raw String ( data [ ] byte ) string { str : = * ( * string ) ( unsafe . Pointer ( & data ) ) return str [ strings . Index ( str , sep ) + sepl : len ( str ) - rcl ] } 
func ( g * Glg ) Tag String To Level ( tag string ) LEVEL { l , ok : = g . level Map . Load ( tag ) if ! ok { return 2 5 5 } return l . ( LEVEL ) } 
func File Writer ( path string , perm os . File Mode ) * os . File { if path = = " " { return nil } var err error var file * os . File if _ , err = os . Stat ( path ) ; err ! = nil { if _ , err = os . Stat ( filepath . Dir ( path ) ) ; err ! = nil { err = os . Mkdir All ( filepath . Dir ( path ) , perm ) if err ! = nil { return nil } } file , err = os . Create ( path ) if err ! = nil { return nil } err = file . Close ( ) if err ! = nil { return nil } } file , err = os . Open File ( path , os . O _APPEND | os . O _CREATE | os . O _WRONLY , perm ) if err ! = nil { return nil } return file } 
func ( g * Glg ) HTTPLogger ( name string , handler http . Handler ) http . Handler { return g . HTTPLogger Func ( name , handler . Serve HTTP ) } 
func ( g * Glg ) HTTPLogger Func ( name string , hf http . Handler Func ) http . Handler { return http . Handler Func ( func ( w http . Response Writer , r * http . Request ) { start : = fastime . Now ( ) hf ( w , r ) err : = g . Logf ( " \t \t \t " , r . Method , r . Request URI , name , fastime . Now ( ) . Sub ( start ) . String ( ) ) if err ! = nil { err = g . Error ( err ) if err ! = nil { fmt . Println ( err ) } } } ) } 
func HTTPLogger ( name string , handler http . Handler ) http . Handler { return glg . HTTPLogger ( name , handler ) } 
func HTTPLogger Func ( name string , hf http . Handler Func ) http . Handler { return glg . HTTPLogger Func ( name , hf ) } 
func ( g * Glg ) Log ( val . . . interface { } ) error { return g . out ( LOG , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Logf ( format string , val . . . interface { } ) error { return g . out ( LOG , format , val . . . ) } 
func ( g * Glg ) Log Func ( f func ( ) string ) error { if g . is Mode Enable ( LOG ) { return g . out ( LOG , " " , f ( ) ) } return nil } 
func Log ( val . . . interface { } ) error { return glg . out ( LOG , blank Format ( len ( val ) ) , val . . . ) } 
func Logf ( format string , val . . . interface { } ) error { return glg . out ( LOG , format , val . . . ) } 
func Log Func ( f func ( ) string ) error { if is Mode Enable ( LOG ) { return glg . out ( LOG , " " , f ( ) ) } return nil } 
func ( g * Glg ) Info ( val . . . interface { } ) error { return g . out ( INFO , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Infof ( format string , val . . . interface { } ) error { return g . out ( INFO , format , val . . . ) } 
func ( g * Glg ) Info Func ( f func ( ) string ) error { if g . is Mode Enable ( INFO ) { return g . out ( INFO , " " , f ( ) ) } return nil } 
func Info ( val . . . interface { } ) error { return glg . out ( INFO , blank Format ( len ( val ) ) , val . . . ) } 
func Infof ( format string , val . . . interface { } ) error { return glg . out ( INFO , format , val . . . ) } 
func Info Func ( f func ( ) string ) error { if is Mode Enable ( INFO ) { return glg . out ( INFO , " " , f ( ) ) } return nil } 
func ( g * Glg ) Success ( val . . . interface { } ) error { return g . out ( OK , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Successf ( format string , val . . . interface { } ) error { return g . out ( OK , format , val . . . ) } 
func ( g * Glg ) Success Func ( f func ( ) string ) error { if g . is Mode Enable ( OK ) { return g . out ( OK , " " , f ( ) ) } return nil } 
func Success ( val . . . interface { } ) error { return glg . out ( OK , blank Format ( len ( val ) ) , val . . . ) } 
func Successf ( format string , val . . . interface { } ) error { return glg . out ( OK , format , val . . . ) } 
func Success Func ( f func ( ) string ) error { if is Mode Enable ( OK ) { return glg . out ( OK , " " , f ( ) ) } return nil } 
func ( g * Glg ) Debug ( val . . . interface { } ) error { return g . out ( DEBG , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Debugf ( format string , val . . . interface { } ) error { return g . out ( DEBG , format , val . . . ) } 
func ( g * Glg ) Debug Func ( f func ( ) string ) error { if g . is Mode Enable ( DEBG ) { return g . out ( DEBG , " " , f ( ) ) } return nil } 
func Debug ( val . . . interface { } ) error { return glg . out ( DEBG , blank Format ( len ( val ) ) , val . . . ) } 
func Debugf ( format string , val . . . interface { } ) error { return glg . out ( DEBG , format , val . . . ) } 
func Debug Func ( f func ( ) string ) error { if is Mode Enable ( DEBG ) { return glg . out ( DEBG , " " , f ( ) ) } return nil } 
func ( g * Glg ) Warn ( val . . . interface { } ) error { return g . out ( WARN , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Warnf ( format string , val . . . interface { } ) error { return g . out ( WARN , format , val . . . ) } 
func ( g * Glg ) Warn Func ( f func ( ) string ) error { if g . is Mode Enable ( WARN ) { return g . out ( WARN , " " , f ( ) ) } return nil } 
func Warn ( val . . . interface { } ) error { return glg . out ( WARN , blank Format ( len ( val ) ) , val . . . ) } 
func Warnf ( format string , val . . . interface { } ) error { return glg . out ( WARN , format , val . . . ) } 
func Warn Func ( f func ( ) string ) error { if is Mode Enable ( WARN ) { return glg . out ( WARN , " " , f ( ) ) } return nil } 
func ( g * Glg ) Custom Log ( level string , val . . . interface { } ) error { return g . out ( g . Tag String To Level ( level ) , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Custom Logf ( level string , format string , val . . . interface { } ) error { return g . out ( g . Tag String To Level ( level ) , format , val . . . ) } 
func ( g * Glg ) Custom Log Func ( level string , f func ( ) string ) error { lv : = g . Tag String To Level ( level ) if g . is Mode Enable ( lv ) { return g . out ( lv , " " , f ( ) ) } return nil } 
func Custom Log ( level string , val . . . interface { } ) error { return glg . out ( glg . Tag String To Level ( level ) , blank Format ( len ( val ) ) , val . . . ) } 
func Custom Logf ( level string , format string , val . . . interface { } ) error { return glg . out ( glg . Tag String To Level ( level ) , format , val . . . ) } 
func Custom Log Func ( level string , f func ( ) string ) error { lv : = Tag String To Level ( level ) if is Mode Enable ( lv ) { return glg . out ( lv , " " , f ( ) ) } return nil } 
func ( g * Glg ) Print ( val . . . interface { } ) error { return g . out ( PRINT , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Printf ( format string , val . . . interface { } ) error { return g . out ( PRINT , format , val . . . ) } 
func ( g * Glg ) Print Func ( f func ( ) string ) error { if g . is Mode Enable ( PRINT ) { return g . out ( PRINT , " " , f ( ) ) } return nil } 
func Print ( val . . . interface { } ) error { return glg . out ( PRINT , blank Format ( len ( val ) ) , val . . . ) } 
func Println ( val . . . interface { } ) error { return glg . out ( PRINT , blank Format ( len ( val ) ) , val . . . ) } 
func Printf ( format string , val . . . interface { } ) error { return glg . out ( PRINT , format , val . . . ) } 
func Print Func ( f func ( ) string ) error { if is Mode Enable ( PRINT ) { return glg . out ( PRINT , " " , f ( ) ) } return nil } 
func ( g * Glg ) Error ( val . . . interface { } ) error { return g . out ( ERR , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Errorf ( format string , val . . . interface { } ) error { return g . out ( ERR , format , val . . . ) } 
func ( g * Glg ) Error Func ( f func ( ) string ) error { if g . is Mode Enable ( ERR ) { return g . out ( ERR , " " , f ( ) ) } return nil } 
func Error ( val . . . interface { } ) error { return glg . out ( ERR , blank Format ( len ( val ) ) , val . . . ) } 
func Errorf ( format string , val . . . interface { } ) error { return glg . out ( ERR , format , val . . . ) } 
func Error Func ( f func ( ) string ) error { if is Mode Enable ( ERR ) { return glg . out ( ERR , " " , f ( ) ) } return nil } 
func ( g * Glg ) Fail ( val . . . interface { } ) error { return g . out ( FAIL , blank Format ( len ( val ) ) , val . . . ) } 
func ( g * Glg ) Failf ( format string , val . . . interface { } ) error { return g . out ( FAIL , format , val . . . ) } 
func ( g * Glg ) Fail Func ( f func ( ) string ) error { if g . is Mode Enable ( FAIL ) { return g . out ( FAIL , " " , f ( ) ) } return nil } 
func Fail ( val . . . interface { } ) error { return glg . out ( FAIL , blank Format ( len ( val ) ) , val . . . ) } 
func Failf ( format string , val . . . interface { } ) error { return glg . out ( FAIL , format , val . . . ) } 
func Fail Func ( f func ( ) string ) error { if is Mode Enable ( FAIL ) { return glg . out ( FAIL , " " , f ( ) ) } return nil } 
func ( g * Glg ) Fatal ( val . . . interface { } ) { err : = g . out ( FATAL , blank Format ( len ( val ) ) , val . . . ) if err ! = nil { err = g . Error ( err . Error ( ) ) if err ! = nil { panic ( err ) } } exit ( 1 ) } 
func ( g * Glg ) Fatalf ( format string , val . . . interface { } ) { err : = g . out ( FATAL , format , val . . . ) if err ! = nil { err = g . Error ( err . Error ( ) ) if err ! = nil { panic ( err ) } } exit ( 1 ) } 
func ( g * Glg ) is Mode Enable ( l LEVEL ) bool { return g . Get Current Mode ( l ) ! = NONE } 
func Wrap ( w http . Response Writer , hooks Hooks ) http . Response Writer { rw : = & rw { w : w , h : hooks } _ , i 0 : = w . ( http . Flusher ) _ , i 1 : = w . ( http . Close Notifier ) _ , i 2 : = w . ( http . Hijacker ) _ , i 3 : = w . ( io . Reader From ) switch { } { rw } io . Reader From } { rw , rw } http . Hijacker } { rw , rw } http . Hijacker io . Reader From } { rw , rw , rw } http . Close Notifier } { rw , rw } http . Close Notifier io . Reader From } { rw , rw , rw } http . Close Notifier http . Hijacker } { rw , rw , rw } http . Close Notifier http . Hijacker io . Reader From } { rw , rw , rw , rw } http . Flusher } { rw , rw } http . Flusher io . Reader From } { rw , rw , rw } http . Flusher http . Hijacker } { rw , rw , rw } http . Flusher http . Hijacker io . Reader From } { rw , rw , rw , rw } http . Flusher http . Close Notifier } { rw , rw , rw } http . Flusher http . Close Notifier io . Reader From } { rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker } { rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker io . Reader From } { rw , rw , rw , rw , rw } } panic ( " " ) } 
func Wrap ( w http . Response Writer , hooks Hooks ) http . Response Writer { rw : = & rw { w : w , h : hooks } _ , i 0 : = w . ( http . Flusher ) _ , i 1 : = w . ( http . Close Notifier ) _ , i 2 : = w . ( http . Hijacker ) _ , i 3 : = w . ( io . Reader From ) _ , i 4 : = w . ( http . Pusher ) switch { } { rw } http . Pusher } { rw , rw } io . Reader From } { rw , rw } io . Reader From http . Pusher } { rw , rw , rw } http . Hijacker } { rw , rw } http . Hijacker http . Pusher } { rw , rw , rw } http . Hijacker io . Reader From } { rw , rw , rw } http . Hijacker io . Reader From http . Pusher } { rw , rw , rw , rw } http . Close Notifier } { rw , rw } http . Close Notifier http . Pusher } { rw , rw , rw } http . Close Notifier io . Reader From } { rw , rw , rw } http . Close Notifier io . Reader From http . Pusher } { rw , rw , rw , rw } http . Close Notifier http . Hijacker } { rw , rw , rw } http . Close Notifier http . Hijacker http . Pusher } { rw , rw , rw , rw } http . Close Notifier http . Hijacker io . Reader From } { rw , rw , rw , rw } http . Close Notifier http . Hijacker io . Reader From http . Pusher } { rw , rw , rw , rw , rw } http . Flusher } { rw , rw } http . Flusher http . Pusher } { rw , rw , rw } http . Flusher io . Reader From } { rw , rw , rw } http . Flusher io . Reader From http . Pusher } { rw , rw , rw , rw } http . Flusher http . Hijacker } { rw , rw , rw } http . Flusher http . Hijacker http . Pusher } { rw , rw , rw , rw } http . Flusher http . Hijacker io . Reader From } { rw , rw , rw , rw } http . Flusher http . Hijacker io . Reader From http . Pusher } { rw , rw , rw , rw , rw } http . Flusher http . Close Notifier } { rw , rw , rw } http . Flusher http . Close Notifier http . Pusher } { rw , rw , rw , rw } http . Flusher http . Close Notifier io . Reader From } { rw , rw , rw , rw } http . Flusher http . Close Notifier io . Reader From http . Pusher } { rw , rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker } { rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker http . Pusher } { rw , rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker io . Reader From } { rw , rw , rw , rw , rw } http . Flusher http . Close Notifier http . Hijacker io . Reader From http . Pusher } { rw , rw , rw , rw , rw , rw } } panic ( " " ) } 
func Capture Metrics ( hnd http . Handler , w http . Response Writer , r * http . Request ) Metrics { return Capture Metrics Fn ( w , func ( ww http . Response Writer ) { hnd . Serve HTTP ( ww , r ) } ) } 
func Capture Metrics Fn ( w http . Response Writer , fn func ( http . Response Writer ) ) Metrics { var ( start = time . Now ( ) m = Metrics { Code : http . Status OK } header Written bool lock sync . Mutex hooks = Hooks { Write Header : func ( next Write Header Func ) Write Header Func { return func ( code int ) { next ( code ) lock . Lock ( ) defer lock . Unlock ( ) if ! header Written { m . Code = code header Written = true } } } , Write : func ( next Write Func ) Write Func { return func ( p [ ] byte ) ( int , error ) { n , err : = next ( p ) lock . Lock ( ) defer lock . Unlock ( ) m . Written + = int 6 4 ( n ) header Written = true return n , err } } , Read From : func ( next Read From Func ) Read From Func { return func ( src io . Reader ) ( int 6 4 , error ) { n , err : = next ( src ) lock . Lock ( ) defer lock . Unlock ( ) header Written = true m . Written + = n return n , err } } , } ) fn ( Wrap ( w , hooks ) ) m . Duration = time . Since ( start ) return m } 
func ( da * cedar ) get ( key [ ] byte , from , pos int ) * int { for ; pos < len ( key ) ; pos + + { if value : = da . Array [ from ] . Value ; value > = 0 & & value ! = Value Limit { to : = da . follow ( from , 0 ) da . Array [ to ] . Value = value } from = da . follow ( from , key [ pos ] ) } to : = from if da . Array [ from ] . Value < 0 { to = da . follow ( from , 0 ) } return & da . Array [ to ] . Value } 
func ( da * cedar ) push Sibling ( from , base int , label byte , has Child bool ) { c : = & da . Ninfos [ from ] . Child keep Order : = * c = = 0 if da . Ordered { keep Order = label > * c } if has Child & & keep Order { c = & da . Ninfos [ base ^ int ( * c ) ] . Sibling for da . Ordered & & * c ! = 0 & & * c < label { c = & da . Ninfos [ base ^ int ( * c ) ] . Sibling } } da . Ninfos [ base ^ int ( label ) ] . Sibling = * c * c = label } 
func ( da * Cedar ) Save ( out io . Writer , data Type string ) error { switch data Type { case " " , " " : data Eecoder : = gob . New Encoder ( out ) return data Eecoder . Encode ( da . cedar ) case " " , " " : data Eecoder : = json . New Encoder ( out ) return data Eecoder . Encode ( da . cedar ) } return Err Invalid Data Type } 
func ( da * Cedar ) Save To File ( file Name string , data Type string ) error { file , err : = os . Open File ( file Name , os . O _CREATE | os . O _WRONLY , 0 6 6 6 ) if err ! = nil { return err } defer file . Close ( ) out : = bufio . New Writer ( file ) defer out . Flush ( ) da . Save ( out , data Type ) return nil } 
func ( da * Cedar ) Load ( in io . Reader , data Type string ) error { switch data Type { case " " , " " : data Decoder : = gob . New Decoder ( in ) return data Decoder . Decode ( da . cedar ) case " " , " " : data Decoder : = json . New Decoder ( in ) return data Decoder . Decode ( da . cedar ) } return Err Invalid Data Type } 
func ( da * Cedar ) Load From File ( file Name string , data Type string ) error { file , err : = os . Open File ( file Name , os . O _RDONLY , 0 6 0 0 ) defer file . Close ( ) if err ! = nil { return err } in : = bufio . New Reader ( file ) return da . Load ( in , data Type ) } 
func ( da * Cedar ) Status ( ) ( keys , nodes , size , capacity int ) { for i : = 0 ; i < da . Size ; i + + { n : = da . Array [ i ] if n . Check > = 0 { nodes + + if n . Value > = 0 { keys + + } } } return keys , nodes , da . Size , da . Capacity } 
func ( da * Cedar ) Jump ( path [ ] byte , from int ) ( to int , err error ) { for _ , b : = range path { if da . Array [ from ] . Value > = 0 { return from , Err No Path } to = da . Array [ from ] . base ( ) ^ int ( b ) if da . Array [ to ] . Check ! = from { return from , Err No Path } from = to } return to , nil } 
func ( da * Cedar ) Key ( id int ) ( key [ ] byte , err error ) { for id > 0 { from : = da . Array [ id ] . Check if from < 0 { return nil , Err No Path } if char : = byte ( da . Array [ from ] . base ( ) ^ id ) ; char ! = 0 { key = append ( key , char ) } id = from } if id ! = 0 | | len ( key ) = = 0 { return nil , Err Invalid Key } for i : = 0 ; i < len ( key ) / 2 ; i + + { key [ i ] , key [ len ( key ) - i - 1 ] = key [ len ( key ) - i - 1 ] , key [ i ] } return key , nil } 
func ( da * Cedar ) Value ( id int ) ( value int , err error ) { value = da . Array [ id ] . Value if value > = 0 { return value , nil } to : = da . Array [ id ] . base ( ) if da . Array [ to ] . Check = = id & & da . Array [ to ] . Value > = 0 { return da . Array [ to ] . Value , nil } return 0 , Err No Value } 
func ( da * Cedar ) Insert ( key [ ] byte , value int ) error { if value < 0 | | value > = Value Limit { return Err Invalid Value } p : = da . get ( key , 0 , 0 ) * p = value return nil } 
func ( da * Cedar ) Update ( key [ ] byte , value int ) error { p : = da . get ( key , 0 , 0 ) return nil } } * p + = value return nil } 
func ( da * Cedar ) Delete ( key [ ] byte ) error { if err ! = nil { return Err No Path } if da . Array [ to ] . Value < 0 { base : = da . Array [ to ] . base ( ) if da . Array [ base ] . Check = = to { to = base } } for to > 0 { from : = da . Array [ to ] . Check base : = da . Array [ from ] . base ( ) label : = byte ( to ^ base ) break } } return nil } 
func ( da * Cedar ) Get ( key [ ] byte ) ( value int , err error ) { to , err : = da . Jump ( key , 0 ) if err ! = nil { return 0 , err } return da . Value ( to ) } 
func ( da * Cedar ) Prefix Match ( key [ ] byte , num int ) ( ids [ ] int ) { for from , i : = 0 , 0 ; i < len ( key ) ; i + + { to , err : = da . Jump ( key [ i : i + 1 ] , from ) if err ! = nil { break } if _ , err : = da . Value ( to ) ; err = = nil { ids = append ( ids , to ) num - - if num = = 0 { return } } from = to } return } 
func ( da * Cedar ) Prefix Predict ( key [ ] byte , num int ) ( ids [ ] int ) { root , err : = da . Jump ( key , 0 ) if err ! = nil { return } for from , err : = da . begin ( root ) ; err = = nil ; from , err = da . next ( from , root ) { ids = append ( ids , from ) num - - if num = = 0 { return } } return } 
func ( v * Version ) Set ( version string ) error { metadata : = split Off ( & version , " " ) pre Release : = Pre Release ( split Off ( & version , " " ) ) dot Parts : = strings . Split N ( version , " " , 3 ) if len ( dot Parts ) ! = 3 { return fmt . Errorf ( " " , version ) } if err : = validate Identifier ( string ( pre Release ) ) ; err ! = nil { return fmt . Errorf ( " " , err ) } if err : = validate Identifier ( metadata ) ; err ! = nil { return fmt . Errorf ( " " , err ) } parsed : = make ( [ ] int 6 4 , 3 , 3 ) for i , v : = range dot Parts [ : 3 ] { val , err : = strconv . Parse Int ( v , 1 0 , 6 4 ) parsed [ i ] = val if err ! = nil { return err } } v . Metadata = metadata v . Pre Release = pre Release v . Major = parsed [ 0 ] v . Minor = parsed [ 1 ] v . Patch = parsed [ 2 ] return nil } 
func ( v Version ) Compare ( version B Version ) int { if cmp : = recursive Compare ( v . Slice ( ) , version B . Slice ( ) ) ; cmp ! = 0 { return cmp } return pre Release Compare ( v , version B ) } 
func ( v Version ) Slice ( ) [ ] int 6 4 { return [ ] int 6 4 { v . Major , v . Minor , v . Patch } } 
func ( v * Version ) Bump Major ( ) { v . Major + = 1 v . Minor = 0 v . Patch = 0 v . Pre Release = Pre Release ( " " ) v . Metadata = " " } 
func ( v * Version ) Bump Minor ( ) { v . Minor + = 1 v . Patch = 0 v . Pre Release = Pre Release ( " " ) v . Metadata = " " } 
func ( v * Version ) Bump Patch ( ) { v . Patch + = 1 v . Pre Release = Pre Release ( " " ) v . Metadata = " " } 
func validate Identifier ( id string ) error { if id ! = " " & & ! re Identifier . Match String ( id ) { return fmt . Errorf ( " " , id ) } return nil } 
func parse _token ( token string ) ( op string , key string , args interface { } , err error ) { if token = = " " { return " " , " " , nil , nil } if token = = " " { return " " , " " , nil , nil } bracket _idx : = strings . Index ( token , " " ) if bracket _idx < 0 { return " " , token , nil , nil } else { key = token [ : bracket _idx ] tail : = token [ bracket _idx : ] if len ( tail ) < 3 { err = fmt . Errorf ( " " , tail ) return } tail = tail [ 1 : len ( tail ) - 1 ] if strings . Has Prefix ( tail , " " ) & & strings . Has Suffix ( tail , " " ) { args = strings . Trim ( tail [ 2 : len ( tail ) - 1 ] , " " ) } return } else if strings . Contains ( tail , " " ) { tails : = strings . Split ( tail , " " ) if len ( tails ) ! = 2 { err = fmt . Errorf ( " " , tails ) return } var frm interface { } var to interface { } if frm , err = strconv . Atoi ( strings . Trim ( tails [ 0 ] , " " ) ) ; err ! = nil { if strings . Trim ( tails [ 0 ] , " " ) = = " " { err = nil } frm = nil } if to , err = strconv . Atoi ( strings . Trim ( tails [ 1 ] , " " ) ) ; err ! = nil { if strings . Trim ( tails [ 1 ] , " " ) = = " " { err = nil } to = nil } args = [ 2 ] interface { } { frm , to } return } else if tail = = " " { op = " " args = [ 2 ] interface { } { nil , nil } return } else { res : = [ ] int { } for _ , x : = range strings . Split ( tail , " " ) { if i , err : = strconv . Atoi ( strings . Trim ( x , " " ) ) ; err = = nil { res = append ( res , i ) } else { return " " , " " , nil , err } } args = res } } return op , key , args , nil } 
func new Stream ( bufsize int , replay bool ) * Stream { return & Stream { Auto Replay : replay , subscribers : make ( [ ] * Subscriber , 0 ) , register : make ( chan * Subscriber ) , deregister : make ( chan * Subscriber ) , event : make ( chan * Event , bufsize ) , quit : make ( chan bool ) , Eventlog : make ( Event Log , 0 ) , } } 
func ( str * Stream ) add Subscriber ( eventid string ) * Subscriber { sub : = & Subscriber { eventid : eventid , quit : str . deregister , connection : make ( chan * Event , 6 4 ) , } str . register < - sub return sub } 
func New ( ) * Server { return & Server { Buffer Size : Default Buffer Size , Auto Stream : false , Auto Replay : true , Streams : make ( map [ string ] * Stream ) , } } 
func ( s * Server ) Close ( ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) for id : = range s . Streams { s . Streams [ id ] . quit < - true delete ( s . Streams , id ) } } 
func ( s * Server ) Create Stream ( id string ) * Stream { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] ! = nil { return s . Streams [ id ] } str : = new Stream ( s . Buffer Size , s . Auto Replay ) str . run ( ) s . Streams [ id ] = str return str } 
func ( s * Server ) Remove Stream ( id string ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] ! = nil { s . Streams [ id ] . close ( ) delete ( s . Streams , id ) } } 
func ( s * Server ) Stream Exists ( id string ) bool { s . mu . Lock ( ) defer s . mu . Unlock ( ) return s . Streams [ id ] ! = nil } 
func ( s * Server ) Publish ( id string , event * Event ) { s . mu . Lock ( ) defer s . mu . Unlock ( ) if s . Streams [ id ] ! = nil { s . Streams [ id ] . event < - s . process ( event ) } } 
func New Client ( url string ) * Client { return & Client { URL : url , Connection : & http . Client { } , Headers : make ( map [ string ] string ) , subscribed : make ( map [ chan * Event ] chan bool ) , } } 
func ( c * Client ) Subscribe ( stream string , handler func ( msg * Event ) ) error { operation : = func ( ) error { resp , err : = c . request ( stream ) if err ! = nil { return err } defer resp . Body . Close ( ) reader : = New Event Stream Reader ( resp . Body ) for { if err ! = nil { if err = = io . EOF { return nil } } return err } } else { msg . ID = [ ] byte ( c . Event ID ) } handler ( msg ) } } } return backoff . Retry ( operation , backoff . New Exponential Back Off ( ) ) } 
func ( c * Client ) Subscribe Chan ( stream string , ch chan * Event ) error { var connected bool errch : = make ( chan error ) c . mu . Lock ( ) c . subscribed [ ch ] = make ( chan bool ) c . mu . Unlock ( ) go func ( ) { operation : = func ( ) error { resp , err : = c . request ( stream ) if err ! = nil { c . cleanup ( resp , ch ) return err } if resp . Status Code ! = 2 0 0 { c . cleanup ( resp , ch ) return errors . New ( " " ) } if ! connected { errch < - nil connected = true } reader : = New Event Stream Reader ( resp . Body ) for { if err ! = nil { if err = = io . EOF { c . cleanup ( resp , ch ) return nil } } return err } } else { msg . ID = [ ] byte ( c . Event ID ) } select { case < - c . subscribed [ ch ] : c . cleanup ( resp , ch ) return nil case ch < - msg : } } } err : = backoff . Retry ( operation , backoff . New Exponential Back Off ( ) ) if err ! = nil & & ! connected { errch < - err } } ( ) err : = < - errch close ( errch ) return err } 
func ( c * Client ) Subscribe Raw ( handler func ( msg * Event ) ) error { return c . Subscribe ( " " , handler ) } 
func ( c * Client ) Unsubscribe ( ch chan * Event ) { c . mu . Lock ( ) defer c . mu . Unlock ( ) if c . subscribed [ ch ] ! = nil { c . subscribed [ ch ] < - true } } 
func New Event Stream Reader ( event Stream io . Reader ) * Event Stream Reader { scanner : = bufio . New Scanner ( event Stream ) split : = func ( data [ ] byte , at EOF bool ) ( int , [ ] byte , error ) { if at EOF & & len ( data ) = = 0 { return 0 , nil , nil } } if i : = bytes . Index ( data , [ ] byte ( " \r \r " ) ) ; i > = 0 { return i + 1 , data [ 0 : i ] , nil } if i : = bytes . Index ( data , [ ] byte ( " \n \n " ) ) ; i > = 0 { return i + 1 , data [ 0 : i ] , nil } } } return & Event Stream Reader { scanner : scanner , } } 
func ( e * Event Stream Reader ) Read Event ( ) ( [ ] byte , error ) { if e . scanner . Scan ( ) { event : = e . scanner . Bytes ( ) return event , nil } if err : = e . scanner . Err ( ) ; err ! = nil { return nil , err } return nil , io . EOF } 
func ( s * Server ) HTTPHandler ( w http . Response Writer , r * http . Request ) { flusher , err : = w . ( http . Flusher ) if ! err { http . Error ( w , " " , http . Status Internal Server Error ) return } w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) w . Header ( ) . Set ( " " , " " ) if stream ID = = " " { http . Error ( w , " " , http . Status Internal Server Error ) return } stream : = s . get Stream ( stream ID ) if stream = = nil & & ! s . Auto Stream { http . Error ( w , " " , http . Status Internal Server Error ) return } else if stream = = nil & & s . Auto Stream { stream = s . Create Stream ( stream ID ) } eventid : = r . Header . Get ( " " ) if eventid = = " " { eventid = " " } defer sub . close ( ) notify : = w . ( http . Close Notifier ) . Close Notify ( ) go func ( ) { < - notify sub . close ( ) } ( ) } } } fmt . Fprintf ( w , " \n " , ev . ID ) fmt . Fprintf ( w , " \n " , ev . Data ) if len ( ev . Event ) > 0 { fmt . Fprintf ( w , " \n " , ev . Event ) } if len ( ev . Retry ) > 0 { fmt . Fprintf ( w , " \n " , ev . Retry ) } fmt . Fprint ( w , " \n " ) flusher . Flush ( ) } } } 
func ( e * Event Log ) Add ( ev * Event ) { ev . ID = [ ] byte ( e . currentindex ( ) ) ev . timestamp = time . Now ( ) ( * e ) = append ( ( * e ) , ev ) } 
func ( e * Event Log ) Replay ( s * Subscriber ) { for i : = 0 ; i < len ( ( * e ) ) ; i + + { if string ( ( * e ) [ i ] . ID ) > = s . eventid { s . connection < - ( * e ) [ i ] } } } 
func read Config ( ) ( * user Config , error ) { b , err : = ioutil . Read File ( filepath . Join ( config Dir , account File ) ) if err ! = nil { return nil , err } uc : = & user Config { } if err : = json . Unmarshal ( b , uc ) ; err ! = nil { return nil , err } if key , err : = read Key ( filepath . Join ( config Dir , account Key ) ) ; err = = nil { uc . key = key } return uc , nil } 
func write Config ( uc * user Config ) error { b , err : = json . Marshal Indent ( uc , " " , " " ) if err ! = nil { return err } if err : = os . Mkdir All ( config Dir , 0 7 0 0 ) ; err ! = nil { return err } return ioutil . Write File ( filepath . Join ( config Dir , account File ) , b , 0 6 0 0 ) } 
func read Key ( path string ) ( crypto . Signer , error ) { b , err : = ioutil . Read File ( path ) if err ! = nil { return nil , err } d , _ : = pem . Decode ( b ) if d = = nil { return nil , fmt . Errorf ( " " , path ) } switch d . Type { case rsa Private Key : return x 5 0 9 . Parse PKCS 1Private Key ( d . Bytes ) case ec Private Key : return x 5 0 9 . Parse ECPrivate Key ( d . Bytes ) default : return nil , fmt . Errorf ( " " , d . Type ) } } 
func write Key ( path string , k * ecdsa . Private Key ) error { f , err : = os . Open File ( path , os . O _WRONLY | os . O _CREATE | os . O _TRUNC , 0 6 0 0 ) if err ! = nil { return err } bytes , err : = x 5 0 9 . Marshal ECPrivate Key ( k ) if err ! = nil { return err } b : = & pem . Block { Type : ec Private Key , Bytes : bytes } if err : = pem . Encode ( f , b ) ; err ! = nil { f . Close ( ) return err } return f . Close ( ) } 
func any Key ( filename string , gen bool ) ( crypto . Signer , error ) { k , err : = read Key ( filename ) if err = = nil { return k , nil } if ! os . Is Not Exist ( err ) | | ! gen { return nil , err } ec Key , err : = ecdsa . Generate Key ( elliptic . P 2 5 6 ( ) , rand . Reader ) if err ! = nil { return nil , err } return ec Key , write Key ( filename , ec Key ) } 
func same Dir ( existing , filename string ) string { return filepath . Join ( filepath . Dir ( existing ) , filename ) } 
func print Account ( w io . Writer , a * acme . Account , kp string ) { tw : = tabwriter . New Writer ( w , 0 , 8 , 0 , ' \t ' , 0 ) fmt . Fprintln ( tw , " \t " , a . URI ) fmt . Fprintln ( tw , " \t " , kp ) fmt . Fprintln ( tw , " \t " , strings . Join ( a . Contact , " " ) ) fmt . Fprintln ( tw , " \t " , a . Current Terms ) agreed : = a . Agreed Terms if a . Agreed Terms = = " " { agreed = " " } else if a . Agreed Terms = = a . Current Terms { agreed = " " } fmt . Fprintln ( tw , " \t " , agreed ) } 
func tmpl ( w io . Writer , text string , data interface { } ) { t : = template . New ( " " ) t . Funcs ( template . Func Map { " " : strings . Trim Space , " " : capitalize , } ) template . Must ( t . Parse ( text ) ) ew : = & err Writer { w : w } err : = t . Execute ( ew , data ) if ew . err ! = nil { } fatalf ( " " , ew . err ) } if err ! = nil { panic ( err ) } } 
func print Usage ( w io . Writer ) { bw : = bufio . New Writer ( w ) tmpl ( bw , usage Template , commands ) bw . Flush ( ) } 
func ( c * command ) Name ( ) string { name : = c . Usage Line i : = strings . Index Rune ( name , ' ' ) if i > = 0 { name = name [ : i ] } return name } 
func is Private Address ( address string ) ( bool , error ) { ip Address : = net . Parse IP ( address ) if ip Address = = nil { return false , errors . New ( " " ) } for i : = range cidrs { if cidrs [ i ] . Contains ( ip Address ) { return true , nil } } return false , nil } 
func From Request ( r * http . Request ) string { x Forwarded For : = r . Header . Get ( " " ) } else { remote IP = r . Remote Addr } return remote IP } is Private , err : = is Private Address ( address ) if ! is Private & & err = = nil { return address } } } 
func ( p * Clear Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Clear , p , nil ) } 
func ( p * Disable Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Disable , nil , nil ) } 
func ( p * Get DOMStorage Items Params ) Do ( ctx context . Context ) ( entries [ ] Item , err error ) { err = cdp . Execute ( ctx , Command Get DOMStorage Items , p , & res ) if err ! = nil { return nil , err } return res . Entries , nil } 
func Remove DOMStorage Item ( storage ID * Storage ID , key string ) * Remove DOMStorage Item Params { return & Remove DOMStorage Item Params { Storage ID : storage ID , Key : key , } } 
func ( p * Remove DOMStorage Item Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Remove DOMStorage Item , p , nil ) } 
func Set DOMStorage Item ( storage ID * Storage ID , key string , value string ) * Set DOMStorage Item Params { return & Set DOMStorage Item Params { Storage ID : storage ID , Key : key , Value : value , } } 
func ( p * Set DOMStorage Item Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set DOMStorage Item , p , nil ) } 
func ( v Trace Config ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Trace Config ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing ( & r , v ) return r . Error ( ) } 
func ( v Start Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Request Memory Dump Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Memory Dump Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 2 ( & r , v ) return r . Error ( ) } 
func ( v Request Memory Dump Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Memory Dump Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 3 ( & r , v ) return r . Error ( ) } 
func ( v Record Clock Sync Marker Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Record Clock Sync Marker Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 4 ( & r , v ) return r . Error ( ) } 
func ( v Memory Dump Config ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Memory Dump Config ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Categories Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Categories Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Categories Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Categories Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Tracing Complete ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Tracing Complete ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Data Collected ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Data Collected ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Buffer Usage ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Buffer Usage ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 1 0 ( & r , v ) return r . Error ( ) } 
func ( v End Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Tracing 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * End Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Tracing 1 1 ( & r , v ) return r . Error ( ) } 
func Deliver Push Message ( origin string , registration ID Registration ID , data string ) * Deliver Push Message Params { return & Deliver Push Message Params { Origin : origin , Registration ID : registration ID , Data : data , } } 
func ( p * Deliver Push Message Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Deliver Push Message , p , nil ) } 
func Dispatch Sync Event ( origin string , registration ID Registration ID , tag string , last Chance bool ) * Dispatch Sync Event Params { return & Dispatch Sync Event Params { Origin : origin , Registration ID : registration ID , Tag : tag , Last Chance : last Chance , } } 
func ( p * Dispatch Sync Event Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Dispatch Sync Event , p , nil ) } 
func ( p * Inspect Worker Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Inspect Worker , p , nil ) } 
func ( p * Set Force Update On Page Load Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Force Update On Page Load , p , nil ) } 
func ( p * Skip Waiting Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Skip Waiting , p , nil ) } 
func ( p * Start Worker Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Start Worker , p , nil ) } 
func ( p * Stop All Workers Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Stop All Workers , nil , nil ) } 
func ( p * Stop Worker Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Stop Worker , p , nil ) } 
func ( p * Unregister Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Unregister , p , nil ) } 
func ( p * Update Registration Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Update Registration , p , nil ) } 
func ( p * Bind Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Bind , p , nil ) } 
func ( p * Unbind Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Unbind , p , nil ) } 
func ( v Get Encoded Response Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Audits ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Encoded Response Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Audits ( & r , v ) return r . Error ( ) } 
func ( v Get Encoded Response Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Audits 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Encoded Response Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Audits 1 ( & r , v ) return r . Error ( ) } 
func ( e * Exception Details ) Error ( ) string { } 
func ( t * Timestamp ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { * t = Timestamp ( time . Unix ( 0 , int 6 4 ( in . Float 6 4 ( ) * float 6 4 ( time . Millisecond ) ) ) ) } 
func ( t * Timestamp ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Type ( in . String ( ) ) { case Type Object : * t = Type Object case Type Function : * t = Type Function case Type Undefined : * t = Type Undefined case Type String : * t = Type String case Type Number : * t = Type Number case Type Boolean : * t = Type Boolean case Type Symbol : * t = Type Symbol case Type Bigint : * t = Type Bigint case Type Accessor : * t = Type Accessor default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Subtype ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Subtype ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Subtype ( in . String ( ) ) { case Subtype Array : * t = Subtype Array case Subtype Null : * t = Subtype Null case Subtype Node : * t = Subtype Node case Subtype Regexp : * t = Subtype Regexp case Subtype Date : * t = Subtype Date case Subtype Map : * t = Subtype Map case Subtype Set : * t = Subtype Set case Subtype Weakmap : * t = Subtype Weakmap case Subtype Weakset : * t = Subtype Weakset case Subtype Iterator : * t = Subtype Iterator case Subtype Generator : * t = Subtype Generator case Subtype Error : * t = Subtype Error case Subtype Proxy : * t = Subtype Proxy case Subtype Promise : * t = Subtype Promise case Subtype Typedarray : * t = Subtype Typedarray case Subtype Arraybuffer : * t = Subtype Arraybuffer case Subtype Dataview : * t = Subtype Dataview default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Subtype ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t APIType ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * APIType ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch APIType ( in . String ( ) ) { case APIType Log : * t = APIType Log case APIType Debug : * t = APIType Debug case APIType Info : * t = APIType Info case APIType Error : * t = APIType Error case APIType Warning : * t = APIType Warning case APIType Dir : * t = APIType Dir case APIType Dirxml : * t = APIType Dirxml case APIType Table : * t = APIType Table case APIType Trace : * t = APIType Trace case APIType Clear : * t = APIType Clear case APIType Start Group : * t = APIType Start Group case APIType Start Group Collapsed : * t = APIType Start Group Collapsed case APIType End Group : * t = APIType End Group case APIType Assert : * t = APIType Assert case APIType Profile : * t = APIType Profile case APIType Profile End : * t = APIType Profile End case APIType Count : * t = APIType Count case APIType Time End : * t = APIType Time End default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * APIType ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( v Request Database Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Database Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb ( & r , v ) return r . Error ( ) } 
func ( v Request Database Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Database Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 ( & r , v ) return r . Error ( ) } 
func ( v Request Database Names Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Database Names Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 2 ( & r , v ) return r . Error ( ) } 
func ( v Request Database Names Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Database Names Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 3 ( & r , v ) return r . Error ( ) } 
func ( v Request Data Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Data Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 4 ( & r , v ) return r . Error ( ) } 
func ( v Request Data Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Data Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 5 ( & r , v ) return r . Error ( ) } 
func ( v Object Store Index ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Object Store Index ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 6 ( & r , v ) return r . Error ( ) } 
func ( v Object Store ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Object Store ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 7 ( & r , v ) return r . Error ( ) } 
func ( v Key Range ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Key Range ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 8 ( & r , v ) return r . Error ( ) } 
func ( v Key Path ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Key Path ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 9 ( & r , v ) return r . Error ( ) } 
func ( v Key ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Key ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Metadata Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Metadata Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Metadata Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Metadata Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Delete Object Store Entries Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Delete Object Store Entries Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Delete Database Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Delete Database Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Database With Object Stores ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Database With Object Stores ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 7 ( & r , v ) return r . Error ( ) } 
func ( v * Data Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Clear Object Store Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Indexeddb 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Object Store Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Indexeddb 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Violation Setting ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Log ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Violation Setting ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Log ( & r , v ) return r . Error ( ) } 
func ( v Stop Violations Report Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Log 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Violations Report Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Log 1 ( & r , v ) return r . Error ( ) } 
func ( v Start Violations Report Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Log 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Start Violations Report Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Log 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Entry Added ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Log 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Entry Added ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Log 3 ( & r , v ) return r . Error ( ) } 
func ( v Entry ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Log 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Log 4 ( & r , v ) return r . Error ( ) } 
func ( v Sticky Position Constraint ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sticky Position Constraint ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree ( & r , v ) return r . Error ( ) } 
func ( v Snapshot Command Log Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Snapshot Command Log Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 ( & r , v ) return r . Error ( ) } 
func ( v Snapshot Command Log Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Snapshot Command Log Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 2 ( & r , v ) return r . Error ( ) } 
func ( v Scroll Rect ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Scroll Rect ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 3 ( & r , v ) return r . Error ( ) } 
func ( v Replay Snapshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Replay Snapshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 4 ( & r , v ) return r . Error ( ) } 
func ( v Replay Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Replay Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 5 ( & r , v ) return r . Error ( ) } 
func ( v Release Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Release Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 6 ( & r , v ) return r . Error ( ) } 
func ( v Profile Snapshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Profile Snapshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 7 ( & r , v ) return r . Error ( ) } 
func ( v Profile Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Profile Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 8 ( & r , v ) return r . Error ( ) } 
func ( v Picture Tile ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Picture Tile ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 9 ( & r , v ) return r . Error ( ) } 
func ( v Make Snapshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Make Snapshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Make Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Make Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Load Snapshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Load Snapshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Load Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Load Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Layer ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Layer ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Layer Tree Did Change ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Layer Tree Did Change ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Layer Painted ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Layer Painted ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Enable Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Compositing Reasons Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Compositing Reasons Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Compositing Reasons Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Layertree 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Compositing Reasons Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Layertree 2 0 ( & r , v ) return r . Error ( ) } 
func ( t Style Sheet Origin ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Style Sheet Origin ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Style Sheet Origin ( in . String ( ) ) { case Style Sheet Origin Injected : * t = Style Sheet Origin Injected case Style Sheet Origin User Agent : * t = Style Sheet Origin User Agent case Style Sheet Origin Inspector : * t = Style Sheet Origin Inspector case Style Sheet Origin Regular : * t = Style Sheet Origin Regular default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Style Sheet Origin ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Media Source ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Media Source ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Media Source ( in . String ( ) ) { case Media Source Media Rule : * t = Media Source Media Rule case Media Source Import Rule : * t = Media Source Import Rule case Media Source Linked Sheet : * t = Media Source Linked Sheet case Media Source Inline Sheet : * t = Media Source Inline Sheet default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Media Source ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( v Take Heap Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Heap Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler ( & r , v ) return r . Error ( ) } 
func ( v Stop Tracking Heap Objects Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Tracking Heap Objects Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 ( & r , v ) return r . Error ( ) } 
func ( v Stop Sampling Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Sampling Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 2 ( & r , v ) return r . Error ( ) } 
func ( v * Stop Sampling Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 3 ( & r , v ) return r . Error ( ) } 
func ( v Start Tracking Heap Objects Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Start Tracking Heap Objects Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 4 ( & r , v ) return r . Error ( ) } 
func ( v Sampling Heap Profile Sample ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sampling Heap Profile Sample ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 6 ( & r , v ) return r . Error ( ) } 
func ( v Sampling Heap Profile Node ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sampling Heap Profile Node ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 7 ( & r , v ) return r . Error ( ) } 
func ( v Sampling Heap Profile ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sampling Heap Profile ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 8 ( & r , v ) return r . Error ( ) } 
func ( v Get Sampling Profile Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Sampling Profile Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 9 ( & r , v ) return r . Error ( ) } 
func ( v Get Sampling Profile Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Sampling Profile Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Object By Heap Object IDReturns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Object By Heap Object IDReturns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Object By Heap Object IDParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Object By Heap Object IDParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Heap Object IDReturns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Heap Object IDReturns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Heap Object IDParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Heap Object IDParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Reset Profiles ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Reset Profiles ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Report Heap Snapshot Progress ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Report Heap Snapshot Progress ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Last Seen Object ID ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Last Seen Object ID ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Heap Stats Update ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Heap Stats Update ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Add Heap Snapshot Chunk ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Add Heap Snapshot Chunk ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Collect Garbage Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Collect Garbage Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 2 2 ( & r , v ) return r . Error ( ) } 
func ( v Add Inspected Heap Object Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Heapprofiler 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Add Inspected Heap Object Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Heapprofiler 2 3 ( & r , v ) return r . Error ( ) } 
func ( p * Get Current Time Params ) Do ( ctx context . Context ) ( current Time float 6 4 , err error ) { err = cdp . Execute ( ctx , Command Get Current Time , p , & res ) if err ! = nil { return 0 , err } return res . Current Time , nil } 
func ( p * Get Playback Rate Params ) Do ( ctx context . Context ) ( playback Rate float 6 4 , err error ) { err = cdp . Execute ( ctx , Command Get Playback Rate , nil , & res ) if err ! = nil { return 0 , err } return res . Playback Rate , nil } 
func ( p * Release Animations Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Release Animations , p , nil ) } 
func ( p * Resolve Animation Params ) Do ( ctx context . Context ) ( remote Object * runtime . Remote Object , err error ) { err = cdp . Execute ( ctx , Command Resolve Animation , p , & res ) if err ! = nil { return nil , err } return res . Remote Object , nil } 
func Seek Animations ( animations [ ] string , current Time float 6 4 ) * Seek Animations Params { return & Seek Animations Params { Animations : animations , Current Time : current Time , } } 
func ( p * Seek Animations Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Seek Animations , p , nil ) } 
func Set Paused ( animations [ ] string , paused bool ) * Set Paused Params { return & Set Paused Params { Animations : animations , Paused : paused , } } 
func ( p * Set Paused Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Paused , p , nil ) } 
func ( p * Set Playback Rate Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Playback Rate , p , nil ) } 
func Set Timing ( animation ID string , duration float 6 4 , delay float 6 4 ) * Set Timing Params { return & Set Timing Params { Animation ID : animation ID , Duration : duration , Delay : delay , } } 
func ( p * Set Timing Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Timing , p , nil ) } 
func ( v empty ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * empty ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto ( & r , v ) return r . Error ( ) } 
func ( v Message ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Message ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto 1 ( & r , v ) return r . Error ( ) } 
func ( v Error ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Error ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto 2 ( & r , v ) return r . Error ( ) } 
func ( p * Get DOMCounters Params ) Do ( ctx context . Context ) ( documents int 6 4 , nodes int 6 4 , js Event Listeners int 6 4 , err error ) { err = cdp . Execute ( ctx , Command Get DOMCounters , nil , & res ) if err ! = nil { return 0 , 0 , 0 , err } return res . Documents , res . Nodes , res . Js Event Listeners , nil } 
func ( p * Prepare For Leak Detection Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Prepare For Leak Detection , nil , nil ) } 
func ( p * Forcibly Purge Java Script Memory Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Forcibly Purge Java Script Memory , nil , nil ) } 
func ( p * Set Pressure Notifications Suppressed Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Pressure Notifications Suppressed , p , nil ) } 
func ( p * Simulate Pressure Notification Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Simulate Pressure Notification , p , nil ) } 
func ( p Start Sampling Params ) With Sampling Interval ( sampling Interval int 6 4 ) * Start Sampling Params { p . Sampling Interval = sampling Interval return & p } 
func ( p Start Sampling Params ) With Suppress Randomness ( suppress Randomness bool ) * Start Sampling Params { p . Suppress Randomness = suppress Randomness return & p } 
func ( p * Start Sampling Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Start Sampling , p , nil ) } 
func ( p * Stop Sampling Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Stop Sampling , nil , nil ) } 
func ( p * Get All Time Sampling Profile Params ) Do ( ctx context . Context ) ( profile * Sampling Profile , err error ) { err = cdp . Execute ( ctx , Command Get All Time Sampling Profile , nil , & res ) if err ! = nil { return nil , err } return res . Profile , nil } 
func ( p * Get Browser Sampling Profile Params ) Do ( ctx context . Context ) ( profile * Sampling Profile , err error ) { err = cdp . Execute ( ctx , Command Get Browser Sampling Profile , nil , & res ) if err ! = nil { return nil , err } return res . Profile , nil } 
func ( p * Get Sampling Profile Params ) Do ( ctx context . Context ) ( profile * Sampling Profile , err error ) { err = cdp . Execute ( ctx , Command Get Sampling Profile , nil , & res ) if err ! = nil { return nil , err } return res . Profile , nil } 
func ( t Source ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Source ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Source ( in . String ( ) ) { case Source XML : * t = Source XML case Source Javascript : * t = Source Javascript case Source Network : * t = Source Network case Source Storage : * t = Source Storage case Source Appcache : * t = Source Appcache case Source Rendering : * t = Source Rendering case Source Security : * t = Source Security case Source Deprecation : * t = Source Deprecation case Source Worker : * t = Source Worker case Source Violation : * t = Source Violation case Source Intervention : * t = Source Intervention case Source Recommendation : * t = Source Recommendation case Source Other : * t = Source Other default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Source ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Level ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Level ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Level ( in . String ( ) ) { case Level Verbose : * t = Level Verbose case Level Info : * t = Level Info case Level Warning : * t = Level Warning case Level Error : * t = Level Error default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Level ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Violation ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Violation ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Violation ( in . String ( ) ) { case Violation Long Task : * t = Violation Long Task case Violation Long Layout : * t = Violation Long Layout case Violation Blocked Event : * t = Violation Blocked Event case Violation Blocked Parser : * t = Violation Blocked Parser case Violation Discouraged APIUse : * t = Violation Discouraged APIUse case Violation Handler : * t = Violation Handler case Violation Recurring Handler : * t = Violation Recurring Handler default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Violation ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Window State ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Window State ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Window State ( in . String ( ) ) { case Window State Normal : * t = Window State Normal case Window State Minimized : * t = Window State Minimized case Window State Maximized : * t = Window State Maximized case Window State Fullscreen : * t = Window State Fullscreen default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Window State ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Permission Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Permission Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Permission Type ( in . String ( ) ) { case Permission Type Accessibility Events : * t = Permission Type Accessibility Events case Permission Type Audio Capture : * t = Permission Type Audio Capture case Permission Type Background Sync : * t = Permission Type Background Sync case Permission Type Background Fetch : * t = Permission Type Background Fetch case Permission Type Clipboard Read : * t = Permission Type Clipboard Read case Permission Type Clipboard Write : * t = Permission Type Clipboard Write case Permission Type Durable Storage : * t = Permission Type Durable Storage case Permission Type Flash : * t = Permission Type Flash case Permission Type Geolocation : * t = Permission Type Geolocation case Permission Type Midi : * t = Permission Type Midi case Permission Type Midi Sysex : * t = Permission Type Midi Sysex case Permission Type Notifications : * t = Permission Type Notifications case Permission Type Payment Handler : * t = Permission Type Payment Handler case Permission Type Protected Media Identifier : * t = Permission Type Protected Media Identifier case Permission Type Sensors : * t = Permission Type Sensors case Permission Type Video Capture : * t = Permission Type Video Capture case Permission Type Idle Detection : * t = Permission Type Idle Detection default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Permission Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( p * Clear Device Orientation Override Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Clear Device Orientation Override , nil , nil ) } 
func Set Device Orientation Override ( alpha float 6 4 , beta float 6 4 , gamma float 6 4 ) * Set Device Orientation Override Params { return & Set Device Orientation Override Params { Alpha : alpha , Beta : beta , Gamma : gamma , } } 
func ( p * Set Device Orientation Override Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Device Orientation Override , p , nil ) } 
func ( t Request Stage ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Request Stage ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Request Stage ( in . String ( ) ) { case Request Stage Request : * t = Request Stage Request case Request Stage Response : * t = Request Stage Response default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Request Stage ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Auth Challenge Source ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Auth Challenge Source ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Auth Challenge Source ( in . String ( ) ) { case Auth Challenge Source Server : * t = Auth Challenge Source Server case Auth Challenge Source Proxy : * t = Auth Challenge Source Proxy default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Auth Challenge Source ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Auth Challenge Response Response ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Auth Challenge Response Response ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Auth Challenge Response Response ( in . String ( ) ) { case Auth Challenge Response Response Default : * t = Auth Challenge Response Response Default case Auth Challenge Response Response Cancel Auth : * t = Auth Challenge Response Response Cancel Auth case Auth Challenge Response Response Provide Credentials : * t = Auth Challenge Response Response Provide Credentials default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Auth Challenge Response Response ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Mixed Content Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Mixed Content Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Mixed Content Type ( in . String ( ) ) { case Mixed Content Type Blockable : * t = Mixed Content Type Blockable case Mixed Content Type Optionally Blockable : * t = Mixed Content Type Optionally Blockable case Mixed Content Type None : * t = Mixed Content Type None default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Mixed Content Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t State ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * State ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch State ( in . String ( ) ) { case State Unknown : * t = State Unknown case State Neutral : * t = State Neutral case State Insecure : * t = State Insecure case State Secure : * t = State Secure case State Info : * t = State Info default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * State ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Certificate Error Action ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Certificate Error Action ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Certificate Error Action ( in . String ( ) ) { case Certificate Error Action Continue : * t = Certificate Error Action Continue case Certificate Error Action Cancel : * t = Certificate Error Action Cancel default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Certificate Error Action ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t * Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Type ( in . String ( ) ) { case Type Appcache : * t = Type Appcache case Type Cookies : * t = Type Cookies case Type File Systems : * t = Type File Systems case Type Indexeddb : * t = Type Indexeddb case Type Local Storage : * t = Type Local Storage case Type Shader Cache : * t = Type Shader Cache case Type Websql : * t = Type Websql case Type Service Workers : * t = Type Service Workers case Type Cache Storage : * t = Type Cache Storage case Type All : * t = Type All case Type Other : * t = Type Other default : in . Add Error ( errors . New ( " " ) ) } } 
func ( p * Get Realtime Data Params ) Do ( ctx context . Context ) ( realtime Data * Context Realtime Data , err error ) { err = cdp . Execute ( ctx , Command Get Realtime Data , p , & res ) if err ! = nil { return nil , err } return res . Realtime Data , nil } 
func ( t Screenshot Params Format ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Screenshot Params Format ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Screenshot Params Format ( in . String ( ) ) { case Screenshot Params Format Jpeg : * t = Screenshot Params Format Jpeg case Screenshot Params Format Png : * t = Screenshot Params Format Png default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Screenshot Params Format ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( p * Start Violations Report Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Start Violations Report , p , nil ) } 
func ( p * Stop Violations Report Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Stop Violations Report , nil , nil ) } 
func ( v Take Response Body As Stream Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Response Body As Stream Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch ( & r , v ) return r . Error ( ) } 
func ( v Take Response Body As Stream Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Response Body As Stream Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 1 ( & r , v ) return r . Error ( ) } 
func ( v Request Pattern ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request Pattern ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 2 ( & r , v ) return r . Error ( ) } 
func ( v Header Entry ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Header Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Response Body Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Response Body Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 4 ( & r , v ) return r . Error ( ) } 
func ( v * Get Response Body Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 5 ( & r , v ) return r . Error ( ) } 
func ( v Fulfill Request Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Fulfill Request Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 6 ( & r , v ) return r . Error ( ) } 
func ( v Fail Request Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Fail Request Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Request Paused ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Request Paused ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Auth Required ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Auth Required ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 9 ( & r , v ) return r . Error ( ) } 
func ( v Disable Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Continue With Auth Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Continue With Auth Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Continue Request Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Continue Request Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Auth Challenge Response ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Auth Challenge ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Fetch 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Auth Challenge ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Fetch 1 5 ( & r , v ) return r . Error ( ) } 
func ( t Gesture Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Gesture Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Gesture Type ( in . String ( ) ) { case Gesture Default : * t = Gesture Default case Gesture Touch : * t = Gesture Touch case Gesture Mouse : * t = Gesture Mouse default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Gesture Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Time Since Epoch ) Marshal Easy JSON ( out * jwriter . Writer ) { v : = float 6 4 ( time . Time ( t ) . Unix Nano ( ) / int 6 4 ( time . Second ) ) out . Buffer . Ensure Space ( 2 0 ) out . Buffer . Buf = strconv . Append Float ( out . Buffer . Buf , v , 'f ' , - 1 , 6 4 ) } 
func ( t * Time Since Epoch ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { * t = Time Since Epoch ( time . Unix ( 0 , int 6 4 ( in . Float 6 4 ( ) * float 6 4 ( time . Second ) ) ) ) } 
func ( t * Time Since Epoch ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Modifier ) String ( ) string { switch t { case Modifier None : return " " case Modifier Alt : return " " case Modifier Ctrl : return " " case Modifier Meta : return " " case Modifier Shift : return " " } return fmt . Sprintf ( " " , t ) } 
func ( t Modifier ) Marshal Easy JSON ( out * jwriter . Writer ) { out . Int 6 4 ( int 6 4 ( t ) ) } 
func ( t * Modifier ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Modifier ( in . Int 6 4 ( ) ) { case Modifier None : * t = Modifier None case Modifier Alt : * t = Modifier Alt case Modifier Ctrl : * t = Modifier Ctrl case Modifier Meta : * t = Modifier Meta case Modifier Shift : * t = Modifier Shift default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Modifier ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Key Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Key Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Key Type ( in . String ( ) ) { case Key Down : * t = Key Down case Key Up : * t = Key Up case Key Raw Down : * t = Key Raw Down case Key Char : * t = Key Char default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Key Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Mouse Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Mouse Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Mouse Type ( in . String ( ) ) { case Mouse Pressed : * t = Mouse Pressed case Mouse Released : * t = Mouse Released case Mouse Moved : * t = Mouse Moved case Mouse Wheel : * t = Mouse Wheel default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Mouse Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Button Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Button Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Button Type ( in . String ( ) ) { case Button None : * t = Button None case Button Left : * t = Button Left case Button Middle : * t = Button Middle case Button Right : * t = Button Right case Button Back : * t = Button Back case Button Forward : * t = Button Forward default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Button Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Dispatch Mouse Event Pointer Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Dispatch Mouse Event Pointer Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Dispatch Mouse Event Pointer Type ( in . String ( ) ) { case Mouse : * t = Mouse case Pen : * t = Pen default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Dispatch Mouse Event Pointer Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Touch Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Touch Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Touch Type ( in . String ( ) ) { case Touch Start : * t = Touch Start case Touch End : * t = Touch End case Touch Move : * t = Touch Move case Touch Cancel : * t = Touch Cancel default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Touch Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t DOMBreakpoint Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * DOMBreakpoint Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch DOMBreakpoint Type ( in . String ( ) ) { case DOMBreakpoint Type Subtree Modified : * t = DOMBreakpoint Type Subtree Modified case DOMBreakpoint Type Attribute Modified : * t = DOMBreakpoint Type Attribute Modified case DOMBreakpoint Type Node Removed : * t = DOMBreakpoint Type Node Removed default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * DOMBreakpoint Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Scope Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Scope Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Scope Type ( in . String ( ) ) { case Scope Type Global : * t = Scope Type Global case Scope Type Local : * t = Scope Type Local case Scope Type With : * t = Scope Type With case Scope Type Closure : * t = Scope Type Closure case Scope Type Catch : * t = Scope Type Catch case Scope Type Block : * t = Scope Type Block case Scope Type Script : * t = Scope Type Script case Scope Type Eval : * t = Scope Type Eval case Scope Type Module : * t = Scope Type Module default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Scope Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Break Location Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Break Location Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Break Location Type ( in . String ( ) ) { case Break Location Type Debugger Statement : * t = Break Location Type Debugger Statement case Break Location Type Call : * t = Break Location Type Call case Break Location Type Return : * t = Break Location Type Return default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Break Location Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Paused Reason ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Paused Reason ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Paused Reason ( in . String ( ) ) { case Paused Reason XHR : * t = Paused Reason XHR case Paused Reason DOM : * t = Paused Reason DOM case Paused Reason Event Listener : * t = Paused Reason Event Listener case Paused Reason Exception : * t = Paused Reason Exception case Paused Reason Assert : * t = Paused Reason Assert case Paused Reason Debug Command : * t = Paused Reason Debug Command case Paused Reason Promise Rejection : * t = Paused Reason Promise Rejection case Paused Reason OOM : * t = Paused Reason OOM case Paused Reason Other : * t = Paused Reason Other case Paused Reason Ambiguous : * t = Paused Reason Ambiguous default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Paused Reason ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Continue To Location Target Call Frames ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Continue To Location Target Call Frames ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Continue To Location Target Call Frames ( in . String ( ) ) { case Continue To Location Target Call Frames Any : * t = Continue To Location Target Call Frames Any case Continue To Location Target Call Frames Current : * t = Continue To Location Target Call Frames Current default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Continue To Location Target Call Frames ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Exceptions State ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Exceptions State ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Exceptions State ( in . String ( ) ) { case Exceptions State None : * t = Exceptions State None case Exceptions State Uncaught : * t = Exceptions State Uncaught case Exceptions State All : * t = Exceptions State All default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Exceptions State ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( p Get Partial AXTree Params ) With Node ID ( node ID cdp . Node ID ) * Get Partial AXTree Params { p . Node ID = node ID return & p } 
func ( p Get Partial AXTree Params ) With Backend Node ID ( backend Node ID cdp . Backend Node ID ) * Get Partial AXTree Params { p . Backend Node ID = backend Node ID return & p } 
func ( p Get Partial AXTree Params ) With Object ID ( object ID runtime . Remote Object ID ) * Get Partial AXTree Params { p . Object ID = object ID return & p } 
func ( p Get Partial AXTree Params ) With Fetch Relatives ( fetch Relatives bool ) * Get Partial AXTree Params { p . Fetch Relatives = fetch Relatives return & p } 
func ( p * Get Partial AXTree Params ) Do ( ctx context . Context ) ( nodes [ ] * Node , err error ) { err = cdp . Execute ( ctx , Command Get Partial AXTree , p , & res ) if err ! = nil { return nil , err } return res . Nodes , nil } 
func ( p * Get Full AXTree Params ) Do ( ctx context . Context ) ( nodes [ ] * Node , err error ) { err = cdp . Execute ( ctx , Command Get Full AXTree , nil , & res ) if err ! = nil { return nil , err } return res . Nodes , nil } 
func ( v Touch Point ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Touch Point ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input ( & r , v ) return r . Error ( ) } 
func ( v Synthesize Tap Gesture Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Synthesize Tap Gesture Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 1 ( & r , v ) return r . Error ( ) } 
func ( v Synthesize Scroll Gesture Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Synthesize Scroll Gesture Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 2 ( & r , v ) return r . Error ( ) } 
func ( v Synthesize Pinch Gesture Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Synthesize Pinch Gesture Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Ignore Input Events Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Ignore Input Events Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 4 ( & r , v ) return r . Error ( ) } 
func ( v Insert Text Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Insert Text Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 5 ( & r , v ) return r . Error ( ) } 
func ( v Emulate Touch From Mouse Event Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Emulate Touch From Mouse Event Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 6 ( & r , v ) return r . Error ( ) } 
func ( v Dispatch Touch Event Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Dispatch Touch Event Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 7 ( & r , v ) return r . Error ( ) } 
func ( v Dispatch Mouse Event Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Dispatch Mouse Event Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 8 ( & r , v ) return r . Error ( ) } 
func ( v Dispatch Key Event Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Input 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Dispatch Key Event Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Input 9 ( & r , v ) return r . Error ( ) } 
func ( p * Set Time Domain Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Set Time Domain , p , nil ) } 
func ( p * Get Metrics Params ) Do ( ctx context . Context ) ( metrics [ ] * Metric , err error ) { err = cdp . Execute ( ctx , Command Get Metrics , nil , & res ) if err ! = nil { return nil , err } return res . Metrics , nil } 
func ( p * Compositing Reasons Params ) Do ( ctx context . Context ) ( compositing Reasons [ ] string , err error ) { err = cdp . Execute ( ctx , Command Compositing Reasons , p , & res ) if err ! = nil { return nil , err } return res . Compositing Reasons , nil } 
func ( p * Load Snapshot Params ) Do ( ctx context . Context ) ( snapshot ID Snapshot ID , err error ) { err = cdp . Execute ( ctx , Command Load Snapshot , p , & res ) if err ! = nil { return " " , err } return res . Snapshot ID , nil } 
func ( p * Make Snapshot Params ) Do ( ctx context . Context ) ( snapshot ID Snapshot ID , err error ) { err = cdp . Execute ( ctx , Command Make Snapshot , p , & res ) if err ! = nil { return " " , err } return res . Snapshot ID , nil } 
func ( p Profile Snapshot Params ) With Min Repeat Count ( min Repeat Count int 6 4 ) * Profile Snapshot Params { p . Min Repeat Count = min Repeat Count return & p } 
func ( p Profile Snapshot Params ) With Min Duration ( min Duration float 6 4 ) * Profile Snapshot Params { p . Min Duration = min Duration return & p } 
func ( p Profile Snapshot Params ) With Clip Rect ( clip Rect * dom . Rect ) * Profile Snapshot Params { p . Clip Rect = clip Rect return & p } 
func ( p * Profile Snapshot Params ) Do ( ctx context . Context ) ( timings [ ] Paint Profile , err error ) { err = cdp . Execute ( ctx , Command Profile Snapshot , p , & res ) if err ! = nil { return nil , err } return res . Timings , nil } 
func ( p * Release Snapshot Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Release Snapshot , p , nil ) } 
func ( p Replay Snapshot Params ) With From Step ( from Step int 6 4 ) * Replay Snapshot Params { p . From Step = from Step return & p } 
func ( p Replay Snapshot Params ) With To Step ( to Step int 6 4 ) * Replay Snapshot Params { p . To Step = to Step return & p } 
func ( p Replay Snapshot Params ) With Scale ( scale float 6 4 ) * Replay Snapshot Params { p . Scale = scale return & p } 
func ( p * Replay Snapshot Params ) Do ( ctx context . Context ) ( data URL string , err error ) { err = cdp . Execute ( ctx , Command Replay Snapshot , p , & res ) if err ! = nil { return " " , err } return res . Data URL , nil } 
func ( p * Snapshot Command Log Params ) Do ( ctx context . Context ) ( command Log [ ] easyjson . Raw Message , err error ) { err = cdp . Execute ( ctx , Command Snapshot Command Log , p , & res ) if err ! = nil { return nil , err } return res . Command Log , nil } 
func ( v Web Socket Response ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Web Socket Response ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network ( & r , v ) return r . Error ( ) } 
func ( v Web Socket Request ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Web Socket Request ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 ( & r , v ) return r . Error ( ) } 
func ( v Web Socket Frame ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Web Socket Frame ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 ( & r , v ) return r . Error ( ) } 
func ( v Take Response Body For Interception As Stream Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Response Body For Interception As Stream Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 ( & r , v ) return r . Error ( ) } 
func ( v Take Response Body For Interception As Stream Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Response Body For Interception As Stream Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 ( & r , v ) return r . Error ( ) } 
func ( v Signed Exchange Signature ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Signed Exchange Signature ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 ( & r , v ) return r . Error ( ) } 
func ( v Signed Exchange Info ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Signed Exchange Info ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 ( & r , v ) return r . Error ( ) } 
func ( v Signed Exchange Header ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Signed Exchange Header ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 7 ( & r , v ) return r . Error ( ) } 
func ( v Signed Exchange Error ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Signed Exchange Error ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 8 ( & r , v ) return r . Error ( ) } 
func ( v Signed Certificate Timestamp ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Signed Certificate Timestamp ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 9 ( & r , v ) return r . Error ( ) } 
func ( v Set Request Interception Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Request Interception Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Extra HTTPHeaders Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Extra HTTPHeaders Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Data Size Limits For Test Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Data Size Limits For Test Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Cookies Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Cookies Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Cookie Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Cookie Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Set Cookie Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Cookie Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Cache Disabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Cache Disabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Bypass Service Worker Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Bypass Service Worker Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Blocked URLSParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Blocked URLSParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Security Details ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Security Details ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Search In Response Body Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Response Body Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Search In Response Body Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Response Body Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 1 ( & r , v ) return r . Error ( ) } 
func ( v Response ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Resource Timing ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Resource Timing ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 3 ( & r , v ) return r . Error ( ) } 
func ( v Request ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Request ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 5 ( & r , v ) return r . Error ( ) } 
func ( v Replay XHRParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Replay XHRParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 6 ( & r , v ) return r . Error ( ) } 
func ( v Initiator ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Initiator ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 2 7 ( & r , v ) return r . Error ( ) } 
func ( v Get Response Body Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 2 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Get Response Body For Interception Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Response Body For Interception Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Response Body For Interception Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Response Body For Interception Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Request Post Data Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Request Post Data Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Request Post Data Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Request Post Data Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Cookies Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Cookies Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 4 ( & r , v ) return r . Error ( ) } 
func ( v Get Cookies Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Cookies Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Certificate Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Certificate Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Certificate Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Certificate Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 7 ( & r , v ) return r . Error ( ) } 
func ( v Get All Cookies Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get All Cookies Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 8 ( & r , v ) return r . Error ( ) } 
func ( v Get All Cookies Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 3 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get All Cookies Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 3 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Will Send Handshake Request ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Will Send Handshake Request ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Handshake Response Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Handshake Response Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Frame Sent ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Frame Sent ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Frame Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Frame Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Frame Error ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Frame Error ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Created ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Created ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Web Socket Closed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Web Socket Closed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Signed Exchange Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Signed Exchange Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Response Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Response Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Resource Changed Priority ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 4 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Resource Changed Priority ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 4 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Request Will Be Sent ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Request Will Be Sent ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Request Served From Cache ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Request Served From Cache ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Request Intercepted ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Request Intercepted ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Loading Finished ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Loading Finished ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Loading Failed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Loading Failed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Event Source Message Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Event Source Message Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Data Received ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Data Received ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 6 ( & r , v ) return r . Error ( ) } 
func ( v Emulate Network Conditions Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 5 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Emulate Network Conditions Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 5 8 ( & r , v ) return r . Error ( ) } 
func ( v Delete Cookies Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Delete Cookies Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 0 ( & r , v ) return r . Error ( ) } 
func ( v Cookie Param ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Cookie Param ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 1 ( & r , v ) return r . Error ( ) } 
func ( v Continue Intercepted Request Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Continue Intercepted Request Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 3 ( & r , v ) return r . Error ( ) } 
func ( v Clear Browser Cookies Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Browser Cookies Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 4 ( & r , v ) return r . Error ( ) } 
func ( v Clear Browser Cache Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Browser Cache Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 5 ( & r , v ) return r . Error ( ) } 
func ( v Cached Resource ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Network 6 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Cached Resource ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 6 ( & r , v ) return r . Error ( ) } 
func ( v * Auth Challenge Response ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Network 6 7 ( & r , v ) return r . Error ( ) } 
func ( v Text Box Snapshot ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Text Box Snapshot ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot ( & r , v ) return r . Error ( ) } 
func ( v Rare String Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rare String Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 1 ( & r , v ) return r . Error ( ) } 
func ( v Rare Integer Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rare Integer Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 2 ( & r , v ) return r . Error ( ) } 
func ( v Rare Boolean Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rare Boolean Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 3 ( & r , v ) return r . Error ( ) } 
func ( v Node Tree Snapshot ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Node Tree Snapshot ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 4 ( & r , v ) return r . Error ( ) } 
func ( v Name Value ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Name Value ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 5 ( & r , v ) return r . Error ( ) } 
func ( v Layout Tree Snapshot ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Layout Tree Snapshot ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 6 ( & r , v ) return r . Error ( ) } 
func ( v Layout Tree Node ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Layout Tree Node ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 7 ( & r , v ) return r . Error ( ) } 
func ( v Inline Text Box ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Inline Text Box ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 8 ( & r , v ) return r . Error ( ) } 
func ( v Document Snapshot ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Document Snapshot ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 1 0 ( & r , v ) return r . Error ( ) } 
func ( v DOMNode ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * DOMNode ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Computed Style ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Domsnapshot 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Computed Style ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 1 3 ( & r , v ) return r . Error ( ) } 
func ( v * Capture Snapshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Domsnapshot 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Stop Sampling Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Start Sampling Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Start Sampling Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 ( & r , v ) return r . Error ( ) } 
func ( v Simulate Pressure Notification Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Simulate Pressure Notification Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Pressure Notifications Suppressed Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Pressure Notifications Suppressed Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 3 ( & r , v ) return r . Error ( ) } 
func ( v Sampling Profile Node ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sampling Profile Node ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 4 ( & r , v ) return r . Error ( ) } 
func ( v Sampling Profile ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Sampling Profile ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 5 ( & r , v ) return r . Error ( ) } 
func ( v Prepare For Leak Detection Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Prepare For Leak Detection Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 6 ( & r , v ) return r . Error ( ) } 
func ( v Module ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Module ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 7 ( & r , v ) return r . Error ( ) } 
func ( v Get DOMCounters Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get DOMCounters Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Get DOMCounters Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get DOMCounters Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Browser Sampling Profile Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Browser Sampling Profile Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Browser Sampling Profile Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Browser Sampling Profile Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Get All Time Sampling Profile Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get All Time Sampling Profile Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Get All Time Sampling Profile Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get All Time Sampling Profile Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Forcibly Purge Java Script Memory Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Memory 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Forcibly Purge Java Script Memory Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Memory 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Take Coverage Delta Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Coverage Delta Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 ( & r , v ) return r . Error ( ) } 
func ( v Take Coverage Delta Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Take Coverage Delta Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 ( & r , v ) return r . Error ( ) } 
func ( v Style Sheet Header ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Style Sheet Header ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 ( & r , v ) return r . Error ( ) } 
func ( v Style Declaration Edit ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Style Declaration Edit ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 ( & r , v ) return r . Error ( ) } 
func ( v Style ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Style ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 ( & r , v ) return r . Error ( ) } 
func ( v Stop Rule Usage Tracking Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Rule Usage Tracking Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 ( & r , v ) return r . Error ( ) } 
func ( v Stop Rule Usage Tracking Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Rule Usage Tracking Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 7 ( & r , v ) return r . Error ( ) } 
func ( v Start Rule Usage Tracking Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Start Rule Usage Tracking Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 8 ( & r , v ) return r . Error ( ) } 
func ( v Source Range ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Source Range ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 9 ( & r , v ) return r . Error ( ) } 
func ( v Shorthand Entry ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Shorthand Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Style Texts Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Style Texts Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Style Texts Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Style Texts Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Style Sheet Text Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Style Sheet Text Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Style Sheet Text Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Style Sheet Text Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Set Rule Selector Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Rule Selector Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Rule Selector Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Rule Selector Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Media Text Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Media Text Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Media Text Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Media Text Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Set Keyframe Key Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Keyframe Key Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Set Keyframe Key Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Keyframe Key Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Effective Property Value For Node Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Effective Property Value For Node Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 1 ( & r , v ) return r . Error ( ) } 
func ( v Selector List ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Selector List ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 2 ( & r , v ) return r . Error ( ) } 
func ( v Rule Usage ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rule Usage ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 3 ( & r , v ) return r . Error ( ) } 
func ( v Rule Match ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rule Match ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 4 ( & r , v ) return r . Error ( ) } 
func ( v Rule ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Rule ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 5 ( & r , v ) return r . Error ( ) } 
func ( v Pseudo Element Matches ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Pseudo Element Matches ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 6 ( & r , v ) return r . Error ( ) } 
func ( v Property ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Property ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 7 ( & r , v ) return r . Error ( ) } 
func ( v Platform Font Usage ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Platform Font Usage ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 8 ( & r , v ) return r . Error ( ) } 
func ( v Media Query Expression ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 2 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Media Query Expression ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 2 9 ( & r , v ) return r . Error ( ) } 
func ( v Media Query ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Media Query ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 0 ( & r , v ) return r . Error ( ) } 
func ( v Media ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Media ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 1 ( & r , v ) return r . Error ( ) } 
func ( v Keyframes Rule ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Keyframe Rule ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Keyframe Rule ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 3 ( & r , v ) return r . Error ( ) } 
func ( v Inherited Style Entry ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Inherited Style Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 4 ( & r , v ) return r . Error ( ) } 
func ( v Get Style Sheet Text Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Style Sheet Text Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Style Sheet Text Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Style Sheet Text Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Platform Fonts For Node Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Platform Fonts For Node Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 7 ( & r , v ) return r . Error ( ) } 
func ( v Get Platform Fonts For Node Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Platform Fonts For Node Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 8 ( & r , v ) return r . Error ( ) } 
func ( v Get Media Queries Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 3 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Media Queries Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 3 9 ( & r , v ) return r . Error ( ) } 
func ( v Get Media Queries Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Media Queries Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Matched Styles For Node Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Matched Styles For Node Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Matched Styles For Node Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Matched Styles For Node Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Inline Styles For Node Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Inline Styles For Node Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Inline Styles For Node Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Inline Styles For Node Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 4 ( & r , v ) return r . Error ( ) } 
func ( v Get Computed Style For Node Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Computed Style For Node Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Computed Style For Node Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Computed Style For Node Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Background Colors Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Background Colors Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 7 ( & r , v ) return r . Error ( ) } 
func ( v Get Background Colors Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Background Colors Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 8 ( & r , v ) return r . Error ( ) } 
func ( v Force Pseudo State Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 4 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Force Pseudo State Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 4 9 ( & r , v ) return r . Error ( ) } 
func ( v Font Face ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Font Face ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Style Sheet Removed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Style Sheet Removed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Style Sheet Changed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Style Sheet Changed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Style Sheet Added ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Style Sheet Added ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Media Query Result Changed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Media Query Result Changed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Fonts Updated ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Fonts Updated ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 5 ( & r , v ) return r . Error ( ) } 
func ( v * Disable Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 7 ( & r , v ) return r . Error ( ) } 
func ( v Create Style Sheet Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Style Sheet Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 8 ( & r , v ) return r . Error ( ) } 
func ( v Create Style Sheet Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 5 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Style Sheet Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 5 9 ( & r , v ) return r . Error ( ) } 
func ( v Computed Property ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Computed Property ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 0 ( & r , v ) return r . Error ( ) } 
func ( v Collect Class Names Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Collect Class Names Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 1 ( & r , v ) return r . Error ( ) } 
func ( v Collect Class Names Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Collect Class Names Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 2 ( & r , v ) return r . Error ( ) } 
func ( v Add Rule Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Add Rule Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 3 ( & r , v ) return r . Error ( ) } 
func ( v Add Rule Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Css 6 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Add Rule Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Css 6 4 ( & r , v ) return r . Error ( ) } 
func ( v Step Over Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Step Over Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger ( & r , v ) return r . Error ( ) } 
func ( v Step Out Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Step Out Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 ( & r , v ) return r . Error ( ) } 
func ( v Step Into Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Step Into Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Variable Value Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Variable Value Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Skip All Pauses Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Skip All Pauses Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 ( & r , v ) return r . Error ( ) } 
func ( v Set Script Source Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Script Source Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Script Source Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Script Source Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Return Value Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Return Value Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Pause On Exceptions Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Pause On Exceptions Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 8 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoints Active Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoints Active Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 9 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint On Function Call Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint On Function Call Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint On Function Call Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint On Function Call Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint By URLReturns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint By URLReturns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Set Breakpoint By URLParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Breakpoint By URLParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Blackboxed Ranges Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Blackboxed Ranges Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Blackbox Patterns Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Blackbox Patterns Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Async Call Stack Depth Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Async Call Stack Depth Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Search Match ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search Match ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Search In Content Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Content Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Search In Content Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Content Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 1 ( & r , v ) return r . Error ( ) } 
func ( v Script Position ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Script Position ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 2 ( & r , v ) return r . Error ( ) } 
func ( v Scope ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Scope ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 3 ( & r , v ) return r . Error ( ) } 
func ( v Resume Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Resume Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 4 ( & r , v ) return r . Error ( ) } 
func ( v Restart Frame Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Restart Frame Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 5 ( & r , v ) return r . Error ( ) } 
func ( v Restart Frame Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Restart Frame Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 6 ( & r , v ) return r . Error ( ) } 
func ( v Remove Breakpoint Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Remove Breakpoint Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 7 ( & r , v ) return r . Error ( ) } 
func ( v Pause Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Pause Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 8 ( & r , v ) return r . Error ( ) } 
func ( v Pause On Async Call Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 2 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Pause On Async Call Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 2 9 ( & r , v ) return r . Error ( ) } 
func ( v Location ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Location ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Stack Trace Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Stack Trace Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Stack Trace Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Stack Trace Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Script Source Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Script Source Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Script Source Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Script Source Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 4 ( & r , v ) return r . Error ( ) } 
func ( v Get Possible Breakpoints Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Possible Breakpoints Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Possible Breakpoints Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Possible Breakpoints Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Script Parsed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Script Parsed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Script Failed To Parse ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Script Failed To Parse ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Resumed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 3 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Resumed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 3 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Paused ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Paused ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Breakpoint Resolved ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Breakpoint Resolved ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 1 ( & r , v ) return r . Error ( ) } 
func ( v Evaluate On Call Frame Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Evaluate On Call Frame Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 2 ( & r , v ) return r . Error ( ) } 
func ( v Evaluate On Call Frame Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Evaluate On Call Frame Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 3 ( & r , v ) return r . Error ( ) } 
func ( v Enable Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Enable Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 4 ( & r , v ) return r . Error ( ) } 
func ( v Continue To Location Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Continue To Location Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 7 ( & r , v ) return r . Error ( ) } 
func ( v * Call Frame ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 8 ( & r , v ) return r . Error ( ) } 
func ( v Break Location ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Debugger 4 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Break Location ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Debugger 4 9 ( & r , v ) return r . Error ( ) } 
func ( t Pressure Level ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Pressure Level ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Pressure Level ( in . String ( ) ) { case Pressure Level Moderate : * t = Pressure Level Moderate case Pressure Level Critical : * t = Pressure Level Critical default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Pressure Level ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( v Timings ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Timings ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har ( & r , v ) return r . Error ( ) } 
func ( v * Response ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 1 ( & r , v ) return r . Error ( ) } 
func ( v Post Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Post Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 3 ( & r , v ) return r . Error ( ) } 
func ( v Param ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Param ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 4 ( & r , v ) return r . Error ( ) } 
func ( v Page Timings ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Page Timings ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 5 ( & r , v ) return r . Error ( ) } 
func ( v Page ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Page ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 6 ( & r , v ) return r . Error ( ) } 
func ( v Name Value Pair ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Name Value Pair ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 7 ( & r , v ) return r . Error ( ) } 
func ( v Log ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Log ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 8 ( & r , v ) return r . Error ( ) } 
func ( v HAR ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * HAR ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 9 ( & r , v ) return r . Error ( ) } 
func ( v Creator ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Creator ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Cookie ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Cookie ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Content ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Content ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Cache Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Cache Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Har 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Cache ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Har 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Set Virtual Time Policy Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Virtual Time Policy Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation ( & r , v ) return r . Error ( ) } 
func ( v Set Virtual Time Policy Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Virtual Time Policy Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 ( & r , v ) return r . Error ( ) } 
func ( v Set User Agent Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set User Agent Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Touch Emulation Enabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Touch Emulation Enabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Scrollbars Hidden Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Scrollbars Hidden Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 4 ( & r , v ) return r . Error ( ) } 
func ( v Set Script Execution Disabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Script Execution Disabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Page Scale Factor Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Page Scale Factor Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Geolocation Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Geolocation Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Focus Emulation Enabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Focus Emulation Enabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 8 ( & r , v ) return r . Error ( ) } 
func ( v Set Emulated Media Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Emulated Media Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 9 ( & r , v ) return r . Error ( ) } 
func ( v Set Emit Touch Events For Mouse Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Emit Touch Events For Mouse Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Document Cookie Disabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Document Cookie Disabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Device Metrics Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Device Metrics Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Default Background Color Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Default Background Color Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Set CPUThrottling Rate Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set CPUThrottling Rate Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Screen Orientation ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Screen Orientation ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Reset Page Scale Factor Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Reset Page Scale Factor Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Virtual Time Budget Expired ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Virtual Time Budget Expired ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Clear Geolocation Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Geolocation Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Clear Device Metrics Override Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Device Metrics Override Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Can Emulate Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Can Emulate Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Can Emulate Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Emulation 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Can Emulate Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Emulation 2 1 ( & r , v ) return r . Error ( ) } 
func ( t * Key Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Key Type ( in . String ( ) ) { case Key Type Number : * t = Key Type Number case Key Type String : * t = Key Type String case Key Type Date : * t = Key Type Date case Key Type Array : * t = Key Type Array default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t Key Path Type ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Key Path Type ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Key Path Type ( in . String ( ) ) { case Key Path Type Null : * t = Key Path Type Null case Key Path Type String : * t = Key Path Type String case Key Path Type Array : * t = Key Path Type Array default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Key Path Type ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Stream Format ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Stream Format ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Stream Format ( in . String ( ) ) { case Stream Format JSON : * t = Stream Format JSON case Stream Format Proto : * t = Stream Format Proto default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Stream Format ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Stream Compression ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Stream Compression ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Stream Compression ( in . String ( ) ) { case Stream Compression None : * t = Stream Compression None case Stream Compression Gzip : * t = Stream Compression Gzip default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Stream Compression ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Record Mode ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Record Mode ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Record Mode ( in . String ( ) ) { case Record Mode Record Until Full : * t = Record Mode Record Until Full case Record Mode Record Continuously : * t = Record Mode Record Continuously case Record Mode Record As Much As Possible : * t = Record Mode Record As Much As Possible case Record Mode Echo To Console : * t = Record Mode Echo To Console default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Record Mode ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func ( t Transfer Mode ) Marshal Easy JSON ( out * jwriter . Writer ) { out . String ( string ( t ) ) } 
func ( t * Transfer Mode ) Unmarshal Easy JSON ( in * jlexer . Lexer ) { switch Transfer Mode ( in . String ( ) ) { case Transfer Mode Report Events : * t = Transfer Mode Report Events case Transfer Mode Return As Stream : * t = Transfer Mode Return As Stream default : in . Add Error ( errors . New ( " " ) ) } } 
func ( t * Transfer Mode ) Unmarshal JSON ( buf [ ] byte ) error { return easyjson . Unmarshal ( buf , t ) } 
func Clear Object Store ( security Origin string , database Name string , object Store Name string ) * Clear Object Store Params { return & Clear Object Store Params { Security Origin : security Origin , Database Name : database Name , Object Store Name : object Store Name , } } 
func ( p * Clear Object Store Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Clear Object Store , p , nil ) } 
func Delete Database ( security Origin string , database Name string ) * Delete Database Params { return & Delete Database Params { Security Origin : security Origin , Database Name : database Name , } } 
func ( p * Delete Database Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Delete Database , p , nil ) } 
func Delete Object Store Entries ( security Origin string , database Name string , object Store Name string , key Range * Key Range ) * Delete Object Store Entries Params { return & Delete Object Store Entries Params { Security Origin : security Origin , Database Name : database Name , Object Store Name : object Store Name , Key Range : key Range , } } 
func ( p * Delete Object Store Entries Params ) Do ( ctx context . Context ) ( err error ) { return cdp . Execute ( ctx , Command Delete Object Store Entries , p , nil ) } 
func Request Data ( security Origin string , database Name string , object Store Name string , index Name string , skip Count int 6 4 , page Size int 6 4 ) * Request Data Params { return & Request Data Params { Security Origin : security Origin , Database Name : database Name , Object Store Name : object Store Name , Index Name : index Name , Skip Count : skip Count , Page Size : page Size , } } 
func ( p Request Data Params ) With Key Range ( key Range * Key Range ) * Request Data Params { p . Key Range = key Range return & p } 
func ( p * Request Data Params ) Do ( ctx context . Context ) ( object Store Data Entries [ ] * Data Entry , has More bool , err error ) { err = cdp . Execute ( ctx , Command Request Data , p , & res ) if err ! = nil { return nil , false , err } return res . Object Store Data Entries , res . Has More , nil } 
func Get Metadata ( security Origin string , database Name string , object Store Name string ) * Get Metadata Params { return & Get Metadata Params { Security Origin : security Origin , Database Name : database Name , Object Store Name : object Store Name , } } 
func ( p * Get Metadata Params ) Do ( ctx context . Context ) ( entries Count float 6 4 , key Generator Value float 6 4 , err error ) { err = cdp . Execute ( ctx , Command Get Metadata , p , & res ) if err ! = nil { return 0 , 0 , err } return res . Entries Count , res . Key Generator Value , nil } 
func Request Database ( security Origin string , database Name string ) * Request Database Params { return & Request Database Params { Security Origin : security Origin , Database Name : database Name , } } 
func ( p * Request Database Params ) Do ( ctx context . Context ) ( database With Object Stores * Database With Object Stores , err error ) { err = cdp . Execute ( ctx , Command Request Database , p , & res ) if err ! = nil { return nil , err } return res . Database With Object Stores , nil } 
func ( p * Request Database Names Params ) Do ( ctx context . Context ) ( database Names [ ] string , err error ) { err = cdp . Execute ( ctx , Command Request Database Names , p , & res ) if err ! = nil { return nil , err } return res . Database Names , nil } 
func ( v Event Target Reloaded After Crash ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Inspector ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Target Reloaded After Crash ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Inspector ( & r , v ) return r . Error ( ) } 
func ( v Event Detached ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Inspector 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Detached ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Inspector 2 ( & r , v ) return r . Error ( ) } 
func ( v * Enable Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Inspector 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Realtime Data Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Realtime Data Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio ( & r , v ) return r . Error ( ) } 
func ( v Get Realtime Data Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Realtime Data Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Context Destroyed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Context Destroyed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Context Created ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Context Created ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Context Changed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Context Changed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 4 ( & r , v ) return r . Error ( ) } 
func ( v Context Realtime Data ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Context Realtime Data ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 7 ( & r , v ) return r . Error ( ) } 
func ( v Base Audio Context ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Webaudio 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Base Audio Context ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Webaudio 8 ( & r , v ) return r . Error ( ) } 
func ( v Set Remote Locations Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Remote Locations Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target ( & r , v ) return r . Error ( ) } 
func ( v Set Discover Targets Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Discover Targets Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Auto Attach Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Auto Attach Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 ( & r , v ) return r . Error ( ) } 
func ( v Send Message To Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Send Message To Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 3 ( & r , v ) return r . Error ( ) } 
func ( v Remote Location ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Remote Location ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 4 ( & r , v ) return r . Error ( ) } 
func ( v Info ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Info ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Targets Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Targets Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Targets Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Targets Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 7 ( & r , v ) return r . Error ( ) } 
func ( v Get Target Info Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Target Info Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 8 ( & r , v ) return r . Error ( ) } 
func ( v Get Target Info Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Target Info Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 9 ( & r , v ) return r . Error ( ) } 
func ( v Get Browser Contexts Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Browser Contexts Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Browser Contexts Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Browser Contexts Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Expose Dev Tools Protocol Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Expose Dev Tools Protocol Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Target Info Changed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Target Info Changed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Target Destroyed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Target Destroyed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Target Created ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Target Created ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Target Crashed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Target Crashed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Received Message From Target ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Received Message From Target ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Detached From Target ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Detached From Target ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Attached To Target ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Attached To Target ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Dispose Browser Context Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Dispose Browser Context Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Detach From Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Detach From Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 1 ( & r , v ) return r . Error ( ) } 
func ( v Create Target Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Target Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 2 ( & r , v ) return r . Error ( ) } 
func ( v Create Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 3 ( & r , v ) return r . Error ( ) } 
func ( v Create Browser Context Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Browser Context Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 4 ( & r , v ) return r . Error ( ) } 
func ( v Create Browser Context Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Browser Context Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 5 ( & r , v ) return r . Error ( ) } 
func ( v Close Target Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Close Target Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 6 ( & r , v ) return r . Error ( ) } 
func ( v Close Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Close Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 7 ( & r , v ) return r . Error ( ) } 
func ( v Attach To Target Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Attach To Target Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 8 ( & r , v ) return r . Error ( ) } 
func ( v Attach To Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 2 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Attach To Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 2 9 ( & r , v ) return r . Error ( ) } 
func ( v Attach To Browser Target Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 3 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Attach To Browser Target Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 3 0 ( & r , v ) return r . Error ( ) } 
func ( v Attach To Browser Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 3 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Attach To Browser Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 3 1 ( & r , v ) return r . Error ( ) } 
func ( v Activate Target Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Target 3 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Activate Target Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Target 3 2 ( & r , v ) return r . Error ( ) } 
func ( v Wait For Debugger Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Wait For Debugger Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page ( & r , v ) return r . Error ( ) } 
func ( v Visual Viewport ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Visual Viewport ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 ( & r , v ) return r . Error ( ) } 
func ( v Viewport ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Viewport ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 ( & r , v ) return r . Error ( ) } 
func ( v Stop Screencast Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Screencast Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 ( & r , v ) return r . Error ( ) } 
func ( v Stop Loading Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Stop Loading Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 ( & r , v ) return r . Error ( ) } 
func ( v Start Screencast Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Start Screencast Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 ( & r , v ) return r . Error ( ) } 
func ( v Set Web Lifecycle State Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Web Lifecycle State Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 ( & r , v ) return r . Error ( ) } 
func ( v Set Produce Compilation Cache Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Produce Compilation Cache Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 ( & r , v ) return r . Error ( ) } 
func ( v Set Lifecycle Events Enabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Lifecycle Events Enabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 8 ( & r , v ) return r . Error ( ) } 
func ( v Set Font Sizes Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Font Sizes Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 9 ( & r , v ) return r . Error ( ) } 
func ( v Set Font Families Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Font Families Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 0 ( & r , v ) return r . Error ( ) } 
func ( v Set Download Behavior Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Download Behavior Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 1 ( & r , v ) return r . Error ( ) } 
func ( v Set Document Content Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Document Content Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 2 ( & r , v ) return r . Error ( ) } 
func ( v Set Bypass CSPParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Bypass CSPParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 3 ( & r , v ) return r . Error ( ) } 
func ( v Set Ad Blocking Enabled Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Set Ad Blocking Enabled Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 4 ( & r , v ) return r . Error ( ) } 
func ( v Search In Resource Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Resource Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 5 ( & r , v ) return r . Error ( ) } 
func ( v Search In Resource Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Search In Resource Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 6 ( & r , v ) return r . Error ( ) } 
func ( v Screencast Frame Metadata ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Screencast Frame Metadata ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 7 ( & r , v ) return r . Error ( ) } 
func ( v Screencast Frame Ack Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Screencast Frame Ack Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 8 ( & r , v ) return r . Error ( ) } 
func ( v Reset Navigation History Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 1 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Reset Navigation History Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 1 9 ( & r , v ) return r . Error ( ) } 
func ( v Remove Script To Evaluate On New Document Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Remove Script To Evaluate On New Document Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 0 ( & r , v ) return r . Error ( ) } 
func ( v Reload Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Reload Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 1 ( & r , v ) return r . Error ( ) } 
func ( v Print To PDFReturns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Print To PDFReturns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 2 ( & r , v ) return r . Error ( ) } 
func ( v Print To PDFParams ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Print To PDFParams ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 3 ( & r , v ) return r . Error ( ) } 
func ( v Navigation Entry ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Navigation Entry ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 4 ( & r , v ) return r . Error ( ) } 
func ( v Navigate To History Entry Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Navigate To History Entry Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 5 ( & r , v ) return r . Error ( ) } 
func ( v Navigate Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Navigate Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 6 ( & r , v ) return r . Error ( ) } 
func ( v Navigate Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Navigate Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 7 ( & r , v ) return r . Error ( ) } 
func ( v Layout Viewport ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Layout Viewport ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 8 ( & r , v ) return r . Error ( ) } 
func ( v Handle Java Script Dialog Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 2 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Handle Java Script Dialog Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 2 9 ( & r , v ) return r . Error ( ) } 
func ( v Get Resource Tree Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Resource Tree Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Resource Tree Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Resource Tree Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 1 ( & r , v ) return r . Error ( ) } 
func ( v Get Resource Content Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Resource Content Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 2 ( & r , v ) return r . Error ( ) } 
func ( v Get Resource Content Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Resource Content Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 3 ( & r , v ) return r . Error ( ) } 
func ( v Get Navigation History Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Navigation History Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 4 ( & r , v ) return r . Error ( ) } 
func ( v Get Navigation History Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Navigation History Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 5 ( & r , v ) return r . Error ( ) } 
func ( v Get Layout Metrics Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Layout Metrics Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 6 ( & r , v ) return r . Error ( ) } 
func ( v Get Layout Metrics Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Layout Metrics Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 7 ( & r , v ) return r . Error ( ) } 
func ( v Get Installability Errors Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Installability Errors Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 8 ( & r , v ) return r . Error ( ) } 
func ( v Get Installability Errors Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 3 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Installability Errors Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 3 9 ( & r , v ) return r . Error ( ) } 
func ( v Get Frame Tree Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Frame Tree Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 0 ( & r , v ) return r . Error ( ) } 
func ( v Get Frame Tree Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get Frame Tree Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 1 ( & r , v ) return r . Error ( ) } 
func ( v Get App Manifest Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get App Manifest Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 2 ( & r , v ) return r . Error ( ) } 
func ( v Get App Manifest Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Get App Manifest Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 3 ( & r , v ) return r . Error ( ) } 
func ( v Generate Test Report Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Generate Test Report Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 4 ( & r , v ) return r . Error ( ) } 
func ( v Frame Tree ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Frame Tree ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 5 ( & r , v ) return r . Error ( ) } 
func ( v Frame Resource Tree ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Frame Resource Tree ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 6 ( & r , v ) return r . Error ( ) } 
func ( v Frame Resource ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Frame Resource ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 7 ( & r , v ) return r . Error ( ) } 
func ( v Font Sizes ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Font Sizes ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 8 ( & r , v ) return r . Error ( ) } 
func ( v Font Families ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 4 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Font Families ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 4 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Window Open ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Window Open ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Screencast Visibility Changed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Screencast Visibility Changed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Screencast Frame ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Screencast Frame ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Navigated Within Document ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Navigated Within Document ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Load Event Fired ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Load Event Fired ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Lifecycle Event ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Lifecycle Event ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Javascript Dialog Opening ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Javascript Dialog Opening ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Javascript Dialog Closed ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Javascript Dialog Closed ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Interstitial Shown ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Interstitial Shown ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Interstitial Hidden ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 5 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Interstitial Hidden ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 5 9 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Stopped Loading ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Stopped Loading ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 0 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Started Loading ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Started Loading ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 1 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Resized ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Resized ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 2 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Requested Navigation ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Requested Navigation ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 3 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Navigated ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 4 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Navigated ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 4 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Detached ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Detached ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 5 ( & r , v ) return r . Error ( ) } 
func ( v Event Frame Attached ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Frame Attached ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 6 ( & r , v ) return r . Error ( ) } 
func ( v Event Download Will Begin ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Download Will Begin ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 7 ( & r , v ) return r . Error ( ) } 
func ( v Event Dom Content Event Fired ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Dom Content Event Fired ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 8 ( & r , v ) return r . Error ( ) } 
func ( v Event Compilation Cache Produced ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 6 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Event Compilation Cache Produced ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 6 9 ( & r , v ) return r . Error ( ) } 
func ( v Create Isolated World Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Isolated World Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 2 ( & r , v ) return r . Error ( ) } 
func ( v Create Isolated World Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 3 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Create Isolated World Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 3 ( & r , v ) return r . Error ( ) } 
func ( v Close Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 5 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Clear Compilation Cache Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 6 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Clear Compilation Cache Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 6 ( & r , v ) return r . Error ( ) } 
func ( v Capture Snapshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 7 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v Capture Snapshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 8 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Capture Snapshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 8 ( & r , v ) return r . Error ( ) } 
func ( v Capture Screenshot Returns ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 7 9 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Capture Screenshot Returns ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 7 9 ( & r , v ) return r . Error ( ) } 
func ( v Capture Screenshot Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 8 0 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Capture Screenshot Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 8 0 ( & r , v ) return r . Error ( ) } 
func ( v Bring To Front Params ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 8 1 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * Bring To Front Params ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 8 1 ( & r , v ) return r . Error ( ) } 
func ( v App Manifest Error ) Marshal JSON ( ) ( [ ] byte , error ) { w : = jwriter . Writer { } easyjson C 5a 4 5 5 9b Encode Github Com Chromedp Cdproto Page 8 2 ( & w , v ) return w . Buffer . Build Bytes ( ) , w . Error } 
func ( v * App Manifest Error ) Unmarshal JSON ( data [ ] byte ) error { r : = jlexer . Lexer { Data : data } easyjson C 5a 4 5 5 9b Decode Github Com Chromedp Cdproto Page 8 2 ( & r , v ) return r . Error ( ) } 
